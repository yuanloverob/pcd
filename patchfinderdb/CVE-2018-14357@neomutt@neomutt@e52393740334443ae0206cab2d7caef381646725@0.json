{
  "cve_id": "CVE-2018-14357",
  "cve_desc": "An issue was discovered in Mutt before 1.10.1 and NeoMutt before 2018-07-16. They allow remote IMAP servers to execute arbitrary commands via backquote characters, related to the mailboxes command associated with an automatic subscription.",
  "repo": "neomutt/neomutt",
  "patch_hash": "e52393740334443ae0206cab2d7caef381646725",
  "patch_info": {
    "commit_hash": "e52393740334443ae0206cab2d7caef381646725",
    "repo": "neomutt/neomutt",
    "commit_url": "https://github.com/neomutt/neomutt/commit/e52393740334443ae0206cab2d7caef381646725",
    "files": [
      "imap/auth_login.c",
      "imap/command.c",
      "imap/imap.c",
      "imap/imap_private.h",
      "imap/util.c"
    ],
    "message": "quote imap strings more carefully\n\nCo-authored-by: JerikoOne <jeriko.one@gmx.us>",
    "before_after_code_files": [
      "imap/auth_login.c||imap/auth_login.c",
      "imap/command.c||imap/command.c",
      "imap/imap.c||imap/imap.c",
      "imap/imap_private.h||imap/imap_private.h",
      "imap/util.c||imap/util.c"
    ]
  },
  "patch_diff": {
    "imap/auth_login.c||imap/auth_login.c": [
      "File: imap/auth_login.c -> imap/auth_login.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "66:   mutt_message(_(\"Logging in...\"));",
      "",
      "[Removed Lines]",
      "68:   imap_quote_string(q_user, sizeof(q_user), idata->conn->account.user);",
      "69:   imap_quote_string(q_pass, sizeof(q_pass), idata->conn->account.pass);",
      "",
      "[Added Lines]",
      "68:   imap_quote_string(q_user, sizeof(q_user), idata->conn->account.user, false);",
      "69:   imap_quote_string(q_pass, sizeof(q_pass), idata->conn->account.pass, false);",
      "",
      "---------------"
    ],
    "imap/command.c||imap/command.c": [
      "File: imap/command.c -> imap/command.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "499:   mutt_str_strfcpy(buf, \"mailboxes \\\"\", sizeof(buf));",
      "500:   mutt_account_tourl(&idata->conn->account, &url);",
      "503:   url.path = errstr + 1;",
      "504:   url.path[strlen(url.path) - 1] = '\\0';",
      "505:   if (mutt_str_strcmp(url.user, ImapUser) == 0)",
      "",
      "[Removed Lines]",
      "502:   imap_quote_string(errstr, sizeof(errstr), list.name);",
      "",
      "[Added Lines]",
      "502:   imap_quote_string(errstr, sizeof(errstr), list.name, true);",
      "",
      "---------------"
    ],
    "imap/imap.c||imap/imap.c": [
      "File: imap/imap.c -> imap/imap.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "464:           return -1;",
      "465:         }",
      "468:         mutt_buffer_addstr(buf, term);",
      "469:         mutt_buffer_addch(buf, ' ');",
      "",
      "[Removed Lines]",
      "467:         imap_quote_string(term, sizeof(term), pat->p.str);",
      "",
      "[Added Lines]",
      "467:         imap_quote_string(term, sizeof(term), pat->p.str, false);",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "473:         delim++;",
      "474:         SKIPWS(delim);",
      "476:         mutt_buffer_addstr(buf, term);",
      "477:         break;",
      "478:       case MUTT_BODY:",
      "479:         mutt_buffer_addstr(buf, \"BODY \");",
      "481:         mutt_buffer_addstr(buf, term);",
      "482:         break;",
      "483:       case MUTT_WHOLE_MSG:",
      "484:         mutt_buffer_addstr(buf, \"TEXT \");",
      "486:         mutt_buffer_addstr(buf, term);",
      "487:         break;",
      "488:       case MUTT_SERVERSEARCH:",
      "",
      "[Removed Lines]",
      "475:         imap_quote_string(term, sizeof(term), delim);",
      "480:         imap_quote_string(term, sizeof(term), pat->p.str);",
      "485:         imap_quote_string(term, sizeof(term), pat->p.str);",
      "",
      "[Added Lines]",
      "475:         imap_quote_string(term, sizeof(term), delim, false);",
      "480:         imap_quote_string(term, sizeof(term), pat->p.str, false);",
      "485:         imap_quote_string(term, sizeof(term), pat->p.str, false);",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "495:         }",
      "496:       }",
      "497:         mutt_buffer_addstr(buf, \"X-GM-RAW \");",
      "499:         mutt_buffer_addstr(buf, term);",
      "500:         break;",
      "501:     }",
      "",
      "[Removed Lines]",
      "498:         imap_quote_string(term, sizeof(term), pat->p.str);",
      "",
      "[Added Lines]",
      "498:         imap_quote_string(term, sizeof(term), pat->p.str, false);",
      "",
      "---------------"
    ],
    "imap/imap_private.h||imap/imap_private.h": [
      "File: imap/imap_private.h -> imap/imap_private.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "328: int imap_mxcmp(const char *mx1, const char *mx2);",
      "329: char *imap_next_word(char *s);",
      "330: void imap_qualify_path(char *dest, size_t len, struct ImapMbox *mx, char *path);",
      "332: void imap_unquote_string(char *s);",
      "333: void imap_munge_mbox_name(struct ImapData *idata, char *dest, size_t dlen, const char *src);",
      "334: void imap_unmunge_mbox_name(struct ImapData *idata, char *s);",
      "",
      "[Removed Lines]",
      "331: void imap_quote_string(char *dest, size_t dlen, const char *src);",
      "",
      "[Added Lines]",
      "331: void imap_quote_string(char *dest, size_t dlen, const char *src, bool quote_backtick);",
      "",
      "---------------"
    ],
    "imap/util.c||imap/util.c": [
      "File: imap/util.c -> imap/util.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "802: {",
      "804:   char *pt = dest;",
      "805:   const char *s = src;",
      "",
      "[Removed Lines]",
      "801: void imap_quote_string(char *dest, size_t dlen, const char *src)",
      "803:   static const char quote[] = \"\\\"\\\\\";",
      "",
      "[Added Lines]",
      "801: void imap_quote_string(char *dest, size_t dlen, const char *src, bool quote_backtick)",
      "803:   const char *quote = \"`\\\"\\\\\";",
      "804:   if (!quote_backtick)",
      "805:     quote++;",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "874:   char *buf = mutt_str_strdup(src);",
      "875:   imap_utf_encode(idata, &buf);",
      "879:   FREE(&buf);",
      "880: }",
      "",
      "[Removed Lines]",
      "877:   imap_quote_string(dest, dlen, buf);",
      "",
      "[Added Lines]",
      "880:   imap_quote_string(dest, dlen, buf, false);",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "6edb2a71426f239dbbb0ab4bf118faf4af538b9a",
      "candidate_info": {
        "commit_hash": "6edb2a71426f239dbbb0ab4bf118faf4af538b9a",
        "repo": "neomutt/neomutt",
        "commit_url": "https://github.com/neomutt/neomutt/commit/6edb2a71426f239dbbb0ab4bf118faf4af538b9a",
        "files": [
          "context.h",
          "hook.c",
          "imap/imap.c",
          "imap/imap.h",
          "index.c",
          "menu.c",
          "mutt_curses.h",
          "pattern.c",
          "pattern.h",
          "score.c"
        ],
        "message": "pattern: change Pattern to use SLIST_* macros\n\nResolves #1224",
        "before_after_code_files": [
          "context.h||context.h",
          "hook.c||hook.c",
          "imap/imap.c||imap/imap.c",
          "imap/imap.h||imap/imap.h",
          "index.c||index.c",
          "menu.c||menu.c",
          "mutt_curses.h||mutt_curses.h",
          "pattern.c||pattern.c",
          "pattern.h||pattern.h",
          "score.c||score.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "imap/imap.c||imap/imap.c"
          ],
          "candidate": [
            "imap/imap.c||imap/imap.c"
          ]
        }
      },
      "candidate_diff": {
        "context.h||context.h": [
          "File: context.h -> context.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "28: #include <sys/types.h>",
          "29: #include <time.h>",
          "30: #include \"mailbox.h\"",
          "32: struct EmailList;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "31: #include \"pattern.h\"",
          "",
          "---------------"
        ],
        "hook.c||hook.c": [
          "File: hook.c -> hook.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "64: struct Hook",
          "65: {",
          "70:   TAILQ_ENTRY(Hook) entries;",
          "71: };",
          "72: static TAILQ_HEAD(, Hook) Hooks = TAILQ_HEAD_INITIALIZER(Hooks);",
          "",
          "[Removed Lines]",
          "66:   HookFlags type;          ///< Hook type",
          "67:   struct Regex regex;      ///< Regular expression",
          "68:   char *command;           ///< Filename, command or pattern to execute",
          "69:   struct Pattern *pattern; ///< Used for fcc,save,send-hook",
          "",
          "[Added Lines]",
          "66:   HookFlags type;              ///< Hook type",
          "67:   struct Regex regex;          ///< Regular expression",
          "68:   char *command;               ///< Filename, command or pattern to execute",
          "69:   struct PatternHead *pattern; ///< Used for fcc,save,send-hook",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "86:   int rc;",
          "87:   bool not = false, warning = false;",
          "88:   regex_t *rx = NULL;",
          "90:   char path[PATH_MAX];",
          "92:   mutt_buffer_init(&pattern);",
          "",
          "[Removed Lines]",
          "89:   struct Pattern *pat = NULL;",
          "",
          "[Added Lines]",
          "89:   struct PatternHead *pat = NULL;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "458:     if (hook->type & type)",
          "459:     {",
          "461:       {",
          "462:         if (mutt_parse_rc_line(hook->command, &token, &err) == MUTT_CMD_ERROR)",
          "463:         {",
          "",
          "[Removed Lines]",
          "460:       if ((mutt_pattern_exec(hook->pattern, 0, m, e, &cache) > 0) ^ hook->regex.not)",
          "",
          "[Added Lines]",
          "460:       if ((mutt_pattern_exec(SLIST_FIRST(hook->pattern), 0, m, e, &cache) > 0) ^",
          "461:           hook->regex.not)",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "505:     if (hook->type & type)",
          "506:     {",
          "507:       struct Mailbox *m = ctx ? ctx->mailbox : NULL;",
          "509:       {",
          "510:         mutt_make_string_flags(path, pathlen, hook->command, ctx, m, e, MUTT_FORMAT_PLAIN);",
          "511:         return 0;",
          "",
          "[Removed Lines]",
          "508:       if ((mutt_pattern_exec(hook->pattern, 0, m, e, &cache) > 0) ^ hook->regex.not)",
          "",
          "[Added Lines]",
          "509:       if ((mutt_pattern_exec(SLIST_FIRST(hook->pattern), 0, m, e, &cache) > 0) ^",
          "510:           hook->regex.not)",
          "",
          "---------------"
        ],
        "imap/imap.c||imap/imap.c": [
          "File: imap/imap.c -> imap/imap.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "48: #include \"commands.h\"",
          "49: #include \"curs_lib.h\"",
          "50: #include \"globals.h\"",
          "51: #include \"hook.h\"",
          "52: #include \"mailbox.h\"",
          "53: #include \"message.h\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "51: #include \"hcache/hcache.h\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "59: #include \"pattern.h\"",
          "60: #include \"progress.h\"",
          "61: #include \"sort.h\"",
          "63: #ifdef ENABLE_NLS",
          "64: #include <libintl.h>",
          "65: #endif",
          "",
          "[Removed Lines]",
          "62: #include \"hcache/hcache.h\"",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "342: {",
          "343:   int rc = 0;",
          "344:   const struct Pattern *pat = NULL;",
          "347:   {",
          "348:     switch (pat->op)",
          "349:     {",
          "",
          "[Removed Lines]",
          "341: static int do_search(const struct Pattern *search, int allpats)",
          "346:   for (pat = search; pat; pat = pat->next)",
          "",
          "[Added Lines]",
          "341: static int do_search(const struct PatternHead *search, int allpats)",
          "346:   SLIST_FOREACH(pat, search, entries)",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "384: {",
          "385:   if (do_search(pat, 0) == 0)",
          "386:     return 0;",
          "389:     mutt_buffer_addstr(buf, \"NOT \");",
          "392:   {",
          "393:     int clauses;",
          "396:     if (clauses > 0)",
          "397:     {",
          "400:       mutt_buffer_addch(buf, '(');",
          "402:       while (clauses)",
          "403:       {",
          "405:         {",
          "407:             mutt_buffer_addstr(buf, \"OR \");",
          "408:           clauses--;",
          "411:             return -1;",
          "413:           if (clauses)",
          "414:             mutt_buffer_addch(buf, ' ');",
          "415:         }",
          "417:       }",
          "419:       mutt_buffer_addch(buf, ')');",
          "",
          "[Removed Lines]",
          "383: static int compile_search(struct Mailbox *m, const struct Pattern *pat, struct Buffer *buf)",
          "388:   if (pat->not)",
          "391:   if (pat->child)",
          "395:     clauses = do_search(pat->child, 1);",
          "398:       const struct Pattern *clause = pat->child;",
          "404:         if (do_search(clause, 0))",
          "406:           if ((pat->op == MUTT_PAT_OR) && (clauses > 1))",
          "410:           if (compile_search(m, clause, buf) < 0)",
          "416:         clause = clause->next;",
          "",
          "[Added Lines]",
          "383: static int compile_search(struct Mailbox *m, const struct PatternHead *pat, struct Buffer *buf)",
          "385:   struct Pattern *firstpat = SLIST_FIRST(pat);",
          "390:   if (firstpat->not)",
          "393:   if (firstpat->child)",
          "397:     clauses = do_search(firstpat->child, 1);",
          "404:         if (do_search(firstpat->child, 0))",
          "406:           if ((firstpat->op == MUTT_PAT_OR) && (clauses > 1))",
          "410:           if (compile_search(m, firstpat->child, buf) < 0)",
          "417:         SLIST_REMOVE_HEAD(firstpat->child, entries);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "424:     char term[256];",
          "425:     char *delim = NULL;",
          "428:     {",
          "429:       case MUTT_PAT_HEADER:",
          "430:         mutt_buffer_addstr(buf, \"HEADER \");",
          "434:         if (!delim)",
          "435:         {",
          "437:           return -1;",
          "438:         }",
          "441:         mutt_buffer_addstr(buf, term);",
          "442:         mutt_buffer_addch(buf, ' ');",
          "",
          "[Removed Lines]",
          "427:     switch (pat->op)",
          "433:         delim = strchr(pat->p.str, ':');",
          "436:           mutt_error(_(\"Header search without header name: %s\"), pat->p.str);",
          "440:         imap_quote_string(term, sizeof(term), pat->p.str, false);",
          "",
          "[Added Lines]",
          "428:     switch (firstpat->op)",
          "434:         delim = strchr(firstpat->p.str, ':');",
          "437:           mutt_error(_(\"Header search without header name: %s\"), firstpat->p.str);",
          "441:         imap_quote_string(term, sizeof(term), firstpat->p.str, false);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "450:         break;",
          "451:       case MUTT_PAT_BODY:",
          "452:         mutt_buffer_addstr(buf, \"BODY \");",
          "454:         mutt_buffer_addstr(buf, term);",
          "455:         break;",
          "456:       case MUTT_PAT_WHOLE_MSG:",
          "457:         mutt_buffer_addstr(buf, \"TEXT \");",
          "459:         mutt_buffer_addstr(buf, term);",
          "460:         break;",
          "461:       case MUTT_PAT_SERVERSEARCH:",
          "",
          "[Removed Lines]",
          "453:         imap_quote_string(term, sizeof(term), pat->p.str, false);",
          "458:         imap_quote_string(term, sizeof(term), pat->p.str, false);",
          "",
          "[Added Lines]",
          "454:         imap_quote_string(term, sizeof(term), firstpat->p.str, false);",
          "459:         imap_quote_string(term, sizeof(term), firstpat->p.str, false);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "463:         struct ImapAccountData *adata = imap_adata_get(m);",
          "464:         if (!(adata->capabilities & IMAP_CAP_X_GM_EXT_1))",
          "465:         {",
          "467:           return -1;",
          "468:         }",
          "469:       }",
          "470:         mutt_buffer_addstr(buf, \"X-GM-RAW \");",
          "472:         mutt_buffer_addstr(buf, term);",
          "473:         break;",
          "474:     }",
          "",
          "[Removed Lines]",
          "466:           mutt_error(_(\"Server-side custom search not supported: %s\"), pat->p.str);",
          "471:         imap_quote_string(term, sizeof(term), pat->p.str, false);",
          "",
          "[Added Lines]",
          "467:           mutt_error(_(\"Server-side custom search not supported: %s\"),",
          "468:                      firstpat->p.str);",
          "473:         imap_quote_string(term, sizeof(term), firstpat->p.str, false);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "1360: {",
          "1361:   struct Buffer buf;",
          "1362:   struct ImapAccountData *adata = imap_adata_get(m);",
          "",
          "[Removed Lines]",
          "1359: int imap_search(struct Mailbox *m, const struct Pattern *pat)",
          "",
          "[Added Lines]",
          "1361: int imap_search(struct Mailbox *m, const struct PatternHead *pat)",
          "",
          "---------------"
        ],
        "imap/imap.h||imap/imap.h": [
          "File: imap/imap.h -> imap/imap.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "59: struct Mailbox;",
          "60: struct Pattern;",
          "61: struct stat;",
          "64: extern char *C_ImapAuthenticators;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "62: struct PatternHead;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "83: int imap_sync_mailbox(struct Mailbox *m, bool expunge, bool close);",
          "84: int imap_path_status(const char *path, bool queue);",
          "85: int imap_mailbox_status(struct Mailbox *m, bool queue);",
          "87: int imap_subscribe(char *path, bool subscribe);",
          "88: int imap_complete(char *buf, size_t buflen, char *path);",
          "89: int imap_fast_trash(struct Mailbox *m, char *dest);",
          "",
          "[Removed Lines]",
          "86: int imap_search(struct Mailbox *m, const struct Pattern *pat);",
          "",
          "[Added Lines]",
          "87: int imap_search(struct Mailbox *m, const struct PatternHead *pat);",
          "",
          "---------------"
        ],
        "index.c||index.c": [
          "File: index.c -> index.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "458:       else",
          "459:         e = ctx->mailbox->emails[i];",
          "462:       {",
          "",
          "[Removed Lines]",
          "461:       if (mutt_pattern_exec(ctx->limit_pattern, MUTT_MATCH_FULL_ADDRESS, ctx->mailbox, e, NULL))",
          "",
          "[Added Lines]",
          "461:       if (mutt_pattern_exec(SLIST_FIRST(ctx->limit_pattern),",
          "462:                             MUTT_MATCH_FULL_ADDRESS, ctx->mailbox, e, NULL))",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "524:         ctx->vsize = 0;",
          "525:       }",
          "528:                             ctx->mailbox, ctx->mailbox->emails[i], NULL))",
          "529:       {",
          "530:         assert(ctx->mailbox->vcount < ctx->mailbox->msg_count);",
          "",
          "[Removed Lines]",
          "527:       if (mutt_pattern_exec(ctx->limit_pattern, MUTT_MATCH_FULL_ADDRESS,",
          "",
          "[Added Lines]",
          "528:       if (mutt_pattern_exec(SLIST_FIRST(ctx->limit_pattern), MUTT_MATCH_FULL_ADDRESS,",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "3620:   STAILQ_FOREACH(color, &ColorIndexList, entries)",
          "3621:   {",
          "3623:     {",
          "3624:       e->pair = color->pair;",
          "3625:       return;",
          "",
          "[Removed Lines]",
          "3622:     if (mutt_pattern_exec(color->color_pattern, MUTT_MATCH_FULL_ADDRESS, m, e, &cache))",
          "",
          "[Added Lines]",
          "3623:     if (mutt_pattern_exec(SLIST_FIRST(color->color_pattern),",
          "3624:                           MUTT_MATCH_FULL_ADDRESS, m, e, &cache))",
          "",
          "---------------"
        ],
        "menu.c||menu.c": [
          "File: menu.c -> menu.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "119:   STAILQ_FOREACH(np, color, entries)",
          "120:   {",
          "123:       return np->pair;",
          "124:   }",
          "",
          "[Removed Lines]",
          "121:     if (mutt_pattern_exec(np->color_pattern, MUTT_MATCH_FULL_ADDRESS,",
          "122:                           Context->mailbox, e, NULL))",
          "",
          "[Added Lines]",
          "121:     if (mutt_pattern_exec(SLIST_FIRST(np->color_pattern),",
          "122:                           MUTT_MATCH_FULL_ADDRESS, Context->mailbox, e, NULL))",
          "",
          "---------------"
        ],
        "mutt_curses.h||mutt_curses.h": [
          "File: mutt_curses.h -> mutt_curses.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "27: #include <regex.h>",
          "28: #include \"mutt/mutt.h\"",
          "30: #ifdef USE_SLANG_CURSES",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "29: #include \"pattern.h\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "180:   regex_t regex;",
          "182:   char *pattern;",
          "185:   uint32_t fg;",
          "186:   uint32_t bg;",
          "187:   int pair;",
          "",
          "[Removed Lines]",
          "183:   struct Pattern *color_pattern; /**< compiled pattern to speed up index color",
          "",
          "[Added Lines]",
          "184:   struct PatternHead *color_pattern; /**< compiled pattern to speed up index color",
          "",
          "---------------"
        ],
        "pattern.c||pattern.c": [
          "File: pattern.c -> pattern.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1335: {",
          "1336:   if (!pat || !*pat)",
          "1337:     return;",
          "1342:   {",
          "1353:     {",
          "1356:     }",
          "1360:   }",
          "1361: }",
          "1368: {",
          "1370: }",
          "",
          "[Removed Lines]",
          "1334: void mutt_pattern_free(struct Pattern **pat)",
          "1339:   struct Pattern *tmp = NULL;",
          "1341:   while (*pat)",
          "1343:     tmp = *pat;",
          "1346:     if (tmp->ismulti)",
          "1347:       mutt_list_free(&tmp->p.multi_cases);",
          "1348:     else if (tmp->stringmatch)",
          "1349:       FREE(&tmp->p.str);",
          "1350:     else if (tmp->groupmatch)",
          "1351:       tmp->p.group = NULL;",
          "1352:     else if (tmp->p.regex)",
          "1354:       regfree(tmp->p.regex);",
          "1355:       FREE(&tmp->p.regex);",
          "1358:     mutt_pattern_free(&tmp->child);",
          "1359:     FREE(&tmp);",
          "1367: struct Pattern *mutt_pattern_new(void)",
          "1369:   return mutt_mem_calloc(1, sizeof(struct Pattern));",
          "",
          "[Added Lines]",
          "1334: void mutt_pattern_free(struct PatternHead **pat)",
          "1339:   struct Pattern *np = SLIST_FIRST(*pat), *next = NULL;",
          "1341:   while (np)",
          "1343:     next = SLIST_NEXT(np, entries);",
          "1345:     if (np->ismulti)",
          "1346:       mutt_list_free(&np->p.multi_cases);",
          "1347:     else if (np->stringmatch)",
          "1348:       FREE(&np->p.str);",
          "1349:     else if (np->groupmatch)",
          "1350:       np->p.group = NULL;",
          "1351:     else if (np->p.regex)",
          "1353:       regfree(np->p.regex);",
          "1354:       FREE(&np->p.regex);",
          "1357:     mutt_pattern_free(&np->child);",
          "1358:     FREE(&np);",
          "1360:     np = next;",
          "1363:   FREE(pat);",
          "1370: static struct PatternHead *mutt_pattern_node_new(void)",
          "1372:   struct PatternHead *h = mutt_mem_calloc(1, sizeof(struct PatternHead));",
          "1373:   SLIST_INIT(h);",
          "1374:   struct Pattern *p = mutt_mem_calloc(1, sizeof(struct Pattern));",
          "1375:   SLIST_INSERT_HEAD(h, p, entries);",
          "1376:   return h;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1380: {",
          "1384:   bool not = false;",
          "1385:   bool alladdr = false;",
          "1386:   bool or = false;",
          "",
          "[Removed Lines]",
          "1379: struct Pattern *mutt_pattern_comp(/* const */ char *s, int flags, struct Buffer *err)",
          "1381:   struct Pattern *curlist = NULL;",
          "1382:   struct Pattern *tmp = NULL, *tmp2 = NULL;",
          "1383:   struct Pattern *last = NULL;",
          "",
          "[Added Lines]",
          "1386: struct PatternHead *mutt_pattern_comp(/* const */ char *s, int flags, struct Buffer *err)",
          "1390:   struct PatternHead *curlist = NULL;",
          "1391:   struct PatternHead *tmp = NULL, *tmp2 = NULL;",
          "1392:   struct PatternHead *last = NULL;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1421:             mutt_buffer_printf(err, _(\"error in pattern at: %s\"), ps.dptr);",
          "1422:             return NULL;",
          "1423:           }",
          "1425:           {",
          "1431:             curlist = tmp;",
          "1432:             last = curlist;",
          "",
          "[Removed Lines]",
          "1424:           if (curlist->next)",
          "1427:             tmp = mutt_pattern_new();",
          "1428:             tmp->op = MUTT_PAT_AND;",
          "1429:             tmp->child = curlist;",
          "",
          "[Added Lines]",
          "1434:           struct Pattern *pat = SLIST_FIRST(curlist);",
          "1436:           if (SLIST_NEXT(pat, entries))",
          "1439:             tmp = mutt_pattern_node_new();",
          "1440:             pat = SLIST_FIRST(tmp);",
          "1441:             pat->op = MUTT_PAT_AND;",
          "1442:             pat->child = curlist;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1443:       case '%':",
          "1444:       case '=':",
          "1445:       case '~':",
          "1446:         if (!*(ps.dptr + 1))",
          "1447:         {",
          "1448:           mutt_buffer_printf(err, _(\"missing pattern: %s\"), ps.dptr);",
          "1451:         }",
          "1452:         thread_op = 0;",
          "1453:         if (*(ps.dptr + 1) == '(')",
          "",
          "[Removed Lines]",
          "1449:           mutt_pattern_free(&curlist);",
          "1450:           return NULL;",
          "",
          "[Added Lines]",
          "1459:       {",
          "1460:         struct Pattern *pat = NULL;",
          "1464:           goto cleanup;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1465:           if (*p != ')')",
          "1466:           {",
          "1467:             mutt_buffer_printf(err, _(\"mismatched brackets: %s\"), ps.dptr);",
          "1470:           }",
          "1473:           if (last)",
          "1475:           else",
          "1476:             curlist = tmp;",
          "1477:           last = tmp;",
          "1481:           not = false;",
          "1482:           alladdr = false;",
          "1483:           isalias = false;",
          "",
          "[Removed Lines]",
          "1468:             mutt_pattern_free(&curlist);",
          "1469:             return NULL;",
          "1471:           tmp = mutt_pattern_new();",
          "1472:           tmp->op = thread_op;",
          "1474:             last->next = tmp;",
          "1478:           tmp->not ^= not;",
          "1479:           tmp->alladdr |= alladdr;",
          "1480:           tmp->isalias |= isalias;",
          "",
          "[Added Lines]",
          "1482:             goto cleanup;",
          "1484:           tmp = mutt_pattern_node_new();",
          "1485:           pat = SLIST_FIRST(tmp);",
          "1486:           pat->op = thread_op;",
          "1488:             SLIST_NEXT(SLIST_FIRST(last), entries) = pat;",
          "1492:           pat->not ^= not;",
          "1493:           pat->alladdr |= alladdr;",
          "1494:           pat->isalias |= isalias;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1487:           if (!tmp2)",
          "1488:           {",
          "1489:             FREE(&buf);",
          "1492:           }",
          "1493:           FREE(&buf);",
          "1496:           break;",
          "1497:         }",
          "1498:         if (implicit && or)",
          "1499:         {",
          "1504:           curlist = tmp;",
          "1505:           last = tmp;",
          "1506:           or = false;",
          "1507:         }",
          "1515:         not = false;",
          "1516:         alladdr = false;",
          "1517:         isalias = false;",
          "1519:         if (last)",
          "1521:         else",
          "1522:           curlist = tmp;",
          "1523:         last = tmp;",
          "",
          "[Removed Lines]",
          "1490:             mutt_pattern_free(&curlist);",
          "1491:             return NULL;",
          "1494:           tmp->child = tmp2;",
          "1501:           tmp = mutt_pattern_new();",
          "1502:           tmp->op = MUTT_PAT_OR;",
          "1503:           tmp->child = curlist;",
          "1509:         tmp = mutt_pattern_new();",
          "1510:         tmp->not = not;",
          "1511:         tmp->alladdr = alladdr;",
          "1512:         tmp->isalias = isalias;",
          "1513:         tmp->stringmatch = (*ps.dptr == '=');",
          "1514:         tmp->groupmatch = (*ps.dptr == '%');",
          "1520:           last->next = tmp;",
          "",
          "[Added Lines]",
          "1504:             goto cleanup;",
          "1507:           pat->child = tmp2;",
          "1514:           tmp = mutt_pattern_node_new();",
          "1515:           pat = SLIST_FIRST(tmp);",
          "1516:           pat->op = MUTT_PAT_OR;",
          "1517:           pat->child = curlist;",
          "1523:         tmp = mutt_pattern_node_new();",
          "1524:         pat = SLIST_FIRST(tmp);",
          "1525:         pat->not = not;",
          "1526:         pat->alladdr = alladdr;",
          "1527:         pat->isalias = isalias;",
          "1528:         pat->stringmatch = (*ps.dptr == '=');",
          "1529:         pat->groupmatch = (*ps.dptr == '%');",
          "1535:           SLIST_NEXT(SLIST_FIRST(last), entries) = pat;",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "1527:         if (!entry)",
          "1528:         {",
          "1529:           mutt_buffer_printf(err, _(\"%c: invalid pattern modifier\"), *ps.dptr);",
          "1532:         }",
          "1533:         if (entry->class && ((flags & entry->class) == 0))",
          "1534:         {",
          "1535:           mutt_buffer_printf(err, _(\"%c: not supported in this mode\"), *ps.dptr);",
          "1538:         }",
          "1542:         SKIPWS(ps.dptr);",
          "",
          "[Removed Lines]",
          "1530:           mutt_pattern_free(&curlist);",
          "1531:           return NULL;",
          "1536:           mutt_pattern_free(&curlist);",
          "1537:           return NULL;",
          "1539:         tmp->op = entry->op;",
          "",
          "[Added Lines]",
          "1545:           goto cleanup;",
          "1550:           goto cleanup;",
          "1552:         pat->op = entry->op;",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "1546:           if (!*ps.dptr)",
          "1547:           {",
          "1548:             mutt_buffer_printf(err, \"%s\", _(\"missing parameter\"));",
          "1551:           }",
          "1553:           {",
          "1556:           }",
          "1557:         }",
          "1558:         implicit = true;",
          "1559:         break;",
          "1560:       case '(':",
          "1561:         p = find_matching_paren(ps.dptr + 1);",
          "1562:         if (*p != ')')",
          "1563:         {",
          "1564:           mutt_buffer_printf(err, _(\"mismatched parenthesis: %s\"), ps.dptr);",
          "1567:         }",
          "1569:         buf = mutt_str_substr_dup(ps.dptr + 1, p);",
          "1570:         tmp = mutt_pattern_comp(buf, flags, err);",
          "1577:         FREE(&buf);",
          "1578:         if (last)",
          "1580:         else",
          "1581:           curlist = tmp;",
          "1582:         last = tmp;",
          "1586:         not = false;",
          "1587:         alladdr = false;",
          "1588:         isalias = false;",
          "1590:         break;",
          "1591:       default:",
          "1592:         mutt_buffer_printf(err, _(\"error in pattern at: %s\"), ps.dptr);",
          "1595:     }",
          "1596:   }",
          "1597:   if (!curlist)",
          "",
          "[Removed Lines]",
          "1549:             mutt_pattern_free(&curlist);",
          "1550:             return NULL;",
          "1552:           if (!entry->eat_arg(tmp, &ps, err))",
          "1554:             mutt_pattern_free(&curlist);",
          "1555:             return NULL;",
          "1565:           mutt_pattern_free(&curlist);",
          "1566:           return NULL;",
          "1571:         if (!tmp)",
          "1572:         {",
          "1573:           FREE(&buf);",
          "1574:           mutt_pattern_free(&curlist);",
          "1575:           return NULL;",
          "1576:         }",
          "1579:           last->next = tmp;",
          "1583:         tmp->not ^= not;",
          "1584:         tmp->alladdr |= alladdr;",
          "1585:         tmp->isalias |= isalias;",
          "1593:         mutt_pattern_free(&curlist);",
          "1594:         return NULL;",
          "",
          "[Added Lines]",
          "1562:             goto cleanup;",
          "1564:           if (!entry->eat_arg(pat, &ps, err))",
          "1566:             goto cleanup;",
          "1571:       }",
          "1574:       {",
          "1579:           goto cleanup;",
          "1585:         if (!tmp)",
          "1586:           goto cleanup;",
          "1587:         struct Pattern *pat = SLIST_FIRST(tmp);",
          "1589:           SLIST_NEXT(SLIST_FIRST(last), entries) = pat;",
          "1593:         pat = SLIST_FIRST(tmp);",
          "1594:         pat->not ^= not;",
          "1595:         pat->alladdr |= alladdr;",
          "1596:         pat->isalias |= isalias;",
          "1602:       }",
          "1606:         goto cleanup;",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "1599:     mutt_buffer_strcpy(err, _(\"empty pattern\"));",
          "1600:     return NULL;",
          "1601:   }",
          "1603:   {",
          "1607:     curlist = tmp;",
          "1608:   }",
          "1609:   return curlist;",
          "1610: }",
          "",
          "[Removed Lines]",
          "1602:   if (curlist->next)",
          "1604:     tmp = mutt_pattern_new();",
          "1605:     tmp->op = or ? MUTT_PAT_OR : MUTT_PAT_AND;",
          "1606:     tmp->child = curlist;",
          "",
          "[Added Lines]",
          "1614:   if (SLIST_NEXT(SLIST_FIRST(curlist), entries))",
          "1616:     tmp = mutt_pattern_node_new();",
          "1617:     struct Pattern *pat = SLIST_FIRST(tmp);",
          "1618:     pat->op = or ? MUTT_PAT_OR : MUTT_PAT_AND;",
          "1619:     pat->child = curlist;",
          "1625: cleanup:",
          "1626:   mutt_pattern_free(&curlist);",
          "1627:   return NULL;",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "1622:                         struct Mailbox *m, struct Email *e, struct PatternCache *cache)",
          "1623: {",
          "1626:       return false;",
          "1627:   return true;",
          "1628: }",
          "",
          "[Removed Lines]",
          "1621: static bool perform_and(struct Pattern *pat, enum PatternExecFlag flags,",
          "1624:   for (; pat; pat = pat->next)",
          "1625:     if (mutt_pattern_exec(pat, flags, m, e, cache) <= 0)",
          "",
          "[Added Lines]",
          "1639: static bool perform_and(struct PatternHead *pat, enum PatternExecFlag flags,",
          "1642:   struct Pattern *p = NULL;",
          "1644:   SLIST_FOREACH(p, pat, entries)",
          "1645:   {",
          "1646:     if (mutt_pattern_exec(p, flags, m, e, cache) <= 0)",
          "1648:   }",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "1640:                       struct Mailbox *m, struct Email *e, struct PatternCache *cache)",
          "1641: {",
          "1644:       return true;",
          "1645:   return false;",
          "1646: }",
          "",
          "[Removed Lines]",
          "1639: static int perform_or(struct Pattern *pat, enum PatternExecFlag flags,",
          "1642:   for (; pat; pat = pat->next)",
          "1643:     if (mutt_pattern_exec(pat, flags, m, e, cache) > 0)",
          "",
          "[Added Lines]",
          "1661: static int perform_or(struct PatternHead *pat, enum PatternExecFlag flags,",
          "1664:   struct Pattern *p = NULL;",
          "1666:   SLIST_FOREACH(p, pat, entries)",
          "1667:   {",
          "1668:     if (mutt_pattern_exec(p, flags, m, e, cache) > 0)",
          "1670:   }",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "1770:                                 struct Mailbox *m, struct MuttThread *t,",
          "1771:                                 int left, int up, int right, int down)",
          "1772: {",
          "",
          "[Removed Lines]",
          "1769: static int match_threadcomplete(struct Pattern *pat, enum PatternExecFlag flags,",
          "",
          "[Added Lines]",
          "1795: static int match_threadcomplete(struct PatternHead *pat, enum PatternExecFlag flags,",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "1777:     return 0;",
          "1778:   e = t->message;",
          "1779:   if (e)",
          "1781:       return 1;",
          "1783:   if (up && (a = match_threadcomplete(pat, flags, m, t->parent, 1, 1, 1, 0)))",
          "",
          "[Removed Lines]",
          "1780:     if (mutt_pattern_exec(pat, flags, m, e, NULL))",
          "",
          "[Added Lines]",
          "1806:     if (mutt_pattern_exec(SLIST_FIRST(pat), flags, m, e, NULL))",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "1809:                               struct Mailbox *m, struct MuttThread *t)",
          "1810: {",
          "1811:   if (!t || !t->parent || !t->parent->message)",
          "1812:     return 0;",
          "1815: }",
          "",
          "[Removed Lines]",
          "1808: static int match_threadparent(struct Pattern *pat, enum PatternExecFlag flags,",
          "1814:   return mutt_pattern_exec(pat, flags, m, t->parent->message, NULL);",
          "",
          "[Added Lines]",
          "1834: static int match_threadparent(struct PatternHead *pat, enum PatternExecFlag flags,",
          "1840:   return mutt_pattern_exec(SLIST_FIRST(pat), flags, m, t->parent->message, NULL);",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "1828:                                 struct Mailbox *m, struct MuttThread *t)",
          "1829: {",
          "1830:   if (!t || !t->child)",
          "1831:     return 0;",
          "1833:   for (t = t->child; t; t = t->next)",
          "1835:       return 1;",
          "1837:   return 0;",
          "",
          "[Removed Lines]",
          "1827: static int match_threadchildren(struct Pattern *pat, enum PatternExecFlag flags,",
          "1834:     if (t->message && mutt_pattern_exec(pat, flags, m, t->message, NULL))",
          "",
          "[Added Lines]",
          "1853: static int match_threadchildren(struct PatternHead *pat, enum PatternExecFlag flags,",
          "1860:     if (t->message && mutt_pattern_exec(SLIST_FIRST(pat), flags, m, t->message, NULL))",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "2328: int mutt_pattern_func(int op, char *prompt)",
          "2329: {",
          "2331:   char buf[1024] = \"\", *simple = NULL;",
          "2332:   struct Buffer err;",
          "2333:   int rc = -1, padding;",
          "",
          "[Removed Lines]",
          "2330:   struct Pattern *pat = NULL;",
          "",
          "[Added Lines]",
          "2356:   struct PatternHead *pat = NULL;",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "2379:       Context->mailbox->emails[i]->limited = false;",
          "2380:       Context->mailbox->emails[i]->collapsed = false;",
          "2381:       Context->mailbox->emails[i]->num_hidden = 0;",
          "2384:       {",
          "2385:         Context->mailbox->emails[i]->virtual = Context->mailbox->vcount;",
          "2386:         Context->mailbox->emails[i]->limited = true;",
          "",
          "[Removed Lines]",
          "2382:       if (mutt_pattern_exec(pat, MUTT_MATCH_FULL_ADDRESS, Context->mailbox,",
          "2383:                             Context->mailbox->emails[i], NULL))",
          "",
          "[Added Lines]",
          "2408:       if (mutt_pattern_exec(SLIST_FIRST(pat), MUTT_MATCH_FULL_ADDRESS,",
          "2409:                             Context->mailbox, Context->mailbox->emails[i], NULL))",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "2396:     for (int i = 0; i < Context->mailbox->vcount; i++)",
          "2397:     {",
          "2398:       mutt_progress_update(&progress, i, -1);",
          "2400:                             Context->mailbox->emails[Context->mailbox->v2r[i]], NULL))",
          "2401:       {",
          "2402:         switch (op)",
          "",
          "[Removed Lines]",
          "2399:       if (mutt_pattern_exec(pat, MUTT_MATCH_FULL_ADDRESS, Context->mailbox,",
          "",
          "[Added Lines]",
          "2425:       if (mutt_pattern_exec(SLIST_FIRST(pat), MUTT_MATCH_FULL_ADDRESS, Context->mailbox,",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "2575:     {",
          "2577:       e->searched = true;",
          "2579:                                      Context->mailbox, e, NULL);",
          "2580:       if (e->matched > 0)",
          "2581:       {",
          "",
          "[Removed Lines]",
          "2578:       e->matched = mutt_pattern_exec(SearchPattern, MUTT_MATCH_FULL_ADDRESS,",
          "",
          "[Added Lines]",
          "2604:       e->matched = mutt_pattern_exec(SLIST_FIRST(SearchPattern), MUTT_MATCH_FULL_ADDRESS,",
          "",
          "---------------"
        ],
        "pattern.h||pattern.h": [
          "File: pattern.h -> pattern.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "42: SLIST_HEAD(PatternHead, Pattern);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "55:   int min;",
          "56:   int max;",
          "59:   union {",
          "60:     regex_t *regex;",
          "61:     struct Group *group;",
          "",
          "[Removed Lines]",
          "57:   struct Pattern *next;",
          "",
          "[Added Lines]",
          "59:   SLIST_ENTRY(Pattern) entries;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "149:   MUTT_PAT_MAX,",
          "150: };",
          "153: int mutt_pattern_exec(struct Pattern *pat, enum PatternExecFlag flags,",
          "154:                       struct Mailbox *m, struct Email *e, struct PatternCache *cache);",
          "156: void mutt_check_simple(char *s, size_t len, const char *simple);",
          "159: int mutt_which_case(const char *s);",
          "160: int mutt_is_list_recipient(bool alladdr, struct Address *a1, struct Address *a2);",
          "",
          "[Removed Lines]",
          "152: struct Pattern *mutt_pattern_new(void);",
          "155: struct Pattern *mutt_pattern_comp(/* const */ char *s, int flags, struct Buffer *err);",
          "157: void mutt_pattern_free(struct Pattern **pat);",
          "",
          "[Added Lines]",
          "155: struct PatternHead *mutt_pattern_comp(/* const */ char *s, int flags, struct Buffer *err);",
          "157: void mutt_pattern_free(struct PatternHead **pat);",
          "",
          "---------------"
        ],
        "score.c||score.c": [
          "File: score.c -> score.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "56: struct Score",
          "57: {",
          "58:   char *str;",
          "60:   int val;",
          "62:   struct Score *next;",
          "",
          "[Removed Lines]",
          "59:   struct Pattern *pat;",
          "",
          "[Added Lines]",
          "59:   struct PatternHead *pat;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "100: {",
          "101:   struct Score *ptr = NULL, *last = NULL;",
          "102:   char *pattern = NULL, *pc = NULL;",
          "105:   mutt_extract_token(buf, s, 0);",
          "106:   if (!MoreArgs(s))",
          "",
          "[Removed Lines]",
          "103:   struct Pattern *pat = NULL;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "125:       break;",
          "126:   if (!ptr)",
          "127:   {",
          "129:     if (!pat)",
          "130:     {",
          "131:       FREE(&pattern);",
          "",
          "[Removed Lines]",
          "128:     pat = mutt_pattern_comp(pattern, 0, err);",
          "",
          "[Added Lines]",
          "127:     struct PatternHead *pat = mutt_pattern_comp(pattern, 0, err);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "177:   for (tmp = ScoreList; tmp; tmp = tmp->next)",
          "178:   {",
          "180:     {",
          "181:       if (tmp->exact || (tmp->val == 9999) || (tmp->val == -9999))",
          "182:       {",
          "",
          "[Removed Lines]",
          "179:     if (mutt_pattern_exec(tmp->pat, MUTT_MATCH_FULL_ADDRESS, NULL, e, &cache) > 0)",
          "",
          "[Added Lines]",
          "178:     if (mutt_pattern_exec(SLIST_FIRST(tmp->pat), MUTT_MATCH_FULL_ADDRESS, NULL, e, &cache) > 0)",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "a67009c07079c977f9628edbe61f899294e7ce1a",
      "candidate_info": {
        "commit_hash": "a67009c07079c977f9628edbe61f899294e7ce1a",
        "repo": "neomutt/neomutt",
        "commit_url": "https://github.com/neomutt/neomutt/commit/a67009c07079c977f9628edbe61f899294e7ce1a",
        "files": [
          "imap/auth.c",
          "imap/auth.h",
          "imap/auth_anon.c",
          "imap/auth_cram.c",
          "imap/auth_gss.c",
          "imap/auth_login.c",
          "imap/auth_oauth.c",
          "imap/auth_plain.c",
          "imap/auth_sasl.c",
          "imap/browse.c",
          "imap/command.c",
          "imap/imap.c",
          "imap/imap_private.h",
          "imap/message.c",
          "imap/utf7.c",
          "imap/util.c"
        ],
        "message": "ImapAccountData\n\nEven though it's attached to a Mailbox, this is Account data.",
        "before_after_code_files": [
          "imap/auth.c||imap/auth.c",
          "imap/auth.h||imap/auth.h",
          "imap/auth_anon.c||imap/auth_anon.c",
          "imap/auth_cram.c||imap/auth_cram.c",
          "imap/auth_gss.c||imap/auth_gss.c",
          "imap/auth_login.c||imap/auth_login.c",
          "imap/auth_oauth.c||imap/auth_oauth.c",
          "imap/auth_plain.c||imap/auth_plain.c",
          "imap/auth_sasl.c||imap/auth_sasl.c",
          "imap/browse.c||imap/browse.c",
          "imap/command.c||imap/command.c",
          "imap/imap.c||imap/imap.c",
          "imap/imap_private.h||imap/imap_private.h",
          "imap/message.c||imap/message.c",
          "imap/utf7.c||imap/utf7.c",
          "imap/util.c||imap/util.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "imap/auth_login.c||imap/auth_login.c",
            "imap/command.c||imap/command.c",
            "imap/imap.c||imap/imap.c",
            "imap/imap_private.h||imap/imap_private.h",
            "imap/util.c||imap/util.c"
          ],
          "candidate": [
            "imap/auth_login.c||imap/auth_login.c",
            "imap/command.c||imap/command.c",
            "imap/imap.c||imap/imap.c",
            "imap/imap_private.h||imap/imap_private.h",
            "imap/util.c||imap/util.c"
          ]
        }
      },
      "candidate_diff": {
        "imap/auth.c||imap/auth.c": [
          "File: imap/auth.c -> imap/auth.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "68: {",
          "69:   int r = IMAP_AUTH_FAILURE;",
          "",
          "[Removed Lines]",
          "67: int imap_authenticate(struct ImapMboxData *mdata)",
          "",
          "[Added Lines]",
          "67: int imap_authenticate(struct ImapAccountData *adata)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "91:         const struct ImapAuth *auth = &imap_authenticators[i];",
          "92:         if (!auth->method || (mutt_str_strcasecmp(auth->method, method) == 0))",
          "93:         {",
          "95:           if (r == IMAP_AUTH_SUCCESS)",
          "96:           {",
          "97:             FREE(&methods);",
          "",
          "[Removed Lines]",
          "94:           r = auth->authenticate(mdata, method);",
          "",
          "[Added Lines]",
          "94:           r = auth->authenticate(adata, method);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "111:     for (size_t i = 0; i < mutt_array_size(imap_authenticators); ++i)",
          "112:     {",
          "114:       if (r == IMAP_AUTH_SUCCESS)",
          "115:         return r;",
          "116:     }",
          "",
          "[Removed Lines]",
          "113:       r = imap_authenticators[i].authenticate(mdata, NULL);",
          "",
          "[Added Lines]",
          "113:       r = imap_authenticators[i].authenticate(adata, NULL);",
          "",
          "---------------"
        ],
        "imap/auth.h||imap/auth.h": [
          "File: imap/auth.h -> imap/auth.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "26: #ifndef MUTT_IMAP_AUTH_H",
          "27: #define MUTT_IMAP_AUTH_H",
          "",
          "[Removed Lines]",
          "29: struct ImapMboxData;",
          "",
          "[Added Lines]",
          "29: struct ImapAccountData;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "44: struct ImapAuth",
          "45: {",
          "50:   const char *method;",
          "51: };",
          "55: #ifndef USE_SASL",
          "58: #endif",
          "60: #ifdef USE_GSS",
          "62: #endif",
          "63: #ifdef USE_SASL",
          "65: #endif",
          "",
          "[Removed Lines]",
          "47:   enum ImapAuthRes (*authenticate)(struct ImapMboxData *mdata, const char *method);",
          "54: enum ImapAuthRes imap_auth_plain(struct ImapMboxData *mdata, const char *method);",
          "56: enum ImapAuthRes imap_auth_anon(struct ImapMboxData *mdata, const char *method);",
          "57: enum ImapAuthRes imap_auth_cram_md5(struct ImapMboxData *mdata, const char *method);",
          "59: enum ImapAuthRes imap_auth_login(struct ImapMboxData *mdata, const char *method);",
          "61: enum ImapAuthRes imap_auth_gss(struct ImapMboxData *mdata, const char *method);",
          "64: enum ImapAuthRes imap_auth_sasl(struct ImapMboxData *mdata, const char *method);",
          "66: enum ImapAuthRes imap_auth_oauth(struct ImapMboxData *mdata, const char *method);",
          "",
          "[Added Lines]",
          "47:   enum ImapAuthRes (*authenticate)(struct ImapAccountData *adata, const char *method);",
          "54: enum ImapAuthRes imap_auth_plain(struct ImapAccountData *adata, const char *method);",
          "56: enum ImapAuthRes imap_auth_anon(struct ImapAccountData *adata, const char *method);",
          "57: enum ImapAuthRes imap_auth_cram_md5(struct ImapAccountData *adata, const char *method);",
          "59: enum ImapAuthRes imap_auth_login(struct ImapAccountData *adata, const char *method);",
          "61: enum ImapAuthRes imap_auth_gss(struct ImapAccountData *adata, const char *method);",
          "64: enum ImapAuthRes imap_auth_sasl(struct ImapAccountData *adata, const char *method);",
          "66: enum ImapAuthRes imap_auth_oauth(struct ImapAccountData *adata, const char *method);",
          "",
          "---------------"
        ],
        "imap/auth_anon.c||imap/auth_anon.c": [
          "File: imap/auth_anon.c -> imap/auth_anon.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "46: {",
          "47:   int rc;",
          "50:     return IMAP_AUTH_UNAVAIL;",
          "53:     return IMAP_AUTH_FAILURE;",
          "56:     return IMAP_AUTH_UNAVAIL;",
          "58:   mutt_message(_(\"Authenticating (anonymous)...\"));",
          "62:   do",
          "64:   while (rc == IMAP_CMD_CONTINUE);",
          "66:   if (rc != IMAP_CMD_RESPOND)",
          "",
          "[Removed Lines]",
          "45: enum ImapAuthRes imap_auth_anon(struct ImapMboxData *mdata, const char *method)",
          "49:   if (!mutt_bit_isset(mdata->capabilities, AUTH_ANON))",
          "52:   if (mutt_account_getuser(&mdata->conn->account) < 0)",
          "55:   if (mdata->conn->account.user[0] != '\\0')",
          "60:   imap_cmd_start(mdata, \"AUTHENTICATE ANONYMOUS\");",
          "63:     rc = imap_cmd_step(mdata);",
          "",
          "[Added Lines]",
          "45: enum ImapAuthRes imap_auth_anon(struct ImapAccountData *adata, const char *method)",
          "49:   if (!mutt_bit_isset(adata->capabilities, AUTH_ANON))",
          "52:   if (mutt_account_getuser(&adata->conn->account) < 0)",
          "55:   if (adata->conn->account.user[0] != '\\0')",
          "60:   imap_cmd_start(adata, \"AUTHENTICATE ANONYMOUS\");",
          "63:     rc = imap_cmd_step(adata);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "69:     goto bail;",
          "70:   }",
          "74:   do",
          "76:   while (rc == IMAP_CMD_CONTINUE);",
          "78:   if (rc != IMAP_CMD_OK)",
          "",
          "[Removed Lines]",
          "75:     rc = imap_cmd_step(mdata);",
          "",
          "[Added Lines]",
          "75:     rc = imap_cmd_step(adata);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "81:     goto bail;",
          "82:   }",
          "85:     return IMAP_AUTH_SUCCESS;",
          "87: bail:",
          "",
          "[Removed Lines]",
          "84:   if (imap_code(mdata->buf))",
          "",
          "[Added Lines]",
          "84:   if (imap_code(adata->buf))",
          "",
          "---------------"
        ],
        "imap/auth_cram.c||imap/auth_cram.c": [
          "File: imap/auth_cram.c -> imap/auth_cram.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "99: {",
          "100:   char ibuf[LONG_STRING * 2], obuf[LONG_STRING];",
          "101:   unsigned char hmac_response[MD5_DIGEST_LEN];",
          "102:   int len;",
          "103:   int rc;",
          "106:     return IMAP_AUTH_UNAVAIL;",
          "108:   mutt_message(_(\"Authenticating (CRAM-MD5)...\"));",
          "112:     return IMAP_AUTH_FAILURE;",
          "114:     return IMAP_AUTH_FAILURE;",
          "",
          "[Removed Lines]",
          "98: enum ImapAuthRes imap_auth_cram_md5(struct ImapMboxData *mdata, const char *method)",
          "105:   if (!mutt_bit_isset(mdata->capabilities, ACRAM_MD5))",
          "111:   if (mutt_account_getlogin(&mdata->conn->account) < 0)",
          "113:   if (mutt_account_getpass(&mdata->conn->account) < 0)",
          "116:   imap_cmd_start(mdata, \"AUTHENTICATE CRAM-MD5\");",
          "",
          "[Added Lines]",
          "98: enum ImapAuthRes imap_auth_cram_md5(struct ImapAccountData *adata, const char *method)",
          "105:   if (!mutt_bit_isset(adata->capabilities, ACRAM_MD5))",
          "111:   if (mutt_account_getlogin(&adata->conn->account) < 0)",
          "113:   if (mutt_account_getpass(&adata->conn->account) < 0)",
          "116:   imap_cmd_start(adata, \"AUTHENTICATE CRAM-MD5\");",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "124:   do",
          "126:   while (rc == IMAP_CMD_CONTINUE);",
          "128:   if (rc != IMAP_CMD_RESPOND)",
          "",
          "[Removed Lines]",
          "125:     rc = imap_cmd_step(mdata);",
          "",
          "[Added Lines]",
          "125:     rc = imap_cmd_step(adata);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "131:     goto bail;",
          "132:   }",
          "135:   if (len == -1)",
          "136:   {",
          "137:     mutt_debug(1, \"Error decoding base64 response.\\n\");",
          "",
          "[Removed Lines]",
          "134:   len = mutt_b64_decode(mdata->buf + 2, obuf, sizeof(obuf));",
          "",
          "[Added Lines]",
          "134:   len = mutt_b64_decode(adata->buf + 2, obuf, sizeof(obuf));",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "158:   mutt_md5_toascii(hmac_response, obuf + off);",
          "159:   mutt_debug(2, \"CRAM response: %s\\n\", obuf);",
          "",
          "[Removed Lines]",
          "155:   hmac_md5(mdata->conn->account.pass, obuf, hmac_response);",
          "157:   int off = snprintf(obuf, sizeof(obuf), \"%s \", mdata->conn->account.user);",
          "",
          "[Added Lines]",
          "155:   hmac_md5(adata->conn->account.pass, obuf, hmac_response);",
          "157:   int off = snprintf(obuf, sizeof(obuf), \"%s \", adata->conn->account.user);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "163:   mutt_b64_encode(obuf, strlen(obuf), ibuf, sizeof(ibuf) - 2);",
          "164:   mutt_str_strcat(ibuf, sizeof(ibuf), \"\\r\\n\");",
          "167:   do",
          "169:   while (rc == IMAP_CMD_CONTINUE);",
          "171:   if (rc != IMAP_CMD_OK)",
          "",
          "[Removed Lines]",
          "165:   mutt_socket_send(mdata->conn, ibuf);",
          "168:     rc = imap_cmd_step(mdata);",
          "",
          "[Added Lines]",
          "165:   mutt_socket_send(adata->conn, ibuf);",
          "168:     rc = imap_cmd_step(adata);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "174:     goto bail;",
          "175:   }",
          "178:     return IMAP_AUTH_SUCCESS;",
          "180: bail:",
          "",
          "[Removed Lines]",
          "177:   if (imap_code(mdata->buf))",
          "",
          "[Added Lines]",
          "177:   if (imap_code(adata->buf))",
          "",
          "---------------"
        ],
        "imap/auth_gss.c||imap/auth_gss.c": [
          "File: imap/auth_gss.c -> imap/auth_gss.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "110: {",
          "111:   gss_buffer_desc request_buf, send_token;",
          "112:   gss_buffer_t sec_token;",
          "",
          "[Removed Lines]",
          "109: enum ImapAuthRes imap_auth_gss(struct ImapMboxData *mdata, const char *method)",
          "",
          "[Added Lines]",
          "109: enum ImapAuthRes imap_auth_gss(struct ImapAccountData *adata, const char *method)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "121:   unsigned long buf_size;",
          "122:   int rc;",
          "125:     return IMAP_AUTH_UNAVAIL;",
          "128:     return IMAP_AUTH_FAILURE;",
          "132:   request_buf.value = buf1;",
          "133:   request_buf.length = strlen(buf1);",
          "134:   maj_stat = gss_import_name(&min_stat, &request_buf, gss_nt_service_name, &target_name);",
          "",
          "[Removed Lines]",
          "124:   if (!mutt_bit_isset(mdata->capabilities, AGSSAPI))",
          "127:   if (mutt_account_getuser(&mdata->conn->account) < 0)",
          "131:   snprintf(buf1, sizeof(buf1), \"imap@%s\", mdata->conn->account.host);",
          "",
          "[Added Lines]",
          "124:   if (!mutt_bit_isset(adata->capabilities, AGSSAPI))",
          "127:   if (mutt_account_getuser(&adata->conn->account) < 0)",
          "131:   snprintf(buf1, sizeof(buf1), \"imap@%s\", adata->conn->account.host);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "165:   mutt_message(_(\"Authenticating (GSSAPI)...\"));",
          "170:   do",
          "172:   while (rc == IMAP_CMD_CONTINUE);",
          "174:   if (rc != IMAP_CMD_RESPOND)",
          "",
          "[Removed Lines]",
          "167:   imap_cmd_start(mdata, \"AUTHENTICATE GSSAPI\");",
          "171:     rc = imap_cmd_step(mdata);",
          "",
          "[Added Lines]",
          "167:   imap_cmd_start(adata, \"AUTHENTICATE GSSAPI\");",
          "171:     rc = imap_cmd_step(adata);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "183:   mutt_b64_encode(send_token.value, send_token.length, buf1, sizeof(buf1) - 2);",
          "184:   gss_release_buffer(&min_stat, &send_token);",
          "185:   mutt_str_strcat(buf1, sizeof(buf1), \"\\r\\n\");",
          "188:   while (maj_stat == GSS_S_CONTINUE_NEEDED)",
          "189:   {",
          "191:     do",
          "193:     while (rc == IMAP_CMD_CONTINUE);",
          "195:     if (rc != IMAP_CMD_RESPOND)",
          "",
          "[Removed Lines]",
          "186:   mutt_socket_send(mdata->conn, buf1);",
          "192:       rc = imap_cmd_step(mdata);",
          "",
          "[Added Lines]",
          "186:   mutt_socket_send(adata->conn, buf1);",
          "192:       rc = imap_cmd_step(adata);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "199:       goto bail;",
          "200:     }",
          "203:     request_buf.value = buf2;",
          "204:     sec_token = &request_buf;",
          "",
          "[Removed Lines]",
          "202:     request_buf.length = mutt_b64_decode(mdata->buf + 2, buf2, sizeof(buf2));",
          "",
          "[Added Lines]",
          "202:     request_buf.length = mutt_b64_decode(adata->buf + 2, buf2, sizeof(buf2));",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "219:     mutt_b64_encode(send_token.value, send_token.length, buf1, sizeof(buf1) - 2);",
          "220:     gss_release_buffer(&min_stat, &send_token);",
          "221:     mutt_str_strcat(buf1, sizeof(buf1), \"\\r\\n\");",
          "223:   }",
          "225:   gss_release_name(&min_stat, &target_name);",
          "228:   do",
          "230:   while (rc == IMAP_CMD_CONTINUE);",
          "232:   if (rc != IMAP_CMD_RESPOND)",
          "",
          "[Removed Lines]",
          "222:     mutt_socket_send(mdata->conn, buf1);",
          "229:     rc = imap_cmd_step(mdata);",
          "",
          "[Added Lines]",
          "222:     mutt_socket_send(adata->conn, buf1);",
          "229:     rc = imap_cmd_step(adata);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "234:     mutt_debug(1, \"#2 Error receiving server response.\\n\");",
          "235:     goto bail;",
          "236:   }",
          "238:   request_buf.value = buf2;",
          "240:   maj_stat = gss_unwrap(&min_stat, context, &request_buf, &send_token, &cflags, &quality);",
          "",
          "[Removed Lines]",
          "237:   request_buf.length = mutt_b64_decode(mdata->buf + 2, buf2, sizeof(buf2));",
          "",
          "[Added Lines]",
          "237:   request_buf.length = mutt_b64_decode(adata->buf + 2, buf2, sizeof(buf2));",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "271:   memcpy(buf1, &buf_size, 4);",
          "272:   buf1[0] = GSS_AUTH_P_NONE;",
          "275:   request_buf.value = buf1;",
          "277:   maj_stat = gss_wrap(&min_stat, context, 0, GSS_C_QOP_DEFAULT, &request_buf,",
          "278:                       &cflags, &send_token);",
          "279:   if (maj_stat != GSS_S_COMPLETE)",
          "",
          "[Removed Lines]",
          "274:   strncpy(buf1 + 4, mdata->conn->account.user, sizeof(buf1) - 4);",
          "276:   request_buf.length = 4 + strlen(mdata->conn->account.user);",
          "",
          "[Added Lines]",
          "274:   strncpy(buf1 + 4, adata->conn->account.user, sizeof(buf1) - 4);",
          "276:   request_buf.length = 4 + strlen(adata->conn->account.user);",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "283:   }",
          "285:   mutt_b64_encode(send_token.value, send_token.length, buf1, sizeof(buf1) - 2);",
          "287:   mutt_str_strcat(buf1, sizeof(buf1), \"\\r\\n\");",
          "291:   do",
          "293:   while (rc == IMAP_CMD_CONTINUE);",
          "294:   if (rc == IMAP_CMD_RESPOND)",
          "295:   {",
          "296:     mutt_debug(1, \"Unexpected server continuation request.\\n\");",
          "297:     goto err_abort_cmd;",
          "298:   }",
          "300:   {",
          "302:     mutt_debug(2, \"Releasing GSS credentials\\n\");",
          "",
          "[Removed Lines]",
          "286:   mutt_debug(2, \"Requesting authorisation as %s\\n\", mdata->conn->account.user);",
          "288:   mutt_socket_send(mdata->conn, buf1);",
          "292:     rc = imap_cmd_step(mdata);",
          "299:   if (imap_code(mdata->buf))",
          "",
          "[Added Lines]",
          "286:   mutt_debug(2, \"Requesting authorisation as %s\\n\", adata->conn->account.user);",
          "288:   mutt_socket_send(adata->conn, buf1);",
          "292:     rc = imap_cmd_step(adata);",
          "299:   if (imap_code(adata->buf))",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "316:     goto bail;",
          "318: err_abort_cmd:",
          "320:   do",
          "322:   while (rc == IMAP_CMD_CONTINUE);",
          "324: bail:",
          "",
          "[Removed Lines]",
          "319:   mutt_socket_send(mdata->conn, \"*\\r\\n\");",
          "321:     rc = imap_cmd_step(mdata);",
          "",
          "[Added Lines]",
          "319:   mutt_socket_send(adata->conn, \"*\\r\\n\");",
          "321:     rc = imap_cmd_step(adata);",
          "",
          "---------------"
        ],
        "imap/auth_login.c||imap/auth_login.c": [
          "File: imap/auth_login.c -> imap/auth_login.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "46: {",
          "47:   char q_user[STRING], q_pass[STRING];",
          "48:   char buf[LONG_STRING];",
          "49:   int rc;",
          "52:   {",
          "53:     mutt_message(_(\"LOGIN disabled on this server\"));",
          "54:     return IMAP_AUTH_UNAVAIL;",
          "55:   }",
          "58:     return IMAP_AUTH_FAILURE;",
          "60:     return IMAP_AUTH_FAILURE;",
          "62:   mutt_message(_(\"Logging in...\"));",
          "70:   if (DebugLevel < IMAP_LOG_PASS)",
          "73:   snprintf(buf, sizeof(buf), \"LOGIN %s %s\", q_user, q_pass);",
          "76:   if (!rc)",
          "77:   {",
          "",
          "[Removed Lines]",
          "45: enum ImapAuthRes imap_auth_login(struct ImapMboxData *mdata, const char *method)",
          "51:   if (mutt_bit_isset(mdata->capabilities, LOGINDISABLED))",
          "57:   if (mutt_account_getuser(&mdata->conn->account) < 0)",
          "59:   if (mutt_account_getpass(&mdata->conn->account) < 0)",
          "64:   imap_quote_string(q_user, sizeof(q_user), mdata->conn->account.user, false);",
          "65:   imap_quote_string(q_pass, sizeof(q_pass), mdata->conn->account.pass, false);",
          "71:     mutt_debug(2, \"Sending LOGIN command for %s...\\n\", mdata->conn->account.user);",
          "74:   rc = imap_exec(mdata, buf, IMAP_CMD_FAIL_OK | IMAP_CMD_PASS);",
          "",
          "[Added Lines]",
          "45: enum ImapAuthRes imap_auth_login(struct ImapAccountData *adata, const char *method)",
          "51:   if (mutt_bit_isset(adata->capabilities, LOGINDISABLED))",
          "57:   if (mutt_account_getuser(&adata->conn->account) < 0)",
          "59:   if (mutt_account_getpass(&adata->conn->account) < 0)",
          "64:   imap_quote_string(q_user, sizeof(q_user), adata->conn->account.user, false);",
          "65:   imap_quote_string(q_pass, sizeof(q_pass), adata->conn->account.pass, false);",
          "71:     mutt_debug(2, \"Sending LOGIN command for %s...\\n\", adata->conn->account.user);",
          "74:   rc = imap_exec(adata, buf, IMAP_CMD_FAIL_OK | IMAP_CMD_PASS);",
          "",
          "---------------"
        ],
        "imap/auth_oauth.c||imap/auth_oauth.c": [
          "File: imap/auth_oauth.c -> imap/auth_oauth.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "48: {",
          "49:   char *ibuf = NULL;",
          "50:   char *oauthbearer = NULL;",
          "",
          "[Removed Lines]",
          "47: enum ImapAuthRes imap_auth_oauth(struct ImapMboxData *mdata, const char *method)",
          "",
          "[Added Lines]",
          "47: enum ImapAuthRes imap_auth_oauth(struct ImapAccountData *adata, const char *method)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "52:   int rc;",
          "57:   {",
          "58:     return IMAP_AUTH_UNAVAIL;",
          "59:   }",
          "",
          "[Removed Lines]",
          "55:   if (!mutt_bit_isset(mdata->capabilities, AUTH_OAUTHBEARER) ||",
          "56:       !mutt_bit_isset(mdata->capabilities, SASL_IR) || !mdata->conn->ssf)",
          "",
          "[Added Lines]",
          "55:   if (!mutt_bit_isset(adata->capabilities, AUTH_OAUTHBEARER) ||",
          "56:       !mutt_bit_isset(adata->capabilities, SASL_IR) || !adata->conn->ssf)",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "61:   mutt_message(_(\"Authenticating (OAUTHBEARER)...\"));",
          "65:   if (!oauthbearer)",
          "66:     return IMAP_AUTH_FAILURE;",
          "",
          "[Removed Lines]",
          "64:   oauthbearer = mutt_account_getoauthbearer(&mdata->conn->account);",
          "",
          "[Added Lines]",
          "64:   oauthbearer = mutt_account_getoauthbearer(&adata->conn->account);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "77:   FREE(&oauthbearer);",
          "78:   FREE(&ibuf);",
          "",
          "[Removed Lines]",
          "75:   rc = imap_exec(mdata, ibuf, IMAP_CMD_FAIL_OK | IMAP_CMD_PASS);",
          "",
          "[Added Lines]",
          "75:   rc = imap_exec(adata, ibuf, IMAP_CMD_FAIL_OK | IMAP_CMD_PASS);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "87:   }",
          "89:   if (!rc)",
          "",
          "[Removed Lines]",
          "85:     mutt_socket_send(mdata->conn, \"\\001\");",
          "86:     rc = imap_exec(mdata, ibuf, IMAP_CMD_FAIL_OK);",
          "",
          "[Added Lines]",
          "85:     mutt_socket_send(adata->conn, \"\\001\");",
          "86:     rc = imap_exec(adata, ibuf, IMAP_CMD_FAIL_OK);",
          "",
          "---------------"
        ],
        "imap/auth_plain.c||imap/auth_plain.c": [
          "File: imap/auth_plain.c -> imap/auth_plain.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "46: {",
          "47:   int rc = IMAP_CMD_CONTINUE;",
          "48:   enum ImapAuthRes res = IMAP_AUTH_SUCCESS;",
          "49:   static const char auth_plain_cmd[] = \"AUTHENTICATE PLAIN\";",
          "50:   char buf[STRING] = { 0 };",
          "53:     return IMAP_AUTH_FAILURE;",
          "55:     return IMAP_AUTH_FAILURE;",
          "57:   mutt_message(_(\"Logging in...\"));",
          "64:   {",
          "66:   }",
          "67:   else",
          "68:   {",
          "71:     buf[sizeof(auth_plain_cmd) - 1] = '\\0';",
          "73:     while (rc == IMAP_CMD_CONTINUE)",
          "74:     {",
          "76:     }",
          "77:     if (rc == IMAP_CMD_RESPOND)",
          "78:     {",
          "79:       mutt_str_strcat(buf + sizeof(auth_plain_cmd),",
          "80:                       sizeof(buf) - sizeof(auth_plain_cmd), \"\\r\\n\");",
          "82:     }",
          "83:   }",
          "85:   while (rc == IMAP_CMD_CONTINUE)",
          "86:   {",
          "88:   }",
          "90:   if (rc == IMAP_CMD_BAD)",
          "",
          "[Removed Lines]",
          "45: enum ImapAuthRes imap_auth_plain(struct ImapMboxData *mdata, const char *method)",
          "52:   if (mutt_account_getuser(&mdata->conn->account) < 0)",
          "54:   if (mutt_account_getpass(&mdata->conn->account) < 0)",
          "60:   mutt_sasl_plain_msg(buf, sizeof(buf), auth_plain_cmd, mdata->conn->account.user,",
          "61:                       mdata->conn->account.user, mdata->conn->account.pass);",
          "63:   if (mutt_bit_isset(mdata->capabilities, SASL_IR))",
          "65:     imap_cmd_start(mdata, buf);",
          "72:     imap_cmd_start(mdata, buf);",
          "75:       rc = imap_cmd_step(mdata);",
          "81:       mutt_socket_send(mdata->conn, buf + sizeof(auth_plain_cmd));",
          "87:     rc = imap_cmd_step(mdata);",
          "",
          "[Added Lines]",
          "45: enum ImapAuthRes imap_auth_plain(struct ImapAccountData *adata, const char *method)",
          "52:   if (mutt_account_getuser(&adata->conn->account) < 0)",
          "54:   if (mutt_account_getpass(&adata->conn->account) < 0)",
          "60:   mutt_sasl_plain_msg(buf, sizeof(buf), auth_plain_cmd, adata->conn->account.user,",
          "61:                       adata->conn->account.user, adata->conn->account.pass);",
          "63:   if (mutt_bit_isset(adata->capabilities, SASL_IR))",
          "65:     imap_cmd_start(adata, buf);",
          "72:     imap_cmd_start(adata, buf);",
          "75:       rc = imap_cmd_step(adata);",
          "81:       mutt_socket_send(adata->conn, buf + sizeof(auth_plain_cmd));",
          "87:     rc = imap_cmd_step(adata);",
          "",
          "---------------"
        ],
        "imap/auth_sasl.c||imap/auth_sasl.c": [
          "File: imap/auth_sasl.c -> imap/auth_sasl.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "50: {",
          "51:   sasl_conn_t *saslconn = NULL;",
          "52:   sasl_interact_t *interaction = NULL;",
          "",
          "[Removed Lines]",
          "49: enum ImapAuthRes imap_auth_sasl(struct ImapMboxData *mdata, const char *method)",
          "",
          "[Added Lines]",
          "49: enum ImapAuthRes imap_auth_sasl(struct ImapAccountData *adata, const char *method)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "58:   unsigned int len = 0, olen = 0;",
          "59:   bool client_start;",
          "62:   {",
          "63:     mutt_debug(1, \"Error allocating SASL connection.\\n\");",
          "64:     return IMAP_AUTH_FAILURE;",
          "",
          "[Removed Lines]",
          "61:   if (mutt_sasl_client_new(mdata->conn, &saslconn) < 0)",
          "",
          "[Added Lines]",
          "61:   if (mutt_sasl_client_new(adata->conn, &saslconn) < 0)",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "70:   if (!method)",
          "71:   {",
          "80:       return IMAP_AUTH_FAILURE;",
          "85:     {",
          "86:       rc = sasl_client_start(saslconn, \"AUTH=ANONYMOUS\", NULL, &pc, &olen, &mech);",
          "87:     }",
          "88:   }",
          "89:   else if ((mutt_str_strcasecmp(\"login\", method) == 0) &&",
          "91:   {",
          "93:     return IMAP_AUTH_UNAVAIL;",
          "",
          "[Removed Lines]",
          "72:     method = mdata->capstr;",
          "79:     if (mutt_account_getuser(&mdata->conn->account) < 0)",
          "82:     if (mutt_bit_isset(mdata->capabilities, AUTH_ANON) &&",
          "83:         (!mdata->conn->account.user[0] ||",
          "84:          (mutt_str_strncmp(mdata->conn->account.user, \"anonymous\", 9) == 0)))",
          "90:            !strstr(NONULL(mdata->capstr), \"AUTH=LOGIN\"))",
          "",
          "[Added Lines]",
          "72:     method = adata->capstr;",
          "79:     if (mutt_account_getuser(&adata->conn->account) < 0)",
          "82:     if (mutt_bit_isset(adata->capabilities, AUTH_ANON) &&",
          "83:         (!adata->conn->account.user[0] ||",
          "84:          (mutt_str_strncmp(adata->conn->account.user, \"anonymous\", 9) == 0)))",
          "90:            !strstr(NONULL(adata->capstr), \"AUTH=LOGIN\"))",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "126:   buf = mutt_mem_malloc(bufsize);",
          "128:   snprintf(buf, bufsize, \"AUTHENTICATE %s\", mech);",
          "130:   {",
          "131:     len = mutt_str_strlen(buf);",
          "132:     buf[len++] = ' ';",
          "",
          "[Removed Lines]",
          "129:   if (mutt_bit_isset(mdata->capabilities, SASL_IR) && client_start)",
          "",
          "[Added Lines]",
          "129:   if (mutt_bit_isset(adata->capabilities, SASL_IR) && client_start)",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "138:     client_start = false;",
          "139:     olen = 0;",
          "140:   }",
          "142:   irc = IMAP_CMD_CONTINUE;",
          "145:   while (rc == SASL_CONTINUE || olen > 0)",
          "146:   {",
          "147:     do",
          "149:     while (irc == IMAP_CMD_CONTINUE);",
          "151:     if (irc == IMAP_CMD_BAD || irc == IMAP_CMD_NO)",
          "",
          "[Removed Lines]",
          "141:   imap_cmd_start(mdata, buf);",
          "148:       irc = imap_cmd_step(mdata);",
          "",
          "[Added Lines]",
          "141:   imap_cmd_start(adata, buf);",
          "148:       irc = imap_cmd_step(adata);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "154:     if (irc == IMAP_CMD_RESPOND)",
          "155:     {",
          "158:       {",
          "159:         buf[0] = '\\0';",
          "160:         len = 0;",
          "161:       }",
          "162:       else",
          "163:       {",
          "165:         if (len > bufsize)",
          "166:         {",
          "167:           bufsize = len;",
          "",
          "[Removed Lines]",
          "157:       if (mdata->buf[1] == '\\0')",
          "164:         len = strlen(mdata->buf + 2);",
          "",
          "[Added Lines]",
          "157:       if (adata->buf[1] == '\\0')",
          "164:         len = strlen(adata->buf + 2);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "169:         }",
          "173:         {",
          "174:           mutt_debug(1, \"error base64-decoding server response.\\n\");",
          "175:           goto bail;",
          "",
          "[Removed Lines]",
          "172:         if (sasl_decode64(mdata->buf + 2, len, buf, bufsize - 1, &len) != SASL_OK)",
          "",
          "[Added Lines]",
          "172:         if (sasl_decode64(adata->buf + 2, len, buf, bufsize - 1, &len) != SASL_OK)",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "210:     if (irc == IMAP_CMD_RESPOND)",
          "211:     {",
          "212:       mutt_str_strfcpy(buf + olen, \"\\r\\n\", bufsize - olen);",
          "214:     }",
          "217:     if (rc < 0)",
          "218:     {",
          "220:       mutt_debug(1, \"sasl_client_step error %d\\n\", rc);",
          "221:     }",
          "",
          "[Removed Lines]",
          "213:       mutt_socket_send(mdata->conn, buf);",
          "219:       mutt_socket_send(mdata->conn, \"*\\r\\n\");",
          "",
          "[Added Lines]",
          "213:       mutt_socket_send(adata->conn, buf);",
          "219:       mutt_socket_send(adata->conn, \"*\\r\\n\");",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "226:   while (irc != IMAP_CMD_OK)",
          "227:   {",
          "229:     if (irc != IMAP_CMD_CONTINUE)",
          "230:       break;",
          "231:   }",
          "",
          "[Removed Lines]",
          "228:     irc = imap_cmd_step(mdata);",
          "",
          "[Added Lines]",
          "228:     irc = imap_cmd_step(adata);",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "233:   if (rc != SASL_OK)",
          "234:     goto bail;",
          "237:   {",
          "239:     FREE(&buf);",
          "240:     return IMAP_AUTH_SUCCESS;",
          "241:   }",
          "",
          "[Removed Lines]",
          "236:   if (imap_code(mdata->buf))",
          "238:     mutt_sasl_setup_conn(mdata->conn, saslconn);",
          "",
          "[Added Lines]",
          "236:   if (imap_code(adata->buf))",
          "238:     mutt_sasl_setup_conn(adata->conn, saslconn);",
          "",
          "---------------"
        ],
        "imap/browse.c||imap/browse.c": [
          "File: imap/browse.c -> imap/browse.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "146:                                   struct BrowserState *state, bool isparent)",
          "147: {",
          "148:   struct ImapList list;",
          "",
          "[Removed Lines]",
          "145: static int browse_add_list_result(struct ImapMboxData *mdata, const char *cmd,",
          "",
          "[Added Lines]",
          "145: static int browse_add_list_result(struct ImapAccountData *adata, const char *cmd,",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "155:     return -1;",
          "156:   }",
          "161:   do",
          "162:   {",
          "163:     list.name = NULL;",
          "166:     if (rc == IMAP_CMD_CONTINUE && list.name)",
          "167:     {",
          "",
          "[Removed Lines]",
          "158:   imap_cmd_start(mdata, cmd);",
          "159:   mdata->cmdtype = IMAP_CT_LIST;",
          "160:   mdata->cmddata = &list;",
          "164:     rc = imap_cmd_step(mdata);",
          "",
          "[Added Lines]",
          "158:   imap_cmd_start(adata, cmd);",
          "159:   adata->cmdtype = IMAP_CT_LIST;",
          "160:   adata->cmddata = &list;",
          "164:     rc = imap_cmd_step(adata);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "173:         add_folder(list.delim, list.name, list.noselect, list.noinferiors, state, isparent);",
          "174:     }",
          "175:   } while (rc == IMAP_CMD_CONTINUE);",
          "178:   FREE(&mx.mbox);",
          "179:   return (rc == IMAP_CMD_OK) ? 0 : -1;",
          "",
          "[Removed Lines]",
          "176:   mdata->cmddata = NULL;",
          "",
          "[Added Lines]",
          "176:   adata->cmddata = NULL;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "191: int imap_browse(char *path, struct BrowserState *state)",
          "192: {",
          "194:   struct ImapList list;",
          "195:   char buf[PATH_MAX];",
          "196:   char mbox[PATH_MAX];",
          "",
          "[Removed Lines]",
          "193:   struct ImapMboxData *mdata = NULL;",
          "",
          "[Added Lines]",
          "193:   struct ImapAccountData *adata = NULL;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "212:   ImapCheckSubscribed = false;",
          "213:   mutt_str_strfcpy(list_cmd, ImapListSubscribed ? \"LSUB\" : \"LIST\", sizeof(list_cmd));",
          "217:     goto fail;",
          "219:   mutt_message(_(\"Getting folder list...\"));",
          "",
          "[Removed Lines]",
          "215:   mdata = imap_conn_find(&(mx.account), 0);",
          "216:   if (!mdata)",
          "",
          "[Added Lines]",
          "215:   adata = imap_conn_find(&(mx.account), 0);",
          "216:   if (!adata)",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "222:   if (mx.mbox && mx.mbox[0] != '\\0')",
          "223:   {",
          "225:     n = mutt_str_strlen(mbox);",
          "226:   }",
          "227:   else",
          "",
          "[Removed Lines]",
          "224:     imap_fix_path(mdata, mx.mbox, mbox, sizeof(mbox));",
          "",
          "[Added Lines]",
          "224:     imap_fix_path(adata, mx.mbox, mbox, sizeof(mbox));",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "241:     snprintf(buf, sizeof(buf), \"%s \\\"\\\" %s\", list_cmd, munged_mbox);",
          "245:     do",
          "246:     {",
          "247:       list.name = 0;",
          "249:       if (rc == IMAP_CMD_CONTINUE && list.name)",
          "250:       {",
          "251:         if (!list.noinferiors && list.name[0] &&",
          "",
          "[Removed Lines]",
          "240:     imap_munge_mbox_name(mdata, munged_mbox, sizeof(munged_mbox), mbox);",
          "242:     imap_cmd_start(mdata, buf);",
          "243:     mdata->cmdtype = IMAP_CT_LIST;",
          "244:     mdata->cmddata = &list;",
          "248:       rc = imap_cmd_step(mdata);",
          "",
          "[Added Lines]",
          "240:     imap_munge_mbox_name(adata, munged_mbox, sizeof(munged_mbox), mbox);",
          "242:     imap_cmd_start(adata, buf);",
          "243:     adata->cmdtype = IMAP_CT_LIST;",
          "244:     adata->cmddata = &list;",
          "248:       rc = imap_cmd_step(adata);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "256:         }",
          "257:       }",
          "258:     } while (rc == IMAP_CMD_CONTINUE);",
          "262:     if (mbox[n - 1] == list.delim)",
          "",
          "[Removed Lines]",
          "259:     mdata->cmddata = NULL;",
          "",
          "[Added Lines]",
          "259:     adata->cmddata = NULL;",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "305:     {",
          "306:       char relpath[2];",
          "309:       if (showparents)",
          "311:       if (!state->folder)",
          "312:       {",
          "313:         imap_qualify_path(buf, sizeof(buf), &mx, relpath);",
          "",
          "[Removed Lines]",
          "308:       snprintf(relpath, sizeof(relpath), \"%c\", n < 0 ? '\\0' : mdata->delim);",
          "310:         add_folder(mdata->delim, relpath, true, false, state, true);",
          "",
          "[Added Lines]",
          "308:       snprintf(relpath, sizeof(relpath), \"%c\", n < 0 ? '\\0' : adata->delim);",
          "310:         add_folder(adata->delim, relpath, true, false, state, true);",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "326:   mutt_debug(3, \"Quoting mailbox scan: %s -> \", mbox);",
          "327:   snprintf(buf, sizeof(buf), \"%s%%\", mbox);",
          "329:   mutt_debug(3, \"%s\\n\", munged_mbox);",
          "330:   snprintf(buf, sizeof(buf), \"%s \\\"\\\" %s\", list_cmd, munged_mbox);",
          "332:     goto fail;",
          "334:   if (state->entrylen == 0)",
          "",
          "[Removed Lines]",
          "328:   imap_munge_mbox_name(mdata, munged_mbox, sizeof(munged_mbox), buf);",
          "331:   if (browse_add_list_result(mdata, buf, state, false))",
          "",
          "[Added Lines]",
          "328:   imap_munge_mbox_name(adata, munged_mbox, sizeof(munged_mbox), buf);",
          "331:   if (browse_add_list_result(adata, buf, state, false))",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "363: int imap_mailbox_create(const char *folder)",
          "364: {",
          "366:   struct ImapMbox mx;",
          "367:   char buf[PATH_MAX];",
          "368:   short n;",
          "",
          "[Removed Lines]",
          "365:   struct ImapMboxData *mdata = NULL;",
          "",
          "[Added Lines]",
          "365:   struct ImapAccountData *adata = NULL;",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "373:     return -1;",
          "374:   }",
          "378:   {",
          "379:     mutt_debug(1, \"Couldn't find open connection to %s\\n\", mx.account.host);",
          "380:     goto fail;",
          "",
          "[Removed Lines]",
          "376:   mdata = imap_conn_find(&mx.account, MUTT_IMAP_CONN_NONEW);",
          "377:   if (!mdata)",
          "",
          "[Added Lines]",
          "376:   adata = imap_conn_find(&mx.account, MUTT_IMAP_CONN_NONEW);",
          "377:   if (!adata)",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "386:   n = mutt_str_strlen(buf);",
          "388:   {",
          "390:     buf[n] = '\\0';",
          "391:   }",
          "",
          "[Removed Lines]",
          "387:   if (n && (n < sizeof(buf) - 1) && (buf[n - 1] != mdata->delim))",
          "389:     buf[n++] = mdata->delim;",
          "",
          "[Added Lines]",
          "387:   if (n && (n < sizeof(buf) - 1) && (buf[n - 1] != adata->delim))",
          "389:     buf[n++] = adata->delim;",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "399:     goto fail;",
          "400:   }",
          "403:     goto fail;",
          "405:   mutt_message(_(\"Mailbox created\"));",
          "",
          "[Removed Lines]",
          "402:   if (imap_create_mailbox(mdata, buf) < 0)",
          "",
          "[Added Lines]",
          "402:   if (imap_create_mailbox(adata, buf) < 0)",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "424: int imap_mailbox_rename(const char *mailbox)",
          "425: {",
          "427:   struct ImapMbox mx;",
          "428:   char buf[PATH_MAX];",
          "429:   char newname[PATH_MAX];",
          "",
          "[Removed Lines]",
          "426:   struct ImapMboxData *mdata = NULL;",
          "",
          "[Added Lines]",
          "426:   struct ImapAccountData *adata = NULL;",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "434:     return -1;",
          "435:   }",
          "439:   {",
          "440:     mutt_debug(1, \"Couldn't find open connection to %s\\n\", mx.account.host);",
          "441:     goto fail;",
          "",
          "[Removed Lines]",
          "437:   mdata = imap_conn_find(&mx.account, MUTT_IMAP_CONN_NONEW);",
          "438:   if (!mdata)",
          "",
          "[Added Lines]",
          "437:   adata = imap_conn_find(&mx.account, MUTT_IMAP_CONN_NONEW);",
          "438:   if (!adata)",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "459:     goto fail;",
          "460:   }",
          "465:   {",
          "467:     goto fail;",
          "468:   }",
          "",
          "[Removed Lines]",
          "462:   imap_fix_path(mdata, newname, buf, sizeof(buf));",
          "464:   if (imap_rename_mailbox(mdata, &mx, buf) < 0)",
          "466:     mutt_error(_(\"Rename failed: %s\"), imap_get_qualifier(mdata->buf));",
          "",
          "[Added Lines]",
          "462:   imap_fix_path(adata, newname, buf, sizeof(buf));",
          "464:   if (imap_rename_mailbox(adata, &mx, buf) < 0)",
          "466:     mutt_error(_(\"Rename failed: %s\"), imap_get_qualifier(adata->buf));",
          "",
          "---------------"
        ],
        "imap/command.c||imap/command.c": [
          "File: imap/command.c -> imap/command.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "85: {",
          "87:     return true;",
          "89:   return false;",
          "",
          "[Removed Lines]",
          "84: static bool cmd_queue_full(struct ImapMboxData *mdata)",
          "86:   if ((mdata->nextcmd + 1) % mdata->cmdslots == mdata->lastcmd)",
          "",
          "[Added Lines]",
          "84: static bool cmd_queue_full(struct ImapAccountData *adata)",
          "86:   if ((adata->nextcmd + 1) % adata->cmdslots == adata->lastcmd)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "99: {",
          "100:   struct ImapCommand *cmd = NULL;",
          "103:   {",
          "104:     mutt_debug(3, \"IMAP command queue full\\n\");",
          "105:     return NULL;",
          "106:   }",
          "115:   cmd->state = IMAP_CMD_NEW;",
          "",
          "[Removed Lines]",
          "98: static struct ImapCommand *cmd_new(struct ImapMboxData *mdata)",
          "102:   if (cmd_queue_full(mdata))",
          "108:   cmd = mdata->cmds + mdata->nextcmd;",
          "109:   mdata->nextcmd = (mdata->nextcmd + 1) % mdata->cmdslots;",
          "111:   snprintf(cmd->seq, sizeof(cmd->seq), \"a%04u\", mdata->seqno++);",
          "112:   if (mdata->seqno > 9999)",
          "113:     mdata->seqno = 0;",
          "",
          "[Added Lines]",
          "98: static struct ImapCommand *cmd_new(struct ImapAccountData *adata)",
          "102:   if (cmd_queue_full(adata))",
          "108:   cmd = adata->cmds + adata->nextcmd;",
          "109:   adata->nextcmd = (adata->nextcmd + 1) % adata->cmdslots;",
          "111:   snprintf(cmd->seq, sizeof(cmd->seq), \"a%04u\", adata->seqno++);",
          "112:   if (adata->seqno > 9999)",
          "113:     adata->seqno = 0;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "131: {",
          "133:   {",
          "134:     mutt_debug(3, \"Draining IMAP command pipeline\\n\");",
          "138:     if (rc < 0 && rc != -2)",
          "139:       return rc;",
          "140:   }",
          "143:   if (!cmd)",
          "144:     return IMAP_CMD_BAD;",
          "147:     return IMAP_CMD_BAD;",
          "149:   return 0;",
          "150: }",
          "157: {",
          "161:   {",
          "167:   }",
          "171:   {",
          "174:       mutt_clear_error();",
          "176:   }",
          "177: }",
          "188: {",
          "189:   int rc;",
          "192:   {",
          "194:     return -1;",
          "195:   }",
          "198:     return rc;",
          "200:   if (flags & IMAP_CMD_QUEUE)",
          "201:     return 0;",
          "204:     return IMAP_CMD_BAD;",
          "207:                           (flags & IMAP_CMD_PASS) ? IMAP_LOG_PASS : IMAP_LOG_CMD);",
          "214:   return (rc < 0) ? IMAP_CMD_BAD : 0;",
          "215: }",
          "",
          "[Removed Lines]",
          "130: static int cmd_queue(struct ImapMboxData *mdata, const char *cmdstr, int flags)",
          "132:   if (cmd_queue_full(mdata))",
          "136:     const int rc = imap_exec(mdata, NULL, IMAP_CMD_FAIL_OK | (flags & IMAP_CMD_POLL));",
          "142:   struct ImapCommand *cmd = cmd_new(mdata);",
          "146:   if (mutt_buffer_printf(mdata->cmdbuf, \"%s %s\\r\\n\", cmd->seq, cmdstr) < 0)",
          "156: static void cmd_handle_fatal(struct ImapMboxData *mdata)",
          "158:   mdata->status = IMAP_FATAL;",
          "160:   if ((mdata->state >= IMAP_SELECTED) && (mdata->reopen & IMAP_REOPEN_ALLOW))",
          "162:     mx_fastclose_mailbox(mdata->ctx);",
          "163:     mutt_socket_close(mdata->conn);",
          "164:     mutt_error(_(\"Mailbox %s@%s closed\"), mdata->conn->account.login,",
          "165:                mdata->conn->account.host);",
          "166:     mdata->state = IMAP_DISCONNECTED;",
          "169:   imap_close_connection(mdata);",
          "170:   if (!mdata->recovering)",
          "172:     mdata->recovering = true;",
          "173:     if (imap_conn_find(&mdata->conn->account, 0))",
          "175:     mdata->recovering = false;",
          "187: static int cmd_start(struct ImapMboxData *mdata, const char *cmdstr, int flags)",
          "191:   if (mdata->status == IMAP_FATAL)",
          "193:     cmd_handle_fatal(mdata);",
          "197:   if (cmdstr && ((rc = cmd_queue(mdata, cmdstr, flags)) < 0))",
          "203:   if (mdata->cmdbuf->dptr == mdata->cmdbuf->data)",
          "206:   rc = mutt_socket_send_d(mdata->conn, mdata->cmdbuf->data,",
          "208:   mdata->cmdbuf->dptr = mdata->cmdbuf->data;",
          "211:   if (mdata->state == IMAP_IDLE)",
          "212:     mdata->state = IMAP_SELECTED;",
          "",
          "[Added Lines]",
          "130: static int cmd_queue(struct ImapAccountData *adata, const char *cmdstr, int flags)",
          "132:   if (cmd_queue_full(adata))",
          "136:     const int rc = imap_exec(adata, NULL, IMAP_CMD_FAIL_OK | (flags & IMAP_CMD_POLL));",
          "142:   struct ImapCommand *cmd = cmd_new(adata);",
          "146:   if (mutt_buffer_printf(adata->cmdbuf, \"%s %s\\r\\n\", cmd->seq, cmdstr) < 0)",
          "156: static void cmd_handle_fatal(struct ImapAccountData *adata)",
          "158:   adata->status = IMAP_FATAL;",
          "160:   if ((adata->state >= IMAP_SELECTED) && (adata->reopen & IMAP_REOPEN_ALLOW))",
          "162:     mx_fastclose_mailbox(adata->ctx);",
          "163:     mutt_socket_close(adata->conn);",
          "164:     mutt_error(_(\"Mailbox %s@%s closed\"), adata->conn->account.login,",
          "165:                adata->conn->account.host);",
          "166:     adata->state = IMAP_DISCONNECTED;",
          "169:   imap_close_connection(adata);",
          "170:   if (!adata->recovering)",
          "172:     adata->recovering = true;",
          "173:     if (imap_conn_find(&adata->conn->account, 0))",
          "175:     adata->recovering = false;",
          "187: static int cmd_start(struct ImapAccountData *adata, const char *cmdstr, int flags)",
          "191:   if (adata->status == IMAP_FATAL)",
          "193:     cmd_handle_fatal(adata);",
          "197:   if (cmdstr && ((rc = cmd_queue(adata, cmdstr, flags)) < 0))",
          "203:   if (adata->cmdbuf->dptr == adata->cmdbuf->data)",
          "206:   rc = mutt_socket_send_d(adata->conn, adata->cmdbuf->data,",
          "208:   adata->cmdbuf->dptr = adata->cmdbuf->data;",
          "211:   if (adata->state == IMAP_IDLE)",
          "212:     adata->state = IMAP_SELECTED;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "244: {",
          "245:   unsigned int exp_msn;",
          "246:   struct Email *e = NULL;",
          "248:   mutt_debug(2, \"Handling EXPUNGE\\n\");",
          "251:     return;",
          "254:   if (e)",
          "255:   {",
          "",
          "[Removed Lines]",
          "243: static void cmd_parse_expunge(struct ImapMboxData *mdata, const char *s)",
          "250:   if (mutt_str_atoui(s, &exp_msn) < 0 || exp_msn < 1 || exp_msn > mdata->max_msn)",
          "253:   e = mdata->msn_index[exp_msn - 1];",
          "",
          "[Added Lines]",
          "243: static void cmd_parse_expunge(struct ImapAccountData *adata, const char *s)",
          "250:   if (mutt_str_atoui(s, &exp_msn) < 0 || exp_msn < 1 || exp_msn > adata->max_msn)",
          "253:   e = adata->msn_index[exp_msn - 1];",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "261:   }",
          "265:   {",
          "267:     if (e)",
          "268:       IMAP_EDATA(e)->msn--;",
          "270:   }",
          "276: }",
          "287: {",
          "288:   bool earlier = false;",
          "289:   int rc;",
          "",
          "[Removed Lines]",
          "264:   for (unsigned int cur = exp_msn; cur < mdata->max_msn; cur++)",
          "266:     e = mdata->msn_index[cur];",
          "269:     mdata->msn_index[cur - 1] = e;",
          "272:   mdata->msn_index[mdata->max_msn - 1] = NULL;",
          "273:   mdata->max_msn--;",
          "275:   mdata->reopen |= IMAP_EXPUNGE_PENDING;",
          "286: static void cmd_parse_vanished(struct ImapMboxData *mdata, char *s)",
          "",
          "[Added Lines]",
          "264:   for (unsigned int cur = exp_msn; cur < adata->max_msn; cur++)",
          "266:     e = adata->msn_index[cur];",
          "269:     adata->msn_index[cur - 1] = e;",
          "272:   adata->msn_index[adata->max_msn - 1] = NULL;",
          "273:   adata->max_msn--;",
          "275:   adata->reopen |= IMAP_EXPUNGE_PENDING;",
          "286: static void cmd_parse_vanished(struct ImapAccountData *adata, char *s)",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "318:   while ((rc = mutt_seqset_iterator_next(iter, &uid)) == 0)",
          "319:   {",
          "321:     if (!e)",
          "322:       continue;",
          "",
          "[Removed Lines]",
          "320:     struct Email *e = mutt_hash_int_find(mdata->uid_hash, uid);",
          "",
          "[Added Lines]",
          "320:     struct Email *e = mutt_hash_int_find(adata->uid_hash, uid);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "329:     e->index = INT_MAX;",
          "330:     IMAP_EDATA(e)->msn = 0;",
          "333:     {",
          "334:       mutt_debug(1, \"VANISHED: msn for UID %u is incorrect.\\n\", uid);",
          "335:       continue;",
          "336:     }",
          "338:     {",
          "339:       mutt_debug(1, \"VANISHED: msn_index for UID %u is incorrect.\\n\", uid);",
          "340:       continue;",
          "341:     }",
          "345:     if (!earlier)",
          "346:     {",
          "349:       {",
          "351:         if (e)",
          "352:           IMAP_EDATA(e)->msn--;",
          "354:       }",
          "358:     }",
          "359:   }",
          "361:   if (rc < 0)",
          "362:     mutt_debug(1, \"VANISHED: illegal seqset %s\\n\", s);",
          "366:   mutt_seqset_iterator_free(&iter);",
          "367: }",
          "379: {",
          "380:   unsigned int msn, uid;",
          "381:   struct Email *e = NULL;",
          "",
          "[Removed Lines]",
          "332:     if ((exp_msn < 1) || (exp_msn > mdata->max_msn))",
          "337:     if (mdata->msn_index[exp_msn - 1] != e)",
          "343:     mdata->msn_index[exp_msn - 1] = NULL;",
          "348:       for (unsigned int cur = exp_msn; cur < mdata->max_msn; cur++)",
          "350:         e = mdata->msn_index[cur];",
          "353:         mdata->msn_index[cur - 1] = e;",
          "356:       mdata->msn_index[mdata->max_msn - 1] = NULL;",
          "357:       mdata->max_msn--;",
          "364:   mdata->reopen |= IMAP_EXPUNGE_PENDING;",
          "378: static void cmd_parse_fetch(struct ImapMboxData *mdata, char *s)",
          "",
          "[Added Lines]",
          "332:     if ((exp_msn < 1) || (exp_msn > adata->max_msn))",
          "337:     if (adata->msn_index[exp_msn - 1] != e)",
          "343:     adata->msn_index[exp_msn - 1] = NULL;",
          "348:       for (unsigned int cur = exp_msn; cur < adata->max_msn; cur++)",
          "350:         e = adata->msn_index[cur];",
          "353:         adata->msn_index[cur - 1] = e;",
          "356:       adata->msn_index[adata->max_msn - 1] = NULL;",
          "357:       adata->max_msn--;",
          "364:   adata->reopen |= IMAP_EXPUNGE_PENDING;",
          "378: static void cmd_parse_fetch(struct ImapAccountData *adata, char *s)",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "391:     return;",
          "392:   }",
          "395:   {",
          "396:     mutt_debug(3, \"Skipping FETCH response - MSN %u out of range\\n\", msn);",
          "397:     return;",
          "398:   }",
          "401:   if (!e || !e->active)",
          "402:   {",
          "403:     mutt_debug(3, \"Skipping FETCH response - MSN %u not in msn_index\\n\", msn);",
          "",
          "[Removed Lines]",
          "394:   if ((msn < 1) || (msn > mdata->max_msn))",
          "400:   e = mdata->msn_index[msn - 1];",
          "",
          "[Added Lines]",
          "394:   if ((msn < 1) || (msn > adata->max_msn))",
          "400:   e = adata->msn_index[msn - 1];",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "495:   if (flags)",
          "496:   {",
          "498:     if (server_changes)",
          "499:     {",
          "501:       if (e->changed)",
          "503:       else",
          "505:     }",
          "506:   }",
          "507: }",
          "515: {",
          "516:   mutt_debug(3, \"Handling CAPABILITY\\n\");",
          "",
          "[Removed Lines]",
          "497:     imap_set_flags(mdata, e, flags, &server_changes);",
          "502:         mdata->reopen |= IMAP_EXPUNGE_PENDING;",
          "504:         mdata->check_status = IMAP_FLAGS_PENDING;",
          "514: static void cmd_parse_capability(struct ImapMboxData *mdata, char *s)",
          "",
          "[Added Lines]",
          "497:     imap_set_flags(adata, e, flags, &server_changes);",
          "502:         adata->reopen |= IMAP_EXPUNGE_PENDING;",
          "504:         adata->check_status = IMAP_FLAGS_PENDING;",
          "514: static void cmd_parse_capability(struct ImapAccountData *adata, char *s)",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "519:   char *bracket = strchr(s, ']');",
          "520:   if (bracket)",
          "527:   while (*s)",
          "528:   {",
          "",
          "[Removed Lines]",
          "522:   FREE(&mdata->capstr);",
          "523:   mdata->capstr = mutt_str_strdup(s);",
          "525:   memset(mdata->capabilities, 0, sizeof(mdata->capabilities));",
          "",
          "[Added Lines]",
          "522:   FREE(&adata->capstr);",
          "523:   adata->capstr = mutt_str_strdup(s);",
          "525:   memset(adata->capabilities, 0, sizeof(adata->capabilities));",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "530:     {",
          "531:       if (mutt_str_word_casecmp(Capabilities[i], s) == 0)",
          "532:       {",
          "534:         mutt_debug(4, \" Found capability \\\"%s\\\": %d\\n\", Capabilities[i], i);",
          "535:         break;",
          "536:       }",
          "",
          "[Removed Lines]",
          "533:         mutt_bit_set(mdata->capabilities, i);",
          "",
          "[Added Lines]",
          "533:         mutt_bit_set(adata->capabilities, i);",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "548: {",
          "549:   struct ImapList *list = NULL;",
          "550:   struct ImapList lb;",
          "552:   unsigned int litlen;",
          "556:   else",
          "557:     list = &lb;",
          "",
          "[Removed Lines]",
          "547: static void cmd_parse_list(struct ImapMboxData *mdata, char *s)",
          "554:   if (mdata->cmddata && mdata->cmdtype == IMAP_CT_LIST)",
          "555:     list = mdata->cmddata;",
          "",
          "[Added Lines]",
          "547: static void cmd_parse_list(struct ImapAccountData *adata, char *s)",
          "554:   if (adata->cmddata && adata->cmdtype == IMAP_CT_LIST)",
          "555:     list = adata->cmddata;",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "596:   if (imap_get_literal_count(s, &litlen) == 0)",
          "597:   {",
          "599:     {",
          "601:       return;",
          "602:     }",
          "604:   }",
          "605:   else",
          "606:   {",
          "608:     list->name = s;",
          "609:   }",
          "611:   if (list->name[0] == '\\0')",
          "612:   {",
          "615:   }",
          "616: }",
          "624: {",
          "625:   char buf[STRING];",
          "626:   char errstr[STRING];",
          "",
          "[Removed Lines]",
          "598:     if (imap_cmd_step(mdata) != IMAP_CMD_CONTINUE)",
          "600:       mdata->status = IMAP_FATAL;",
          "603:     list->name = mdata->buf;",
          "607:     imap_unmunge_mbox_name(mdata, s);",
          "613:     mdata->delim = list->delim;",
          "614:     mutt_debug(3, \"Root delimiter: %c\\n\", mdata->delim);",
          "623: static void cmd_parse_lsub(struct ImapMboxData *mdata, char *s)",
          "",
          "[Added Lines]",
          "598:     if (imap_cmd_step(adata) != IMAP_CMD_CONTINUE)",
          "600:       adata->status = IMAP_FATAL;",
          "603:     list->name = adata->buf;",
          "607:     imap_unmunge_mbox_name(adata, s);",
          "613:     adata->delim = list->delim;",
          "614:     mutt_debug(3, \"Root delimiter: %c\\n\", adata->delim);",
          "623: static void cmd_parse_lsub(struct ImapAccountData *adata, char *s)",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "628:   struct Url url;",
          "629:   struct ImapList list;",
          "632:   {",
          "635:     return;",
          "636:   }",
          "638:   if (!ImapCheckSubscribed)",
          "639:     return;",
          "646:   if (!list.name || list.noselect)",
          "647:     return;",
          "",
          "[Removed Lines]",
          "631:   if (mdata->cmddata && mdata->cmdtype == IMAP_CT_LIST)",
          "634:     cmd_parse_list(mdata, s);",
          "641:   mdata->cmdtype = IMAP_CT_LIST;",
          "642:   mdata->cmddata = &list;",
          "643:   cmd_parse_list(mdata, s);",
          "644:   mdata->cmddata = NULL;",
          "",
          "[Added Lines]",
          "631:   if (adata->cmddata && adata->cmdtype == IMAP_CT_LIST)",
          "634:     cmd_parse_list(adata, s);",
          "641:   adata->cmdtype = IMAP_CT_LIST;",
          "642:   adata->cmddata = &list;",
          "643:   cmd_parse_list(adata, s);",
          "644:   adata->cmddata = NULL;",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "649:   mutt_debug(3, \"Subscribing to %s\\n\", list.name);",
          "651:   mutt_str_strfcpy(buf, \"mailboxes \\\"\", sizeof(buf));",
          "654:   imap_quote_string(errstr, sizeof(errstr), list.name, true);",
          "655:   url.path = errstr + 1;",
          "",
          "[Removed Lines]",
          "652:   mutt_account_tourl(&mdata->conn->account, &url);",
          "",
          "[Added Lines]",
          "652:   mutt_account_tourl(&adata->conn->account, &url);",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "676: {",
          "677:   mutt_debug(2, \"Handling MYRIGHTS\\n\");",
          "",
          "[Removed Lines]",
          "675: static void cmd_parse_myrights(struct ImapMboxData *mdata, const char *s)",
          "",
          "[Added Lines]",
          "675: static void cmd_parse_myrights(struct ImapAccountData *adata, const char *s)",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "680:   s = imap_next_word((char *) s);",
          "685:   while (*s && !isspace((unsigned char) *s))",
          "686:   {",
          "687:     switch (*s)",
          "688:     {",
          "689:       case 'a':",
          "691:         break;",
          "692:       case 'e':",
          "694:         break;",
          "695:       case 'i':",
          "697:         break;",
          "698:       case 'k':",
          "700:         break;",
          "701:       case 'l':",
          "703:         break;",
          "704:       case 'p':",
          "706:         break;",
          "707:       case 'r':",
          "709:         break;",
          "710:       case 's':",
          "712:         break;",
          "713:       case 't':",
          "715:         break;",
          "716:       case 'w':",
          "718:         break;",
          "719:       case 'x':",
          "721:         break;",
          "724:       case 'c':",
          "727:         break;",
          "728:       case 'd':",
          "731:         break;",
          "732:       default:",
          "733:         mutt_debug(1, \"Unknown right: %c\\n\", *s);",
          "",
          "[Removed Lines]",
          "683:   memset(mdata->ctx->mailbox->rights, 0, sizeof(mdata->ctx->mailbox->rights));",
          "690:         mutt_bit_set(mdata->ctx->mailbox->rights, MUTT_ACL_ADMIN);",
          "693:         mutt_bit_set(mdata->ctx->mailbox->rights, MUTT_ACL_EXPUNGE);",
          "696:         mutt_bit_set(mdata->ctx->mailbox->rights, MUTT_ACL_INSERT);",
          "699:         mutt_bit_set(mdata->ctx->mailbox->rights, MUTT_ACL_CREATE);",
          "702:         mutt_bit_set(mdata->ctx->mailbox->rights, MUTT_ACL_LOOKUP);",
          "705:         mutt_bit_set(mdata->ctx->mailbox->rights, MUTT_ACL_POST);",
          "708:         mutt_bit_set(mdata->ctx->mailbox->rights, MUTT_ACL_READ);",
          "711:         mutt_bit_set(mdata->ctx->mailbox->rights, MUTT_ACL_SEEN);",
          "714:         mutt_bit_set(mdata->ctx->mailbox->rights, MUTT_ACL_DELETE);",
          "717:         mutt_bit_set(mdata->ctx->mailbox->rights, MUTT_ACL_WRITE);",
          "720:         mutt_bit_set(mdata->ctx->mailbox->rights, MUTT_ACL_DELMX);",
          "725:         mutt_bit_set(mdata->ctx->mailbox->rights, MUTT_ACL_CREATE);",
          "726:         mutt_bit_set(mdata->ctx->mailbox->rights, MUTT_ACL_DELMX);",
          "729:         mutt_bit_set(mdata->ctx->mailbox->rights, MUTT_ACL_DELETE);",
          "730:         mutt_bit_set(mdata->ctx->mailbox->rights, MUTT_ACL_EXPUNGE);",
          "",
          "[Added Lines]",
          "683:   memset(adata->ctx->mailbox->rights, 0, sizeof(adata->ctx->mailbox->rights));",
          "690:         mutt_bit_set(adata->ctx->mailbox->rights, MUTT_ACL_ADMIN);",
          "693:         mutt_bit_set(adata->ctx->mailbox->rights, MUTT_ACL_EXPUNGE);",
          "696:         mutt_bit_set(adata->ctx->mailbox->rights, MUTT_ACL_INSERT);",
          "699:         mutt_bit_set(adata->ctx->mailbox->rights, MUTT_ACL_CREATE);",
          "702:         mutt_bit_set(adata->ctx->mailbox->rights, MUTT_ACL_LOOKUP);",
          "705:         mutt_bit_set(adata->ctx->mailbox->rights, MUTT_ACL_POST);",
          "708:         mutt_bit_set(adata->ctx->mailbox->rights, MUTT_ACL_READ);",
          "711:         mutt_bit_set(adata->ctx->mailbox->rights, MUTT_ACL_SEEN);",
          "714:         mutt_bit_set(adata->ctx->mailbox->rights, MUTT_ACL_DELETE);",
          "717:         mutt_bit_set(adata->ctx->mailbox->rights, MUTT_ACL_WRITE);",
          "720:         mutt_bit_set(adata->ctx->mailbox->rights, MUTT_ACL_DELMX);",
          "725:         mutt_bit_set(adata->ctx->mailbox->rights, MUTT_ACL_CREATE);",
          "726:         mutt_bit_set(adata->ctx->mailbox->rights, MUTT_ACL_DELMX);",
          "729:         mutt_bit_set(adata->ctx->mailbox->rights, MUTT_ACL_DELETE);",
          "730:         mutt_bit_set(adata->ctx->mailbox->rights, MUTT_ACL_EXPUNGE);",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "745: {",
          "746:   unsigned int uid;",
          "747:   struct Email *e = NULL;",
          "",
          "[Removed Lines]",
          "744: static void cmd_parse_search(struct ImapMboxData *mdata, const char *s)",
          "",
          "[Added Lines]",
          "744: static void cmd_parse_search(struct ImapAccountData *adata, const char *s)",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "752:   {",
          "753:     if (mutt_str_atoui(s, &uid) < 0)",
          "754:       continue;",
          "756:     if (e)",
          "757:       e->matched = true;",
          "758:   }",
          "",
          "[Removed Lines]",
          "755:     e = mutt_hash_int_find(mdata->uid_hash, uid);",
          "",
          "[Added Lines]",
          "755:     e = mutt_hash_int_find(adata->uid_hash, uid);",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "770: {",
          "771:   char *value = NULL;",
          "772:   struct ImapMbox mx;",
          "",
          "[Removed Lines]",
          "769: static void cmd_parse_status(struct ImapMboxData *mdata, char *s)",
          "",
          "[Added Lines]",
          "769: static void cmd_parse_status(struct ImapAccountData *adata, char *s)",
          "",
          "---------------",
          "--- Hunk 21 ---",
          "[Context before]",
          "782:   if (imap_get_literal_count(mailbox, &litlen) == 0)",
          "783:   {",
          "785:     {",
          "787:       return;",
          "788:     }",
          "791:     {",
          "792:       mutt_debug(1, \"Error parsing STATUS mailbox\\n\");",
          "793:       return;",
          "794:     }",
          "797:     s = mailbox + litlen;",
          "799:     s++;",
          "",
          "[Removed Lines]",
          "784:     if (imap_cmd_step(mdata) != IMAP_CMD_CONTINUE)",
          "786:       mdata->status = IMAP_FATAL;",
          "790:     if (strlen(mdata->buf) < litlen)",
          "796:     mailbox = mdata->buf;",
          "",
          "[Added Lines]",
          "784:     if (imap_cmd_step(adata) != IMAP_CMD_CONTINUE)",
          "786:       adata->status = IMAP_FATAL;",
          "790:     if (strlen(adata->buf) < litlen)",
          "796:     mailbox = adata->buf;",
          "",
          "---------------",
          "--- Hunk 22 ---",
          "[Context before]",
          "803:   {",
          "804:     s = imap_next_word(mailbox);",
          "807:   }",
          "810:   olduv = status->uidvalidity;",
          "811:   oldun = status->uidnext;",
          "",
          "[Removed Lines]",
          "806:     imap_unmunge_mbox_name(mdata, mailbox);",
          "809:   status = imap_mboxcache_get(mdata, mailbox, 1);",
          "",
          "[Added Lines]",
          "806:     imap_unmunge_mbox_name(adata, mailbox);",
          "809:   status = imap_mboxcache_get(adata, mailbox, 1);",
          "",
          "---------------",
          "--- Hunk 23 ---",
          "[Context before]",
          "851:              status->messages, status->recent, status->unseen);",
          "855:   {",
          "857:     return;",
          "858:   }",
          "",
          "[Removed Lines]",
          "854:   if (mdata->cmddata && mdata->cmdtype == IMAP_CT_STATUS)",
          "856:     memcpy(mdata->cmddata, status, sizeof(struct ImapStatus));",
          "",
          "[Added Lines]",
          "854:   if (adata->cmddata && adata->cmdtype == IMAP_CT_STATUS)",
          "856:     memcpy(adata->cmddata, status, sizeof(struct ImapStatus));",
          "",
          "---------------",
          "--- Hunk 24 ---",
          "[Context before]",
          "872:       continue;",
          "873:     }",
          "876:     {",
          "877:       if (mx.mbox)",
          "878:       {",
          "879:         value = mutt_str_strdup(mx.mbox);",
          "881:         FREE(&mx.mbox);",
          "882:       }",
          "883:       else",
          "",
          "[Removed Lines]",
          "875:     if (imap_account_match(&mdata->conn->account, &mx.account))",
          "880:         imap_fix_path(mdata, mx.mbox, value, mutt_str_strlen(value) + 1);",
          "",
          "[Added Lines]",
          "875:     if (imap_account_match(&adata->conn->account, &mx.account))",
          "880:         imap_fix_path(adata, mx.mbox, value, mutt_str_strlen(value) + 1);",
          "",
          "---------------",
          "--- Hunk 25 ---",
          "[Context before]",
          "945: {",
          "946:   mutt_debug(2, \"Handling ENABLED\\n\");",
          "",
          "[Removed Lines]",
          "944: static void cmd_parse_enabled(struct ImapMboxData *mdata, const char *s)",
          "",
          "[Added Lines]",
          "944: static void cmd_parse_enabled(struct ImapAccountData *adata, const char *s)",
          "",
          "---------------",
          "--- Hunk 26 ---",
          "[Context before]",
          "950:     if ((mutt_str_strncasecmp(s, \"UTF8=ACCEPT\", 11) == 0) ||",
          "951:         (mutt_str_strncasecmp(s, \"UTF8=ONLY\", 9) == 0))",
          "952:     {",
          "954:     }",
          "955:     if (mutt_str_strncasecmp(s, \"QRESYNC\", 7) == 0)",
          "957:   }",
          "958: }",
          "967: {",
          "968:   unsigned int count = 0;",
          "970:   char *pn = imap_next_word(s);",
          "973:   {",
          "974:     pn = s;",
          "975:     s = imap_next_word(s);",
          "",
          "[Removed Lines]",
          "953:       mdata->unicode = true;",
          "956:       mdata->qresync = true;",
          "966: static int cmd_handle_untagged(struct ImapMboxData *mdata)",
          "969:   char *s = imap_next_word(mdata->buf);",
          "972:   if ((mdata->state >= IMAP_SELECTED) && isdigit((unsigned char) *s))",
          "",
          "[Added Lines]",
          "953:       adata->unicode = true;",
          "956:       adata->qresync = true;",
          "966: static int cmd_handle_untagged(struct ImapAccountData *adata)",
          "969:   char *s = imap_next_word(adata->buf);",
          "972:   if ((adata->state >= IMAP_SELECTED) && isdigit((unsigned char) *s))",
          "",
          "---------------",
          "--- Hunk 27 ---",
          "[Context before]",
          "987:         mutt_debug(1, \"Malformed EXISTS: '%s'\\n\", pn);",
          "988:       }",
          "991:       {",
          "",
          "[Removed Lines]",
          "990:       if (!(mdata->reopen & IMAP_EXPUNGE_PENDING) && count < mdata->max_msn)",
          "",
          "[Added Lines]",
          "990:       if (!(adata->reopen & IMAP_EXPUNGE_PENDING) && count < adata->max_msn)",
          "",
          "---------------",
          "--- Hunk 28 ---",
          "[Context before]",
          "996:       }",
          "1000:         mutt_debug(3, \"superfluous EXISTS message.\\n\");",
          "1001:       else",
          "1002:       {",
          "1004:         {",
          "1007:         }",
          "1009:       }",
          "1010:     }",
          "1012:     else if (mutt_str_strncasecmp(\"EXPUNGE\", s, 7) == 0)",
          "1014:     else if (mutt_str_strncasecmp(\"FETCH\", s, 5) == 0)",
          "1016:   }",
          "1019:   else if (mutt_str_strncasecmp(\"CAPABILITY\", s, 10) == 0)",
          "1021:   else if (mutt_str_strncasecmp(\"OK [CAPABILITY\", s, 14) == 0)",
          "1023:   else if (mutt_str_strncasecmp(\"OK [CAPABILITY\", pn, 14) == 0)",
          "1025:   else if (mutt_str_strncasecmp(\"LIST\", s, 4) == 0)",
          "1027:   else if (mutt_str_strncasecmp(\"LSUB\", s, 4) == 0)",
          "1029:   else if (mutt_str_strncasecmp(\"MYRIGHTS\", s, 8) == 0)",
          "1031:   else if (mutt_str_strncasecmp(\"SEARCH\", s, 6) == 0)",
          "1033:   else if (mutt_str_strncasecmp(\"STATUS\", s, 6) == 0)",
          "1035:   else if (mutt_str_strncasecmp(\"ENABLED\", s, 7) == 0)",
          "1037:   else if (mutt_str_strncasecmp(\"BYE\", s, 3) == 0)",
          "1038:   {",
          "1039:     mutt_debug(2, \"Handling BYE\\n\");",
          "1043:       return 0;",
          "1046:     s += 3;",
          "1047:     SKIPWS(s);",
          "1048:     mutt_error(\"%s\", s);",
          "1051:     return -1;",
          "1052:   }",
          "",
          "[Removed Lines]",
          "999:       else if (count == mdata->max_msn)",
          "1003:         if (!(mdata->reopen & IMAP_EXPUNGE_PENDING))",
          "1005:           mutt_debug(2, \"New mail in %s - %d messages total.\\n\", mdata->mbox_name, count);",
          "1006:           mdata->reopen |= IMAP_NEWMAIL_PENDING;",
          "1008:         mdata->new_mail_count = count;",
          "1013:       cmd_parse_expunge(mdata, pn);",
          "1015:       cmd_parse_fetch(mdata, pn);",
          "1017:   else if ((mdata->state >= IMAP_SELECTED) && (mutt_str_strncasecmp(\"VANISHED\", s, 8) == 0))",
          "1018:     cmd_parse_vanished(mdata, pn);",
          "1020:     cmd_parse_capability(mdata, s);",
          "1022:     cmd_parse_capability(mdata, pn);",
          "1024:     cmd_parse_capability(mdata, imap_next_word(pn));",
          "1026:     cmd_parse_list(mdata, s);",
          "1028:     cmd_parse_lsub(mdata, s);",
          "1030:     cmd_parse_myrights(mdata, s);",
          "1032:     cmd_parse_search(mdata, s);",
          "1034:     cmd_parse_status(mdata, s);",
          "1036:     cmd_parse_enabled(mdata, s);",
          "1042:     if (mdata->status == IMAP_BYE)",
          "1049:     cmd_handle_fatal(mdata);",
          "",
          "[Added Lines]",
          "999:       else if (count == adata->max_msn)",
          "1003:         if (!(adata->reopen & IMAP_EXPUNGE_PENDING))",
          "1005:           mutt_debug(2, \"New mail in %s - %d messages total.\\n\", adata->mbox_name, count);",
          "1006:           adata->reopen |= IMAP_NEWMAIL_PENDING;",
          "1008:         adata->new_mail_count = count;",
          "1013:       cmd_parse_expunge(adata, pn);",
          "1015:       cmd_parse_fetch(adata, pn);",
          "1017:   else if ((adata->state >= IMAP_SELECTED) && (mutt_str_strncasecmp(\"VANISHED\", s, 8) == 0))",
          "1018:     cmd_parse_vanished(adata, pn);",
          "1020:     cmd_parse_capability(adata, s);",
          "1022:     cmd_parse_capability(adata, pn);",
          "1024:     cmd_parse_capability(adata, imap_next_word(pn));",
          "1026:     cmd_parse_list(adata, s);",
          "1028:     cmd_parse_lsub(adata, s);",
          "1030:     cmd_parse_myrights(adata, s);",
          "1032:     cmd_parse_search(adata, s);",
          "1034:     cmd_parse_status(adata, s);",
          "1036:     cmd_parse_enabled(adata, s);",
          "1042:     if (adata->status == IMAP_BYE)",
          "1049:     cmd_handle_fatal(adata);",
          "",
          "---------------",
          "--- Hunk 29 ---",
          "[Context before]",
          "1074: {",
          "1076: }",
          "1088: {",
          "1089:   size_t len = 0;",
          "1090:   int c;",
          "",
          "[Removed Lines]",
          "1073: int imap_cmd_start(struct ImapMboxData *mdata, const char *cmdstr)",
          "1075:   return cmd_start(mdata, cmdstr, 0);",
          "1087: int imap_cmd_step(struct ImapMboxData *mdata)",
          "",
          "[Added Lines]",
          "1073: int imap_cmd_start(struct ImapAccountData *adata, const char *cmdstr)",
          "1075:   return cmd_start(adata, cmdstr, 0);",
          "1087: int imap_cmd_step(struct ImapAccountData *adata)",
          "",
          "---------------",
          "--- Hunk 30 ---",
          "[Context before]",
          "1092:   int stillrunning = 0;",
          "1093:   struct ImapCommand *cmd = NULL;",
          "1096:   {",
          "1098:     return IMAP_CMD_BAD;",
          "1099:   }",
          "",
          "[Removed Lines]",
          "1095:   if (mdata->status == IMAP_FATAL)",
          "1097:     cmd_handle_fatal(mdata);",
          "",
          "[Added Lines]",
          "1095:   if (adata->status == IMAP_FATAL)",
          "1097:     cmd_handle_fatal(adata);",
          "",
          "---------------",
          "--- Hunk 31 ---",
          "[Context before]",
          "1103:   do",
          "1104:   {",
          "1106:     {",
          "1110:     }",
          "1113:     if (len)",
          "1114:       len--;",
          "1116:     if (c <= 0)",
          "1117:     {",
          "1118:       mutt_debug(1, \"Error reading server response.\\n\");",
          "1120:       return IMAP_CMD_BAD;",
          "1121:     }",
          "",
          "[Removed Lines]",
          "1105:     if (len == mdata->blen)",
          "1107:       mutt_mem_realloc(&mdata->buf, mdata->blen + IMAP_CMD_BUFSIZE);",
          "1108:       mdata->blen = mdata->blen + IMAP_CMD_BUFSIZE;",
          "1109:       mutt_debug(3, \"grew buffer to %u bytes\\n\", mdata->blen);",
          "1115:     c = mutt_socket_readln(mdata->buf + len, mdata->blen - len, mdata->conn);",
          "1119:       cmd_handle_fatal(mdata);",
          "",
          "[Added Lines]",
          "1105:     if (len == adata->blen)",
          "1107:       mutt_mem_realloc(&adata->buf, adata->blen + IMAP_CMD_BUFSIZE);",
          "1108:       adata->blen = adata->blen + IMAP_CMD_BUFSIZE;",
          "1109:       mutt_debug(3, \"grew buffer to %u bytes\\n\", adata->blen);",
          "1115:     c = mutt_socket_readln(adata->buf + len, adata->blen - len, adata->conn);",
          "1119:       cmd_handle_fatal(adata);",
          "",
          "---------------",
          "--- Hunk 32 ---",
          "[Context before]",
          "1132:   {",
          "1136:   }",
          "1144:   {",
          "1145:     return IMAP_CMD_BAD;",
          "1146:   }",
          "1150:     return IMAP_CMD_RESPOND;",
          "",
          "[Removed Lines]",
          "1128:   while (len == mdata->blen);",
          "1131:   if ((mdata->blen > IMAP_CMD_BUFSIZE) && (len <= IMAP_CMD_BUFSIZE))",
          "1133:     mutt_mem_realloc(&mdata->buf, IMAP_CMD_BUFSIZE);",
          "1134:     mdata->blen = IMAP_CMD_BUFSIZE;",
          "1135:     mutt_debug(3, \"shrank buffer to %u bytes\\n\", mdata->blen);",
          "1138:   mdata->lastread = time(NULL);",
          "1141:   if (((mutt_str_strncmp(mdata->buf, \"* \", 2) == 0) ||",
          "1142:        (mutt_str_strncmp(imap_next_word(mdata->buf), \"OK [\", 4) == 0)) &&",
          "1143:       cmd_handle_untagged(mdata))",
          "1149:   if (mdata->buf[0] == '+')",
          "",
          "[Added Lines]",
          "1128:   while (len == adata->blen);",
          "1131:   if ((adata->blen > IMAP_CMD_BUFSIZE) && (len <= IMAP_CMD_BUFSIZE))",
          "1133:     mutt_mem_realloc(&adata->buf, IMAP_CMD_BUFSIZE);",
          "1134:     adata->blen = IMAP_CMD_BUFSIZE;",
          "1135:     mutt_debug(3, \"shrank buffer to %u bytes\\n\", adata->blen);",
          "1138:   adata->lastread = time(NULL);",
          "1141:   if (((mutt_str_strncmp(adata->buf, \"* \", 2) == 0) ||",
          "1142:        (mutt_str_strncmp(imap_next_word(adata->buf), \"OK [\", 4) == 0)) &&",
          "1143:       cmd_handle_untagged(adata))",
          "1149:   if (adata->buf[0] == '+')",
          "",
          "---------------",
          "--- Hunk 33 ---",
          "[Context before]",
          "1162:   rc = IMAP_CMD_OK;",
          "1164:   do",
          "1165:   {",
          "1167:     if (cmd->state == IMAP_CMD_NEW)",
          "1168:     {",
          "1170:       {",
          "1171:         if (!stillrunning)",
          "1172:         {",
          "1175:         }",
          "1179:         rc = cmd->state;",
          "",
          "[Removed Lines]",
          "1163:   c = mdata->lastcmd;",
          "1166:     cmd = &mdata->cmds[c];",
          "1169:       if (mutt_str_strncmp(mdata->buf, cmd->seq, SEQLEN) == 0)",
          "1174:           mdata->lastcmd = (mdata->lastcmd + 1) % mdata->cmdslots;",
          "1176:         cmd->state = cmd_status(mdata->buf);",
          "",
          "[Added Lines]",
          "1163:   c = adata->lastcmd;",
          "1166:     cmd = &adata->cmds[c];",
          "1169:       if (mutt_str_strncmp(adata->buf, cmd->seq, SEQLEN) == 0)",
          "1174:           adata->lastcmd = (adata->lastcmd + 1) % adata->cmdslots;",
          "1176:         cmd->state = cmd_status(adata->buf);",
          "",
          "---------------",
          "--- Hunk 34 ---",
          "[Context before]",
          "1182:         stillrunning++;",
          "1183:     }",
          "1188:   if (stillrunning)",
          "1189:     rc = IMAP_CMD_CONTINUE;",
          "1190:   else",
          "1191:   {",
          "1192:     mutt_debug(3, \"IMAP queue drained\\n\");",
          "1194:   }",
          "1196:   return rc;",
          "",
          "[Removed Lines]",
          "1185:     c = (c + 1) % mdata->cmdslots;",
          "1186:   } while (c != mdata->nextcmd);",
          "1193:     imap_cmd_finish(mdata);",
          "",
          "[Added Lines]",
          "1185:     c = (c + 1) % adata->cmdslots;",
          "1186:   } while (c != adata->nextcmd);",
          "1193:     imap_cmd_finish(adata);",
          "",
          "---------------",
          "--- Hunk 35 ---",
          "[Context before]",
          "1217: {",
          "1218:   static const char *notrailer = \"\";",
          "1221:   if (!s)",
          "1222:   {",
          "",
          "[Removed Lines]",
          "1216: const char *imap_cmd_trailer(struct ImapMboxData *mdata)",
          "1219:   const char *s = mdata->buf;",
          "",
          "[Added Lines]",
          "1216: const char *imap_cmd_trailer(struct ImapAccountData *adata)",
          "1219:   const char *s = adata->buf;",
          "",
          "---------------",
          "--- Hunk 36 ---",
          "[Context before]",
          "1229:              (mutt_str_strncasecmp(s, \"NO\", 2) != 0) &&",
          "1230:              (mutt_str_strncasecmp(s, \"BAD\", 3) != 0)))",
          "1231:   {",
          "1233:     return notrailer;",
          "1234:   }",
          "",
          "[Removed Lines]",
          "1232:     mutt_debug(2, \"not a command completion: %s\\n\", mdata->buf);",
          "",
          "[Added Lines]",
          "1232:     mutt_debug(2, \"not a command completion: %s\\n\", adata->buf);",
          "",
          "---------------",
          "--- Hunk 37 ---",
          "[Context before]",
          "1262: {",
          "1263:   int rc;",
          "1266:   if (rc < 0)",
          "1267:   {",
          "1269:     return -1;",
          "1270:   }",
          "",
          "[Removed Lines]",
          "1261: int imap_exec(struct ImapMboxData *mdata, const char *cmdstr, int flags)",
          "1265:   rc = cmd_start(mdata, cmdstr, flags);",
          "1268:     cmd_handle_fatal(mdata);",
          "",
          "[Added Lines]",
          "1261: int imap_exec(struct ImapAccountData *adata, const char *cmdstr, int flags)",
          "1265:   rc = cmd_start(adata, cmdstr, flags);",
          "1268:     cmd_handle_fatal(adata);",
          "",
          "---------------",
          "--- Hunk 38 ---",
          "[Context before]",
          "1273:     return 0;",
          "1275:   if ((flags & IMAP_CMD_POLL) && (ImapPollTimeout > 0) &&",
          "1277:   {",
          "1280:     return -1;",
          "1281:   }",
          "1284:   mutt_sig_allow_interrupt(1);",
          "1285:   do",
          "1287:   while (rc == IMAP_CMD_CONTINUE);",
          "1288:   mutt_sig_allow_interrupt(0);",
          "",
          "[Removed Lines]",
          "1276:       (mutt_socket_poll(mdata->conn, ImapPollTimeout)) == 0)",
          "1278:     mutt_error(_(\"Connection to %s timed out\"), mdata->conn->account.host);",
          "1279:     cmd_handle_fatal(mdata);",
          "1286:     rc = imap_cmd_step(mdata);",
          "",
          "[Added Lines]",
          "1276:       (mutt_socket_poll(adata->conn, ImapPollTimeout)) == 0)",
          "1278:     mutt_error(_(\"Connection to %s timed out\"), adata->conn->account.host);",
          "1279:     cmd_handle_fatal(adata);",
          "1286:     rc = imap_cmd_step(adata);",
          "",
          "---------------",
          "--- Hunk 39 ---",
          "[Context before]",
          "1293:   if (rc != IMAP_CMD_OK)",
          "1294:   {",
          "1296:       return -2;",
          "1299:     return -1;",
          "1300:   }",
          "",
          "[Removed Lines]",
          "1295:     if ((flags & IMAP_CMD_FAIL_OK) && mdata->status != IMAP_FATAL)",
          "1298:     mutt_debug(1, \"command failed: %s\\n\", mdata->buf);",
          "",
          "[Added Lines]",
          "1295:     if ((flags & IMAP_CMD_FAIL_OK) && adata->status != IMAP_FATAL)",
          "1298:     mutt_debug(1, \"command failed: %s\\n\", adata->buf);",
          "",
          "---------------",
          "--- Hunk 40 ---",
          "[Context before]",
          "1315: {",
          "1317:   {",
          "1319:     return;",
          "1320:   }",
          "1323:     return;",
          "1326:   {",
          "1331:     {",
          "1333:       mutt_debug(2, \"Fetching new mail\\n\");",
          "1338:     }",
          "1340:     {",
          "1341:       mutt_debug(2, \"Expunging mailbox\\n\");",
          "1347:           ~(IMAP_EXPUNGE_PENDING | IMAP_NEWMAIL_PENDING | IMAP_EXPUNGE_EXPECTED);",
          "1348:     }",
          "1349:   }",
          "1352: }",
          "1361: {",
          "1362:   int rc;",
          "1365:   {",
          "1367:     return -1;",
          "1368:   }",
          "1371:   {",
          "1374:     return -1;",
          "1375:   }",
          "1377:   do",
          "1379:   while (rc == IMAP_CMD_CONTINUE);",
          "1381:   if (rc == IMAP_CMD_RESPOND)",
          "1382:   {",
          "1387:     rc = IMAP_CMD_OK;",
          "1388:   }",
          "1389:   if (rc != IMAP_CMD_OK)",
          "",
          "[Removed Lines]",
          "1314: void imap_cmd_finish(struct ImapMboxData *mdata)",
          "1316:   if (mdata->status == IMAP_FATAL)",
          "1318:     cmd_handle_fatal(mdata);",
          "1322:   if (!(mdata->state >= IMAP_SELECTED) || mdata->ctx->mailbox->closing)",
          "1325:   if (mdata->reopen & IMAP_REOPEN_ALLOW)",
          "1327:     unsigned int count = mdata->new_mail_count;",
          "1329:     if (!(mdata->reopen & IMAP_EXPUNGE_PENDING) &&",
          "1330:         (mdata->reopen & IMAP_NEWMAIL_PENDING) && count > mdata->max_msn)",
          "1336:       mdata->check_status = IMAP_NEWMAIL_PENDING;",
          "1337:       imap_read_headers(mdata, mdata->max_msn + 1, count, false);",
          "1339:     else if (mdata->reopen & IMAP_EXPUNGE_PENDING)",
          "1342:       imap_expunge_mailbox(mdata);",
          "1344:       if ((mdata->reopen & IMAP_EXPUNGE_PENDING) && !(mdata->reopen & IMAP_EXPUNGE_EXPECTED))",
          "1345:         mdata->check_status = IMAP_EXPUNGE_PENDING;",
          "1346:       mdata->reopen &=",
          "1351:   mdata->status = 0;",
          "1360: int imap_cmd_idle(struct ImapMboxData *mdata)",
          "1364:   if (cmd_start(mdata, \"IDLE\", IMAP_CMD_POLL) < 0)",
          "1366:     cmd_handle_fatal(mdata);",
          "1370:   if ((ImapPollTimeout > 0) && (mutt_socket_poll(mdata->conn, ImapPollTimeout)) == 0)",
          "1372:     mutt_error(_(\"Connection to %s timed out\"), mdata->conn->account.host);",
          "1373:     cmd_handle_fatal(mdata);",
          "1378:     rc = imap_cmd_step(mdata);",
          "1384:     mdata->state = IMAP_IDLE;",
          "1386:     mutt_buffer_printf(mdata->cmdbuf, \"DONE\\r\\n\");",
          "",
          "[Added Lines]",
          "1314: void imap_cmd_finish(struct ImapAccountData *adata)",
          "1316:   if (adata->status == IMAP_FATAL)",
          "1318:     cmd_handle_fatal(adata);",
          "1322:   if (!(adata->state >= IMAP_SELECTED) || adata->ctx->mailbox->closing)",
          "1325:   if (adata->reopen & IMAP_REOPEN_ALLOW)",
          "1327:     unsigned int count = adata->new_mail_count;",
          "1329:     if (!(adata->reopen & IMAP_EXPUNGE_PENDING) &&",
          "1330:         (adata->reopen & IMAP_NEWMAIL_PENDING) && count > adata->max_msn)",
          "1336:       adata->check_status = IMAP_NEWMAIL_PENDING;",
          "1337:       imap_read_headers(adata, adata->max_msn + 1, count, false);",
          "1339:     else if (adata->reopen & IMAP_EXPUNGE_PENDING)",
          "1342:       imap_expunge_mailbox(adata);",
          "1344:       if ((adata->reopen & IMAP_EXPUNGE_PENDING) && !(adata->reopen & IMAP_EXPUNGE_EXPECTED))",
          "1345:         adata->check_status = IMAP_EXPUNGE_PENDING;",
          "1346:       adata->reopen &=",
          "1351:   adata->status = 0;",
          "1360: int imap_cmd_idle(struct ImapAccountData *adata)",
          "1364:   if (cmd_start(adata, \"IDLE\", IMAP_CMD_POLL) < 0)",
          "1366:     cmd_handle_fatal(adata);",
          "1370:   if ((ImapPollTimeout > 0) && (mutt_socket_poll(adata->conn, ImapPollTimeout)) == 0)",
          "1372:     mutt_error(_(\"Connection to %s timed out\"), adata->conn->account.host);",
          "1373:     cmd_handle_fatal(adata);",
          "1378:     rc = imap_cmd_step(adata);",
          "1384:     adata->state = IMAP_IDLE;",
          "1386:     mutt_buffer_printf(adata->cmdbuf, \"DONE\\r\\n\");",
          "",
          "---------------"
        ],
        "imap/imap.c||imap/imap.c": [
          "File: imap/imap.c -> imap/imap.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "78: {",
          "80:   {",
          "82:     return -1;",
          "83:   }",
          "87:   {",
          "88:     mutt_error(",
          "89:         _(\"This IMAP server is ancient. NeoMutt does not work with it.\"));",
          "",
          "[Removed Lines]",
          "77: static int check_capabilities(struct ImapMboxData *mdata)",
          "79:   if (imap_exec(mdata, \"CAPABILITY\", 0) != 0)",
          "81:     imap_error(\"check_capabilities\", mdata->buf);",
          "85:   if (!(mutt_bit_isset(mdata->capabilities, IMAP4) ||",
          "86:         mutt_bit_isset(mdata->capabilities, IMAP4REV1)))",
          "",
          "[Added Lines]",
          "77: static int check_capabilities(struct ImapAccountData *adata)",
          "79:   if (imap_exec(adata, \"CAPABILITY\", 0) != 0)",
          "81:     imap_error(\"check_capabilities\", adata->buf);",
          "85:   if (!(mutt_bit_isset(adata->capabilities, IMAP4) ||",
          "86:         mutt_bit_isset(adata->capabilities, IMAP4REV1)))",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "160:                      const char *str, char *flags, size_t flsize)",
          "161: {",
          "164:       mutt_str_strcat(flags, flsize, str);",
          "165: }",
          "",
          "[Removed Lines]",
          "159: static void set_flag(struct ImapMboxData *mdata, int aclbit, int flag,",
          "162:   if (mutt_bit_isset(mdata->ctx->mailbox->rights, aclbit))",
          "163:     if (flag && imap_has_flag(&mdata->flags, str))",
          "",
          "[Added Lines]",
          "159: static void set_flag(struct ImapAccountData *adata, int aclbit, int flag,",
          "162:   if (mutt_bit_isset(adata->ctx->mailbox->rights, aclbit))",
          "163:     if (flag && imap_has_flag(&adata->flags, str))",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "181:                         int flag, bool changed, bool invert, int *pos)",
          "182: {",
          "185:   int n;",
          "186:   bool started = false;",
          "190:        n++)",
          "191:   {",
          "",
          "[Removed Lines]",
          "180: static int make_msg_set(struct ImapMboxData *mdata, struct Buffer *buf,",
          "187:   struct Email **emails = mdata->ctx->mailbox->hdrs;",
          "189:   for (n = *pos; n < mdata->ctx->mailbox->msg_count && buf->dptr - buf->data < IMAP_MAX_CMDLEN;",
          "",
          "[Added Lines]",
          "180: static int make_msg_set(struct ImapAccountData *adata, struct Buffer *buf,",
          "187:   struct Email **emails = adata->ctx->mailbox->hdrs;",
          "189:   for (n = *pos; n < adata->ctx->mailbox->msg_count && buf->dptr - buf->data < IMAP_MAX_CMDLEN;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "241:           mutt_buffer_printf(buf, \",%u\", IMAP_EDATA(emails[n])->uid);",
          "242:       }",
          "245:         mutt_buffer_printf(buf, \":%u\", IMAP_EDATA(emails[n])->uid);",
          "246:     }",
          "250:     {",
          "251:       if (IMAP_EDATA(emails[n - 1])->uid > setstart)",
          "252:         mutt_buffer_printf(buf, \":%u\", IMAP_EDATA(emails[n - 1])->uid);",
          "",
          "[Removed Lines]",
          "244:       else if (n == mdata->ctx->mailbox->msg_count - 1)",
          "249:     else if (setstart && (emails[n]->active || n == mdata->ctx->mailbox->msg_count - 1))",
          "",
          "[Added Lines]",
          "244:       else if (n == adata->ctx->mailbox->msg_count - 1)",
          "249:     else if (setstart && (emails[n]->active || n == adata->ctx->mailbox->msg_count - 1))",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "296: {",
          "297:   int count = 0;",
          "298:   int rc;",
          "299:   char buf[LONG_STRING];",
          "302:     return -1;",
          "305:     return 0;",
          "308:     return 0;",
          "310:   snprintf(buf, sizeof(buf), \"+FLAGS.SILENT (%s)\", name);",
          "312:   if (rc < 0)",
          "313:     return rc;",
          "314:   count += rc;",
          "316:   buf[0] = '-';",
          "318:   if (rc < 0)",
          "319:     return rc;",
          "320:   count += rc;",
          "",
          "[Removed Lines]",
          "295: static int sync_helper(struct ImapMboxData *mdata, int right, int flag, const char *name)",
          "301:   if (!mdata->ctx)",
          "304:   if (!mutt_bit_isset(mdata->ctx->mailbox->rights, right))",
          "307:   if (right == MUTT_ACL_WRITE && !imap_has_flag(&mdata->flags, name))",
          "311:   rc = imap_exec_msgset(mdata, \"UID STORE\", buf, flag, true, false);",
          "317:   rc = imap_exec_msgset(mdata, \"UID STORE\", buf, flag, true, true);",
          "",
          "[Added Lines]",
          "295: static int sync_helper(struct ImapAccountData *adata, int right, int flag, const char *name)",
          "301:   if (!adata->ctx)",
          "304:   if (!mutt_bit_isset(adata->ctx->mailbox->rights, right))",
          "307:   if (right == MUTT_ACL_WRITE && !imap_has_flag(&adata->flags, name))",
          "311:   rc = imap_exec_msgset(adata, \"UID STORE\", buf, flag, true, false);",
          "317:   rc = imap_exec_msgset(adata, \"UID STORE\", buf, flag, true, true);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "338: {",
          "339:   struct ImapMbox mx;",
          "",
          "[Removed Lines]",
          "337: static int get_mailbox(const char *path, struct ImapMboxData **hidata, char *buf, size_t buflen)",
          "",
          "[Added Lines]",
          "337: static int get_mailbox(const char *path, struct ImapAccountData **hidata, char *buf, size_t buflen)",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "490:         break;",
          "491:       case MUTT_SERVERSEARCH:",
          "492:       {",
          "495:         {",
          "496:           mutt_error(_(\"Server-side custom search not supported: %s\"), pat->p.str);",
          "497:           return -1;",
          "",
          "[Removed Lines]",
          "493:         struct ImapMboxData *mdata = mailbox->data;",
          "494:         if (!mutt_bit_isset(mdata->capabilities, X_GM_EXT1))",
          "",
          "[Added Lines]",
          "493:         struct ImapAccountData *adata = mailbox->data;",
          "494:         if (!mutt_bit_isset(adata->capabilities, X_GM_EXT1))",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "599: int imap_access(const char *path)",
          "600: {",
          "602:   struct ImapMbox mx;",
          "603:   char buf[LONG_STRING * 2];",
          "604:   char mailbox[LONG_STRING];",
          "",
          "[Removed Lines]",
          "601:   struct ImapMboxData *mdata = NULL;",
          "",
          "[Added Lines]",
          "601:   struct ImapAccountData *adata = NULL;",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "608:   if (imap_parse_path(path, &mx))",
          "609:     return -1;",
          "613:   {",
          "614:     FREE(&mx.mbox);",
          "615:     return -1;",
          "616:   }",
          "619:   if (!*mailbox)",
          "620:     mutt_str_strfcpy(mailbox, \"INBOX\", sizeof(mailbox));",
          "624:   {",
          "625:     FREE(&mx.mbox);",
          "626:     return 0;",
          "627:   }",
          "628:   FREE(&mx.mbox);",
          "631:   {",
          "632:     mutt_debug(3, \"found %s in cache\\n\", mailbox);",
          "633:     return 0;",
          "634:   }",
          "639:     snprintf(buf, sizeof(buf), \"STATUS %s (UIDVALIDITY)\", mbox);",
          "641:     snprintf(buf, sizeof(buf), \"STATUS %s (UID-VALIDITY)\", mbox);",
          "642:   else",
          "643:   {",
          "",
          "[Removed Lines]",
          "611:   mdata = imap_conn_find(&mx.account, ImapPassive ? MUTT_IMAP_CONN_NONEW : 0);",
          "612:   if (!mdata)",
          "618:   imap_fix_path(mdata, mx.mbox, mailbox, sizeof(mailbox));",
          "623:   if (mutt_str_strcmp(mdata->mbox_name, mx.mbox) == 0)",
          "630:   if (imap_mboxcache_get(mdata, mailbox, false))",
          "636:   imap_munge_mbox_name(mdata, mbox, sizeof(mbox), mailbox);",
          "638:   if (mutt_bit_isset(mdata->capabilities, IMAP4REV1))",
          "640:   else if (mutt_bit_isset(mdata->capabilities, STATUS))",
          "",
          "[Added Lines]",
          "611:   adata = imap_conn_find(&mx.account, ImapPassive ? MUTT_IMAP_CONN_NONEW : 0);",
          "612:   if (!adata)",
          "618:   imap_fix_path(adata, mx.mbox, mailbox, sizeof(mailbox));",
          "623:   if (mutt_str_strcmp(adata->mbox_name, mx.mbox) == 0)",
          "630:   if (imap_mboxcache_get(adata, mailbox, false))",
          "636:   imap_munge_mbox_name(adata, mbox, sizeof(mbox), mailbox);",
          "638:   if (mutt_bit_isset(adata->capabilities, IMAP4REV1))",
          "640:   else if (mutt_bit_isset(adata->capabilities, STATUS))",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "645:     return -1;",
          "646:   }",
          "649:   if (rc < 0)",
          "650:   {",
          "651:     mutt_debug(1, \"Can't check STATUS of %s\\n\", mbox);",
          "",
          "[Removed Lines]",
          "648:   rc = imap_exec(mdata, buf, IMAP_CMD_FAIL_OK);",
          "",
          "[Added Lines]",
          "648:   rc = imap_exec(adata, buf, IMAP_CMD_FAIL_OK);",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "666: {",
          "667:   char buf[LONG_STRING * 2], mbox[LONG_STRING];",
          "670:   snprintf(buf, sizeof(buf), \"CREATE %s\", mbox);",
          "673:   {",
          "675:     return -1;",
          "676:   }",
          "",
          "[Removed Lines]",
          "665: int imap_create_mailbox(struct ImapMboxData *mdata, char *mailbox)",
          "669:   imap_munge_mbox_name(mdata, mbox, sizeof(mbox), mailbox);",
          "672:   if (imap_exec(mdata, buf, 0) != 0)",
          "674:     mutt_error(_(\"CREATE failed: %s\"), imap_cmd_trailer(mdata));",
          "",
          "[Added Lines]",
          "665: int imap_create_mailbox(struct ImapAccountData *adata, char *mailbox)",
          "669:   imap_munge_mbox_name(adata, mbox, sizeof(mbox), mailbox);",
          "672:   if (imap_exec(adata, buf, 0) != 0)",
          "674:     mutt_error(_(\"CREATE failed: %s\"), imap_cmd_trailer(adata));",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "690: {",
          "691:   char oldmbox[LONG_STRING];",
          "692:   char newmbox[LONG_STRING];",
          "693:   int rc = 0;",
          "698:   struct Buffer *b = mutt_buffer_alloc(LONG_STRING);",
          "699:   mutt_buffer_printf(b, \"RENAME %s %s\", oldmbox, newmbox);",
          "702:     rc = -1;",
          "704:   mutt_buffer_free(&b);",
          "",
          "[Removed Lines]",
          "689: int imap_rename_mailbox(struct ImapMboxData *mdata, struct ImapMbox *mx, const char *newname)",
          "695:   imap_munge_mbox_name(mdata, oldmbox, sizeof(oldmbox), mx->mbox);",
          "696:   imap_munge_mbox_name(mdata, newmbox, sizeof(newmbox), newname);",
          "701:   if (imap_exec(mdata, b->data, 0) != 0)",
          "",
          "[Added Lines]",
          "689: int imap_rename_mailbox(struct ImapAccountData *adata, struct ImapMbox *mx, const char *newname)",
          "695:   imap_munge_mbox_name(adata, oldmbox, sizeof(oldmbox), mx->mbox);",
          "696:   imap_munge_mbox_name(adata, newmbox, sizeof(newmbox), newname);",
          "701:   if (imap_exec(adata, b->data, 0) != 0)",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "716: int imap_delete_mailbox(struct Mailbox *mailbox, struct ImapMbox *mx)",
          "717: {",
          "718:   char buf[PATH_MAX], mbox[PATH_MAX];",
          "721:   if (!mailbox || !mailbox->data)",
          "722:   {",
          "725:     {",
          "726:       FREE(&mx->mbox);",
          "727:       return -1;",
          "",
          "[Removed Lines]",
          "719:   struct ImapMboxData *mdata = NULL;",
          "723:     mdata = imap_conn_find(&mx->account, ImapPassive ? MUTT_IMAP_CONN_NONEW : 0);",
          "724:     if (!mdata)",
          "",
          "[Added Lines]",
          "719:   struct ImapAccountData *adata = NULL;",
          "723:     adata = imap_conn_find(&mx->account, ImapPassive ? MUTT_IMAP_CONN_NONEW : 0);",
          "724:     if (!adata)",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "729:   }",
          "730:   else",
          "731:   {",
          "733:   }",
          "736:   snprintf(buf, sizeof(buf), \"DELETE %s\", mbox);",
          "739:     return -1;",
          "741:   return 0;",
          "",
          "[Removed Lines]",
          "732:     mdata = mailbox->data;",
          "735:   imap_munge_mbox_name(mdata, mbox, sizeof(mbox), mx->mbox);",
          "738:   if (imap_exec(mdata, buf, 0) != 0)",
          "",
          "[Added Lines]",
          "732:     adata = mailbox->data;",
          "735:   imap_munge_mbox_name(adata, mbox, sizeof(mbox), mx->mbox);",
          "738:   if (imap_exec(adata, buf, 0) != 0)",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "756:     {",
          "757:       TAILQ_REMOVE(head, np, entries);",
          "758:       mutt_message(_(\"Closing connection to %s...\"), np->account.host);",
          "760:       mutt_clear_error();",
          "761:       mutt_socket_free(np);",
          "762:     }",
          "",
          "[Removed Lines]",
          "759:       imap_logout((struct ImapMboxData **) (void *) &np->data);",
          "",
          "[Added Lines]",
          "759:       imap_logout((struct ImapAccountData **) (void *) &np->data);",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "781:                       struct Progress *pbar)",
          "782: {",
          "783:   char c;",
          "",
          "[Removed Lines]",
          "780: int imap_read_literal(FILE *fp, struct ImapMboxData *mdata, unsigned long bytes,",
          "",
          "[Added Lines]",
          "780: int imap_read_literal(FILE *fp, struct ImapAccountData *adata, unsigned long bytes,",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "792:   for (unsigned long pos = 0; pos < bytes; pos++)",
          "793:   {",
          "795:     {",
          "796:       mutt_debug(1, \"error during read, %ld bytes read\\n\", pos);",
          "799:       mutt_buffer_free(&buf);",
          "800:       return -1;",
          "",
          "[Removed Lines]",
          "794:     if (mutt_socket_readchar(mdata->conn, &c) != 1)",
          "797:       mdata->status = IMAP_FATAL;",
          "",
          "[Added Lines]",
          "794:     if (mutt_socket_readchar(adata->conn, &c) != 1)",
          "797:       adata->status = IMAP_FATAL;",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "839: {",
          "840:   struct Email *e = NULL;",
          "841:   int cacheno;",
          "842:   short old_sort;",
          "844: #ifdef USE_HCACHE",
          "846: #endif",
          "848:   old_sort = Sort;",
          "849:   Sort = SORT_ORDER;",
          "853:   {",
          "856:     if (e->index == INT_MAX)",
          "857:     {",
          "858:       mutt_debug(2, \"Expunging message UID %u.\\n\", IMAP_EDATA(e)->uid);",
          "860:       e->active = false;",
          "864: #ifdef USE_HCACHE",
          "866: #endif",
          "869:       cacheno = IMAP_EDATA(e)->uid % IMAP_CACHE_LEN;",
          "872:       {",
          "875:       }",
          "879:       imap_free_emaildata((void **) &e->data);",
          "880:     }",
          "",
          "[Removed Lines]",
          "838: void imap_expunge_mailbox(struct ImapMboxData *mdata)",
          "845:   mdata->hcache = imap_hcache_open(mdata, NULL);",
          "850:   mutt_sort_headers(mdata->ctx, false);",
          "852:   for (int i = 0; i < mdata->ctx->mailbox->msg_count; i++)",
          "854:     e = mdata->ctx->mailbox->hdrs[i];",
          "861:       mdata->ctx->mailbox->size -= e->content->length;",
          "863:       imap_cache_del(mdata, e);",
          "865:       imap_hcache_del(mdata, IMAP_EDATA(e)->uid);",
          "870:       if (mdata->cache[cacheno].uid == IMAP_EDATA(e)->uid &&",
          "871:           mdata->cache[cacheno].path)",
          "873:         unlink(mdata->cache[cacheno].path);",
          "874:         FREE(&mdata->cache[cacheno].path);",
          "877:       mutt_hash_int_delete(mdata->uid_hash, IMAP_EDATA(e)->uid, e);",
          "",
          "[Added Lines]",
          "838: void imap_expunge_mailbox(struct ImapAccountData *adata)",
          "845:   adata->hcache = imap_hcache_open(adata, NULL);",
          "850:   mutt_sort_headers(adata->ctx, false);",
          "852:   for (int i = 0; i < adata->ctx->mailbox->msg_count; i++)",
          "854:     e = adata->ctx->mailbox->hdrs[i];",
          "861:       adata->ctx->mailbox->size -= e->content->length;",
          "863:       imap_cache_del(adata, e);",
          "865:       imap_hcache_del(adata, IMAP_EDATA(e)->uid);",
          "870:       if (adata->cache[cacheno].uid == IMAP_EDATA(e)->uid &&",
          "871:           adata->cache[cacheno].path)",
          "873:         unlink(adata->cache[cacheno].path);",
          "874:         FREE(&adata->cache[cacheno].path);",
          "877:       mutt_hash_int_delete(adata->uid_hash, IMAP_EDATA(e)->uid, e);",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "902:   }",
          "904: #ifdef USE_HCACHE",
          "906: #endif",
          "911:   Sort = old_sort;",
          "913: }",
          "",
          "[Removed Lines]",
          "905:   imap_hcache_close(mdata);",
          "910:   mx_update_tables(mdata->ctx, false);",
          "912:   mutt_sort_headers(mdata->ctx, true);",
          "",
          "[Added Lines]",
          "905:   imap_hcache_close(adata);",
          "910:   mx_update_tables(adata->ctx, false);",
          "912:   mutt_sort_headers(adata->ctx, true);",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "926: {",
          "927:   struct Connection *conn = NULL;",
          "928:   struct ConnAccount *creds = NULL;",
          "930:   bool new = false;",
          "932:   while ((conn = mutt_conn_find(conn, account)))",
          "",
          "[Removed Lines]",
          "925: struct ImapMboxData *imap_conn_find(const struct ConnAccount *account, int flags)",
          "929:   struct ImapMboxData *mdata = NULL;",
          "",
          "[Added Lines]",
          "925: struct ImapAccountData *imap_conn_find(const struct ConnAccount *account, int flags)",
          "929:   struct ImapAccountData *adata = NULL;",
          "",
          "---------------",
          "--- Hunk 21 ---",
          "[Context before]",
          "936:     else",
          "937:       memcpy(&conn->account, creds, sizeof(struct ConnAccount));",
          "940:     if (flags & MUTT_IMAP_CONN_NONEW)",
          "941:     {",
          "943:       {",
          "945:         mutt_socket_free(conn);",
          "946:         return NULL;",
          "947:       }",
          "949:         continue;",
          "950:     }",
          "952:       continue;",
          "954:       continue;",
          "955:     break;",
          "956:   }",
          "",
          "[Removed Lines]",
          "939:     mdata = conn->data;",
          "942:       if (!mdata)",
          "948:       else if (mdata->state < IMAP_AUTHENTICATED)",
          "951:     if (flags & MUTT_IMAP_CONN_NOSELECT && mdata && mdata->state >= IMAP_SELECTED)",
          "953:     if (mdata && mdata->status == IMAP_FATAL)",
          "",
          "[Added Lines]",
          "939:     adata = conn->data;",
          "942:       if (!adata)",
          "948:       else if (adata->state < IMAP_AUTHENTICATED)",
          "951:     if (flags & MUTT_IMAP_CONN_NOSELECT && adata && adata->state >= IMAP_SELECTED)",
          "953:     if (adata && adata->status == IMAP_FATAL)",
          "",
          "---------------",
          "--- Hunk 22 ---",
          "[Context before]",
          "962:   {",
          "967:     new = true;",
          "968:   }",
          "973:   {",
          "975:     {",
          "978:       new = true;",
          "981:     }",
          "982:     else",
          "984:   }",
          "986:   {",
          "997:     {",
          "999:       if (ImapQResync)",
          "1001:     }",
          "1009:   }",
          "1012:     return NULL;",
          "1015: }",
          "1024: {",
          "1025:   char buf[LONG_STRING];",
          "1028:     return -1;",
          "1033:   {",
          "1035:     return -1;",
          "1036:   }",
          "1039:   {",
          "1042:     {",
          "1043:       goto bail;",
          "1044:     }",
          "1045: #ifdef USE_SSL",
          "1048:     {",
          "1049:       int rc;",
          "",
          "[Removed Lines]",
          "961:   if (!mdata)",
          "964:     mdata = imap_mdata_new();",
          "965:     conn->data = mdata;",
          "966:     mdata->conn = conn;",
          "970:   if (mdata->state == IMAP_DISCONNECTED)",
          "971:     imap_open_connection(mdata);",
          "972:   if (mdata->state == IMAP_CONNECTED)",
          "974:     if (imap_authenticate(mdata) == IMAP_AUTH_SUCCESS)",
          "976:       mdata->state = IMAP_AUTHENTICATED;",
          "977:       FREE(&mdata->capstr);",
          "979:       if (mdata->conn->ssf)",
          "980:         mutt_debug(2, \"Communication encrypted at %d bits\\n\", mdata->conn->ssf);",
          "983:       mutt_account_unsetpass(&mdata->conn->account);",
          "985:   if (new && mdata->state == IMAP_AUTHENTICATED)",
          "988:     imap_exec(mdata, \"CAPABILITY\", IMAP_CMD_QUEUE);",
          "991:     if (mutt_bit_isset(mdata->capabilities, ENABLE))",
          "992:       imap_exec(mdata, \"ENABLE UTF8=ACCEPT\", IMAP_CMD_QUEUE);",
          "996:     if (mutt_bit_isset(mdata->capabilities, QRESYNC))",
          "998:       mutt_bit_set(mdata->capabilities, CONDSTORE);",
          "1000:         imap_exec(mdata, \"ENABLE QRESYNC\", IMAP_CMD_QUEUE);",
          "1004:     mdata->delim = '/';",
          "1005:     imap_exec(mdata, \"LIST \\\"\\\" \\\"\\\"\", IMAP_CMD_QUEUE);",
          "1008:     imap_exec(mdata, NULL, IMAP_CMD_FAIL_OK);",
          "1011:   if (mdata->state < IMAP_AUTHENTICATED)",
          "1014:   return mdata;",
          "1023: int imap_open_connection(struct ImapMboxData *mdata)",
          "1027:   if (mutt_socket_open(mdata->conn) < 0)",
          "1030:   mdata->state = IMAP_CONNECTED;",
          "1032:   if (imap_cmd_step(mdata) != IMAP_CMD_OK)",
          "1034:     imap_close_connection(mdata);",
          "1038:   if (mutt_str_strncasecmp(\"* OK\", mdata->buf, 4) == 0)",
          "1040:     if ((mutt_str_strncasecmp(\"* OK [CAPABILITY\", mdata->buf, 16) != 0) &&",
          "1041:         check_capabilities(mdata))",
          "1047:     if (!mdata->conn->ssf && (SslForceTls || mutt_bit_isset(mdata->capabilities, STARTTLS)))",
          "",
          "[Added Lines]",
          "961:   if (!adata)",
          "964:     adata = imap_adata_new();",
          "965:     conn->data = adata;",
          "966:     adata->conn = conn;",
          "970:   if (adata->state == IMAP_DISCONNECTED)",
          "971:     imap_open_connection(adata);",
          "972:   if (adata->state == IMAP_CONNECTED)",
          "974:     if (imap_authenticate(adata) == IMAP_AUTH_SUCCESS)",
          "976:       adata->state = IMAP_AUTHENTICATED;",
          "977:       FREE(&adata->capstr);",
          "979:       if (adata->conn->ssf)",
          "980:         mutt_debug(2, \"Communication encrypted at %d bits\\n\", adata->conn->ssf);",
          "983:       mutt_account_unsetpass(&adata->conn->account);",
          "985:   if (new && adata->state == IMAP_AUTHENTICATED)",
          "988:     imap_exec(adata, \"CAPABILITY\", IMAP_CMD_QUEUE);",
          "991:     if (mutt_bit_isset(adata->capabilities, ENABLE))",
          "992:       imap_exec(adata, \"ENABLE UTF8=ACCEPT\", IMAP_CMD_QUEUE);",
          "996:     if (mutt_bit_isset(adata->capabilities, QRESYNC))",
          "998:       mutt_bit_set(adata->capabilities, CONDSTORE);",
          "1000:         imap_exec(adata, \"ENABLE QRESYNC\", IMAP_CMD_QUEUE);",
          "1004:     adata->delim = '/';",
          "1005:     imap_exec(adata, \"LIST \\\"\\\" \\\"\\\"\", IMAP_CMD_QUEUE);",
          "1008:     imap_exec(adata, NULL, IMAP_CMD_FAIL_OK);",
          "1011:   if (adata->state < IMAP_AUTHENTICATED)",
          "1014:   return adata;",
          "1023: int imap_open_connection(struct ImapAccountData *adata)",
          "1027:   if (mutt_socket_open(adata->conn) < 0)",
          "1030:   adata->state = IMAP_CONNECTED;",
          "1032:   if (imap_cmd_step(adata) != IMAP_CMD_OK)",
          "1034:     imap_close_connection(adata);",
          "1038:   if (mutt_str_strncasecmp(\"* OK\", adata->buf, 4) == 0)",
          "1040:     if ((mutt_str_strncasecmp(\"* OK [CAPABILITY\", adata->buf, 16) != 0) &&",
          "1041:         check_capabilities(adata))",
          "1047:     if (!adata->conn->ssf && (SslForceTls || mutt_bit_isset(adata->capabilities, STARTTLS)))",
          "",
          "---------------",
          "--- Hunk 23 ---",
          "[Context before]",
          "1057:       }",
          "1058:       if (rc == MUTT_YES)",
          "1059:       {",
          "1061:         if (rc == -1)",
          "1062:           goto bail;",
          "1063:         if (rc != -2)",
          "1064:         {",
          "1066:           {",
          "1067:             mutt_error(_(\"Could not negotiate TLS connection\"));",
          "1068:             goto err_close_conn;",
          "",
          "[Removed Lines]",
          "1060:         rc = imap_exec(mdata, \"STARTTLS\", IMAP_CMD_FAIL_OK);",
          "1065:           if (mutt_ssl_starttls(mdata->conn))",
          "",
          "[Added Lines]",
          "1060:         rc = imap_exec(adata, \"STARTTLS\", IMAP_CMD_FAIL_OK);",
          "1065:           if (mutt_ssl_starttls(adata->conn))",
          "",
          "---------------",
          "--- Hunk 24 ---",
          "[Context before]",
          "1070:           else",
          "1071:           {",
          "1074:               goto bail;",
          "1075:           }",
          "1076:         }",
          "1077:       }",
          "1078:     }",
          "1081:     {",
          "1082:       mutt_error(_(\"Encrypted connection unavailable\"));",
          "1083:       goto err_close_conn;",
          "1084:     }",
          "1085: #endif",
          "1086:   }",
          "1088:   {",
          "1091:       goto bail;",
          "1093:   }",
          "1094:   else",
          "1095:   {",
          "",
          "[Removed Lines]",
          "1073:             if (imap_exec(mdata, \"CAPABILITY\", 0))",
          "1080:     if (SslForceTls && !mdata->conn->ssf)",
          "1087:   else if (mutt_str_strncasecmp(\"* PREAUTH\", mdata->buf, 9) == 0)",
          "1089:     mdata->state = IMAP_AUTHENTICATED;",
          "1090:     if (check_capabilities(mdata) != 0)",
          "1092:     FREE(&mdata->capstr);",
          "",
          "[Added Lines]",
          "1073:             if (imap_exec(adata, \"CAPABILITY\", 0))",
          "1080:     if (SslForceTls && !adata->conn->ssf)",
          "1087:   else if (mutt_str_strncasecmp(\"* PREAUTH\", adata->buf, 9) == 0)",
          "1089:     adata->state = IMAP_AUTHENTICATED;",
          "1090:     if (check_capabilities(adata) != 0)",
          "1092:     FREE(&adata->capstr);",
          "",
          "---------------",
          "--- Hunk 25 ---",
          "[Context before]",
          "1102: #ifdef USE_SSL",
          "1103: err_close_conn:",
          "1105: #endif",
          "1106: bail:",
          "1108:   return -1;",
          "1109: }",
          "1116: {",
          "1118:   {",
          "1121:   }",
          "1127: }",
          "1134: {",
          "1140:   {",
          "1142:       ;",
          "1143:   }",
          "1147: }",
          "",
          "[Removed Lines]",
          "1104:   imap_close_connection(mdata);",
          "1107:   FREE(&mdata->capstr);",
          "1115: void imap_close_connection(struct ImapMboxData *mdata)",
          "1117:   if (mdata->state != IMAP_DISCONNECTED)",
          "1119:     mutt_socket_close(mdata->conn);",
          "1120:     mdata->state = IMAP_DISCONNECTED;",
          "1122:   mdata->seqno = false;",
          "1123:   mdata->nextcmd = false;",
          "1124:   mdata->lastcmd = false;",
          "1125:   mdata->status = false;",
          "1126:   memset(mdata->cmds, 0, sizeof(struct ImapCommand) * mdata->cmdslots);",
          "1133: void imap_logout(struct ImapMboxData **mdata)",
          "1137:   (*mdata)->status = IMAP_BYE;",
          "1138:   imap_cmd_start(*mdata, \"LOGOUT\");",
          "1139:   if (ImapPollTimeout <= 0 || mutt_socket_poll((*mdata)->conn, ImapPollTimeout) != 0)",
          "1141:     while (imap_cmd_step(*mdata) == IMAP_CMD_CONTINUE)",
          "1145:   mutt_socket_close((*mdata)->conn);",
          "1146:   imap_mdata_free(mdata);",
          "",
          "[Added Lines]",
          "1104:   imap_close_connection(adata);",
          "1107:   FREE(&adata->capstr);",
          "1115: void imap_close_connection(struct ImapAccountData *adata)",
          "1117:   if (adata->state != IMAP_DISCONNECTED)",
          "1119:     mutt_socket_close(adata->conn);",
          "1120:     adata->state = IMAP_DISCONNECTED;",
          "1122:   adata->seqno = false;",
          "1123:   adata->nextcmd = false;",
          "1124:   adata->lastcmd = false;",
          "1125:   adata->status = false;",
          "1126:   memset(adata->cmds, 0, sizeof(struct ImapCommand) * adata->cmdslots);",
          "1133: void imap_logout(struct ImapAccountData **adata)",
          "1137:   (*adata)->status = IMAP_BYE;",
          "1138:   imap_cmd_start(*adata, \"LOGOUT\");",
          "1139:   if (ImapPollTimeout <= 0 || mutt_socket_poll((*adata)->conn, ImapPollTimeout) != 0)",
          "1141:     while (imap_cmd_step(*adata) == IMAP_CMD_CONTINUE)",
          "1145:   mutt_socket_close((*adata)->conn);",
          "1146:   imap_adata_free(adata);",
          "",
          "---------------",
          "--- Hunk 26 ---",
          "[Context before]",
          "1192:                      const char *post, int flag, bool changed, bool invert)",
          "1193: {",
          "1194:   struct Email **emails = NULL;",
          "",
          "[Removed Lines]",
          "1191: int imap_exec_msgset(struct ImapMboxData *mdata, const char *pre,",
          "",
          "[Added Lines]",
          "1191: int imap_exec_msgset(struct ImapAccountData *adata, const char *pre,",
          "",
          "---------------",
          "--- Hunk 27 ---",
          "[Context before]",
          "1205:   oldsort = Sort;",
          "1206:   if (Sort != SORT_ORDER)",
          "1207:   {",
          "1214:     Sort = SORT_ORDER;",
          "1216:           sizeof(struct Email *), mutt_get_sort_func(SORT_ORDER));",
          "1217:   }",
          "",
          "[Removed Lines]",
          "1208:     emails = mdata->ctx->mailbox->hdrs;",
          "1209:     mdata->ctx->mailbox->hdrs =",
          "1210:         mutt_mem_malloc(mdata->ctx->mailbox->msg_count * sizeof(struct Email *));",
          "1211:     memcpy(mdata->ctx->mailbox->hdrs, emails,",
          "1212:            mdata->ctx->mailbox->msg_count * sizeof(struct Email *));",
          "1215:     qsort(mdata->ctx->mailbox->hdrs, mdata->ctx->mailbox->msg_count,",
          "",
          "[Added Lines]",
          "1208:     emails = adata->ctx->mailbox->hdrs;",
          "1209:     adata->ctx->mailbox->hdrs =",
          "1210:         mutt_mem_malloc(adata->ctx->mailbox->msg_count * sizeof(struct Email *));",
          "1211:     memcpy(adata->ctx->mailbox->hdrs, emails,",
          "1212:            adata->ctx->mailbox->msg_count * sizeof(struct Email *));",
          "1215:     qsort(adata->ctx->mailbox->hdrs, adata->ctx->mailbox->msg_count,",
          "",
          "---------------",
          "--- Hunk 28 ---",
          "[Context before]",
          "1222:   {",
          "1223:     cmd->dptr = cmd->data;",
          "1224:     mutt_buffer_printf(cmd, \"%s \", pre);",
          "1226:     if (rc > 0)",
          "1227:     {",
          "1228:       mutt_buffer_printf(cmd, \" %s\", post);",
          "1230:       {",
          "1231:         rc = -1;",
          "1232:         goto out;",
          "",
          "[Removed Lines]",
          "1225:     rc = make_msg_set(mdata, cmd, flag, changed, invert, &pos);",
          "1229:       if (imap_exec(mdata, cmd->data, IMAP_CMD_QUEUE))",
          "",
          "[Added Lines]",
          "1225:     rc = make_msg_set(adata, cmd, flag, changed, invert, &pos);",
          "1229:       if (imap_exec(adata, cmd->data, IMAP_CMD_QUEUE))",
          "",
          "---------------",
          "--- Hunk 29 ---",
          "[Context before]",
          "1242:   if (oldsort != Sort)",
          "1243:   {",
          "1244:     Sort = oldsort;",
          "1247:   }",
          "1249:   return rc;",
          "",
          "[Removed Lines]",
          "1245:     FREE(&mdata->ctx->mailbox->hdrs);",
          "1246:     mdata->ctx->mailbox->hdrs = emails;",
          "",
          "[Added Lines]",
          "1245:     FREE(&adata->ctx->mailbox->hdrs);",
          "1246:     adata->ctx->mailbox->hdrs = emails;",
          "",
          "---------------",
          "--- Hunk 30 ---",
          "[Context before]",
          "1268:                                struct Buffer *cmd, int *err_continue)",
          "1269: {",
          "1270:   char flags[LONG_STRING];",
          "",
          "[Removed Lines]",
          "1267: int imap_sync_message_for_copy(struct ImapMboxData *mdata, struct Email *e,",
          "",
          "[Added Lines]",
          "1267: int imap_sync_message_for_copy(struct ImapAccountData *adata, struct Email *e,",
          "",
          "---------------",
          "--- Hunk 31 ---",
          "[Context before]",
          "1286:   flags[0] = '\\0';",
          "1293:            sizeof(flags));",
          "1296:   {",
          "1298:     if (IMAP_EDATA(e)->flags_system)",
          "",
          "[Removed Lines]",
          "1288:   set_flag(mdata, MUTT_ACL_SEEN, e->read, \"\\\\Seen \", flags, sizeof(flags));",
          "1289:   set_flag(mdata, MUTT_ACL_WRITE, e->old, \"Old \", flags, sizeof(flags));",
          "1290:   set_flag(mdata, MUTT_ACL_WRITE, e->flagged, \"\\\\Flagged \", flags, sizeof(flags));",
          "1291:   set_flag(mdata, MUTT_ACL_WRITE, e->replied, \"\\\\Answered \", flags, sizeof(flags));",
          "1292:   set_flag(mdata, MUTT_ACL_DELETE, IMAP_EDATA(e)->deleted, \"\\\\Deleted \", flags,",
          "1295:   if (mutt_bit_isset(mdata->ctx->mailbox->rights, MUTT_ACL_WRITE))",
          "",
          "[Added Lines]",
          "1288:   set_flag(adata, MUTT_ACL_SEEN, e->read, \"\\\\Seen \", flags, sizeof(flags));",
          "1289:   set_flag(adata, MUTT_ACL_WRITE, e->old, \"Old \", flags, sizeof(flags));",
          "1290:   set_flag(adata, MUTT_ACL_WRITE, e->flagged, \"\\\\Flagged \", flags, sizeof(flags));",
          "1291:   set_flag(adata, MUTT_ACL_WRITE, e->replied, \"\\\\Answered \", flags, sizeof(flags));",
          "1292:   set_flag(adata, MUTT_ACL_DELETE, IMAP_EDATA(e)->deleted, \"\\\\Deleted \", flags,",
          "1295:   if (mutt_bit_isset(adata->ctx->mailbox->rights, MUTT_ACL_WRITE))",
          "",
          "---------------",
          "--- Hunk 32 ---",
          "[Context before]",
          "1313:   if (!*flags)",
          "1314:   {",
          "1320:              flags, sizeof(flags));",
          "1324:         IMAP_EDATA(e)->flags_remote)",
          "1325:       mutt_str_strcat(flags, sizeof(flags), IMAP_EDATA(e)->flags_remote);",
          "",
          "[Removed Lines]",
          "1315:     set_flag(mdata, MUTT_ACL_SEEN, 1, \"\\\\Seen \", flags, sizeof(flags));",
          "1316:     set_flag(mdata, MUTT_ACL_WRITE, 1, \"Old \", flags, sizeof(flags));",
          "1317:     set_flag(mdata, MUTT_ACL_WRITE, 1, \"\\\\Flagged \", flags, sizeof(flags));",
          "1318:     set_flag(mdata, MUTT_ACL_WRITE, 1, \"\\\\Answered \", flags, sizeof(flags));",
          "1319:     set_flag(mdata, MUTT_ACL_DELETE, !IMAP_EDATA(e)->deleted, \"\\\\Deleted \",",
          "1323:     if (mutt_bit_isset(mdata->ctx->mailbox->rights, MUTT_ACL_WRITE) &&",
          "",
          "[Added Lines]",
          "1315:     set_flag(adata, MUTT_ACL_SEEN, 1, \"\\\\Seen \", flags, sizeof(flags));",
          "1316:     set_flag(adata, MUTT_ACL_WRITE, 1, \"Old \", flags, sizeof(flags));",
          "1317:     set_flag(adata, MUTT_ACL_WRITE, 1, \"\\\\Flagged \", flags, sizeof(flags));",
          "1318:     set_flag(adata, MUTT_ACL_WRITE, 1, \"\\\\Answered \", flags, sizeof(flags));",
          "1319:     set_flag(adata, MUTT_ACL_DELETE, !IMAP_EDATA(e)->deleted, \"\\\\Deleted \",",
          "1323:     if (mutt_bit_isset(adata->ctx->mailbox->rights, MUTT_ACL_WRITE) &&",
          "",
          "---------------",
          "--- Hunk 33 ---",
          "[Context before]",
          "1343:       (*err_continue != MUTT_YES))",
          "1344:   {",
          "1346:     if (*err_continue != MUTT_YES)",
          "1347:     {",
          "1348:       e->active = true;",
          "",
          "[Removed Lines]",
          "1342:   if (*flags && (imap_exec(mdata, cmd->data, 0) != 0) && err_continue &&",
          "",
          "[Added Lines]",
          "1342:   if (*flags && (imap_exec(adata, cmd->data, 0) != 0) && err_continue &&",
          "",
          "---------------",
          "--- Hunk 34 ---",
          "[Context before]",
          "1386: {",
          "1389:   int result = 0;",
          "1394:   {",
          "1396:       return -1;",
          "1397:   }",
          "1399:   {",
          "1401:     {",
          "1403:       {",
          "1404:         mutt_debug(1, \"Error reading IDLE response\\n\");",
          "1405:         return -1;",
          "",
          "[Removed Lines]",
          "1385: int imap_check(struct ImapMboxData *mdata, bool force)",
          "1392:   if (!force && ImapIdle && mutt_bit_isset(mdata->capabilities, IDLE) &&",
          "1393:       (mdata->state != IMAP_IDLE || time(NULL) >= mdata->lastread + ImapKeepalive))",
          "1395:     if (imap_cmd_idle(mdata) < 0)",
          "1398:   if (mdata->state == IMAP_IDLE)",
          "1400:     while ((result = mutt_socket_poll(mdata->conn, 0)) > 0)",
          "1402:       if (imap_cmd_step(mdata) != IMAP_CMD_CONTINUE)",
          "",
          "[Added Lines]",
          "1385: int imap_check(struct ImapAccountData *adata, bool force)",
          "1392:   if (!force && ImapIdle && mutt_bit_isset(adata->capabilities, IDLE) &&",
          "1393:       (adata->state != IMAP_IDLE || time(NULL) >= adata->lastread + ImapKeepalive))",
          "1395:     if (imap_cmd_idle(adata) < 0)",
          "1398:   if (adata->state == IMAP_IDLE)",
          "1400:     while ((result = mutt_socket_poll(adata->conn, 0)) > 0)",
          "1402:       if (imap_cmd_step(adata) != IMAP_CMD_CONTINUE)",
          "",
          "---------------",
          "--- Hunk 35 ---",
          "[Context before]",
          "1408:     if (result < 0)",
          "1409:     {",
          "1410:       mutt_debug(1, \"Poll failed, disabling IDLE\\n\");",
          "1412:     }",
          "1413:   }",
          "1417:   {",
          "1418:     return -1;",
          "1419:   }",
          "1426:     result = MUTT_REOPENED;",
          "1428:     result = MUTT_NEW_MAIL;",
          "1430:     result = MUTT_FLAGS;",
          "1434:   return result;",
          "1435: }",
          "",
          "[Removed Lines]",
          "1411:       mutt_bit_unset(mdata->capabilities, IDLE);",
          "1415:   if ((force || (mdata->state != IMAP_IDLE && time(NULL) >= mdata->lastread + Timeout)) &&",
          "1416:       imap_exec(mdata, \"NOOP\", IMAP_CMD_POLL) != 0)",
          "1423:   imap_cmd_finish(mdata);",
          "1425:   if (mdata->check_status & IMAP_EXPUNGE_PENDING)",
          "1427:   else if (mdata->check_status & IMAP_NEWMAIL_PENDING)",
          "1429:   else if (mdata->check_status & IMAP_FLAGS_PENDING)",
          "1432:   mdata->check_status = 0;",
          "",
          "[Added Lines]",
          "1411:       mutt_bit_unset(adata->capabilities, IDLE);",
          "1415:   if ((force || (adata->state != IMAP_IDLE && time(NULL) >= adata->lastread + Timeout)) &&",
          "1416:       imap_exec(adata, \"NOOP\", IMAP_CMD_POLL) != 0)",
          "1423:   imap_cmd_finish(adata);",
          "1425:   if (adata->check_status & IMAP_EXPUNGE_PENDING)",
          "1427:   else if (adata->check_status & IMAP_NEWMAIL_PENDING)",
          "1429:   else if (adata->check_status & IMAP_FLAGS_PENDING)",
          "1432:   adata->check_status = 0;",
          "",
          "---------------",
          "--- Hunk 36 ---",
          "[Context before]",
          "1446: int imap_mailbox_check(bool check_stats)",
          "1447: {",
          "1450:   char name[LONG_STRING];",
          "1451:   char command[LONG_STRING * 2];",
          "1452:   char munged[LONG_STRING];",
          "",
          "[Removed Lines]",
          "1448:   struct ImapMboxData *mdata = NULL;",
          "1449:   struct ImapMboxData *lastdata = NULL;",
          "",
          "[Added Lines]",
          "1448:   struct ImapAccountData *adata = NULL;",
          "1449:   struct ImapAccountData *lastdata = NULL;",
          "",
          "---------------",
          "--- Hunk 37 ---",
          "[Context before]",
          "1465:     if (np->m->magic != MUTT_IMAP)",
          "1466:       continue;",
          "1469:     {",
          "1470:       np->m->has_new = false;",
          "1471:       continue;",
          "",
          "[Removed Lines]",
          "1468:     if (get_mailbox(np->m->path, &mdata, name, sizeof(name)) < 0)",
          "",
          "[Added Lines]",
          "1468:     if (get_mailbox(np->m->path, &adata, name, sizeof(name)) < 0)",
          "",
          "---------------",
          "--- Hunk 38 ---",
          "[Context before]",
          "1479:     {",
          "1480:       np->m->has_new = false;",
          "1481:       continue;",
          "1482:     }",
          "1486:     {",
          "1487:       mutt_debug(2, \"Server doesn't support STATUS\\n\");",
          "1488:       continue;",
          "1489:     }",
          "1492:     {",
          "",
          "[Removed Lines]",
          "1478:     if (mdata->mbox_name && (imap_mxcmp(name, mdata->mbox_name) == 0))",
          "1484:     if (!mutt_bit_isset(mdata->capabilities, IMAP4REV1) &&",
          "1485:         !mutt_bit_isset(mdata->capabilities, STATUS))",
          "1491:     if (lastdata && mdata != lastdata)",
          "",
          "[Added Lines]",
          "1478:     if (adata->mbox_name && (imap_mxcmp(name, adata->mbox_name) == 0))",
          "1484:     if (!mutt_bit_isset(adata->capabilities, IMAP4REV1) &&",
          "1485:         !mutt_bit_isset(adata->capabilities, STATUS))",
          "1491:     if (lastdata && adata != lastdata)",
          "",
          "---------------",
          "--- Hunk 39 ---",
          "[Context before]",
          "1499:     }",
          "1501:     if (!lastdata)",
          "1505:     if (check_stats)",
          "1506:     {",
          "1507:       snprintf(command, sizeof(command),",
          "",
          "[Removed Lines]",
          "1502:       lastdata = mdata;",
          "1504:     imap_munge_mbox_name(mdata, munged, sizeof(munged), name);",
          "",
          "[Added Lines]",
          "1502:       lastdata = adata;",
          "1504:     imap_munge_mbox_name(adata, munged, sizeof(munged), name);",
          "",
          "---------------",
          "--- Hunk 40 ---",
          "[Context before]",
          "1513:                \"STATUS %s (UIDNEXT UIDVALIDITY UNSEEN RECENT)\", munged);",
          "1514:     }",
          "1517:     {",
          "1518:       mutt_debug(1, \"Error queueing command\\n\");",
          "1519:       return 0;",
          "",
          "[Removed Lines]",
          "1516:     if (imap_exec(mdata, command, IMAP_CMD_QUEUE | IMAP_CMD_POLL) < 0)",
          "",
          "[Added Lines]",
          "1516:     if (imap_exec(adata, command, IMAP_CMD_QUEUE | IMAP_CMD_POLL) < 0)",
          "",
          "---------------",
          "--- Hunk 41 ---",
          "[Context before]",
          "1550: {",
          "1551:   static int queued = 0;",
          "1554:   char buf[LONG_STRING * 2];",
          "1555:   char mbox[LONG_STRING];",
          "1556:   struct ImapStatus *status = NULL;",
          "1559:     return -1;",
          "1569:   {",
          "1571:     snprintf(buf, sizeof(buf), \"STATUS %s (%s)\", mbox, \"MESSAGES\");",
          "1573:   }",
          "1574:   else",
          "1575:   {",
          "",
          "[Removed Lines]",
          "1553:   struct ImapMboxData *mdata = NULL;",
          "1558:   if (get_mailbox(path, &mdata, buf, sizeof(buf)) < 0)",
          "1565:   if (mdata->ctx && !imap_mxcmp(buf, mdata->mbox_name))",
          "1566:     return mdata->ctx->mailbox->msg_count;",
          "1567:   else if (mutt_bit_isset(mdata->capabilities, IMAP4REV1) ||",
          "1568:            mutt_bit_isset(mdata->capabilities, STATUS))",
          "1570:     imap_munge_mbox_name(mdata, mbox, sizeof(mbox), buf);",
          "1572:     imap_unmunge_mbox_name(mdata, mbox);",
          "",
          "[Added Lines]",
          "1553:   struct ImapAccountData *adata = NULL;",
          "1558:   if (get_mailbox(path, &adata, buf, sizeof(buf)) < 0)",
          "1565:   if (adata->ctx && !imap_mxcmp(buf, adata->mbox_name))",
          "1566:     return adata->ctx->mailbox->msg_count;",
          "1567:   else if (mutt_bit_isset(adata->capabilities, IMAP4REV1) ||",
          "1568:            mutt_bit_isset(adata->capabilities, STATUS))",
          "1570:     imap_munge_mbox_name(adata, mbox, sizeof(mbox), buf);",
          "1572:     imap_unmunge_mbox_name(adata, mbox);",
          "",
          "---------------",
          "--- Hunk 42 ---",
          "[Context before]",
          "1581:   if (queue)",
          "1582:   {",
          "1584:     queued = 1;",
          "1585:     return 0;",
          "1586:   }",
          "1587:   else if (!queued)",
          "1590:   queued = 0;",
          "1592:   if (status)",
          "1593:     return status->messages;",
          "",
          "[Removed Lines]",
          "1583:     imap_exec(mdata, buf, IMAP_CMD_QUEUE);",
          "1588:     imap_exec(mdata, buf, 0);",
          "1591:   status = imap_mboxcache_get(mdata, mbox, false);",
          "",
          "[Added Lines]",
          "1583:     imap_exec(adata, buf, IMAP_CMD_QUEUE);",
          "1588:     imap_exec(adata, buf, 0);",
          "1591:   status = imap_mboxcache_get(adata, mbox, false);",
          "",
          "---------------",
          "--- Hunk 43 ---",
          "[Context before]",
          "1610: {",
          "1611:   struct ImapStatus *status = NULL;",
          "1612:   struct ListNode *np = NULL;",
          "1614:   {",
          "1615:     status = (struct ImapStatus *) np->data;",
          "",
          "[Removed Lines]",
          "1609: struct ImapStatus *imap_mboxcache_get(struct ImapMboxData *mdata, const char *mbox, bool create)",
          "1613:   STAILQ_FOREACH(np, &mdata->mboxcache, entries)",
          "",
          "[Added Lines]",
          "1609: struct ImapStatus *imap_mboxcache_get(struct ImapAccountData *adata, const char *mbox, bool create)",
          "1613:   STAILQ_FOREACH(np, &adata->mboxcache, entries)",
          "",
          "---------------",
          "--- Hunk 44 ---",
          "[Context before]",
          "1624:   {",
          "1625:     struct ImapStatus *scache = mutt_mem_calloc(1, sizeof(struct ImapStatus));",
          "1626:     scache->name = (char *) mbox;",
          "1629:     status->name = mutt_str_strdup(mbox);",
          "1630:   }",
          "1632: #ifdef USE_HCACHE",
          "1634:   if (hc)",
          "1635:   {",
          "1636:     void *uidvalidity = mutt_hcache_fetch_raw(hc, \"/UIDVALIDITY\", 12);",
          "",
          "[Removed Lines]",
          "1627:     mutt_list_insert_tail(&mdata->mboxcache, (char *) scache);",
          "1628:     status = imap_mboxcache_get(mdata, mbox, false);",
          "1633:   header_cache_t *hc = imap_hcache_open(mdata, mbox);",
          "",
          "[Added Lines]",
          "1627:     mutt_list_insert_tail(&adata->mboxcache, (char *) scache);",
          "1628:     status = imap_mboxcache_get(adata, mbox, false);",
          "1633:   header_cache_t *hc = imap_hcache_open(adata, mbox);",
          "",
          "---------------",
          "--- Hunk 45 ---",
          "[Context before]",
          "1644:         mutt_hcache_free(hc, &uidnext);",
          "1645:         mutt_hcache_free(hc, (void **) &modseq);",
          "1646:         mutt_hcache_close(hc);",
          "1648:       }",
          "1649:       status->uidvalidity = *(unsigned int *) uidvalidity;",
          "1650:       status->uidnext = uidnext ? *(unsigned int *) uidnext : 0;",
          "",
          "[Removed Lines]",
          "1647:         return imap_mboxcache_get(mdata, mbox, true);",
          "",
          "[Added Lines]",
          "1647:         return imap_mboxcache_get(adata, mbox, true);",
          "",
          "---------------",
          "--- Hunk 46 ---",
          "[Context before]",
          "1670: {",
          "1671:   struct ImapStatus *status = NULL;",
          "1673:   struct ListNode *np = NULL;",
          "1675:   {",
          "1676:     status = (struct ImapStatus *) np->data;",
          "1677:     FREE(&status->name);",
          "1678:   }",
          "1681: }",
          "",
          "[Removed Lines]",
          "1669: void imap_mboxcache_free(struct ImapMboxData *mdata)",
          "1674:   STAILQ_FOREACH(np, &mdata->mboxcache, entries)",
          "1680:   mutt_list_free(&mdata->mboxcache);",
          "",
          "[Added Lines]",
          "1669: void imap_mboxcache_free(struct ImapAccountData *adata)",
          "1674:   STAILQ_FOREACH(np, &adata->mboxcache, entries)",
          "1680:   mutt_list_free(&adata->mboxcache);",
          "",
          "---------------",
          "--- Hunk 47 ---",
          "[Context before]",
          "1690: int imap_search(struct Mailbox *mailbox, const struct Pattern *pat)",
          "1691: {",
          "1692:   struct Buffer buf;",
          "1694:   for (int i = 0; i < mailbox->msg_count; i++)",
          "1695:     mailbox->hdrs[i]->matched = false;",
          "",
          "[Removed Lines]",
          "1693:   struct ImapMboxData *mdata = mailbox->data;",
          "",
          "[Added Lines]",
          "1693:   struct ImapAccountData *adata = mailbox->data;",
          "",
          "---------------",
          "--- Hunk 48 ---",
          "[Context before]",
          "1704:     FREE(&buf.data);",
          "1705:     return -1;",
          "1706:   }",
          "1708:   {",
          "1709:     FREE(&buf.data);",
          "1710:     return -1;",
          "",
          "[Removed Lines]",
          "1707:   if (imap_exec(mdata, buf.data, 0) < 0)",
          "",
          "[Added Lines]",
          "1707:   if (imap_exec(adata, buf.data, 0) < 0)",
          "",
          "---------------",
          "--- Hunk 49 ---",
          "[Context before]",
          "1724: int imap_subscribe(char *path, bool subscribe)",
          "1725: {",
          "1727:   char buf[LONG_STRING * 2];",
          "1728:   char mbox[LONG_STRING];",
          "1729:   char errstr[STRING];",
          "",
          "[Removed Lines]",
          "1726:   struct ImapMboxData *mdata = NULL;",
          "",
          "[Added Lines]",
          "1726:   struct ImapAccountData *adata = NULL;",
          "",
          "---------------",
          "--- Hunk 50 ---",
          "[Context before]",
          "1736:     mutt_error(_(\"Bad mailbox name\"));",
          "1737:     return -1;",
          "1738:   }",
          "1741:     goto fail;",
          "1744:   if (!*buf)",
          "1745:     mutt_str_strfcpy(buf, \"INBOX\", sizeof(buf));",
          "",
          "[Removed Lines]",
          "1739:   mdata = imap_conn_find(&(mx.account), 0);",
          "1740:   if (!mdata)",
          "1743:   imap_fix_path(mdata, mx.mbox, buf, sizeof(buf));",
          "",
          "[Added Lines]",
          "1739:   adata = imap_conn_find(&(mx.account), 0);",
          "1740:   if (!adata)",
          "1743:   imap_fix_path(adata, mx.mbox, buf, sizeof(buf));",
          "",
          "---------------",
          "--- Hunk 51 ---",
          "[Context before]",
          "1761:     mutt_message(_(\"Subscribing to %s...\"), buf);",
          "1762:   else",
          "1763:     mutt_message(_(\"Unsubscribing from %s...\"), buf);",
          "1766:   snprintf(buf, sizeof(buf), \"%sSUBSCRIBE %s\", subscribe ? \"\" : \"UN\", mbox);",
          "1769:     goto fail;",
          "1772:   if (subscribe)",
          "1773:     mutt_message(_(\"Subscribed to %s\"), mx.mbox);",
          "1774:   else",
          "",
          "[Removed Lines]",
          "1764:   imap_munge_mbox_name(mdata, mbox, sizeof(mbox), buf);",
          "1768:   if (imap_exec(mdata, buf, 0) < 0)",
          "1771:   imap_unmunge_mbox_name(mdata, mx.mbox);",
          "",
          "[Added Lines]",
          "1764:   imap_munge_mbox_name(adata, mbox, sizeof(mbox), buf);",
          "1768:   if (imap_exec(adata, buf, 0) < 0)",
          "1771:   imap_unmunge_mbox_name(adata, mx.mbox);",
          "",
          "---------------",
          "--- Hunk 52 ---",
          "[Context before]",
          "1795: int imap_complete(char *buf, size_t buflen, char *path)",
          "1796: {",
          "1798:   char list[LONG_STRING];",
          "1799:   char tmp[LONG_STRING * 2];",
          "1800:   struct ImapList listresp;",
          "",
          "[Removed Lines]",
          "1797:   struct ImapMboxData *mdata = NULL;",
          "",
          "[Added Lines]",
          "1797:   struct ImapAccountData *adata = NULL;",
          "",
          "---------------",
          "--- Hunk 53 ---",
          "[Context before]",
          "1818:   {",
          "1819:     FREE(&mx.mbox);",
          "1820:     mutt_str_strfcpy(buf, path, buflen);",
          "",
          "[Removed Lines]",
          "1816:   mdata = imap_conn_find(&(mx.account), MUTT_IMAP_CONN_NONEW);",
          "1817:   if (!mdata)",
          "",
          "[Added Lines]",
          "1816:   adata = imap_conn_find(&(mx.account), MUTT_IMAP_CONN_NONEW);",
          "1817:   if (!adata)",
          "",
          "---------------",
          "--- Hunk 54 ---",
          "[Context before]",
          "1826:   if (mx.mbox && mx.mbox[0])",
          "1828:   else",
          "1829:     list[0] = '\\0';",
          "1832:   snprintf(tmp, sizeof(tmp), \"%s \\\"\\\" \\\"%s%%\\\"\", ImapListSubscribed ? \"LSUB\" : \"LIST\", list);",
          "1837:   mutt_str_strfcpy(completion, mx.mbox, sizeof(completion));",
          "1840:   do",
          "1841:   {",
          "1842:     listresp.name = NULL;",
          "1845:     if (rc == IMAP_CMD_CONTINUE && listresp.name)",
          "1846:     {",
          "",
          "[Removed Lines]",
          "1827:     imap_fix_path(mdata, mx.mbox, list, sizeof(list));",
          "1834:   imap_cmd_start(mdata, tmp);",
          "1838:   mdata->cmdtype = IMAP_CT_LIST;",
          "1839:   mdata->cmddata = &listresp;",
          "1843:     rc = imap_cmd_step(mdata);",
          "",
          "[Added Lines]",
          "1827:     imap_fix_path(adata, mx.mbox, list, sizeof(list));",
          "1834:   imap_cmd_start(adata, tmp);",
          "1838:   adata->cmdtype = IMAP_CT_LIST;",
          "1839:   adata->cmddata = &listresp;",
          "1843:     rc = imap_cmd_step(adata);",
          "",
          "---------------",
          "--- Hunk 55 ---",
          "[Context before]",
          "1865:       completions++;",
          "1866:     }",
          "1867:   } while (rc == IMAP_CMD_CONTINUE);",
          "1870:   if (completions)",
          "1871:   {",
          "",
          "[Removed Lines]",
          "1868:   mdata->cmddata = NULL;",
          "",
          "[Added Lines]",
          "1868:   adata->cmddata = NULL;",
          "",
          "---------------",
          "--- Hunk 56 ---",
          "[Context before]",
          "1899:   struct Buffer *sync_cmd = NULL;",
          "1900:   int err_continue = MUTT_NO;",
          "1904:   if (imap_parse_path(dest, &mx))",
          "1905:   {",
          "",
          "[Removed Lines]",
          "1902:   struct ImapMboxData *mdata = mailbox->data;",
          "",
          "[Added Lines]",
          "1902:   struct ImapAccountData *adata = mailbox->data;",
          "",
          "---------------",
          "--- Hunk 57 ---",
          "[Context before]",
          "1908:   }",
          "1912:   {",
          "1913:     mutt_debug(3, \"%s not same server as %s\\n\", dest, mailbox->path);",
          "1914:     return 1;",
          "1915:   }",
          "1918:   if (!*mbox)",
          "1919:     mutt_str_strfcpy(mbox, \"INBOX\", sizeof(mbox));",
          "1922:   sync_cmd = mutt_buffer_new();",
          "1923:   for (int i = 0; i < mailbox->msg_count; i++)",
          "",
          "[Removed Lines]",
          "1911:   if (!mutt_account_match(&(mdata->conn->account), &(mx.account)))",
          "1917:   imap_fix_path(mdata, mx.mbox, mbox, sizeof(mbox));",
          "1920:   imap_munge_mbox_name(mdata, mmbox, sizeof(mmbox), mbox);",
          "",
          "[Added Lines]",
          "1911:   if (!mutt_account_match(&(adata->conn->account), &(mx.account)))",
          "1917:   imap_fix_path(adata, mx.mbox, mbox, sizeof(mbox));",
          "1920:   imap_munge_mbox_name(adata, mmbox, sizeof(mmbox), mbox);",
          "",
          "---------------",
          "--- Hunk 58 ---",
          "[Context before]",
          "1925:     if (mailbox->hdrs[i]->active && mailbox->hdrs[i]->changed &&",
          "1926:         mailbox->hdrs[i]->deleted && !mailbox->hdrs[i]->purge)",
          "1927:     {",
          "1929:       if (rc < 0)",
          "1930:       {",
          "1931:         mutt_debug(1, \"could not sync\\n\");",
          "",
          "[Removed Lines]",
          "1928:       rc = imap_sync_message_for_copy(mdata, mailbox->hdrs[i], sync_cmd, &err_continue);",
          "",
          "[Added Lines]",
          "1928:       rc = imap_sync_message_for_copy(adata, mailbox->hdrs[i], sync_cmd, &err_continue);",
          "",
          "---------------",
          "--- Hunk 59 ---",
          "[Context before]",
          "1938:   do",
          "1939:   {",
          "1941:     if (!rc)",
          "1942:     {",
          "1943:       mutt_debug(1, \"No messages to trash\\n\");",
          "",
          "[Removed Lines]",
          "1940:     rc = imap_exec_msgset(mdata, \"UID COPY\", mmbox, MUTT_TRASH, false, false);",
          "",
          "[Added Lines]",
          "1940:     rc = imap_exec_msgset(adata, \"UID COPY\", mmbox, MUTT_TRASH, false, false);",
          "",
          "---------------",
          "--- Hunk 60 ---",
          "[Context before]",
          "1956:     }",
          "1960:     if (rc == -2)",
          "1961:     {",
          "1962:       if (triedcreate)",
          "",
          "[Removed Lines]",
          "1959:     rc = imap_exec(mdata, NULL, IMAP_CMD_FAIL_OK);",
          "",
          "[Added Lines]",
          "1959:     rc = imap_exec(adata, NULL, IMAP_CMD_FAIL_OK);",
          "",
          "---------------",
          "--- Hunk 61 ---",
          "[Context before]",
          "1965:         break;",
          "1966:       }",
          "1969:         break;",
          "1970:       mutt_debug(3, \"server suggests TRYCREATE\\n\");",
          "1971:       snprintf(prompt, sizeof(prompt), _(\"Create %s?\"), mbox);",
          "",
          "[Removed Lines]",
          "1968:       if (mutt_str_strncasecmp(imap_get_qualifier(mdata->buf), \"[TRYCREATE]\", 11) != 0)",
          "",
          "[Added Lines]",
          "1968:       if (mutt_str_strncasecmp(imap_get_qualifier(adata->buf), \"[TRYCREATE]\", 11) != 0)",
          "",
          "---------------",
          "--- Hunk 62 ---",
          "[Context before]",
          "1974:         mutt_clear_error();",
          "1975:         goto out;",
          "1976:       }",
          "1978:         break;",
          "1979:       triedcreate = true;",
          "1980:     }",
          "",
          "[Removed Lines]",
          "1977:       if (imap_create_mailbox(mdata, mbox) < 0)",
          "",
          "[Added Lines]",
          "1977:       if (imap_create_mailbox(adata, mbox) < 0)",
          "",
          "---------------",
          "--- Hunk 63 ---",
          "[Context before]",
          "1983:   if (rc != 0)",
          "1984:   {",
          "1986:     goto out;",
          "1987:   }",
          "",
          "[Removed Lines]",
          "1985:     imap_error(\"imap_fast_trash\", mdata->buf);",
          "",
          "[Added Lines]",
          "1985:     imap_error(\"imap_fast_trash\", adata->buf);",
          "",
          "---------------",
          "--- Hunk 64 ---",
          "[Context before]",
          "2010:   int oldsort;",
          "2011:   int rc;",
          "2016:   {",
          "2017:     mutt_debug(2, \"no mailbox selected\\n\");",
          "2018:     return -1;",
          "",
          "[Removed Lines]",
          "2013:   struct ImapMboxData *mdata = ctx->mailbox->data;",
          "2015:   if (mdata->state < IMAP_SELECTED)",
          "",
          "[Added Lines]",
          "2013:   struct ImapAccountData *adata = ctx->mailbox->data;",
          "2015:   if (adata->state < IMAP_SELECTED)",
          "",
          "---------------",
          "--- Hunk 65 ---",
          "[Context before]",
          "2023:   imap_allow_reopen(ctx);",
          "2026:   if (rc != 0)",
          "2027:     return rc;",
          "2030:   if (expunge && mutt_bit_isset(ctx->mailbox->rights, MUTT_ACL_DELETE))",
          "2031:   {",
          "2033:                           MUTT_DELETED, true, false);",
          "2034:     if (rc < 0)",
          "2035:     {",
          "",
          "[Removed Lines]",
          "2025:   rc = imap_check(mdata, false);",
          "2032:     rc = imap_exec_msgset(mdata, \"UID STORE\", \"+FLAGS.SILENT (\\\\Deleted)\",",
          "",
          "[Added Lines]",
          "2025:   rc = imap_check(adata, false);",
          "2032:     rc = imap_exec_msgset(adata, \"UID STORE\", \"+FLAGS.SILENT (\\\\Deleted)\",",
          "",
          "---------------",
          "--- Hunk 66 ---",
          "[Context before]",
          "2051:   }",
          "2053: #ifdef USE_HCACHE",
          "2055: #endif",
          "",
          "[Removed Lines]",
          "2054:   mdata->hcache = imap_hcache_open(mdata, NULL);",
          "",
          "[Added Lines]",
          "2054:   adata->hcache = imap_hcache_open(adata, NULL);",
          "",
          "---------------",
          "--- Hunk 67 ---",
          "[Context before]",
          "2062:     if (e->deleted)",
          "2063:     {",
          "2065: #ifdef USE_HCACHE",
          "2067: #endif",
          "2068:     }",
          "2070:     if (e->active && e->changed)",
          "2071:     {",
          "2072: #ifdef USE_HCACHE",
          "2074: #endif",
          "",
          "[Removed Lines]",
          "2064:       imap_cache_del(mdata, e);",
          "2066:       imap_hcache_del(mdata, IMAP_EDATA(e)->uid);",
          "2073:       imap_hcache_put(mdata, e);",
          "",
          "[Added Lines]",
          "2064:       imap_cache_del(adata, e);",
          "2066:       imap_hcache_del(adata, IMAP_EDATA(e)->uid);",
          "2073:       imap_hcache_put(adata, e);",
          "",
          "---------------",
          "--- Hunk 68 ---",
          "[Context before]",
          "2094:   }",
          "2096: #ifdef USE_HCACHE",
          "2098: #endif",
          "",
          "[Removed Lines]",
          "2097:   imap_hcache_close(mdata);",
          "",
          "[Added Lines]",
          "2097:   imap_hcache_close(adata);",
          "",
          "---------------",
          "--- Hunk 69 ---",
          "[Context before]",
          "2111:           mutt_get_sort_func(SORT_ORDER));",
          "2112:   }",
          "2115:   if (rc >= 0)",
          "2117:   if (rc >= 0)",
          "2119:   if (rc >= 0)",
          "2121:   if (rc >= 0)",
          "2124:   if (oldsort != Sort)",
          "2125:   {",
          "",
          "[Removed Lines]",
          "2114:   rc = sync_helper(mdata, MUTT_ACL_DELETE, MUTT_DELETED, \"\\\\Deleted\");",
          "2116:     rc |= sync_helper(mdata, MUTT_ACL_WRITE, MUTT_FLAG, \"\\\\Flagged\");",
          "2118:     rc |= sync_helper(mdata, MUTT_ACL_WRITE, MUTT_OLD, \"Old\");",
          "2120:     rc |= sync_helper(mdata, MUTT_ACL_SEEN, MUTT_READ, \"\\\\Seen\");",
          "2122:     rc |= sync_helper(mdata, MUTT_ACL_WRITE, MUTT_REPLIED, \"\\\\Answered\");",
          "",
          "[Added Lines]",
          "2114:   rc = sync_helper(adata, MUTT_ACL_DELETE, MUTT_DELETED, \"\\\\Deleted\");",
          "2116:     rc |= sync_helper(adata, MUTT_ACL_WRITE, MUTT_FLAG, \"\\\\Flagged\");",
          "2118:     rc |= sync_helper(adata, MUTT_ACL_WRITE, MUTT_OLD, \"Old\");",
          "2120:     rc |= sync_helper(adata, MUTT_ACL_SEEN, MUTT_READ, \"\\\\Seen\");",
          "2122:     rc |= sync_helper(adata, MUTT_ACL_WRITE, MUTT_REPLIED, \"\\\\Answered\");",
          "",
          "---------------",
          "--- Hunk 70 ---",
          "[Context before]",
          "2132:   if (rc > 0)",
          "2134:       rc = -1;",
          "2136:   if (rc < 0)",
          "",
          "[Removed Lines]",
          "2133:     if (imap_exec(mdata, NULL, 0) != IMAP_CMD_OK)",
          "",
          "[Added Lines]",
          "2133:     if (imap_exec(adata, NULL, 0) != IMAP_CMD_OK)",
          "",
          "---------------",
          "--- Hunk 71 ---",
          "[Context before]",
          "2140:       if (mutt_yesorno(_(\"Error saving flags. Close anyway?\"), 0) == MUTT_YES)",
          "2141:       {",
          "2142:         rc = 0;",
          "2144:         goto out;",
          "2145:       }",
          "2146:     }",
          "",
          "[Removed Lines]",
          "2143:         mdata->state = IMAP_AUTHENTICATED;",
          "",
          "[Added Lines]",
          "2143:         adata->state = IMAP_AUTHENTICATED;",
          "",
          "---------------",
          "--- Hunk 72 ---",
          "[Context before]",
          "2169:   {",
          "2170:     mutt_message(_(\"Expunging messages from server...\"));",
          "2174:     {",
          "2177:       rc = -1;",
          "2178:       goto out;",
          "2179:     }",
          "2181:   }",
          "2183:   if (expunge && ctx->mailbox->closing)",
          "2184:   {",
          "2187:   }",
          "2189:   if (MessageCacheClean)",
          "2192:   rc = 0;",
          "",
          "[Removed Lines]",
          "2172:     mdata->reopen |= IMAP_EXPUNGE_EXPECTED;",
          "2173:     if (imap_exec(mdata, \"EXPUNGE\", 0) != 0)",
          "2175:       mdata->reopen &= ~IMAP_EXPUNGE_EXPECTED;",
          "2176:       imap_error(_(\"imap_sync_mailbox: EXPUNGE failed\"), mdata->buf);",
          "2180:     mdata->reopen &= ~IMAP_EXPUNGE_EXPECTED;",
          "2185:     imap_exec(mdata, \"CLOSE\", IMAP_CMD_QUEUE);",
          "2186:     mdata->state = IMAP_AUTHENTICATED;",
          "2190:     imap_cache_clean(mdata);",
          "",
          "[Added Lines]",
          "2172:     adata->reopen |= IMAP_EXPUNGE_EXPECTED;",
          "2173:     if (imap_exec(adata, \"EXPUNGE\", 0) != 0)",
          "2175:       adata->reopen &= ~IMAP_EXPUNGE_EXPECTED;",
          "2176:       imap_error(_(\"imap_sync_mailbox: EXPUNGE failed\"), adata->buf);",
          "2180:     adata->reopen &= ~IMAP_EXPUNGE_EXPECTED;",
          "2185:     imap_exec(adata, \"CLOSE\", IMAP_CMD_QUEUE);",
          "2186:     adata->state = IMAP_AUTHENTICATED;",
          "2190:     imap_cache_clean(adata);",
          "",
          "---------------",
          "--- Hunk 73 ---",
          "[Context before]",
          "2206: static int imap_mbox_open(struct Context *ctx)",
          "2207: {",
          "2209:   struct ImapStatus *status = NULL;",
          "2210:   char buf[PATH_MAX];",
          "2211:   char bufout[PATH_MAX];",
          "",
          "[Removed Lines]",
          "2208:   struct ImapMboxData *mdata = NULL;",
          "",
          "[Added Lines]",
          "2208:   struct ImapAccountData *adata = NULL;",
          "",
          "---------------",
          "--- Hunk 74 ---",
          "[Context before]",
          "2221:   }",
          "2226:     goto fail_noidata;",
          "2228:     goto fail;",
          "2235:   if (!*buf)",
          "2236:     mutt_str_strfcpy(buf, \"INBOX\", sizeof(buf));",
          "2241:   mutt_str_strfcpy(ctx->mailbox->path, buf, sizeof(ctx->mailbox->path));",
          "2242:   mutt_str_strfcpy(ctx->mailbox->realpath, ctx->mailbox->path,",
          "2243:                    sizeof(ctx->mailbox->realpath));",
          "2258:   {",
          "2259:     snprintf(bufout, sizeof(bufout), \"MYRIGHTS %s\", buf);",
          "2261:   }",
          "2263:   else",
          "2264:   {",
          "2273:   }",
          "2275:   pmx.mbox = NULL;",
          "",
          "[Removed Lines]",
          "2224:   mdata = imap_conn_find(&(mx.account), MUTT_IMAP_CONN_NOSELECT);",
          "2225:   if (!mdata)",
          "2227:   if (mdata->state < IMAP_AUTHENTICATED)",
          "2231:   ctx->mailbox->data = mdata;",
          "2234:   imap_fix_path(mdata, mx.mbox, buf, sizeof(buf));",
          "2237:   FREE(&(mdata->mbox_name));",
          "2238:   mdata->mbox_name = mutt_str_strdup(buf);",
          "2239:   imap_qualify_path(buf, sizeof(buf), &mx, mdata->mbox_name);",
          "2245:   mdata->ctx = ctx;",
          "2248:   mdata->status = false;",
          "2249:   memset(mdata->ctx->mailbox->rights, 0, sizeof(mdata->ctx->mailbox->rights));",
          "2250:   mdata->new_mail_count = 0;",
          "2251:   mdata->max_msn = 0;",
          "2253:   mutt_message(_(\"Selecting %s...\"), mdata->mbox_name);",
          "2254:   imap_munge_mbox_name(mdata, buf, sizeof(buf), mdata->mbox_name);",
          "2257:   if (mutt_bit_isset(mdata->capabilities, ACL))",
          "2260:     imap_exec(mdata, bufout, IMAP_CMD_QUEUE);",
          "2265:     mutt_bit_set(mdata->ctx->mailbox->rights, MUTT_ACL_LOOKUP);",
          "2266:     mutt_bit_set(mdata->ctx->mailbox->rights, MUTT_ACL_READ);",
          "2267:     mutt_bit_set(mdata->ctx->mailbox->rights, MUTT_ACL_SEEN);",
          "2268:     mutt_bit_set(mdata->ctx->mailbox->rights, MUTT_ACL_WRITE);",
          "2269:     mutt_bit_set(mdata->ctx->mailbox->rights, MUTT_ACL_INSERT);",
          "2270:     mutt_bit_set(mdata->ctx->mailbox->rights, MUTT_ACL_POST);",
          "2271:     mutt_bit_set(mdata->ctx->mailbox->rights, MUTT_ACL_CREATE);",
          "2272:     mutt_bit_set(mdata->ctx->mailbox->rights, MUTT_ACL_DELETE);",
          "",
          "[Added Lines]",
          "2224:   adata = imap_conn_find(&(mx.account), MUTT_IMAP_CONN_NOSELECT);",
          "2225:   if (!adata)",
          "2227:   if (adata->state < IMAP_AUTHENTICATED)",
          "2231:   ctx->mailbox->data = adata;",
          "2234:   imap_fix_path(adata, mx.mbox, buf, sizeof(buf));",
          "2237:   FREE(&(adata->mbox_name));",
          "2238:   adata->mbox_name = mutt_str_strdup(buf);",
          "2239:   imap_qualify_path(buf, sizeof(buf), &mx, adata->mbox_name);",
          "2245:   adata->ctx = ctx;",
          "2248:   adata->status = false;",
          "2249:   memset(adata->ctx->mailbox->rights, 0, sizeof(adata->ctx->mailbox->rights));",
          "2250:   adata->new_mail_count = 0;",
          "2251:   adata->max_msn = 0;",
          "2253:   mutt_message(_(\"Selecting %s...\"), adata->mbox_name);",
          "2254:   imap_munge_mbox_name(adata, buf, sizeof(buf), adata->mbox_name);",
          "2257:   if (mutt_bit_isset(adata->capabilities, ACL))",
          "2260:     imap_exec(adata, bufout, IMAP_CMD_QUEUE);",
          "2265:     mutt_bit_set(adata->ctx->mailbox->rights, MUTT_ACL_LOOKUP);",
          "2266:     mutt_bit_set(adata->ctx->mailbox->rights, MUTT_ACL_READ);",
          "2267:     mutt_bit_set(adata->ctx->mailbox->rights, MUTT_ACL_SEEN);",
          "2268:     mutt_bit_set(adata->ctx->mailbox->rights, MUTT_ACL_WRITE);",
          "2269:     mutt_bit_set(adata->ctx->mailbox->rights, MUTT_ACL_INSERT);",
          "2270:     mutt_bit_set(adata->ctx->mailbox->rights, MUTT_ACL_POST);",
          "2271:     mutt_bit_set(adata->ctx->mailbox->rights, MUTT_ACL_CREATE);",
          "2272:     mutt_bit_set(adata->ctx->mailbox->rights, MUTT_ACL_DELETE);",
          "",
          "---------------",
          "--- Hunk 75 ---",
          "[Context before]",
          "2281:   FREE(&pmx.mbox);",
          "2283:   if (ImapCheckSubscribed)",
          "2286: #ifdef USE_HCACHE",
          "2288:     condstore = \" (CONDSTORE)\";",
          "2289:   else",
          "2290: #endif",
          "",
          "[Removed Lines]",
          "2284:     imap_exec(mdata, \"LSUB \\\"\\\" \\\"*\\\"\", IMAP_CMD_QUEUE);",
          "2287:   if (mutt_bit_isset(mdata->capabilities, CONDSTORE) && ImapCondStore)",
          "",
          "[Added Lines]",
          "2284:     imap_exec(adata, \"LSUB \\\"\\\" \\\"*\\\"\", IMAP_CMD_QUEUE);",
          "2287:   if (mutt_bit_isset(adata->capabilities, CONDSTORE) && ImapCondStore)",
          "",
          "---------------",
          "--- Hunk 76 ---",
          "[Context before]",
          "2293:   snprintf(bufout, sizeof(bufout), \"%s %s%s\",",
          "2294:            ctx->mailbox->readonly ? \"EXAMINE\" : \"SELECT\", buf, condstore);",
          "2302:   do",
          "2303:   {",
          "2304:     char *pc = NULL;",
          "2307:     if (rc != IMAP_CMD_CONTINUE)",
          "2308:       break;",
          "2314:     if (mutt_str_strncasecmp(\"FLAGS\", pc, 5) == 0)",
          "2315:     {",
          "2318:       {",
          "2319:         mutt_debug(3, \"Getting mailbox FLAGS\\n\");",
          "2321:         if (!pc)",
          "2322:           goto fail;",
          "2323:       }",
          "",
          "[Removed Lines]",
          "2296:   mdata->state = IMAP_SELECTED;",
          "2298:   imap_cmd_start(mdata, bufout);",
          "2300:   status = imap_mboxcache_get(mdata, mdata->mbox_name, true);",
          "2306:     rc = imap_cmd_step(mdata);",
          "2310:     pc = mdata->buf + 2;",
          "2317:       if (STAILQ_EMPTY(&mdata->flags))",
          "2320:         pc = get_flags(&mdata->flags, pc);",
          "",
          "[Added Lines]",
          "2296:   adata->state = IMAP_SELECTED;",
          "2298:   imap_cmd_start(adata, bufout);",
          "2300:   status = imap_mboxcache_get(adata, adata->mbox_name, true);",
          "2306:     rc = imap_cmd_step(adata);",
          "2310:     pc = adata->buf + 2;",
          "2317:       if (STAILQ_EMPTY(&adata->flags))",
          "2320:         pc = get_flags(&adata->flags, pc);",
          "",
          "---------------",
          "--- Hunk 77 ---",
          "[Context before]",
          "2327:     {",
          "2328:       mutt_debug(3, \"Getting mailbox PERMANENTFLAGS\\n\");",
          "2332:       pc += 13;",
          "2334:       if (!pc)",
          "2335:         goto fail;",
          "2336:     }",
          "",
          "[Removed Lines]",
          "2330:       mutt_list_free(&mdata->flags);",
          "2333:       pc = get_flags(&(mdata->flags), pc);",
          "",
          "[Added Lines]",
          "2330:       mutt_list_free(&adata->flags);",
          "2333:       pc = get_flags(&(adata->flags), pc);",
          "",
          "---------------",
          "--- Hunk 78 ---",
          "[Context before]",
          "2340:       mutt_debug(3, \"Getting mailbox UIDVALIDITY\\n\");",
          "2341:       pc += 3;",
          "2342:       pc = imap_next_word(pc);",
          "2344:         goto fail;",
          "2346:     }",
          "2347:     else if (mutt_str_strncasecmp(\"OK [UIDNEXT\", pc, 11) == 0)",
          "2348:     {",
          "2349:       mutt_debug(3, \"Getting mailbox UIDNEXT\\n\");",
          "2350:       pc += 3;",
          "2351:       pc = imap_next_word(pc);",
          "2353:         goto fail;",
          "2355:     }",
          "2356:     else if (mutt_str_strncasecmp(\"OK [HIGHESTMODSEQ\", pc, 17) == 0)",
          "2357:     {",
          "2358:       mutt_debug(3, \"Getting mailbox HIGHESTMODSEQ\\n\");",
          "2359:       pc += 3;",
          "2360:       pc = imap_next_word(pc);",
          "2362:         goto fail;",
          "2364:     }",
          "2365:     else if (mutt_str_strncasecmp(\"OK [NOMODSEQ\", pc, 12) == 0)",
          "2366:     {",
          "2367:       mutt_debug(3, \"Mailbox has NOMODSEQ set\\n\");",
          "2369:     }",
          "2370:     else",
          "2371:     {",
          "2372:       pc = imap_next_word(pc);",
          "2373:       if (mutt_str_strncasecmp(\"EXISTS\", pc, 6) == 0)",
          "2374:       {",
          "2377:       }",
          "2378:     }",
          "2379:   } while (rc == IMAP_CMD_CONTINUE);",
          "2381:   if (rc == IMAP_CMD_NO)",
          "2382:   {",
          "2385:     mutt_error(\"%s\", s);",
          "2386:     goto fail;",
          "",
          "[Removed Lines]",
          "2343:       if (mutt_str_atoui(pc, &mdata->uid_validity) < 0)",
          "2345:       status->uidvalidity = mdata->uid_validity;",
          "2352:       if (mutt_str_atoui(pc, &mdata->uidnext) < 0)",
          "2354:       status->uidnext = mdata->uidnext;",
          "2361:       if (mutt_str_atoull(pc, &mdata->modseq) < 0)",
          "2363:       status->modseq = mdata->modseq;",
          "2368:       status->modseq = mdata->modseq = 0;",
          "2375:         count = mdata->new_mail_count;",
          "2376:         mdata->new_mail_count = 0;",
          "",
          "[Added Lines]",
          "2343:       if (mutt_str_atoui(pc, &adata->uid_validity) < 0)",
          "2345:       status->uidvalidity = adata->uid_validity;",
          "2352:       if (mutt_str_atoui(pc, &adata->uidnext) < 0)",
          "2354:       status->uidnext = adata->uidnext;",
          "2361:       if (mutt_str_atoull(pc, &adata->modseq) < 0)",
          "2363:       status->modseq = adata->modseq;",
          "2368:       status->modseq = adata->modseq = 0;",
          "2375:         count = adata->new_mail_count;",
          "2376:         adata->new_mail_count = 0;",
          "",
          "---------------",
          "--- Hunk 79 ---",
          "[Context before]",
          "2390:     goto fail;",
          "2395:   {",
          "2396:     mutt_debug(2, \"Mailbox is read-only.\\n\");",
          "2397:     ctx->mailbox->readonly = true;",
          "",
          "[Removed Lines]",
          "2393:   if ((mutt_str_strncasecmp(imap_get_qualifier(mdata->buf), \"[READ-ONLY]\", 11) == 0) &&",
          "2394:       !mutt_bit_isset(mdata->capabilities, ACL))",
          "",
          "[Added Lines]",
          "2393:   if ((mutt_str_strncasecmp(imap_get_qualifier(adata->buf), \"[READ-ONLY]\", 11) == 0) &&",
          "2394:       !mutt_bit_isset(adata->capabilities, ACL))",
          "",
          "---------------",
          "--- Hunk 80 ---",
          "[Context before]",
          "2401:   if (DebugLevel > 2)",
          "2402:   {",
          "2404:       mutt_debug(3, \"No folder flags found\\n\");",
          "2405:     else",
          "2406:     {",
          "",
          "[Removed Lines]",
          "2403:     if (STAILQ_EMPTY(&mdata->flags))",
          "",
          "[Added Lines]",
          "2403:     if (STAILQ_EMPTY(&adata->flags))",
          "",
          "---------------",
          "--- Hunk 81 ---",
          "[Context before]",
          "2408:       struct Buffer flag_buffer;",
          "2409:       mutt_buffer_init(&flag_buffer);",
          "2410:       mutt_buffer_printf(&flag_buffer, \"Mailbox flags: \");",
          "2412:       {",
          "2413:         mutt_buffer_printf(&flag_buffer, \"[%s] \", np->data);",
          "2414:       }",
          "",
          "[Removed Lines]",
          "2411:       STAILQ_FOREACH(np, &mdata->flags, entries)",
          "",
          "[Added Lines]",
          "2411:       STAILQ_FOREACH(np, &adata->flags, entries)",
          "",
          "---------------",
          "--- Hunk 82 ---",
          "[Context before]",
          "2417:     }",
          "2418:   }",
          "2424:   {",
          "2425:     ctx->mailbox->readonly = true;",
          "2426:   }",
          "",
          "[Removed Lines]",
          "2420:   if (!(mutt_bit_isset(mdata->ctx->mailbox->rights, MUTT_ACL_DELETE) ||",
          "2421:         mutt_bit_isset(mdata->ctx->mailbox->rights, MUTT_ACL_SEEN) ||",
          "2422:         mutt_bit_isset(mdata->ctx->mailbox->rights, MUTT_ACL_WRITE) ||",
          "2423:         mutt_bit_isset(mdata->ctx->mailbox->rights, MUTT_ACL_INSERT)))",
          "",
          "[Added Lines]",
          "2420:   if (!(mutt_bit_isset(adata->ctx->mailbox->rights, MUTT_ACL_DELETE) ||",
          "2421:         mutt_bit_isset(adata->ctx->mailbox->rights, MUTT_ACL_SEEN) ||",
          "2422:         mutt_bit_isset(adata->ctx->mailbox->rights, MUTT_ACL_WRITE) ||",
          "2423:         mutt_bit_isset(adata->ctx->mailbox->rights, MUTT_ACL_INSERT)))",
          "",
          "---------------",
          "--- Hunk 83 ---",
          "[Context before]",
          "2430:   ctx->mailbox->v2r = mutt_mem_calloc(count, sizeof(int));",
          "2431:   ctx->mailbox->msg_count = 0;",
          "2434:   {",
          "2435:     mutt_error(_(\"Error opening mailbox\"));",
          "2436:     goto fail;",
          "",
          "[Removed Lines]",
          "2433:   if (count && (imap_read_headers(mdata, 1, count, true) < 0))",
          "",
          "[Added Lines]",
          "2433:   if (count && (imap_read_headers(adata, 1, count, true) < 0))",
          "",
          "---------------",
          "--- Hunk 84 ---",
          "[Context before]",
          "2441:   return 0;",
          "2443: fail:",
          "2446: fail_noidata:",
          "2447:   FREE(&mx.mbox);",
          "2448:   return -1;",
          "",
          "[Removed Lines]",
          "2444:   if (mdata->state == IMAP_SELECTED)",
          "2445:     mdata->state = IMAP_AUTHENTICATED;",
          "",
          "[Added Lines]",
          "2444:   if (adata->state == IMAP_SELECTED)",
          "2445:     adata->state = IMAP_AUTHENTICATED;",
          "",
          "---------------",
          "--- Hunk 85 ---",
          "[Context before]",
          "2454: static int imap_mbox_open_append(struct Context *ctx, int flags)",
          "2455: {",
          "2457:   char mailbox[PATH_MAX];",
          "2458:   struct ImapMbox mx;",
          "2459:   int rc;",
          "",
          "[Removed Lines]",
          "2456:   struct ImapMboxData *mdata = NULL;",
          "",
          "[Added Lines]",
          "2456:   struct ImapAccountData *adata = NULL;",
          "",
          "---------------",
          "--- Hunk 86 ---",
          "[Context before]",
          "2469:   {",
          "2470:     FREE(&mx.mbox);",
          "2471:     return -1;",
          "2472:   }",
          "2477:   if (!*mailbox)",
          "2478:     mutt_str_strfcpy(mailbox, \"INBOX\", sizeof(mailbox));",
          "2479:   FREE(&mx.mbox);",
          "",
          "[Removed Lines]",
          "2467:   mdata = imap_conn_find(&(mx.account), 0);",
          "2468:   if (!mdata)",
          "2474:   ctx->mailbox->data = mdata;",
          "2476:   imap_fix_path(mdata, mx.mbox, mailbox, sizeof(mailbox));",
          "",
          "[Added Lines]",
          "2467:   adata = imap_conn_find(&(mx.account), 0);",
          "2468:   if (!adata)",
          "2474:   ctx->mailbox->data = adata;",
          "2476:   imap_fix_path(adata, mx.mbox, mailbox, sizeof(mailbox));",
          "",
          "---------------",
          "--- Hunk 87 ---",
          "[Context before]",
          "2490:   if (Confirmcreate && mutt_yesorno(buf, 1) != MUTT_YES)",
          "2491:     return -1;",
          "2494:     return -1;",
          "2496:   return 0;",
          "",
          "[Removed Lines]",
          "2493:   if (imap_create_mailbox(mdata, mailbox) < 0)",
          "",
          "[Added Lines]",
          "2493:   if (imap_create_mailbox(adata, mailbox) < 0)",
          "",
          "---------------",
          "--- Hunk 88 ---",
          "[Context before]",
          "2524: static int imap_mbox_close(struct Context *ctx)",
          "2525: {",
          "2529:     return 0;",
          "2540:   {",
          "2542:     {",
          "2545:       if (!ctx->deleted)",
          "2548:     }",
          "2560:     for (int i = 0; i < IMAP_CACHE_LEN; i++)",
          "2561:     {",
          "2563:       {",
          "2566:       }",
          "2567:     }",
          "2570:   }",
          "2572:   return 0;",
          "",
          "[Removed Lines]",
          "2526:   struct ImapMboxData *mdata = ctx->mailbox->data;",
          "2528:   if (!mdata)",
          "2539:   if (ctx == mdata->ctx)",
          "2541:     if (mdata->status != IMAP_FATAL && mdata->state >= IMAP_SELECTED)",
          "2546:         imap_exec(mdata, \"CLOSE\", IMAP_CMD_QUEUE);",
          "2547:       mdata->state = IMAP_AUTHENTICATED;",
          "2550:     mdata->reopen &= IMAP_REOPEN_ALLOW;",
          "2551:     FREE(&(mdata->mbox_name));",
          "2552:     mutt_list_free(&mdata->flags);",
          "2553:     mdata->ctx = NULL;",
          "2555:     mutt_hash_destroy(&mdata->uid_hash);",
          "2556:     FREE(&mdata->msn_index);",
          "2557:     mdata->msn_index_size = 0;",
          "2558:     mdata->max_msn = 0;",
          "2562:       if (mdata->cache[i].path)",
          "2564:         unlink(mdata->cache[i].path);",
          "2565:         FREE(&mdata->cache[i].path);",
          "2569:     mutt_bcache_close(&mdata->bcache);",
          "",
          "[Added Lines]",
          "2526:   struct ImapAccountData *adata = ctx->mailbox->data;",
          "2528:   if (!adata)",
          "2539:   if (ctx == adata->ctx)",
          "2541:     if (adata->status != IMAP_FATAL && adata->state >= IMAP_SELECTED)",
          "2546:         imap_exec(adata, \"CLOSE\", IMAP_CMD_QUEUE);",
          "2547:       adata->state = IMAP_AUTHENTICATED;",
          "2550:     adata->reopen &= IMAP_REOPEN_ALLOW;",
          "2551:     FREE(&(adata->mbox_name));",
          "2552:     mutt_list_free(&adata->flags);",
          "2553:     adata->ctx = NULL;",
          "2555:     mutt_hash_destroy(&adata->uid_hash);",
          "2556:     FREE(&adata->msn_index);",
          "2557:     adata->msn_index_size = 0;",
          "2558:     adata->max_msn = 0;",
          "2562:       if (adata->cache[i].path)",
          "2564:         unlink(adata->cache[i].path);",
          "2565:         FREE(&adata->cache[i].path);",
          "2569:     mutt_bcache_close(&adata->bcache);",
          "",
          "---------------",
          "--- Hunk 89 ---",
          "[Context before]",
          "2597: {",
          "2598:   char *new = NULL;",
          "2599:   char *checker = NULL;",
          "2604:   {",
          "2605:     mutt_error(_(\"IMAP server doesn't support custom flags\"));",
          "2606:     return -1;",
          "",
          "[Removed Lines]",
          "2600:   struct ImapMboxData *mdata = ctx->mailbox->data;",
          "2603:   if (!imap_has_flag(&mdata->flags, NULL))",
          "",
          "[Added Lines]",
          "2600:   struct ImapAccountData *adata = ctx->mailbox->data;",
          "2603:   if (!imap_has_flag(&adata->flags, NULL))",
          "",
          "---------------",
          "--- Hunk 90 ---",
          "[Context before]",
          "2684:   struct Buffer *cmd = NULL;",
          "2685:   char uid[11];",
          "2689:   if (*buf == '\\0')",
          "2690:     buf = NULL;",
          "2693:     return 0;",
          "2695:   snprintf(uid, sizeof(uid), \"%u\", IMAP_EDATA(e)->uid);",
          "",
          "[Removed Lines]",
          "2687:   struct ImapMboxData *mdata = ctx->mailbox->data;",
          "2692:   if (!mutt_bit_isset(mdata->ctx->mailbox->rights, MUTT_ACL_WRITE))",
          "",
          "[Added Lines]",
          "2687:   struct ImapAccountData *adata = ctx->mailbox->data;",
          "2692:   if (!mutt_bit_isset(adata->ctx->mailbox->rights, MUTT_ACL_WRITE))",
          "",
          "---------------",
          "--- Hunk 91 ---",
          "[Context before]",
          "2716:     {",
          "2717:       mutt_buffer_free(&cmd);",
          "2718:       return -1;",
          "",
          "[Removed Lines]",
          "2715:     if (imap_exec(mdata, cmd->data, 0) != 0)",
          "",
          "[Added Lines]",
          "2715:     if (imap_exec(adata, cmd->data, 0) != 0)",
          "",
          "---------------",
          "--- Hunk 92 ---",
          "[Context before]",
          "2737:     mutt_buffer_addstr(cmd, buf);",
          "2738:     mutt_buffer_addstr(cmd, \")\");",
          "2741:     {",
          "2742:       mutt_debug(1, \"fail to add new flags\\n\");",
          "2743:       mutt_buffer_free(&cmd);",
          "",
          "[Removed Lines]",
          "2740:     if (imap_exec(mdata, cmd->data, 0) != 0)",
          "",
          "[Added Lines]",
          "2740:     if (imap_exec(adata, cmd->data, 0) != 0)",
          "",
          "---------------"
        ],
        "imap/imap_private.h||imap/imap_private.h": [
          "File: imap/imap_private.h -> imap/imap_private.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "202: };",
          "210: {",
          "211:   struct Connection *conn;",
          "212:   bool recovering;",
          "",
          "[Removed Lines]",
          "209: struct ImapMboxData",
          "",
          "[Added Lines]",
          "209: struct ImapAccountData",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "295:                      int flag, bool changed, bool invert);",
          "303: bool imap_has_flag(struct ListHead *flag_list, const char *flag);",
          "312: bool imap_code(const char *s);",
          "318: void imap_free_emaildata(void **data);",
          "323: int imap_append_message(struct Context *ctx, struct Message *msg);",
          "325: int imap_msg_open(struct Context *ctx, struct Message *msg, int msgno);",
          "",
          "[Removed Lines]",
          "289: int imap_check(struct ImapMboxData *mdata, bool force);",
          "290: int imap_create_mailbox(struct ImapMboxData *mdata, char *mailbox);",
          "291: int imap_rename_mailbox(struct ImapMboxData *mdata, struct ImapMbox *mx, const char *newname);",
          "292: struct ImapStatus *imap_mboxcache_get(struct ImapMboxData *mdata, const char *mbox, bool create);",
          "293: void imap_mboxcache_free(struct ImapMboxData *mdata);",
          "294: int imap_exec_msgset(struct ImapMboxData *mdata, const char *pre, const char *post,",
          "296: int imap_open_connection(struct ImapMboxData *mdata);",
          "297: void imap_close_connection(struct ImapMboxData *mdata);",
          "298: struct ImapMboxData *imap_conn_find(const struct ConnAccount *account, int flags);",
          "299: int imap_read_literal(FILE *fp, struct ImapMboxData *mdata, unsigned long bytes, struct Progress *pbar);",
          "300: void imap_expunge_mailbox(struct ImapMboxData *mdata);",
          "301: void imap_logout(struct ImapMboxData **mdata);",
          "302: int imap_sync_message_for_copy(struct ImapMboxData *mdata, struct Email *e, struct Buffer *cmd, int *err_continue);",
          "306: int imap_authenticate(struct ImapMboxData *mdata);",
          "309: int imap_cmd_start(struct ImapMboxData *mdata, const char *cmdstr);",
          "310: int imap_cmd_step(struct ImapMboxData *mdata);",
          "311: void imap_cmd_finish(struct ImapMboxData *mdata);",
          "313: const char *imap_cmd_trailer(struct ImapMboxData *mdata);",
          "314: int imap_exec(struct ImapMboxData *mdata, const char *cmdstr, int flags);",
          "315: int imap_cmd_idle(struct ImapMboxData *mdata);",
          "319: int imap_read_headers(struct ImapMboxData *mdata, unsigned int msn_begin, unsigned int msn_end, bool initial_download);",
          "320: char *imap_set_flags(struct ImapMboxData *mdata, struct Email *e, char *s, int *server_changes);",
          "321: int imap_cache_del(struct ImapMboxData *mdata, struct Email *e);",
          "322: int imap_cache_clean(struct ImapMboxData *mdata);",
          "",
          "[Added Lines]",
          "289: int imap_check(struct ImapAccountData *adata, bool force);",
          "290: int imap_create_mailbox(struct ImapAccountData *adata, char *mailbox);",
          "291: int imap_rename_mailbox(struct ImapAccountData *adata, struct ImapMbox *mx, const char *newname);",
          "292: struct ImapStatus *imap_mboxcache_get(struct ImapAccountData *adata, const char *mbox, bool create);",
          "293: void imap_mboxcache_free(struct ImapAccountData *adata);",
          "294: int imap_exec_msgset(struct ImapAccountData *adata, const char *pre, const char *post,",
          "296: int imap_open_connection(struct ImapAccountData *adata);",
          "297: void imap_close_connection(struct ImapAccountData *adata);",
          "298: struct ImapAccountData *imap_conn_find(const struct ConnAccount *account, int flags);",
          "299: int imap_read_literal(FILE *fp, struct ImapAccountData *adata, unsigned long bytes, struct Progress *pbar);",
          "300: void imap_expunge_mailbox(struct ImapAccountData *adata);",
          "301: void imap_logout(struct ImapAccountData **adata);",
          "302: int imap_sync_message_for_copy(struct ImapAccountData *adata, struct Email *e, struct Buffer *cmd, int *err_continue);",
          "306: int imap_authenticate(struct ImapAccountData *adata);",
          "309: int imap_cmd_start(struct ImapAccountData *adata, const char *cmdstr);",
          "310: int imap_cmd_step(struct ImapAccountData *adata);",
          "311: void imap_cmd_finish(struct ImapAccountData *adata);",
          "313: const char *imap_cmd_trailer(struct ImapAccountData *adata);",
          "314: int imap_exec(struct ImapAccountData *adata, const char *cmdstr, int flags);",
          "315: int imap_cmd_idle(struct ImapAccountData *adata);",
          "319: int imap_read_headers(struct ImapAccountData *adata, unsigned int msn_begin, unsigned int msn_end, bool initial_download);",
          "320: char *imap_set_flags(struct ImapAccountData *adata, struct Email *e, char *s, int *server_changes);",
          "321: int imap_cache_del(struct ImapAccountData *adata, struct Email *e);",
          "322: int imap_cache_clean(struct ImapAccountData *adata);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "330: #ifdef USE_HCACHE",
          "339: #endif",
          "341: int imap_continue(const char *msg, const char *resp);",
          "342: void imap_error(const char *where, const char *msg);",
          "345: struct ImapAccountData *imap_adata_new(void);",
          "349: int imap_get_literal_count(const char *buf, unsigned int *bytes);",
          "350: char *imap_get_qualifier(char *buf);",
          "351: int imap_mxcmp(const char *mx1, const char *mx2);",
          "",
          "[Removed Lines]",
          "331: header_cache_t *imap_hcache_open(struct ImapMboxData *mdata, const char *path);",
          "332: void imap_hcache_close(struct ImapMboxData *mdata);",
          "333: struct Email *imap_hcache_get(struct ImapMboxData *mdata, unsigned int uid);",
          "334: int imap_hcache_put(struct ImapMboxData *mdata, struct Email *e);",
          "335: int imap_hcache_del(struct ImapMboxData *mdata, unsigned int uid);",
          "336: int imap_hcache_store_uid_seqset(struct ImapMboxData *mdata);",
          "337: int imap_hcache_clear_uid_seqset(struct ImapMboxData *mdata);",
          "338: char *imap_hcache_get_uid_seqset(struct ImapMboxData *mdata);",
          "343: struct ImapMboxData *imap_mdata_new(void);",
          "344: void imap_mdata_free(struct ImapMboxData **mdata);",
          "346: void imap_adata_free(void **adata);",
          "347: char *imap_fix_path(struct ImapMboxData *mdata, const char *mailbox, char *path, size_t plen);",
          "348: void imap_cachepath(struct ImapMboxData *mdata, const char *mailbox, char *dest, size_t dlen);",
          "",
          "[Added Lines]",
          "331: header_cache_t *imap_hcache_open(struct ImapAccountData *adata, const char *path);",
          "332: void imap_hcache_close(struct ImapAccountData *adata);",
          "333: struct Email *imap_hcache_get(struct ImapAccountData *adata, unsigned int uid);",
          "334: int imap_hcache_put(struct ImapAccountData *adata, struct Email *e);",
          "335: int imap_hcache_del(struct ImapAccountData *adata, unsigned int uid);",
          "336: int imap_hcache_store_uid_seqset(struct ImapAccountData *adata);",
          "337: int imap_hcache_clear_uid_seqset(struct ImapAccountData *adata);",
          "338: char *imap_hcache_get_uid_seqset(struct ImapAccountData *adata);",
          "344: void imap_adata_free(struct ImapAccountData **adata);",
          "345: char *imap_fix_path(struct ImapAccountData *adata, const char *mailbox, char *path, size_t plen);",
          "346: void imap_cachepath(struct ImapAccountData *adata, const char *mailbox, char *dest, size_t dlen);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "353: void imap_qualify_path(char *buf, size_t buflen, struct ImapMbox *mx, char *path);",
          "354: void imap_quote_string(char *dest, size_t dlen, const char *src, bool quote_backtick);",
          "355: void imap_unquote_string(char *s);",
          "358: struct SeqsetIterator *mutt_seqset_iterator_new(const char *seqset);",
          "359: int mutt_seqset_iterator_next(struct SeqsetIterator *iter, unsigned int *next);",
          "360: void mutt_seqset_iterator_free(struct SeqsetIterator **p_iter);",
          "",
          "[Removed Lines]",
          "356: void imap_munge_mbox_name(struct ImapMboxData *mdata, char *dest, size_t dlen, const char *src);",
          "357: void imap_unmunge_mbox_name(struct ImapMboxData *mdata, char *s);",
          "",
          "[Added Lines]",
          "354: void imap_munge_mbox_name(struct ImapAccountData *adata, char *dest, size_t dlen, const char *src);",
          "355: void imap_unmunge_mbox_name(struct ImapAccountData *adata, char *s);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "362: void imap_get_parent(const char *mbox, char delim, char *buf, size_t buflen);",
          "367: void imap_allow_reopen(struct Context *ctx);",
          "368: void imap_disallow_reopen(struct Context *ctx);",
          "",
          "[Removed Lines]",
          "365: void imap_utf_encode(struct ImapMboxData *mdata, char **s);",
          "366: void imap_utf_decode(struct ImapMboxData *mdata, char **s);",
          "",
          "[Added Lines]",
          "363: void imap_utf_encode(struct ImapAccountData *adata, char **s);",
          "364: void imap_utf_decode(struct ImapAccountData *adata, char **s);",
          "",
          "---------------"
        ],
        "imap/message.c||imap/message.c": [
          "File: imap/message.c -> imap/message.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "87: {",
          "88:   char mailbox[PATH_MAX];",
          "96: }",
          "106: {",
          "108:     return NULL;",
          "111:   char id[64];",
          "114: }",
          "124: {",
          "126:     return NULL;",
          "129:   char id[64];",
          "132: }",
          "142: {",
          "144:     return -1;",
          "147:   char id[64];",
          "151: }",
          "",
          "[Removed Lines]",
          "86: static struct BodyCache *msg_cache_open(struct ImapMboxData *mdata)",
          "90:   if (mdata->bcache)",
          "91:     return mdata->bcache;",
          "93:   imap_cachepath(mdata, mdata->mbox_name, mailbox, sizeof(mailbox));",
          "95:   return mutt_bcache_open(&mdata->conn->account, mailbox);",
          "105: static FILE *msg_cache_get(struct ImapMboxData *mdata, struct Email *e)",
          "107:   if (!mdata || !e)",
          "110:   mdata->bcache = msg_cache_open(mdata);",
          "112:   snprintf(id, sizeof(id), \"%u-%u\", mdata->uid_validity, IMAP_EDATA(e)->uid);",
          "113:   return mutt_bcache_get(mdata->bcache, id);",
          "123: static FILE *msg_cache_put(struct ImapMboxData *mdata, struct Email *e)",
          "125:   if (!mdata || !e)",
          "128:   mdata->bcache = msg_cache_open(mdata);",
          "130:   snprintf(id, sizeof(id), \"%u-%u\", mdata->uid_validity, IMAP_EDATA(e)->uid);",
          "131:   return mutt_bcache_put(mdata->bcache, id);",
          "141: static int msg_cache_commit(struct ImapMboxData *mdata, struct Email *e)",
          "143:   if (!mdata || !e)",
          "146:   mdata->bcache = msg_cache_open(mdata);",
          "148:   snprintf(id, sizeof(id), \"%u-%u\", mdata->uid_validity, IMAP_EDATA(e)->uid);",
          "150:   return mutt_bcache_commit(mdata->bcache, id);",
          "",
          "[Added Lines]",
          "86: static struct BodyCache *msg_cache_open(struct ImapAccountData *adata)",
          "90:   if (adata->bcache)",
          "91:     return adata->bcache;",
          "93:   imap_cachepath(adata, adata->mbox_name, mailbox, sizeof(mailbox));",
          "95:   return mutt_bcache_open(&adata->conn->account, mailbox);",
          "105: static FILE *msg_cache_get(struct ImapAccountData *adata, struct Email *e)",
          "107:   if (!adata || !e)",
          "110:   adata->bcache = msg_cache_open(adata);",
          "112:   snprintf(id, sizeof(id), \"%u-%u\", adata->uid_validity, IMAP_EDATA(e)->uid);",
          "113:   return mutt_bcache_get(adata->bcache, id);",
          "123: static FILE *msg_cache_put(struct ImapAccountData *adata, struct Email *e)",
          "125:   if (!adata || !e)",
          "128:   adata->bcache = msg_cache_open(adata);",
          "130:   snprintf(id, sizeof(id), \"%u-%u\", adata->uid_validity, IMAP_EDATA(e)->uid);",
          "131:   return mutt_bcache_put(adata->bcache, id);",
          "141: static int msg_cache_commit(struct ImapAccountData *adata, struct Email *e)",
          "143:   if (!adata || !e)",
          "146:   adata->bcache = msg_cache_open(adata);",
          "148:   snprintf(id, sizeof(id), \"%u-%u\", adata->uid_validity, IMAP_EDATA(e)->uid);",
          "150:   return mutt_bcache_commit(adata->bcache, id);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "157: static int msg_cache_clean_cb(const char *id, struct BodyCache *bcache, void *data)",
          "158: {",
          "159:   unsigned int uv, uid;",
          "162:   if (sscanf(id, \"%u-%u\", &uv, &uid) != 2)",
          "163:     return 0;",
          "167:     mutt_bcache_del(bcache, id);",
          "169:   return 0;",
          "",
          "[Removed Lines]",
          "160:   struct ImapMboxData *mdata = data;",
          "166:   if (uv != mdata->uid_validity || !mutt_hash_int_find(mdata->uid_hash, uid))",
          "",
          "[Added Lines]",
          "160:   struct ImapAccountData *adata = data;",
          "166:   if (uv != adata->uid_validity || !mutt_hash_int_find(adata->uid_hash, uid))",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "394:   int parse_rc;",
          "398:   if (buf[0] != '*')",
          "399:     return rc;",
          "",
          "[Removed Lines]",
          "396:   struct ImapMboxData *mdata = mailbox->data;",
          "",
          "[Added Lines]",
          "396:   struct ImapAccountData *adata = mailbox->data;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "425:   if (imap_get_literal_count(buf, &bytes) == 0)",
          "426:   {",
          "434:       return rc;",
          "437:       return rc;",
          "438:   }",
          "",
          "[Removed Lines]",
          "427:     imap_read_literal(fp, mdata, bytes, NULL);",
          "433:     if (imap_cmd_step(mdata) != IMAP_CMD_CONTINUE)",
          "436:     if (msg_parse_fetch(h, mdata->buf) == -1)",
          "",
          "[Added Lines]",
          "427:     imap_read_literal(fp, adata, bytes, NULL);",
          "433:     if (imap_cmd_step(adata) != IMAP_CMD_CONTINUE)",
          "436:     if (msg_parse_fetch(h, adata->buf) == -1)",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "471: {",
          "472:   bool abort = false;",
          "",
          "[Removed Lines]",
          "470: static bool query_abort_header_download(struct ImapMboxData *mdata)",
          "",
          "[Added Lines]",
          "470: static bool query_abort_header_download(struct ImapAccountData *adata)",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "476:   if (mutt_yesorno(_(\"Abort download and close mailbox?\"), MUTT_YES) == MUTT_YES)",
          "477:   {",
          "478:     abort = true;",
          "480:   }",
          "481:   SigInt = 0;",
          "",
          "[Removed Lines]",
          "479:     imap_close_connection(mdata);",
          "",
          "[Added Lines]",
          "479:     imap_close_connection(adata);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "494: {",
          "495:   size_t new_size;",
          "498:     return;",
          "",
          "[Removed Lines]",
          "493: static void alloc_msn_index(struct ImapMboxData *mdata, size_t msn_count)",
          "497:   if (msn_count <= mdata->msn_index_size)",
          "",
          "[Added Lines]",
          "493: static void alloc_msn_index(struct ImapAccountData *adata, size_t msn_count)",
          "497:   if (msn_count <= adata->msn_index_size)",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "510:   new_size = msn_count + 25;",
          "514:   else",
          "515:   {",
          "519:   }",
          "522: }",
          "533: {",
          "536: }",
          "",
          "[Removed Lines]",
          "512:   if (!mdata->msn_index)",
          "513:     mdata->msn_index = mutt_mem_calloc(new_size, sizeof(struct Email *));",
          "516:     mutt_mem_realloc(&mdata->msn_index, sizeof(struct Email *) * new_size);",
          "517:     memset(mdata->msn_index + mdata->msn_index_size, 0,",
          "518:            sizeof(struct Email *) * (new_size - mdata->msn_index_size));",
          "521:   mdata->msn_index_size = new_size;",
          "532: static void imap_alloc_uid_hash(struct ImapMboxData *mdata, unsigned int msn_count)",
          "534:   if (!mdata->uid_hash)",
          "535:     mdata->uid_hash = mutt_hash_int_create(MAX(6 * msn_count / 5, 30), 0);",
          "",
          "[Added Lines]",
          "512:   if (!adata->msn_index)",
          "513:     adata->msn_index = mutt_mem_calloc(new_size, sizeof(struct Email *));",
          "516:     mutt_mem_realloc(&adata->msn_index, sizeof(struct Email *) * new_size);",
          "517:     memset(adata->msn_index + adata->msn_index_size, 0,",
          "518:            sizeof(struct Email *) * (new_size - adata->msn_index_size));",
          "521:   adata->msn_index_size = new_size;",
          "532: static void imap_alloc_uid_hash(struct ImapAccountData *adata, unsigned int msn_count)",
          "534:   if (!adata->uid_hash)",
          "535:     adata->uid_hash = mutt_hash_int_create(MAX(6 * msn_count / 5, 30), 0);",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "553:                                   unsigned int msn_begin, unsigned int msn_end)",
          "554: {",
          "555:   int chunks = 0;",
          "",
          "[Removed Lines]",
          "552: static void imap_fetch_msn_seqset(struct Buffer *b, struct ImapMboxData *mdata,",
          "",
          "[Added Lines]",
          "552: static void imap_fetch_msn_seqset(struct Buffer *b, struct ImapAccountData *adata,",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "560:   for (unsigned int msn = msn_begin; msn <= (msn_end + 1); msn++)",
          "561:   {",
          "563:     {",
          "564:       switch (state)",
          "565:       {",
          "",
          "[Removed Lines]",
          "562:     if ((msn <= msn_end) && !mdata->msn_index[msn - 1])",
          "",
          "[Added Lines]",
          "562:     if ((msn <= msn_end) && !adata->msn_index[msn - 1])",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "658:                                           unsigned int msn_end, unsigned int uidnext,",
          "659:                                           bool store_flag_updates, bool eval_condstore)",
          "660: {",
          "661:   struct Progress progress;",
          "662:   char buf[LONG_STRING];",
          "665:   int idx = ctx->mailbox->msg_count;",
          "",
          "[Removed Lines]",
          "657: static int read_headers_normal_eval_cache(struct ImapMboxData *mdata,",
          "664:   struct Context *ctx = mdata->ctx;",
          "",
          "[Added Lines]",
          "657: static int read_headers_normal_eval_cache(struct ImapAccountData *adata,",
          "664:   struct Context *ctx = adata->ctx;",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "674:   snprintf(buf, sizeof(buf), \"UID FETCH 1:%u (UID%s)\", uidnext - 1,",
          "675:            eval_condstore ? \"\" : \" FLAGS\");",
          "679:   int rc = IMAP_CMD_CONTINUE;",
          "680:   int mfhrc = 0;",
          "681:   struct ImapHeader h;",
          "682:   for (int msgno = 1; rc == IMAP_CMD_CONTINUE; msgno++)",
          "683:   {",
          "685:       return -1;",
          "687:     mutt_progress_update(&progress, msgno, -1);",
          "",
          "[Removed Lines]",
          "677:   imap_cmd_start(mdata, buf);",
          "684:     if (SigInt && query_abort_header_download(mdata))",
          "",
          "[Added Lines]",
          "677:   imap_cmd_start(adata, buf);",
          "684:     if (SigInt && query_abort_header_download(adata))",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "690:     h.data = new_emaildata();",
          "691:     do",
          "692:     {",
          "694:       if (rc != IMAP_CMD_CONTINUE)",
          "695:         break;",
          "698:       if (mfhrc < 0)",
          "699:         continue;",
          "",
          "[Removed Lines]",
          "693:       rc = imap_cmd_step(mdata);",
          "697:       mfhrc = msg_fetch_header(ctx->mailbox, &h, mdata->buf, NULL);",
          "",
          "[Added Lines]",
          "693:       rc = imap_cmd_step(adata);",
          "697:       mfhrc = msg_fetch_header(ctx->mailbox, &h, adata->buf, NULL);",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "712:         continue;",
          "713:       }",
          "716:       {",
          "717:         mutt_debug(2, \"skipping hcache FETCH for duplicate message %d\\n\", h.data->msn);",
          "718:         continue;",
          "719:       }",
          "722:       if (ctx->mailbox->hdrs[idx])",
          "723:       {",
          "728:         ctx->mailbox->hdrs[idx]->index = idx;",
          "",
          "[Removed Lines]",
          "715:       if (mdata->msn_index[h.data->msn - 1])",
          "721:       ctx->mailbox->hdrs[idx] = imap_hcache_get(mdata, h.data->uid);",
          "724:         mdata->max_msn = MAX(mdata->max_msn, h.data->msn);",
          "725:         mdata->msn_index[h.data->msn - 1] = ctx->mailbox->hdrs[idx];",
          "726:         mutt_hash_int_insert(mdata->uid_hash, h.data->uid, ctx->mailbox->hdrs[idx]);",
          "",
          "[Added Lines]",
          "715:       if (adata->msn_index[h.data->msn - 1])",
          "721:       ctx->mailbox->hdrs[idx] = imap_hcache_get(adata, h.data->uid);",
          "724:         adata->max_msn = MAX(adata->max_msn, h.data->msn);",
          "725:         adata->msn_index[h.data->msn - 1] = ctx->mailbox->hdrs[idx];",
          "726:         mutt_hash_int_insert(adata->uid_hash, h.data->uid, ctx->mailbox->hdrs[idx]);",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "761:         if (!eval_condstore && store_flag_updates)",
          "764:         h.data = NULL;",
          "765:         idx++;",
          "",
          "[Removed Lines]",
          "762:           imap_hcache_put(mdata, ctx->mailbox->hdrs[idx]);",
          "",
          "[Added Lines]",
          "762:           imap_hcache_put(adata, ctx->mailbox->hdrs[idx]);",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "791: {",
          "792:   int rc;",
          "793:   unsigned int uid = 0;",
          "795:   mutt_debug(2, \"Reading uid seqset from header cache\\n\");",
          "797:   unsigned int msn = 1;",
          "799:   struct SeqsetIterator *iter = mutt_seqset_iterator_new(uid_seqset);",
          "",
          "[Removed Lines]",
          "790: static int read_headers_qresync_eval_cache(struct ImapMboxData *mdata, char *uid_seqset)",
          "796:   struct Context *ctx = mdata->ctx;",
          "",
          "[Added Lines]",
          "790: static int read_headers_qresync_eval_cache(struct ImapAccountData *adata, char *uid_seqset)",
          "796:   struct Context *ctx = adata->ctx;",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "804:   {",
          "811:     if (e)",
          "812:     {",
          "816:       if (ctx->mailbox->msg_count >= ctx->mailbox->hdrmax)",
          "817:         mx_alloc_memory(ctx->mailbox);",
          "",
          "[Removed Lines]",
          "807:     if (msn > mdata->msn_index_size)",
          "808:       alloc_msn_index(mdata, msn);",
          "810:     struct Email *e = imap_hcache_get(mdata, uid);",
          "813:       mdata->max_msn = MAX(mdata->max_msn, msn);",
          "814:       mdata->msn_index[msn - 1] = e;",
          "",
          "[Added Lines]",
          "807:     if (msn > adata->msn_index_size)",
          "808:       alloc_msn_index(adata, msn);",
          "810:     struct Email *e = imap_hcache_get(adata, uid);",
          "813:       adata->max_msn = MAX(adata->max_msn, msn);",
          "814:       adata->msn_index[msn - 1] = e;",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "832:       edata->msn = msn;",
          "833:       edata->uid = uid;",
          "836:       ctx->mailbox->size += e->content->length;",
          "837:       ctx->mailbox->hdrs[ctx->mailbox->msg_count++] = e;",
          "",
          "[Removed Lines]",
          "834:       mutt_hash_int_insert(mdata->uid_hash, uid, e);",
          "",
          "[Added Lines]",
          "834:       mutt_hash_int_insert(adata->uid_hash, uid, e);",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "861:                                                   unsigned int msn_end, unsigned int uidnext,",
          "862:                                                   unsigned long long hc_modseq, bool eval_qresync)",
          "863: {",
          "",
          "[Removed Lines]",
          "860: static int read_headers_condstore_qresync_updates(struct ImapMboxData *mdata,",
          "",
          "[Added Lines]",
          "860: static int read_headers_condstore_qresync_updates(struct ImapAccountData *adata,",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "865:   char buf[LONG_STRING];",
          "866:   unsigned int header_msn = 0;",
          "871:   mutt_progress_init(&progress, _(\"Fetching flag updates...\"),",
          "",
          "[Removed Lines]",
          "868:   struct Context *ctx = mdata->ctx;",
          "",
          "[Added Lines]",
          "868:   struct Context *ctx = adata->ctx;",
          "",
          "---------------",
          "--- Hunk 21 ---",
          "[Context before]",
          "874:   snprintf(buf, sizeof(buf), \"UID FETCH 1:%u (FLAGS) (CHANGEDSINCE %llu%s)\",",
          "875:            uidnext - 1, hc_modseq, eval_qresync ? \" VANISHED\" : \"\");",
          "879:   int rc = IMAP_CMD_CONTINUE;",
          "880:   for (int msgno = 1; rc == IMAP_CMD_CONTINUE; msgno++)",
          "881:   {",
          "883:       return -1;",
          "885:     mutt_progress_update(&progress, msgno, -1);",
          "889:     if (rc != IMAP_CMD_CONTINUE)",
          "890:       break;",
          "895:     if (fetch_buf[0] != '*')",
          "896:       continue;",
          "",
          "[Removed Lines]",
          "877:   imap_cmd_start(mdata, buf);",
          "882:     if (SigInt && query_abort_header_download(mdata))",
          "888:     rc = imap_cmd_step(mdata);",
          "894:     char *fetch_buf = mdata->buf;",
          "",
          "[Added Lines]",
          "877:   imap_cmd_start(adata, buf);",
          "882:     if (SigInt && query_abort_header_download(adata))",
          "888:     rc = imap_cmd_step(adata);",
          "894:     char *fetch_buf = adata->buf;",
          "",
          "---------------",
          "--- Hunk 22 ---",
          "[Context before]",
          "899:     if (!isdigit((unsigned char) *fetch_buf) || (mutt_str_atoui(fetch_buf, &header_msn) < 0))",
          "900:       continue;",
          "903:     {",
          "904:       mutt_debug(1, \"skipping CONDSTORE flag update for unknown message number %u\\n\", header_msn);",
          "905:       continue;",
          "906:     }",
          "909:   }",
          "914:   ctx->mailbox->changed = false;",
          "918:   {",
          "923:   }",
          "925:   return 0;",
          "",
          "[Removed Lines]",
          "902:     if ((header_msn < 1) || (header_msn > msn_end) || !mdata->msn_index[header_msn - 1])",
          "908:     imap_hcache_put(mdata, mdata->msn_index[header_msn - 1]);",
          "913:   mdata->check_status &= ~IMAP_FLAGS_PENDING;",
          "917:   if (mdata->reopen & IMAP_EXPUNGE_PENDING)",
          "919:     imap_hcache_close(mdata);",
          "920:     imap_expunge_mailbox(mdata);",
          "921:     mdata->hcache = imap_hcache_open(mdata, NULL);",
          "922:     mdata->reopen &= ~IMAP_EXPUNGE_PENDING;",
          "",
          "[Added Lines]",
          "902:     if ((header_msn < 1) || (header_msn > msn_end) || !adata->msn_index[header_msn - 1])",
          "908:     imap_hcache_put(adata, adata->msn_index[header_msn - 1]);",
          "913:   adata->check_status &= ~IMAP_FLAGS_PENDING;",
          "917:   if (adata->reopen & IMAP_EXPUNGE_PENDING)",
          "919:     imap_hcache_close(adata);",
          "920:     imap_expunge_mailbox(adata);",
          "921:     adata->hcache = imap_hcache_open(adata, NULL);",
          "922:     adata->reopen &= ~IMAP_EXPUNGE_PENDING;",
          "",
          "---------------",
          "--- Hunk 23 ---",
          "[Context before]",
          "941:                                   unsigned int msn_end, bool evalhc,",
          "942:                                   unsigned int *maxuid, bool initial_download)",
          "943: {",
          "",
          "[Removed Lines]",
          "940: static int read_headers_fetch_new(struct ImapMboxData *mdata, unsigned int msn_begin,",
          "",
          "[Added Lines]",
          "940: static int read_headers_fetch_new(struct ImapAccountData *adata, unsigned int msn_begin,",
          "",
          "---------------",
          "--- Hunk 24 ---",
          "[Context before]",
          "953:       \"CONTENT-DESCRIPTION IN-REPLY-TO REPLY-TO LINES LIST-POST X-LABEL \"",
          "954:       \"X-ORIGINAL-TO\";",
          "957:   int idx = ctx->mailbox->msg_count;",
          "960:   {",
          "961:     safe_asprintf(&hdrreq, \"BODY.PEEK[HEADER.FIELDS (%s%s%s)]\", want_headers,",
          "962:                   ImapHeaders ? \" \" : \"\", NONULL(ImapHeaders));",
          "963:   }",
          "965:   {",
          "966:     safe_asprintf(&hdrreq, \"RFC822.HEADER.LINES (%s%s%s)\", want_headers,",
          "967:                   ImapHeaders ? \" \" : \"\", NONULL(ImapHeaders));",
          "",
          "[Removed Lines]",
          "956:   struct Context *ctx = mdata->ctx;",
          "959:   if (mutt_bit_isset(mdata->capabilities, IMAP4REV1))",
          "964:   else if (mutt_bit_isset(mdata->capabilities, IMAP4))",
          "",
          "[Added Lines]",
          "956:   struct Context *ctx = adata->ctx;",
          "959:   if (mutt_bit_isset(adata->capabilities, IMAP4REV1))",
          "964:   else if (mutt_bit_isset(adata->capabilities, IMAP4))",
          "",
          "---------------",
          "--- Hunk 25 ---",
          "[Context before]",
          "993:     {",
          "995:       evalhc = false;",
          "997:     }",
          "998:     else",
          "999:       mutt_buffer_printf(b, \"%u:%u\", msn_begin, msn_end);",
          "",
          "[Removed Lines]",
          "996:       imap_fetch_msn_seqset(b, mdata, msn_begin, msn_end);",
          "",
          "[Added Lines]",
          "996:       imap_fetch_msn_seqset(b, adata, msn_begin, msn_end);",
          "",
          "---------------",
          "--- Hunk 26 ---",
          "[Context before]",
          "1001:     fetch_msn_end = msn_end;",
          "1002:     char *cmd = NULL;",
          "1003:     safe_asprintf(&cmd, \"FETCH %s (UID FLAGS INTERNALDATE RFC822.SIZE %s)\", b->data, hdrreq);",
          "1005:     FREE(&cmd);",
          "1006:     mutt_buffer_free(&b);",
          "1008:     rc = IMAP_CMD_CONTINUE;",
          "1009:     for (int msgno = msn_begin; rc == IMAP_CMD_CONTINUE; msgno++)",
          "1010:     {",
          "1012:         goto bail;",
          "1014:       mutt_progress_update(&progress, msgno, -1);",
          "",
          "[Removed Lines]",
          "1004:     imap_cmd_start(mdata, cmd);",
          "1011:       if (initial_download && SigInt && query_abort_header_download(mdata))",
          "",
          "[Added Lines]",
          "1004:     imap_cmd_start(adata, cmd);",
          "1011:       if (initial_download && SigInt && query_abort_header_download(adata))",
          "",
          "---------------",
          "--- Hunk 27 ---",
          "[Context before]",
          "1024:       do",
          "1025:       {",
          "1027:         if (rc != IMAP_CMD_CONTINUE)",
          "1028:           break;",
          "1031:         if (mfhrc < 0)",
          "1032:           continue;",
          "",
          "[Removed Lines]",
          "1026:         rc = imap_cmd_step(mdata);",
          "1030:         mfhrc = msg_fetch_header(ctx->mailbox, &h, mdata->buf, fp);",
          "",
          "[Added Lines]",
          "1026:         rc = imap_cmd_step(adata);",
          "1030:         mfhrc = msg_fetch_header(ctx->mailbox, &h, adata->buf, fp);",
          "",
          "---------------",
          "--- Hunk 28 ---",
          "[Context before]",
          "1048:         }",
          "1052:         {",
          "1053:           mutt_debug(2, \"skipping FETCH response for duplicate message %d\\n\",",
          "1054:                      h.data->msn);",
          "",
          "[Removed Lines]",
          "1051:         if (mdata->msn_index[h.data->msn - 1])",
          "",
          "[Added Lines]",
          "1051:         if (adata->msn_index[h.data->msn - 1])",
          "",
          "---------------",
          "--- Hunk 29 ---",
          "[Context before]",
          "1058:         ctx->mailbox->hdrs[idx] = mutt_email_new();",
          "1064:         ctx->mailbox->hdrs[idx]->index = idx;",
          "",
          "[Removed Lines]",
          "1060:         mdata->max_msn = MAX(mdata->max_msn, h.data->msn);",
          "1061:         mdata->msn_index[h.data->msn - 1] = ctx->mailbox->hdrs[idx];",
          "1062:         mutt_hash_int_insert(mdata->uid_hash, h.data->uid, ctx->mailbox->hdrs[idx]);",
          "",
          "[Added Lines]",
          "1060:         adata->max_msn = MAX(adata->max_msn, h.data->msn);",
          "1061:         adata->msn_index[h.data->msn - 1] = ctx->mailbox->hdrs[idx];",
          "1062:         mutt_hash_int_insert(adata->uid_hash, h.data->uid, ctx->mailbox->hdrs[idx]);",
          "",
          "---------------",
          "--- Hunk 30 ---",
          "[Context before]",
          "1090:         ctx->mailbox->size += h.content_length;",
          "1092: #ifdef USE_HCACHE",
          "1096:         ctx->mailbox->msg_count++;",
          "",
          "[Removed Lines]",
          "1093:         imap_hcache_put(mdata, ctx->mailbox->hdrs[idx]);",
          "",
          "[Added Lines]",
          "1093:         imap_hcache_put(adata, ctx->mailbox->hdrs[idx]);",
          "",
          "---------------",
          "--- Hunk 31 ---",
          "[Context before]",
          "1115:     {",
          "1120:       while (msn_end > ctx->mailbox->hdrmax)",
          "1121:         mx_alloc_memory(ctx->mailbox);",
          "1125:     }",
          "1126:   }",
          "",
          "[Removed Lines]",
          "1114:     if (mdata->reopen & IMAP_NEWMAIL_PENDING)",
          "1117:       fetch_msn_end = mdata->max_msn;",
          "1118:       msn_begin = mdata->max_msn + 1;",
          "1119:       msn_end = mdata->new_mail_count;",
          "1122:       alloc_msn_index(mdata, msn_end);",
          "1123:       mdata->reopen &= ~IMAP_NEWMAIL_PENDING;",
          "1124:       mdata->new_mail_count = 0;",
          "",
          "[Added Lines]",
          "1114:     if (adata->reopen & IMAP_NEWMAIL_PENDING)",
          "1117:       fetch_msn_end = adata->max_msn;",
          "1118:       msn_begin = adata->max_msn + 1;",
          "1119:       msn_end = adata->new_mail_count;",
          "1122:       alloc_msn_index(adata, msn_end);",
          "1123:       adata->reopen &= ~IMAP_NEWMAIL_PENDING;",
          "1124:       adata->new_mail_count = 0;",
          "",
          "---------------",
          "--- Hunk 32 ---",
          "[Context before]",
          "1151:                       unsigned int msn_end, bool initial_download)",
          "1152: {",
          "1153:   struct ImapStatus *status = NULL;",
          "",
          "[Removed Lines]",
          "1150: int imap_read_headers(struct ImapMboxData *mdata, unsigned int msn_begin,",
          "",
          "[Added Lines]",
          "1150: int imap_read_headers(struct ImapAccountData *adata, unsigned int msn_begin,",
          "",
          "---------------",
          "--- Hunk 33 ---",
          "[Context before]",
          "1169:   char *uid_seqset = NULL;",
          "1175:   while (msn_end > ctx->mailbox->hdrmax)",
          "1176:     mx_alloc_memory(ctx->mailbox);",
          "1180:   oldmsgcount = ctx->mailbox->msg_count;",
          "1184: #ifdef USE_HCACHE",
          "1188:   {",
          "1191:     if (puidnext)",
          "1192:     {",
          "1193:       uidnext = *(unsigned int *) puidnext;",
          "1195:     }",
          "1198:     {",
          "1200:         has_condstore = true;",
          "1207:         has_qresync = true;",
          "1208:     }",
          "1211:     {",
          "1212:       evalhc = true;",
          "1214:       if (pmodseq)",
          "1215:       {",
          "1216:         hc_modseq = *pmodseq;",
          "1218:       }",
          "1219:       if (hc_modseq)",
          "1220:       {",
          "1221:         if (has_qresync)",
          "1222:         {",
          "1224:           if (uid_seqset)",
          "1225:             eval_qresync = true;",
          "1226:         }",
          "",
          "[Removed Lines]",
          "1172:   struct Context *ctx = mdata->ctx;",
          "1177:   alloc_msn_index(mdata, msn_end);",
          "1178:   imap_alloc_uid_hash(mdata, msn_end);",
          "1181:   mdata->reopen &= ~(IMAP_REOPEN_ALLOW | IMAP_NEWMAIL_PENDING);",
          "1182:   mdata->new_mail_count = 0;",
          "1185:   mdata->hcache = imap_hcache_open(mdata, NULL);",
          "1187:   if (mdata->hcache && initial_download)",
          "1189:     uid_validity = mutt_hcache_fetch_raw(mdata->hcache, \"/UIDVALIDITY\", 12);",
          "1190:     puidnext = mutt_hcache_fetch_raw(mdata->hcache, \"/UIDNEXT\", 8);",
          "1194:       mutt_hcache_free(mdata->hcache, &puidnext);",
          "1197:     if (mdata->modseq)",
          "1199:       if (mutt_bit_isset(mdata->capabilities, CONDSTORE) && ImapCondStore)",
          "1206:       if (mdata->qresync)",
          "1210:     if (uid_validity && uidnext && (*(unsigned int *) uid_validity == mdata->uid_validity))",
          "1213:       pmodseq = mutt_hcache_fetch_raw(mdata->hcache, \"/MODSEQ\", 7);",
          "1217:         mutt_hcache_free(mdata->hcache, (void **) &pmodseq);",
          "1223:           uid_seqset = imap_hcache_get_uid_seqset(mdata);",
          "",
          "[Added Lines]",
          "1172:   struct Context *ctx = adata->ctx;",
          "1177:   alloc_msn_index(adata, msn_end);",
          "1178:   imap_alloc_uid_hash(adata, msn_end);",
          "1181:   adata->reopen &= ~(IMAP_REOPEN_ALLOW | IMAP_NEWMAIL_PENDING);",
          "1182:   adata->new_mail_count = 0;",
          "1185:   adata->hcache = imap_hcache_open(adata, NULL);",
          "1187:   if (adata->hcache && initial_download)",
          "1189:     uid_validity = mutt_hcache_fetch_raw(adata->hcache, \"/UIDVALIDITY\", 12);",
          "1190:     puidnext = mutt_hcache_fetch_raw(adata->hcache, \"/UIDNEXT\", 8);",
          "1194:       mutt_hcache_free(adata->hcache, &puidnext);",
          "1197:     if (adata->modseq)",
          "1199:       if (mutt_bit_isset(adata->capabilities, CONDSTORE) && ImapCondStore)",
          "1206:       if (adata->qresync)",
          "1210:     if (uid_validity && uidnext && (*(unsigned int *) uid_validity == adata->uid_validity))",
          "1213:       pmodseq = mutt_hcache_fetch_raw(adata->hcache, \"/MODSEQ\", 7);",
          "1217:         mutt_hcache_free(adata->hcache, (void **) &pmodseq);",
          "1223:           uid_seqset = imap_hcache_get_uid_seqset(adata);",
          "",
          "---------------",
          "--- Hunk 34 ---",
          "[Context before]",
          "1229:           eval_condstore = true;",
          "1230:       }",
          "1231:     }",
          "1233:   }",
          "1234:   if (evalhc)",
          "1235:   {",
          "1236:     if (eval_qresync)",
          "1237:     {",
          "1239:         goto bail;",
          "1240:     }",
          "1241:     else",
          "1242:     {",
          "1244:                                          eval_condstore) < 0)",
          "1245:         goto bail;",
          "1246:     }",
          "1249:     {",
          "1251:                                                  hc_modseq, eval_qresync) < 0)",
          "1252:       {",
          "1253:         goto bail;",
          "",
          "[Removed Lines]",
          "1232:     mutt_hcache_free(mdata->hcache, &uid_validity);",
          "1238:       if (read_headers_qresync_eval_cache(mdata, uid_seqset) < 0)",
          "1243:       if (read_headers_normal_eval_cache(mdata, msn_end, uidnext, has_condstore || has_qresync,",
          "1248:     if ((eval_condstore || eval_qresync) && (hc_modseq != mdata->modseq))",
          "1250:       if (read_headers_condstore_qresync_updates(mdata, msn_end, uidnext,",
          "",
          "[Added Lines]",
          "1232:     mutt_hcache_free(adata->hcache, &uid_validity);",
          "1238:       if (read_headers_qresync_eval_cache(adata, uid_seqset) < 0)",
          "1243:       if (read_headers_normal_eval_cache(adata, msn_end, uidnext, has_condstore || has_qresync,",
          "1248:     if ((eval_condstore || eval_qresync) && (hc_modseq != adata->modseq))",
          "1250:       if (read_headers_condstore_qresync_updates(adata, msn_end, uidnext,",
          "",
          "---------------",
          "--- Hunk 35 ---",
          "[Context before]",
          "1258:     while (msn_begin <= msn_end)",
          "1259:     {",
          "1261:         break;",
          "1262:       msn_begin++;",
          "1263:     }",
          "1264:   }",
          "1268:     goto bail;",
          "1271:       (status->uidnext < maxuid + 1))",
          "1272:   {",
          "1273:     status->uidnext = maxuid + 1;",
          "1274:   }",
          "1276: #ifdef USE_HCACHE",
          "1280:   {",
          "1283:   }",
          "1285:   {",
          "1288:   }",
          "",
          "[Removed Lines]",
          "1260:       if (!mdata->msn_index[msn_begin - 1])",
          "1267:   if (read_headers_fetch_new(mdata, msn_begin, msn_end, evalhc, &maxuid, initial_download) < 0)",
          "1270:   if (maxuid && (status = imap_mboxcache_get(mdata, mdata->mbox_name, 0)) &&",
          "1277:   mutt_hcache_store_raw(mdata->hcache, \"/UIDVALIDITY\", 12, &mdata->uid_validity,",
          "1278:                         sizeof(mdata->uid_validity));",
          "1279:   if (maxuid && mdata->uidnext < maxuid + 1)",
          "1281:     mutt_debug(2, \"Overriding UIDNEXT: %u -> %u\\n\", mdata->uidnext, maxuid + 1);",
          "1282:     mdata->uidnext = maxuid + 1;",
          "1284:   if (mdata->uidnext > 1)",
          "1286:     mutt_hcache_store_raw(mdata->hcache, \"/UIDNEXT\", 8, &mdata->uidnext,",
          "1287:                           sizeof(mdata->uidnext));",
          "",
          "[Added Lines]",
          "1260:       if (!adata->msn_index[msn_begin - 1])",
          "1267:   if (read_headers_fetch_new(adata, msn_begin, msn_end, evalhc, &maxuid, initial_download) < 0)",
          "1270:   if (maxuid && (status = imap_mboxcache_get(adata, adata->mbox_name, 0)) &&",
          "1277:   mutt_hcache_store_raw(adata->hcache, \"/UIDVALIDITY\", 12, &adata->uid_validity,",
          "1278:                         sizeof(adata->uid_validity));",
          "1279:   if (maxuid && adata->uidnext < maxuid + 1)",
          "1281:     mutt_debug(2, \"Overriding UIDNEXT: %u -> %u\\n\", adata->uidnext, maxuid + 1);",
          "1282:     adata->uidnext = maxuid + 1;",
          "1284:   if (adata->uidnext > 1)",
          "1286:     mutt_hcache_store_raw(adata->hcache, \"/UIDNEXT\", 8, &adata->uidnext,",
          "1287:                           sizeof(adata->uidnext));",
          "",
          "---------------",
          "--- Hunk 36 ---",
          "[Context before]",
          "1296:   {",
          "1297:     if (has_condstore || has_qresync)",
          "1298:     {",
          "1301:     }",
          "1302:     else",
          "1305:     if (has_qresync)",
          "1307:     else",
          "1309:   }",
          "",
          "[Removed Lines]",
          "1299:       mutt_hcache_store_raw(mdata->hcache, \"/MODSEQ\", 7, &mdata->modseq,",
          "1300:                             sizeof(mdata->modseq));",
          "1303:       mutt_hcache_delete(mdata->hcache, \"/MODSEQ\", 7);",
          "1306:       imap_hcache_store_uid_seqset(mdata);",
          "1308:       imap_hcache_clear_uid_seqset(mdata);",
          "",
          "[Added Lines]",
          "1299:       mutt_hcache_store_raw(adata->hcache, \"/MODSEQ\", 7, &adata->modseq,",
          "1300:                             sizeof(adata->modseq));",
          "1303:       mutt_hcache_delete(adata->hcache, \"/MODSEQ\", 7);",
          "1306:       imap_hcache_store_uid_seqset(adata);",
          "1308:       imap_hcache_clear_uid_seqset(adata);",
          "",
          "---------------",
          "--- Hunk 37 ---",
          "[Context before]",
          "1317:     mx_update_context(ctx, ctx->mailbox->msg_count - oldmsgcount);",
          "1318:   }",
          "1322:   retval = msn_end;",
          "1324: bail:",
          "1325: #ifdef USE_HCACHE",
          "1327:   FREE(&uid_seqset);",
          "",
          "[Removed Lines]",
          "1320:   mdata->reopen |= IMAP_REOPEN_ALLOW;",
          "1326:   imap_hcache_close(mdata);",
          "",
          "[Added Lines]",
          "1320:   adata->reopen |= IMAP_REOPEN_ALLOW;",
          "1326:   imap_hcache_close(adata);",
          "",
          "---------------",
          "--- Hunk 38 ---",
          "[Context before]",
          "1352:   struct ImapMbox mx;",
          "1353:   int rc;",
          "1357:   if (imap_parse_path(ctx->mailbox->path, &mx))",
          "1358:     return -1;",
          "1361:   if (!*mailbox)",
          "1362:     mutt_str_strfcpy(mailbox, \"INBOX\", sizeof(mailbox));",
          "",
          "[Removed Lines]",
          "1355:   struct ImapMboxData *mdata = ctx->mailbox->data;",
          "1360:   imap_fix_path(mdata, mx.mbox, mailbox, sizeof(mailbox));",
          "",
          "[Added Lines]",
          "1355:   struct ImapAccountData *adata = ctx->mailbox->data;",
          "1360:   imap_fix_path(adata, mx.mbox, mailbox, sizeof(mailbox));",
          "",
          "---------------",
          "--- Hunk 39 ---",
          "[Context before]",
          "1386:   mutt_progress_init(&progressbar, _(\"Uploading message...\"),",
          "1387:                      MUTT_PROGRESS_SIZE, NetInc, len);",
          "1390:   mutt_date_make_imap(internaldate, sizeof(internaldate), msg->received);",
          "1392:   imap_flags[0] = 0;",
          "",
          "[Removed Lines]",
          "1389:   imap_munge_mbox_name(mdata, mbox, sizeof(mbox), mailbox);",
          "",
          "[Added Lines]",
          "1389:   imap_munge_mbox_name(adata, mbox, sizeof(mbox), mailbox);",
          "",
          "---------------",
          "--- Hunk 40 ---",
          "[Context before]",
          "1404:   snprintf(buf, sizeof(buf), \"APPEND %s (%s) \\\"%s\\\" {%lu}\", mbox,",
          "1405:            imap_flags + 1, internaldate, (unsigned long) len);",
          "1409:   do",
          "1411:   while (rc == IMAP_CMD_CONTINUE);",
          "1413:   if (rc != IMAP_CMD_RESPOND)",
          "1414:   {",
          "1418:     SKIPWS(pc);",
          "1419:     pc = imap_next_word(pc);",
          "1420:     mutt_error(\"%s\", pc);",
          "",
          "[Removed Lines]",
          "1407:   imap_cmd_start(mdata, buf);",
          "1410:     rc = imap_cmd_step(mdata);",
          "1415:     mutt_debug(1, \"#1 command failed: %s\\n\", mdata->buf);",
          "1417:     char *pc = mdata->buf + SEQLEN;",
          "",
          "[Added Lines]",
          "1407:   imap_cmd_start(adata, buf);",
          "1410:     rc = imap_cmd_step(adata);",
          "1415:     mutt_debug(1, \"#1 command failed: %s\\n\", adata->buf);",
          "1417:     char *pc = adata->buf + SEQLEN;",
          "",
          "---------------",
          "--- Hunk 41 ---",
          "[Context before]",
          "1432:     if (len > sizeof(buf) - 3)",
          "1433:     {",
          "1434:       sent += len;",
          "1436:       mutt_progress_update(&progressbar, sent, -1);",
          "1437:     }",
          "1438:   }",
          "1440:   if (len)",
          "1444:   mutt_file_fclose(&fp);",
          "1446:   do",
          "1448:   while (rc == IMAP_CMD_CONTINUE);",
          "1451:   {",
          "1454:     SKIPWS(pc);",
          "1455:     pc = imap_next_word(pc);",
          "1456:     mutt_error(\"%s\", pc);",
          "",
          "[Removed Lines]",
          "1435:       flush_buffer(buf, &len, mdata->conn);",
          "1441:     flush_buffer(buf, &len, mdata->conn);",
          "1443:   mutt_socket_send(mdata->conn, \"\\r\\n\");",
          "1447:     rc = imap_cmd_step(mdata);",
          "1450:   if (!imap_code(mdata->buf))",
          "1452:     mutt_debug(1, \"#2 command failed: %s\\n\", mdata->buf);",
          "1453:     char *pc = mdata->buf + SEQLEN;",
          "",
          "[Added Lines]",
          "1435:       flush_buffer(buf, &len, adata->conn);",
          "1441:     flush_buffer(buf, &len, adata->conn);",
          "1443:   mutt_socket_send(adata->conn, \"\\r\\n\");",
          "1447:     rc = imap_cmd_step(adata);",
          "1450:   if (!imap_code(adata->buf))",
          "1452:     mutt_debug(1, \"#2 command failed: %s\\n\", adata->buf);",
          "1453:     char *pc = adata->buf + SEQLEN;",
          "",
          "---------------",
          "--- Hunk 42 ---",
          "[Context before]",
          "1486:   int err_continue = MUTT_NO;",
          "1487:   int triedcreate = 0;",
          "1491:   if (imap_parse_path(dest, &mx))",
          "1492:   {",
          "",
          "[Removed Lines]",
          "1489:   struct ImapMboxData *mdata = ctx->mailbox->data;",
          "",
          "[Added Lines]",
          "1489:   struct ImapAccountData *adata = ctx->mailbox->data;",
          "",
          "---------------",
          "--- Hunk 43 ---",
          "[Context before]",
          "1495:   }",
          "1499:   {",
          "1500:     mutt_debug(3, \"%s not same server as %s\\n\", dest, ctx->mailbox->path);",
          "1501:     return 1;",
          "",
          "[Removed Lines]",
          "1498:   if (!mutt_account_match(&(mdata->conn->account), &(mx.account)))",
          "",
          "[Added Lines]",
          "1498:   if (!mutt_account_match(&(adata->conn->account), &(mx.account)))",
          "",
          "---------------",
          "--- Hunk 44 ---",
          "[Context before]",
          "1507:     return 1;",
          "1508:   }",
          "1511:   if (!*mbox)",
          "1512:     mutt_str_strfcpy(mbox, \"INBOX\", sizeof(mbox));",
          "1516:   do",
          "",
          "[Removed Lines]",
          "1510:   imap_fix_path(mdata, mx.mbox, mbox, sizeof(mbox));",
          "1513:   imap_munge_mbox_name(mdata, mmbox, sizeof(mmbox), mbox);",
          "",
          "[Added Lines]",
          "1510:   imap_fix_path(adata, mx.mbox, mbox, sizeof(mbox));",
          "1513:   imap_munge_mbox_name(adata, mmbox, sizeof(mmbox), mbox);",
          "",
          "---------------",
          "--- Hunk 45 ---",
          "[Context before]",
          "1538:         if (ctx->mailbox->hdrs[i]->active && ctx->mailbox->hdrs[i]->changed)",
          "1539:         {",
          "1541:                                           &sync_cmd, &err_continue);",
          "1542:           if (rc < 0)",
          "1543:           {",
          "",
          "[Removed Lines]",
          "1540:           rc = imap_sync_message_for_copy(mdata, ctx->mailbox->hdrs[i],",
          "",
          "[Added Lines]",
          "1540:           rc = imap_sync_message_for_copy(adata, ctx->mailbox->hdrs[i],",
          "",
          "---------------",
          "--- Hunk 46 ---",
          "[Context before]",
          "1547:         }",
          "1548:       }",
          "1551:       if (!rc)",
          "1552:       {",
          "1553:         mutt_debug(1, \"No messages tagged\\n\");",
          "",
          "[Removed Lines]",
          "1550:       rc = imap_exec_msgset(mdata, \"UID COPY\", mmbox, MUTT_TAG, false, false);",
          "",
          "[Added Lines]",
          "1550:       rc = imap_exec_msgset(adata, \"UID COPY\", mmbox, MUTT_TAG, false, false);",
          "",
          "---------------",
          "--- Hunk 47 ---",
          "[Context before]",
          "1573:       if (e->active && e->changed)",
          "1574:       {",
          "1576:         if (rc < 0)",
          "1577:         {",
          "1578:           mutt_debug(1, \"#2 could not sync\\n\");",
          "1579:           goto out;",
          "1580:         }",
          "1581:       }",
          "1583:       if (rc < 0)",
          "1584:       {",
          "1585:         mutt_debug(1, \"#2 could not queue copy\\n\");",
          "",
          "[Removed Lines]",
          "1575:         rc = imap_sync_message_for_copy(mdata, e, &sync_cmd, &err_continue);",
          "1582:       rc = imap_exec(mdata, cmd.data, IMAP_CMD_QUEUE);",
          "",
          "[Added Lines]",
          "1575:         rc = imap_sync_message_for_copy(adata, e, &sync_cmd, &err_continue);",
          "1582:       rc = imap_exec(adata, cmd.data, IMAP_CMD_QUEUE);",
          "",
          "---------------",
          "--- Hunk 48 ---",
          "[Context before]",
          "1588:     }",
          "1592:     if (rc == -2)",
          "1593:     {",
          "1594:       if (triedcreate)",
          "",
          "[Removed Lines]",
          "1591:     rc = imap_exec(mdata, NULL, IMAP_CMD_FAIL_OK);",
          "",
          "[Added Lines]",
          "1591:     rc = imap_exec(adata, NULL, IMAP_CMD_FAIL_OK);",
          "",
          "---------------",
          "--- Hunk 49 ---",
          "[Context before]",
          "1597:         break;",
          "1598:       }",
          "1601:         break;",
          "1602:       mutt_debug(3, \"server suggests TRYCREATE\\n\");",
          "1603:       snprintf(prompt, sizeof(prompt), _(\"Create %s?\"), mbox);",
          "",
          "[Removed Lines]",
          "1600:       if (mutt_str_strncasecmp(imap_get_qualifier(mdata->buf), \"[TRYCREATE]\", 11) != 0)",
          "",
          "[Added Lines]",
          "1600:       if (mutt_str_strncasecmp(imap_get_qualifier(adata->buf), \"[TRYCREATE]\", 11) != 0)",
          "",
          "---------------",
          "--- Hunk 50 ---",
          "[Context before]",
          "1606:         mutt_clear_error();",
          "1607:         goto out;",
          "1608:       }",
          "1610:         break;",
          "1611:       triedcreate = 1;",
          "1612:     }",
          "",
          "[Removed Lines]",
          "1609:       if (imap_create_mailbox(mdata, mbox) < 0)",
          "",
          "[Added Lines]",
          "1609:       if (imap_create_mailbox(adata, mbox) < 0)",
          "",
          "---------------",
          "--- Hunk 51 ---",
          "[Context before]",
          "1615:   if (rc != 0)",
          "1616:   {",
          "1618:     goto out;",
          "1619:   }",
          "",
          "[Removed Lines]",
          "1617:     imap_error(\"imap_copy_messages\", mdata->buf);",
          "",
          "[Added Lines]",
          "1617:     imap_error(\"imap_copy_messages\", adata->buf);",
          "",
          "---------------",
          "--- Hunk 52 ---",
          "[Context before]",
          "1666: {",
          "1668:     return -1;",
          "1671:   char id[64];",
          "1674: }",
          "1682: {",
          "1686:   return 0;",
          "1687: }",
          "",
          "[Removed Lines]",
          "1665: int imap_cache_del(struct ImapMboxData *mdata, struct Email *e)",
          "1667:   if (!mdata || !e)",
          "1670:   mdata->bcache = msg_cache_open(mdata);",
          "1672:   snprintf(id, sizeof(id), \"%u-%u\", mdata->uid_validity, IMAP_EDATA(e)->uid);",
          "1673:   return mutt_bcache_del(mdata->bcache, id);",
          "1681: int imap_cache_clean(struct ImapMboxData *mdata)",
          "1683:   mdata->bcache = msg_cache_open(mdata);",
          "1684:   mutt_bcache_list(mdata->bcache, msg_cache_clean_cb, mdata);",
          "",
          "[Added Lines]",
          "1665: int imap_cache_del(struct ImapAccountData *adata, struct Email *e)",
          "1667:   if (!adata || !e)",
          "1670:   adata->bcache = msg_cache_open(adata);",
          "1672:   snprintf(id, sizeof(id), \"%u-%u\", adata->uid_validity, IMAP_EDATA(e)->uid);",
          "1673:   return mutt_bcache_del(adata->bcache, id);",
          "1681: int imap_cache_clean(struct ImapAccountData *adata)",
          "1683:   adata->bcache = msg_cache_open(adata);",
          "1684:   mutt_bcache_list(adata->bcache, msg_cache_clean_cb, adata);",
          "",
          "---------------",
          "--- Hunk 53 ---",
          "[Context before]",
          "1724: {",
          "1726:   struct ImapHeader newh = { 0 };",
          "1727:   struct ImapEmailData old_edata;",
          "1728:   bool readonly;",
          "",
          "[Removed Lines]",
          "1723: char *imap_set_flags(struct ImapMboxData *mdata, struct Email *e, char *s, int *server_changes)",
          "1725:   struct Context *ctx = mdata->ctx;",
          "",
          "[Added Lines]",
          "1723: char *imap_set_flags(struct ImapAccountData *adata, struct Email *e, char *s, int *server_changes)",
          "1725:   struct Context *ctx = adata->ctx;",
          "",
          "---------------",
          "--- Hunk 54 ---",
          "[Context before]",
          "1797:   bool fetched = false;",
          "1798:   int output_progress;",
          "1801:   struct Email *e = ctx->mailbox->hdrs[msgno];",
          "1804:   if (msg->fp)",
          "1805:   {",
          "1806:     if (IMAP_EDATA(e)->parsed)",
          "",
          "[Removed Lines]",
          "1800:   struct ImapMboxData *mdata = ctx->mailbox->data;",
          "1803:   msg->fp = msg_cache_get(mdata, e);",
          "",
          "[Added Lines]",
          "1800:   struct ImapAccountData *adata = ctx->mailbox->data;",
          "1803:   msg->fp = msg_cache_get(adata, e);",
          "",
          "---------------",
          "--- Hunk 55 ---",
          "[Context before]",
          "1814:   cacheno = IMAP_EDATA(e)->uid % IMAP_CACHE_LEN;",
          "1817:   if (cache->path)",
          "1818:   {",
          "",
          "[Removed Lines]",
          "1815:   cache = &mdata->cache[cacheno];",
          "",
          "[Added Lines]",
          "1815:   cache = &adata->cache[cacheno];",
          "",
          "---------------",
          "--- Hunk 56 ---",
          "[Context before]",
          "1832:   if (output_progress)",
          "1833:     mutt_message(_(\"Fetching message...\"));",
          "1836:   if (!msg->fp)",
          "1837:   {",
          "1838:     cache->uid = IMAP_EDATA(e)->uid;",
          "",
          "[Removed Lines]",
          "1835:   msg->fp = msg_cache_put(mdata, e);",
          "",
          "[Added Lines]",
          "1835:   msg->fp = msg_cache_put(adata, e);",
          "",
          "---------------",
          "--- Hunk 57 ---",
          "[Context before]",
          "1852:   e->active = false;",
          "1854:   snprintf(buf, sizeof(buf), \"UID FETCH %u %s\", IMAP_EDATA(e)->uid,",
          "1856:                 (ImapPeek ? \"BODY.PEEK[]\" : \"BODY[]\") :",
          "1857:                 \"RFC822\"));",
          "1860:   do",
          "1861:   {",
          "1863:     if (rc != IMAP_CMD_CONTINUE)",
          "1864:       break;",
          "1867:     pc = imap_next_word(pc);",
          "1868:     pc = imap_next_word(pc);",
          "",
          "[Removed Lines]",
          "1855:            (mutt_bit_isset(mdata->capabilities, IMAP4REV1) ?",
          "1859:   imap_cmd_start(mdata, buf);",
          "1862:     rc = imap_cmd_step(mdata);",
          "1866:     pc = mdata->buf;",
          "",
          "[Added Lines]",
          "1855:            (mutt_bit_isset(adata->capabilities, IMAP4REV1) ?",
          "1859:   imap_cmd_start(adata, buf);",
          "1862:     rc = imap_cmd_step(adata);",
          "1866:     pc = adata->buf;",
          "",
          "---------------",
          "--- Hunk 58 ---",
          "[Context before]",
          "1899:             mutt_progress_init(&progressbar, _(\"Fetching message...\"),",
          "1900:                                MUTT_PROGRESS_SIZE, NetInc, bytes);",
          "1901:           }",
          "1903:                                 output_progress ? &progressbar : NULL) < 0)",
          "1904:           {",
          "1905:             goto bail;",
          "1906:           }",
          "1909:           if (rc != IMAP_CMD_CONTINUE)",
          "1910:             goto bail;",
          "1913:           fetched = true;",
          "1914:         }",
          "",
          "[Removed Lines]",
          "1902:           if (imap_read_literal(msg->fp, mdata, bytes,",
          "1908:           rc = imap_cmd_step(mdata);",
          "1911:           pc = mdata->buf;",
          "",
          "[Added Lines]",
          "1902:           if (imap_read_literal(msg->fp, adata, bytes,",
          "1908:           rc = imap_cmd_step(adata);",
          "1911:           pc = adata->buf;",
          "",
          "---------------",
          "--- Hunk 59 ---",
          "[Context before]",
          "1919:         else if ((mutt_str_strncasecmp(\"FLAGS\", pc, 5) == 0) && !e->changed)",
          "1920:         {",
          "1922:           if (!pc)",
          "1923:             goto bail;",
          "1924:         }",
          "",
          "[Removed Lines]",
          "1921:           pc = imap_set_flags(mdata, e, pc, NULL);",
          "",
          "[Added Lines]",
          "1921:           pc = imap_set_flags(adata, e, pc, NULL);",
          "",
          "---------------",
          "--- Hunk 60 ---",
          "[Context before]",
          "1939:   if (rc != IMAP_CMD_OK)",
          "1940:     goto bail;",
          "1943:     goto bail;",
          "1947: parsemsg:",
          "",
          "[Removed Lines]",
          "1942:   if (!fetched || !imap_code(mdata->buf))",
          "1945:   msg_cache_commit(mdata, e);",
          "",
          "[Added Lines]",
          "1942:   if (!fetched || !imap_code(adata->buf))",
          "1945:   msg_cache_commit(adata, e);",
          "",
          "---------------",
          "--- Hunk 61 ---",
          "[Context before]",
          "1984:   if (!retried && ((e->lines == 0) || (e->content->length == 0)))",
          "1985:   {",
          "1987:     retried = true;",
          "1988:     goto parsemsg;",
          "1989:   }",
          "",
          "[Removed Lines]",
          "1986:     imap_cache_del(mdata, e);",
          "",
          "[Added Lines]",
          "1986:     imap_cache_del(adata, e);",
          "",
          "---------------",
          "--- Hunk 62 ---",
          "[Context before]",
          "1993: bail:",
          "1994:   mutt_file_fclose(&msg->fp);",
          "1996:   if (cache->path)",
          "1997:   {",
          "1998:     unlink(cache->path);",
          "",
          "[Removed Lines]",
          "1995:   imap_cache_del(mdata, e);",
          "",
          "[Added Lines]",
          "1995:   imap_cache_del(adata, e);",
          "",
          "---------------"
        ],
        "imap/utf7.c||imap/utf7.c": [
          "File: imap/utf7.c -> imap/utf7.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "318: {",
          "319:   if (!Charset || !s)",
          "320:     return;",
          "",
          "[Removed Lines]",
          "317: void imap_utf_encode(struct ImapMboxData *mdata, char **s)",
          "",
          "[Added Lines]",
          "317: void imap_utf_encode(struct ImapAccountData *adata, char **s)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "323:   if (t && (mutt_ch_convert_string(&t, Charset, \"utf-8\", 0) == 0))",
          "324:   {",
          "325:     FREE(s);",
          "328:     else",
          "",
          "[Removed Lines]",
          "326:     if (mdata->unicode)",
          "",
          "[Added Lines]",
          "326:     if (adata->unicode)",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "340: {",
          "341:   if (!Charset)",
          "342:     return;",
          "344:   char *t = NULL;",
          "347:     t = mutt_str_strdup(*s);",
          "348:   else",
          "349:     t = utf7_to_utf8(*s, strlen(*s), 0, 0);",
          "",
          "[Removed Lines]",
          "339: void imap_utf_decode(struct ImapMboxData *mdata, char **s)",
          "346:   if (mdata->unicode)",
          "",
          "[Added Lines]",
          "339: void imap_utf_decode(struct ImapAccountData *adata, char **s)",
          "346:   if (adata->unicode)",
          "",
          "---------------"
        ],
        "imap/util.c||imap/util.c": [
          "File: imap/util.c -> imap/util.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "81: int imap_expand_path(char *buf, size_t buflen)",
          "82: {",
          "83:   struct ImapMbox mx;",
          "85:   struct Url url;",
          "86:   char fixedpath[LONG_STRING];",
          "87:   int rc;",
          "",
          "[Removed Lines]",
          "84:   struct ImapMboxData *mdata = NULL;",
          "",
          "[Added Lines]",
          "84:   struct ImapAccountData *adata = NULL;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "89:   if (imap_parse_path(buf, &mx) < 0)",
          "90:     return -1;",
          "93:   mutt_account_tourl(&mx.account, &url);",
          "95:   url.path = fixedpath;",
          "97:   rc = url_tostring(&url, buf, buflen, U_DECODE_PASSWD);",
          "",
          "[Removed Lines]",
          "92:   mdata = imap_conn_find(&mx.account, MUTT_IMAP_CONN_NONEW);",
          "94:   imap_fix_path(mdata, mx.mbox, fixedpath, sizeof(fixedpath));",
          "",
          "[Added Lines]",
          "92:   adata = imap_conn_find(&mx.account, MUTT_IMAP_CONN_NONEW);",
          "94:   imap_fix_path(adata, mx.mbox, fixedpath, sizeof(fixedpath));",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "156: void imap_get_parent_path(const char *path, char *buf, size_t buflen)",
          "157: {",
          "158:   struct ImapMbox mx;",
          "160:   char mbox[LONG_STRING] = \"\";",
          "162:   if (imap_parse_path(path, &mx) < 0)",
          "",
          "[Removed Lines]",
          "159:   struct ImapMboxData *mdata = NULL;",
          "",
          "[Added Lines]",
          "159:   struct ImapAccountData *adata = NULL;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "165:     return;",
          "166:   }",
          "170:   {",
          "171:     mutt_str_strfcpy(buf, path, buflen);",
          "172:     return;",
          "173:   }",
          "182:   imap_qualify_path(buf, buflen, &mx, mbox);",
          "",
          "[Removed Lines]",
          "168:   mdata = imap_conn_find(&mx.account, MUTT_IMAP_CONN_NONEW);",
          "169:   if (!mdata)",
          "176:   imap_fix_path(mdata, mx.mbox, mbox, sizeof(mbox));",
          "179:   imap_get_parent(mbox, mdata->delim, mbox, sizeof(mbox));",
          "",
          "[Added Lines]",
          "168:   adata = imap_conn_find(&mx.account, MUTT_IMAP_CONN_NONEW);",
          "169:   if (!adata)",
          "176:   imap_fix_path(adata, mx.mbox, mbox, sizeof(mbox));",
          "179:   imap_get_parent(mbox, adata->delim, mbox, sizeof(mbox));",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "193: void imap_clean_path(char *path, size_t plen)",
          "194: {",
          "195:   struct ImapMbox mx;",
          "197:   char mbox[LONG_STRING] = \"\";",
          "199:   if (imap_parse_path(path, &mx) < 0)",
          "200:     return;",
          "204:     return;",
          "210:   imap_qualify_path(path, plen, &mx, mbox);",
          "",
          "[Removed Lines]",
          "196:   struct ImapMboxData *mdata = NULL;",
          "202:   mdata = imap_conn_find(&mx.account, MUTT_IMAP_CONN_NONEW);",
          "203:   if (!mdata)",
          "207:   imap_fix_path(mdata, mx.mbox, mbox, sizeof(mbox));",
          "",
          "[Added Lines]",
          "196:   struct ImapAccountData *adata = NULL;",
          "202:   adata = imap_conn_find(&mx.account, MUTT_IMAP_CONN_NONEW);",
          "203:   if (!adata)",
          "207:   imap_fix_path(adata, mx.mbox, mbox, sizeof(mbox));",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "223: {",
          "224:   int first = 1, state = 0;",
          "225:   unsigned int cur_uid = 0, last_uid = 0;",
          "226:   unsigned int range_begin = 0, range_end = 0;",
          "229:   {",
          "230:     bool match = false;",
          "232:     {",
          "234:       cur_uid = cur_header ? IMAP_EDATA(cur_header)->uid : 0;",
          "235:       if (!state || (cur_uid && ((cur_uid - 1) == last_uid)))",
          "236:         match = true;",
          "",
          "[Removed Lines]",
          "222: static void imap_msn_index_to_uid_seqset(struct Buffer *b, struct ImapMboxData *mdata)",
          "228:   for (unsigned int msn = 1; msn <= mdata->max_msn + 1; msn++)",
          "231:     if (msn <= mdata->max_msn)",
          "233:       struct Email *cur_header = mdata->msn_index[msn - 1];",
          "",
          "[Added Lines]",
          "222: static void imap_msn_index_to_uid_seqset(struct Buffer *b, struct ImapAccountData *adata)",
          "228:   for (unsigned int msn = 1; msn <= adata->max_msn + 1; msn++)",
          "231:     if (msn <= adata->max_msn)",
          "233:       struct Email *cur_header = adata->msn_index[msn - 1];",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "290: {",
          "291:   struct ImapMbox mx;",
          "292:   struct Url url;",
          "",
          "[Removed Lines]",
          "289: header_cache_t *imap_hcache_open(struct ImapMboxData *mdata, const char *path)",
          "",
          "[Added Lines]",
          "289: header_cache_t *imap_hcache_open(struct ImapAccountData *adata, const char *path)",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "294:   char mbox[PATH_MAX];",
          "296:   if (path)",
          "298:   else",
          "299:   {",
          "301:       return NULL;",
          "304:     FREE(&mx.mbox);",
          "305:   }",
          "",
          "[Removed Lines]",
          "297:     imap_cachepath(mdata, path, mbox, sizeof(mbox));",
          "300:     if (!mdata->ctx || imap_parse_path(mdata->ctx->mailbox->path, &mx) < 0)",
          "303:     imap_cachepath(mdata, mx.mbox, mbox, sizeof(mbox));",
          "",
          "[Added Lines]",
          "297:     imap_cachepath(adata, path, mbox, sizeof(mbox));",
          "300:     if (!adata->ctx || imap_parse_path(adata->ctx->mailbox->path, &mx) < 0)",
          "303:     imap_cachepath(adata, mx.mbox, mbox, sizeof(mbox));",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "310:   if ((len > 3) && (strcmp(mbox + len - 3, \"/..\") == 0))",
          "311:     return NULL;",
          "314:   url.path = mbox;",
          "315:   url_tostring(&url, cachepath, sizeof(cachepath), U_PATH);",
          "",
          "[Removed Lines]",
          "313:   mutt_account_tourl(&mdata->conn->account, &url);",
          "",
          "[Added Lines]",
          "313:   mutt_account_tourl(&adata->conn->account, &url);",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "325: {",
          "327:     return;",
          "331: }",
          "341: {",
          "342:   char key[16];",
          "343:   void *uv = NULL;",
          "344:   struct Email *e = NULL;",
          "347:     return NULL;",
          "349:   sprintf(key, \"/%u\", uid);",
          "351:   if (uv)",
          "352:   {",
          "354:       e = mutt_hcache_restore(uv);",
          "355:     else",
          "356:       mutt_debug(3, \"hcache uidvalidity mismatch: %u\\n\", *(unsigned int *) uv);",
          "358:   }",
          "360:   return e;",
          "",
          "[Removed Lines]",
          "324: void imap_hcache_close(struct ImapMboxData *mdata)",
          "326:   if (!mdata->hcache)",
          "329:   mutt_hcache_close(mdata->hcache);",
          "330:   mdata->hcache = NULL;",
          "340: struct Email *imap_hcache_get(struct ImapMboxData *mdata, unsigned int uid)",
          "346:   if (!mdata->hcache)",
          "350:   uv = mutt_hcache_fetch(mdata->hcache, key, imap_hcache_keylen(key));",
          "353:     if (*(unsigned int *) uv == mdata->uid_validity)",
          "357:     mutt_hcache_free(mdata->hcache, &uv);",
          "",
          "[Added Lines]",
          "324: void imap_hcache_close(struct ImapAccountData *adata)",
          "326:   if (!adata->hcache)",
          "329:   mutt_hcache_close(adata->hcache);",
          "330:   adata->hcache = NULL;",
          "340: struct Email *imap_hcache_get(struct ImapAccountData *adata, unsigned int uid)",
          "346:   if (!adata->hcache)",
          "350:   uv = mutt_hcache_fetch(adata->hcache, key, imap_hcache_keylen(key));",
          "353:     if (*(unsigned int *) uv == adata->uid_validity)",
          "357:     mutt_hcache_free(adata->hcache, &uv);",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "371: {",
          "372:   char key[16];",
          "375:     return -1;",
          "377:   sprintf(key, \"/%u\", IMAP_EDATA(e)->uid);",
          "379: }",
          "389: {",
          "390:   char key[16];",
          "393:     return -1;",
          "395:   sprintf(key, \"/%u\", uid);",
          "397: }",
          "406: {",
          "408:     return -1;",
          "410:   struct Buffer *b = mutt_buffer_new();",
          "412:   mutt_buffer_increase_size(b, HUGE_STRING);",
          "415:   size_t seqset_size = b->dptr - b->data;",
          "416:   if (seqset_size == 0)",
          "417:     b->data[0] = '\\0';",
          "420:   mutt_debug(5, \"Stored /UIDSEQSET %s\\n\", b->data);",
          "421:   mutt_buffer_free(&b);",
          "422:   return rc;",
          "",
          "[Removed Lines]",
          "370: int imap_hcache_put(struct ImapMboxData *mdata, struct Email *e)",
          "374:   if (!mdata->hcache)",
          "378:   return mutt_hcache_store(mdata->hcache, key, imap_hcache_keylen(key), e, mdata->uid_validity);",
          "388: int imap_hcache_del(struct ImapMboxData *mdata, unsigned int uid)",
          "392:   if (!mdata->hcache)",
          "396:   return mutt_hcache_delete(mdata->hcache, key, imap_hcache_keylen(key));",
          "405: int imap_hcache_store_uid_seqset(struct ImapMboxData *mdata)",
          "407:   if (!mdata->hcache)",
          "413:   imap_msn_index_to_uid_seqset(b, mdata);",
          "419:   int rc = mutt_hcache_store_raw(mdata->hcache, \"/UIDSEQSET\", 10, b->data, seqset_size + 1);",
          "",
          "[Added Lines]",
          "370: int imap_hcache_put(struct ImapAccountData *adata, struct Email *e)",
          "374:   if (!adata->hcache)",
          "378:   return mutt_hcache_store(adata->hcache, key, imap_hcache_keylen(key), e, adata->uid_validity);",
          "388: int imap_hcache_del(struct ImapAccountData *adata, unsigned int uid)",
          "392:   if (!adata->hcache)",
          "396:   return mutt_hcache_delete(adata->hcache, key, imap_hcache_keylen(key));",
          "405: int imap_hcache_store_uid_seqset(struct ImapAccountData *adata)",
          "407:   if (!adata->hcache)",
          "413:   imap_msn_index_to_uid_seqset(b, adata);",
          "419:   int rc = mutt_hcache_store_raw(adata->hcache, \"/UIDSEQSET\", 10, b->data, seqset_size + 1);",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "432: {",
          "434:     return -1;",
          "437: }",
          "446: {",
          "448:     return NULL;",
          "451:   char *seqset = mutt_str_strdup(hc_seqset);",
          "453:   mutt_debug(5, \"Retrieved /UIDSEQSET %s\\n\", NONULL(seqset));",
          "455:   return seqset;",
          "",
          "[Removed Lines]",
          "431: int imap_hcache_clear_uid_seqset(struct ImapMboxData *mdata)",
          "433:   if (!mdata->hcache)",
          "436:   return mutt_hcache_delete(mdata->hcache, \"/UIDSEQSET\", 10);",
          "445: char *imap_hcache_get_uid_seqset(struct ImapMboxData *mdata)",
          "447:   if (!mdata->hcache)",
          "450:   char *hc_seqset = mutt_hcache_fetch_raw(mdata->hcache, \"/UIDSEQSET\", 10);",
          "452:   mutt_hcache_free(mdata->hcache, (void **) &hc_seqset);",
          "",
          "[Added Lines]",
          "431: int imap_hcache_clear_uid_seqset(struct ImapAccountData *adata)",
          "433:   if (!adata->hcache)",
          "436:   return mutt_hcache_delete(adata->hcache, \"/UIDSEQSET\", 10);",
          "445: char *imap_hcache_get_uid_seqset(struct ImapAccountData *adata)",
          "447:   if (!adata->hcache)",
          "450:   char *hc_seqset = mutt_hcache_fetch_raw(adata->hcache, \"/UIDSEQSET\", 10);",
          "452:   mutt_hcache_free(adata->hcache, (void **) &hc_seqset);",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "701: }",
          "708: {",
          "719: }",
          "726: {",
          "728:     return;",
          "738: }",
          "",
          "[Removed Lines]",
          "707: struct ImapMboxData *imap_mdata_new(void)",
          "709:   struct ImapMboxData *mdata = mutt_mem_calloc(1, sizeof(struct ImapMboxData));",
          "711:   mdata->cmdbuf = mutt_buffer_new();",
          "712:   mdata->cmdslots = ImapPipelineDepth + 2;",
          "713:   mdata->cmds = mutt_mem_calloc(mdata->cmdslots, sizeof(*mdata->cmds));",
          "715:   STAILQ_INIT(&mdata->flags);",
          "716:   STAILQ_INIT(&mdata->mboxcache);",
          "718:   return mdata;",
          "725: void imap_mdata_free(struct ImapMboxData **mdata)",
          "727:   if (!mdata)",
          "730:   FREE(&(*mdata)->capstr);",
          "731:   mutt_list_free(&(*mdata)->flags);",
          "732:   imap_mboxcache_free(*mdata);",
          "733:   mutt_buffer_free(&(*mdata)->cmdbuf);",
          "734:   FREE(&(*mdata)->buf);",
          "735:   mutt_bcache_close(&(*mdata)->bcache);",
          "736:   FREE(&(*mdata)->cmds);",
          "737:   FREE(mdata);",
          "",
          "[Added Lines]",
          "707: struct ImapAccountData *imap_adata_new(void)",
          "709:   struct ImapAccountData *adata = mutt_mem_calloc(1, sizeof(struct ImapAccountData));",
          "711:   adata->cmdbuf = mutt_buffer_new();",
          "712:   adata->cmdslots = ImapPipelineDepth + 2;",
          "713:   adata->cmds = mutt_mem_calloc(adata->cmdslots, sizeof(*adata->cmds));",
          "715:   STAILQ_INIT(&adata->flags);",
          "716:   STAILQ_INIT(&adata->mboxcache);",
          "718:   return adata;",
          "725: void imap_adata_free(struct ImapAccountData **adata)",
          "727:   if (!adata)",
          "730:   FREE(&(*adata)->capstr);",
          "731:   mutt_list_free(&(*adata)->flags);",
          "732:   imap_mboxcache_free(*adata);",
          "733:   mutt_buffer_free(&(*adata)->cmdbuf);",
          "734:   FREE(&(*adata)->buf);",
          "735:   mutt_bcache_close(&(*adata)->bcache);",
          "736:   FREE(&(*adata)->cmds);",
          "737:   FREE(adata);",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "755: {",
          "756:   int i = 0;",
          "757:   char delim = '\\0';",
          "762:   while (mailbox && *mailbox && i < plen - 1)",
          "763:   {",
          "764:     if ((ImapDelimChars && strchr(ImapDelimChars, *mailbox)) || (delim && *mailbox == delim))",
          "765:     {",
          "768:         delim = *mailbox;",
          "770:       while (*mailbox && ((ImapDelimChars && strchr(ImapDelimChars, *mailbox)) ||",
          "",
          "[Removed Lines]",
          "754: char *imap_fix_path(struct ImapMboxData *mdata, const char *mailbox, char *path, size_t plen)",
          "759:   if (mdata)",
          "760:     delim = mdata->delim;",
          "767:       if (!mdata)",
          "",
          "[Added Lines]",
          "754: char *imap_fix_path(struct ImapAccountData *adata, const char *mailbox, char *path, size_t plen)",
          "759:   if (adata)",
          "760:     delim = adata->delim;",
          "767:       if (!adata)",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "799: {",
          "800:   char *s = NULL;",
          "801:   const char *p = mailbox;",
          "803:   for (s = dest; p && *p && dlen; dlen--)",
          "804:   {",
          "806:     {",
          "",
          "[Removed Lines]",
          "798: void imap_cachepath(struct ImapMboxData *mdata, const char *mailbox, char *dest, size_t dlen)",
          "805:     if (*p == mdata->delim)",
          "",
          "[Added Lines]",
          "798: void imap_cachepath(struct ImapAccountData *adata, const char *mailbox, char *dest, size_t dlen)",
          "805:     if (*p == adata->delim)",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "1001: {",
          "1002:   char *buf = mutt_str_strdup(src);",
          "1005:   imap_quote_string(dest, dlen, buf, false);",
          "",
          "[Removed Lines]",
          "1000: void imap_munge_mbox_name(struct ImapMboxData *mdata, char *dest, size_t dlen, const char *src)",
          "1003:   imap_utf_encode(mdata, &buf);",
          "",
          "[Added Lines]",
          "1000: void imap_munge_mbox_name(struct ImapAccountData *adata, char *dest, size_t dlen, const char *src)",
          "1003:   imap_utf_encode(adata, &buf);",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "1018: {",
          "1019:   imap_unquote_string(s);",
          "1021:   char *buf = mutt_str_strdup(s);",
          "1022:   if (buf)",
          "1023:   {",
          "1025:     strncpy(s, buf, strlen(s));",
          "1026:   }",
          "",
          "[Removed Lines]",
          "1017: void imap_unmunge_mbox_name(struct ImapMboxData *mdata, char *s)",
          "1024:     imap_utf_decode(mdata, &buf);",
          "",
          "[Added Lines]",
          "1017: void imap_unmunge_mbox_name(struct ImapAccountData *adata, char *s)",
          "1024:     imap_utf_decode(adata, &buf);",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "1034: void imap_keepalive(void)",
          "1035: {",
          "1036:   struct Connection *conn = NULL;",
          "1038:   time_t now = time(NULL);",
          "1040:   TAILQ_FOREACH(conn, mutt_socket_head(), entries)",
          "1041:   {",
          "1042:     if (conn->account.type == MUTT_ACCT_TYPE_IMAP)",
          "1043:     {",
          "1046:       {",
          "1048:       }",
          "1049:     }",
          "1050:   }",
          "",
          "[Removed Lines]",
          "1037:   struct ImapMboxData *mdata = NULL;",
          "1044:       mdata = conn->data;",
          "1045:       if (mdata->state >= IMAP_AUTHENTICATED && now >= mdata->lastread + ImapKeepalive)",
          "1047:         imap_check(mdata, true);",
          "",
          "[Added Lines]",
          "1037:   struct ImapAccountData *adata = NULL;",
          "1044:       adata = conn->data;",
          "1045:       if (adata->state >= IMAP_AUTHENTICATED && now >= adata->lastread + ImapKeepalive)",
          "1047:         imap_check(adata, true);",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "1106: void imap_allow_reopen(struct Context *ctx)",
          "1107: {",
          "1109:   if (!ctx || !ctx->mailbox->data || ctx->mailbox->magic != MUTT_IMAP)",
          "1110:     return;",
          "1115: }",
          "",
          "[Removed Lines]",
          "1108:   struct ImapMboxData *mdata = NULL;",
          "1112:   mdata = ctx->mailbox->data;",
          "1113:   if (mdata->ctx == ctx)",
          "1114:     mdata->reopen |= IMAP_REOPEN_ALLOW;",
          "",
          "[Added Lines]",
          "1108:   struct ImapAccountData *adata = NULL;",
          "1112:   adata = ctx->mailbox->data;",
          "1113:   if (adata->ctx == ctx)",
          "1114:     adata->reopen |= IMAP_REOPEN_ALLOW;",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "1121: void imap_disallow_reopen(struct Context *ctx)",
          "1122: {",
          "1124:   if (!ctx || !ctx->mailbox || !ctx->mailbox->data || ctx->mailbox->magic != MUTT_IMAP)",
          "1125:     return;",
          "1130: }",
          "",
          "[Removed Lines]",
          "1123:   struct ImapMboxData *mdata = NULL;",
          "1127:   mdata = ctx->mailbox->data;",
          "1128:   if (mdata->ctx == ctx)",
          "1129:     mdata->reopen &= ~IMAP_REOPEN_ALLOW;",
          "",
          "[Added Lines]",
          "1123:   struct ImapAccountData *adata = NULL;",
          "1127:   adata = ctx->mailbox->data;",
          "1128:   if (adata->ctx == ctx)",
          "1129:     adata->reopen &= ~IMAP_REOPEN_ALLOW;",
          "",
          "---------------",
          "--- Hunk 21 ---",
          "[Context before]",
          "1138: bool imap_account_match(const struct ConnAccount *a1, const struct ConnAccount *a2)",
          "1139: {",
          "1142:   const struct ConnAccount *a1_canon = a1_idata ? &a1_idata->conn->account : a1;",
          "1143:   const struct ConnAccount *a2_canon = a2_idata ? &a2_idata->conn->account : a2;",
          "",
          "[Removed Lines]",
          "1140:   struct ImapMboxData *a1_idata = imap_conn_find(a1, MUTT_IMAP_CONN_NONEW);",
          "1141:   struct ImapMboxData *a2_idata = imap_conn_find(a2, MUTT_IMAP_CONN_NONEW);",
          "",
          "[Added Lines]",
          "1140:   struct ImapAccountData *a1_idata = imap_conn_find(a1, MUTT_IMAP_CONN_NONEW);",
          "1141:   struct ImapAccountData *a2_idata = imap_conn_find(a2, MUTT_IMAP_CONN_NONEW);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "d58a649a71e922009c670afc7ed563bd71f87479",
      "candidate_info": {
        "commit_hash": "d58a649a71e922009c670afc7ed563bd71f87479",
        "repo": "neomutt/neomutt",
        "commit_url": "https://github.com/neomutt/neomutt/commit/d58a649a71e922009c670afc7ed563bd71f87479",
        "files": [
          "imap/auth_cram.c",
          "imap/imap.c",
          "imap/imap.h",
          "imap/imap_private.h",
          "imap/message.c"
        ],
        "message": "rearrange functions\n\nNo code changes\n\nStatic functions first\nGeneral public functions\nMailbox functions",
        "before_after_code_files": [
          "imap/auth_cram.c||imap/auth_cram.c",
          "imap/imap.c||imap/imap.c",
          "imap/imap.h||imap/imap.h",
          "imap/imap_private.h||imap/imap_private.h",
          "imap/message.c||imap/message.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "imap/imap.c||imap/imap.c",
            "imap/imap_private.h||imap/imap_private.h"
          ],
          "candidate": [
            "imap/imap.c||imap/imap.c",
            "imap/imap_private.h||imap/imap_private.h"
          ]
        }
      },
      "candidate_diff": {
        "imap/auth_cram.c||imap/auth_cram.c": [
          "File: imap/auth_cram.c -> imap/auth_cram.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "37: #define MD5_BLOCK_LEN 64",
          "38: #define MD5_DIGEST_LEN 16",
          "",
          "[Removed Lines]",
          "41: static void hmac_md5(const char *password, char *challenge, unsigned char *response);",
          "",
          "[Added Lines]",
          "43: static void hmac_md5(const char *password, char *challenge, unsigned char *response)",
          "44: {",
          "45:   struct Md5Ctx ctx;",
          "46:   unsigned char ipad[MD5_BLOCK_LEN], opad[MD5_BLOCK_LEN];",
          "47:   unsigned char secret[MD5_BLOCK_LEN + 1];",
          "48:   unsigned char hash_passwd[MD5_DIGEST_LEN];",
          "49:   unsigned int secret_len, chal_len;",
          "51:   secret_len = strlen(password);",
          "52:   chal_len = strlen(challenge);",
          "56:   if (secret_len > MD5_BLOCK_LEN)",
          "57:   {",
          "58:     md5_buffer(password, secret_len, hash_passwd);",
          "59:     strfcpy((char *) secret, (char *) hash_passwd, MD5_DIGEST_LEN);",
          "60:     secret_len = MD5_DIGEST_LEN;",
          "61:   }",
          "62:   else",
          "63:     strfcpy((char *) secret, password, sizeof(secret));",
          "65:   memset(ipad, 0, sizeof(ipad));",
          "66:   memset(opad, 0, sizeof(opad));",
          "67:   memcpy(ipad, secret, secret_len);",
          "68:   memcpy(opad, secret, secret_len);",
          "70:   for (int i = 0; i < MD5_BLOCK_LEN; i++)",
          "71:   {",
          "72:     ipad[i] ^= 0x36;",
          "73:     opad[i] ^= 0x5c;",
          "74:   }",
          "77:   md5_init_ctx(&ctx);",
          "78:   md5_process_bytes(ipad, MD5_BLOCK_LEN, &ctx);",
          "79:   md5_process_bytes(challenge, chal_len, &ctx);",
          "80:   md5_finish_ctx(&ctx, response);",
          "83:   md5_init_ctx(&ctx);",
          "84:   md5_process_bytes(opad, MD5_BLOCK_LEN, &ctx);",
          "85:   md5_process_bytes(response, MD5_DIGEST_LEN, &ctx);",
          "86:   md5_finish_ctx(&ctx, response);",
          "87: }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "138:   mutt_sleep(2);",
          "139:   return IMAP_AUTH_FAILURE;",
          "140: }",
          "",
          "[Removed Lines]",
          "145: static void hmac_md5(const char *password, char *challenge, unsigned char *response)",
          "146: {",
          "147:   struct Md5Ctx ctx;",
          "148:   unsigned char ipad[MD5_BLOCK_LEN], opad[MD5_BLOCK_LEN];",
          "149:   unsigned char secret[MD5_BLOCK_LEN + 1];",
          "150:   unsigned char hash_passwd[MD5_DIGEST_LEN];",
          "151:   unsigned int secret_len, chal_len;",
          "153:   secret_len = strlen(password);",
          "154:   chal_len = strlen(challenge);",
          "158:   if (secret_len > MD5_BLOCK_LEN)",
          "159:   {",
          "160:     md5_buffer(password, secret_len, hash_passwd);",
          "161:     strfcpy((char *) secret, (char *) hash_passwd, MD5_DIGEST_LEN);",
          "162:     secret_len = MD5_DIGEST_LEN;",
          "163:   }",
          "164:   else",
          "165:     strfcpy((char *) secret, password, sizeof(secret));",
          "167:   memset(ipad, 0, sizeof(ipad));",
          "168:   memset(opad, 0, sizeof(opad));",
          "169:   memcpy(ipad, secret, secret_len);",
          "170:   memcpy(opad, secret, secret_len);",
          "172:   for (int i = 0; i < MD5_BLOCK_LEN; i++)",
          "173:   {",
          "174:     ipad[i] ^= 0x36;",
          "175:     opad[i] ^= 0x5c;",
          "176:   }",
          "179:   md5_init_ctx(&ctx);",
          "180:   md5_process_bytes(ipad, MD5_BLOCK_LEN, &ctx);",
          "181:   md5_process_bytes(challenge, chal_len, &ctx);",
          "182:   md5_finish_ctx(&ctx, response);",
          "185:   md5_init_ctx(&ctx);",
          "186:   md5_process_bytes(opad, MD5_BLOCK_LEN, &ctx);",
          "187:   md5_process_bytes(response, MD5_DIGEST_LEN, &ctx);",
          "188:   md5_finish_ctx(&ctx, response);",
          "189: }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "imap/imap.c||imap/imap.c": [
          "File: imap/imap.c -> imap/imap.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "64: #include \"mutt_ssl.h\"",
          "65: #endif",
          "79: {",
          "92:   {",
          "94:     return -1;",
          "95:   }",
          "110:   {",
          "124:     return -1;",
          "125:   }",
          "134:   return 0;",
          "135: }",
          "138: {",
          "145:   {",
          "148:   }",
          "176:   {",
          "184:   }",
          "186:   {",
          "188:   }",
          "197: }",
          "205: {",
          "219: }",
          "228: {",
          "235:   {",
          "248:     {",
          "251:     }",
          "263:   }",
          "266: }",
          "276: {",
          "350: }",
          "356: {",
          "358:   {",
          "360:     return -1;",
          "361:   }",
          "365:   {",
          "370:     return -1;",
          "371:   }",
          "373:   return 0;",
          "374: }",
          "383: {",
          "390:   {",
          "398:     {",
          "407:     }",
          "413:   }",
          "435:   {",
          "437:     {",
          "479:   }",
          "482:   {",
          "490:     {",
          "499:       {",
          "504:         {",
          "517:         }",
          "518:       }",
          "519:     }",
          "540:   }",
          "542:   return 0;",
          "551: }",
          "554: {",
          "562: }",
          "570: {",
          "583:   {",
          "586:   }",
          "590:   {",
          "610:   }",
          "615: }",
          "618: {",
          "619:   struct ImapData *idata = NULL;",
          "621:   char buf[LONG_STRING];",
          "625:   int rc;",
          "630:     return -1;",
          "635:   if (!idata)",
          "675:   {",
          "684:   }",
          "702:   {",
          "765:   {",
          "772:   }",
          "780:   {",
          "783:   }",
          "788:   {",
          "804:   }",
          "819:   {",
          "823:   }",
          "827:   return 0;",
          "835: }",
          "838: {",
          "840:   char buf[LONG_STRING];",
          "877:     return -1;",
          "879:   return 0;",
          "880: }",
          "886: {",
          "892:   {",
          "895:   }",
          "910:     return -1;",
          "913:   return 0;",
          "914: }",
          "923: {",
          "927: }",
          "937: {",
          "943:   {",
          "949:   }",
          "952: }",
          "962: {",
          "1011:     {",
          "1014:       {",
          "1023:       }",
          "",
          "[Removed Lines]",
          "68: static char *imap_get_flags(struct ListHead *hflags, char *s);",
          "69: static int imap_check_capabilities(struct ImapData *idata);",
          "70: static void imap_set_flag(struct ImapData *idata, int aclbit, int flag,",
          "71:                           const char *str, char *flags, size_t flsize);",
          "78: int imap_access(const char *path)",
          "80:   struct ImapData *idata = NULL;",
          "81:   struct ImapMbox mx;",
          "82:   char buf[LONG_STRING];",
          "83:   char mailbox[LONG_STRING];",
          "84:   char mbox[LONG_STRING];",
          "85:   int rc;",
          "87:   if (imap_parse_path(path, &mx))",
          "88:     return -1;",
          "90:   idata = imap_conn_find(&mx.account, option(OPT_IMAP_PASSIVE) ? MUTT_IMAP_CONN_NONEW : 0);",
          "91:   if (!idata)",
          "93:     FREE(&mx.mbox);",
          "97:   imap_fix_path(idata, mx.mbox, mailbox, sizeof(mailbox));",
          "98:   if (!*mailbox)",
          "99:     strfcpy(mailbox, \"INBOX\", sizeof(mailbox));",
          "102:   if (mutt_strcmp(idata->mailbox, mx.mbox) == 0)",
          "103:   {",
          "104:     FREE(&mx.mbox);",
          "105:     return 0;",
          "106:   }",
          "107:   FREE(&mx.mbox);",
          "109:   if (imap_mboxcache_get(idata, mailbox, 0))",
          "111:     mutt_debug(3, \"imap_access: found %s in cache\\n\", mailbox);",
          "112:     return 0;",
          "113:   }",
          "115:   imap_munge_mbox_name(idata, mbox, sizeof(mbox), mailbox);",
          "117:   if (mutt_bit_isset(idata->capabilities, IMAP4REV1))",
          "118:     snprintf(buf, sizeof(buf), \"STATUS %s (UIDVALIDITY)\", mbox);",
          "119:   else if (mutt_bit_isset(idata->capabilities, STATUS))",
          "120:     snprintf(buf, sizeof(buf), \"STATUS %s (UID-VALIDITY)\", mbox);",
          "121:   else",
          "122:   {",
          "123:     mutt_debug(2, \"imap_access: STATUS not supported?\\n\");",
          "127:   rc = imap_exec(idata, buf, IMAP_CMD_FAIL_OK);",
          "128:   if (rc < 0)",
          "129:   {",
          "130:     mutt_debug(1, \"imap_access: Can't check STATUS of %s\\n\", mbox);",
          "131:     return rc;",
          "132:   }",
          "137: int imap_create_mailbox(struct ImapData *idata, char *mailbox)",
          "139:   char buf[LONG_STRING], mbox[LONG_STRING];",
          "141:   imap_munge_mbox_name(idata, mbox, sizeof(mbox), mailbox);",
          "142:   snprintf(buf, sizeof(buf), \"CREATE %s\", mbox);",
          "144:   if (imap_exec(idata, buf, 0) != 0)",
          "146:     mutt_error(_(\"CREATE failed: %s\"), imap_cmd_trailer(idata));",
          "147:     return -1;",
          "150:   return 0;",
          "151: }",
          "153: int imap_rename_mailbox(struct ImapData *idata, struct ImapMbox *mx, const char *newname)",
          "154: {",
          "155:   char oldmbox[LONG_STRING];",
          "156:   char newmbox[LONG_STRING];",
          "157:   char buf[LONG_STRING];",
          "159:   imap_munge_mbox_name(idata, oldmbox, sizeof(oldmbox), mx->mbox);",
          "160:   imap_munge_mbox_name(idata, newmbox, sizeof(newmbox), newname);",
          "162:   snprintf(buf, sizeof(buf), \"RENAME %s %s\", oldmbox, newmbox);",
          "164:   if (imap_exec(idata, buf, 0) != 0)",
          "165:     return -1;",
          "167:   return 0;",
          "168: }",
          "170: int imap_delete_mailbox(struct Context *ctx, struct ImapMbox *mx)",
          "171: {",
          "172:   char buf[LONG_STRING], mbox[LONG_STRING];",
          "173:   struct ImapData *idata = NULL;",
          "175:   if (!ctx || !ctx->data)",
          "177:     idata = imap_conn_find(&mx->account,",
          "178:                            option(OPT_IMAP_PASSIVE) ? MUTT_IMAP_CONN_NONEW : 0);",
          "179:     if (!idata)",
          "180:     {",
          "181:       FREE(&mx->mbox);",
          "182:       return -1;",
          "183:     }",
          "185:   else",
          "187:     idata = ctx->data;",
          "190:   imap_munge_mbox_name(idata, mbox, sizeof(mbox), mx->mbox);",
          "191:   snprintf(buf, sizeof(buf), \"DELETE %s\", mbox);",
          "193:   if (imap_exec(idata, buf, 0) != 0)",
          "194:     return -1;",
          "196:   return 0;",
          "204: void imap_logout_all(void)",
          "206:   struct ConnectionList *head = mutt_socket_head();",
          "207:   struct Connection *np, *tmp;",
          "208:   TAILQ_FOREACH_SAFE(np, head, entries, tmp)",
          "209:   {",
          "210:     if (np->account.type == MUTT_ACCT_TYPE_IMAP && np->fd >= 0)",
          "211:     {",
          "212:       TAILQ_REMOVE(head, np, entries);",
          "213:       mutt_message(_(\"Closing connection to %s...\"), np->account.host);",
          "214:       imap_logout((struct ImapData **) (void *) &np->data);",
          "215:       mutt_clear_error();",
          "216:       mutt_socket_free(np);",
          "217:     }",
          "218:   }",
          "227: int imap_read_literal(FILE *fp, struct ImapData *idata, long bytes, struct Progress *pbar)",
          "229:   char c;",
          "230:   bool r = false;",
          "232:   mutt_debug(2, \"imap_read_literal: reading %ld bytes\\n\", bytes);",
          "234:   for (long pos = 0; pos < bytes; pos++)",
          "236:     if (mutt_socket_readchar(idata->conn, &c) != 1)",
          "237:     {",
          "238:       mutt_debug(1, \"imap_read_literal: error during read, %ld bytes read\\n\", pos);",
          "239:       idata->status = IMAP_FATAL;",
          "241:       return -1;",
          "242:     }",
          "244:     if (r && c != '\\n')",
          "245:       fputc('\\r', fp);",
          "247:     if (c == '\\r')",
          "249:       r = true;",
          "250:       continue;",
          "252:     else",
          "253:       r = false;",
          "255:     fputc(c, fp);",
          "257:     if (pbar && !(pos % 1024))",
          "258:       mutt_progress_update(pbar, pos, -1);",
          "259: #ifdef DEBUG",
          "260:     if (debuglevel >= IMAP_LOG_LTRL)",
          "261:       fputc(c, debugfile);",
          "262: #endif",
          "265:   return 0;",
          "275: void imap_expunge_mailbox(struct ImapData *idata)",
          "277:   struct Header *h = NULL;",
          "278:   int cacheno;",
          "279:   short old_sort;",
          "281: #ifdef USE_HCACHE",
          "282:   idata->hcache = imap_hcache_open(idata, NULL);",
          "283: #endif",
          "285:   old_sort = Sort;",
          "286:   Sort = SORT_ORDER;",
          "287:   mutt_sort_headers(idata->ctx, 0);",
          "289:   for (int i = 0; i < idata->ctx->msgcount; i++)",
          "290:   {",
          "291:     h = idata->ctx->hdrs[i];",
          "293:     if (h->index == INT_MAX)",
          "294:     {",
          "295:       mutt_debug(2, \"Expunging message UID %d.\\n\", HEADER_DATA(h)->uid);",
          "297:       h->active = false;",
          "298:       idata->ctx->size -= h->content->length;",
          "300:       imap_cache_del(idata, h);",
          "301: #ifdef USE_HCACHE",
          "302:       imap_hcache_del(idata, HEADER_DATA(h)->uid);",
          "303: #endif",
          "306:       cacheno = HEADER_DATA(h)->uid % IMAP_CACHE_LEN;",
          "307:       if (idata->cache[cacheno].uid == HEADER_DATA(h)->uid &&",
          "308:           idata->cache[cacheno].path)",
          "309:       {",
          "310:         unlink(idata->cache[cacheno].path);",
          "311:         FREE(&idata->cache[cacheno].path);",
          "312:       }",
          "314:       int_hash_delete(idata->uid_hash, HEADER_DATA(h)->uid, h, NULL);",
          "316:       imap_free_header_data((struct ImapHeaderData **) &h->data);",
          "317:     }",
          "318:     else",
          "319:     {",
          "320:       h->index = i;",
          "337:       h->active = true;",
          "338:     }",
          "339:   }",
          "341: #ifdef USE_HCACHE",
          "342:   imap_hcache_close(idata);",
          "343: #endif",
          "347:   mx_update_tables(idata->ctx, false);",
          "348:   Sort = old_sort;",
          "349:   mutt_sort_headers(idata->ctx, 1);",
          "355: static int imap_check_capabilities(struct ImapData *idata)",
          "357:   if (imap_exec(idata, \"CAPABILITY\", 0) != 0)",
          "359:     imap_error(\"imap_check_capabilities\", idata->buf);",
          "363:   if (!(mutt_bit_isset(idata->capabilities, IMAP4) ||",
          "364:         mutt_bit_isset(idata->capabilities, IMAP4REV1)))",
          "366:     mutt_error(",
          "367:         _(\"This IMAP server is ancient. NeoMutt does not work with it.\"));",
          "382: struct ImapData *imap_conn_find(const struct Account *account, int flags)",
          "384:   struct Connection *conn = NULL;",
          "385:   struct Account *creds = NULL;",
          "386:   struct ImapData *idata = NULL;",
          "387:   bool new = false;",
          "389:   while ((conn = mutt_conn_find(conn, account)))",
          "391:     if (!creds)",
          "392:       creds = &conn->account;",
          "393:     else",
          "394:       memcpy(&conn->account, creds, sizeof(struct Account));",
          "396:     idata = conn->data;",
          "397:     if (flags & MUTT_IMAP_CONN_NONEW)",
          "399:       if (!idata)",
          "400:       {",
          "402:         mutt_socket_free(conn);",
          "403:         return NULL;",
          "404:       }",
          "405:       else if (idata->state < IMAP_AUTHENTICATED)",
          "406:         continue;",
          "408:     if (flags & MUTT_IMAP_CONN_NOSELECT && idata && idata->state >= IMAP_SELECTED)",
          "409:       continue;",
          "410:     if (idata && idata->status == IMAP_FATAL)",
          "411:       continue;",
          "412:     break;",
          "414:   if (!conn)",
          "417:   if (!idata)",
          "418:   {",
          "420:     idata = imap_new_idata();",
          "421:     if (!idata)",
          "422:     {",
          "423:       mutt_socket_free(conn);",
          "424:       return NULL;",
          "425:     }",
          "427:     conn->data = idata;",
          "428:     idata->conn = conn;",
          "429:     new = true;",
          "430:   }",
          "432:   if (idata->state == IMAP_DISCONNECTED)",
          "433:     imap_open_connection(idata);",
          "434:   if (idata->state == IMAP_CONNECTED)",
          "436:     if (!imap_authenticate(idata))",
          "438:       idata->state = IMAP_AUTHENTICATED;",
          "439:       FREE(&idata->capstr);",
          "440:       new = true;",
          "441:       if (idata->conn->ssf)",
          "442:         mutt_debug(2, \"Communication encrypted at %d bits\\n\", idata->conn->ssf);",
          "443:     }",
          "444:     else",
          "445:       mutt_account_unsetpass(&idata->conn->account);",
          "446:   }",
          "447:   if (new && idata->state == IMAP_AUTHENTICATED)",
          "448:   {",
          "450:     imap_exec(idata, \"CAPABILITY\", IMAP_CMD_QUEUE);",
          "452:     if (mutt_bit_isset(idata->capabilities, ENABLE))",
          "453:       imap_exec(idata, \"ENABLE UTF8=ACCEPT\", IMAP_CMD_QUEUE);",
          "455:     idata->delim = '/';",
          "456:     imap_exec(idata, \"LIST \\\"\\\" \\\"\\\"\", IMAP_CMD_QUEUE);",
          "457:     if (option(OPT_IMAP_CHECK_SUBSCRIBED))",
          "458:       imap_exec(idata, \"LSUB \\\"\\\" \\\"*\\\"\", IMAP_CMD_QUEUE);",
          "460:     imap_exec(idata, NULL, IMAP_CMD_FAIL_OK);",
          "461:   }",
          "463:   return idata;",
          "464: }",
          "466: int imap_open_connection(struct ImapData *idata)",
          "467: {",
          "468:   char buf[LONG_STRING];",
          "470:   if (mutt_socket_open(idata->conn) < 0)",
          "471:     return -1;",
          "473:   idata->state = IMAP_CONNECTED;",
          "475:   if (imap_cmd_step(idata) != IMAP_CMD_OK)",
          "476:   {",
          "477:     imap_close_connection(idata);",
          "478:     return -1;",
          "481:   if (mutt_strncasecmp(\"* OK\", idata->buf, 4) == 0)",
          "483:     if ((mutt_strncasecmp(\"* OK [CAPABILITY\", idata->buf, 16) != 0) &&",
          "484:         imap_check_capabilities(idata))",
          "485:       goto bail;",
          "486: #ifdef USE_SSL",
          "488:     if (!idata->conn->ssf &&",
          "489:         (option(OPT_SSL_FORCE_TLS) || mutt_bit_isset(idata->capabilities, STARTTLS)))",
          "491:       int rc;",
          "493:       if (option(OPT_SSL_FORCE_TLS))",
          "494:         rc = MUTT_YES;",
          "495:       else if ((rc = query_quadoption(OPT_SSL_STARTTLS,",
          "496:                                       _(\"Secure connection with TLS?\"))) == MUTT_ABORT)",
          "497:         goto err_close_conn;",
          "498:       if (rc == MUTT_YES)",
          "500:         rc = imap_exec(idata, \"STARTTLS\", IMAP_CMD_FAIL_OK);",
          "501:         if (rc == -1)",
          "502:           goto bail;",
          "503:         if (rc != -2)",
          "505:           if (mutt_ssl_starttls(idata->conn))",
          "506:           {",
          "507:             mutt_error(_(\"Could not negotiate TLS connection\"));",
          "508:             mutt_sleep(1);",
          "509:             goto err_close_conn;",
          "510:           }",
          "511:           else",
          "512:           {",
          "514:             if (imap_exec(idata, \"CAPABILITY\", 0))",
          "515:               goto bail;",
          "516:           }",
          "521:     if (option(OPT_SSL_FORCE_TLS) && !idata->conn->ssf)",
          "522:     {",
          "523:       mutt_error(_(\"Encrypted connection unavailable\"));",
          "524:       mutt_sleep(1);",
          "525:       goto err_close_conn;",
          "526:     }",
          "527: #endif",
          "528:   }",
          "529:   else if (mutt_strncasecmp(\"* PREAUTH\", idata->buf, 9) == 0)",
          "530:   {",
          "531:     idata->state = IMAP_AUTHENTICATED;",
          "532:     if (imap_check_capabilities(idata) != 0)",
          "533:       goto bail;",
          "534:     FREE(&idata->capstr);",
          "535:   }",
          "536:   else",
          "537:   {",
          "538:     imap_error(\"imap_open_connection()\", buf);",
          "539:     goto bail;",
          "544: #ifdef USE_SSL",
          "545: err_close_conn:",
          "546:   imap_close_connection(idata);",
          "547: #endif",
          "548: bail:",
          "549:   FREE(&idata->capstr);",
          "550:   return -1;",
          "553: void imap_close_connection(struct ImapData *idata)",
          "555:   if (idata->state != IMAP_DISCONNECTED)",
          "556:   {",
          "557:     mutt_socket_close(idata->conn);",
          "558:     idata->state = IMAP_DISCONNECTED;",
          "559:   }",
          "560:   idata->seqno = idata->nextcmd = idata->lastcmd = idata->status = false;",
          "561:   memset(idata->cmds, 0, sizeof(struct ImapCommand) * idata->cmdslots);",
          "569: static char *imap_get_flags(struct ListHead *hflags, char *s)",
          "571:   char *flag_word = NULL;",
          "572:   char ctmp;",
          "575:   if (mutt_strncasecmp(\"FLAGS\", s, 5) != 0)",
          "576:   {",
          "577:     mutt_debug(1, \"imap_get_flags: not a FLAGS response: %s\\n\", s);",
          "578:     return NULL;",
          "579:   }",
          "580:   s += 5;",
          "581:   SKIPWS(s);",
          "582:   if (*s != '(')",
          "584:     mutt_debug(1, \"imap_get_flags: bogus FLAGS response: %s\\n\", s);",
          "585:     return NULL;",
          "589:   while (*s && *s != ')')",
          "591:     s++;",
          "592:     SKIPWS(s);",
          "593:     flag_word = s;",
          "594:     while (*s && (*s != ')') && !ISSPACE(*s))",
          "595:       s++;",
          "596:     ctmp = *s;",
          "598:     if (*flag_word)",
          "599:       mutt_list_insert_tail(hflags, safe_strdup(flag_word));",
          "601:   }",
          "604:   if (*s != ')')",
          "605:   {",
          "606:     mutt_debug(1, \"imap_get_flags: Unterminated FLAGS response: %s\\n\", s);",
          "607:     mutt_list_free(hflags);",
          "609:     return NULL;",
          "612:   s++;",
          "614:   return s;",
          "617: static int imap_open_mailbox(struct Context *ctx)",
          "620:   struct ImapStatus *status = NULL;",
          "622:   char bufout[LONG_STRING];",
          "623:   int count = 0;",
          "624:   struct ImapMbox mx, pmx;",
          "627:   if (imap_parse_path(ctx->path, &mx))",
          "628:   {",
          "629:     mutt_error(_(\"%s is an invalid IMAP path\"), ctx->path);",
          "631:   }",
          "634:   idata = imap_conn_find(&(mx.account), MUTT_IMAP_CONN_NOSELECT);",
          "636:     goto fail_noidata;",
          "637:   if (idata->state < IMAP_AUTHENTICATED)",
          "638:     goto fail;",
          "641:   ctx->data = idata;",
          "644:   imap_fix_path(idata, mx.mbox, buf, sizeof(buf));",
          "645:   if (!*buf)",
          "646:     strfcpy(buf, \"INBOX\", sizeof(buf));",
          "647:   FREE(&(idata->mailbox));",
          "648:   idata->mailbox = safe_strdup(buf);",
          "649:   imap_qualify_path(buf, sizeof(buf), &mx, idata->mailbox);",
          "651:   FREE(&(ctx->path));",
          "652:   FREE(&(ctx->realpath));",
          "653:   ctx->path = safe_strdup(buf);",
          "654:   ctx->realpath = safe_strdup(ctx->path);",
          "656:   idata->ctx = ctx;",
          "659:   idata->status = false;",
          "660:   memset(idata->ctx->rights, 0, sizeof(idata->ctx->rights));",
          "661:   idata->new_mail_count = 0;",
          "662:   idata->max_msn = 0;",
          "664:   mutt_message(_(\"Selecting %s...\"), idata->mailbox);",
          "665:   imap_munge_mbox_name(idata, buf, sizeof(buf), idata->mailbox);",
          "668:   if (mutt_bit_isset(idata->capabilities, ACL))",
          "669:   {",
          "670:     snprintf(bufout, sizeof(bufout), \"MYRIGHTS %s\", buf);",
          "671:     imap_exec(idata, bufout, IMAP_CMD_QUEUE);",
          "672:   }",
          "674:   else",
          "676:     mutt_bit_set(idata->ctx->rights, MUTT_ACL_LOOKUP);",
          "677:     mutt_bit_set(idata->ctx->rights, MUTT_ACL_READ);",
          "678:     mutt_bit_set(idata->ctx->rights, MUTT_ACL_SEEN);",
          "679:     mutt_bit_set(idata->ctx->rights, MUTT_ACL_WRITE);",
          "680:     mutt_bit_set(idata->ctx->rights, MUTT_ACL_INSERT);",
          "681:     mutt_bit_set(idata->ctx->rights, MUTT_ACL_POST);",
          "682:     mutt_bit_set(idata->ctx->rights, MUTT_ACL_CREATE);",
          "683:     mutt_bit_set(idata->ctx->rights, MUTT_ACL_DELETE);",
          "686:   pmx.mbox = NULL;",
          "687:   if (mx_is_imap(Postponed) && !imap_parse_path(Postponed, &pmx) &&",
          "688:       mutt_account_match(&pmx.account, &mx.account))",
          "689:     imap_status(Postponed, 1);",
          "690:   FREE(&pmx.mbox);",
          "692:   snprintf(bufout, sizeof(bufout), \"%s %s\",",
          "693:            ctx->readonly ? \"EXAMINE\" : \"SELECT\", buf);",
          "695:   idata->state = IMAP_SELECTED;",
          "697:   imap_cmd_start(idata, bufout);",
          "699:   status = imap_mboxcache_get(idata, idata->mailbox, 1);",
          "701:   do",
          "703:     char *pc = NULL;",
          "705:     rc = imap_cmd_step(idata);",
          "706:     if (rc != IMAP_CMD_CONTINUE)",
          "707:       break;",
          "709:     pc = idata->buf + 2;",
          "713:     if (mutt_strncasecmp(\"FLAGS\", pc, 5) == 0)",
          "714:     {",
          "716:       if (STAILQ_EMPTY(&idata->flags))",
          "717:       {",
          "718:         mutt_debug(3, \"Getting mailbox FLAGS\\n\");",
          "719:         pc = imap_get_flags(&idata->flags, pc);",
          "720:         if (!pc)",
          "721:           goto fail;",
          "722:       }",
          "723:     }",
          "725:     else if (mutt_strncasecmp(\"OK [PERMANENTFLAGS\", pc, 18) == 0)",
          "726:     {",
          "727:       mutt_debug(3, \"Getting mailbox PERMANENTFLAGS\\n\");",
          "729:       mutt_list_free(&idata->flags);",
          "731:       pc += 13;",
          "732:       pc = imap_get_flags(&(idata->flags), pc);",
          "733:       if (!pc)",
          "734:         goto fail;",
          "735:     }",
          "737:     else if (mutt_strncasecmp(\"OK [UIDVALIDITY\", pc, 14) == 0)",
          "738:     {",
          "739:       mutt_debug(3, \"Getting mailbox UIDVALIDITY\\n\");",
          "740:       pc += 3;",
          "741:       pc = imap_next_word(pc);",
          "742:       idata->uid_validity = strtol(pc, NULL, 10);",
          "743:       status->uidvalidity = idata->uid_validity;",
          "744:     }",
          "745:     else if (mutt_strncasecmp(\"OK [UIDNEXT\", pc, 11) == 0)",
          "746:     {",
          "747:       mutt_debug(3, \"Getting mailbox UIDNEXT\\n\");",
          "748:       pc += 3;",
          "749:       pc = imap_next_word(pc);",
          "750:       idata->uidnext = strtol(pc, NULL, 10);",
          "751:       status->uidnext = idata->uidnext;",
          "752:     }",
          "753:     else",
          "754:     {",
          "755:       pc = imap_next_word(pc);",
          "756:       if (mutt_strncasecmp(\"EXISTS\", pc, 6) == 0)",
          "757:       {",
          "758:         count = idata->new_mail_count;",
          "759:         idata->new_mail_count = 0;",
          "760:       }",
          "761:     }",
          "762:   } while (rc == IMAP_CMD_CONTINUE);",
          "764:   if (rc == IMAP_CMD_NO)",
          "766:     char *s = NULL;",
          "769:     mutt_error(\"%s\", s);",
          "770:     mutt_sleep(2);",
          "771:     goto fail;",
          "774:   if (rc != IMAP_CMD_OK)",
          "775:     goto fail;",
          "778:   if ((mutt_strncasecmp(imap_get_qualifier(idata->buf), \"[READ-ONLY]\", 11) == 0) &&",
          "779:       !mutt_bit_isset(idata->capabilities, ACL))",
          "781:     mutt_debug(2, \"Mailbox is read-only.\\n\");",
          "782:     ctx->readonly = true;",
          "785: #ifdef DEBUG",
          "787:   if (debuglevel > 2)",
          "789:     if (STAILQ_EMPTY(&idata->flags))",
          "790:       mutt_debug(3, \"No folder flags found\\n\");",
          "791:     else",
          "792:     {",
          "793:       struct ListNode *np;",
          "794:       struct Buffer flag_buffer;",
          "795:       mutt_buffer_init(&flag_buffer);",
          "796:       mutt_buffer_printf(&flag_buffer, \"Mailbox flags: \");",
          "797:       STAILQ_FOREACH(np, &idata->flags, entries)",
          "798:       {",
          "799:         mutt_buffer_printf(&flag_buffer, \"[%s] \", np->data);",
          "800:       }",
          "801:       mutt_debug(3, \"%s\\n\", flag_buffer.data);",
          "802:       FREE(&flag_buffer.data);",
          "803:     }",
          "805: #endif",
          "807:   if (!(mutt_bit_isset(idata->ctx->rights, MUTT_ACL_DELETE) ||",
          "808:         mutt_bit_isset(idata->ctx->rights, MUTT_ACL_SEEN) ||",
          "809:         mutt_bit_isset(idata->ctx->rights, MUTT_ACL_WRITE) ||",
          "810:         mutt_bit_isset(idata->ctx->rights, MUTT_ACL_INSERT)))",
          "811:     ctx->readonly = true;",
          "813:   ctx->hdrmax = count;",
          "814:   ctx->hdrs = safe_calloc(count, sizeof(struct Header *));",
          "815:   ctx->v2r = safe_calloc(count, sizeof(int));",
          "816:   ctx->msgcount = 0;",
          "818:   if (count && (imap_read_headers(idata, 1, count) < 0))",
          "820:     mutt_error(_(\"Error opening mailbox\"));",
          "821:     mutt_sleep(1);",
          "822:     goto fail;",
          "825:   mutt_debug(2, \"imap_open_mailbox: msgcount is %d\\n\", ctx->msgcount);",
          "826:   FREE(&mx.mbox);",
          "829: fail:",
          "830:   if (idata->state == IMAP_SELECTED)",
          "831:     idata->state = IMAP_AUTHENTICATED;",
          "832: fail_noidata:",
          "833:   FREE(&mx.mbox);",
          "834:   return -1;",
          "837: static int imap_open_mailbox_append(struct Context *ctx, int flags)",
          "839:   struct ImapData *idata = NULL;",
          "841:   char mailbox[LONG_STRING];",
          "842:   struct ImapMbox mx;",
          "843:   int rc;",
          "845:   if (imap_parse_path(ctx->path, &mx))",
          "846:     return -1;",
          "851:   idata = imap_conn_find(&(mx.account), 0);",
          "852:   if (!idata)",
          "853:   {",
          "854:     FREE(&mx.mbox);",
          "855:     return -1;",
          "856:   }",
          "858:   ctx->data = idata;",
          "860:   imap_fix_path(idata, mx.mbox, mailbox, sizeof(mailbox));",
          "861:   if (!*mailbox)",
          "862:     strfcpy(mailbox, \"INBOX\", sizeof(mailbox));",
          "863:   FREE(&mx.mbox);",
          "865:   rc = imap_access(ctx->path);",
          "866:   if (rc == 0)",
          "867:     return 0;",
          "869:   if (rc == -1)",
          "870:     return -1;",
          "872:   snprintf(buf, sizeof(buf), _(\"Create %s?\"), mailbox);",
          "873:   if (option(OPT_CONFIRMCREATE) && mutt_yesorno(buf, 1) != MUTT_YES)",
          "874:     return -1;",
          "876:   if (imap_create_mailbox(idata, mailbox) < 0)",
          "885: void imap_logout(struct ImapData **idata)",
          "889:   (*idata)->status = IMAP_BYE;",
          "890:   imap_cmd_start(*idata, \"LOGOUT\");",
          "891:   if (ImapPollTimeout <= 0 || mutt_socket_poll((*idata)->conn, ImapPollTimeout) != 0)",
          "893:     while (imap_cmd_step(*idata) == IMAP_CMD_CONTINUE)",
          "894:       ;",
          "897:   mutt_socket_close((*idata)->conn);",
          "898:   imap_free_idata(idata);",
          "899: }",
          "901: static int imap_open_new_message(struct Message *msg, struct Context *dest, struct Header *hdr)",
          "902: {",
          "903:   char tmp[_POSIX_PATH_MAX];",
          "905:   mutt_mktemp(tmp, sizeof(tmp));",
          "906:   msg->fp = safe_fopen(tmp, \"w\");",
          "907:   if (!msg->fp)",
          "908:   {",
          "909:     mutt_perror(tmp);",
          "911:   }",
          "912:   msg->path = safe_strdup(tmp);",
          "921: static void imap_set_flag(struct ImapData *idata, int aclbit, int flag,",
          "922:                           const char *str, char *flags, size_t flsize)",
          "924:   if (mutt_bit_isset(idata->ctx->rights, aclbit))",
          "925:     if (flag && imap_has_flag(&idata->flags, str))",
          "926:       safe_strcat(flags, flsize, str);",
          "936: bool imap_has_flag(struct ListHead *flag_list, const char *flag)",
          "938:   if (STAILQ_EMPTY(flag_list))",
          "939:     return false;",
          "941:   struct ListNode *np;",
          "942:   STAILQ_FOREACH(np, flag_list, entries)",
          "944:     if (mutt_strncasecmp(np->data, flag, strlen(np->data)) == 0)",
          "945:       return true;",
          "947:     if (mutt_strncmp(np->data, \"\\\\*\", strlen(np->data)) == 0)",
          "948:       return true;",
          "951:   return false;",
          "960: static int imap_make_msg_set(struct ImapData *idata, struct Buffer *buf,",
          "961:                              int flag, bool changed, bool invert, int *pos)",
          "963:   struct Header **hdrs = idata->ctx->hdrs;",
          "967:   int n;",
          "968:   bool started = false;",
          "970:   hdrs = idata->ctx->hdrs;",
          "972:   for (n = *pos; n < idata->ctx->msgcount && buf->dptr - buf->data < IMAP_MAX_CMDLEN; n++)",
          "973:   {",
          "974:     match = false;",
          "976:     if (hdrs[n]->active)",
          "977:       switch (flag)",
          "978:       {",
          "979:         case MUTT_DELETED:",
          "980:           if (hdrs[n]->deleted != HEADER_DATA(hdrs[n])->deleted)",
          "981:             match = invert ^ hdrs[n]->deleted;",
          "982:           break;",
          "983:         case MUTT_FLAG:",
          "984:           if (hdrs[n]->flagged != HEADER_DATA(hdrs[n])->flagged)",
          "985:             match = invert ^ hdrs[n]->flagged;",
          "986:           break;",
          "987:         case MUTT_OLD:",
          "988:           if (hdrs[n]->old != HEADER_DATA(hdrs[n])->old)",
          "989:             match = invert ^ hdrs[n]->old;",
          "990:           break;",
          "991:         case MUTT_READ:",
          "992:           if (hdrs[n]->read != HEADER_DATA(hdrs[n])->read)",
          "993:             match = invert ^ hdrs[n]->read;",
          "994:           break;",
          "995:         case MUTT_REPLIED:",
          "996:           if (hdrs[n]->replied != HEADER_DATA(hdrs[n])->replied)",
          "997:             match = invert ^ hdrs[n]->replied;",
          "998:           break;",
          "1000:         case MUTT_TAG:",
          "1001:           if (hdrs[n]->tagged)",
          "1002:             match = true;",
          "1003:           break;",
          "1004:         case MUTT_TRASH:",
          "1005:           if (hdrs[n]->deleted && !hdrs[n]->purge)",
          "1006:             match = true;",
          "1007:           break;",
          "1008:       }",
          "1010:     if (match && (!changed || hdrs[n]->changed))",
          "1012:       count++;",
          "1013:       if (setstart == 0)",
          "1015:         setstart = HEADER_DATA(hdrs[n])->uid;",
          "1016:         if (!started)",
          "1017:         {",
          "1018:           mutt_buffer_printf(buf, \"%u\", HEADER_DATA(hdrs[n])->uid);",
          "1019:           started = true;",
          "1020:         }",
          "1021:         else",
          "1022:           mutt_buffer_printf(buf, \",%u\", HEADER_DATA(hdrs[n])->uid);",
          "1025:       else if (n == idata->ctx->msgcount - 1)",
          "1026:         mutt_buffer_printf(buf, \":%u\", HEADER_DATA(hdrs[n])->uid);",
          "1027:     }",
          "1030:     else if (setstart && (hdrs[n]->active || n == idata->ctx->msgcount - 1))",
          "1031:     {",
          "1032:       if (HEADER_DATA(hdrs[n - 1])->uid > setstart)",
          "1033:         mutt_buffer_printf(buf, \":%u\", HEADER_DATA(hdrs[n - 1])->uid);",
          "1034:       setstart = 0;",
          "1035:     }",
          "1036:   }",
          "1040:   return count;",
          "1041: }",
          "",
          "[Added Lines]",
          "70: static int imap_check_capabilities(struct ImapData *idata)",
          "72:   if (imap_exec(idata, \"CAPABILITY\", 0) != 0)",
          "74:     imap_error(\"imap_check_capabilities\", idata->buf);",
          "78:   if (!(mutt_bit_isset(idata->capabilities, IMAP4) ||",
          "79:         mutt_bit_isset(idata->capabilities, IMAP4REV1)))",
          "81:     mutt_error(",
          "82:         _(\"This IMAP server is ancient. NeoMutt does not work with it.\"));",
          "96: static char *imap_get_flags(struct ListHead *hflags, char *s)",
          "98:   char *flag_word = NULL;",
          "99:   char ctmp;",
          "102:   if (mutt_strncasecmp(\"FLAGS\", s, 5) != 0)",
          "104:     mutt_debug(1, \"imap_get_flags: not a FLAGS response: %s\\n\", s);",
          "105:     return NULL;",
          "107:   s += 5;",
          "108:   SKIPWS(s);",
          "109:   if (*s != '(')",
          "111:     mutt_debug(1, \"imap_get_flags: bogus FLAGS response: %s\\n\", s);",
          "112:     return NULL;",
          "116:   while (*s && *s != ')')",
          "118:     s++;",
          "119:     SKIPWS(s);",
          "120:     flag_word = s;",
          "121:     while (*s && (*s != ')') && !ISSPACE(*s))",
          "122:       s++;",
          "123:     ctmp = *s;",
          "125:     if (*flag_word)",
          "126:       mutt_list_insert_tail(hflags, safe_strdup(flag_word));",
          "131:   if (*s != ')')",
          "132:   {",
          "133:     mutt_debug(1, \"imap_get_flags: Unterminated FLAGS response: %s\\n\", s);",
          "134:     mutt_list_free(hflags);",
          "136:     return NULL;",
          "137:   }",
          "139:   s++;",
          "141:   return s;",
          "149: static void imap_set_flag(struct ImapData *idata, int aclbit, int flag,",
          "150:                           const char *str, char *flags, size_t flsize)",
          "152:   if (mutt_bit_isset(idata->ctx->rights, aclbit))",
          "153:     if (flag && imap_has_flag(&idata->flags, str))",
          "154:       safe_strcat(flags, flsize, str);",
          "163: static int imap_make_msg_set(struct ImapData *idata, struct Buffer *buf,",
          "164:                              int flag, bool changed, bool invert, int *pos)",
          "166:   struct Header **hdrs = idata->ctx->hdrs;",
          "170:   int n;",
          "171:   bool started = false;",
          "173:   hdrs = idata->ctx->hdrs;",
          "175:   for (n = *pos; n < idata->ctx->msgcount && buf->dptr - buf->data < IMAP_MAX_CMDLEN; n++)",
          "177:     match = false;",
          "179:     if (hdrs[n]->active)",
          "180:       switch (flag)",
          "181:       {",
          "182:         case MUTT_DELETED:",
          "183:           if (hdrs[n]->deleted != HEADER_DATA(hdrs[n])->deleted)",
          "184:             match = invert ^ hdrs[n]->deleted;",
          "185:           break;",
          "186:         case MUTT_FLAG:",
          "187:           if (hdrs[n]->flagged != HEADER_DATA(hdrs[n])->flagged)",
          "188:             match = invert ^ hdrs[n]->flagged;",
          "189:           break;",
          "190:         case MUTT_OLD:",
          "191:           if (hdrs[n]->old != HEADER_DATA(hdrs[n])->old)",
          "192:             match = invert ^ hdrs[n]->old;",
          "193:           break;",
          "194:         case MUTT_READ:",
          "195:           if (hdrs[n]->read != HEADER_DATA(hdrs[n])->read)",
          "196:             match = invert ^ hdrs[n]->read;",
          "197:           break;",
          "198:         case MUTT_REPLIED:",
          "199:           if (hdrs[n]->replied != HEADER_DATA(hdrs[n])->replied)",
          "200:             match = invert ^ hdrs[n]->replied;",
          "201:           break;",
          "203:         case MUTT_TAG:",
          "204:           if (hdrs[n]->tagged)",
          "205:             match = true;",
          "206:           break;",
          "207:         case MUTT_TRASH:",
          "208:           if (hdrs[n]->deleted && !hdrs[n]->purge)",
          "209:             match = true;",
          "210:           break;",
          "211:       }",
          "213:     if (match && (!changed || hdrs[n]->changed))",
          "215:       count++;",
          "216:       if (setstart == 0)",
          "217:       {",
          "218:         setstart = HEADER_DATA(hdrs[n])->uid;",
          "219:         if (!started)",
          "220:         {",
          "221:           mutt_buffer_printf(buf, \"%u\", HEADER_DATA(hdrs[n])->uid);",
          "222:           started = true;",
          "223:         }",
          "224:         else",
          "225:           mutt_buffer_printf(buf, \",%u\", HEADER_DATA(hdrs[n])->uid);",
          "226:       }",
          "228:       else if (n == idata->ctx->msgcount - 1)",
          "229:         mutt_buffer_printf(buf, \":%u\", HEADER_DATA(hdrs[n])->uid);",
          "230:     }",
          "233:     else if (setstart && (hdrs[n]->active || n == idata->ctx->msgcount - 1))",
          "234:     {",
          "235:       if (HEADER_DATA(hdrs[n - 1])->uid > setstart)",
          "236:         mutt_buffer_printf(buf, \":%u\", HEADER_DATA(hdrs[n - 1])->uid);",
          "237:       setstart = 0;",
          "243:   return count;",
          "251: static bool compare_flags_for_copy(struct Header *h)",
          "253:   struct ImapHeaderData *hd = (struct ImapHeaderData *) h->data;",
          "255:   if (h->read != hd->read)",
          "256:     return true;",
          "257:   if (h->old != hd->old)",
          "258:     return true;",
          "259:   if (h->flagged != hd->flagged)",
          "260:     return true;",
          "261:   if (h->replied != hd->replied)",
          "262:     return true;",
          "264:   return false;",
          "265: }",
          "267: static int sync_helper(struct ImapData *idata, int right, int flag, const char *name)",
          "268: {",
          "269:   int count = 0;",
          "270:   int rc;",
          "271:   char buf[LONG_STRING];",
          "273:   if (!idata->ctx)",
          "274:     return -1;",
          "276:   if (!mutt_bit_isset(idata->ctx->rights, right))",
          "277:     return 0;",
          "279:   if (right == MUTT_ACL_WRITE && !imap_has_flag(&idata->flags, name))",
          "280:     return 0;",
          "282:   snprintf(buf, sizeof(buf), \"+FLAGS.SILENT (%s)\", name);",
          "283:   rc = imap_exec_msgset(idata, \"UID STORE\", buf, flag, 1, 0);",
          "284:   if (rc < 0)",
          "285:     return rc;",
          "286:   count += rc;",
          "288:   buf[0] = '-';",
          "289:   rc = imap_exec_msgset(idata, \"UID STORE\", buf, flag, 1, 1);",
          "290:   if (rc < 0)",
          "291:     return rc;",
          "292:   count += rc;",
          "294:   return count;",
          "300: static int imap_get_mailbox(const char *path, struct ImapData **hidata, char *buf, size_t blen)",
          "302:   struct ImapMbox mx;",
          "304:   if (imap_parse_path(path, &mx))",
          "306:     mutt_debug(1, \"imap_get_mailbox: Error parsing %s\\n\", path);",
          "309:   if (!(*hidata = imap_conn_find(&(mx.account), option(OPT_IMAP_PASSIVE) ? MUTT_IMAP_CONN_NONEW : 0)) ||",
          "310:       (*hidata)->state < IMAP_AUTHENTICATED)",
          "312:     FREE(&mx.mbox);",
          "316:   imap_fix_path(*hidata, mx.mbox, buf, blen);",
          "317:   if (!*buf)",
          "318:     strfcpy(buf, \"INBOX\", blen);",
          "319:   FREE(&mx.mbox);",
          "330: static int do_search(const struct Pattern *search, int allpats)",
          "332:   int rc = 0;",
          "333:   const struct Pattern *pat = NULL;",
          "335:   for (pat = search; pat; pat = pat->next)",
          "337:     switch (pat->op)",
          "339:       case MUTT_BODY:",
          "340:       case MUTT_HEADER:",
          "341:       case MUTT_WHOLE_MSG:",
          "342:         if (pat->stringmatch)",
          "343:           rc++;",
          "344:         break;",
          "345:       case MUTT_SERVERSEARCH:",
          "346:         rc++;",
          "347:         break;",
          "348:       default:",
          "349:         if (pat->child && do_search(pat->child, 1))",
          "350:           rc++;",
          "353:     if (!allpats)",
          "354:       break;",
          "357:   return rc;",
          "358: }",
          "367: static int imap_compile_search(struct Context *ctx, const struct Pattern *pat,",
          "368:                                struct Buffer *buf)",
          "369: {",
          "370:   if (!do_search(pat, 0))",
          "371:     return 0;",
          "373:   if (pat->not)",
          "374:     mutt_buffer_addstr(buf, \"NOT \");",
          "376:   if (pat->child)",
          "378:     int clauses;",
          "380:     clauses = do_search(pat->child, 1);",
          "381:     if (clauses > 0)",
          "383:       const struct Pattern *clause = pat->child;",
          "385:       mutt_buffer_addch(buf, '(');",
          "387:       while (clauses)",
          "388:       {",
          "389:         if (do_search(clause, 0))",
          "390:         {",
          "391:           if (pat->op == MUTT_OR && clauses > 1)",
          "392:             mutt_buffer_addstr(buf, \"OR \");",
          "393:           clauses--;",
          "395:           if (imap_compile_search(ctx, clause, buf) < 0)",
          "396:             return -1;",
          "398:           if (clauses)",
          "399:             mutt_buffer_addch(buf, ' ');",
          "400:         }",
          "401:         clause = clause->next;",
          "402:       }",
          "404:       mutt_buffer_addch(buf, ')');",
          "405:     }",
          "407:   else",
          "409:     char term[STRING];",
          "410:     char *delim = NULL;",
          "412:     switch (pat->op)",
          "414:       case MUTT_HEADER:",
          "415:         mutt_buffer_addstr(buf, \"HEADER \");",
          "418:         delim = strchr(pat->p.str, ':');",
          "419:         if (!delim)",
          "420:         {",
          "421:           mutt_error(_(\"Header search without header name: %s\"), pat->p.str);",
          "422:           return -1;",
          "423:         }",
          "425:         imap_quote_string(term, sizeof(term), pat->p.str);",
          "426:         mutt_buffer_addstr(buf, term);",
          "427:         mutt_buffer_addch(buf, ' ');",
          "431:         delim++;",
          "432:         SKIPWS(delim);",
          "433:         imap_quote_string(term, sizeof(term), delim);",
          "434:         mutt_buffer_addstr(buf, term);",
          "435:         break;",
          "436:       case MUTT_BODY:",
          "437:         mutt_buffer_addstr(buf, \"BODY \");",
          "438:         imap_quote_string(term, sizeof(term), pat->p.str);",
          "439:         mutt_buffer_addstr(buf, term);",
          "440:         break;",
          "441:       case MUTT_WHOLE_MSG:",
          "442:         mutt_buffer_addstr(buf, \"TEXT \");",
          "443:         imap_quote_string(term, sizeof(term), pat->p.str);",
          "444:         mutt_buffer_addstr(buf, term);",
          "445:         break;",
          "446:       case MUTT_SERVERSEARCH:",
          "448:         struct ImapData *idata = ctx->data;",
          "449:         if (!mutt_bit_isset(idata->capabilities, X_GM_EXT1))",
          "451:           mutt_error(_(\"Server-side custom search not supported: %s\"), pat->p.str);",
          "452:           return -1;",
          "455:         mutt_buffer_addstr(buf, \"X-GM-RAW \");",
          "456:         imap_quote_string(term, sizeof(term), pat->p.str);",
          "457:         mutt_buffer_addstr(buf, term);",
          "458:         break;",
          "475: static size_t longest_common_prefix(char *dest, const char *src, size_t start, size_t dlen)",
          "477:   size_t pos = start;",
          "479:   while (pos < dlen && dest[pos] && dest[pos] == src[pos])",
          "480:     pos++;",
          "481:   dest[pos] = '\\0';",
          "483:   return pos;",
          "492: static int imap_complete_hosts(char *dest, size_t len)",
          "494:   struct Buffy *mailbox = NULL;",
          "495:   struct Connection *conn = NULL;",
          "496:   int rc = -1;",
          "497:   size_t matchlen;",
          "499:   matchlen = mutt_strlen(dest);",
          "500:   for (mailbox = Incoming; mailbox; mailbox = mailbox->next)",
          "502:     if (mutt_strncmp(dest, mailbox->path, matchlen) == 0)",
          "503:     {",
          "504:       if (rc)",
          "505:       {",
          "506:         strfcpy(dest, mailbox->path, len);",
          "507:         rc = 0;",
          "508:       }",
          "509:       else",
          "510:         longest_common_prefix(dest, mailbox->path, matchlen, len);",
          "511:     }",
          "514:   TAILQ_FOREACH(conn, mutt_socket_head(), entries)",
          "516:     struct Url url;",
          "517:     char urlstr[LONG_STRING];",
          "519:     if (conn->account.type != MUTT_ACCT_TYPE_IMAP)",
          "520:       continue;",
          "522:     mutt_account_tourl(&conn->account, &url);",
          "524:     url.user = NULL;",
          "525:     url.path = NULL;",
          "526:     url_tostring(&url, urlstr, sizeof(urlstr), 0);",
          "527:     if (mutt_strncmp(dest, urlstr, matchlen) == 0)",
          "528:     {",
          "529:       if (rc)",
          "530:       {",
          "531:         strfcpy(dest, urlstr, len);",
          "532:         rc = 0;",
          "533:       }",
          "534:       else",
          "535:         longest_common_prefix(dest, urlstr, matchlen, len);",
          "536:     }",
          "539:   return rc;",
          "547: int imap_access(const char *path)",
          "550:   struct ImapMbox mx;",
          "552:   char mailbox[LONG_STRING];",
          "553:   char mbox[LONG_STRING];",
          "556:   if (imap_parse_path(path, &mx))",
          "559:   idata = imap_conn_find(&mx.account, option(OPT_IMAP_PASSIVE) ? MUTT_IMAP_CONN_NONEW : 0);",
          "562:     FREE(&mx.mbox);",
          "563:     return -1;",
          "566:   imap_fix_path(idata, mx.mbox, mailbox, sizeof(mailbox));",
          "567:   if (!*mailbox)",
          "568:     strfcpy(mailbox, \"INBOX\", sizeof(mailbox));",
          "571:   if (mutt_strcmp(idata->mailbox, mx.mbox) == 0)",
          "573:     FREE(&mx.mbox);",
          "574:     return 0;",
          "575:   }",
          "576:   FREE(&mx.mbox);",
          "578:   if (imap_mboxcache_get(idata, mailbox, 0))",
          "580:     mutt_debug(3, \"imap_access: found %s in cache\\n\", mailbox);",
          "581:     return 0;",
          "584:   imap_munge_mbox_name(idata, mbox, sizeof(mbox), mailbox);",
          "586:   if (mutt_bit_isset(idata->capabilities, IMAP4REV1))",
          "587:     snprintf(buf, sizeof(buf), \"STATUS %s (UIDVALIDITY)\", mbox);",
          "588:   else if (mutt_bit_isset(idata->capabilities, STATUS))",
          "589:     snprintf(buf, sizeof(buf), \"STATUS %s (UID-VALIDITY)\", mbox);",
          "590:   else",
          "592:     mutt_debug(2, \"imap_access: STATUS not supported?\\n\");",
          "593:     return -1;",
          "596:   rc = imap_exec(idata, buf, IMAP_CMD_FAIL_OK);",
          "597:   if (rc < 0)",
          "599:     mutt_debug(1, \"imap_access: Can't check STATUS of %s\\n\", mbox);",
          "600:     return rc;",
          "603:   return 0;",
          "604: }",
          "606: int imap_create_mailbox(struct ImapData *idata, char *mailbox)",
          "607: {",
          "608:   char buf[LONG_STRING], mbox[LONG_STRING];",
          "610:   imap_munge_mbox_name(idata, mbox, sizeof(mbox), mailbox);",
          "611:   snprintf(buf, sizeof(buf), \"CREATE %s\", mbox);",
          "613:   if (imap_exec(idata, buf, 0) != 0)",
          "615:     mutt_error(_(\"CREATE failed: %s\"), imap_cmd_trailer(idata));",
          "616:     return -1;",
          "622: int imap_rename_mailbox(struct ImapData *idata, struct ImapMbox *mx, const char *newname)",
          "624:   char oldmbox[LONG_STRING];",
          "625:   char newmbox[LONG_STRING];",
          "628:   imap_munge_mbox_name(idata, oldmbox, sizeof(oldmbox), mx->mbox);",
          "629:   imap_munge_mbox_name(idata, newmbox, sizeof(newmbox), newname);",
          "631:   snprintf(buf, sizeof(buf), \"RENAME %s %s\", oldmbox, newmbox);",
          "633:   if (imap_exec(idata, buf, 0) != 0)",
          "639: int imap_delete_mailbox(struct Context *ctx, struct ImapMbox *mx)",
          "641:   char buf[LONG_STRING], mbox[LONG_STRING];",
          "642:   struct ImapData *idata = NULL;",
          "644:   if (!ctx || !ctx->data)",
          "646:     idata = imap_conn_find(&mx->account,",
          "647:                            option(OPT_IMAP_PASSIVE) ? MUTT_IMAP_CONN_NONEW : 0);",
          "648:     if (!idata)",
          "649:     {",
          "650:       FREE(&mx->mbox);",
          "651:       return -1;",
          "652:     }",
          "653:   }",
          "654:   else",
          "655:   {",
          "656:     idata = ctx->data;",
          "659:   imap_munge_mbox_name(idata, mbox, sizeof(mbox), mx->mbox);",
          "660:   snprintf(buf, sizeof(buf), \"DELETE %s\", mbox);",
          "662:   if (imap_exec(idata, buf, 0) != 0)",
          "673: void imap_logout_all(void)",
          "675:   struct ConnectionList *head = mutt_socket_head();",
          "676:   struct Connection *np, *tmp;",
          "677:   TAILQ_FOREACH_SAFE(np, head, entries, tmp)",
          "678:   {",
          "679:     if (np->account.type == MUTT_ACCT_TYPE_IMAP && np->fd >= 0)",
          "680:     {",
          "681:       TAILQ_REMOVE(head, np, entries);",
          "682:       mutt_message(_(\"Closing connection to %s...\"), np->account.host);",
          "683:       imap_logout((struct ImapData **) (void *) &np->data);",
          "684:       mutt_clear_error();",
          "685:       mutt_socket_free(np);",
          "686:     }",
          "687:   }",
          "696: int imap_read_literal(FILE *fp, struct ImapData *idata, long bytes, struct Progress *pbar)",
          "698:   char c;",
          "699:   bool r = false;",
          "701:   mutt_debug(2, \"imap_read_literal: reading %ld bytes\\n\", bytes);",
          "703:   for (long pos = 0; pos < bytes; pos++)",
          "705:     if (mutt_socket_readchar(idata->conn, &c) != 1)",
          "706:     {",
          "707:       mutt_debug(1, \"imap_read_literal: error during read, %ld bytes read\\n\", pos);",
          "708:       idata->status = IMAP_FATAL;",
          "710:       return -1;",
          "711:     }",
          "713:     if (r && c != '\\n')",
          "714:       fputc('\\r', fp);",
          "716:     if (c == '\\r')",
          "717:     {",
          "718:       r = true;",
          "719:       continue;",
          "720:     }",
          "721:     else",
          "722:       r = false;",
          "724:     fputc(c, fp);",
          "726:     if (pbar && !(pos % 1024))",
          "727:       mutt_progress_update(pbar, pos, -1);",
          "728: #ifdef DEBUG",
          "729:     if (debuglevel >= IMAP_LOG_LTRL)",
          "730:       fputc(c, debugfile);",
          "731: #endif",
          "734:   return 0;",
          "744: void imap_expunge_mailbox(struct ImapData *idata)",
          "746:   struct Header *h = NULL;",
          "747:   int cacheno;",
          "748:   short old_sort;",
          "750: #ifdef USE_HCACHE",
          "751:   idata->hcache = imap_hcache_open(idata, NULL);",
          "752: #endif",
          "754:   old_sort = Sort;",
          "755:   Sort = SORT_ORDER;",
          "756:   mutt_sort_headers(idata->ctx, 0);",
          "758:   for (int i = 0; i < idata->ctx->msgcount; i++)",
          "759:   {",
          "760:     h = idata->ctx->hdrs[i];",
          "762:     if (h->index == INT_MAX)",
          "764:       mutt_debug(2, \"Expunging message UID %d.\\n\", HEADER_DATA(h)->uid);",
          "766:       h->active = false;",
          "767:       idata->ctx->size -= h->content->length;",
          "769:       imap_cache_del(idata, h);",
          "770: #ifdef USE_HCACHE",
          "771:       imap_hcache_del(idata, HEADER_DATA(h)->uid);",
          "772: #endif",
          "775:       cacheno = HEADER_DATA(h)->uid % IMAP_CACHE_LEN;",
          "776:       if (idata->cache[cacheno].uid == HEADER_DATA(h)->uid &&",
          "777:           idata->cache[cacheno].path)",
          "779:         unlink(idata->cache[cacheno].path);",
          "780:         FREE(&idata->cache[cacheno].path);",
          "783:       int_hash_delete(idata->uid_hash, HEADER_DATA(h)->uid, h, NULL);",
          "785:       imap_free_header_data((struct ImapHeaderData **) &h->data);",
          "786:     }",
          "787:     else",
          "788:     {",
          "789:       h->index = i;",
          "806:       h->active = true;",
          "807:     }",
          "808:   }",
          "810: #ifdef USE_HCACHE",
          "811:   imap_hcache_close(idata);",
          "812: #endif",
          "816:   mx_update_tables(idata->ctx, false);",
          "817:   Sort = old_sort;",
          "818:   mutt_sort_headers(idata->ctx, 1);",
          "819: }",
          "827: struct ImapData *imap_conn_find(const struct Account *account, int flags)",
          "828: {",
          "829:   struct Connection *conn = NULL;",
          "830:   struct Account *creds = NULL;",
          "831:   struct ImapData *idata = NULL;",
          "832:   bool new = false;",
          "834:   while ((conn = mutt_conn_find(conn, account)))",
          "835:   {",
          "836:     if (!creds)",
          "837:       creds = &conn->account;",
          "838:     else",
          "839:       memcpy(&conn->account, creds, sizeof(struct Account));",
          "841:     idata = conn->data;",
          "842:     if (flags & MUTT_IMAP_CONN_NONEW)",
          "843:     {",
          "844:       if (!idata)",
          "845:       {",
          "847:         mutt_socket_free(conn);",
          "848:         return NULL;",
          "849:       }",
          "850:       else if (idata->state < IMAP_AUTHENTICATED)",
          "851:         continue;",
          "852:     }",
          "853:     if (flags & MUTT_IMAP_CONN_NOSELECT && idata && idata->state >= IMAP_SELECTED)",
          "854:       continue;",
          "855:     if (idata && idata->status == IMAP_FATAL)",
          "856:       continue;",
          "857:     break;",
          "858:   }",
          "859:   if (!conn)",
          "862:   if (!idata)",
          "863:   {",
          "865:     idata = imap_new_idata();",
          "866:     if (!idata)",
          "867:     {",
          "868:       mutt_socket_free(conn);",
          "869:       return NULL;",
          "870:     }",
          "872:     conn->data = idata;",
          "873:     idata->conn = conn;",
          "874:     new = true;",
          "875:   }",
          "877:   if (idata->state == IMAP_DISCONNECTED)",
          "878:     imap_open_connection(idata);",
          "879:   if (idata->state == IMAP_CONNECTED)",
          "880:   {",
          "881:     if (!imap_authenticate(idata))",
          "882:     {",
          "883:       idata->state = IMAP_AUTHENTICATED;",
          "884:       FREE(&idata->capstr);",
          "885:       new = true;",
          "886:       if (idata->conn->ssf)",
          "887:         mutt_debug(2, \"Communication encrypted at %d bits\\n\", idata->conn->ssf);",
          "888:     }",
          "889:     else",
          "890:       mutt_account_unsetpass(&idata->conn->account);",
          "891:   }",
          "892:   if (new && idata->state == IMAP_AUTHENTICATED)",
          "893:   {",
          "895:     imap_exec(idata, \"CAPABILITY\", IMAP_CMD_QUEUE);",
          "897:     if (mutt_bit_isset(idata->capabilities, ENABLE))",
          "898:       imap_exec(idata, \"ENABLE UTF8=ACCEPT\", IMAP_CMD_QUEUE);",
          "900:     idata->delim = '/';",
          "901:     imap_exec(idata, \"LIST \\\"\\\" \\\"\\\"\", IMAP_CMD_QUEUE);",
          "902:     if (option(OPT_IMAP_CHECK_SUBSCRIBED))",
          "903:       imap_exec(idata, \"LSUB \\\"\\\" \\\"*\\\"\", IMAP_CMD_QUEUE);",
          "905:     imap_exec(idata, NULL, IMAP_CMD_FAIL_OK);",
          "906:   }",
          "908:   return idata;",
          "909: }",
          "911: int imap_open_connection(struct ImapData *idata)",
          "912: {",
          "913:   char buf[LONG_STRING];",
          "915:   if (mutt_socket_open(idata->conn) < 0)",
          "916:     return -1;",
          "918:   idata->state = IMAP_CONNECTED;",
          "920:   if (imap_cmd_step(idata) != IMAP_CMD_OK)",
          "921:   {",
          "922:     imap_close_connection(idata);",
          "923:     return -1;",
          "924:   }",
          "926:   if (mutt_strncasecmp(\"* OK\", idata->buf, 4) == 0)",
          "927:   {",
          "928:     if ((mutt_strncasecmp(\"* OK [CAPABILITY\", idata->buf, 16) != 0) &&",
          "929:         imap_check_capabilities(idata))",
          "930:       goto bail;",
          "931: #ifdef USE_SSL",
          "933:     if (!idata->conn->ssf &&",
          "934:         (option(OPT_SSL_FORCE_TLS) || mutt_bit_isset(idata->capabilities, STARTTLS)))",
          "935:     {",
          "936:       int rc;",
          "938:       if (option(OPT_SSL_FORCE_TLS))",
          "939:         rc = MUTT_YES;",
          "940:       else if ((rc = query_quadoption(OPT_SSL_STARTTLS,",
          "941:                                       _(\"Secure connection with TLS?\"))) == MUTT_ABORT)",
          "942:         goto err_close_conn;",
          "943:       if (rc == MUTT_YES)",
          "944:       {",
          "945:         rc = imap_exec(idata, \"STARTTLS\", IMAP_CMD_FAIL_OK);",
          "946:         if (rc == -1)",
          "947:           goto bail;",
          "948:         if (rc != -2)",
          "949:         {",
          "950:           if (mutt_ssl_starttls(idata->conn))",
          "951:           {",
          "952:             mutt_error(_(\"Could not negotiate TLS connection\"));",
          "953:             mutt_sleep(1);",
          "954:             goto err_close_conn;",
          "955:           }",
          "956:           else",
          "957:           {",
          "959:             if (imap_exec(idata, \"CAPABILITY\", 0))",
          "960:               goto bail;",
          "961:           }",
          "962:         }",
          "963:       }",
          "964:     }",
          "966:     if (option(OPT_SSL_FORCE_TLS) && !idata->conn->ssf)",
          "967:     {",
          "968:       mutt_error(_(\"Encrypted connection unavailable\"));",
          "969:       mutt_sleep(1);",
          "970:       goto err_close_conn;",
          "971:     }",
          "972: #endif",
          "973:   }",
          "974:   else if (mutt_strncasecmp(\"* PREAUTH\", idata->buf, 9) == 0)",
          "975:   {",
          "976:     idata->state = IMAP_AUTHENTICATED;",
          "977:     if (imap_check_capabilities(idata) != 0)",
          "978:       goto bail;",
          "979:     FREE(&idata->capstr);",
          "980:   }",
          "981:   else",
          "982:   {",
          "983:     imap_error(\"imap_open_connection()\", buf);",
          "984:     goto bail;",
          "985:   }",
          "987:   return 0;",
          "989: #ifdef USE_SSL",
          "990: err_close_conn:",
          "991:   imap_close_connection(idata);",
          "992: #endif",
          "993: bail:",
          "994:   FREE(&idata->capstr);",
          "995:   return -1;",
          "996: }",
          "998: void imap_close_connection(struct ImapData *idata)",
          "999: {",
          "1000:   if (idata->state != IMAP_DISCONNECTED)",
          "1001:   {",
          "1002:     mutt_socket_close(idata->conn);",
          "1003:     idata->state = IMAP_DISCONNECTED;",
          "1004:   }",
          "1005:   idata->seqno = idata->nextcmd = idata->lastcmd = idata->status = false;",
          "1006:   memset(idata->cmds, 0, sizeof(struct ImapCommand) * idata->cmdslots);",
          "1007: }",
          "1012: void imap_logout(struct ImapData **idata)",
          "1013: {",
          "1016:   (*idata)->status = IMAP_BYE;",
          "1017:   imap_cmd_start(*idata, \"LOGOUT\");",
          "1018:   if (ImapPollTimeout <= 0 || mutt_socket_poll((*idata)->conn, ImapPollTimeout) != 0)",
          "1019:   {",
          "1020:     while (imap_cmd_step(*idata) == IMAP_CMD_CONTINUE)",
          "1021:       ;",
          "1022:   }",
          "1024:   mutt_socket_close((*idata)->conn);",
          "1025:   imap_free_idata(idata);",
          "1026: }",
          "1035: bool imap_has_flag(struct ListHead *flag_list, const char *flag)",
          "1036: {",
          "1037:   if (STAILQ_EMPTY(flag_list))",
          "1038:     return false;",
          "1040:   struct ListNode *np;",
          "1041:   STAILQ_FOREACH(np, flag_list, entries)",
          "1042:   {",
          "1043:     if (mutt_strncasecmp(np->data, flag, strlen(np->data)) == 0)",
          "1044:       return true;",
          "1046:     if (mutt_strncmp(np->data, \"\\\\*\", strlen(np->data)) == 0)",
          "1047:       return true;",
          "1048:   }",
          "1050:   return false;",
          "1051: }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1113:   if (oldsort != Sort)",
          "1114:   {",
          "1115:     Sort = oldsort;",
          "1142: }",
          "",
          "[Removed Lines]",
          "1116:     FREE(&idata->ctx->hdrs);",
          "1117:     idata->ctx->hdrs = hdrs;",
          "1118:   }",
          "1120:   return rc;",
          "1121: }",
          "1128: static bool compare_flags_for_copy(struct Header *h)",
          "1129: {",
          "1130:   struct ImapHeaderData *hd = (struct ImapHeaderData *) h->data;",
          "1132:   if (h->read != hd->read)",
          "1133:     return true;",
          "1134:   if (h->old != hd->old)",
          "1135:     return true;",
          "1136:   if (h->flagged != hd->flagged)",
          "1137:     return true;",
          "1138:   if (h->replied != hd->replied)",
          "1139:     return true;",
          "1141:   return false;",
          "",
          "[Added Lines]",
          "1126:     FREE(&idata->ctx->hdrs);",
          "1127:     idata->ctx->hdrs = hdrs;",
          "1128:   }",
          "1130:   return rc;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1245:   return 0;",
          "1246: }",
          "1249: {",
          "1276: }",
          "1286: {",
          "1293:   {",
          "1296:   }",
          "1322:   {",
          "1337:     {",
          "1341:     }",
          "1357: }",
          "1378: {",
          "1379:   struct ImapData *idata = NULL;",
          "1398:     {",
          "1401:     }",
          "1413:     {",
          "1416:     }",
          "1426:     {",
          "1429:     }",
          "1438:     {",
          "1442:     }",
          "1445:   }",
          "1453: }",
          "1463: {",
          "1476:     return -1;",
          "1489:   {",
          "1507:   }",
          "1515:   {",
          "1550: #ifdef USE_HCACHE",
          "1552: #endif",
          "1557:   {",
          "1564:   }",
          "1577:   {",
          "1581:   }",
          "1589:   {",
          "1591:     {",
          "1593:       {",
          "1631:     }",
          "1639:   }",
          "1648:   {",
          "1651:   }",
          "1653: }",
          "1659: {",
          "1665:     return 0;",
          "1676:   {",
          "1706:   }",
          "1710:   {",
          "1714:   }",
          "1716:   return 0;",
          "1717: }",
          "1734: {",
          "1742:   {",
          "1745:   }",
          "1747:   {",
          "1761:   }",
          "1793: }",
          "1799: {",
          "1800:   struct ImapMbox mx;",
          "1803:   {",
          "1805:     return -1;",
          "1806:   }",
          "1809:   {",
          "1812:   }",
          "1840:   {",
          "1843:     {",
          "1846:     }",
          "1852:     {",
          "1855:     }",
          "1862:     {",
          "1865:     }",
          "1869:     {",
          "1872:     }",
          "1903:   {",
          "1906:   }",
          "1946:   {",
          "1950:   }",
          "1951:   else",
          "1957:   {",
          "1961:   }",
          "1988:   {",
          "1993:   }",
          "1998:   {",
          "2004:   }",
          "2009:   {",
          "2013:     {",
          "2015:       {",
          "2020:       }",
          "2025:     }",
          "2029:   }",
          "2030: #endif",
          "2033: }",
          "2036: {",
          "2041:   {",
          "2044:   }",
          "2083: }",
          "2094: {",
          "2102:   {",
          "2107:     {",
          "2130:     }",
          "2172:       {",
          "2179:       }",
          "2184:     }",
          "2185:   }",
          "2187:   return 0;",
          "2188: }",
          "2191: {",
          "2208:   {",
          "2210:     return -1;",
          "2211:   }",
          "2214:   return 0;",
          "2215: }",
          "2218: {",
          "2219:   struct ImapData *idata = NULL;",
          "2227:   {",
          "2229:     return -1;",
          "2230:   }",
          "2240:   {",
          "2311:   {",
          "2313:     {",
          "2315:       {",
          "2317:         rc = 0;",
          "2318:       }",
          "2321:     }",
          "2322:   }",
          "2325:   {",
          "2338:     {",
          "2346:     }",
          "2347:   }",
          "2349:   return rc;",
          "2350: }",
          "2359: {",
          "2385:   }",
          "2405:   {",
          "2410:     {",
          "2430:     }",
          "2442:   }",
          "2445: }",
          "2454: {",
          "2455:   struct ImapData *idata = NULL;",
          "2465:   idata = ctx->data;",
          "2487:   {",
          "2490:     {",
          "2497:     }",
          "2505:     {",
          "2509:     }",
          "2511:     {",
          "2514:     }",
          "2521:     {",
          "2540:     }",
          "2547:   }",
          "2556: }",
          "2558: struct MxOps mx_imap_ops = {",
          "",
          "[Removed Lines]",
          "1248: static int sync_helper(struct ImapData *idata, int right, int flag, const char *name)",
          "1250:   int count = 0;",
          "1251:   int rc;",
          "1252:   char buf[LONG_STRING];",
          "1254:   if (!idata->ctx)",
          "1255:     return -1;",
          "1257:   if (!mutt_bit_isset(idata->ctx->rights, right))",
          "1258:     return 0;",
          "1260:   if (right == MUTT_ACL_WRITE && !imap_has_flag(&idata->flags, name))",
          "1261:     return 0;",
          "1263:   snprintf(buf, sizeof(buf), \"+FLAGS.SILENT (%s)\", name);",
          "1264:   rc = imap_exec_msgset(idata, \"UID STORE\", buf, flag, 1, 0);",
          "1265:   if (rc < 0)",
          "1266:     return rc;",
          "1267:   count += rc;",
          "1269:   buf[0] = '-';",
          "1270:   rc = imap_exec_msgset(idata, \"UID STORE\", buf, flag, 1, 1);",
          "1271:   if (rc < 0)",
          "1272:     return rc;",
          "1273:   count += rc;",
          "1275:   return count;",
          "1285: static int imap_edit_message_tags(struct Context *ctx, const char *tags, char *buf, size_t buflen)",
          "1287:   char *new = NULL;",
          "1288:   char *checker = NULL;",
          "1289:   struct ImapData *idata = (struct ImapData *) ctx->data;",
          "1292:   if (!imap_has_flag(&idata->flags, NULL))",
          "1294:     mutt_error(_(\"IMAP server doesn't support custom flags\"));",
          "1295:     return -1;",
          "1299:   if (tags)",
          "1300:     strncpy(buf, tags, buflen);",
          "1302:   if (mutt_get_field(\"Tags: \", buf, buflen, 0) != 0)",
          "1303:     return -1;",
          "1318:   new = buf;",
          "1319:   checker = buf;",
          "1320:   SKIPWS(checker);",
          "1321:   while (*checker != '\\0')",
          "1323:     if (*checker < 32 || *checker >= 127 || // We allow space because it's the separator",
          "1338:       mutt_error(_(\"Invalid IMAP flags\"));",
          "1339:       mutt_sleep(2);",
          "1340:       return 0;",
          "1344:     while (*checker == ' ' && *(checker + 1) == ' ')",
          "1345:       checker++;",
          "1349:   }",
          "1352:   mutt_remove_trailing_ws(new);",
          "1354:   if (mutt_strcmp(tags, buf) == 0)",
          "1355:     return 0;",
          "1356:   return 1;",
          "1377: static int imap_commit_message_tags(struct Context *ctx, struct Header *h, char *tags)",
          "1380:   struct Buffer *cmd = NULL;",
          "1381:   char uid[11];",
          "1383:   idata = ctx->data;",
          "1385:   if (*tags == '\\0')",
          "1386:     tags = NULL;",
          "1388:   if (!mutt_bit_isset(idata->ctx->rights, MUTT_ACL_WRITE))",
          "1389:     return 0;",
          "1391:   snprintf(uid, sizeof(uid), \"%u\", HEADER_DATA(h)->uid);",
          "1394:   if (HEADER_DATA(h)->flags_remote)",
          "1395:   {",
          "1396:     cmd = mutt_buffer_new();",
          "1397:     if (!cmd)",
          "1399:       mutt_debug(1, \"imap_commit_message_tags: unable to allocate buffer\\n\");",
          "1400:       return -1;",
          "1402:     cmd->dptr = cmd->data;",
          "1403:     mutt_buffer_addstr(cmd, \"UID STORE \");",
          "1404:     mutt_buffer_addstr(cmd, uid);",
          "1405:     mutt_buffer_addstr(cmd, \" -FLAGS.SILENT (\");",
          "1406:     mutt_buffer_addstr(cmd, HEADER_DATA(h)->flags_remote);",
          "1407:     mutt_buffer_addstr(cmd, \")\");",
          "1412:     if (imap_exec(idata, cmd->data, 0) != 0)",
          "1414:       mutt_buffer_free(&cmd);",
          "1415:       return -1;",
          "1418:     mutt_buffer_free(&cmd);",
          "1419:   }",
          "1422:   if (tags)",
          "1423:   {",
          "1424:     cmd = mutt_buffer_new();",
          "1425:     if (!cmd)",
          "1427:       mutt_debug(1, \"imap_commit_message_tags: fail to remove old flags\\n\");",
          "1428:       return -1;",
          "1430:     cmd->dptr = cmd->data;",
          "1431:     mutt_buffer_addstr(cmd, \"UID STORE \");",
          "1432:     mutt_buffer_addstr(cmd, uid);",
          "1433:     mutt_buffer_addstr(cmd, \" +FLAGS.SILENT (\");",
          "1434:     mutt_buffer_addstr(cmd, tags);",
          "1435:     mutt_buffer_addstr(cmd, \")\");",
          "1437:     if (imap_exec(idata, cmd->data, 0) != 0)",
          "1439:       mutt_debug(1, \"imap_commit_message_tags: fail to add new flags\\n\");",
          "1440:       mutt_buffer_free(&cmd);",
          "1441:       return -1;",
          "1444:     mutt_buffer_free(&cmd);",
          "1448:   mutt_debug(1, \"NEW TAGS: %d\\n\", tags);",
          "1449:   driver_tags_replace(&h->tags, tags);",
          "1450:   FREE(&HEADER_DATA(h)->flags_remote);",
          "1451:   HEADER_DATA(h)->flags_remote = driver_tags_get_with_hidden(&h->tags);",
          "1452:   return 0;",
          "1462: int imap_sync_mailbox(struct Context *ctx, int expunge)",
          "1464:   struct ImapData *idata = NULL;",
          "1465:   struct Context *appendctx = NULL;",
          "1466:   struct Header *h = NULL;",
          "1467:   struct Header **hdrs = NULL;",
          "1468:   int oldsort;",
          "1469:   int rc;",
          "1471:   idata = ctx->data;",
          "1473:   if (idata->state < IMAP_SELECTED)",
          "1474:   {",
          "1475:     mutt_debug(2, \"imap_sync_mailbox: no mailbox selected\\n\");",
          "1477:   }",
          "1481:   imap_allow_reopen(ctx);",
          "1483:   rc = imap_check(idata, 0);",
          "1484:   if (rc != 0)",
          "1485:     return rc;",
          "1488:   if (expunge && mutt_bit_isset(ctx->rights, MUTT_ACL_DELETE))",
          "1490:     if ((rc = imap_exec_msgset(idata, \"UID STORE\", \"+FLAGS.SILENT (\\\\Deleted)\",",
          "1491:                                MUTT_DELETED, 1, 0)) < 0)",
          "1492:     {",
          "1493:       mutt_error(_(\"Expunge failed\"));",
          "1494:       mutt_sleep(1);",
          "1495:       goto out;",
          "1496:     }",
          "1498:     if (rc > 0)",
          "1499:     {",
          "1502:       for (int i = 0; i < ctx->msgcount; i++)",
          "1503:         if (ctx->hdrs[i]->deleted && ctx->hdrs[i]->changed)",
          "1504:           ctx->hdrs[i]->active = false;",
          "1505:       mutt_message(_(\"Marking %d messages deleted...\"), rc);",
          "1506:     }",
          "1509: #ifdef USE_HCACHE",
          "1510:   idata->hcache = imap_hcache_open(idata, NULL);",
          "1511: #endif",
          "1514:   for (int i = 0; i < ctx->msgcount; i++)",
          "1516:     h = ctx->hdrs[i];",
          "1518:     if (h->deleted)",
          "1519:     {",
          "1520:       imap_cache_del(idata, h);",
          "1521: #ifdef USE_HCACHE",
          "1522:       imap_hcache_del(idata, HEADER_DATA(h)->uid);",
          "1523: #endif",
          "1524:     }",
          "1526:     if (h->active && h->changed)",
          "1527:     {",
          "1528: #ifdef USE_HCACHE",
          "1529:       imap_hcache_put(idata, h);",
          "1530: #endif",
          "1534:       if ((h->env && (h->env->refs_changed || h->env->irt_changed)) ||",
          "1535:           h->attach_del || h->xlabel_changed)",
          "1536:       {",
          "1537:         mutt_message(_(\"Saving changed messages... [%d/%d]\"), i + 1, ctx->msgcount);",
          "1538:         if (!appendctx)",
          "1539:           appendctx = mx_open_mailbox(ctx->path, MUTT_APPEND | MUTT_QUIET, NULL);",
          "1540:         if (!appendctx)",
          "1541:           mutt_debug(",
          "1542:               1, \"imap_sync_mailbox: Error opening mailbox in append mode\\n\");",
          "1543:         else",
          "1544:           _mutt_save_message(h, appendctx, 1, 0, 0);",
          "1545:         h->xlabel_changed = false;",
          "1546:       }",
          "1547:     }",
          "1548:   }",
          "1551:   imap_hcache_close(idata);",
          "1555:   oldsort = Sort;",
          "1556:   if (Sort != SORT_ORDER)",
          "1558:     hdrs = ctx->hdrs;",
          "1559:     ctx->hdrs = safe_malloc(ctx->msgcount * sizeof(struct Header *));",
          "1560:     memcpy(ctx->hdrs, hdrs, ctx->msgcount * sizeof(struct Header *));",
          "1562:     Sort = SORT_ORDER;",
          "1563:     qsort(ctx->hdrs, ctx->msgcount, sizeof(struct Header *), mutt_get_sort_func(SORT_ORDER));",
          "1566:   rc = sync_helper(idata, MUTT_ACL_DELETE, MUTT_DELETED, \"\\\\Deleted\");",
          "1567:   if (rc >= 0)",
          "1568:     rc |= sync_helper(idata, MUTT_ACL_WRITE, MUTT_FLAG, \"\\\\Flagged\");",
          "1569:   if (rc >= 0)",
          "1570:     rc |= sync_helper(idata, MUTT_ACL_WRITE, MUTT_OLD, \"Old\");",
          "1571:   if (rc >= 0)",
          "1572:     rc |= sync_helper(idata, MUTT_ACL_SEEN, MUTT_READ, \"\\\\Seen\");",
          "1573:   if (rc >= 0)",
          "1574:     rc |= sync_helper(idata, MUTT_ACL_WRITE, MUTT_REPLIED, \"\\\\Answered\");",
          "1576:   if (oldsort != Sort)",
          "1578:     Sort = oldsort;",
          "1579:     FREE(&ctx->hdrs);",
          "1580:     ctx->hdrs = hdrs;",
          "1584:   if (rc > 0)",
          "1585:     if (imap_exec(idata, NULL, 0) != IMAP_CMD_OK)",
          "1586:       rc = -1;",
          "1588:   if (rc < 0)",
          "1590:     if (ctx->closing)",
          "1592:       if (mutt_yesorno(_(\"Error saving flags. Close anyway?\"), 0) == MUTT_YES)",
          "1594:         rc = 0;",
          "1595:         idata->state = IMAP_AUTHENTICATED;",
          "1596:         goto out;",
          "1597:       }",
          "1598:     }",
          "1599:     else",
          "1600:       mutt_error(_(\"Error saving flags\"));",
          "1601:     rc = -1;",
          "1602:     goto out;",
          "1603:   }",
          "1608:   for (int i = 0; i < ctx->msgcount; i++)",
          "1609:   {",
          "1610:     HEADER_DATA(ctx->hdrs[i])->deleted = ctx->hdrs[i]->deleted;",
          "1611:     HEADER_DATA(ctx->hdrs[i])->flagged = ctx->hdrs[i]->flagged;",
          "1612:     HEADER_DATA(ctx->hdrs[i])->old = ctx->hdrs[i]->old;",
          "1613:     HEADER_DATA(ctx->hdrs[i])->read = ctx->hdrs[i]->read;",
          "1614:     HEADER_DATA(ctx->hdrs[i])->replied = ctx->hdrs[i]->replied;",
          "1615:     ctx->hdrs[i]->changed = false;",
          "1616:   }",
          "1617:   ctx->changed = false;",
          "1620:   if (expunge && !(ctx->closing) && mutt_bit_isset(ctx->rights, MUTT_ACL_DELETE))",
          "1621:   {",
          "1622:     mutt_message(_(\"Expunging messages from server...\"));",
          "1624:     idata->reopen |= IMAP_EXPUNGE_EXPECTED;",
          "1625:     if (imap_exec(idata, \"EXPUNGE\", 0) != 0)",
          "1626:     {",
          "1627:       idata->reopen &= ~IMAP_EXPUNGE_EXPECTED;",
          "1628:       imap_error(_(\"imap_sync_mailbox: EXPUNGE failed\"), idata->buf);",
          "1629:       rc = -1;",
          "1630:       goto out;",
          "1632:     idata->reopen &= ~IMAP_EXPUNGE_EXPECTED;",
          "1633:   }",
          "1635:   if (expunge && ctx->closing)",
          "1636:   {",
          "1637:     imap_exec(idata, \"CLOSE\", IMAP_CMD_QUEUE);",
          "1638:     idata->state = IMAP_AUTHENTICATED;",
          "1641:   if (option(OPT_MESSAGE_CACHE_CLEAN))",
          "1642:     imap_cache_clean(idata);",
          "1644:   rc = 0;",
          "1646: out:",
          "1647:   if (appendctx)",
          "1649:     mx_fastclose_mailbox(appendctx);",
          "1650:     FREE(&appendctx);",
          "1652:   return rc;",
          "1658: int imap_close_mailbox(struct Context *ctx)",
          "1660:   struct ImapData *idata = NULL;",
          "1662:   idata = ctx->data;",
          "1664:   if (!idata)",
          "1675:   if (ctx == idata->ctx)",
          "1677:     if (idata->status != IMAP_FATAL && idata->state >= IMAP_SELECTED)",
          "1678:     {",
          "1681:       if (!ctx->deleted)",
          "1682:         imap_exec(idata, \"CLOSE\", IMAP_CMD_QUEUE);",
          "1683:       idata->state = IMAP_AUTHENTICATED;",
          "1684:     }",
          "1686:     idata->reopen &= IMAP_REOPEN_ALLOW;",
          "1687:     FREE(&(idata->mailbox));",
          "1688:     mutt_list_free(&idata->flags);",
          "1689:     idata->ctx = NULL;",
          "1691:     hash_destroy(&idata->uid_hash, NULL);",
          "1692:     FREE(&idata->msn_index);",
          "1693:     idata->msn_index_size = 0;",
          "1694:     idata->max_msn = 0;",
          "1696:     for (int i = 0; i < IMAP_CACHE_LEN; i++)",
          "1697:     {",
          "1698:       if (idata->cache[i].path)",
          "1699:       {",
          "1700:         unlink(idata->cache[i].path);",
          "1701:         FREE(&idata->cache[i].path);",
          "1702:       }",
          "1703:     }",
          "1705:     mutt_bcache_close(&idata->bcache);",
          "1709:   for (int i = 0; i < ctx->msgcount; i++)",
          "1712:     if (ctx->hdrs[i] && ctx->hdrs[i]->data)",
          "1713:       imap_free_header_data((struct ImapHeaderData **) &(ctx->hdrs[i]->data));",
          "1728: int imap_check_mailbox(struct Context *ctx, int force)",
          "1729: {",
          "1730:   return imap_check(ctx->data, force);",
          "1731: }",
          "1733: int imap_check(struct ImapData *idata, int force)",
          "1737:   int result = 0;",
          "1740:   if (!force && option(OPT_IMAP_IDLE) && mutt_bit_isset(idata->capabilities, IDLE) &&",
          "1741:       (idata->state != IMAP_IDLE || time(NULL) >= idata->lastread + ImapKeepalive))",
          "1743:     if (imap_cmd_idle(idata) < 0)",
          "1744:       return -1;",
          "1746:   if (idata->state == IMAP_IDLE)",
          "1748:     while ((result = mutt_socket_poll(idata->conn, 0)) > 0)",
          "1749:     {",
          "1750:       if (imap_cmd_step(idata) != IMAP_CMD_CONTINUE)",
          "1751:       {",
          "1752:         mutt_debug(1, \"Error reading IDLE response\\n\");",
          "1753:         return -1;",
          "1754:       }",
          "1755:     }",
          "1756:     if (result < 0)",
          "1757:     {",
          "1758:       mutt_debug(1, \"Poll failed, disabling IDLE\\n\");",
          "1759:       mutt_bit_unset(idata->capabilities, IDLE);",
          "1760:     }",
          "1763:   if ((force || (idata->state != IMAP_IDLE && time(NULL) >= idata->lastread + Timeout)) &&",
          "1764:       imap_exec(idata, \"NOOP\", IMAP_CMD_POLL) != 0)",
          "1765:     return -1;",
          "1769:   imap_cmd_finish(idata);",
          "1771:   if (idata->check_status & IMAP_EXPUNGE_PENDING)",
          "1772:     result = MUTT_REOPENED;",
          "1773:   else if (idata->check_status & IMAP_NEWMAIL_PENDING)",
          "1774:     result = MUTT_NEW_MAIL;",
          "1775:   else if (idata->check_status & IMAP_FLAGS_PENDING)",
          "1776:     result = MUTT_FLAGS;",
          "1778:   idata->check_status = 0;",
          "1780:   return result;",
          "1781: }",
          "1783: static int imap_check_mailbox_reopen(struct Context *ctx, int *index_hint)",
          "1784: {",
          "1785:   int rc;",
          "1786:   (void) index_hint;",
          "1788:   imap_allow_reopen(ctx);",
          "1789:   rc = imap_check(ctx->data, 0);",
          "1790:   imap_disallow_reopen(ctx);",
          "1792:   return rc;",
          "1798: static int imap_get_mailbox(const char *path, struct ImapData **hidata, char *buf, size_t blen)",
          "1802:   if (imap_parse_path(path, &mx))",
          "1804:     mutt_debug(1, \"imap_get_mailbox: Error parsing %s\\n\", path);",
          "1807:   if (!(*hidata = imap_conn_find(&(mx.account), option(OPT_IMAP_PASSIVE) ? MUTT_IMAP_CONN_NONEW : 0)) ||",
          "1808:       (*hidata)->state < IMAP_AUTHENTICATED)",
          "1810:     FREE(&mx.mbox);",
          "1811:     return -1;",
          "1814:   imap_fix_path(*hidata, mx.mbox, buf, blen);",
          "1815:   if (!*buf)",
          "1816:     strfcpy(buf, \"INBOX\", blen);",
          "1817:   FREE(&mx.mbox);",
          "1819:   return 0;",
          "1820: }",
          "1829: int imap_buffy_check(int force, int check_stats)",
          "1830: {",
          "1831:   struct ImapData *idata = NULL;",
          "1832:   struct ImapData *lastdata = NULL;",
          "1833:   struct Buffy *mailbox = NULL;",
          "1834:   char name[LONG_STRING];",
          "1835:   char command[LONG_STRING];",
          "1836:   char munged[LONG_STRING];",
          "1837:   int buffies = 0;",
          "1839:   for (mailbox = Incoming; mailbox; mailbox = mailbox->next)",
          "1842:     if (!mailbox->magic)",
          "1844:       if (mx_is_imap(mailbox->path))",
          "1845:         mailbox->magic = MUTT_IMAP;",
          "1848:     if (mailbox->magic != MUTT_IMAP)",
          "1849:       continue;",
          "1851:     if (imap_get_mailbox(mailbox->path, &idata, name, sizeof(name)) < 0)",
          "1853:       mailbox->new = false;",
          "1854:       continue;",
          "1861:     if (idata->mailbox && (imap_mxcmp(name, idata->mailbox) == 0))",
          "1863:       mailbox->new = false;",
          "1864:       continue;",
          "1867:     if (!mutt_bit_isset(idata->capabilities, IMAP4REV1) &&",
          "1868:         !mutt_bit_isset(idata->capabilities, STATUS))",
          "1870:       mutt_debug(2, \"Server doesn't support STATUS\\n\");",
          "1871:       continue;",
          "1874:     if (lastdata && idata != lastdata)",
          "1875:     {",
          "1878:       if (imap_exec(lastdata, NULL, IMAP_CMD_FAIL_OK | IMAP_CMD_POLL) == -1)",
          "1879:         mutt_debug(1, \"Error polling mailboxes\\n\");",
          "1881:       lastdata = NULL;",
          "1882:     }",
          "1884:     if (!lastdata)",
          "1885:       lastdata = idata;",
          "1887:     imap_munge_mbox_name(idata, munged, sizeof(munged), name);",
          "1888:     if (check_stats)",
          "1889:       snprintf(command, sizeof(command),",
          "1890:                \"STATUS %s (UIDNEXT UIDVALIDITY UNSEEN RECENT MESSAGES)\", munged);",
          "1891:     else",
          "1892:       snprintf(command, sizeof(command),",
          "1893:                \"STATUS %s (UIDNEXT UIDVALIDITY UNSEEN RECENT)\", munged);",
          "1895:     if (imap_exec(idata, command, IMAP_CMD_QUEUE | IMAP_CMD_POLL) < 0)",
          "1896:     {",
          "1897:       mutt_debug(1, \"Error queueing command\\n\");",
          "1898:       return 0;",
          "1899:     }",
          "1900:   }",
          "1902:   if (lastdata && (imap_exec(lastdata, NULL, IMAP_CMD_FAIL_OK | IMAP_CMD_POLL) == -1))",
          "1904:     mutt_debug(1, \"Error polling mailboxes\\n\");",
          "1905:     return 0;",
          "1909:   for (mailbox = Incoming; mailbox; mailbox = mailbox->next)",
          "1910:   {",
          "1911:     if (mailbox->magic == MUTT_IMAP && mailbox->new)",
          "1912:       buffies++;",
          "1913:   }",
          "1915:   return buffies;",
          "1916: }",
          "1926: int imap_status(char *path, int queue)",
          "1927: {",
          "1928:   static int queued = 0;",
          "1930:   struct ImapData *idata = NULL;",
          "1931:   char buf[LONG_STRING];",
          "1932:   char mbox[LONG_STRING];",
          "1933:   struct ImapStatus *status = NULL;",
          "1935:   if (imap_get_mailbox(path, &idata, buf, sizeof(buf)) < 0)",
          "1936:     return -1;",
          "1942:   if (idata->ctx && !imap_mxcmp(buf, idata->mailbox))",
          "1943:     return idata->ctx->msgcount;",
          "1944:   else if (mutt_bit_isset(idata->capabilities, IMAP4REV1) ||",
          "1945:            mutt_bit_isset(idata->capabilities, STATUS))",
          "1947:     imap_munge_mbox_name(idata, mbox, sizeof(mbox), buf);",
          "1948:     snprintf(buf, sizeof(buf), \"STATUS %s (%s)\", mbox, \"MESSAGES\");",
          "1949:     imap_unmunge_mbox_name(idata, mbox);",
          "1954:     return -1;",
          "1956:   if (queue)",
          "1958:     imap_exec(idata, buf, IMAP_CMD_QUEUE);",
          "1959:     queued = 1;",
          "1960:     return 0;",
          "1962:   else if (!queued)",
          "1963:     imap_exec(idata, buf, 0);",
          "1965:   queued = 0;",
          "1966:   if ((status = imap_mboxcache_get(idata, mbox, 0)))",
          "1967:     return status->messages;",
          "1969:   return 0;",
          "1970: }",
          "1977: struct ImapStatus *imap_mboxcache_get(struct ImapData *idata, const char *mbox, int create)",
          "1978: {",
          "1979:   struct ImapStatus *status = NULL;",
          "1980: #ifdef USE_HCACHE",
          "1981:   header_cache_t *hc = NULL;",
          "1982:   void *uidvalidity = NULL;",
          "1983:   void *uidnext = NULL;",
          "1984: #endif",
          "1986:   struct ListNode *np;",
          "1987:   STAILQ_FOREACH(np, &idata->mboxcache, entries)",
          "1989:     status = (struct ImapStatus *) np->data;",
          "1991:     if (imap_mxcmp(mbox, status->name) == 0)",
          "1992:       return status;",
          "1994:   status = NULL;",
          "1997:   if (create)",
          "1999:     struct ImapStatus *scache = safe_calloc(1, sizeof(struct ImapStatus));",
          "2000:     scache->name = (char *) mbox;",
          "2001:     mutt_list_insert_tail(&idata->mboxcache, (char *) scache);",
          "2002:     status = imap_mboxcache_get(idata, mbox, 0);",
          "2003:     status->name = safe_strdup(mbox);",
          "2006: #ifdef USE_HCACHE",
          "2007:   hc = imap_hcache_open(idata, mbox);",
          "2008:   if (hc)",
          "2010:     uidvalidity = mutt_hcache_fetch_raw(hc, \"/UIDVALIDITY\", 12);",
          "2011:     uidnext = mutt_hcache_fetch_raw(hc, \"/UIDNEXT\", 8);",
          "2012:     if (uidvalidity)",
          "2014:       if (!status)",
          "2016:         mutt_hcache_free(hc, &uidvalidity);",
          "2017:         mutt_hcache_free(hc, &uidnext);",
          "2018:         mutt_hcache_close(hc);",
          "2019:         return imap_mboxcache_get(idata, mbox, 1);",
          "2021:       status->uidvalidity = *(unsigned int *) uidvalidity;",
          "2022:       status->uidnext = uidnext ? *(unsigned int *) uidnext : 0;",
          "2023:       mutt_debug(3, \"mboxcache: hcache uidvalidity %d, uidnext %d\\n\",",
          "2024:                  status->uidvalidity, status->uidnext);",
          "2026:     mutt_hcache_free(hc, &uidvalidity);",
          "2027:     mutt_hcache_free(hc, &uidnext);",
          "2028:     mutt_hcache_close(hc);",
          "2032:   return status;",
          "2035: void imap_mboxcache_free(struct ImapData *idata)",
          "2037:   struct ImapStatus *status = NULL;",
          "2039:   struct ListNode *np;",
          "2040:   STAILQ_FOREACH(np, &idata->mboxcache, entries)",
          "2042:     status = (struct ImapStatus *) np->data;",
          "2043:     FREE(&status->name);",
          "2046:   mutt_list_free(&idata->mboxcache);",
          "2047: }",
          "2055: static int do_search(const struct Pattern *search, int allpats)",
          "2056: {",
          "2057:   int rc = 0;",
          "2058:   const struct Pattern *pat = NULL;",
          "2060:   for (pat = search; pat; pat = pat->next)",
          "2061:   {",
          "2062:     switch (pat->op)",
          "2063:     {",
          "2064:       case MUTT_BODY:",
          "2065:       case MUTT_HEADER:",
          "2066:       case MUTT_WHOLE_MSG:",
          "2067:         if (pat->stringmatch)",
          "2068:           rc++;",
          "2069:         break;",
          "2070:       case MUTT_SERVERSEARCH:",
          "2071:         rc++;",
          "2072:         break;",
          "2073:       default:",
          "2074:         if (pat->child && do_search(pat->child, 1))",
          "2075:           rc++;",
          "2076:     }",
          "2078:     if (!allpats)",
          "2079:       break;",
          "2080:   }",
          "2082:   return rc;",
          "2092: static int imap_compile_search(struct Context *ctx, const struct Pattern *pat,",
          "2093:                                struct Buffer *buf)",
          "2095:   if (!do_search(pat, 0))",
          "2096:     return 0;",
          "2098:   if (pat->not)",
          "2099:     mutt_buffer_addstr(buf, \"NOT \");",
          "2101:   if (pat->child)",
          "2103:     int clauses;",
          "2105:     clauses = do_search(pat->child, 1);",
          "2106:     if (clauses > 0)",
          "2108:       const struct Pattern *clause = pat->child;",
          "2110:       mutt_buffer_addch(buf, '(');",
          "2112:       while (clauses)",
          "2113:       {",
          "2114:         if (do_search(clause, 0))",
          "2115:         {",
          "2116:           if (pat->op == MUTT_OR && clauses > 1)",
          "2117:             mutt_buffer_addstr(buf, \"OR \");",
          "2118:           clauses--;",
          "2120:           if (imap_compile_search(ctx, clause, buf) < 0)",
          "2121:             return -1;",
          "2123:           if (clauses)",
          "2124:             mutt_buffer_addch(buf, ' ');",
          "2125:         }",
          "2126:         clause = clause->next;",
          "2127:       }",
          "2129:       mutt_buffer_addch(buf, ')');",
          "2131:   }",
          "2132:   else",
          "2133:   {",
          "2134:     char term[STRING];",
          "2135:     char *delim = NULL;",
          "2137:     switch (pat->op)",
          "2138:     {",
          "2139:       case MUTT_HEADER:",
          "2140:         mutt_buffer_addstr(buf, \"HEADER \");",
          "2143:         delim = strchr(pat->p.str, ':');",
          "2144:         if (!delim)",
          "2145:         {",
          "2146:           mutt_error(_(\"Header search without header name: %s\"), pat->p.str);",
          "2147:           return -1;",
          "2148:         }",
          "2150:         imap_quote_string(term, sizeof(term), pat->p.str);",
          "2151:         mutt_buffer_addstr(buf, term);",
          "2152:         mutt_buffer_addch(buf, ' ');",
          "2156:         delim++;",
          "2157:         SKIPWS(delim);",
          "2158:         imap_quote_string(term, sizeof(term), delim);",
          "2159:         mutt_buffer_addstr(buf, term);",
          "2160:         break;",
          "2161:       case MUTT_BODY:",
          "2162:         mutt_buffer_addstr(buf, \"BODY \");",
          "2163:         imap_quote_string(term, sizeof(term), pat->p.str);",
          "2164:         mutt_buffer_addstr(buf, term);",
          "2165:         break;",
          "2166:       case MUTT_WHOLE_MSG:",
          "2167:         mutt_buffer_addstr(buf, \"TEXT \");",
          "2168:         imap_quote_string(term, sizeof(term), pat->p.str);",
          "2169:         mutt_buffer_addstr(buf, term);",
          "2170:         break;",
          "2171:       case MUTT_SERVERSEARCH:",
          "2173:         struct ImapData *idata = ctx->data;",
          "2174:         if (!mutt_bit_isset(idata->capabilities, X_GM_EXT1))",
          "2175:         {",
          "2176:           mutt_error(_(\"Server-side custom search not supported: %s\"), pat->p.str);",
          "2177:           return -1;",
          "2178:         }",
          "2180:         mutt_buffer_addstr(buf, \"X-GM-RAW \");",
          "2181:         imap_quote_string(term, sizeof(term), pat->p.str);",
          "2182:         mutt_buffer_addstr(buf, term);",
          "2183:         break;",
          "2190: int imap_search(struct Context *ctx, const struct Pattern *pat)",
          "2192:   struct Buffer buf;",
          "2193:   struct ImapData *idata = ctx->data;",
          "2194:   for (int i = 0; i < ctx->msgcount; i++)",
          "2195:     ctx->hdrs[i]->matched = false;",
          "2197:   if (!do_search(pat, 1))",
          "2198:     return 0;",
          "2200:   mutt_buffer_init(&buf);",
          "2201:   mutt_buffer_addstr(&buf, \"UID SEARCH \");",
          "2202:   if (imap_compile_search(ctx, pat, &buf) < 0)",
          "2203:   {",
          "2204:     FREE(&buf.data);",
          "2205:     return -1;",
          "2206:   }",
          "2207:   if (imap_exec(idata, buf.data, 0) < 0)",
          "2209:     FREE(&buf.data);",
          "2213:   FREE(&buf.data);",
          "2217: int imap_subscribe(char *path, int subscribe)",
          "2220:   char buf[LONG_STRING];",
          "2221:   char mbox[LONG_STRING];",
          "2222:   char errstr[STRING];",
          "2223:   struct Buffer err, token;",
          "2224:   struct ImapMbox mx;",
          "2226:   if (!mx_is_imap(path) || imap_parse_path(path, &mx) || !mx.mbox)",
          "2228:     mutt_error(_(\"Bad mailbox name\"));",
          "2231:   idata = imap_conn_find(&(mx.account), 0);",
          "2232:   if (!idata)",
          "2233:     goto fail;",
          "2235:   imap_fix_path(idata, mx.mbox, buf, sizeof(buf));",
          "2236:   if (!*buf)",
          "2237:     strfcpy(buf, \"INBOX\", sizeof(buf));",
          "2239:   if (option(OPT_IMAP_CHECK_SUBSCRIBED))",
          "2241:     mutt_buffer_init(&token);",
          "2242:     mutt_buffer_init(&err);",
          "2243:     err.data = errstr;",
          "2244:     err.dsize = sizeof(errstr);",
          "2245:     snprintf(mbox, sizeof(mbox), \"%smailboxes \\\"%s\\\"\", subscribe ? \"\" : \"un\", path);",
          "2246:     if (mutt_parse_rc_line(mbox, &token, &err))",
          "2247:       mutt_debug(1, \"Error adding subscribed mailbox: %s\\n\", errstr);",
          "2248:     FREE(&token.data);",
          "2249:   }",
          "2251:   if (subscribe)",
          "2252:     mutt_message(_(\"Subscribing to %s...\"), buf);",
          "2253:   else",
          "2254:     mutt_message(_(\"Unsubscribing from %s...\"), buf);",
          "2255:   imap_munge_mbox_name(idata, mbox, sizeof(mbox), buf);",
          "2257:   snprintf(buf, sizeof(buf), \"%sSUBSCRIBE %s\", subscribe ? \"\" : \"UN\", mbox);",
          "2259:   if (imap_exec(idata, buf, 0) < 0)",
          "2260:     goto fail;",
          "2262:   imap_unmunge_mbox_name(idata, mx.mbox);",
          "2263:   if (subscribe)",
          "2264:     mutt_message(_(\"Subscribed to %s\"), mx.mbox);",
          "2265:   else",
          "2266:     mutt_message(_(\"Unsubscribed from %s\"), mx.mbox);",
          "2267:   FREE(&mx.mbox);",
          "2268:   return 0;",
          "2270: fail:",
          "2271:   FREE(&mx.mbox);",
          "2272:   return -1;",
          "2273: }",
          "2285: static size_t longest_common_prefix(char *dest, const char *src, size_t start, size_t dlen)",
          "2286: {",
          "2287:   size_t pos = start;",
          "2289:   while (pos < dlen && dest[pos] && dest[pos] == src[pos])",
          "2290:     pos++;",
          "2291:   dest[pos] = '\\0';",
          "2293:   return pos;",
          "2294: }",
          "2302: static int imap_complete_hosts(char *dest, size_t len)",
          "2303: {",
          "2304:   struct Buffy *mailbox = NULL;",
          "2305:   struct Connection *conn = NULL;",
          "2306:   int rc = -1;",
          "2307:   size_t matchlen;",
          "2309:   matchlen = mutt_strlen(dest);",
          "2310:   for (mailbox = Incoming; mailbox; mailbox = mailbox->next)",
          "2312:     if (mutt_strncmp(dest, mailbox->path, matchlen) == 0)",
          "2314:       if (rc)",
          "2316:         strfcpy(dest, mailbox->path, len);",
          "2319:       else",
          "2320:         longest_common_prefix(dest, mailbox->path, matchlen, len);",
          "2324:   TAILQ_FOREACH(conn, mutt_socket_head(), entries)",
          "2326:     struct Url url;",
          "2327:     char urlstr[LONG_STRING];",
          "2329:     if (conn->account.type != MUTT_ACCT_TYPE_IMAP)",
          "2330:       continue;",
          "2332:     mutt_account_tourl(&conn->account, &url);",
          "2334:     url.user = NULL;",
          "2335:     url.path = NULL;",
          "2336:     url_tostring(&url, urlstr, sizeof(urlstr), 0);",
          "2337:     if (mutt_strncmp(dest, urlstr, matchlen) == 0)",
          "2339:       if (rc)",
          "2340:       {",
          "2341:         strfcpy(dest, urlstr, len);",
          "2342:         rc = 0;",
          "2343:       }",
          "2344:       else",
          "2345:         longest_common_prefix(dest, urlstr, matchlen, len);",
          "2358: int imap_complete(char *dest, size_t dlen, char *path)",
          "2360:   struct ImapData *idata = NULL;",
          "2361:   char list[LONG_STRING];",
          "2362:   char buf[LONG_STRING];",
          "2363:   struct ImapList listresp;",
          "2364:   char completion[LONG_STRING];",
          "2365:   int clen;",
          "2366:   size_t matchlen = 0;",
          "2367:   int completions = 0;",
          "2368:   struct ImapMbox mx;",
          "2369:   int rc;",
          "2371:   if (imap_parse_path(path, &mx))",
          "2372:   {",
          "2373:     strfcpy(dest, path, dlen);",
          "2374:     return imap_complete_hosts(dest, dlen);",
          "2375:   }",
          "2379:   idata = imap_conn_find(&(mx.account), MUTT_IMAP_CONN_NONEW);",
          "2380:   if (!idata)",
          "2381:   {",
          "2382:     FREE(&mx.mbox);",
          "2383:     strfcpy(dest, path, dlen);",
          "2384:     return imap_complete_hosts(dest, dlen);",
          "2389:   if (mx.mbox && mx.mbox[0])",
          "2390:     imap_fix_path(idata, mx.mbox, list, sizeof(list));",
          "2391:   else",
          "2392:     list[0] = '\\0';",
          "2395:   snprintf(buf, sizeof(buf), \"%s \\\"\\\" \\\"%s%%\\\"\",",
          "2396:            option(OPT_IMAP_LIST_SUBSCRIBED) ? \"LSUB\" : \"LIST\", list);",
          "2398:   imap_cmd_start(idata, buf);",
          "2401:   strfcpy(completion, NONULL(mx.mbox), sizeof(completion));",
          "2402:   idata->cmdtype = IMAP_CT_LIST;",
          "2403:   idata->cmddata = &listresp;",
          "2404:   do",
          "2406:     listresp.name = NULL;",
          "2407:     rc = imap_cmd_step(idata);",
          "2409:     if (rc == IMAP_CMD_CONTINUE && listresp.name)",
          "2413:       if (listresp.noselect)",
          "2414:       {",
          "2415:         clen = strlen(listresp.name);",
          "2416:         listresp.name[clen++] = listresp.delim;",
          "2417:         listresp.name[clen] = '\\0';",
          "2418:       }",
          "2420:       if (!completions)",
          "2421:       {",
          "2422:         strfcpy(completion, listresp.name, sizeof(completion));",
          "2423:         matchlen = strlen(completion);",
          "2424:         completions++;",
          "2425:         continue;",
          "2426:       }",
          "2428:       matchlen = longest_common_prefix(completion, listresp.name, 0, matchlen);",
          "2429:       completions++;",
          "2431:   } while (rc == IMAP_CMD_CONTINUE);",
          "2432:   idata->cmddata = NULL;",
          "2434:   if (completions)",
          "2435:   {",
          "2437:     imap_qualify_path(dest, dlen, &mx, completion);",
          "2438:     mutt_pretty_mailbox(dest, dlen);",
          "2440:     FREE(&mx.mbox);",
          "2441:     return 0;",
          "2444:   return -1;",
          "2453: int imap_fast_trash(struct Context *ctx, char *dest)",
          "2456:   char mbox[LONG_STRING];",
          "2457:   char mmbox[LONG_STRING];",
          "2458:   char prompt[LONG_STRING];",
          "2459:   int rc;",
          "2460:   struct ImapMbox mx;",
          "2461:   bool triedcreate = false;",
          "2462:   struct Buffer *sync_cmd = NULL;",
          "2463:   int err_continue = MUTT_NO;",
          "2467:   if (imap_parse_path(dest, &mx))",
          "2468:   {",
          "2469:     mutt_debug(1, \"imap_fast_trash: bad destination %s\\n\", dest);",
          "2470:     return -1;",
          "2471:   }",
          "2474:   if (!mutt_account_match(&(idata->conn->account), &(mx.account)))",
          "2475:   {",
          "2476:     mutt_debug(3, \"imap_fast_trash: %s not same server as %s\\n\", dest, ctx->path);",
          "2477:     return 1;",
          "2478:   }",
          "2480:   imap_fix_path(idata, mx.mbox, mbox, sizeof(mbox));",
          "2481:   if (!*mbox)",
          "2482:     strfcpy(mbox, \"INBOX\", sizeof(mbox));",
          "2483:   imap_munge_mbox_name(idata, mmbox, sizeof(mmbox), mbox);",
          "2485:   sync_cmd = mutt_buffer_new();",
          "2486:   for (int i = 0; i < ctx->msgcount; i++)",
          "2488:     if (ctx->hdrs[i]->active && ctx->hdrs[i]->changed &&",
          "2489:         ctx->hdrs[i]->deleted && !ctx->hdrs[i]->purge)",
          "2491:       rc = imap_sync_message_for_copy(idata, ctx->hdrs[i], sync_cmd, &err_continue);",
          "2492:       if (rc < 0)",
          "2493:       {",
          "2494:         mutt_debug(1, \"imap_fast_trash: could not sync\\n\");",
          "2495:         goto out;",
          "2496:       }",
          "2498:   }",
          "2501:   do",
          "2502:   {",
          "2503:     rc = imap_exec_msgset(idata, \"UID COPY\", mmbox, MUTT_TRASH, 0, 0);",
          "2504:     if (!rc)",
          "2506:       mutt_debug(1, \"imap_fast_trash: No messages to trash\\n\");",
          "2507:       rc = -1;",
          "2508:       goto out;",
          "2510:     else if (rc < 0)",
          "2512:       mutt_debug(1, \"could not queue copy\\n\");",
          "2513:       goto out;",
          "2515:     else",
          "2516:       mutt_message(_(\"Copying %d messages to %s...\"), rc, mbox);",
          "2519:     rc = imap_exec(idata, NULL, IMAP_CMD_FAIL_OK);",
          "2520:     if (rc == -2)",
          "2522:       if (triedcreate)",
          "2523:       {",
          "2524:         mutt_debug(1, \"Already tried to create mailbox %s\\n\", mbox);",
          "2525:         break;",
          "2526:       }",
          "2528:       if (mutt_strncasecmp(imap_get_qualifier(idata->buf), \"[TRYCREATE]\", 11) != 0)",
          "2529:         break;",
          "2530:       mutt_debug(3, \"imap_fast_trash: server suggests TRYCREATE\\n\");",
          "2531:       snprintf(prompt, sizeof(prompt), _(\"Create %s?\"), mbox);",
          "2532:       if (option(OPT_CONFIRMCREATE) && mutt_yesorno(prompt, 1) != MUTT_YES)",
          "2533:       {",
          "2534:         mutt_clear_error();",
          "2535:         goto out;",
          "2536:       }",
          "2537:       if (imap_create_mailbox(idata, mbox) < 0)",
          "2538:         break;",
          "2539:       triedcreate = true;",
          "2541:   } while (rc == -2);",
          "2543:   if (rc != 0)",
          "2544:   {",
          "2545:     imap_error(\"imap_fast_trash\", idata->buf);",
          "2546:     goto out;",
          "2549:   rc = 0;",
          "2551: out:",
          "2552:   mutt_buffer_free(&sync_cmd);",
          "2553:   FREE(&mx.mbox);",
          "2555:   return rc < 0 ? -1 : rc;",
          "",
          "[Added Lines]",
          "1246: int imap_check_mailbox(struct Context *ctx, int force)",
          "1248:   return imap_check(ctx->data, force);",
          "1251: int imap_check(struct ImapData *idata, int force)",
          "1255:   int result = 0;",
          "1258:   if (!force && option(OPT_IMAP_IDLE) && mutt_bit_isset(idata->capabilities, IDLE) &&",
          "1259:       (idata->state != IMAP_IDLE || time(NULL) >= idata->lastread + ImapKeepalive))",
          "1261:     if (imap_cmd_idle(idata) < 0)",
          "1262:       return -1;",
          "1264:   if (idata->state == IMAP_IDLE)",
          "1266:     while ((result = mutt_socket_poll(idata->conn, 0)) > 0)",
          "1268:       if (imap_cmd_step(idata) != IMAP_CMD_CONTINUE)",
          "1269:       {",
          "1270:         mutt_debug(1, \"Error reading IDLE response\\n\");",
          "1271:         return -1;",
          "1272:       }",
          "1273:     }",
          "1274:     if (result < 0)",
          "1275:     {",
          "1276:       mutt_debug(1, \"Poll failed, disabling IDLE\\n\");",
          "1277:       mutt_bit_unset(idata->capabilities, IDLE);",
          "1279:   }",
          "1281:   if ((force || (idata->state != IMAP_IDLE && time(NULL) >= idata->lastread + Timeout)) &&",
          "1282:       imap_exec(idata, \"NOOP\", IMAP_CMD_POLL) != 0)",
          "1283:     return -1;",
          "1287:   imap_cmd_finish(idata);",
          "1289:   if (idata->check_status & IMAP_EXPUNGE_PENDING)",
          "1290:     result = MUTT_REOPENED;",
          "1291:   else if (idata->check_status & IMAP_NEWMAIL_PENDING)",
          "1292:     result = MUTT_NEW_MAIL;",
          "1293:   else if (idata->check_status & IMAP_FLAGS_PENDING)",
          "1294:     result = MUTT_FLAGS;",
          "1296:   idata->check_status = 0;",
          "1298:   return result;",
          "1308: int imap_buffy_check(int force, int check_stats)",
          "1311:   struct ImapData *lastdata = NULL;",
          "1312:   struct Buffy *mailbox = NULL;",
          "1313:   char name[LONG_STRING];",
          "1314:   char command[LONG_STRING];",
          "1315:   char munged[LONG_STRING];",
          "1316:   int buffies = 0;",
          "1318:   for (mailbox = Incoming; mailbox; mailbox = mailbox->next)",
          "1319:   {",
          "1321:     if (!mailbox->magic)",
          "1322:     {",
          "1323:       if (mx_is_imap(mailbox->path))",
          "1324:         mailbox->magic = MUTT_IMAP;",
          "1325:     }",
          "1327:     if (mailbox->magic != MUTT_IMAP)",
          "1328:       continue;",
          "1330:     if (imap_get_mailbox(mailbox->path, &idata, name, sizeof(name)) < 0)",
          "1332:       mailbox->new = false;",
          "1333:       continue;",
          "1340:     if (idata->mailbox && (imap_mxcmp(name, idata->mailbox) == 0))",
          "1342:       mailbox->new = false;",
          "1343:       continue;",
          "1346:     if (!mutt_bit_isset(idata->capabilities, IMAP4REV1) &&",
          "1347:         !mutt_bit_isset(idata->capabilities, STATUS))",
          "1348:     {",
          "1349:       mutt_debug(2, \"Server doesn't support STATUS\\n\");",
          "1350:       continue;",
          "1351:     }",
          "1353:     if (lastdata && idata != lastdata)",
          "1357:       if (imap_exec(lastdata, NULL, IMAP_CMD_FAIL_OK | IMAP_CMD_POLL) == -1)",
          "1358:         mutt_debug(1, \"Error polling mailboxes\\n\");",
          "1360:       lastdata = NULL;",
          "1363:     if (!lastdata)",
          "1364:       lastdata = idata;",
          "1366:     imap_munge_mbox_name(idata, munged, sizeof(munged), name);",
          "1367:     if (check_stats)",
          "1368:       snprintf(command, sizeof(command),",
          "1369:                \"STATUS %s (UIDNEXT UIDVALIDITY UNSEEN RECENT MESSAGES)\", munged);",
          "1370:     else",
          "1371:       snprintf(command, sizeof(command),",
          "1372:                \"STATUS %s (UIDNEXT UIDVALIDITY UNSEEN RECENT)\", munged);",
          "1374:     if (imap_exec(idata, command, IMAP_CMD_QUEUE | IMAP_CMD_POLL) < 0)",
          "1376:       mutt_debug(1, \"Error queueing command\\n\");",
          "1377:       return 0;",
          "1379:   }",
          "1381:   if (lastdata && (imap_exec(lastdata, NULL, IMAP_CMD_FAIL_OK | IMAP_CMD_POLL) == -1))",
          "1382:   {",
          "1383:     mutt_debug(1, \"Error polling mailboxes\\n\");",
          "1384:     return 0;",
          "1388:   for (mailbox = Incoming; mailbox; mailbox = mailbox->next)",
          "1389:   {",
          "1390:     if (mailbox->magic == MUTT_IMAP && mailbox->new)",
          "1391:       buffies++;",
          "1392:   }",
          "1394:   return buffies;",
          "1405: int imap_status(char *path, int queue)",
          "1407:   static int queued = 0;",
          "1409:   struct ImapData *idata = NULL;",
          "1410:   char buf[LONG_STRING];",
          "1411:   char mbox[LONG_STRING];",
          "1412:   struct ImapStatus *status = NULL;",
          "1414:   if (imap_get_mailbox(path, &idata, buf, sizeof(buf)) < 0)",
          "1421:   if (idata->ctx && !imap_mxcmp(buf, idata->mailbox))",
          "1422:     return idata->ctx->msgcount;",
          "1423:   else if (mutt_bit_isset(idata->capabilities, IMAP4REV1) ||",
          "1424:            mutt_bit_isset(idata->capabilities, STATUS))",
          "1426:     imap_munge_mbox_name(idata, mbox, sizeof(mbox), buf);",
          "1427:     snprintf(buf, sizeof(buf), \"STATUS %s (%s)\", mbox, \"MESSAGES\");",
          "1428:     imap_unmunge_mbox_name(idata, mbox);",
          "1430:   else",
          "1433:     return -1;",
          "1435:   if (queue)",
          "1437:     imap_exec(idata, buf, IMAP_CMD_QUEUE);",
          "1438:     queued = 1;",
          "1439:     return 0;",
          "1440:   }",
          "1441:   else if (!queued)",
          "1442:     imap_exec(idata, buf, 0);",
          "1444:   queued = 0;",
          "1445:   if ((status = imap_mboxcache_get(idata, mbox, 0)))",
          "1446:     return status->messages;",
          "1448:   return 0;",
          "1449: }",
          "1456: struct ImapStatus *imap_mboxcache_get(struct ImapData *idata, const char *mbox, int create)",
          "1457: {",
          "1458:   struct ImapStatus *status = NULL;",
          "1460:   header_cache_t *hc = NULL;",
          "1461:   void *uidvalidity = NULL;",
          "1462:   void *uidnext = NULL;",
          "1465:   struct ListNode *np;",
          "1466:   STAILQ_FOREACH(np, &idata->mboxcache, entries)",
          "1468:     status = (struct ImapStatus *) np->data;",
          "1470:     if (imap_mxcmp(mbox, status->name) == 0)",
          "1471:       return status;",
          "1473:   status = NULL;",
          "1476:   if (create)",
          "1478:     struct ImapStatus *scache = safe_calloc(1, sizeof(struct ImapStatus));",
          "1479:     scache->name = (char *) mbox;",
          "1480:     mutt_list_insert_tail(&idata->mboxcache, (char *) scache);",
          "1481:     status = imap_mboxcache_get(idata, mbox, 0);",
          "1482:     status->name = safe_strdup(mbox);",
          "1485: #ifdef USE_HCACHE",
          "1486:   hc = imap_hcache_open(idata, mbox);",
          "1487:   if (hc)",
          "1489:     uidvalidity = mutt_hcache_fetch_raw(hc, \"/UIDVALIDITY\", 12);",
          "1490:     uidnext = mutt_hcache_fetch_raw(hc, \"/UIDNEXT\", 8);",
          "1491:     if (uidvalidity)",
          "1493:       if (!status)",
          "1495:         mutt_hcache_free(hc, &uidvalidity);",
          "1496:         mutt_hcache_free(hc, &uidnext);",
          "1497:         mutt_hcache_close(hc);",
          "1498:         return imap_mboxcache_get(idata, mbox, 1);",
          "1499:       }",
          "1500:       status->uidvalidity = *(unsigned int *) uidvalidity;",
          "1501:       status->uidnext = uidnext ? *(unsigned int *) uidnext : 0;",
          "1502:       mutt_debug(3, \"mboxcache: hcache uidvalidity %d, uidnext %d\\n\",",
          "1503:                  status->uidvalidity, status->uidnext);",
          "1505:     mutt_hcache_free(hc, &uidvalidity);",
          "1506:     mutt_hcache_free(hc, &uidnext);",
          "1507:     mutt_hcache_close(hc);",
          "1509: #endif",
          "1511:   return status;",
          "1512: }",
          "1514: void imap_mboxcache_free(struct ImapData *idata)",
          "1515: {",
          "1516:   struct ImapStatus *status = NULL;",
          "1518:   struct ListNode *np;",
          "1519:   STAILQ_FOREACH(np, &idata->mboxcache, entries)",
          "1521:     status = (struct ImapStatus *) np->data;",
          "1522:     FREE(&status->name);",
          "1525:   mutt_list_free(&idata->mboxcache);",
          "1528: int imap_search(struct Context *ctx, const struct Pattern *pat)",
          "1530:   struct Buffer buf;",
          "1531:   struct ImapData *idata = ctx->data;",
          "1532:   for (int i = 0; i < ctx->msgcount; i++)",
          "1533:     ctx->hdrs[i]->matched = false;",
          "1535:   if (!do_search(pat, 1))",
          "1538:   mutt_buffer_init(&buf);",
          "1539:   mutt_buffer_addstr(&buf, \"UID SEARCH \");",
          "1540:   if (imap_compile_search(ctx, pat, &buf) < 0)",
          "1542:     FREE(&buf.data);",
          "1543:     return -1;",
          "1544:   }",
          "1545:   if (imap_exec(idata, buf.data, 0) < 0)",
          "1546:   {",
          "1547:     FREE(&buf.data);",
          "1548:     return -1;",
          "1549:   }",
          "1551:   FREE(&buf.data);",
          "1552:   return 0;",
          "1553: }",
          "1555: int imap_subscribe(char *path, int subscribe)",
          "1556: {",
          "1557:   struct ImapData *idata = NULL;",
          "1558:   char buf[LONG_STRING];",
          "1559:   char mbox[LONG_STRING];",
          "1560:   char errstr[STRING];",
          "1561:   struct Buffer err, token;",
          "1562:   struct ImapMbox mx;",
          "1564:   if (!mx_is_imap(path) || imap_parse_path(path, &mx) || !mx.mbox)",
          "1565:   {",
          "1566:     mutt_error(_(\"Bad mailbox name\"));",
          "1567:     return -1;",
          "1569:   idata = imap_conn_find(&(mx.account), 0);",
          "1570:   if (!idata)",
          "1571:     goto fail;",
          "1573:   imap_fix_path(idata, mx.mbox, buf, sizeof(buf));",
          "1574:   if (!*buf)",
          "1575:     strfcpy(buf, \"INBOX\", sizeof(buf));",
          "1577:   if (option(OPT_IMAP_CHECK_SUBSCRIBED))",
          "1579:     mutt_buffer_init(&token);",
          "1580:     mutt_buffer_init(&err);",
          "1581:     err.data = errstr;",
          "1582:     err.dsize = sizeof(errstr);",
          "1583:     snprintf(mbox, sizeof(mbox), \"%smailboxes \\\"%s\\\"\", subscribe ? \"\" : \"un\", path);",
          "1584:     if (mutt_parse_rc_line(mbox, &token, &err))",
          "1585:       mutt_debug(1, \"Error adding subscribed mailbox: %s\\n\", errstr);",
          "1586:     FREE(&token.data);",
          "1589:   if (subscribe)",
          "1590:     mutt_message(_(\"Subscribing to %s...\"), buf);",
          "1591:   else",
          "1592:     mutt_message(_(\"Unsubscribing from %s...\"), buf);",
          "1593:   imap_munge_mbox_name(idata, mbox, sizeof(mbox), buf);",
          "1595:   snprintf(buf, sizeof(buf), \"%sSUBSCRIBE %s\", subscribe ? \"\" : \"UN\", mbox);",
          "1597:   if (imap_exec(idata, buf, 0) < 0)",
          "1598:     goto fail;",
          "1600:   imap_unmunge_mbox_name(idata, mx.mbox);",
          "1601:   if (subscribe)",
          "1602:     mutt_message(_(\"Subscribed to %s\"), mx.mbox);",
          "1603:   else",
          "1604:     mutt_message(_(\"Unsubscribed from %s\"), mx.mbox);",
          "1605:   FREE(&mx.mbox);",
          "1608: fail:",
          "1609:   FREE(&mx.mbox);",
          "1610:   return -1;",
          "1619: int imap_complete(char *dest, size_t dlen, char *path)",
          "1621:   struct ImapData *idata = NULL;",
          "1622:   char list[LONG_STRING];",
          "1623:   char buf[LONG_STRING];",
          "1624:   struct ImapList listresp;",
          "1625:   char completion[LONG_STRING];",
          "1626:   int clen;",
          "1627:   size_t matchlen = 0;",
          "1628:   int completions = 0;",
          "1629:   struct ImapMbox mx;",
          "1630:   int rc;",
          "1632:   if (imap_parse_path(path, &mx))",
          "1634:     strfcpy(dest, path, dlen);",
          "1635:     return imap_complete_hosts(dest, dlen);",
          "1640:   idata = imap_conn_find(&(mx.account), MUTT_IMAP_CONN_NONEW);",
          "1641:   if (!idata)",
          "1643:     FREE(&mx.mbox);",
          "1644:     strfcpy(dest, path, dlen);",
          "1645:     return imap_complete_hosts(dest, dlen);",
          "1650:   if (mx.mbox && mx.mbox[0])",
          "1651:     imap_fix_path(idata, mx.mbox, list, sizeof(list));",
          "1652:   else",
          "1653:     list[0] = '\\0';",
          "1656:   snprintf(buf, sizeof(buf), \"%s \\\"\\\" \\\"%s%%\\\"\",",
          "1657:            option(OPT_IMAP_LIST_SUBSCRIBED) ? \"LSUB\" : \"LIST\", list);",
          "1659:   imap_cmd_start(idata, buf);",
          "1662:   strfcpy(completion, NONULL(mx.mbox), sizeof(completion));",
          "1663:   idata->cmdtype = IMAP_CT_LIST;",
          "1664:   idata->cmddata = &listresp;",
          "1665:   do",
          "1666:   {",
          "1667:     listresp.name = NULL;",
          "1668:     rc = imap_cmd_step(idata);",
          "1670:     if (rc == IMAP_CMD_CONTINUE && listresp.name)",
          "1671:     {",
          "1674:       if (listresp.noselect)",
          "1675:       {",
          "1676:         clen = strlen(listresp.name);",
          "1677:         listresp.name[clen++] = listresp.delim;",
          "1678:         listresp.name[clen] = '\\0';",
          "1679:       }",
          "1681:       if (!completions)",
          "1682:       {",
          "1683:         strfcpy(completion, listresp.name, sizeof(completion));",
          "1684:         matchlen = strlen(completion);",
          "1685:         completions++;",
          "1686:         continue;",
          "1687:       }",
          "1689:       matchlen = longest_common_prefix(completion, listresp.name, 0, matchlen);",
          "1690:       completions++;",
          "1691:     }",
          "1692:   } while (rc == IMAP_CMD_CONTINUE);",
          "1693:   idata->cmddata = NULL;",
          "1695:   if (completions)",
          "1696:   {",
          "1698:     imap_qualify_path(dest, dlen, &mx, completion);",
          "1699:     mutt_pretty_mailbox(dest, dlen);",
          "1701:     FREE(&mx.mbox);",
          "1702:     return 0;",
          "1703:   }",
          "1705:   return -1;",
          "1714: int imap_fast_trash(struct Context *ctx, char *dest)",
          "1716:   struct ImapData *idata = NULL;",
          "1717:   char mbox[LONG_STRING];",
          "1718:   char mmbox[LONG_STRING];",
          "1719:   char prompt[LONG_STRING];",
          "1720:   int rc;",
          "1722:   bool triedcreate = false;",
          "1723:   struct Buffer *sync_cmd = NULL;",
          "1724:   int err_continue = MUTT_NO;",
          "1726:   idata = ctx->data;",
          "1728:   if (imap_parse_path(dest, &mx))",
          "1730:     mutt_debug(1, \"imap_fast_trash: bad destination %s\\n\", dest);",
          "1735:   if (!mutt_account_match(&(idata->conn->account), &(mx.account)))",
          "1737:     mutt_debug(3, \"imap_fast_trash: %s not same server as %s\\n\", dest, ctx->path);",
          "1738:     return 1;",
          "1741:   imap_fix_path(idata, mx.mbox, mbox, sizeof(mbox));",
          "1742:   if (!*mbox)",
          "1743:     strfcpy(mbox, \"INBOX\", sizeof(mbox));",
          "1744:   imap_munge_mbox_name(idata, mmbox, sizeof(mmbox), mbox);",
          "1746:   sync_cmd = mutt_buffer_new();",
          "1747:   for (int i = 0; i < ctx->msgcount; i++)",
          "1749:     if (ctx->hdrs[i]->active && ctx->hdrs[i]->changed &&",
          "1750:         ctx->hdrs[i]->deleted && !ctx->hdrs[i]->purge)",
          "1752:       rc = imap_sync_message_for_copy(idata, ctx->hdrs[i], sync_cmd, &err_continue);",
          "1753:       if (rc < 0)",
          "1754:       {",
          "1755:         mutt_debug(1, \"imap_fast_trash: could not sync\\n\");",
          "1756:         goto out;",
          "1757:       }",
          "1759:   }",
          "1762:   do",
          "1763:   {",
          "1764:     rc = imap_exec_msgset(idata, \"UID COPY\", mmbox, MUTT_TRASH, 0, 0);",
          "1765:     if (!rc)",
          "1767:       mutt_debug(1, \"imap_fast_trash: No messages to trash\\n\");",
          "1768:       rc = -1;",
          "1769:       goto out;",
          "1771:     else if (rc < 0)",
          "1773:       mutt_debug(1, \"could not queue copy\\n\");",
          "1774:       goto out;",
          "1776:     else",
          "1777:       mutt_message(_(\"Copying %d messages to %s...\"), rc, mbox);",
          "1780:     rc = imap_exec(idata, NULL, IMAP_CMD_FAIL_OK);",
          "1781:     if (rc == -2)",
          "1783:       if (triedcreate)",
          "1784:       {",
          "1785:         mutt_debug(1, \"Already tried to create mailbox %s\\n\", mbox);",
          "1786:         break;",
          "1787:       }",
          "1789:       if (mutt_strncasecmp(imap_get_qualifier(idata->buf), \"[TRYCREATE]\", 11) != 0)",
          "1790:         break;",
          "1791:       mutt_debug(3, \"imap_fast_trash: server suggests TRYCREATE\\n\");",
          "1792:       snprintf(prompt, sizeof(prompt), _(\"Create %s?\"), mbox);",
          "1793:       if (option(OPT_CONFIRMCREATE) && mutt_yesorno(prompt, 1) != MUTT_YES)",
          "1794:       {",
          "1795:         mutt_clear_error();",
          "1796:         goto out;",
          "1797:       }",
          "1798:       if (imap_create_mailbox(idata, mbox) < 0)",
          "1799:         break;",
          "1800:       triedcreate = true;",
          "1802:   } while (rc == -2);",
          "1804:   if (rc != 0)",
          "1805:   {",
          "1806:     imap_error(\"imap_fast_trash\", idata->buf);",
          "1807:     goto out;",
          "1808:   }",
          "1810:   rc = 0;",
          "1812: out:",
          "1813:   mutt_buffer_free(&sync_cmd);",
          "1814:   FREE(&mx.mbox);",
          "1816:   return rc < 0 ? -1 : rc;",
          "1817: }",
          "1819: static int imap_open_mailbox(struct Context *ctx)",
          "1820: {",
          "1821:   struct ImapData *idata = NULL;",
          "1822:   struct ImapStatus *status = NULL;",
          "1823:   char buf[LONG_STRING];",
          "1824:   char bufout[LONG_STRING];",
          "1825:   int count = 0;",
          "1826:   struct ImapMbox mx, pmx;",
          "1827:   int rc;",
          "1829:   if (imap_parse_path(ctx->path, &mx))",
          "1831:     mutt_error(_(\"%s is an invalid IMAP path\"), ctx->path);",
          "1832:     return -1;",
          "1836:   idata = imap_conn_find(&(mx.account), MUTT_IMAP_CONN_NOSELECT);",
          "1837:   if (!idata)",
          "1838:     goto fail_noidata;",
          "1839:   if (idata->state < IMAP_AUTHENTICATED)",
          "1840:     goto fail;",
          "1843:   ctx->data = idata;",
          "1846:   imap_fix_path(idata, mx.mbox, buf, sizeof(buf));",
          "1847:   if (!*buf)",
          "1848:     strfcpy(buf, \"INBOX\", sizeof(buf));",
          "1849:   FREE(&(idata->mailbox));",
          "1850:   idata->mailbox = safe_strdup(buf);",
          "1851:   imap_qualify_path(buf, sizeof(buf), &mx, idata->mailbox);",
          "1853:   FREE(&(ctx->path));",
          "1854:   FREE(&(ctx->realpath));",
          "1855:   ctx->path = safe_strdup(buf);",
          "1856:   ctx->realpath = safe_strdup(ctx->path);",
          "1858:   idata->ctx = ctx;",
          "1861:   idata->status = false;",
          "1862:   memset(idata->ctx->rights, 0, sizeof(idata->ctx->rights));",
          "1863:   idata->new_mail_count = 0;",
          "1864:   idata->max_msn = 0;",
          "1866:   mutt_message(_(\"Selecting %s...\"), idata->mailbox);",
          "1867:   imap_munge_mbox_name(idata, buf, sizeof(buf), idata->mailbox);",
          "1870:   if (mutt_bit_isset(idata->capabilities, ACL))",
          "1872:     snprintf(bufout, sizeof(bufout), \"MYRIGHTS %s\", buf);",
          "1873:     imap_exec(idata, bufout, IMAP_CMD_QUEUE);",
          "1878:     mutt_bit_set(idata->ctx->rights, MUTT_ACL_LOOKUP);",
          "1879:     mutt_bit_set(idata->ctx->rights, MUTT_ACL_READ);",
          "1880:     mutt_bit_set(idata->ctx->rights, MUTT_ACL_SEEN);",
          "1881:     mutt_bit_set(idata->ctx->rights, MUTT_ACL_WRITE);",
          "1882:     mutt_bit_set(idata->ctx->rights, MUTT_ACL_INSERT);",
          "1883:     mutt_bit_set(idata->ctx->rights, MUTT_ACL_POST);",
          "1884:     mutt_bit_set(idata->ctx->rights, MUTT_ACL_CREATE);",
          "1885:     mutt_bit_set(idata->ctx->rights, MUTT_ACL_DELETE);",
          "1888:   pmx.mbox = NULL;",
          "1889:   if (mx_is_imap(Postponed) && !imap_parse_path(Postponed, &pmx) &&",
          "1890:       mutt_account_match(&pmx.account, &mx.account))",
          "1891:     imap_status(Postponed, 1);",
          "1892:   FREE(&pmx.mbox);",
          "1894:   snprintf(bufout, sizeof(bufout), \"%s %s\",",
          "1895:            ctx->readonly ? \"EXAMINE\" : \"SELECT\", buf);",
          "1897:   idata->state = IMAP_SELECTED;",
          "1899:   imap_cmd_start(idata, bufout);",
          "1901:   status = imap_mboxcache_get(idata, idata->mailbox, 1);",
          "1903:   do",
          "1905:     char *pc = NULL;",
          "1907:     rc = imap_cmd_step(idata);",
          "1908:     if (rc != IMAP_CMD_CONTINUE)",
          "1909:       break;",
          "1911:     pc = idata->buf + 2;",
          "1915:     if (mutt_strncasecmp(\"FLAGS\", pc, 5) == 0)",
          "1916:     {",
          "1918:       if (STAILQ_EMPTY(&idata->flags))",
          "1919:       {",
          "1920:         mutt_debug(3, \"Getting mailbox FLAGS\\n\");",
          "1921:         pc = imap_get_flags(&idata->flags, pc);",
          "1922:         if (!pc)",
          "1923:           goto fail;",
          "1924:       }",
          "1925:     }",
          "1927:     else if (mutt_strncasecmp(\"OK [PERMANENTFLAGS\", pc, 18) == 0)",
          "1928:     {",
          "1929:       mutt_debug(3, \"Getting mailbox PERMANENTFLAGS\\n\");",
          "1931:       mutt_list_free(&idata->flags);",
          "1933:       pc += 13;",
          "1934:       pc = imap_get_flags(&(idata->flags), pc);",
          "1935:       if (!pc)",
          "1936:         goto fail;",
          "1937:     }",
          "1939:     else if (mutt_strncasecmp(\"OK [UIDVALIDITY\", pc, 14) == 0)",
          "1940:     {",
          "1941:       mutt_debug(3, \"Getting mailbox UIDVALIDITY\\n\");",
          "1942:       pc += 3;",
          "1943:       pc = imap_next_word(pc);",
          "1944:       idata->uid_validity = strtol(pc, NULL, 10);",
          "1945:       status->uidvalidity = idata->uid_validity;",
          "1946:     }",
          "1947:     else if (mutt_strncasecmp(\"OK [UIDNEXT\", pc, 11) == 0)",
          "1948:     {",
          "1949:       mutt_debug(3, \"Getting mailbox UIDNEXT\\n\");",
          "1950:       pc += 3;",
          "1951:       pc = imap_next_word(pc);",
          "1952:       idata->uidnext = strtol(pc, NULL, 10);",
          "1953:       status->uidnext = idata->uidnext;",
          "1954:     }",
          "1955:     else",
          "1956:     {",
          "1957:       pc = imap_next_word(pc);",
          "1958:       if (mutt_strncasecmp(\"EXISTS\", pc, 6) == 0)",
          "1959:       {",
          "1960:         count = idata->new_mail_count;",
          "1961:         idata->new_mail_count = 0;",
          "1962:       }",
          "1963:     }",
          "1964:   } while (rc == IMAP_CMD_CONTINUE);",
          "1966:   if (rc == IMAP_CMD_NO)",
          "1967:   {",
          "1968:     char *s = NULL;",
          "1971:     mutt_error(\"%s\", s);",
          "1972:     mutt_sleep(2);",
          "1973:     goto fail;",
          "1976:   if (rc != IMAP_CMD_OK)",
          "1977:     goto fail;",
          "1980:   if ((mutt_strncasecmp(imap_get_qualifier(idata->buf), \"[READ-ONLY]\", 11) == 0) &&",
          "1981:       !mutt_bit_isset(idata->capabilities, ACL))",
          "1983:     mutt_debug(2, \"Mailbox is read-only.\\n\");",
          "1984:     ctx->readonly = true;",
          "1987: #ifdef DEBUG",
          "1989:   if (debuglevel > 2)",
          "1991:     if (STAILQ_EMPTY(&idata->flags))",
          "1992:       mutt_debug(3, \"No folder flags found\\n\");",
          "1993:     else",
          "1995:       struct ListNode *np;",
          "1996:       struct Buffer flag_buffer;",
          "1997:       mutt_buffer_init(&flag_buffer);",
          "1998:       mutt_buffer_printf(&flag_buffer, \"Mailbox flags: \");",
          "1999:       STAILQ_FOREACH(np, &idata->flags, entries)",
          "2001:         mutt_buffer_printf(&flag_buffer, \"[%s] \", np->data);",
          "2003:       mutt_debug(3, \"%s\\n\", flag_buffer.data);",
          "2004:       FREE(&flag_buffer.data);",
          "2009:   if (!(mutt_bit_isset(idata->ctx->rights, MUTT_ACL_DELETE) ||",
          "2010:         mutt_bit_isset(idata->ctx->rights, MUTT_ACL_SEEN) ||",
          "2011:         mutt_bit_isset(idata->ctx->rights, MUTT_ACL_WRITE) ||",
          "2012:         mutt_bit_isset(idata->ctx->rights, MUTT_ACL_INSERT)))",
          "2013:     ctx->readonly = true;",
          "2015:   ctx->hdrmax = count;",
          "2016:   ctx->hdrs = safe_calloc(count, sizeof(struct Header *));",
          "2017:   ctx->v2r = safe_calloc(count, sizeof(int));",
          "2018:   ctx->msgcount = 0;",
          "2020:   if (count && (imap_read_headers(idata, 1, count) < 0))",
          "2021:   {",
          "2022:     mutt_error(_(\"Error opening mailbox\"));",
          "2023:     mutt_sleep(1);",
          "2024:     goto fail;",
          "2025:   }",
          "2027:   mutt_debug(2, \"imap_open_mailbox: msgcount is %d\\n\", ctx->msgcount);",
          "2028:   FREE(&mx.mbox);",
          "2029:   return 0;",
          "2031: fail:",
          "2032:   if (idata->state == IMAP_SELECTED)",
          "2033:     idata->state = IMAP_AUTHENTICATED;",
          "2034: fail_noidata:",
          "2035:   FREE(&mx.mbox);",
          "2036:   return -1;",
          "2039: static int imap_open_mailbox_append(struct Context *ctx, int flags)",
          "2041:   struct ImapData *idata = NULL;",
          "2042:   char buf[LONG_STRING];",
          "2043:   char mailbox[LONG_STRING];",
          "2044:   struct ImapMbox mx;",
          "2045:   int rc;",
          "2047:   if (imap_parse_path(ctx->path, &mx))",
          "2048:     return -1;",
          "2053:   idata = imap_conn_find(&(mx.account), 0);",
          "2054:   if (!idata)",
          "2056:     FREE(&mx.mbox);",
          "2057:     return -1;",
          "2060:   ctx->data = idata;",
          "2062:   imap_fix_path(idata, mx.mbox, mailbox, sizeof(mailbox));",
          "2063:   if (!*mailbox)",
          "2064:     strfcpy(mailbox, \"INBOX\", sizeof(mailbox));",
          "2065:   FREE(&mx.mbox);",
          "2067:   rc = imap_access(ctx->path);",
          "2068:   if (rc == 0)",
          "2069:     return 0;",
          "2071:   if (rc == -1)",
          "2072:     return -1;",
          "2074:   snprintf(buf, sizeof(buf), _(\"Create %s?\"), mailbox);",
          "2075:   if (option(OPT_CONFIRMCREATE) && mutt_yesorno(buf, 1) != MUTT_YES)",
          "2076:     return -1;",
          "2078:   if (imap_create_mailbox(idata, mailbox) < 0)",
          "2079:     return -1;",
          "2081:   return 0;",
          "2087: int imap_close_mailbox(struct Context *ctx)",
          "2089:   struct ImapData *idata = NULL;",
          "2091:   idata = ctx->data;",
          "2093:   if (!idata)",
          "2094:     return 0;",
          "2104:   if (ctx == idata->ctx)",
          "2106:     if (idata->status != IMAP_FATAL && idata->state >= IMAP_SELECTED)",
          "2110:       if (!ctx->deleted)",
          "2111:         imap_exec(idata, \"CLOSE\", IMAP_CMD_QUEUE);",
          "2112:       idata->state = IMAP_AUTHENTICATED;",
          "2115:     idata->reopen &= IMAP_REOPEN_ALLOW;",
          "2116:     FREE(&(idata->mailbox));",
          "2117:     mutt_list_free(&idata->flags);",
          "2118:     idata->ctx = NULL;",
          "2120:     hash_destroy(&idata->uid_hash, NULL);",
          "2121:     FREE(&idata->msn_index);",
          "2122:     idata->msn_index_size = 0;",
          "2123:     idata->max_msn = 0;",
          "2125:     for (int i = 0; i < IMAP_CACHE_LEN; i++)",
          "2126:     {",
          "2127:       if (idata->cache[i].path)",
          "2129:         unlink(idata->cache[i].path);",
          "2130:         FREE(&idata->cache[i].path);",
          "2134:     mutt_bcache_close(&idata->bcache);",
          "2135:   }",
          "2138:   for (int i = 0; i < ctx->msgcount; i++)",
          "2139:   {",
          "2141:     if (ctx->hdrs[i] && ctx->hdrs[i]->data)",
          "2142:       imap_free_header_data((struct ImapHeaderData **) &(ctx->hdrs[i]->data));",
          "2148: static int imap_open_new_message(struct Message *msg, struct Context *dest, struct Header *hdr)",
          "2150:   char tmp[_POSIX_PATH_MAX];",
          "2152:   mutt_mktemp(tmp, sizeof(tmp));",
          "2153:   msg->fp = safe_fopen(tmp, \"w\");",
          "2154:   if (!msg->fp)",
          "2156:     mutt_perror(tmp);",
          "2159:   msg->path = safe_strdup(tmp);",
          "2163: static int imap_check_mailbox_reopen(struct Context *ctx, int *index_hint)",
          "2164: {",
          "2165:   int rc;",
          "2166:   (void) index_hint;",
          "2168:   imap_allow_reopen(ctx);",
          "2169:   rc = imap_check(ctx->data, 0);",
          "2170:   imap_disallow_reopen(ctx);",
          "2172:   return rc;",
          "2173: }",
          "2182: int imap_sync_mailbox(struct Context *ctx, int expunge)",
          "2185:   struct Context *appendctx = NULL;",
          "2186:   struct Header *h = NULL;",
          "2187:   struct Header **hdrs = NULL;",
          "2188:   int oldsort;",
          "2189:   int rc;",
          "2191:   idata = ctx->data;",
          "2193:   if (idata->state < IMAP_SELECTED)",
          "2195:     mutt_debug(2, \"imap_sync_mailbox: no mailbox selected\\n\");",
          "2201:   imap_allow_reopen(ctx);",
          "2203:   rc = imap_check(idata, 0);",
          "2204:   if (rc != 0)",
          "2205:     return rc;",
          "2208:   if (expunge && mutt_bit_isset(ctx->rights, MUTT_ACL_DELETE))",
          "2209:   {",
          "2210:     if ((rc = imap_exec_msgset(idata, \"UID STORE\", \"+FLAGS.SILENT (\\\\Deleted)\",",
          "2211:                                MUTT_DELETED, 1, 0)) < 0)",
          "2212:     {",
          "2213:       mutt_error(_(\"Expunge failed\"));",
          "2214:       mutt_sleep(1);",
          "2215:       goto out;",
          "2216:     }",
          "2218:     if (rc > 0)",
          "2219:     {",
          "2222:       for (int i = 0; i < ctx->msgcount; i++)",
          "2223:         if (ctx->hdrs[i]->deleted && ctx->hdrs[i]->changed)",
          "2224:           ctx->hdrs[i]->active = false;",
          "2225:       mutt_message(_(\"Marking %d messages deleted...\"), rc);",
          "2226:     }",
          "2227:   }",
          "2229: #ifdef USE_HCACHE",
          "2230:   idata->hcache = imap_hcache_open(idata, NULL);",
          "2231: #endif",
          "2234:   for (int i = 0; i < ctx->msgcount; i++)",
          "2236:     h = ctx->hdrs[i];",
          "2238:     if (h->deleted)",
          "2239:     {",
          "2240:       imap_cache_del(idata, h);",
          "2241: #ifdef USE_HCACHE",
          "2242:       imap_hcache_del(idata, HEADER_DATA(h)->uid);",
          "2243: #endif",
          "2244:     }",
          "2246:     if (h->active && h->changed)",
          "2247:     {",
          "2248: #ifdef USE_HCACHE",
          "2249:       imap_hcache_put(idata, h);",
          "2250: #endif",
          "2254:       if ((h->env && (h->env->refs_changed || h->env->irt_changed)) ||",
          "2255:           h->attach_del || h->xlabel_changed)",
          "2256:       {",
          "2257:         mutt_message(_(\"Saving changed messages... [%d/%d]\"), i + 1, ctx->msgcount);",
          "2258:         if (!appendctx)",
          "2259:           appendctx = mx_open_mailbox(ctx->path, MUTT_APPEND | MUTT_QUIET, NULL);",
          "2260:         if (!appendctx)",
          "2261:           mutt_debug(",
          "2262:               1, \"imap_sync_mailbox: Error opening mailbox in append mode\\n\");",
          "2263:         else",
          "2264:           _mutt_save_message(h, appendctx, 1, 0, 0);",
          "2265:         h->xlabel_changed = false;",
          "2266:       }",
          "2267:     }",
          "2268:   }",
          "2270: #ifdef USE_HCACHE",
          "2271:   imap_hcache_close(idata);",
          "2272: #endif",
          "2275:   oldsort = Sort;",
          "2276:   if (Sort != SORT_ORDER)",
          "2277:   {",
          "2278:     hdrs = ctx->hdrs;",
          "2279:     ctx->hdrs = safe_malloc(ctx->msgcount * sizeof(struct Header *));",
          "2280:     memcpy(ctx->hdrs, hdrs, ctx->msgcount * sizeof(struct Header *));",
          "2282:     Sort = SORT_ORDER;",
          "2283:     qsort(ctx->hdrs, ctx->msgcount, sizeof(struct Header *), mutt_get_sort_func(SORT_ORDER));",
          "2284:   }",
          "2286:   rc = sync_helper(idata, MUTT_ACL_DELETE, MUTT_DELETED, \"\\\\Deleted\");",
          "2287:   if (rc >= 0)",
          "2288:     rc |= sync_helper(idata, MUTT_ACL_WRITE, MUTT_FLAG, \"\\\\Flagged\");",
          "2289:   if (rc >= 0)",
          "2290:     rc |= sync_helper(idata, MUTT_ACL_WRITE, MUTT_OLD, \"Old\");",
          "2291:   if (rc >= 0)",
          "2292:     rc |= sync_helper(idata, MUTT_ACL_SEEN, MUTT_READ, \"\\\\Seen\");",
          "2293:   if (rc >= 0)",
          "2294:     rc |= sync_helper(idata, MUTT_ACL_WRITE, MUTT_REPLIED, \"\\\\Answered\");",
          "2296:   if (oldsort != Sort)",
          "2297:   {",
          "2298:     Sort = oldsort;",
          "2299:     FREE(&ctx->hdrs);",
          "2300:     ctx->hdrs = hdrs;",
          "2301:   }",
          "2304:   if (rc > 0)",
          "2305:     if (imap_exec(idata, NULL, 0) != IMAP_CMD_OK)",
          "2306:       rc = -1;",
          "2308:   if (rc < 0)",
          "2310:     if (ctx->closing)",
          "2312:       if (mutt_yesorno(_(\"Error saving flags. Close anyway?\"), 0) == MUTT_YES)",
          "2315:         idata->state = IMAP_AUTHENTICATED;",
          "2316:         goto out;",
          "2319:     else",
          "2320:       mutt_error(_(\"Error saving flags\"));",
          "2321:     rc = -1;",
          "2322:     goto out;",
          "2328:   for (int i = 0; i < ctx->msgcount; i++)",
          "2330:     HEADER_DATA(ctx->hdrs[i])->deleted = ctx->hdrs[i]->deleted;",
          "2331:     HEADER_DATA(ctx->hdrs[i])->flagged = ctx->hdrs[i]->flagged;",
          "2332:     HEADER_DATA(ctx->hdrs[i])->old = ctx->hdrs[i]->old;",
          "2333:     HEADER_DATA(ctx->hdrs[i])->read = ctx->hdrs[i]->read;",
          "2334:     HEADER_DATA(ctx->hdrs[i])->replied = ctx->hdrs[i]->replied;",
          "2335:     ctx->hdrs[i]->changed = false;",
          "2336:   }",
          "2337:   ctx->changed = false;",
          "2340:   if (expunge && !(ctx->closing) && mutt_bit_isset(ctx->rights, MUTT_ACL_DELETE))",
          "2341:   {",
          "2342:     mutt_message(_(\"Expunging messages from server...\"));",
          "2344:     idata->reopen |= IMAP_EXPUNGE_EXPECTED;",
          "2345:     if (imap_exec(idata, \"EXPUNGE\", 0) != 0)",
          "2347:       idata->reopen &= ~IMAP_EXPUNGE_EXPECTED;",
          "2348:       imap_error(_(\"imap_sync_mailbox: EXPUNGE failed\"), idata->buf);",
          "2349:       rc = -1;",
          "2350:       goto out;",
          "2352:     idata->reopen &= ~IMAP_EXPUNGE_EXPECTED;",
          "2353:   }",
          "2355:   if (expunge && ctx->closing)",
          "2356:   {",
          "2357:     imap_exec(idata, \"CLOSE\", IMAP_CMD_QUEUE);",
          "2358:     idata->state = IMAP_AUTHENTICATED;",
          "2361:   if (option(OPT_MESSAGE_CACHE_CLEAN))",
          "2362:     imap_cache_clean(idata);",
          "2364:   rc = 0;",
          "2366: out:",
          "2367:   if (appendctx)",
          "2368:   {",
          "2369:     mx_fastclose_mailbox(appendctx);",
          "2370:     FREE(&appendctx);",
          "2371:   }",
          "2382: static int imap_edit_message_tags(struct Context *ctx, const char *tags, char *buf, size_t buflen)",
          "2384:   char *new = NULL;",
          "2385:   char *checker = NULL;",
          "2386:   struct ImapData *idata = (struct ImapData *) ctx->data;",
          "2389:   if (!imap_has_flag(&idata->flags, NULL))",
          "2390:   {",
          "2391:     mutt_error(_(\"IMAP server doesn't support custom flags\"));",
          "2392:     return -1;",
          "2396:   if (tags)",
          "2397:     strncpy(buf, tags, buflen);",
          "2399:   if (mutt_get_field(\"Tags: \", buf, buflen, 0) != 0)",
          "2400:     return -1;",
          "2415:   new = buf;",
          "2416:   checker = buf;",
          "2417:   SKIPWS(checker);",
          "2418:   while (*checker != '\\0')",
          "2420:     if (*checker < 32 || *checker >= 127 || // We allow space because it's the separator",
          "2435:       mutt_error(_(\"Invalid IMAP flags\"));",
          "2436:       mutt_sleep(2);",
          "2437:       return 0;",
          "2441:     while (*checker == ' ' && *(checker + 1) == ' ')",
          "2442:       checker++;",
          "2449:   mutt_remove_trailing_ws(new);",
          "2451:   if (mutt_strcmp(tags, buf) == 0)",
          "2452:     return 0;",
          "2453:   return 1;",
          "2474: static int imap_commit_message_tags(struct Context *ctx, struct Header *h, char *tags)",
          "2477:   struct Buffer *cmd = NULL;",
          "2478:   char uid[11];",
          "2482:   if (*tags == '\\0')",
          "2483:     tags = NULL;",
          "2485:   if (!mutt_bit_isset(idata->ctx->rights, MUTT_ACL_WRITE))",
          "2486:     return 0;",
          "2488:   snprintf(uid, sizeof(uid), \"%u\", HEADER_DATA(h)->uid);",
          "2491:   if (HEADER_DATA(h)->flags_remote)",
          "2493:     cmd = mutt_buffer_new();",
          "2494:     if (!cmd)",
          "2496:       mutt_debug(1, \"imap_commit_message_tags: unable to allocate buffer\\n\");",
          "2497:       return -1;",
          "2499:     cmd->dptr = cmd->data;",
          "2500:     mutt_buffer_addstr(cmd, \"UID STORE \");",
          "2501:     mutt_buffer_addstr(cmd, uid);",
          "2502:     mutt_buffer_addstr(cmd, \" -FLAGS.SILENT (\");",
          "2503:     mutt_buffer_addstr(cmd, HEADER_DATA(h)->flags_remote);",
          "2504:     mutt_buffer_addstr(cmd, \")\");",
          "2509:     if (imap_exec(idata, cmd->data, 0) != 0)",
          "2511:       mutt_buffer_free(&cmd);",
          "2512:       return -1;",
          "2515:     mutt_buffer_free(&cmd);",
          "2516:   }",
          "2519:   if (tags)",
          "2520:   {",
          "2521:     cmd = mutt_buffer_new();",
          "2522:     if (!cmd)",
          "2524:       mutt_debug(1, \"imap_commit_message_tags: fail to remove old flags\\n\");",
          "2525:       return -1;",
          "2527:     cmd->dptr = cmd->data;",
          "2528:     mutt_buffer_addstr(cmd, \"UID STORE \");",
          "2529:     mutt_buffer_addstr(cmd, uid);",
          "2530:     mutt_buffer_addstr(cmd, \" +FLAGS.SILENT (\");",
          "2531:     mutt_buffer_addstr(cmd, tags);",
          "2532:     mutt_buffer_addstr(cmd, \")\");",
          "2534:     if (imap_exec(idata, cmd->data, 0) != 0)",
          "2536:       mutt_debug(1, \"imap_commit_message_tags: fail to add new flags\\n\");",
          "2537:       mutt_buffer_free(&cmd);",
          "2538:       return -1;",
          "2541:     mutt_buffer_free(&cmd);",
          "2545:   mutt_debug(1, \"NEW TAGS: %d\\n\", tags);",
          "2546:   driver_tags_replace(&h->tags, tags);",
          "2547:   FREE(&HEADER_DATA(h)->flags_remote);",
          "2548:   HEADER_DATA(h)->flags_remote = driver_tags_get_with_hidden(&h->tags);",
          "2549:   return 0;",
          "",
          "---------------"
        ],
        "imap/imap.h||imap/imap.h": [
          "File: imap/imap.h -> imap/imap.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "56: int imap_complete(char *dest, size_t dlen, char *path);",
          "57: int imap_fast_trash(struct Context *ctx, char *dest);",
          "62: extern struct MxOps mx_imap_ops;",
          "",
          "[Removed Lines]",
          "59: void imap_allow_reopen(struct Context *ctx);",
          "60: void imap_disallow_reopen(struct Context *ctx);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "67: int imap_mailbox_rename(const char *mailbox);",
          "71: int imap_copy_messages(struct Context *ctx, struct Header *h, char *dest, int delete);",
          "",
          "[Removed Lines]",
          "70: int imap_append_message(struct Context *ctx, struct Message *msg);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "81: int imap_wait_keepalive(pid_t pid);",
          "82: void imap_keepalive(void);",
          "86: void imap_get_parent_path(char *output, const char *path, size_t olen);",
          "87: void imap_clean_path(char *path, size_t plen);",
          "",
          "[Removed Lines]",
          "84: int imap_account_match(const struct Account *a1, const struct Account *a2);",
          "85: void imap_get_parent(char *output, const char *mbox, size_t olen, char delim);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "imap/imap_private.h||imap/imap_private.h": [
          "File: imap/imap_private.h -> imap/imap_private.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "300: char *imap_set_flags(struct ImapData *idata, struct Header *h, char *s, int *server_changes);",
          "301: int imap_cache_del(struct ImapData *idata, struct Header *h);",
          "302: int imap_cache_clean(struct ImapData *idata);",
          "304: int imap_fetch_message(struct Context *ctx, struct Message *msg, int msgno);",
          "305: int imap_close_message(struct Context *ctx, struct Message *msg);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "303: int imap_append_message(struct Context *ctx, struct Message *msg);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "329: void imap_unquote_string(char *s);",
          "330: void imap_munge_mbox_name(struct ImapData *idata, char *dest, size_t dlen, const char *src);",
          "331: void imap_unmunge_mbox_name(struct ImapData *idata, char *s);",
          "334: void imap_utf_encode(struct ImapData *idata, char **s);",
          "335: void imap_utf_decode(struct ImapData *idata, char **s);",
          "337: #ifdef USE_HCACHE",
          "338: #define imap_hcache_keylen mutt_strlen",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "333: int imap_account_match(const struct Account *a1, const struct Account *a2);",
          "334: void imap_get_parent(char *output, const char *mbox, size_t olen, char delim);",
          "339: void imap_allow_reopen(struct Context *ctx);",
          "340: void imap_disallow_reopen(struct Context *ctx);",
          "",
          "---------------"
        ],
        "imap/message.c||imap/message.c": [
          "File: imap/message.c -> imap/message.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "478:   }",
          "479: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "484: static void imap_set_changed_flag(struct Context *ctx, struct Header *h,",
          "485:                                   int local_changes, int *server_changes, int flag_name,",
          "486:                                   int old_hd_flag, int new_hd_flag, int h_flag)",
          "487: {",
          "493:   if ((old_hd_flag != new_hd_flag) || (!local_changes))",
          "494:   {",
          "495:     if (new_hd_flag != h_flag)",
          "496:     {",
          "497:       if (server_changes)",
          "501:       if (!local_changes)",
          "502:         mutt_set_flag(ctx, h, flag_name, new_hd_flag);",
          "503:     }",
          "504:   }",
          "505: }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1435:   }",
          "1436: }",
          "",
          "[Removed Lines]",
          "1441: static void imap_set_changed_flag(struct Context *ctx, struct Header *h,",
          "1442:                                   int local_changes, int *server_changes, int flag_name,",
          "1443:                                   int old_hd_flag, int new_hd_flag, int h_flag)",
          "1444: {",
          "1450:   if ((old_hd_flag != new_hd_flag) || (!local_changes))",
          "1451:   {",
          "1452:     if (new_hd_flag != h_flag)",
          "1453:     {",
          "1454:       if (server_changes)",
          "1458:       if (!local_changes)",
          "1459:         mutt_set_flag(ctx, h, flag_name, new_hd_flag);",
          "1460:     }",
          "1461:   }",
          "1462: }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "1756e57ebcba938e3f74f37eabfb5ab39ca95eb5",
      "candidate_info": {
        "commit_hash": "1756e57ebcba938e3f74f37eabfb5ab39ca95eb5",
        "repo": "neomutt/neomutt",
        "commit_url": "https://github.com/neomutt/neomutt/commit/1756e57ebcba938e3f74f37eabfb5ab39ca95eb5",
        "files": [
          "attach.h",
          "copy.c",
          "imap/imap_private.h",
          "init.c",
          "mutt/hash.h",
          "mutt/md5.c",
          "mutt/string2.h",
          "mutt_account.h",
          "mutt_menu.h",
          "nntp.h",
          "protos.h",
          "url.h"
        ],
        "message": "cppcheck: match prototypes to their functions",
        "before_after_code_files": [
          "attach.h||attach.h",
          "copy.c||copy.c",
          "imap/imap_private.h||imap/imap_private.h",
          "init.c||init.c",
          "mutt/hash.h||mutt/hash.h",
          "mutt/md5.c||mutt/md5.c",
          "mutt/string2.h||mutt/string2.h",
          "mutt_account.h||mutt_account.h",
          "mutt_menu.h||mutt_menu.h",
          "nntp.h||nntp.h",
          "protos.h||protos.h",
          "url.h||url.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "imap/imap_private.h||imap/imap_private.h"
          ],
          "candidate": [
            "imap/imap_private.h||imap/imap_private.h"
          ]
        }
      },
      "candidate_diff": {
        "attach.h||attach.h": [
          "File: attach.h -> attach.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "79: int mutt_tag_attach(struct Menu *menu, int n, int m);",
          "80: int mutt_attach_display_loop(struct Menu *menu, int op, struct Header *hdr,",
          "83: void mutt_save_attachment_list(struct AttachCtx *actx, FILE *fp, bool tag,",
          "84:                                struct Body *top, struct Header *hdr, struct Menu *menu);",
          "",
          "[Removed Lines]",
          "81:                              struct AttachCtx *acvtx, bool recv);",
          "",
          "[Added Lines]",
          "81:                              struct AttachCtx *actx, bool recv);",
          "",
          "---------------"
        ],
        "copy.c||copy.c": [
          "File: copy.c -> copy.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "47: #include \"mutt_notmuch.h\"",
          "48: #endif",
          "51: static int copy_delete_attach(struct Body *b, FILE *fpin, FILE *fpout, char *date);",
          "",
          "[Removed Lines]",
          "50: static int address_header_decode(char **str);",
          "",
          "[Added Lines]",
          "50: static int address_header_decode(char **h);",
          "",
          "---------------"
        ],
        "imap/imap_private.h||imap/imap_private.h": [
          "File: imap/imap_private.h -> imap/imap_private.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "288: int imap_authenticate(struct ImapData *idata);",
          "292: int imap_cmd_step(struct ImapData *idata);",
          "293: void imap_cmd_finish(struct ImapData *idata);",
          "294: bool imap_code(const char *s);",
          "295: const char *imap_cmd_trailer(struct ImapData *idata);",
          "297: int imap_cmd_idle(struct ImapData *idata);",
          "",
          "[Removed Lines]",
          "291: int imap_cmd_start(struct ImapData *idata, const char *cmd);",
          "296: int imap_exec(struct ImapData *idata, const char *cmd, int flags);",
          "",
          "[Added Lines]",
          "291: int imap_cmd_start(struct ImapData *idata, const char *cmdstr);",
          "296: int imap_exec(struct ImapData *idata, const char *cmdstr, int flags);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "328: int imap_mxcmp(const char *mx1, const char *mx2);",
          "329: char *imap_next_word(char *s);",
          "330: void imap_qualify_path(char *dest, size_t len, struct ImapMbox *mx, char *path);",
          "332: void imap_unquote_string(char *s);",
          "333: void imap_munge_mbox_name(struct ImapData *idata, char *dest, size_t dlen, const char *src);",
          "334: void imap_unmunge_mbox_name(struct ImapData *idata, char *s);",
          "",
          "[Removed Lines]",
          "331: void imap_quote_string(char *dest, size_t slen, const char *src);",
          "",
          "[Added Lines]",
          "331: void imap_quote_string(char *dest, size_t dlen, const char *src);",
          "",
          "---------------"
        ],
        "init.c||init.c": [
          "File: init.c -> init.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "754:                          unsigned long data, struct Buffer *err)",
          "755: {",
          "756:   if (MoreArgs(s))",
          "",
          "[Removed Lines]",
          "753: static int finish_source(struct Buffer *tmp, struct Buffer *s,",
          "",
          "[Added Lines]",
          "753: static int finish_source(struct Buffer *buf, struct Buffer *s,",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "785:                        struct Buffer *err)",
          "786: {",
          "787:   bool res = 0;",
          "788:   struct Buffer token;",
          "790:   memset(&token, 0, sizeof(token));",
          "797:   if (!res)",
          "798:   {",
          "800:   }",
          "",
          "[Removed Lines]",
          "784: static int parse_ifdef(struct Buffer *tmp, struct Buffer *s, unsigned long data,",
          "791:   mutt_extract_token(tmp, s, 0);",
          "794:   res = (mutt_option_index(tmp->data) != -1);",
          "799:     res = feature_enabled(tmp->data);",
          "",
          "[Added Lines]",
          "784: static int parse_ifdef(struct Buffer *buf, struct Buffer *s, unsigned long data,",
          "791:   mutt_extract_token(buf, s, 0);",
          "794:   res = (mutt_option_index(buf->data) != -1);",
          "799:     res = feature_enabled(buf->data);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "811:       for (int j = 0; b[j].name; j++)",
          "812:       {",
          "814:         {",
          "815:           res = true;",
          "816:           break;",
          "",
          "[Removed Lines]",
          "813:         if (mutt_str_strcmp(tmp->data, b[j].name) == 0)",
          "",
          "[Added Lines]",
          "813:         if (mutt_str_strcmp(buf->data, b[j].name) == 0)",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "824:   {",
          "825:     for (int i = 0; Commands[i].name; i++)",
          "826:     {",
          "828:       {",
          "829:         res = true;",
          "830:         break;",
          "",
          "[Removed Lines]",
          "827:       if (mutt_str_strcmp(tmp->data, Commands[i].name) == 0)",
          "",
          "[Added Lines]",
          "827:       if (mutt_str_strcmp(buf->data, Commands[i].name) == 0)",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "836:   if (!res)",
          "837:   {",
          "839:   }",
          "841:   if (!MoreArgs(s))",
          "",
          "[Removed Lines]",
          "838:     res = !!myvar_get(tmp->data);",
          "",
          "[Added Lines]",
          "838:     res = !!myvar_get(buf->data);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "843:     snprintf(err->data, err->dsize, _(\"%s: too few arguments\"), (data ? \"ifndef\" : \"ifdef\"));",
          "844:     return -1;",
          "845:   }",
          "849:   if ((res && (data == 0)) || (!res && (data == 1)))",
          "850:   {",
          "852:     if (rc == -1)",
          "853:     {",
          "854:       mutt_error(\"Error: %s\", err->data);",
          "",
          "[Removed Lines]",
          "846:   mutt_extract_token(tmp, s, MUTT_TOKEN_SPACE);",
          "851:     int rc = mutt_parse_rc_line(tmp->data, &token, err);",
          "",
          "[Added Lines]",
          "846:   mutt_extract_token(buf, s, MUTT_TOKEN_SPACE);",
          "851:     int rc = mutt_parse_rc_line(buf->data, &token, err);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "2067:           (mutt_str_strcmp(val, \"info\") == 0) || !val || (*val == 0));",
          "2068: }",
          "2071:                         unsigned long data, struct Buffer *err)",
          "2072: {",
          "2073:   char **envp = mutt_envlist_getlist();",
          "",
          "[Removed Lines]",
          "2070: static int parse_setenv(struct Buffer *tmp, struct Buffer *s,",
          "",
          "[Added Lines]",
          "2070: static int parse_setenv(struct Buffer *buf, struct Buffer *s,",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "2088:   }",
          "2094:   if (query)",
          "2095:   {",
          "",
          "[Removed Lines]",
          "2091:   mutt_extract_token(tmp, s, MUTT_TOKEN_EQUAL);",
          "2092:   int len = strlen(tmp->data);",
          "",
          "[Added Lines]",
          "2091:   mutt_extract_token(buf, s, MUTT_TOKEN_EQUAL);",
          "2092:   int len = strlen(buf->data);",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "2097:     while (envp && *envp)",
          "2098:     {",
          "2101:       {",
          "2102:         if (!found)",
          "2103:         {",
          "",
          "[Removed Lines]",
          "2100:       if (mutt_str_strncmp(tmp->data, *envp, len) == 0)",
          "",
          "[Added Lines]",
          "2100:       if (mutt_str_strncmp(buf->data, *envp, len) == 0)",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "2115:       return 0;",
          "2116:     }",
          "2119:     return -1;",
          "2120:   }",
          "2122:   if (unset)",
          "2123:   {",
          "2125:       return 0;",
          "2126:     return -1;",
          "2127:   }",
          "",
          "[Removed Lines]",
          "2118:     snprintf(err->data, err->dsize, _(\"%s is unset\"), tmp->data);",
          "2124:     if (mutt_envlist_unset(tmp->data))",
          "",
          "[Added Lines]",
          "2118:     snprintf(err->data, err->dsize, _(\"%s is unset\"), buf->data);",
          "2124:     if (mutt_envlist_unset(buf->data))",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "2140:     return -1;",
          "2141:   }",
          "2146:   FREE(&name);",
          "2148:   return 0;",
          "2149: }",
          "2152:                      struct Buffer *err)",
          "2153: {",
          "2154:   int r = 0;",
          "",
          "[Removed Lines]",
          "2143:   char *name = mutt_str_strdup(tmp->data);",
          "2144:   mutt_extract_token(tmp, s, 0);",
          "2145:   mutt_envlist_set(name, tmp->data, true);",
          "2151: static int parse_set(struct Buffer *tmp, struct Buffer *s, unsigned long data,",
          "",
          "[Added Lines]",
          "2143:   char *name = mutt_str_strdup(buf->data);",
          "2144:   mutt_extract_token(buf, s, 0);",
          "2145:   mutt_envlist_set(name, buf->data, true);",
          "2151: static int parse_set(struct Buffer *buf, struct Buffer *s, unsigned long data,",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "2185:     }",
          "2194:     {",
          "2196:       return -1;",
          "2197:     }",
          "2198:     SKIPWS(s->dptr);",
          "",
          "[Removed Lines]",
          "2188:     mutt_extract_token(tmp, s, MUTT_TOKEN_EQUAL);",
          "2190:     if (mutt_str_strncmp(\"my_\", tmp->data, 3) == 0)",
          "2191:       myvar = tmp->data;",
          "2192:     else if ((idx = mutt_option_index(tmp->data)) == -1 &&",
          "2193:              !(reset && (mutt_str_strcmp(\"all\", tmp->data) == 0)))",
          "2195:       snprintf(err->data, err->dsize, _(\"%s: unknown variable\"), tmp->data);",
          "",
          "[Added Lines]",
          "2188:     mutt_extract_token(buf, s, MUTT_TOKEN_EQUAL);",
          "2190:     if (mutt_str_strncmp(\"my_\", buf->data, 3) == 0)",
          "2191:       myvar = buf->data;",
          "2192:     else if ((idx = mutt_option_index(buf->data)) == -1 &&",
          "2193:              !(reset && (mutt_str_strcmp(\"all\", buf->data) == 0)))",
          "2195:       snprintf(err->data, err->dsize, _(\"%s: unknown variable\"), buf->data);",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "2211:         return -1;",
          "2212:       }",
          "2215:       {",
          "2216:         if (CurrentMenu == MENU_PAGER)",
          "2217:         {",
          "",
          "[Removed Lines]",
          "2214:       if (mutt_str_strcmp(\"all\", tmp->data) == 0)",
          "",
          "[Added Lines]",
          "2214:       if (mutt_str_strcmp(\"all\", buf->data) == 0)",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "2247:         }",
          "2249:         s->dptr++;",
          "2252:           unset = inv = 0;",
          "2254:           unset = 1;",
          "2255:         else",
          "2256:         {",
          "",
          "[Removed Lines]",
          "2250:         mutt_extract_token(tmp, s, 0);",
          "2251:         if (mutt_str_strcasecmp(\"yes\", tmp->data) == 0)",
          "2253:         else if (mutt_str_strcasecmp(\"no\", tmp->data) == 0)",
          "",
          "[Added Lines]",
          "2250:         mutt_extract_token(buf, s, 0);",
          "2251:         if (mutt_str_strcasecmp(\"yes\", buf->data) == 0)",
          "2253:         else if (mutt_str_strcasecmp(\"no\", buf->data) == 0)",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "2263:       {",
          "2264:         snprintf(err->data, err->dsize,",
          "2267:         return 0;",
          "2268:       }",
          "",
          "[Removed Lines]",
          "2266:                  tmp->data);",
          "",
          "[Added Lines]",
          "2266:                  buf->data);",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "2347:         if (myvar)",
          "2348:         {",
          "2350:           myvar = mutt_str_strdup(myvar);",
          "2351:           myvar_del(myvar);",
          "2352:         }",
          "2356:         if (myvar)",
          "2357:         {",
          "2359:           FREE(&myvar);",
          "2360:           myvar = \"don't resort\";",
          "2361:         }",
          "2362:         else if ((idx >= 0) && (DTYPE(MuttVars[idx].type) == DT_PATH))",
          "2363:         {",
          "2364:           char scratch[_POSIX_PATH_MAX];",
          "2366:           mutt_expand_path(scratch, sizeof(scratch));",
          "2367:           if (mutt_str_strcmp(MuttVars[idx].name, \"debug_file\") == 0)",
          "2368:           {",
          "",
          "[Removed Lines]",
          "2354:         mutt_extract_token(tmp, s, 0);",
          "2358:           myvar_set(myvar, tmp->data);",
          "2365:           mutt_str_strfcpy(scratch, tmp->data, sizeof(scratch));",
          "",
          "[Added Lines]",
          "2354:         mutt_extract_token(buf, s, 0);",
          "2358:           myvar_set(myvar, buf->data);",
          "2365:           mutt_str_strfcpy(scratch, buf->data, sizeof(scratch));",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "2379:         else if ((idx >= 0) && (DTYPE(MuttVars[idx].type) == DT_STRING))",
          "2380:         {",
          "2381:           if ((strstr(MuttVars[idx].name, \"charset\") &&",
          "2385:           {",
          "2386:             snprintf(err->data, err->dsize, _(\"Invalid value for option %s: \\\"%s\\\"\"),",
          "2388:             return -1;",
          "2389:           }",
          "2391:           FREE((void *) MuttVars[idx].var);",
          "2393:           if (mutt_str_strcmp(MuttVars[idx].name, \"charset\") == 0)",
          "2394:             mutt_ch_set_charset(Charset);",
          "2396:           if ((mutt_str_strcmp(MuttVars[idx].name,",
          "2397:                                \"show_multipart_alternative\") == 0) &&",
          "2399:           {",
          "2400:             snprintf(err->data, err->dsize, _(\"Invalid value for name %s: \\\"%s\\\"\"),",
          "2402:             return -1;",
          "2403:           }",
          "2404:         }",
          "2405:         else if (DTYPE(MuttVars[idx].type) == DT_MBTABLE)",
          "2406:         {",
          "2407:           free_mbtable((struct MbTable **) MuttVars[idx].var);",
          "2409:         }",
          "2410:         else",
          "2411:         {",
          "2412:           mutt_addr_free((struct Address **) MuttVars[idx].var);",
          "2415:         }",
          "2416:       }",
          "2417:     }",
          "",
          "[Removed Lines]",
          "2382:                check_charset(&MuttVars[idx], tmp->data) < 0) |",
          "2384:               ((strcmp(MuttVars[idx].name, \"charset\") == 0) && !*tmp->data))",
          "2387:                      MuttVars[idx].name, tmp->data);",
          "2398:               !valid_show_multipart_alternative(tmp->data))",
          "2401:                      MuttVars[idx].name, tmp->data);",
          "2414:               mutt_addr_parse_list(NULL, tmp->data);",
          "",
          "[Added Lines]",
          "2382:                check_charset(&MuttVars[idx], buf->data) < 0) |",
          "2384:               ((strcmp(MuttVars[idx].name, \"charset\") == 0) && !*buf->data))",
          "2387:                      MuttVars[idx].name, buf->data);",
          "2398:               !valid_show_multipart_alternative(buf->data))",
          "2401:                      MuttVars[idx].name, buf->data);",
          "2414:               mutt_addr_parse_list(NULL, buf->data);",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "2438:       s->dptr++;",
          "2444:       {",
          "2446:         if (Context && Context->msgcount &&",
          "",
          "[Removed Lines]",
          "2441:       mutt_extract_token(tmp, s, 0);",
          "2443:       if (parse_regex(idx, tmp, err))",
          "",
          "[Added Lines]",
          "2441:       mutt_extract_token(buf, s, 0);",
          "2443:       if (parse_regex(idx, buf, err))",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "2492:       s->dptr++;",
          "2497:       {",
          "2499:         r = -1;",
          "2500:         break;",
          "2501:       }",
          "",
          "[Removed Lines]",
          "2495:       mutt_extract_token(tmp, s, 0);",
          "2496:       if (mx_set_magic(tmp->data))",
          "2498:         snprintf(err->data, err->dsize, _(\"%s: invalid mailbox type\"), tmp->data);",
          "",
          "[Added Lines]",
          "2495:       mutt_extract_token(buf, s, 0);",
          "2496:       if (mx_set_magic(buf->data))",
          "2498:         snprintf(err->data, err->dsize, _(\"%s: invalid mailbox type\"), buf->data);",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "2521:       CHECK_PAGER;",
          "2522:       s->dptr++;",
          "2528:       {",
          "2530:                  rc == -1 ? _(\"format error\") : _(\"number overflow\"));",
          "2531:         r = -1;",
          "2532:         break;",
          "",
          "[Removed Lines]",
          "2524:       mutt_extract_token(tmp, s, 0);",
          "2525:       rc = mutt_str_atos(tmp->data, (short *) &val);",
          "2527:       if (rc < 0 || !*tmp->data)",
          "2529:         snprintf(err->data, err->dsize, _(\"%s: invalid value (%s)\"), tmp->data,",
          "",
          "[Added Lines]",
          "2524:       mutt_extract_token(buf, s, 0);",
          "2525:       rc = mutt_str_atos(buf->data, (short *) &val);",
          "2527:       if (rc < 0 || !*buf->data)",
          "2529:         snprintf(err->data, err->dsize, _(\"%s: invalid value (%s)\"), buf->data,",
          "",
          "---------------",
          "--- Hunk 21 ---",
          "[Context before]",
          "2579:       if (*s->dptr == '=')",
          "2580:       {",
          "2581:         s->dptr++;",
          "2591:         else",
          "2592:         {",
          "2594:           r = -1;",
          "2595:           break;",
          "2596:         }",
          "",
          "[Removed Lines]",
          "2582:         mutt_extract_token(tmp, s, 0);",
          "2583:         if (mutt_str_strcasecmp(\"yes\", tmp->data) == 0)",
          "2585:         else if (mutt_str_strcasecmp(\"no\", tmp->data) == 0)",
          "2587:         else if (mutt_str_strcasecmp(\"ask-yes\", tmp->data) == 0)",
          "2589:         else if (mutt_str_strcasecmp(\"ask-no\", tmp->data) == 0)",
          "2593:           snprintf(err->data, err->dsize, _(\"%s: invalid value\"), tmp->data);",
          "",
          "[Added Lines]",
          "2582:         mutt_extract_token(buf, s, 0);",
          "2583:         if (mutt_str_strcasecmp(\"yes\", buf->data) == 0)",
          "2585:         else if (mutt_str_strcasecmp(\"no\", buf->data) == 0)",
          "2587:         else if (mutt_str_strcasecmp(\"ask-yes\", buf->data) == 0)",
          "2589:         else if (mutt_str_strcasecmp(\"ask-no\", buf->data) == 0)",
          "2593:           snprintf(err->data, err->dsize, _(\"%s: invalid value\"), buf->data);",
          "",
          "---------------",
          "--- Hunk 22 ---",
          "[Context before]",
          "2651:       }",
          "2652:       CHECK_PAGER;",
          "2653:       s->dptr++;",
          "2657:       {",
          "2658:         r = -1;",
          "2659:         break;",
          "",
          "[Removed Lines]",
          "2654:       mutt_extract_token(tmp, s, 0);",
          "2656:       if (parse_sort((short *) MuttVars[idx].var, tmp->data, map, err) == -1)",
          "",
          "[Added Lines]",
          "2654:       mutt_extract_token(buf, s, 0);",
          "2656:       if (parse_sort((short *) MuttVars[idx].var, buf->data, map, err) == -1)",
          "",
          "---------------",
          "--- Hunk 23 ---",
          "[Context before]",
          "2673:       s->dptr++;",
          "2678:       {",
          "2679:         FREE((void *) MuttVars[idx].var);",
          "2681:       }",
          "2682:       else",
          "2683:       {",
          "2685:         r = -1;",
          "2686:         break;",
          "2687:       }",
          "",
          "[Removed Lines]",
          "2676:       mutt_extract_token(tmp, s, 0);",
          "2677:       if (mutt_hcache_is_valid_backend(tmp->data))",
          "2684:         snprintf(err->data, err->dsize, _(\"%s: invalid backend\"), tmp->data);",
          "",
          "[Added Lines]",
          "2676:       mutt_extract_token(buf, s, 0);",
          "2677:       if (mutt_hcache_is_valid_backend(buf->data))",
          "2684:         snprintf(err->data, err->dsize, _(\"%s: invalid backend\"), buf->data);",
          "",
          "---------------",
          "--- Hunk 24 ---",
          "[Context before]",
          "2875: #undef MAXERRS",
          "2878:                         unsigned long data, struct Buffer *err)",
          "2879: {",
          "2880:   char path[_POSIX_PATH_MAX];",
          "2882:   do",
          "2883:   {",
          "2885:     {",
          "2887:       return -1;",
          "2888:     }",
          "2890:     mutt_expand_path(path, sizeof(path));",
          "2892:     if (source_rc(path, err) < 0)",
          "",
          "[Removed Lines]",
          "2877: static int parse_source(struct Buffer *tmp, struct Buffer *token,",
          "2884:     if (mutt_extract_token(tmp, token, 0) != 0)",
          "2886:       snprintf(err->data, err->dsize, _(\"source: error at %s\"), token->dptr);",
          "2889:     mutt_str_strfcpy(path, tmp->data, sizeof(path));",
          "",
          "[Added Lines]",
          "2877: static int parse_source(struct Buffer *buf, struct Buffer *s,",
          "2884:     if (mutt_extract_token(buf, s, 0) != 0)",
          "2886:       snprintf(err->data, err->dsize, _(\"source: error at %s\"), s->dptr);",
          "2889:     mutt_str_strfcpy(path, buf->data, sizeof(path));",
          "",
          "---------------",
          "--- Hunk 25 ---",
          "[Context before]",
          "2895:       return -1;",
          "2896:     }",
          "2900:   return 0;",
          "2901: }",
          "",
          "[Removed Lines]",
          "2898:   } while (MoreArgs(token));",
          "",
          "[Added Lines]",
          "2898:   } while (MoreArgs(s));",
          "",
          "---------------",
          "--- Hunk 26 ---",
          "[Context before]",
          "4006:   return -1;",
          "4007: }",
          "4010:                                 unsigned long data, struct Buffer *err)",
          "4011: {",
          "4013:     return -1;",
          "4015:   char *tmp = NULL;",
          "",
          "[Removed Lines]",
          "4009: static int parse_tag_transforms(struct Buffer *b, struct Buffer *s,",
          "4012:   if (!b || !s)",
          "",
          "[Added Lines]",
          "4009: static int parse_tag_transforms(struct Buffer *buf, struct Buffer *s,",
          "4012:   if (!buf || !s)",
          "",
          "---------------",
          "--- Hunk 27 ---",
          "[Context before]",
          "4018:   {",
          "4019:     char *tag = NULL, *transform = NULL;",
          "4024:     else",
          "4025:       continue;",
          "4031:     tmp = mutt_hash_find(TagTransforms, tag);",
          "",
          "[Removed Lines]",
          "4021:     mutt_extract_token(b, s, 0);",
          "4022:     if (b->data && *b->data)",
          "4023:       tag = mutt_str_strdup(b->data);",
          "4027:     mutt_extract_token(b, s, 0);",
          "4028:     transform = mutt_str_strdup(b->data);",
          "",
          "[Added Lines]",
          "4021:     mutt_extract_token(buf, s, 0);",
          "4022:     if (buf->data && *buf->data)",
          "4023:       tag = mutt_str_strdup(buf->data);",
          "4027:     mutt_extract_token(buf, s, 0);",
          "4028:     transform = mutt_str_strdup(buf->data);",
          "",
          "---------------",
          "--- Hunk 28 ---",
          "[Context before]",
          "4042:   return 0;",
          "4043: }",
          "4046:                              unsigned long data, struct Buffer *err)",
          "4047: {",
          "4049:     return -1;",
          "4051:   char *tmp = NULL;",
          "",
          "[Removed Lines]",
          "4045: static int parse_tag_formats(struct Buffer *b, struct Buffer *s,",
          "4048:   if (!b || !s)",
          "",
          "[Added Lines]",
          "4045: static int parse_tag_formats(struct Buffer *buf, struct Buffer *s,",
          "4048:   if (!buf || !s)",
          "",
          "---------------",
          "--- Hunk 29 ---",
          "[Context before]",
          "4054:   {",
          "4055:     char *tag = NULL, *format = NULL;",
          "4060:     else",
          "4061:       continue;",
          "4067:     tmp = mutt_hash_find(TagFormats, format);",
          "",
          "[Removed Lines]",
          "4057:     mutt_extract_token(b, s, 0);",
          "4058:     if (b->data && *b->data)",
          "4059:       tag = mutt_str_strdup(b->data);",
          "4063:     mutt_extract_token(b, s, 0);",
          "4064:     format = mutt_str_strdup(b->data);",
          "",
          "[Added Lines]",
          "4057:     mutt_extract_token(buf, s, 0);",
          "4058:     if (buf->data && *buf->data)",
          "4059:       tag = mutt_str_strdup(buf->data);",
          "4063:     mutt_extract_token(buf, s, 0);",
          "4064:     format = mutt_str_strdup(buf->data);",
          "",
          "---------------"
        ],
        "mutt/hash.h||mutt/hash.h": [
          "File: mutt/hash.h -> mutt/hash.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "75: void *           mutt_hash_find(const struct Hash *table, const char *strkey);",
          "76: struct HashElem *mutt_hash_find_elem(const struct Hash *table, const char *strkey);",
          "77: struct HashElem *mutt_hash_insert(struct Hash *table, const char *strkey, void *data);",
          "79: struct HashElem *mutt_hash_typed_insert(struct Hash *table, const char *strkey, int type, void *data);",
          "80: struct Hash *    mutt_hash_int_create(int nelem, int flags);",
          "81: void             mutt_hash_int_delete(struct Hash *table, unsigned int intkey, const void *data);",
          "",
          "[Removed Lines]",
          "78: void             mutt_hash_set_destructor(struct Hash *hash, hash_destructor fn, intptr_t fn_data);",
          "",
          "[Added Lines]",
          "78: void             mutt_hash_set_destructor(struct Hash *table, hash_destructor fn, intptr_t fn_data);",
          "",
          "---------------"
        ],
        "mutt/md5.c||mutt/md5.c": [
          "File: mutt/md5.c -> mutt/md5.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "309: {",
          "311: }",
          "",
          "[Removed Lines]",
          "308: void *mutt_md5(const char *s, void *resbuf)",
          "310:   return mutt_md5_bytes(s, strlen(s), resbuf);",
          "",
          "[Added Lines]",
          "308: void *mutt_md5(const char *string, void *resbuf)",
          "310:   return mutt_md5_bytes(string, strlen(string), resbuf);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "344: {",
          "346: }",
          "",
          "[Removed Lines]",
          "343: void mutt_md5_process(const char *s, struct Md5Ctx *ctx)",
          "345:   mutt_md5_process_bytes(s, strlen(s), ctx);",
          "",
          "[Added Lines]",
          "343: void mutt_md5_process(const char *string, struct Md5Ctx *ctx)",
          "345:   mutt_md5_process_bytes(string, strlen(string), ctx);",
          "",
          "---------------"
        ],
        "mutt/string2.h||mutt/string2.h": [
          "File: mutt/string2.h -> mutt/string2.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "62: #define terminate_buffer(a, b) terminate_string(a, b, sizeof(a) - 1)",
          "64: void        mutt_str_adjust(char **p);",
          "66: int         mutt_str_atoi(const char *str, int *dst);",
          "67: int         mutt_str_atol(const char *str, long *dst);",
          "68: int         mutt_str_atos(const char *str, short *dst);",
          "",
          "[Removed Lines]",
          "65: void        mutt_str_append_item(char **p, const char *item, int sep);",
          "",
          "[Added Lines]",
          "65: void        mutt_str_append_item(char **str, const char *item, int sep);",
          "",
          "---------------"
        ],
        "mutt_account.h||mutt_account.h": [
          "File: mutt_account.h -> mutt_account.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "47: #define MUTT_ACCT_PASS  (1 << 3)",
          "48: #define MUTT_ACCT_SSL   (1 << 4)",
          "51: int mutt_account_fromurl(struct Account *account, struct Url *url);",
          "52: void mutt_account_tourl(struct Account *account, struct Url *url);",
          "53: int mutt_account_getuser(struct Account *account);",
          "",
          "[Removed Lines]",
          "50: int mutt_account_match(const struct Account *a1, const struct Account *m2);",
          "",
          "[Added Lines]",
          "50: int mutt_account_match(const struct Account *a1, const struct Account *a2);",
          "",
          "---------------"
        ],
        "mutt_menu.h||mutt_menu.h": [
          "File: mutt_menu.h -> mutt_menu.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "134: void         mutt_menu_set_redraw(int menu_type, int redraw);",
          "138: int index_color(int index_no);",
          "",
          "[Removed Lines]",
          "137: void index_make_entry(char *s, size_t l, struct Menu *menu, int num);",
          "",
          "[Added Lines]",
          "137: void index_make_entry(char *buf, size_t buflen, struct Menu *menu, int num);",
          "",
          "---------------"
        ],
        "nntp.h||nntp.h": [
          "File: nntp.h -> nntp.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "174: void nntp_buffy(char *buf, size_t len);",
          "175: void nntp_expand_path(char *line, size_t len, struct Account *acct);",
          "176: void nntp_clear_cache(struct NntpServer *nserv);",
          "182: struct NntpServer *CurrentNewsSrv;",
          "",
          "[Removed Lines]",
          "177: const char *nntp_format_str(char *dest, size_t destlen, size_t col, int cols,",
          "178:                             char op, const char *src, const char *fmt,",
          "179:                             const char *if_str, const char *else_str,",
          "180:                             unsigned long data, enum FormatFlag flags);",
          "",
          "[Added Lines]",
          "177: const char *nntp_format_str(char *buf, size_t buflen, size_t col, int cols, char op,",
          "178:                             const char *src, const char *prec, const char *if_str,",
          "179:                             const char *else_str, unsigned long data, enum FormatFlag flags);",
          "",
          "---------------"
        ],
        "protos.h||protos.h": [
          "File: protos.h -> protos.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "54: struct passwd;",
          "56: #define mutt_make_string(A, B, C, D, E) mutt_make_string_flags(A, B, C, D, E, 0)",
          "",
          "[Removed Lines]",
          "57: void mutt_make_string_flags(char *dest, size_t destlen, const char *s, struct Context *ctx,",
          "58:                        struct Header *hdr, enum FormatFlag flags);",
          "",
          "[Added Lines]",
          "57: void mutt_make_string_flags(char *buf, size_t buflen, const char *s,",
          "58:                             struct Context *ctx, struct Header *hdr, enum FormatFlag flags);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "79: int mutt_extract_token(struct Buffer *dest, struct Buffer *tok, int flags);",
          "82:                            struct HdrFormatInfo *hfi, enum FormatFlag flags);",
          "84: void mutt_free_opts(void);",
          "",
          "[Removed Lines]",
          "81: void mutt_make_string_info(char *dst, size_t dstlen, int cols, const char *s,",
          "",
          "[Added Lines]",
          "81: void mutt_make_string_info(char *buf, size_t buflen, int cols, const char *s,",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "171: void mutt_expand_fmt(char *dest, size_t destlen, const char *fmt, const char *src);",
          "172: void mutt_fix_reply_recipients(struct Envelope *env);",
          "173: void mutt_folder_hook(const char *path);",
          "176: void mutt_format_s(char *buf, size_t buflen, const char *prec, const char *s);",
          "177: void mutt_format_s_tree(char *buf, size_t buflen, const char *prec, const char *s);",
          "178: void mutt_forward_intro(struct Context *ctx, struct Header *cur, FILE *fp);",
          "",
          "[Removed Lines]",
          "174: void mutt_simple_format(char *buf, size_t buflen, int min_width, int max_width, int justify,",
          "175:                         char m_pad_char, const char *s, size_t n, int arboreal);",
          "",
          "[Added Lines]",
          "174: void mutt_simple_format(char *buf, size_t buflen, int min_width, int max_width,",
          "175:                         int justify, char pad_char, const char *s, size_t n, int arboreal);",
          "",
          "---------------"
        ],
        "url.h||url.h": [
          "File: url.h -> url.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "85: int url_tostring(struct Url *u, char *dest, size_t len, int flags);",
          "86: int url_parse_mailto(struct Envelope *e, char **body, const char *src);",
          "87: int url_pct_decode(char *s);",
          "",
          "[Removed Lines]",
          "88: void url_pct_encode(char *dest, size_t len, const char *src);",
          "",
          "[Added Lines]",
          "88: void url_pct_encode(char *dst, size_t l, const char *src);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "98e30df8b57a14458ca100bfef97f45022fb910e",
      "candidate_info": {
        "commit_hash": "98e30df8b57a14458ca100bfef97f45022fb910e",
        "repo": "neomutt/neomutt",
        "commit_url": "https://github.com/neomutt/neomutt/commit/98e30df8b57a14458ca100bfef97f45022fb910e",
        "files": [
          "imap/auth.c",
          "imap/auth.h",
          "imap/auth_anon.c",
          "imap/auth_cram.c",
          "imap/auth_gss.c",
          "imap/auth_login.c",
          "imap/auth_oauth.c",
          "imap/auth_plain.c",
          "imap/auth_sasl.c",
          "imap/browse.c",
          "imap/command.c",
          "imap/imap.c",
          "imap/imap_private.h",
          "imap/message.c",
          "imap/message.h",
          "imap/utf7.c",
          "imap/util.c"
        ],
        "message": "imap: tidy data naming",
        "before_after_code_files": [
          "imap/auth.c||imap/auth.c",
          "imap/auth.h||imap/auth.h",
          "imap/auth_anon.c||imap/auth_anon.c",
          "imap/auth_cram.c||imap/auth_cram.c",
          "imap/auth_gss.c||imap/auth_gss.c",
          "imap/auth_login.c||imap/auth_login.c",
          "imap/auth_oauth.c||imap/auth_oauth.c",
          "imap/auth_plain.c||imap/auth_plain.c",
          "imap/auth_sasl.c||imap/auth_sasl.c",
          "imap/browse.c||imap/browse.c",
          "imap/command.c||imap/command.c",
          "imap/imap.c||imap/imap.c",
          "imap/imap_private.h||imap/imap_private.h",
          "imap/message.c||imap/message.c",
          "imap/message.h||imap/message.h",
          "imap/utf7.c||imap/utf7.c",
          "imap/util.c||imap/util.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "imap/auth_login.c||imap/auth_login.c",
            "imap/command.c||imap/command.c",
            "imap/imap.c||imap/imap.c",
            "imap/imap_private.h||imap/imap_private.h",
            "imap/util.c||imap/util.c"
          ],
          "candidate": [
            "imap/auth_login.c||imap/auth_login.c",
            "imap/command.c||imap/command.c",
            "imap/imap.c||imap/imap.c",
            "imap/imap_private.h||imap/imap_private.h",
            "imap/util.c||imap/util.c"
          ]
        }
      },
      "candidate_diff": {
        "imap/auth.c||imap/auth.c": [
          "File: imap/auth.c -> imap/auth.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "68: {",
          "69:   int r = IMAP_AUTH_FAILURE;",
          "",
          "[Removed Lines]",
          "67: int imap_authenticate(struct ImapData *idata)",
          "",
          "[Added Lines]",
          "67: int imap_authenticate(struct ImapMboxData *mdata)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "91:         const struct ImapAuth *auth = &imap_authenticators[i];",
          "92:         if (!auth->method || (mutt_str_strcasecmp(auth->method, method) == 0))",
          "93:         {",
          "95:           if (r == IMAP_AUTH_SUCCESS)",
          "96:           {",
          "97:             FREE(&methods);",
          "",
          "[Removed Lines]",
          "94:           r = auth->authenticate(idata, method);",
          "",
          "[Added Lines]",
          "94:           r = auth->authenticate(mdata, method);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "111:     for (size_t i = 0; i < mutt_array_size(imap_authenticators); ++i)",
          "112:     {",
          "114:       if (r == IMAP_AUTH_SUCCESS)",
          "115:         return r;",
          "116:     }",
          "",
          "[Removed Lines]",
          "113:       r = imap_authenticators[i].authenticate(idata, NULL);",
          "",
          "[Added Lines]",
          "113:       r = imap_authenticators[i].authenticate(mdata, NULL);",
          "",
          "---------------"
        ],
        "imap/auth.h||imap/auth.h": [
          "File: imap/auth.h -> imap/auth.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "26: #ifndef MUTT_IMAP_AUTH_H",
          "27: #define MUTT_IMAP_AUTH_H",
          "",
          "[Removed Lines]",
          "29: struct ImapData;",
          "",
          "[Added Lines]",
          "29: struct ImapMboxData;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "44: struct ImapAuth",
          "45: {",
          "50:   const char *method;",
          "51: };",
          "55: #ifndef USE_SASL",
          "58: #endif",
          "60: #ifdef USE_GSS",
          "62: #endif",
          "63: #ifdef USE_SASL",
          "65: #endif",
          "",
          "[Removed Lines]",
          "47:   enum ImapAuthRes (*authenticate)(struct ImapData *idata, const char *method);",
          "54: enum ImapAuthRes imap_auth_plain(struct ImapData *idata, const char *method);",
          "56: enum ImapAuthRes imap_auth_anon(struct ImapData *idata, const char *method);",
          "57: enum ImapAuthRes imap_auth_cram_md5(struct ImapData *idata, const char *method);",
          "59: enum ImapAuthRes imap_auth_login(struct ImapData *idata, const char *method);",
          "61: enum ImapAuthRes imap_auth_gss(struct ImapData *idata, const char *method);",
          "64: enum ImapAuthRes imap_auth_sasl(struct ImapData *idata, const char *method);",
          "66: enum ImapAuthRes imap_auth_oauth(struct ImapData *idata, const char *method);",
          "",
          "[Added Lines]",
          "47:   enum ImapAuthRes (*authenticate)(struct ImapMboxData *mdata, const char *method);",
          "54: enum ImapAuthRes imap_auth_plain(struct ImapMboxData *mdata, const char *method);",
          "56: enum ImapAuthRes imap_auth_anon(struct ImapMboxData *mdata, const char *method);",
          "57: enum ImapAuthRes imap_auth_cram_md5(struct ImapMboxData *mdata, const char *method);",
          "59: enum ImapAuthRes imap_auth_login(struct ImapMboxData *mdata, const char *method);",
          "61: enum ImapAuthRes imap_auth_gss(struct ImapMboxData *mdata, const char *method);",
          "64: enum ImapAuthRes imap_auth_sasl(struct ImapMboxData *mdata, const char *method);",
          "66: enum ImapAuthRes imap_auth_oauth(struct ImapMboxData *mdata, const char *method);",
          "",
          "---------------"
        ],
        "imap/auth_anon.c||imap/auth_anon.c": [
          "File: imap/auth_anon.c -> imap/auth_anon.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "46: {",
          "47:   int rc;",
          "50:     return IMAP_AUTH_UNAVAIL;",
          "53:     return IMAP_AUTH_FAILURE;",
          "56:     return IMAP_AUTH_UNAVAIL;",
          "58:   mutt_message(_(\"Authenticating (anonymous)...\"));",
          "62:   do",
          "64:   while (rc == IMAP_CMD_CONTINUE);",
          "66:   if (rc != IMAP_CMD_RESPOND)",
          "",
          "[Removed Lines]",
          "45: enum ImapAuthRes imap_auth_anon(struct ImapData *idata, const char *method)",
          "49:   if (!mutt_bit_isset(idata->capabilities, AUTH_ANON))",
          "52:   if (mutt_account_getuser(&idata->conn->account) < 0)",
          "55:   if (idata->conn->account.user[0] != '\\0')",
          "60:   imap_cmd_start(idata, \"AUTHENTICATE ANONYMOUS\");",
          "63:     rc = imap_cmd_step(idata);",
          "",
          "[Added Lines]",
          "45: enum ImapAuthRes imap_auth_anon(struct ImapMboxData *mdata, const char *method)",
          "49:   if (!mutt_bit_isset(mdata->capabilities, AUTH_ANON))",
          "52:   if (mutt_account_getuser(&mdata->conn->account) < 0)",
          "55:   if (mdata->conn->account.user[0] != '\\0')",
          "60:   imap_cmd_start(mdata, \"AUTHENTICATE ANONYMOUS\");",
          "63:     rc = imap_cmd_step(mdata);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "69:     goto bail;",
          "70:   }",
          "74:   do",
          "76:   while (rc == IMAP_CMD_CONTINUE);",
          "78:   if (rc != IMAP_CMD_OK)",
          "",
          "[Removed Lines]",
          "75:     rc = imap_cmd_step(idata);",
          "",
          "[Added Lines]",
          "75:     rc = imap_cmd_step(mdata);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "81:     goto bail;",
          "82:   }",
          "85:     return IMAP_AUTH_SUCCESS;",
          "87: bail:",
          "",
          "[Removed Lines]",
          "84:   if (imap_code(idata->buf))",
          "",
          "[Added Lines]",
          "84:   if (imap_code(mdata->buf))",
          "",
          "---------------"
        ],
        "imap/auth_cram.c||imap/auth_cram.c": [
          "File: imap/auth_cram.c -> imap/auth_cram.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "99: {",
          "100:   char ibuf[LONG_STRING * 2], obuf[LONG_STRING];",
          "101:   unsigned char hmac_response[MD5_DIGEST_LEN];",
          "102:   int len;",
          "103:   int rc;",
          "106:     return IMAP_AUTH_UNAVAIL;",
          "108:   mutt_message(_(\"Authenticating (CRAM-MD5)...\"));",
          "112:     return IMAP_AUTH_FAILURE;",
          "114:     return IMAP_AUTH_FAILURE;",
          "",
          "[Removed Lines]",
          "98: enum ImapAuthRes imap_auth_cram_md5(struct ImapData *idata, const char *method)",
          "105:   if (!mutt_bit_isset(idata->capabilities, ACRAM_MD5))",
          "111:   if (mutt_account_getlogin(&idata->conn->account) < 0)",
          "113:   if (mutt_account_getpass(&idata->conn->account) < 0)",
          "116:   imap_cmd_start(idata, \"AUTHENTICATE CRAM-MD5\");",
          "",
          "[Added Lines]",
          "98: enum ImapAuthRes imap_auth_cram_md5(struct ImapMboxData *mdata, const char *method)",
          "105:   if (!mutt_bit_isset(mdata->capabilities, ACRAM_MD5))",
          "111:   if (mutt_account_getlogin(&mdata->conn->account) < 0)",
          "113:   if (mutt_account_getpass(&mdata->conn->account) < 0)",
          "116:   imap_cmd_start(mdata, \"AUTHENTICATE CRAM-MD5\");",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "124:   do",
          "126:   while (rc == IMAP_CMD_CONTINUE);",
          "128:   if (rc != IMAP_CMD_RESPOND)",
          "",
          "[Removed Lines]",
          "125:     rc = imap_cmd_step(idata);",
          "",
          "[Added Lines]",
          "125:     rc = imap_cmd_step(mdata);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "131:     goto bail;",
          "132:   }",
          "135:   if (len == -1)",
          "136:   {",
          "137:     mutt_debug(1, \"Error decoding base64 response.\\n\");",
          "",
          "[Removed Lines]",
          "134:   len = mutt_b64_decode(idata->buf + 2, obuf, sizeof(obuf));",
          "",
          "[Added Lines]",
          "134:   len = mutt_b64_decode(mdata->buf + 2, obuf, sizeof(obuf));",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "158:   mutt_md5_toascii(hmac_response, obuf + off);",
          "159:   mutt_debug(2, \"CRAM response: %s\\n\", obuf);",
          "",
          "[Removed Lines]",
          "155:   hmac_md5(idata->conn->account.pass, obuf, hmac_response);",
          "157:   int off = snprintf(obuf, sizeof(obuf), \"%s \", idata->conn->account.user);",
          "",
          "[Added Lines]",
          "155:   hmac_md5(mdata->conn->account.pass, obuf, hmac_response);",
          "157:   int off = snprintf(obuf, sizeof(obuf), \"%s \", mdata->conn->account.user);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "163:   mutt_b64_encode(obuf, strlen(obuf), ibuf, sizeof(ibuf) - 2);",
          "164:   mutt_str_strcat(ibuf, sizeof(ibuf), \"\\r\\n\");",
          "167:   do",
          "169:   while (rc == IMAP_CMD_CONTINUE);",
          "171:   if (rc != IMAP_CMD_OK)",
          "",
          "[Removed Lines]",
          "165:   mutt_socket_send(idata->conn, ibuf);",
          "168:     rc = imap_cmd_step(idata);",
          "",
          "[Added Lines]",
          "165:   mutt_socket_send(mdata->conn, ibuf);",
          "168:     rc = imap_cmd_step(mdata);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "174:     goto bail;",
          "175:   }",
          "178:     return IMAP_AUTH_SUCCESS;",
          "180: bail:",
          "",
          "[Removed Lines]",
          "177:   if (imap_code(idata->buf))",
          "",
          "[Added Lines]",
          "177:   if (imap_code(mdata->buf))",
          "",
          "---------------"
        ],
        "imap/auth_gss.c||imap/auth_gss.c": [
          "File: imap/auth_gss.c -> imap/auth_gss.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "110: {",
          "111:   gss_buffer_desc request_buf, send_token;",
          "112:   gss_buffer_t sec_token;",
          "",
          "[Removed Lines]",
          "109: enum ImapAuthRes imap_auth_gss(struct ImapData *idata, const char *method)",
          "",
          "[Added Lines]",
          "109: enum ImapAuthRes imap_auth_gss(struct ImapMboxData *mdata, const char *method)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "121:   unsigned long buf_size;",
          "122:   int rc;",
          "125:     return IMAP_AUTH_UNAVAIL;",
          "128:     return IMAP_AUTH_FAILURE;",
          "132:   request_buf.value = buf1;",
          "133:   request_buf.length = strlen(buf1);",
          "134:   maj_stat = gss_import_name(&min_stat, &request_buf, gss_nt_service_name, &target_name);",
          "",
          "[Removed Lines]",
          "124:   if (!mutt_bit_isset(idata->capabilities, AGSSAPI))",
          "127:   if (mutt_account_getuser(&idata->conn->account) < 0)",
          "131:   snprintf(buf1, sizeof(buf1), \"imap@%s\", idata->conn->account.host);",
          "",
          "[Added Lines]",
          "124:   if (!mutt_bit_isset(mdata->capabilities, AGSSAPI))",
          "127:   if (mutt_account_getuser(&mdata->conn->account) < 0)",
          "131:   snprintf(buf1, sizeof(buf1), \"imap@%s\", mdata->conn->account.host);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "165:   mutt_message(_(\"Authenticating (GSSAPI)...\"));",
          "170:   do",
          "172:   while (rc == IMAP_CMD_CONTINUE);",
          "174:   if (rc != IMAP_CMD_RESPOND)",
          "",
          "[Removed Lines]",
          "167:   imap_cmd_start(idata, \"AUTHENTICATE GSSAPI\");",
          "171:     rc = imap_cmd_step(idata);",
          "",
          "[Added Lines]",
          "167:   imap_cmd_start(mdata, \"AUTHENTICATE GSSAPI\");",
          "171:     rc = imap_cmd_step(mdata);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "183:   mutt_b64_encode(send_token.value, send_token.length, buf1, sizeof(buf1) - 2);",
          "184:   gss_release_buffer(&min_stat, &send_token);",
          "185:   mutt_str_strcat(buf1, sizeof(buf1), \"\\r\\n\");",
          "188:   while (maj_stat == GSS_S_CONTINUE_NEEDED)",
          "189:   {",
          "191:     do",
          "193:     while (rc == IMAP_CMD_CONTINUE);",
          "195:     if (rc != IMAP_CMD_RESPOND)",
          "",
          "[Removed Lines]",
          "186:   mutt_socket_send(idata->conn, buf1);",
          "192:       rc = imap_cmd_step(idata);",
          "",
          "[Added Lines]",
          "186:   mutt_socket_send(mdata->conn, buf1);",
          "192:       rc = imap_cmd_step(mdata);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "199:       goto bail;",
          "200:     }",
          "203:     request_buf.value = buf2;",
          "204:     sec_token = &request_buf;",
          "",
          "[Removed Lines]",
          "202:     request_buf.length = mutt_b64_decode(idata->buf + 2, buf2, sizeof(buf2));",
          "",
          "[Added Lines]",
          "202:     request_buf.length = mutt_b64_decode(mdata->buf + 2, buf2, sizeof(buf2));",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "219:     mutt_b64_encode(send_token.value, send_token.length, buf1, sizeof(buf1) - 2);",
          "220:     gss_release_buffer(&min_stat, &send_token);",
          "221:     mutt_str_strcat(buf1, sizeof(buf1), \"\\r\\n\");",
          "223:   }",
          "225:   gss_release_name(&min_stat, &target_name);",
          "228:   do",
          "230:   while (rc == IMAP_CMD_CONTINUE);",
          "232:   if (rc != IMAP_CMD_RESPOND)",
          "",
          "[Removed Lines]",
          "222:     mutt_socket_send(idata->conn, buf1);",
          "229:     rc = imap_cmd_step(idata);",
          "",
          "[Added Lines]",
          "222:     mutt_socket_send(mdata->conn, buf1);",
          "229:     rc = imap_cmd_step(mdata);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "234:     mutt_debug(1, \"#2 Error receiving server response.\\n\");",
          "235:     goto bail;",
          "236:   }",
          "238:   request_buf.value = buf2;",
          "240:   maj_stat = gss_unwrap(&min_stat, context, &request_buf, &send_token, &cflags, &quality);",
          "",
          "[Removed Lines]",
          "237:   request_buf.length = mutt_b64_decode(idata->buf + 2, buf2, sizeof(buf2));",
          "",
          "[Added Lines]",
          "237:   request_buf.length = mutt_b64_decode(mdata->buf + 2, buf2, sizeof(buf2));",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "271:   memcpy(buf1, &buf_size, 4);",
          "272:   buf1[0] = GSS_AUTH_P_NONE;",
          "275:   request_buf.value = buf1;",
          "277:   maj_stat = gss_wrap(&min_stat, context, 0, GSS_C_QOP_DEFAULT, &request_buf,",
          "278:                       &cflags, &send_token);",
          "279:   if (maj_stat != GSS_S_COMPLETE)",
          "",
          "[Removed Lines]",
          "274:   strncpy(buf1 + 4, idata->conn->account.user, sizeof(buf1) - 4);",
          "276:   request_buf.length = 4 + strlen(idata->conn->account.user);",
          "",
          "[Added Lines]",
          "274:   strncpy(buf1 + 4, mdata->conn->account.user, sizeof(buf1) - 4);",
          "276:   request_buf.length = 4 + strlen(mdata->conn->account.user);",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "283:   }",
          "285:   mutt_b64_encode(send_token.value, send_token.length, buf1, sizeof(buf1) - 2);",
          "287:   mutt_str_strcat(buf1, sizeof(buf1), \"\\r\\n\");",
          "291:   do",
          "293:   while (rc == IMAP_CMD_CONTINUE);",
          "294:   if (rc == IMAP_CMD_RESPOND)",
          "295:   {",
          "296:     mutt_debug(1, \"Unexpected server continuation request.\\n\");",
          "297:     goto err_abort_cmd;",
          "298:   }",
          "300:   {",
          "302:     mutt_debug(2, \"Releasing GSS credentials\\n\");",
          "",
          "[Removed Lines]",
          "286:   mutt_debug(2, \"Requesting authorisation as %s\\n\", idata->conn->account.user);",
          "288:   mutt_socket_send(idata->conn, buf1);",
          "292:     rc = imap_cmd_step(idata);",
          "299:   if (imap_code(idata->buf))",
          "",
          "[Added Lines]",
          "286:   mutt_debug(2, \"Requesting authorisation as %s\\n\", mdata->conn->account.user);",
          "288:   mutt_socket_send(mdata->conn, buf1);",
          "292:     rc = imap_cmd_step(mdata);",
          "299:   if (imap_code(mdata->buf))",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "316:     goto bail;",
          "318: err_abort_cmd:",
          "320:   do",
          "322:   while (rc == IMAP_CMD_CONTINUE);",
          "324: bail:",
          "",
          "[Removed Lines]",
          "319:   mutt_socket_send(idata->conn, \"*\\r\\n\");",
          "321:     rc = imap_cmd_step(idata);",
          "",
          "[Added Lines]",
          "319:   mutt_socket_send(mdata->conn, \"*\\r\\n\");",
          "321:     rc = imap_cmd_step(mdata);",
          "",
          "---------------"
        ],
        "imap/auth_login.c||imap/auth_login.c": [
          "File: imap/auth_login.c -> imap/auth_login.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "46: {",
          "47:   char q_user[SHORT_STRING], q_pass[SHORT_STRING];",
          "48:   char buf[STRING];",
          "49:   int rc;",
          "52:   {",
          "53:     mutt_message(_(\"LOGIN disabled on this server\"));",
          "54:     return IMAP_AUTH_UNAVAIL;",
          "55:   }",
          "58:     return IMAP_AUTH_FAILURE;",
          "60:     return IMAP_AUTH_FAILURE;",
          "62:   mutt_message(_(\"Logging in...\"));",
          "70:   if (DebugLevel < IMAP_LOG_PASS)",
          "73:   snprintf(buf, sizeof(buf), \"LOGIN %s %s\", q_user, q_pass);",
          "76:   if (!rc)",
          "77:   {",
          "",
          "[Removed Lines]",
          "45: enum ImapAuthRes imap_auth_login(struct ImapData *idata, const char *method)",
          "51:   if (mutt_bit_isset(idata->capabilities, LOGINDISABLED))",
          "57:   if (mutt_account_getuser(&idata->conn->account) < 0)",
          "59:   if (mutt_account_getpass(&idata->conn->account) < 0)",
          "64:   imap_quote_string(q_user, sizeof(q_user), idata->conn->account.user, false);",
          "65:   imap_quote_string(q_pass, sizeof(q_pass), idata->conn->account.pass, false);",
          "71:     mutt_debug(2, \"Sending LOGIN command for %s...\\n\", idata->conn->account.user);",
          "74:   rc = imap_exec(idata, buf, IMAP_CMD_FAIL_OK | IMAP_CMD_PASS);",
          "",
          "[Added Lines]",
          "45: enum ImapAuthRes imap_auth_login(struct ImapMboxData *mdata, const char *method)",
          "51:   if (mutt_bit_isset(mdata->capabilities, LOGINDISABLED))",
          "57:   if (mutt_account_getuser(&mdata->conn->account) < 0)",
          "59:   if (mutt_account_getpass(&mdata->conn->account) < 0)",
          "64:   imap_quote_string(q_user, sizeof(q_user), mdata->conn->account.user, false);",
          "65:   imap_quote_string(q_pass, sizeof(q_pass), mdata->conn->account.pass, false);",
          "71:     mutt_debug(2, \"Sending LOGIN command for %s...\\n\", mdata->conn->account.user);",
          "74:   rc = imap_exec(mdata, buf, IMAP_CMD_FAIL_OK | IMAP_CMD_PASS);",
          "",
          "---------------"
        ],
        "imap/auth_oauth.c||imap/auth_oauth.c": [
          "File: imap/auth_oauth.c -> imap/auth_oauth.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "48: {",
          "49:   char *ibuf = NULL;",
          "50:   char *oauthbearer = NULL;",
          "",
          "[Removed Lines]",
          "47: enum ImapAuthRes imap_auth_oauth(struct ImapData *idata, const char *method)",
          "",
          "[Added Lines]",
          "47: enum ImapAuthRes imap_auth_oauth(struct ImapMboxData *mdata, const char *method)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "52:   int rc;",
          "57:   {",
          "58:     return IMAP_AUTH_UNAVAIL;",
          "59:   }",
          "",
          "[Removed Lines]",
          "55:   if (!mutt_bit_isset(idata->capabilities, AUTH_OAUTHBEARER) ||",
          "56:       !mutt_bit_isset(idata->capabilities, SASL_IR) || !idata->conn->ssf)",
          "",
          "[Added Lines]",
          "55:   if (!mutt_bit_isset(mdata->capabilities, AUTH_OAUTHBEARER) ||",
          "56:       !mutt_bit_isset(mdata->capabilities, SASL_IR) || !mdata->conn->ssf)",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "61:   mutt_message(_(\"Authenticating (OAUTHBEARER)...\"));",
          "65:   if (!oauthbearer)",
          "66:     return IMAP_AUTH_FAILURE;",
          "",
          "[Removed Lines]",
          "64:   oauthbearer = mutt_account_getoauthbearer(&idata->conn->account);",
          "",
          "[Added Lines]",
          "64:   oauthbearer = mutt_account_getoauthbearer(&mdata->conn->account);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "77:   FREE(&oauthbearer);",
          "78:   FREE(&ibuf);",
          "",
          "[Removed Lines]",
          "75:   rc = imap_exec(idata, ibuf, IMAP_CMD_FAIL_OK | IMAP_CMD_PASS);",
          "",
          "[Added Lines]",
          "75:   rc = imap_exec(mdata, ibuf, IMAP_CMD_FAIL_OK | IMAP_CMD_PASS);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "87:   }",
          "89:   if (!rc)",
          "",
          "[Removed Lines]",
          "85:     mutt_socket_send(idata->conn, \"\\001\");",
          "86:     rc = imap_exec(idata, ibuf, IMAP_CMD_FAIL_OK);",
          "",
          "[Added Lines]",
          "85:     mutt_socket_send(mdata->conn, \"\\001\");",
          "86:     rc = imap_exec(mdata, ibuf, IMAP_CMD_FAIL_OK);",
          "",
          "---------------"
        ],
        "imap/auth_plain.c||imap/auth_plain.c": [
          "File: imap/auth_plain.c -> imap/auth_plain.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "46: {",
          "47:   int rc = IMAP_CMD_CONTINUE;",
          "48:   enum ImapAuthRes res = IMAP_AUTH_SUCCESS;",
          "49:   static const char auth_plain_cmd[] = \"AUTHENTICATE PLAIN\";",
          "50:   char buf[STRING] = { 0 };",
          "53:     return IMAP_AUTH_FAILURE;",
          "55:     return IMAP_AUTH_FAILURE;",
          "57:   mutt_message(_(\"Logging in...\"));",
          "64:   {",
          "66:   }",
          "67:   else",
          "68:   {",
          "71:     buf[sizeof(auth_plain_cmd) - 1] = '\\0';",
          "73:     while (rc == IMAP_CMD_CONTINUE)",
          "74:     {",
          "76:     }",
          "77:     if (rc == IMAP_CMD_RESPOND)",
          "78:     {",
          "79:       mutt_str_strcat(buf + sizeof(auth_plain_cmd),",
          "80:                       sizeof(buf) - sizeof(auth_plain_cmd), \"\\r\\n\");",
          "82:     }",
          "83:   }",
          "85:   while (rc == IMAP_CMD_CONTINUE)",
          "86:   {",
          "88:   }",
          "90:   if (rc == IMAP_CMD_BAD)",
          "",
          "[Removed Lines]",
          "45: enum ImapAuthRes imap_auth_plain(struct ImapData *idata, const char *method)",
          "52:   if (mutt_account_getuser(&idata->conn->account) < 0)",
          "54:   if (mutt_account_getpass(&idata->conn->account) < 0)",
          "60:   mutt_sasl_plain_msg(buf, sizeof(buf), auth_plain_cmd, idata->conn->account.user,",
          "61:                       idata->conn->account.user, idata->conn->account.pass);",
          "63:   if (mutt_bit_isset(idata->capabilities, SASL_IR))",
          "65:     imap_cmd_start(idata, buf);",
          "72:     imap_cmd_start(idata, buf);",
          "75:       rc = imap_cmd_step(idata);",
          "81:       mutt_socket_send(idata->conn, buf + sizeof(auth_plain_cmd));",
          "87:     rc = imap_cmd_step(idata);",
          "",
          "[Added Lines]",
          "45: enum ImapAuthRes imap_auth_plain(struct ImapMboxData *mdata, const char *method)",
          "52:   if (mutt_account_getuser(&mdata->conn->account) < 0)",
          "54:   if (mutt_account_getpass(&mdata->conn->account) < 0)",
          "60:   mutt_sasl_plain_msg(buf, sizeof(buf), auth_plain_cmd, mdata->conn->account.user,",
          "61:                       mdata->conn->account.user, mdata->conn->account.pass);",
          "63:   if (mutt_bit_isset(mdata->capabilities, SASL_IR))",
          "65:     imap_cmd_start(mdata, buf);",
          "72:     imap_cmd_start(mdata, buf);",
          "75:       rc = imap_cmd_step(mdata);",
          "81:       mutt_socket_send(mdata->conn, buf + sizeof(auth_plain_cmd));",
          "87:     rc = imap_cmd_step(mdata);",
          "",
          "---------------"
        ],
        "imap/auth_sasl.c||imap/auth_sasl.c": [
          "File: imap/auth_sasl.c -> imap/auth_sasl.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "50: {",
          "51:   sasl_conn_t *saslconn = NULL;",
          "52:   sasl_interact_t *interaction = NULL;",
          "",
          "[Removed Lines]",
          "49: enum ImapAuthRes imap_auth_sasl(struct ImapData *idata, const char *method)",
          "",
          "[Added Lines]",
          "49: enum ImapAuthRes imap_auth_sasl(struct ImapMboxData *mdata, const char *method)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "58:   unsigned int len = 0, olen = 0;",
          "59:   bool client_start;",
          "62:   {",
          "63:     mutt_debug(1, \"Error allocating SASL connection.\\n\");",
          "64:     return IMAP_AUTH_FAILURE;",
          "",
          "[Removed Lines]",
          "61:   if (mutt_sasl_client_new(idata->conn, &saslconn) < 0)",
          "",
          "[Added Lines]",
          "61:   if (mutt_sasl_client_new(mdata->conn, &saslconn) < 0)",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "70:   if (!method)",
          "71:   {",
          "80:       return IMAP_AUTH_FAILURE;",
          "85:     {",
          "86:       rc = sasl_client_start(saslconn, \"AUTH=ANONYMOUS\", NULL, &pc, &olen, &mech);",
          "87:     }",
          "88:   }",
          "89:   else if ((mutt_str_strcasecmp(\"login\", method) == 0) &&",
          "91:   {",
          "93:     return IMAP_AUTH_UNAVAIL;",
          "",
          "[Removed Lines]",
          "72:     method = idata->capstr;",
          "79:     if (mutt_account_getuser(&idata->conn->account) < 0)",
          "82:     if (mutt_bit_isset(idata->capabilities, AUTH_ANON) &&",
          "83:         (!idata->conn->account.user[0] ||",
          "84:          (mutt_str_strncmp(idata->conn->account.user, \"anonymous\", 9) == 0)))",
          "90:            !strstr(NONULL(idata->capstr), \"AUTH=LOGIN\"))",
          "",
          "[Added Lines]",
          "72:     method = mdata->capstr;",
          "79:     if (mutt_account_getuser(&mdata->conn->account) < 0)",
          "82:     if (mutt_bit_isset(mdata->capabilities, AUTH_ANON) &&",
          "83:         (!mdata->conn->account.user[0] ||",
          "84:          (mutt_str_strncmp(mdata->conn->account.user, \"anonymous\", 9) == 0)))",
          "90:            !strstr(NONULL(mdata->capstr), \"AUTH=LOGIN\"))",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "126:   buf = mutt_mem_malloc(bufsize);",
          "128:   snprintf(buf, bufsize, \"AUTHENTICATE %s\", mech);",
          "130:   {",
          "131:     len = mutt_str_strlen(buf);",
          "132:     buf[len++] = ' ';",
          "",
          "[Removed Lines]",
          "129:   if (mutt_bit_isset(idata->capabilities, SASL_IR) && client_start)",
          "",
          "[Added Lines]",
          "129:   if (mutt_bit_isset(mdata->capabilities, SASL_IR) && client_start)",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "138:     client_start = false;",
          "139:     olen = 0;",
          "140:   }",
          "142:   irc = IMAP_CMD_CONTINUE;",
          "145:   while (rc == SASL_CONTINUE || olen > 0)",
          "146:   {",
          "147:     do",
          "149:     while (irc == IMAP_CMD_CONTINUE);",
          "151:     if (irc == IMAP_CMD_BAD || irc == IMAP_CMD_NO)",
          "",
          "[Removed Lines]",
          "141:   imap_cmd_start(idata, buf);",
          "148:       irc = imap_cmd_step(idata);",
          "",
          "[Added Lines]",
          "141:   imap_cmd_start(mdata, buf);",
          "148:       irc = imap_cmd_step(mdata);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "154:     if (irc == IMAP_CMD_RESPOND)",
          "155:     {",
          "158:       {",
          "159:         buf[0] = '\\0';",
          "160:         len = 0;",
          "161:       }",
          "162:       else",
          "163:       {",
          "165:         if (len > bufsize)",
          "166:         {",
          "167:           bufsize = len;",
          "",
          "[Removed Lines]",
          "157:       if (idata->buf[1] == '\\0')",
          "164:         len = strlen(idata->buf + 2);",
          "",
          "[Added Lines]",
          "157:       if (mdata->buf[1] == '\\0')",
          "164:         len = strlen(mdata->buf + 2);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "169:         }",
          "173:         {",
          "174:           mutt_debug(1, \"error base64-decoding server response.\\n\");",
          "175:           goto bail;",
          "",
          "[Removed Lines]",
          "172:         if (sasl_decode64(idata->buf + 2, len, buf, bufsize - 1, &len) != SASL_OK)",
          "",
          "[Added Lines]",
          "172:         if (sasl_decode64(mdata->buf + 2, len, buf, bufsize - 1, &len) != SASL_OK)",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "210:     if (irc == IMAP_CMD_RESPOND)",
          "211:     {",
          "212:       mutt_str_strfcpy(buf + olen, \"\\r\\n\", bufsize - olen);",
          "214:     }",
          "217:     if (rc < 0)",
          "218:     {",
          "220:       mutt_debug(1, \"sasl_client_step error %d\\n\", rc);",
          "221:     }",
          "",
          "[Removed Lines]",
          "213:       mutt_socket_send(idata->conn, buf);",
          "219:       mutt_socket_send(idata->conn, \"*\\r\\n\");",
          "",
          "[Added Lines]",
          "213:       mutt_socket_send(mdata->conn, buf);",
          "219:       mutt_socket_send(mdata->conn, \"*\\r\\n\");",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "226:   while (irc != IMAP_CMD_OK)",
          "227:   {",
          "229:     if (irc != IMAP_CMD_CONTINUE)",
          "230:       break;",
          "231:   }",
          "",
          "[Removed Lines]",
          "228:     irc = imap_cmd_step(idata);",
          "",
          "[Added Lines]",
          "228:     irc = imap_cmd_step(mdata);",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "233:   if (rc != SASL_OK)",
          "234:     goto bail;",
          "237:   {",
          "239:     FREE(&buf);",
          "240:     return IMAP_AUTH_SUCCESS;",
          "241:   }",
          "",
          "[Removed Lines]",
          "236:   if (imap_code(idata->buf))",
          "238:     mutt_sasl_setup_conn(idata->conn, saslconn);",
          "",
          "[Added Lines]",
          "236:   if (imap_code(mdata->buf))",
          "238:     mutt_sasl_setup_conn(mdata->conn, saslconn);",
          "",
          "---------------"
        ],
        "imap/browse.c||imap/browse.c": [
          "File: imap/browse.c -> imap/browse.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "146:                                   struct BrowserState *state, bool isparent)",
          "147: {",
          "148:   struct ImapList list;",
          "",
          "[Removed Lines]",
          "145: static int browse_add_list_result(struct ImapData *idata, const char *cmd,",
          "",
          "[Added Lines]",
          "145: static int browse_add_list_result(struct ImapMboxData *mdata, const char *cmd,",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "155:     return -1;",
          "156:   }",
          "161:   do",
          "162:   {",
          "163:     list.name = NULL;",
          "166:     if (rc == IMAP_CMD_CONTINUE && list.name)",
          "167:     {",
          "",
          "[Removed Lines]",
          "158:   imap_cmd_start(idata, cmd);",
          "159:   idata->cmdtype = IMAP_CT_LIST;",
          "160:   idata->cmddata = &list;",
          "164:     rc = imap_cmd_step(idata);",
          "",
          "[Added Lines]",
          "158:   imap_cmd_start(mdata, cmd);",
          "159:   mdata->cmdtype = IMAP_CT_LIST;",
          "160:   mdata->cmddata = &list;",
          "164:     rc = imap_cmd_step(mdata);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "173:         add_folder(list.delim, list.name, list.noselect, list.noinferiors, state, isparent);",
          "174:     }",
          "175:   } while (rc == IMAP_CMD_CONTINUE);",
          "178:   FREE(&mx.mbox);",
          "179:   return (rc == IMAP_CMD_OK) ? 0 : -1;",
          "",
          "[Removed Lines]",
          "176:   idata->cmddata = NULL;",
          "",
          "[Added Lines]",
          "176:   mdata->cmddata = NULL;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "191: int imap_browse(char *path, struct BrowserState *state)",
          "192: {",
          "194:   struct ImapList list;",
          "195:   char buf[PATH_MAX];",
          "196:   char mbox[PATH_MAX];",
          "",
          "[Removed Lines]",
          "193:   struct ImapData *idata = NULL;",
          "",
          "[Added Lines]",
          "193:   struct ImapMboxData *mdata = NULL;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "212:   ImapCheckSubscribed = false;",
          "213:   mutt_str_strfcpy(list_cmd, ImapListSubscribed ? \"LSUB\" : \"LIST\", sizeof(list_cmd));",
          "217:     goto fail;",
          "219:   mutt_message(_(\"Getting folder list...\"));",
          "",
          "[Removed Lines]",
          "215:   idata = imap_conn_find(&(mx.account), 0);",
          "216:   if (!idata)",
          "",
          "[Added Lines]",
          "215:   mdata = imap_conn_find(&(mx.account), 0);",
          "216:   if (!mdata)",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "222:   if (mx.mbox && mx.mbox[0] != '\\0')",
          "223:   {",
          "225:     n = mutt_str_strlen(mbox);",
          "226:   }",
          "227:   else",
          "",
          "[Removed Lines]",
          "224:     imap_fix_path(idata, mx.mbox, mbox, sizeof(mbox));",
          "",
          "[Added Lines]",
          "224:     imap_fix_path(mdata, mx.mbox, mbox, sizeof(mbox));",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "241:     snprintf(buf, sizeof(buf), \"%s \\\"\\\" %s\", list_cmd, munged_mbox);",
          "245:     do",
          "246:     {",
          "247:       list.name = 0;",
          "249:       if (rc == IMAP_CMD_CONTINUE && list.name)",
          "250:       {",
          "251:         if (!list.noinferiors && list.name[0] &&",
          "",
          "[Removed Lines]",
          "240:     imap_munge_mbox_name(idata, munged_mbox, sizeof(munged_mbox), mbox);",
          "242:     imap_cmd_start(idata, buf);",
          "243:     idata->cmdtype = IMAP_CT_LIST;",
          "244:     idata->cmddata = &list;",
          "248:       rc = imap_cmd_step(idata);",
          "",
          "[Added Lines]",
          "240:     imap_munge_mbox_name(mdata, munged_mbox, sizeof(munged_mbox), mbox);",
          "242:     imap_cmd_start(mdata, buf);",
          "243:     mdata->cmdtype = IMAP_CT_LIST;",
          "244:     mdata->cmddata = &list;",
          "248:       rc = imap_cmd_step(mdata);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "256:         }",
          "257:       }",
          "258:     } while (rc == IMAP_CMD_CONTINUE);",
          "262:     if (mbox[n - 1] == list.delim)",
          "",
          "[Removed Lines]",
          "259:     idata->cmddata = NULL;",
          "",
          "[Added Lines]",
          "259:     mdata->cmddata = NULL;",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "305:     {",
          "306:       char relpath[2];",
          "309:       if (showparents)",
          "311:       if (!state->folder)",
          "312:       {",
          "313:         imap_qualify_path(buf, sizeof(buf), &mx, relpath);",
          "",
          "[Removed Lines]",
          "308:       snprintf(relpath, sizeof(relpath), \"%c\", n < 0 ? '\\0' : idata->delim);",
          "310:         add_folder(idata->delim, relpath, true, false, state, true);",
          "",
          "[Added Lines]",
          "308:       snprintf(relpath, sizeof(relpath), \"%c\", n < 0 ? '\\0' : mdata->delim);",
          "310:         add_folder(mdata->delim, relpath, true, false, state, true);",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "326:   mutt_debug(3, \"Quoting mailbox scan: %s -> \", mbox);",
          "327:   snprintf(buf, sizeof(buf), \"%s%%\", mbox);",
          "329:   mutt_debug(3, \"%s\\n\", munged_mbox);",
          "330:   snprintf(buf, sizeof(buf), \"%s \\\"\\\" %s\", list_cmd, munged_mbox);",
          "332:     goto fail;",
          "334:   if (state->entrylen == 0)",
          "",
          "[Removed Lines]",
          "328:   imap_munge_mbox_name(idata, munged_mbox, sizeof(munged_mbox), buf);",
          "331:   if (browse_add_list_result(idata, buf, state, false))",
          "",
          "[Added Lines]",
          "328:   imap_munge_mbox_name(mdata, munged_mbox, sizeof(munged_mbox), buf);",
          "331:   if (browse_add_list_result(mdata, buf, state, false))",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "363: int imap_mailbox_create(const char *folder)",
          "364: {",
          "366:   struct ImapMbox mx;",
          "367:   char buf[PATH_MAX];",
          "368:   short n;",
          "",
          "[Removed Lines]",
          "365:   struct ImapData *idata = NULL;",
          "",
          "[Added Lines]",
          "365:   struct ImapMboxData *mdata = NULL;",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "373:     return -1;",
          "374:   }",
          "378:   {",
          "379:     mutt_debug(1, \"Couldn't find open connection to %s\\n\", mx.account.host);",
          "380:     goto fail;",
          "",
          "[Removed Lines]",
          "376:   idata = imap_conn_find(&mx.account, MUTT_IMAP_CONN_NONEW);",
          "377:   if (!idata)",
          "",
          "[Added Lines]",
          "376:   mdata = imap_conn_find(&mx.account, MUTT_IMAP_CONN_NONEW);",
          "377:   if (!mdata)",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "386:   n = mutt_str_strlen(buf);",
          "388:   {",
          "390:     buf[n] = '\\0';",
          "391:   }",
          "",
          "[Removed Lines]",
          "387:   if (n && (n < sizeof(buf) - 1) && (buf[n - 1] != idata->delim))",
          "389:     buf[n++] = idata->delim;",
          "",
          "[Added Lines]",
          "387:   if (n && (n < sizeof(buf) - 1) && (buf[n - 1] != mdata->delim))",
          "389:     buf[n++] = mdata->delim;",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "399:     goto fail;",
          "400:   }",
          "403:     goto fail;",
          "405:   mutt_message(_(\"Mailbox created\"));",
          "",
          "[Removed Lines]",
          "402:   if (imap_create_mailbox(idata, buf) < 0)",
          "",
          "[Added Lines]",
          "402:   if (imap_create_mailbox(mdata, buf) < 0)",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "424: int imap_mailbox_rename(const char *mailbox)",
          "425: {",
          "427:   struct ImapMbox mx;",
          "428:   char buf[PATH_MAX];",
          "429:   char newname[PATH_MAX];",
          "",
          "[Removed Lines]",
          "426:   struct ImapData *idata = NULL;",
          "",
          "[Added Lines]",
          "426:   struct ImapMboxData *mdata = NULL;",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "434:     return -1;",
          "435:   }",
          "439:   {",
          "440:     mutt_debug(1, \"Couldn't find open connection to %s\\n\", mx.account.host);",
          "441:     goto fail;",
          "",
          "[Removed Lines]",
          "437:   idata = imap_conn_find(&mx.account, MUTT_IMAP_CONN_NONEW);",
          "438:   if (!idata)",
          "",
          "[Added Lines]",
          "437:   mdata = imap_conn_find(&mx.account, MUTT_IMAP_CONN_NONEW);",
          "438:   if (!mdata)",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "459:     goto fail;",
          "460:   }",
          "465:   {",
          "467:     goto fail;",
          "468:   }",
          "",
          "[Removed Lines]",
          "462:   imap_fix_path(idata, newname, buf, sizeof(buf));",
          "464:   if (imap_rename_mailbox(idata, &mx, buf) < 0)",
          "466:     mutt_error(_(\"Rename failed: %s\"), imap_get_qualifier(idata->buf));",
          "",
          "[Added Lines]",
          "462:   imap_fix_path(mdata, newname, buf, sizeof(buf));",
          "464:   if (imap_rename_mailbox(mdata, &mx, buf) < 0)",
          "466:     mutt_error(_(\"Rename failed: %s\"), imap_get_qualifier(mdata->buf));",
          "",
          "---------------"
        ],
        "imap/command.c||imap/command.c": [
          "File: imap/command.c -> imap/command.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "85: {",
          "87:     return true;",
          "89:   return false;",
          "",
          "[Removed Lines]",
          "84: static bool cmd_queue_full(struct ImapData *idata)",
          "86:   if ((idata->nextcmd + 1) % idata->cmdslots == idata->lastcmd)",
          "",
          "[Added Lines]",
          "84: static bool cmd_queue_full(struct ImapMboxData *mdata)",
          "86:   if ((mdata->nextcmd + 1) % mdata->cmdslots == mdata->lastcmd)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "99: {",
          "100:   struct ImapCommand *cmd = NULL;",
          "103:   {",
          "104:     mutt_debug(3, \"IMAP command queue full\\n\");",
          "105:     return NULL;",
          "106:   }",
          "115:   cmd->state = IMAP_CMD_NEW;",
          "",
          "[Removed Lines]",
          "98: static struct ImapCommand *cmd_new(struct ImapData *idata)",
          "102:   if (cmd_queue_full(idata))",
          "108:   cmd = idata->cmds + idata->nextcmd;",
          "109:   idata->nextcmd = (idata->nextcmd + 1) % idata->cmdslots;",
          "111:   snprintf(cmd->seq, sizeof(cmd->seq), \"a%04u\", idata->seqno++);",
          "112:   if (idata->seqno > 9999)",
          "113:     idata->seqno = 0;",
          "",
          "[Added Lines]",
          "98: static struct ImapCommand *cmd_new(struct ImapMboxData *mdata)",
          "102:   if (cmd_queue_full(mdata))",
          "108:   cmd = mdata->cmds + mdata->nextcmd;",
          "109:   mdata->nextcmd = (mdata->nextcmd + 1) % mdata->cmdslots;",
          "111:   snprintf(cmd->seq, sizeof(cmd->seq), \"a%04u\", mdata->seqno++);",
          "112:   if (mdata->seqno > 9999)",
          "113:     mdata->seqno = 0;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "131: {",
          "133:   {",
          "134:     mutt_debug(3, \"Draining IMAP command pipeline\\n\");",
          "138:     if (rc < 0 && rc != -2)",
          "139:       return rc;",
          "140:   }",
          "143:   if (!cmd)",
          "144:     return IMAP_CMD_BAD;",
          "147:     return IMAP_CMD_BAD;",
          "149:   return 0;",
          "150: }",
          "157: {",
          "161:   {",
          "167:   }",
          "171:   {",
          "174:       mutt_clear_error();",
          "176:   }",
          "177: }",
          "188: {",
          "189:   int rc;",
          "192:   {",
          "194:     return -1;",
          "195:   }",
          "198:     return rc;",
          "200:   if (flags & IMAP_CMD_QUEUE)",
          "201:     return 0;",
          "204:     return IMAP_CMD_BAD;",
          "207:                           (flags & IMAP_CMD_PASS) ? IMAP_LOG_PASS : IMAP_LOG_CMD);",
          "214:   return (rc < 0) ? IMAP_CMD_BAD : 0;",
          "215: }",
          "",
          "[Removed Lines]",
          "130: static int cmd_queue(struct ImapData *idata, const char *cmdstr, int flags)",
          "132:   if (cmd_queue_full(idata))",
          "136:     const int rc = imap_exec(idata, NULL, IMAP_CMD_FAIL_OK | (flags & IMAP_CMD_POLL));",
          "142:   struct ImapCommand *cmd = cmd_new(idata);",
          "146:   if (mutt_buffer_printf(idata->cmdbuf, \"%s %s\\r\\n\", cmd->seq, cmdstr) < 0)",
          "156: static void cmd_handle_fatal(struct ImapData *idata)",
          "158:   idata->status = IMAP_FATAL;",
          "160:   if ((idata->state >= IMAP_SELECTED) && (idata->reopen & IMAP_REOPEN_ALLOW))",
          "162:     mx_fastclose_mailbox(idata->ctx);",
          "163:     mutt_socket_close(idata->conn);",
          "164:     mutt_error(_(\"Mailbox %s@%s closed\"), idata->conn->account.login,",
          "165:                idata->conn->account.host);",
          "166:     idata->state = IMAP_DISCONNECTED;",
          "169:   imap_close_connection(idata);",
          "170:   if (!idata->recovering)",
          "172:     idata->recovering = true;",
          "173:     if (imap_conn_find(&idata->conn->account, 0))",
          "175:     idata->recovering = false;",
          "187: static int cmd_start(struct ImapData *idata, const char *cmdstr, int flags)",
          "191:   if (idata->status == IMAP_FATAL)",
          "193:     cmd_handle_fatal(idata);",
          "197:   if (cmdstr && ((rc = cmd_queue(idata, cmdstr, flags)) < 0))",
          "203:   if (idata->cmdbuf->dptr == idata->cmdbuf->data)",
          "206:   rc = mutt_socket_send_d(idata->conn, idata->cmdbuf->data,",
          "208:   idata->cmdbuf->dptr = idata->cmdbuf->data;",
          "211:   if (idata->state == IMAP_IDLE)",
          "212:     idata->state = IMAP_SELECTED;",
          "",
          "[Added Lines]",
          "130: static int cmd_queue(struct ImapMboxData *mdata, const char *cmdstr, int flags)",
          "132:   if (cmd_queue_full(mdata))",
          "136:     const int rc = imap_exec(mdata, NULL, IMAP_CMD_FAIL_OK | (flags & IMAP_CMD_POLL));",
          "142:   struct ImapCommand *cmd = cmd_new(mdata);",
          "146:   if (mutt_buffer_printf(mdata->cmdbuf, \"%s %s\\r\\n\", cmd->seq, cmdstr) < 0)",
          "156: static void cmd_handle_fatal(struct ImapMboxData *mdata)",
          "158:   mdata->status = IMAP_FATAL;",
          "160:   if ((mdata->state >= IMAP_SELECTED) && (mdata->reopen & IMAP_REOPEN_ALLOW))",
          "162:     mx_fastclose_mailbox(mdata->ctx);",
          "163:     mutt_socket_close(mdata->conn);",
          "164:     mutt_error(_(\"Mailbox %s@%s closed\"), mdata->conn->account.login,",
          "165:                mdata->conn->account.host);",
          "166:     mdata->state = IMAP_DISCONNECTED;",
          "169:   imap_close_connection(mdata);",
          "170:   if (!mdata->recovering)",
          "172:     mdata->recovering = true;",
          "173:     if (imap_conn_find(&mdata->conn->account, 0))",
          "175:     mdata->recovering = false;",
          "187: static int cmd_start(struct ImapMboxData *mdata, const char *cmdstr, int flags)",
          "191:   if (mdata->status == IMAP_FATAL)",
          "193:     cmd_handle_fatal(mdata);",
          "197:   if (cmdstr && ((rc = cmd_queue(mdata, cmdstr, flags)) < 0))",
          "203:   if (mdata->cmdbuf->dptr == mdata->cmdbuf->data)",
          "206:   rc = mutt_socket_send_d(mdata->conn, mdata->cmdbuf->data,",
          "208:   mdata->cmdbuf->dptr = mdata->cmdbuf->data;",
          "211:   if (mdata->state == IMAP_IDLE)",
          "212:     mdata->state = IMAP_SELECTED;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "244: {",
          "245:   unsigned int exp_msn;",
          "246:   struct Email *e = NULL;",
          "248:   mutt_debug(2, \"Handling EXPUNGE\\n\");",
          "251:     return;",
          "254:   if (e)",
          "255:   {",
          "",
          "[Removed Lines]",
          "243: static void cmd_parse_expunge(struct ImapData *idata, const char *s)",
          "250:   if (mutt_str_atoui(s, &exp_msn) < 0 || exp_msn < 1 || exp_msn > idata->max_msn)",
          "253:   e = idata->msn_index[exp_msn - 1];",
          "",
          "[Added Lines]",
          "243: static void cmd_parse_expunge(struct ImapMboxData *mdata, const char *s)",
          "250:   if (mutt_str_atoui(s, &exp_msn) < 0 || exp_msn < 1 || exp_msn > mdata->max_msn)",
          "253:   e = mdata->msn_index[exp_msn - 1];",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "261:   }",
          "265:   {",
          "267:     if (e)",
          "268:       HEADER_DATA(e)->msn--;",
          "270:   }",
          "276: }",
          "287: {",
          "288:   bool earlier = false;",
          "289:   int rc;",
          "",
          "[Removed Lines]",
          "264:   for (unsigned int cur = exp_msn; cur < idata->max_msn; cur++)",
          "266:     e = idata->msn_index[cur];",
          "269:     idata->msn_index[cur - 1] = e;",
          "272:   idata->msn_index[idata->max_msn - 1] = NULL;",
          "273:   idata->max_msn--;",
          "275:   idata->reopen |= IMAP_EXPUNGE_PENDING;",
          "286: static void cmd_parse_vanished(struct ImapData *idata, char *s)",
          "",
          "[Added Lines]",
          "264:   for (unsigned int cur = exp_msn; cur < mdata->max_msn; cur++)",
          "266:     e = mdata->msn_index[cur];",
          "269:     mdata->msn_index[cur - 1] = e;",
          "272:   mdata->msn_index[mdata->max_msn - 1] = NULL;",
          "273:   mdata->max_msn--;",
          "275:   mdata->reopen |= IMAP_EXPUNGE_PENDING;",
          "286: static void cmd_parse_vanished(struct ImapMboxData *mdata, char *s)",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "318:   while ((rc = mutt_seqset_iterator_next(iter, &uid)) == 0)",
          "319:   {",
          "321:     if (!e)",
          "322:       continue;",
          "",
          "[Removed Lines]",
          "320:     struct Email *e = mutt_hash_int_find(idata->uid_hash, uid);",
          "",
          "[Added Lines]",
          "320:     struct Email *e = mutt_hash_int_find(mdata->uid_hash, uid);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "329:     e->index = INT_MAX;",
          "330:     HEADER_DATA(e)->msn = 0;",
          "333:     {",
          "334:       mutt_debug(1, \"VANISHED: msn for UID %u is incorrect.\\n\", uid);",
          "335:       continue;",
          "336:     }",
          "338:     {",
          "339:       mutt_debug(1, \"VANISHED: msn_index for UID %u is incorrect.\\n\", uid);",
          "340:       continue;",
          "341:     }",
          "345:     if (!earlier)",
          "346:     {",
          "349:       {",
          "351:         if (e)",
          "352:           HEADER_DATA(e)->msn--;",
          "354:       }",
          "358:     }",
          "359:   }",
          "361:   if (rc < 0)",
          "362:     mutt_debug(1, \"VANISHED: illegal seqset %s\\n\", s);",
          "366:   mutt_seqset_iterator_free(&iter);",
          "367: }",
          "379: {",
          "380:   unsigned int msn, uid;",
          "381:   struct Email *e = NULL;",
          "",
          "[Removed Lines]",
          "332:     if ((exp_msn < 1) || (exp_msn > idata->max_msn))",
          "337:     if (idata->msn_index[exp_msn - 1] != e)",
          "343:     idata->msn_index[exp_msn - 1] = NULL;",
          "348:       for (unsigned int cur = exp_msn; cur < idata->max_msn; cur++)",
          "350:         e = idata->msn_index[cur];",
          "353:         idata->msn_index[cur - 1] = e;",
          "356:       idata->msn_index[idata->max_msn - 1] = NULL;",
          "357:       idata->max_msn--;",
          "364:   idata->reopen |= IMAP_EXPUNGE_PENDING;",
          "378: static void cmd_parse_fetch(struct ImapData *idata, char *s)",
          "",
          "[Added Lines]",
          "332:     if ((exp_msn < 1) || (exp_msn > mdata->max_msn))",
          "337:     if (mdata->msn_index[exp_msn - 1] != e)",
          "343:     mdata->msn_index[exp_msn - 1] = NULL;",
          "348:       for (unsigned int cur = exp_msn; cur < mdata->max_msn; cur++)",
          "350:         e = mdata->msn_index[cur];",
          "353:         mdata->msn_index[cur - 1] = e;",
          "356:       mdata->msn_index[mdata->max_msn - 1] = NULL;",
          "357:       mdata->max_msn--;",
          "364:   mdata->reopen |= IMAP_EXPUNGE_PENDING;",
          "378: static void cmd_parse_fetch(struct ImapMboxData *mdata, char *s)",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "391:     return;",
          "392:   }",
          "395:   {",
          "396:     mutt_debug(3, \"Skipping FETCH response - MSN %u out of range\\n\", msn);",
          "397:     return;",
          "398:   }",
          "401:   if (!e || !e->active)",
          "402:   {",
          "403:     mutt_debug(3, \"Skipping FETCH response - MSN %u not in msn_index\\n\", msn);",
          "",
          "[Removed Lines]",
          "394:   if ((msn < 1) || (msn > idata->max_msn))",
          "400:   e = idata->msn_index[msn - 1];",
          "",
          "[Added Lines]",
          "394:   if ((msn < 1) || (msn > mdata->max_msn))",
          "400:   e = mdata->msn_index[msn - 1];",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "495:   if (flags)",
          "496:   {",
          "498:     if (server_changes)",
          "499:     {",
          "501:       if (e->changed)",
          "503:       else",
          "505:     }",
          "506:   }",
          "507: }",
          "515: {",
          "516:   mutt_debug(3, \"Handling CAPABILITY\\n\");",
          "",
          "[Removed Lines]",
          "497:     imap_set_flags(idata, e, flags, &server_changes);",
          "502:         idata->reopen |= IMAP_EXPUNGE_PENDING;",
          "504:         idata->check_status = IMAP_FLAGS_PENDING;",
          "514: static void cmd_parse_capability(struct ImapData *idata, char *s)",
          "",
          "[Added Lines]",
          "497:     imap_set_flags(mdata, e, flags, &server_changes);",
          "502:         mdata->reopen |= IMAP_EXPUNGE_PENDING;",
          "504:         mdata->check_status = IMAP_FLAGS_PENDING;",
          "514: static void cmd_parse_capability(struct ImapMboxData *mdata, char *s)",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "519:   char *bracket = strchr(s, ']');",
          "520:   if (bracket)",
          "527:   while (*s)",
          "528:   {",
          "",
          "[Removed Lines]",
          "522:   FREE(&idata->capstr);",
          "523:   idata->capstr = mutt_str_strdup(s);",
          "525:   memset(idata->capabilities, 0, sizeof(idata->capabilities));",
          "",
          "[Added Lines]",
          "522:   FREE(&mdata->capstr);",
          "523:   mdata->capstr = mutt_str_strdup(s);",
          "525:   memset(mdata->capabilities, 0, sizeof(mdata->capabilities));",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "530:     {",
          "531:       if (mutt_str_word_casecmp(Capabilities[i], s) == 0)",
          "532:       {",
          "534:         mutt_debug(4, \" Found capability \\\"%s\\\": %d\\n\", Capabilities[i], i);",
          "535:         break;",
          "536:       }",
          "",
          "[Removed Lines]",
          "533:         mutt_bit_set(idata->capabilities, i);",
          "",
          "[Added Lines]",
          "533:         mutt_bit_set(mdata->capabilities, i);",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "548: {",
          "549:   struct ImapList *list = NULL;",
          "550:   struct ImapList lb;",
          "552:   unsigned int litlen;",
          "556:   else",
          "557:     list = &lb;",
          "",
          "[Removed Lines]",
          "547: static void cmd_parse_list(struct ImapData *idata, char *s)",
          "554:   if (idata->cmddata && idata->cmdtype == IMAP_CT_LIST)",
          "555:     list = idata->cmddata;",
          "",
          "[Added Lines]",
          "547: static void cmd_parse_list(struct ImapMboxData *mdata, char *s)",
          "554:   if (mdata->cmddata && mdata->cmdtype == IMAP_CT_LIST)",
          "555:     list = mdata->cmddata;",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "596:   if (imap_get_literal_count(s, &litlen) == 0)",
          "597:   {",
          "599:     {",
          "601:       return;",
          "602:     }",
          "604:   }",
          "605:   else",
          "606:   {",
          "608:     list->name = s;",
          "609:   }",
          "611:   if (list->name[0] == '\\0')",
          "612:   {",
          "615:   }",
          "616: }",
          "624: {",
          "625:   char buf[STRING];",
          "626:   char errstr[STRING];",
          "",
          "[Removed Lines]",
          "598:     if (imap_cmd_step(idata) != IMAP_CMD_CONTINUE)",
          "600:       idata->status = IMAP_FATAL;",
          "603:     list->name = idata->buf;",
          "607:     imap_unmunge_mbox_name(idata, s);",
          "613:     idata->delim = list->delim;",
          "614:     mutt_debug(3, \"Root delimiter: %c\\n\", idata->delim);",
          "623: static void cmd_parse_lsub(struct ImapData *idata, char *s)",
          "",
          "[Added Lines]",
          "598:     if (imap_cmd_step(mdata) != IMAP_CMD_CONTINUE)",
          "600:       mdata->status = IMAP_FATAL;",
          "603:     list->name = mdata->buf;",
          "607:     imap_unmunge_mbox_name(mdata, s);",
          "613:     mdata->delim = list->delim;",
          "614:     mutt_debug(3, \"Root delimiter: %c\\n\", mdata->delim);",
          "623: static void cmd_parse_lsub(struct ImapMboxData *mdata, char *s)",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "628:   struct Url url;",
          "629:   struct ImapList list;",
          "632:   {",
          "635:     return;",
          "636:   }",
          "638:   if (!ImapCheckSubscribed)",
          "639:     return;",
          "646:   if (!list.name || list.noselect)",
          "647:     return;",
          "",
          "[Removed Lines]",
          "631:   if (idata->cmddata && idata->cmdtype == IMAP_CT_LIST)",
          "634:     cmd_parse_list(idata, s);",
          "641:   idata->cmdtype = IMAP_CT_LIST;",
          "642:   idata->cmddata = &list;",
          "643:   cmd_parse_list(idata, s);",
          "644:   idata->cmddata = NULL;",
          "",
          "[Added Lines]",
          "631:   if (mdata->cmddata && mdata->cmdtype == IMAP_CT_LIST)",
          "634:     cmd_parse_list(mdata, s);",
          "641:   mdata->cmdtype = IMAP_CT_LIST;",
          "642:   mdata->cmddata = &list;",
          "643:   cmd_parse_list(mdata, s);",
          "644:   mdata->cmddata = NULL;",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "649:   mutt_debug(3, \"Subscribing to %s\\n\", list.name);",
          "651:   mutt_str_strfcpy(buf, \"mailboxes \\\"\", sizeof(buf));",
          "654:   imap_quote_string(errstr, sizeof(errstr), list.name, true);",
          "655:   url.path = errstr + 1;",
          "",
          "[Removed Lines]",
          "652:   mutt_account_tourl(&idata->conn->account, &url);",
          "",
          "[Added Lines]",
          "652:   mutt_account_tourl(&mdata->conn->account, &url);",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "676: {",
          "677:   mutt_debug(2, \"Handling MYRIGHTS\\n\");",
          "",
          "[Removed Lines]",
          "675: static void cmd_parse_myrights(struct ImapData *idata, const char *s)",
          "",
          "[Added Lines]",
          "675: static void cmd_parse_myrights(struct ImapMboxData *mdata, const char *s)",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "680:   s = imap_next_word((char *) s);",
          "685:   while (*s && !isspace((unsigned char) *s))",
          "686:   {",
          "687:     switch (*s)",
          "688:     {",
          "689:       case 'a':",
          "691:         break;",
          "692:       case 'e':",
          "694:         break;",
          "695:       case 'i':",
          "697:         break;",
          "698:       case 'k':",
          "700:         break;",
          "701:       case 'l':",
          "703:         break;",
          "704:       case 'p':",
          "706:         break;",
          "707:       case 'r':",
          "709:         break;",
          "710:       case 's':",
          "712:         break;",
          "713:       case 't':",
          "715:         break;",
          "716:       case 'w':",
          "718:         break;",
          "719:       case 'x':",
          "721:         break;",
          "724:       case 'c':",
          "727:         break;",
          "728:       case 'd':",
          "731:         break;",
          "732:       default:",
          "733:         mutt_debug(1, \"Unknown right: %c\\n\", *s);",
          "",
          "[Removed Lines]",
          "683:   memset(idata->ctx->mailbox->rights, 0, sizeof(idata->ctx->mailbox->rights));",
          "690:         mutt_bit_set(idata->ctx->mailbox->rights, MUTT_ACL_ADMIN);",
          "693:         mutt_bit_set(idata->ctx->mailbox->rights, MUTT_ACL_EXPUNGE);",
          "696:         mutt_bit_set(idata->ctx->mailbox->rights, MUTT_ACL_INSERT);",
          "699:         mutt_bit_set(idata->ctx->mailbox->rights, MUTT_ACL_CREATE);",
          "702:         mutt_bit_set(idata->ctx->mailbox->rights, MUTT_ACL_LOOKUP);",
          "705:         mutt_bit_set(idata->ctx->mailbox->rights, MUTT_ACL_POST);",
          "708:         mutt_bit_set(idata->ctx->mailbox->rights, MUTT_ACL_READ);",
          "711:         mutt_bit_set(idata->ctx->mailbox->rights, MUTT_ACL_SEEN);",
          "714:         mutt_bit_set(idata->ctx->mailbox->rights, MUTT_ACL_DELETE);",
          "717:         mutt_bit_set(idata->ctx->mailbox->rights, MUTT_ACL_WRITE);",
          "720:         mutt_bit_set(idata->ctx->mailbox->rights, MUTT_ACL_DELMX);",
          "725:         mutt_bit_set(idata->ctx->mailbox->rights, MUTT_ACL_CREATE);",
          "726:         mutt_bit_set(idata->ctx->mailbox->rights, MUTT_ACL_DELMX);",
          "729:         mutt_bit_set(idata->ctx->mailbox->rights, MUTT_ACL_DELETE);",
          "730:         mutt_bit_set(idata->ctx->mailbox->rights, MUTT_ACL_EXPUNGE);",
          "",
          "[Added Lines]",
          "683:   memset(mdata->ctx->mailbox->rights, 0, sizeof(mdata->ctx->mailbox->rights));",
          "690:         mutt_bit_set(mdata->ctx->mailbox->rights, MUTT_ACL_ADMIN);",
          "693:         mutt_bit_set(mdata->ctx->mailbox->rights, MUTT_ACL_EXPUNGE);",
          "696:         mutt_bit_set(mdata->ctx->mailbox->rights, MUTT_ACL_INSERT);",
          "699:         mutt_bit_set(mdata->ctx->mailbox->rights, MUTT_ACL_CREATE);",
          "702:         mutt_bit_set(mdata->ctx->mailbox->rights, MUTT_ACL_LOOKUP);",
          "705:         mutt_bit_set(mdata->ctx->mailbox->rights, MUTT_ACL_POST);",
          "708:         mutt_bit_set(mdata->ctx->mailbox->rights, MUTT_ACL_READ);",
          "711:         mutt_bit_set(mdata->ctx->mailbox->rights, MUTT_ACL_SEEN);",
          "714:         mutt_bit_set(mdata->ctx->mailbox->rights, MUTT_ACL_DELETE);",
          "717:         mutt_bit_set(mdata->ctx->mailbox->rights, MUTT_ACL_WRITE);",
          "720:         mutt_bit_set(mdata->ctx->mailbox->rights, MUTT_ACL_DELMX);",
          "725:         mutt_bit_set(mdata->ctx->mailbox->rights, MUTT_ACL_CREATE);",
          "726:         mutt_bit_set(mdata->ctx->mailbox->rights, MUTT_ACL_DELMX);",
          "729:         mutt_bit_set(mdata->ctx->mailbox->rights, MUTT_ACL_DELETE);",
          "730:         mutt_bit_set(mdata->ctx->mailbox->rights, MUTT_ACL_EXPUNGE);",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "745: {",
          "746:   unsigned int uid;",
          "747:   struct Email *e = NULL;",
          "",
          "[Removed Lines]",
          "744: static void cmd_parse_search(struct ImapData *idata, const char *s)",
          "",
          "[Added Lines]",
          "744: static void cmd_parse_search(struct ImapMboxData *mdata, const char *s)",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "752:   {",
          "753:     if (mutt_str_atoui(s, &uid) < 0)",
          "754:       continue;",
          "756:     if (e)",
          "757:       e->matched = true;",
          "758:   }",
          "",
          "[Removed Lines]",
          "755:     e = mutt_hash_int_find(idata->uid_hash, uid);",
          "",
          "[Added Lines]",
          "755:     e = mutt_hash_int_find(mdata->uid_hash, uid);",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "770: {",
          "771:   char *value = NULL;",
          "772:   struct ImapMbox mx;",
          "",
          "[Removed Lines]",
          "769: static void cmd_parse_status(struct ImapData *idata, char *s)",
          "",
          "[Added Lines]",
          "769: static void cmd_parse_status(struct ImapMboxData *mdata, char *s)",
          "",
          "---------------",
          "--- Hunk 21 ---",
          "[Context before]",
          "782:   if (imap_get_literal_count(mailbox, &litlen) == 0)",
          "783:   {",
          "785:     {",
          "787:       return;",
          "788:     }",
          "791:     {",
          "792:       mutt_debug(1, \"Error parsing STATUS mailbox\\n\");",
          "793:       return;",
          "794:     }",
          "797:     s = mailbox + litlen;",
          "799:     s++;",
          "",
          "[Removed Lines]",
          "784:     if (imap_cmd_step(idata) != IMAP_CMD_CONTINUE)",
          "786:       idata->status = IMAP_FATAL;",
          "790:     if (strlen(idata->buf) < litlen)",
          "796:     mailbox = idata->buf;",
          "",
          "[Added Lines]",
          "784:     if (imap_cmd_step(mdata) != IMAP_CMD_CONTINUE)",
          "786:       mdata->status = IMAP_FATAL;",
          "790:     if (strlen(mdata->buf) < litlen)",
          "796:     mailbox = mdata->buf;",
          "",
          "---------------",
          "--- Hunk 22 ---",
          "[Context before]",
          "803:   {",
          "804:     s = imap_next_word(mailbox);",
          "807:   }",
          "810:   olduv = status->uidvalidity;",
          "811:   oldun = status->uidnext;",
          "",
          "[Removed Lines]",
          "806:     imap_unmunge_mbox_name(idata, mailbox);",
          "809:   status = imap_mboxcache_get(idata, mailbox, 1);",
          "",
          "[Added Lines]",
          "806:     imap_unmunge_mbox_name(mdata, mailbox);",
          "809:   status = imap_mboxcache_get(mdata, mailbox, 1);",
          "",
          "---------------",
          "--- Hunk 23 ---",
          "[Context before]",
          "851:              status->messages, status->recent, status->unseen);",
          "855:   {",
          "857:     return;",
          "858:   }",
          "",
          "[Removed Lines]",
          "854:   if (idata->cmddata && idata->cmdtype == IMAP_CT_STATUS)",
          "856:     memcpy(idata->cmddata, status, sizeof(struct ImapStatus));",
          "",
          "[Added Lines]",
          "854:   if (mdata->cmddata && mdata->cmdtype == IMAP_CT_STATUS)",
          "856:     memcpy(mdata->cmddata, status, sizeof(struct ImapStatus));",
          "",
          "---------------",
          "--- Hunk 24 ---",
          "[Context before]",
          "872:       continue;",
          "873:     }",
          "876:     {",
          "877:       if (mx.mbox)",
          "878:       {",
          "879:         value = mutt_str_strdup(mx.mbox);",
          "881:         FREE(&mx.mbox);",
          "882:       }",
          "883:       else",
          "",
          "[Removed Lines]",
          "875:     if (imap_account_match(&idata->conn->account, &mx.account))",
          "880:         imap_fix_path(idata, mx.mbox, value, mutt_str_strlen(value) + 1);",
          "",
          "[Added Lines]",
          "875:     if (imap_account_match(&mdata->conn->account, &mx.account))",
          "880:         imap_fix_path(mdata, mx.mbox, value, mutt_str_strlen(value) + 1);",
          "",
          "---------------",
          "--- Hunk 25 ---",
          "[Context before]",
          "945: {",
          "946:   mutt_debug(2, \"Handling ENABLED\\n\");",
          "",
          "[Removed Lines]",
          "944: static void cmd_parse_enabled(struct ImapData *idata, const char *s)",
          "",
          "[Added Lines]",
          "944: static void cmd_parse_enabled(struct ImapMboxData *mdata, const char *s)",
          "",
          "---------------",
          "--- Hunk 26 ---",
          "[Context before]",
          "950:     if ((mutt_str_strncasecmp(s, \"UTF8=ACCEPT\", 11) == 0) ||",
          "951:         (mutt_str_strncasecmp(s, \"UTF8=ONLY\", 9) == 0))",
          "952:     {",
          "954:     }",
          "955:     if (mutt_str_strncasecmp(s, \"QRESYNC\", 7) == 0)",
          "957:   }",
          "958: }",
          "967: {",
          "968:   unsigned int count = 0;",
          "970:   char *pn = imap_next_word(s);",
          "973:   {",
          "974:     pn = s;",
          "975:     s = imap_next_word(s);",
          "",
          "[Removed Lines]",
          "953:       idata->unicode = 1;",
          "956:       idata->qresync = 1;",
          "966: static int cmd_handle_untagged(struct ImapData *idata)",
          "969:   char *s = imap_next_word(idata->buf);",
          "972:   if ((idata->state >= IMAP_SELECTED) && isdigit((unsigned char) *s))",
          "",
          "[Added Lines]",
          "953:       mdata->unicode = 1;",
          "956:       mdata->qresync = 1;",
          "966: static int cmd_handle_untagged(struct ImapMboxData *mdata)",
          "969:   char *s = imap_next_word(mdata->buf);",
          "972:   if ((mdata->state >= IMAP_SELECTED) && isdigit((unsigned char) *s))",
          "",
          "---------------",
          "--- Hunk 27 ---",
          "[Context before]",
          "987:         mutt_debug(1, \"Malformed EXISTS: '%s'\\n\", pn);",
          "988:       }",
          "991:       {",
          "",
          "[Removed Lines]",
          "990:       if (!(idata->reopen & IMAP_EXPUNGE_PENDING) && count < idata->max_msn)",
          "",
          "[Added Lines]",
          "990:       if (!(mdata->reopen & IMAP_EXPUNGE_PENDING) && count < mdata->max_msn)",
          "",
          "---------------",
          "--- Hunk 28 ---",
          "[Context before]",
          "996:       }",
          "1000:         mutt_debug(3, \"superfluous EXISTS message.\\n\");",
          "1001:       else",
          "1002:       {",
          "1004:         {",
          "1007:         }",
          "1009:       }",
          "1010:     }",
          "1012:     else if (mutt_str_strncasecmp(\"EXPUNGE\", s, 7) == 0)",
          "1014:     else if (mutt_str_strncasecmp(\"FETCH\", s, 5) == 0)",
          "1016:   }",
          "1019:   else if (mutt_str_strncasecmp(\"CAPABILITY\", s, 10) == 0)",
          "1021:   else if (mutt_str_strncasecmp(\"OK [CAPABILITY\", s, 14) == 0)",
          "1023:   else if (mutt_str_strncasecmp(\"OK [CAPABILITY\", pn, 14) == 0)",
          "1025:   else if (mutt_str_strncasecmp(\"LIST\", s, 4) == 0)",
          "1027:   else if (mutt_str_strncasecmp(\"LSUB\", s, 4) == 0)",
          "1029:   else if (mutt_str_strncasecmp(\"MYRIGHTS\", s, 8) == 0)",
          "1031:   else if (mutt_str_strncasecmp(\"SEARCH\", s, 6) == 0)",
          "1033:   else if (mutt_str_strncasecmp(\"STATUS\", s, 6) == 0)",
          "1035:   else if (mutt_str_strncasecmp(\"ENABLED\", s, 7) == 0)",
          "1037:   else if (mutt_str_strncasecmp(\"BYE\", s, 3) == 0)",
          "1038:   {",
          "1039:     mutt_debug(2, \"Handling BYE\\n\");",
          "1043:       return 0;",
          "1046:     s += 3;",
          "1047:     SKIPWS(s);",
          "1048:     mutt_error(\"%s\", s);",
          "1051:     return -1;",
          "1052:   }",
          "",
          "[Removed Lines]",
          "999:       else if (count == idata->max_msn)",
          "1003:         if (!(idata->reopen & IMAP_EXPUNGE_PENDING))",
          "1005:           mutt_debug(2, \"New mail in %s - %d messages total.\\n\", idata->mbox_name, count);",
          "1006:           idata->reopen |= IMAP_NEWMAIL_PENDING;",
          "1008:         idata->new_mail_count = count;",
          "1013:       cmd_parse_expunge(idata, pn);",
          "1015:       cmd_parse_fetch(idata, pn);",
          "1017:   else if ((idata->state >= IMAP_SELECTED) && (mutt_str_strncasecmp(\"VANISHED\", s, 8) == 0))",
          "1018:     cmd_parse_vanished(idata, pn);",
          "1020:     cmd_parse_capability(idata, s);",
          "1022:     cmd_parse_capability(idata, pn);",
          "1024:     cmd_parse_capability(idata, imap_next_word(pn));",
          "1026:     cmd_parse_list(idata, s);",
          "1028:     cmd_parse_lsub(idata, s);",
          "1030:     cmd_parse_myrights(idata, s);",
          "1032:     cmd_parse_search(idata, s);",
          "1034:     cmd_parse_status(idata, s);",
          "1036:     cmd_parse_enabled(idata, s);",
          "1042:     if (idata->status == IMAP_BYE)",
          "1049:     cmd_handle_fatal(idata);",
          "",
          "[Added Lines]",
          "999:       else if (count == mdata->max_msn)",
          "1003:         if (!(mdata->reopen & IMAP_EXPUNGE_PENDING))",
          "1005:           mutt_debug(2, \"New mail in %s - %d messages total.\\n\", mdata->mbox_name, count);",
          "1006:           mdata->reopen |= IMAP_NEWMAIL_PENDING;",
          "1008:         mdata->new_mail_count = count;",
          "1013:       cmd_parse_expunge(mdata, pn);",
          "1015:       cmd_parse_fetch(mdata, pn);",
          "1017:   else if ((mdata->state >= IMAP_SELECTED) && (mutt_str_strncasecmp(\"VANISHED\", s, 8) == 0))",
          "1018:     cmd_parse_vanished(mdata, pn);",
          "1020:     cmd_parse_capability(mdata, s);",
          "1022:     cmd_parse_capability(mdata, pn);",
          "1024:     cmd_parse_capability(mdata, imap_next_word(pn));",
          "1026:     cmd_parse_list(mdata, s);",
          "1028:     cmd_parse_lsub(mdata, s);",
          "1030:     cmd_parse_myrights(mdata, s);",
          "1032:     cmd_parse_search(mdata, s);",
          "1034:     cmd_parse_status(mdata, s);",
          "1036:     cmd_parse_enabled(mdata, s);",
          "1042:     if (mdata->status == IMAP_BYE)",
          "1049:     cmd_handle_fatal(mdata);",
          "",
          "---------------",
          "--- Hunk 29 ---",
          "[Context before]",
          "1074: {",
          "1076: }",
          "1088: {",
          "1089:   size_t len = 0;",
          "1090:   int c;",
          "",
          "[Removed Lines]",
          "1073: int imap_cmd_start(struct ImapData *idata, const char *cmdstr)",
          "1075:   return cmd_start(idata, cmdstr, 0);",
          "1087: int imap_cmd_step(struct ImapData *idata)",
          "",
          "[Added Lines]",
          "1073: int imap_cmd_start(struct ImapMboxData *mdata, const char *cmdstr)",
          "1075:   return cmd_start(mdata, cmdstr, 0);",
          "1087: int imap_cmd_step(struct ImapMboxData *mdata)",
          "",
          "---------------",
          "--- Hunk 30 ---",
          "[Context before]",
          "1092:   int stillrunning = 0;",
          "1093:   struct ImapCommand *cmd = NULL;",
          "1096:   {",
          "1098:     return IMAP_CMD_BAD;",
          "1099:   }",
          "",
          "[Removed Lines]",
          "1095:   if (idata->status == IMAP_FATAL)",
          "1097:     cmd_handle_fatal(idata);",
          "",
          "[Added Lines]",
          "1095:   if (mdata->status == IMAP_FATAL)",
          "1097:     cmd_handle_fatal(mdata);",
          "",
          "---------------",
          "--- Hunk 31 ---",
          "[Context before]",
          "1103:   do",
          "1104:   {",
          "1106:     {",
          "1110:     }",
          "1113:     if (len)",
          "1114:       len--;",
          "1116:     if (c <= 0)",
          "1117:     {",
          "1118:       mutt_debug(1, \"Error reading server response.\\n\");",
          "1120:       return IMAP_CMD_BAD;",
          "1121:     }",
          "",
          "[Removed Lines]",
          "1105:     if (len == idata->blen)",
          "1107:       mutt_mem_realloc(&idata->buf, idata->blen + IMAP_CMD_BUFSIZE);",
          "1108:       idata->blen = idata->blen + IMAP_CMD_BUFSIZE;",
          "1109:       mutt_debug(3, \"grew buffer to %u bytes\\n\", idata->blen);",
          "1115:     c = mutt_socket_readln(idata->buf + len, idata->blen - len, idata->conn);",
          "1119:       cmd_handle_fatal(idata);",
          "",
          "[Added Lines]",
          "1105:     if (len == mdata->blen)",
          "1107:       mutt_mem_realloc(&mdata->buf, mdata->blen + IMAP_CMD_BUFSIZE);",
          "1108:       mdata->blen = mdata->blen + IMAP_CMD_BUFSIZE;",
          "1109:       mutt_debug(3, \"grew buffer to %u bytes\\n\", mdata->blen);",
          "1115:     c = mutt_socket_readln(mdata->buf + len, mdata->blen - len, mdata->conn);",
          "1119:       cmd_handle_fatal(mdata);",
          "",
          "---------------",
          "--- Hunk 32 ---",
          "[Context before]",
          "1132:   {",
          "1136:   }",
          "1144:   {",
          "1145:     return IMAP_CMD_BAD;",
          "1146:   }",
          "1150:     return IMAP_CMD_RESPOND;",
          "",
          "[Removed Lines]",
          "1128:   while (len == idata->blen);",
          "1131:   if ((idata->blen > IMAP_CMD_BUFSIZE) && (len <= IMAP_CMD_BUFSIZE))",
          "1133:     mutt_mem_realloc(&idata->buf, IMAP_CMD_BUFSIZE);",
          "1134:     idata->blen = IMAP_CMD_BUFSIZE;",
          "1135:     mutt_debug(3, \"shrank buffer to %u bytes\\n\", idata->blen);",
          "1138:   idata->lastread = time(NULL);",
          "1141:   if (((mutt_str_strncmp(idata->buf, \"* \", 2) == 0) ||",
          "1142:        (mutt_str_strncmp(imap_next_word(idata->buf), \"OK [\", 4) == 0)) &&",
          "1143:       cmd_handle_untagged(idata))",
          "1149:   if (idata->buf[0] == '+')",
          "",
          "[Added Lines]",
          "1128:   while (len == mdata->blen);",
          "1131:   if ((mdata->blen > IMAP_CMD_BUFSIZE) && (len <= IMAP_CMD_BUFSIZE))",
          "1133:     mutt_mem_realloc(&mdata->buf, IMAP_CMD_BUFSIZE);",
          "1134:     mdata->blen = IMAP_CMD_BUFSIZE;",
          "1135:     mutt_debug(3, \"shrank buffer to %u bytes\\n\", mdata->blen);",
          "1138:   mdata->lastread = time(NULL);",
          "1141:   if (((mutt_str_strncmp(mdata->buf, \"* \", 2) == 0) ||",
          "1142:        (mutt_str_strncmp(imap_next_word(mdata->buf), \"OK [\", 4) == 0)) &&",
          "1143:       cmd_handle_untagged(mdata))",
          "1149:   if (mdata->buf[0] == '+')",
          "",
          "---------------",
          "--- Hunk 33 ---",
          "[Context before]",
          "1162:   rc = IMAP_CMD_OK;",
          "1164:   do",
          "1165:   {",
          "1167:     if (cmd->state == IMAP_CMD_NEW)",
          "1168:     {",
          "1170:       {",
          "1171:         if (!stillrunning)",
          "1172:         {",
          "1175:         }",
          "1179:         rc = cmd->state;",
          "",
          "[Removed Lines]",
          "1163:   c = idata->lastcmd;",
          "1166:     cmd = &idata->cmds[c];",
          "1169:       if (mutt_str_strncmp(idata->buf, cmd->seq, SEQLEN) == 0)",
          "1174:           idata->lastcmd = (idata->lastcmd + 1) % idata->cmdslots;",
          "1176:         cmd->state = cmd_status(idata->buf);",
          "",
          "[Added Lines]",
          "1163:   c = mdata->lastcmd;",
          "1166:     cmd = &mdata->cmds[c];",
          "1169:       if (mutt_str_strncmp(mdata->buf, cmd->seq, SEQLEN) == 0)",
          "1174:           mdata->lastcmd = (mdata->lastcmd + 1) % mdata->cmdslots;",
          "1176:         cmd->state = cmd_status(mdata->buf);",
          "",
          "---------------",
          "--- Hunk 34 ---",
          "[Context before]",
          "1182:         stillrunning++;",
          "1183:     }",
          "1188:   if (stillrunning)",
          "1189:     rc = IMAP_CMD_CONTINUE;",
          "1190:   else",
          "1191:   {",
          "1192:     mutt_debug(3, \"IMAP queue drained\\n\");",
          "1194:   }",
          "1196:   return rc;",
          "",
          "[Removed Lines]",
          "1185:     c = (c + 1) % idata->cmdslots;",
          "1186:   } while (c != idata->nextcmd);",
          "1193:     imap_cmd_finish(idata);",
          "",
          "[Added Lines]",
          "1185:     c = (c + 1) % mdata->cmdslots;",
          "1186:   } while (c != mdata->nextcmd);",
          "1193:     imap_cmd_finish(mdata);",
          "",
          "---------------",
          "--- Hunk 35 ---",
          "[Context before]",
          "1217: {",
          "1218:   static const char *notrailer = \"\";",
          "1221:   if (!s)",
          "1222:   {",
          "",
          "[Removed Lines]",
          "1216: const char *imap_cmd_trailer(struct ImapData *idata)",
          "1219:   const char *s = idata->buf;",
          "",
          "[Added Lines]",
          "1216: const char *imap_cmd_trailer(struct ImapMboxData *mdata)",
          "1219:   const char *s = mdata->buf;",
          "",
          "---------------",
          "--- Hunk 36 ---",
          "[Context before]",
          "1229:              (mutt_str_strncasecmp(s, \"NO\", 2) != 0) &&",
          "1230:              (mutt_str_strncasecmp(s, \"BAD\", 3) != 0)))",
          "1231:   {",
          "1233:     return notrailer;",
          "1234:   }",
          "",
          "[Removed Lines]",
          "1232:     mutt_debug(2, \"not a command completion: %s\\n\", idata->buf);",
          "",
          "[Added Lines]",
          "1232:     mutt_debug(2, \"not a command completion: %s\\n\", mdata->buf);",
          "",
          "---------------",
          "--- Hunk 37 ---",
          "[Context before]",
          "1262: {",
          "1263:   int rc;",
          "1266:   if (rc < 0)",
          "1267:   {",
          "1269:     return -1;",
          "1270:   }",
          "",
          "[Removed Lines]",
          "1261: int imap_exec(struct ImapData *idata, const char *cmdstr, int flags)",
          "1265:   rc = cmd_start(idata, cmdstr, flags);",
          "1268:     cmd_handle_fatal(idata);",
          "",
          "[Added Lines]",
          "1261: int imap_exec(struct ImapMboxData *mdata, const char *cmdstr, int flags)",
          "1265:   rc = cmd_start(mdata, cmdstr, flags);",
          "1268:     cmd_handle_fatal(mdata);",
          "",
          "---------------",
          "--- Hunk 38 ---",
          "[Context before]",
          "1273:     return 0;",
          "1275:   if ((flags & IMAP_CMD_POLL) && (ImapPollTimeout > 0) &&",
          "1277:   {",
          "1280:     return -1;",
          "1281:   }",
          "1284:   mutt_sig_allow_interrupt(1);",
          "1285:   do",
          "1287:   while (rc == IMAP_CMD_CONTINUE);",
          "1288:   mutt_sig_allow_interrupt(0);",
          "",
          "[Removed Lines]",
          "1276:       (mutt_socket_poll(idata->conn, ImapPollTimeout)) == 0)",
          "1278:     mutt_error(_(\"Connection to %s timed out\"), idata->conn->account.host);",
          "1279:     cmd_handle_fatal(idata);",
          "1286:     rc = imap_cmd_step(idata);",
          "",
          "[Added Lines]",
          "1276:       (mutt_socket_poll(mdata->conn, ImapPollTimeout)) == 0)",
          "1278:     mutt_error(_(\"Connection to %s timed out\"), mdata->conn->account.host);",
          "1279:     cmd_handle_fatal(mdata);",
          "1286:     rc = imap_cmd_step(mdata);",
          "",
          "---------------",
          "--- Hunk 39 ---",
          "[Context before]",
          "1293:   if (rc != IMAP_CMD_OK)",
          "1294:   {",
          "1296:       return -2;",
          "1299:     return -1;",
          "1300:   }",
          "",
          "[Removed Lines]",
          "1295:     if ((flags & IMAP_CMD_FAIL_OK) && idata->status != IMAP_FATAL)",
          "1298:     mutt_debug(1, \"command failed: %s\\n\", idata->buf);",
          "",
          "[Added Lines]",
          "1295:     if ((flags & IMAP_CMD_FAIL_OK) && mdata->status != IMAP_FATAL)",
          "1298:     mutt_debug(1, \"command failed: %s\\n\", mdata->buf);",
          "",
          "---------------",
          "--- Hunk 40 ---",
          "[Context before]",
          "1315: {",
          "1317:   {",
          "1319:     return;",
          "1320:   }",
          "1323:     return;",
          "1326:   {",
          "1331:     {",
          "1333:       mutt_debug(2, \"Fetching new mail\\n\");",
          "1338:     }",
          "1340:     {",
          "1341:       mutt_debug(2, \"Expunging mailbox\\n\");",
          "1347:           ~(IMAP_EXPUNGE_PENDING | IMAP_NEWMAIL_PENDING | IMAP_EXPUNGE_EXPECTED);",
          "1348:     }",
          "1349:   }",
          "1352: }",
          "1361: {",
          "1362:   int rc;",
          "1365:   {",
          "1367:     return -1;",
          "1368:   }",
          "1371:   {",
          "1374:     return -1;",
          "1375:   }",
          "1377:   do",
          "1379:   while (rc == IMAP_CMD_CONTINUE);",
          "1381:   if (rc == IMAP_CMD_RESPOND)",
          "1382:   {",
          "1387:     rc = IMAP_CMD_OK;",
          "1388:   }",
          "1389:   if (rc != IMAP_CMD_OK)",
          "",
          "[Removed Lines]",
          "1314: void imap_cmd_finish(struct ImapData *idata)",
          "1316:   if (idata->status == IMAP_FATAL)",
          "1318:     cmd_handle_fatal(idata);",
          "1322:   if (!(idata->state >= IMAP_SELECTED) || idata->ctx->mailbox->closing)",
          "1325:   if (idata->reopen & IMAP_REOPEN_ALLOW)",
          "1327:     unsigned int count = idata->new_mail_count;",
          "1329:     if (!(idata->reopen & IMAP_EXPUNGE_PENDING) &&",
          "1330:         (idata->reopen & IMAP_NEWMAIL_PENDING) && count > idata->max_msn)",
          "1336:       idata->check_status = IMAP_NEWMAIL_PENDING;",
          "1337:       imap_read_headers(idata, idata->max_msn + 1, count, false);",
          "1339:     else if (idata->reopen & IMAP_EXPUNGE_PENDING)",
          "1342:       imap_expunge_mailbox(idata);",
          "1344:       if ((idata->reopen & IMAP_EXPUNGE_PENDING) && !(idata->reopen & IMAP_EXPUNGE_EXPECTED))",
          "1345:         idata->check_status = IMAP_EXPUNGE_PENDING;",
          "1346:       idata->reopen &=",
          "1351:   idata->status = false;",
          "1360: int imap_cmd_idle(struct ImapData *idata)",
          "1364:   if (cmd_start(idata, \"IDLE\", IMAP_CMD_POLL) < 0)",
          "1366:     cmd_handle_fatal(idata);",
          "1370:   if ((ImapPollTimeout > 0) && (mutt_socket_poll(idata->conn, ImapPollTimeout)) == 0)",
          "1372:     mutt_error(_(\"Connection to %s timed out\"), idata->conn->account.host);",
          "1373:     cmd_handle_fatal(idata);",
          "1378:     rc = imap_cmd_step(idata);",
          "1384:     idata->state = IMAP_IDLE;",
          "1386:     mutt_buffer_printf(idata->cmdbuf, \"DONE\\r\\n\");",
          "",
          "[Added Lines]",
          "1314: void imap_cmd_finish(struct ImapMboxData *mdata)",
          "1316:   if (mdata->status == IMAP_FATAL)",
          "1318:     cmd_handle_fatal(mdata);",
          "1322:   if (!(mdata->state >= IMAP_SELECTED) || mdata->ctx->mailbox->closing)",
          "1325:   if (mdata->reopen & IMAP_REOPEN_ALLOW)",
          "1327:     unsigned int count = mdata->new_mail_count;",
          "1329:     if (!(mdata->reopen & IMAP_EXPUNGE_PENDING) &&",
          "1330:         (mdata->reopen & IMAP_NEWMAIL_PENDING) && count > mdata->max_msn)",
          "1336:       mdata->check_status = IMAP_NEWMAIL_PENDING;",
          "1337:       imap_read_headers(mdata, mdata->max_msn + 1, count, false);",
          "1339:     else if (mdata->reopen & IMAP_EXPUNGE_PENDING)",
          "1342:       imap_expunge_mailbox(mdata);",
          "1344:       if ((mdata->reopen & IMAP_EXPUNGE_PENDING) && !(mdata->reopen & IMAP_EXPUNGE_EXPECTED))",
          "1345:         mdata->check_status = IMAP_EXPUNGE_PENDING;",
          "1346:       mdata->reopen &=",
          "1351:   mdata->status = false;",
          "1360: int imap_cmd_idle(struct ImapMboxData *mdata)",
          "1364:   if (cmd_start(mdata, \"IDLE\", IMAP_CMD_POLL) < 0)",
          "1366:     cmd_handle_fatal(mdata);",
          "1370:   if ((ImapPollTimeout > 0) && (mutt_socket_poll(mdata->conn, ImapPollTimeout)) == 0)",
          "1372:     mutt_error(_(\"Connection to %s timed out\"), mdata->conn->account.host);",
          "1373:     cmd_handle_fatal(mdata);",
          "1378:     rc = imap_cmd_step(mdata);",
          "1384:     mdata->state = IMAP_IDLE;",
          "1386:     mutt_buffer_printf(mdata->cmdbuf, \"DONE\\r\\n\");",
          "",
          "---------------"
        ],
        "imap/imap.c||imap/imap.c": [
          "File: imap/imap.c -> imap/imap.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "78: {",
          "80:   {",
          "82:     return -1;",
          "83:   }",
          "87:   {",
          "88:     mutt_error(",
          "89:         _(\"This IMAP server is ancient. NeoMutt does not work with it.\"));",
          "",
          "[Removed Lines]",
          "77: static int check_capabilities(struct ImapData *idata)",
          "79:   if (imap_exec(idata, \"CAPABILITY\", 0) != 0)",
          "81:     imap_error(\"check_capabilities\", idata->buf);",
          "85:   if (!(mutt_bit_isset(idata->capabilities, IMAP4) ||",
          "86:         mutt_bit_isset(idata->capabilities, IMAP4REV1)))",
          "",
          "[Added Lines]",
          "77: static int check_capabilities(struct ImapMboxData *mdata)",
          "79:   if (imap_exec(mdata, \"CAPABILITY\", 0) != 0)",
          "81:     imap_error(\"check_capabilities\", mdata->buf);",
          "85:   if (!(mutt_bit_isset(mdata->capabilities, IMAP4) ||",
          "86:         mutt_bit_isset(mdata->capabilities, IMAP4REV1)))",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "160:                      const char *str, char *flags, size_t flsize)",
          "161: {",
          "164:       mutt_str_strcat(flags, flsize, str);",
          "165: }",
          "",
          "[Removed Lines]",
          "159: static void set_flag(struct ImapData *idata, int aclbit, int flag,",
          "162:   if (mutt_bit_isset(idata->ctx->mailbox->rights, aclbit))",
          "163:     if (flag && imap_has_flag(&idata->flags, str))",
          "",
          "[Added Lines]",
          "159: static void set_flag(struct ImapMboxData *mdata, int aclbit, int flag,",
          "162:   if (mutt_bit_isset(mdata->ctx->mailbox->rights, aclbit))",
          "163:     if (flag && imap_has_flag(&mdata->flags, str))",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "181:                         bool changed, bool invert, int *pos)",
          "182: {",
          "185:   int n;",
          "186:   bool started = false;",
          "190:        n++)",
          "191:   {",
          "",
          "[Removed Lines]",
          "180: static int make_msg_set(struct ImapData *idata, struct Buffer *buf, int flag,",
          "187:   struct Email **emails = idata->ctx->mailbox->hdrs;",
          "189:   for (n = *pos; n < idata->ctx->mailbox->msg_count && buf->dptr - buf->data < IMAP_MAX_CMDLEN;",
          "",
          "[Added Lines]",
          "180: static int make_msg_set(struct ImapMboxData *mdata, struct Buffer *buf, int flag,",
          "187:   struct Email **emails = mdata->ctx->mailbox->hdrs;",
          "189:   for (n = *pos; n < mdata->ctx->mailbox->msg_count && buf->dptr - buf->data < IMAP_MAX_CMDLEN;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "241:           mutt_buffer_printf(buf, \",%u\", HEADER_DATA(emails[n])->uid);",
          "242:       }",
          "245:         mutt_buffer_printf(buf, \":%u\", HEADER_DATA(emails[n])->uid);",
          "246:     }",
          "250:     {",
          "251:       if (HEADER_DATA(emails[n - 1])->uid > setstart)",
          "252:         mutt_buffer_printf(buf, \":%u\", HEADER_DATA(emails[n - 1])->uid);",
          "",
          "[Removed Lines]",
          "244:       else if (n == idata->ctx->mailbox->msg_count - 1)",
          "249:     else if (setstart && (emails[n]->active || n == idata->ctx->mailbox->msg_count - 1))",
          "",
          "[Added Lines]",
          "244:       else if (n == mdata->ctx->mailbox->msg_count - 1)",
          "249:     else if (setstart && (emails[n]->active || n == mdata->ctx->mailbox->msg_count - 1))",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "270: static bool compare_flags_for_copy(struct Email *e)",
          "271: {",
          "275:     return true;",
          "277:     return true;",
          "279:     return true;",
          "281:     return true;",
          "283:   return false;",
          "",
          "[Removed Lines]",
          "272:   struct ImapHeaderData *hd = e->data;",
          "274:   if (e->read != hd->read)",
          "276:   if (e->old != hd->old)",
          "278:   if (e->flagged != hd->flagged)",
          "280:   if (e->replied != hd->replied)",
          "",
          "[Added Lines]",
          "272:   struct ImapEmailData *edata = e->data;",
          "274:   if (e->read != edata->read)",
          "276:   if (e->old != edata->old)",
          "278:   if (e->flagged != edata->flagged)",
          "280:   if (e->replied != edata->replied)",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "296: {",
          "297:   int count = 0;",
          "298:   int rc;",
          "299:   char buf[LONG_STRING];",
          "302:     return -1;",
          "305:     return 0;",
          "308:     return 0;",
          "310:   snprintf(buf, sizeof(buf), \"+FLAGS.SILENT (%s)\", name);",
          "312:   if (rc < 0)",
          "313:     return rc;",
          "314:   count += rc;",
          "316:   buf[0] = '-';",
          "318:   if (rc < 0)",
          "319:     return rc;",
          "320:   count += rc;",
          "",
          "[Removed Lines]",
          "295: static int sync_helper(struct ImapData *idata, int right, int flag, const char *name)",
          "301:   if (!idata->ctx)",
          "304:   if (!mutt_bit_isset(idata->ctx->mailbox->rights, right))",
          "307:   if (right == MUTT_ACL_WRITE && !imap_has_flag(&idata->flags, name))",
          "311:   rc = imap_exec_msgset(idata, \"UID STORE\", buf, flag, true, false);",
          "317:   rc = imap_exec_msgset(idata, \"UID STORE\", buf, flag, true, true);",
          "",
          "[Added Lines]",
          "295: static int sync_helper(struct ImapMboxData *mdata, int right, int flag, const char *name)",
          "301:   if (!mdata->ctx)",
          "304:   if (!mutt_bit_isset(mdata->ctx->mailbox->rights, right))",
          "307:   if (right == MUTT_ACL_WRITE && !imap_has_flag(&mdata->flags, name))",
          "311:   rc = imap_exec_msgset(mdata, \"UID STORE\", buf, flag, true, false);",
          "317:   rc = imap_exec_msgset(mdata, \"UID STORE\", buf, flag, true, true);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "338: {",
          "339:   struct ImapMbox mx;",
          "",
          "[Removed Lines]",
          "337: static int get_mailbox(const char *path, struct ImapData **hidata, char *buf, size_t buflen)",
          "",
          "[Added Lines]",
          "337: static int get_mailbox(const char *path, struct ImapMboxData **hidata, char *buf, size_t buflen)",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "489:         break;",
          "490:       case MUTT_SERVERSEARCH:",
          "491:       {",
          "494:         {",
          "495:           mutt_error(_(\"Server-side custom search not supported: %s\"), pat->p.str);",
          "496:           return -1;",
          "",
          "[Removed Lines]",
          "492:         struct ImapData *idata = mailbox->data;",
          "493:         if (!mutt_bit_isset(idata->capabilities, X_GM_EXT1))",
          "",
          "[Added Lines]",
          "492:         struct ImapMboxData *mdata = mailbox->data;",
          "493:         if (!mutt_bit_isset(mdata->capabilities, X_GM_EXT1))",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "598: int imap_access(const char *path)",
          "599: {",
          "601:   struct ImapMbox mx;",
          "602:   char buf[LONG_STRING];",
          "603:   char mailbox[LONG_STRING];",
          "",
          "[Removed Lines]",
          "600:   struct ImapData *idata = NULL;",
          "",
          "[Added Lines]",
          "600:   struct ImapMboxData *mdata = NULL;",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "607:   if (imap_parse_path(path, &mx))",
          "608:     return -1;",
          "612:   {",
          "613:     FREE(&mx.mbox);",
          "614:     return -1;",
          "615:   }",
          "618:   if (!*mailbox)",
          "619:     mutt_str_strfcpy(mailbox, \"INBOX\", sizeof(mailbox));",
          "623:   {",
          "624:     FREE(&mx.mbox);",
          "625:     return 0;",
          "626:   }",
          "627:   FREE(&mx.mbox);",
          "630:   {",
          "631:     mutt_debug(3, \"found %s in cache\\n\", mailbox);",
          "632:     return 0;",
          "633:   }",
          "638:     snprintf(buf, sizeof(buf), \"STATUS %s (UIDVALIDITY)\", mbox);",
          "640:     snprintf(buf, sizeof(buf), \"STATUS %s (UID-VALIDITY)\", mbox);",
          "641:   else",
          "642:   {",
          "",
          "[Removed Lines]",
          "610:   idata = imap_conn_find(&mx.account, ImapPassive ? MUTT_IMAP_CONN_NONEW : 0);",
          "611:   if (!idata)",
          "617:   imap_fix_path(idata, mx.mbox, mailbox, sizeof(mailbox));",
          "622:   if (mutt_str_strcmp(idata->mbox_name, mx.mbox) == 0)",
          "629:   if (imap_mboxcache_get(idata, mailbox, false))",
          "635:   imap_munge_mbox_name(idata, mbox, sizeof(mbox), mailbox);",
          "637:   if (mutt_bit_isset(idata->capabilities, IMAP4REV1))",
          "639:   else if (mutt_bit_isset(idata->capabilities, STATUS))",
          "",
          "[Added Lines]",
          "610:   mdata = imap_conn_find(&mx.account, ImapPassive ? MUTT_IMAP_CONN_NONEW : 0);",
          "611:   if (!mdata)",
          "617:   imap_fix_path(mdata, mx.mbox, mailbox, sizeof(mailbox));",
          "622:   if (mutt_str_strcmp(mdata->mbox_name, mx.mbox) == 0)",
          "629:   if (imap_mboxcache_get(mdata, mailbox, false))",
          "635:   imap_munge_mbox_name(mdata, mbox, sizeof(mbox), mailbox);",
          "637:   if (mutt_bit_isset(mdata->capabilities, IMAP4REV1))",
          "639:   else if (mutt_bit_isset(mdata->capabilities, STATUS))",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "644:     return -1;",
          "645:   }",
          "648:   if (rc < 0)",
          "649:   {",
          "650:     mutt_debug(1, \"Can't check STATUS of %s\\n\", mbox);",
          "",
          "[Removed Lines]",
          "647:   rc = imap_exec(idata, buf, IMAP_CMD_FAIL_OK);",
          "",
          "[Added Lines]",
          "647:   rc = imap_exec(mdata, buf, IMAP_CMD_FAIL_OK);",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "665: {",
          "666:   char buf[LONG_STRING], mbox[LONG_STRING];",
          "669:   snprintf(buf, sizeof(buf), \"CREATE %s\", mbox);",
          "672:   {",
          "674:     return -1;",
          "675:   }",
          "",
          "[Removed Lines]",
          "664: int imap_create_mailbox(struct ImapData *idata, char *mailbox)",
          "668:   imap_munge_mbox_name(idata, mbox, sizeof(mbox), mailbox);",
          "671:   if (imap_exec(idata, buf, 0) != 0)",
          "673:     mutt_error(_(\"CREATE failed: %s\"), imap_cmd_trailer(idata));",
          "",
          "[Added Lines]",
          "664: int imap_create_mailbox(struct ImapMboxData *mdata, char *mailbox)",
          "668:   imap_munge_mbox_name(mdata, mbox, sizeof(mbox), mailbox);",
          "671:   if (imap_exec(mdata, buf, 0) != 0)",
          "673:     mutt_error(_(\"CREATE failed: %s\"), imap_cmd_trailer(mdata));",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "689: {",
          "690:   char oldmbox[LONG_STRING];",
          "691:   char newmbox[LONG_STRING];",
          "692:   char buf[LONG_STRING];",
          "697:   snprintf(buf, sizeof(buf), \"RENAME %s %s\", oldmbox, newmbox);",
          "700:     return -1;",
          "702:   return 0;",
          "",
          "[Removed Lines]",
          "688: int imap_rename_mailbox(struct ImapData *idata, struct ImapMbox *mx, const char *newname)",
          "694:   imap_munge_mbox_name(idata, oldmbox, sizeof(oldmbox), mx->mbox);",
          "695:   imap_munge_mbox_name(idata, newmbox, sizeof(newmbox), newname);",
          "699:   if (imap_exec(idata, buf, 0) != 0)",
          "",
          "[Added Lines]",
          "688: int imap_rename_mailbox(struct ImapMboxData *mdata, struct ImapMbox *mx, const char *newname)",
          "694:   imap_munge_mbox_name(mdata, oldmbox, sizeof(oldmbox), mx->mbox);",
          "695:   imap_munge_mbox_name(mdata, newmbox, sizeof(newmbox), newname);",
          "699:   if (imap_exec(mdata, buf, 0) != 0)",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "712: int imap_delete_mailbox(struct Mailbox *mailbox, struct ImapMbox *mx)",
          "713: {",
          "714:   char buf[PATH_MAX], mbox[PATH_MAX];",
          "717:   if (!mailbox || !mailbox->data)",
          "718:   {",
          "721:     {",
          "722:       FREE(&mx->mbox);",
          "723:       return -1;",
          "",
          "[Removed Lines]",
          "715:   struct ImapData *idata = NULL;",
          "719:     idata = imap_conn_find(&mx->account, ImapPassive ? MUTT_IMAP_CONN_NONEW : 0);",
          "720:     if (!idata)",
          "",
          "[Added Lines]",
          "715:   struct ImapMboxData *mdata = NULL;",
          "719:     mdata = imap_conn_find(&mx->account, ImapPassive ? MUTT_IMAP_CONN_NONEW : 0);",
          "720:     if (!mdata)",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "725:   }",
          "726:   else",
          "727:   {",
          "729:   }",
          "732:   snprintf(buf, sizeof(buf), \"DELETE %s\", mbox);",
          "735:     return -1;",
          "737:   return 0;",
          "",
          "[Removed Lines]",
          "728:     idata = mailbox->data;",
          "731:   imap_munge_mbox_name(idata, mbox, sizeof(mbox), mx->mbox);",
          "734:   if (imap_exec(idata, buf, 0) != 0)",
          "",
          "[Added Lines]",
          "728:     mdata = mailbox->data;",
          "731:   imap_munge_mbox_name(mdata, mbox, sizeof(mbox), mx->mbox);",
          "734:   if (imap_exec(mdata, buf, 0) != 0)",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "752:     {",
          "753:       TAILQ_REMOVE(head, np, entries);",
          "754:       mutt_message(_(\"Closing connection to %s...\"), np->account.host);",
          "756:       mutt_clear_error();",
          "757:       mutt_socket_free(np);",
          "758:     }",
          "",
          "[Removed Lines]",
          "755:       imap_logout((struct ImapData **) (void *) &np->data);",
          "",
          "[Added Lines]",
          "755:       imap_logout((struct ImapMboxData **) (void *) &np->data);",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "777:                       struct Progress *pbar)",
          "778: {",
          "779:   char c;",
          "",
          "[Removed Lines]",
          "776: int imap_read_literal(FILE *fp, struct ImapData *idata, unsigned long bytes,",
          "",
          "[Added Lines]",
          "776: int imap_read_literal(FILE *fp, struct ImapMboxData *mdata, unsigned long bytes,",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "788:   for (unsigned long pos = 0; pos < bytes; pos++)",
          "789:   {",
          "791:     {",
          "792:       mutt_debug(1, \"error during read, %ld bytes read\\n\", pos);",
          "795:       mutt_buffer_free(&buf);",
          "796:       return -1;",
          "",
          "[Removed Lines]",
          "790:     if (mutt_socket_readchar(idata->conn, &c) != 1)",
          "793:       idata->status = IMAP_FATAL;",
          "",
          "[Added Lines]",
          "790:     if (mutt_socket_readchar(mdata->conn, &c) != 1)",
          "793:       mdata->status = IMAP_FATAL;",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "835: {",
          "836:   struct Email *e = NULL;",
          "837:   int cacheno;",
          "838:   short old_sort;",
          "840: #ifdef USE_HCACHE",
          "842: #endif",
          "844:   old_sort = Sort;",
          "845:   Sort = SORT_ORDER;",
          "849:   {",
          "852:     if (e->index == INT_MAX)",
          "853:     {",
          "854:       mutt_debug(2, \"Expunging message UID %u.\\n\", HEADER_DATA(e)->uid);",
          "856:       e->active = false;",
          "860: #ifdef USE_HCACHE",
          "862: #endif",
          "865:       cacheno = HEADER_DATA(e)->uid % IMAP_CACHE_LEN;",
          "868:       {",
          "871:       }",
          "876:     }",
          "877:     else",
          "878:     {",
          "",
          "[Removed Lines]",
          "834: void imap_expunge_mailbox(struct ImapData *idata)",
          "841:   idata->hcache = imap_hcache_open(idata, NULL);",
          "846:   mutt_sort_headers(idata->ctx, false);",
          "848:   for (int i = 0; i < idata->ctx->mailbox->msg_count; i++)",
          "850:     e = idata->ctx->mailbox->hdrs[i];",
          "857:       idata->ctx->mailbox->size -= e->content->length;",
          "859:       imap_cache_del(idata, e);",
          "861:       imap_hcache_del(idata, HEADER_DATA(e)->uid);",
          "866:       if (idata->cache[cacheno].uid == HEADER_DATA(e)->uid &&",
          "867:           idata->cache[cacheno].path)",
          "869:         unlink(idata->cache[cacheno].path);",
          "870:         FREE(&idata->cache[cacheno].path);",
          "873:       mutt_hash_int_delete(idata->uid_hash, HEADER_DATA(e)->uid, e);",
          "875:       imap_free_header_data((struct ImapHeaderData **) &e->data);",
          "",
          "[Added Lines]",
          "834: void imap_expunge_mailbox(struct ImapMboxData *mdata)",
          "841:   mdata->hcache = imap_hcache_open(mdata, NULL);",
          "846:   mutt_sort_headers(mdata->ctx, false);",
          "848:   for (int i = 0; i < mdata->ctx->mailbox->msg_count; i++)",
          "850:     e = mdata->ctx->mailbox->hdrs[i];",
          "857:       mdata->ctx->mailbox->size -= e->content->length;",
          "859:       imap_cache_del(mdata, e);",
          "861:       imap_hcache_del(mdata, HEADER_DATA(e)->uid);",
          "866:       if (mdata->cache[cacheno].uid == HEADER_DATA(e)->uid &&",
          "867:           mdata->cache[cacheno].path)",
          "869:         unlink(mdata->cache[cacheno].path);",
          "870:         FREE(&mdata->cache[cacheno].path);",
          "873:       mutt_hash_int_delete(mdata->uid_hash, HEADER_DATA(e)->uid, e);",
          "875:       imap_free_email_data((struct ImapEmailData **) &e->data);",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "898:   }",
          "900: #ifdef USE_HCACHE",
          "902: #endif",
          "907:   Sort = old_sort;",
          "909: }",
          "",
          "[Removed Lines]",
          "901:   imap_hcache_close(idata);",
          "906:   mx_update_tables(idata->ctx, false);",
          "908:   mutt_sort_headers(idata->ctx, true);",
          "",
          "[Added Lines]",
          "901:   imap_hcache_close(mdata);",
          "906:   mx_update_tables(mdata->ctx, false);",
          "908:   mutt_sort_headers(mdata->ctx, true);",
          "",
          "---------------",
          "--- Hunk 21 ---",
          "[Context before]",
          "922: {",
          "923:   struct Connection *conn = NULL;",
          "924:   struct ConnAccount *creds = NULL;",
          "926:   bool new = false;",
          "928:   while ((conn = mutt_conn_find(conn, account)))",
          "",
          "[Removed Lines]",
          "921: struct ImapData *imap_conn_find(const struct ConnAccount *account, int flags)",
          "925:   struct ImapData *idata = NULL;",
          "",
          "[Added Lines]",
          "921: struct ImapMboxData *imap_conn_find(const struct ConnAccount *account, int flags)",
          "925:   struct ImapMboxData *mdata = NULL;",
          "",
          "---------------",
          "--- Hunk 22 ---",
          "[Context before]",
          "932:     else",
          "933:       memcpy(&conn->account, creds, sizeof(struct ConnAccount));",
          "936:     if (flags & MUTT_IMAP_CONN_NONEW)",
          "937:     {",
          "939:       {",
          "941:         mutt_socket_free(conn);",
          "942:         return NULL;",
          "943:       }",
          "945:         continue;",
          "946:     }",
          "948:       continue;",
          "950:       continue;",
          "951:     break;",
          "952:   }",
          "953:   if (!conn)",
          "957:   {",
          "961:     {",
          "962:       mutt_socket_free(conn);",
          "963:       return NULL;",
          "964:     }",
          "968:     new = true;",
          "969:   }",
          "974:   {",
          "976:     {",
          "979:       new = true;",
          "982:     }",
          "983:     else",
          "985:   }",
          "987:   {",
          "998:     {",
          "1000:       if (ImapQResync)",
          "1002:     }",
          "1010:   }",
          "1013: }",
          "1022: {",
          "1023:   char buf[LONG_STRING];",
          "1026:     return -1;",
          "1031:   {",
          "1033:     return -1;",
          "1034:   }",
          "1037:   {",
          "1040:     {",
          "1041:       goto bail;",
          "1042:     }",
          "1043: #ifdef USE_SSL",
          "1046:     {",
          "1047:       int rc;",
          "",
          "[Removed Lines]",
          "935:     idata = conn->data;",
          "938:       if (!idata)",
          "944:       else if (idata->state < IMAP_AUTHENTICATED)",
          "947:     if (flags & MUTT_IMAP_CONN_NOSELECT && idata && idata->state >= IMAP_SELECTED)",
          "949:     if (idata && idata->status == IMAP_FATAL)",
          "956:   if (!idata)",
          "959:     idata = imap_new_idata();",
          "960:     if (!idata)",
          "966:     conn->data = idata;",
          "967:     idata->conn = conn;",
          "971:   if (idata->state == IMAP_DISCONNECTED)",
          "972:     imap_open_connection(idata);",
          "973:   if (idata->state == IMAP_CONNECTED)",
          "975:     if (imap_authenticate(idata) == IMAP_AUTH_SUCCESS)",
          "977:       idata->state = IMAP_AUTHENTICATED;",
          "978:       FREE(&idata->capstr);",
          "980:       if (idata->conn->ssf)",
          "981:         mutt_debug(2, \"Communication encrypted at %d bits\\n\", idata->conn->ssf);",
          "984:       mutt_account_unsetpass(&idata->conn->account);",
          "986:   if (new && idata->state == IMAP_AUTHENTICATED)",
          "989:     imap_exec(idata, \"CAPABILITY\", IMAP_CMD_QUEUE);",
          "992:     if (mutt_bit_isset(idata->capabilities, ENABLE))",
          "993:       imap_exec(idata, \"ENABLE UTF8=ACCEPT\", IMAP_CMD_QUEUE);",
          "997:     if (mutt_bit_isset(idata->capabilities, QRESYNC))",
          "999:       mutt_bit_set(idata->capabilities, CONDSTORE);",
          "1001:         imap_exec(idata, \"ENABLE QRESYNC\", IMAP_CMD_QUEUE);",
          "1005:     idata->delim = '/';",
          "1006:     imap_exec(idata, \"LIST \\\"\\\" \\\"\\\"\", IMAP_CMD_QUEUE);",
          "1009:     imap_exec(idata, NULL, IMAP_CMD_FAIL_OK);",
          "1012:   return idata;",
          "1021: int imap_open_connection(struct ImapData *idata)",
          "1025:   if (mutt_socket_open(idata->conn) < 0)",
          "1028:   idata->state = IMAP_CONNECTED;",
          "1030:   if (imap_cmd_step(idata) != IMAP_CMD_OK)",
          "1032:     imap_close_connection(idata);",
          "1036:   if (mutt_str_strncasecmp(\"* OK\", idata->buf, 4) == 0)",
          "1038:     if ((mutt_str_strncasecmp(\"* OK [CAPABILITY\", idata->buf, 16) != 0) &&",
          "1039:         check_capabilities(idata))",
          "1045:     if (!idata->conn->ssf && (SslForceTls || mutt_bit_isset(idata->capabilities, STARTTLS)))",
          "",
          "[Added Lines]",
          "935:     mdata = conn->data;",
          "938:       if (!mdata)",
          "944:       else if (mdata->state < IMAP_AUTHENTICATED)",
          "947:     if (flags & MUTT_IMAP_CONN_NOSELECT && mdata && mdata->state >= IMAP_SELECTED)",
          "949:     if (mdata && mdata->status == IMAP_FATAL)",
          "956:   if (!mdata)",
          "959:     mdata = imap_new_idata();",
          "960:     if (!mdata)",
          "966:     conn->data = mdata;",
          "967:     mdata->conn = conn;",
          "971:   if (mdata->state == IMAP_DISCONNECTED)",
          "972:     imap_open_connection(mdata);",
          "973:   if (mdata->state == IMAP_CONNECTED)",
          "975:     if (imap_authenticate(mdata) == IMAP_AUTH_SUCCESS)",
          "977:       mdata->state = IMAP_AUTHENTICATED;",
          "978:       FREE(&mdata->capstr);",
          "980:       if (mdata->conn->ssf)",
          "981:         mutt_debug(2, \"Communication encrypted at %d bits\\n\", mdata->conn->ssf);",
          "984:       mutt_account_unsetpass(&mdata->conn->account);",
          "986:   if (new && mdata->state == IMAP_AUTHENTICATED)",
          "989:     imap_exec(mdata, \"CAPABILITY\", IMAP_CMD_QUEUE);",
          "992:     if (mutt_bit_isset(mdata->capabilities, ENABLE))",
          "993:       imap_exec(mdata, \"ENABLE UTF8=ACCEPT\", IMAP_CMD_QUEUE);",
          "997:     if (mutt_bit_isset(mdata->capabilities, QRESYNC))",
          "999:       mutt_bit_set(mdata->capabilities, CONDSTORE);",
          "1001:         imap_exec(mdata, \"ENABLE QRESYNC\", IMAP_CMD_QUEUE);",
          "1005:     mdata->delim = '/';",
          "1006:     imap_exec(mdata, \"LIST \\\"\\\" \\\"\\\"\", IMAP_CMD_QUEUE);",
          "1009:     imap_exec(mdata, NULL, IMAP_CMD_FAIL_OK);",
          "1012:   return mdata;",
          "1021: int imap_open_connection(struct ImapMboxData *mdata)",
          "1025:   if (mutt_socket_open(mdata->conn) < 0)",
          "1028:   mdata->state = IMAP_CONNECTED;",
          "1030:   if (imap_cmd_step(mdata) != IMAP_CMD_OK)",
          "1032:     imap_close_connection(mdata);",
          "1036:   if (mutt_str_strncasecmp(\"* OK\", mdata->buf, 4) == 0)",
          "1038:     if ((mutt_str_strncasecmp(\"* OK [CAPABILITY\", mdata->buf, 16) != 0) &&",
          "1039:         check_capabilities(mdata))",
          "1045:     if (!mdata->conn->ssf && (SslForceTls || mutt_bit_isset(mdata->capabilities, STARTTLS)))",
          "",
          "---------------",
          "--- Hunk 23 ---",
          "[Context before]",
          "1055:       }",
          "1056:       if (rc == MUTT_YES)",
          "1057:       {",
          "1059:         if (rc == -1)",
          "1060:           goto bail;",
          "1061:         if (rc != -2)",
          "1062:         {",
          "1064:           {",
          "1065:             mutt_error(_(\"Could not negotiate TLS connection\"));",
          "1066:             goto err_close_conn;",
          "",
          "[Removed Lines]",
          "1058:         rc = imap_exec(idata, \"STARTTLS\", IMAP_CMD_FAIL_OK);",
          "1063:           if (mutt_ssl_starttls(idata->conn))",
          "",
          "[Added Lines]",
          "1058:         rc = imap_exec(mdata, \"STARTTLS\", IMAP_CMD_FAIL_OK);",
          "1063:           if (mutt_ssl_starttls(mdata->conn))",
          "",
          "---------------",
          "--- Hunk 24 ---",
          "[Context before]",
          "1068:           else",
          "1069:           {",
          "1072:               goto bail;",
          "1073:           }",
          "1074:         }",
          "1075:       }",
          "1076:     }",
          "1079:     {",
          "1080:       mutt_error(_(\"Encrypted connection unavailable\"));",
          "1081:       goto err_close_conn;",
          "1082:     }",
          "1083: #endif",
          "1084:   }",
          "1086:   {",
          "1089:       goto bail;",
          "1091:   }",
          "1092:   else",
          "1093:   {",
          "",
          "[Removed Lines]",
          "1071:             if (imap_exec(idata, \"CAPABILITY\", 0))",
          "1078:     if (SslForceTls && !idata->conn->ssf)",
          "1085:   else if (mutt_str_strncasecmp(\"* PREAUTH\", idata->buf, 9) == 0)",
          "1087:     idata->state = IMAP_AUTHENTICATED;",
          "1088:     if (check_capabilities(idata) != 0)",
          "1090:     FREE(&idata->capstr);",
          "",
          "[Added Lines]",
          "1071:             if (imap_exec(mdata, \"CAPABILITY\", 0))",
          "1078:     if (SslForceTls && !mdata->conn->ssf)",
          "1085:   else if (mutt_str_strncasecmp(\"* PREAUTH\", mdata->buf, 9) == 0)",
          "1087:     mdata->state = IMAP_AUTHENTICATED;",
          "1088:     if (check_capabilities(mdata) != 0)",
          "1090:     FREE(&mdata->capstr);",
          "",
          "---------------",
          "--- Hunk 25 ---",
          "[Context before]",
          "1100: #ifdef USE_SSL",
          "1101: err_close_conn:",
          "1103: #endif",
          "1104: bail:",
          "1106:   return -1;",
          "1107: }",
          "1114: {",
          "1116:   {",
          "1119:   }",
          "1125: }",
          "1132: {",
          "1138:   {",
          "1140:       ;",
          "1141:   }",
          "1145: }",
          "",
          "[Removed Lines]",
          "1102:   imap_close_connection(idata);",
          "1105:   FREE(&idata->capstr);",
          "1113: void imap_close_connection(struct ImapData *idata)",
          "1115:   if (idata->state != IMAP_DISCONNECTED)",
          "1117:     mutt_socket_close(idata->conn);",
          "1118:     idata->state = IMAP_DISCONNECTED;",
          "1120:   idata->seqno = false;",
          "1121:   idata->nextcmd = false;",
          "1122:   idata->lastcmd = false;",
          "1123:   idata->status = false;",
          "1124:   memset(idata->cmds, 0, sizeof(struct ImapCommand) * idata->cmdslots);",
          "1131: void imap_logout(struct ImapData **idata)",
          "1135:   (*idata)->status = IMAP_BYE;",
          "1136:   imap_cmd_start(*idata, \"LOGOUT\");",
          "1137:   if (ImapPollTimeout <= 0 || mutt_socket_poll((*idata)->conn, ImapPollTimeout) != 0)",
          "1139:     while (imap_cmd_step(*idata) == IMAP_CMD_CONTINUE)",
          "1143:   mutt_socket_close((*idata)->conn);",
          "1144:   imap_free_idata(idata);",
          "",
          "[Added Lines]",
          "1102:   imap_close_connection(mdata);",
          "1105:   FREE(&mdata->capstr);",
          "1113: void imap_close_connection(struct ImapMboxData *mdata)",
          "1115:   if (mdata->state != IMAP_DISCONNECTED)",
          "1117:     mutt_socket_close(mdata->conn);",
          "1118:     mdata->state = IMAP_DISCONNECTED;",
          "1120:   mdata->seqno = false;",
          "1121:   mdata->nextcmd = false;",
          "1122:   mdata->lastcmd = false;",
          "1123:   mdata->status = false;",
          "1124:   memset(mdata->cmds, 0, sizeof(struct ImapCommand) * mdata->cmdslots);",
          "1131: void imap_logout(struct ImapMboxData **mdata)",
          "1135:   (*mdata)->status = IMAP_BYE;",
          "1136:   imap_cmd_start(*mdata, \"LOGOUT\");",
          "1137:   if (ImapPollTimeout <= 0 || mutt_socket_poll((*mdata)->conn, ImapPollTimeout) != 0)",
          "1139:     while (imap_cmd_step(*mdata) == IMAP_CMD_CONTINUE)",
          "1143:   mutt_socket_close((*mdata)->conn);",
          "1144:   imap_free_idata(mdata);",
          "",
          "---------------",
          "--- Hunk 26 ---",
          "[Context before]",
          "1190:                      int flag, bool changed, bool invert)",
          "1191: {",
          "1192:   struct Email **emails = NULL;",
          "",
          "[Removed Lines]",
          "1189: int imap_exec_msgset(struct ImapData *idata, const char *pre, const char *post,",
          "",
          "[Added Lines]",
          "1189: int imap_exec_msgset(struct ImapMboxData *mdata, const char *pre, const char *post,",
          "",
          "---------------",
          "--- Hunk 27 ---",
          "[Context before]",
          "1203:   oldsort = Sort;",
          "1204:   if (Sort != SORT_ORDER)",
          "1205:   {",
          "1212:     Sort = SORT_ORDER;",
          "1214:           sizeof(struct Email *), mutt_get_sort_func(SORT_ORDER));",
          "1215:   }",
          "",
          "[Removed Lines]",
          "1206:     emails = idata->ctx->mailbox->hdrs;",
          "1207:     idata->ctx->mailbox->hdrs =",
          "1208:         mutt_mem_malloc(idata->ctx->mailbox->msg_count * sizeof(struct Email *));",
          "1209:     memcpy(idata->ctx->mailbox->hdrs, emails,",
          "1210:            idata->ctx->mailbox->msg_count * sizeof(struct Email *));",
          "1213:     qsort(idata->ctx->mailbox->hdrs, idata->ctx->mailbox->msg_count,",
          "",
          "[Added Lines]",
          "1206:     emails = mdata->ctx->mailbox->hdrs;",
          "1207:     mdata->ctx->mailbox->hdrs =",
          "1208:         mutt_mem_malloc(mdata->ctx->mailbox->msg_count * sizeof(struct Email *));",
          "1209:     memcpy(mdata->ctx->mailbox->hdrs, emails,",
          "1210:            mdata->ctx->mailbox->msg_count * sizeof(struct Email *));",
          "1213:     qsort(mdata->ctx->mailbox->hdrs, mdata->ctx->mailbox->msg_count,",
          "",
          "---------------",
          "--- Hunk 28 ---",
          "[Context before]",
          "1220:   {",
          "1221:     cmd->dptr = cmd->data;",
          "1222:     mutt_buffer_printf(cmd, \"%s \", pre);",
          "1224:     if (rc > 0)",
          "1225:     {",
          "1226:       mutt_buffer_printf(cmd, \" %s\", post);",
          "1228:       {",
          "1229:         rc = -1;",
          "1230:         goto out;",
          "",
          "[Removed Lines]",
          "1223:     rc = make_msg_set(idata, cmd, flag, changed, invert, &pos);",
          "1227:       if (imap_exec(idata, cmd->data, IMAP_CMD_QUEUE))",
          "",
          "[Added Lines]",
          "1223:     rc = make_msg_set(mdata, cmd, flag, changed, invert, &pos);",
          "1227:       if (imap_exec(mdata, cmd->data, IMAP_CMD_QUEUE))",
          "",
          "---------------",
          "--- Hunk 29 ---",
          "[Context before]",
          "1240:   if (oldsort != Sort)",
          "1241:   {",
          "1242:     Sort = oldsort;",
          "1245:   }",
          "1247:   return rc;",
          "",
          "[Removed Lines]",
          "1243:     FREE(&idata->ctx->mailbox->hdrs);",
          "1244:     idata->ctx->mailbox->hdrs = emails;",
          "",
          "[Added Lines]",
          "1243:     FREE(&mdata->ctx->mailbox->hdrs);",
          "1244:     mdata->ctx->mailbox->hdrs = emails;",
          "",
          "---------------",
          "--- Hunk 30 ---",
          "[Context before]",
          "1266:                                struct Buffer *cmd, int *err_continue)",
          "1267: {",
          "1268:   char flags[LONG_STRING];",
          "",
          "[Removed Lines]",
          "1265: int imap_sync_message_for_copy(struct ImapData *idata, struct Email *e,",
          "",
          "[Added Lines]",
          "1265: int imap_sync_message_for_copy(struct ImapMboxData *mdata, struct Email *e,",
          "",
          "---------------",
          "--- Hunk 31 ---",
          "[Context before]",
          "1284:   flags[0] = '\\0';",
          "1291:            sizeof(flags));",
          "1294:   {",
          "1296:     if (HEADER_DATA(e)->flags_system)",
          "",
          "[Removed Lines]",
          "1286:   set_flag(idata, MUTT_ACL_SEEN, e->read, \"\\\\Seen \", flags, sizeof(flags));",
          "1287:   set_flag(idata, MUTT_ACL_WRITE, e->old, \"Old \", flags, sizeof(flags));",
          "1288:   set_flag(idata, MUTT_ACL_WRITE, e->flagged, \"\\\\Flagged \", flags, sizeof(flags));",
          "1289:   set_flag(idata, MUTT_ACL_WRITE, e->replied, \"\\\\Answered \", flags, sizeof(flags));",
          "1290:   set_flag(idata, MUTT_ACL_DELETE, HEADER_DATA(e)->deleted, \"\\\\Deleted \", flags,",
          "1293:   if (mutt_bit_isset(idata->ctx->mailbox->rights, MUTT_ACL_WRITE))",
          "",
          "[Added Lines]",
          "1286:   set_flag(mdata, MUTT_ACL_SEEN, e->read, \"\\\\Seen \", flags, sizeof(flags));",
          "1287:   set_flag(mdata, MUTT_ACL_WRITE, e->old, \"Old \", flags, sizeof(flags));",
          "1288:   set_flag(mdata, MUTT_ACL_WRITE, e->flagged, \"\\\\Flagged \", flags, sizeof(flags));",
          "1289:   set_flag(mdata, MUTT_ACL_WRITE, e->replied, \"\\\\Answered \", flags, sizeof(flags));",
          "1290:   set_flag(mdata, MUTT_ACL_DELETE, HEADER_DATA(e)->deleted, \"\\\\Deleted \", flags,",
          "1293:   if (mutt_bit_isset(mdata->ctx->mailbox->rights, MUTT_ACL_WRITE))",
          "",
          "---------------",
          "--- Hunk 32 ---",
          "[Context before]",
          "1311:   if (!*flags)",
          "1312:   {",
          "1318:              flags, sizeof(flags));",
          "1322:         HEADER_DATA(e)->flags_remote)",
          "1323:       mutt_str_strcat(flags, sizeof(flags), HEADER_DATA(e)->flags_remote);",
          "",
          "[Removed Lines]",
          "1313:     set_flag(idata, MUTT_ACL_SEEN, 1, \"\\\\Seen \", flags, sizeof(flags));",
          "1314:     set_flag(idata, MUTT_ACL_WRITE, 1, \"Old \", flags, sizeof(flags));",
          "1315:     set_flag(idata, MUTT_ACL_WRITE, 1, \"\\\\Flagged \", flags, sizeof(flags));",
          "1316:     set_flag(idata, MUTT_ACL_WRITE, 1, \"\\\\Answered \", flags, sizeof(flags));",
          "1317:     set_flag(idata, MUTT_ACL_DELETE, !HEADER_DATA(e)->deleted, \"\\\\Deleted \",",
          "1321:     if (mutt_bit_isset(idata->ctx->mailbox->rights, MUTT_ACL_WRITE) &&",
          "",
          "[Added Lines]",
          "1313:     set_flag(mdata, MUTT_ACL_SEEN, 1, \"\\\\Seen \", flags, sizeof(flags));",
          "1314:     set_flag(mdata, MUTT_ACL_WRITE, 1, \"Old \", flags, sizeof(flags));",
          "1315:     set_flag(mdata, MUTT_ACL_WRITE, 1, \"\\\\Flagged \", flags, sizeof(flags));",
          "1316:     set_flag(mdata, MUTT_ACL_WRITE, 1, \"\\\\Answered \", flags, sizeof(flags));",
          "1317:     set_flag(mdata, MUTT_ACL_DELETE, !HEADER_DATA(e)->deleted, \"\\\\Deleted \",",
          "1321:     if (mutt_bit_isset(mdata->ctx->mailbox->rights, MUTT_ACL_WRITE) &&",
          "",
          "---------------",
          "--- Hunk 33 ---",
          "[Context before]",
          "1341:       (*err_continue != MUTT_YES))",
          "1342:   {",
          "1344:     if (*err_continue != MUTT_YES)",
          "1345:     {",
          "1346:       e->active = true;",
          "",
          "[Removed Lines]",
          "1340:   if (*flags && (imap_exec(idata, cmd->data, 0) != 0) && err_continue &&",
          "",
          "[Added Lines]",
          "1340:   if (*flags && (imap_exec(mdata, cmd->data, 0) != 0) && err_continue &&",
          "",
          "---------------",
          "--- Hunk 34 ---",
          "[Context before]",
          "1384: {",
          "1387:   int result = 0;",
          "1392:   {",
          "1394:       return -1;",
          "1395:   }",
          "1397:   {",
          "1399:     {",
          "1401:       {",
          "1402:         mutt_debug(1, \"Error reading IDLE response\\n\");",
          "1403:         return -1;",
          "",
          "[Removed Lines]",
          "1383: int imap_check(struct ImapData *idata, bool force)",
          "1390:   if (!force && ImapIdle && mutt_bit_isset(idata->capabilities, IDLE) &&",
          "1391:       (idata->state != IMAP_IDLE || time(NULL) >= idata->lastread + ImapKeepalive))",
          "1393:     if (imap_cmd_idle(idata) < 0)",
          "1396:   if (idata->state == IMAP_IDLE)",
          "1398:     while ((result = mutt_socket_poll(idata->conn, 0)) > 0)",
          "1400:       if (imap_cmd_step(idata) != IMAP_CMD_CONTINUE)",
          "",
          "[Added Lines]",
          "1383: int imap_check(struct ImapMboxData *mdata, bool force)",
          "1390:   if (!force && ImapIdle && mutt_bit_isset(mdata->capabilities, IDLE) &&",
          "1391:       (mdata->state != IMAP_IDLE || time(NULL) >= mdata->lastread + ImapKeepalive))",
          "1393:     if (imap_cmd_idle(mdata) < 0)",
          "1396:   if (mdata->state == IMAP_IDLE)",
          "1398:     while ((result = mutt_socket_poll(mdata->conn, 0)) > 0)",
          "1400:       if (imap_cmd_step(mdata) != IMAP_CMD_CONTINUE)",
          "",
          "---------------",
          "--- Hunk 35 ---",
          "[Context before]",
          "1406:     if (result < 0)",
          "1407:     {",
          "1408:       mutt_debug(1, \"Poll failed, disabling IDLE\\n\");",
          "1410:     }",
          "1411:   }",
          "1415:   {",
          "1416:     return -1;",
          "1417:   }",
          "1424:     result = MUTT_REOPENED;",
          "1426:     result = MUTT_NEW_MAIL;",
          "1428:     result = MUTT_FLAGS;",
          "1432:   return result;",
          "1433: }",
          "",
          "[Removed Lines]",
          "1409:       mutt_bit_unset(idata->capabilities, IDLE);",
          "1413:   if ((force || (idata->state != IMAP_IDLE && time(NULL) >= idata->lastread + Timeout)) &&",
          "1414:       imap_exec(idata, \"NOOP\", IMAP_CMD_POLL) != 0)",
          "1421:   imap_cmd_finish(idata);",
          "1423:   if (idata->check_status & IMAP_EXPUNGE_PENDING)",
          "1425:   else if (idata->check_status & IMAP_NEWMAIL_PENDING)",
          "1427:   else if (idata->check_status & IMAP_FLAGS_PENDING)",
          "1430:   idata->check_status = 0;",
          "",
          "[Added Lines]",
          "1409:       mutt_bit_unset(mdata->capabilities, IDLE);",
          "1413:   if ((force || (mdata->state != IMAP_IDLE && time(NULL) >= mdata->lastread + Timeout)) &&",
          "1414:       imap_exec(mdata, \"NOOP\", IMAP_CMD_POLL) != 0)",
          "1421:   imap_cmd_finish(mdata);",
          "1423:   if (mdata->check_status & IMAP_EXPUNGE_PENDING)",
          "1425:   else if (mdata->check_status & IMAP_NEWMAIL_PENDING)",
          "1427:   else if (mdata->check_status & IMAP_FLAGS_PENDING)",
          "1430:   mdata->check_status = 0;",
          "",
          "---------------",
          "--- Hunk 36 ---",
          "[Context before]",
          "1444: int imap_mailbox_check(bool check_stats)",
          "1445: {",
          "1448:   char name[LONG_STRING];",
          "1449:   char command[LONG_STRING];",
          "1450:   char munged[LONG_STRING];",
          "",
          "[Removed Lines]",
          "1446:   struct ImapData *idata = NULL;",
          "1447:   struct ImapData *lastdata = NULL;",
          "",
          "[Added Lines]",
          "1446:   struct ImapMboxData *mdata = NULL;",
          "1447:   struct ImapMboxData *lastdata = NULL;",
          "",
          "---------------",
          "--- Hunk 37 ---",
          "[Context before]",
          "1463:     if (np->m->magic != MUTT_IMAP)",
          "1464:       continue;",
          "1467:     {",
          "1468:       np->m->has_new = false;",
          "1469:       continue;",
          "",
          "[Removed Lines]",
          "1466:     if (get_mailbox(np->m->path, &idata, name, sizeof(name)) < 0)",
          "",
          "[Added Lines]",
          "1466:     if (get_mailbox(np->m->path, &mdata, name, sizeof(name)) < 0)",
          "",
          "---------------",
          "--- Hunk 38 ---",
          "[Context before]",
          "1477:     {",
          "1478:       np->m->has_new = false;",
          "1479:       continue;",
          "1480:     }",
          "1484:     {",
          "1485:       mutt_debug(2, \"Server doesn't support STATUS\\n\");",
          "1486:       continue;",
          "1487:     }",
          "1490:     {",
          "",
          "[Removed Lines]",
          "1476:     if (idata->mbox_name && (imap_mxcmp(name, idata->mbox_name) == 0))",
          "1482:     if (!mutt_bit_isset(idata->capabilities, IMAP4REV1) &&",
          "1483:         !mutt_bit_isset(idata->capabilities, STATUS))",
          "1489:     if (lastdata && idata != lastdata)",
          "",
          "[Added Lines]",
          "1476:     if (mdata->mbox_name && (imap_mxcmp(name, mdata->mbox_name) == 0))",
          "1482:     if (!mutt_bit_isset(mdata->capabilities, IMAP4REV1) &&",
          "1483:         !mutt_bit_isset(mdata->capabilities, STATUS))",
          "1489:     if (lastdata && mdata != lastdata)",
          "",
          "---------------",
          "--- Hunk 39 ---",
          "[Context before]",
          "1497:     }",
          "1499:     if (!lastdata)",
          "1503:     if (check_stats)",
          "1504:     {",
          "1505:       snprintf(command, sizeof(command),",
          "",
          "[Removed Lines]",
          "1500:       lastdata = idata;",
          "1502:     imap_munge_mbox_name(idata, munged, sizeof(munged), name);",
          "",
          "[Added Lines]",
          "1500:       lastdata = mdata;",
          "1502:     imap_munge_mbox_name(mdata, munged, sizeof(munged), name);",
          "",
          "---------------",
          "--- Hunk 40 ---",
          "[Context before]",
          "1511:                \"STATUS %s (UIDNEXT UIDVALIDITY UNSEEN RECENT)\", munged);",
          "1512:     }",
          "1515:     {",
          "1516:       mutt_debug(1, \"Error queueing command\\n\");",
          "1517:       return 0;",
          "",
          "[Removed Lines]",
          "1514:     if (imap_exec(idata, command, IMAP_CMD_QUEUE | IMAP_CMD_POLL) < 0)",
          "",
          "[Added Lines]",
          "1514:     if (imap_exec(mdata, command, IMAP_CMD_QUEUE | IMAP_CMD_POLL) < 0)",
          "",
          "---------------",
          "--- Hunk 41 ---",
          "[Context before]",
          "1548: {",
          "1549:   static int queued = 0;",
          "1552:   char buf[LONG_STRING];",
          "1553:   char mbox[LONG_STRING];",
          "1554:   struct ImapStatus *status = NULL;",
          "1557:     return -1;",
          "1567:   {",
          "1569:     snprintf(buf, sizeof(buf), \"STATUS %s (%s)\", mbox, \"MESSAGES\");",
          "1571:   }",
          "1572:   else",
          "1573:   {",
          "",
          "[Removed Lines]",
          "1551:   struct ImapData *idata = NULL;",
          "1556:   if (get_mailbox(path, &idata, buf, sizeof(buf)) < 0)",
          "1563:   if (idata->ctx && !imap_mxcmp(buf, idata->mbox_name))",
          "1564:     return idata->ctx->mailbox->msg_count;",
          "1565:   else if (mutt_bit_isset(idata->capabilities, IMAP4REV1) ||",
          "1566:            mutt_bit_isset(idata->capabilities, STATUS))",
          "1568:     imap_munge_mbox_name(idata, mbox, sizeof(mbox), buf);",
          "1570:     imap_unmunge_mbox_name(idata, mbox);",
          "",
          "[Added Lines]",
          "1551:   struct ImapMboxData *mdata = NULL;",
          "1556:   if (get_mailbox(path, &mdata, buf, sizeof(buf)) < 0)",
          "1563:   if (mdata->ctx && !imap_mxcmp(buf, mdata->mbox_name))",
          "1564:     return mdata->ctx->mailbox->msg_count;",
          "1565:   else if (mutt_bit_isset(mdata->capabilities, IMAP4REV1) ||",
          "1566:            mutt_bit_isset(mdata->capabilities, STATUS))",
          "1568:     imap_munge_mbox_name(mdata, mbox, sizeof(mbox), buf);",
          "1570:     imap_unmunge_mbox_name(mdata, mbox);",
          "",
          "---------------",
          "--- Hunk 42 ---",
          "[Context before]",
          "1579:   if (queue)",
          "1580:   {",
          "1582:     queued = 1;",
          "1583:     return 0;",
          "1584:   }",
          "1585:   else if (!queued)",
          "1588:   queued = 0;",
          "1590:   if (status)",
          "1591:     return status->messages;",
          "",
          "[Removed Lines]",
          "1581:     imap_exec(idata, buf, IMAP_CMD_QUEUE);",
          "1586:     imap_exec(idata, buf, 0);",
          "1589:   status = imap_mboxcache_get(idata, mbox, false);",
          "",
          "[Added Lines]",
          "1581:     imap_exec(mdata, buf, IMAP_CMD_QUEUE);",
          "1586:     imap_exec(mdata, buf, 0);",
          "1589:   status = imap_mboxcache_get(mdata, mbox, false);",
          "",
          "---------------",
          "--- Hunk 43 ---",
          "[Context before]",
          "1608: {",
          "1609:   struct ImapStatus *status = NULL;",
          "1610:   struct ListNode *np = NULL;",
          "1612:   {",
          "1613:     status = (struct ImapStatus *) np->data;",
          "",
          "[Removed Lines]",
          "1607: struct ImapStatus *imap_mboxcache_get(struct ImapData *idata, const char *mbox, bool create)",
          "1611:   STAILQ_FOREACH(np, &idata->mboxcache, entries)",
          "",
          "[Added Lines]",
          "1607: struct ImapStatus *imap_mboxcache_get(struct ImapMboxData *mdata, const char *mbox, bool create)",
          "1611:   STAILQ_FOREACH(np, &mdata->mboxcache, entries)",
          "",
          "---------------",
          "--- Hunk 44 ---",
          "[Context before]",
          "1622:   {",
          "1623:     struct ImapStatus *scache = mutt_mem_calloc(1, sizeof(struct ImapStatus));",
          "1624:     scache->name = (char *) mbox;",
          "1627:     status->name = mutt_str_strdup(mbox);",
          "1628:   }",
          "1630: #ifdef USE_HCACHE",
          "1632:   if (hc)",
          "1633:   {",
          "1634:     void *uidvalidity = mutt_hcache_fetch_raw(hc, \"/UIDVALIDITY\", 12);",
          "",
          "[Removed Lines]",
          "1625:     mutt_list_insert_tail(&idata->mboxcache, (char *) scache);",
          "1626:     status = imap_mboxcache_get(idata, mbox, false);",
          "1631:   header_cache_t *hc = imap_hcache_open(idata, mbox);",
          "",
          "[Added Lines]",
          "1625:     mutt_list_insert_tail(&mdata->mboxcache, (char *) scache);",
          "1626:     status = imap_mboxcache_get(mdata, mbox, false);",
          "1631:   header_cache_t *hc = imap_hcache_open(mdata, mbox);",
          "",
          "---------------",
          "--- Hunk 45 ---",
          "[Context before]",
          "1642:         mutt_hcache_free(hc, &uidnext);",
          "1643:         mutt_hcache_free(hc, (void **) &modseq);",
          "1644:         mutt_hcache_close(hc);",
          "1646:       }",
          "1647:       status->uidvalidity = *(unsigned int *) uidvalidity;",
          "1648:       status->uidnext = uidnext ? *(unsigned int *) uidnext : 0;",
          "",
          "[Removed Lines]",
          "1645:         return imap_mboxcache_get(idata, mbox, true);",
          "",
          "[Added Lines]",
          "1645:         return imap_mboxcache_get(mdata, mbox, true);",
          "",
          "---------------",
          "--- Hunk 46 ---",
          "[Context before]",
          "1668: {",
          "1669:   struct ImapStatus *status = NULL;",
          "1671:   struct ListNode *np = NULL;",
          "1673:   {",
          "1674:     status = (struct ImapStatus *) np->data;",
          "1675:     FREE(&status->name);",
          "1676:   }",
          "1679: }",
          "",
          "[Removed Lines]",
          "1667: void imap_mboxcache_free(struct ImapData *idata)",
          "1672:   STAILQ_FOREACH(np, &idata->mboxcache, entries)",
          "1678:   mutt_list_free(&idata->mboxcache);",
          "",
          "[Added Lines]",
          "1667: void imap_mboxcache_free(struct ImapMboxData *mdata)",
          "1672:   STAILQ_FOREACH(np, &mdata->mboxcache, entries)",
          "1678:   mutt_list_free(&mdata->mboxcache);",
          "",
          "---------------",
          "--- Hunk 47 ---",
          "[Context before]",
          "1688: int imap_search(struct Mailbox *mailbox, const struct Pattern *pat)",
          "1689: {",
          "1690:   struct Buffer buf;",
          "1692:   for (int i = 0; i < mailbox->msg_count; i++)",
          "1693:     mailbox->hdrs[i]->matched = false;",
          "",
          "[Removed Lines]",
          "1691:   struct ImapData *idata = mailbox->data;",
          "",
          "[Added Lines]",
          "1691:   struct ImapMboxData *mdata = mailbox->data;",
          "",
          "---------------",
          "--- Hunk 48 ---",
          "[Context before]",
          "1702:     FREE(&buf.data);",
          "1703:     return -1;",
          "1704:   }",
          "1706:   {",
          "1707:     FREE(&buf.data);",
          "1708:     return -1;",
          "",
          "[Removed Lines]",
          "1705:   if (imap_exec(idata, buf.data, 0) < 0)",
          "",
          "[Added Lines]",
          "1705:   if (imap_exec(mdata, buf.data, 0) < 0)",
          "",
          "---------------",
          "--- Hunk 49 ---",
          "[Context before]",
          "1722: int imap_subscribe(char *path, bool subscribe)",
          "1723: {",
          "1725:   char buf[LONG_STRING];",
          "1726:   char mbox[LONG_STRING];",
          "1727:   char errstr[STRING];",
          "",
          "[Removed Lines]",
          "1724:   struct ImapData *idata = NULL;",
          "",
          "[Added Lines]",
          "1724:   struct ImapMboxData *mdata = NULL;",
          "",
          "---------------",
          "--- Hunk 50 ---",
          "[Context before]",
          "1734:     mutt_error(_(\"Bad mailbox name\"));",
          "1735:     return -1;",
          "1736:   }",
          "1739:     goto fail;",
          "1742:   if (!*buf)",
          "1743:     mutt_str_strfcpy(buf, \"INBOX\", sizeof(buf));",
          "",
          "[Removed Lines]",
          "1737:   idata = imap_conn_find(&(mx.account), 0);",
          "1738:   if (!idata)",
          "1741:   imap_fix_path(idata, mx.mbox, buf, sizeof(buf));",
          "",
          "[Added Lines]",
          "1737:   mdata = imap_conn_find(&(mx.account), 0);",
          "1738:   if (!mdata)",
          "1741:   imap_fix_path(mdata, mx.mbox, buf, sizeof(buf));",
          "",
          "---------------",
          "--- Hunk 51 ---",
          "[Context before]",
          "1759:     mutt_message(_(\"Subscribing to %s...\"), buf);",
          "1760:   else",
          "1761:     mutt_message(_(\"Unsubscribing from %s...\"), buf);",
          "1764:   snprintf(buf, sizeof(buf), \"%sSUBSCRIBE %s\", subscribe ? \"\" : \"UN\", mbox);",
          "1767:     goto fail;",
          "1770:   if (subscribe)",
          "1771:     mutt_message(_(\"Subscribed to %s\"), mx.mbox);",
          "1772:   else",
          "",
          "[Removed Lines]",
          "1762:   imap_munge_mbox_name(idata, mbox, sizeof(mbox), buf);",
          "1766:   if (imap_exec(idata, buf, 0) < 0)",
          "1769:   imap_unmunge_mbox_name(idata, mx.mbox);",
          "",
          "[Added Lines]",
          "1762:   imap_munge_mbox_name(mdata, mbox, sizeof(mbox), buf);",
          "1766:   if (imap_exec(mdata, buf, 0) < 0)",
          "1769:   imap_unmunge_mbox_name(mdata, mx.mbox);",
          "",
          "---------------",
          "--- Hunk 52 ---",
          "[Context before]",
          "1793: int imap_complete(char *buf, size_t buflen, char *path)",
          "1794: {",
          "1796:   char list[LONG_STRING];",
          "1797:   char tmp[LONG_STRING];",
          "1798:   struct ImapList listresp;",
          "",
          "[Removed Lines]",
          "1795:   struct ImapData *idata = NULL;",
          "",
          "[Added Lines]",
          "1795:   struct ImapMboxData *mdata = NULL;",
          "",
          "---------------",
          "--- Hunk 53 ---",
          "[Context before]",
          "1816:   {",
          "1817:     FREE(&mx.mbox);",
          "1818:     mutt_str_strfcpy(buf, path, buflen);",
          "",
          "[Removed Lines]",
          "1814:   idata = imap_conn_find(&(mx.account), MUTT_IMAP_CONN_NONEW);",
          "1815:   if (!idata)",
          "",
          "[Added Lines]",
          "1814:   mdata = imap_conn_find(&(mx.account), MUTT_IMAP_CONN_NONEW);",
          "1815:   if (!mdata)",
          "",
          "---------------",
          "--- Hunk 54 ---",
          "[Context before]",
          "1824:   if (mx.mbox && mx.mbox[0])",
          "1826:   else",
          "1827:     list[0] = '\\0';",
          "1830:   snprintf(tmp, sizeof(tmp), \"%s \\\"\\\" \\\"%s%%\\\"\", ImapListSubscribed ? \"LSUB\" : \"LIST\", list);",
          "1835:   mutt_str_strfcpy(completion, mx.mbox, sizeof(completion));",
          "1838:   do",
          "1839:   {",
          "1840:     listresp.name = NULL;",
          "1843:     if (rc == IMAP_CMD_CONTINUE && listresp.name)",
          "1844:     {",
          "",
          "[Removed Lines]",
          "1825:     imap_fix_path(idata, mx.mbox, list, sizeof(list));",
          "1832:   imap_cmd_start(idata, tmp);",
          "1836:   idata->cmdtype = IMAP_CT_LIST;",
          "1837:   idata->cmddata = &listresp;",
          "1841:     rc = imap_cmd_step(idata);",
          "",
          "[Added Lines]",
          "1825:     imap_fix_path(mdata, mx.mbox, list, sizeof(list));",
          "1832:   imap_cmd_start(mdata, tmp);",
          "1836:   mdata->cmdtype = IMAP_CT_LIST;",
          "1837:   mdata->cmddata = &listresp;",
          "1841:     rc = imap_cmd_step(mdata);",
          "",
          "---------------",
          "--- Hunk 55 ---",
          "[Context before]",
          "1863:       completions++;",
          "1864:     }",
          "1865:   } while (rc == IMAP_CMD_CONTINUE);",
          "1868:   if (completions)",
          "1869:   {",
          "",
          "[Removed Lines]",
          "1866:   idata->cmddata = NULL;",
          "",
          "[Added Lines]",
          "1866:   mdata->cmddata = NULL;",
          "",
          "---------------",
          "--- Hunk 56 ---",
          "[Context before]",
          "1897:   struct Buffer *sync_cmd = NULL;",
          "1898:   int err_continue = MUTT_NO;",
          "1902:   if (imap_parse_path(dest, &mx))",
          "1903:   {",
          "",
          "[Removed Lines]",
          "1900:   struct ImapData *idata = mailbox->data;",
          "",
          "[Added Lines]",
          "1900:   struct ImapMboxData *mdata = mailbox->data;",
          "",
          "---------------",
          "--- Hunk 57 ---",
          "[Context before]",
          "1906:   }",
          "1910:   {",
          "1911:     mutt_debug(3, \"%s not same server as %s\\n\", dest, mailbox->path);",
          "1912:     return 1;",
          "1913:   }",
          "1916:   if (!*mbox)",
          "1917:     mutt_str_strfcpy(mbox, \"INBOX\", sizeof(mbox));",
          "1920:   sync_cmd = mutt_buffer_new();",
          "1921:   for (int i = 0; i < mailbox->msg_count; i++)",
          "",
          "[Removed Lines]",
          "1909:   if (mutt_account_match(&(idata->conn->account), &(mx.account)) == 0)",
          "1915:   imap_fix_path(idata, mx.mbox, mbox, sizeof(mbox));",
          "1918:   imap_munge_mbox_name(idata, mmbox, sizeof(mmbox), mbox);",
          "",
          "[Added Lines]",
          "1909:   if (mutt_account_match(&(mdata->conn->account), &(mx.account)) == 0)",
          "1915:   imap_fix_path(mdata, mx.mbox, mbox, sizeof(mbox));",
          "1918:   imap_munge_mbox_name(mdata, mmbox, sizeof(mmbox), mbox);",
          "",
          "---------------",
          "--- Hunk 58 ---",
          "[Context before]",
          "1923:     if (mailbox->hdrs[i]->active && mailbox->hdrs[i]->changed &&",
          "1924:         mailbox->hdrs[i]->deleted && !mailbox->hdrs[i]->purge)",
          "1925:     {",
          "1927:       if (rc < 0)",
          "1928:       {",
          "1929:         mutt_debug(1, \"could not sync\\n\");",
          "",
          "[Removed Lines]",
          "1926:       rc = imap_sync_message_for_copy(idata, mailbox->hdrs[i], sync_cmd, &err_continue);",
          "",
          "[Added Lines]",
          "1926:       rc = imap_sync_message_for_copy(mdata, mailbox->hdrs[i], sync_cmd, &err_continue);",
          "",
          "---------------",
          "--- Hunk 59 ---",
          "[Context before]",
          "1936:   do",
          "1937:   {",
          "1939:     if (!rc)",
          "1940:     {",
          "1941:       mutt_debug(1, \"No messages to trash\\n\");",
          "",
          "[Removed Lines]",
          "1938:     rc = imap_exec_msgset(idata, \"UID COPY\", mmbox, MUTT_TRASH, false, false);",
          "",
          "[Added Lines]",
          "1938:     rc = imap_exec_msgset(mdata, \"UID COPY\", mmbox, MUTT_TRASH, false, false);",
          "",
          "---------------",
          "--- Hunk 60 ---",
          "[Context before]",
          "1954:     }",
          "1958:     if (rc == -2)",
          "1959:     {",
          "1960:       if (triedcreate)",
          "",
          "[Removed Lines]",
          "1957:     rc = imap_exec(idata, NULL, IMAP_CMD_FAIL_OK);",
          "",
          "[Added Lines]",
          "1957:     rc = imap_exec(mdata, NULL, IMAP_CMD_FAIL_OK);",
          "",
          "---------------",
          "--- Hunk 61 ---",
          "[Context before]",
          "1963:         break;",
          "1964:       }",
          "1967:         break;",
          "1968:       mutt_debug(3, \"server suggests TRYCREATE\\n\");",
          "1969:       snprintf(prompt, sizeof(prompt), _(\"Create %s?\"), mbox);",
          "",
          "[Removed Lines]",
          "1966:       if (mutt_str_strncasecmp(imap_get_qualifier(idata->buf), \"[TRYCREATE]\", 11) != 0)",
          "",
          "[Added Lines]",
          "1966:       if (mutt_str_strncasecmp(imap_get_qualifier(mdata->buf), \"[TRYCREATE]\", 11) != 0)",
          "",
          "---------------",
          "--- Hunk 62 ---",
          "[Context before]",
          "1972:         mutt_clear_error();",
          "1973:         goto out;",
          "1974:       }",
          "1976:         break;",
          "1977:       triedcreate = true;",
          "1978:     }",
          "",
          "[Removed Lines]",
          "1975:       if (imap_create_mailbox(idata, mbox) < 0)",
          "",
          "[Added Lines]",
          "1975:       if (imap_create_mailbox(mdata, mbox) < 0)",
          "",
          "---------------",
          "--- Hunk 63 ---",
          "[Context before]",
          "1981:   if (rc != 0)",
          "1982:   {",
          "1984:     goto out;",
          "1985:   }",
          "",
          "[Removed Lines]",
          "1983:     imap_error(\"imap_fast_trash\", idata->buf);",
          "",
          "[Added Lines]",
          "1983:     imap_error(\"imap_fast_trash\", mdata->buf);",
          "",
          "---------------",
          "--- Hunk 64 ---",
          "[Context before]",
          "2008:   int oldsort;",
          "2009:   int rc;",
          "2014:   {",
          "2015:     mutt_debug(2, \"no mailbox selected\\n\");",
          "2016:     return -1;",
          "",
          "[Removed Lines]",
          "2011:   struct ImapData *idata = ctx->mailbox->data;",
          "2013:   if (idata->state < IMAP_SELECTED)",
          "",
          "[Added Lines]",
          "2011:   struct ImapMboxData *mdata = ctx->mailbox->data;",
          "2013:   if (mdata->state < IMAP_SELECTED)",
          "",
          "---------------",
          "--- Hunk 65 ---",
          "[Context before]",
          "2021:   imap_allow_reopen(ctx);",
          "2024:   if (rc != 0)",
          "2025:     return rc;",
          "2028:   if (expunge && mutt_bit_isset(ctx->mailbox->rights, MUTT_ACL_DELETE))",
          "2029:   {",
          "2031:                           MUTT_DELETED, true, false);",
          "2032:     if (rc < 0)",
          "2033:     {",
          "",
          "[Removed Lines]",
          "2023:   rc = imap_check(idata, false);",
          "2030:     rc = imap_exec_msgset(idata, \"UID STORE\", \"+FLAGS.SILENT (\\\\Deleted)\",",
          "",
          "[Added Lines]",
          "2023:   rc = imap_check(mdata, false);",
          "2030:     rc = imap_exec_msgset(mdata, \"UID STORE\", \"+FLAGS.SILENT (\\\\Deleted)\",",
          "",
          "---------------",
          "--- Hunk 66 ---",
          "[Context before]",
          "2049:   }",
          "2051: #ifdef USE_HCACHE",
          "2053: #endif",
          "",
          "[Removed Lines]",
          "2052:   idata->hcache = imap_hcache_open(idata, NULL);",
          "",
          "[Added Lines]",
          "2052:   mdata->hcache = imap_hcache_open(mdata, NULL);",
          "",
          "---------------",
          "--- Hunk 67 ---",
          "[Context before]",
          "2060:     if (e->deleted)",
          "2061:     {",
          "2063: #ifdef USE_HCACHE",
          "2065: #endif",
          "2066:     }",
          "2068:     if (e->active && e->changed)",
          "2069:     {",
          "2070: #ifdef USE_HCACHE",
          "2072: #endif",
          "",
          "[Removed Lines]",
          "2062:       imap_cache_del(idata, e);",
          "2064:       imap_hcache_del(idata, HEADER_DATA(e)->uid);",
          "2071:       imap_hcache_put(idata, e);",
          "",
          "[Added Lines]",
          "2062:       imap_cache_del(mdata, e);",
          "2064:       imap_hcache_del(mdata, HEADER_DATA(e)->uid);",
          "2071:       imap_hcache_put(mdata, e);",
          "",
          "---------------",
          "--- Hunk 68 ---",
          "[Context before]",
          "2092:   }",
          "2094: #ifdef USE_HCACHE",
          "2096: #endif",
          "",
          "[Removed Lines]",
          "2095:   imap_hcache_close(idata);",
          "",
          "[Added Lines]",
          "2095:   imap_hcache_close(mdata);",
          "",
          "---------------",
          "--- Hunk 69 ---",
          "[Context before]",
          "2109:           mutt_get_sort_func(SORT_ORDER));",
          "2110:   }",
          "2113:   if (rc >= 0)",
          "2115:   if (rc >= 0)",
          "2117:   if (rc >= 0)",
          "2119:   if (rc >= 0)",
          "2122:   if (oldsort != Sort)",
          "2123:   {",
          "",
          "[Removed Lines]",
          "2112:   rc = sync_helper(idata, MUTT_ACL_DELETE, MUTT_DELETED, \"\\\\Deleted\");",
          "2114:     rc |= sync_helper(idata, MUTT_ACL_WRITE, MUTT_FLAG, \"\\\\Flagged\");",
          "2116:     rc |= sync_helper(idata, MUTT_ACL_WRITE, MUTT_OLD, \"Old\");",
          "2118:     rc |= sync_helper(idata, MUTT_ACL_SEEN, MUTT_READ, \"\\\\Seen\");",
          "2120:     rc |= sync_helper(idata, MUTT_ACL_WRITE, MUTT_REPLIED, \"\\\\Answered\");",
          "",
          "[Added Lines]",
          "2112:   rc = sync_helper(mdata, MUTT_ACL_DELETE, MUTT_DELETED, \"\\\\Deleted\");",
          "2114:     rc |= sync_helper(mdata, MUTT_ACL_WRITE, MUTT_FLAG, \"\\\\Flagged\");",
          "2116:     rc |= sync_helper(mdata, MUTT_ACL_WRITE, MUTT_OLD, \"Old\");",
          "2118:     rc |= sync_helper(mdata, MUTT_ACL_SEEN, MUTT_READ, \"\\\\Seen\");",
          "2120:     rc |= sync_helper(mdata, MUTT_ACL_WRITE, MUTT_REPLIED, \"\\\\Answered\");",
          "",
          "---------------",
          "--- Hunk 70 ---",
          "[Context before]",
          "2130:   if (rc > 0)",
          "2132:       rc = -1;",
          "2134:   if (rc < 0)",
          "",
          "[Removed Lines]",
          "2131:     if (imap_exec(idata, NULL, 0) != IMAP_CMD_OK)",
          "",
          "[Added Lines]",
          "2131:     if (imap_exec(mdata, NULL, 0) != IMAP_CMD_OK)",
          "",
          "---------------",
          "--- Hunk 71 ---",
          "[Context before]",
          "2138:       if (mutt_yesorno(_(\"Error saving flags. Close anyway?\"), 0) == MUTT_YES)",
          "2139:       {",
          "2140:         rc = 0;",
          "2142:         goto out;",
          "2143:       }",
          "2144:     }",
          "",
          "[Removed Lines]",
          "2141:         idata->state = IMAP_AUTHENTICATED;",
          "",
          "[Added Lines]",
          "2141:         mdata->state = IMAP_AUTHENTICATED;",
          "",
          "---------------",
          "--- Hunk 72 ---",
          "[Context before]",
          "2167:   {",
          "2168:     mutt_message(_(\"Expunging messages from server...\"));",
          "2172:     {",
          "2175:       rc = -1;",
          "2176:       goto out;",
          "2177:     }",
          "2179:   }",
          "2181:   if (expunge && ctx->mailbox->closing)",
          "2182:   {",
          "2185:   }",
          "2187:   if (MessageCacheClean)",
          "2190:   rc = 0;",
          "",
          "[Removed Lines]",
          "2170:     idata->reopen |= IMAP_EXPUNGE_EXPECTED;",
          "2171:     if (imap_exec(idata, \"EXPUNGE\", 0) != 0)",
          "2173:       idata->reopen &= ~IMAP_EXPUNGE_EXPECTED;",
          "2174:       imap_error(_(\"imap_sync_mailbox: EXPUNGE failed\"), idata->buf);",
          "2178:     idata->reopen &= ~IMAP_EXPUNGE_EXPECTED;",
          "2183:     imap_exec(idata, \"CLOSE\", IMAP_CMD_QUEUE);",
          "2184:     idata->state = IMAP_AUTHENTICATED;",
          "2188:     imap_cache_clean(idata);",
          "",
          "[Added Lines]",
          "2170:     mdata->reopen |= IMAP_EXPUNGE_EXPECTED;",
          "2171:     if (imap_exec(mdata, \"EXPUNGE\", 0) != 0)",
          "2173:       mdata->reopen &= ~IMAP_EXPUNGE_EXPECTED;",
          "2174:       imap_error(_(\"imap_sync_mailbox: EXPUNGE failed\"), mdata->buf);",
          "2178:     mdata->reopen &= ~IMAP_EXPUNGE_EXPECTED;",
          "2183:     imap_exec(mdata, \"CLOSE\", IMAP_CMD_QUEUE);",
          "2184:     mdata->state = IMAP_AUTHENTICATED;",
          "2188:     imap_cache_clean(mdata);",
          "",
          "---------------",
          "--- Hunk 73 ---",
          "[Context before]",
          "2204: static int imap_mbox_open(struct Context *ctx)",
          "2205: {",
          "2207:   struct ImapStatus *status = NULL;",
          "2208:   char buf[PATH_MAX];",
          "2209:   char bufout[PATH_MAX];",
          "",
          "[Removed Lines]",
          "2206:   struct ImapData *idata = NULL;",
          "",
          "[Added Lines]",
          "2206:   struct ImapMboxData *mdata = NULL;",
          "",
          "---------------",
          "--- Hunk 74 ---",
          "[Context before]",
          "2219:   }",
          "2224:     goto fail_noidata;",
          "2226:     goto fail;",
          "2233:   if (!*buf)",
          "2234:     mutt_str_strfcpy(buf, \"INBOX\", sizeof(buf));",
          "2239:   mutt_str_strfcpy(ctx->mailbox->path, buf, sizeof(ctx->mailbox->path));",
          "2240:   mutt_str_strfcpy(ctx->mailbox->realpath, ctx->mailbox->path,",
          "2241:                    sizeof(ctx->mailbox->realpath));",
          "2256:   {",
          "2257:     snprintf(bufout, sizeof(bufout), \"MYRIGHTS %s\", buf);",
          "2259:   }",
          "2261:   else",
          "2262:   {",
          "2271:   }",
          "2273:   pmx.mbox = NULL;",
          "",
          "[Removed Lines]",
          "2222:   idata = imap_conn_find(&(mx.account), MUTT_IMAP_CONN_NOSELECT);",
          "2223:   if (!idata)",
          "2225:   if (idata->state < IMAP_AUTHENTICATED)",
          "2229:   ctx->mailbox->data = idata;",
          "2232:   imap_fix_path(idata, mx.mbox, buf, sizeof(buf));",
          "2235:   FREE(&(idata->mbox_name));",
          "2236:   idata->mbox_name = mutt_str_strdup(buf);",
          "2237:   imap_qualify_path(buf, sizeof(buf), &mx, idata->mbox_name);",
          "2243:   idata->ctx = ctx;",
          "2246:   idata->status = false;",
          "2247:   memset(idata->ctx->mailbox->rights, 0, sizeof(idata->ctx->mailbox->rights));",
          "2248:   idata->new_mail_count = 0;",
          "2249:   idata->max_msn = 0;",
          "2251:   mutt_message(_(\"Selecting %s...\"), idata->mbox_name);",
          "2252:   imap_munge_mbox_name(idata, buf, sizeof(buf), idata->mbox_name);",
          "2255:   if (mutt_bit_isset(idata->capabilities, ACL))",
          "2258:     imap_exec(idata, bufout, IMAP_CMD_QUEUE);",
          "2263:     mutt_bit_set(idata->ctx->mailbox->rights, MUTT_ACL_LOOKUP);",
          "2264:     mutt_bit_set(idata->ctx->mailbox->rights, MUTT_ACL_READ);",
          "2265:     mutt_bit_set(idata->ctx->mailbox->rights, MUTT_ACL_SEEN);",
          "2266:     mutt_bit_set(idata->ctx->mailbox->rights, MUTT_ACL_WRITE);",
          "2267:     mutt_bit_set(idata->ctx->mailbox->rights, MUTT_ACL_INSERT);",
          "2268:     mutt_bit_set(idata->ctx->mailbox->rights, MUTT_ACL_POST);",
          "2269:     mutt_bit_set(idata->ctx->mailbox->rights, MUTT_ACL_CREATE);",
          "2270:     mutt_bit_set(idata->ctx->mailbox->rights, MUTT_ACL_DELETE);",
          "",
          "[Added Lines]",
          "2222:   mdata = imap_conn_find(&(mx.account), MUTT_IMAP_CONN_NOSELECT);",
          "2223:   if (!mdata)",
          "2225:   if (mdata->state < IMAP_AUTHENTICATED)",
          "2229:   ctx->mailbox->data = mdata;",
          "2232:   imap_fix_path(mdata, mx.mbox, buf, sizeof(buf));",
          "2235:   FREE(&(mdata->mbox_name));",
          "2236:   mdata->mbox_name = mutt_str_strdup(buf);",
          "2237:   imap_qualify_path(buf, sizeof(buf), &mx, mdata->mbox_name);",
          "2243:   mdata->ctx = ctx;",
          "2246:   mdata->status = false;",
          "2247:   memset(mdata->ctx->mailbox->rights, 0, sizeof(mdata->ctx->mailbox->rights));",
          "2248:   mdata->new_mail_count = 0;",
          "2249:   mdata->max_msn = 0;",
          "2251:   mutt_message(_(\"Selecting %s...\"), mdata->mbox_name);",
          "2252:   imap_munge_mbox_name(mdata, buf, sizeof(buf), mdata->mbox_name);",
          "2255:   if (mutt_bit_isset(mdata->capabilities, ACL))",
          "2258:     imap_exec(mdata, bufout, IMAP_CMD_QUEUE);",
          "2263:     mutt_bit_set(mdata->ctx->mailbox->rights, MUTT_ACL_LOOKUP);",
          "2264:     mutt_bit_set(mdata->ctx->mailbox->rights, MUTT_ACL_READ);",
          "2265:     mutt_bit_set(mdata->ctx->mailbox->rights, MUTT_ACL_SEEN);",
          "2266:     mutt_bit_set(mdata->ctx->mailbox->rights, MUTT_ACL_WRITE);",
          "2267:     mutt_bit_set(mdata->ctx->mailbox->rights, MUTT_ACL_INSERT);",
          "2268:     mutt_bit_set(mdata->ctx->mailbox->rights, MUTT_ACL_POST);",
          "2269:     mutt_bit_set(mdata->ctx->mailbox->rights, MUTT_ACL_CREATE);",
          "2270:     mutt_bit_set(mdata->ctx->mailbox->rights, MUTT_ACL_DELETE);",
          "",
          "---------------",
          "--- Hunk 75 ---",
          "[Context before]",
          "2279:   FREE(&pmx.mbox);",
          "2281:   if (ImapCheckSubscribed)",
          "2284: #ifdef USE_HCACHE",
          "2286:     condstore = \" (CONDSTORE)\";",
          "2287:   else",
          "2288: #endif",
          "",
          "[Removed Lines]",
          "2282:     imap_exec(idata, \"LSUB \\\"\\\" \\\"*\\\"\", IMAP_CMD_QUEUE);",
          "2285:   if (mutt_bit_isset(idata->capabilities, CONDSTORE) && ImapCondStore)",
          "",
          "[Added Lines]",
          "2282:     imap_exec(mdata, \"LSUB \\\"\\\" \\\"*\\\"\", IMAP_CMD_QUEUE);",
          "2285:   if (mutt_bit_isset(mdata->capabilities, CONDSTORE) && ImapCondStore)",
          "",
          "---------------",
          "--- Hunk 76 ---",
          "[Context before]",
          "2291:   snprintf(bufout, sizeof(bufout), \"%s %s%s\",",
          "2292:            ctx->mailbox->readonly ? \"EXAMINE\" : \"SELECT\", buf, condstore);",
          "2300:   do",
          "2301:   {",
          "2302:     char *pc = NULL;",
          "2305:     if (rc != IMAP_CMD_CONTINUE)",
          "2306:       break;",
          "2312:     if (mutt_str_strncasecmp(\"FLAGS\", pc, 5) == 0)",
          "2313:     {",
          "2316:       {",
          "2317:         mutt_debug(3, \"Getting mailbox FLAGS\\n\");",
          "2319:         if (!pc)",
          "2320:           goto fail;",
          "2321:       }",
          "",
          "[Removed Lines]",
          "2294:   idata->state = IMAP_SELECTED;",
          "2296:   imap_cmd_start(idata, bufout);",
          "2298:   status = imap_mboxcache_get(idata, idata->mbox_name, true);",
          "2304:     rc = imap_cmd_step(idata);",
          "2308:     pc = idata->buf + 2;",
          "2315:       if (STAILQ_EMPTY(&idata->flags))",
          "2318:         pc = get_flags(&idata->flags, pc);",
          "",
          "[Added Lines]",
          "2294:   mdata->state = IMAP_SELECTED;",
          "2296:   imap_cmd_start(mdata, bufout);",
          "2298:   status = imap_mboxcache_get(mdata, mdata->mbox_name, true);",
          "2304:     rc = imap_cmd_step(mdata);",
          "2308:     pc = mdata->buf + 2;",
          "2315:       if (STAILQ_EMPTY(&mdata->flags))",
          "2318:         pc = get_flags(&mdata->flags, pc);",
          "",
          "---------------",
          "--- Hunk 77 ---",
          "[Context before]",
          "2325:     {",
          "2326:       mutt_debug(3, \"Getting mailbox PERMANENTFLAGS\\n\");",
          "2330:       pc += 13;",
          "2332:       if (!pc)",
          "2333:         goto fail;",
          "2334:     }",
          "",
          "[Removed Lines]",
          "2328:       mutt_list_free(&idata->flags);",
          "2331:       pc = get_flags(&(idata->flags), pc);",
          "",
          "[Added Lines]",
          "2328:       mutt_list_free(&mdata->flags);",
          "2331:       pc = get_flags(&(mdata->flags), pc);",
          "",
          "---------------",
          "--- Hunk 78 ---",
          "[Context before]",
          "2338:       mutt_debug(3, \"Getting mailbox UIDVALIDITY\\n\");",
          "2339:       pc += 3;",
          "2340:       pc = imap_next_word(pc);",
          "2342:         goto fail;",
          "2344:     }",
          "2345:     else if (mutt_str_strncasecmp(\"OK [UIDNEXT\", pc, 11) == 0)",
          "2346:     {",
          "2347:       mutt_debug(3, \"Getting mailbox UIDNEXT\\n\");",
          "2348:       pc += 3;",
          "2349:       pc = imap_next_word(pc);",
          "2351:         goto fail;",
          "2353:     }",
          "2354:     else if (mutt_str_strncasecmp(\"OK [HIGHESTMODSEQ\", pc, 17) == 0)",
          "2355:     {",
          "2356:       mutt_debug(3, \"Getting mailbox HIGHESTMODSEQ\\n\");",
          "2357:       pc += 3;",
          "2358:       pc = imap_next_word(pc);",
          "2360:         goto fail;",
          "2362:     }",
          "2363:     else if (mutt_str_strncasecmp(\"OK [NOMODSEQ\", pc, 12) == 0)",
          "2364:     {",
          "2365:       mutt_debug(3, \"Mailbox has NOMODSEQ set\\n\");",
          "2367:     }",
          "2368:     else",
          "2369:     {",
          "2370:       pc = imap_next_word(pc);",
          "2371:       if (mutt_str_strncasecmp(\"EXISTS\", pc, 6) == 0)",
          "2372:       {",
          "2375:       }",
          "2376:     }",
          "2377:   } while (rc == IMAP_CMD_CONTINUE);",
          "2379:   if (rc == IMAP_CMD_NO)",
          "2380:   {",
          "2383:     mutt_error(\"%s\", s);",
          "2384:     goto fail;",
          "",
          "[Removed Lines]",
          "2341:       if (mutt_str_atoui(pc, &idata->uid_validity) < 0)",
          "2343:       status->uidvalidity = idata->uid_validity;",
          "2350:       if (mutt_str_atoui(pc, &idata->uidnext) < 0)",
          "2352:       status->uidnext = idata->uidnext;",
          "2359:       if (mutt_str_atoull(pc, &idata->modseq) < 0)",
          "2361:       status->modseq = idata->modseq;",
          "2366:       status->modseq = idata->modseq = 0;",
          "2373:         count = idata->new_mail_count;",
          "2374:         idata->new_mail_count = 0;",
          "",
          "[Added Lines]",
          "2341:       if (mutt_str_atoui(pc, &mdata->uid_validity) < 0)",
          "2343:       status->uidvalidity = mdata->uid_validity;",
          "2350:       if (mutt_str_atoui(pc, &mdata->uidnext) < 0)",
          "2352:       status->uidnext = mdata->uidnext;",
          "2359:       if (mutt_str_atoull(pc, &mdata->modseq) < 0)",
          "2361:       status->modseq = mdata->modseq;",
          "2366:       status->modseq = mdata->modseq = 0;",
          "2373:         count = mdata->new_mail_count;",
          "2374:         mdata->new_mail_count = 0;",
          "",
          "---------------",
          "--- Hunk 79 ---",
          "[Context before]",
          "2388:     goto fail;",
          "2393:   {",
          "2394:     mutt_debug(2, \"Mailbox is read-only.\\n\");",
          "2395:     ctx->mailbox->readonly = true;",
          "",
          "[Removed Lines]",
          "2391:   if ((mutt_str_strncasecmp(imap_get_qualifier(idata->buf), \"[READ-ONLY]\", 11) == 0) &&",
          "2392:       !mutt_bit_isset(idata->capabilities, ACL))",
          "",
          "[Added Lines]",
          "2391:   if ((mutt_str_strncasecmp(imap_get_qualifier(mdata->buf), \"[READ-ONLY]\", 11) == 0) &&",
          "2392:       !mutt_bit_isset(mdata->capabilities, ACL))",
          "",
          "---------------",
          "--- Hunk 80 ---",
          "[Context before]",
          "2399:   if (DebugLevel > 2)",
          "2400:   {",
          "2402:       mutt_debug(3, \"No folder flags found\\n\");",
          "2403:     else",
          "2404:     {",
          "",
          "[Removed Lines]",
          "2401:     if (STAILQ_EMPTY(&idata->flags))",
          "",
          "[Added Lines]",
          "2401:     if (STAILQ_EMPTY(&mdata->flags))",
          "",
          "---------------",
          "--- Hunk 81 ---",
          "[Context before]",
          "2406:       struct Buffer flag_buffer;",
          "2407:       mutt_buffer_init(&flag_buffer);",
          "2408:       mutt_buffer_printf(&flag_buffer, \"Mailbox flags: \");",
          "2410:       {",
          "2411:         mutt_buffer_printf(&flag_buffer, \"[%s] \", np->data);",
          "2412:       }",
          "",
          "[Removed Lines]",
          "2409:       STAILQ_FOREACH(np, &idata->flags, entries)",
          "",
          "[Added Lines]",
          "2409:       STAILQ_FOREACH(np, &mdata->flags, entries)",
          "",
          "---------------",
          "--- Hunk 82 ---",
          "[Context before]",
          "2415:     }",
          "2416:   }",
          "2422:   {",
          "2423:     ctx->mailbox->readonly = true;",
          "2424:   }",
          "",
          "[Removed Lines]",
          "2418:   if (!(mutt_bit_isset(idata->ctx->mailbox->rights, MUTT_ACL_DELETE) ||",
          "2419:         mutt_bit_isset(idata->ctx->mailbox->rights, MUTT_ACL_SEEN) ||",
          "2420:         mutt_bit_isset(idata->ctx->mailbox->rights, MUTT_ACL_WRITE) ||",
          "2421:         mutt_bit_isset(idata->ctx->mailbox->rights, MUTT_ACL_INSERT)))",
          "",
          "[Added Lines]",
          "2418:   if (!(mutt_bit_isset(mdata->ctx->mailbox->rights, MUTT_ACL_DELETE) ||",
          "2419:         mutt_bit_isset(mdata->ctx->mailbox->rights, MUTT_ACL_SEEN) ||",
          "2420:         mutt_bit_isset(mdata->ctx->mailbox->rights, MUTT_ACL_WRITE) ||",
          "2421:         mutt_bit_isset(mdata->ctx->mailbox->rights, MUTT_ACL_INSERT)))",
          "",
          "---------------",
          "--- Hunk 83 ---",
          "[Context before]",
          "2428:   ctx->mailbox->v2r = mutt_mem_calloc(count, sizeof(int));",
          "2429:   ctx->mailbox->msg_count = 0;",
          "2432:   {",
          "2433:     mutt_error(_(\"Error opening mailbox\"));",
          "2434:     goto fail;",
          "",
          "[Removed Lines]",
          "2431:   if (count && (imap_read_headers(idata, 1, count, true) < 0))",
          "",
          "[Added Lines]",
          "2431:   if (count && (imap_read_headers(mdata, 1, count, true) < 0))",
          "",
          "---------------",
          "--- Hunk 84 ---",
          "[Context before]",
          "2439:   return 0;",
          "2441: fail:",
          "2444: fail_noidata:",
          "2445:   FREE(&mx.mbox);",
          "2446:   return -1;",
          "",
          "[Removed Lines]",
          "2442:   if (idata->state == IMAP_SELECTED)",
          "2443:     idata->state = IMAP_AUTHENTICATED;",
          "",
          "[Added Lines]",
          "2442:   if (mdata->state == IMAP_SELECTED)",
          "2443:     mdata->state = IMAP_AUTHENTICATED;",
          "",
          "---------------",
          "--- Hunk 85 ---",
          "[Context before]",
          "2452: static int imap_mbox_open_append(struct Context *ctx, int flags)",
          "2453: {",
          "2455:   char mailbox[PATH_MAX];",
          "2456:   struct ImapMbox mx;",
          "2457:   int rc;",
          "",
          "[Removed Lines]",
          "2454:   struct ImapData *idata = NULL;",
          "",
          "[Added Lines]",
          "2454:   struct ImapMboxData *mdata = NULL;",
          "",
          "---------------",
          "--- Hunk 86 ---",
          "[Context before]",
          "2467:   {",
          "2468:     FREE(&mx.mbox);",
          "2469:     return -1;",
          "2470:   }",
          "2475:   if (!*mailbox)",
          "2476:     mutt_str_strfcpy(mailbox, \"INBOX\", sizeof(mailbox));",
          "2477:   FREE(&mx.mbox);",
          "",
          "[Removed Lines]",
          "2465:   idata = imap_conn_find(&(mx.account), 0);",
          "2466:   if (!idata)",
          "2472:   ctx->mailbox->data = idata;",
          "2474:   imap_fix_path(idata, mx.mbox, mailbox, sizeof(mailbox));",
          "",
          "[Added Lines]",
          "2465:   mdata = imap_conn_find(&(mx.account), 0);",
          "2466:   if (!mdata)",
          "2472:   ctx->mailbox->data = mdata;",
          "2474:   imap_fix_path(mdata, mx.mbox, mailbox, sizeof(mailbox));",
          "",
          "---------------",
          "--- Hunk 87 ---",
          "[Context before]",
          "2488:   if (Confirmcreate && mutt_yesorno(buf, 1) != MUTT_YES)",
          "2489:     return -1;",
          "2492:     return -1;",
          "2494:   return 0;",
          "",
          "[Removed Lines]",
          "2491:   if (imap_create_mailbox(idata, mailbox) < 0)",
          "",
          "[Added Lines]",
          "2491:   if (imap_create_mailbox(mdata, mailbox) < 0)",
          "",
          "---------------",
          "--- Hunk 88 ---",
          "[Context before]",
          "2520: static int imap_mbox_close(struct Context *ctx)",
          "2521: {",
          "2525:     return 0;",
          "2536:   {",
          "2538:     {",
          "2541:       if (!ctx->deleted)",
          "2544:     }",
          "2556:     for (int i = 0; i < IMAP_CACHE_LEN; i++)",
          "2557:     {",
          "2559:       {",
          "2562:       }",
          "2563:     }",
          "2566:   }",
          "",
          "[Removed Lines]",
          "2522:   struct ImapData *idata = ctx->mailbox->data;",
          "2524:   if (!idata)",
          "2535:   if (ctx == idata->ctx)",
          "2537:     if (idata->status != IMAP_FATAL && idata->state >= IMAP_SELECTED)",
          "2542:         imap_exec(idata, \"CLOSE\", IMAP_CMD_QUEUE);",
          "2543:       idata->state = IMAP_AUTHENTICATED;",
          "2546:     idata->reopen &= IMAP_REOPEN_ALLOW;",
          "2547:     FREE(&(idata->mbox_name));",
          "2548:     mutt_list_free(&idata->flags);",
          "2549:     idata->ctx = NULL;",
          "2551:     mutt_hash_destroy(&idata->uid_hash);",
          "2552:     FREE(&idata->msn_index);",
          "2553:     idata->msn_index_size = 0;",
          "2554:     idata->max_msn = 0;",
          "2558:       if (idata->cache[i].path)",
          "2560:         unlink(idata->cache[i].path);",
          "2561:         FREE(&idata->cache[i].path);",
          "2565:     mutt_bcache_close(&idata->bcache);",
          "",
          "[Added Lines]",
          "2522:   struct ImapMboxData *mdata = ctx->mailbox->data;",
          "2524:   if (!mdata)",
          "2535:   if (ctx == mdata->ctx)",
          "2537:     if (mdata->status != IMAP_FATAL && mdata->state >= IMAP_SELECTED)",
          "2542:         imap_exec(mdata, \"CLOSE\", IMAP_CMD_QUEUE);",
          "2543:       mdata->state = IMAP_AUTHENTICATED;",
          "2546:     mdata->reopen &= IMAP_REOPEN_ALLOW;",
          "2547:     FREE(&(mdata->mbox_name));",
          "2548:     mutt_list_free(&mdata->flags);",
          "2549:     mdata->ctx = NULL;",
          "2551:     mutt_hash_destroy(&mdata->uid_hash);",
          "2552:     FREE(&mdata->msn_index);",
          "2553:     mdata->msn_index_size = 0;",
          "2554:     mdata->max_msn = 0;",
          "2558:       if (mdata->cache[i].path)",
          "2560:         unlink(mdata->cache[i].path);",
          "2561:         FREE(&mdata->cache[i].path);",
          "2565:     mutt_bcache_close(&mdata->bcache);",
          "",
          "---------------",
          "--- Hunk 89 ---",
          "[Context before]",
          "2570:   {",
          "2572:     if (ctx->mailbox->hdrs[i] && ctx->mailbox->hdrs[i]->data)",
          "2574:   }",
          "2576:   return 0;",
          "",
          "[Removed Lines]",
          "2573:       imap_free_header_data((struct ImapHeaderData **) &(ctx->mailbox->hdrs[i]->data));",
          "",
          "[Added Lines]",
          "2573:       imap_free_email_data((struct ImapEmailData **) &(ctx->mailbox->hdrs[i]->data));",
          "",
          "---------------",
          "--- Hunk 90 ---",
          "[Context before]",
          "2601: {",
          "2602:   char *new = NULL;",
          "2603:   char *checker = NULL;",
          "2608:   {",
          "2609:     mutt_error(_(\"IMAP server doesn't support custom flags\"));",
          "2610:     return -1;",
          "",
          "[Removed Lines]",
          "2604:   struct ImapData *idata = ctx->mailbox->data;",
          "2607:   if (!imap_has_flag(&idata->flags, NULL))",
          "",
          "[Added Lines]",
          "2604:   struct ImapMboxData *mdata = ctx->mailbox->data;",
          "2607:   if (!imap_has_flag(&mdata->flags, NULL))",
          "",
          "---------------",
          "--- Hunk 91 ---",
          "[Context before]",
          "2688:   struct Buffer *cmd = NULL;",
          "2689:   char uid[11];",
          "2693:   if (*buf == '\\0')",
          "2694:     buf = NULL;",
          "2697:     return 0;",
          "2699:   snprintf(uid, sizeof(uid), \"%u\", HEADER_DATA(e)->uid);",
          "",
          "[Removed Lines]",
          "2691:   struct ImapData *idata = ctx->mailbox->data;",
          "2696:   if (!mutt_bit_isset(idata->ctx->mailbox->rights, MUTT_ACL_WRITE))",
          "",
          "[Added Lines]",
          "2691:   struct ImapMboxData *mdata = ctx->mailbox->data;",
          "2696:   if (!mutt_bit_isset(mdata->ctx->mailbox->rights, MUTT_ACL_WRITE))",
          "",
          "---------------",
          "--- Hunk 92 ---",
          "[Context before]",
          "2720:     {",
          "2721:       mutt_buffer_free(&cmd);",
          "2722:       return -1;",
          "",
          "[Removed Lines]",
          "2719:     if (imap_exec(idata, cmd->data, 0) != 0)",
          "",
          "[Added Lines]",
          "2719:     if (imap_exec(mdata, cmd->data, 0) != 0)",
          "",
          "---------------",
          "--- Hunk 93 ---",
          "[Context before]",
          "2741:     mutt_buffer_addstr(cmd, buf);",
          "2742:     mutt_buffer_addstr(cmd, \")\");",
          "2745:     {",
          "2746:       mutt_debug(1, \"fail to add new flags\\n\");",
          "2747:       mutt_buffer_free(&cmd);",
          "",
          "[Removed Lines]",
          "2744:     if (imap_exec(idata, cmd->data, 0) != 0)",
          "",
          "[Added Lines]",
          "2744:     if (imap_exec(mdata, cmd->data, 0) != 0)",
          "",
          "---------------"
        ],
        "imap/imap_private.h||imap/imap_private.h": [
          "File: imap/imap_private.h -> imap/imap_private.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "35: struct ConnAccount;",
          "36: struct Context;",
          "37: struct Email;",
          "39: struct ImapMbox;",
          "40: struct Message;",
          "41: struct Progress;",
          "",
          "[Removed Lines]",
          "38: struct ImapHeaderData;",
          "",
          "[Added Lines]",
          "38: struct ImapEmailData;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "202: };",
          "210: {",
          "211:   struct Connection *conn;",
          "212:   bool recovering;",
          "",
          "[Removed Lines]",
          "209: struct ImapData",
          "",
          "[Added Lines]",
          "209: struct ImapMboxData",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "298:                      int flag, bool changed, bool invert);",
          "306: bool imap_has_flag(struct ListHead *flag_list, const char *flag);",
          "315: bool imap_code(const char *s);",
          "326: int imap_append_message(struct Context *ctx, struct Message *msg);",
          "328: int imap_msg_open(struct Context *ctx, struct Message *msg, int msgno);",
          "",
          "[Removed Lines]",
          "292: int imap_check(struct ImapData *idata, bool force);",
          "293: int imap_create_mailbox(struct ImapData *idata, char *mailbox);",
          "294: int imap_rename_mailbox(struct ImapData *idata, struct ImapMbox *mx, const char *newname);",
          "295: struct ImapStatus *imap_mboxcache_get(struct ImapData *idata, const char *mbox, bool create);",
          "296: void imap_mboxcache_free(struct ImapData *idata);",
          "297: int imap_exec_msgset(struct ImapData *idata, const char *pre, const char *post,",
          "299: int imap_open_connection(struct ImapData *idata);",
          "300: void imap_close_connection(struct ImapData *idata);",
          "301: struct ImapData *imap_conn_find(const struct ConnAccount *account, int flags);",
          "302: int imap_read_literal(FILE *fp, struct ImapData *idata, unsigned long bytes, struct Progress *pbar);",
          "303: void imap_expunge_mailbox(struct ImapData *idata);",
          "304: void imap_logout(struct ImapData **idata);",
          "305: int imap_sync_message_for_copy(struct ImapData *idata, struct Email *e, struct Buffer *cmd, int *err_continue);",
          "309: int imap_authenticate(struct ImapData *idata);",
          "312: int imap_cmd_start(struct ImapData *idata, const char *cmdstr);",
          "313: int imap_cmd_step(struct ImapData *idata);",
          "314: void imap_cmd_finish(struct ImapData *idata);",
          "316: const char *imap_cmd_trailer(struct ImapData *idata);",
          "317: int imap_exec(struct ImapData *idata, const char *cmdstr, int flags);",
          "318: int imap_cmd_idle(struct ImapData *idata);",
          "321: void imap_free_header_data(struct ImapHeaderData **data);",
          "322: int imap_read_headers(struct ImapData *idata, unsigned int msn_begin, unsigned int msn_end, bool initial_download);",
          "323: char *imap_set_flags(struct ImapData *idata, struct Email *e, char *s, int *server_changes);",
          "324: int imap_cache_del(struct ImapData *idata, struct Email *e);",
          "325: int imap_cache_clean(struct ImapData *idata);",
          "",
          "[Added Lines]",
          "292: int imap_check(struct ImapMboxData *mdata, bool force);",
          "293: int imap_create_mailbox(struct ImapMboxData *mdata, char *mailbox);",
          "294: int imap_rename_mailbox(struct ImapMboxData *mdata, struct ImapMbox *mx, const char *newname);",
          "295: struct ImapStatus *imap_mboxcache_get(struct ImapMboxData *mdata, const char *mbox, bool create);",
          "296: void imap_mboxcache_free(struct ImapMboxData *mdata);",
          "297: int imap_exec_msgset(struct ImapMboxData *mdata, const char *pre, const char *post,",
          "299: int imap_open_connection(struct ImapMboxData *mdata);",
          "300: void imap_close_connection(struct ImapMboxData *mdata);",
          "301: struct ImapMboxData *imap_conn_find(const struct ConnAccount *account, int flags);",
          "302: int imap_read_literal(FILE *fp, struct ImapMboxData *mdata, unsigned long bytes, struct Progress *pbar);",
          "303: void imap_expunge_mailbox(struct ImapMboxData *mdata);",
          "304: void imap_logout(struct ImapMboxData **mdata);",
          "305: int imap_sync_message_for_copy(struct ImapMboxData *mdata, struct Email *e, struct Buffer *cmd, int *err_continue);",
          "309: int imap_authenticate(struct ImapMboxData *mdata);",
          "312: int imap_cmd_start(struct ImapMboxData *mdata, const char *cmdstr);",
          "313: int imap_cmd_step(struct ImapMboxData *mdata);",
          "314: void imap_cmd_finish(struct ImapMboxData *mdata);",
          "316: const char *imap_cmd_trailer(struct ImapMboxData *mdata);",
          "317: int imap_exec(struct ImapMboxData *mdata, const char *cmdstr, int flags);",
          "318: int imap_cmd_idle(struct ImapMboxData *mdata);",
          "321: void imap_free_email_data(struct ImapEmailData **data);",
          "322: int imap_read_headers(struct ImapMboxData *mdata, unsigned int msn_begin, unsigned int msn_end, bool initial_download);",
          "323: char *imap_set_flags(struct ImapMboxData *mdata, struct Email *e, char *s, int *server_changes);",
          "324: int imap_cache_del(struct ImapMboxData *mdata, struct Email *e);",
          "325: int imap_cache_clean(struct ImapMboxData *mdata);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "333: #ifdef USE_HCACHE",
          "342: #endif",
          "344: int imap_continue(const char *msg, const char *resp);",
          "345: void imap_error(const char *where, const char *msg);",
          "350: int imap_get_literal_count(const char *buf, unsigned int *bytes);",
          "351: char *imap_get_qualifier(char *buf);",
          "352: int imap_mxcmp(const char *mx1, const char *mx2);",
          "",
          "[Removed Lines]",
          "334: header_cache_t *imap_hcache_open(struct ImapData *idata, const char *path);",
          "335: void imap_hcache_close(struct ImapData *idata);",
          "336: struct Email *imap_hcache_get(struct ImapData *idata, unsigned int uid);",
          "337: int imap_hcache_put(struct ImapData *idata, struct Email *e);",
          "338: int imap_hcache_del(struct ImapData *idata, unsigned int uid);",
          "339: int imap_hcache_store_uid_seqset(struct ImapData *idata);",
          "340: int imap_hcache_clear_uid_seqset(struct ImapData *idata);",
          "341: char *imap_hcache_get_uid_seqset(struct ImapData *idata);",
          "346: struct ImapData *imap_new_idata(void);",
          "347: void imap_free_idata(struct ImapData **idata);",
          "348: char *imap_fix_path(struct ImapData *idata, const char *mailbox, char *path, size_t plen);",
          "349: void imap_cachepath(struct ImapData *idata, const char *mailbox, char *dest, size_t dlen);",
          "",
          "[Added Lines]",
          "334: header_cache_t *imap_hcache_open(struct ImapMboxData *mdata, const char *path);",
          "335: void imap_hcache_close(struct ImapMboxData *mdata);",
          "336: struct Email *imap_hcache_get(struct ImapMboxData *mdata, unsigned int uid);",
          "337: int imap_hcache_put(struct ImapMboxData *mdata, struct Email *e);",
          "338: int imap_hcache_del(struct ImapMboxData *mdata, unsigned int uid);",
          "339: int imap_hcache_store_uid_seqset(struct ImapMboxData *mdata);",
          "340: int imap_hcache_clear_uid_seqset(struct ImapMboxData *mdata);",
          "341: char *imap_hcache_get_uid_seqset(struct ImapMboxData *mdata);",
          "346: struct ImapMboxData *imap_new_idata(void);",
          "347: void imap_free_idata(struct ImapMboxData **mdata);",
          "348: char *imap_fix_path(struct ImapMboxData *mdata, const char *mailbox, char *path, size_t plen);",
          "349: void imap_cachepath(struct ImapMboxData *mdata, const char *mailbox, char *dest, size_t dlen);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "354: void imap_qualify_path(char *buf, size_t buflen, struct ImapMbox *mx, char *path);",
          "355: void imap_quote_string(char *dest, size_t dlen, const char *src, bool quote_backtick);",
          "356: void imap_unquote_string(char *s);",
          "359: struct SeqsetIterator *mutt_seqset_iterator_new(const char *seqset);",
          "360: int mutt_seqset_iterator_next(struct SeqsetIterator *iter, unsigned int *next);",
          "361: void mutt_seqset_iterator_free(struct SeqsetIterator **p_iter);",
          "",
          "[Removed Lines]",
          "357: void imap_munge_mbox_name(struct ImapData *idata, char *dest, size_t dlen, const char *src);",
          "358: void imap_unmunge_mbox_name(struct ImapData *idata, char *s);",
          "",
          "[Added Lines]",
          "357: void imap_munge_mbox_name(struct ImapMboxData *mdata, char *dest, size_t dlen, const char *src);",
          "358: void imap_unmunge_mbox_name(struct ImapMboxData *mdata, char *s);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "363: void imap_get_parent(const char *mbox, char delim, char *buf, size_t buflen);",
          "368: void imap_allow_reopen(struct Context *ctx);",
          "369: void imap_disallow_reopen(struct Context *ctx);",
          "",
          "[Removed Lines]",
          "366: void imap_utf_encode(struct ImapData *idata, char **s);",
          "367: void imap_utf_decode(struct ImapData *idata, char **s);",
          "",
          "[Added Lines]",
          "366: void imap_utf_encode(struct ImapMboxData *mdata, char **s);",
          "367: void imap_utf_decode(struct ImapMboxData *mdata, char **s);",
          "",
          "---------------"
        ],
        "imap/message.c||imap/message.c": [
          "File: imap/message.c -> imap/message.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "68: char *ImapHeaders; ///< Config: (imap) Additional email headers to download when getting index",
          "75: {",
          "78: }",
          "88: {",
          "89:   char mailbox[PATH_MAX];",
          "97: }",
          "107: {",
          "109:     return NULL;",
          "112:   char id[64];",
          "115: }",
          "125: {",
          "127:     return NULL;",
          "130:   char id[64];",
          "133: }",
          "143: {",
          "145:     return -1;",
          "148:   char id[64];",
          "152: }",
          "",
          "[Removed Lines]",
          "74: static struct ImapHeaderData *new_header_data(void)",
          "76:   struct ImapHeaderData *d = mutt_mem_calloc(1, sizeof(struct ImapHeaderData));",
          "77:   return d;",
          "87: static struct BodyCache *msg_cache_open(struct ImapData *idata)",
          "91:   if (idata->bcache)",
          "92:     return idata->bcache;",
          "94:   imap_cachepath(idata, idata->mbox_name, mailbox, sizeof(mailbox));",
          "96:   return mutt_bcache_open(&idata->conn->account, mailbox);",
          "106: static FILE *msg_cache_get(struct ImapData *idata, struct Email *e)",
          "108:   if (!idata || !e)",
          "111:   idata->bcache = msg_cache_open(idata);",
          "113:   snprintf(id, sizeof(id), \"%u-%u\", idata->uid_validity, HEADER_DATA(e)->uid);",
          "114:   return mutt_bcache_get(idata->bcache, id);",
          "124: static FILE *msg_cache_put(struct ImapData *idata, struct Email *e)",
          "126:   if (!idata || !e)",
          "129:   idata->bcache = msg_cache_open(idata);",
          "131:   snprintf(id, sizeof(id), \"%u-%u\", idata->uid_validity, HEADER_DATA(e)->uid);",
          "132:   return mutt_bcache_put(idata->bcache, id);",
          "142: static int msg_cache_commit(struct ImapData *idata, struct Email *e)",
          "144:   if (!idata || !e)",
          "147:   idata->bcache = msg_cache_open(idata);",
          "149:   snprintf(id, sizeof(id), \"%u-%u\", idata->uid_validity, HEADER_DATA(e)->uid);",
          "151:   return mutt_bcache_commit(idata->bcache, id);",
          "",
          "[Added Lines]",
          "74: static struct ImapEmailData *new_header_data(void)",
          "76:   return mutt_mem_calloc(1, sizeof(struct ImapEmailData));",
          "86: static struct BodyCache *msg_cache_open(struct ImapMboxData *mdata)",
          "90:   if (mdata->bcache)",
          "91:     return mdata->bcache;",
          "93:   imap_cachepath(mdata, mdata->mbox_name, mailbox, sizeof(mailbox));",
          "95:   return mutt_bcache_open(&mdata->conn->account, mailbox);",
          "105: static FILE *msg_cache_get(struct ImapMboxData *mdata, struct Email *e)",
          "107:   if (!mdata || !e)",
          "110:   mdata->bcache = msg_cache_open(mdata);",
          "112:   snprintf(id, sizeof(id), \"%u-%u\", mdata->uid_validity, HEADER_DATA(e)->uid);",
          "113:   return mutt_bcache_get(mdata->bcache, id);",
          "123: static FILE *msg_cache_put(struct ImapMboxData *mdata, struct Email *e)",
          "125:   if (!mdata || !e)",
          "128:   mdata->bcache = msg_cache_open(mdata);",
          "130:   snprintf(id, sizeof(id), \"%u-%u\", mdata->uid_validity, HEADER_DATA(e)->uid);",
          "131:   return mutt_bcache_put(mdata->bcache, id);",
          "141: static int msg_cache_commit(struct ImapMboxData *mdata, struct Email *e)",
          "143:   if (!mdata || !e)",
          "146:   mdata->bcache = msg_cache_open(mdata);",
          "148:   snprintf(id, sizeof(id), \"%u-%u\", mdata->uid_validity, HEADER_DATA(e)->uid);",
          "150:   return mutt_bcache_commit(mdata->bcache, id);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "158: static int msg_cache_clean_cb(const char *id, struct BodyCache *bcache, void *data)",
          "159: {",
          "160:   unsigned int uv, uid;",
          "163:   if (sscanf(id, \"%u-%u\", &uv, &uid) != 2)",
          "164:     return 0;",
          "168:     mutt_bcache_del(bcache, id);",
          "170:   return 0;",
          "",
          "[Removed Lines]",
          "161:   struct ImapData *idata = data;",
          "167:   if (uv != idata->uid_validity || !mutt_hash_int_find(idata->uid_hash, uid))",
          "",
          "[Added Lines]",
          "160:   struct ImapMboxData *mdata = data;",
          "166:   if (uv != mdata->uid_validity || !mutt_hash_int_find(mdata->uid_hash, uid))",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "180: static char *msg_parse_flags(struct ImapHeader *h, char *s)",
          "181: {",
          "185:   if (mutt_str_strncasecmp(\"FLAGS\", s, 5) != 0)",
          "",
          "[Removed Lines]",
          "182:   struct ImapHeaderData *hd = h->data;",
          "",
          "[Added Lines]",
          "181:   struct ImapEmailData *edata = h->data;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "196:   }",
          "197:   s++;",
          "209:   while (*s && *s != ')')",
          "",
          "[Removed Lines]",
          "199:   FREE(&hd->flags_system);",
          "200:   FREE(&hd->flags_remote);",
          "202:   hd->deleted = false;",
          "203:   hd->flagged = false;",
          "204:   hd->replied = false;",
          "205:   hd->read = false;",
          "206:   hd->old = false;",
          "",
          "[Added Lines]",
          "198:   FREE(&edata->flags_system);",
          "199:   FREE(&edata->flags_remote);",
          "201:   edata->deleted = false;",
          "202:   edata->flagged = false;",
          "203:   edata->replied = false;",
          "204:   edata->read = false;",
          "205:   edata->old = false;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "211:     if (mutt_str_strncasecmp(\"\\\\deleted\", s, 8) == 0)",
          "212:     {",
          "213:       s += 8;",
          "215:     }",
          "216:     else if (mutt_str_strncasecmp(\"\\\\flagged\", s, 8) == 0)",
          "217:     {",
          "218:       s += 8;",
          "220:     }",
          "221:     else if (mutt_str_strncasecmp(\"\\\\answered\", s, 9) == 0)",
          "222:     {",
          "223:       s += 9;",
          "225:     }",
          "226:     else if (mutt_str_strncasecmp(\"\\\\seen\", s, 5) == 0)",
          "227:     {",
          "228:       s += 5;",
          "230:     }",
          "231:     else if (mutt_str_strncasecmp(\"\\\\recent\", s, 7) == 0)",
          "232:       s += 7;",
          "233:     else if (mutt_str_strncasecmp(\"old\", s, 3) == 0)",
          "234:     {",
          "235:       s += 3;",
          "237:     }",
          "238:     else",
          "239:     {",
          "",
          "[Removed Lines]",
          "214:       hd->deleted = true;",
          "219:       hd->flagged = true;",
          "224:       hd->replied = true;",
          "229:       hd->read = true;",
          "236:       hd->old = MarkOld ? true : false;",
          "",
          "[Added Lines]",
          "213:       edata->deleted = true;",
          "218:       edata->flagged = true;",
          "223:       edata->replied = true;",
          "228:       edata->read = true;",
          "235:       edata->old = MarkOld ? true : false;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "251:       if (is_system_keyword)",
          "254:       else",
          "258:     }",
          "",
          "[Removed Lines]",
          "252:         mutt_str_append_item(&hd->flags_system, flag_word, ' ');",
          "255:         mutt_str_append_item(&hd->flags_remote, flag_word, ' ');",
          "",
          "[Added Lines]",
          "251:         mutt_str_append_item(&edata->flags_system, flag_word, ' ');",
          "254:         mutt_str_append_item(&edata->flags_remote, flag_word, ' ');",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "395:   int parse_rc;",
          "399:   if (buf[0] != '*')",
          "400:     return rc;",
          "",
          "[Removed Lines]",
          "397:   struct ImapData *idata = mailbox->data;",
          "",
          "[Added Lines]",
          "396:   struct ImapMboxData *mdata = mailbox->data;",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "426:   if (imap_get_literal_count(buf, &bytes) == 0)",
          "427:   {",
          "435:       return rc;",
          "438:       return rc;",
          "439:   }",
          "",
          "[Removed Lines]",
          "428:     imap_read_literal(fp, idata, bytes, NULL);",
          "434:     if (imap_cmd_step(idata) != IMAP_CMD_CONTINUE)",
          "437:     if (msg_parse_fetch(h, idata->buf) == -1)",
          "",
          "[Added Lines]",
          "427:     imap_read_literal(fp, mdata, bytes, NULL);",
          "433:     if (imap_cmd_step(mdata) != IMAP_CMD_CONTINUE)",
          "436:     if (msg_parse_fetch(h, mdata->buf) == -1)",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "472: {",
          "473:   bool abort = false;",
          "",
          "[Removed Lines]",
          "471: static bool query_abort_header_download(struct ImapData *idata)",
          "",
          "[Added Lines]",
          "470: static bool query_abort_header_download(struct ImapMboxData *mdata)",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "477:   if (mutt_yesorno(_(\"Abort download and close mailbox?\"), MUTT_YES) == MUTT_YES)",
          "478:   {",
          "479:     abort = true;",
          "481:   }",
          "482:   SigInt = 0;",
          "",
          "[Removed Lines]",
          "480:     imap_close_connection(idata);",
          "",
          "[Added Lines]",
          "479:     imap_close_connection(mdata);",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "495: {",
          "496:   size_t new_size;",
          "499:     return;",
          "",
          "[Removed Lines]",
          "494: static void alloc_msn_index(struct ImapData *idata, size_t msn_count)",
          "498:   if (msn_count <= idata->msn_index_size)",
          "",
          "[Added Lines]",
          "493: static void alloc_msn_index(struct ImapMboxData *mdata, size_t msn_count)",
          "497:   if (msn_count <= mdata->msn_index_size)",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "511:   new_size = msn_count + 25;",
          "515:   else",
          "516:   {",
          "520:   }",
          "523: }",
          "534: {",
          "537: }",
          "",
          "[Removed Lines]",
          "513:   if (!idata->msn_index)",
          "514:     idata->msn_index = mutt_mem_calloc(new_size, sizeof(struct Email *));",
          "517:     mutt_mem_realloc(&idata->msn_index, sizeof(struct Email *) * new_size);",
          "518:     memset(idata->msn_index + idata->msn_index_size, 0,",
          "519:            sizeof(struct Email *) * (new_size - idata->msn_index_size));",
          "522:   idata->msn_index_size = new_size;",
          "533: static void imap_alloc_uid_hash(struct ImapData *idata, unsigned int msn_count)",
          "535:   if (!idata->uid_hash)",
          "536:     idata->uid_hash = mutt_hash_int_create(MAX(6 * msn_count / 5, 30), 0);",
          "",
          "[Added Lines]",
          "512:   if (!mdata->msn_index)",
          "513:     mdata->msn_index = mutt_mem_calloc(new_size, sizeof(struct Email *));",
          "516:     mutt_mem_realloc(&mdata->msn_index, sizeof(struct Email *) * new_size);",
          "517:     memset(mdata->msn_index + mdata->msn_index_size, 0,",
          "518:            sizeof(struct Email *) * (new_size - mdata->msn_index_size));",
          "521:   mdata->msn_index_size = new_size;",
          "532: static void imap_alloc_uid_hash(struct ImapMboxData *mdata, unsigned int msn_count)",
          "534:   if (!mdata->uid_hash)",
          "535:     mdata->uid_hash = mutt_hash_int_create(MAX(6 * msn_count / 5, 30), 0);",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "554:                                   unsigned int msn_begin, unsigned int msn_end)",
          "555: {",
          "556:   int chunks = 0;",
          "",
          "[Removed Lines]",
          "553: static void imap_fetch_msn_seqset(struct Buffer *b, struct ImapData *idata,",
          "",
          "[Added Lines]",
          "552: static void imap_fetch_msn_seqset(struct Buffer *b, struct ImapMboxData *mdata,",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "561:   for (unsigned int msn = msn_begin; msn <= (msn_end + 1); msn++)",
          "562:   {",
          "564:     {",
          "565:       switch (state)",
          "566:       {",
          "",
          "[Removed Lines]",
          "563:     if ((msn <= msn_end) && !idata->msn_index[msn - 1])",
          "",
          "[Added Lines]",
          "562:     if ((msn <= msn_end) && !mdata->msn_index[msn - 1])",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "659:                                           unsigned int msn_end, unsigned int uidnext,",
          "660:                                           bool store_flag_updates, bool eval_condstore)",
          "661: {",
          "662:   struct Progress progress;",
          "663:   char buf[LONG_STRING];",
          "666:   int idx = ctx->mailbox->msg_count;",
          "",
          "[Removed Lines]",
          "658: static int read_headers_normal_eval_cache(struct ImapData *idata,",
          "665:   struct Context *ctx = idata->ctx;",
          "",
          "[Added Lines]",
          "657: static int read_headers_normal_eval_cache(struct ImapMboxData *mdata,",
          "664:   struct Context *ctx = mdata->ctx;",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "675:   snprintf(buf, sizeof(buf), \"UID FETCH 1:%u (UID%s)\", uidnext - 1,",
          "676:            eval_condstore ? \"\" : \" FLAGS\");",
          "680:   int rc = IMAP_CMD_CONTINUE;",
          "681:   int mfhrc = 0;",
          "682:   struct ImapHeader h;",
          "683:   for (int msgno = 1; rc == IMAP_CMD_CONTINUE; msgno++)",
          "684:   {",
          "686:       return -1;",
          "688:     mutt_progress_update(&progress, msgno, -1);",
          "690:     memset(&h, 0, sizeof(h));",
          "692:     do",
          "693:     {",
          "695:       if (rc != IMAP_CMD_CONTINUE)",
          "696:         break;",
          "699:       if (mfhrc < 0)",
          "700:         continue;",
          "",
          "[Removed Lines]",
          "678:   imap_cmd_start(idata, buf);",
          "685:     if (SigInt && query_abort_header_download(idata))",
          "691:     h.data = mutt_mem_calloc(1, sizeof(struct ImapHeaderData));",
          "694:       rc = imap_cmd_step(idata);",
          "698:       mfhrc = msg_fetch_header(ctx->mailbox, &h, idata->buf, NULL);",
          "",
          "[Added Lines]",
          "677:   imap_cmd_start(mdata, buf);",
          "684:     if (SigInt && query_abort_header_download(mdata))",
          "690:     h.data = mutt_mem_calloc(1, sizeof(struct ImapEmailData));",
          "693:       rc = imap_cmd_step(mdata);",
          "697:       mfhrc = msg_fetch_header(ctx->mailbox, &h, mdata->buf, NULL);",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "713:         continue;",
          "714:       }",
          "717:       {",
          "718:         mutt_debug(2, \"skipping hcache FETCH for duplicate message %d\\n\", h.data->msn);",
          "719:         continue;",
          "720:       }",
          "723:       if (ctx->mailbox->hdrs[idx])",
          "724:       {",
          "729:         ctx->mailbox->hdrs[idx]->index = idx;",
          "",
          "[Removed Lines]",
          "716:       if (idata->msn_index[h.data->msn - 1])",
          "722:       ctx->mailbox->hdrs[idx] = imap_hcache_get(idata, h.data->uid);",
          "725:         idata->max_msn = MAX(idata->max_msn, h.data->msn);",
          "726:         idata->msn_index[h.data->msn - 1] = ctx->mailbox->hdrs[idx];",
          "727:         mutt_hash_int_insert(idata->uid_hash, h.data->uid, ctx->mailbox->hdrs[idx]);",
          "",
          "[Added Lines]",
          "715:       if (mdata->msn_index[h.data->msn - 1])",
          "721:       ctx->mailbox->hdrs[idx] = imap_hcache_get(mdata, h.data->uid);",
          "724:         mdata->max_msn = MAX(mdata->max_msn, h.data->msn);",
          "725:         mdata->msn_index[h.data->msn - 1] = ctx->mailbox->hdrs[idx];",
          "726:         mutt_hash_int_insert(mdata->uid_hash, h.data->uid, ctx->mailbox->hdrs[idx]);",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "762:         if (!eval_condstore && store_flag_updates)",
          "765:         h.data = NULL;",
          "766:         idx++;",
          "767:       }",
          "768:     } while (mfhrc == -1);",
          "772:     if ((mfhrc < -1) || ((rc != IMAP_CMD_CONTINUE) && (rc != IMAP_CMD_OK)))",
          "773:       return -1;",
          "",
          "[Removed Lines]",
          "763:           imap_hcache_put(idata, ctx->mailbox->hdrs[idx]);",
          "770:     imap_free_header_data(&h.data);",
          "",
          "[Added Lines]",
          "762:           imap_hcache_put(mdata, ctx->mailbox->hdrs[idx]);",
          "769:     imap_free_email_data(&h.data);",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "792: {",
          "793:   int rc;",
          "794:   unsigned int uid = 0;",
          "796:   mutt_debug(2, \"Reading uid seqset from header cache\\n\");",
          "798:   unsigned int msn = 1;",
          "800:   struct SeqsetIterator *iter = mutt_seqset_iterator_new(uid_seqset);",
          "",
          "[Removed Lines]",
          "791: static int read_headers_qresync_eval_cache(struct ImapData *idata, char *uid_seqset)",
          "797:   struct Context *ctx = idata->ctx;",
          "",
          "[Added Lines]",
          "790: static int read_headers_qresync_eval_cache(struct ImapMboxData *mdata, char *uid_seqset)",
          "796:   struct Context *ctx = mdata->ctx;",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "805:   {",
          "812:     if (e)",
          "813:     {",
          "817:       if (ctx->mailbox->msg_count >= ctx->mailbox->hdrmax)",
          "818:         mx_alloc_memory(ctx->mailbox);",
          "823:       e->index = ctx->mailbox->msg_count;",
          "824:       e->active = true;",
          "825:       e->changed = false;",
          "836:       ctx->mailbox->size += e->content->length;",
          "837:       ctx->mailbox->hdrs[ctx->mailbox->msg_count++] = e;",
          "",
          "[Removed Lines]",
          "808:     if (msn > idata->msn_index_size)",
          "809:       alloc_msn_index(idata, msn);",
          "811:     struct Email *e = imap_hcache_get(idata, uid);",
          "814:       idata->max_msn = MAX(idata->max_msn, msn);",
          "815:       idata->msn_index[msn - 1] = e;",
          "820:       struct ImapHeaderData *ihd = mutt_mem_calloc(1, sizeof(struct ImapHeaderData));",
          "821:       e->data = ihd;",
          "826:       ihd->read = e->read;",
          "827:       ihd->old = e->old;",
          "828:       ihd->deleted = e->deleted;",
          "829:       ihd->flagged = e->flagged;",
          "830:       ihd->replied = e->replied;",
          "832:       ihd->msn = msn;",
          "833:       ihd->uid = uid;",
          "834:       mutt_hash_int_insert(idata->uid_hash, uid, e);",
          "",
          "[Added Lines]",
          "807:     if (msn > mdata->msn_index_size)",
          "808:       alloc_msn_index(mdata, msn);",
          "810:     struct Email *e = imap_hcache_get(mdata, uid);",
          "813:       mdata->max_msn = MAX(mdata->max_msn, msn);",
          "814:       mdata->msn_index[msn - 1] = e;",
          "819:       struct ImapEmailData *edata = mutt_mem_calloc(1, sizeof(struct ImapEmailData));",
          "820:       e->data = edata;",
          "825:       edata->read = e->read;",
          "826:       edata->old = e->old;",
          "827:       edata->deleted = e->deleted;",
          "828:       edata->flagged = e->flagged;",
          "829:       edata->replied = e->replied;",
          "831:       edata->msn = msn;",
          "832:       edata->uid = uid;",
          "833:       mutt_hash_int_insert(mdata->uid_hash, uid, e);",
          "",
          "---------------",
          "--- Hunk 21 ---",
          "[Context before]",
          "861:                                                   unsigned int msn_end, unsigned int uidnext,",
          "862:                                                   unsigned long long hc_modseq, bool eval_qresync)",
          "863: {",
          "",
          "[Removed Lines]",
          "860: static int read_headers_condstore_qresync_updates(struct ImapData *idata,",
          "",
          "[Added Lines]",
          "859: static int read_headers_condstore_qresync_updates(struct ImapMboxData *mdata,",
          "",
          "---------------",
          "--- Hunk 22 ---",
          "[Context before]",
          "865:   char buf[LONG_STRING];",
          "866:   unsigned int header_msn = 0;",
          "871:   mutt_progress_init(&progress, _(\"Fetching flag updates...\"),",
          "",
          "[Removed Lines]",
          "868:   struct Context *ctx = idata->ctx;",
          "",
          "[Added Lines]",
          "867:   struct Context *ctx = mdata->ctx;",
          "",
          "---------------",
          "--- Hunk 23 ---",
          "[Context before]",
          "874:   snprintf(buf, sizeof(buf), \"UID FETCH 1:%u (FLAGS) (CHANGEDSINCE %llu%s)\",",
          "875:            uidnext - 1, hc_modseq, eval_qresync ? \" VANISHED\" : \"\");",
          "879:   int rc = IMAP_CMD_CONTINUE;",
          "880:   for (int msgno = 1; rc == IMAP_CMD_CONTINUE; msgno++)",
          "881:   {",
          "883:       return -1;",
          "885:     mutt_progress_update(&progress, msgno, -1);",
          "889:     if (rc != IMAP_CMD_CONTINUE)",
          "890:       break;",
          "895:     if (fetch_buf[0] != '*')",
          "896:       continue;",
          "",
          "[Removed Lines]",
          "877:   imap_cmd_start(idata, buf);",
          "882:     if (SigInt && query_abort_header_download(idata))",
          "888:     rc = imap_cmd_step(idata);",
          "894:     char *fetch_buf = idata->buf;",
          "",
          "[Added Lines]",
          "876:   imap_cmd_start(mdata, buf);",
          "881:     if (SigInt && query_abort_header_download(mdata))",
          "887:     rc = imap_cmd_step(mdata);",
          "893:     char *fetch_buf = mdata->buf;",
          "",
          "---------------",
          "--- Hunk 24 ---",
          "[Context before]",
          "899:     if (!isdigit((unsigned char) *fetch_buf) || (mutt_str_atoui(fetch_buf, &header_msn) < 0))",
          "900:       continue;",
          "903:     {",
          "904:       mutt_debug(1, \"skipping CONDSTORE flag update for unknown message number %u\\n\", header_msn);",
          "905:       continue;",
          "906:     }",
          "909:   }",
          "914:   ctx->mailbox->changed = false;",
          "918:   {",
          "923:   }",
          "925:   return 0;",
          "",
          "[Removed Lines]",
          "902:     if ((header_msn < 1) || (header_msn > msn_end) || !idata->msn_index[header_msn - 1])",
          "908:     imap_hcache_put(idata, idata->msn_index[header_msn - 1]);",
          "913:   idata->check_status &= ~IMAP_FLAGS_PENDING;",
          "917:   if (idata->reopen & IMAP_EXPUNGE_PENDING)",
          "919:     imap_hcache_close(idata);",
          "920:     imap_expunge_mailbox(idata);",
          "921:     idata->hcache = imap_hcache_open(idata, NULL);",
          "922:     idata->reopen &= ~IMAP_EXPUNGE_PENDING;",
          "",
          "[Added Lines]",
          "901:     if ((header_msn < 1) || (header_msn > msn_end) || !mdata->msn_index[header_msn - 1])",
          "907:     imap_hcache_put(mdata, mdata->msn_index[header_msn - 1]);",
          "912:   mdata->check_status &= ~IMAP_FLAGS_PENDING;",
          "916:   if (mdata->reopen & IMAP_EXPUNGE_PENDING)",
          "918:     imap_hcache_close(mdata);",
          "919:     imap_expunge_mailbox(mdata);",
          "920:     mdata->hcache = imap_hcache_open(mdata, NULL);",
          "921:     mdata->reopen &= ~IMAP_EXPUNGE_PENDING;",
          "",
          "---------------",
          "--- Hunk 25 ---",
          "[Context before]",
          "941:                                   unsigned int msn_end, bool evalhc,",
          "942:                                   unsigned int *maxuid, bool initial_download)",
          "943: {",
          "",
          "[Removed Lines]",
          "940: static int read_headers_fetch_new(struct ImapData *idata, unsigned int msn_begin,",
          "",
          "[Added Lines]",
          "939: static int read_headers_fetch_new(struct ImapMboxData *mdata, unsigned int msn_begin,",
          "",
          "---------------",
          "--- Hunk 26 ---",
          "[Context before]",
          "953:       \"CONTENT-DESCRIPTION IN-REPLY-TO REPLY-TO LINES LIST-POST X-LABEL \"",
          "954:       \"X-ORIGINAL-TO\";",
          "957:   int idx = ctx->mailbox->msg_count;",
          "960:   {",
          "961:     safe_asprintf(&hdrreq, \"BODY.PEEK[HEADER.FIELDS (%s%s%s)]\", want_headers,",
          "962:                   ImapHeaders ? \" \" : \"\", NONULL(ImapHeaders));",
          "963:   }",
          "965:   {",
          "966:     safe_asprintf(&hdrreq, \"RFC822.HEADER.LINES (%s%s%s)\", want_headers,",
          "967:                   ImapHeaders ? \" \" : \"\", NONULL(ImapHeaders));",
          "",
          "[Removed Lines]",
          "956:   struct Context *ctx = idata->ctx;",
          "959:   if (mutt_bit_isset(idata->capabilities, IMAP4REV1))",
          "964:   else if (mutt_bit_isset(idata->capabilities, IMAP4))",
          "",
          "[Added Lines]",
          "955:   struct Context *ctx = mdata->ctx;",
          "958:   if (mutt_bit_isset(mdata->capabilities, IMAP4REV1))",
          "963:   else if (mutt_bit_isset(mdata->capabilities, IMAP4))",
          "",
          "---------------",
          "--- Hunk 27 ---",
          "[Context before]",
          "993:     {",
          "995:       evalhc = false;",
          "997:     }",
          "998:     else",
          "999:       mutt_buffer_printf(b, \"%u:%u\", msn_begin, msn_end);",
          "",
          "[Removed Lines]",
          "996:       imap_fetch_msn_seqset(b, idata, msn_begin, msn_end);",
          "",
          "[Added Lines]",
          "995:       imap_fetch_msn_seqset(b, mdata, msn_begin, msn_end);",
          "",
          "---------------",
          "--- Hunk 28 ---",
          "[Context before]",
          "1001:     fetch_msn_end = msn_end;",
          "1002:     char *cmd = NULL;",
          "1003:     safe_asprintf(&cmd, \"FETCH %s (UID FLAGS INTERNALDATE RFC822.SIZE %s)\", b->data, hdrreq);",
          "1005:     FREE(&cmd);",
          "1006:     mutt_buffer_free(&b);",
          "1008:     rc = IMAP_CMD_CONTINUE;",
          "1009:     for (int msgno = msn_begin; rc == IMAP_CMD_CONTINUE; msgno++)",
          "1010:     {",
          "1012:         goto bail;",
          "1014:       mutt_progress_update(&progress, msgno, -1);",
          "",
          "[Removed Lines]",
          "1004:     imap_cmd_start(idata, cmd);",
          "1011:       if (initial_download && SigInt && query_abort_header_download(idata))",
          "",
          "[Added Lines]",
          "1003:     imap_cmd_start(mdata, cmd);",
          "1010:       if (initial_download && SigInt && query_abort_header_download(mdata))",
          "",
          "---------------",
          "--- Hunk 29 ---",
          "[Context before]",
          "1024:       do",
          "1025:       {",
          "1027:         if (rc != IMAP_CMD_CONTINUE)",
          "1028:           break;",
          "1031:         if (mfhrc < 0)",
          "1032:           continue;",
          "",
          "[Removed Lines]",
          "1026:         rc = imap_cmd_step(idata);",
          "1030:         mfhrc = msg_fetch_header(ctx->mailbox, &h, idata->buf, fp);",
          "",
          "[Added Lines]",
          "1025:         rc = imap_cmd_step(mdata);",
          "1029:         mfhrc = msg_fetch_header(ctx->mailbox, &h, mdata->buf, fp);",
          "",
          "---------------",
          "--- Hunk 30 ---",
          "[Context before]",
          "1048:         }",
          "1052:         {",
          "1053:           mutt_debug(2, \"skipping FETCH response for duplicate message %d\\n\",",
          "1054:                      h.data->msn);",
          "",
          "[Removed Lines]",
          "1051:         if (idata->msn_index[h.data->msn - 1])",
          "",
          "[Added Lines]",
          "1050:         if (mdata->msn_index[h.data->msn - 1])",
          "",
          "---------------",
          "--- Hunk 31 ---",
          "[Context before]",
          "1058:         ctx->mailbox->hdrs[idx] = mutt_email_new();",
          "1064:         ctx->mailbox->hdrs[idx]->index = idx;",
          "",
          "[Removed Lines]",
          "1060:         idata->max_msn = MAX(idata->max_msn, h.data->msn);",
          "1061:         idata->msn_index[h.data->msn - 1] = ctx->mailbox->hdrs[idx];",
          "1062:         mutt_hash_int_insert(idata->uid_hash, h.data->uid, ctx->mailbox->hdrs[idx]);",
          "",
          "[Added Lines]",
          "1059:         mdata->max_msn = MAX(mdata->max_msn, h.data->msn);",
          "1060:         mdata->msn_index[h.data->msn - 1] = ctx->mailbox->hdrs[idx];",
          "1061:         mutt_hash_int_insert(mdata->uid_hash, h.data->uid, ctx->mailbox->hdrs[idx]);",
          "",
          "---------------",
          "--- Hunk 32 ---",
          "[Context before]",
          "1090:         ctx->mailbox->size += h.content_length;",
          "1092: #ifdef USE_HCACHE",
          "1096:         ctx->mailbox->msg_count++;",
          "",
          "[Removed Lines]",
          "1093:         imap_hcache_put(idata, ctx->mailbox->hdrs[idx]);",
          "",
          "[Added Lines]",
          "1092:         imap_hcache_put(mdata, ctx->mailbox->hdrs[idx]);",
          "",
          "---------------",
          "--- Hunk 33 ---",
          "[Context before]",
          "1099:         idx++;",
          "1100:       } while (mfhrc == -1);",
          "1104:       if ((mfhrc < -1) || ((rc != IMAP_CMD_CONTINUE) && (rc != IMAP_CMD_OK)))",
          "1105:         goto bail;",
          "",
          "[Removed Lines]",
          "1102:       imap_free_header_data(&h.data);",
          "",
          "[Added Lines]",
          "1101:       imap_free_email_data(&h.data);",
          "",
          "---------------",
          "--- Hunk 34 ---",
          "[Context before]",
          "1115:     {",
          "1120:       while (msn_end > ctx->mailbox->hdrmax)",
          "1121:         mx_alloc_memory(ctx->mailbox);",
          "1125:     }",
          "1126:   }",
          "",
          "[Removed Lines]",
          "1114:     if (idata->reopen & IMAP_NEWMAIL_PENDING)",
          "1117:       fetch_msn_end = idata->max_msn;",
          "1118:       msn_begin = idata->max_msn + 1;",
          "1119:       msn_end = idata->new_mail_count;",
          "1122:       alloc_msn_index(idata, msn_end);",
          "1123:       idata->reopen &= ~IMAP_NEWMAIL_PENDING;",
          "1124:       idata->new_mail_count = 0;",
          "",
          "[Added Lines]",
          "1113:     if (mdata->reopen & IMAP_NEWMAIL_PENDING)",
          "1116:       fetch_msn_end = mdata->max_msn;",
          "1117:       msn_begin = mdata->max_msn + 1;",
          "1118:       msn_end = mdata->new_mail_count;",
          "1121:       alloc_msn_index(mdata, msn_end);",
          "1122:       mdata->reopen &= ~IMAP_NEWMAIL_PENDING;",
          "1123:       mdata->new_mail_count = 0;",
          "",
          "---------------",
          "--- Hunk 35 ---",
          "[Context before]",
          "1151:                       unsigned int msn_end, bool initial_download)",
          "1152: {",
          "1153:   struct ImapStatus *status = NULL;",
          "",
          "[Removed Lines]",
          "1150: int imap_read_headers(struct ImapData *idata, unsigned int msn_begin,",
          "",
          "[Added Lines]",
          "1149: int imap_read_headers(struct ImapMboxData *mdata, unsigned int msn_begin,",
          "",
          "---------------",
          "--- Hunk 36 ---",
          "[Context before]",
          "1169:   char *uid_seqset = NULL;",
          "1175:   while (msn_end > ctx->mailbox->hdrmax)",
          "1176:     mx_alloc_memory(ctx->mailbox);",
          "1180:   oldmsgcount = ctx->mailbox->msg_count;",
          "1184: #ifdef USE_HCACHE",
          "1188:   {",
          "1191:     if (puidnext)",
          "1192:     {",
          "1193:       uidnext = *(unsigned int *) puidnext;",
          "1195:     }",
          "1198:     {",
          "1200:         has_condstore = true;",
          "1207:         has_qresync = true;",
          "1208:     }",
          "1211:     {",
          "1212:       evalhc = true;",
          "1214:       if (pmodseq)",
          "1215:       {",
          "1216:         hc_modseq = *pmodseq;",
          "1218:       }",
          "1219:       if (hc_modseq)",
          "1220:       {",
          "1221:         if (has_qresync)",
          "1222:         {",
          "1224:           if (uid_seqset)",
          "1225:             eval_qresync = true;",
          "1226:         }",
          "",
          "[Removed Lines]",
          "1172:   struct Context *ctx = idata->ctx;",
          "1177:   alloc_msn_index(idata, msn_end);",
          "1178:   imap_alloc_uid_hash(idata, msn_end);",
          "1181:   idata->reopen &= ~(IMAP_REOPEN_ALLOW | IMAP_NEWMAIL_PENDING);",
          "1182:   idata->new_mail_count = 0;",
          "1185:   idata->hcache = imap_hcache_open(idata, NULL);",
          "1187:   if (idata->hcache && initial_download)",
          "1189:     uid_validity = mutt_hcache_fetch_raw(idata->hcache, \"/UIDVALIDITY\", 12);",
          "1190:     puidnext = mutt_hcache_fetch_raw(idata->hcache, \"/UIDNEXT\", 8);",
          "1194:       mutt_hcache_free(idata->hcache, &puidnext);",
          "1197:     if (idata->modseq)",
          "1199:       if (mutt_bit_isset(idata->capabilities, CONDSTORE) && ImapCondStore)",
          "1206:       if (idata->qresync)",
          "1210:     if (uid_validity && uidnext && (*(unsigned int *) uid_validity == idata->uid_validity))",
          "1213:       pmodseq = mutt_hcache_fetch_raw(idata->hcache, \"/MODSEQ\", 7);",
          "1217:         mutt_hcache_free(idata->hcache, (void **) &pmodseq);",
          "1223:           uid_seqset = imap_hcache_get_uid_seqset(idata);",
          "",
          "[Added Lines]",
          "1171:   struct Context *ctx = mdata->ctx;",
          "1176:   alloc_msn_index(mdata, msn_end);",
          "1177:   imap_alloc_uid_hash(mdata, msn_end);",
          "1180:   mdata->reopen &= ~(IMAP_REOPEN_ALLOW | IMAP_NEWMAIL_PENDING);",
          "1181:   mdata->new_mail_count = 0;",
          "1184:   mdata->hcache = imap_hcache_open(mdata, NULL);",
          "1186:   if (mdata->hcache && initial_download)",
          "1188:     uid_validity = mutt_hcache_fetch_raw(mdata->hcache, \"/UIDVALIDITY\", 12);",
          "1189:     puidnext = mutt_hcache_fetch_raw(mdata->hcache, \"/UIDNEXT\", 8);",
          "1193:       mutt_hcache_free(mdata->hcache, &puidnext);",
          "1196:     if (mdata->modseq)",
          "1198:       if (mutt_bit_isset(mdata->capabilities, CONDSTORE) && ImapCondStore)",
          "1205:       if (mdata->qresync)",
          "1209:     if (uid_validity && uidnext && (*(unsigned int *) uid_validity == mdata->uid_validity))",
          "1212:       pmodseq = mutt_hcache_fetch_raw(mdata->hcache, \"/MODSEQ\", 7);",
          "1216:         mutt_hcache_free(mdata->hcache, (void **) &pmodseq);",
          "1222:           uid_seqset = imap_hcache_get_uid_seqset(mdata);",
          "",
          "---------------",
          "--- Hunk 37 ---",
          "[Context before]",
          "1229:           eval_condstore = true;",
          "1230:       }",
          "1231:     }",
          "1233:   }",
          "1234:   if (evalhc)",
          "1235:   {",
          "1236:     if (eval_qresync)",
          "1237:     {",
          "1239:         goto bail;",
          "1240:     }",
          "1241:     else",
          "1242:     {",
          "1244:                                          eval_condstore) < 0)",
          "1245:         goto bail;",
          "1246:     }",
          "1249:     {",
          "1251:                                                  hc_modseq, eval_qresync) < 0)",
          "1252:       {",
          "1253:         goto bail;",
          "",
          "[Removed Lines]",
          "1232:     mutt_hcache_free(idata->hcache, &uid_validity);",
          "1238:       if (read_headers_qresync_eval_cache(idata, uid_seqset) < 0)",
          "1243:       if (read_headers_normal_eval_cache(idata, msn_end, uidnext, has_condstore || has_qresync,",
          "1248:     if ((eval_condstore || eval_qresync) && (hc_modseq != idata->modseq))",
          "1250:       if (read_headers_condstore_qresync_updates(idata, msn_end, uidnext,",
          "",
          "[Added Lines]",
          "1231:     mutt_hcache_free(mdata->hcache, &uid_validity);",
          "1237:       if (read_headers_qresync_eval_cache(mdata, uid_seqset) < 0)",
          "1242:       if (read_headers_normal_eval_cache(mdata, msn_end, uidnext, has_condstore || has_qresync,",
          "1247:     if ((eval_condstore || eval_qresync) && (hc_modseq != mdata->modseq))",
          "1249:       if (read_headers_condstore_qresync_updates(mdata, msn_end, uidnext,",
          "",
          "---------------",
          "--- Hunk 38 ---",
          "[Context before]",
          "1258:     while (msn_begin <= msn_end)",
          "1259:     {",
          "1261:         break;",
          "1262:       msn_begin++;",
          "1263:     }",
          "1264:   }",
          "1268:     goto bail;",
          "1271:       (status->uidnext < maxuid + 1))",
          "1272:   {",
          "1273:     status->uidnext = maxuid + 1;",
          "1274:   }",
          "1276: #ifdef USE_HCACHE",
          "1280:   {",
          "1283:   }",
          "1285:   {",
          "1288:   }",
          "",
          "[Removed Lines]",
          "1260:       if (!idata->msn_index[msn_begin - 1])",
          "1267:   if (read_headers_fetch_new(idata, msn_begin, msn_end, evalhc, &maxuid, initial_download) < 0)",
          "1270:   if (maxuid && (status = imap_mboxcache_get(idata, idata->mbox_name, 0)) &&",
          "1277:   mutt_hcache_store_raw(idata->hcache, \"/UIDVALIDITY\", 12, &idata->uid_validity,",
          "1278:                         sizeof(idata->uid_validity));",
          "1279:   if (maxuid && idata->uidnext < maxuid + 1)",
          "1281:     mutt_debug(2, \"Overriding UIDNEXT: %u -> %u\\n\", idata->uidnext, maxuid + 1);",
          "1282:     idata->uidnext = maxuid + 1;",
          "1284:   if (idata->uidnext > 1)",
          "1286:     mutt_hcache_store_raw(idata->hcache, \"/UIDNEXT\", 8, &idata->uidnext,",
          "1287:                           sizeof(idata->uidnext));",
          "",
          "[Added Lines]",
          "1259:       if (!mdata->msn_index[msn_begin - 1])",
          "1266:   if (read_headers_fetch_new(mdata, msn_begin, msn_end, evalhc, &maxuid, initial_download) < 0)",
          "1269:   if (maxuid && (status = imap_mboxcache_get(mdata, mdata->mbox_name, 0)) &&",
          "1276:   mutt_hcache_store_raw(mdata->hcache, \"/UIDVALIDITY\", 12, &mdata->uid_validity,",
          "1277:                         sizeof(mdata->uid_validity));",
          "1278:   if (maxuid && mdata->uidnext < maxuid + 1)",
          "1280:     mutt_debug(2, \"Overriding UIDNEXT: %u -> %u\\n\", mdata->uidnext, maxuid + 1);",
          "1281:     mdata->uidnext = maxuid + 1;",
          "1283:   if (mdata->uidnext > 1)",
          "1285:     mutt_hcache_store_raw(mdata->hcache, \"/UIDNEXT\", 8, &mdata->uidnext,",
          "1286:                           sizeof(mdata->uidnext));",
          "",
          "---------------",
          "--- Hunk 39 ---",
          "[Context before]",
          "1296:   {",
          "1297:     if (has_condstore || has_qresync)",
          "1298:     {",
          "1301:     }",
          "1302:     else",
          "1305:     if (has_qresync)",
          "1307:     else",
          "1309:   }",
          "",
          "[Removed Lines]",
          "1299:       mutt_hcache_store_raw(idata->hcache, \"/MODSEQ\", 7, &idata->modseq,",
          "1300:                             sizeof(idata->modseq));",
          "1303:       mutt_hcache_delete(idata->hcache, \"/MODSEQ\", 7);",
          "1306:       imap_hcache_store_uid_seqset(idata);",
          "1308:       imap_hcache_clear_uid_seqset(idata);",
          "",
          "[Added Lines]",
          "1298:       mutt_hcache_store_raw(mdata->hcache, \"/MODSEQ\", 7, &mdata->modseq,",
          "1299:                             sizeof(mdata->modseq));",
          "1302:       mutt_hcache_delete(mdata->hcache, \"/MODSEQ\", 7);",
          "1305:       imap_hcache_store_uid_seqset(mdata);",
          "1307:       imap_hcache_clear_uid_seqset(mdata);",
          "",
          "---------------",
          "--- Hunk 40 ---",
          "[Context before]",
          "1317:     mx_update_context(ctx, ctx->mailbox->msg_count - oldmsgcount);",
          "1318:   }",
          "1322:   retval = msn_end;",
          "1324: bail:",
          "1325: #ifdef USE_HCACHE",
          "1327:   FREE(&uid_seqset);",
          "",
          "[Removed Lines]",
          "1320:   idata->reopen |= IMAP_REOPEN_ALLOW;",
          "1326:   imap_hcache_close(idata);",
          "",
          "[Added Lines]",
          "1319:   mdata->reopen |= IMAP_REOPEN_ALLOW;",
          "1325:   imap_hcache_close(mdata);",
          "",
          "---------------",
          "--- Hunk 41 ---",
          "[Context before]",
          "1352:   struct ImapMbox mx;",
          "1353:   int rc;",
          "1357:   if (imap_parse_path(ctx->mailbox->path, &mx))",
          "1358:     return -1;",
          "1361:   if (!*mailbox)",
          "1362:     mutt_str_strfcpy(mailbox, \"INBOX\", sizeof(mailbox));",
          "",
          "[Removed Lines]",
          "1355:   struct ImapData *idata = ctx->mailbox->data;",
          "1360:   imap_fix_path(idata, mx.mbox, mailbox, sizeof(mailbox));",
          "",
          "[Added Lines]",
          "1354:   struct ImapMboxData *mdata = ctx->mailbox->data;",
          "1359:   imap_fix_path(mdata, mx.mbox, mailbox, sizeof(mailbox));",
          "",
          "---------------",
          "--- Hunk 42 ---",
          "[Context before]",
          "1386:   mutt_progress_init(&progressbar, _(\"Uploading message...\"),",
          "1387:                      MUTT_PROGRESS_SIZE, NetInc, len);",
          "1390:   mutt_date_make_imap(internaldate, sizeof(internaldate), msg->received);",
          "1392:   imap_flags[0] = 0;",
          "",
          "[Removed Lines]",
          "1389:   imap_munge_mbox_name(idata, mbox, sizeof(mbox), mailbox);",
          "",
          "[Added Lines]",
          "1388:   imap_munge_mbox_name(mdata, mbox, sizeof(mbox), mailbox);",
          "",
          "---------------",
          "--- Hunk 43 ---",
          "[Context before]",
          "1404:   snprintf(buf, sizeof(buf), \"APPEND %s (%s) \\\"%s\\\" {%lu}\", mbox,",
          "1405:            imap_flags + 1, internaldate, (unsigned long) len);",
          "1409:   do",
          "1411:   while (rc == IMAP_CMD_CONTINUE);",
          "1413:   if (rc != IMAP_CMD_RESPOND)",
          "1414:   {",
          "1418:     SKIPWS(pc);",
          "1419:     pc = imap_next_word(pc);",
          "1420:     mutt_error(\"%s\", pc);",
          "",
          "[Removed Lines]",
          "1407:   imap_cmd_start(idata, buf);",
          "1410:     rc = imap_cmd_step(idata);",
          "1415:     mutt_debug(1, \"#1 command failed: %s\\n\", idata->buf);",
          "1417:     char *pc = idata->buf + SEQLEN;",
          "",
          "[Added Lines]",
          "1406:   imap_cmd_start(mdata, buf);",
          "1409:     rc = imap_cmd_step(mdata);",
          "1414:     mutt_debug(1, \"#1 command failed: %s\\n\", mdata->buf);",
          "1416:     char *pc = mdata->buf + SEQLEN;",
          "",
          "---------------",
          "--- Hunk 44 ---",
          "[Context before]",
          "1432:     if (len > sizeof(buf) - 3)",
          "1433:     {",
          "1434:       sent += len;",
          "1436:       mutt_progress_update(&progressbar, sent, -1);",
          "1437:     }",
          "1438:   }",
          "1440:   if (len)",
          "1444:   mutt_file_fclose(&fp);",
          "1446:   do",
          "1448:   while (rc == IMAP_CMD_CONTINUE);",
          "1451:   {",
          "1454:     SKIPWS(pc);",
          "1455:     pc = imap_next_word(pc);",
          "1456:     mutt_error(\"%s\", pc);",
          "",
          "[Removed Lines]",
          "1435:       flush_buffer(buf, &len, idata->conn);",
          "1441:     flush_buffer(buf, &len, idata->conn);",
          "1443:   mutt_socket_send(idata->conn, \"\\r\\n\");",
          "1447:     rc = imap_cmd_step(idata);",
          "1450:   if (!imap_code(idata->buf))",
          "1452:     mutt_debug(1, \"#2 command failed: %s\\n\", idata->buf);",
          "1453:     char *pc = idata->buf + SEQLEN;",
          "",
          "[Added Lines]",
          "1434:       flush_buffer(buf, &len, mdata->conn);",
          "1440:     flush_buffer(buf, &len, mdata->conn);",
          "1442:   mutt_socket_send(mdata->conn, \"\\r\\n\");",
          "1446:     rc = imap_cmd_step(mdata);",
          "1449:   if (!imap_code(mdata->buf))",
          "1451:     mutt_debug(1, \"#2 command failed: %s\\n\", mdata->buf);",
          "1452:     char *pc = mdata->buf + SEQLEN;",
          "",
          "---------------",
          "--- Hunk 45 ---",
          "[Context before]",
          "1486:   int err_continue = MUTT_NO;",
          "1487:   int triedcreate = 0;",
          "1491:   if (imap_parse_path(dest, &mx))",
          "1492:   {",
          "",
          "[Removed Lines]",
          "1489:   struct ImapData *idata = ctx->mailbox->data;",
          "",
          "[Added Lines]",
          "1488:   struct ImapMboxData *mdata = ctx->mailbox->data;",
          "",
          "---------------",
          "--- Hunk 46 ---",
          "[Context before]",
          "1495:   }",
          "1499:   {",
          "1500:     mutt_debug(3, \"%s not same server as %s\\n\", dest, ctx->mailbox->path);",
          "1501:     return 1;",
          "",
          "[Removed Lines]",
          "1498:   if (mutt_account_match(&(idata->conn->account), &(mx.account)) == 0)",
          "",
          "[Added Lines]",
          "1497:   if (mutt_account_match(&(mdata->conn->account), &(mx.account)) == 0)",
          "",
          "---------------",
          "--- Hunk 47 ---",
          "[Context before]",
          "1507:     return 1;",
          "1508:   }",
          "1511:   if (!*mbox)",
          "1512:     mutt_str_strfcpy(mbox, \"INBOX\", sizeof(mbox));",
          "1516:   do",
          "",
          "[Removed Lines]",
          "1510:   imap_fix_path(idata, mx.mbox, mbox, sizeof(mbox));",
          "1513:   imap_munge_mbox_name(idata, mmbox, sizeof(mmbox), mbox);",
          "",
          "[Added Lines]",
          "1509:   imap_fix_path(mdata, mx.mbox, mbox, sizeof(mbox));",
          "1512:   imap_munge_mbox_name(mdata, mmbox, sizeof(mmbox), mbox);",
          "",
          "---------------",
          "--- Hunk 48 ---",
          "[Context before]",
          "1538:         if (ctx->mailbox->hdrs[i]->active && ctx->mailbox->hdrs[i]->changed)",
          "1539:         {",
          "1541:                                           &sync_cmd, &err_continue);",
          "1542:           if (rc < 0)",
          "1543:           {",
          "",
          "[Removed Lines]",
          "1540:           rc = imap_sync_message_for_copy(idata, ctx->mailbox->hdrs[i],",
          "",
          "[Added Lines]",
          "1539:           rc = imap_sync_message_for_copy(mdata, ctx->mailbox->hdrs[i],",
          "",
          "---------------",
          "--- Hunk 49 ---",
          "[Context before]",
          "1547:         }",
          "1548:       }",
          "1551:       if (!rc)",
          "1552:       {",
          "1553:         mutt_debug(1, \"No messages tagged\\n\");",
          "",
          "[Removed Lines]",
          "1550:       rc = imap_exec_msgset(idata, \"UID COPY\", mmbox, MUTT_TAG, false, false);",
          "",
          "[Added Lines]",
          "1549:       rc = imap_exec_msgset(mdata, \"UID COPY\", mmbox, MUTT_TAG, false, false);",
          "",
          "---------------",
          "--- Hunk 50 ---",
          "[Context before]",
          "1573:       if (e->active && e->changed)",
          "1574:       {",
          "1576:         if (rc < 0)",
          "1577:         {",
          "1578:           mutt_debug(1, \"#2 could not sync\\n\");",
          "1579:           goto out;",
          "1580:         }",
          "1581:       }",
          "1583:       if (rc < 0)",
          "1584:       {",
          "1585:         mutt_debug(1, \"#2 could not queue copy\\n\");",
          "",
          "[Removed Lines]",
          "1575:         rc = imap_sync_message_for_copy(idata, e, &sync_cmd, &err_continue);",
          "1582:       rc = imap_exec(idata, cmd.data, IMAP_CMD_QUEUE);",
          "",
          "[Added Lines]",
          "1574:         rc = imap_sync_message_for_copy(mdata, e, &sync_cmd, &err_continue);",
          "1581:       rc = imap_exec(mdata, cmd.data, IMAP_CMD_QUEUE);",
          "",
          "---------------",
          "--- Hunk 51 ---",
          "[Context before]",
          "1588:     }",
          "1592:     if (rc == -2)",
          "1593:     {",
          "1594:       if (triedcreate)",
          "",
          "[Removed Lines]",
          "1591:     rc = imap_exec(idata, NULL, IMAP_CMD_FAIL_OK);",
          "",
          "[Added Lines]",
          "1590:     rc = imap_exec(mdata, NULL, IMAP_CMD_FAIL_OK);",
          "",
          "---------------",
          "--- Hunk 52 ---",
          "[Context before]",
          "1597:         break;",
          "1598:       }",
          "1601:         break;",
          "1602:       mutt_debug(3, \"server suggests TRYCREATE\\n\");",
          "1603:       snprintf(prompt, sizeof(prompt), _(\"Create %s?\"), mbox);",
          "",
          "[Removed Lines]",
          "1600:       if (mutt_str_strncasecmp(imap_get_qualifier(idata->buf), \"[TRYCREATE]\", 11) != 0)",
          "",
          "[Added Lines]",
          "1599:       if (mutt_str_strncasecmp(imap_get_qualifier(mdata->buf), \"[TRYCREATE]\", 11) != 0)",
          "",
          "---------------",
          "--- Hunk 53 ---",
          "[Context before]",
          "1606:         mutt_clear_error();",
          "1607:         goto out;",
          "1608:       }",
          "1610:         break;",
          "1611:       triedcreate = 1;",
          "1612:     }",
          "",
          "[Removed Lines]",
          "1609:       if (imap_create_mailbox(idata, mbox) < 0)",
          "",
          "[Added Lines]",
          "1608:       if (imap_create_mailbox(mdata, mbox) < 0)",
          "",
          "---------------",
          "--- Hunk 54 ---",
          "[Context before]",
          "1615:   if (rc != 0)",
          "1616:   {",
          "1618:     goto out;",
          "1619:   }",
          "",
          "[Removed Lines]",
          "1617:     imap_error(\"imap_copy_messages\", idata->buf);",
          "",
          "[Added Lines]",
          "1616:     imap_error(\"imap_copy_messages\", mdata->buf);",
          "",
          "---------------",
          "--- Hunk 55 ---",
          "[Context before]",
          "1666: {",
          "1668:     return -1;",
          "1671:   char id[64];",
          "1674: }",
          "1682: {",
          "1686:   return 0;",
          "1687: }",
          "1694: {",
          "1695:   if (!data || !*data)",
          "1696:     return;",
          "",
          "[Removed Lines]",
          "1665: int imap_cache_del(struct ImapData *idata, struct Email *e)",
          "1667:   if (!idata || !e)",
          "1670:   idata->bcache = msg_cache_open(idata);",
          "1672:   snprintf(id, sizeof(id), \"%u-%u\", idata->uid_validity, HEADER_DATA(e)->uid);",
          "1673:   return mutt_bcache_del(idata->bcache, id);",
          "1681: int imap_cache_clean(struct ImapData *idata)",
          "1683:   idata->bcache = msg_cache_open(idata);",
          "1684:   mutt_bcache_list(idata->bcache, msg_cache_clean_cb, idata);",
          "1693: void imap_free_header_data(struct ImapHeaderData **data)",
          "",
          "[Added Lines]",
          "1664: int imap_cache_del(struct ImapMboxData *mdata, struct Email *e)",
          "1666:   if (!mdata || !e)",
          "1669:   mdata->bcache = msg_cache_open(mdata);",
          "1671:   snprintf(id, sizeof(id), \"%u-%u\", mdata->uid_validity, HEADER_DATA(e)->uid);",
          "1672:   return mutt_bcache_del(mdata->bcache, id);",
          "1680: int imap_cache_clean(struct ImapMboxData *mdata)",
          "1682:   mdata->bcache = msg_cache_open(mdata);",
          "1683:   mutt_bcache_list(mdata->bcache, msg_cache_clean_cb, mdata);",
          "1692: void imap_free_email_data(struct ImapEmailData **data)",
          "",
          "---------------",
          "--- Hunk 56 ---",
          "[Context before]",
          "1723: {",
          "1725:   struct ImapHeader newh = { 0 };",
          "1727:   bool readonly;",
          "1728:   int local_changes;",
          "1730:   local_changes = e->changed;",
          "1737:   mutt_debug(2, \"parsing FLAGS\\n\");",
          "1738:   s = msg_parse_flags(&newh, s);",
          "",
          "[Removed Lines]",
          "1722: char *imap_set_flags(struct ImapData *idata, struct Email *e, char *s, int *server_changes)",
          "1724:   struct Context *ctx = idata->ctx;",
          "1726:   struct ImapHeaderData old_hd;",
          "1732:   struct ImapHeaderData *hd = e->data;",
          "1733:   newh.data = hd;",
          "1735:   memcpy(&old_hd, hd, sizeof(old_hd));",
          "",
          "[Added Lines]",
          "1721: char *imap_set_flags(struct ImapMboxData *mdata, struct Email *e, char *s, int *server_changes)",
          "1723:   struct Context *ctx = mdata->ctx;",
          "1725:   struct ImapEmailData old_edata;",
          "1731:   struct ImapEmailData *edata = e->data;",
          "1732:   newh.data = edata;",
          "1734:   memcpy(&old_edata, edata, sizeof(old_edata));",
          "",
          "---------------",
          "--- Hunk 57 ---",
          "[Context before]",
          "1740:     return NULL;",
          "",
          "[Removed Lines]",
          "1743:   driver_tags_replace(&e->tags, mutt_str_strdup(hd->flags_remote));",
          "",
          "[Added Lines]",
          "1742:   driver_tags_replace(&e->tags, mutt_str_strdup(edata->flags_remote));",
          "",
          "---------------",
          "--- Hunk 58 ---",
          "[Context before]",
          "1750:   ctx->mailbox->readonly = false;",
          "1757:   set_changed_flag(ctx, e, local_changes, server_changes, MUTT_READ,",
          "1759:   set_changed_flag(ctx, e, local_changes, server_changes, MUTT_DELETE,",
          "1761:   set_changed_flag(ctx, e, local_changes, server_changes, MUTT_FLAG,",
          "1763:   set_changed_flag(ctx, e, local_changes, server_changes, MUTT_REPLIED,",
          "",
          "[Removed Lines]",
          "1755:   set_changed_flag(ctx, e, local_changes, server_changes, MUTT_OLD, old_hd.old,",
          "1756:                    hd->old, e->old);",
          "1758:                    old_hd.read, hd->read, e->read);",
          "1760:                    old_hd.deleted, hd->deleted, e->deleted);",
          "1762:                    old_hd.flagged, hd->flagged, e->flagged);",
          "1764:                    old_hd.replied, hd->replied, e->replied);",
          "",
          "[Added Lines]",
          "1754:   set_changed_flag(ctx, e, local_changes, server_changes, MUTT_OLD,",
          "1755:                    old_edata.old, edata->old, e->old);",
          "1757:                    old_edata.read, edata->read, e->read);",
          "1759:                    old_edata.deleted, edata->deleted, e->deleted);",
          "1761:                    old_edata.flagged, edata->flagged, e->flagged);",
          "1763:                    old_edata.replied, edata->replied, e->replied);",
          "",
          "---------------",
          "--- Hunk 59 ---",
          "[Context before]",
          "1796:   bool fetched = false;",
          "1797:   int output_progress;",
          "1800:   struct Email *e = ctx->mailbox->hdrs[msgno];",
          "1803:   if (msg->fp)",
          "1804:   {",
          "1805:     if (HEADER_DATA(e)->parsed)",
          "",
          "[Removed Lines]",
          "1799:   struct ImapData *idata = ctx->mailbox->data;",
          "1802:   msg->fp = msg_cache_get(idata, e);",
          "",
          "[Added Lines]",
          "1798:   struct ImapMboxData *mdata = ctx->mailbox->data;",
          "1801:   msg->fp = msg_cache_get(mdata, e);",
          "",
          "---------------",
          "--- Hunk 60 ---",
          "[Context before]",
          "1813:   cacheno = HEADER_DATA(e)->uid % IMAP_CACHE_LEN;",
          "1816:   if (cache->path)",
          "1817:   {",
          "",
          "[Removed Lines]",
          "1814:   cache = &idata->cache[cacheno];",
          "",
          "[Added Lines]",
          "1813:   cache = &mdata->cache[cacheno];",
          "",
          "---------------",
          "--- Hunk 61 ---",
          "[Context before]",
          "1831:   if (output_progress)",
          "1832:     mutt_message(_(\"Fetching message...\"));",
          "1835:   if (!msg->fp)",
          "1836:   {",
          "1837:     cache->uid = HEADER_DATA(e)->uid;",
          "",
          "[Removed Lines]",
          "1834:   msg->fp = msg_cache_put(idata, e);",
          "",
          "[Added Lines]",
          "1833:   msg->fp = msg_cache_put(mdata, e);",
          "",
          "---------------",
          "--- Hunk 62 ---",
          "[Context before]",
          "1851:   e->active = false;",
          "1853:   snprintf(buf, sizeof(buf), \"UID FETCH %u %s\", HEADER_DATA(e)->uid,",
          "1855:                 (ImapPeek ? \"BODY.PEEK[]\" : \"BODY[]\") :",
          "1856:                 \"RFC822\"));",
          "1859:   do",
          "1860:   {",
          "1862:     if (rc != IMAP_CMD_CONTINUE)",
          "1863:       break;",
          "1866:     pc = imap_next_word(pc);",
          "1867:     pc = imap_next_word(pc);",
          "",
          "[Removed Lines]",
          "1854:            (mutt_bit_isset(idata->capabilities, IMAP4REV1) ?",
          "1858:   imap_cmd_start(idata, buf);",
          "1861:     rc = imap_cmd_step(idata);",
          "1865:     pc = idata->buf;",
          "",
          "[Added Lines]",
          "1853:            (mutt_bit_isset(mdata->capabilities, IMAP4REV1) ?",
          "1857:   imap_cmd_start(mdata, buf);",
          "1860:     rc = imap_cmd_step(mdata);",
          "1864:     pc = mdata->buf;",
          "",
          "---------------",
          "--- Hunk 63 ---",
          "[Context before]",
          "1898:             mutt_progress_init(&progressbar, _(\"Fetching message...\"),",
          "1899:                                MUTT_PROGRESS_SIZE, NetInc, bytes);",
          "1900:           }",
          "1902:                                 output_progress ? &progressbar : NULL) < 0)",
          "1903:           {",
          "1904:             goto bail;",
          "1905:           }",
          "1908:           if (rc != IMAP_CMD_CONTINUE)",
          "1909:             goto bail;",
          "1912:           fetched = true;",
          "1913:         }",
          "",
          "[Removed Lines]",
          "1901:           if (imap_read_literal(msg->fp, idata, bytes,",
          "1907:           rc = imap_cmd_step(idata);",
          "1910:           pc = idata->buf;",
          "",
          "[Added Lines]",
          "1900:           if (imap_read_literal(msg->fp, mdata, bytes,",
          "1906:           rc = imap_cmd_step(mdata);",
          "1909:           pc = mdata->buf;",
          "",
          "---------------",
          "--- Hunk 64 ---",
          "[Context before]",
          "1918:         else if ((mutt_str_strncasecmp(\"FLAGS\", pc, 5) == 0) && !e->changed)",
          "1919:         {",
          "1921:           if (!pc)",
          "1922:             goto bail;",
          "1923:         }",
          "",
          "[Removed Lines]",
          "1920:           pc = imap_set_flags(idata, e, pc, NULL);",
          "",
          "[Added Lines]",
          "1919:           pc = imap_set_flags(mdata, e, pc, NULL);",
          "",
          "---------------",
          "--- Hunk 65 ---",
          "[Context before]",
          "1938:   if (rc != IMAP_CMD_OK)",
          "1939:     goto bail;",
          "1942:     goto bail;",
          "1946: parsemsg:",
          "",
          "[Removed Lines]",
          "1941:   if (!fetched || !imap_code(idata->buf))",
          "1944:   msg_cache_commit(idata, e);",
          "",
          "[Added Lines]",
          "1940:   if (!fetched || !imap_code(mdata->buf))",
          "1943:   msg_cache_commit(mdata, e);",
          "",
          "---------------",
          "--- Hunk 66 ---",
          "[Context before]",
          "1983:   if (!retried && ((e->lines == 0) || (e->content->length == 0)))",
          "1984:   {",
          "1986:     retried = true;",
          "1987:     goto parsemsg;",
          "1988:   }",
          "",
          "[Removed Lines]",
          "1985:     imap_cache_del(idata, e);",
          "",
          "[Added Lines]",
          "1984:     imap_cache_del(mdata, e);",
          "",
          "---------------",
          "--- Hunk 67 ---",
          "[Context before]",
          "1992: bail:",
          "1993:   mutt_file_fclose(&msg->fp);",
          "1995:   if (cache->path)",
          "1996:   {",
          "1997:     unlink(cache->path);",
          "",
          "[Removed Lines]",
          "1994:   imap_cache_del(idata, e);",
          "",
          "[Added Lines]",
          "1993:   imap_cache_del(mdata, e);",
          "",
          "---------------"
        ],
        "imap/message.h||imap/message.h": [
          "File: imap/message.h -> imap/message.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "29: #include \"email/lib.h\"",
          "37: {",
          "39:   bool read : 1;",
          "",
          "[Removed Lines]",
          "36: struct ImapHeaderData",
          "",
          "[Added Lines]",
          "36: struct ImapEmailData",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "57: struct ImapHeader",
          "58: {",
          "61:   time_t received;",
          "62:   long content_length;",
          "63: };",
          "",
          "[Removed Lines]",
          "59:   struct ImapHeaderData *data;",
          "65: #define HEADER_DATA(ph) ((struct ImapHeaderData *) ((ph)->data))",
          "",
          "[Added Lines]",
          "59:   struct ImapEmailData *data;",
          "65: #define HEADER_DATA(ph) ((struct ImapEmailData *) ((ph)->data))",
          "",
          "---------------"
        ],
        "imap/utf7.c||imap/utf7.c": [
          "File: imap/utf7.c -> imap/utf7.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "318: {",
          "319:   if (!Charset || !s)",
          "320:     return;",
          "",
          "[Removed Lines]",
          "317: void imap_utf_encode(struct ImapData *idata, char **s)",
          "",
          "[Added Lines]",
          "317: void imap_utf_encode(struct ImapMboxData *mdata, char **s)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "323:   if (t && (mutt_ch_convert_string(&t, Charset, \"utf-8\", 0) == 0))",
          "324:   {",
          "325:     FREE(s);",
          "328:     else",
          "",
          "[Removed Lines]",
          "326:     if (idata->unicode)",
          "",
          "[Added Lines]",
          "326:     if (mdata->unicode)",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "340: {",
          "341:   if (!Charset)",
          "342:     return;",
          "344:   char *t = NULL;",
          "347:     t = mutt_str_strdup(*s);",
          "348:   else",
          "349:     t = utf7_to_utf8(*s, strlen(*s), 0, 0);",
          "",
          "[Removed Lines]",
          "339: void imap_utf_decode(struct ImapData *idata, char **s)",
          "346:   if (idata->unicode)",
          "",
          "[Added Lines]",
          "339: void imap_utf_decode(struct ImapMboxData *mdata, char **s)",
          "346:   if (mdata->unicode)",
          "",
          "---------------"
        ],
        "imap/util.c||imap/util.c": [
          "File: imap/util.c -> imap/util.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "81: int imap_expand_path(char *buf, size_t buflen)",
          "82: {",
          "83:   struct ImapMbox mx;",
          "85:   struct Url url;",
          "86:   char fixedpath[LONG_STRING];",
          "87:   int rc;",
          "",
          "[Removed Lines]",
          "84:   struct ImapData *idata = NULL;",
          "",
          "[Added Lines]",
          "84:   struct ImapMboxData *mdata = NULL;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "89:   if (imap_parse_path(buf, &mx) < 0)",
          "90:     return -1;",
          "93:   mutt_account_tourl(&mx.account, &url);",
          "95:   url.path = fixedpath;",
          "97:   rc = url_tostring(&url, buf, buflen, U_DECODE_PASSWD);",
          "",
          "[Removed Lines]",
          "92:   idata = imap_conn_find(&mx.account, MUTT_IMAP_CONN_NONEW);",
          "94:   imap_fix_path(idata, mx.mbox, fixedpath, sizeof(fixedpath));",
          "",
          "[Added Lines]",
          "92:   mdata = imap_conn_find(&mx.account, MUTT_IMAP_CONN_NONEW);",
          "94:   imap_fix_path(mdata, mx.mbox, fixedpath, sizeof(fixedpath));",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "156: void imap_get_parent_path(const char *path, char *buf, size_t buflen)",
          "157: {",
          "158:   struct ImapMbox mx;",
          "160:   char mbox[LONG_STRING] = \"\";",
          "162:   if (imap_parse_path(path, &mx) < 0)",
          "",
          "[Removed Lines]",
          "159:   struct ImapData *idata = NULL;",
          "",
          "[Added Lines]",
          "159:   struct ImapMboxData *mdata = NULL;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "165:     return;",
          "166:   }",
          "170:   {",
          "171:     mutt_str_strfcpy(buf, path, buflen);",
          "172:     return;",
          "173:   }",
          "182:   imap_qualify_path(buf, buflen, &mx, mbox);",
          "",
          "[Removed Lines]",
          "168:   idata = imap_conn_find(&mx.account, MUTT_IMAP_CONN_NONEW);",
          "169:   if (!idata)",
          "176:   imap_fix_path(idata, mx.mbox, mbox, sizeof(mbox));",
          "179:   imap_get_parent(mbox, idata->delim, mbox, sizeof(mbox));",
          "",
          "[Added Lines]",
          "168:   mdata = imap_conn_find(&mx.account, MUTT_IMAP_CONN_NONEW);",
          "169:   if (!mdata)",
          "176:   imap_fix_path(mdata, mx.mbox, mbox, sizeof(mbox));",
          "179:   imap_get_parent(mbox, mdata->delim, mbox, sizeof(mbox));",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "193: void imap_clean_path(char *path, size_t plen)",
          "194: {",
          "195:   struct ImapMbox mx;",
          "197:   char mbox[LONG_STRING] = \"\";",
          "199:   if (imap_parse_path(path, &mx) < 0)",
          "200:     return;",
          "204:     return;",
          "210:   imap_qualify_path(path, plen, &mx, mbox);",
          "",
          "[Removed Lines]",
          "196:   struct ImapData *idata = NULL;",
          "202:   idata = imap_conn_find(&mx.account, MUTT_IMAP_CONN_NONEW);",
          "203:   if (!idata)",
          "207:   imap_fix_path(idata, mx.mbox, mbox, sizeof(mbox));",
          "",
          "[Added Lines]",
          "196:   struct ImapMboxData *mdata = NULL;",
          "202:   mdata = imap_conn_find(&mx.account, MUTT_IMAP_CONN_NONEW);",
          "203:   if (!mdata)",
          "207:   imap_fix_path(mdata, mx.mbox, mbox, sizeof(mbox));",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "223: {",
          "224:   int first = 1, state = 0;",
          "225:   bool match = false;",
          "226:   unsigned int cur_uid = 0, last_uid = 0;",
          "227:   unsigned int range_begin = 0, range_end = 0;",
          "230:   {",
          "231:     match = false;",
          "233:     {",
          "235:       cur_uid = cur_header ? HEADER_DATA(cur_header)->uid : 0;",
          "236:       if (!state || (cur_uid && ((cur_uid - 1) == last_uid)))",
          "237:         match = true;",
          "",
          "[Removed Lines]",
          "222: static void imap_msn_index_to_uid_seqset(struct Buffer *b, struct ImapData *idata)",
          "229:   for (unsigned int msn = 1; msn <= idata->max_msn + 1; msn++)",
          "232:     if (msn <= idata->max_msn)",
          "234:       struct Email *cur_header = idata->msn_index[msn - 1];",
          "",
          "[Added Lines]",
          "222: static void imap_msn_index_to_uid_seqset(struct Buffer *b, struct ImapMboxData *mdata)",
          "229:   for (unsigned int msn = 1; msn <= mdata->max_msn + 1; msn++)",
          "232:     if (msn <= mdata->max_msn)",
          "234:       struct Email *cur_header = mdata->msn_index[msn - 1];",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "291: {",
          "292:   struct ImapMbox mx;",
          "293:   struct Url url;",
          "",
          "[Removed Lines]",
          "290: header_cache_t *imap_hcache_open(struct ImapData *idata, const char *path)",
          "",
          "[Added Lines]",
          "290: header_cache_t *imap_hcache_open(struct ImapMboxData *mdata, const char *path)",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "295:   char mbox[PATH_MAX];",
          "297:   if (path)",
          "299:   else",
          "300:   {",
          "302:       return NULL;",
          "305:     FREE(&mx.mbox);",
          "306:   }",
          "",
          "[Removed Lines]",
          "298:     imap_cachepath(idata, path, mbox, sizeof(mbox));",
          "301:     if (!idata->ctx || imap_parse_path(idata->ctx->mailbox->path, &mx) < 0)",
          "304:     imap_cachepath(idata, mx.mbox, mbox, sizeof(mbox));",
          "",
          "[Added Lines]",
          "298:     imap_cachepath(mdata, path, mbox, sizeof(mbox));",
          "301:     if (!mdata->ctx || imap_parse_path(mdata->ctx->mailbox->path, &mx) < 0)",
          "304:     imap_cachepath(mdata, mx.mbox, mbox, sizeof(mbox));",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "311:   if ((len > 3) && (strcmp(mbox + len - 3, \"/..\") == 0))",
          "312:     return NULL;",
          "315:   url.path = mbox;",
          "316:   url_tostring(&url, cachepath, sizeof(cachepath), U_PATH);",
          "",
          "[Removed Lines]",
          "314:   mutt_account_tourl(&idata->conn->account, &url);",
          "",
          "[Added Lines]",
          "314:   mutt_account_tourl(&mdata->conn->account, &url);",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "326: {",
          "328:     return;",
          "332: }",
          "342: {",
          "343:   char key[16];",
          "344:   void *uv = NULL;",
          "345:   struct Email *e = NULL;",
          "348:     return NULL;",
          "350:   sprintf(key, \"/%u\", uid);",
          "352:   if (uv)",
          "353:   {",
          "355:       e = mutt_hcache_restore(uv);",
          "356:     else",
          "357:       mutt_debug(3, \"hcache uidvalidity mismatch: %u\\n\", *(unsigned int *) uv);",
          "359:   }",
          "361:   return e;",
          "",
          "[Removed Lines]",
          "325: void imap_hcache_close(struct ImapData *idata)",
          "327:   if (!idata->hcache)",
          "330:   mutt_hcache_close(idata->hcache);",
          "331:   idata->hcache = NULL;",
          "341: struct Email *imap_hcache_get(struct ImapData *idata, unsigned int uid)",
          "347:   if (!idata->hcache)",
          "351:   uv = mutt_hcache_fetch(idata->hcache, key, imap_hcache_keylen(key));",
          "354:     if (*(unsigned int *) uv == idata->uid_validity)",
          "358:     mutt_hcache_free(idata->hcache, &uv);",
          "",
          "[Added Lines]",
          "325: void imap_hcache_close(struct ImapMboxData *mdata)",
          "327:   if (!mdata->hcache)",
          "330:   mutt_hcache_close(mdata->hcache);",
          "331:   mdata->hcache = NULL;",
          "341: struct Email *imap_hcache_get(struct ImapMboxData *mdata, unsigned int uid)",
          "347:   if (!mdata->hcache)",
          "351:   uv = mutt_hcache_fetch(mdata->hcache, key, imap_hcache_keylen(key));",
          "354:     if (*(unsigned int *) uv == mdata->uid_validity)",
          "358:     mutt_hcache_free(mdata->hcache, &uv);",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "372: {",
          "373:   char key[16];",
          "376:     return -1;",
          "378:   sprintf(key, \"/%u\", HEADER_DATA(e)->uid);",
          "380: }",
          "390: {",
          "391:   char key[16];",
          "394:     return -1;",
          "396:   sprintf(key, \"/%u\", uid);",
          "398: }",
          "407: {",
          "409:     return -1;",
          "411:   struct Buffer *b = mutt_buffer_new();",
          "413:   mutt_buffer_increase_size(b, HUGE_STRING);",
          "416:   size_t seqset_size = b->dptr - b->data;",
          "417:   if (seqset_size == 0)",
          "418:     b->data[0] = '\\0';",
          "421:   mutt_debug(5, \"Stored /UIDSEQSET %s\\n\", b->data);",
          "422:   mutt_buffer_free(&b);",
          "423:   return rc;",
          "",
          "[Removed Lines]",
          "371: int imap_hcache_put(struct ImapData *idata, struct Email *e)",
          "375:   if (!idata->hcache)",
          "379:   return mutt_hcache_store(idata->hcache, key, imap_hcache_keylen(key), e, idata->uid_validity);",
          "389: int imap_hcache_del(struct ImapData *idata, unsigned int uid)",
          "393:   if (!idata->hcache)",
          "397:   return mutt_hcache_delete(idata->hcache, key, imap_hcache_keylen(key));",
          "406: int imap_hcache_store_uid_seqset(struct ImapData *idata)",
          "408:   if (!idata->hcache)",
          "414:   imap_msn_index_to_uid_seqset(b, idata);",
          "420:   int rc = mutt_hcache_store_raw(idata->hcache, \"/UIDSEQSET\", 10, b->data, seqset_size + 1);",
          "",
          "[Added Lines]",
          "371: int imap_hcache_put(struct ImapMboxData *mdata, struct Email *e)",
          "375:   if (!mdata->hcache)",
          "379:   return mutt_hcache_store(mdata->hcache, key, imap_hcache_keylen(key), e, mdata->uid_validity);",
          "389: int imap_hcache_del(struct ImapMboxData *mdata, unsigned int uid)",
          "393:   if (!mdata->hcache)",
          "397:   return mutt_hcache_delete(mdata->hcache, key, imap_hcache_keylen(key));",
          "406: int imap_hcache_store_uid_seqset(struct ImapMboxData *mdata)",
          "408:   if (!mdata->hcache)",
          "414:   imap_msn_index_to_uid_seqset(b, mdata);",
          "420:   int rc = mutt_hcache_store_raw(mdata->hcache, \"/UIDSEQSET\", 10, b->data, seqset_size + 1);",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "433: {",
          "435:     return -1;",
          "438: }",
          "447: {",
          "449:     return NULL;",
          "452:   char *seqset = mutt_str_strdup(hc_seqset);",
          "454:   mutt_debug(5, \"Retrieved /UIDSEQSET %s\\n\", NONULL(seqset));",
          "456:   return seqset;",
          "",
          "[Removed Lines]",
          "432: int imap_hcache_clear_uid_seqset(struct ImapData *idata)",
          "434:   if (!idata->hcache)",
          "437:   return mutt_hcache_delete(idata->hcache, \"/UIDSEQSET\", 10);",
          "446: char *imap_hcache_get_uid_seqset(struct ImapData *idata)",
          "448:   if (!idata->hcache)",
          "451:   char *hc_seqset = mutt_hcache_fetch_raw(idata->hcache, \"/UIDSEQSET\", 10);",
          "453:   mutt_hcache_free(idata->hcache, (void **) &hc_seqset);",
          "",
          "[Added Lines]",
          "432: int imap_hcache_clear_uid_seqset(struct ImapMboxData *mdata)",
          "434:   if (!mdata->hcache)",
          "437:   return mutt_hcache_delete(mdata->hcache, \"/UIDSEQSET\", 10);",
          "446: char *imap_hcache_get_uid_seqset(struct ImapMboxData *mdata)",
          "448:   if (!mdata->hcache)",
          "451:   char *hc_seqset = mutt_hcache_fetch_raw(mdata->hcache, \"/UIDSEQSET\", 10);",
          "453:   mutt_hcache_free(mdata->hcache, (void **) &hc_seqset);",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "702: }",
          "710: {",
          "721: }",
          "728: {",
          "730:     return;",
          "740: }",
          "",
          "[Removed Lines]",
          "709: struct ImapData *imap_new_idata(void)",
          "711:   struct ImapData *idata = mutt_mem_calloc(1, sizeof(struct ImapData));",
          "713:   idata->cmdbuf = mutt_buffer_new();",
          "714:   idata->cmdslots = ImapPipelineDepth + 2;",
          "715:   idata->cmds = mutt_mem_calloc(idata->cmdslots, sizeof(*idata->cmds));",
          "717:   STAILQ_INIT(&idata->flags);",
          "718:   STAILQ_INIT(&idata->mboxcache);",
          "720:   return idata;",
          "727: void imap_free_idata(struct ImapData **idata)",
          "729:   if (!idata)",
          "732:   FREE(&(*idata)->capstr);",
          "733:   mutt_list_free(&(*idata)->flags);",
          "734:   imap_mboxcache_free(*idata);",
          "735:   mutt_buffer_free(&(*idata)->cmdbuf);",
          "736:   FREE(&(*idata)->buf);",
          "737:   mutt_bcache_close(&(*idata)->bcache);",
          "738:   FREE(&(*idata)->cmds);",
          "739:   FREE(idata);",
          "",
          "[Added Lines]",
          "709: struct ImapMboxData *imap_new_idata(void)",
          "711:   struct ImapMboxData *mdata = mutt_mem_calloc(1, sizeof(struct ImapMboxData));",
          "713:   mdata->cmdbuf = mutt_buffer_new();",
          "714:   mdata->cmdslots = ImapPipelineDepth + 2;",
          "715:   mdata->cmds = mutt_mem_calloc(mdata->cmdslots, sizeof(*mdata->cmds));",
          "717:   STAILQ_INIT(&mdata->flags);",
          "718:   STAILQ_INIT(&mdata->mboxcache);",
          "720:   return mdata;",
          "727: void imap_free_idata(struct ImapMboxData **mdata)",
          "729:   if (!mdata)",
          "732:   FREE(&(*mdata)->capstr);",
          "733:   mutt_list_free(&(*mdata)->flags);",
          "734:   imap_mboxcache_free(*mdata);",
          "735:   mutt_buffer_free(&(*mdata)->cmdbuf);",
          "736:   FREE(&(*mdata)->buf);",
          "737:   mutt_bcache_close(&(*mdata)->bcache);",
          "738:   FREE(&(*mdata)->cmds);",
          "739:   FREE(mdata);",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "757: {",
          "758:   int i = 0;",
          "759:   char delim = '\\0';",
          "764:   while (mailbox && *mailbox && i < plen - 1)",
          "765:   {",
          "766:     if ((ImapDelimChars && strchr(ImapDelimChars, *mailbox)) || (delim && *mailbox == delim))",
          "767:     {",
          "770:         delim = *mailbox;",
          "772:       while (*mailbox && ((ImapDelimChars && strchr(ImapDelimChars, *mailbox)) ||",
          "",
          "[Removed Lines]",
          "756: char *imap_fix_path(struct ImapData *idata, const char *mailbox, char *path, size_t plen)",
          "761:   if (idata)",
          "762:     delim = idata->delim;",
          "769:       if (!idata)",
          "",
          "[Added Lines]",
          "756: char *imap_fix_path(struct ImapMboxData *mdata, const char *mailbox, char *path, size_t plen)",
          "761:   if (mdata)",
          "762:     delim = mdata->delim;",
          "769:       if (!mdata)",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "801: {",
          "802:   char *s = NULL;",
          "803:   const char *p = mailbox;",
          "805:   for (s = dest; p && *p && dlen; dlen--)",
          "806:   {",
          "808:     {",
          "",
          "[Removed Lines]",
          "800: void imap_cachepath(struct ImapData *idata, const char *mailbox, char *dest, size_t dlen)",
          "807:     if (*p == idata->delim)",
          "",
          "[Added Lines]",
          "800: void imap_cachepath(struct ImapMboxData *mdata, const char *mailbox, char *dest, size_t dlen)",
          "807:     if (*p == mdata->delim)",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "1003: {",
          "1004:   char *buf = mutt_str_strdup(src);",
          "1007:   imap_quote_string(dest, dlen, buf, false);",
          "",
          "[Removed Lines]",
          "1002: void imap_munge_mbox_name(struct ImapData *idata, char *dest, size_t dlen, const char *src)",
          "1005:   imap_utf_encode(idata, &buf);",
          "",
          "[Added Lines]",
          "1002: void imap_munge_mbox_name(struct ImapMboxData *mdata, char *dest, size_t dlen, const char *src)",
          "1005:   imap_utf_encode(mdata, &buf);",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "1020: {",
          "1021:   imap_unquote_string(s);",
          "1023:   char *buf = mutt_str_strdup(s);",
          "1024:   if (buf)",
          "1025:   {",
          "1027:     strncpy(s, buf, strlen(s));",
          "1028:   }",
          "",
          "[Removed Lines]",
          "1019: void imap_unmunge_mbox_name(struct ImapData *idata, char *s)",
          "1026:     imap_utf_decode(idata, &buf);",
          "",
          "[Added Lines]",
          "1019: void imap_unmunge_mbox_name(struct ImapMboxData *mdata, char *s)",
          "1026:     imap_utf_decode(mdata, &buf);",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "1036: void imap_keepalive(void)",
          "1037: {",
          "1038:   struct Connection *conn = NULL;",
          "1040:   time_t now = time(NULL);",
          "1042:   TAILQ_FOREACH(conn, mutt_socket_head(), entries)",
          "1043:   {",
          "1044:     if (conn->account.type == MUTT_ACCT_TYPE_IMAP)",
          "1045:     {",
          "1048:       {",
          "1050:       }",
          "1051:     }",
          "1052:   }",
          "",
          "[Removed Lines]",
          "1039:   struct ImapData *idata = NULL;",
          "1046:       idata = conn->data;",
          "1047:       if (idata->state >= IMAP_AUTHENTICATED && now >= idata->lastread + ImapKeepalive)",
          "1049:         imap_check(idata, true);",
          "",
          "[Added Lines]",
          "1039:   struct ImapMboxData *mdata = NULL;",
          "1046:       mdata = conn->data;",
          "1047:       if (mdata->state >= IMAP_AUTHENTICATED && now >= mdata->lastread + ImapKeepalive)",
          "1049:         imap_check(mdata, true);",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "1108: void imap_allow_reopen(struct Context *ctx)",
          "1109: {",
          "1111:   if (!ctx || !ctx->mailbox->data || ctx->mailbox->magic != MUTT_IMAP)",
          "1112:     return;",
          "1117: }",
          "",
          "[Removed Lines]",
          "1110:   struct ImapData *idata = NULL;",
          "1114:   idata = ctx->mailbox->data;",
          "1115:   if (idata->ctx == ctx)",
          "1116:     idata->reopen |= IMAP_REOPEN_ALLOW;",
          "",
          "[Added Lines]",
          "1110:   struct ImapMboxData *mdata = NULL;",
          "1114:   mdata = ctx->mailbox->data;",
          "1115:   if (mdata->ctx == ctx)",
          "1116:     mdata->reopen |= IMAP_REOPEN_ALLOW;",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "1123: void imap_disallow_reopen(struct Context *ctx)",
          "1124: {",
          "1126:   if (!ctx || !ctx->mailbox->data || ctx->mailbox->magic != MUTT_IMAP)",
          "1127:     return;",
          "1132: }",
          "",
          "[Removed Lines]",
          "1125:   struct ImapData *idata = NULL;",
          "1129:   idata = ctx->mailbox->data;",
          "1130:   if (idata->ctx == ctx)",
          "1131:     idata->reopen &= ~IMAP_REOPEN_ALLOW;",
          "",
          "[Added Lines]",
          "1125:   struct ImapMboxData *mdata = NULL;",
          "1129:   mdata = ctx->mailbox->data;",
          "1130:   if (mdata->ctx == ctx)",
          "1131:     mdata->reopen &= ~IMAP_REOPEN_ALLOW;",
          "",
          "---------------",
          "--- Hunk 21 ---",
          "[Context before]",
          "1140: int imap_account_match(const struct ConnAccount *a1, const struct ConnAccount *a2)",
          "1141: {",
          "1144:   const struct ConnAccount *a1_canon = a1_idata ? &a1_idata->conn->account : a1;",
          "1145:   const struct ConnAccount *a2_canon = a2_idata ? &a2_idata->conn->account : a2;",
          "",
          "[Removed Lines]",
          "1142:   struct ImapData *a1_idata = imap_conn_find(a1, MUTT_IMAP_CONN_NONEW);",
          "1143:   struct ImapData *a2_idata = imap_conn_find(a2, MUTT_IMAP_CONN_NONEW);",
          "",
          "[Added Lines]",
          "1142:   struct ImapMboxData *a1_idata = imap_conn_find(a1, MUTT_IMAP_CONN_NONEW);",
          "1143:   struct ImapMboxData *a2_idata = imap_conn_find(a2, MUTT_IMAP_CONN_NONEW);",
          "",
          "---------------"
        ]
      }
    }
  ]
}
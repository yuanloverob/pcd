{
  "cve_id": "CVE-2017-9993",
  "cve_desc": "FFmpeg before 2.8.12, 3.0.x and 3.1.x before 3.1.9, 3.2.x before 3.2.6, and 3.3.x before 3.3.2 does not properly restrict HTTP Live Streaming filename extensions and demuxer names, which allows attackers to read arbitrary files via crafted playlist data.",
  "repo": "FFmpeg/FFmpeg",
  "patch_hash": "189ff4219644532bdfa7bab28dfedaee4d6d4021",
  "patch_info": {
    "commit_hash": "189ff4219644532bdfa7bab28dfedaee4d6d4021",
    "repo": "FFmpeg/FFmpeg",
    "commit_url": "https://github.com/FFmpeg/FFmpeg/commit/189ff4219644532bdfa7bab28dfedaee4d6d4021",
    "files": [
      "libavformat/hls.c"
    ],
    "message": "avformat/hls: Check local file extensions\n\nThis reduces the attack surface of local file-system\ninformation leaking.\n\nIt prevents the existing exploit leading to an information leak. As\nwell as similar hypothetical attacks.\n\nLeaks of information from files and symlinks ending in common multimedia extensions\nare still possible. But files with sensitive information like private keys and passwords\ngenerally do not use common multimedia filename extensions.\nIt does not stop leaks via remote addresses in the LAN.\n\nThe existing exploit depends on a specific decoder as well.\nIt does appear though that the exploit should be possible with any decoder.\nThe problem is that as long as sensitive information gets into the decoder,\nthe output of the decoder becomes sensitive as well.\nThe only obvious solution is to prevent access to sensitive information. Or to\ndisable hls or possibly some of its feature. More complex solutions like\nchecking the path to limit access to only subdirectories of the hls path may\nwork as an alternative. But such solutions are fragile and tricky to implement\nportably and would not stop every possible attack nor would they work with all\nvalid hls files.\n\nDevelopers have expressed their dislike / objected to disabling hls by default as well\nas disabling hls with local files. There also where objections against restricting\nremote url file extensions. This here is a less robust but also lower\ninconvenience solution.\nIt can be applied stand alone or together with other solutions.\nlimiting the check to local files was suggested by nevcairiel\n\nThis recommits the security fix without the author name joke which was\noriginally requested by Nicolas.\n\nFound-by: Emil Lerner and Pavel Cheremushkin\nReported-by: Thierry Foucu <tfoucu@google.com>\n\nSigned-off-by: Michael Niedermayer <michael@niedermayer.cc>",
    "before_after_code_files": [
      "libavformat/hls.c||libavformat/hls.c"
    ]
  },
  "patch_diff": {
    "libavformat/hls.c||libavformat/hls.c": [
      "File: libavformat/hls.c -> libavformat/hls.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "204:     char *http_proxy;                    ///< holds the address of the HTTP proxy server",
      "205:     AVDictionary *avio_opts;",
      "206:     int strict_std_compliance;",
      "207: } HLSContext;",
      "209: static int read_chomp_line(AVIOContext *s, char *buf, int maxlen)",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "207:     char *allowed_extensions;",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "618:         return AVERROR_INVALIDDATA;",
      "622:         return AVERROR_INVALIDDATA;",
      "623:     if (!strncmp(proto_name, url, strlen(proto_name)) && url[strlen(proto_name)] == ':')",
      "624:         ;",
      "625:     else if (av_strstart(url, \"crypto\", NULL) && !strncmp(proto_name, url + 7, strlen(proto_name)) && url[7 + strlen(proto_name)] == ':')",
      "",
      "[Removed Lines]",
      "621:     if (!av_strstart(proto_name, \"http\", NULL) && !av_strstart(proto_name, \"file\", NULL))",
      "",
      "[Added Lines]",
      "622:     if (av_strstart(proto_name, \"file\", NULL)) {",
      "623:         if (strcmp(c->allowed_extensions, \"ALL\") && !av_match_ext(url, c->allowed_extensions)) {",
      "624:             av_log(s, AV_LOG_ERROR,",
      "625:                 \"Filename extension of \\'%s\\' is not a common multimedia extension, blocked for security reasons.\\n\"",
      "626:                 \"If you wish to override this adjust allowed_extensions, you can set it to \\'ALL\\' to allow all\\n\",",
      "627:                 url);",
      "628:             return AVERROR_INVALIDDATA;",
      "629:         }",
      "630:     } else if (av_strstart(proto_name, \"http\", NULL)) {",
      "631:         ;",
      "632:     } else",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "2134: static const AVOption hls_options[] = {",
      "2135:     {\"live_start_index\", \"segment index to start live streams at (negative values are from the end)\",",
      "2136:         OFFSET(live_start_index), AV_OPT_TYPE_INT, {.i64 = -3}, INT_MIN, INT_MAX, FLAGS},",
      "2137:     {NULL}",
      "2138: };",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "2149:     {\"allowed_extensions\", \"List of file extensions that hls is allowed to access\",",
      "2150:         OFFSET(allowed_extensions), AV_OPT_TYPE_STRING,",
      "2151:         {.str = \"3gp,aac,avi,flac,mkv,m3u8,m4a,m4s,m4v,mpg,mov,mp2,mp3,mp4,mpeg,mpegts,ogg,ogv,oga,ts,vob,wav\"},",
      "2152:         INT_MIN, INT_MAX, FLAGS},",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "e0a3b8670d27863bfe6175b383918a5516a6bc42",
      "candidate_info": {
        "commit_hash": "e0a3b8670d27863bfe6175b383918a5516a6bc42",
        "repo": "FFmpeg/FFmpeg",
        "commit_url": "https://github.com/FFmpeg/FFmpeg/commit/e0a3b8670d27863bfe6175b383918a5516a6bc42",
        "files": [
          "libavformat/hls.c"
        ],
        "message": "avformat/hls: Check local file extensions\n\nThis reduces the attack surface of local file-system\ninformation leaking.\n\nIt prevents the existing exploit leading to an information leak. As\nwell as similar hypothetical attacks.\n\nLeaks of information from files and symlinks ending in common multimedia extensions\nare still possible. But files with sensitive information like private keys and passwords\ngenerally do not use common multimedia filename extensions.\nIt does not stop leaks via remote addresses in the LAN.\n\nThe existing exploit depends on a specific decoder as well.\nIt does appear though that the exploit should be possible with any decoder.\nThe problem is that as long as sensitive information gets into the decoder,\nthe output of the decoder becomes sensitive as well.\nThe only obvious solution is to prevent access to sensitive information. Or to\ndisable hls or possibly some of its feature. More complex solutions like\nchecking the path to limit access to only subdirectories of the hls path may\nwork as an alternative. But such solutions are fragile and tricky to implement\nportably and would not stop every possible attack nor would they work with all\nvalid hls files.\n\nDevelopers have expressed their dislike / objected to disabling hls by default as well\nas disabling hls with local files. There also where objections against restricting\nremote url file extensions. This here is a less robust but also lower\ninconvenience solution.\nIt can be applied stand alone or together with other solutions.\nlimiting the check to local files was suggested by nevcairiel\n\nThis recommits the security fix without the author name joke which was\noriginally requested by Nicolas.\n\nFound-by: Emil Lerner and Pavel Cheremushkin\nReported-by: Thierry Foucu <tfoucu@google.com>\n\nSigned-off-by: Michael Niedermayer <michael@niedermayer.cc>\n(cherry picked from commit 189ff4219644532bdfa7bab28dfedaee4d6d4021)\nSigned-off-by: Michael Niedermayer <michael@niedermayer.cc>",
        "before_after_code_files": [
          "libavformat/hls.c||libavformat/hls.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_cherry_pick": 1,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "libavformat/hls.c||libavformat/hls.c"
          ],
          "candidate": [
            "libavformat/hls.c||libavformat/hls.c"
          ]
        }
      },
      "candidate_diff": {
        "libavformat/hls.c||libavformat/hls.c": [
          "File: libavformat/hls.c -> libavformat/hls.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "203:     char *http_proxy;                    ///< holds the address of the HTTP proxy server",
          "204:     AVDictionary *avio_opts;",
          "205:     int strict_std_compliance;",
          "206: } HLSContext;",
          "208: static int read_chomp_line(AVIOContext *s, char *buf, int maxlen)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "206:     char *allowed_extensions;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "617:         return AVERROR_INVALIDDATA;",
          "621:         return AVERROR_INVALIDDATA;",
          "622:     if (!strncmp(proto_name, url, strlen(proto_name)) && url[strlen(proto_name)] == ':')",
          "623:         ;",
          "624:     else if (av_strstart(url, \"crypto\", NULL) && !strncmp(proto_name, url + 7, strlen(proto_name)) && url[7 + strlen(proto_name)] == ':')",
          "",
          "[Removed Lines]",
          "620:     if (!av_strstart(proto_name, \"http\", NULL) && !av_strstart(proto_name, \"file\", NULL))",
          "",
          "[Added Lines]",
          "621:     if (av_strstart(proto_name, \"file\", NULL)) {",
          "622:         if (strcmp(c->allowed_extensions, \"ALL\") && !av_match_ext(url, c->allowed_extensions)) {",
          "623:             av_log(s, AV_LOG_ERROR,",
          "624:                 \"Filename extension of \\'%s\\' is not a common multimedia extension, blocked for security reasons.\\n\"",
          "625:                 \"If you wish to override this adjust allowed_extensions, you can set it to \\'ALL\\' to allow all\\n\",",
          "626:                 url);",
          "627:             return AVERROR_INVALIDDATA;",
          "628:         }",
          "629:     } else if (av_strstart(proto_name, \"http\", NULL)) {",
          "630:         ;",
          "631:     } else",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "2046: static const AVOption hls_options[] = {",
          "2047:     {\"live_start_index\", \"segment index to start live streams at (negative values are from the end)\",",
          "2048:         OFFSET(live_start_index), AV_OPT_TYPE_INT, {.i64 = -3}, INT_MIN, INT_MAX, FLAGS},",
          "2049:     {NULL}",
          "2050: };",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2061:     {\"allowed_extensions\", \"List of file extensions that hls is allowed to access\",",
          "2062:         OFFSET(allowed_extensions), AV_OPT_TYPE_STRING,",
          "2063:         {.str = \"3gp,aac,avi,flac,mkv,m3u8,m4a,m4s,m4v,mpg,mov,mp2,mp3,mp4,mpeg,mpegts,ogg,ogv,oga,ts,vob,wav\"},",
          "2064:         INT_MIN, INT_MAX, FLAGS},",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "7e6b64a7d9a2dd64e652b3e42a741b673cda3a26",
      "candidate_info": {
        "commit_hash": "7e6b64a7d9a2dd64e652b3e42a741b673cda3a26",
        "repo": "FFmpeg/FFmpeg",
        "commit_url": "https://github.com/FFmpeg/FFmpeg/commit/7e6b64a7d9a2dd64e652b3e42a741b673cda3a26",
        "files": [
          "libavformat/hls.c"
        ],
        "message": "avformat/hls: Check local file extensions\n\nThis reduces the attack surface of local file-system\ninformation leaking.\n\nIt prevents the existing exploit leading to an information leak. As\nwell as similar hypothetical attacks.\n\nLeaks of information from files and symlinks ending in common multimedia extensions\nare still possible. But files with sensitive information like private keys and passwords\ngenerally do not use common multimedia filename extensions.\nIt does not stop leaks via remote addresses in the LAN.\n\nThe existing exploit depends on a specific decoder as well.\nIt does appear though that the exploit should be possible with any decoder.\nThe problem is that as long as sensitive information gets into the decoder,\nthe output of the decoder becomes sensitive as well.\nThe only obvious solution is to prevent access to sensitive information. Or to\ndisable hls or possibly some of its feature. More complex solutions like\nchecking the path to limit access to only subdirectories of the hls path may\nwork as an alternative. But such solutions are fragile and tricky to implement\nportably and would not stop every possible attack nor would they work with all\nvalid hls files.\n\nDevelopers have expressed their dislike / objected to disabling hls by default as well\nas disabling hls with local files. There also where objections against restricting\nremote url file extensions. This here is a less robust but also lower\ninconvenience solution.\nIt can be applied stand alone or together with other solutions.\nlimiting the check to local files was suggested by nevcairiel\n\nThis recommits the security fix without the author name joke which was\noriginally requested by Nicolas.\n\nFound-by: Emil Lerner and Pavel Cheremushkin\nReported-by: Thierry Foucu <tfoucu@google.com>\n\nSigned-off-by: Michael Niedermayer <michael@niedermayer.cc>\n(cherry picked from commit 189ff4219644532bdfa7bab28dfedaee4d6d4021)\nSigned-off-by: Michael Niedermayer <michael@niedermayer.cc>",
        "before_after_code_files": [
          "libavformat/hls.c||libavformat/hls.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_cherry_pick": 1,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "libavformat/hls.c||libavformat/hls.c"
          ],
          "candidate": [
            "libavformat/hls.c||libavformat/hls.c"
          ]
        }
      },
      "candidate_diff": {
        "libavformat/hls.c||libavformat/hls.c": [
          "File: libavformat/hls.c -> libavformat/hls.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "164: };",
          "166: typedef struct HLSContext {",
          "167:     int n_variants;",
          "168:     struct variant **variants;",
          "169:     int n_playlists;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "167:     AVClass *class;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "179:     char *user_agent;                    ///< holds HTTP user agent set as an AVOption to the HTTP protocol context",
          "180:     char *cookies;                       ///< holds HTTP cookie values set in either the initial response or as an AVOption to the HTTP protocol context",
          "181:     char *headers;                       ///< holds HTTP headers set as an AVOption to the HTTP protocol context",
          "182: } HLSContext;",
          "184: static int read_chomp_line(AVIOContext *s, char *buf, int maxlen)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "183:     char *allowed_extensions;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "901: }",
          "905:     const char *proto_name = avio_find_protocol_name(url);",
          "907:     if (!proto_name)",
          "908:         return AVERROR_INVALIDDATA;",
          "911:         return AVERROR_INVALIDDATA;",
          "913:     if (!strncmp(proto_name, url, strlen(proto_name)) && url[strlen(proto_name)] == ':')",
          "",
          "[Removed Lines]",
          "904: static int check_url(const char *url) {",
          "910:     if (!av_strstart(proto_name, \"http\", NULL) && !av_strstart(proto_name, \"file\", NULL))",
          "",
          "[Added Lines]",
          "906: static int check_url(HLSContext *c, const char *url) {",
          "912:     if (av_strstart(proto_name, \"file\", NULL)) {",
          "913:         if (strcmp(c->allowed_extensions, \"ALL\") && !av_match_ext(url, c->allowed_extensions)) {",
          "914:             av_log(c, AV_LOG_ERROR,",
          "915:                 \"Filename extension of \\'%s\\' is not a common multimedia extension, blocked for security reasons.\\n\"",
          "916:                 \"If you wish to override this adjust allowed_extensions, you can set it to \\'ALL\\' to allow all\\n\",",
          "917:                 url);",
          "918:             return AVERROR_INVALIDDATA;",
          "919:         }",
          "920:     } else if (av_strstart(proto_name, \"http\", NULL)) {",
          "921:         ;",
          "922:     } else",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "945:            seg->url, seg->url_offset, pls->index);",
          "947:     if (seg->key_type == KEY_NONE) {",
          "949:         if (ret < 0)",
          "950:             goto cleanup;",
          "",
          "[Removed Lines]",
          "948:         ret = check_url(seg->url);",
          "",
          "[Added Lines]",
          "960:         ret = check_url(c, seg->url);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "956:         char iv[33], key[33], url[MAX_URL_SIZE];",
          "957:         if (strcmp(seg->key, pls->key_url)) {",
          "958:             URLContext *uc;",
          "960:             if (ret < 0)",
          "961:                 goto cleanup;",
          "",
          "[Removed Lines]",
          "959:             ret = check_url(seg->key);",
          "",
          "[Added Lines]",
          "971:             ret = check_url(c, seg->key);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1728:     return 0;",
          "1729: }",
          "1731: AVInputFormat ff_hls_demuxer = {",
          "1732:     .name           = \"hls,applehttp\",",
          "1733:     .long_name      = NULL_IF_CONFIG_SMALL(\"Apple HTTP Live Streaming\"),",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1743: #define OFFSET(x) offsetof(HLSContext, x)",
          "1744: #define FLAGS AV_OPT_FLAG_DECODING_PARAM",
          "1745: static const AVOption hls_options[] = {",
          "1746:     {\"allowed_extensions\", \"List of file extensions that hls is allowed to access\",",
          "1747:         OFFSET(allowed_extensions), AV_OPT_TYPE_STRING,",
          "1748:         {.str = \"3gp,aac,avi,flac,mkv,m3u8,m4a,m4s,m4v,mpg,mov,mp2,mp3,mp4,mpeg,mpegts,ogg,ogv,oga,ts,vob,wav\"},",
          "1749:         INT_MIN, INT_MAX, FLAGS},",
          "1750:     {NULL}",
          "1751: };",
          "1753: static const AVClass hls_class = {",
          "1754:     .class_name = \"hls,applehttp\",",
          "1755:     .item_name  = av_default_item_name,",
          "1756:     .option     = hls_options,",
          "1757:     .version    = LIBAVUTIL_VERSION_INT,",
          "1758: };",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "1737:     .read_packet    = hls_read_packet,",
          "1738:     .read_close     = hls_close,",
          "1739:     .read_seek      = hls_read_seek,",
          "1740: };",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1769:     .priv_class     = &hls_class,",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "bb1014279d865597c281c651c9d78dfb56ca2742",
      "candidate_info": {
        "commit_hash": "bb1014279d865597c281c651c9d78dfb56ca2742",
        "repo": "FFmpeg/FFmpeg",
        "commit_url": "https://github.com/FFmpeg/FFmpeg/commit/bb1014279d865597c281c651c9d78dfb56ca2742",
        "files": [
          "libavformat/hls.c"
        ],
        "message": "avformat/hls: Check local file extensions\n\nThis reduces the attack surface of local file-system\ninformation leaking.\n\nIt prevents the existing exploit leading to an information leak. As\nwell as similar hypothetical attacks.\n\nLeaks of information from files and symlinks ending in common multimedia extensions\nare still possible. But files with sensitive information like private keys and passwords\ngenerally do not use common multimedia filename extensions.\nIt does not stop leaks via remote addresses in the LAN.\n\nThe existing exploit depends on a specific decoder as well.\nIt does appear though that the exploit should be possible with any decoder.\nThe problem is that as long as sensitive information gets into the decoder,\nthe output of the decoder becomes sensitive as well.\nThe only obvious solution is to prevent access to sensitive information. Or to\ndisable hls or possibly some of its feature. More complex solutions like\nchecking the path to limit access to only subdirectories of the hls path may\nwork as an alternative. But such solutions are fragile and tricky to implement\nportably and would not stop every possible attack nor would they work with all\nvalid hls files.\n\nDevelopers have expressed their dislike / objected to disabling hls by default as well\nas disabling hls with local files. There also where objections against restricting\nremote url file extensions. This here is a less robust but also lower\ninconvenience solution.\nIt can be applied stand alone or together with other solutions.\nlimiting the check to local files was suggested by nevcairiel\n\nThis recommits the security fix without the author name joke which was\noriginally requested by Nicolas.\n\nFound-by: Emil Lerner and Pavel Cheremushkin\nReported-by: Thierry Foucu <tfoucu@google.com>\n\nSigned-off-by: Michael Niedermayer <michael@niedermayer.cc>\n(cherry picked from commit 189ff4219644532bdfa7bab28dfedaee4d6d4021)\nSigned-off-by: Michael Niedermayer <michael@niedermayer.cc>",
        "before_after_code_files": [
          "libavformat/hls.c||libavformat/hls.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_cherry_pick": 1,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "libavformat/hls.c||libavformat/hls.c"
          ],
          "candidate": [
            "libavformat/hls.c||libavformat/hls.c"
          ]
        }
      },
      "candidate_diff": {
        "libavformat/hls.c||libavformat/hls.c": [
          "File: libavformat/hls.c -> libavformat/hls.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "200:     char *http_proxy;                    ///< holds the address of the HTTP proxy server",
          "201:     AVDictionary *avio_opts;",
          "202:     int strict_std_compliance;",
          "203: } HLSContext;",
          "205: static int read_chomp_line(AVIOContext *s, char *buf, int maxlen)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "203:     char *allowed_extensions;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "625:         return AVERROR_INVALIDDATA;",
          "629:         return AVERROR_INVALIDDATA;",
          "630:     if (!strncmp(proto_name, url, strlen(proto_name)) && url[strlen(proto_name)] == ':')",
          "631:         ;",
          "632:     else if (strcmp(proto_name, \"file\") || !strncmp(url, \"file,\", 5))",
          "",
          "[Removed Lines]",
          "628:     if (!av_strstart(proto_name, \"http\", NULL) && !av_strstart(proto_name, \"file\", NULL))",
          "",
          "[Added Lines]",
          "629:     if (av_strstart(proto_name, \"file\", NULL)) {",
          "630:         if (strcmp(c->allowed_extensions, \"ALL\") && !av_match_ext(url, c->allowed_extensions)) {",
          "631:             av_log(c, AV_LOG_ERROR,",
          "632:                 \"Filename extension of \\'%s\\' is not a common multimedia extension, blocked for security reasons.\\n\"",
          "633:                 \"If you wish to override this adjust allowed_extensions, you can set it to \\'ALL\\' to allow all\\n\",",
          "634:                 url);",
          "635:             return AVERROR_INVALIDDATA;",
          "636:         }",
          "637:     } else if (av_strstart(proto_name, \"http\", NULL)) {",
          "638:         ;",
          "639:     } else",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "2005: static const AVOption hls_options[] = {",
          "2006:     {\"live_start_index\", \"segment index to start live streams at (negative values are from the end)\",",
          "2007:         OFFSET(live_start_index), AV_OPT_TYPE_INT, {.i64 = -3}, INT_MIN, INT_MAX, FLAGS},",
          "2008:     {NULL}",
          "2009: };",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2020:     {\"allowed_extensions\", \"List of file extensions that hls is allowed to access\",",
          "2021:         OFFSET(allowed_extensions), AV_OPT_TYPE_STRING,",
          "2022:         {.str = \"3gp,aac,avi,flac,mkv,m3u8,m4a,m4s,m4v,mpg,mov,mp2,mp3,mp4,mpeg,mpegts,ogg,ogv,oga,ts,vob,wav\"},",
          "2023:         INT_MIN, INT_MAX, FLAGS},",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "e447d3143faab23da9cbe3a7dbf4adec100f938a",
      "candidate_info": {
        "commit_hash": "e447d3143faab23da9cbe3a7dbf4adec100f938a",
        "repo": "FFmpeg/FFmpeg",
        "commit_url": "https://github.com/FFmpeg/FFmpeg/commit/e447d3143faab23da9cbe3a7dbf4adec100f938a",
        "files": [
          "libavformat/hls.c"
        ],
        "message": "avformat/hls: Check local file extensions\n\nThis reduces the attack surface of local file-system\ninformation leaking.\n\nIt prevents the existing exploit leading to an information leak. As\nwell as similar hypothetical attacks.\n\nLeaks of information from files and symlinks ending in common multimedia extensions\nare still possible. But files with sensitive information like private keys and passwords\ngenerally do not use common multimedia filename extensions.\nIt does not stop leaks via remote addresses in the LAN.\n\nThe existing exploit depends on a specific decoder as well.\nIt does appear though that the exploit should be possible with any decoder.\nThe problem is that as long as sensitive information gets into the decoder,\nthe output of the decoder becomes sensitive as well.\nThe only obvious solution is to prevent access to sensitive information. Or to\ndisable hls or possibly some of its feature. More complex solutions like\nchecking the path to limit access to only subdirectories of the hls path may\nwork as an alternative. But such solutions are fragile and tricky to implement\nportably and would not stop every possible attack nor would they work with all\nvalid hls files.\n\nDevelopers have expressed their dislike / objected to disabling hls by default as well\nas disabling hls with local files. There also where objections against restricting\nremote url file extensions. This here is a less robust but also lower\ninconvenience solution.\nIt can be applied stand alone or together with other solutions.\nlimiting the check to local files was suggested by nevcairiel\n\nThis recommits the security fix without the author name joke which was\noriginally requested by Nicolas.\n\nFound-by: Emil Lerner and Pavel Cheremushkin\nReported-by: Thierry Foucu <tfoucu@google.com>\n\nSigned-off-by: Michael Niedermayer <michael@niedermayer.cc>\n(cherry picked from commit 189ff4219644532bdfa7bab28dfedaee4d6d4021)\nSigned-off-by: Michael Niedermayer <michael@niedermayer.cc>",
        "before_after_code_files": [
          "libavformat/hls.c||libavformat/hls.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_cherry_pick": 1,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "libavformat/hls.c||libavformat/hls.c"
          ],
          "candidate": [
            "libavformat/hls.c||libavformat/hls.c"
          ]
        }
      },
      "candidate_diff": {
        "libavformat/hls.c||libavformat/hls.c": [
          "File: libavformat/hls.c -> libavformat/hls.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "197:     char *cookies;                       ///< holds HTTP cookie values set in either the initial response or as an AVOption to the HTTP protocol context",
          "198:     char *headers;                       ///< holds HTTP headers set as an AVOption to the HTTP protocol context",
          "199:     AVDictionary *avio_opts;",
          "200: } HLSContext;",
          "202: static int read_chomp_line(AVIOContext *s, char *buf, int maxlen)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "200:     char *allowed_extensions;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "624:         return AVERROR_INVALIDDATA;",
          "628:         return AVERROR_INVALIDDATA;",
          "629:     if (!strncmp(proto_name, url, strlen(proto_name)) && url[strlen(proto_name)] == ':')",
          "630:         ;",
          "631:     else if (strcmp(proto_name, \"file\") || !strncmp(url, \"file,\", 5))",
          "",
          "[Removed Lines]",
          "627:     if (!av_strstart(proto_name, \"http\", NULL) && !av_strstart(proto_name, \"file\", NULL))",
          "",
          "[Added Lines]",
          "628:     if (av_strstart(proto_name, \"file\", NULL)) {",
          "629:         if (strcmp(c->allowed_extensions, \"ALL\") && !av_match_ext(url, c->allowed_extensions)) {",
          "630:             av_log(c, AV_LOG_ERROR,",
          "631:                 \"Filename extension of \\'%s\\' is not a common multimedia extension, blocked for security reasons.\\n\"",
          "632:                 \"If you wish to override this adjust allowed_extensions, you can set it to \\'ALL\\' to allow all\\n\",",
          "633:                 url);",
          "634:             return AVERROR_INVALIDDATA;",
          "635:         }",
          "636:     } else if (av_strstart(proto_name, \"http\", NULL)) {",
          "637:         ;",
          "638:     } else",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1995: static const AVOption hls_options[] = {",
          "1996:     {\"live_start_index\", \"segment index to start live streams at (negative values are from the end)\",",
          "1997:         OFFSET(live_start_index), AV_OPT_TYPE_INT, {.i64 = -3}, INT_MIN, INT_MAX, FLAGS},",
          "1998:     {NULL}",
          "1999: };",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2010:     {\"allowed_extensions\", \"List of file extensions that hls is allowed to access\",",
          "2011:         OFFSET(allowed_extensions), AV_OPT_TYPE_STRING,",
          "2012:         {.str = \"3gp,aac,avi,flac,mkv,m3u8,m4a,m4s,m4v,mpg,mov,mp2,mp3,mp4,mpeg,mpegts,ogg,ogv,oga,ts,vob,wav\"},",
          "2013:         INT_MIN, INT_MAX, FLAGS},",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "25dac3128b605f2867e3e0f0288b896f84d3a033",
      "candidate_info": {
        "commit_hash": "25dac3128b605f2867e3e0f0288b896f84d3a033",
        "repo": "FFmpeg/FFmpeg",
        "commit_url": "https://github.com/FFmpeg/FFmpeg/commit/25dac3128b605f2867e3e0f0288b896f84d3a033",
        "files": [
          "libavformat/hls.c"
        ],
        "message": "avformat/hls: Check local file extensions\n\nThis reduces the attack surface of local file-system\ninformation leaking.\n\nIt prevents the existing exploit leading to an information leak. As\nwell as similar hypothetical attacks.\n\nLeaks of information from files and symlinks ending in common multimedia extensions\nare still possible. But files with sensitive information like private keys and passwords\ngenerally do not use common multimedia filename extensions.\nIt does not stop leaks via remote addresses in the LAN.\n\nThe existing exploit depends on a specific decoder as well.\nIt does appear though that the exploit should be possible with any decoder.\nThe problem is that as long as sensitive information gets into the decoder,\nthe output of the decoder becomes sensitive as well.\nThe only obvious solution is to prevent access to sensitive information. Or to\ndisable hls or possibly some of its feature. More complex solutions like\nchecking the path to limit access to only subdirectories of the hls path may\nwork as an alternative. But such solutions are fragile and tricky to implement\nportably and would not stop every possible attack nor would they work with all\nvalid hls files.\n\nDevelopers have expressed their dislike / objected to disabling hls by default as well\nas disabling hls with local files. There also where objections against restricting\nremote url file extensions. This here is a less robust but also lower\ninconvenience solution.\nIt can be applied stand alone or together with other solutions.\nlimiting the check to local files was suggested by nevcairiel\n\nThis recommits the security fix without the author name joke which was\noriginally requested by Nicolas.\n\nFound-by: Emil Lerner and Pavel Cheremushkin\nReported-by: Thierry Foucu <tfoucu@google.com>\n\nSigned-off-by: Michael Niedermayer <michael@niedermayer.cc>\n(cherry picked from commit 189ff4219644532bdfa7bab28dfedaee4d6d4021)\nSigned-off-by: Michael Niedermayer <michael@niedermayer.cc>",
        "before_after_code_files": [
          "libavformat/hls.c||libavformat/hls.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_cherry_pick": 1,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "libavformat/hls.c||libavformat/hls.c"
          ],
          "candidate": [
            "libavformat/hls.c||libavformat/hls.c"
          ]
        }
      },
      "candidate_diff": {
        "libavformat/hls.c||libavformat/hls.c": [
          "File: libavformat/hls.c -> libavformat/hls.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "204:     char *http_proxy;                    ///< holds the address of the HTTP proxy server",
          "205:     AVDictionary *avio_opts;",
          "206:     int strict_std_compliance;",
          "207: } HLSContext;",
          "209: static int read_chomp_line(AVIOContext *s, char *buf, int maxlen)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "207:     char *allowed_extensions;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "618:         return AVERROR_INVALIDDATA;",
          "622:         return AVERROR_INVALIDDATA;",
          "623:     if (!strncmp(proto_name, url, strlen(proto_name)) && url[strlen(proto_name)] == ':')",
          "624:         ;",
          "625:     else if (av_strstart(url, \"crypto\", NULL) && !strncmp(proto_name, url + 7, strlen(proto_name)) && url[7 + strlen(proto_name)] == ':')",
          "",
          "[Removed Lines]",
          "621:     if (!av_strstart(proto_name, \"http\", NULL) && !av_strstart(proto_name, \"file\", NULL))",
          "",
          "[Added Lines]",
          "622:     if (av_strstart(proto_name, \"file\", NULL)) {",
          "623:         if (strcmp(c->allowed_extensions, \"ALL\") && !av_match_ext(url, c->allowed_extensions)) {",
          "624:             av_log(s, AV_LOG_ERROR,",
          "625:                 \"Filename extension of \\'%s\\' is not a common multimedia extension, blocked for security reasons.\\n\"",
          "626:                 \"If you wish to override this adjust allowed_extensions, you can set it to \\'ALL\\' to allow all\\n\",",
          "627:                 url);",
          "628:             return AVERROR_INVALIDDATA;",
          "629:         }",
          "630:     } else if (av_strstart(proto_name, \"http\", NULL)) {",
          "631:         ;",
          "632:     } else",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "2127: static const AVOption hls_options[] = {",
          "2128:     {\"live_start_index\", \"segment index to start live streams at (negative values are from the end)\",",
          "2129:         OFFSET(live_start_index), AV_OPT_TYPE_INT, {.i64 = -3}, INT_MIN, INT_MAX, FLAGS},",
          "2130:     {NULL}",
          "2131: };",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2142:     {\"allowed_extensions\", \"List of file extensions that hls is allowed to access\",",
          "2143:         OFFSET(allowed_extensions), AV_OPT_TYPE_STRING,",
          "2144:         {.str = \"3gp,aac,avi,flac,mkv,m3u8,m4a,m4s,m4v,mpg,mov,mp2,mp3,mp4,mpeg,mpegts,ogg,ogv,oga,ts,vob,wav\"},",
          "2145:         INT_MIN, INT_MAX, FLAGS},",
          "",
          "---------------"
        ]
      }
    }
  ]
}
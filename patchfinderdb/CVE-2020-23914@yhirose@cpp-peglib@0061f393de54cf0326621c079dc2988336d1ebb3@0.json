{
  "cve_id": "CVE-2020-23914",
  "cve_desc": "An issue was discovered in cpp-peglib through v0.1.12. A NULL pointer dereference exists in the peg::AstOptimizer::optimize() located in peglib.h. It allows an attacker to cause Denial of Service.",
  "repo": "yhirose/cpp-peglib",
  "patch_hash": "0061f393de54cf0326621c079dc2988336d1ebb3",
  "patch_info": {
    "commit_hash": "0061f393de54cf0326621c079dc2988336d1ebb3",
    "repo": "yhirose/cpp-peglib",
    "commit_url": "https://github.com/yhirose/cpp-peglib/commit/0061f393de54cf0326621c079dc2988336d1ebb3",
    "files": [
      "peglib.h",
      "test/test1.cc"
    ],
    "message": "Fix #121",
    "before_after_code_files": [
      "peglib.h||peglib.h",
      "test/test1.cc||test/test1.cc"
    ]
  },
  "patch_diff": {
    "peglib.h||peglib.h": [
      "File: peglib.h -> peglib.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "1239:                       public std::enable_shared_from_this<LiteralString> {",
      "1240: public:",
      "1241:   LiteralString(std::string &&s, bool ignore_case)",
      "1245:   LiteralString(const std::string &s, bool ignore_case)",
      "1249:   size_t parse_core(const char *s, size_t n, SemanticValues &sv, Context &c,",
      "1250:                     any &dt) const override;",
      "",
      "[Removed Lines]",
      "1242:       : lit_(s), ignore_case_(ignore_case),",
      "1243:         is_word_(false) {}",
      "1246:       : lit_(s), ignore_case_(ignore_case),",
      "1247:         is_word_(false) {}",
      "",
      "[Added Lines]",
      "1242:       : lit_(s), ignore_case_(ignore_case), is_word_(false) {}",
      "1245:       : lit_(s), ignore_case_(ignore_case), is_word_(false) {}",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "3438:       }",
      "3439:     }",
      "3442:     for (auto &x : grammar) {",
      "3443:       auto &rule = x.second;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "3440:     {",
      "3441:       auto &rule = grammar[data.start];",
      "3442:       if (rule.ignoreSemanticValue) {",
      "3443:         if (log) {",
      "3444:           auto line = line_info(s, rule.s_);",
      "3445:           log(line.first, line.second,",
      "3446:               \"Ignore operator cannot be applied to '\" + rule.name + \"'.\");",
      "3447:         }",
      "3448:         ret = false;",
      "3449:       }",
      "3450:     }",
      "3452:     if (!ret) { return nullptr; }",
      "",
      "---------------"
    ],
    "test/test1.cc||test/test1.cc": [
      "File: test/test1.cc -> test/test1.cc",
      "--- Hunk 1 ---",
      "[Context before]",
      "34:     REQUIRE(ret == false);",
      "35: }",
      "37: TEST_CASE(\"Backslash escape sequence test\", \"[general]\")",
      "38: {",
      "39:     parser parser(R\"(",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "37: TEST_CASE(\"Start rule with ignore operator test\", \"[general]\")",
      "38: {",
      "39:     parser parser(R\"(",
      "40:         ~ROOT <- _",
      "41:         _ <- ' '",
      "42:     )\");",
      "44:     bool ret = parser;",
      "45:     REQUIRE(ret == false);",
      "46: }",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "10cc75d5033a82c9c0e8f983558aee5fefca19ab",
      "candidate_info": {
        "commit_hash": "10cc75d5033a82c9c0e8f983558aee5fefca19ab",
        "repo": "yhirose/cpp-peglib",
        "commit_url": "https://github.com/yhirose/cpp-peglib/commit/10cc75d5033a82c9c0e8f983558aee5fefca19ab",
        "files": [
          "peglib.h"
        ],
        "message": "Performance improvement. Close #82",
        "before_after_code_files": [
          "peglib.h||peglib.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "peglib.h||peglib.h"
          ],
          "candidate": [
            "peglib.h||peglib.h"
          ]
        }
      },
      "candidate_diff": {
        "peglib.h||peglib.h": [
          "File: peglib.h -> peglib.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "928:       auto &sv = *value_stack[value_stack_size];",
          "929:       if (!sv.empty()) {",
          "930:         sv.clear();",
          "932:       }",
          "933:       sv.s_ = nullptr;",
          "934:       sv.n_ = 0;",
          "935:       sv.choice_count_ = 0;",
          "936:       sv.choice_ = 0;",
          "938:     }",
          "940:     auto &sv = *value_stack[value_stack_size++];",
          "",
          "[Removed Lines]",
          "931:         sv.tags.clear();",
          "937:       sv.tokens.clear();",
          "",
          "[Added Lines]",
          "931:         if (!sv.tags.empty()) { sv.tags.clear(); }",
          "937:       if (!sv.tokens.empty()) { sv.tokens.clear(); }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "962:       capture_scope_stack.emplace_back(std::map<std::string, std::string>());",
          "963:     } else {",
          "964:       auto &cs = capture_scope_stack[capture_scope_stack_size];",
          "966:     }",
          "967:     capture_scope_stack_size++;",
          "968:   }",
          "",
          "[Removed Lines]",
          "965:       cs.clear();",
          "",
          "[Added Lines]",
          "965:       if (!cs.empty()) { cs.clear(); }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1070:         c.pop();",
          "1071:         c.pop_capture_scope();",
          "1072:       });",
          "1075:       if (success(len)) {",
          "1076:         if (!chldsv.empty()) {",
          "1077:           for (size_t i = 0; i < chldsv.size(); i++) {",
          "",
          "[Removed Lines]",
          "1073:       const auto &rule = *ope;",
          "1074:       auto len = rule.parse(s, n, chldsv, c, dt);",
          "",
          "[Added Lines]",
          "1073:       auto len = ope->parse(s, n, chldsv, c, dt);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1224:       c.pop();",
          "1225:       c.pop_capture_scope();",
          "1226:     });",
          "1229:     if (success(len)) {",
          "1230:       c.set_error_pos(s);",
          "1231:       return static_cast<size_t>(-1);",
          "",
          "[Removed Lines]",
          "1227:     const auto &rule = *ope_;",
          "1228:     auto len = rule.parse(s, n, chldsv, c, dt);",
          "",
          "[Added Lines]",
          "1226:     auto len = ope_->parse(s, n, chldsv, c, dt);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1255: class LiteralString : public Ope,",
          "1256:                       public std::enable_shared_from_this<LiteralString> {",
          "1257: public:",
          "1259:       : lit_(s), ignore_case_(ignore_case), init_is_word_(false),",
          "1260:         is_word_(false) {}",
          "",
          "[Removed Lines]",
          "1258:   LiteralString(const std::string &s, bool ignore_case)",
          "",
          "[Added Lines]",
          "1256:   LiteralString(std::string &&s, bool ignore_case)",
          "1257:       : lit_(s), ignore_case_(ignore_case), init_is_word_(false),",
          "1258:         is_word_(false) {}",
          "1260:   LiteralString(const std::string& s, bool ignore_case)",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1614:   return std::make_shared<Dictionary>(v);",
          "1615: }",
          "1618:   return std::make_shared<LiteralString>(s, false);",
          "1619: }",
          "1622:   return std::make_shared<LiteralString>(s, true);",
          "1623: }",
          "",
          "[Removed Lines]",
          "1617: inline std::shared_ptr<Ope> lit(const std::string &s) {",
          "1621: inline std::shared_ptr<Ope> liti(const std::string &s) {",
          "",
          "[Added Lines]",
          "1619: inline std::shared_ptr<Ope> lit(std::string &&s) {",
          "1623: inline std::shared_ptr<Ope> liti(std::string &&s) {",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "2378:   }",
          "2380:   if (is_word) {",
          "2383:     if (fail(len)) { return static_cast<size_t>(-1); }",
          "2384:     i += len;",
          "2385:   }",
          "",
          "[Removed Lines]",
          "2381:     auto ope = std::make_shared<NotPredicate>(c.wordOpe);",
          "2382:     auto len = ope->parse(s + i, n - i, dummy_sv, dummy_c, dummy_dt);",
          "",
          "[Added Lines]",
          "2383:     NotPredicate ope(c.wordOpe);",
          "2384:     auto len = ope.parse(s + i, n - i, dummy_sv, dummy_c, dummy_dt);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "2452:                                         any &dt) const {",
          "2453:   c.in_token = true;",
          "2454:   auto se = make_scope_exit([&]() { c.in_token = false; });",
          "2457:   if (success(len)) {",
          "2460:     if (c.whitespaceOpe) {",
          "2461:       auto l = c.whitespaceOpe->parse(s + len, n - len, sv, c, dt);",
          "",
          "[Removed Lines]",
          "2455:   const auto &rule = *ope_;",
          "2456:   auto len = rule.parse(s, n, sv, c, dt);",
          "2458:     sv.tokens.push_back(std::make_pair(s, len));",
          "",
          "[Added Lines]",
          "2457:   auto len = ope_->parse(s, n, sv, c, dt);",
          "2459:     sv.tokens.emplace_back(std::make_pair(s, len));",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "2520:   if (success(len)) {",
          "2521:     if (!outer_->ignoreSemanticValue) {",
          "2523:       sv.tags.emplace_back(str2tag(outer_->name.c_str()));",
          "2524:     }",
          "2525:   } else {",
          "",
          "[Removed Lines]",
          "2522:       sv.emplace_back(val);",
          "",
          "[Added Lines]",
          "2523:       sv.emplace_back(std::move(val));",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "2561:       std::vector<std::shared_ptr<Ope>> args;",
          "2562:       for (auto arg : args_) {",
          "2563:         arg->accept(vis);",
          "2565:       }",
          "2567:       c.push_args(std::move(args));",
          "",
          "[Removed Lines]",
          "2564:         args.push_back(vis.found_ope);",
          "",
          "[Added Lines]",
          "2565:         args.emplace_back(std::move(vis.found_ope));",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "b26e2477ffe34deb37b92e9fc609a3a16cd55ec1",
      "candidate_info": {
        "commit_hash": "b26e2477ffe34deb37b92e9fc609a3a16cd55ec1",
        "repo": "yhirose/cpp-peglib",
        "commit_url": "https://github.com/yhirose/cpp-peglib/commit/b26e2477ffe34deb37b92e9fc609a3a16cd55ec1",
        "files": [
          ".github/workflows/cmake.yml",
          ".travis.yml",
          "CMakeLists.txt",
          "README.md",
          "appveyor.yml",
          "docs/build.sh",
          "docs/native.js",
          "docs/native.wasm",
          "example/CMakeLists.txt",
          "example/calc.cc",
          "example/calc2.cc",
          "example/calc3.cc",
          "example/calc4.cc",
          "example/calc5.cc",
          "lint/CMakeLists.txt",
          "lint/peglint.cc",
          "peglib.h",
          "pl0/CMakeLists.txt",
          "pl0/pl0.cc",
          "test/CMakeLists.txt",
          "test/test1.cc",
          "test/test2.cc"
        ],
        "message": "C++17 support",
        "before_after_code_files": [
          "example/calc.cc||example/calc.cc",
          "example/calc2.cc||example/calc2.cc",
          "example/calc3.cc||example/calc3.cc",
          "example/calc4.cc||example/calc4.cc",
          "example/calc5.cc||example/calc5.cc",
          "lint/peglint.cc||lint/peglint.cc",
          "peglib.h||peglib.h",
          "pl0/pl0.cc||pl0/pl0.cc",
          "test/test1.cc||test/test1.cc",
          "test/test2.cc||test/test2.cc"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "peglib.h||peglib.h",
            "test/test1.cc||test/test1.cc"
          ],
          "candidate": [
            "peglib.h||peglib.h",
            "test/test1.cc||test/test1.cc"
          ]
        }
      },
      "candidate_diff": {
        "example/calc.cc||example/calc.cc": [
          "File: example/calc.cc -> example/calc.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "2: #include <assert.h>",
          "3: #include <iostream>",
          "5: using namespace peg;",
          "6: using namespace std;",
          "8: int main(void) {",
          "11:         # Grammar for Calculator...",
          "12:         Additive    <- Multitive '+' Additive / Multitive",
          "13:         Multitive   <- Primary '*' Multitive / Primary",
          "",
          "[Removed Lines]",
          "1: #include <peglib.h>",
          "10:     parser parser(R\"(",
          "",
          "[Added Lines]",
          "3: #include <peglib.h>",
          "10:   parser parser(R\"(",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "16:         %whitespace <- [ \\t]*",
          "17:     )\");",
          "51: }",
          "",
          "[Removed Lines]",
          "19:     assert(static_cast<bool>(parser) == true);",
          "22:     parser[\"Additive\"] = [](const SemanticValues& sv) {",
          "23:         switch (sv.choice()) {",
          "24:         case 0:  // \"Multitive '+' Additive\"",
          "25:             return any_cast<int>(sv[0]) + any_cast<int>(sv[1]);",
          "26:         default: // \"Multitive\"",
          "27:             return any_cast<int>(sv[0]);",
          "28:         }",
          "29:     };",
          "31:     parser[\"Multitive\"] = [](const SemanticValues& sv) {",
          "32:         switch (sv.choice()) {",
          "33:         case 0:  // \"Primary '*' Multitive\"",
          "34:             return any_cast<int>(sv[0]) * any_cast<int>(sv[1]);",
          "35:         default: // \"Primary\"",
          "36:             return any_cast<int>(sv[0]);",
          "37:         }",
          "38:     };",
          "40:     parser[\"Number\"] = [](const SemanticValues& sv) {",
          "41:         return stoi(sv.token(), nullptr, 10);",
          "42:     };",
          "45:     parser.enable_packrat_parsing(); // Enable packrat parsing.",
          "47:     int val;",
          "48:     parser.parse(\" (1 + 2) * 3 \", val);",
          "50:     assert(val == 9);",
          "",
          "[Added Lines]",
          "19:   assert(static_cast<bool>(parser) == true);",
          "22:   parser[\"Additive\"] = [](const SemanticValues &vs) {",
          "23:     switch (vs.choice()) {",
          "24:     case 0: // \"Multitive '+' Additive\"",
          "25:       return any_cast<int>(vs[0]) + any_cast<int>(vs[1]);",
          "26:     default: // \"Multitive\"",
          "27:       return any_cast<int>(vs[0]);",
          "28:     }",
          "29:   };",
          "31:   parser[\"Multitive\"] = [](const SemanticValues &vs) {",
          "32:     switch (vs.choice()) {",
          "33:     case 0: // \"Primary '*' Multitive\"",
          "34:       return any_cast<int>(vs[0]) * any_cast<int>(vs[1]);",
          "35:     default: // \"Primary\"",
          "36:       return any_cast<int>(vs[0]);",
          "37:     }",
          "38:   };",
          "40:   parser[\"Number\"] = [](const SemanticValues &vs) {",
          "41:     return vs.token_to_number<int>();",
          "42:   };",
          "45:   parser.enable_packrat_parsing(); // Enable packrat parsing.",
          "47:   int val;",
          "48:   parser.parse(\" (1 + 2) * 3 \", val);",
          "50:   assert(val == 9);",
          "",
          "---------------"
        ],
        "example/calc2.cc||example/calc2.cc": [
          "File: example/calc2.cc -> example/calc2.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "10: #include <cstdlib>",
          "12: using namespace peg;",
          "",
          "[Removed Lines]",
          "8: #include <peglib.h>",
          "9: #include <iostream>",
          "",
          "[Added Lines]",
          "9: #include <iostream>",
          "10: #include <peglib.h>",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "63: }",
          "",
          "[Removed Lines]",
          "24: int main(int argc, const char** argv)",
          "25: {",
          "26:     if (argc < 2 || std::string(\"--help\") == argv[1]) {",
          "27:         std::cout << \"usage: calc [formula]\" << std::endl;",
          "28:         return 1;",
          "29:     }",
          "31:     auto reduce = [](const SemanticValues& sv) -> long {",
          "32:         auto result = any_cast<long>(sv[0]);",
          "33:         for (auto i = 1u; i < sv.size(); i += 2) {",
          "34:             auto num = any_cast<long>(sv[i + 1]);",
          "35:             auto ope = any_cast<char>(sv[i]);",
          "36:             switch (ope) {",
          "37:                 case '+': result += num; break;",
          "38:                 case '-': result -= num; break;",
          "39:                 case '*': result *= num; break;",
          "40:                 case '/': result /= num; break;",
          "41:             }",
          "42:         }",
          "43:         return result;",
          "44:     };",
          "46:     Definition EXPRESSION, TERM, FACTOR, TERM_OPERATOR, FACTOR_OPERATOR, NUMBER;",
          "48:     EXPRESSION      <= seq(TERM, zom(seq(TERM_OPERATOR, TERM))),         reduce;",
          "49:     TERM            <= seq(FACTOR, zom(seq(FACTOR_OPERATOR, FACTOR))),   reduce;",
          "50:     FACTOR          <= cho(NUMBER, seq(chr('('), EXPRESSION, chr(')')));",
          "51:     TERM_OPERATOR   <= cls(\"+-\"),                                        [](const SemanticValues& sv) { return static_cast<char>(*sv.c_str()); };",
          "52:     FACTOR_OPERATOR <= cls(\"*/\"),                                        [](const SemanticValues& sv) { return static_cast<char>(*sv.c_str()); };",
          "53:     NUMBER          <= oom(cls(\"0-9\")),                                  [](const SemanticValues& sv) { return atol(sv.c_str()); };",
          "55:     auto expr = argv[1];",
          "56:     long val = 0;",
          "57:     if (EXPRESSION.parse_and_get_value(expr, val).ret) {",
          "58:         std::cout << expr << \" = \" << val << std::endl;",
          "59:         return 0;",
          "60:     }",
          "62:     return -1;",
          "",
          "[Added Lines]",
          "24: int main(int argc, const char **argv) {",
          "25:   if (argc < 2 || std::string(\"--help\") == argv[1]) {",
          "26:     std::cout << \"usage: calc [formula]\" << std::endl;",
          "27:     return 1;",
          "28:   }",
          "30:   auto reduce = [](const SemanticValues &vs) {",
          "31:     auto result = std::any_cast<long>(vs[0]);",
          "32:     for (auto i = 1u; i < vs.size(); i += 2) {",
          "33:       auto num = std::any_cast<long>(vs[i + 1]);",
          "34:       auto ope = std::any_cast<char>(vs[i]);",
          "35:       switch (ope) {",
          "36:       case '+': result += num; break;",
          "37:       case '-': result -= num; break;",
          "38:       case '*': result *= num; break;",
          "39:       case '/': result /= num; break;",
          "40:       }",
          "41:     }",
          "42:     return result;",
          "43:   };",
          "45:   Definition EXPRESSION, TERM, FACTOR, TERM_OPERATOR, FACTOR_OPERATOR, NUMBER;",
          "47:   EXPRESSION <= seq(TERM, zom(seq(TERM_OPERATOR, TERM))), reduce;",
          "48:   TERM <= seq(FACTOR, zom(seq(FACTOR_OPERATOR, FACTOR))), reduce;",
          "49:   FACTOR <= cho(NUMBER, seq(chr('('), EXPRESSION, chr(')')));",
          "50:   TERM_OPERATOR <= cls(\"+-\"),",
          "51:       [](const SemanticValues &vs) { return static_cast<char>(*vs.sv().data()); };",
          "52:   FACTOR_OPERATOR <= cls(\"*/\"),",
          "53:       [](const SemanticValues &vs) { return static_cast<char>(*vs.sv().data()); };",
          "54:   NUMBER <= oom(cls(\"0-9\")),",
          "55:       [](const SemanticValues &vs) { return vs.token_to_number<long>(); };",
          "57:   auto expr = argv[1];",
          "58:   long val = 0;",
          "59:   if (EXPRESSION.parse_and_get_value(expr, val).ret) {",
          "60:     std::cout << expr << \" = \" << val << std::endl;",
          "61:     return 0;",
          "62:   }",
          "64:   return -1;",
          "",
          "---------------"
        ],
        "example/calc3.cc||example/calc3.cc": [
          "File: example/calc3.cc -> example/calc3.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "10: #include <cstdlib>",
          "12: using namespace peg;",
          "38:         }",
          "42:         EXPRESSION       <-  TERM (TERM_OPERATOR TERM)*",
          "43:         TERM             <-  FACTOR (FACTOR_OPERATOR FACTOR)*",
          "44:         FACTOR           <-  NUMBER / '(' EXPRESSION ')'",
          "",
          "[Removed Lines]",
          "8: #include <peglib.h>",
          "9: #include <iostream>",
          "14: int main(int argc, const char** argv)",
          "15: {",
          "16:     if (argc < 2 || std::string(\"--help\") == argv[1]) {",
          "17:         std::cout << \"usage: calc3 [formula]\" << std::endl;",
          "18:         return 1;",
          "19:     }",
          "21:     std::function<long (const Ast&)> eval = [&](const Ast& ast) {",
          "22:         if (ast.name == \"NUMBER\") {",
          "23:             return stol(ast.token);",
          "24:         } else {",
          "25:             const auto& nodes = ast.nodes;",
          "26:             auto result = eval(*nodes[0]);",
          "27:             for (auto i = 1u; i < nodes.size(); i += 2) {",
          "28:                 auto num = eval(*nodes[i + 1]);",
          "29:                 auto ope = nodes[i]->token[0];",
          "30:                 switch (ope) {",
          "31:                     case '+': result += num; break;",
          "32:                     case '-': result -= num; break;",
          "33:                     case '*': result *= num; break;",
          "34:                     case '/': result /= num; break;",
          "35:                 }",
          "36:             }",
          "37:             return result;",
          "39:     };",
          "41:     parser parser(R\"(",
          "",
          "[Added Lines]",
          "9: #include <iostream>",
          "10: #include <peglib.h>",
          "14: int main(int argc, const char **argv) {",
          "15:   if (argc < 2 || std::string(\"--help\") == argv[1]) {",
          "16:     std::cout << \"usage: calc3 [formula]\" << std::endl;",
          "17:     return 1;",
          "18:   }",
          "20:   std::function<long(const Ast &)> eval = [&](const Ast &ast) {",
          "21:     if (ast.name == \"NUMBER\") {",
          "22:       return ast.token_to_number<long>();",
          "23:     } else {",
          "24:       const auto &nodes = ast.nodes;",
          "25:       auto result = eval(*nodes[0]);",
          "26:       for (auto i = 1u; i < nodes.size(); i += 2) {",
          "27:         auto num = eval(*nodes[i + 1]);",
          "28:         auto ope = nodes[i]->token[0];",
          "29:         switch (ope) {",
          "30:         case '+': result += num; break;",
          "31:         case '-': result -= num; break;",
          "32:         case '*': result *= num; break;",
          "33:         case '/': result /= num; break;",
          "35:       }",
          "36:       return result;",
          "37:     }",
          "38:   };",
          "40:   parser parser(R\"(",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "50:         %whitespace      <-  [ \\t\\r\\n]*",
          "51:     )\");",
          "67: }",
          "",
          "[Removed Lines]",
          "53:     parser.enable_ast();",
          "55:     auto expr = argv[1];",
          "56:     std::shared_ptr<Ast> ast;",
          "57:     if (parser.parse(expr, ast)) {",
          "58:         ast = AstOptimizer(true).optimize(ast);",
          "59:         std::cout << ast_to_s(ast);",
          "60:         std::cout << expr << \" = \" << eval(*ast) << std::endl;",
          "61:         return 0;",
          "62:     }",
          "64:     std::cout << \"syntax error...\" << std::endl;",
          "66:     return -1;",
          "",
          "[Added Lines]",
          "52:   parser.enable_ast();",
          "54:   auto expr = argv[1];",
          "55:   std::shared_ptr<Ast> ast;",
          "56:   if (parser.parse(expr, ast)) {",
          "57:     ast = AstOptimizer(true).optimize(ast);",
          "58:     std::cout << ast_to_s(ast);",
          "59:     std::cout << expr << \" = \" << eval(*ast) << std::endl;",
          "60:     return 0;",
          "61:   }",
          "63:   std::cout << \"syntax error...\" << std::endl;",
          "65:   return -1;",
          "",
          "---------------"
        ],
        "example/calc4.cc||example/calc4.cc": [
          "File: example/calc4.cc -> example/calc4.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "2: #include <assert.h>",
          "3: #include <iostream>",
          "5: using namespace peg;",
          "6: using namespace std;",
          "8: int main(void) {",
          "10:         EXPRESSION  <- ATOM (OPERATOR ATOM)* {",
          "11:                          precedence",
          "12:                            L - +",
          "",
          "[Removed Lines]",
          "1: #include <peglib.h>",
          "9:     parser parser(R\"(",
          "",
          "[Added Lines]",
          "3: #include <peglib.h>",
          "9:   parser parser(R\"(",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "18:         %whitespace <- [ \\t\\r\\n]*",
          "19:     )\");",
          "42: }",
          "",
          "[Removed Lines]",
          "21:     parser[\"EXPRESSION\"] = [](const SemanticValues& sv) -> long {",
          "22:         auto result = any_cast<long>(sv[0]);",
          "23:         if (sv.size() > 1) {",
          "24:             auto ope = any_cast<char>(sv[1]);",
          "25:             auto num = any_cast<long>(sv[2]);",
          "26:             switch (ope) {",
          "27:                 case '+': result += num; break;",
          "28:                 case '-': result -= num; break;",
          "29:                 case '*': result *= num; break;",
          "30:                 case '/': result /= num; break;",
          "31:             }",
          "32:         }",
          "33:         return result;",
          "34:     };",
          "35:     parser[\"OPERATOR\"] = [](const SemanticValues& sv) { return *sv.c_str(); };",
          "36:     parser[\"NUMBER\"] = [](const SemanticValues& sv) { return atol(sv.c_str()); };",
          "38:     long val;",
          "39:     parser.parse(\" -1 + (1 + 2) * 3 - -1\", val);",
          "41:     assert(val == 9);",
          "",
          "[Added Lines]",
          "21:   parser[\"EXPRESSION\"] = [](const SemanticValues &vs) {",
          "22:     auto result = any_cast<long>(vs[0]);",
          "23:     if (vs.size() > 1) {",
          "24:       auto ope = any_cast<char>(vs[1]);",
          "25:       auto num = any_cast<long>(vs[2]);",
          "26:       switch (ope) {",
          "27:       case '+': result += num; break;",
          "28:       case '-': result -= num; break;",
          "29:       case '*': result *= num; break;",
          "30:       case '/': result /= num; break;",
          "31:       }",
          "32:     }",
          "33:     return result;",
          "34:   };",
          "35:   parser[\"OPERATOR\"] = [](const SemanticValues &vs) { return *vs.sv().data(); };",
          "36:   parser[\"NUMBER\"] = [](const SemanticValues &vs) { return atol(vs.sv().data()); };",
          "38:   long val;",
          "39:   parser.parse(\" -1 + (1 + 2) * 3 - -1\", val);",
          "41:   assert(val == 9);",
          "",
          "---------------"
        ],
        "example/calc5.cc||example/calc5.cc": [
          "File: example/calc5.cc -> example/calc5.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "10: #include <cstdlib>",
          "12: using namespace peg;",
          "38:         }",
          "42:         EXPRESSION  <- ATOM (OPERATOR ATOM)* {",
          "43:                          precedence",
          "44:                            L - +",
          "",
          "[Removed Lines]",
          "8: #include <peglib.h>",
          "9: #include <iostream>",
          "14: int main(int argc, const char** argv)",
          "15: {",
          "16:     if (argc < 2 || std::string(\"--help\") == argv[1]) {",
          "17:         std::cout << \"usage: calc5 [formula]\" << std::endl;",
          "18:         return 1;",
          "19:     }",
          "21:     std::function<long (const Ast&)> eval = [&](const Ast& ast) {",
          "22:         if (ast.name == \"NUMBER\") {",
          "23:             return stol(ast.token);",
          "24:         } else {",
          "25:             const auto& nodes = ast.nodes;",
          "26:             auto result = eval(*nodes[0]);",
          "27:             if (nodes.size() > 1) {",
          "28:                 auto ope = nodes[1]->token[0];",
          "29:                 auto num = eval(*nodes[2]);",
          "30:                 switch (ope) {",
          "31:                     case '+': result += num; break;",
          "32:                     case '-': result -= num; break;",
          "33:                     case '*': result *= num; break;",
          "34:                     case '/': result /= num; break;",
          "35:                 }",
          "36:             }",
          "37:             return result;",
          "39:     };",
          "41:     parser parser(R\"(",
          "",
          "[Added Lines]",
          "9: #include <iostream>",
          "10: #include <peglib.h>",
          "14: int main(int argc, const char **argv) {",
          "15:   if (argc < 2 || std::string(\"--help\") == argv[1]) {",
          "16:     std::cout << \"usage: calc5 [formula]\" << std::endl;",
          "17:     return 1;",
          "18:   }",
          "20:   std::function<long(const Ast &)> eval = [&](const Ast &ast) {",
          "21:     if (ast.name == \"NUMBER\") {",
          "22:       return ast.token_to_number<long>();",
          "23:     } else {",
          "24:       const auto &nodes = ast.nodes;",
          "25:       auto result = eval(*nodes[0]);",
          "26:       if (nodes.size() > 1) {",
          "27:         auto ope = nodes[1]->token[0];",
          "28:         auto num = eval(*nodes[2]);",
          "29:         switch (ope) {",
          "30:         case '+': result += num; break;",
          "31:         case '-': result -= num; break;",
          "32:         case '*': result *= num; break;",
          "33:         case '/': result /= num; break;",
          "35:       }",
          "36:       return result;",
          "37:     }",
          "38:   };",
          "40:   parser parser(R\"(",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "50:         %whitespace <- [ \\t\\r\\n]*",
          "51:     )\");",
          "67: }",
          "",
          "[Removed Lines]",
          "53:     parser.enable_ast();",
          "55:     auto expr = argv[1];",
          "56:     std::shared_ptr<Ast> ast;",
          "57:     if (parser.parse(expr, ast)) {",
          "58:         ast = AstOptimizer(true).optimize(ast);",
          "59:         std::cout << ast_to_s(ast);",
          "60:         std::cout << expr << \" = \" << eval(*ast) << std::endl;",
          "61:         return 0;",
          "62:     }",
          "64:     std::cout << \"syntax error...\" << std::endl;",
          "66:     return -1;",
          "",
          "[Added Lines]",
          "52:   parser.enable_ast();",
          "54:   auto expr = argv[1];",
          "55:   std::shared_ptr<Ast> ast;",
          "56:   if (parser.parse(expr, ast)) {",
          "57:     ast = AstOptimizer(true).optimize(ast);",
          "58:     std::cout << ast_to_s(ast);",
          "59:     std::cout << expr << \" = \" << eval(*ast) << std::endl;",
          "60:     return 0;",
          "61:   }",
          "63:   std::cout << \"syntax error...\" << std::endl;",
          "65:   return -1;",
          "",
          "---------------"
        ],
        "lint/peglint.cc||lint/peglint.cc": [
          "File: lint/peglint.cc -> lint/peglint.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "131:     parser.enable_trace(",
          "132:         [&](const char *name, const char *s, size_t /*n*/,",
          "133:             const peg::SemanticValues & /*sv*/, const peg::Context &c,",
          "135:           auto pos = static_cast<size_t>(s - c.s);",
          "136:           auto backtrack = (pos < prev_pos ? \"*\" : \"\");",
          "137:           string indent;",
          "",
          "[Removed Lines]",
          "134:             const peg::any & /*dt*/) {",
          "",
          "[Added Lines]",
          "134:             const std::any & /*dt*/) {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "145:         },",
          "146:         [&](const char *name, const char *s, size_t /*n*/,",
          "147:             const peg::SemanticValues &sv, const peg::Context &c,",
          "149:           auto pos = static_cast<size_t>(s - c.s);",
          "150:           if (len != static_cast<size_t>(-1)) { pos += len; }",
          "151:           string indent;",
          "",
          "[Removed Lines]",
          "148:             const peg::any & /*dt*/, size_t len) {",
          "",
          "[Added Lines]",
          "148:             const std::any & /*dt*/, size_t len) {",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "160:           }",
          "161:           std::string token;",
          "162:           if (!sv.tokens.empty()) {",
          "165:           }",
          "166:           std::cout << \"L \" << pos << \"\\t\" << indent << ret << name << \" #\"",
          "167:                     << c.trace_ids.back() << choice.str() << token << std::endl;",
          "",
          "[Removed Lines]",
          "163:             const auto &tok = sv.tokens[0];",
          "164:             token += \" '\" + std::string(tok.first, tok.second) + \"'\";",
          "",
          "[Added Lines]",
          "163:             token += \" '\";",
          "164:             token += sv.tokens[0];",
          "165:             token +=+ \"'\";",
          "",
          "---------------"
        ],
        "peglib.h||peglib.h": [
          "File: peglib.h -> peglib.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "19: #include <algorithm>",
          "20: #include <cassert>",
          "21: #include <cctype>",
          "22: #include <cstring>",
          "23: #include <functional>",
          "24: #include <initializer_list>",
          "",
          "[Removed Lines]",
          "8: #ifndef CPPPEGLIB_PEGLIB_H",
          "9: #define CPPPEGLIB_PEGLIB_H",
          "11: #ifndef PEGLIB_USE_STD_ANY",
          "12: #ifdef _MSVC_LANG",
          "13: #define PEGLIB_USE_STD_ANY _MSVC_LANG >= 201703L",
          "14: #elif defined(__cplusplus)",
          "15: #define PEGLIB_USE_STD_ANY __cplusplus >= 201703L",
          "16: #endif",
          "17: #endif // PEGLIB_USE_STD_ANY",
          "",
          "[Added Lines]",
          "8: #pragma once",
          "11: #include <any>",
          "14: #include <charconv>",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "29: #include <memory>",
          "30: #include <mutex>",
          "31: #include <set>",
          "33: #include <string>",
          "34: #include <unordered_map>",
          "35: #include <vector>",
          "45: #endif",
          "47: namespace peg {",
          "",
          "[Removed Lines]",
          "32: #include <sstream>",
          "36: #if PEGLIB_USE_STD_ANY",
          "37: #include <any>",
          "38: #endif",
          "41: #ifdef _MSC_VER",
          "42: #if defined(_MSC_VER) && _MSC_VER < 1900 // Less than Visual Studio 2015",
          "43: #error \"Requires complete C+11 support\"",
          "44: #endif",
          "53: #if PEGLIB_USE_STD_ANY",
          "54: using any = std::any;",
          "57: template <typename T, typename... Args>",
          "58: auto any_cast(Args &&... args)",
          "59:     -> decltype(std::any_cast<T>(std::forward<Args>(args)...)) {",
          "60:   return std::any_cast<T>(std::forward<Args>(args)...);",
          "61: }",
          "62: #else",
          "63: class any {",
          "64: public:",
          "65:   any() = default;",
          "67:   any(const any &rhs) : content_(rhs.clone()) {}",
          "69:   any(any &&rhs) : content_(rhs.content_) { rhs.content_ = nullptr; }",
          "71:   template <typename T> any(const T &value) : content_(new holder<T>(value)) {}",
          "73:   any &operator=(const any &rhs) {",
          "74:     if (this != &rhs) {",
          "75:       if (content_) { delete content_; }",
          "76:       content_ = rhs.clone();",
          "77:     }",
          "78:     return *this;",
          "79:   }",
          "81:   any &operator=(any &&rhs) {",
          "82:     if (this != &rhs) {",
          "83:       if (content_) { delete content_; }",
          "84:       content_ = rhs.content_;",
          "85:       rhs.content_ = nullptr;",
          "86:     }",
          "87:     return *this;",
          "88:   }",
          "90:   ~any() { delete content_; }",
          "92:   bool has_value() const { return content_ != nullptr; }",
          "94:   template <typename T> friend T &any_cast(any &val);",
          "96:   template <typename T> friend const T &any_cast(const any &val);",
          "98: private:",
          "99:   struct placeholder {",
          "100:     virtual ~placeholder() {}",
          "101:     virtual placeholder *clone() const = 0;",
          "102:   };",
          "104:   template <typename T> struct holder : placeholder {",
          "105:     holder(const T &value) : value_(value) {}",
          "106:     placeholder *clone() const override { return new holder(value_); }",
          "107:     T value_;",
          "108:   };",
          "110:   placeholder *clone() const { return content_ ? content_->clone() : nullptr; }",
          "112:   placeholder *content_ = nullptr;",
          "113: };",
          "115: template <typename T> T &any_cast(any &val) {",
          "116:   if (!val.content_) { throw std::bad_cast(); }",
          "117:   auto p = dynamic_cast<any::holder<T> *>(val.content_);",
          "118:   assert(p);",
          "119:   if (!p) { throw std::bad_cast(); }",
          "120:   return p->value_;",
          "121: }",
          "123: template <> inline any &any_cast<any>(any &val) { return val; }",
          "125: template <typename T> const T &any_cast(const any &val) {",
          "126:   assert(val.content_);",
          "127:   auto p = dynamic_cast<any::holder<T> *>(val.content_);",
          "128:   assert(p);",
          "129:   if (!p) { throw std::bad_cast(); }",
          "130:   return p->value_;",
          "131: }",
          "133: template <> inline const any &any_cast<any>(const any &val) { return val; }",
          "134: #endif",
          "",
          "[Added Lines]",
          "29: #if !defined(__cplusplus) || __cplusplus < 201703L",
          "30: #error \"Requires complete C++17 support\"",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "165:   bool execute_on_destruction;",
          "166: };",
          "",
          "[Removed Lines]",
          "168: template <typename EF>",
          "169: auto make_scope_exit(EF &&exit_function) -> scope_exit<EF> {",
          "170:   return scope_exit<typename std::remove_reference<EF>::type>(",
          "171:       std::forward<EF>(exit_function));",
          "172: }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "324:     ret = static_cast<int>(ret * 16 + val);",
          "325:     i++;",
          "326:   }",
          "328: }",
          "330: inline std::pair<int, size_t> parse_octal_number(const char *s, size_t n,",
          "",
          "[Removed Lines]",
          "327:   return std::make_pair(ret, i);",
          "",
          "[Added Lines]",
          "220:   return std::pair(ret, i);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "335:     ret = static_cast<int>(ret * 8 + val);",
          "336:     i++;",
          "337:   }",
          "339: }",
          "341: inline std::string resolve_escape_sequence(const char *s, size_t n) {",
          "",
          "[Removed Lines]",
          "338:   return std::make_pair(ret, i);",
          "",
          "[Added Lines]",
          "231:   return std::pair(ret, i);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "416:     for (const auto &item : items) {",
          "417:       for (size_t len = 1; len <= item.size(); len++) {",
          "418:         auto last = len == item.size();",
          "421:         if (it == dic_.end()) {",
          "423:         } else if (last) {",
          "424:           it->second.match = true;",
          "425:         } else {",
          "",
          "[Removed Lines]",
          "419:         std::string s(item.c_str(), len);",
          "420:         auto it = dic_.find(s);",
          "422:           dic_.emplace(s, Info{last, last});",
          "",
          "[Added Lines]",
          "312:         std::string_view sv(item.data(), len);",
          "313:         auto it = dic_.find(sv);",
          "315:           dic_.emplace(sv, Info{last, last});",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "432:   size_t match(const char *text, size_t text_len) const {",
          "433:     size_t match_len = 0;",
          "447:       }",
          "448:     }",
          "449:     return match_len;",
          "450:   }",
          "",
          "[Removed Lines]",
          "434:     {",
          "435:       auto done = false;",
          "436:       size_t len = 1;",
          "437:       while (!done && len <= text_len) {",
          "438:         std::string s(text, len);",
          "439:         auto it = dic_.find(s);",
          "440:         if (it == dic_.end()) {",
          "441:           done = true;",
          "442:         } else {",
          "443:           if (it->second.match) { match_len = len; }",
          "444:           if (it->second.done) { done = true; }",
          "445:         }",
          "446:         len += 1;",
          "",
          "[Added Lines]",
          "327:     auto done = false;",
          "328:     size_t len = 1;",
          "329:     while (!done && len <= text_len) {",
          "330:       std::string_view sv(text, len);",
          "331:       auto it = dic_.find(sv);",
          "332:       if (it == dic_.end()) {",
          "333:         done = true;",
          "334:       } else {",
          "335:         if (it->second.match) { match_len = len; }",
          "336:         if (it->second.done) { done = true; }",
          "338:       len += 1;",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "454:     bool done;",
          "455:     bool match;",
          "456:   };",
          "458: };",
          "",
          "[Removed Lines]",
          "457:   std::unordered_map<std::string, Info> dic_;",
          "",
          "[Added Lines]",
          "351:   std::map<std::string, Info, std::less<>> dic_;",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "480:   auto col = p - col_ptr + 1;",
          "483: }",
          "492: }",
          "494: namespace udl {",
          "498: }",
          "500: } // namespace udl",
          "",
          "[Removed Lines]",
          "482:   return std::make_pair(no, col);",
          "488: inline constexpr unsigned int str2tag(const char *str, unsigned int h = 0) {",
          "489:   return (*str == '\\0')",
          "490:              ? h",
          "491:              : str2tag(str + 1, (h * 33) ^ static_cast<unsigned char>(*str));",
          "496: inline constexpr unsigned int operator\"\" _(const char *s, size_t) {",
          "497:   return str2tag(s);",
          "",
          "[Added Lines]",
          "376:   return std::pair(no, col);",
          "382: inline constexpr unsigned int str2tag_core(const char *s, size_t l,",
          "383:                                            unsigned int h) {",
          "384:   return (l == 0) ? h",
          "385:                   : str2tag_core(s + 1, l - 1,",
          "386:                                  (h * 33) ^ static_cast<unsigned char>(*s));",
          "387: }",
          "389: inline constexpr unsigned int str2tag(std::string_view sv) {",
          "390:   return str2tag_core(sv.data(), sv.size(), 0);",
          "395: inline constexpr unsigned int operator\"\" _(const char *s, size_t l) {",
          "396:   return str2tag_core(s, l, 0);",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "507:   const char *path = nullptr;",
          "508:   const char *ss = nullptr;",
          "509:   const std::vector<size_t> *source_line_index = nullptr;",
          "518:   const std::string &name() const { return name_; }",
          "",
          "[Removed Lines]",
          "505: struct SemanticValues : protected std::vector<any> {",
          "512:   const char *c_str() const { return s_; }",
          "513:   size_t length() const { return n_; }",
          "515:   std::string str() const { return std::string(s_, n_); }",
          "",
          "[Added Lines]",
          "404: struct SemanticValues : protected std::vector<std::any> {",
          "411:   std::string_view sv() const { return sv_; }",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "523:   std::pair<size_t, size_t> line_info() const {",
          "524:     const auto &idx = *source_line_index;",
          "527:     auto it = std::lower_bound(",
          "528:         idx.begin(), idx.end(), cur,",
          "529:         [](size_t element, size_t value) { return element < value; });",
          "531:     auto id = static_cast<size_t>(std::distance(idx.begin(), it));",
          "532:     auto off = cur - (id == 0 ? 0 : idx[id - 1] + 1);",
          "534:   }",
          "",
          "[Removed Lines]",
          "526:     auto cur = static_cast<size_t>(std::distance(ss, s_));",
          "533:     return std::make_pair(id + 1, off + 1);",
          "",
          "[Added Lines]",
          "422:     auto cur = static_cast<size_t>(std::distance(ss, sv_.data()));",
          "429:     return std::pair(id + 1, off + 1);",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "540:   size_t choice() const { return choice_; }",
          "552:   }",
          "",
          "[Removed Lines]",
          "543:   std::vector<std::pair<const char *, size_t>> tokens;",
          "545:   std::string token(size_t id = 0) const {",
          "546:     if (!tokens.empty()) {",
          "547:       assert(id < tokens.size());",
          "548:       const auto &tok = tokens[id];",
          "549:       return std::string(tok.first, tok.second);",
          "550:     }",
          "551:     return std::string(s_, n_);",
          "",
          "[Added Lines]",
          "439:   std::vector<std::string_view> tokens;",
          "441:   std::string_view token(size_t id = 0) const {",
          "442:     if (tokens.empty()) { return sv_; }",
          "443:     assert(id < tokens.size());",
          "444:     return tokens[id];",
          "445:   }",
          "448:   std::string token_to_string(size_t id = 0) const {",
          "449:     return std::string(token(id));",
          "450:   }",
          "452:   template <typename T> T token_to_number() const {",
          "453:     auto sv = token();",
          "454:     T n = 0;",
          "455:     std::from_chars(sv.data(), sv.data() + sv.size(), n);",
          "456:     return n;",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "558:     std::vector<T> r;",
          "559:     end = (std::min)(end, size());",
          "560:     for (size_t i = beg; i < end; i++) {",
          "562:     }",
          "563:     return r;",
          "564:   }",
          "589: private:",
          "590:   friend class Context;",
          "",
          "[Removed Lines]",
          "561:       r.emplace_back(any_cast<T>((*this)[i]));",
          "566:   using std::vector<any>::iterator;",
          "567:   using std::vector<any>::const_iterator;",
          "568:   using std::vector<any>::size;",
          "569:   using std::vector<any>::empty;",
          "570:   using std::vector<any>::assign;",
          "571:   using std::vector<any>::begin;",
          "572:   using std::vector<any>::end;",
          "573:   using std::vector<any>::rbegin;",
          "574:   using std::vector<any>::rend;",
          "575:   using std::vector<any>::operator[];",
          "576:   using std::vector<any>::at;",
          "577:   using std::vector<any>::resize;",
          "578:   using std::vector<any>::front;",
          "579:   using std::vector<any>::back;",
          "580:   using std::vector<any>::push_back;",
          "581:   using std::vector<any>::pop_back;",
          "582:   using std::vector<any>::insert;",
          "583:   using std::vector<any>::erase;",
          "584:   using std::vector<any>::clear;",
          "585:   using std::vector<any>::swap;",
          "586:   using std::vector<any>::emplace;",
          "587:   using std::vector<any>::emplace_back;",
          "",
          "[Added Lines]",
          "466:       r.emplace_back(std::any_cast<T>((*this)[i]));",
          "471:   using std::vector<std::any>::iterator;",
          "472:   using std::vector<std::any>::const_iterator;",
          "473:   using std::vector<std::any>::size;",
          "474:   using std::vector<std::any>::empty;",
          "475:   using std::vector<std::any>::assign;",
          "476:   using std::vector<std::any>::begin;",
          "477:   using std::vector<std::any>::end;",
          "478:   using std::vector<std::any>::rbegin;",
          "479:   using std::vector<std::any>::rend;",
          "480:   using std::vector<std::any>::operator[];",
          "481:   using std::vector<std::any>::at;",
          "482:   using std::vector<std::any>::resize;",
          "483:   using std::vector<std::any>::front;",
          "484:   using std::vector<std::any>::back;",
          "485:   using std::vector<std::any>::push_back;",
          "486:   using std::vector<std::any>::pop_back;",
          "487:   using std::vector<std::any>::insert;",
          "488:   using std::vector<std::any>::erase;",
          "489:   using std::vector<std::any>::clear;",
          "490:   using std::vector<std::any>::swap;",
          "491:   using std::vector<std::any>::emplace;",
          "492:   using std::vector<std::any>::emplace_back;",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "593:   friend class Holder;",
          "594:   friend class PrecedenceClimbing;",
          "598:   size_t choice_count_ = 0;",
          "599:   size_t choice_ = 0;",
          "600:   std::string name_;",
          "",
          "[Removed Lines]",
          "596:   const char *s_ = nullptr;",
          "597:   size_t n_ = 0;",
          "",
          "[Added Lines]",
          "501:   std::string_view sv_;",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "632: }",
          "634: class Action {",
          "635: public:",
          "636:   Action() = default;",
          "673:   Action &operator=(const Action &rhs) = default;",
          "675:   operator bool() const { return bool(fn_); }",
          "679: private:",
          "692:     }",
          "770:   }",
          "772:   Fty fn_;",
          "",
          "[Removed Lines]",
          "606: template <typename R, typename F,",
          "607:           typename std::enable_if<std::is_void<R>::value,",
          "608:                                   std::nullptr_t>::type = nullptr,",
          "609:           typename... Args>",
          "610: any call(F fn, Args &&... args) {",
          "611:   fn(std::forward<Args>(args)...);",
          "612:   return any();",
          "613: }",
          "615: template <typename R, typename F,",
          "616:           typename std::enable_if<",
          "617:               std::is_same<typename std::remove_cv<R>::type, any>::value,",
          "618:               std::nullptr_t>::type = nullptr,",
          "619:           typename... Args>",
          "620: any call(F fn, Args &&... args) {",
          "621:   return fn(std::forward<Args>(args)...);",
          "622: }",
          "624: template <typename R, typename F,",
          "625:           typename std::enable_if<",
          "626:               !std::is_void<R>::value &&",
          "627:                   !std::is_same<typename std::remove_cv<R>::type, any>::value,",
          "628:               std::nullptr_t>::type = nullptr,",
          "629:           typename... Args>",
          "630: any call(F fn, Args &&... args) {",
          "631:   return any(fn(std::forward<Args>(args)...));",
          "637:   Action(const Action &rhs) = default;",
          "639:   template <typename F,",
          "640:             typename std::enable_if<!std::is_pointer<F>::value &&",
          "641:                                         !std::is_same<F, std::nullptr_t>::value,",
          "642:                                     std::nullptr_t>::type = nullptr>",
          "643:   Action(F fn) : fn_(make_adaptor(fn, &F::operator())) {}",
          "645:   template <typename F, typename std::enable_if<std::is_pointer<F>::value,",
          "646:                                                 std::nullptr_t>::type = nullptr>",
          "647:   Action(F fn) : fn_(make_adaptor(fn, fn)) {}",
          "649:   template <typename F,",
          "650:             typename std::enable_if<std::is_same<F, std::nullptr_t>::value,",
          "651:                                     std::nullptr_t>::type = nullptr>",
          "652:   Action(F /*fn*/) {}",
          "654:   template <typename F,",
          "655:             typename std::enable_if<!std::is_pointer<F>::value &&",
          "656:                                         !std::is_same<F, std::nullptr_t>::value,",
          "657:                                     std::nullptr_t>::type = nullptr>",
          "658:   void operator=(F fn) {",
          "659:     fn_ = make_adaptor(fn, &F::operator());",
          "660:   }",
          "662:   template <typename F, typename std::enable_if<std::is_pointer<F>::value,",
          "663:                                                 std::nullptr_t>::type = nullptr>",
          "664:   void operator=(F fn) {",
          "665:     fn_ = make_adaptor(fn, fn);",
          "666:   }",
          "668:   template <typename F,",
          "669:             typename std::enable_if<std::is_same<F, std::nullptr_t>::value,",
          "670:                                     std::nullptr_t>::type = nullptr>",
          "671:   void operator=(F /*fn*/) {}",
          "677:   any operator()(SemanticValues &sv, any &dt) const { return fn_(sv, dt); }",
          "680:   template <typename R> struct TypeAdaptor_sv {",
          "681:     TypeAdaptor_sv(std::function<R(SemanticValues &sv)> fn) : fn_(fn) {}",
          "682:     any operator()(SemanticValues &sv, any & /*dt*/) {",
          "683:       return call<R>(fn_, sv);",
          "684:     }",
          "685:     std::function<R(SemanticValues &sv)> fn_;",
          "686:   };",
          "688:   template <typename R> struct TypeAdaptor_csv {",
          "689:     TypeAdaptor_csv(std::function<R(const SemanticValues &sv)> fn) : fn_(fn) {}",
          "690:     any operator()(SemanticValues &sv, any & /*dt*/) {",
          "691:       return call<R>(fn_, sv);",
          "693:     std::function<R(const SemanticValues &sv)> fn_;",
          "694:   };",
          "696:   template <typename R> struct TypeAdaptor_sv_dt {",
          "697:     TypeAdaptor_sv_dt(std::function<R(SemanticValues &sv, any &dt)> fn)",
          "698:         : fn_(fn) {}",
          "699:     any operator()(SemanticValues &sv, any &dt) { return call<R>(fn_, sv, dt); }",
          "700:     std::function<R(SemanticValues &sv, any &dt)> fn_;",
          "701:   };",
          "703:   template <typename R> struct TypeAdaptor_csv_dt {",
          "704:     TypeAdaptor_csv_dt(std::function<R(const SemanticValues &sv, any &dt)> fn)",
          "705:         : fn_(fn) {}",
          "706:     any operator()(SemanticValues &sv, any &dt) { return call<R>(fn_, sv, dt); }",
          "707:     std::function<R(const SemanticValues &sv, any &dt)> fn_;",
          "708:   };",
          "710:   typedef std::function<any(SemanticValues &sv, any &dt)> Fty;",
          "712:   template <typename F, typename R>",
          "713:   Fty make_adaptor(F fn, R (F::*)(SemanticValues &sv) const) {",
          "714:     return TypeAdaptor_sv<R>(fn);",
          "715:   }",
          "717:   template <typename F, typename R>",
          "718:   Fty make_adaptor(F fn, R (F::*)(const SemanticValues &sv) const) {",
          "719:     return TypeAdaptor_csv<R>(fn);",
          "720:   }",
          "722:   template <typename F, typename R>",
          "723:   Fty make_adaptor(F fn, R (F::*)(SemanticValues &sv)) {",
          "724:     return TypeAdaptor_sv<R>(fn);",
          "725:   }",
          "727:   template <typename F, typename R>",
          "728:   Fty make_adaptor(F fn, R (F::*)(const SemanticValues &sv)) {",
          "729:     return TypeAdaptor_csv<R>(fn);",
          "730:   }",
          "732:   template <typename F, typename R>",
          "733:   Fty make_adaptor(F fn, R (*)(SemanticValues &sv)) {",
          "734:     return TypeAdaptor_sv<R>(fn);",
          "735:   }",
          "737:   template <typename F, typename R>",
          "738:   Fty make_adaptor(F fn, R (*)(const SemanticValues &sv)) {",
          "739:     return TypeAdaptor_csv<R>(fn);",
          "740:   }",
          "742:   template <typename F, typename R>",
          "743:   Fty make_adaptor(F fn, R (F::*)(SemanticValues &sv, any &dt) const) {",
          "744:     return TypeAdaptor_sv_dt<R>(fn);",
          "745:   }",
          "747:   template <typename F, typename R>",
          "748:   Fty make_adaptor(F fn, R (F::*)(const SemanticValues &sv, any &dt) const) {",
          "749:     return TypeAdaptor_csv_dt<R>(fn);",
          "750:   }",
          "752:   template <typename F, typename R>",
          "753:   Fty make_adaptor(F fn, R (F::*)(SemanticValues &sv, any &dt)) {",
          "754:     return TypeAdaptor_sv_dt<R>(fn);",
          "755:   }",
          "757:   template <typename F, typename R>",
          "758:   Fty make_adaptor(F fn, R (F::*)(const SemanticValues &sv, any &dt)) {",
          "759:     return TypeAdaptor_csv_dt<R>(fn);",
          "760:   }",
          "762:   template <typename F, typename R>",
          "763:   Fty make_adaptor(F fn, R (*)(SemanticValues &sv, any &dt)) {",
          "764:     return TypeAdaptor_sv_dt<R>(fn);",
          "765:   }",
          "767:   template <typename F, typename R>",
          "768:   Fty make_adaptor(F fn, R (*)(const SemanticValues &sv, any &dt)) {",
          "769:     return TypeAdaptor_csv_dt<R>(fn);",
          "",
          "[Added Lines]",
          "510: template <typename F, typename... Args> std::any call(F fn, Args &&... args) {",
          "511:   using R = decltype(fn(std::forward<Args>(args)...));",
          "512:   if constexpr (std::is_void<R>::value) {",
          "513:     fn(std::forward<Args>(args)...);",
          "514:     return std::any();",
          "515:   } else if constexpr (std::is_same<typename std::remove_cv<R>::type,",
          "516:                                     std::any>::value) {",
          "517:     return fn(std::forward<Args>(args)...);",
          "518:   } else {",
          "519:     return std::any(fn(std::forward<Args>(args)...));",
          "520:   }",
          "523: template <typename T>",
          "524: struct argument_count : argument_count<decltype(&T::operator())> {};",
          "525: template <typename R, typename... Args>",
          "526: struct argument_count<R (*)(Args...)>",
          "527:     : std::integral_constant<unsigned, sizeof...(Args)> {};",
          "528: template <typename R, typename C, typename... Args>",
          "529: struct argument_count<R (C::*)(Args...)>",
          "530:     : std::integral_constant<unsigned, sizeof...(Args)> {};",
          "531: template <typename R, typename C, typename... Args>",
          "532: struct argument_count<R (C::*)(Args...) const>",
          "533:     : std::integral_constant<unsigned, sizeof...(Args)> {};",
          "538:   Action(Action &&rhs) = default;",
          "539:   template <typename F> Action(F fn) : fn_(make_adaptor(fn)) {}",
          "540:   template <typename F> void operator=(F fn) { fn_ = make_adaptor(fn); }",
          "545:   std::any operator()(SemanticValues &vs, std::any &dt) const {",
          "546:     return fn_(vs, dt);",
          "547:   }",
          "550:   using Fty = std::function<std::any(SemanticValues &vs, std::any &dt)>;",
          "552:   template <typename F> Fty make_adaptor(F fn) {",
          "553:     if constexpr (argument_count<F>::value == 1) {",
          "554:       return [fn](auto &vs, auto & /*dt*/) { return call(fn, vs); };",
          "555:     } else {",
          "556:       return [fn](auto &vs, auto &dt) { return call(fn, vs, dt); };",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "780: struct parse_error {",
          "781:   parse_error() = default;",
          "782:   parse_error(const char *s) : s_(s) {}",
          "785: private:",
          "786:   std::string s_;",
          "",
          "[Removed Lines]",
          "783:   const char *what() const { return s_.empty() ? nullptr : s_.c_str(); }",
          "",
          "[Added Lines]",
          "571:   const char *what() const { return s_.empty() ? nullptr : s_.data(); }",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "800: class Ope;",
          "801: class Definition;",
          "813: class Context {",
          "814: public:",
          "",
          "[Removed Lines]",
          "803: typedef std::function<void(const char *name, const char *s, size_t n,",
          "804:                            const SemanticValues &sv, const Context &c,",
          "805:                            const any &dt)>",
          "806:     TracerEnter;",
          "808: typedef std::function<void(const char *name, const char *s, size_t n,",
          "809:                            const SemanticValues &sv, const Context &c,",
          "810:                            const any &dt, size_t)>",
          "811:     TracerLeave;",
          "",
          "[Added Lines]",
          "591: using TracerEnter = std::function<void(const char *name, const char *s,",
          "592:                                        size_t n, const SemanticValues &vs,",
          "593:                                        const Context &c, const std::any &dt)>;",
          "595: using TracerLeave = std::function<void(",
          "596:     const char *name, const char *s, size_t n, const SemanticValues &vs,",
          "597:     const Context &c, const std::any &dt, size_t)>;",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "835:   std::shared_ptr<Ope> wordOpe;",
          "838:   size_t capture_scope_stack_size = 0;",
          "840:   const size_t def_count;",
          "",
          "[Removed Lines]",
          "837:   std::vector<std::map<std::string, std::string>> capture_scope_stack;",
          "",
          "[Added Lines]",
          "623:   std::vector<std::map<std::string_view, std::string>> capture_scope_stack;",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "842:   std::vector<bool> cache_registered;",
          "843:   std::vector<bool> cache_success;",
          "847:   TracerEnter tracer_enter;",
          "848:   TracerLeave tracer_leave;",
          "",
          "[Removed Lines]",
          "845:   std::map<std::pair<size_t, size_t>, std::tuple<size_t, any>> cache_values;",
          "",
          "[Added Lines]",
          "631:   std::map<std::pair<size_t, size_t>, std::tuple<size_t, std::any>>",
          "632:       cache_values;",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "875:   Context operator=(const Context &) = delete;",
          "877:   template <typename T>",
          "879:     if (!enablePackratParsing) {",
          "880:       fn(val);",
          "881:       return;",
          "",
          "[Removed Lines]",
          "878:   void packrat(const char *a_s, size_t def_id, size_t &len, any &val, T fn) {",
          "",
          "[Added Lines]",
          "665:   void packrat(const char *a_s, size_t def_id, size_t &len, std::any &val,",
          "666:                T fn) {",
          "",
          "---------------",
          "--- Hunk 21 ---",
          "[Context before]",
          "887:     if (cache_registered[idx]) {",
          "888:       if (cache_success[idx]) {",
          "890:         std::tie(len, val) = cache_values[key];",
          "891:         return;",
          "892:       } else {",
          "",
          "[Removed Lines]",
          "889:         auto key = std::make_pair(col, def_id);",
          "",
          "[Added Lines]",
          "677:         auto key = std::pair(col, def_id);",
          "",
          "---------------",
          "--- Hunk 22 ---",
          "[Context before]",
          "898:       cache_registered[idx] = true;",
          "899:       cache_success[idx] = success(len);",
          "900:       if (success(len)) {",
          "903:       }",
          "904:       return;",
          "905:     }",
          "",
          "[Removed Lines]",
          "901:         auto key = std::make_pair(col, def_id);",
          "902:         cache_values[key] = std::make_pair(len, val);",
          "",
          "[Added Lines]",
          "689:         auto key = std::pair(col, def_id);",
          "690:         cache_values[key] = std::pair(len, val);",
          "",
          "---------------",
          "--- Hunk 23 ---",
          "[Context before]",
          "910:     if (value_stack_size == value_stack.size()) {",
          "911:       value_stack.emplace_back(std::make_shared<SemanticValues>());",
          "912:     } else {",
          "917:       }",
          "923:     }",
          "930:   }",
          "932:   void pop() { value_stack_size--; }",
          "",
          "[Removed Lines]",
          "913:       auto &sv = *value_stack[value_stack_size];",
          "914:       if (!sv.empty()) {",
          "915:         sv.clear();",
          "916:         if (!sv.tags.empty()) { sv.tags.clear(); }",
          "918:       sv.s_ = nullptr;",
          "919:       sv.n_ = 0;",
          "920:       sv.choice_count_ = 0;",
          "921:       sv.choice_ = 0;",
          "922:       if (!sv.tokens.empty()) { sv.tokens.clear(); }",
          "925:     auto &sv = *value_stack[value_stack_size++];",
          "926:     sv.path = path;",
          "927:     sv.ss = s;",
          "928:     sv.source_line_index = &source_line_index;",
          "929:     return sv;",
          "",
          "[Added Lines]",
          "701:       auto &vs = *value_stack[value_stack_size];",
          "702:       if (!vs.empty()) {",
          "703:         vs.clear();",
          "704:         if (!vs.tags.empty()) { vs.tags.clear(); }",
          "706:       vs.sv_ = std::string_view();",
          "707:       vs.choice_count_ = 0;",
          "708:       vs.choice_ = 0;",
          "709:       if (!vs.tokens.empty()) { vs.tokens.clear(); }",
          "712:     auto &vs = *value_stack[value_stack_size++];",
          "713:     vs.path = path;",
          "714:     vs.ss = s;",
          "715:     vs.source_line_index = &source_line_index;",
          "716:     return vs;",
          "",
          "---------------",
          "--- Hunk 24 ---",
          "[Context before]",
          "944:   void push_capture_scope() {",
          "945:     assert(capture_scope_stack_size <= capture_scope_stack.size());",
          "946:     if (capture_scope_stack_size == capture_scope_stack.size()) {",
          "948:     } else {",
          "949:       auto &cs = capture_scope_stack[capture_scope_stack_size];",
          "950:       if (!cs.empty()) { cs.clear(); }",
          "",
          "[Removed Lines]",
          "947:       capture_scope_stack.emplace_back(std::map<std::string, std::string>());",
          "",
          "[Added Lines]",
          "734:       capture_scope_stack.emplace_back(",
          "735:           std::map<std::string_view, std::string>());",
          "",
          "---------------",
          "--- Hunk 25 ---",
          "[Context before]",
          "968:   }",
          "970:   void trace_enter(const char *name, const char *a_s, size_t n,",
          "972:   void trace_leave(const char *name, const char *a_s, size_t n,",
          "974:   bool is_traceable(const Ope &ope) const;",
          "976:   mutable size_t next_trace_id = 0;",
          "",
          "[Removed Lines]",
          "971:                    SemanticValues &sv, any &dt) const;",
          "973:                    SemanticValues &sv, any &dt, size_t len) const;",
          "",
          "[Added Lines]",
          "759:                    SemanticValues &vs, std::any &dt) const;",
          "761:                    SemanticValues &vs, std::any &dt, size_t len) const;",
          "",
          "---------------",
          "--- Hunk 26 ---",
          "[Context before]",
          "985:   struct Visitor;",
          "987:   virtual ~Ope() {}",
          "992:   virtual void accept(Visitor &v) = 0;",
          "993: };",
          "",
          "[Removed Lines]",
          "988:   size_t parse(const char *s, size_t n, SemanticValues &sv, Context &c,",
          "989:                any &dt) const;",
          "990:   virtual size_t parse_core(const char *s, size_t n, SemanticValues &sv,",
          "991:                             Context &c, any &dt) const = 0;",
          "",
          "[Added Lines]",
          "776:   size_t parse(const char *s, size_t n, SemanticValues &vs, Context &c,",
          "777:                std::any &dt) const;",
          "778:   virtual size_t parse_core(const char *s, size_t n, SemanticValues &vs,",
          "779:                             Context &c, std::any &dt) const = 0;",
          "",
          "---------------",
          "--- Hunk 27 ---",
          "[Context before]",
          "1000:   Sequence(const std::vector<std::shared_ptr<Ope>> &opes) : opes_(opes) {}",
          "1001:   Sequence(std::vector<std::shared_ptr<Ope>> &&opes) : opes_(opes) {}",
          "1005:     auto &chldsv = c.push();",
          "1007:     size_t i = 0;",
          "1008:     for (const auto &ope : opes_) {",
          "1009:       const auto &rule = *ope;",
          "",
          "[Removed Lines]",
          "1003:   size_t parse_core(const char *s, size_t n, SemanticValues &sv, Context &c,",
          "1004:                     any &dt) const override {",
          "1006:     auto pop_se = make_scope_exit([&]() { c.pop(); });",
          "",
          "[Added Lines]",
          "791:   size_t parse_core(const char *s, size_t n, SemanticValues &vs, Context &c,",
          "792:                     std::any &dt) const override {",
          "794:     auto pop_se = scope_exit([&]() { c.pop(); });",
          "",
          "---------------",
          "--- Hunk 28 ---",
          "[Context before]",
          "1013:     }",
          "1014:     if (!chldsv.empty()) {",
          "1015:       for (size_t j = 0; j < chldsv.size(); j++) {",
          "1017:       }",
          "1018:     }",
          "1019:     if (!chldsv.tags.empty()) {",
          "1020:       for (size_t j = 0; j < chldsv.tags.size(); j++) {",
          "1022:       }",
          "1023:     }",
          "1026:     if (!chldsv.tokens.empty()) {",
          "1027:       for (size_t j = 0; j < chldsv.tokens.size(); j++) {",
          "1029:       }",
          "1030:     }",
          "1031:     return i;",
          "",
          "[Removed Lines]",
          "1016:         sv.emplace_back(std::move(chldsv[j]));",
          "1021:         sv.tags.emplace_back(std::move(chldsv.tags[j]));",
          "1024:     sv.s_ = chldsv.c_str();",
          "1025:     sv.n_ = chldsv.length();",
          "1028:         sv.tokens.emplace_back(std::move(chldsv.tokens[j]));",
          "",
          "[Added Lines]",
          "804:         vs.emplace_back(std::move(chldsv[j]));",
          "809:         vs.tags.emplace_back(std::move(chldsv.tags[j]));",
          "812:     vs.sv_ = chldsv.sv_;",
          "815:         vs.tokens.emplace_back(std::move(chldsv.tokens[j]));",
          "",
          "---------------",
          "--- Hunk 29 ---",
          "[Context before]",
          "1045:       : opes_(opes) {}",
          "1046:   PrioritizedChoice(std::vector<std::shared_ptr<Ope>> &&opes) : opes_(opes) {}",
          "1050:     size_t id = 0;",
          "1051:     for (const auto &ope : opes_) {",
          "1052:       auto &chldsv = c.push();",
          "1053:       c.push_capture_scope();",
          "1055:         c.pop();",
          "1056:         c.pop_capture_scope();",
          "1057:       });",
          "",
          "[Removed Lines]",
          "1048:   size_t parse_core(const char *s, size_t n, SemanticValues &sv, Context &c,",
          "1049:                     any &dt) const override {",
          "1054:       auto se = make_scope_exit([&]() {",
          "",
          "[Added Lines]",
          "835:   size_t parse_core(const char *s, size_t n, SemanticValues &vs, Context &c,",
          "836:                     std::any &dt) const override {",
          "841:       auto se = scope_exit([&]() {",
          "",
          "---------------",
          "--- Hunk 30 ---",
          "[Context before]",
          "1059:       if (success(len)) {",
          "1060:         if (!chldsv.empty()) {",
          "1061:           for (size_t i = 0; i < chldsv.size(); i++) {",
          "1063:           }",
          "1064:         }",
          "1065:         if (!chldsv.tags.empty()) {",
          "1066:           for (size_t i = 0; i < chldsv.tags.size(); i++) {",
          "1068:           }",
          "1069:         }",
          "1074:         if (!chldsv.tokens.empty()) {",
          "1075:           for (size_t i = 0; i < chldsv.tokens.size(); i++) {",
          "1077:           }",
          "1078:         }",
          "",
          "[Removed Lines]",
          "1062:             sv.emplace_back(std::move(chldsv[i]));",
          "1067:             sv.tags.emplace_back(std::move(chldsv.tags[i]));",
          "1070:         sv.s_ = chldsv.c_str();",
          "1071:         sv.n_ = chldsv.length();",
          "1072:         sv.choice_count_ = opes_.size();",
          "1073:         sv.choice_ = id;",
          "1076:             sv.tokens.emplace_back(std::move(chldsv.tokens[i]));",
          "",
          "[Added Lines]",
          "849:             vs.emplace_back(std::move(chldsv[i]));",
          "854:             vs.tags.emplace_back(std::move(chldsv.tags[i]));",
          "857:         vs.sv_ = chldsv.sv_;",
          "858:         vs.choice_count_ = opes_.size();",
          "859:         vs.choice_ = id;",
          "862:             vs.tokens.emplace_back(std::move(chldsv.tokens[i]));",
          "",
          "---------------",
          "--- Hunk 31 ---",
          "[Context before]",
          "1097:   Repetition(const std::shared_ptr<Ope> &ope, size_t min, size_t max)",
          "1098:       : ope_(ope), min_(min), max_(max) {}",
          "1102:     size_t count = 0;",
          "1103:     size_t i = 0;",
          "1104:     while (count < min_) {",
          "1105:       c.push_capture_scope();",
          "1107:       const auto &rule = *ope_;",
          "1109:       if (success(len)) {",
          "1110:         c.shift_capture_values();",
          "1111:       } else {",
          "",
          "[Removed Lines]",
          "1100:   size_t parse_core(const char *s, size_t n, SemanticValues &sv, Context &c,",
          "1101:                     any &dt) const override {",
          "1106:       auto se = make_scope_exit([&]() { c.pop_capture_scope(); });",
          "1108:       auto len = rule.parse(s + i, n - i, sv, c, dt);",
          "",
          "[Added Lines]",
          "886:   size_t parse_core(const char *s, size_t n, SemanticValues &vs, Context &c,",
          "887:                     std::any &dt) const override {",
          "892:       auto se = scope_exit([&]() { c.pop_capture_scope(); });",
          "894:       auto len = rule.parse(s + i, n - i, vs, c, dt);",
          "",
          "---------------",
          "--- Hunk 32 ---",
          "[Context before]",
          "1118:     auto save_error_pos = c.error_pos;",
          "1119:     while (n - i > 0 && count < max_) {",
          "1120:       c.push_capture_scope();",
          "1124:       const auto &rule = *ope_;",
          "1126:       if (success(len)) {",
          "1127:         c.shift_capture_values();",
          "1128:       } else {",
          "1132:                         static_cast<std::ptrdiff_t>(save_sv_size));",
          "1133:         }",
          "1136:                           static_cast<std::ptrdiff_t>(save_tok_size));",
          "1137:         }",
          "1138:         c.error_pos = save_error_pos;",
          "",
          "[Removed Lines]",
          "1121:       auto se = make_scope_exit([&]() { c.pop_capture_scope(); });",
          "1122:       auto save_sv_size = sv.size();",
          "1123:       auto save_tok_size = sv.tokens.size();",
          "1125:       auto len = rule.parse(s + i, n - i, sv, c, dt);",
          "1129:         if (sv.size() != save_sv_size) {",
          "1130:           sv.erase(sv.begin() + static_cast<std::ptrdiff_t>(save_sv_size));",
          "1131:           sv.tags.erase(sv.tags.begin() +",
          "1134:         if (sv.tokens.size() != save_tok_size) {",
          "1135:           sv.tokens.erase(sv.tokens.begin() +",
          "",
          "[Added Lines]",
          "907:       auto se = scope_exit([&]() { c.pop_capture_scope(); });",
          "908:       auto save_sv_size = vs.size();",
          "909:       auto save_tok_size = vs.tokens.size();",
          "911:       auto len = rule.parse(s + i, n - i, vs, c, dt);",
          "915:         if (vs.size() != save_sv_size) {",
          "916:           vs.erase(vs.begin() + static_cast<std::ptrdiff_t>(save_sv_size));",
          "917:           vs.tags.erase(vs.tags.begin() +",
          "920:         if (vs.tokens.size() != save_tok_size) {",
          "921:           vs.tokens.erase(vs.tokens.begin() +",
          "",
          "---------------",
          "--- Hunk 33 ---",
          "[Context before]",
          "1173: public:",
          "1174:   AndPredicate(const std::shared_ptr<Ope> &ope) : ope_(ope) {}",
          "1178:     auto &chldsv = c.push();",
          "1179:     c.push_capture_scope();",
          "1181:       c.pop();",
          "1182:       c.pop_capture_scope();",
          "1183:     });",
          "",
          "[Removed Lines]",
          "1176:   size_t parse_core(const char *s, size_t n, SemanticValues & /*sv*/,",
          "1177:                     Context &c, any &dt) const override {",
          "1180:     auto se = make_scope_exit([&]() {",
          "",
          "[Added Lines]",
          "962:   size_t parse_core(const char *s, size_t n, SemanticValues & /*vs*/,",
          "963:                     Context &c, std::any &dt) const override {",
          "966:     auto se = scope_exit([&]() {",
          "",
          "---------------",
          "--- Hunk 34 ---",
          "[Context before]",
          "1199: public:",
          "1200:   NotPredicate(const std::shared_ptr<Ope> &ope) : ope_(ope) {}",
          "1204:     auto save_error_pos = c.error_pos;",
          "1205:     auto &chldsv = c.push();",
          "1206:     c.push_capture_scope();",
          "1208:       c.pop();",
          "1209:       c.pop_capture_scope();",
          "1210:     });",
          "",
          "[Removed Lines]",
          "1202:   size_t parse_core(const char *s, size_t n, SemanticValues & /*sv*/,",
          "1203:                     Context &c, any &dt) const override {",
          "1207:     auto se = make_scope_exit([&]() {",
          "",
          "[Added Lines]",
          "988:   size_t parse_core(const char *s, size_t n, SemanticValues & /*vs*/,",
          "989:                     Context &c, std::any &dt) const override {",
          "993:     auto se = scope_exit([&]() {",
          "",
          "---------------",
          "--- Hunk 35 ---",
          "[Context before]",
          "1227: public:",
          "1228:   Dictionary(const std::vector<std::string> &v) : trie_(v) {}",
          "1233:   void accept(Visitor &v) override;",
          "",
          "[Removed Lines]",
          "1230:   size_t parse_core(const char *s, size_t n, SemanticValues &sv, Context &c,",
          "1231:                     any &dt) const override;",
          "",
          "[Added Lines]",
          "1016:   size_t parse_core(const char *s, size_t n, SemanticValues &vs, Context &c,",
          "1017:                     std::any &dt) const override;",
          "",
          "---------------",
          "--- Hunk 36 ---",
          "[Context before]",
          "1244:   LiteralString(const std::string &s, bool ignore_case)",
          "1245:       : lit_(s), ignore_case_(ignore_case), is_word_(false) {}",
          "1250:   void accept(Visitor &v) override;",
          "",
          "[Removed Lines]",
          "1247:   size_t parse_core(const char *s, size_t n, SemanticValues &sv, Context &c,",
          "1248:                     any &dt) const override;",
          "",
          "[Added Lines]",
          "1033:   size_t parse_core(const char *s, size_t n, SemanticValues &vs, Context &c,",
          "1034:                     std::any &dt) const override;",
          "",
          "---------------",
          "--- Hunk 37 ---",
          "[Context before]",
          "1259:                        public std::enable_shared_from_this<CharacterClass> {",
          "1260: public:",
          "1261:   CharacterClass(const std::string &s, bool negated) : negated_(negated) {",
          "1263:     auto i = 0u;",
          "1264:     while (i < chars.size()) {",
          "1265:       if (i + 2 < chars.size() && chars[i + 1] == '-') {",
          "1266:         auto cp1 = chars[i];",
          "1267:         auto cp2 = chars[i + 2];",
          "1269:         i += 3;",
          "1270:       } else {",
          "1271:         auto cp = chars[i];",
          "1273:         i += 1;",
          "1274:       }",
          "1275:     }",
          "",
          "[Removed Lines]",
          "1262:     auto chars = decode(s.c_str(), s.length());",
          "1268:         ranges_.emplace_back(std::make_pair(cp1, cp2));",
          "1272:         ranges_.emplace_back(std::make_pair(cp, cp));",
          "",
          "[Added Lines]",
          "1048:     auto chars = decode(s.data(), s.length());",
          "1054:         ranges_.emplace_back(std::pair(cp1, cp2));",
          "1058:         ranges_.emplace_back(std::pair(cp, cp));",
          "",
          "---------------",
          "--- Hunk 38 ---",
          "[Context before]",
          "1282:     assert(!ranges_.empty());",
          "1283:   }",
          "1287:     if (n < 1) {",
          "1288:       c.set_error_pos(s);",
          "1289:       return static_cast<size_t>(-1);",
          "",
          "[Removed Lines]",
          "1285:   size_t parse_core(const char *s, size_t n, SemanticValues & /*sv*/,",
          "1286:                     Context &c, any & /*dt*/) const override {",
          "",
          "[Added Lines]",
          "1071:   size_t parse_core(const char *s, size_t n, SemanticValues & /*vs*/,",
          "1072:                     Context &c, std::any & /*dt*/) const override {",
          "",
          "---------------",
          "--- Hunk 39 ---",
          "[Context before]",
          "1321: public:",
          "1322:   Character(char ch) : ch_(ch) {}",
          "1326:     if (n < 1 || s[0] != ch_) {",
          "1327:       c.set_error_pos(s);",
          "1328:       return static_cast<size_t>(-1);",
          "",
          "[Removed Lines]",
          "1324:   size_t parse_core(const char *s, size_t n, SemanticValues & /*sv*/,",
          "1325:                     Context &c, any & /*dt*/) const override {",
          "",
          "[Added Lines]",
          "1110:   size_t parse_core(const char *s, size_t n, SemanticValues & /*vs*/,",
          "1111:                     Context &c, std::any & /*dt*/) const override {",
          "",
          "---------------",
          "--- Hunk 40 ---",
          "[Context before]",
          "1338: class AnyCharacter : public Ope,",
          "1339:                      public std::enable_shared_from_this<AnyCharacter> {",
          "1340: public:",
          "1343:     auto len = codepoint_length(s, n);",
          "1344:     if (len < 1) {",
          "1345:       c.set_error_pos(s);",
          "",
          "[Removed Lines]",
          "1341:   size_t parse_core(const char *s, size_t n, SemanticValues & /*sv*/,",
          "1342:                     Context &c, any & /*dt*/) const override {",
          "",
          "[Added Lines]",
          "1127:   size_t parse_core(const char *s, size_t n, SemanticValues & /*vs*/,",
          "1128:                     Context &c, std::any & /*dt*/) const override {",
          "",
          "---------------",
          "--- Hunk 41 ---",
          "[Context before]",
          "1355: public:",
          "1356:   CaptureScope(const std::shared_ptr<Ope> &ope) : ope_(ope) {}",
          "1360:     c.push_capture_scope();",
          "1362:     const auto &rule = *ope_;",
          "1364:     return len;",
          "1365:   }",
          "",
          "[Removed Lines]",
          "1358:   size_t parse_core(const char *s, size_t n, SemanticValues &sv, Context &c,",
          "1359:                     any &dt) const override {",
          "1361:     auto se = make_scope_exit([&]() { c.pop_capture_scope(); });",
          "1363:     auto len = rule.parse(s, n, sv, c, dt);",
          "",
          "[Added Lines]",
          "1144:   size_t parse_core(const char *s, size_t n, SemanticValues &vs, Context &c,",
          "1145:                     std::any &dt) const override {",
          "1147:     auto se = scope_exit([&]() { c.pop_capture_scope(); });",
          "1149:     auto len = rule.parse(s, n, vs, c, dt);",
          "",
          "---------------",
          "--- Hunk 42 ---",
          "[Context before]",
          "1372: class Capture : public Ope {",
          "1373: public:",
          "1376:   Capture(const std::shared_ptr<Ope> &ope, MatchAction ma)",
          "1377:       : ope_(ope), match_action_(ma) {}",
          "1381:     const auto &rule = *ope_;",
          "1383:     if (success(len) && match_action_) { match_action_(s, len, c); }",
          "1384:     return len;",
          "1385:   }",
          "",
          "[Removed Lines]",
          "1374:   typedef std::function<void(const char *s, size_t n, Context &c)> MatchAction;",
          "1379:   size_t parse_core(const char *s, size_t n, SemanticValues &sv, Context &c,",
          "1380:                     any &dt) const override {",
          "1382:     auto len = rule.parse(s, n, sv, c, dt);",
          "",
          "[Added Lines]",
          "1160:   using MatchAction = std::function<void(const char *s, size_t n, Context &c)>;",
          "1165:   size_t parse_core(const char *s, size_t n, SemanticValues &vs, Context &c,",
          "1166:                     std::any &dt) const override {",
          "1168:     auto len = rule.parse(s, n, vs, c, dt);",
          "",
          "---------------",
          "--- Hunk 43 ---",
          "[Context before]",
          "1394: public:",
          "1395:   TokenBoundary(const std::shared_ptr<Ope> &ope) : ope_(ope) {}",
          "1400:   void accept(Visitor &v) override;",
          "",
          "[Removed Lines]",
          "1397:   size_t parse_core(const char *s, size_t n, SemanticValues &sv, Context &c,",
          "1398:                     any &dt) const override;",
          "",
          "[Added Lines]",
          "1183:   size_t parse_core(const char *s, size_t n, SemanticValues &vs, Context &c,",
          "1184:                     std::any &dt) const override;",
          "",
          "---------------",
          "--- Hunk 44 ---",
          "[Context before]",
          "1406: public:",
          "1407:   Ignore(const std::shared_ptr<Ope> &ope) : ope_(ope) {}",
          "1411:     const auto &rule = *ope_;",
          "1412:     auto &chldsv = c.push();",
          "1414:     return rule.parse(s, n, chldsv, c, dt);",
          "1415:   }",
          "",
          "[Removed Lines]",
          "1409:   size_t parse_core(const char *s, size_t n, SemanticValues & /*sv*/,",
          "1410:                     Context &c, any &dt) const override {",
          "1413:     auto se = make_scope_exit([&]() { c.pop(); });",
          "",
          "[Added Lines]",
          "1195:   size_t parse_core(const char *s, size_t n, SemanticValues & /*vs*/,",
          "1196:                     Context &c, std::any &dt) const override {",
          "1199:     auto se = scope_exit([&]() { c.pop(); });",
          "",
          "---------------",
          "--- Hunk 45 ---",
          "[Context before]",
          "1419:   std::shared_ptr<Ope> ope_;",
          "1420: };",
          "1426: class User : public Ope {",
          "1427: public:",
          "1428:   User(Parser fn) : fn_(fn) {}",
          "1431:     assert(fn_);",
          "1433:   }",
          "1434:   void accept(Visitor &v) override;",
          "1436:       fn_;",
          "1437: };",
          "",
          "[Removed Lines]",
          "1422: typedef std::function<size_t(const char *s, size_t n, SemanticValues &sv,",
          "1423:                              any &dt)>",
          "1424:     Parser;",
          "1429:   size_t parse_core(const char *s, size_t n, SemanticValues &sv,",
          "1430:                     Context & /*c*/, any &dt) const override {",
          "1432:     return fn_(s, n, sv, dt);",
          "1435:   std::function<size_t(const char *s, size_t n, SemanticValues &sv, any &dt)>",
          "",
          "[Added Lines]",
          "1208: using Parser = std::function<size_t(const char *s, size_t n, SemanticValues &vs,",
          "1209:                                     std::any &dt)>;",
          "1214:   size_t parse_core(const char *s, size_t n, SemanticValues &vs,",
          "1215:                     Context & /*c*/, std::any &dt) const override {",
          "1217:     return fn_(s, n, vs, dt);",
          "1220:   std::function<size_t(const char *s, size_t n, SemanticValues &vs,",
          "1221:                        std::any &dt)>",
          "",
          "---------------",
          "--- Hunk 46 ---",
          "[Context before]",
          "1440: public:",
          "1441:   WeakHolder(const std::shared_ptr<Ope> &ope) : weak_(ope) {}",
          "1445:     auto ope = weak_.lock();",
          "1446:     assert(ope);",
          "1447:     const auto &rule = *ope;",
          "1449:   }",
          "1451:   void accept(Visitor &v) override;",
          "",
          "[Removed Lines]",
          "1443:   size_t parse_core(const char *s, size_t n, SemanticValues &sv, Context &c,",
          "1444:                     any &dt) const override {",
          "1448:     return rule.parse(s, n, sv, c, dt);",
          "",
          "[Added Lines]",
          "1229:   size_t parse_core(const char *s, size_t n, SemanticValues &vs, Context &c,",
          "1230:                     std::any &dt) const override {",
          "1234:     return rule.parse(s, n, vs, c, dt);",
          "",
          "---------------",
          "--- Hunk 47 ---",
          "[Context before]",
          "1457: public:",
          "1458:   Holder(Definition *outer) : outer_(outer) {}",
          "1463:   void accept(Visitor &v) override;",
          "1467:   const char *trace_name() const;",
          "",
          "[Removed Lines]",
          "1460:   size_t parse_core(const char *s, size_t n, SemanticValues &sv, Context &c,",
          "1461:                     any &dt) const override;",
          "1465:   any reduce(SemanticValues &sv, any &dt) const;",
          "",
          "[Added Lines]",
          "1246:   size_t parse_core(const char *s, size_t n, SemanticValues &vs, Context &c,",
          "1247:                     std::any &dt) const override;",
          "1251:   std::any reduce(SemanticValues &vs, std::any &dt) const;",
          "",
          "---------------",
          "--- Hunk 48 ---",
          "[Context before]",
          "1473:   friend class Definition;",
          "1474: };",
          "1478: class Reference : public Ope, public std::enable_shared_from_this<Reference> {",
          "1479: public:",
          "",
          "[Removed Lines]",
          "1476: typedef std::unordered_map<std::string, Definition> Grammar;",
          "",
          "[Added Lines]",
          "1262: using Grammar = std::unordered_map<std::string, Definition>;",
          "",
          "---------------",
          "--- Hunk 49 ---",
          "[Context before]",
          "1482:       : grammar_(grammar), name_(name), s_(s), is_macro_(is_macro), args_(args),",
          "1483:         rule_(nullptr), iarg_(0) {}",
          "1488:   void accept(Visitor &v) override;",
          "",
          "[Removed Lines]",
          "1485:   size_t parse_core(const char *s, size_t n, SemanticValues &sv, Context &c,",
          "1486:                     any &dt) const override;",
          "",
          "[Added Lines]",
          "1271:   size_t parse_core(const char *s, size_t n, SemanticValues &vs, Context &c,",
          "1272:                     std::any &dt) const override;",
          "",
          "---------------",
          "--- Hunk 50 ---",
          "[Context before]",
          "1504: public:",
          "1505:   Whitespace(const std::shared_ptr<Ope> &ope) : ope_(ope) {}",
          "1509:     if (c.in_whitespace) { return 0; }",
          "1510:     c.in_whitespace = true;",
          "1512:     const auto &rule = *ope_;",
          "1514:   }",
          "1516:   void accept(Visitor &v) override;",
          "",
          "[Removed Lines]",
          "1507:   size_t parse_core(const char *s, size_t n, SemanticValues &sv, Context &c,",
          "1508:                     any &dt) const override {",
          "1511:     auto se = make_scope_exit([&]() { c.in_whitespace = false; });",
          "1513:     return rule.parse(s, n, sv, c, dt);",
          "",
          "[Added Lines]",
          "1293:   size_t parse_core(const char *s, size_t n, SemanticValues &vs, Context &c,",
          "1294:                     std::any &dt) const override {",
          "1297:     auto se = scope_exit([&]() { c.in_whitespace = false; });",
          "1299:     return rule.parse(s, n, vs, c, dt);",
          "",
          "---------------",
          "--- Hunk 51 ---",
          "[Context before]",
          "1521: class BackReference : public Ope {",
          "1522: public:",
          "1523:   BackReference(const std::string &name) : name_(name) {}",
          "1528:   void accept(Visitor &v) override;",
          "",
          "[Removed Lines]",
          "1525:   size_t parse_core(const char *s, size_t n, SemanticValues &sv, Context &c,",
          "1526:                     any &dt) const override;",
          "",
          "[Added Lines]",
          "1309:   BackReference(std::string &&name) : name_(name) {}",
          "1313:   size_t parse_core(const char *s, size_t n, SemanticValues &vs, Context &c,",
          "1314:                     std::any &dt) const override;",
          "",
          "---------------",
          "--- Hunk 52 ---",
          "[Context before]",
          "1533: class PrecedenceClimbing : public Ope {",
          "1534: public:",
          "1537:   PrecedenceClimbing(const std::shared_ptr<Ope> &atom,",
          "1538:                      const std::shared_ptr<Ope> &binop, const BinOpeInfo &info,",
          "1539:                      const Definition &rule)",
          "1540:       : atom_(atom), binop_(binop), info_(info), rule_(rule) {}",
          "1545:   }",
          "1547:   void accept(Visitor &v) override;",
          "",
          "[Removed Lines]",
          "1535:   using BinOpeInfo = std::map<std::string, std::pair<size_t, char>>;",
          "1542:   size_t parse_core(const char *s, size_t n, SemanticValues &sv, Context &c,",
          "1543:                     any &dt) const override {",
          "1544:     return parse_expression(s, n, sv, c, dt, 0);",
          "",
          "[Added Lines]",
          "1323:   using BinOpeInfo = std::map<std::string_view, std::pair<size_t, char>>;",
          "1330:   size_t parse_core(const char *s, size_t n, SemanticValues &vs, Context &c,",
          "1331:                     std::any &dt) const override {",
          "1332:     return parse_expression(s, n, vs, c, dt, 0);",
          "",
          "---------------",
          "--- Hunk 53 ---",
          "[Context before]",
          "1552:   const Definition &rule_;",
          "1554: private:",
          "1558:   Definition &get_reference_for_binop(Context &c) const;",
          "1559: };",
          "",
          "[Removed Lines]",
          "1555:   size_t parse_expression(const char *s, size_t n, SemanticValues &sv,",
          "1556:                           Context &c, any &dt, size_t min_prec) const;",
          "",
          "[Added Lines]",
          "1343:   size_t parse_expression(const char *s, size_t n, SemanticValues &vs,",
          "1344:                           Context &c, std::any &dt, size_t min_prec) const;",
          "",
          "---------------",
          "--- Hunk 54 ---",
          "[Context before]",
          "1649: }",
          "1651: inline std::shared_ptr<Ope>",
          "1653:         fn) {",
          "1654:   return std::make_shared<User>(fn);",
          "1655: }",
          "",
          "[Removed Lines]",
          "1652: usr(std::function<size_t(const char *s, size_t n, SemanticValues &sv, any &dt)>",
          "",
          "[Added Lines]",
          "1440: usr(std::function<size_t(const char *s, size_t n, SemanticValues &vs,",
          "1441:                          std::any &dt)>",
          "",
          "---------------",
          "--- Hunk 55 ---",
          "[Context before]",
          "1664:   return std::make_shared<Whitespace>(std::make_shared<Ignore>(ope));",
          "1665: }",
          "1668:   return std::make_shared<BackReference>(name);",
          "1669: }",
          "",
          "[Removed Lines]",
          "1667: inline std::shared_ptr<Ope> bkr(const std::string &name) {",
          "",
          "[Added Lines]",
          "1456: inline std::shared_ptr<Ope> bkr(std::string &&name) {",
          "",
          "---------------",
          "--- Hunk 56 ---",
          "[Context before]",
          "1681: struct Ope::Visitor {",
          "1682:   virtual ~Visitor() {}",
          "1704: };",
          "1706: struct IsReference : public Ope::Visitor {",
          "1709:   bool is_reference = false;",
          "1710: };",
          "1712: struct TraceOpeName : public Ope::Visitor {",
          "1731:   void visit(Holder &ope) override { name = ope.trace_name(); }",
          "1739:   const char *name = nullptr;",
          "1740: };",
          "1742: struct AssignIDToDefinition : public Ope::Visitor {",
          "1745:   void visit(Sequence &ope) override {",
          "1746:     for (auto op : ope.opes_) {",
          "1747:       op->accept(*this);",
          "",
          "[Removed Lines]",
          "1683:   virtual void visit(Sequence & /*ope*/) {}",
          "1684:   virtual void visit(PrioritizedChoice & /*ope*/) {}",
          "1685:   virtual void visit(Repetition & /*ope*/) {}",
          "1686:   virtual void visit(AndPredicate & /*ope*/) {}",
          "1687:   virtual void visit(NotPredicate & /*ope*/) {}",
          "1688:   virtual void visit(Dictionary & /*ope*/) {}",
          "1689:   virtual void visit(LiteralString & /*ope*/) {}",
          "1690:   virtual void visit(CharacterClass & /*ope*/) {}",
          "1691:   virtual void visit(Character & /*ope*/) {}",
          "1692:   virtual void visit(AnyCharacter & /*ope*/) {}",
          "1693:   virtual void visit(CaptureScope & /*ope*/) {}",
          "1694:   virtual void visit(Capture & /*ope*/) {}",
          "1695:   virtual void visit(TokenBoundary & /*ope*/) {}",
          "1696:   virtual void visit(Ignore & /*ope*/) {}",
          "1697:   virtual void visit(User & /*ope*/) {}",
          "1698:   virtual void visit(WeakHolder & /*ope*/) {}",
          "1699:   virtual void visit(Holder & /*ope*/) {}",
          "1700:   virtual void visit(Reference & /*ope*/) {}",
          "1701:   virtual void visit(Whitespace & /*ope*/) {}",
          "1702:   virtual void visit(BackReference & /*ope*/) {}",
          "1703:   virtual void visit(PrecedenceClimbing & /*ope*/) {}",
          "1707:   using Ope::Visitor::visit;",
          "1708:   void visit(Reference & /*ope*/) override { is_reference = true; }",
          "1713:   void visit(Sequence & /*ope*/) override { name = \"Sequence\"; }",
          "1714:   void visit(PrioritizedChoice & /*ope*/) override {",
          "1715:     name = \"PrioritizedChoice\";",
          "1716:   }",
          "1717:   void visit(Repetition & /*ope*/) override { name = \"Repetition\"; }",
          "1718:   void visit(AndPredicate & /*ope*/) override { name = \"AndPredicate\"; }",
          "1719:   void visit(NotPredicate & /*ope*/) override { name = \"NotPredicate\"; }",
          "1720:   void visit(Dictionary & /*ope*/) override { name = \"Dictionary\"; }",
          "1721:   void visit(LiteralString & /*ope*/) override { name = \"LiteralString\"; }",
          "1722:   void visit(CharacterClass & /*ope*/) override { name = \"CharacterClass\"; }",
          "1723:   void visit(Character & /*ope*/) override { name = \"Character\"; }",
          "1724:   void visit(AnyCharacter & /*ope*/) override { name = \"AnyCharacter\"; }",
          "1725:   void visit(CaptureScope & /*ope*/) override { name = \"CaptureScope\"; }",
          "1726:   void visit(Capture & /*ope*/) override { name = \"Capture\"; }",
          "1727:   void visit(TokenBoundary & /*ope*/) override { name = \"TokenBoundary\"; }",
          "1728:   void visit(Ignore & /*ope*/) override { name = \"Ignore\"; }",
          "1729:   void visit(User & /*ope*/) override { name = \"User\"; }",
          "1730:   void visit(WeakHolder & /*ope*/) override { name = \"WeakHolder\"; }",
          "1732:   void visit(Reference & /*ope*/) override { name = \"Reference\"; }",
          "1733:   void visit(Whitespace & /*ope*/) override { name = \"Whitespace\"; }",
          "1734:   void visit(BackReference & /*ope*/) override { name = \"BackReference\"; }",
          "1735:   void visit(PrecedenceClimbing & /*ope*/) override {",
          "1736:     name = \"PrecedenceClimbing\";",
          "1737:   }",
          "1743:   using Ope::Visitor::visit;",
          "",
          "[Added Lines]",
          "1472:   virtual void visit(Sequence &) {}",
          "1473:   virtual void visit(PrioritizedChoice &) {}",
          "1474:   virtual void visit(Repetition &) {}",
          "1475:   virtual void visit(AndPredicate &) {}",
          "1476:   virtual void visit(NotPredicate &) {}",
          "1477:   virtual void visit(Dictionary &) {}",
          "1478:   virtual void visit(LiteralString &) {}",
          "1479:   virtual void visit(CharacterClass &) {}",
          "1480:   virtual void visit(Character &) {}",
          "1481:   virtual void visit(AnyCharacter &) {}",
          "1482:   virtual void visit(CaptureScope &) {}",
          "1483:   virtual void visit(Capture &) {}",
          "1484:   virtual void visit(TokenBoundary &) {}",
          "1485:   virtual void visit(Ignore &) {}",
          "1486:   virtual void visit(User &) {}",
          "1487:   virtual void visit(WeakHolder &) {}",
          "1488:   virtual void visit(Holder &) {}",
          "1489:   virtual void visit(Reference &) {}",
          "1490:   virtual void visit(Whitespace &) {}",
          "1491:   virtual void visit(BackReference &) {}",
          "1492:   virtual void visit(PrecedenceClimbing &) {}",
          "1496:   void visit(Reference &) override { is_reference = true; }",
          "1501:   void visit(Sequence &) override { name = \"Sequence\"; }",
          "1502:   void visit(PrioritizedChoice &) override { name = \"PrioritizedChoice\"; }",
          "1503:   void visit(Repetition &) override { name = \"Repetition\"; }",
          "1504:   void visit(AndPredicate &) override { name = \"AndPredicate\"; }",
          "1505:   void visit(NotPredicate &) override { name = \"NotPredicate\"; }",
          "1506:   void visit(Dictionary &) override { name = \"Dictionary\"; }",
          "1507:   void visit(LiteralString &) override { name = \"LiteralString\"; }",
          "1508:   void visit(CharacterClass &) override { name = \"CharacterClass\"; }",
          "1509:   void visit(Character &) override { name = \"Character\"; }",
          "1510:   void visit(AnyCharacter &) override { name = \"AnyCharacter\"; }",
          "1511:   void visit(CaptureScope &) override { name = \"CaptureScope\"; }",
          "1512:   void visit(Capture &) override { name = \"Capture\"; }",
          "1513:   void visit(TokenBoundary &) override { name = \"TokenBoundary\"; }",
          "1514:   void visit(Ignore &) override { name = \"Ignore\"; }",
          "1515:   void visit(User &) override { name = \"User\"; }",
          "1516:   void visit(WeakHolder &) override { name = \"WeakHolder\"; }",
          "1518:   void visit(Reference &) override { name = \"Reference\"; }",
          "1519:   void visit(Whitespace &) override { name = \"Whitespace\"; }",
          "1520:   void visit(BackReference &) override { name = \"BackReference\"; }",
          "1521:   void visit(PrecedenceClimbing &) override { name = \"PrecedenceClimbing\"; }",
          "",
          "---------------",
          "--- Hunk 57 ---",
          "[Context before]",
          "1769: };",
          "1771: struct IsLiteralToken : public Ope::Visitor {",
          "1774:   void visit(PrioritizedChoice &ope) override {",
          "1775:     for (auto op : ope.opes_) {",
          "1776:       if (!IsLiteralToken::check(*op)) { return; }",
          "",
          "[Removed Lines]",
          "1772:   using Ope::Visitor::visit;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 58 ---",
          "[Context before]",
          "1778:     result_ = true;",
          "1779:   }",
          "1784:   static bool check(Ope &ope) {",
          "1785:     IsLiteralToken vis;",
          "",
          "[Removed Lines]",
          "1781:   void visit(Dictionary & /*ope*/) override { result_ = true; }",
          "1782:   void visit(LiteralString & /*ope*/) override { result_ = true; }",
          "",
          "[Added Lines]",
          "1561:   void visit(Dictionary &) override { result_ = true; }",
          "1562:   void visit(LiteralString &) override { result_ = true; }",
          "",
          "---------------",
          "--- Hunk 59 ---",
          "[Context before]",
          "1792: };",
          "1794: struct TokenChecker : public Ope::Visitor {",
          "1797:   void visit(Sequence &ope) override {",
          "1798:     for (auto op : ope.opes_) {",
          "1799:       op->accept(*this);",
          "",
          "[Removed Lines]",
          "1795:   using Ope::Visitor::visit;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 60 ---",
          "[Context before]",
          "1807:   void visit(Repetition &ope) override { ope.ope_->accept(*this); }",
          "1808:   void visit(CaptureScope &ope) override { ope.ope_->accept(*this); }",
          "1809:   void visit(Capture &ope) override { ope.ope_->accept(*this); }",
          "1811:   void visit(Ignore &ope) override { ope.ope_->accept(*this); }",
          "1812:   void visit(WeakHolder &ope) override;",
          "1813:   void visit(Reference &ope) override;",
          "",
          "[Removed Lines]",
          "1810:   void visit(TokenBoundary & /*ope*/) override { has_token_boundary_ = true; }",
          "",
          "[Added Lines]",
          "1588:   void visit(TokenBoundary &) override { has_token_boundary_ = true; }",
          "",
          "---------------",
          "--- Hunk 61 ---",
          "[Context before]",
          "1862:     ope.ope_->accept(*this);",
          "1863:     done_ = false;",
          "1864:   }",
          "1866:   void visit(LiteralString &ope) override { done_ = !ope.lit_.empty(); }",
          "1870:   void visit(CaptureScope &ope) override { ope.ope_->accept(*this); }",
          "1871:   void visit(Capture &ope) override { ope.ope_->accept(*this); }",
          "1872:   void visit(TokenBoundary &ope) override { ope.ope_->accept(*this); }",
          "1873:   void visit(Ignore &ope) override { ope.ope_->accept(*this); }",
          "1875:   void visit(WeakHolder &ope) override { ope.weak_.lock()->accept(*this); }",
          "1876:   void visit(Holder &ope) override { ope.ope_->accept(*this); }",
          "1877:   void visit(Reference &ope) override;",
          "1878:   void visit(Whitespace &ope) override { ope.ope_->accept(*this); }",
          "1880:   void visit(PrecedenceClimbing &ope) override { ope.atom_->accept(*this); }",
          "1882:   const char *error_s = nullptr;",
          "",
          "[Removed Lines]",
          "1865:   void visit(Dictionary & /*ope*/) override { done_ = true; }",
          "1867:   void visit(CharacterClass & /*ope*/) override { done_ = true; }",
          "1868:   void visit(Character & /*ope*/) override { done_ = true; }",
          "1869:   void visit(AnyCharacter & /*ope*/) override { done_ = true; }",
          "1874:   void visit(User & /*ope*/) override { done_ = true; }",
          "1879:   void visit(BackReference & /*ope*/) override { done_ = true; }",
          "",
          "[Added Lines]",
          "1643:   void visit(Dictionary &) override { done_ = true; }",
          "1645:   void visit(CharacterClass &) override { done_ = true; }",
          "1646:   void visit(Character &) override { done_ = true; }",
          "1647:   void visit(AnyCharacter &) override { done_ = true; }",
          "1652:   void visit(User &) override { done_ = true; }",
          "1657:   void visit(BackReference &) override { done_ = true; }",
          "",
          "---------------",
          "--- Hunk 62 ---",
          "[Context before]",
          "1888: };",
          "1890: struct HasEmptyElement : public Ope::Visitor {",
          "1893:   HasEmptyElement(std::list<std::pair<const char *, std::string>> &refs)",
          "1894:       : refs_(refs) {}",
          "1896:   void visit(Sequence &ope) override {",
          "1898:     const char *save_error_s = nullptr;",
          "1899:     std::string save_error_name;",
          "1900:     for (auto op : ope.opes_) {",
          "",
          "[Removed Lines]",
          "1891:   using Ope::Visitor::visit;",
          "1897:     bool save_is_empty = false;",
          "",
          "[Added Lines]",
          "1673:     auto save_is_empty = false;",
          "",
          "---------------",
          "--- Hunk 63 ---",
          "[Context before]",
          "1923:       ope.ope_->accept(*this);",
          "1924:     }",
          "1925:   }",
          "1928:   void visit(LiteralString &ope) override {",
          "1929:     if (ope.lit_.empty()) { set_error(); }",
          "1930:   }",
          "",
          "[Removed Lines]",
          "1926:   void visit(AndPredicate & /*ope*/) override { set_error(); }",
          "1927:   void visit(NotPredicate & /*ope*/) override { set_error(); }",
          "",
          "[Added Lines]",
          "1702:   void visit(AndPredicate &) override { set_error(); }",
          "1703:   void visit(NotPredicate &) override { set_error(); }",
          "",
          "---------------",
          "--- Hunk 64 ---",
          "[Context before]",
          "1952: };",
          "1954: struct DetectInfiniteLoop : public Ope::Visitor {",
          "1957:   DetectInfiniteLoop(const char *s, const std::string &name) {",
          "1958:     refs_.emplace_back(s, name);",
          "1959:   }",
          "",
          "[Removed Lines]",
          "1955:   using Ope::Visitor::visit;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 65 ---",
          "[Context before]",
          "2004: };",
          "2006: struct ReferenceChecker : public Ope::Visitor {",
          "2009:   ReferenceChecker(const Grammar &grammar,",
          "2010:                    const std::vector<std::string> &params)",
          "2011:       : grammar_(grammar), params_(params) {}",
          "",
          "[Removed Lines]",
          "2007:   using Ope::Visitor::visit;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 66 ---",
          "[Context before]",
          "2042: };",
          "2044: struct LinkReferences : public Ope::Visitor {",
          "2047:   LinkReferences(Grammar &grammar, const std::vector<std::string> &params)",
          "2048:       : grammar_(grammar), params_(params) {}",
          "",
          "[Removed Lines]",
          "2045:   using Ope::Visitor::visit;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 67 ---",
          "[Context before]",
          "2076: };",
          "2078: struct FindReference : public Ope::Visitor {",
          "2081:   FindReference(const std::vector<std::shared_ptr<Ope>> &args,",
          "2082:                 const std::vector<std::string> &params)",
          "2083:       : args_(args), params_(params) {}",
          "",
          "[Removed Lines]",
          "2079:   using Ope::Visitor::visit;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 68 ---",
          "[Context before]",
          "2155: };",
          "2157: struct IsPrioritizedChoice : public Ope::Visitor {",
          "2162:   static bool check(Ope &ope) {",
          "2163:     IsPrioritizedChoice vis;",
          "",
          "[Removed Lines]",
          "2158:   using Ope::Visitor::visit;",
          "2160:   void visit(PrioritizedChoice & /*ope*/) override { result_ = true; }",
          "",
          "[Added Lines]",
          "1926:   void visit(PrioritizedChoice &) override { result_ = true; }",
          "",
          "---------------",
          "--- Hunk 69 ---",
          "[Context before]",
          "2209:   }",
          "2211:   Result parse(const char *s, size_t n, const char *path = nullptr) const {",
          "2215:   }",
          "2217:   Result parse(const char *s, const char *path = nullptr) const {",
          "",
          "[Removed Lines]",
          "2212:     SemanticValues sv;",
          "2213:     any dt;",
          "2214:     return parse_core(s, n, sv, dt, path);",
          "",
          "[Added Lines]",
          "1978:     SemanticValues vs;",
          "1979:     std::any dt;",
          "1980:     return parse_core(s, n, vs, dt, path);",
          "",
          "---------------",
          "--- Hunk 70 ---",
          "[Context before]",
          "2219:     return parse(s, n, path);",
          "2220:   }",
          "2223:                const char *path = nullptr) const {",
          "2226:   }",
          "2229:     auto n = strlen(s);",
          "2230:     return parse(s, n, dt, path);",
          "2231:   }",
          "",
          "[Removed Lines]",
          "2222:   Result parse(const char *s, size_t n, any &dt,",
          "2224:     SemanticValues sv;",
          "2225:     return parse_core(s, n, sv, dt, path);",
          "2228:   Result parse(const char *s, any &dt, const char *path = nullptr) const {",
          "",
          "[Added Lines]",
          "1988:   Result parse(const char *s, size_t n, std::any &dt,",
          "1990:     SemanticValues vs;",
          "1991:     return parse_core(s, n, vs, dt, path);",
          "1994:   Result parse(const char *s, std::any &dt, const char *path = nullptr) const {",
          "",
          "---------------",
          "--- Hunk 71 ---",
          "[Context before]",
          "2233:   template <typename T>",
          "2234:   Result parse_and_get_value(const char *s, size_t n, T &val,",
          "2235:                              const char *path = nullptr) const {",
          "2241:     }",
          "2242:     return r;",
          "2243:   }",
          "",
          "[Removed Lines]",
          "2236:     SemanticValues sv;",
          "2237:     any dt;",
          "2238:     auto r = parse_core(s, n, sv, dt, path);",
          "2239:     if (r.ret && !sv.empty() && sv.front().has_value()) {",
          "2240:       val = any_cast<T>(sv[0]);",
          "",
          "[Added Lines]",
          "2002:     SemanticValues vs;",
          "2003:     std::any dt;",
          "2004:     auto r = parse_core(s, n, vs, dt, path);",
          "2005:     if (r.ret && !vs.empty() && vs.front().has_value()) {",
          "2006:       val = std::any_cast<T>(vs[0]);",
          "",
          "---------------",
          "--- Hunk 72 ---",
          "[Context before]",
          "2250:   }",
          "2252:   template <typename T>",
          "2254:                              const char *path = nullptr) const {",
          "2259:     }",
          "2260:     return r;",
          "2261:   }",
          "2263:   template <typename T>",
          "2265:                              const char *path = nullptr) const {",
          "2266:     auto n = strlen(s);",
          "2267:     return parse_and_get_value(s, n, dt, val, path);",
          "2268:   }",
          "2275:   template <typename T> Definition &operator,(T fn) {",
          "2276:     operator=(fn);",
          "",
          "[Removed Lines]",
          "2253:   Result parse_and_get_value(const char *s, size_t n, any &dt, T &val,",
          "2255:     SemanticValues sv;",
          "2256:     auto r = parse_core(s, n, sv, dt, path);",
          "2257:     if (r.ret && !sv.empty() && sv.front().has_value()) {",
          "2258:       val = any_cast<T>(sv[0]);",
          "2264:   Result parse_and_get_value(const char *s, any &dt, T &val,",
          "2270:   Action operator=(Action a) {",
          "2271:     action = a;",
          "2272:     return a;",
          "2273:   }",
          "",
          "[Added Lines]",
          "2019:   Result parse_and_get_value(const char *s, size_t n, std::any &dt, T &val,",
          "2021:     SemanticValues vs;",
          "2022:     auto r = parse_core(s, n, vs, dt, path);",
          "2023:     if (r.ret && !vs.empty() && vs.front().has_value()) {",
          "2024:       val = std::any_cast<T>(vs[0]);",
          "2030:   Result parse_and_get_value(const char *s, std::any &dt, T &val,",
          "2036:   void operator=(Action a) { action = a; }",
          "",
          "---------------",
          "--- Hunk 73 ---",
          "[Context before]",
          "2299:   size_t id = 0;",
          "2300:   Action action;",
          "2304:       leave;",
          "2305:   std::function<std::string()> error_message;",
          "2306:   bool ignoreSemanticValue = false;",
          "",
          "[Removed Lines]",
          "2301:   std::function<void(const char *s, size_t n, any &dt)> enter;",
          "2302:   std::function<void(const char *s, size_t n, size_t matchlen, any &value,",
          "2303:                      any &dt)>",
          "",
          "[Added Lines]",
          "2064:   std::function<void(const char *s, size_t n, std::any &dt)> enter;",
          "2065:   std::function<void(const char *s, size_t n, size_t matchlen, std::any &value,",
          "2066:                      std::any &dt)>",
          "",
          "---------------",
          "--- Hunk 74 ---",
          "[Context before]",
          "2330:     });",
          "2331:   }",
          "2334:                     const char *path) const {",
          "2335:     initialize_definition_ids();",
          "",
          "[Removed Lines]",
          "2333:   Result parse_core(const char *s, size_t n, SemanticValues &sv, any &dt,",
          "",
          "[Added Lines]",
          "2096:   Result parse_core(const char *s, size_t n, SemanticValues &vs, std::any &dt,",
          "",
          "---------------",
          "--- Hunk 75 ---",
          "[Context before]",
          "2340:     Context cxt(path, s, n, definition_ids_.size(), whitespaceOpe, wordOpe,",
          "2341:                 enablePackratParsing, tracer_enter, tracer_leave);",
          "2344:     return Result{success(len), len, cxt.error_pos, cxt.message_pos,",
          "2345:                   cxt.message};",
          "2346:   }",
          "",
          "[Removed Lines]",
          "2343:     auto len = ope->parse(s, n, sv, cxt, dt);",
          "",
          "[Added Lines]",
          "2106:     auto len = ope->parse(s, n, vs, cxt, dt);",
          "",
          "---------------",
          "--- Hunk 76 ---",
          "[Context before]",
          "2362:                             std::once_flag &init_is_word, bool &is_word,",
          "2363:                             bool ignore_case) {",
          "2364:   size_t i = 0;",
          "",
          "[Removed Lines]",
          "2360: inline size_t parse_literal(const char *s, size_t n, SemanticValues &sv,",
          "2361:                             Context &c, any &dt, const std::string &lit,",
          "",
          "[Added Lines]",
          "2123: inline size_t parse_literal(const char *s, size_t n, SemanticValues &vs,",
          "2124:                             Context &c, std::any &dt, const std::string &lit,",
          "",
          "---------------",
          "--- Hunk 77 ---",
          "[Context before]",
          "2374:   static Context dummy_c(nullptr, c.s, c.l, 0, nullptr, nullptr, false, nullptr,",
          "2375:                          nullptr);",
          "2376:   static SemanticValues dummy_sv;",
          "2379:   std::call_once(init_is_word, [&]() {",
          "2380:     if (c.wordOpe) {",
          "",
          "[Removed Lines]",
          "2377:   static any dummy_dt;",
          "",
          "[Added Lines]",
          "2140:   static std::any dummy_dt;",
          "",
          "---------------",
          "--- Hunk 78 ---",
          "[Context before]",
          "2395:   if (!c.in_token_boundary_count) {",
          "2396:     if (c.whitespaceOpe) {",
          "2398:       if (fail(len)) { return static_cast<size_t>(-1); }",
          "2399:       i += len;",
          "2400:     }",
          "",
          "[Removed Lines]",
          "2397:       auto len = c.whitespaceOpe->parse(s + i, n - i, sv, c, dt);",
          "",
          "[Added Lines]",
          "2160:       auto len = c.whitespaceOpe->parse(s + i, n - i, vs, c, dt);",
          "",
          "---------------",
          "--- Hunk 79 ---",
          "[Context before]",
          "2404: }",
          "2406: inline void Context::trace_enter(const char *name, const char *a_s, size_t n,",
          "2408:   trace_ids.push_back(next_trace_id++);",
          "2410: }",
          "2412: inline void Context::trace_leave(const char *name, const char *a_s, size_t n,",
          "2414:                                  size_t len) const {",
          "2416:   trace_ids.pop_back();",
          "2417: }",
          "",
          "[Removed Lines]",
          "2407:                                  SemanticValues &sv, any &dt) const {",
          "2409:   tracer_enter(name, a_s, n, sv, *this, dt);",
          "2413:                                  SemanticValues &sv, any &dt,",
          "2415:   tracer_leave(name, a_s, n, sv, *this, dt, len);",
          "",
          "[Added Lines]",
          "2170:                                  SemanticValues &vs, std::any &dt) const {",
          "2172:   tracer_enter(name, a_s, n, vs, *this, dt);",
          "2176:                                  SemanticValues &vs, std::any &dt,",
          "2178:   tracer_leave(name, a_s, n, vs, *this, dt, len);",
          "",
          "---------------",
          "--- Hunk 80 ---",
          "[Context before]",
          "2425:   return false;",
          "2426: }",
          "2430:   if (c.is_traceable(*this)) {",
          "2431:     TraceOpeName vis;",
          "2432:     const_cast<Ope &>(*this).accept(vis);",
          "2436:     return len;",
          "2437:   }",
          "2439: }",
          "2441: inline size_t Dictionary::parse_core(const char *s, size_t n,",
          "2444:   auto len = trie_.match(s, n);",
          "2445:   if (len > 0) { return len; }",
          "2446:   c.set_error_pos(s);",
          "",
          "[Removed Lines]",
          "2428: inline size_t Ope::parse(const char *s, size_t n, SemanticValues &sv,",
          "2429:                          Context &c, any &dt) const {",
          "2433:     c.trace_enter(vis.name, s, n, sv, dt);",
          "2434:     auto len = parse_core(s, n, sv, c, dt);",
          "2435:     c.trace_leave(vis.name, s, n, sv, dt, len);",
          "2438:   return parse_core(s, n, sv, c, dt);",
          "2442:                                      SemanticValues & /*sv*/, Context &c,",
          "2443:                                      any & /*dt*/) const {",
          "",
          "[Added Lines]",
          "2191: inline size_t Ope::parse(const char *s, size_t n, SemanticValues &vs,",
          "2192:                          Context &c, std::any &dt) const {",
          "2196:     c.trace_enter(vis.name, s, n, vs, dt);",
          "2197:     auto len = parse_core(s, n, vs, c, dt);",
          "2198:     c.trace_leave(vis.name, s, n, vs, dt, len);",
          "2201:   return parse_core(s, n, vs, c, dt);",
          "2205:                                      SemanticValues & /*vs*/, Context &c,",
          "2206:                                      std::any & /*dt*/) const {",
          "",
          "---------------",
          "--- Hunk 81 ---",
          "[Context before]",
          "2448: }",
          "2450: inline size_t LiteralString::parse_core(const char *s, size_t n,",
          "2454:                        ignore_case_);",
          "2455: }",
          "2457: inline size_t TokenBoundary::parse_core(const char *s, size_t n,",
          "2460:   size_t len;",
          "2461:   {",
          "2462:     c.in_token_boundary_count++;",
          "2465:   }",
          "2467:   if (success(len)) {",
          "2470:     if (!c.in_token_boundary_count) {",
          "2471:       if (c.whitespaceOpe) {",
          "2473:         if (fail(l)) { return static_cast<size_t>(-1); }",
          "2474:         len += l;",
          "2475:       }",
          "",
          "[Removed Lines]",
          "2451:                                         SemanticValues &sv, Context &c,",
          "2452:                                         any &dt) const {",
          "2453:   return parse_literal(s, n, sv, c, dt, lit_, init_is_word_, is_word_,",
          "2458:                                         SemanticValues &sv, Context &c,",
          "2459:                                         any &dt) const {",
          "2463:     auto se = make_scope_exit([&]() { c.in_token_boundary_count--; });",
          "2464:     len = ope_->parse(s, n, sv, c, dt);",
          "2468:     sv.tokens.emplace_back(std::make_pair(s, len));",
          "2472:         auto l = c.whitespaceOpe->parse(s + len, n - len, sv, c, dt);",
          "",
          "[Added Lines]",
          "2214:                                         SemanticValues &vs, Context &c,",
          "2215:                                         std::any &dt) const {",
          "2216:   return parse_literal(s, n, vs, c, dt, lit_, init_is_word_, is_word_,",
          "2221:                                         SemanticValues &vs, Context &c,",
          "2222:                                         std::any &dt) const {",
          "2226:     auto se = scope_exit([&]() { c.in_token_boundary_count--; });",
          "2227:     len = ope_->parse(s, n, vs, c, dt);",
          "2231:     vs.tokens.emplace_back(std::string_view(s, len));",
          "2235:         auto l = c.whitespaceOpe->parse(s + len, n - len, vs, c, dt);",
          "",
          "---------------",
          "--- Hunk 82 ---",
          "[Context before]",
          "2478:   return len;",
          "2479: }",
          "2483:   if (!ope_) {",
          "2484:     throw std::logic_error(\"Uninitialized definition ope was used...\");",
          "2485:   }",
          "",
          "[Removed Lines]",
          "2481: inline size_t Holder::parse_core(const char *s, size_t n, SemanticValues &sv,",
          "2482:                                  Context &c, any &dt) const {",
          "",
          "[Added Lines]",
          "2244: inline size_t Holder::parse_core(const char *s, size_t n, SemanticValues &vs,",
          "2245:                                  Context &c, std::any &dt) const {",
          "",
          "---------------",
          "--- Hunk 83 ---",
          "[Context before]",
          "2488:   if (outer_->is_macro) {",
          "2489:     c.rule_stack.push_back(outer_);",
          "2491:     c.rule_stack.pop_back();",
          "2492:     return len;",
          "2493:   }",
          "2495:   size_t len;",
          "2499:     if (outer_->enter) { outer_->enter(s, n, dt); }",
          "2502:       c.pop();",
          "2504:       if (outer_->leave) { outer_->leave(s, n, len, a_val, dt); }",
          "2505:     });",
          "",
          "[Removed Lines]",
          "2490:     auto len = ope_->parse(s, n, sv, c, dt);",
          "2496:   any val;",
          "2498:   c.packrat(s, outer_->id, len, val, [&](any &a_val) {",
          "2501:     auto se2 = make_scope_exit([&]() {",
          "",
          "[Added Lines]",
          "2253:     auto len = ope_->parse(s, n, vs, c, dt);",
          "2259:   std::any val;",
          "2261:   c.packrat(s, outer_->id, len, val, [&](std::any &a_val) {",
          "2264:     auto se2 = scope_exit([&]() {",
          "",
          "---------------",
          "--- Hunk 84 ---",
          "[Context before]",
          "2514:     if (success(len)) {",
          "2517:       chldsv.name_ = outer_->name;",
          "2519:       if (!IsPrioritizedChoice::check(*ope_)) {",
          "",
          "[Removed Lines]",
          "2515:       chldsv.s_ = s;",
          "2516:       chldsv.n_ = len;",
          "",
          "[Added Lines]",
          "2277:       chldsv.sv_ = std::string_view(s, len);",
          "",
          "---------------",
          "--- Hunk 85 ---",
          "[Context before]",
          "2538:   if (success(len)) {",
          "2539:     if (!outer_->ignoreSemanticValue) {",
          "2542:     }",
          "2543:   } else {",
          "2544:     if (outer_->error_message) {",
          "",
          "[Removed Lines]",
          "2540:       sv.emplace_back(std::move(val));",
          "2541:       sv.tags.emplace_back(str2tag(outer_->name.c_str()));",
          "",
          "[Added Lines]",
          "2301:       vs.emplace_back(std::move(val));",
          "2302:       vs.tags.emplace_back(str2tag(outer_->name));",
          "",
          "---------------",
          "--- Hunk 86 ---",
          "[Context before]",
          "2552:   return len;",
          "2553: }",
          "2556:   if (outer_->action && !outer_->disable_action) {",
          "2560:   } else {",
          "2562:   }",
          "2563: }",
          "2565: inline const char *Holder::trace_name() const {",
          "2566:   if (trace_name_.empty()) { trace_name_ = \"[\" + outer_->name + \"]\"; }",
          "2568: }",
          "2572:   if (rule_) {",
          "2574:     if (rule_->is_macro) {",
          "",
          "[Removed Lines]",
          "2555: inline any Holder::reduce(SemanticValues &sv, any &dt) const {",
          "2557:     return outer_->action(sv, dt);",
          "2558:   } else if (sv.empty()) {",
          "2559:     return any();",
          "2561:     return std::move(sv.front());",
          "2567:   return trace_name_.c_str();",
          "2570: inline size_t Reference::parse_core(const char *s, size_t n, SemanticValues &sv,",
          "2571:                                     Context &c, any &dt) const {",
          "",
          "[Added Lines]",
          "2316: inline std::any Holder::reduce(SemanticValues &vs, std::any &dt) const {",
          "2318:     return outer_->action(vs, dt);",
          "2319:   } else if (vs.empty()) {",
          "2320:     return std::any();",
          "2322:     return std::move(vs.front());",
          "2328:   return trace_name_.data();",
          "2331: inline size_t Reference::parse_core(const char *s, size_t n, SemanticValues &vs,",
          "2332:                                     Context &c, std::any &dt) const {",
          "",
          "---------------",
          "--- Hunk 87 ---",
          "[Context before]",
          "2583:       }",
          "2585:       c.push_args(std::move(args));",
          "2587:       auto ope = get_core_operator();",
          "2589:     } else {",
          "2591:       c.push_args(std::vector<std::shared_ptr<Ope>>());",
          "2593:       auto ope = get_core_operator();",
          "2595:     }",
          "2596:   } else {",
          "2598:     const auto &args = c.top_args();",
          "2600:   }",
          "2601: }",
          "",
          "[Removed Lines]",
          "2586:       auto se = make_scope_exit([&]() { c.pop_args(); });",
          "2588:       return ope->parse(s, n, sv, c, dt);",
          "2592:       auto se = make_scope_exit([&]() { c.pop_args(); });",
          "2594:       return ope->parse(s, n, sv, c, dt);",
          "2599:     return args[iarg_]->parse(s, n, sv, c, dt);",
          "",
          "[Added Lines]",
          "2347:       auto se = scope_exit([&]() { c.pop_args(); });",
          "2349:       return ope->parse(s, n, vs, c, dt);",
          "2353:       auto se = scope_exit([&]() { c.pop_args(); });",
          "2355:       return ope->parse(s, n, vs, c, dt);",
          "2360:     return args[iarg_]->parse(s, n, vs, c, dt);",
          "",
          "---------------",
          "--- Hunk 88 ---",
          "[Context before]",
          "2605: }",
          "2607: inline size_t BackReference::parse_core(const char *s, size_t n,",
          "2610:   auto size = static_cast<int>(c.capture_scope_stack_size);",
          "2611:   for (auto i = size - 1; i >= 0; i--) {",
          "2612:     auto index = static_cast<size_t>(i);",
          "",
          "[Removed Lines]",
          "2608:                                         SemanticValues &sv, Context &c,",
          "2609:                                         any &dt) const {",
          "",
          "[Added Lines]",
          "2369:                                         SemanticValues &vs, Context &c,",
          "2370:                                         std::any &dt) const {",
          "",
          "---------------",
          "--- Hunk 89 ---",
          "[Context before]",
          "2615:       const auto &lit = cs.at(name_);",
          "2616:       std::once_flag init_is_word;",
          "2617:       auto is_word = false;",
          "2619:     }",
          "2620:   }",
          "2621:   throw std::runtime_error(\"Invalid back reference...\");",
          "",
          "[Removed Lines]",
          "2618:       return parse_literal(s, n, sv, c, dt, lit, init_is_word, is_word, false);",
          "",
          "[Added Lines]",
          "2379:       return parse_literal(s, n, vs, c, dt, lit, init_is_word, is_word, false);",
          "",
          "---------------",
          "--- Hunk 90 ---",
          "[Context before]",
          "2635: }",
          "2637: inline size_t PrecedenceClimbing::parse_expression(const char *s, size_t n,",
          "2640:                                                    size_t min_prec) const {",
          "2642:   if (fail(len)) { return len; }",
          "2644:   std::string tok;",
          "2645:   auto &rule = get_reference_for_binop(c);",
          "2650:     if (action) {",
          "2654:     }",
          "2656:   };",
          "2659:   auto save_error_pos = c.error_pos;",
          "2661:   auto i = len;",
          "2662:   while (i < n) {",
          "2666:     auto chv = c.push();",
          "2667:     auto chl = binop_->parse(s + i, n - i, chv, c, dt);",
          "",
          "[Removed Lines]",
          "2638:                                                    SemanticValues &sv,",
          "2639:                                                    Context &c, any &dt,",
          "2641:   auto len = atom_->parse(s, n, sv, c, dt);",
          "2646:   auto action = rule.action;",
          "2648:   rule.action = [&](SemanticValues &sv2, any &dt2) -> any {",
          "2649:     tok = sv2.token();",
          "2651:       return action(sv2, dt2);",
          "2652:     } else if (!sv2.empty()) {",
          "2653:       return sv2[0];",
          "2655:     return any();",
          "2657:   auto action_se = make_scope_exit([&]() { rule.action = action; });",
          "2663:     std::vector<any> save_values(sv.begin(), sv.end());",
          "2664:     auto save_tokens = sv.tokens;",
          "",
          "[Added Lines]",
          "2399:                                                    SemanticValues &vs,",
          "2400:                                                    Context &c, std::any &dt,",
          "2402:   auto len = atom_->parse(s, n, vs, c, dt);",
          "2407:   auto action = std::move(rule.action);",
          "2409:   rule.action = [&](SemanticValues &vs2, std::any &dt2) {",
          "2410:     tok = vs2.token();",
          "2412:       return action(vs2, dt2);",
          "2413:     } else if (!vs2.empty()) {",
          "2414:       return vs2[0];",
          "2416:     return std::any();",
          "2418:   auto action_se = scope_exit([&]() { rule.action = std::move(action); });",
          "2424:     std::vector<std::any> save_values(vs.begin(), vs.end());",
          "2425:     auto save_tokens = vs.tokens;",
          "",
          "---------------",
          "--- Hunk 91 ---",
          "[Context before]",
          "2681:     if (level < min_prec) { break; }",
          "2684:     i += chl;",
          "2686:     auto next_min_prec = level;",
          "",
          "[Removed Lines]",
          "2683:     sv.emplace_back(std::move(chv[0]));",
          "",
          "[Added Lines]",
          "2444:     vs.emplace_back(std::move(chv[0]));",
          "",
          "---------------",
          "--- Hunk 92 ---",
          "[Context before]",
          "2691:     c.pop();",
          "2693:     if (fail(chl)) {",
          "2696:       c.error_pos = save_error_pos;",
          "2697:       break;",
          "2698:     }",
          "2701:     i += chl;",
          "2704:     if (rule_.action) {",
          "2710:     }",
          "2713:   }",
          "2715:   return i;",
          "",
          "[Removed Lines]",
          "2694:       sv.assign(save_values.begin(), save_values.end());",
          "2695:       sv.tokens = save_tokens;",
          "2700:     sv.emplace_back(std::move(chv[0]));",
          "2703:     any val;",
          "2705:       sv.s_ = s;",
          "2706:       sv.n_ = i;",
          "2707:       val = rule_.action(sv, dt);",
          "2708:     } else if (!sv.empty()) {",
          "2709:       val = sv[0];",
          "2711:     sv.clear();",
          "2712:     sv.emplace_back(std::move(val));",
          "",
          "[Added Lines]",
          "2455:       vs.assign(save_values.begin(), save_values.end());",
          "2456:       vs.tokens = save_tokens;",
          "2461:     vs.emplace_back(std::move(chv[0]));",
          "2464:     std::any val;",
          "2466:       vs.sv_ = std::string_view(s, i);",
          "2467:       val = rule_.action(vs, dt);",
          "2468:     } else if (!vs.empty()) {",
          "2469:       val = vs[0];",
          "2471:     vs.clear();",
          "2472:     vs.emplace_back(std::move(val));",
          "",
          "---------------",
          "--- Hunk 93 ---",
          "[Context before]",
          "2760:   ope.binop_->accept(*this);",
          "2761: }",
          "2765: inline void TokenChecker::visit(Reference &ope) {",
          "2766:   if (ope.is_macro_) {",
          "",
          "[Removed Lines]",
          "2763: inline void TokenChecker::visit(WeakHolder & /*ope*/) { has_rule_ = true; }",
          "",
          "[Added Lines]",
          "2523: inline void TokenChecker::visit(WeakHolder &) { has_rule_ = true; }",
          "",
          "---------------",
          "--- Hunk 94 ---",
          "[Context before]",
          "2879: class ParserGenerator {",
          "2880: public:",
          "",
          "[Removed Lines]",
          "2876: typedef std::unordered_map<std::string, std::shared_ptr<Ope>> Rules;",
          "2877: typedef std::function<void(size_t, size_t, const std::string &)> Log;",
          "",
          "[Added Lines]",
          "2636: using Rules = std::unordered_map<std::string, std::shared_ptr<Ope>>;",
          "2637: using Log = std::function<void(size_t, size_t, const std::string &)>;",
          "",
          "---------------",
          "--- Hunk 95 ---",
          "[Context before]",
          "2907:   struct Instruction {",
          "2908:     std::string type;",
          "2910:   };",
          "2912:   struct Data {",
          "",
          "[Removed Lines]",
          "2909:     any data;",
          "",
          "[Added Lines]",
          "2669:     std::any data;",
          "",
          "---------------",
          "--- Hunk 96 ---",
          "[Context before]",
          "3061:   }",
          "3063:   void setup_actions() {",
          "3071:       std::vector<std::string> params;",
          "3072:       std::shared_ptr<Ope> ope;",
          "3073:       if (is_macro) {",
          "3078:         }",
          "3079:       } else {",
          "3083:         }",
          "3084:       }",
          "",
          "[Removed Lines]",
          "3064:     g[\"Definition\"] = [&](const SemanticValues &sv, any &dt) {",
          "3065:       Data &data = *any_cast<Data *>(dt);",
          "3067:       auto is_macro = sv.choice() == 0;",
          "3068:       auto ignore = any_cast<bool>(sv[0]);",
          "3069:       auto name = any_cast<std::string>(sv[1]);",
          "3074:         params = any_cast<std::vector<std::string>>(sv[2]);",
          "3075:         ope = any_cast<std::shared_ptr<Ope>>(sv[4]);",
          "3076:         if (sv.size() == 6) {",
          "3077:           data.instructions[name] = any_cast<Instruction>(sv[5]);",
          "3080:         ope = any_cast<std::shared_ptr<Ope>>(sv[3]);",
          "3081:         if (sv.size() == 5) {",
          "3082:           data.instructions[name] = any_cast<Instruction>(sv[4]);",
          "",
          "[Added Lines]",
          "2824:     g[\"Definition\"] = [&](const SemanticValues &vs, std::any &dt) {",
          "2825:       Data &data = *std::any_cast<Data *>(dt);",
          "2827:       auto is_macro = vs.choice() == 0;",
          "2828:       auto ignore = std::any_cast<bool>(vs[0]);",
          "2829:       auto name = std::any_cast<std::string>(vs[1]);",
          "2834:         params = std::any_cast<std::vector<std::string>>(vs[2]);",
          "2835:         ope = std::any_cast<std::shared_ptr<Ope>>(vs[4]);",
          "2836:         if (vs.size() == 6) {",
          "2837:           data.instructions[name] = std::any_cast<Instruction>(vs[5]);",
          "2840:         ope = std::any_cast<std::shared_ptr<Ope>>(vs[3]);",
          "2841:         if (vs.size() == 5) {",
          "2842:           data.instructions[name] = std::any_cast<Instruction>(vs[4]);",
          "",
          "---------------",
          "--- Hunk 97 ---",
          "[Context before]",
          "3088:         auto &rule = grammar[name];",
          "3089:         rule <= ope;",
          "3090:         rule.name = name;",
          "3092:         rule.ignoreSemanticValue = ignore;",
          "3093:         rule.is_macro = is_macro;",
          "3094:         rule.params = params;",
          "3096:         if (data.start.empty()) {",
          "3097:           data.start = name;",
          "3099:         }",
          "3100:       } else {",
          "3102:       }",
          "3103:     };",
          "3108:       } else {",
          "3109:         std::vector<std::shared_ptr<Ope>> opes;",
          "3112:         }",
          "3113:         const std::shared_ptr<Ope> ope =",
          "3114:             std::make_shared<PrioritizedChoice>(opes);",
          "",
          "[Removed Lines]",
          "3091:         rule.s_ = sv.c_str();",
          "3098:           data.start_pos = sv.c_str();",
          "3101:         data.duplicates.emplace_back(name, sv.c_str());",
          "3105:     g[\"Expression\"] = [&](const SemanticValues &sv) {",
          "3106:       if (sv.size() == 1) {",
          "3107:         return any_cast<std::shared_ptr<Ope>>(sv[0]);",
          "3110:         for (auto i = 0u; i < sv.size(); i++) {",
          "3111:           opes.emplace_back(any_cast<std::shared_ptr<Ope>>(sv[i]));",
          "",
          "[Added Lines]",
          "2851:         rule.s_ = vs.sv().data();",
          "2858:           data.start_pos = vs.sv().data();",
          "2861:         data.duplicates.emplace_back(name, vs.sv().data());",
          "2865:     g[\"Expression\"] = [&](const SemanticValues &vs) {",
          "2866:       if (vs.size() == 1) {",
          "2867:         return std::any_cast<std::shared_ptr<Ope>>(vs[0]);",
          "2870:         for (auto i = 0u; i < vs.size(); i++) {",
          "2871:           opes.emplace_back(std::any_cast<std::shared_ptr<Ope>>(vs[i]));",
          "",
          "---------------",
          "--- Hunk 98 ---",
          "[Context before]",
          "3116:       }",
          "3117:     };",
          "3122:       } else {",
          "3123:         std::vector<std::shared_ptr<Ope>> opes;",
          "3126:         }",
          "3127:         const std::shared_ptr<Ope> ope = std::make_shared<Sequence>(opes);",
          "3128:         return ope;",
          "3129:       }",
          "3130:     };",
          "3133:       std::shared_ptr<Ope> ope;",
          "3136:       } else {",
          "3140:         if (tok == '&') {",
          "3141:           ope = apd(ope);",
          "3142:         } else { // '!'",
          "",
          "[Removed Lines]",
          "3119:     g[\"Sequence\"] = [&](const SemanticValues &sv) {",
          "3120:       if (sv.size() == 1) {",
          "3121:         return any_cast<std::shared_ptr<Ope>>(sv[0]);",
          "3124:         for (const auto &x : sv) {",
          "3125:           opes.emplace_back(any_cast<std::shared_ptr<Ope>>(x));",
          "3132:     g[\"Prefix\"] = [&](const SemanticValues &sv) {",
          "3134:       if (sv.size() == 1) {",
          "3135:         ope = any_cast<std::shared_ptr<Ope>>(sv[0]);",
          "3137:         assert(sv.size() == 2);",
          "3138:         auto tok = any_cast<char>(sv[0]);",
          "3139:         ope = any_cast<std::shared_ptr<Ope>>(sv[1]);",
          "",
          "[Added Lines]",
          "2879:     g[\"Sequence\"] = [&](const SemanticValues &vs) {",
          "2880:       if (vs.size() == 1) {",
          "2881:         return std::any_cast<std::shared_ptr<Ope>>(vs[0]);",
          "2884:         for (const auto &x : vs) {",
          "2885:           opes.emplace_back(std::any_cast<std::shared_ptr<Ope>>(x));",
          "2892:     g[\"Prefix\"] = [&](const SemanticValues &vs) {",
          "2894:       if (vs.size() == 1) {",
          "2895:         ope = std::any_cast<std::shared_ptr<Ope>>(vs[0]);",
          "2897:         assert(vs.size() == 2);",
          "2898:         auto tok = std::any_cast<char>(vs[0]);",
          "2899:         ope = std::any_cast<std::shared_ptr<Ope>>(vs[1]);",
          "",
          "---------------",
          "--- Hunk 99 ---",
          "[Context before]",
          "3152:       std::pair<size_t, size_t> range;",
          "3153:     };",
          "3158:         return ope;",
          "3159:       } else {",
          "3162:         switch (loop.type) {",
          "3163:         case Loop::Type::opt: return opt(ope);",
          "3164:         case Loop::Type::zom: return zom(ope);",
          "",
          "[Removed Lines]",
          "3155:     g[\"Suffix\"] = [&](const SemanticValues &sv) {",
          "3156:       auto ope = any_cast<std::shared_ptr<Ope>>(sv[0]);",
          "3157:       if (sv.size() == 1) {",
          "3160:         assert(sv.size() == 2);",
          "3161:         auto loop = any_cast<Loop>(sv[1]);",
          "",
          "[Added Lines]",
          "2915:     g[\"Suffix\"] = [&](const SemanticValues &vs) {",
          "2916:       auto ope = std::any_cast<std::shared_ptr<Ope>>(vs[0]);",
          "2917:       if (vs.size() == 1) {",
          "2920:         assert(vs.size() == 2);",
          "2921:         auto loop = std::any_cast<Loop>(vs[1]);",
          "",
          "---------------",
          "--- Hunk 100 ---",
          "[Context before]",
          "3169:       }",
          "3170:     };",
          "3174:       case 0: // Option",
          "3175:         return Loop{Loop::Type::opt, std::pair<size_t, size_t>()};",
          "3176:       case 1: // Zero or More",
          "",
          "[Removed Lines]",
          "3172:     g[\"Loop\"] = [&](const SemanticValues &sv) {",
          "3173:       switch (sv.choice()) {",
          "",
          "[Added Lines]",
          "2932:     g[\"Loop\"] = [&](const SemanticValues &vs) {",
          "2933:       switch (vs.choice()) {",
          "",
          "---------------",
          "--- Hunk 101 ---",
          "[Context before]",
          "3179:         return Loop{Loop::Type::oom, std::pair<size_t, size_t>()};",
          "3180:       default: // Regex-like repetition",
          "3181:         return Loop{Loop::Type::rep,",
          "3183:       }",
          "3184:     };",
          "3188:       case 0: { // Number COMMA Number",
          "3192:       }",
          "3193:       case 1: // Number COMMA",
          "3196:       case 2: { // Number",
          "3199:       }",
          "3200:       default: // COMMA Number",
          "3203:       }",
          "3204:     };",
          "3210:     };",
          "3216:       case 0:   // Macro Reference",
          "3217:       case 1: { // Reference",
          "3222:         std::vector<std::shared_ptr<Ope>> args;",
          "3223:         if (is_macro) {",
          "3225:         }",
          "3227:         std::shared_ptr<Ope> ope =",
          "3230:         if (ignore) {",
          "3231:           return ign(ope);",
          "",
          "[Removed Lines]",
          "3182:                     any_cast<std::pair<size_t, size_t>>(sv[0])};",
          "3186:     g[\"RepetitionRange\"] = [&](const SemanticValues &sv) {",
          "3187:       switch (sv.choice()) {",
          "3189:         auto min = any_cast<size_t>(sv[0]);",
          "3190:         auto max = any_cast<size_t>(sv[1]);",
          "3191:         return std::make_pair(min, max);",
          "3194:         return std::make_pair(any_cast<size_t>(sv[0]),",
          "3195:                               std::numeric_limits<size_t>::max());",
          "3197:         auto n = any_cast<size_t>(sv[0]);",
          "3198:         return std::make_pair(n, n);",
          "3201:         return std::make_pair(std::numeric_limits<size_t>::min(),",
          "3202:                               any_cast<size_t>(sv[0]));",
          "3205:     g[\"Number\"] = [&](const SemanticValues &sv) {",
          "3206:       std::stringstream ss(sv.str());",
          "3207:       size_t n;",
          "3208:       ss >> n;",
          "3209:       return n;",
          "3212:     g[\"Primary\"] = [&](const SemanticValues &sv, any &dt) {",
          "3213:       Data &data = *any_cast<Data *>(dt);",
          "3215:       switch (sv.choice()) {",
          "3218:         auto is_macro = sv.choice() == 0;",
          "3219:         auto ignore = any_cast<bool>(sv[0]);",
          "3220:         const auto &ident = any_cast<std::string>(sv[1]);",
          "3224:           args = any_cast<std::vector<std::shared_ptr<Ope>>>(sv[2]);",
          "3228:             ref(*data.grammar, ident, sv.c_str(), is_macro, args);",
          "",
          "[Added Lines]",
          "2942:                     std::any_cast<std::pair<size_t, size_t>>(vs[0])};",
          "2946:     g[\"RepetitionRange\"] = [&](const SemanticValues &vs) {",
          "2947:       switch (vs.choice()) {",
          "2949:         auto min = std::any_cast<size_t>(vs[0]);",
          "2950:         auto max = std::any_cast<size_t>(vs[1]);",
          "2951:         return std::pair(min, max);",
          "2954:         return std::pair(std::any_cast<size_t>(vs[0]),",
          "2955:                          std::numeric_limits<size_t>::max());",
          "2957:         auto n = std::any_cast<size_t>(vs[0]);",
          "2958:         return std::pair(n, n);",
          "2961:         return std::pair(std::numeric_limits<size_t>::min(),",
          "2962:                          std::any_cast<size_t>(vs[0]));",
          "2965:     g[\"Number\"] = [&](const SemanticValues &vs) {",
          "2966:       return vs.token_to_number<size_t>();",
          "2969:     g[\"Primary\"] = [&](const SemanticValues &vs, std::any &dt) {",
          "2970:       Data &data = *std::any_cast<Data *>(dt);",
          "2972:       switch (vs.choice()) {",
          "2975:         auto is_macro = vs.choice() == 0;",
          "2976:         auto ignore = std::any_cast<bool>(vs[0]);",
          "2977:         const auto &ident = std::any_cast<std::string>(vs[1]);",
          "2981:           args = std::any_cast<std::vector<std::shared_ptr<Ope>>>(vs[2]);",
          "2985:             ref(*data.grammar, ident, vs.sv().data(), is_macro, args);",
          "",
          "---------------",
          "--- Hunk 102 ---",
          "[Context before]",
          "3234:         }",
          "3235:       }",
          "3236:       case 2: { // (Expression)",
          "3238:       }",
          "3239:       case 3: { // TokenBoundary",
          "3241:       }",
          "3242:       case 4: { // CaptureScope",
          "3244:       }",
          "3245:       case 5: { // Capture",
          "3248:         return cap(ope, [name](const char *a_s, size_t a_n, Context &c) {",
          "3249:           auto &cs = c.capture_scope_stack[c.capture_scope_stack_size - 1];",
          "3250:           cs[name] = std::string(a_s, a_n);",
          "3251:         });",
          "3252:       }",
          "3253:       default: {",
          "3255:       }",
          "3256:       }",
          "3257:     };",
          "3261:     };",
          "3265:       return dic(items);",
          "3266:     };",
          "3271:     };",
          "3275:     };",
          "3279:     };",
          "3283:       return cls(ranges);",
          "3284:     };",
          "3287:       return ncls(ranges);",
          "3288:     };",
          "3291:       case 0: {",
          "3297:       }",
          "3298:       case 1: {",
          "3302:       }",
          "3303:       }",
          "3305:     };",
          "3308:     };",
          "3326:     };",
          "3330:     };",
          "3333:       PrecedenceClimbing::BinOpeInfo binOpeInfo;",
          "3334:       size_t level = 1;",
          "3337:         auto assoc = tokens[0][0];",
          "3338:         for (size_t i = 1; i < tokens.size(); i++) {",
          "3341:         }",
          "3342:         level++;",
          "3343:       }",
          "",
          "[Removed Lines]",
          "3237:         return any_cast<std::shared_ptr<Ope>>(sv[0]);",
          "3240:         return tok(any_cast<std::shared_ptr<Ope>>(sv[0]));",
          "3243:         return csc(any_cast<std::shared_ptr<Ope>>(sv[0]));",
          "3246:         const auto &name = any_cast<std::string>(sv[0]);",
          "3247:         auto ope = any_cast<std::shared_ptr<Ope>>(sv[1]);",
          "3254:         return any_cast<std::shared_ptr<Ope>>(sv[0]);",
          "3259:     g[\"IdentCont\"] = [](const SemanticValues &sv) {",
          "3260:       return std::string(sv.c_str(), sv.length());",
          "3263:     g[\"Dictionary\"] = [](const SemanticValues &sv) {",
          "3264:       auto items = sv.transform<std::string>();",
          "3268:     g[\"Literal\"] = [](const SemanticValues &sv) {",
          "3269:       const auto &tok = sv.tokens.front();",
          "3270:       return lit(resolve_escape_sequence(tok.first, tok.second));",
          "3272:     g[\"LiteralI\"] = [](const SemanticValues &sv) {",
          "3273:       const auto &tok = sv.tokens.front();",
          "3274:       return liti(resolve_escape_sequence(tok.first, tok.second));",
          "3276:     g[\"LiteralD\"] = [](const SemanticValues &sv) {",
          "3277:       auto &tok = sv.tokens.front();",
          "3278:       return resolve_escape_sequence(tok.first, tok.second);",
          "3281:     g[\"Class\"] = [](const SemanticValues &sv) {",
          "3282:       auto ranges = sv.transform<std::pair<char32_t, char32_t>>();",
          "3285:     g[\"NegatedClass\"] = [](const SemanticValues &sv) {",
          "3286:       auto ranges = sv.transform<std::pair<char32_t, char32_t>>();",
          "3289:     g[\"Range\"] = [](const SemanticValues &sv) {",
          "3290:       switch (sv.choice()) {",
          "3292:         auto s1 = any_cast<std::string>(sv[0]);",
          "3293:         auto s2 = any_cast<std::string>(sv[1]);",
          "3294:         auto cp1 = decode_codepoint(s1.c_str(), s1.length());",
          "3295:         auto cp2 = decode_codepoint(s2.c_str(), s2.length());",
          "3296:         return std::make_pair(cp1, cp2);",
          "3299:         auto s = any_cast<std::string>(sv[0]);",
          "3300:         auto cp = decode_codepoint(s.c_str(), s.length());",
          "3301:         return std::make_pair(cp, cp);",
          "3304:       return std::make_pair<char32_t, char32_t>(0, 0);",
          "3306:     g[\"Char\"] = [](const SemanticValues &sv) {",
          "3307:       return resolve_escape_sequence(sv.c_str(), sv.length());",
          "3310:     g[\"AND\"] = [](const SemanticValues &sv) { return *sv.c_str(); };",
          "3311:     g[\"NOT\"] = [](const SemanticValues &sv) { return *sv.c_str(); };",
          "3312:     g[\"QUESTION\"] = [](const SemanticValues &sv) { return *sv.c_str(); };",
          "3313:     g[\"STAR\"] = [](const SemanticValues &sv) { return *sv.c_str(); };",
          "3314:     g[\"PLUS\"] = [](const SemanticValues &sv) { return *sv.c_str(); };",
          "3316:     g[\"DOT\"] = [](const SemanticValues & /*sv*/) { return dot(); };",
          "3318:     g[\"BeginCap\"] = [](const SemanticValues &sv) { return sv.token(); };",
          "3320:     g[\"BackRef\"] = [&](const SemanticValues &sv) { return bkr(sv.token()); };",
          "3322:     g[\"Ignore\"] = [](const SemanticValues &sv) { return sv.size() > 0; };",
          "3324:     g[\"Parameters\"] = [](const SemanticValues &sv) {",
          "3325:       return sv.transform<std::string>();",
          "3328:     g[\"Arguments\"] = [](const SemanticValues &sv) {",
          "3329:       return sv.transform<std::shared_ptr<Ope>>();",
          "3332:     g[\"PrecedenceClimbing\"] = [](const SemanticValues &sv) {",
          "3335:       for (auto v : sv) {",
          "3336:         auto tokens = any_cast<std::vector<std::string>>(v);",
          "3339:           const auto &tok = tokens[i];",
          "3340:           binOpeInfo[tok] = std::make_pair(level, assoc);",
          "",
          "[Added Lines]",
          "2994:         return std::any_cast<std::shared_ptr<Ope>>(vs[0]);",
          "2997:         return tok(std::any_cast<std::shared_ptr<Ope>>(vs[0]));",
          "3000:         return csc(std::any_cast<std::shared_ptr<Ope>>(vs[0]));",
          "3003:         const auto &name = std::any_cast<std::string_view>(vs[0]);",
          "3004:         auto ope = std::any_cast<std::shared_ptr<Ope>>(vs[1]);",
          "3011:         return std::any_cast<std::shared_ptr<Ope>>(vs[0]);",
          "3016:     g[\"IdentCont\"] = [](const SemanticValues &vs) {",
          "3017:       return std::string(vs.sv().data(), vs.sv().length());",
          "3020:     g[\"Dictionary\"] = [](const SemanticValues &vs) {",
          "3021:       auto items = vs.transform<std::string>();",
          "3025:     g[\"Literal\"] = [](const SemanticValues &vs) {",
          "3026:       const auto &tok = vs.tokens.front();",
          "3027:       return lit(resolve_escape_sequence(tok.data(), tok.size()));",
          "3029:     g[\"LiteralI\"] = [](const SemanticValues &vs) {",
          "3030:       const auto &tok = vs.tokens.front();",
          "3031:       return liti(resolve_escape_sequence(tok.data(), tok.size()));",
          "3033:     g[\"LiteralD\"] = [](const SemanticValues &vs) {",
          "3034:       auto &tok = vs.tokens.front();",
          "3035:       return resolve_escape_sequence(tok.data(), tok.size());",
          "3038:     g[\"Class\"] = [](const SemanticValues &vs) {",
          "3039:       auto ranges = vs.transform<std::pair<char32_t, char32_t>>();",
          "3042:     g[\"NegatedClass\"] = [](const SemanticValues &vs) {",
          "3043:       auto ranges = vs.transform<std::pair<char32_t, char32_t>>();",
          "3046:     g[\"Range\"] = [](const SemanticValues &vs) {",
          "3047:       switch (vs.choice()) {",
          "3049:         auto s1 = std::any_cast<std::string>(vs[0]);",
          "3050:         auto s2 = std::any_cast<std::string>(vs[1]);",
          "3051:         auto cp1 = decode_codepoint(s1.data(), s1.length());",
          "3052:         auto cp2 = decode_codepoint(s2.data(), s2.length());",
          "3053:         return std::pair(cp1, cp2);",
          "3056:         auto s = std::any_cast<std::string>(vs[0]);",
          "3057:         auto cp = decode_codepoint(s.data(), s.length());",
          "3058:         return std::pair(cp, cp);",
          "3061:       return std::pair<char32_t, char32_t>(0, 0);",
          "3063:     g[\"Char\"] = [](const SemanticValues &vs) {",
          "3064:       return resolve_escape_sequence(vs.sv().data(), vs.sv().length());",
          "3067:     g[\"AND\"] = [](const SemanticValues &vs) { return *vs.sv().data(); };",
          "3068:     g[\"NOT\"] = [](const SemanticValues &vs) { return *vs.sv().data(); };",
          "3069:     g[\"QUESTION\"] = [](const SemanticValues &vs) { return *vs.sv().data(); };",
          "3070:     g[\"STAR\"] = [](const SemanticValues &vs) { return *vs.sv().data(); };",
          "3071:     g[\"PLUS\"] = [](const SemanticValues &vs) { return *vs.sv().data(); };",
          "3073:     g[\"DOT\"] = [](const SemanticValues & /*vs*/) { return dot(); };",
          "3075:     g[\"BeginCap\"] = [](const SemanticValues &vs) { return vs.token(); };",
          "3077:     g[\"BackRef\"] = [&](const SemanticValues &vs) {",
          "3078:       return bkr(vs.token_to_string());",
          "3079:     };",
          "3081:     g[\"Ignore\"] = [](const SemanticValues &vs) { return vs.size() > 0; };",
          "3083:     g[\"Parameters\"] = [](const SemanticValues &vs) {",
          "3084:       return vs.transform<std::string>();",
          "3087:     g[\"Arguments\"] = [](const SemanticValues &vs) {",
          "3088:       return vs.transform<std::shared_ptr<Ope>>();",
          "3091:     g[\"PrecedenceClimbing\"] = [](const SemanticValues &vs) {",
          "3094:       for (auto v : vs) {",
          "3095:         auto tokens = std::any_cast<std::vector<std::string_view>>(v);",
          "3098:           binOpeInfo[tokens[i]] = std::pair(level, assoc);",
          "",
          "---------------",
          "--- Hunk 103 ---",
          "[Context before]",
          "3346:       instruction.data = binOpeInfo;",
          "3347:       return instruction;",
          "3348:     };",
          "3351:     };",
          "3354:   }",
          "3356:   bool apply_precedence_instruction(Definition &rule,",
          "",
          "[Removed Lines]",
          "3349:     g[\"PrecedenceInfo\"] = [](const SemanticValues &sv) {",
          "3350:       return sv.transform<std::string>();",
          "3352:     g[\"PrecedenceOpe\"] = [](const SemanticValues &sv) { return sv.token(); };",
          "3353:     g[\"PrecedenceAssoc\"] = [](const SemanticValues &sv) { return sv.token(); };",
          "",
          "[Added Lines]",
          "3107:     g[\"PrecedenceInfo\"] = [](const SemanticValues &vs) {",
          "3108:       return vs.transform<std::string_view>();",
          "3110:     g[\"PrecedenceOpe\"] = [](const SemanticValues &vs) { return vs.token(); };",
          "3111:     g[\"PrecedenceAssoc\"] = [](const SemanticValues &vs) { return vs.token(); };",
          "",
          "---------------",
          "--- Hunk 104 ---",
          "[Context before]",
          "3396:                                         const Rules &rules, std::string &start,",
          "3397:                                         Log log) {",
          "3398:     Data data;",
          "3400:     auto r = g[\"Grammar\"].parse(s, n, dt);",
          "3402:     if (!r.ret) {",
          "",
          "[Removed Lines]",
          "3399:     any dt = &data;",
          "",
          "[Added Lines]",
          "3157:     std::any dt = &data;",
          "",
          "---------------",
          "--- Hunk 105 ---",
          "[Context before]",
          "3418:     for (const auto &x : rules) {",
          "3419:       auto name = x.first;",
          "3421:       if (!name.empty() && name[0] == '~') {",
          "3422:         ignore = true;",
          "3423:         name.erase(0, 1);",
          "",
          "[Removed Lines]",
          "3420:       bool ignore = false;",
          "",
          "[Added Lines]",
          "3178:       auto ignore = false;",
          "",
          "---------------",
          "--- Hunk 106 ---",
          "[Context before]",
          "3431:     }",
          "3436:     for (const auto &x : data.duplicates) {",
          "3437:       if (log) {",
          "",
          "[Removed Lines]",
          "3434:     bool ret = data.duplicates.empty();",
          "",
          "[Added Lines]",
          "3192:     auto ret = data.duplicates.empty();",
          "",
          "---------------",
          "--- Hunk 107 ---",
          "[Context before]",
          "3547:       if (instruction.type == \"precedence\") {",
          "3548:         const auto &info =",
          "3551:         if (!apply_precedence_instruction(rule, info, s, log)) {",
          "3552:           return nullptr;",
          "",
          "[Removed Lines]",
          "3549:             any_cast<PrecedenceClimbing::BinOpeInfo>(instruction.data);",
          "",
          "[Added Lines]",
          "3307:             std::any_cast<PrecedenceClimbing::BinOpeInfo>(instruction.data);",
          "",
          "---------------",
          "--- Hunk 108 ---",
          "[Context before]",
          "3581:         nodes(a_nodes) {}",
          "3583:   AstBase(const char *a_path, size_t a_line, size_t a_column,",
          "3586:       : path(a_path ? a_path : \"\"), line(a_line), column(a_column),",
          "3587:         name(a_name), position(a_position), length(a_length),",
          "3588:         choice_count(a_choice_count), choice(a_choice), original_name(a_name),",
          "",
          "[Removed Lines]",
          "3584:           const char *a_name, const std::string &a_token, size_t a_position = 0,",
          "3585:           size_t a_length = 0, size_t a_choice_count = 0, size_t a_choice = 0)",
          "",
          "[Added Lines]",
          "3342:           const char *a_name, const std::string_view &a_token,",
          "3343:           size_t a_position = 0, size_t a_length = 0, size_t a_choice_count = 0,",
          "3344:           size_t a_choice = 0)",
          "",
          "---------------",
          "--- Hunk 109 ---",
          "[Context before]",
          "3617:   const unsigned int original_tag;",
          "3619:   const bool is_token;",
          "3622:   std::vector<std::shared_ptr<AstBase<Annotation>>> nodes;",
          "3623:   std::weak_ptr<AstBase<Annotation>> parent;",
          "3624: };",
          "3626: template <typename T>",
          "",
          "[Removed Lines]",
          "3620:   const std::string token;",
          "",
          "[Added Lines]",
          "3379:   const std::string_view token;",
          "3384:   std::string token_to_string() const {",
          "3385:     assert(is_token);",
          "3386:     return std::string(token);",
          "3387:   }",
          "3389:   template <typename T> T token_to_number() const {",
          "3390:     assert(is_token);",
          "3391:     T n = 0;",
          "3392:     std::from_chars(token.data(), token.data() + token.size(), n);",
          "3393:     return n;",
          "3394:   }",
          "",
          "---------------",
          "--- Hunk 110 ---",
          "[Context before]",
          "3636:   }",
          "3637:   if (ast.name != ast.original_name) { name += \"[\" + ast.name + \"]\"; }",
          "3638:   if (ast.is_token) {",
          "3640:   } else {",
          "3641:     s += \"+ \" + name + \"\\n\";",
          "3642:   }",
          "",
          "[Removed Lines]",
          "3639:     s += \"- \" + name + \" (\" + ast.token + \")\\n\";",
          "",
          "[Added Lines]",
          "3410:     s += \"- \" + name + \" (\";",
          "3411:     s += ast.token;",
          "3412:     s += \")\\n\";",
          "",
          "---------------",
          "--- Hunk 111 ---",
          "[Context before]",
          "3669:     if (opt && original->nodes.size() == 1) {",
          "3670:       auto child = optimize(original->nodes[0], parent);",
          "3672:                                  original->choice_count, original->position,",
          "3673:                                  original->length, original->choice);",
          "3674:     }",
          "",
          "[Removed Lines]",
          "3671:       return std::make_shared<T>(*child, original->name.c_str(),",
          "",
          "[Added Lines]",
          "3444:       return std::make_shared<T>(*child, original->name.data(),",
          "",
          "---------------",
          "--- Hunk 112 ---",
          "[Context before]",
          "3689: };",
          "3691: struct EmptyType {};",
          "3694: template <typename T = Ast> void add_ast_action(Definition &rule) {",
          "3698:     if (rule.is_token()) {",
          "3703:     }",
          "3710:     for (auto node : ast->nodes) {",
          "3711:       node->parent = ast;",
          "",
          "[Removed Lines]",
          "3692: typedef AstBase<EmptyType> Ast;",
          "3695:   rule.action = [&](const SemanticValues &sv) {",
          "3696:     auto line = sv.line_info();",
          "3699:       return std::make_shared<T>(sv.path, line.first, line.second,",
          "3700:                                  rule.name.c_str(), sv.token(),",
          "3701:                                  std::distance(sv.ss, sv.c_str()), sv.length(),",
          "3702:                                  sv.choice_count(), sv.choice());",
          "3705:     auto ast = std::make_shared<T>(",
          "3706:         sv.path, line.first, line.second, rule.name.c_str(),",
          "3707:         sv.transform<std::shared_ptr<T>>(), std::distance(sv.ss, sv.c_str()),",
          "3708:         sv.length(), sv.choice_count(), sv.choice());",
          "",
          "[Added Lines]",
          "3465: using Ast = AstBase<EmptyType>;",
          "3468:   rule.action = [&](const SemanticValues &vs) {",
          "3469:     auto line = vs.line_info();",
          "3472:       return std::make_shared<T>(",
          "3473:           vs.path, line.first, line.second, rule.name.data(), vs.token(),",
          "3474:           std::distance(vs.ss, vs.sv().data()), vs.sv().length(),",
          "3475:           vs.choice_count(), vs.choice());",
          "3478:     auto ast =",
          "3479:         std::make_shared<T>(vs.path, line.first, line.second, rule.name.data(),",
          "3480:                             vs.transform<std::shared_ptr<T>>(),",
          "3481:                             std::distance(vs.ss, vs.sv().data()),",
          "3482:                             vs.sv().length(), vs.choice_count(), vs.choice());",
          "",
          "---------------",
          "--- Hunk 113 ---",
          "[Context before]",
          "3899:     return parse_n(s, n, path);",
          "3900:   }",
          "3903:                const char *path = nullptr) const {",
          "3904:     if (grammar_ != nullptr) {",
          "3905:       const auto &rule = (*grammar_)[start_];",
          "",
          "[Removed Lines]",
          "3902:   bool parse_n(const char *s, size_t n, any &dt,",
          "",
          "[Added Lines]",
          "3676:   bool parse_n(const char *s, size_t n, std::any &dt,",
          "",
          "---------------",
          "--- Hunk 114 ---",
          "[Context before]",
          "3910:     return false;",
          "3911:   }",
          "3914:     auto n = strlen(s);",
          "3915:     return parse_n(s, n, dt, path);",
          "3916:   }",
          "",
          "[Removed Lines]",
          "3913:   bool parse(const char *s, any &dt, const char *path = nullptr) const {",
          "",
          "[Added Lines]",
          "3687:   bool parse(const char *s, std::any &dt, const char *path = nullptr) const {",
          "",
          "---------------",
          "--- Hunk 115 ---",
          "[Context before]",
          "3934:   }",
          "3936:   template <typename T>",
          "3938:                const char *path = nullptr) const {",
          "3939:     if (grammar_ != nullptr) {",
          "3940:       const auto &rule = (*grammar_)[start_];",
          "",
          "[Removed Lines]",
          "3937:   bool parse_n(const char *s, size_t n, any &dt, T &val,",
          "",
          "[Added Lines]",
          "3711:   bool parse_n(const char *s, size_t n, std::any &dt, T &val,",
          "",
          "---------------",
          "--- Hunk 116 ---",
          "[Context before]",
          "3946:   }",
          "3948:   template <typename T>",
          "3950:              const char * /*path*/ = nullptr) const {",
          "3951:     auto n = strlen(s);",
          "3952:     return parse_n(s, n, dt, val);",
          "",
          "[Removed Lines]",
          "3949:   bool parse(const char *s, any &dt, T &val,",
          "",
          "[Added Lines]",
          "3723:   bool parse(const char *s, std::any &dt, T &val,",
          "",
          "---------------",
          "--- Hunk 117 ---",
          "[Context before]",
          "4013: };",
          "4015: } // namespace peg",
          "",
          "[Removed Lines]",
          "4017: #endif",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "pl0/pl0.cc||pl0/pl0.cc": [
          "File: pl0/pl0.cc -> pl0/pl0.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "183:     const auto& nodes = ast->nodes;",
          "184:     for (auto i = 0u; i < nodes.size(); i += 2) {",
          "186:       if (scope->has_symbol(ident)) {",
          "187:         throw_runtime_error(nodes[i], \"'\" + ident + \"' is already defined...\");",
          "188:       }",
          "190:       scope->constants.emplace(ident, number);",
          "191:     }",
          "192:   }",
          "",
          "[Removed Lines]",
          "185:       const auto& ident = nodes[i + 0]->token;",
          "189:       auto number = stoi(nodes[i + 1]->token);",
          "",
          "[Added Lines]",
          "185:       const auto& ident = nodes[i + 0]->token_to_string();",
          "189:       auto number = nodes[i + 1]->token_to_number<int>();",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "197:     const auto& nodes = ast->nodes;",
          "198:     for (auto i = 0u; i < nodes.size(); i += 1) {",
          "200:       if (scope->has_symbol(ident)) {",
          "201:         throw_runtime_error(nodes[i], \"'\" + ident + \"' is already defined...\");",
          "202:       }",
          "",
          "[Removed Lines]",
          "199:       const auto& ident = nodes[i]->token;",
          "",
          "[Added Lines]",
          "199:       const auto& ident = nodes[i]->token_to_string();",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "210:     const auto& nodes = ast->nodes;",
          "211:     for (auto i = 0u; i < nodes.size(); i += 2) {",
          "213:       auto block = nodes[i + 1];",
          "214:       scope->procedures[ident] = block;",
          "215:       build_on_ast(block, scope);",
          "",
          "[Removed Lines]",
          "212:       const auto& ident = nodes[i + 0]->token;",
          "",
          "[Added Lines]",
          "212:       const auto& ident = nodes[i + 0]->token_to_string();",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "219:   static void assignment(const shared_ptr<AstPL0> ast,",
          "220:                          shared_ptr<SymbolScope> scope) {",
          "223:     if (scope->has_constant(ident)) {",
          "224:       throw_runtime_error(ast->nodes[0],",
          "225:                           \"cannot modify constant value '\" + ident + \"'...\");",
          "",
          "[Removed Lines]",
          "222:     const auto& ident = ast->nodes[0]->token;",
          "",
          "[Added Lines]",
          "222:     const auto& ident = ast->nodes[0]->token_to_string();",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "238:   static void call(const shared_ptr<AstPL0> ast,",
          "239:                    shared_ptr<SymbolScope> scope) {",
          "242:     if (!scope->has_procedure(ident)) {",
          "243:       throw_runtime_error(ast->nodes[0],",
          "244:                           \"undefined procedure '\" + ident + \"'...\");",
          "",
          "[Removed Lines]",
          "241:     const auto& ident = ast->nodes[0]->token;",
          "",
          "[Added Lines]",
          "241:     const auto& ident = ast->nodes[0]->token_to_string();",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "257:   static void ident(const shared_ptr<AstPL0> ast,",
          "258:                     shared_ptr<SymbolScope> scope) {",
          "260:     if (!scope->has_symbol(ident)) {",
          "261:       throw_runtime_error(ast, \"undefined variable '\" + ident + \"'...\");",
          "262:     }",
          "",
          "[Removed Lines]",
          "259:     const auto& ident = ast->token;",
          "",
          "[Added Lines]",
          "259:     const auto& ident = ast->token_to_string();",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "360:   static void exec_assignment(const shared_ptr<AstPL0> ast,",
          "361:                               shared_ptr<Environment> env) {",
          "364:   }",
          "366:   static void exec_call(const shared_ptr<AstPL0> ast,",
          "367:                         shared_ptr<Environment> env) {",
          "370:   }",
          "372:   static void exec_statements(const shared_ptr<AstPL0> ast,",
          "",
          "[Removed Lines]",
          "363:     env->set_variable(ast->nodes[0]->token, eval(ast->nodes[1], env));",
          "369:     exec_block(env->get_procedure(ast->nodes[0]->token), env);",
          "",
          "[Added Lines]",
          "363:     env->set_variable(ast->nodes[0]->token_to_string(), eval(ast->nodes[1], env));",
          "369:     exec_block(env->get_procedure(ast->nodes[0]->token_to_string()), env);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "407:     int val;",
          "408:     cin >> val;",
          "410:   }",
          "412:   static bool eval_condition(const shared_ptr<AstPL0> ast,",
          "",
          "[Removed Lines]",
          "409:     env->set_variable(ast->nodes[0]->token, val);",
          "",
          "[Added Lines]",
          "409:     env->set_variable(ast->nodes[0]->token_to_string(), val);",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "435:     const auto& nodes = ast->nodes;",
          "436:     auto lval = eval_expression(nodes[0], env);",
          "438:     auto rval = eval_expression(nodes[2], env);",
          "439:     switch (op) {",
          "440:       case \"=\"_:",
          "",
          "[Removed Lines]",
          "437:     auto op = peg::str2tag(nodes[1]->token.c_str());",
          "",
          "[Added Lines]",
          "437:     auto op = peg::str2tag(nodes[1]->token_to_string().c_str());",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "473:                              shared_ptr<Environment> env) {",
          "475:     const auto& nodes = ast->nodes;",
          "477:     auto sign_val = (sign.empty() || sign == \"+\") ? 1 : -1;",
          "478:     auto val = eval(nodes[1], env) * sign_val;",
          "479:     for (auto i = 2u; i < nodes.size(); i += 2) {",
          "481:       auto rval = eval(nodes[i + 1], env);",
          "482:       switch (ope) {",
          "483:         case '+':",
          "",
          "[Removed Lines]",
          "476:     auto sign = nodes[0]->token;",
          "480:       auto ope = nodes[i + 0]->token[0];",
          "",
          "[Added Lines]",
          "476:     auto sign = nodes[0]->token_to_string();",
          "480:       auto ope = nodes[i + 0]->token_to_string()[0];",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "497:     const auto& nodes = ast->nodes;",
          "498:     auto val = eval(nodes[0], env);",
          "499:     for (auto i = 1u; i < nodes.size(); i += 2) {",
          "501:       auto rval = eval(nodes[i + 1], env);",
          "502:       switch (ope) {",
          "503:         case '*':",
          "",
          "[Removed Lines]",
          "500:       auto ope = nodes[i + 0]->token[0];",
          "",
          "[Added Lines]",
          "500:       auto ope = nodes[i + 0]->token_to_string()[0];",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "517:   static int eval_ident(const shared_ptr<AstPL0> ast,",
          "518:                         shared_ptr<Environment> env) {",
          "520:   }",
          "522:   static int eval_number(const shared_ptr<AstPL0> ast,",
          "523:                          shared_ptr<Environment> env) {",
          "525:   }",
          "526: };",
          "",
          "[Removed Lines]",
          "519:     return env->get_value(ast, ast->token);",
          "524:     return stol(ast->token);",
          "",
          "[Added Lines]",
          "519:     return env->get_value(ast, ast->token_to_string());",
          "524:     return stol(ast->token_to_string());",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "654:   void compile_const(const shared_ptr<AstPL0> ast) {",
          "655:     for (auto i = 0u; i < ast->nodes.size(); i += 2) {",
          "659:       auto alloca =",
          "660:           builder_.CreateAlloca(builder_.getInt32Ty(), nullptr, ident);",
          "",
          "[Removed Lines]",
          "656:       auto ident = ast->nodes[i]->token;",
          "657:       auto number = stoi(ast->nodes[i + 1]->token);",
          "",
          "[Added Lines]",
          "656:       auto ident = ast->nodes[i]->token_to_string();",
          "657:       auto number = stoi(ast->nodes[i + 1]->token_to_string());",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "665:   void compile_var(const shared_ptr<AstPL0> ast) {",
          "666:     for (const auto node : ast->nodes) {",
          "668:       builder_.CreateAlloca(builder_.getInt32Ty(), nullptr, ident);",
          "669:     }",
          "670:   }",
          "672:   void compile_procedure(const shared_ptr<AstPL0> ast) {",
          "673:     for (auto i = 0u; i < ast->nodes.size(); i += 2) {",
          "675:       auto block = ast->nodes[i + 1];",
          "677:       std::vector<Type*> pt(block->scope->free_variables.size(),",
          "",
          "[Removed Lines]",
          "667:       auto ident = node->token;",
          "674:       auto ident = ast->nodes[i]->token;",
          "",
          "[Added Lines]",
          "667:       auto ident = node->token_to_string();",
          "674:       auto ident = ast->nodes[i]->token_to_string();",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "712:   }",
          "714:   void compile_assignment(const shared_ptr<AstPL0> ast) {",
          "717:     auto fn = builder_.GetInsertBlock()->getParent();",
          "718:     auto tbl = fn->getValueSymbolTable();",
          "",
          "[Removed Lines]",
          "715:     auto ident = ast->nodes[0]->token;",
          "",
          "[Added Lines]",
          "715:     auto ident = ast->nodes[0]->token_to_string();",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "726:   }",
          "728:   void compile_call(const shared_ptr<AstPL0> ast) {",
          "731:     auto scope = get_closest_scope(ast);",
          "732:     auto block = scope->get_procedure(ident);",
          "",
          "[Removed Lines]",
          "729:     auto ident = ast->nodes[0]->token;",
          "",
          "[Added Lines]",
          "729:     auto ident = ast->nodes[0]->token_to_string();",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "805:     auto lhs = compile_expression(ast->nodes[0]);",
          "806:     auto rhs = compile_expression(ast->nodes[2]);",
          "809:     switch (ope[0]) {",
          "810:       case '=':",
          "811:         return builder_.CreateICmpEQ(lhs, rhs, \"icmpeq\");",
          "",
          "[Removed Lines]",
          "808:     const auto& ope = ast->nodes[1]->token;",
          "",
          "[Added Lines]",
          "808:     const auto& ope = ast->nodes[1]->token_to_string();",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "836:   Value* compile_expression(const shared_ptr<AstPL0> ast) {",
          "837:     const auto& nodes = ast->nodes;",
          "840:     auto negative = !(sign.empty() || sign == \"+\");",
          "842:     auto val = compile_term(nodes[1]);",
          "",
          "[Removed Lines]",
          "839:     auto sign = nodes[0]->token;",
          "",
          "[Added Lines]",
          "839:     auto sign = nodes[0]->token_to_string();",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "845:     }",
          "847:     for (auto i = 2u; i < nodes.size(); i += 2) {",
          "849:       auto rval = compile_term(nodes[i + 1]);",
          "850:       switch (ope) {",
          "851:         case '+':",
          "",
          "[Removed Lines]",
          "848:       auto ope = nodes[i + 0]->token[0];",
          "",
          "[Added Lines]",
          "848:       auto ope = nodes[i + 0]->token_to_string()[0];",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "863:     const auto& nodes = ast->nodes;",
          "864:     auto val = compile_factor(nodes[0]);",
          "865:     for (auto i = 1u; i < nodes.size(); i += 2) {",
          "867:       auto rval = compile_switch_value(nodes[i + 1]);",
          "868:       switch (ope) {",
          "869:         case '*':",
          "",
          "[Removed Lines]",
          "866:       auto ope = nodes[i + 0]->token[0];",
          "",
          "[Added Lines]",
          "866:       auto ope = nodes[i + 0]->token_to_string()[0];",
          "",
          "---------------",
          "--- Hunk 21 ---",
          "[Context before]",
          "889:   }",
          "891:   Value* compile_ident(const shared_ptr<AstPL0> ast) {",
          "894:     auto fn = builder_.GetInsertBlock()->getParent();",
          "895:     auto tbl = fn->getValueSymbolTable();",
          "",
          "[Removed Lines]",
          "892:     auto ident = ast->token;",
          "",
          "[Added Lines]",
          "892:     auto ident = ast->token_to_string();",
          "",
          "---------------",
          "--- Hunk 22 ---",
          "[Context before]",
          "904:   Value* compile_number(const shared_ptr<AstPL0> ast) {",
          "905:     return ConstantInt::getIntegerValue(builder_.getInt32Ty(),",
          "907:   }",
          "908: };",
          "",
          "[Removed Lines]",
          "906:                                         APInt(32, ast->token, 10));",
          "",
          "[Added Lines]",
          "906:                                         APInt(32, ast->token_to_string(), 10));",
          "",
          "---------------"
        ],
        "test/test1.cc||test/test1.cc": [
          "File: test/test1.cc -> test/test1.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "4: using namespace peg;",
          "6: #if !defined(PEGLIB_NO_UNICODE_CHARS)",
          "16: }",
          "17: #endif",
          "22:         ROOT <- _",
          "23:         _ <- ' '",
          "24:     )\");",
          "28: }",
          "35: }",
          "40:         ~ROOT <- _",
          "41:         _ <- ' '",
          "42:     )\");",
          "46: }",
          "57: }",
          "62:         ROOT <- _",
          "63:         _ <- '\\\\'",
          "64:     )\");",
          "68: }",
          "73:         ROOT <- _",
          "74:         _ <- '\\'",
          "75:     )\");",
          "79: }",
          "84:         ROOT <- TEXT",
          "85:         TEXT <- [a-zA-Z]+",
          "86:     )\");",
          "102: }",
          "107:         ROOT      <-  _ ('[' TAG_NAME ']' _)*",
          "108:         TAG_NAME  <-  (!']' .)+",
          "109:         _         <-  [ \\t]*",
          "110:     )\");",
          "125: }",
          "127: using namespace peg;",
          "146: }",
          "151:         ROOT  <- _ TOKEN*",
          "152:         TOKEN <- '[' < (!']' .)+ > ']' _",
          "153:         _     <- [ \\t\\r\\n]*",
          "154:     )\");",
          "170: }",
          "179: }",
          "194: }",
          "199:         EXPRESSION       <-  _ TERM (TERM_OPERATOR TERM)*",
          "200:         TERM             <-  FACTOR (FACTOR_OPERATOR FACTOR)*",
          "201:         FACTOR           <-  NUMBER / '(' _ EXPRESSION ')' _",
          "",
          "[Removed Lines]",
          "7: TEST_CASE(\"Simple syntax test (with unicode)\", \"[general]\")",
          "8: {",
          "9:     parser parser(",
          "10:         u8\" ROOT \u2190 _ \"",
          "11:         \" _ <- ' ' \"",
          "12:     );",
          "14:     bool ret = parser;",
          "15:     REQUIRE(ret == true);",
          "19: TEST_CASE(\"Simple syntax test\", \"[general]\")",
          "20: {",
          "21:     parser parser(R\"(",
          "26:     bool ret = parser;",
          "27:     REQUIRE(ret == true);",
          "30: TEST_CASE(\"Empty syntax test\", \"[general]\")",
          "31: {",
          "32:     parser parser(\"\");",
          "33:     bool ret = parser;",
          "34:     REQUIRE(ret == false);",
          "37: TEST_CASE(\"Start rule with ignore operator test\", \"[general]\")",
          "38: {",
          "39:     parser parser(R\"(",
          "44:     bool ret = parser;",
          "45:     REQUIRE(ret == false);",
          "48: TEST_CASE(\"Invalid UTF-8 text test\", \"[general]\")",
          "49: {",
          "50:     std::string s = \"a <- '\";",
          "51:     s += static_cast<char>(0xe8); // Make invalid utf8 text...",
          "53:     parser parser(s.c_str());",
          "55:     bool ret = parser;",
          "56:     REQUIRE(ret == false);",
          "59: TEST_CASE(\"Backslash escape sequence test\", \"[general]\")",
          "60: {",
          "61:     parser parser(R\"(",
          "66:     bool ret = parser;",
          "67:     REQUIRE(ret == true);",
          "70: TEST_CASE(\"Invalid escape sequence test\", \"[general]\")",
          "71: {",
          "72:     parser parser(R\"(",
          "77:     bool ret = parser;",
          "78:     REQUIRE(ret == false);",
          "81: TEST_CASE(\"Action taking non const Semantic Values parameter\", \"[general]\")",
          "82: {",
          "83:     parser parser(R\"(",
          "88:     parser[\"ROOT\"] = [&](SemanticValues& sv) {",
          "89:         auto s = any_cast<std::string>(sv[0]);",
          "90:         s[0] = 'H'; // mutate",
          "91:         return std::string(std::move(s)); // move",
          "92:     };",
          "94:     parser[\"TEXT\"] = [&](SemanticValues& sv) {",
          "95:         return sv.token();",
          "96:     };",
          "98:     std::string val;",
          "99:     auto ret = parser.parse(\"hello\", val);",
          "100:     REQUIRE(ret == true);",
          "101:     REQUIRE(val == \"Hello\");",
          "104: TEST_CASE(\"String capture test\", \"[general]\")",
          "105: {",
          "106:     parser parser(R\"(",
          "112:     std::vector<std::string> tags;",
          "114:     parser[\"TAG_NAME\"] = [&](const SemanticValues& sv) {",
          "115:         tags.push_back(sv.str());",
          "116:     };",
          "118:     auto ret = parser.parse(\" [tag1] [tag:2] [tag-3] \");",
          "120:     REQUIRE(ret == true);",
          "121:     REQUIRE(tags.size() == 3);",
          "122:     REQUIRE(tags[0] == \"tag1\");",
          "123:     REQUIRE(tags[1] == \"tag:2\");",
          "124:     REQUIRE(tags[2] == \"tag-3\");",
          "129: TEST_CASE(\"String capture test2\", \"[general]\")",
          "130: {",
          "131:     std::vector<std::string> tags;",
          "133:     Definition ROOT, TAG, TAG_NAME, WS;",
          "134:     ROOT     <= seq(WS, zom(TAG));",
          "135:     TAG      <= seq(chr('['), TAG_NAME, chr(']'), WS);",
          "136:     TAG_NAME <= oom(seq(npd(chr(']')), dot())), [&](const SemanticValues& sv) { tags.push_back(sv.str()); };",
          "137:     WS       <= zom(cls(\" \\t\"));",
          "139:     auto r = ROOT.parse(\" [tag1] [tag:2] [tag-3] \");",
          "141:     REQUIRE(r.ret == true);",
          "142:     REQUIRE(tags.size() == 3);",
          "143:     REQUIRE(tags[0] == \"tag1\");",
          "144:     REQUIRE(tags[1] == \"tag:2\");",
          "145:     REQUIRE(tags[2] == \"tag-3\");",
          "148: TEST_CASE(\"String capture test3\", \"[general]\")",
          "149: {",
          "150:     parser pg(R\"(",
          "157:     std::vector<std::string> tags;",
          "159:     pg[\"TOKEN\"] = [&](const SemanticValues& sv) {",
          "160:         tags.push_back(sv.token());",
          "161:     };",
          "163:     auto ret = pg.parse(\" [tag1] [tag:2] [tag-3] \");",
          "165:     REQUIRE(ret == true);",
          "166:     REQUIRE(tags.size() == 3);",
          "167:     REQUIRE(tags[0] == \"tag1\");",
          "168:     REQUIRE(tags[1] == \"tag:2\");",
          "169:     REQUIRE(tags[2] == \"tag-3\");",
          "172: TEST_CASE(\"Cyclic grammer test\", \"[general]\")",
          "173: {",
          "174:     Definition PARENT;",
          "175:     Definition CHILD;",
          "177:     PARENT <= seq(CHILD);",
          "178:     CHILD  <= seq(PARENT);",
          "181: TEST_CASE(\"Visit test\", \"[general]\")",
          "182: {",
          "183:     Definition ROOT, TAG, TAG_NAME, WS;",
          "185:     ROOT     <= seq(WS, zom(TAG));",
          "186:     TAG      <= seq(chr('['), TAG_NAME, chr(']'), WS);",
          "187:     TAG_NAME <= oom(seq(npd(chr(']')), dot()));",
          "188:     WS       <= zom(cls(\" \\t\"));",
          "190:     AssignIDToDefinition defIds;",
          "191:     ROOT.accept(defIds);",
          "193:     REQUIRE(defIds.ids.size() == 4);",
          "196: TEST_CASE(\"Token check test\", \"[general]\")",
          "197: {",
          "198:     parser parser(R\"(",
          "",
          "[Added Lines]",
          "7: TEST_CASE(\"Simple syntax test (with unicode)\", \"[general]\") {",
          "8:   parser parser(u8\" ROOT \u2190 _ \"",
          "9:                 \" _ <- ' ' \");",
          "11:   bool ret = parser;",
          "12:   REQUIRE(ret == true);",
          "16: TEST_CASE(\"Simple syntax test\", \"[general]\") {",
          "17:   parser parser(R\"(",
          "22:   bool ret = parser;",
          "23:   REQUIRE(ret == true);",
          "26: TEST_CASE(\"Empty syntax test\", \"[general]\") {",
          "27:   parser parser(\"\");",
          "28:   bool ret = parser;",
          "29:   REQUIRE(ret == false);",
          "32: TEST_CASE(\"Start rule with ignore operator test\", \"[general]\") {",
          "33:   parser parser(R\"(",
          "38:   bool ret = parser;",
          "39:   REQUIRE(ret == false);",
          "42: TEST_CASE(\"Invalid UTF-8 text test\", \"[general]\") {",
          "43:   std::string s = \"a <- '\";",
          "44:   s += static_cast<char>(0xe8); // Make invalid utf8 text...",
          "46:   parser parser(s.data());",
          "48:   bool ret = parser;",
          "49:   REQUIRE(ret == false);",
          "52: TEST_CASE(\"Backslash escape sequence test\", \"[general]\") {",
          "53:   parser parser(R\"(",
          "58:   bool ret = parser;",
          "59:   REQUIRE(ret == true);",
          "62: TEST_CASE(\"Invalid escape sequence test\", \"[general]\") {",
          "63:   parser parser(R\"(",
          "68:   bool ret = parser;",
          "69:   REQUIRE(ret == false);",
          "72: TEST_CASE(\"Action taking non const Semantic Values parameter\", \"[general]\") {",
          "73:   parser parser(R\"(",
          "78:   parser[\"ROOT\"] = [&](SemanticValues &vs) {",
          "79:     auto s = std::string(std::any_cast<std::string_view>(vs[0]));",
          "80:     s[0] = 'H'; // mutate",
          "81:     return s;   // move",
          "82:   };",
          "84:   parser[\"TEXT\"] = [&](SemanticValues &vs) { return vs.token(); };",
          "86:   std::string val;",
          "87:   auto ret = parser.parse(\"hello\", val);",
          "88:   REQUIRE(ret == true);",
          "89:   REQUIRE(val == \"Hello\");",
          "92: TEST_CASE(\"String capture test\", \"[general]\") {",
          "93:   parser parser(R\"(",
          "99:   std::vector<std::string_view> tags;",
          "101:   parser[\"TAG_NAME\"] = [&](const SemanticValues &vs) {",
          "102:     tags.push_back(vs.sv());",
          "103:   };",
          "105:   auto ret = parser.parse(\" [tag1] [tag:2] [tag-3] \");",
          "107:   REQUIRE(ret == true);",
          "108:   REQUIRE(tags.size() == 3);",
          "109:   REQUIRE(tags[0] == \"tag1\");",
          "110:   REQUIRE(tags[1] == \"tag:2\");",
          "111:   REQUIRE(tags[2] == \"tag-3\");",
          "116: TEST_CASE(\"String capture test2\", \"[general]\") {",
          "117:   std::vector<std::string_view> tags;",
          "119:   Definition ROOT, TAG, TAG_NAME, WS;",
          "120:   ROOT <= seq(WS, zom(TAG));",
          "121:   TAG <= seq(chr('['), TAG_NAME, chr(']'), WS);",
          "122:   TAG_NAME <= oom(seq(npd(chr(']')), dot())),",
          "123:       [&](const SemanticValues &vs) { tags.push_back(vs.sv()); };",
          "124:   WS <= zom(cls(\" \\t\"));",
          "126:   auto r = ROOT.parse(\" [tag1] [tag:2] [tag-3] \");",
          "128:   REQUIRE(r.ret == true);",
          "129:   REQUIRE(tags.size() == 3);",
          "130:   REQUIRE(tags[0] == \"tag1\");",
          "131:   REQUIRE(tags[1] == \"tag:2\");",
          "132:   REQUIRE(tags[2] == \"tag-3\");",
          "135: TEST_CASE(\"String capture test3\", \"[general]\") {",
          "136:   parser pg(R\"(",
          "142:   std::vector<std::string_view> tags;",
          "144:   pg[\"TOKEN\"] = [&](const SemanticValues &vs) { tags.push_back(vs.token()); };",
          "146:   auto ret = pg.parse(\" [tag1] [tag:2] [tag-3] \");",
          "148:   REQUIRE(ret == true);",
          "149:   REQUIRE(tags.size() == 3);",
          "150:   REQUIRE(tags[0] == \"tag1\");",
          "151:   REQUIRE(tags[1] == \"tag:2\");",
          "152:   REQUIRE(tags[2] == \"tag-3\");",
          "155: TEST_CASE(\"Cyclic grammer test\", \"[general]\") {",
          "156:   Definition PARENT;",
          "157:   Definition CHILD;",
          "159:   PARENT <= seq(CHILD);",
          "160:   CHILD <= seq(PARENT);",
          "163: TEST_CASE(\"Visit test\", \"[general]\") {",
          "164:   Definition ROOT, TAG, TAG_NAME, WS;",
          "166:   ROOT <= seq(WS, zom(TAG));",
          "167:   TAG <= seq(chr('['), TAG_NAME, chr(']'), WS);",
          "168:   TAG_NAME <= oom(seq(npd(chr(']')), dot()));",
          "169:   WS <= zom(cls(\" \\t\"));",
          "171:   AssignIDToDefinition defIds;",
          "172:   ROOT.accept(defIds);",
          "174:   REQUIRE(defIds.ids.size() == 4);",
          "177: TEST_CASE(\"Token check test\", \"[general]\") {",
          "178:   parser parser(R\"(",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "205:         _                <-  [ \\t\\r\\n]*",
          "206:     )\");",
          "213: }",
          "218:        START <- (CHAR)*",
          "219:        CHAR  <- .",
          "220:     )\");",
          "230: }",
          "235:         START  <- LTOKEN '=' RTOKEN",
          "236:         LTOKEN <- TOKEN",
          "237:         RTOKEN <- TOKEN",
          "238:         TOKEN  <- [A-Za-z]+",
          "239:     )\");",
          "275: }",
          "280:         # Rules",
          "281:         ROOT         <-  ITEM (',' ITEM)*",
          "282:         ITEM         <-  WORD / PHRASE",
          "",
          "[Removed Lines]",
          "208:     REQUIRE(parser[\"EXPRESSION\"].is_token() == false);",
          "209:     REQUIRE(parser[\"FACTOR\"].is_token() == false);",
          "210:     REQUIRE(parser[\"FACTOR_OPERATOR\"].is_token() == true);",
          "211:     REQUIRE(parser[\"NUMBER\"].is_token() == true);",
          "212:     REQUIRE(parser[\"_\"].is_token() == true);",
          "215: TEST_CASE(\"Lambda action test\", \"[general]\")",
          "216: {",
          "217:     parser parser(R\"(",
          "222:     std::string ss;",
          "223:     parser[\"CHAR\"] = [&](const SemanticValues& sv) {",
          "224:         ss += *sv.c_str();",
          "225:     };",
          "227:     bool ret = parser.parse(\"hello\");",
          "228:     REQUIRE(ret == true);",
          "229:     REQUIRE(ss == \"hello\");",
          "232: TEST_CASE(\"enter/leave handlers test\", \"[general]\")",
          "233: {",
          "234:     parser parser(R\"(",
          "241:     parser[\"LTOKEN\"].enter = [&](const char*, size_t, any& dt) {",
          "242:         auto& require_upper_case = *any_cast<bool*>(dt);",
          "243:         require_upper_case = false;",
          "244:     };",
          "245:     parser[\"LTOKEN\"].leave = [&](const char*, size_t, size_t, any&, any& dt) {",
          "246:         auto& require_upper_case = *any_cast<bool*>(dt);",
          "247:         require_upper_case = true;",
          "248:     };",
          "250:     auto message = \"should be upper case string...\";",
          "252:     parser[\"TOKEN\"] = [&](const SemanticValues& sv, any& dt) {",
          "253:         auto& require_upper_case = *any_cast<bool*>(dt);",
          "254:         if (require_upper_case) {",
          "255:             const auto& s = sv.str();",
          "256:             if (!std::all_of(s.begin(), s.end(), ::isupper)) {",
          "257:                 throw parse_error(message);",
          "258:             }",
          "259:         }",
          "260:     };",
          "262:     bool require_upper_case = false;",
          "263:     any dt = &require_upper_case;",
          "264:     REQUIRE(parser.parse(\"hello=world\", dt) == false);",
          "265:     REQUIRE(parser.parse(\"HELLO=world\", dt) == false);",
          "266:     REQUIRE(parser.parse(\"hello=WORLD\", dt) == true);",
          "267:     REQUIRE(parser.parse(\"HELLO=WORLD\", dt) == true);",
          "269:     parser.log = [&](size_t ln, size_t col, const std::string& msg) {",
          "270:         REQUIRE(ln == 1);",
          "271:         REQUIRE(col == 7);",
          "272:         REQUIRE(msg == message);",
          "273:     };",
          "274:     parser.parse(\"hello=world\", dt);",
          "277: TEST_CASE(\"WHITESPACE test\", \"[general]\")",
          "278: {",
          "279:     parser parser(R\"(",
          "",
          "[Added Lines]",
          "188:   REQUIRE(parser[\"EXPRESSION\"].is_token() == false);",
          "189:   REQUIRE(parser[\"FACTOR\"].is_token() == false);",
          "190:   REQUIRE(parser[\"FACTOR_OPERATOR\"].is_token() == true);",
          "191:   REQUIRE(parser[\"NUMBER\"].is_token() == true);",
          "192:   REQUIRE(parser[\"_\"].is_token() == true);",
          "195: TEST_CASE(\"Lambda action test\", \"[general]\") {",
          "196:   parser parser(R\"(",
          "201:   std::string ss;",
          "202:   parser[\"CHAR\"] = [&](const SemanticValues &vs) { ss += *vs.sv().data(); };",
          "204:   bool ret = parser.parse(\"hello\");",
          "205:   REQUIRE(ret == true);",
          "206:   REQUIRE(ss == \"hello\");",
          "209: TEST_CASE(\"enter/leave handlers test\", \"[general]\") {",
          "210:   parser parser(R\"(",
          "217:   parser[\"LTOKEN\"].enter = [&](const char *, size_t, std::any &dt) {",
          "218:     auto &require_upper_case = *std::any_cast<bool *>(dt);",
          "219:     require_upper_case = false;",
          "220:   };",
          "221:   parser[\"LTOKEN\"].leave = [&](const char *, size_t, size_t, std::any &,",
          "222:                                std::any &dt) {",
          "223:     auto &require_upper_case = *std::any_cast<bool *>(dt);",
          "224:     require_upper_case = true;",
          "225:   };",
          "227:   auto message = \"should be upper case string...\";",
          "229:   parser[\"TOKEN\"] = [&](const SemanticValues &vs, std::any &dt) {",
          "230:     auto &require_upper_case = *std::any_cast<bool *>(dt);",
          "231:     if (require_upper_case) {",
          "232:       const auto &s = vs.sv();",
          "233:       if (!std::all_of(s.begin(), s.end(), ::isupper)) {",
          "234:         throw parse_error(message);",
          "235:       }",
          "236:     }",
          "237:   };",
          "239:   bool require_upper_case = false;",
          "240:   std::any dt = &require_upper_case;",
          "241:   REQUIRE(parser.parse(\"hello=world\", dt) == false);",
          "242:   REQUIRE(parser.parse(\"HELLO=world\", dt) == false);",
          "243:   REQUIRE(parser.parse(\"hello=WORLD\", dt) == true);",
          "244:   REQUIRE(parser.parse(\"HELLO=WORLD\", dt) == true);",
          "246:   parser.log = [&](size_t ln, size_t col, const std::string &msg) {",
          "247:     REQUIRE(ln == 1);",
          "248:     REQUIRE(col == 7);",
          "249:     REQUIRE(msg == message);",
          "250:   };",
          "251:   parser.parse(\"hello=world\", dt);",
          "254: TEST_CASE(\"WHITESPACE test\", \"[general]\") {",
          "255:   parser parser(R\"(",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "288:         %whitespace  <-  [ \\t\\r\\n]*",
          "289:     )\");",
          "294: }",
          "299:         # Rules",
          "300:         ROOT         <-  ITEM (',' ITEM)*",
          "301:         ITEM         <-  '[' < [a-zA-Z0-9_]+ > ']'",
          "",
          "[Removed Lines]",
          "291:     auto ret = parser.parse(R\"(  one,   \"two, three\",   four  )\");",
          "293:     REQUIRE(ret == true);",
          "296: TEST_CASE(\"WHITESPACE test2\", \"[general]\")",
          "297: {",
          "298:     parser parser(R\"(",
          "",
          "[Added Lines]",
          "267:   auto ret = parser.parse(R\"(  one,   \"two, three\",   four  )\");",
          "269:   REQUIRE(ret == true);",
          "272: TEST_CASE(\"WHITESPACE test2\", \"[general]\") {",
          "273:   parser parser(R\"(",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "305:         TAB          <-  '\\t'",
          "306:     )\");",
          "320: }",
          "322: TEST_CASE(\"WHITESPACE test3\", \"[general]\") {",
          "324:         StrQuot      <- < '\"' < (StrEscape / StrChars)* > '\"' >",
          "325:         StrEscape    <- '\\\\' any",
          "326:         StrChars     <- (!'\"' !'\\\\' any)+",
          "",
          "[Removed Lines]",
          "308:     std::vector<std::string> items;",
          "309:     parser[\"ITEM\"] = [&](const SemanticValues& sv) {",
          "310:         items.push_back(sv.token());",
          "311:     };",
          "313:     auto ret = parser.parse(R\"([one],  [two] ,[three] )\");",
          "315:     REQUIRE(ret == true);",
          "316:     REQUIRE(items.size() == 3);",
          "317:     REQUIRE(items[0] == \"one\");",
          "318:     REQUIRE(items[1] == \"two\");",
          "319:     REQUIRE(items[2] == \"three\");",
          "323:     parser parser(R\"(",
          "",
          "[Added Lines]",
          "283:   std::vector<std::string_view> items;",
          "284:   parser[\"ITEM\"] = [&](const SemanticValues &vs) {",
          "285:     items.push_back(vs.token());",
          "286:   };",
          "288:   auto ret = parser.parse(R\"([one],  [two] ,[three] )\");",
          "290:   REQUIRE(ret == true);",
          "291:   REQUIRE(items.size() == 3);",
          "292:   REQUIRE(items[0] == \"one\");",
          "293:   REQUIRE(items[1] == \"two\");",
          "294:   REQUIRE(items[2] == \"three\");",
          "298:   parser parser(R\"(",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "328:         %whitespace  <- [ \\t]*",
          "329:     )\");",
          "337: }",
          "339: TEST_CASE(\"WHITESPACE test4\", \"[general]\") {",
          "341:         ROOT         <-  HELLO OPE WORLD",
          "342:         HELLO        <-  'hello'",
          "343:         OPE          <-  < [-+] >",
          "",
          "[Removed Lines]",
          "331:     parser[\"StrQuot\"] = [](const SemanticValues& sv) {",
          "332:         REQUIRE(sv.token() == R\"(  aaa \\\" bbb  )\");",
          "333:     };",
          "335:     auto ret = parser.parse(R\"( \"  aaa \\\" bbb  \" )\");",
          "336:     REQUIRE(ret == true);",
          "340:     parser parser(R\"(",
          "",
          "[Added Lines]",
          "306:   parser[\"StrQuot\"] = [](const SemanticValues &vs) {",
          "307:     REQUIRE(vs.token() == R\"(  aaa \\\" bbb  )\");",
          "308:   };",
          "310:   auto ret = parser.parse(R\"( \"  aaa \\\" bbb  \" )\");",
          "311:   REQUIRE(ret == true);",
          "315:   parser parser(R\"(",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "345:         %whitespace  <-  [ \\t\\r\\n]*",
          "346:     )\");",
          "362: }",
          "364: TEST_CASE(\"Word expression test\", \"[general]\") {",
          "366:         ROOT         <-  'hello' ','? 'world'",
          "367:         %whitespace  <-  [ \\t\\r\\n]*",
          "368:         %word        <-  [a-z]+",
          "369:     )\");",
          "376: }",
          "393: }",
          "398:         ROOT        <-  ITEM (',' ITEM)*",
          "399:         ITEM        <-  < ([a-z0-9])+ >",
          "400:         %whitespace <-  [ \\t]*",
          "401:     )\");",
          "410: }",
          "418:         ROOT <- _ TEXT*",
          "419:         TEXT <- [a-zA-Z]+ _",
          "420:         _ <- [ \\t\\r\\n]*",
          "421:     )\");",
          "428: }",
          "433:        START <- PAT1 / PAT2",
          "434:        PAT1  <- HELLO ' One'",
          "435:        PAT2  <- HELLO ' Two'",
          "436:        HELLO <- 'Hello'",
          "437:     )\");",
          "449: }",
          "454:         S <- A? B (A B)* A",
          "455:         A <- 'a'",
          "456:         B <- 'b'",
          "457:     )\");",
          "464: }",
          "475: }",
          "477: TEST_CASE(\"Ignore case test\", \"[general]\") {",
          "479:         ROOT         <-  HELLO WORLD",
          "480:         HELLO        <-  'hello'i",
          "481:         WORLD        <-  'world'i",
          "482:         %whitespace  <-  [ \\t\\r\\n]*",
          "483:     )\");",
          "495: }",
          "507: }",
          "512:         Additive  <- Multitive '+' Additive / Multitive",
          "513:         Multitive <- Primary '*' Multitive / Primary",
          "514:         Primary   <- '(' Additive ')' / Number",
          "515:         Number    <- [0-9]+",
          "516:     )\");",
          "585: }",
          "591:         # Grammar for Calculator...",
          "592:         EXPRESSION       <-  TERM (TERM_OPERATOR TERM)*",
          "593:         TERM             <-  FACTOR (FACTOR_OPERATOR FACTOR)*",
          "",
          "[Removed Lines]",
          "348:     parser[\"HELLO\"] = [](const SemanticValues& sv) {",
          "349:         REQUIRE(sv.token() == \"hello\");",
          "350:     };",
          "352:     parser[\"OPE\"] = [](const SemanticValues& sv) {",
          "353:         REQUIRE(sv.token() == \"+\");",
          "354:     };",
          "356:     parser[\"WORLD\"] = [](const SemanticValues& sv) {",
          "357:         REQUIRE(sv.token() == \"world\");",
          "358:     };",
          "360:     auto ret = parser.parse(\"  hello + world  \");",
          "361:     REQUIRE(ret == true);",
          "365:     parser parser(R\"(",
          "371:  REQUIRE(parser.parse(\"helloworld\") == false);",
          "372:  REQUIRE(parser.parse(\"hello world\") == true);",
          "373:  REQUIRE(parser.parse(\"hello,world\") == true);",
          "374:  REQUIRE(parser.parse(\"hello, world\") == true);",
          "375:  REQUIRE(parser.parse(\"hello , world\") == true);",
          "378: TEST_CASE(\"Skip token test\", \"[general]\")",
          "379: {",
          "380:     parser parser(",
          "381:         \"  ROOT  <-  _ ITEM (',' _ ITEM _)* \"",
          "382:         \"  ITEM  <-  ([a-z0-9])+  \"",
          "383:         \"  ~_    <-  [ \\t]*    \"",
          "384:     );",
          "386:     parser[\"ROOT\"] = [&](const SemanticValues& sv) {",
          "387:         REQUIRE(sv.size() == 2);",
          "388:     };",
          "390:     auto ret = parser.parse(\" item1, item2 \");",
          "392:     REQUIRE(ret == true);",
          "395: TEST_CASE(\"Skip token test2\", \"[general]\")",
          "396: {",
          "397:     parser parser(R\"(",
          "403:     parser[\"ROOT\"] = [&](const SemanticValues& sv) {",
          "404:         REQUIRE(sv.size() == 2);",
          "405:     };",
          "407:     auto ret = parser.parse(\" item1, item2 \");",
          "409:     REQUIRE(ret == true);",
          "412: TEST_CASE(\"Custom AST test\", \"[general]\")",
          "413: {",
          "414:  struct CustomType {};",
          "415:  using CustomAst = AstBase<CustomType>;",
          "417:     parser parser(R\"(",
          "423:     parser.enable_ast<CustomAst>();",
          "424:     std::shared_ptr<CustomAst> ast;",
          "425:     bool ret = parser.parse(\"a b c\", ast);",
          "426:     REQUIRE(ret == true);",
          "427:     REQUIRE(ast->nodes.size() == 4);",
          "430: TEST_CASE(\"Backtracking test\", \"[general]\")",
          "431: {",
          "432:     parser parser(R\"(",
          "439:     size_t count = 0;",
          "440:     parser[\"HELLO\"] = [&](const SemanticValues& /*sv*/) {",
          "441:         count++;",
          "442:     };",
          "444:     parser.enable_packrat_parsing();",
          "446:     bool ret = parser.parse(\"Hello Two\");",
          "447:     REQUIRE(ret == true);",
          "448:     REQUIRE(count == 1); // Skip second time",
          "451: TEST_CASE(\"Backtracking with AST\", \"[general]\")",
          "452: {",
          "453:     parser parser(R\"(",
          "459:     parser.enable_ast();",
          "460:     std::shared_ptr<Ast> ast;",
          "461:     bool ret = parser.parse(\"ba\", ast);",
          "462:     REQUIRE(ret == true);",
          "463:     REQUIRE(ast->nodes.size() == 2);",
          "466: TEST_CASE(\"Octal/Hex/Unicode value test\", \"[general]\")",
          "467: {",
          "468:     parser parser(",
          "469:         R\"( ROOT <- '\\132\\x7a\\u30f3' )\"",
          "470:     );",
          "472:     auto ret = parser.parse(\"Zz\u30f3\");",
          "474:     REQUIRE(ret == true);",
          "478:     parser parser(R\"(",
          "485:     parser[\"HELLO\"] = [](const SemanticValues& sv) {",
          "486:         REQUIRE(sv.token() == \"Hello\");",
          "487:     };",
          "489:     parser[\"WORLD\"] = [](const SemanticValues& sv) {",
          "490:         REQUIRE(sv.token() == \"World\");",
          "491:     };",
          "493:     auto ret = parser.parse(\"  Hello World  \");",
          "494:     REQUIRE(ret == true);",
          "497: TEST_CASE(\"mutable lambda test\", \"[general]\")",
          "498: {",
          "499:     std::vector<std::string> vec;",
          "501:     parser pg(\"ROOT <- 'mutable lambda test'\");",
          "504:     pg[\"TOKEN\"] = [=](const SemanticValues& sv) mutable {",
          "505:         vec.push_back(sv.str());",
          "506:     };",
          "509: TEST_CASE(\"Simple calculator test\", \"[general]\")",
          "510: {",
          "511:     parser parser(R\"(",
          "518:     parser[\"Additive\"] = [](const SemanticValues& sv) {",
          "519:         switch (sv.choice()) {",
          "520:         case 0:",
          "521:             return any_cast<int>(sv[0]) + any_cast<int>(sv[1]);",
          "522:         default:",
          "523:             return any_cast<int>(sv[0]);",
          "524:         }",
          "525:     };",
          "527:     parser[\"Multitive\"] = [](const SemanticValues& sv) {",
          "528:         switch (sv.choice()) {",
          "529:         case 0:",
          "530:             return any_cast<int>(sv[0]) * any_cast<int>(sv[1]);",
          "531:         default:",
          "532:             return any_cast<int>(sv[0]);",
          "533:         }",
          "534:     };",
          "536:     parser[\"Number\"] = [](const SemanticValues& sv) {",
          "537:         return atoi(sv.c_str());",
          "538:     };",
          "540:     int val;",
          "541:     parser.parse(\"(1+2)*3\", val);",
          "543:     REQUIRE(val == 9);",
          "544: }",
          "546: TEST_CASE(\"Calculator test\", \"[general]\")",
          "547: {",
          "549:     Definition EXPRESSION, TERM, FACTOR, TERM_OPERATOR, FACTOR_OPERATOR, NUMBER;",
          "551:     EXPRESSION      <= seq(TERM, zom(seq(TERM_OPERATOR, TERM)));",
          "552:     TERM            <= seq(FACTOR, zom(seq(FACTOR_OPERATOR, FACTOR)));",
          "553:     FACTOR          <= cho(NUMBER, seq(chr('('), EXPRESSION, chr(')')));",
          "554:     TERM_OPERATOR   <= cls(\"+-\");",
          "555:     FACTOR_OPERATOR <= cls(\"*/\");",
          "556:     NUMBER          <= oom(cls(\"0-9\"));",
          "559:     auto reduce = [](const SemanticValues& sv) -> long {",
          "560:         long ret = any_cast<long>(sv[0]);",
          "561:         for (auto i = 1u; i < sv.size(); i += 2) {",
          "562:             auto num = any_cast<long>(sv[i + 1]);",
          "563:             switch (any_cast<char>(sv[i])) {",
          "564:                 case '+': ret += num; break;",
          "565:                 case '-': ret -= num; break;",
          "566:                 case '*': ret *= num; break;",
          "567:                 case '/': ret /= num; break;",
          "568:             }",
          "569:         }",
          "570:         return ret;",
          "571:     };",
          "573:     EXPRESSION      = reduce;",
          "574:     TERM            = reduce;",
          "575:     TERM_OPERATOR   = [](const SemanticValues& sv) { return *sv.c_str(); };",
          "576:     FACTOR_OPERATOR = [](const SemanticValues& sv) { return *sv.c_str(); };",
          "577:     NUMBER          = [](const SemanticValues& sv) { return stol(sv.str(), nullptr, 10); };",
          "580:     long val;",
          "581:     auto r = EXPRESSION.parse_and_get_value(\"1+2*3*(4-5+6)/7-8\", val);",
          "583:     REQUIRE(r.ret == true);",
          "584:     REQUIRE(val == -3);",
          "587: TEST_CASE(\"Calculator test2\", \"[general]\")",
          "588: {",
          "590:     auto syntax = R\"(",
          "",
          "[Added Lines]",
          "323:   parser[\"HELLO\"] = [](const SemanticValues &vs) {",
          "324:     REQUIRE(vs.token() == \"hello\");",
          "325:   };",
          "327:   parser[\"OPE\"] = [](const SemanticValues &vs) { REQUIRE(vs.token() == \"+\"); };",
          "329:   parser[\"WORLD\"] = [](const SemanticValues &vs) {",
          "330:     REQUIRE(vs.token() == \"world\");",
          "331:   };",
          "333:   auto ret = parser.parse(\"  hello + world  \");",
          "334:   REQUIRE(ret == true);",
          "338:   parser parser(R\"(",
          "344:   REQUIRE(parser.parse(\"helloworld\") == false);",
          "345:   REQUIRE(parser.parse(\"hello world\") == true);",
          "346:   REQUIRE(parser.parse(\"hello,world\") == true);",
          "347:   REQUIRE(parser.parse(\"hello, world\") == true);",
          "348:   REQUIRE(parser.parse(\"hello , world\") == true);",
          "351: TEST_CASE(\"Skip token test\", \"[general]\") {",
          "352:   parser parser(\"  ROOT  <-  _ ITEM (',' _ ITEM _)* \"",
          "353:                 \"  ITEM  <-  ([a-z0-9])+  \"",
          "354:                 \"  ~_    <-  [ \\t]*    \");",
          "356:   parser[\"ROOT\"] = [&](const SemanticValues &vs) { REQUIRE(vs.size() == 2); };",
          "358:   auto ret = parser.parse(\" item1, item2 \");",
          "360:   REQUIRE(ret == true);",
          "363: TEST_CASE(\"Skip token test2\", \"[general]\") {",
          "364:   parser parser(R\"(",
          "370:   parser[\"ROOT\"] = [&](const SemanticValues &vs) { REQUIRE(vs.size() == 2); };",
          "372:   auto ret = parser.parse(\" item1, item2 \");",
          "374:   REQUIRE(ret == true);",
          "377: TEST_CASE(\"Custom AST test\", \"[general]\") {",
          "378:   struct CustomType {};",
          "379:   using CustomAst = AstBase<CustomType>;",
          "381:   parser parser(R\"(",
          "387:   parser.enable_ast<CustomAst>();",
          "388:   std::shared_ptr<CustomAst> ast;",
          "389:   bool ret = parser.parse(\"a b c\", ast);",
          "390:   REQUIRE(ret == true);",
          "391:   REQUIRE(ast->nodes.size() == 4);",
          "394: TEST_CASE(\"Backtracking test\", \"[general]\") {",
          "395:   parser parser(R\"(",
          "402:   size_t count = 0;",
          "403:   parser[\"HELLO\"] = [&](const SemanticValues & /*vs*/) { count++; };",
          "405:   parser.enable_packrat_parsing();",
          "407:   bool ret = parser.parse(\"Hello Two\");",
          "408:   REQUIRE(ret == true);",
          "409:   REQUIRE(count == 1); // Skip second time",
          "412: TEST_CASE(\"Backtracking with AST\", \"[general]\") {",
          "413:   parser parser(R\"(",
          "419:   parser.enable_ast();",
          "420:   std::shared_ptr<Ast> ast;",
          "421:   bool ret = parser.parse(\"ba\", ast);",
          "422:   REQUIRE(ret == true);",
          "423:   REQUIRE(ast->nodes.size() == 2);",
          "426: TEST_CASE(\"Octal/Hex/Unicode value test\", \"[general]\") {",
          "427:   parser parser(R\"( ROOT <- '\\132\\x7a\\u30f3' )\");",
          "429:   auto ret = parser.parse(\"Zz\u30f3\");",
          "431:   REQUIRE(ret == true);",
          "435:   parser parser(R\"(",
          "442:   parser[\"HELLO\"] = [](const SemanticValues &vs) {",
          "443:     REQUIRE(vs.token() == \"Hello\");",
          "444:   };",
          "446:   parser[\"WORLD\"] = [](const SemanticValues &vs) {",
          "447:     REQUIRE(vs.token() == \"World\");",
          "448:   };",
          "450:   auto ret = parser.parse(\"  Hello World  \");",
          "451:   REQUIRE(ret == true);",
          "454: TEST_CASE(\"mutable lambda test\", \"[general]\") {",
          "455:   std::vector<std::string_view> vec;",
          "457:   parser pg(\"ROOT <- 'mutable lambda test'\");",
          "460:   pg[\"TOKEN\"] = [=](const SemanticValues &vs) mutable {",
          "461:     vec.push_back(vs.sv());",
          "462:   };",
          "465: TEST_CASE(\"Simple calculator test\", \"[general]\") {",
          "466:   parser parser(R\"(",
          "473:   parser[\"Additive\"] = [](const SemanticValues &vs) {",
          "474:     switch (vs.choice()) {",
          "475:     case 0: return std::any_cast<int>(vs[0]) + std::any_cast<int>(vs[1]);",
          "476:     default: return std::any_cast<int>(vs[0]);",
          "477:     }",
          "478:   };",
          "480:   parser[\"Multitive\"] = [](const SemanticValues &vs) {",
          "481:     switch (vs.choice()) {",
          "482:     case 0: return std::any_cast<int>(vs[0]) * std::any_cast<int>(vs[1]);",
          "483:     default: return std::any_cast<int>(vs[0]);",
          "484:     }",
          "485:   };",
          "487:   parser[\"Number\"] = [](const SemanticValues &vs) { return vs.token_to_number<int>(); };",
          "489:   int val;",
          "490:   parser.parse(\"(1+2)*3\", val);",
          "492:   REQUIRE(val == 9);",
          "493: }",
          "495: TEST_CASE(\"Calculator test\", \"[general]\") {",
          "497:   Definition EXPRESSION, TERM, FACTOR, TERM_OPERATOR, FACTOR_OPERATOR, NUMBER;",
          "499:   EXPRESSION <= seq(TERM, zom(seq(TERM_OPERATOR, TERM)));",
          "500:   TERM <= seq(FACTOR, zom(seq(FACTOR_OPERATOR, FACTOR)));",
          "501:   FACTOR <= cho(NUMBER, seq(chr('('), EXPRESSION, chr(')')));",
          "502:   TERM_OPERATOR <= cls(\"+-\");",
          "503:   FACTOR_OPERATOR <= cls(\"*/\");",
          "504:   NUMBER <= oom(cls(\"0-9\"));",
          "507:   auto reduce = [](const SemanticValues &vs) -> long {",
          "508:     long ret = std::any_cast<long>(vs[0]);",
          "509:     for (auto i = 1u; i < vs.size(); i += 2) {",
          "510:       auto num = std::any_cast<long>(vs[i + 1]);",
          "511:       switch (std::any_cast<char>(vs[i])) {",
          "512:       case '+': ret += num; break;",
          "513:       case '-': ret -= num; break;",
          "514:       case '*': ret *= num; break;",
          "515:       case '/': ret /= num; break;",
          "516:       }",
          "517:     }",
          "518:     return ret;",
          "519:   };",
          "521:   EXPRESSION = reduce;",
          "522:   TERM = reduce;",
          "523:   TERM_OPERATOR = [](const SemanticValues &vs) { return *vs.sv().data(); };",
          "524:   FACTOR_OPERATOR = [](const SemanticValues &vs) { return *vs.sv().data(); };",
          "525:   NUMBER = [](const SemanticValues &vs) { return vs.token_to_number<long>(); };",
          "528:   long val;",
          "529:   auto r = EXPRESSION.parse_and_get_value(\"1+2*3*(4-5+6)/7-8\", val);",
          "531:   REQUIRE(r.ret == true);",
          "532:   REQUIRE(val == -3);",
          "535: TEST_CASE(\"Calculator test2\", \"[general]\") {",
          "537:   auto syntax = R\"(",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "597:         NUMBER           <-  [0-9]+",
          "598:     )\";",
          "631: }",
          "637:         # Grammar for Calculator...",
          "638:         EXPRESSION       <-  TERM (TERM_OPERATOR TERM)*",
          "639:         TERM             <-  FACTOR (FACTOR_OPERATOR FACTOR)*",
          "",
          "[Removed Lines]",
          "600:     std::string start;",
          "601:     auto grammar = ParserGenerator::parse(syntax, strlen(syntax), start, nullptr);",
          "602:     auto& g = *grammar;",
          "605:     auto reduce = [](const SemanticValues& sv) -> long {",
          "606:         long ret = any_cast<long>(sv[0]);",
          "607:         for (auto i = 1u; i < sv.size(); i += 2) {",
          "608:             auto num = any_cast<long>(sv[i + 1]);",
          "609:             switch (any_cast<char>(sv[i])) {",
          "610:                 case '+': ret += num; break;",
          "611:                 case '-': ret -= num; break;",
          "612:                 case '*': ret *= num; break;",
          "613:                 case '/': ret /= num; break;",
          "614:             }",
          "615:         }",
          "616:         return ret;",
          "617:     };",
          "619:     g[\"EXPRESSION\"]      = reduce;",
          "620:     g[\"TERM\"]            = reduce;",
          "621:     g[\"TERM_OPERATOR\"]   = [](const SemanticValues& sv) { return *sv.c_str(); };",
          "622:     g[\"FACTOR_OPERATOR\"] = [](const SemanticValues& sv) { return *sv.c_str(); };",
          "623:     g[\"NUMBER\"]          = [](const SemanticValues& sv) { return stol(sv.str(), nullptr, 10); };",
          "626:     long val;",
          "627:     auto r = g[start].parse_and_get_value(\"1+2*3*(4-5+6)/7-8\", val);",
          "629:     REQUIRE(r.ret == true);",
          "630:     REQUIRE(val == -3);",
          "633: TEST_CASE(\"Calculator test3\", \"[general]\")",
          "634: {",
          "636:     parser parser(R\"(",
          "",
          "[Added Lines]",
          "547:   std::string start;",
          "548:   auto grammar = ParserGenerator::parse(syntax, strlen(syntax), start, nullptr);",
          "549:   auto &g = *grammar;",
          "552:   auto reduce = [](const SemanticValues &vs) -> long {",
          "553:     long ret = std::any_cast<long>(vs[0]);",
          "554:     for (auto i = 1u; i < vs.size(); i += 2) {",
          "555:       auto num = std::any_cast<long>(vs[i + 1]);",
          "556:       switch (std::any_cast<char>(vs[i])) {",
          "557:       case '+': ret += num; break;",
          "558:       case '-': ret -= num; break;",
          "559:       case '*': ret *= num; break;",
          "560:       case '/': ret /= num; break;",
          "561:       }",
          "562:     }",
          "563:     return ret;",
          "564:   };",
          "566:   g[\"EXPRESSION\"] = reduce;",
          "567:   g[\"TERM\"] = reduce;",
          "568:   g[\"TERM_OPERATOR\"] = [](const SemanticValues &vs) { return *vs.sv().data(); };",
          "569:   g[\"FACTOR_OPERATOR\"] = [](const SemanticValues &vs) { return *vs.sv().data(); };",
          "570:   g[\"NUMBER\"] = [](const SemanticValues &vs) { return vs.token_to_number<long>(); };",
          "573:   long val;",
          "574:   auto r = g[start].parse_and_get_value(\"1+2*3*(4-5+6)/7-8\", val);",
          "576:   REQUIRE(r.ret == true);",
          "577:   REQUIRE(val == -3);",
          "580: TEST_CASE(\"Calculator test3\", \"[general]\") {",
          "582:   parser parser(R\"(",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "643:         NUMBER           <-  [0-9]+",
          "644:     )\");",
          "673: }",
          "678:         EXPRESSION       <-  _ TERM (TERM_OPERATOR TERM)*",
          "679:         TERM             <-  FACTOR (FACTOR_OPERATOR FACTOR)*",
          "680:         FACTOR           <-  NUMBER / '(' _ EXPRESSION ')' _",
          "",
          "[Removed Lines]",
          "646:     auto reduce = [](const SemanticValues& sv) -> long {",
          "647:         long ret = any_cast<long>(sv[0]);",
          "648:         for (auto i = 1u; i < sv.size(); i += 2) {",
          "649:             auto num = any_cast<long>(sv[i + 1]);",
          "650:             switch (any_cast<char>(sv[i])) {",
          "651:                 case '+': ret += num; break;",
          "652:                 case '-': ret -= num; break;",
          "653:                 case '*': ret *= num; break;",
          "654:                 case '/': ret /= num; break;",
          "655:             }",
          "656:         }",
          "657:         return ret;",
          "658:     };",
          "661:     parser[\"EXPRESSION\"]      = reduce;",
          "662:     parser[\"TERM\"]            = reduce;",
          "663:     parser[\"TERM_OPERATOR\"]   = [](const SemanticValues& sv) { return static_cast<char>(*sv.c_str()); };",
          "664:     parser[\"FACTOR_OPERATOR\"] = [](const SemanticValues& sv) { return static_cast<char>(*sv.c_str()); };",
          "665:     parser[\"NUMBER\"]          = [](const SemanticValues& sv) { return stol(sv.str(), nullptr, 10); };",
          "668:     long val;",
          "669:     auto ret = parser.parse(\"1+2*3*(4-5+6)/7-8\", val);",
          "671:     REQUIRE(ret == true);",
          "672:     REQUIRE(val == -3);",
          "675: TEST_CASE(\"Calculator test with AST\", \"[general]\")",
          "676: {",
          "677:     parser parser(R\"(",
          "",
          "[Added Lines]",
          "592:   auto reduce = [](const SemanticValues &vs) -> long {",
          "593:     long ret = std::any_cast<long>(vs[0]);",
          "594:     for (auto i = 1u; i < vs.size(); i += 2) {",
          "595:       auto num = std::any_cast<long>(vs[i + 1]);",
          "596:       switch (std::any_cast<char>(vs[i])) {",
          "597:       case '+': ret += num; break;",
          "598:       case '-': ret -= num; break;",
          "599:       case '*': ret *= num; break;",
          "600:       case '/': ret /= num; break;",
          "601:       }",
          "602:     }",
          "603:     return ret;",
          "604:   };",
          "607:   parser[\"EXPRESSION\"] = reduce;",
          "608:   parser[\"TERM\"] = reduce;",
          "609:   parser[\"TERM_OPERATOR\"] = [](const SemanticValues &vs) {",
          "610:     return static_cast<char>(*vs.sv().data());",
          "611:   };",
          "612:   parser[\"FACTOR_OPERATOR\"] = [](const SemanticValues &vs) {",
          "613:     return static_cast<char>(*vs.sv().data());",
          "614:   };",
          "615:   parser[\"NUMBER\"] = [](const SemanticValues &vs) { return vs.token_to_number<long>(); };",
          "618:   long val;",
          "619:   auto ret = parser.parse(\"1+2*3*(4-5+6)/7-8\", val);",
          "621:   REQUIRE(ret == true);",
          "622:   REQUIRE(val == -3);",
          "625: TEST_CASE(\"Calculator test with AST\", \"[general]\") {",
          "626:   parser parser(R\"(",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "684:         ~_               <-  [ \\t\\r\\n]*",
          "685:     )\");",
          "706:         }",
          "716: }",
          "718: TEST_CASE(\"Calculator test with combinators and AST\", \"[general]\") {",
          "722:   EXPRESSION <= seq(TERM, zom(seq(TERM_OPERATOR, TERM)));",
          "723:   TERM <= seq(FACTOR, zom(seq(FACTOR_OPERATOR, FACTOR)));",
          "",
          "[Removed Lines]",
          "687:     parser.enable_ast();",
          "689:     std::function<long (const Ast&)> eval = [&](const Ast& ast) {",
          "690:         if (ast.name == \"NUMBER\") {",
          "691:             return stol(ast.token);",
          "692:         } else {",
          "693:             const auto& nodes = ast.nodes;",
          "694:             auto result = eval(*nodes[0]);",
          "695:             for (auto i = 1u; i < nodes.size(); i += 2) {",
          "696:                 auto num = eval(*nodes[i + 1]);",
          "697:                 auto ope = nodes[i]->token[0];",
          "698:                 switch (ope) {",
          "699:                     case '+': result += num; break;",
          "700:                     case '-': result -= num; break;",
          "701:                     case '*': result *= num; break;",
          "702:                     case '/': result /= num; break;",
          "703:                 }",
          "704:             }",
          "705:             return result;",
          "707:     };",
          "709:     std::shared_ptr<Ast> ast;",
          "710:     auto ret = parser.parse(\"1+2*3*(4-5+6)/7-8\", ast);",
          "711:     ast = AstOptimizer(true).optimize(ast);",
          "712:     auto val = eval(*ast);",
          "714:     REQUIRE(ret == true);",
          "715:     REQUIRE(val == -3);",
          "720:   AST_DEFINITIONS(EXPRESSION, TERM, FACTOR, TERM_OPERATOR, FACTOR_OPERATOR, NUMBER);",
          "",
          "[Added Lines]",
          "636:   parser.enable_ast();",
          "638:   std::function<long(const Ast &)> eval = [&](const Ast &ast) {",
          "639:     if (ast.name == \"NUMBER\") {",
          "640:       return ast.token_to_number<long>();",
          "641:     } else {",
          "642:       const auto &nodes = ast.nodes;",
          "643:       auto result = eval(*nodes[0]);",
          "644:       for (auto i = 1u; i < nodes.size(); i += 2) {",
          "645:         auto num = eval(*nodes[i + 1]);",
          "646:         auto ope = nodes[i]->token[0];",
          "647:         switch (ope) {",
          "648:         case '+': result += num; break;",
          "649:         case '-': result -= num; break;",
          "650:         case '*': result *= num; break;",
          "651:         case '/': result /= num; break;",
          "653:       }",
          "654:       return result;",
          "655:     }",
          "656:   };",
          "658:   std::shared_ptr<Ast> ast;",
          "659:   auto ret = parser.parse(\"1+2*3*(4-5+6)/7-8\", ast);",
          "660:   ast = AstOptimizer(true).optimize(ast);",
          "661:   auto val = eval(*ast);",
          "663:   REQUIRE(ret == true);",
          "664:   REQUIRE(val == -3);",
          "669:   AST_DEFINITIONS(EXPRESSION, TERM, FACTOR, TERM_OPERATOR, FACTOR_OPERATOR,",
          "670:                   NUMBER);",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "729:   std::function<long(const Ast &)> eval = [&](const Ast &ast) {",
          "730:     if (ast.name == \"NUMBER\") {",
          "732:     } else {",
          "733:       const auto &nodes = ast.nodes;",
          "734:       auto result = eval(*nodes[0]);",
          "",
          "[Removed Lines]",
          "731:       return stol(ast.token);",
          "",
          "[Added Lines]",
          "681:       return ast.token_to_number<long>();",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "755:   REQUIRE(val == -3);",
          "756: }",
          "761:        START <-  ~HELLO WORLD",
          "762:        HELLO <- 'Hello' _",
          "763:        WORLD <- 'World' _",
          "764:        _     <- [ \\t\\r\\n]*",
          "765:     )\");",
          "775: }",
          "780:        START       <- _ !DUMMY HELLO_WORLD '.'",
          "781:        HELLO_WORLD <- HELLO 'World' _",
          "782:        HELLO       <- 'Hello' _",
          "",
          "[Removed Lines]",
          "758: TEST_CASE(\"Ignore semantic value test\", \"[general]\")",
          "759: {",
          "760:     parser parser(R\"(",
          "767:     parser.enable_ast();",
          "769:     std::shared_ptr<Ast> ast;",
          "770:     auto ret = parser.parse(\"Hello World\", ast);",
          "772:     REQUIRE(ret == true);",
          "773:     REQUIRE(ast->nodes.size() == 1);",
          "774:     REQUIRE(ast->nodes[0]->name == \"WORLD\");",
          "777: TEST_CASE(\"Ignore semantic value of 'or' predicate test\", \"[general]\")",
          "778: {",
          "779:     parser parser(R\"(",
          "",
          "[Added Lines]",
          "708: TEST_CASE(\"Ignore semantic value test\", \"[general]\") {",
          "709:   parser parser(R\"(",
          "716:   parser.enable_ast();",
          "718:   std::shared_ptr<Ast> ast;",
          "719:   auto ret = parser.parse(\"Hello World\", ast);",
          "721:   REQUIRE(ret == true);",
          "722:   REQUIRE(ast->nodes.size() == 1);",
          "723:   REQUIRE(ast->nodes[0]->name == \"WORLD\");",
          "726: TEST_CASE(\"Ignore semantic value of 'or' predicate test\", \"[general]\") {",
          "727:   parser parser(R\"(",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "784:        ~_          <- [ \\t\\r\\n]*",
          "785:    )\");",
          "795: }",
          "800:        START       <- _ &HELLO HELLO_WORLD '.'",
          "801:        HELLO_WORLD <- HELLO 'World' _",
          "802:        HELLO       <- 'Hello' _",
          "803:        ~_          <- [ \\t\\r\\n]*",
          "804:     )\");",
          "814: }",
          "819:         STRING_LITERAL  <- '\"' (('\\\\\"' / '\\\\t' / '\\\\n') / (![\"] .))* '\"'",
          "820:     )\");",
          "830: }",
          "835:         STRING_LITERAL  <-  '\"' (ESC / CHAR)* '\"'",
          "836:         ESC             <-  ('\\\\\"' / '\\\\t' / '\\\\n')",
          "837:         CHAR            <-  (![\"] .)",
          "838:     )\");",
          "848: }",
          "853:         STRING_LITERAL  <-  < '\"' (ESC / CHAR)* '\"' >",
          "854:         ESC             <-  ('\\\\\"' / '\\\\t' / '\\\\n')",
          "855:         CHAR            <-  (![\"] .)",
          "856:     )\");",
          "866: }",
          "871:         A <- B C",
          "872:     )\");",
          "875: }",
          "880:         A <- ''",
          "881:         A <- ''",
          "882:     )\");",
          "885: }",
          "890:         term <- ( a b c x )? a b c",
          "891:         a <- 'a'",
          "892:         b <- 'b'",
          "",
          "[Removed Lines]",
          "787:     parser.enable_ast();",
          "789:     std::shared_ptr<Ast> ast;",
          "790:     auto ret = parser.parse(\"Hello World.\", ast);",
          "792:     REQUIRE(ret == true);",
          "793:     REQUIRE(ast->nodes.size() == 1);",
          "794:     REQUIRE(ast->nodes[0]->name == \"HELLO_WORLD\");",
          "797: TEST_CASE(\"Ignore semantic value of 'and' predicate test\", \"[general]\")",
          "798: {",
          "799:     parser parser(R\"(",
          "806:     parser.enable_ast();",
          "808:     std::shared_ptr<Ast> ast;",
          "809:     auto ret = parser.parse(\"Hello World.\", ast);",
          "811:     REQUIRE(ret == true);",
          "812:     REQUIRE(ast->nodes.size() == 1);",
          "813:     REQUIRE(ast->nodes[0]->name == \"HELLO_WORLD\");",
          "816: TEST_CASE(\"Literal token on AST test1\", \"[general]\")",
          "817: {",
          "818:     parser parser(R\"(",
          "821:     parser.enable_ast();",
          "823:     std::shared_ptr<Ast> ast;",
          "824:     auto ret = parser.parse(R\"(\"a\\tb\")\", ast);",
          "826:     REQUIRE(ret == true);",
          "827:     REQUIRE(ast->is_token == true);",
          "828:     REQUIRE(ast->token == R\"(\"a\\tb\")\");",
          "829:     REQUIRE(ast->nodes.empty());",
          "832: TEST_CASE(\"Literal token on AST test2\", \"[general]\")",
          "833: {",
          "834:     parser parser(R\"(",
          "839:     parser.enable_ast();",
          "841:     std::shared_ptr<Ast> ast;",
          "842:     auto ret = parser.parse(R\"(\"a\\tb\")\", ast);",
          "844:     REQUIRE(ret == true);",
          "845:     REQUIRE(ast->is_token == false);",
          "846:     REQUIRE(ast->token.empty());",
          "847:     REQUIRE(ast->nodes.size() == 3);",
          "850: TEST_CASE(\"Literal token on AST test3\", \"[general]\")",
          "851: {",
          "852:     parser parser(R\"(",
          "857:     parser.enable_ast();",
          "859:     std::shared_ptr<Ast> ast;",
          "860:     auto ret = parser.parse(R\"(\"a\\tb\")\", ast);",
          "862:     REQUIRE(ret == true);",
          "863:     REQUIRE(ast->is_token == true);",
          "864:     REQUIRE(ast->token == R\"(\"a\\tb\")\");",
          "865:     REQUIRE(ast->nodes.empty());",
          "868: TEST_CASE(\"Missing missing definitions test\", \"[general]\")",
          "869: {",
          "870:     parser parser(R\"(",
          "874:     REQUIRE(!parser);",
          "877: TEST_CASE(\"Definition duplicates test\", \"[general]\")",
          "878: {",
          "879:     parser parser(R\"(",
          "884:     REQUIRE(!parser);",
          "887: TEST_CASE(\"Semantic values test\", \"[general]\")",
          "888: {",
          "889:     parser parser(R\"(",
          "",
          "[Added Lines]",
          "735:   parser.enable_ast();",
          "737:   std::shared_ptr<Ast> ast;",
          "738:   auto ret = parser.parse(\"Hello World.\", ast);",
          "740:   REQUIRE(ret == true);",
          "741:   REQUIRE(ast->nodes.size() == 1);",
          "742:   REQUIRE(ast->nodes[0]->name == \"HELLO_WORLD\");",
          "745: TEST_CASE(\"Ignore semantic value of 'and' predicate test\", \"[general]\") {",
          "746:   parser parser(R\"(",
          "753:   parser.enable_ast();",
          "755:   std::shared_ptr<Ast> ast;",
          "756:   auto ret = parser.parse(\"Hello World.\", ast);",
          "758:   REQUIRE(ret == true);",
          "759:   REQUIRE(ast->nodes.size() == 1);",
          "760:   REQUIRE(ast->nodes[0]->name == \"HELLO_WORLD\");",
          "763: TEST_CASE(\"Literal token on AST test1\", \"[general]\") {",
          "764:   parser parser(R\"(",
          "767:   parser.enable_ast();",
          "769:   std::shared_ptr<Ast> ast;",
          "770:   auto ret = parser.parse(R\"(\"a\\tb\")\", ast);",
          "772:   REQUIRE(ret == true);",
          "773:   REQUIRE(ast->is_token == true);",
          "774:   REQUIRE(ast->token == R\"(\"a\\tb\")\");",
          "775:   REQUIRE(ast->nodes.empty());",
          "778: TEST_CASE(\"Literal token on AST test2\", \"[general]\") {",
          "779:   parser parser(R\"(",
          "784:   parser.enable_ast();",
          "786:   std::shared_ptr<Ast> ast;",
          "787:   auto ret = parser.parse(R\"(\"a\\tb\")\", ast);",
          "789:   REQUIRE(ret == true);",
          "790:   REQUIRE(ast->is_token == false);",
          "791:   REQUIRE(ast->token.empty());",
          "792:   REQUIRE(ast->nodes.size() == 3);",
          "795: TEST_CASE(\"Literal token on AST test3\", \"[general]\") {",
          "796:   parser parser(R\"(",
          "801:   parser.enable_ast();",
          "803:   std::shared_ptr<Ast> ast;",
          "804:   auto ret = parser.parse(R\"(\"a\\tb\")\", ast);",
          "806:   REQUIRE(ret == true);",
          "807:   REQUIRE(ast->is_token == true);",
          "808:   REQUIRE(ast->token == R\"(\"a\\tb\")\");",
          "809:   REQUIRE(ast->nodes.empty());",
          "812: TEST_CASE(\"Missing missing definitions test\", \"[general]\") {",
          "813:   parser parser(R\"(",
          "817:   REQUIRE(!parser);",
          "820: TEST_CASE(\"Definition duplicates test\", \"[general]\") {",
          "821:   parser parser(R\"(",
          "826:   REQUIRE(!parser);",
          "829: TEST_CASE(\"Semantic values test\", \"[general]\") {",
          "830:   parser parser(R\"(",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "894:         x <- 'x'",
          "895:     )\");",
          "911: }",
          "916:         S <- 'a' / 'b'",
          "917:     )\");",
          "925: }",
          "930:         S <- ('a' / 'b')*",
          "931:     )\");",
          "939: }",
          "944:         S <- A? B* C?",
          "945:         A <- 'a'",
          "946:         B <- 'b'",
          "947:         C <- 'c'",
          "948:     )\");",
          "984: }",
          "989:         ROOT <- [^a-z_]+",
          "990:     )\");",
          "999: }",
          "",
          "[Removed Lines]",
          "897:  for (const auto& rule: parser.get_rule_names()){",
          "898:   parser[rule.c_str()] = [rule](const SemanticValues& sv, any&) {",
          "899:             if (rule == \"term\") {",
          "900:                 REQUIRE(any_cast<std::string>(sv[0]) == \"a at 0\");",
          "901:                 REQUIRE(any_cast<std::string>(sv[1]) == \"b at 1\");",
          "902:                 REQUIRE(any_cast<std::string>(sv[2]) == \"c at 2\");",
          "903:                 return std::string();",
          "904:             } else {",
          "905:                 return rule + \" at \" + std::to_string(sv.c_str() - sv.ss);",
          "906:             }",
          "907:   };",
          "908:  }",
          "910:  REQUIRE(parser.parse(\"abc\"));",
          "913: TEST_CASE(\"Ordered choice count\", \"[general]\")",
          "914: {",
          "915:     parser parser(R\"(",
          "919:     parser[\"S\"] = [](const SemanticValues& sv) {",
          "920:         REQUIRE(sv.choice() == 1);",
          "921:         REQUIRE(sv.choice_count() == 2);",
          "922:     };",
          "924:     parser.parse(\"b\");",
          "927: TEST_CASE(\"Ordered choice count 2\", \"[general]\")",
          "928: {",
          "929:     parser parser(R\"(",
          "933:     parser[\"S\"] = [](const SemanticValues& sv) {",
          "934:         REQUIRE(sv.choice() == 0);",
          "935:         REQUIRE(sv.choice_count() == 0);",
          "936:     };",
          "938:     parser.parse(\"b\");",
          "941: TEST_CASE(\"Semantic value tag\", \"[general]\")",
          "942: {",
          "943:     parser parser(R\"(",
          "950:     {",
          "951:         using namespace udl;",
          "952:         parser[\"S\"] = [](const SemanticValues& sv) {",
          "953:             REQUIRE(sv.size() == 1);",
          "954:             REQUIRE(sv.tags.size() == 1);",
          "955:             REQUIRE(sv.tags[0] == \"C\"_);",
          "956:         };",
          "957:         auto ret = parser.parse(\"c\");",
          "958:         REQUIRE(ret == true);",
          "959:     }",
          "961:     {",
          "962:         using namespace udl;",
          "963:         parser[\"S\"] = [](const SemanticValues& sv) {",
          "964:             REQUIRE(sv.size() == 2);",
          "965:             REQUIRE(sv.tags.size() == 2);",
          "966:             REQUIRE(sv.tags[0] == \"B\"_);",
          "967:             REQUIRE(sv.tags[1] == \"B\"_);",
          "968:         };",
          "969:         auto ret = parser.parse(\"bb\");",
          "970:         REQUIRE(ret == true);",
          "971:     }",
          "973:     {",
          "974:         using namespace udl;",
          "975:         parser[\"S\"] = [](const SemanticValues& sv) {",
          "976:             REQUIRE(sv.size() == 2);",
          "977:             REQUIRE(sv.tags.size() == 2);",
          "978:             REQUIRE(sv.tags[0] == \"A\"_);",
          "979:             REQUIRE(sv.tags[1] == \"C\"_);",
          "980:         };",
          "981:         auto ret = parser.parse(\"ac\");",
          "982:         REQUIRE(ret == true);",
          "983:     }",
          "986: TEST_CASE(\"Negated Class test\", \"[general]\")",
          "987: {",
          "988:     parser parser(R\"(",
          "992:     bool ret = parser;",
          "993:     REQUIRE(ret == true);",
          "995:     REQUIRE(parser.parse(\"ABC123\"));",
          "996:     REQUIRE_FALSE(parser.parse(\"ABcZ\"));",
          "997:     REQUIRE_FALSE(parser.parse(\"ABCZ_\"));",
          "998:     REQUIRE_FALSE(parser.parse(\"\"));",
          "",
          "[Added Lines]",
          "838:   for (const auto &rule : parser.get_rule_names()) {",
          "839:     parser[rule.data()] = [rule](const SemanticValues &vs, std::any &) {",
          "840:       if (rule == \"term\") {",
          "841:         REQUIRE(std::any_cast<std::string>(vs[0]) == \"a at 0\");",
          "842:         REQUIRE(std::any_cast<std::string>(vs[1]) == \"b at 1\");",
          "843:         REQUIRE(std::any_cast<std::string>(vs[2]) == \"c at 2\");",
          "844:         return std::string();",
          "845:       } else {",
          "846:         return rule + \" at \" + std::to_string(vs.sv().data() - vs.ss);",
          "847:       }",
          "848:     };",
          "849:   }",
          "851:   REQUIRE(parser.parse(\"abc\"));",
          "854: TEST_CASE(\"Ordered choice count\", \"[general]\") {",
          "855:   parser parser(R\"(",
          "859:   parser[\"S\"] = [](const SemanticValues &vs) {",
          "860:     REQUIRE(vs.choice() == 1);",
          "861:     REQUIRE(vs.choice_count() == 2);",
          "862:   };",
          "864:   parser.parse(\"b\");",
          "867: TEST_CASE(\"Ordered choice count 2\", \"[general]\") {",
          "868:   parser parser(R\"(",
          "872:   parser[\"S\"] = [](const SemanticValues &vs) {",
          "873:     REQUIRE(vs.choice() == 0);",
          "874:     REQUIRE(vs.choice_count() == 0);",
          "875:   };",
          "877:   parser.parse(\"b\");",
          "880: TEST_CASE(\"Semantic value tag\", \"[general]\") {",
          "881:   parser parser(R\"(",
          "888:   {",
          "889:     using namespace udl;",
          "890:     parser[\"S\"] = [](const SemanticValues &vs) {",
          "891:       REQUIRE(vs.size() == 1);",
          "892:       REQUIRE(vs.tags.size() == 1);",
          "893:       REQUIRE(vs.tags[0] == \"C\"_);",
          "894:     };",
          "895:     auto ret = parser.parse(\"c\");",
          "896:     REQUIRE(ret == true);",
          "897:   }",
          "899:   {",
          "900:     using namespace udl;",
          "901:     parser[\"S\"] = [](const SemanticValues &vs) {",
          "902:       REQUIRE(vs.size() == 2);",
          "903:       REQUIRE(vs.tags.size() == 2);",
          "904:       REQUIRE(vs.tags[0] == \"B\"_);",
          "905:       REQUIRE(vs.tags[1] == \"B\"_);",
          "906:     };",
          "907:     auto ret = parser.parse(\"bb\");",
          "908:     REQUIRE(ret == true);",
          "909:   }",
          "911:   {",
          "912:     using namespace udl;",
          "913:     parser[\"S\"] = [](const SemanticValues &vs) {",
          "914:       REQUIRE(vs.size() == 2);",
          "915:       REQUIRE(vs.tags.size() == 2);",
          "916:       REQUIRE(vs.tags[0] == \"A\"_);",
          "917:       REQUIRE(vs.tags[1] == \"C\"_);",
          "918:     };",
          "919:     auto ret = parser.parse(\"ac\");",
          "920:     REQUIRE(ret == true);",
          "921:   }",
          "924: TEST_CASE(\"Negated Class test\", \"[general]\") {",
          "925:   parser parser(R\"(",
          "929:   bool ret = parser;",
          "930:   REQUIRE(ret == true);",
          "932:   REQUIRE(parser.parse(\"ABC123\"));",
          "933:   REQUIRE_FALSE(parser.parse(\"ABcZ\"));",
          "934:   REQUIRE_FALSE(parser.parse(\"ABCZ_\"));",
          "935:   REQUIRE_FALSE(parser.parse(\"\"));",
          "",
          "---------------"
        ],
        "test/test2.cc||test/test2.cc": [
          "File: test/test2.cc -> test/test2.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "98:         WH    <- [ \\t]*",
          "99:     )\");",
          "102: }",
          "107:         ROOT  <- WH TOKEN+ WH",
          "108:         TOKEN <- [a-z0-9]*",
          "109:         WH    <- [ \\t]*",
          "110:     )\");",
          "113: }",
          "118:         ROOT  <- WH TOKEN* WH",
          "119:         TOKEN <- !'word1'",
          "120:         WH    <- [ \\t]*",
          "121:     )\");",
          "124: }",
          "129:         ROOT  <- WH TOKEN* WH",
          "130:         TOKEN <- &'word1'",
          "131:         WH    <- [ \\t]*",
          "132:     )\");",
          "135: }",
          "140:         Numbers <- Number*",
          "141:         Number <- [0-9]+ / Spacing",
          "142:         Spacing <- ' ' / '\\t' / '\\n' / EOF # EOF is empty",
          "143:         EOF <- !.",
          "144:     )\");",
          "147: }",
          "152:         S <- ''*",
          "153:     )\");",
          "156: }",
          "161:         S <- A*",
          "162:         A <- ''",
          "163:     )\");",
          "166: }",
          "171:         Numbers <- Number* EOF",
          "172:         Number <- [0-9]+ / Spacing",
          "173:         Spacing <- ' ' / '\\t' / '\\n'",
          "174:         EOF <- !.",
          "175:     )\");",
          "178: }",
          "183:         ROOT      <-  _ ('[' TAG_NAME ']' _)*",
          "184:         # In a sequence operator, if there is at least one non-empty element, we can treat it as non-empty",
          "185:         TAG_NAME  <-  (!']' .)+",
          "186:         _         <-  [ \\t]*",
          "187:     )\");",
          "190: }",
          "195:         EXPRESSION       <-  _ TERM (TERM_OPERATOR TERM)*",
          "196:         TERM             <-  FACTOR (FACTOR_OPERATOR FACTOR)*",
          "197:         FACTOR           <-  NUMBER / '(' _ EXPRESSION ')' _ # Recursive...",
          "",
          "[Removed Lines]",
          "101:     REQUIRE(!pg);",
          "104: TEST_CASE(\"Infinite loop 2\", \"[infinite loop]\")",
          "105: {",
          "106:     parser pg(R\"(",
          "112:     REQUIRE(!pg);",
          "115: TEST_CASE(\"Infinite loop 3\", \"[infinite loop]\")",
          "116: {",
          "117:     parser pg(R\"(",
          "123:     REQUIRE(!pg);",
          "126: TEST_CASE(\"Infinite loop 4\", \"[infinite loop]\")",
          "127: {",
          "128:     parser pg(R\"(",
          "134:     REQUIRE(!pg);",
          "137: TEST_CASE(\"Infinite loop 5\", \"[infinite loop]\")",
          "138: {",
          "139:     parser pg(R\"(",
          "146:     REQUIRE(!pg);",
          "149: TEST_CASE(\"Infinite loop 6\", \"[infinite loop]\")",
          "150: {",
          "151:     parser pg(R\"(",
          "155:     REQUIRE(!pg);",
          "158: TEST_CASE(\"Infinite loop 7\", \"[infinite loop]\")",
          "159: {",
          "160:     parser pg(R\"(",
          "165:     REQUIRE(!pg);",
          "168: TEST_CASE(\"Not infinite 1\", \"[infinite loop]\")",
          "169: {",
          "170:     parser pg(R\"(",
          "177:     REQUIRE(!!pg); // OK",
          "180: TEST_CASE(\"Not infinite 2\", \"[infinite loop]\")",
          "181: {",
          "182:     parser pg(R\"(",
          "189:     REQUIRE(!!pg); // OK",
          "192: TEST_CASE(\"Not infinite 3\", \"[infinite loop]\")",
          "193: {",
          "194:     parser pg(R\"(",
          "",
          "[Added Lines]",
          "101:   REQUIRE(!pg);",
          "104: TEST_CASE(\"Infinite loop 2\", \"[infinite loop]\") {",
          "105:   parser pg(R\"(",
          "111:   REQUIRE(!pg);",
          "114: TEST_CASE(\"Infinite loop 3\", \"[infinite loop]\") {",
          "115:   parser pg(R\"(",
          "121:   REQUIRE(!pg);",
          "124: TEST_CASE(\"Infinite loop 4\", \"[infinite loop]\") {",
          "125:   parser pg(R\"(",
          "131:   REQUIRE(!pg);",
          "134: TEST_CASE(\"Infinite loop 5\", \"[infinite loop]\") {",
          "135:   parser pg(R\"(",
          "142:   REQUIRE(!pg);",
          "145: TEST_CASE(\"Infinite loop 6\", \"[infinite loop]\") {",
          "146:   parser pg(R\"(",
          "150:   REQUIRE(!pg);",
          "153: TEST_CASE(\"Infinite loop 7\", \"[infinite loop]\") {",
          "154:   parser pg(R\"(",
          "159:   REQUIRE(!pg);",
          "162: TEST_CASE(\"Not infinite 1\", \"[infinite loop]\") {",
          "163:   parser pg(R\"(",
          "170:   REQUIRE(!!pg); // OK",
          "173: TEST_CASE(\"Not infinite 2\", \"[infinite loop]\") {",
          "174:   parser pg(R\"(",
          "181:   REQUIRE(!!pg); // OK",
          "184: TEST_CASE(\"Not infinite 3\", \"[infinite loop]\") {",
          "185:   parser pg(R\"(",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "201:         _                <-  [ \\t\\r\\n]*",
          "202:     )\");",
          "205: }",
          "210:         START            <-  _ EXPRESSION",
          "211:         EXPRESSION       <-  ATOM (OPERATOR ATOM)* {",
          "212:                                precedence",
          "",
          "[Removed Lines]",
          "204:     REQUIRE(!!pg); // OK",
          "207: TEST_CASE(\"Precedence climbing\", \"[precedence]\")",
          "208: {",
          "209:     parser parser(R\"(",
          "",
          "[Added Lines]",
          "195:   REQUIRE(!!pg); // OK",
          "198: TEST_CASE(\"Precedence climbing\", \"[precedence]\") {",
          "199:   parser parser(R\"(",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "220:   T(S)             <-  < S > _",
          "221:  )\");",
          "253:     }",
          "263: }",
          "269:         EXPRESSION             <-  INFIX_EXPRESSION(ATOM, OPERATOR)",
          "270:         INFIX_EXPRESSION(A, O) <-  A (O A)* {",
          "271:                                      precedence",
          "",
          "[Removed Lines]",
          "223:     parser.enable_packrat_parsing();",
          "226:     parser[\"EXPRESSION\"] = [](const SemanticValues& sv) -> long {",
          "227:         auto result = any_cast<long>(sv[0]);",
          "228:         if (sv.size() > 1) {",
          "229:             auto ope = any_cast<char>(sv[1]);",
          "230:             auto num = any_cast<long>(sv[2]);",
          "231:             switch (ope) {",
          "232:                 case '+': result += num; break;",
          "233:                 case '-': result -= num; break;",
          "234:                 case '*': result *= num; break;",
          "235:                 case '/': result /= num; break;",
          "236:             }",
          "237:         }",
          "238:         return result;",
          "239:     };",
          "240:     parser[\"OPERATOR\"] = [](const SemanticValues& sv) { return *sv.c_str(); };",
          "241:     parser[\"NUMBER\"] = [](const SemanticValues& sv) { return atol(sv.c_str()); };",
          "243:     bool ret = parser;",
          "244:     REQUIRE(ret == true);",
          "246:     {",
          "247:         auto expr = \" 1 + 2 * 3 * (4 - 5 + 6) / 7 - 8 \";",
          "248:         long val = 0;",
          "249:         ret = parser.parse(expr, val);",
          "251:         REQUIRE(ret == true);",
          "252:         REQUIRE(val == -3);",
          "255:     {",
          "256:       auto expr = \"-1+-2--3\"; // -1 + -2 - -3 = 0",
          "257:       long val = 0;",
          "258:       ret = parser.parse(expr, val);",
          "260:       REQUIRE(ret == true);",
          "261:       REQUIRE(val == 0);",
          "262:     }",
          "265: TEST_CASE(\"Precedence climbing with macro\", \"[precedence]\")",
          "266: {",
          "268:     parser parser(R\"(",
          "",
          "[Added Lines]",
          "213:   parser.enable_packrat_parsing();",
          "216:   parser[\"EXPRESSION\"] = [](const SemanticValues &vs) -> long {",
          "217:     auto result = std::any_cast<long>(vs[0]);",
          "218:     if (vs.size() > 1) {",
          "219:       auto ope = std::any_cast<char>(vs[1]);",
          "220:       auto num = std::any_cast<long>(vs[2]);",
          "221:       switch (ope) {",
          "222:       case '+': result += num; break;",
          "223:       case '-': result -= num; break;",
          "224:       case '*': result *= num; break;",
          "225:       case '/': result /= num; break;",
          "226:       }",
          "228:     return result;",
          "229:   };",
          "230:   parser[\"OPERATOR\"] = [](const SemanticValues &vs) { return *vs.sv().data(); };",
          "231:   parser[\"NUMBER\"] = [](const SemanticValues &vs) { return vs.token_to_number<long>(); };",
          "233:   bool ret = parser;",
          "234:   REQUIRE(ret == true);",
          "236:   {",
          "237:     auto expr = \" 1 + 2 * 3 * (4 - 5 + 6) / 7 - 8 \";",
          "238:     long val = 0;",
          "239:     ret = parser.parse(expr, val);",
          "241:     REQUIRE(ret == true);",
          "242:     REQUIRE(val == -3);",
          "243:   }",
          "245:   {",
          "246:     auto expr = \"-1+-2--3\"; // -1 + -2 - -3 = 0",
          "247:     long val = 0;",
          "248:     ret = parser.parse(expr, val);",
          "250:     REQUIRE(ret == true);",
          "251:     REQUIRE(val == 0);",
          "252:   }",
          "255: TEST_CASE(\"Precedence climbing with macro\", \"[precedence]\") {",
          "257:   parser parser(R\"(",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "278:         %whitespace            <-  [ \\t]*",
          "279:  )\");",
          "311:     }",
          "321: }",
          "326:         START            <-  _ EXPRESSION",
          "327:         EXPRESSION       <-  ATOM (OPERATOR ATOM1)* {",
          "328:                                precedence",
          "",
          "[Removed Lines]",
          "281:     parser.enable_packrat_parsing();",
          "283:     bool ret = parser;",
          "284:     REQUIRE(ret == true);",
          "287:     parser[\"INFIX_EXPRESSION\"] = [](const SemanticValues& sv) -> long {",
          "288:         auto result = any_cast<long>(sv[0]);",
          "289:         if (sv.size() > 1) {",
          "290:             auto ope = any_cast<char>(sv[1]);",
          "291:             auto num = any_cast<long>(sv[2]);",
          "292:             switch (ope) {",
          "293:                 case '+': result += num; break;",
          "294:                 case '-': result -= num; break;",
          "295:                 case '*': result *= num; break;",
          "296:                 case '/': result /= num; break;",
          "297:             }",
          "298:         }",
          "299:         return result;",
          "300:     };",
          "301:     parser[\"OPERATOR\"] = [](const SemanticValues& sv) { return *sv.c_str(); };",
          "302:     parser[\"NUMBER\"] = [](const SemanticValues& sv) { return atol(sv.c_str()); };",
          "304:     {",
          "305:         auto expr = \" 1 + 2 * 3 * (4 - 5 + 6) / 7 - 8 \";",
          "306:         long val = 0;",
          "307:         ret = parser.parse(expr, val);",
          "309:         REQUIRE(ret == true);",
          "310:         REQUIRE(val == -3);",
          "313:     {",
          "314:       auto expr = \"-1+-2--3\"; // -1 + -2 - -3 = 0",
          "315:       long val = 0;",
          "316:       ret = parser.parse(expr, val);",
          "318:       REQUIRE(ret == true);",
          "319:       REQUIRE(val == 0);",
          "320:     }",
          "323: TEST_CASE(\"Precedence climbing error1\", \"[precedence]\")",
          "324: {",
          "325:     parser parser(R\"(",
          "",
          "[Added Lines]",
          "270:   parser.enable_packrat_parsing();",
          "272:   bool ret = parser;",
          "273:   REQUIRE(ret == true);",
          "276:   parser[\"INFIX_EXPRESSION\"] = [](const SemanticValues &vs) -> long {",
          "277:     auto result = std::any_cast<long>(vs[0]);",
          "278:     if (vs.size() > 1) {",
          "279:       auto ope = std::any_cast<char>(vs[1]);",
          "280:       auto num = std::any_cast<long>(vs[2]);",
          "281:       switch (ope) {",
          "282:       case '+': result += num; break;",
          "283:       case '-': result -= num; break;",
          "284:       case '*': result *= num; break;",
          "285:       case '/': result /= num; break;",
          "286:       }",
          "288:     return result;",
          "289:   };",
          "290:   parser[\"OPERATOR\"] = [](const SemanticValues &vs) { return *vs.sv().data(); };",
          "291:   parser[\"NUMBER\"] = [](const SemanticValues &vs) { return vs.token_to_number<long>(); };",
          "293:   {",
          "294:     auto expr = \" 1 + 2 * 3 * (4 - 5 + 6) / 7 - 8 \";",
          "295:     long val = 0;",
          "296:     ret = parser.parse(expr, val);",
          "298:     REQUIRE(ret == true);",
          "299:     REQUIRE(val == -3);",
          "300:   }",
          "302:   {",
          "303:     auto expr = \"-1+-2--3\"; // -1 + -2 - -3 = 0",
          "304:     long val = 0;",
          "305:     ret = parser.parse(expr, val);",
          "307:     REQUIRE(ret == true);",
          "308:     REQUIRE(val == 0);",
          "309:   }",
          "312: TEST_CASE(\"Precedence climbing error1\", \"[precedence]\") {",
          "313:   parser parser(R\"(",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "337:   T(S)             <-  < S > _",
          "338:  )\");",
          "342: }",
          "347:         START            <-  _ EXPRESSION",
          "348:         EXPRESSION       <-  ATOM OPERATOR ATOM {",
          "349:                                precedence",
          "",
          "[Removed Lines]",
          "340:     bool ret = parser;",
          "341:     REQUIRE(ret == false);",
          "344: TEST_CASE(\"Precedence climbing error2\", \"[precedence]\")",
          "345: {",
          "346:     parser parser(R\"(",
          "",
          "[Added Lines]",
          "328:   bool ret = parser;",
          "329:   REQUIRE(ret == false);",
          "332: TEST_CASE(\"Precedence climbing error2\", \"[precedence]\") {",
          "333:   parser parser(R\"(",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "357:   T(S)             <-  < S > _",
          "358:  )\");",
          "362: }",
          "364: TEST_CASE(\"Precedence climbing error3\", \"[precedence]\") {",
          "366:         EXPRESSION               <-  PRECEDENCE_PARSING(ATOM, OPERATOR)",
          "367:         PRECEDENCE_PARSING(A, O) <-  A (O A)+ {",
          "368:                                        precedence",
          "",
          "[Removed Lines]",
          "360:     bool ret = parser;",
          "361:     REQUIRE(ret == false);",
          "365:     parser parser(R\"(",
          "",
          "[Added Lines]",
          "347:   bool ret = parser;",
          "348:   REQUIRE(ret == false);",
          "352:   parser parser(R\"(",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "375:         %whitespace              <-  [ \\t]*",
          "376:  )\");",
          "380: }",
          "382: TEST_CASE(\"Packrat parser test with %whitespace%\", \"[packrat]\") {",
          "384:         ROOT         <-  'a'",
          "385:         %whitespace  <-  SPACE*",
          "386:         SPACE        <-  ' '",
          "387:     )\");",
          "393: }",
          "398:         EXPRESSION       <-  _ LIST(TERM, TERM_OPERATOR)",
          "399:         TERM             <-  LIST(FACTOR, FACTOR_OPERATOR)",
          "400:         FACTOR           <-  NUMBER / T('(') EXPRESSION T(')')",
          "",
          "[Removed Lines]",
          "378:     bool ret = parser;",
          "379:     REQUIRE(ret == false);",
          "383:     peg::parser parser(R\"(",
          "389:     parser.enable_packrat_parsing();",
          "391:     auto ret = parser.parse(\"a\");",
          "392:     REQUIRE(ret == true);",
          "395: TEST_CASE(\"Packrat parser test with macro\", \"[packrat]\")",
          "396: {",
          "397:     parser parser(R\"(",
          "",
          "[Added Lines]",
          "365:   bool ret = parser;",
          "366:   REQUIRE(ret == false);",
          "370:   peg::parser parser(R\"(",
          "376:   parser.enable_packrat_parsing();",
          "378:   auto ret = parser.parse(\"a\");",
          "379:   REQUIRE(ret == true);",
          "382: TEST_CASE(\"Packrat parser test with macro\", \"[packrat]\") {",
          "383:   parser parser(R\"(",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "406:   T(S)             <-  < S > _",
          "407:  )\");",
          "413: }",
          "416:   peg::parser parser(R\"(",
          "417:     Expression  <- Atom (Operator Atom)* { precedence L + - L * / }",
          "418:     Atom        <- _? Number _?",
          "",
          "[Removed Lines]",
          "409:     parser.enable_packrat_parsing();",
          "411:     auto ret = parser.parse(\" 1 + 2 * 3 * (4 - 5 + 6) / 7 - 8 \");",
          "412:     REQUIRE(ret == true);",
          "415: TEST_CASE(\"Packrat parser test with precedence expression parser\", \"[packrat]\") {",
          "",
          "[Added Lines]",
          "395:   parser.enable_packrat_parsing();",
          "397:   auto ret = parser.parse(\" 1 + 2 * 3 * (4 - 5 + 6) / 7 - 8 \");",
          "398:   REQUIRE(ret == true);",
          "401: TEST_CASE(\"Packrat parser test with precedence expression parser\",",
          "402:           \"[packrat]\") {",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "430:   REQUIRE(ret == true);",
          "431: }",
          "436:         START  <- _ LQUOTE < (!RQUOTE .)* > RQUOTE _",
          "437:         LQUOTE <- 'R\"' $delm< [a-zA-Z]* > '('",
          "438:         RQUOTE <- ')' $delm '\"'",
          "439:         ~_     <- [ \\t\\r\\n]*",
          "440:     )\");",
          "450:             R\"(\"hello world\")\"",
          "451:         )delm\");",
          "460:             R\"foo(\"(hello world)\")foo\"",
          "461:         )delm\");",
          "470:             R\"foo(\"(hello world)foo\")foo\"",
          "471:         )delm\");",
          "480:             R\"foo(\"(hello world)\")bar\"",
          "481:         )delm\");",
          "486: }",
          "491:         START  <- _ LQUOTE (!RQUOTE .)* RQUOTE _",
          "492:         LQUOTE <- 'R\"' $delm< [a-zA-Z]* > '('",
          "493:         RQUOTE <- ')' $delm2 '\"'",
          "494:         ~_     <- [ \\t\\r\\n]*",
          "495:     )\");",
          "499:             R\"foo(\"(hello world)\")foo\"",
          "500:         )delm\"),",
          "502: }",
          "508:         ROOT      <- CONTENT",
          "509:         CONTENT   <- (ELEMENT / TEXT)*",
          "510:         ELEMENT   <- $(STAG CONTENT ETAG)",
          "",
          "[Removed Lines]",
          "433: TEST_CASE(\"Backreference test\", \"[backreference]\")",
          "434: {",
          "435:     parser parser(R\"(",
          "442:     std::string token;",
          "443:     parser[\"START\"] = [&](const SemanticValues& sv) {",
          "444:         token = sv.token();",
          "445:     };",
          "447:     {",
          "448:         token.clear();",
          "449:         auto ret = parser.parse(R\"delm(",
          "453:         REQUIRE(ret == true);",
          "454:         REQUIRE(token == \"\\\"hello world\\\"\");",
          "455:     }",
          "457:     {",
          "458:         token.clear();",
          "459:         auto ret = parser.parse(R\"delm(",
          "463:         REQUIRE(ret == true);",
          "464:         REQUIRE(token == \"\\\"(hello world)\\\"\");",
          "465:     }",
          "467:     {",
          "468:         token.clear();",
          "469:         auto ret = parser.parse(R\"delm(",
          "473:         REQUIRE(ret == false);",
          "474:         REQUIRE(token == \"\\\"(hello world\");",
          "475:     }",
          "477:     {",
          "478:         token.clear();",
          "479:         auto ret = parser.parse(R\"delm(",
          "483:         REQUIRE(ret == false);",
          "484:         REQUIRE(token.empty());",
          "485:     }",
          "488: TEST_CASE(\"Invalid backreference test\", \"[backreference]\")",
          "489: {",
          "490:     parser parser(R\"(",
          "497:     REQUIRE_THROWS_AS(",
          "498:         parser.parse(R\"delm(",
          "501:         std::runtime_error);",
          "505: TEST_CASE(\"Nested capture test\", \"[backreference]\")",
          "506: {",
          "507:     parser parser(R\"(",
          "",
          "[Added Lines]",
          "420: TEST_CASE(\"Backreference test\", \"[backreference]\") {",
          "421:   parser parser(R\"(",
          "428:   std::string token;",
          "429:   parser[\"START\"] = [&](const SemanticValues &vs) { token = vs.token(); };",
          "431:   {",
          "432:     token.clear();",
          "433:     auto ret = parser.parse(R\"delm(",
          "437:     REQUIRE(ret == true);",
          "438:     REQUIRE(token == \"\\\"hello world\\\"\");",
          "439:   }",
          "441:   {",
          "442:     token.clear();",
          "443:     auto ret = parser.parse(R\"delm(",
          "447:     REQUIRE(ret == true);",
          "448:     REQUIRE(token == \"\\\"(hello world)\\\"\");",
          "449:   }",
          "451:   {",
          "452:     token.clear();",
          "453:     auto ret = parser.parse(R\"delm(",
          "457:     REQUIRE(ret == false);",
          "458:     REQUIRE(token == \"\\\"(hello world\");",
          "459:   }",
          "461:   {",
          "462:     token.clear();",
          "463:     auto ret = parser.parse(R\"delm(",
          "467:     REQUIRE(ret == false);",
          "468:     REQUIRE(token.empty());",
          "469:   }",
          "472: TEST_CASE(\"Invalid backreference test\", \"[backreference]\") {",
          "473:   parser parser(R\"(",
          "480:   REQUIRE_THROWS_AS(parser.parse(R\"delm(",
          "483:                     std::runtime_error);",
          "486: TEST_CASE(\"Nested capture test\", \"[backreference]\") {",
          "487:   parser parser(R\"(",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "515:         TEXT_DATA <- ![<] .",
          "516:     )\");",
          "522: }",
          "527:         TREE           <- WRONG_BRANCH / CORRECT_BRANCH",
          "528:         WRONG_BRANCH   <- BRANCH THAT IS_capture WRONG",
          "529:         CORRECT_BRANCH <- BRANCH THAT IS_backref CORRECT",
          "",
          "[Removed Lines]",
          "518:     REQUIRE(parser.parse(\"This is <b>a <u>test</u> text</b>.\"));",
          "519:     REQUIRE(!parser.parse(\"This is <b>a <u>test</b> text</u>.\"));",
          "520:     REQUIRE(!parser.parse(\"This is <b>a <u>test text</b>.\"));",
          "521:     REQUIRE(!parser.parse(\"This is a <u>test</u> text</b>.\"));",
          "524: TEST_CASE(\"Backreference with Prioritized Choice test\", \"[backreference]\")",
          "525: {",
          "526:     parser parser(R\"(",
          "",
          "[Added Lines]",
          "498:   REQUIRE(parser.parse(\"This is <b>a <u>test</u> text</b>.\"));",
          "499:   REQUIRE(!parser.parse(\"This is <b>a <u>test</b> text</u>.\"));",
          "500:   REQUIRE(!parser.parse(\"This is <b>a <u>test text</b>.\"));",
          "501:   REQUIRE(!parser.parse(\"This is a <u>test</u> text</b>.\"));",
          "504: TEST_CASE(\"Backreference with Prioritized Choice test\", \"[backreference]\") {",
          "505:   parser parser(R\"(",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "535:         CORRECT        <- 'correct'",
          "536:     )\");",
          "539: }",
          "544:         TREE           <- WRONG_BRANCH* CORRECT_BRANCH",
          "545:         WRONG_BRANCH   <- BRANCH THAT IS_capture WRONG",
          "546:         CORRECT_BRANCH <- BRANCH THAT IS_backref CORRECT",
          "",
          "[Removed Lines]",
          "538:     REQUIRE_THROWS_AS(parser.parse(\"branchthatiscorrect\"), std::runtime_error);",
          "541: TEST_CASE(\"Backreference with Zero or More test\", \"[backreference]\")",
          "542: {",
          "543:     parser parser(R\"(",
          "",
          "[Added Lines]",
          "517:   REQUIRE_THROWS_AS(parser.parse(\"branchthatiscorrect\"), std::runtime_error);",
          "520: TEST_CASE(\"Backreference with Zero or More test\", \"[backreference]\") {",
          "521:   parser parser(R\"(",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "552:         CORRECT        <- 'correct'",
          "553:     )\");",
          "561: }",
          "566:         TREE           <- WRONG_BRANCH+ CORRECT_BRANCH",
          "567:         WRONG_BRANCH   <- BRANCH THAT IS_capture WRONG",
          "568:         CORRECT_BRANCH <- BRANCH THAT IS_backref CORRECT",
          "",
          "[Removed Lines]",
          "555:     REQUIRE(parser.parse(\"branchthatiswrongbranchthatiscorrect\"));",
          "556:     REQUIRE(!parser.parse(\"branchthatiswrongbranchthatIscorrect\"));",
          "557:     REQUIRE(!parser.parse(\"branchthatiswrongbranchthatIswrongbranchthatiscorrect\"));",
          "558:     REQUIRE(parser.parse(\"branchthatiswrongbranchthatIswrongbranchthatIscorrect\"));",
          "559:     REQUIRE_THROWS_AS(parser.parse(\"branchthatiscorrect\"), std::runtime_error);",
          "560:     REQUIRE_THROWS_AS(parser.parse(\"branchthatiswron_branchthatiscorrect\"), std::runtime_error);",
          "563: TEST_CASE(\"Backreference with One or More test\", \"[backreference]\")",
          "564: {",
          "565:     parser parser(R\"(",
          "",
          "[Added Lines]",
          "533:   REQUIRE(parser.parse(\"branchthatiswrongbranchthatiscorrect\"));",
          "534:   REQUIRE(!parser.parse(\"branchthatiswrongbranchthatIscorrect\"));",
          "535:   REQUIRE(",
          "536:       !parser.parse(\"branchthatiswrongbranchthatIswrongbranchthatiscorrect\"));",
          "537:   REQUIRE(",
          "538:       parser.parse(\"branchthatiswrongbranchthatIswrongbranchthatIscorrect\"));",
          "539:   REQUIRE_THROWS_AS(parser.parse(\"branchthatiscorrect\"), std::runtime_error);",
          "540:   REQUIRE_THROWS_AS(parser.parse(\"branchthatiswron_branchthatiscorrect\"),",
          "541:                     std::runtime_error);",
          "544: TEST_CASE(\"Backreference with One or More test\", \"[backreference]\") {",
          "545:   parser parser(R\"(",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "574:         CORRECT        <- 'correct'",
          "575:     )\");",
          "583: }",
          "588:         TREE           <- WRONG_BRANCH? CORRECT_BRANCH",
          "589:         WRONG_BRANCH   <- BRANCH THAT IS_capture WRONG",
          "590:         CORRECT_BRANCH <- BRANCH THAT IS_backref CORRECT",
          "",
          "[Removed Lines]",
          "577:     REQUIRE(parser.parse(\"branchthatiswrongbranchthatiscorrect\"));",
          "578:     REQUIRE(!parser.parse(\"branchthatiswrongbranchthatIscorrect\"));",
          "579:     REQUIRE(!parser.parse(\"branchthatiswrongbranchthatIswrongbranchthatiscorrect\"));",
          "580:     REQUIRE(parser.parse(\"branchthatiswrongbranchthatIswrongbranchthatIscorrect\"));",
          "581:     REQUIRE(!parser.parse(\"branchthatiscorrect\"));",
          "582:     REQUIRE(!parser.parse(\"branchthatiswron_branchthatiscorrect\"));",
          "585: TEST_CASE(\"Backreference with Option test\", \"[backreference]\")",
          "586: {",
          "587:     parser parser(R\"(",
          "",
          "[Added Lines]",
          "557:   REQUIRE(parser.parse(\"branchthatiswrongbranchthatiscorrect\"));",
          "558:   REQUIRE(!parser.parse(\"branchthatiswrongbranchthatIscorrect\"));",
          "559:   REQUIRE(",
          "560:       !parser.parse(\"branchthatiswrongbranchthatIswrongbranchthatiscorrect\"));",
          "561:   REQUIRE(",
          "562:       parser.parse(\"branchthatiswrongbranchthatIswrongbranchthatIscorrect\"));",
          "563:   REQUIRE(!parser.parse(\"branchthatiscorrect\"));",
          "564:   REQUIRE(!parser.parse(\"branchthatiswron_branchthatiscorrect\"));",
          "567: TEST_CASE(\"Backreference with Option test\", \"[backreference]\") {",
          "568:   parser parser(R\"(",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "596:         CORRECT        <- 'correct'",
          "597:     )\");",
          "605: }",
          "610:         START <- '(' DIGIT{3} ') ' DIGIT{3} '-' DIGIT{4}",
          "611:         DIGIT <- [0-9]",
          "612:     )\");",
          "617: }",
          "622:         START <- DIGIT{2,4}",
          "623:         DIGIT <- [0-9]",
          "624:     )\");",
          "630: }",
          "635:         START <- DIGIT{2,1} # invalid range",
          "636:         DIGIT <- [0-9]",
          "637:     )\");",
          "641: }",
          "646:         START <- DIGIT{2,}",
          "647:         DIGIT <- [0-9]",
          "648:     )\");",
          "653: }",
          "658:         START <- DIGIT{,2}",
          "659:         DIGIT <- [0-9]",
          "660:     )\");",
          "665: }",
          "670:         A <- A 'a'",
          "671:         B <- A 'a'",
          "672:     )\");",
          "675: }",
          "680:         A  <- 'a' / 'b'? B 'c'",
          "681:         B  <- A",
          "682:     )\");",
          "685: }",
          "690:         A <- 'a'* A*",
          "691:     )\");",
          "694: }",
          "699:         A <- B",
          "700:         B <- _ A",
          "701:         _ <- ' '* # Zero or more",
          "702:     )\");",
          "705: }",
          "714: }",
          "719:         ROOT <- _ 'Hello' _ NAME '!' _",
          "720:     )\",",
          "768:         \u6587 <- \u4fee\u98fe\u8a9e? \u4e3b\u8a9e \u8ff0\u8a9e '\u3002'",
          "769:         \u4e3b\u8a9e <- \u540d\u8a5e \u52a9\u8a5e",
          "770:         \u8ff0\u8a9e <- \u52d5\u8a5e \u52a9\u8a5e",
          "",
          "[Removed Lines]",
          "599:     REQUIRE(parser.parse(\"branchthatiswrongbranchthatiscorrect\"));",
          "600:     REQUIRE(!parser.parse(\"branchthatiswrongbranchthatIscorrect\"));",
          "601:     REQUIRE(!parser.parse(\"branchthatiswrongbranchthatIswrongbranchthatiscorrect\"));",
          "602:     REQUIRE(!parser.parse(\"branchthatiswrongbranchthatIswrongbranchthatIscorrect\"));",
          "603:     REQUIRE_THROWS_AS(parser.parse(\"branchthatiscorrect\"), std::runtime_error);",
          "604:     REQUIRE_THROWS_AS(parser.parse(\"branchthatiswron_branchthatiscorrect\"), std::runtime_error);",
          "607: TEST_CASE(\"Repetition {0}\", \"[repetition]\")",
          "608: {",
          "609:     parser parser(R\"(",
          "613:     REQUIRE(parser.parse(\"(123) 456-7890\"));",
          "614:     REQUIRE(!parser.parse(\"(12a) 456-7890\"));",
          "615:     REQUIRE(!parser.parse(\"(123) 45-7890\"));",
          "616:     REQUIRE(!parser.parse(\"(123) 45-7a90\"));",
          "619: TEST_CASE(\"Repetition {2,4}\", \"[repetition]\")",
          "620: {",
          "621:     parser parser(R\"(",
          "625:     REQUIRE(!parser.parse(\"1\"));",
          "626:     REQUIRE(parser.parse(\"12\"));",
          "627:     REQUIRE(parser.parse(\"123\"));",
          "628:     REQUIRE(parser.parse(\"1234\"));",
          "629:     REQUIRE(!parser.parse(\"12345\"));",
          "632: TEST_CASE(\"Repetition {2,1}\", \"[repetition]\")",
          "633: {",
          "634:     parser parser(R\"(",
          "638:     REQUIRE(!parser.parse(\"1\"));",
          "639:     REQUIRE(parser.parse(\"12\"));",
          "640:     REQUIRE(!parser.parse(\"123\"));",
          "643: TEST_CASE(\"Repetition {2,}\", \"[repetition]\")",
          "644: {",
          "645:     parser parser(R\"(",
          "649:     REQUIRE(!parser.parse(\"1\"));",
          "650:     REQUIRE(parser.parse(\"12\"));",
          "651:     REQUIRE(parser.parse(\"123\"));",
          "652:     REQUIRE(parser.parse(\"1234\"));",
          "655: TEST_CASE(\"Repetition {,2}\", \"[repetition]\")",
          "656: {",
          "657:     parser parser(R\"(",
          "661:     REQUIRE(parser.parse(\"1\"));",
          "662:     REQUIRE(parser.parse(\"12\"));",
          "663:     REQUIRE(!parser.parse(\"123\"));",
          "664:     REQUIRE(!parser.parse(\"1234\"));",
          "667: TEST_CASE(\"Left recursive test\", \"[left recursive]\")",
          "668: {",
          "669:     parser parser(R\"(",
          "674:     REQUIRE(!parser);",
          "677: TEST_CASE(\"Left recursive with option test\", \"[left recursive]\")",
          "678: {",
          "679:     parser parser(R\"(",
          "684:     REQUIRE(!parser);",
          "687: TEST_CASE(\"Left recursive with zom test\", \"[left recursive]\")",
          "688: {",
          "689:     parser parser(R\"(",
          "693:     REQUIRE(!parser);",
          "696: TEST_CASE(\"Left recursive with a ZOM content rule\", \"[left recursive]\")",
          "697: {",
          "698:     parser parser(R\"(",
          "704:     REQUIRE(!parser);",
          "707: TEST_CASE(\"Left recursive with empty string test\", \"[left recursive]\")",
          "708: {",
          "709:     parser parser(",
          "710:         \" A <- '' A\"",
          "711:     );",
          "713:     REQUIRE(!parser);",
          "716: TEST_CASE(\"User defined rule test\", \"[user rule]\")",
          "717: {",
          "718:     auto g = parser(R\"(",
          "721:     {",
          "722:         {",
          "723:             \"NAME\", usr([](const char* s, size_t n, SemanticValues& /*sv*/, any& /*dt*/) -> size_t {",
          "724:                 static std::vector<std::string> names = { \"PEG\", \"BNF\" };",
          "725:                 for (const auto& name: names) {",
          "726:                     if (name.size() <= n && !name.compare(0, name.size(), s, name.size())) {",
          "727:                         return name.size();",
          "728:                     }",
          "729:                 }",
          "730:                 return static_cast<size_t>(-1);",
          "731:             })",
          "732:         },",
          "733:         {",
          "734:             \"~_\", zom(cls(\" \\t\\r\\n\"))",
          "735:         }",
          "736:     });",
          "738:     REQUIRE(g.parse(\" Hello BNF! \") == true);",
          "739: }",
          "741: TEST_CASE(\"Semantic predicate test\", \"[predicate]\")",
          "742: {",
          "743:     parser parser(\"NUMBER  <-  [0-9]+\");",
          "745:     parser[\"NUMBER\"] = [](const SemanticValues& sv) {",
          "746:         auto val = stol(sv.token(), nullptr, 10);",
          "747:         if (val != 100) {",
          "748:             throw parse_error(\"value error!!\");",
          "749:         }",
          "750:         return val;",
          "751:     };",
          "753:     long val;",
          "754:     REQUIRE(parser.parse(\"100\", val));",
          "755:     REQUIRE(val == 100);",
          "757:     parser.log = [](size_t line, size_t col, const std::string& msg) {",
          "758:         REQUIRE(line == 1);",
          "759:         REQUIRE(col == 1);",
          "760:         REQUIRE(msg == \"value error!!\");",
          "761:     };",
          "762:     REQUIRE(!parser.parse(\"200\", val));",
          "763: }",
          "765: TEST_CASE(\"Japanese character\", \"[unicode]\")",
          "766: {",
          "767:     peg::parser parser(u8R\"(",
          "",
          "[Added Lines]",
          "580:   REQUIRE(parser.parse(\"branchthatiswrongbranchthatiscorrect\"));",
          "581:   REQUIRE(!parser.parse(\"branchthatiswrongbranchthatIscorrect\"));",
          "582:   REQUIRE(",
          "583:       !parser.parse(\"branchthatiswrongbranchthatIswrongbranchthatiscorrect\"));",
          "584:   REQUIRE(",
          "585:       !parser.parse(\"branchthatiswrongbranchthatIswrongbranchthatIscorrect\"));",
          "586:   REQUIRE_THROWS_AS(parser.parse(\"branchthatiscorrect\"), std::runtime_error);",
          "587:   REQUIRE_THROWS_AS(parser.parse(\"branchthatiswron_branchthatiscorrect\"),",
          "588:                     std::runtime_error);",
          "591: TEST_CASE(\"Repetition {0}\", \"[repetition]\") {",
          "592:   parser parser(R\"(",
          "596:   REQUIRE(parser.parse(\"(123) 456-7890\"));",
          "597:   REQUIRE(!parser.parse(\"(12a) 456-7890\"));",
          "598:   REQUIRE(!parser.parse(\"(123) 45-7890\"));",
          "599:   REQUIRE(!parser.parse(\"(123) 45-7a90\"));",
          "602: TEST_CASE(\"Repetition {2,4}\", \"[repetition]\") {",
          "603:   parser parser(R\"(",
          "607:   REQUIRE(!parser.parse(\"1\"));",
          "608:   REQUIRE(parser.parse(\"12\"));",
          "609:   REQUIRE(parser.parse(\"123\"));",
          "610:   REQUIRE(parser.parse(\"1234\"));",
          "611:   REQUIRE(!parser.parse(\"12345\"));",
          "614: TEST_CASE(\"Repetition {2,1}\", \"[repetition]\") {",
          "615:   parser parser(R\"(",
          "619:   REQUIRE(!parser.parse(\"1\"));",
          "620:   REQUIRE(parser.parse(\"12\"));",
          "621:   REQUIRE(!parser.parse(\"123\"));",
          "624: TEST_CASE(\"Repetition {2,}\", \"[repetition]\") {",
          "625:   parser parser(R\"(",
          "629:   REQUIRE(!parser.parse(\"1\"));",
          "630:   REQUIRE(parser.parse(\"12\"));",
          "631:   REQUIRE(parser.parse(\"123\"));",
          "632:   REQUIRE(parser.parse(\"1234\"));",
          "635: TEST_CASE(\"Repetition {,2}\", \"[repetition]\") {",
          "636:   parser parser(R\"(",
          "640:   REQUIRE(parser.parse(\"1\"));",
          "641:   REQUIRE(parser.parse(\"12\"));",
          "642:   REQUIRE(!parser.parse(\"123\"));",
          "643:   REQUIRE(!parser.parse(\"1234\"));",
          "646: TEST_CASE(\"Left recursive test\", \"[left recursive]\") {",
          "647:   parser parser(R\"(",
          "652:   REQUIRE(!parser);",
          "655: TEST_CASE(\"Left recursive with option test\", \"[left recursive]\") {",
          "656:   parser parser(R\"(",
          "661:   REQUIRE(!parser);",
          "664: TEST_CASE(\"Left recursive with zom test\", \"[left recursive]\") {",
          "665:   parser parser(R\"(",
          "669:   REQUIRE(!parser);",
          "672: TEST_CASE(\"Left recursive with a ZOM content rule\", \"[left recursive]\") {",
          "673:   parser parser(R\"(",
          "679:   REQUIRE(!parser);",
          "682: TEST_CASE(\"Left recursive with empty string test\", \"[left recursive]\") {",
          "683:   parser parser(\" A <- '' A\");",
          "685:   REQUIRE(!parser);",
          "688: TEST_CASE(\"User defined rule test\", \"[user rule]\") {",
          "689:   auto g = parser(R\"(",
          "692:                   {{\"NAME\", usr([](const char *s, size_t n, SemanticValues &,",
          "693:                                    std::any &) -> size_t {",
          "694:                       static std::vector<std::string> names = {\"PEG\", \"BNF\"};",
          "695:                       for (const auto &name : names) {",
          "696:                         if (name.size() <= n &&",
          "697:                             !name.compare(0, name.size(), s, name.size())) {",
          "698:                           return name.size();",
          "699:                         }",
          "700:                       }",
          "701:                       return static_cast<size_t>(-1);",
          "702:                     })},",
          "703:                    {\"~_\", zom(cls(\" \\t\\r\\n\"))}});",
          "705:   REQUIRE(g.parse(\" Hello BNF! \") == true);",
          "706: }",
          "708: TEST_CASE(\"Semantic predicate test\", \"[predicate]\") {",
          "709:   parser parser(\"NUMBER  <-  [0-9]+\");",
          "711:   parser[\"NUMBER\"] = [](const SemanticValues &vs) {",
          "712:     auto val = vs.token_to_number<long>();",
          "713:     if (val != 100) { throw parse_error(\"value error!!\"); }",
          "714:     return val;",
          "715:   };",
          "717:   long val;",
          "718:   REQUIRE(parser.parse(\"100\", val));",
          "719:   REQUIRE(val == 100);",
          "721:   parser.log = [](size_t line, size_t col, const std::string &msg) {",
          "722:     REQUIRE(line == 1);",
          "723:     REQUIRE(col == 1);",
          "724:     REQUIRE(msg == \"value error!!\");",
          "725:   };",
          "726:   REQUIRE(!parser.parse(\"200\", val));",
          "727: }",
          "729: TEST_CASE(\"Japanese character\", \"[unicode]\") {",
          "730:   peg::parser parser(u8R\"(",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "775:         \u52a9\u8a5e <- '\u304c' / '\u3092' / '\u305f' / '\u307e\u3059' / '\u306b'",
          "776:     )\");",
          "782: }",
          "788: }",
          "794: }",
          "799:         S <- 'a' [\u3044-\u304aA\u3055C-E\u305f-\u3068\u306f] 'b'",
          "800:     )\");",
          "821: }",
          "823: #if 0 // TODO: Unicode Grapheme support",
          "",
          "[Removed Lines]",
          "778:     bool ret = parser;",
          "779:     REQUIRE(ret == true);",
          "781:     REQUIRE(parser.parse(u8R\"(\u30b5\u30fc\u30d0\u30fc\u3092\u5fa9\u65e7\u3057\u307e\u3059\u3002)\"));",
          "784: TEST_CASE(\"dot with a code\", \"[unicode]\")",
          "785: {",
          "786:     peg::parser parser(\" S <- 'a' . 'b' \");",
          "787:     REQUIRE(parser.parse(u8R\"(a\u3042b)\"));",
          "790: TEST_CASE(\"dot with a char\", \"[unicode]\")",
          "791: {",
          "792:     peg::parser parser(\" S <- 'a' . 'b' \");",
          "793:     REQUIRE(parser.parse(u8R\"(a\u00e5b)\"));",
          "796: TEST_CASE(\"character class\", \"[unicode]\")",
          "797: {",
          "798:     peg::parser parser(R\"(",
          "802:     bool ret = parser;",
          "803:     REQUIRE(ret == true);",
          "805:     REQUIRE(!parser.parse(u8R\"(a\u3042b)\"));",
          "806:     REQUIRE(parser.parse(u8R\"(a\u3044b)\"));",
          "807:     REQUIRE(parser.parse(u8R\"(a\u3046b)\"));",
          "808:     REQUIRE(parser.parse(u8R\"(a\u304ab)\"));",
          "809:     REQUIRE(!parser.parse(u8R\"(a\u304bb)\"));",
          "810:     REQUIRE(parser.parse(u8R\"(aAb)\"));",
          "811:     REQUIRE(!parser.parse(u8R\"(aBb)\"));",
          "812:     REQUIRE(parser.parse(u8R\"(aEb)\"));",
          "813:     REQUIRE(!parser.parse(u8R\"(aFb)\"));",
          "814:     REQUIRE(!parser.parse(u8R\"(a\u305db)\"));",
          "815:     REQUIRE(parser.parse(u8R\"(a\u305fb)\"));",
          "816:     REQUIRE(parser.parse(u8R\"(a\u3061b)\"));",
          "817:     REQUIRE(parser.parse(u8R\"(a\u3068b)\"));",
          "818:     REQUIRE(!parser.parse(u8R\"(a\u306ab)\"));",
          "819:     REQUIRE(parser.parse(u8R\"(a\u306fb)\"));",
          "820:     REQUIRE(!parser.parse(u8R\"(a?b)\"));",
          "",
          "[Added Lines]",
          "741:   bool ret = parser;",
          "742:   REQUIRE(ret == true);",
          "744:   REQUIRE(parser.parse(u8R\"(\u30b5\u30fc\u30d0\u30fc\u3092\u5fa9\u65e7\u3057\u307e\u3059\u3002)\"));",
          "747: TEST_CASE(\"dot with a code\", \"[unicode]\") {",
          "748:   peg::parser parser(\" S <- 'a' . 'b' \");",
          "749:   REQUIRE(parser.parse(u8R\"(a\u3042b)\"));",
          "752: TEST_CASE(\"dot with a char\", \"[unicode]\") {",
          "753:   peg::parser parser(\" S <- 'a' . 'b' \");",
          "754:   REQUIRE(parser.parse(u8R\"(a\u00e5b)\"));",
          "757: TEST_CASE(\"character class\", \"[unicode]\") {",
          "758:   peg::parser parser(R\"(",
          "762:   bool ret = parser;",
          "763:   REQUIRE(ret == true);",
          "765:   REQUIRE(!parser.parse(u8R\"(a\u3042b)\"));",
          "766:   REQUIRE(parser.parse(u8R\"(a\u3044b)\"));",
          "767:   REQUIRE(parser.parse(u8R\"(a\u3046b)\"));",
          "768:   REQUIRE(parser.parse(u8R\"(a\u304ab)\"));",
          "769:   REQUIRE(!parser.parse(u8R\"(a\u304bb)\"));",
          "770:   REQUIRE(parser.parse(u8R\"(aAb)\"));",
          "771:   REQUIRE(!parser.parse(u8R\"(aBb)\"));",
          "772:   REQUIRE(parser.parse(u8R\"(aEb)\"));",
          "773:   REQUIRE(!parser.parse(u8R\"(aFb)\"));",
          "774:   REQUIRE(!parser.parse(u8R\"(a\u305db)\"));",
          "775:   REQUIRE(parser.parse(u8R\"(a\u305fb)\"));",
          "776:   REQUIRE(parser.parse(u8R\"(a\u3061b)\"));",
          "777:   REQUIRE(parser.parse(u8R\"(a\u3068b)\"));",
          "778:   REQUIRE(!parser.parse(u8R\"(a\u306ab)\"));",
          "779:   REQUIRE(parser.parse(u8R\"(a\u306fb)\"));",
          "780:   REQUIRE(!parser.parse(u8R\"(a?b)\"));",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "828: }",
          "829: #endif",
          "834:   S     <- HELLO WORLD",
          "835:   HELLO <- T('hello')",
          "836:   WORLD <- T('world')",
          "837:   T(a)  <- a [ \\t]*",
          "838:  )\");",
          "841: }",
          "846:   S           <- HELLO_WORLD",
          "847:   HELLO_WORLD <- T('hello', 'world')",
          "848:   T(a, b)     <- a [ \\t]* b [ \\t]*",
          "849:  )\");",
          "852: }",
          "857:   S     <- T('hello')",
          "858:   T (a) <- a [ \\t]*",
          "859:  )\");",
          "863: }",
          "868:   S       <- T ('hello')",
          "869:   T(a, b) <- a [ \\t]* b",
          "870:  )\");",
          "874: }",
          "879:   S    <- T ('hello')",
          "880:   T(a) <- a [ \\t]*",
          "881:  )\");",
          "885: }",
          "890:   S <- T('hello')",
          "891:   T <- 'world'",
          "892:  )\");",
          "896: }",
          "902:         # Grammar for simple calculator...",
          "903:         EXPRESSION       <-  _ LIST(TERM, TERM_OPERATOR)",
          "904:         TERM             <-  LIST(FACTOR, FACTOR_OPERATOR)",
          "",
          "[Removed Lines]",
          "831: TEST_CASE(\"Macro simple test\", \"[macro]\")",
          "832: {",
          "833:     parser parser(R\"(",
          "840:     REQUIRE(parser.parse(\"hello \\tworld \"));",
          "843: TEST_CASE(\"Macro two parameters\", \"[macro]\")",
          "844: {",
          "845:     parser parser(R\"(",
          "851:     REQUIRE(parser.parse(\"hello \\tworld \"));",
          "854: TEST_CASE(\"Macro syntax error\", \"[macro]\")",
          "855: {",
          "856:     parser parser(R\"(",
          "861:     bool ret = parser;",
          "862:     REQUIRE(ret == false);",
          "865: TEST_CASE(\"Macro missing argument\", \"[macro]\")",
          "866: {",
          "867:     parser parser(R\"(",
          "872:     bool ret = parser;",
          "873:     REQUIRE(ret == false);",
          "876: TEST_CASE(\"Macro reference syntax error\", \"[macro]\")",
          "877: {",
          "878:     parser parser(R\"(",
          "883:     bool ret = parser;",
          "884:     REQUIRE(ret == false);",
          "887: TEST_CASE(\"Macro invalid macro reference error\", \"[macro]\")",
          "888: {",
          "889:     parser parser(R\"(",
          "894:     bool ret = parser;",
          "895:     REQUIRE(ret == false);",
          "898: TEST_CASE(\"Macro calculator\", \"[macro]\")",
          "899: {",
          "901:     parser parser(R\"(",
          "",
          "[Added Lines]",
          "791: TEST_CASE(\"Macro simple test\", \"[macro]\") {",
          "792:   parser parser(R\"(",
          "799:   REQUIRE(parser.parse(\"hello \\tworld \"));",
          "802: TEST_CASE(\"Macro two parameters\", \"[macro]\") {",
          "803:   parser parser(R\"(",
          "809:   REQUIRE(parser.parse(\"hello \\tworld \"));",
          "812: TEST_CASE(\"Macro syntax error\", \"[macro]\") {",
          "813:   parser parser(R\"(",
          "818:   bool ret = parser;",
          "819:   REQUIRE(ret == false);",
          "822: TEST_CASE(\"Macro missing argument\", \"[macro]\") {",
          "823:   parser parser(R\"(",
          "828:   bool ret = parser;",
          "829:   REQUIRE(ret == false);",
          "832: TEST_CASE(\"Macro reference syntax error\", \"[macro]\") {",
          "833:   parser parser(R\"(",
          "838:   bool ret = parser;",
          "839:   REQUIRE(ret == false);",
          "842: TEST_CASE(\"Macro invalid macro reference error\", \"[macro]\") {",
          "843:   parser parser(R\"(",
          "848:   bool ret = parser;",
          "849:   REQUIRE(ret == false);",
          "852: TEST_CASE(\"Macro calculator\", \"[macro]\") {",
          "854:   parser parser(R\"(",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "911:   T(S)             <-  < S > _",
          "912:  )\");",
          "945: }",
          "950:   S             <- M('hello' / 'Hello', 'world' / 'World')",
          "951:   M(arg0, arg1) <- arg0 [ \\t]+ arg1",
          "952:  )\");",
          "955: }",
          "960:   S    <- M('abc')",
          "961:   M(s) <- !s / s ' ' M(s / '123') / s",
          "962:  )\");",
          "968: }",
          "991:   S                   <- Modifiers(!\"\") _",
          "992:   Modifiers(Appeared) <- (!Appeared) (",
          "993:            Token('public') Modifiers(Appeared / 'public') /",
          "",
          "[Removed Lines]",
          "915:     auto reduce = [](const SemanticValues& sv) -> long {",
          "916:         auto result = any_cast<long>(sv[0]);",
          "917:         for (auto i = 1u; i < sv.size(); i += 2) {",
          "918:             auto num = any_cast<long>(sv[i + 1]);",
          "919:             auto ope = any_cast<char>(sv[i]);",
          "920:             switch (ope) {",
          "921:                 case '+': result += num; break;",
          "922:                 case '-': result -= num; break;",
          "923:                 case '*': result *= num; break;",
          "924:                 case '/': result /= num; break;",
          "925:             }",
          "926:         }",
          "927:         return result;",
          "928:     };",
          "930:     parser[\"EXPRESSION\"]      = reduce;",
          "931:     parser[\"TERM\"]            = reduce;",
          "932:     parser[\"TERM_OPERATOR\"]   = [](const SemanticValues& sv) { return static_cast<char>(*sv.c_str()); };",
          "933:     parser[\"FACTOR_OPERATOR\"] = [](const SemanticValues& sv) { return static_cast<char>(*sv.c_str()); };",
          "934:     parser[\"NUMBER\"]          = [](const SemanticValues& sv) { return atol(sv.c_str()); };",
          "936:     bool ret = parser;",
          "937:     REQUIRE(ret == true);",
          "939:  auto expr = \" 1 + 2 * 3 * (4 - 5 + 6) / 7 - 8 \";",
          "940:     long val = 0;",
          "941:     ret = parser.parse(expr, val);",
          "943:     REQUIRE(ret == true);",
          "944:     REQUIRE(val == -3);",
          "947: TEST_CASE(\"Macro expression arguments\", \"[macro]\")",
          "948: {",
          "949:     parser parser(R\"(",
          "954:     REQUIRE(parser.parse(\"Hello world\"));",
          "957: TEST_CASE(\"Macro recursive\", \"[macro]\")",
          "958: {",
          "959:     parser parser(R\"(",
          "964:     REQUIRE(parser.parse(\"\"));",
          "965:     REQUIRE(parser.parse(\"abc\"));",
          "966:     REQUIRE(parser.parse(\"abc abc\"));",
          "967:     REQUIRE(parser.parse(\"abc 123 abc\"));",
          "970: TEST_CASE(\"Macro recursive2\", \"[macro]\")",
          "971: {",
          "972:  auto syntaxes = std::vector<const char*>{",
          "973:   \"S <- M('abc') M(s) <- !s / s ' ' M(s* '-' '123') / s\",",
          "974:   \"S <- M('abc') M(s) <- !s / s ' ' M(s+ '-' '123') / s\",",
          "975:   \"S <- M('abc') M(s) <- !s / s ' ' M(s? '-' '123') / s\",",
          "976:   \"S <- M('abc') M(s) <- !s / s ' ' M(&s s+ '-' '123') / s\",",
          "977:   \"S <- M('abc') M(s) <- !s / s ' ' M(s '-' !s '123') / s\",",
          "978:   \"S <- M('abc') M(s) <- !s / s ' ' M(< s > '-' '123') / s\",",
          "979:   \"S <- M('abc') M(s) <- !s / s ' ' M(~s '-' '123') / s\",",
          "980:  };",
          "982:  for (const auto& syntax: syntaxes) {",
          "983:         parser parser(syntax);",
          "984:         REQUIRE(parser.parse(\"abc abc-123\"));",
          "985:  }",
          "986: }",
          "988: TEST_CASE(\"Macro exclusive modifiers\", \"[macro]\")",
          "989: {",
          "990:     parser parser(R\"(",
          "",
          "[Added Lines]",
          "868:   auto reduce = [](const SemanticValues &vs) {",
          "869:     auto result = std::any_cast<long>(vs[0]);",
          "870:     for (auto i = 1u; i < vs.size(); i += 2) {",
          "871:       auto num = std::any_cast<long>(vs[i + 1]);",
          "872:       auto ope = std::any_cast<char>(vs[i]);",
          "873:       switch (ope) {",
          "874:       case '+': result += num; break;",
          "875:       case '-': result -= num; break;",
          "876:       case '*': result *= num; break;",
          "877:       case '/': result /= num; break;",
          "878:       }",
          "879:     }",
          "880:     return result;",
          "881:   };",
          "883:   parser[\"EXPRESSION\"] = reduce;",
          "884:   parser[\"TERM\"] = reduce;",
          "885:   parser[\"TERM_OPERATOR\"] = [](const SemanticValues &vs) {",
          "886:     return static_cast<char>(*vs.sv().data());",
          "887:   };",
          "888:   parser[\"FACTOR_OPERATOR\"] = [](const SemanticValues &vs) {",
          "889:     return static_cast<char>(*vs.sv().data());",
          "890:   };",
          "891:   parser[\"NUMBER\"] = [](const SemanticValues &vs) { return vs.token_to_number<long>(); };",
          "893:   bool ret = parser;",
          "894:   REQUIRE(ret == true);",
          "896:   auto expr = \" 1 + 2 * 3 * (4 - 5 + 6) / 7 - 8 \";",
          "897:   long val = 0;",
          "898:   ret = parser.parse(expr, val);",
          "900:   REQUIRE(ret == true);",
          "901:   REQUIRE(val == -3);",
          "904: TEST_CASE(\"Macro expression arguments\", \"[macro]\") {",
          "905:   parser parser(R\"(",
          "910:   REQUIRE(parser.parse(\"Hello world\"));",
          "913: TEST_CASE(\"Macro recursive\", \"[macro]\") {",
          "914:   parser parser(R\"(",
          "919:   REQUIRE(parser.parse(\"\"));",
          "920:   REQUIRE(parser.parse(\"abc\"));",
          "921:   REQUIRE(parser.parse(\"abc abc\"));",
          "922:   REQUIRE(parser.parse(\"abc 123 abc\"));",
          "925: TEST_CASE(\"Macro recursive2\", \"[macro]\") {",
          "926:   auto syntaxes = std::vector<const char *>{",
          "927:       \"S <- M('abc') M(s) <- !s / s ' ' M(s* '-' '123') / s\",",
          "928:       \"S <- M('abc') M(s) <- !s / s ' ' M(s+ '-' '123') / s\",",
          "929:       \"S <- M('abc') M(s) <- !s / s ' ' M(s? '-' '123') / s\",",
          "930:       \"S <- M('abc') M(s) <- !s / s ' ' M(&s s+ '-' '123') / s\",",
          "931:       \"S <- M('abc') M(s) <- !s / s ' ' M(s '-' !s '123') / s\",",
          "932:       \"S <- M('abc') M(s) <- !s / s ' ' M(< s > '-' '123') / s\",",
          "933:       \"S <- M('abc') M(s) <- !s / s ' ' M(~s '-' '123') / s\",",
          "934:   };",
          "936:   for (const auto &syntax : syntaxes) {",
          "937:     parser parser(syntax);",
          "938:     REQUIRE(parser.parse(\"abc abc-123\"));",
          "939:   }",
          "940: }",
          "942: TEST_CASE(\"Macro exclusive modifiers\", \"[macro]\") {",
          "943:   parser parser(R\"(",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "998:   _                   <- [ \\t\\r\\n]*",
          "999:  )\");",
          "1007: }",
          "1012:         # Grammar for simple calculator...",
          "1013:         EXPRESSION       <-  _ LIST(TERM, TERM_OPERATOR)",
          "1014:         TERM             <-  LIST(FACTOR, FACTOR_OPERATOR)",
          "",
          "[Removed Lines]",
          "1001:  REQUIRE(parser.parse(\"public\"));",
          "1002:  REQUIRE(parser.parse(\"static\"));",
          "1003:  REQUIRE(parser.parse(\"final\"));",
          "1004:  REQUIRE(parser.parse(\"public static final\"));",
          "1005:  REQUIRE(!parser.parse(\"public public\"));",
          "1006:  REQUIRE(!parser.parse(\"public static public\"));",
          "1009: TEST_CASE(\"Macro token check test\", \"[macro]\")",
          "1010: {",
          "1011:     parser parser(R\"(",
          "",
          "[Added Lines]",
          "954:   REQUIRE(parser.parse(\"public\"));",
          "955:   REQUIRE(parser.parse(\"static\"));",
          "956:   REQUIRE(parser.parse(\"final\"));",
          "957:   REQUIRE(parser.parse(\"public static final\"));",
          "958:   REQUIRE(!parser.parse(\"public public\"));",
          "959:   REQUIRE(!parser.parse(\"public static public\"));",
          "962: TEST_CASE(\"Macro token check test\", \"[macro]\") {",
          "963:   parser parser(R\"(",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "1021:   T(S)             <-  < S > _",
          "1022:  )\");",
          "1032: }",
          "1034: TEST_CASE(\"Macro passes an arg to another macro\", \"[macro]\") {",
          "",
          "[Removed Lines]",
          "1024:     REQUIRE(parser[\"EXPRESSION\"].is_token() == false);",
          "1025:     REQUIRE(parser[\"TERM\"].is_token() == false);",
          "1026:     REQUIRE(parser[\"FACTOR\"].is_token() == false);",
          "1027:     REQUIRE(parser[\"FACTOR_OPERATOR\"].is_token() == true);",
          "1028:     REQUIRE(parser[\"NUMBER\"].is_token() == true);",
          "1029:     REQUIRE(parser[\"_\"].is_token() == true);",
          "1030:     REQUIRE(parser[\"LIST\"].is_token() == false);",
          "1031:     REQUIRE(parser[\"T\"].is_token() == true);",
          "",
          "[Added Lines]",
          "976:   REQUIRE(parser[\"EXPRESSION\"].is_token() == false);",
          "977:   REQUIRE(parser[\"TERM\"].is_token() == false);",
          "978:   REQUIRE(parser[\"FACTOR\"].is_token() == false);",
          "979:   REQUIRE(parser[\"FACTOR_OPERATOR\"].is_token() == true);",
          "980:   REQUIRE(parser[\"NUMBER\"].is_token() == true);",
          "981:   REQUIRE(parser[\"_\"].is_token() == true);",
          "982:   REQUIRE(parser[\"LIST\"].is_token() == false);",
          "983:   REQUIRE(parser[\"T\"].is_token() == true);",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "1053:   REQUIRE(parser.parse(\"val\"));",
          "1054: }",
          "1059:         START           <- A('TestVal1', 'TestVal2')+",
          "1060:         A(Aarg1, Aarg2) <- B(Aarg1) '#End'",
          "1061:         B(Barg1)        <- '#' Barg1",
          "1062:  )\");",
          "1065: }",
          "1067: TEST_CASE(\"Line information test\", \"[line information]\") {",
          "1069:         S    <- _ (WORD _)+",
          "1070:         WORD <- [A-Za-z]+",
          "1071:         ~_   <- [ \\t\\r\\n]+",
          "1072:     )\");",
          "1092: }",
          "1097:         START <- 'This month is ' MONTH '.'",
          "1098:         MONTH <- 'Jan' | 'January' | 'Feb' | 'February'",
          "1099:  )\");",
          "1105: }",
          "1110:         START <- 'This month is ' MONTH '.'",
          "1111:         MONTH <- 'Jan' | 'January' | [a-z]+ | 'Feb' | 'February'",
          "1112:  )\");",
          "1116: }",
          "",
          "[Removed Lines]",
          "1056: TEST_CASE(\"Nested macro call2\", \"[macro]\")",
          "1057: {",
          "1058:     parser parser(R\"(",
          "1064:     REQUIRE(parser.parse(\"#TestVal1#End\"));",
          "1068:     parser parser(R\"(",
          "1074:     std::vector<std::pair<size_t, size_t>> locations;",
          "1075:     parser[\"WORD\"] = [&](const peg::SemanticValues& sv) {",
          "1076:         locations.push_back(sv.line_info());",
          "1077:     };",
          "1079:     bool ret = parser;",
          "1080:     REQUIRE(ret == true);",
          "1082:     ret = parser.parse(\" Mon Tue Wed \\nThu  Fri  Sat\\nSun\\n\");",
          "1083:     REQUIRE(ret == true);",
          "1085:     REQUIRE(locations[0] == std::make_pair<size_t, size_t>(1, 2));",
          "1086:     REQUIRE(locations[1] == std::make_pair<size_t, size_t>(1, 6));",
          "1087:     REQUIRE(locations[2] == std::make_pair<size_t, size_t>(1, 10));",
          "1088:     REQUIRE(locations[3] == std::make_pair<size_t, size_t>(2, 1));",
          "1089:     REQUIRE(locations[4] == std::make_pair<size_t, size_t>(2, 6));",
          "1090:     REQUIRE(locations[5] == std::make_pair<size_t, size_t>(2, 11));",
          "1091:     REQUIRE(locations[6] == std::make_pair<size_t, size_t>(3, 1));",
          "1094: TEST_CASE(\"Dictionary\", \"[dic]\")",
          "1095: {",
          "1096:     parser parser(R\"(",
          "1101:     REQUIRE(parser.parse(\"This month is Jan.\"));",
          "1102:     REQUIRE(parser.parse(\"This month is January.\"));",
          "1103:     REQUIRE_FALSE(parser.parse(\"This month is Jannuary.\"));",
          "1104:     REQUIRE_FALSE(parser.parse(\"This month is .\"));",
          "1107: TEST_CASE(\"Dictionary invalid\", \"[dic]\")",
          "1108: {",
          "1109:     parser parser(R\"(",
          "1114:     bool ret = parser;",
          "1115:     REQUIRE_FALSE(ret);",
          "",
          "[Added Lines]",
          "1008: TEST_CASE(\"Nested macro call2\", \"[macro]\") {",
          "1009:   parser parser(R\"(",
          "1015:   REQUIRE(parser.parse(\"#TestVal1#End\"));",
          "1019:   parser parser(R\"(",
          "1025:   std::vector<std::pair<size_t, size_t>> locations;",
          "1026:   parser[\"WORD\"] = [&](const peg::SemanticValues &vs) {",
          "1027:     locations.push_back(vs.line_info());",
          "1028:   };",
          "1030:   bool ret = parser;",
          "1031:   REQUIRE(ret == true);",
          "1033:   ret = parser.parse(\" Mon Tue Wed \\nThu  Fri  Sat\\nSun\\n\");",
          "1034:   REQUIRE(ret == true);",
          "1036:   REQUIRE(locations[0] == std::make_pair<size_t, size_t>(1, 2));",
          "1037:   REQUIRE(locations[1] == std::make_pair<size_t, size_t>(1, 6));",
          "1038:   REQUIRE(locations[2] == std::make_pair<size_t, size_t>(1, 10));",
          "1039:   REQUIRE(locations[3] == std::make_pair<size_t, size_t>(2, 1));",
          "1040:   REQUIRE(locations[4] == std::make_pair<size_t, size_t>(2, 6));",
          "1041:   REQUIRE(locations[5] == std::make_pair<size_t, size_t>(2, 11));",
          "1042:   REQUIRE(locations[6] == std::make_pair<size_t, size_t>(3, 1));",
          "1045: TEST_CASE(\"Dictionary\", \"[dic]\") {",
          "1046:   parser parser(R\"(",
          "1051:   REQUIRE(parser.parse(\"This month is Jan.\"));",
          "1052:   REQUIRE(parser.parse(\"This month is January.\"));",
          "1053:   REQUIRE_FALSE(parser.parse(\"This month is Jannuary.\"));",
          "1054:   REQUIRE_FALSE(parser.parse(\"This month is .\"));",
          "1057: TEST_CASE(\"Dictionary invalid\", \"[dic]\") {",
          "1058:   parser parser(R\"(",
          "1063:   bool ret = parser;",
          "1064:   REQUIRE_FALSE(ret);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "fe2d67fc88e2ca69bfdd6630532efc8909e76e09",
      "candidate_info": {
        "commit_hash": "fe2d67fc88e2ca69bfdd6630532efc8909e76e09",
        "repo": "yhirose/cpp-peglib",
        "commit_url": "https://github.com/yhirose/cpp-peglib/commit/fe2d67fc88e2ca69bfdd6630532efc8909e76e09",
        "files": [
          "lint/peglint.cc",
          "peglib.h"
        ],
        "message": "Improved peglint trace format",
        "before_after_code_files": [
          "lint/peglint.cc||lint/peglint.cc",
          "peglib.h||peglib.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "peglib.h||peglib.h"
          ],
          "candidate": [
            "peglib.h||peglib.h"
          ]
        }
      },
      "candidate_diff": {
        "lint/peglint.cc||lint/peglint.cc": [
          "File: lint/peglint.cc -> lint/peglint.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "8: #include <peglib.h>",
          "9: #include <fstream>",
          "11: using namespace std;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "10: #include <sstream>",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "99:     };",
          "101:     if (opt_trace) {",
          "104:         size_t prev_pos = 0;",
          "118:             }",
          "124:     }",
          "126:     if (opt_ast) {",
          "",
          "[Removed Lines]",
          "102:         std::cout << \"pos:lev\\trule/ope\" << std::endl;",
          "103:         std::cout << \"-------\\t--------\" << std::endl;",
          "105:         parser.enable_trace([&](",
          "106:             const char* name,",
          "107:             const char* s,",
          "108:             size_t /*n*/,",
          "109:             const peg::SemanticValues& /*sv*/,",
          "110:             const peg::Context& c,",
          "111:             const peg::any& /*dt*/) {",
          "112:             auto pos = static_cast<size_t>(s - c.s);",
          "113:             auto backtrack = (pos < prev_pos ? \"*\" : \"\");",
          "114:             string indent;",
          "115:             auto level = c.nest_level;",
          "116:             while (level--) {",
          "117:                 indent += \"  \";",
          "119:             std::cout",
          "120:                 << pos << \":\" << c.nest_level << backtrack << \"\\t\"",
          "121:                 << indent << name << std::endl;",
          "122:             prev_pos = static_cast<size_t>(pos);",
          "123:         });",
          "",
          "[Added Lines]",
          "104:         parser.enable_trace(",
          "105:             [&](const char* name,",
          "106:                 const char* s,",
          "107:                 size_t /*n*/,",
          "108:                 const peg::SemanticValues& /*sv*/,",
          "109:                 const peg::Context& c,",
          "110:                 const peg::any& /*dt*/) {",
          "111:                 auto pos = static_cast<size_t>(s - c.s);",
          "112:                 auto backtrack = (pos < prev_pos ? \"*\" : \"\");",
          "113:                 string indent;",
          "114:                 auto level = c.trace_ids.size() - 1;",
          "115:                 while (level--) { indent += \"\u2502\"; }",
          "116:                 std::cout",
          "117:                     << \"E \" << pos << backtrack << \"\\t\"",
          "118:                     << indent << \"\u250c\" << name",
          "119:                     << \" #\" << c.trace_ids.back()",
          "120:                     << std::endl;",
          "121:                 prev_pos = static_cast<size_t>(pos);",
          "122:             },",
          "123:             [&](const char* name,",
          "124:                 const char* s,",
          "125:                 size_t /*n*/,",
          "126:                 const peg::SemanticValues& sv,",
          "127:                 const peg::Context& c,",
          "128:                 const peg::any& /*dt*/,",
          "129:                 size_t len) {",
          "130:                 auto pos = static_cast<size_t>(s - c.s);",
          "131:                 if (len != -1) {",
          "132:                     pos += len;",
          "133:                 }",
          "134:                 string indent;",
          "135:                 auto level = c.trace_ids.size() - 1;",
          "136:                 while (level--) { indent += \"\u2502\"; }",
          "137:                 auto ret = len != -1 ? \"\u2514o \" : \"\u2514x \";",
          "138:                 std::stringstream choice;",
          "139:                 if (sv.choice_count() > 0) {",
          "140:                     choice << \" \" << sv.choice() << \"/\" << sv.choice_count();",
          "141:                 }",
          "142:                 std::string token;",
          "143:                 if (!sv.tokens.empty()) {",
          "144:                     const auto& tok = sv.tokens[0];",
          "145:                     token += \" '\" + std::string(tok.first, tok.second) + \"'\";",
          "146:                 }",
          "147:                 std::cout",
          "148:                     << \"L \" << pos << \"\\t\"",
          "149:                     << indent << ret << name",
          "150:                     << \" #\" << c.trace_ids.back()",
          "151:                     << choice.str()",
          "152:                     << token",
          "153:                     << std::endl;",
          "155:         );",
          "",
          "---------------"
        ],
        "peglib.h||peglib.h": [
          "File: peglib.h -> peglib.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "777: class Ope;",
          "778: class Definition;",
          "782: class Context",
          "783: {",
          "",
          "[Removed Lines]",
          "780: typedef std::function<void (const char* name, const char* s, size_t n, const SemanticValues& sv, const Context& c, const any& dt)> Tracer;",
          "",
          "[Added Lines]",
          "780: typedef std::function<void (const char* name, const char* s, size_t n, const SemanticValues& sv, const Context& c, const any& dt)> TracerEnter;",
          "782: typedef std::function<void (const char* name, const char* s, size_t n, const SemanticValues& sv, const Context& c, const any& dt, size_t)> TracerLeave;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "795:     size_t                                       value_stack_size = 0;",
          "796:     std::vector<std::vector<std::shared_ptr<Ope>>> args_stack;",
          "800:     bool                                         in_token = false;",
          "802:     std::shared_ptr<Ope>                         whitespaceOpe;",
          "",
          "[Removed Lines]",
          "798:     size_t                                       nest_level = 0;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "815:     std::map<std::pair<size_t, size_t>, std::tuple<size_t, any>> cache_values;",
          "819:     Context(",
          "820:         const char*          a_path,",
          "",
          "[Removed Lines]",
          "817:     std::function<void (const char*, const char*, size_t, const SemanticValues&, const Context&, const any&)> tracer;",
          "",
          "[Added Lines]",
          "817:     TracerEnter tracer_enter;",
          "818:     TracerLeave tracer_leave;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "824:         std::shared_ptr<Ope> a_whitespaceOpe,",
          "825:         std::shared_ptr<Ope> a_wordOpe,",
          "826:         bool                 a_enablePackratParsing,",
          "828:         : path(a_path)",
          "829:         , s(a_s)",
          "830:         , l(a_l)",
          "",
          "[Removed Lines]",
          "827:         Tracer               a_tracer)",
          "",
          "[Added Lines]",
          "828:         TracerEnter          a_tracer_enter,",
          "829:         TracerLeave          a_tracer_leave)",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "834:         , enablePackratParsing(a_enablePackratParsing)",
          "835:         , cache_registered(enablePackratParsing ? def_count * (l + 1) : 0)",
          "836:         , cache_success(enablePackratParsing ? def_count * (l + 1) : 0)",
          "839:         for (size_t pos = 0; pos < l; pos++) {",
          "840:             if (s[pos] == '\\n') {",
          "",
          "[Removed Lines]",
          "837:         , tracer(a_tracer) {",
          "",
          "[Added Lines]",
          "839:         , tracer_enter(a_tracer_enter)",
          "840:         , tracer_leave(a_tracer_leave) {",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "955:         if (error_pos < a_s) error_pos = a_s;",
          "956:     }",
          "961: };",
          "",
          "[Removed Lines]",
          "958:     void trace(const char* name, const char* a_s, size_t n, SemanticValues& sv, any& dt) const {",
          "959:         if (tracer) tracer(name, a_s, n, sv, *this, dt);",
          "960:     }",
          "",
          "[Added Lines]",
          "961:     void trace_enter(const char* name, const char* a_s, size_t n, SemanticValues& sv, any& dt) const;",
          "962:     void trace_leave(const char* name, const char* a_s, size_t n, SemanticValues& sv, any& dt, size_t len) const;",
          "963:     bool is_traceable(const Ope& ope) const;",
          "965:     mutable size_t next_trace_id = 0;",
          "966:     mutable std::list<size_t> trace_ids;",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "969:     struct Visitor;",
          "971:     virtual ~Ope() {}",
          "973:     virtual void accept(Visitor& v) = 0;",
          "974: };",
          "",
          "[Removed Lines]",
          "972:     virtual size_t parse(const char* s, size_t n, SemanticValues& sv, Context& c, any& dt) const = 0;",
          "",
          "[Added Lines]",
          "978:     size_t parse(const char* s, size_t n, SemanticValues& sv, Context& c, any& dt) const;",
          "979:     virtual size_t parse_core(const char* s, size_t n, SemanticValues& sv, Context& c, any& dt) const = 0;",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "981:     Sequence(const std::vector<std::shared_ptr<Ope>>& opes) : opes_(opes) {}",
          "982:     Sequence(std::vector<std::shared_ptr<Ope>>&& opes) : opes_(opes) {}",
          "986:         auto& chldsv = c.push();",
          "987:         auto pop_se = make_scope_exit([&]() { c.pop(); });",
          "988:         size_t i = 0;",
          "989:         for (const auto& ope : opes_) {",
          "992:             const auto& rule = *ope;",
          "993:             auto len = rule.parse(s + i, n - i, chldsv, c, dt);",
          "994:             if (fail(len)) {",
          "",
          "[Removed Lines]",
          "984:     size_t parse(const char* s, size_t n, SemanticValues& sv, Context& c, any& dt) const override {",
          "985:         c.trace(\"Sequence\", s, n, sv, dt);",
          "990:             c.nest_level++;",
          "991:             auto se = make_scope_exit([&]() { c.nest_level--; });",
          "",
          "[Added Lines]",
          "991:     size_t parse_core(const char* s, size_t n, SemanticValues& sv, Context& c, any& dt) const override {",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "1029:     PrioritizedChoice(const std::vector<std::shared_ptr<Ope>>& opes) : opes_(opes) {}",
          "1030:     PrioritizedChoice(std::vector<std::shared_ptr<Ope>>&& opes) : opes_(opes) {}",
          "1034:         size_t id = 0;",
          "1035:         for (const auto& ope : opes_) {",
          "1037:             auto& chldsv = c.push();",
          "1038:             c.push_capture_scope();",
          "1039:             auto se = make_scope_exit([&]() {",
          "1041:                 c.pop();",
          "1042:                 c.pop_capture_scope();",
          "1043:             });",
          "",
          "[Removed Lines]",
          "1032:     size_t parse(const char* s, size_t n, SemanticValues& sv, Context& c, any& dt) const override {",
          "1033:         c.trace(\"PrioritizedChoice\", s, n, sv, dt);",
          "1036:             c.nest_level++;",
          "1040:                 c.nest_level--;",
          "",
          "[Added Lines]",
          "1036:     size_t parse_core(const char* s, size_t n, SemanticValues& sv, Context& c, any& dt) const override {",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "1084: public:",
          "1085:     ZeroOrMore(const std::shared_ptr<Ope>& ope) : ope_(ope) {}",
          "1089:         auto save_error_pos = c.error_pos;",
          "1090:         size_t i = 0;",
          "1091:         while (n - i > 0) {",
          "1093:             c.push_capture_scope();",
          "1094:             auto se = make_scope_exit([&]() {",
          "1096:                 c.pop_capture_scope();",
          "1097:             });",
          "1098:             auto save_sv_size = sv.size();",
          "",
          "[Removed Lines]",
          "1087:     size_t parse(const char* s, size_t n, SemanticValues& sv, Context& c, any& dt) const override {",
          "1088:         c.trace(\"ZeroOrMore\", s, n, sv, dt);",
          "1092:             c.nest_level++;",
          "1095:                 c.nest_level--;",
          "",
          "[Added Lines]",
          "1088:     size_t parse_core(const char* s, size_t n, SemanticValues& sv, Context& c, any& dt) const override {",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "1127: public:",
          "1128:     OneOrMore(const std::shared_ptr<Ope>& ope) : ope_(ope) {}",
          "1132:         size_t len = 0;",
          "1133:         {",
          "1135:             c.push_capture_scope();",
          "1136:             auto se = make_scope_exit([&]() {",
          "1138:                 c.pop_capture_scope();",
          "1139:             });",
          "1140:             const auto& rule = *ope_;",
          "",
          "[Removed Lines]",
          "1130:     size_t parse(const char* s, size_t n, SemanticValues& sv, Context& c, any& dt) const override {",
          "1131:         c.trace(\"OneOrMore\", s, n, sv, dt);",
          "1134:             c.nest_level++;",
          "1137:                 c.nest_level--;",
          "",
          "[Added Lines]",
          "1128:     size_t parse_core(const char* s, size_t n, SemanticValues& sv, Context& c, any& dt) const override {",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "1148:         auto save_error_pos = c.error_pos;",
          "1149:         auto i = len;",
          "1150:         while (n - i > 0) {",
          "1152:             c.push_capture_scope();",
          "1153:             auto se = make_scope_exit([&]() {",
          "1155:                 c.pop_capture_scope();",
          "1156:             });",
          "1157:             auto save_sv_size = sv.size();",
          "",
          "[Removed Lines]",
          "1151:             c.nest_level++;",
          "1154:                 c.nest_level--;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "1186: public:",
          "1187:     Option(const std::shared_ptr<Ope>& ope) : ope_(ope) {}",
          "1191:         auto save_error_pos = c.error_pos;",
          "1193:         auto save_sv_size = sv.size();",
          "1194:         auto save_tok_size = sv.tokens.size();",
          "1195:         c.push_capture_scope();",
          "1196:         auto se = make_scope_exit([&]() {",
          "1198:             c.pop_capture_scope();",
          "1199:         });",
          "1200:         const auto& rule = *ope_;",
          "",
          "[Removed Lines]",
          "1189:     size_t parse(const char* s, size_t n, SemanticValues& sv, Context& c, any& dt) const override {",
          "1190:         c.trace(\"Option\", s, n, sv, dt);",
          "1192:         c.nest_level++;",
          "1197:             c.nest_level--;",
          "",
          "[Added Lines]",
          "1182:     size_t parse_core(const char* s, size_t n, SemanticValues& sv, Context& c, any& dt) const override {",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "1225: public:",
          "1226:     AndPredicate(const std::shared_ptr<Ope>& ope) : ope_(ope) {}",
          "1231:         auto& chldsv = c.push();",
          "1232:         c.push_capture_scope();",
          "1233:         auto se = make_scope_exit([&]() {",
          "1235:             c.pop();",
          "1236:             c.pop_capture_scope();",
          "1237:         });",
          "",
          "[Removed Lines]",
          "1228:     size_t parse(const char* s, size_t n, SemanticValues& sv, Context& c, any& dt) const override {",
          "1229:         c.trace(\"AndPredicate\", s, n, sv, dt);",
          "1230:         c.nest_level++;",
          "1234:             c.nest_level--;",
          "",
          "[Added Lines]",
          "1218:     size_t parse_core(const char* s, size_t n, SemanticValues& sv, Context& c, any& dt) const override {",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "1254: public:",
          "1255:     NotPredicate(const std::shared_ptr<Ope>& ope) : ope_(ope) {}",
          "1259:         auto save_error_pos = c.error_pos;",
          "1261:         auto& chldsv = c.push();",
          "1262:         c.push_capture_scope();",
          "1263:         auto se = make_scope_exit([&]() {",
          "1265:             c.pop();",
          "1266:             c.pop_capture_scope();",
          "1267:         });",
          "",
          "[Removed Lines]",
          "1257:     size_t parse(const char* s, size_t n, SemanticValues& sv, Context& c, any& dt) const override {",
          "1258:         c.trace(\"NotPredicate\", s, n, sv, dt);",
          "1260:         c.nest_level++;",
          "1264:             c.nest_level--;",
          "",
          "[Added Lines]",
          "1244:     size_t parse_core(const char* s, size_t n, SemanticValues& sv, Context& c, any& dt) const override {",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "1292:         , is_word_(false)",
          "1293:         {}",
          "1297:     void accept(Visitor& v) override;",
          "",
          "[Removed Lines]",
          "1295:     size_t parse(const char* s, size_t n, SemanticValues& sv, Context& c, any& dt) const override;",
          "",
          "[Added Lines]",
          "1279:     size_t parse_core(const char* s, size_t n, SemanticValues& sv, Context& c, any& dt) const override;",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "1328:         assert(!ranges_.empty());",
          "1329:     }",
          "1334:         if (n < 1) {",
          "1335:             c.set_error_pos(s);",
          "1336:             return static_cast<size_t>(-1);",
          "",
          "[Removed Lines]",
          "1331:     size_t parse(const char* s, size_t n, SemanticValues& sv, Context& c, any& dt) const override {",
          "1332:         c.trace(\"CharacterClass\", s, n, sv, dt);",
          "",
          "[Added Lines]",
          "1315:     size_t parse_core(const char* s, size_t n, SemanticValues& sv, Context& c, any& dt) const override {",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "1370: public:",
          "1371:     Character(char ch) : ch_(ch) {}",
          "1375:         if (n < 1 || s[0] != ch_) {",
          "1376:             c.set_error_pos(s);",
          "1377:             return static_cast<size_t>(-1);",
          "",
          "[Removed Lines]",
          "1373:     size_t parse(const char* s, size_t n, SemanticValues& sv, Context& c, any& dt) const override {",
          "1374:         c.trace(\"Character\", s, n, sv, dt);",
          "",
          "[Added Lines]",
          "1355:     size_t parse_core(const char* s, size_t n, SemanticValues& sv, Context& c, any& dt) const override {",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "1388:     , public std::enable_shared_from_this<AnyCharacter>",
          "1389: {",
          "1390: public:",
          "1393:         auto len = codepoint_length(s, n);",
          "1394:         if (len < 1) {",
          "1395:             c.set_error_pos(s);",
          "",
          "[Removed Lines]",
          "1391:     size_t parse(const char* s, size_t n, SemanticValues& sv, Context& c, any& dt) const override {",
          "1392:         c.trace(\"AnyCharacter\", s, n, sv, dt);",
          "",
          "[Added Lines]",
          "1372:     size_t parse_core(const char* s, size_t n, SemanticValues& sv, Context& c, any& dt) const override {",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "1407:     CaptureScope(const std::shared_ptr<Ope>& ope)",
          "1408:         : ope_(ope) {}",
          "1411:         c.push_capture_scope();",
          "1412:         auto se = make_scope_exit([&]() {",
          "1413:             c.pop_capture_scope();",
          "",
          "[Removed Lines]",
          "1410:     size_t parse(const char* s, size_t n, SemanticValues& sv, Context& c, any& dt) const override {",
          "",
          "[Added Lines]",
          "1390:     size_t parse_core(const char* s, size_t n, SemanticValues& sv, Context& c, any& dt) const override {",
          "",
          "---------------",
          "--- Hunk 21 ---",
          "[Context before]",
          "1430:     Capture(const std::shared_ptr<Ope>& ope, MatchAction ma)",
          "1431:         : ope_(ope), match_action_(ma) {}",
          "1434:         const auto& rule = *ope_;",
          "1435:         auto len = rule.parse(s, n, sv, c, dt);",
          "1436:         if (success(len) && match_action_) {",
          "",
          "[Removed Lines]",
          "1433:     size_t parse(const char* s, size_t n, SemanticValues& sv, Context& c, any& dt) const override {",
          "",
          "[Added Lines]",
          "1413:     size_t parse_core(const char* s, size_t n, SemanticValues& sv, Context& c, any& dt) const override {",
          "",
          "---------------",
          "--- Hunk 22 ---",
          "[Context before]",
          "1450: public:",
          "1451:     TokenBoundary(const std::shared_ptr<Ope>& ope) : ope_(ope) {}",
          "1455:     void accept(Visitor& v) override;",
          "",
          "[Removed Lines]",
          "1453:     size_t parse(const char* s, size_t n, SemanticValues& sv, Context& c, any& dt) const override;",
          "",
          "[Added Lines]",
          "1433:     size_t parse_core(const char* s, size_t n, SemanticValues& sv, Context& c, any& dt) const override;",
          "",
          "---------------",
          "--- Hunk 23 ---",
          "[Context before]",
          "1462: public:",
          "1463:     Ignore(const std::shared_ptr<Ope>& ope) : ope_(ope) {}",
          "1466:         const auto& rule = *ope_;",
          "1467:         auto& chldsv = c.push();",
          "1468:         auto se = make_scope_exit([&]() {",
          "",
          "[Removed Lines]",
          "1465:     size_t parse(const char* s, size_t n, SemanticValues& /*sv*/, Context& c, any& dt) const override {",
          "",
          "[Added Lines]",
          "1445:     size_t parse_core(const char* s, size_t n, SemanticValues& sv, Context& c, any& dt) const override {",
          "",
          "---------------",
          "--- Hunk 24 ---",
          "[Context before]",
          "1482: {",
          "1483: public:",
          "1484:     User(Parser fn) : fn_(fn) {}",
          "1487:         assert(fn_);",
          "1488:         return fn_(s, n, sv, dt);",
          "1489:     }",
          "",
          "[Removed Lines]",
          "1485:      size_t parse(const char* s, size_t n, SemanticValues& sv, Context& c, any& dt) const override {",
          "1486:         c.trace(\"User\", s, n, sv, dt);",
          "",
          "[Added Lines]",
          "1465:      size_t parse_core(const char* s, size_t n, SemanticValues& sv, Context& c, any& dt) const override {",
          "",
          "---------------",
          "--- Hunk 25 ---",
          "[Context before]",
          "1496: public:",
          "1497:     WeakHolder(const std::shared_ptr<Ope>& ope) : weak_(ope) {}",
          "1500:         auto ope = weak_.lock();",
          "1501:         assert(ope);",
          "1502:         const auto& rule = *ope;",
          "",
          "[Removed Lines]",
          "1499:     size_t parse(const char* s, size_t n, SemanticValues& sv, Context& c, any& dt) const override {",
          "",
          "[Added Lines]",
          "1478:     size_t parse_core(const char* s, size_t n, SemanticValues& sv, Context& c, any& dt) const override {",
          "",
          "---------------",
          "--- Hunk 26 ---",
          "[Context before]",
          "1514:     Holder(Definition* outer)",
          "1515:        : outer_(outer) {}",
          "1519:     void accept(Visitor& v) override;",
          "1521:     any reduce(SemanticValues& sv, any& dt) const;",
          "1523:     std::shared_ptr<Ope> ope_;",
          "1524:     Definition*          outer_;",
          "1526:     friend class Definition;",
          "1527: };",
          "",
          "[Removed Lines]",
          "1517:     size_t parse(const char* s, size_t n, SemanticValues& sv, Context& c, any& dt) const override;",
          "",
          "[Added Lines]",
          "1496:     size_t parse_core(const char* s, size_t n, SemanticValues& sv, Context& c, any& dt) const override;",
          "1502:     const char* trace_name() const;",
          "1506:     mutable std::string  trace_name_;",
          "",
          "---------------",
          "--- Hunk 27 ---",
          "[Context before]",
          "1547:         , iarg_(0)",
          "1548:         {}",
          "1552:     void accept(Visitor& v) override;",
          "",
          "[Removed Lines]",
          "1550:     size_t parse(const char* s, size_t n, SemanticValues& sv, Context& c, any& dt) const override;",
          "",
          "[Added Lines]",
          "1532:     size_t parse_core(const char* s, size_t n, SemanticValues& sv, Context& c, any& dt) const override;",
          "",
          "---------------",
          "--- Hunk 28 ---",
          "[Context before]",
          "1569: public:",
          "1570:     Whitespace(const std::shared_ptr<Ope>& ope) : ope_(ope) {}",
          "1573:         if (c.in_whitespace) {",
          "1574:             return 0;",
          "1575:         }",
          "",
          "[Removed Lines]",
          "1572:     size_t parse(const char* s, size_t n, SemanticValues& sv, Context& c, any& dt) const override {",
          "",
          "[Added Lines]",
          "1554:     size_t parse_core(const char* s, size_t n, SemanticValues& sv, Context& c, any& dt) const override {",
          "",
          "---------------",
          "--- Hunk 29 ---",
          "[Context before]",
          "1589: public:",
          "1590:     BackReference(const std::string& name) : name_(name) {}",
          "1594:     void accept(Visitor& v) override;",
          "",
          "[Removed Lines]",
          "1592:     size_t parse(const char* s, size_t n, SemanticValues& sv, Context& c, any& dt) const override;",
          "",
          "[Added Lines]",
          "1574:     size_t parse_core(const char* s, size_t n, SemanticValues& sv, Context& c, any& dt) const override;",
          "",
          "---------------",
          "--- Hunk 30 ---",
          "[Context before]",
          "1722:     virtual void visit(BackReference& /*ope*/) {}",
          "1723: };",
          "1725: struct AssignIDToDefinition : public Ope::Visitor",
          "1726: {",
          "1727:     void visit(Sequence& ope) override {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1707: struct IsReference : public Ope::Visitor",
          "1708: {",
          "1709:     void visit(Reference& ope) override {",
          "1710:         is_reference = true;",
          "1711:     }",
          "1712:     bool is_reference = false;",
          "1713: };",
          "1715: struct TraceOpeName : public Ope::Visitor",
          "1716: {",
          "1717:     void visit(Sequence& ope) override { name = \"Sequence\"; }",
          "1718:     void visit(PrioritizedChoice& ope) override { name = \"PrioritizedChoice\"; }",
          "1719:     void visit(ZeroOrMore& ope) override { name = \"ZeroOrMore\"; }",
          "1720:     void visit(OneOrMore& ope) override { name = \"OneOrMore\"; }",
          "1721:     void visit(Option& ope) override { name = \"Option\"; }",
          "1722:     void visit(AndPredicate& ope) override { name = \"AndPredicate\"; }",
          "1723:     void visit(NotPredicate& ope) override { name = \"NotPredicate\"; }",
          "1724:     void visit(LiteralString& ope) override { name = \"LiteralString\"; }",
          "1725:     void visit(CharacterClass& ope) override { name = \"CharacterClass\"; }",
          "1726:     void visit(Character& ope) override { name = \"Character\"; }",
          "1727:     void visit(AnyCharacter& ope) override { name = \"AnyCharacter\"; }",
          "1728:     void visit(CaptureScope& ope) override { name = \"CaptureScope\"; }",
          "1729:     void visit(Capture& ope) override { name = \"Capture\"; }",
          "1730:     void visit(TokenBoundary& ope) override { name = \"TokenBoundary\"; }",
          "1731:     void visit(Ignore& ope) override { name = \"Ignore\"; }",
          "1732:     void visit(User& ope) override { name = \"User\"; }",
          "1733:     void visit(WeakHolder& ope) override { name = \"WeakHolder\"; }",
          "1734:     void visit(Holder& ope) override {",
          "1735:         name = ope.trace_name();",
          "1736:     }",
          "1737:     void visit(Reference& ope) override {",
          "1738:         name = \"Reference\";",
          "1739:     }",
          "1740:     void visit(Whitespace& ope) override { name = \"Whitespace\"; }",
          "1741:     void visit(BackReference& ope) override { name = \"BackReference\"; }",
          "1743:     const char* name = nullptr;",
          "1744: };",
          "",
          "---------------",
          "--- Hunk 31 ---",
          "[Context before]",
          "2253:     bool                                                                                 enablePackratParsing = false;",
          "2254:     bool                                                                                 is_macro = false;",
          "2255:     std::vector<std::string>                                                             params;",
          "2258: private:",
          "2259:     friend class Reference;",
          "",
          "[Removed Lines]",
          "2256:     Tracer                                                                               tracer;",
          "",
          "[Added Lines]",
          "2277:     TracerEnter                                                                          tracer_enter;",
          "2278:     TracerLeave                                                                          tracer_leave;",
          "",
          "---------------",
          "--- Hunk 32 ---",
          "[Context before]",
          "2283:             ope = std::make_shared<Sequence>(whitespaceOpe, ope);",
          "2284:         }",
          "2287:         auto len = ope->parse(s, n, sv, cxt, dt);",
          "2288:         return Result{ success(len), len, cxt.error_pos, cxt.message_pos, cxt.message };",
          "2289:     }",
          "",
          "[Removed Lines]",
          "2286:         Context cxt(path, s, n, definition_ids_.size(), whitespaceOpe, wordOpe, enablePackratParsing, tracer);",
          "",
          "[Added Lines]",
          "2308:         Context cxt(",
          "2309:             path, s, n,",
          "2310:             definition_ids_.size(),",
          "2311:             whitespaceOpe, wordOpe,",
          "2312:             enablePackratParsing,",
          "2313:             tracer_enter, tracer_leave);",
          "",
          "---------------",
          "--- Hunk 33 ---",
          "[Context before]",
          "2312:     }",
          "2316:     static SemanticValues dummy_sv;",
          "2317:     static any dummy_dt;",
          "",
          "[Removed Lines]",
          "2315:     static Context dummy_c(nullptr, c.s, c.l, 0, nullptr, nullptr, false, nullptr);",
          "",
          "[Added Lines]",
          "2343:     static Context dummy_c(nullptr, c.s, c.l, 0, nullptr, nullptr, false, nullptr, nullptr);",
          "",
          "---------------",
          "--- Hunk 34 ---",
          "[Context before]",
          "2347:     return i;",
          "2348: }",
          "2352:     return parse_literal(s, n, sv, c, dt, lit_, init_is_word_, is_word_, ignore_case_);",
          "2353: }",
          "2356:     c.in_token = true;",
          "2357:     auto se = make_scope_exit([&]() { c.in_token = false; });",
          "2358:     const auto& rule = *ope_;",
          "",
          "[Removed Lines]",
          "2350: inline size_t LiteralString::parse(const char* s, size_t n, SemanticValues& sv, Context& c, any& dt) const {",
          "2351:     c.trace(\"LiteralString\", s, n, sv, dt);",
          "2355: inline size_t TokenBoundary::parse(const char* s, size_t n, SemanticValues& sv, Context& c, any& dt) const {",
          "",
          "[Added Lines]",
          "2378: inline void Context::trace_enter(const char* name, const char* a_s, size_t n, SemanticValues& sv, any& dt) const {",
          "2379:     trace_ids.push_back(next_trace_id++);",
          "2380:     tracer_enter(name, a_s, n, sv, *this, dt);",
          "2381: }",
          "2383: inline void Context::trace_leave(const char* name, const char* a_s, size_t n, SemanticValues& sv, any& dt, size_t len) const {",
          "2384:     tracer_leave(name, a_s, n, sv, *this, dt, len);",
          "2385:     trace_ids.pop_back();",
          "2386: }",
          "2388: inline bool Context::is_traceable(const Ope& ope) const {",
          "2389:     if (tracer_enter && tracer_leave) {",
          "2390:         IsReference vis;",
          "2391:         const_cast<Ope&>(ope).accept(vis);",
          "2392:         return !vis.is_reference;",
          "2393:     }",
          "2394:     return false;",
          "2395: }",
          "2397: inline size_t Ope::parse(const char* s, size_t n, SemanticValues& sv, Context& c, any& dt) const {",
          "2398:     if (c.is_traceable(*this)) {",
          "2399:         TraceOpeName vis;",
          "2400:         const_cast<Ope&>(*this).accept(vis);",
          "2401:         c.trace_enter(vis.name, s, n, sv, dt);",
          "2402:         auto len = parse_core(s, n, sv, c, dt);",
          "2403:         c.trace_leave(vis.name, s, n, sv, dt, len);",
          "2404:         return len;",
          "2405:     }",
          "2406:     return parse_core(s, n, sv, c, dt);",
          "2407: }",
          "2409: inline size_t LiteralString::parse_core(const char* s, size_t n, SemanticValues& sv, Context& c, any& dt) const {",
          "2413: inline size_t TokenBoundary::parse_core(const char* s, size_t n, SemanticValues& sv, Context& c, any& dt) const {",
          "",
          "---------------",
          "--- Hunk 35 ---",
          "[Context before]",
          "2371:     return len;",
          "2372: }",
          "2375:     if (!ope_) {",
          "2376:         throw std::logic_error(\"Uninitialized definition ope was used...\");",
          "2377:     }",
          "2387:     if (outer_->is_macro) {",
          "",
          "[Removed Lines]",
          "2374: inline size_t Holder::parse(const char* s, size_t n, SemanticValues& sv, Context& c, any& dt) const {",
          "2379:     c.trace(outer_->name.c_str(), s, n, sv, dt);",
          "2380:     c.nest_level++;",
          "2381:     auto se = make_scope_exit([&]() {",
          "2382:         c.nest_level--;",
          "2383:     });",
          "",
          "[Added Lines]",
          "2432: inline size_t Holder::parse_core(const char* s, size_t n, SemanticValues& sv, Context& c, any& dt) const {",
          "",
          "---------------",
          "--- Hunk 36 ---",
          "[Context before]",
          "2460:     }",
          "2461: }",
          "2464:     const char* s, size_t n, SemanticValues& sv, Context& c, any& dt) const {",
          "2465:     if (rule_) {",
          "",
          "[Removed Lines]",
          "2463: inline size_t Reference::parse(",
          "",
          "[Added Lines]",
          "2515: inline const char* Holder::trace_name() const {",
          "2516:     if (trace_name_.empty()) {",
          "2517:         trace_name_ = \"[\" + outer_->name + \"]\";",
          "2518:     }",
          "2519:     return trace_name_.c_str();",
          "2520: }",
          "2522: inline size_t Reference::parse_core(",
          "",
          "---------------",
          "--- Hunk 37 ---",
          "[Context before]",
          "2495:     return rule_->holder_;",
          "2496: }",
          "2500:     for (int i = c.capture_scope_stack_size - 1; i >= 0; i--) {",
          "2501:         const auto& cs = c.capture_scope_stack[i];",
          "2502:         if (cs.find(name_) != cs.end()) {",
          "",
          "[Removed Lines]",
          "2498: inline size_t BackReference::parse(const char* s, size_t n, SemanticValues& sv, Context& c, any& dt) const {",
          "2499:     c.trace(\"BackReference\", s, n, sv, dt);",
          "",
          "[Added Lines]",
          "2557: inline size_t BackReference::parse_core(const char* s, size_t n, SemanticValues& sv, Context& c, any& dt) const {",
          "",
          "---------------",
          "--- Hunk 38 ---",
          "[Context before]",
          "3523:         return *this;",
          "3524:     }",
          "3527:         if (grammar_ != nullptr) {",
          "3528:             auto& rule = (*grammar_)[start_];",
          "3530:         }",
          "3531:     }",
          "",
          "[Removed Lines]",
          "3526:     void enable_trace(Tracer tracer) {",
          "3529:             rule.tracer = tracer;",
          "",
          "[Added Lines]",
          "3584:     void enable_trace(TracerEnter tracer_enter, TracerLeave tracer_leave) {",
          "3587:             rule.tracer_enter = tracer_enter;",
          "3588:             rule.tracer_leave = tracer_leave;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "c49366ad07444e8c58dae58716c990eba60823c9",
      "candidate_info": {
        "commit_hash": "c49366ad07444e8c58dae58716c990eba60823c9",
        "repo": "yhirose/cpp-peglib",
        "commit_url": "https://github.com/yhirose/cpp-peglib/commit/c49366ad07444e8c58dae58716c990eba60823c9",
        "files": [
          "peglib.h"
        ],
        "message": "Use `std::call_once` to initialize `is_word` in LiteralString",
        "before_after_code_files": [
          "peglib.h||peglib.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "peglib.h||peglib.h"
          ],
          "candidate": [
            "peglib.h||peglib.h"
          ]
        }
      },
      "candidate_diff": {
        "peglib.h||peglib.h": [
          "File: peglib.h -> peglib.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "1239:                       public std::enable_shared_from_this<LiteralString> {",
          "1240: public:",
          "1241:   LiteralString(std::string &&s, bool ignore_case)",
          "1243:         is_word_(false) {}",
          "1245:   LiteralString(const std::string &s, bool ignore_case)",
          "1247:         is_word_(false) {}",
          "1249:   size_t parse_core(const char *s, size_t n, SemanticValues &sv, Context &c,",
          "",
          "[Removed Lines]",
          "1242:       : lit_(s), ignore_case_(ignore_case), init_is_word_(false),",
          "1246:       : lit_(s), ignore_case_(ignore_case), init_is_word_(false),",
          "",
          "[Added Lines]",
          "1242:       : lit_(s), ignore_case_(ignore_case),",
          "1246:       : lit_(s), ignore_case_(ignore_case),",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1254:   std::string lit_;",
          "1255:   bool ignore_case_;",
          "1257:   mutable bool is_word_;",
          "1258: };",
          "",
          "[Removed Lines]",
          "1256:   mutable bool init_is_word_;",
          "",
          "[Added Lines]",
          "1256:   mutable std::once_flag init_is_word_;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "2343: inline size_t parse_literal(const char *s, size_t n, SemanticValues &sv,",
          "2344:                             Context &c, any &dt, const std::string &lit,",
          "2346:                             bool ignore_case) {",
          "2347:   size_t i = 0;",
          "2348:   for (; i < lit.size(); i++) {",
          "",
          "[Removed Lines]",
          "2345:                             bool &init_is_word, bool &is_word,",
          "",
          "[Added Lines]",
          "2345:                             std::once_flag &init_is_word, bool &is_word,",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "2359:   static SemanticValues dummy_sv;",
          "2360:   static any dummy_dt;",
          "2363:     if (c.wordOpe) {",
          "2364:       auto len =",
          "2365:           c.wordOpe->parse(lit.data(), lit.size(), dummy_sv, dummy_c, dummy_dt);",
          "2366:       is_word = success(len);",
          "2367:     }",
          "2371:   if (is_word) {",
          "2372:     NotPredicate ope(c.wordOpe);",
          "",
          "[Removed Lines]",
          "2362:   if (!init_is_word) { // TODO: Protect with mutex",
          "2368:     init_is_word = true;",
          "2369:   }",
          "",
          "[Added Lines]",
          "2362:   std::call_once(init_is_word, [&]() {",
          "2368:   });",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "2592:     const auto &cs = c.capture_scope_stack[index];",
          "2593:     if (cs.find(name_) != cs.end()) {",
          "2594:       const auto &lit = cs.at(name_);",
          "2596:       auto is_word = false;",
          "2597:       return parse_literal(s, n, sv, c, dt, lit, init_is_word, is_word, false);",
          "2598:     }",
          "",
          "[Removed Lines]",
          "2595:       auto init_is_word = false;",
          "",
          "[Added Lines]",
          "2593:       std::once_flag init_is_word;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "4d0b2b3591e4d4007bc7cbea5f0754fb3092a1b9",
      "candidate_info": {
        "commit_hash": "4d0b2b3591e4d4007bc7cbea5f0754fb3092a1b9",
        "repo": "yhirose/cpp-peglib",
        "commit_url": "https://github.com/yhirose/cpp-peglib/commit/4d0b2b3591e4d4007bc7cbea5f0754fb3092a1b9",
        "files": [
          "README.md",
          "peglib.h",
          "test/test.cc"
        ],
        "message": "Fix #66",
        "before_after_code_files": [
          "peglib.h||peglib.h",
          "test/test.cc||test/test.cc"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "peglib.h||peglib.h"
          ],
          "candidate": [
            "peglib.h||peglib.h"
          ]
        }
      },
      "candidate_diff": {
        "peglib.h||peglib.h": [
          "File: peglib.h -> peglib.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "1233:     , public std::enable_shared_from_this<LiteralString>",
          "1234: {",
          "1235: public:",
          "1237:         : lit_(s)",
          "1238:         , init_is_word_(false)",
          "1239:         , is_word_(false)",
          "1240:         {}",
          "",
          "[Removed Lines]",
          "1236:     LiteralString(const std::string& s)",
          "",
          "[Added Lines]",
          "1236:     LiteralString(const std::string& s, bool ignore_case)",
          "1238:         , ignore_case_(ignore_case)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1244:     void accept(Visitor& v) override;",
          "1246:     std::string lit_;",
          "1247:     mutable bool init_is_word_;",
          "1248:     mutable bool is_word_;",
          "1249: };",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1248:     bool ignore_case_;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1564:     return std::make_shared<NotPredicate>(ope);",
          "1565: }",
          "1569: }",
          "1571: inline std::shared_ptr<Ope> cls(const std::string& s) {",
          "",
          "[Removed Lines]",
          "1567: inline std::shared_ptr<Ope> lit(const std::string& lit) {",
          "1568:     return std::make_shared<LiteralString>(lit);",
          "",
          "[Added Lines]",
          "1569: inline std::shared_ptr<Ope> lit(const std::string& s) {",
          "1570:     return std::make_shared<LiteralString>(s, false);",
          "1571: }",
          "1573: inline std::shared_ptr<Ope> liti(const std::string& s) {",
          "1574:     return std::make_shared<LiteralString>(s, true);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "2138: inline size_t parse_literal(const char* s, size_t n, SemanticValues& sv, Context& c, any& dt,",
          "2140: {",
          "2141:     size_t i = 0;",
          "2142:     for (; i < lit.size(); i++) {",
          "2144:             c.set_error_pos(s);",
          "2145:             return static_cast<size_t>(-1);",
          "2146:         }",
          "",
          "[Removed Lines]",
          "2139:         const std::string& lit, bool& init_is_word, bool& is_word)",
          "2143:         if (i >= n || s[i] != lit[i]) {",
          "",
          "[Added Lines]",
          "2145:         const std::string& lit, bool& init_is_word, bool& is_word, bool ignore_case)",
          "2149:         if (i >= n || (ignore_case ? (std::tolower(s[i]) != std::tolower(lit[i])) : (s[i] != lit[i]))) {",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "2185: inline size_t LiteralString::parse(const char* s, size_t n, SemanticValues& sv, Context& c, any& dt) const {",
          "2186:     c.trace(\"LiteralString\", s, n, sv, dt);",
          "2188: }",
          "2190: inline size_t TokenBoundary::parse(const char* s, size_t n, SemanticValues& sv, Context& c, any& dt) const {",
          "",
          "[Removed Lines]",
          "2187:     return parse_literal(s, n, sv, c, dt, lit_, init_is_word_, is_word_);",
          "",
          "[Added Lines]",
          "2193:     return parse_literal(s, n, sv, c, dt, lit_, init_is_word_, is_word_, ignore_case_);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "2338:             const auto& lit = captures.at(name_);",
          "2339:             auto init_is_word = false;",
          "2340:             auto is_word = false;",
          "2342:         }",
          "2343:         ++it;",
          "2344:     }",
          "",
          "[Removed Lines]",
          "2341:             return parse_literal(s, n, sv, c, dt, lit, init_is_word, is_word);",
          "",
          "[Added Lines]",
          "2347:             return parse_literal(s, n, sv, c, dt, lit, init_is_word, is_word, false);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "2535:                                seq(g[\"BeginTok\"], g[\"Expression\"], g[\"EndTok\"]),",
          "2536:                                seq(g[\"BeginCapScope\"], g[\"Expression\"], g[\"EndCapScope\"]),",
          "2537:                                seq(g[\"BeginCap\"], g[\"Expression\"], g[\"EndCap\"]),",
          "2540:         g[\"Identifier\"] <= seq(g[\"IdentCont\"], g[\"Spacing\"]);",
          "2541:         g[\"IdentCont\"]  <= seq(g[\"IdentStart\"], zom(g[\"IdentRest\"]));",
          "",
          "[Removed Lines]",
          "2538:                                g[\"BackRef\"], g[\"Literal\"], g[\"Class\"], g[\"DOT\"]);",
          "",
          "[Added Lines]",
          "2544:                                g[\"BackRef\"], g[\"LiteralI\"], g[\"Literal\"], g[\"Class\"], g[\"DOT\"]);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "2546:         g[\"IdentRest\"]  <= cho(g[\"IdentStart\"], cls(\"0-9\"));",
          "2548:         g[\"Literal\"]    <= cho(seq(cls(\"'\"), tok(zom(seq(npd(cls(\"'\")), g[\"Char\"]))), cls(\"'\"), g[\"Spacing\"]),",
          "2549:                                seq(cls(\"\\\"\"), tok(zom(seq(npd(cls(\"\\\"\")), g[\"Char\"]))), cls(\"\\\"\"), g[\"Spacing\"]));",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2554:         g[\"LiteralI\"]   <= cho(seq(cls(\"'\"), tok(zom(seq(npd(cls(\"'\")), g[\"Char\"]))), lit(\"'i\"), g[\"Spacing\"]),",
          "2555:                                seq(cls(\"\\\"\"), tok(zom(seq(npd(cls(\"\\\"\")), g[\"Char\"]))), lit(\"\\\"i\"), g[\"Spacing\"]));",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "2744:         g[\"IdentCont\"] = [](const SemanticValues& sv) {",
          "2745:             return std::string(sv.c_str(), sv.length());",
          "2746:         };",
          "2748:         g[\"IdentStart\"] = [](const SemanticValues& /*sv*/) {",
          "2749:             return std::string();",
          "2750:         };",
          "2752:         g[\"IdentRest\"] = [](const SemanticValues& /*sv*/) {",
          "2753:             return std::string();",
          "2754:         };",
          "2756:         g[\"Literal\"] = [](const SemanticValues& sv) {",
          "2757:             const auto& tok = sv.tokens.front();",
          "2758:             return lit(resolve_escape_sequence(tok.first, tok.second));",
          "2759:         };",
          "2760:         g[\"Class\"] = [](const SemanticValues& sv) {",
          "2761:             auto ranges = sv.transform<std::pair<char32_t, char32_t>>();",
          "2762:             return cls(ranges);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2763:         g[\"LiteralI\"] = [](const SemanticValues& sv) {",
          "2764:             const auto& tok = sv.tokens.front();",
          "2765:             return liti(resolve_escape_sequence(tok.first, tok.second));",
          "2766:         };",
          "",
          "---------------"
        ],
        "test/test.cc||test/test.cc": [
          "File: test/test.cc -> test/test.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "416:     REQUIRE(ret == true);",
          "417: }",
          "419: TEST_CASE(\"mutable lambda test\", \"[general]\")",
          "420: {",
          "421:     vector<string> vec;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "419: TEST_CASE(\"Ignore case test\", \"[general]\") {",
          "420:     peg::parser parser(R\"(",
          "421:         ROOT         <-  HELLO WORLD",
          "422:         HELLO        <-  'hello'i",
          "423:         WORLD        <-  'world'i",
          "424:         %whitespace  <-  [ \\t\\r\\n]*",
          "425:     )\");",
          "427:     parser[\"HELLO\"] = [](const SemanticValues& sv) {",
          "428:         REQUIRE(sv.token() == \"Hello\");",
          "429:     };",
          "431:     parser[\"WORLD\"] = [](const SemanticValues& sv) {",
          "432:         REQUIRE(sv.token() == \"World\");",
          "433:     };",
          "435:     auto ret = parser.parse(\"  Hello World  \");",
          "436:     REQUIRE(ret == true);",
          "437: }",
          "",
          "---------------"
        ]
      }
    }
  ]
}
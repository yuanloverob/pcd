{
  "cve_id": "CVE-2015-0278",
  "cve_desc": "libuv before 0.10.34 does not properly drop group privileges, which allows context-dependent attackers to gain privileges via unspecified vectors.",
  "repo": "libuv/libuv",
  "patch_hash": "66ab38918c911bcff025562cf06237d7fedaba0c",
  "patch_info": {
    "commit_hash": "66ab38918c911bcff025562cf06237d7fedaba0c",
    "repo": "libuv/libuv",
    "commit_url": "https://github.com/libuv/libuv/commit/66ab38918c911bcff025562cf06237d7fedaba0c",
    "files": [
      "src/unix/process.c"
    ],
    "message": "unix: call setgoups before calling setuid/setgid\n\nPartial fix for #1093",
    "before_after_code_files": [
      "src/unix/process.c||src/unix/process.c"
    ]
  },
  "patch_diff": {
    "src/unix/process.c||src/unix/process.c": [
      "File: src/unix/process.c -> src/unix/process.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "330:     _exit(127);",
      "331:   }",
      "333:   if ((options->flags & UV_PROCESS_SETGID) && setgid(options->gid)) {",
      "334:     uv__write_int(error_fd, -errno);",
      "335:     perror(\"setgid()\");",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "333:   if (options->flags & (UV_PROCESS_SETUID | UV_PROCESS_SETGID)) {",
      "341:     SAVE_ERRNO(setgroups(0, NULL));",
      "342:   }",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "d7a6482f45c1b4eb4a853dbe1a9ce8090a35633a",
      "candidate_info": {
        "commit_hash": "d7a6482f45c1b4eb4a853dbe1a9ce8090a35633a",
        "repo": "libuv/libuv",
        "commit_url": "https://github.com/libuv/libuv/commit/d7a6482f45c1b4eb4a853dbe1a9ce8090a35633a",
        "files": [
          ".mailmap",
          "AUTHORS",
          "ChangeLog",
          "src/version.c"
        ],
        "message": "2013.10.30, Version 0.11.14 (Unstable)\n\nChanges since version 0.11.13:\n\n* darwin: create fsevents thread on demand (Ben Noordhuis)\n\n* fsevents: FSEvents is most likely not thread-safe (Fedor Indutny)\n\n* fsevents: use shared FSEventStream (Fedor Indutny)\n\n* windows: make uv_fs_chmod() report errors correctly (Bert Belder)\n\n* windows: make uv_shutdown() for write-only pipes work (Bert Belder)\n\n* windows/fs: wrap multi-statement macros in do..while block (Bert\n  Belder)\n\n* windows/fs: make uv_fs_open() report EINVAL correctly (Bert Belder)\n\n* windows/fs: handle _open_osfhandle() failure correctly (Bert Belder)\n\n* windows/fs: wrap multi-statement macros in do..while block (Bert\n  Belder)\n\n* windows/fs: make uv_fs_open() report EINVAL correctly (Bert Belder)\n\n* windows/fs: handle _open_osfhandle() failure correctly (Bert Belder)\n\n* build: clarify instructions for Windows (Brian Kaisner)\n\n* build: remove GCC_WARN_ABOUT_MISSING_NEWLINE (Ben Noordhuis)\n\n* darwin: fix 10.6 build error in fsevents.c (Ben Noordhuis)\n\n* windows: run close callbacks after polling for i/o (Sa\u00fal Ibarra\n  Corretg\u00e9)\n\n* include: clarify uv_tcp_bind() behavior (Ben Noordhuis)\n\n* include: clean up includes in uv.h (Ben Noordhuis)\n\n* include: remove UV_IO_PRIVATE_FIELDS macro (Ben Noordhuis)\n\n* include: fix typo in comment in uv.h (Ben Noordhuis)\n\n* include: update uv_is_active() documentation (Ben Noordhuis)\n\n* include: make uv_process_options_t.cwd const (Ben Noordhuis)\n\n* unix: wrap long lines at 80 columns (Ben Noordhuis)\n\n* unix, windows: make uv_is_*() always return 0 or 1 (Ben Noordhuis)\n\n* bench: measure total/init/dispatch/cleanup times (Ben Noordhuis)\n\n* build: use -pthread on sunos (Timothy J. Fontaine)\n\n* windows: remove duplicate check in stream.c (Ben Noordhuis)\n\n* unix: sanity-check fds before closing (Ben Noordhuis)\n\n* unix: remove uv__pipe_accept() (Ben Noordhuis)\n\n* unix: fix uv_spawn() NULL pointer deref on ENOMEM (Ben Noordhuis)\n\n* unix: don't close inherited fds on uv_spawn() fail (Ben Noordhuis)\n\n* unix: revert recent FSEvent changes (Ben Noordhuis)\n\n* fsevents: fix clever rescheduling (Fedor Indutny)\n\n* linux: ignore fractional time in uv_uptime() (Ben Noordhuis)\n\n* unix: fix SIGCHLD waitpid() race in process.c (Ben Noordhuis)\n\n* unix, windows: add uv_fs_event_start/stop functions (Sa\u00fal Ibarra\n  Corretg\u00e9)\n\n* unix: fix non-synchronized access in signal.c (Ben Noordhuis)\n\n* unix: add atomic-ops.h (Ben Noordhuis)\n\n* unix: add spinlock.h (Ben Noordhuis)\n\n* unix: clean up uv_tty_set_mode() a little (Ben Noordhuis)\n\n* unix: make uv_tty_reset_mode() async signal-safe (Ben Noordhuis)\n\n* include: add E2BIG status code mapping (Ben Noordhuis)\n\n* windows: fix duplicate case build error (Ben Noordhuis)\n\n* windows: remove unneeded check (Sa\u00fal Ibarra Corretg\u00e9)\n\n* include: document pipe path truncation behavior (Ben Noordhuis)\n\n* fsevents: increase stack size for OSX 10.9 (Fedor Indutny)\n\n* windows: _snprintf expected wrong parameter type in string (Maks\n  Naumov)\n\n* windows: \"else\" keyword is missing (Maks Naumov)\n\n* windows: incorrect check for SOCKET_ERROR (Maks Naumov)\n\n* windows: add stdlib.h to satisfy reference to abort (Sean Farrell)\n\n* build: fix check target for mingw (Sean Farrell)\n\n* unix: move uv_shutdown() assertion (Keno Fischer)\n\n* darwin: avoid calling GetCurrentProcess (Fedor Indutny)",
        "before_after_code_files": [
          "src/version.c||src/version.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/libuv/libuv/pull/41"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "src/version.c||src/version.c": [
          "File: src/version.c -> src/version.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "32: #define UV_VERSION_MAJOR 0",
          "33: #define UV_VERSION_MINOR 11",
          "34: #define UV_VERSION_PATCH 14",
          "38: #define UV_VERSION  ((UV_VERSION_MAJOR << 16) | \\",
          "",
          "[Removed Lines]",
          "35: #define UV_VERSION_IS_RELEASE 0",
          "",
          "[Added Lines]",
          "35: #define UV_VERSION_IS_RELEASE 1",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "ba47e68824dbd00c51d2c659ab05a83989283aab",
      "candidate_info": {
        "commit_hash": "ba47e68824dbd00c51d2c659ab05a83989283aab",
        "repo": "libuv/libuv",
        "commit_url": "https://github.com/libuv/libuv/commit/ba47e68824dbd00c51d2c659ab05a83989283aab",
        "files": [
          "src/win/pipe.c"
        ],
        "message": "windows: fix opening of read-only stdin pipes\n\nFix https://github.com/joyent/node/issues/7345\n\nGoogle Chrome is launching native messaging hosts by invoking cmd.exe\nwith input/output redirected from/to named pipes. The host ends up\nwith a read-only handle to the stdin pipe. This is causing\nSetNamedPipeHandleState to fail.",
        "before_after_code_files": [
          "src/win/pipe.c||src/win/pipe.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/libuv/libuv/pull/41"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "src/win/pipe.c||src/win/pipe.c": [
          "File: src/win/pipe.c -> src/win/pipe.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "223: }",
          "228:   NTSTATUS nt_status;",
          "229:   IO_STATUS_BLOCK io_status;",
          "230:   FILE_MODE_INFORMATION mode_info;",
          "231:   DWORD mode = PIPE_TYPE_BYTE | PIPE_READMODE_BYTE | PIPE_WAIT;",
          "233:   if (!SetNamedPipeHandleState(pipeHandle, &mode, NULL, NULL)) {",
          "238:     }",
          "240:   }",
          "",
          "[Removed Lines]",
          "226: static int uv_set_pipe_handle(uv_loop_t* loop, uv_pipe_t* handle,",
          "227:     HANDLE pipeHandle, DWORD duplex_flags) {",
          "236:     if (GetLastError() == ERROR_INVALID_PARAMETER) {",
          "237:       SetLastError(WSAENOTSOCK);",
          "239:     return -1;",
          "",
          "[Added Lines]",
          "226: static int uv_set_pipe_handle(uv_loop_t* loop,",
          "227:                               uv_pipe_t* handle,",
          "228:                               HANDLE pipeHandle,",
          "229:                               DWORD duplex_flags) {",
          "234:   DWORD current_mode = 0;",
          "235:   DWORD err = 0;",
          "238:     err = GetLastError();",
          "239:     if (err == ERROR_ACCESS_DENIED) {",
          "246:       if (!GetNamedPipeHandleState(pipeHandle, &current_mode, NULL, NULL,",
          "247:                                    NULL, NULL, 0)) {",
          "248:         return -1;",
          "249:       } else if (current_mode != mode) {",
          "250:         SetLastError(ERROR_ACCESS_DENIED);",
          "251:         return -1;",
          "252:       } else {",
          "253:         duplex_flags &= ~UV_HANDLE_WRITABLE;",
          "254:       }",
          "255:     } else {",
          "258:       if (err == ERROR_INVALID_PARAMETER) {",
          "259:         SetLastError(WSAENOTSOCK);",
          "260:       }",
          "261:       return -1;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1750: int uv_pipe_open(uv_pipe_t* pipe, uv_file file) {",
          "1751:   HANDLE os_handle = uv__get_osfhandle(file);",
          "1753:   if (os_handle == INVALID_HANDLE_VALUE ||",
          "1755:     return UV_EINVAL;",
          "1756:   }",
          "1758:   uv_pipe_connection_init(pipe);",
          "1762:   if (pipe->ipc) {",
          "1763:     assert(!(pipe->flags & UV_HANDLE_NON_OVERLAPPED_PIPE));",
          "",
          "[Removed Lines]",
          "1754:       uv_set_pipe_handle(pipe->loop, pipe, os_handle, 0) == -1) {",
          "1759:   pipe->handle = os_handle;",
          "1760:   pipe->flags |= UV_HANDLE_READABLE | UV_HANDLE_WRITABLE;",
          "",
          "[Added Lines]",
          "1775:   DWORD duplex_flags = UV_HANDLE_READABLE | UV_HANDLE_WRITABLE;",
          "1778:       uv_set_pipe_handle(pipe->loop, pipe, os_handle, duplex_flags) == -1) {",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "3a4ec61d46921406b094d6e4031ecca4dffab335",
      "candidate_info": {
        "commit_hash": "3a4ec61d46921406b094d6e4031ecca4dffab335",
        "repo": "libuv/libuv",
        "commit_url": "https://github.com/libuv/libuv/commit/3a4ec61d46921406b094d6e4031ecca4dffab335",
        "files": [
          "test/test-spawn.c"
        ],
        "message": "test: fix after merge",
        "before_after_code_files": [
          "test/test-spawn.c||test/test-spawn.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/libuv/libuv/pull/41"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "test/test-spawn.c||test/test-spawn.c": [
          "File: test/test-spawn.c -> test/test-spawn.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "292:   options.stdio[2].data.fd = file;",
          "293:   options.stdio_count = 3;",
          "296:   ASSERT(r == 0);",
          "298:   r = uv_run(uv_default_loop(), UV_RUN_DEFAULT);",
          "",
          "[Removed Lines]",
          "295:   r = uv_spawn(uv_default_loop(), &process, options);",
          "",
          "[Added Lines]",
          "295:   r = uv_spawn(uv_default_loop(), &process, &options);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "638:   options.stdio[1].data.stream = (uv_stream_t*)&out;",
          "639:   options.stdio_count = 2;",
          "642:   ASSERT(r == 0);",
          "",
          "[Removed Lines]",
          "641:   r = uv_spawn(uv_default_loop(), &process, options);",
          "",
          "[Added Lines]",
          "641:   r = uv_spawn(uv_default_loop(), &process, &options);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "bde41b255b9c68cc8d065213e28219b90a945acf",
      "candidate_info": {
        "commit_hash": "bde41b255b9c68cc8d065213e28219b90a945acf",
        "repo": "libuv/libuv",
        "commit_url": "https://github.com/libuv/libuv/commit/bde41b255b9c68cc8d065213e28219b90a945acf",
        "files": [
          "samples/.gitignore",
          "samples/socks5-proxy/.gitignore",
          "samples/socks5-proxy/LICENSE",
          "samples/socks5-proxy/Makefile",
          "samples/socks5-proxy/build.gyp",
          "samples/socks5-proxy/client.c",
          "samples/socks5-proxy/defs.h",
          "samples/socks5-proxy/getopt.c",
          "samples/socks5-proxy/main.c",
          "samples/socks5-proxy/s5.c",
          "samples/socks5-proxy/s5.h",
          "samples/socks5-proxy/server.c",
          "samples/socks5-proxy/util.c"
        ],
        "message": "samples: add socks5 proxy sample application",
        "before_after_code_files": [
          "samples/socks5-proxy/build.gyp||samples/socks5-proxy/build.gyp",
          "samples/socks5-proxy/client.c||samples/socks5-proxy/client.c",
          "samples/socks5-proxy/defs.h||samples/socks5-proxy/defs.h",
          "samples/socks5-proxy/getopt.c||samples/socks5-proxy/getopt.c",
          "samples/socks5-proxy/main.c||samples/socks5-proxy/main.c",
          "samples/socks5-proxy/s5.c||samples/socks5-proxy/s5.c",
          "samples/socks5-proxy/s5.h||samples/socks5-proxy/s5.h",
          "samples/socks5-proxy/server.c||samples/socks5-proxy/server.c",
          "samples/socks5-proxy/util.c||samples/socks5-proxy/util.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/libuv/libuv/pull/41"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "samples/socks5-proxy/build.gyp||samples/socks5-proxy/build.gyp": [
          "File: samples/socks5-proxy/build.gyp -> samples/socks5-proxy/build.gyp",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: # Copyright StrongLoop, Inc. All rights reserved.",
          "2: #",
          "3: # Permission is hereby granted, free of charge, to any person obtaining a copy",
          "4: # of this software and associated documentation files (the \"Software\"), to",
          "5: # deal in the Software without restriction, including without limitation the",
          "6: # rights to use, copy, modify, merge, publish, distribute, sublicense, and/or",
          "7: # sell copies of the Software, and to permit persons to whom the Software is",
          "8: # furnished to do so, subject to the following conditions:",
          "9: #",
          "10: # The above copyright notice and this permission notice shall be included in",
          "11: # all copies or substantial portions of the Software.",
          "12: #",
          "13: # THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR",
          "14: # IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,",
          "15: # FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE",
          "16: # AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER",
          "17: # LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING",
          "18: # FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS",
          "19: # IN THE SOFTWARE.",
          "21: {",
          "22:   'targets': [",
          "23:     {",
          "24:       'dependencies': ['../../uv.gyp:libuv'],",
          "25:       'target_name': 's5-proxy',",
          "26:       'type': 'executable',",
          "27:       'sources': [",
          "28:         'client.c',",
          "29:         'defs.h',",
          "30:         'main.c',",
          "31:         's5.c',",
          "32:         's5.h',",
          "33:         'server.c',",
          "34:         'util.c',",
          "35:       ],",
          "36:       'conditions': [",
          "37:         ['OS==\"win\"', {",
          "38:           'defines': ['HAVE_UNISTD_H=0'],",
          "39:           'sources': ['getopt.c']",
          "40:         }, {",
          "41:           'defines': ['HAVE_UNISTD_H=1']",
          "42:         }]",
          "43:       ]",
          "44:     }",
          "45:   ]",
          "46: }",
          "",
          "---------------"
        ],
        "samples/socks5-proxy/client.c||samples/socks5-proxy/client.c": [
          "File: samples/socks5-proxy/client.c -> samples/socks5-proxy/client.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "22: #include \"defs.h\"",
          "23: #include <errno.h>",
          "24: #include <stdlib.h>",
          "25: #include <string.h>",
          "58: enum conn_state {",
          "62:   c_dead",
          "63: };",
          "66: enum sess_state {",
          "82: };",
          "84: static void do_next(client_ctx *cx);",
          "85: static int do_handshake(client_ctx *cx);",
          "86: static int do_handshake_auth(client_ctx *cx);",
          "87: static int do_req_start(client_ctx *cx);",
          "88: static int do_req_parse(client_ctx *cx);",
          "89: static int do_req_lookup(client_ctx *cx);",
          "90: static int do_req_connect_start(client_ctx *cx);",
          "91: static int do_req_connect(client_ctx *cx);",
          "92: static int do_proxy_start(client_ctx *cx);",
          "93: static int do_proxy(client_ctx *cx);",
          "94: static int do_kill(client_ctx *cx);",
          "95: static int do_almost_dead(client_ctx *cx);",
          "96: static int conn_cycle(const char *who, conn *a, conn *b);",
          "97: static void conn_timer_reset(conn *c);",
          "98: static void conn_timer_expire(uv_timer_t *handle, int status);",
          "99: static void conn_getaddrinfo(conn *c, const char *hostname);",
          "100: static void conn_getaddrinfo_done(uv_getaddrinfo_t *req,",
          "101:                                   int status,",
          "102:                                   struct addrinfo *ai);",
          "103: static int conn_connect(conn *c);",
          "104: static void conn_connect_done(uv_connect_t *req, int status);",
          "105: static void conn_read(conn *c);",
          "106: static void conn_read_done(uv_stream_t *handle,",
          "107:                            ssize_t nread,",
          "108:                            const uv_buf_t *buf);",
          "109: static void conn_alloc(uv_handle_t *handle, size_t size, uv_buf_t *buf);",
          "110: static void conn_write(conn *c, const void *data, unsigned int len);",
          "111: static void conn_write_done(uv_write_t *req, int status);",
          "112: static void conn_close(conn *c);",
          "113: static void conn_close_done(uv_handle_t *handle);",
          "116: void client_finish_init(server_ctx *sx, client_ctx *cx) {",
          "117:   conn *incoming;",
          "118:   conn *outgoing;",
          "120:   cx->sx = sx;",
          "121:   cx->state = s_handshake;",
          "122:   s5_init(&cx->parser);",
          "124:   incoming = &cx->incoming;",
          "125:   incoming->client = cx;",
          "126:   incoming->result = 0;",
          "127:   incoming->rdstate = c_stop;",
          "128:   incoming->wrstate = c_stop;",
          "129:   incoming->idle_timeout = sx->idle_timeout;",
          "130:   CHECK(0 == uv_timer_init(sx->loop, &incoming->timer_handle));",
          "132:   outgoing = &cx->outgoing;",
          "133:   outgoing->client = cx;",
          "134:   outgoing->result = 0;",
          "135:   outgoing->rdstate = c_stop;",
          "136:   outgoing->wrstate = c_stop;",
          "137:   outgoing->idle_timeout = sx->idle_timeout;",
          "138:   CHECK(0 == uv_tcp_init(cx->sx->loop, &outgoing->handle.tcp));",
          "139:   CHECK(0 == uv_timer_init(cx->sx->loop, &outgoing->timer_handle));",
          "142:   conn_read(incoming);",
          "143: }",
          "150: static void do_next(client_ctx *cx) {",
          "151:   int new_state;",
          "153:   ASSERT(cx->state != s_dead);",
          "154:   switch (cx->state) {",
          "155:     case s_handshake:",
          "156:       new_state = do_handshake(cx);",
          "157:       break;",
          "158:     case s_handshake_auth:",
          "159:       new_state = do_handshake_auth(cx);",
          "160:       break;",
          "161:     case s_req_start:",
          "162:       new_state = do_req_start(cx);",
          "163:       break;",
          "164:     case s_req_parse:",
          "165:       new_state = do_req_parse(cx);",
          "166:       break;",
          "167:     case s_req_lookup:",
          "168:       new_state = do_req_lookup(cx);",
          "169:       break;",
          "170:     case s_req_connect:",
          "171:       new_state = do_req_connect(cx);",
          "172:       break;",
          "173:     case s_proxy_start:",
          "174:       new_state = do_proxy_start(cx);",
          "175:       break;",
          "176:     case s_proxy:",
          "177:       new_state = do_proxy(cx);",
          "178:       break;",
          "179:     case s_kill:",
          "180:       new_state = do_kill(cx);",
          "181:       break;",
          "182:     case s_almost_dead_0:",
          "183:     case s_almost_dead_1:",
          "184:     case s_almost_dead_2:",
          "185:     case s_almost_dead_3:",
          "186:     case s_almost_dead_4:",
          "187:       new_state = do_almost_dead(cx);",
          "188:       break;",
          "189:     default:",
          "190:       UNREACHABLE();",
          "191:   }",
          "192:   cx->state = new_state;",
          "194:   if (cx->state == s_dead) {",
          "195:     if (DEBUG_CHECKS) {",
          "196:       memset(cx, -1, sizeof(*cx));",
          "197:     }",
          "198:     free(cx);",
          "199:   }",
          "200: }",
          "202: static int do_handshake(client_ctx *cx) {",
          "203:   unsigned int methods;",
          "204:   conn *incoming;",
          "205:   s5_ctx *parser;",
          "206:   uint8_t *data;",
          "207:   size_t size;",
          "208:   int err;",
          "210:   parser = &cx->parser;",
          "211:   incoming = &cx->incoming;",
          "212:   ASSERT(incoming->rdstate == c_done);",
          "213:   ASSERT(incoming->wrstate == c_stop);",
          "214:   incoming->rdstate = c_stop;",
          "216:   if (incoming->result < 0) {",
          "217:     pr_err(\"read error: %s\", uv_strerror(incoming->result));",
          "218:     return do_kill(cx);",
          "219:   }",
          "221:   data = (uint8_t *) incoming->t.buf;",
          "222:   size = (size_t) incoming->result;",
          "223:   err = s5_parse(parser, &data, &size);",
          "224:   if (err == s5_ok) {",
          "225:     conn_read(incoming);",
          "227:   }",
          "229:   if (size != 0) {",
          "234:     pr_err(\"junk in handshake\");",
          "235:     return do_kill(cx);",
          "236:   }",
          "238:   if (err != s5_auth_select) {",
          "239:     pr_err(\"handshake error: %s\", s5_strerror(err));",
          "240:     return do_kill(cx);",
          "241:   }",
          "243:   methods = s5_auth_methods(parser);",
          "244:   if ((methods & S5_AUTH_NONE) && can_auth_none(cx->sx, cx)) {",
          "245:     s5_select_auth(parser, S5_AUTH_NONE);",
          "247:     return s_req_start;",
          "248:   }",
          "250:   if ((methods & S5_AUTH_PASSWD) && can_auth_passwd(cx->sx, cx)) {",
          "252:   }",
          "255:   return s_kill;",
          "256: }",
          "259: static int do_handshake_auth(client_ctx *cx) {",
          "260:   UNREACHABLE();",
          "261:   return do_kill(cx);",
          "262: }",
          "264: static int do_req_start(client_ctx *cx) {",
          "265:   conn *incoming;",
          "267:   incoming = &cx->incoming;",
          "268:   ASSERT(incoming->rdstate == c_stop);",
          "269:   ASSERT(incoming->wrstate == c_done);",
          "270:   incoming->wrstate = c_stop;",
          "272:   if (incoming->result < 0) {",
          "273:     pr_err(\"write error: %s\", uv_strerror(incoming->result));",
          "274:     return do_kill(cx);",
          "275:   }",
          "277:   conn_read(incoming);",
          "278:   return s_req_parse;",
          "279: }",
          "281: static int do_req_parse(client_ctx *cx) {",
          "282:   conn *incoming;",
          "283:   conn *outgoing;",
          "284:   s5_ctx *parser;",
          "285:   uint8_t *data;",
          "286:   size_t size;",
          "287:   int err;",
          "289:   parser = &cx->parser;",
          "290:   incoming = &cx->incoming;",
          "291:   outgoing = &cx->outgoing;",
          "292:   ASSERT(incoming->rdstate == c_done);",
          "293:   ASSERT(incoming->wrstate == c_stop);",
          "294:   ASSERT(outgoing->rdstate == c_stop);",
          "295:   ASSERT(outgoing->wrstate == c_stop);",
          "296:   incoming->rdstate = c_stop;",
          "298:   if (incoming->result < 0) {",
          "299:     pr_err(\"read error: %s\", uv_strerror(incoming->result));",
          "300:     return do_kill(cx);",
          "301:   }",
          "303:   data = (uint8_t *) incoming->t.buf;",
          "304:   size = (size_t) incoming->result;",
          "305:   err = s5_parse(parser, &data, &size);",
          "306:   if (err == s5_ok) {",
          "307:     conn_read(incoming);",
          "309:   }",
          "311:   if (size != 0) {",
          "312:     pr_err(\"junk in request %u\", (unsigned) size);",
          "313:     return do_kill(cx);",
          "314:   }",
          "316:   if (err != s5_exec_cmd) {",
          "317:     pr_err(\"request error: %s\", s5_strerror(err));",
          "318:     return do_kill(cx);",
          "319:   }",
          "321:   if (parser->cmd == s5_cmd_tcp_bind) {",
          "323:     pr_warn(\"BIND requests are not supported.\");",
          "324:     return do_kill(cx);",
          "325:   }",
          "327:   if (parser->cmd == s5_cmd_udp_assoc) {",
          "331:     pr_warn(\"UDP ASSOC requests are not supported.\");",
          "332:     return do_kill(cx);",
          "333:   }",
          "334:   ASSERT(parser->cmd == s5_cmd_tcp_connect);",
          "336:   if (parser->atyp == s5_atyp_host) {",
          "337:     conn_getaddrinfo(outgoing, (const char *) parser->daddr);",
          "338:     return s_req_lookup;",
          "339:   }",
          "341:   if (parser->atyp == s5_atyp_ipv4) {",
          "342:     memset(&outgoing->t.addr4, 0, sizeof(outgoing->t.addr4));",
          "343:     outgoing->t.addr4.sin_family = AF_INET;",
          "344:     outgoing->t.addr4.sin_port = htons(parser->dport);",
          "345:     memcpy(&outgoing->t.addr4.sin_addr,",
          "346:            parser->daddr,",
          "347:            sizeof(outgoing->t.addr4.sin_addr));",
          "348:   } else if (parser->atyp == s5_atyp_ipv6) {",
          "349:     memset(&outgoing->t.addr6, 0, sizeof(outgoing->t.addr6));",
          "350:     outgoing->t.addr6.sin6_family = AF_INET6;",
          "351:     outgoing->t.addr6.sin6_port = htons(parser->dport);",
          "352:     memcpy(&outgoing->t.addr6.sin6_addr,",
          "353:            parser->daddr,",
          "354:            sizeof(outgoing->t.addr6.sin6_addr));",
          "355:   } else {",
          "356:     UNREACHABLE();",
          "357:   }",
          "359:   return do_req_connect_start(cx);",
          "360: }",
          "362: static int do_req_lookup(client_ctx *cx) {",
          "363:   s5_ctx *parser;",
          "364:   conn *incoming;",
          "365:   conn *outgoing;",
          "367:   parser = &cx->parser;",
          "368:   incoming = &cx->incoming;",
          "369:   outgoing = &cx->outgoing;",
          "370:   ASSERT(incoming->rdstate == c_stop);",
          "371:   ASSERT(incoming->wrstate == c_stop);",
          "372:   ASSERT(outgoing->rdstate == c_stop);",
          "373:   ASSERT(outgoing->wrstate == c_stop);",
          "375:   if (outgoing->result < 0) {",
          "377:     pr_err(\"lookup error for \\\"%s\\\": %s\",",
          "378:            parser->daddr,",
          "379:            uv_strerror(outgoing->result));",
          "381:     conn_write(incoming, \"\\5\\4\\0\\1\\0\\0\\0\\0\\0\\0\", 10);",
          "382:     return s_kill;",
          "383:   }",
          "386:   switch (outgoing->t.addr.sa_family) {",
          "387:     case AF_INET:",
          "388:       outgoing->t.addr4.sin_port = htons(parser->dport);",
          "389:       break;",
          "390:     case AF_INET6:",
          "391:       outgoing->t.addr6.sin6_port = htons(parser->dport);",
          "392:       break;",
          "393:     default:",
          "394:       UNREACHABLE();",
          "395:   }",
          "397:   return do_req_connect_start(cx);",
          "398: }",
          "401: static int do_req_connect_start(client_ctx *cx) {",
          "402:   conn *incoming;",
          "403:   conn *outgoing;",
          "404:   int err;",
          "406:   incoming = &cx->incoming;",
          "407:   outgoing = &cx->outgoing;",
          "408:   ASSERT(incoming->rdstate == c_stop);",
          "409:   ASSERT(incoming->wrstate == c_stop);",
          "410:   ASSERT(outgoing->rdstate == c_stop);",
          "411:   ASSERT(outgoing->wrstate == c_stop);",
          "413:   if (!can_access(cx->sx, cx, &outgoing->t.addr)) {",
          "414:     pr_warn(\"connection not allowed by ruleset\");",
          "416:     conn_write(incoming, \"\\5\\2\\0\\1\\0\\0\\0\\0\\0\\0\", 10);",
          "417:     return s_kill;",
          "418:   }",
          "420:   err = conn_connect(outgoing);",
          "421:   if (err != 0) {",
          "422:     pr_err(\"connect error: %s\\n\", uv_strerror(err));",
          "423:     return do_kill(cx);",
          "424:   }",
          "426:   return s_req_connect;",
          "427: }",
          "429: static int do_req_connect(client_ctx *cx) {",
          "430:   const struct sockaddr_in6 *in6;",
          "431:   const struct sockaddr_in *in;",
          "432:   char addr_storage[sizeof(*in6)];",
          "433:   conn *incoming;",
          "434:   conn *outgoing;",
          "435:   uint8_t *buf;",
          "436:   int addrlen;",
          "438:   incoming = &cx->incoming;",
          "439:   outgoing = &cx->outgoing;",
          "440:   ASSERT(incoming->rdstate == c_stop);",
          "441:   ASSERT(incoming->wrstate == c_stop);",
          "442:   ASSERT(outgoing->rdstate == c_stop);",
          "443:   ASSERT(outgoing->wrstate == c_stop);",
          "446:   buf = (uint8_t *) incoming->t.buf;",
          "447:   if (outgoing->result == 0) {",
          "451:     addrlen = sizeof(addr_storage);",
          "452:     CHECK(0 == uv_tcp_getsockname(&outgoing->handle.tcp,",
          "453:                                   (struct sockaddr *) addr_storage,",
          "454:                                   &addrlen));",
          "458:     if (addrlen == sizeof(*in)) {",
          "460:       in = (const struct sockaddr_in *) &addr_storage;",
          "461:       memcpy(buf + 4, &in->sin_addr, 4);",
          "462:       memcpy(buf + 8, &in->sin_port, 2);",
          "463:       conn_write(incoming, buf, 10);",
          "464:     } else if (addrlen == sizeof(*in6)) {",
          "466:       in6 = (const struct sockaddr_in6 *) &addr_storage;",
          "467:       memcpy(buf + 4, &in6->sin6_addr, 16);",
          "468:       memcpy(buf + 20, &in6->sin6_port, 2);",
          "469:       conn_write(incoming, buf, 22);",
          "470:     } else {",
          "471:       UNREACHABLE();",
          "472:     }",
          "473:     return s_proxy_start;",
          "474:   } else {",
          "475:     pr_err(\"upstream connection error: %s\\n\", uv_strerror(outgoing->result));",
          "477:     conn_write(incoming, \"\\5\\5\\0\\1\\0\\0\\0\\0\\0\\0\", 10);",
          "478:     return s_kill;",
          "479:   }",
          "481:   UNREACHABLE();",
          "482:   return s_kill;",
          "483: }",
          "485: static int do_proxy_start(client_ctx *cx) {",
          "486:   conn *incoming;",
          "487:   conn *outgoing;",
          "489:   incoming = &cx->incoming;",
          "490:   outgoing = &cx->outgoing;",
          "491:   ASSERT(incoming->rdstate == c_stop);",
          "492:   ASSERT(incoming->wrstate == c_done);",
          "493:   ASSERT(outgoing->rdstate == c_stop);",
          "494:   ASSERT(outgoing->wrstate == c_stop);",
          "495:   incoming->wrstate = c_stop;",
          "497:   if (incoming->result < 0) {",
          "498:     pr_err(\"write error: %s\", uv_strerror(incoming->result));",
          "499:     return do_kill(cx);",
          "500:   }",
          "502:   conn_read(incoming);",
          "503:   conn_read(outgoing);",
          "504:   return s_proxy;",
          "505: }",
          "508: static int do_proxy(client_ctx *cx) {",
          "509:   if (conn_cycle(\"client\", &cx->incoming, &cx->outgoing)) {",
          "510:     return do_kill(cx);",
          "511:   }",
          "513:   if (conn_cycle(\"upstream\", &cx->outgoing, &cx->incoming)) {",
          "514:     return do_kill(cx);",
          "515:   }",
          "517:   return s_proxy;",
          "518: }",
          "520: static int do_kill(client_ctx *cx) {",
          "521:   int new_state;",
          "523:   if (cx->state >= s_almost_dead_0) {",
          "524:     return cx->state;",
          "525:   }",
          "530:   new_state = s_almost_dead_1;",
          "531:   if (cx->state == s_req_lookup) {",
          "532:     new_state = s_almost_dead_0;",
          "533:     uv_cancel(&cx->outgoing.t.req);",
          "534:   }",
          "536:   conn_close(&cx->incoming);",
          "537:   conn_close(&cx->outgoing);",
          "538:   return new_state;",
          "539: }",
          "541: static int do_almost_dead(client_ctx *cx) {",
          "542:   ASSERT(cx->state >= s_almost_dead_0);",
          "544: }",
          "546: static int conn_cycle(const char *who, conn *a, conn *b) {",
          "547:   if (a->result < 0) {",
          "548:     if (a->result != UV_EOF) {",
          "549:       pr_err(\"%s error: %s\", who, uv_strerror(a->result));",
          "550:     }",
          "551:     return -1;",
          "552:   }",
          "554:   if (b->result < 0) {",
          "555:     return -1;",
          "556:   }",
          "558:   if (a->wrstate == c_done) {",
          "559:     a->wrstate = c_stop;",
          "560:   }",
          "566:   if (a->wrstate == c_stop) {",
          "567:     if (b->rdstate == c_stop) {",
          "568:       conn_read(b);",
          "569:     } else if (b->rdstate == c_done) {",
          "570:       conn_write(a, b->t.buf, b->result);",
          "572:     }",
          "573:   }",
          "575:   return 0;",
          "576: }",
          "578: static void conn_timer_reset(conn *c) {",
          "579:   CHECK(0 == uv_timer_start(&c->timer_handle,",
          "580:                             conn_timer_expire,",
          "581:                             c->idle_timeout,",
          "582:                             0));",
          "583: }",
          "585: static void conn_timer_expire(uv_timer_t *handle, int status) {",
          "586:   conn *c;",
          "588:   CHECK(0 == status);",
          "589:   c = CONTAINER_OF(handle, conn, timer_handle);",
          "590:   c->result = UV_ETIMEDOUT;",
          "591:   do_next(c->client);",
          "592: }",
          "594: static void conn_getaddrinfo(conn *c, const char *hostname) {",
          "595:   struct addrinfo hints;",
          "597:   memset(&hints, 0, sizeof(hints));",
          "598:   hints.ai_family = AF_UNSPEC;",
          "599:   hints.ai_socktype = SOCK_STREAM;",
          "600:   hints.ai_protocol = IPPROTO_TCP;",
          "601:   CHECK(0 == uv_getaddrinfo(c->client->sx->loop,",
          "602:                             &c->t.addrinfo_req,",
          "603:                             conn_getaddrinfo_done,",
          "604:                             hostname,",
          "605:                             NULL,",
          "606:                             &hints));",
          "607:   conn_timer_reset(c);",
          "608: }",
          "610: static void conn_getaddrinfo_done(uv_getaddrinfo_t *req,",
          "611:                                   int status,",
          "612:                                   struct addrinfo *ai) {",
          "613:   conn *c;",
          "615:   c = CONTAINER_OF(req, conn, t.addrinfo_req);",
          "616:   c->result = status;",
          "618:   if (status == 0) {",
          "620:     if (ai->ai_family == AF_INET) {",
          "621:       c->t.addr4 = *(const struct sockaddr_in *) ai->ai_addr;",
          "622:     } else if (ai->ai_family == AF_INET6) {",
          "623:       c->t.addr6 = *(const struct sockaddr_in6 *) ai->ai_addr;",
          "624:     } else {",
          "625:       UNREACHABLE();",
          "626:     }",
          "627:   }",
          "629:   uv_freeaddrinfo(ai);",
          "630:   do_next(c->client);",
          "631: }",
          "634: static int conn_connect(conn *c) {",
          "635:   ASSERT(c->t.addr.sa_family == AF_INET ||",
          "636:          c->t.addr.sa_family == AF_INET6);",
          "637:   conn_timer_reset(c);",
          "638:   return uv_tcp_connect(&c->t.connect_req,",
          "639:                         &c->handle.tcp,",
          "640:                         &c->t.addr,",
          "641:                         conn_connect_done);",
          "642: }",
          "644: static void conn_connect_done(uv_connect_t *req, int status) {",
          "645:   conn *c;",
          "647:   if (status == UV_ECANCELED) {",
          "649:   }",
          "651:   c = CONTAINER_OF(req, conn, t.connect_req);",
          "652:   c->result = status;",
          "653:   do_next(c->client);",
          "654: }",
          "656: static void conn_read(conn *c) {",
          "657:   ASSERT(c->rdstate == c_stop);",
          "658:   CHECK(0 == uv_read_start(&c->handle.stream, conn_alloc, conn_read_done));",
          "659:   c->rdstate = c_busy;",
          "660:   conn_timer_reset(c);",
          "661: }",
          "663: static void conn_read_done(uv_stream_t *handle,",
          "664:                            ssize_t nread,",
          "665:                            const uv_buf_t *buf) {",
          "666:   conn *c;",
          "668:   c = CONTAINER_OF(handle, conn, handle);",
          "669:   ASSERT(c->t.buf == buf->base);",
          "670:   ASSERT(c->rdstate == c_busy);",
          "671:   c->rdstate = c_done;",
          "672:   c->result = nread;",
          "674:   uv_read_stop(&c->handle.stream);",
          "675:   do_next(c->client);",
          "676: }",
          "678: static void conn_alloc(uv_handle_t *handle, size_t size, uv_buf_t *buf) {",
          "679:   conn *c;",
          "681:   c = CONTAINER_OF(handle, conn, handle);",
          "682:   ASSERT(c->rdstate == c_busy);",
          "683:   buf->base = c->t.buf;",
          "684:   buf->len = sizeof(c->t.buf);",
          "685: }",
          "687: static void conn_write(conn *c, const void *data, unsigned int len) {",
          "688:   uv_buf_t buf;",
          "690:   ASSERT(c->wrstate == c_stop || c->wrstate == c_done);",
          "691:   c->wrstate = c_busy;",
          "696:   buf.base = (char *) data;",
          "697:   buf.len = len;",
          "699:   CHECK(0 == uv_write(&c->write_req,",
          "700:                       &c->handle.stream,",
          "701:                       &buf,",
          "702:                       1,",
          "703:                       conn_write_done));",
          "704:   conn_timer_reset(c);",
          "705: }",
          "707: static void conn_write_done(uv_write_t *req, int status) {",
          "708:   conn *c;",
          "710:   if (status == UV_ECANCELED) {",
          "712:   }",
          "714:   c = CONTAINER_OF(req, conn, write_req);",
          "715:   ASSERT(c->wrstate == c_busy);",
          "716:   c->wrstate = c_done;",
          "717:   c->result = status;",
          "718:   do_next(c->client);",
          "719: }",
          "721: static void conn_close(conn *c) {",
          "722:   ASSERT(c->rdstate != c_dead);",
          "723:   ASSERT(c->wrstate != c_dead);",
          "724:   c->rdstate = c_dead;",
          "725:   c->wrstate = c_dead;",
          "726:   c->timer_handle.data = c;",
          "727:   c->handle.handle.data = c;",
          "728:   uv_close(&c->handle.handle, conn_close_done);",
          "729:   uv_close((uv_handle_t *) &c->timer_handle, conn_close_done);",
          "730: }",
          "732: static void conn_close_done(uv_handle_t *handle) {",
          "733:   conn *c;",
          "735:   c = handle->data;",
          "736:   do_next(c->client);",
          "737: }",
          "",
          "---------------"
        ],
        "samples/socks5-proxy/defs.h||samples/socks5-proxy/defs.h": [
          "File: samples/socks5-proxy/defs.h -> samples/socks5-proxy/defs.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "22: #ifndef DEFS_H_",
          "23: #define DEFS_H_",
          "25: #include \"s5.h\"",
          "26: #include \"uv.h\"",
          "28: #include <assert.h>",
          "31: #include <stdint.h>",
          "34: struct client_ctx;",
          "36: typedef struct {",
          "37:   const char *bind_host;",
          "38:   unsigned short bind_port;",
          "39:   unsigned int idle_timeout;",
          "40: } server_config;",
          "42: typedef struct {",
          "44:   uv_tcp_t tcp_handle;",
          "45:   uv_loop_t *loop;",
          "46: } server_ctx;",
          "48: typedef struct {",
          "49:   unsigned char rdstate;",
          "50:   unsigned char wrstate;",
          "51:   unsigned int idle_timeout;",
          "53:   ssize_t result;",
          "54:   union {",
          "55:     uv_handle_t handle;",
          "56:     uv_stream_t stream;",
          "57:     uv_tcp_t tcp;",
          "58:     uv_udp_t udp;",
          "59:   } handle;",
          "61:   uv_write_t write_req;",
          "63:   union {",
          "64:     uv_getaddrinfo_t addrinfo_req;",
          "65:     uv_connect_t connect_req;",
          "66:     uv_req_t req;",
          "67:     struct sockaddr_in6 addr6;",
          "68:     struct sockaddr_in addr4;",
          "69:     struct sockaddr addr;",
          "71:   } t;",
          "72: } conn;",
          "74: typedef struct client_ctx {",
          "75:   unsigned int state;",
          "80: } client_ctx;",
          "83: int server_run(const server_config *cf, uv_loop_t *loop);",
          "84: int can_auth_none(const server_ctx *sx, const client_ctx *cx);",
          "85: int can_auth_passwd(const server_ctx *sx, const client_ctx *cx);",
          "86: int can_access(const server_ctx *sx,",
          "87:                const client_ctx *cx,",
          "88:                const struct sockaddr *addr);",
          "91: void client_finish_init(server_ctx *sx, client_ctx *cx);",
          "94: #if defined(__GNUC__)",
          "95: # define ATTRIBUTE_FORMAT_PRINTF(a, b) __attribute__((format(printf, a, b)))",
          "96: #else",
          "97: # define ATTRIBUTE_FORMAT_PRINTF(a, b)",
          "98: #endif",
          "99: void pr_info(const char *fmt, ...) ATTRIBUTE_FORMAT_PRINTF(1, 2);",
          "100: void pr_warn(const char *fmt, ...) ATTRIBUTE_FORMAT_PRINTF(1, 2);",
          "101: void pr_err(const char *fmt, ...) ATTRIBUTE_FORMAT_PRINTF(1, 2);",
          "102: void *xmalloc(size_t size);",
          "105: const char *_getprogname(void);",
          "108: #if !HAVE_UNISTD_H",
          "109: extern char *optarg;",
          "110: int getopt(int argc, char **argv, const char *options);",
          "111: #endif",
          "118: #if defined(NDEBUG)",
          "119: # define ASSERT(exp)",
          "120: # define CHECK(exp)   do { if (!(exp)) abort(); } while (0)",
          "121: # define DEBUG_CHECKS (0)",
          "122: #else",
          "123: # define ASSERT(exp)  assert(exp)",
          "124: # define CHECK(exp)   assert(exp)",
          "125: # define DEBUG_CHECKS (1)",
          "126: #endif",
          "128: #define UNREACHABLE() CHECK(!\"Unreachable code reached.\")",
          "136: #define CONTAINER_OF(ptr, type, field)                                        \\",
          "137:   ((type *) ((char *) (ptr) - ((char *) &((type *) 0)->field)))",
          "",
          "---------------"
        ],
        "samples/socks5-proxy/getopt.c||samples/socks5-proxy/getopt.c": [
          "File: samples/socks5-proxy/getopt.c -> samples/socks5-proxy/getopt.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "32: #if defined(LIBC_SCCS) && !defined(lint)",
          "33: static char sccsid[] = \"@(#)getopt.c 8.3 (Berkeley) 4/27/95\";",
          "36: #include <stdio.h>",
          "37: #include <stdlib.h>",
          "38: #include <string.h>",
          "39: #include <unistd.h>",
          "41: extern const char *_getprogname(void);",
          "49: #define BADCH (int)'?'",
          "50: #define BADARG (int)':'",
          "51: #define EMSG \"\"",
          "57: int",
          "58: getopt(nargc, nargv, ostr)",
          "59:  int nargc;",
          "60:  char * const nargv[];",
          "61:  const char *ostr;",
          "62: {",
          "67:   optreset = 0;",
          "68:   place = nargv[optind];",
          "69:   if (optind >= nargc || *place++ != '-') {",
          "71:    place = EMSG;",
          "72:    return (-1);",
          "73:   }",
          "74:   optopt = *place++;",
          "75:   if (optopt == '-' && *place == 0) {",
          "77:    ++optind;",
          "78:    place = EMSG;",
          "79:    return (-1);",
          "80:   }",
          "81:   if (optopt == 0) {",
          "84:    place = EMSG;",
          "85:    if (strchr(ostr, '-') == NULL)",
          "86:     return (-1);",
          "87:    optopt = '-';",
          "88:   }",
          "89:  } else",
          "90:   optopt = *place++;",
          "93:  if (optopt == ':' || (oli = strchr(ostr, optopt)) == NULL) {",
          "94:   if (*place == 0)",
          "95:    ++optind;",
          "96:   if (opterr && *ostr != ':')",
          "97:    (void)fprintf(stderr,",
          "98:        \"%s: illegal option -- %c\\n\", _getprogname(),",
          "99:        optopt);",
          "100:   return (BADCH);",
          "101:  }",
          "104:  if (oli[1] != ':') {",
          "106:   optarg = NULL;",
          "107:   if (*place == 0)",
          "108:    ++optind;",
          "109:  } else {",
          "112:   if (*place)",
          "113:    optarg = place;",
          "114:   else if (nargc > ++optind)",
          "115:    optarg = nargv[optind];",
          "116:   else {",
          "118:    place = EMSG;",
          "119:    if (*ostr == ':')",
          "120:     return (BADARG);",
          "121:    if (opterr)",
          "122:     (void)fprintf(stderr,",
          "123:         \"%s: option requires an argument -- %c\\n\",",
          "124:         _getprogname(), optopt);",
          "125:    return (BADCH);",
          "126:   }",
          "127:   place = EMSG;",
          "128:   ++optind;",
          "129:  }",
          "131: }",
          "",
          "---------------"
        ],
        "samples/socks5-proxy/main.c||samples/socks5-proxy/main.c": [
          "File: samples/socks5-proxy/main.c -> samples/socks5-proxy/main.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "22: #include \"defs.h\"",
          "23: #include <stdio.h>",
          "24: #include <stdlib.h>",
          "25: #include <string.h>",
          "27: #if HAVE_UNISTD_H",
          "29: #endif",
          "31: #define DEFAULT_BIND_HOST     \"127.0.0.1\"",
          "32: #define DEFAULT_BIND_PORT     1080",
          "33: #define DEFAULT_IDLE_TIMEOUT  (60 * 1000)",
          "35: static void parse_opts(server_config *cf, int argc, char **argv);",
          "36: static void usage(void);",
          "40: int main(int argc, char **argv) {",
          "41:   server_config config;",
          "42:   int err;",
          "44:   progname = argv[0];",
          "45:   memset(&config, 0, sizeof(config));",
          "46:   config.bind_host = DEFAULT_BIND_HOST;",
          "47:   config.bind_port = DEFAULT_BIND_PORT;",
          "48:   config.idle_timeout = DEFAULT_IDLE_TIMEOUT;",
          "49:   parse_opts(&config, argc, argv);",
          "51:   err = server_run(&config, uv_default_loop());",
          "52:   if (err) {",
          "53:     exit(1);",
          "54:   }",
          "56:   return 0;",
          "57: }",
          "59: const char *_getprogname(void) {",
          "60:   return progname;",
          "61: }",
          "63: static void parse_opts(server_config *cf, int argc, char **argv) {",
          "64:   int opt;",
          "66:   while (-1 != (opt = getopt(argc, argv, \"H:hp:\"))) {",
          "67:     switch (opt) {",
          "68:       case 'H':",
          "69:         cf->bind_host = optarg;",
          "70:         break;",
          "72:       case 'p':",
          "73:         if (1 != sscanf(optarg, \"%hu\", &cf->bind_port)) {",
          "74:           pr_err(\"bad port number: %s\", optarg);",
          "75:           usage();",
          "76:         }",
          "77:         break;",
          "79:       default:",
          "80:         usage();",
          "81:     }",
          "82:   }",
          "83: }",
          "85: static void usage(void) {",
          "86:   printf(\"Usage:\\n\"",
          "87:          \"\\n\"",
          "88:          \"  %s [-b <address> [-h] [-p <port>]\\n\"",
          "89:          \"\\n\"",
          "90:          \"Options:\\n\"",
          "91:          \"\\n\"",
          "92:          \"  -b <hostname|address>  Bind to this address or hostname.\\n\"",
          "93:          \"                         Default: \\\"127.0.0.1\\\"\\n\"",
          "94:          \"  -h                     Show this help message.\\n\"",
          "95:          \"  -p <port>              Bind to this port number.  Default: 1080\\n\"",
          "96:          \"\",",
          "97:          progname);",
          "98:   exit(1);",
          "99: }",
          "",
          "---------------"
        ],
        "samples/socks5-proxy/s5.c||samples/socks5-proxy/s5.c": [
          "File: samples/socks5-proxy/s5.c -> samples/socks5-proxy/s5.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "22: #include \"s5.h\"",
          "23: #include <errno.h>",
          "24: #include <stdint.h>",
          "28: enum {",
          "29:   s5_version,",
          "30:   s5_nmethods,",
          "31:   s5_methods,",
          "32:   s5_auth_pw_version,",
          "33:   s5_auth_pw_userlen,",
          "34:   s5_auth_pw_username,",
          "35:   s5_auth_pw_passlen,",
          "36:   s5_auth_pw_password,",
          "37:   s5_req_version,",
          "38:   s5_req_cmd,",
          "39:   s5_req_reserved,",
          "40:   s5_req_atyp,",
          "41:   s5_req_atyp_host,",
          "42:   s5_req_daddr,",
          "43:   s5_req_dport0,",
          "44:   s5_req_dport1,",
          "45:   s5_dead",
          "46: };",
          "48: void s5_init(s5_ctx *cx) {",
          "49:   memset(cx, 0, sizeof(*cx));",
          "50:   cx->state = s5_version;",
          "51: }",
          "53: s5_err s5_parse(s5_ctx *cx, uint8_t **data, size_t *size) {",
          "54:   s5_err err;",
          "55:   uint8_t *p;",
          "56:   uint8_t c;",
          "57:   size_t i;",
          "58:   size_t n;",
          "60:   p = *data;",
          "61:   n = *size;",
          "62:   i = 0;",
          "64:   while (i < n) {",
          "65:     c = p[i];",
          "66:     i += 1;",
          "67:     switch (cx->state) {",
          "68:       case s5_version:",
          "69:         if (c != 5) {",
          "70:           err = s5_bad_version;",
          "71:           goto out;",
          "72:         }",
          "73:         cx->state = s5_nmethods;",
          "74:         break;",
          "76:       case s5_nmethods:",
          "77:         cx->arg0 = 0;",
          "79:         cx->state = s5_methods;",
          "80:         break;",
          "82:       case s5_methods:",
          "83:         if (cx->arg0 < cx->arg1) {",
          "84:           switch (c) {",
          "85:             case 0:",
          "86:               cx->methods |= S5_AUTH_NONE;",
          "87:               break;",
          "88:             case 1:",
          "89:               cx->methods |= S5_AUTH_GSSAPI;",
          "90:               break;",
          "91:             case 2:",
          "92:               cx->methods |= S5_AUTH_PASSWD;",
          "93:               break;",
          "95:           }",
          "96:           cx->arg0 += 1;",
          "97:         }",
          "98:         if (cx->arg0 == cx->arg1) {",
          "99:           err = s5_auth_select;",
          "100:           goto out;",
          "101:         }",
          "102:         break;",
          "104:       case s5_auth_pw_version:",
          "105:         if (c != 1) {",
          "106:           err = s5_bad_version;",
          "107:           goto out;",
          "108:         }",
          "109:         cx->state = s5_auth_pw_userlen;",
          "110:         break;",
          "112:       case s5_auth_pw_userlen:",
          "113:         cx->arg0 = 0;",
          "114:         cx->userlen = c;",
          "115:         cx->state = s5_auth_pw_username;",
          "116:         break;",
          "118:       case s5_auth_pw_username:",
          "119:         if (cx->arg0 < cx->userlen) {",
          "120:           cx->username[cx->arg0] = c;",
          "121:           cx->arg0 += 1;",
          "122:         }",
          "123:         if (cx->arg0 == cx->userlen) {",
          "124:           cx->username[cx->userlen] = '\\0';",
          "125:           cx->state = s5_auth_pw_passlen;",
          "126:         }",
          "127:         break;",
          "129:       case s5_auth_pw_passlen:",
          "130:         cx->arg0 = 0;",
          "131:         cx->passlen = c;",
          "132:         cx->state = s5_auth_pw_password;",
          "133:         break;",
          "135:       case s5_auth_pw_password:",
          "136:         if (cx->arg0 < cx->passlen) {",
          "137:           cx->password[cx->arg0] = c;",
          "138:           cx->arg0 += 1;",
          "139:         }",
          "140:         if (cx->arg0 == cx->passlen) {",
          "141:           cx->password[cx->passlen] = '\\0';",
          "142:           cx->state = s5_req_version;",
          "143:           err = s5_auth_verify;",
          "144:           goto out;",
          "145:         }",
          "146:         break;",
          "148:       case s5_req_version:",
          "149:         if (c != 5) {",
          "150:           err = s5_bad_version;",
          "151:           goto out;",
          "152:         }",
          "153:         cx->state = s5_req_cmd;",
          "154:         break;",
          "156:       case s5_req_cmd:",
          "157:         switch (c) {",
          "159:             cx->cmd = s5_cmd_tcp_connect;",
          "160:             break;",
          "162:             cx->cmd = s5_cmd_udp_assoc;",
          "163:             break;",
          "164:           default:",
          "165:             err = s5_bad_cmd;",
          "166:             goto out;",
          "167:         }",
          "168:         cx->state = s5_req_reserved;",
          "169:         break;",
          "171:       case s5_req_reserved:",
          "172:         cx->state = s5_req_atyp;",
          "173:         break;",
          "175:       case s5_req_atyp:",
          "176:         cx->arg0 = 0;",
          "177:         switch (c) {",
          "179:             cx->state = s5_req_daddr;",
          "180:             cx->atyp = s5_atyp_ipv4;",
          "181:             cx->arg1 = 4;",
          "182:             break;",
          "184:             cx->state = s5_req_atyp_host;",
          "185:             cx->atyp = s5_atyp_host;",
          "186:             cx->arg1 = 0;",
          "187:             break;",
          "189:             cx->state = s5_req_daddr;",
          "190:             cx->atyp = s5_atyp_ipv6;",
          "191:             cx->arg1 = 16;",
          "192:             break;",
          "193:           default:",
          "194:             err = s5_bad_atyp;",
          "195:             goto out;",
          "196:         }",
          "197:         break;",
          "199:       case s5_req_atyp_host:",
          "200:         cx->arg1 = c;",
          "201:         cx->state = s5_req_daddr;",
          "202:         break;",
          "204:       case s5_req_daddr:",
          "205:         if (cx->arg0 < cx->arg1) {",
          "206:           cx->daddr[cx->arg0] = c;",
          "207:           cx->arg0 += 1;",
          "208:         }",
          "209:         if (cx->arg0 == cx->arg1) {",
          "210:           cx->daddr[cx->arg1] = '\\0';",
          "211:           cx->state = s5_req_dport0;",
          "212:         }",
          "213:         break;",
          "215:       case s5_req_dport0:",
          "216:         cx->dport = c << 8;",
          "217:         cx->state = s5_req_dport1;",
          "218:         break;",
          "220:       case s5_req_dport1:",
          "221:         cx->dport |= c;",
          "222:         cx->state = s5_dead;",
          "223:         err = s5_exec_cmd;",
          "224:         goto out;",
          "226:       case s5_dead:",
          "227:         break;",
          "229:       default:",
          "230:         abort();",
          "231:     }",
          "232:   }",
          "233:   err = s5_ok;",
          "235: out:",
          "238:   return err;",
          "239: }",
          "241: unsigned int s5_auth_methods(const s5_ctx *cx) {",
          "242:   return cx->methods;",
          "243: }",
          "245: int s5_select_auth(s5_ctx *cx, s5_auth_method method) {",
          "246:   int err;",
          "248:   err = 0;",
          "249:   switch (method) {",
          "250:     case S5_AUTH_NONE:",
          "251:       cx->state = s5_req_version;",
          "252:       break;",
          "253:     case S5_AUTH_PASSWD:",
          "254:       cx->state = s5_auth_pw_version;",
          "255:       break;",
          "256:     default:",
          "257:       err = -EINVAL;",
          "258:   }",
          "260:   return err;",
          "261: }",
          "263: const char *s5_strerror(s5_err err) {",
          "264: #define S5_ERR_GEN(_, name, errmsg) case s5_ ## name: return errmsg;",
          "265:   switch (err) {",
          "266:     S5_ERR_MAP(S5_ERR_GEN)",
          "268:   }",
          "269: #undef S5_ERR_GEN",
          "270:   return \"Unknown error.\";",
          "271: }",
          "",
          "---------------"
        ],
        "samples/socks5-proxy/s5.h||samples/socks5-proxy/s5.h": [
          "File: samples/socks5-proxy/s5.h -> samples/socks5-proxy/s5.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "22: #ifndef S5_H_",
          "23: #define S5_H_",
          "25: #include <stddef.h>",
          "26: #include <stdint.h>",
          "28: #define S5_ERR_MAP(V)                                                         \\",
          "29:   V(-1, bad_version, \"Bad protocol version.\")                                 \\",
          "30:   V(-2, bad_cmd, \"Bad protocol command.\")                                     \\",
          "31:   V(-3, bad_atyp, \"Bad address type.\")                                        \\",
          "32:   V(0, ok, \"No error.\")                                                       \\",
          "33:   V(1, auth_select, \"Select authentication method.\")                          \\",
          "34:   V(2, auth_verify, \"Verify authentication.\")                                 \\",
          "35:   V(3, exec_cmd, \"Execute command.\")                                          \\",
          "37: typedef enum {",
          "38: #define S5_ERR_GEN(code, name, _) s5_ ## name = code,",
          "39:   S5_ERR_MAP(S5_ERR_GEN)",
          "40: #undef S5_ERR_GEN",
          "41:   s5_max_errors",
          "42: } s5_err;",
          "44: typedef enum {",
          "45:   S5_AUTH_NONE = 1 << 0,",
          "46:   S5_AUTH_GSSAPI = 1 << 1,",
          "47:   S5_AUTH_PASSWD = 1 << 2",
          "48: } s5_auth_method;",
          "50: typedef enum {",
          "51:   s5_auth_allow,",
          "52:   s5_auth_deny",
          "53: } s5_auth_result;",
          "55: typedef enum {",
          "56:   s5_atyp_ipv4,",
          "57:   s5_atyp_ipv6,",
          "58:   s5_atyp_host",
          "59: } s5_atyp;",
          "61: typedef enum {",
          "62:   s5_cmd_tcp_connect,",
          "63:   s5_cmd_tcp_bind,",
          "64:   s5_cmd_udp_assoc",
          "65: } s5_cmd;",
          "67: typedef struct {",
          "70:   uint8_t state;",
          "71:   uint8_t methods;",
          "72:   uint8_t cmd;",
          "73:   uint8_t atyp;",
          "74:   uint8_t userlen;",
          "75:   uint8_t passlen;",
          "76:   uint16_t dport;",
          "77:   uint8_t username[257];",
          "78:   uint8_t password[257];",
          "80: } s5_ctx;",
          "82: void s5_init(s5_ctx *ctx);",
          "84: s5_err s5_parse(s5_ctx *cx, uint8_t **data, size_t *size);",
          "87: unsigned int s5_auth_methods(const s5_ctx *cx);",
          "90: int s5_select_auth(s5_ctx *cx, s5_auth_method method);",
          "92: const char *s5_strerror(s5_err err);",
          "",
          "---------------"
        ],
        "samples/socks5-proxy/server.c||samples/socks5-proxy/server.c": [
          "File: samples/socks5-proxy/server.c -> samples/socks5-proxy/server.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "22: #include \"defs.h\"",
          "24: #include <stdlib.h>",
          "25: #include <string.h>",
          "27: #ifndef INET6_ADDRSTRLEN",
          "28: # define INET6_ADDRSTRLEN 63",
          "29: #endif",
          "31: typedef struct {",
          "32:   uv_getaddrinfo_t getaddrinfo_req;",
          "33:   server_config config;",
          "34:   server_ctx *servers;",
          "35:   uv_loop_t *loop;",
          "36: } server_state;",
          "38: static void do_bind(uv_getaddrinfo_t *req, int status, struct addrinfo *ai);",
          "39: static void on_connection(uv_stream_t *server, int status);",
          "41: int server_run(const server_config *cf, uv_loop_t *loop) {",
          "42:   struct addrinfo hints;",
          "43:   server_state state;",
          "44:   int err;",
          "46:   memset(&state, 0, sizeof(state));",
          "47:   state.servers = NULL;",
          "48:   state.config = *cf;",
          "49:   state.loop = loop;",
          "54:   memset(&hints, 0, sizeof(hints));",
          "55:   hints.ai_family = AF_UNSPEC;",
          "56:   hints.ai_socktype = SOCK_STREAM;",
          "57:   hints.ai_protocol = IPPROTO_TCP;",
          "59:   err = uv_getaddrinfo(loop,",
          "60:                        &state.getaddrinfo_req,",
          "61:                        do_bind,",
          "62:                        cf->bind_host,",
          "63:                        NULL,",
          "64:                        &hints);",
          "65:   if (err != 0) {",
          "66:     pr_err(\"getaddrinfo: %s\", uv_strerror(err));",
          "67:     return err;",
          "68:   }",
          "71:   if (uv_run(loop, UV_RUN_DEFAULT)) {",
          "72:     abort();",
          "73:   }",
          "76:   uv_loop_delete(loop);",
          "77:   free(state.servers);",
          "78:   return 0;",
          "79: }",
          "82: static void do_bind(uv_getaddrinfo_t *req, int status, struct addrinfo *addrs) {",
          "83:   char addrbuf[INET6_ADDRSTRLEN + 1];",
          "84:   unsigned int ipv4_naddrs;",
          "85:   unsigned int ipv6_naddrs;",
          "86:   server_state *state;",
          "87:   server_config *cf;",
          "88:   struct addrinfo *ai;",
          "89:   const void *addrv;",
          "90:   const char *what;",
          "91:   uv_loop_t *loop;",
          "92:   server_ctx *sx;",
          "93:   unsigned int n;",
          "94:   int err;",
          "95:   union {",
          "96:     struct sockaddr addr;",
          "97:     struct sockaddr_in addr4;",
          "98:     struct sockaddr_in6 addr6;",
          "99:   } s;",
          "101:   state = CONTAINER_OF(req, server_state, getaddrinfo_req);",
          "102:   loop = state->loop;",
          "103:   cf = &state->config;",
          "105:   if (status < 0) {",
          "106:     pr_err(\"getaddrinfo(\\\"%s\\\"): %s\", cf->bind_host, uv_strerror(status));",
          "107:     uv_freeaddrinfo(addrs);",
          "108:     return;",
          "109:   }",
          "111:   ipv4_naddrs = 0;",
          "112:   ipv6_naddrs = 0;",
          "113:   for (ai = addrs; ai != NULL; ai = ai->ai_next) {",
          "114:     if (ai->ai_family == AF_INET) {",
          "115:       ipv4_naddrs += 1;",
          "116:     } else if (ai->ai_family == AF_INET6) {",
          "117:       ipv6_naddrs += 1;",
          "118:     }",
          "119:   }",
          "121:   if (ipv4_naddrs == 0 && ipv6_naddrs == 0) {",
          "122:     pr_err(\"%s has no IPv4/6 addresses\", cf->bind_host);",
          "123:     uv_freeaddrinfo(addrs);",
          "124:     return;",
          "125:   }",
          "127:   state->servers =",
          "128:       xmalloc((ipv4_naddrs + ipv6_naddrs) * sizeof(state->servers[0]));",
          "130:   n = 0;",
          "131:   for (ai = addrs; ai != NULL; ai = ai->ai_next) {",
          "132:     if (ai->ai_family != AF_INET && ai->ai_family != AF_INET6) {",
          "133:       continue;",
          "134:     }",
          "136:     if (ai->ai_family == AF_INET) {",
          "137:       s.addr4 = *(const struct sockaddr_in *) ai->ai_addr;",
          "138:       s.addr4.sin_port = htons(cf->bind_port);",
          "139:       addrv = &s.addr4.sin_addr;",
          "140:     } else if (ai->ai_family == AF_INET6) {",
          "141:       s.addr6 = *(const struct sockaddr_in6 *) ai->ai_addr;",
          "142:       s.addr6.sin6_port = htons(cf->bind_port);",
          "143:       addrv = &s.addr6.sin6_addr;",
          "144:     } else {",
          "145:       UNREACHABLE();",
          "146:     }",
          "148:     if (uv_inet_ntop(s.addr.sa_family, addrv, addrbuf, sizeof(addrbuf))) {",
          "149:       UNREACHABLE();",
          "150:     }",
          "152:     sx = state->servers + n;",
          "153:     sx->loop = loop;",
          "154:     sx->idle_timeout = state->config.idle_timeout;",
          "155:     CHECK(0 == uv_tcp_init(loop, &sx->tcp_handle));",
          "157:     what = \"uv_tcp_bind\";",
          "158:     err = uv_tcp_bind(&sx->tcp_handle, &s.addr);",
          "159:     if (err == 0) {",
          "160:       what = \"uv_listen\";",
          "161:       err = uv_listen((uv_stream_t *) &sx->tcp_handle, 128, on_connection);",
          "162:     }",
          "164:     if (err != 0) {",
          "165:       pr_err(\"%s(\\\"%s:%hu\\\"): %s\",",
          "166:              what,",
          "167:              addrbuf,",
          "168:              cf->bind_port,",
          "169:              uv_strerror(err));",
          "170:       while (n > 0) {",
          "171:         n -= 1;",
          "172:         uv_close((uv_handle_t *) (state->servers + n), NULL);",
          "173:       }",
          "174:       break;",
          "175:     }",
          "177:     pr_info(\"listening on %s:%hu\", addrbuf, cf->bind_port);",
          "178:     n += 1;",
          "179:   }",
          "181:   uv_freeaddrinfo(addrs);",
          "182: }",
          "184: static void on_connection(uv_stream_t *server, int status) {",
          "185:   server_ctx *sx;",
          "186:   client_ctx *cx;",
          "188:   CHECK(status == 0);",
          "189:   sx = CONTAINER_OF(server, server_ctx, tcp_handle);",
          "190:   cx = xmalloc(sizeof(*cx));",
          "191:   CHECK(0 == uv_tcp_init(sx->loop, &cx->incoming.handle.tcp));",
          "192:   CHECK(0 == uv_accept(server, &cx->incoming.handle.stream));",
          "193:   client_finish_init(sx, cx);",
          "194: }",
          "196: int can_auth_none(const server_ctx *sx, const client_ctx *cx) {",
          "197:   return 1;",
          "198: }",
          "200: int can_auth_passwd(const server_ctx *sx, const client_ctx *cx) {",
          "201:   return 0;",
          "202: }",
          "204: int can_access(const server_ctx *sx,",
          "205:                const client_ctx *cx,",
          "206:                const struct sockaddr *addr) {",
          "207:   const struct sockaddr_in6 *addr6;",
          "208:   const struct sockaddr_in *addr4;",
          "209:   const uint32_t *p;",
          "210:   uint32_t a;",
          "211:   uint32_t b;",
          "212:   uint32_t c;",
          "213:   uint32_t d;",
          "218:   if (addr->sa_family == AF_INET) {",
          "219:     addr4 = (const struct sockaddr_in *) addr;",
          "220:     d = ntohl(addr4->sin_addr.s_addr);",
          "221:     return (d >> 24) != 0x7F;",
          "222:   }",
          "224:   if (addr->sa_family == AF_INET6) {",
          "225:     addr6 = (const struct sockaddr_in6 *) addr;",
          "226:     p = (const uint32_t *) &addr6->sin6_addr.s6_addr;",
          "227:     a = ntohl(p[0]);",
          "228:     b = ntohl(p[1]);",
          "229:     c = ntohl(p[2]);",
          "230:     d = ntohl(p[3]);",
          "231:     if (a == 0 && b == 0 && c == 0 && d == 1) {",
          "233:     }",
          "234:     if (a == 0 && b == 0 && c == 0xFFFF && (d >> 24) == 0x7F) {",
          "236:     }",
          "237:     return 1;",
          "238:   }",
          "240:   return 0;",
          "241: }",
          "",
          "---------------"
        ],
        "samples/socks5-proxy/util.c||samples/socks5-proxy/util.c": [
          "File: samples/socks5-proxy/util.c -> samples/socks5-proxy/util.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "22: #include \"defs.h\"",
          "23: #include <stdarg.h>",
          "24: #include <stdio.h>",
          "25: #include <stdlib.h>",
          "27: static void pr_do(FILE *stream,",
          "28:                   const char *label,",
          "29:                   const char *fmt,",
          "30:                   va_list ap);",
          "32: void *xmalloc(size_t size) {",
          "33:   void *ptr;",
          "35:   ptr = malloc(size);",
          "36:   if (ptr == NULL) {",
          "37:     pr_err(\"out of memory, need %lu bytes\", (unsigned long) size);",
          "38:     exit(1);",
          "39:   }",
          "41:   return ptr;",
          "42: }",
          "44: void pr_info(const char *fmt, ...) {",
          "45:   va_list ap;",
          "46:   va_start(ap, fmt);",
          "47:   pr_do(stdout, \"info\", fmt, ap);",
          "48:   va_end(ap);",
          "49: }",
          "51: void pr_warn(const char *fmt, ...) {",
          "52:   va_list ap;",
          "53:   va_start(ap, fmt);",
          "54:   pr_do(stderr, \"warn\", fmt, ap);",
          "55:   va_end(ap);",
          "56: }",
          "58: void pr_err(const char *fmt, ...) {",
          "59:   va_list ap;",
          "60:   va_start(ap, fmt);",
          "61:   pr_do(stderr, \"error\", fmt, ap);",
          "62:   va_end(ap);",
          "63: }",
          "65: static void pr_do(FILE *stream,",
          "66:                   const char *label,",
          "67:                   const char *fmt,",
          "68:                   va_list ap) {",
          "69:   char fmtbuf[1024];",
          "70:   vsnprintf(fmtbuf, sizeof(fmtbuf), fmt, ap);",
          "71:   fprintf(stream, \"%s:%s: %s\\n\", _getprogname(), label, fmtbuf);",
          "72: }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "d3308c25b90ffd3449482e6fe4d5ae0091a336f0",
      "candidate_info": {
        "commit_hash": "d3308c25b90ffd3449482e6fe4d5ae0091a336f0",
        "repo": "libuv/libuv",
        "commit_url": "https://github.com/libuv/libuv/commit/d3308c25b90ffd3449482e6fe4d5ae0091a336f0",
        "files": [
          "include/uv.h"
        ],
        "message": "include: update uv_udp_open() / uv_udp_bind() docs\n\nMention that:\n\n* these functions set the SO_REUSEADDR and SO_REUSEPORT socket flags,\n* what the effect of those flags is, and\n* that we may remove it someday",
        "before_after_code_files": [
          "include/uv.h||include/uv.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/libuv/libuv/pull/41"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "include/uv.h||include/uv.h": [
          "File: include/uv.h -> include/uv.h"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2007-6762",
  "cve_desc": "In the Linux kernel before 2.6.20, there is an off-by-one bug in net/netlabel/netlabel_cipso_v4.c where it is possible to overflow the doi_def->tags[] array.",
  "repo": "torvalds/linux",
  "patch_hash": "2a2f11c227bdf292b3a2900ad04139d301b56ac4",
  "patch_info": {
    "commit_hash": "2a2f11c227bdf292b3a2900ad04139d301b56ac4",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/2a2f11c227bdf292b3a2900ad04139d301b56ac4",
    "files": [
      "net/netlabel/netlabel_cipso_v4.c"
    ],
    "message": "NetLabel: correct CIPSO tag handling when adding new DOI definitions\n\nThe current netlbl_cipsov4_add_common() function has two problems which are\nfixed with this patch.  The first is an off-by-one bug where it is possibile to\noverflow the doi_def->tags[] array.  The second is a bug where the same\ndoi_def->tags[] array was not always fully initialized, which caused sporadic\nfailures.\n\nSigned-off-by: Paul Moore <paul.moore@hp.com>\nSigned-off-by: James Morris <jmorris@namei.org>",
    "before_after_code_files": [
      "net/netlabel/netlabel_cipso_v4.c||net/netlabel/netlabel_cipso_v4.c"
    ]
  },
  "patch_diff": {
    "net/netlabel/netlabel_cipso_v4.c||net/netlabel/netlabel_cipso_v4.c": [
      "File: net/netlabel/netlabel_cipso_v4.c -> net/netlabel/netlabel_cipso_v4.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "131:  nla_for_each_nested(nla, info->attrs[NLBL_CIPSOV4_A_TAGLST], nla_rem)",
      "132:   if (nla->nla_type == NLBL_CIPSOV4_A_TAG) {",
      "134:     return -EINVAL;",
      "135:    doi_def->tags[iter++] = nla_get_u8(nla);",
      "136:   }",
      "140:  return 0;",
      "141: }",
      "",
      "[Removed Lines]",
      "133:    if (iter > CIPSO_V4_TAG_MAXCNT)",
      "137:  if (iter < CIPSO_V4_TAG_MAXCNT)",
      "138:   doi_def->tags[iter] = CIPSO_V4_TAG_INVALID;",
      "",
      "[Added Lines]",
      "133:    if (iter >= CIPSO_V4_TAG_MAXCNT)",
      "137:  while (iter < CIPSO_V4_TAG_MAXCNT)",
      "138:   doi_def->tags[iter++] = CIPSO_V4_TAG_INVALID;",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "fd3858554b62c3af6b7664b5c58ad864c87116c9",
      "candidate_info": {
        "commit_hash": "fd3858554b62c3af6b7664b5c58ad864c87116c9",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/fd3858554b62c3af6b7664b5c58ad864c87116c9",
        "files": [
          "net/netlabel/netlabel_cipso_v4.c",
          "net/netlabel/netlabel_cipso_v4.h",
          "net/netlabel/netlabel_mgmt.c",
          "net/netlabel/netlabel_mgmt.h",
          "net/netlabel/netlabel_unlabeled.c",
          "net/netlabel/netlabel_unlabeled.h"
        ],
        "message": "[NetLabel]: rework the Netlink attribute handling (part 2)\n\nAt the suggestion of Thomas Graf, rewrite NetLabel's use of Netlink attributes\nto better follow the common Netlink attribute usage.\n\nSigned-off-by: Paul Moore <paul.moore@hp.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "before_after_code_files": [
          "net/netlabel/netlabel_cipso_v4.c||net/netlabel/netlabel_cipso_v4.c",
          "net/netlabel/netlabel_cipso_v4.h||net/netlabel/netlabel_cipso_v4.h",
          "net/netlabel/netlabel_mgmt.c||net/netlabel/netlabel_mgmt.c",
          "net/netlabel/netlabel_mgmt.h||net/netlabel/netlabel_mgmt.h",
          "net/netlabel/netlabel_unlabeled.c||net/netlabel/netlabel_unlabeled.c",
          "net/netlabel/netlabel_unlabeled.h||net/netlabel/netlabel_unlabeled.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "net/netlabel/netlabel_cipso_v4.c||net/netlabel/netlabel_cipso_v4.c"
          ],
          "candidate": [
            "net/netlabel/netlabel_cipso_v4.c||net/netlabel/netlabel_cipso_v4.c"
          ]
        }
      },
      "candidate_diff": {
        "net/netlabel/netlabel_cipso_v4.c||net/netlabel/netlabel_cipso_v4.c": [
          "File: net/netlabel/netlabel_cipso_v4.c -> net/netlabel/netlabel_cipso_v4.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "41: #include \"netlabel_user.h\"",
          "42: #include \"netlabel_cipso_v4.h\"",
          "45: static struct genl_family netlbl_cipsov4_gnl_family = {",
          "46:  .id = GENL_ID_GENERATE,",
          "47:  .hdrsize = 0,",
          "48:  .name = NETLBL_NLTYPE_CIPSOV4_NAME,",
          "49:  .version = NETLBL_PROTO_VERSION,",
          "51: };",
          "",
          "[Removed Lines]",
          "50:  .maxattr = 0,",
          "",
          "[Added Lines]",
          "45: struct netlbl_cipsov4_doiwalk_arg {",
          "46:  struct netlink_callback *nl_cb;",
          "47:  struct sk_buff *skb;",
          "48:  u32 seq;",
          "49: };",
          "57:  .maxattr = NLBL_CIPSOV4_A_MAX,",
          "61: static struct nla_policy netlbl_cipsov4_genl_policy[NLBL_CIPSOV4_A_MAX + 1] = {",
          "62:  [NLBL_CIPSOV4_A_DOI] = { .type = NLA_U32 },",
          "63:  [NLBL_CIPSOV4_A_MTYPE] = { .type = NLA_U32 },",
          "64:  [NLBL_CIPSOV4_A_TAG] = { .type = NLA_U8 },",
          "65:  [NLBL_CIPSOV4_A_TAGLST] = { .type = NLA_NESTED },",
          "66:  [NLBL_CIPSOV4_A_MLSLVLLOC] = { .type = NLA_U32 },",
          "67:  [NLBL_CIPSOV4_A_MLSLVLREM] = { .type = NLA_U32 },",
          "68:  [NLBL_CIPSOV4_A_MLSLVL] = { .type = NLA_NESTED },",
          "69:  [NLBL_CIPSOV4_A_MLSLVLLST] = { .type = NLA_NESTED },",
          "70:  [NLBL_CIPSOV4_A_MLSCATLOC] = { .type = NLA_U32 },",
          "71:  [NLBL_CIPSOV4_A_MLSCATREM] = { .type = NLA_U32 },",
          "72:  [NLBL_CIPSOV4_A_MLSCAT] = { .type = NLA_NESTED },",
          "73:  [NLBL_CIPSOV4_A_MLSCATLST] = { .type = NLA_NESTED },",
          "74: };",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "81:  kfree(ptr);",
          "82: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "116: static int netlbl_cipsov4_add_common(struct genl_info *info,",
          "117:          struct cipso_v4_doi *doi_def)",
          "118: {",
          "119:  struct nlattr *nla;",
          "120:  int nla_rem;",
          "121:  u32 iter = 0;",
          "123:  doi_def->doi = nla_get_u32(info->attrs[NLBL_CIPSOV4_A_DOI]);",
          "125:  if (nla_validate_nested(info->attrs[NLBL_CIPSOV4_A_TAGLST],",
          "126:     NLBL_CIPSOV4_A_MAX,",
          "127:     netlbl_cipsov4_genl_policy) != 0)",
          "128:   return -EINVAL;",
          "130:  nla_for_each_nested(nla, info->attrs[NLBL_CIPSOV4_A_TAGLST], nla_rem)",
          "131:   if (nla->nla_type == NLBL_CIPSOV4_A_TAG) {",
          "132:    if (iter > CIPSO_V4_TAG_MAXCNT)",
          "133:     return -EINVAL;",
          "134:    doi_def->tags[iter++] = nla_get_u8(nla);",
          "135:   }",
          "136:  if (iter < CIPSO_V4_TAG_MAXCNT)",
          "137:   doi_def->tags[iter] = CIPSO_V4_TAG_INVALID;",
          "139:  return 0;",
          "140: }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "102: {",
          "103:  int ret_val = -EINVAL;",
          "108:  struct cipso_v4_doi *doi_def = NULL;",
          "119:  doi_def = kmalloc(sizeof(*doi_def), GFP_KERNEL);",
          "124:  doi_def->map.std = kzalloc(sizeof(*doi_def->map.std), GFP_KERNEL);",
          "125:  if (doi_def->map.std == NULL) {",
          "126:   ret_val = -ENOMEM;",
          "",
          "[Removed Lines]",
          "101: static int netlbl_cipsov4_add_std(u32 doi, struct nlattr *msg, size_t msg_size)",
          "104:  int msg_len = msg_size;",
          "105:  u32 num_tags;",
          "106:  u32 num_lvls;",
          "107:  u32 num_cats;",
          "109:  u32 iter;",
          "110:  u32 tmp_val_a;",
          "111:  u32 tmp_val_b;",
          "113:  if (msg_len < NETLBL_LEN_U32)",
          "114:   goto add_std_failure;",
          "115:  num_tags = netlbl_getinc_u32(&msg, &msg_len);",
          "116:  if (num_tags == 0 || num_tags > CIPSO_V4_TAG_MAXCNT)",
          "117:   goto add_std_failure;",
          "120:  if (doi_def == NULL) {",
          "121:   ret_val = -ENOMEM;",
          "122:   goto add_std_failure;",
          "123:  }",
          "",
          "[Added Lines]",
          "156: static int netlbl_cipsov4_add_std(struct genl_info *info)",
          "160:  struct nlattr *nla_a;",
          "161:  struct nlattr *nla_b;",
          "162:  int nla_a_rem;",
          "163:  int nla_b_rem;",
          "165:  if (!info->attrs[NLBL_CIPSOV4_A_DOI] ||",
          "166:      !info->attrs[NLBL_CIPSOV4_A_TAGLST] ||",
          "167:      !info->attrs[NLBL_CIPSOV4_A_MLSLVLLST])",
          "168:   return -EINVAL;",
          "170:  if (nla_validate_nested(info->attrs[NLBL_CIPSOV4_A_MLSLVLLST],",
          "171:     NLBL_CIPSOV4_A_MAX,",
          "172:     netlbl_cipsov4_genl_policy) != 0)",
          "173:   return -EINVAL;",
          "176:  if (doi_def == NULL)",
          "177:   return -ENOMEM;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "128:  }",
          "129:  doi_def->type = CIPSO_V4_MAP_STD;",
          "146:   goto add_std_failure;",
          "153:   goto add_std_failure;",
          "154:  doi_def->map.std->lvl.local = kcalloc(doi_def->map.std->lvl.local_size,",
          "155:            sizeof(u32),",
          "",
          "[Removed Lines]",
          "131:  for (iter = 0; iter < num_tags; iter++) {",
          "132:   if (msg_len < NETLBL_LEN_U8)",
          "133:    goto add_std_failure;",
          "134:   doi_def->tags[iter] = netlbl_getinc_u8(&msg, &msg_len);",
          "135:   switch (doi_def->tags[iter]) {",
          "136:   case CIPSO_V4_TAG_RBITMAP:",
          "137:    break;",
          "138:   default:",
          "139:    goto add_std_failure;",
          "140:   }",
          "141:  }",
          "142:  if (iter < CIPSO_V4_TAG_MAXCNT)",
          "143:   doi_def->tags[iter] = CIPSO_V4_TAG_INVALID;",
          "145:  if (msg_len < 6 * NETLBL_LEN_U32)",
          "148:  num_lvls = netlbl_getinc_u32(&msg, &msg_len);",
          "149:  if (num_lvls == 0)",
          "150:   goto add_std_failure;",
          "151:  doi_def->map.std->lvl.local_size = netlbl_getinc_u32(&msg, &msg_len);",
          "152:  if (doi_def->map.std->lvl.local_size > CIPSO_V4_MAX_LOC_LVLS)",
          "",
          "[Added Lines]",
          "185:  ret_val = netlbl_cipsov4_add_common(info, doi_def);",
          "186:  if (ret_val != 0)",
          "189:  nla_for_each_nested(nla_a,",
          "190:        info->attrs[NLBL_CIPSOV4_A_MLSLVLLST],",
          "191:        nla_a_rem)",
          "192:   if (nla_a->nla_type == NLBL_CIPSOV4_A_MLSLVL) {",
          "193:    nla_for_each_nested(nla_b, nla_a, nla_b_rem)",
          "194:     switch (nla_b->nla_type) {",
          "195:     case NLBL_CIPSOV4_A_MLSLVLLOC:",
          "196:      if (nla_get_u32(nla_b) >=",
          "197:          doi_def->map.std->lvl.local_size)",
          "198:           doi_def->map.std->lvl.local_size =",
          "199:            nla_get_u32(nla_b) + 1;",
          "200:      break;",
          "201:     case NLBL_CIPSOV4_A_MLSLVLREM:",
          "202:      if (nla_get_u32(nla_b) >=",
          "203:          doi_def->map.std->lvl.cipso_size)",
          "204:           doi_def->map.std->lvl.cipso_size =",
          "205:            nla_get_u32(nla_b) + 1;",
          "206:      break;",
          "207:     }",
          "208:   }",
          "209:  if (doi_def->map.std->lvl.local_size > CIPSO_V4_MAX_LOC_LVLS ||",
          "210:      doi_def->map.std->lvl.cipso_size > CIPSO_V4_MAX_REM_LVLS)",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "158:   ret_val = -ENOMEM;",
          "159:   goto add_std_failure;",
          "160:  }",
          "164:  doi_def->map.std->lvl.cipso = kcalloc(doi_def->map.std->lvl.cipso_size,",
          "165:            sizeof(u32),",
          "166:            GFP_KERNEL);",
          "",
          "[Removed Lines]",
          "161:  doi_def->map.std->lvl.cipso_size = netlbl_getinc_u8(&msg, &msg_len);",
          "162:  if (doi_def->map.std->lvl.cipso_size > CIPSO_V4_MAX_REM_LVLS)",
          "163:   goto add_std_failure;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "168:   ret_val = -ENOMEM;",
          "169:   goto add_std_failure;",
          "170:  }",
          "177:            sizeof(u32),",
          "178:            GFP_KERNEL);",
          "187:            sizeof(u32),",
          "188:            GFP_KERNEL);",
          "226:    goto add_std_failure;",
          "230:  }",
          "233:  ret_val = cipso_v4_doi_add(doi_def);",
          "234:  if (ret_val != 0)",
          "235:   goto add_std_failure;",
          "",
          "[Removed Lines]",
          "172:  num_cats = netlbl_getinc_u32(&msg, &msg_len);",
          "173:  doi_def->map.std->cat.local_size = netlbl_getinc_u32(&msg, &msg_len);",
          "174:  if (doi_def->map.std->cat.local_size > CIPSO_V4_MAX_LOC_CATS)",
          "175:   goto add_std_failure;",
          "176:  doi_def->map.std->cat.local = kcalloc(doi_def->map.std->cat.local_size,",
          "179:  if (doi_def->map.std->cat.local == NULL) {",
          "180:   ret_val = -ENOMEM;",
          "181:   goto add_std_failure;",
          "182:  }",
          "183:  doi_def->map.std->cat.cipso_size = netlbl_getinc_u16(&msg, &msg_len);",
          "184:  if (doi_def->map.std->cat.cipso_size > CIPSO_V4_MAX_REM_CATS)",
          "185:   goto add_std_failure;",
          "186:  doi_def->map.std->cat.cipso = kcalloc(doi_def->map.std->cat.cipso_size,",
          "189:  if (doi_def->map.std->cat.cipso == NULL) {",
          "190:   ret_val = -ENOMEM;",
          "191:   goto add_std_failure;",
          "192:  }",
          "194:  if (msg_len <",
          "195:      num_lvls * (NETLBL_LEN_U32 + NETLBL_LEN_U8) +",
          "196:      num_cats * (NETLBL_LEN_U32 + NETLBL_LEN_U16))",
          "197:   goto add_std_failure;",
          "199:  for (iter = 0; iter < doi_def->map.std->lvl.cipso_size; iter++)",
          "200:   doi_def->map.std->lvl.cipso[iter] = CIPSO_V4_INV_LVL;",
          "201:  for (iter = 0; iter < doi_def->map.std->lvl.local_size; iter++)",
          "202:   doi_def->map.std->lvl.local[iter] = CIPSO_V4_INV_LVL;",
          "203:  for (iter = 0; iter < doi_def->map.std->cat.cipso_size; iter++)",
          "204:   doi_def->map.std->cat.cipso[iter] = CIPSO_V4_INV_CAT;",
          "205:  for (iter = 0; iter < doi_def->map.std->cat.local_size; iter++)",
          "206:   doi_def->map.std->cat.local[iter] = CIPSO_V4_INV_CAT;",
          "208:  for (iter = 0; iter < num_lvls; iter++) {",
          "209:   tmp_val_a = netlbl_getinc_u32(&msg, &msg_len);",
          "210:   tmp_val_b = netlbl_getinc_u8(&msg, &msg_len);",
          "212:   if (tmp_val_a >= doi_def->map.std->lvl.local_size ||",
          "213:       tmp_val_b >= doi_def->map.std->lvl.cipso_size)",
          "214:    goto add_std_failure;",
          "216:   doi_def->map.std->lvl.cipso[tmp_val_b] = tmp_val_a;",
          "217:   doi_def->map.std->lvl.local[tmp_val_a] = tmp_val_b;",
          "218:  }",
          "220:  for (iter = 0; iter < num_cats; iter++) {",
          "221:   tmp_val_a = netlbl_getinc_u32(&msg, &msg_len);",
          "222:   tmp_val_b = netlbl_getinc_u16(&msg, &msg_len);",
          "224:   if (tmp_val_a >= doi_def->map.std->cat.local_size ||",
          "225:       tmp_val_b >= doi_def->map.std->cat.cipso_size)",
          "228:   doi_def->map.std->cat.cipso[tmp_val_b] = tmp_val_a;",
          "229:   doi_def->map.std->cat.local[tmp_val_a] = tmp_val_b;",
          "232:  doi_def->doi = doi;",
          "",
          "[Added Lines]",
          "226:  nla_for_each_nested(nla_a,",
          "227:        info->attrs[NLBL_CIPSOV4_A_MLSLVLLST],",
          "228:        nla_a_rem)",
          "229:   if (nla_a->nla_type == NLBL_CIPSOV4_A_MLSLVL) {",
          "230:    struct nlattr *lvl_loc;",
          "231:    struct nlattr *lvl_rem;",
          "233:    if (nla_validate_nested(nla_a,",
          "234:            NLBL_CIPSOV4_A_MAX,",
          "235:            netlbl_cipsov4_genl_policy) != 0)",
          "236:     goto add_std_failure;",
          "238:    lvl_loc = nla_find_nested(nla_a,",
          "239:         NLBL_CIPSOV4_A_MLSLVLLOC);",
          "240:    lvl_rem = nla_find_nested(nla_a,",
          "241:         NLBL_CIPSOV4_A_MLSLVLREM);",
          "242:    if (lvl_loc == NULL || lvl_rem == NULL)",
          "243:     goto add_std_failure;",
          "244:    doi_def->map.std->lvl.local[nla_get_u32(lvl_loc)] =",
          "245:     nla_get_u32(lvl_rem);",
          "246:    doi_def->map.std->lvl.cipso[nla_get_u32(lvl_rem)] =",
          "247:     nla_get_u32(lvl_loc);",
          "248:   }",
          "250:  if (info->attrs[NLBL_CIPSOV4_A_MLSCATLST]) {",
          "251:   if (nla_validate_nested(info->attrs[NLBL_CIPSOV4_A_MLSCATLST],",
          "252:      NLBL_CIPSOV4_A_MAX,",
          "253:      netlbl_cipsov4_genl_policy) != 0)",
          "254:    goto add_std_failure;",
          "256:   nla_for_each_nested(nla_a,",
          "257:         info->attrs[NLBL_CIPSOV4_A_MLSCATLST],",
          "258:         nla_a_rem)",
          "259:    if (nla_a->nla_type == NLBL_CIPSOV4_A_MLSCAT) {",
          "260:     if (nla_validate_nested(nla_a,",
          "261:            NLBL_CIPSOV4_A_MAX,",
          "262:            netlbl_cipsov4_genl_policy) != 0)",
          "263:      goto add_std_failure;",
          "264:     nla_for_each_nested(nla_b, nla_a, nla_b_rem)",
          "265:      switch (nla_b->nla_type) {",
          "266:      case NLBL_CIPSOV4_A_MLSCATLOC:",
          "267:       if (nla_get_u32(nla_b) >=",
          "268:            doi_def->map.std->cat.local_size)",
          "269:           doi_def->map.std->cat.local_size =",
          "270:            nla_get_u32(nla_b) + 1;",
          "271:       break;",
          "272:      case NLBL_CIPSOV4_A_MLSCATREM:",
          "273:       if (nla_get_u32(nla_b) >=",
          "274:            doi_def->map.std->cat.cipso_size)",
          "275:           doi_def->map.std->cat.cipso_size =",
          "276:            nla_get_u32(nla_b) + 1;",
          "277:       break;",
          "278:      }",
          "279:    }",
          "280:   if (doi_def->map.std->cat.local_size > CIPSO_V4_MAX_LOC_CATS ||",
          "281:       doi_def->map.std->cat.cipso_size > CIPSO_V4_MAX_REM_CATS)",
          "282:    goto add_std_failure;",
          "283:   doi_def->map.std->cat.local = kcalloc(",
          "284:                          doi_def->map.std->cat.local_size,",
          "287:   if (doi_def->map.std->cat.local == NULL) {",
          "288:    ret_val = -ENOMEM;",
          "289:    goto add_std_failure;",
          "290:   }",
          "291:   doi_def->map.std->cat.cipso = kcalloc(",
          "292:                          doi_def->map.std->cat.cipso_size,",
          "295:   if (doi_def->map.std->cat.cipso == NULL) {",
          "296:    ret_val = -ENOMEM;",
          "298:   }",
          "299:   nla_for_each_nested(nla_a,",
          "300:         info->attrs[NLBL_CIPSOV4_A_MLSCATLST],",
          "301:         nla_a_rem)",
          "302:    if (nla_a->nla_type == NLBL_CIPSOV4_A_MLSCAT) {",
          "303:     struct nlattr *cat_loc;",
          "304:     struct nlattr *cat_rem;",
          "306:     cat_loc = nla_find_nested(nla_a,",
          "307:            NLBL_CIPSOV4_A_MLSCATLOC);",
          "308:     cat_rem = nla_find_nested(nla_a,",
          "309:            NLBL_CIPSOV4_A_MLSCATREM);",
          "310:     if (cat_loc == NULL || cat_rem == NULL)",
          "311:      goto add_std_failure;",
          "312:     doi_def->map.std->cat.local[",
          "313:                             nla_get_u32(cat_loc)] =",
          "314:      nla_get_u32(cat_rem);",
          "315:     doi_def->map.std->cat.cipso[",
          "316:                      nla_get_u32(cat_rem)] =",
          "317:      nla_get_u32(cat_loc);",
          "318:    }",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "259: {",
          "263:  struct cipso_v4_doi *doi_def = NULL;",
          "272:  doi_def = kmalloc(sizeof(*doi_def), GFP_KERNEL);",
          "277:  doi_def->type = CIPSO_V4_MAP_PASS;",
          "294:  ret_val = cipso_v4_doi_add(doi_def);",
          "295:  if (ret_val != 0)",
          "296:   goto add_pass_failure;",
          "297:  return 0;",
          "299: add_pass_failure:",
          "302:  return ret_val;",
          "303: }",
          "",
          "[Removed Lines]",
          "256: static int netlbl_cipsov4_add_pass(u32 doi,",
          "257:        struct nlattr *msg,",
          "258:        size_t msg_size)",
          "260:  int ret_val = -EINVAL;",
          "261:  int msg_len = msg_size;",
          "262:  u32 num_tags;",
          "264:  u32 iter;",
          "266:  if (msg_len < NETLBL_LEN_U32)",
          "267:   goto add_pass_failure;",
          "268:  num_tags = netlbl_getinc_u32(&msg, &msg_len);",
          "269:  if (num_tags == 0 || num_tags > CIPSO_V4_TAG_MAXCNT)",
          "270:   goto add_pass_failure;",
          "273:  if (doi_def == NULL) {",
          "274:   ret_val = -ENOMEM;",
          "275:   goto add_pass_failure;",
          "276:  }",
          "279:  for (iter = 0; iter < num_tags; iter++) {",
          "280:   if (msg_len < NETLBL_LEN_U8)",
          "281:    goto add_pass_failure;",
          "282:   doi_def->tags[iter] = netlbl_getinc_u8(&msg, &msg_len);",
          "283:   switch (doi_def->tags[iter]) {",
          "284:   case CIPSO_V4_TAG_RBITMAP:",
          "285:    break;",
          "286:   default:",
          "287:    goto add_pass_failure;",
          "288:   }",
          "289:  }",
          "290:  if (iter < CIPSO_V4_TAG_MAXCNT)",
          "291:   doi_def->tags[iter] = CIPSO_V4_TAG_INVALID;",
          "293:  doi_def->doi = doi;",
          "300:  if (doi_def)",
          "301:   netlbl_cipsov4_doi_free(&doi_def->rcu);",
          "",
          "[Added Lines]",
          "342: static int netlbl_cipsov4_add_pass(struct genl_info *info)",
          "344:  int ret_val;",
          "347:  if (!info->attrs[NLBL_CIPSOV4_A_DOI] ||",
          "348:      !info->attrs[NLBL_CIPSOV4_A_TAGLST])",
          "349:   return -EINVAL;",
          "352:  if (doi_def == NULL)",
          "353:   return -ENOMEM;",
          "356:  ret_val = netlbl_cipsov4_add_common(info, doi_def);",
          "357:  if (ret_val != 0)",
          "358:   goto add_pass_failure;",
          "366:  netlbl_cipsov4_doi_free(&doi_def->rcu);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "317: {",
          "318:  int ret_val = -EINVAL;",
          "320:  u32 map_type;",
          "333:  switch (map_type) {",
          "334:  case CIPSO_V4_MAP_STD:",
          "336:   break;",
          "337:  case CIPSO_V4_MAP_PASS:",
          "339:   break;",
          "340:  }",
          "347:  return ret_val;",
          "348: }",
          "",
          "[Removed Lines]",
          "319:  u32 doi;",
          "321:  int msg_len = netlbl_netlink_payload_len(skb);",
          "322:  struct nlattr *msg = netlbl_netlink_payload_data(skb);",
          "324:  ret_val = netlbl_netlink_cap_check(skb, CAP_NET_ADMIN);",
          "325:  if (ret_val != 0)",
          "326:   goto add_return;",
          "328:  if (msg_len < 2 * NETLBL_LEN_U32)",
          "329:   goto add_return;",
          "331:  doi = netlbl_getinc_u32(&msg, &msg_len);",
          "332:  map_type = netlbl_getinc_u32(&msg, &msg_len);",
          "335:   ret_val = netlbl_cipsov4_add_std(doi, msg, msg_len);",
          "338:   ret_val = netlbl_cipsov4_add_pass(doi, msg, msg_len);",
          "342: add_return:",
          "343:  netlbl_netlink_send_ack(info,",
          "344:     netlbl_cipsov4_gnl_family.id,",
          "345:     NLBL_CIPSOV4_C_ACK,",
          "346:     -ret_val);",
          "",
          "[Added Lines]",
          "386:  if (!info->attrs[NLBL_CIPSOV4_A_MTYPE])",
          "387:   return -EINVAL;",
          "389:  map_type = nla_get_u32(info->attrs[NLBL_CIPSOV4_A_MTYPE]);",
          "392:   ret_val = netlbl_cipsov4_add_std(info);",
          "395:   ret_val = netlbl_cipsov4_add_pass(info);",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "360: static int netlbl_cipsov4_list(struct sk_buff *skb, struct genl_info *info)",
          "361: {",
          "363:  u32 doi;",
          "368:   goto list_failure;",
          "372:  if (ans_skb == NULL) {",
          "373:   ret_val = -ENOMEM;",
          "374:   goto list_failure;",
          "375:  }",
          "383:  if (ret_val != 0)",
          "384:   goto list_failure;",
          "386:  return 0;",
          "388: list_failure:",
          "393:  return ret_val;",
          "394: }",
          "407: {",
          "434: }",
          "",
          "[Removed Lines]",
          "362:  int ret_val = -EINVAL;",
          "364:  struct nlattr *msg = netlbl_netlink_payload_data(skb);",
          "365:  struct sk_buff *ans_skb;",
          "367:  if (netlbl_netlink_payload_len(skb) != NETLBL_LEN_U32)",
          "370:  doi = nla_get_u32(msg);",
          "371:  ans_skb = cipso_v4_doi_dump(doi, NLMSG_SPACE(GENL_HDRLEN));",
          "376:  netlbl_netlink_hdr_push(ans_skb,",
          "377:     info->snd_pid,",
          "378:     0,",
          "379:     netlbl_cipsov4_gnl_family.id,",
          "380:     NLBL_CIPSOV4_C_LIST);",
          "382:  ret_val = netlbl_netlink_snd(ans_skb, info->snd_pid);",
          "389:  netlbl_netlink_send_ack(info,",
          "390:     netlbl_cipsov4_gnl_family.id,",
          "391:     NLBL_CIPSOV4_C_ACK,",
          "392:     -ret_val);",
          "406: static int netlbl_cipsov4_listall(struct sk_buff *skb, struct genl_info *info)",
          "408:  int ret_val = -EINVAL;",
          "409:  struct sk_buff *ans_skb;",
          "411:  ans_skb = cipso_v4_doi_dump_all(NLMSG_SPACE(GENL_HDRLEN));",
          "412:  if (ans_skb == NULL) {",
          "413:   ret_val = -ENOMEM;",
          "414:   goto listall_failure;",
          "415:  }",
          "416:  netlbl_netlink_hdr_push(ans_skb,",
          "417:     info->snd_pid,",
          "418:     0,",
          "419:     netlbl_cipsov4_gnl_family.id,",
          "420:     NLBL_CIPSOV4_C_LISTALL);",
          "422:  ret_val = netlbl_netlink_snd(ans_skb, info->snd_pid);",
          "423:  if (ret_val != 0)",
          "424:   goto listall_failure;",
          "426:  return 0;",
          "428: listall_failure:",
          "429:  netlbl_netlink_send_ack(info,",
          "430:     netlbl_cipsov4_gnl_family.id,",
          "431:     NLBL_CIPSOV4_C_ACK,",
          "432:     -ret_val);",
          "433:  return ret_val;",
          "",
          "[Added Lines]",
          "421:  int ret_val;",
          "422:  struct sk_buff *ans_skb = NULL;",
          "423:  u32 nlsze_mult = 1;",
          "424:  void *data;",
          "426:  struct nlattr *nla_a;",
          "427:  struct nlattr *nla_b;",
          "428:  struct cipso_v4_doi *doi_def;",
          "429:  u32 iter;",
          "431:  if (!info->attrs[NLBL_CIPSOV4_A_DOI]) {",
          "432:   ret_val = -EINVAL;",
          "434:  }",
          "436: list_start:",
          "437:  ans_skb = nlmsg_new(NLMSG_GOODSIZE * nlsze_mult, GFP_KERNEL);",
          "442:  data = netlbl_netlink_hdr_put(ans_skb,",
          "443:           info->snd_pid,",
          "444:           info->snd_seq,",
          "445:           netlbl_cipsov4_gnl_family.id,",
          "446:           0,",
          "447:           NLBL_CIPSOV4_C_LIST);",
          "448:  if (data == NULL) {",
          "449:   ret_val = -ENOMEM;",
          "450:   goto list_failure;",
          "451:  }",
          "453:  doi = nla_get_u32(info->attrs[NLBL_CIPSOV4_A_DOI]);",
          "455:  rcu_read_lock();",
          "456:  doi_def = cipso_v4_doi_getdef(doi);",
          "457:  if (doi_def == NULL) {",
          "458:   ret_val = -EINVAL;",
          "459:   goto list_failure;",
          "460:  }",
          "462:  ret_val = nla_put_u32(ans_skb, NLBL_CIPSOV4_A_MTYPE, doi_def->type);",
          "463:  if (ret_val != 0)",
          "464:   goto list_failure_lock;",
          "466:  nla_a = nla_nest_start(ans_skb, NLBL_CIPSOV4_A_TAGLST);",
          "467:  if (nla_a == NULL) {",
          "468:   ret_val = -ENOMEM;",
          "469:   goto list_failure_lock;",
          "470:  }",
          "471:  for (iter = 0;",
          "472:       iter < CIPSO_V4_TAG_MAXCNT &&",
          "473:         doi_def->tags[iter] != CIPSO_V4_TAG_INVALID;",
          "474:       iter++) {",
          "475:   ret_val = nla_put_u8(ans_skb,",
          "476:          NLBL_CIPSOV4_A_TAG,",
          "477:          doi_def->tags[iter]);",
          "478:   if (ret_val != 0)",
          "479:    goto list_failure_lock;",
          "480:  }",
          "481:  nla_nest_end(ans_skb, nla_a);",
          "483:  switch (doi_def->type) {",
          "484:  case CIPSO_V4_MAP_STD:",
          "485:   nla_a = nla_nest_start(ans_skb, NLBL_CIPSOV4_A_MLSLVLLST);",
          "486:   if (nla_a == NULL) {",
          "487:    ret_val = -ENOMEM;",
          "488:    goto list_failure_lock;",
          "489:   }",
          "490:   for (iter = 0;",
          "491:        iter < doi_def->map.std->lvl.local_size;",
          "492:        iter++) {",
          "493:    if (doi_def->map.std->lvl.local[iter] ==",
          "494:        CIPSO_V4_INV_LVL)",
          "495:     continue;",
          "497:    nla_b = nla_nest_start(ans_skb, NLBL_CIPSOV4_A_MLSLVL);",
          "498:    if (nla_b == NULL) {",
          "499:     ret_val = -ENOMEM;",
          "500:     goto list_retry;",
          "501:    }",
          "502:    ret_val = nla_put_u32(ans_skb,",
          "503:            NLBL_CIPSOV4_A_MLSLVLLOC,",
          "504:            iter);",
          "505:    if (ret_val != 0)",
          "506:     goto list_retry;",
          "507:    ret_val = nla_put_u32(ans_skb,",
          "508:          NLBL_CIPSOV4_A_MLSLVLREM,",
          "509:          doi_def->map.std->lvl.local[iter]);",
          "510:    if (ret_val != 0)",
          "511:     goto list_retry;",
          "512:    nla_nest_end(ans_skb, nla_b);",
          "513:   }",
          "514:   nla_nest_end(ans_skb, nla_a);",
          "516:   nla_a = nla_nest_start(ans_skb, NLBL_CIPSOV4_A_MLSCATLST);",
          "517:   if (nla_a == NULL) {",
          "518:    ret_val = -ENOMEM;",
          "519:    goto list_retry;",
          "520:   }",
          "521:   for (iter = 0;",
          "522:        iter < doi_def->map.std->cat.local_size;",
          "523:        iter++) {",
          "524:    if (doi_def->map.std->cat.local[iter] ==",
          "525:        CIPSO_V4_INV_CAT)",
          "526:     continue;",
          "528:    nla_b = nla_nest_start(ans_skb, NLBL_CIPSOV4_A_MLSCAT);",
          "529:    if (nla_b == NULL) {",
          "530:     ret_val = -ENOMEM;",
          "531:     goto list_retry;",
          "532:    }",
          "533:    ret_val = nla_put_u32(ans_skb,",
          "534:            NLBL_CIPSOV4_A_MLSCATLOC,",
          "535:            iter);",
          "536:    if (ret_val != 0)",
          "537:     goto list_retry;",
          "538:    ret_val = nla_put_u32(ans_skb,",
          "539:          NLBL_CIPSOV4_A_MLSCATREM,",
          "540:          doi_def->map.std->cat.local[iter]);",
          "541:    if (ret_val != 0)",
          "542:     goto list_retry;",
          "543:    nla_nest_end(ans_skb, nla_b);",
          "544:   }",
          "545:   nla_nest_end(ans_skb, nla_a);",
          "547:   break;",
          "548:  }",
          "549:  rcu_read_unlock();",
          "551:  genlmsg_end(ans_skb, data);",
          "553:  ret_val = genlmsg_unicast(ans_skb, info->snd_pid);",
          "559: list_retry:",
          "561:  if (nlsze_mult < 4) {",
          "562:   rcu_read_unlock();",
          "563:   kfree_skb(ans_skb);",
          "564:   nlsze_mult++;",
          "565:   goto list_start;",
          "566:  }",
          "567: list_failure_lock:",
          "568:  rcu_read_unlock();",
          "570:  kfree_skb(ans_skb);",
          "571:  return ret_val;",
          "572: }",
          "586: static int netlbl_cipsov4_listall_cb(struct cipso_v4_doi *doi_def, void *arg)",
          "587: {",
          "588:  int ret_val = -ENOMEM;",
          "589:  struct netlbl_cipsov4_doiwalk_arg *cb_arg = arg;",
          "590:  void *data;",
          "592:  data = netlbl_netlink_hdr_put(cb_arg->skb,",
          "593:           NETLINK_CB(cb_arg->nl_cb->skb).pid,",
          "594:           cb_arg->seq,",
          "595:           netlbl_cipsov4_gnl_family.id,",
          "596:           NLM_F_MULTI,",
          "597:           NLBL_CIPSOV4_C_LISTALL);",
          "598:  if (data == NULL)",
          "599:   goto listall_cb_failure;",
          "601:  ret_val = nla_put_u32(cb_arg->skb, NLBL_CIPSOV4_A_DOI, doi_def->doi);",
          "602:  if (ret_val != 0)",
          "603:   goto listall_cb_failure;",
          "604:  ret_val = nla_put_u32(cb_arg->skb,",
          "605:          NLBL_CIPSOV4_A_MTYPE,",
          "606:          doi_def->type);",
          "607:  if (ret_val != 0)",
          "608:   goto listall_cb_failure;",
          "610:  return genlmsg_end(cb_arg->skb, data);",
          "612: listall_cb_failure:",
          "613:  genlmsg_cancel(cb_arg->skb, data);",
          "627: static int netlbl_cipsov4_listall(struct sk_buff *skb,",
          "628:       struct netlink_callback *cb)",
          "630:  struct netlbl_cipsov4_doiwalk_arg cb_arg;",
          "631:  int doi_skip = cb->args[0];",
          "633:  cb_arg.nl_cb = cb;",
          "634:  cb_arg.skb = skb;",
          "635:  cb_arg.seq = cb->nlh->nlmsg_seq;",
          "637:  cipso_v4_doi_walk(&doi_skip, netlbl_cipsov4_listall_cb, &cb_arg);",
          "639:  cb->args[0] = doi_skip;",
          "640:  return skb->len;",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "446: static int netlbl_cipsov4_remove(struct sk_buff *skb, struct genl_info *info)",
          "447: {",
          "449:  u32 doi;",
          "459:  }",
          "469:  return ret_val;",
          "470: }",
          "",
          "[Removed Lines]",
          "448:  int ret_val;",
          "450:  struct nlattr *msg = netlbl_netlink_payload_data(skb);",
          "452:  ret_val = netlbl_netlink_cap_check(skb, CAP_NET_ADMIN);",
          "453:  if (ret_val != 0)",
          "454:   goto remove_return;",
          "456:  if (netlbl_netlink_payload_len(skb) != NETLBL_LEN_U32) {",
          "457:   ret_val = -EINVAL;",
          "458:   goto remove_return;",
          "461:  doi = nla_get_u32(msg);",
          "462:  ret_val = cipso_v4_doi_remove(doi, netlbl_cipsov4_doi_free);",
          "464: remove_return:",
          "465:  netlbl_netlink_send_ack(info,",
          "466:     netlbl_cipsov4_gnl_family.id,",
          "467:     NLBL_CIPSOV4_C_ACK,",
          "468:     -ret_val);",
          "",
          "[Added Lines]",
          "655:  int ret_val = -EINVAL;",
          "658:  if (info->attrs[NLBL_CIPSOV4_A_DOI]) {",
          "659:   doi = nla_get_u32(info->attrs[NLBL_CIPSOV4_A_DOI]);",
          "660:   ret_val = cipso_v4_doi_remove(doi, netlbl_cipsov4_doi_free);",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "476: static struct genl_ops netlbl_cipsov4_genl_c_add = {",
          "477:  .cmd = NLBL_CIPSOV4_C_ADD,",
          "479:  .doit = netlbl_cipsov4_add,",
          "480:  .dumpit = NULL,",
          "481: };",
          "483: static struct genl_ops netlbl_cipsov4_genl_c_remove = {",
          "484:  .cmd = NLBL_CIPSOV4_C_REMOVE,",
          "486:  .doit = netlbl_cipsov4_remove,",
          "487:  .dumpit = NULL,",
          "488: };",
          "",
          "[Removed Lines]",
          "478:  .flags = 0,",
          "485:  .flags = 0,",
          "",
          "[Added Lines]",
          "672:  .flags = GENL_ADMIN_PERM,",
          "673:  .policy = netlbl_cipsov4_genl_policy,",
          "680:  .flags = GENL_ADMIN_PERM,",
          "681:  .policy = netlbl_cipsov4_genl_policy,",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "490: static struct genl_ops netlbl_cipsov4_genl_c_list = {",
          "491:  .cmd = NLBL_CIPSOV4_C_LIST,",
          "492:  .flags = 0,",
          "493:  .doit = netlbl_cipsov4_list,",
          "494:  .dumpit = NULL,",
          "495: };",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "689:  .policy = netlbl_cipsov4_genl_policy,",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "497: static struct genl_ops netlbl_cipsov4_genl_c_listall = {",
          "498:  .cmd = NLBL_CIPSOV4_C_LISTALL,",
          "499:  .flags = 0,",
          "502: };",
          "",
          "[Removed Lines]",
          "500:  .doit = netlbl_cipsov4_listall,",
          "501:  .dumpit = NULL,",
          "",
          "[Added Lines]",
          "697:  .policy = netlbl_cipsov4_genl_policy,",
          "698:  .doit = NULL,",
          "699:  .dumpit = netlbl_cipsov4_listall,",
          "",
          "---------------"
        ],
        "net/netlabel/netlabel_cipso_v4.h||net/netlabel/netlabel_cipso_v4.h": [
          "File: net/netlabel/netlabel_cipso_v4.h -> net/netlabel/netlabel_cipso_v4.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "34: #include <net/netlabel.h>",
          "203: enum {",
          "204:  NLBL_CIPSOV4_C_UNSPEC,",
          "206:  NLBL_CIPSOV4_C_ADD,",
          "207:  NLBL_CIPSOV4_C_REMOVE,",
          "208:  NLBL_CIPSOV4_C_LIST,",
          "",
          "[Removed Lines]",
          "205:  NLBL_CIPSOV4_C_ACK,",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "211: };",
          "212: #define NLBL_CIPSOV4_C_MAX (__NLBL_CIPSOV4_C_MAX - 1)",
          "215: int netlbl_cipsov4_genl_init(void);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "111: enum {",
          "112:  NLBL_CIPSOV4_A_UNSPEC,",
          "113:  NLBL_CIPSOV4_A_DOI,",
          "116:  NLBL_CIPSOV4_A_MTYPE,",
          "120:  NLBL_CIPSOV4_A_TAG,",
          "124:  NLBL_CIPSOV4_A_TAGLST,",
          "129:  NLBL_CIPSOV4_A_MLSLVLLOC,",
          "132:  NLBL_CIPSOV4_A_MLSLVLREM,",
          "135:  NLBL_CIPSOV4_A_MLSLVL,",
          "140:  NLBL_CIPSOV4_A_MLSLVLLST,",
          "144:  NLBL_CIPSOV4_A_MLSCATLOC,",
          "147:  NLBL_CIPSOV4_A_MLSCATREM,",
          "150:  NLBL_CIPSOV4_A_MLSCAT,",
          "155:  NLBL_CIPSOV4_A_MLSCATLST,",
          "159:  __NLBL_CIPSOV4_A_MAX,",
          "160: };",
          "161: #define NLBL_CIPSOV4_A_MAX (__NLBL_CIPSOV4_A_MAX - 1)",
          "",
          "---------------"
        ],
        "net/netlabel/netlabel_mgmt.c||net/netlabel/netlabel_mgmt.c": [
          "File: net/netlabel/netlabel_mgmt.c -> net/netlabel/netlabel_mgmt.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "42: #include \"netlabel_user.h\"",
          "43: #include \"netlabel_mgmt.h\"",
          "46: static struct genl_family netlbl_mgmt_gnl_family = {",
          "47:  .id = GENL_ID_GENERATE,",
          "48:  .hdrsize = 0,",
          "49:  .name = NETLBL_NLTYPE_MGMT_NAME,",
          "50:  .version = NETLBL_PROTO_VERSION,",
          "52: };",
          "",
          "[Removed Lines]",
          "51:  .maxattr = 0,",
          "",
          "[Added Lines]",
          "46: struct netlbl_domhsh_walk_arg {",
          "47:  struct netlink_callback *nl_cb;",
          "48:  struct sk_buff *skb;",
          "49:  u32 seq;",
          "50: };",
          "58:  .maxattr = NLBL_MGMT_A_MAX,",
          "62: static struct nla_policy netlbl_mgmt_genl_policy[NLBL_MGMT_A_MAX + 1] = {",
          "63:  [NLBL_MGMT_A_DOMAIN] = { .type = NLA_NUL_STRING },",
          "64:  [NLBL_MGMT_A_PROTOCOL] = { .type = NLA_U32 },",
          "65:  [NLBL_MGMT_A_VERSION] = { .type = NLA_U32 },",
          "66:  [NLBL_MGMT_A_CV4DOI] = { .type = NLA_U32 },",
          "67: };",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "70: static int netlbl_mgmt_add(struct sk_buff *skb, struct genl_info *info)",
          "71: {",
          "72:  int ret_val = -EINVAL;",
          "76:  struct netlbl_dom_map *entry = NULL;",
          "78:  u32 tmp_val;",
          "83:   goto add_failure;",
          "86:   goto add_failure;",
          "107:    goto add_failure;",
          "141:    rcu_read_unlock();",
          "147:    goto add_failure;",
          "148:  }",
          "154:  return 0;",
          "156: add_failure:",
          "157:  if (entry)",
          "158:   kfree(entry->domain);",
          "159:  kfree(entry);",
          "164:  return ret_val;",
          "165: }",
          "",
          "[Removed Lines]",
          "73:  struct nlattr *msg_ptr = netlbl_netlink_payload_data(skb);",
          "74:  int msg_len = netlbl_netlink_payload_len(skb);",
          "75:  u32 count;",
          "77:  u32 iter;",
          "79:  int tmp_size;",
          "81:  ret_val = netlbl_netlink_cap_check(skb, CAP_NET_ADMIN);",
          "82:  if (ret_val != 0)",
          "85:  if (msg_len < NETLBL_LEN_U32)",
          "87:  count = netlbl_getinc_u32(&msg_ptr, &msg_len);",
          "89:  for (iter = 0; iter < count && msg_len > 0; iter++, entry = NULL) {",
          "90:   if (msg_len <= 0) {",
          "91:    ret_val = -EINVAL;",
          "92:    goto add_failure;",
          "93:   }",
          "94:   entry = kzalloc(sizeof(*entry), GFP_KERNEL);",
          "95:   if (entry == NULL) {",
          "96:    ret_val = -ENOMEM;",
          "97:    goto add_failure;",
          "98:   }",
          "99:   tmp_size = nla_len(msg_ptr);",
          "100:   if (tmp_size <= 0 || tmp_size > msg_len) {",
          "101:    ret_val = -EINVAL;",
          "102:    goto add_failure;",
          "103:   }",
          "104:   entry->domain = kmalloc(tmp_size, GFP_KERNEL);",
          "105:   if (entry->domain == NULL) {",
          "106:    ret_val = -ENOMEM;",
          "108:   }",
          "109:   nla_strlcpy(entry->domain, msg_ptr, tmp_size);",
          "110:   entry->domain[tmp_size - 1] = '\\0';",
          "111:   msg_ptr = nla_next(msg_ptr, &msg_len);",
          "113:   if (msg_len < NETLBL_LEN_U32) {",
          "114:    ret_val = -EINVAL;",
          "115:    goto add_failure;",
          "116:   }",
          "117:   tmp_val = netlbl_getinc_u32(&msg_ptr, &msg_len);",
          "118:   entry->type = tmp_val;",
          "119:   switch (tmp_val) {",
          "120:   case NETLBL_NLTYPE_UNLABELED:",
          "121:    ret_val = netlbl_domhsh_add(entry);",
          "122:    break;",
          "123:   case NETLBL_NLTYPE_CIPSOV4:",
          "124:    if (msg_len < NETLBL_LEN_U32) {",
          "125:     ret_val = -EINVAL;",
          "126:     goto add_failure;",
          "127:    }",
          "128:    tmp_val = netlbl_getinc_u32(&msg_ptr, &msg_len);",
          "133:    rcu_read_lock();",
          "134:    entry->type_def.cipsov4 = cipso_v4_doi_getdef(tmp_val);",
          "135:    if (entry->type_def.cipsov4 == NULL) {",
          "136:     rcu_read_unlock();",
          "137:     ret_val = -EINVAL;",
          "138:     goto add_failure;",
          "139:    }",
          "140:    ret_val = netlbl_domhsh_add(entry);",
          "142:    break;",
          "143:   default:",
          "144:    ret_val = -EINVAL;",
          "145:   }",
          "146:   if (ret_val != 0)",
          "150:  netlbl_netlink_send_ack(info,",
          "151:     netlbl_mgmt_gnl_family.id,",
          "152:     NLBL_MGMT_C_ACK,",
          "153:     NETLBL_E_OK);",
          "160:  netlbl_netlink_send_ack(info,",
          "161:     netlbl_mgmt_gnl_family.id,",
          "162:     NLBL_MGMT_C_ACK,",
          "163:     -ret_val);",
          "",
          "[Added Lines]",
          "88:  size_t tmp_size;",
          "91:  if (!info->attrs[NLBL_MGMT_A_DOMAIN] ||",
          "92:      !info->attrs[NLBL_MGMT_A_PROTOCOL])",
          "95:  entry = kzalloc(sizeof(*entry), GFP_KERNEL);",
          "96:  if (entry == NULL) {",
          "97:   ret_val = -ENOMEM;",
          "98:   goto add_failure;",
          "99:  }",
          "100:  tmp_size = nla_len(info->attrs[NLBL_MGMT_A_DOMAIN]);",
          "101:  entry->domain = kmalloc(tmp_size, GFP_KERNEL);",
          "102:  if (entry->domain == NULL) {",
          "103:   ret_val = -ENOMEM;",
          "105:  }",
          "106:  entry->type = nla_get_u32(info->attrs[NLBL_MGMT_A_PROTOCOL]);",
          "107:  nla_strlcpy(entry->domain, info->attrs[NLBL_MGMT_A_DOMAIN], tmp_size);",
          "109:  switch (entry->type) {",
          "110:  case NETLBL_NLTYPE_UNLABELED:",
          "111:   ret_val = netlbl_domhsh_add(entry);",
          "112:   break;",
          "113:  case NETLBL_NLTYPE_CIPSOV4:",
          "114:   if (!info->attrs[NLBL_MGMT_A_CV4DOI])",
          "117:   tmp_val = nla_get_u32(info->attrs[NLBL_MGMT_A_CV4DOI]);",
          "122:   rcu_read_lock();",
          "123:   entry->type_def.cipsov4 = cipso_v4_doi_getdef(tmp_val);",
          "124:   if (entry->type_def.cipsov4 == NULL) {",
          "127:   }",
          "128:   ret_val = netlbl_domhsh_add(entry);",
          "129:   rcu_read_unlock();",
          "130:   break;",
          "131:  default:",
          "132:   goto add_failure;",
          "134:  if (ret_val != 0)",
          "135:   goto add_failure;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "177: static int netlbl_mgmt_remove(struct sk_buff *skb, struct genl_info *info)",
          "178: {",
          "208:   if (ret_val != 0)",
          "211:  }",
          "220:  return ret_val;",
          "221: }",
          "235: {",
          "260: }",
          "",
          "[Removed Lines]",
          "179:  int ret_val = -EINVAL;",
          "180:  struct nlattr *msg_ptr = netlbl_netlink_payload_data(skb);",
          "181:  int msg_len = netlbl_netlink_payload_len(skb);",
          "182:  u32 count;",
          "183:  u32 iter;",
          "184:  int tmp_size;",
          "185:  unsigned char *domain;",
          "187:  ret_val = netlbl_netlink_cap_check(skb, CAP_NET_ADMIN);",
          "188:  if (ret_val != 0)",
          "189:   goto remove_return;",
          "191:  if (msg_len < NETLBL_LEN_U32)",
          "192:   goto remove_return;",
          "193:  count = netlbl_getinc_u32(&msg_ptr, &msg_len);",
          "195:  for (iter = 0; iter < count && msg_len > 0; iter++) {",
          "196:   if (msg_len <= 0) {",
          "197:    ret_val = -EINVAL;",
          "198:    goto remove_return;",
          "199:   }",
          "200:   tmp_size = nla_len(msg_ptr);",
          "201:   domain = nla_data(msg_ptr);",
          "202:   if (tmp_size <= 0 || tmp_size > msg_len ||",
          "203:       domain[tmp_size - 1] != '\\0') {",
          "204:    ret_val = -EINVAL;",
          "205:    goto remove_return;",
          "206:   }",
          "207:   ret_val = netlbl_domhsh_remove(domain);",
          "209:    goto remove_return;",
          "210:   msg_ptr = nla_next(msg_ptr, &msg_len);",
          "213:  ret_val = 0;",
          "215: remove_return:",
          "216:  netlbl_netlink_send_ack(info,",
          "217:     netlbl_mgmt_gnl_family.id,",
          "218:     NLBL_MGMT_C_ACK,",
          "219:     -ret_val);",
          "234: static int netlbl_mgmt_list(struct sk_buff *skb, struct genl_info *info)",
          "236:  int ret_val = -ENOMEM;",
          "237:  struct sk_buff *ans_skb;",
          "239:  ans_skb = netlbl_domhsh_dump(NLMSG_SPACE(GENL_HDRLEN));",
          "240:  if (ans_skb == NULL)",
          "241:   goto list_failure;",
          "242:  netlbl_netlink_hdr_push(ans_skb,",
          "243:     info->snd_pid,",
          "244:     0,",
          "245:     netlbl_mgmt_gnl_family.id,",
          "246:     NLBL_MGMT_C_LIST);",
          "248:  ret_val = netlbl_netlink_snd(ans_skb, info->snd_pid);",
          "249:  if (ret_val != 0)",
          "250:   goto list_failure;",
          "252:  return 0;",
          "254: list_failure:",
          "255:  netlbl_netlink_send_ack(info,",
          "256:     netlbl_mgmt_gnl_family.id,",
          "257:     NLBL_MGMT_C_ACK,",
          "258:     -ret_val);",
          "259:  return ret_val;",
          "",
          "[Added Lines]",
          "158:  char *domain;",
          "160:  if (!info->attrs[NLBL_MGMT_A_DOMAIN])",
          "161:   return -EINVAL;",
          "163:  domain = nla_data(info->attrs[NLBL_MGMT_A_DOMAIN]);",
          "164:  return netlbl_domhsh_remove(domain);",
          "165: }",
          "179: static int netlbl_mgmt_listall_cb(struct netlbl_dom_map *entry, void *arg)",
          "180: {",
          "181:  int ret_val = -ENOMEM;",
          "182:  struct netlbl_domhsh_walk_arg *cb_arg = arg;",
          "183:  void *data;",
          "185:  data = netlbl_netlink_hdr_put(cb_arg->skb,",
          "186:           NETLINK_CB(cb_arg->nl_cb->skb).pid,",
          "187:           cb_arg->seq,",
          "188:           netlbl_mgmt_gnl_family.id,",
          "189:           NLM_F_MULTI,",
          "190:           NLBL_MGMT_C_LISTALL);",
          "191:  if (data == NULL)",
          "192:   goto listall_cb_failure;",
          "194:  ret_val = nla_put_string(cb_arg->skb,",
          "195:      NLBL_MGMT_A_DOMAIN,",
          "196:      entry->domain);",
          "197:  if (ret_val != 0)",
          "198:   goto listall_cb_failure;",
          "199:  ret_val = nla_put_u32(cb_arg->skb, NLBL_MGMT_A_PROTOCOL, entry->type);",
          "200:  if (ret_val != 0)",
          "201:   goto listall_cb_failure;",
          "202:  switch (entry->type) {",
          "203:  case NETLBL_NLTYPE_CIPSOV4:",
          "204:   ret_val = nla_put_u32(cb_arg->skb,",
          "205:           NLBL_MGMT_A_CV4DOI,",
          "206:           entry->type_def.cipsov4->doi);",
          "208:    goto listall_cb_failure;",
          "209:   break;",
          "212:  cb_arg->seq++;",
          "213:  return genlmsg_end(cb_arg->skb, data);",
          "215: listall_cb_failure:",
          "216:  genlmsg_cancel(cb_arg->skb, data);",
          "231: static int netlbl_mgmt_listall(struct sk_buff *skb,",
          "232:           struct netlink_callback *cb)",
          "234:  struct netlbl_domhsh_walk_arg cb_arg;",
          "235:  u32 skip_bkt = cb->args[0];",
          "236:  u32 skip_chain = cb->args[1];",
          "238:  cb_arg.nl_cb = cb;",
          "239:  cb_arg.skb = skb;",
          "240:  cb_arg.seq = cb->nlh->nlmsg_seq;",
          "242:  netlbl_domhsh_walk(&skip_bkt,",
          "243:       &skip_chain,",
          "244:       netlbl_mgmt_listall_cb,",
          "245:       &cb_arg);",
          "247:  cb->args[0] = skip_bkt;",
          "248:  cb->args[1] = skip_chain;",
          "249:  return skb->len;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "272: static int netlbl_mgmt_adddef(struct sk_buff *skb, struct genl_info *info)",
          "273: {",
          "274:  int ret_val = -EINVAL;",
          "277:  struct netlbl_dom_map *entry = NULL;",
          "278:  u32 tmp_val;",
          "285:   goto adddef_failure;",
          "288:  entry = kzalloc(sizeof(*entry), GFP_KERNEL);",
          "289:  if (entry == NULL) {",
          "290:   ret_val = -ENOMEM;",
          "291:   goto adddef_failure;",
          "292:  }",
          "295:  switch (entry->type) {",
          "296:  case NETLBL_NLTYPE_UNLABELED:",
          "297:   ret_val = netlbl_domhsh_add_default(entry);",
          "298:   break;",
          "299:  case NETLBL_NLTYPE_CIPSOV4:",
          "302:    goto adddef_failure;",
          "309:   rcu_read_lock();",
          "310:   entry->type_def.cipsov4 = cipso_v4_doi_getdef(tmp_val);",
          "311:   if (entry->type_def.cipsov4 == NULL) {",
          "312:    rcu_read_unlock();",
          "314:    goto adddef_failure;",
          "315:   }",
          "316:   ret_val = netlbl_domhsh_add_default(entry);",
          "317:   rcu_read_unlock();",
          "318:   break;",
          "319:  default:",
          "321:  }",
          "322:  if (ret_val != 0)",
          "323:   goto adddef_failure;",
          "329:  return 0;",
          "331: adddef_failure:",
          "332:  kfree(entry);",
          "337:  return ret_val;",
          "338: }",
          "",
          "[Removed Lines]",
          "275:  struct nlattr *msg_ptr = netlbl_netlink_payload_data(skb);",
          "276:  int msg_len = netlbl_netlink_payload_len(skb);",
          "280:  ret_val = netlbl_netlink_cap_check(skb, CAP_NET_ADMIN);",
          "281:  if (ret_val != 0)",
          "282:   goto adddef_failure;",
          "284:  if (msg_len < NETLBL_LEN_U32)",
          "286:  tmp_val = netlbl_getinc_u32(&msg_ptr, &msg_len);",
          "294:  entry->type = tmp_val;",
          "300:   if (msg_len < NETLBL_LEN_U32) {",
          "301:    ret_val = -EINVAL;",
          "303:   }",
          "304:   tmp_val = netlbl_getinc_u32(&msg_ptr, &msg_len);",
          "313:    ret_val = -EINVAL;",
          "320:   ret_val = -EINVAL;",
          "325:  netlbl_netlink_send_ack(info,",
          "326:     netlbl_mgmt_gnl_family.id,",
          "327:     NLBL_MGMT_C_ACK,",
          "328:     NETLBL_E_OK);",
          "333:  netlbl_netlink_send_ack(info,",
          "334:     netlbl_mgmt_gnl_family.id,",
          "335:     NLBL_MGMT_C_ACK,",
          "336:     -ret_val);",
          "",
          "[Added Lines]",
          "268:  if (!info->attrs[NLBL_MGMT_A_PROTOCOL])",
          "276:  entry->type = nla_get_u32(info->attrs[NLBL_MGMT_A_PROTOCOL]);",
          "283:   if (!info->attrs[NLBL_MGMT_A_CV4DOI])",
          "286:   tmp_val = nla_get_u32(info->attrs[NLBL_MGMT_A_CV4DOI]);",
          "301:   goto adddef_failure;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "350: static int netlbl_mgmt_removedef(struct sk_buff *skb, struct genl_info *info)",
          "351: {",
          "366: }",
          "",
          "[Removed Lines]",
          "352:  int ret_val;",
          "354:  ret_val = netlbl_netlink_cap_check(skb, CAP_NET_ADMIN);",
          "355:  if (ret_val != 0)",
          "356:   goto removedef_return;",
          "358:  ret_val = netlbl_domhsh_remove_default();",
          "360: removedef_return:",
          "361:  netlbl_netlink_send_ack(info,",
          "362:     netlbl_mgmt_gnl_family.id,",
          "363:     NLBL_MGMT_C_ACK,",
          "364:     -ret_val);",
          "365:  return ret_val;",
          "",
          "[Added Lines]",
          "325:  return netlbl_domhsh_remove_default();",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "379: static int netlbl_mgmt_listdef(struct sk_buff *skb, struct genl_info *info)",
          "380: {",
          "381:  int ret_val = -ENOMEM;",
          "385:  if (ans_skb == NULL)",
          "386:   goto listdef_failure;",
          "394:  if (ret_val != 0)",
          "397:  return 0;",
          "399: listdef_failure:",
          "404:  return ret_val;",
          "405: }",
          "417: {",
          "418:  int ret_val = -ENOMEM;",
          "442:  if (ret_val != 0)",
          "460:  return ret_val;",
          "461: }",
          "",
          "[Removed Lines]",
          "382:  struct sk_buff *ans_skb;",
          "384:  ans_skb = netlbl_domhsh_dump_default(NLMSG_SPACE(GENL_HDRLEN));",
          "387:  netlbl_netlink_hdr_push(ans_skb,",
          "388:     info->snd_pid,",
          "389:     0,",
          "390:     netlbl_mgmt_gnl_family.id,",
          "391:     NLBL_MGMT_C_LISTDEF);",
          "393:  ret_val = netlbl_netlink_snd(ans_skb, info->snd_pid);",
          "395:   goto listdef_failure;",
          "400:  netlbl_netlink_send_ack(info,",
          "401:     netlbl_mgmt_gnl_family.id,",
          "402:     NLBL_MGMT_C_ACK,",
          "403:     -ret_val);",
          "416: static int netlbl_mgmt_modules(struct sk_buff *skb, struct genl_info *info)",
          "419:  size_t data_size;",
          "420:  u32 mod_count;",
          "421:  struct sk_buff *ans_skb = NULL;",
          "424:  mod_count = 2;",
          "426:  data_size = GENL_HDRLEN + NETLBL_LEN_U32 + mod_count * NETLBL_LEN_U32;",
          "427:  ans_skb = netlbl_netlink_alloc_skb(0, data_size, GFP_KERNEL);",
          "428:  if (ans_skb == NULL)",
          "429:   goto modules_failure;",
          "431:  if (netlbl_netlink_hdr_put(ans_skb,",
          "432:        info->snd_pid,",
          "433:        0,",
          "434:        netlbl_mgmt_gnl_family.id,",
          "435:        NLBL_MGMT_C_MODULES) == NULL)",
          "436:   goto modules_failure;",
          "438:  ret_val = nla_put_u32(ans_skb, NLA_U32, mod_count);",
          "439:  if (ret_val != 0)",
          "440:   goto modules_failure;",
          "441:  ret_val = nla_put_u32(ans_skb, NLA_U32, NETLBL_NLTYPE_UNLABELED);",
          "443:   goto modules_failure;",
          "444:  ret_val = nla_put_u32(ans_skb, NLA_U32, NETLBL_NLTYPE_CIPSOV4);",
          "445:  if (ret_val != 0)",
          "446:   goto modules_failure;",
          "448:  ret_val = netlbl_netlink_snd(ans_skb, info->snd_pid);",
          "449:  if (ret_val != 0)",
          "450:   goto modules_failure;",
          "452:  return 0;",
          "454: modules_failure:",
          "455:  kfree_skb(ans_skb);",
          "456:  netlbl_netlink_send_ack(info,",
          "457:     netlbl_mgmt_gnl_family.id,",
          "458:     NLBL_MGMT_C_ACK,",
          "459:     -ret_val);",
          "",
          "[Added Lines]",
          "342:  struct sk_buff *ans_skb = NULL;",
          "343:  void *data;",
          "344:  struct netlbl_dom_map *entry;",
          "346:  ans_skb = nlmsg_new(NLMSG_GOODSIZE, GFP_KERNEL);",
          "348:   return -ENOMEM;",
          "349:  data = netlbl_netlink_hdr_put(ans_skb,",
          "350:           info->snd_pid,",
          "351:           info->snd_seq,",
          "352:           netlbl_mgmt_gnl_family.id,",
          "353:           0,",
          "354:           NLBL_MGMT_C_LISTDEF);",
          "355:  if (data == NULL)",
          "358:  rcu_read_lock();",
          "359:  entry = netlbl_domhsh_getentry(NULL);",
          "360:  if (entry == NULL) {",
          "361:   ret_val = -ENOENT;",
          "362:   goto listdef_failure_lock;",
          "363:  }",
          "364:  ret_val = nla_put_u32(ans_skb, NLBL_MGMT_A_PROTOCOL, entry->type);",
          "366:   goto listdef_failure_lock;",
          "367:  switch (entry->type) {",
          "368:  case NETLBL_NLTYPE_CIPSOV4:",
          "369:   ret_val = nla_put_u32(ans_skb,",
          "370:           NLBL_MGMT_A_CV4DOI,",
          "371:           entry->type_def.cipsov4->doi);",
          "372:   if (ret_val != 0)",
          "373:    goto listdef_failure_lock;",
          "374:   break;",
          "375:  }",
          "376:  rcu_read_unlock();",
          "378:  genlmsg_end(ans_skb, data);",
          "380:  ret_val = genlmsg_unicast(ans_skb, info->snd_pid);",
          "381:  if (ret_val != 0)",
          "382:   goto listdef_failure;",
          "385: listdef_failure_lock:",
          "386:  rcu_read_unlock();",
          "388:  kfree_skb(ans_skb);",
          "405: static int netlbl_mgmt_protocols_cb(struct sk_buff *skb,",
          "406:         struct netlink_callback *cb,",
          "407:         u32 protocol)",
          "410:  void *data;",
          "412:  data = netlbl_netlink_hdr_put(skb,",
          "413:           NETLINK_CB(cb->skb).pid,",
          "414:           cb->nlh->nlmsg_seq,",
          "415:           netlbl_mgmt_gnl_family.id,",
          "416:           NLM_F_MULTI,",
          "417:           NLBL_MGMT_C_PROTOCOLS);",
          "418:  if (data == NULL)",
          "419:   goto protocols_cb_failure;",
          "421:  ret_val = nla_put_u32(skb, NLBL_MGMT_A_PROTOCOL, protocol);",
          "423:   goto protocols_cb_failure;",
          "425:  return genlmsg_end(skb, data);",
          "427: protocols_cb_failure:",
          "428:  genlmsg_cancel(skb, data);",
          "441: static int netlbl_mgmt_protocols(struct sk_buff *skb,",
          "442:      struct netlink_callback *cb)",
          "443: {",
          "444:  u32 protos_sent = cb->args[0];",
          "446:  if (protos_sent == 0) {",
          "447:   if (netlbl_mgmt_protocols_cb(skb,",
          "448:           cb,",
          "449:           NETLBL_NLTYPE_UNLABELED) < 0)",
          "450:    goto protocols_return;",
          "451:   protos_sent++;",
          "452:  }",
          "453:  if (protos_sent == 1) {",
          "454:   if (netlbl_mgmt_protocols_cb(skb,",
          "455:           cb,",
          "456:           NETLBL_NLTYPE_CIPSOV4) < 0)",
          "457:    goto protocols_return;",
          "458:   protos_sent++;",
          "459:  }",
          "461: protocols_return:",
          "462:  cb->args[0] = protos_sent;",
          "463:  return skb->len;",
          "464: }",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "474: {",
          "475:  int ret_val = -ENOMEM;",
          "476:  struct sk_buff *ans_skb = NULL;",
          "481:  if (ans_skb == NULL)",
          "488:   goto version_failure;",
          "491:  if (ret_val != 0)",
          "492:   goto version_failure;",
          "495:  if (ret_val != 0)",
          "496:   goto version_failure;",
          "498:  return 0;",
          "500: version_failure:",
          "501:  kfree_skb(ans_skb);",
          "506:  return ret_val;",
          "507: }",
          "",
          "[Removed Lines]",
          "478:  ans_skb = netlbl_netlink_alloc_skb(0,",
          "479:         GENL_HDRLEN + NETLBL_LEN_U32,",
          "480:         GFP_KERNEL);",
          "482:   goto version_failure;",
          "483:  if (netlbl_netlink_hdr_put(ans_skb,",
          "484:        info->snd_pid,",
          "485:        0,",
          "486:        netlbl_mgmt_gnl_family.id,",
          "487:        NLBL_MGMT_C_VERSION) == NULL)",
          "490:  ret_val = nla_put_u32(ans_skb, NLA_U32, NETLBL_PROTO_VERSION);",
          "494:  ret_val = netlbl_netlink_snd(ans_skb, info->snd_pid);",
          "502:  netlbl_netlink_send_ack(info,",
          "503:     netlbl_mgmt_gnl_family.id,",
          "504:     NLBL_MGMT_C_ACK,",
          "505:     -ret_val);",
          "",
          "[Added Lines]",
          "480:  void *data;",
          "482:  ans_skb = nlmsg_new(NLMSG_GOODSIZE, GFP_KERNEL);",
          "484:   return -ENOMEM;",
          "485:  data = netlbl_netlink_hdr_put(ans_skb,",
          "486:           info->snd_pid,",
          "487:           info->snd_seq,",
          "488:           netlbl_mgmt_gnl_family.id,",
          "489:           0,",
          "490:           NLBL_MGMT_C_VERSION);",
          "491:  if (data == NULL)",
          "494:  ret_val = nla_put_u32(ans_skb,",
          "495:          NLBL_MGMT_A_VERSION,",
          "496:          NETLBL_PROTO_VERSION);",
          "500:  genlmsg_end(ans_skb, data);",
          "502:  ret_val = genlmsg_unicast(ans_skb, info->snd_pid);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "514: static struct genl_ops netlbl_mgmt_genl_c_add = {",
          "515:  .cmd = NLBL_MGMT_C_ADD,",
          "517:  .doit = netlbl_mgmt_add,",
          "518:  .dumpit = NULL,",
          "519: };",
          "521: static struct genl_ops netlbl_mgmt_genl_c_remove = {",
          "522:  .cmd = NLBL_MGMT_C_REMOVE,",
          "524:  .doit = netlbl_mgmt_remove,",
          "525:  .dumpit = NULL,",
          "526: };",
          "530:  .flags = 0,",
          "533: };",
          "535: static struct genl_ops netlbl_mgmt_genl_c_adddef = {",
          "536:  .cmd = NLBL_MGMT_C_ADDDEF,",
          "538:  .doit = netlbl_mgmt_adddef,",
          "539:  .dumpit = NULL,",
          "540: };",
          "542: static struct genl_ops netlbl_mgmt_genl_c_removedef = {",
          "543:  .cmd = NLBL_MGMT_C_REMOVEDEF,",
          "545:  .doit = netlbl_mgmt_removedef,",
          "546:  .dumpit = NULL,",
          "547: };",
          "",
          "[Removed Lines]",
          "516:  .flags = 0,",
          "523:  .flags = 0,",
          "528: static struct genl_ops netlbl_mgmt_genl_c_list = {",
          "529:  .cmd = NLBL_MGMT_C_LIST,",
          "531:  .doit = netlbl_mgmt_list,",
          "532:  .dumpit = NULL,",
          "537:  .flags = 0,",
          "544:  .flags = 0,",
          "",
          "[Added Lines]",
          "519:  .flags = GENL_ADMIN_PERM,",
          "520:  .policy = netlbl_mgmt_genl_policy,",
          "527:  .flags = GENL_ADMIN_PERM,",
          "528:  .policy = netlbl_mgmt_genl_policy,",
          "533: static struct genl_ops netlbl_mgmt_genl_c_listall = {",
          "534:  .cmd = NLBL_MGMT_C_LISTALL,",
          "536:  .policy = netlbl_mgmt_genl_policy,",
          "537:  .doit = NULL,",
          "538:  .dumpit = netlbl_mgmt_listall,",
          "543:  .flags = GENL_ADMIN_PERM,",
          "544:  .policy = netlbl_mgmt_genl_policy,",
          "551:  .flags = GENL_ADMIN_PERM,",
          "552:  .policy = netlbl_mgmt_genl_policy,",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "549: static struct genl_ops netlbl_mgmt_genl_c_listdef = {",
          "550:  .cmd = NLBL_MGMT_C_LISTDEF,",
          "551:  .flags = 0,",
          "552:  .doit = netlbl_mgmt_listdef,",
          "553:  .dumpit = NULL,",
          "554: };",
          "558:  .flags = 0,",
          "561: };",
          "563: static struct genl_ops netlbl_mgmt_genl_c_version = {",
          "564:  .cmd = NLBL_MGMT_C_VERSION,",
          "565:  .flags = 0,",
          "566:  .doit = netlbl_mgmt_version,",
          "567:  .dumpit = NULL,",
          "568: };",
          "",
          "[Removed Lines]",
          "556: static struct genl_ops netlbl_mgmt_genl_c_modules = {",
          "557:  .cmd = NLBL_MGMT_C_MODULES,",
          "559:  .doit = netlbl_mgmt_modules,",
          "560:  .dumpit = NULL,",
          "",
          "[Added Lines]",
          "560:  .policy = netlbl_mgmt_genl_policy,",
          "565: static struct genl_ops netlbl_mgmt_genl_c_protocols = {",
          "566:  .cmd = NLBL_MGMT_C_PROTOCOLS,",
          "568:  .policy = netlbl_mgmt_genl_policy,",
          "569:  .doit = NULL,",
          "570:  .dumpit = netlbl_mgmt_protocols,",
          "576:  .policy = netlbl_mgmt_genl_policy,",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "596:  if (ret_val != 0)",
          "597:   return ret_val;",
          "598:  ret_val = genl_register_ops(&netlbl_mgmt_gnl_family,",
          "600:  if (ret_val != 0)",
          "601:   return ret_val;",
          "602:  ret_val = genl_register_ops(&netlbl_mgmt_gnl_family,",
          "",
          "[Removed Lines]",
          "599:         &netlbl_mgmt_genl_c_list);",
          "",
          "[Added Lines]",
          "610:         &netlbl_mgmt_genl_c_listall);",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "612:  if (ret_val != 0)",
          "613:   return ret_val;",
          "614:  ret_val = genl_register_ops(&netlbl_mgmt_gnl_family,",
          "616:  if (ret_val != 0)",
          "617:   return ret_val;",
          "618:  ret_val = genl_register_ops(&netlbl_mgmt_gnl_family,",
          "",
          "[Removed Lines]",
          "615:         &netlbl_mgmt_genl_c_modules);",
          "",
          "[Added Lines]",
          "626:         &netlbl_mgmt_genl_c_protocols);",
          "",
          "---------------"
        ],
        "net/netlabel/netlabel_mgmt.h||net/netlabel/netlabel_mgmt.h": [
          "File: net/netlabel/netlabel_mgmt.h -> net/netlabel/netlabel_mgmt.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "34: #include <net/netlabel.h>",
          "228: enum {",
          "229:  NLBL_MGMT_C_UNSPEC,",
          "231:  NLBL_MGMT_C_ADD,",
          "232:  NLBL_MGMT_C_REMOVE,",
          "234:  NLBL_MGMT_C_ADDDEF,",
          "235:  NLBL_MGMT_C_REMOVEDEF,",
          "236:  NLBL_MGMT_C_LISTDEF,",
          "238:  NLBL_MGMT_C_VERSION,",
          "239:  __NLBL_MGMT_C_MAX,",
          "240: };",
          "241: #define NLBL_MGMT_C_MAX (__NLBL_MGMT_C_MAX - 1)",
          "244: int netlbl_mgmt_genl_init(void);",
          "",
          "[Removed Lines]",
          "230:  NLBL_MGMT_C_ACK,",
          "233:  NLBL_MGMT_C_LIST,",
          "237:  NLBL_MGMT_C_MODULES,",
          "",
          "[Added Lines]",
          "138:  NLBL_MGMT_C_LISTALL,",
          "142:  NLBL_MGMT_C_PROTOCOLS,",
          "149: enum {",
          "150:  NLBL_MGMT_A_UNSPEC,",
          "151:  NLBL_MGMT_A_DOMAIN,",
          "154:  NLBL_MGMT_A_PROTOCOL,",
          "157:  NLBL_MGMT_A_VERSION,",
          "161:  NLBL_MGMT_A_CV4DOI,",
          "164:  __NLBL_MGMT_A_MAX,",
          "165: };",
          "166: #define NLBL_MGMT_A_MAX (__NLBL_MGMT_A_MAX - 1)",
          "",
          "---------------"
        ],
        "net/netlabel/netlabel_unlabeled.c||net/netlabel/netlabel_unlabeled.c": [
          "File: net/netlabel/netlabel_unlabeled.c -> net/netlabel/netlabel_unlabeled.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "55:  .hdrsize = 0,",
          "56:  .name = NETLBL_NLTYPE_UNLABELED_NAME,",
          "57:  .version = NETLBL_PROTO_VERSION,",
          "59: };",
          "",
          "[Removed Lines]",
          "58:  .maxattr = 0,",
          "",
          "[Added Lines]",
          "58:  .maxattr = NLBL_UNLABEL_A_MAX,",
          "62: static struct nla_policy netlbl_unlabel_genl_policy[NLBL_UNLABEL_A_MAX + 1] = {",
          "63:  [NLBL_UNLABEL_A_ACPTFLG] = { .type = NLA_U8 },",
          "64: };",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "76: static int netlbl_unlabel_accept(struct sk_buff *skb, struct genl_info *info)",
          "77: {",
          "88:   if (value == 1 || value == 0) {",
          "89:    atomic_set(&netlabel_unlabel_accept_flg, value);",
          "95:   }",
          "96:  }",
          "103: }",
          "",
          "[Removed Lines]",
          "78:  int ret_val;",
          "79:  struct nlattr *data = netlbl_netlink_payload_data(skb);",
          "80:  u32 value;",
          "82:  ret_val = netlbl_netlink_cap_check(skb, CAP_NET_ADMIN);",
          "83:  if (ret_val != 0)",
          "84:   return ret_val;",
          "86:  if (netlbl_netlink_payload_len(skb) == NETLBL_LEN_U32) {",
          "87:   value = nla_get_u32(data);",
          "90:    netlbl_netlink_send_ack(info,",
          "91:       netlbl_unlabel_gnl_family.id,",
          "92:       NLBL_UNLABEL_C_ACK,",
          "93:       NETLBL_E_OK);",
          "94:    return 0;",
          "98:  netlbl_netlink_send_ack(info,",
          "99:     netlbl_unlabel_gnl_family.id,",
          "100:     NLBL_UNLABEL_C_ACK,",
          "101:     EINVAL);",
          "102:  return -EINVAL;",
          "",
          "[Added Lines]",
          "82:  int ret_val = -EINVAL;",
          "83:  u8 value;",
          "85:  if (info->attrs[NLBL_UNLABEL_A_ACPTFLG]) {",
          "86:   value = nla_get_u8(info->attrs[NLBL_UNLABEL_A_ACPTFLG]);",
          "89:    ret_val = 0;",
          "93:  return ret_val;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "115: static int netlbl_unlabel_list(struct sk_buff *skb, struct genl_info *info)",
          "116: {",
          "118:  struct sk_buff *ans_skb;",
          "123:  if (ans_skb == NULL)",
          "124:   goto list_failure;",
          "131:   goto list_failure;",
          "136:  if (ret_val != 0)",
          "137:   goto list_failure;",
          "140:  if (ret_val != 0)",
          "141:   goto list_failure;",
          "143:  return 0;",
          "145: list_failure:",
          "150:  return ret_val;",
          "151: }",
          "",
          "[Removed Lines]",
          "117:  int ret_val = -ENOMEM;",
          "120:  ans_skb = netlbl_netlink_alloc_skb(0,",
          "121:         GENL_HDRLEN + NETLBL_LEN_U32,",
          "122:         GFP_KERNEL);",
          "126:  if (netlbl_netlink_hdr_put(ans_skb,",
          "127:        info->snd_pid,",
          "128:        0,",
          "129:        netlbl_unlabel_gnl_family.id,",
          "130:        NLBL_UNLABEL_C_LIST) == NULL)",
          "133:  ret_val = nla_put_u32(ans_skb,",
          "134:          NLA_U32,",
          "135:          atomic_read(&netlabel_unlabel_accept_flg));",
          "139:  ret_val = netlbl_netlink_snd(ans_skb, info->snd_pid);",
          "146:  netlbl_netlink_send_ack(info,",
          "147:     netlbl_unlabel_gnl_family.id,",
          "148:     NLBL_UNLABEL_C_ACK,",
          "149:     -ret_val);",
          "",
          "[Added Lines]",
          "108:  int ret_val = -EINVAL;",
          "110:  void *data;",
          "112:  ans_skb = nlmsg_new(NLMSG_GOODSIZE, GFP_KERNEL);",
          "115:  data = netlbl_netlink_hdr_put(ans_skb,",
          "116:           info->snd_pid,",
          "117:           info->snd_seq,",
          "118:           netlbl_unlabel_gnl_family.id,",
          "119:           0,",
          "120:           NLBL_UNLABEL_C_LIST);",
          "121:  if (data == NULL) {",
          "122:   ret_val = -ENOMEM;",
          "124:  }",
          "126:  ret_val = nla_put_u8(ans_skb,",
          "127:         NLBL_UNLABEL_A_ACPTFLG,",
          "128:         atomic_read(&netlabel_unlabel_accept_flg));",
          "132:  genlmsg_end(ans_skb, data);",
          "134:  ret_val = genlmsg_unicast(ans_skb, info->snd_pid);",
          "140:  kfree(ans_skb);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "158: static struct genl_ops netlbl_unlabel_genl_c_accept = {",
          "159:  .cmd = NLBL_UNLABEL_C_ACCEPT,",
          "161:  .doit = netlbl_unlabel_accept,",
          "162:  .dumpit = NULL,",
          "163: };",
          "",
          "[Removed Lines]",
          "160:  .flags = 0,",
          "",
          "[Added Lines]",
          "151:  .flags = GENL_ADMIN_PERM,",
          "152:  .policy = netlbl_unlabel_genl_policy,",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "165: static struct genl_ops netlbl_unlabel_genl_c_list = {",
          "166:  .cmd = NLBL_UNLABEL_C_LIST,",
          "167:  .flags = 0,",
          "168:  .doit = netlbl_unlabel_list,",
          "169:  .dumpit = NULL,",
          "170: };",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "160:  .policy = netlbl_unlabel_genl_policy,",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "219: int netlbl_unlabel_getattr(struct netlbl_lsm_secattr *secattr)",
          "220: {",
          "226:  return -ENOMSG;",
          "227: }",
          "",
          "[Removed Lines]",
          "221:  if (atomic_read(&netlabel_unlabel_accept_flg) == 1) {",
          "222:   memset(secattr, 0, sizeof(*secattr));",
          "223:   return 0;",
          "224:  }",
          "",
          "[Added Lines]",
          "214:  if (atomic_read(&netlabel_unlabel_accept_flg) == 1)",
          "215:   return netlbl_secattr_init(secattr);",
          "",
          "---------------"
        ],
        "net/netlabel/netlabel_unlabeled.h||net/netlabel/netlabel_unlabeled.h": [
          "File: net/netlabel/netlabel_unlabeled.h -> net/netlabel/netlabel_unlabeled.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "80: enum {",
          "81:  NLBL_UNLABEL_C_UNSPEC,",
          "83:  NLBL_UNLABEL_C_ACCEPT,",
          "84:  NLBL_UNLABEL_C_LIST,",
          "85:  __NLBL_UNLABEL_C_MAX,",
          "86: };",
          "87: #define NLBL_UNLABEL_C_MAX (__NLBL_UNLABEL_C_MAX - 1)",
          "90: int netlbl_unlabel_genl_init(void);",
          "",
          "[Removed Lines]",
          "82:  NLBL_UNLABEL_C_ACK,",
          "",
          "[Added Lines]",
          "70: enum {",
          "71:  NLBL_UNLABEL_A_UNSPEC,",
          "72:  NLBL_UNLABEL_A_ACPTFLG,",
          "76:  __NLBL_UNLABEL_A_MAX,",
          "77: };",
          "78: #define NLBL_UNLABEL_A_MAX (__NLBL_UNLABEL_A_MAX - 1)",
          "",
          "---------------"
        ]
      }
    }
  ]
}
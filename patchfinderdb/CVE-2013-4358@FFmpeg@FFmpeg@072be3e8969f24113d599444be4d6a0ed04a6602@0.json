{
  "cve_id": "CVE-2013-4358",
  "cve_desc": "libavcodec/h264.c in FFmpeg before 0.11.4 allows remote attackers to cause a denial of service (crash) via vectors related to alternating bit depths in H.264 data.",
  "repo": "FFmpeg/FFmpeg",
  "patch_hash": "072be3e8969f24113d599444be4d6a0ed04a6602",
  "patch_info": {
    "commit_hash": "072be3e8969f24113d599444be4d6a0ed04a6602",
    "repo": "FFmpeg/FFmpeg",
    "commit_url": "https://github.com/FFmpeg/FFmpeg/commit/072be3e8969f24113d599444be4d6a0ed04a6602",
    "files": [
      "libavcodec/h264.c",
      "libavcodec/h264.h",
      "libavcodec/h264_ps.c"
    ],
    "message": "h264: set parameters from SPS whenever it changes\n\nFixes a crash in the fuzzed sample sample_varPAR.avi_s26638 with\nalternating bit depths.",
    "before_after_code_files": [
      "libavcodec/h264.c||libavcodec/h264.c",
      "libavcodec/h264.h||libavcodec/h264.h",
      "libavcodec/h264_ps.c||libavcodec/h264_ps.c"
    ]
  },
  "patch_diff": {
    "libavcodec/h264.c||libavcodec/h264.c": [
      "File: libavcodec/h264.c -> libavcodec/h264.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "2340:     return profile;",
      "2341: }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "2343: static int h264_set_parameter_from_sps(H264Context *h)",
      "2344: {",
      "2345:     MpegEncContext *s = &h->s;",
      "2347:     if (s->flags & CODEC_FLAG_LOW_DELAY ||",
      "2348:         (h->sps.bitstream_restriction_flag &&",
      "2349:          !h->sps.num_reorder_frames)) {",
      "2350:         if (s->avctx->has_b_frames > 1 || h->delayed_pic[0])",
      "2351:             av_log(h->s.avctx, AV_LOG_WARNING, \"Delayed frames seen. \"",
      "2352:                    \"Reenabling low delay requires a codec flush.\\n\");",
      "2353:         else",
      "2354:             s->low_delay = 1;",
      "2355:     }",
      "2357:     if (s->avctx->has_b_frames < 2)",
      "2358:         s->avctx->has_b_frames = !s->low_delay;",
      "2360:     if (s->avctx->bits_per_raw_sample != h->sps.bit_depth_luma ||",
      "2361:         h->cur_chroma_format_idc      != h->sps.chroma_format_idc) {",
      "2362:         if (s->avctx->codec &&",
      "2363:             s->avctx->codec->capabilities & CODEC_CAP_HWACCEL_VDPAU &&",
      "2364:             (h->sps.bit_depth_luma != 8 || h->sps.chroma_format_idc > 1)) {",
      "2365:             av_log(s->avctx, AV_LOG_ERROR,",
      "2366:                    \"VDPAU decoding does not support video colorspace.\\n\");",
      "2367:             return AVERROR_INVALIDDATA;",
      "2368:         }",
      "2369:         if (h->sps.bit_depth_luma >= 8 && h->sps.bit_depth_luma <= 10) {",
      "2370:             s->avctx->bits_per_raw_sample = h->sps.bit_depth_luma;",
      "2371:             h->cur_chroma_format_idc      = h->sps.chroma_format_idc;",
      "2372:             h->pixel_shift                = h->sps.bit_depth_luma > 8;",
      "2374:             ff_h264dsp_init(&h->h264dsp, h->sps.bit_depth_luma,",
      "2375:                             h->sps.chroma_format_idc);",
      "2376:             ff_h264_pred_init(&h->hpc, s->codec_id, h->sps.bit_depth_luma,",
      "2377:                               h->sps.chroma_format_idc);",
      "2378:             s->dsp.dct_bits = h->sps.bit_depth_luma > 8 ? 32 : 16;",
      "2379:             ff_dsputil_init(&s->dsp, s->avctx);",
      "2380:         } else {",
      "2381:             av_log(s->avctx, AV_LOG_ERROR, \"Unsupported bit depth: %d\\n\",",
      "2382:                    h->sps.bit_depth_luma);",
      "2383:             return AVERROR_INVALIDDATA;",
      "2384:         }",
      "2385:     }",
      "2386:     return 0;",
      "2387: }",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "2356:     MpegEncContext *const s0 = &h0->s;",
      "2357:     unsigned int first_mb_in_slice;",
      "2358:     unsigned int pps_id;",
      "2360:     unsigned int slice_type, tmp, i, j;",
      "2361:     int default_ref_list_done = 0;",
      "2362:     int last_pic_structure, last_pic_droppable;",
      "",
      "[Removed Lines]",
      "2359:     int num_ref_idx_active_override_flag, max_refs;",
      "",
      "[Added Lines]",
      "2405:     int num_ref_idx_active_override_flag, max_refs, ret;",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "2432:                h->pps.sps_id);",
      "2433:         return -1;",
      "2434:     }",
      "2437:     s->avctx->profile = ff_h264_get_profile(&h->sps);",
      "2438:     s->avctx->level   = h->sps.level_idc;",
      "",
      "[Removed Lines]",
      "2435:     h->sps = *h0->sps_buffers[h->pps.sps_id];",
      "",
      "[Added Lines]",
      "2482:     if (h->pps.sps_id != h->current_sps_id ||",
      "2483:         h0->sps_buffers[h->pps.sps_id]->new) {",
      "2484:         h0->sps_buffers[h->pps.sps_id]->new = 0;",
      "2486:         h->current_sps_id = h->pps.sps_id;",
      "2487:         h->sps            = *h0->sps_buffers[h->pps.sps_id];",
      "2489:         if ((ret = h264_set_parameter_from_sps(h)) < 0)",
      "2490:             return ret;",
      "2491:     }",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "3878:                     ff_h264_decode_seq_parameter_set(h);",
      "3879:                 }",
      "3926:                 }",
      "3927:                 break;",
      "3928:             case NAL_PPS:",
      "",
      "[Removed Lines]",
      "3881:                 if (s->flags & CODEC_FLAG_LOW_DELAY ||",
      "3882:                     (h->sps.bitstream_restriction_flag &&",
      "3883:                      !h->sps.num_reorder_frames)) {",
      "3884:                     if (s->avctx->has_b_frames > 1 || h->delayed_pic[0])",
      "3885:                         av_log(avctx, AV_LOG_WARNING, \"Delayed frames seen \"",
      "3886:                                \"reenabling low delay requires a codec \"",
      "3887:                                \"flush.\\n\");",
      "3888:                         else",
      "3889:                             s->low_delay = 1;",
      "3890:                 }",
      "3892:                 if (avctx->has_b_frames < 2)",
      "3893:                     avctx->has_b_frames = !s->low_delay;",
      "3895:                 if (avctx->bits_per_raw_sample != h->sps.bit_depth_luma ||",
      "3896:                     h->cur_chroma_format_idc   != h->sps.chroma_format_idc) {",
      "3897:                     if (s->avctx->codec &&",
      "3898:                         s->avctx->codec->capabilities & CODEC_CAP_HWACCEL_VDPAU",
      "3899:                         && (h->sps.bit_depth_luma != 8 ||",
      "3900:                             h->sps.chroma_format_idc > 1)) {",
      "3901:                         av_log(avctx, AV_LOG_ERROR,",
      "3902:                                \"VDPAU decoding does not support video \"",
      "3903:                                \"colorspace\\n\");",
      "3904:                         buf_index = -1;",
      "3905:                         goto end;",
      "3906:                     }",
      "3907:                     if (h->sps.bit_depth_luma >= 8 && h->sps.bit_depth_luma <= 10) {",
      "3908:                         avctx->bits_per_raw_sample = h->sps.bit_depth_luma;",
      "3909:                         h->cur_chroma_format_idc   = h->sps.chroma_format_idc;",
      "3910:                         h->pixel_shift             = h->sps.bit_depth_luma > 8;",
      "3912:                         ff_h264dsp_init(&h->h264dsp, h->sps.bit_depth_luma,",
      "3913:                                         h->sps.chroma_format_idc);",
      "3914:                         ff_h264_pred_init(&h->hpc, s->codec_id,",
      "3915:                                           h->sps.bit_depth_luma,",
      "3916:                                           h->sps.chroma_format_idc);",
      "3917:                         s->dsp.dct_bits = h->sps.bit_depth_luma > 8 ? 32 : 16;",
      "3918:                         ff_dsputil_init(&s->dsp, s->avctx);",
      "3919:                     } else {",
      "3920:                         av_log(avctx, AV_LOG_ERROR,",
      "3921:                                \"Unsupported bit depth: %d\\n\",",
      "3922:                                h->sps.bit_depth_luma);",
      "3923:                         buf_index = -1;",
      "3924:                         goto end;",
      "3925:                     }",
      "",
      "[Added Lines]",
      "3937:                 if (h264_set_parameter_from_sps(h) < 0) {",
      "3938:                     buf_index = -1;",
      "3939:                     goto end;",
      "",
      "---------------"
    ],
    "libavcodec/h264.h||libavcodec/h264.h": [
      "File: libavcodec/h264.h -> libavcodec/h264.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "203:     int bit_depth_chroma;                 ///< bit_depth_chroma_minus8 + 8",
      "204:     int residual_color_transform_flag;    ///< residual_colour_transform_flag",
      "205:     int constraint_set_flags;             ///< constraint_set[0-3]_flag",
      "206: } SPS;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "206:     int new;                              ///< flag to keep track if the decoder context needs re-init due to changed SPS",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "329:     int emu_edge_width;",
      "330:     int emu_edge_height;",
      "332:     SPS sps; ///< current sps",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "333:     unsigned current_sps_id; ///< id of the current SPS",
      "",
      "---------------"
    ],
    "libavcodec/h264_ps.c||libavcodec/h264_ps.c": [
      "File: libavcodec/h264_ps.c -> libavcodec/h264_ps.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "459:                sps->timing_info_present_flag ? sps->time_scale : 0",
      "460:                );",
      "461:     }",
      "463:     av_free(h->sps_buffers[sps_id]);",
      "466:     return 0;",
      "467: fail:",
      "468:     av_free(sps);",
      "",
      "[Removed Lines]",
      "464:     h->sps_buffers[sps_id]= sps;",
      "465:     h->sps = *sps;",
      "",
      "[Added Lines]",
      "462:     sps->new = 1;",
      "465:     h->sps_buffers[sps_id] = sps;",
      "466:     h->sps                 = *sps;",
      "467:     h->current_sps_id      = sps_id;",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "c1fcf563b13051f280db169ba41c6a1b21b25e08",
      "candidate_info": {
        "commit_hash": "c1fcf563b13051f280db169ba41c6a1b21b25e08",
        "repo": "FFmpeg/FFmpeg",
        "commit_url": "https://github.com/FFmpeg/FFmpeg/commit/c1fcf563b13051f280db169ba41c6a1b21b25e08",
        "files": [
          "libavcodec/h264.c"
        ],
        "message": "h264: check context state before decoding slice data partitions\n\nFixes mov_h264_aac__Demo_FlagOfOurFathers.mov.SIGSEGV.4e9.656.\n\nFound-by: Mateusz \"j00ru\" Jurczyk\nCC: libav-stable@libav.org",
        "before_after_code_files": [
          "libavcodec/h264.c||libavcodec/h264.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "libavcodec/h264.c||libavcodec/h264.c"
          ],
          "candidate": [
            "libavcodec/h264.c||libavcodec/h264.c"
          ]
        }
      },
      "candidate_diff": {
        "libavcodec/h264.c||libavcodec/h264.c": [
          "File: libavcodec/h264.c -> libavcodec/h264.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "3848:                 if (hx->redundant_pic_count == 0 &&",
          "3849:                     hx->intra_gb_ptr &&",
          "3850:                     hx->s.data_partitioning &&",
          "3851:                     s->context_initialized &&",
          "3852:                     (avctx->skip_frame < AVDISCARD_NONREF || hx->nal_ref_idc) &&",
          "3853:                     (avctx->skip_frame < AVDISCARD_BIDIR  ||",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3851:                     s->current_picture_ptr &&",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "4baba6c813b7a1f27370e20fb1a87b05fcb39208",
      "candidate_info": {
        "commit_hash": "4baba6c813b7a1f27370e20fb1a87b05fcb39208",
        "repo": "FFmpeg/FFmpeg",
        "commit_url": "https://github.com/FFmpeg/FFmpeg/commit/4baba6c813b7a1f27370e20fb1a87b05fcb39208",
        "files": [
          "libavcodec/h264.c",
          "libavcodec/h264.h",
          "libavcodec/h264_parser.c"
        ],
        "message": "h264_parser: Fix POC parsing for the case where MMCO_RESET is present.\n\nSigned-off-by: Anton Khirnov <anton@khirnov.net>",
        "before_after_code_files": [
          "libavcodec/h264.c||libavcodec/h264.c",
          "libavcodec/h264.h||libavcodec/h264.h",
          "libavcodec/h264_parser.c||libavcodec/h264_parser.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "libavcodec/h264.c||libavcodec/h264.c",
            "libavcodec/h264.h||libavcodec/h264.h"
          ],
          "candidate": [
            "libavcodec/h264.c||libavcodec/h264.c",
            "libavcodec/h264.h||libavcodec/h264.h"
          ]
        }
      },
      "candidate_diff": {
        "libavcodec/h264.c||libavcodec/h264.c": [
          "File: libavcodec/h264.c -> libavcodec/h264.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "2554:         hl_decode_mb_simple_8(h);",
          "2555: }",
          "2558: {",
          "2559:     int list, i;",
          "2560:     int luma_def, chroma_def;",
          "",
          "[Removed Lines]",
          "2557: static int pred_weight_table(H264Context *h)",
          "",
          "[Added Lines]",
          "2557: int ff_pred_weight_table(H264Context *h)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "3198:     return 0;",
          "3199: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3201: int ff_set_ref_count(H264Context *h)",
          "3202: {",
          "3203:     int num_ref_idx_active_override_flag, max_refs;",
          "3206:     h->ref_count[0] = h->pps.ref_count[0];",
          "3207:     h->ref_count[1] = h->pps.ref_count[1];",
          "3209:     if (h->slice_type_nos != AV_PICTURE_TYPE_I) {",
          "3210:         if (h->slice_type_nos == AV_PICTURE_TYPE_B)",
          "3211:             h->direct_spatial_mv_pred = get_bits1(&h->gb);",
          "3212:         num_ref_idx_active_override_flag = get_bits1(&h->gb);",
          "3214:         if (num_ref_idx_active_override_flag) {",
          "3215:             h->ref_count[0] = get_ue_golomb(&h->gb) + 1;",
          "3216:             if (h->ref_count[0] < 1)",
          "3217:                 return AVERROR_INVALIDDATA;",
          "3218:             if (h->slice_type_nos == AV_PICTURE_TYPE_B) {",
          "3219:                 h->ref_count[1] = get_ue_golomb(&h->gb) + 1;",
          "3220:                 if (h->ref_count[1] < 1)",
          "3221:                     return AVERROR_INVALIDDATA;",
          "3222:             }",
          "3223:         }",
          "3225:         if (h->slice_type_nos == AV_PICTURE_TYPE_B)",
          "3226:             h->list_count = 2;",
          "3227:         else",
          "3228:             h->list_count = 1;",
          "3229:     } else {",
          "3230:         h->list_count   = 0;",
          "3231:         h->ref_count[0] = h->ref_count[1] = 0;",
          "3232:     }",
          "3234:     max_refs = h->picture_structure == PICT_FRAME ? 16 : 32;",
          "3236:     if (h->ref_count[0] > max_refs || h->ref_count[1] > max_refs) {",
          "3237:         av_log(h->avctx, AV_LOG_ERROR, \"reference overflow\\n\");",
          "3238:         h->ref_count[0] = h->ref_count[1] = 0;",
          "3239:         return AVERROR_INVALIDDATA;",
          "3240:     }",
          "3242:     return 0;",
          "3243: }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "3212: {",
          "3213:     unsigned int first_mb_in_slice;",
          "3214:     unsigned int pps_id;",
          "3216:     unsigned int slice_type, tmp, i, j;",
          "3217:     int default_ref_list_done = 0;",
          "3218:     int last_pic_structure, last_pic_droppable;",
          "",
          "[Removed Lines]",
          "3215:     int num_ref_idx_active_override_flag, max_refs, ret;",
          "",
          "[Added Lines]",
          "3259:     int ret;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "3619:     if (h->pps.redundant_pic_cnt_present)",
          "3620:         h->redundant_pic_count = get_ue_golomb(&h->gb);",
          "3659:     if (!default_ref_list_done)",
          "3660:         ff_h264_fill_default_ref_list(h);",
          "",
          "[Removed Lines]",
          "3623:     h->ref_count[0] = h->pps.ref_count[0];",
          "3624:     h->ref_count[1] = h->pps.ref_count[1];",
          "3626:     if (h->slice_type_nos != AV_PICTURE_TYPE_I) {",
          "3627:         if (h->slice_type_nos == AV_PICTURE_TYPE_B)",
          "3628:             h->direct_spatial_mv_pred = get_bits1(&h->gb);",
          "3629:         num_ref_idx_active_override_flag = get_bits1(&h->gb);",
          "3631:         if (num_ref_idx_active_override_flag) {",
          "3632:             h->ref_count[0] = get_ue_golomb(&h->gb) + 1;",
          "3633:             if (h->ref_count[0] < 1)",
          "3634:                 return AVERROR_INVALIDDATA;",
          "3635:             if (h->slice_type_nos == AV_PICTURE_TYPE_B) {",
          "3636:                 h->ref_count[1] = get_ue_golomb(&h->gb) + 1;",
          "3637:                 if (h->ref_count[1] < 1)",
          "3638:                     return AVERROR_INVALIDDATA;",
          "3639:             }",
          "3640:         }",
          "3642:         if (h->slice_type_nos == AV_PICTURE_TYPE_B)",
          "3643:             h->list_count = 2;",
          "3644:         else",
          "3645:             h->list_count = 1;",
          "3646:     } else {",
          "3647:         h->list_count   = 0;",
          "3648:         h->ref_count[0] = h->ref_count[1] = 0;",
          "3649:     }",
          "3651:     max_refs = h->picture_structure == PICT_FRAME ? 16 : 32;",
          "3653:     if (h->ref_count[0] > max_refs || h->ref_count[1] > max_refs) {",
          "3654:         av_log(h->avctx, AV_LOG_ERROR, \"reference overflow\\n\");",
          "3655:         h->ref_count[0] = h->ref_count[1] = 0;",
          "3656:         return AVERROR_INVALIDDATA;",
          "3657:     }",
          "",
          "[Added Lines]",
          "3666:     ret = ff_set_ref_count(h);",
          "3667:     if (ret < 0)",
          "3668:         return ret;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "3670:     if ((h->pps.weighted_pred && h->slice_type_nos == AV_PICTURE_TYPE_P) ||",
          "3671:         (h->pps.weighted_bipred_idc == 1 &&",
          "3672:          h->slice_type_nos == AV_PICTURE_TYPE_B))",
          "3674:     else if (h->pps.weighted_bipred_idc == 2 &&",
          "3675:              h->slice_type_nos == AV_PICTURE_TYPE_B) {",
          "3676:         implicit_weight_table(h, -1);",
          "",
          "[Removed Lines]",
          "3673:         pred_weight_table(h);",
          "",
          "[Added Lines]",
          "3684:         ff_pred_weight_table(h);",
          "",
          "---------------"
        ],
        "libavcodec/h264.h||libavcodec/h264.h": [
          "File: libavcodec/h264.h -> libavcodec/h264.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "951: void ff_h264_draw_horiz_band(H264Context *h, int y, int height);",
          "952: int ff_init_poc(H264Context *h, int pic_field_poc[2], int *pic_poc);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "953: int ff_pred_weight_table(H264Context *h);",
          "954: int ff_set_ref_count(H264Context *h);",
          "",
          "---------------"
        ],
        "libavcodec/h264_parser.c||libavcodec/h264_parser.c": [
          "File: libavcodec/h264_parser.c -> libavcodec/h264_parser.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "87:     return i - (state & 5);",
          "88: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "90: static int scan_mmco_reset(AVCodecParserContext *s)",
          "91: {",
          "92:     H264Context *h = s->priv_data;",
          "94:     h->slice_type_nos = s->pict_type & 3;",
          "96:     if (h->pps.redundant_pic_cnt_present)",
          "97:         get_ue_golomb(&h->gb); // redundant_pic_count",
          "99:     if (ff_set_ref_count(h) < 0)",
          "100:         return AVERROR_INVALIDDATA;",
          "102:     if (h->slice_type_nos != AV_PICTURE_TYPE_I) {",
          "103:         int list;",
          "104:         for (list = 0; list < h->list_count; list++) {",
          "105:             if (get_bits1(&h->gb)) {",
          "106:                 int index;",
          "107:                 for (index = 0; ; index++) {",
          "108:                     unsigned int reordering_of_pic_nums_idc = get_ue_golomb_31(&h->gb);",
          "110:                     if (reordering_of_pic_nums_idc < 3)",
          "111:                         get_ue_golomb(&h->gb);",
          "112:                     else if (reordering_of_pic_nums_idc > 3) {",
          "113:                         av_log(h->avctx, AV_LOG_ERROR,",
          "114:                                \"illegal reordering_of_pic_nums_idc %d\\n\",",
          "115:                                reordering_of_pic_nums_idc);",
          "116:                         return AVERROR_INVALIDDATA;",
          "117:                     } else",
          "118:                         break;",
          "120:                     if (index >= h->ref_count[list]) {",
          "121:                         av_log(h->avctx, AV_LOG_ERROR, \"reference count overflow\\n\");",
          "122:                         return AVERROR_INVALIDDATA;",
          "123:                     }",
          "124:                 }",
          "125:             }",
          "126:         }",
          "127:     }",
          "129:     if ((h->pps.weighted_pred && h->slice_type_nos == AV_PICTURE_TYPE_P) ||",
          "130:         (h->pps.weighted_bipred_idc == 1 && h->slice_type_nos == AV_PICTURE_TYPE_B))",
          "131:         ff_pred_weight_table(h);",
          "133:     if (get_bits1(&h->gb)) { // adaptive_ref_pic_marking_mode_flag",
          "134:         int i;",
          "135:         for (i = 0; i < MAX_MMCO_COUNT; i++) {",
          "136:             MMCOOpcode opcode = get_ue_golomb_31(&h->gb);",
          "137:             if (opcode > (unsigned) MMCO_LONG) {",
          "138:                 av_log(h->avctx, AV_LOG_ERROR,",
          "139:                        \"illegal memory management control operation %d\\n\",",
          "140:                        opcode);",
          "141:                 return AVERROR_INVALIDDATA;",
          "142:             }",
          "143:             if (opcode == MMCO_END)",
          "144:                return 0;",
          "145:             else if (opcode == MMCO_RESET)",
          "146:                 return 1;",
          "148:             if (opcode == MMCO_SHORT2UNUSED || opcode == MMCO_SHORT2LONG)",
          "149:                 get_ue_golomb(&h->gb);",
          "150:             if (opcode == MMCO_SHORT2LONG || opcode == MMCO_LONG2UNUSED ||",
          "151:                 opcode == MMCO_LONG || opcode == MMCO_SET_MAX_LONG)",
          "152:                 get_ue_golomb_31(&h->gb);",
          "153:         }",
          "154:     }",
          "156:     return 0;",
          "157: }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "103:     const uint8_t *buf_end = buf + buf_size;",
          "104:     unsigned int pps_id;",
          "105:     unsigned int slice_type;",
          "107:     const uint8_t *ptr;",
          "108:     int field_poc[2];",
          "",
          "[Removed Lines]",
          "106:     int state = -1;",
          "",
          "[Added Lines]",
          "175:     int state = -1, got_reset = 0;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "132:         case NAL_SLICE:",
          "133:         case NAL_IDR_SLICE:",
          "137:             break;",
          "138:         }",
          "139:         ptr = ff_h264_decode_nal(h, buf, &dst_length, &consumed, src_length);",
          "",
          "[Removed Lines]",
          "135:             if (src_length > 60)",
          "136:                 src_length = 60;",
          "",
          "[Added Lines]",
          "204:             if (state & 0x1f == NAL_IDR_SLICE || (state >> 5) & 0x3 == 0) {",
          "207:                 if (src_length > 60)",
          "208:                     src_length = 60;",
          "209:             } else {",
          "211:                 if (src_length > 1000)",
          "212:                     src_length = 1000;",
          "213:             }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "219:                     h->delta_poc[1] = get_se_golomb(&h->gb);",
          "220:             }",
          "223:             field_poc[0] = field_poc[1] = INT_MAX;",
          "224:             ff_init_poc(h, field_poc, &s->output_picture_number);",
          "229:             if (h->nal_ref_idc != 0) {",
          "232:             }",
          "234:             if (h->sps.pic_struct_present_flag) {",
          "",
          "[Removed Lines]",
          "227:             h->prev_frame_num        = h->frame_num;",
          "228:             h->prev_frame_num_offset = h->frame_num_offset;",
          "230:                 h->prev_poc_msb = h->poc_msb;",
          "231:                 h->prev_poc_lsb = h->poc_lsb;",
          "",
          "[Added Lines]",
          "308:             if (h->nal_ref_idc && h->nal_unit_type != NAL_IDR_SLICE) {",
          "309:                 got_reset = scan_mmco_reset(s);",
          "310:                 if (got_reset < 0)",
          "311:                     return got_reset;",
          "312:             }",
          "315:             h->prev_frame_num        = got_reset ? 0 : h->frame_num;",
          "316:             h->prev_frame_num_offset = got_reset ? 0 : h->frame_num_offset;",
          "318:                 if (!got_reset) {",
          "319:                     h->prev_poc_msb = h->poc_msb;",
          "320:                     h->prev_poc_lsb = h->poc_lsb;",
          "321:                 } else {",
          "322:                     h->prev_poc_msb = 0;",
          "323:                     h->prev_poc_lsb =",
          "324:                         h->picture_structure == PICT_BOTTOM_FIELD ? 0 : field_poc[0];",
          "325:                 }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "b9d887c225466576ae80ef7f2b109e866ff137b2",
      "candidate_info": {
        "commit_hash": "b9d887c225466576ae80ef7f2b109e866ff137b2",
        "repo": "FFmpeg/FFmpeg",
        "commit_url": "https://github.com/FFmpeg/FFmpeg/commit/b9d887c225466576ae80ef7f2b109e866ff137b2",
        "files": [
          "libavcodec/h264.c",
          "libavcodec/h264.h",
          "libavcodec/h264_ps.c",
          "libavfilter/af_asyncts.c"
        ],
        "message": "Merge commit '072be3e8969f24113d599444be4d6a0ed04a6602'\n\n* commit '072be3e8969f24113d599444be4d6a0ed04a6602':\n  h264: set parameters from SPS whenever it changes\n  asyncts: cosmetics: reindent\n\nConflicts:\n\tlibavcodec/h264.c\n\nMerged-by: Michael Niedermayer <michaelni@gmx.at>",
        "before_after_code_files": [
          "libavcodec/h264.c||libavcodec/h264.c",
          "libavcodec/h264.h||libavcodec/h264.h",
          "libavcodec/h264_ps.c||libavcodec/h264_ps.c",
          "libavfilter/af_asyncts.c||libavfilter/af_asyncts.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "libavcodec/h264.c||libavcodec/h264.c",
            "libavcodec/h264.h||libavcodec/h264.h",
            "libavcodec/h264_ps.c||libavcodec/h264_ps.c"
          ],
          "candidate": [
            "libavcodec/h264.c||libavcodec/h264.c",
            "libavcodec/h264.h||libavcodec/h264.h",
            "libavcodec/h264_ps.c||libavcodec/h264_ps.c"
          ]
        }
      },
      "candidate_diff": {
        "libavcodec/h264.c||libavcodec/h264.c": [
          "File: libavcodec/h264.c -> libavcodec/h264.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "2357:     return profile;",
          "2358: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2360: static int h264_set_parameter_from_sps(H264Context *h)",
          "2361: {",
          "2362:     MpegEncContext *s = &h->s;",
          "2364:     if (s->flags & CODEC_FLAG_LOW_DELAY ||",
          "2365:         (h->sps.bitstream_restriction_flag &&",
          "2366:          !h->sps.num_reorder_frames)) {",
          "2367:         if (s->avctx->has_b_frames > 1 || h->delayed_pic[0])",
          "2368:             av_log(h->s.avctx, AV_LOG_WARNING, \"Delayed frames seen. \"",
          "2369:                    \"Reenabling low delay requires a codec flush.\\n\");",
          "2370:         else",
          "2371:             s->low_delay = 1;",
          "2372:     }",
          "2374:     if (s->avctx->has_b_frames < 2)",
          "2375:         s->avctx->has_b_frames = !s->low_delay;",
          "2377:     if (s->avctx->bits_per_raw_sample != h->sps.bit_depth_luma ||",
          "2378:         h->cur_chroma_format_idc      != h->sps.chroma_format_idc) {",
          "2379:         if (s->avctx->codec &&",
          "2380:             s->avctx->codec->capabilities & CODEC_CAP_HWACCEL_VDPAU &&",
          "2381:             (h->sps.bit_depth_luma != 8 || h->sps.chroma_format_idc > 1)) {",
          "2382:             av_log(s->avctx, AV_LOG_ERROR,",
          "2383:                    \"VDPAU decoding does not support video colorspace.\\n\");",
          "2384:             return AVERROR_INVALIDDATA;",
          "2385:         }",
          "2386:         if (h->sps.bit_depth_luma >= 8 && h->sps.bit_depth_luma <= 14 &&",
          "2387:             h->sps.bit_depth_luma != 11 && h->sps.bit_depth_luma != 13 &&",
          "2388:                 (h->sps.bit_depth_luma != 9 || !CHROMA422)) {",
          "2389:             s->avctx->bits_per_raw_sample = h->sps.bit_depth_luma;",
          "2390:             h->cur_chroma_format_idc      = h->sps.chroma_format_idc;",
          "2391:             h->pixel_shift                = h->sps.bit_depth_luma > 8;",
          "2393:             ff_h264dsp_init(&h->h264dsp, h->sps.bit_depth_luma,",
          "2394:                             h->sps.chroma_format_idc);",
          "2395:             ff_h264_pred_init(&h->hpc, s->codec_id, h->sps.bit_depth_luma,",
          "2396:                               h->sps.chroma_format_idc);",
          "2397:             s->dsp.dct_bits = h->sps.bit_depth_luma > 8 ? 32 : 16;",
          "2398:             ff_dsputil_init(&s->dsp, s->avctx);",
          "2399:         } else {",
          "2400:             av_log(s->avctx, AV_LOG_ERROR, \"Unsupported bit depth: %d\\n\",",
          "2401:                    h->sps.bit_depth_luma);",
          "2402:             return AVERROR_INVALIDDATA;",
          "2403:         }",
          "2404:     }",
          "2405:     return 0;",
          "2406: }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2373:     MpegEncContext *const s0 = &h0->s;",
          "2374:     unsigned int first_mb_in_slice;",
          "2375:     unsigned int pps_id;",
          "2377:     unsigned int slice_type, tmp, i, j;",
          "2378:     int default_ref_list_done = 0;",
          "2379:     int last_pic_structure, last_pic_droppable;",
          "",
          "[Removed Lines]",
          "2376:     int num_ref_idx_active_override_flag;",
          "",
          "[Added Lines]",
          "2424:     int num_ref_idx_active_override_flag, ret;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "2450:                h->pps.sps_id);",
          "2451:         return -1;",
          "2452:     }",
          "2455:     s->avctx->profile = ff_h264_get_profile(&h->sps);",
          "2456:     s->avctx->level   = h->sps.level_idc;",
          "",
          "[Removed Lines]",
          "2453:     h->sps = *h0->sps_buffers[h->pps.sps_id];",
          "",
          "[Added Lines]",
          "2502:     if (h->pps.sps_id != h->current_sps_id ||",
          "2503:         h0->sps_buffers[h->pps.sps_id]->new) {",
          "2504:         h0->sps_buffers[h->pps.sps_id]->new = 0;",
          "2506:         h->current_sps_id = h->pps.sps_id;",
          "2507:         h->sps            = *h0->sps_buffers[h->pps.sps_id];",
          "2508:     }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "2508:         s->avctx->sample_aspect_ratio = h->sps.sar;",
          "2509:         av_assert0(s->avctx->sample_aspect_ratio.den);",
          "2539:         if (h->sps.video_signal_type_present_flag) {",
          "2540:             s->avctx->color_range = h->sps.full_range>0 ? AVCOL_RANGE_JPEG",
          "",
          "[Removed Lines]",
          "2511:         if (s->avctx->codec->capabilities & CODEC_CAP_HWACCEL_VDPAU",
          "2512:             && (h->sps.bit_depth_luma != 8 ||",
          "2513:                 h->sps.chroma_format_idc > 1)) {",
          "2514:             av_log(s->avctx, AV_LOG_ERROR,",
          "2515:                    \"VDPAU decoding does not support video \"",
          "2516:                    \"colorspace\\n\");",
          "2517:             return -1;",
          "2518:         }",
          "2520:         if (s->avctx->bits_per_raw_sample != h->sps.bit_depth_luma ||",
          "2521:             h->cur_chroma_format_idc != h->sps.chroma_format_idc) {",
          "2522:             if (h->sps.bit_depth_luma >= 8 && h->sps.bit_depth_luma <= 14 && h->sps.bit_depth_luma != 11 && h->sps.bit_depth_luma != 13 &&",
          "2523:                 (h->sps.bit_depth_luma != 9 || !CHROMA422)) {",
          "2524:                 s->avctx->bits_per_raw_sample = h->sps.bit_depth_luma;",
          "2525:                 h->cur_chroma_format_idc = h->sps.chroma_format_idc;",
          "2526:                 h->pixel_shift = h->sps.bit_depth_luma > 8;",
          "2528:                 ff_h264dsp_init(&h->h264dsp, h->sps.bit_depth_luma, h->sps.chroma_format_idc);",
          "2529:                 ff_h264_pred_init(&h->hpc, s->codec_id, h->sps.bit_depth_luma, h->sps.chroma_format_idc);",
          "2530:                 s->dsp.dct_bits = h->sps.bit_depth_luma > 8 ? 32 : 16;",
          "2531:                 ff_dsputil_init(&s->dsp, s->avctx);",
          "2532:             } else {",
          "2533:                 av_log(s->avctx, AV_LOG_ERROR, \"Unsupported bit depth: %d chroma_idc: %d\\n\",",
          "2534:                        h->sps.bit_depth_luma, h->sps.chroma_format_idc);",
          "2535:                 return -1;",
          "2536:             }",
          "2537:         }",
          "",
          "[Added Lines]",
          "2566:         if ((ret = h264_set_parameter_from_sps(h)) < 0)",
          "2567:             return ret;",
          "",
          "---------------"
        ],
        "libavcodec/h264.h||libavcodec/h264.h": [
          "File: libavcodec/h264.h -> libavcodec/h264.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "207:     int bit_depth_chroma;                 ///< bit_depth_chroma_minus8 + 8",
          "208:     int residual_color_transform_flag;    ///< residual_colour_transform_flag",
          "209:     int constraint_set_flags;             ///< constraint_set[0-3]_flag",
          "210: } SPS;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "210:     int new;                              ///< flag to keep track if the decoder context needs re-init due to changed SPS",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "333:     int emu_edge_width;",
          "334:     int emu_edge_height;",
          "336:     SPS sps; ///< current sps",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "337:     unsigned current_sps_id; ///< id of the current SPS",
          "",
          "---------------"
        ],
        "libavcodec/h264_ps.c||libavcodec/h264_ps.c": [
          "File: libavcodec/h264_ps.c -> libavcodec/h264_ps.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "517:                h->sps.bitstream_restriction_flag ? sps->num_reorder_frames : -1",
          "518:                );",
          "519:     }",
          "521:     av_free(h->sps_buffers[sps_id]);",
          "524:     return 0;",
          "525: fail:",
          "526:     av_free(sps);",
          "",
          "[Removed Lines]",
          "522:     h->sps_buffers[sps_id]= sps;",
          "523:     h->sps = *sps;",
          "",
          "[Added Lines]",
          "520:     sps->new = 1;",
          "523:     h->sps_buffers[sps_id] = sps;",
          "524:     h->sps                 = *sps;",
          "525:     h->current_sps_id      = sps_id;",
          "",
          "---------------"
        ],
        "libavfilter/af_asyncts.c||libavfilter/af_asyncts.c": [
          "File: libavfilter/af_asyncts.c -> libavfilter/af_asyncts.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "152:             handle_trimming(ctx);",
          "154:         if (nb_samples = get_delay(s)) {",
          "168:         }",
          "169:     }",
          "",
          "[Removed Lines]",
          "155:         AVFilterBufferRef *buf = ff_get_audio_buffer(link, AV_PERM_WRITE,",
          "156:                                                      nb_samples);",
          "157:         if (!buf)",
          "158:             return AVERROR(ENOMEM);",
          "159:         ret = avresample_convert(s->avr, buf->extended_data,",
          "160:                                  buf->linesize[0], nb_samples, NULL, 0, 0);",
          "161:         if (ret <= 0) {",
          "162:             avfilter_unref_bufferp(&buf);",
          "163:             return (ret < 0) ? ret : AVERROR_EOF;",
          "164:         }",
          "166:         buf->pts = s->pts;",
          "167:         return ff_filter_frame(link, buf);",
          "",
          "[Added Lines]",
          "155:             AVFilterBufferRef *buf = ff_get_audio_buffer(link, AV_PERM_WRITE,",
          "156:                                                          nb_samples);",
          "157:             if (!buf)",
          "158:                 return AVERROR(ENOMEM);",
          "159:             ret = avresample_convert(s->avr, buf->extended_data,",
          "160:                                      buf->linesize[0], nb_samples, NULL, 0, 0);",
          "161:             if (ret <= 0) {",
          "162:                 avfilter_unref_bufferp(&buf);",
          "163:                 return (ret < 0) ? ret : AVERROR_EOF;",
          "164:             }",
          "166:             buf->pts = s->pts;",
          "167:             return ff_filter_frame(link, buf);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "d4e649cca6de9e5b25f8ebb28c82a95bd24a9e9c",
      "candidate_info": {
        "commit_hash": "d4e649cca6de9e5b25f8ebb28c82a95bd24a9e9c",
        "repo": "FFmpeg/FFmpeg",
        "commit_url": "https://github.com/FFmpeg/FFmpeg/commit/d4e649cca6de9e5b25f8ebb28c82a95bd24a9e9c",
        "files": [
          "configure",
          "libavcodec/h264.c",
          "libavcodec/h264.h"
        ],
        "message": "h264: make it possible to compile without error_resilience.\n\nSigned-off-by: Michael Niedermayer <michaelni@gmx.at>",
        "before_after_code_files": [
          "libavcodec/h264.c||libavcodec/h264.c",
          "libavcodec/h264.h||libavcodec/h264.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "libavcodec/h264.c||libavcodec/h264.c",
            "libavcodec/h264.h||libavcodec/h264.h"
          ],
          "candidate": [
            "libavcodec/h264.c||libavcodec/h264.c",
            "libavcodec/h264.h||libavcodec/h264.h"
          ]
        }
      },
      "candidate_diff": {
        "libavcodec/h264.c||libavcodec/h264.c": [
          "File: libavcodec/h264.c -> libavcodec/h264.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1270:     h->ref_cache[1][scan8[7]  + 1] =",
          "1271:     h->ref_cache[1][scan8[13] + 1] = PART_NOT_AVAILABLE;",
          "1274:     er->avctx          = h->avctx;",
          "1275:     er->dsp            = &h->dsp;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1273:     if (CONFIG_ERROR_RESILIENCE) {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1309:     er->dc_val[2] = er->dc_val[1] + c_size;",
          "1310:     for (i = 0; i < yc_size; i++)",
          "1311:         h->dc_val_base[i] = 1024;",
          "1313:     return 0;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1313:     }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1340:     h->dequant_coeff_pps = -1;",
          "1345:     ff_videodsp_init(&h->vdsp, 8);",
          "1347:     memset(h->pps.scaling_matrix4, 16, 6 * 16 * sizeof(uint8_t));",
          "",
          "[Removed Lines]",
          "1342:     h->dsp.dct_bits = 16;",
          "1344:     ff_dsputil_init(&h->dsp, h->avctx);",
          "",
          "[Added Lines]",
          "1344:     if (CONFIG_ERROR_RESILIENCE) {",
          "1345:         h->dsp.dct_bits = 16;",
          "1347:         ff_dsputil_init(&h->dsp, h->avctx);",
          "1348:     }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1765:     h->cur_pic     = *h->cur_pic_ptr;",
          "1766:     h->cur_pic.f.extended_data = h->cur_pic.f.data;",
          "1772:     assert(h->linesize && h->uvlinesize);",
          "",
          "[Removed Lines]",
          "1768:     ff_er_frame_start(&h->er);",
          "1769:     h->er.last_pic =",
          "1770:     h->er.next_pic = NULL;",
          "",
          "[Added Lines]",
          "1772:     if (CONFIG_ERROR_RESILIENCE) {",
          "1773:         ff_er_frame_start(&h->er);",
          "1774:         h->er.last_pic =",
          "1775:         h->er.next_pic = NULL;",
          "1776:     }",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "2781:         h->er.cur_pic  = h->cur_pic_ptr;",
          "2782:         ff_er_frame_end(&h->er);",
          "2783:     }",
          "",
          "[Removed Lines]",
          "2780:     if (!FIELD_PICTURE && h->current_slice && !h->sps.new) {",
          "",
          "[Added Lines]",
          "2786:     if (CONFIG_ERROR_RESILIENCE &&",
          "2787:         !FIELD_PICTURE && h->current_slice && !h->sps.new) {",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "2880:             ff_h264qpel_init(&h->h264qpel, h->sps.bit_depth_luma);",
          "2881:             ff_h264_pred_init(&h->hpc, h->avctx->codec_id, h->sps.bit_depth_luma,",
          "2882:                               h->sps.chroma_format_idc);",
          "2885:             ff_videodsp_init(&h->vdsp, h->sps.bit_depth_luma);",
          "2886:         } else {",
          "2887:             av_log(h->avctx, AV_LOG_ERROR, \"Unsupported bit depth: %d\\n\",",
          "",
          "[Removed Lines]",
          "2883:             h->dsp.dct_bits = h->sps.bit_depth_luma > 8 ? 32 : 16;",
          "2884:             ff_dsputil_init(&h->dsp, h->avctx);",
          "",
          "[Added Lines]",
          "2890:             if (CONFIG_ERROR_RESILIENCE) {",
          "2891:                 h->dsp.dct_bits = h->sps.bit_depth_luma > 8 ? 32 : 16;",
          "2892:                 ff_dsputil_init(&h->dsp, h->avctx);",
          "2893:             }",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "3043:             H264Context *c;",
          "3044:             c = h->thread_context[i] = av_mallocz(sizeof(H264Context));",
          "3045:             c->avctx       = h->avctx;",
          "3047:             c->vdsp        = h->vdsp;",
          "3048:             c->h264dsp     = h->h264dsp;",
          "3049:             c->h264qpel    = h->h264qpel;",
          "",
          "[Removed Lines]",
          "3046:             c->dsp         = h->dsp;",
          "",
          "[Added Lines]",
          "3055:             if (CONFIG_ERROR_RESILIENCE) {",
          "3056:                 c->dsp         = h->dsp;",
          "3057:             }",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "4152: static void er_add_slice(H264Context *h, int startx, int starty,",
          "4153:                          int endx, int endy, int status)",
          "4154: {",
          "4159: }",
          "4161: static int decode_slice(struct AVCodecContext *avctx, void *arg)",
          "",
          "[Removed Lines]",
          "4155:     ERContext *er = &h->er;",
          "4157:     er->ref_count = h->ref_count[0];",
          "4158:     ff_er_add_slice(er, startx, starty, endx, endy, status);",
          "",
          "[Added Lines]",
          "4166:     if (CONFIG_ERROR_RESILIENCE) {",
          "4167:         ERContext *er = &h->er;",
          "4169:         er->ref_count = h->ref_count[0];",
          "4170:         ff_er_add_slice(er, startx, starty, endx, endy, status);",
          "4171:     }",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "4344:         av_assert0(context_count > 0);",
          "4345:         for (i = 1; i < context_count; i++) {",
          "4346:             hx                    = h->thread_context[i];",
          "4348:             hx->x264_build        = h->x264_build;",
          "4349:         }",
          "",
          "[Removed Lines]",
          "4347:             hx->er.error_count  = 0;",
          "",
          "[Added Lines]",
          "4360:             if (CONFIG_ERROR_RESILIENCE) {",
          "4361:                 hx->er.error_count = 0;",
          "4362:             }",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "4357:         h->mb_y              = hx->mb_y;",
          "4358:         h->droppable         = hx->droppable;",
          "4359:         h->picture_structure = hx->picture_structure;",
          "4362:     }",
          "4364:     return 0;",
          "",
          "[Removed Lines]",
          "4360:         for (i = 1; i < context_count; i++)",
          "4361:             h->er.error_count += h->thread_context[i]->er.error_count;",
          "",
          "[Added Lines]",
          "4375:         if (CONFIG_ERROR_RESILIENCE) {",
          "4376:             for (i = 1; i < context_count; i++)",
          "4377:                 h->er.error_count += h->thread_context[i]->er.error_count;",
          "4378:         }",
          "",
          "---------------"
        ],
        "libavcodec/h264.h||libavcodec/h264.h": [
          "File: libavcodec/h264.h -> libavcodec/h264.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "257: typedef struct H264Context {",
          "258:     AVCodecContext *avctx;",
          "260:     VideoDSPContext vdsp;",
          "261:     H264DSPContext h264dsp;",
          "262:     H264ChromaContext h264chroma;",
          "",
          "[Removed Lines]",
          "259:     DSPContext       dsp;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "264:     MotionEstContext me;",
          "265:     ParseContext parse_context;",
          "266:     GetBitContext gb;",
          "267:     ERContext er;",
          "269:     Picture *DPB;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "266:     DSPContext       dsp;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "e5d403720ec4914169f55913a5a5555d908500b6",
      "candidate_info": {
        "commit_hash": "e5d403720ec4914169f55913a5a5555d908500b6",
        "repo": "FFmpeg/FFmpeg",
        "commit_url": "https://github.com/FFmpeg/FFmpeg/commit/e5d403720ec4914169f55913a5a5555d908500b6",
        "files": [
          "libavcodec/h264.c"
        ],
        "message": "h264: K&R formatting cosmetics\n\nAlso remove some disabled code and fix a few comment typos.",
        "before_after_code_files": [
          "libavcodec/h264.c||libavcodec/h264.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "libavcodec/h264.c||libavcodec/h264.c"
          ],
          "candidate": [
            "libavcodec/h264.c||libavcodec/h264.c"
          ]
        }
      },
      "candidate_diff": {
        "libavcodec/h264.c||libavcodec/h264.c": [
          "File: libavcodec/h264.c -> libavcodec/h264.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "42: #include \"vdpau_internal.h\"",
          "43: #include \"libavutil/avassert.h\"",
          "46: #include <assert.h>",
          "50: };",
          "54: };",
          "56: static const enum PixelFormat hwaccel_pixfmt_list_h264_jpeg_420[] = {",
          "",
          "[Removed Lines]",
          "48: static const uint8_t rem6[QP_MAX_NUM+1]={",
          "49: 0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5, 0, 1, 2, 3,",
          "52: static const uint8_t div6[QP_MAX_NUM+1]={",
          "53: 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 9,10,10,10,10,",
          "",
          "[Added Lines]",
          "48: static const uint8_t rem6[QP_MAX_NUM + 1] = {",
          "49:     0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5, 0, 1, 2,",
          "50:     3, 4, 5, 0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5,",
          "51:     0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5, 0, 1, 2, 3,",
          "54: static const uint8_t div6[QP_MAX_NUM + 1] = {",
          "55:     0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 3,  3,  3,",
          "56:     3, 3, 3, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6,  6,  6,",
          "57:     7, 7, 7, 7, 7, 7, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 9, 10, 10, 10, 10,",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "72:     int i;",
          "79:                 return -1;",
          "82:             }",
          "83:         }",
          "84:     }",
          "93:                     return -1;",
          "96:                 }",
          "97:             }",
          "99:     }",
          "101:     return 0;",
          "115:         return -1;",
          "116:     }",
          "122:             return -1;",
          "123:         }",
          "124:     }",
          "130:         }",
          "133:             return -1;",
          "134:         }",
          "135:     }",
          "",
          "[Removed Lines]",
          "68: int ff_h264_check_intra4x4_pred_mode(H264Context *h){",
          "69:     MpegEncContext * const s = &h->s;",
          "70:     static const int8_t top [12]= {-1, 0,LEFT_DC_PRED,-1,-1,-1,-1,-1, 0};",
          "71:     static const int8_t left[12]= { 0,-1, TOP_DC_PRED, 0,-1,-1,-1, 0,-1,DC_128_PRED};",
          "74:     if(!(h->top_samples_available&0x8000)){",
          "75:         for(i=0; i<4; i++){",
          "76:             int status= top[ h->intra4x4_pred_mode_cache[scan8[0] + i] ];",
          "77:             if(status<0){",
          "78:                 av_log(h->s.avctx, AV_LOG_ERROR, \"top block unavailable for requested intra4x4 mode %d at %d %d\\n\", status, s->mb_x, s->mb_y);",
          "80:             } else if(status){",
          "81:                 h->intra4x4_pred_mode_cache[scan8[0] + i]= status;",
          "86:     if((h->left_samples_available&0x8888)!=0x8888){",
          "87:         static const int mask[4]={0x8000,0x2000,0x80,0x20};",
          "88:         for(i=0; i<4; i++){",
          "89:             if(!(h->left_samples_available&mask[i])){",
          "90:                 int status= left[ h->intra4x4_pred_mode_cache[scan8[0] + 8*i] ];",
          "91:                 if(status<0){",
          "92:                     av_log(h->s.avctx, AV_LOG_ERROR, \"left block unavailable for requested intra4x4 mode %d at %d %d\\n\", status, s->mb_x, s->mb_y);",
          "94:                 } else if(status){",
          "95:                     h->intra4x4_pred_mode_cache[scan8[0] + 8*i]= status;",
          "98:         }",
          "102: } //FIXME cleanup like ff_h264_check_intra_pred_mode",
          "108: int ff_h264_check_intra_pred_mode(H264Context *h, int mode, int is_chroma){",
          "109:     MpegEncContext * const s = &h->s;",
          "110:     static const int8_t top [7]= {LEFT_DC_PRED8x8, 1,-1,-1};",
          "111:     static const int8_t left[7]= { TOP_DC_PRED8x8,-1, 2,-1,DC_128_PRED8x8};",
          "113:     if(mode > 6U) {",
          "114:         av_log(h->s.avctx, AV_LOG_ERROR, \"out of range intra chroma pred mode at %d %d\\n\", s->mb_x, s->mb_y);",
          "118:     if(!(h->top_samples_available&0x8000)){",
          "119:         mode= top[ mode ];",
          "120:         if(mode<0){",
          "121:             av_log(h->s.avctx, AV_LOG_ERROR, \"top block unavailable for requested intra mode at %d %d\\n\", s->mb_x, s->mb_y);",
          "126:     if((h->left_samples_available&0x8080) != 0x8080){",
          "127:         mode= left[ mode ];",
          "128:         if(is_chroma && (h->left_samples_available&0x8080)){ //mad cow disease mode, aka MBAFF + constrained_intra_pred",
          "129:             mode= ALZHEIMER_DC_L0T_PRED8x8 + (!(h->left_samples_available&0x8000)) + 2*(mode == DC_128_PRED8x8);",
          "131:         if(mode<0){",
          "132:             av_log(h->s.avctx, AV_LOG_ERROR, \"left block unavailable for requested intra mode at %d %d\\n\", s->mb_x, s->mb_y);",
          "",
          "[Added Lines]",
          "72: int ff_h264_check_intra4x4_pred_mode(H264Context *h)",
          "73: {",
          "74:     MpegEncContext *const s     = &h->s;",
          "75:     static const int8_t top[12] = {",
          "76:         -1, 0, LEFT_DC_PRED, -1, -1, -1, -1, -1, 0",
          "77:     };",
          "78:     static const int8_t left[12] = {",
          "79:         0, -1, TOP_DC_PRED, 0, -1, -1, -1, 0, -1, DC_128_PRED",
          "80:     };",
          "83:     if (!(h->top_samples_available & 0x8000)) {",
          "84:         for (i = 0; i < 4; i++) {",
          "85:             int status = top[h->intra4x4_pred_mode_cache[scan8[0] + i]];",
          "86:             if (status < 0) {",
          "87:                 av_log(h->s.avctx, AV_LOG_ERROR,",
          "88:                        \"top block unavailable for requested intra4x4 mode %d at %d %d\\n\",",
          "89:                        status, s->mb_x, s->mb_y);",
          "91:             } else if (status) {",
          "92:                 h->intra4x4_pred_mode_cache[scan8[0] + i] = status;",
          "97:     if ((h->left_samples_available & 0x8888) != 0x8888) {",
          "98:         static const int mask[4] = { 0x8000, 0x2000, 0x80, 0x20 };",
          "99:         for (i = 0; i < 4; i++)",
          "100:             if (!(h->left_samples_available & mask[i])) {",
          "101:                 int status = left[h->intra4x4_pred_mode_cache[scan8[0] + 8 * i]];",
          "102:                 if (status < 0) {",
          "103:                     av_log(h->s.avctx, AV_LOG_ERROR,",
          "104:                            \"left block unavailable for requested intra4x4 mode %d at %d %d\\n\",",
          "105:                            status, s->mb_x, s->mb_y);",
          "107:                 } else if (status) {",
          "108:                     h->intra4x4_pred_mode_cache[scan8[0] + 8 * i] = status;",
          "114: } // FIXME cleanup like ff_h264_check_intra_pred_mode",
          "120: int ff_h264_check_intra_pred_mode(H264Context *h, int mode, int is_chroma)",
          "121: {",
          "122:     MpegEncContext *const s     = &h->s;",
          "123:     static const int8_t top[7]  = { LEFT_DC_PRED8x8, 1, -1, -1 };",
          "124:     static const int8_t left[7] = { TOP_DC_PRED8x8, -1, 2, -1, DC_128_PRED8x8 };",
          "126:     if (mode > 6U) {",
          "127:         av_log(h->s.avctx, AV_LOG_ERROR,",
          "128:                \"out of range intra chroma pred mode at %d %d\\n\",",
          "129:                s->mb_x, s->mb_y);",
          "133:     if (!(h->top_samples_available & 0x8000)) {",
          "134:         mode = top[mode];",
          "135:         if (mode < 0) {",
          "136:             av_log(h->s.avctx, AV_LOG_ERROR,",
          "137:                    \"top block unavailable for requested intra mode at %d %d\\n\",",
          "138:                    s->mb_x, s->mb_y);",
          "143:     if ((h->left_samples_available & 0x8080) != 0x8080) {",
          "144:         mode = left[mode];",
          "145:         if (is_chroma && (h->left_samples_available & 0x8080)) {",
          "147:             mode = ALZHEIMER_DC_L0T_PRED8x8 +",
          "148:                    (!(h->left_samples_available & 0x8000)) +",
          "149:                    2 * (mode == DC_128_PRED8x8);",
          "151:         if (mode < 0) {",
          "152:             av_log(h->s.avctx, AV_LOG_ERROR,",
          "153:                    \"left block unavailable for requested intra mode at %d %d\\n\",",
          "154:                    s->mb_x, s->mb_y);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "137:     return mode;",
          "138: }",
          "141:     int i, si, di;",
          "142:     uint8_t *dst;",
          "143:     int bufidx;",
          "151: #if HAVE_FAST_UNALIGNED",
          "161:             continue;",
          "164: #else",
          "169: #endif",
          "174:             }",
          "175:             break;",
          "176:         }",
          "178:     }",
          "183:         return src;",
          "184:     }",
          "191:         return NULL;",
          "195:     memcpy(dst, src, i);",
          "207:                 continue;",
          "209:                 goto nsc;",
          "210:         }",
          "213:     }",
          "216: nsc:",
          "223:     return dst;",
          "224: }",
          "",
          "[Removed Lines]",
          "140: const uint8_t *ff_h264_decode_nal(H264Context *h, const uint8_t *src, int *dst_length, int *consumed, int length){",
          "146:     h->nal_ref_idc= src[0]>>5;",
          "147:     h->nal_unit_type= src[0]&0x1F;",
          "149:     src++; length--;",
          "152: # if HAVE_FAST_64BIT",
          "153: #   define RS 7",
          "154:     for(i=0; i+1<length; i+=9){",
          "155:         if(!((~AV_RN64A(src+i) & (AV_RN64A(src+i) - 0x0100010001000101ULL)) & 0x8000800080008080ULL))",
          "156: # else",
          "157: #   define RS 3",
          "158:     for(i=0; i+1<length; i+=5){",
          "159:         if(!((~AV_RN32A(src+i) & (AV_RN32A(src+i) - 0x01000101U)) & 0x80008080U))",
          "160: # endif",
          "162:         if(i>0 && !src[i]) i--;",
          "163:         while(src[i]) i++;",
          "165: #   define RS 0",
          "166:     for(i=0; i+1<length; i+=2){",
          "167:         if(src[i]) continue;",
          "168:         if(i>0 && src[i-1]==0) i--;",
          "170:         if(i+2<length && src[i+1]==0 && src[i+2]<=3){",
          "171:             if(src[i+2]!=3){",
          "173:                 length=i;",
          "177:         i-= RS;",
          "180:     if(i>=length-1){ //no escaped 0",
          "186:     bufidx = h->nal_unit_type == NAL_DPC ? 1 : 0; // use second escape buffer for inter data",
          "187:     av_fast_malloc(&h->rbsp_buffer[bufidx], &h->rbsp_buffer_size[bufidx], length+FF_INPUT_BUFFER_PADDING_SIZE);",
          "188:     dst= h->rbsp_buffer[bufidx];",
          "190:     if (dst == NULL){",
          "192:     }",
          "196:     si=di=i;",
          "197:     while(si+2<length){",
          "199:         if(src[si+2]>3){",
          "200:             dst[di++]= src[si++];",
          "201:             dst[di++]= src[si++];",
          "202:         }else if(src[si]==0 && src[si+1]==0){",
          "203:             if(src[si+2]==3){ //escape",
          "204:                 dst[di++]= 0;",
          "205:                 dst[di++]= 0;",
          "206:                 si+=3;",
          "208:             }else //next start code",
          "212:         dst[di++]= src[si++];",
          "214:     while(si<length)",
          "215:         dst[di++]= src[si++];",
          "218:     memset(dst+di, 0, FF_INPUT_BUFFER_PADDING_SIZE);",
          "",
          "[Added Lines]",
          "162: const uint8_t *ff_h264_decode_nal(H264Context *h, const uint8_t *src,",
          "163:                                   int *dst_length, int *consumed, int length)",
          "164: {",
          "170:     h->nal_ref_idc   = src[0] >> 5;",
          "171:     h->nal_unit_type = src[0] & 0x1F;",
          "173:     src++;",
          "174:     length--;",
          "177: #if HAVE_FAST_64BIT",
          "178: #define RS 7",
          "179:     for (i = 0; i + 1 < length; i += 9) {",
          "180:         if (!((~AV_RN64A(src + i) &",
          "181:                (AV_RN64A(src + i) - 0x0100010001000101ULL)) &",
          "182:               0x8000800080008080ULL))",
          "183: #else",
          "184: #define RS 3",
          "185:     for (i = 0; i + 1 < length; i += 5) {",
          "186:         if (!((~AV_RN32A(src + i) &",
          "187:                (AV_RN32A(src + i) - 0x01000101U)) &",
          "188:               0x80008080U))",
          "189: #endif",
          "191:         if (i > 0 && !src[i])",
          "192:             i--;",
          "193:         while (src[i])",
          "194:             i++;",
          "196: #define RS 0",
          "197:     for (i = 0; i + 1 < length; i += 2) {",
          "198:         if (src[i])",
          "199:             continue;",
          "200:         if (i > 0 && src[i - 1] == 0)",
          "201:             i--;",
          "203:         if (i + 2 < length && src[i + 1] == 0 && src[i + 2] <= 3) {",
          "204:             if (src[i + 2] != 3) {",
          "206:                 length = i;",
          "210:         i -= RS;",
          "213:     if (i >= length - 1) { // no escaped 0",
          "220:     bufidx = h->nal_unit_type == NAL_DPC ? 1 : 0;",
          "221:     av_fast_malloc(&h->rbsp_buffer[bufidx], &h->rbsp_buffer_size[bufidx],",
          "222:                    length + FF_INPUT_BUFFER_PADDING_SIZE);",
          "223:     dst = h->rbsp_buffer[bufidx];",
          "225:     if (dst == NULL)",
          "230:     si = di = i;",
          "231:     while (si + 2 < length) {",
          "233:         if (src[si + 2] > 3) {",
          "234:             dst[di++] = src[si++];",
          "235:             dst[di++] = src[si++];",
          "236:         } else if (src[si] == 0 && src[si + 1] == 0) {",
          "237:             if (src[si + 2] == 3) { // escape",
          "238:                 dst[di++]  = 0;",
          "239:                 dst[di++]  = 0;",
          "240:                 si        += 3;",
          "242:             } else // next start code",
          "246:         dst[di++] = src[si++];",
          "248:     while (si < length)",
          "249:         dst[di++] = src[si++];",
          "252:     memset(dst + di, 0, FF_INPUT_BUFFER_PADDING_SIZE);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "232:     int r;",
          "234:     tprintf(h->s.avctx, \"rbsp trailing %X\\n\", v);",
          "239:     }",
          "240:     return 0;",
          "241: }",
          "250:     return FFMAX(abs(top), bottom);",
          "251: }",
          "256:     int my;",
          "269:             my = get_lowest_part_list_y(h, ref, n, height, y_offset, 0);",
          "271:             refs[0][ref_n] = FFMAX(refs[0][ref_n], my);",
          "272:         }",
          "273:     }",
          "281:             my = get_lowest_part_list_y(h, ref, n, height, y_offset, 1);",
          "283:             refs[1][ref_n] = FFMAX(refs[1][ref_n], my);",
          "284:         }",
          "285:     }",
          "",
          "[Removed Lines]",
          "230: static int ff_h264_decode_rbsp_trailing(H264Context *h, const uint8_t *src){",
          "231:     int v= *src;",
          "236:     for(r=1; r<9; r++){",
          "237:         if(v&1) return r;",
          "238:         v>>=1;",
          "243: static inline int get_lowest_part_list_y(H264Context *h, Picture *pic, int n, int height,",
          "244:                                  int y_offset, int list){",
          "245:     int raw_my= h->mv_cache[list][ scan8[n] ][1];",
          "246:     int filter_height= (raw_my&3) ? 2 : 0;",
          "247:     int full_my= (raw_my>>2) + y_offset;",
          "248:     int top = full_my - filter_height, bottom = full_my + height + filter_height;",
          "253: static inline void get_lowest_part_y(H264Context *h, int refs[2][48], int n, int height,",
          "254:                                int y_offset, int list0, int list1, int *nrefs){",
          "255:     MpegEncContext * const s = &h->s;",
          "258:     y_offset += 16*(s->mb_y >> MB_FIELD);",
          "260:     if(list0){",
          "261:         int ref_n = h->ref_cache[0][ scan8[n] ];",
          "262:         Picture *ref= &h->ref_list[0][ref_n];",
          "267:         if (ref->f.thread_opaque != s->current_picture.f.thread_opaque ||",
          "268:            (ref->f.reference & 3) != s->picture_structure) {",
          "270:             if (refs[0][ref_n] < 0) nrefs[0] += 1;",
          "275:     if(list1){",
          "276:         int ref_n = h->ref_cache[1][ scan8[n] ];",
          "277:         Picture *ref= &h->ref_list[1][ref_n];",
          "279:         if (ref->f.thread_opaque != s->current_picture.f.thread_opaque ||",
          "280:            (ref->f.reference & 3) != s->picture_structure) {",
          "282:             if (refs[1][ref_n] < 0) nrefs[1] += 1;",
          "",
          "[Added Lines]",
          "265: static int ff_h264_decode_rbsp_trailing(H264Context *h, const uint8_t *src)",
          "266: {",
          "267:     int v = *src;",
          "272:     for (r = 1; r < 9; r++) {",
          "273:         if (v & 1)",
          "274:             return r;",
          "275:         v >>= 1;",
          "280: static inline int get_lowest_part_list_y(H264Context *h, Picture *pic, int n,",
          "281:                                          int height, int y_offset, int list)",
          "282: {",
          "283:     int raw_my        = h->mv_cache[list][scan8[n]][1];",
          "284:     int filter_height = (raw_my & 3) ? 2 : 0;",
          "285:     int full_my       = (raw_my >> 2) + y_offset;",
          "286:     int top           = full_my - filter_height;",
          "287:     int bottom        = full_my + filter_height + height;",
          "292: static inline void get_lowest_part_y(H264Context *h, int refs[2][48], int n,",
          "293:                                      int height, int y_offset, int list0,",
          "294:                                      int list1, int *nrefs)",
          "295: {",
          "296:     MpegEncContext *const s = &h->s;",
          "299:     y_offset += 16 * (s->mb_y >> MB_FIELD);",
          "301:     if (list0) {",
          "302:         int ref_n    = h->ref_cache[0][scan8[n]];",
          "303:         Picture *ref = &h->ref_list[0][ref_n];",
          "308:         if (ref->f.thread_opaque   != s->current_picture.f.thread_opaque ||",
          "309:             (ref->f.reference & 3) != s->picture_structure) {",
          "311:             if (refs[0][ref_n] < 0)",
          "312:                 nrefs[0] += 1;",
          "317:     if (list1) {",
          "318:         int ref_n    = h->ref_cache[1][scan8[n]];",
          "319:         Picture *ref = &h->ref_list[1][ref_n];",
          "321:         if (ref->f.thread_opaque   != s->current_picture.f.thread_opaque ||",
          "322:             (ref->f.reference & 3) != s->picture_structure) {",
          "324:             if (refs[1][ref_n] < 0)",
          "325:                 nrefs[1] += 1;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "296:     const int mb_type = s->current_picture.f.mb_type[mb_xy];",
          "297:     int refs[2][48];",
          "299:     int ref, list;",
          "301:     memset(refs, -1, sizeof(refs));",
          "304:         get_lowest_part_y(h, refs, 0, 16, 0,",
          "307:         get_lowest_part_y(h, refs, 0, 8, 0,",
          "309:         get_lowest_part_y(h, refs, 8, 8, 8,",
          "312:         get_lowest_part_y(h, refs, 0, 16, 0,",
          "314:         get_lowest_part_y(h, refs, 4, 16, 0,",
          "317:         int i;",
          "319:         assert(IS_8X8(mb_type));",
          "340:                 int j;",
          "341:                 assert(IS_SUB_4X4(sub_mb_type));",
          "346:                 }",
          "347:             }",
          "348:         }",
          "349:     }",
          "353:             int row = refs[list][ref];",
          "357:                 int ref_field_picture = ref_pic->field_picture;",
          "360:                 row <<= MB_MBAFF;",
          "361:                 nrefs[list]--;",
          "372:                 }",
          "373:             }",
          "374:         }",
          "441: }",
          "451: {",
          "466:     int ysh;",
          "483:         qpix_op[luma_xy](dest_y + delta, src_y + delta, h->mb_linesize);",
          "489:         src_cb = pic->f.data[1] + offset;",
          "494:         }",
          "497:             qpix_op[luma_xy](dest_cb + delta, src_cb + delta, h->mb_linesize);",
          "500:         src_cr = pic->f.data[2] + offset;",
          "505:         }",
          "508:             qpix_op[luma_xy](dest_cr + delta, src_cr + delta, h->mb_linesize);",
          "510:         return;",
          "511:     }",
          "513:     ysh = 3 - (chroma_idc == 2 /* yuv422 */);",
          "518:     }",
          "524:         s->dsp.emulated_edge_mc(s->edge_emu_buffer, src_cb, h->mb_uvlinesize,",
          "525:                                 9, 8 * chroma_idc + 1, (mx >> 3), (my >> ysh),",
          "526:                                 pic_width >> 1, pic_height >> (chroma_idc == 1 /* yuv420 */));",
          "528:     }",
          "533:         s->dsp.emulated_edge_mc(s->edge_emu_buffer, src_cr, h->mb_uvlinesize,",
          "534:                                 9, 8 * chroma_idc + 1, (mx >> 3), (my >> ysh),",
          "535:                                 pic_width >> 1, pic_height >> (chroma_idc == 1 /* yuv420 */));",
          "537:     }",
          "538:     chroma_op(dest_cr, src_cr, h->mb_uvlinesize, height >> (chroma_idc == 1 /* yuv420 */),",
          "540: }",
          "549: {",
          "555:     if (chroma_idc == 3 /* yuv444 */) {",
          "558:     } else if (chroma_idc == 2 /* yuv422 */) {",
          "564:     }",
          "570:         mc_dir_part(h, ref, n, square, height, delta, 0,",
          "576:     }",
          "580:         mc_dir_part(h, ref, n, square, height, delta, 1,",
          "583:     }",
          "584: }",
          "595:     int chroma_height;",
          "598:     if (chroma_idc == 3 /* yuv444 */) {",
          "600:         chroma_weight_avg = luma_weight_avg;",
          "604:     } else if (chroma_idc == 2 /* yuv422 */) {",
          "605:         chroma_height = height;",
          "609:         chroma_height = height >> 1;",
          "612:     }",
          "619:         uint8_t *tmp_cb = s->obmc_scratchpad;",
          "620:         uint8_t *tmp_cr = s->obmc_scratchpad + (16 << pixel_shift);",
          "625:         mc_dir_part(h, &h->ref_list[0][refn0], n, square, height, delta, 0,",
          "626:                     dest_y, dest_cb, dest_cr,",
          "",
          "[Removed Lines]",
          "293: static void await_references(H264Context *h){",
          "294:     MpegEncContext * const s = &h->s;",
          "295:     const int mb_xy= h->mb_xy;",
          "298:     int nrefs[2] = {0};",
          "303:     if(IS_16X16(mb_type)){",
          "305:                   IS_DIR(mb_type, 0, 0), IS_DIR(mb_type, 0, 1), nrefs);",
          "306:     }else if(IS_16X8(mb_type)){",
          "308:                   IS_DIR(mb_type, 0, 0), IS_DIR(mb_type, 0, 1), nrefs);",
          "310:                   IS_DIR(mb_type, 1, 0), IS_DIR(mb_type, 1, 1), nrefs);",
          "311:     }else if(IS_8X16(mb_type)){",
          "313:                   IS_DIR(mb_type, 0, 0), IS_DIR(mb_type, 0, 1), nrefs);",
          "315:                   IS_DIR(mb_type, 1, 0), IS_DIR(mb_type, 1, 1), nrefs);",
          "316:     }else{",
          "321:         for(i=0; i<4; i++){",
          "322:             const int sub_mb_type= h->sub_mb_type[i];",
          "323:             const int n= 4*i;",
          "324:             int y_offset= (i&2)<<2;",
          "326:             if(IS_SUB_8X8(sub_mb_type)){",
          "327:                 get_lowest_part_y(h, refs, n  , 8, y_offset,",
          "328:                           IS_DIR(sub_mb_type, 0, 0), IS_DIR(sub_mb_type, 0, 1), nrefs);",
          "329:             }else if(IS_SUB_8X4(sub_mb_type)){",
          "330:                 get_lowest_part_y(h, refs, n  , 4, y_offset,",
          "331:                           IS_DIR(sub_mb_type, 0, 0), IS_DIR(sub_mb_type, 0, 1), nrefs);",
          "332:                 get_lowest_part_y(h, refs, n+2, 4, y_offset+4,",
          "333:                           IS_DIR(sub_mb_type, 0, 0), IS_DIR(sub_mb_type, 0, 1), nrefs);",
          "334:             }else if(IS_SUB_4X8(sub_mb_type)){",
          "335:                 get_lowest_part_y(h, refs, n  , 8, y_offset,",
          "336:                           IS_DIR(sub_mb_type, 0, 0), IS_DIR(sub_mb_type, 0, 1), nrefs);",
          "337:                 get_lowest_part_y(h, refs, n+1, 8, y_offset,",
          "338:                           IS_DIR(sub_mb_type, 0, 0), IS_DIR(sub_mb_type, 0, 1), nrefs);",
          "339:             }else{",
          "342:                 for(j=0; j<4; j++){",
          "343:                     int sub_y_offset= y_offset + 2*(j&2);",
          "344:                     get_lowest_part_y(h, refs, n+j, 4, sub_y_offset,",
          "345:                               IS_DIR(sub_mb_type, 0, 0), IS_DIR(sub_mb_type, 0, 1), nrefs);",
          "351:     for(list=h->list_count-1; list>=0; list--){",
          "352:         for(ref=0; ref<48 && nrefs[list]; ref++){",
          "354:             if(row >= 0){",
          "355:                 Picture *ref_pic = &h->ref_list[list][ref];",
          "356:                 int ref_field = ref_pic->f.reference - 1;",
          "358:                 int pic_height = 16*s->mb_height >> ref_field_picture;",
          "363:                 if(!FIELD_PICTURE && ref_field_picture){ // frame referencing two fields",
          "364:                     ff_thread_await_progress(&ref_pic->f, FFMIN((row >> 1) - !(row & 1), pic_height - 1), 1);",
          "365:                     ff_thread_await_progress(&ref_pic->f, FFMIN((row >> 1),              pic_height - 1), 0);",
          "366:                 }else if(FIELD_PICTURE && !ref_field_picture){ // field referencing one field of a frame",
          "367:                     ff_thread_await_progress(&ref_pic->f, FFMIN(row * 2 + ref_field, pic_height - 1), 0);",
          "368:                 }else if(FIELD_PICTURE){",
          "369:                     ff_thread_await_progress(&ref_pic->f, FFMIN(row, pic_height - 1), ref_field);",
          "370:                 }else{",
          "371:                     ff_thread_await_progress(&ref_pic->f, FFMIN(row, pic_height - 1), 0);",
          "375:     }",
          "376: }",
          "378: #if 0",
          "383: static void h264_luma_dc_dct_c(DCTELEM *block/*, int qp*/){",
          "385:     int i;",
          "386:     int temp[16]; //FIXME check if this is a good idea",
          "387:     static const int x_offset[4]={0, 1*stride, 4* stride,  5*stride};",
          "388:     static const int y_offset[4]={0, 2*stride, 8* stride, 10*stride};",
          "390:     for(i=0; i<4; i++){",
          "391:         const int offset= y_offset[i];",
          "392:         const int z0= block[offset+stride*0] + block[offset+stride*4];",
          "393:         const int z1= block[offset+stride*0] - block[offset+stride*4];",
          "394:         const int z2= block[offset+stride*1] - block[offset+stride*5];",
          "395:         const int z3= block[offset+stride*1] + block[offset+stride*5];",
          "397:         temp[4*i+0]= z0+z3;",
          "398:         temp[4*i+1]= z1+z2;",
          "399:         temp[4*i+2]= z1-z2;",
          "400:         temp[4*i+3]= z0-z3;",
          "401:     }",
          "403:     for(i=0; i<4; i++){",
          "404:         const int offset= x_offset[i];",
          "405:         const int z0= temp[4*0+i] + temp[4*2+i];",
          "406:         const int z1= temp[4*0+i] - temp[4*2+i];",
          "407:         const int z2= temp[4*1+i] - temp[4*3+i];",
          "408:         const int z3= temp[4*1+i] + temp[4*3+i];",
          "410:         block[stride*0 +offset]= (z0 + z3)>>1;",
          "411:         block[stride*2 +offset]= (z1 + z2)>>1;",
          "412:         block[stride*8 +offset]= (z1 - z2)>>1;",
          "413:         block[stride*10+offset]= (z0 - z3)>>1;",
          "414:     }",
          "415: }",
          "416: #endif",
          "418: #undef xStride",
          "419: #undef stride",
          "421: #if 0",
          "422: static void chroma_dc_dct_c(DCTELEM *block){",
          "423:     const int stride= 16*2;",
          "424:     const int xStride= 16;",
          "425:     int a,b,c,d,e;",
          "427:     a= block[stride*0 + xStride*0];",
          "428:     b= block[stride*0 + xStride*1];",
          "429:     c= block[stride*1 + xStride*0];",
          "430:     d= block[stride*1 + xStride*1];",
          "432:     e= a-b;",
          "433:     a= a+b;",
          "434:     b= c-d;",
          "435:     c= c+d;",
          "437:     block[stride*0 + xStride*0]= (a+c);",
          "438:     block[stride*0 + xStride*1]= (e+b);",
          "439:     block[stride*1 + xStride*0]= (a-c);",
          "440:     block[stride*1 + xStride*1]= (e-b);",
          "442: #endif",
          "444: static av_always_inline void",
          "445: mc_dir_part(H264Context *h, Picture *pic, int n, int square,",
          "446:             int height, int delta, int list,",
          "447:             uint8_t *dest_y, uint8_t *dest_cb, uint8_t *dest_cr,",
          "448:             int src_x_offset, int src_y_offset,",
          "449:             qpel_mc_func *qpix_op, h264_chroma_mc_func chroma_op,",
          "450:             int pixel_shift, int chroma_idc)",
          "452:     MpegEncContext * const s = &h->s;",
          "453:     const int mx= h->mv_cache[list][ scan8[n] ][0] + src_x_offset*8;",
          "454:     int my=       h->mv_cache[list][ scan8[n] ][1] + src_y_offset*8;",
          "455:     const int luma_xy= (mx&3) + ((my&3)<<2);",
          "456:     int offset = ((mx>>2) << pixel_shift) + (my>>2)*h->mb_linesize;",
          "457:     uint8_t * src_y = pic->f.data[0] + offset;",
          "458:     uint8_t * src_cb, * src_cr;",
          "459:     int extra_width= h->emu_edge_width;",
          "460:     int extra_height= h->emu_edge_height;",
          "461:     int emu=0;",
          "462:     const int full_mx= mx>>2;",
          "463:     const int full_my= my>>2;",
          "464:     const int pic_width  = 16*s->mb_width;",
          "465:     const int pic_height = 16*s->mb_height >> MB_FIELD;",
          "468:     if(mx&7) extra_width -= 3;",
          "469:     if(my&7) extra_height -= 3;",
          "471:     if(   full_mx < 0-extra_width",
          "472:        || full_my < 0-extra_height",
          "473:        || full_mx + 16/*FIXME*/ > pic_width + extra_width",
          "474:        || full_my + 16/*FIXME*/ > pic_height + extra_height){",
          "475:         s->dsp.emulated_edge_mc(s->edge_emu_buffer, src_y - (2 << pixel_shift) - 2*h->mb_linesize, h->mb_linesize,",
          "476:                                 16+5, 16+5/*FIXME*/, full_mx-2, full_my-2, pic_width, pic_height);",
          "477:             src_y= s->edge_emu_buffer + (2 << pixel_shift) + 2*h->mb_linesize;",
          "478:         emu=1;",
          "479:     }",
          "481:     qpix_op[luma_xy](dest_y, src_y, h->mb_linesize); //FIXME try variable height perhaps?",
          "482:     if(!square){",
          "484:     }",
          "486:     if(CONFIG_GRAY && s->flags&CODEC_FLAG_GRAY) return;",
          "488:     if(chroma_idc == 3 /* yuv444 */){",
          "490:         if(emu){",
          "491:             s->dsp.emulated_edge_mc(s->edge_emu_buffer, src_cb - (2 << pixel_shift) - 2*h->mb_linesize, h->mb_linesize,",
          "492:                                     16+5, 16+5/*FIXME*/, full_mx-2, full_my-2, pic_width, pic_height);",
          "493:             src_cb= s->edge_emu_buffer + (2 << pixel_shift) + 2*h->mb_linesize;",
          "495:         qpix_op[luma_xy](dest_cb, src_cb, h->mb_linesize); //FIXME try variable height perhaps?",
          "496:         if(!square){",
          "498:         }",
          "501:         if(emu){",
          "502:             s->dsp.emulated_edge_mc(s->edge_emu_buffer, src_cr - (2 << pixel_shift) - 2*h->mb_linesize, h->mb_linesize,",
          "503:                                     16+5, 16+5/*FIXME*/, full_mx-2, full_my-2, pic_width, pic_height);",
          "504:             src_cr= s->edge_emu_buffer + (2 << pixel_shift) + 2*h->mb_linesize;",
          "506:         qpix_op[luma_xy](dest_cr, src_cr, h->mb_linesize); //FIXME try variable height perhaps?",
          "507:         if(!square){",
          "509:         }",
          "514:     if(chroma_idc == 1 /* yuv420 */ && MB_FIELD){",
          "516:         my += 2 * ((s->mb_y & 1) - (pic->f.reference - 1));",
          "517:         emu |= (my>>3) < 0 || (my>>3) + 8 >= (pic_height>>1);",
          "520:     src_cb = pic->f.data[1] + ((mx >> 3) << pixel_shift) + (my >> ysh) * h->mb_uvlinesize;",
          "521:     src_cr = pic->f.data[2] + ((mx >> 3) << pixel_shift) + (my >> ysh) * h->mb_uvlinesize;",
          "523:     if(emu){",
          "527:             src_cb= s->edge_emu_buffer;",
          "529:     chroma_op(dest_cb, src_cb, h->mb_uvlinesize, height >> (chroma_idc == 1 /* yuv420 */),",
          "530:               mx&7, (my << (chroma_idc == 2 /* yuv422 */)) &7);",
          "532:     if(emu){",
          "536:             src_cr= s->edge_emu_buffer;",
          "539:               mx&7, (my << (chroma_idc == 2 /* yuv422 */)) &7);",
          "542: static av_always_inline void",
          "543: mc_part_std(H264Context *h, int n, int square, int height, int delta,",
          "544:             uint8_t *dest_y, uint8_t *dest_cb, uint8_t *dest_cr,",
          "545:             int x_offset, int y_offset,",
          "546:             qpel_mc_func *qpix_put, h264_chroma_mc_func chroma_put,",
          "547:             qpel_mc_func *qpix_avg, h264_chroma_mc_func chroma_avg,",
          "548:             int list0, int list1, int pixel_shift, int chroma_idc)",
          "550:     MpegEncContext * const s = &h->s;",
          "551:     qpel_mc_func *qpix_op=  qpix_put;",
          "552:     h264_chroma_mc_func chroma_op= chroma_put;",
          "554:     dest_y  += (2*x_offset << pixel_shift) + 2*y_offset*h->mb_linesize;",
          "556:         dest_cb += (2*x_offset << pixel_shift) + 2*y_offset*h->mb_linesize;",
          "557:         dest_cr += (2*x_offset << pixel_shift) + 2*y_offset*h->mb_linesize;",
          "559:         dest_cb += (  x_offset << pixel_shift) + 2*y_offset*h->mb_uvlinesize;",
          "560:         dest_cr += (  x_offset << pixel_shift) + 2*y_offset*h->mb_uvlinesize;",
          "561:     } else /* yuv420 */ {",
          "562:         dest_cb += (  x_offset << pixel_shift) +   y_offset*h->mb_uvlinesize;",
          "563:         dest_cr += (  x_offset << pixel_shift) +   y_offset*h->mb_uvlinesize;",
          "565:     x_offset += 8*s->mb_x;",
          "566:     y_offset += 8*(s->mb_y >> MB_FIELD);",
          "568:     if(list0){",
          "569:         Picture *ref= &h->ref_list[0][ h->ref_cache[0][ scan8[n] ] ];",
          "571:                            dest_y, dest_cb, dest_cr, x_offset, y_offset,",
          "572:                            qpix_op, chroma_op, pixel_shift, chroma_idc);",
          "574:         qpix_op=  qpix_avg;",
          "575:         chroma_op= chroma_avg;",
          "578:     if(list1){",
          "579:         Picture *ref= &h->ref_list[1][ h->ref_cache[1][ scan8[n] ] ];",
          "581:                            dest_y, dest_cb, dest_cr, x_offset, y_offset,",
          "582:                            qpix_op, chroma_op, pixel_shift, chroma_idc);",
          "586: static av_always_inline void",
          "587: mc_part_weighted(H264Context *h, int n, int square, int height, int delta,",
          "588:                  uint8_t *dest_y, uint8_t *dest_cb, uint8_t *dest_cr,",
          "589:                  int x_offset, int y_offset,",
          "590:                  qpel_mc_func *qpix_put, h264_chroma_mc_func chroma_put,",
          "591:                  h264_weight_func luma_weight_op, h264_weight_func chroma_weight_op,",
          "592:                  h264_biweight_func luma_weight_avg, h264_biweight_func chroma_weight_avg,",
          "593:                  int list0, int list1, int pixel_shift, int chroma_idc){",
          "594:     MpegEncContext * const s = &h->s;",
          "597:     dest_y += (2*x_offset << pixel_shift) + 2*y_offset*h->mb_linesize;",
          "599:         chroma_height = height;",
          "601:         chroma_weight_op = luma_weight_op;",
          "602:         dest_cb += (2*x_offset << pixel_shift) + 2*y_offset*h->mb_linesize;",
          "603:         dest_cr += (2*x_offset << pixel_shift) + 2*y_offset*h->mb_linesize;",
          "606:         dest_cb += (  x_offset << pixel_shift) + 2*y_offset*h->mb_uvlinesize;",
          "607:         dest_cr += (  x_offset << pixel_shift) + 2*y_offset*h->mb_uvlinesize;",
          "608:     } else /* yuv420 */ {",
          "610:         dest_cb += (  x_offset << pixel_shift) +   y_offset*h->mb_uvlinesize;",
          "611:         dest_cr += (  x_offset << pixel_shift) +   y_offset*h->mb_uvlinesize;",
          "613:     x_offset += 8*s->mb_x;",
          "614:     y_offset += 8*(s->mb_y >> MB_FIELD);",
          "616:     if(list0 && list1){",
          "621:         uint8_t *tmp_y  = s->obmc_scratchpad + 16*h->mb_uvlinesize;",
          "622:         int refn0 = h->ref_cache[0][ scan8[n] ];",
          "623:         int refn1 = h->ref_cache[1][ scan8[n] ];",
          "",
          "[Added Lines]",
          "336: static void await_references(H264Context *h)",
          "337: {",
          "338:     MpegEncContext *const s = &h->s;",
          "339:     const int mb_xy   = h->mb_xy;",
          "342:     int nrefs[2] = { 0 };",
          "347:     if (IS_16X16(mb_type)) {",
          "349:                           IS_DIR(mb_type, 0, 0), IS_DIR(mb_type, 0, 1), nrefs);",
          "350:     } else if (IS_16X8(mb_type)) {",
          "352:                           IS_DIR(mb_type, 0, 0), IS_DIR(mb_type, 0, 1), nrefs);",
          "354:                           IS_DIR(mb_type, 1, 0), IS_DIR(mb_type, 1, 1), nrefs);",
          "355:     } else if (IS_8X16(mb_type)) {",
          "357:                           IS_DIR(mb_type, 0, 0), IS_DIR(mb_type, 0, 1), nrefs);",
          "359:                           IS_DIR(mb_type, 1, 0), IS_DIR(mb_type, 1, 1), nrefs);",
          "360:     } else {",
          "365:         for (i = 0; i < 4; i++) {",
          "366:             const int sub_mb_type = h->sub_mb_type[i];",
          "367:             const int n           = 4 * i;",
          "368:             int y_offset          = (i & 2) << 2;",
          "370:             if (IS_SUB_8X8(sub_mb_type)) {",
          "371:                 get_lowest_part_y(h, refs, n, 8, y_offset,",
          "372:                                   IS_DIR(sub_mb_type, 0, 0),",
          "373:                                   IS_DIR(sub_mb_type, 0, 1),",
          "374:                                   nrefs);",
          "375:             } else if (IS_SUB_8X4(sub_mb_type)) {",
          "376:                 get_lowest_part_y(h, refs, n, 4, y_offset,",
          "377:                                   IS_DIR(sub_mb_type, 0, 0),",
          "378:                                   IS_DIR(sub_mb_type, 0, 1),",
          "379:                                   nrefs);",
          "380:                 get_lowest_part_y(h, refs, n + 2, 4, y_offset + 4,",
          "381:                                   IS_DIR(sub_mb_type, 0, 0),",
          "382:                                   IS_DIR(sub_mb_type, 0, 1),",
          "383:                                   nrefs);",
          "384:             } else if (IS_SUB_4X8(sub_mb_type)) {",
          "385:                 get_lowest_part_y(h, refs, n, 8, y_offset,",
          "386:                                   IS_DIR(sub_mb_type, 0, 0),",
          "387:                                   IS_DIR(sub_mb_type, 0, 1),",
          "388:                                   nrefs);",
          "389:                 get_lowest_part_y(h, refs, n + 1, 8, y_offset,",
          "390:                                   IS_DIR(sub_mb_type, 0, 0),",
          "391:                                   IS_DIR(sub_mb_type, 0, 1),",
          "392:                                   nrefs);",
          "393:             } else {",
          "396:                 for (j = 0; j < 4; j++) {",
          "397:                     int sub_y_offset = y_offset + 2 * (j & 2);",
          "398:                     get_lowest_part_y(h, refs, n + j, 4, sub_y_offset,",
          "399:                                       IS_DIR(sub_mb_type, 0, 0),",
          "400:                                       IS_DIR(sub_mb_type, 0, 1),",
          "401:                                       nrefs);",
          "407:     for (list = h->list_count - 1; list >= 0; list--)",
          "408:         for (ref = 0; ref < 48 && nrefs[list]; ref++) {",
          "410:             if (row >= 0) {",
          "411:                 Picture *ref_pic      = &h->ref_list[list][ref];",
          "412:                 int ref_field         = ref_pic->f.reference - 1;",
          "414:                 int pic_height        = 16 * s->mb_height >> ref_field_picture;",
          "419:                 if (!FIELD_PICTURE && ref_field_picture) { // frame referencing two fields",
          "420:                     ff_thread_await_progress(&ref_pic->f,",
          "421:                                              FFMIN((row >> 1) - !(row & 1),",
          "422:                                                    pic_height - 1),",
          "423:                                              1);",
          "424:                     ff_thread_await_progress(&ref_pic->f,",
          "425:                                              FFMIN((row >> 1), pic_height - 1),",
          "426:                                              0);",
          "427:                 } else if (FIELD_PICTURE && !ref_field_picture) { // field referencing one field of a frame",
          "428:                     ff_thread_await_progress(&ref_pic->f,",
          "429:                                              FFMIN(row * 2 + ref_field,",
          "430:                                                    pic_height - 1),",
          "431:                                              0);",
          "432:                 } else if (FIELD_PICTURE) {",
          "433:                     ff_thread_await_progress(&ref_pic->f,",
          "434:                                              FFMIN(row, pic_height - 1),",
          "435:                                              ref_field);",
          "436:                 } else {",
          "437:                     ff_thread_await_progress(&ref_pic->f,",
          "438:                                              FFMIN(row, pic_height - 1),",
          "439:                                              0);",
          "445: static av_always_inline void mc_dir_part(H264Context *h, Picture *pic,",
          "446:                                          int n, int square, int height,",
          "447:                                          int delta, int list,",
          "448:                                          uint8_t *dest_y, uint8_t *dest_cb,",
          "449:                                          uint8_t *dest_cr,",
          "450:                                          int src_x_offset, int src_y_offset,",
          "451:                                          qpel_mc_func *qpix_op,",
          "452:                                          h264_chroma_mc_func chroma_op,",
          "453:                                          int pixel_shift, int chroma_idc)",
          "455:     MpegEncContext *const s = &h->s;",
          "456:     const int mx      = h->mv_cache[list][scan8[n]][0] + src_x_offset * 8;",
          "457:     int my            = h->mv_cache[list][scan8[n]][1] + src_y_offset * 8;",
          "458:     const int luma_xy = (mx & 3) + ((my & 3) << 2);",
          "459:     int offset        = ((mx >> 2) << pixel_shift) + (my >> 2) * h->mb_linesize;",
          "460:     uint8_t *src_y    = pic->f.data[0] + offset;",
          "461:     uint8_t *src_cb, *src_cr;",
          "462:     int extra_width  = h->emu_edge_width;",
          "463:     int extra_height = h->emu_edge_height;",
          "464:     int emu = 0;",
          "465:     const int full_mx    = mx >> 2;",
          "466:     const int full_my    = my >> 2;",
          "467:     const int pic_width  = 16 * s->mb_width;",
          "468:     const int pic_height = 16 * s->mb_height >> MB_FIELD;",
          "471:     if (mx & 7)",
          "472:         extra_width -= 3;",
          "473:     if (my & 7)",
          "474:         extra_height -= 3;",
          "476:     if (full_mx                <          0 - extra_width  ||",
          "477:         full_my                <          0 - extra_height ||",
          "478:         full_mx + 16 /*FIXME*/ > pic_width  + extra_width  ||",
          "479:         full_my + 16 /*FIXME*/ > pic_height + extra_height) {",
          "480:         s->dsp.emulated_edge_mc(s->edge_emu_buffer,",
          "481:                                 src_y - (2 << pixel_shift) - 2 * h->mb_linesize,",
          "482:                                 h->mb_linesize,",
          "483:                                 16 + 5, 16 + 5 /*FIXME*/, full_mx - 2,",
          "484:                                 full_my - 2, pic_width, pic_height);",
          "485:         src_y = s->edge_emu_buffer + (2 << pixel_shift) + 2 * h->mb_linesize;",
          "486:         emu   = 1;",
          "487:     }",
          "489:     qpix_op[luma_xy](dest_y, src_y, h->mb_linesize); // FIXME try variable height perhaps?",
          "490:     if (!square)",
          "493:     if (CONFIG_GRAY && s->flags & CODEC_FLAG_GRAY)",
          "494:         return;",
          "496:     if (chroma_idc == 3 /* yuv444 */) {",
          "498:         if (emu) {",
          "499:             s->dsp.emulated_edge_mc(s->edge_emu_buffer,",
          "500:                                     src_cb - (2 << pixel_shift) - 2 * h->mb_linesize,",
          "501:                                     h->mb_linesize,",
          "502:                                     16 + 5, 16 + 5 /*FIXME*/,",
          "503:                                     full_mx - 2, full_my - 2,",
          "504:                                     pic_width, pic_height);",
          "505:             src_cb = s->edge_emu_buffer + (2 << pixel_shift) + 2 * h->mb_linesize;",
          "507:         qpix_op[luma_xy](dest_cb, src_cb, h->mb_linesize); // FIXME try variable height perhaps?",
          "508:         if (!square)",
          "512:         if (emu) {",
          "513:             s->dsp.emulated_edge_mc(s->edge_emu_buffer,",
          "514:                                     src_cr - (2 << pixel_shift) - 2 * h->mb_linesize,",
          "515:                                     h->mb_linesize,",
          "516:                                     16 + 5, 16 + 5 /*FIXME*/,",
          "517:                                     full_mx - 2, full_my - 2,",
          "518:                                     pic_width, pic_height);",
          "519:             src_cr = s->edge_emu_buffer + (2 << pixel_shift) + 2 * h->mb_linesize;",
          "521:         qpix_op[luma_xy](dest_cr, src_cr, h->mb_linesize); // FIXME try variable height perhaps?",
          "522:         if (!square)",
          "528:     if (chroma_idc == 1 /* yuv420 */ && MB_FIELD) {",
          "530:         my  += 2 * ((s->mb_y & 1) - (pic->f.reference - 1));",
          "531:         emu |= (my >> 3) < 0 || (my >> 3) + 8 >= (pic_height >> 1);",
          "534:     src_cb = pic->f.data[1] + ((mx >> 3) << pixel_shift) +",
          "535:              (my >> ysh) * h->mb_uvlinesize;",
          "536:     src_cr = pic->f.data[2] + ((mx >> 3) << pixel_shift) +",
          "537:              (my >> ysh) * h->mb_uvlinesize;",
          "539:     if (emu) {",
          "543:         src_cb = s->edge_emu_buffer;",
          "545:     chroma_op(dest_cb, src_cb, h->mb_uvlinesize,",
          "546:               height >> (chroma_idc == 1 /* yuv420 */),",
          "547:               mx & 7, (my << (chroma_idc == 2 /* yuv422 */)) & 7);",
          "549:     if (emu) {",
          "553:         src_cr = s->edge_emu_buffer;",
          "556:               mx & 7, (my << (chroma_idc == 2 /* yuv422 */)) & 7);",
          "559: static av_always_inline void mc_part_std(H264Context *h, int n, int square,",
          "560:                                          int height, int delta,",
          "561:                                          uint8_t *dest_y, uint8_t *dest_cb,",
          "562:                                          uint8_t *dest_cr,",
          "563:                                          int x_offset, int y_offset,",
          "564:                                          qpel_mc_func *qpix_put,",
          "565:                                          h264_chroma_mc_func chroma_put,",
          "566:                                          qpel_mc_func *qpix_avg,",
          "567:                                          h264_chroma_mc_func chroma_avg,",
          "568:                                          int list0, int list1,",
          "569:                                          int pixel_shift, int chroma_idc)",
          "571:     MpegEncContext *const s       = &h->s;",
          "572:     qpel_mc_func *qpix_op         = qpix_put;",
          "573:     h264_chroma_mc_func chroma_op = chroma_put;",
          "575:     dest_y += (2 * x_offset << pixel_shift) + 2 * y_offset * h->mb_linesize;",
          "577:         dest_cb += (2 * x_offset << pixel_shift) + 2 * y_offset * h->mb_linesize;",
          "578:         dest_cr += (2 * x_offset << pixel_shift) + 2 * y_offset * h->mb_linesize;",
          "580:         dest_cb += (x_offset << pixel_shift) + 2 * y_offset * h->mb_uvlinesize;",
          "581:         dest_cr += (x_offset << pixel_shift) + 2 * y_offset * h->mb_uvlinesize;",
          "583:         dest_cb += (x_offset << pixel_shift) + y_offset * h->mb_uvlinesize;",
          "584:         dest_cr += (x_offset << pixel_shift) + y_offset * h->mb_uvlinesize;",
          "586:     x_offset += 8 * s->mb_x;",
          "587:     y_offset += 8 * (s->mb_y >> MB_FIELD);",
          "589:     if (list0) {",
          "590:         Picture *ref = &h->ref_list[0][h->ref_cache[0][scan8[n]]];",
          "592:                     dest_y, dest_cb, dest_cr, x_offset, y_offset,",
          "593:                     qpix_op, chroma_op, pixel_shift, chroma_idc);",
          "595:         qpix_op   = qpix_avg;",
          "596:         chroma_op = chroma_avg;",
          "599:     if (list1) {",
          "600:         Picture *ref = &h->ref_list[1][h->ref_cache[1][scan8[n]]];",
          "602:                     dest_y, dest_cb, dest_cr, x_offset, y_offset,",
          "603:                     qpix_op, chroma_op, pixel_shift, chroma_idc);",
          "607: static av_always_inline void mc_part_weighted(H264Context *h, int n, int square,",
          "608:                                               int height, int delta,",
          "609:                                               uint8_t *dest_y, uint8_t *dest_cb,",
          "610:                                               uint8_t *dest_cr,",
          "611:                                               int x_offset, int y_offset,",
          "612:                                               qpel_mc_func *qpix_put,",
          "613:                                               h264_chroma_mc_func chroma_put,",
          "614:                                               h264_weight_func luma_weight_op,",
          "615:                                               h264_weight_func chroma_weight_op,",
          "616:                                               h264_biweight_func luma_weight_avg,",
          "617:                                               h264_biweight_func chroma_weight_avg,",
          "618:                                               int list0, int list1,",
          "619:                                               int pixel_shift, int chroma_idc)",
          "620: {",
          "621:     MpegEncContext *const s = &h->s;",
          "624:     dest_y += (2 * x_offset << pixel_shift) + 2 * y_offset * h->mb_linesize;",
          "626:         chroma_height     = height;",
          "628:         chroma_weight_op  = luma_weight_op;",
          "629:         dest_cb += (2 * x_offset << pixel_shift) + 2 * y_offset * h->mb_linesize;",
          "630:         dest_cr += (2 * x_offset << pixel_shift) + 2 * y_offset * h->mb_linesize;",
          "633:         dest_cb      += (x_offset << pixel_shift) + 2 * y_offset * h->mb_uvlinesize;",
          "634:         dest_cr      += (x_offset << pixel_shift) + 2 * y_offset * h->mb_uvlinesize;",
          "637:         dest_cb      += (x_offset << pixel_shift) + y_offset * h->mb_uvlinesize;",
          "638:         dest_cr      += (x_offset << pixel_shift) + y_offset * h->mb_uvlinesize;",
          "640:     x_offset += 8 * s->mb_x;",
          "641:     y_offset += 8 * (s->mb_y >> MB_FIELD);",
          "643:     if (list0 && list1) {",
          "648:         uint8_t *tmp_y  = s->obmc_scratchpad + 16 * h->mb_uvlinesize;",
          "649:         int refn0       = h->ref_cache[0][scan8[n]];",
          "650:         int refn1       = h->ref_cache[1][scan8[n]];",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "631:                     x_offset, y_offset, qpix_put, chroma_put,",
          "632:                     pixel_shift, chroma_idc);",
          "636:             int weight1 = 64 - weight0;",
          "639:             chroma_weight_avg(dest_cb, tmp_cb, h->mb_uvlinesize,",
          "640:                               chroma_height, 5, weight0, weight1, 0);",
          "641:             chroma_weight_avg(dest_cr, tmp_cr, h->mb_uvlinesize,",
          "642:                               chroma_height, 5, weight0, weight1, 0);",
          "653:         }",
          "658:         mc_dir_part(h, ref, n, square, height, delta, list,",
          "659:                     dest_y, dest_cb, dest_cr, x_offset, y_offset,",
          "660:                     qpix_put, chroma_put, pixel_shift, chroma_idc);",
          "669:         }",
          "670:     }",
          "671: }",
          "681: {",
          "685:         mc_part_weighted(h, n, square, height, delta, dest_y, dest_cb, dest_cr,",
          "686:                          x_offset, y_offset, qpix_put, chroma_put,",
          "687:                          weight_op[0], weight_op[1], weight_avg[0],",
          "",
          "[Removed Lines]",
          "634:         if(h->use_weight == 2){",
          "635:             int weight0 = h->implicit_weight[refn0][refn1][s->mb_y&1];",
          "637:             luma_weight_avg(  dest_y,  tmp_y,  h->  mb_linesize,",
          "638:                               height,        5, weight0, weight1, 0);",
          "643:         }else{",
          "644:             luma_weight_avg(dest_y, tmp_y, h->mb_linesize, height, h->luma_log2_weight_denom,",
          "645:                             h->luma_weight[refn0][0][0] , h->luma_weight[refn1][1][0],",
          "646:                             h->luma_weight[refn0][0][1] + h->luma_weight[refn1][1][1]);",
          "647:             chroma_weight_avg(dest_cb, tmp_cb, h->mb_uvlinesize, chroma_height, h->chroma_log2_weight_denom,",
          "648:                             h->chroma_weight[refn0][0][0][0] , h->chroma_weight[refn1][1][0][0],",
          "649:                             h->chroma_weight[refn0][0][0][1] + h->chroma_weight[refn1][1][0][1]);",
          "650:             chroma_weight_avg(dest_cr, tmp_cr, h->mb_uvlinesize, chroma_height, h->chroma_log2_weight_denom,",
          "651:                             h->chroma_weight[refn0][0][1][0] , h->chroma_weight[refn1][1][1][0],",
          "652:                             h->chroma_weight[refn0][0][1][1] + h->chroma_weight[refn1][1][1][1]);",
          "654:     }else{",
          "655:         int list = list1 ? 1 : 0;",
          "656:         int refn = h->ref_cache[list][ scan8[n] ];",
          "657:         Picture *ref= &h->ref_list[list][refn];",
          "662:         luma_weight_op(dest_y, h->mb_linesize, height, h->luma_log2_weight_denom,",
          "663:                        h->luma_weight[refn][list][0], h->luma_weight[refn][list][1]);",
          "664:         if(h->use_weight_chroma){",
          "665:             chroma_weight_op(dest_cb, h->mb_uvlinesize, chroma_height, h->chroma_log2_weight_denom,",
          "666:                              h->chroma_weight[refn][list][0][0], h->chroma_weight[refn][list][0][1]);",
          "667:             chroma_weight_op(dest_cr, h->mb_uvlinesize, chroma_height, h->chroma_log2_weight_denom,",
          "668:                              h->chroma_weight[refn][list][1][0], h->chroma_weight[refn][list][1][1]);",
          "673: static av_always_inline void",
          "674: mc_part(H264Context *h, int n, int square, int height, int delta,",
          "675:         uint8_t *dest_y, uint8_t *dest_cb, uint8_t *dest_cr,",
          "676:         int x_offset, int y_offset,",
          "677:         qpel_mc_func *qpix_put, h264_chroma_mc_func chroma_put,",
          "678:         qpel_mc_func *qpix_avg, h264_chroma_mc_func chroma_avg,",
          "679:         h264_weight_func *weight_op, h264_biweight_func *weight_avg,",
          "680:         int list0, int list1, int pixel_shift, int chroma_idc)",
          "682:     if((h->use_weight==2 && list0 && list1",
          "683:         && (h->implicit_weight[ h->ref_cache[0][scan8[n]] ][ h->ref_cache[1][scan8[n]] ][h->s.mb_y&1] != 32))",
          "684:        || h->use_weight==1)",
          "",
          "[Added Lines]",
          "661:         if (h->use_weight == 2) {",
          "662:             int weight0 = h->implicit_weight[refn0][refn1][s->mb_y & 1];",
          "664:             luma_weight_avg(dest_y, tmp_y, h->mb_linesize,",
          "665:                             height, 5, weight0, weight1, 0);",
          "670:         } else {",
          "671:             luma_weight_avg(dest_y, tmp_y, h->mb_linesize, height,",
          "672:                             h->luma_log2_weight_denom,",
          "673:                             h->luma_weight[refn0][0][0],",
          "674:                             h->luma_weight[refn1][1][0],",
          "675:                             h->luma_weight[refn0][0][1] +",
          "676:                             h->luma_weight[refn1][1][1]);",
          "677:             chroma_weight_avg(dest_cb, tmp_cb, h->mb_uvlinesize, chroma_height,",
          "678:                               h->chroma_log2_weight_denom,",
          "679:                               h->chroma_weight[refn0][0][0][0],",
          "680:                               h->chroma_weight[refn1][1][0][0],",
          "681:                               h->chroma_weight[refn0][0][0][1] +",
          "682:                               h->chroma_weight[refn1][1][0][1]);",
          "683:             chroma_weight_avg(dest_cr, tmp_cr, h->mb_uvlinesize, chroma_height,",
          "684:                               h->chroma_log2_weight_denom,",
          "685:                               h->chroma_weight[refn0][0][1][0],",
          "686:                               h->chroma_weight[refn1][1][1][0],",
          "687:                               h->chroma_weight[refn0][0][1][1] +",
          "688:                               h->chroma_weight[refn1][1][1][1]);",
          "690:     } else {",
          "691:         int list     = list1 ? 1 : 0;",
          "692:         int refn     = h->ref_cache[list][scan8[n]];",
          "693:         Picture *ref = &h->ref_list[list][refn];",
          "698:         luma_weight_op(dest_y, h->mb_linesize, height,",
          "699:                        h->luma_log2_weight_denom,",
          "700:                        h->luma_weight[refn][list][0],",
          "701:                        h->luma_weight[refn][list][1]);",
          "702:         if (h->use_weight_chroma) {",
          "703:             chroma_weight_op(dest_cb, h->mb_uvlinesize, chroma_height,",
          "704:                              h->chroma_log2_weight_denom,",
          "705:                              h->chroma_weight[refn][list][0][0],",
          "706:                              h->chroma_weight[refn][list][0][1]);",
          "707:             chroma_weight_op(dest_cr, h->mb_uvlinesize, chroma_height,",
          "708:                              h->chroma_log2_weight_denom,",
          "709:                              h->chroma_weight[refn][list][1][0],",
          "710:                              h->chroma_weight[refn][list][1][1]);",
          "715: static av_always_inline void mc_part(H264Context *h, int n, int square,",
          "716:                                      int height, int delta,",
          "717:                                      uint8_t *dest_y, uint8_t *dest_cb,",
          "718:                                      uint8_t *dest_cr,",
          "719:                                      int x_offset, int y_offset,",
          "720:                                      qpel_mc_func *qpix_put,",
          "721:                                      h264_chroma_mc_func chroma_put,",
          "722:                                      qpel_mc_func *qpix_avg,",
          "723:                                      h264_chroma_mc_func chroma_avg,",
          "724:                                      h264_weight_func *weight_op,",
          "725:                                      h264_biweight_func *weight_avg,",
          "726:                                      int list0, int list1,",
          "727:                                      int pixel_shift, int chroma_idc)",
          "729:     if ((h->use_weight == 2 && list0 && list1 &&",
          "730:          (h->implicit_weight[h->ref_cache[0][scan8[n]]][h->ref_cache[1][scan8[n]]][h->s.mb_y & 1] != 32)) ||",
          "731:         h->use_weight == 1)",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "692:                     chroma_avg, list0, list1, pixel_shift, chroma_idc);",
          "693: }",
          "697: {",
          "701:     const int refn = h->ref_cache[list][scan8[0]];",
          "705:         uint8_t **src = h->ref_list[list][refn].f.data;",
          "708:         if (chroma_idc == 3 /* yuv444 */) {",
          "714:         }",
          "715:     }",
          "716: }",
          "723: {",
          "726:     const int mb_type = s->current_picture.f.mb_type[mb_xy];",
          "728:     assert(IS_INTER(mb_type));",
          "731:         await_references(h);",
          "732:     prefetch_motion(h, 0, pixel_shift, chroma_idc);",
          "735:         mc_part(h, 0, 1, 16, 0, dest_y, dest_cb, dest_cr, 0, 0,",
          "736:                 qpix_put[0], chroma_put[0], qpix_avg[0], chroma_avg[0],",
          "737:                 weight_op, weight_avg,",
          "738:                 IS_DIR(mb_type, 0, 0), IS_DIR(mb_type, 0, 1),",
          "739:                 pixel_shift, chroma_idc);",
          "741:         mc_part(h, 0, 0, 8, 8 << pixel_shift, dest_y, dest_cb, dest_cr, 0, 0,",
          "742:                 qpix_put[1], chroma_put[0], qpix_avg[1], chroma_avg[0],",
          "743:                 weight_op, weight_avg,",
          "",
          "[Removed Lines]",
          "695: static av_always_inline void",
          "696: prefetch_motion(H264Context *h, int list, int pixel_shift, int chroma_idc)",
          "700:     MpegEncContext * const s = &h->s;",
          "702:     if(refn >= 0){",
          "703:         const int mx= (h->mv_cache[list][scan8[0]][0]>>2) + 16*s->mb_x + 8;",
          "704:         const int my= (h->mv_cache[list][scan8[0]][1]>>2) + 16*s->mb_y;",
          "706:         int off= (mx << pixel_shift) + (my + (s->mb_x&3)*4)*h->mb_linesize + (64 << pixel_shift);",
          "707:         s->dsp.prefetch(src[0]+off, s->linesize, 4);",
          "709:             s->dsp.prefetch(src[1]+off, s->linesize, 4);",
          "710:             s->dsp.prefetch(src[2]+off, s->linesize, 4);",
          "711:         }else{",
          "712:             off= ((mx>>1) << pixel_shift) + ((my>>1) + (s->mb_x&7))*s->uvlinesize + (64 << pixel_shift);",
          "713:             s->dsp.prefetch(src[1]+off, src[2]-src[1], 2);",
          "718: static av_always_inline void hl_motion(H264Context *h, uint8_t *dest_y, uint8_t *dest_cb, uint8_t *dest_cr,",
          "719:                       qpel_mc_func (*qpix_put)[16], h264_chroma_mc_func (*chroma_put),",
          "720:                       qpel_mc_func (*qpix_avg)[16], h264_chroma_mc_func (*chroma_avg),",
          "721:                       h264_weight_func *weight_op, h264_biweight_func *weight_avg,",
          "722:                       int pixel_shift, int chroma_idc)",
          "724:     MpegEncContext * const s = &h->s;",
          "725:     const int mb_xy= h->mb_xy;",
          "730:     if(HAVE_THREADS && (s->avctx->active_thread_type & FF_THREAD_FRAME))",
          "734:     if(IS_16X16(mb_type)){",
          "740:     }else if(IS_16X8(mb_type)){",
          "",
          "[Added Lines]",
          "742: static av_always_inline void prefetch_motion(H264Context *h, int list,",
          "743:                                              int pixel_shift, int chroma_idc)",
          "747:     MpegEncContext *const s = &h->s;",
          "749:     if (refn >= 0) {",
          "750:         const int mx  = (h->mv_cache[list][scan8[0]][0] >> 2) + 16 * s->mb_x + 8;",
          "751:         const int my  = (h->mv_cache[list][scan8[0]][1] >> 2) + 16 * s->mb_y;",
          "753:         int off       = (mx << pixel_shift) +",
          "754:                         (my + (s->mb_x & 3) * 4) * h->mb_linesize +",
          "755:                         (64 << pixel_shift);",
          "756:         s->dsp.prefetch(src[0] + off, s->linesize, 4);",
          "758:             s->dsp.prefetch(src[1] + off, s->linesize, 4);",
          "759:             s->dsp.prefetch(src[2] + off, s->linesize, 4);",
          "760:         } else {",
          "761:             off = ((mx >> 1) << pixel_shift) +",
          "762:                   ((my >> 1) + (s->mb_x & 7)) * s->uvlinesize +",
          "763:                   (64 << pixel_shift);",
          "764:             s->dsp.prefetch(src[1] + off, src[2] - src[1], 2);",
          "769: static av_always_inline void hl_motion(H264Context *h, uint8_t *dest_y,",
          "770:                                        uint8_t *dest_cb, uint8_t *dest_cr,",
          "771:                                        qpel_mc_func(*qpix_put)[16],",
          "772:                                        h264_chroma_mc_func(*chroma_put),",
          "773:                                        qpel_mc_func(*qpix_avg)[16],",
          "774:                                        h264_chroma_mc_func(*chroma_avg),",
          "775:                                        h264_weight_func *weight_op,",
          "776:                                        h264_biweight_func *weight_avg,",
          "777:                                        int pixel_shift, int chroma_idc)",
          "779:     MpegEncContext *const s = &h->s;",
          "780:     const int mb_xy   = h->mb_xy;",
          "785:     if (HAVE_THREADS && (s->avctx->active_thread_type & FF_THREAD_FRAME))",
          "789:     if (IS_16X16(mb_type)) {",
          "795:     } else if (IS_16X8(mb_type)) {",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "748:                 weight_op, weight_avg,",
          "749:                 IS_DIR(mb_type, 1, 0), IS_DIR(mb_type, 1, 1),",
          "750:                 pixel_shift, chroma_idc);",
          "753:                 qpix_put[1], chroma_put[1], qpix_avg[1], chroma_avg[1],",
          "754:                 &weight_op[1], &weight_avg[1],",
          "755:                 IS_DIR(mb_type, 0, 0), IS_DIR(mb_type, 0, 1),",
          "756:                 pixel_shift, chroma_idc);",
          "758:                 qpix_put[1], chroma_put[1], qpix_avg[1], chroma_avg[1],",
          "759:                 &weight_op[1], &weight_avg[1],",
          "760:                 IS_DIR(mb_type, 1, 0), IS_DIR(mb_type, 1, 1),",
          "761:                 pixel_shift, chroma_idc);",
          "763:         int i;",
          "765:         assert(IS_8X8(mb_type));",
          "808:                         qpix_put[2], chroma_put[2], qpix_avg[2], chroma_avg[2],",
          "809:                         &weight_op[2], &weight_avg[2],",
          "810:                         IS_DIR(sub_mb_type, 0, 0), IS_DIR(sub_mb_type, 0, 1),",
          "811:                         pixel_shift, chroma_idc);",
          "812:                 }",
          "813:             }",
          "814:         }",
          "",
          "[Removed Lines]",
          "751:     }else if(IS_8X16(mb_type)){",
          "752:         mc_part(h, 0, 0, 16, 8*h->mb_linesize, dest_y, dest_cb, dest_cr, 0, 0,",
          "757:         mc_part(h, 4, 0, 16, 8*h->mb_linesize, dest_y, dest_cb, dest_cr, 4, 0,",
          "762:     }else{",
          "767:         for(i=0; i<4; i++){",
          "768:             const int sub_mb_type= h->sub_mb_type[i];",
          "769:             const int n= 4*i;",
          "770:             int x_offset= (i&1)<<2;",
          "771:             int y_offset= (i&2)<<1;",
          "773:             if(IS_SUB_8X8(sub_mb_type)){",
          "774:                 mc_part(h, n, 1, 8, 0, dest_y, dest_cb, dest_cr, x_offset, y_offset,",
          "775:                     qpix_put[1], chroma_put[1], qpix_avg[1], chroma_avg[1],",
          "776:                     &weight_op[1], &weight_avg[1],",
          "777:                     IS_DIR(sub_mb_type, 0, 0), IS_DIR(sub_mb_type, 0, 1),",
          "778:                     pixel_shift, chroma_idc);",
          "779:             }else if(IS_SUB_8X4(sub_mb_type)){",
          "780:                 mc_part(h, n  , 0, 4, 4 << pixel_shift, dest_y, dest_cb, dest_cr, x_offset, y_offset,",
          "781:                     qpix_put[2], chroma_put[1], qpix_avg[2], chroma_avg[1],",
          "782:                     &weight_op[1], &weight_avg[1],",
          "783:                     IS_DIR(sub_mb_type, 0, 0), IS_DIR(sub_mb_type, 0, 1),",
          "784:                     pixel_shift, chroma_idc);",
          "785:                 mc_part(h, n+2, 0, 4, 4 << pixel_shift, dest_y, dest_cb, dest_cr, x_offset, y_offset+2,",
          "786:                     qpix_put[2], chroma_put[1], qpix_avg[2], chroma_avg[1],",
          "787:                     &weight_op[1], &weight_avg[1],",
          "788:                     IS_DIR(sub_mb_type, 0, 0), IS_DIR(sub_mb_type, 0, 1),",
          "789:                     pixel_shift, chroma_idc);",
          "790:             }else if(IS_SUB_4X8(sub_mb_type)){",
          "791:                 mc_part(h, n  , 0, 8, 4*h->mb_linesize, dest_y, dest_cb, dest_cr, x_offset, y_offset,",
          "792:                     qpix_put[2], chroma_put[2], qpix_avg[2], chroma_avg[2],",
          "793:                     &weight_op[2], &weight_avg[2],",
          "794:                     IS_DIR(sub_mb_type, 0, 0), IS_DIR(sub_mb_type, 0, 1),",
          "795:                     pixel_shift, chroma_idc);",
          "796:                 mc_part(h, n+1, 0, 8, 4*h->mb_linesize, dest_y, dest_cb, dest_cr, x_offset+2, y_offset,",
          "797:                     qpix_put[2], chroma_put[2], qpix_avg[2], chroma_avg[2],",
          "798:                     &weight_op[2], &weight_avg[2],",
          "799:                     IS_DIR(sub_mb_type, 0, 0), IS_DIR(sub_mb_type, 0, 1),",
          "800:                     pixel_shift, chroma_idc);",
          "801:             }else{",
          "802:                 int j;",
          "803:                 assert(IS_SUB_4X4(sub_mb_type));",
          "804:                 for(j=0; j<4; j++){",
          "805:                     int sub_x_offset= x_offset + 2*(j&1);",
          "806:                     int sub_y_offset= y_offset +   (j&2);",
          "807:                     mc_part(h, n+j, 1, 4, 0, dest_y, dest_cb, dest_cr, sub_x_offset, sub_y_offset,",
          "",
          "[Added Lines]",
          "806:     } else if (IS_8X16(mb_type)) {",
          "807:         mc_part(h, 0, 0, 16, 8 * h->mb_linesize, dest_y, dest_cb, dest_cr, 0, 0,",
          "812:         mc_part(h, 4, 0, 16, 8 * h->mb_linesize, dest_y, dest_cb, dest_cr, 4, 0,",
          "817:     } else {",
          "822:         for (i = 0; i < 4; i++) {",
          "823:             const int sub_mb_type = h->sub_mb_type[i];",
          "824:             const int n  = 4 * i;",
          "825:             int x_offset = (i & 1) << 2;",
          "826:             int y_offset = (i & 2) << 1;",
          "828:             if (IS_SUB_8X8(sub_mb_type)) {",
          "829:                 mc_part(h, n, 1, 8, 0, dest_y, dest_cb, dest_cr,",
          "830:                         x_offset, y_offset,",
          "831:                         qpix_put[1], chroma_put[1], qpix_avg[1], chroma_avg[1],",
          "832:                         &weight_op[1], &weight_avg[1],",
          "833:                         IS_DIR(sub_mb_type, 0, 0), IS_DIR(sub_mb_type, 0, 1),",
          "834:                         pixel_shift, chroma_idc);",
          "835:             } else if (IS_SUB_8X4(sub_mb_type)) {",
          "836:                 mc_part(h, n, 0, 4, 4 << pixel_shift, dest_y, dest_cb, dest_cr,",
          "837:                         x_offset, y_offset,",
          "838:                         qpix_put[2], chroma_put[1], qpix_avg[2], chroma_avg[1],",
          "839:                         &weight_op[1], &weight_avg[1],",
          "840:                         IS_DIR(sub_mb_type, 0, 0), IS_DIR(sub_mb_type, 0, 1),",
          "841:                         pixel_shift, chroma_idc);",
          "842:                 mc_part(h, n + 2, 0, 4, 4 << pixel_shift,",
          "843:                         dest_y, dest_cb, dest_cr, x_offset, y_offset + 2,",
          "844:                         qpix_put[2], chroma_put[1], qpix_avg[2], chroma_avg[1],",
          "845:                         &weight_op[1], &weight_avg[1],",
          "846:                         IS_DIR(sub_mb_type, 0, 0), IS_DIR(sub_mb_type, 0, 1),",
          "847:                         pixel_shift, chroma_idc);",
          "848:             } else if (IS_SUB_4X8(sub_mb_type)) {",
          "849:                 mc_part(h, n, 0, 8, 4 * h->mb_linesize,",
          "850:                         dest_y, dest_cb, dest_cr, x_offset, y_offset,",
          "855:                 mc_part(h, n + 1, 0, 8, 4 * h->mb_linesize,",
          "856:                         dest_y, dest_cb, dest_cr, x_offset + 2, y_offset,",
          "857:                         qpix_put[2], chroma_put[2], qpix_avg[2], chroma_avg[2],",
          "858:                         &weight_op[2], &weight_avg[2],",
          "859:                         IS_DIR(sub_mb_type, 0, 0), IS_DIR(sub_mb_type, 0, 1),",
          "860:                         pixel_shift, chroma_idc);",
          "861:             } else {",
          "862:                 int j;",
          "863:                 assert(IS_SUB_4X4(sub_mb_type));",
          "864:                 for (j = 0; j < 4; j++) {",
          "865:                     int sub_x_offset = x_offset + 2 * (j & 1);",
          "866:                     int sub_y_offset = y_offset + (j & 2);",
          "867:                     mc_part(h, n + j, 1, 4, 0,",
          "868:                             dest_y, dest_cb, dest_cr, sub_x_offset, sub_y_offset,",
          "869:                             qpix_put[2], chroma_put[2], qpix_avg[2], chroma_avg[2],",
          "870:                             &weight_op[2], &weight_avg[2],",
          "871:                             IS_DIR(sub_mb_type, 0, 0), IS_DIR(sub_mb_type, 0, 1),",
          "872:                             pixel_shift, chroma_idc);",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "817:     prefetch_motion(h, 1, pixel_shift, chroma_idc);",
          "818: }",
          "826: {",
          "827:     hl_motion(h, dest_y, dest_cb, dest_cr, qpix_put, chroma_put,",
          "828:               qpix_avg, chroma_avg, weight_op, weight_avg, pixel_shift, 1);",
          "829: }",
          "837: {",
          "838:     hl_motion(h, dest_y, dest_cb, dest_cr, qpix_put, chroma_put,",
          "839:               qpix_avg, chroma_avg, weight_op, weight_avg, pixel_shift, 2);",
          "840: }",
          "843:     int i;",
          "844:     H264Context *hx;",
          "",
          "[Removed Lines]",
          "820: static av_always_inline void",
          "821: hl_motion_420(H264Context *h, uint8_t *dest_y, uint8_t *dest_cb, uint8_t *dest_cr,",
          "822:               qpel_mc_func (*qpix_put)[16], h264_chroma_mc_func (*chroma_put),",
          "823:               qpel_mc_func (*qpix_avg)[16], h264_chroma_mc_func (*chroma_avg),",
          "824:               h264_weight_func *weight_op, h264_biweight_func *weight_avg,",
          "825:               int pixel_shift)",
          "831: static av_always_inline void",
          "832: hl_motion_422(H264Context *h, uint8_t *dest_y, uint8_t *dest_cb, uint8_t *dest_cr,",
          "833:               qpel_mc_func (*qpix_put)[16], h264_chroma_mc_func (*chroma_put),",
          "834:               qpel_mc_func (*qpix_avg)[16], h264_chroma_mc_func (*chroma_avg),",
          "835:               h264_weight_func *weight_op, h264_biweight_func *weight_avg,",
          "836:               int pixel_shift)",
          "842: static void free_tables(H264Context *h, int free_rbsp){",
          "",
          "[Added Lines]",
          "881: static av_always_inline void hl_motion_420(H264Context *h, uint8_t *dest_y,",
          "882:                                            uint8_t *dest_cb, uint8_t *dest_cr,",
          "883:                                            qpel_mc_func(*qpix_put)[16],",
          "884:                                            h264_chroma_mc_func(*chroma_put),",
          "885:                                            qpel_mc_func(*qpix_avg)[16],",
          "886:                                            h264_chroma_mc_func(*chroma_avg),",
          "887:                                            h264_weight_func *weight_op,",
          "888:                                            h264_biweight_func *weight_avg,",
          "889:                                            int pixel_shift)",
          "895: static av_always_inline void hl_motion_422(H264Context *h, uint8_t *dest_y,",
          "896:                                            uint8_t *dest_cb, uint8_t *dest_cr,",
          "897:                                            qpel_mc_func(*qpix_put)[16],",
          "898:                                            h264_chroma_mc_func(*chroma_put),",
          "899:                                            qpel_mc_func(*qpix_avg)[16],",
          "900:                                            h264_chroma_mc_func(*chroma_avg),",
          "901:                                            h264_weight_func *weight_op,",
          "902:                                            h264_biweight_func *weight_avg,",
          "903:                                            int pixel_shift)",
          "909: static void free_tables(H264Context *h, int free_rbsp)",
          "910: {",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "851:     av_freep(&h->direct_table);",
          "852:     av_freep(&h->non_zero_count);",
          "853:     av_freep(&h->slice_table_base);",
          "855:     av_freep(&h->list_counts);",
          "857:     av_freep(&h->mb2b_xy);",
          "858:     av_freep(&h->mb2br_xy);",
          "861:         hx = h->thread_context[i];",
          "863:         av_freep(&hx->top_borders[1]);",
          "864:         av_freep(&hx->top_borders[0]);",
          "865:         av_freep(&hx->s.obmc_scratchpad);",
          "867:             av_freep(&hx->rbsp_buffer[1]);",
          "868:             av_freep(&hx->rbsp_buffer[0]);",
          "869:             hx->rbsp_buffer_size[0] = 0;",
          "870:             hx->rbsp_buffer_size[1] = 0;",
          "871:         }",
          "873:     }",
          "874: }",
          "881:         h->dequant8_coeff[i] = h->dequant8_buffer[i];",
          "884:                 h->dequant8_coeff[i] = h->dequant8_buffer[j];",
          "885:                 break;",
          "886:             }",
          "889:             continue;",
          "892:             int shift = div6[q];",
          "898:         }",
          "899:     }",
          "900: }",
          "906:         h->dequant4_coeff[i] = h->dequant4_buffer[i];",
          "909:                 h->dequant4_coeff[i] = h->dequant4_buffer[j];",
          "910:                 break;",
          "911:             }",
          "914:             continue;",
          "917:             int shift = div6[q] + 2;",
          "923:         }",
          "924:     }",
          "925: }",
          "929:     init_dequant4_coeff_table(h);",
          "931:         init_dequant8_coeff_table(h);",
          "940:     }",
          "941: }",
          "974:         }",
          "977:     s->obmc_scratchpad = NULL;",
          "980:         init_dequant_tables(h);",
          "982:     return 0;",
          "983: fail:",
          "984:     free_tables(h, 1);",
          "985:     return -1;",
          "",
          "[Removed Lines]",
          "854:     h->slice_table= NULL;",
          "860:     for(i = 0; i < MAX_THREADS; i++) {",
          "862:         if(!hx) continue;",
          "866:         if (free_rbsp){",
          "872:         if (i) av_freep(&h->thread_context[i]);",
          "876: static void init_dequant8_coeff_table(H264Context *h){",
          "877:     int i,j,q,x;",
          "878:     const int max_qp = 51 + 6*(h->sps.bit_depth_luma-8);",
          "880:     for(i=0; i<6; i++ ){",
          "882:         for(j=0; j<i; j++){",
          "883:             if(!memcmp(h->pps.scaling_matrix8[j], h->pps.scaling_matrix8[i], 64*sizeof(uint8_t))){",
          "887:         }",
          "888:         if(j<i)",
          "891:         for(q=0; q<max_qp+1; q++){",
          "893:             int idx = rem6[q];",
          "894:             for(x=0; x<64; x++)",
          "895:                 h->dequant8_coeff[i][q][(x>>3)|((x&7)<<3)] =",
          "896:                     ((uint32_t)dequant8_coeff_init[idx][ dequant8_coeff_init_scan[((x>>1)&12) | (x&3)] ] *",
          "897:                     h->pps.scaling_matrix8[i][x]) << shift;",
          "902: static void init_dequant4_coeff_table(H264Context *h){",
          "903:     int i,j,q,x;",
          "904:     const int max_qp = 51 + 6*(h->sps.bit_depth_luma-8);",
          "905:     for(i=0; i<6; i++ ){",
          "907:         for(j=0; j<i; j++){",
          "908:             if(!memcmp(h->pps.scaling_matrix4[j], h->pps.scaling_matrix4[i], 16*sizeof(uint8_t))){",
          "912:         }",
          "913:         if(j<i)",
          "916:         for(q=0; q<max_qp+1; q++){",
          "918:             int idx = rem6[q];",
          "919:             for(x=0; x<16; x++)",
          "920:                 h->dequant4_coeff[i][q][(x>>2)|((x<<2)&0xF)] =",
          "921:                     ((uint32_t)dequant4_coeff_init[idx][(x&1) + ((x>>2)&1)] *",
          "922:                     h->pps.scaling_matrix4[i][x]) << shift;",
          "927: static void init_dequant_tables(H264Context *h){",
          "928:     int i,x;",
          "930:     if(h->pps.transform_8x8_mode)",
          "932:     if(h->sps.transform_bypass){",
          "933:         for(i=0; i<6; i++)",
          "934:             for(x=0; x<16; x++)",
          "935:                 h->dequant4_coeff[i][0][x] = 1<<6;",
          "936:         if(h->pps.transform_8x8_mode)",
          "937:             for(i=0; i<6; i++)",
          "938:                 for(x=0; x<64; x++)",
          "939:                     h->dequant8_coeff[i][0][x] = 1<<6;",
          "944: int ff_h264_alloc_tables(H264Context *h){",
          "945:     MpegEncContext * const s = &h->s;",
          "946:     const int big_mb_num= s->mb_stride * (s->mb_height+1);",
          "947:     const int row_mb_num= 2*s->mb_stride*s->avctx->thread_count;",
          "948:     int x,y;",
          "950:     FF_ALLOCZ_OR_GOTO(h->s.avctx, h->intra4x4_pred_mode, row_mb_num * 8  * sizeof(uint8_t), fail)",
          "952:     FF_ALLOCZ_OR_GOTO(h->s.avctx, h->non_zero_count    , big_mb_num * 48 * sizeof(uint8_t), fail)",
          "953:     FF_ALLOCZ_OR_GOTO(h->s.avctx, h->slice_table_base  , (big_mb_num+s->mb_stride) * sizeof(*h->slice_table_base), fail)",
          "954:     FF_ALLOCZ_OR_GOTO(h->s.avctx, h->cbp_table, big_mb_num * sizeof(uint16_t), fail)",
          "956:     FF_ALLOCZ_OR_GOTO(h->s.avctx, h->chroma_pred_mode_table, big_mb_num * sizeof(uint8_t), fail)",
          "957:     FF_ALLOCZ_OR_GOTO(h->s.avctx, h->mvd_table[0], 16*row_mb_num * sizeof(uint8_t), fail);",
          "958:     FF_ALLOCZ_OR_GOTO(h->s.avctx, h->mvd_table[1], 16*row_mb_num * sizeof(uint8_t), fail);",
          "959:     FF_ALLOCZ_OR_GOTO(h->s.avctx, h->direct_table, 4*big_mb_num * sizeof(uint8_t) , fail);",
          "960:     FF_ALLOCZ_OR_GOTO(h->s.avctx, h->list_counts, big_mb_num * sizeof(uint8_t), fail)",
          "962:     memset(h->slice_table_base, -1, (big_mb_num+s->mb_stride)  * sizeof(*h->slice_table_base));",
          "963:     h->slice_table= h->slice_table_base + s->mb_stride*2 + 1;",
          "965:     FF_ALLOCZ_OR_GOTO(h->s.avctx, h->mb2b_xy  , big_mb_num * sizeof(uint32_t), fail);",
          "966:     FF_ALLOCZ_OR_GOTO(h->s.avctx, h->mb2br_xy , big_mb_num * sizeof(uint32_t), fail);",
          "967:     for(y=0; y<s->mb_height; y++){",
          "968:         for(x=0; x<s->mb_width; x++){",
          "969:             const int mb_xy= x + y*s->mb_stride;",
          "970:             const int b_xy = 4*x + 4*y*h->b_stride;",
          "972:             h->mb2b_xy [mb_xy]= b_xy;",
          "973:             h->mb2br_xy[mb_xy]= 8*(FMO ? mb_xy : (mb_xy % (2*s->mb_stride)));",
          "975:     }",
          "979:     if(!h->dequant4_coeff[0])",
          "",
          "[Added Lines]",
          "922:     h->slice_table = NULL;",
          "928:     for (i = 0; i < MAX_THREADS; i++) {",
          "930:         if (!hx)",
          "931:             continue;",
          "935:         if (free_rbsp) {",
          "941:         if (i)",
          "942:             av_freep(&h->thread_context[i]);",
          "946: static void init_dequant8_coeff_table(H264Context *h)",
          "947: {",
          "948:     int i, j, q, x;",
          "949:     const int max_qp = 51 + 6 * (h->sps.bit_depth_luma - 8);",
          "951:     for (i = 0; i < 6; i++) {",
          "953:         for (j = 0; j < i; j++)",
          "954:             if (!memcmp(h->pps.scaling_matrix8[j], h->pps.scaling_matrix8[i],",
          "955:                         64 * sizeof(uint8_t))) {",
          "959:         if (j < i)",
          "962:         for (q = 0; q < max_qp + 1; q++) {",
          "964:             int idx   = rem6[q];",
          "965:             for (x = 0; x < 64; x++)",
          "966:                 h->dequant8_coeff[i][q][(x >> 3) | ((x & 7) << 3)] =",
          "967:                     ((uint32_t)dequant8_coeff_init[idx][dequant8_coeff_init_scan[((x >> 1) & 12) | (x & 3)]] *",
          "968:                      h->pps.scaling_matrix8[i][x]) << shift;",
          "973: static void init_dequant4_coeff_table(H264Context *h)",
          "974: {",
          "975:     int i, j, q, x;",
          "976:     const int max_qp = 51 + 6 * (h->sps.bit_depth_luma - 8);",
          "977:     for (i = 0; i < 6; i++) {",
          "979:         for (j = 0; j < i; j++)",
          "980:             if (!memcmp(h->pps.scaling_matrix4[j], h->pps.scaling_matrix4[i],",
          "981:                         16 * sizeof(uint8_t))) {",
          "985:         if (j < i)",
          "988:         for (q = 0; q < max_qp + 1; q++) {",
          "990:             int idx   = rem6[q];",
          "991:             for (x = 0; x < 16; x++)",
          "992:                 h->dequant4_coeff[i][q][(x >> 2) | ((x << 2) & 0xF)] =",
          "993:                     ((uint32_t)dequant4_coeff_init[idx][(x & 1) + ((x >> 2) & 1)] *",
          "994:                      h->pps.scaling_matrix4[i][x]) << shift;",
          "999: static void init_dequant_tables(H264Context *h)",
          "1000: {",
          "1001:     int i, x;",
          "1003:     if (h->pps.transform_8x8_mode)",
          "1005:     if (h->sps.transform_bypass) {",
          "1006:         for (i = 0; i < 6; i++)",
          "1007:             for (x = 0; x < 16; x++)",
          "1008:                 h->dequant4_coeff[i][0][x] = 1 << 6;",
          "1009:         if (h->pps.transform_8x8_mode)",
          "1010:             for (i = 0; i < 6; i++)",
          "1011:                 for (x = 0; x < 64; x++)",
          "1012:                     h->dequant8_coeff[i][0][x] = 1 << 6;",
          "1016: int ff_h264_alloc_tables(H264Context *h)",
          "1017: {",
          "1018:     MpegEncContext *const s = &h->s;",
          "1019:     const int big_mb_num    = s->mb_stride * (s->mb_height + 1);",
          "1020:     const int row_mb_num    = s->mb_stride * 2 * s->avctx->thread_count;",
          "1021:     int x, y;",
          "1023:     FF_ALLOCZ_OR_GOTO(h->s.avctx, h->intra4x4_pred_mode,",
          "1024:                       row_mb_num * 8 * sizeof(uint8_t), fail)",
          "1025:     FF_ALLOCZ_OR_GOTO(h->s.avctx, h->non_zero_count,",
          "1026:                       big_mb_num * 48 * sizeof(uint8_t), fail)",
          "1027:     FF_ALLOCZ_OR_GOTO(h->s.avctx, h->slice_table_base,",
          "1028:                       (big_mb_num + s->mb_stride) * sizeof(*h->slice_table_base), fail)",
          "1029:     FF_ALLOCZ_OR_GOTO(h->s.avctx, h->cbp_table,",
          "1030:                       big_mb_num * sizeof(uint16_t), fail)",
          "1031:     FF_ALLOCZ_OR_GOTO(h->s.avctx, h->chroma_pred_mode_table,",
          "1032:                       big_mb_num * sizeof(uint8_t), fail)",
          "1033:     FF_ALLOCZ_OR_GOTO(h->s.avctx, h->mvd_table[0],",
          "1034:                       16 * row_mb_num * sizeof(uint8_t), fail);",
          "1035:     FF_ALLOCZ_OR_GOTO(h->s.avctx, h->mvd_table[1],",
          "1036:                       16 * row_mb_num * sizeof(uint8_t), fail);",
          "1037:     FF_ALLOCZ_OR_GOTO(h->s.avctx, h->direct_table,",
          "1038:                       4 * big_mb_num * sizeof(uint8_t), fail);",
          "1039:     FF_ALLOCZ_OR_GOTO(h->s.avctx, h->list_counts,",
          "1040:                       big_mb_num * sizeof(uint8_t), fail)",
          "1042:     memset(h->slice_table_base, -1,",
          "1043:            (big_mb_num + s->mb_stride) * sizeof(*h->slice_table_base));",
          "1044:     h->slice_table = h->slice_table_base + s->mb_stride * 2 + 1;",
          "1046:     FF_ALLOCZ_OR_GOTO(h->s.avctx, h->mb2b_xy,",
          "1047:                       big_mb_num * sizeof(uint32_t), fail);",
          "1048:     FF_ALLOCZ_OR_GOTO(h->s.avctx, h->mb2br_xy,",
          "1049:                       big_mb_num * sizeof(uint32_t), fail);",
          "1050:     for (y = 0; y < s->mb_height; y++)",
          "1051:         for (x = 0; x < s->mb_width; x++) {",
          "1052:             const int mb_xy = x + y * s->mb_stride;",
          "1053:             const int b_xy  = 4 * x + 4 * y * h->b_stride;",
          "1055:             h->mb2b_xy[mb_xy]  = b_xy;",
          "1056:             h->mb2br_xy[mb_xy] = 8 * (FMO ? mb_xy : (mb_xy % (2 * s->mb_stride)));",
          "1061:     if (!h->dequant4_coeff[0])",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "1007: }",
          "1020:     return 0;",
          "1021: fail:",
          "1022:     return -1; // free_tables will clean up for us",
          "1023: }",
          "1025: static int decode_nal_units(H264Context *h, const uint8_t *buf, int buf_size);",
          "1034:     ff_h264dsp_init(&h->h264dsp, 8, 1);",
          "1035:     ff_h264_pred_init(&h->hpc, s->codec_id, 8, 1);",
          "1044: }",
          "1046: int ff_h264_decode_extradata(H264Context *h)",
          "1047: {",
          "1048:     AVCodecContext *avctx = h->s.avctx;",
          "1051:         int i, cnt, nalsize;",
          "1052:         unsigned char *p = avctx->extradata;",
          "1054:         h->is_avc = 1;",
          "1057:             av_log(avctx, AV_LOG_ERROR, \"avcC too short\\n\");",
          "1058:             return -1;",
          "1059:         }",
          "1062:         h->nal_length_size = 2;",
          "1066:         for (i = 0; i < cnt; i++) {",
          "1067:             nalsize = AV_RB16(p) + 2;",
          "1068:             if (p - avctx->extradata + nalsize > avctx->extradata_size)",
          "1069:                 return -1;",
          "1072:                 return -1;",
          "1073:             }",
          "1074:             p += nalsize;",
          "",
          "[Removed Lines]",
          "991: static void clone_tables(H264Context *dst, H264Context *src, int i){",
          "992:     MpegEncContext * const s = &src->s;",
          "993:     dst->intra4x4_pred_mode       = src->intra4x4_pred_mode + i*8*2*s->mb_stride;",
          "994:     dst->non_zero_count           = src->non_zero_count;",
          "995:     dst->slice_table              = src->slice_table;",
          "996:     dst->cbp_table                = src->cbp_table;",
          "997:     dst->mb2b_xy                  = src->mb2b_xy;",
          "998:     dst->mb2br_xy                 = src->mb2br_xy;",
          "999:     dst->chroma_pred_mode_table   = src->chroma_pred_mode_table;",
          "1000:     dst->mvd_table[0]             = src->mvd_table[0] + i*8*2*s->mb_stride;",
          "1001:     dst->mvd_table[1]             = src->mvd_table[1] + i*8*2*s->mb_stride;",
          "1002:     dst->direct_table             = src->direct_table;",
          "1003:     dst->list_counts              = src->list_counts;",
          "1005:     dst->s.obmc_scratchpad = NULL;",
          "1006:     ff_h264_pred_init(&dst->hpc, src->s.codec_id, src->sps.bit_depth_luma, src->sps.chroma_format_idc);",
          "1013: static int context_init(H264Context *h){",
          "1014:     FF_ALLOCZ_OR_GOTO(h->s.avctx, h->top_borders[0], h->s.mb_width * 16*3 * sizeof(uint8_t)*2, fail)",
          "1015:     FF_ALLOCZ_OR_GOTO(h->s.avctx, h->top_borders[1], h->s.mb_width * 16*3 * sizeof(uint8_t)*2, fail)",
          "1017:     h->ref_cache[0][scan8[5 ]+1] = h->ref_cache[0][scan8[7 ]+1] = h->ref_cache[0][scan8[13]+1] =",
          "1018:     h->ref_cache[1][scan8[5 ]+1] = h->ref_cache[1][scan8[7 ]+1] = h->ref_cache[1][scan8[13]+1] = PART_NOT_AVAILABLE;",
          "1027: static av_cold void common_init(H264Context *h){",
          "1028:     MpegEncContext * const s = &h->s;",
          "1030:     s->width = s->avctx->width;",
          "1031:     s->height = s->avctx->height;",
          "1032:     s->codec_id= s->avctx->codec->id;",
          "1037:     h->dequant_coeff_pps= -1;",
          "1038:     s->unrestricted_mv=1;",
          "1040:     ff_dsputil_init(&s->dsp, s->avctx); // needed so that idct permutation is known early",
          "1042:     memset(h->pps.scaling_matrix4, 16, 6*16*sizeof(uint8_t));",
          "1043:     memset(h->pps.scaling_matrix8, 16, 2*64*sizeof(uint8_t));",
          "1050:     if(avctx->extradata[0] == 1){",
          "1056:         if(avctx->extradata_size < 7) {",
          "1064:         cnt = *(p+5) & 0x1f; // Number of sps",
          "1065:         p += 6;",
          "1070:             if(decode_nal_units(h, p, nalsize) < 0) {",
          "1071:                 av_log(avctx, AV_LOG_ERROR, \"Decoding sps %d from avcC failed\\n\", i);",
          "",
          "[Added Lines]",
          "1074: static void clone_tables(H264Context *dst, H264Context *src, int i)",
          "1075: {",
          "1076:     MpegEncContext *const s     = &src->s;",
          "1077:     dst->intra4x4_pred_mode     = src->intra4x4_pred_mode + i * 8 * 2 * s->mb_stride;",
          "1078:     dst->non_zero_count         = src->non_zero_count;",
          "1079:     dst->slice_table            = src->slice_table;",
          "1080:     dst->cbp_table              = src->cbp_table;",
          "1081:     dst->mb2b_xy                = src->mb2b_xy;",
          "1082:     dst->mb2br_xy               = src->mb2br_xy;",
          "1083:     dst->chroma_pred_mode_table = src->chroma_pred_mode_table;",
          "1084:     dst->mvd_table[0]           = src->mvd_table[0] + i * 8 * 2 * s->mb_stride;",
          "1085:     dst->mvd_table[1]           = src->mvd_table[1] + i * 8 * 2 * s->mb_stride;",
          "1086:     dst->direct_table           = src->direct_table;",
          "1087:     dst->list_counts            = src->list_counts;",
          "1088:     dst->s.obmc_scratchpad      = NULL;",
          "1089:     ff_h264_pred_init(&dst->hpc, src->s.codec_id, src->sps.bit_depth_luma,",
          "1090:                       src->sps.chroma_format_idc);",
          "1097: static int context_init(H264Context *h)",
          "1098: {",
          "1099:     FF_ALLOCZ_OR_GOTO(h->s.avctx, h->top_borders[0],",
          "1100:                       h->s.mb_width * 16 * 3 * sizeof(uint8_t) * 2, fail)",
          "1101:     FF_ALLOCZ_OR_GOTO(h->s.avctx, h->top_borders[1],",
          "1102:                       h->s.mb_width * 16 * 3 * sizeof(uint8_t) * 2, fail)",
          "1104:     h->ref_cache[0][scan8[5]  + 1] =",
          "1105:     h->ref_cache[0][scan8[7]  + 1] =",
          "1106:     h->ref_cache[0][scan8[13] + 1] =",
          "1107:     h->ref_cache[1][scan8[5]  + 1] =",
          "1108:     h->ref_cache[1][scan8[7]  + 1] =",
          "1109:     h->ref_cache[1][scan8[13] + 1] = PART_NOT_AVAILABLE;",
          "1119: static av_cold void common_init(H264Context *h)",
          "1120: {",
          "1121:     MpegEncContext *const s = &h->s;",
          "1123:     s->width    = s->avctx->width;",
          "1124:     s->height   = s->avctx->height;",
          "1125:     s->codec_id = s->avctx->codec->id;",
          "1130:     h->dequant_coeff_pps = -1;",
          "1131:     s->unrestricted_mv   = 1;",
          "1134:     ff_dsputil_init(&s->dsp, s->avctx);",
          "1136:     memset(h->pps.scaling_matrix4, 16, 6 * 16 * sizeof(uint8_t));",
          "1137:     memset(h->pps.scaling_matrix8, 16, 2 * 64 * sizeof(uint8_t));",
          "1144:     if (avctx->extradata[0] == 1) {",
          "1150:         if (avctx->extradata_size < 7) {",
          "1158:         cnt = *(p + 5) & 0x1f; // Number of sps",
          "1159:         p  += 6;",
          "1164:             if (decode_nal_units(h, p, nalsize) < 0) {",
          "1165:                 av_log(avctx, AV_LOG_ERROR,",
          "1166:                        \"Decoding sps %d from avcC failed\\n\", i);",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "1080:             if (p - avctx->extradata + nalsize > avctx->extradata_size)",
          "1081:                 return -1;",
          "1082:             if (decode_nal_units(h, p, nalsize) < 0) {",
          "1084:                 return -1;",
          "1085:             }",
          "1086:             p += nalsize;",
          "1087:         }",
          "1089:         h->nal_length_size = (avctx->extradata[4] & 0x03) + 1;",
          "1090:     } else {",
          "1091:         h->is_avc = 0;",
          "1093:             return -1;",
          "1094:     }",
          "1095:     return 0;",
          "1096: }",
          "1101:     int i;",
          "1103:     ff_MPV_decode_defaults(s);",
          "",
          "[Removed Lines]",
          "1083:                 av_log(avctx, AV_LOG_ERROR, \"Decoding pps %d from avcC failed\\n\", i);",
          "1092:         if(decode_nal_units(h, avctx->extradata, avctx->extradata_size) < 0)",
          "1098: av_cold int ff_h264_decode_init(AVCodecContext *avctx){",
          "1099:     H264Context *h= avctx->priv_data;",
          "1100:     MpegEncContext * const s = &h->s;",
          "",
          "[Added Lines]",
          "1178:                 av_log(avctx, AV_LOG_ERROR,",
          "1179:                        \"Decoding pps %d from avcC failed\\n\", i);",
          "1188:         if (decode_nal_units(h, avctx->extradata, avctx->extradata_size) < 0)",
          "1194: av_cold int ff_h264_decode_init(AVCodecContext *avctx)",
          "1195: {",
          "1196:     H264Context *h = avctx->priv_data;",
          "1197:     MpegEncContext *const s = &h->s;",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "1105:     s->avctx = avctx;",
          "1106:     common_init(h);",
          "1113:     s->quarter_sample = 1;",
          "1117:     avctx->chroma_sample_location = AVCHROMA_LOC_LEFT;",
          "",
          "[Removed Lines]",
          "1108:     s->out_format = FMT_H264;",
          "1109:     s->workaround_bugs= avctx->workaround_bugs;",
          "1114:     if(!avctx->has_b_frames)",
          "1115:     s->low_delay= 1;",
          "",
          "[Added Lines]",
          "1205:     s->out_format      = FMT_H264;",
          "1206:     s->workaround_bugs = avctx->workaround_bugs;",
          "1211:     if (!avctx->has_b_frames)",
          "1212:         s->low_delay = 1;",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "1122:     h->sps.bit_depth_luma = avctx->bits_per_raw_sample = 8;",
          "1124:     h->thread_context[0] = h;",
          "1126:     for (i = 0; i < MAX_DELAYED_PIC_COUNT; i++)",
          "1127:         h->last_pocs[i] = INT_MIN;",
          "1130:     ff_h264_reset_sei(h);",
          "1135:         avctx->ticks_per_frame = 2;",
          "1136:     }",
          "1139:         ff_h264_decode_extradata(h))",
          "1140:         return -1;",
          "1143:         s->avctx->has_b_frames = h->sps.num_reorder_frames;",
          "1145:     }",
          "1147:     return 0;",
          "1148: }",
          "1152: {",
          "1153:     int i;",
          "1156:         assert((IN_RANGE(from[i], old_base, sizeof(*old_base)) ||",
          "1158:                 !from[i]));",
          "1159:         to[i] = REBASE_PICTURE(from[i], new_base, old_base);",
          "1160:     }",
          "",
          "[Removed Lines]",
          "1125:     h->outputed_poc = h->next_outputed_poc = INT_MIN;",
          "1128:     h->prev_poc_msb= 1<<16;",
          "1129:     h->x264_build = -1;",
          "1131:     if(avctx->codec_id == CODEC_ID_H264){",
          "1132:         if(avctx->ticks_per_frame == 1){",
          "1133:             s->avctx->time_base.den *=2;",
          "1134:         }",
          "1138:     if(avctx->extradata_size > 0 && avctx->extradata &&",
          "1142:     if(h->sps.bitstream_restriction_flag && s->avctx->has_b_frames < h->sps.num_reorder_frames){",
          "1144:         s->low_delay = 0;",
          "1150: #define IN_RANGE(a, b, size) (((a) >= (b)) && ((a) < ((b)+(size))))",
          "1151: static void copy_picture_range(Picture **to, Picture **from, int count, MpegEncContext *new_base, MpegEncContext *old_base)",
          "1155:     for (i=0; i<count; i++){",
          "1157:                 IN_RANGE(from[i], old_base->picture, sizeof(Picture) * old_base->picture_count) ||",
          "",
          "[Added Lines]",
          "1222:     h->outputed_poc      = h->next_outputed_poc = INT_MIN;",
          "1225:     h->prev_poc_msb = 1 << 16;",
          "1226:     h->x264_build   = -1;",
          "1228:     if (avctx->codec_id == CODEC_ID_H264) {",
          "1229:         if (avctx->ticks_per_frame == 1)",
          "1230:             s->avctx->time_base.den *= 2;",
          "1234:     if (avctx->extradata_size > 0 && avctx->extradata &&",
          "1238:     if (h->sps.bitstream_restriction_flag &&",
          "1239:         s->avctx->has_b_frames < h->sps.num_reorder_frames) {",
          "1241:         s->low_delay           = 0;",
          "1247: #define IN_RANGE(a, b, size) (((a) >= (b)) && ((a) < ((b) + (size))))",
          "1249: static void copy_picture_range(Picture **to, Picture **from, int count,",
          "1250:                                MpegEncContext *new_base,",
          "1251:                                MpegEncContext *old_base)",
          "1255:     for (i = 0; i < count; i++) {",
          "1257:                 IN_RANGE(from[i], old_base->picture,",
          "1258:                          sizeof(Picture) * old_base->picture_count) ||",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "1164: {",
          "1165:     int i;",
          "1172:     }",
          "1173: }",
          "1178:     if (!avctx->internal->is_copy)",
          "1179:         return 0;",
          "",
          "[Removed Lines]",
          "1167:     for (i=0; i<count; i++){",
          "1168:         if (to[i] && !from[i]) av_freep(&to[i]);",
          "1169:         else if (from[i] && !to[i]) to[i] = av_malloc(size);",
          "1171:         if (from[i]) memcpy(to[i], from[i], size);",
          "1175: static int decode_init_thread_copy(AVCodecContext *avctx){",
          "1176:     H264Context *h= avctx->priv_data;",
          "",
          "[Added Lines]",
          "1268:     for (i = 0; i < count; i++) {",
          "1269:         if (to[i] && !from[i])",
          "1270:             av_freep(&to[i]);",
          "1271:         else if (from[i] && !to[i])",
          "1272:             to[i] = av_malloc(size);",
          "1274:         if (from[i])",
          "1275:             memcpy(to[i], from[i], size);",
          "1279: static int decode_init_thread_copy(AVCodecContext *avctx)",
          "1280: {",
          "1281:     H264Context *h = avctx->priv_data;",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "1183:     return 0;",
          "1184: }",
          "1190:     int inited = s->context_initialized, err;",
          "1191:     int i;",
          "1195:     err = ff_mpeg_update_thread_context(dst, src);",
          "1201:             av_freep(h->sps_buffers + i);",
          "1204:             av_freep(h->pps_buffers + i);",
          "1207:         memset(h->sps_buffers, 0, sizeof(h->sps_buffers));",
          "1208:         memset(h->pps_buffers, 0, sizeof(h->pps_buffers));",
          "1209:         if (ff_h264_alloc_tables(h) < 0) {",
          "",
          "[Removed Lines]",
          "1186: #define copy_fields(to, from, start_field, end_field) memcpy(&to->start_field, &from->start_field, (char*)&to->end_field - (char*)&to->start_field)",
          "1187: static int decode_update_thread_context(AVCodecContext *dst, const AVCodecContext *src){",
          "1188:     H264Context *h= dst->priv_data, *h1= src->priv_data;",
          "1189:     MpegEncContext * const s = &h->s, * const s1 = &h1->s;",
          "1193:     if(dst == src || !s1->context_initialized) return 0;",
          "1196:     if(err) return err;",
          "1199:     if(!inited){",
          "1200:         for(i = 0; i < MAX_SPS_COUNT; i++)",
          "1203:         for(i = 0; i < MAX_PPS_COUNT; i++)",
          "1206:         memcpy(&h->s + 1, &h1->s + 1, sizeof(H264Context) - sizeof(MpegEncContext)); //copy all fields after MpegEnc",
          "",
          "[Added Lines]",
          "1291: #define copy_fields(to, from, start_field, end_field)                   \\",
          "1292:     memcpy(&to->start_field, &from->start_field,                        \\",
          "1293:            (char *)&to->end_field - (char *)&to->start_field)",
          "1295: static int decode_update_thread_context(AVCodecContext *dst,",
          "1296:                                         const AVCodecContext *src)",
          "1297: {",
          "1298:     H264Context *h = dst->priv_data, *h1 = src->priv_data;",
          "1299:     MpegEncContext *const s = &h->s, *const s1 = &h1->s;",
          "1303:     if (dst == src || !s1->context_initialized)",
          "1304:         return 0;",
          "1307:     if (err)",
          "1308:         return err;",
          "1311:     if (!inited) {",
          "1312:         for (i = 0; i < MAX_SPS_COUNT; i++)",
          "1315:         for (i = 0; i < MAX_PPS_COUNT; i++)",
          "1319:         memcpy(&h->s + 1, &h1->s + 1,",
          "1320:                sizeof(H264Context) - sizeof(MpegEncContext));",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "1212:         }",
          "1213:         context_init(h);",
          "1217:             h->rbsp_buffer_size[i] = 0;",
          "1218:         }",
          "1220:         h->thread_context[0] = h;",
          "1226:         s->dsp.clear_blocks(h->mb);",
          "1228:     }",
          "1241:     copy_fields(h, h1, dequant4_buffer, dequant4_coeff);",
          "1249:     h->dequant_coeff_pps = h1->dequant_coeff_pps;",
          "1252:     copy_fields(h, h1, poc_lsb, redundant_pic_count);",
          "1255:     copy_fields(h, h1, ref_count, list_count);",
          "1257:     copy_fields(h, h1, short_ref, cabac_init_idc);",
          "1263:     h->last_slice_type = h1->last_slice_type;",
          "1268:         err = ff_h264_execute_ref_pic_marking(h, h->mmco, h->mmco_index);",
          "1271:     }",
          "1276:     return err;",
          "1277: }",
          "1281:     int i;",
          "1282:     const int pixel_shift = h->pixel_shift;",
          "1285:         return -1;",
          "1286:     ff_er_frame_start(s);",
          "",
          "[Removed Lines]",
          "1215:         for(i=0; i<2; i++){",
          "1216:             h->rbsp_buffer[i] = NULL;",
          "1224:         h->s.obmc_scratchpad = av_malloc(16*6*s->linesize);",
          "1227:         s->dsp.clear_blocks(h->mb+(24*16<<h->pixel_shift));",
          "1231:     h->is_avc          = h1->is_avc;",
          "1234:     copy_parameter_set((void**)h->sps_buffers, (void**)h1->sps_buffers, MAX_SPS_COUNT, sizeof(SPS));",
          "1235:     h->sps             = h1->sps;",
          "1236:     copy_parameter_set((void**)h->pps_buffers, (void**)h1->pps_buffers, MAX_PPS_COUNT, sizeof(PPS));",
          "1237:     h->pps             = h1->pps;",
          "1243:     for(i=0; i<6; i++)",
          "1244:         h->dequant4_coeff[i] = h->dequant4_buffer[0] + (h1->dequant4_coeff[i] - h1->dequant4_buffer[0]);",
          "1246:     for(i=0; i<6; i++)",
          "1247:         h->dequant8_coeff[i] = h->dequant8_buffer[0] + (h1->dequant8_coeff[i] - h1->dequant8_buffer[0]);",
          "1256:     copy_fields(h, h1, ref_list,  intra_gb);",
          "1259:     copy_picture_range(h->short_ref,   h1->short_ref,   32, s, s1);",
          "1260:     copy_picture_range(h->long_ref,    h1->long_ref,    32, s, s1);",
          "1261:     copy_picture_range(h->delayed_pic, h1->delayed_pic, MAX_DELAYED_PIC_COUNT+2, s, s1);",
          "1265:     if(!s->current_picture_ptr) return 0;",
          "1267:     if(!s->dropable) {",
          "1269:         h->prev_poc_msb     = h->poc_msb;",
          "1270:         h->prev_poc_lsb     = h->poc_lsb;",
          "1272:     h->prev_frame_num_offset= h->frame_num_offset;",
          "1273:     h->prev_frame_num       = h->frame_num;",
          "1274:     h->outputed_poc         = h->next_outputed_poc;",
          "1279: int ff_h264_frame_start(H264Context *h){",
          "1280:     MpegEncContext * const s = &h->s;",
          "1284:     if(ff_MPV_frame_start(s, s->avctx) < 0)",
          "",
          "[Added Lines]",
          "1329:         for (i = 0; i < 2; i++) {",
          "1330:             h->rbsp_buffer[i]      = NULL;",
          "1338:         h->s.obmc_scratchpad = av_malloc(16 * 6 * s->linesize);",
          "1341:         s->dsp.clear_blocks(h->mb + (24 * 16 << h->pixel_shift));",
          "1345:     h->is_avc = h1->is_avc;",
          "1348:     copy_parameter_set((void **)h->sps_buffers, (void **)h1->sps_buffers,",
          "1349:                        MAX_SPS_COUNT, sizeof(SPS));",
          "1350:     h->sps = h1->sps;",
          "1351:     copy_parameter_set((void **)h->pps_buffers, (void **)h1->pps_buffers,",
          "1352:                        MAX_PPS_COUNT, sizeof(PPS));",
          "1353:     h->pps = h1->pps;",
          "1359:     for (i = 0; i < 6; i++)",
          "1360:         h->dequant4_coeff[i] = h->dequant4_buffer[0] +",
          "1361:                                (h1->dequant4_coeff[i] - h1->dequant4_buffer[0]);",
          "1363:     for (i = 0; i < 6; i++)",
          "1364:         h->dequant8_coeff[i] = h->dequant8_buffer[0] +",
          "1365:                                (h1->dequant8_coeff[i] - h1->dequant8_buffer[0]);",
          "1374:     copy_fields(h, h1, ref_list, intra_gb);",
          "1377:     copy_picture_range(h->short_ref, h1->short_ref, 32, s, s1);",
          "1378:     copy_picture_range(h->long_ref, h1->long_ref, 32, s, s1);",
          "1379:     copy_picture_range(h->delayed_pic, h1->delayed_pic,",
          "1380:                        MAX_DELAYED_PIC_COUNT + 2, s, s1);",
          "1384:     if (!s->current_picture_ptr)",
          "1385:         return 0;",
          "1387:     if (!s->dropable) {",
          "1389:         h->prev_poc_msb = h->poc_msb;",
          "1390:         h->prev_poc_lsb = h->poc_lsb;",
          "1392:     h->prev_frame_num_offset = h->frame_num_offset;",
          "1393:     h->prev_frame_num        = h->frame_num;",
          "1394:     h->outputed_poc          = h->next_outputed_poc;",
          "1399: int ff_h264_frame_start(H264Context *h)",
          "1400: {",
          "1401:     MpegEncContext *const s = &h->s;",
          "1405:     if (ff_MPV_frame_start(s, s->avctx) < 0)",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "1293:     s->current_picture_ptr->f.key_frame = 0;",
          "1296:     assert(s->linesize && s->uvlinesize);",
          "1301:     }",
          "1307:     }",
          "1327:         s->current_picture_ptr->f.reference = 0;",
          "1332:     h->next_output_pic = NULL;",
          "1336:     return 0;",
          "1337: }",
          "1349:     Picture *out = s->current_picture_ptr;",
          "1350:     Picture *cur = s->current_picture_ptr;",
          "1351:     int i, pics, out_of_order, out_idx;",
          "",
          "[Removed Lines]",
          "1294:     s->current_picture_ptr->mmco_reset= 0;",
          "1298:     for(i=0; i<16; i++){",
          "1299:         h->block_offset[i]= (4*((scan8[i] - scan8[0])&7) << pixel_shift) + 4*s->linesize*((scan8[i] - scan8[0])>>3);",
          "1300:         h->block_offset[48+i]= (4*((scan8[i] - scan8[0])&7) << pixel_shift) + 8*s->linesize*((scan8[i] - scan8[0])>>3);",
          "1302:     for(i=0; i<16; i++){",
          "1303:         h->block_offset[16+i]=",
          "1304:         h->block_offset[32+i]= (4*((scan8[i] - scan8[0])&7) << pixel_shift) + 4*s->uvlinesize*((scan8[i] - scan8[0])>>3);",
          "1305:         h->block_offset[48+16+i]=",
          "1306:         h->block_offset[48+32+i]= (4*((scan8[i] - scan8[0])&7) << pixel_shift) + 8*s->uvlinesize*((scan8[i] - scan8[0])>>3);",
          "1311:     for(i = 0; i < s->slice_context_count; i++)",
          "1312:         if(h->thread_context[i] && !h->thread_context[i]->s.obmc_scratchpad)",
          "1313:             h->thread_context[i]->s.obmc_scratchpad = av_malloc(16*6*s->linesize);",
          "1316:     memset(h->slice_table, -1, (s->mb_height*s->mb_stride-1) * sizeof(*h->slice_table));",
          "1326:     if(s->codec_id != CODEC_ID_SVQ3)",
          "1329:     s->current_picture_ptr->field_poc[0]=",
          "1330:     s->current_picture_ptr->field_poc[1]= INT_MAX;",
          "1334:     assert(s->current_picture_ptr->long_ref==0);",
          "1347: static void decode_postinit(H264Context *h, int setup_finished){",
          "1348:     MpegEncContext * const s = &h->s;",
          "",
          "[Added Lines]",
          "1415:     s->current_picture_ptr->mmco_reset  = 0;",
          "1419:     for (i = 0; i < 16; i++) {",
          "1420:         h->block_offset[i]           = (4 * ((scan8[i] - scan8[0]) & 7) << pixel_shift) + 4 * s->linesize * ((scan8[i] - scan8[0]) >> 3);",
          "1421:         h->block_offset[48 + i]      = (4 * ((scan8[i] - scan8[0]) & 7) << pixel_shift) + 8 * s->linesize * ((scan8[i] - scan8[0]) >> 3);",
          "1423:     for (i = 0; i < 16; i++) {",
          "1424:         h->block_offset[16 + i]      =",
          "1425:         h->block_offset[32 + i]      = (4 * ((scan8[i] - scan8[0]) & 7) << pixel_shift) + 4 * s->uvlinesize * ((scan8[i] - scan8[0]) >> 3);",
          "1426:         h->block_offset[48 + 16 + i] =",
          "1427:         h->block_offset[48 + 32 + i] = (4 * ((scan8[i] - scan8[0]) & 7) << pixel_shift) + 8 * s->uvlinesize * ((scan8[i] - scan8[0]) >> 3);",
          "1432:     for (i = 0; i < s->slice_context_count; i++)",
          "1433:         if (h->thread_context[i] && !h->thread_context[i]->s.obmc_scratchpad)",
          "1434:             h->thread_context[i]->s.obmc_scratchpad = av_malloc(16 * 6 * s->linesize);",
          "1438:     memset(h->slice_table, -1,",
          "1439:            (s->mb_height * s->mb_stride - 1) * sizeof(*h->slice_table));",
          "1450:     if (s->codec_id != CODEC_ID_SVQ3)",
          "1453:     s->current_picture_ptr->field_poc[0]     =",
          "1454:         s->current_picture_ptr->field_poc[1] = INT_MAX;",
          "1458:     assert(s->current_picture_ptr->long_ref == 0);",
          "1471: static void decode_postinit(H264Context *h, int setup_finished)",
          "1472: {",
          "1473:     MpegEncContext *const s = &h->s;",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "1354:     s->current_picture_ptr->f.qscale_type = FF_QSCALE_TYPE_H264;",
          "1355:     s->current_picture_ptr->f.pict_type   = s->pict_type;",
          "1365:         return;",
          "1366:     }",
          "",
          "[Removed Lines]",
          "1357:     if (h->next_output_pic) return;",
          "1359:     if (cur->field_poc[0]==INT_MAX || cur->field_poc[1]==INT_MAX) {",
          "",
          "[Added Lines]",
          "1482:     if (h->next_output_pic)",
          "1483:         return;",
          "1485:     if (cur->field_poc[0] == INT_MAX || cur->field_poc[1] == INT_MAX) {",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "1369:     cur->f.repeat_pict      = 0;",
          "1377:         case SEI_PIC_STRUCT_FRAME:",
          "1378:             break;",
          "1379:         case SEI_PIC_STRUCT_TOP_FIELD:",
          "",
          "[Removed Lines]",
          "1374:     if(h->sps.pic_struct_present_flag){",
          "1375:         switch (h->sei_pic_struct)",
          "1376:         {",
          "",
          "[Added Lines]",
          "1502:     if (h->sps.pic_struct_present_flag) {",
          "1503:         switch (h->sei_pic_struct) {",
          "",
          "---------------",
          "--- Hunk 21 ---",
          "[Context before]",
          "1403:             break;",
          "1404:         }",
          "1407:             cur->f.interlaced_frame = (h->sei_ct_type & (1 << 1)) != 0;",
          "1410:         cur->f.interlaced_frame = FIELD_OR_MBAFF_PICTURE;",
          "1411:     }",
          "1412:     h->prev_interlaced_frame = cur->f.interlaced_frame;",
          "1416:         cur->f.top_field_first = cur->field_poc[0] < cur->field_poc[1];",
          "1418:         if (cur->f.interlaced_frame || h->sps.pic_struct_present_flag) {",
          "1422:                 cur->f.top_field_first = 1;",
          "1423:             else",
          "1424:                 cur->f.top_field_first = 0;",
          "1427:             cur->f.top_field_first = 0;",
          "1428:         }",
          "1429:     }",
          "1437:         s->avctx->has_b_frames = h->sps.num_reorder_frames;",
          "1439:     }",
          "1443:         s->avctx->has_b_frames = MAX_DELAYED_PIC_COUNT - 1;",
          "1445:     }",
          "1447:     pics = 0;",
          "1450:     assert(pics <= MAX_DELAYED_PIC_COUNT);",
          "",
          "[Removed Lines]",
          "1406:         if ((h->sei_ct_type & 3) && h->sei_pic_struct <= SEI_PIC_STRUCT_BOTTOM_TOP)",
          "1408:     }else{",
          "1414:     if (cur->field_poc[0] != cur->field_poc[1]){",
          "1417:     }else{",
          "1420:             if(h->sei_pic_struct == SEI_PIC_STRUCT_TOP_BOTTOM",
          "1421:               || h->sei_pic_struct == SEI_PIC_STRUCT_TOP_BOTTOM_TOP)",
          "1425:         }else{",
          "1435:     if(h->sps.bitstream_restriction_flag",
          "1436:        && s->avctx->has_b_frames < h->sps.num_reorder_frames){",
          "1438:         s->low_delay = 0;",
          "1441:     if(   s->avctx->strict_std_compliance >= FF_COMPLIANCE_STRICT",
          "1442:        && !h->sps.bitstream_restriction_flag){",
          "1444:         s->low_delay= 0;",
          "1448:     while(h->delayed_pic[pics]) pics++;",
          "",
          "[Added Lines]",
          "1534:         if ((h->sei_ct_type & 3) &&",
          "1535:             h->sei_pic_struct <= SEI_PIC_STRUCT_BOTTOM_TOP)",
          "1537:     } else {",
          "1543:     if (cur->field_poc[0] != cur->field_poc[1]) {",
          "1546:     } else {",
          "1550:             if (h->sei_pic_struct == SEI_PIC_STRUCT_TOP_BOTTOM ||",
          "1551:                 h->sei_pic_struct == SEI_PIC_STRUCT_TOP_BOTTOM_TOP)",
          "1555:         } else {",
          "1565:     if (h->sps.bitstream_restriction_flag &&",
          "1566:         s->avctx->has_b_frames < h->sps.num_reorder_frames) {",
          "1568:         s->low_delay           = 0;",
          "1571:     if (s->avctx->strict_std_compliance >= FF_COMPLIANCE_STRICT &&",
          "1572:         !h->sps.bitstream_restriction_flag) {",
          "1574:         s->low_delay           = 0;",
          "1578:     while (h->delayed_pic[pics])",
          "1579:         pics++;",
          "",
          "---------------",
          "--- Hunk 22 ---",
          "[Context before]",
          "1470:         cnt     += out->poc < h->last_pocs[i];",
          "1471:         invalid += out->poc == INT_MIN;",
          "1472:     }",
          "1474:         h->mmco_reset = 2;",
          "1475:         if (pics > 1)",
          "1476:             h->delayed_pic[pics - 2]->mmco_reset = 2;",
          "",
          "[Removed Lines]",
          "1473:     if (!h->mmco_reset && !cur->f.key_frame && cnt + invalid == MAX_DELAYED_PIC_COUNT && cnt > 0) {",
          "",
          "[Added Lines]",
          "1604:     if (!h->mmco_reset && !cur->f.key_frame &&",
          "1605:         cnt + invalid == MAX_DELAYED_PIC_COUNT && cnt > 0) {",
          "",
          "---------------",
          "--- Hunk 23 ---",
          "[Context before]",
          "1481:         cnt     = 0;",
          "1482:         invalid = MAX_DELAYED_PIC_COUNT;",
          "1483:     }",
          "1485:     out_idx = 0;",
          "1491:             out_idx = i;",
          "1492:         }",
          "1495:         h->next_outputed_poc = INT_MIN;",
          "1502:         if (invalid + cnt < MAX_DELAYED_PIC_COUNT) {",
          "1503:             s->avctx->has_b_frames = FFMAX(s->avctx->has_b_frames, cnt);",
          "1504:         }",
          "1505:         s->low_delay = 0;",
          "1506:     } else if (s->low_delay &&",
          "1508:                 cur->f.pict_type == AV_PICTURE_TYPE_B)) {",
          "1509:         s->low_delay = 0;",
          "1510:         s->avctx->has_b_frames++;",
          "1511:     }",
          "1514:         out->f.reference &= ~DELAYED_PIC_REF;",
          "1521:     h->last_pocs[MAX_DELAYED_PIC_COUNT - 1] = cur->poc;",
          "1523:         h->next_output_pic = out;",
          "1524:         if (out->mmco_reset) {",
          "1525:             if (out_idx > 0) {",
          "1527:                 h->delayed_pic[out_idx - 1]->mmco_reset = out->mmco_reset;",
          "1528:             } else {",
          "1529:                 h->next_outputed_poc = INT_MIN;",
          "",
          "[Removed Lines]",
          "1484:     out = h->delayed_pic[0];",
          "1486:     for (i = 1; i < MAX_DELAYED_PIC_COUNT && h->delayed_pic[i] &&",
          "1487:          !h->delayed_pic[i-1]->mmco_reset && !h->delayed_pic[i]->f.key_frame; i++)",
          "1488:     {",
          "1489:         if(h->delayed_pic[i]->poc < out->poc){",
          "1490:             out = h->delayed_pic[i];",
          "1493:     }",
          "1494:     if (s->avctx->has_b_frames == 0 && (h->delayed_pic[0]->f.key_frame || h->mmco_reset))",
          "1496:     out_of_order = !out->f.key_frame && !h->mmco_reset && (out->poc < h->next_outputed_poc);",
          "1498:     if(h->sps.bitstream_restriction_flag && s->avctx->has_b_frames >= h->sps.num_reorder_frames)",
          "1499:         { }",
          "1500:     else if (out_of_order && pics-1 == s->avctx->has_b_frames &&",
          "1501:              s->avctx->has_b_frames < MAX_DELAYED_PIC_COUNT) {",
          "1507:                ((h->next_outputed_poc != INT_MIN && out->poc > h->next_outputed_poc + 2) ||",
          "1513:     if(pics > s->avctx->has_b_frames){",
          "1515:         out->owner2 = s; // for frame threading, the owner must be the second field's thread",
          "1517:         for(i=out_idx; h->delayed_pic[i]; i++)",
          "1518:             h->delayed_pic[i] = h->delayed_pic[i+1];",
          "1519:     }",
          "1520:     memmove(h->last_pocs, &h->last_pocs[1], sizeof(*h->last_pocs) * (MAX_DELAYED_PIC_COUNT - 1));",
          "1522:     if(!out_of_order && pics > s->avctx->has_b_frames){",
          "1526:                 h->next_outputed_poc = out->poc;",
          "",
          "[Added Lines]",
          "1616:     out     = h->delayed_pic[0];",
          "1618:     for (i = 1; i < MAX_DELAYED_PIC_COUNT &&",
          "1619:                 h->delayed_pic[i] &&",
          "1620:                 !h->delayed_pic[i - 1]->mmco_reset &&",
          "1621:                 !h->delayed_pic[i]->f.key_frame;",
          "1622:          i++)",
          "1623:         if (h->delayed_pic[i]->poc < out->poc) {",
          "1624:             out     = h->delayed_pic[i];",
          "1627:     if (s->avctx->has_b_frames == 0 &&",
          "1628:         (h->delayed_pic[0]->f.key_frame || h->mmco_reset))",
          "1630:     out_of_order = !out->f.key_frame && !h->mmco_reset &&",
          "1631:                    (out->poc < h->next_outputed_poc);",
          "1633:     if (h->sps.bitstream_restriction_flag &&",
          "1634:         s->avctx->has_b_frames >= h->sps.num_reorder_frames) {",
          "1635:     } else if (out_of_order && pics - 1 == s->avctx->has_b_frames &&",
          "1636:                s->avctx->has_b_frames < MAX_DELAYED_PIC_COUNT) {",
          "1642:                ((h->next_outputed_poc != INT_MIN &&",
          "1643:                  out->poc > h->next_outputed_poc + 2) ||",
          "1649:     if (pics > s->avctx->has_b_frames) {",
          "1653:         out->owner2       = s;",
          "1654:         for (i = out_idx; h->delayed_pic[i]; i++)",
          "1655:             h->delayed_pic[i] = h->delayed_pic[i + 1];",
          "1656:     }",
          "1657:     memmove(h->last_pocs, &h->last_pocs[1],",
          "1658:             sizeof(*h->last_pocs) * (MAX_DELAYED_PIC_COUNT - 1));",
          "1660:     if (!out_of_order && pics > s->avctx->has_b_frames) {",
          "1664:                 h->next_outputed_poc                    = out->poc;",
          "",
          "---------------",
          "--- Hunk 24 ---",
          "[Context before]",
          "1536:             }",
          "1537:         }",
          "1538:         h->mmco_reset = 0;",
          "1540:         av_log(s->avctx, AV_LOG_DEBUG, \"no picture\\n\");",
          "1541:     }",
          "",
          "[Removed Lines]",
          "1539:     }else{",
          "",
          "[Added Lines]",
          "1677:     } else {",
          "",
          "---------------",
          "--- Hunk 25 ---",
          "[Context before]",
          "1547: static av_always_inline void backup_mb_border(H264Context *h, uint8_t *src_y,",
          "1548:                                               uint8_t *src_cb, uint8_t *src_cr,",
          "1550: {",
          "1552:     uint8_t *top_border;",
          "1553:     int top_idx = 1;",
          "1554:     const int pixel_shift = h->pixel_shift;",
          "1555:     int chroma444 = CHROMA444;",
          "1556:     int chroma422 = CHROMA422;",
          "1559:     src_cb -= uvlinesize;",
          "1560:     src_cr -= uvlinesize;",
          "1565:                 top_border = h->top_borders[0][s->mb_x];",
          "1567:                 if (pixel_shift)",
          "1576:                         } else {",
          "1579:                         }",
          "1581:                         if (pixel_shift) {",
          "1584:                         } else {",
          "1587:                         }",
          "1588:                     } else {",
          "1589:                         if (pixel_shift) {",
          "1592:                         } else {",
          "1595:                         }",
          "1596:                     }",
          "1597:                 }",
          "1598:             }",
          "1600:             top_idx = 0;",
          "1602:             return;",
          "1603:     }",
          "1605:     top_border = h->top_borders[top_idx][s->mb_x];",
          "1609:     if (pixel_shift)",
          "1619:             } else {",
          "1622:             }",
          "1624:             if (pixel_shift) {",
          "1627:             } else {",
          "1630:             }",
          "1631:         } else {",
          "1632:             if (pixel_shift) {",
          "1635:             } else {",
          "1638:             }",
          "1639:         }",
          "1640:     }",
          "1641: }",
          "1643: static av_always_inline void xchg_mb_border(H264Context *h, uint8_t *src_y,",
          "1649:     int deblock_topleft;",
          "1650:     int deblock_top;",
          "1651:     int top_idx = 1;",
          "1652:     uint8_t *top_border_m1;",
          "1653:     uint8_t *top_border;",
          "1658:                 return;",
          "1660:             top_idx = MB_MBAFF ? 0 : 1;",
          "1661:         }",
          "1662:     }",
          "1665:         deblock_topleft = h->slice_table[h->mb_xy - 1 - s->mb_stride] == h->slice_num;",
          "1666:         deblock_top     = h->top_type;",
          "1667:     } else {",
          "",
          "[Removed Lines]",
          "1549:                                               int linesize, int uvlinesize, int simple)",
          "1551:     MpegEncContext * const s = &h->s;",
          "1558:     src_y  -=   linesize;",
          "1562:     if(!simple && FRAME_MBAFF){",
          "1563:         if(s->mb_y&1){",
          "1564:             if(!MB_MBAFF){",
          "1566:                 AV_COPY128(top_border, src_y + 15*linesize);",
          "1568:                     AV_COPY128(top_border+16, src_y+15*linesize+16);",
          "1569:                 if(simple || !CONFIG_GRAY || !(s->flags&CODEC_FLAG_GRAY)){",
          "1570:                     if(chroma444){",
          "1571:                         if (pixel_shift){",
          "1572:                             AV_COPY128(top_border+32, src_cb + 15*uvlinesize);",
          "1573:                             AV_COPY128(top_border+48, src_cb + 15*uvlinesize+16);",
          "1574:                             AV_COPY128(top_border+64, src_cr + 15*uvlinesize);",
          "1575:                             AV_COPY128(top_border+80, src_cr + 15*uvlinesize+16);",
          "1577:                             AV_COPY128(top_border+16, src_cb + 15*uvlinesize);",
          "1578:                             AV_COPY128(top_border+32, src_cr + 15*uvlinesize);",
          "1580:                     } else if(chroma422) {",
          "1582:                             AV_COPY128(top_border+32, src_cb + 15*uvlinesize);",
          "1583:                             AV_COPY128(top_border+48, src_cr + 15*uvlinesize);",
          "1585:                             AV_COPY64(top_border+16, src_cb +  15*uvlinesize);",
          "1586:                             AV_COPY64(top_border+24, src_cr +  15*uvlinesize);",
          "1590:                             AV_COPY128(top_border+32, src_cb+7*uvlinesize);",
          "1591:                             AV_COPY128(top_border+48, src_cr+7*uvlinesize);",
          "1593:                             AV_COPY64(top_border+16, src_cb+7*uvlinesize);",
          "1594:                             AV_COPY64(top_border+24, src_cr+7*uvlinesize);",
          "1599:         }else if(MB_MBAFF){",
          "1601:         }else",
          "1608:     AV_COPY128(top_border, src_y + 16*linesize);",
          "1610:         AV_COPY128(top_border+16, src_y+16*linesize+16);",
          "1612:     if(simple || !CONFIG_GRAY || !(s->flags&CODEC_FLAG_GRAY)){",
          "1613:         if(chroma444){",
          "1614:             if (pixel_shift){",
          "1615:                 AV_COPY128(top_border+32, src_cb + 16*linesize);",
          "1616:                 AV_COPY128(top_border+48, src_cb + 16*linesize+16);",
          "1617:                 AV_COPY128(top_border+64, src_cr + 16*linesize);",
          "1618:                 AV_COPY128(top_border+80, src_cr + 16*linesize+16);",
          "1620:                 AV_COPY128(top_border+16, src_cb + 16*linesize);",
          "1621:                 AV_COPY128(top_border+32, src_cr + 16*linesize);",
          "1623:         } else if(chroma422) {",
          "1625:                 AV_COPY128(top_border+32, src_cb+16*uvlinesize);",
          "1626:                 AV_COPY128(top_border+48, src_cr+16*uvlinesize);",
          "1628:                 AV_COPY64(top_border+16, src_cb+16*uvlinesize);",
          "1629:                 AV_COPY64(top_border+24, src_cr+16*uvlinesize);",
          "1633:                 AV_COPY128(top_border+32, src_cb+8*uvlinesize);",
          "1634:                 AV_COPY128(top_border+48, src_cr+8*uvlinesize);",
          "1636:                 AV_COPY64(top_border+16, src_cb+8*uvlinesize);",
          "1637:                 AV_COPY64(top_border+24, src_cr+8*uvlinesize);",
          "1644:                                   uint8_t *src_cb, uint8_t *src_cr,",
          "1645:                                   int linesize, int uvlinesize,",
          "1646:                                   int xchg, int chroma444,",
          "1647:                                   int simple, int pixel_shift){",
          "1648:     MpegEncContext * const s = &h->s;",
          "1655:     if(!simple && FRAME_MBAFF){",
          "1656:         if(s->mb_y&1){",
          "1657:             if(!MB_MBAFF)",
          "1659:         }else{",
          "1664:     if(h->deblocking_filter == 2) {",
          "",
          "[Added Lines]",
          "1687:                                               int linesize, int uvlinesize,",
          "1688:                                               int simple)",
          "1690:     MpegEncContext *const s = &h->s;",
          "1697:     src_y  -= linesize;",
          "1701:     if (!simple && FRAME_MBAFF) {",
          "1702:         if (s->mb_y & 1) {",
          "1703:             if (!MB_MBAFF) {",
          "1705:                 AV_COPY128(top_border, src_y + 15 * linesize);",
          "1707:                     AV_COPY128(top_border + 16, src_y + 15 * linesize + 16);",
          "1708:                 if (simple || !CONFIG_GRAY || !(s->flags & CODEC_FLAG_GRAY)) {",
          "1709:                     if (chroma444) {",
          "1710:                         if (pixel_shift) {",
          "1711:                             AV_COPY128(top_border + 32, src_cb + 15 * uvlinesize);",
          "1712:                             AV_COPY128(top_border + 48, src_cb + 15 * uvlinesize + 16);",
          "1713:                             AV_COPY128(top_border + 64, src_cr + 15 * uvlinesize);",
          "1714:                             AV_COPY128(top_border + 80, src_cr + 15 * uvlinesize + 16);",
          "1716:                             AV_COPY128(top_border + 16, src_cb + 15 * uvlinesize);",
          "1717:                             AV_COPY128(top_border + 32, src_cr + 15 * uvlinesize);",
          "1719:                     } else if (chroma422) {",
          "1721:                             AV_COPY128(top_border + 32, src_cb + 15 * uvlinesize);",
          "1722:                             AV_COPY128(top_border + 48, src_cr + 15 * uvlinesize);",
          "1724:                             AV_COPY64(top_border + 16, src_cb + 15 * uvlinesize);",
          "1725:                             AV_COPY64(top_border + 24, src_cr + 15 * uvlinesize);",
          "1729:                             AV_COPY128(top_border + 32, src_cb + 7 * uvlinesize);",
          "1730:                             AV_COPY128(top_border + 48, src_cr + 7 * uvlinesize);",
          "1732:                             AV_COPY64(top_border + 16, src_cb + 7 * uvlinesize);",
          "1733:                             AV_COPY64(top_border + 24, src_cr + 7 * uvlinesize);",
          "1738:         } else if (MB_MBAFF) {",
          "1740:         } else",
          "1747:     AV_COPY128(top_border, src_y + 16 * linesize);",
          "1749:         AV_COPY128(top_border + 16, src_y + 16 * linesize + 16);",
          "1751:     if (simple || !CONFIG_GRAY || !(s->flags & CODEC_FLAG_GRAY)) {",
          "1752:         if (chroma444) {",
          "1753:             if (pixel_shift) {",
          "1754:                 AV_COPY128(top_border + 32, src_cb + 16 * linesize);",
          "1755:                 AV_COPY128(top_border + 48, src_cb + 16 * linesize + 16);",
          "1756:                 AV_COPY128(top_border + 64, src_cr + 16 * linesize);",
          "1757:                 AV_COPY128(top_border + 80, src_cr + 16 * linesize + 16);",
          "1759:                 AV_COPY128(top_border + 16, src_cb + 16 * linesize);",
          "1760:                 AV_COPY128(top_border + 32, src_cr + 16 * linesize);",
          "1762:         } else if (chroma422) {",
          "1764:                 AV_COPY128(top_border + 32, src_cb + 16 * uvlinesize);",
          "1765:                 AV_COPY128(top_border + 48, src_cr + 16 * uvlinesize);",
          "1767:                 AV_COPY64(top_border + 16, src_cb + 16 * uvlinesize);",
          "1768:                 AV_COPY64(top_border + 24, src_cr + 16 * uvlinesize);",
          "1772:                 AV_COPY128(top_border + 32, src_cb + 8 * uvlinesize);",
          "1773:                 AV_COPY128(top_border + 48, src_cr + 8 * uvlinesize);",
          "1775:                 AV_COPY64(top_border + 16, src_cb + 8 * uvlinesize);",
          "1776:                 AV_COPY64(top_border + 24, src_cr + 8 * uvlinesize);",
          "1783:                                             uint8_t *src_cb, uint8_t *src_cr,",
          "1784:                                             int linesize, int uvlinesize,",
          "1785:                                             int xchg, int chroma444,",
          "1786:                                             int simple, int pixel_shift)",
          "1787: {",
          "1788:     MpegEncContext *const s = &h->s;",
          "1795:     if (!simple && FRAME_MBAFF) {",
          "1796:         if (s->mb_y & 1) {",
          "1797:             if (!MB_MBAFF)",
          "1799:         } else {",
          "1804:     if (h->deblocking_filter == 2) {",
          "",
          "---------------",
          "--- Hunk 26 ---",
          "[Context before]",
          "1669:         deblock_top     = (s->mb_y > !!MB_FIELD);",
          "1670:     }",
          "1673:     src_cb -= uvlinesize + 1 + pixel_shift;",
          "1674:     src_cr -= uvlinesize + 1 + pixel_shift;",
          "1677:     top_border    = h->top_borders[top_idx][s->mb_x];",
          "1694:         }",
          "1695:         XCHG(top_border + (0 << pixel_shift), src_y + (1 << pixel_shift), xchg);",
          "1696:         XCHG(top_border + (8 << pixel_shift), src_y + (9 << pixel_shift), 1);",
          "1699:         }",
          "1700:     }",
          "1704:                 XCHG(top_border_m1 + (24 << pixel_shift), src_cb - (7 << pixel_shift), 1);",
          "1705:                 XCHG(top_border_m1 + (40 << pixel_shift), src_cr - (7 << pixel_shift), 1);",
          "1706:             }",
          "",
          "[Removed Lines]",
          "1672:     src_y  -=   linesize + 1 + pixel_shift;",
          "1676:     top_border_m1 = h->top_borders[top_idx][s->mb_x-1];",
          "1679: #define XCHG(a,b,xchg)\\",
          "1680:     if (pixel_shift) {\\",
          "1681:         if (xchg) {\\",
          "1682:             AV_SWAP64(b+0,a+0);\\",
          "1683:             AV_SWAP64(b+8,a+8);\\",
          "1684:         } else {\\",
          "1685:             AV_COPY128(b,a); \\",
          "1686:         }\\",
          "1687:     } else \\",
          "1688: if (xchg) AV_SWAP64(b,a);\\",
          "1689: else      AV_COPY64(b,a);",
          "1691:     if(deblock_top){",
          "1692:         if(deblock_topleft){",
          "1693:             XCHG(top_border_m1 + (8 << pixel_shift), src_y - (7 << pixel_shift), 1);",
          "1697:         if(s->mb_x+1 < s->mb_width){",
          "1698:             XCHG(h->top_borders[top_idx][s->mb_x+1], src_y + (17 << pixel_shift), 1);",
          "1701:     if(simple || !CONFIG_GRAY || !(s->flags&CODEC_FLAG_GRAY)){",
          "1702:         if(chroma444){",
          "1703:             if(deblock_topleft){",
          "",
          "[Added Lines]",
          "1812:     src_y  -= linesize   + 1 + pixel_shift;",
          "1816:     top_border_m1 = h->top_borders[top_idx][s->mb_x - 1];",
          "1819: #define XCHG(a, b, xchg)                        \\",
          "1820:     if (pixel_shift) {                          \\",
          "1821:         if (xchg) {                             \\",
          "1822:             AV_SWAP64(b + 0, a + 0);            \\",
          "1823:             AV_SWAP64(b + 8, a + 8);            \\",
          "1824:         } else {                                \\",
          "1825:             AV_COPY128(b, a);                   \\",
          "1826:         }                                       \\",
          "1827:     } else if (xchg)                            \\",
          "1828:         AV_SWAP64(b, a);                        \\",
          "1829:     else                                        \\",
          "1830:         AV_COPY64(b, a);",
          "1832:     if (deblock_top) {",
          "1833:         if (deblock_topleft) {",
          "1834:             XCHG(top_border_m1 + (8 << pixel_shift),",
          "1835:                  src_y - (7 << pixel_shift), 1);",
          "1839:         if (s->mb_x + 1 < s->mb_width) {",
          "1840:             XCHG(h->top_borders[top_idx][s->mb_x + 1],",
          "1841:                  src_y + (17 << pixel_shift), 1);",
          "1844:     if (simple || !CONFIG_GRAY || !(s->flags & CODEC_FLAG_GRAY)) {",
          "1845:         if (chroma444) {",
          "1846:             if (deblock_topleft) {",
          "",
          "---------------",
          "--- Hunk 27 ---",
          "[Context before]",
          "1708:             XCHG(top_border + (24 << pixel_shift), src_cb + (9 << pixel_shift), 1);",
          "1709:             XCHG(top_border + (32 << pixel_shift), src_cr + (1 << pixel_shift), xchg);",
          "1710:             XCHG(top_border + (40 << pixel_shift), src_cr + (9 << pixel_shift), 1);",
          "1714:             }",
          "1715:         } else {",
          "1718:                     XCHG(top_border_m1 + (16 << pixel_shift), src_cb - (7 << pixel_shift), 1);",
          "1719:                     XCHG(top_border_m1 + (24 << pixel_shift), src_cr - (7 << pixel_shift), 1);",
          "1720:                 }",
          "1723:             }",
          "1724:         }",
          "1725:     }",
          "1726: }",
          "1729:     if (high_bit_depth) {",
          "1731:     } else",
          "1732:         return AV_RN16A(mb + index);",
          "1733: }",
          "1736:     if (high_bit_depth) {",
          "1738:     } else",
          "1739:         AV_WN16A(mb + index, value);",
          "1740: }",
          "1744: {",
          "1746:     void (*idct_add)(uint8_t *dst, DCTELEM *block, int stride);",
          "1747:     void (*idct_dc_add)(uint8_t *dst, DCTELEM *block, int stride);",
          "1748:     int i;",
          "1758:                     idct_dc_add = h->h264dsp.h264_idct8_dc_add;",
          "1759:                     idct_add    = h->h264dsp.h264_idct8_add;",
          "1760:                 }",
          "1773:                             else",
          "1775:                         }",
          "1776:                     }",
          "1777:                 }",
          "1783:                     idct_dc_add = h->h264dsp.h264_idct_dc_add;",
          "1784:                     idct_add    = h->h264dsp.h264_idct_add;",
          "1785:                 }",
          "1793:                         uint8_t *topright;",
          "1794:                         int nnz, tr;",
          "1795:                         uint64_t tr_high;",
          "1798:                             assert(s->mb_y || linesize <= block_offset[i]);",
          "1800:                                 if (pixel_shift) {",
          "1803:                                 } else {",
          "1806:                                 }",
          "1818:                                 else",
          "1820:                             } else if (CONFIG_SVQ3_DECODER)",
          "1822:                         }",
          "1823:                     }",
          "1824:                 }",
          "1825:             }",
          "1826:         }",
          "1838:                 }",
          "1839:             }",
          "1840:         } else if (CONFIG_SVQ3_DECODER)",
          "1842:     }",
          "1843: }",
          "1847: {",
          "1849:     void (*idct_add)(uint8_t *dst, DCTELEM *block, int stride);",
          "1850:     int i;",
          "1863:                     }",
          "1866:                 }",
          "1869:                     const int di = IS_8x8DCT(mb_type) ? 4 : 1;",
          "1882:                 }",
          "1883:             }",
          "1884:         } else if (CONFIG_SVQ3_DECODER) {",
          "1889:                 }",
          "1891:         }",
          "1892:     }",
          "1893: }",
          "1896: {",
          "1901:     const int mb_type = s->current_picture.f.mb_type[mb_xy];",
          "1903:     int linesize, uvlinesize /*dct_offset*/;",
          "1904:     int i, j;",
          "1905:     int *block_offset = &h->block_offset[0];",
          "",
          "[Removed Lines]",
          "1711:             if(s->mb_x+1 < s->mb_width){",
          "1712:                 XCHG(h->top_borders[top_idx][s->mb_x+1] + (16 << pixel_shift), src_cb + (17 << pixel_shift), 1);",
          "1713:                 XCHG(h->top_borders[top_idx][s->mb_x+1] + (32 << pixel_shift), src_cr + (17 << pixel_shift), 1);",
          "1716:             if(deblock_top){",
          "1717:                 if(deblock_topleft){",
          "1721:                 XCHG(top_border + (16 << pixel_shift), src_cb+1+pixel_shift, 1);",
          "1722:                 XCHG(top_border + (24 << pixel_shift), src_cr+1+pixel_shift, 1);",
          "1728: static av_always_inline int dctcoef_get(DCTELEM *mb, int high_bit_depth, int index) {",
          "1730:         return AV_RN32A(((int32_t*)mb) + index);",
          "1735: static av_always_inline void dctcoef_set(DCTELEM *mb, int high_bit_depth, int index, int value) {",
          "1737:         AV_WN32A(((int32_t*)mb) + index, value);",
          "1742: static av_always_inline void hl_decode_mb_predict_luma(H264Context *h, int mb_type, int is_h264, int simple, int transform_bypass,",
          "1743:                                                        int pixel_shift, int *block_offset, int linesize, uint8_t *dest_y, int p)",
          "1745:     MpegEncContext * const s = &h->s;",
          "1749:     int qscale = p == 0 ? s->qscale : h->chroma_qp[p-1];",
          "1750:     block_offset += 16*p;",
          "1751:     if(IS_INTRA4x4(mb_type)){",
          "1752:         if(simple || !s->encoding){",
          "1753:             if(IS_8x8DCT(mb_type)){",
          "1754:                 if(transform_bypass){",
          "1755:                     idct_dc_add =",
          "1756:                     idct_add    = s->dsp.add_pixels8;",
          "1757:                 }else{",
          "1761:                 for(i=0; i<16; i+=4){",
          "1762:                     uint8_t * const ptr= dest_y + block_offset[i];",
          "1763:                     const int dir= h->intra4x4_pred_mode_cache[ scan8[i] ];",
          "1764:                     if(transform_bypass && h->sps.profile_idc==244 && dir<=1){",
          "1765:                         h->hpc.pred8x8l_add[dir](ptr, h->mb + (i*16+p*256 << pixel_shift), linesize);",
          "1766:                     }else{",
          "1767:                         const int nnz = h->non_zero_count_cache[ scan8[i+p*16] ];",
          "1768:                         h->hpc.pred8x8l[ dir ](ptr, (h->topleft_samples_available<<i)&0x8000,",
          "1769:                                                     (h->topright_samples_available<<i)&0x4000, linesize);",
          "1770:                         if(nnz){",
          "1771:                             if(nnz == 1 && dctcoef_get(h->mb, pixel_shift, i*16+p*256))",
          "1772:                                 idct_dc_add(ptr, h->mb + (i*16+p*256 << pixel_shift), linesize);",
          "1774:                                 idct_add   (ptr, h->mb + (i*16+p*256 << pixel_shift), linesize);",
          "1778:             }else{",
          "1779:                 if(transform_bypass){",
          "1780:                     idct_dc_add =",
          "1781:                     idct_add    = s->dsp.add_pixels4;",
          "1782:                 }else{",
          "1786:                 for(i=0; i<16; i++){",
          "1787:                     uint8_t * const ptr= dest_y + block_offset[i];",
          "1788:                     const int dir= h->intra4x4_pred_mode_cache[ scan8[i] ];",
          "1790:                     if(transform_bypass && h->sps.profile_idc==244 && dir<=1){",
          "1791:                         h->hpc.pred4x4_add[dir](ptr, h->mb + (i*16+p*256 << pixel_shift), linesize);",
          "1792:                     }else{",
          "1796:                         if(dir == DIAG_DOWN_LEFT_PRED || dir == VERT_LEFT_PRED){",
          "1797:                             const int topright_avail= (h->topright_samples_available<<i)&0x8000;",
          "1799:                             if(!topright_avail){",
          "1801:                                     tr_high= ((uint16_t*)ptr)[3 - linesize/2]*0x0001000100010001ULL;",
          "1802:                                     topright= (uint8_t*) &tr_high;",
          "1804:                                     tr= ptr[3 - linesize]*0x01010101u;",
          "1805:                                     topright= (uint8_t*) &tr;",
          "1807:                             }else",
          "1808:                                 topright= ptr + (4 << pixel_shift) - linesize;",
          "1809:                         }else",
          "1810:                             topright= NULL;",
          "1812:                         h->hpc.pred4x4[ dir ](ptr, topright, linesize);",
          "1813:                         nnz = h->non_zero_count_cache[ scan8[i+p*16] ];",
          "1814:                         if(nnz){",
          "1815:                             if(is_h264){",
          "1816:                                 if(nnz == 1 && dctcoef_get(h->mb, pixel_shift, i*16+p*256))",
          "1817:                                     idct_dc_add(ptr, h->mb + (i*16+p*256 << pixel_shift), linesize);",
          "1819:                                     idct_add   (ptr, h->mb + (i*16+p*256 << pixel_shift), linesize);",
          "1821:                                 ff_svq3_add_idct_c(ptr, h->mb + i*16+p*256, linesize, qscale, 0);",
          "1827:     }else{",
          "1828:         h->hpc.pred16x16[ h->intra16x16_pred_mode ](dest_y , linesize);",
          "1829:         if(is_h264){",
          "1830:             if(h->non_zero_count_cache[ scan8[LUMA_DC_BLOCK_INDEX+p] ]){",
          "1831:                 if(!transform_bypass)",
          "1832:                     h->h264dsp.h264_luma_dc_dequant_idct(h->mb+(p*256 << pixel_shift), h->mb_luma_dc[p], h->dequant4_coeff[p][qscale][0]);",
          "1833:                 else{",
          "1834:                     static const uint8_t dc_mapping[16] = { 0*16, 1*16, 4*16, 5*16, 2*16, 3*16, 6*16, 7*16,",
          "1835:                                                             8*16, 9*16,12*16,13*16,10*16,11*16,14*16,15*16};",
          "1836:                     for(i = 0; i < 16; i++)",
          "1837:                         dctcoef_set(h->mb+(p*256 << pixel_shift), pixel_shift, dc_mapping[i], dctcoef_get(h->mb_luma_dc[p], pixel_shift, i));",
          "1841:             ff_svq3_luma_dc_dequant_idct_c(h->mb+p*256, h->mb_luma_dc[p], qscale);",
          "1845: static av_always_inline void hl_decode_mb_idct_luma(H264Context *h, int mb_type, int is_h264, int simple, int transform_bypass,",
          "1846:                                                     int pixel_shift, int *block_offset, int linesize, uint8_t *dest_y, int p)",
          "1848:     MpegEncContext * const s = &h->s;",
          "1851:     block_offset += 16*p;",
          "1852:     if(!IS_INTRA4x4(mb_type)){",
          "1853:         if(is_h264){",
          "1854:             if(IS_INTRA16x16(mb_type)){",
          "1855:                 if(transform_bypass){",
          "1856:                     if(h->sps.profile_idc==244 && (h->intra16x16_pred_mode==VERT_PRED8x8 || h->intra16x16_pred_mode==HOR_PRED8x8)){",
          "1857:                         h->hpc.pred16x16_add[h->intra16x16_pred_mode](dest_y, block_offset, h->mb + (p*256 << pixel_shift), linesize);",
          "1858:                     }else{",
          "1859:                         for(i=0; i<16; i++){",
          "1860:                             if(h->non_zero_count_cache[ scan8[i+p*16] ] || dctcoef_get(h->mb, pixel_shift, i*16+p*256))",
          "1861:                                 s->dsp.add_pixels4(dest_y + block_offset[i], h->mb + (i*16+p*256 << pixel_shift), linesize);",
          "1862:                         }",
          "1864:                 }else{",
          "1865:                     h->h264dsp.h264_idct_add16intra(dest_y, block_offset, h->mb + (p*256 << pixel_shift), linesize, h->non_zero_count_cache+p*5*8);",
          "1867:             }else if(h->cbp&15){",
          "1868:                 if(transform_bypass){",
          "1870:                     idct_add= IS_8x8DCT(mb_type) ? s->dsp.add_pixels8 : s->dsp.add_pixels4;",
          "1871:                     for(i=0; i<16; i+=di){",
          "1872:                         if(h->non_zero_count_cache[ scan8[i+p*16] ]){",
          "1873:                             idct_add(dest_y + block_offset[i], h->mb + (i*16+p*256 << pixel_shift), linesize);",
          "1874:                         }",
          "1875:                     }",
          "1876:                 }else{",
          "1877:                     if(IS_8x8DCT(mb_type)){",
          "1878:                         h->h264dsp.h264_idct8_add4(dest_y, block_offset, h->mb + (p*256 << pixel_shift), linesize, h->non_zero_count_cache+p*5*8);",
          "1879:                     }else{",
          "1880:                         h->h264dsp.h264_idct_add16(dest_y, block_offset, h->mb + (p*256 << pixel_shift), linesize, h->non_zero_count_cache+p*5*8);",
          "1881:                     }",
          "1885:             for(i=0; i<16; i++){",
          "1886:                 if(h->non_zero_count_cache[ scan8[i+p*16] ] || h->mb[i*16+p*256]){ //FIXME benchmark weird rule, & below",
          "1887:                     uint8_t * const ptr= dest_y + block_offset[i];",
          "1888:                     ff_svq3_add_idct_c(ptr, h->mb + i*16 + p*256, linesize, s->qscale, IS_INTRA(mb_type) ? 1 : 0);",
          "1890:             }",
          "1895: static av_always_inline void hl_decode_mb_internal(H264Context *h, int simple, int pixel_shift)",
          "1897:     MpegEncContext * const s = &h->s;",
          "1898:     const int mb_x= s->mb_x;",
          "1899:     const int mb_y= s->mb_y;",
          "1900:     const int mb_xy= h->mb_xy;",
          "1902:     uint8_t  *dest_y, *dest_cb, *dest_cr;",
          "",
          "[Added Lines]",
          "1854:             if (s->mb_x + 1 < s->mb_width) {",
          "1855:                 XCHG(h->top_borders[top_idx][s->mb_x + 1] + (16 << pixel_shift), src_cb + (17 << pixel_shift), 1);",
          "1856:                 XCHG(h->top_borders[top_idx][s->mb_x + 1] + (32 << pixel_shift), src_cr + (17 << pixel_shift), 1);",
          "1859:             if (deblock_top) {",
          "1860:                 if (deblock_topleft) {",
          "1864:                 XCHG(top_border + (16 << pixel_shift), src_cb + 1 + pixel_shift, 1);",
          "1865:                 XCHG(top_border + (24 << pixel_shift), src_cr + 1 + pixel_shift, 1);",
          "1871: static av_always_inline int dctcoef_get(DCTELEM *mb, int high_bit_depth,",
          "1872:                                         int index)",
          "1873: {",
          "1875:         return AV_RN32A(((int32_t *)mb) + index);",
          "1880: static av_always_inline void dctcoef_set(DCTELEM *mb, int high_bit_depth,",
          "1881:                                          int index, int value)",
          "1882: {",
          "1884:         AV_WN32A(((int32_t *)mb) + index, value);",
          "1889: static av_always_inline void hl_decode_mb_predict_luma(H264Context *h,",
          "1890:                                                        int mb_type, int is_h264,",
          "1891:                                                        int simple,",
          "1892:                                                        int transform_bypass,",
          "1893:                                                        int pixel_shift,",
          "1894:                                                        int *block_offset,",
          "1895:                                                        int linesize,",
          "1896:                                                        uint8_t *dest_y, int p)",
          "1898:     MpegEncContext *const s = &h->s;",
          "1902:     int qscale = p == 0 ? s->qscale : h->chroma_qp[p - 1];",
          "1903:     block_offset += 16 * p;",
          "1904:     if (IS_INTRA4x4(mb_type)) {",
          "1905:         if (simple || !s->encoding) {",
          "1906:             if (IS_8x8DCT(mb_type)) {",
          "1907:                 if (transform_bypass) {",
          "1908:                     idct_dc_add  =",
          "1909:                     idct_add     = s->dsp.add_pixels8;",
          "1910:                 } else {",
          "1914:                 for (i = 0; i < 16; i += 4) {",
          "1915:                     uint8_t *const ptr = dest_y + block_offset[i];",
          "1916:                     const int dir      = h->intra4x4_pred_mode_cache[scan8[i]];",
          "1917:                     if (transform_bypass && h->sps.profile_idc == 244 && dir <= 1) {",
          "1918:                         h->hpc.pred8x8l_add[dir](ptr, h->mb + (i * 16 + p * 256 << pixel_shift), linesize);",
          "1919:                     } else {",
          "1920:                         const int nnz = h->non_zero_count_cache[scan8[i + p * 16]];",
          "1921:                         h->hpc.pred8x8l[dir](ptr, (h->topleft_samples_available << i) & 0x8000,",
          "1922:                                              (h->topright_samples_available << i) & 0x4000, linesize);",
          "1923:                         if (nnz) {",
          "1924:                             if (nnz == 1 && dctcoef_get(h->mb, pixel_shift, i * 16 + p * 256))",
          "1925:                                 idct_dc_add(ptr, h->mb + (i * 16 + p * 256 << pixel_shift), linesize);",
          "1927:                                 idct_add(ptr, h->mb + (i * 16 + p * 256 << pixel_shift), linesize);",
          "1931:             } else {",
          "1932:                 if (transform_bypass) {",
          "1933:                     idct_dc_add  =",
          "1934:                         idct_add = s->dsp.add_pixels4;",
          "1935:                 } else {",
          "1939:                 for (i = 0; i < 16; i++) {",
          "1940:                     uint8_t *const ptr = dest_y + block_offset[i];",
          "1941:                     const int dir      = h->intra4x4_pred_mode_cache[scan8[i]];",
          "1943:                     if (transform_bypass && h->sps.profile_idc == 244 && dir <= 1) {",
          "1944:                         h->hpc.pred4x4_add[dir](ptr, h->mb + (i * 16 + p * 256 << pixel_shift), linesize);",
          "1945:                     } else {",
          "1949:                         if (dir == DIAG_DOWN_LEFT_PRED || dir == VERT_LEFT_PRED) {",
          "1950:                             const int topright_avail = (h->topright_samples_available << i) & 0x8000;",
          "1952:                             if (!topright_avail) {",
          "1954:                                     tr_high  = ((uint16_t *)ptr)[3 - linesize / 2] * 0x0001000100010001ULL;",
          "1955:                                     topright = (uint8_t *)&tr_high;",
          "1957:                                     tr       = ptr[3 - linesize] * 0x01010101u;",
          "1958:                                     topright = (uint8_t *)&tr;",
          "1960:                             } else",
          "1961:                                 topright = ptr + (4 << pixel_shift) - linesize;",
          "1962:                         } else",
          "1963:                             topright = NULL;",
          "1965:                         h->hpc.pred4x4[dir](ptr, topright, linesize);",
          "1966:                         nnz = h->non_zero_count_cache[scan8[i + p * 16]];",
          "1967:                         if (nnz) {",
          "1968:                             if (is_h264) {",
          "1969:                                 if (nnz == 1 && dctcoef_get(h->mb, pixel_shift, i * 16 + p * 256))",
          "1970:                                     idct_dc_add(ptr, h->mb + (i * 16 + p * 256 << pixel_shift), linesize);",
          "1972:                                     idct_add(ptr, h->mb + (i * 16 + p * 256 << pixel_shift), linesize);",
          "1974:                                 ff_svq3_add_idct_c(ptr, h->mb + i * 16 + p * 256, linesize, qscale, 0);",
          "1980:     } else {",
          "1981:         h->hpc.pred16x16[h->intra16x16_pred_mode](dest_y, linesize);",
          "1982:         if (is_h264) {",
          "1983:             if (h->non_zero_count_cache[scan8[LUMA_DC_BLOCK_INDEX + p]]) {",
          "1984:                 if (!transform_bypass)",
          "1985:                     h->h264dsp.h264_luma_dc_dequant_idct(h->mb + (p * 256 << pixel_shift),",
          "1986:                                                          h->mb_luma_dc[p],",
          "1987:                                                          h->dequant4_coeff[p][qscale][0]);",
          "1988:                 else {",
          "1989:                     static const uint8_t dc_mapping[16] = {",
          "1990:                          0 * 16,  1 * 16,  4 * 16,  5 * 16,",
          "1991:                          2 * 16,  3 * 16,  6 * 16,  7 * 16,",
          "1992:                          8 * 16,  9 * 16, 12 * 16, 13 * 16,",
          "1993:                         10 * 16, 11 * 16, 14 * 16, 15 * 16 };",
          "1994:                     for (i = 0; i < 16; i++)",
          "1995:                         dctcoef_set(h->mb + (p * 256 << pixel_shift),",
          "1996:                                     pixel_shift, dc_mapping[i],",
          "1997:                                     dctcoef_get(h->mb_luma_dc[p],",
          "1998:                                                 pixel_shift, i));",
          "2002:             ff_svq3_luma_dc_dequant_idct_c(h->mb + p * 256,",
          "2003:                                            h->mb_luma_dc[p], qscale);",
          "2007: static av_always_inline void hl_decode_mb_idct_luma(H264Context *h, int mb_type,",
          "2008:                                                     int is_h264, int simple,",
          "2009:                                                     int transform_bypass,",
          "2010:                                                     int pixel_shift,",
          "2011:                                                     int *block_offset,",
          "2012:                                                     int linesize,",
          "2013:                                                     uint8_t *dest_y, int p)",
          "2015:     MpegEncContext *const s = &h->s;",
          "2018:     block_offset += 16 * p;",
          "2019:     if (!IS_INTRA4x4(mb_type)) {",
          "2020:         if (is_h264) {",
          "2021:             if (IS_INTRA16x16(mb_type)) {",
          "2022:                 if (transform_bypass) {",
          "2023:                     if (h->sps.profile_idc == 244 &&",
          "2024:                         (h->intra16x16_pred_mode == VERT_PRED8x8 ||",
          "2025:                          h->intra16x16_pred_mode == HOR_PRED8x8)) {",
          "2026:                         h->hpc.pred16x16_add[h->intra16x16_pred_mode](dest_y, block_offset,",
          "2027:                                                                       h->mb + (p * 256 << pixel_shift),",
          "2028:                                                                       linesize);",
          "2029:                     } else {",
          "2030:                         for (i = 0; i < 16; i++)",
          "2031:                             if (h->non_zero_count_cache[scan8[i + p * 16]] ||",
          "2032:                                 dctcoef_get(h->mb, pixel_shift, i * 16 + p * 256))",
          "2033:                                 s->dsp.add_pixels4(dest_y + block_offset[i],",
          "2034:                                                    h->mb + (i * 16 + p * 256 << pixel_shift),",
          "2035:                                                    linesize);",
          "2037:                 } else {",
          "2038:                     h->h264dsp.h264_idct_add16intra(dest_y, block_offset,",
          "2039:                                                     h->mb + (p * 256 << pixel_shift),",
          "2040:                                                     linesize,",
          "2041:                                                     h->non_zero_count_cache + p * 5 * 8);",
          "2043:             } else if (h->cbp & 15) {",
          "2044:                 if (transform_bypass) {",
          "2046:                     idct_add = IS_8x8DCT(mb_type) ? s->dsp.add_pixels8",
          "2047:                                                   : s->dsp.add_pixels4;",
          "2048:                     for (i = 0; i < 16; i += di)",
          "2049:                         if (h->non_zero_count_cache[scan8[i + p * 16]])",
          "2050:                             idct_add(dest_y + block_offset[i],",
          "2051:                                      h->mb + (i * 16 + p * 256 << pixel_shift),",
          "2052:                                      linesize);",
          "2053:                 } else {",
          "2054:                     if (IS_8x8DCT(mb_type))",
          "2055:                         h->h264dsp.h264_idct8_add4(dest_y, block_offset,",
          "2056:                                                    h->mb + (p * 256 << pixel_shift),",
          "2057:                                                    linesize,",
          "2058:                                                    h->non_zero_count_cache + p * 5 * 8);",
          "2059:                     else",
          "2060:                         h->h264dsp.h264_idct_add16(dest_y, block_offset,",
          "2061:                                                    h->mb + (p * 256 << pixel_shift),",
          "2062:                                                    linesize,",
          "2063:                                                    h->non_zero_count_cache + p * 5 * 8);",
          "2067:             for (i = 0; i < 16; i++)",
          "2068:                 if (h->non_zero_count_cache[scan8[i + p * 16]] || h->mb[i * 16 + p * 256]) {",
          "2070:                     uint8_t *const ptr = dest_y + block_offset[i];",
          "2071:                     ff_svq3_add_idct_c(ptr, h->mb + i * 16 + p * 256, linesize,",
          "2072:                                        s->qscale, IS_INTRA(mb_type) ? 1 : 0);",
          "2078: static av_always_inline void hl_decode_mb_internal(H264Context *h, int simple,",
          "2079:                                                    int pixel_shift)",
          "2081:     MpegEncContext *const s = &h->s;",
          "2082:     const int mb_x    = s->mb_x;",
          "2083:     const int mb_y    = s->mb_y;",
          "2084:     const int mb_xy   = h->mb_xy;",
          "2086:     uint8_t *dest_y, *dest_cb, *dest_cr;",
          "",
          "---------------",
          "--- Hunk 28 ---",
          "[Context before]",
          "1908:     const int is_h264 = !CONFIG_SVQ3_DECODER || simple || s->codec_id == CODEC_ID_H264;",
          "1909:     void (*idct_add)(uint8_t *dst, DCTELEM *block, int stride);",
          "1911:     const int chroma422 = CHROMA422;",
          "1922:     if (!simple && MB_FIELD) {",
          "1925:         block_offset = &h->block_offset[48];",
          "1930:         }",
          "1932:             int list;",
          "1935:                     continue;",
          "1937:                     int8_t *ref = &h->ref_cache[list][scan8[0]];",
          "1941:                         int ref = h->ref_cache[list][scan8[i]];",
          "1944:                     }",
          "1945:                 }",
          "1946:             }",
          "",
          "[Removed Lines]",
          "1910:     const int block_h = 16 >> s->chroma_y_shift;",
          "1913:     dest_y  = s->current_picture.f.data[0] + ((mb_x << pixel_shift) + mb_y * s->linesize  ) * 16;",
          "1914:     dest_cb = s->current_picture.f.data[1] + (mb_x << pixel_shift)*8 + mb_y * s->uvlinesize * block_h;",
          "1915:     dest_cr = s->current_picture.f.data[2] + (mb_x << pixel_shift)*8 + mb_y * s->uvlinesize * block_h;",
          "1917:     s->dsp.prefetch(dest_y + (s->mb_x&3)*4*s->linesize + (64 << pixel_shift), s->linesize, 4);",
          "1918:     s->dsp.prefetch(dest_cb + (s->mb_x&7)*s->uvlinesize + (64 << pixel_shift), dest_cr - dest_cb, 2);",
          "1920:     h->list_counts[mb_xy]= h->list_count;",
          "1923:         linesize   = h->mb_linesize   = s->linesize * 2;",
          "1924:         uvlinesize = h->mb_uvlinesize = s->uvlinesize * 2;",
          "1926:         if(mb_y&1){ //FIXME move out of this function?",
          "1927:             dest_y -= s->linesize*15;",
          "1928:             dest_cb-= s->uvlinesize * (block_h - 1);",
          "1929:             dest_cr-= s->uvlinesize * (block_h - 1);",
          "1931:         if(FRAME_MBAFF) {",
          "1933:             for(list=0; list<h->list_count; list++){",
          "1934:                 if(!USES_LIST(mb_type, list))",
          "1936:                 if(IS_16X16(mb_type)){",
          "1938:                     fill_rectangle(ref, 4, 4, 8, (16+*ref)^(s->mb_y&1), 1);",
          "1939:                 }else{",
          "1940:                     for(i=0; i<16; i+=4){",
          "1942:                         if(ref >= 0)",
          "1943:                             fill_rectangle(&h->ref_cache[list][scan8[i]], 2, 2, 8, (16+ref)^(s->mb_y&1), 1);",
          "",
          "[Added Lines]",
          "2094:     const int block_h   = 16 >> s->chroma_y_shift;",
          "2097:     dest_y  = s->current_picture.f.data[0] + ((mb_x << pixel_shift)     + mb_y * s->linesize)  * 16;",
          "2098:     dest_cb = s->current_picture.f.data[1] +  (mb_x << pixel_shift) * 8 + mb_y * s->uvlinesize * block_h;",
          "2099:     dest_cr = s->current_picture.f.data[2] +  (mb_x << pixel_shift) * 8 + mb_y * s->uvlinesize * block_h;",
          "2101:     s->dsp.prefetch(dest_y  + (s->mb_x & 3) * 4 * s->linesize   + (64 << pixel_shift), s->linesize,       4);",
          "2102:     s->dsp.prefetch(dest_cb + (s->mb_x & 7)     * s->uvlinesize + (64 << pixel_shift), dest_cr - dest_cb, 2);",
          "2104:     h->list_counts[mb_xy] = h->list_count;",
          "2107:         linesize     = h->mb_linesize = s->linesize * 2;",
          "2108:         uvlinesize   = h->mb_uvlinesize = s->uvlinesize * 2;",
          "2110:         if (mb_y & 1) { // FIXME move out of this function?",
          "2111:             dest_y  -= s->linesize * 15;",
          "2112:             dest_cb -= s->uvlinesize * (block_h - 1);",
          "2113:             dest_cr -= s->uvlinesize * (block_h - 1);",
          "2115:         if (FRAME_MBAFF) {",
          "2117:             for (list = 0; list < h->list_count; list++) {",
          "2118:                 if (!USES_LIST(mb_type, list))",
          "2120:                 if (IS_16X16(mb_type)) {",
          "2122:                     fill_rectangle(ref, 4, 4, 8, (16 + *ref) ^ (s->mb_y & 1), 1);",
          "2123:                 } else {",
          "2124:                     for (i = 0; i < 16; i += 4) {",
          "2126:                         if (ref >= 0)",
          "2127:                             fill_rectangle(&h->ref_cache[list][scan8[i]], 2, 2,",
          "2128:                                            8, (16 + ref) ^ (s->mb_y & 1), 1);",
          "",
          "---------------",
          "--- Hunk 29 ---",
          "[Context before]",
          "1956:             const int bit_depth = h->sps.bit_depth_luma;",
          "1957:             int j;",
          "1958:             GetBitContext gb;",
          "1961:             for (i = 0; i < 16; i++) {",
          "1963:                 for (j = 0; j < 16; j++)",
          "1964:                     tmp_y[j] = get_bits(&gb, bit_depth);",
          "1965:             }",
          "1967:                 if (!h->sps.chroma_format_idc) {",
          "1968:                     for (i = 0; i < block_h; i++) {",
          "1971:                             tmp_cb[j] = 1 << (bit_depth - 1);",
          "1973:                     }",
          "1974:                     for (i = 0; i < block_h; i++) {",
          "1977:                             tmp_cr[j] = 1 << (bit_depth - 1);",
          "1979:                     }",
          "1980:                 } else {",
          "1981:                     for (i = 0; i < block_h; i++) {",
          "1983:                         for (j = 0; j < 8; j++)",
          "1984:                             tmp_cb[j] = get_bits(&gb, bit_depth);",
          "1985:                     }",
          "1986:                     for (i = 0; i < block_h; i++) {",
          "1988:                         for (j = 0; j < 8; j++)",
          "1989:                             tmp_cr[j] = get_bits(&gb, bit_depth);",
          "1990:                     }",
          "1991:                 }",
          "1992:             }",
          "1993:         } else {",
          "1998:                 if (!h->sps.chroma_format_idc) {",
          "1999:                     for (i = 0; i < block_h; i++) {",
          "2002:                     }",
          "2003:                 } else {",
          "2004:                     for (i = 0; i < block_h; i++) {",
          "2007:                     }",
          "2008:                 }",
          "2009:             }",
          "2010:         }",
          "2011:     } else {",
          "2019:             }",
          "2026:             if (chroma422) {",
          "2027:                 hl_motion_422(h, dest_y, dest_cb, dest_cr,",
          "2028:                               s->me.qpel_put, s->dsp.put_h264_chroma_pixels_tab,",
          "",
          "[Removed Lines]",
          "1959:             init_get_bits(&gb, (uint8_t*)h->mb, 384*bit_depth);",
          "1962:                 uint16_t *tmp_y  = (uint16_t*)(dest_y  + i*linesize);",
          "1966:             if(simple || !CONFIG_GRAY || !(s->flags&CODEC_FLAG_GRAY)){",
          "1969:                         uint16_t *tmp_cb = (uint16_t*)(dest_cb + i*uvlinesize);",
          "1970:                         for (j = 0; j < 8; j++) {",
          "1972:                         }",
          "1975:                         uint16_t *tmp_cr = (uint16_t*)(dest_cr + i*uvlinesize);",
          "1976:                         for (j = 0; j < 8; j++) {",
          "1978:                         }",
          "1982:                         uint16_t *tmp_cb = (uint16_t*)(dest_cb + i*uvlinesize);",
          "1987:                         uint16_t *tmp_cr = (uint16_t*)(dest_cr + i*uvlinesize);",
          "1994:             for (i=0; i<16; i++) {",
          "1995:                 memcpy(dest_y + i*  linesize, h->mb       + i*8, 16);",
          "1996:             }",
          "1997:             if(simple || !CONFIG_GRAY || !(s->flags&CODEC_FLAG_GRAY)){",
          "2000:                         memset(dest_cb + i*uvlinesize, 128, 8);",
          "2001:                         memset(dest_cr + i*uvlinesize, 128, 8);",
          "2005:                         memcpy(dest_cb + i*uvlinesize, h->mb + 128 + i*4,  8);",
          "2006:                         memcpy(dest_cr + i*uvlinesize, h->mb + 160 + i*4,  8);",
          "2012:         if(IS_INTRA(mb_type)){",
          "2013:             if(h->deblocking_filter)",
          "2014:                 xchg_mb_border(h, dest_y, dest_cb, dest_cr, linesize, uvlinesize, 1, 0, simple, pixel_shift);",
          "2016:             if(simple || !CONFIG_GRAY || !(s->flags&CODEC_FLAG_GRAY)){",
          "2017:                 h->hpc.pred8x8[ h->chroma_pred_mode ](dest_cb, uvlinesize);",
          "2018:                 h->hpc.pred8x8[ h->chroma_pred_mode ](dest_cr, uvlinesize);",
          "2021:             hl_decode_mb_predict_luma(h, mb_type, is_h264, simple, transform_bypass, pixel_shift, block_offset, linesize, dest_y, 0);",
          "2023:             if(h->deblocking_filter)",
          "2024:                 xchg_mb_border(h, dest_y, dest_cb, dest_cr, linesize, uvlinesize, 0, 0, simple, pixel_shift);",
          "2025:         }else if(is_h264){",
          "",
          "[Added Lines]",
          "2144:             init_get_bits(&gb, (uint8_t *)h->mb, 384 * bit_depth);",
          "2147:                 uint16_t *tmp_y = (uint16_t *)(dest_y + i * linesize);",
          "2151:             if (simple || !CONFIG_GRAY || !(s->flags & CODEC_FLAG_GRAY)) {",
          "2154:                         uint16_t *tmp_cb = (uint16_t *)(dest_cb + i * uvlinesize);",
          "2155:                         for (j = 0; j < 8; j++)",
          "2159:                         uint16_t *tmp_cr = (uint16_t *)(dest_cr + i * uvlinesize);",
          "2160:                         for (j = 0; j < 8; j++)",
          "2165:                         uint16_t *tmp_cb = (uint16_t *)(dest_cb + i * uvlinesize);",
          "2170:                         uint16_t *tmp_cr = (uint16_t *)(dest_cr + i * uvlinesize);",
          "2177:             for (i = 0; i < 16; i++)",
          "2178:                 memcpy(dest_y + i * linesize, h->mb + i * 8, 16);",
          "2179:             if (simple || !CONFIG_GRAY || !(s->flags & CODEC_FLAG_GRAY)) {",
          "2182:                         memset(dest_cb + i * uvlinesize, 128, 8);",
          "2183:                         memset(dest_cr + i * uvlinesize, 128, 8);",
          "2187:                         memcpy(dest_cb + i * uvlinesize, h->mb + 128 + i * 4, 8);",
          "2188:                         memcpy(dest_cr + i * uvlinesize, h->mb + 160 + i * 4, 8);",
          "2194:         if (IS_INTRA(mb_type)) {",
          "2195:             if (h->deblocking_filter)",
          "2196:                 xchg_mb_border(h, dest_y, dest_cb, dest_cr, linesize,",
          "2197:                                uvlinesize, 1, 0, simple, pixel_shift);",
          "2199:             if (simple || !CONFIG_GRAY || !(s->flags & CODEC_FLAG_GRAY)) {",
          "2200:                 h->hpc.pred8x8[h->chroma_pred_mode](dest_cb, uvlinesize);",
          "2201:                 h->hpc.pred8x8[h->chroma_pred_mode](dest_cr, uvlinesize);",
          "2204:             hl_decode_mb_predict_luma(h, mb_type, is_h264, simple,",
          "2205:                                       transform_bypass, pixel_shift,",
          "2206:                                       block_offset, linesize, dest_y, 0);",
          "2208:             if (h->deblocking_filter)",
          "2209:                 xchg_mb_border(h, dest_y, dest_cb, dest_cr, linesize,",
          "2210:                                uvlinesize, 0, 0, simple, pixel_shift);",
          "2211:         } else if (is_h264) {",
          "",
          "---------------",
          "--- Hunk 30 ---",
          "[Context before]",
          "2040:             }",
          "2041:         }",
          "2052:                     idct_add = s->dsp.add_pixels4;",
          "2058:                         if (chroma422) {",
          "2063:                         }",
          "2064:                     }",
          "2065:                 }",
          "2068:                     int qp[2];",
          "2069:                     if (chroma422) {",
          "2070:                         qp[0] = h->chroma_qp[0] + 3;",
          "",
          "[Removed Lines]",
          "2043:         hl_decode_mb_idct_luma(h, mb_type, is_h264, simple, transform_bypass, pixel_shift, block_offset, linesize, dest_y, 0);",
          "2045:         if((simple || !CONFIG_GRAY || !(s->flags&CODEC_FLAG_GRAY)) && (h->cbp&0x30)){",
          "2046:             uint8_t *dest[2] = {dest_cb, dest_cr};",
          "2047:             if(transform_bypass){",
          "2048:                 if(IS_INTRA(mb_type) && h->sps.profile_idc==244 && (h->chroma_pred_mode==VERT_PRED8x8 || h->chroma_pred_mode==HOR_PRED8x8)){",
          "2049:                     h->hpc.pred8x8_add[h->chroma_pred_mode](dest[0], block_offset + 16, h->mb + (16*16*1 << pixel_shift), uvlinesize);",
          "2050:                     h->hpc.pred8x8_add[h->chroma_pred_mode](dest[1], block_offset + 32, h->mb + (16*16*2 << pixel_shift), uvlinesize);",
          "2051:                 }else{",
          "2053:                     for(j=1; j<3; j++){",
          "2054:                         for(i=j*16; i<j*16+4; i++){",
          "2055:                             if(h->non_zero_count_cache[ scan8[i] ] || dctcoef_get(h->mb, pixel_shift, i*16))",
          "2056:                                 idct_add   (dest[j-1] + block_offset[i], h->mb + (i*16 << pixel_shift), uvlinesize);",
          "2057:                         }",
          "2059:                             for(i=j*16+4; i<j*16+8; i++){",
          "2060:                                 if(h->non_zero_count_cache[ scan8[i+4] ] || dctcoef_get(h->mb, pixel_shift, i*16))",
          "2061:                                     idct_add   (dest[j-1] + block_offset[i+4], h->mb + (i*16 << pixel_shift), uvlinesize);",
          "2062:                             }",
          "2066:             }else{",
          "2067:                 if(is_h264){",
          "",
          "[Added Lines]",
          "2229:         hl_decode_mb_idct_luma(h, mb_type, is_h264, simple, transform_bypass,",
          "2230:                                pixel_shift, block_offset, linesize, dest_y, 0);",
          "2232:         if ((simple || !CONFIG_GRAY || !(s->flags & CODEC_FLAG_GRAY)) &&",
          "2233:             (h->cbp & 0x30)) {",
          "2234:             uint8_t *dest[2] = { dest_cb, dest_cr };",
          "2235:             if (transform_bypass) {",
          "2236:                 if (IS_INTRA(mb_type) && h->sps.profile_idc == 244 &&",
          "2237:                     (h->chroma_pred_mode == VERT_PRED8x8 ||",
          "2238:                      h->chroma_pred_mode == HOR_PRED8x8)) {",
          "2239:                     h->hpc.pred8x8_add[h->chroma_pred_mode](dest[0],",
          "2240:                                                             block_offset + 16,",
          "2241:                                                             h->mb + (16 * 16 * 1 << pixel_shift),",
          "2242:                                                             uvlinesize);",
          "2243:                     h->hpc.pred8x8_add[h->chroma_pred_mode](dest[1],",
          "2244:                                                             block_offset + 32,",
          "2245:                                                             h->mb + (16 * 16 * 2 << pixel_shift),",
          "2246:                                                             uvlinesize);",
          "2247:                 } else {",
          "2249:                     for (j = 1; j < 3; j++) {",
          "2250:                         for (i = j * 16; i < j * 16 + 4; i++)",
          "2251:                             if (h->non_zero_count_cache[scan8[i]] ||",
          "2252:                                 dctcoef_get(h->mb, pixel_shift, i * 16))",
          "2253:                                 idct_add(dest[j - 1] + block_offset[i],",
          "2254:                                          h->mb + (i * 16 << pixel_shift),",
          "2255:                                          uvlinesize);",
          "2257:                             for (i = j * 16 + 4; i < j * 16 + 8; i++)",
          "2258:                                 if (h->non_zero_count_cache[scan8[i + 4]] ||",
          "2259:                                     dctcoef_get(h->mb, pixel_shift, i * 16))",
          "2260:                                     idct_add(dest[j - 1] + block_offset[i + 4],",
          "2261:                                              h->mb + (i * 16 << pixel_shift),",
          "2262:                                              uvlinesize);",
          "2266:             } else {",
          "2267:                 if (is_h264) {",
          "",
          "---------------",
          "--- Hunk 31 ---",
          "[Context before]",
          "2073:                         qp[0] = h->chroma_qp[0];",
          "2074:                         qp[1] = h->chroma_qp[1];",
          "2075:                     }",
          "2080:                     h->h264dsp.h264_idct_add8(dest, block_offset,",
          "2081:                                               h->mb, uvlinesize,",
          "2082:                                               h->non_zero_count_cache);",
          "2083:                 } else if (CONFIG_SVQ3_DECODER) {",
          "2091:                             }",
          "2093:                     }",
          "2094:                 }",
          "2095:             }",
          "2096:         }",
          "2097:     }",
          "2100:         s->dsp.clear_blocks(h->mb);",
          "2102:     }",
          "2103: }",
          "2110:     const int mb_type = s->current_picture.f.mb_type[mb_xy];",
          "2112:     int linesize;",
          "2113:     int i, j, p;",
          "2114:     int *block_offset = &h->block_offset[0];",
          "2115:     const int transform_bypass = !simple && (s->qscale == 0 && h->sps.transform_bypass);",
          "2122:     }",
          "2126:     if (!simple && MB_FIELD) {",
          "2128:         block_offset = &h->block_offset[48];",
          "2130:             for (p = 0; p < 3; p++)",
          "2133:             int list;",
          "2136:                     continue;",
          "2138:                     int8_t *ref = &h->ref_cache[list][scan8[0]];",
          "2142:                         int ref = h->ref_cache[list][scan8[i]];",
          "2145:                     }",
          "2146:                 }",
          "2147:             }",
          "2148:         }",
          "2149:     } else {",
          "2151:     }",
          "2153:     if (!simple && IS_INTRA_PCM(mb_type)) {",
          "2154:         if (pixel_shift) {",
          "2155:             const int bit_depth = h->sps.bit_depth_luma;",
          "2156:             GetBitContext gb;",
          "2160:                 for (i = 0; i < 16; i++) {",
          "2162:                     for (j = 0; j < 16; j++)",
          "2163:                         tmp[j] = get_bits(&gb, bit_depth);",
          "2164:                 }",
          "2166:         } else {",
          "2172:         }",
          "2173:     } else {",
          "2178:             for (p = 0; p < plane_count; p++)",
          "2184:             hl_motion(h, dest[0], dest[1], dest[2],",
          "2185:                       s->me.qpel_put, s->dsp.put_h264_chroma_pixels_tab,",
          "2186:                       s->me.qpel_avg, s->dsp.avg_h264_chroma_pixels_tab,",
          "",
          "[Removed Lines]",
          "2076:                     if(h->non_zero_count_cache[ scan8[CHROMA_DC_BLOCK_INDEX+0] ])",
          "2077:                         h->h264dsp.h264_chroma_dc_dequant_idct(h->mb + (16*16*1 << pixel_shift), h->dequant4_coeff[IS_INTRA(mb_type) ? 1:4][qp[0]][0]);",
          "2078:                     if(h->non_zero_count_cache[ scan8[CHROMA_DC_BLOCK_INDEX+1] ])",
          "2079:                         h->h264dsp.h264_chroma_dc_dequant_idct(h->mb + (16*16*2 << pixel_shift), h->dequant4_coeff[IS_INTRA(mb_type) ? 2:5][qp[1]][0]);",
          "2084:                     h->h264dsp.h264_chroma_dc_dequant_idct(h->mb + 16*16*1, h->dequant4_coeff[IS_INTRA(mb_type) ? 1:4][h->chroma_qp[0]][0]);",
          "2085:                     h->h264dsp.h264_chroma_dc_dequant_idct(h->mb + 16*16*2, h->dequant4_coeff[IS_INTRA(mb_type) ? 2:5][h->chroma_qp[1]][0]);",
          "2086:                     for(j=1; j<3; j++){",
          "2087:                         for(i=j*16; i<j*16+4; i++){",
          "2088:                             if(h->non_zero_count_cache[ scan8[i] ] || h->mb[i*16]){",
          "2089:                                 uint8_t * const ptr= dest[j-1] + block_offset[i];",
          "2090:                                 ff_svq3_add_idct_c(ptr, h->mb + i*16, uvlinesize, ff_h264_chroma_qp[0][s->qscale + 12] - 12, 2);",
          "2092:                         }",
          "2098:     if(h->cbp || IS_INTRA(mb_type))",
          "2099:     {",
          "2101:         s->dsp.clear_blocks(h->mb+(24*16<<pixel_shift));",
          "2105: static av_always_inline void hl_decode_mb_444_internal(H264Context *h, int simple, int pixel_shift){",
          "2106:     MpegEncContext * const s = &h->s;",
          "2107:     const int mb_x= s->mb_x;",
          "2108:     const int mb_y= s->mb_y;",
          "2109:     const int mb_xy= h->mb_xy;",
          "2111:     uint8_t  *dest[3];",
          "2116:     const int plane_count = (simple || !CONFIG_GRAY || !(s->flags&CODEC_FLAG_GRAY)) ? 3 : 1;",
          "2118:     for (p = 0; p < plane_count; p++)",
          "2119:     {",
          "2120:         dest[p] = s->current_picture.f.data[p] + ((mb_x << pixel_shift) + mb_y * s->linesize) * 16;",
          "2121:         s->dsp.prefetch(dest[p] + (s->mb_x&3)*4*s->linesize + (64 << pixel_shift), s->linesize, 4);",
          "2124:     h->list_counts[mb_xy]= h->list_count;",
          "2127:         linesize   = h->mb_linesize = h->mb_uvlinesize = s->linesize * 2;",
          "2129:         if(mb_y&1) //FIXME move out of this function?",
          "2131:                 dest[p] -= s->linesize*15;",
          "2132:         if(FRAME_MBAFF) {",
          "2134:             for(list=0; list<h->list_count; list++){",
          "2135:                 if(!USES_LIST(mb_type, list))",
          "2137:                 if(IS_16X16(mb_type)){",
          "2139:                     fill_rectangle(ref, 4, 4, 8, (16+*ref)^(s->mb_y&1), 1);",
          "2140:                 }else{",
          "2141:                     for(i=0; i<16; i+=4){",
          "2143:                         if(ref >= 0)",
          "2144:                             fill_rectangle(&h->ref_cache[list][scan8[i]], 2, 2, 8, (16+ref)^(s->mb_y&1), 1);",
          "2150:         linesize   = h->mb_linesize = h->mb_uvlinesize = s->linesize;",
          "2157:             init_get_bits(&gb, (uint8_t*)h->mb, 768*bit_depth);",
          "2159:             for (p = 0; p < plane_count; p++) {",
          "2161:                     uint16_t *tmp = (uint16_t*)(dest[p] + i*linesize);",
          "2165:             }",
          "2167:             for (p = 0; p < plane_count; p++) {",
          "2168:                 for (i = 0; i < 16; i++) {",
          "2169:                     memcpy(dest[p] + i*linesize, h->mb + p*128 + i*8, 16);",
          "2170:                 }",
          "2171:             }",
          "2174:         if(IS_INTRA(mb_type)){",
          "2175:             if(h->deblocking_filter)",
          "2176:                 xchg_mb_border(h, dest[0], dest[1], dest[2], linesize, linesize, 1, 1, simple, pixel_shift);",
          "2179:                 hl_decode_mb_predict_luma(h, mb_type, 1, simple, transform_bypass, pixel_shift, block_offset, linesize, dest[p], p);",
          "2181:             if(h->deblocking_filter)",
          "2182:                 xchg_mb_border(h, dest[0], dest[1], dest[2], linesize, linesize, 0, 1, simple, pixel_shift);",
          "2183:         }else{",
          "",
          "[Added Lines]",
          "2276:                     if (h->non_zero_count_cache[scan8[CHROMA_DC_BLOCK_INDEX + 0]])",
          "2277:                         h->h264dsp.h264_chroma_dc_dequant_idct(h->mb + (16 * 16 * 1 << pixel_shift),",
          "2278:                                                                h->dequant4_coeff[IS_INTRA(mb_type) ? 1 : 4][qp[0]][0]);",
          "2279:                     if (h->non_zero_count_cache[scan8[CHROMA_DC_BLOCK_INDEX + 1]])",
          "2280:                         h->h264dsp.h264_chroma_dc_dequant_idct(h->mb + (16 * 16 * 2 << pixel_shift),",
          "2281:                                                                h->dequant4_coeff[IS_INTRA(mb_type) ? 2 : 5][qp[1]][0]);",
          "2286:                     h->h264dsp.h264_chroma_dc_dequant_idct(h->mb + 16 * 16 * 1,",
          "2287:                                                            h->dequant4_coeff[IS_INTRA(mb_type) ? 1 : 4][h->chroma_qp[0]][0]);",
          "2288:                     h->h264dsp.h264_chroma_dc_dequant_idct(h->mb + 16 * 16 * 2,",
          "2289:                                                            h->dequant4_coeff[IS_INTRA(mb_type) ? 2 : 5][h->chroma_qp[1]][0]);",
          "2290:                     for (j = 1; j < 3; j++) {",
          "2291:                         for (i = j * 16; i < j * 16 + 4; i++)",
          "2292:                             if (h->non_zero_count_cache[scan8[i]] || h->mb[i * 16]) {",
          "2293:                                 uint8_t *const ptr = dest[j - 1] + block_offset[i];",
          "2294:                                 ff_svq3_add_idct_c(ptr, h->mb + i * 16,",
          "2295:                                                    uvlinesize,",
          "2296:                                                    ff_h264_chroma_qp[0][s->qscale + 12] - 12, 2);",
          "2303:     if (h->cbp || IS_INTRA(mb_type)) {",
          "2305:         s->dsp.clear_blocks(h->mb + (24 * 16 << pixel_shift));",
          "2309: static av_always_inline void hl_decode_mb_444_internal(H264Context *h,",
          "2310:                                                        int simple,",
          "2311:                                                        int pixel_shift)",
          "2312: {",
          "2313:     MpegEncContext *const s = &h->s;",
          "2314:     const int mb_x    = s->mb_x;",
          "2315:     const int mb_y    = s->mb_y;",
          "2316:     const int mb_xy   = h->mb_xy;",
          "2318:     uint8_t *dest[3];",
          "2323:     const int plane_count      = (simple || !CONFIG_GRAY || !(s->flags & CODEC_FLAG_GRAY)) ? 3 : 1;",
          "2325:     for (p = 0; p < plane_count; p++) {",
          "2326:         dest[p] = s->current_picture.f.data[p] +",
          "2327:                   ((mb_x << pixel_shift) + mb_y * s->linesize) * 16;",
          "2328:         s->dsp.prefetch(dest[p] + (s->mb_x & 3) * 4 * s->linesize + (64 << pixel_shift),",
          "2329:                         s->linesize, 4);",
          "2332:     h->list_counts[mb_xy] = h->list_count;",
          "2335:         linesize     = h->mb_linesize = h->mb_uvlinesize = s->linesize * 2;",
          "2337:         if (mb_y & 1) // FIXME move out of this function?",
          "2339:                 dest[p] -= s->linesize * 15;",
          "2340:         if (FRAME_MBAFF) {",
          "2342:             for (list = 0; list < h->list_count; list++) {",
          "2343:                 if (!USES_LIST(mb_type, list))",
          "2345:                 if (IS_16X16(mb_type)) {",
          "2347:                     fill_rectangle(ref, 4, 4, 8, (16 + *ref) ^ (s->mb_y & 1), 1);",
          "2348:                 } else {",
          "2349:                     for (i = 0; i < 16; i += 4) {",
          "2351:                         if (ref >= 0)",
          "2352:                             fill_rectangle(&h->ref_cache[list][scan8[i]], 2, 2,",
          "2353:                                            8, (16 + ref) ^ (s->mb_y & 1), 1);",
          "2359:         linesize = h->mb_linesize = h->mb_uvlinesize = s->linesize;",
          "2366:             init_get_bits(&gb, (uint8_t *)h->mb, 768 * bit_depth);",
          "2368:             for (p = 0; p < plane_count; p++)",
          "2370:                     uint16_t *tmp = (uint16_t *)(dest[p] + i * linesize);",
          "2375:             for (p = 0; p < plane_count; p++)",
          "2376:                 for (i = 0; i < 16; i++)",
          "2377:                     memcpy(dest[p] + i * linesize, h->mb + p * 128 + i * 8, 16);",
          "2380:         if (IS_INTRA(mb_type)) {",
          "2381:             if (h->deblocking_filter)",
          "2382:                 xchg_mb_border(h, dest[0], dest[1], dest[2], linesize,",
          "2383:                                linesize, 1, 1, simple, pixel_shift);",
          "2386:                 hl_decode_mb_predict_luma(h, mb_type, 1, simple,",
          "2387:                                           transform_bypass, pixel_shift,",
          "2388:                                           block_offset, linesize, dest[p], p);",
          "2390:             if (h->deblocking_filter)",
          "2391:                 xchg_mb_border(h, dest[0], dest[1], dest[2], linesize,",
          "2392:                                linesize, 0, 1, simple, pixel_shift);",
          "2393:         } else {",
          "",
          "---------------",
          "--- Hunk 32 ---",
          "[Context before]",
          "2189:         }",
          "2191:         for (p = 0; p < plane_count; p++)",
          "2193:     }",
          "2196:         s->dsp.clear_blocks(h->mb);",
          "2198:     }",
          "2199: }",
          "2207: }",
          "2208: hl_decode_mb_simple(0, 8)",
          "2209: hl_decode_mb_simple(1, 16)",
          "2215:     hl_decode_mb_internal(h, 0, h->pixel_shift);",
          "2216: }",
          "2219:     hl_decode_mb_444_internal(h, 0, h->pixel_shift);",
          "2220: }",
          "2223:     hl_decode_mb_444_internal(h, 1, 0);",
          "2224: }",
          "2229:     const int mb_type = s->current_picture.f.mb_type[mb_xy];",
          "2232:     if (CHROMA444) {",
          "2234:             hl_decode_mb_444_complex(h);",
          "2235:         else",
          "2236:             hl_decode_mb_444_simple(h);",
          "",
          "[Removed Lines]",
          "2192:             hl_decode_mb_idct_luma(h, mb_type, 1, simple, transform_bypass, pixel_shift, block_offset, linesize, dest[p], p);",
          "2194:     if(h->cbp || IS_INTRA(mb_type))",
          "2195:     {",
          "2197:         s->dsp.clear_blocks(h->mb+(24*16<<pixel_shift));",
          "2204: #define hl_decode_mb_simple(sh, bits) \\",
          "2205: static void hl_decode_mb_simple_ ## bits(H264Context *h){ \\",
          "2206:     hl_decode_mb_internal(h, 1, sh); \\",
          "2214: static void av_noinline hl_decode_mb_complex(H264Context *h){",
          "2218: static void av_noinline hl_decode_mb_444_complex(H264Context *h){",
          "2222: static void av_noinline hl_decode_mb_444_simple(H264Context *h){",
          "2226: void ff_h264_hl_decode_mb(H264Context *h){",
          "2227:     MpegEncContext * const s = &h->s;",
          "2228:     const int mb_xy= h->mb_xy;",
          "2230:     int is_complex = CONFIG_SMALL || h->is_complex || IS_INTRA_PCM(mb_type) || s->qscale == 0;",
          "2233:         if(is_complex || h->pixel_shift)",
          "",
          "[Added Lines]",
          "2402:             hl_decode_mb_idct_luma(h, mb_type, 1, simple, transform_bypass,",
          "2403:                                    pixel_shift, block_offset, linesize,",
          "2404:                                    dest[p], p);",
          "2406:     if (h->cbp || IS_INTRA(mb_type)) {",
          "2408:         s->dsp.clear_blocks(h->mb + (24 * 16 << pixel_shift));",
          "2415: #define hl_decode_mb_simple(sh, bits)                          \\",
          "2416: static void hl_decode_mb_simple_ ## bits(H264Context *h)       \\",
          "2417: {                                                              \\",
          "2418:     hl_decode_mb_internal(h, 1, sh);                           \\",
          "2427: static void av_noinline hl_decode_mb_complex(H264Context *h)",
          "2428: {",
          "2432: static void av_noinline hl_decode_mb_444_complex(H264Context *h)",
          "2433: {",
          "2437: static void av_noinline hl_decode_mb_444_simple(H264Context *h)",
          "2438: {",
          "2442: void ff_h264_hl_decode_mb(H264Context *h)",
          "2443: {",
          "2444:     MpegEncContext *const s = &h->s;",
          "2445:     const int mb_xy   = h->mb_xy;",
          "2447:     int is_complex    = CONFIG_SMALL || h->is_complex || IS_INTRA_PCM(mb_type) || s->qscale == 0;",
          "2450:         if (is_complex || h->pixel_shift)",
          "",
          "---------------",
          "--- Hunk 33 ---",
          "[Context before]",
          "2242:         hl_decode_mb_simple_8(h);",
          "2243: }",
          "2247:     int list, i;",
          "2248:     int luma_def, chroma_def;",
          "2259:         h->luma_weight_flag[list]   = 0;",
          "2260:         h->chroma_weight_flag[list] = 0;",
          "2262:             int luma_weight_flag, chroma_weight_flag;",
          "2272:                 }",
          "2276:             }",
          "2281:                     int j;",
          "2289:                         }",
          "2290:                     }",
          "2292:                     int j;",
          "2296:                     }",
          "2297:                 }",
          "2298:             }",
          "2299:         }",
          "2301:     }",
          "2303:     return 0;",
          "2304: }",
          "",
          "[Removed Lines]",
          "2245: static int pred_weight_table(H264Context *h){",
          "2246:     MpegEncContext * const s = &h->s;",
          "2250:     h->use_weight= 0;",
          "2251:     h->use_weight_chroma= 0;",
          "2252:     h->luma_log2_weight_denom= get_ue_golomb(&s->gb);",
          "2253:     if(h->sps.chroma_format_idc)",
          "2254:         h->chroma_log2_weight_denom= get_ue_golomb(&s->gb);",
          "2255:     luma_def = 1<<h->luma_log2_weight_denom;",
          "2256:     chroma_def = 1<<h->chroma_log2_weight_denom;",
          "2258:     for(list=0; list<2; list++){",
          "2261:         for(i=0; i<h->ref_count[list]; i++){",
          "2264:             luma_weight_flag= get_bits1(&s->gb);",
          "2265:             if(luma_weight_flag){",
          "2266:                 h->luma_weight[i][list][0]= get_se_golomb(&s->gb);",
          "2267:                 h->luma_weight[i][list][1]= get_se_golomb(&s->gb);",
          "2268:                 if(   h->luma_weight[i][list][0] != luma_def",
          "2269:                    || h->luma_weight[i][list][1] != 0) {",
          "2270:                     h->use_weight= 1;",
          "2271:                     h->luma_weight_flag[list]= 1;",
          "2273:             }else{",
          "2274:                 h->luma_weight[i][list][0]= luma_def;",
          "2275:                 h->luma_weight[i][list][1]= 0;",
          "2278:             if(h->sps.chroma_format_idc){",
          "2279:                 chroma_weight_flag= get_bits1(&s->gb);",
          "2280:                 if(chroma_weight_flag){",
          "2282:                     for(j=0; j<2; j++){",
          "2283:                         h->chroma_weight[i][list][j][0]= get_se_golomb(&s->gb);",
          "2284:                         h->chroma_weight[i][list][j][1]= get_se_golomb(&s->gb);",
          "2285:                         if(   h->chroma_weight[i][list][j][0] != chroma_def",
          "2286:                            || h->chroma_weight[i][list][j][1] != 0) {",
          "2287:                             h->use_weight_chroma= 1;",
          "2288:                             h->chroma_weight_flag[list]= 1;",
          "2291:                 }else{",
          "2293:                     for(j=0; j<2; j++){",
          "2294:                         h->chroma_weight[i][list][j][0]= chroma_def;",
          "2295:                         h->chroma_weight[i][list][j][1]= 0;",
          "2300:         if(h->slice_type_nos != AV_PICTURE_TYPE_B) break;",
          "2302:     h->use_weight= h->use_weight || h->use_weight_chroma;",
          "",
          "[Added Lines]",
          "2462: static int pred_weight_table(H264Context *h)",
          "2463: {",
          "2464:     MpegEncContext *const s = &h->s;",
          "2468:     h->use_weight             = 0;",
          "2469:     h->use_weight_chroma      = 0;",
          "2470:     h->luma_log2_weight_denom = get_ue_golomb(&s->gb);",
          "2471:     if (h->sps.chroma_format_idc)",
          "2472:         h->chroma_log2_weight_denom = get_ue_golomb(&s->gb);",
          "2473:     luma_def   = 1 << h->luma_log2_weight_denom;",
          "2474:     chroma_def = 1 << h->chroma_log2_weight_denom;",
          "2476:     for (list = 0; list < 2; list++) {",
          "2479:         for (i = 0; i < h->ref_count[list]; i++) {",
          "2482:             luma_weight_flag = get_bits1(&s->gb);",
          "2483:             if (luma_weight_flag) {",
          "2484:                 h->luma_weight[i][list][0] = get_se_golomb(&s->gb);",
          "2485:                 h->luma_weight[i][list][1] = get_se_golomb(&s->gb);",
          "2486:                 if (h->luma_weight[i][list][0] != luma_def ||",
          "2487:                     h->luma_weight[i][list][1] != 0) {",
          "2488:                     h->use_weight             = 1;",
          "2489:                     h->luma_weight_flag[list] = 1;",
          "2491:             } else {",
          "2492:                 h->luma_weight[i][list][0] = luma_def;",
          "2493:                 h->luma_weight[i][list][1] = 0;",
          "2496:             if (h->sps.chroma_format_idc) {",
          "2497:                 chroma_weight_flag = get_bits1(&s->gb);",
          "2498:                 if (chroma_weight_flag) {",
          "2500:                     for (j = 0; j < 2; j++) {",
          "2501:                         h->chroma_weight[i][list][j][0] = get_se_golomb(&s->gb);",
          "2502:                         h->chroma_weight[i][list][j][1] = get_se_golomb(&s->gb);",
          "2503:                         if (h->chroma_weight[i][list][j][0] != chroma_def ||",
          "2504:                             h->chroma_weight[i][list][j][1] != 0) {",
          "2505:                             h->use_weight_chroma = 1;",
          "2506:                             h->chroma_weight_flag[list] = 1;",
          "2509:                 } else {",
          "2511:                     for (j = 0; j < 2; j++) {",
          "2512:                         h->chroma_weight[i][list][j][0] = chroma_def;",
          "2513:                         h->chroma_weight[i][list][j][1] = 0;",
          "2518:         if (h->slice_type_nos != AV_PICTURE_TYPE_B)",
          "2519:             break;",
          "2521:     h->use_weight = h->use_weight || h->use_weight_chroma;",
          "",
          "---------------",
          "--- Hunk 34 ---",
          "[Context before]",
          "2313:     int ref0, ref1, i, cur_poc, ref_start, ref_count0, ref_count1;",
          "2315:     for (i = 0; i < 2; i++) {",
          "",
          "[Removed Lines]",
          "2311: static void implicit_weight_table(H264Context *h, int field){",
          "2312:     MpegEncContext * const s = &h->s;",
          "",
          "[Added Lines]",
          "2530: static void implicit_weight_table(H264Context *h, int field)",
          "2531: {",
          "2532:     MpegEncContext *const s = &h->s;",
          "",
          "---------------",
          "--- Hunk 35 ---",
          "[Context before]",
          "2317:         h->chroma_weight_flag[i] = 0;",
          "2318:     }",
          "2321:         if (s->picture_structure == PICT_FRAME) {",
          "2322:             cur_poc = s->current_picture_ptr->poc;",
          "2323:         } else {",
          "2324:             cur_poc = s->current_picture_ptr->field_poc[s->picture_structure - 1];",
          "2325:         }",
          "2340:     }",
          "2348:         int poc0 = h->ref_list[0][ref0].poc;",
          "2350:             int w = 32;",
          "2351:             if (!h->ref_list[0][ref0].long_ref && !h->ref_list[1][ref1].long_ref) {",
          "2352:                 int poc1 = h->ref_list[1][ref1].poc;",
          "2355:                     int tb = av_clip(cur_poc - poc0, -128, 127);",
          "2356:                     int tx = (16384 + (FFABS(td) >> 1)) / td;",
          "2359:                         w = 64 - dist_scale_factor;",
          "2360:                 }",
          "2361:             }",
          "2367:             }",
          "2368:         }",
          "2369:     }",
          "",
          "[Removed Lines]",
          "2320:     if(field < 0){",
          "2326:     if(   h->ref_count[0] == 1 && h->ref_count[1] == 1 && !FRAME_MBAFF",
          "2327:        && h->ref_list[0][0].poc + h->ref_list[1][0].poc == 2*cur_poc){",
          "2328:         h->use_weight= 0;",
          "2329:         h->use_weight_chroma= 0;",
          "2330:         return;",
          "2331:     }",
          "2332:         ref_start= 0;",
          "2333:         ref_count0= h->ref_count[0];",
          "2334:         ref_count1= h->ref_count[1];",
          "2335:     }else{",
          "2336:         cur_poc = s->current_picture_ptr->field_poc[field];",
          "2337:         ref_start= 16;",
          "2338:         ref_count0= 16+2*h->ref_count[0];",
          "2339:         ref_count1= 16+2*h->ref_count[1];",
          "2342:     h->use_weight= 2;",
          "2343:     h->use_weight_chroma= 2;",
          "2344:     h->luma_log2_weight_denom= 5;",
          "2345:     h->chroma_log2_weight_denom= 5;",
          "2347:     for(ref0=ref_start; ref0 < ref_count0; ref0++){",
          "2349:         for(ref1=ref_start; ref1 < ref_count1; ref1++){",
          "2353:                 int td = av_clip(poc1 - poc0, -128, 127);",
          "2354:                 if(td){",
          "2357:                     int dist_scale_factor = (tb*tx + 32) >> 8;",
          "2358:                     if(dist_scale_factor >= -64 && dist_scale_factor <= 128)",
          "2362:             if(field<0){",
          "2363:                 h->implicit_weight[ref0][ref1][0]=",
          "2364:                 h->implicit_weight[ref0][ref1][1]= w;",
          "2365:             }else{",
          "2366:                 h->implicit_weight[ref0][ref1][field]=w;",
          "",
          "[Added Lines]",
          "2540:     if (field < 0) {",
          "2546:         if (h->ref_count[0] == 1 && h->ref_count[1] == 1 && !FRAME_MBAFF &&",
          "2547:             h->ref_list[0][0].poc + h->ref_list[1][0].poc == 2 * cur_poc) {",
          "2548:             h->use_weight = 0;",
          "2549:             h->use_weight_chroma = 0;",
          "2550:             return;",
          "2551:         }",
          "2552:         ref_start  = 0;",
          "2553:         ref_count0 = h->ref_count[0];",
          "2554:         ref_count1 = h->ref_count[1];",
          "2555:     } else {",
          "2556:         cur_poc    = s->current_picture_ptr->field_poc[field];",
          "2557:         ref_start  = 16;",
          "2558:         ref_count0 = 16 + 2 * h->ref_count[0];",
          "2559:         ref_count1 = 16 + 2 * h->ref_count[1];",
          "2562:     h->use_weight               = 2;",
          "2563:     h->use_weight_chroma        = 2;",
          "2564:     h->luma_log2_weight_denom   = 5;",
          "2565:     h->chroma_log2_weight_denom = 5;",
          "2567:     for (ref0 = ref_start; ref0 < ref_count0; ref0++) {",
          "2569:         for (ref1 = ref_start; ref1 < ref_count1; ref1++) {",
          "2573:                 int td   = av_clip(poc1 - poc0, -128, 127);",
          "2574:                 if (td) {",
          "2577:                     int dist_scale_factor = (tb * tx + 32) >> 8;",
          "2578:                     if (dist_scale_factor >= -64 && dist_scale_factor <= 128)",
          "2582:             if (field < 0) {",
          "2583:                 h->implicit_weight[ref0][ref1][0] =",
          "2584:                 h->implicit_weight[ref0][ref1][1] = w;",
          "2585:             } else {",
          "2586:                 h->implicit_weight[ref0][ref1][field] = w;",
          "",
          "---------------",
          "--- Hunk 36 ---",
          "[Context before]",
          "2376:     ff_h264_remove_all_refs(h);",
          "2381: }",
          "2386:     int i;",
          "2389:             h->delayed_pic[i]->f.reference = 0;",
          "2391:     }",
          "2392:     for (i = 0; i < MAX_DELAYED_PIC_COUNT; i++)",
          "2393:         h->last_pocs[i] = INT_MIN;",
          "2395:     h->prev_interlaced_frame = 1;",
          "2396:     idr(h);",
          "2398:         h->s.current_picture_ptr->f.reference = 0;",
          "2400:     ff_h264_reset_sei(h);",
          "2401:     ff_mpeg_flush(avctx);",
          "2402: }",
          "2407:     int field_poc[2];",
          "2408:     Picture *cur = s->current_picture_ptr;",
          "2412:         h->frame_num_offset += max_frame_num;",
          "2418:             h->poc_msb = h->prev_poc_msb + max_poc_lsb;",
          "2420:             h->poc_msb = h->prev_poc_msb - max_poc_lsb;",
          "2421:         else",
          "2422:             h->poc_msb = h->prev_poc_msb;",
          "2424:         field_poc[0] =",
          "2425:         field_poc[1] = h->poc_msb + h->poc_lsb;",
          "2427:             field_poc[1] += h->delta_poc_bottom;",
          "2429:         int abs_frame_num, expected_delta_per_poc_cycle, expectedpoc;",
          "2430:         int i;",
          "2433:             abs_frame_num = h->frame_num_offset + h->frame_num;",
          "2434:         else",
          "2435:             abs_frame_num = 0;",
          "2438:             abs_frame_num--;",
          "2440:         expected_delta_per_poc_cycle = 0;",
          "2445:             int poc_cycle_cnt          = (abs_frame_num - 1) / h->sps.poc_cycle_length;",
          "2446:             int frame_num_in_poc_cycle = (abs_frame_num - 1) % h->sps.poc_cycle_length;",
          "2448:             expectedpoc = poc_cycle_cnt * expected_delta_per_poc_cycle;",
          "2451:         } else",
          "2452:             expectedpoc = 0;",
          "2455:             expectedpoc = expectedpoc + h->sps.offset_for_non_ref_pic;",
          "2457:         field_poc[0] = expectedpoc + h->delta_poc[0];",
          "2458:         field_poc[1] = field_poc[0] + h->sps.offset_for_top_to_bottom_field;",
          "2461:             field_poc[1] += h->delta_poc[1];",
          "2466:             poc--;",
          "2470:     }",
          "2478:     return 0;",
          "2479: }",
          "2486:     int i;",
          "2489:         h->zigzag_scan[i] = T(zigzag_scan[i]);",
          "2491: #undef T",
          "2492:     }",
          "2495:         h->zigzag_scan8x8[i]       = T(ff_zigzag_direct[i]);",
          "2496:         h->zigzag_scan8x8_cavlc[i] = T(zigzag_scan8x8_cavlc[i]);",
          "2497:         h->field_scan8x8[i]        = T(field_scan8x8[i]);",
          "2498:         h->field_scan8x8_cavlc[i]  = T(field_scan8x8_cavlc[i]);",
          "2499: #undef T",
          "2500:     }",
          "2502:         h->zigzag_scan_q0          = zigzag_scan;",
          "2503:         h->zigzag_scan8x8_q0       = ff_zigzag_direct;",
          "2504:         h->zigzag_scan8x8_cavlc_q0 = zigzag_scan8x8_cavlc;",
          "2505:         h->field_scan_q0           = field_scan;",
          "2506:         h->field_scan8x8_q0        = field_scan8x8;",
          "2507:         h->field_scan8x8_cavlc_q0  = field_scan8x8_cavlc;",
          "2509:         h->zigzag_scan_q0          = h->zigzag_scan;",
          "2510:         h->zigzag_scan8x8_q0       = h->zigzag_scan8x8;",
          "2511:         h->zigzag_scan8x8_cavlc_q0 = h->zigzag_scan8x8_cavlc;",
          "",
          "[Removed Lines]",
          "2375: static void idr(H264Context *h){",
          "2377:     h->prev_frame_num= 0;",
          "2378:     h->prev_frame_num_offset= 0;",
          "2379:     h->prev_poc_msb=",
          "2380:     h->prev_poc_lsb= 0;",
          "2384: static void flush_dpb(AVCodecContext *avctx){",
          "2385:     H264Context *h= avctx->priv_data;",
          "2387:     for(i=0; i<MAX_DELAYED_PIC_COUNT; i++) {",
          "2388:         if(h->delayed_pic[i])",
          "2390:         h->delayed_pic[i]= NULL;",
          "2394:     h->outputed_poc=h->next_outputed_poc= INT_MIN;",
          "2397:     if(h->s.current_picture_ptr)",
          "2399:     h->s.first_field= 0;",
          "2404: static int init_poc(H264Context *h){",
          "2405:     MpegEncContext * const s = &h->s;",
          "2406:     const int max_frame_num= 1<<h->sps.log2_max_frame_num;",
          "2410:     h->frame_num_offset= h->prev_frame_num_offset;",
          "2411:     if(h->frame_num < h->prev_frame_num)",
          "2414:     if(h->sps.poc_type==0){",
          "2415:         const int max_poc_lsb= 1<<h->sps.log2_max_poc_lsb;",
          "2417:         if     (h->poc_lsb < h->prev_poc_lsb && h->prev_poc_lsb - h->poc_lsb >= max_poc_lsb/2)",
          "2419:         else if(h->poc_lsb > h->prev_poc_lsb && h->prev_poc_lsb - h->poc_lsb < -max_poc_lsb/2)",
          "2426:         if(s->picture_structure == PICT_FRAME)",
          "2428:     }else if(h->sps.poc_type==1){",
          "2432:         if(h->sps.poc_cycle_length != 0)",
          "2437:         if(h->nal_ref_idc==0 && abs_frame_num > 0)",
          "2441:         for(i=0; i < h->sps.poc_cycle_length; i++)",
          "2442:             expected_delta_per_poc_cycle += h->sps.offset_for_ref_frame[ i ]; //FIXME integrate during sps parse",
          "2444:         if(abs_frame_num > 0){",
          "2449:             for(i = 0; i <= frame_num_in_poc_cycle; i++)",
          "2450:                 expectedpoc = expectedpoc + h->sps.offset_for_ref_frame[ i ];",
          "2454:         if(h->nal_ref_idc == 0)",
          "2460:         if(s->picture_structure == PICT_FRAME)",
          "2462:     }else{",
          "2463:         int poc= 2*(h->frame_num_offset + h->frame_num);",
          "2465:         if(!h->nal_ref_idc)",
          "2468:         field_poc[0]= poc;",
          "2469:         field_poc[1]= poc;",
          "2472:     if(s->picture_structure != PICT_BOTTOM_FIELD)",
          "2473:         s->current_picture_ptr->field_poc[0]= field_poc[0];",
          "2474:     if(s->picture_structure != PICT_TOP_FIELD)",
          "2475:         s->current_picture_ptr->field_poc[1]= field_poc[1];",
          "2476:     cur->poc= FFMIN(cur->field_poc[0], cur->field_poc[1]);",
          "2485: static void init_scan_tables(H264Context *h){",
          "2487:     for(i=0; i<16; i++){",
          "2488: #define T(x) (x>>2) | ((x<<2) & 0xF)",
          "2490:         h-> field_scan[i] = T( field_scan[i]);",
          "2493:     for(i=0; i<64; i++){",
          "2494: #define T(x) (x>>3) | ((x&7)<<3)",
          "2501:     if(h->sps.transform_bypass){ //FIXME same ugly",
          "2508:     }else{",
          "",
          "[Added Lines]",
          "2595: static void idr(H264Context *h)",
          "2596: {",
          "2598:     h->prev_frame_num        = 0;",
          "2599:     h->prev_frame_num_offset = 0;",
          "2600:     h->prev_poc_msb          =",
          "2601:     h->prev_poc_lsb          = 0;",
          "2605: static void flush_dpb(AVCodecContext *avctx)",
          "2606: {",
          "2607:     H264Context *h = avctx->priv_data;",
          "2609:     for (i = 0; i < MAX_DELAYED_PIC_COUNT; i++) {",
          "2610:         if (h->delayed_pic[i])",
          "2612:         h->delayed_pic[i] = NULL;",
          "2616:     h->outputed_poc = h->next_outputed_poc = INT_MIN;",
          "2619:     if (h->s.current_picture_ptr)",
          "2621:     h->s.first_field = 0;",
          "2626: static int init_poc(H264Context *h)",
          "2627: {",
          "2628:     MpegEncContext *const s = &h->s;",
          "2629:     const int max_frame_num = 1 << h->sps.log2_max_frame_num;",
          "2633:     h->frame_num_offset = h->prev_frame_num_offset;",
          "2634:     if (h->frame_num < h->prev_frame_num)",
          "2637:     if (h->sps.poc_type == 0) {",
          "2638:         const int max_poc_lsb = 1 << h->sps.log2_max_poc_lsb;",
          "2640:         if (h->poc_lsb < h->prev_poc_lsb && h->prev_poc_lsb - h->poc_lsb >= max_poc_lsb / 2)",
          "2642:         else if (h->poc_lsb > h->prev_poc_lsb && h->prev_poc_lsb - h->poc_lsb < -max_poc_lsb / 2)",
          "2649:         if (s->picture_structure == PICT_FRAME)",
          "2651:     } else if (h->sps.poc_type == 1) {",
          "2655:         if (h->sps.poc_cycle_length != 0)",
          "2660:         if (h->nal_ref_idc == 0 && abs_frame_num > 0)",
          "2664:         for (i = 0; i < h->sps.poc_cycle_length; i++)",
          "2666:             expected_delta_per_poc_cycle += h->sps.offset_for_ref_frame[i];",
          "2668:         if (abs_frame_num > 0) {",
          "2673:             for (i = 0; i <= frame_num_in_poc_cycle; i++)",
          "2674:                 expectedpoc = expectedpoc + h->sps.offset_for_ref_frame[i];",
          "2678:         if (h->nal_ref_idc == 0)",
          "2684:         if (s->picture_structure == PICT_FRAME)",
          "2686:     } else {",
          "2687:         int poc = 2 * (h->frame_num_offset + h->frame_num);",
          "2689:         if (!h->nal_ref_idc)",
          "2692:         field_poc[0] = poc;",
          "2693:         field_poc[1] = poc;",
          "2696:     if (s->picture_structure != PICT_BOTTOM_FIELD)",
          "2697:         s->current_picture_ptr->field_poc[0] = field_poc[0];",
          "2698:     if (s->picture_structure != PICT_TOP_FIELD)",
          "2699:         s->current_picture_ptr->field_poc[1] = field_poc[1];",
          "2700:     cur->poc = FFMIN(cur->field_poc[0], cur->field_poc[1]);",
          "2708: static void init_scan_tables(H264Context *h)",
          "2709: {",
          "2711:     for (i = 0; i < 16; i++) {",
          "2712: #define T(x) (x >> 2) | ((x << 2) & 0xF)",
          "2714:         h->field_scan[i]  = T(field_scan[i]);",
          "2717:     for (i = 0; i < 64; i++) {",
          "2718: #define T(x) (x >> 3) | ((x & 7) << 3)",
          "2725:     if (h->sps.transform_bypass) { // FIXME same ugly",
          "2732:     } else {",
          "",
          "---------------",
          "--- Hunk 37 ---",
          "[Context before]",
          "2515:     }",
          "2516: }",
          "2521:     int err = 0;",
          "2524:     if (!in_setup && !s->dropable)",
          "2525:         ff_thread_report_progress(&s->current_picture_ptr->f,",
          "2526:                                   (16 * s->mb_height >> FIELD_PICTURE) - 1,",
          "2527:                                   s->picture_structure == PICT_BOTTOM_FIELD);",
          "2530:         ff_vdpau_h264_set_reference_frames(s);",
          "2534:             err = ff_h264_execute_ref_pic_marking(h, h->mmco, h->mmco_index);",
          "2537:         }",
          "2541:     }",
          "2543:     if (avctx->hwaccel) {",
          "2544:         if (avctx->hwaccel->end_frame(avctx) < 0)",
          "2546:     }",
          "2549:         ff_vdpau_h264_picture_complete(s);",
          "",
          "[Removed Lines]",
          "2518: static int field_end(H264Context *h, int in_setup){",
          "2519:     MpegEncContext * const s = &h->s;",
          "2520:     AVCodecContext * const avctx= s->avctx;",
          "2522:     s->mb_y= 0;",
          "2529:     if (CONFIG_H264_VDPAU_DECODER && s->avctx->codec->capabilities&CODEC_CAP_HWACCEL_VDPAU)",
          "2532:     if(in_setup || !(avctx->active_thread_type&FF_THREAD_FRAME)){",
          "2533:         if(!s->dropable) {",
          "2535:             h->prev_poc_msb= h->poc_msb;",
          "2536:             h->prev_poc_lsb= h->poc_lsb;",
          "2538:         h->prev_frame_num_offset= h->frame_num_offset;",
          "2539:         h->prev_frame_num= h->frame_num;",
          "2540:         h->outputed_poc = h->next_outputed_poc;",
          "2545:             av_log(avctx, AV_LOG_ERROR, \"hardware accelerator failed to decode picture\\n\");",
          "2548:     if (CONFIG_H264_VDPAU_DECODER && s->avctx->codec->capabilities&CODEC_CAP_HWACCEL_VDPAU)",
          "",
          "[Added Lines]",
          "2742: static int field_end(H264Context *h, int in_setup)",
          "2743: {",
          "2744:     MpegEncContext *const s     = &h->s;",
          "2745:     AVCodecContext *const avctx = s->avctx;",
          "2747:     s->mb_y = 0;",
          "2754:     if (CONFIG_H264_VDPAU_DECODER &&",
          "2755:         s->avctx->codec->capabilities & CODEC_CAP_HWACCEL_VDPAU)",
          "2758:     if (in_setup || !(avctx->active_thread_type & FF_THREAD_FRAME)) {",
          "2759:         if (!s->dropable) {",
          "2761:             h->prev_poc_msb = h->poc_msb;",
          "2762:             h->prev_poc_lsb = h->poc_lsb;",
          "2764:         h->prev_frame_num_offset = h->frame_num_offset;",
          "2765:         h->prev_frame_num        = h->frame_num;",
          "2766:         h->outputed_poc          = h->next_outputed_poc;",
          "2771:             av_log(avctx, AV_LOG_ERROR,",
          "2772:                    \"hardware accelerator failed to decode picture\\n\");",
          "2775:     if (CONFIG_H264_VDPAU_DECODER &&",
          "2776:         s->avctx->codec->capabilities & CODEC_CAP_HWACCEL_VDPAU)",
          "",
          "---------------",
          "--- Hunk 38 ---",
          "[Context before]",
          "2566:     ff_MPV_frame_end(s);",
          "2570:     return err;",
          "2571: }",
          "",
          "[Removed Lines]",
          "2568:     h->current_slice=0;",
          "",
          "[Added Lines]",
          "2796:     h->current_slice = 0;",
          "",
          "---------------",
          "--- Hunk 39 ---",
          "[Context before]",
          "2576: static void clone_slice(H264Context *dst, H264Context *src)",
          "2577: {",
          "2591:     memcpy(dst->short_ref,        src->short_ref,        sizeof(dst->short_ref));",
          "2592:     memcpy(dst->long_ref,         src->long_ref,         sizeof(dst->long_ref));",
          "",
          "[Removed Lines]",
          "2578:     memcpy(dst->block_offset,     src->block_offset, sizeof(dst->block_offset));",
          "2579:     dst->s.current_picture_ptr  = src->s.current_picture_ptr;",
          "2580:     dst->s.current_picture      = src->s.current_picture;",
          "2581:     dst->s.linesize             = src->s.linesize;",
          "2582:     dst->s.uvlinesize           = src->s.uvlinesize;",
          "2583:     dst->s.first_field          = src->s.first_field;",
          "2585:     dst->prev_poc_msb           = src->prev_poc_msb;",
          "2586:     dst->prev_poc_lsb           = src->prev_poc_lsb;",
          "2587:     dst->prev_frame_num_offset  = src->prev_frame_num_offset;",
          "2588:     dst->prev_frame_num         = src->prev_frame_num;",
          "2589:     dst->short_ref_count        = src->short_ref_count;",
          "",
          "[Added Lines]",
          "2806:     memcpy(dst->block_offset, src->block_offset, sizeof(dst->block_offset));",
          "2807:     dst->s.current_picture_ptr = src->s.current_picture_ptr;",
          "2808:     dst->s.current_picture     = src->s.current_picture;",
          "2809:     dst->s.linesize            = src->s.linesize;",
          "2810:     dst->s.uvlinesize          = src->s.uvlinesize;",
          "2811:     dst->s.first_field         = src->s.first_field;",
          "2813:     dst->prev_poc_msb          = src->prev_poc_msb;",
          "2814:     dst->prev_poc_lsb          = src->prev_poc_lsb;",
          "2815:     dst->prev_frame_num_offset = src->prev_frame_num_offset;",
          "2816:     dst->prev_frame_num        = src->prev_frame_num;",
          "2817:     dst->short_ref_count       = src->short_ref_count;",
          "",
          "---------------",
          "--- Hunk 40 ---",
          "[Context before]",
          "2608: {",
          "2609:     int profile = sps->profile_idc;",
          "2612:     case FF_PROFILE_H264_BASELINE:",
          "2615:         break;",
          "2616:     case FF_PROFILE_H264_HIGH_10:",
          "2617:     case FF_PROFILE_H264_HIGH_422:",
          "2618:     case FF_PROFILE_H264_HIGH_444_PREDICTIVE:",
          "2621:         break;",
          "2622:     }",
          "",
          "[Removed Lines]",
          "2611:     switch(sps->profile_idc) {",
          "2614:         profile |= (sps->constraint_set_flags & 1<<1) ? FF_PROFILE_H264_CONSTRAINED : 0;",
          "2620:         profile |= (sps->constraint_set_flags & 1<<3) ? FF_PROFILE_H264_INTRA : 0;",
          "",
          "[Added Lines]",
          "2839:     switch (sps->profile_idc) {",
          "2842:         profile |= (sps->constraint_set_flags & 1 << 1) ? FF_PROFILE_H264_CONSTRAINED : 0;",
          "2848:         profile |= (sps->constraint_set_flags & 1 << 3) ? FF_PROFILE_H264_INTRA : 0;",
          "",
          "---------------",
          "--- Hunk 41 ---",
          "[Context before]",
          "2639:     unsigned int first_mb_in_slice;",
          "2640:     unsigned int pps_id;",
          "2641:     int num_ref_idx_active_override_flag;",
          "",
          "[Removed Lines]",
          "2636: static int decode_slice_header(H264Context *h, H264Context *h0){",
          "2637:     MpegEncContext * const s = &h->s;",
          "2638:     MpegEncContext * const s0 = &h0->s;",
          "",
          "[Added Lines]",
          "2865: static int decode_slice_header(H264Context *h, H264Context *h0)",
          "2866: {",
          "2867:     MpegEncContext *const s  = &h->s;",
          "2868:     MpegEncContext *const s0 = &h0->s;",
          "",
          "---------------",
          "--- Hunk 42 ---",
          "[Context before]",
          "2643:     int default_ref_list_done = 0;",
          "2644:     int last_pic_structure;",
          "2655:     }",
          "2661:             field_end(h, 1);",
          "2662:         }",
          "2664:         h0->current_slice = 0;",
          "2665:         if (!s0->first_field)",
          "2667:     }",
          "2672:         return -1;",
          "2673:     }",
          "2675:         slice_type -= 5;",
          "2683:         default_ref_list_done = 1;",
          "2684:     }",
          "2692:         av_log(h->s.avctx, AV_LOG_ERROR, \"pps_id out of range\\n\");",
          "2693:         return -1;",
          "2694:     }",
          "2697:         return -1;",
          "2698:     }",
          "2703:         return -1;",
          "2704:     }",
          "2705:     h->sps = *h0->sps_buffers[h->pps.sps_id];",
          "",
          "[Removed Lines]",
          "2646:     s->dropable= h->nal_ref_idc == 0;",
          "2649:     if((s->avctx->flags2 & CODEC_FLAG2_FAST) && !h->nal_ref_idc && !h->pixel_shift){",
          "2650:         s->me.qpel_put= s->dsp.put_2tap_qpel_pixels_tab;",
          "2651:         s->me.qpel_avg= s->dsp.avg_2tap_qpel_pixels_tab;",
          "2652:     }else{",
          "2653:         s->me.qpel_put= s->dsp.put_h264_qpel_pixels_tab;",
          "2654:         s->me.qpel_avg= s->dsp.avg_h264_qpel_pixels_tab;",
          "2657:     first_mb_in_slice= get_ue_golomb(&s->gb);",
          "2659:     if(first_mb_in_slice == 0){ //FIXME better field boundary detection",
          "2660:         if(h0->current_slice && FIELD_PICTURE){",
          "2666:             s->current_picture_ptr= NULL;",
          "2669:     slice_type= get_ue_golomb_31(&s->gb);",
          "2670:     if(slice_type > 9){",
          "2671:         av_log(h->s.avctx, AV_LOG_ERROR, \"slice type too large (%d) at %d %d\\n\", h->slice_type, s->mb_x, s->mb_y);",
          "2674:     if(slice_type > 4){",
          "2676:         h->slice_type_fixed=1;",
          "2677:     }else",
          "2678:         h->slice_type_fixed=0;",
          "2680:     slice_type= golomb_to_pict_type[ slice_type ];",
          "2681:     if (slice_type == AV_PICTURE_TYPE_I",
          "2682:         || (h0->current_slice != 0 && slice_type == h0->last_slice_type) ) {",
          "2685:     h->slice_type= slice_type;",
          "2686:     h->slice_type_nos= slice_type & 3;",
          "2688:     s->pict_type= h->slice_type; // to make a few old functions happy, it's wrong though",
          "2690:     pps_id= get_ue_golomb(&s->gb);",
          "2691:     if(pps_id>=MAX_PPS_COUNT){",
          "2695:     if(!h0->pps_buffers[pps_id]) {",
          "2696:         av_log(h->s.avctx, AV_LOG_ERROR, \"non-existing PPS %u referenced\\n\", pps_id);",
          "2699:     h->pps= *h0->pps_buffers[pps_id];",
          "2701:     if(!h0->sps_buffers[h->pps.sps_id]) {",
          "2702:         av_log(h->s.avctx, AV_LOG_ERROR, \"non-existing SPS %u referenced\\n\", h->pps.sps_id);",
          "",
          "[Added Lines]",
          "2876:     s->dropable = h->nal_ref_idc == 0;",
          "2879:     if ((s->avctx->flags2 & CODEC_FLAG2_FAST) &&",
          "2880:         !h->nal_ref_idc && !h->pixel_shift) {",
          "2881:         s->me.qpel_put = s->dsp.put_2tap_qpel_pixels_tab;",
          "2882:         s->me.qpel_avg = s->dsp.avg_2tap_qpel_pixels_tab;",
          "2883:     } else {",
          "2884:         s->me.qpel_put = s->dsp.put_h264_qpel_pixels_tab;",
          "2885:         s->me.qpel_avg = s->dsp.avg_h264_qpel_pixels_tab;",
          "2888:     first_mb_in_slice = get_ue_golomb(&s->gb);",
          "2890:     if (first_mb_in_slice == 0) { // FIXME better field boundary detection",
          "2891:         if (h0->current_slice && FIELD_PICTURE) {",
          "2897:             s->current_picture_ptr = NULL;",
          "2900:     slice_type = get_ue_golomb_31(&s->gb);",
          "2901:     if (slice_type > 9) {",
          "2902:         av_log(h->s.avctx, AV_LOG_ERROR,",
          "2903:                \"slice type too large (%d) at %d %d\\n\",",
          "2904:                h->slice_type, s->mb_x, s->mb_y);",
          "2907:     if (slice_type > 4) {",
          "2909:         h->slice_type_fixed = 1;",
          "2910:     } else",
          "2911:         h->slice_type_fixed = 0;",
          "2913:     slice_type = golomb_to_pict_type[slice_type];",
          "2914:     if (slice_type == AV_PICTURE_TYPE_I ||",
          "2915:         (h0->current_slice != 0 && slice_type == h0->last_slice_type)) {",
          "2918:     h->slice_type     = slice_type;",
          "2919:     h->slice_type_nos = slice_type & 3;",
          "2922:     s->pict_type = h->slice_type;",
          "2924:     pps_id = get_ue_golomb(&s->gb);",
          "2925:     if (pps_id >= MAX_PPS_COUNT) {",
          "2929:     if (!h0->pps_buffers[pps_id]) {",
          "2930:         av_log(h->s.avctx, AV_LOG_ERROR,",
          "2931:                \"non-existing PPS %u referenced\\n\",",
          "2932:                pps_id);",
          "2935:     h->pps = *h0->pps_buffers[pps_id];",
          "2937:     if (!h0->sps_buffers[h->pps.sps_id]) {",
          "2938:         av_log(h->s.avctx, AV_LOG_ERROR,",
          "2939:                \"non-existing SPS %u referenced\\n\",",
          "2940:                h->pps.sps_id);",
          "",
          "---------------",
          "--- Hunk 43 ---",
          "[Context before]",
          "2708:     s->avctx->level   = h->sps.level_idc;",
          "2709:     s->avctx->refs    = h->sps.ref_frame_count;",
          "2716:     s->chroma_y_shift = h->sps.chroma_format_idc <= 1; // 400 uses yuv420p",
          "2721:     else",
          "2729:             return -1;   // width / height changed during parallelized decoding",
          "2730:         }",
          "2731:         free_tables(h, 0);",
          "",
          "[Removed Lines]",
          "2711:     s->mb_width= h->sps.mb_width;",
          "2712:     s->mb_height= h->sps.mb_height * (2 - h->sps.frame_mbs_only_flag);",
          "2714:     h->b_stride=  s->mb_width*4;",
          "2718:     s->width = 16*s->mb_width - (2>>CHROMA444)*FFMIN(h->sps.crop_right, (8<<CHROMA444)-1);",
          "2719:     if(h->sps.frame_mbs_only_flag)",
          "2720:         s->height= 16*s->mb_height - (1<<s->chroma_y_shift)*FFMIN(h->sps.crop_bottom, (16>>s->chroma_y_shift)-1);",
          "2722:         s->height= 16*s->mb_height - (2<<s->chroma_y_shift)*FFMIN(h->sps.crop_bottom, (16>>s->chroma_y_shift)-1);",
          "2724:     if (s->context_initialized",
          "2725:         && (   s->width != s->avctx->width || s->height != s->avctx->height",
          "2726:             || av_cmp_q(h->sps.sar, s->avctx->sample_aspect_ratio))) {",
          "2727:         if(h != h0) {",
          "2728:             av_log_missing_feature(s->avctx, \"Width/height changing with threads is\", 0);",
          "",
          "[Added Lines]",
          "2949:     s->mb_width  = h->sps.mb_width;",
          "2950:     s->mb_height = h->sps.mb_height * (2 - h->sps.frame_mbs_only_flag);",
          "2952:     h->b_stride = s->mb_width * 4;",
          "2956:     s->width = 16 * s->mb_width - (2 >> CHROMA444) * FFMIN(h->sps.crop_right, (8 << CHROMA444) - 1);",
          "2957:     if (h->sps.frame_mbs_only_flag)",
          "2958:         s->height = 16 * s->mb_height - (1 << s->chroma_y_shift) * FFMIN(h->sps.crop_bottom, (16 >> s->chroma_y_shift) - 1);",
          "2960:         s->height = 16 * s->mb_height - (2 << s->chroma_y_shift) * FFMIN(h->sps.crop_bottom, (16 >> s->chroma_y_shift) - 1);",
          "2962:     if (s->context_initialized &&",
          "2963:         (s->width != s->avctx->width || s->height != s->avctx->height ||",
          "2964:          av_cmp_q(h->sps.sar, s->avctx->sample_aspect_ratio))) {",
          "2965:         if (h != h0) {",
          "2966:             av_log_missing_feature(s->avctx,",
          "2967:                                    \"Width/height changing with threads is\", 0);",
          "",
          "---------------",
          "--- Hunk 44 ---",
          "[Context before]",
          "2734:     }",
          "2735:     if (!s->context_initialized) {",
          "2736:         if (h != h0) {",
          "2738:             return -1;",
          "2739:         }",
          "2741:         avcodec_set_dimensions(s->avctx, s->width, s->height);",
          "2743:         av_assert0(s->avctx->sample_aspect_ratio.den);",
          "2748:                 s->avctx->color_primaries = h->sps.color_primaries;",
          "2749:                 s->avctx->color_trc       = h->sps.color_trc;",
          "2750:                 s->avctx->colorspace      = h->sps.colorspace;",
          "2751:             }",
          "2752:         }",
          "2757:                 den *= 2;",
          "2758:             av_reduce(&s->avctx->time_base.num, &s->avctx->time_base.den,",
          "2760:         }",
          "2762:         switch (h->sps.bit_depth_luma) {",
          "2806:         }",
          "2810:         if (ff_MPV_common_init(s) < 0) {",
          "2811:             av_log(h->s.avctx, AV_LOG_ERROR, \"ff_MPV_common_init() failed.\\n\");",
          "",
          "[Removed Lines]",
          "2737:             av_log(h->s.avctx, AV_LOG_ERROR, \"Cannot (re-)initialize context during parallel decoding.\\n\");",
          "2742:         s->avctx->sample_aspect_ratio= h->sps.sar;",
          "2745:         if(h->sps.video_signal_type_present_flag){",
          "2746:             s->avctx->color_range = h->sps.full_range ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG;",
          "2747:             if(h->sps.colour_description_present_flag){",
          "2754:         if(h->sps.timing_info_present_flag){",
          "2755:             int64_t den= h->sps.time_scale;",
          "2756:             if(h->x264_build < 44U)",
          "2759:                       h->sps.num_units_in_tick, den, 1<<30);",
          "2763:             case 9 :",
          "2764:                 if (CHROMA444) {",
          "2765:                     if (s->avctx->colorspace == AVCOL_SPC_RGB) {",
          "2766:                         s->avctx->pix_fmt = PIX_FMT_GBRP9;",
          "2767:                     } else",
          "2768:                         s->avctx->pix_fmt = PIX_FMT_YUV444P9;",
          "2769:                 } else if (CHROMA422)",
          "2770:                     s->avctx->pix_fmt = PIX_FMT_YUV422P9;",
          "2771:                 else",
          "2772:                     s->avctx->pix_fmt = PIX_FMT_YUV420P9;",
          "2773:                 break;",
          "2774:             case 10 :",
          "2775:                 if (CHROMA444) {",
          "2776:                     if (s->avctx->colorspace == AVCOL_SPC_RGB) {",
          "2777:                         s->avctx->pix_fmt = PIX_FMT_GBRP10;",
          "2778:                     } else",
          "2779:                         s->avctx->pix_fmt = PIX_FMT_YUV444P10;",
          "2780:                 } else if (CHROMA422)",
          "2781:                     s->avctx->pix_fmt = PIX_FMT_YUV422P10;",
          "2782:                 else",
          "2783:                     s->avctx->pix_fmt = PIX_FMT_YUV420P10;",
          "2784:                 break;",
          "2785:             case 8:",
          "2786:                 if (CHROMA444){",
          "2787:                     if (s->avctx->colorspace == AVCOL_SPC_RGB) {",
          "2788:                         s->avctx->pix_fmt = PIX_FMT_GBRP;",
          "2789:                     } else",
          "2790:                         s->avctx->pix_fmt = s->avctx->color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ444P : PIX_FMT_YUV444P;",
          "2791:                 } else if (CHROMA422) {",
          "2792:                     s->avctx->pix_fmt = s->avctx->color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ422P : PIX_FMT_YUV422P;",
          "2793:                 }else{",
          "2794:                     s->avctx->pix_fmt = s->avctx->get_format(s->avctx,",
          "2795:                                                              s->avctx->codec->pix_fmts ?",
          "2796:                                                              s->avctx->codec->pix_fmts :",
          "2797:                                                              s->avctx->color_range == AVCOL_RANGE_JPEG ?",
          "2798:                                                              hwaccel_pixfmt_list_h264_jpeg_420 :",
          "2799:                                                              ff_hwaccel_pixfmt_list_420);",
          "2800:                 }",
          "2801:                 break;",
          "2802:             default:",
          "2803:                 av_log(s->avctx, AV_LOG_ERROR,",
          "2804:                        \"Unsupported bit depth: %d\\n\", h->sps.bit_depth_luma);",
          "2805:                 return AVERROR_INVALIDDATA;",
          "2808:         s->avctx->hwaccel = ff_find_hwaccel(s->avctx->codec->id, s->avctx->pix_fmt);",
          "",
          "[Added Lines]",
          "2976:             av_log(h->s.avctx, AV_LOG_ERROR,",
          "2977:                    \"Cannot (re-)initialize context during parallel decoding.\\n\");",
          "2982:         s->avctx->sample_aspect_ratio = h->sps.sar;",
          "2985:         if (h->sps.video_signal_type_present_flag) {",
          "2986:             s->avctx->color_range = h->sps.full_range ? AVCOL_RANGE_JPEG",
          "2987:                                                       : AVCOL_RANGE_MPEG;",
          "2988:             if (h->sps.colour_description_present_flag) {",
          "2995:         if (h->sps.timing_info_present_flag) {",
          "2996:             int64_t den = h->sps.time_scale;",
          "2997:             if (h->x264_build < 44U)",
          "3000:                       h->sps.num_units_in_tick, den, 1 << 30);",
          "3004:         case 9:",
          "3005:             if (CHROMA444) {",
          "3006:                 if (s->avctx->colorspace == AVCOL_SPC_RGB) {",
          "3007:                     s->avctx->pix_fmt = PIX_FMT_GBRP9;",
          "3008:                 } else",
          "3009:                     s->avctx->pix_fmt = PIX_FMT_YUV444P9;",
          "3010:             } else if (CHROMA422)",
          "3011:                 s->avctx->pix_fmt = PIX_FMT_YUV422P9;",
          "3012:             else",
          "3013:                 s->avctx->pix_fmt = PIX_FMT_YUV420P9;",
          "3014:             break;",
          "3015:         case 10:",
          "3016:             if (CHROMA444) {",
          "3017:                 if (s->avctx->colorspace == AVCOL_SPC_RGB) {",
          "3018:                     s->avctx->pix_fmt = PIX_FMT_GBRP10;",
          "3019:                 } else",
          "3020:                     s->avctx->pix_fmt = PIX_FMT_YUV444P10;",
          "3021:             } else if (CHROMA422)",
          "3022:                 s->avctx->pix_fmt = PIX_FMT_YUV422P10;",
          "3023:             else",
          "3024:                 s->avctx->pix_fmt = PIX_FMT_YUV420P10;",
          "3025:             break;",
          "3026:         case 8:",
          "3027:             if (CHROMA444) {",
          "3028:                 if (s->avctx->colorspace == AVCOL_SPC_RGB) {",
          "3029:                     s->avctx->pix_fmt = PIX_FMT_GBRP;",
          "3030:                 } else",
          "3031:                     s->avctx->pix_fmt = s->avctx->color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ444P",
          "3032:                                                                                   : PIX_FMT_YUV444P;",
          "3033:             } else if (CHROMA422) {",
          "3034:                 s->avctx->pix_fmt = s->avctx->color_range == AVCOL_RANGE_JPEG ? PIX_FMT_YUVJ422P",
          "3035:                                                                               : PIX_FMT_YUV422P;",
          "3036:             } else {",
          "3037:                 s->avctx->pix_fmt = s->avctx->get_format(s->avctx,",
          "3038:                                                          s->avctx->codec->pix_fmts ?",
          "3039:                                                          s->avctx->codec->pix_fmts :",
          "3040:                                                          s->avctx->color_range == AVCOL_RANGE_JPEG ?",
          "3041:                                                          hwaccel_pixfmt_list_h264_jpeg_420 :",
          "3042:                                                          ff_hwaccel_pixfmt_list_420);",
          "3043:             }",
          "3044:             break;",
          "3045:         default:",
          "3046:             av_log(s->avctx, AV_LOG_ERROR,",
          "3047:                    \"Unsupported bit depth: %d\\n\", h->sps.bit_depth_luma);",
          "3048:             return AVERROR_INVALIDDATA;",
          "3051:         s->avctx->hwaccel = ff_find_hwaccel(s->avctx->codec->id,",
          "3052:                                             s->avctx->pix_fmt);",
          "",
          "---------------",
          "--- Hunk 45 ---",
          "[Context before]",
          "2817:         init_scan_tables(h);",
          "2818:         if (ff_h264_alloc_tables(h) < 0) {",
          "2820:             return AVERROR(ENOMEM);",
          "2821:         }",
          "2824:             if (context_init(h) < 0) {",
          "2825:                 av_log(h->s.avctx, AV_LOG_ERROR, \"context_init() failed.\\n\");",
          "2826:                 return -1;",
          "2827:             }",
          "2828:         } else {",
          "2830:                 H264Context *c;",
          "2831:                 c = h->thread_context[i] = av_malloc(sizeof(H264Context));",
          "2832:                 memcpy(c, h->s.thread_context[i], sizeof(MpegEncContext));",
          "2833:                 memset(&c->s + 1, 0, sizeof(H264Context) - sizeof(MpegEncContext));",
          "2837:                 c->pixel_shift = h->pixel_shift;",
          "2838:                 init_scan_tables(c);",
          "2839:                 clone_tables(c, h, i);",
          "2840:             }",
          "2843:                 if (context_init(h->thread_context[i]) < 0) {",
          "2845:                     return -1;",
          "2846:                 }",
          "2847:         }",
          "2848:     }",
          "2851:         h->dequant_coeff_pps = pps_id;",
          "2852:         init_dequant_tables(h);",
          "2853:     }",
          "2859:     last_pic_structure = s0->picture_structure;",
          "2865:         } else {",
          "2868:         }",
          "2869:     }",
          "2879:             if ((h->frame_num - unwrap_prev_frame_num) > h->sps.ref_frame_count) {",
          "2880:                 unwrap_prev_frame_num = (h->frame_num - h->sps.ref_frame_count) - 1;",
          "",
          "[Removed Lines]",
          "2819:             av_log(h->s.avctx, AV_LOG_ERROR, \"Could not allocate memory for h264\\n\");",
          "2823:         if (!HAVE_THREADS || !(s->avctx->active_thread_type&FF_THREAD_SLICE)) {",
          "2829:             for(i = 1; i < s->slice_context_count; i++) {",
          "2834:                 c->h264dsp = h->h264dsp;",
          "2835:                 c->sps = h->sps;",
          "2836:                 c->pps = h->pps;",
          "2842:             for(i = 0; i < s->slice_context_count; i++)",
          "2844:                     av_log(h->s.avctx, AV_LOG_ERROR, \"context_init() failed.\\n\");",
          "2850:     if(h == h0 && h->dequant_coeff_pps != pps_id){",
          "2855:     h->frame_num= get_bits(&s->gb, h->sps.log2_max_frame_num);",
          "2857:     h->mb_mbaff = 0;",
          "2858:     h->mb_aff_frame = 0;",
          "2860:     if(h->sps.frame_mbs_only_flag){",
          "2861:         s->picture_structure= PICT_FRAME;",
          "2862:     }else{",
          "2863:         if(get_bits1(&s->gb)) { //field_pic_flag",
          "2864:             s->picture_structure= PICT_TOP_FIELD + get_bits1(&s->gb); //bottom_field_flag",
          "2866:             s->picture_structure= PICT_FRAME;",
          "2867:             h->mb_aff_frame = h->sps.mb_aff;",
          "2870:     h->mb_field_decoding_flag= s->picture_structure != PICT_FRAME;",
          "2872:     if(h0->current_slice == 0){",
          "2874:         if(h->frame_num != h->prev_frame_num) {",
          "2875:             int unwrap_prev_frame_num = h->prev_frame_num, max_frame_num = 1<<h->sps.log2_max_frame_num;",
          "2877:             if (unwrap_prev_frame_num > h->frame_num) unwrap_prev_frame_num -= max_frame_num;",
          "",
          "[Added Lines]",
          "3063:             av_log(h->s.avctx, AV_LOG_ERROR,",
          "3064:                    \"Could not allocate memory for h264\\n\");",
          "3068:         if (!HAVE_THREADS || !(s->avctx->active_thread_type & FF_THREAD_SLICE)) {",
          "3074:             for (i = 1; i < s->slice_context_count; i++) {",
          "3079:                 c->h264dsp     = h->h264dsp;",
          "3080:                 c->sps         = h->sps;",
          "3081:                 c->pps         = h->pps;",
          "3087:             for (i = 0; i < s->slice_context_count; i++)",
          "3089:                     av_log(h->s.avctx, AV_LOG_ERROR,",
          "3090:                            \"context_init() failed.\\n\");",
          "3096:     if (h == h0 && h->dequant_coeff_pps != pps_id) {",
          "3101:     h->frame_num = get_bits(&s->gb, h->sps.log2_max_frame_num);",
          "3103:     h->mb_mbaff        = 0;",
          "3104:     h->mb_aff_frame    = 0;",
          "3106:     if (h->sps.frame_mbs_only_flag) {",
          "3107:         s->picture_structure = PICT_FRAME;",
          "3108:     } else {",
          "3109:         if (get_bits1(&s->gb)) { // field_pic_flag",
          "3110:             s->picture_structure = PICT_TOP_FIELD + get_bits1(&s->gb); // bottom_field_flag",
          "3112:             s->picture_structure = PICT_FRAME;",
          "3113:             h->mb_aff_frame      = h->sps.mb_aff;",
          "3116:     h->mb_field_decoding_flag = s->picture_structure != PICT_FRAME;",
          "3118:     if (h0->current_slice == 0) {",
          "3121:         if (h->frame_num != h->prev_frame_num) {",
          "3122:             int unwrap_prev_frame_num = h->prev_frame_num;",
          "3123:             int max_frame_num         = 1 << h->sps.log2_max_frame_num;",
          "3125:             if (unwrap_prev_frame_num > h->frame_num)",
          "3126:                 unwrap_prev_frame_num -= max_frame_num;",
          "",
          "---------------",
          "--- Hunk 46 ---",
          "[Context before]",
          "2885:             }",
          "2886:         }",
          "2890:             Picture *prev = h->short_ref_count ? h->short_ref[0] : NULL;",
          "2892:             if (ff_h264_frame_start(h) < 0)",
          "2893:                 return -1;",
          "2894:             h->prev_frame_num++;",
          "2897:             ff_thread_report_progress(&s->current_picture_ptr->f, INT_MAX, 0);",
          "2898:             ff_thread_report_progress(&s->current_picture_ptr->f, INT_MAX, 1);",
          "2899:             ff_generate_sliding_window_mmcos(h);",
          "",
          "[Removed Lines]",
          "2888:         while(h->frame_num !=  h->prev_frame_num &&",
          "2889:               h->frame_num != (h->prev_frame_num+1)%(1<<h->sps.log2_max_frame_num)){",
          "2891:             av_log(h->s.avctx, AV_LOG_DEBUG, \"Frame num gap %d %d\\n\", h->frame_num, h->prev_frame_num);",
          "2895:             h->prev_frame_num %= 1<<h->sps.log2_max_frame_num;",
          "2896:             s->current_picture_ptr->frame_num= h->prev_frame_num;",
          "",
          "[Added Lines]",
          "3137:         while (h->frame_num != h->prev_frame_num &&",
          "3138:                h->frame_num != (h->prev_frame_num + 1) % (1 << h->sps.log2_max_frame_num)) {",
          "3140:             av_log(h->s.avctx, AV_LOG_DEBUG, \"Frame num gap %d %d\\n\",",
          "3141:                    h->frame_num, h->prev_frame_num);",
          "3145:             h->prev_frame_num %= 1 << h->sps.log2_max_frame_num;",
          "3146:             s->current_picture_ptr->frame_num = h->prev_frame_num;",
          "",
          "---------------",
          "--- Hunk 47 ---",
          "[Context before]",
          "2909:             if (h->short_ref_count) {",
          "2910:                 if (prev) {",
          "2911:                     av_image_copy(h->short_ref[0]->f.data, h->short_ref[0]->f.linesize,",
          "2915:                 }",
          "2916:                 h->short_ref[0]->frame_num = h->prev_frame_num;",
          "2917:             }",
          "",
          "[Removed Lines]",
          "2912:                                   (const uint8_t**)prev->f.data, prev->f.linesize,",
          "2913:                                   s->avctx->pix_fmt, s->mb_width*16, s->mb_height*16);",
          "2914:                     h->short_ref[0]->poc = prev->poc+2;",
          "",
          "[Added Lines]",
          "3162:                                   (const uint8_t **)prev->f.data, prev->f.linesize,",
          "3163:                                   s->avctx->pix_fmt, s->mb_width * 16, s->mb_height * 16);",
          "3164:                     h->short_ref[0]->poc = prev->poc + 2;",
          "",
          "---------------",
          "--- Hunk 48 ---",
          "[Context before]",
          "2927:             if (!FIELD_PICTURE || s->picture_structure == last_pic_structure) {",
          "2932:                 s0->current_picture_ptr = NULL;",
          "2935:             } else {",
          "2936:                 if (h->nal_ref_idc &&",
          "2946:                     s0->current_picture_ptr = NULL;",
          "2948:                 } else {",
          "2950:                     s0->first_field = 0;",
          "2951:                 }",
          "2952:             }",
          "2954:         } else {",
          "2956:             assert(!s0->current_picture_ptr);",
          "2957:             s0->first_field = FIELD_PICTURE;",
          "2958:         }",
          "2961:             if (ff_h264_frame_start(h) < 0) {",
          "2962:                 s0->first_field = 0;",
          "2963:                 return -1;",
          "",
          "[Removed Lines]",
          "2933:                 s0->first_field = FIELD_PICTURE;",
          "2937:                         s0->current_picture_ptr->f.reference &&",
          "2938:                         s0->current_picture_ptr->frame_num != h->frame_num) {",
          "2945:                     s0->first_field = 1;",
          "2960:         if(!FIELD_PICTURE || s0->first_field) {",
          "",
          "[Added Lines]",
          "3181:                 s0->first_field         = FIELD_PICTURE;",
          "3184:                     s0->current_picture_ptr->f.reference &&",
          "3185:                     s0->current_picture_ptr->frame_num != h->frame_num) {",
          "3189:                     s0->first_field         = 1;",
          "3202:         if (!FIELD_PICTURE || s0->first_field) {",
          "",
          "---------------",
          "--- Hunk 49 ---",
          "[Context before]",
          "2966:             ff_release_unused_pictures(s, 0);",
          "2967:         }",
          "2968:     }",
          "2970:         clone_slice(h, h0);",
          "2974:     assert(s->mb_num == s->mb_width * s->mb_height);",
          "2977:         av_log(h->s.avctx, AV_LOG_ERROR, \"first_mb_in_slice overflow\\n\");",
          "2978:         return -1;",
          "2979:     }",
          "2981:     s->resync_mb_y = s->mb_y = (first_mb_in_slice / s->mb_width) << FIELD_OR_MBAFF_PICTURE;",
          "2982:     if (s->picture_structure == PICT_BOTTOM_FIELD)",
          "2983:         s->resync_mb_y = s->mb_y = s->mb_y + 1;",
          "2984:     assert(s->mb_y < s->mb_height);",
          "2992:     }",
          "3004:     }",
          "3011:     }",
          "3013:     init_poc(h);",
          "3024:         int max_refs = s->picture_structure == PICT_FRAME ? 16 : 32;",
          "3035:         }",
          "3037:         if (h->ref_count[0] > max_refs || h->ref_count[1] > max_refs) {",
          "",
          "[Removed Lines]",
          "2969:     if(h != h0)",
          "2972:     s->current_picture_ptr->frame_num= h->frame_num; //FIXME frame_num cleanup",
          "2975:     if(first_mb_in_slice << FIELD_OR_MBAFF_PICTURE >= s->mb_num ||",
          "2976:        first_mb_in_slice                    >= s->mb_num){",
          "2980:     s->resync_mb_x = s->mb_x = first_mb_in_slice % s->mb_width;",
          "2986:     if(s->picture_structure==PICT_FRAME){",
          "2987:         h->curr_pic_num=   h->frame_num;",
          "2988:         h->max_pic_num= 1<< h->sps.log2_max_frame_num;",
          "2989:     }else{",
          "2990:         h->curr_pic_num= 2*h->frame_num + 1;",
          "2991:         h->max_pic_num= 1<<(h->sps.log2_max_frame_num + 1);",
          "2994:     if(h->nal_unit_type == NAL_IDR_SLICE){",
          "2996:     }",
          "2998:     if(h->sps.poc_type==0){",
          "2999:         h->poc_lsb= get_bits(&s->gb, h->sps.log2_max_poc_lsb);",
          "3001:         if(h->pps.pic_order_present==1 && s->picture_structure==PICT_FRAME){",
          "3002:             h->delta_poc_bottom= get_se_golomb(&s->gb);",
          "3003:         }",
          "3006:     if(h->sps.poc_type==1 && !h->sps.delta_pic_order_always_zero_flag){",
          "3007:         h->delta_poc[0]= get_se_golomb(&s->gb);",
          "3009:         if(h->pps.pic_order_present==1 && s->picture_structure==PICT_FRAME)",
          "3010:             h->delta_poc[1]= get_se_golomb(&s->gb);",
          "3015:     if(h->pps.redundant_pic_cnt_present){",
          "3016:         h->redundant_pic_count= get_ue_golomb(&s->gb);",
          "3017:     }",
          "3020:     h->ref_count[0]= h->pps.ref_count[0];",
          "3021:     h->ref_count[1]= h->pps.ref_count[1];",
          "3023:     if(h->slice_type_nos != AV_PICTURE_TYPE_I){",
          "3026:         if(h->slice_type_nos == AV_PICTURE_TYPE_B){",
          "3027:             h->direct_spatial_mv_pred= get_bits1(&s->gb);",
          "3028:         }",
          "3029:         num_ref_idx_active_override_flag= get_bits1(&s->gb);",
          "3031:         if(num_ref_idx_active_override_flag){",
          "3032:             h->ref_count[0]= get_ue_golomb(&s->gb) + 1;",
          "3033:             if(h->slice_type_nos==AV_PICTURE_TYPE_B)",
          "3034:                 h->ref_count[1]= get_ue_golomb(&s->gb) + 1;",
          "",
          "[Added Lines]",
          "3211:     if (h != h0)",
          "3214:     s->current_picture_ptr->frame_num = h->frame_num; // FIXME frame_num cleanup",
          "3217:     if (first_mb_in_slice << FIELD_OR_MBAFF_PICTURE >= s->mb_num ||",
          "3218:         first_mb_in_slice >= s->mb_num) {",
          "3222:     s->resync_mb_x = s->mb_x =  first_mb_in_slice % s->mb_width;",
          "3228:     if (s->picture_structure == PICT_FRAME) {",
          "3229:         h->curr_pic_num = h->frame_num;",
          "3230:         h->max_pic_num  = 1 << h->sps.log2_max_frame_num;",
          "3231:     } else {",
          "3232:         h->curr_pic_num = 2 * h->frame_num + 1;",
          "3233:         h->max_pic_num  = 1 << (h->sps.log2_max_frame_num + 1);",
          "3236:     if (h->nal_unit_type == NAL_IDR_SLICE)",
          "3239:     if (h->sps.poc_type == 0) {",
          "3240:         h->poc_lsb = get_bits(&s->gb, h->sps.log2_max_poc_lsb);",
          "3242:         if (h->pps.pic_order_present == 1 && s->picture_structure == PICT_FRAME)",
          "3243:             h->delta_poc_bottom = get_se_golomb(&s->gb);",
          "3246:     if (h->sps.poc_type == 1 && !h->sps.delta_pic_order_always_zero_flag) {",
          "3247:         h->delta_poc[0] = get_se_golomb(&s->gb);",
          "3249:         if (h->pps.pic_order_present == 1 && s->picture_structure == PICT_FRAME)",
          "3250:             h->delta_poc[1] = get_se_golomb(&s->gb);",
          "3255:     if (h->pps.redundant_pic_cnt_present)",
          "3256:         h->redundant_pic_count = get_ue_golomb(&s->gb);",
          "3259:     h->ref_count[0] = h->pps.ref_count[0];",
          "3260:     h->ref_count[1] = h->pps.ref_count[1];",
          "3262:     if (h->slice_type_nos != AV_PICTURE_TYPE_I) {",
          "3265:         if (h->slice_type_nos == AV_PICTURE_TYPE_B)",
          "3266:             h->direct_spatial_mv_pred = get_bits1(&s->gb);",
          "3267:         num_ref_idx_active_override_flag = get_bits1(&s->gb);",
          "3269:         if (num_ref_idx_active_override_flag) {",
          "3270:             h->ref_count[0] = get_ue_golomb(&s->gb) + 1;",
          "3271:             if (h->slice_type_nos == AV_PICTURE_TYPE_B)",
          "3272:                 h->ref_count[1] = get_ue_golomb(&s->gb) + 1;",
          "",
          "---------------",
          "--- Hunk 50 ---",
          "[Context before]",
          "3040:             return AVERROR_INVALIDDATA;",
          "3041:         }",
          "3045:         else",
          "3051:         ff_h264_fill_default_ref_list(h);",
          "3056:         return -1;",
          "3057:     }",
          "3061:         ff_copy_picture(&s->last_picture, s->last_picture_ptr);",
          "3062:     }",
          "3065:         ff_copy_picture(&s->next_picture, s->next_picture_ptr);",
          "3066:     }",
          "3070:         pred_weight_table(h);",
          "3072:         implicit_weight_table(h, -1);",
          "3074:         h->use_weight = 0;",
          "3075:         for (i = 0; i < 2; i++) {",
          "3076:             h->luma_weight_flag[i]   = 0;",
          "",
          "[Removed Lines]",
          "3043:         if(h->slice_type_nos == AV_PICTURE_TYPE_B)",
          "3044:             h->list_count= 2;",
          "3046:             h->list_count= 1;",
          "3047:     }else",
          "3048:         h->list_count= 0;",
          "3050:     if(!default_ref_list_done){",
          "3052:     }",
          "3054:     if(h->slice_type_nos!=AV_PICTURE_TYPE_I && ff_h264_decode_ref_pic_list_reordering(h) < 0) {",
          "3055:         h->ref_count[1]= h->ref_count[0]= 0;",
          "3059:     if(h->slice_type_nos!=AV_PICTURE_TYPE_I){",
          "3060:         s->last_picture_ptr= &h->ref_list[0][0];",
          "3063:     if(h->slice_type_nos==AV_PICTURE_TYPE_B){",
          "3064:         s->next_picture_ptr= &h->ref_list[1][0];",
          "3068:     if(   (h->pps.weighted_pred          && h->slice_type_nos == AV_PICTURE_TYPE_P )",
          "3069:        ||  (h->pps.weighted_bipred_idc==1 && h->slice_type_nos== AV_PICTURE_TYPE_B ) )",
          "3071:     else if(h->pps.weighted_bipred_idc==2 && h->slice_type_nos== AV_PICTURE_TYPE_B){",
          "3073:     }else {",
          "",
          "[Added Lines]",
          "3281:         if (h->slice_type_nos == AV_PICTURE_TYPE_B)",
          "3282:             h->list_count = 2;",
          "3284:             h->list_count = 1;",
          "3285:     } else",
          "3286:         h->list_count = 0;",
          "3288:     if (!default_ref_list_done)",
          "3291:     if (h->slice_type_nos != AV_PICTURE_TYPE_I &&",
          "3292:         ff_h264_decode_ref_pic_list_reordering(h) < 0) {",
          "3293:         h->ref_count[1] = h->ref_count[0] = 0;",
          "3297:     if (h->slice_type_nos != AV_PICTURE_TYPE_I) {",
          "3298:         s->last_picture_ptr = &h->ref_list[0][0];",
          "3301:     if (h->slice_type_nos == AV_PICTURE_TYPE_B) {",
          "3302:         s->next_picture_ptr = &h->ref_list[1][0];",
          "3306:     if ((h->pps.weighted_pred && h->slice_type_nos == AV_PICTURE_TYPE_P) ||",
          "3307:         (h->pps.weighted_bipred_idc == 1 &&",
          "3308:          h->slice_type_nos == AV_PICTURE_TYPE_B))",
          "3310:     else if (h->pps.weighted_bipred_idc == 2 &&",
          "3311:              h->slice_type_nos == AV_PICTURE_TYPE_B) {",
          "3313:     } else {",
          "",
          "---------------",
          "--- Hunk 51 ---",
          "[Context before]",
          "3078:         }",
          "3079:     }",
          "3083:         return AVERROR_INVALIDDATA;",
          "3086:         ff_h264_fill_mbaff_ref_list(h);",
          "3089:             implicit_weight_table(h, 0);",
          "3090:             implicit_weight_table(h, 1);",
          "3091:         }",
          "3092:     }",
          "3095:         ff_h264_direct_dist_scale_factor(h);",
          "3096:     ff_h264_direct_ref_list_init(h);",
          "3099:         tmp = get_ue_golomb_31(&s->gb);",
          "3101:             av_log(s->avctx, AV_LOG_ERROR, \"cabac_init_idc overflow\\n\");",
          "3102:             return -1;",
          "3103:         }",
          "3105:     }",
          "3107:     h->last_qscale_diff = 0;",
          "3108:     tmp = h->pps.init_qp + get_se_golomb(&s->gb);",
          "3110:         av_log(s->avctx, AV_LOG_ERROR, \"QP %u out of range\\n\", tmp);",
          "3111:         return -1;",
          "3112:     }",
          "3114:     h->chroma_qp[0] = get_chroma_qp(h, 0, s->qscale);",
          "3115:     h->chroma_qp[1] = get_chroma_qp(h, 1, s->qscale);",
          "3125:     h->slice_alpha_c0_offset = 52;",
          "3131:             return -1;",
          "3132:         }",
          "3138:             h->slice_alpha_c0_offset += get_se_golomb(&s->gb) << 1;",
          "3139:             h->slice_beta_offset     += get_se_golomb(&s->gb) << 1;",
          "3143:                 return -1;",
          "3144:             }",
          "3145:         }",
          "3146:     }",
          "3158:             h->deblocking_filter = 2;",
          "3159:         } else {",
          "3160:             h0->max_contexts = 1;",
          "3163:                 h0->single_decode_warning = 1;",
          "3164:             }",
          "3165:             if (h != h0) {",
          "3167:                 return 1;",
          "3168:             }",
          "3169:         }",
          "3170:     }",
          "3180:     h0->last_slice_type = slice_type;",
          "3181:     h->slice_num = ++h0->current_slice;",
          "3184:     }",
          "3187:         int id_list[16];",
          "3191:             if (h->ref_list[j][i].f.data[0]) {",
          "3192:                 int k;",
          "3193:                 uint8_t *base = h->ref_list[j][i].f.base[0];",
          "3195:                     if (h->short_ref[k]->f.base[0] == base) {",
          "3197:                         break;",
          "3198:                     }",
          "3200:                     if (h->long_ref[k] && h->long_ref[k]->f.base[0] == base) {",
          "3202:                         break;",
          "3203:                     }",
          "3204:             }",
          "3205:         }",
          "3225:                h->slice_num,",
          "3227:                first_mb_in_slice,",
          "3229:                pps_id, h->frame_num,",
          "3231:                h->ref_count[0], h->ref_count[1],",
          "3232:                s->qscale,",
          "3234:                h->use_weight,",
          "3238:     }",
          "3240:     return 0;",
          "",
          "[Removed Lines]",
          "3081:     if(h->nal_ref_idc && ff_h264_decode_ref_pic_marking(h0, &s->gb) < 0 &&",
          "3082:        (s->avctx->err_recognition & AV_EF_EXPLODE))",
          "3085:     if(FRAME_MBAFF){",
          "3088:         if(h->pps.weighted_bipred_idc==2 && h->slice_type_nos== AV_PICTURE_TYPE_B){",
          "3094:     if(h->slice_type_nos==AV_PICTURE_TYPE_B && !h->direct_spatial_mv_pred)",
          "3098:     if( h->slice_type_nos != AV_PICTURE_TYPE_I && h->pps.cabac ){",
          "3100:         if(tmp > 2){",
          "3104:         h->cabac_init_idc= tmp;",
          "3109:     if(tmp>51+6*(h->sps.bit_depth_luma-8)){",
          "3113:     s->qscale= tmp;",
          "3117:     if(h->slice_type == AV_PICTURE_TYPE_SP){",
          "3119:     }",
          "3120:     if(h->slice_type==AV_PICTURE_TYPE_SP || h->slice_type == AV_PICTURE_TYPE_SI){",
          "3122:     }",
          "3124:     h->deblocking_filter = 1;",
          "3126:     h->slice_beta_offset = 52;",
          "3127:     if( h->pps.deblocking_filter_parameters_present ) {",
          "3128:         tmp= get_ue_golomb_31(&s->gb);",
          "3129:         if(tmp > 2){",
          "3130:             av_log(s->avctx, AV_LOG_ERROR, \"deblocking_filter_idc %u out of range\\n\", tmp);",
          "3133:         h->deblocking_filter= tmp;",
          "3134:         if(h->deblocking_filter < 2)",
          "3135:             h->deblocking_filter^= 1; // 1<->0",
          "3137:         if( h->deblocking_filter ) {",
          "3140:             if(   h->slice_alpha_c0_offset > 104U",
          "3141:                || h->slice_beta_offset     > 104U){",
          "3142:                 av_log(s->avctx, AV_LOG_ERROR, \"deblocking filter parameters %d %d out of range\\n\", h->slice_alpha_c0_offset, h->slice_beta_offset);",
          "3148:     if(   s->avctx->skip_loop_filter >= AVDISCARD_ALL",
          "3149:        ||(s->avctx->skip_loop_filter >= AVDISCARD_NONKEY && h->slice_type_nos != AV_PICTURE_TYPE_I)",
          "3150:        ||(s->avctx->skip_loop_filter >= AVDISCARD_BIDIR  && h->slice_type_nos == AV_PICTURE_TYPE_B)",
          "3151:        ||(s->avctx->skip_loop_filter >= AVDISCARD_NONREF && h->nal_ref_idc == 0))",
          "3152:         h->deblocking_filter= 0;",
          "3154:     if(h->deblocking_filter == 1 && h0->max_contexts > 1) {",
          "3155:         if(s->avctx->flags2 & CODEC_FLAG2_FAST) {",
          "3161:             if(!h0->single_decode_warning) {",
          "3162:                 av_log(s->avctx, AV_LOG_INFO, \"Cannot parallelize deblocking type 1, decoding such frames in sequential order\\n\");",
          "3166:                 av_log(h->s.avctx, AV_LOG_ERROR, \"Deblocking switched inside frame.\\n\");",
          "3171:     h->qp_thresh = 15 + 52 - FFMIN(h->slice_alpha_c0_offset, h->slice_beta_offset)",
          "3172:                  - FFMAX3(0, h->pps.chroma_qp_index_offset[0], h->pps.chroma_qp_index_offset[1])",
          "3173:                  + 6 * (h->sps.bit_depth_luma - 8);",
          "3175: #if 0 //FMO",
          "3176:     if( h->pps.num_slice_groups > 1  && h->pps.mb_slice_group_map_type >= 3 && h->pps.mb_slice_group_map_type <= 5)",
          "3177:         slice_group_change_cycle= get_bits(&s->gb, ?);",
          "3178: #endif",
          "3182:     if(h->slice_num >= MAX_SLICES){",
          "3183:         av_log(s->avctx, AV_LOG_ERROR, \"Too many slices, increase MAX_SLICES and recompile\\n\");",
          "3186:     for(j=0; j<2; j++){",
          "3188:         int *ref2frm= h->ref2frm[h->slice_num&(MAX_SLICES-1)][j];",
          "3189:         for(i=0; i<16; i++){",
          "3190:             id_list[i]= 60;",
          "3194:                 for(k=0; k<h->short_ref_count; k++)",
          "3196:                         id_list[i]= k;",
          "3199:                 for(k=0; k<h->long_ref_count; k++)",
          "3201:                         id_list[i]= h->short_ref_count + k;",
          "3207:         ref2frm[0]=",
          "3208:         ref2frm[1]= -1;",
          "3209:         for(i=0; i<16; i++)",
          "3210:             ref2frm[i+2]= 4*id_list[i]",
          "3211:                           + (h->ref_list[j][i].f.reference & 3);",
          "3212:         ref2frm[18+0]=",
          "3213:         ref2frm[18+1]= -1;",
          "3214:         for(i=16; i<48; i++)",
          "3215:             ref2frm[i+4]= 4*id_list[(i-16)>>1]",
          "3216:                           + (h->ref_list[j][i].f.reference & 3);",
          "3217:     }",
          "3220:     h->emu_edge_width= (s->flags&CODEC_FLAG_EMU_EDGE || (!h->sps.frame_mbs_only_flag && s->avctx->active_thread_type)) ? 0 : 16;",
          "3221:     h->emu_edge_height= (FRAME_MBAFF || FIELD_PICTURE) ? 0 : h->emu_edge_width;",
          "3223:     if(s->avctx->debug&FF_DEBUG_PICT_INFO){",
          "3224:         av_log(h->s.avctx, AV_LOG_DEBUG, \"slice:%d %s mb:%d %c%s%s pps:%u frame:%d poc:%d/%d ref:%d/%d qp:%d loop:%d:%d:%d weight:%d%s %s\\n\",",
          "3226:                (s->picture_structure==PICT_FRAME ? \"F\" : s->picture_structure==PICT_TOP_FIELD ? \"T\" : \"B\"),",
          "3228:                av_get_picture_type_char(h->slice_type), h->slice_type_fixed ? \" fix\" : \"\", h->nal_unit_type == NAL_IDR_SLICE ? \" IDR\" : \"\",",
          "3230:                s->current_picture_ptr->field_poc[0], s->current_picture_ptr->field_poc[1],",
          "3233:                h->deblocking_filter, h->slice_alpha_c0_offset/2-26, h->slice_beta_offset/2-26,",
          "3235:                h->use_weight==1 && h->use_weight_chroma ? \"c\" : \"\",",
          "3236:                h->slice_type == AV_PICTURE_TYPE_B ? (h->direct_spatial_mv_pred ? \"SPAT\" : \"TEMP\") : \"\"",
          "3237:                );",
          "",
          "[Added Lines]",
          "3321:     if (h->nal_ref_idc && ff_h264_decode_ref_pic_marking(h0, &s->gb) < 0 &&",
          "3322:         (s->avctx->err_recognition & AV_EF_EXPLODE))",
          "3325:     if (FRAME_MBAFF) {",
          "3328:         if (h->pps.weighted_bipred_idc == 2 && h->slice_type_nos == AV_PICTURE_TYPE_B) {",
          "3334:     if (h->slice_type_nos == AV_PICTURE_TYPE_B && !h->direct_spatial_mv_pred)",
          "3338:     if (h->slice_type_nos != AV_PICTURE_TYPE_I && h->pps.cabac) {",
          "3340:         if (tmp > 2) {",
          "3344:         h->cabac_init_idc = tmp;",
          "3349:     if (tmp > 51 + 6 * (h->sps.bit_depth_luma - 8)) {",
          "3353:     s->qscale       = tmp;",
          "3357:     if (h->slice_type == AV_PICTURE_TYPE_SP)",
          "3359:     if (h->slice_type == AV_PICTURE_TYPE_SP ||",
          "3360:         h->slice_type == AV_PICTURE_TYPE_SI)",
          "3363:     h->deblocking_filter     = 1;",
          "3365:     h->slice_beta_offset     = 52;",
          "3366:     if (h->pps.deblocking_filter_parameters_present) {",
          "3367:         tmp = get_ue_golomb_31(&s->gb);",
          "3368:         if (tmp > 2) {",
          "3369:             av_log(s->avctx, AV_LOG_ERROR,",
          "3370:                    \"deblocking_filter_idc %u out of range\\n\", tmp);",
          "3373:         h->deblocking_filter = tmp;",
          "3374:         if (h->deblocking_filter < 2)",
          "3375:             h->deblocking_filter ^= 1;  // 1<->0",
          "3377:         if (h->deblocking_filter) {",
          "3380:             if (h->slice_alpha_c0_offset > 104U ||",
          "3381:                 h->slice_beta_offset     > 104U) {",
          "3382:                 av_log(s->avctx, AV_LOG_ERROR,",
          "3383:                        \"deblocking filter parameters %d %d out of range\\n\",",
          "3384:                        h->slice_alpha_c0_offset, h->slice_beta_offset);",
          "3390:     if (s->avctx->skip_loop_filter >= AVDISCARD_ALL ||",
          "3391:         (s->avctx->skip_loop_filter >= AVDISCARD_NONKEY &&",
          "3392:          h->slice_type_nos != AV_PICTURE_TYPE_I) ||",
          "3393:         (s->avctx->skip_loop_filter >= AVDISCARD_BIDIR  &&",
          "3394:          h->slice_type_nos == AV_PICTURE_TYPE_B) ||",
          "3395:         (s->avctx->skip_loop_filter >= AVDISCARD_NONREF &&",
          "3396:          h->nal_ref_idc == 0))",
          "3397:         h->deblocking_filter = 0;",
          "3399:     if (h->deblocking_filter == 1 && h0->max_contexts > 1) {",
          "3400:         if (s->avctx->flags2 & CODEC_FLAG2_FAST) {",
          "3406:             if (!h0->single_decode_warning) {",
          "3407:                 av_log(s->avctx, AV_LOG_INFO,",
          "3408:                        \"Cannot parallelize deblocking type 1, decoding such frames in sequential order\\n\");",
          "3412:                 av_log(h->s.avctx, AV_LOG_ERROR,",
          "3413:                        \"Deblocking switched inside frame.\\n\");",
          "3418:     h->qp_thresh = 15 + 52 -",
          "3419:                    FFMIN(h->slice_alpha_c0_offset, h->slice_beta_offset) -",
          "3420:                    FFMAX3(0,",
          "3421:                           h->pps.chroma_qp_index_offset[0],",
          "3422:                           h->pps.chroma_qp_index_offset[1]) +",
          "3423:                    6 * (h->sps.bit_depth_luma - 8);",
          "3427:     if (h->slice_num >= MAX_SLICES) {",
          "3428:         av_log(s->avctx, AV_LOG_ERROR,",
          "3429:                \"Too many slices, increase MAX_SLICES and recompile\\n\");",
          "3432:     for (j = 0; j < 2; j++) {",
          "3434:         int *ref2frm = h->ref2frm[h->slice_num & (MAX_SLICES - 1)][j];",
          "3435:         for (i = 0; i < 16; i++) {",
          "3436:             id_list[i] = 60;",
          "3440:                 for (k = 0; k < h->short_ref_count; k++)",
          "3442:                         id_list[i] = k;",
          "3445:                 for (k = 0; k < h->long_ref_count; k++)",
          "3447:                         id_list[i] = h->short_ref_count + k;",
          "3453:         ref2frm[0]     =",
          "3454:             ref2frm[1] = -1;",
          "3455:         for (i = 0; i < 16; i++)",
          "3456:             ref2frm[i + 2] = 4 * id_list[i] +",
          "3457:                              (h->ref_list[j][i].f.reference & 3);",
          "3458:         ref2frm[18 + 0]     =",
          "3459:             ref2frm[18 + 1] = -1;",
          "3460:         for (i = 16; i < 48; i++)",
          "3461:             ref2frm[i + 4] = 4 * id_list[(i - 16) >> 1] +",
          "3462:                              (h->ref_list[j][i].f.reference & 3);",
          "3463:     }",
          "3466:     h->emu_edge_width  = (s->flags & CODEC_FLAG_EMU_EDGE ||",
          "3467:                           (!h->sps.frame_mbs_only_flag &&",
          "3468:                            s->avctx->active_thread_type))",
          "3469:                          ? 0 : 16;",
          "3470:     h->emu_edge_height = (FRAME_MBAFF || FIELD_PICTURE) ? 0 : h->emu_edge_width;",
          "3472:     if (s->avctx->debug & FF_DEBUG_PICT_INFO) {",
          "3473:         av_log(h->s.avctx, AV_LOG_DEBUG,",
          "3474:                \"slice:%d %s mb:%d %c%s%s pps:%u frame:%d poc:%d/%d ref:%d/%d qp:%d loop:%d:%d:%d weight:%d%s %s\\n\",",
          "3476:                (s->picture_structure == PICT_FRAME ? \"F\" : s->picture_structure == PICT_TOP_FIELD ? \"T\" : \"B\"),",
          "3478:                av_get_picture_type_char(h->slice_type),",
          "3479:                h->slice_type_fixed ? \" fix\" : \"\",",
          "3480:                h->nal_unit_type == NAL_IDR_SLICE ? \" IDR\" : \"\",",
          "3482:                s->current_picture_ptr->field_poc[0],",
          "3483:                s->current_picture_ptr->field_poc[1],",
          "3486:                h->deblocking_filter,",
          "3487:                h->slice_alpha_c0_offset / 2 - 26, h->slice_beta_offset / 2 - 26,",
          "3489:                h->use_weight == 1 && h->use_weight_chroma ? \"c\" : \"\",",
          "3490:                h->slice_type == AV_PICTURE_TYPE_B ? (h->direct_spatial_mv_pred ? \"SPAT\" : \"TEMP\") : \"\");",
          "",
          "---------------",
          "--- Hunk 52 ---",
          "[Context before]",
          "3243: int ff_h264_get_slice_type(const H264Context *h)",
          "3244: {",
          "3245:     switch (h->slice_type) {",
          "3252:     }",
          "3253: }",
          "3257: {",
          "3258:     int b_stride = h->b_stride;",
          "3260:     int8_t *ref_cache = &h->ref_cache[list][scan8[0]];",
          "3274:         }",
          "3298:             }",
          "3299:         }",
          "3300:     }",
          "3308:         return;",
          "3309:     }",
          "3311:     {",
          "3320:     }",
          "3322:     {",
          "3328:     }",
          "3329: }",
          "",
          "[Removed Lines]",
          "3246:     case AV_PICTURE_TYPE_P:  return 0;",
          "3247:     case AV_PICTURE_TYPE_B:  return 1;",
          "3248:     case AV_PICTURE_TYPE_I:  return 2;",
          "3249:     case AV_PICTURE_TYPE_SP: return 3;",
          "3250:     case AV_PICTURE_TYPE_SI: return 4;",
          "3251:     default:         return -1;",
          "3255: static av_always_inline void fill_filter_caches_inter(H264Context *h, MpegEncContext * const s, int mb_type, int top_xy,",
          "3256:                                                       int left_xy[LEFT_MBS], int top_type, int left_type[LEFT_MBS], int mb_xy, int list)",
          "3259:     int16_t (*mv_dst)[2] = &h->mv_cache[list][scan8[0]];",
          "3261:     if(IS_INTER(mb_type) || IS_DIRECT(mb_type)){",
          "3262:         if(USES_LIST(top_type, list)){",
          "3263:             const int b_xy= h->mb2b_xy[top_xy] + 3*b_stride;",
          "3264:             const int b8_xy= 4*top_xy + 2;",
          "3265:             int (*ref2frm)[64] = h->ref2frm[ h->slice_table[top_xy]&(MAX_SLICES-1) ][0] + (MB_MBAFF ? 20 : 2);",
          "3266:             AV_COPY128(mv_dst - 1*8, s->current_picture.f.motion_val[list][b_xy + 0]);",
          "3267:             ref_cache[0 - 1*8]=",
          "3268:             ref_cache[1 - 1*8]= ref2frm[list][s->current_picture.f.ref_index[list][b8_xy + 0]];",
          "3269:             ref_cache[2 - 1*8]=",
          "3270:             ref_cache[3 - 1*8]= ref2frm[list][s->current_picture.f.ref_index[list][b8_xy + 1]];",
          "3271:         }else{",
          "3272:             AV_ZERO128(mv_dst - 1*8);",
          "3273:             AV_WN32A(&ref_cache[0 - 1*8], ((LIST_NOT_USED)&0xFF)*0x01010101u);",
          "3276:         if(!IS_INTERLACED(mb_type^left_type[LTOP])){",
          "3277:             if(USES_LIST(left_type[LTOP], list)){",
          "3278:                 const int b_xy= h->mb2b_xy[left_xy[LTOP]] + 3;",
          "3279:                 const int b8_xy= 4*left_xy[LTOP] + 1;",
          "3280:                 int (*ref2frm)[64] = h->ref2frm[ h->slice_table[left_xy[LTOP]]&(MAX_SLICES-1) ][0] + (MB_MBAFF ? 20 : 2);",
          "3281:                 AV_COPY32(mv_dst - 1 +  0, s->current_picture.f.motion_val[list][b_xy + b_stride*0]);",
          "3282:                 AV_COPY32(mv_dst - 1 +  8, s->current_picture.f.motion_val[list][b_xy + b_stride*1]);",
          "3283:                 AV_COPY32(mv_dst - 1 + 16, s->current_picture.f.motion_val[list][b_xy + b_stride*2]);",
          "3284:                 AV_COPY32(mv_dst - 1 + 24, s->current_picture.f.motion_val[list][b_xy + b_stride*3]);",
          "3285:                 ref_cache[-1 +  0]=",
          "3286:                 ref_cache[-1 +  8]= ref2frm[list][s->current_picture.f.ref_index[list][b8_xy + 2*0]];",
          "3287:                 ref_cache[-1 + 16]=",
          "3288:                 ref_cache[-1 + 24]= ref2frm[list][s->current_picture.f.ref_index[list][b8_xy + 2*1]];",
          "3289:             }else{",
          "3290:                 AV_ZERO32(mv_dst - 1 + 0);",
          "3291:                 AV_ZERO32(mv_dst - 1 + 8);",
          "3292:                 AV_ZERO32(mv_dst - 1 +16);",
          "3293:                 AV_ZERO32(mv_dst - 1 +24);",
          "3294:                 ref_cache[-1 +  0]=",
          "3295:                 ref_cache[-1 +  8]=",
          "3296:                 ref_cache[-1 + 16]=",
          "3297:                 ref_cache[-1 + 24]= LIST_NOT_USED;",
          "3302:     if(!USES_LIST(mb_type, list)){",
          "3303:         fill_rectangle(mv_dst, 4, 4, 8, pack16to32(0,0), 4);",
          "3304:         AV_WN32A(&ref_cache[0*8], ((LIST_NOT_USED)&0xFF)*0x01010101u);",
          "3305:         AV_WN32A(&ref_cache[1*8], ((LIST_NOT_USED)&0xFF)*0x01010101u);",
          "3306:         AV_WN32A(&ref_cache[2*8], ((LIST_NOT_USED)&0xFF)*0x01010101u);",
          "3307:         AV_WN32A(&ref_cache[3*8], ((LIST_NOT_USED)&0xFF)*0x01010101u);",
          "3312:         int8_t *ref = &s->current_picture.f.ref_index[list][4*mb_xy];",
          "3313:         int (*ref2frm)[64] = h->ref2frm[ h->slice_num&(MAX_SLICES-1) ][0] + (MB_MBAFF ? 20 : 2);",
          "3314:         uint32_t ref01 = (pack16to32(ref2frm[list][ref[0]],ref2frm[list][ref[1]])&0x00FF00FF)*0x0101;",
          "3315:         uint32_t ref23 = (pack16to32(ref2frm[list][ref[2]],ref2frm[list][ref[3]])&0x00FF00FF)*0x0101;",
          "3316:         AV_WN32A(&ref_cache[0*8], ref01);",
          "3317:         AV_WN32A(&ref_cache[1*8], ref01);",
          "3318:         AV_WN32A(&ref_cache[2*8], ref23);",
          "3319:         AV_WN32A(&ref_cache[3*8], ref23);",
          "3323:         int16_t (*mv_src)[2] = &s->current_picture.f.motion_val[list][4*s->mb_x + 4*s->mb_y*b_stride];",
          "3324:         AV_COPY128(mv_dst + 8*0, mv_src + 0*b_stride);",
          "3325:         AV_COPY128(mv_dst + 8*1, mv_src + 1*b_stride);",
          "3326:         AV_COPY128(mv_dst + 8*2, mv_src + 2*b_stride);",
          "3327:         AV_COPY128(mv_dst + 8*3, mv_src + 3*b_stride);",
          "",
          "[Added Lines]",
          "3499:     case AV_PICTURE_TYPE_P:",
          "3500:         return 0;",
          "3501:     case AV_PICTURE_TYPE_B:",
          "3502:         return 1;",
          "3503:     case AV_PICTURE_TYPE_I:",
          "3504:         return 2;",
          "3505:     case AV_PICTURE_TYPE_SP:",
          "3506:         return 3;",
          "3507:     case AV_PICTURE_TYPE_SI:",
          "3508:         return 4;",
          "3509:     default:",
          "3510:         return -1;",
          "3514: static av_always_inline void fill_filter_caches_inter(H264Context *h,",
          "3515:                                                       MpegEncContext *const s,",
          "3516:                                                       int mb_type, int top_xy,",
          "3517:                                                       int left_xy[LEFT_MBS],",
          "3518:                                                       int top_type,",
          "3519:                                                       int left_type[LEFT_MBS],",
          "3520:                                                       int mb_xy, int list)",
          "3523:     int16_t(*mv_dst)[2] = &h->mv_cache[list][scan8[0]];",
          "3525:     if (IS_INTER(mb_type) || IS_DIRECT(mb_type)) {",
          "3526:         if (USES_LIST(top_type, list)) {",
          "3527:             const int b_xy  = h->mb2b_xy[top_xy] + 3 * b_stride;",
          "3528:             const int b8_xy = 4 * top_xy + 2;",
          "3529:             int (*ref2frm)[64] = h->ref2frm[h->slice_table[top_xy] & (MAX_SLICES - 1)][0] + (MB_MBAFF ? 20 : 2);",
          "3530:             AV_COPY128(mv_dst - 1 * 8, s->current_picture.f.motion_val[list][b_xy + 0]);",
          "3531:             ref_cache[0 - 1 * 8] =",
          "3532:             ref_cache[1 - 1 * 8] = ref2frm[list][s->current_picture.f.ref_index[list][b8_xy + 0]];",
          "3533:             ref_cache[2 - 1 * 8] =",
          "3534:             ref_cache[3 - 1 * 8] = ref2frm[list][s->current_picture.f.ref_index[list][b8_xy + 1]];",
          "3535:         } else {",
          "3536:             AV_ZERO128(mv_dst - 1 * 8);",
          "3537:             AV_WN32A(&ref_cache[0 - 1 * 8], ((LIST_NOT_USED) & 0xFF) * 0x01010101u);",
          "3540:         if (!IS_INTERLACED(mb_type ^ left_type[LTOP])) {",
          "3541:             if (USES_LIST(left_type[LTOP], list)) {",
          "3542:                 const int b_xy  = h->mb2b_xy[left_xy[LTOP]] + 3;",
          "3543:                 const int b8_xy = 4 * left_xy[LTOP] + 1;",
          "3544:                 int (*ref2frm)[64] = h->ref2frm[h->slice_table[left_xy[LTOP]] & (MAX_SLICES - 1)][0] + (MB_MBAFF ? 20 : 2);",
          "3545:                 AV_COPY32(mv_dst - 1 +  0, s->current_picture.f.motion_val[list][b_xy + b_stride * 0]);",
          "3546:                 AV_COPY32(mv_dst - 1 +  8, s->current_picture.f.motion_val[list][b_xy + b_stride * 1]);",
          "3547:                 AV_COPY32(mv_dst - 1 + 16, s->current_picture.f.motion_val[list][b_xy + b_stride * 2]);",
          "3548:                 AV_COPY32(mv_dst - 1 + 24, s->current_picture.f.motion_val[list][b_xy + b_stride * 3]);",
          "3549:                 ref_cache[-1 +  0] =",
          "3550:                 ref_cache[-1 +  8] = ref2frm[list][s->current_picture.f.ref_index[list][b8_xy + 2 * 0]];",
          "3551:                 ref_cache[-1 + 16] =",
          "3552:                 ref_cache[-1 + 24] = ref2frm[list][s->current_picture.f.ref_index[list][b8_xy + 2 * 1]];",
          "3553:             } else {",
          "3554:                 AV_ZERO32(mv_dst - 1 +  0);",
          "3555:                 AV_ZERO32(mv_dst - 1 +  8);",
          "3556:                 AV_ZERO32(mv_dst - 1 + 16);",
          "3557:                 AV_ZERO32(mv_dst - 1 + 24);",
          "3558:                 ref_cache[-1 +  0] =",
          "3559:                 ref_cache[-1 +  8] =",
          "3560:                 ref_cache[-1 + 16] =",
          "3561:                 ref_cache[-1 + 24] = LIST_NOT_USED;",
          "3566:     if (!USES_LIST(mb_type, list)) {",
          "3567:         fill_rectangle(mv_dst, 4, 4, 8, pack16to32(0, 0), 4);",
          "3568:         AV_WN32A(&ref_cache[0 * 8], ((LIST_NOT_USED) & 0xFF) * 0x01010101u);",
          "3569:         AV_WN32A(&ref_cache[1 * 8], ((LIST_NOT_USED) & 0xFF) * 0x01010101u);",
          "3570:         AV_WN32A(&ref_cache[2 * 8], ((LIST_NOT_USED) & 0xFF) * 0x01010101u);",
          "3571:         AV_WN32A(&ref_cache[3 * 8], ((LIST_NOT_USED) & 0xFF) * 0x01010101u);",
          "3576:         int8_t *ref = &s->current_picture.f.ref_index[list][4 * mb_xy];",
          "3577:         int (*ref2frm)[64] = h->ref2frm[h->slice_num & (MAX_SLICES - 1)][0] + (MB_MBAFF ? 20 : 2);",
          "3578:         uint32_t ref01 = (pack16to32(ref2frm[list][ref[0]], ref2frm[list][ref[1]]) & 0x00FF00FF) * 0x0101;",
          "3579:         uint32_t ref23 = (pack16to32(ref2frm[list][ref[2]], ref2frm[list][ref[3]]) & 0x00FF00FF) * 0x0101;",
          "3580:         AV_WN32A(&ref_cache[0 * 8], ref01);",
          "3581:         AV_WN32A(&ref_cache[1 * 8], ref01);",
          "3582:         AV_WN32A(&ref_cache[2 * 8], ref23);",
          "3583:         AV_WN32A(&ref_cache[3 * 8], ref23);",
          "3587:         int16_t(*mv_src)[2] = &s->current_picture.f.motion_val[list][4 * s->mb_x + 4 * s->mb_y * b_stride];",
          "3588:         AV_COPY128(mv_dst + 8 * 0, mv_src + 0 * b_stride);",
          "3589:         AV_COPY128(mv_dst + 8 * 1, mv_src + 1 * b_stride);",
          "3590:         AV_COPY128(mv_dst + 8 * 2, mv_src + 2 * b_stride);",
          "3591:         AV_COPY128(mv_dst + 8 * 3, mv_src + 3 * b_stride);",
          "",
          "---------------",
          "--- Hunk 53 ---",
          "[Context before]",
          "3338:     int top_xy, left_xy[LEFT_MBS];",
          "3339:     int top_type, left_type[LEFT_MBS];",
          "3340:     uint8_t *nnz;",
          "3341:     uint8_t *nnz_cache;",
          "3354:                 left_xy[LTOP] -= s->mb_stride;",
          "3361:                 left_xy[LBOT] += s->mb_stride;",
          "3363:         }",
          "3364:     }",
          "3367:     h->left_mb_xy[LTOP] = left_xy[LTOP];",
          "3368:     h->left_mb_xy[LBOT] = left_xy[LBOT];",
          "3369:     {",
          "3378:                 return 1;",
          "3381:                 return 1;",
          "3382:         }",
          "3383:     }",
          "",
          "[Removed Lines]",
          "3335: static int fill_filter_caches(H264Context *h, int mb_type){",
          "3336:     MpegEncContext * const s = &h->s;",
          "3337:     const int mb_xy= h->mb_xy;",
          "3343:     top_xy     = mb_xy  - (s->mb_stride << MB_FIELD);",
          "3348:     left_xy[LBOT] = left_xy[LTOP] = mb_xy-1;",
          "3349:     if(FRAME_MBAFF){",
          "3350:         const int left_mb_field_flag     = IS_INTERLACED(s->current_picture.f.mb_type[mb_xy - 1]);",
          "3351:         const int curr_mb_field_flag     = IS_INTERLACED(mb_type);",
          "3352:         if(s->mb_y&1){",
          "3353:             if (left_mb_field_flag != curr_mb_field_flag) {",
          "3355:             }",
          "3356:         }else{",
          "3357:             if(curr_mb_field_flag){",
          "3358:                 top_xy += s->mb_stride & (((s->current_picture.f.mb_type[top_xy] >> 7) & 1) - 1);",
          "3359:             }",
          "3360:             if (left_mb_field_flag != curr_mb_field_flag) {",
          "3362:             }",
          "3366:     h->top_mb_xy = top_xy;",
          "3372:         int qp_thresh = h->qp_thresh; //FIXME strictly we should store qp_thresh for each mb of a slice",
          "3373:         int qp = s->current_picture.f.qscale_table[mb_xy];",
          "3374:         if(qp <= qp_thresh",
          "3375:            && (left_xy[LTOP] < 0 || ((qp + s->current_picture.f.qscale_table[left_xy[LTOP]] + 1) >> 1) <= qp_thresh)",
          "3376:            && (top_xy        < 0 || ((qp + s->current_picture.f.qscale_table[top_xy       ] + 1) >> 1) <= qp_thresh)) {",
          "3377:             if(!FRAME_MBAFF)",
          "3379:             if ((left_xy[LTOP] < 0            || ((qp + s->current_picture.f.qscale_table[left_xy[LBOT]        ] + 1) >> 1) <= qp_thresh) &&",
          "3380:                 (top_xy        < s->mb_stride || ((qp + s->current_picture.f.qscale_table[top_xy - s->mb_stride] + 1) >> 1) <= qp_thresh))",
          "",
          "[Added Lines]",
          "3599: static int fill_filter_caches(H264Context *h, int mb_type)",
          "3600: {",
          "3601:     MpegEncContext *const s = &h->s;",
          "3602:     const int mb_xy = h->mb_xy;",
          "3608:     top_xy = mb_xy - (s->mb_stride << MB_FIELD);",
          "3613:     left_xy[LBOT] = left_xy[LTOP] = mb_xy - 1;",
          "3614:     if (FRAME_MBAFF) {",
          "3615:         const int left_mb_field_flag = IS_INTERLACED(s->current_picture.f.mb_type[mb_xy - 1]);",
          "3616:         const int curr_mb_field_flag = IS_INTERLACED(mb_type);",
          "3617:         if (s->mb_y & 1) {",
          "3618:             if (left_mb_field_flag != curr_mb_field_flag)",
          "3620:         } else {",
          "3621:             if (curr_mb_field_flag)",
          "3622:                 top_xy += s->mb_stride &",
          "3623:                     (((s->current_picture.f.mb_type[top_xy] >> 7) & 1) - 1);",
          "3624:             if (left_mb_field_flag != curr_mb_field_flag)",
          "3629:     h->top_mb_xy        = top_xy;",
          "3636:         int qp_thresh = h->qp_thresh; // FIXME strictly we should store qp_thresh for each mb of a slice",
          "3637:         int qp        = s->current_picture.f.qscale_table[mb_xy];",
          "3638:         if (qp <= qp_thresh &&",
          "3639:             (left_xy[LTOP] < 0 ||",
          "3640:              ((qp + s->current_picture.f.qscale_table[left_xy[LTOP]] + 1) >> 1) <= qp_thresh) &&",
          "3641:             (top_xy < 0 ||",
          "3642:              ((qp + s->current_picture.f.qscale_table[top_xy] + 1) >> 1) <= qp_thresh)) {",
          "3643:             if (!FRAME_MBAFF)",
          "3645:             if ((left_xy[LTOP] < 0 ||",
          "3646:                  ((qp + s->current_picture.f.qscale_table[left_xy[LBOT]] + 1) >> 1) <= qp_thresh) &&",
          "3647:                 (top_xy < s->mb_stride ||",
          "3648:                  ((qp + s->current_picture.f.qscale_table[top_xy - s->mb_stride] + 1) >> 1) <= qp_thresh))",
          "",
          "---------------",
          "--- Hunk 54 ---",
          "[Context before]",
          "3385:     top_type        = s->current_picture.f.mb_type[top_xy];",
          "3386:     left_type[LTOP] = s->current_picture.f.mb_type[left_xy[LTOP]];",
          "3387:     left_type[LBOT] = s->current_picture.f.mb_type[left_xy[LBOT]];",
          "3394:     }",
          "3400:         return 0;",
          "3407:     nnz_cache = h->non_zero_count_cache;",
          "3415:         nnz = h->non_zero_count[top_xy];",
          "3417:     }",
          "3420:         nnz = h->non_zero_count[left_xy[LTOP]];",
          "3434:         }",
          "3438:         }",
          "3442:         }",
          "3456:         }",
          "3457:     }",
          "3459:     return 0;",
          "3460: }",
          "3465:     int linesize, uvlinesize, mb_x, mb_y;",
          "3474:                 int mb_xy, mb_type;",
          "3490:                 if (MB_FIELD) {",
          "3492:                     uvlinesize = h->mb_uvlinesize = s->uvlinesize * 2;",
          "3497:                     }",
          "3498:                 } else {",
          "3499:                     linesize   = h->mb_linesize   = s->linesize;",
          "3500:                     uvlinesize = h->mb_uvlinesize = s->uvlinesize;",
          "3501:                 }",
          "3504:                     continue;",
          "3505:                 h->chroma_qp[0] = get_chroma_qp(h, 0, s->current_picture.f.qscale_table[mb_xy]);",
          "3506:                 h->chroma_qp[1] = get_chroma_qp(h, 1, s->current_picture.f.qscale_table[mb_xy]);",
          "3508:                 if (FRAME_MBAFF) {",
          "3510:                 } else {",
          "3512:                 }",
          "3513:             }",
          "3515:     }",
          "3519:     h->chroma_qp[0] = get_chroma_qp(h, 0, s->qscale);",
          "3520:     h->chroma_qp[1] = get_chroma_qp(h, 1, s->qscale);",
          "3521: }",
          "3532: }",
          "3541:     int deblock_border = (16 + 4) << FRAME_MBAFF;",
          "3544:     if (h->deblocking_filter) {",
          "3546:             height += deblock_border;",
          "3548:         top -= deblock_border;",
          "3549:     }",
          "",
          "[Removed Lines]",
          "3388:     if(h->deblocking_filter == 2){",
          "3389:         if(h->slice_table[top_xy       ] != h->slice_num) top_type= 0;",
          "3390:         if(h->slice_table[left_xy[LBOT]] != h->slice_num) left_type[LTOP]= left_type[LBOT]= 0;",
          "3391:     }else{",
          "3392:         if(h->slice_table[top_xy       ] == 0xFFFF) top_type= 0;",
          "3393:         if(h->slice_table[left_xy[LBOT]] == 0xFFFF) left_type[LTOP]= left_type[LBOT] =0;",
          "3395:     h->top_type       = top_type;",
          "3396:     h->left_type[LTOP]= left_type[LTOP];",
          "3397:     h->left_type[LBOT]= left_type[LBOT];",
          "3399:     if(IS_INTRA(mb_type))",
          "3402:     fill_filter_caches_inter(h, s, mb_type, top_xy, left_xy, top_type, left_type, mb_xy, 0);",
          "3403:     if(h->list_count == 2)",
          "3404:         fill_filter_caches_inter(h, s, mb_type, top_xy, left_xy, top_type, left_type, mb_xy, 1);",
          "3406:     nnz = h->non_zero_count[mb_xy];",
          "3408:     AV_COPY32(&nnz_cache[4+8*1], &nnz[ 0]);",
          "3409:     AV_COPY32(&nnz_cache[4+8*2], &nnz[ 4]);",
          "3410:     AV_COPY32(&nnz_cache[4+8*3], &nnz[ 8]);",
          "3411:     AV_COPY32(&nnz_cache[4+8*4], &nnz[12]);",
          "3412:     h->cbp= h->cbp_table[mb_xy];",
          "3414:     if(top_type){",
          "3416:         AV_COPY32(&nnz_cache[4+8*0], &nnz[3*4]);",
          "3419:     if(left_type[LTOP]){",
          "3421:         nnz_cache[3+8*1]= nnz[3+0*4];",
          "3422:         nnz_cache[3+8*2]= nnz[3+1*4];",
          "3423:         nnz_cache[3+8*3]= nnz[3+2*4];",
          "3424:         nnz_cache[3+8*4]= nnz[3+3*4];",
          "3425:     }",
          "3428:     if(!CABAC && h->pps.transform_8x8_mode){",
          "3429:         if(IS_8x8DCT(top_type)){",
          "3430:             nnz_cache[4+8*0]=",
          "3431:             nnz_cache[5+8*0]= (h->cbp_table[top_xy] & 0x4000) >> 12;",
          "3432:             nnz_cache[6+8*0]=",
          "3433:             nnz_cache[7+8*0]= (h->cbp_table[top_xy] & 0x8000) >> 12;",
          "3435:         if(IS_8x8DCT(left_type[LTOP])){",
          "3436:             nnz_cache[3+8*1]=",
          "3437:             nnz_cache[3+8*2]= (h->cbp_table[left_xy[LTOP]]&0x2000) >> 12; //FIXME check MBAFF",
          "3439:         if(IS_8x8DCT(left_type[LBOT])){",
          "3440:             nnz_cache[3+8*3]=",
          "3441:             nnz_cache[3+8*4]= (h->cbp_table[left_xy[LBOT]]&0x8000) >> 12; //FIXME check MBAFF",
          "3444:         if(IS_8x8DCT(mb_type)){",
          "3445:             nnz_cache[scan8[0   ]]= nnz_cache[scan8[1   ]]=",
          "3446:             nnz_cache[scan8[2   ]]= nnz_cache[scan8[3   ]]= (h->cbp & 0x1000) >> 12;",
          "3448:             nnz_cache[scan8[0+ 4]]= nnz_cache[scan8[1+ 4]]=",
          "3449:             nnz_cache[scan8[2+ 4]]= nnz_cache[scan8[3+ 4]]= (h->cbp & 0x2000) >> 12;",
          "3451:             nnz_cache[scan8[0+ 8]]= nnz_cache[scan8[1+ 8]]=",
          "3452:             nnz_cache[scan8[2+ 8]]= nnz_cache[scan8[3+ 8]]= (h->cbp & 0x4000) >> 12;",
          "3454:             nnz_cache[scan8[0+12]]= nnz_cache[scan8[1+12]]=",
          "3455:             nnz_cache[scan8[2+12]]= nnz_cache[scan8[3+12]]= (h->cbp & 0x8000) >> 12;",
          "3462: static void loop_filter(H264Context *h, int start_x, int end_x){",
          "3463:     MpegEncContext * const s = &h->s;",
          "3464:     uint8_t  *dest_y, *dest_cb, *dest_cr;",
          "3466:     const int end_mb_y= s->mb_y + FRAME_MBAFF;",
          "3467:     const int old_slice_type= h->slice_type;",
          "3468:     const int pixel_shift = h->pixel_shift;",
          "3469:     const int block_h = 16 >> s->chroma_y_shift;",
          "3471:     if(h->deblocking_filter) {",
          "3472:         for(mb_x= start_x; mb_x<end_x; mb_x++){",
          "3473:             for(mb_y=end_mb_y - FRAME_MBAFF; mb_y<= end_mb_y; mb_y++){",
          "3475:                 mb_xy = h->mb_xy = mb_x + mb_y*s->mb_stride;",
          "3476:                 h->slice_num= h->slice_table[mb_xy];",
          "3477:                 mb_type = s->current_picture.f.mb_type[mb_xy];",
          "3478:                 h->list_count= h->list_counts[mb_xy];",
          "3480:                 if(FRAME_MBAFF)",
          "3481:                     h->mb_mbaff = h->mb_field_decoding_flag = !!IS_INTERLACED(mb_type);",
          "3483:                 s->mb_x= mb_x;",
          "3484:                 s->mb_y= mb_y;",
          "3485:                 dest_y  = s->current_picture.f.data[0] + ((mb_x << pixel_shift) + mb_y * s->linesize  ) * 16;",
          "3486:                 dest_cb = s->current_picture.f.data[1] + (mb_x << pixel_shift) * (8 << CHROMA444) + mb_y * s->uvlinesize * block_h;",
          "3487:                 dest_cr = s->current_picture.f.data[2] + (mb_x << pixel_shift) * (8 << CHROMA444) + mb_y * s->uvlinesize * block_h;",
          "3491:                     linesize   = h->mb_linesize   = s->linesize * 2;",
          "3493:                     if(mb_y&1){ //FIXME move out of this function?",
          "3494:                         dest_y -= s->linesize*15;",
          "3495:                         dest_cb-= s->uvlinesize * (block_h - 1);",
          "3496:                         dest_cr-= s->uvlinesize * (block_h - 1);",
          "3502:                 backup_mb_border(h, dest_y, dest_cb, dest_cr, linesize, uvlinesize, 0);",
          "3503:                 if(fill_filter_caches(h, mb_type))",
          "3509:                     ff_h264_filter_mb     (h, mb_x, mb_y, dest_y, dest_cb, dest_cr, linesize, uvlinesize);",
          "3511:                     ff_h264_filter_mb_fast(h, mb_x, mb_y, dest_y, dest_cb, dest_cr, linesize, uvlinesize);",
          "3514:         }",
          "3516:     h->slice_type= old_slice_type;",
          "3517:     s->mb_x= end_x;",
          "3518:     s->mb_y= end_mb_y - FRAME_MBAFF;",
          "3523: static void predict_field_decoding_flag(H264Context *h){",
          "3524:     MpegEncContext * const s = &h->s;",
          "3525:     const int mb_xy= s->mb_x + s->mb_y*s->mb_stride;",
          "3526:     int mb_type = (h->slice_table[mb_xy-1] == h->slice_num)",
          "3527:                 ? s->current_picture.f.mb_type[mb_xy - 1]",
          "3528:                 : (h->slice_table[mb_xy-s->mb_stride] == h->slice_num)",
          "3529:                 ? s->current_picture.f.mb_type[mb_xy - s->mb_stride]",
          "3530:                 : 0;",
          "3531:     h->mb_mbaff = h->mb_field_decoding_flag = IS_INTERLACED(mb_type) ? 1 : 0;",
          "3537: static void decode_finish_row(H264Context *h){",
          "3538:     MpegEncContext * const s = &h->s;",
          "3539:     int top = 16*(s->mb_y >> FIELD_PICTURE);",
          "3540:     int height = 16 << FRAME_MBAFF;",
          "3542:     int pic_height = 16*s->mb_height >> FIELD_PICTURE;",
          "3545:         if((top + height) >= pic_height)",
          "",
          "[Added Lines]",
          "3656:     if (h->deblocking_filter == 2) {",
          "3657:         if (h->slice_table[top_xy] != h->slice_num)",
          "3658:             top_type = 0;",
          "3659:         if (h->slice_table[left_xy[LBOT]] != h->slice_num)",
          "3660:             left_type[LTOP] = left_type[LBOT] = 0;",
          "3661:     } else {",
          "3662:         if (h->slice_table[top_xy] == 0xFFFF)",
          "3663:             top_type = 0;",
          "3664:         if (h->slice_table[left_xy[LBOT]] == 0xFFFF)",
          "3665:             left_type[LTOP] = left_type[LBOT] = 0;",
          "3667:     h->top_type        = top_type;",
          "3668:     h->left_type[LTOP] = left_type[LTOP];",
          "3669:     h->left_type[LBOT] = left_type[LBOT];",
          "3671:     if (IS_INTRA(mb_type))",
          "3674:     fill_filter_caches_inter(h, s, mb_type, top_xy, left_xy,",
          "3675:                              top_type, left_type, mb_xy, 0);",
          "3676:     if (h->list_count == 2)",
          "3677:         fill_filter_caches_inter(h, s, mb_type, top_xy, left_xy,",
          "3678:                                  top_type, left_type, mb_xy, 1);",
          "3680:     nnz       = h->non_zero_count[mb_xy];",
          "3682:     AV_COPY32(&nnz_cache[4 + 8 * 1], &nnz[0]);",
          "3683:     AV_COPY32(&nnz_cache[4 + 8 * 2], &nnz[4]);",
          "3684:     AV_COPY32(&nnz_cache[4 + 8 * 3], &nnz[8]);",
          "3685:     AV_COPY32(&nnz_cache[4 + 8 * 4], &nnz[12]);",
          "3686:     h->cbp = h->cbp_table[mb_xy];",
          "3688:     if (top_type) {",
          "3690:         AV_COPY32(&nnz_cache[4 + 8 * 0], &nnz[3 * 4]);",
          "3693:     if (left_type[LTOP]) {",
          "3695:         nnz_cache[3 + 8 * 1] = nnz[3 + 0 * 4];",
          "3696:         nnz_cache[3 + 8 * 2] = nnz[3 + 1 * 4];",
          "3697:         nnz_cache[3 + 8 * 3] = nnz[3 + 2 * 4];",
          "3698:         nnz_cache[3 + 8 * 4] = nnz[3 + 3 * 4];",
          "3699:     }",
          "3703:     if (!CABAC && h->pps.transform_8x8_mode) {",
          "3704:         if (IS_8x8DCT(top_type)) {",
          "3705:             nnz_cache[4 + 8 * 0]     =",
          "3706:                 nnz_cache[5 + 8 * 0] = (h->cbp_table[top_xy] & 0x4000) >> 12;",
          "3707:             nnz_cache[6 + 8 * 0]     =",
          "3708:                 nnz_cache[7 + 8 * 0] = (h->cbp_table[top_xy] & 0x8000) >> 12;",
          "3710:         if (IS_8x8DCT(left_type[LTOP])) {",
          "3711:             nnz_cache[3 + 8 * 1]     =",
          "3712:                 nnz_cache[3 + 8 * 2] = (h->cbp_table[left_xy[LTOP]] & 0x2000) >> 12; // FIXME check MBAFF",
          "3714:         if (IS_8x8DCT(left_type[LBOT])) {",
          "3715:             nnz_cache[3 + 8 * 3]     =",
          "3716:                 nnz_cache[3 + 8 * 4] = (h->cbp_table[left_xy[LBOT]] & 0x8000) >> 12; // FIXME check MBAFF",
          "3719:         if (IS_8x8DCT(mb_type)) {",
          "3720:             nnz_cache[scan8[0]] =",
          "3721:             nnz_cache[scan8[1]] =",
          "3722:             nnz_cache[scan8[2]] =",
          "3723:             nnz_cache[scan8[3]] = (h->cbp & 0x1000) >> 12;",
          "3725:             nnz_cache[scan8[0 + 4]] =",
          "3726:             nnz_cache[scan8[1 + 4]] =",
          "3727:             nnz_cache[scan8[2 + 4]] =",
          "3728:             nnz_cache[scan8[3 + 4]] = (h->cbp & 0x2000) >> 12;",
          "3730:             nnz_cache[scan8[0 + 8]] =",
          "3731:             nnz_cache[scan8[1 + 8]] =",
          "3732:             nnz_cache[scan8[2 + 8]] =",
          "3733:             nnz_cache[scan8[3 + 8]] = (h->cbp & 0x4000) >> 12;",
          "3735:             nnz_cache[scan8[0 + 12]] =",
          "3736:             nnz_cache[scan8[1 + 12]] =",
          "3737:             nnz_cache[scan8[2 + 12]] =",
          "3738:             nnz_cache[scan8[3 + 12]] = (h->cbp & 0x8000) >> 12;",
          "3745: static void loop_filter(H264Context *h, int start_x, int end_x)",
          "3746: {",
          "3747:     MpegEncContext *const s = &h->s;",
          "3748:     uint8_t *dest_y, *dest_cb, *dest_cr;",
          "3750:     const int end_mb_y       = s->mb_y + FRAME_MBAFF;",
          "3751:     const int old_slice_type = h->slice_type;",
          "3752:     const int pixel_shift    = h->pixel_shift;",
          "3753:     const int block_h        = 16 >> s->chroma_y_shift;",
          "3755:     if (h->deblocking_filter) {",
          "3756:         for (mb_x = start_x; mb_x < end_x; mb_x++)",
          "3757:             for (mb_y = end_mb_y - FRAME_MBAFF; mb_y <= end_mb_y; mb_y++) {",
          "3759:                 mb_xy         = h->mb_xy = mb_x + mb_y * s->mb_stride;",
          "3760:                 h->slice_num  = h->slice_table[mb_xy];",
          "3761:                 mb_type       = s->current_picture.f.mb_type[mb_xy];",
          "3762:                 h->list_count = h->list_counts[mb_xy];",
          "3764:                 if (FRAME_MBAFF)",
          "3765:                     h->mb_mbaff               =",
          "3766:                     h->mb_field_decoding_flag = !!IS_INTERLACED(mb_type);",
          "3768:                 s->mb_x = mb_x;",
          "3769:                 s->mb_y = mb_y;",
          "3770:                 dest_y  = s->current_picture.f.data[0] +",
          "3771:                           ((mb_x << pixel_shift) + mb_y * s->linesize) * 16;",
          "3772:                 dest_cb = s->current_picture.f.data[1] +",
          "3773:                           (mb_x << pixel_shift) * (8 << CHROMA444) +",
          "3774:                           mb_y * s->uvlinesize * block_h;",
          "3775:                 dest_cr = s->current_picture.f.data[2] +",
          "3776:                           (mb_x << pixel_shift) * (8 << CHROMA444) +",
          "3777:                           mb_y * s->uvlinesize * block_h;",
          "3781:                     linesize   = h->mb_linesize   = s->linesize   * 2;",
          "3783:                     if (mb_y & 1) { // FIXME move out of this function?",
          "3784:                         dest_y  -= s->linesize   * 15;",
          "3785:                         dest_cb -= s->uvlinesize * (block_h - 1);",
          "3786:                         dest_cr -= s->uvlinesize * (block_h - 1);",
          "3792:                 backup_mb_border(h, dest_y, dest_cb, dest_cr, linesize,",
          "3793:                                  uvlinesize, 0);",
          "3794:                 if (fill_filter_caches(h, mb_type))",
          "3800:                     ff_h264_filter_mb(h, mb_x, mb_y, dest_y, dest_cb, dest_cr,",
          "3801:                                       linesize, uvlinesize);",
          "3803:                     ff_h264_filter_mb_fast(h, mb_x, mb_y, dest_y, dest_cb,",
          "3804:                                            dest_cr, linesize, uvlinesize);",
          "3808:     h->slice_type   = old_slice_type;",
          "3809:     s->mb_x         = end_x;",
          "3810:     s->mb_y         = end_mb_y - FRAME_MBAFF;",
          "3815: static void predict_field_decoding_flag(H264Context *h)",
          "3816: {",
          "3817:     MpegEncContext *const s = &h->s;",
          "3818:     const int mb_xy = s->mb_x + s->mb_y * s->mb_stride;",
          "3819:     int mb_type     = (h->slice_table[mb_xy - 1] == h->slice_num) ?",
          "3820:                       s->current_picture.f.mb_type[mb_xy - 1] :",
          "3821:                       (h->slice_table[mb_xy - s->mb_stride] == h->slice_num) ?",
          "3822:                       s->current_picture.f.mb_type[mb_xy - s->mb_stride] : 0;",
          "3823:     h->mb_mbaff     = h->mb_field_decoding_flag = IS_INTERLACED(mb_type) ? 1 : 0;",
          "3829: static void decode_finish_row(H264Context *h)",
          "3830: {",
          "3831:     MpegEncContext *const s = &h->s;",
          "3832:     int top            = 16 * (s->mb_y      >> FIELD_PICTURE);",
          "3833:     int pic_height     = 16 *  s->mb_height >> FIELD_PICTURE;",
          "3834:     int height         =  16      << FRAME_MBAFF;",
          "3838:         if ((top + height) >= pic_height)",
          "",
          "---------------",
          "--- Hunk 55 ---",
          "[Context before]",
          "3554:     height = FFMIN(height, pic_height - top);",
          "3555:     if (top < h->emu_edge_height) {",
          "3558:     }",
          "3560:     ff_draw_horiz_band(s, top, height);",
          "3564:     ff_thread_report_progress(&s->current_picture_ptr->f, top + height - 1,",
          "3565:                               s->picture_structure == PICT_BOTTOM_FIELD);",
          "3566: }",
          "3572:     int lf_x_start = s->mb_x;",
          "3589:         ff_h264_init_cabac_states(h);",
          "3593:             int ret = ff_h264_decode_mb_cabac(h);",
          "3594:             int eos;",
          "3600:                 s->mb_y++;",
          "3602:                 ret = ff_h264_decode_mb_cabac(h);",
          "3605:                 s->mb_y--;",
          "3606:             }",
          "3612:                 return 0;",
          "3613:             }",
          "3617:                 return -1;",
          "3618:             }",
          "3621:                 loop_filter(h, lf_x_start, s->mb_x);",
          "3622:                 s->mb_x = lf_x_start = 0;",
          "3623:                 decode_finish_row(h);",
          "3624:                 ++s->mb_y;",
          "3626:                     ++s->mb_y;",
          "3628:                         predict_field_decoding_flag(h);",
          "3629:                 }",
          "3630:             }",
          "3636:                 return 0;",
          "3637:             }",
          "3638:         }",
          "3640:     } else {",
          "3642:             int ret = ff_h264_decode_mb_cavlc(h);",
          "3647:                 s->mb_y++;",
          "3648:                 ret = ff_h264_decode_mb_cavlc(h);",
          "3651:                 s->mb_y--;",
          "3652:             }",
          "3657:                 return -1;",
          "3658:             }",
          "3661:                 loop_filter(h, lf_x_start, s->mb_x);",
          "3662:                 s->mb_x = lf_x_start = 0;",
          "3663:                 decode_finish_row(h);",
          "3664:                 ++s->mb_y;",
          "3666:                     ++s->mb_y;",
          "3668:                         predict_field_decoding_flag(h);",
          "3669:                 }",
          "3673:                     if (get_bits_left(&s->gb) == 0) {",
          "3676:                         return 0;",
          "3680:                         return -1;",
          "3681:                     }",
          "3682:                 }",
          "3683:             }",
          "3687:                 if (get_bits_left(&s->gb) == 0) {",
          "3691:                     return 0;",
          "3695:                     return -1;",
          "3696:                 }",
          "",
          "[Removed Lines]",
          "3556:         height = top+height;",
          "3557:         top = 0;",
          "3562:     if (s->dropable) return;",
          "3568: static int decode_slice(struct AVCodecContext *avctx, void *arg){",
          "3569:     H264Context *h = *(void**)arg;",
          "3570:     MpegEncContext * const s = &h->s;",
          "3571:     const int part_mask= s->partitioned_frame ? (ER_AC_END|ER_AC_ERROR) : 0x7F;",
          "3574:     s->mb_skip_run= -1;",
          "3576:     h->is_complex = FRAME_MBAFF || s->picture_structure != PICT_FRAME || s->codec_id != CODEC_ID_H264 ||",
          "3577:                     (CONFIG_GRAY && (s->flags&CODEC_FLAG_GRAY));",
          "3579:     if( h->pps.cabac ) {",
          "3581:         align_get_bits( &s->gb );",
          "3584:         ff_init_cabac_states( &h->cabac);",
          "3585:         ff_init_cabac_decoder( &h->cabac,",
          "3586:                                s->gb.buffer + get_bits_count(&s->gb)/8,",
          "3587:                                (get_bits_left(&s->gb) + 7)/8);",
          "3591:         for(;;){",
          "3597:             if(ret>=0) ff_h264_hl_decode_mb(h);",
          "3599:             if( ret >= 0 && FRAME_MBAFF ) { //FIXME optimal? or let mb_decode decode 16x32 ?",
          "3604:                 if(ret>=0) ff_h264_hl_decode_mb(h);",
          "3607:             eos = get_cabac_terminate( &h->cabac );",
          "3609:             if((s->workaround_bugs & FF_BUG_TRUNCATED) && h->cabac.bytestream > h->cabac.bytestream_end + 2){",
          "3610:                 ff_er_add_slice(s, s->resync_mb_x, s->resync_mb_y, s->mb_x-1, s->mb_y, ER_MB_END&part_mask);",
          "3611:                 if (s->mb_x >= lf_x_start) loop_filter(h, lf_x_start, s->mb_x + 1);",
          "3614:             if( ret < 0 || h->cabac.bytestream > h->cabac.bytestream_end + 2) {",
          "3615:                 av_log(h->s.avctx, AV_LOG_ERROR, \"error while decoding MB %d %d, bytestream (%td)\\n\", s->mb_x, s->mb_y, h->cabac.bytestream_end - h->cabac.bytestream);",
          "3616:                 ff_er_add_slice(s, s->resync_mb_x, s->resync_mb_y, s->mb_x, s->mb_y, ER_MB_ERROR&part_mask);",
          "3620:             if( ++s->mb_x >= s->mb_width ) {",
          "3625:                 if(FIELD_OR_MBAFF_PICTURE) {",
          "3627:                     if(FRAME_MBAFF && s->mb_y < s->mb_height)",
          "3632:             if( eos || s->mb_y >= s->mb_height ) {",
          "3633:                 tprintf(s->avctx, \"slice end %d %d\\n\", get_bits_count(&s->gb), s->gb.size_in_bits);",
          "3634:                 ff_er_add_slice(s, s->resync_mb_x, s->resync_mb_y, s->mb_x-1, s->mb_y, ER_MB_END&part_mask);",
          "3635:                 if (s->mb_x > lf_x_start) loop_filter(h, lf_x_start, s->mb_x);",
          "3641:         for(;;){",
          "3644:             if(ret>=0) ff_h264_hl_decode_mb(h);",
          "3646:             if(ret>=0 && FRAME_MBAFF){ //FIXME optimal? or let mb_decode decode 16x32 ?",
          "3650:                 if(ret>=0) ff_h264_hl_decode_mb(h);",
          "3654:             if(ret<0){",
          "3655:                 av_log(h->s.avctx, AV_LOG_ERROR, \"error while decoding MB %d %d\\n\", s->mb_x, s->mb_y);",
          "3656:                 ff_er_add_slice(s, s->resync_mb_x, s->resync_mb_y, s->mb_x, s->mb_y, ER_MB_ERROR&part_mask);",
          "3660:             if(++s->mb_x >= s->mb_width){",
          "3665:                 if(FIELD_OR_MBAFF_PICTURE) {",
          "3667:                     if(FRAME_MBAFF && s->mb_y < s->mb_height)",
          "3670:                 if(s->mb_y >= s->mb_height){",
          "3671:                     tprintf(s->avctx, \"slice end %d %d\\n\", get_bits_count(&s->gb), s->gb.size_in_bits);",
          "3674:                         ff_er_add_slice(s, s->resync_mb_x, s->resync_mb_y, s->mb_x-1, s->mb_y, ER_MB_END&part_mask);",
          "3677:                     }else{",
          "3678:                         ff_er_add_slice(s, s->resync_mb_x, s->resync_mb_y, s->mb_x, s->mb_y, ER_MB_END&part_mask);",
          "3685:             if (get_bits_left(&s->gb) <= 0 && s->mb_skip_run <= 0){",
          "3686:                 tprintf(s->avctx, \"slice end %d %d\\n\", get_bits_count(&s->gb), s->gb.size_in_bits);",
          "3688:                     ff_er_add_slice(s, s->resync_mb_x, s->resync_mb_y, s->mb_x-1, s->mb_y, ER_MB_END&part_mask);",
          "3689:                     if (s->mb_x > lf_x_start) loop_filter(h, lf_x_start, s->mb_x);",
          "3692:                 }else{",
          "3693:                     ff_er_add_slice(s, s->resync_mb_x, s->resync_mb_y, s->mb_x, s->mb_y, ER_MB_ERROR&part_mask);",
          "",
          "[Added Lines]",
          "3848:         height = top + height;",
          "3849:         top    = 0;",
          "3854:     if (s->dropable)",
          "3855:         return;",
          "3861: static int decode_slice(struct AVCodecContext *avctx, void *arg)",
          "3862: {",
          "3863:     H264Context *h = *(void **)arg;",
          "3864:     MpegEncContext *const s = &h->s;",
          "3865:     const int part_mask     = s->partitioned_frame ? (ER_AC_END | ER_AC_ERROR)",
          "3866:                                                    : 0x7F;",
          "3869:     s->mb_skip_run = -1;",
          "3871:     h->is_complex = FRAME_MBAFF || s->picture_structure != PICT_FRAME ||",
          "3872:                     s->codec_id != CODEC_ID_H264 ||",
          "3873:                     (CONFIG_GRAY && (s->flags & CODEC_FLAG_GRAY));",
          "3875:     if (h->pps.cabac) {",
          "3877:         align_get_bits(&s->gb);",
          "3880:         ff_init_cabac_states(&h->cabac);",
          "3881:         ff_init_cabac_decoder(&h->cabac,",
          "3882:                               s->gb.buffer + get_bits_count(&s->gb) / 8,",
          "3883:                               (get_bits_left(&s->gb) + 7) / 8);",
          "3887:         for (;;) {",
          "3893:             if (ret >= 0)",
          "3894:                 ff_h264_hl_decode_mb(h);",
          "3897:             if (ret >= 0 && FRAME_MBAFF) {",
          "3902:                 if (ret >= 0)",
          "3903:                     ff_h264_hl_decode_mb(h);",
          "3906:             eos = get_cabac_terminate(&h->cabac);",
          "3908:             if ((s->workaround_bugs & FF_BUG_TRUNCATED) &&",
          "3909:                 h->cabac.bytestream > h->cabac.bytestream_end + 2) {",
          "3910:                 ff_er_add_slice(s, s->resync_mb_x, s->resync_mb_y, s->mb_x - 1,",
          "3911:                                 s->mb_y, ER_MB_END & part_mask);",
          "3912:                 if (s->mb_x >= lf_x_start)",
          "3913:                     loop_filter(h, lf_x_start, s->mb_x + 1);",
          "3916:             if (ret < 0 || h->cabac.bytestream > h->cabac.bytestream_end + 2) {",
          "3917:                 av_log(h->s.avctx, AV_LOG_ERROR,",
          "3918:                        \"error while decoding MB %d %d, bytestream (%td)\\n\",",
          "3919:                        s->mb_x, s->mb_y,",
          "3920:                        h->cabac.bytestream_end - h->cabac.bytestream);",
          "3921:                 ff_er_add_slice(s, s->resync_mb_x, s->resync_mb_y, s->mb_x,",
          "3922:                                 s->mb_y, ER_MB_ERROR & part_mask);",
          "3926:             if (++s->mb_x >= s->mb_width) {",
          "3931:                 if (FIELD_OR_MBAFF_PICTURE) {",
          "3933:                     if (FRAME_MBAFF && s->mb_y < s->mb_height)",
          "3938:             if (eos || s->mb_y >= s->mb_height) {",
          "3939:                 tprintf(s->avctx, \"slice end %d %d\\n\",",
          "3940:                         get_bits_count(&s->gb), s->gb.size_in_bits);",
          "3941:                 ff_er_add_slice(s, s->resync_mb_x, s->resync_mb_y, s->mb_x - 1,",
          "3942:                                 s->mb_y, ER_MB_END & part_mask);",
          "3943:                 if (s->mb_x > lf_x_start)",
          "3944:                     loop_filter(h, lf_x_start, s->mb_x);",
          "3949:         for (;;) {",
          "3952:             if (ret >= 0)",
          "3953:                 ff_h264_hl_decode_mb(h);",
          "3956:             if (ret >= 0 && FRAME_MBAFF) {",
          "3960:                 if (ret >= 0)",
          "3961:                     ff_h264_hl_decode_mb(h);",
          "3965:             if (ret < 0) {",
          "3966:                 av_log(h->s.avctx, AV_LOG_ERROR,",
          "3967:                        \"error while decoding MB %d %d\\n\", s->mb_x, s->mb_y);",
          "3968:                 ff_er_add_slice(s, s->resync_mb_x, s->resync_mb_y, s->mb_x,",
          "3969:                                 s->mb_y, ER_MB_ERROR & part_mask);",
          "3973:             if (++s->mb_x >= s->mb_width) {",
          "3978:                 if (FIELD_OR_MBAFF_PICTURE) {",
          "3980:                     if (FRAME_MBAFF && s->mb_y < s->mb_height)",
          "3983:                 if (s->mb_y >= s->mb_height) {",
          "3984:                     tprintf(s->avctx, \"slice end %d %d\\n\",",
          "3985:                             get_bits_count(&s->gb), s->gb.size_in_bits);",
          "3988:                         ff_er_add_slice(s, s->resync_mb_x, s->resync_mb_y,",
          "3989:                                         s->mb_x - 1, s->mb_y,",
          "3990:                                         ER_MB_END & part_mask);",
          "3993:                     } else {",
          "3994:                         ff_er_add_slice(s, s->resync_mb_x, s->resync_mb_y,",
          "3995:                                         s->mb_x, s->mb_y,",
          "3996:                                         ER_MB_END & part_mask);",
          "4003:             if (get_bits_left(&s->gb) <= 0 && s->mb_skip_run <= 0) {",
          "4004:                 tprintf(s->avctx, \"slice end %d %d\\n\",",
          "4005:                         get_bits_count(&s->gb), s->gb.size_in_bits);",
          "4007:                     ff_er_add_slice(s, s->resync_mb_x, s->resync_mb_y,",
          "4008:                                     s->mb_x - 1, s->mb_y,",
          "4009:                                     ER_MB_END & part_mask);",
          "4010:                     if (s->mb_x > lf_x_start)",
          "4011:                         loop_filter(h, lf_x_start, s->mb_x);",
          "4014:                 } else {",
          "4015:                     ff_er_add_slice(s, s->resync_mb_x, s->resync_mb_y, s->mb_x,",
          "4016:                                     s->mb_y, ER_MB_ERROR & part_mask);",
          "",
          "---------------",
          "--- Hunk 56 ---",
          "[Context before]",
          "3711:     H264Context *hx;",
          "3712:     int i;",
          "3715:         return 0;",
          "3717:         return decode_slice(avctx, &h);",
          "3718:     } else {",
          "3721:             hx->s.err_recognition = avctx->err_recognition;",
          "3723:         }",
          "3733:         s->picture_structure = hx->s.picture_structure;",
          "3735:             h->s.error_count += h->thread_context[i]->s.error_count;",
          "3736:     }",
          "3738:     return 0;",
          "3739: }",
          "3745:     H264Context *hx; ///< thread context",
          "3746:     int buf_index;",
          "3747:     int context_count;",
          "3748:     int next_avc;",
          "3749:     int pass = !(avctx->active_thread_type & FF_THREAD_FRAME);",
          "3751:     int nal_index;",
          "3753:     h->max_contexts = s->slice_context_count;",
          "3755:         h->current_slice = 0;",
          "3756:         if (!s->first_field)",
          "3758:         ff_h264_reset_sei(h);",
          "3759:     }",
          "3763:         context_count = 0;",
          "3789:                     break;",
          "3831:                 case NAL_SPS:",
          "3832:                 case NAL_PPS:",
          "3833:                     nals_needed = nal_index;",
          "",
          "[Removed Lines]",
          "3708: static int execute_decode_slices(H264Context *h, int context_count){",
          "3709:     MpegEncContext * const s = &h->s;",
          "3710:     AVCodecContext * const avctx= s->avctx;",
          "3714:     if (s->avctx->hwaccel || s->avctx->codec->capabilities&CODEC_CAP_HWACCEL_VDPAU)",
          "3716:     if(context_count == 1) {",
          "3719:         for(i = 1; i < context_count; i++) {",
          "3720:             hx = h->thread_context[i];",
          "3722:             hx->s.error_count = 0;",
          "3725:         avctx->execute(avctx, decode_slice,",
          "3726:                        h->thread_context, NULL, context_count, sizeof(void*));",
          "3729:         hx = h->thread_context[context_count - 1];",
          "3730:         s->mb_x = hx->s.mb_x;",
          "3731:         s->mb_y = hx->s.mb_y;",
          "3732:         s->dropable = hx->s.dropable;",
          "3734:         for(i = 1; i < context_count; i++)",
          "3742: static int decode_nal_units(H264Context *h, const uint8_t *buf, int buf_size){",
          "3743:     MpegEncContext * const s = &h->s;",
          "3744:     AVCodecContext * const avctx= s->avctx;",
          "3750:     int nals_needed=0; ///< number of NALs that need decoding before the next frame thread starts",
          "3754:     if(!(s->flags2 & CODEC_FLAG2_CHUNKS)){",
          "3757:             s->current_picture_ptr= NULL;",
          "3761:     for(;pass <= 1;pass++){",
          "3762:         buf_index = 0;",
          "3764:         next_avc = h->is_avc ? 0 : buf_size;",
          "3765:         nal_index = 0;",
          "3766:     for(;;){",
          "3767:         int consumed;",
          "3768:         int dst_length;",
          "3769:         int bit_length;",
          "3770:         const uint8_t *ptr;",
          "3771:         int i, nalsize = 0;",
          "3772:         int err;",
          "3774:         if(buf_index >= next_avc) {",
          "3775:             if (buf_index >= buf_size - h->nal_length_size) break;",
          "3776:             nalsize = 0;",
          "3777:             for(i = 0; i < h->nal_length_size; i++)",
          "3778:                 nalsize = (nalsize << 8) | buf[buf_index++];",
          "3779:             if(nalsize <= 0 || nalsize > buf_size - buf_index){",
          "3780:                 av_log(h->s.avctx, AV_LOG_ERROR, \"AVC: nal size %d\\n\", nalsize);",
          "3781:                 break;",
          "3782:             }",
          "3783:             next_avc= buf_index + nalsize;",
          "3784:         } else {",
          "3786:             for(; buf_index + 3 < next_avc; buf_index++){",
          "3788:                 if(buf[buf_index] == 0 && buf[buf_index+1] == 0 && buf[buf_index+2] == 1)",
          "3790:             }",
          "3792:             if(buf_index+3 >= buf_size) break;",
          "3794:             buf_index+=3;",
          "3795:             if(buf_index >= next_avc) continue;",
          "3796:         }",
          "3798:         hx = h->thread_context[context_count];",
          "3800:         ptr= ff_h264_decode_nal(hx, buf + buf_index, &dst_length, &consumed, next_avc - buf_index);",
          "3801:         if (ptr==NULL || dst_length < 0){",
          "3802:             return -1;",
          "3803:         }",
          "3804:         i= buf_index + consumed;",
          "3805:         if((s->workaround_bugs & FF_BUG_AUTODETECT) && i+3<next_avc &&",
          "3806:            buf[i]==0x00 && buf[i+1]==0x00 && buf[i+2]==0x01 && buf[i+3]==0xE0)",
          "3807:             s->workaround_bugs |= FF_BUG_TRUNCATED;",
          "3809:         if(!(s->workaround_bugs & FF_BUG_TRUNCATED)){",
          "3810:         while(ptr[dst_length - 1] == 0 && dst_length > 0)",
          "3811:             dst_length--;",
          "3812:         }",
          "3813:         bit_length= !dst_length ? 0 : (8*dst_length - ff_h264_decode_rbsp_trailing(h, ptr + dst_length - 1));",
          "3815:         if(s->avctx->debug&FF_DEBUG_STARTCODE){",
          "3816:             av_log(h->s.avctx, AV_LOG_DEBUG, \"NAL %d at %d/%d length %d\\n\", hx->nal_unit_type, buf_index, buf_size, dst_length);",
          "3817:         }",
          "3819:         if (h->is_avc && (nalsize != consumed) && nalsize){",
          "3820:             av_log(h->s.avctx, AV_LOG_DEBUG, \"AVC: Consumed only %d bytes instead of %d\\n\", consumed, nalsize);",
          "3821:         }",
          "3823:         buf_index += consumed;",
          "3824:         nal_index++;",
          "3826:         if(pass == 0) {",
          "3830:             switch (hx->nal_unit_type) {",
          "",
          "[Added Lines]",
          "4031: static int execute_decode_slices(H264Context *h, int context_count)",
          "4032: {",
          "4033:     MpegEncContext *const s     = &h->s;",
          "4034:     AVCodecContext *const avctx = s->avctx;",
          "4038:     if (s->avctx->hwaccel ||",
          "4039:         s->avctx->codec->capabilities & CODEC_CAP_HWACCEL_VDPAU)",
          "4041:     if (context_count == 1) {",
          "4044:         for (i = 1; i < context_count; i++) {",
          "4045:             hx                    = h->thread_context[i];",
          "4047:             hx->s.error_count     = 0;",
          "4050:         avctx->execute(avctx, decode_slice, h->thread_context,",
          "4051:                        NULL, context_count, sizeof(void *));",
          "4054:         hx                   = h->thread_context[context_count - 1];",
          "4055:         s->mb_x              = hx->s.mb_x;",
          "4056:         s->mb_y              = hx->s.mb_y;",
          "4057:         s->dropable          = hx->s.dropable;",
          "4059:         for (i = 1; i < context_count; i++)",
          "4066: static int decode_nal_units(H264Context *h, const uint8_t *buf, int buf_size)",
          "4067: {",
          "4068:     MpegEncContext *const s     = &h->s;",
          "4069:     AVCodecContext *const avctx = s->avctx;",
          "4075:     int nals_needed = 0; ///< number of NALs that need decoding before the next frame thread starts",
          "4079:     if (!(s->flags2 & CODEC_FLAG2_CHUNKS)) {",
          "4082:             s->current_picture_ptr = NULL;",
          "4086:     for (; pass <= 1; pass++) {",
          "4087:         buf_index     = 0;",
          "4089:         next_avc      = h->is_avc ? 0 : buf_size;",
          "4090:         nal_index     = 0;",
          "4091:         for (;;) {",
          "4092:             int consumed;",
          "4093:             int dst_length;",
          "4094:             int bit_length;",
          "4095:             const uint8_t *ptr;",
          "4096:             int i, nalsize = 0;",
          "4097:             int err;",
          "4099:             if (buf_index >= next_avc) {",
          "4100:                 if (buf_index >= buf_size - h->nal_length_size)",
          "4102:                 nalsize = 0;",
          "4103:                 for (i = 0; i < h->nal_length_size; i++)",
          "4104:                     nalsize = (nalsize << 8) | buf[buf_index++];",
          "4105:                 if (nalsize <= 0 || nalsize > buf_size - buf_index) {",
          "4106:                     av_log(h->s.avctx, AV_LOG_ERROR,",
          "4107:                            \"AVC: nal size %d\\n\", nalsize);",
          "4108:                     break;",
          "4109:                 }",
          "4110:                 next_avc = buf_index + nalsize;",
          "4111:             } else {",
          "4113:                 for (; buf_index + 3 < next_avc; buf_index++)",
          "4115:                     if (buf[buf_index]     == 0 &&",
          "4116:                         buf[buf_index + 1] == 0 &&",
          "4117:                         buf[buf_index + 2] == 1)",
          "4118:                         break;",
          "4120:                 if (buf_index + 3 >= buf_size)",
          "4121:                     break;",
          "4123:                 buf_index += 3;",
          "4124:                 if (buf_index >= next_avc)",
          "4125:                     continue;",
          "4126:             }",
          "4128:             hx = h->thread_context[context_count];",
          "4130:             ptr = ff_h264_decode_nal(hx, buf + buf_index, &dst_length,",
          "4131:                                      &consumed, next_avc - buf_index);",
          "4132:             if (ptr == NULL || dst_length < 0)",
          "4133:                 return -1;",
          "4134:             i = buf_index + consumed;",
          "4135:             if ((s->workaround_bugs & FF_BUG_AUTODETECT) && i + 3 < next_avc &&",
          "4136:                 buf[i]     == 0x00 && buf[i + 1] == 0x00 &&",
          "4137:                 buf[i + 2] == 0x01 && buf[i + 3] == 0xE0)",
          "4138:                 s->workaround_bugs |= FF_BUG_TRUNCATED;",
          "4140:             if (!(s->workaround_bugs & FF_BUG_TRUNCATED))",
          "4141:                 while (ptr[dst_length - 1] == 0 && dst_length > 0)",
          "4142:                     dst_length--;",
          "4143:             bit_length = !dst_length ? 0",
          "4144:                                      : (8 * dst_length -",
          "4145:                                         ff_h264_decode_rbsp_trailing(h, ptr + dst_length - 1));",
          "4147:             if (s->avctx->debug & FF_DEBUG_STARTCODE)",
          "4148:                 av_log(h->s.avctx, AV_LOG_DEBUG,",
          "4149:                        \"NAL %d at %d/%d length %d\\n\",",
          "4150:                        hx->nal_unit_type, buf_index, buf_size, dst_length);",
          "4152:             if (h->is_avc && (nalsize != consumed) && nalsize)",
          "4153:                 av_log(h->s.avctx, AV_LOG_DEBUG,",
          "4154:                        \"AVC: Consumed only %d bytes instead of %d\\n\",",
          "4155:                        consumed, nalsize);",
          "4157:             buf_index += consumed;",
          "4158:             nal_index++;",
          "4160:             if (pass == 0) {",
          "4165:                 switch (hx->nal_unit_type) {",
          "",
          "---------------",
          "--- Hunk 57 ---",
          "[Context before]",
          "3837:                     init_get_bits(&hx->s.gb, ptr, bit_length);",
          "3838:                     if (!get_ue_golomb(&hx->s.gb))",
          "3839:                         nals_needed = nal_index;",
          "3840:             }",
          "3867:                     (hx->nal_unit_type == NAL_IDR_SLICE) ||",
          "3868:                     (h->sei_recovery_frame_cnt >= 0);",
          "3888:                         return -1;",
          "3904:                 break;",
          "3961:                 }",
          "3962:             }",
          "3997:         }",
          "3998:     }",
          "4001:         execute_decode_slices(h, context_count);",
          "4002:     return buf_index;",
          "4003: }",
          "",
          "[Removed Lines]",
          "3841:             continue;",
          "3842:         }",
          "3845:         if(avctx->skip_frame >= AVDISCARD_NONREF && h->nal_ref_idc  == 0)",
          "3846:             continue;",
          "3848:       again:",
          "3849:         err = 0;",
          "3850:         switch(hx->nal_unit_type){",
          "3851:         case NAL_IDR_SLICE:",
          "3852:             if (h->nal_unit_type != NAL_IDR_SLICE) {",
          "3853:                 av_log(h->s.avctx, AV_LOG_ERROR, \"Invalid mix of idr and non-idr slices\");",
          "3854:                 return -1;",
          "3855:             }",
          "3856:             idr(h); // FIXME ensure we don't lose some frames if there is reordering",
          "3857:         case NAL_SLICE:",
          "3858:             init_get_bits(&hx->s.gb, ptr, bit_length);",
          "3859:             hx->intra_gb_ptr=",
          "3860:             hx->inter_gb_ptr= &hx->s.gb;",
          "3861:             hx->s.data_partitioning = 0;",
          "3863:             if((err = decode_slice_header(hx, h)))",
          "3864:                break;",
          "3866:             s->current_picture_ptr->f.key_frame |=",
          "3870:             if (h->current_slice == 1) {",
          "3871:                 if(!(s->flags2 & CODEC_FLAG2_CHUNKS)) {",
          "3872:                     decode_postinit(h, nal_index >= nals_needed);",
          "3873:                 }",
          "3875:                 if (s->avctx->hwaccel && s->avctx->hwaccel->start_frame(s->avctx, NULL, 0) < 0)",
          "3876:                     return -1;",
          "3877:                 if(CONFIG_H264_VDPAU_DECODER && s->avctx->codec->capabilities&CODEC_CAP_HWACCEL_VDPAU)",
          "3878:                     ff_vdpau_h264_picture_start(s);",
          "3879:             }",
          "3881:             if(hx->redundant_pic_count==0",
          "3882:                && (avctx->skip_frame < AVDISCARD_NONREF || hx->nal_ref_idc)",
          "3883:                && (avctx->skip_frame < AVDISCARD_BIDIR  || hx->slice_type_nos!=AV_PICTURE_TYPE_B)",
          "3884:                && (avctx->skip_frame < AVDISCARD_NONKEY || hx->slice_type_nos==AV_PICTURE_TYPE_I)",
          "3885:                && avctx->skip_frame < AVDISCARD_ALL){",
          "3886:                 if(avctx->hwaccel) {",
          "3887:                     if (avctx->hwaccel->decode_slice(avctx, &buf[buf_index - consumed], consumed) < 0)",
          "3889:                 }else",
          "3890:                 if(CONFIG_H264_VDPAU_DECODER && s->avctx->codec->capabilities&CODEC_CAP_HWACCEL_VDPAU){",
          "3891:                     static const uint8_t start_code[] = {0x00, 0x00, 0x01};",
          "3892:                     ff_vdpau_add_data_chunk(s, start_code, sizeof(start_code));",
          "3893:                     ff_vdpau_add_data_chunk(s, &buf[buf_index - consumed], consumed );",
          "3894:                 }else",
          "3895:                     context_count++;",
          "3896:             }",
          "3897:             break;",
          "3898:         case NAL_DPA:",
          "3899:             init_get_bits(&hx->s.gb, ptr, bit_length);",
          "3900:             hx->intra_gb_ptr=",
          "3901:             hx->inter_gb_ptr= NULL;",
          "3903:             if ((err = decode_slice_header(hx, h)) < 0)",
          "3906:             hx->s.data_partitioning = 1;",
          "3908:             break;",
          "3909:         case NAL_DPB:",
          "3910:             init_get_bits(&hx->intra_gb, ptr, bit_length);",
          "3911:             hx->intra_gb_ptr= &hx->intra_gb;",
          "3912:             break;",
          "3913:         case NAL_DPC:",
          "3914:             init_get_bits(&hx->inter_gb, ptr, bit_length);",
          "3915:             hx->inter_gb_ptr= &hx->inter_gb;",
          "3917:             if(hx->redundant_pic_count==0 && hx->intra_gb_ptr && hx->s.data_partitioning",
          "3918:                && s->context_initialized",
          "3919:                && (avctx->skip_frame < AVDISCARD_NONREF || hx->nal_ref_idc)",
          "3920:                && (avctx->skip_frame < AVDISCARD_BIDIR  || hx->slice_type_nos!=AV_PICTURE_TYPE_B)",
          "3921:                && (avctx->skip_frame < AVDISCARD_NONKEY || hx->slice_type_nos==AV_PICTURE_TYPE_I)",
          "3922:                && avctx->skip_frame < AVDISCARD_ALL)",
          "3923:                 context_count++;",
          "3924:             break;",
          "3925:         case NAL_SEI:",
          "3926:             init_get_bits(&s->gb, ptr, bit_length);",
          "3927:             ff_h264_decode_sei(h);",
          "3928:             break;",
          "3929:         case NAL_SPS:",
          "3930:             init_get_bits(&s->gb, ptr, bit_length);",
          "3931:             if (ff_h264_decode_seq_parameter_set(h) < 0 &&",
          "3932:                 h->is_avc && (nalsize != consumed) && nalsize) {",
          "3933:                 av_log(h->s.avctx, AV_LOG_DEBUG, \"SPS decoding failure, \"",
          "3934:                        \"try parsing the coomplete NAL\\n\");",
          "3935:                 init_get_bits(&s->gb, buf + buf_index + 1 - consumed,",
          "3936:                               8 * (nalsize - 1));",
          "3937:                 ff_h264_decode_seq_parameter_set(h);",
          "3938:             }",
          "3940:             if (s->flags& CODEC_FLAG_LOW_DELAY ||",
          "3941:                 (h->sps.bitstream_restriction_flag && !h->sps.num_reorder_frames))",
          "3942:                 s->low_delay=1;",
          "3944:             if(avctx->has_b_frames < 2)",
          "3945:                 avctx->has_b_frames= !s->low_delay;",
          "3947:             if (avctx->bits_per_raw_sample != h->sps.bit_depth_luma ||",
          "3948:                 h->cur_chroma_format_idc != h->sps.chroma_format_idc) {",
          "3949:                 if (h->sps.bit_depth_luma >= 8 && h->sps.bit_depth_luma <= 10) {",
          "3950:                     avctx->bits_per_raw_sample = h->sps.bit_depth_luma;",
          "3951:                     h->cur_chroma_format_idc = h->sps.chroma_format_idc;",
          "3952:                     h->pixel_shift = h->sps.bit_depth_luma > 8;",
          "3954:                     ff_h264dsp_init(&h->h264dsp, h->sps.bit_depth_luma, h->sps.chroma_format_idc);",
          "3955:                     ff_h264_pred_init(&h->hpc, s->codec_id, h->sps.bit_depth_luma, h->sps.chroma_format_idc);",
          "3956:                     s->dsp.dct_bits = h->sps.bit_depth_luma > 8 ? 32 : 16;",
          "3957:                     ff_dsputil_init(&s->dsp, s->avctx);",
          "3958:                 } else {",
          "3959:                     av_log(avctx, AV_LOG_ERROR, \"Unsupported bit depth: %d\\n\", h->sps.bit_depth_luma);",
          "3960:                     return -1;",
          "3963:             break;",
          "3964:         case NAL_PPS:",
          "3965:             init_get_bits(&s->gb, ptr, bit_length);",
          "3967:             ff_h264_decode_picture_parameter_set(h, bit_length);",
          "3969:             break;",
          "3970:         case NAL_AUD:",
          "3971:         case NAL_END_SEQUENCE:",
          "3972:         case NAL_END_STREAM:",
          "3973:         case NAL_FILLER_DATA:",
          "3974:         case NAL_SPS_EXT:",
          "3975:         case NAL_AUXILIARY_SLICE:",
          "3976:             break;",
          "3977:         default:",
          "3978:             av_log(avctx, AV_LOG_DEBUG, \"Unknown NAL code: %d (%d bits)\\n\", hx->nal_unit_type, bit_length);",
          "3979:         }",
          "3981:         if(context_count == h->max_contexts) {",
          "3982:             execute_decode_slices(h, context_count);",
          "3983:             context_count = 0;",
          "3984:         }",
          "3986:         if (err < 0)",
          "3987:             av_log(h->s.avctx, AV_LOG_ERROR, \"decode_slice_header error\\n\");",
          "3988:         else if(err == 1) {",
          "3993:             h->nal_unit_type = hx->nal_unit_type;",
          "3994:             h->nal_ref_idc   = hx->nal_ref_idc;",
          "3995:             hx = h;",
          "3996:             goto again;",
          "3999:     }",
          "4000:     if(context_count)",
          "",
          "[Added Lines]",
          "4175:                 }",
          "4176:                 continue;",
          "4180:             if (avctx->skip_frame >= AVDISCARD_NONREF && h->nal_ref_idc == 0)",
          "4181:                 continue;",
          "4183: again:",
          "4184:             err = 0;",
          "4185:             switch (hx->nal_unit_type) {",
          "4186:             case NAL_IDR_SLICE:",
          "4187:                 if (h->nal_unit_type != NAL_IDR_SLICE) {",
          "4188:                     av_log(h->s.avctx, AV_LOG_ERROR,",
          "4189:                            \"Invalid mix of idr and non-idr slices\");",
          "4190:                     return -1;",
          "4191:                 }",
          "4192:                 idr(h); // FIXME ensure we don't lose some frames if there is reordering",
          "4193:             case NAL_SLICE:",
          "4194:                 init_get_bits(&hx->s.gb, ptr, bit_length);",
          "4195:                 hx->intra_gb_ptr        =",
          "4196:                     hx->inter_gb_ptr    = &hx->s.gb;",
          "4197:                 hx->s.data_partitioning = 0;",
          "4199:                 if ((err = decode_slice_header(hx, h)))",
          "4200:                     break;",
          "4202:                 s->current_picture_ptr->f.key_frame |=",
          "4206:                 if (h->current_slice == 1) {",
          "4207:                     if (!(s->flags2 & CODEC_FLAG2_CHUNKS))",
          "4208:                         decode_postinit(h, nal_index >= nals_needed);",
          "4210:                     if (s->avctx->hwaccel &&",
          "4211:                         s->avctx->hwaccel->start_frame(s->avctx, NULL, 0) < 0)",
          "4213:                     if (CONFIG_H264_VDPAU_DECODER &&",
          "4214:                         s->avctx->codec->capabilities & CODEC_CAP_HWACCEL_VDPAU)",
          "4215:                         ff_vdpau_h264_picture_start(s);",
          "4216:                 }",
          "4218:                 if (hx->redundant_pic_count == 0 &&",
          "4219:                     (avctx->skip_frame < AVDISCARD_NONREF ||",
          "4220:                      hx->nal_ref_idc) &&",
          "4221:                     (avctx->skip_frame < AVDISCARD_BIDIR  ||",
          "4222:                      hx->slice_type_nos != AV_PICTURE_TYPE_B) &&",
          "4223:                     (avctx->skip_frame < AVDISCARD_NONKEY ||",
          "4224:                      hx->slice_type_nos == AV_PICTURE_TYPE_I) &&",
          "4225:                     avctx->skip_frame < AVDISCARD_ALL) {",
          "4226:                     if (avctx->hwaccel) {",
          "4227:                         if (avctx->hwaccel->decode_slice(avctx,",
          "4228:                                                          &buf[buf_index - consumed],",
          "4229:                                                          consumed) < 0)",
          "4230:                             return -1;",
          "4231:                     } else if (CONFIG_H264_VDPAU_DECODER &&",
          "4232:                                s->avctx->codec->capabilities & CODEC_CAP_HWACCEL_VDPAU) {",
          "4233:                         static const uint8_t start_code[] = {",
          "4234:                             0x00, 0x00, 0x01 };",
          "4235:                         ff_vdpau_add_data_chunk(s, start_code,",
          "4236:                                                 sizeof(start_code));",
          "4237:                         ff_vdpau_add_data_chunk(s, &buf[buf_index - consumed],",
          "4238:                                                 consumed);",
          "4239:                     } else",
          "4240:                         context_count++;",
          "4241:                 }",
          "4243:             case NAL_DPA:",
          "4244:                 init_get_bits(&hx->s.gb, ptr, bit_length);",
          "4245:                 hx->intra_gb_ptr =",
          "4246:                 hx->inter_gb_ptr = NULL;",
          "4248:                 if ((err = decode_slice_header(hx, h)) < 0)",
          "4249:                     break;",
          "4251:                 hx->s.data_partitioning = 1;",
          "4252:                 break;",
          "4253:             case NAL_DPB:",
          "4254:                 init_get_bits(&hx->intra_gb, ptr, bit_length);",
          "4255:                 hx->intra_gb_ptr = &hx->intra_gb;",
          "4256:                 break;",
          "4257:             case NAL_DPC:",
          "4258:                 init_get_bits(&hx->inter_gb, ptr, bit_length);",
          "4259:                 hx->inter_gb_ptr = &hx->inter_gb;",
          "4261:                 if (hx->redundant_pic_count == 0 &&",
          "4262:                     hx->intra_gb_ptr &&",
          "4263:                     hx->s.data_partitioning &&",
          "4264:                     s->context_initialized &&",
          "4265:                     (avctx->skip_frame < AVDISCARD_NONREF || hx->nal_ref_idc) &&",
          "4266:                     (avctx->skip_frame < AVDISCARD_BIDIR  ||",
          "4267:                      hx->slice_type_nos != AV_PICTURE_TYPE_B) &&",
          "4268:                     (avctx->skip_frame < AVDISCARD_NONKEY ||",
          "4269:                      hx->slice_type_nos == AV_PICTURE_TYPE_I) &&",
          "4270:                     avctx->skip_frame < AVDISCARD_ALL)",
          "4271:                     context_count++;",
          "4272:                 break;",
          "4273:             case NAL_SEI:",
          "4274:                 init_get_bits(&s->gb, ptr, bit_length);",
          "4275:                 ff_h264_decode_sei(h);",
          "4276:                 break;",
          "4277:             case NAL_SPS:",
          "4278:                 init_get_bits(&s->gb, ptr, bit_length);",
          "4279:                 if (ff_h264_decode_seq_parameter_set(h) < 0 &&",
          "4280:                     h->is_avc && (nalsize != consumed) && nalsize) {",
          "4281:                     av_log(h->s.avctx, AV_LOG_DEBUG,",
          "4282:                            \"SPS decoding failure, try parsing the coomplete NAL\\n\");",
          "4283:                     init_get_bits(&s->gb, buf + buf_index + 1 - consumed,",
          "4284:                                   8 * (nalsize - 1));",
          "4285:                     ff_h264_decode_seq_parameter_set(h);",
          "4286:                 }",
          "4288:                 if (s->flags & CODEC_FLAG_LOW_DELAY ||",
          "4289:                     (h->sps.bitstream_restriction_flag &&",
          "4290:                      !h->sps.num_reorder_frames))",
          "4291:                     s->low_delay = 1;",
          "4293:                 if (avctx->has_b_frames < 2)",
          "4294:                     avctx->has_b_frames = !s->low_delay;",
          "4296:                 if (avctx->bits_per_raw_sample != h->sps.bit_depth_luma ||",
          "4297:                     h->cur_chroma_format_idc   != h->sps.chroma_format_idc) {",
          "4298:                     if (h->sps.bit_depth_luma >= 8 && h->sps.bit_depth_luma <= 10) {",
          "4299:                         avctx->bits_per_raw_sample = h->sps.bit_depth_luma;",
          "4300:                         h->cur_chroma_format_idc   = h->sps.chroma_format_idc;",
          "4301:                         h->pixel_shift             = h->sps.bit_depth_luma > 8;",
          "4303:                         ff_h264dsp_init(&h->h264dsp, h->sps.bit_depth_luma,",
          "4304:                                         h->sps.chroma_format_idc);",
          "4305:                         ff_h264_pred_init(&h->hpc, s->codec_id,",
          "4306:                                           h->sps.bit_depth_luma,",
          "4307:                                           h->sps.chroma_format_idc);",
          "4308:                         s->dsp.dct_bits = h->sps.bit_depth_luma > 8 ? 32 : 16;",
          "4309:                         ff_dsputil_init(&s->dsp, s->avctx);",
          "4310:                     } else {",
          "4311:                         av_log(avctx, AV_LOG_ERROR,",
          "4312:                                \"Unsupported bit depth: %d\\n\",",
          "4313:                                h->sps.bit_depth_luma);",
          "4314:                         return -1;",
          "4315:                     }",
          "4317:                 break;",
          "4318:             case NAL_PPS:",
          "4319:                 init_get_bits(&s->gb, ptr, bit_length);",
          "4320:                 ff_h264_decode_picture_parameter_set(h, bit_length);",
          "4321:                 break;",
          "4322:             case NAL_AUD:",
          "4323:             case NAL_END_SEQUENCE:",
          "4324:             case NAL_END_STREAM:",
          "4325:             case NAL_FILLER_DATA:",
          "4326:             case NAL_SPS_EXT:",
          "4327:             case NAL_AUXILIARY_SLICE:",
          "4328:                 break;",
          "4329:             default:",
          "4330:                 av_log(avctx, AV_LOG_DEBUG, \"Unknown NAL code: %d (%d bits)\\n\",",
          "4331:                        hx->nal_unit_type, bit_length);",
          "4334:             if (context_count == h->max_contexts) {",
          "4335:                 execute_decode_slices(h, context_count);",
          "4336:                 context_count = 0;",
          "4337:             }",
          "4339:             if (err < 0)",
          "4340:                 av_log(h->s.avctx, AV_LOG_ERROR, \"decode_slice_header error\\n\");",
          "4341:             else if (err == 1) {",
          "4346:                 h->nal_unit_type = hx->nal_unit_type;",
          "4347:                 h->nal_ref_idc   = hx->nal_ref_idc;",
          "4348:                 hx               = h;",
          "4349:                 goto again;",
          "4350:             }",
          "4353:     if (context_count)",
          "",
          "---------------",
          "--- Hunk 58 ---",
          "[Context before]",
          "4013: }",
          "4018: {",
          "4019:     const uint8_t *buf = avpkt->data;",
          "4031:     if (buf_size == 0) {",
          "4032:         Picture *out;",
          "4033:         int i, out_idx;",
          "4035:         s->current_picture_ptr = NULL;",
          "4039:         out_idx = 0;",
          "4043:                 out_idx = i;",
          "4044:             }",
          "4052:         }",
          "",
          "[Removed Lines]",
          "4008: static int get_consumed_bytes(MpegEncContext *s, int pos, int buf_size){",
          "4009:         if(pos==0) pos=1; //avoid infinite loops (i doubt that is needed but ...)",
          "4010:         if(pos+10>buf_size) pos=buf_size; // oops ;)",
          "4012:         return pos;",
          "4015: static int decode_frame(AVCodecContext *avctx,",
          "4016:                              void *data, int *data_size,",
          "4017:                              AVPacket *avpkt)",
          "4020:     int buf_size = avpkt->size;",
          "4021:     H264Context *h = avctx->priv_data;",
          "4022:     MpegEncContext *s = &h->s;",
          "4023:     AVFrame *pict = data;",
          "4024:     int buf_index = 0;",
          "4026:     s->flags= avctx->flags;",
          "4027:     s->flags2= avctx->flags2;",
          "4030:  out:",
          "4038:         out = h->delayed_pic[0];",
          "4040:         for (i = 1; h->delayed_pic[i] && !h->delayed_pic[i]->f.key_frame && !h->delayed_pic[i]->mmco_reset; i++)",
          "4041:             if(h->delayed_pic[i]->poc < out->poc){",
          "4042:                 out = h->delayed_pic[i];",
          "4046:         for(i=out_idx; h->delayed_pic[i]; i++)",
          "4047:             h->delayed_pic[i] = h->delayed_pic[i+1];",
          "4049:         if(out){",
          "",
          "[Added Lines]",
          "4361: static int get_consumed_bytes(MpegEncContext *s, int pos, int buf_size)",
          "4362: {",
          "4363:     if (pos == 0)",
          "4364:         pos = 1;          // avoid infinite loops (i doubt that is needed but ...)",
          "4365:     if (pos + 10 > buf_size)",
          "4366:         pos = buf_size;                   // oops ;)",
          "4368:     return pos;",
          "4371: static int decode_frame(AVCodecContext *avctx, void *data,",
          "4372:                         int *data_size, AVPacket *avpkt)",
          "4375:     int buf_size       = avpkt->size;",
          "4376:     H264Context *h     = avctx->priv_data;",
          "4377:     MpegEncContext *s  = &h->s;",
          "4378:     AVFrame *pict      = data;",
          "4379:     int buf_index      = 0;",
          "4381:     s->flags  = avctx->flags;",
          "4382:     s->flags2 = avctx->flags2;",
          "4385: out:",
          "4393:         out     = h->delayed_pic[0];",
          "4395:         for (i = 1;",
          "4396:              h->delayed_pic[i] &&",
          "4397:              !h->delayed_pic[i]->f.key_frame &&",
          "4398:              !h->delayed_pic[i]->mmco_reset;",
          "4399:              i++)",
          "4400:             if (h->delayed_pic[i]->poc < out->poc) {",
          "4401:                 out     = h->delayed_pic[i];",
          "4405:         for (i = out_idx; h->delayed_pic[i]; i++)",
          "4406:             h->delayed_pic[i] = h->delayed_pic[i + 1];",
          "4408:         if (out) {",
          "",
          "---------------",
          "--- Hunk 59 ---",
          "[Context before]",
          "4054:         return buf_index;",
          "4055:     }",
          "4059:         return -1;",
          "4061:     if (!s->current_picture_ptr && h->nal_unit_type == NAL_END_SEQUENCE) {",
          "",
          "[Removed Lines]",
          "4057:     buf_index=decode_nal_units(h, buf, buf_size);",
          "4058:     if(buf_index < 0)",
          "",
          "[Added Lines]",
          "4416:     buf_index = decode_nal_units(h, buf, buf_size);",
          "4417:     if (buf_index < 0)",
          "",
          "---------------",
          "--- Hunk 60 ---",
          "[Context before]",
          "4063:         goto out;",
          "4064:     }",
          "4067:         if (avctx->skip_frame >= AVDISCARD_NONREF)",
          "4068:             return 0;",
          "4069:         av_log(avctx, AV_LOG_ERROR, \"no frame!\\n\");",
          "4070:         return -1;",
          "4071:     }",
          "4077:         field_end(h, 0);",
          "4079:         if (!h->next_output_pic) {",
          "4083:         } else {",
          "",
          "[Removed Lines]",
          "4066:     if(!(s->flags2 & CODEC_FLAG2_CHUNKS) && !s->current_picture_ptr){",
          "4073:     if(!(s->flags2 & CODEC_FLAG2_CHUNKS) || (s->mb_y >= s->mb_height && s->mb_height)){",
          "4075:         if(s->flags2 & CODEC_FLAG2_CHUNKS) decode_postinit(h, 1);",
          "",
          "[Added Lines]",
          "4425:     if (!(s->flags2 & CODEC_FLAG2_CHUNKS) && !s->current_picture_ptr) {",
          "4432:     if (!(s->flags2 & CODEC_FLAG2_CHUNKS) ||",
          "4433:         (s->mb_y >= s->mb_height && s->mb_height)) {",
          "4434:         if (s->flags2 & CODEC_FLAG2_CHUNKS)",
          "4435:             decode_postinit(h, 1);",
          "",
          "---------------",
          "--- Hunk 61 ---",
          "[Context before]",
          "4089:     assert(pict->data[0] || !*data_size);",
          "4090:     ff_print_debug_info(s, pict);",
          "4093:     return get_consumed_bytes(s, buf_index, buf_size);",
          "4094: }",
          "4115: av_cold void ff_h264_free_context(H264Context *h)",
          "4116: {",
          "4117:     int i;",
          "4122:         av_freep(h->sps_buffers + i);",
          "4125:         av_freep(h->pps_buffers + i);",
          "4126: }",
          "4128: av_cold int ff_h264_decode_end(AVCodecContext *avctx)",
          "4129: {",
          "4131:     MpegEncContext *s = &h->s;",
          "4133:     ff_h264_free_context(h);",
          "4135:     ff_MPV_common_end(s);",
          "4139:     return 0;",
          "4140: }",
          "",
          "[Removed Lines]",
          "4095: #if 0",
          "4096: static inline void fill_mb_avail(H264Context *h){",
          "4097:     MpegEncContext * const s = &h->s;",
          "4098:     const int mb_xy= s->mb_x + s->mb_y*s->mb_stride;",
          "4100:     if(s->mb_y){",
          "4101:         h->mb_avail[0]= s->mb_x                 && h->slice_table[mb_xy - s->mb_stride - 1] == h->slice_num;",
          "4102:         h->mb_avail[1]=                            h->slice_table[mb_xy - s->mb_stride    ] == h->slice_num;",
          "4103:         h->mb_avail[2]= s->mb_x+1 < s->mb_width && h->slice_table[mb_xy - s->mb_stride + 1] == h->slice_num;",
          "4104:     }else{",
          "4105:         h->mb_avail[0]=",
          "4106:         h->mb_avail[1]=",
          "4107:         h->mb_avail[2]= 0;",
          "4108:     }",
          "4109:     h->mb_avail[3]= s->mb_x && h->slice_table[mb_xy - 1] == h->slice_num;",
          "4110:     h->mb_avail[4]= 1; //FIXME move out",
          "4111:     h->mb_avail[5]= 0; //FIXME move out",
          "4112: }",
          "4113: #endif",
          "4119:     free_tables(h, 1); //FIXME cleanup init stuff perhaps",
          "4121:     for(i = 0; i < MAX_SPS_COUNT; i++)",
          "4124:     for(i = 0; i < MAX_PPS_COUNT; i++)",
          "4130:     H264Context *h = avctx->priv_data;",
          "",
          "[Added Lines]",
          "4459:     free_tables(h, 1); // FIXME cleanup init stuff perhaps",
          "4461:     for (i = 0; i < MAX_SPS_COUNT; i++)",
          "4464:     for (i = 0; i < MAX_PPS_COUNT; i++)",
          "4470:     H264Context *h    = avctx->priv_data;",
          "",
          "---------------",
          "--- Hunk 62 ---",
          "[Context before]",
          "4157: };",
          "4159: AVCodec ff_h264_decoder = {",
          "4171:     .init_thread_copy      = ONLY_IF_THREADS_ENABLED(decode_init_thread_copy),",
          "4172:     .update_thread_context = ONLY_IF_THREADS_ENABLED(decode_update_thread_context),",
          "4174: };",
          "4176: #if CONFIG_H264_VDPAU_DECODER",
          "",
          "[Removed Lines]",
          "4160:     .name           = \"h264\",",
          "4161:     .type           = AVMEDIA_TYPE_VIDEO,",
          "4162:     .id             = CODEC_ID_H264,",
          "4163:     .priv_data_size = sizeof(H264Context),",
          "4164:     .init           = ff_h264_decode_init,",
          "4165:     .close          = ff_h264_decode_end,",
          "4166:     .decode         = decode_frame,",
          "4167:     .capabilities   = /*CODEC_CAP_DRAW_HORIZ_BAND |*/ CODEC_CAP_DR1 | CODEC_CAP_DELAY |",
          "4168:                       CODEC_CAP_SLICE_THREADS | CODEC_CAP_FRAME_THREADS,",
          "4169:     .flush= flush_dpb,",
          "4170:     .long_name = NULL_IF_CONFIG_SMALL(\"H.264 / AVC / MPEG-4 AVC / MPEG-4 part 10\"),",
          "4173:     .profiles = NULL_IF_CONFIG_SMALL(profiles),",
          "",
          "[Added Lines]",
          "4500:     .name                  = \"h264\",",
          "4501:     .type                  = AVMEDIA_TYPE_VIDEO,",
          "4502:     .id                    = CODEC_ID_H264,",
          "4503:     .priv_data_size        = sizeof(H264Context),",
          "4504:     .init                  = ff_h264_decode_init,",
          "4505:     .close                 = ff_h264_decode_end,",
          "4506:     .decode                = decode_frame,",
          "4507:     .capabilities          = /*CODEC_CAP_DRAW_HORIZ_BAND |*/ CODEC_CAP_DR1 |",
          "4508:                              CODEC_CAP_DELAY | CODEC_CAP_SLICE_THREADS |",
          "4509:                              CODEC_CAP_FRAME_THREADS,",
          "4510:     .flush                 = flush_dpb,",
          "4511:     .long_name             = NULL_IF_CONFIG_SMALL(\"H.264 / AVC / MPEG-4 AVC / MPEG-4 part 10\"),",
          "4514:     .profiles              = NULL_IF_CONFIG_SMALL(profiles),",
          "",
          "---------------",
          "--- Hunk 63 ---",
          "[Context before]",
          "4183:     .close          = ff_h264_decode_end,",
          "4184:     .decode         = decode_frame,",
          "4185:     .capabilities   = CODEC_CAP_DR1 | CODEC_CAP_DELAY | CODEC_CAP_HWACCEL_VDPAU,",
          "4190: };",
          "4191: #endif",
          "",
          "[Removed Lines]",
          "4186:     .flush= flush_dpb,",
          "4187:     .long_name = NULL_IF_CONFIG_SMALL(\"H.264 / AVC / MPEG-4 AVC / MPEG-4 part 10 (VDPAU acceleration)\"),",
          "4188:     .pix_fmts = (const enum PixelFormat[]){PIX_FMT_VDPAU_H264, PIX_FMT_NONE},",
          "4189:     .profiles = NULL_IF_CONFIG_SMALL(profiles),",
          "",
          "[Added Lines]",
          "4527:     .flush          = flush_dpb,",
          "4528:     .long_name      = NULL_IF_CONFIG_SMALL(\"H.264 / AVC / MPEG-4 AVC / MPEG-4 part 10 (VDPAU acceleration)\"),",
          "4529:     .pix_fmts       = (const enum PixelFormat[]) { PIX_FMT_VDPAU_H264,",
          "4530:                                                    PIX_FMT_NONE},",
          "4531:     .profiles       = NULL_IF_CONFIG_SMALL(profiles),",
          "",
          "---------------"
        ]
      }
    }
  ]
}
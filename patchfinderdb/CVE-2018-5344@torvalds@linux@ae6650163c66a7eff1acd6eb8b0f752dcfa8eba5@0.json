{
  "cve_id": "CVE-2018-5344",
  "cve_desc": "In the Linux kernel through 4.14.13, drivers/block/loop.c mishandles lo_release serialization, which allows attackers to cause a denial of service (__lock_acquire use-after-free) or possibly have unspecified other impact.",
  "repo": "torvalds/linux",
  "patch_hash": "ae6650163c66a7eff1acd6eb8b0f752dcfa8eba5",
  "patch_info": {
    "commit_hash": "ae6650163c66a7eff1acd6eb8b0f752dcfa8eba5",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/ae6650163c66a7eff1acd6eb8b0f752dcfa8eba5",
    "files": [
      "drivers/block/loop.c"
    ],
    "message": "loop: fix concurrent lo_open/lo_release\n\n\u8303\u9f99\u98de reports that KASAN can report a use-after-free in __lock_acquire.\nThe reason is due to insufficient serialization in lo_release(), which\nwill continue to use the loop device even after it has decremented the\nlo_refcnt to zero.\n\nIn the meantime, another process can come in, open the loop device\nagain as it is being shut down. Confusion ensues.\n\nReported-by: \u8303\u9f99\u98de <long7573@126.com>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>\nSigned-off-by: Jens Axboe <axboe@kernel.dk>",
    "before_after_code_files": [
      "drivers/block/loop.c||drivers/block/loop.c"
    ]
  },
  "patch_diff": {
    "drivers/block/loop.c||drivers/block/loop.c": [
      "File: drivers/block/loop.c -> drivers/block/loop.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "1581:  return err;",
      "1582: }",
      "1585: {",
      "1587:  int err;",
      "1589:  if (atomic_dec_return(&lo->lo_refcnt))",
      "",
      "[Removed Lines]",
      "1584: static void lo_release(struct gendisk *disk, fmode_t mode)",
      "1586:  struct loop_device *lo = disk->private_data;",
      "",
      "[Added Lines]",
      "1584: static void __lo_release(struct loop_device *lo)",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "1610:  mutex_unlock(&lo->lo_ctl_mutex);",
      "1611: }",
      "1613: static const struct block_device_operations lo_fops = {",
      "1614:  .owner = THIS_MODULE,",
      "1615:  .open =  lo_open,",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1612: static void lo_release(struct gendisk *disk, fmode_t mode)",
      "1613: {",
      "1614:  mutex_lock(&loop_index_mutex);",
      "1615:  __lo_release(disk->private_data);",
      "1616:  mutex_unlock(&loop_index_mutex);",
      "1617: }",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "967d1dc144b50ad005e5eecdfadfbcfb399ffff6",
      "candidate_info": {
        "commit_hash": "967d1dc144b50ad005e5eecdfadfbcfb399ffff6",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/967d1dc144b50ad005e5eecdfadfbcfb399ffff6",
        "files": [
          "drivers/block/loop.c"
        ],
        "message": "loop: Fold __loop_release into loop_release\n\n__loop_release() has a single call site. Fold it there. This is\ncurrently not a huge win but it will make following replacement of\nloop_index_mutex more obvious.\n\nSigned-off-by: Jan Kara <jack@suse.cz>\nSigned-off-by: Jens Axboe <axboe@kernel.dk>",
        "before_after_code_files": [
          "drivers/block/loop.c||drivers/block/loop.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "drivers/block/loop.c||drivers/block/loop.c"
          ],
          "candidate": [
            "drivers/block/loop.c||drivers/block/loop.c"
          ]
        }
      },
      "candidate_diff": {
        "drivers/block/loop.c||drivers/block/loop.c": [
          "File: drivers/block/loop.c -> drivers/block/loop.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1641:  return err;",
          "1642: }",
          "1645: {",
          "1646:  int err;",
          "1648:  if (atomic_dec_return(&lo->lo_refcnt))",
          "1651:  mutex_lock(&loop_ctl_mutex);",
          "1652:  if (lo->lo_flags & LO_FLAGS_AUTOCLEAR) {",
          "",
          "[Removed Lines]",
          "1644: static void __lo_release(struct loop_device *lo)",
          "1649:   return;",
          "",
          "[Added Lines]",
          "1644: static void lo_release(struct gendisk *disk, fmode_t mode)",
          "1646:  struct loop_device *lo;",
          "1649:  mutex_lock(&loop_index_mutex);",
          "1650:  lo = disk->private_data;",
          "1652:   goto unlock_index;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1657:   err = loop_clr_fd(lo);",
          "1658:   if (!err)",
          "1660:  } else if (lo->lo_state == Lo_bound) {",
          "",
          "[Removed Lines]",
          "1659:    return;",
          "",
          "[Added Lines]",
          "1662:    goto unlock_index;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1667:  }",
          "1669:  mutex_unlock(&loop_ctl_mutex);",
          "1676:  mutex_unlock(&loop_index_mutex);",
          "1677: }",
          "",
          "[Removed Lines]",
          "1670: }",
          "1672: static void lo_release(struct gendisk *disk, fmode_t mode)",
          "1673: {",
          "1674:  mutex_lock(&loop_index_mutex);",
          "1675:  __lo_release(disk->private_data);",
          "",
          "[Added Lines]",
          "1673: unlock_index:",
          "",
          "---------------"
        ]
      }
    }
  ]
}
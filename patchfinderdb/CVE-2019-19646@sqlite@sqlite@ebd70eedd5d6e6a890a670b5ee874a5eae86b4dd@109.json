{
  "cve_id": "CVE-2019-19646",
  "cve_desc": "pragma.c in SQLite through 3.30.1 mishandles NOT NULL in an integrity_check PRAGMA command in certain cases of generated columns.",
  "repo": "sqlite/sqlite",
  "patch_hash": "ebd70eedd5d6e6a890a670b5ee874a5eae86b4dd",
  "patch_info": {
    "commit_hash": "ebd70eedd5d6e6a890a670b5ee874a5eae86b4dd",
    "repo": "sqlite/sqlite",
    "commit_url": "https://github.com/sqlite/sqlite/commit/ebd70eedd5d6e6a890a670b5ee874a5eae86b4dd",
    "files": [
      "manifest",
      "manifest.uuid",
      "src/pragma.c",
      "test/gencol1.test"
    ],
    "message": "Fix the NOT NULL verification logic in PRAGMA integrity_check so that it works for generated columns whose value is the result of a comparison operator. Ticket [bd8c280671ba44a7]\n\nFossilOrigin-Name: f3b39c71b88cb6721f443de56cdce4c08252453a5e340b00a2bd88dc10c42400",
    "before_after_code_files": [
      "manifest.uuid||manifest.uuid",
      "src/pragma.c||src/pragma.c",
      "test/gencol1.test||test/gencol1.test"
    ]
  },
  "patch_diff": {
    "manifest.uuid||manifest.uuid": [
      "File: manifest.uuid -> manifest.uuid",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "1: e3398c5ffb060b2b26334b8598e2c63953741e2d6f5124dbd6bdfc8e94742539",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ],
    "src/pragma.c||src/pragma.c": [
      "File: src/pragma.c -> src/pragma.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "1596:           if( j==pTab->iPKey ) continue;",
      "1597:           if( pTab->aCol[j].notNull==0 ) continue;",
      "1598:           sqlite3ExprCodeGetColumnOfTable(v, pTab, iDataCur, j, 3);",
      "1600:           jmp2 = sqlite3VdbeAddOp1(v, OP_NotNull, 3); VdbeCoverage(v);",
      "1601:           zErr = sqlite3MPrintf(db, \"NULL value in %s.%s\", pTab->zName,",
      "1602:                               pTab->aCol[j].zName);",
      "",
      "[Removed Lines]",
      "1599:           sqlite3VdbeChangeP5(v, OPFLAG_TYPEOFARG);",
      "",
      "[Added Lines]",
      "1599:           if( sqlite3VdbeGetOp(v,-1)->opcode==OP_Column ){",
      "1600:             sqlite3VdbeChangeP5(v, OPFLAG_TYPEOFARG);",
      "1601:           }",
      "",
      "---------------"
    ],
    "test/gencol1.test||test/gencol1.test": [
      "File: test/gencol1.test -> test/gencol1.test",
      "--- Hunk 1 ---",
      "[Context before]",
      "328:   INSERT OR REPLACE INTO t0(c0, c1) VALUES (2, 1), (1, 0)",
      "329: } {1 {FOREIGN KEY constraint failed}}",
      "331: finish_test",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "331: # 2019-12-09 ticket bd8c280671ba44a7",
      "332: # With generated columns, the sqlite3ExprGetColumnOfTable() routine might",
      "333: # generate a code sequence that does not end with OP_Column.  So check to",
      "334: # make sure that the last instruction generated is an OP_column prior to",
      "335: # applying the OPFLAG_TYPEOFARG optimization to NOT NULL checks in the",
      "336: # PRAGMA integrity_check code.",
      "337: #",
      "338: sqlite3 db :memory:",
      "339: do_execsql_test gencol1-12.10 {",
      "340:   CREATE TABLE t0 (c0, c1 NOT NULL AS (c0==0));",
      "341:   INSERT INTO t0(c0) VALUES (0);",
      "342:   PRAGMA integrity_check;",
      "343: } {ok}",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "85bcdce270575e78258148c00f2efff7e81e7bc1",
      "candidate_info": {
        "commit_hash": "85bcdce270575e78258148c00f2efff7e81e7bc1",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/85bcdce270575e78258148c00f2efff7e81e7bc1",
        "files": [
          "manifest",
          "manifest.uuid",
          "src/expr.c",
          "src/sqliteInt.h",
          "src/wherecode.c"
        ],
        "message": "Split the code generation for the RHS of IN operators and for SELECT and EXISTS expressions into two separate subroutines, because there is now little commonality between those to functions. This is intended to help make the code easier to read and maintain.\n\nFossilOrigin-Name: 2b6494b1509f0d0189f98aa34c990eee99c775ff57826e79b2c5b0a12b4c97ad",
        "before_after_code_files": [
          "manifest.uuid||manifest.uuid",
          "src/expr.c||src/expr.c",
          "src/sqliteInt.h||src/sqliteInt.h",
          "src/wherecode.c||src/wherecode.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: 6231485114eb07b258cd0e6e163ca05f7e9cf5664e071808fcb1329b33e4c4f5",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/expr.c||src/expr.c": [
          "File: src/expr.c -> src/expr.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "481:   int reg = 0;",
          "482: #ifndef SQLITE_OMIT_SUBQUERY",
          "483:   if( pExpr->op==TK_SELECT ){",
          "485:   }",
          "486: #endif",
          "487:   return reg;",
          "",
          "[Removed Lines]",
          "484:     reg = sqlite3CodeSubselect(pParse, pExpr, 0, 0);",
          "",
          "[Added Lines]",
          "484:     reg = sqlite3CodeSubselect(pParse, pExpr);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2542:     }else if( prRhsHasNull ){",
          "2544:     }",
          "2546:     pParse->nQueryLoop = savedNQueryLoop;",
          "2547:   }else{",
          "2548:     pX->iTable = iTab;",
          "",
          "[Removed Lines]",
          "2545:     sqlite3CodeSubselect(pParse, pX, rMayHaveNull, eType==IN_INDEX_ROWID);",
          "",
          "[Added Lines]",
          "2545:     assert( pX->op==TK_IN );",
          "2546:     sqlite3CodeRhsOfIN(pParse, pX, eType==IN_INDEX_ROWID);",
          "2547:     if( rMayHaveNull ){",
          "2548:       sqlite3SetHasNullFlag(v, pX->iTable, rMayHaveNull);",
          "2549:     }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "2626:   }",
          "2627: }",
          "2664: ){",
          "",
          "[Removed Lines]",
          "2658: #ifndef SQLITE_OMIT_SUBQUERY",
          "2659: int sqlite3CodeSubselect(",
          "2667:   Vdbe *v = sqlite3GetVdbe(pParse);",
          "2668:   if( NEVER(v==0) ) return 0;",
          "",
          "[Added Lines]",
          "2633: #ifndef SQLITE_OMIT_SUBQUERY",
          "2658: void sqlite3CodeRhsOfIN(",
          "2670:   v = sqlite3GetVdbe(pParse);",
          "2671:   assert( v!=0 );",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "2681:     jmpIfDynamic = sqlite3VdbeAddOp0(v, OP_Once); VdbeCoverage(v);",
          "2682:   }",
          "2810:       }",
          "2813:       }",
          "2815:     }",
          "2859:       }",
          "2864:       }else{",
          "2870:       }",
          "2874:     }",
          "2875:   }",
          "2879:   }",
          "2881:   if( jmpIfDynamic>=0 ){",
          "2882:     sqlite3VdbeJumpHere(v, jmpIfDynamic);",
          "",
          "[Removed Lines]",
          "2684:   switch( pExpr->op ){",
          "2685:     case TK_IN: {",
          "2691:       nVal = sqlite3ExprVectorSize(pLeft);",
          "2692:       assert( !isRowid || nVal==1 );",
          "2707:       pExpr->iTable = pParse->nTab++;",
          "2708:       addr = sqlite3VdbeAddOp2(v, OP_OpenEphemeral,",
          "2709:           pExpr->iTable, (isRowid?0:nVal));",
          "2710:       pKeyInfo = isRowid ? 0 : sqlite3KeyInfoAlloc(pParse->db, nVal, 1);",
          "2712:       if( ExprHasProperty(pExpr, EP_xIsSelect) ){",
          "2718:         Select *pSelect = pExpr->x.pSelect;",
          "2719:         ExprList *pEList = pSelect->pEList;",
          "2721:         ExplainQueryPlan((pParse, 1, \"%sLIST SUBQUERY\",",
          "2722:             jmpIfDynamic>=0?\"\":\"CORRELATED \"",
          "2723:         ));",
          "2724:         assert( !isRowid );",
          "2727:         if( ALWAYS(pEList->nExpr==nVal) ){",
          "2728:           SelectDest dest;",
          "2729:           int i;",
          "2730:           sqlite3SelectDestInit(&dest, SRT_Set, pExpr->iTable);",
          "2731:           dest.zAffSdst = exprINAffinity(pParse, pExpr);",
          "2732:           pSelect->iLimit = 0;",
          "2733:           testcase( pSelect->selFlags & SF_Distinct );",
          "2735:           if( sqlite3Select(pParse, pSelect, &dest) ){",
          "2736:             sqlite3DbFree(pParse->db, dest.zAffSdst);",
          "2737:             sqlite3KeyInfoUnref(pKeyInfo);",
          "2738:             return 0;",
          "2739:           }",
          "2740:           sqlite3DbFree(pParse->db, dest.zAffSdst);",
          "2742:           assert( pEList!=0 );",
          "2743:           assert( pEList->nExpr>0 );",
          "2744:           assert( sqlite3KeyInfoIsWriteable(pKeyInfo) );",
          "2745:           for(i=0; i<nVal; i++){",
          "2746:             Expr *p = sqlite3VectorFieldSubexpr(pLeft, i);",
          "2747:             pKeyInfo->aColl[i] = sqlite3BinaryCompareCollSeq(",
          "2748:                 pParse, p, pEList->a[i].pExpr",
          "2749:             );",
          "2750:           }",
          "2751:         }",
          "2752:       }else if( ALWAYS(pExpr->x.pList!=0) ){",
          "2761:         int i;",
          "2762:         ExprList *pList = pExpr->x.pList;",
          "2763:         struct ExprList_item *pItem;",
          "2764:         int r1, r2, r3;",
          "2765:         affinity = sqlite3ExprAffinity(pLeft);",
          "2766:         if( !affinity ){",
          "2767:           affinity = SQLITE_AFF_BLOB;",
          "2768:         }",
          "2769:         if( pKeyInfo ){",
          "2770:           assert( sqlite3KeyInfoIsWriteable(pKeyInfo) );",
          "2771:           pKeyInfo->aColl[0] = sqlite3ExprCollSeq(pParse, pExpr->pLeft);",
          "2772:         }",
          "2775:         r1 = sqlite3GetTempReg(pParse);",
          "2776:         r2 = sqlite3GetTempReg(pParse);",
          "2777:         if( isRowid ) sqlite3VdbeAddOp4(v, OP_Blob, 0, r2, 0, \"\", P4_STATIC);",
          "2778:         for(i=pList->nExpr, pItem=pList->a; i>0; i--, pItem++){",
          "2779:           Expr *pE2 = pItem->pExpr;",
          "2780:           int iValToIns;",
          "2787:           if( jmpIfDynamic>=0 && !sqlite3ExprIsConstant(pE2) ){",
          "2788:             sqlite3VdbeChangeToNoop(v, jmpIfDynamic);",
          "2789:             jmpIfDynamic = -1;",
          "2790:           }",
          "2793:           if( isRowid && sqlite3ExprIsInteger(pE2, &iValToIns) ){",
          "2794:             sqlite3VdbeAddOp3(v, OP_InsertInt, pExpr->iTable, r2, iValToIns);",
          "2795:           }else{",
          "2796:             r3 = sqlite3ExprCodeTarget(pParse, pE2, r1);",
          "2797:             if( isRowid ){",
          "2798:               sqlite3VdbeAddOp2(v, OP_MustBeInt, r3,",
          "2799:                                 sqlite3VdbeCurrentAddr(v)+2);",
          "2800:               VdbeCoverage(v);",
          "2801:               sqlite3VdbeAddOp3(v, OP_Insert, pExpr->iTable, r2, r3);",
          "2802:             }else{",
          "2803:               sqlite3VdbeAddOp4(v, OP_MakeRecord, r3, 1, r2, &affinity, 1);",
          "2804:               sqlite3VdbeAddOp4Int(v, OP_IdxInsert, pExpr->iTable, r2, r3, 1);",
          "2805:             }",
          "2806:           }",
          "2807:         }",
          "2808:         sqlite3ReleaseTempReg(pParse, r1);",
          "2809:         sqlite3ReleaseTempReg(pParse, r2);",
          "2811:       if( pKeyInfo ){",
          "2812:         sqlite3VdbeChangeP4(v, addr, (void *)pKeyInfo, P4_KEYINFO);",
          "2814:       break;",
          "2817:     case TK_EXISTS:",
          "2818:     case TK_SELECT:",
          "2819:     default: {",
          "2838:       testcase( pExpr->op==TK_EXISTS );",
          "2839:       testcase( pExpr->op==TK_SELECT );",
          "2840:       assert( pExpr->op==TK_EXISTS || pExpr->op==TK_SELECT );",
          "2841:       assert( ExprHasProperty(pExpr, EP_xIsSelect) );",
          "2843:       pSel = pExpr->x.pSelect;",
          "2844:       ExplainQueryPlan((pParse, 1, \"%sSCALAR SUBQUERY\",",
          "2845:             jmpIfDynamic>=0?\"\":\"CORRELATED \"));",
          "2846:       nReg = pExpr->op==TK_SELECT ? pSel->pEList->nExpr : 1;",
          "2847:       sqlite3SelectDestInit(&dest, 0, pParse->nMem+1);",
          "2848:       pParse->nMem += nReg;",
          "2849:       if( pExpr->op==TK_SELECT ){",
          "2850:         dest.eDest = SRT_Mem;",
          "2851:         dest.iSdst = dest.iSDParm;",
          "2852:         dest.nSdst = nReg;",
          "2853:         sqlite3VdbeAddOp3(v, OP_Null, 0, dest.iSDParm, dest.iSDParm+nReg-1);",
          "2854:         VdbeComment((v, \"Init subquery result\"));",
          "2855:       }else{",
          "2856:         dest.eDest = SRT_Exists;",
          "2857:         sqlite3VdbeAddOp2(v, OP_Integer, 0, dest.iSDParm);",
          "2858:         VdbeComment((v, \"Init EXISTS result\"));",
          "2860:       pLimit = sqlite3ExprAlloc(pParse->db, TK_INTEGER,&sqlite3IntTokens[1], 0);",
          "2861:       if( pSel->pLimit ){",
          "2862:         sqlite3ExprDelete(pParse->db, pSel->pLimit->pLeft);",
          "2863:         pSel->pLimit->pLeft = pLimit;",
          "2865:         pSel->pLimit = sqlite3PExpr(pParse, TK_LIMIT, pLimit, 0);",
          "2866:       }",
          "2867:       pSel->iLimit = 0;",
          "2868:       if( sqlite3Select(pParse, pSel, &dest) ){",
          "2869:         return 0;",
          "2871:       rReg = dest.iSDParm;",
          "2872:       ExprSetVVAProperty(pExpr, EP_NoReduce);",
          "2873:       break;",
          "2877:   if( rHasNullFlag ){",
          "2878:     sqlite3SetHasNullFlag(v, pExpr->iTable, rHasNullFlag);",
          "",
          "[Added Lines]",
          "2688:   pLeft = pExpr->pLeft;",
          "2689:   nVal = sqlite3ExprVectorSize(pLeft);",
          "2690:   assert( !isRowid || nVal==1 );",
          "2695:   pExpr->iTable = pParse->nTab++;",
          "2696:   addr = sqlite3VdbeAddOp2(v, OP_OpenEphemeral,",
          "2697:       pExpr->iTable, (isRowid?0:nVal));",
          "2698:   pKeyInfo = isRowid ? 0 : sqlite3KeyInfoAlloc(pParse->db, nVal, 1);",
          "2700:   if( ExprHasProperty(pExpr, EP_xIsSelect) ){",
          "2706:     Select *pSelect = pExpr->x.pSelect;",
          "2707:     ExprList *pEList = pSelect->pEList;",
          "2709:     ExplainQueryPlan((pParse, 1, \"%sLIST SUBQUERY\",",
          "2710:         jmpIfDynamic>=0?\"\":\"CORRELATED \"",
          "2711:     ));",
          "2712:     assert( !isRowid );",
          "2715:     if( ALWAYS(pEList->nExpr==nVal) ){",
          "2716:       SelectDest dest;",
          "2717:       int i;",
          "2718:       sqlite3SelectDestInit(&dest, SRT_Set, pExpr->iTable);",
          "2719:       dest.zAffSdst = exprINAffinity(pParse, pExpr);",
          "2720:       pSelect->iLimit = 0;",
          "2721:       testcase( pSelect->selFlags & SF_Distinct );",
          "2723:       if( sqlite3Select(pParse, pSelect, &dest) ){",
          "2724:         sqlite3DbFree(pParse->db, dest.zAffSdst);",
          "2725:         sqlite3KeyInfoUnref(pKeyInfo);",
          "2726:         return;",
          "2728:       sqlite3DbFree(pParse->db, dest.zAffSdst);",
          "2730:       assert( pEList!=0 );",
          "2731:       assert( pEList->nExpr>0 );",
          "2732:       assert( sqlite3KeyInfoIsWriteable(pKeyInfo) );",
          "2733:       for(i=0; i<nVal; i++){",
          "2734:         Expr *p = sqlite3VectorFieldSubexpr(pLeft, i);",
          "2735:         pKeyInfo->aColl[i] = sqlite3BinaryCompareCollSeq(",
          "2736:             pParse, p, pEList->a[i].pExpr",
          "2737:         );",
          "2740:   }else if( ALWAYS(pExpr->x.pList!=0) ){",
          "2749:     int i;",
          "2750:     ExprList *pList = pExpr->x.pList;",
          "2751:     struct ExprList_item *pItem;",
          "2752:     int r1, r2, r3;",
          "2753:     affinity = sqlite3ExprAffinity(pLeft);",
          "2754:     if( !affinity ){",
          "2755:       affinity = SQLITE_AFF_BLOB;",
          "2756:     }",
          "2757:     if( pKeyInfo ){",
          "2758:       assert( sqlite3KeyInfoIsWriteable(pKeyInfo) );",
          "2759:       pKeyInfo->aColl[0] = sqlite3ExprCollSeq(pParse, pExpr->pLeft);",
          "2760:     }",
          "2763:     r1 = sqlite3GetTempReg(pParse);",
          "2764:     r2 = sqlite3GetTempReg(pParse);",
          "2765:     if( isRowid ) sqlite3VdbeAddOp4(v, OP_Blob, 0, r2, 0, \"\", P4_STATIC);",
          "2766:     for(i=pList->nExpr, pItem=pList->a; i>0; i--, pItem++){",
          "2767:       Expr *pE2 = pItem->pExpr;",
          "2768:       int iValToIns;",
          "2775:       if( jmpIfDynamic>=0 && !sqlite3ExprIsConstant(pE2) ){",
          "2776:         sqlite3VdbeChangeToNoop(v, jmpIfDynamic);",
          "2777:         jmpIfDynamic = -1;",
          "2781:       if( isRowid && sqlite3ExprIsInteger(pE2, &iValToIns) ){",
          "2782:         sqlite3VdbeAddOp3(v, OP_InsertInt, pExpr->iTable, r2, iValToIns);",
          "2784:         r3 = sqlite3ExprCodeTarget(pParse, pE2, r1);",
          "2785:         if( isRowid ){",
          "2786:           sqlite3VdbeAddOp2(v, OP_MustBeInt, r3,",
          "2787:                             sqlite3VdbeCurrentAddr(v)+2);",
          "2788:           VdbeCoverage(v);",
          "2789:           sqlite3VdbeAddOp3(v, OP_Insert, pExpr->iTable, r2, r3);",
          "2790:         }else{",
          "2791:           sqlite3VdbeAddOp4(v, OP_MakeRecord, r3, 1, r2, &affinity, 1);",
          "2792:           sqlite3VdbeAddOp4Int(v, OP_IdxInsert, pExpr->iTable, r2, r3, 1);",
          "2793:         }",
          "2796:     sqlite3ReleaseTempReg(pParse, r1);",
          "2797:     sqlite3ReleaseTempReg(pParse, r2);",
          "2799:   if( pKeyInfo ){",
          "2800:     sqlite3VdbeChangeP4(v, addr, (void *)pKeyInfo, P4_KEYINFO);",
          "2801:   }",
          "2802:   if( jmpIfDynamic>=0 ){",
          "2803:     sqlite3VdbeJumpHere(v, jmpIfDynamic);",
          "2804:   }",
          "2805: }",
          "2822: #ifndef SQLITE_OMIT_SUBQUERY",
          "2823: int sqlite3CodeSubselect(Parse *pParse, Expr *pExpr){",
          "2830:   Vdbe *v = sqlite3GetVdbe(pParse);",
          "2831:   assert( v!=0 );",
          "2843:   if( !ExprHasProperty(pExpr, EP_VarSelect) ){",
          "2844:     jmpIfDynamic = sqlite3VdbeAddOp0(v, OP_Once); VdbeCoverage(v);",
          "2845:   }",
          "2857:   testcase( pExpr->op==TK_EXISTS );",
          "2858:   testcase( pExpr->op==TK_SELECT );",
          "2859:   assert( pExpr->op==TK_EXISTS || pExpr->op==TK_SELECT );",
          "2860:   assert( ExprHasProperty(pExpr, EP_xIsSelect) );",
          "2862:   pSel = pExpr->x.pSelect;",
          "2863:   ExplainQueryPlan((pParse, 1, \"%sSCALAR SUBQUERY\",",
          "2864:         jmpIfDynamic>=0?\"\":\"CORRELATED \"));",
          "2865:   nReg = pExpr->op==TK_SELECT ? pSel->pEList->nExpr : 1;",
          "2866:   sqlite3SelectDestInit(&dest, 0, pParse->nMem+1);",
          "2867:   pParse->nMem += nReg;",
          "2868:   if( pExpr->op==TK_SELECT ){",
          "2869:     dest.eDest = SRT_Mem;",
          "2870:     dest.iSdst = dest.iSDParm;",
          "2871:     dest.nSdst = nReg;",
          "2872:     sqlite3VdbeAddOp3(v, OP_Null, 0, dest.iSDParm, dest.iSDParm+nReg-1);",
          "2873:     VdbeComment((v, \"Init subquery result\"));",
          "2874:   }else{",
          "2875:     dest.eDest = SRT_Exists;",
          "2876:     sqlite3VdbeAddOp2(v, OP_Integer, 0, dest.iSDParm);",
          "2877:     VdbeComment((v, \"Init EXISTS result\"));",
          "2878:   }",
          "2879:   pLimit = sqlite3ExprAlloc(pParse->db, TK_INTEGER,&sqlite3IntTokens[1], 0);",
          "2880:   if( pSel->pLimit ){",
          "2881:     sqlite3ExprDelete(pParse->db, pSel->pLimit->pLeft);",
          "2882:     pSel->pLimit->pLeft = pLimit;",
          "2883:   }else{",
          "2884:     pSel->pLimit = sqlite3PExpr(pParse, TK_LIMIT, pLimit, 0);",
          "2885:   }",
          "2886:   pSel->iLimit = 0;",
          "2887:   if( sqlite3Select(pParse, pSel, &dest) ){",
          "2888:     return 0;",
          "2890:   rReg = dest.iSDParm;",
          "2891:   ExprSetVVAProperty(pExpr, EP_NoReduce);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "3343: #if SQLITE_OMIT_SUBQUERY",
          "3344:       iResult = 0;",
          "3345: #else",
          "3347: #endif",
          "3348:     }else{",
          "3349:       int i;",
          "",
          "[Removed Lines]",
          "3346:       iResult = sqlite3CodeSubselect(pParse, p, 0, 0);",
          "",
          "[Added Lines]",
          "3358:       iResult = sqlite3CodeSubselect(pParse, p);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "3817:       if( op==TK_SELECT && (nCol = pExpr->x.pSelect->pEList->nExpr)!=1 ){",
          "3818:         sqlite3SubselectError(pParse, nCol, 1);",
          "3819:       }else{",
          "3821:       }",
          "3822:       break;",
          "3823:     }",
          "3824:     case TK_SELECT_COLUMN: {",
          "3825:       int n;",
          "3826:       if( pExpr->pLeft->iTable==0 ){",
          "3828:       }",
          "3829:       assert( pExpr->iTable==0 || pExpr->pLeft->op==TK_SELECT );",
          "3830:       if( pExpr->iTable",
          "",
          "[Removed Lines]",
          "3820:         return sqlite3CodeSubselect(pParse, pExpr, 0, 0);",
          "3827:         pExpr->pLeft->iTable = sqlite3CodeSubselect(pParse, pExpr->pLeft, 0, 0);",
          "",
          "[Added Lines]",
          "3832:         return sqlite3CodeSubselect(pParse, pExpr);",
          "3839:         pExpr->pLeft->iTable = sqlite3CodeSubselect(pParse, pExpr->pLeft);",
          "",
          "---------------"
        ],
        "src/sqliteInt.h||src/sqliteInt.h": [
          "File: src/sqliteInt.h -> src/sqliteInt.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "4258: int sqlite3GetToken(const unsigned char *, int *);",
          "4259: void sqlite3NestedParse(Parse*, const char*, ...);",
          "4260: void sqlite3ExpirePreparedStatements(sqlite3*, int);",
          "4262: void sqlite3SelectPrep(Parse*, Select*, NameContext*);",
          "4263: void sqlite3SelectWrongNumTermsError(Parse *pParse, Select *p);",
          "4264: int sqlite3MatchSpanName(const char*, const char*, const char*, const char*);",
          "",
          "[Removed Lines]",
          "4261: int sqlite3CodeSubselect(Parse*, Expr *, int, int);",
          "",
          "[Added Lines]",
          "4261: void sqlite3CodeRhsOfIN(Parse*, Expr*, int);",
          "4262: int sqlite3CodeSubselect(Parse*, Expr*);",
          "",
          "---------------"
        ],
        "src/wherecode.c||src/wherecode.c": [
          "File: src/wherecode.c -> src/wherecode.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1076: #ifndef SQLITE_OMIT_SUBQUERY",
          "1077:     if( (p->flags & EP_xIsSelect) ){",
          "1078:       Vdbe *v = pParse->pVdbe;",
          "1080:       sqlite3VdbeAddOp3(v, OP_Copy, iSelect, iReg, nReg-1);",
          "1081:     }else",
          "1082: #endif",
          "",
          "[Removed Lines]",
          "1079:       int iSelect = sqlite3CodeSubselect(pParse, p, 0, 0);",
          "",
          "[Added Lines]",
          "1079:       int iSelect;",
          "1080:       assert( p->op==TK_SELECT );",
          "1081:       iSelect = sqlite3CodeSubselect(pParse, p);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "b15f19c75e74a939f13fe86e57820571aaa2295b",
      "candidate_info": {
        "commit_hash": "b15f19c75e74a939f13fe86e57820571aaa2295b",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/b15f19c75e74a939f13fe86e57820571aaa2295b",
        "files": [
          "ext/fts5/fts5Int.h",
          "ext/fts5/fts5_hash.c",
          "ext/fts5/fts5_index.c",
          "ext/fts5/test/fts5aa.test",
          "manifest",
          "manifest.uuid"
        ],
        "message": "Fix an fts5 problem with interleaving reads and writes in a single transaction.\n\nFossilOrigin-Name: 45c73deb440496e848cb24d4c1326d4105dacfee8bbafb115e567051855e6518",
        "before_after_code_files": [
          "ext/fts5/fts5Int.h||ext/fts5/fts5Int.h",
          "ext/fts5/fts5_hash.c||ext/fts5/fts5_hash.c",
          "ext/fts5/fts5_index.c||ext/fts5/fts5_index.c",
          "ext/fts5/test/fts5aa.test||ext/fts5/test/fts5aa.test",
          "manifest.uuid||manifest.uuid"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "ext/fts5/fts5Int.h||ext/fts5/fts5Int.h": [
          "File: ext/fts5/fts5Int.h -> ext/fts5/fts5Int.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "584: int sqlite3Fts5HashQuery(",
          "589: );",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "586:   int nPre,",
          "",
          "---------------"
        ],
        "ext/fts5/fts5_hash.c||ext/fts5/fts5_hash.c": [
          "File: ext/fts5/fts5_hash.c -> ext/fts5/fts5_hash.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "187:   return SQLITE_OK;",
          "188: }",
          "191:   if( p->iSzPoslist ){",
          "193:     if( pHash->eDetail==FTS5_DETAIL_NONE ){",
          "195:       if( p->bDel ){",
          "197:         if( p->bContent ){",
          "199:         }",
          "200:       }",
          "201:     }else{",
          "205:       assert( p->bDel==0 || p->bDel==1 );",
          "",
          "[Removed Lines]",
          "190: static void fts5HashAddPoslistSize(Fts5Hash *pHash, Fts5HashEntry *p){",
          "192:     u8 *pPtr = (u8*)p;",
          "194:       assert( p->nData==p->iSzPoslist );",
          "196:         pPtr[p->nData++] = 0x00;",
          "198:           pPtr[p->nData++] = 0x00;",
          "",
          "[Added Lines]",
          "190: static int fts5HashAddPoslistSize(",
          "191:   Fts5Hash *pHash,",
          "192:   Fts5HashEntry *p,",
          "193:   Fts5HashEntry *p2",
          "194: ){",
          "195:   int nRet = 0;",
          "197:     u8 *pPtr = p2 ? (u8*)p2 : (u8*)p;",
          "198:     int nData = p->nData;",
          "200:       assert( nData==p->iSzPoslist );",
          "202:         pPtr[nData++] = 0x00;",
          "204:           pPtr[nData++] = 0x00;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "209:         int nByte = sqlite3Fts5GetVarintLen((u32)nPos);",
          "210:         memmove(&pPtr[p->iSzPoslist + nByte], &pPtr[p->iSzPoslist + 1], nSz);",
          "211:         sqlite3Fts5PutVarint(&pPtr[p->iSzPoslist], nPos);",
          "213:       }",
          "214:     }",
          "219:   }",
          "220: }",
          "",
          "[Removed Lines]",
          "212:         p->nData += (nByte-1);",
          "216:     p->iSzPoslist = 0;",
          "217:     p->bDel = 0;",
          "218:     p->bContent = 0;",
          "",
          "[Added Lines]",
          "218:         nData += (nByte-1);",
          "222:     nRet = nData - p->nData;",
          "223:     if( p2==0 ){",
          "224:       p->iSzPoslist = 0;",
          "225:       p->bDel = 0;",
          "226:       p->bContent = 0;",
          "227:       p->nData = nData;",
          "228:     }",
          "230:   return nRet;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "330:   if( iRowid!=p->iRowid ){",
          "332:     p->nData += sqlite3Fts5PutVarint(&pPtr[p->nData], iRowid - p->iRowid);",
          "333:     p->iRowid = iRowid;",
          "334:     bNew = 1;",
          "",
          "[Removed Lines]",
          "331:     fts5HashAddPoslistSize(pHash, p);",
          "",
          "[Added Lines]",
          "342:     fts5HashAddPoslistSize(pHash, p, 0);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "474: int sqlite3Fts5HashQuery(",
          "479: ){",
          "480:   unsigned int iHash = fts5HashKey(pHash->nSlot, (const u8*)pTerm, nTerm);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "487:   int nPre,",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "488:   }",
          "490:   if( p ){",
          "494:   }else{",
          "497:   }",
          "",
          "[Removed Lines]",
          "491:     fts5HashAddPoslistSize(pHash, p);",
          "",
          "[Added Lines]",
          "503:     int nHashPre = sizeof(Fts5HashEntry) + nTerm + 1;",
          "504:     int nList = p->nData - nHashPre;",
          "505:     u8 *pRet = (u8*)(*ppOut = sqlite3_malloc64(nPre + nList + 10));",
          "506:     if( pRet ){",
          "507:       Fts5HashEntry *pFaux = (Fts5HashEntry*)&pRet[nPre-nHashPre];",
          "508:       memcpy(&pRet[nPre], &((u8*)p)[nHashPre], nList);",
          "509:       nList += fts5HashAddPoslistSize(pHash, p, pFaux);",
          "511:     }else{",
          "513:       return SQLITE_NOMEM;",
          "514:     }",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "525:   if( (p = pHash->pScan) ){",
          "526:     char *zKey = fts5EntryKey(p);",
          "527:     int nTerm = (int)strlen(zKey);",
          "",
          "[Removed Lines]",
          "528:     fts5HashAddPoslistSize(pHash, p);",
          "",
          "[Added Lines]",
          "549:     fts5HashAddPoslistSize(pHash, p, 0);",
          "",
          "---------------"
        ],
        "ext/fts5/fts5_index.c||ext/fts5/fts5_index.c": [
          "File: ext/fts5/fts5_index.c -> ext/fts5/fts5_index.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "2459: ){",
          "2461:   int nList = 0;",
          "2462:   const u8 *z = 0;",
          "2463:   int n = 0;",
          "2465:   assert( p->pHash );",
          "2466:   assert( p->rc==SQLITE_OK );",
          "2468:   if( pTerm==0 || (flags & FTS5INDEX_QUERY_SCAN) ){",
          "2469:     p->rc = sqlite3Fts5HashScanInit(p->pHash, (const char*)pTerm, nTerm);",
          "2470:     sqlite3Fts5HashScanEntry(p->pHash, (const char**)&z, &pList, &nList);",
          "2471:     n = (z ? (int)strlen((const char*)z) : 0);",
          "2472:   }else{",
          "2475:     z = pTerm;",
          "2476:     n = nTerm;",
          "2477:   }",
          "2481:     sqlite3Fts5BufferSet(&p->rc, &pIter->term, n, z);",
          "2485:     pLeaf->nn = pLeaf->szLeaf = nList;",
          "2486:     pIter->pLeaf = pLeaf;",
          "2487:     pIter->iLeafOffset = fts5GetVarint(pLeaf->p, (u64*)&pIter->iRowid);",
          "",
          "[Removed Lines]",
          "2460:   const u8 *pList = 0;",
          "2473:     pIter->flags |= FTS5_SEGITER_ONETERM;",
          "2474:     sqlite3Fts5HashQuery(p->pHash, (const char*)pTerm, nTerm, &pList, &nList);",
          "2479:   if( pList ){",
          "2480:     Fts5Data *pLeaf;",
          "2482:     pLeaf = fts5IdxMalloc(p, sizeof(Fts5Data));",
          "2483:     if( pLeaf==0 ) return;",
          "2484:     pLeaf->p = (u8*)pList;",
          "",
          "[Added Lines]",
          "2463:   Fts5Data *pLeaf = 0;",
          "2469:     const u8 *pList = 0;",
          "2474:     if( pList ){",
          "2475:       pLeaf = fts5IdxMalloc(p, sizeof(Fts5Data));",
          "2476:       if( pLeaf ){",
          "2477:         pLeaf->p = pList;",
          "2478:       }",
          "2479:     }",
          "2481:     p->rc = sqlite3Fts5HashQuery(p->pHash, sizeof(Fts5Data),",
          "2482:         (const char*)pTerm, nTerm, (void**)&pLeaf, &nList",
          "2483:     );",
          "2484:     if( pLeaf ){",
          "2485:       pLeaf->p = (u8*)&pLeaf[1];",
          "2486:     }",
          "2489:     pIter->flags |= FTS5_SEGITER_ONETERM;",
          "2492:   if( pLeaf ){",
          "",
          "---------------"
        ],
        "ext/fts5/test/fts5aa.test||ext/fts5/test/fts5aa.test": [
          "File: ext/fts5/test/fts5aa.test -> ext/fts5/test/fts5aa.test",
          "--- Hunk 1 ---",
          "[Context before]",
          "427:   db eval { UPDATE n1_config SET v=50 WHERE k='version' }",
          "428:   set fd [db incrblob main n1_data block 10]",
          "429:   fconfigure $fd -encoding binary -translation binary",
          "431:   close $fd",
          "432: }",
          "433: db func funk funk",
          "",
          "[Removed Lines]",
          "430:   puts -nonewline $fd \"\\x44\\x45\"",
          "",
          "[Added Lines]",
          "430: #  puts -nonewline $fd \"\\x44\\x45\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "603:   SELECT * FROM t11, t10 WHERE t10.rowid IS NULL;",
          "604: }",
          "606: }",
          "608: expand_all_sql db",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "606: #-------------------------------------------------------------------------",
          "607: do_execsql_test 24.0 {",
          "608:   CREATE VIRTUAL TABLE t12 USING fts5(x, detail=%DETAIL%);",
          "609:   INSERT INTO t12 VALUES('aaaa');",
          "610: }",
          "611: do_execsql_test 24.1 {",
          "612:   BEGIN;",
          "613:     DELETE FROM t12 WHERE rowid=1;",
          "614:     SELECT * FROM t12('aaaa');",
          "615:     INSERT INTO t12 VALUES('aaaa');",
          "616:   END;",
          "617: }",
          "618: do_execsql_test 24.2 {",
          "619:   INSERT INTO t12(t12) VALUES('integrity-check');",
          "620: }",
          "621: do_execsql_test 24.3 {",
          "622:     SELECT * FROM t12('aaaa');",
          "623: } {aaaa}",
          "",
          "---------------"
        ],
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: c2f50aa4e7bad8821e91a7490283dd53e44047d10a8cfebc3e2da26c770a5218",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "89dec01e4867f2ab888bc33adbf4a65c2cf7b16a",
      "candidate_info": {
        "commit_hash": "89dec01e4867f2ab888bc33adbf4a65c2cf7b16a",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/89dec01e4867f2ab888bc33adbf4a65c2cf7b16a",
        "files": [
          "manifest",
          "manifest.uuid",
          "src/test_vfs.c",
          "test/walvfs.test"
        ],
        "message": "Add a few more test cases to walvfs.test.\n\nFossilOrigin-Name: 14a64df36efe0dc36795311d58385f9c65dc465b214059e07c2ee6b95ea99c87",
        "before_after_code_files": [
          "manifest.uuid||manifest.uuid",
          "src/test_vfs.c||src/test_vfs.c",
          "test/walvfs.test||test/walvfs.test"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: 6cae81cd1ffb0180e0260d5ba921502c7dee2f54637bff3558a4d1cb5dfd3f32",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/test_vfs.c||src/test_vfs.c": [
          "File: src/test_vfs.c -> src/test_vfs.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "234:     { SQLITE_LOCKED,   \"SQLITE_LOCKED\" },",
          "235:     { SQLITE_BUSY,     \"SQLITE_BUSY\"   },",
          "236:     { SQLITE_READONLY, \"SQLITE_READONLY\"   },",
          "237:   };",
          "239:   const char *z;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "237:     { SQLITE_READONLY_CANTINIT, \"SQLITE_READONLY_CANTINIT\"   },",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "919:   if( rc==SQLITE_OK && isWrite && !pFd->pShm->aPage[iPage] ){",
          "920:     tvfsAllocPage(pFd->pShm, iPage, pgsz);",
          "921:   }",
          "924:   return rc;",
          "925: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "923:   if( rc==SQLITE_OK || rc==SQLITE_READONLY ){",
          "925:   }",
          "",
          "---------------"
        ],
        "test/walvfs.test||test/walvfs.test": [
          "File: test/walvfs.test -> test/walvfs.test",
          "--- Hunk 1 ---",
          "[Context before]",
          "106: #-------------------------------------------------------------------------",
          "107: # Test that a checkpoint may be interrupted using sqlite3_interrupt().",
          "108: #",
          "109: reset_db",
          "110: db close",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "109: # And that the error code is SQLITE_NOMEM, not SQLITE_INTERRUPT, if",
          "110: # an OOM error occurs just before the sqlite3_interrupt() call.",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "137:   PRAGMA wal_checkpoint",
          "138: } {1 interrupted}",
          "140: #-------------------------------------------------------------------------",
          "141: #",
          "142: reset_db",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "143: set ::cnt 2",
          "144: proc xWrite {method file args} {",
          "145:   if {[file tail $file]==\"test.db\"} {",
          "146:     incr ::cnt -1",
          "147:     if {$::cnt==0} {",
          "148:       sqlite3_memdebug_fail 5 -repeat 0",
          "149:       catchsql { SELECT 'a big long string!' }",
          "150:       sqlite3_interrupt db",
          "151:     }",
          "152:   }",
          "153:   return SQLITE_OK",
          "154: }",
          "156: do_catchsql_test 3.2 {",
          "157:   PRAGMA wal_checkpoint",
          "158: } {1 {out of memory}}",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "235:   execsql { SELECT count(*) FROM t1 }",
          "236: } {20}",
          "238: #-------------------------------------------------------------------------",
          "239: # Cause an SQLITE_PROTOCOL while attempting to restart the wal file.",
          "240: #",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "258: vfs_set_readmark db main 1 100",
          "259: vfs_set_readmark db main 2 100",
          "260: vfs_set_readmark db main 3 100",
          "261: vfs_set_readmark db main 4 100",
          "263: tvfs script xShmMapLock",
          "264: tvfs filter {xShmLock xShmMap}",
          "265: proc xShmMapLock {method args} {",
          "266:   if {$method==\"xShmMap\"} {",
          "267:     return \"SQLITE_READONLY\"",
          "268:   }",
          "269:   return SQLITE_BUSY",
          "270: }",
          "272: sqlite3 db2 test.db -vfs tvfs",
          "273: breakpoint",
          "274: do_test 5.5 {",
          "275:   list [catch { execsql { SELECT count(*) FROM t1 } db2 } msg] $msg",
          "276: } {1 {attempt to write a readonly database}}",
          "278: tvfs filter {}",
          "279: vfs_set_readmark db main 1 1",
          "281: do_test 5.6 {",
          "282:   list [catch { execsql { SELECT count(*) FROM t1 } db2 } msg] $msg",
          "283: } {0 20}",
          "284: db2 close",
          "285: db close",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "259: } {}",
          "261: tvfs filter xShmLock",
          "262: set ::flag 0",
          "263: proc xShmLock {method file handle spec} {",
          "264:   if {$::flag && [lrange $spec 2 end]==\"lock shared\"} {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "311: tvfs script xShmLock",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "306:   PRAGMA wal_checkpoint",
          "307: } {1 -1 -1}",
          "309: db close",
          "310: tvfs delete",
          "311: finish_test",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "359: #-------------------------------------------------------------------------",
          "360: # Check that the page cache is correctly flushed if a checkpointer using",
          "361: # a version 2 VFS makes a checkpoint with an out-of-date cache.",
          "362: #",
          "363: reset_db",
          "364: testvfs tvfs2 -iversion 2",
          "365: db close",
          "366: sqlite3 db test.db -vfs tvfs2",
          "367: do_execsql_test 8.0 {",
          "368:   PRAGMA auto_vacuum = 0;",
          "369:   PRAGMA page_size = 1024;",
          "370:   CREATE TABLE t1(x);",
          "371:   PRAGMA journal_mode = wal;",
          "372:   WITH s(i) AS ( SELECT 1 UNION ALL SELECT i+1 FROM s LIMIT 20 )",
          "373:   INSERT INTO t1 SELECT randomblob(75) FROM s;",
          "374: } {wal}",
          "376: do_execsql_test 8.1 { SELECT count(*) FROM t1 } {20}",
          "378: do_test 8.2 {",
          "379:   sqlite3 db2 test.db -vfs tvfs2",
          "380:   execsql {",
          "381:     INSERT INTO t1 VALUES(randomblob(75));",
          "382:   } db2",
          "383:   db2 close",
          "384: } {}",
          "386: do_execsql_test 8.3 {",
          "387:   PRAGMA wal_checkpoint;",
          "388:   SELECT count(*) FROM t1",
          "389: } {0 5 5 21}",
          "390: tvfs2 delete",
          "392: #-------------------------------------------------------------------------",
          "393: reset_db",
          "394: db close",
          "395: sqlite3 db test.db -vfs tvfs",
          "396: do_execsql_test 9.0 {",
          "397:   PRAGMA auto_vacuum = 0;",
          "398:   PRAGMA page_size = 1024;",
          "399:   CREATE TABLE t1(x);",
          "400:   PRAGMA journal_mode = wal;",
          "401:   WITH s(i) AS ( SELECT 1 UNION ALL SELECT i+1 FROM s LIMIT 20 )",
          "402:   INSERT INTO t1 SELECT randomblob(75) FROM s;",
          "403: } {wal}",
          "405: sqlite3 db2 test.db -vfs tvfs",
          "406: tvfs filter {xShmMap xShmLock}",
          "407: tvfs script xShmMap",
          "408: proc xShmMap {method file handle args} {",
          "409:   switch -- $method {",
          "410:     xShmMap {",
          "411:       return \"SQLITE_READONLY_CANTINIT\"",
          "412:     }",
          "413:     xShmLock {",
          "414:       if {$args==\"{3 1 lock shared}\"} {",
          "415:         return \"SQLITE_IOERR\"",
          "416:       }",
          "417:     }",
          "418:   }",
          "419: }",
          "421: do_test 9.1 {",
          "422:   catchsql { SELECT count(*) FROM t1 } db2",
          "423: } {1 {disk I/O error}}",
          "426: db2 close",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "f7e74904ccd2ed0f6c359ec44709446025b2b110",
      "candidate_info": {
        "commit_hash": "f7e74904ccd2ed0f6c359ec44709446025b2b110",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/f7e74904ccd2ed0f6c359ec44709446025b2b110",
        "files": [
          "manifest",
          "manifest.uuid",
          "src/test1.c",
          "test/dbfuzz001.test"
        ],
        "message": "Add the \"decode_hexdb\" TCL command to testfixture.  Add the dbfuzz001.test module to demonstration how to use decode_hexdb to deserialize a dbtotxt database description for use in a corruption test.\n\nFossilOrigin-Name: 1f583c53f3b7318c69f6e235934d97ef9493278feeab0837217076d7d071c35b",
        "before_after_code_files": [
          "manifest.uuid||manifest.uuid",
          "src/test1.c||src/test1.c",
          "test/dbfuzz001.test||test/dbfuzz001.test"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: 7ffa9858162774cba03a565a7b65135d9e8bfea726af1a29de6898f66c4b1261",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/test1.c||src/test1.c": [
          "File: src/test1.c -> src/test1.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "7641:   }",
          "7642: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "7653: static int SQLITE_TCLAPI test_decode_hexdb(",
          "7654:   void * clientData,",
          "7655:   Tcl_Interp *interp,",
          "7656:   int objc,",
          "7657:   Tcl_Obj *CONST objv[]",
          "7658: ){",
          "7659:   const char *zIn = 0;",
          "7660:   unsigned char *a = 0;",
          "7661:   int n = 0;",
          "7662:   int lineno = 0;",
          "7663:   int i, iNext;",
          "7664:   int iOffset = 0;",
          "7665:   int j, k;",
          "7666:   int rc;",
          "7667:   unsigned char x[16];",
          "7668:   if( objc!=2 ){",
          "7669:     Tcl_WrongNumArgs(interp, 1, objv, \"HEXDB\");",
          "7670:     return TCL_ERROR;",
          "7671:   }",
          "7672:   zIn = Tcl_GetString(objv[1]);",
          "7673:   for(i=0; zIn[i]; i=iNext){",
          "7674:     lineno++;",
          "7675:     for(iNext=i; zIn[iNext] && zIn[iNext]!='\\n'; iNext++){}",
          "7676:     if( zIn[iNext]=='\\n' ) iNext++;",
          "7677:     while( zIn[i]==' ' || zIn[i]=='\\t' ){ i++; }",
          "7678:     if( a==0 ){",
          "7679:       int pgsz;",
          "7680:       rc = sscanf(zIn+i, \"| size %d pagesize %d\", &n, &pgsz);",
          "7681:       if( rc!=2 ) continue;",
          "7682:       if( n<512 ){",
          "7683:         Tcl_AppendResult(interp, \"bad 'size' field\", (void*)0);",
          "7684:         return TCL_ERROR;",
          "7685:       }",
          "7686:       a = malloc( n );",
          "7687:       if( a==0 ){",
          "7688:         Tcl_AppendResult(interp, \"out of memory\", (void*)0);",
          "7689:         return TCL_ERROR;",
          "7690:       }",
          "7691:       memset(a, 0, n);",
          "7692:       continue;",
          "7693:     }",
          "7694:     rc = sscanf(zIn+i, \"| page %d offset %d\", &j, &k);",
          "7695:     if( rc==2 ){",
          "7696:       iOffset = k;",
          "7697:       continue;",
          "7698:     }",
          "7699:     rc = sscanf(zIn+i,\"| %d: %hhx %hhx %hhx %hhx %hhx %hhx %hhx %hhx\"",
          "7700:                       \"  %hhx %hhx %hhx %hhx %hhx %hhx %hhx %hhx\",",
          "7701:                 &j, &x[0], &x[1], &x[2], &x[3], &x[4], &x[5], &x[6], &x[7],",
          "7702:                 &x[8], &x[9], &x[10], &x[11], &x[12], &x[13], &x[14], &x[15]);",
          "7703:     if( rc==17 ){",
          "7704:       k = iOffset+j;",
          "7705:       if( k+16<=n ){",
          "7706:         memcpy(a+k, x, 16);",
          "7707:       }",
          "7708:       continue;",
          "7709:     }",
          "7710:   }",
          "7711:   Tcl_SetObjResult(interp, Tcl_NewByteArrayObj(a, n));",
          "7712:   free(a);",
          "7713:   return TCL_OK;",
          "7714: }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "7920:      { \"atomic_batch_write\",      test_atomic_batch_write, 0 },",
          "7921:      { \"sqlite3_mmap_warm\",       test_mmap_warm,          0 },",
          "7922:      { \"sqlite3_config_sorterref\", test_config_sorterref,   0 },",
          "7923:   };",
          "7924:   static int bitmask_size = sizeof(Bitmask)*8;",
          "7925:   static int longdouble_size = sizeof(LONGDOUBLE_TYPE);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "7996:      { \"decode_hexdb\",             test_decode_hexdb,       0 },",
          "",
          "---------------"
        ],
        "test/dbfuzz001.test||test/dbfuzz001.test": [
          "File: test/dbfuzz001.test -> test/dbfuzz001.test",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: # 2012-12-13",
          "2: #",
          "3: # The author disclaims copyright to this source code.  In place of",
          "4: # a legal notice, here is a blessing:",
          "5: #",
          "6: #    May you do good and not evil.",
          "7: #    May you find forgiveness for yourself and forgive others.",
          "8: #    May you share freely, never taking more than you give.",
          "9: #",
          "10: #***********************************************************************",
          "11: #",
          "12: # Test cases for corrupt database files.",
          "14: set testdir [file dirname $argv0]",
          "15: source $testdir/tester.tcl",
          "17: ifcapable !deserialize {",
          "18:   finish_test",
          "19:   return",
          "20: }",
          "22: do_test dbfuzz001-100 {",
          "23:   sqlite3 db {}",
          "24:   db deserialize [decode_hexdb {",
          "25:     | size 5632 pagesize 512 filename c4.db",
          "26:     | page 1 offset 0",
          "27:     |      0: 53 51 4c 69 74 65 20 66 6f 72 6d 61 74 20 33 00   SQLite format 3.",
          "28:     |     16: 02 00 01 01 00 40 20 20 00 00 00 02 00 00 00 0b   .....@  ........",
          "29:     |     32: 00 00 00 06 00 00 00 01 00 00 00 28 00 00 00 04   ...........(....",
          "30:     |     48: 00 00 00 00 00 00 00 00 00 00 00 01 00 00 00 00   ................",
          "31:     |     80: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 02   ................",
          "32:     |     96: 00 2e 30 38 0d 00 00 00 06 01 06 00 01 da 01 b0   ..08............",
          "33:     |    112: 01 56 01 86 01 2a 01 06 00 00 00 00 00 00 00 00   .V...*..........",
          "34:     |    256: 00 00 00 00 00 00 22 07 06 17 11 11 01 31 74 61   ......\"......1ta",
          "35:     |    272: 62 6c 65 74 34 74 34 07 43 52 45 41 54 45 20 54   blet4t4.CREATE T",
          "36:     |    288: 41 42 4c 45 20 74 34 28 78 29 2a 06 06 17 13 11   ABLE t4(x)*.....",
          "37:     |    304: 01 3f 69 6e 64 65 78 00 00 00 00 00 00 00 00 00   .?index.........",
          "38:     |    336: 20 74 33 28 78 29 2e 04 06 17 15 11 01 45 69 6e    t3(x).......Ein",
          "39:     |    352: 64 65 78 74 32 63 64 74 32 05 43 52 45 41 54 45   dext2cdt2.CREATE",
          "40:     |    368: 20 49 4e 44 45 58 20 74 32 63 64 20 4f 4e 20 74    INDEX t2cd ON t",
          "41:     |    384: 32 28 63 2c 64 29 28 05 06 17 11 11 01 3d 74 61   2(c,d)(......=ta",
          "42:     |    400: 62 6c 65 74 33 74 33 04 43 52 45 41 54 45 20 54   blet3t3.CREATE T",
          "43:     |    416: 41 42 4c 45 20 74 33 28 63 2c 78 2c 65 2c 66 29   ABLE t3(c,x,e,f)",
          "44:     |    432: 28 02 06 17 11 11 01 3d 74 61 62 6c 65 74 32 74   (......=tablet2t",
          "45:     |    448: 32 03 43 52 45 41 54 45 20 54 41 42 4c 45 20 74   2.CREATE TABLE t",
          "46:     |    464: 32 28 63 2c 64 2c 65 2c 66 29 24 01 06 17 11 11   2(c,d,e,f)$.....",
          "47:     |    480: 01 35 74 61 62 6c 65 74 31 74 31 02 43 52 45 41   .5tablet1t1.CREA",
          "48:     |    496: 54 45 20 54 41 42 4c 45 20 74 31 28 61 2c 62 29   TE TABLE t1(a,b)",
          "49:     | page 2 offset 512",
          "50:     |      0: 0d 00 00 00 00 02 00 00 00 00 00 00 00 00 00 00   ................",
          "51:     | page 3 offset 1024",
          "52:     |      0: 0d 00 00 00 00 02 00 00 00 00 00 00 00 00 00 00   ................",
          "53:     | page 4 offset 1536",
          "54:     |      0: 05 00 00 00 03 01 f1 00 00 00 00 0b 01 fb 01 f6   ................",
          "55:     |     16: 01 f1 00 16 00 00 09 06 05 01 01 01 01 04 04 03   ................",
          "56:     |     32: 03 07 05 05 01 01 09 09 02 02 19 04 05 17 17 17   ................",
          "57:     |     48: 17 73 65 76 65 6e 65 69 67 68 74 65 69 67 68 74   .seveneighteight",
          "58:     |     64: 73 65 76 65 6e 25 03 05 07 07 07 07 40 14 00 00   seven%......@...",
          "59:     |     80: 00 00 00 00 40 18 00 00 00 00 00 00 40 18 00 00   ....@.......@...",
          "60:     |     96: 00 00 00 00 40 14 00 00 00 00 00 00 09 02 05 01   ....@...........",
          "61:     |    112: 01 01 01 03 04 04 03 07 01 05 09 01 01 09 02 02   ................",
          "62:     |    352: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 1a   ................",
          "63:     |    496: 00 00 00 00 0a 3e 00 00 00 09 21 00 00 00 08 06   .....>....!.....",
          "64:     | page 5 offset 2048",
          "65:     |      0: 0a 00 00 00 00 02 00 00 00 00 00 00 00 00 00 00   ................",
          "66:     | page 7 offset 3072",
          "67:     |      0: 0d 00 00 00 08 01 c2 00 01 fb 01 f6 01 f1 01 ec   ................",
          "68:     |     16: 01 e0 01 d4 01 cb 01 c2 00 00 00 00 00 00 00 00   ................",
          "69:     |     96: 00 00 00 00 13 00 00 00 00 00 00 00 00 00 00 00   ................",
          "70:     |    224: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 02   ................",
          "71:     |    288: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 03   ................",
          "72:     |    448: 00 00 07 08 02 17 65 69 67 68 74 07 07 02 17 65   ......eight....e",
          "73:     |    464: 69 67 68 74 0a 06 02 07 40 18 00 00 00 00 00 00   ight....@.......",
          "74:     |    480: 0a 05 02 07 40 18 00 00 00 00 00 00 03 04 02 01   ....@...........",
          "75:     |    496: 04 03 03 02 01 04 03 02 02 01 02 03 01 02 01 02   ................",
          "76:     | page 8 offset 3584",
          "77:     |      0: 0d 00 21 00 01 00 16 00 00 16 00 16 00 16 00 16   ..!.............",
          "78:     |     16: 00 16 00 16 00 00 09 06 05 01 01 01 01 04 04 03   ................",
          "79:     |     32: 03 00 00 00 5f 01 09 09 02 02 00 00 00 56 17 17   ...._........V..",
          "80:     |     48: 17 73 65 76 65 6e 65 69 67 68 74 65 69 67 68 74   .seveneighteight",
          "81:     |     64: 73 65 76 65 6e 00 00 00 3b 07 07 07 40 14 00 00   seven...;...@...",
          "82:     |     80: 00 00 00 00 40 18 00 00 00 00 00 00 40 18 00 00   ....@.......@...",
          "83:     |     96: 00 00 00 00 40 14 00 00 00 00 00 00 00 00 00 14   ....@...........",
          "84:     |    112: 01 01 01 03 04 04 03 00 00 00 09 01 01 09 02 02   ................",
          "85:     |    352: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 1a   ................",
          "86:     | page 9 offset 4096",
          "87:     |      0: 0d 00 00 00 1b 00 47 00 01 d9 01 be 01 af 01 a0   ......G.........",
          "88:     |     16: 01 91 01 82 01 73 01 64 01 55 01 46 01 37 01 28   .....s.d.U.F.7.(",
          "89:     |     32: 01 19 01 0a 00 fb 00 ec 00 dd 00 ce 00 bf 00 b0   ................",
          "90:     |     48: 00 a1 00 92 00 83 00 74 00 65 00 56 00 47 00 00   .......t.e.V.G..",
          "91:     |     64: 00 00 00 00 00 00 00 0d 21 00 00 48 01 54 00 01   ........!..H.T..",
          "92:     |     80: f7 01 ec 01 c5 01 0d 20 00 00 48 01 54 00 01 f7   ....... ..H.T...",
          "93:     |     96: 01 ec 01 c5 01 0d 1f 00 00 48 01 54 00 01 f7 01   .........H.T....",
          "94:     |    112: ec 01 c5 01 0d 1e 00 00 48 01 54 00 01 f7 01 ec   ........H.T.....",
          "95:     |    128: 01 c5 01 0d 1d 00 00 48 01 54 00 01 f7 01 ec 01   .......H.T......",
          "96:     |    144: c5 01 0d 1c 00 00 48 01 54 00 01 f7 01 ec 01 c5   ......H.T.......",
          "97:     |    160: 01 0d 1b 00 00 48 01 54 00 01 f7 01 ec 01 c5 01   .....H.T........",
          "98:     |    176: 0d 1a 00 00 48 01 54 00 01 f7 01 ec 01 c5 01 0d   ....H.T.........",
          "99:     |    192: 19 00 00 48 01 54 00 01 f7 01 ec 01 c5 01 0d 18   ...H.T..........",
          "100:     |    208: 00 00 48 01 54 00 01 f7 01 ec 01 c5 01 0d 17 00   ..H.T...........",
          "101:     |    224: 00 48 01 54 00 01 f7 01 ec 01 c5 01 0d 16 00 00   .H.T............",
          "102:     |    240: 48 01 54 00 01 f7 01 ec 01 c5 01 0d 15 00 00 48   H.T............H",
          "103:     |    256: 01 54 00 01 f7 01 ec 01 c5 01 0d 14 00 00 48 01   .T............H.",
          "104:     |    272: 54 00 01 f7 01 ec 01 c5 01 0d 13 00 00 48 01 54   T............H.T",
          "105:     |    288: 00 01 f7 01 ec 01 c5 01 0d 12 00 00 48 01 54 00   ............H.T.",
          "106:     |    304: 01 f7 01 ec 01 c5 01 0d 11 00 00 48 01 54 00 01   ...........H.T..",
          "107:     |    320: f7 01 ec 01 c5 01 0d 10 00 00 48 01 54 00 01 f7   ..........H.T...",
          "108:     |    336: 01 ec 01 c5 01 0d 0f 00 00 48 01 54 00 01 f7 01   .........H.T....",
          "109:     |    352: ec 01 c5 01 0d 0e 00 00 48 01 54 00 01 f7 01 ec   ........H.T.....",
          "110:     |    368: 01 c5 01 0d 0d 00 00 48 01 54 00 01 f7 01 ec 01   .......H.T......",
          "111:     |    384: c5 01 0d 0c 00 00 48 01 54 00 01 f7 01 ec 01 c5   ......H.T.......",
          "112:     |    400: 01 0d 0b 00 00 48 01 54 00 01 f7 01 ec 01 c5 01   .....H.T........",
          "113:     |    416: 0d 0a 00 00 48 01 54 00 01 f7 01 ec 01 c5 01 0d   ....H.T.........",
          "114:     |    432: 09 00 00 48 01 54 00 01 f7 01 ec 01 c5 01 19 08   ...H.T..........",
          "115:     |    448: 05 17 17 17 17 65 69 67 68 74 65 69 67 68 74 73   .....eighteights",
          "116:     |    464: 65 76 65 6e 73 65 76 65 6e 25 07 05 07 07 07 07   evenseven%......",
          "117:     |    480: 40 18 00 00 00 00 00 00 40 18 00 00 00 00 00 00   @.......@.......",
          "118:     |    496: 40 14 00 00 00 00 00 00 40 14 00 00 00 00 00 00   @.......@.......",
          "119:     | page 10 offset 4608",
          "120:     |      0: 0d 00 00 00 1d 00 4d 00 01 f1 01 e2 01 d3 01 c4   ......M.........",
          "121:     |     16: 01 b5 01 a6 01 97 01 88 01 79 01 6a 01 5b 01 4c   .........y.j.[.L",
          "122:     |     32: 01 3d 01 2e 01 1f 01 10 01 01 00 f2 00 e3 00 d4   .=..............",
          "123:     |     48: 00 c5 00 b6 00 a7 00 98 00 89 00 7a 00 6b 00 5c   ...........z.k.\\",
          "124:     |     64: 00 4d 00 00 00 00 00 00 00 00 00 00 00 0d 3e 00   .M............>.",
          "125:     |     80: 00 48 01 54 00 01 f7 01 ec 01 c5 01 0d 3d 00 00   .H.T.........=..",
          "126:     |     96: 48 01 54 00 01 f7 01 ec 01 c5 01 0d 3c 00 00 48   H.T.........<..H",
          "127:     |    112: 01 54 00 01 f7 01 ec 01 c5 01 0d 3b 00 00 48 01   .T.........;..H.",
          "128:     |    128: 54 00 01 f7 01 ec 01 c5 01 0d 3a 00 00 48 01 54   T.........:..H.T",
          "129:     |    144: 00 01 f7 01 ec 01 c5 01 0d 39 00 00 48 01 54 00   .........9..H.T.",
          "130:     |    160: 01 f7 01 ec 01 c5 01 0d 38 00 00 48 01 54 00 01   ........8..H.T..",
          "131:     |    176: f7 01 ec 01 c5 01 0d 37 00 00 48 01 54 00 01 f7   .......7..H.T...",
          "132:     |    192: 01 ec 01 c5 01 0d 36 00 00 48 01 54 00 01 f7 01   ......6..H.T....",
          "133:     |    208: ec 01 c5 01 0d 35 00 00 48 01 54 00 01 f7 01 ec   .....5..H.T.....",
          "134:     |    224: 01 c5 01 0d 34 00 00 48 01 54 00 01 f7 01 ec 01   ....4..H.T......",
          "135:     |    240: c5 01 0d 33 00 00 48 01 54 00 01 f7 01 ec 01 c5   ...3..H.T.......",
          "136:     |    256: 01 0d 32 00 00 48 01 54 00 01 f7 01 ec 01 c5 01   ..2..H.T........",
          "137:     |    272: 0d 31 00 00 48 01 54 00 01 f7 01 ec 01 c5 01 0d   .1..H.T.........",
          "138:     |    288: 30 00 00 48 01 54 00 01 f7 01 ec 01 c5 01 0d 2f   0..H.T........./",
          "139:     |    304: 00 00 48 01 54 00 01 f7 01 ec 01 c5 01 0d 2e 00   ..H.T...........",
          "140:     |    320: 00 48 01 54 00 01 f7 01 ec 01 c5 01 0d 2d 00 00   .H.T.........-..",
          "141:     |    336: 48 01 54 00 01 f7 01 ec 01 c5 01 0d 2c 00 00 48   H.T.........,..H",
          "142:     |    352: 01 54 00 01 f7 01 ec 01 c5 01 0d 2b 00 00 48 01   .T.........+..H.",
          "143:     |    368: 54 00 01 f7 01 ec 01 c5 01 0d 2a 00 00 48 01 54   T.........*..H.T",
          "144:     |    384: 00 01 f7 01 ec 01 c5 01 0d 29 00 00 48 01 54 00   .........)..H.T.",
          "145:     |    400: 01 f7 01 ec 01 c5 01 0d 28 00 00 48 01 54 00 01   ........(..H.T..",
          "146:     |    416: f7 01 ec 01 c5 01 0d 27 00 00 48 01 54 00 01 f7   .......'..H.T...",
          "147:     |    432: 01 ec 01 c5 01 0d 26 00 00 48 01 54 00 01 f7 01   ......&..H.T....",
          "148:     |    448: ec 01 c5 01 0d 25 00 00 48 01 54 00 01 f7 01 ec   .....%..H.T.....",
          "149:     |    464: 01 c5 01 0d 24 00 00 48 01 54 00 01 f7 01 ec 01   ....$..H.T......",
          "150:     |    480: c5 01 0d 23 00 00 48 01 54 00 01 f7 01 ec 01 c5   ...#..H.T.......",
          "151:     |    496: 01 0d 22 00 00 48 01 54 00 01 f7 01 ec 01 c5 01   ..\"..H.T........",
          "152:     | page 11 offset 5120",
          "153:     |      0: 0d 00 00 00 0a 01 6a 00 01 f1 01 e2 01 d3 01 c4   ......j.........",
          "154:     |     16: 01 b5 01 a6 01 97 01 88 01 79 01 6a 00 00 00 00   .........y.j....",
          "155:     |    352: 00 00 00 00 00 00 00 00 00 00 0d 48 00 00 48 01   ...........H..H.",
          "156:     |    368: 54 00 01 f7 01 ec 01 c5 01 0d 47 00 00 48 01 54   T.........G..H.T",
          "157:     |    384: 00 01 f7 01 ec 01 c5 01 0d 46 00 00 48 01 54 00   .........F..H.T.",
          "158:     |    400: 01 f7 01 ec 01 c5 01 0d 45 00 00 48 01 54 00 01   ........E..H.T..",
          "159:     |    416: f7 01 ec 01 c5 01 0d 44 00 00 48 01 54 00 01 f7   .......D..H.T...",
          "160:     |    432: 01 ec 01 c5 01 0d 43 00 00 48 01 54 00 01 f7 01   ......C..H.T....",
          "161:     |    448: ec 01 c5 01 0d 42 00 00 48 01 54 00 01 f7 01 ec   .....B..H.T.....",
          "162:     |    464: 01 c5 01 0d 41 00 00 48 01 54 00 01 f7 01 ec 01   ....A..H.T......",
          "163:     |    480: c5 01 0d 40 00 00 48 01 54 00 01 f7 01 ec 01 c5   ...@..H.T.......",
          "164:     |    496: 01 0d 3f 00 00 48 01 54 00 01 f7 01 ec 01 c5 01   ..?..H.T........",
          "165:     | end c4.db",
          "166:   }]",
          "167:   db eval {PRAGMA integrity_check}",
          "168: } {/Fragmentation of 384 bytes reported as 0 on page 8/}",
          "170: finish_test",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "c90653365027c505e13d45f2c8bc986306b24744",
      "candidate_info": {
        "commit_hash": "c90653365027c505e13d45f2c8bc986306b24744",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/c90653365027c505e13d45f2c8bc986306b24744",
        "files": [
          "manifest",
          "manifest.uuid",
          "src/vdbe.c"
        ],
        "message": "Improved comments on the VDBE branch coverage testing logic.  Fix the VDBE branch coverage measurement on the OP_MustBeInt opcode.\n\nFossilOrigin-Name: 8681750e855a020ee374cb9f973f701a72068e33f97d0101a4fab3a228e5ebda",
        "before_after_code_files": [
          "manifest.uuid||manifest.uuid",
          "src/vdbe.c||src/vdbe.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: 1fcf3307d37f0e8e0c8c54491c609b73c7add6eaa38409a41c7cd6614a877a19",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/vdbe.c||src/vdbe.c": [
          "File: src/vdbe.c -> src/vdbe.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1734:   pIn1 = &aMem[pOp->p1];",
          "1735:   if( (pIn1->flags & MEM_Int)==0 ){",
          "1736:     applyAffinity(pIn1, SQLITE_AFF_NUMERIC, encoding);",
          "1738:     if( (pIn1->flags & MEM_Int)==0 ){",
          "1739:       if( pOp->p2==0 ){",
          "1740:         rc = SQLITE_MISMATCH;",
          "1741:         goto abort_due_to_error;",
          "",
          "[Removed Lines]",
          "1737:     VdbeBranchTaken((pIn1->flags&MEM_Int)==0, 2);",
          "",
          "[Added Lines]",
          "1758:       VdbeBranchTaken(1, 2);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1744:       }",
          "1745:     }",
          "1746:   }",
          "1747:   MemSetTypeFlag(pIn1, MEM_Int);",
          "1748:   break;",
          "1749: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1767:   VdbeBranchTaken(0, 2);",
          "",
          "---------------"
        ]
      }
    }
  ]
}
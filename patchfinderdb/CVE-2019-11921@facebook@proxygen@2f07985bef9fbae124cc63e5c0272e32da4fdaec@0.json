{
  "cve_id": "CVE-2019-11921",
  "cve_desc": "An out of bounds write is possible via a specially crafted packet in certain configurations of Proxygen due to improper handling of Base64 when parsing malformed binary content in Structured HTTP Headers. This issue affects versions of proxygen prior to v2019.07.22.00.",
  "repo": "facebook/proxygen",
  "patch_hash": "2f07985bef9fbae124cc63e5c0272e32da4fdaec",
  "patch_info": {
    "commit_hash": "2f07985bef9fbae124cc63e5c0272e32da4fdaec",
    "repo": "facebook/proxygen",
    "commit_url": "https://github.com/facebook/proxygen/commit/2f07985bef9fbae124cc63e5c0272e32da4fdaec",
    "files": [
      "proxygen/lib/http/structuredheaders/StructuredHeadersUtilities.cpp"
    ],
    "message": "Fix SEGV in StructuredHeaders::decodeBase64\n\nSummary:\nThe existing code can potentially cause a SEGV due to an out of bounds write.\n\nThis fixes CVE-2019-11921.\n\nReviewed By: knekritz\n\nDifferential Revision: D12983120\n\nfbshipit-source-id: 1d48063595c8d518fd8afcbc941de260af7e37fd",
    "before_after_code_files": [
      "proxygen/lib/http/structuredheaders/StructuredHeadersUtilities.cpp||proxygen/lib/http/structuredheaders/StructuredHeadersUtilities.cpp"
    ]
  },
  "patch_diff": {
    "proxygen/lib/http/structuredheaders/StructuredHeadersUtilities.cpp||proxygen/lib/http/structuredheaders/StructuredHeadersUtilities.cpp": [
      "File: proxygen/lib/http/structuredheaders/StructuredHeadersUtilities.cpp -> proxygen/lib/http/structuredheaders/StructuredHeadersUtilities.cpp",
      "--- Hunk 1 ---",
      "[Context before]",
      "11: #include \"StructuredHeadersUtilities.h\"",
      "15: #include \"StructuredHeadersConstants.h\"",
      "17: namespace proxygen {",
      "18: namespace StructuredHeaders {",
      "",
      "[Removed Lines]",
      "12: #include <boost/archive/iterators/binary_from_base64.hpp>",
      "13: #include <boost/archive/iterators/base64_from_binary.hpp>",
      "14: #include <boost/archive/iterators/transform_width.hpp>",
      "",
      "[Added Lines]",
      "14: #include \"proxygen/lib/utils/Base64.h\"",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "108:   if (encoded.size() == 0) {",
      "111:   }",
      "124: }",
      "126: std::string encodeBase64(const std::string& input) {",
      "135: }",
      "137: }",
      "",
      "[Removed Lines]",
      "110:     return \"\";",
      "113:   using namespace boost::archive::iterators;",
      "114:   using b64it =",
      "115:     transform_width<binary_from_base64<std::string::const_iterator>, 8, 6>;",
      "117:   std::string decoded = std::string(b64it(std::begin(encoded)),",
      "118:                                     b64it(std::end(encoded)));",
      "120:   uint32_t numPadding = std::count(encoded.begin(), encoded.end(), '=');",
      "121:   decoded.erase(decoded.end() - numPadding, decoded.end());",
      "123:   return decoded;",
      "127:   using namespace boost::archive::iterators;",
      "128:   using b64it = base64_from_binary<transform_width<const char*, 6, 8>>;",
      "130:   auto data = input.data();",
      "131:   std::string encoded(b64it(data), b64it(data + (input.length())));",
      "132:   encoded.append((3 - (input.length() % 3)) % 3, '=');",
      "134:   return encoded;",
      "",
      "[Added Lines]",
      "109:     return std::string();",
      "112:   int padding = 0;",
      "113:   for (auto it = encoded.rbegin();",
      "114:        padding < 2 && it != encoded.rend() && *it == '=';",
      "115:        ++it) {",
      "116:     ++padding;",
      "117:   }",
      "119:   return Base64::decode(encoded, padding);",
      "123:   return Base64::encode(folly::ByteRange(",
      "124:                             reinterpret_cast<const uint8_t*>(input.c_str()),",
      "125:                             input.length()));",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "6dc1eb5dde8caef88ecc810fa4b40098e01fa4b8",
      "candidate_info": {
        "commit_hash": "6dc1eb5dde8caef88ecc810fa4b40098e01fa4b8",
        "repo": "facebook/proxygen",
        "commit_url": "https://github.com/facebook/proxygen/commit/6dc1eb5dde8caef88ecc810fa4b40098e01fa4b8",
        "files": [
          "proxygen/lib/http/structuredheaders/StructuredHeadersBuffer.cpp",
          "proxygen/lib/http/structuredheaders/StructuredHeadersBuffer.h",
          "proxygen/lib/http/structuredheaders/StructuredHeadersConstants.h",
          "proxygen/lib/http/structuredheaders/StructuredHeadersDecoder.cpp",
          "proxygen/lib/http/structuredheaders/StructuredHeadersDecoder.h",
          "proxygen/lib/http/structuredheaders/StructuredHeadersEncoder.cpp",
          "proxygen/lib/http/structuredheaders/StructuredHeadersEncoder.h",
          "proxygen/lib/http/structuredheaders/StructuredHeadersUtilities.cpp",
          "proxygen/lib/http/structuredheaders/StructuredHeadersUtilities.h",
          "proxygen/lib/http/structuredheaders/test/StructuredHeadersBufferTest.cpp",
          "proxygen/lib/http/structuredheaders/test/StructuredHeadersDecoderTest.cpp",
          "proxygen/lib/http/structuredheaders/test/StructuredHeadersEncoderTest.cpp",
          "proxygen/lib/http/structuredheaders/test/StructuredHeadersUtilitiesTest.cpp"
        ],
        "message": "Added Structured Headers functionality\n\nSummary: Added in functionality to decode and encode structured headers, as per https://tools.ietf.org/html/draft-ietf-httpbis-header-structure-07\n\nReviewed By: jalopezsilva, mjoras\n\nDifferential Revision: D8885631\n\nfbshipit-source-id: 84eef4d7bcd2379b081c406c1358134b25a38b4d",
        "before_after_code_files": [
          "proxygen/lib/http/structuredheaders/StructuredHeadersBuffer.cpp||proxygen/lib/http/structuredheaders/StructuredHeadersBuffer.cpp",
          "proxygen/lib/http/structuredheaders/StructuredHeadersBuffer.h||proxygen/lib/http/structuredheaders/StructuredHeadersBuffer.h",
          "proxygen/lib/http/structuredheaders/StructuredHeadersConstants.h||proxygen/lib/http/structuredheaders/StructuredHeadersConstants.h",
          "proxygen/lib/http/structuredheaders/StructuredHeadersDecoder.cpp||proxygen/lib/http/structuredheaders/StructuredHeadersDecoder.cpp",
          "proxygen/lib/http/structuredheaders/StructuredHeadersDecoder.h||proxygen/lib/http/structuredheaders/StructuredHeadersDecoder.h",
          "proxygen/lib/http/structuredheaders/StructuredHeadersEncoder.cpp||proxygen/lib/http/structuredheaders/StructuredHeadersEncoder.cpp",
          "proxygen/lib/http/structuredheaders/StructuredHeadersEncoder.h||proxygen/lib/http/structuredheaders/StructuredHeadersEncoder.h",
          "proxygen/lib/http/structuredheaders/StructuredHeadersUtilities.cpp||proxygen/lib/http/structuredheaders/StructuredHeadersUtilities.cpp",
          "proxygen/lib/http/structuredheaders/StructuredHeadersUtilities.h||proxygen/lib/http/structuredheaders/StructuredHeadersUtilities.h",
          "proxygen/lib/http/structuredheaders/test/StructuredHeadersBufferTest.cpp||proxygen/lib/http/structuredheaders/test/StructuredHeadersBufferTest.cpp",
          "proxygen/lib/http/structuredheaders/test/StructuredHeadersDecoderTest.cpp||proxygen/lib/http/structuredheaders/test/StructuredHeadersDecoderTest.cpp",
          "proxygen/lib/http/structuredheaders/test/StructuredHeadersEncoderTest.cpp||proxygen/lib/http/structuredheaders/test/StructuredHeadersEncoderTest.cpp",
          "proxygen/lib/http/structuredheaders/test/StructuredHeadersUtilitiesTest.cpp||proxygen/lib/http/structuredheaders/test/StructuredHeadersUtilitiesTest.cpp"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "proxygen/lib/http/structuredheaders/StructuredHeadersUtilities.cpp||proxygen/lib/http/structuredheaders/StructuredHeadersUtilities.cpp"
          ],
          "candidate": [
            "proxygen/lib/http/structuredheaders/StructuredHeadersUtilities.cpp||proxygen/lib/http/structuredheaders/StructuredHeadersUtilities.cpp"
          ]
        }
      },
      "candidate_diff": {
        "proxygen/lib/http/structuredheaders/StructuredHeadersBuffer.cpp||proxygen/lib/http/structuredheaders/StructuredHeadersBuffer.cpp": [
          "File: proxygen/lib/http/structuredheaders/StructuredHeadersBuffer.cpp -> proxygen/lib/http/structuredheaders/StructuredHeadersBuffer.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "11: #include \"StructuredHeadersBuffer.h\"",
          "12: #include <boost/lexical_cast.hpp>",
          "13: #include \"StructuredHeadersUtilities.h\"// @manual=:utils",
          "15: namespace proxygen {",
          "17: using namespace StructuredHeaders;",
          "19: DecodeError StructuredHeadersBuffer::parseItem(StructuredHeaderItem& result) {",
          "21:   removeOptionalWhitespace();",
          "23:   if (isEmpty()) {",
          "24:     return handleDecodeError(DecodeError::UNEXPECTED_END_OF_BUFFER);",
          "25:   } else {",
          "26:     char firstCharacter = peek();",
          "27:     if (firstCharacter == '\"') {",
          "28:       return parseString(result);",
          "29:     } else if (firstCharacter == '*') {",
          "30:       return parseBinaryContent(result);",
          "31:     } else if (std::isdigit(firstCharacter) || firstCharacter == '-') {",
          "32:       return parseNumber(result);",
          "33:     } else {",
          "34:       return handleDecodeError(DecodeError::INVALID_CHARACTER);",
          "35:     }",
          "36:   }",
          "37: }",
          "39: DecodeError StructuredHeadersBuffer::parseNumber(StructuredHeaderItem& result) {",
          "40:   auto type = StructuredHeaderItem::Type::INT64;",
          "42:   bool positive = true;",
          "43:   std::string input;",
          "45:   if (isEmpty()) {",
          "46:     return handleDecodeError(DecodeError::UNEXPECTED_END_OF_BUFFER);",
          "47:   }",
          "49:   if (peek() == '-') {",
          "50:     advanceCursor();",
          "51:     positive = false;",
          "52:     input.push_back('-');",
          "53:   }",
          "55:   if (isEmpty()) {",
          "56:     return handleDecodeError(DecodeError::UNEXPECTED_END_OF_BUFFER);",
          "57:   }",
          "59:   if (!std::isdigit(peek())) {",
          "60:     return handleDecodeError(DecodeError::INVALID_CHARACTER);",
          "61:   }",
          "63:   while (!isEmpty()) {",
          "64:     char current = peek();",
          "65:     if (std::isdigit(current)) {",
          "66:       input.push_back(current);",
          "67:       advanceCursor();",
          "68:     } else if (type == StructuredHeaderItem::Type::INT64 && current == '.') {",
          "69:       type = StructuredHeaderItem::Type::DOUBLE;",
          "70:       input.push_back(current);",
          "71:       advanceCursor();",
          "72:     } else {",
          "73:       break;",
          "74:     }",
          "76:     int numDigits = input.length() - (positive ? 0 : 1);",
          "77:     if (type == StructuredHeaderItem::Type::INT64 &&",
          "78:        numDigits > StructuredHeaders::kMaxValidIntegerLength) {",
          "79:       return handleDecodeError(DecodeError::VALUE_TOO_LONG);",
          "80:     } else if (type == StructuredHeaderItem::Type::DOUBLE &&",
          "81:        numDigits > StructuredHeaders::kMaxValidFloatLength) {",
          "82:       return handleDecodeError(DecodeError::VALUE_TOO_LONG);",
          "83:     }",
          "84:   }",
          "86:   if (type == StructuredHeaderItem::Type::INT64) {",
          "87:     return parseInteger(input, result);",
          "88:   } else if (input.back() == '.') {",
          "89:     return handleDecodeError(DecodeError::INVALID_CHARACTER);",
          "90:   } else {",
          "91:     return parseFloat(input, result);",
          "92:   }",
          "94:   return DecodeError::OK;",
          "95: }",
          "97: DecodeError StructuredHeadersBuffer::parseBinaryContent(",
          "98:   StructuredHeaderItem& result) {",
          "100:   std::string outputString;",
          "101:   if (isEmpty()) {",
          "102:     return handleDecodeError(DecodeError::UNEXPECTED_END_OF_BUFFER);",
          "103:   }",
          "105:   if (peek() != '*') {",
          "106:     return handleDecodeError(DecodeError::INVALID_CHARACTER);",
          "107:   }",
          "109:   advanceCursor();",
          "111:   while (!isEmpty()) {",
          "112:     char current = peek();",
          "113:     advanceCursor();",
          "114:     if (current == '*') {",
          "115:       if (!isValidEncodedBinaryContent(",
          "116:          outputString)) {",
          "117:         return handleDecodeError(DecodeError::UNDECODEABLE_BINARY_CONTENT);",
          "118:       }",
          "120:       std::string decodedContent = decodeBase64(outputString);",
          "121:       if (encodeBase64(decodedContent) != outputString) {",
          "122:         return handleDecodeError(DecodeError::UNDECODEABLE_BINARY_CONTENT);",
          "123:       }",
          "125:       result.value = std::move(decodedContent);",
          "126:       result.tag = StructuredHeaderItem::Type::BINARYCONTENT;",
          "127:       return DecodeError::OK;",
          "128:     } else if (!isValidEncodedBinaryContentChar(",
          "129:         current)) {",
          "130:       return handleDecodeError(DecodeError::INVALID_CHARACTER);",
          "131:     } else {",
          "132:       outputString.push_back(current);",
          "133:     }",
          "134:   }",
          "136:   return handleDecodeError(DecodeError::UNEXPECTED_END_OF_BUFFER);",
          "137: }",
          "139: DecodeError StructuredHeadersBuffer::parseIdentifier(",
          "140:   StructuredHeaderItem& result) {",
          "142:   std::string outputString;",
          "144:   auto err = parseIdentifier(outputString);",
          "145:   if (err != DecodeError::OK) {",
          "146:     return err;",
          "147:   }",
          "149:   result.value = outputString;",
          "150:   result.tag = StructuredHeaderItem::Type::IDENTIFIER;",
          "152:   return DecodeError::OK;",
          "153: }",
          "155: DecodeError StructuredHeadersBuffer::parseIdentifier(",
          "156:   std::string& result) {",
          "158:   if (isEmpty()) {",
          "159:     return handleDecodeError(DecodeError::UNEXPECTED_END_OF_BUFFER);",
          "160:   }",
          "162:   if (!isLcAlpha(peek())) {",
          "163:     return handleDecodeError(DecodeError::INVALID_CHARACTER);",
          "164:   }",
          "166:   while (!isEmpty()) {",
          "167:     char current = peek();",
          "168:     if (!isValidIdentifierChar(current)) {",
          "169:       break;",
          "170:     } else {",
          "171:       advanceCursor();",
          "172:       result.push_back(current);",
          "173:     }",
          "174:   }",
          "176:   return DecodeError::OK;",
          "177: }",
          "179: DecodeError StructuredHeadersBuffer::parseInteger(const std::string& input,",
          "180:   StructuredHeaderItem& result) {",
          "182:   try {",
          "183:     result.value = boost::lexical_cast<int64_t>(input);",
          "184:     result.tag = StructuredHeaderItem::Type::INT64;",
          "185:   } catch (boost::bad_lexical_cast &) {",
          "186:     return handleDecodeError(DecodeError::UNPARSEABLE_NUMERIC_TYPE);",
          "187:   }",
          "188:   return DecodeError::OK;",
          "189: }",
          "191: DecodeError StructuredHeadersBuffer::parseFloat(const std::string& input,",
          "192:   StructuredHeaderItem& result) {",
          "194:   try {",
          "195:     result.value = boost::lexical_cast<double>(input);",
          "196:     result.tag = StructuredHeaderItem::Type::DOUBLE;",
          "197:   } catch (boost::bad_lexical_cast &) {",
          "198:     return handleDecodeError(DecodeError::UNPARSEABLE_NUMERIC_TYPE);",
          "199:   }",
          "200:   return DecodeError::OK;",
          "201: }",
          "203: DecodeError StructuredHeadersBuffer::parseString(StructuredHeaderItem& result) {",
          "205:   std::string outputString;",
          "207:   if (isEmpty()) {",
          "208:     return handleDecodeError(DecodeError::UNEXPECTED_END_OF_BUFFER);",
          "209:   }",
          "211:   if (peek() != '\"') {",
          "212:     return handleDecodeError(DecodeError::INVALID_CHARACTER);",
          "213:   }",
          "215:   advanceCursor();",
          "217:   while (!isEmpty()) {",
          "218:     char current = peek();",
          "219:     if (current == '\\\\') {",
          "220:       advanceCursor();",
          "221:       if (isEmpty()) {",
          "222:         return handleDecodeError(DecodeError::UNEXPECTED_END_OF_BUFFER);",
          "223:       } else {",
          "224:         char nextChar = peek();",
          "225:         advanceCursor();",
          "226:         if (nextChar != '\"' && nextChar != '\\\\') {",
          "227:           return handleDecodeError(DecodeError::INVALID_CHARACTER);",
          "228:         }",
          "229:         outputString.push_back(nextChar);",
          "230:       }",
          "231:     } else if (current == '\"') {",
          "232:       advanceCursor();",
          "233:       result.value = outputString;",
          "234:       result.tag = StructuredHeaderItem::Type::STRING;",
          "235:       return DecodeError::OK;",
          "236:     } else if (!isValidStringChar(current)) {",
          "237:       return handleDecodeError(DecodeError::INVALID_CHARACTER);",
          "238:     } else {",
          "239:       advanceCursor();",
          "240:       outputString.push_back(current);",
          "241:     }",
          "242:   }",
          "244:   return handleDecodeError(DecodeError::UNEXPECTED_END_OF_BUFFER);",
          "245: }",
          "247: DecodeError StructuredHeadersBuffer::removeOptionalWhitespace() {",
          "248:   while (peek() == ' ' || peek() == '\\t') {",
          "249:     advanceCursor();",
          "250:   }",
          "251:   return DecodeError::OK;",
          "252: }",
          "254: DecodeError StructuredHeadersBuffer::removeSymbol(const std::string& symbol,",
          "255:   bool strict) {",
          "257:   if (content_.startsWith(symbol)) {",
          "258:     content_.advance(symbol.length());",
          "259:     return DecodeError::OK;",
          "260:   } else {",
          "261:     if (strict) {",
          "263:       return handleDecodeError(DecodeError::INVALID_CHARACTER);",
          "264:     }",
          "265:     return DecodeError::INVALID_CHARACTER;",
          "266:   }",
          "267: }",
          "269: DecodeError StructuredHeadersBuffer::handleDecodeError(const DecodeError& err) {",
          "270:   LOG_EVERY_N(ERROR, 1000) << \"Error message: \" <<",
          "271:     decodeErrorDescription.at(err) <<",
          "272:     \". Number of characters parsed before error:\" <<",
          "273:     getNumCharsParsed() << \". Header Content:\" << originalContent_.str();",
          "274:   return err;",
          "275: }",
          "277: char StructuredHeadersBuffer::peek() {",
          "278:   return *content_.begin();",
          "279: }",
          "281: void StructuredHeadersBuffer::advanceCursor() {",
          "282:   content_.advance(1);",
          "283: }",
          "285: bool StructuredHeadersBuffer::isEmpty() {",
          "286:   return content_.begin() == content_.end();",
          "287: }",
          "289: int32_t StructuredHeadersBuffer::getNumCharsParsed() {",
          "290:   return std::distance(originalContent_.begin(), content_.begin());",
          "291: }",
          "293: }",
          "",
          "---------------"
        ],
        "proxygen/lib/http/structuredheaders/StructuredHeadersBuffer.h||proxygen/lib/http/structuredheaders/StructuredHeadersBuffer.h": [
          "File: proxygen/lib/http/structuredheaders/StructuredHeadersBuffer.h -> proxygen/lib/http/structuredheaders/StructuredHeadersBuffer.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "10: #pragma once",
          "12: #include <string>",
          "13: #include <folly/Range.h>",
          "14: #include \"StructuredHeadersConstants.h\"",
          "16: namespace proxygen {",
          "18: using namespace StructuredHeaders;",
          "20: class StructuredHeadersBuffer {",
          "21: public:",
          "23:   explicit StructuredHeadersBuffer(const std::string& s) :",
          "24:     content_(s),",
          "25:     originalContent_(s) {}",
          "33:   StructuredHeaders::DecodeError parseIdentifier(StructuredHeaderItem& result);",
          "35:   StructuredHeaders::DecodeError parseIdentifier(std::string& result);",
          "37:   StructuredHeaders::DecodeError parseItem(StructuredHeaderItem& result);",
          "39:   DecodeError removeSymbol(const std::string& symbol, bool strict);",
          "41:   DecodeError removeOptionalWhitespace();",
          "43:   bool isEmpty();",
          "45:   DecodeError handleDecodeError(const DecodeError& err);",
          "47: private:",
          "49:   DecodeError parseBinaryContent(StructuredHeaderItem& result);",
          "51:   DecodeError parseNumber(StructuredHeaderItem& result);",
          "53:   DecodeError parseString(StructuredHeaderItem& result);",
          "55:   DecodeError parseInteger(const std::string& input,",
          "56:     StructuredHeaderItem& result);",
          "58:   DecodeError parseFloat(const std::string& input,",
          "59:     StructuredHeaderItem& result);",
          "61:   char peek();",
          "63:   void advanceCursor();",
          "65:   int32_t getNumCharsParsed();",
          "67:   folly::StringPiece content_;",
          "68:   folly::StringPiece originalContent_;",
          "69: };",
          "71: }",
          "",
          "---------------"
        ],
        "proxygen/lib/http/structuredheaders/StructuredHeadersConstants.h||proxygen/lib/http/structuredheaders/StructuredHeadersConstants.h": [
          "File: proxygen/lib/http/structuredheaders/StructuredHeadersConstants.h -> proxygen/lib/http/structuredheaders/StructuredHeadersConstants.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "10: #pragma once",
          "12: #include <unordered_map>",
          "13: #include <map>",
          "14: #include <boost/variant.hpp>",
          "16: namespace proxygen {",
          "18: namespace StructuredHeaders {",
          "20: static const int kMaxValidIntegerLength = 19;",
          "21: static const int kMaxValidFloatLength = 16;",
          "24: class StructuredHeaderItem {",
          "25: public:",
          "26:   enum class Type {",
          "27:     NONE,",
          "28:     STRING,",
          "29:     BINARYCONTENT,",
          "30:     IDENTIFIER,",
          "31:     DOUBLE,",
          "32:     INT64",
          "33:   };",
          "35:   template<typename T>",
          "36:   bool operator!=(const T& other) const {",
          "37:     return !operator==(other);",
          "38:   }",
          "40:   template<typename T>",
          "41:   bool operator==(const T& other) const {",
          "42:     try {",
          "43:       return boost::get<T>(value) == other;",
          "44:     } catch (boost::bad_get& ) {",
          "45:       return false;",
          "46:     }",
          "47:   }",
          "49:   Type tag;",
          "50:   boost::variant<int64_t, double, std::string> value;",
          "51: };",
          "53: struct ParameterisedIdentifier {",
          "54:   std::string identifier;",
          "55:   std::unordered_map<std::string, StructuredHeaderItem> parameterMap;",
          "56: };",
          "58: using ParameterisedList =",
          "59:   std::vector<StructuredHeaders::ParameterisedIdentifier>;",
          "61: using Dictionary = std::unordered_map<std::string, StructuredHeaderItem>;",
          "63: enum class DecodeError : uint8_t {",
          "64:   OK = 0,",
          "65:   VALUE_TOO_LONG = 1,",
          "66:   INVALID_CHARACTER = 2,",
          "67:   UNDECODEABLE_BINARY_CONTENT = 3,",
          "68:   UNEXPECTED_END_OF_BUFFER = 4,",
          "69:   UNPARSEABLE_NUMERIC_TYPE = 5,",
          "70:   DUPLICATE_KEY = 6",
          "71: };",
          "73: enum class EncodeError : uint8_t {",
          "74:   OK = 0,",
          "75:   EMPTY_DATA_STRUCTURE = 1,",
          "76:   BAD_IDENTIFIER = 2,",
          "77:   BAD_STRING = 3,",
          "78:   ITEM_TYPE_MISMATCH = 4,",
          "79:   ENCODING_NULL_ITEM = 5",
          "80: };",
          "82: static const std::map<DecodeError, std::string>",
          "83:   decodeErrorDescription {",
          "84:     {DecodeError::OK, \"No error\"},",
          "85:     {DecodeError::VALUE_TOO_LONG, \"Numeric value is too long\"},",
          "86:     {DecodeError::INVALID_CHARACTER, \"Invalid character\"},",
          "87:     {DecodeError::UNDECODEABLE_BINARY_CONTENT, \"Undecodable binary content\"},",
          "88:     {DecodeError::UNEXPECTED_END_OF_BUFFER, \"Unexpected end of buffer\"},",
          "89:     {DecodeError::UNPARSEABLE_NUMERIC_TYPE, \"Unparseable numeric type\"},",
          "90:     {DecodeError::DUPLICATE_KEY, \"Duplicate key found\"}",
          "91: };",
          "93: static const std::map<EncodeError, std::string>",
          "94:   encodeErrorDescription {",
          "95:     {EncodeError::OK, \"No error\"},",
          "96:     {EncodeError::EMPTY_DATA_STRUCTURE, \"Empty data structure\"},",
          "97:     {EncodeError::BAD_IDENTIFIER, \"Bad identifier\"},",
          "98:     {EncodeError::BAD_STRING, \"Bad string\"},",
          "99:     {EncodeError::ITEM_TYPE_MISMATCH, \"Item type mismatch\"},",
          "100:     {EncodeError::ENCODING_NULL_ITEM, \"Tried to encode null item\"}",
          "101: };",
          "103: }",
          "104: }",
          "",
          "---------------"
        ],
        "proxygen/lib/http/structuredheaders/StructuredHeadersDecoder.cpp||proxygen/lib/http/structuredheaders/StructuredHeadersDecoder.cpp": [
          "File: proxygen/lib/http/structuredheaders/StructuredHeadersDecoder.cpp -> proxygen/lib/http/structuredheaders/StructuredHeadersDecoder.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "11: #include \"StructuredHeadersDecoder.h\"",
          "13: namespace proxygen {",
          "15: using namespace StructuredHeaders;",
          "17: DecodeError StructuredHeadersDecoder::decodeItem(",
          "18:   StructuredHeaderItem& result) {",
          "19:     auto err = buf_.parseItem(result);",
          "20:     if (err != DecodeError::OK) {",
          "21:       return err;",
          "22:     }",
          "23:     return buf_.isEmpty() ?",
          "24:       DecodeError::OK : buf_.handleDecodeError(DecodeError::INVALID_CHARACTER);",
          "25: }",
          "27: DecodeError StructuredHeadersDecoder::decodeList(",
          "28:    std::vector<StructuredHeaderItem>& result) {",
          "30:   while (!buf_.isEmpty()) {",
          "32:     StructuredHeaderItem item;",
          "33:     auto err = buf_.parseItem(item);",
          "34:     if (err != DecodeError::OK) {",
          "35:       return err;",
          "36:     }",
          "38:     result.push_back(item);",
          "40:     buf_.removeOptionalWhitespace();",
          "42:     if (buf_.isEmpty()) {",
          "43:       return DecodeError::OK;",
          "44:     }",
          "46:     err = buf_.removeSymbol(\",\", true);",
          "47:     if (err != DecodeError::OK) {",
          "48:       return err;",
          "49:     }",
          "51:     buf_.removeOptionalWhitespace();",
          "53:     if (buf_.isEmpty()) {",
          "54:       return buf_.handleDecodeError(DecodeError::UNEXPECTED_END_OF_BUFFER);",
          "55:     }",
          "56:   }",
          "58:   return buf_.handleDecodeError(DecodeError::UNEXPECTED_END_OF_BUFFER);",
          "59: }",
          "61: DecodeError StructuredHeadersDecoder::decodeDictionary(Dictionary& result) {",
          "62:   return decodeMap(result, MapType::DICTIONARY);",
          "63: }",
          "65: DecodeError StructuredHeadersDecoder::decodeParameterisedList(",
          "66:   ParameterisedList& result) {",
          "68:   while (!buf_.isEmpty()) {",
          "70:     ParameterisedIdentifier primaryIdentifier;",
          "72:     auto err = buf_.parseIdentifier(primaryIdentifier.identifier);",
          "73:     if (err != DecodeError::OK) {",
          "74:       return err;",
          "75:     }",
          "77:     buf_.removeOptionalWhitespace();",
          "79:     err = decodeMap(primaryIdentifier.parameterMap, MapType::PARAMETERISED_MAP);",
          "80:     if (err != DecodeError::OK) {",
          "81:       return err;",
          "82:     }",
          "84:     result.emplace_back(primaryIdentifier);",
          "86:     buf_.removeOptionalWhitespace();",
          "88:     if (buf_.isEmpty()) {",
          "89:       return DecodeError::OK;",
          "90:     }",
          "92:     if (buf_.removeSymbol(\",\", true) != DecodeError::OK) {",
          "93:       return err;",
          "94:     }",
          "96:     buf_.removeOptionalWhitespace();",
          "98:   }",
          "100:   return buf_.handleDecodeError(DecodeError::UNEXPECTED_END_OF_BUFFER);",
          "101: }",
          "103: DecodeError StructuredHeadersDecoder::decodeMap(",
          "104:   std::unordered_map<std::string, StructuredHeaderItem>& result,",
          "105:   MapType mapType) {",
          "107:   std::string delimiter = (mapType == MapType::PARAMETERISED_MAP) ? \";\" : \",\";",
          "109:   buf_.removeOptionalWhitespace();",
          "111:   if ((mapType == MapType::PARAMETERISED_MAP) &&",
          "112:       (buf_.removeSymbol(delimiter, false) != DecodeError::OK)) {",
          "113:     return DecodeError::OK;",
          "114:   }",
          "116:   while (!buf_.isEmpty()) {",
          "118:     buf_.removeOptionalWhitespace();",
          "120:     std::string thisKey;",
          "121:     auto err = buf_.parseIdentifier(thisKey);",
          "122:     if (err != DecodeError::OK) {",
          "123:       return err;",
          "124:     }",
          "126:     if (result.find(thisKey) != result.end()) {",
          "127:       return buf_.handleDecodeError(DecodeError::DUPLICATE_KEY);",
          "128:     }",
          "130:     err = buf_.removeSymbol(\"=\", mapType == MapType::DICTIONARY);",
          "131:     if (err != DecodeError::OK) {",
          "132:       if (mapType == MapType::DICTIONARY) {",
          "133:         return err;",
          "134:       } else {",
          "135:         StructuredHeaderItem value;",
          "136:         value.tag = StructuredHeaderItem::Type::NONE;",
          "137:         result[thisKey] = value;",
          "138:       }",
          "139:     } else {",
          "140:       StructuredHeaderItem value;",
          "141:       err = buf_.parseItem(value);",
          "142:       if (err != DecodeError::OK) {",
          "143:         return err;",
          "144:       }",
          "146:       result[thisKey] = value;",
          "147:     }",
          "149:     buf_.removeOptionalWhitespace();",
          "151:     if (buf_.isEmpty()) {",
          "152:       return DecodeError::OK;",
          "153:     }",
          "155:     err = buf_.removeSymbol(delimiter, mapType == MapType::DICTIONARY);",
          "156:     if (err != DecodeError::OK) {",
          "157:       if (mapType == MapType::PARAMETERISED_MAP) {",
          "158:         return DecodeError::OK;",
          "159:       } else {",
          "160:         return err;",
          "161:       }",
          "162:     }",
          "163:   }",
          "165:   return buf_.handleDecodeError(DecodeError::UNEXPECTED_END_OF_BUFFER);",
          "167: }",
          "169: }",
          "",
          "---------------"
        ],
        "proxygen/lib/http/structuredheaders/StructuredHeadersDecoder.h||proxygen/lib/http/structuredheaders/StructuredHeadersDecoder.h": [
          "File: proxygen/lib/http/structuredheaders/StructuredHeadersDecoder.h -> proxygen/lib/http/structuredheaders/StructuredHeadersDecoder.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "10: #pragma once",
          "12: #include <unordered_map>",
          "13: #include <vector>",
          "14: #include \"StructuredHeadersBuffer.h\" // @manual=:structured_headers",
          "16: namespace proxygen {",
          "18: class StructuredHeadersDecoder {",
          "19: public:",
          "21:   explicit StructuredHeadersDecoder(const std::string& s): buf_(s) {}",
          "23:   StructuredHeaders::DecodeError decodeItem(StructuredHeaderItem& result);",
          "25:   StructuredHeaders::DecodeError",
          "26:     decodeList(std::vector<StructuredHeaderItem>& result);",
          "28:   StructuredHeaders::DecodeError decodeDictionary(Dictionary& result);",
          "30:   StructuredHeaders::DecodeError",
          "31:     decodeParameterisedList(ParameterisedList& result);",
          "33: private:",
          "34:   enum class MapType {",
          "35:     DICTIONARY = 0,",
          "36:     PARAMETERISED_MAP = 1",
          "37:   };",
          "39:   StructuredHeaders::DecodeError decodeMap(",
          "40:     std::unordered_map<std::string, StructuredHeaderItem>& result,",
          "41:     MapType mapType);",
          "43:   StructuredHeadersBuffer buf_;",
          "44: };",
          "46: }",
          "",
          "---------------"
        ],
        "proxygen/lib/http/structuredheaders/StructuredHeadersEncoder.cpp||proxygen/lib/http/structuredheaders/StructuredHeadersEncoder.cpp": [
          "File: proxygen/lib/http/structuredheaders/StructuredHeadersEncoder.cpp -> proxygen/lib/http/structuredheaders/StructuredHeadersEncoder.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "11: #include \"StructuredHeadersEncoder.h\"",
          "12: #include <typeinfo>",
          "13: #include <boost/lexical_cast.hpp>",
          "14: #include <boost/variant.hpp>",
          "15: #include <glog/logging.h>",
          "16: #include \"StructuredHeadersUtilities.h\" // @manual=:utils",
          "18: namespace proxygen {",
          "20: using namespace StructuredHeaders;",
          "22: EncodeError StructuredHeadersEncoder::encodeList(",
          "23:   const std::vector<StructuredHeaderItem>& input) {",
          "25:   if (input.empty()) {",
          "26:     return handleEncodeError(EncodeError::EMPTY_DATA_STRUCTURE);",
          "27:   }",
          "29:   for (auto it = input.begin(); it != input.end(); it++) {",
          "30:     auto err = encodeItem(*it);",
          "31:     if (err != EncodeError::OK) {",
          "32:       return err;",
          "33:     }",
          "35:     if (std::next(it, 1)!= input.end()) {",
          "36:       outputStream_ << \", \";",
          "37:     }",
          "38:   }",
          "40:   return EncodeError::OK;",
          "41: }",
          "43: EncodeError StructuredHeadersEncoder::encodeDictionary(",
          "44:   const Dictionary& input) {",
          "46:   if (input.empty()) {",
          "47:     return handleEncodeError(EncodeError::EMPTY_DATA_STRUCTURE);",
          "48:   }",
          "50:   for (auto it = input.begin(); it != input.end(); it++) {",
          "51:     auto err = encodeIdentifier(it->first);",
          "52:     if (err != EncodeError::OK) {",
          "53:       return err;",
          "54:     }",
          "56:     outputStream_ << \"=\";",
          "58:     err = encodeItem(it->second);",
          "59:     if (err != EncodeError::OK) {",
          "60:       return err;",
          "61:     }",
          "63:     if (std::next(it, 1) != input.end()) {",
          "64:       outputStream_ << \", \";",
          "65:     }",
          "66:   }",
          "68:   return EncodeError::OK;",
          "69: }",
          "71: EncodeError StructuredHeadersEncoder::encodeParameterisedList(",
          "72:   const ParameterisedList& input) {",
          "74:   if (input.empty()) {",
          "75:     return handleEncodeError(EncodeError::EMPTY_DATA_STRUCTURE);",
          "76:   }",
          "78:   for (auto it1 = input.begin(); it1 != input.end(); it1++) {",
          "79:     auto err = encodeIdentifier(it1->identifier);",
          "80:     if (err != EncodeError::OK) {",
          "81:       return err;",
          "82:     }",
          "84:     for (auto it2 = it1->parameterMap.begin();",
          "85:       it2 != it1->parameterMap.end(); it2++) {",
          "87:       outputStream_ << \"; \";",
          "89:       err = encodeIdentifier(it2->first);",
          "90:       if (err != EncodeError::OK) {",
          "91:         return err;",
          "92:       }",
          "94:       if (it2->second.tag != StructuredHeaderItem::Type::NONE) {",
          "95:         outputStream_ << \"=\";",
          "96:         err = encodeItem(it2->second);",
          "97:         if (err != EncodeError::OK) {",
          "98:           return err;",
          "99:         }",
          "100:       }",
          "101:     }",
          "103:     if (std::next(it1, 1) != input.end()) {",
          "104:       outputStream_ << \", \";",
          "105:     }",
          "106:   }",
          "108:   return EncodeError::OK;",
          "109: }",
          "111: StructuredHeadersEncoder::StructuredHeadersEncoder():",
          "112:    output_(),",
          "113:    buf_(output_),",
          "114:    outputStream_(&buf_) {",
          "115:   outputStream_.precision(kMaxValidFloatLength - 1);",
          "116: }",
          "118: EncodeError StructuredHeadersEncoder::encodeItem(",
          "119:   const StructuredHeaderItem& input) {",
          "121:   if (!itemTypeMatchesContent(input)) {",
          "122:     return handleEncodeError(EncodeError::ITEM_TYPE_MISMATCH);",
          "123:   }",
          "125:   switch (input.tag) {",
          "126:     case StructuredHeaderItem::Type::STRING:",
          "127:       return encodeString(boost::get<std::string>(input.value));",
          "128:     case StructuredHeaderItem::Type::INT64:",
          "129:       return encodeInteger(boost::get<int64_t>(input.value));",
          "130:     case StructuredHeaderItem::Type::DOUBLE:",
          "131:       return encodeFloat(boost::get<double>(input.value));",
          "132:     case StructuredHeaderItem::Type::BINARYCONTENT:",
          "133:       return encodeBinaryContent(",
          "134:         boost::get<std::string>(input.value));",
          "135:     default:",
          "136:       return handleEncodeError(EncodeError::ENCODING_NULL_ITEM);",
          "137:   }",
          "139:   return EncodeError::OK;",
          "140: }",
          "142: EncodeError StructuredHeadersEncoder::encodeBinaryContent(",
          "143:    const std::string& input) {",
          "145:   outputStream_ << \"*\";",
          "146:   outputStream_ << encodeBase64(input);",
          "147:   outputStream_ << \"*\";",
          "149:   return EncodeError::OK;",
          "150: }",
          "152: EncodeError StructuredHeadersEncoder::encodeString(const std::string& input) {",
          "154:   if (!isValidString(input)) {",
          "155:     return handleEncodeError(EncodeError::BAD_STRING, input);",
          "156:   }",
          "158:   outputStream_ << \"\\\"\";",
          "159:   for (char c : input) {",
          "160:     if (c == '\"' || c == '\\\\') {",
          "161:       outputStream_ << \"\\\\\";",
          "162:     }",
          "163:     outputStream_ << c;",
          "164:   }",
          "166:   outputStream_ << \"\\\"\";",
          "168:   return EncodeError::OK;",
          "169: }",
          "171: EncodeError StructuredHeadersEncoder::encodeInteger(int64_t input) {",
          "173:   outputStream_ << input;",
          "175:   return EncodeError::OK;",
          "176: }",
          "178: EncodeError StructuredHeadersEncoder::encodeFloat(double input) {",
          "180:   outputStream_ << input;",
          "182:   return EncodeError::OK;",
          "183: }",
          "185: EncodeError StructuredHeadersEncoder::encodeIdentifier(",
          "186:   const std::string &input) {",
          "188:   if (!isValidIdentifier(input)) {",
          "189:     return handleEncodeError(EncodeError::BAD_IDENTIFIER, input);",
          "190:   }",
          "191:   outputStream_ << input;",
          "192:   return EncodeError::OK;",
          "193: }",
          "197: EncodeError StructuredHeadersEncoder::handleEncodeError(EncodeError err,",
          "198:   const std::string &culprit) {",
          "200:   LOG_EVERY_N(ERROR, 1000) << \"Error message: \" <<",
          "201:     encodeErrorDescription.at(err) << \" .The culprit was: \" << culprit;",
          "202:   return err;",
          "203: }",
          "206: EncodeError StructuredHeadersEncoder::handleEncodeError(EncodeError err) {",
          "207:   LOG_EVERY_N(ERROR, 1000) << \"Error message: \" <<",
          "208:     encodeErrorDescription.at(err);",
          "209:   return err;",
          "210: }",
          "212: std::string StructuredHeadersEncoder::get() {",
          "213:   outputStream_.flush();",
          "214:   return std::move(output_);",
          "215: }",
          "217: }",
          "",
          "---------------"
        ],
        "proxygen/lib/http/structuredheaders/StructuredHeadersEncoder.h||proxygen/lib/http/structuredheaders/StructuredHeadersEncoder.h": [
          "File: proxygen/lib/http/structuredheaders/StructuredHeadersEncoder.h -> proxygen/lib/http/structuredheaders/StructuredHeadersEncoder.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "11: #pragma once",
          "13: #include \"StructuredHeadersConstants.h\"",
          "14: #include <ostream>",
          "15: #include <string>",
          "16: #include <unordered_map>",
          "17: #include <vector>",
          "18: #include <boost/iostreams/device/back_inserter.hpp>",
          "19: #include <boost/iostreams/stream_buffer.hpp>",
          "21: namespace proxygen {",
          "23: using namespace StructuredHeaders;",
          "25: using string_buf = boost::iostreams::stream_buffer<",
          "26:   boost::iostreams::back_insert_device<std::string> >;",
          "28: class StructuredHeadersEncoder {",
          "30:  public:",
          "32:    StructuredHeadersEncoder();",
          "34:    EncodeError encodeParameterisedList(const ParameterisedList& input);",
          "36:    EncodeError encodeDictionary(const Dictionary& input);",
          "38:    EncodeError encodeList(const std::vector<StructuredHeaderItem>& input);",
          "40:    EncodeError encodeItem(const StructuredHeaderItem& input);",
          "42:    EncodeError encodeIdentifier(const std::string& input);",
          "44:    std::string get();",
          "46:  private:",
          "48:    EncodeError encodeBinaryContent(const std::string& input);",
          "50:    EncodeError encodeString(const std::string& input);",
          "52:    EncodeError encodeInteger(int64_t input);",
          "54:    EncodeError encodeFloat(double input);",
          "56:    EncodeError handleEncodeError(EncodeError err,",
          "57:      const std::string& badContent);",
          "59:    EncodeError handleEncodeError(EncodeError err);",
          "61:    std::string output_;",
          "62:    string_buf buf_;",
          "63:    std::ostream outputStream_;",
          "65: };",
          "67: }",
          "",
          "---------------"
        ],
        "proxygen/lib/http/structuredheaders/StructuredHeadersUtilities.cpp||proxygen/lib/http/structuredheaders/StructuredHeadersUtilities.cpp": [
          "File: proxygen/lib/http/structuredheaders/StructuredHeadersUtilities.cpp -> proxygen/lib/http/structuredheaders/StructuredHeadersUtilities.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "11: #include \"StructuredHeadersUtilities.h\"",
          "12: #include <boost/archive/iterators/binary_from_base64.hpp>",
          "13: #include <boost/archive/iterators/base64_from_binary.hpp>",
          "14: #include <boost/archive/iterators/transform_width.hpp>",
          "15: #include \"StructuredHeadersConstants.h\"",
          "17: namespace proxygen {",
          "18: namespace StructuredHeaders {",
          "20: bool isLcAlpha(char c) {",
          "21:   return c >= 0x61 && c <= 0x7A;",
          "22: }",
          "24: bool isValidIdentifierChar(char c) {",
          "25:   return isLcAlpha(c) || std::isdigit(c) || c == '_' || c == '-' || c == '*' ||",
          "26:     c == '/';",
          "27: }",
          "29: bool isValidEncodedBinaryContentChar(",
          "30:    char c) {",
          "31:   return std::isalpha(c) || std::isdigit(c) || c == '+' || c == '/' || c == '=';",
          "32: }",
          "34: bool isValidStringChar(char c) {",
          "42:   return c >= 0x20 && c <= 0x7E;",
          "43: }",
          "45: bool isValidIdentifier(const std::string& s) {",
          "46:   if (s.size() == 0 || !isLcAlpha(s[0])) {",
          "47:     return false;",
          "48:   }",
          "50:   for (char c : s) {",
          "51:     if (!isValidIdentifierChar(c)) {",
          "52:       return false;",
          "53:     }",
          "54:   }",
          "56:   return true;",
          "57: }",
          "59: bool isValidString(const std::string& s) {",
          "60:   for (char c : s) {",
          "61:     if (!isValidStringChar(c)) {",
          "62:       return false;",
          "63:     }",
          "64:   }",
          "65:   return true;",
          "66: }",
          "68: bool isValidEncodedBinaryContent(",
          "69:   const std::string& s) {",
          "71:   if (s.size() % 4 != 0) {",
          "72:     return false;",
          "73:   }",
          "75:   bool equalSeen = false;",
          "76:   for (auto it = s.begin(); it != s.end(); it++) {",
          "77:     if (*it == '=') {",
          "78:       equalSeen = true;",
          "79:     } else if (equalSeen || !isValidEncodedBinaryContentChar(*it)) {",
          "80:       return false;",
          "81:     }",
          "82:   }",
          "84:   return true;",
          "85: }",
          "87: bool itemTypeMatchesContent(",
          "88:    const StructuredHeaderItem& input) {",
          "89:   switch (input.tag) {",
          "90:     case StructuredHeaderItem::Type::BINARYCONTENT:",
          "91:     case StructuredHeaderItem::Type::IDENTIFIER:",
          "92:     case StructuredHeaderItem::Type::STRING:",
          "93:       return input.value.type() == typeid(std::string);",
          "94:     case StructuredHeaderItem::Type::INT64:",
          "95:       return input.value.type() == typeid(int64_t);",
          "96:     case StructuredHeaderItem::Type::DOUBLE:",
          "97:       return input.value.type() == typeid(double);",
          "98:     case StructuredHeaderItem::Type::NONE:",
          "99:       return true;",
          "100:   }",
          "102:   return false;",
          "103: }",
          "105: std::string decodeBase64(",
          "106:     const std::string& encoded) {",
          "108:   if (encoded.size() == 0) {",
          "110:     return \"\";",
          "111:   }",
          "113:   using namespace boost::archive::iterators;",
          "114:   using b64it =",
          "115:     transform_width<binary_from_base64<std::string::const_iterator>, 8, 6>;",
          "117:   std::string decoded = std::string(b64it(std::begin(encoded)),",
          "118:                                     b64it(std::end(encoded)));",
          "120:   uint32_t numPadding = std::count(encoded.begin(), encoded.end(), '=');",
          "121:   decoded.erase(decoded.end() - numPadding, decoded.end());",
          "123:   return decoded;",
          "124: }",
          "126: std::string encodeBase64(const std::string& input) {",
          "127:   using namespace boost::archive::iterators;",
          "128:   using b64it = base64_from_binary<transform_width<const char*, 6, 8>>;",
          "130:   auto data = input.data();",
          "131:   std::string encoded(b64it(data), b64it(data + (input.length())));",
          "132:   encoded.append((3 - (input.length() % 3)) % 3, '=');",
          "134:   return encoded;",
          "135: }",
          "137: }",
          "138: }",
          "",
          "---------------"
        ],
        "proxygen/lib/http/structuredheaders/StructuredHeadersUtilities.h||proxygen/lib/http/structuredheaders/StructuredHeadersUtilities.h": [
          "File: proxygen/lib/http/structuredheaders/StructuredHeadersUtilities.h -> proxygen/lib/http/structuredheaders/StructuredHeadersUtilities.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "10: #include <string>",
          "11: #include \"StructuredHeadersConstants.h\"",
          "13: #pragma once",
          "15: namespace proxygen {",
          "16: namespace StructuredHeaders {",
          "18: bool isLcAlpha(char c);",
          "20: bool isValidIdentifierChar(char c);",
          "22: bool isValidEncodedBinaryContentChar(char c);",
          "24: bool isValidStringChar(char c);",
          "26: bool isValidIdentifier(const std::string& s);",
          "28: bool isValidString(const std::string& s);",
          "30: bool isValidEncodedBinaryContent(const std::string& s);",
          "32: bool itemTypeMatchesContent(const StructuredHeaderItem& input);",
          "34: std::string decodeBase64(const std::string& encoded);",
          "36: std::string encodeBase64(const std::string& input);",
          "38: }",
          "39: }",
          "",
          "---------------"
        ],
        "proxygen/lib/http/structuredheaders/test/StructuredHeadersBufferTest.cpp||proxygen/lib/http/structuredheaders/test/StructuredHeadersBufferTest.cpp": [
          "File: proxygen/lib/http/structuredheaders/test/StructuredHeadersBufferTest.cpp -> proxygen/lib/http/structuredheaders/test/StructuredHeadersBufferTest.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "10: #include <proxygen/lib/http/structuredheaders/StructuredHeadersBuffer.h>",
          "11: #include <string>",
          "12: #include <folly/portability/GTest.h>",
          "13: #include <proxygen/lib/http/structuredheaders/StructuredHeadersConstants.h>",
          "14: #include <common/encode/Base64.h>",
          "16: namespace proxygen{",
          "18: using namespace facebook;",
          "20: class StructuredHeadersBufferTest : public testing::Test {",
          "21: };",
          "23: TEST_F(StructuredHeadersBufferTest, test_binary_content) {",
          "24:   std::string input = \"*bWF4aW0gaXMgdGhlIGJlc3Q=*\";",
          "25:   StructuredHeadersBuffer shd(input);",
          "26:   StructuredHeaderItem output;",
          "27:   auto err = shd.parseItem(output);",
          "28:   EXPECT_EQ(err, StructuredHeaders::DecodeError::OK);",
          "29:   EXPECT_EQ(output.tag, StructuredHeaderItem::Type::BINARYCONTENT);",
          "30:   EXPECT_EQ(output, std::string(\"maxim is the best\"));",
          "31: }",
          "33: TEST_F(StructuredHeadersBufferTest, test_binary_content_illegal_characters) {",
          "34:   std::string input = \"*()645\\t  this is not a b64 encoded string ((({]}}}))*\";",
          "35:   StructuredHeadersBuffer shd(input);",
          "36:   StructuredHeaderItem output;",
          "37:   auto err = shd.parseItem(output);",
          "38:   EXPECT_NE(err, StructuredHeaders::DecodeError::OK);",
          "39: }",
          "41: TEST_F(StructuredHeadersBufferTest, test_binary_content_no_ending_asterisk) {",
          "42:   std::string input = \"*seattle\";",
          "43:   StructuredHeadersBuffer shd(input);",
          "44:   StructuredHeaderItem output;",
          "45:   auto err = shd.parseItem(output);",
          "46:   EXPECT_NE(err, StructuredHeaders::DecodeError::OK);",
          "47: }",
          "49: TEST_F(StructuredHeadersBufferTest, test_binary_content_empty) {",
          "50:   std::string input = \"**\";",
          "51:   StructuredHeadersBuffer shd(input);",
          "52:   StructuredHeaderItem output;",
          "53:   auto err = shd.parseItem(output);",
          "54:   EXPECT_EQ(err, StructuredHeaders::DecodeError::OK);",
          "55:   EXPECT_EQ(output.tag, StructuredHeaderItem::Type::BINARYCONTENT);",
          "56:   EXPECT_EQ(output, std::string(\"\"));",
          "57: }",
          "59: TEST_F(StructuredHeadersBufferTest, test_identifier) {",
          "60:   std::string input = \"abcdefg\";",
          "61:   StructuredHeadersBuffer shd(input);",
          "62:   StructuredHeaderItem output;",
          "63:   auto err = shd.parseIdentifier(output);",
          "64:   EXPECT_EQ(err, StructuredHeaders::DecodeError::OK);",
          "65:   EXPECT_EQ(output.tag, StructuredHeaderItem::Type::IDENTIFIER);",
          "66:   EXPECT_EQ(output, std::string(\"abcdefg\"));",
          "67: }",
          "69: TEST_F(StructuredHeadersBufferTest, test_identifier_all_legal_characters) {",
          "70:   std::string input = \"a0_-*/\";",
          "71:   StructuredHeadersBuffer shd(input);",
          "72:   StructuredHeaderItem output;",
          "73:   auto err = shd.parseIdentifier(output);",
          "74:   EXPECT_EQ(err, StructuredHeaders::DecodeError::OK);",
          "75:   EXPECT_EQ(output.tag, StructuredHeaderItem::Type::IDENTIFIER);",
          "76:   EXPECT_EQ(output, std::string(\"a0_-*/\"));",
          "77: }",
          "79: TEST_F(StructuredHeadersBufferTest, test_identifier_beginning_underscore) {",
          "80:   std::string input = \"_af09d____****\";",
          "81:   StructuredHeadersBuffer shd(input);",
          "82:   StructuredHeaderItem output;",
          "83:   auto err = shd.parseIdentifier(output);",
          "84:   EXPECT_NE(err, StructuredHeaders::DecodeError::OK);",
          "85: }",
          "87: TEST_F(StructuredHeadersBufferTest, test_string) {",
          "88:   std::string input = \"\\\"fsdfsdf\\\"sdfsdf\\\"\";",
          "89:   StructuredHeadersBuffer shd(input);",
          "90:   StructuredHeaderItem output;",
          "91:   auto err = shd.parseItem(output);",
          "92:   EXPECT_EQ(err, StructuredHeaders::DecodeError::OK);",
          "93:   EXPECT_EQ(output.tag, StructuredHeaderItem::Type::STRING);",
          "94:   EXPECT_EQ(output, std::string(\"fsdfsdf\"));",
          "95: }",
          "97: TEST_F(StructuredHeadersBufferTest, test_string_escaped_quote) {",
          "98:   std::string input = \"\\\"abc\\\\\\\"def\\\"\";",
          "99:   StructuredHeadersBuffer shd(input);",
          "100:   StructuredHeaderItem output;",
          "101:   auto err = shd.parseItem(output);",
          "102:   EXPECT_EQ(err, StructuredHeaders::DecodeError::OK);",
          "103:   EXPECT_EQ(output.tag, StructuredHeaderItem::Type::STRING);",
          "104:   EXPECT_EQ(output, std::string(\"abc\\\"def\"));",
          "105: }",
          "107: TEST_F(StructuredHeadersBufferTest, test_string_escaped_backslash) {",
          "108:   std::string input = \"\\\"abc\\\\\\\\def\\\"\";",
          "109:   StructuredHeadersBuffer shd(input);",
          "110:   StructuredHeaderItem output;",
          "111:   auto err = shd.parseItem(output);",
          "112:   EXPECT_EQ(err, StructuredHeaders::DecodeError::OK);",
          "113:   EXPECT_EQ(output.tag, StructuredHeaderItem::Type::STRING);",
          "114:   EXPECT_EQ(output, std::string(\"abc\\\\def\"));",
          "115: }",
          "117: TEST_F(StructuredHeadersBufferTest, test_string_stray_backslash) {",
          "118:   std::string input = \"\\\"abc\\\\def\\\"\";",
          "119:   StructuredHeadersBuffer shd(input);",
          "120:   StructuredHeaderItem output;",
          "121:   auto err = shd.parseItem(output);",
          "122:   EXPECT_NE(err, StructuredHeaders::DecodeError::OK);",
          "123: }",
          "125: TEST_F(StructuredHeadersBufferTest, test_string_invalid_character) {",
          "126:   std::string input = \"\\\"abcdefg\\thij\\\"\";",
          "127:   StructuredHeadersBuffer shd(input);",
          "128:   StructuredHeaderItem output;",
          "129:   auto err = shd.parseItem(output);",
          "130:   EXPECT_NE(err, StructuredHeaders::DecodeError::OK);",
          "131: }",
          "133: TEST_F(StructuredHeadersBufferTest, test_string_parsing_repeated) {",
          "134:   std::string input = \"\\\"proxy\\\"\\\"gen\\\"\";",
          "135:   StructuredHeadersBuffer shd(input);",
          "136:   StructuredHeaderItem output;",
          "137:   auto err = shd.parseItem(output);",
          "138:   EXPECT_EQ(err, StructuredHeaders::DecodeError::OK);",
          "139:   EXPECT_EQ(output.tag, StructuredHeaderItem::Type::STRING);",
          "140:   EXPECT_EQ(output, std::string(\"proxy\"));",
          "142:   err = shd.parseItem(output);",
          "143:   EXPECT_EQ(err, StructuredHeaders::DecodeError::OK);",
          "144:   EXPECT_EQ(output.tag, StructuredHeaderItem::Type::STRING);",
          "145:   EXPECT_EQ(output, std::string(\"gen\"));",
          "146: }",
          "148: TEST_F(StructuredHeadersBufferTest, test_integer) {",
          "149:   std::string input = \"843593\";",
          "150:   StructuredHeadersBuffer shd(input);",
          "151:   StructuredHeaderItem output;",
          "152:   auto err = shd.parseItem(output);",
          "153:   EXPECT_EQ(err, StructuredHeaders::DecodeError::OK);",
          "154:   EXPECT_EQ(output.tag, StructuredHeaderItem::Type::INT64);",
          "155:   EXPECT_EQ(output, int64_t(843593));",
          "156: }",
          "158: TEST_F(StructuredHeadersBufferTest, test_integer_two_negatives) {",
          "159:   std::string input = \"--843593\";",
          "160:   StructuredHeadersBuffer shd(input);",
          "161:   StructuredHeaderItem output;",
          "162:   auto err = shd.parseItem(output);",
          "163:   EXPECT_NE(err, StructuredHeaders::DecodeError::OK);",
          "164: }",
          "166: TEST_F(StructuredHeadersBufferTest, test_integer_empty_after_negative) {",
          "167:   std::string input = \"-\";",
          "168:   StructuredHeadersBuffer shd(input);",
          "169:   StructuredHeaderItem output;",
          "170:   auto err = shd.parseItem(output);",
          "171:   EXPECT_NE(err, StructuredHeaders::DecodeError::OK);",
          "172: }",
          "174: TEST_F(StructuredHeadersBufferTest, test_integer_negative) {",
          "175:   std::string input = \"-843593\";",
          "176:   StructuredHeadersBuffer shd(input);",
          "177:   StructuredHeaderItem output;",
          "178:   auto err = shd.parseItem(output);",
          "179:   EXPECT_EQ(err, StructuredHeaders::DecodeError::OK);",
          "180:   EXPECT_EQ(output.tag, StructuredHeaderItem::Type::INT64);",
          "181:   EXPECT_EQ(output, int64_t(-843593));",
          "182: }",
          "184: TEST_F(StructuredHeadersBufferTest, test_integer_overflow) {",
          "185:   std::string input = \"9223372036854775808\";",
          "186:   StructuredHeadersBuffer shd(input);",
          "187:   StructuredHeaderItem output;",
          "188:   auto err = shd.parseItem(output);",
          "189:   EXPECT_NE(err, StructuredHeaders::DecodeError::OK);",
          "190: }",
          "192: TEST_F(StructuredHeadersBufferTest, test_integer_high_borderline) {",
          "193:   std::string input = \"9223372036854775807\";",
          "194:   StructuredHeadersBuffer shd(input);",
          "195:   StructuredHeaderItem output;",
          "196:   auto err = shd.parseItem(output);",
          "197:   EXPECT_EQ(err, StructuredHeaders::DecodeError::OK);",
          "198:   EXPECT_EQ(output.tag, StructuredHeaderItem::Type::INT64);",
          "199:   EXPECT_EQ(output, std::numeric_limits<int64_t>::max());",
          "200: }",
          "202: TEST_F(StructuredHeadersBufferTest, test_integer_low_borderline) {",
          "203:   std::string input = \"-9223372036854775808\";",
          "204:   StructuredHeadersBuffer shd(input);",
          "205:   StructuredHeaderItem output;",
          "206:   auto err = shd.parseItem(output);",
          "207:   EXPECT_EQ(err, StructuredHeaders::DecodeError::OK);",
          "208:   EXPECT_EQ(output.tag, StructuredHeaderItem::Type::INT64);",
          "209:   EXPECT_EQ(output, std::numeric_limits<int64_t>::min());",
          "210: }",
          "212: TEST_F(StructuredHeadersBufferTest, test_integer_underflow) {",
          "213:   std::string input = \"-9223372036854775809\";",
          "214:   StructuredHeadersBuffer shd(input);",
          "215:   StructuredHeaderItem output;",
          "216:   auto err = shd.parseItem(output);",
          "217:   EXPECT_NE(err, StructuredHeaders::DecodeError::OK);",
          "218: }",
          "220: TEST_F(StructuredHeadersBufferTest, test_float) {",
          "221:   std::string input = \"3.1415926536\";",
          "222:   StructuredHeadersBuffer shd(input);",
          "223:   StructuredHeaderItem output;",
          "224:   auto err = shd.parseItem(output);",
          "225:   EXPECT_EQ(err, StructuredHeaders::DecodeError::OK);",
          "226:   EXPECT_EQ(output.tag, StructuredHeaderItem::Type::DOUBLE);",
          "227:   EXPECT_EQ(output, 3.1415926536);",
          "228: }",
          "230: TEST_F(StructuredHeadersBufferTest, test_float_preceding_whitespace) {",
          "231:   std::string input = \"         \\t\\t    66000.5645\";",
          "232:   StructuredHeadersBuffer shd(input);",
          "233:   StructuredHeaderItem output;",
          "234:   auto err = shd.parseItem(output);",
          "235:   EXPECT_EQ(err, StructuredHeaders::DecodeError::OK);",
          "236:   EXPECT_EQ(output.tag, StructuredHeaderItem::Type::DOUBLE);",
          "237:   EXPECT_EQ(output, 66000.5645);",
          "238: }",
          "240: TEST_F(StructuredHeadersBufferTest, test_float_no_digit_preceding_decimal) {",
          "241:   std::string input = \".1415926536\";",
          "242:   StructuredHeadersBuffer shd(input);",
          "243:   StructuredHeaderItem output;",
          "244:   auto err = shd.parseItem(output);",
          "245:   EXPECT_NE(err, StructuredHeaders::DecodeError::OK);",
          "246: }",
          "248: TEST_F(StructuredHeadersBufferTest, test_integer_too_many_chars) {",
          "249:   std::string input = \"10000000000000000000\"; // has 20 characters",
          "250:   StructuredHeadersBuffer shd(input);",
          "251:   StructuredHeaderItem output;",
          "252:   auto err = shd.parseItem(output);",
          "253:   EXPECT_NE(err, StructuredHeaders::DecodeError::OK);",
          "254: }",
          "256: TEST_F(StructuredHeadersBufferTest, test_float_too_many_chars) {",
          "257:   std::string input = \"111111111.1111111\"; // has 17 characters",
          "258:   StructuredHeadersBuffer shd(input);",
          "259:   StructuredHeaderItem output;",
          "260:   auto err = shd.parseItem(output);",
          "261:   EXPECT_NE(err, StructuredHeaders::DecodeError::OK);",
          "262: }",
          "264: TEST_F(StructuredHeadersBufferTest, test_float_borderline_num_chars) {",
          "265:   std::string input = \"111111111.111111\"; // has 16 characters",
          "266:   StructuredHeadersBuffer shd(input);",
          "267:   StructuredHeaderItem output;",
          "268:   auto err = shd.parseItem(output);",
          "269:   EXPECT_EQ(output.tag, StructuredHeaderItem::Type::DOUBLE);",
          "270:   EXPECT_EQ(err, StructuredHeaders::DecodeError::OK);",
          "271: }",
          "273: TEST_F(StructuredHeadersBufferTest, test_float_ends_with_decimal) {",
          "274:   std::string input = \"100.\";",
          "275:   StructuredHeadersBuffer shd(input);",
          "276:   StructuredHeaderItem output;",
          "277:   auto err = shd.parseItem(output);",
          "278:   EXPECT_NE(err, StructuredHeaders::DecodeError::OK);",
          "279: }",
          "281: TEST_F(StructuredHeadersBufferTest, test_consume_comma) {",
          "282:   std::string input = \",5345346\";",
          "283:   StructuredHeadersBuffer shd(input);",
          "284:   StructuredHeaderItem output;",
          "285:   shd.removeSymbol(\",\", true);",
          "286:   auto err = shd.parseItem(output);",
          "287:   EXPECT_EQ(err, StructuredHeaders::DecodeError::OK);",
          "288:   EXPECT_EQ(output.tag, StructuredHeaderItem::Type::INT64);",
          "289:   EXPECT_EQ(output, int64_t(5345346));",
          "290: }",
          "292: TEST_F(StructuredHeadersBufferTest, test_consume_equals) {",
          "293:   std::string input = \"=456346.646\";",
          "294:   StructuredHeadersBuffer shd(input);",
          "295:   StructuredHeaderItem output;",
          "296:   shd.removeSymbol(\"=\", true);",
          "297:   auto err = shd.parseItem(output);",
          "298:   EXPECT_EQ(err, StructuredHeaders::DecodeError::OK);",
          "299:   EXPECT_EQ(output.tag, StructuredHeaderItem::Type::DOUBLE);",
          "300:   EXPECT_EQ(output, 456346.646);",
          "301: }",
          "303: TEST_F(StructuredHeadersBufferTest, test_consume_messy) {",
          "304:   std::string input = \"asfgsdfg,asfgsdfg,\";",
          "305:   StructuredHeadersBuffer shd(input);",
          "306:   for (int i = 0; i < 2; i++) {",
          "307:     StructuredHeaderItem output;",
          "308:     auto err = shd.parseIdentifier(output);",
          "309:     EXPECT_EQ(err, StructuredHeaders::DecodeError::OK);",
          "310:     EXPECT_EQ(output.tag, StructuredHeaderItem::Type::IDENTIFIER);",
          "311:     EXPECT_EQ(output, std::string(\"asfgsdfg\"));",
          "312:     shd.removeSymbol(\",\", true);",
          "313:   }",
          "314: }",
          "316: TEST_F(StructuredHeadersBufferTest, test_inequality_operator) {",
          "317:   StructuredHeaderItem integerItem;",
          "318:   integerItem.value = int64_t(999);",
          "320:   StructuredHeaderItem doubleItem;",
          "321:   doubleItem.value = 11.43;",
          "323:   StructuredHeaderItem stringItem;",
          "324:   stringItem.value = std::string(\"hi\");",
          "326:   EXPECT_NE(integerItem, int64_t(998));",
          "327:   EXPECT_NE(doubleItem, double(11.44));",
          "328:   EXPECT_NE(stringItem, std::string(\"bye\"));",
          "329: }",
          "331: }",
          "",
          "---------------"
        ],
        "proxygen/lib/http/structuredheaders/test/StructuredHeadersDecoderTest.cpp||proxygen/lib/http/structuredheaders/test/StructuredHeadersDecoderTest.cpp": [
          "File: proxygen/lib/http/structuredheaders/test/StructuredHeadersDecoderTest.cpp -> proxygen/lib/http/structuredheaders/test/StructuredHeadersDecoderTest.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "10: #include <proxygen/lib/http/structuredheaders/StructuredHeadersDecoder.h>",
          "11: #include <string>",
          "12: #include <folly/portability/GTest.h>",
          "14: namespace proxygen{",
          "16: class StructuredHeadersDecoderTest : public testing::Test {",
          "17: };",
          "19: TEST_F(StructuredHeadersDecoderTest, test_item) {",
          "20:   std::string input = \"645643\";",
          "21:   StructuredHeadersDecoder shd(input);",
          "23:   StructuredHeaderItem item;",
          "24:   shd.decodeItem(item);",
          "26:   EXPECT_EQ(item.tag, StructuredHeaderItem::Type::INT64);",
          "27:   EXPECT_EQ(item, int64_t(645643));",
          "28: }",
          "30: TEST_F(StructuredHeadersDecoderTest, test_list) {",
          "31:   std::string input = \"\\\"cookies\\\", 3.1415    , 74657\";",
          "32:   StructuredHeadersDecoder shd(input);",
          "34:   std::vector<StructuredHeaderItem> v;",
          "35:   shd.decodeList(v);",
          "36:   EXPECT_EQ(v.size(), 3);",
          "38:   EXPECT_EQ(v[0].tag, StructuredHeaderItem::Type::STRING);",
          "39:   EXPECT_EQ(v[1].tag, StructuredHeaderItem::Type::DOUBLE);",
          "40:   EXPECT_EQ(v[2].tag, StructuredHeaderItem::Type::INT64);",
          "42:   EXPECT_EQ(v[0], std::string(\"cookies\"));",
          "43:   EXPECT_EQ(v[1], 3.1415);",
          "44:   EXPECT_EQ(v[2], int64_t(74657));",
          "45: }",
          "47: TEST_F(StructuredHeadersDecoderTest, test_list_beginning_whitespace) {",
          "48:   std::string input = \"   19   , 95\";",
          "49:   StructuredHeadersDecoder shd(input);",
          "51:   std::vector<StructuredHeaderItem> v;",
          "52:   shd.decodeList(v);",
          "53:   EXPECT_EQ(v.size(), 2);",
          "55:   EXPECT_EQ(v[0].tag, StructuredHeaderItem::Type::INT64);",
          "56:   EXPECT_EQ(v[1].tag, StructuredHeaderItem::Type::INT64);",
          "58:   EXPECT_EQ(v[0], int64_t(19));",
          "59:   EXPECT_EQ(v[1], int64_t(95));",
          "60: }",
          "62: TEST_F(StructuredHeadersDecoderTest, test_list_ending_whitespace) {",
          "63:   std::string input = \"19   , 95    \";",
          "64:   StructuredHeadersDecoder shd(input);",
          "66:   std::vector<StructuredHeaderItem> v;",
          "67:   shd.decodeList(v);",
          "68:   EXPECT_EQ(v.size(), 2);",
          "70:   EXPECT_EQ(v[0].tag, StructuredHeaderItem::Type::INT64);",
          "71:   EXPECT_EQ(v[1].tag, StructuredHeaderItem::Type::INT64);",
          "73:   EXPECT_EQ(v[0], int64_t(19));",
          "74:   EXPECT_EQ(v[1], int64_t(95));",
          "75: }",
          "77: TEST_F(StructuredHeadersDecoderTest, test_list_no_whitespace) {",
          "78:   std::string input = \"19,95\";",
          "79:   StructuredHeadersDecoder shd(input);",
          "81:   std::vector<StructuredHeaderItem> v;",
          "82:   shd.decodeList(v);",
          "83:   EXPECT_EQ(v.size(), 2);",
          "85:   EXPECT_EQ(v[0].tag, StructuredHeaderItem::Type::INT64);",
          "86:   EXPECT_EQ(v[1].tag, StructuredHeaderItem::Type::INT64);",
          "88:   EXPECT_EQ(v[0], int64_t(19));",
          "89:   EXPECT_EQ(v[1], int64_t(95));",
          "90: }",
          "92: TEST_F(StructuredHeadersDecoderTest, test_list_one_item) {",
          "93:   std::string input = \"*Zm9vZA==*\";",
          "94:   StructuredHeadersDecoder shd(input);",
          "96:   std::vector<StructuredHeaderItem> v;",
          "97:   shd.decodeList(v);",
          "98:   EXPECT_EQ(v.size(), 1);",
          "100:   EXPECT_EQ(v[0].tag, StructuredHeaderItem::Type::BINARYCONTENT);",
          "102:   EXPECT_EQ(v[0], std::string(\"food\"));",
          "103: }",
          "105: TEST_F(StructuredHeadersDecoderTest, test_dictionary_many_elts) {",
          "106:   std::string input = \"age=87  ,  weight=150.8 ,   name=\\\"John Doe\\\"\";",
          "107:   StructuredHeadersDecoder shd(input);",
          "109:   std::unordered_map<std::string, StructuredHeaderItem> m;",
          "110:   shd.decodeDictionary(m);",
          "111:   EXPECT_EQ(m.size(), 3);",
          "113:   EXPECT_EQ(m[\"age\"].tag, StructuredHeaderItem::Type::INT64);",
          "114:   EXPECT_EQ(m[\"weight\"].tag, StructuredHeaderItem::Type::DOUBLE);",
          "115:   EXPECT_EQ(m[\"name\"].tag, StructuredHeaderItem::Type::STRING);",
          "117:   EXPECT_EQ(m[\"age\"], int64_t(87));",
          "118:   EXPECT_EQ(m[\"weight\"], 150.8);",
          "119:   EXPECT_EQ(m[\"name\"], std::string(\"John Doe\"));",
          "120: }",
          "122: TEST_F(StructuredHeadersDecoderTest, test_dictionary_one_elt) {",
          "123:   std::string input = \"bagel=*YXZvY2Fkbw==*\";",
          "124:   StructuredHeadersDecoder shd(input);",
          "126:   std::unordered_map<std::string, StructuredHeaderItem> m;",
          "127:   shd.decodeDictionary(m);",
          "128:   EXPECT_EQ(m.size(), 1);",
          "130:   EXPECT_EQ(m[\"bagel\"].tag, StructuredHeaderItem::Type::BINARYCONTENT);",
          "131:   EXPECT_EQ(m[\"bagel\"], std::string(\"avocado\"));",
          "132: }",
          "134: TEST_F(StructuredHeadersDecoderTest, test_param_list_one_elt) {",
          "135:   std::string input = \"abc_123;a=1;b=2\";",
          "136:   StructuredHeadersDecoder shd(input);",
          "138:   ParameterisedList pl;",
          "139:   shd.decodeParameterisedList(pl);",
          "140:   EXPECT_EQ(pl.size(), 1);",
          "141:   EXPECT_EQ(pl[0].identifier, \"abc_123\");",
          "142:   EXPECT_EQ(pl[0].parameterMap.size(), 2);",
          "143:   EXPECT_EQ(pl[0].parameterMap[\"a\"], int64_t(1));",
          "144:   EXPECT_EQ(pl[0].parameterMap[\"b\"], int64_t(2));",
          "145: }",
          "147: TEST_F(StructuredHeadersDecoderTest, test_param_list_many_elts) {",
          "148:   std::string input = \"a_13;a=1;b=2; c_4, ghi;q=\\\"9\\\";r=*bWF4IGlzIGF3ZXNvbWU=*\";",
          "149:   StructuredHeadersDecoder shd(input);",
          "151:   ParameterisedList pl;",
          "152:   shd.decodeParameterisedList(pl);",
          "153:   EXPECT_EQ(pl.size(), 2);",
          "155:   EXPECT_EQ(pl[0].identifier, \"a_13\");",
          "156:   EXPECT_EQ(pl[0].parameterMap.size(), 3);",
          "157:   EXPECT_EQ(pl[0].parameterMap[\"a\"].tag, StructuredHeaderItem::Type::INT64);",
          "158:   EXPECT_EQ(pl[0].parameterMap[\"b\"].tag, StructuredHeaderItem::Type::INT64);",
          "159:   EXPECT_EQ(pl[0].parameterMap[\"c_4\"].tag, StructuredHeaderItem::Type::NONE);",
          "160:   EXPECT_EQ(pl[0].parameterMap[\"a\"], int64_t(1));",
          "161:   EXPECT_EQ(pl[0].parameterMap[\"b\"], int64_t(2));",
          "163:   EXPECT_EQ(pl[1].identifier, \"ghi\");",
          "164:   EXPECT_EQ(pl[1].parameterMap.size(), 2);",
          "165:   EXPECT_EQ(pl[1].parameterMap[\"q\"].tag, StructuredHeaderItem::Type::STRING);",
          "166:   EXPECT_EQ(pl[1].parameterMap[\"r\"].tag,",
          "167:     StructuredHeaderItem::Type::BINARYCONTENT);",
          "168:   EXPECT_EQ(pl[1].parameterMap[\"q\"], std::string(\"9\"));",
          "169:   EXPECT_EQ(pl[1].parameterMap[\"r\"], std::string(\"max is awesome\"));",
          "170: }",
          "172: TEST_F(StructuredHeadersDecoderTest, test_param_list_no_params) {",
          "173:   std::string input = \"apple12, cat14, dog22\";",
          "174:   StructuredHeadersDecoder shd(input);",
          "176:   ParameterisedList pl;",
          "177:   shd.decodeParameterisedList(pl);",
          "178:   EXPECT_EQ(pl.size(), 3);",
          "179:   EXPECT_EQ(pl[0].identifier, \"apple12\");",
          "180:   EXPECT_EQ(pl[0].parameterMap.size(), 0);",
          "182:   EXPECT_EQ(pl[1].identifier, \"cat14\");",
          "183:   EXPECT_EQ(pl[1].parameterMap.size(), 0);",
          "185:   EXPECT_EQ(pl[2].identifier, \"dog22\");",
          "186:   EXPECT_EQ(pl[2].parameterMap.size(), 0);",
          "187: }",
          "189: TEST_F(StructuredHeadersDecoderTest, test_param_list_whitespace) {",
          "190:   std::string input = \"am_95    ;    abc=11.8   ,    foo      \";",
          "191:   StructuredHeadersDecoder shd(input);",
          "193:   ParameterisedList pl;",
          "194:   shd.decodeParameterisedList(pl);",
          "195:   EXPECT_EQ(pl.size(), 2);",
          "197:   EXPECT_EQ(pl[0].identifier, \"am_95\");",
          "198:   EXPECT_EQ(pl[0].parameterMap.size(), 1);",
          "199:   EXPECT_EQ(pl[0].parameterMap[\"abc\"].tag, StructuredHeaderItem::Type::DOUBLE);",
          "200:   EXPECT_EQ(pl[0].parameterMap[\"abc\"], 11.8);",
          "202:   EXPECT_EQ(pl[1].identifier, \"foo\");",
          "203:   EXPECT_EQ(pl[1].parameterMap.size(), 0);",
          "204: }",
          "206: TEST_F(StructuredHeadersDecoderTest, test_param_list_null_values) {",
          "207:   std::string input = \"beverages;water;juice, food;pizza;burger\";",
          "208:   StructuredHeadersDecoder shd(input);",
          "210:   ParameterisedList pl;",
          "211:   shd.decodeParameterisedList(pl);",
          "212:   EXPECT_EQ(pl.size(), 2);",
          "214:   EXPECT_EQ(pl[0].identifier, \"beverages\");",
          "215:   EXPECT_EQ(pl[0].parameterMap.size(), 2);",
          "216:   EXPECT_EQ(pl[0].parameterMap[\"water\"].tag, StructuredHeaderItem::Type::NONE);",
          "217:   EXPECT_EQ(pl[0].parameterMap[\"juice\"].tag, StructuredHeaderItem::Type::NONE);",
          "219:   EXPECT_EQ(pl[1].identifier, \"food\");",
          "220:   EXPECT_EQ(pl[1].parameterMap.size(), 2);",
          "221:   EXPECT_EQ(pl[1].parameterMap[\"pizza\"].tag, StructuredHeaderItem::Type::NONE);",
          "222:   EXPECT_EQ(pl[1].parameterMap[\"burger\"].tag, StructuredHeaderItem::Type::NONE);",
          "223: }",
          "225: }",
          "",
          "---------------"
        ],
        "proxygen/lib/http/structuredheaders/test/StructuredHeadersEncoderTest.cpp||proxygen/lib/http/structuredheaders/test/StructuredHeadersEncoderTest.cpp": [
          "File: proxygen/lib/http/structuredheaders/test/StructuredHeadersEncoderTest.cpp -> proxygen/lib/http/structuredheaders/test/StructuredHeadersEncoderTest.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "10: #include <proxygen/lib/http/structuredheaders/StructuredHeadersEncoder.h>",
          "11: #include <unordered_map>",
          "12: #include <folly/portability/GTest.h>",
          "13: #include <folly/portability/GMock.h>",
          "15: using namespace testing;",
          "17: namespace proxygen {",
          "19: class StructuredHeadersEncoderTest : public testing::Test {",
          "20: };",
          "22: TEST_F(StructuredHeadersEncoderTest, test_integer) {",
          "23:   StructuredHeaderItem item;",
          "24:   int64_t val = 2018;",
          "25:   item.tag = StructuredHeaderItem::Type::INT64;",
          "26:   item.value = val;",
          "28:   StructuredHeadersEncoder encoder;",
          "29:   auto err = encoder.encodeItem(item);",
          "31:   EXPECT_EQ(err, EncodeError::OK);",
          "32:   EXPECT_EQ(encoder.get(), \"2018\");",
          "33: }",
          "35: TEST_F(StructuredHeadersEncoderTest, test_integer_negative) {",
          "36:   StructuredHeaderItem item;",
          "37:   int64_t val = -2018;",
          "38:   item.tag = StructuredHeaderItem::Type::INT64;",
          "39:   item.value = val;",
          "41:   StructuredHeadersEncoder encoder;",
          "42:   auto err = encoder.encodeItem(item);",
          "44:   EXPECT_EQ(err, EncodeError::OK);",
          "45:   EXPECT_EQ(encoder.get(), \"-2018\");",
          "46: }",
          "48: TEST_F(StructuredHeadersEncoderTest, test_float) {",
          "49:   StructuredHeaderItem item;",
          "50:   double val = 3.1415926535;",
          "51:   item.tag = StructuredHeaderItem::Type::DOUBLE;",
          "52:   item.value = val;",
          "54:   StructuredHeadersEncoder encoder;",
          "55:   auto err = encoder.encodeItem(item);",
          "57:   EXPECT_EQ(err, EncodeError::OK);",
          "58:   EXPECT_EQ(encoder.get(), \"3.1415926535\");",
          "59: }",
          "61: TEST_F(StructuredHeadersEncoderTest, test_float_too_much_precision) {",
          "62:   StructuredHeadersEncoder encoder;",
          "63:   StructuredHeaderItem item;",
          "64:   double val = 100000.8392758372647; // has 20 characters",
          "65:   item.tag = StructuredHeaderItem::Type::DOUBLE;",
          "66:   item.value = val;",
          "68:   auto err = encoder.encodeItem(item);",
          "70:   EXPECT_EQ(err, EncodeError::OK);",
          "71:   EXPECT_EQ(encoder.get(), \"100000.839275837\");",
          "72: }",
          "74: TEST_F(StructuredHeadersEncoderTest, test_float_negative) {",
          "75:   StructuredHeaderItem item;",
          "76:   double val = -3.141;",
          "77:   item.tag = StructuredHeaderItem::Type::DOUBLE;",
          "78:   item.value = val;",
          "80:   StructuredHeadersEncoder encoder;",
          "81:   auto err = encoder.encodeItem(item);",
          "83:   EXPECT_EQ(err, EncodeError::OK);",
          "84:   EXPECT_EQ(encoder.get(), \"-3.141\");",
          "85: }",
          "87: TEST_F(StructuredHeadersEncoderTest, test_string) {",
          "88:   StructuredHeaderItem item;",
          "89:   std::string val = \"seattle is the best\";",
          "90:   item.tag = StructuredHeaderItem::Type::STRING;",
          "91:   item.value = val;",
          "93:   StructuredHeadersEncoder encoder;",
          "94:   auto err = encoder.encodeItem(item);",
          "96:   EXPECT_EQ(err, EncodeError::OK);",
          "97:   EXPECT_EQ(encoder.get(), \"\\\"seattle is the best\\\"\");",
          "98: }",
          "100: TEST_F(StructuredHeadersEncoderTest, test_string_bad_content) {",
          "101:   StructuredHeaderItem item;",
          "102:   std::string val = \"seattle \\n is the best\";",
          "103:   item.tag = StructuredHeaderItem::Type::STRING;",
          "104:   item.value = val;",
          "106:   StructuredHeadersEncoder encoder;",
          "107:   auto err = encoder.encodeItem(item);",
          "109:   EXPECT_NE(err, EncodeError::OK);",
          "110: }",
          "112: TEST_F(StructuredHeadersEncoderTest, test_string_backslash) {",
          "113:   StructuredHeaderItem item;",
          "114:   std::string val = \"seattle \\\\is the best\";",
          "115:   item.tag = StructuredHeaderItem::Type::STRING;",
          "116:   item.value = val;",
          "118:   StructuredHeadersEncoder encoder;",
          "119:   auto err = encoder.encodeItem(item);",
          "121:   EXPECT_EQ(err, EncodeError::OK);",
          "122:   EXPECT_EQ(encoder.get(), \"\\\"seattle \\\\\\\\is the best\\\"\");",
          "123: }",
          "125: TEST_F(StructuredHeadersEncoderTest, test_string_quote) {",
          "126:   StructuredHeaderItem item;",
          "127:   std::string val = \"seattle \\\"is the best\";",
          "128:   item.tag = StructuredHeaderItem::Type::STRING;",
          "129:   item.value = val;",
          "131:   StructuredHeadersEncoder encoder;",
          "132:   auto err = encoder.encodeItem(item);",
          "134:   EXPECT_EQ(err, EncodeError::OK);",
          "135:   EXPECT_EQ(encoder.get(), \"\\\"seattle \\\\\\\"is the best\\\"\");",
          "136: }",
          "138: TEST_F(StructuredHeadersEncoderTest, test_binary_content) {",
          "139:   StructuredHeaderItem item;",
          "140:   std::string val = \"seattle <3\";",
          "141:   item.tag = StructuredHeaderItem::Type::BINARYCONTENT;",
          "142:   item.value = val;",
          "144:   StructuredHeadersEncoder encoder;",
          "145:   auto err = encoder.encodeItem(item);",
          "147:   EXPECT_EQ(err, EncodeError::OK);",
          "148:   EXPECT_EQ(encoder.get(), \"*c2VhdHRsZSA8Mw==*\");",
          "149: }",
          "151: TEST_F(StructuredHeadersEncoderTest, test_identifier) {",
          "152:   std::string result;",
          "153:   std::string val = \"abc_00123\";",
          "155:   StructuredHeadersEncoder encoder;",
          "156:   auto err = encoder.encodeIdentifier(val);",
          "158:   EXPECT_EQ(err, EncodeError::OK);",
          "159:   EXPECT_EQ(encoder.get(), \"abc_00123\");",
          "160: }",
          "162: TEST_F(StructuredHeadersEncoderTest, test_identifier_bad_content) {",
          "163:   std::string result;",
          "164:   std::string val = \"_abc_00123\";",
          "166:   StructuredHeadersEncoder encoder;",
          "167:   auto err = encoder.encodeIdentifier(val);",
          "169:   EXPECT_NE(err, EncodeError::OK);",
          "170: }",
          "172: TEST_F(StructuredHeadersEncoderTest, test_wrong_type) {",
          "173:   StructuredHeaderItem item;",
          "174:   double val = 3.1415;",
          "175:   item.tag = StructuredHeaderItem::Type::INT64;",
          "176:   item.value = val;",
          "178:   StructuredHeadersEncoder encoder;",
          "179:   auto err = encoder.encodeItem(item);",
          "181:   EXPECT_NE(err, EncodeError::OK);",
          "182: }",
          "184: TEST_F(StructuredHeadersEncoderTest, test_list_many_elts) {",
          "185:   std::vector<StructuredHeaderItem> vec;",
          "186:   StructuredHeaderItem item;",
          "188:   item.tag = StructuredHeaderItem::Type::DOUBLE;",
          "189:   double val1 = 3.14;",
          "190:   item.value = val1;",
          "191:   vec.push_back(item);",
          "193:   item.tag = StructuredHeaderItem::Type::BINARYCONTENT;",
          "194:   std::string val2 = \"pizza\";",
          "195:   item.value = val2;",
          "196:   vec.push_back(item);",
          "198:   item.tag = StructuredHeaderItem::Type::INT64;",
          "199:   int64_t val3 = 65;",
          "200:   item.value = val3;",
          "201:   vec.push_back(item);",
          "203:   StructuredHeadersEncoder encoder;",
          "204:   auto err = encoder.encodeList(vec);",
          "206:   EXPECT_EQ(err, EncodeError::OK);",
          "207:   EXPECT_EQ(encoder.get(), \"3.14, *cGl6emE=*, 65\");",
          "208: }",
          "210: TEST_F(StructuredHeadersEncoderTest, test_list_one_elt) {",
          "211:   std::vector<StructuredHeaderItem> vec;",
          "212:   StructuredHeaderItem item;",
          "214:   item.tag = StructuredHeaderItem::Type::STRING;",
          "215:   std::string val1 = \"hello world\";",
          "216:   item.value = val1;",
          "217:   vec.push_back(item);",
          "219:   StructuredHeadersEncoder encoder;",
          "220:   auto err = encoder.encodeList(vec);",
          "222:   EXPECT_EQ(err, EncodeError::OK);",
          "223:   EXPECT_EQ(encoder.get(), \"\\\"hello world\\\"\");",
          "224: }",
          "226: TEST_F(StructuredHeadersEncoderTest, test_list_empty) {",
          "227:   std::vector<StructuredHeaderItem> vec;",
          "229:   StructuredHeadersEncoder encoder;",
          "230:   auto err = encoder.encodeList(vec);",
          "232:   EXPECT_NE(err, EncodeError::OK);",
          "233: }",
          "235: TEST_F(StructuredHeadersEncoderTest, test_list_bad_item) {",
          "236:   std::vector<StructuredHeaderItem> vec;",
          "237:   StructuredHeaderItem item;",
          "239:   item.tag = StructuredHeaderItem::Type::STRING;",
          "240:   std::string val1 = \"hello \\x10world\";",
          "241:   item.value = val1;",
          "242:   vec.push_back(item);",
          "244:   StructuredHeadersEncoder encoder;",
          "245:   auto err = encoder.encodeList(vec);",
          "247:   EXPECT_NE(err, EncodeError::OK);",
          "248: }",
          "250: TEST_F(StructuredHeadersEncoderTest, test_dictionary_one_elt) {",
          "251:   StructuredHeaders::Dictionary dict;",
          "253:   StructuredHeaderItem item1;",
          "254:   item1.tag = StructuredHeaderItem::Type::DOUBLE;",
          "255:   double val1 = 2.71;",
          "256:   item1.value = val1;",
          "258:   dict[\"e\"] = item1;",
          "260:   StructuredHeadersEncoder encoder;",
          "261:   auto err = encoder.encodeDictionary(dict);",
          "263:   EXPECT_EQ(err, EncodeError::OK);",
          "264:   EXPECT_EQ(encoder.get(), \"e=2.71\");",
          "265: }",
          "267: TEST_F(StructuredHeadersEncoderTest, test_dictionary_many_elts) {",
          "268:   StructuredHeaders::Dictionary dict;",
          "269:   StructuredHeaderItem item;",
          "271:   item.tag = StructuredHeaderItem::Type::INT64;",
          "272:   int64_t val1 = 87;",
          "273:   item.value = val1;",
          "274:   dict[\"age\"] = item;",
          "276:   item.tag = StructuredHeaderItem::Type::STRING;",
          "277:   std::string val2 = \"John Doe\";",
          "278:   item.value = val2;",
          "279:   dict[\"name\"] = item;",
          "281:   item.tag = StructuredHeaderItem::Type::BINARYCONTENT;",
          "282:   std::string val3 = \"password\";",
          "283:   item.value = val3;",
          "284:   dict[\"password\"] = item;",
          "286:   StructuredHeadersEncoder encoder;",
          "287:   auto err = encoder.encodeDictionary(dict);",
          "289:   EXPECT_EQ(err, EncodeError::OK);",
          "293:   EXPECT_THAT(encoder.get(), AnyOf(",
          "294:     Eq(\"age=87, name=\\\"John Doe\\\", password=*cGFzc3dvcmQ=*\"),",
          "295:     Eq(\"age=87, password=*cGFzc3dvcmQ=*, name=\\\"John Doe\\\"\"),",
          "296:     Eq(\"name=\\\"John Doe\\\", age=87, password=*cGFzc3dvcmQ=*\"),",
          "297:     Eq(\"name=\\\"John Doe\\\", password=*cGFzc3dvcmQ=*, age=87\"),",
          "298:     Eq(\"password=*cGFzc3dvcmQ=*, name=\\\"John Doe\\\", age=87\"),",
          "299:     Eq(\"password=*cGFzc3dvcmQ=*, age=87, name=\\\"John Doe\\\"\")",
          "300:   ));",
          "301: }",
          "303: TEST_F(StructuredHeadersEncoderTest, test_dictionary_empty) {",
          "304:   StructuredHeaders::Dictionary dict;",
          "306:   StructuredHeadersEncoder encoder;",
          "307:   auto err = encoder.encodeDictionary(dict);",
          "309:   EXPECT_NE(err, EncodeError::OK);",
          "310: }",
          "312: TEST_F(StructuredHeadersEncoderTest, test_dictionary_bad_item) {",
          "313:   StructuredHeaders::Dictionary dict;",
          "315:   StructuredHeaderItem item1;",
          "316:   item1.tag = StructuredHeaderItem::Type::STRING;",
          "317:   std::string val1 = \"hi\\nmy name is bob\";",
          "318:   item1.value = val1;",
          "320:   dict[\"e\"] = item1;",
          "322:   StructuredHeadersEncoder encoder;",
          "323:   auto err = encoder.encodeDictionary(dict);",
          "325:   EXPECT_NE(err, EncodeError::OK);",
          "326: }",
          "328: TEST_F(StructuredHeadersEncoderTest, test_dictionary_bad_identifier) {",
          "329:   StructuredHeaders::Dictionary dict;",
          "331:   StructuredHeaderItem item1;",
          "332:   item1.tag = StructuredHeaderItem::Type::STRING;",
          "333:   std::string val1 = \"hi\";",
          "334:   item1.value = val1;",
          "336:   dict[\"_bad_identifier\"] = item1;",
          "338:   StructuredHeadersEncoder encoder;",
          "339:   auto err = encoder.encodeDictionary(dict);",
          "341:   EXPECT_NE(err, EncodeError::OK);",
          "342: }",
          "344: TEST_F(StructuredHeadersEncoderTest, test_param_list_one_elt) {",
          "345:   ParameterisedList pl;",
          "346:   std::unordered_map<std::string, StructuredHeaderItem> m;",
          "348:   StructuredHeaderItem item;",
          "350:   item.tag = StructuredHeaderItem::Type::INT64;",
          "351:   int64_t val1 = 1;",
          "352:   item.value = val1;",
          "353:   m[\"abc\"] = item;",
          "355:   ParameterisedIdentifier pident = {\"foo\", m};",
          "357:   pl.emplace_back(pident);",
          "359:   StructuredHeadersEncoder encoder;",
          "360:   auto err = encoder.encodeParameterisedList(pl);",
          "362:   EXPECT_EQ(err, EncodeError::OK);",
          "364:   EXPECT_EQ(encoder.get(), \"foo; abc=1\");",
          "365: }",
          "367: TEST_F(StructuredHeadersEncoderTest, test_param_list_successive_nulls) {",
          "368:   ParameterisedList pl;",
          "369:   std::unordered_map<std::string, StructuredHeaderItem> m;",
          "371:   StructuredHeaderItem item;",
          "373:   item.tag = StructuredHeaderItem::Type::NONE;",
          "374:   m[\"a\"] = item;",
          "375:   m[\"b\"] = item;",
          "377:   ParameterisedIdentifier pident = {\"foo\", m};",
          "379:   pl.emplace_back(pident);",
          "381:   StructuredHeadersEncoder encoder;",
          "382:   auto err = encoder.encodeParameterisedList(pl);",
          "384:   EXPECT_EQ(err, EncodeError::OK);",
          "386:   EXPECT_THAT(encoder.get(), AnyOf(",
          "387:     Eq(\"foo; a; b\"),",
          "388:     Eq(\"foo; b; a\")",
          "389:   ));",
          "390: }",
          "392: TEST_F(StructuredHeadersEncoderTest, test_param_list_many_elts) {",
          "393:   ParameterisedList pl;",
          "394:   std::unordered_map<std::string, StructuredHeaderItem> m1;",
          "396:   StructuredHeaderItem item;",
          "398:   item.tag = StructuredHeaderItem::Type::DOUBLE;",
          "399:   double val1 = 4234.234;",
          "400:   item.value = val1;",
          "401:   m1[\"foo\"] = item;",
          "403:   item.tag = StructuredHeaderItem::Type::BINARYCONTENT;",
          "404:   std::string val2 = \"+++!\";",
          "405:   item.value = val2;",
          "406:   m1[\"goo\"] = item;",
          "408:   ParameterisedIdentifier pident1 = {\"bar\", m1};",
          "410:   pl.emplace_back(pident1);",
          "412:   std::unordered_map<std::string, StructuredHeaderItem> m2;",
          "414:   item.tag = StructuredHeaderItem::Type::NONE;",
          "415:   m2[\"foo\"] = item;",
          "417:   item.tag = StructuredHeaderItem::Type::INT64;",
          "418:   int64_t val4 = 100;",
          "419:   item.value = val4;",
          "420:   m2[\"goo\"] = item;",
          "422:   ParameterisedIdentifier pident2 = {\"far\", m2};",
          "424:   pl.emplace_back(pident2);",
          "426:   StructuredHeadersEncoder encoder;",
          "427:   auto err = encoder.encodeParameterisedList(pl);",
          "429:   EXPECT_EQ(err, EncodeError::OK);",
          "433:   EXPECT_THAT(encoder.get(), AnyOf(",
          "434:     Eq(\"bar; foo=4234.234; goo=*KysrIQ==*, far; foo; goo=100\"),",
          "435:     Eq(\"bar; foo=4234.234; goo=*KysrIQ==*, far; goo=100; foo\"),",
          "436:     Eq(\"bar; goo=*KysrIQ==*; foo=4234.234, far; foo; goo=100\"),",
          "437:     Eq(\"bar; goo=*KysrIQ==*; foo=4234.234, far; goo=100; foo\"),",
          "438:     Eq(\"far; foo; goo=100, bar; foo=4234.234; goo=*KysrIQ==*\"),",
          "439:     Eq(\"far; foo; goo=100, bar; goo=*KysrIQ==*; foo=4234.234\"),",
          "440:     Eq(\"far; goo=100; foo, bar; foo=4234.234; goo=*KysrIQ==*\"),",
          "441:     Eq(\"far; goo=100; foo, bar; goo=*KysrIQ==*; foo=4234.234\")",
          "442:   ));",
          "443: }",
          "445: TEST_F(StructuredHeadersEncoderTest, test_param_list_empty) {",
          "446:   ParameterisedList pl;",
          "447:   StructuredHeadersEncoder encoder;",
          "448:   auto err = encoder.encodeParameterisedList(pl);",
          "450:   EXPECT_NE(err, EncodeError::OK);",
          "451: }",
          "453: TEST_F(StructuredHeadersEncoderTest, test_param_list_bad_secondary_identifier) {",
          "454:   ParameterisedList pl;",
          "455:   std::unordered_map<std::string, StructuredHeaderItem> m;",
          "457:   StructuredHeaderItem item;",
          "459:   item.tag = StructuredHeaderItem::Type::STRING;",
          "460:   std::string val1 = \"ABC\";",
          "461:   item.value = val1;",
          "462:   m[\"\\nbbb\"] = item;",
          "464:   ParameterisedIdentifier pident = {\"foo\", m};",
          "466:   pl.emplace_back(pident);",
          "468:   StructuredHeadersEncoder encoder;",
          "469:   auto err = encoder.encodeParameterisedList(pl);",
          "471:   EXPECT_NE(err, EncodeError::OK);",
          "472: }",
          "474: TEST_F(StructuredHeadersEncoderTest, test_param_list_bad_primary_identifier) {",
          "475:   ParameterisedList pl;",
          "476:   std::unordered_map<std::string, StructuredHeaderItem> m;",
          "478:   StructuredHeaderItem item;",
          "480:   item.tag = StructuredHeaderItem::Type::INT64;",
          "481:   int64_t val1 = 143;",
          "482:   item.value = val1;",
          "483:   m[\"abc\"] = item;",
          "485:   ParameterisedIdentifier pident = {\"a+++\", m};",
          "487:   pl.emplace_back(pident);",
          "489:   StructuredHeadersEncoder encoder;",
          "490:   auto err = encoder.encodeParameterisedList(pl);",
          "492:   EXPECT_NE(err, EncodeError::OK);",
          "493: }",
          "495: TEST_F(StructuredHeadersEncoderTest, test_param_list_bad_items) {",
          "496:   ParameterisedList pl;",
          "497:   std::unordered_map<std::string, StructuredHeaderItem> m;",
          "499:   StructuredHeaderItem item;",
          "501:   item.tag = StructuredHeaderItem::Type::STRING;",
          "502:   std::string val1 = \"AB\\nC\";",
          "503:   item.value = val1;",
          "504:   m[\"bbb\"] = item;",
          "506:   ParameterisedIdentifier pident = {\"foo\", m};",
          "508:   pl.emplace_back(pident);",
          "510:   StructuredHeadersEncoder encoder;",
          "511:   auto err = encoder.encodeParameterisedList(pl);",
          "513:   EXPECT_NE(err, EncodeError::OK);",
          "514: }",
          "516: }",
          "",
          "---------------"
        ],
        "proxygen/lib/http/structuredheaders/test/StructuredHeadersUtilitiesTest.cpp||proxygen/lib/http/structuredheaders/test/StructuredHeadersUtilitiesTest.cpp": [
          "File: proxygen/lib/http/structuredheaders/test/StructuredHeadersUtilitiesTest.cpp -> proxygen/lib/http/structuredheaders/test/StructuredHeadersUtilitiesTest.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "10: #include <proxygen/lib/http/structuredheaders/StructuredHeadersUtilities.h>",
          "11: #include <string>",
          "12: #include <folly/portability/GTest.h>",
          "14: namespace proxygen {",
          "15: namespace StructuredHeaders {",
          "17: class StructuredHeadersUtilitiesTest : public testing::Test {",
          "18: };",
          "20: TEST_F(StructuredHeadersUtilitiesTest, test_lcalpha) {",
          "21:   for (uint32_t i = 0; i < 256; i++) {",
          "22:     uint8_t c = (uint8_t) i;",
          "23:     if (c >= 'a' && c <= 'z') {",
          "24:       EXPECT_TRUE(isLcAlpha(c));",
          "25:     } else {",
          "26:       EXPECT_FALSE(isLcAlpha(c));",
          "27:     }",
          "28:   }",
          "29: }",
          "31: TEST_F(StructuredHeadersUtilitiesTest, test_isValidIdentifierChar) {",
          "32:   for (uint32_t i = 0; i < 256; i++) {",
          "33:     uint8_t c = (uint8_t) i;",
          "34:     if ((c >= 'a' && c <= 'z') ||",
          "35:         (c >= '0' && c <= '9') ||",
          "36:         (c == '_' || c == '-' || c == '*' || c == '/')) {",
          "37:       EXPECT_TRUE(isValidIdentifierChar(c));",
          "38:     } else {",
          "39:       EXPECT_FALSE(isValidIdentifierChar(c));",
          "40:     }",
          "41:   }",
          "42: }",
          "44: TEST_F(StructuredHeadersUtilitiesTest,",
          "45:    test_isValidEncodedBinaryContentChar_alphanumeric) {",
          "46:   EXPECT_TRUE(isValidEncodedBinaryContentChar('a'));",
          "47:   EXPECT_TRUE(isValidEncodedBinaryContentChar('Z'));",
          "48:   EXPECT_TRUE(isValidEncodedBinaryContentChar('0'));",
          "49:   EXPECT_TRUE(isValidEncodedBinaryContentChar('9'));",
          "50: }",
          "52: TEST_F(StructuredHeadersUtilitiesTest,",
          "53:    test_isValidEncodedBinaryContentChar_allowed_symbols) {",
          "54:   EXPECT_TRUE(isValidEncodedBinaryContentChar('+'));",
          "55:   EXPECT_TRUE(isValidEncodedBinaryContentChar('/'));",
          "56:   EXPECT_TRUE(isValidEncodedBinaryContentChar('='));",
          "57: }",
          "59: TEST_F(StructuredHeadersUtilitiesTest,",
          "60:    test_isValidEncodedBinaryContentChar_disallowed_symbols) {",
          "61:   EXPECT_FALSE(isValidEncodedBinaryContentChar('*'));",
          "62:   EXPECT_FALSE(isValidEncodedBinaryContentChar('_'));",
          "63:   EXPECT_FALSE(isValidEncodedBinaryContentChar('-'));",
          "64:   EXPECT_FALSE(isValidEncodedBinaryContentChar(' '));",
          "65: }",
          "67: TEST_F(StructuredHeadersUtilitiesTest, test_isValidStringChar_allowed) {",
          "68:   EXPECT_TRUE(isValidStringChar(' '));",
          "69:   EXPECT_TRUE(isValidStringChar('~'));",
          "70:   EXPECT_TRUE(isValidStringChar('\\\\'));",
          "71:   EXPECT_TRUE(isValidStringChar('\\\"'));",
          "72:   EXPECT_TRUE(isValidStringChar('a'));",
          "73:   EXPECT_TRUE(isValidStringChar('0'));",
          "74:   EXPECT_TRUE(isValidStringChar('A'));",
          "75: }",
          "77: TEST_F(StructuredHeadersUtilitiesTest, test_isValidStringChar_disallowed) {",
          "78:   EXPECT_FALSE(isValidStringChar('\\0'));",
          "79:   EXPECT_FALSE(isValidStringChar(0x1F));",
          "80:   EXPECT_FALSE(isValidStringChar(0x7F));",
          "81:   EXPECT_FALSE(isValidStringChar('\\t'));",
          "82: }",
          "84: TEST_F(StructuredHeadersUtilitiesTest, test_isValidIdentifier_allowed) {",
          "85:   EXPECT_TRUE(isValidIdentifier(\"a\"));",
          "86:   EXPECT_TRUE(isValidIdentifier(\"a_0-*/\"));",
          "87:   EXPECT_TRUE(isValidIdentifier(\"abc___xyz\"));",
          "88: }",
          "90: TEST_F(StructuredHeadersUtilitiesTest, test_isValidIdentifier_disallowed) {",
          "91:   EXPECT_FALSE(isValidIdentifier(\"aAAA\"));",
          "92:   EXPECT_FALSE(isValidIdentifier(\"_aa\"));",
          "93:   EXPECT_FALSE(isValidIdentifier(\"0abc\"));",
          "94:   EXPECT_FALSE(isValidIdentifier(\"\"));",
          "95: }",
          "97: TEST_F(StructuredHeadersUtilitiesTest, test_isValidString_allowed) {",
          "98:   EXPECT_TRUE(isValidString(\"a cat.\"));",
          "99:   EXPECT_TRUE(isValidString(\"!~)($@^^) g\"));",
          "100:   EXPECT_TRUE(isValidString(\"\\\\\\\"\\\"\\\\\"));",
          "101:   EXPECT_TRUE(isValidString(\"\"));",
          "102: }",
          "104: TEST_F(StructuredHeadersUtilitiesTest, test_isValidString_disallowed) {",
          "105:   EXPECT_FALSE(isValidString(\"a\\tcat.\"));",
          "106:   EXPECT_FALSE(isValidString(\"\\x10 aaaaaaa\"));",
          "107:   EXPECT_FALSE(isValidString(\"chocolate\\x11\"));",
          "108:   EXPECT_FALSE(isValidString(\"pota\\nto\"));",
          "109: }",
          "111: TEST_F(StructuredHeadersUtilitiesTest, test_goodBinaryContent) {",
          "112:   EXPECT_TRUE(isValidEncodedBinaryContent(\"aGVsbG8=\"));",
          "113:   EXPECT_TRUE(isValidEncodedBinaryContent(\"ZGZzZGZmc2Rm\"));",
          "114:   EXPECT_TRUE(isValidEncodedBinaryContent(\"ZA==\"));",
          "115: }",
          "117: TEST_F(StructuredHeadersUtilitiesTest, test_badBinaryContent) {",
          "118:   EXPECT_FALSE(isValidEncodedBinaryContent(\"aGVsbG8\"));",
          "119:   EXPECT_FALSE(isValidEncodedBinaryContent(\"aGVsb G8=\"));",
          "120:   EXPECT_FALSE(isValidEncodedBinaryContent(\"aGVsbG!8=\"));",
          "121:   EXPECT_FALSE(isValidEncodedBinaryContent(\"=aGVsbG8\"));",
          "122: }",
          "124: TEST_F(StructuredHeadersUtilitiesTest, test_DecodeBinaryContent) {",
          "125:   std::string input1 = \"ZnJ1aXQ=\";",
          "126:   std::string input2 = \"dG9tYXRv\";",
          "127:   std::string input3 = \"ZWdncw==\";",
          "128:   EXPECT_EQ(decodeBase64(input1), \"fruit\");",
          "129:   EXPECT_EQ(decodeBase64(input2), \"tomato\");",
          "130:   EXPECT_EQ(decodeBase64(input3), \"eggs\");",
          "131: }",
          "133: TEST_F(StructuredHeadersUtilitiesTest, test_EncodeBinaryContent) {",
          "134:   std::string input1 = \"fruit\";",
          "135:   std::string input2 = \"tomato\";",
          "136:   std::string input3 = \"eggs\";",
          "137:   EXPECT_EQ(encodeBase64(input1), \"ZnJ1aXQ=\");",
          "138:   EXPECT_EQ(encodeBase64(input2), \"dG9tYXRv\");",
          "139:   EXPECT_EQ(encodeBase64(input3), \"ZWdncw==\");",
          "140: }",
          "142: TEST_F(StructuredHeadersUtilitiesTest, test_BinaryContentEmpty) {",
          "143:   std::string input1 = \"\";",
          "144:   std::string input2 = \"\";",
          "145:   EXPECT_EQ(encodeBase64(input1), \"\");",
          "146:   EXPECT_EQ(decodeBase64(input2), \"\");",
          "147: }",
          "149: TEST_F(StructuredHeadersUtilitiesTest, test_itemTypeMatchesContent_good) {",
          "150:   StructuredHeaderItem item;",
          "151:   item.value = \"\\\"potato\\\"\";",
          "152:   item.tag = StructuredHeaderItem::Type::STRING;",
          "153:   EXPECT_TRUE(itemTypeMatchesContent(item));",
          "155:   item.value = \"a_800\";",
          "156:   item.tag = StructuredHeaderItem::Type::IDENTIFIER;",
          "157:   EXPECT_TRUE(itemTypeMatchesContent(item));",
          "159:   item.tag = StructuredHeaderItem::Type::NONE;",
          "160:   EXPECT_TRUE(itemTypeMatchesContent(item));",
          "162:   item.value = \"hello\";",
          "163:   item.tag = StructuredHeaderItem::Type::BINARYCONTENT;",
          "164:   EXPECT_TRUE(itemTypeMatchesContent(item));",
          "166:   item.value = int64_t(88);",
          "167:   item.tag = StructuredHeaderItem::Type::INT64;",
          "168:   EXPECT_TRUE(itemTypeMatchesContent(item));",
          "170:   item.value = double(88.8);",
          "171:   item.tag = StructuredHeaderItem::Type::DOUBLE;",
          "172:   EXPECT_TRUE(itemTypeMatchesContent(item));",
          "173: }",
          "175: TEST_F(StructuredHeadersUtilitiesTest, test_itemTypeMatchesContent_bad) {",
          "176:   StructuredHeaderItem item;",
          "178:   item.value = \"hello\";",
          "179:   item.tag = StructuredHeaderItem::Type::DOUBLE;",
          "180:   EXPECT_FALSE(itemTypeMatchesContent(item));",
          "181:   item.tag = StructuredHeaderItem::Type::INT64;",
          "182:   EXPECT_FALSE(itemTypeMatchesContent(item));",
          "184:   item.value = int64_t(68);",
          "185:   item.tag = StructuredHeaderItem::Type::DOUBLE;",
          "186:   EXPECT_FALSE(itemTypeMatchesContent(item));",
          "187:   item.tag = StructuredHeaderItem::Type::STRING;",
          "188:   EXPECT_FALSE(itemTypeMatchesContent(item));",
          "189:   item.tag = StructuredHeaderItem::Type::BINARYCONTENT;",
          "190:   EXPECT_FALSE(itemTypeMatchesContent(item));",
          "191:   item.tag = StructuredHeaderItem::Type::IDENTIFIER;",
          "192:   EXPECT_FALSE(itemTypeMatchesContent(item));",
          "194:   item.value = double(68.8);",
          "195:   item.tag = StructuredHeaderItem::Type::INT64;",
          "196:   EXPECT_FALSE(itemTypeMatchesContent(item));",
          "197:   item.tag = StructuredHeaderItem::Type::IDENTIFIER;",
          "198:   EXPECT_FALSE(itemTypeMatchesContent(item));",
          "199:   item.tag = StructuredHeaderItem::Type::STRING;",
          "200:   EXPECT_FALSE(itemTypeMatchesContent(item));",
          "201:   item.tag = StructuredHeaderItem::Type::BINARYCONTENT;",
          "202:   EXPECT_FALSE(itemTypeMatchesContent(item));",
          "203: }",
          "205: }",
          "206: }",
          "",
          "---------------"
        ]
      }
    }
  ]
}
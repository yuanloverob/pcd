{
  "cve_id": "CVE-2016-3841",
  "cve_desc": "The IPv6 stack in the Linux kernel before 4.3.3 mishandles options data, which allows local users to gain privileges or cause a denial of service (use-after-free and system crash) via a crafted sendmsg system call.",
  "repo": "torvalds/linux",
  "patch_hash": "45f6fad84cc305103b28d73482b344d7f5b76f39",
  "patch_info": {
    "commit_hash": "45f6fad84cc305103b28d73482b344d7f5b76f39",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/45f6fad84cc305103b28d73482b344d7f5b76f39",
    "files": [
      "include/linux/ipv6.h",
      "include/net/ipv6.h",
      "net/dccp/ipv6.c",
      "net/ipv6/af_inet6.c",
      "net/ipv6/datagram.c",
      "net/ipv6/exthdrs.c",
      "net/ipv6/inet6_connection_sock.c",
      "net/ipv6/ipv6_sockglue.c",
      "net/ipv6/raw.c",
      "net/ipv6/syncookies.c",
      "net/ipv6/tcp_ipv6.c",
      "net/ipv6/udp.c",
      "net/l2tp/l2tp_ip6.c"
    ],
    "message": "ipv6: add complete rcu protection around np->opt\n\nThis patch addresses multiple problems :\n\nUDP/RAW sendmsg() need to get a stable struct ipv6_txoptions\nwhile socket is not locked : Other threads can change np->opt\nconcurrently. Dmitry posted a syzkaller\n(http://github.com/google/syzkaller) program desmonstrating\nuse-after-free.\n\nStarting with TCP/DCCP lockless listeners, tcp_v6_syn_recv_sock()\nand dccp_v6_request_recv_sock() also need to use RCU protection\nto dereference np->opt once (before calling ipv6_dup_options())\n\nThis patch adds full RCU protection to np->opt\n\nReported-by: Dmitry Vyukov <dvyukov@google.com>\nSigned-off-by: Eric Dumazet <edumazet@google.com>\nAcked-by: Hannes Frederic Sowa <hannes@stressinduktion.org>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
    "before_after_code_files": [
      "include/linux/ipv6.h||include/linux/ipv6.h",
      "include/net/ipv6.h||include/net/ipv6.h",
      "net/dccp/ipv6.c||net/dccp/ipv6.c",
      "net/ipv6/af_inet6.c||net/ipv6/af_inet6.c",
      "net/ipv6/datagram.c||net/ipv6/datagram.c",
      "net/ipv6/exthdrs.c||net/ipv6/exthdrs.c",
      "net/ipv6/inet6_connection_sock.c||net/ipv6/inet6_connection_sock.c",
      "net/ipv6/ipv6_sockglue.c||net/ipv6/ipv6_sockglue.c",
      "net/ipv6/raw.c||net/ipv6/raw.c",
      "net/ipv6/syncookies.c||net/ipv6/syncookies.c",
      "net/ipv6/tcp_ipv6.c||net/ipv6/tcp_ipv6.c",
      "net/ipv6/udp.c||net/ipv6/udp.c",
      "net/l2tp/l2tp_ip6.c||net/l2tp/l2tp_ip6.c"
    ]
  },
  "patch_diff": {
    "include/linux/ipv6.h||include/linux/ipv6.h": [
      "File: include/linux/ipv6.h -> include/linux/ipv6.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "227:  struct ipv6_ac_socklist *ipv6_ac_list;",
      "228:  struct ipv6_fl_socklist __rcu *ipv6_fl_list;",
      "231:  struct sk_buff  *pktoptions;",
      "232:  struct sk_buff  *rxpmtu;",
      "233:  struct inet6_cork cork;",
      "",
      "[Removed Lines]",
      "230:  struct ipv6_txoptions *opt;",
      "",
      "[Added Lines]",
      "230:  struct ipv6_txoptions __rcu *opt;",
      "",
      "---------------"
    ],
    "include/net/ipv6.h||include/net/ipv6.h": [
      "File: include/net/ipv6.h -> include/net/ipv6.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "207: struct ipv6_txoptions {",
      "209:  int   tot_len;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "208:  atomic_t  refcnt;",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "217:  struct ipv6_opt_hdr *dst0opt;",
      "219:  struct ipv6_opt_hdr *dst1opt;",
      "222: };",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "221:  struct rcu_head  rcu;",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "252:  struct rcu_head   rcu;",
      "253: };",
      "255: struct ip6_flowlabel *fl6_sock_lookup(struct sock *sk, __be32 label);",
      "256: struct ipv6_txoptions *fl6_merge_options(struct ipv6_txoptions *opt_space,",
      "257:       struct ip6_flowlabel *fl,",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "256: static inline struct ipv6_txoptions *txopt_get(const struct ipv6_pinfo *np)",
      "257: {",
      "258:  struct ipv6_txoptions *opt;",
      "260:  rcu_read_lock();",
      "261:  opt = rcu_dereference(np->opt);",
      "262:  if (opt && !atomic_inc_not_zero(&opt->refcnt))",
      "263:   opt = NULL;",
      "264:  rcu_read_unlock();",
      "265:  return opt;",
      "266: }",
      "268: static inline void txopt_put(struct ipv6_txoptions *opt)",
      "269: {",
      "270:  if (opt && atomic_dec_and_test(&opt->refcnt))",
      "271:   kfree_rcu(opt, rcu);",
      "272: }",
      "",
      "---------------"
    ],
    "net/dccp/ipv6.c||net/dccp/ipv6.c": [
      "File: net/dccp/ipv6.c -> net/dccp/ipv6.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "202:  security_req_classify_flow(req, flowi6_to_flowi(&fl6));",
      "207:  dst = ip6_dst_lookup_flow(sk, &fl6, final_p);",
      "208:  if (IS_ERR(dst)) {",
      "",
      "[Removed Lines]",
      "205:  final_p = fl6_update_dst(&fl6, np->opt, &final);",
      "",
      "[Added Lines]",
      "205:  rcu_read_lock();",
      "206:  final_p = fl6_update_dst(&fl6, rcu_dereference(np->opt), &final);",
      "207:  rcu_read_unlock();",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "219:         &ireq->ir_v6_loc_addr,",
      "220:         &ireq->ir_v6_rmt_addr);",
      "221:   fl6.daddr = ireq->ir_v6_rmt_addr;",
      "223:   err = net_xmit_eval(err);",
      "224:  }",
      "",
      "[Removed Lines]",
      "222:   err = ip6_xmit(sk, skb, &fl6, np->opt, np->tclass);",
      "",
      "[Added Lines]",
      "224:   rcu_read_lock();",
      "225:   err = ip6_xmit(sk, skb, &fl6, rcu_dereference(np->opt),",
      "226:           np->tclass);",
      "227:   rcu_read_unlock();",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "387:  struct inet_request_sock *ireq = inet_rsk(req);",
      "388:  struct ipv6_pinfo *newnp;",
      "389:  const struct ipv6_pinfo *np = inet6_sk(sk);",
      "390:  struct inet_sock *newinet;",
      "391:  struct dccp6_sock *newdp6;",
      "392:  struct sock *newsk;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "395:  struct ipv6_txoptions *opt;",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "494:  inet_csk(newsk)->icsk_ext_hdr_len = 0;",
      "499:  dccp_sync_mss(newsk, dst_mtu(dst));",
      "",
      "[Removed Lines]",
      "491:  if (np->opt != NULL)",
      "492:   newnp->opt = ipv6_dup_options(newsk, np->opt);",
      "495:  if (newnp->opt != NULL)",
      "496:   inet_csk(newsk)->icsk_ext_hdr_len = (newnp->opt->opt_nflen +",
      "497:            newnp->opt->opt_flen);",
      "",
      "[Added Lines]",
      "497:  opt = rcu_dereference(np->opt);",
      "498:  if (opt) {",
      "499:   opt = ipv6_dup_options(newsk, opt);",
      "500:   RCU_INIT_POINTER(newnp->opt, opt);",
      "501:  }",
      "503:  if (opt)",
      "504:   inet_csk(newsk)->icsk_ext_hdr_len = opt->opt_nflen +",
      "505:           opt->opt_flen;",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "757:  struct ipv6_pinfo *np = inet6_sk(sk);",
      "758:  struct dccp_sock *dp = dccp_sk(sk);",
      "759:  struct in6_addr *saddr = NULL, *final_p, final;",
      "760:  struct flowi6 fl6;",
      "761:  struct dst_entry *dst;",
      "762:  int addr_type;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "768:  struct ipv6_txoptions *opt;",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "856:  fl6.fl6_sport = inet->inet_sport;",
      "857:  security_sk_classify_flow(sk, flowi6_to_flowi(&fl6));",
      "861:  dst = ip6_dst_lookup_flow(sk, &fl6, final_p);",
      "862:  if (IS_ERR(dst)) {",
      "",
      "[Removed Lines]",
      "859:  final_p = fl6_update_dst(&fl6, np->opt, &final);",
      "",
      "[Added Lines]",
      "868:  opt = rcu_dereference_protected(np->opt, sock_owned_by_user(sk));",
      "869:  final_p = fl6_update_dst(&fl6, opt, &final);",
      "",
      "---------------",
      "--- Hunk 7 ---",
      "[Context before]",
      "876:  __ip6_dst_store(sk, dst, NULL, NULL);",
      "878:  icsk->icsk_ext_hdr_len = 0;",
      "883:  inet->inet_dport = usin->sin6_port;",
      "",
      "[Removed Lines]",
      "879:  if (np->opt != NULL)",
      "880:   icsk->icsk_ext_hdr_len = (np->opt->opt_flen +",
      "881:        np->opt->opt_nflen);",
      "",
      "[Added Lines]",
      "889:  if (opt)",
      "890:   icsk->icsk_ext_hdr_len = opt->opt_flen + opt->opt_nflen;",
      "",
      "---------------"
    ],
    "net/ipv6/af_inet6.c||net/ipv6/af_inet6.c": [
      "File: net/ipv6/af_inet6.c -> net/ipv6/af_inet6.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "434: }",
      "435: EXPORT_SYMBOL_GPL(inet6_destroy_sock);",
      "",
      "[Removed Lines]",
      "431:  opt = xchg(&np->opt, NULL);",
      "432:  if (opt)",
      "433:   sock_kfree_s(sk, opt, opt->tot_len);",
      "",
      "[Added Lines]",
      "431:  opt = xchg((__force struct ipv6_txoptions **)&np->opt, NULL);",
      "432:  if (opt) {",
      "433:   atomic_sub(opt->tot_len, &sk->sk_omem_alloc);",
      "434:   txopt_put(opt);",
      "435:  }",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "659:   fl6.fl6_sport = inet->inet_sport;",
      "660:   security_sk_classify_flow(sk, flowi6_to_flowi(&fl6));",
      "664:   dst = ip6_dst_lookup_flow(sk, &fl6, final_p);",
      "665:   if (IS_ERR(dst)) {",
      "",
      "[Removed Lines]",
      "662:   final_p = fl6_update_dst(&fl6, np->opt, &final);",
      "",
      "[Added Lines]",
      "664:   rcu_read_lock();",
      "665:   final_p = fl6_update_dst(&fl6, rcu_dereference(np->opt),",
      "666:       &final);",
      "667:   rcu_read_unlock();",
      "",
      "---------------"
    ],
    "net/ipv6/datagram.c||net/ipv6/datagram.c": [
      "File: net/ipv6/datagram.c -> net/ipv6/datagram.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "168:  security_sk_classify_flow(sk, flowi6_to_flowi(&fl6));",
      "171:  final_p = fl6_update_dst(&fl6, opt, &final);",
      "173:  dst = ip6_dst_lookup_flow(sk, &fl6, final_p);",
      "174:  err = 0;",
      "",
      "[Removed Lines]",
      "170:  opt = flowlabel ? flowlabel->opt : np->opt;",
      "",
      "[Added Lines]",
      "170:  rcu_read_lock();",
      "171:  opt = flowlabel ? flowlabel->opt : rcu_dereference(np->opt);",
      "173:  rcu_read_unlock();",
      "",
      "---------------"
    ],
    "net/ipv6/exthdrs.c||net/ipv6/exthdrs.c": [
      "File: net/ipv6/exthdrs.c -> net/ipv6/exthdrs.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "728:   if (opt2->srcrt)",
      "730:  }",
      "731:  return opt2;",
      "732: }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "730:   atomic_set(&opt2->refcnt, 1);",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "790:   return ERR_PTR(-ENOBUFS);",
      "792:  memset(opt2, 0, tot_len);",
      "794:  opt2->tot_len = tot_len;",
      "795:  p = (char *)(opt2 + 1);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "794:  atomic_set(&opt2->refcnt, 1);",
      "",
      "---------------"
    ],
    "net/ipv6/inet6_connection_sock.c||net/ipv6/inet6_connection_sock.c": [
      "File: net/ipv6/inet6_connection_sock.c -> net/ipv6/inet6_connection_sock.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "78:  memset(fl6, 0, sizeof(*fl6));",
      "79:  fl6->flowi6_proto = proto;",
      "80:  fl6->daddr = ireq->ir_v6_rmt_addr;",
      "82:  fl6->saddr = ireq->ir_v6_loc_addr;",
      "83:  fl6->flowi6_oif = ireq->ir_iif;",
      "84:  fl6->flowi6_mark = ireq->ir_mark;",
      "",
      "[Removed Lines]",
      "81:  final_p = fl6_update_dst(fl6, np->opt, &final);",
      "",
      "[Added Lines]",
      "81:  rcu_read_lock();",
      "82:  final_p = fl6_update_dst(fl6, rcu_dereference(np->opt), &final);",
      "83:  rcu_read_unlock();",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "142:  fl6->fl6_dport = inet->inet_dport;",
      "143:  security_sk_classify_flow(sk, flowi6_to_flowi(fl6));",
      "147:  dst = __inet6_csk_dst_check(sk, np->dst_cookie);",
      "148:  if (!dst) {",
      "",
      "[Removed Lines]",
      "145:  final_p = fl6_update_dst(fl6, np->opt, &final);",
      "",
      "[Added Lines]",
      "147:  rcu_read_lock();",
      "148:  final_p = fl6_update_dst(fl6, rcu_dereference(np->opt), &final);",
      "149:  rcu_read_unlock();",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "176:  fl6.daddr = sk->sk_v6_daddr;",
      "179:  rcu_read_unlock();",
      "180:  return res;",
      "181: }",
      "",
      "[Removed Lines]",
      "178:  res = ip6_xmit(sk, skb, &fl6, np->opt, np->tclass);",
      "",
      "[Added Lines]",
      "182:  res = ip6_xmit(sk, skb, &fl6, rcu_dereference(np->opt),",
      "183:          np->tclass);",
      "",
      "---------------"
    ],
    "net/ipv6/ipv6_sockglue.c||net/ipv6/ipv6_sockglue.c": [
      "File: net/ipv6/ipv6_sockglue.c -> net/ipv6/ipv6_sockglue.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "111:    icsk->icsk_sync_mss(sk, icsk->icsk_pmtu_cookie);",
      "112:   }",
      "113:  }",
      "115:  sk_dst_reset(sk);",
      "117:  return opt;",
      "",
      "[Removed Lines]",
      "114:  opt = xchg(&inet6_sk(sk)->opt, opt);",
      "",
      "[Added Lines]",
      "114:  opt = xchg((__force struct ipv6_txoptions **)&inet6_sk(sk)->opt,",
      "115:      opt);",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "231:     sk->sk_socket->ops = &inet_dgram_ops;",
      "232:     sk->sk_family = PF_INET;",
      "233:    }",
      "237:    pktopt = xchg(&np->pktoptions, NULL);",
      "238:    kfree_skb(pktopt);",
      "",
      "[Removed Lines]",
      "234:    opt = xchg(&np->opt, NULL);",
      "235:    if (opt)",
      "236:     sock_kfree_s(sk, opt, opt->tot_len);",
      "",
      "[Added Lines]",
      "235:    opt = xchg((__force struct ipv6_txoptions **)&np->opt,",
      "236:        NULL);",
      "237:    if (opt) {",
      "238:     atomic_sub(opt->tot_len, &sk->sk_omem_alloc);",
      "239:     txopt_put(opt);",
      "240:    }",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "403:   if (optname != IPV6_RTHDR && !ns_capable(net->user_ns, CAP_NET_RAW))",
      "404:    break;",
      "407:       (struct ipv6_opt_hdr __user *)optval,",
      "408:       optlen);",
      "409:   if (IS_ERR(opt)) {",
      "",
      "[Removed Lines]",
      "406:   opt = ipv6_renew_options(sk, np->opt, optname,",
      "",
      "[Added Lines]",
      "410:   opt = rcu_dereference_protected(np->opt, sock_owned_by_user(sk));",
      "411:   opt = ipv6_renew_options(sk, opt, optname,",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "432:   retv = 0;",
      "433:   opt = ipv6_update_options(sk, opt);",
      "434: sticky_done:",
      "437:   break;",
      "438:  }",
      "",
      "[Removed Lines]",
      "435:   if (opt)",
      "436:    sock_kfree_s(sk, opt, opt->tot_len);",
      "",
      "[Added Lines]",
      "440:   if (opt) {",
      "441:    atomic_sub(opt->tot_len, &sk->sk_omem_alloc);",
      "442:    txopt_put(opt);",
      "443:   }",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "486:    break;",
      "488:   memset(opt, 0, sizeof(*opt));",
      "489:   opt->tot_len = sizeof(*opt) + optlen;",
      "490:   retv = -EFAULT;",
      "491:   if (copy_from_user(opt+1, optval, optlen))",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "496:   atomic_set(&opt->refcnt, 1);",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "502:   retv = 0;",
      "503:   opt = ipv6_update_options(sk, opt);",
      "504: done:",
      "507:   break;",
      "508:  }",
      "509:  case IPV6_UNICAST_HOPS:",
      "",
      "[Removed Lines]",
      "505:   if (opt)",
      "506:    sock_kfree_s(sk, opt, opt->tot_len);",
      "",
      "[Added Lines]",
      "513:   if (opt) {",
      "514:    atomic_sub(opt->tot_len, &sk->sk_omem_alloc);",
      "515:    txopt_put(opt);",
      "516:   }",
      "",
      "---------------",
      "--- Hunk 7 ---",
      "[Context before]",
      "1110:  case IPV6_RTHDR:",
      "1111:  case IPV6_DSTOPTS:",
      "1112:  {",
      "1114:   lock_sock(sk);",
      "1117:   release_sock(sk);",
      "1119:   if (len < 0)",
      "",
      "[Removed Lines]",
      "1115:   len = ipv6_getsockopt_sticky(sk, np->opt,",
      "1116:           optname, optval, len);",
      "",
      "[Added Lines]",
      "1123:   struct ipv6_txoptions *opt;",
      "1126:   opt = rcu_dereference_protected(np->opt, sock_owned_by_user(sk));",
      "1127:   len = ipv6_getsockopt_sticky(sk, opt, optname, optval, len);",
      "",
      "---------------"
    ],
    "net/ipv6/raw.c||net/ipv6/raw.c": [
      "File: net/ipv6/raw.c -> net/ipv6/raw.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "734: static int rawv6_sendmsg(struct sock *sk, struct msghdr *msg, size_t len)",
      "735: {",
      "736:  struct ipv6_txoptions opt_space;",
      "737:  DECLARE_SOCKADDR(struct sockaddr_in6 *, sin6, msg->msg_name);",
      "738:  struct in6_addr *daddr, *final_p, final;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "736:  struct ipv6_txoptions *opt_to_free = NULL;",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "839:   if (!(opt->opt_nflen|opt->opt_flen))",
      "840:    opt = NULL;",
      "841:  }",
      "844:  if (flowlabel)",
      "845:   opt = fl6_merge_options(&opt_space, flowlabel, opt);",
      "846:  opt = ipv6_fixup_options(&opt_space, opt);",
      "",
      "[Removed Lines]",
      "842:  if (!opt)",
      "843:   opt = np->opt;",
      "",
      "[Added Lines]",
      "843:  if (!opt) {",
      "844:   opt = txopt_get(np);",
      "845:   opt_to_free = opt;",
      "846:   }",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "906:  dst_release(dst);",
      "907: out:",
      "908:  fl6_sock_release(flowlabel);",
      "909:  return err < 0 ? err : len;",
      "910: do_confirm:",
      "911:  dst_confirm(dst);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "912:  txopt_put(opt_to_free);",
      "",
      "---------------"
    ],
    "net/ipv6/syncookies.c||net/ipv6/syncookies.c": [
      "File: net/ipv6/syncookies.c -> net/ipv6/syncookies.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "222:   memset(&fl6, 0, sizeof(fl6));",
      "223:   fl6.flowi6_proto = IPPROTO_TCP;",
      "224:   fl6.daddr = ireq->ir_v6_rmt_addr;",
      "226:   fl6.saddr = ireq->ir_v6_loc_addr;",
      "227:   fl6.flowi6_oif = sk->sk_bound_dev_if;",
      "228:   fl6.flowi6_mark = ireq->ir_mark;",
      "",
      "[Removed Lines]",
      "225:   final_p = fl6_update_dst(&fl6, np->opt, &final);",
      "",
      "[Added Lines]",
      "225:   final_p = fl6_update_dst(&fl6, rcu_dereference(np->opt), &final);",
      "",
      "---------------"
    ],
    "net/ipv6/tcp_ipv6.c||net/ipv6/tcp_ipv6.c": [
      "File: net/ipv6/tcp_ipv6.c -> net/ipv6/tcp_ipv6.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "120:  struct ipv6_pinfo *np = inet6_sk(sk);",
      "121:  struct tcp_sock *tp = tcp_sk(sk);",
      "122:  struct in6_addr *saddr = NULL, *final_p, final;",
      "123:  struct flowi6 fl6;",
      "124:  struct dst_entry *dst;",
      "125:  int addr_type;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "123:  struct ipv6_txoptions *opt;",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "235:  fl6.fl6_dport = usin->sin6_port;",
      "236:  fl6.fl6_sport = inet->inet_sport;",
      "240:  security_sk_classify_flow(sk, flowi6_to_flowi(&fl6));",
      "",
      "[Removed Lines]",
      "238:  final_p = fl6_update_dst(&fl6, np->opt, &final);",
      "",
      "[Added Lines]",
      "239:  opt = rcu_dereference_protected(np->opt, sock_owned_by_user(sk));",
      "240:  final_p = fl6_update_dst(&fl6, opt, &final);",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "263:   tcp_fetch_timewait_stamp(sk, dst);",
      "265:  icsk->icsk_ext_hdr_len = 0;",
      "270:  tp->rx_opt.mss_clamp = IPV6_MIN_MTU - sizeof(struct tcphdr) - sizeof(struct ipv6hdr);",
      "",
      "[Removed Lines]",
      "266:  if (np->opt)",
      "267:   icsk->icsk_ext_hdr_len = (np->opt->opt_flen +",
      "268:        np->opt->opt_nflen);",
      "",
      "[Added Lines]",
      "268:  if (opt)",
      "269:   icsk->icsk_ext_hdr_len = opt->opt_flen +",
      "270:       opt->opt_nflen;",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "461:   if (np->repflow && ireq->pktopts)",
      "462:    fl6->flowlabel = ip6_flowlabel(ipv6_hdr(ireq->pktopts));",
      "465:   err = net_xmit_eval(err);",
      "466:  }",
      "",
      "[Removed Lines]",
      "464:   err = ip6_xmit(sk, skb, fl6, np->opt, np->tclass);",
      "",
      "[Added Lines]",
      "466:   err = ip6_xmit(sk, skb, fl6, rcu_dereference(np->opt),",
      "467:           np->tclass);",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "972:  struct inet_request_sock *ireq;",
      "973:  struct ipv6_pinfo *newnp;",
      "974:  const struct ipv6_pinfo *np = inet6_sk(sk);",
      "975:  struct tcp6_sock *newtcp6sk;",
      "976:  struct inet_sock *newinet;",
      "977:  struct tcp_sock *newtp;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "978:  struct ipv6_txoptions *opt;",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "1098:     but we make one more one thing there: reattach optmem",
      "1099:     to newsk.",
      "1104:  inet_csk(newsk)->icsk_ext_hdr_len = 0;",
      "1109:  tcp_ca_openreq_child(newsk, dst);",
      "",
      "[Removed Lines]",
      "1101:  if (np->opt)",
      "1102:   newnp->opt = ipv6_dup_options(newsk, np->opt);",
      "1105:  if (newnp->opt)",
      "1106:   inet_csk(newsk)->icsk_ext_hdr_len = (newnp->opt->opt_nflen +",
      "1107:            newnp->opt->opt_flen);",
      "",
      "[Added Lines]",
      "1105:  opt = rcu_dereference(np->opt);",
      "1106:  if (opt) {",
      "1107:   opt = ipv6_dup_options(newsk, opt);",
      "1108:   RCU_INIT_POINTER(newnp->opt, opt);",
      "1109:  }",
      "1111:  if (opt)",
      "1112:   inet_csk(newsk)->icsk_ext_hdr_len = opt->opt_nflen +",
      "1113:           opt->opt_flen;",
      "",
      "---------------"
    ],
    "net/ipv6/udp.c||net/ipv6/udp.c": [
      "File: net/ipv6/udp.c -> net/ipv6/udp.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "1110:  DECLARE_SOCKADDR(struct sockaddr_in6 *, sin6, msg->msg_name);",
      "1111:  struct in6_addr *daddr, *final_p, final;",
      "1112:  struct ipv6_txoptions *opt = NULL;",
      "1113:  struct ip6_flowlabel *flowlabel = NULL;",
      "1114:  struct flowi6 fl6;",
      "1115:  struct dst_entry *dst;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1113:  struct ipv6_txoptions *opt_to_free = NULL;",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "1263:    opt = NULL;",
      "1264:   connected = 0;",
      "1265:  }",
      "1268:  if (flowlabel)",
      "1269:   opt = fl6_merge_options(&opt_space, flowlabel, opt);",
      "1270:  opt = ipv6_fixup_options(&opt_space, opt);",
      "",
      "[Removed Lines]",
      "1266:  if (!opt)",
      "1267:   opt = np->opt;",
      "",
      "[Added Lines]",
      "1267:  if (!opt) {",
      "1268:   opt = txopt_get(np);",
      "1269:   opt_to_free = opt;",
      "1270:  }",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "1373: out:",
      "1374:  dst_release(dst);",
      "1375:  fl6_sock_release(flowlabel);",
      "1376:  if (!err)",
      "1377:   return len;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1379:  txopt_put(opt_to_free);",
      "",
      "---------------"
    ],
    "net/l2tp/l2tp_ip6.c||net/l2tp/l2tp_ip6.c": [
      "File: net/l2tp/l2tp_ip6.c -> net/l2tp/l2tp_ip6.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "486:  DECLARE_SOCKADDR(struct sockaddr_l2tpip6 *, lsa, msg->msg_name);",
      "487:  struct in6_addr *daddr, *final_p, final;",
      "488:  struct ipv6_pinfo *np = inet6_sk(sk);",
      "489:  struct ipv6_txoptions *opt = NULL;",
      "490:  struct ip6_flowlabel *flowlabel = NULL;",
      "491:  struct dst_entry *dst = NULL;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "489:  struct ipv6_txoptions *opt_to_free = NULL;",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "575:    opt = NULL;",
      "576:  }",
      "580:  if (flowlabel)",
      "581:   opt = fl6_merge_options(&opt_space, flowlabel, opt);",
      "582:  opt = ipv6_fixup_options(&opt_space, opt);",
      "",
      "[Removed Lines]",
      "578:  if (opt == NULL)",
      "579:   opt = np->opt;",
      "",
      "[Added Lines]",
      "579:  if (!opt) {",
      "580:   opt = txopt_get(np);",
      "581:   opt_to_free = opt;",
      "582:  }",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "631:  dst_release(dst);",
      "632: out:",
      "633:  fl6_sock_release(flowlabel);",
      "635:  return err < 0 ? err : len;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "637:  txopt_put(opt_to_free);",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "1cdda91871470f15e79375991bd2eddc6e86ddb1",
      "candidate_info": {
        "commit_hash": "1cdda91871470f15e79375991bd2eddc6e86ddb1",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/1cdda91871470f15e79375991bd2eddc6e86ddb1",
        "files": [
          "net/ipv6/datagram.c"
        ],
        "message": "ipv6/udp: use sticky pktinfo egress ifindex on connect()\n\nCurrently, the egress interface index specified via IPV6_PKTINFO\nis ignored by __ip6_datagram_connect(), so that RFC 3542 section 6.7\ncan be subverted when the user space application calls connect()\nbefore sendmsg().\nFix it by initializing properly flowi6_oif in connect() before\nperforming the route lookup.\n\nSigned-off-by: Paolo Abeni <pabeni@redhat.com>\nAcked-by: Hannes Frederic Sowa <hannes@stressinduktion.org>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "before_after_code_files": [
          "net/ipv6/datagram.c||net/ipv6/datagram.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "net/ipv6/datagram.c||net/ipv6/datagram.c"
          ],
          "candidate": [
            "net/ipv6/datagram.c||net/ipv6/datagram.c"
          ]
        }
      },
      "candidate_diff": {
        "net/ipv6/datagram.c||net/ipv6/datagram.c": [
          "File: net/ipv6/datagram.c -> net/ipv6/datagram.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "162:  fl6.fl6_dport = inet->inet_dport;",
          "163:  fl6.fl6_sport = inet->inet_sport;",
          "165:  if (!fl6.flowi6_oif && (addr_type&IPV6_ADDR_MULTICAST))",
          "166:   fl6.flowi6_oif = np->mcast_oif;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "165:  if (!fl6.flowi6_oif)",
          "166:   fl6.flowi6_oif = np->sticky_pktinfo.ipi6_ifindex;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "26879da58711aa604a1b866cbeedd7e0f78f90ad",
      "candidate_info": {
        "commit_hash": "26879da58711aa604a1b866cbeedd7e0f78f90ad",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/26879da58711aa604a1b866cbeedd7e0f78f90ad",
        "files": [
          "include/net/ipv6.h",
          "include/net/transp_v6.h",
          "net/ipv6/datagram.c",
          "net/ipv6/icmp.c",
          "net/ipv6/ip6_flowlabel.c",
          "net/ipv6/ip6_output.c",
          "net/ipv6/ipv6_sockglue.c",
          "net/ipv6/ping.c",
          "net/ipv6/raw.c",
          "net/ipv6/udp.c",
          "net/l2tp/l2tp_ip6.c"
        ],
        "message": "ipv6: add new struct ipcm6_cookie\n\nIn the sendmsg function of UDP, raw, ICMP and l2tp sockets, we use local\nvariables like hlimits, tclass, opt and dontfrag and pass them to corresponding\nfunctions like ip6_make_skb, ip6_append_data and xxx_push_pending_frames.\nThis is not a good practice and makes it hard to add new parameters.\nThis fix introduces a new struct ipcm6_cookie similar to ipcm_cookie in\nipv4 and include the above mentioned variables. And we only pass the\npointer to this structure to corresponding functions. This makes it easier\nto add new parameters in the future and makes the function cleaner.\n\nSigned-off-by: Wei Wang <weiwan@google.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "before_after_code_files": [
          "include/net/ipv6.h||include/net/ipv6.h",
          "include/net/transp_v6.h||include/net/transp_v6.h",
          "net/ipv6/datagram.c||net/ipv6/datagram.c",
          "net/ipv6/icmp.c||net/ipv6/icmp.c",
          "net/ipv6/ip6_flowlabel.c||net/ipv6/ip6_flowlabel.c",
          "net/ipv6/ip6_output.c||net/ipv6/ip6_output.c",
          "net/ipv6/ipv6_sockglue.c||net/ipv6/ipv6_sockglue.c",
          "net/ipv6/ping.c||net/ipv6/ping.c",
          "net/ipv6/raw.c||net/ipv6/raw.c",
          "net/ipv6/udp.c||net/ipv6/udp.c",
          "net/l2tp/l2tp_ip6.c||net/l2tp/l2tp_ip6.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "include/net/ipv6.h||include/net/ipv6.h",
            "net/ipv6/datagram.c||net/ipv6/datagram.c",
            "net/ipv6/ipv6_sockglue.c||net/ipv6/ipv6_sockglue.c",
            "net/ipv6/raw.c||net/ipv6/raw.c",
            "net/ipv6/udp.c||net/ipv6/udp.c",
            "net/l2tp/l2tp_ip6.c||net/l2tp/l2tp_ip6.c"
          ],
          "candidate": [
            "include/net/ipv6.h||include/net/ipv6.h",
            "net/ipv6/datagram.c||net/ipv6/datagram.c",
            "net/ipv6/ipv6_sockglue.c||net/ipv6/ipv6_sockglue.c",
            "net/ipv6/raw.c||net/ipv6/raw.c",
            "net/ipv6/udp.c||net/ipv6/udp.c",
            "net/l2tp/l2tp_ip6.c||net/l2tp/l2tp_ip6.c"
          ]
        }
      },
      "candidate_diff": {
        "include/net/ipv6.h||include/net/ipv6.h": [
          "File: include/net/ipv6.h -> include/net/ipv6.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "251:  struct rcu_head   rcu;",
          "252: };",
          "254: static inline struct ipv6_txoptions *txopt_get(const struct ipv6_pinfo *np)",
          "255: {",
          "256:  struct ipv6_txoptions *opt;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "254: struct ipcm6_cookie {",
          "255:  __s16 hlimit;",
          "256:  __s16 tclass;",
          "257:  __s8  dontfrag;",
          "258:  struct ipv6_txoptions *opt;",
          "259: };",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "863: int ip6_append_data(struct sock *sk,",
          "864:       int getfrag(void *from, char *to, int offset, int len,",
          "865:     int odd, struct sk_buff *skb),",
          "869:       const struct sockcm_cookie *sockc);",
          "871: int ip6_push_pending_frames(struct sock *sk);",
          "",
          "[Removed Lines]",
          "866:       void *from, int length, int transhdrlen, int hlimit,",
          "867:       int tclass, struct ipv6_txoptions *opt, struct flowi6 *fl6,",
          "868:       struct rt6_info *rt, unsigned int flags, int dontfrag,",
          "",
          "[Added Lines]",
          "873:       void *from, int length, int transhdrlen,",
          "874:       struct ipcm6_cookie *ipc6, struct flowi6 *fl6,",
          "875:       struct rt6_info *rt, unsigned int flags,",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "881:         int getfrag(void *from, char *to, int offset,",
          "882:       int len, int odd, struct sk_buff *skb),",
          "883:         void *from, int length, int transhdrlen,",
          "887:         const struct sockcm_cookie *sockc);",
          "889: static inline struct sk_buff *ip6_finish_skb(struct sock *sk)",
          "",
          "[Removed Lines]",
          "884:         int hlimit, int tclass, struct ipv6_txoptions *opt,",
          "885:         struct flowi6 *fl6, struct rt6_info *rt,",
          "886:         unsigned int flags, int dontfrag,",
          "",
          "[Added Lines]",
          "891:         struct ipcm6_cookie *ipc6, struct flowi6 *fl6,",
          "892:         struct rt6_info *rt, unsigned int flags,",
          "",
          "---------------"
        ],
        "include/net/transp_v6.h||include/net/transp_v6.h": [
          "File: include/net/transp_v6.h -> include/net/transp_v6.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "41:         struct sk_buff *skb);",
          "43: int ip6_datagram_send_ctl(struct net *net, struct sock *sk, struct msghdr *msg,",
          "46:      struct sockcm_cookie *sockc);",
          "48: void ip6_dgram_sock_seq_show(struct seq_file *seq, struct sock *sp,",
          "",
          "[Removed Lines]",
          "44:      struct flowi6 *fl6, struct ipv6_txoptions *opt,",
          "45:      int *hlimit, int *tclass, int *dontfrag,",
          "",
          "[Added Lines]",
          "44:      struct flowi6 *fl6, struct ipcm6_cookie *ipc6,",
          "",
          "---------------"
        ],
        "net/ipv6/datagram.c||net/ipv6/datagram.c": [
          "File: net/ipv6/datagram.c -> net/ipv6/datagram.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "728: int ip6_datagram_send_ctl(struct net *net, struct sock *sk,",
          "729:      struct msghdr *msg, struct flowi6 *fl6,",
          "733: {",
          "734:  struct in6_pktinfo *src_info;",
          "735:  struct cmsghdr *cmsg;",
          "736:  struct ipv6_rt_hdr *rthdr;",
          "737:  struct ipv6_opt_hdr *hdr;",
          "738:  int len;",
          "739:  int err = 0;",
          "",
          "[Removed Lines]",
          "730:      struct ipv6_txoptions *opt,",
          "731:      int *hlimit, int *tclass, int *dontfrag,",
          "732:      struct sockcm_cookie *sockc)",
          "",
          "[Added Lines]",
          "730:      struct ipcm6_cookie *ipc6, struct sockcm_cookie *sockc)",
          "736:  struct ipv6_txoptions *opt = ipc6->opt;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "953:     goto exit_f;",
          "954:    }",
          "958:     err = -EINVAL;",
          "959:     goto exit_f;",
          "960:    }",
          "",
          "[Removed Lines]",
          "957:    if (*hlimit < -1 || *hlimit > 0xff) {",
          "",
          "[Added Lines]",
          "955:    ipc6->hlimit = *(int *)CMSG_DATA(cmsg);",
          "956:    if (ipc6->hlimit < -1 || ipc6->hlimit > 0xff) {",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "974:     goto exit_f;",
          "976:    err = 0;",
          "979:    break;",
          "980:       }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "976:    ipc6->tclass = tc;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "992:     goto exit_f;",
          "994:    err = 0;",
          "997:    break;",
          "998:       }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "994:    ipc6->dontfrag = df;",
          "",
          "---------------"
        ],
        "net/ipv6/icmp.c||net/ipv6/icmp.c": [
          "File: net/ipv6/icmp.c -> net/ipv6/icmp.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "401:  struct flowi6 fl6;",
          "402:  struct icmpv6_msg msg;",
          "403:  struct sockcm_cookie sockc_unused = {0};",
          "404:  int iif = 0;",
          "405:  int addr_type = 0;",
          "406:  int len;",
          "408:  int err = 0;",
          "409:  u32 mark = IP6_REPLY_MARK(net, skb->mark);",
          "",
          "[Removed Lines]",
          "407:  int hlimit;",
          "",
          "[Added Lines]",
          "404:  struct ipcm6_cookie ipc6;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "507:  if (IS_ERR(dst))",
          "508:   goto out;",
          "512:  msg.skb = skb;",
          "513:  msg.offset = skb_network_offset(skb);",
          "",
          "[Removed Lines]",
          "510:  hlimit = ip6_sk_dst_hoplimit(np, &fl6, dst);",
          "",
          "[Added Lines]",
          "510:  ipc6.hlimit = ip6_sk_dst_hoplimit(np, &fl6, dst);",
          "511:  ipc6.tclass = np->tclass;",
          "512:  ipc6.dontfrag = np->dontfrag;",
          "513:  ipc6.opt = NULL;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "527:  err = ip6_append_data(sk, icmpv6_getfrag, &msg,",
          "528:          len + sizeof(struct icmp6hdr),",
          "532:  if (err) {",
          "533:   ICMP6_INC_STATS(net, idev, ICMP6_MIB_OUTERRORS);",
          "534:   ip6_flush_pending_frames(sk);",
          "",
          "[Removed Lines]",
          "529:          sizeof(struct icmp6hdr), hlimit,",
          "530:          np->tclass, NULL, &fl6, (struct rt6_info *)dst,",
          "531:          MSG_DONTWAIT, np->dontfrag, &sockc_unused);",
          "",
          "[Added Lines]",
          "532:          sizeof(struct icmp6hdr),",
          "533:          &ipc6, &fl6, (struct rt6_info *)dst,",
          "534:          MSG_DONTWAIT, &sockc_unused);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "563:  struct flowi6 fl6;",
          "564:  struct icmpv6_msg msg;",
          "565:  struct dst_entry *dst;",
          "566:  int err = 0;",
          "569:  u32 mark = IP6_REPLY_MARK(net, skb->mark);",
          "570:  struct sockcm_cookie sockc_unused = {0};",
          "",
          "[Removed Lines]",
          "567:  int hlimit;",
          "568:  u8 tclass;",
          "",
          "[Added Lines]",
          "569:  struct ipcm6_cookie ipc6;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "607:  if (IS_ERR(dst))",
          "608:   goto out;",
          "612:  idev = __in6_dev_get(skb->dev);",
          "614:  msg.skb = skb;",
          "615:  msg.offset = 0;",
          "616:  msg.type = ICMPV6_ECHO_REPLY;",
          "619:  err = ip6_append_data(sk, icmpv6_getfrag, &msg, skb->len + sizeof(struct icmp6hdr),",
          "621:     (struct rt6_info *)dst, MSG_DONTWAIT,",
          "624:  if (err) {",
          "625:   __ICMP6_INC_STATS(net, idev, ICMP6_MIB_OUTERRORS);",
          "",
          "[Removed Lines]",
          "610:  hlimit = ip6_sk_dst_hoplimit(np, &fl6, dst);",
          "618:  tclass = ipv6_get_dsfield(ipv6_hdr(skb));",
          "620:     sizeof(struct icmp6hdr), hlimit, tclass, NULL, &fl6,",
          "622:     np->dontfrag, &sockc_unused);",
          "",
          "[Added Lines]",
          "618:  ipc6.hlimit = ip6_sk_dst_hoplimit(np, &fl6, dst);",
          "619:  ipc6.tclass = ipv6_get_dsfield(ipv6_hdr(skb));",
          "620:  ipc6.dontfrag = np->dontfrag;",
          "621:  ipc6.opt = NULL;",
          "624:     sizeof(struct icmp6hdr), &ipc6, &fl6,",
          "626:     &sockc_unused);",
          "",
          "---------------"
        ],
        "net/ipv6/ip6_flowlabel.c||net/ipv6/ip6_flowlabel.c": [
          "File: net/ipv6/ip6_flowlabel.c -> net/ipv6/ip6_flowlabel.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "373:   struct msghdr msg;",
          "374:   struct flowi6 flowi6;",
          "375:   struct sockcm_cookie sockc_junk;",
          "378:   err = -ENOMEM;",
          "379:   fl->opt = kmalloc(sizeof(*fl->opt) + olen, GFP_KERNEL);",
          "",
          "[Removed Lines]",
          "376:   int junk;",
          "",
          "[Added Lines]",
          "376:   struct ipcm6_cookie ipc6;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "390:   msg.msg_control = (void *)(fl->opt+1);",
          "391:   memset(&flowi6, 0, sizeof(flowi6));",
          "395:   if (err)",
          "396:    goto done;",
          "397:   err = -EINVAL;",
          "",
          "[Removed Lines]",
          "393:   err = ip6_datagram_send_ctl(net, sk, &msg, &flowi6, fl->opt,",
          "394:          &junk, &junk, &junk, &sockc_junk);",
          "",
          "[Added Lines]",
          "393:   ipc6.opt = fl->opt;",
          "394:   err = ip6_datagram_send_ctl(net, sk, &msg, &flowi6, &ipc6, &sockc_junk);",
          "",
          "---------------"
        ],
        "net/ipv6/ip6_output.c||net/ipv6/ip6_output.c": [
          "File: net/ipv6/ip6_output.c -> net/ipv6/ip6_output.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1182: }",
          "1184: static int ip6_setup_cork(struct sock *sk, struct inet_cork_full *cork,",
          "1187:      struct rt6_info *rt, struct flowi6 *fl6)",
          "1188: {",
          "1189:  struct ipv6_pinfo *np = inet6_sk(sk);",
          "1190:  unsigned int mtu;",
          "",
          "[Removed Lines]",
          "1185:      struct inet6_cork *v6_cork,",
          "1186:      int hlimit, int tclass, struct ipv6_txoptions *opt,",
          "",
          "[Added Lines]",
          "1185:      struct inet6_cork *v6_cork, struct ipcm6_cookie *ipc6,",
          "1190:  struct ipv6_txoptions *opt = ipc6->opt;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1229:  dst_hold(&rt->dst);",
          "1230:  cork->base.dst = &rt->dst;",
          "1231:  cork->fl.u.ip6 = *fl6;",
          "1234:  if (rt->dst.flags & DST_XFRM_TUNNEL)",
          "1235:   mtu = np->pmtudisc >= IPV6_PMTUDISC_PROBE ?",
          "1236:         rt->dst.dev->mtu : dst_mtu(&rt->dst);",
          "",
          "[Removed Lines]",
          "1232:  v6_cork->hop_limit = hlimit;",
          "1233:  v6_cork->tclass = tclass;",
          "",
          "[Added Lines]",
          "1232:  v6_cork->hop_limit = ipc6->hlimit;",
          "1233:  v6_cork->tclass = ipc6->tclass;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1258:         int getfrag(void *from, char *to, int offset,",
          "1259:       int len, int odd, struct sk_buff *skb),",
          "1260:         void *from, int length, int transhdrlen,",
          "1262:         const struct sockcm_cookie *sockc)",
          "1263: {",
          "1264:  struct sk_buff *skb, *skb_prev = NULL;",
          "",
          "[Removed Lines]",
          "1261:         unsigned int flags, int dontfrag,",
          "",
          "[Added Lines]",
          "1261:         unsigned int flags, struct ipcm6_cookie *ipc6,",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1298:         sizeof(struct frag_hdr) : 0) +",
          "1299:        rt->rt6i_nfheader_len;",
          "1302:      (sk->sk_protocol == IPPROTO_UDP ||",
          "1303:       sk->sk_protocol == IPPROTO_RAW)) {",
          "1304:   ipv6_local_rxpmtu(sk, fl6, mtu - headersize +",
          "",
          "[Removed Lines]",
          "1301:  if (cork->length + length > mtu - headersize && dontfrag &&",
          "",
          "[Added Lines]",
          "1301:  if (cork->length + length > mtu - headersize && ipc6->dontfrag &&",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1564: int ip6_append_data(struct sock *sk,",
          "1565:       int getfrag(void *from, char *to, int offset, int len,",
          "1566:     int odd, struct sk_buff *skb),",
          "1570:       const struct sockcm_cookie *sockc)",
          "1571: {",
          "1572:  struct inet_sock *inet = inet_sk(sk);",
          "",
          "[Removed Lines]",
          "1567:       void *from, int length, int transhdrlen, int hlimit,",
          "1568:       int tclass, struct ipv6_txoptions *opt, struct flowi6 *fl6,",
          "1569:       struct rt6_info *rt, unsigned int flags, int dontfrag,",
          "",
          "[Added Lines]",
          "1567:       void *from, int length, int transhdrlen,",
          "1568:       struct ipcm6_cookie *ipc6, struct flowi6 *fl6,",
          "1569:       struct rt6_info *rt, unsigned int flags,",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1585:   if (err)",
          "1586:    return err;",
          "1589:   length += exthdrlen;",
          "1590:   transhdrlen += exthdrlen;",
          "1591:  } else {",
          "",
          "[Removed Lines]",
          "1583:   err = ip6_setup_cork(sk, &inet->cork, &np->cork, hlimit,",
          "1584:          tclass, opt, rt, fl6);",
          "1588:   exthdrlen = (opt ? opt->opt_flen : 0);",
          "",
          "[Added Lines]",
          "1583:   err = ip6_setup_cork(sk, &inet->cork, &np->cork,",
          "1584:          ipc6, rt, fl6);",
          "1588:   exthdrlen = (ipc6->opt ? ipc6->opt->opt_flen : 0);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "1596:  return __ip6_append_data(sk, fl6, &sk->sk_write_queue, &inet->cork.base,",
          "1597:      &np->cork, sk_page_frag(sk), getfrag,",
          "1600: }",
          "1601: EXPORT_SYMBOL_GPL(ip6_append_data);",
          "",
          "[Removed Lines]",
          "1598:      from, length, transhdrlen, flags, dontfrag,",
          "1599:      sockc);",
          "",
          "[Added Lines]",
          "1598:      from, length, transhdrlen, flags, ipc6, sockc);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "1752:         int getfrag(void *from, char *to, int offset,",
          "1753:       int len, int odd, struct sk_buff *skb),",
          "1754:         void *from, int length, int transhdrlen,",
          "1757:         struct rt6_info *rt, unsigned int flags,",
          "1759: {",
          "1760:  struct inet_cork_full cork;",
          "1761:  struct inet6_cork v6_cork;",
          "1762:  struct sk_buff_head queue;",
          "1764:  int err;",
          "1766:  if (flags & MSG_PROBE)",
          "",
          "[Removed Lines]",
          "1755:         int hlimit, int tclass,",
          "1756:         struct ipv6_txoptions *opt, struct flowi6 *fl6,",
          "1758:         int dontfrag, const struct sockcm_cookie *sockc)",
          "1763:  int exthdrlen = (opt ? opt->opt_flen : 0);",
          "",
          "[Added Lines]",
          "1754:         struct ipcm6_cookie *ipc6, struct flowi6 *fl6,",
          "1756:         const struct sockcm_cookie *sockc)",
          "1761:  int exthdrlen = (ipc6->opt ? ipc6->opt->opt_flen : 0);",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "1772:  cork.base.addr = 0;",
          "1773:  cork.base.opt = NULL;",
          "1774:  v6_cork.opt = NULL;",
          "1776:  if (err)",
          "1777:   return ERR_PTR(err);",
          "1782:  err = __ip6_append_data(sk, fl6, &queue, &cork.base, &v6_cork,",
          "1783:     &current->task_frag, getfrag, from,",
          "1784:     length + exthdrlen, transhdrlen + exthdrlen,",
          "1786:  if (err) {",
          "1787:   __ip6_flush_pending_frames(sk, &queue, &cork, &v6_cork);",
          "1788:   return ERR_PTR(err);",
          "",
          "[Removed Lines]",
          "1775:  err = ip6_setup_cork(sk, &cork, &v6_cork, hlimit, tclass, opt, rt, fl6);",
          "1779:  if (dontfrag < 0)",
          "1780:   dontfrag = inet6_sk(sk)->dontfrag;",
          "1785:     flags, dontfrag, sockc);",
          "",
          "[Added Lines]",
          "1773:  err = ip6_setup_cork(sk, &cork, &v6_cork, ipc6, rt, fl6);",
          "1777:  if (ipc6->dontfrag < 0)",
          "1778:   ipc6->dontfrag = inet6_sk(sk)->dontfrag;",
          "1783:     flags, ipc6, sockc);",
          "",
          "---------------"
        ],
        "net/ipv6/ipv6_sockglue.c||net/ipv6/ipv6_sockglue.c": [
          "File: net/ipv6/ipv6_sockglue.c -> net/ipv6/ipv6_sockglue.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "473:   struct msghdr msg;",
          "474:   struct flowi6 fl6;",
          "475:   struct sockcm_cookie sockc_junk;",
          "478:   memset(&fl6, 0, sizeof(fl6));",
          "479:   fl6.flowi6_oif = sk->sk_bound_dev_if;",
          "",
          "[Removed Lines]",
          "476:   int junk;",
          "",
          "[Added Lines]",
          "476:   struct ipcm6_cookie ipc6;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "504:   msg.msg_controllen = optlen;",
          "505:   msg.msg_control = (void *)(opt+1);",
          "509:   if (retv)",
          "510:    goto done;",
          "511: update:",
          "",
          "[Removed Lines]",
          "507:   retv = ip6_datagram_send_ctl(net, sk, &msg, &fl6, opt, &junk,",
          "508:           &junk, &junk, &sockc_junk);",
          "",
          "[Added Lines]",
          "506:   ipc6.opt = opt;",
          "508:   retv = ip6_datagram_send_ctl(net, sk, &msg, &fl6, &ipc6, &sockc_junk);",
          "",
          "---------------"
        ],
        "net/ipv6/ping.c||net/ipv6/ping.c": [
          "File: net/ipv6/ping.c -> net/ipv6/ping.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "58:  int iif = 0;",
          "59:  struct flowi6 fl6;",
          "60:  int err;",
          "62:  struct dst_entry *dst;",
          "63:  struct rt6_info *rt;",
          "64:  struct pingfakehdr pfh;",
          "65:  struct sockcm_cookie junk = {0};",
          "67:  pr_debug(\"ping_v6_sendmsg(sk=%p,sk->num=%u)\\n\", inet, inet->inet_num);",
          "",
          "[Removed Lines]",
          "61:  int hlimit;",
          "",
          "[Added Lines]",
          "65:  struct ipcm6_cookie ipc6;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "139:  pfh.wcheck = 0;",
          "140:  pfh.family = AF_INET6;",
          "144:  lock_sock(sk);",
          "145:  err = ip6_append_data(sk, ping_getfrag, &pfh, len,",
          "150:  if (err) {",
          "151:   ICMP6_INC_STATS(sock_net(sk), rt->rt6i_idev,",
          "",
          "[Removed Lines]",
          "142:  hlimit = ip6_sk_dst_hoplimit(np, &fl6, dst);",
          "146:          0, hlimit,",
          "147:          np->tclass, NULL, &fl6, rt,",
          "148:          MSG_DONTWAIT, np->dontfrag, &junk);",
          "",
          "[Added Lines]",
          "142:  ipc6.hlimit = ip6_sk_dst_hoplimit(np, &fl6, dst);",
          "143:  ipc6.tclass = np->tclass;",
          "144:  ipc6.dontfrag = np->dontfrag;",
          "145:  ipc6.opt = NULL;",
          "149:          0, &ipc6, &fl6, rt,",
          "150:          MSG_DONTWAIT, &junk);",
          "",
          "---------------"
        ],
        "net/ipv6/raw.c||net/ipv6/raw.c": [
          "File: net/ipv6/raw.c -> net/ipv6/raw.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "746:  struct raw6_frag_vec rfv;",
          "747:  struct flowi6 fl6;",
          "748:  struct sockcm_cookie sockc;",
          "749:  int addr_len = msg->msg_namelen;",
          "753:  u16 proto;",
          "754:  int err;",
          "",
          "[Removed Lines]",
          "750:  int hlimit = -1;",
          "751:  int tclass = -1;",
          "752:  int dontfrag = -1;",
          "",
          "[Added Lines]",
          "749:  struct ipcm6_cookie ipc6;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "771:  fl6.flowi6_mark = sk->sk_mark;",
          "773:  if (sin6) {",
          "774:   if (addr_len < SIN6_LEN_RFC2133)",
          "775:    return -EINVAL;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "771:  ipc6.hlimit = -1;",
          "772:  ipc6.tclass = -1;",
          "773:  ipc6.dontfrag = -1;",
          "774:  ipc6.opt = NULL;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "827:   opt = &opt_space;",
          "828:   memset(opt, 0, sizeof(struct ipv6_txoptions));",
          "829:   opt->tot_len = sizeof(struct ipv6_txoptions);",
          "834:   if (err < 0) {",
          "835:    fl6_sock_release(flowlabel);",
          "836:    return err;",
          "",
          "[Removed Lines]",
          "831:   err = ip6_datagram_send_ctl(sock_net(sk), sk, msg, &fl6, opt,",
          "832:          &hlimit, &tclass, &dontfrag,",
          "833:          &sockc);",
          "",
          "[Added Lines]",
          "833:   ipc6.opt = opt;",
          "835:   err = ip6_datagram_send_ctl(sock_net(sk), sk, msg, &fl6, &ipc6, &sockc);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "846:  if (!opt) {",
          "847:   opt = txopt_get(np);",
          "848:   opt_to_free = opt;",
          "850:  if (flowlabel)",
          "851:   opt = fl6_merge_options(&opt_space, flowlabel, opt);",
          "852:  opt = ipv6_fixup_options(&opt_space, opt);",
          "",
          "[Removed Lines]",
          "849:   }",
          "",
          "[Added Lines]",
          "851:  }",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "881:   err = PTR_ERR(dst);",
          "882:   goto out;",
          "883:  }",
          "893:  if (msg->msg_flags&MSG_CONFIRM)",
          "894:   goto do_confirm;",
          "",
          "[Removed Lines]",
          "884:  if (hlimit < 0)",
          "885:   hlimit = ip6_sk_dst_hoplimit(np, &fl6, dst);",
          "887:  if (tclass < 0)",
          "888:   tclass = np->tclass;",
          "890:  if (dontfrag < 0)",
          "891:   dontfrag = np->dontfrag;",
          "",
          "[Added Lines]",
          "886:  if (ipc6.hlimit < 0)",
          "887:   ipc6.hlimit = ip6_sk_dst_hoplimit(np, &fl6, dst);",
          "889:  if (ipc6.tclass < 0)",
          "890:   ipc6.tclass = np->tclass;",
          "892:  if (ipc6.dontfrag < 0)",
          "893:   ipc6.dontfrag = np->dontfrag;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "897:  if (inet->hdrincl)",
          "898:   err = rawv6_send_hdrinc(sk, msg, len, &fl6, &dst, msg->msg_flags);",
          "899:  else {",
          "900:   lock_sock(sk);",
          "901:   err = ip6_append_data(sk, raw6_getfrag, &rfv,",
          "905:   if (err)",
          "906:    ip6_flush_pending_frames(sk);",
          "",
          "[Removed Lines]",
          "902:    len, 0, hlimit, tclass, opt, &fl6, (struct rt6_info *)dst,",
          "903:    msg->msg_flags, dontfrag, &sockc);",
          "",
          "[Added Lines]",
          "902:   ipc6.opt = opt;",
          "905:    len, 0, &ipc6, &fl6, (struct rt6_info *)dst,",
          "906:    msg->msg_flags, &sockc);",
          "",
          "---------------"
        ],
        "net/ipv6/udp.c||net/ipv6/udp.c": [
          "File: net/ipv6/udp.c -> net/ipv6/udp.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1064:  struct ip6_flowlabel *flowlabel = NULL;",
          "1065:  struct flowi6 fl6;",
          "1066:  struct dst_entry *dst;",
          "1067:  int addr_len = msg->msg_namelen;",
          "1068:  int ulen = len;",
          "1072:  int corkreq = up->corkflag || msg->msg_flags&MSG_MORE;",
          "1073:  int err;",
          "1074:  int connected = 0;",
          "",
          "[Removed Lines]",
          "1069:  int hlimit = -1;",
          "1070:  int tclass = -1;",
          "1071:  int dontfrag = -1;",
          "",
          "[Added Lines]",
          "1067:  struct ipcm6_cookie ipc6;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1076:  int (*getfrag)(void *, char *, int, int, int, struct sk_buff *);",
          "1077:  struct sockcm_cookie sockc;",
          "1080:  if (sin6) {",
          "1081:   if (addr_len < offsetof(struct sockaddr, sa_data))",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1077:  ipc6.hlimit = -1;",
          "1078:  ipc6.tclass = -1;",
          "1079:  ipc6.dontfrag = -1;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1200:   opt = &opt_space;",
          "1201:   memset(opt, 0, sizeof(struct ipv6_txoptions));",
          "1202:   opt->tot_len = sizeof(*opt);",
          "1207:   if (err < 0) {",
          "1208:    fl6_sock_release(flowlabel);",
          "1209:    return err;",
          "",
          "[Removed Lines]",
          "1204:   err = ip6_datagram_send_ctl(sock_net(sk), sk, msg, &fl6, opt,",
          "1205:          &hlimit, &tclass, &dontfrag,",
          "1206:          &sockc);",
          "",
          "[Added Lines]",
          "1205:   ipc6.opt = opt;",
          "1207:   err = ip6_datagram_send_ctl(sock_net(sk), sk, msg, &fl6, &ipc6, &sockc);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1224:  if (flowlabel)",
          "1225:   opt = fl6_merge_options(&opt_space, flowlabel, opt);",
          "1226:  opt = ipv6_fixup_options(&opt_space, opt);",
          "1228:  fl6.flowi6_proto = sk->sk_protocol;",
          "1229:  if (!ipv6_addr_any(daddr))",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1228:  ipc6.opt = opt;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1253:   goto out;",
          "1254:  }",
          "1262:  if (msg->msg_flags&MSG_CONFIRM)",
          "1263:   goto do_confirm;",
          "",
          "[Removed Lines]",
          "1256:  if (hlimit < 0)",
          "1257:   hlimit = ip6_sk_dst_hoplimit(np, &fl6, dst);",
          "1259:  if (tclass < 0)",
          "1260:   tclass = np->tclass;",
          "",
          "[Added Lines]",
          "1258:  if (ipc6.hlimit < 0)",
          "1259:   ipc6.hlimit = ip6_sk_dst_hoplimit(np, &fl6, dst);",
          "1261:  if (ipc6.tclass < 0)",
          "1262:   ipc6.tclass = np->tclass;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1268:   struct sk_buff *skb;",
          "1270:   skb = ip6_make_skb(sk, getfrag, msg, ulen,",
          "1272:        &fl6, (struct rt6_info *)dst,",
          "1274:   err = PTR_ERR(skb);",
          "1275:   if (!IS_ERR_OR_NULL(skb))",
          "1276:    err = udp_v6_send_skb(skb, &fl6);",
          "",
          "[Removed Lines]",
          "1271:        sizeof(struct udphdr), hlimit, tclass, opt,",
          "1273:        msg->msg_flags, dontfrag, &sockc);",
          "",
          "[Added Lines]",
          "1273:        sizeof(struct udphdr), &ipc6,",
          "1275:        msg->msg_flags, &sockc);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "1291:  up->pending = AF_INET6;",
          "1293: do_append_data:",
          "1296:  up->len += ulen;",
          "1302:  if (err)",
          "1303:   udp_v6_flush_pending_frames(sk);",
          "1304:  else if (!corkreq)",
          "",
          "[Removed Lines]",
          "1294:  if (dontfrag < 0)",
          "1295:   dontfrag = np->dontfrag;",
          "1297:  err = ip6_append_data(sk, getfrag, msg, ulen,",
          "1298:   sizeof(struct udphdr), hlimit, tclass, opt, &fl6,",
          "1299:   (struct rt6_info *)dst,",
          "1300:   corkreq ? msg->msg_flags|MSG_MORE : msg->msg_flags, dontfrag,",
          "1301:   &sockc);",
          "",
          "[Added Lines]",
          "1296:  if (ipc6.dontfrag < 0)",
          "1297:   ipc6.dontfrag = np->dontfrag;",
          "1299:  err = ip6_append_data(sk, getfrag, msg, ulen, sizeof(struct udphdr),",
          "1300:          &ipc6, &fl6, (struct rt6_info *)dst,",
          "1301:          corkreq ? msg->msg_flags|MSG_MORE : msg->msg_flags, &sockc);",
          "",
          "---------------"
        ],
        "net/l2tp/l2tp_ip6.c||net/l2tp/l2tp_ip6.c": [
          "File: net/l2tp/l2tp_ip6.c -> net/l2tp/l2tp_ip6.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "495:  struct dst_entry *dst = NULL;",
          "496:  struct flowi6 fl6;",
          "497:  struct sockcm_cookie sockc_unused = {0};",
          "498:  int addr_len = msg->msg_namelen;",
          "503:  int ulen = len + transhdrlen;",
          "504:  int err;",
          "",
          "[Removed Lines]",
          "499:  int hlimit = -1;",
          "500:  int tclass = -1;",
          "501:  int dontfrag = -1;",
          "",
          "[Added Lines]",
          "498:  struct ipcm6_cookie ipc6;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "521:  fl6.flowi6_mark = sk->sk_mark;",
          "523:  if (lsa) {",
          "524:   if (addr_len < SIN6_LEN_RFC2133)",
          "525:    return -EINVAL;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "521:  ipc6.hlimit = -1;",
          "522:  ipc6.tclass = -1;",
          "523:  ipc6.dontfrag = -1;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "564:   opt = &opt_space;",
          "565:   memset(opt, 0, sizeof(struct ipv6_txoptions));",
          "566:   opt->tot_len = sizeof(struct ipv6_txoptions);",
          "572:    fl6_sock_release(flowlabel);",
          "573:    return err;",
          "574:   }",
          "",
          "[Removed Lines]",
          "568:                 err = ip6_datagram_send_ctl(sock_net(sk), sk, msg, &fl6, opt,",
          "569:                                             &hlimit, &tclass, &dontfrag,",
          "570:                                             &sockc_unused);",
          "571:                 if (err < 0) {",
          "",
          "[Added Lines]",
          "569:   ipc6.opt = opt;",
          "571:   err = ip6_datagram_send_ctl(sock_net(sk), sk, msg, &fl6, &ipc6,",
          "572:          &sockc_unused);",
          "573:   if (err < 0) {",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "588:  if (flowlabel)",
          "589:   opt = fl6_merge_options(&opt_space, flowlabel, opt);",
          "590:  opt = ipv6_fixup_options(&opt_space, opt);",
          "592:  fl6.flowi6_proto = sk->sk_protocol;",
          "593:  if (!ipv6_addr_any(daddr))",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "593:  ipc6.opt = opt;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "612:   goto out;",
          "613:  }",
          "624:  if (msg->msg_flags & MSG_CONFIRM)",
          "625:   goto do_confirm;",
          "",
          "[Removed Lines]",
          "615:  if (hlimit < 0)",
          "616:   hlimit = ip6_sk_dst_hoplimit(np, &fl6, dst);",
          "618:  if (tclass < 0)",
          "619:   tclass = np->tclass;",
          "621:  if (dontfrag < 0)",
          "622:   dontfrag = np->dontfrag;",
          "",
          "[Added Lines]",
          "618:  if (ipc6.hlimit < 0)",
          "619:   ipc6.hlimit = ip6_sk_dst_hoplimit(np, &fl6, dst);",
          "621:  if (ipc6.tclass < 0)",
          "622:   ipc6.tclass = np->tclass;",
          "624:  if (ipc6.dontfrag < 0)",
          "625:   ipc6.dontfrag = np->dontfrag;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "627: back_from_confirm:",
          "628:  lock_sock(sk);",
          "629:  err = ip6_append_data(sk, ip_generic_getfrag, msg,",
          "631:          &fl6, (struct rt6_info *)dst,",
          "633:  if (err)",
          "634:   ip6_flush_pending_frames(sk);",
          "635:  else if (!(msg->msg_flags & MSG_MORE))",
          "",
          "[Removed Lines]",
          "630:          ulen, transhdrlen, hlimit, tclass, opt,",
          "632:          msg->msg_flags, dontfrag, &sockc_unused);",
          "",
          "[Added Lines]",
          "633:          ulen, transhdrlen, &ipc6,",
          "635:          msg->msg_flags, &sockc_unused);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "53b24b8f94cb15e38e332db82177cf3f0f4df0c5",
      "candidate_info": {
        "commit_hash": "53b24b8f94cb15e38e332db82177cf3f0f4df0c5",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/53b24b8f94cb15e38e332db82177cf3f0f4df0c5",
        "files": [
          "net/ipv6/addrconf_core.c",
          "net/ipv6/af_inet6.c",
          "net/ipv6/ip6_fib.c",
          "net/ipv6/ip6_flowlabel.c",
          "net/ipv6/ip6_gre.c",
          "net/ipv6/ip6_input.c",
          "net/ipv6/ip6_offload.c",
          "net/ipv6/ip6_output.c",
          "net/ipv6/ip6_tunnel.c",
          "net/ipv6/ip6_vti.c",
          "net/ipv6/ip6mr.c",
          "net/ipv6/mcast.c",
          "net/ipv6/raw.c",
          "net/ipv6/reassembly.c",
          "net/ipv6/sit.c",
          "net/ipv6/tcp_ipv6.c",
          "net/ipv6/udp.c"
        ],
        "message": "ipv6: coding style: comparison for inequality with NULL\n\nThe ipv6 code uses a mixture of coding styles. In some instances check for NULL\npointer is done as x != NULL and sometimes as x. x is preferred according to\ncheckpatch and this patch makes the code consistent by adopting the latter\nform.\n\nNo changes detected by objdiff.\n\nSigned-off-by: Ian Morris <ipm@chirality.org.uk>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "before_after_code_files": [
          "net/ipv6/addrconf_core.c||net/ipv6/addrconf_core.c",
          "net/ipv6/af_inet6.c||net/ipv6/af_inet6.c",
          "net/ipv6/ip6_fib.c||net/ipv6/ip6_fib.c",
          "net/ipv6/ip6_flowlabel.c||net/ipv6/ip6_flowlabel.c",
          "net/ipv6/ip6_gre.c||net/ipv6/ip6_gre.c",
          "net/ipv6/ip6_input.c||net/ipv6/ip6_input.c",
          "net/ipv6/ip6_offload.c||net/ipv6/ip6_offload.c",
          "net/ipv6/ip6_output.c||net/ipv6/ip6_output.c",
          "net/ipv6/ip6_tunnel.c||net/ipv6/ip6_tunnel.c",
          "net/ipv6/ip6_vti.c||net/ipv6/ip6_vti.c",
          "net/ipv6/ip6mr.c||net/ipv6/ip6mr.c",
          "net/ipv6/mcast.c||net/ipv6/mcast.c",
          "net/ipv6/raw.c||net/ipv6/raw.c",
          "net/ipv6/reassembly.c||net/ipv6/reassembly.c",
          "net/ipv6/sit.c||net/ipv6/sit.c",
          "net/ipv6/tcp_ipv6.c||net/ipv6/tcp_ipv6.c",
          "net/ipv6/udp.c||net/ipv6/udp.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "net/ipv6/af_inet6.c||net/ipv6/af_inet6.c",
            "net/ipv6/raw.c||net/ipv6/raw.c",
            "net/ipv6/tcp_ipv6.c||net/ipv6/tcp_ipv6.c",
            "net/ipv6/udp.c||net/ipv6/udp.c"
          ],
          "candidate": [
            "net/ipv6/af_inet6.c||net/ipv6/af_inet6.c",
            "net/ipv6/raw.c||net/ipv6/raw.c",
            "net/ipv6/tcp_ipv6.c||net/ipv6/tcp_ipv6.c",
            "net/ipv6/udp.c||net/ipv6/udp.c"
          ]
        }
      },
      "candidate_diff": {
        "net/ipv6/addrconf_core.c||net/ipv6/addrconf_core.c": [
          "File: net/ipv6/addrconf_core.c -> net/ipv6/addrconf_core.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "140:  struct net_device *dev = idev->dev;",
          "142:  WARN_ON(!list_empty(&idev->addr_list));",
          "144:  WARN_ON(timer_pending(&idev->rs_timer));",
          "146: #ifdef NET_REFCNT_DEBUG",
          "",
          "[Removed Lines]",
          "143:  WARN_ON(idev->mc_list != NULL);",
          "",
          "[Added Lines]",
          "143:  WARN_ON(idev->mc_list);",
          "",
          "---------------"
        ],
        "net/ipv6/af_inet6.c||net/ipv6/af_inet6.c": [
          "File: net/ipv6/af_inet6.c -> net/ipv6/af_inet6.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "415:  skb = xchg(&np->pktoptions, NULL);",
          "417:   kfree_skb(skb);",
          "419:  skb = xchg(&np->rxpmtu, NULL);",
          "421:   kfree_skb(skb);",
          "",
          "[Removed Lines]",
          "416:  if (skb != NULL)",
          "420:  if (skb != NULL)",
          "",
          "[Added Lines]",
          "416:  if (skb)",
          "420:  if (skb)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "428:  opt = xchg(&np->opt, NULL);",
          "430:   sock_kfree_s(sk, opt, opt->tot_len);",
          "431: }",
          "432: EXPORT_SYMBOL_GPL(inet6_destroy_sock);",
          "",
          "[Removed Lines]",
          "429:  if (opt != NULL)",
          "",
          "[Added Lines]",
          "429:  if (opt)",
          "",
          "---------------"
        ],
        "net/ipv6/ip6_fib.c||net/ipv6/ip6_fib.c": [
          "File: net/ipv6/ip6_fib.c -> net/ipv6/ip6_fib.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1207:   WARN_ON(fn->fn_flags & RTN_RTINFO);",
          "1208:   WARN_ON(fn->fn_flags & RTN_TL_ROOT);",
          "1211:   children = 0;",
          "1212:   child = NULL;",
          "",
          "[Removed Lines]",
          "1209:   WARN_ON(fn->leaf != NULL);",
          "",
          "[Added Lines]",
          "1209:   WARN_ON(fn->leaf);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1362: #if RT6_DEBUG >= 2",
          "1363:  if (rt->dst.obsolete > 0) {",
          "1365:   return -ENOENT;",
          "1366:  }",
          "1367: #endif",
          "",
          "[Removed Lines]",
          "1364:   WARN_ON(fn != NULL);",
          "",
          "[Added Lines]",
          "1364:   WARN_ON(fn);",
          "",
          "---------------"
        ],
        "net/ipv6/ip6_flowlabel.c||net/ipv6/ip6_flowlabel.c": [
          "File: net/ipv6/ip6_flowlabel.c -> net/ipv6/ip6_flowlabel.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "221:   lfl = __fl_lookup(net, fl->label);",
          "223:    atomic_inc(&lfl->users);",
          "224:    spin_unlock_bh(&ip6_fl_lock);",
          "225:    return lfl;",
          "",
          "[Removed Lines]",
          "222:   if (lfl != NULL) {",
          "",
          "[Added Lines]",
          "222:   if (lfl) {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "300:  if (!fopt || fopt->opt_flen == 0)",
          "301:   return fl_opt;",
          "304:   opt_space->hopopt = fl_opt->hopopt;",
          "305:   opt_space->dst0opt = fl_opt->dst0opt;",
          "306:   opt_space->srcrt = fl_opt->srcrt;",
          "",
          "[Removed Lines]",
          "303:  if (fl_opt != NULL) {",
          "",
          "[Added Lines]",
          "303:  if (fl_opt) {",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "661:    goto done;",
          "663:   fl1 = fl_intern(net, fl, freq.flr_label);",
          "665:    goto recheck;",
          "667:   if (!freq.flr_label) {",
          "",
          "[Removed Lines]",
          "664:   if (fl1 != NULL)",
          "",
          "[Added Lines]",
          "664:   if (fl1)",
          "",
          "---------------"
        ],
        "net/ipv6/ip6_gre.c||net/ipv6/ip6_gre.c": [
          "File: net/ipv6/ip6_gre.c -> net/ipv6/ip6_gre.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "223:   }",
          "224:  }",
          "227:   return cand;",
          "229:  dev = ign->fb_tunnel_dev;",
          "",
          "[Removed Lines]",
          "226:  if (cand != NULL)",
          "",
          "[Added Lines]",
          "226:  if (cand)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1105:   t = ip6gre_tunnel_locate(net, &p1, cmd == SIOCADDTUNNEL);",
          "1107:   if (dev != ign->fb_tunnel_dev && cmd == SIOCCHGTUNNEL) {",
          "1109:     if (t->dev != dev) {",
          "1110:      err = -EEXIST;",
          "1111:      break;",
          "",
          "[Removed Lines]",
          "1108:    if (t != NULL) {",
          "",
          "[Added Lines]",
          "1108:    if (t) {",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1314:    t = rtnl_dereference(ign->tunnels[prio][h]);",
          "",
          "[Removed Lines]",
          "1316:    while (t != NULL) {",
          "",
          "[Added Lines]",
          "1316:    while (t) {",
          "",
          "---------------"
        ],
        "net/ipv6/ip6_input.c||net/ipv6/ip6_input.c": [
          "File: net/ipv6/ip6_input.c -> net/ipv6/ip6_input.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "222:  raw = raw6_local_deliver(skb, nexthdr);",
          "223:  ipprot = rcu_dereference(inet6_protos[nexthdr]);",
          "225:   int ret;",
          "227:   if (ipprot->flags & INET6_PROTO_FINAL) {",
          "",
          "[Removed Lines]",
          "224:  if (ipprot != NULL) {",
          "",
          "[Added Lines]",
          "224:  if (ipprot) {",
          "",
          "---------------"
        ],
        "net/ipv6/ip6_offload.c||net/ipv6/ip6_offload.c": [
          "File: net/ipv6/ip6_offload.c -> net/ipv6/ip6_offload.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "124:    unfrag_ip6hlen = ip6_find_1stfragopt(skb, &prevhdr);",
          "125:    fptr = (struct frag_hdr *)((u8 *)ipv6h + unfrag_ip6hlen);",
          "126:    fptr->frag_off = htons(offset);",
          "128:     fptr->frag_off |= htons(IP6_MF);",
          "129:    offset += (ntohs(ipv6h->payload_len) -",
          "130:        sizeof(struct frag_hdr));",
          "",
          "[Removed Lines]",
          "127:    if (skb->next != NULL)",
          "",
          "[Added Lines]",
          "127:    if (skb->next)",
          "",
          "---------------"
        ],
        "net/ipv6/ip6_output.c||net/ipv6/ip6_output.c": [
          "File: net/ipv6/ip6_output.c -> net/ipv6/ip6_output.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "657:     fh->nexthdr = nexthdr;",
          "658:     fh->reserved = 0;",
          "659:     fh->frag_off = htons(offset);",
          "661:      fh->frag_off |= htons(IP6_MF);",
          "662:     fh->identification = frag_id;",
          "663:     ipv6_hdr(frag)->payload_len =",
          "",
          "[Removed Lines]",
          "660:     if (frag->next != NULL)",
          "",
          "[Added Lines]",
          "660:     if (frag->next)",
          "",
          "---------------"
        ],
        "net/ipv6/ip6_tunnel.c||net/ipv6/ip6_tunnel.c": [
          "File: net/ipv6/ip6_tunnel.c -> net/ipv6/ip6_tunnel.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "808:  rcu_read_lock();",
          "809:  t = ip6_tnl_lookup(dev_net(skb->dev), &ipv6h->saddr, &ipv6h->daddr);",
          "811:   struct pcpu_sw_netstats *tstats;",
          "813:   tproto = ACCESS_ONCE(t->parms.proto);",
          "",
          "[Removed Lines]",
          "810:  if (t != NULL) {",
          "",
          "[Added Lines]",
          "810:  if (t) {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1816:  for (h = 0; h < HASH_SIZE; h++) {",
          "1817:   t = rtnl_dereference(ip6n->tnls_r_l[h]);",
          "",
          "[Removed Lines]",
          "1818:   while (t != NULL) {",
          "",
          "[Added Lines]",
          "1818:   while (t) {",
          "",
          "---------------"
        ],
        "net/ipv6/ip6_vti.c||net/ipv6/ip6_vti.c": [
          "File: net/ipv6/ip6_vti.c -> net/ipv6/ip6_vti.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "306:  rcu_read_lock();",
          "307:  t = vti6_tnl_lookup(dev_net(skb->dev), &ipv6h->saddr, &ipv6h->daddr);",
          "309:   if (t->parms.proto != IPPROTO_IPV6 && t->parms.proto != 0) {",
          "310:    rcu_read_unlock();",
          "311:    goto discard;",
          "",
          "[Removed Lines]",
          "308:  if (t != NULL) {",
          "",
          "[Added Lines]",
          "308:  if (t) {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "736:   vti6_parm_from_user(&p1, &p);",
          "737:   t = vti6_locate(net, &p1, cmd == SIOCADDTUNNEL);",
          "738:   if (dev != ip6n->fb_tnl_dev && cmd == SIOCCHGTUNNEL) {",
          "740:     if (t->dev != dev) {",
          "741:      err = -EEXIST;",
          "742:      break;",
          "",
          "[Removed Lines]",
          "739:    if (t != NULL) {",
          "",
          "[Added Lines]",
          "739:    if (t) {",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1028:  for (h = 0; h < HASH_SIZE; h++) {",
          "1029:   t = rtnl_dereference(ip6n->tnls_r_l[h]);",
          "1031:    unregister_netdevice_queue(t->dev, &list);",
          "1032:    t = rtnl_dereference(t->next);",
          "1033:   }",
          "",
          "[Removed Lines]",
          "1030:   while (t != NULL) {",
          "",
          "[Added Lines]",
          "1030:   while (t) {",
          "",
          "---------------"
        ],
        "net/ipv6/ip6mr.c||net/ipv6/ip6mr.c": [
          "File: net/ipv6/ip6mr.c -> net/ipv6/ip6mr.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "305:  unsigned int i;",
          "307:  mrt = ip6mr_get_table(net, id);",
          "309:   return mrt;",
          "311:  mrt = kzalloc(sizeof(*mrt), GFP_KERNEL);",
          "",
          "[Removed Lines]",
          "308:  if (mrt != NULL)",
          "",
          "[Added Lines]",
          "308:  if (mrt)",
          "",
          "---------------"
        ],
        "net/ipv6/mcast.c||net/ipv6/mcast.c": [
          "File: net/ipv6/mcast.c -> net/ipv6/mcast.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "228:    dev = __dev_get_by_index(net, mc_lst->ifindex);",
          "230:     struct inet6_dev *idev = __in6_dev_get(dev);",
          "232:     (void) ip6_mc_leave_src(sk, mc_lst, idev);",
          "",
          "[Removed Lines]",
          "229:    if (dev != NULL) {",
          "",
          "[Added Lines]",
          "229:    if (dev) {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2612:  im = im->next;",
          "2613:  while (!im) {",
          "2615:    read_unlock_bh(&state->idev->lock);",
          "2617:   state->dev = next_net_device_rcu(state->dev);",
          "",
          "[Removed Lines]",
          "2614:   if (likely(state->idev != NULL))",
          "",
          "[Added Lines]",
          "2614:   if (likely(state->idev))",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "2657: {",
          "2658:  struct igmp6_mc_iter_state *state = igmp6_mc_seq_private(seq);",
          "2661:   read_unlock_bh(&state->idev->lock);",
          "2662:   state->idev = NULL;",
          "2663:  }",
          "",
          "[Removed Lines]",
          "2660:  if (likely(state->idev != NULL)) {",
          "",
          "[Added Lines]",
          "2660:  if (likely(state->idev)) {",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "2726:    continue;",
          "2727:   read_lock_bh(&idev->lock);",
          "2728:   im = idev->mc_list;",
          "2730:    spin_lock_bh(&im->mca_lock);",
          "2731:    psf = im->mca_sources;",
          "2733:     state->im = im;",
          "2734:     state->idev = idev;",
          "2735:     break;",
          "",
          "[Removed Lines]",
          "2729:   if (likely(im != NULL)) {",
          "2732:    if (likely(psf != NULL)) {",
          "",
          "[Added Lines]",
          "2729:   if (likely(im)) {",
          "2732:    if (likely(psf)) {",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "2750:   spin_unlock_bh(&state->im->mca_lock);",
          "2751:   state->im = state->im->next;",
          "2752:   while (!state->im) {",
          "2754:     read_unlock_bh(&state->idev->lock);",
          "2756:    state->dev = next_net_device_rcu(state->dev);",
          "",
          "[Removed Lines]",
          "2753:    if (likely(state->idev != NULL))",
          "",
          "[Added Lines]",
          "2753:    if (likely(state->idev))",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "2804:  __releases(RCU)",
          "2805: {",
          "2806:  struct igmp6_mcf_iter_state *state = igmp6_mcf_seq_private(seq);",
          "2808:   spin_unlock_bh(&state->im->mca_lock);",
          "2809:   state->im = NULL;",
          "2810:  }",
          "2812:   read_unlock_bh(&state->idev->lock);",
          "2813:   state->idev = NULL;",
          "2814:  }",
          "",
          "[Removed Lines]",
          "2807:  if (likely(state->im != NULL)) {",
          "2811:  if (likely(state->idev != NULL)) {",
          "",
          "[Added Lines]",
          "2807:  if (likely(state->im)) {",
          "2811:  if (likely(state->idev)) {",
          "",
          "---------------"
        ],
        "net/ipv6/raw.c||net/ipv6/raw.c": [
          "File: net/ipv6/raw.c -> net/ipv6/raw.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "368:  read_lock(&raw_v6_hashinfo.lock);",
          "369:  sk = sk_head(&raw_v6_hashinfo.ht[hash]);",
          "372:   const struct ipv6hdr *ip6h = (const struct ipv6hdr *)skb->data;",
          "373:   saddr = &ip6h->saddr;",
          "",
          "[Removed Lines]",
          "370:  if (sk != NULL) {",
          "",
          "[Added Lines]",
          "370:  if (sk) {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1131:   spin_lock_bh(&sk->sk_receive_queue.lock);",
          "1132:   skb = skb_peek(&sk->sk_receive_queue);",
          "1134:    amount = skb_tail_pointer(skb) -",
          "1135:     skb_transport_header(skb);",
          "1136:   spin_unlock_bh(&sk->sk_receive_queue.lock);",
          "",
          "[Removed Lines]",
          "1133:   if (skb != NULL)",
          "",
          "[Added Lines]",
          "1133:   if (skb)",
          "",
          "---------------"
        ],
        "net/ipv6/reassembly.c||net/ipv6/reassembly.c": [
          "File: net/ipv6/reassembly.c -> net/ipv6/reassembly.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "553:  fq = fq_find(net, fhdr->identification, &hdr->saddr, &hdr->daddr,",
          "554:        ip6_frag_ecn(hdr));",
          "556:   int ret;",
          "558:   spin_lock(&fq->q.lock);",
          "",
          "[Removed Lines]",
          "555:  if (fq != NULL) {",
          "",
          "[Added Lines]",
          "555:  if (fq) {",
          "",
          "---------------"
        ],
        "net/ipv6/sit.c||net/ipv6/sit.c": [
          "File: net/ipv6/sit.c -> net/ipv6/sit.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "118:    return t;",
          "119:  }",
          "120:  t = rcu_dereference(sitn->tunnels_wc[0]);",
          "122:   return t;",
          "123:  return NULL;",
          "124: }",
          "",
          "[Removed Lines]",
          "121:  if ((t != NULL) && (t->dev->flags & IFF_UP))",
          "",
          "[Added Lines]",
          "121:  if (t && (t->dev->flags & IFF_UP))",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "672:  tunnel = ipip6_tunnel_lookup(dev_net(skb->dev), skb->dev,",
          "673:          iph->saddr, iph->daddr);",
          "675:   struct pcpu_sw_netstats *tstats;",
          "677:   if (tunnel->parms.iph.protocol != IPPROTO_IPV6 &&",
          "",
          "[Removed Lines]",
          "674:  if (tunnel != NULL) {",
          "",
          "[Added Lines]",
          "674:  if (tunnel) {",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "733:  iph = ip_hdr(skb);",
          "734:  tunnel = ipip6_tunnel_lookup(dev_net(skb->dev), skb->dev,",
          "735:          iph->saddr, iph->daddr);",
          "737:   if (tunnel->parms.iph.protocol != IPPROTO_IPIP &&",
          "738:       tunnel->parms.iph.protocol != 0)",
          "739:    goto drop;",
          "",
          "[Removed Lines]",
          "736:  if (tunnel != NULL) {",
          "",
          "[Added Lines]",
          "736:  if (tunnel) {",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1206:   t = ipip6_tunnel_locate(net, &p, cmd == SIOCADDTUNNEL);",
          "1208:   if (dev != sitn->fb_tunnel_dev && cmd == SIOCCHGTUNNEL) {",
          "1210:     if (t->dev != dev) {",
          "1211:      err = -EEXIST;",
          "1212:      break;",
          "",
          "[Removed Lines]",
          "1209:    if (t != NULL) {",
          "",
          "[Added Lines]",
          "1209:    if (t) {",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1795:    struct ip_tunnel *t;",
          "1797:    t = rtnl_dereference(sitn->tunnels[prio][h]);",
          "",
          "[Removed Lines]",
          "1798:    while (t != NULL) {",
          "",
          "[Added Lines]",
          "1798:    while (t) {",
          "",
          "---------------"
        ],
        "net/ipv6/tcp_ipv6.c||net/ipv6/tcp_ipv6.c": [
          "File: net/ipv6/tcp_ipv6.c -> net/ipv6/tcp_ipv6.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "460:         &ireq->ir_v6_rmt_addr);",
          "462:   fl6->daddr = ireq->ir_v6_rmt_addr;",
          "464:    fl6->flowlabel = ip6_flowlabel(ipv6_hdr(ireq->pktopts));",
          "466:   skb_set_queue_mapping(skb, queue_mapping);",
          "",
          "[Removed Lines]",
          "463:   if (np->repflow && (ireq->pktopts != NULL))",
          "",
          "[Added Lines]",
          "463:   if (np->repflow && ireq->pktopts)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1109:  newnp->pktoptions = NULL;",
          "1111:   newnp->pktoptions = skb_clone(ireq->pktopts,",
          "1112:            sk_gfp_atomic(sk, GFP_ATOMIC));",
          "1113:   consume_skb(ireq->pktopts);",
          "",
          "[Removed Lines]",
          "1110:  if (ireq->pktopts != NULL) {",
          "",
          "[Added Lines]",
          "1110:  if (ireq->pktopts) {",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1152: #ifdef CONFIG_TCP_MD5SIG",
          "1154:  key = tcp_v6_md5_do_lookup(sk, &newsk->sk_v6_daddr);",
          "",
          "[Removed Lines]",
          "1155:  if (key != NULL) {",
          "",
          "[Added Lines]",
          "1155:  if (key) {",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1475:          &ipv6_hdr(skb)->saddr, th->source,",
          "1476:          &ipv6_hdr(skb)->daddr,",
          "1477:          ntohs(th->dest), tcp_v6_iif(skb));",
          "1479:    struct inet_timewait_sock *tw = inet_twsk(sk);",
          "1480:    inet_twsk_deschedule(tw, &tcp_death_row);",
          "1481:    inet_twsk_put(tw);",
          "",
          "[Removed Lines]",
          "1478:   if (sk2 != NULL) {",
          "",
          "[Added Lines]",
          "1478:   if (sk2) {",
          "",
          "---------------"
        ],
        "net/ipv6/udp.c||net/ipv6/udp.c": [
          "File: net/ipv6/udp.c -> net/ipv6/udp.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "650:   encap_rcv = ACCESS_ONCE(up->encap_rcv);",
          "652:    int ret;",
          "",
          "[Removed Lines]",
          "651:   if (skb->len > sizeof(struct udphdr) && encap_rcv != NULL) {",
          "",
          "[Added Lines]",
          "651:   if (skb->len > sizeof(struct udphdr) && encap_rcv) {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "901:  sk = __udp6_lib_lookup_skb(skb, uh->source, uh->dest, udptable);",
          "903:   int ret;",
          "905:   if (!uh->check && !udp_sk(sk)->no_check6_rx) {",
          "",
          "[Removed Lines]",
          "902:  if (sk != NULL) {",
          "",
          "[Added Lines]",
          "902:  if (sk) {",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "80fbdb208f37740774652ba095a5b2045205ed59",
      "candidate_info": {
        "commit_hash": "80fbdb208f37740774652ba095a5b2045205ed59",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/80fbdb208f37740774652ba095a5b2045205ed59",
        "files": [
          "net/ipv6/datagram.c"
        ],
        "message": "ipv6: datagram: Refactor flowi6 init codes to a new function\n\nMove flowi6 init codes for connected datagram sk to a newly created\nfunction ip6_datagram_flow_key_init().\n\nNotes:\n1. fl6_flowlabel is used instead of fl6.flowlabel in __ip6_datagram_connect\n2. ipv6_addr_is_multicast(&fl6->daddr) is used instead of\n   (addr_type & IPV6_ADDR_MULTICAST) in ip6_datagram_flow_key_init()\n\nThis new function will be reused during pmtu update in the later patch.\n\nSigned-off-by: Martin KaFai Lau <kafai@fb.com>\nCc: Cong Wang <xiyou.wangcong@gmail.com>\nCc: Eric Dumazet <edumazet@google.com>\nCc: Wei Wang <weiwan@google.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "before_after_code_files": [
          "net/ipv6/datagram.c||net/ipv6/datagram.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "net/ipv6/datagram.c||net/ipv6/datagram.c"
          ],
          "candidate": [
            "net/ipv6/datagram.c||net/ipv6/datagram.c"
          ]
        }
      },
      "candidate_diff": {
        "net/ipv6/datagram.c||net/ipv6/datagram.c": [
          "File: net/ipv6/datagram.c -> net/ipv6/datagram.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "40:  return ipv6_addr_v4mapped(a) && (a->s6_addr32[3] == 0);",
          "41: }",
          "43: static int __ip6_datagram_connect(struct sock *sk, struct sockaddr *uaddr, int addr_len)",
          "44: {",
          "45:  struct sockaddr_in6 *usin = (struct sockaddr_in6 *) uaddr;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "43: static void ip6_datagram_flow_key_init(struct flowi6 *fl6, struct sock *sk)",
          "44: {",
          "45:  struct inet_sock *inet = inet_sk(sk);",
          "46:  struct ipv6_pinfo *np = inet6_sk(sk);",
          "48:  memset(fl6, 0, sizeof(*fl6));",
          "49:  fl6->flowi6_proto = sk->sk_protocol;",
          "50:  fl6->daddr = sk->sk_v6_daddr;",
          "51:  fl6->saddr = np->saddr;",
          "52:  fl6->flowi6_oif = sk->sk_bound_dev_if;",
          "53:  fl6->flowi6_mark = sk->sk_mark;",
          "54:  fl6->fl6_dport = inet->inet_dport;",
          "55:  fl6->fl6_sport = inet->inet_sport;",
          "56:  fl6->flowlabel = np->flow_label;",
          "58:  if (!fl6->flowi6_oif)",
          "59:   fl6->flowi6_oif = np->sticky_pktinfo.ipi6_ifindex;",
          "61:  if (!fl6->flowi6_oif && ipv6_addr_is_multicast(&fl6->daddr))",
          "62:   fl6->flowi6_oif = np->mcast_oif;",
          "64:  security_sk_classify_flow(sk, flowi6_to_flowi(fl6));",
          "65: }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "52:  struct ipv6_txoptions *opt;",
          "53:  int   addr_type;",
          "54:  int   err;",
          "56:  if (usin->sin6_family == AF_INET) {",
          "57:   if (__ipv6_only_sock(sk))",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "79:  __be32   fl6_flowlabel = 0;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "66:  if (usin->sin6_family != AF_INET6)",
          "67:   return -EAFNOSUPPORT;",
          "70:  if (np->sndflow) {",
          "74:    if (!flowlabel)",
          "75:     return -EINVAL;",
          "76:   }",
          "",
          "[Removed Lines]",
          "69:  memset(&fl6, 0, sizeof(fl6));",
          "71:   fl6.flowlabel = usin->sin6_flowinfo&IPV6_FLOWINFO_MASK;",
          "72:   if (fl6.flowlabel&IPV6_FLOWLABEL_MASK) {",
          "73:    flowlabel = fl6_sock_lookup(sk, fl6.flowlabel);",
          "",
          "[Added Lines]",
          "95:   fl6_flowlabel = usin->sin6_flowinfo & IPV6_FLOWINFO_MASK;",
          "96:   if (fl6_flowlabel & IPV6_FLOWLABEL_MASK) {",
          "97:    flowlabel = fl6_sock_lookup(sk, fl6_flowlabel);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "145:  }",
          "147:  sk->sk_v6_daddr = *daddr;",
          "150:  inet->inet_dport = usin->sin6_port;",
          "",
          "[Removed Lines]",
          "148:  np->flow_label = fl6.flowlabel;",
          "",
          "[Added Lines]",
          "172:  np->flow_label = fl6_flowlabel;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "173:  rcu_read_lock();",
          "174:  opt = flowlabel ? flowlabel->opt : rcu_dereference(np->opt);",
          "",
          "[Removed Lines]",
          "157:  fl6.flowi6_proto = sk->sk_protocol;",
          "158:  fl6.daddr = sk->sk_v6_daddr;",
          "159:  fl6.saddr = np->saddr;",
          "160:  fl6.flowi6_oif = sk->sk_bound_dev_if;",
          "161:  fl6.flowi6_mark = sk->sk_mark;",
          "162:  fl6.fl6_dport = inet->inet_dport;",
          "163:  fl6.fl6_sport = inet->inet_sport;",
          "165:  if (!fl6.flowi6_oif)",
          "166:   fl6.flowi6_oif = np->sticky_pktinfo.ipi6_ifindex;",
          "168:  if (!fl6.flowi6_oif && (addr_type&IPV6_ADDR_MULTICAST))",
          "169:   fl6.flowi6_oif = np->mcast_oif;",
          "171:  security_sk_classify_flow(sk, flowi6_to_flowi(&fl6));",
          "",
          "[Added Lines]",
          "181:  ip6_datagram_flow_key_init(&fl6, sk);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "33c162a980fe03498fcecb917f618ad7e7c55e61",
      "candidate_info": {
        "commit_hash": "33c162a980fe03498fcecb917f618ad7e7c55e61",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/33c162a980fe03498fcecb917f618ad7e7c55e61",
        "files": [
          "include/net/ipv6.h",
          "net/ipv6/datagram.c",
          "net/ipv6/route.c"
        ],
        "message": "ipv6: datagram: Update dst cache of a connected datagram sk during pmtu update\n\nThere is a case in connected UDP socket such that\ngetsockopt(IPV6_MTU) will return a stale MTU value. The reproducible\nsequence could be the following:\n1. Create a connected UDP socket\n2. Send some datagrams out\n3. Receive a ICMPV6_PKT_TOOBIG\n4. No new outgoing datagrams to trigger the sk_dst_check()\n   logic to update the sk->sk_dst_cache.\n5. getsockopt(IPV6_MTU) returns the mtu from the invalid\n   sk->sk_dst_cache instead of the newly created RTF_CACHE clone.\n\nThis patch updates the sk->sk_dst_cache for a connected datagram sk\nduring pmtu-update code path.\n\nNote that the sk->sk_v6_daddr is used to do the route lookup\ninstead of skb->data (i.e. iph).  It is because a UDP socket can become\nconnected after sending out some datagrams in un-connected state.  or\nIt can be connected multiple times to different destinations.  Hence,\niph may not be related to where sk is currently connected to.\n\nIt is done under '!sock_owned_by_user(sk)' condition because\nthe user may make another ip6_datagram_connect()  (i.e changing\nthe sk->sk_v6_daddr) while dst lookup is happening in the pmtu-update\ncode path.\n\nFor the sock_owned_by_user(sk) == true case, the next patch will\nintroduce a release_cb() which will update the sk->sk_dst_cache.\n\nTest:\n\nServer (Connected UDP Socket):\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nRoute Details:\n[root@arch-fb-vm1 ~]# ip -6 r show | egrep '2fac'\n2fac::/64 dev eth0  proto kernel  metric 256  pref medium\n2fac:face::/64 via 2fac::face dev eth0  metric 1024  pref medium\n\nA simple python code to create a connected UDP socket:\n\nimport socket\nimport errno\n\nHOST = '2fac::1'\nPORT = 8080\n\ns = socket.socket(socket.AF_INET6, socket.SOCK_DGRAM)\ns.bind((HOST, PORT))\ns.connect(('2fac:face::face', 53))\nprint(\"connected\")\nwhile True:\n    try:\n\tdata = s.recv(1024)\n    except socket.error as se:\n\tif se.errno == errno.EMSGSIZE:\n\t\tpmtu = s.getsockopt(41, 24)\n\t\tprint(\"PMTU:%d\" % pmtu)\n\t\tbreak\ns.close()\n\nPython program output after getting a ICMPV6_PKT_TOOBIG:\n[root@arch-fb-vm1 ~]# python2 ~/devshare/kernel/tasks/fib6/udp-connect-53-8080.py\nconnected\nPMTU:1300\n\nCache routes after recieving TOOBIG:\n[root@arch-fb-vm1 ~]# ip -6 r show table cache\n2fac:face::face via 2fac::face dev eth0  metric 0\n    cache  expires 463sec mtu 1300 pref medium\n\nClient (Send the ICMPV6_PKT_TOOBIG):\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nscapy is used to generate the TOOBIG message.  Here is the scapy script I have\nused:\n\n>>> p=Ether(src='da:75:4d:36:ac:32', dst='52:54:00:12:34:66', type=0x86dd)/IPv6(src='2fac::face', dst='2fac::1')/ICMPv6PacketTooBig(mtu=1300)/IPv6(src='2fac::\n1',dst='2fac:face::face', nh='UDP')/UDP(sport=8080,dport=53)\n>>> sendp(p, iface='qemubr0')\n\nFixes: 45e4fd26683c (\"ipv6: Only create RTF_CACHE routes after encountering pmtu exception\")\nSigned-off-by: Martin KaFai Lau <kafai@fb.com>\nReported-by: Wei Wang <weiwan@google.com>\nCc: Cong Wang <xiyou.wangcong@gmail.com>\nCc: Eric Dumazet <edumazet@google.com>\nCc: Wei Wang <weiwan@google.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "before_after_code_files": [
          "include/net/ipv6.h||include/net/ipv6.h",
          "net/ipv6/datagram.c||net/ipv6/datagram.c",
          "net/ipv6/route.c||net/ipv6/route.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "include/net/ipv6.h||include/net/ipv6.h",
            "net/ipv6/datagram.c||net/ipv6/datagram.c"
          ],
          "candidate": [
            "include/net/ipv6.h||include/net/ipv6.h",
            "net/ipv6/datagram.c||net/ipv6/datagram.c"
          ]
        }
      },
      "candidate_diff": {
        "include/net/ipv6.h||include/net/ipv6.h": [
          "File: include/net/ipv6.h -> include/net/ipv6.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "959: int ip6_datagram_connect(struct sock *sk, struct sockaddr *addr, int addr_len);",
          "960: int ip6_datagram_connect_v6_only(struct sock *sk, struct sockaddr *addr,",
          "961:      int addr_len);",
          "963: int ipv6_recv_error(struct sock *sk, struct msghdr *msg, int len,",
          "964:       int *addr_len);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "962: int ip6_datagram_dst_update(struct sock *sk, bool fix_sk_saddr);",
          "",
          "---------------"
        ],
        "net/ipv6/datagram.c||net/ipv6/datagram.c": [
          "File: net/ipv6/datagram.c -> net/ipv6/datagram.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "64:  security_sk_classify_flow(sk, flowi6_to_flowi(fl6));",
          "65: }",
          "68: {",
          "69:  struct ip6_flowlabel *flowlabel = NULL;",
          "70:  struct in6_addr *final_p, final;",
          "",
          "[Removed Lines]",
          "67: static int ip6_datagram_dst_update(struct sock *sk)",
          "",
          "[Added Lines]",
          "67: int ip6_datagram_dst_update(struct sock *sk, bool fix_sk_saddr)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "93:   goto out;",
          "94:  }",
          "104:  }",
          "106:  ip6_dst_store(sk, dst,",
          "",
          "[Removed Lines]",
          "96:  if (ipv6_addr_any(&np->saddr))",
          "97:   np->saddr = fl6.saddr;",
          "99:  if (ipv6_addr_any(&sk->sk_v6_rcv_saddr)) {",
          "100:   sk->sk_v6_rcv_saddr = fl6.saddr;",
          "101:   inet->inet_rcv_saddr = LOOPBACK4_IPV6;",
          "102:   if (sk->sk_prot->rehash)",
          "103:    sk->sk_prot->rehash(sk);",
          "",
          "[Added Lines]",
          "96:  if (fix_sk_saddr) {",
          "97:   if (ipv6_addr_any(&np->saddr))",
          "98:    np->saddr = fl6.saddr;",
          "100:   if (ipv6_addr_any(&sk->sk_v6_rcv_saddr)) {",
          "101:    sk->sk_v6_rcv_saddr = fl6.saddr;",
          "102:    inet->inet_rcv_saddr = LOOPBACK4_IPV6;",
          "103:    if (sk->sk_prot->rehash)",
          "104:     sk->sk_prot->rehash(sk);",
          "105:   }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "225:  if (err)",
          "226:   goto out;",
          "",
          "[Removed Lines]",
          "224:  err = ip6_datagram_dst_update(sk);",
          "",
          "[Added Lines]",
          "226:  err = ip6_datagram_dst_update(sk, true);",
          "",
          "---------------"
        ],
        "net/ipv6/route.c||net/ipv6/route.c": [
          "File: net/ipv6/route.c -> net/ipv6/route.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1419: void ip6_sk_update_pmtu(struct sk_buff *skb, struct sock *sk, __be32 mtu)",
          "1420: {",
          "1421:  ip6_update_pmtu(skb, sock_net(sk), mtu,",
          "1422:    sk->sk_bound_dev_if, sk->sk_mark);",
          "1423: }",
          "1424: EXPORT_SYMBOL_GPL(ip6_sk_update_pmtu);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1421:  struct dst_entry *dst;",
          "1426:  dst = __sk_dst_get(sk);",
          "1427:  if (!dst || !dst->obsolete ||",
          "1428:      dst->ops->check(dst, inet6_sk(sk)->dst_cookie))",
          "1429:   return;",
          "1431:  bh_lock_sock(sk);",
          "1432:  if (!sock_owned_by_user(sk) && !ipv6_addr_v4mapped(&sk->sk_v6_daddr))",
          "1433:   ip6_datagram_dst_update(sk, false);",
          "1434:  bh_unlock_sock(sk);",
          "",
          "---------------"
        ]
      }
    }
  ]
}
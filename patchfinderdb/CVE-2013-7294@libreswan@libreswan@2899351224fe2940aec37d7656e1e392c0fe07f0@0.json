{
  "cve_id": "CVE-2013-7294",
  "cve_desc": "The ikev2parent_inI1outR1 function in pluto/ikev2_parent.c in libreswan before 3.7 allows remote attackers to cause a denial of service (restart) via an IKEv2 I1 notification without a KE payload.",
  "repo": "libreswan/libreswan",
  "patch_hash": "2899351224fe2940aec37d7656e1e392c0fe07f0",
  "patch_info": {
    "commit_hash": "2899351224fe2940aec37d7656e1e392c0fe07f0",
    "repo": "libreswan/libreswan",
    "commit_url": "https://github.com/libreswan/libreswan/commit/2899351224fe2940aec37d7656e1e392c0fe07f0",
    "files": [
      "programs/pluto/ikev2_parent.c"
    ],
    "message": "SECURITY: Properly handle IKEv2 I1 notification packet without KE payload",
    "before_after_code_files": [
      "programs/pluto/ikev2_parent.c||programs/pluto/ikev2_parent.c"
    ]
  },
  "patch_diff": {
    "programs/pluto/ikev2_parent.c||programs/pluto/ikev2_parent.c": [
      "File: programs/pluto/ikev2_parent.c -> programs/pluto/ikev2_parent.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "306:  }",
      "307:  reset_cur_state();",
      "308:  reset_globals();",
      "311: }",
      "",
      "[Removed Lines]",
      "310:  passert(GLOBALS_ARE_RESET());",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "730:  {",
      "731:   struct ikev2_ke *ke;",
      "732:   ke = &md->chain[ISAKMP_NEXT_v2KE]->payload.v2ke;",
      "734:   st->st_oakley.group = lookup_group(ke->isak_group);",
      "735:   if (st->st_oakley.group == NULL) {",
      "739:    libreswan_log(",
      "740:     \"rejecting I1 from %s:%u, invalid DH group=%u\",",
      "741:     fromname, md->sender_port,",
      "742:     ke->isak_group);",
      "744:   }",
      "745:  }",
      "",
      "[Removed Lines]",
      "736:    char fromname[ADDRTOT_BUF];",
      "738:    addrtot(&md->sender, 0, fromname, ADDRTOT_BUF);",
      "743:    return v2N_INVALID_KE_PAYLOAD;",
      "",
      "[Added Lines]",
      "730:   char fromname[ADDRTOT_BUF];",
      "731:   addrtot(&md->sender, 0, fromname, ADDRTOT_BUF);",
      "733:   if (!md->chain[ISAKMP_NEXT_v2KE]) {",
      "735:    if(md->chain[ISAKMP_NEXT_v2N]) {",
      "736:     libreswan_log(\"Received Notify(%d): %s\",",
      "737:      md->chain[ISAKMP_NEXT_v2N]->payload.v2n.isan_type,",
      "738:      enum_name(&ikev2_notify_names,",
      "739:       md->chain[ISAKMP_NEXT_v2N]->payload.v2n.isan_type));",
      "740:    }",
      "741:    libreswan_log(",
      "742:     \"rejecting I1 from %s:%u, no KE payload present\",",
      "743:     fromname, md->sender_port);",
      "744:    return STF_FAIL + v2N_INVALID_KE_PAYLOAD;",
      "745:   }",
      "754:    return STF_FAIL + v2N_INVALID_KE_PAYLOAD;",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "819:    release_md(ke->md);",
      "820:  }",
      "821:  reset_globals();",
      "824: }",
      "826: static stf_status ikev2_parent_inI1outR1_tail(",
      "",
      "[Removed Lines]",
      "823:  passert(GLOBALS_ARE_RESET());",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "1145:    release_md(dh->md);",
      "1146:  }",
      "1147:  reset_globals();",
      "1150: }",
      "1152: static void ikev2_padup_pre_encrypt(struct msg_digest *md,",
      "",
      "[Removed Lines]",
      "1149:  passert(GLOBALS_ARE_RESET());",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "1715:  if (!md->chain[ISAKMP_NEXT_v2E]) {",
      "1716:   libreswan_log(\"R2 state should receive an encrypted payload\");",
      "1718:   return STF_FATAL;",
      "1719:  }",
      "",
      "[Removed Lines]",
      "1717:   reset_globals();",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "1794:    release_md(dh->md);",
      "1795:  }",
      "1796:  reset_globals();",
      "1799: }",
      "1801: static stf_status ikev2_parent_inI2outR2_tail(",
      "",
      "[Removed Lines]",
      "1798:  passert(GLOBALS_ARE_RESET());",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "b900c5afb24bc4e4d3e70d48432a31fd41041566",
      "candidate_info": {
        "commit_hash": "b900c5afb24bc4e4d3e70d48432a31fd41041566",
        "repo": "libreswan/libreswan",
        "commit_url": "https://github.com/libreswan/libreswan/commit/b900c5afb24bc4e4d3e70d48432a31fd41041566",
        "files": [
          "lib/libswan/id.c",
          "lib/libswan/x509dn.c",
          "programs/pluto/crypt_ke.c",
          "programs/pluto/demux.h",
          "programs/pluto/ikev1.c",
          "programs/pluto/ikev1_aggr.c",
          "programs/pluto/ikev1_main.c",
          "programs/pluto/ikev1_quick.c",
          "programs/pluto/ikev2.c",
          "programs/pluto/ikev2.h",
          "programs/pluto/ikev2_child.c",
          "programs/pluto/ikev2_parent.c",
          "programs/pluto/ipsec_doi.c",
          "programs/pluto/pluto_crypt.c",
          "programs/pluto/pluto_crypt.h",
          "programs/pluto/spdb.c",
          "programs/pluto/state.h",
          "testing/lib/libpluto/seam_crypt.c"
        ],
        "message": "Pluto: fallout from code reading\n\ntidy:\n\tfix grammar in comments and messages\n\tfix some whitespace\n\ttesting pointers for NULL should be explicit\n\treduce scope of locals\n\tuse symbols, not magic numerals\n\tremove some redundant parentheses\n\nclarify:\n\trename build_ke => build_ke_and_nonce\n\trename unpack_KE => unpack_KE_from_helper\n\trename enum member pcr_build_kenonce => pcr_build_ke_and_nonce\n\tadd const to some pointer parameters\n\tuse enum type instead of int where appropriate\n\timprove pluto_cryptoop_strings\n\nCorrect:\n\tIn TS handling, some functions returned -1 for exceptions\n\tbut the callers stored the result in unsigned int variables.\n\tFix:\n\t\tdocument function return values\n\t\tretype index variables and parameters\n\t\thandle -1 results\n\nSimplify:\n\teliminate struct msg_digest's pst (redundant and only sometimes accurate)\n\trefactor TS matching code, reducing redundancy\n\tremove redundant payload checking (already done by state machine)\n\narchaeology:\n\tadd pexpects for exploratory purposes\n\tadd explanitory comments capturing discoveries\n\t\tdocument functions better (note -1 returns)\n\tadd comments for mysteries (possible bugs)",
        "before_after_code_files": [
          "lib/libswan/id.c||lilibswan/id.c",
          "lib/libswan/x509dn.c||lilibswan/x509dn.c",
          "programs/pluto/crypt_ke.c||programs/pluto/crypt_ke.c",
          "programs/pluto/demux.h||programs/pluto/demux.h",
          "programs/pluto/ikev1.c||programs/pluto/ikev1.c",
          "programs/pluto/ikev1_aggr.c||programs/pluto/ikev1_aggr.c",
          "programs/pluto/ikev1_main.c||programs/pluto/ikev1_main.c",
          "programs/pluto/ikev1_quick.c||programs/pluto/ikev1_quick.c",
          "programs/pluto/ikev2.c||programs/pluto/ikev2.c",
          "programs/pluto/ikev2.h||programs/pluto/ikev2.h",
          "programs/pluto/ikev2_child.c||programs/pluto/ikev2_child.c",
          "programs/pluto/ikev2_parent.c||programs/pluto/ikev2_parent.c",
          "programs/pluto/ipsec_doi.c||programs/pluto/ipsec_doi.c",
          "programs/pluto/pluto_crypt.c||programs/pluto/pluto_crypt.c",
          "programs/pluto/pluto_crypt.h||programs/pluto/pluto_crypt.h",
          "programs/pluto/spdb.c||programs/pluto/spdb.c",
          "programs/pluto/state.h||programs/pluto/state.h",
          "testing/lib/libpluto/seam_crypt.c||testing/lilibpluto/seam_crypt.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "programs/pluto/ikev2_parent.c||programs/pluto/ikev2_parent.c"
          ],
          "candidate": [
            "programs/pluto/ikev2_parent.c||programs/pluto/ikev2_parent.c"
          ]
        }
      },
      "candidate_diff": {
        "lib/libswan/id.c||lilibswan/id.c": [
          "File: lib/libswan/id.c -> lilibswan/id.c"
        ],
        "lib/libswan/x509dn.c||lilibswan/x509dn.c": [
          "File: lib/libswan/x509dn.c -> lilibswan/x509dn.c"
        ],
        "programs/pluto/crypt_ke.c||programs/pluto/crypt_ke.c": [
          "File: programs/pluto/crypt_ke.c -> programs/pluto/crypt_ke.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "157:        DEFAULT_NONCE_SIZE));",
          "158: }",
          "164: {",
          "165:  struct pluto_crypto_req rd;",
          "168:  rd.pcr_d.kn.oakley_group = group->group;",
          "170:  cn->pcrc_serialno = st->st_serialno;",
          "",
          "[Removed Lines]",
          "160: stf_status build_ke(struct pluto_crypto_req_cont *cn,",
          "161:       struct state *st,",
          "162:       const struct oakley_group_desc *group,",
          "163:       enum crypto_importance importance)",
          "167:  pcr_nonce_init(&rd, pcr_build_kenonce, importance);",
          "",
          "[Added Lines]",
          "160: stf_status build_ke_and_nonce(",
          "161:  struct pluto_crypto_req_cont *cn,",
          "162:  struct state *st,",
          "163:  const struct oakley_group_desc *group,",
          "164:  enum crypto_importance importance)",
          "168:  pcr_nonce_init(&rd, pcr_build_ke_and_nonce, importance);",
          "",
          "---------------"
        ],
        "programs/pluto/demux.h||programs/pluto/demux.h": [
          "File: programs/pluto/demux.h -> programs/pluto/demux.h"
        ],
        "programs/pluto/ikev1.c||programs/pluto/ikev1.c": [
          "File: programs/pluto/ikev1.c -> programs/pluto/ikev1.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "2131:   DBG(DBG_CONTROLMORE, DBG_log(\"peer supports fragmentation\"));",
          "2132:   st->st_seen_fragvid = TRUE;",
          "2133:  }",
          "2136:      st->hidden_variables.st_peer_supports_dpd != md->dpd) {",
          "2137:   DBG(DBG_DPD, DBG_log(\"peer supports dpd\"));",
          "2138:   st->hidden_variables.st_peer_supports_dpd = md->dpd;",
          "",
          "[Removed Lines]",
          "2130:  if ( st && md->fragvid) {",
          "2135:  if ( st && md->dpd &&",
          "",
          "[Added Lines]",
          "2132:  if (st != NULL && md->fragvid) {",
          "2137:  if (st != NULL && md->dpd &&",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2142:   }",
          "2143:  }",
          "2146:   DBG(DBG_CONTROLMORE, DBG_log(\"peer requires nortel contivity workaround\"));",
          "2147:   st->st_seen_nortel_vid = TRUE;",
          "2148:  }",
          "",
          "[Removed Lines]",
          "2145:  if (st && md->nortel) {",
          "",
          "[Added Lines]",
          "2147:  if (st != NULL && md->nortel) {",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "2204:    struct state *p1st = state_with_serialno(",
          "2205:     st->st_clonedfrom);",
          "2209:     reserve_msgid(p1st, st->st_msgid);",
          "2210:    }",
          "",
          "[Removed Lines]",
          "2207:    if (p1st) {",
          "",
          "[Added Lines]",
          "2209:    if (p1st != NULL) {",
          "",
          "---------------"
        ],
        "programs/pluto/ikev1_aggr.c||programs/pluto/ikev1_aggr.c": [
          "File: programs/pluto/ikev1_aggr.c -> programs/pluto/ikev1_aggr.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "177:  st->st_calculating = FALSE;",
          "183:  unpack_nonce(&st->st_nr, r);",
          "",
          "[Removed Lines]",
          "180:  unpack_KE(st, r, &st->st_gr);",
          "",
          "[Added Lines]",
          "193:  unpack_KE_from_helper(st, r, &st->st_gr);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "320:  set_nat_traversal(st, md);",
          "323:  clonereplacechunk(st->st_p1isa, sa_pd->pbs.start,",
          "324:   pbs_room(&sa_pd->pbs), \"sa in aggr_inI1_outR1()\");",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "343:  pexpect(st->st_p1isa.ptr == NULL);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "352:   ke->ke_md = md;",
          "353:   set_suspended(st, md);",
          "355:   if (!st->st_sec_in_use) {",
          "357:    pcrc_init(&ke->ke_pcrc, aggr_inI1_outR1_continue1);",
          "359:      st->st_import);",
          "360:   } else {",
          "",
          "[Removed Lines]",
          "358:    return build_ke(&ke->ke_pcrc, st, st->st_oakley.group,",
          "",
          "[Added Lines]",
          "382:   pexpect(!st->st_sec_in_use);",
          "386:    return build_ke_and_nonce(&ke->ke_pcrc, st, st->st_oakley.group,",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1167:   ke->ke_md->st = st;",
          "1168:   set_suspended(st, ke->ke_md);",
          "1170:   if (!st->st_sec_in_use) {",
          "1172:    pcrc_init(&ke->ke_pcrc, aggr_outI1_continue);",
          "1174:          importance);",
          "1175:   } else {",
          "",
          "[Removed Lines]",
          "1173:    e = build_ke(&ke->ke_pcrc, st, st->st_oakley.group,",
          "",
          "[Added Lines]",
          "1203:   pexpect(!st->st_sec_in_use);",
          "1207:    e = build_ke_and_nonce(&ke->ke_pcrc, st, st->st_oakley.group,",
          "",
          "---------------"
        ],
        "programs/pluto/ikev1_main.c||programs/pluto/ikev1_main.c": [
          "File: programs/pluto/ikev1_main.c -> programs/pluto/ikev1_main.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "984:   passert(!st->st_sec_in_use);",
          "985:   pcrc_init(&ke->ke_pcrc, main_inR1_outI2_continue);",
          "986:   set_suspended(st, md);",
          "988:     st->st_import);",
          "989:  }",
          "990: }",
          "",
          "[Removed Lines]",
          "987:   return build_ke(&ke->ke_pcrc, st, st->st_oakley.group,",
          "",
          "[Added Lines]",
          "987:   return build_ke_and_nonce(&ke->ke_pcrc, st, st->st_oakley.group,",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1005:  chunk_t *g,",
          "1006:  pb_stream *outs, u_int8_t np)",
          "1007: {",
          "1009:  return justship_KE(g, outs, np);",
          "1010: }",
          "",
          "[Removed Lines]",
          "1008:  unpack_KE(st, r, g);",
          "",
          "[Added Lines]",
          "1008:  unpack_KE_from_helper(st, r, g);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1180:   passert(!st->st_sec_in_use);",
          "1181:   pcrc_init(&ke->ke_pcrc, main_inI2_outR2_continue);",
          "1183:     st->st_oakley.group, st->st_import);",
          "1184:  }",
          "1185: }",
          "",
          "[Removed Lines]",
          "1182:   return build_ke(&ke->ke_pcrc, st,",
          "",
          "[Added Lines]",
          "1182:   return build_ke_and_nonce(&ke->ke_pcrc, st,",
          "",
          "---------------"
        ],
        "programs/pluto/ikev1_quick.c||programs/pluto/ikev1_quick.c": [
          "File: programs/pluto/ikev1_quick.c -> programs/pluto/ikev1_quick.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "921:   pcrc_init(&qke->qke_pcrc, quick_outI1_continue);",
          "923:   if (policy & POLICY_PFS)",
          "925:          st->st_import);",
          "926:   else",
          "927:    e = build_nonce(&qke->qke_pcrc, st, st->st_import);",
          "",
          "[Removed Lines]",
          "924:    e = build_ke(&qke->qke_pcrc, st, st->st_pfs_group,",
          "",
          "[Added Lines]",
          "924:    e = build_ke_and_nonce(&qke->qke_pcrc, st, st->st_pfs_group,",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2083:    if (st->st_pfs_group != NULL) {",
          "2087:    } else {",
          "2089:     e = build_nonce(&qke->qke_pcrc, st, ci);",
          "",
          "[Removed Lines]",
          "2085:     e = build_ke(&qke->qke_pcrc, st,",
          "2086:           st->st_pfs_group, ci);",
          "",
          "[Added Lines]",
          "2085:     e = build_ke_and_nonce(&qke->qke_pcrc, st,",
          "2086:      st->st_pfs_group, ci);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "2143:    struct dh_continuation,",
          "2144:    \"quick outR1 DH\");",
          "2149:   dh->dh_md = md;",
          "",
          "[Removed Lines]",
          "2146:   unpack_KE(st, r, &st->st_gr);",
          "",
          "[Added Lines]",
          "2148:   unpack_KE_from_helper(st, r, &st->st_gr);",
          "",
          "---------------"
        ],
        "programs/pluto/ikev2.c||programs/pluto/ikev2.c": [
          "File: programs/pluto/ikev2.c -> programs/pluto/ikev2.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "923: void ikev2_update_counters(struct msg_digest *md)",
          "924: {",
          "926:  struct state *st = md->st;",
          "935:  if (md->hdr.isa_flags & ISAKMP_FLAGS_MSG_R) {",
          "940:  } else {",
          "944:  }",
          "945: }",
          "",
          "[Removed Lines]",
          "925:  struct state *pst = md->pst;",
          "928:  if (pst == NULL) {",
          "929:   if (IS_CHILD_SA(st))",
          "930:    pst = state_with_serialno(st->st_clonedfrom);",
          "931:   if (pst == NULL)",
          "932:    pst = st;",
          "933:  }",
          "937:   pst->st_msgid_lastack = md->msgid_received;",
          "938:   if(pst->st_msgid_lastack <= pst->st_msgid_nextuse)",
          "939:    pst->st_msgid_nextuse = pst->st_msgid_lastack + 1;",
          "942:   if (md->msgid_received > pst->st_msgid_lastrecv)",
          "943:    pst->st_msgid_lastrecv = md->msgid_received;",
          "",
          "[Added Lines]",
          "926:  struct state *ikesa = IS_CHILD_SA(st) ?",
          "927:   state_with_serialno(st->st_clonedfrom) : st;",
          "931:   ikesa->st_msgid_lastack = md->msgid_received;",
          "932:   if (ikesa->st_msgid_lastack <= ikesa->st_msgid_nextuse)",
          "933:    ikesa->st_msgid_nextuse = ikesa->st_msgid_lastack + 1;",
          "936:   if (md->msgid_received > ikesa->st_msgid_lastrecv)",
          "937:    ikesa->st_msgid_lastrecv = md->msgid_received;",
          "",
          "---------------"
        ],
        "programs/pluto/ikev2.h||programs/pluto/ikev2.h": [
          "File: programs/pluto/ikev2.h -> programs/pluto/ikev2.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "131: extern struct traffic_selector ikev2_end_to_ts(struct end *e);",
          "135:       enum phase1_role role,",
          "143:            enum phase1_role role,",
          "151: extern stf_status ikev2_calc_emit_ts(struct msg_digest *md,",
          "152:          pb_stream *outpbs,",
          "",
          "[Removed Lines]",
          "133: extern int ikev2_evaluate_connection_fit(struct connection *d,",
          "134:       struct spd_route *sr,",
          "136:       struct traffic_selector *tsi,",
          "137:       struct traffic_selector *tsr,",
          "138:       unsigned int tsi_n,",
          "139:       unsigned int tsr_n);",
          "141: extern int ikev2_evaluate_connection_port_fit(struct connection *d,",
          "142:            struct spd_route *sr,",
          "144:            struct traffic_selector *tsi,",
          "145:            struct traffic_selector *tsr,",
          "146:            unsigned int tsi_n,",
          "147:            unsigned int tsr_n,",
          "148:            unsigned int *best_tsi_i,",
          "149:            unsigned int *best_tsr_i);",
          "",
          "[Added Lines]",
          "133: extern int ikev2_evaluate_connection_fit(const struct connection *d,",
          "134:       const struct spd_route *sr,",
          "136:       const struct traffic_selector *tsi,",
          "137:       const struct traffic_selector *tsr,",
          "138:       int tsi_n,",
          "139:       int tsr_n);",
          "141: extern int ikev2_evaluate_connection_port_fit(const struct connection *d,",
          "142:            const struct spd_route *sr,",
          "144:            const struct traffic_selector *tsi,",
          "145:            const struct traffic_selector *tsr,",
          "146:            int tsi_n,",
          "147:            int tsr_n,",
          "148:            int *best_tsi_i,",
          "149:            int *best_tsr_i);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "158:      struct traffic_selector *array,",
          "159:      unsigned int array_max);",
          "163:         enum phase1_role role,",
          "171: extern stf_status ikev2_child_sa_respond(struct msg_digest *md,",
          "172:       enum phase1_role role,",
          "",
          "[Removed Lines]",
          "161: extern int ikev2_evaluate_connection_protocol_fit(struct connection *d,",
          "162:         struct spd_route *sr,",
          "164:         struct traffic_selector *tsi,",
          "165:         struct traffic_selector *tsr,",
          "166:         unsigned int tsi_n,",
          "167:         unsigned int tsr_n,",
          "168:         unsigned int *best_tsi_i,",
          "169:         unsigned int *best_tsr_i);",
          "",
          "[Added Lines]",
          "161: extern int ikev2_evaluate_connection_protocol_fit(const struct connection *d,",
          "162:         const struct spd_route *sr,",
          "164:         const struct traffic_selector *tsi,",
          "165:         const struct traffic_selector *tsr,",
          "166:         int tsi_n,",
          "167:         int tsr_n,",
          "168:         int *best_tsi_i,",
          "169:         int *best_tsr_i);",
          "",
          "---------------"
        ],
        "programs/pluto/ikev2_child.c||programs/pluto/ikev2_child.c": [
          "File: programs/pluto/ikev2_child.c -> programs/pluto/ikev2_child.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "88:  switch (e->client.addr.u.v4.sin_family) {",
          "89:  case AF_INET:",
          "90:   ts.ts_type = IKEv2_TS_IPV4_ADDR_RANGE;",
          "92:   ts.low.u.v4.sin_addr.s_addr &=",
          "93:    bitstomask(e->client.maskbits).s_addr;",
          "95:   ts.high.u.v4.sin_addr.s_addr |=",
          "96:    ~bitstomask(e->client.maskbits).s_addr;",
          "97:   break;",
          "",
          "[Removed Lines]",
          "91:   ts.low   = e->client.addr;",
          "94:   ts.high  = e->client.addr;",
          "",
          "[Added Lines]",
          "91:   ts.low = e->client.addr;",
          "94:   ts.high = e->client.addr;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "100:   ts.ts_type = IKEv2_TS_IPV6_ADDR_RANGE;",
          "101:   v6mask = bitstomask6(e->client.maskbits);",
          "104:   ts.low.u.v6.sin6_addr.s6_addr32[0] &= v6mask.s6_addr32[0];",
          "105:   ts.low.u.v6.sin6_addr.s6_addr32[1] &= v6mask.s6_addr32[1];",
          "106:   ts.low.u.v6.sin6_addr.s6_addr32[2] &= v6mask.s6_addr32[2];",
          "107:   ts.low.u.v6.sin6_addr.s6_addr32[3] &= v6mask.s6_addr32[3];",
          "110:   ts.high.u.v6.sin6_addr.s6_addr32[0] |= ~v6mask.s6_addr32[0];",
          "111:   ts.high.u.v6.sin6_addr.s6_addr32[1] |= ~v6mask.s6_addr32[1];",
          "112:   ts.high.u.v6.sin6_addr.s6_addr32[2] |= ~v6mask.s6_addr32[2];",
          "",
          "[Removed Lines]",
          "103:   ts.low   = e->client.addr;",
          "109:   ts.high  = e->client.addr;",
          "",
          "[Added Lines]",
          "103:   ts.low = e->client.addr;",
          "109:   ts.high = e->client.addr;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "268:  return STF_OK;",
          "269: }",
          "272: int ikev2_parse_ts(struct payload_digest *const ts_pd,",
          "273:      struct traffic_selector *array,",
          "274:      unsigned int array_max)",
          "275: {",
          "277:  unsigned int i;",
          "279:  for (i = 0; i < ts_pd->payload.v2ts.isat_num; i++) {",
          "280:   pb_stream addr;",
          "281:   if (!in_struct(&ts1, &ikev2_ts1_desc, &ts_pd->pbs, &addr))",
          "282:    return -1;",
          "290: #ifdef NEED_SIN_LEN",
          "293: #endif",
          "299: #ifdef NEED_SIN_LEN",
          "302: #endif",
          "313: #ifdef NEED_SIN_LEN",
          "316: #endif",
          "323: #ifdef NEED_SIN_LEN",
          "326: #endif",
          "335:     return -1;",
          "342:   }",
          "343:  }",
          "345:  return i;",
          "346: }",
          "350:         enum phase1_role role,",
          "357: {",
          "359:  int bestfit_pr = -1;",
          "361:  int narrowing = (d->policy & POLICY_IKEV2_ALLOW_NARROWING);",
          "363:  if (role == O_INITIATOR) {",
          "",
          "[Removed Lines]",
          "276:  struct ikev2_ts1 ts1;",
          "284:   if (i < array_max) {",
          "285:    zero(&array[i]);",
          "286:    switch (ts1.isat1_type) {",
          "287:    case IKEv2_TS_IPV4_ADDR_RANGE:",
          "288:     array[i].ts_type = IKEv2_TS_IPV4_ADDR_RANGE;",
          "289:     array[i].low.u.v4.sin_family  = AF_INET;",
          "291:     array[i].low.u.v4.sin_len =",
          "292:      sizeof( struct sockaddr_in);",
          "294:     if (!in_raw(&array[i].low.u.v4.sin_addr.s_addr,",
          "295:          4, &addr, \"ipv4 ts\"))",
          "296:      return -1;",
          "298:     array[i].high.u.v4.sin_family = AF_INET;",
          "300:     array[i].high.u.v4.sin_len =",
          "301:      sizeof( struct sockaddr_in);",
          "304:     if (!in_raw(&array[i].high.u.v4.sin_addr.s_addr,",
          "305:          4, &addr, \"ipv4 ts\"))",
          "306:      return -1;",
          "308:     break;",
          "310:    case IKEv2_TS_IPV6_ADDR_RANGE:",
          "311:     array[i].ts_type = IKEv2_TS_IPV6_ADDR_RANGE;",
          "312:     array[i].low.u.v6.sin6_family  = AF_INET6;",
          "314:     array[i].low.u.v6.sin6_len =",
          "315:      sizeof( struct sockaddr_in6);",
          "318:     if (!in_raw(&array[i].low.u.v6.sin6_addr.",
          "319:          s6_addr, 16, &addr, \"ipv6 ts\"))",
          "320:      return -1;",
          "322:     array[i].high.u.v6.sin6_family = AF_INET6;",
          "324:     array[i].high.u.v6.sin6_len =",
          "325:      sizeof( struct sockaddr_in6);",
          "328:     if (!in_raw(&array[i].high.u.v6.sin6_addr.",
          "329:          s6_addr, 16, &addr, \"ipv6 ts\"))",
          "330:      return -1;",
          "332:     break;",
          "334:    default:",
          "336:    }",
          "338:    array[i].ipprotoid = ts1.isat1_ipprotoid;",
          "340:    array[i].startport = ts1.isat1_startport;",
          "341:    array[i].endport   = ts1.isat1_endport;",
          "348: int ikev2_evaluate_connection_protocol_fit(struct connection *d,",
          "349:         struct spd_route *sr,",
          "351:         struct traffic_selector *tsi,",
          "352:         struct traffic_selector *tsr,",
          "353:         unsigned int tsi_n,",
          "354:         unsigned int tsr_n,",
          "355:         unsigned int *best_tsi_i,",
          "356:         unsigned int *best_tsr_i)",
          "358:  unsigned int tsi_ni, tsr_ni;",
          "360:  struct end *ei, *er;",
          "",
          "[Added Lines]",
          "280:   struct ikev2_ts1 ts1;",
          "285:   if (i >= array_max)",
          "286:    return -1;",
          "288:   zero(&array[i]);",
          "289:   switch (ts1.isat1_type) {",
          "290:   case IKEv2_TS_IPV4_ADDR_RANGE:",
          "291:    array[i].ts_type = IKEv2_TS_IPV4_ADDR_RANGE;",
          "292:    array[i].low.u.v4.sin_family = AF_INET;",
          "294:    array[i].low.u.v4.sin_len =",
          "295:     sizeof(struct sockaddr_in);",
          "297:    if (!in_raw(&array[i].low.u.v4.sin_addr.s_addr,",
          "298:         sizeof(array[i].low.u.v4.sin_addr.s_addr),",
          "299:         &addr, \"ipv4 ts\"))",
          "300:     return -1;",
          "302:    array[i].high.u.v4.sin_family = AF_INET;",
          "304:    array[i].high.u.v4.sin_len =",
          "305:     sizeof(struct sockaddr_in);",
          "308:    if (!in_raw(&array[i].high.u.v4.sin_addr.s_addr,",
          "309:         sizeof(array[i].high.u.v4.sin_addr.s_addr),",
          "310:         &addr, \"ipv4 ts\"))",
          "311:     return -1;",
          "313:    break;",
          "315:   case IKEv2_TS_IPV6_ADDR_RANGE:",
          "316:    array[i].ts_type = IKEv2_TS_IPV6_ADDR_RANGE;",
          "317:    array[i].low.u.v6.sin6_family = AF_INET6;",
          "319:    array[i].low.u.v6.sin6_len =",
          "320:     sizeof(struct sockaddr_in6);",
          "323:    if (!in_raw(&array[i].low.u.v6.sin6_addr.s6_addr,",
          "324:         sizeof(array[i].low.u.v6.sin6_addr.s6_addr),",
          "325:         &addr, \"ipv6 ts\"))",
          "326:     return -1;",
          "328:    array[i].high.u.v6.sin6_family = AF_INET6;",
          "330:    array[i].high.u.v6.sin6_len =",
          "331:     sizeof(struct sockaddr_in6);",
          "334:    if (!in_raw(&array[i].high.u.v6.sin6_addr.s6_addr,",
          "335:         sizeof(array[i].high.u.v6.sin6_addr.s6_addr),",
          "336:         &addr, \"ipv6 ts\"))",
          "339:    break;",
          "341:   default:",
          "342:    return -1;",
          "345:   if (pbs_left(&addr) != 0)",
          "346:    return -1;",
          "348:   array[i].ipprotoid = ts1.isat1_ipprotoid;",
          "351:   array[i].startport = ts1.isat1_startport;",
          "352:   array[i].endport = ts1.isat1_endport;",
          "365: static int ikev2_match_protocol(u_int8_t proto, u_int8_t ts_proto,",
          "366:  bool superset_ok, bool subset_ok, const char *which, int index)",
          "367: {",
          "369:  const char *m = \"no\";",
          "371:  if (proto == ts_proto) {",
          "373:   m = \"exact\";",
          "374:  } else if (superset_ok && ts_proto == 0) {",
          "375:   f = 1;",
          "376:   m = \"superset\";",
          "377:  } else if (subset_ok && proto == 0) {",
          "378:   f = 1;",
          "379:   m = \"subset\";",
          "380:  }",
          "381:  DBG(DBG_CONTROL,",
          "382:      DBG_log(\"protocol %d and %s[%d].ipprotoid %d: %s match\",",
          "383:       proto,",
          "384:       which, index,",
          "385:       ts_proto,",
          "386:       m));",
          "387:  return f;",
          "388: }",
          "394: int ikev2_evaluate_connection_protocol_fit(const struct connection *d,",
          "395:         const struct spd_route *sr,",
          "397:         const struct traffic_selector *tsi,",
          "398:         const struct traffic_selector *tsr,",
          "399:         int tsi_n,",
          "400:         int tsr_n,",
          "401:         int *best_tsi_i,",
          "402:         int *best_tsr_i)",
          "404:  int tsi_ni;",
          "406:  const struct end *ei, *er;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "367:   ei = &sr->that;",
          "368:   er = &sr->this;",
          "369:  }",
          "371:  for (tsi_ni = 0; tsi_ni < tsi_n; tsi_ni++) {",
          "372:   for (tsr_ni = 0; tsr_ni < tsr_n; tsr_ni++) {",
          "473:     DBG(DBG_CONTROL,",
          "475:    }",
          "476:   }",
          "477:  }",
          "479:  return bestfit_pr;",
          "481: }",
          "485:            enum phase1_role role,",
          "492: {",
          "494:  int bestfit_p = -1;",
          "496:  int narrowing = (d->policy & POLICY_IKEV2_ALLOW_NARROWING);",
          "498:  if (role == O_INITIATOR) {",
          "",
          "[Removed Lines]",
          "373:    int fitrange1 = 0;",
          "374:    int fitrange2 = 0;",
          "375:    DBG(DBG_CONTROL,",
          "376:        DBG_log(\"ei->protocol %d  tsi[tsi_ni].ipprotoid %d narrowing=%s\",",
          "377:         ei->protocol,",
          "378:         tsi[tsi_ni].ipprotoid,",
          "379:         (narrowing ? \"yes\" : \"no\")));",
          "380:    if (ei->protocol == tsi[tsi_ni].ipprotoid) {",
          "381:     fitrange1 = 255;",
          "382:     DBG(DBG_CONTROL,",
          "383:         DBG_log(\"   tsi[%d] %d  ==  ei->protocol %d exact match  fitrange1 %d\",",
          "384:          tsi_ni,",
          "385:          tsi[tsi_ni].ipprotoid,",
          "386:          ei->protocol,",
          "387:          fitrange1));",
          "389:    } else if ( (role == O_INITIATOR) && narrowing &&",
          "390:         (!ei->protocol)) {",
          "391:     DBG(DBG_CONTROL,",
          "392:         DBG_log(\"  O_INITIATOR narrowing=yes, want to narrow ei->protocol 0(all) to tsi[%d] protocol %d\",",
          "393:          tsi_ni,",
          "394:          tsi[tsi_ni].ipprotoid));",
          "395:     fitrange1 = 1;",
          "396:     DBG(DBG_CONTROL,",
          "397:         DBG_log(\"  tsi[%d] protocol %d >= ei->protocol 0(all) can be narrowed  fitrange1 %d\",",
          "398:          tsi_ni,",
          "399:          tsi[tsi_ni].ipprotoid, fitrange1));",
          "400:    } else if ( (role == O_RESPONDER) && narrowing &&",
          "401:         (ei->protocol)) {",
          "402:     DBG(DBG_CONTROL,",
          "403:         DBG_log(\"  O_RESPONDER narrowing=yes, want to narrow ei->protocol %d to tsi[%d] protocol %d\",",
          "404:          ei->protocol, tsi_ni,",
          "405:          tsi[tsi_ni].ipprotoid));",
          "406:     fitrange1 = 1;",
          "407:    } else {",
          "408:     DBG(DBG_CONTROL,",
          "409:         DBG_log(\"  mismatch tsi[%d] %d to ei->protocol %d\",",
          "410:          tsi_ni,",
          "411:          tsi[tsi_ni].ipprotoid,",
          "412:          ei->protocol));",
          "413:    }",
          "415:    if (er->protocol == tsr[tsr_ni].ipprotoid) {",
          "416:     fitrange2 = 255;",
          "417:     DBG(DBG_CONTROL,",
          "418:         DBG_log(\"   tsr[%d] %d  ==  er->protocol %d exact match  fitrange2 %d\",",
          "419:          tsr_ni,",
          "420:          tsr[tsr_ni].ipprotoid,",
          "421:          er->protocol,",
          "422:          fitrange2));",
          "424:    } else if ( (role == O_INITIATOR) && narrowing &&",
          "425:         (!er->protocol)) {",
          "426:     DBG(DBG_CONTROL,",
          "427:         DBG_log(\"  O_INITIATOR narrowing=yes, want to narrow er->protocol 0(all) to tsr[%d] protocol %d\",",
          "428:          tsr_ni,",
          "429:          tsr[tsr_ni].ipprotoid));",
          "430:     fitrange2 = 1;",
          "431:     DBG(DBG_CONTROL,",
          "432:         DBG_log(\"  tsr[%d] protocol %d >= er->protocol 0(all) can be narrowed  fitrange1 %d\",",
          "433:          tsr_ni,",
          "434:          tsr[tsr_ni].ipprotoid, fitrange1));",
          "435:    } else if ( (role == O_RESPONDER) && narrowing &&",
          "436:         (er->protocol)) {",
          "437:     DBG(DBG_CONTROL,",
          "438:         DBG_log(\"  O_RESPONDER narrowing=yes, want to narrow er->protocol %d to tsr[%d] protocol %d\",",
          "439:          er->protocol, tsr_ni,",
          "440:          tsr[tsr_ni].ipprotoid));",
          "441:     fitrange2 = 1;",
          "442:    } else {",
          "443:     DBG(DBG_CONTROL,",
          "444:         DBG_log(\"  mismatch tsr[%d] %d to er->protocol %d\",",
          "445:          tsr_ni,",
          "446:          tsr[tsr_ni].ipprotoid,",
          "447:          er->protocol));",
          "448:    }",
          "450:    int fitbits  = 0;",
          "451:    if (fitrange1 && fitrange2) {",
          "452:     fitbits = (fitrange1 << 8) + fitrange2;",
          "453:     DBG(DBG_CONTROL, DBG_log(\"    is a match\"));",
          "454:     if (fitbits > bestfit_pr) {",
          "457:      bestfit_pr = fitbits;",
          "458:      DBG(DBG_CONTROL,",
          "459:          DBG_log(\"    and is a better fit tsi[%d] fitrange1 %d tsr[%d] fitrange2 %d fitbits %d\",",
          "461:           fitrange1, *best_tsr_i,",
          "462:           fitrange2,",
          "463:           fitbits));",
          "464:     } else {",
          "465:      DBG(DBG_CONTROL,",
          "466:          DBG_log(\"    and is not a better fit tsi[%d] fitrange %d tsr[%d] fitrange2 %d fitbits %d\",",
          "468:           fitrange1, *best_tsr_i,",
          "469:           fitrange2,",
          "470:           fitbits));",
          "471:     }",
          "472:    } else {",
          "474:         DBG_log(\"    is not a match\"));",
          "478:  DBG(DBG_CONTROL, DBG_log(\"    protocol_fitnes  %d\", bestfit_pr));",
          "483: int ikev2_evaluate_connection_port_fit(struct connection *d,",
          "484:            struct spd_route *sr,",
          "486:            struct traffic_selector *tsi,",
          "487:            struct traffic_selector *tsr,",
          "488:            unsigned int tsi_n,",
          "489:            unsigned int tsr_n,",
          "490:            unsigned int *best_tsi_i,",
          "491:            unsigned int *best_tsr_i)",
          "493:  unsigned int tsi_ni, tsr_ni;",
          "495:  struct end *ei, *er;",
          "",
          "[Added Lines]",
          "419:   int tsr_ni;",
          "421:   int fitrange_i = ikev2_match_protocol(ei->protocol, tsi[tsi_ni].ipprotoid,",
          "422:    role == O_RESPONDER && narrowing,",
          "423:    role == O_INITIATOR && narrowing,",
          "424:    \"tsi\", tsi_ni);",
          "426:   if (fitrange_i == 0)",
          "430:    int fitrange_r = ikev2_match_protocol(er->protocol, tsr[tsr_ni].ipprotoid,",
          "431:     role == O_RESPONDER && narrowing,",
          "432:     role == O_INITIATOR && narrowing,",
          "433:     \"tsr\", tsr_ni);",
          "435:    int matchiness;",
          "437:    if (fitrange_r == 0)",
          "442:    if (matchiness > bestfit_pr) {",
          "445:     bestfit_pr = matchiness;",
          "447:         DBG_log(\"    best protocol fit so far: tsi[%d] fitrange_i %d, tsr[%d] fitrange_r %d, matchiness %d\",",
          "450:          matchiness));",
          "454:  DBG(DBG_CONTROL, DBG_log(\"    protocol_fitness %d\", bestfit_pr));",
          "456: }",
          "467: static int ikev2_match_port_range(u_int16_t port, struct traffic_selector ts,",
          "468:  bool superset_ok, bool subset_ok, const char *which, int index)",
          "469: {",
          "470:  u_int16_t low = port;",
          "471:  u_int16_t high = port == 0 ? 65535 : port;",
          "473:  const char *m = \"no\";",
          "475:  if (ts.startport > ts.endport) {",
          "476:   m = \"invalid range in\";",
          "477:  } else if (ts.startport == low && ts.endport == high) {",
          "478:   f = 1 + (high - low);",
          "479:   m = \"exact\";",
          "480:  } else if (superset_ok && ts.startport <= low && high <= ts.endport) {",
          "481:   f = 1 + (high - low);",
          "482:   m = \"superset\";",
          "483:  } else if (subset_ok && low <= ts.startport && ts.endport <= high) {",
          "484:   f = 1 + (ts.endport - ts.startport);",
          "485:   m = \"subset\";",
          "486:  }",
          "487:  DBG(DBG_CONTROL,",
          "488:      DBG_log(\"   %s[%d] %u-%u: %s port match with %u.  fitness %d\",",
          "489:       which, index,",
          "490:       ts.startport, ts.endport,",
          "491:       m,",
          "492:       port,",
          "493:       f));",
          "494:  return f;",
          "501: int ikev2_evaluate_connection_port_fit(const struct connection *d,",
          "502:            const struct spd_route *sr,",
          "504:            const struct traffic_selector *tsi,",
          "505:            const struct traffic_selector *tsr,",
          "506:            int tsi_n,",
          "507:            int tsr_n,",
          "508:            int *best_tsi_i,",
          "509:            int *best_tsr_i)",
          "511:  int tsi_ni;",
          "513:  const struct end *ei, *er;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "502:   ei = &sr->that;",
          "503:   er = &sr->this;",
          "504:  }",
          "506:  for (tsi_ni = 0; tsi_ni < tsi_n; tsi_ni++) {",
          "702:     DBG(DBG_CONTROL,",
          "704:    }",
          "706:   }",
          "707:  }",
          "709:  return bestfit_p;",
          "710: }",
          "",
          "[Removed Lines]",
          "507:   for (tsr_ni = 0; tsr_ni < tsr_n; tsr_ni++) {",
          "508:    int fitrange1 = 0;",
          "509:    int fitrange2 = 0;",
          "511:    DBG(DBG_CONTROL,",
          "512:        DBG_log(\"ei->port %d  tsi[tsi_ni].startport %d  tsi[tsi_ni].endport %d narrowing=%s\",",
          "513:         ei->port,",
          "514:         tsi[tsi_ni].startport, tsi[tsi_ni].endport,",
          "515:         (narrowing ? \"yes\" : \"no\")));",
          "517:    if ((ei->port) &&",
          "518:        (( ei->port == tsi[tsi_ni].startport ) &&",
          "519:         (ei->port == tsi[tsi_ni].endport))) {",
          "520:     fitrange1 = 1;",
          "521:     DBG(DBG_CONTROL,",
          "522:         DBG_log(\"   tsi[%d] %d  ==  ei->port %d exact match single port  fitrange1 %d\",",
          "523:          tsi_ni,",
          "524:          tsi[tsi_ni].startport, ei->port,",
          "525:          fitrange1));",
          "527:    } else if ((!ei->port) &&",
          "528:        ( ( tsi[tsi_ni].startport == ei->port ) &&",
          "529:          (tsi[tsi_ni].endport == 65535 ))) {",
          "531:     fitrange1 =  65535;",
          "532:     DBG(DBG_CONTROL,",
          "533:         DBG_log(\"   tsi[%d] %d-%d  ==  ei 0-65535 exact match all ports  fitrange1 %d\",",
          "534:          tsi_ni,",
          "535:          tsi[tsi_ni].startport,",
          "536:          tsi[tsi_ni].endport,",
          "537:          fitrange1));",
          "538:    } else if ( (role == O_INITIATOR) && narrowing &&",
          "539:         (!ei->port)) {",
          "540:     DBG(DBG_CONTROL,",
          "541:         DBG_log(\"   narrowing=yes want to narrow ei->port 0-65355 to tsi[%d] %d-%d\",",
          "542:          tsi_ni,",
          "543:          tsi[tsi_ni].startport,",
          "544:          tsi[tsi_ni].endport));",
          "545:     if ( tsi[tsi_ni].startport <=",
          "546:          tsi[tsi_ni].endport ) {",
          "547:      fitrange1 = 1 + tsi[tsi_ni].endport -",
          "548:           tsi[tsi_ni].startport;",
          "549:      DBG(DBG_CONTROL,",
          "550:          DBG_log(\"  tsi[%d] %d-%d >= ei->port 0-65535 can be narrowed  fitrange1 %d\",",
          "551:           tsi_ni,",
          "552:           tsi[tsi_ni].startport,",
          "553:           tsi[tsi_ni].endport,",
          "554:           fitrange1));",
          "555:     } else {",
          "556:      DBG(DBG_CONTROL,",
          "557:          DBG_log(\"   cant narrow tsi[%d] %d-%d to ei->port %d\",",
          "558:           tsi_ni,",
          "559:           tsi[tsi_ni].startport,",
          "560:           tsi[tsi_ni].endport,",
          "561:           ei->port));",
          "562:     }",
          "564:    } else if ((role == O_RESPONDER) &&",
          "565:        ( narrowing  && ei->port) ) {",
          "566:     DBG(DBG_CONTROL,",
          "567:         DBG_log(",
          "568:          \"   narrowing=yes want to narrow ei->port %d to tsi[%d] %d-%d to\",",
          "569:          ei->port, tsi_ni,",
          "570:          tsi[tsi_ni].startport,",
          "571:          tsi[tsi_ni].endport));",
          "572:     if (( ei->port >= tsi[tsi_ni].startport ) &&",
          "573:         (ei->port <= tsi[tsi_ni].endport)) {",
          "574:      fitrange1 = 1;",
          "575:      DBG(DBG_CONTROL,",
          "576:          DBG_log(\"  tsi[%d] %d-%d >= ei->port 0-65535. can be narrowed  fitrange1 %d\",",
          "577:           tsi_ni,",
          "578:           tsi[tsi_ni].startport,",
          "579:           tsi[tsi_ni].endport,",
          "580:           fitrange1));",
          "581:     } else {",
          "582:      DBG(DBG_CONTROL,",
          "583:          DBG_log(\"   cant narrow tsi[%d] %d-%d to ei->port %d\",",
          "584:           tsi_ni,",
          "585:           tsi[tsi_ni].startport,",
          "586:           tsi[tsi_ni].endport,",
          "587:           ei->port));",
          "588:     }",
          "590:    } else {",
          "591:     DBG(DBG_CONTROL,",
          "592:         DBG_log(\"  mismatch tsi[%d] %d-%d to ei->port %d\",",
          "593:          tsi_ni,",
          "594:          tsi[tsi_ni].startport,",
          "595:          tsi[tsi_ni].endport,",
          "596:          ei->port));",
          "597:    }",
          "599:    if ((er->port) &&",
          "600:        (( er->port == tsr[tsr_ni].startport ) &&",
          "601:         (er->port == tsr[tsr_ni].endport))) {",
          "602:     fitrange2 = 1;",
          "603:     DBG(DBG_CONTROL,",
          "604:         DBG_log(\"   tsr[%d] %d  ==  er->port %d exact match single port fitrange2 %d\",",
          "605:          tsr_ni,",
          "606:          tsr[tsr_ni].startport, er->port,",
          "607:          fitrange2));",
          "609:    } else if ((!er->port) &&",
          "610:        ( ( tsr[tsr_ni].startport == er->port ) &&",
          "611:          (tsr[tsr_ni].endport == 65535 ))) {",
          "613:     fitrange2 =  65535;",
          "614:     DBG(DBG_CONTROL,",
          "615:         DBG_log(\"   tsr[%d] %d-%d  ==  ei 0-65535 exact match all ports fitrange2 %d\",",
          "616:          tsr_ni,",
          "617:          tsr[tsr_ni].startport,",
          "618:          tsr[tsr_ni].endport,",
          "619:          fitrange2));",
          "620:    } else if ( (role == O_INITIATOR) && narrowing &&",
          "621:         (!er->port)) {",
          "622:     DBG(DBG_CONTROL,",
          "623:         DBG_log(\"   narrowing=yes want to narrow ei->port 0-65355 to tsi[%d] %d-%d\",",
          "624:          tsr_ni,",
          "625:          tsr[tsr_ni].startport,",
          "626:          tsr[tsr_ni].endport));",
          "627:     if ( tsr[tsr_ni].startport <=",
          "628:          tsi[tsr_ni].endport ) {",
          "629:      fitrange2 = 1 + tsr[tsr_ni].endport -",
          "630:           tsr[tsr_ni].startport;",
          "631:      DBG(DBG_CONTROL,",
          "632:          DBG_log(\"  tsr[%d] %d-%d <= er->port 0-65535 can be narrowed  fitrange2 %d\",",
          "633:           tsr_ni,",
          "634:           tsr[tsr_ni].startport,",
          "635:           tsr[tsr_ni].endport,",
          "636:           fitrange2));",
          "637:     } else {",
          "638:      DBG(DBG_CONTROL,",
          "639:          DBG_log(\"   cant narrow tsr[%d] %d-%d to er->port 0-65535\",",
          "640:           tsr_ni,",
          "641:           tsr[tsr_ni].startport,",
          "642:           tsr[tsr_ni].endport));",
          "643:     }",
          "645:    } else if ((role == O_RESPONDER) &&  narrowing  &&",
          "646:        (er->port)) {",
          "647:     DBG(DBG_CONTROL,",
          "648:         DBG_log(\"   narrowing=yes want to narrow ei->port 0-65535 to tsi[%d] %d-%d\",",
          "649:          tsr_ni,",
          "650:          tsr[tsr_ni].startport,",
          "651:          tsr[tsr_ni].endport));",
          "652:     if ((  er->port >= tsr[tsr_ni].startport ) &&",
          "653:         (er->port <= tsr[tsr_ni].endport)) {",
          "654:      fitrange2 = 1;",
          "655:      DBG(DBG_CONTROL,",
          "656:          DBG_log(\"  tsr[%d] %d-%d <= er->port %d can be narrowed fitrange2 %d\",",
          "657:           tsr_ni,",
          "658:           tsr[tsr_ni].startport,",
          "659:           tsr[tsr_ni].endport,",
          "660:           er->port,",
          "661:           fitrange2));",
          "662:     } else {",
          "663:      DBG(DBG_CONTROL,",
          "664:          DBG_log(\"   can't narrow tsr[%d] %d-%d to er->port %d\",",
          "665:           tsr_ni,",
          "666:           tsr[tsr_ni].startport,",
          "667:           tsr[tsr_ni].endport,",
          "668:           er->port));",
          "669:     }",
          "670:    } else {",
          "671:     DBG(DBG_CONTROL,",
          "672:         DBG_log(\"  mismatch tsr[%d] %d-%d to er->port %d\",",
          "673:          tsr_ni,",
          "674:          tsr[tsr_ni].startport,",
          "675:          tsr[tsr_ni].endport,",
          "676:          er->port));",
          "677:    }",
          "679:    int fitbits  = 0;",
          "680:    if (fitrange1 && fitrange2) {",
          "681:     fitbits = (fitrange1 << 8) + fitrange2;",
          "682:     DBG(DBG_CONTROL, DBG_log(\"    is a match\"));",
          "683:     if (fitbits > bestfit_p) {",
          "686:      bestfit_p = fitbits;",
          "687:      DBG(DBG_CONTROL,",
          "688:          DBG_log(\"    and is a better fit tsi[%d] fitrange1 %d tsr[%d] fitrange2 %d fitbits %d\",",
          "690:           fitrange1, *best_tsr_i,",
          "691:           fitrange2,",
          "692:           fitbits));",
          "693:     } else {",
          "694:      DBG(DBG_CONTROL,",
          "695:          DBG_log(\"    and is not a better fit tsi[%d] fitrange %d tsr[%d] fitrange2 %d fitbits %d\",",
          "697:           fitrange1, *best_tsr_i,",
          "698:           fitrange2,",
          "699:           fitbits));",
          "700:     }",
          "701:    } else {",
          "703:         DBG_log(\"    is not a match\"));",
          "708:  DBG(DBG_CONTROL, DBG_log(\"    port_fitness  %d\", bestfit_p));",
          "",
          "[Added Lines]",
          "526:   int tsr_ni;",
          "527:   int fitrange_i = ikev2_match_port_range(ei->port, tsi[tsi_ni],",
          "528:    role == O_RESPONDER && narrowing,",
          "529:    role == O_INITIATOR && narrowing,",
          "530:    \"tsi\", tsi_ni);",
          "532:   if (fitrange_i == 0)",
          "535:   for (tsr_ni = 0; tsr_ni < tsr_n; tsr_ni++) {",
          "536:    int fitrange_r = ikev2_match_port_range(er->port, tsr[tsr_ni],",
          "537:     role == O_RESPONDER && narrowing,",
          "538:     role == O_INITIATOR && narrowing,",
          "539:     \"tsr\", tsr_ni);",
          "541:    int matchiness;",
          "543:    if (fitrange_r == 0)",
          "548:    if (matchiness > bestfit_p) {",
          "551:     bestfit_p = matchiness;",
          "553:         DBG_log(\"    best ports fit so far: tsi[%d] fitrange_i %d, tsr[%d] fitrange_r %d, matchiness %d\",",
          "556:          matchiness));",
          "560:  DBG(DBG_CONTROL, DBG_log(\"    port_fitness %d\", bestfit_p));",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "718:       enum phase1_role role,",
          "723: {",
          "725:  int bestfit = -1;",
          "728:  if (role == O_INITIATOR) {",
          "729:   ei = &sr->this;",
          "",
          "[Removed Lines]",
          "716: int ikev2_evaluate_connection_fit(struct connection *d,",
          "717:       struct spd_route *sr,",
          "719:       struct traffic_selector *tsi,",
          "720:       struct traffic_selector *tsr,",
          "721:       unsigned int tsi_n,",
          "722:       unsigned int tsr_n)",
          "724:  unsigned int tsi_ni, tsr_ni;",
          "726:  struct end *ei, *er;",
          "",
          "[Added Lines]",
          "568: int ikev2_evaluate_connection_fit(const struct connection *d,",
          "569:       const struct spd_route *sr,",
          "571:       const struct traffic_selector *tsi,",
          "572:       const struct traffic_selector *tsr,",
          "573:       int tsi_n,",
          "574:       int tsr_n)",
          "576:  int tsi_ni;",
          "578:  const struct end *ei, *er;",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "749:  for (tsi_ni = 0; tsi_ni < tsi_n; tsi_ni++) {",
          "750:   for (tsr_ni = 0; tsr_ni < tsr_n; tsr_ni++) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "602:   int tsr_ni;",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "792:      tsr[tsr_ni].low, tsr[tsr_ni].high);",
          "793:     int maskbits2 = er->client.maskbits;",
          "794:     int fitbits2 = maskbits2 + ts_range2;",
          "795:     int fitbits = (fitbits1 << 8) + fitbits2;",
          "801:     DBG(DBG_CONTROL,",
          "803:          ei->port,",
          "804:          tsi[tsi_ni].startport,",
          "805:          tsi[tsi_ni].endport));",
          "809:      fitbits = fitbits << 1;",
          "814:      fitbits = fitbits << 1;",
          "816:     DBG(DBG_CONTROLMORE,",
          "",
          "[Removed Lines]",
          "802:         DBG_log(\"ei->port %d  tsi[tsi_ni].startport %d  tsi[tsi_ni].endport %d\",",
          "806:     if (ei->port &&",
          "807:          (tsi[tsi_ni].startport == ei->port &&",
          "808:           tsi[tsi_ni].endport == ei->port))",
          "811:     if (er->port &&",
          "812:          (tsr[tsr_ni].startport == er->port &&",
          "813:           tsr[tsr_ni].endport == er->port))",
          "",
          "[Added Lines]",
          "659:         DBG_log(\"ei->port %d tsi[tsi_ni].startport %d  tsi[tsi_ni].endport %d\",",
          "664:     if (ei->port != 0 &&",
          "665:         tsi[tsi_ni].startport == ei->port &&",
          "666:         tsi[tsi_ni].endport == ei->port)",
          "669:     if (er->port != 0 &&",
          "670:         tsr[tsr_ni].startport == er->port &&",
          "671:         tsr[tsr_ni].endport == er->port)",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "828:  return bestfit;",
          "829: }",
          "834: {",
          "843:  struct traffic_selector tsi[16], tsr[16];",
          "879:     DBG(DBG_CONTROLMORE,",
          "888:      DBG(DBG_CONTROLMORE,",
          "890:           c->name,",
          "915:     }",
          "920:    }",
          "921:   }",
          "945:     continue;",
          "975:         &best_tsi_i,",
          "976:         &best_tsr_i);",
          "1007:       }",
          "1012:      }",
          "1013:     }",
          "1014:    }",
          "1015:   }",
          "1048:  }",
          "1055:  {",
          "",
          "[Removed Lines]",
          "831: stf_status ikev2_child_sa_respond(struct msg_digest *md,",
          "832:       enum phase1_role role,",
          "833:       pb_stream *outpbs)",
          "835:  struct state      *st = md->st;",
          "836:  struct state      *st1;",
          "837:  struct connection *c  = st->st_connection;",
          "839:  struct payload_digest *const sa_pd = md->chain[ISAKMP_NEXT_v2SA];",
          "840:  stf_status ret;",
          "841:  struct payload_digest *const tsi_pd = md->chain[ISAKMP_NEXT_v2TSi];",
          "842:  struct payload_digest *const tsr_pd = md->chain[ISAKMP_NEXT_v2TSr];",
          "844:  unsigned int tsi_n, tsr_n;",
          "850:  tsi_n = ikev2_parse_ts(tsi_pd, tsi, 16);",
          "851:  tsr_n = ikev2_parse_ts(tsr_pd, tsr, 16);",
          "859:  {",
          "860:   struct connection *b = c;",
          "861:   struct connection *d;",
          "862:   int bestfit_n, newfit, bestfit_p, bestfit_pr;",
          "863:   struct spd_route *sra, *bsr;",
          "864:   struct host_pair *hp = NULL;",
          "865:   unsigned int best_tsi_i,  best_tsr_i;",
          "867:   bsr = NULL;",
          "868:   bestfit_n = -1;",
          "869:   bestfit_p = -1;",
          "870:   bestfit_pr = -1,",
          "871:   best_tsi_i =  best_tsr_i = -1;",
          "873:   for (sra = &c->spd; sra != NULL; sra = sra->next) {",
          "874:    int bfit_n = ikev2_evaluate_connection_fit(c, sra,",
          "875:            role, tsi,",
          "876:            tsr, tsi_n,",
          "877:            tsr_n);",
          "878:    if (bfit_n > bestfit_n) {",
          "880:         DBG_log(\"bfit_n=ikev2_evaluate_connection_fit found better fit c %s\",",
          "881:          c->name));",
          "882:     int bfit_p = ikev2_evaluate_connection_port_fit(",
          "883:      c, sra, role,",
          "884:      tsi, tsr,",
          "885:      tsi_n, tsr_n,",
          "886:      &best_tsi_i, &best_tsr_i);",
          "887:     if (bfit_p > bestfit_p) {",
          "889:          DBG_log(\"ikev2_evaluate_connection_port_fit found better fit c %s, tsi[%d],tsr[%d]\",",
          "891:           best_tsi_i, best_tsr_i));",
          "892:      int bfit_pr =",
          "893:       ikev2_evaluate_connection_protocol_fit(",
          "894:        c, sra, role, tsi, tsr,",
          "895:        tsi_n,",
          "896:        tsr_n, &best_tsi_i,",
          "897:        &best_tsr_i);",
          "898:      if (bfit_pr > bestfit_pr ) {",
          "899:       DBG(DBG_CONTROLMORE,",
          "900:           DBG_log(\"ikev2_evaluate_connection_protocol_fit found better fit c %s, tsi[%d],tsr[%d]\",",
          "901:            c->name,",
          "902:            best_tsi_i,",
          "903:            best_tsr_i));",
          "905:       bestfit_p = bfit_p;",
          "906:       bestfit_n = bfit_n;",
          "907:       b = c;",
          "908:       bsr = sra;",
          "909:      } else {",
          "910:       DBG(DBG_CONTROLMORE,",
          "911:           DBG_log(\"protocol range fit c %s c->name was rejected by protocol matching\",",
          "912:            c",
          "913:            ->name));",
          "914:      }",
          "916:    } else {",
          "917:     DBG(DBG_CONTROLMORE,",
          "918:         DBG_log(\"prefix range fit c %s c->name was rejected by port matching\",",
          "919:          c->name));",
          "923:   for (sra = &c->spd; hp == NULL && sra != NULL;",
          "924:        sra = sra->next) {",
          "925:    hp = find_host_pair(&sra->this.host_addr,",
          "926:          sra->this.host_port,",
          "927:          &sra->that.host_addr,",
          "928:          sra->that.host_port);",
          "930:    DBG(DBG_CONTROLMORE, {",
          "931:     char s2[SUBNETTOT_BUF];",
          "932:     char d2[SUBNETTOT_BUF];",
          "934:     subnettot(&sra->this.client, 0, s2,",
          "935:        sizeof(s2));",
          "936:     subnettot(&sra->that.client, 0, d2,",
          "937:        sizeof(d2));",
          "939:     DBG_log(\"  checking hostpair %s -> %s is %s\",",
          "940:      s2, d2,",
          "941:      (hp ? \"found\" : \"not found\"));",
          "942:    });",
          "944:    if (!hp)",
          "947:    for (d = hp->connections; d != NULL; d = d->hp_next) {",
          "948:     struct spd_route *sr;",
          "951:     if (d->policy & POLICY_GROUP)",
          "952:      continue;",
          "954:     if (!(same_id(&c->spd.this.id,",
          "955:            &d->spd.this.id) &&",
          "956:           match_id(&c->spd.that.id,",
          "957:             &d->spd.that.id, &wildcards) &&",
          "958:           trusted_ca(c->spd.that.ca,",
          "959:        d->spd.that.ca, &pathlen)))",
          "960:      continue;",
          "961:     for (sr = &d->spd; sr != NULL; sr = sr->next) {",
          "962:      newfit = ikev2_evaluate_connection_fit(",
          "963:       d, sr, role,",
          "964:       tsi, tsr, tsi_n,",
          "965:       tsr_n);",
          "967:       DBG(DBG_CONTROLMORE,",
          "968:           DBG_log(\"bfit=ikev2_evaluate_connection_fit found better fit d %s\",",
          "969:            d->name));",
          "970:       int bfit_p =",
          "971:        ikev2_evaluate_connection_port_fit(",
          "972:         d, sra, role,",
          "973:         tsi, tsr,",
          "974:         tsi_n, tsr_n,",
          "977:       if (bfit_p > bestfit_p) {",
          "978:        DBG(DBG_CONTROLMORE, DBG_log(",
          "979:             \"ikev2_evaluate_connection_port_fit found better fit d %s, tsi[%d],tsr[%d]\",",
          "980:             d->name,",
          "981:             best_tsi_i,",
          "982:             best_tsr_i));",
          "983:        int bfit_pr =",
          "984:         ikev2_evaluate_connection_protocol_fit(",
          "985:          d, sra,",
          "986:          role,",
          "987:          tsi,",
          "988:          tsr,",
          "989:          tsi_n,",
          "990:          tsr_n,",
          "991:          &best_tsi_i,",
          "992:          &best_tsr_i);",
          "993:        if (bfit_pr > bestfit_pr) {",
          "994:         DBG(DBG_CONTROLMORE,",
          "995:             DBG_log(\"ikev2_evaluate_connection_protocol_fit found better fit d %s, tsi[%d],tsr[%d]\",",
          "996:              d->name, best_tsi_i, best_tsr_i));",
          "998:         bestfit_p = bfit_p;",
          "999:         bestfit_n = newfit;",
          "1000:         b = d;",
          "1001:         bsr = sr;",
          "1002:        } else {",
          "1003:         DBG(DBG_CONTROLMORE,",
          "1004:             DBG_log(\"protocol range fit d %s c->name was rejected by protocol matching\",",
          "1005:              d->name));",
          "1006:        }",
          "1008:      } else {",
          "1009:       DBG(DBG_CONTROLMORE,",
          "1010:           DBG_log(\"prefix range fit d %s d->name was rejected by port matching\",",
          "1011:            d->name));",
          "1024:   c = b;",
          "1027:   if (bsr != NULL) {",
          "1028:    st1 = duplicate_state(st);",
          "1031:    if (role == O_INITIATOR) {",
          "1032:     memcpy(&st1->st_ts_this, &tsi[best_tsi_i],",
          "1033:            sizeof(struct traffic_selector));",
          "1034:     memcpy(&st1->st_ts_that, &tsr[best_tsr_i],",
          "1035:            sizeof(struct traffic_selector));",
          "1036:    } else {",
          "1037:     st1->st_ts_this = ikev2_end_to_ts(&bsr->this);",
          "1038:     st1->st_ts_that = ikev2_end_to_ts(&bsr->that);",
          "1039:    }",
          "1040:    ikev2_print_ts(&st1->st_ts_this);",
          "1041:    ikev2_print_ts(&st1->st_ts_that);",
          "1042:   } else {",
          "1043:    if (role == O_INITIATOR)",
          "1044:     return STF_FAIL;",
          "1045:    else",
          "1046:     return STF_FAIL + v2N_NO_PROPOSAL_CHOSEN;",
          "1047:   }",
          "1050:  st1->st_connection = c;",
          "1051:  md->st = st1;",
          "1052:  md->pst = st;",
          "",
          "[Added Lines]",
          "691: static stf_status ikev2_create_responder_child_state(",
          "692:  struct msg_digest *md,",
          "694:  enum phase1_role role)",
          "698:  struct connection *c = pst->st_connection;",
          "702:  const int tsi_n = ikev2_parse_ts(md->chain[ISAKMP_NEXT_v2TSi],",
          "703:   tsi, elemsof(tsi));",
          "704:  const int tsr_n = ikev2_parse_ts(md->chain[ISAKMP_NEXT_v2TSr],",
          "705:   tsr, elemsof(tsr));",
          "708:  int bestfit_n = -1;",
          "709:  int bestfit_p = -1;",
          "710:  int bestfit_pr = -1;",
          "711:  struct spd_route *sra, *bsr = NULL;",
          "712:  struct host_pair *hp = NULL;",
          "714:  int best_tsi_i = -1;",
          "715:  int best_tsr_i = -1;",
          "720:  if (tsi_n < 0 || tsr_n < 0)",
          "721:   return STF_FAIL + v2N_TS_UNACCEPTABLE;",
          "723:  for (sra = &c->spd; sra != NULL; sra = sra->next) {",
          "724:   int bfit_n = ikev2_evaluate_connection_fit(",
          "725:    c, sra, role,",
          "726:    tsi, tsr, tsi_n, tsr_n);",
          "728:   if (bfit_n > bestfit_n) {",
          "729:    DBG(DBG_CONTROLMORE,",
          "730:        DBG_log(\"bfit_n=ikev2_evaluate_connection_fit found better fit c %s\",",
          "731:         c->name));",
          "732:    int bfit_p = ikev2_evaluate_connection_port_fit(",
          "733:         c, sra, role,",
          "734:         tsi, tsr, tsi_n, tsr_n,",
          "735:         &best_tsi_i, &best_tsr_i);",
          "737:    if (bfit_p > bestfit_p) {",
          "739:         DBG_log(\"ikev2_evaluate_connection_port_fit found better fit c %s, tsi[%d],tsr[%d]\",",
          "740:          c->name,",
          "741:          best_tsi_i, best_tsr_i));",
          "742:     int bfit_pr =",
          "743:      ikev2_evaluate_connection_protocol_fit(",
          "744:       c, sra, role,",
          "745:       tsi, tsr, tsi_n, tsr_n,",
          "746:       &best_tsi_i, &best_tsr_i);",
          "748:     if (bfit_pr > bestfit_pr) {",
          "750:          DBG_log(\"ikev2_evaluate_connection_protocol_fit found better fit c %s, tsi[%d],tsr[%d]\",",
          "752:           best_tsi_i,",
          "753:           best_tsr_i));",
          "755:      bestfit_p = bfit_p;",
          "756:      bestfit_n = bfit_n;",
          "758:      b = c;",
          "759:      bsr = sra;",
          "760:     } else {",
          "761:      DBG(DBG_CONTROLMORE,",
          "762:          DBG_log(\"protocol fit c %s c->name was rejected by protocol matching\",",
          "763:           c->name));",
          "766:   } else {",
          "767:    DBG(DBG_CONTROLMORE,",
          "768:        DBG_log(\"prefix range fit c %s c->name was rejected by port matching\",",
          "769:         c->name));",
          "771:  }",
          "784:  for (sra = &c->spd; hp == NULL && sra != NULL;",
          "785:       sra = sra->next) {",
          "786:   struct connection *d;",
          "788:   hp = find_host_pair(&sra->this.host_addr,",
          "789:         sra->this.host_port,",
          "790:         &sra->that.host_addr,",
          "791:         sra->that.host_port);",
          "793:   DBG(DBG_CONTROLMORE, {",
          "794:    char s2[SUBNETTOT_BUF];",
          "795:    char d2[SUBNETTOT_BUF];",
          "797:    subnettot(&sra->this.client, 0, s2,",
          "798:       sizeof(s2));",
          "799:    subnettot(&sra->that.client, 0, d2,",
          "800:       sizeof(d2));",
          "802:    DBG_log(\"  checking hostpair %s -> %s is %s\",",
          "803:     s2, d2,",
          "804:     hp == NULL ? \"not found\" : \"found\");",
          "805:   });",
          "807:   if (hp == NULL)",
          "808:    continue;",
          "810:   for (d = hp->connections; d != NULL; d = d->hp_next) {",
          "811:    struct spd_route *sr;",
          "814:    if (d->policy & POLICY_GROUP)",
          "827:    if (!(same_id(&c->spd.this.id,",
          "828:           &d->spd.this.id) &&",
          "829:          match_id(&c->spd.that.id,",
          "830:            &d->spd.that.id, &wildcards) &&",
          "831:          trusted_ca(c->spd.that.ca,",
          "832:       d->spd.that.ca, &pathlen)))",
          "833:     continue;",
          "835:    for (sr = &d->spd; sr != NULL; sr = sr->next) {",
          "836:     int newfit = ikev2_evaluate_connection_fit(",
          "837:      d, sr, role,",
          "838:      tsi, tsr, tsi_n, tsr_n);",
          "840:     if (newfit > bestfit_n) {",
          "843:      DBG(DBG_CONTROLMORE,",
          "844:          DBG_log(\"bfit=ikev2_evaluate_connection_fit found better fit d %s\",",
          "845:           d->name));",
          "846:      int bfit_p =",
          "847:       ikev2_evaluate_connection_port_fit(",
          "848:        d, sra, role,",
          "849:        tsi, tsr,",
          "850:        tsi_n, tsr_n,",
          "851:        &best_tsi_i,",
          "852:        &best_tsr_i);",
          "854:      if (bfit_p > bestfit_p) {",
          "855:       DBG(DBG_CONTROLMORE, DBG_log(",
          "856:            \"ikev2_evaluate_connection_port_fit found better fit d %s, tsi[%d],tsr[%d]\",",
          "857:            d->name,",
          "858:            best_tsi_i,",
          "859:            best_tsr_i));",
          "860:       int bfit_pr =",
          "861:        ikev2_evaluate_connection_protocol_fit(",
          "862:         d, sra,",
          "863:         role,",
          "864:         tsi,",
          "865:         tsr,",
          "866:         tsi_n,",
          "867:         tsr_n,",
          "871:       if (bfit_pr > bestfit_pr) {",
          "872:        DBG(DBG_CONTROLMORE,",
          "873:            DBG_log(\"ikev2_evaluate_connection_protocol_fit found better fit d %s, tsi[%d],tsr[%d]\",",
          "874:             d->name, best_tsi_i, best_tsr_i));",
          "876:        bestfit_p = bfit_p;",
          "877:        bestfit_n = newfit;",
          "878:        b = d;",
          "879:        bsr = sr;",
          "880:       } else {",
          "881:        DBG(DBG_CONTROLMORE,",
          "882:            DBG_log(\"protocol fit d %s c->name was rejected by protocol matching\",",
          "883:             d->name));",
          "886:     } else {",
          "887:      DBG(DBG_CONTROLMORE,",
          "888:          DBG_log(\"prefix range fit d %s d->name was rejected by port matching\",",
          "889:           d->name));",
          "893:  }",
          "902:  c = b;",
          "904:  if (bsr == NULL) {",
          "906:   if (role == O_INITIATOR)",
          "907:    return STF_FAIL;",
          "908:   else",
          "909:    return STF_FAIL + v2N_NO_PROPOSAL_CHOSEN;",
          "912:  cst = duplicate_state(pst);",
          "913:  cst->st_connection = c;",
          "916:  if (role == O_INITIATOR) {",
          "917:   memcpy(&cst->st_ts_this, &tsi[best_tsi_i],",
          "918:          sizeof(struct traffic_selector));",
          "919:   memcpy(&cst->st_ts_that, &tsr[best_tsr_i],",
          "920:          sizeof(struct traffic_selector));",
          "921:  } else {",
          "922:   cst->st_ts_this = ikev2_end_to_ts(&bsr->this);",
          "923:   cst->st_ts_that = ikev2_end_to_ts(&bsr->that);",
          "924:  }",
          "925:  ikev2_print_ts(&cst->st_ts_this);",
          "926:  ikev2_print_ts(&cst->st_ts_that);",
          "930: }",
          "932: stf_status ikev2_child_sa_respond(struct msg_digest *md,",
          "933:       enum phase1_role role,",
          "934:       pb_stream *outpbs)",
          "935: {",
          "937:  struct connection *c;",
          "938:  struct payload_digest *const sa_pd = md->chain[ISAKMP_NEXT_v2SA];",
          "940:  {",
          "941:   stf_status ret = ikev2_create_responder_child_state(md, &cst, role);",
          "943:   if (cst == NULL)",
          "945:  }",
          "947:  c = cst->st_connection;",
          "949:  md->st = cst;",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "1065:   ret = ikev2_parse_child_sa_body(&sa_pd->pbs,",
          "1068:   if (ret != STF_OK)",
          "1069:    return ret;",
          "1070:  }",
          "1073:      c, c->policy);",
          "1077:  if (role == O_RESPONDER) {",
          "1078:   struct payload_digest *p;",
          "",
          "[Removed Lines]",
          "1066:             &r_sa_pbs, st1, FALSE);",
          "1072:  ret = ikev2_calc_emit_ts(md, outpbs, role,",
          "1074:  if (ret != STF_OK)",
          "",
          "[Added Lines]",
          "963:       &r_sa_pbs, cst, FALSE);",
          "969:  {",
          "970:   stf_status ret = ikev2_calc_emit_ts(md, outpbs, role,",
          "973:   if (ret != STF_OK)",
          "975:  }",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "1080:   for (p = md->chain[ISAKMP_NEXT_v2N]; p != NULL; p = p->next) {",
          "1081:    if (p->payload.v2n.isan_type ==",
          "1082:        v2N_USE_TRANSPORT_MODE) {",
          "1085:         POLICY_TUNNEL) {",
          "1086:      DBG_log(\"Although local policy is tunnel, received USE_TRANSPORT_MODE\");",
          "1087:      DBG_log(\"So switching to transport mode, and responding with USE_TRANSPORT_MODE notify\");",
          "",
          "[Removed Lines]",
          "1084:     if (st1->st_connection->policy &",
          "",
          "[Added Lines]",
          "983:     if (cst->st_connection->policy &",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "1094:     if (!ship_v2N(ISAKMP_NEXT_v2NONE,",
          "1100:      return STF_INTERNAL_ERROR;",
          "1104:       ENCAPSULATION_MODE_TRANSPORT;",
          "1105:     }",
          "1108:       ENCAPSULATION_MODE_TRANSPORT;",
          "1109:     }",
          "1110:     break;",
          "",
          "[Removed Lines]",
          "1095:       ISAKMP_PAYLOAD_NONCRITICAL,",
          "1096:              PROTO_v2_RESERVED,",
          "1097:       &empty_chunk,",
          "1098:       v2N_USE_TRANSPORT_MODE, &empty_chunk,",
          "1099:       outpbs))",
          "1102:     if (st1->st_esp.present) {",
          "1103:      st1->st_esp.attrs.encapsulation =",
          "1106:     if (st1->st_ah.present) {",
          "1107:      st1->st_ah.attrs.encapsulation =",
          "",
          "[Added Lines]",
          "994:            ISAKMP_PAYLOAD_NONCRITICAL,",
          "995:            PROTO_v2_RESERVED,",
          "996:            &empty_chunk,",
          "997:            v2N_USE_TRANSPORT_MODE,",
          "998:            &empty_chunk,",
          "999:            outpbs))",
          "1002:     if (cst->st_esp.present) {",
          "1003:      cst->st_esp.attrs.encapsulation =",
          "1006:     if (cst->st_ah.present) {",
          "1007:      cst->st_ah.attrs.encapsulation =",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "1112:   }",
          "1113:  }",
          "1118:   return STF_FATAL;",
          "1123:  return STF_OK;",
          "1124: }",
          "",
          "[Removed Lines]",
          "1115:  ikev2_derive_child_keys(st1, role);",
          "1117:  if (!install_ipsec_sa(st1, TRUE))",
          "1121:  st1->st_connection->newest_ipsec_sa = st1->st_serialno;",
          "",
          "[Added Lines]",
          "1015:  ikev2_derive_child_keys(cst, role);",
          "1018:  if (!install_ipsec_sa(cst, TRUE))",
          "1022:  cst->st_connection->newest_ipsec_sa = cst->st_serialno;",
          "",
          "---------------"
        ],
        "programs/pluto/ikev2_parent.c||programs/pluto/ikev2_parent.c": [
          "File: programs/pluto/ikev2_parent.c -> programs/pluto/ikev2_parent.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "232:   ke->ke_md->st = st;",
          "233:   set_suspended(st, ke->ke_md);",
          "235:   if (!st->st_sec_in_use) {",
          "236:    pcrc_init(&ke->ke_pcrc, ikev2_parent_outI1_continue);",
          "238:          importance);",
          "239:   } else {",
          "",
          "[Removed Lines]",
          "237:    e = build_ke(&ke->ke_pcrc, st, st->st_oakley.group,",
          "",
          "[Added Lines]",
          "240:   pexpect(!st->st_sec_in_use);",
          "243:    e = build_ke_and_nonce(&ke->ke_pcrc, st, st->st_oakley.group,",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "302:          const struct pluto_crypto_req *r,",
          "303:          chunk_t *g)",
          "304: {",
          "305:  const struct pcr_kenonce *kn = &r->pcr_d.kn;",
          "308:  return kn->oakley_group;",
          "309: }",
          "315: static bool justship_v2KE(struct state *st UNUSED,",
          "318: {",
          "319:  struct ikev2_ke v2ke;",
          "320:  pb_stream kepbs;",
          "",
          "[Removed Lines]",
          "301: static int unpack_v2KE(struct state *st,",
          "307:  unpack_KE(st, r, g);",
          "316:      chunk_t *g, unsigned int oakley_group,",
          "317:      pb_stream *outs, u_int8_t np)",
          "",
          "[Added Lines]",
          "307: static enum ike_trans_type_dh unpack_v2KE_from_helper(struct state *st,",
          "313:  unpack_KE_from_helper(st, r, g);",
          "322:      chunk_t *g,",
          "323:      enum ike_trans_type_dh oakley_group,",
          "324:      pb_stream *outs,",
          "325:      u_int8_t np)",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "337:         chunk_t *g,",
          "338:         pb_stream *outs, u_int8_t np)",
          "339: {",
          "342:  return justship_v2KE(st, g, oakley_group, outs, np);",
          "343: }",
          "",
          "[Removed Lines]",
          "340:  int oakley_group = unpack_v2KE(st, r, g);",
          "",
          "[Added Lines]",
          "348:  enum ike_trans_type_dh oakley_group = unpack_v2KE_from_helper(st, r, g);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "359:  unpack_nonce(&st->st_ni, r);",
          "360:  return ikev2_parent_outI1_common(md, st);",
          "361: }",
          "",
          "[Removed Lines]",
          "358:  unpack_v2KE(st, r, &st->st_gi);",
          "",
          "[Added Lines]",
          "366:  unpack_v2KE_from_helper(st, r, &st->st_gi);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "598:     return STF_IGNORE;",
          "599:    }",
          "600:    DBG(DBG_CONTROLMORE, DBG_log(",
          "602:   } else {",
          "604:    DBG(DBG_CONTROLMORE,",
          "",
          "[Removed Lines]",
          "601:     \"dcookie received match with computed one\"));",
          "",
          "[Added Lines]",
          "609:     \"dcookie received matched computed one\"));",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "747:  {",
          "767:   st->st_oakley.group = lookup_group(ke->isak_group);",
          "768:   if (st->st_oakley.group == NULL) {",
          "",
          "[Removed Lines]",
          "748:   struct ikev2_ke *ke;",
          "750:   if (!md->chain[ISAKMP_NEXT_v2KE]) {",
          "751:    ipstr_buf b;",
          "754:    if (md->chain[ISAKMP_NEXT_v2N]) {",
          "755:     libreswan_log(\"Received Notify(%d): %s\",",
          "756:      md->chain[ISAKMP_NEXT_v2N]->payload.v2n.isan_type,",
          "757:      enum_name(&ikev2_notify_names,",
          "758:       md->chain[ISAKMP_NEXT_v2N]->payload.v2n.isan_type));",
          "759:    }",
          "760:    libreswan_log(",
          "761:     \"rejecting I1 from %s:%u, no KE payload present\",",
          "762:     ipstr(&md->sender, &b), md->sender_port);",
          "763:    return STF_FAIL + v2N_INVALID_KE_PAYLOAD;",
          "764:   }",
          "765:   ke = &md->chain[ISAKMP_NEXT_v2KE]->payload.v2ke;",
          "",
          "[Added Lines]",
          "758:   struct ikev2_ke *ke = &md->chain[ISAKMP_NEXT_v2KE]->payload.v2ke;",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "789:   stf_status e;",
          "791:   ke->ke_md = md;",
          "794:   if (!st->st_sec_in_use) {",
          "796:    pcrc_init(&ke->ke_pcrc, ikev2_parent_inI1outR1_continue);",
          "798:          pcim_stranger_crypto);",
          "799:   } else {",
          "",
          "[Removed Lines]",
          "792:   set_suspended(st, ke->ke_md);",
          "797:    e = build_ke(&ke->ke_pcrc, st, st->st_oakley.group,",
          "",
          "[Added Lines]",
          "787:   set_suspended(st, md);",
          "794:   pexpect(!st->st_sec_in_use);",
          "798:    e = build_ke_and_nonce(&ke->ke_pcrc, st, st->st_oakley.group,",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "1548:  insert_state(st);",
          "1549:  md->st = st;",
          "",
          "[Removed Lines]",
          "1550:  md->pst = pst;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "1815:  DBG(DBG_CONTROLMORE,",
          "1816:      DBG_log(\"ikev2 parent inI2outR2: calculating g^{xy} in order to decrypt I2\"));",
          "1826:  return start_dh_v2(md, \"ikev2_inI2outR2 KE\", O_RESPONDER,",
          "1827:   ikev2_parent_inI2outR2_continue);",
          "",
          "[Removed Lines]",
          "1819:  if (!md->chain[ISAKMP_NEXT_v2E]) {",
          "1820:   libreswan_log(\"R2 state should receive an encrypted payload\");",
          "1822:   return STF_FATAL;",
          "1823:  }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "1910:    return ret;",
          "1911:  }",
          "1920:  if (!ikev2_decode_peer_id(md, O_RESPONDER))",
          "1921:   return STF_FAIL + v2N_AUTHENTICATION_FAILED;",
          "1923:  {",
          "1924:   struct hmac_ctx id_ctx;",
          "1925:   const pb_stream *id_pbs = &md->chain[ISAKMP_NEXT_v2IDi]->pbs;",
          "1929:   hmac_init(&id_ctx, st->st_oakley.prf_hasher,",
          "1930:     st->st_skey_pi_nss);",
          "",
          "[Removed Lines]",
          "1915:  if (!md->chain[ISAKMP_NEXT_v2AUTH]) {",
          "1916:   libreswan_log(\"no authentication payload found\");",
          "1917:   return STF_FAIL;",
          "1918:  }",
          "1926:   unsigned char *idstart = id_pbs->start + 4;",
          "1927:   unsigned int idlen  = pbs_room(id_pbs) - 4;",
          "",
          "[Added Lines]",
          "1911:   unsigned char *idstart = id_pbs->start + NSIZEOF_isakmp_generic;",
          "1912:   unsigned int idlen = pbs_room(id_pbs) - NSIZEOF_isakmp_generic;",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "1940:  {",
          "",
          "[Removed Lines]",
          "1941:   if (md->chain[ISAKMP_NEXT_v2CERT]) {",
          "",
          "[Added Lines]",
          "1926:   if (md->chain[ISAKMP_NEXT_v2CERT] != NULL) {",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "1949:  }",
          "1953:   DBG(DBG_CONTROLMORE,",
          "1955:   ikev2_decode_cr(md, &st->st_connection->requested_ca);",
          "1956:  }",
          "",
          "[Removed Lines]",
          "1952:  if (md->chain[ISAKMP_NEXT_v2CERTREQ]) {",
          "1954:       DBG_log(\"has a v2CERTREQ payload going to decode it\"));",
          "",
          "[Added Lines]",
          "1937:  if (md->chain[ISAKMP_NEXT_v2CERTREQ] != NULL) {",
          "1939:       DBG_log(\"has a v2CERTREQ payload; going to decode it\"));",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "1960:  switch (md->chain[ISAKMP_NEXT_v2AUTH]->payload.v2a.isaa_type) {",
          "1961:  case IKEv2_AUTH_RSA:",
          "1962:  {",
          "1970:   if (authstat != STF_OK) {",
          "1971:    libreswan_log(\"RSA authentication failed\");",
          "1972:    SEND_NOTIFICATION(v2N_AUTHENTICATION_FAILED);",
          "1973:    return STF_FATAL;",
          "1974:   }",
          "",
          "[Removed Lines]",
          "1963:   stf_status authstat = ikev2_verify_rsa_sha1(st,",
          "1964:            O_RESPONDER,",
          "1965:            idhash_in,",
          "1968:            &md->chain[",
          "1969:             ISAKMP_NEXT_v2AUTH]->pbs);",
          "",
          "[Added Lines]",
          "1948:   stf_status authstat = ikev2_verify_rsa_sha1(",
          "1949:     st,",
          "1950:     O_RESPONDER,",
          "1951:     idhash_in,",
          "1954:     &md->chain[ISAKMP_NEXT_v2AUTH]->pbs);",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "1976:  }",
          "1977:  case IKEv2_AUTH_PSK:",
          "1978:  {",
          "1984:   if (authstat != STF_OK) {",
          "1985:    libreswan_log(",
          "1986:     \"PSK authentication failed AUTH mismatch!\");",
          "1987:    SEND_NOTIFICATION(v2N_AUTHENTICATION_FAILED);",
          "1988:    return STF_FATAL;",
          "1989:   }",
          "",
          "[Removed Lines]",
          "1979:   stf_status authstat = ikev2_verify_psk_auth(st,",
          "1980:            O_RESPONDER,",
          "1981:            idhash_in,",
          "1982:            &md->chain[",
          "1983:             ISAKMP_NEXT_v2AUTH]->pbs);",
          "",
          "[Added Lines]",
          "1972:   stf_status authstat = ikev2_verify_psk_auth(",
          "1973:     st,",
          "1974:     O_RESPONDER,",
          "1975:     idhash_in,",
          "1976:     &md->chain[ISAKMP_NEXT_v2AUTH]->pbs);",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "2266:  {",
          "2267:   struct hmac_ctx id_ctx;",
          "2268:   const pb_stream *id_pbs = &md->chain[ISAKMP_NEXT_v2IDr]->pbs;",
          "2272:   hmac_init(&id_ctx, pst->st_oakley.prf_hasher,",
          "2273:     pst->st_skey_pr_nss);",
          "",
          "[Removed Lines]",
          "2269:   unsigned char *idstart = id_pbs->start + 4;",
          "2270:   unsigned int idlen  = pbs_room(id_pbs) - 4;",
          "",
          "[Added Lines]",
          "2271:   unsigned char *idstart = id_pbs->start + NSIZEOF_isakmp_generic;",
          "2272:   unsigned int idlen = pbs_room(id_pbs) - NSIZEOF_isakmp_generic;",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "2279:   hmac_final(idhash_in, &id_ctx);",
          "2280:  }",
          "2286:   DBG(DBG_CONTROLMORE,",
          "2288:   ikev2_decode_cert(md);",
          "2289:  }",
          "2298:  switch (md->chain[ISAKMP_NEXT_v2AUTH]->payload.v2a.isaa_type) {",
          "2299:  case IKEv2_AUTH_RSA:",
          "2300:  {",
          "2309:   if (authstat != STF_OK) {",
          "2311:    SEND_NOTIFICATION(v2N_AUTHENTICATION_FAILED);",
          "2312:    return STF_FAIL;",
          "2313:   }",
          "",
          "[Removed Lines]",
          "2282:  if (md->chain[ISAKMP_NEXT_v2CERT]) {",
          "2287:       DBG_log(\"has a v2_CERT payload going to decode it\"));",
          "2292:  if (!md->chain[ISAKMP_NEXT_v2AUTH]) {",
          "2293:   libreswan_log(\"no authentication payload found\");",
          "2294:   return STF_FAIL;",
          "2295:  }",
          "2301:   stf_status authstat = ikev2_verify_rsa_sha1(pst,",
          "2302:            O_INITIATOR,",
          "2303:            idhash_in,",
          "2306:            &md->chain[",
          "2307:             ISAKMP_NEXT_v2AUTH]->pbs);",
          "2310:    libreswan_log(\"authentication failed\");",
          "",
          "[Added Lines]",
          "2284:  if (md->chain[ISAKMP_NEXT_v2CERT] != NULL) {",
          "2289:       DBG_log(\"has a v2_CERT payload; going to decode it\"));",
          "2298:   stf_status authstat = ikev2_verify_rsa_sha1(",
          "2299:     pst,",
          "2300:     O_INITIATOR,",
          "2301:     idhash_in,",
          "2304:     &md->chain[ISAKMP_NEXT_v2AUTH]->pbs);",
          "2307:    libreswan_log(\"RSA authentication failed\");",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "2315:  }",
          "2316:  case IKEv2_AUTH_PSK:",
          "2317:  {",
          "2324:   if (authstat != STF_OK) {",
          "2325:    libreswan_log(\"PSK authentication failed\");",
          "2326:    SEND_NOTIFICATION(v2N_AUTHENTICATION_FAILED);",
          "2327:    return STF_FAIL;",
          "2328:   }",
          "",
          "[Removed Lines]",
          "2318:   stf_status authstat = ikev2_verify_psk_auth(pst,",
          "2319:            O_INITIATOR,",
          "2320:            idhash_in,",
          "2321:            &md->chain[",
          "2322:             ISAKMP_NEXT_v2AUTH]->pbs);",
          "",
          "[Added Lines]",
          "2322:   stf_status authstat = ikev2_verify_psk_auth(",
          "2323:     pst,",
          "2324:     O_INITIATOR,",
          "2325:     idhash_in,",
          "2326:     &md->chain[ISAKMP_NEXT_v2AUTH]->pbs);",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "2354:  if (md->chain[ISAKMP_NEXT_v2SA] == NULL ||",
          "2355:      md->chain[ISAKMP_NEXT_v2TSi] == NULL ||",
          "2356:      md->chain[ISAKMP_NEXT_v2TSr] == NULL) {",
          "2362:   delete_event(st);",
          "2363:   return STF_FAIL + v2N_NO_PROPOSAL_CHOSEN;",
          "2364:  }",
          "2366:  {",
          "2367:   int bestfit_n, bestfit_p, bestfit_pr;",
          "2369:   bestfit_n = -1;",
          "2370:   bestfit_p = -1;",
          "2371:   bestfit_pr = -1;",
          "",
          "[Removed Lines]",
          "2358:       libreswan_log(\"no v2SA, v2TSi or v2TSr received, not attempting to setup child SA\");",
          "2368:   unsigned int best_tsi_i,  best_tsr_i;",
          "",
          "[Added Lines]",
          "2367:   libreswan_log(\"missing v2SA, v2TSi or v2TSr: not attempting to setup child SA\");",
          "2382:   int best_tsi_i,  best_tsr_i;",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "2384:   ip_subnet tsi_subnet, tsr_subnet;",
          "2385:   const char *oops;",
          "2386: #endif",
          "2391:   DBG(DBG_CONTROLMORE, DBG_log(\"Checking TSi(%d)/TSr(%d) selectors, looking for exact match\",",
          "2392:    tsi_n, tsr_n));",
          "",
          "[Removed Lines]",
          "2387:   unsigned int tsi_n, tsr_n;",
          "2388:   tsi_n = ikev2_parse_ts(tsi_pd, tsi, 16);",
          "2389:   tsr_n = ikev2_parse_ts(tsr_pd, tsr, 16);",
          "",
          "[Added Lines]",
          "2401:   const int tsi_n = ikev2_parse_ts(tsi_pd, tsi, elemsof(tsi));",
          "2402:   const int tsr_n = ikev2_parse_ts(tsr_pd, tsr, elemsof(tsr));",
          "2404:   if (tsi_n < 0 || tsr_n < 0)",
          "2405:    return STF_FAIL + v2N_TS_UNACCEPTABLE;",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "2405:          c->name));",
          "2406:     int bfit_p =",
          "2407:      ikev2_evaluate_connection_port_fit(",
          "2411:     if (bfit_p > bestfit_p) {",
          "2412:      DBG(DBG_CONTROLMORE,",
          "2413:          DBG_log(\"ikev2_evaluate_connection_port_fit found better fit c %s, tsi[%d],tsr[%d]\",",
          "",
          "[Removed Lines]",
          "2408:       c, sra, O_INITIATOR, tsi, tsr,",
          "2409:       tsi_n, tsr_n, &best_tsi_i,",
          "2410:       &best_tsr_i);",
          "",
          "[Added Lines]",
          "2424:       c, sra, O_INITIATOR,",
          "2425:       tsi, tsr,",
          "2426:       tsi_n, tsr_n,",
          "2427:       &best_tsi_i, &best_tsr_i);",
          "",
          "---------------",
          "--- Hunk 21 ---",
          "[Context before]",
          "2520:             p->payload.v2n.isan_type;",
          "2521:    }",
          "2528:      DBG(DBG_CONTROLMORE,",
          "2529:          DBG_log(\"Initiator policy is tunnel, responder sends v2N_USE_TRANSPORT_MODE notification in inR2, ignoring it\"));",
          "",
          "[Removed Lines]",
          "2523:    if ( p->payload.v2n.isan_type ==",
          "2524:         v2N_USE_TRANSPORT_MODE ) {",
          "2525:     if (st->st_connection->policy &",
          "2526:          POLICY_TUNNEL) {",
          "",
          "[Added Lines]",
          "2541:    if (p->payload.v2n.isan_type ==",
          "2542:        v2N_USE_TRANSPORT_MODE ) {",
          "2543:     if (st->st_connection->policy & POLICY_TUNNEL) {",
          "",
          "---------------",
          "--- Hunk 22 ---",
          "[Context before]",
          "3286:    if (md->hdr.isa_flags & ISAKMP_FLAGS_MSG_R) {",
          "3287:     if (st->st_state == STATE_IKESA_DEL) {",
          "3292:      delete_my_family(st, TRUE);",
          "3293:     } else {",
          "3294:      DBG(DBG_CONTROLMORE,",
          "3297:      st->st_last_liveness = mononow();",
          "3298:      st->st_pend_liveness = FALSE;",
          "3299:      ikev2_update_counters(md);",
          "",
          "[Removed Lines]",
          "3295:          DBG_log(\"Received an INFORMATIONAL response, \"",
          "3296:           \"updating liveness, no longer pending.\"));",
          "",
          "[Added Lines]",
          "3313:          DBG_log(\"Received an INFORMATIONAL response; updating liveness, no longer pending.\"));",
          "",
          "---------------",
          "--- Hunk 23 ---",
          "[Context before]",
          "3336:   pb_stream reply_stream;",
          "3338:   md.st = st;",
          "3340:   zero(&buffer);",
          "3341:   init_pbs(&reply_stream, buffer, sizeof(buffer),",
          "3342:     \"informational exchange request packet\");",
          "",
          "[Removed Lines]",
          "3339:   md.pst = pst;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 24 ---",
          "[Context before]",
          "3468:   enum phase1_role role;",
          "3470:   md.st = st;",
          "3474:   zero(&reply_buffer);",
          "",
          "[Removed Lines]",
          "3471:   md.pst = pst;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 25 ---",
          "[Context before]",
          "3651: static int build_ike_version()",
          "3652: {",
          "3656: }",
          "",
          "[Removed Lines]",
          "3653: return ((IKEv2_MAJOR_VERSION + (DBGP(IMPAIR_MAJOR_VERSION_BUMP) ? 1 : 0))",
          "3654:  << ISA_MAJ_SHIFT) | (IKEv2_MINOR_VERSION +",
          "3655:  (DBGP(IMPAIR_MINOR_VERSION_BUMP) ? 1 : 0));",
          "",
          "[Added Lines]",
          "3671:  return ((IKEv2_MAJOR_VERSION + (DBGP(IMPAIR_MAJOR_VERSION_BUMP) ? 1 : 0))",
          "3672:    << ISA_MAJ_SHIFT) |",
          "3673:   (IKEv2_MINOR_VERSION + (DBGP(IMPAIR_MINOR_VERSION_BUMP) ? 1 : 0));",
          "",
          "---------------"
        ],
        "programs/pluto/ipsec_doi.c||programs/pluto/ipsec_doi.c": [
          "File: programs/pluto/ipsec_doi.c -> programs/pluto/ipsec_doi.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "117: }",
          "125: {",
          "126:  const struct pcr_kenonce *kn = &r->pcr_d.kn;",
          "128:  if (!st->st_sec_in_use) {",
          "129:   st->st_sec_in_use = TRUE;",
          "",
          "[Removed Lines]",
          "122: void unpack_KE(struct state *st,",
          "123:         const struct pluto_crypto_req *r,",
          "124:         chunk_t *g)",
          "",
          "[Added Lines]",
          "122: void unpack_KE_from_helper(",
          "123:  struct state *st,",
          "124:  const struct pluto_crypto_req *r,",
          "125:  chunk_t *g)",
          "130:  pexpect(!st->st_sec_in_use);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "151:     const struct oakley_group_desc *gr,",
          "152:     pb_stream *pbs)",
          "153: {",
          "157:  if (pbs_left(pbs) != gr->bytes) {",
          "158:   loglog(RC_LOG_SERIOUS,",
          "159:          \"KE has %u byte DH public value; %u required\",",
          "",
          "[Removed Lines]",
          "155:  passert(pbs != NULL);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "programs/pluto/pluto_crypt.c||programs/pluto/pluto_crypt.c": [
          "File: programs/pluto/pluto_crypt.c -> programs/pluto/pluto_crypt.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "130: static const char *const pluto_cryptoop_strings[] = {",
          "136: };",
          "138: static enum_names pluto_cryptoop_names =",
          "",
          "[Removed Lines]",
          "139:  { pcr_build_kenonce, pcr_compute_dh_v2, pluto_cryptoop_strings, NULL };",
          "",
          "[Added Lines]",
          "139:  { pcr_build_ke_and_nonce, pcr_compute_dh_v2, pluto_cryptoop_strings, NULL };",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "193:  switch (r->pcr_type) {",
          "195:   calc_ke(r);",
          "199:  case pcr_build_nonce:",
          "200:   calc_nonce(r);",
          "201:   break;",
          "",
          "[Removed Lines]",
          "194:  case pcr_build_kenonce:",
          "196:   calc_nonce(r);",
          "197:   break;",
          "",
          "[Added Lines]",
          "194:  case pcr_build_ke_and_nonce:",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "670:   struct pluto_crypto_req_cont *cn;",
          "672:   for (cn = w->pcw_active.tqh_first; cn != NULL; cn = cn->pcrc_list.tqe_next) {",
          "674:      cn->pcrc_id, cn->pcrc_serialno,",
          "675:      w->pcw_dead ? \"dead \" : \"\", i);",
          "676:   }",
          "",
          "[Removed Lines]",
          "673:    libreswan_log(\"crypto queue: request ID%u for #%lu assigned to %scrypto helper %d\",",
          "",
          "[Added Lines]",
          "671:    libreswan_log(\"crypto queue: request ID %u for #%lu assigned to %scrypto helper %d\",",
          "",
          "---------------"
        ],
        "programs/pluto/pluto_crypt.h||programs/pluto/pluto_crypt.h": [
          "File: programs/pluto/pluto_crypt.h -> programs/pluto/pluto_crypt.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "320: extern void log_crypto_workers(void);",
          "324:       struct state *st,",
          "325:       const struct oakley_group_desc *group,",
          "326:       enum crypto_importance importance);",
          "",
          "[Removed Lines]",
          "323: extern stf_status build_ke(struct pluto_crypto_req_cont *cn,",
          "",
          "[Added Lines]",
          "322: extern stf_status build_ke_and_nonce(struct pluto_crypto_req_cont *cn,",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "364: extern void calc_dh(struct pluto_crypto_req *r);",
          "365: extern void calc_dh_v2(struct pluto_crypto_req *r);",
          "371: extern void pcr_nonce_init(struct pluto_crypto_req *r,",
          "372:        enum pluto_crypto_requests pcr_type,",
          "",
          "[Removed Lines]",
          "367: extern void unpack_KE(struct state *st,",
          "368:         const struct pluto_crypto_req *r,",
          "369:         chunk_t *g);",
          "",
          "[Added Lines]",
          "366: extern void unpack_KE_from_helper(",
          "367:  struct state *st,",
          "368:  const struct pluto_crypto_req *r,",
          "369:  chunk_t *g);",
          "",
          "---------------"
        ],
        "programs/pluto/spdb.c||programs/pluto/spdb.c": [
          "File: programs/pluto/spdb.c -> programs/pluto/spdb.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1392:    struct db_prop *pa = &pca->props[j];",
          "1393:    struct db_prop *pb = &pcb->props[j];",
          "1394:    struct db_trans *t;",
          "1397:    t = alloc_bytes(t_cnt * sizeof(pa->trans[0]),",
          "1398:      \"sa copy trans array\");",
          "1401:           sizeof(pa->trans[0]));",
          "1403:           pb->trans,",
          "1406:    pa->trans = t;",
          "1407:    pa->trans_cnt = t_cnt;",
          "",
          "[Removed Lines]",
          "1395:    int t_cnt = (pa->trans_cnt + pb->trans_cnt);",
          "1400:    memcpy(t, pa->trans, (pa->trans_cnt) *",
          "1402:    memcpy(t + (pa->trans_cnt),",
          "1404:           (pb->trans_cnt) * sizeof(pa->trans[0]));",
          "",
          "[Added Lines]",
          "1395:    int t_cnt = pa->trans_cnt + pb->trans_cnt;",
          "1400:    memcpy(t, pa->trans, pa->trans_cnt *",
          "1402:    memcpy(t + pa->trans_cnt,",
          "1404:           pb->trans_cnt * sizeof(pa->trans[0]));",
          "",
          "---------------"
        ],
        "programs/pluto/state.h||programs/pluto/state.h": [
          "File: programs/pluto/state.h -> programs/pluto/state.h"
        ],
        "testing/lib/libpluto/seam_crypt.c||testing/lilibpluto/seam_crypt.c": [
          "File: testing/lib/libpluto/seam_crypt.c -> testing/lilibpluto/seam_crypt.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "8: struct pluto_crypto_req rd;",
          "9: struct pluto_crypto_req *r = &rd;",
          "12:       struct state *st,",
          "13:       const struct oakley_group_desc *group,",
          "14:       enum crypto_importance importance)",
          "",
          "[Removed Lines]",
          "11: stf_status build_ke(struct pluto_crypto_req_cont *cn,",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "17:  zero(&rd);",
          "19:  r->pcr_len  = sizeof(struct pluto_crypto_req);",
          "21:  r->pcr_pcim = importance;",
          "24:  r->pcr_d.kn.oakley_group = group->group;",
          "26:  return STF_SUSPEND;",
          "",
          "[Removed Lines]",
          "20:  r->pcr_type = pcr_build_kenonce;",
          "23:  pcr_nonce_init(r, pcr_build_kenonce, importance);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    }
  ]
}
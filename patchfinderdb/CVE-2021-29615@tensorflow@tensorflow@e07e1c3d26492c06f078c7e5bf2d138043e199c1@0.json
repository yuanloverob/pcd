{
  "cve_id": "CVE-2021-29615",
  "cve_desc": "TensorFlow is an end-to-end open source platform for machine learning. The implementation of `ParseAttrValue`(https://github.com/tensorflow/tensorflow/blob/c22d88d6ff33031aa113e48aa3fc9aa74ed79595/tensorflow/core/framework/attr_value_util.cc#L397-L453) can be tricked into stack overflow due to recursion by giving in a specially crafted input. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
  "repo": "tensorflow/tensorflow",
  "patch_hash": "e07e1c3d26492c06f078c7e5bf2d138043e199c1",
  "patch_info": {
    "commit_hash": "e07e1c3d26492c06f078c7e5bf2d138043e199c1",
    "repo": "tensorflow/tensorflow",
    "commit_url": "https://github.com/tensorflow/tensorflow/commit/e07e1c3d26492c06f078c7e5bf2d138043e199c1",
    "files": [
      "tensorflow/core/framework/attr_value_util.cc"
    ],
    "message": "Prevent memory overflow in ParseAttrValue from nested tensors.\n\nPiperOrigin-RevId: 370108442\nChange-Id: I84d64a5e8895a6aeffbf4749841b4c54d51b5889",
    "before_after_code_files": [
      "tensorflow/core/framework/attr_value_util.cc||tensorflow/core/framework/attr_value_util.cc"
    ]
  },
  "patch_diff": {
    "tensorflow/core/framework/attr_value_util.cc||tensorflow/core/framework/attr_value_util.cc": [
      "File: tensorflow/core/framework/attr_value_util.cc -> tensorflow/core/framework/attr_value_util.cc",
      "--- Hunk 1 ---",
      "[Context before]",
      "39: constexpr int kMaxAttrValueTensorByteSize = 32 * 1024 * 1024;  // 32mb",
      "43: int64 TensorByteSize(const TensorProto& t) {",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "42: constexpr int kMaxTensorNestDepth = 100;",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "224:   return strings::StrCat(func.name(), \"[\", absl::StrJoin(entries, \", \"), \"]\");",
      "225: }",
      "227: }  // namespace",
      "229: string SummarizeAttrValue(const AttrValue& attr_value) {",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "230: bool ParseAttrValueHelper_TensorNestsUnderLimit(int limit, string to_parse) {",
      "231:   int nests = 0;",
      "232:   int maxed_out = to_parse.length();",
      "233:   int open_curly = to_parse.find('{');",
      "234:   int open_bracket = to_parse.find('<');",
      "235:   int close_curly = to_parse.find('}');",
      "236:   int close_bracket = to_parse.find('>');",
      "237:   if (open_curly == -1) {",
      "238:     open_curly = maxed_out;",
      "239:   }",
      "240:   if (open_bracket == -1) {",
      "241:     open_bracket = maxed_out;",
      "242:   }",
      "243:   int min = std::min(open_curly, open_bracket);",
      "244:   do {",
      "245:     if (open_curly == maxed_out && open_bracket == maxed_out) {",
      "246:       return true;",
      "247:     }",
      "248:     if (min == open_curly) {",
      "249:       nests += 1;",
      "250:       open_curly = to_parse.find('{', open_curly + 1);",
      "251:       if (open_curly == -1) {",
      "252:         open_curly = maxed_out;",
      "253:       }",
      "254:     } else if (min == open_bracket) {",
      "255:       nests += 1;",
      "256:       open_bracket = to_parse.find('<', open_bracket + 1);",
      "257:       if (open_bracket == -1) {",
      "258:         open_bracket = maxed_out;",
      "259:       }",
      "260:     } else if (min == close_curly) {",
      "261:       nests -= 1;",
      "262:       close_curly = to_parse.find('}', close_curly + 1);",
      "263:       if (close_curly == -1) {",
      "264:         close_curly = maxed_out;",
      "265:       }",
      "266:     } else if (min == close_bracket) {",
      "267:       nests -= 1;",
      "268:       close_bracket = to_parse.find('>', close_bracket + 1);",
      "269:       if (close_bracket == -1) {",
      "270:         close_bracket = maxed_out;",
      "271:       }",
      "272:     }",
      "273:     min = std::min({open_curly, open_bracket, close_curly, close_bracket});",
      "274:   } while (nests < 100);",
      "275:   return false;",
      "276: }",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "448:   } else {",
      "449:     to_parse = strings::StrCat(field_name, \": \", text);",
      "450:   }",
      "452:   return ProtoParseFromString(to_parse, out);",
      "453: }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "502:   if (field_name == \"tensor\") {",
      "503:     if (!ParseAttrValueHelper_TensorNestsUnderLimit(kMaxTensorNestDepth,",
      "504:                                                     to_parse)) {",
      "505:       return false;",
      "506:     }",
      "507:   }",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "74f34ad0731f9c6a2defe198c9904a00d5d93903",
      "candidate_info": {
        "commit_hash": "74f34ad0731f9c6a2defe198c9904a00d5d93903",
        "repo": "tensorflow/tensorflow",
        "commit_url": "https://github.com/tensorflow/tensorflow/commit/74f34ad0731f9c6a2defe198c9904a00d5d93903",
        "files": [
          "tensorflow/core/framework/attr_value_util.cc"
        ],
        "message": "Prevent memory overflow in ParseAttrValue from nested tensors.\n\nPiperOrigin-RevId: 370108442\nChange-Id: I84d64a5e8895a6aeffbf4749841b4c54d51b5889",
        "before_after_code_files": [
          "tensorflow/core/framework/attr_value_util.cc||tensorflow/core/framework/attr_value_util.cc"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "tensorflow/core/framework/attr_value_util.cc||tensorflow/core/framework/attr_value_util.cc"
          ],
          "candidate": [
            "tensorflow/core/framework/attr_value_util.cc||tensorflow/core/framework/attr_value_util.cc"
          ]
        }
      },
      "candidate_diff": {
        "tensorflow/core/framework/attr_value_util.cc||tensorflow/core/framework/attr_value_util.cc": [
          "File: tensorflow/core/framework/attr_value_util.cc -> tensorflow/core/framework/attr_value_util.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "39: constexpr int kMaxAttrValueTensorByteSize = 32 * 1024 * 1024;  // 32mb",
          "43: int64 TensorByteSize(const TensorProto& t) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "42: constexpr int kMaxTensorNestDepth = 100;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "224:   return strings::StrCat(func.name(), \"[\", absl::StrJoin(entries, \", \"), \"]\");",
          "225: }",
          "227: }  // namespace",
          "229: string SummarizeAttrValue(const AttrValue& attr_value) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "230: bool ParseAttrValueHelper_TensorNestsUnderLimit(int limit, string to_parse) {",
          "231:   int nests = 0;",
          "232:   int maxed_out = to_parse.length();",
          "233:   int open_curly = to_parse.find('{');",
          "234:   int open_bracket = to_parse.find('<');",
          "235:   int close_curly = to_parse.find('}');",
          "236:   int close_bracket = to_parse.find('>');",
          "237:   if (open_curly == -1) {",
          "238:     open_curly = maxed_out;",
          "239:   }",
          "240:   if (open_bracket == -1) {",
          "241:     open_bracket = maxed_out;",
          "242:   }",
          "243:   int min = std::min(open_curly, open_bracket);",
          "244:   do {",
          "245:     if (open_curly == maxed_out && open_bracket == maxed_out) {",
          "246:       return true;",
          "247:     }",
          "248:     if (min == open_curly) {",
          "249:       nests += 1;",
          "250:       open_curly = to_parse.find('{', open_curly + 1);",
          "251:       if (open_curly == -1) {",
          "252:         open_curly = maxed_out;",
          "253:       }",
          "254:     } else if (min == open_bracket) {",
          "255:       nests += 1;",
          "256:       open_bracket = to_parse.find('<', open_bracket + 1);",
          "257:       if (open_bracket == -1) {",
          "258:         open_bracket = maxed_out;",
          "259:       }",
          "260:     } else if (min == close_curly) {",
          "261:       nests -= 1;",
          "262:       close_curly = to_parse.find('}', close_curly + 1);",
          "263:       if (close_curly == -1) {",
          "264:         close_curly = maxed_out;",
          "265:       }",
          "266:     } else if (min == close_bracket) {",
          "267:       nests -= 1;",
          "268:       close_bracket = to_parse.find('>', close_bracket + 1);",
          "269:       if (close_bracket == -1) {",
          "270:         close_bracket = maxed_out;",
          "271:       }",
          "272:     }",
          "273:     min = std::min({open_curly, open_bracket, close_curly, close_bracket});",
          "274:   } while (nests < 100);",
          "275:   return false;",
          "276: }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "448:   } else {",
          "449:     to_parse = strings::StrCat(field_name, \": \", text);",
          "450:   }",
          "452:   return ProtoParseFromString(to_parse, out);",
          "453: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "502:   if (field_name == \"tensor\") {",
          "503:     if (!ParseAttrValueHelper_TensorNestsUnderLimit(kMaxTensorNestDepth,",
          "504:                                                     to_parse)) {",
          "505:       return false;",
          "506:     }",
          "507:   }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "fee1f4ec02e7a2b52e5fb43541244782a45b6ee2",
      "candidate_info": {
        "commit_hash": "fee1f4ec02e7a2b52e5fb43541244782a45b6ee2",
        "repo": "tensorflow/tensorflow",
        "commit_url": "https://github.com/tensorflow/tensorflow/commit/fee1f4ec02e7a2b52e5fb43541244782a45b6ee2",
        "files": [
          "tensorflow/core/framework/attr_value_util.cc"
        ],
        "message": "Prevent memory overflow in ParseAttrValue from nested tensors.\n\nPiperOrigin-RevId: 370108442\nChange-Id: I84d64a5e8895a6aeffbf4749841b4c54d51b5889",
        "before_after_code_files": [
          "tensorflow/core/framework/attr_value_util.cc||tensorflow/core/framework/attr_value_util.cc"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "tensorflow/core/framework/attr_value_util.cc||tensorflow/core/framework/attr_value_util.cc"
          ],
          "candidate": [
            "tensorflow/core/framework/attr_value_util.cc||tensorflow/core/framework/attr_value_util.cc"
          ]
        }
      },
      "candidate_diff": {
        "tensorflow/core/framework/attr_value_util.cc||tensorflow/core/framework/attr_value_util.cc": [
          "File: tensorflow/core/framework/attr_value_util.cc -> tensorflow/core/framework/attr_value_util.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "39: constexpr int kMaxAttrValueTensorByteSize = 32 * 1024 * 1024;  // 32mb",
          "43: int64 TensorByteSize(const TensorProto& t) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "42: constexpr int kMaxTensorNestDepth = 100;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "224:   return strings::StrCat(func.name(), \"[\", absl::StrJoin(entries, \", \"), \"]\");",
          "225: }",
          "227: }  // namespace",
          "229: string SummarizeAttrValue(const AttrValue& attr_value) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "230: bool ParseAttrValueHelper_TensorNestsUnderLimit(int limit, string to_parse) {",
          "231:   int nests = 0;",
          "232:   int maxed_out = to_parse.length();",
          "233:   int open_curly = to_parse.find('{');",
          "234:   int open_bracket = to_parse.find('<');",
          "235:   int close_curly = to_parse.find('}');",
          "236:   int close_bracket = to_parse.find('>');",
          "237:   if (open_curly == -1) {",
          "238:     open_curly = maxed_out;",
          "239:   }",
          "240:   if (open_bracket == -1) {",
          "241:     open_bracket = maxed_out;",
          "242:   }",
          "243:   int min = std::min(open_curly, open_bracket);",
          "244:   do {",
          "245:     if (open_curly == maxed_out && open_bracket == maxed_out) {",
          "246:       return true;",
          "247:     }",
          "248:     if (min == open_curly) {",
          "249:       nests += 1;",
          "250:       open_curly = to_parse.find('{', open_curly + 1);",
          "251:       if (open_curly == -1) {",
          "252:         open_curly = maxed_out;",
          "253:       }",
          "254:     } else if (min == open_bracket) {",
          "255:       nests += 1;",
          "256:       open_bracket = to_parse.find('<', open_bracket + 1);",
          "257:       if (open_bracket == -1) {",
          "258:         open_bracket = maxed_out;",
          "259:       }",
          "260:     } else if (min == close_curly) {",
          "261:       nests -= 1;",
          "262:       close_curly = to_parse.find('}', close_curly + 1);",
          "263:       if (close_curly == -1) {",
          "264:         close_curly = maxed_out;",
          "265:       }",
          "266:     } else if (min == close_bracket) {",
          "267:       nests -= 1;",
          "268:       close_bracket = to_parse.find('>', close_bracket + 1);",
          "269:       if (close_bracket == -1) {",
          "270:         close_bracket = maxed_out;",
          "271:       }",
          "272:     }",
          "273:     min = std::min({open_curly, open_bracket, close_curly, close_bracket});",
          "274:   } while (nests < 100);",
          "275:   return false;",
          "276: }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "448:   } else {",
          "449:     to_parse = strings::StrCat(field_name, \": \", text);",
          "450:   }",
          "452:   return ProtoParseFromString(to_parse, out);",
          "453: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "502:   if (field_name == \"tensor\") {",
          "503:     if (!ParseAttrValueHelper_TensorNestsUnderLimit(kMaxTensorNestDepth,",
          "504:                                                     to_parse)) {",
          "505:       return false;",
          "506:     }",
          "507:   }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "270923c2a3eaea3cce3822b8f49eef55430fa20d",
      "candidate_info": {
        "commit_hash": "270923c2a3eaea3cce3822b8f49eef55430fa20d",
        "repo": "tensorflow/tensorflow",
        "commit_url": "https://github.com/tensorflow/tensorflow/commit/270923c2a3eaea3cce3822b8f49eef55430fa20d",
        "files": [
          "tensorflow/core/framework/attr_value_util.cc"
        ],
        "message": "Prevent memory overflow in ParseAttrValue from nested tensors.\n\nPiperOrigin-RevId: 370108442\nChange-Id: I84d64a5e8895a6aeffbf4749841b4c54d51b5889",
        "before_after_code_files": [
          "tensorflow/core/framework/attr_value_util.cc||tensorflow/core/framework/attr_value_util.cc"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "tensorflow/core/framework/attr_value_util.cc||tensorflow/core/framework/attr_value_util.cc"
          ],
          "candidate": [
            "tensorflow/core/framework/attr_value_util.cc||tensorflow/core/framework/attr_value_util.cc"
          ]
        }
      },
      "candidate_diff": {
        "tensorflow/core/framework/attr_value_util.cc||tensorflow/core/framework/attr_value_util.cc": [
          "File: tensorflow/core/framework/attr_value_util.cc -> tensorflow/core/framework/attr_value_util.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "39: constexpr int kMaxAttrValueTensorByteSize = 32 * 1024 * 1024;  // 32mb",
          "43: int64 TensorByteSize(const TensorProto& t) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "42: constexpr int kMaxTensorNestDepth = 100;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "224:   return strings::StrCat(func.name(), \"[\", absl::StrJoin(entries, \", \"), \"]\");",
          "225: }",
          "227: }  // namespace",
          "229: string SummarizeAttrValue(const AttrValue& attr_value) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "230: bool ParseAttrValueHelper_TensorNestsUnderLimit(int limit, string to_parse) {",
          "231:   int nests = 0;",
          "232:   int maxed_out = to_parse.length();",
          "233:   int open_curly = to_parse.find('{');",
          "234:   int open_bracket = to_parse.find('<');",
          "235:   int close_curly = to_parse.find('}');",
          "236:   int close_bracket = to_parse.find('>');",
          "237:   if (open_curly == -1) {",
          "238:     open_curly = maxed_out;",
          "239:   }",
          "240:   if (open_bracket == -1) {",
          "241:     open_bracket = maxed_out;",
          "242:   }",
          "243:   int min = std::min(open_curly, open_bracket);",
          "244:   do {",
          "245:     if (open_curly == maxed_out && open_bracket == maxed_out) {",
          "246:       return true;",
          "247:     }",
          "248:     if (min == open_curly) {",
          "249:       nests += 1;",
          "250:       open_curly = to_parse.find('{', open_curly + 1);",
          "251:       if (open_curly == -1) {",
          "252:         open_curly = maxed_out;",
          "253:       }",
          "254:     } else if (min == open_bracket) {",
          "255:       nests += 1;",
          "256:       open_bracket = to_parse.find('<', open_bracket + 1);",
          "257:       if (open_bracket == -1) {",
          "258:         open_bracket = maxed_out;",
          "259:       }",
          "260:     } else if (min == close_curly) {",
          "261:       nests -= 1;",
          "262:       close_curly = to_parse.find('}', close_curly + 1);",
          "263:       if (close_curly == -1) {",
          "264:         close_curly = maxed_out;",
          "265:       }",
          "266:     } else if (min == close_bracket) {",
          "267:       nests -= 1;",
          "268:       close_bracket = to_parse.find('>', close_bracket + 1);",
          "269:       if (close_bracket == -1) {",
          "270:         close_bracket = maxed_out;",
          "271:       }",
          "272:     }",
          "273:     min = std::min({open_curly, open_bracket, close_curly, close_bracket});",
          "274:   } while (nests < 100);",
          "275:   return false;",
          "276: }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "448:   } else {",
          "449:     to_parse = strings::StrCat(field_name, \": \", text);",
          "450:   }",
          "452:   return ProtoParseFromString(to_parse, out);",
          "453: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "502:   if (field_name == \"tensor\") {",
          "503:     if (!ParseAttrValueHelper_TensorNestsUnderLimit(kMaxTensorNestDepth,",
          "504:                                                     to_parse)) {",
          "505:       return false;",
          "506:     }",
          "507:   }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "190de93862b87ebff8b7be26bc5e65e03e8005e3",
      "candidate_info": {
        "commit_hash": "190de93862b87ebff8b7be26bc5e65e03e8005e3",
        "repo": "tensorflow/tensorflow",
        "commit_url": "https://github.com/tensorflow/tensorflow/commit/190de93862b87ebff8b7be26bc5e65e03e8005e3",
        "files": [
          "tensorflow/core/framework/attr_value_util.cc"
        ],
        "message": "Prevent memory overflow in ParseAttrValue from nested tensors.\n\nPiperOrigin-RevId: 370108442\nChange-Id: I84d64a5e8895a6aeffbf4749841b4c54d51b5889",
        "before_after_code_files": [
          "tensorflow/core/framework/attr_value_util.cc||tensorflow/core/framework/attr_value_util.cc"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "tensorflow/core/framework/attr_value_util.cc||tensorflow/core/framework/attr_value_util.cc"
          ],
          "candidate": [
            "tensorflow/core/framework/attr_value_util.cc||tensorflow/core/framework/attr_value_util.cc"
          ]
        }
      },
      "candidate_diff": {
        "tensorflow/core/framework/attr_value_util.cc||tensorflow/core/framework/attr_value_util.cc": [
          "File: tensorflow/core/framework/attr_value_util.cc -> tensorflow/core/framework/attr_value_util.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "39: constexpr int kMaxAttrValueTensorByteSize = 32 * 1024 * 1024;  // 32mb",
          "43: int64 TensorByteSize(const TensorProto& t) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "42: constexpr int kMaxTensorNestDepth = 100;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "224:   return strings::StrCat(func.name(), \"[\", absl::StrJoin(entries, \", \"), \"]\");",
          "225: }",
          "227: }  // namespace",
          "229: string SummarizeAttrValue(const AttrValue& attr_value) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "230: bool ParseAttrValueHelper_TensorNestsUnderLimit(int limit, string to_parse) {",
          "231:   int nests = 0;",
          "232:   int maxed_out = to_parse.length();",
          "233:   int open_curly = to_parse.find('{');",
          "234:   int open_bracket = to_parse.find('<');",
          "235:   int close_curly = to_parse.find('}');",
          "236:   int close_bracket = to_parse.find('>');",
          "237:   if (open_curly == -1) {",
          "238:     open_curly = maxed_out;",
          "239:   }",
          "240:   if (open_bracket == -1) {",
          "241:     open_bracket = maxed_out;",
          "242:   }",
          "243:   int min = std::min(open_curly, open_bracket);",
          "244:   do {",
          "245:     if (open_curly == maxed_out && open_bracket == maxed_out) {",
          "246:       return true;",
          "247:     }",
          "248:     if (min == open_curly) {",
          "249:       nests += 1;",
          "250:       open_curly = to_parse.find('{', open_curly + 1);",
          "251:       if (open_curly == -1) {",
          "252:         open_curly = maxed_out;",
          "253:       }",
          "254:     } else if (min == open_bracket) {",
          "255:       nests += 1;",
          "256:       open_bracket = to_parse.find('<', open_bracket + 1);",
          "257:       if (open_bracket == -1) {",
          "258:         open_bracket = maxed_out;",
          "259:       }",
          "260:     } else if (min == close_curly) {",
          "261:       nests -= 1;",
          "262:       close_curly = to_parse.find('}', close_curly + 1);",
          "263:       if (close_curly == -1) {",
          "264:         close_curly = maxed_out;",
          "265:       }",
          "266:     } else if (min == close_bracket) {",
          "267:       nests -= 1;",
          "268:       close_bracket = to_parse.find('>', close_bracket + 1);",
          "269:       if (close_bracket == -1) {",
          "270:         close_bracket = maxed_out;",
          "271:       }",
          "272:     }",
          "273:     min = std::min({open_curly, open_bracket, close_curly, close_bracket});",
          "274:   } while (nests < 100);",
          "275:   return false;",
          "276: }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "448:   } else {",
          "449:     to_parse = strings::StrCat(field_name, \": \", text);",
          "450:   }",
          "452:   return ProtoParseFromString(to_parse, out);",
          "453: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "502:   if (field_name == \"tensor\") {",
          "503:     if (!ParseAttrValueHelper_TensorNestsUnderLimit(kMaxTensorNestDepth,",
          "504:                                                     to_parse)) {",
          "505:       return false;",
          "506:     }",
          "507:   }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "809bd2e2bdb28fb20ee84303d95def152f3d1ea9",
      "candidate_info": {
        "commit_hash": "809bd2e2bdb28fb20ee84303d95def152f3d1ea9",
        "repo": "tensorflow/tensorflow",
        "commit_url": "https://github.com/tensorflow/tensorflow/commit/809bd2e2bdb28fb20ee84303d95def152f3d1ea9",
        "files": [
          "tensorflow/core/framework/attr_value_util.cc"
        ],
        "message": "Prevent memory overflow in ParseAttrValue from nested tensors.\n\nPiperOrigin-RevId: 370108442\nChange-Id: I84d64a5e8895a6aeffbf4749841b4c54d51b5889",
        "before_after_code_files": [
          "tensorflow/core/framework/attr_value_util.cc||tensorflow/core/framework/attr_value_util.cc"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "tensorflow/core/framework/attr_value_util.cc||tensorflow/core/framework/attr_value_util.cc"
          ],
          "candidate": [
            "tensorflow/core/framework/attr_value_util.cc||tensorflow/core/framework/attr_value_util.cc"
          ]
        }
      },
      "candidate_diff": {
        "tensorflow/core/framework/attr_value_util.cc||tensorflow/core/framework/attr_value_util.cc": [
          "File: tensorflow/core/framework/attr_value_util.cc -> tensorflow/core/framework/attr_value_util.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "39: constexpr int kMaxAttrValueTensorByteSize = 32 * 1024 * 1024;  // 32mb",
          "43: int64 TensorByteSize(const TensorProto& t) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "42: constexpr int kMaxTensorNestDepth = 100;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "224:   return strings::StrCat(func.name(), \"[\", absl::StrJoin(entries, \", \"), \"]\");",
          "225: }",
          "227: }  // namespace",
          "229: string SummarizeAttrValue(const AttrValue& attr_value) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "230: bool ParseAttrValueHelper_TensorNestsUnderLimit(int limit, string to_parse) {",
          "231:   int nests = 0;",
          "232:   int maxed_out = to_parse.length();",
          "233:   int open_curly = to_parse.find('{');",
          "234:   int open_bracket = to_parse.find('<');",
          "235:   int close_curly = to_parse.find('}');",
          "236:   int close_bracket = to_parse.find('>');",
          "237:   if (open_curly == -1) {",
          "238:     open_curly = maxed_out;",
          "239:   }",
          "240:   if (open_bracket == -1) {",
          "241:     open_bracket = maxed_out;",
          "242:   }",
          "243:   int min = std::min(open_curly, open_bracket);",
          "244:   do {",
          "245:     if (open_curly == maxed_out && open_bracket == maxed_out) {",
          "246:       return true;",
          "247:     }",
          "248:     if (min == open_curly) {",
          "249:       nests += 1;",
          "250:       open_curly = to_parse.find('{', open_curly + 1);",
          "251:       if (open_curly == -1) {",
          "252:         open_curly = maxed_out;",
          "253:       }",
          "254:     } else if (min == open_bracket) {",
          "255:       nests += 1;",
          "256:       open_bracket = to_parse.find('<', open_bracket + 1);",
          "257:       if (open_bracket == -1) {",
          "258:         open_bracket = maxed_out;",
          "259:       }",
          "260:     } else if (min == close_curly) {",
          "261:       nests -= 1;",
          "262:       close_curly = to_parse.find('}', close_curly + 1);",
          "263:       if (close_curly == -1) {",
          "264:         close_curly = maxed_out;",
          "265:       }",
          "266:     } else if (min == close_bracket) {",
          "267:       nests -= 1;",
          "268:       close_bracket = to_parse.find('>', close_bracket + 1);",
          "269:       if (close_bracket == -1) {",
          "270:         close_bracket = maxed_out;",
          "271:       }",
          "272:     }",
          "273:     min = std::min({open_curly, open_bracket, close_curly, close_bracket});",
          "274:   } while (nests < 100);",
          "275:   return false;",
          "276: }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "448:   } else {",
          "449:     to_parse = strings::StrCat(field_name, \": \", text);",
          "450:   }",
          "452:   return ProtoParseFromString(to_parse, out);",
          "453: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "502:   if (field_name == \"tensor\") {",
          "503:     if (!ParseAttrValueHelper_TensorNestsUnderLimit(kMaxTensorNestDepth,",
          "504:                                                     to_parse)) {",
          "505:       return false;",
          "506:     }",
          "507:   }",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2019-15538",
  "cve_desc": "An issue was discovered in xfs_setattr_nonsize in fs/xfs/xfs_iops.c in the Linux kernel through 5.2.9. XFS partially wedges when a chgrp fails on account of being out of disk quota. xfs_setattr_nonsize is failing to unlock the ILOCK after the xfs_qm_vop_chown_reserve call fails. This is primarily a local DoS attack vector, but it might result as well in remote DoS if the XFS filesystem is exported for instance via NFS.",
  "repo": "torvalds/linux",
  "patch_hash": "1fb254aa983bf190cfd685d40c64a480a9bafaee",
  "patch_info": {
    "commit_hash": "1fb254aa983bf190cfd685d40c64a480a9bafaee",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/1fb254aa983bf190cfd685d40c64a480a9bafaee",
    "files": [
      "fs/xfs/xfs_iops.c"
    ],
    "message": "xfs: fix missing ILOCK unlock when xfs_setattr_nonsize fails due to EDQUOT\n\nBenjamin Moody reported to Debian that XFS partially wedges when a chgrp\nfails on account of being out of disk quota.  I ran his reproducer\nscript:\n\n# adduser dummy\n# adduser dummy plugdev\n\n# dd if=/dev/zero bs=1M count=100 of=test.img\n# mkfs.xfs test.img\n# mount -t xfs -o gquota test.img /mnt\n# mkdir -p /mnt/dummy\n# chown -c dummy /mnt/dummy\n# xfs_quota -xc 'limit -g bsoft=100k bhard=100k plugdev' /mnt\n\n(and then as user dummy)\n\n$ dd if=/dev/urandom bs=1M count=50 of=/mnt/dummy/foo\n$ chgrp plugdev /mnt/dummy/foo\n\nand saw:\n\n================================================\nWARNING: lock held when returning to user space!\n5.3.0-rc5 #rc5 Tainted: G        W\n------------------------------------------------\nchgrp/47006 is leaving the kernel with locks still held!\n1 lock held by chgrp/47006:\n #0: 000000006664ea2d (&xfs_nondir_ilock_class){++++}, at: xfs_ilock+0xd2/0x290 [xfs]\n\n...which is clearly caused by xfs_setattr_nonsize failing to unlock the\nILOCK after the xfs_qm_vop_chown_reserve call fails.  Add the missing\nunlock.\n\nReported-by: benjamin.moody@gmail.com\nFixes: 253f4911f297 (\"xfs: better xfs_trans_alloc interface\")\nSigned-off-by: Darrick J. Wong <darrick.wong@oracle.com>\nReviewed-by: Dave Chinner <dchinner@redhat.com>\nTested-by: Salvatore Bonaccorso <carnil@debian.org>",
    "before_after_code_files": [
      "fs/xfs/xfs_iops.c||fs/xfs/xfs_iops.c"
    ]
  },
  "patch_diff": {
    "fs/xfs/xfs_iops.c||fs/xfs/xfs_iops.c": [
      "File: fs/xfs/xfs_iops.c -> fs/xfs/xfs_iops.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "794: out_cancel:",
      "795:  xfs_trans_cancel(tp);",
      "796: out_dqrele:",
      "797:  xfs_qm_dqrele(udqp);",
      "798:  xfs_qm_dqrele(gdqp);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "796:  xfs_iunlock(ip, XFS_ILOCK_EXCL);",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "af8a85a41734f37b67ba8ce69d56b685bee4ac48",
      "candidate_info": {
        "commit_hash": "af8a85a41734f37b67ba8ce69d56b685bee4ac48",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/af8a85a41734f37b67ba8ce69d56b685bee4ac48",
        "files": [
          "fs/ceph/inode.c"
        ],
        "message": "ceph: fix buffer free while holding i_ceph_lock in fill_inode()\n\nCalling ceph_buffer_put() in fill_inode() may result in freeing the\ni_xattrs.blob buffer while holding the i_ceph_lock.  This can be fixed by\npostponing the call until later, when the lock is released.\n\nThe following backtrace was triggered by fstests generic/070.\n\n  BUG: sleeping function called from invalid context at mm/vmalloc.c:2283\n  in_atomic(): 1, irqs_disabled(): 0, pid: 3852, name: kworker/0:4\n  6 locks held by kworker/0:4/3852:\n   #0: 000000004270f6bb ((wq_completion)ceph-msgr){+.+.}, at: process_one_work+0x1b8/0x5f0\n   #1: 00000000eb420803 ((work_completion)(&(&con->work)->work)){+.+.}, at: process_one_work+0x1b8/0x5f0\n   #2: 00000000be1c53a4 (&s->s_mutex){+.+.}, at: dispatch+0x288/0x1476\n   #3: 00000000559cb958 (&mdsc->snap_rwsem){++++}, at: dispatch+0x2eb/0x1476\n   #4: 000000000d5ebbae (&req->r_fill_mutex){+.+.}, at: dispatch+0x2fc/0x1476\n   #5: 00000000a83d0514 (&(&ci->i_ceph_lock)->rlock){+.+.}, at: fill_inode.isra.0+0xf8/0xf70\n  CPU: 0 PID: 3852 Comm: kworker/0:4 Not tainted 5.2.0+ #441\n  Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.12.1-0-ga5cab58-prebuilt.qemu.org 04/01/2014\n  Workqueue: ceph-msgr ceph_con_workfn\n  Call Trace:\n   dump_stack+0x67/0x90\n   ___might_sleep.cold+0x9f/0xb1\n   vfree+0x4b/0x60\n   ceph_buffer_release+0x1b/0x60\n   fill_inode.isra.0+0xa9b/0xf70\n   ceph_fill_trace+0x13b/0xc70\n   ? dispatch+0x2eb/0x1476\n   dispatch+0x320/0x1476\n   ? __mutex_unlock_slowpath+0x4d/0x2a0\n   ceph_con_workfn+0xc97/0x2ec0\n   ? process_one_work+0x1b8/0x5f0\n   process_one_work+0x244/0x5f0\n   worker_thread+0x4d/0x3e0\n   kthread+0x105/0x140\n   ? process_one_work+0x5f0/0x5f0\n   ? kthread_park+0x90/0x90\n   ret_from_fork+0x3a/0x50\n\nSigned-off-by: Luis Henriques <lhenriques@suse.com>\nReviewed-by: Jeff Layton <jlayton@kernel.org>\nSigned-off-by: Ilya Dryomov <idryomov@gmail.com>",
        "before_after_code_files": [
          "fs/ceph/inode.c||fs/ceph/inode.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "fs/ceph/inode.c||fs/ceph/inode.c": [
          "File: fs/ceph/inode.c -> fs/ceph/inode.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "736:  int issued, new_issued, info_caps;",
          "737:  struct timespec64 mtime, atime, ctime;",
          "738:  struct ceph_buffer *xattr_blob = NULL;",
          "739:  struct ceph_string *pool_ns = NULL;",
          "740:  struct ceph_cap *new_cap = NULL;",
          "741:  int err = 0;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "739:  struct ceph_buffer *old_blob = NULL;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "881:  if ((ci->i_xattrs.version == 0 || !(issued & CEPH_CAP_XATTR_EXCL))  &&",
          "882:      le64_to_cpu(info->xattr_version) > ci->i_xattrs.version) {",
          "883:   if (ci->i_xattrs.blob)",
          "885:   ci->i_xattrs.blob = xattr_blob;",
          "886:   if (xattr_blob)",
          "887:    memcpy(ci->i_xattrs.blob->vec.iov_base,",
          "",
          "[Removed Lines]",
          "884:    ceph_buffer_put(ci->i_xattrs.blob);",
          "",
          "[Added Lines]",
          "885:    old_blob = ci->i_xattrs.blob;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1022: out:",
          "1023:  if (new_cap)",
          "1024:   ceph_put_cap(mdsc, new_cap);",
          "1027:  ceph_put_string(pool_ns);",
          "1028:  return err;",
          "1029: }",
          "",
          "[Removed Lines]",
          "1025:  if (xattr_blob)",
          "1026:   ceph_buffer_put(xattr_blob);",
          "",
          "[Added Lines]",
          "1026:  ceph_buffer_put(old_blob);",
          "1027:  ceph_buffer_put(xattr_blob);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "dfbc7a46b940b5d5ef8c3db3b7c3b51e6ec8fec4",
      "candidate_info": {
        "commit_hash": "dfbc7a46b940b5d5ef8c3db3b7c3b51e6ec8fec4",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/dfbc7a46b940b5d5ef8c3db3b7c3b51e6ec8fec4",
        "files": [
          "drivers/gpu/drm/drm_gem_shmem_helper.c",
          "include/drm/drm_gem_shmem_helper.h"
        ],
        "message": "drm/shmem: Use mutex_trylock in drm_gem_shmem_purge\n\nLockdep reports a circular locking dependency with pages_lock taken in\nthe shrinker callback. The deadlock can't actually happen with current\nusers at least as a BO will never be purgeable when pages_lock is held.\nTo be safe, let's use mutex_trylock() instead and bail if a BO is locked\nalready.\n\nWARNING: possible circular locking dependency detected\n5.3.0-rc1+ #100 Tainted: G             L\n------------------------------------------------------\nkswapd0/171 is trying to acquire lock:\n000000009b9823fd (&shmem->pages_lock){+.+.}, at: drm_gem_shmem_purge+0x20/0x40\n\nbut task is already holding lock:\n00000000f82369b6 (fs_reclaim){+.+.}, at: __fs_reclaim_acquire+0x0/0x40\n\nwhich lock already depends on the new lock.\n\nthe existing dependency chain (in reverse order) is:\n\n-> #1 (fs_reclaim){+.+.}:\n       fs_reclaim_acquire.part.18+0x34/0x40\n       fs_reclaim_acquire+0x20/0x28\n       __kmalloc_node+0x6c/0x4c0\n       kvmalloc_node+0x38/0xa8\n       drm_gem_get_pages+0x80/0x1d0\n       drm_gem_shmem_get_pages+0x58/0xa0\n       drm_gem_shmem_get_pages_sgt+0x48/0xd0\n       panfrost_mmu_map+0x38/0xf8 [panfrost]\n       panfrost_gem_open+0xc0/0xe8 [panfrost]\n       drm_gem_handle_create_tail+0xe8/0x198\n       drm_gem_handle_create+0x3c/0x50\n       panfrost_gem_create_with_handle+0x70/0xa0 [panfrost]\n       panfrost_ioctl_create_bo+0x48/0x80 [panfrost]\n       drm_ioctl_kernel+0xb8/0x110\n       drm_ioctl+0x244/0x3f0\n       do_vfs_ioctl+0xbc/0x910\n       ksys_ioctl+0x78/0xa8\n       __arm64_sys_ioctl+0x1c/0x28\n       el0_svc_common.constprop.0+0x90/0x168\n       el0_svc_handler+0x28/0x78\n       el0_svc+0x8/0xc\n\n-> #0 (&shmem->pages_lock){+.+.}:\n       __lock_acquire+0xa2c/0x1d70\n       lock_acquire+0xdc/0x228\n       __mutex_lock+0x8c/0x800\n       mutex_lock_nested+0x1c/0x28\n       drm_gem_shmem_purge+0x20/0x40\n       panfrost_gem_shrinker_scan+0xc0/0x180 [panfrost]\n       do_shrink_slab+0x208/0x500\n       shrink_slab+0x10c/0x2c0\n       shrink_node+0x28c/0x4d8\n       balance_pgdat+0x2c8/0x570\n       kswapd+0x22c/0x638\n       kthread+0x128/0x130\n       ret_from_fork+0x10/0x18\n\nother info that might help us debug this:\n\n Possible unsafe locking scenario:\n\n       CPU0                    CPU1\n       ----                    ----\n  lock(fs_reclaim);\n                               lock(&shmem->pages_lock);\n                               lock(fs_reclaim);\n  lock(&shmem->pages_lock);\n\n *** DEADLOCK ***\n\n3 locks held by kswapd0/171:\n #0: 00000000f82369b6 (fs_reclaim){+.+.}, at: __fs_reclaim_acquire+0x0/0x40\n #1: 00000000ceb37808 (shrinker_rwsem){++++}, at: shrink_slab+0xbc/0x2c0\n #2: 00000000f31efa81 (&pfdev->shrinker_lock){+.+.}, at: panfrost_gem_shrinker_scan+0x34/0x180 [panfrost]\n\nFixes: 17acb9f35ed7 (\"drm/shmem: Add madvise state and purge helpers\")\nCc: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>\nCc: Maxime Ripard <maxime.ripard@bootlin.com>\nCc: Sean Paul <sean@poorly.run>\nCc: David Airlie <airlied@linux.ie>\nCc: Daniel Vetter <daniel@ffwll.ch>\nSigned-off-by: Rob Herring <robh@kernel.org>\nReviewed-by: Steven Price <steven.price@arm.com>\nAcked-by: Alyssa Rosenzweig <alyssa.rosenzweig@collabora.com>\nLink: https://patchwork.freedesktop.org/patch/msgid/20190823021216.5862-6-robh@kernel.org",
        "before_after_code_files": [
          "drivers/gpu/drm/drm_gem_shmem_helper.c||drivers/gpu/drm/drm_gem_shmem_helper.c",
          "include/drm/drm_gem_shmem_helper.h||include/drm/drm_gem_shmem_helper.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "drivers/gpu/drm/drm_gem_shmem_helper.c||drivers/gpu/drm/drm_gem_shmem_helper.c": [
          "File: drivers/gpu/drm/drm_gem_shmem_helper.c -> drivers/gpu/drm/drm_gem_shmem_helper.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "415: }",
          "416: EXPORT_SYMBOL(drm_gem_shmem_purge_locked);",
          "419: {",
          "420:  struct drm_gem_shmem_object *shmem = to_drm_gem_shmem_obj(obj);",
          "423:  drm_gem_shmem_purge_locked(obj);",
          "424:  mutex_unlock(&shmem->pages_lock);",
          "425: }",
          "426: EXPORT_SYMBOL(drm_gem_shmem_purge);",
          "",
          "[Removed Lines]",
          "418: void drm_gem_shmem_purge(struct drm_gem_object *obj)",
          "422:  mutex_lock(&shmem->pages_lock);",
          "",
          "[Added Lines]",
          "418: bool drm_gem_shmem_purge(struct drm_gem_object *obj)",
          "422:  if (!mutex_trylock(&shmem->pages_lock))",
          "423:   return false;",
          "427:  return true;",
          "",
          "---------------"
        ],
        "include/drm/drm_gem_shmem_helper.h||include/drm/drm_gem_shmem_helper.h": [
          "File: include/drm/drm_gem_shmem_helper.h -> include/drm/drm_gem_shmem_helper.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "134: }",
          "136: void drm_gem_shmem_purge_locked(struct drm_gem_object *obj);",
          "139: struct drm_gem_shmem_object *",
          "140: drm_gem_shmem_create_with_handle(struct drm_file *file_priv,",
          "",
          "[Removed Lines]",
          "137: void drm_gem_shmem_purge(struct drm_gem_object *obj);",
          "",
          "[Added Lines]",
          "137: bool drm_gem_shmem_purge(struct drm_gem_object *obj);",
          "",
          "---------------"
        ]
      }
    }
  ]
}
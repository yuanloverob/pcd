{
  "cve_id": "CVE-2017-3730",
  "cve_desc": "In OpenSSL 1.1.0 before 1.1.0d, if a malicious server supplies bad parameters for a DHE or ECDHE key exchange then this can result in the client attempting to dereference a NULL pointer leading to a client crash. This could be exploited in a Denial of Service attack.",
  "repo": "openssl/openssl",
  "patch_hash": "efbe126e3ebb9123ac9d058aa2bb044261342aaa",
  "patch_info": {
    "commit_hash": "efbe126e3ebb9123ac9d058aa2bb044261342aaa",
    "repo": "openssl/openssl",
    "commit_url": "https://github.com/openssl/openssl/commit/efbe126e3ebb9123ac9d058aa2bb044261342aaa",
    "files": [
      "ssl/statem/statem_clnt.c"
    ],
    "message": "Fix missing NULL checks in CKE processing\n\nReviewed-by: Rich Salz <rsalz@openssl.org>",
    "before_after_code_files": [
      "ssl/statem/statem_clnt.c||ssl/statem/statem_clnt.c"
    ]
  },
  "patch_diff": {
    "ssl/statem/statem_clnt.c||ssl/statem/statem_clnt.c": [
      "File: ssl/statem/statem_clnt.c -> ssl/statem/statem_clnt.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "2258:         return 0;",
      "2259:     }",
      "2260:     ckey = ssl_generate_pkey(skey);",
      "2261:     dh_clnt = EVP_PKEY_get0_DH(ckey);",
      "2263:     if (dh_clnt == NULL || ssl_derive(s, ckey, skey) == 0) {",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "2261:     if (ckey == NULL) {",
      "2262:         SSLerr(SSL_F_TLS_CONSTRUCT_CKE_DHE, ERR_R_INTERNAL_ERROR);",
      "2263:         return 0;",
      "2264:     }",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "2296:     }",
      "2298:     ckey = ssl_generate_pkey(skey);",
      "2300:     if (ssl_derive(s, ckey, skey) == 0) {",
      "2301:         SSLerr(SSL_F_TLS_CONSTRUCT_CKE_ECDHE, ERR_R_EVP_LIB);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "2304:     if (ckey == NULL) {",
      "2305:         SSLerr(SSL_F_TLS_CONSTRUCT_CKE_ECDHE, ERR_R_INTERNAL_ERROR);",
      "2306:         goto err;",
      "2307:     }",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "a08ae8fee9539ed1432f4169cea46f6e27990dd5",
      "candidate_info": {
        "commit_hash": "a08ae8fee9539ed1432f4169cea46f6e27990dd5",
        "repo": "openssl/openssl",
        "commit_url": "https://github.com/openssl/openssl/commit/a08ae8fee9539ed1432f4169cea46f6e27990dd5",
        "files": [
          "crypto/dso/dso_lib.c"
        ],
        "message": "Avoid the call to OPENSSL_malloc with a negative value (then casted to unsigned)\n\nCLA: trivial\nReviewed-by: Matt Caswell <matt@openssl.org>\nReviewed-by: Richard Levitte <levitte@openssl.org>\nReviewed-by: Rich Salz <rsalz@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/2021)\n(cherry picked from commit 210fe4edee6514e4c1f0677adc9112c4459da02b)",
        "before_after_code_files": [
          "crypto/dso/dso_lib.c||crypto/dso/dso_lib.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/EktapopaT/openssl/pull/1"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "crypto/dso/dso_lib.c||crypto/dso/dso_lib.c": [
          "File: crypto/dso/dso_lib.c -> crypto/dso/dso_lib.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "324:     char *filename = NULL;",
          "325:     int len = DSO_pathbyaddr(addr, NULL, 0);",
          "327:     filename = OPENSSL_malloc(len);",
          "328:     if (filename != NULL",
          "329:             && DSO_pathbyaddr(addr, filename, len) == len)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "327:     if (len < 0)",
          "328:         return NULL;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "f56c786769e13bb06e9855cd426e74a1c9eea3a1",
      "candidate_info": {
        "commit_hash": "f56c786769e13bb06e9855cd426e74a1c9eea3a1",
        "repo": "openssl/openssl",
        "commit_url": "https://github.com/openssl/openssl/commit/f56c786769e13bb06e9855cd426e74a1c9eea3a1",
        "files": [
          "crypto/init.c"
        ],
        "message": "Stop init loops\n\nUnder certain circumstances, the libcrypto init code would loop,\ncausing a deadlock.  This would typically happen if something in\nossl_init_base() caused an OpenSSL error, and the error stack routines\nwould recurse into the init code before the flag that ossl_init_base()\nhad been run was checked.\n\nThis change makes sure ossl_init_base isn't run once more of the base\nis initiated.\n\nThanks to Dmitry Kostjuchenko for the idea.\n\nFixes Github issue #1899\n\nReviewed-by: Matt Caswell <matt@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/1922)\n(cherry picked from commit b7a7f39afeb4748b4c25dbccb8951711b8b70eaf)",
        "before_after_code_files": [
          "crypto/init.c||crypto/init.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/EktapopaT/openssl/pull/1"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "crypto/init.c||crypto/init.c": [
          "File: crypto/init.c -> crypto/init.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "503:         return 0;",
          "504:     }",
          "507:         return 0;",
          "509:     if ((opts & OPENSSL_INIT_NO_LOAD_CRYPTO_STRINGS)",
          "",
          "[Removed Lines]",
          "506:     if (!RUN_ONCE(&base, ossl_init_base))",
          "",
          "[Added Lines]",
          "506:     if (!base_inited && !RUN_ONCE(&base, ossl_init_base))",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "f3a7e57c92b2c9b87dc4b2997f2ebda6781300d0",
      "candidate_info": {
        "commit_hash": "f3a7e57c92b2c9b87dc4b2997f2ebda6781300d0",
        "repo": "openssl/openssl",
        "commit_url": "https://github.com/openssl/openssl/commit/f3a7e57c92b2c9b87dc4b2997f2ebda6781300d0",
        "files": [
          "crypto/evp/e_rc4_hmac_md5.c"
        ],
        "message": "crypto/evp: harden RC4_MD5 cipher.\n\nOriginally a crash in 32-bit build was reported CHACHA20-POLY1305\ncipher. The crash is triggered by truncated packet and is result\nof excessive hashing to the edge of accessible memory (or bogus\nMAC value is produced if x86 MD5 assembly module is involved). Since\nhash operation is read-only it is not considered to be exploitable\nbeyond a DoS condition.\n\nThanks to Robert \u015awi\u0119cki for report.\n\nCVE-2017-3731\n\nReviewed-by: Rich Salz <rsalz@openssl.org>",
        "before_after_code_files": [
          "crypto/evp/e_rc4_hmac_md5.c||crypto/evp/e_rc4_hmac_md5.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/EktapopaT/openssl/pull/1"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "crypto/evp/e_rc4_hmac_md5.c||crypto/evp/e_rc4_hmac_md5.c": [
          "File: crypto/evp/e_rc4_hmac_md5.c -> crypto/evp/e_rc4_hmac_md5.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "219:             len = p[arg - 2] << 8 | p[arg - 1];",
          "221:             if (!EVP_CIPHER_CTX_encrypting(ctx)) {",
          "222:                 len -= MD5_DIGEST_LENGTH;",
          "223:                 p[arg - 2] = len >> 8;",
          "224:                 p[arg - 1] = len;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "222:                 if (len < MD5_DIGEST_LENGTH)",
          "223:                     return -1;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "b763981b76b6a97c72011c290ec574b37a15f6e4",
      "candidate_info": {
        "commit_hash": "b763981b76b6a97c72011c290ec574b37a15f6e4",
        "repo": "openssl/openssl",
        "commit_url": "https://github.com/openssl/openssl/commit/b763981b76b6a97c72011c290ec574b37a15f6e4",
        "files": [
          "crypto/armcap.c"
        ],
        "message": "crypto/armcap.c: short-circuit processor capability probe in iOS builds.\n\nCapability probing by catching SIGILL appears to be problematic\non iOS. But since Apple universe is \"monocultural\", it's actually\npossible to simply set pre-defined processor capability mask.\n\nReviewed-by: Rich Salz <rsalz@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/2617)\n\n(cherry picked from commit 8653e78f4319b23d60239f9557d8c1e1d23be1a5)",
        "before_after_code_files": [
          "crypto/armcap.c||crypto/armcap.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/EktapopaT/openssl/pull/1"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "crypto/armcap.c||crypto/armcap.c": [
          "File: crypto/armcap.c -> crypto/armcap.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "111:         return;",
          "112:     }",
          "114:     sigfillset(&all_masked);",
          "115:     sigdelset(&all_masked, SIGILL);",
          "116:     sigdelset(&all_masked, SIGTRAP);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "114: # if defined(__APPLE__) && !defined(__aarch64__)",
          "120:     if (1) {",
          "121:         OPENSSL_armcap_P = ARMV7_NEON;",
          "122:         return;",
          "123:     }",
          "130: # endif",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "75f12d7cbffcaa31cc8ff5c7fee02e614785632a",
      "candidate_info": {
        "commit_hash": "75f12d7cbffcaa31cc8ff5c7fee02e614785632a",
        "repo": "openssl/openssl",
        "commit_url": "https://github.com/openssl/openssl/commit/75f12d7cbffcaa31cc8ff5c7fee02e614785632a",
        "files": [
          "test/README.ssltest.md",
          "test/handshake_helper.c",
          "test/handshake_helper.h",
          "test/ssl_test.c",
          "test/ssl_test_ctx.c",
          "test/ssl_test_ctx.h"
        ],
        "message": "Add new ssl_test option.\n\nAdd option ExpectedTmpKeyType to test the temporary key the server\nsends is of the correct type.\n\nReviewed-by: Kurt Roeckx <kurt@openssl.org>\nReviewed-by: Matt Caswell <matt@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/2191)\n(cherry picked from commit b93ad05dba3e3d2ceb79799a883ae43d42ba16e2)",
        "before_after_code_files": [
          "test/handshake_helper.c||test/handshake_helper.c",
          "test/handshake_helper.h||test/handshake_helper.h",
          "test/ssl_test.c||test/ssl_test.c",
          "test/ssl_test_ctx.c||test/ssl_test_ctx.c",
          "test/ssl_test_ctx.h||test/ssl_test_ctx.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/EktapopaT/openssl/pull/1"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "test/handshake_helper.c||test/handshake_helper.c": [
          "File: test/handshake_helper.c -> test/handshake_helper.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "876:     const unsigned char *proto = NULL;",
          "878:     unsigned int proto_len = 0;",
          "880:     memset(&server_ctx_data, 0, sizeof(server_ctx_data));",
          "881:     memset(&server2_ctx_data, 0, sizeof(server2_ctx_data));",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "879:     EVP_PKEY *tmp_key;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1035:     if (session_out != NULL)",
          "1038:     ctx_data_free_data(&server_ctx_data);",
          "1039:     ctx_data_free_data(&server2_ctx_data);",
          "1040:     ctx_data_free_data(&client_ctx_data);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1039:     if (SSL_get_server_tmp_key(client.ssl, &tmp_key)) {",
          "1040:         int nid = EVP_PKEY_id(tmp_key);",
          "1042: #ifndef OPENSSL_NO_EC",
          "1043:         if (nid == EVP_PKEY_EC) {",
          "1044:             EC_KEY *ec = EVP_PKEY_get0_EC_KEY(tmp_key);",
          "1045:             nid = EC_GROUP_get_curve_name(EC_KEY_get0_group(ec));",
          "1046:         }",
          "1047: #endif",
          "1048:         EVP_PKEY_free(tmp_key);",
          "1049:         ret->tmp_key_type = nid;",
          "1050:     }",
          "",
          "---------------"
        ],
        "test/handshake_helper.h||test/handshake_helper.h": [
          "File: test/handshake_helper.h -> test/handshake_helper.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "44:     int client_resumed;",
          "45:     int server_resumed;",
          "46: } HANDSHAKE_RESULT;",
          "48: HANDSHAKE_RESULT *HANDSHAKE_RESULT_new(void);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "47:     int tmp_key_type;",
          "",
          "---------------"
        ],
        "test/ssl_test.c||test/ssl_test.c": [
          "File: test/ssl_test.c -> test/ssl_test.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "198:     return 1;",
          "199: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "201: static int check_tmp_key(HANDSHAKE_RESULT *result, SSL_TEST_CTX *test_ctx)",
          "202: {",
          "203:     if (test_ctx->expected_tmp_key_type == 0",
          "204:         || test_ctx->expected_tmp_key_type == result->tmp_key_type)",
          "205:         return 1;",
          "206:     fprintf(stderr, \"Tmp key type mismatch, %s vs %s\\n\",",
          "207:             OBJ_nid2ln(test_ctx->expected_tmp_key_type),",
          "208:             OBJ_nid2ln(result->tmp_key_type));",
          "209:     return 0;",
          "210: }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "218: #endif",
          "219:         ret &= check_alpn(result, test_ctx);",
          "220:         ret &= check_resumption(result, test_ctx);",
          "221:     }",
          "222:     return ret;",
          "223: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "232:         ret &= check_tmp_key(result, test_ctx);",
          "",
          "---------------"
        ],
        "test/ssl_test_ctx.c||test/ssl_test_ctx.c": [
          "File: test/ssl_test_ctx.c -> test/ssl_test_ctx.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "432: IMPLEMENT_SSL_TEST_INT_OPTION(SSL_TEST_CTX, test, max_fragment_size)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "438: __owur static int parse_expected_tmp_key_type(SSL_TEST_CTX *test_ctx,",
          "439:                                               const char *value)",
          "440: {",
          "441:     int nid;",
          "443:     if (value == NULL)",
          "444:         return 0;",
          "445:     nid = OBJ_sn2nid(value);",
          "446:     if (nid == NID_undef)",
          "447:         nid = OBJ_ln2nid(value);",
          "448: #ifndef OPENSSL_NO_EC",
          "449:     if (nid == NID_undef)",
          "450:         nid = EC_curve_nist2nid(value);",
          "451: #endif",
          "452:     if (nid == NID_undef)",
          "453:         return 0;",
          "454:     test_ctx->expected_tmp_key_type = nid;",
          "455:     return 1;",
          "456: }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "455:     { \"ResumptionExpected\", &parse_test_resumption_expected },",
          "456:     { \"ApplicationData\", &parse_test_app_data_size },",
          "457:     { \"MaxFragmentSize\", &parse_test_max_fragment_size },",
          "458: };",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "482:     { \"ExpectedTmpKeyType\", &parse_expected_tmp_key_type },",
          "",
          "---------------"
        ],
        "test/ssl_test_ctx.h||test/ssl_test_ctx.h": [
          "File: test/ssl_test_ctx.h -> test/ssl_test_ctx.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "159:     char *expected_alpn_protocol;",
          "161:     int resumption_expected;",
          "162: } SSL_TEST_CTX;",
          "164: const char *ssl_test_result_name(ssl_test_result_t result);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "163:     int expected_tmp_key_type;",
          "",
          "---------------"
        ]
      }
    }
  ]
}
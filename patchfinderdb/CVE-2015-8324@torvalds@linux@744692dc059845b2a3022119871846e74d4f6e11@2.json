{
  "cve_id": "CVE-2015-8324",
  "cve_desc": "The ext4 implementation in the Linux kernel before 2.6.34 does not properly track the initialization of certain data structures, which allows physically proximate attackers to cause a denial of service (NULL pointer dereference and panic) via a crafted USB device, related to the ext4_fill_super function.",
  "repo": "torvalds/linux",
  "patch_hash": "744692dc059845b2a3022119871846e74d4f6e11",
  "patch_info": {
    "commit_hash": "744692dc059845b2a3022119871846e74d4f6e11",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/744692dc059845b2a3022119871846e74d4f6e11",
    "files": [
      "fs/ext4/ext4.h",
      "fs/ext4/ext4_jbd2.h",
      "fs/ext4/extents.c",
      "fs/ext4/inode.c",
      "fs/ext4/super.c"
    ],
    "message": "ext4: use ext4_get_block_write in buffer write\n\nAllocate uninitialized extent before ext4 buffer write and\nconvert the extent to initialized after io completes.\nThe purpose is to make sure an extent can only be marked\ninitialized after it has been written with new data so\nwe can safely drop the i_mutex lock in ext4 DIO read without\nexposing stale data. This helps to improve multi-thread DIO\nread performance on high-speed disks.\n\nSkip the nobh and data=journal mount cases to make things simple for now.\n\nSigned-off-by: Jiaying Zhang <jiayingz@google.com>\nSigned-off-by: \"Theodore Ts'o\" <tytso@mit.edu>",
    "before_after_code_files": [
      "fs/ext4/ext4.h||fs/ext4/ext4.h",
      "fs/ext4/ext4_jbd2.h||fs/ext4/ext4_jbd2.h",
      "fs/ext4/extents.c||fs/ext4/extents.c",
      "fs/ext4/inode.c||fs/ext4/inode.c",
      "fs/ext4/super.c||fs/ext4/super.c"
    ]
  },
  "patch_diff": {
    "fs/ext4/ext4.h||fs/ext4/ext4.h": [
      "File: fs/ext4/ext4.h -> fs/ext4/ext4.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "361:       EXT4_GET_BLOCKS_CREATE_UNINIT_EXT)",
      "363: #define EXT4_GET_BLOCKS_IO_CONVERT_EXT  (EXT4_GET_BLOCKS_CONVERT|\\",
      "",
      "[Removed Lines]",
      "364:       EXT4_GET_BLOCKS_IO_CREATE_EXT)",
      "",
      "[Added Lines]",
      "364:       EXT4_GET_BLOCKS_CREATE_UNINIT_EXT)",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "704:  struct list_head i_completed_io_list;",
      "706:  ext4_io_end_t *cur_aio_dio;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "705:  spinlock_t i_completed_io_lock;",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "1781:         __u64 len, __u64 *moved_len);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1787: enum ext4_state_bits {",
      "1789:    = BH_JBDPrivateStart,",
      "1790: };",
      "1792: BUFFER_FNS(Uninit, uninit)",
      "1793: TAS_BUFFER_FNS(Uninit, uninit)",
      "",
      "---------------"
    ],
    "fs/ext4/ext4_jbd2.h||fs/ext4/ext4_jbd2.h": [
      "File: fs/ext4/ext4_jbd2.h -> fs/ext4/ext4_jbd2.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "304:  return 0;",
      "305: }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "316: static inline int ext4_should_dioread_nolock(struct inode *inode)",
      "317: {",
      "318:  if (!test_opt(inode->i_sb, DIOREAD_NOLOCK))",
      "319:   return 0;",
      "320:  if (test_opt(inode->i_sb, NOBH))",
      "321:   return 0;",
      "322:  if (!S_ISREG(inode->i_mode))",
      "323:   return 0;",
      "324:  if (!(EXT4_I(inode)->i_flags & EXT4_EXTENTS_FL))",
      "325:   return 0;",
      "326:  if (ext4_should_journal_data(inode))",
      "327:   return 0;",
      "328:  return 1;",
      "329: }",
      "",
      "---------------"
    ],
    "fs/ext4/extents.c||fs/ext4/extents.c": [
      "File: fs/ext4/extents.c -> fs/ext4/extents.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "1619:  BUG_ON(path[depth].p_hdr == NULL);",
      "1623:   && ext4_can_extents_be_merged(inode, ex, newext)) {",
      "1624:   ext_debug(\"append [%d]%d block to %d:[%d]%d (from %llu)\\n\",",
      "1625:     ext4_ext_is_uninitialized(newext),",
      "",
      "[Removed Lines]",
      "1622:  if (ex && (flag != EXT4_GET_BLOCKS_PRE_IO)",
      "",
      "[Added Lines]",
      "1622:  if (ex && !(flag & EXT4_GET_BLOCKS_PRE_IO)",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "1741: merge:",
      "1744:   ext4_ext_try_to_merge(inode, path, nearex);",
      "",
      "[Removed Lines]",
      "1743:  if (flag != EXT4_GET_BLOCKS_PRE_IO)",
      "",
      "[Added Lines]",
      "1743:  if (!(flag & EXT4_GET_BLOCKS_PRE_IO))",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "3065:  ext4_ext_show_leaf(inode, path);",
      "3069:   ret = ext4_split_unwritten_extents(handle,",
      "3070:       inode, path, iblock,",
      "3071:       max_blocks, flags);",
      "",
      "[Removed Lines]",
      "3068:  if (flags == EXT4_GET_BLOCKS_PRE_IO) {",
      "",
      "[Added Lines]",
      "3068:  if ((flags & EXT4_GET_BLOCKS_PRE_IO)) {",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "3078:    io->flag = EXT4_IO_UNWRITTEN;",
      "3079:   else",
      "3080:    ext4_set_inode_state(inode, EXT4_STATE_DIO_UNWRITTEN);",
      "3081:   goto out;",
      "3082:  }",
      "3085:   ret = ext4_convert_unwritten_extents_endio(handle, inode,",
      "3086:        path);",
      "3087:   if (ret >= 0)",
      "",
      "[Removed Lines]",
      "3084:  if (flags == EXT4_GET_BLOCKS_CONVERT) {",
      "",
      "[Added Lines]",
      "3081:   if (ext4_should_dioread_nolock(inode))",
      "3082:    set_buffer_uninit(bh_result);",
      "3086:  if ((flags & EXT4_GET_BLOCKS_CONVERT)) {",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "3351:  if (flags & EXT4_GET_BLOCKS_UNINIT_EXT){",
      "3352:   ext4_ext_mark_uninitialized(&newex);",
      "3363:    if (io)",
      "3364:     io->flag = EXT4_IO_UNWRITTEN;",
      "3365:    else",
      "3366:     ext4_set_inode_state(inode,",
      "3367:            EXT4_STATE_DIO_UNWRITTEN);",
      "3368:   }",
      "3369:  }",
      "3371:  if (unlikely(EXT4_I(inode)->i_flags & EXT4_EOFBLOCKS_FL)) {",
      "",
      "[Removed Lines]",
      "3362:   if (flags == EXT4_GET_BLOCKS_PRE_IO) {",
      "",
      "[Added Lines]",
      "3362:   if ((flags & EXT4_GET_BLOCKS_PRE_IO)) {",
      "3369:   if (ext4_should_dioread_nolock(inode))",
      "3370:    set_buffer_uninit(bh_result);",
      "",
      "---------------"
    ],
    "fs/ext4/inode.c||fs/ext4/inode.c": [
      "File: fs/ext4/inode.c -> fs/ext4/inode.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "38: #include <linux/uio.h>",
      "39: #include <linux/bio.h>",
      "40: #include <linux/workqueue.h>",
      "42: #include \"ext4_jbd2.h\"",
      "43: #include \"xattr.h\"",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "41: #include <linux/kernel.h>",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "1534:  ext4_truncate(inode);",
      "1535: }",
      "1537: static int ext4_write_begin(struct file *file, struct address_space *mapping,",
      "1538:        loff_t pos, unsigned len, unsigned flags,",
      "1539:        struct page **pagep, void **fsdata)",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1538: static int ext4_get_block_write(struct inode *inode, sector_t iblock,",
      "1539:      struct buffer_head *bh_result, int create);",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "1575:  }",
      "1581:  if (!ret && ext4_should_journal_data(inode)) {",
      "1582:   ret = walk_page_buffers(handle, page_buffers(page),",
      "",
      "[Removed Lines]",
      "1578:  ret = block_write_begin(file, mapping, pos, len, flags, pagep, fsdata,",
      "1579:     ext4_get_block);",
      "",
      "[Added Lines]",
      "1581:  if (ext4_should_dioread_nolock(inode))",
      "1582:   ret = block_write_begin(file, mapping, pos, len, flags, pagep,",
      "1583:     fsdata, ext4_get_block_write);",
      "1584:  else",
      "1585:   ret = block_write_begin(file, mapping, pos, len, flags, pagep,",
      "1586:     fsdata, ext4_get_block);",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "2092:     } else if (buffer_mapped(bh))",
      "2093:      BUG_ON(bh->b_blocknr != pblock);",
      "2095:     cur_logical++;",
      "2096:     pblock++;",
      "2097:    } while ((bh = bh->b_this_page) != head);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "2102:     if (buffer_uninit(exbh))",
      "2103:      set_buffer_uninit(bh);",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "2222:  new.b_state = 0;",
      "2223:  get_blocks_flags = EXT4_GET_BLOCKS_CREATE;",
      "2224:  if (mpd->b_state & (1 << BH_Delay))",
      "2225:   get_blocks_flags |= EXT4_GET_BLOCKS_DELALLOC_RESERVE;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "2233:  if (ext4_should_dioread_nolock(mpd->inode))",
      "2234:   get_blocks_flags |= EXT4_GET_BLOCKS_IO_CREATE_EXT;",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "2636:  return ret;",
      "2637: }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "2650: static int ext4_set_bh_endio(struct buffer_head *bh, struct inode *inode);",
      "2651: static void ext4_end_io_buffer_write(struct buffer_head *bh, int uptodate);",
      "",
      "---------------",
      "--- Hunk 7 ---",
      "[Context before]",
      "2683:  int ret = 0;",
      "2684:  loff_t size;",
      "2685:  unsigned int len;",
      "2687:  struct inode *inode = page->mapping->host;",
      "2689:  trace_ext4_writepage(inode, page);",
      "",
      "[Removed Lines]",
      "2686:  struct buffer_head *page_bufs;",
      "",
      "[Added Lines]",
      "2700:  struct buffer_head *page_bufs = NULL;",
      "",
      "---------------",
      "--- Hunk 8 ---",
      "[Context before]",
      "2760:  if (test_opt(inode->i_sb, NOBH) && ext4_should_writeback_data(inode))",
      "2761:   ret = nobh_writepage(page, noalloc_get_block_write, wbc);",
      "2763:   ret = block_write_full_page(page, noalloc_get_block_write,",
      "2764:          wbc);",
      "",
      "[Removed Lines]",
      "2762:  else",
      "",
      "[Added Lines]",
      "2776:  else if (page_bufs && buffer_uninit(page_bufs)) {",
      "2777:   ext4_set_bh_endio(page_bufs, inode);",
      "2778:   ret = block_write_full_page_endio(page, noalloc_get_block_write,",
      "2779:          wbc, ext4_end_io_buffer_write);",
      "2780:  } else",
      "",
      "---------------",
      "--- Hunk 9 ---",
      "[Context before]",
      "3347:  return mpage_readpages(mapping, pages, nr_pages, ext4_get_block);",
      "3348: }",
      "3350: static void ext4_invalidatepage(struct page *page, unsigned long offset)",
      "3351: {",
      "3352:  journal_t *journal = EXT4_JOURNAL(page->mapping->host);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "3368: static void ext4_free_io_end(ext4_io_end_t *io)",
      "3369: {",
      "3370:  BUG_ON(!io);",
      "3371:  if (io->page)",
      "3372:   put_page(io->page);",
      "3373:  iput(io->inode);",
      "3374:  kfree(io);",
      "3375: }",
      "3377: static void ext4_invalidatepage_free_endio(struct page *page, unsigned long offset)",
      "3378: {",
      "3379:  struct buffer_head *head, *bh;",
      "3380:  unsigned int curr_off = 0;",
      "3382:  if (!page_has_buffers(page))",
      "3383:   return;",
      "3384:  head = bh = page_buffers(page);",
      "3385:  do {",
      "3386:   if (offset <= curr_off && test_clear_buffer_uninit(bh)",
      "3387:      && bh->b_private) {",
      "3388:    ext4_free_io_end(bh->b_private);",
      "3389:    bh->b_private = NULL;",
      "3390:    bh->b_end_io = NULL;",
      "3391:   }",
      "3392:   curr_off = curr_off + bh->b_size;",
      "3393:   bh = bh->b_this_page;",
      "3394:  } while (bh != head);",
      "3395: }",
      "3404:  if (ext4_should_dioread_nolock(page->mapping->host))",
      "3405:   ext4_invalidatepage_free_endio(page, offset);",
      "",
      "---------------",
      "--- Hunk 10 ---",
      "[Context before]",
      "3471: static int ext4_get_block_write(struct inode *inode, sector_t iblock,",
      "3472:      struct buffer_head *bh_result, int create)",
      "3473: {",
      "3475:  int ret = 0;",
      "3476:  unsigned max_blocks = bh_result->b_size >> inode->i_blkbits;",
      "3477:  int dio_credits;",
      "3479:  ext4_debug(\"ext4_get_block_write: inode %lu, create flag %d\\n\",",
      "3480:      inode->i_ino, create);",
      "",
      "[Removed Lines]",
      "3474:  handle_t *handle = NULL;",
      "",
      "[Added Lines]",
      "3526:  handle_t *handle = ext4_journal_current_handle();",
      "3530:  int started = 0;",
      "",
      "---------------",
      "--- Hunk 11 ---",
      "[Context before]",
      "3486:  create = EXT4_GET_BLOCKS_IO_CREATE_EXT;",
      "3495:  }",
      "3496:  ret = ext4_get_blocks(handle, inode, iblock, max_blocks, bh_result,",
      "3497:          create);",
      "3498:  if (ret > 0) {",
      "3499:   bh_result->b_size = (ret << inode->i_blkbits);",
      "3500:   ret = 0;",
      "3501:  }",
      "3503: out:",
      "3504:  return ret;",
      "3505: }",
      "3514: static void dump_completed_IO(struct inode * inode)",
      "3515: {",
      "3516: #ifdef EXT4_DEBUG",
      "3517:  struct list_head *cur, *before, *after;",
      "3518:  ext4_io_end_t *io, *io0, *io1;",
      "3520:  if (list_empty(&EXT4_I(inode)->i_completed_io_list)){",
      "3521:   ext4_debug(\"inode %lu completed_io list is empty\\n\", inode->i_ino);",
      "",
      "[Removed Lines]",
      "3488:  if (max_blocks > DIO_MAX_BLOCKS)",
      "3489:   max_blocks = DIO_MAX_BLOCKS;",
      "3490:  dio_credits = ext4_chunk_trans_blocks(inode, max_blocks);",
      "3491:  handle = ext4_journal_start(inode, dio_credits);",
      "3492:  if (IS_ERR(handle)) {",
      "3493:   ret = PTR_ERR(handle);",
      "3494:   goto out;",
      "3502:  ext4_journal_stop(handle);",
      "3507: static void ext4_free_io_end(ext4_io_end_t *io)",
      "3508: {",
      "3509:  BUG_ON(!io);",
      "3510:  iput(io->inode);",
      "3511:  kfree(io);",
      "3512: }",
      "",
      "[Added Lines]",
      "3541:  if (!handle) {",
      "3542:   if (max_blocks > DIO_MAX_BLOCKS)",
      "3543:    max_blocks = DIO_MAX_BLOCKS;",
      "3544:   dio_credits = ext4_chunk_trans_blocks(inode, max_blocks);",
      "3545:   handle = ext4_journal_start(inode, dio_credits);",
      "3546:   if (IS_ERR(handle)) {",
      "3547:    ret = PTR_ERR(handle);",
      "3548:    goto out;",
      "3549:   }",
      "3550:   started = 1;",
      "3559:  if (started)",
      "3560:   ext4_journal_stop(handle);",
      "3570:  unsigned long flags;",
      "",
      "---------------",
      "--- Hunk 12 ---",
      "[Context before]",
      "3523:  }",
      "3525:  ext4_debug(\"Dump inode %lu completed_io list \\n\", inode->i_ino);",
      "3526:  list_for_each_entry(io, &EXT4_I(inode)->i_completed_io_list, list){",
      "3527:   cur = &io->list;",
      "3528:   before = cur->prev;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "3578:  spin_lock_irqsave(&EXT4_I(inode)->i_completed_io_lock, flags);",
      "",
      "---------------",
      "--- Hunk 13 ---",
      "[Context before]",
      "3533:   ext4_debug(\"io 0x%p from inode %lu,prev 0x%p,next 0x%p\\n\",",
      "3534:        io, inode->i_ino, io0, io1);",
      "3535:  }",
      "3536: #endif",
      "3537: }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "3589:  spin_unlock_irqrestore(&EXT4_I(inode)->i_completed_io_lock, flags);",
      "",
      "---------------",
      "--- Hunk 14 ---",
      "[Context before]",
      "3556:  if (io->flag != EXT4_IO_UNWRITTEN)",
      "3557:   return ret;",
      "3562:  if (ret < 0) {",
      "3563:   printk(KERN_EMERG \"%s: failed to convert unwritten\"",
      "3564:    \"extents to written extents, error is %d\"",
      "",
      "[Removed Lines]",
      "3559:  if (offset + size <= i_size_read(inode))",
      "3560:   ret = ext4_convert_unwritten_extents(inode, offset, size);",
      "",
      "[Added Lines]",
      "3613:  ret = ext4_convert_unwritten_extents(inode, offset, size);",
      "",
      "---------------",
      "--- Hunk 15 ---",
      "[Context before]",
      "3578: static void ext4_end_io_work(struct work_struct *work)",
      "3579: {",
      "3584:  mutex_lock(&inode->i_mutex);",
      "3585:  ret = ext4_end_io_nolock(io);",
      "3590:  }",
      "3591:  mutex_unlock(&inode->i_mutex);",
      "3592: }",
      "",
      "[Removed Lines]",
      "3580:  ext4_io_end_t *io  = container_of(work, ext4_io_end_t, work);",
      "3581:  struct inode *inode = io->inode;",
      "3582:  int ret = 0;",
      "3586:  if (ret >= 0) {",
      "3587:   if (!list_empty(&io->list))",
      "3588:    list_del_init(&io->list);",
      "3589:   ext4_free_io_end(io);",
      "",
      "[Added Lines]",
      "3632:  ext4_io_end_t  *io = container_of(work, ext4_io_end_t, work);",
      "3633:  struct inode  *inode = io->inode;",
      "3634:  struct ext4_inode_info *ei = EXT4_I(inode);",
      "3635:  unsigned long  flags;",
      "3636:  int   ret;",
      "3640:  if (ret < 0) {",
      "3641:   mutex_unlock(&inode->i_mutex);",
      "3642:   return;",
      "3645:  spin_lock_irqsave(&ei->i_completed_io_lock, flags);",
      "3646:  if (!list_empty(&io->list))",
      "3647:   list_del_init(&io->list);",
      "3648:  spin_unlock_irqrestore(&ei->i_completed_io_lock, flags);",
      "3650:  ext4_free_io_end(io);",
      "",
      "---------------",
      "--- Hunk 16 ---",
      "[Context before]",
      "3607: int flush_completed_IO(struct inode *inode)",
      "3608: {",
      "3609:  ext4_io_end_t *io;",
      "3610:  int ret = 0;",
      "3611:  int ret2 = 0;",
      "3614:   return ret;",
      "3616:  dump_completed_IO(inode);",
      "3619:     ext4_io_end_t, list);",
      "",
      "[Removed Lines]",
      "3613:  if (list_empty(&EXT4_I(inode)->i_completed_io_list))",
      "3617:  while (!list_empty(&EXT4_I(inode)->i_completed_io_list)){",
      "3618:   io = list_entry(EXT4_I(inode)->i_completed_io_list.next,",
      "",
      "[Added Lines]",
      "3669:  struct ext4_inode_info *ei = EXT4_I(inode);",
      "3670:  unsigned long flags;",
      "3674:  if (list_empty(&ei->i_completed_io_list))",
      "3678:  spin_lock_irqsave(&ei->i_completed_io_lock, flags);",
      "3679:  while (!list_empty(&ei->i_completed_io_list)){",
      "3680:   io = list_entry(ei->i_completed_io_list.next,",
      "",
      "---------------",
      "--- Hunk 17 ---",
      "[Context before]",
      "3634:   ret = ext4_end_io_nolock(io);",
      "3635:   if (ret < 0)",
      "3636:    ret2 = ret;",
      "3637:   else",
      "3638:    list_del_init(&io->list);",
      "3639:  }",
      "3640:  return (ret2 < 0) ? ret2 : 0;",
      "3641: }",
      "3644: {",
      "3645:  ext4_io_end_t *io = NULL;",
      "3649:  if (io) {",
      "3650:   igrab(inode);",
      "",
      "[Removed Lines]",
      "3643: static ext4_io_end_t *ext4_init_io_end (struct inode *inode)",
      "3647:  io = kmalloc(sizeof(*io), GFP_NOFS);",
      "",
      "[Added Lines]",
      "3696:   spin_unlock_irqrestore(&ei->i_completed_io_lock, flags);",
      "3698:   spin_lock_irqsave(&ei->i_completed_io_lock, flags);",
      "3704:  spin_unlock_irqrestore(&ei->i_completed_io_lock, flags);",
      "3708: static ext4_io_end_t *ext4_init_io_end (struct inode *inode, gfp_t flags)",
      "3712:  io = kmalloc(sizeof(*io), flags);",
      "",
      "---------------",
      "--- Hunk 18 ---",
      "[Context before]",
      "3652:   io->flag = 0;",
      "3653:   io->offset = 0;",
      "3654:   io->size = 0;",
      "3656:   INIT_WORK(&io->work, ext4_end_io_work);",
      "3657:   INIT_LIST_HEAD(&io->list);",
      "3658:  }",
      "",
      "[Removed Lines]",
      "3655:   io->error = 0;",
      "",
      "[Added Lines]",
      "3720:   io->page = NULL;",
      "",
      "---------------",
      "--- Hunk 19 ---",
      "[Context before]",
      "3665: {",
      "3666:         ext4_io_end_t *io_end = iocb->private;",
      "3667:  struct workqueue_struct *wq;",
      "3670:  if (!io_end || !size)",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "3733:  unsigned long flags;",
      "3734:  struct ext4_inode_info *ei;",
      "",
      "---------------",
      "--- Hunk 20 ---",
      "[Context before]",
      "3685:  io_end->offset = offset;",
      "3686:  io_end->size = size;",
      "3687:  wq = EXT4_SB(io_end->inode->i_sb)->dio_unwritten_wq;",
      "3690:  queue_work(wq, &io_end->work);",
      "3695:  iocb->private = NULL;",
      "3696: }",
      "",
      "[Removed Lines]",
      "3693:  list_add_tail(&io_end->list,",
      "3694:    &EXT4_I(io_end->inode)->i_completed_io_list);",
      "",
      "[Added Lines]",
      "3754:  io_end->flag = EXT4_IO_UNWRITTEN;",
      "3761:  ei = EXT4_I(io_end->inode);",
      "3762:  spin_lock_irqsave(&ei->i_completed_io_lock, flags);",
      "3763:  list_add_tail(&io_end->list, &ei->i_completed_io_list);",
      "3764:  spin_unlock_irqrestore(&ei->i_completed_io_lock, flags);",
      "3768: static void ext4_end_io_buffer_write(struct buffer_head *bh, int uptodate)",
      "3769: {",
      "3770:  ext4_io_end_t *io_end = bh->b_private;",
      "3771:  struct workqueue_struct *wq;",
      "3772:  struct inode *inode;",
      "3773:  unsigned long flags;",
      "3775:  if (!test_clear_buffer_uninit(bh) || !io_end)",
      "3776:   goto out;",
      "3778:  if (!(io_end->inode->i_sb->s_flags & MS_ACTIVE)) {",
      "3779:   printk(\"sb umounted, discard end_io request for inode %lu\\n\",",
      "3780:    io_end->inode->i_ino);",
      "3781:   ext4_free_io_end(io_end);",
      "3782:   goto out;",
      "3783:  }",
      "3785:  io_end->flag = EXT4_IO_UNWRITTEN;",
      "3786:  inode = io_end->inode;",
      "3789:  spin_lock_irqsave(&EXT4_I(inode)->i_completed_io_lock, flags);",
      "3790:  list_add_tail(&io_end->list, &EXT4_I(inode)->i_completed_io_list);",
      "3791:  spin_unlock_irqrestore(&EXT4_I(inode)->i_completed_io_lock, flags);",
      "3793:  wq = EXT4_SB(inode->i_sb)->dio_unwritten_wq;",
      "3795:  queue_work(wq, &io_end->work);",
      "3796: out:",
      "3797:  bh->b_private = NULL;",
      "3798:  bh->b_end_io = NULL;",
      "3799:  clear_buffer_uninit(bh);",
      "3800:  end_buffer_async_write(bh, uptodate);",
      "3801: }",
      "3803: static int ext4_set_bh_endio(struct buffer_head *bh, struct inode *inode)",
      "3804: {",
      "3805:  ext4_io_end_t *io_end;",
      "3806:  struct page *page = bh->b_page;",
      "3807:  loff_t offset = (sector_t)page->index << PAGE_CACHE_SHIFT;",
      "3808:  size_t size = bh->b_size;",
      "3810: retry:",
      "3811:  io_end = ext4_init_io_end(inode, GFP_ATOMIC);",
      "3812:  if (!io_end) {",
      "3813:   if (printk_ratelimit())",
      "3814:    printk(KERN_WARNING \"%s: allocation fail\\n\", __func__);",
      "3815:   schedule();",
      "3816:   goto retry;",
      "3817:  }",
      "3818:  io_end->offset = offset;",
      "3819:  io_end->size = size;",
      "3825:  io_end->page = page;",
      "3826:  get_page(io_end->page);",
      "3828:  bh->b_private = io_end;",
      "3829:  bh->b_end_io = ext4_end_io_buffer_write;",
      "3830:  return 0;",
      "3831: }",
      "",
      "---------------",
      "--- Hunk 21 ---",
      "[Context before]",
      "3748:   iocb->private = NULL;",
      "3749:   EXT4_I(inode)->cur_aio_dio = NULL;",
      "3750:   if (!is_sync_kiocb(iocb)) {",
      "3752:    if (!iocb->private)",
      "3753:     return -ENOMEM;",
      "",
      "[Removed Lines]",
      "3751:    iocb->private = ext4_init_io_end(inode);",
      "",
      "[Added Lines]",
      "3886:    iocb->private = ext4_init_io_end(inode, GFP_NOFS);",
      "",
      "---------------"
    ],
    "fs/ext4/super.c||fs/ext4/super.c": [
      "File: fs/ext4/super.c -> fs/ext4/super.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "709:  ei->i_reserved_quota = 0;",
      "710: #endif",
      "711:  INIT_LIST_HEAD(&ei->i_completed_io_list);",
      "712:  ei->cur_aio_dio = NULL;",
      "713:  ei->i_sync_tid = 0;",
      "714:  ei->i_datasync_tid = 0;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "712:  spin_lock_init(&ei->i_completed_io_lock);",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "926:  if (test_opt(sb, NOLOAD))",
      "927:   seq_puts(seq, \",norecovery\");",
      "929:  ext4_show_quota_options(seq, sb);",
      "931:  return 0;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "930:  if (test_opt(sb, DIOREAD_NOLOCK))",
      "931:   seq_puts(seq, \",dioread_nolock\");",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "1109:  Opt_stripe, Opt_delalloc, Opt_nodelalloc,",
      "1110:  Opt_block_validity, Opt_noblock_validity,",
      "1111:  Opt_inode_readahead_blks, Opt_journal_ioprio,",
      "1112:  Opt_discard, Opt_nodiscard,",
      "1113: };",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1116:  Opt_dioread_nolock, Opt_dioread_lock,",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "1176:  {Opt_auto_da_alloc, \"auto_da_alloc=%u\"},",
      "1177:  {Opt_auto_da_alloc, \"auto_da_alloc\"},",
      "1178:  {Opt_noauto_da_alloc, \"noauto_da_alloc\"},",
      "1179:  {Opt_discard, \"discard\"},",
      "1180:  {Opt_nodiscard, \"nodiscard\"},",
      "1181:  {Opt_err, NULL},",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1184:  {Opt_dioread_nolock, \"dioread_nolock\"},",
      "1185:  {Opt_dioread_lock, \"dioread_lock\"},",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "1640:   case Opt_nodiscard:",
      "1641:    clear_opt(sbi->s_mount_opt, DISCARD);",
      "1642:    break;",
      "1643:   default:",
      "1644:    ext4_msg(sb, KERN_ERR,",
      "1645:           \"Unrecognized mount option \\\"%s\\\" \"",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1650:   case Opt_dioread_nolock:",
      "1651:    set_opt(sbi->s_mount_opt, DIOREAD_NOLOCK);",
      "1652:    break;",
      "1653:   case Opt_dioread_lock:",
      "1654:    clear_opt(sbi->s_mount_opt, DIOREAD_NOLOCK);",
      "1655:    break;",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "2795:        EXT4_HAS_INCOMPAT_FEATURE(sb, EXT4_FEATURE_INCOMPAT_RECOVER)) {",
      "2796:   ext4_msg(sb, KERN_ERR, \"required journal recovery \"",
      "2797:          \"suppressed and not mounted read-only\");",
      "2799:  } else {",
      "2800:   clear_opt(sbi->s_mount_opt, DATA_FLAGS);",
      "2801:   set_opt(sbi->s_mount_opt, WRITEBACK_DATA);",
      "",
      "[Removed Lines]",
      "2798:   goto failed_mount4;",
      "",
      "[Added Lines]",
      "2811:   goto failed_mount_wq;",
      "",
      "---------------",
      "--- Hunk 7 ---",
      "[Context before]",
      "2808:      !jbd2_journal_set_features(EXT4_SB(sb)->s_journal, 0, 0,",
      "2809:            JBD2_FEATURE_INCOMPAT_64BIT)) {",
      "2810:   ext4_msg(sb, KERN_ERR, \"Failed to set 64-bit journal feature\");",
      "2812:  }",
      "2814:  if (test_opt(sb, JOURNAL_ASYNC_COMMIT)) {",
      "",
      "[Removed Lines]",
      "2811:   goto failed_mount4;",
      "",
      "[Added Lines]",
      "2824:   goto failed_mount_wq;",
      "",
      "---------------",
      "--- Hunk 8 ---",
      "[Context before]",
      "2847:       (sbi->s_journal, 0, 0, JBD2_FEATURE_INCOMPAT_REVOKE)) {",
      "2848:    ext4_msg(sb, KERN_ERR, \"Journal does not support \"",
      "2849:           \"requested data journaling mode\");",
      "2851:   }",
      "2852:  default:",
      "2853:   break;",
      "",
      "[Removed Lines]",
      "2850:    goto failed_mount4;",
      "",
      "[Added Lines]",
      "2863:    goto failed_mount_wq;",
      "",
      "---------------",
      "--- Hunk 9 ---",
      "[Context before]",
      "2855:  set_task_ioprio(sbi->s_journal->j_task, journal_ioprio);",
      "2857: no_journal:",
      "2859:  if (test_opt(sb, NOBH)) {",
      "2860:   if (!(test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_WRITEBACK_DATA)) {",
      "2861:    ext4_msg(sb, KERN_WARNING, \"Ignoring nobh option - \"",
      "2862:     \"its supported only with writeback mode\");",
      "2863:    clear_opt(sbi->s_mount_opt, NOBH);",
      "2864:   }",
      "2865:  }",
      "2866:  EXT4_SB(sb)->dio_unwritten_wq = create_workqueue(\"ext4-dio-unwritten\");",
      "2867:  if (!EXT4_SB(sb)->dio_unwritten_wq) {",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "2877:   if (test_opt(sb, DIOREAD_NOLOCK)) {",
      "2878:    ext4_msg(sb, KERN_WARNING, \"dioread_nolock option is \"",
      "2879:     \"not supported with nobh mode\");",
      "2880:    goto failed_mount_wq;",
      "2881:   }",
      "",
      "---------------",
      "--- Hunk 10 ---",
      "[Context before]",
      "2926:     \"requested data journaling mode\");",
      "2927:   clear_opt(sbi->s_mount_opt, DELALLOC);",
      "2928:  }",
      "2930:  err = ext4_setup_system_zone(sb);",
      "2931:  if (err) {",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "2946:  if (test_opt(sb, DIOREAD_NOLOCK)) {",
      "2947:   if (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_JOURNAL_DATA) {",
      "2948:    ext4_msg(sb, KERN_WARNING, \"Ignoring dioread_nolock \"",
      "2949:     \"option - requested data journaling mode\");",
      "2950:    clear_opt(sbi->s_mount_opt, DIOREAD_NOLOCK);",
      "2951:   }",
      "2952:   if (sb->s_blocksize < PAGE_SIZE) {",
      "2953:    ext4_msg(sb, KERN_WARNING, \"Ignoring dioread_nolock \"",
      "2954:     \"option - block size is too small\");",
      "2955:    clear_opt(sbi->s_mount_opt, DIOREAD_NOLOCK);",
      "2956:   }",
      "2957:  }",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "a8901d34872dafcafa23efa0865dcecfd4fddf8c",
      "candidate_info": {
        "commit_hash": "a8901d34872dafcafa23efa0865dcecfd4fddf8c",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/a8901d34872dafcafa23efa0865dcecfd4fddf8c",
        "files": [
          "fs/ext4/inode.c"
        ],
        "message": "ext4: Use pr_warning_ratelimited() instead of printk_ratelimit()\n\nprintk_ratelimit() is deprecated since it is a global instead of a\nper-printk ratelimit.\n\nSigned-off-by: \"Theodore Ts'o\" <tytso@mit.edu>",
        "before_after_code_files": [
          "fs/ext4/inode.c||fs/ext4/inode.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "fs/ext4/inode.c||fs/ext4/inode.c"
          ],
          "candidate": [
            "fs/ext4/inode.c||fs/ext4/inode.c"
          ]
        }
      },
      "candidate_diff": {
        "fs/ext4/inode.c||fs/ext4/inode.c": [
          "File: fs/ext4/inode.c -> fs/ext4/inode.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "40: #include <linux/workqueue.h>",
          "41: #include <linux/kernel.h>",
          "42: #include <linux/slab.h>",
          "44: #include \"ext4_jbd2.h\"",
          "45: #include \"xattr.h\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "43: #include <linux/ratelimit.h>",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "3729: retry:",
          "3730:  io_end = ext4_init_io_end(inode, GFP_ATOMIC);",
          "3731:  if (!io_end) {",
          "3734:   schedule();",
          "3735:   goto retry;",
          "3736:  }",
          "",
          "[Removed Lines]",
          "3732:   if (printk_ratelimit())",
          "3733:    printk(KERN_WARNING \"%s: allocation fail\\n\", __func__);",
          "",
          "[Added Lines]",
          "3733:   pr_warning_ratelimited(\"%s: allocation fail\\n\", __func__);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "2ac3b6e00acb46406c993d57921f86a594aafe08",
      "candidate_info": {
        "commit_hash": "2ac3b6e00acb46406c993d57921f86a594aafe08",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/2ac3b6e00acb46406c993d57921f86a594aafe08",
        "files": [
          "fs/ext4/ext4.h",
          "fs/ext4/inode.c"
        ],
        "message": "ext4: Clean up ext4_get_blocks() so it does not depend on bh_result->b_state\n\nThe ext4_get_blocks() function was depending on the value of\nbh_result->b_state as an input parameter to decide whether or not\nupdate the delalloc accounting statistics by calling\next4_da_update_reserve_space().  We now use a separate flag,\nEXT4_GET_BLOCKS_UPDATE_RESERVE_SPACE, to requests this update, so that\nall callers of ext4_get_blocks() can clear map_bh.b_state before\ncalling ext4_get_blocks() without worrying about any consistency\nissues.\n\nSigned-off-by: \"Theodore Ts'o\" <tytso@mit.edu>",
        "before_after_code_files": [
          "fs/ext4/ext4.h||fs/ext4/ext4.h",
          "fs/ext4/inode.c||fs/ext4/inode.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "fs/ext4/ext4.h||fs/ext4/ext4.h",
            "fs/ext4/inode.c||fs/ext4/inode.c"
          ],
          "candidate": [
            "fs/ext4/ext4.h||fs/ext4/ext4.h",
            "fs/ext4/inode.c||fs/ext4/inode.c"
          ]
        }
      },
      "candidate_diff": {
        "fs/ext4/ext4.h||fs/ext4/ext4.h": [
          "File: fs/ext4/ext4.h -> fs/ext4/ext4.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "324: #define EXT4_GET_BLOCKS_CREATE_UNINIT_EXT (EXT4_GET_BLOCKS_UNINIT_EXT|\\",
          "325:        EXT4_GET_BLOCKS_CREATE)",
          "",
          "[Removed Lines]",
          "321: #define EXT4_GET_BLOCKS_CREATE   1",
          "323: #define EXT4_GET_BLOCKS_UNINIT_EXT  2",
          "327: #define EXT4_GET_BLOCKS_EXTEND_DISKSIZE  4",
          "330: #define EXT4_GET_BLOCKS_DELALLOC_RESERVE 8",
          "",
          "[Added Lines]",
          "321: #define EXT4_GET_BLOCKS_CREATE   0x0001",
          "323: #define EXT4_GET_BLOCKS_UNINIT_EXT  0x0002",
          "327: #define EXT4_GET_BLOCKS_EXTEND_DISKSIZE  0x0004",
          "329:     so set the magic i_delalloc_reserve_flag after taking the",
          "331: #define EXT4_GET_BLOCKS_DELALLOC_RESERVE 0x0008",
          "334: #define EXT4_GET_BLOCKS_UPDATE_RESERVE_SPACE 0x0010",
          "",
          "---------------"
        ],
        "fs/ext4/inode.c||fs/ext4/inode.c": [
          "File: fs/ext4/inode.c -> fs/ext4/inode.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1234:   }",
          "1235:  }",
          "1238:   EXT4_I(inode)->i_delalloc_reserved_flag = 0;",
          "1248:  up_write((&EXT4_I(inode)->i_data_sem));",
          "1249:  return retval;",
          "",
          "[Removed Lines]",
          "1237:  if (flags & EXT4_GET_BLOCKS_DELALLOC_RESERVE) {",
          "1244:   if ((retval > 0) && buffer_delay(bh))",
          "1245:    ext4_da_update_reserve_space(inode, retval);",
          "1246:  }",
          "",
          "[Added Lines]",
          "1237:  if (flags & EXT4_GET_BLOCKS_DELALLOC_RESERVE)",
          "1244:  if ((retval > 0) && (flags & EXT4_GET_BLOCKS_UPDATE_RESERVE_SPACE))",
          "1245:   ext4_da_update_reserve_space(inode, retval);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2016: static int mpage_da_map_blocks(struct mpage_da_data *mpd)",
          "2017: {",
          "2019:  struct buffer_head new;",
          "2020:  sector_t next = mpd->b_blocknr;",
          "2021:  unsigned max_blocks = mpd->b_size >> mpd->inode->i_blkbits;",
          "",
          "[Removed Lines]",
          "2018:  int err, blks;",
          "",
          "[Added Lines]",
          "2017:  int err, blks, get_blocks_flags;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "2040:  BUG_ON(!handle);",
          "2057:  blks = ext4_get_blocks(handle, mpd->inode, next, max_blocks,",
          "2060:  if (blks < 0) {",
          "2061:   err = blks;",
          "",
          "[Removed Lines]",
          "2056:  new.b_state = mpd->b_state & (1 << BH_Delay);",
          "2058:           &new, EXT4_GET_BLOCKS_CREATE|",
          "2059:           EXT4_GET_BLOCKS_DELALLOC_RESERVE);",
          "",
          "[Added Lines]",
          "2059:  new.b_state = 0;",
          "2060:  get_blocks_flags = (EXT4_GET_BLOCKS_CREATE |",
          "2061:        EXT4_GET_BLOCKS_DELALLOC_RESERVE);",
          "2062:  if (mpd->b_state & (1 << BH_Delay))",
          "2063:   get_blocks_flags |= EXT4_GET_BLOCKS_UPDATE_RESERVE_SPACE;",
          "2065:           &new, get_blocks_flags);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "bd2d0210cf22f2bd0cef72eb97cf94fc7d31d8cc",
      "candidate_info": {
        "commit_hash": "bd2d0210cf22f2bd0cef72eb97cf94fc7d31d8cc",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/bd2d0210cf22f2bd0cef72eb97cf94fc7d31d8cc",
        "files": [
          "fs/ext4/Makefile",
          "fs/ext4/ext4.h",
          "fs/ext4/extents.c",
          "fs/ext4/inode.c",
          "fs/ext4/page-io.c",
          "fs/ext4/super.c"
        ],
        "message": "ext4: use bio layer instead of buffer layer in mpage_da_submit_io\n\nCall the block I/O layer directly instad of going through the buffer\nlayer.  This should give us much better performance and scalability,\nas well as lowering our CPU utilization when doing buffered writeback.\n\nSigned-off-by: \"Theodore Ts'o\" <tytso@mit.edu>",
        "before_after_code_files": [
          "fs/ext4/ext4.h||fs/ext4/ext4.h",
          "fs/ext4/extents.c||fs/ext4/extents.c",
          "fs/ext4/inode.c||fs/ext4/inode.c",
          "fs/ext4/page-io.c||fs/ext4/page-io.c",
          "fs/ext4/super.c||fs/ext4/super.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "fs/ext4/ext4.h||fs/ext4/ext4.h",
            "fs/ext4/extents.c||fs/ext4/extents.c",
            "fs/ext4/inode.c||fs/ext4/inode.c",
            "fs/ext4/super.c||fs/ext4/super.c"
          ],
          "candidate": [
            "fs/ext4/ext4.h||fs/ext4/ext4.h",
            "fs/ext4/extents.c||fs/ext4/extents.c",
            "fs/ext4/inode.c||fs/ext4/inode.c",
            "fs/ext4/super.c||fs/ext4/super.c"
          ]
        }
      },
      "candidate_diff": {
        "fs/ext4/ext4.h||fs/ext4/ext4.h": [
          "File: fs/ext4/ext4.h -> fs/ext4/ext4.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "168:  int pages_written;",
          "169:  int retval;",
          "170: };",
          "172: typedef struct ext4_io_end {",
          "",
          "[Removed Lines]",
          "171: #define EXT4_IO_UNWRITTEN 0x1",
          "",
          "[Added Lines]",
          "175: #define EXT4_IO_END_UNWRITTEN 0x0001",
          "176: #define EXT4_IO_END_ERROR 0x0002",
          "178: struct ext4_io_page {",
          "179:  struct page *p_page;",
          "180:  int  p_count;",
          "181: };",
          "183: #define MAX_IO_PAGES 128",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "182: } ext4_io_end_t;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "195:  int   num_io_pages;",
          "196:  struct ext4_io_page *pages[MAX_IO_PAGES];",
          "199: struct ext4_io_submit {",
          "200:  int   io_op;",
          "201:  struct bio  *io_bio;",
          "202:  ext4_io_end_t  *io_end;",
          "203:  struct ext4_io_page *io_page;",
          "204:  sector_t  io_next_block;",
          "205: };",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "2044:         __u64 start_orig, __u64 start_donor,",
          "2045:         __u64 len, __u64 *moved_len);",
          "2049: enum ext4_state_bits {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2071: extern int __init init_ext4_pageio(void);",
          "2072: extern void exit_ext4_pageio(void);",
          "2073: extern void ext4_free_io_end(ext4_io_end_t *io);",
          "2074: extern ext4_io_end_t *ext4_init_io_end(struct inode *inode, gfp_t flags);",
          "2075: extern int ext4_end_io_nolock(ext4_io_end_t *io);",
          "2076: extern void ext4_io_submit(struct ext4_io_submit *io);",
          "2077: extern int ext4_bio_write_page(struct ext4_io_submit *io,",
          "2078:           struct page *page,",
          "2079:           int len,",
          "2080:           struct writeback_control *wbc);",
          "",
          "---------------"
        ],
        "fs/ext4/extents.c||fs/ext4/extents.c": [
          "File: fs/ext4/extents.c -> fs/ext4/extents.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "3204:   if (io)",
          "3206:   else",
          "3207:    ext4_set_inode_state(inode, EXT4_STATE_DIO_UNWRITTEN);",
          "3208:   if (ext4_should_dioread_nolock(inode))",
          "",
          "[Removed Lines]",
          "3205:    io->flag = EXT4_IO_UNWRITTEN;",
          "",
          "[Added Lines]",
          "3205:    io->flag = EXT4_IO_END_UNWRITTEN;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "3495:   if ((flags & EXT4_GET_BLOCKS_PRE_IO)) {",
          "3496:    if (io)",
          "3498:    else",
          "3499:     ext4_set_inode_state(inode,",
          "3500:            EXT4_STATE_DIO_UNWRITTEN);",
          "",
          "[Removed Lines]",
          "3497:     io->flag = EXT4_IO_UNWRITTEN;",
          "",
          "[Added Lines]",
          "3497:     io->flag = EXT4_IO_END_UNWRITTEN;",
          "",
          "---------------"
        ],
        "fs/ext4/inode.c||fs/ext4/inode.c": [
          "File: fs/ext4/inode.c -> fs/ext4/inode.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "2016:  struct buffer_head *bh, *page_bufs = NULL;",
          "2017:  int journal_data = ext4_should_journal_data(inode);",
          "2018:  sector_t pblock = 0, cur_logical = 0;",
          "2020:  BUG_ON(mpd->next_page <= mpd->first_page);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2019:  struct ext4_io_submit io_submit;",
          "2022:  memset(&io_submit, 0, sizeof(io_submit));",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2110:     block_commit_write(page, 0, len);",
          "2113:     err = __ext4_journalled_writepage(page, len);",
          "2123:    if (!err)",
          "2124:     mpd->pages_written++;",
          "",
          "[Removed Lines]",
          "2112:    if (journal_data && PageChecked(page))",
          "2114:    else if (buffer_uninit(page_bufs)) {",
          "2115:     ext4_set_bh_endio(page_bufs, inode);",
          "2116:     err = block_write_full_page_endio(page,",
          "2117:      noalloc_get_block_write,",
          "2118:      mpd->wbc, ext4_end_io_buffer_write);",
          "2119:    } else",
          "2120:     err = block_write_full_page(page,",
          "2121:          noalloc_get_block_write, mpd->wbc);",
          "",
          "[Added Lines]",
          "2119:    if (unlikely(journal_data && PageChecked(page)))",
          "2121:    else",
          "2122:     err = ext4_bio_write_page(&io_submit, page,",
          "2123:          len, mpd->wbc);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "2131:   }",
          "2132:   pagevec_release(&pvec);",
          "2133:  }",
          "2134:  return ret;",
          "2135: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2136:  ext4_io_submit(&io_submit);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "3426:  return mpage_readpages(mapping, pages, nr_pages, ext4_get_block);",
          "3427: }",
          "3438: static void ext4_invalidatepage_free_endio(struct page *page, unsigned long offset)",
          "3439: {",
          "3440:  struct buffer_head *head, *bh;",
          "",
          "[Removed Lines]",
          "3429: static void ext4_free_io_end(ext4_io_end_t *io)",
          "3430: {",
          "3431:  BUG_ON(!io);",
          "3432:  if (io->page)",
          "3433:   put_page(io->page);",
          "3434:  iput(io->inode);",
          "3435:  kfree(io);",
          "3436: }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "3639: #endif",
          "3640: }",
          "",
          "[Removed Lines]",
          "3645: static int ext4_end_io_nolock(ext4_io_end_t *io)",
          "3646: {",
          "3647:  struct inode *inode = io->inode;",
          "3648:  loff_t offset = io->offset;",
          "3649:  ssize_t size = io->size;",
          "3650:  int ret = 0;",
          "3652:  ext4_debug(\"ext4_end_io_nolock: io 0x%p from inode %lu,list->next 0x%p,\"",
          "3653:      \"list->prev 0x%p\\n\",",
          "3654:             io, inode->i_ino, io->list.next, io->list.prev);",
          "3656:  if (list_empty(&io->list))",
          "3657:   return ret;",
          "3659:  if (io->flag != EXT4_IO_UNWRITTEN)",
          "3660:   return ret;",
          "3662:  ret = ext4_convert_unwritten_extents(inode, offset, size);",
          "3663:  if (ret < 0) {",
          "3664:   printk(KERN_EMERG \"%s: failed to convert unwritten\"",
          "3665:    \"extents to written extents, error is %d\"",
          "3666:    \" io is still on inode %lu aio dio list\\n\",",
          "3667:                        __func__, ret, inode->i_ino);",
          "3668:   return ret;",
          "3669:  }",
          "3671:  if (io->iocb)",
          "3672:   aio_complete(io->iocb, io->result, 0);",
          "3674:  io->flag = 0;",
          "3675:  return ret;",
          "3676: }",
          "3681: static void ext4_end_io_work(struct work_struct *work)",
          "3682: {",
          "3683:  ext4_io_end_t  *io = container_of(work, ext4_io_end_t, work);",
          "3684:  struct inode  *inode = io->inode;",
          "3685:  struct ext4_inode_info *ei = EXT4_I(inode);",
          "3686:  unsigned long  flags;",
          "3687:  int   ret;",
          "3689:  mutex_lock(&inode->i_mutex);",
          "3690:  ret = ext4_end_io_nolock(io);",
          "3691:  if (ret < 0) {",
          "3692:   mutex_unlock(&inode->i_mutex);",
          "3693:   return;",
          "3694:  }",
          "3696:  spin_lock_irqsave(&ei->i_completed_io_lock, flags);",
          "3697:  if (!list_empty(&io->list))",
          "3698:   list_del_init(&io->list);",
          "3699:  spin_unlock_irqrestore(&ei->i_completed_io_lock, flags);",
          "3700:  mutex_unlock(&inode->i_mutex);",
          "3701:  ext4_free_io_end(io);",
          "3702: }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "3756:  return (ret2 < 0) ? ret2 : 0;",
          "3757: }",
          "3781: static void ext4_end_io_dio(struct kiocb *iocb, loff_t offset,",
          "3782:        ssize_t size, void *private, int ret,",
          "3783:        bool is_async)",
          "",
          "[Removed Lines]",
          "3759: static ext4_io_end_t *ext4_init_io_end (struct inode *inode, gfp_t flags)",
          "3760: {",
          "3761:  ext4_io_end_t *io = NULL;",
          "3763:  io = kmalloc(sizeof(*io), flags);",
          "3765:  if (io) {",
          "3766:   igrab(inode);",
          "3767:   io->inode = inode;",
          "3768:   io->flag = 0;",
          "3769:   io->offset = 0;",
          "3770:   io->size = 0;",
          "3771:   io->page = NULL;",
          "3772:   io->iocb = NULL;",
          "3773:   io->result = 0;",
          "3774:   INIT_WORK(&io->work, ext4_end_io_work);",
          "3775:   INIT_LIST_HEAD(&io->list);",
          "3776:  }",
          "3778:  return io;",
          "3779: }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "3797:     size);",
          "3801:   ext4_free_io_end(io_end);",
          "3802:   iocb->private = NULL;",
          "3803: out:",
          "",
          "[Removed Lines]",
          "3800:  if (io_end->flag != EXT4_IO_UNWRITTEN){",
          "",
          "[Added Lines]",
          "3710:  if (!(io_end->flag & EXT4_IO_END_UNWRITTEN)) {",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "3842:   goto out;",
          "3843:  }",
          "3846:  inode = io_end->inode;",
          "",
          "[Removed Lines]",
          "3845:  io_end->flag = EXT4_IO_UNWRITTEN;",
          "",
          "[Added Lines]",
          "3755:  io_end->flag = EXT4_IO_END_UNWRITTEN;",
          "",
          "---------------"
        ],
        "fs/ext4/page-io.c||fs/ext4/page-io.c": [
          "File: fs/ext4/page-io.c -> fs/ext4/page-io.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "9: #include <linux/module.h>",
          "10: #include <linux/fs.h>",
          "11: #include <linux/time.h>",
          "12: #include <linux/jbd2.h>",
          "13: #include <linux/highuid.h>",
          "14: #include <linux/pagemap.h>",
          "15: #include <linux/quotaops.h>",
          "16: #include <linux/string.h>",
          "17: #include <linux/buffer_head.h>",
          "18: #include <linux/writeback.h>",
          "19: #include <linux/pagevec.h>",
          "20: #include <linux/mpage.h>",
          "21: #include <linux/namei.h>",
          "22: #include <linux/uio.h>",
          "23: #include <linux/bio.h>",
          "24: #include <linux/workqueue.h>",
          "25: #include <linux/kernel.h>",
          "26: #include <linux/slab.h>",
          "28: #include \"ext4_jbd2.h\"",
          "29: #include \"xattr.h\"",
          "30: #include \"acl.h\"",
          "31: #include \"ext4_extents.h\"",
          "33: static struct kmem_cache *io_page_cachep, *io_end_cachep;",
          "35: int __init init_ext4_pageio(void)",
          "36: {",
          "37:  io_page_cachep = KMEM_CACHE(ext4_io_page, SLAB_RECLAIM_ACCOUNT);",
          "38:  if (io_page_cachep == NULL)",
          "39:   return -ENOMEM;",
          "40:  io_end_cachep = KMEM_CACHE(ext4_io_end, SLAB_RECLAIM_ACCOUNT);",
          "41:  if (io_page_cachep == NULL) {",
          "42:   kmem_cache_destroy(io_page_cachep);",
          "43:   return -ENOMEM;",
          "44:  }",
          "46:  return 0;",
          "47: }",
          "49: void exit_ext4_pageio(void)",
          "50: {",
          "51:  kmem_cache_destroy(io_end_cachep);",
          "52:  kmem_cache_destroy(io_page_cachep);",
          "53: }",
          "55: void ext4_free_io_end(ext4_io_end_t *io)",
          "56: {",
          "57:  int i;",
          "59:  BUG_ON(!io);",
          "60:  if (io->page)",
          "61:   put_page(io->page);",
          "62:  for (i = 0; i < io->num_io_pages; i++) {",
          "63:   if (--io->pages[i]->p_count == 0) {",
          "64:    struct page *page = io->pages[i]->p_page;",
          "66:    end_page_writeback(page);",
          "67:    put_page(page);",
          "68:    kmem_cache_free(io_page_cachep, io->pages[i]);",
          "69:   }",
          "70:  }",
          "71:  io->num_io_pages = 0;",
          "72:  iput(io->inode);",
          "73:  kmem_cache_free(io_end_cachep, io);",
          "74: }",
          "79: int ext4_end_io_nolock(ext4_io_end_t *io)",
          "80: {",
          "81:  struct inode *inode = io->inode;",
          "82:  loff_t offset = io->offset;",
          "83:  ssize_t size = io->size;",
          "84:  int ret = 0;",
          "86:  ext4_debug(\"ext4_end_io_nolock: io 0x%p from inode %lu,list->next 0x%p,\"",
          "87:      \"list->prev 0x%p\\n\",",
          "88:      io, inode->i_ino, io->list.next, io->list.prev);",
          "90:  if (list_empty(&io->list))",
          "91:   return ret;",
          "93:  if (!(io->flag & EXT4_IO_END_UNWRITTEN))",
          "94:   return ret;",
          "96:  ret = ext4_convert_unwritten_extents(inode, offset, size);",
          "97:  if (ret < 0) {",
          "98:   printk(KERN_EMERG \"%s: failed to convert unwritten \"",
          "99:    \"extents to written extents, error is %d \"",
          "100:    \"io is still on inode %lu aio dio list\\n\",",
          "101:          __func__, ret, inode->i_ino);",
          "102:   return ret;",
          "103:  }",
          "105:  if (io->iocb)",
          "106:   aio_complete(io->iocb, io->result, 0);",
          "108:  io->flag &= ~EXT4_IO_END_UNWRITTEN;",
          "109:  return ret;",
          "110: }",
          "115: static void ext4_end_io_work(struct work_struct *work)",
          "116: {",
          "117:  ext4_io_end_t  *io = container_of(work, ext4_io_end_t, work);",
          "118:  struct inode  *inode = io->inode;",
          "119:  struct ext4_inode_info *ei = EXT4_I(inode);",
          "120:  unsigned long  flags;",
          "121:  int   ret;",
          "123:  mutex_lock(&inode->i_mutex);",
          "124:  ret = ext4_end_io_nolock(io);",
          "125:  if (ret < 0) {",
          "126:   mutex_unlock(&inode->i_mutex);",
          "127:   return;",
          "128:  }",
          "130:  spin_lock_irqsave(&ei->i_completed_io_lock, flags);",
          "131:  if (!list_empty(&io->list))",
          "132:   list_del_init(&io->list);",
          "133:  spin_unlock_irqrestore(&ei->i_completed_io_lock, flags);",
          "134:  mutex_unlock(&inode->i_mutex);",
          "135:  ext4_free_io_end(io);",
          "136: }",
          "138: ext4_io_end_t *ext4_init_io_end(struct inode *inode, gfp_t flags)",
          "139: {",
          "140:  ext4_io_end_t *io = NULL;",
          "142:  io = kmem_cache_alloc(io_end_cachep, flags);",
          "143:  if (io) {",
          "144:   memset(io, 0, sizeof(*io));",
          "145:   io->inode = igrab(inode);",
          "146:   BUG_ON(!io->inode);",
          "147:   INIT_WORK(&io->work, ext4_end_io_work);",
          "148:   INIT_LIST_HEAD(&io->list);",
          "149:  }",
          "150:  return io;",
          "151: }",
          "160: static void buffer_io_error(struct buffer_head *bh)",
          "161: {",
          "162:  char b[BDEVNAME_SIZE];",
          "163:  printk(KERN_ERR \"Buffer I/O error on device %s, logical block %llu\\n\",",
          "164:    bdevname(bh->b_bdev, b),",
          "165:    (unsigned long long)bh->b_blocknr);",
          "166: }",
          "168: static void ext4_end_bio(struct bio *bio, int error)",
          "169: {",
          "170:  ext4_io_end_t *io_end = bio->bi_private;",
          "171:  struct workqueue_struct *wq;",
          "172:  struct inode *inode;",
          "173:  unsigned long flags;",
          "174:  ext4_fsblk_t err_block;",
          "175:  int i;",
          "177:  BUG_ON(!io_end);",
          "178:  inode = io_end->inode;",
          "179:  bio->bi_private = NULL;",
          "180:  bio->bi_end_io = NULL;",
          "181:  if (test_bit(BIO_UPTODATE, &bio->bi_flags))",
          "182:   error = 0;",
          "183:  err_block = bio->bi_sector >> (inode->i_blkbits - 9);",
          "184:  bio_put(bio);",
          "186:  if (!(inode->i_sb->s_flags & MS_ACTIVE)) {",
          "187:   pr_err(\"sb umounted, discard end_io request for inode %lu\\n\",",
          "188:    io_end->inode->i_ino);",
          "189:   ext4_free_io_end(io_end);",
          "190:   return;",
          "191:  }",
          "193:  if (error) {",
          "194:   io_end->flag |= EXT4_IO_END_ERROR;",
          "195:   ext4_warning(inode->i_sb, \"I/O error writing to inode %lu \"",
          "196:         \"(offset %llu size %ld starting block %llu)\",",
          "197:         inode->i_ino,",
          "198:         (unsigned long long) io_end->offset,",
          "199:         (long) io_end->size,",
          "200:         (unsigned long long) err_block);",
          "201:  }",
          "203:  for (i = 0; i < io_end->num_io_pages; i++) {",
          "204:   struct page *page = io_end->pages[i]->p_page;",
          "205:   struct buffer_head *bh, *head;",
          "206:   int partial_write = 0;",
          "208:   head = page_buffers(page);",
          "209:   if (error)",
          "210:    SetPageError(page);",
          "211:   BUG_ON(!head);",
          "212:   if (head->b_size == PAGE_CACHE_SIZE)",
          "213:    clear_buffer_dirty(head);",
          "214:   else {",
          "215:    loff_t offset;",
          "216:    loff_t io_end_offset = io_end->offset + io_end->size;",
          "218:    offset = (sector_t) page->index << PAGE_CACHE_SHIFT;",
          "219:    bh = head;",
          "220:    do {",
          "221:     if ((offset >= io_end->offset) &&",
          "222:         (offset+bh->b_size <= io_end_offset)) {",
          "223:      if (error)",
          "224:       buffer_io_error(bh);",
          "226:      clear_buffer_dirty(bh);",
          "227:     }",
          "228:     if (buffer_delay(bh))",
          "229:      partial_write = 1;",
          "230:     else if (!buffer_mapped(bh))",
          "231:      clear_buffer_dirty(bh);",
          "232:     else if (buffer_dirty(bh))",
          "233:      partial_write = 1;",
          "234:     offset += bh->b_size;",
          "235:     bh = bh->b_this_page;",
          "236:    } while (bh != head);",
          "237:   }",
          "239:   if (--io_end->pages[i]->p_count == 0) {",
          "240:    struct page *page = io_end->pages[i]->p_page;",
          "242:    end_page_writeback(page);",
          "243:    put_page(page);",
          "244:    kmem_cache_free(io_page_cachep, io_end->pages[i]);",
          "245:   }",
          "254:   if (!partial_write)",
          "255:    SetPageUptodate(page);",
          "256:  }",
          "258:  io_end->num_io_pages = 0;",
          "261:  spin_lock_irqsave(&EXT4_I(inode)->i_completed_io_lock, flags);",
          "262:  list_add_tail(&io_end->list, &EXT4_I(inode)->i_completed_io_list);",
          "263:  spin_unlock_irqrestore(&EXT4_I(inode)->i_completed_io_lock, flags);",
          "265:  wq = EXT4_SB(inode->i_sb)->dio_unwritten_wq;",
          "267:  queue_work(wq, &io_end->work);",
          "268: }",
          "270: void ext4_io_submit(struct ext4_io_submit *io)",
          "271: {",
          "272:  struct bio *bio = io->io_bio;",
          "274:  if (bio) {",
          "275:   bio_get(io->io_bio);",
          "276:   submit_bio(io->io_op, io->io_bio);",
          "277:   BUG_ON(bio_flagged(io->io_bio, BIO_EOPNOTSUPP));",
          "278:   bio_put(io->io_bio);",
          "279:  }",
          "280:  io->io_bio = 0;",
          "281:  io->io_op = 0;",
          "282:  io->io_end = 0;",
          "283: }",
          "285: static int io_submit_init(struct ext4_io_submit *io,",
          "286:      struct inode *inode,",
          "287:      struct writeback_control *wbc,",
          "288:      struct buffer_head *bh)",
          "289: {",
          "290:  ext4_io_end_t *io_end;",
          "291:  struct page *page = bh->b_page;",
          "292:  int nvecs = bio_get_nr_vecs(bh->b_bdev);",
          "293:  struct bio *bio;",
          "295:  io_end = ext4_init_io_end(inode, GFP_NOFS);",
          "296:  if (!io_end)",
          "297:   return -ENOMEM;",
          "298:  do {",
          "299:   bio = bio_alloc(GFP_NOIO, nvecs);",
          "300:   nvecs >>= 1;",
          "301:  } while (bio == NULL);",
          "303:  bio->bi_sector = bh->b_blocknr * (bh->b_size >> 9);",
          "304:  bio->bi_bdev = bh->b_bdev;",
          "305:  bio->bi_private = io->io_end = io_end;",
          "306:  bio->bi_end_io = ext4_end_bio;",
          "308:  io_end->inode = inode;",
          "309:  io_end->offset = (page->index << PAGE_CACHE_SHIFT) + bh_offset(bh);",
          "311:  io->io_bio = bio;",
          "312:  io->io_op = (wbc->sync_mode == WB_SYNC_ALL ?",
          "313:    WRITE_SYNC_PLUG : WRITE);",
          "314:  io->io_next_block = bh->b_blocknr;",
          "315:  return 0;",
          "316: }",
          "318: static int io_submit_add_bh(struct ext4_io_submit *io,",
          "319:        struct ext4_io_page *io_page,",
          "320:        struct inode *inode,",
          "321:        struct writeback_control *wbc,",
          "322:        struct buffer_head *bh)",
          "323: {",
          "324:  ext4_io_end_t *io_end;",
          "325:  int ret;",
          "327:  if (buffer_new(bh)) {",
          "328:   clear_buffer_new(bh);",
          "329:   unmap_underlying_metadata(bh->b_bdev, bh->b_blocknr);",
          "330:  }",
          "332:  if (!buffer_mapped(bh) || buffer_delay(bh)) {",
          "333:   if (!buffer_mapped(bh))",
          "334:    clear_buffer_dirty(bh);",
          "335:   if (io->io_bio)",
          "336:    ext4_io_submit(io);",
          "337:   return 0;",
          "338:  }",
          "340:  if (io->io_bio && bh->b_blocknr != io->io_next_block) {",
          "341: submit_and_retry:",
          "342:   ext4_io_submit(io);",
          "343:  }",
          "344:  if (io->io_bio == NULL) {",
          "345:   ret = io_submit_init(io, inode, wbc, bh);",
          "346:   if (ret)",
          "347:    return ret;",
          "348:  }",
          "349:  io_end = io->io_end;",
          "350:  if ((io_end->num_io_pages >= MAX_IO_PAGES) &&",
          "351:      (io_end->pages[io_end->num_io_pages-1] != io_page))",
          "352:   goto submit_and_retry;",
          "353:  if (buffer_uninit(bh))",
          "354:   io->io_end->flag |= EXT4_IO_END_UNWRITTEN;",
          "355:  io->io_end->size += bh->b_size;",
          "356:  io->io_next_block++;",
          "357:  ret = bio_add_page(io->io_bio, bh->b_page, bh->b_size, bh_offset(bh));",
          "358:  if (ret != bh->b_size)",
          "359:   goto submit_and_retry;",
          "360:  if ((io_end->num_io_pages == 0) ||",
          "361:      (io_end->pages[io_end->num_io_pages-1] != io_page)) {",
          "362:   io_end->pages[io_end->num_io_pages++] = io_page;",
          "363:   io_page->p_count++;",
          "364:  }",
          "365:  return 0;",
          "366: }",
          "368: int ext4_bio_write_page(struct ext4_io_submit *io,",
          "369:    struct page *page,",
          "370:    int len,",
          "371:    struct writeback_control *wbc)",
          "372: {",
          "373:  struct inode *inode = page->mapping->host;",
          "374:  unsigned block_start, block_end, blocksize;",
          "375:  struct ext4_io_page *io_page;",
          "376:  struct buffer_head *bh, *head;",
          "377:  int ret = 0;",
          "379:  blocksize = 1 << inode->i_blkbits;",
          "381:  BUG_ON(PageWriteback(page));",
          "382:  set_page_writeback(page);",
          "383:  ClearPageError(page);",
          "385:  io_page = kmem_cache_alloc(io_page_cachep, GFP_NOFS);",
          "386:  if (!io_page) {",
          "387:   set_page_dirty(page);",
          "388:   unlock_page(page);",
          "389:   return -ENOMEM;",
          "390:  }",
          "391:  io_page->p_page = page;",
          "392:  io_page->p_count = 0;",
          "393:  get_page(page);",
          "395:  for (bh = head = page_buffers(page), block_start = 0;",
          "396:       bh != head || !block_start;",
          "397:       block_start = block_end, bh = bh->b_this_page) {",
          "398:   block_end = block_start + blocksize;",
          "399:   if (block_start >= len) {",
          "400:    clear_buffer_dirty(bh);",
          "401:    set_buffer_uptodate(bh);",
          "402:    continue;",
          "403:   }",
          "404:   ret = io_submit_add_bh(io, io_page, inode, wbc, bh);",
          "405:   if (ret) {",
          "411:    set_page_dirty(page);",
          "412:    break;",
          "413:   }",
          "414:  }",
          "415:  unlock_page(page);",
          "424:  if (io_page->p_count == 0) {",
          "425:   put_page(page);",
          "426:   end_page_writeback(page);",
          "427:   kmem_cache_free(io_page_cachep, io_page);",
          "428:  }",
          "429:  return ret;",
          "430: }",
          "",
          "---------------"
        ],
        "fs/ext4/super.c||fs/ext4/super.c": [
          "File: fs/ext4/super.c -> fs/ext4/super.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "4769:  int err;",
          "4771:  ext4_check_flag_values();",
          "4773:  if (err)",
          "4774:   return err;",
          "4775:  ext4_kset = kset_create_and_add(\"ext4\", NULL, fs_kobj);",
          "4776:  if (!ext4_kset)",
          "4777:   goto out4;",
          "",
          "[Removed Lines]",
          "4772:  err = init_ext4_system_zone();",
          "",
          "[Added Lines]",
          "4772:  err = init_ext4_pageio();",
          "4775:  err = init_ext4_system_zone();",
          "4776:  if (err)",
          "4777:   goto out5;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "4812:  kset_unregister(ext4_kset);",
          "4813: out4:",
          "4814:  exit_ext4_system_zone();",
          "4815:  return err;",
          "4816: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4818: out5:",
          "4819:  exit_ext4_pageio();",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "4827:  remove_proc_entry(\"fs/ext4\", NULL);",
          "4828:  kset_unregister(ext4_kset);",
          "4829:  exit_ext4_system_zone();",
          "4830: }",
          "4832: MODULE_AUTHOR(\"Remy Card, Stephen Tweedie, Andrew Morton, Andreas Dilger, Theodore Ts'o and others\");",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4835:  exit_ext4_pageio();",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "12e9b892002d9af057655d35b44db8ee9243b0dc",
      "candidate_info": {
        "commit_hash": "12e9b892002d9af057655d35b44db8ee9243b0dc",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/12e9b892002d9af057655d35b44db8ee9243b0dc",
        "files": [
          "fs/ext4/dir.c",
          "fs/ext4/ext4.h",
          "fs/ext4/ext4_jbd2.h",
          "fs/ext4/extents.c",
          "fs/ext4/file.c",
          "fs/ext4/ialloc.c",
          "fs/ext4/inode.c",
          "fs/ext4/mballoc.c",
          "fs/ext4/migrate.c",
          "fs/ext4/move_extent.c",
          "fs/ext4/namei.c",
          "fs/ext4/super.c",
          "fs/ext4/xattr.c"
        ],
        "message": "ext4: Use bitops to read/modify i_flags in struct ext4_inode_info\n\nAt several places we modify EXT4_I(inode)->i_flags without holding\ni_mutex (ext4_do_update_inode, ...). These modifications are racy and\nwe can lose updates to i_flags. So convert handling of i_flags to use\nbitops which are atomic.\n\nhttps://bugzilla.kernel.org/show_bug.cgi?id=15792\n\nSigned-off-by: Dmitry Monakhov <dmonakhov@openvz.org>\nSigned-off-by: \"Theodore Ts'o\" <tytso@mit.edu>",
        "before_after_code_files": [
          "fs/ext4/dir.c||fs/ext4/dir.c",
          "fs/ext4/ext4.h||fs/ext4/ext4.h",
          "fs/ext4/ext4_jbd2.h||fs/ext4/ext4_jbd2.h",
          "fs/ext4/extents.c||fs/ext4/extents.c",
          "fs/ext4/file.c||fs/ext4/file.c",
          "fs/ext4/ialloc.c||fs/ext4/ialloc.c",
          "fs/ext4/inode.c||fs/ext4/inode.c",
          "fs/ext4/mballoc.c||fs/ext4/mballoc.c",
          "fs/ext4/migrate.c||fs/ext4/migrate.c",
          "fs/ext4/move_extent.c||fs/ext4/move_extent.c",
          "fs/ext4/namei.c||fs/ext4/namei.c",
          "fs/ext4/super.c||fs/ext4/super.c",
          "fs/ext4/xattr.c||fs/ext4/xattr.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "fs/ext4/ext4.h||fs/ext4/ext4.h",
            "fs/ext4/ext4_jbd2.h||fs/ext4/ext4_jbd2.h",
            "fs/ext4/extents.c||fs/ext4/extents.c",
            "fs/ext4/inode.c||fs/ext4/inode.c",
            "fs/ext4/super.c||fs/ext4/super.c"
          ],
          "candidate": [
            "fs/ext4/ext4.h||fs/ext4/ext4.h",
            "fs/ext4/ext4_jbd2.h||fs/ext4/ext4_jbd2.h",
            "fs/ext4/extents.c||fs/ext4/extents.c",
            "fs/ext4/inode.c||fs/ext4/inode.c",
            "fs/ext4/super.c||fs/ext4/super.c"
          ]
        }
      },
      "candidate_diff": {
        "fs/ext4/dir.c||fs/ext4/dir.c": [
          "File: fs/ext4/dir.c -> fs/ext4/dir.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "111:  if (EXT4_HAS_COMPAT_FEATURE(inode->i_sb,",
          "112:         EXT4_FEATURE_COMPAT_DIR_INDEX) &&",
          "114:       ((inode->i_size >> sb->s_blocksize_bits) == 1))) {",
          "115:   err = ext4_dx_readdir(filp, dirent, filldir);",
          "116:   if (err != ERR_BAD_DX_DIR) {",
          "",
          "[Removed Lines]",
          "113:      ((EXT4_I(inode)->i_flags & EXT4_INDEX_FL) ||",
          "",
          "[Added Lines]",
          "113:      ((ext4_test_inode_flag(inode, EXT4_INODE_INDEX)) ||",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "125:  }",
          "126:  stored = 0;",
          "127:  offset = filp->f_pos & (sb->s_blocksize - 1);",
          "",
          "[Removed Lines]",
          "124:   EXT4_I(filp->f_path.dentry->d_inode)->i_flags &= ~EXT4_INDEX_FL;",
          "",
          "[Added Lines]",
          "124:   ext4_clear_inode_flag(filp->f_path.dentry->d_inode, EXT4_INODE_INDEX);",
          "",
          "---------------"
        ],
        "fs/ext4/ext4.h||fs/ext4/ext4.h": [
          "File: fs/ext4/ext4.h -> fs/ext4/ext4.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "344:   return flags & EXT4_OTHER_FLMASK;",
          "345: }",
          "348: struct ext4_new_group_input {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "350: enum {",
          "360:  EXT4_INODE_DIRTY = 8,",
          "376: };",
          "378: #define TEST_FLAG_VALUE(FLAG) (EXT4_##FLAG##_FL == (1 << EXT4_INODE_##FLAG))",
          "379: #define CHECK_FLAG_VALUE(FLAG) if (!TEST_FLAG_VALUE(FLAG)) { \\",
          "380:  printk(KERN_EMERG \"EXT4 flag fail: \" #FLAG \": %d %d\\n\", \\",
          "381:   EXT4_##FLAG##_FL, EXT4_INODE_##FLAG); BUG_ON(1); }",
          "397: static inline void ext4_check_flag_values(void)",
          "398: {",
          "399:  CHECK_FLAG_VALUE(SECRM);",
          "400:  CHECK_FLAG_VALUE(UNRM);",
          "401:  CHECK_FLAG_VALUE(COMPR);",
          "402:  CHECK_FLAG_VALUE(SYNC);",
          "403:  CHECK_FLAG_VALUE(IMMUTABLE);",
          "404:  CHECK_FLAG_VALUE(APPEND);",
          "405:  CHECK_FLAG_VALUE(NODUMP);",
          "406:  CHECK_FLAG_VALUE(NOATIME);",
          "407:  CHECK_FLAG_VALUE(DIRTY);",
          "408:  CHECK_FLAG_VALUE(COMPRBLK);",
          "409:  CHECK_FLAG_VALUE(NOCOMPR);",
          "410:  CHECK_FLAG_VALUE(ECOMPR);",
          "411:  CHECK_FLAG_VALUE(INDEX);",
          "412:  CHECK_FLAG_VALUE(IMAGIC);",
          "413:  CHECK_FLAG_VALUE(JOURNAL_DATA);",
          "414:  CHECK_FLAG_VALUE(NOTAIL);",
          "415:  CHECK_FLAG_VALUE(DIRSYNC);",
          "416:  CHECK_FLAG_VALUE(TOPDIR);",
          "417:  CHECK_FLAG_VALUE(HUGE_FILE);",
          "418:  CHECK_FLAG_VALUE(EXTENTS);",
          "419:  CHECK_FLAG_VALUE(EA_INODE);",
          "420:  CHECK_FLAG_VALUE(EOFBLOCKS);",
          "421:  CHECK_FLAG_VALUE(RESERVED);",
          "422: }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "640: struct ext4_inode_info {",
          "644:  __u32 i_dtime;",
          "",
          "[Removed Lines]",
          "642:  __u32 i_flags;",
          "643:  ext4_fsblk_t i_file_acl;",
          "",
          "[Added Lines]",
          "720:  ext4_fsblk_t i_file_acl;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "653:  ext4_group_t i_block_group;",
          "656:  ext4_lblk_t  i_dir_start_lookup;",
          "657: #ifdef CONFIG_EXT4_FS_XATTR",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "731:  unsigned long i_flags;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1088: };",
          "1093: }",
          "1104: #else",
          "",
          "[Removed Lines]",
          "1090: static inline int ext4_test_inode_state(struct inode *inode, int bit)",
          "1091: {",
          "1092:  return test_bit(bit, &EXT4_I(inode)->i_state_flags);",
          "1095: static inline void ext4_set_inode_state(struct inode *inode, int bit)",
          "1096: {",
          "1097:  set_bit(bit, &EXT4_I(inode)->i_state_flags);",
          "1098: }",
          "1100: static inline void ext4_clear_inode_state(struct inode *inode, int bit)",
          "1101: {",
          "1102:  clear_bit(bit, &EXT4_I(inode)->i_state_flags);",
          "1103: }",
          "",
          "[Added Lines]",
          "1167: #define EXT4_INODE_BIT_FNS(name, field)     \\",
          "1168: static inline int ext4_test_inode_##name(struct inode *inode, int bit) \\",
          "1169: {         \\",
          "1170:  return test_bit(bit, &EXT4_I(inode)->i_##field);  \\",
          "1171: }         \\",
          "1172: static inline void ext4_set_inode_##name(struct inode *inode, int bit) \\",
          "1173: {         \\",
          "1174:  set_bit(bit, &EXT4_I(inode)->i_##field);   \\",
          "1175: }         \\",
          "1176: static inline void ext4_clear_inode_##name(struct inode *inode, int bit) \\",
          "1177: {         \\",
          "1178:  clear_bit(bit, &EXT4_I(inode)->i_##field);   \\",
          "1181: EXT4_INODE_BIT_FNS(flag, flags)",
          "1182: EXT4_INODE_BIT_FNS(state, state_flags)",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1288: #define is_dx(dir) (EXT4_HAS_COMPAT_FEATURE(dir->i_sb, \\",
          "1289:           EXT4_FEATURE_COMPAT_DIR_INDEX) && \\",
          "1291: #define EXT4_DIR_LINK_MAX(dir) (!is_dx(dir) && (dir)->i_nlink >= EXT4_LINK_MAX)",
          "1292: #define EXT4_DIR_LINK_EMPTY(dir) ((dir)->i_nlink == 2 || (dir)->i_nlink == 1)",
          "",
          "[Removed Lines]",
          "1290:         (EXT4_I(dir)->i_flags & EXT4_INDEX_FL))",
          "",
          "[Added Lines]",
          "1369:       ext4_test_inode_flag((dir), EXT4_INODE_INDEX))",
          "",
          "---------------"
        ],
        "fs/ext4/ext4_jbd2.h||fs/ext4/ext4_jbd2.h": [
          "File: fs/ext4/ext4_jbd2.h -> fs/ext4/ext4_jbd2.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "273:   return 1;",
          "274:  if (test_opt(inode->i_sb, DATA_FLAGS) == EXT4_MOUNT_JOURNAL_DATA)",
          "275:   return 1;",
          "277:   return 1;",
          "278:  return 0;",
          "279: }",
          "",
          "[Removed Lines]",
          "276:  if (EXT4_I(inode)->i_flags & EXT4_JOURNAL_DATA_FL)",
          "",
          "[Added Lines]",
          "276:  if (ext4_test_inode_flag(inode, EXT4_INODE_JOURNAL_DATA))",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "284:   return 0;",
          "285:  if (!S_ISREG(inode->i_mode))",
          "286:   return 0;",
          "288:   return 0;",
          "289:  if (test_opt(inode->i_sb, DATA_FLAGS) == EXT4_MOUNT_ORDERED_DATA)",
          "290:   return 1;",
          "",
          "[Removed Lines]",
          "287:  if (EXT4_I(inode)->i_flags & EXT4_JOURNAL_DATA_FL)",
          "",
          "[Added Lines]",
          "287:  if (ext4_test_inode_flag(inode, EXT4_INODE_JOURNAL_DATA))",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "297:   return 0;",
          "298:  if (EXT4_JOURNAL(inode) == NULL)",
          "299:   return 1;",
          "301:   return 0;",
          "302:  if (test_opt(inode->i_sb, DATA_FLAGS) == EXT4_MOUNT_WRITEBACK_DATA)",
          "303:   return 1;",
          "",
          "[Removed Lines]",
          "300:  if (EXT4_I(inode)->i_flags & EXT4_JOURNAL_DATA_FL)",
          "",
          "[Added Lines]",
          "300:  if (ext4_test_inode_flag(inode, EXT4_INODE_JOURNAL_DATA))",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "321:   return 0;",
          "322:  if (!S_ISREG(inode->i_mode))",
          "323:   return 0;",
          "325:   return 0;",
          "326:  if (ext4_should_journal_data(inode))",
          "327:   return 0;",
          "",
          "[Removed Lines]",
          "324:  if (!(EXT4_I(inode)->i_flags & EXT4_EXTENTS_FL))",
          "",
          "[Added Lines]",
          "324:  if (!(ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS)))",
          "",
          "---------------"
        ],
        "fs/ext4/extents.c||fs/ext4/extents.c": [
          "File: fs/ext4/extents.c -> fs/ext4/extents.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "3498:    map->m_flags |= EXT4_MAP_UNINIT;",
          "3499:  }",
          "3502:   if (unlikely(!eh->eh_entries)) {",
          "3503:    EXT4_ERROR_INODE(inode,",
          "3504:       \"eh->eh_entries == 0 ee_block %d\",",
          "",
          "[Removed Lines]",
          "3501:  if (unlikely(EXT4_I(inode)->i_flags & EXT4_EOFBLOCKS_FL)) {",
          "",
          "[Added Lines]",
          "3501:  if (unlikely(ext4_test_inode_flag(inode, EXT4_INODE_EOFBLOCKS))) {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "3509:   last_ex = EXT_LAST_EXTENT(eh);",
          "3510:   if (map->m_lblk + ar.len > le32_to_cpu(last_ex->ee_block)",
          "3511:       + ext4_ext_get_actual_len(last_ex))",
          "3513:  }",
          "3514:  err = ext4_ext_insert_extent(handle, inode, path, &newex, flags);",
          "3515:  if (err) {",
          "",
          "[Removed Lines]",
          "3512:    EXT4_I(inode)->i_flags &= ~EXT4_EOFBLOCKS_FL;",
          "",
          "[Added Lines]",
          "3512:    ext4_clear_inode_flag(inode, EXT4_INODE_EOFBLOCKS);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "3652:   if (new_size > i_size_read(inode))",
          "3654:  }",
          "3656: }",
          "",
          "[Removed Lines]",
          "3653:    EXT4_I(inode)->i_flags |= EXT4_EOFBLOCKS_FL;",
          "",
          "[Added Lines]",
          "3653:    ext4_set_inode_flag(inode, EXT4_INODE_EOFBLOCKS);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "3681:   return -EOPNOTSUPP;",
          "",
          "[Removed Lines]",
          "3680:  if (!(EXT4_I(inode)->i_flags & EXT4_EXTENTS_FL))",
          "",
          "[Added Lines]",
          "3680:  if (!(ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS)))",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "3922:  int error = 0;",
          "3926:   return generic_block_fiemap(inode, fieinfo, start, len,",
          "3927:    ext4_get_block);",
          "",
          "[Removed Lines]",
          "3925:  if (!(EXT4_I(inode)->i_flags & EXT4_EXTENTS_FL))",
          "",
          "[Added Lines]",
          "3925:  if (!(ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS)))",
          "",
          "---------------"
        ],
        "fs/ext4/file.c||fs/ext4/file.c": [
          "File: fs/ext4/file.c -> fs/ext4/file.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "70:   struct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);",
          "71:   size_t length = iov_length(iov, nr_segs);",
          "",
          "[Removed Lines]",
          "69:  if (!(EXT4_I(inode)->i_flags & EXT4_EXTENTS_FL)) {",
          "",
          "[Added Lines]",
          "69:  if (!(ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS))) {",
          "",
          "---------------"
        ],
        "fs/ext4/ialloc.c||fs/ext4/ialloc.c": [
          "File: fs/ext4/ialloc.c -> fs/ext4/ialloc.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "493:  if (S_ISDIR(mode) &&",
          "494:      ((parent == sb->s_root->d_inode) ||",
          "496:   int best_ndir = inodes_per_group;",
          "497:   int ret = -1;",
          "",
          "[Removed Lines]",
          "495:       (EXT4_I(parent)->i_flags & EXT4_TOPDIR_FL))) {",
          "",
          "[Added Lines]",
          "495:       (ext4_test_inode_flag(parent, EXT4_INODE_TOPDIR)))) {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1038:  if (EXT4_HAS_INCOMPAT_FEATURE(sb, EXT4_FEATURE_INCOMPAT_EXTENTS)) {",
          "1040:   if (S_ISDIR(mode) || S_ISREG(mode) || S_ISLNK(mode)) {",
          "1042:    ext4_ext_tree_init(handle, inode);",
          "1043:   }",
          "1044:  }",
          "",
          "[Removed Lines]",
          "1041:    EXT4_I(inode)->i_flags |= EXT4_EXTENTS_FL;",
          "",
          "[Added Lines]",
          "1041:    ext4_set_inode_flag(inode, EXT4_INODE_EXTENTS);",
          "",
          "---------------"
        ],
        "fs/ext4/inode.c||fs/ext4/inode.c": [
          "File: fs/ext4/inode.c -> fs/ext4/inode.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "931:  int count = 0;",
          "932:  ext4_fsblk_t first_block = 0;",
          "935:  J_ASSERT(handle != NULL || (flags & EXT4_GET_BLOCKS_CREATE) == 0);",
          "936:  depth = ext4_block_to_path(inode, map->m_lblk, offsets,",
          "937:        &blocks_to_boundary);",
          "",
          "[Removed Lines]",
          "934:  J_ASSERT(!(EXT4_I(inode)->i_flags & EXT4_EXTENTS_FL));",
          "",
          "[Added Lines]",
          "934:  J_ASSERT(!(ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS)));",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1060: static int ext4_calc_metadata_amount(struct inode *inode, sector_t lblock)",
          "1061: {",
          "1063:   return ext4_ext_calc_metadata_amount(inode, lblock);",
          "1065:  return ext4_indirect_calc_metadata_amount(inode, lblock);",
          "",
          "[Removed Lines]",
          "1062:  if (EXT4_I(inode)->i_flags & EXT4_EXTENTS_FL)",
          "",
          "[Added Lines]",
          "1062:  if (ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS))",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1238:  down_read((&EXT4_I(inode)->i_data_sem));",
          "1240:   retval = ext4_ext_map_blocks(handle, inode, map, 0);",
          "1241:  } else {",
          "1242:   retval = ext4_ind_map_blocks(handle, inode, map, 0);",
          "",
          "[Removed Lines]",
          "1239:  if (EXT4_I(inode)->i_flags & EXT4_EXTENTS_FL) {",
          "",
          "[Added Lines]",
          "1239:  if (ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS)) {",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1299:   retval = ext4_ext_map_blocks(handle, inode, map, flags);",
          "1300:  } else {",
          "1301:   retval = ext4_ind_map_blocks(handle, inode, map, flags);",
          "",
          "[Removed Lines]",
          "1298:  if (EXT4_I(inode)->i_flags & EXT4_EXTENTS_FL) {",
          "",
          "[Added Lines]",
          "1298:  if (ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS)) {",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "2325:   goto flush_it;",
          "2329:   if (nrblocks >= EXT4_MAX_TRANS_DATA) {",
          "",
          "[Removed Lines]",
          "2328:  if (!(EXT4_I(mpd->inode)->i_flags & EXT4_EXTENTS_FL)) {",
          "",
          "[Added Lines]",
          "2328:  if (!(ext4_test_inode_flag(mpd->inode, EXT4_INODE_EXTENTS))) {",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "2783:      (max_blocks > EXT4_MAX_TRANS_DATA))",
          "2784:   max_blocks = EXT4_MAX_TRANS_DATA;",
          "",
          "[Removed Lines]",
          "2782:  if (!(EXT4_I(inode)->i_flags & EXT4_EXTENTS_FL) &&",
          "",
          "[Added Lines]",
          "2782:  if (!(ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS)) &&",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "3995:  struct file *file = iocb->ki_filp;",
          "3996:  struct inode *inode = file->f_mapping->host;",
          "3999:   return ext4_ext_direct_IO(rw, iocb, iov, offset, nr_segs);",
          "4001:  return ext4_ind_direct_IO(rw, iocb, iov, offset, nr_segs);",
          "",
          "[Removed Lines]",
          "3998:  if (EXT4_I(inode)->i_flags & EXT4_EXTENTS_FL)",
          "",
          "[Added Lines]",
          "3998:  if (ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS))",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "4631:  if (!ext4_can_truncate(inode))",
          "4632:   return;",
          "4636:  if (inode->i_size == 0 && !test_opt(inode->i_sb, NO_AUTO_DA_ALLOC))",
          "4637:   ext4_set_inode_state(inode, EXT4_STATE_DA_ALLOC_CLOSE);",
          "4640:   ext4_ext_truncate(inode);",
          "4641:   return;",
          "4642:  }",
          "",
          "[Removed Lines]",
          "4634:  EXT4_I(inode)->i_flags &= ~EXT4_EOFBLOCKS_FL;",
          "4639:  if (EXT4_I(inode)->i_flags & EXT4_EXTENTS_FL) {",
          "",
          "[Added Lines]",
          "4634:  ext4_clear_inode_flag(inode, EXT4_INODE_EOFBLOCKS);",
          "4639:  if (ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS)) {",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "5473:  }",
          "5475:  if (attr->ia_valid & ATTR_SIZE) {",
          "5477:    struct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);",
          "5479:    if (attr->ia_size > sbi->s_bitmap_maxbytes) {",
          "",
          "[Removed Lines]",
          "5476:   if (!(EXT4_I(inode)->i_flags & EXT4_EXTENTS_FL)) {",
          "",
          "[Added Lines]",
          "5476:   if (!(ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS))) {",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "5486:  if (S_ISREG(inode->i_mode) &&",
          "5487:      attr->ia_valid & ATTR_SIZE &&",
          "5488:      (attr->ia_size < inode->i_size ||",
          "5490:   handle_t *handle;",
          "5492:   handle = ext4_journal_start(inode, 3);",
          "",
          "[Removed Lines]",
          "5489:       (EXT4_I(inode)->i_flags & EXT4_EOFBLOCKS_FL))) {",
          "",
          "[Added Lines]",
          "5489:       (ext4_test_inode_flag(inode, EXT4_INODE_EOFBLOCKS)))) {",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "5518:    }",
          "5519:   }",
          "5522:    ext4_truncate(inode);",
          "5523:  }",
          "",
          "[Removed Lines]",
          "5521:   if ((EXT4_I(inode)->i_flags & EXT4_EOFBLOCKS_FL))",
          "",
          "[Added Lines]",
          "5521:   if ((ext4_test_inode_flag(inode, EXT4_INODE_EOFBLOCKS)))",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "5595: static int ext4_index_trans_blocks(struct inode *inode, int nrblocks, int chunk)",
          "5596: {",
          "5598:   return ext4_indirect_trans_blocks(inode, nrblocks, chunk);",
          "5599:  return ext4_ext_index_trans_blocks(inode, nrblocks, chunk);",
          "5600: }",
          "",
          "[Removed Lines]",
          "5597:  if (!(EXT4_I(inode)->i_flags & EXT4_EXTENTS_FL))",
          "",
          "[Added Lines]",
          "5597:  if (!(ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS)))",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "5931:  if (val)",
          "5933:  else",
          "5935:  ext4_set_aops(inode);",
          "5937:  jbd2_journal_unlock_updates(journal);",
          "",
          "[Removed Lines]",
          "5932:   EXT4_I(inode)->i_flags |= EXT4_JOURNAL_DATA_FL;",
          "5934:   EXT4_I(inode)->i_flags &= ~EXT4_JOURNAL_DATA_FL;",
          "",
          "[Added Lines]",
          "5932:   ext4_set_inode_flag(inode, EXT4_INODE_JOURNAL_DATA);",
          "5934:   ext4_clear_inode_flag(inode, EXT4_INODE_JOURNAL_DATA);",
          "",
          "---------------"
        ],
        "fs/ext4/mballoc.c||fs/ext4/mballoc.c": [
          "File: fs/ext4/mballoc.c -> fs/ext4/mballoc.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "2006:  sbi = EXT4_SB(sb);",
          "2007:  ngroups = ext4_get_groups_count(sb);",
          "2010:   ngroups = sbi->s_blockfile_groups;",
          "2012:  BUG_ON(ac->ac_status == AC_STATUS_FOUND);",
          "",
          "[Removed Lines]",
          "2009:  if (!(EXT4_I(ac->ac_inode)->i_flags & EXT4_EXTENTS_FL))",
          "",
          "[Added Lines]",
          "2009:  if (!(ext4_test_inode_flag(ac->ac_inode, EXT4_INODE_EXTENTS)))",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "3171:    continue;",
          "3175:    pa->pa_pstart + pa->pa_len > EXT4_MAX_BLOCK_FILE_PHYS)",
          "3176:    continue;",
          "",
          "[Removed Lines]",
          "3174:   if (!(EXT4_I(ac->ac_inode)->i_flags & EXT4_EXTENTS_FL) &&",
          "",
          "[Added Lines]",
          "3174:   if (!(ext4_test_inode_flag(ac->ac_inode, EXT4_INODE_EXTENTS)) &&",
          "",
          "---------------"
        ],
        "fs/ext4/migrate.c||fs/ext4/migrate.c": [
          "File: fs/ext4/migrate.c -> fs/ext4/migrate.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "476:  if (!EXT4_HAS_INCOMPAT_FEATURE(inode->i_sb,",
          "477:            EXT4_FEATURE_INCOMPAT_EXTENTS) ||",
          "479:   return -EINVAL;",
          "481:  if (S_ISLNK(inode->i_mode) && inode->i_blocks == 0)",
          "",
          "[Removed Lines]",
          "478:      (EXT4_I(inode)->i_flags & EXT4_EXTENTS_FL))",
          "",
          "[Added Lines]",
          "478:      (ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS)))",
          "",
          "---------------"
        ],
        "fs/ext4/move_extent.c||fs/ext4/move_extent.c": [
          "File: fs/ext4/move_extent.c -> fs/ext4/move_extent.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "977:  }",
          "981:   ext4_debug(\"ext4 move extent: orig file is not extents \"",
          "982:    \"based file [ino:orig %lu]\\n\", orig_inode->i_ino);",
          "983:   return -EOPNOTSUPP;",
          "985:   ext4_debug(\"ext4 move extent: donor file is not extents \"",
          "986:    \"based file [ino:donor %lu]\\n\", donor_inode->i_ino);",
          "987:   return -EOPNOTSUPP;",
          "",
          "[Removed Lines]",
          "980:  if (!(EXT4_I(orig_inode)->i_flags & EXT4_EXTENTS_FL)) {",
          "984:  } else if (!(EXT4_I(donor_inode)->i_flags & EXT4_EXTENTS_FL)) {",
          "",
          "[Added Lines]",
          "980:  if (!(ext4_test_inode_flag(orig_inode, EXT4_INODE_EXTENTS))) {",
          "984:  } else if (!(ext4_test_inode_flag(donor_inode, EXT4_INODE_EXTENTS))) {",
          "",
          "---------------"
        ],
        "fs/ext4/namei.c||fs/ext4/namei.c": [
          "File: fs/ext4/namei.c -> fs/ext4/namei.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "656:  dxtrace(printk(KERN_DEBUG \"In htree_fill_tree, start hash: %x:%x\\n\",",
          "657:          start_hash, start_minor_hash));",
          "658:  dir = dir_file->f_path.dentry->d_inode;",
          "660:   hinfo.hash_version = EXT4_SB(dir->i_sb)->s_def_hash_version;",
          "661:   if (hinfo.hash_version <= DX_HASH_TEA)",
          "662:    hinfo.hash_version +=",
          "",
          "[Removed Lines]",
          "659:  if (!(EXT4_I(dir)->i_flags & EXT4_INDEX_FL)) {",
          "",
          "[Added Lines]",
          "659:  if (!(ext4_test_inode_flag(dir, EXT4_INODE_INDEX))) {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "801: {",
          "802:  if (!EXT4_HAS_COMPAT_FEATURE(inode->i_sb,",
          "803:          EXT4_FEATURE_COMPAT_DIR_INDEX))",
          "805: }",
          "",
          "[Removed Lines]",
          "804:   EXT4_I(inode)->i_flags &= ~EXT4_INDEX_FL;",
          "",
          "[Added Lines]",
          "804:   ext4_clear_inode_flag(inode, EXT4_INODE_INDEX);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1416:   brelse(bh);",
          "1417:   return retval;",
          "1418:  }",
          "1420:  data1 = bh2->b_data;",
          "1422:  memcpy (data1, de, len);",
          "",
          "[Removed Lines]",
          "1419:  EXT4_I(dir)->i_flags |= EXT4_INDEX_FL;",
          "",
          "[Added Lines]",
          "1419:  ext4_set_inode_flag(dir, EXT4_INODE_INDEX);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1489:   retval = ext4_dx_add_entry(handle, dentry, inode);",
          "1490:   if (!retval || (retval != ERR_BAD_DX_DIR))",
          "1491:    return retval;",
          "1493:   dx_fallback++;",
          "1494:   ext4_mark_inode_dirty(handle, dir);",
          "1495:  }",
          "",
          "[Removed Lines]",
          "1492:   EXT4_I(dir)->i_flags &= ~EXT4_INDEX_FL;",
          "",
          "[Added Lines]",
          "1492:   ext4_clear_inode_flag(dir, EXT4_INODE_INDEX);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "2294:   }",
          "2295:  } else {",
          "2298:   inode->i_op = &ext4_fast_symlink_inode_operations;",
          "2299:   memcpy((char *)&EXT4_I(inode)->i_data, symname, l);",
          "2300:   inode->i_size = l-1;",
          "",
          "[Removed Lines]",
          "2297:   EXT4_I(inode)->i_flags &= ~EXT4_EXTENTS_FL;",
          "",
          "[Added Lines]",
          "2297:   ext4_clear_inode_flag(inode, EXT4_INODE_EXTENTS);",
          "",
          "---------------"
        ],
        "fs/ext4/super.c||fs/ext4/super.c": [
          "File: fs/ext4/super.c -> fs/ext4/super.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "4148: {",
          "4149:  int err;",
          "4151:  err = init_ext4_system_zone();",
          "4152:  if (err)",
          "4153:   return err;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4151:  ext4_check_flag_values();",
          "",
          "---------------"
        ],
        "fs/ext4/xattr.c||fs/ext4/xattr.c": [
          "File: fs/ext4/xattr.c -> fs/ext4/xattr.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "818:       EXT4_I(inode)->i_block_group);",
          "822:     goal = goal & EXT4_MAX_BLOCK_FILE_PHYS;",
          "824:    block = ext4_new_meta_blocks(handle, inode,",
          "",
          "[Removed Lines]",
          "821:    if (!(EXT4_I(inode)->i_flags & EXT4_EXTENTS_FL))",
          "",
          "[Added Lines]",
          "821:    if (!(ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS)))",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "826:    if (error)",
          "827:     goto cleanup;",
          "830:     BUG_ON(block > EXT4_MAX_BLOCK_FILE_PHYS);",
          "832:    ea_idebug(inode, \"creating block %d\", block);",
          "",
          "[Removed Lines]",
          "829:    if (!(EXT4_I(inode)->i_flags & EXT4_EXTENTS_FL))",
          "",
          "[Added Lines]",
          "829:    if (!(ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS)))",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "8d5d02e6b176565c77ff03604908b1453a22044d",
      "candidate_info": {
        "commit_hash": "8d5d02e6b176565c77ff03604908b1453a22044d",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/8d5d02e6b176565c77ff03604908b1453a22044d",
        "files": [
          "fs/ext4/ext4.h",
          "fs/ext4/extents.c",
          "fs/ext4/fsync.c",
          "fs/ext4/inode.c",
          "fs/ext4/super.c"
        ],
        "message": "ext4: async direct IO for holes and fallocate support\n\nFor async direct IO that covers holes or fallocate, the end_io\ncallback function now queued the convertion work on workqueue but\ndon't flush the work rightaway as it might take too long to afford.\n\nBut when fsync is called after all the data is completed, user expects\nthe metadata also being updated before fsync returns.\n\nThus we need to flush the conversion work when fsync() is called.\nThis patch keep track of a listed of completed async direct io that\nhas a work queued on workqueue.  When fsync() is called, it will go\nthrough the list and do the conversion.\n\nSigned-off-by: Mingming Cao <cmm@us.ibm.com>",
        "before_after_code_files": [
          "fs/ext4/ext4.h||fs/ext4/ext4.h",
          "fs/ext4/extents.c||fs/ext4/extents.c",
          "fs/ext4/fsync.c||fs/ext4/fsync.c",
          "fs/ext4/inode.c||fs/ext4/inode.c",
          "fs/ext4/super.c||fs/ext4/super.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "fs/ext4/ext4.h||fs/ext4/ext4.h",
            "fs/ext4/extents.c||fs/ext4/extents.c",
            "fs/ext4/inode.c||fs/ext4/inode.c",
            "fs/ext4/super.c||fs/ext4/super.c"
          ],
          "candidate": [
            "fs/ext4/ext4.h||fs/ext4/ext4.h",
            "fs/ext4/extents.c||fs/ext4/extents.c",
            "fs/ext4/inode.c||fs/ext4/inode.c",
            "fs/ext4/super.c||fs/ext4/super.c"
          ]
        }
      },
      "candidate_diff": {
        "fs/ext4/ext4.h||fs/ext4/ext4.h": [
          "File: fs/ext4/ext4.h -> fs/ext4/ext4.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "127:  int pages_written;",
          "128:  int retval;",
          "129: };",
          "131: typedef struct ext4_io_end {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "130: #define DIO_AIO_UNWRITTEN 0x1",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "690:  __u16 i_extra_isize;",
          "692:  spinlock_t i_block_reservation_lock;",
          "693: };",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "696:  struct list_head i_aio_dio_complete_list;",
          "698:  ext4_io_end_t *cur_aio_dio;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1419:   struct address_space *mapping, loff_t from);",
          "1420: extern int ext4_page_mkwrite(struct vm_area_struct *vma, struct vm_fault *vmf);",
          "1421: extern qsize_t ext4_get_reserved_space(struct inode *inode);",
          "1424: extern long ext4_ioctl(struct file *, unsigned int, unsigned long);",
          "1425: extern long ext4_compat_ioctl(struct file *, unsigned int, unsigned long);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1428: extern int flush_aio_dio_completed_IO(struct inode *inode);",
          "",
          "---------------"
        ],
        "fs/ext4/extents.c||fs/ext4/extents.c": [
          "File: fs/ext4/extents.c -> fs/ext4/extents.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "3033: {",
          "3034:  int ret = 0;",
          "3035:  int err = 0;",
          "3037:  ext_debug(\"ext4_ext_handle_uninitialized_extents: inode %lu, logical\"",
          "3038:     \"block %llu, max_blocks %u, flags %d, allocated %u\",",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3036:  ext4_io_end_t *io = EXT4_I(inode)->cur_aio_dio;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "3045:   ret = ext4_split_unwritten_extents(handle,",
          "3046:       inode, path, iblock,",
          "3047:       max_blocks, flags);",
          "3048:   goto out;",
          "3049:  }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3050:   if (io)",
          "3051:    io->flag = DIO_AIO_UNWRITTEN;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "3130:  int err = 0, depth, ret, cache_type;",
          "3131:  unsigned int allocated = 0;",
          "3132:  struct ext4_allocation_request ar;",
          "3134:  __clear_bit(BH_New, &bh_result->b_state);",
          "3135:  ext_debug(\"blocks %u/%u requested for inode %lu\\n\",",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3137:  ext4_io_end_t *io = EXT4_I(inode)->cur_aio_dio;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "3280:  ext4_ext_store_pblock(&newex, newblock);",
          "3281:  newex.ee_len = cpu_to_le16(ar.len);",
          "3283:   ext4_ext_mark_uninitialized(&newex);",
          "3284:  err = ext4_ext_insert_extent(handle, inode, path, &newex, flags);",
          "3285:  if (err) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3288:  if (flags & EXT4_GET_BLOCKS_UNINIT_EXT){",
          "3298:   if (io && flags == EXT4_GET_BLOCKS_DIO_CREATE_EXT)",
          "3299:    io->flag = DIO_AIO_UNWRITTEN;",
          "3300:  }",
          "",
          "---------------"
        ],
        "fs/ext4/fsync.c||fs/ext4/fsync.c": [
          "File: fs/ext4/fsync.c -> fs/ext4/fsync.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "57:  trace_ext4_sync_file(file, dentry, datasync);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "61:  ret = flush_aio_dio_completed_IO(inode);",
          "62:  if (ret < 0)",
          "63:   goto out;",
          "",
          "---------------"
        ],
        "fs/ext4/inode.c||fs/ext4/inode.c": [
          "File: fs/ext4/inode.c -> fs/ext4/inode.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "3451:  unsigned max_blocks = bh_result->b_size >> inode->i_blkbits;",
          "3452:  int dio_credits;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3454:  ext4_debug(\"ext4_get_block_dio_write: inode %lu, create flag %d\\n\",",
          "3455:      inode->i_ino, create);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "3491:  return ret;",
          "3492: }",
          "3496: static void ext4_free_io_end(ext4_io_end_t *io)",
          "3497: {",
          "3498:  kfree(io);",
          "3499: }",
          "3507: {",
          "3509:  struct inode *inode = io->inode;",
          "3510:  loff_t offset = io->offset;",
          "3511:  size_t size = io->size;",
          "3512:  int ret = 0;",
          "3517:  if (offset + size <= i_size_read(inode))",
          "3518:   ret = ext4_convert_unwritten_extents(inode, offset, size);",
          "3521:   printk(KERN_EMERG \"%s: failed to convert unwritten\"",
          "3528: }",
          "3531: {",
          "3532:  ext4_io_end_t *io = NULL;",
          "3534:  io = kmalloc(sizeof(*io), GFP_NOFS);",
          "3536:  if (io) {",
          "3537:   io->inode = inode;",
          "3539:   io->offset = 0;",
          "3540:   io->size = 0;",
          "3541:   io->error = 0;",
          "3543:  }",
          "3545:  return io;",
          "",
          "[Removed Lines]",
          "3494: #define  DIO_AIO  0x1",
          "3506: static void ext4_end_dio_unwritten(struct work_struct *work)",
          "3508:  ext4_io_end_t *io = container_of(work, ext4_io_end_t, work);",
          "3513:  int aio = io->flag & DIO_AIO;",
          "3515:  if (aio)",
          "3516:   mutex_lock(&inode->i_mutex);",
          "3520:  if (ret < 0)",
          "3522:    \"extents to written extents, error is %d\\n\",",
          "3523:                        __func__, ret);",
          "3525:  ext4_free_io_end(io);",
          "3526:  if (aio)",
          "3527:   mutex_unlock(&inode->i_mutex);",
          "3530: static ext4_io_end_t *ext4_init_io_end (struct inode *inode, unsigned int flag)",
          "3538:   io->flag = flag;",
          "3542:   INIT_WORK(&io->work, ext4_end_dio_unwritten);",
          "",
          "[Added Lines]",
          "3498:  BUG_ON(!io);",
          "3499:  iput(io->inode);",
          "3502: static void dump_aio_dio_list(struct inode * inode)",
          "3503: {",
          "3504: #ifdef EXT4_DEBUG",
          "3505:  struct list_head *cur, *before, *after;",
          "3506:  ext4_io_end_t *io, *io0, *io1;",
          "3508:  if (list_empty(&EXT4_I(inode)->i_aio_dio_complete_list)){",
          "3509:   ext4_debug(\"inode %lu aio dio list is empty\\n\", inode->i_ino);",
          "3510:   return;",
          "3511:  }",
          "3513:  ext4_debug(\"Dump inode %lu aio_dio_completed_IO list \\n\", inode->i_ino);",
          "3514:  list_for_each_entry(io, &EXT4_I(inode)->i_aio_dio_complete_list, list){",
          "3515:   cur = &io->list;",
          "3516:   before = cur->prev;",
          "3517:   io0 = container_of(before, ext4_io_end_t, list);",
          "3518:   after = cur->next;",
          "3519:   io1 = container_of(after, ext4_io_end_t, list);",
          "3521:   ext4_debug(\"io 0x%p from inode %lu,prev 0x%p,next 0x%p\\n\",",
          "3522:        io, inode->i_ino, io0, io1);",
          "3523:  }",
          "3524: #endif",
          "3525: }",
          "3530: static int ext4_end_aio_dio_nolock(ext4_io_end_t *io)",
          "3537:  ext4_debug(\"end_aio_dio_onlock: io 0x%p from inode %lu,list->next 0x%p,\"",
          "3538:      \"list->prev 0x%p\\n\",",
          "3539:             io, inode->i_ino, io->list.next, io->list.prev);",
          "3541:  if (list_empty(&io->list))",
          "3542:   return ret;",
          "3544:  if (io->flag != DIO_AIO_UNWRITTEN)",
          "3545:   return ret;",
          "3550:  if (ret < 0) {",
          "3552:    \"extents to written extents, error is %d\"",
          "3553:    \" io is still on inode %lu aio dio list\\n\",",
          "3554:                        __func__, ret, inode->i_ino);",
          "3555:   return ret;",
          "3556:  }",
          "3559:  io->flag = 0;",
          "3560:  return ret;",
          "3565: static void ext4_end_aio_dio_work(struct work_struct *work)",
          "3566: {",
          "3567:  ext4_io_end_t *io  = container_of(work, ext4_io_end_t, work);",
          "3568:  struct inode *inode = io->inode;",
          "3569:  int ret = 0;",
          "3571:  mutex_lock(&inode->i_mutex);",
          "3572:  ret = ext4_end_aio_dio_nolock(io);",
          "3573:  if (ret >= 0) {",
          "3574:   if (!list_empty(&io->list))",
          "3575:    list_del_init(&io->list);",
          "3576:   ext4_free_io_end(io);",
          "3577:  }",
          "3578:  mutex_unlock(&inode->i_mutex);",
          "3579: }",
          "3591: int flush_aio_dio_completed_IO(struct inode *inode)",
          "3592: {",
          "3593:  ext4_io_end_t *io;",
          "3594:  int ret = 0;",
          "3595:  int ret2 = 0;",
          "3597:  if (list_empty(&EXT4_I(inode)->i_aio_dio_complete_list))",
          "3598:   return ret;",
          "3600:  dump_aio_dio_list(inode);",
          "3601:  while (!list_empty(&EXT4_I(inode)->i_aio_dio_complete_list)){",
          "3602:   io = list_entry(EXT4_I(inode)->i_aio_dio_complete_list.next,",
          "3603:     ext4_io_end_t, list);",
          "3618:   ret = ext4_end_aio_dio_nolock(io);",
          "3619:   if (ret < 0)",
          "3620:    ret2 = ret;",
          "3621:   else",
          "3622:    list_del_init(&io->list);",
          "3623:  }",
          "3624:  return (ret2 < 0) ? ret2 : 0;",
          "3625: }",
          "3627: static ext4_io_end_t *ext4_init_io_end (struct inode *inode)",
          "3634:   igrab(inode);",
          "3636:   io->flag = 0;",
          "3640:   INIT_WORK(&io->work, ext4_end_aio_dio_work);",
          "3641:   INIT_LIST_HEAD(&io->list);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "3551:         ext4_io_end_t *io_end = iocb->private;",
          "3552:  struct workqueue_struct *wq;",
          "3556:   return;",
          "3557:  io_end->offset = offset;",
          "3558:  io_end->size = size;",
          "3559:  wq = EXT4_SB(io_end->inode->i_sb)->dio_unwritten_wq;",
          "3562:  queue_work(wq, &io_end->work);",
          "3567:  iocb->private = NULL;",
          "3568: }",
          "",
          "[Removed Lines]",
          "3555:  if (!io_end || !size || !iocb->private)",
          "3564:         if (is_sync_kiocb(iocb))",
          "3565:   flush_workqueue(wq);",
          "",
          "[Added Lines]",
          "3653:  ext_debug(\"ext4_end_io_dio(): io_end 0x%p\"",
          "3654:     \"for inode %lu, iocb 0x%p, offset %llu, size %llu\\n\",",
          "3655:      iocb->private, io_end->inode->i_ino, iocb, offset,",
          "3656:     size);",
          "3658:  if (!io_end || !size)",
          "3659:   return;",
          "3662:  if (io_end->flag != DIO_AIO_UNWRITTEN){",
          "3663:   ext4_free_io_end(io_end);",
          "3664:   iocb->private = NULL;",
          "3666:  }",
          "3676:  list_add_tail(&io_end->list,",
          "3677:    &EXT4_I(io_end->inode)->i_aio_dio_complete_list);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "3595:  loff_t final_size = offset + count;",
          "3596:  if (rw == WRITE && final_size <= inode->i_size) {",
          "3613:   ret = blockdev_direct_IO(rw, iocb, inode,",
          "3614:       inode->i_sb->s_bdev, iov,",
          "3615:       offset, nr_segs,",
          "3616:       ext4_get_block_dio_write,",
          "3617:       ext4_end_io_dio);",
          "3618:   return ret;",
          "3619:  }",
          "3620:  return ext4_ind_direct_IO(rw, iocb, iov, offset, nr_segs);",
          "3621: }",
          "",
          "[Removed Lines]",
          "3610:   iocb->private = ext4_init_io_end(inode, !is_sync_kiocb(iocb));",
          "3611:   if (!iocb->private)",
          "3612:    return -ENOMEM;",
          "",
          "[Added Lines]",
          "3730:   iocb->private = NULL;",
          "3731:   EXT4_I(inode)->cur_aio_dio = NULL;",
          "3732:   if (!is_sync_kiocb(iocb)) {",
          "3733:    iocb->private = ext4_init_io_end(inode);",
          "3734:    if (!iocb->private)",
          "3735:     return -ENOMEM;",
          "3743:    EXT4_I(inode)->cur_aio_dio = iocb->private;",
          "3744:   }",
          "3751:   if (iocb->private)",
          "3752:    EXT4_I(inode)->cur_aio_dio = NULL;",
          "3767:   if (ret != -EIOCBQUEUED && ret <= 0 && iocb->private) {",
          "3768:    ext4_free_io_end(iocb->private);",
          "3769:    iocb->private = NULL;",
          "3770:   } else if (ret > 0)",
          "3775:    ret = ext4_convert_unwritten_extents(inode,",
          "3776:         offset, ret);",
          "",
          "---------------"
        ],
        "fs/ext4/super.c||fs/ext4/super.c": [
          "File: fs/ext4/super.c -> fs/ext4/super.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "687:  ei->i_allocated_meta_blocks = 0;",
          "688:  ei->i_delalloc_reserved_flag = 0;",
          "689:  spin_lock_init(&(ei->i_block_reservation_lock));",
          "691:  return &ei->vfs_inode;",
          "692: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "690:  INIT_LIST_HEAD(&ei->i_aio_dio_complete_list);",
          "691:  ei->cur_aio_dio = NULL;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "3375: {",
          "3376:  int ret = 0;",
          "3377:  tid_t target;",
          "3379:  trace_ext4_sync_fs(sb, wait);",
          "3381:   if (wait)",
          "3383:  }",
          "3384:  return ret;",
          "3385: }",
          "",
          "[Removed Lines]",
          "3380:  if (jbd2_journal_start_commit(EXT4_SB(sb)->s_journal, &target)) {",
          "3382:    jbd2_log_wait_commit(EXT4_SB(sb)->s_journal, target);",
          "",
          "[Added Lines]",
          "3380:  struct ext4_sb_info *sbi = EXT4_SB(sb);",
          "3383:  flush_workqueue(sbi->dio_unwritten_wq);",
          "3384:  if (jbd2_journal_start_commit(sbi->s_journal, &target)) {",
          "3386:    jbd2_log_wait_commit(sbi->s_journal, target);",
          "",
          "---------------"
        ]
      }
    }
  ]
}
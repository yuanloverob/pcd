{
  "cve_id": "CVE-2019-15239",
  "cve_desc": "In the Linux kernel, a certain net/ipv4/tcp_output.c change, which was properly incorporated into 4.16.12, was incorrectly backported to the earlier longterm kernels, introducing a new vulnerability that was potentially more severe than the issue that was intended to be fixed by backporting. Specifically, by adding to a write queue between disconnection and re-connection, a local attacker can trigger multiple use-after-free conditions. This can result in a kernel crash, or potentially in privilege escalation. NOTE: this affects (for example) Linux distributions that use 4.9.x longterm kernels before 4.9.190 or 4.14.x longterm kernels before 4.14.139.",
  "repo": "torvalds/linux",
  "patch_hash": "7f582b248d0a86bae5788c548d7bb5bca6f7691a",
  "patch_info": {
    "commit_hash": "7f582b248d0a86bae5788c548d7bb5bca6f7691a",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/7f582b248d0a86bae5788c548d7bb5bca6f7691a",
    "files": [
      "net/ipv4/tcp_output.c"
    ],
    "message": "tcp: purge write queue in tcp_connect_init()\n\nsyzkaller found a reliable way to crash the host, hitting a BUG()\nin __tcp_retransmit_skb()\n\nMalicous MSG_FASTOPEN is the root cause. We need to purge write queue\nin tcp_connect_init() at the point we init snd_una/write_seq.\n\nThis patch also replaces the BUG() by a less intrusive WARN_ON_ONCE()\n\nkernel BUG at net/ipv4/tcp_output.c:2837!\ninvalid opcode: 0000 [#1] SMP KASAN\nDumping ftrace buffer:\n   (ftrace buffer empty)\nModules linked in:\nCPU: 0 PID: 5276 Comm: syz-executor0 Not tainted 4.17.0-rc3+ #51\nHardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011\nRIP: 0010:__tcp_retransmit_skb+0x2992/0x2eb0 net/ipv4/tcp_output.c:2837\nRSP: 0000:ffff8801dae06ff8 EFLAGS: 00010206\nRAX: ffff8801b9fe61c0 RBX: 00000000ffc18a16 RCX: ffffffff864e1a49\nRDX: 0000000000000100 RSI: ffffffff864e2e12 RDI: 0000000000000005\nRBP: ffff8801dae073a0 R08: ffff8801b9fe61c0 R09: ffffed0039c40dd2\nR10: ffffed0039c40dd2 R11: ffff8801ce206e93 R12: 00000000421eeaad\nR13: ffff8801ce206d4e R14: ffff8801ce206cc0 R15: ffff8801cd4f4a80\nFS:  0000000000000000(0000) GS:ffff8801dae00000(0063) knlGS:00000000096bc900\nCS:  0010 DS: 002b ES: 002b CR0: 0000000080050033\nCR2: 0000000020000000 CR3: 00000001c47b6000 CR4: 00000000001406f0\nDR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\nDR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\nCall Trace:\n <IRQ>\n tcp_retransmit_skb+0x2e/0x250 net/ipv4/tcp_output.c:2923\n tcp_retransmit_timer+0xc50/0x3060 net/ipv4/tcp_timer.c:488\n tcp_write_timer_handler+0x339/0x960 net/ipv4/tcp_timer.c:573\n tcp_write_timer+0x111/0x1d0 net/ipv4/tcp_timer.c:593\n call_timer_fn+0x230/0x940 kernel/time/timer.c:1326\n expire_timers kernel/time/timer.c:1363 [inline]\n __run_timers+0x79e/0xc50 kernel/time/timer.c:1666\n run_timer_softirq+0x4c/0x70 kernel/time/timer.c:1692\n __do_softirq+0x2e0/0xaf5 kernel/softirq.c:285\n invoke_softirq kernel/softirq.c:365 [inline]\n irq_exit+0x1d1/0x200 kernel/softirq.c:405\n exiting_irq arch/x86/include/asm/apic.h:525 [inline]\n smp_apic_timer_interrupt+0x17e/0x710 arch/x86/kernel/apic/apic.c:1052\n apic_timer_interrupt+0xf/0x20 arch/x86/entry/entry_64.S:863\n\nFixes: cf60af03ca4e (\"net-tcp: Fast Open client - sendmsg(MSG_FASTOPEN)\")\nSigned-off-by: Eric Dumazet <edumazet@google.com>\nCc: Yuchung Cheng <ycheng@google.com>\nCc: Neal Cardwell <ncardwell@google.com>\nReported-by: syzbot <syzkaller@googlegroups.com>\nAcked-by: Neal Cardwell <ncardwell@google.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
    "before_after_code_files": [
      "net/ipv4/tcp_output.c||net/ipv4/tcp_output.c"
    ]
  },
  "patch_diff": {
    "net/ipv4/tcp_output.c||net/ipv4/tcp_output.c": [
      "File: net/ipv4/tcp_output.c -> net/ipv4/tcp_output.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "2833:   return -EBUSY;",
      "2835:  if (before(TCP_SKB_CB(skb)->seq, tp->snd_una)) {",
      "2838:   if (tcp_trim_head(sk, skb, tp->snd_una - TCP_SKB_CB(skb)->seq))",
      "2839:    return -ENOMEM;",
      "2840:  }",
      "",
      "[Removed Lines]",
      "2836:   if (before(TCP_SKB_CB(skb)->end_seq, tp->snd_una))",
      "2837:    BUG();",
      "",
      "[Added Lines]",
      "2836:   if (unlikely(before(TCP_SKB_CB(skb)->end_seq, tp->snd_una))) {",
      "2837:    WARN_ON_ONCE(1);",
      "2838:    return -EINVAL;",
      "2839:   }",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "3342:  sock_reset_flag(sk, SOCK_DONE);",
      "3343:  tp->snd_wnd = 0;",
      "3344:  tcp_init_wl(tp, 0);",
      "3345:  tp->snd_una = tp->write_seq;",
      "3346:  tp->snd_sml = tp->write_seq;",
      "3347:  tp->snd_up = tp->write_seq;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "3347:  tcp_write_queue_purge(sk);",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "9e156c54ace310ce7fb1cd960e62416947f3d47c",
      "candidate_info": {
        "commit_hash": "9e156c54ace310ce7fb1cd960e62416947f3d47c",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/9e156c54ace310ce7fb1cd960e62416947f3d47c",
        "files": [
          "drivers/s390/scsi/zfcp_dbf.c"
        ],
        "message": "scsi: zfcp: assert that the ERP lock is held when tracing a recovery trigger\n\nOtherwise iterating with list_for_each() over the adapter->erp_ready_head\nand adapter->erp_running_head lists can lead to an infinite loop. See commit\n\"zfcp: fix infinite iteration on erp_ready_head list\".\n\nThe run-time check is only performed for debug kernels which have the kernel\nlock validator enabled. Following is an example of the warning that is\nreported, if the ERP lock is not held when calling zfcp_dbf_rec_trig():\n\nWARNING: CPU: 0 PID: 604 at drivers/s390/scsi/zfcp_dbf.c:288 zfcp_dbf_rec_trig+0x172/0x188\nModules linked in: ...\nCPU: 0 PID: 604 Comm: kworker/u128:3 Not tainted 4.16.0-... #1\nHardware name: IBM 2964 N96 702 (z/VM 6.4.0)\nWorkqueue: zfcp_q_0.0.1906 zfcp_scsi_rport_work\nKrnl PSW : 00000000330fdbf9 00000000367e9728 (zfcp_dbf_rec_trig+0x172/0x188)\n           R:0 T:1 IO:1 EX:1 Key:0 M:1 W:0 P:0 AS:3 CC:3 PM:0 RI:0 EA:3\nKrnl GPRS: 00000000c57a5d99 3288200000000000 0000000000000000 000000006cc82740\n           00000000009d09d6 0000000000000000 00000000000000ff 0000000000000000\n           0000000000000000 0000000000e1b5fe 000000006de01d38 0000000076130958\n           000000006cc82548 000000006de01a98 00000000009d09d6 000000006a6d3c80\nKrnl Code: 00000000009d0ad2: eb7ff0b80004        lmg        %r7,%r15,184(%r15)\n           00000000009d0ad8: c0f4000d7dd0        brcl       15,b80678\n          #00000000009d0ade: a7f40001            brc        15,9d0ae0\n          >00000000009d0ae2: a7f4ff7d            brc        15,9d09dc\n           00000000009d0ae6: e340f0f00004        lg         %r4,240(%r15)\n           00000000009d0aec: eb7ff0b80004        lmg        %r7,%r15,184(%r15)\n           00000000009d0af2: 07f4                bcr        15,%r4\n           00000000009d0af4: 0707                bcr        0,%r7\nCall Trace:\n([<00000000009d09d6>] zfcp_dbf_rec_trig+0x66/0x188)\n [<00000000009dd740>] zfcp_scsi_rport_work+0x98/0x190\n [<0000000000169b34>] process_one_work+0x3d4/0x6f8\n [<000000000016a08a>] worker_thread+0x232/0x418\n [<000000000017219e>] kthread+0x166/0x178\n [<0000000000b815ea>] kernel_thread_starter+0x6/0xc\n [<0000000000b815e4>] kernel_thread_starter+0x0/0xc\n2 locks held by kworker/u128:3/604:\n #0:  ((wq_completion)name){+.+.}, at: [<0000000082af1024>] process_one_work+0x1dc/0x6f8\n #1:  ((work_completion)(&port->rport_work)){+.+.}, at: [<0000000082af1024>] process_one_work+0x1dc/0x6f8\nLast Breaking-Event-Address:\n [<00000000009d0ade>] zfcp_dbf_rec_trig+0x16e/0x188\n---[ end trace b2f4020572e2c124 ]---\n\nSuggested-by: Steffen Maier <maier@linux.ibm.com>\nSigned-off-by: Jens Remus <jremus@linux.ibm.com>\nReviewed-by: Benjamin Block <bblock@linux.ibm.com>\nReviewed-by: Steffen Maier <maier@linux.ibm.com>\nSigned-off-by: Steffen Maier <maier@linux.ibm.com>\nSigned-off-by: Martin K. Petersen <martin.petersen@oracle.com>",
        "before_after_code_files": [
          "drivers/s390/scsi/zfcp_dbf.c||drivers/s390/scsi/zfcp_dbf.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "drivers/s390/scsi/zfcp_dbf.c||drivers/s390/scsi/zfcp_dbf.c": [
          "File: drivers/s390/scsi/zfcp_dbf.c -> drivers/s390/scsi/zfcp_dbf.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "285:  struct list_head *entry;",
          "286:  unsigned long flags;",
          "288:  if (unlikely(!debug_level_enabled(dbf->rec, level)))",
          "289:   return;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "288:  lockdep_assert_held(&adapter->erp_lock);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "5c750d58e9d78987e2bda6b65441e6f6b961a01e",
      "candidate_info": {
        "commit_hash": "5c750d58e9d78987e2bda6b65441e6f6b961a01e",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/5c750d58e9d78987e2bda6b65441e6f6b961a01e",
        "files": [
          "drivers/s390/scsi/zfcp_fc.c",
          "drivers/s390/scsi/zfcp_scsi.c",
          "kernel/workqueue.c"
        ],
        "message": "scsi: zfcp: workqueue: set description for port work items with their WWPN as context\n\nAs a prerequisite, complement commit 3d1cb2059d93 (\"workqueue: include\nworkqueue info when printing debug dump of a worker task\") to be usable with\nkernel modules by exporting the symbol set_worker_desc().  Current built-in\nuser was introduced with commit ef3b101925f2 (\"writeback: set worker desc to\nidentify writeback workers in task dumps\").\n\nCan help distinguishing work items which do not have adapter scope.\nDescription is printed out with task dump for debugging on WARN, BUG, panic,\nor magic-sysrq [show-task-states(t)].\n\nExample:\n$ echo 0 >| /sys/bus/ccw/drivers/zfcp/0.0.1880/0x50050763031bd327/failed &\n$ echo 't' >| /proc/sysrq-trigger\n$ dmesg\nsysrq: SysRq : Show State\n  task                        PC stack   pid father\n...\nzfcp_q_0.0.1880 S14640  2165      2 0x02000000\nCall Trace:\n([<00000000009df464>] __schedule+0xbf4/0xc78)\n [<00000000009df57c>] schedule+0x94/0xc0\n [<0000000000168654>] rescuer_thread+0x33c/0x3a0\n [<000000000016f8be>] kthread+0x166/0x178\n [<00000000009e71f2>] kernel_thread_starter+0x6/0xc\n [<00000000009e71ec>] kernel_thread_starter+0x0/0xc\nno locks held by zfcp_q_0.0.1880/2165.\n...\nkworker/u512:2  D11280  2193      2 0x02000000\nWorkqueue: zfcp_q_0.0.1880 zfcp_scsi_rport_work [zfcp] (zrpd-50050763031bd327)\n                                                        ^^^^^^^^^^^^^^^^^^^^^\nCall Trace:\n([<00000000009df464>] __schedule+0xbf4/0xc78)\n [<00000000009df57c>] schedule+0x94/0xc0\n [<00000000009e50c0>] schedule_timeout+0x488/0x4d0\n [<00000000001e425c>] msleep+0x5c/0x78                  >>test code only<<\n [<000003ff8008a21e>] zfcp_scsi_rport_work+0xbe/0x100 [zfcp]\n [<0000000000167154>] process_one_work+0x3b4/0x718\n [<000000000016771c>] worker_thread+0x264/0x408\n [<000000000016f8be>] kthread+0x166/0x178\n [<00000000009e71f2>] kernel_thread_starter+0x6/0xc\n [<00000000009e71ec>] kernel_thread_starter+0x0/0xc\n2 locks held by kworker/u512:2/2193:\n #0:  (name){++++.+}, at: [<0000000000166f4e>] process_one_work+0x1ae/0x718\n #1:  ((&(&port->rport_work)->work)){+.+.+.}, at: [<0000000000166f4e>] process_one_work+0x1ae/0x718\n...\n\n=============================================\nShowing busy workqueues and worker pools:\nworkqueue zfcp_q_0.0.1880: flags=0x2000a\n  pwq 512: cpus=0-255 flags=0x4 nice=0 active=1/1\n    in-flight: 2193:zfcp_scsi_rport_work [zfcp]\npool 512: cpus=0-255 flags=0x4 nice=0 hung=0s workers=4 idle: 5 2354 2311\n\nWork items with adapter scope are already identified by the workqueue name\n\"zfcp_q_<devbusid>\" and the work item function name.\n\nSigned-off-by: Steffen Maier <maier@linux.ibm.com>\nCc: Tejun Heo <tj@kernel.org>\nCc: Lai Jiangshan <jiangshanlai@gmail.com>\nReviewed-by: Benjamin Block <bblock@linux.ibm.com>\nAcked-by: Tejun Heo <tj@kernel.org>\nSigned-off-by: Martin K. Petersen <martin.petersen@oracle.com>",
        "before_after_code_files": [
          "drivers/s390/scsi/zfcp_fc.c||drivers/s390/scsi/zfcp_fc.c",
          "drivers/s390/scsi/zfcp_scsi.c||drivers/s390/scsi/zfcp_scsi.c",
          "kernel/workqueue.c||kernel/workqueue.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "drivers/s390/scsi/zfcp_fc.c||drivers/s390/scsi/zfcp_fc.c": [
          "File: drivers/s390/scsi/zfcp_fc.c -> drivers/s390/scsi/zfcp_fc.c"
        ],
        "drivers/s390/scsi/zfcp_scsi.c||drivers/s390/scsi/zfcp_scsi.c": [
          "File: drivers/s390/scsi/zfcp_scsi.c -> drivers/s390/scsi/zfcp_scsi.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "730:  struct zfcp_port *port = container_of(work, struct zfcp_port,",
          "731:            rport_work);",
          "733:  while (port->rport_task) {",
          "734:   if (port->rport_task == RPORT_ADD) {",
          "735:    port->rport_task = RPORT_NONE;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "733:  set_worker_desc(\"zrp%c-%16llx\",",
          "734:    (port->rport_task == RPORT_ADD) ? 'a' : 'd',",
          "",
          "---------------"
        ],
        "kernel/workqueue.c||kernel/workqueue.c": [
          "File: kernel/workqueue.c -> kernel/workqueue.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "4350:   worker->desc_valid = true;",
          "4351:  }",
          "4352: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4353: EXPORT_SYMBOL_GPL(set_worker_desc);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "b71534583f22d08c3e3563bf5100aeb5f5c9fbe5",
      "candidate_info": {
        "commit_hash": "b71534583f22d08c3e3563bf5100aeb5f5c9fbe5",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/b71534583f22d08c3e3563bf5100aeb5f5c9fbe5",
        "files": [
          "net/netfilter/nft_ct.c"
        ],
        "message": "netfilter: nf_tables: fix NULL pointer dereference on nft_ct_helper_obj_dump()\n\nIn the nft_ct_helper_obj_dump(), always priv->helper4 is dereferenced.\nBut if family is ipv6, priv->helper6 should be dereferenced.\n\nSteps to reproduces:\n\n   #test.nft\n   table ip6 filter {\n\t   ct helper ftp {\n\t\t   type \"ftp\" protocol tcp\n\t   }\n\t   chain input {\n\t\t   type filter hook input priority 4;\n\t\t   ct helper set \"ftp\"\n\t   }\n   }\n\n   %nft -f test.nft\n   %nft list ruleset\n\nwe can see the below messages:\n\n[  916.286233] kasan: GPF could be caused by NULL-ptr deref or user memory access\n[  916.294777] general protection fault: 0000 [#1] SMP DEBUG_PAGEALLOC KASAN PTI\n[  916.302613] Modules linked in: nft_objref nf_conntrack_sip nf_conntrack_snmp nf_conntrack_broadcast nf_conntrack_ftp nft_ct nf_conntrack nf_tables nfnetlink [last unloaded: nfnetlink]\n[  916.318758] CPU: 1 PID: 2093 Comm: nft Not tainted 4.17.0-rc4+ #181\n[  916.326772] Hardware name: To be filled by O.E.M. To be filled by O.E.M./Aptio CRB, BIOS 5.6.5 07/08/2015\n[  916.338773] RIP: 0010:strlen+0x1a/0x90\n[  916.342781] RSP: 0018:ffff88010ff0f2f8 EFLAGS: 00010292\n[  916.346773] RAX: dffffc0000000000 RBX: ffff880119b26ee8 RCX: ffff88010c150038\n[  916.354777] RDX: 0000000000000002 RSI: ffff880119b26ee8 RDI: 0000000000000010\n[  916.362773] RBP: 0000000000000010 R08: 0000000000007e88 R09: ffff88010c15003c\n[  916.370773] R10: ffff88010c150037 R11: ffffed002182a007 R12: ffff88010ff04040\n[  916.378779] R13: 0000000000000010 R14: ffff880119b26f30 R15: ffff88010ff04110\n[  916.387265] FS:  00007f57a1997700(0000) GS:ffff88011b800000(0000) knlGS:0000000000000000\n[  916.394785] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n[  916.402778] CR2: 00007f57a0ac80f0 CR3: 000000010ff02000 CR4: 00000000001006e0\n[  916.410772] Call Trace:\n[  916.414787]  nft_ct_helper_obj_dump+0x94/0x200 [nft_ct]\n[  916.418779]  ? nft_ct_set_eval+0x560/0x560 [nft_ct]\n[  916.426771]  ? memset+0x1f/0x40\n[  916.426771]  ? __nla_reserve+0x92/0xb0\n[  916.434774]  ? memcpy+0x34/0x50\n[  916.434774]  nf_tables_fill_obj_info+0x484/0x860 [nf_tables]\n[  916.442773]  ? __nft_release_basechain+0x600/0x600 [nf_tables]\n[  916.450779]  ? lock_acquire+0x193/0x380\n[  916.454771]  ? lock_acquire+0x193/0x380\n[  916.458789]  ? nf_tables_dump_obj+0x148/0xcb0 [nf_tables]\n[  916.462777]  nf_tables_dump_obj+0x5f0/0xcb0 [nf_tables]\n[  916.470769]  ? __alloc_skb+0x30b/0x500\n[  916.474779]  netlink_dump+0x752/0xb50\n[  916.478775]  __netlink_dump_start+0x4d3/0x750\n[  916.482784]  nf_tables_getobj+0x27a/0x930 [nf_tables]\n[  916.490774]  ? nft_obj_notify+0x100/0x100 [nf_tables]\n[  916.494772]  ? nf_tables_getobj+0x930/0x930 [nf_tables]\n[  916.502579]  ? nf_tables_dump_flowtable_done+0x70/0x70 [nf_tables]\n[  916.506774]  ? nft_obj_notify+0x100/0x100 [nf_tables]\n[  916.514808]  nfnetlink_rcv_msg+0x8ab/0xa86 [nfnetlink]\n[  916.518771]  ? nfnetlink_rcv_msg+0x550/0xa86 [nfnetlink]\n[  916.526782]  netlink_rcv_skb+0x23e/0x360\n[  916.530773]  ? nfnetlink_bind+0x200/0x200 [nfnetlink]\n[  916.534778]  ? debug_check_no_locks_freed+0x280/0x280\n[  916.542770]  ? netlink_ack+0x870/0x870\n[  916.546786]  ? ns_capable_common+0xf4/0x130\n[  916.550765]  nfnetlink_rcv+0x172/0x16c0 [nfnetlink]\n[  916.554771]  ? sched_clock_local+0xe2/0x150\n[  916.558774]  ? sched_clock_cpu+0x144/0x180\n[  916.566575]  ? lock_acquire+0x380/0x380\n[  916.570775]  ? sched_clock_local+0xe2/0x150\n[  916.574765]  ? nfnetlink_net_init+0x130/0x130 [nfnetlink]\n[  916.578763]  ? sched_clock_cpu+0x144/0x180\n[  916.582770]  ? lock_acquire+0x193/0x380\n[  916.590771]  ? lock_acquire+0x193/0x380\n[  916.594766]  ? lock_acquire+0x380/0x380\n[  916.598760]  ? netlink_deliver_tap+0x262/0xa60\n[  916.602766]  ? lock_acquire+0x193/0x380\n[  916.606766]  netlink_unicast+0x3ef/0x5a0\n[  916.610771]  ? netlink_attachskb+0x630/0x630\n[  916.614763]  netlink_sendmsg+0x72a/0xb00\n[  916.618769]  ? netlink_unicast+0x5a0/0x5a0\n[  916.626766]  ? _copy_from_user+0x92/0xc0\n[  916.630773]  __sys_sendto+0x202/0x300\n[  916.634772]  ? __ia32_sys_getpeername+0xb0/0xb0\n[  916.638759]  ? lock_acquire+0x380/0x380\n[  916.642769]  ? lock_acquire+0x193/0x380\n[  916.646761]  ? finish_task_switch+0xf4/0x560\n[  916.650763]  ? __schedule+0x582/0x19a0\n[  916.655301]  ? __sched_text_start+0x8/0x8\n[  916.655301]  ? up_read+0x1c/0x110\n[  916.655301]  ? __do_page_fault+0x48b/0xaa0\n[  916.655301]  ? entry_SYSCALL_64_after_hwframe+0x59/0xbe\n[  916.655301]  __x64_sys_sendto+0xdd/0x1b0\n[  916.655301]  do_syscall_64+0x96/0x3d0\n[  916.655301]  entry_SYSCALL_64_after_hwframe+0x49/0xbe\n[  916.655301] RIP: 0033:0x7f57a0ff5e03\n[  916.655301] RSP: 002b:00007fff6367e0a8 EFLAGS: 00000246 ORIG_RAX: 000000000000002c\n[  916.655301] RAX: ffffffffffffffda RBX: 00007fff6367f1e0 RCX: 00007f57a0ff5e03\n[  916.655301] RDX: 0000000000000020 RSI: 00007fff6367e110 RDI: 0000000000000003\n[  916.655301] RBP: 00007fff6367e100 R08: 00007f57a0ce9160 R09: 000000000000000c\n[  916.655301] R10: 0000000000000000 R11: 0000000000000246 R12: 00007fff6367e110\n[  916.655301] R13: 0000000000000020 R14: 00007f57a153c610 R15: 0000562417258de0\n[  916.655301] Code: ff ff ff 0f 1f 40 00 66 2e 0f 1f 84 00 00 00 00 00 55 48 89 fa 53 48 c1 ea 03 48 b8 00 00 00 00 00 fc ff df 48 89 fd 48 83 ec 08 <0f> b6 04 02 48 89 fa 83 e2 07 38 d0 7f\n[  916.655301] RIP: strlen+0x1a/0x90 RSP: ffff88010ff0f2f8\n[  916.771929] ---[ end trace 1065e048e72479fe ]---\n[  916.777204] Kernel panic - not syncing: Fatal exception\n[  916.778158] Kernel Offset: 0x14000000 from 0xffffffff81000000 (relocation range: 0xffffffff80000000-0xffffffffbfffffff)\n\nSigned-off-by: Taehee Yoo <ap420073@gmail.com>\nAcked-by: Florian Westphal <fw@strlen.de>\nSigned-off-by: Pablo Neira Ayuso <pablo@netfilter.org>",
        "before_after_code_files": [
          "net/netfilter/nft_ct.c||net/netfilter/nft_ct.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "net/netfilter/nft_ct.c||net/netfilter/nft_ct.c": [
          "File: net/netfilter/nft_ct.c -> net/netfilter/nft_ct.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "880:       struct nft_object *obj, bool reset)",
          "881: {",
          "882:  const struct nft_ct_helper_obj *priv = nft_obj_data(obj);",
          "884:  u16 family;",
          "886:  if (nla_put_string(skb, NFTA_CT_HELPER_NAME, helper->name))",
          "887:   return -1;",
          "889:  if (nla_put_u8(skb, NFTA_CT_HELPER_L4PROTO, priv->l4proto))",
          "890:   return -1;",
          "899:  if (nla_put_be16(skb, NFTA_CT_HELPER_L3PROTO, htons(family)))",
          "900:   return -1;",
          "",
          "[Removed Lines]",
          "883:  const struct nf_conntrack_helper *helper = priv->helper4;",
          "892:  if (priv->helper4 && priv->helper6)",
          "893:   family = NFPROTO_INET;",
          "894:  else if (priv->helper6)",
          "895:   family = NFPROTO_IPV6;",
          "896:  else",
          "897:   family = NFPROTO_IPV4;",
          "",
          "[Added Lines]",
          "883:  const struct nf_conntrack_helper *helper;",
          "886:  if (priv->helper4 && priv->helper6) {",
          "887:   family = NFPROTO_INET;",
          "888:   helper = priv->helper4;",
          "889:  } else if (priv->helper6) {",
          "890:   family = NFPROTO_IPV6;",
          "891:   helper = priv->helper6;",
          "892:  } else {",
          "893:   family = NFPROTO_IPV4;",
          "894:   helper = priv->helper4;",
          "895:  }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "44a63b137f7b6e4c7bd6c9cc21615941cb36509d",
      "candidate_info": {
        "commit_hash": "44a63b137f7b6e4c7bd6c9cc21615941cb36509d",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/44a63b137f7b6e4c7bd6c9cc21615941cb36509d",
        "files": [
          "net/sched/sch_red.c",
          "net/sched/sch_tbf.c"
        ],
        "message": "net: sched: red: avoid hashing NULL child\n\nHangbin reported an Oops triggered by the syzkaller qdisc rules:\n\n kasan: GPF could be caused by NULL-ptr deref or user memory access\n general protection fault: 0000 [#1] SMP KASAN PTI\n Modules linked in: sch_red\n CPU: 0 PID: 28699 Comm: syz-executor5 Not tainted 4.17.0-rc4.kcov #1\n Hardware name: Red Hat KVM, BIOS 0.5.1 01/01/2011\n RIP: 0010:qdisc_hash_add+0x26/0xa0\n RSP: 0018:ffff8800589cf470 EFLAGS: 00010203\n RAX: dffffc0000000000 RBX: 0000000000000000 RCX: ffffffff824ad971\n RDX: 0000000000000007 RSI: ffffc9000ce9f000 RDI: 000000000000003c\n RBP: 0000000000000001 R08: ffffed000b139ea2 R09: ffff8800589cf4f0\n R10: ffff8800589cf50f R11: ffffed000b139ea2 R12: ffff880054019fc0\n R13: ffff880054019fb4 R14: ffff88005c0af600 R15: ffff880054019fb0\n FS:  00007fa6edcb1700(0000) GS:ffff88005ce00000(0000) knlGS:0000000000000000\n CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n CR2: 0000000020000740 CR3: 000000000fc16000 CR4: 00000000000006f0\n DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\n DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\n Call Trace:\n  red_change+0x2d2/0xed0 [sch_red]\n  qdisc_create+0x57e/0xef0\n  tc_modify_qdisc+0x47f/0x14e0\n  rtnetlink_rcv_msg+0x6a8/0x920\n  netlink_rcv_skb+0x2a2/0x3c0\n  netlink_unicast+0x511/0x740\n  netlink_sendmsg+0x825/0xc30\n  sock_sendmsg+0xc5/0x100\n  ___sys_sendmsg+0x778/0x8e0\n  __sys_sendmsg+0xf5/0x1b0\n  do_syscall_64+0xbd/0x3b0\n  entry_SYSCALL_64_after_hwframe+0x44/0xa9\n RIP: 0033:0x450869\n RSP: 002b:00007fa6edcb0c48 EFLAGS: 00000246 ORIG_RAX: 000000000000002e\n RAX: ffffffffffffffda RBX: 00007fa6edcb16b4 RCX: 0000000000450869\n RDX: 0000000000000000 RSI: 00000000200000c0 RDI: 0000000000000013\n RBP: 000000000072bea0 R08: 0000000000000000 R09: 0000000000000000\n R10: 0000000000000000 R11: 0000000000000246 R12: 00000000ffffffff\n R13: 0000000000008778 R14: 0000000000702838 R15: 00007fa6edcb1700\n Code: e9 0b fe ff ff 0f 1f 44 00 00 55 53 48 89 fb 89 f5 e8 3f 07 f3 fe 48 8d 7b 3c 48 b8 00 00 00 00 00 fc ff df 48 89 fa 48 c1 ea 03 <0f> b6 14 02 48 89 f8 83 e0 07 83 c0 03 38 d0 7c 04 84 d2 75 51\n RIP: qdisc_hash_add+0x26/0xa0 RSP: ffff8800589cf470\n\nWhen a red qdisc is updated with a 0 limit, the child qdisc is left\nunmodified, no additional scheduler is created in red_change(),\nthe 'child' local variable is rightfully NULL and must not add it\nto the hash table.\n\nThis change addresses the above issue moving qdisc_hash_add() right\nafter the child qdisc creation. It additionally removes unneeded checks\nfor noop_qdisc.\n\nReported-by: Hangbin Liu <liuhangbin@gmail.com>\nFixes: 49b499718fa1 (\"net: sched: make default fifo qdiscs appear in the dump\")\nSigned-off-by: Paolo Abeni <pabeni@redhat.com>\nAcked-by: Jiri Kosina <jkosina@suse.cz>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "before_after_code_files": [
          "net/sched/sch_red.c||net/sched/sch_red.c",
          "net/sched/sch_tbf.c||net/sched/sch_tbf.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "net/sched/sch_red.c||net/sched/sch_red.c": [
          "File: net/sched/sch_red.c -> net/sched/sch_red.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "222:       extack);",
          "223:   if (IS_ERR(child))",
          "224:    return PTR_ERR(child);",
          "228:   qdisc_hash_add(child, true);",
          "229:  sch_tree_lock(sch);",
          "230:  q->flags = ctl->flags;",
          "231:  q->limit = ctl->limit;",
          "",
          "[Removed Lines]",
          "225:  }",
          "227:  if (child != &noop_qdisc)",
          "",
          "[Added Lines]",
          "228:  }",
          "",
          "---------------"
        ],
        "net/sched/sch_tbf.c||net/sched/sch_tbf.c": [
          "File: net/sched/sch_tbf.c -> net/sched/sch_tbf.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "383:    err = PTR_ERR(child);",
          "384:    goto done;",
          "385:   }",
          "386:  }",
          "388:  sch_tree_lock(sch);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "388:   qdisc_hash_add(child, true);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "391:        q->qdisc->qstats.backlog);",
          "392:   qdisc_destroy(q->qdisc);",
          "393:   q->qdisc = child;",
          "396:  }",
          "397:  q->limit = qopt->limit;",
          "398:  if (tb[TCA_TBF_PBURST])",
          "",
          "[Removed Lines]",
          "394:   if (child != &noop_qdisc)",
          "395:    qdisc_hash_add(child, true);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "050fad7c4534c13c8eb1d9c2ba66012e014773cb",
      "candidate_info": {
        "commit_hash": "050fad7c4534c13c8eb1d9c2ba66012e014773cb",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/050fad7c4534c13c8eb1d9c2ba66012e014773cb",
        "files": [
          "kernel/bpf/core.c",
          "net/core/filter.c"
        ],
        "message": "bpf: fix truncated jump targets on heavy expansions\n\nRecently during testing, I ran into the following panic:\n\n  [  207.892422] Internal error: Accessing user space memory outside uaccess.h routines: 96000004 [#1] SMP\n  [  207.901637] Modules linked in: binfmt_misc [...]\n  [  207.966530] CPU: 45 PID: 2256 Comm: test_verifier Tainted: G        W         4.17.0-rc3+ #7\n  [  207.974956] Hardware name: FOXCONN R2-1221R-A4/C2U4N_MB, BIOS G31FB18A 03/31/2017\n  [  207.982428] pstate: 60400005 (nZCv daif +PAN -UAO)\n  [  207.987214] pc : bpf_skb_load_helper_8_no_cache+0x34/0xc0\n  [  207.992603] lr : 0xffff000000bdb754\n  [  207.996080] sp : ffff000013703ca0\n  [  207.999384] x29: ffff000013703ca0 x28: 0000000000000001\n  [  208.004688] x27: 0000000000000001 x26: 0000000000000000\n  [  208.009992] x25: ffff000013703ce0 x24: ffff800fb4afcb00\n  [  208.015295] x23: ffff00007d2f5038 x22: ffff00007d2f5000\n  [  208.020599] x21: fffffffffeff2a6f x20: 000000000000000a\n  [  208.025903] x19: ffff000009578000 x18: 0000000000000a03\n  [  208.031206] x17: 0000000000000000 x16: 0000000000000000\n  [  208.036510] x15: 0000ffff9de83000 x14: 0000000000000000\n  [  208.041813] x13: 0000000000000000 x12: 0000000000000000\n  [  208.047116] x11: 0000000000000001 x10: ffff0000089e7f18\n  [  208.052419] x9 : fffffffffeff2a6f x8 : 0000000000000000\n  [  208.057723] x7 : 000000000000000a x6 : 00280c6160000000\n  [  208.063026] x5 : 0000000000000018 x4 : 0000000000007db6\n  [  208.068329] x3 : 000000000008647a x2 : 19868179b1484500\n  [  208.073632] x1 : 0000000000000000 x0 : ffff000009578c08\n  [  208.078938] Process test_verifier (pid: 2256, stack limit = 0x0000000049ca7974)\n  [  208.086235] Call trace:\n  [  208.088672]  bpf_skb_load_helper_8_no_cache+0x34/0xc0\n  [  208.093713]  0xffff000000bdb754\n  [  208.096845]  bpf_test_run+0x78/0xf8\n  [  208.100324]  bpf_prog_test_run_skb+0x148/0x230\n  [  208.104758]  sys_bpf+0x314/0x1198\n  [  208.108064]  el0_svc_naked+0x30/0x34\n  [  208.111632] Code: 91302260 f9400001 f9001fa1 d2800001 (29500680)\n  [  208.117717] ---[ end trace 263cb8a59b5bf29f ]---\n\nThe program itself which caused this had a long jump over the whole\ninstruction sequence where all of the inner instructions required\nheavy expansions into multiple BPF instructions. Additionally, I also\nhad BPF hardening enabled which requires once more rewrites of all\nconstant values in order to blind them. Each time we rewrite insns,\nbpf_adj_branches() would need to potentially adjust branch targets\nwhich cross the patchlet boundary to accommodate for the additional\ndelta. Eventually that lead to the case where the target offset could\nnot fit into insn->off's upper 0x7fff limit anymore where then offset\nwraps around becoming negative (in s16 universe), or vice versa\ndepending on the jump direction.\n\nTherefore it becomes necessary to detect and reject any such occasions\nin a generic way for native eBPF and cBPF to eBPF migrations. For\nthe latter we can simply check bounds in the bpf_convert_filter()'s\nBPF_EMIT_JMP helper macro and bail out once we surpass limits. The\nbpf_patch_insn_single() for native eBPF (and cBPF to eBPF in case\nof subsequent hardening) is a bit more complex in that we need to\ndetect such truncations before hitting the bpf_prog_realloc(). Thus\nthe latter is split into an extra pass to probe problematic offsets\non the original program in order to fail early. With that in place\nand carefully tested I no longer hit the panic and the rewrites are\nrejected properly. The above example panic I've seen on bpf-next,\nthough the issue itself is generic in that a guard against this issue\nin bpf seems more appropriate in this case.\n\nSigned-off-by: Daniel Borkmann <daniel@iogearbox.net>\nAcked-by: Martin KaFai Lau <kafai@fb.com>\nSigned-off-by: Alexei Starovoitov <ast@kernel.org>",
        "before_after_code_files": [
          "kernel/bpf/core.c||kernel/bpf/core.c",
          "net/core/filter.c||net/core/filter.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "kernel/bpf/core.c||kernel/bpf/core.c": [
          "File: kernel/bpf/core.c -> kernel/bpf/core.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "218:  return 0;",
          "219: }",
          "222: {",
          "223:  struct bpf_insn *insn = prog->insnsi;",
          "229:  for (i = 0; i < insn_cnt; i++, insn++) {",
          "230:   code = insn->code;",
          "234:    continue;",
          "235:   if (BPF_OP(code) == BPF_CALL) {",
          "239:     continue;",
          "240:   } else {",
          "242:   }",
          "255:  }",
          "256: }",
          "258: struct bpf_prog *bpf_patch_insn_single(struct bpf_prog *prog, u32 off,",
          "259:            const struct bpf_insn *patch, u32 len)",
          "260: {",
          "261:  u32 insn_adj_cnt, insn_rest, insn_delta = len - 1;",
          "262:  struct bpf_prog *prog_adj;",
          "",
          "[Removed Lines]",
          "221: static void bpf_adj_branches(struct bpf_prog *prog, u32 pos, u32 delta)",
          "224:  u32 i, insn_cnt = prog->len;",
          "225:  bool pseudo_call;",
          "226:  u8 code;",
          "227:  int off;",
          "231:   if (BPF_CLASS(code) != BPF_JMP)",
          "232:    continue;",
          "233:   if (BPF_OP(code) == BPF_EXIT)",
          "236:    if (insn->src_reg == BPF_PSEUDO_CALL)",
          "237:     pseudo_call = true;",
          "238:    else",
          "241:    pseudo_call = false;",
          "243:   off = pseudo_call ? insn->imm : insn->off;",
          "246:   if (i < pos && i + off + 1 > pos)",
          "247:    off += delta;",
          "248:   else if (i > pos + delta && i + off + 1 <= pos + delta)",
          "249:    off -= delta;",
          "251:   if (pseudo_call)",
          "252:    insn->imm = off;",
          "253:   else",
          "254:    insn->off = off;",
          "",
          "[Added Lines]",
          "221: static int bpf_adj_delta_to_imm(struct bpf_insn *insn, u32 pos, u32 delta,",
          "222:     u32 curr, const bool probe_pass)",
          "224:  const s64 imm_min = S32_MIN, imm_max = S32_MAX;",
          "225:  s64 imm = insn->imm;",
          "227:  if (curr < pos && curr + imm + 1 > pos)",
          "228:   imm += delta;",
          "229:  else if (curr > pos + delta && curr + imm + 1 <= pos + delta)",
          "230:   imm -= delta;",
          "231:  if (imm < imm_min || imm > imm_max)",
          "232:   return -ERANGE;",
          "233:  if (!probe_pass)",
          "234:   insn->imm = imm;",
          "235:  return 0;",
          "236: }",
          "238: static int bpf_adj_delta_to_off(struct bpf_insn *insn, u32 pos, u32 delta,",
          "239:     u32 curr, const bool probe_pass)",
          "240: {",
          "241:  const s32 off_min = S16_MIN, off_max = S16_MAX;",
          "242:  s32 off = insn->off;",
          "244:  if (curr < pos && curr + off + 1 > pos)",
          "245:   off += delta;",
          "246:  else if (curr > pos + delta && curr + off + 1 <= pos + delta)",
          "247:   off -= delta;",
          "248:  if (off < off_min || off > off_max)",
          "249:   return -ERANGE;",
          "250:  if (!probe_pass)",
          "251:   insn->off = off;",
          "252:  return 0;",
          "253: }",
          "255: static int bpf_adj_branches(struct bpf_prog *prog, u32 pos, u32 delta,",
          "256:        const bool probe_pass)",
          "257: {",
          "258:  u32 i, insn_cnt = prog->len + (probe_pass ? delta : 0);",
          "260:  int ret = 0;",
          "263:   u8 code;",
          "269:   if (probe_pass && i == pos) {",
          "270:    i += delta + 1;",
          "271:    insn++;",
          "272:   }",
          "274:   if (BPF_CLASS(code) != BPF_JMP ||",
          "275:       BPF_OP(code) == BPF_EXIT)",
          "279:    if (insn->src_reg != BPF_PSEUDO_CALL)",
          "281:    ret = bpf_adj_delta_to_imm(insn, pos, delta, i,",
          "282:          probe_pass);",
          "284:    ret = bpf_adj_delta_to_off(insn, pos, delta, i,",
          "285:          probe_pass);",
          "287:   if (ret)",
          "288:    break;",
          "291:  return ret;",
          "298:  const u32 cnt_max = S16_MAX;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "270:  insn_adj_cnt = prog->len + insn_delta;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "314:  if (insn_adj_cnt > cnt_max &&",
          "315:      bpf_adj_branches(prog, off, insn_delta, true))",
          "316:   return NULL;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "294:   sizeof(*patch) * insn_rest);",
          "295:  memcpy(prog_adj->insnsi + off, patch, sizeof(*patch) * len);",
          "299:  return prog_adj;",
          "300: }",
          "",
          "[Removed Lines]",
          "297:  bpf_adj_branches(prog_adj, off, insn_delta);",
          "",
          "[Added Lines]",
          "347:  BUG_ON(bpf_adj_branches(prog_adj, off, insn_delta, false));",
          "",
          "---------------"
        ],
        "net/core/filter.c||net/core/filter.c": [
          "File: net/core/filter.c -> net/core/filter.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "482: #define BPF_EMIT_JMP       \\",
          "483:  do {        \\",
          "484:   if (target >= len || target < 0)   \\",
          "485:    goto err;     \\",
          "489:  } while (0)",
          "491:   case BPF_JMP | BPF_JA:",
          "",
          "[Removed Lines]",
          "486:   insn->off = addrs ? addrs[target] - addrs[i] - 1 : 0; \\",
          "488:   insn->off -= insn - tmp_insns;    \\",
          "",
          "[Added Lines]",
          "484:   const s32 off_min = S16_MIN, off_max = S16_MAX;  \\",
          "485:   s32 off;      \\",
          "486:          \\",
          "489:   off = addrs ? addrs[target] - addrs[i] - 1 : 0;  \\",
          "491:   off -= insn - tmp_insns;    \\",
          "493:   if (off < off_min || off > off_max)   \\",
          "494:    goto err;     \\",
          "495:   insn->off = off;     \\",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2019-15924",
  "cve_desc": "An issue was discovered in the Linux kernel before 5.0.11. fm10k_init_module in drivers/net/ethernet/intel/fm10k/fm10k_main.c has a NULL pointer dereference because there is no -ENOMEM upon an alloc_workqueue failure.",
  "repo": "torvalds/linux",
  "patch_hash": "01ca667133d019edc9f0a1f70a272447c84ec41f",
  "patch_info": {
    "commit_hash": "01ca667133d019edc9f0a1f70a272447c84ec41f",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/01ca667133d019edc9f0a1f70a272447c84ec41f",
    "files": [
      "drivers/net/ethernet/intel/fm10k/fm10k_main.c"
    ],
    "message": "fm10k: Fix a potential NULL pointer dereference\n\nSyzkaller report this:\n\nkasan: GPF could be caused by NULL-ptr deref or user memory access\ngeneral protection fault: 0000 [#1] SMP KASAN PTI\nCPU: 0 PID: 4378 Comm: syz-executor.0 Tainted: G         C        5.0.0+ #5\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.10.2-1ubuntu1 04/01/2014\nRIP: 0010:__lock_acquire+0x95b/0x3200 kernel/locking/lockdep.c:3573\nCode: 00 0f 85 28 1e 00 00 48 81 c4 08 01 00 00 5b 5d 41 5c 41 5d 41 5e 41 5f c3 4c 89 ea 48 b8 00 00 00 00 00 fc ff df 48 c1 ea 03 <80> 3c 02 00 0f 85 cc 24 00 00 49 81 7d 00 e0 de 03 a6 41 bc 00 00\nRSP: 0018:ffff8881e3c07a40 EFLAGS: 00010002\nRAX: dffffc0000000000 RBX: 0000000000000000 RCX: 0000000000000000\nRDX: 0000000000000010 RSI: 0000000000000000 RDI: 0000000000000080\nRBP: 0000000000000000 R08: 0000000000000001 R09: 0000000000000000\nR10: ffff8881e3c07d98 R11: ffff8881c7f21f80 R12: 0000000000000001\nR13: 0000000000000080 R14: 0000000000000000 R15: 0000000000000001\nFS:  00007fce2252e700(0000) GS:ffff8881f2400000(0000) knlGS:0000000000000000\nCS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nCR2: 00007fffc7eb0228 CR3: 00000001e5bea002 CR4: 00000000007606f0\nDR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\nDR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\nPKRU: 55555554\nCall Trace:\n lock_acquire+0xff/0x2c0 kernel/locking/lockdep.c:4211\n __mutex_lock_common kernel/locking/mutex.c:925 [inline]\n __mutex_lock+0xdf/0x1050 kernel/locking/mutex.c:1072\n drain_workqueue+0x24/0x3f0 kernel/workqueue.c:2934\n destroy_workqueue+0x23/0x630 kernel/workqueue.c:4319\n __do_sys_delete_module kernel/module.c:1018 [inline]\n __se_sys_delete_module kernel/module.c:961 [inline]\n __x64_sys_delete_module+0x30c/0x480 kernel/module.c:961\n do_syscall_64+0x9f/0x450 arch/x86/entry/common.c:290\n entry_SYSCALL_64_after_hwframe+0x49/0xbe\nRIP: 0033:0x462e99\nCode: f7 d8 64 89 02 b8 ff ff ff ff c3 66 0f 1f 44 00 00 48 89 f8 48 89 f7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 <48> 3d 01 f0 ff ff 73 01 c3 48 c7 c1 bc ff ff ff f7 d8 64 89 01 48\nRSP: 002b:00007fce2252dc58 EFLAGS: 00000246 ORIG_RAX: 00000000000000b0\nRAX: ffffffffffffffda RBX: 000000000073bf00 RCX: 0000000000462e99\nRDX: 0000000000000000 RSI: 0000000000000000 RDI: 0000000020000140\nRBP: 0000000000000002 R08: 0000000000000000 R09: 0000000000000000\nR10: 0000000000000000 R11: 0000000000000246 R12: 00007fce2252e6bc\nR13: 00000000004bcca9 R14: 00000000006f6b48 R15: 00000000ffffffff\n\nIf alloc_workqueue fails, it should return -ENOMEM, otherwise may\ntrigger this NULL pointer dereference while unloading drivers.\n\nReported-by: Hulk Robot <hulkci@huawei.com>\nFixes: 0a38c17a21a0 (\"fm10k: Remove create_workqueue\")\nSigned-off-by: Yue Haibing <yuehaibing@huawei.com>\nTested-by: Andrew Bowers <andrewx.bowers@intel.com>\nSigned-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>",
    "before_after_code_files": [
      "drivers/net/ethernet/intel/fm10k/fm10k_main.c||drivers/net/ethernet/intel/fm10k/fm10k_main.c"
    ]
  },
  "patch_diff": {
    "drivers/net/ethernet/intel/fm10k/fm10k_main.c||drivers/net/ethernet/intel/fm10k/fm10k_main.c": [
      "File: drivers/net/ethernet/intel/fm10k/fm10k_main.c -> drivers/net/ethernet/intel/fm10k/fm10k_main.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "42:  fm10k_workqueue = alloc_workqueue(\"%s\", WQ_MEM_RECLAIM, 0,",
      "43:        fm10k_driver_name);",
      "45:  fm10k_dbg_init();",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "44:  if (!fm10k_workqueue)",
      "45:   return -ENOMEM;",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "4b006b0c139e486773335f4c23b4d82348cfeb04",
      "candidate_info": {
        "commit_hash": "4b006b0c139e486773335f4c23b4d82348cfeb04",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/4b006b0c139e486773335f4c23b4d82348cfeb04",
        "files": [
          "net/sched/act_simple.c",
          "tools/testing/selftests/tc-testing/tc-tests/actions/simple.json"
        ],
        "message": "net/sched: act_simple: validate the control action inside init()\n\nthe following script:\n\n # tc qdisc add dev crash0 clsact\n # tc filter add dev crash0 egress matchall \\\n > action simple sdata hello pass index 90\n # tc actions replace action simple \\\n > sdata world goto chain 42 index 90 cookie c1a0c1a0\n # tc action show action simple\n\nhad the following output:\n\n Error: Failed to init TC action chain.\n We have an error talking to the kernel\n total acts 1\n\n         action order 0: Simple <world>\n          index 90 ref 2 bind 1\n         cookie c1a0c1a0\n\nThen, the first packet transmitted by crash0 made the kernel crash:\n\n BUG: unable to handle kernel NULL pointer dereference at 0000000000000000\n #PF error: [normal kernel read fault]\n PGD 800000006a6fb067 P4D 800000006a6fb067 PUD 6aed6067 PMD 0\n Oops: 0000 [#1] SMP PTI\n CPU: 2 PID: 3241 Comm: kworker/2:0 Not tainted 5.0.0-rc4.gotochain_crash+ #536\n Hardware name: Red Hat KVM, BIOS 0.5.1 01/01/2011\n Workqueue: ipv6_addrconf addrconf_dad_work\n RIP: 0010:tcf_action_exec+0xb8/0x100\n Code: 00 00 00 20 74 1d 83 f8 03 75 09 49 83 c4 08 4d 39 ec 75 bc 48 83 c4 10 5b 5d 41 5c 41 5d 41 5e 41 5f c3 49 8b 97 a8 00 00 00 <48> 8b 12 48 89 55 00 48 83 c4 10 5b 5d 41 5c 41 5d 41 5e 41 5f c3\n RSP: 0018:ffffbe6781763ad0 EFLAGS: 00010246\n RAX: 000000002000002a RBX: ffff9e59bdb80e00 RCX: 0000000000000000\n RDX: 0000000000000000 RSI: ffff9e59b4716738 RDI: ffff9e59ab12d140\n RBP: ffffbe6781763b70 R08: 0000000000000234 R09: 0000000000aaaaaa\n R10: 0000000000000000 R11: ffff9e59b247cd50 R12: ffff9e59b112f100\n R13: ffff9e59b112f108 R14: 0000000000000001 R15: ffff9e59ab12d0c0\n FS:  0000000000000000(0000) GS:ffff9e59b4700000(0000) knlGS:0000000000000000\n CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n CR2: 0000000000000000 CR3: 000000006af92004 CR4: 00000000001606e0\n Call Trace:\n  tcf_classify+0x58/0x120\n  __dev_queue_xmit+0x40a/0x890\n  ? ndisc_next_option+0x50/0x50\n  ? ___neigh_create+0x4d5/0x680\n  ? ip6_finish_output2+0x1b5/0x590\n  ip6_finish_output2+0x1b5/0x590\n  ? ip6_output+0x68/0x110\n  ip6_output+0x68/0x110\n  ? nf_hook.constprop.28+0x79/0xc0\n  ndisc_send_skb+0x248/0x2e0\n  ndisc_send_ns+0xf8/0x200\n  ? addrconf_dad_work+0x389/0x4b0\n  addrconf_dad_work+0x389/0x4b0\n  ? __switch_to_asm+0x34/0x70\n  ? process_one_work+0x195/0x380\n  ? addrconf_dad_completed+0x370/0x370\n  process_one_work+0x195/0x380\n  worker_thread+0x30/0x390\n  ? process_one_work+0x380/0x380\n  kthread+0x113/0x130\n  ? kthread_park+0x90/0x90\n  ret_from_fork+0x35/0x40\n Modules linked in: act_simple veth ip6table_filter ip6_tables iptable_filter binfmt_misc crct10dif_pclmul crc32_pclmul ghash_clmulni_intel ext4 snd_hda_codec_generic snd_hda_intel snd_hda_codec snd_hwdep mbcache snd_hda_core jbd2 snd_seq snd_seq_device snd_pcm aesni_intel crypto_simd cryptd snd_timer glue_helper snd joydev virtio_balloon pcspkr soundcore i2c_piix4 nfsd auth_rpcgss nfs_acl lockd grace sunrpc ip_tables xfs ata_generic pata_acpi qxl drm_kms_helper syscopyarea sysfillrect sysimgblt fb_sys_fops virtio_net ttm net_failover virtio_console virtio_blk failover drm crc32c_intel serio_raw floppy ata_piix libata virtio_pci virtio_ring virtio dm_mirror dm_region_hash dm_log dm_mod\n CR2: 0000000000000000\n\nValidating the control action within tcf_simple_init() proved to fix the\nabove issue. A TDC selftest is added to verify the correct behavior.\n\nFixes: db50514f9a9c (\"net: sched: add termination action to allow goto chain\")\nFixes: 97763dc0f401 (\"net_sched: reject unknown tcfa_action values\")\nSigned-off-by: Davide Caratti <dcaratti@redhat.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "before_after_code_files": [
          "net/sched/act_simple.c||net/sched/act_simple.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "net/sched/act_simple.c||net/sched/act_simple.c": [
          "File: net/sched/act_simple.c -> net/sched/act_simple.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "18: #include <linux/rtnetlink.h>",
          "19: #include <net/netlink.h>",
          "20: #include <net/pkt_sched.h>",
          "22: #include <linux/tc_act/tc_defact.h>",
          "23: #include <net/tc_act/tc_defact.h>",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "21: #include <net/pkt_cls.h>",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "60:  return 0;",
          "61: }",
          "65: {",
          "66:  spin_lock_bh(&d->tcf_lock);",
          "68:  memset(d->tcfd_defdata, 0, SIMP_MAX_DATA);",
          "69:  nla_strlcpy(d->tcfd_defdata, defdata, SIMP_MAX_DATA);",
          "70:  spin_unlock_bh(&d->tcf_lock);",
          "71: }",
          "73: static const struct nla_policy simple_policy[TCA_DEF_MAX + 1] = {",
          "",
          "[Removed Lines]",
          "63: static void reset_policy(struct tcf_defact *d, const struct nlattr *defdata,",
          "64:     struct tc_defact *p)",
          "67:  d->tcf_action = p->action;",
          "",
          "[Added Lines]",
          "64: static int reset_policy(struct tc_action *a, const struct nlattr *defdata,",
          "65:    struct tc_defact *p, struct tcf_proto *tp,",
          "66:    struct netlink_ext_ack *extack)",
          "68:  struct tcf_chain *goto_ch = NULL;",
          "69:  struct tcf_defact *d;",
          "70:  int err;",
          "72:  err = tcf_action_check_ctrlact(p->action, tp, &goto_ch, extack);",
          "73:  if (err < 0)",
          "74:   return err;",
          "75:  d = to_defact(a);",
          "77:  goto_ch = tcf_action_set_ctrlact(a, p->action, goto_ch);",
          "81:  if (goto_ch)",
          "82:   tcf_chain_put_by_act(goto_ch);",
          "83:  return 0;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "82: {",
          "83:  struct tc_action_net *tn = net_generic(net, simp_net_id);",
          "84:  struct nlattr *tb[TCA_DEF_MAX + 1];",
          "85:  struct tc_defact *parm;",
          "86:  struct tcf_defact *d;",
          "87:  bool exists = false;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "98:  struct tcf_chain *goto_ch = NULL;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "122:   }",
          "124:   d = to_defact(*a);",
          "131:   ret = ACT_P_CREATED;",
          "132:  } else {",
          "135:   if (!ovr) {",
          "138:   }",
          "141:  }",
          "143:  if (ret == ACT_P_CREATED)",
          "144:   tcf_idr_insert(tn, *a);",
          "145:  return ret;",
          "146: }",
          "148: static int tcf_simp_dump(struct sk_buff *skb, struct tc_action *a,",
          "",
          "[Removed Lines]",
          "125:   ret = alloc_defdata(d, tb[TCA_DEF_DATA]);",
          "126:   if (ret < 0) {",
          "127:    tcf_idr_release(*a, bind);",
          "128:    return ret;",
          "129:   }",
          "130:   d->tcf_action = parm->action;",
          "133:   d = to_defact(*a);",
          "136:    tcf_idr_release(*a, bind);",
          "137:    return -EEXIST;",
          "140:   reset_policy(d, tb[TCA_DEF_DATA], parm);",
          "",
          "[Added Lines]",
          "139:   err = tcf_action_check_ctrlact(parm->action, tp, &goto_ch,",
          "140:             extack);",
          "141:   if (err < 0)",
          "142:    goto release_idr;",
          "144:   err = alloc_defdata(d, tb[TCA_DEF_DATA]);",
          "145:   if (err < 0)",
          "146:    goto put_chain;",
          "148:   tcf_action_set_ctrlact(*a, parm->action, goto_ch);",
          "152:    err = -EEXIST;",
          "153:    goto release_idr;",
          "156:   err = reset_policy(*a, tb[TCA_DEF_DATA], parm, tp, extack);",
          "157:   if (err)",
          "158:    goto release_idr;",
          "164: put_chain:",
          "165:  if (goto_ch)",
          "166:   tcf_chain_put_by_act(goto_ch);",
          "167: release_idr:",
          "168:  tcf_idr_release(*a, bind);",
          "169:  return err;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "46ca3f735f345c9d87383dd3a09fa5d43870770e",
      "candidate_info": {
        "commit_hash": "46ca3f735f345c9d87383dd3a09fa5d43870770e",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/46ca3f735f345c9d87383dd3a09fa5d43870770e",
        "files": [
          "drivers/tty/vt/keyboard.c"
        ],
        "message": "tty/vt: fix write/write race in ioctl(KDSKBSENT) handler\n\nThe bug manifests as an attempt to access deallocated memory:\n\n    BUG: unable to handle kernel paging request at ffff9c8735448000\n    #PF error: [PROT] [WRITE]\n    PGD 288a05067 P4D 288a05067 PUD 288a07067 PMD 7f60c2063 PTE 80000007f5448161\n    Oops: 0003 [#1] PREEMPT SMP\n    CPU: 6 PID: 388 Comm: loadkeys Tainted: G         C        5.0.0-rc6-00153-g5ded5871030e #91\n    Hardware name: Gigabyte Technology Co., Ltd. To be filled by O.E.M./H77M-D3H, BIOS F12 11/14/2013\n    RIP: 0010:__memmove+0x81/0x1a0\n    Code: 4c 89 4f 10 4c 89 47 18 48 8d 7f 20 73 d4 48 83 c2 20 e9 a2 00 00 00 66 90 48 89 d1 4c 8b 5c 16 f8 4c 8d 54 17 f8 48 c1 e9 03 <f3> 48 a5 4d 89 1a e9 0c 01 00 00 0f 1f 40 00 48 89 d1 4c 8b 1e 49\n    RSP: 0018:ffffa1b9002d7d08 EFLAGS: 00010203\n    RAX: ffff9c873541af43 RBX: ffff9c873541af43 RCX: 00000c6f105cd6bf\n    RDX: 0000637882e986b6 RSI: ffff9c8735447ffb RDI: ffff9c8735447ffb\n    RBP: ffff9c8739cd3800 R08: ffff9c873b802f00 R09: 00000000fffff73b\n    R10: ffffffffb82b35f1 R11: 00505b1b004d5b1b R12: 0000000000000000\n    R13: ffff9c873541af3d R14: 000000000000000b R15: 000000000000000c\n    FS:  00007f450c390580(0000) GS:ffff9c873f180000(0000) knlGS:0000000000000000\n    CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n    CR2: ffff9c8735448000 CR3: 00000007e213c002 CR4: 00000000000606e0\n    Call Trace:\n     vt_do_kdgkb_ioctl+0x34d/0x440\n     vt_ioctl+0xba3/0x1190\n     ? __bpf_prog_run32+0x39/0x60\n     ? mem_cgroup_commit_charge+0x7b/0x4e0\n     tty_ioctl+0x23f/0x920\n     ? preempt_count_sub+0x98/0xe0\n     ? __seccomp_filter+0x67/0x600\n     do_vfs_ioctl+0xa2/0x6a0\n     ? syscall_trace_enter+0x192/0x2d0\n     ksys_ioctl+0x3a/0x70\n     __x64_sys_ioctl+0x16/0x20\n     do_syscall_64+0x54/0xe0\n     entry_SYSCALL_64_after_hwframe+0x49/0xbe\n\nThe bug manifests on systemd systems with multiple vtcon devices:\n  # cat /sys/devices/virtual/vtconsole/vtcon0/name\n  (S) dummy device\n  # cat /sys/devices/virtual/vtconsole/vtcon1/name\n  (M) frame buffer device\n\nThere systemd runs 'loadkeys' tool in tapallel for each vtcon\ninstance. This causes two parallel ioctl(KDSKBSENT) calls to\nrace into adding the same entry into 'func_table' array at:\n\n    drivers/tty/vt/keyboard.c:vt_do_kdgkb_ioctl()\n\nThe function has no locking around writes to 'func_table'.\n\nThe simplest reproducer is to have initrams with the following\ninit on a 8-CPU machine x86_64:\n\n    #!/bin/sh\n\n    loadkeys -q windowkeys ru4 &\n    loadkeys -q windowkeys ru4 &\n    loadkeys -q windowkeys ru4 &\n    loadkeys -q windowkeys ru4 &\n\n    loadkeys -q windowkeys ru4 &\n    loadkeys -q windowkeys ru4 &\n    loadkeys -q windowkeys ru4 &\n    loadkeys -q windowkeys ru4 &\n    wait\n\nThe change adds lock on write path only. Reads are still racy.\n\nCC: Greg Kroah-Hartman <gregkh@linuxfoundation.org>\nCC: Jiri Slaby <jslaby@suse.com>\nLink: https://lkml.org/lkml/2019/2/17/256\nSigned-off-by: Sergei Trofimovich <slyfox@gentoo.org>\nCc: stable <stable@vger.kernel.org>\nSigned-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>",
        "before_after_code_files": [
          "drivers/tty/vt/keyboard.c||drivers/tty/vt/keyboard.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "drivers/tty/vt/keyboard.c||drivers/tty/vt/keyboard.c": [
          "File: drivers/tty/vt/keyboard.c -> drivers/tty/vt/keyboard.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1990:  char *p;",
          "1991:  u_char *q;",
          "1992:  u_char __user *up;",
          "1994:  int delta;",
          "1995:  char *first_free, *fj, *fnw;",
          "1996:  int i, j, k;",
          "1997:  int ret;",
          "1999:  if (!capable(CAP_SYS_TTY_CONFIG))",
          "2000:   perm = 0;",
          "",
          "[Removed Lines]",
          "1993:  int sz;",
          "",
          "[Added Lines]",
          "1994:  int sz, fnw_sz;",
          "1999:  unsigned long flags;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2037:    goto reterr;",
          "2038:   }",
          "2040:   q = func_table[i];",
          "2041:   first_free = funcbufptr + (funcbufsize - funcbufleft);",
          "2042:   for (j = i+1; j < MAX_NR_FUNC && !func_table[j]; j++)",
          "2043:    ;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2042:   fnw = NULL;",
          "2043:   fnw_sz = 0;",
          "2045:   again:",
          "2046:   spin_lock_irqsave(&func_buf_lock, flags);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "2061:       sz = 256;",
          "2062:       while (sz < funcbufsize - funcbufleft + delta)",
          "2063:         sz <<= 1;",
          "2068:       }",
          "2070:       if (!q)",
          "2071:         func_table[i] = fj;",
          "2072:       if (fj > funcbufptr)",
          "2073:    memmove(fnw, funcbufptr, fj - funcbufptr);",
          "2074:       for (k = 0; k < j; k++)",
          "2075:         if (func_table[k])",
          "2076:    func_table[k] = fnw + (func_table[k] - funcbufptr);",
          "2078:       if (first_free > fj) {",
          "2079:    memmove(fnw + (fj - funcbufptr) + delta, fj, first_free - fj);",
          "2080:    for (k = j; k < MAX_NR_FUNC; k++)",
          "",
          "[Removed Lines]",
          "2064:       fnw = kmalloc(sz, GFP_KERNEL);",
          "2065:       if(!fnw) {",
          "2066:         ret = -ENOMEM;",
          "2067:         goto reterr;",
          "",
          "[Added Lines]",
          "2075:       if (fnw_sz != sz) {",
          "2076:         spin_unlock_irqrestore(&func_buf_lock, flags);",
          "2077:         kfree(fnw);",
          "2078:         fnw = kmalloc(sz, GFP_KERNEL);",
          "2079:         fnw_sz = sz;",
          "2080:         if (!fnw) {",
          "2081:    ret = -ENOMEM;",
          "2082:    goto reterr;",
          "2083:         }",
          "2084:         goto again;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "2087:       funcbufleft = funcbufleft - delta + sz - funcbufsize;",
          "2088:       funcbufsize = sz;",
          "2089:   }",
          "2090:   strcpy(func_table[i], kbs->kb_string);",
          "2091:   break;",
          "2092:  }",
          "2093:  ret = 0;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2111:   spin_unlock_irqrestore(&func_buf_lock, flags);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "6ac86ca3524b4549d31c45d11487b0626c334f10",
      "candidate_info": {
        "commit_hash": "6ac86ca3524b4549d31c45d11487b0626c334f10",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/6ac86ca3524b4549d31c45d11487b0626c334f10",
        "files": [
          "net/sched/act_pedit.c",
          "tools/testing/selftests/tc-testing/tc-tests/actions/pedit.json"
        ],
        "message": "net/sched: act_pedit: validate the control action inside init()\n\nthe following script:\n\n # tc filter add dev crash0 egress matchall \\\n > action pedit ex munge ip ttl set 10 pass index 90\n # tc actions replace action pedit \\\n > ex munge ip ttl set 10 goto chain 42 index 90 cookie c1a0c1a0\n # tc actions show action pedit\n\nhad the following output:\n\n Error: Failed to init TC action chain.\n We have an error talking to the kernel\n total acts 1\n\n         action order 0:  pedit action goto chain 42 keys 1\n          index 90 ref 2 bind 1\n          key #0  at ipv4+8: val 0a000000 mask 00ffffff\n         cookie c1a0c1a0\n\nThen, the first packet transmitted by crash0 made the kernel crash:\n\n BUG: unable to handle kernel NULL pointer dereference at 0000000000000000\n #PF error: [normal kernel read fault]\n PGD 0 P4D 0\n Oops: 0000 [#1] SMP PTI\n CPU: 2 PID: 0 Comm: swapper/2 Not tainted 5.0.0-rc4.gotochain_crash+ #533\n Hardware name: Red Hat KVM, BIOS 0.5.1 01/01/2011\n RIP: 0010:tcf_action_exec+0xb8/0x100\n Code: 00 00 00 20 74 1d 83 f8 03 75 09 49 83 c4 08 4d 39 ec 75 bc 48 83 c4 10 5b 5d 41 5c 41 5d 41 5e 41 5f c3 49 8b 97 a8 00 00 00 <48> 8b 12 48 89 55 00 48 83 c4 10 5b 5d 41 5c 41 5d 41 5e 41 5f c3\n RSP: 0018:ffff94a73db03be0 EFLAGS: 00010246\n RAX: 000000002000002a RBX: ffff94a6ee4c0700 RCX: 000000000000000a\n RDX: 0000000000000000 RSI: ffff94a6ed22c800 RDI: 0000000000000000\n RBP: ffff94a73db03c80 R08: ffff94a7386fa4c8 R09: ffff94a73229ea20\n R10: 0000000000000000 R11: 0000000000000000 R12: ffff94a6ed22cb00\n R13: ffff94a6ed22cb08 R14: 0000000000000001 R15: ffff94a6ed22c800\n FS:  0000000000000000(0000) GS:ffff94a73db00000(0000) knlGS:0000000000000000\n CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n CR2: 0000000000000000 CR3: 000000007120e002 CR4: 00000000001606e0\n Call Trace:\n  <IRQ>\n  tcf_classify+0x58/0x120\n  __dev_queue_xmit+0x40a/0x890\n  ? ip6_finish_output2+0x369/0x590\n  ip6_finish_output2+0x369/0x590\n  ? ip6_output+0x68/0x110\n  ip6_output+0x68/0x110\n  ? nf_hook.constprop.35+0x79/0xc0\n  mld_sendpack+0x16f/0x220\n  mld_ifc_timer_expire+0x195/0x2c0\n  ? igmp6_timer_handler+0x70/0x70\n  call_timer_fn+0x2b/0x130\n  run_timer_softirq+0x3e8/0x440\n  ? tick_sched_timer+0x37/0x70\n  __do_softirq+0xe3/0x2f5\n  irq_exit+0xf0/0x100\n  smp_apic_timer_interrupt+0x6c/0x130\n  apic_timer_interrupt+0xf/0x20\n  </IRQ>\n RIP: 0010:native_safe_halt+0x2/0x10\n Code: 4e ff ff ff 7f f3 c3 65 48 8b 04 25 00 5c 01 00 f0 80 48 02 20 48 8b 00 a8 08 74 8b eb c1 90 90 90 90 90 90 90 90 90 90 fb f4 <c3> 0f 1f 00 66 2e 0f 1f 84 00 00 00 00 00 f4 c3 90 90 90 90 90 90\n RSP: 0018:ffffab1740387eb8 EFLAGS: 00000246 ORIG_RAX: ffffffffffffff13\n RAX: ffffffffb18184f0 RBX: 0000000000000002 RCX: 0000000000000001\n RDX: 0000000000000001 RSI: 0000000000000087 RDI: 0000000000000002\n RBP: 0000000000000002 R08: 000f168fa695f9a9 R09: 0000000000000020\n R10: 0000000000000004 R11: 0000000000000000 R12: 0000000000000000\n R13: 0000000000000000 R14: 0000000000000000 R15: 0000000000000000\n  ? __sched_text_end+0x1/0x1\n  default_idle+0x1c/0x140\n  do_idle+0x1c4/0x280\n  cpu_startup_entry+0x19/0x20\n  start_secondary+0x1a7/0x200\n  secondary_startup_64+0xa4/0xb0\n Modules linked in: act_pedit veth ip6table_filter ip6_tables iptable_filter binfmt_misc ext4 mbcache jbd2 crct10dif_pclmul crc32_pclmul ghash_clmulni_intel snd_hda_codec_generic snd_hda_intel snd_hda_codec snd_hwdep aesni_intel snd_hda_core crypto_simd snd_seq cryptd glue_helper snd_seq_device snd_pcm joydev snd_timer pcspkr virtio_balloon snd soundcore i2c_piix4 nfsd auth_rpcgss nfs_acl lockd grace sunrpc ip_tables xfs qxl ata_generic pata_acpi drm_kms_helper virtio_net net_failover syscopyarea sysfillrect sysimgblt failover virtio_blk fb_sys_fops virtio_console ttm drm crc32c_intel serio_raw ata_piix virtio_pci libata virtio_ring virtio floppy dm_mirror dm_region_hash dm_log dm_mod\n CR2: 0000000000000000\n\nValidating the control action within tcf_pedit_init() proved to fix the\nabove issue. A TDC selftest is added to verify the correct behavior.\n\nFixes: db50514f9a9c (\"net: sched: add termination action to allow goto chain\")\nFixes: 97763dc0f401 (\"net_sched: reject unknown tcfa_action values\")\nSigned-off-by: Davide Caratti <dcaratti@redhat.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "before_after_code_files": [
          "net/sched/act_pedit.c||net/sched/act_pedit.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "net/sched/act_pedit.c||net/sched/act_pedit.c": [
          "File: net/sched/act_pedit.c -> net/sched/act_pedit.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "23: #include <linux/tc_act/tc_pedit.h>",
          "24: #include <net/tc_act/tc_pedit.h>",
          "25: #include <uapi/linux/tc_act/tc_pedit.h>",
          "27: static unsigned int pedit_net_id;",
          "28: static struct tc_action_ops act_pedit_ops;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "26: #include <net/pkt_cls.h>",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "142: {",
          "143:  struct tc_action_net *tn = net_generic(net, pedit_net_id);",
          "144:  struct nlattr *tb[TCA_PEDIT_MAX + 1];",
          "145:  struct tc_pedit_key *keys = NULL;",
          "146:  struct tcf_pedit_key_ex *keys_ex;",
          "147:  struct tc_pedit *parm;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "146:  struct tcf_chain *goto_ch = NULL;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "205:   goto out_free;",
          "206:  }",
          "208:  p = to_pedit(*a);",
          "209:  spin_lock_bh(&p->tcf_lock);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "210:  err = tcf_action_check_ctrlact(parm->action, tp, &goto_ch, extack);",
          "211:  if (err < 0) {",
          "212:   ret = err;",
          "213:   goto out_release;",
          "214:  }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "214:   if (!keys) {",
          "215:    spin_unlock_bh(&p->tcf_lock);",
          "216:    ret = -ENOMEM;",
          "218:   }",
          "219:   kfree(p->tcfp_keys);",
          "220:   p->tcfp_keys = keys;",
          "",
          "[Removed Lines]",
          "217:    goto out_release;",
          "",
          "[Added Lines]",
          "224:    goto put_chain;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "223:  memcpy(p->tcfp_keys, parm->keys, ksize);",
          "225:  p->tcfp_flags = parm->flags;",
          "228:  kfree(p->tcfp_keys_ex);",
          "229:  p->tcfp_keys_ex = keys_ex;",
          "231:  spin_unlock_bh(&p->tcf_lock);",
          "232:  if (ret == ACT_P_CREATED)",
          "233:   tcf_idr_insert(tn, *a);",
          "234:  return ret;",
          "236: out_release:",
          "237:  tcf_idr_release(*a, bind);",
          "238: out_free:",
          "",
          "[Removed Lines]",
          "226:  p->tcf_action = parm->action;",
          "",
          "[Added Lines]",
          "233:  goto_ch = tcf_action_set_ctrlact(*a, parm->action, goto_ch);",
          "239:  if (goto_ch)",
          "240:   tcf_chain_put_by_act(goto_ch);",
          "245: put_chain:",
          "246:  if (goto_ch)",
          "247:   tcf_chain_put_by_act(goto_ch);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "1e45d043a8bb2ed8a541384db3cc133e92001f0c",
      "candidate_info": {
        "commit_hash": "1e45d043a8bb2ed8a541384db3cc133e92001f0c",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/1e45d043a8bb2ed8a541384db3cc133e92001f0c",
        "files": [
          "net/sched/act_nat.c",
          "tools/testing/selftests/tc-testing/tc-tests/actions/nat.json"
        ],
        "message": "net/sched: act_nat: validate the control action inside init()\n\nthe following script:\n\n # tc qdisc add dev crash0 clsact\n # tc filter add dev crash0 egress matchall \\\n > action nat ingress 1.18.1.1 1.18.2.2 pass index 90\n # tc actions replace action nat \\\n > ingress 1.18.1.1 1.18.2.2 goto chain 42 index 90 cookie c1a0c1a0\n # tc actions show action nat\n\nhad the following output:\n\n Error: Failed to init TC action chain.\n We have an error talking to the kernel\n total acts 1\n\n         action order 0:  nat ingress 1.18.1.1/32 1.18.2.2 goto chain 42\n          index 90 ref 2 bind 1\n         cookie c1a0c1a0\n\nThen, the first packet transmitted by crash0 made the kernel crash:\n\n BUG: unable to handle kernel NULL pointer dereference at 0000000000000000\n #PF error: [normal kernel read fault]\n PGD 800000002d180067 P4D 800000002d180067 PUD 7cb8b067 PMD 0\n Oops: 0000 [#1] SMP PTI\n CPU: 3 PID: 164 Comm: kworker/3:1 Not tainted 5.0.0-rc4.gotochain_crash+ #533\n Hardware name: Red Hat KVM, BIOS 0.5.1 01/01/2011\n Workqueue: ipv6_addrconf addrconf_dad_work\n RIP: 0010:tcf_action_exec+0xb8/0x100\n Code: 00 00 00 20 74 1d 83 f8 03 75 09 49 83 c4 08 4d 39 ec 75 bc 48 83 c4 10 5b 5d 41 5c 41 5d 41 5e 41 5f c3 49 8b 97 a8 00 00 00 <48> 8b 12 48 89 55 00 48 83 c4 10 5b 5d 41 5c 41 5d 41 5e 41 5f c3\n RSP: 0018:ffffae4500e2fad0 EFLAGS: 00010246\n RAX: 000000002000002a RBX: ffff9fa52e28c800 RCX: 0000000001011201\n RDX: 0000000000000000 RSI: 0000000000000056 RDI: ffff9fa52ca12800\n RBP: ffffae4500e2fb70 R08: 0000000000000022 R09: 000000000000000e\n R10: 00000000ffffffff R11: 0000000001011201 R12: ffff9fa52cbc9c00\n R13: ffff9fa52cbc9c08 R14: 0000000000000001 R15: ffff9fa52ca12780\n FS:  0000000000000000(0000) GS:ffff9fa57db80000(0000) knlGS:0000000000000000\n CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n CR2: 0000000000000000 CR3: 0000000073f8c004 CR4: 00000000001606e0\n Call Trace:\n  tcf_classify+0x58/0x120\n  __dev_queue_xmit+0x40a/0x890\n  ? ndisc_next_option+0x50/0x50\n  ? ___neigh_create+0x4d5/0x680\n  ? ip6_finish_output2+0x1b5/0x590\n  ip6_finish_output2+0x1b5/0x590\n  ? ip6_output+0x68/0x110\n  ip6_output+0x68/0x110\n  ? nf_hook.constprop.28+0x79/0xc0\n  ndisc_send_skb+0x248/0x2e0\n  ndisc_send_ns+0xf8/0x200\n  ? addrconf_dad_work+0x389/0x4b0\n  addrconf_dad_work+0x389/0x4b0\n  ? __switch_to_asm+0x34/0x70\n  ? process_one_work+0x195/0x380\n  ? addrconf_dad_completed+0x370/0x370\n  process_one_work+0x195/0x380\n  worker_thread+0x30/0x390\n  ? process_one_work+0x380/0x380\n  kthread+0x113/0x130\n  ? kthread_park+0x90/0x90\n  ret_from_fork+0x35/0x40\n Modules linked in: act_nat veth ip6table_filter ip6_tables iptable_filter binfmt_misc ext4 crct10dif_pclmul crc32_pclmul ghash_clmulni_intel mbcache jbd2 snd_hda_codec_generic snd_hda_intel snd_hda_codec snd_hwdep snd_hda_core snd_seq snd_seq_device snd_pcm aesni_intel crypto_simd cryptd glue_helper snd_timer snd joydev virtio_balloon pcspkr soundcore i2c_piix4 nfsd auth_rpcgss nfs_acl lockd grace sunrpc ip_tables xfs qxl ata_generic pata_acpi drm_kms_helper syscopyarea sysfillrect sysimgblt fb_sys_fops ttm virtio_net virtio_blk net_failover failover virtio_console drm crc32c_intel floppy ata_piix libata virtio_pci virtio_ring virtio serio_raw dm_mirror dm_region_hash dm_log dm_mod\n CR2: 0000000000000000\n\nValidating the control action within tcf_nat_init() proved to fix the\nabove issue. A TDC selftest is added to verify the correct behavior.\n\nFixes: db50514f9a9c (\"net: sched: add termination action to allow goto chain\")\nFixes: 97763dc0f401 (\"net_sched: reject unknown tcfa_action values\")\nSigned-off-by: Davide Caratti <dcaratti@redhat.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "before_after_code_files": [
          "net/sched/act_nat.c||net/sched/act_nat.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "net/sched/act_nat.c||net/sched/act_nat.c": [
          "File: net/sched/act_nat.c -> net/sched/act_nat.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "21: #include <linux/string.h>",
          "22: #include <linux/tc_act/tc_nat.h>",
          "23: #include <net/act_api.h>",
          "24: #include <net/icmp.h>",
          "25: #include <net/ip.h>",
          "26: #include <net/netlink.h>",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "24: #include <net/pkt_cls.h>",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "43: {",
          "44:  struct tc_action_net *tn = net_generic(net, nat_net_id);",
          "45:  struct nlattr *tb[TCA_NAT_MAX + 1];",
          "46:  struct tc_nat *parm;",
          "47:  int ret = 0, err;",
          "48:  struct tcf_nat *p;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "47:  struct tcf_chain *goto_ch = NULL;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "77:  } else {",
          "78:   return err;",
          "79:  }",
          "80:  p = to_tcf_nat(*a);",
          "82:  spin_lock_bh(&p->tcf_lock);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "82:  err = tcf_action_check_ctrlact(parm->action, tp, &goto_ch, extack);",
          "83:  if (err < 0)",
          "84:   goto release_idr;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "85:  p->mask = parm->mask;",
          "86:  p->flags = parm->flags;",
          "89:  spin_unlock_bh(&p->tcf_lock);",
          "91:  if (ret == ACT_P_CREATED)",
          "92:   tcf_idr_insert(tn, *a);",
          "94:  return ret;",
          "95: }",
          "97: static int tcf_nat_act(struct sk_buff *skb, const struct tc_action *a,",
          "",
          "[Removed Lines]",
          "88:  p->tcf_action = parm->action;",
          "",
          "[Added Lines]",
          "93:  goto_ch = tcf_action_set_ctrlact(*a, parm->action, goto_ch);",
          "95:  if (goto_ch)",
          "96:   tcf_chain_put_by_act(goto_ch);",
          "102: release_idr:",
          "103:  tcf_idr_release(*a, bind);",
          "104:  return err;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "b6ffdf27f3d4f1e9af56effe6f86989170d71e95",
      "candidate_info": {
        "commit_hash": "b6ffdf27f3d4f1e9af56effe6f86989170d71e95",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/b6ffdf27f3d4f1e9af56effe6f86989170d71e95",
        "files": [
          "arch/s390/kernel/perf_cpum_cf_diag.c"
        ],
        "message": "s390/cpumf: Fix warning from check_processor_id\n\nFunction __hw_perf_event_init() used a CPU variable without\nensuring CPU preemption has been disabled. This caused the\nfollowing warning in the kernel log:\n\n  [ 7.277085] BUG: using smp_processor_id() in preemptible\n                 [00000000] code: cf-csdiag/1892\n  [ 7.277111] caller is cf_diag_event_init+0x13a/0x338\n  [ 7.277122] CPU: 10 PID: 1892 Comm: cf-csdiag Not tainted\n                 5.0.0-20190318.rc0.git0.9e1a11e0f602.300.fc29.s390x+debug #1\n  [ 7.277131] Hardware name: IBM 2964 NC9 712 (LPAR)\n  [ 7.277139] Call Trace:\n  [ 7.277150] ([<000000000011385a>] show_stack+0x82/0xd0)\n  [ 7.277161]  [<0000000000b7a71a>] dump_stack+0x92/0xd0\n  [ 7.277174]  [<00000000007b7e9c>] check_preemption_disabled+0xe4/0x100\n  [ 7.277183]  [<00000000001228aa>] cf_diag_event_init+0x13a/0x338\n  [ 7.277195]  [<00000000002cf3aa>] perf_try_init_event+0x72/0xf0\n  [ 7.277204]  [<00000000002d0bba>] perf_event_alloc+0x6fa/0xce0\n  [ 7.277214]  [<00000000002dc4a8>] __s390x_sys_perf_event_open+0x398/0xd50\n  [ 7.277224]  [<0000000000b9e8f0>] system_call+0xdc/0x2d8\n  [ 7.277233] 2 locks held by cf-csdiag/1892:\n  [ 7.277241]  #0: 00000000976f5510 (&sig->cred_guard_mutex){+.+.},\n                  at: __s390x_sys_perf_event_open+0xd2e/0xd50\n  [ 7.277257]  #1: 00000000363b11bd (&pmus_srcu){....},\n                  at: perf_event_alloc+0x52e/0xce0\n\nThe variable is now accessed in proper context. Use\nget_cpu_var()/put_cpu_var() pair to disable\npreemption during access.\nAs the hardware authorization settings apply to all CPUs, it\ndoes not matter which CPU is used to check the authorization setting.\n\nRemove the event->count assignment. It is not needed as function\nperf_event_alloc() allocates memory for the event with kzalloc() and\nthus count is already set to zero.\n\nFixes: fe5908bccc56 (\"s390/cpum_cf_diag: Add support for s390 counter facility diagnostic trace\")\n\nSigned-off-by: Thomas Richter <tmricht@linux.ibm.com>\nReviewed-by: Hendrik Brueckner <brueckner@linux.ibm.com>\nSigned-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>",
        "before_after_code_files": [
          "arch/s390/kernel/perf_cpum_cf_diag.c||arch/s390/kernel/perf_cpum_cf_diag.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "arch/s390/kernel/perf_cpum_cf_diag.c||arch/s390/kernel/perf_cpum_cf_diag.c": [
          "File: arch/s390/kernel/perf_cpum_cf_diag.c -> arch/s390/kernel/perf_cpum_cf_diag.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "197: static int __hw_perf_event_init(struct perf_event *event)",
          "198: {",
          "200:  struct perf_event_attr *attr = &event->attr;",
          "201:  enum cpumf_ctr_set i;",
          "202:  int err = 0;",
          "208:  event->hw.config = attr->config;",
          "209:  event->hw.config_base = 0;",
          "213:  for (i = CPUMF_CTR_SET_BASIC; i < CPUMF_CTR_SET_MAX; ++i)",
          "214:   if (cpuhw->info.auth_ctl & cpumf_ctr_ctl[i])",
          "215:    event->hw.config_base |= cpumf_ctr_ctl[i];",
          "218:  if (!event->hw.config_base) {",
          "",
          "[Removed Lines]",
          "199:  struct cpu_cf_events *cpuhw = this_cpu_ptr(&cpu_cf_events);",
          "204:  debug_sprintf_event(cf_diag_dbg, 5,",
          "205:        \"%s event %p cpu %d authorized %#x\\n\", __func__,",
          "206:        event, event->cpu, cpuhw->info.auth_ctl);",
          "210:  local64_set(&event->count, 0);",
          "",
          "[Added Lines]",
          "200:  struct cpu_cf_events *cpuhw;",
          "204:  debug_sprintf_event(cf_diag_dbg, 5, \"%s event %p cpu %d\\n\", __func__,",
          "205:        event, event->cpu);",
          "218:  cpuhw = &get_cpu_var(cpu_cf_events);",
          "222:  put_cpu_var(cpu_cf_events);",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2012-2330",
  "cve_desc": "The Update method in src/node_http_parser.cc in Node.js before 0.6.17 and 0.7 before 0.7.8 does not properly check the length of a string, which allows remote attackers to obtain sensitive information (request header contents) and possibly spoof HTTP headers via a zero length string.",
  "repo": "joyent/node",
  "patch_hash": "c9a231db0e59658be419d926b1dfa17b939ba158",
  "patch_info": {
    "commit_hash": "c9a231db0e59658be419d926b1dfa17b939ba158",
    "repo": "joyent/node",
    "commit_url": "https://github.com/joyent/node/commit/c9a231d",
    "files": [
      "src/node_http_parser.cc"
    ],
    "message": "typo in node_http_parser",
    "before_after_code_files": [
      "src/node_http_parser.cc||src/node_http_parser.cc"
    ]
  },
  "patch_diff": {
    "src/node_http_parser.cc||src/node_http_parser.cc": [
      "File: src/node_http_parser.cc -> src/node_http_parser.cc",
      "--- Hunk 1 ---",
      "[Context before]",
      "191:   void Update(const char* str, size_t size) {",
      "192:     if (str_ == NULL)",
      "193:       str_ = str;",
      "197:       char* s = new char[size_ + size];",
      "",
      "[Removed Lines]",
      "194:     else if (on_heap_ || str_ + size != str) {",
      "",
      "[Added Lines]",
      "194:     else if (on_heap_ || str_ + size_ != str) {",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "977e211421fc0055fb46bde392207bef9703b0ce",
      "candidate_info": {
        "commit_hash": "977e211421fc0055fb46bde392207bef9703b0ce",
        "repo": "joyent/node",
        "commit_url": "https://github.com/joyent/node/commit/977e211421fc0055fb46bde392207bef9703b0ce",
        "files": [
          "src/node.cc"
        ],
        "message": "debugger: rename `process.debug_port` to `process.debugPort`\n\nWe should comply to to camelCase naming convention.",
        "before_after_code_files": [
          "src/node.cc||src/node.cc"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/roamm/node/pull/1",
          "https://github.com/kingzone/node/pull/1",
          "https://github.com/OpenFPGAduino/node/pull/1"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "src/node.cc||src/node.cc": [
          "File: src/node.cc -> src/node.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "2115:   }",
          "2116:   delete [] execPath;",
          "2119:                        DebugPortGetter,",
          "2120:                        DebugPortSetter);",
          "",
          "[Removed Lines]",
          "2118:   process->SetAccessor(String::New(\"debug_port\"),",
          "",
          "[Added Lines]",
          "2118:   process->SetAccessor(String::New(\"debugPort\"),",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "83fd1c1de51e6b0171101a725c8d92081c2fadbd",
      "candidate_info": {
        "commit_hash": "83fd1c1de51e6b0171101a725c8d92081c2fadbd",
        "repo": "joyent/node",
        "commit_url": "https://github.com/joyent/node/commit/83fd1c1de51e6b0171101a725c8d92081c2fadbd",
        "files": [
          "lib/http.js",
          "test/simple/test-http-server-multiheaders.js"
        ],
        "message": "Add WebSocket RFC6455 multiheader fields to the http parser.",
        "before_after_code_files": [
          "lib/http.js||lihttp.js",
          "test/simple/test-http-server-multiheaders.js||test/simple/test-http-server-multiheaders.js"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/roamm/node/pull/1",
          "https://github.com/kingzone/node/pull/1",
          "https://github.com/OpenFPGAduino/node/pull/1"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "lib/http.js||lihttp.js": [
          "File: lib/http.js -> lihttp.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "295:     case 'pragma':",
          "296:     case 'link':",
          "297:     case 'www-authenticate':",
          "298:       if (field in dest) {",
          "299:         dest[field] += ', ' + value;",
          "300:       } else {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "test/simple/test-http-server-multiheaders.js||test/simple/test-http-server-multiheaders.js": [
          "File: test/simple/test-http-server-multiheaders.js -> test/simple/test-http-server-multiheaders.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "33:   assert.equal(req.headers['www-authenticate'], 'foo, bar, baz');",
          "34:   assert.equal(req.headers['x-foo'], 'bingo');",
          "35:   assert.equal(req.headers['x-bar'], 'banjo, bango');",
          "37:   res.writeHead(200, {'Content-Type' : 'text/plain'});",
          "38:   res.end('EOF');",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "36:   assert.equal(req.headers['sec-websocket-protocol'], 'chat, share');",
          "37:   assert.equal(req.headers['sec-websocket-extensions'], 'foo; 1, bar; 2, baz');",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "57:       ['WWW-AUTHENTICATE', 'baz'],",
          "58:       ['x-foo', 'bingo'],",
          "59:       ['x-bar', 'banjo'],",
          "61:     ]",
          "62:   });",
          "63: });",
          "",
          "[Removed Lines]",
          "60:       ['x-bar', 'bango']",
          "",
          "[Added Lines]",
          "62:       ['x-bar', 'bango'],",
          "63:       ['sec-websocket-protocol', 'chat'],",
          "64:       ['sec-websocket-protocol', 'share'],",
          "65:       ['sec-websocket-extensions', 'foo; 1'],",
          "66:       ['sec-websocket-extensions', 'bar; 2'],",
          "67:       ['sec-websocket-extensions', 'baz']",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "1e13a2d242b98dd5ea944598157f449c771f7048",
      "candidate_info": {
        "commit_hash": "1e13a2d242b98dd5ea944598157f449c771f7048",
        "repo": "joyent/node",
        "commit_url": "https://github.com/joyent/node/commit/1e13a2d242b98dd5ea944598157f449c771f7048",
        "files": [
          "src/stream_wrap.cc"
        ],
        "message": "stream_wrap: use new slab allocator",
        "before_after_code_files": [
          "src/stream_wrap.cc||src/stream_wrap.cc"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/roamm/node/pull/1",
          "https://github.com/kingzone/node/pull/1",
          "https://github.com/OpenFPGAduino/node/pull/1"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "src/stream_wrap.cc||src/stream_wrap.cc": [
          "File: src/stream_wrap.cc -> src/stream_wrap.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "22: #include \"node.h\"",
          "23: #include \"node_buffer.h\"",
          "24: #include \"handle_wrap.h\"",
          "25: #include \"stream_wrap.h\"",
          "26: #include \"pipe_wrap.h\"",
          "27: #include \"tcp_wrap.h\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "25: #include \"slab_allocator.h\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "30: #include <stdlib.h> // abort()",
          "36: #define SLAB_SIZE (1024 * 1024)",
          "40: using v8::Object;",
          "41: using v8::Handle;",
          "42: using v8::Local;",
          "",
          "[Removed Lines]",
          "33: namespace node {",
          "37: #define MIN(a, b) ((a) < (b) ? (a) : (b))",
          "",
          "[Added Lines]",
          "36: namespace node {",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "69: typedef class ReqWrap<uv_write_t> WriteWrap;",
          "75: static Persistent<String> buffer_sym;",
          "76: static Persistent<String> write_queue_size_sym;",
          "77: static bool initialized;",
          "80: void StreamWrap::Initialize(Handle<Object> target) {",
          "87:   HandleScope scope;",
          "89:   HandleWrap::Initialize(target);",
          "92:   buffer_sym = Persistent<String>::New(String::NewSymbol(\"buffer\"));",
          "93:   write_queue_size_sym =",
          "94:     Persistent<String>::New(String::NewSymbol(\"writeQueueSize\"));",
          "",
          "[Removed Lines]",
          "72: static size_t slab_used;",
          "73: static uv_stream_t* handle_that_last_alloced;",
          "74: static Persistent<String> slab_sym;",
          "81:   if (initialized) {",
          "82:     return;",
          "83:   } else {",
          "84:     initialized = true;",
          "85:   }",
          "91:   slab_sym = Persistent<String>::New(String::NewSymbol(\"slab\"));",
          "",
          "[Added Lines]",
          "72: static SlabAllocator slab_allocator(SLAB_SIZE);",
          "77:   if (initialized) return;",
          "78:   initialized = true;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "152: }",
          "170: uv_buf_t StreamWrap::OnAlloc(uv_handle_t* handle, size_t suggested_size) {",
          "173:   StreamWrap* wrap = static_cast<StreamWrap*>(handle->data);",
          "174:   assert(wrap->stream_ == reinterpret_cast<uv_stream_t*>(handle));",
          "209: }",
          "",
          "[Removed Lines]",
          "155: char* StreamWrap::NewSlab(Handle<Object> global,",
          "156:                           Handle<Object> wrap_obj) {",
          "157:   HandleScope scope;",
          "158:   Local<Value> arg = Integer::NewFromUnsigned(SLAB_SIZE);",
          "159:   Local<Object> b = Buffer::constructor_template->GetFunction()->",
          "160:     NewInstance(1, &arg);",
          "161:   if (b.IsEmpty()) return NULL;",
          "162:   global->SetHiddenValue(slab_sym, b);",
          "163:   assert(Buffer::Length(b) == SLAB_SIZE);",
          "164:   slab_used = 0;",
          "165:   wrap_obj->SetHiddenValue(slab_sym, b);",
          "166:   return Buffer::Data(b);",
          "167: }",
          "171:   HandleScope scope;",
          "176:   char* slab = NULL;",
          "178:   Handle<Object> global = Context::GetCurrent()->Global();",
          "179:   Local<Value> slab_v = global->GetHiddenValue(slab_sym);",
          "181:   if (slab_v.IsEmpty()) {",
          "183:     slab = NewSlab(global, wrap->object_);",
          "184:   } else {",
          "186:     Local<Object> slab_obj = slab_v->ToObject();",
          "187:     slab = Buffer::Data(slab_obj);",
          "188:     assert(Buffer::Length(slab_obj) == SLAB_SIZE);",
          "189:     assert(SLAB_SIZE >= slab_used);",
          "192:     if (SLAB_SIZE - slab_used < 64 * 1024) {",
          "193:       slab = NewSlab(global, wrap->object_);",
          "194:     } else {",
          "195:       wrap->object_->SetHiddenValue(slab_sym, slab_obj);",
          "196:     }",
          "197:   }",
          "199:   uv_buf_t buf;",
          "200:   buf.base = slab + slab_used;",
          "201:   buf.len = MIN(SLAB_SIZE - slab_used, suggested_size);",
          "203:   wrap->slab_offset_ = slab_used;",
          "204:   slab_used += buf.len;",
          "206:   handle_that_last_alloced = reinterpret_cast<uv_stream_t*>(handle);",
          "208:   return buf;",
          "",
          "[Added Lines]",
          "150:   char* buf = slab_allocator.Allocate(wrap->object_, suggested_size);",
          "151:   return uv_buf_init(buf, suggested_size);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "220:   assert(wrap->object_.IsEmpty() == false);",
          "226:   if (nread < 0)  {",
          "232:     SetErrno(uv_last_error(uv_default_loop()));",
          "233:     MakeCallback(wrap->object_, \"onread\", 0, NULL);",
          "234:     return;",
          "235:   }",
          "243:   if (nread == 0) return;",
          "245:   int argc = 3;",
          "246:   Local<Value> argv[4] = {",
          "250:   };",
          "252:   Local<Object> pending_obj;",
          "",
          "[Removed Lines]",
          "223:   Local<Value> slab_v = wrap->object_->GetHiddenValue(slab_sym);",
          "224:   wrap->object_->SetHiddenValue(slab_sym, v8::Null());",
          "228:     if (handle_that_last_alloced == handle) {",
          "229:       slab_used -= buf.len;",
          "230:     }",
          "237:   assert(static_cast<size_t>(nread) <= buf.len);",
          "239:   if (handle_that_last_alloced == handle) {",
          "240:     slab_used -= (buf.len - nread);",
          "241:   }",
          "247:     slab_v,",
          "248:     Integer::New(wrap->slab_offset_),",
          "249:     Integer::New(nread)",
          "",
          "[Added Lines]",
          "165:   Local<Object> slab = slab_allocator.Shrink(wrap->object_,",
          "166:                                              buf.base,",
          "167:                                              nread < 0 ? 0 : nread);",
          "176:   assert(static_cast<size_t>(nread) <= buf.len);",
          "180:     slab,",
          "181:     Integer::NewFromUnsigned(buf.base - Buffer::Data(slab)),",
          "182:     Integer::NewFromUnsigned(nread)",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "c6c6f98f1c33e9569b885e89750278fc6a211080",
      "candidate_info": {
        "commit_hash": "c6c6f98f1c33e9569b885e89750278fc6a211080",
        "repo": "joyent/node",
        "commit_url": "https://github.com/joyent/node/commit/c6c6f98f1c33e9569b885e89750278fc6a211080",
        "files": [
          "lib/child_process.js",
          "lib/cluster.js",
          "lib/util.js"
        ],
        "message": "util: add `util._extend` for extending objects\n\nThere were 2 duplicates with such functionality in `cluster` and\n`child_process` modules which were replaced by this function.",
        "before_after_code_files": [
          "lib/child_process.js||lichild_process.js",
          "lib/cluster.js||licluster.js",
          "lib/util.js||liutil.js"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/roamm/node/pull/1",
          "https://github.com/kingzone/node/pull/1",
          "https://github.com/OpenFPGAduino/node/pull/1"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "lib/child_process.js||lichild_process.js": [
          "File: lib/child_process.js -> lichild_process.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "22: var EventEmitter = require('events').EventEmitter;",
          "23: var net = require('net');",
          "24: var Process = process.binding('process_wrap').Process;",
          "26: var constants; // if (!constants) constants = process.binding('constants');",
          "28: var Pipe;",
          "",
          "[Removed Lines]",
          "25: var inherits = require('util').inherits;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "53:   return s;",
          "54: }",
          "70: function setupChannel(target, channel) {",
          "71:   target._channel = channel;",
          "",
          "[Removed Lines]",
          "56: function mergeOptions(target, overrides) {",
          "57:   if (overrides) {",
          "58:     var keys = Object.keys(overrides);",
          "59:     for (var i = 0, len = keys.length; i < len; i++) {",
          "60:       var k = keys[i];",
          "61:       if (overrides[k] !== undefined) {",
          "62:         target[k] = overrides[k];",
          "63:       }",
          "64:     }",
          "65:   }",
          "66:   return target;",
          "67: }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "244:     args = ['/s', '/c', '\"' + command + '\"'];",
          "248:     options.windowsVerbatimArguments = true;",
          "249:   } else {",
          "250:     file = '/bin/sh';",
          "",
          "[Removed Lines]",
          "247:     options = mergeOptions({}, options);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "281:   }",
          "286:   var child = spawn(file, args, {",
          "287:     cwd: options.cwd,",
          "",
          "[Removed Lines]",
          "284:   mergeOptions(options, optionArg);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "430:     maybeExit(self);",
          "431:   };",
          "432: }",
          "436: function setStreamOption(name, index, options) {",
          "",
          "[Removed Lines]",
          "433: inherits(ChildProcess, EventEmitter);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "lib/cluster.js||licluster.js": [
          "File: lib/cluster.js -> licluster.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "29:   return (typeof o === 'object' && o !== null);",
          "30: }",
          "44: var debug;",
          "45: if (process.env.NODE_DEBUG && /cluster/.test(process.env.NODE_DEBUG)) {",
          "46:   debug = function(x) {",
          "",
          "[Removed Lines]",
          "32: function extendObject(origin, add) {",
          "34:   if (!add) return origin;",
          "36:   var keys = Object.keys(add),",
          "37:       i = keys.length;",
          "38:   while (i--) {",
          "39:     origin[keys[i]] = add[keys[i]];",
          "40:   }",
          "41:   return origin;",
          "42: }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "140: function internalMessage(inMessage) {",
          "144:   outMessage.cmd = INTERNAL_PREFIX + (outMessage.cmd || '');",
          "",
          "[Removed Lines]",
          "141:   var outMessage = extendObject({}, inMessage);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "172: function handleMessage(worker, inMessage, inHandle) {",
          "176:   message.cmd = inMessage.cmd.substr(INTERNAL_PREFIX.length);",
          "178:   var respondUsed = false;",
          "",
          "[Removed Lines]",
          "175:   var message = extendObject({}, inMessage);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "280:     envCopy['NODE_UNIQUE_ID'] = this.uniqueID;",
          "282:     if (isObject(customEnv)) {",
          "284:     }",
          "",
          "[Removed Lines]",
          "279:     var envCopy = extendObject({}, env);",
          "283:       envCopy = extendObject(envCopy, customEnv);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "lib/util.js||liutil.js": [
          "File: lib/util.js -> liutil.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "506:     }",
          "507:   });",
          "508: };",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "66116924edb6fcdb2b30f809f479e3f750ca4d61",
      "candidate_info": {
        "commit_hash": "66116924edb6fcdb2b30f809f479e3f750ca4d61",
        "repo": "joyent/node",
        "commit_url": "https://github.com/joyent/node/commit/66116924edb6fcdb2b30f809f479e3f750ca4d61",
        "files": [
          "src/node.cc",
          "src/node_isolate.cc",
          "src/node_isolate.h",
          "src/queue.h"
        ],
        "message": "isolates: add atexit() functionality for isolates",
        "before_after_code_files": [
          "src/node.cc||src/node.cc",
          "src/node_isolate.cc||src/node_isolate.cc",
          "src/node_isolate.h||src/node_isolate.h",
          "src/queue.h||src/queue.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/roamm/node/pull/1",
          "https://github.com/kingzone/node/pull/1",
          "https://github.com/OpenFPGAduino/node/pull/1"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "src/node.cc||src/node.cc": [
          "File: src/node.cc -> src/node.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "2650:   v8::Context::Scope context_scope(context);",
          "2655:   Handle<Object> process_l = SetupProcessObject(argc, argv);",
          "",
          "[Removed Lines]",
          "2653:   Isolate::New(uv_default_loop());",
          "",
          "[Added Lines]",
          "2653:   Isolate* isolate = Isolate::New(uv_default_loop());",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2670:   EmitExit(process_l);",
          "2672: #ifndef NDEBUG",
          "2674:   context.Dispose();",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2672:   isolate->Dispose();",
          "",
          "---------------"
        ],
        "src/node_isolate.cc||src/node_isolate.cc": [
          "File: src/node_isolate.cc -> src/node_isolate.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "22: #include \"node_isolate.h\"",
          "23: #include <assert.h>",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "24: #include <stdlib.h>",
          "25: #include <string.h>",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "34: Isolate::Isolate(uv_loop_t* loop) {",
          "35:   loop_ = loop;",
          "36:   isolate_ = v8::Isolate::GetCurrent();",
          "37:   assert(isolate_->GetData() == NULL);",
          "38:   isolate_->SetData(this);",
          "39: }",
          "42: } // namespace node",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "40:   SLIST_INIT(&at_exit_callbacks_);",
          "46: void Isolate::AtExit(AtExitCallback callback, void* arg) {",
          "47:   struct AtExitCallbackInfo* it = new AtExitCallbackInfo;",
          "49:   NODE_ISOLATE_CHECK(this);",
          "51:   it->callback_ = callback;",
          "52:   it->arg_ = arg;",
          "54:   SLIST_INSERT_HEAD(&at_exit_callbacks_, it, entries_);",
          "55: }",
          "58: void Isolate::Dispose() {",
          "59:   struct AtExitCallbackInfo* it;",
          "61:   NODE_ISOLATE_CHECK(this);",
          "63:   SLIST_FOREACH(it, &at_exit_callbacks_, entries_) {",
          "64:     it->callback_(it->arg_);",
          "65:     delete it;",
          "66:   }",
          "67: }",
          "",
          "---------------"
        ],
        "src/node_isolate.h||src/node_isolate.h": [
          "File: src/node_isolate.h -> src/node_isolate.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "22: #ifndef SRC_NODE_ISOLATE_H_",
          "23: #define SRC_NODE_ISOLATE_H_",
          "28: #ifdef NDEBUG",
          "29: # define NODE_ISOLATE_CHECK(ptr) ((void) (ptr))",
          "",
          "[Removed Lines]",
          "25: #include <v8.h>",
          "26: #include <uv.h>",
          "",
          "[Added Lines]",
          "25: #include \"queue.h\"",
          "26: #include \"v8.h\"",
          "27: #include \"uv.h\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "43: class Isolate {",
          "44: public:",
          "45:   static Isolate* New(uv_loop_t* loop);",
          "47:   static Isolate* GetCurrent() {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "46:   typedef void (*AtExitCallback)(void* arg);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "58:     return isolate_;",
          "59:   }",
          "61: private:",
          "62:   Isolate(uv_loop_t* loop);",
          "63:   v8::Isolate* isolate_;",
          "64:   uv_loop_t* loop_;",
          "65: };",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "67:   void AtExit(AtExitCallback callback, void *arg);",
          "70:   void Dispose();",
          "75:   struct AtExitCallbackInfo {",
          "76:     SLIST_ENTRY(AtExitCallbackInfo) entries_;",
          "77:     AtExitCallback callback_;",
          "78:     void* arg_;",
          "79:   };",
          "81:   SLIST_HEAD(AtExitCallbacks, AtExitCallbackInfo) at_exit_callbacks_;",
          "",
          "---------------"
        ],
        "src/queue.h||src/queue.h": [
          "File: src/queue.h -> src/queue.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "34: #ifndef _SYS_QUEUE_H_",
          "35: #define _SYS_QUEUE_H_",
          "86: #define LIST_HEAD(name, type)      \\",
          "87: struct name {        \\",
          "88:  struct type *lh_first; /* first element */   \\",
          "89: }",
          "91: #define LIST_HEAD_INITIALIZER(head)     \\",
          "92:  { NULL }",
          "94: #define LIST_ENTRY(type)      \\",
          "95: struct {        \\",
          "96:  struct type *le_next; /* next element */   \\",
          "97:  struct type **le_prev; /* address of previous next element */ \\",
          "98: }",
          "103: #if defined(_KERNEL) && defined(QUEUEDEBUG)",
          "104: #define QUEUEDEBUG_LIST_INSERT_HEAD(head, elm, field)   \\",
          "105:  if ((head)->lh_first &&      \\",
          "106:      (head)->lh_first->field.le_prev != &(head)->lh_first) \\",
          "107:   panic(\"LIST_INSERT_HEAD %p %s:%d\", (head), __FILE__, __LINE__);",
          "108: #define QUEUEDEBUG_LIST_OP(elm, field)     \\",
          "109:  if ((elm)->field.le_next &&     \\",
          "110:      (elm)->field.le_next->field.le_prev !=   \\",
          "111:      &(elm)->field.le_next)     \\",
          "112:   panic(\"LIST_* forw %p %s:%d\", (elm), __FILE__, __LINE__);\\",
          "113:  if (*(elm)->field.le_prev != (elm))    \\",
          "114:   panic(\"LIST_* back %p %s:%d\", (elm), __FILE__, __LINE__);",
          "115: #define QUEUEDEBUG_LIST_POSTREMOVE(elm, field)    \\",
          "116:  (elm)->field.le_next = (void *)1L;    \\",
          "117:  (elm)->field.le_prev = (void *)1L;",
          "118: #else",
          "119: #define QUEUEDEBUG_LIST_INSERT_HEAD(head, elm, field)",
          "120: #define QUEUEDEBUG_LIST_OP(elm, field)",
          "121: #define QUEUEDEBUG_LIST_POSTREMOVE(elm, field)",
          "122: #endif",
          "124: #define LIST_INIT(head) do {      \\",
          "125:  (head)->lh_first = NULL;     \\",
          "126: } while (/*CONSTCOND*/0)",
          "128: #define LIST_INSERT_AFTER(listelm, elm, field) do {   \\",
          "129:  QUEUEDEBUG_LIST_OP((listelm), field)    \\",
          "130:  if (((elm)->field.le_next = (listelm)->field.le_next) != NULL) \\",
          "131:   (listelm)->field.le_next->field.le_prev =  \\",
          "132:       &(elm)->field.le_next;    \\",
          "133:  (listelm)->field.le_next = (elm);    \\",
          "134:  (elm)->field.le_prev = &(listelm)->field.le_next;  \\",
          "135: } while (/*CONSTCOND*/0)",
          "137: #define LIST_INSERT_BEFORE(listelm, elm, field) do {   \\",
          "138:  QUEUEDEBUG_LIST_OP((listelm), field)    \\",
          "139:  (elm)->field.le_prev = (listelm)->field.le_prev;  \\",
          "140:  (elm)->field.le_next = (listelm);    \\",
          "142:  (listelm)->field.le_prev = &(elm)->field.le_next;  \\",
          "143: } while (/*CONSTCOND*/0)",
          "145: #define LIST_INSERT_HEAD(head, elm, field) do {    \\",
          "146:  QUEUEDEBUG_LIST_INSERT_HEAD((head), (elm), field)  \\",
          "147:  if (((elm)->field.le_next = (head)->lh_first) != NULL)  \\",
          "148:   (head)->lh_first->field.le_prev = &(elm)->field.le_next;\\",
          "149:  (head)->lh_first = (elm);     \\",
          "150:  (elm)->field.le_prev = &(head)->lh_first;   \\",
          "151: } while (/*CONSTCOND*/0)",
          "153: #define LIST_REMOVE(elm, field) do {     \\",
          "154:  QUEUEDEBUG_LIST_OP((elm), field)    \\",
          "155:  if ((elm)->field.le_next != NULL)    \\",
          "156:   (elm)->field.le_next->field.le_prev =    \\",
          "157:       (elm)->field.le_prev;    \\",
          "159:  QUEUEDEBUG_LIST_POSTREMOVE((elm), field)   \\",
          "160: } while (/*CONSTCOND*/0)",
          "162: #define LIST_FOREACH(var, head, field)     \\",
          "163:  for ((var) = ((head)->lh_first);    \\",
          "164:   (var);       \\",
          "165:   (var) = ((var)->field.le_next))",
          "167: #define LIST_FOREACH_SAFE(var, head, field, tvar)   \\",
          "168:  for ((var) = LIST_FIRST((head));    \\",
          "169:   (var) && ((tvar) = LIST_NEXT((var), field), 1);  \\",
          "170:   (var) = (tvar))",
          "174: #define LIST_EMPTY(head)  ((head)->lh_first == NULL)",
          "175: #define LIST_FIRST(head)  ((head)->lh_first)",
          "176: #define LIST_NEXT(elm, field)  ((elm)->field.le_next)",
          "182: #define SLIST_HEAD(name, type)      \\",
          "183: struct name {        \\",
          "184:  struct type *slh_first; /* first element */   \\",
          "185: }",
          "187: #define SLIST_HEAD_INITIALIZER(head)     \\",
          "188:  { NULL }",
          "190: #define SLIST_ENTRY(type)      \\",
          "191: struct {        \\",
          "192:  struct type *sle_next; /* next element */   \\",
          "193: }",
          "198: #define SLIST_INIT(head) do {      \\",
          "199:  (head)->slh_first = NULL;     \\",
          "200: } while (/*CONSTCOND*/0)",
          "202: #define SLIST_INSERT_AFTER(slistelm, elm, field) do {   \\",
          "203:  (elm)->field.sle_next = (slistelm)->field.sle_next;  \\",
          "204:  (slistelm)->field.sle_next = (elm);    \\",
          "205: } while (/*CONSTCOND*/0)",
          "207: #define SLIST_INSERT_HEAD(head, elm, field) do {   \\",
          "208:  (elm)->field.sle_next = (head)->slh_first;   \\",
          "209:  (head)->slh_first = (elm);     \\",
          "210: } while (/*CONSTCOND*/0)",
          "212: #define SLIST_REMOVE_HEAD(head, field) do {    \\",
          "213:  (head)->slh_first = (head)->slh_first->field.sle_next;  \\",
          "214: } while (/*CONSTCOND*/0)",
          "216: #define SLIST_REMOVE(head, elm, type, field) do {   \\",
          "217:  if ((head)->slh_first == (elm)) {    \\",
          "218:   SLIST_REMOVE_HEAD((head), field);   \\",
          "219:  }        \\",
          "220:  else {        \\",
          "221:   struct type *curelm = (head)->slh_first;  \\",
          "222:   while(curelm->field.sle_next != (elm))   \\",
          "223:    curelm = curelm->field.sle_next;  \\",
          "224:   curelm->field.sle_next =    \\",
          "225:       curelm->field.sle_next->field.sle_next;  \\",
          "226:  }        \\",
          "227: } while (/*CONSTCOND*/0)",
          "229: #define SLIST_REMOVE_AFTER(slistelm, field) do {   \\",
          "230:  (slistelm)->field.sle_next =     \\",
          "231:      SLIST_NEXT(SLIST_NEXT((slistelm), field), field);  \\",
          "232: } while (/*CONSTCOND*/0)",
          "234: #define SLIST_FOREACH(var, head, field)     \\",
          "235:  for((var) = (head)->slh_first; (var); (var) = (var)->field.sle_next)",
          "237: #define SLIST_FOREACH_SAFE(var, head, field, tvar)   \\",
          "238:  for ((var) = SLIST_FIRST((head));    \\",
          "239:      (var) && ((tvar) = SLIST_NEXT((var), field), 1);  \\",
          "240:      (var) = (tvar))",
          "245: #define SLIST_EMPTY(head) ((head)->slh_first == NULL)",
          "246: #define SLIST_FIRST(head) ((head)->slh_first)",
          "247: #define SLIST_NEXT(elm, field) ((elm)->field.sle_next)",
          "253: #define STAILQ_HEAD(name, type)     \\",
          "254: struct name {        \\",
          "255:  struct type *stqh_first; /* first element */   \\",
          "256:  struct type **stqh_last; /* addr of last next element */  \\",
          "257: }",
          "259: #define STAILQ_HEAD_INITIALIZER(head)     \\",
          "260:  { NULL, &(head).stqh_first }",
          "262: #define STAILQ_ENTRY(type)      \\",
          "263: struct {        \\",
          "264:  struct type *stqe_next; /* next element */   \\",
          "265: }",
          "270: #define STAILQ_INIT(head) do {      \\",
          "271:  (head)->stqh_first = NULL;     \\",
          "272:  (head)->stqh_last = &(head)->stqh_first;    \\",
          "273: } while (/*CONSTCOND*/0)",
          "275: #define STAILQ_INSERT_HEAD(head, elm, field) do {   \\",
          "276:  if (((elm)->field.stqe_next = (head)->stqh_first) == NULL) \\",
          "277:   (head)->stqh_last = &(elm)->field.stqe_next;  \\",
          "278:  (head)->stqh_first = (elm);     \\",
          "279: } while (/*CONSTCOND*/0)",
          "281: #define STAILQ_INSERT_TAIL(head, elm, field) do {   \\",
          "282:  (elm)->field.stqe_next = NULL;     \\",
          "284:  (head)->stqh_last = &(elm)->field.stqe_next;   \\",
          "285: } while (/*CONSTCOND*/0)",
          "287: #define STAILQ_INSERT_AFTER(head, listelm, elm, field) do {  \\",
          "288:  if (((elm)->field.stqe_next = (listelm)->field.stqe_next) == NULL)\\",
          "289:   (head)->stqh_last = &(elm)->field.stqe_next;  \\",
          "290:  (listelm)->field.stqe_next = (elm);    \\",
          "291: } while (/*CONSTCOND*/0)",
          "293: #define STAILQ_REMOVE_HEAD(head, field) do {    \\",
          "294:  if (((head)->stqh_first = (head)->stqh_first->field.stqe_next) == NULL) \\",
          "295:   (head)->stqh_last = &(head)->stqh_first;   \\",
          "296: } while (/*CONSTCOND*/0)",
          "298: #define STAILQ_REMOVE(head, elm, type, field) do {   \\",
          "299:  if ((head)->stqh_first == (elm)) {    \\",
          "300:   STAILQ_REMOVE_HEAD((head), field);   \\",
          "301:  } else {       \\",
          "302:   struct type *curelm = (head)->stqh_first;  \\",
          "303:   while (curelm->field.stqe_next != (elm))   \\",
          "304:    curelm = curelm->field.stqe_next;  \\",
          "305:   if ((curelm->field.stqe_next =    \\",
          "306:    curelm->field.stqe_next->field.stqe_next) == NULL) \\",
          "307:        (head)->stqh_last = &(curelm)->field.stqe_next; \\",
          "308:  }        \\",
          "309: } while (/*CONSTCOND*/0)",
          "311: #define STAILQ_FOREACH(var, head, field)    \\",
          "312:  for ((var) = ((head)->stqh_first);    \\",
          "313:   (var);       \\",
          "314:   (var) = ((var)->field.stqe_next))",
          "316: #define STAILQ_FOREACH_SAFE(var, head, field, tvar)   \\",
          "317:  for ((var) = STAILQ_FIRST((head));    \\",
          "318:      (var) && ((tvar) = STAILQ_NEXT((var), field), 1);  \\",
          "319:      (var) = (tvar))",
          "321: #define STAILQ_CONCAT(head1, head2) do {    \\",
          "322:  if (!STAILQ_EMPTY((head2))) {     \\",
          "324:   (head1)->stqh_last = (head2)->stqh_last;  \\",
          "325:   STAILQ_INIT((head2));     \\",
          "326:  }        \\",
          "327: } while (/*CONSTCOND*/0)",
          "329: #define STAILQ_LAST(head, type, field)     \\",
          "330:  (STAILQ_EMPTY((head)) ?      \\",
          "331:   NULL :       \\",
          "332:          ((struct type *)(void *)    \\",
          "333:   ((char *)((head)->stqh_last) - offsetof(struct type, field))))",
          "338: #define STAILQ_EMPTY(head) ((head)->stqh_first == NULL)",
          "339: #define STAILQ_FIRST(head) ((head)->stqh_first)",
          "340: #define STAILQ_NEXT(elm, field) ((elm)->field.stqe_next)",
          "346: #define SIMPLEQ_HEAD(name, type)     \\",
          "347: struct name {        \\",
          "348:  struct type *sqh_first; /* first element */   \\",
          "349:  struct type **sqh_last; /* addr of last next element */  \\",
          "350: }",
          "352: #define SIMPLEQ_HEAD_INITIALIZER(head)     \\",
          "353:  { NULL, &(head).sqh_first }",
          "355: #define SIMPLEQ_ENTRY(type)      \\",
          "356: struct {        \\",
          "357:  struct type *sqe_next; /* next element */   \\",
          "358: }",
          "363: #define SIMPLEQ_INIT(head) do {      \\",
          "364:  (head)->sqh_first = NULL;     \\",
          "365:  (head)->sqh_last = &(head)->sqh_first;    \\",
          "366: } while (/*CONSTCOND*/0)",
          "368: #define SIMPLEQ_INSERT_HEAD(head, elm, field) do {   \\",
          "369:  if (((elm)->field.sqe_next = (head)->sqh_first) == NULL) \\",
          "370:   (head)->sqh_last = &(elm)->field.sqe_next;  \\",
          "371:  (head)->sqh_first = (elm);     \\",
          "372: } while (/*CONSTCOND*/0)",
          "374: #define SIMPLEQ_INSERT_TAIL(head, elm, field) do {   \\",
          "375:  (elm)->field.sqe_next = NULL;     \\",
          "377:  (head)->sqh_last = &(elm)->field.sqe_next;   \\",
          "378: } while (/*CONSTCOND*/0)",
          "380: #define SIMPLEQ_INSERT_AFTER(head, listelm, elm, field) do {  \\",
          "381:  if (((elm)->field.sqe_next = (listelm)->field.sqe_next) == NULL)\\",
          "382:   (head)->sqh_last = &(elm)->field.sqe_next;  \\",
          "383:  (listelm)->field.sqe_next = (elm);    \\",
          "384: } while (/*CONSTCOND*/0)",
          "386: #define SIMPLEQ_REMOVE_HEAD(head, field) do {    \\",
          "387:  if (((head)->sqh_first = (head)->sqh_first->field.sqe_next) == NULL) \\",
          "388:   (head)->sqh_last = &(head)->sqh_first;   \\",
          "389: } while (/*CONSTCOND*/0)",
          "391: #define SIMPLEQ_REMOVE(head, elm, type, field) do {   \\",
          "392:  if ((head)->sqh_first == (elm)) {    \\",
          "393:   SIMPLEQ_REMOVE_HEAD((head), field);   \\",
          "394:  } else {       \\",
          "395:   struct type *curelm = (head)->sqh_first;  \\",
          "396:   while (curelm->field.sqe_next != (elm))   \\",
          "397:    curelm = curelm->field.sqe_next;  \\",
          "398:   if ((curelm->field.sqe_next =    \\",
          "399:    curelm->field.sqe_next->field.sqe_next) == NULL) \\",
          "400:        (head)->sqh_last = &(curelm)->field.sqe_next; \\",
          "401:  }        \\",
          "402: } while (/*CONSTCOND*/0)",
          "404: #define SIMPLEQ_FOREACH(var, head, field)    \\",
          "405:  for ((var) = ((head)->sqh_first);    \\",
          "406:   (var);       \\",
          "407:   (var) = ((var)->field.sqe_next))",
          "409: #define SIMPLEQ_FOREACH_SAFE(var, head, field, next)   \\",
          "410:  for ((var) = ((head)->sqh_first);    \\",
          "411:   (var) && ((next = ((var)->field.sqe_next)), 1);  \\",
          "412:   (var) = (next))",
          "414: #define SIMPLEQ_CONCAT(head1, head2) do {    \\",
          "415:  if (!SIMPLEQ_EMPTY((head2))) {     \\",
          "417:   (head1)->sqh_last = (head2)->sqh_last;  \\",
          "418:   SIMPLEQ_INIT((head2));     \\",
          "419:  }        \\",
          "420: } while (/*CONSTCOND*/0)",
          "422: #define SIMPLEQ_LAST(head, type, field)     \\",
          "423:  (SIMPLEQ_EMPTY((head)) ?      \\",
          "424:   NULL :       \\",
          "425:          ((struct type *)(void *)    \\",
          "426:   ((char *)((head)->sqh_last) - offsetof(struct type, field))))",
          "431: #define SIMPLEQ_EMPTY(head)  ((head)->sqh_first == NULL)",
          "432: #define SIMPLEQ_FIRST(head)  ((head)->sqh_first)",
          "433: #define SIMPLEQ_NEXT(elm, field) ((elm)->field.sqe_next)",
          "439: #define _TAILQ_HEAD(name, type, qual)     \\",
          "440: struct name {        \\",
          "441:  qual type *tqh_first;  /* first element */  \\",
          "442:  qual type *qual *tqh_last; /* addr of last next element */ \\",
          "443: }",
          "444: #define TAILQ_HEAD(name, type) _TAILQ_HEAD(name, struct type,)",
          "446: #define TAILQ_HEAD_INITIALIZER(head)     \\",
          "447:  { NULL, &(head).tqh_first }",
          "449: #define _TAILQ_ENTRY(type, qual)     \\",
          "450: struct {        \\",
          "451:  qual type *tqe_next;  /* next element */  \\",
          "452:  qual type *qual *tqe_prev; /* address of previous next element */\\",
          "453: }",
          "454: #define TAILQ_ENTRY(type) _TAILQ_ENTRY(struct type,)",
          "459: #if defined(_KERNEL) && defined(QUEUEDEBUG)",
          "460: #define QUEUEDEBUG_TAILQ_INSERT_HEAD(head, elm, field)   \\",
          "461:  if ((head)->tqh_first &&     \\",
          "462:      (head)->tqh_first->field.tqe_prev != &(head)->tqh_first) \\",
          "463:   panic(\"TAILQ_INSERT_HEAD %p %s:%d\", (head), __FILE__, __LINE__);",
          "464: #define QUEUEDEBUG_TAILQ_INSERT_TAIL(head, elm, field)   \\",
          "465:  if (*(head)->tqh_last != NULL)     \\",
          "466:   panic(\"TAILQ_INSERT_TAIL %p %s:%d\", (head), __FILE__, __LINE__);",
          "467: #define QUEUEDEBUG_TAILQ_OP(elm, field)     \\",
          "468:  if ((elm)->field.tqe_next &&     \\",
          "469:      (elm)->field.tqe_next->field.tqe_prev !=   \\",
          "470:      &(elm)->field.tqe_next)     \\",
          "471:   panic(\"TAILQ_* forw %p %s:%d\", (elm), __FILE__, __LINE__);\\",
          "472:  if (*(elm)->field.tqe_prev != (elm))    \\",
          "473:   panic(\"TAILQ_* back %p %s:%d\", (elm), __FILE__, __LINE__);",
          "474: #define QUEUEDEBUG_TAILQ_PREREMOVE(head, elm, field)   \\",
          "475:  if ((elm)->field.tqe_next == NULL &&    \\",
          "476:      (head)->tqh_last != &(elm)->field.tqe_next)   \\",
          "477:   panic(\"TAILQ_PREREMOVE head %p elm %p %s:%d\",  \\",
          "478:         (head), (elm), __FILE__, __LINE__);",
          "479: #define QUEUEDEBUG_TAILQ_POSTREMOVE(elm, field)    \\",
          "480:  (elm)->field.tqe_next = (void *)1L;    \\",
          "481:  (elm)->field.tqe_prev = (void *)1L;",
          "482: #else",
          "483: #define QUEUEDEBUG_TAILQ_INSERT_HEAD(head, elm, field)",
          "484: #define QUEUEDEBUG_TAILQ_INSERT_TAIL(head, elm, field)",
          "485: #define QUEUEDEBUG_TAILQ_OP(elm, field)",
          "486: #define QUEUEDEBUG_TAILQ_PREREMOVE(head, elm, field)",
          "487: #define QUEUEDEBUG_TAILQ_POSTREMOVE(elm, field)",
          "488: #endif",
          "490: #define TAILQ_INIT(head) do {      \\",
          "491:  (head)->tqh_first = NULL;     \\",
          "492:  (head)->tqh_last = &(head)->tqh_first;    \\",
          "493: } while (/*CONSTCOND*/0)",
          "495: #define TAILQ_INSERT_HEAD(head, elm, field) do {   \\",
          "496:  QUEUEDEBUG_TAILQ_INSERT_HEAD((head), (elm), field)  \\",
          "497:  if (((elm)->field.tqe_next = (head)->tqh_first) != NULL) \\",
          "498:   (head)->tqh_first->field.tqe_prev =   \\",
          "499:       &(elm)->field.tqe_next;    \\",
          "500:  else        \\",
          "501:   (head)->tqh_last = &(elm)->field.tqe_next;  \\",
          "502:  (head)->tqh_first = (elm);     \\",
          "503:  (elm)->field.tqe_prev = &(head)->tqh_first;   \\",
          "504: } while (/*CONSTCOND*/0)",
          "506: #define TAILQ_INSERT_TAIL(head, elm, field) do {   \\",
          "507:  QUEUEDEBUG_TAILQ_INSERT_TAIL((head), (elm), field)  \\",
          "508:  (elm)->field.tqe_next = NULL;     \\",
          "509:  (elm)->field.tqe_prev = (head)->tqh_last;   \\",
          "511:  (head)->tqh_last = &(elm)->field.tqe_next;   \\",
          "512: } while (/*CONSTCOND*/0)",
          "514: #define TAILQ_INSERT_AFTER(head, listelm, elm, field) do {  \\",
          "515:  QUEUEDEBUG_TAILQ_OP((listelm), field)    \\",
          "516:  if (((elm)->field.tqe_next = (listelm)->field.tqe_next) != NULL)\\",
          "517:   (elm)->field.tqe_next->field.tqe_prev =   \\",
          "518:       &(elm)->field.tqe_next;    \\",
          "519:  else        \\",
          "520:   (head)->tqh_last = &(elm)->field.tqe_next;  \\",
          "521:  (listelm)->field.tqe_next = (elm);    \\",
          "522:  (elm)->field.tqe_prev = &(listelm)->field.tqe_next;  \\",
          "523: } while (/*CONSTCOND*/0)",
          "525: #define TAILQ_INSERT_BEFORE(listelm, elm, field) do {   \\",
          "526:  QUEUEDEBUG_TAILQ_OP((listelm), field)    \\",
          "527:  (elm)->field.tqe_prev = (listelm)->field.tqe_prev;  \\",
          "528:  (elm)->field.tqe_next = (listelm);    \\",
          "530:  (listelm)->field.tqe_prev = &(elm)->field.tqe_next;  \\",
          "531: } while (/*CONSTCOND*/0)",
          "533: #define TAILQ_REMOVE(head, elm, field) do {    \\",
          "534:  QUEUEDEBUG_TAILQ_PREREMOVE((head), (elm), field)  \\",
          "535:  QUEUEDEBUG_TAILQ_OP((elm), field)    \\",
          "536:  if (((elm)->field.tqe_next) != NULL)    \\",
          "537:   (elm)->field.tqe_next->field.tqe_prev =   \\",
          "538:       (elm)->field.tqe_prev;    \\",
          "539:  else        \\",
          "540:   (head)->tqh_last = (elm)->field.tqe_prev;  \\",
          "542:  QUEUEDEBUG_TAILQ_POSTREMOVE((elm), field);   \\",
          "543: } while (/*CONSTCOND*/0)",
          "545: #define TAILQ_FOREACH(var, head, field)     \\",
          "546:  for ((var) = ((head)->tqh_first);    \\",
          "547:   (var);       \\",
          "548:   (var) = ((var)->field.tqe_next))",
          "550: #define TAILQ_FOREACH_SAFE(var, head, field, next)   \\",
          "551:  for ((var) = ((head)->tqh_first);    \\",
          "552:          (var) != NULL && ((next) = TAILQ_NEXT(var, field), 1); \\",
          "553:   (var) = (next))",
          "555: #define TAILQ_FOREACH_REVERSE(var, head, headname, field)  \\",
          "556:  for ((var) = (*(((struct headname *)((head)->tqh_last))->tqh_last)); \\",
          "557:   (var);       \\",
          "558:   (var) = (*(((struct headname *)((var)->field.tqe_prev))->tqh_last)))",
          "560: #define TAILQ_FOREACH_REVERSE_SAFE(var, head, headname, field, prev) \\",
          "561:  for ((var) = TAILQ_LAST((head), headname);   \\",
          "562:   (var) && ((prev) = TAILQ_PREV((var), headname, field), 1);\\",
          "563:   (var) = (prev))",
          "565: #define TAILQ_CONCAT(head1, head2, field) do {    \\",
          "566:  if (!TAILQ_EMPTY(head2)) {     \\",
          "568:   (head2)->tqh_first->field.tqe_prev = (head1)->tqh_last; \\",
          "569:   (head1)->tqh_last = (head2)->tqh_last;   \\",
          "570:   TAILQ_INIT((head2));     \\",
          "571:  }        \\",
          "572: } while (/*CONSTCOND*/0)",
          "577: #define TAILQ_EMPTY(head)  ((head)->tqh_first == NULL)",
          "578: #define TAILQ_FIRST(head)  ((head)->tqh_first)",
          "579: #define TAILQ_NEXT(elm, field)  ((elm)->field.tqe_next)",
          "581: #define TAILQ_LAST(head, headname) \\",
          "582:  (*(((struct headname *)((head)->tqh_last))->tqh_last))",
          "583: #define TAILQ_PREV(elm, headname, field) \\",
          "584:  (*(((struct headname *)((elm)->field.tqe_prev))->tqh_last))",
          "590: #if defined(_KERNEL) && defined(QUEUEDEBUG)",
          "591: #define QUEUEDEBUG_CIRCLEQ_HEAD(head, field)    \\",
          "592:  if ((head)->cqh_first != (void *)(head) &&   \\",
          "593:      (head)->cqh_first->field.cqe_prev != (void *)(head)) \\",
          "594:   panic(\"CIRCLEQ head forw %p %s:%d\", (head),  \\",
          "595:         __FILE__, __LINE__);    \\",
          "596:  if ((head)->cqh_last != (void *)(head) &&   \\",
          "597:      (head)->cqh_last->field.cqe_next != (void *)(head))  \\",
          "598:   panic(\"CIRCLEQ head back %p %s:%d\", (head),  \\",
          "599:         __FILE__, __LINE__);",
          "600: #define QUEUEDEBUG_CIRCLEQ_ELM(head, elm, field)   \\",
          "601:  if ((elm)->field.cqe_next == (void *)(head)) {   \\",
          "602:   if ((head)->cqh_last != (elm))    \\",
          "603:    panic(\"CIRCLEQ elm last %p %s:%d\", (elm), \\",
          "604:          __FILE__, __LINE__);   \\",
          "605:  } else {       \\",
          "606:   if ((elm)->field.cqe_next->field.cqe_prev != (elm)) \\",
          "607:    panic(\"CIRCLEQ elm forw %p %s:%d\", (elm), \\",
          "608:          __FILE__, __LINE__);   \\",
          "609:  }        \\",
          "610:  if ((elm)->field.cqe_prev == (void *)(head)) {   \\",
          "611:   if ((head)->cqh_first != (elm))    \\",
          "612:    panic(\"CIRCLEQ elm first %p %s:%d\", (elm), \\",
          "613:          __FILE__, __LINE__);   \\",
          "614:  } else {       \\",
          "615:   if ((elm)->field.cqe_prev->field.cqe_next != (elm)) \\",
          "616:    panic(\"CIRCLEQ elm prev %p %s:%d\", (elm), \\",
          "617:          __FILE__, __LINE__);   \\",
          "618:  }",
          "619: #define QUEUEDEBUG_CIRCLEQ_POSTREMOVE(elm, field)   \\",
          "620:  (elm)->field.cqe_next = (void *)1L;    \\",
          "621:  (elm)->field.cqe_prev = (void *)1L;",
          "622: #else",
          "623: #define QUEUEDEBUG_CIRCLEQ_HEAD(head, field)",
          "624: #define QUEUEDEBUG_CIRCLEQ_ELM(head, elm, field)",
          "625: #define QUEUEDEBUG_CIRCLEQ_POSTREMOVE(elm, field)",
          "626: #endif",
          "628: #define CIRCLEQ_HEAD(name, type)     \\",
          "629: struct name {        \\",
          "630:  struct type *cqh_first;  /* first element */  \\",
          "631:  struct type *cqh_last;  /* last element */  \\",
          "632: }",
          "634: #define CIRCLEQ_HEAD_INITIALIZER(head)     \\",
          "635:  { (void *)&head, (void *)&head }",
          "637: #define CIRCLEQ_ENTRY(type)      \\",
          "638: struct {        \\",
          "639:  struct type *cqe_next;  /* next element */  \\",
          "640:  struct type *cqe_prev;  /* previous element */  \\",
          "641: }",
          "646: #define CIRCLEQ_INIT(head) do {      \\",
          "647:  (head)->cqh_first = (void *)(head);    \\",
          "648:  (head)->cqh_last = (void *)(head);    \\",
          "649: } while (/*CONSTCOND*/0)",
          "651: #define CIRCLEQ_INSERT_AFTER(head, listelm, elm, field) do {  \\",
          "652:  QUEUEDEBUG_CIRCLEQ_HEAD((head), field)    \\",
          "653:  QUEUEDEBUG_CIRCLEQ_ELM((head), (listelm), field)  \\",
          "654:  (elm)->field.cqe_next = (listelm)->field.cqe_next;  \\",
          "655:  (elm)->field.cqe_prev = (listelm);    \\",
          "656:  if ((listelm)->field.cqe_next == (void *)(head))  \\",
          "657:   (head)->cqh_last = (elm);    \\",
          "658:  else        \\",
          "659:   (listelm)->field.cqe_next->field.cqe_prev = (elm); \\",
          "660:  (listelm)->field.cqe_next = (elm);    \\",
          "661: } while (/*CONSTCOND*/0)",
          "663: #define CIRCLEQ_INSERT_BEFORE(head, listelm, elm, field) do {  \\",
          "664:  QUEUEDEBUG_CIRCLEQ_HEAD((head), field)    \\",
          "665:  QUEUEDEBUG_CIRCLEQ_ELM((head), (listelm), field)  \\",
          "666:  (elm)->field.cqe_next = (listelm);    \\",
          "667:  (elm)->field.cqe_prev = (listelm)->field.cqe_prev;  \\",
          "668:  if ((listelm)->field.cqe_prev == (void *)(head))  \\",
          "669:   (head)->cqh_first = (elm);    \\",
          "670:  else        \\",
          "671:   (listelm)->field.cqe_prev->field.cqe_next = (elm); \\",
          "672:  (listelm)->field.cqe_prev = (elm);    \\",
          "673: } while (/*CONSTCOND*/0)",
          "675: #define CIRCLEQ_INSERT_HEAD(head, elm, field) do {   \\",
          "676:  QUEUEDEBUG_CIRCLEQ_HEAD((head), field)    \\",
          "677:  (elm)->field.cqe_next = (head)->cqh_first;   \\",
          "678:  (elm)->field.cqe_prev = (void *)(head);    \\",
          "679:  if ((head)->cqh_last == (void *)(head))    \\",
          "680:   (head)->cqh_last = (elm);    \\",
          "681:  else        \\",
          "682:   (head)->cqh_first->field.cqe_prev = (elm);  \\",
          "683:  (head)->cqh_first = (elm);     \\",
          "684: } while (/*CONSTCOND*/0)",
          "686: #define CIRCLEQ_INSERT_TAIL(head, elm, field) do {   \\",
          "687:  QUEUEDEBUG_CIRCLEQ_HEAD((head), field)    \\",
          "688:  (elm)->field.cqe_next = (void *)(head);    \\",
          "689:  (elm)->field.cqe_prev = (head)->cqh_last;   \\",
          "690:  if ((head)->cqh_first == (void *)(head))   \\",
          "691:   (head)->cqh_first = (elm);    \\",
          "692:  else        \\",
          "693:   (head)->cqh_last->field.cqe_next = (elm);  \\",
          "694:  (head)->cqh_last = (elm);     \\",
          "695: } while (/*CONSTCOND*/0)",
          "697: #define CIRCLEQ_REMOVE(head, elm, field) do {    \\",
          "698:  QUEUEDEBUG_CIRCLEQ_HEAD((head), field)    \\",
          "699:  QUEUEDEBUG_CIRCLEQ_ELM((head), (elm), field)   \\",
          "700:  if ((elm)->field.cqe_next == (void *)(head))   \\",
          "701:   (head)->cqh_last = (elm)->field.cqe_prev;  \\",
          "702:  else        \\",
          "703:   (elm)->field.cqe_next->field.cqe_prev =   \\",
          "704:       (elm)->field.cqe_prev;    \\",
          "705:  if ((elm)->field.cqe_prev == (void *)(head))   \\",
          "706:   (head)->cqh_first = (elm)->field.cqe_next;  \\",
          "707:  else        \\",
          "708:   (elm)->field.cqe_prev->field.cqe_next =   \\",
          "709:       (elm)->field.cqe_next;    \\",
          "710:  QUEUEDEBUG_CIRCLEQ_POSTREMOVE((elm), field)   \\",
          "711: } while (/*CONSTCOND*/0)",
          "713: #define CIRCLEQ_FOREACH(var, head, field)    \\",
          "714:  for ((var) = ((head)->cqh_first);    \\",
          "715:   (var) != (const void *)(head);    \\",
          "716:   (var) = ((var)->field.cqe_next))",
          "718: #define CIRCLEQ_FOREACH_REVERSE(var, head, field)   \\",
          "719:  for ((var) = ((head)->cqh_last);    \\",
          "720:   (var) != (const void *)(head);    \\",
          "721:   (var) = ((var)->field.cqe_prev))",
          "726: #define CIRCLEQ_EMPTY(head)  ((head)->cqh_first == (void *)(head))",
          "727: #define CIRCLEQ_FIRST(head)  ((head)->cqh_first)",
          "728: #define CIRCLEQ_LAST(head)  ((head)->cqh_last)",
          "729: #define CIRCLEQ_NEXT(elm, field) ((elm)->field.cqe_next)",
          "730: #define CIRCLEQ_PREV(elm, field) ((elm)->field.cqe_prev)",
          "732: #define CIRCLEQ_LOOP_NEXT(head, elm, field)    \\",
          "733:  (((elm)->field.cqe_next == (void *)(head))   \\",
          "734:      ? ((head)->cqh_first)     \\",
          "735:      : (elm->field.cqe_next))",
          "736: #define CIRCLEQ_LOOP_PREV(head, elm, field)    \\",
          "737:  (((elm)->field.cqe_prev == (void *)(head))   \\",
          "738:      ? ((head)->cqh_last)     \\",
          "739:      : (elm->field.cqe_prev))",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2013-1943",
  "cve_desc": "The KVM subsystem in the Linux kernel before 3.0 does not check whether kernel addresses are specified during allocation of memory slots for use in a guest's physical address space, which allows local users to gain privileges or obtain sensitive information from kernel memory via a crafted application, related to arch/x86/kvm/paging_tmpl.h and virt/kvm/kvm_main.c.",
  "repo": "torvalds/linux",
  "patch_hash": "fa3d315a4ce2c0891cdde262562e710d95fba19e",
  "patch_info": {
    "commit_hash": "fa3d315a4ce2c0891cdde262562e710d95fba19e",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/fa3d315a4ce2c0891cdde262562e710d95fba19e",
    "files": [
      "arch/x86/kvm/paging_tmpl.h",
      "virt/kvm/kvm_main.c"
    ],
    "message": "KVM: Validate userspace_addr of memslot when registered\n\nThis way, we can avoid checking the user space address many times when\nwe read the guest memory.\n\nAlthough we can do the same for write if we check which slots are\nwritable, we do not care write now: reading the guest memory happens\nmore often than writing.\n\n[avi: change VERIFY_READ to VERIFY_WRITE]\n\nSigned-off-by: Takuya Yoshikawa <yoshikawa.takuya@oss.ntt.co.jp>\nSigned-off-by: Avi Kivity <avi@redhat.com>",
    "before_after_code_files": [
      "arch/x86/kvm/paging_tmpl.h||arch/x86/kvm/paging_tmpl.h",
      "virt/kvm/kvm_main.c||virt/kvm/kvm_main.c"
    ]
  },
  "patch_diff": {
    "arch/x86/kvm/paging_tmpl.h||arch/x86/kvm/paging_tmpl.h": [
      "File: arch/x86/kvm/paging_tmpl.h -> arch/x86/kvm/paging_tmpl.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "185:   }",
      "187:   ptep_user = (pt_element_t __user *)((void *)host_addr + offset);",
      "189:    present = false;",
      "190:    break;",
      "191:   }",
      "",
      "[Removed Lines]",
      "188:   if (unlikely(copy_from_user(&pte, ptep_user, sizeof(pte)))) {",
      "",
      "[Added Lines]",
      "188:   if (unlikely(__copy_from_user(&pte, ptep_user, sizeof(pte)))) {",
      "",
      "---------------"
    ],
    "virt/kvm/kvm_main.c||virt/kvm/kvm_main.c": [
      "File: virt/kvm/kvm_main.c -> virt/kvm/kvm_main.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "648:   goto out;",
      "649:  if (mem->guest_phys_addr & (PAGE_SIZE - 1))",
      "650:   goto out;",
      "652:   goto out;",
      "653:  if (mem->slot >= KVM_MEMORY_SLOTS + KVM_PRIVATE_MEM_SLOTS)",
      "654:   goto out;",
      "",
      "[Removed Lines]",
      "651:  if (user_alloc && (mem->userspace_addr & (PAGE_SIZE - 1)))",
      "",
      "[Added Lines]",
      "652:  if (user_alloc &&",
      "653:      ((mem->userspace_addr & (PAGE_SIZE - 1)) ||",
      "654:       !access_ok(VERIFY_WRITE, mem->userspace_addr, mem->memory_size)))",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "1283:  addr = gfn_to_hva(kvm, gfn);",
      "1284:  if (kvm_is_error_hva(addr))",
      "1285:   return -EFAULT;",
      "1287:  if (r)",
      "1288:   return -EFAULT;",
      "1289:  return 0;",
      "",
      "[Removed Lines]",
      "1286:  r = copy_from_user(data, (void __user *)addr + offset, len);",
      "",
      "[Added Lines]",
      "1289:  r = __copy_from_user(data, (void __user *)addr + offset, len);",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "12cb814f3bb35736420cc6bfc9fed7b6a9d3a828",
      "candidate_info": {
        "commit_hash": "12cb814f3bb35736420cc6bfc9fed7b6a9d3a828",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/12cb814f3bb35736420cc6bfc9fed7b6a9d3a828",
        "files": [
          "arch/x86/kvm/paging_tmpl.h"
        ],
        "message": "KVM: MMU: Clean up gpte reading with copy_from_user()\n\nWhen we optimized walk_addr_generic() by not using the generic guest\nmemory reader, we replaced copy_from_user() with get_user():\n\n  commit e30d2a170506830d5eef5e9d7990c5aedf1b0a51\n  KVM: MMU: Optimize guest page table walk\n\n  commit 15e2ac9a43d4d7d08088e404fddf2533a8e7d52e\n  KVM: MMU: Fix 64-bit paging breakage on x86_32\n\nBut as Andi pointed out later, copy_from_user() does the same as\nget_user() as long as we give a constant size to it.\n\nSo we use copy_from_user() to clean up the code.\n\nThe only, noticeable, regression introduced by this is 64-bit gpte\nreading on x86_32 hosts needed for PAE guests.\n\nBut this can be mitigated by implementing 8-byte get_user() for x86_32,\nif needed.\n\nSigned-off-by: Takuya Yoshikawa <yoshikawa.takuya@oss.ntt.co.jp>\nSigned-off-by: Avi Kivity <avi@redhat.com>",
        "before_after_code_files": [
          "arch/x86/kvm/paging_tmpl.h||arch/x86/kvm/paging_tmpl.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "arch/x86/kvm/paging_tmpl.h||arch/x86/kvm/paging_tmpl.h"
          ],
          "candidate": [
            "arch/x86/kvm/paging_tmpl.h||arch/x86/kvm/paging_tmpl.h"
          ]
        }
      },
      "candidate_diff": {
        "arch/x86/kvm/paging_tmpl.h||arch/x86/kvm/paging_tmpl.h": [
          "File: arch/x86/kvm/paging_tmpl.h -> arch/x86/kvm/paging_tmpl.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "115:  return access;",
          "116: }",
          "",
          "[Removed Lines]",
          "118: static int FNAME(read_gpte)(pt_element_t *pte, pt_element_t __user *ptep_user)",
          "119: {",
          "120: #if defined(CONFIG_X86_32) && (PTTYPE == 64)",
          "121:  u32 *p = (u32 *)pte;",
          "122:  u32 __user *p_user = (u32 __user *)ptep_user;",
          "124:  if (unlikely(get_user(*p, p_user)))",
          "125:   return -EFAULT;",
          "126:  return get_user(*(p + 1), p_user + 1);",
          "127: #else",
          "128:  return get_user(*pte, ptep_user);",
          "129: #endif",
          "130: }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "199:   }",
          "201:   ptep_user = (pt_element_t __user *)((void *)host_addr + offset);",
          "203:    present = false;",
          "204:    break;",
          "205:   }",
          "",
          "[Removed Lines]",
          "202:   if (unlikely(FNAME(read_gpte)(&pte, ptep_user))) {",
          "",
          "[Added Lines]",
          "188:   if (unlikely(copy_from_user(&pte, ptep_user, sizeof(pte)))) {",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "f59c1d2ded54e4bd7a9126f4a32c9eca8b336457",
      "candidate_info": {
        "commit_hash": "f59c1d2ded54e4bd7a9126f4a32c9eca8b336457",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/f59c1d2ded54e4bd7a9126f4a32c9eca8b336457",
        "files": [
          "arch/x86/kvm/paging_tmpl.h"
        ],
        "message": "KVM: MMU: Keep going on permission error\n\nReal hardware disregards permission errors when computing page fault error\ncode bit 0 (page present).  Do the same.\n\nReviewed-by: Xiao Guangrong <xiaoguangrong@cn.fujitsu.com>\nSigned-off-by: Avi Kivity <avi@redhat.com>",
        "before_after_code_files": [
          "arch/x86/kvm/paging_tmpl.h||arch/x86/kvm/paging_tmpl.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "arch/x86/kvm/paging_tmpl.h||arch/x86/kvm/paging_tmpl.h"
          ],
          "candidate": [
            "arch/x86/kvm/paging_tmpl.h||arch/x86/kvm/paging_tmpl.h"
          ]
        }
      },
      "candidate_diff": {
        "arch/x86/kvm/paging_tmpl.h||arch/x86/kvm/paging_tmpl.h": [
          "File: arch/x86/kvm/paging_tmpl.h -> arch/x86/kvm/paging_tmpl.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "119: {",
          "120:  pt_element_t pte;",
          "121:  gfn_t table_gfn;",
          "123:  gpa_t pte_gpa;",
          "126:  trace_kvm_mmu_pagetable_walk(addr, write_fault, user_fault,",
          "127:          fetch_fault);",
          "128: walk:",
          "129:  walker->level = vcpu->arch.mmu.root_level;",
          "130:  pte = vcpu->arch.cr3;",
          "131: #if PTTYPE == 64",
          "132:  if (!is_long_mode(vcpu)) {",
          "133:   pte = kvm_pdptr_read(vcpu, (addr >> 30) & 3);",
          "134:   trace_kvm_mmu_paging_element(pte, walker->level);",
          "137:   --walker->level;",
          "138:  }",
          "139: #endif",
          "",
          "[Removed Lines]",
          "122:  unsigned index, pt_access, pte_access;",
          "124:  int rsvd_fault = 0;",
          "135:   if (!is_present_gpte(pte))",
          "136:    goto not_present;",
          "",
          "[Added Lines]",
          "122:  unsigned index, pt_access, uninitialized_var(pte_access);",
          "124:  bool eperm, present, rsvd_fault;",
          "129:  present = true;",
          "130:  eperm = rsvd_fault = false;",
          "137:   if (!is_present_gpte(pte)) {",
          "138:    present = false;",
          "139:    goto error;",
          "140:   }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "151:   walker->table_gfn[walker->level - 1] = table_gfn;",
          "152:   walker->pte_gpa[walker->level - 1] = pte_gpa;",
          "157:   trace_kvm_mmu_paging_element(pte, walker->level);",
          "166:   if (write_fault && !is_writable_pte(pte))",
          "167:    if (user_fault || is_write_protection(vcpu))",
          "170:   if (user_fault && !(pte & PT_USER_MASK))",
          "173: #if PTTYPE == 64",
          "174:   if (fetch_fault && (pte & PT64_NX_MASK))",
          "176: #endif",
          "179:    trace_kvm_mmu_set_accessed_bit(table_gfn, index,",
          "180:              sizeof(pte));",
          "181:    if (FNAME(cmpxchg_gpte)(vcpu->kvm, table_gfn,",
          "",
          "[Removed Lines]",
          "154:   if (kvm_read_guest(vcpu->kvm, pte_gpa, &pte, sizeof(pte)))",
          "155:    goto not_present;",
          "159:   if (!is_present_gpte(pte))",
          "160:    goto not_present;",
          "162:   rsvd_fault = is_rsvd_bits_set(vcpu, pte, walker->level);",
          "163:   if (rsvd_fault)",
          "164:    goto access_error;",
          "168:     goto access_error;",
          "171:    goto access_error;",
          "175:    goto access_error;",
          "178:   if (!(pte & PT_ACCESSED_MASK)) {",
          "",
          "[Added Lines]",
          "158:   if (kvm_read_guest(vcpu->kvm, pte_gpa, &pte, sizeof(pte))) {",
          "159:    present = false;",
          "160:    break;",
          "161:   }",
          "165:   if (!is_present_gpte(pte)) {",
          "166:    present = false;",
          "167:    break;",
          "168:   }",
          "170:   if (is_rsvd_bits_set(vcpu, pte, walker->level)) {",
          "171:    rsvd_fault = true;",
          "172:    break;",
          "173:   }",
          "177:     eperm = true;",
          "180:    eperm = true;",
          "184:    eperm = true;",
          "187:   if (!eperm && !rsvd_fault && !(pte & PT_ACCESSED_MASK)) {",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "214:   --walker->level;",
          "215:  }",
          "217:  if (write_fault && !is_dirty_gpte(pte)) {",
          "218:   bool ret;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "226:  if (!present || eperm || rsvd_fault)",
          "227:   goto error;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "233:    __func__, (u64)pte, pte_access, pt_access);",
          "234:  return 1;",
          "237:  walker->error_code = 0;",
          "244:  if (write_fault)",
          "245:   walker->error_code |= PFERR_WRITE_MASK;",
          "246:  if (user_fault)",
          "",
          "[Removed Lines]",
          "236: not_present:",
          "238:  goto err;",
          "240: access_error:",
          "241:  walker->error_code = PFERR_PRESENT_MASK;",
          "243: err:",
          "",
          "[Added Lines]",
          "248: error:",
          "250:  if (present)",
          "251:   walker->error_code |= PFERR_PRESENT_MASK;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "2329d46d213d0721dafae18db29f54b196f11468",
      "candidate_info": {
        "commit_hash": "2329d46d213d0721dafae18db29f54b196f11468",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/2329d46d213d0721dafae18db29f54b196f11468",
        "files": [
          "arch/x86/kvm/paging_tmpl.h"
        ],
        "message": "KVM: MMU: Make walk_addr_generic capable for two-level walking\n\nThis patch uses kvm_read_guest_page_tdp to make the\nwalk_addr_generic functions suitable for two-level page\ntable walking.\n\nSigned-off-by: Joerg Roedel <joerg.roedel@amd.com>\nSigned-off-by: Avi Kivity <avi@redhat.com>",
        "before_after_code_files": [
          "arch/x86/kvm/paging_tmpl.h||arch/x86/kvm/paging_tmpl.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "arch/x86/kvm/paging_tmpl.h||arch/x86/kvm/paging_tmpl.h"
          ],
          "candidate": [
            "arch/x86/kvm/paging_tmpl.h||arch/x86/kvm/paging_tmpl.h"
          ]
        }
      },
      "candidate_diff": {
        "arch/x86/kvm/paging_tmpl.h||arch/x86/kvm/paging_tmpl.h": [
          "File: arch/x86/kvm/paging_tmpl.h -> arch/x86/kvm/paging_tmpl.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "124:  unsigned index, pt_access, uninitialized_var(pte_access);",
          "125:  gpa_t pte_gpa;",
          "126:  bool eperm, present, rsvd_fault;",
          "128:  trace_kvm_mmu_pagetable_walk(addr, write_fault, user_fault,",
          "129:          fetch_fault);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "127:  int offset;",
          "128:  u32 access = 0;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "153:   index = PT_INDEX(addr, walker->level);",
          "155:   table_gfn = gpte_to_gfn(pte);",
          "158:   walker->table_gfn[walker->level - 1] = table_gfn;",
          "159:   walker->pte_gpa[walker->level - 1] = pte_gpa;",
          "162:    present = false;",
          "163:    break;",
          "164:   }",
          "",
          "[Removed Lines]",
          "156:   pte_gpa = gfn_to_gpa(table_gfn);",
          "157:   pte_gpa += index * sizeof(pt_element_t);",
          "161:   if (kvm_read_guest(vcpu->kvm, pte_gpa, &pte, sizeof(pte))) {",
          "",
          "[Added Lines]",
          "158:   offset    = index * sizeof(pt_element_t);",
          "159:   pte_gpa   = gfn_to_gpa(table_gfn) + offset;",
          "163:   if (kvm_read_guest_page_mmu(vcpu, mmu, table_gfn, &pte,",
          "164:          offset, sizeof(pte),",
          "165:          PFERR_USER_MASK|PFERR_WRITE_MASK)) {",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "209:     is_large_pte(pte) &&",
          "210:     mmu->root_level == PT64_ROOT_LEVEL)) {",
          "211:    int lvl = walker->level;",
          "217:    if (PTTYPE == 32 &&",
          "218:        walker->level == PT_DIRECTORY_LEVEL &&",
          "219:        is_cpuid_PSE36())",
          "222:    break;",
          "223:   }",
          "",
          "[Removed Lines]",
          "213:    walker->gfn = gpte_to_gfn_lvl(pte, lvl);",
          "214:    walker->gfn += (addr & PT_LVL_OFFSET_MASK(lvl))",
          "215:      >> PAGE_SHIFT;",
          "220:     walker->gfn += pse36_gfn_delta(pte);",
          "",
          "[Added Lines]",
          "216:    gpa_t real_gpa;",
          "217:    gfn_t gfn;",
          "219:    gfn = gpte_to_gfn_lvl(pte, lvl);",
          "220:    gfn += (addr & PT_LVL_OFFSET_MASK(lvl)) >> PAGE_SHIFT;",
          "225:     gfn += pse36_gfn_delta(pte);",
          "227:    access |= write_fault ? PFERR_WRITE_MASK : 0;",
          "228:    access |= fetch_fault ? PFERR_FETCH_MASK : 0;",
          "229:    access |= user_fault  ? PFERR_USER_MASK  : 0;",
          "231:    real_gpa = mmu->translate_gpa(vcpu, gfn_to_gpa(gfn),",
          "232:             access);",
          "233:    if (real_gpa == UNMAPPED_GVA)",
          "234:     return 0;",
          "236:    walker->gfn = real_gpa >> PAGE_SHIFT;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "134291bf3cb434a9039298ba6b15ef33e65ba542",
      "candidate_info": {
        "commit_hash": "134291bf3cb434a9039298ba6b15ef33e65ba542",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/134291bf3cb434a9039298ba6b15ef33e65ba542",
        "files": [
          "arch/x86/kvm/paging_tmpl.h"
        ],
        "message": "KVM: MMU: Clean up the error handling of walk_addr_generic()\n\nAvoid two step jump to the error handling part.  This eliminates the use\nof the variables present and rsvd_fault.\n\nWe also use the const type qualifier to show that write/user/fetch_fault\ndo not change in the function.\n\nBoth of these were suggested by Ingo Molnar.\n\nCc: Ingo Molnar <mingo@elte.hu>\nSigned-off-by: Takuya Yoshikawa <yoshikawa.takuya@oss.ntt.co.jp>\nSigned-off-by: Marcelo Tosatti <mtosatti@redhat.com>",
        "before_after_code_files": [
          "arch/x86/kvm/paging_tmpl.h||arch/x86/kvm/paging_tmpl.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "arch/x86/kvm/paging_tmpl.h||arch/x86/kvm/paging_tmpl.h"
          ],
          "candidate": [
            "arch/x86/kvm/paging_tmpl.h||arch/x86/kvm/paging_tmpl.h"
          ]
        }
      },
      "candidate_diff": {
        "arch/x86/kvm/paging_tmpl.h||arch/x86/kvm/paging_tmpl.h": [
          "File: arch/x86/kvm/paging_tmpl.h -> arch/x86/kvm/paging_tmpl.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "125:  gfn_t table_gfn;",
          "126:  unsigned index, pt_access, uninitialized_var(pte_access);",
          "127:  gpa_t pte_gpa;",
          "135:  trace_kvm_mmu_pagetable_walk(addr, write_fault, user_fault,",
          "136:          fetch_fault);",
          "137: walk:",
          "140:  walker->level = mmu->root_level;",
          "141:  pte           = mmu->get_cr3(vcpu);",
          "",
          "[Removed Lines]",
          "128:  bool eperm, present, rsvd_fault;",
          "129:  int offset, write_fault, user_fault, fetch_fault;",
          "131:  write_fault = access & PFERR_WRITE_MASK;",
          "132:  user_fault = access & PFERR_USER_MASK;",
          "133:  fetch_fault = access & PFERR_FETCH_MASK;",
          "138:  present = true;",
          "139:  eperm = rsvd_fault = false;",
          "",
          "[Added Lines]",
          "128:  bool eperm;",
          "129:  int offset;",
          "130:  const int write_fault = access & PFERR_WRITE_MASK;",
          "131:  const int user_fault  = access & PFERR_USER_MASK;",
          "132:  const int fetch_fault = access & PFERR_FETCH_MASK;",
          "133:  u16 errcode = 0;",
          "138:  eperm = false;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "144:  if (walker->level == PT32E_ROOT_LEVEL) {",
          "145:   pte = kvm_pdptr_read_mmu(vcpu, mmu, (addr >> 30) & 3);",
          "146:   trace_kvm_mmu_paging_element(pte, walker->level);",
          "149:    goto error;",
          "151:   --walker->level;",
          "152:  }",
          "153: #endif",
          "",
          "[Removed Lines]",
          "147:   if (!is_present_gpte(pte)) {",
          "148:    present = false;",
          "150:   }",
          "",
          "[Added Lines]",
          "146:   if (!is_present_gpte(pte))",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "171:   real_gfn = mmu->translate_gpa(vcpu, gfn_to_gpa(table_gfn),",
          "172:            PFERR_USER_MASK|PFERR_WRITE_MASK);",
          "177:   real_gfn = gpa_to_gfn(real_gfn);",
          "179:   host_addr = gfn_to_hva(vcpu->kvm, real_gfn);",
          "185:   ptep_user = (pt_element_t __user *)((void *)host_addr + offset);",
          "191:   trace_kvm_mmu_paging_element(pte, walker->level);",
          "198:   if (unlikely(is_rsvd_bits_set(&vcpu->arch.mmu, pte,",
          "199:            walker->level))) {",
          "202:   }",
          "204:   if (unlikely(write_fault && !is_writable_pte(pte)",
          "",
          "[Removed Lines]",
          "173:   if (unlikely(real_gfn == UNMAPPED_GVA)) {",
          "174:    present = false;",
          "175:    break;",
          "176:   }",
          "180:   if (unlikely(kvm_is_error_hva(host_addr))) {",
          "181:    present = false;",
          "182:    break;",
          "183:   }",
          "186:   if (unlikely(__copy_from_user(&pte, ptep_user, sizeof(pte)))) {",
          "187:    present = false;",
          "188:    break;",
          "189:   }",
          "193:   if (unlikely(!is_present_gpte(pte))) {",
          "194:    present = false;",
          "195:    break;",
          "196:   }",
          "200:    rsvd_fault = true;",
          "201:    break;",
          "",
          "[Added Lines]",
          "170:   if (unlikely(real_gfn == UNMAPPED_GVA))",
          "171:    goto error;",
          "175:   if (unlikely(kvm_is_error_hva(host_addr)))",
          "176:    goto error;",
          "179:   if (unlikely(__copy_from_user(&pte, ptep_user, sizeof(pte))))",
          "180:    goto error;",
          "184:   if (unlikely(!is_present_gpte(pte)))",
          "185:    goto error;",
          "189:    errcode |= PFERR_RSVD_MASK | PFERR_PRESENT_MASK;",
          "190:    goto error;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "213:    eperm = true;",
          "214: #endif",
          "218:    int ret;",
          "219:    trace_kvm_mmu_set_accessed_bit(table_gfn, index,",
          "220:              sizeof(pte));",
          "221:    ret = FNAME(cmpxchg_gpte)(vcpu, mmu, ptep_user, index,",
          "222:         pte, pte|PT_ACCESSED_MASK);",
          "227:     goto walk;",
          "229:    mark_page_dirty(vcpu->kvm, table_gfn);",
          "",
          "[Removed Lines]",
          "216:   if (!eperm && !rsvd_fault",
          "217:       && unlikely(!(pte & PT_ACCESSED_MASK))) {",
          "223:    if (unlikely(ret < 0)) {",
          "224:     present = false;",
          "225:     break;",
          "226:    } else if (ret)",
          "",
          "[Added Lines]",
          "205:   if (!eperm && unlikely(!(pte & PT_ACCESSED_MASK))) {",
          "211:    if (unlikely(ret < 0))",
          "212:     goto error;",
          "213:    else if (ret)",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "276:   --walker->level;",
          "277:  }",
          "280:   goto error;",
          "282:  if (write_fault && unlikely(!is_dirty_gpte(pte))) {",
          "283:   int ret;",
          "",
          "[Removed Lines]",
          "279:  if (unlikely(!present || eperm || rsvd_fault))",
          "",
          "[Added Lines]",
          "266:  if (unlikely(eperm)) {",
          "267:   errcode |= PFERR_PRESENT_MASK;",
          "269:  }",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "285:   trace_kvm_mmu_set_dirty_bit(table_gfn, index, sizeof(pte));",
          "286:   ret = FNAME(cmpxchg_gpte)(vcpu, mmu, ptep_user, index,",
          "287:        pte, pte|PT_DIRTY_MASK);",
          "290:    goto error;",
          "292:    goto walk;",
          "294:   mark_page_dirty(vcpu->kvm, table_gfn);",
          "",
          "[Removed Lines]",
          "288:   if (unlikely(ret < 0)) {",
          "289:    present = false;",
          "291:   } else if (ret)",
          "",
          "[Added Lines]",
          "277:   if (unlikely(ret < 0))",
          "279:   else if (ret)",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "303:  return 1;",
          "305: error:",
          "314:  if (fetch_fault && (mmu->nx ||",
          "315:        kvm_read_cr4_bits(vcpu, X86_CR4_SMEP)))",
          "320:  walker->fault.address = addr;",
          "321:  walker->fault.nested_page_fault = mmu != vcpu->arch.walk_mmu;",
          "",
          "[Removed Lines]",
          "306:  walker->fault.vector = PF_VECTOR;",
          "307:  walker->fault.error_code_valid = true;",
          "308:  walker->fault.error_code = 0;",
          "309:  if (present)",
          "310:   walker->fault.error_code |= PFERR_PRESENT_MASK;",
          "312:  walker->fault.error_code |= write_fault | user_fault;",
          "316:   walker->fault.error_code |= PFERR_FETCH_MASK;",
          "317:  if (rsvd_fault)",
          "318:   walker->fault.error_code |= PFERR_RSVD_MASK;",
          "",
          "[Added Lines]",
          "294:  errcode |= write_fault | user_fault;",
          "297:   errcode |= PFERR_FETCH_MASK;",
          "299:  walker->fault.vector = PF_VECTOR;",
          "300:  walker->fault.error_code_valid = true;",
          "301:  walker->fault.error_code = errcode;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "8f74d8e16812d63639871b4e56409b08bdcb66fc",
      "candidate_info": {
        "commit_hash": "8f74d8e16812d63639871b4e56409b08bdcb66fc",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/8f74d8e16812d63639871b4e56409b08bdcb66fc",
        "files": [
          "arch/x86/kvm/paging_tmpl.h"
        ],
        "message": "KVM: MMU: Fix 64-bit paging breakage on x86_32\n\nFix regression introduced by\n  commit e30d2a170506830d5eef5e9d7990c5aedf1b0a51\n  KVM: MMU: Optimize guest page table walk\n\nOn x86_32, get_user() does not support 64-bit values and we fail to\nbuild KVM at the point of 64-bit paging.\n\nThis patch fixes this by using get_user() twice for that condition.\n\nSigned-off-by: Takuya Yoshikawa <yoshikawa.takuya@oss.ntt.co.jp>\nReported-by: Jan Kiszka <jan.kiszka@web.de>\nSigned-off-by: Avi Kivity <avi@redhat.com>",
        "before_after_code_files": [
          "arch/x86/kvm/paging_tmpl.h||arch/x86/kvm/paging_tmpl.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "arch/x86/kvm/paging_tmpl.h||arch/x86/kvm/paging_tmpl.h"
          ],
          "candidate": [
            "arch/x86/kvm/paging_tmpl.h||arch/x86/kvm/paging_tmpl.h"
          ]
        }
      },
      "candidate_diff": {
        "arch/x86/kvm/paging_tmpl.h||arch/x86/kvm/paging_tmpl.h": [
          "File: arch/x86/kvm/paging_tmpl.h -> arch/x86/kvm/paging_tmpl.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "115:  return access;",
          "116: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "118: static int FNAME(read_gpte)(pt_element_t *pte, pt_element_t __user *ptep_user)",
          "119: {",
          "120: #if defined(CONFIG_X86_32) && (PTTYPE == 64)",
          "121:  u32 *p = (u32 *)pte;",
          "122:  u32 __user *p_user = (u32 __user *)ptep_user;",
          "124:  if (unlikely(get_user(*p, p_user)))",
          "125:   return -EFAULT;",
          "126:  return get_user(*(p + 1), p_user + 1);",
          "127: #else",
          "128:  return get_user(*pte, ptep_user);",
          "129: #endif",
          "130: }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "185:   }",
          "187:   ptep_user = (pt_element_t __user *)((void *)host_addr + offset);",
          "189:    present = false;",
          "190:    break;",
          "191:   }",
          "",
          "[Removed Lines]",
          "188:   if (unlikely(get_user(pte, ptep_user))) {",
          "",
          "[Added Lines]",
          "202:   if (unlikely(FNAME(read_gpte)(&pte, ptep_user))) {",
          "",
          "---------------"
        ]
      }
    }
  ]
}
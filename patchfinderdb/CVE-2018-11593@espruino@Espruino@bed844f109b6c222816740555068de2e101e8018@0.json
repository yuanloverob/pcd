{
  "cve_id": "CVE-2018-11593",
  "cve_desc": "Espruino before 1.99 allows attackers to cause a denial of service (application crash) and potential Information Disclosure with a user crafted input file via a Buffer Overflow during syntax parsing because strncpy is misused in jslex.c.",
  "repo": "espruino/Espruino",
  "patch_hash": "bed844f109b6c222816740555068de2e101e8018",
  "patch_info": {
    "commit_hash": "bed844f109b6c222816740555068de2e101e8018",
    "repo": "espruino/Espruino",
    "commit_url": "https://github.com/espruino/Espruino/commit/bed844f109b6c222816740555068de2e101e8018",
    "files": [
      "src/jslex.c"
    ],
    "message": "remove strncpy usage as it's effectively useless, replace with an assertion since fn is only used internally (fix #1426)",
    "before_after_code_files": [
      "src/jslex.c||src/jslex.c"
    ]
  },
  "patch_diff": {
    "src/jslex.c||src/jslex.c": [
      "File: src/jslex.c -> src/jslex.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "713: }",
      "715: void jslTokenAsString(int token, char *str, size_t len) {",
      "717:   if (token>32 && token<128) {",
      "718:     assert(len>=4);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "716:   assert(len>28); // size of largest string",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "723:     return;",
      "724:   }",
      "726:   switch (token) {",
      "738:   }",
      "739:   if (token>=_LEX_OPERATOR_START && token<_LEX_R_LIST_END) {",
      "740:     const char tokenNames[] =",
      "",
      "[Removed Lines]",
      "727:   case LEX_EOF : strncpy(str, \"EOF\", len); return;",
      "728:   case LEX_ID : strncpy(str, \"ID\", len); return;",
      "729:   case LEX_INT : strncpy(str, \"INT\", len); return;",
      "730:   case LEX_FLOAT : strncpy(str, \"FLOAT\", len); return;",
      "731:   case LEX_STR : strncpy(str, \"STRING\", len); return;",
      "732:   case LEX_UNFINISHED_STR : strncpy(str, \"UNFINISHED STRING\", len); return;",
      "733:   case LEX_TEMPLATE_LITERAL : strncpy(str, \"TEMPLATE LITERAL\", len); return;",
      "734:   case LEX_UNFINISHED_TEMPLATE_LITERAL : strncpy(str, \"UNFINISHED TEMPLATE LITERAL\", len); return;",
      "735:   case LEX_REGEX : strncpy(str, \"REGEX\", len); return;",
      "736:   case LEX_UNFINISHED_REGEX : strncpy(str, \"UNFINISHED REGEX\", len); return;",
      "737:   case LEX_UNFINISHED_COMMENT : strncpy(str, \"UNFINISHED COMMENT\", len); return;",
      "",
      "[Added Lines]",
      "729:   case LEX_EOF : strcpy(str, \"EOF\"); return;",
      "730:   case LEX_ID : strcpy(str, \"ID\"); return;",
      "731:   case LEX_INT : strcpy(str, \"INT\"); return;",
      "732:   case LEX_FLOAT : strcpy(str, \"FLOAT\"); return;",
      "733:   case LEX_STR : strcpy(str, \"STRING\"); return;",
      "734:   case LEX_UNFINISHED_STR : strcpy(str, \"UNFINISHED STRING\"); return;",
      "735:   case LEX_TEMPLATE_LITERAL : strcpy(str, \"TEMPLATE LITERAL\"); return;",
      "736:   case LEX_UNFINISHED_TEMPLATE_LITERAL : strcpy(str, \"UNFINISHED TEMPLATE LITERAL\"); return;",
      "737:   case LEX_REGEX : strcpy(str, \"REGEX\"); return;",
      "738:   case LEX_UNFINISHED_REGEX : strcpy(str, \"UNFINISHED REGEX\"); return;",
      "739:   case LEX_UNFINISHED_COMMENT : strcpy(str, \"UNFINISHED COMMENT\"); return;",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "809:       n--; // next token",
      "810:     }",
      "811:     assert(n==0);",
      "813:     return;",
      "814:   }",
      "817:   espruino_snprintf(str, len, \"?[%d]\", token);",
      "818: }",
      "",
      "[Removed Lines]",
      "812:     strncpy(str, &tokenNames[p], len);",
      "816:   assert(len>=10);",
      "",
      "[Added Lines]",
      "814:     strcpy(str, &tokenNames[p]);",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "53621a1fd752d69025ca499b468ae1cc38166b77",
      "candidate_info": {
        "commit_hash": "53621a1fd752d69025ca499b468ae1cc38166b77",
        "repo": "espruino/Espruino",
        "commit_url": "https://github.com/espruino/Espruino/commit/53621a1fd752d69025ca499b468ae1cc38166b77",
        "files": [
          "ChangeLog",
          "src/jslex.c"
        ],
        "message": "Increase jslMatch error buffer size to handle \"UNFINISHED TEMPLATE LITERAL\" string (#1426)",
        "before_after_code_files": [
          "src/jslex.c||src/jslex.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [
            "src/jslex.c||src/jslex.c"
          ],
          "candidate": [
            "src/jslex.c||src/jslex.c"
          ]
        }
      },
      "candidate_diff": {
        "src/jslex.c||src/jslex.c": [
          "File: src/jslex.c -> src/jslex.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "856:          (lex->tk >= _LEX_R_LIST_START && lex->tk <= _LEX_R_LIST_END);",
          "857: }",
          "860: bool jslMatch(int expected_tk) {",
          "861:   if (lex->tk != expected_tk) {",
          "873:     return false;",
          "874:   }",
          "875:   jslGetNextToken();",
          "",
          "[Removed Lines]",
          "862:     char gotStr[20];",
          "863:     char expStr[20];",
          "864:     jslGetTokenString(gotStr, sizeof(gotStr));",
          "865:     jslTokenAsString(expected_tk, expStr, sizeof(expStr));",
          "867:     size_t oldPos = lex->tokenLastStart;",
          "868:     lex->tokenLastStart = jsvStringIteratorGetIndex(&lex->tokenStart.it)-1;",
          "869:     jsExceptionHere(JSET_SYNTAXERROR, \"Got %s expected %s\", gotStr, expStr);",
          "870:     lex->tokenLastStart = oldPos;",
          "872:     jslGetNextToken();",
          "",
          "[Added Lines]",
          "860: static void jslMatchError(int expected_tk) {",
          "861:   char gotStr[30];",
          "862:   char expStr[30];",
          "863:   jslGetTokenString(gotStr, sizeof(gotStr));",
          "864:   jslTokenAsString(expected_tk, expStr, sizeof(expStr));",
          "866:   size_t oldPos = lex->tokenLastStart;",
          "867:   lex->tokenLastStart = jsvStringIteratorGetIndex(&lex->tokenStart.it)-1;",
          "868:   jsExceptionHere(JSET_SYNTAXERROR, \"Got %s expected %s\", gotStr, expStr);",
          "869:   lex->tokenLastStart = oldPos;",
          "871:   jslGetNextToken();",
          "872: }",
          "877:     jslMatchError(expected_tk);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "a684871c56ec0afb5dea3cb8d46a4db94b0785e6",
      "candidate_info": {
        "commit_hash": "a684871c56ec0afb5dea3cb8d46a4db94b0785e6",
        "repo": "espruino/Espruino",
        "commit_url": "https://github.com/espruino/Espruino/commit/a684871c56ec0afb5dea3cb8d46a4db94b0785e6",
        "files": [
          "ChangeLog",
          "src/jslex.c",
          "src/jslex.h"
        ],
        "message": "Added RegEx lexing (part of #256)",
        "before_after_code_files": [
          "src/jslex.c||src/jslex.c",
          "src/jslex.h||src/jslex.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/jslex.c||src/jslex.c"
          ],
          "candidate": [
            "src/jslex.c||src/jslex.c"
          ]
        }
      },
      "candidate_diff": {
        "src/jslex.c||src/jslex.c": [
          "File: src/jslex.c -> src/jslex.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "210:   jslGetNextCh();",
          "211: }",
          "213: void jslGetNextToken() {",
          "214:   jslGetNextToken_start:",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "213: static void jslLexString() {",
          "214:   char delim = lex->currCh;",
          "215:   lex->tokenValue = jsvNewFromEmptyString();",
          "216:   if (!lex->tokenValue) {",
          "217:     lex->tk = LEX_EOF;",
          "218:     return;",
          "219:   }",
          "220:   JsvStringIterator it;",
          "221:   jsvStringIteratorNew(&it, lex->tokenValue, 0);",
          "223:   jslGetNextCh();",
          "224:   while (lex->currCh && lex->currCh!=delim) {",
          "225:     if (lex->currCh == '\\\\') {",
          "226:       jslGetNextCh();",
          "227:       char ch = lex->currCh;",
          "228:       switch (lex->currCh) {",
          "229:       case 'n'  : ch = 0x0A; jslGetNextCh(); break;",
          "230:       case 'b'  : ch = 0x08; jslGetNextCh(); break;",
          "231:       case 'f'  : ch = 0x0C; jslGetNextCh(); break;",
          "232:       case 'r'  : ch = 0x0D; jslGetNextCh(); break;",
          "233:       case 't'  : ch = 0x09; jslGetNextCh(); break;",
          "234:       case 'v'  : ch = 0x0B; jslGetNextCh(); break;",
          "235:       case 'u' :",
          "236:       case 'x' : { // hex digits",
          "237:         char buf[5] = \"0x??\";",
          "238:         if (lex->currCh == 'u') {",
          "241:           jslGetNextCh();",
          "242:           jslGetNextCh();",
          "243:         }",
          "244:         jslGetNextCh();",
          "245:         buf[2] = lex->currCh; jslGetNextCh();",
          "246:         buf[3] = lex->currCh; jslGetNextCh();",
          "247:         ch = (char)stringToInt(buf);",
          "248:       } break;",
          "249:       default:",
          "250:         if (lex->currCh>='0' && lex->currCh<='7') {",
          "252:           char buf[5] = \"0\";",
          "253:           buf[1] = lex->currCh;",
          "254:           int n=2;",
          "255:           jslGetNextCh();",
          "256:           if (lex->currCh>='0' && lex->currCh<='7') {",
          "257:             buf[n++] = lex->currCh; jslGetNextCh();",
          "258:             if (lex->currCh>='0' && lex->currCh<='7') {",
          "259:               buf[n++] = lex->currCh; jslGetNextCh();",
          "260:             }",
          "261:           }",
          "262:           buf[n]=0;",
          "263:           ch = (char)stringToInt(buf);",
          "264:         } else {",
          "266:           jslGetNextCh();",
          "267:         }",
          "268:         break;",
          "269:       }",
          "270:       jslTokenAppendChar(ch);",
          "271:       jsvStringIteratorAppend(&it, ch);",
          "272:     } else if (lex->currCh=='\\n' && delim!='`') {",
          "275:       break;",
          "276:     } else {",
          "277:       jslTokenAppendChar(lex->currCh);",
          "278:       jsvStringIteratorAppend(&it, lex->currCh);",
          "279:       jslGetNextCh();",
          "280:     }",
          "281:   }",
          "282:   jsvStringIteratorFree(&it);",
          "283:   if (delim=='`')",
          "284:     lex->tk = LEX_TEMPLATE_LITERAL;",
          "285:   else lex->tk = LEX_STR;",
          "287:   if (lex->currCh!=delim)",
          "288:     lex->tk++; // +1 gets you to 'unfinished X'",
          "289:   jslGetNextCh();",
          "290: }",
          "292: static void jslLexRegex() {",
          "293:   lex->tokenValue = jsvNewFromEmptyString();",
          "294:   if (!lex->tokenValue) {",
          "295:     lex->tk = LEX_EOF;",
          "296:     return;",
          "297:   }",
          "298:   JsvStringIterator it;",
          "299:   jsvStringIteratorNew(&it, lex->tokenValue, 0);",
          "300:   jsvStringIteratorAppend(&it, '/');",
          "302:   jslGetNextCh();",
          "303:   while (lex->currCh && lex->currCh!='/') {",
          "304:     if (lex->currCh == '\\\\') {",
          "305:       jsvStringIteratorAppend(&it, lex->currCh);",
          "306:       jslGetNextCh();",
          "307:     } else if (lex->currCh=='\\n') {",
          "310:       break;",
          "311:     }",
          "312:     jsvStringIteratorAppend(&it, lex->currCh);",
          "313:     jslGetNextCh();",
          "314:   }",
          "315:   lex->tk = LEX_REGEX;",
          "316:   if (lex->currCh!='/') {",
          "317:     lex->tk++; // +1 gets you to 'unfinished X'",
          "318:   } else {",
          "319:     jsvStringIteratorAppend(&it, '/');",
          "321:     if (lex->tk=='g' ||",
          "322:         lex->tk=='i' ||",
          "323:         lex->tk=='m' ||",
          "324:         lex->tk=='y' ||",
          "325:         lex->tk=='u') {",
          "326:       jslTokenAppendChar(lex->currCh);",
          "327:       jsvStringIteratorAppend(&it, lex->currCh);",
          "328:       jslGetNextCh();",
          "329:     }",
          "330:   }",
          "331:   jsvStringIteratorFree(&it);",
          "332:   jslGetNextCh();",
          "333: }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "237:       goto jslGetNextToken_start;",
          "238:     }",
          "239:   }",
          "240:   lex->tk = LEX_EOF;",
          "241:   lex->tokenl = 0; // clear token string",
          "242:   if (lex->tokenValue) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "362:   int lastToken = lex->tk;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "364:           }",
          "365:         }",
          "366:       } break;",
          "444:       case JSLJT_EXCLAMATION: jslSingleChar();",
          "445:       if (lex->currCh=='=') { // !=",
          "446:         lex->tk = LEX_NEQUAL;",
          "",
          "[Removed Lines]",
          "367:       case JSLJT_STRING:",
          "368:       {",
          "369:         char delim = lex->currCh;",
          "370:         lex->tokenValue = jsvNewFromEmptyString();",
          "371:         if (!lex->tokenValue) {",
          "372:           lex->tk = LEX_EOF;",
          "373:           return;",
          "374:         }",
          "375:         JsvStringIterator it;",
          "376:         jsvStringIteratorNew(&it, lex->tokenValue, 0);",
          "378:         jslGetNextCh();",
          "379:         while (lex->currCh && lex->currCh!=delim) {",
          "380:           if (lex->currCh == '\\\\') {",
          "381:             jslGetNextCh();",
          "382:             char ch = lex->currCh;",
          "383:             switch (lex->currCh) {",
          "384:             case 'n'  : ch = 0x0A; jslGetNextCh(); break;",
          "385:             case 'b'  : ch = 0x08; jslGetNextCh(); break;",
          "386:             case 'f'  : ch = 0x0C; jslGetNextCh(); break;",
          "387:             case 'r'  : ch = 0x0D; jslGetNextCh(); break;",
          "388:             case 't'  : ch = 0x09; jslGetNextCh(); break;",
          "389:             case 'v'  : ch = 0x0B; jslGetNextCh(); break;",
          "390:             case 'u' :",
          "391:             case 'x' : { // hex digits",
          "392:               char buf[5] = \"0x??\";",
          "393:               if (lex->currCh == 'u') {",
          "396:                 jslGetNextCh();",
          "397:                 jslGetNextCh();",
          "398:               }",
          "399:               jslGetNextCh();",
          "400:               buf[2] = lex->currCh; jslGetNextCh();",
          "401:               buf[3] = lex->currCh; jslGetNextCh();",
          "402:               ch = (char)stringToInt(buf);",
          "403:             } break;",
          "404:             default:",
          "405:               if (lex->currCh>='0' && lex->currCh<='7') {",
          "407:                 char buf[5] = \"0\";",
          "408:                 buf[1] = lex->currCh;",
          "409:                 int n=2;",
          "410:                 jslGetNextCh();",
          "411:                 if (lex->currCh>='0' && lex->currCh<='7') {",
          "412:                   buf[n++] = lex->currCh; jslGetNextCh();",
          "413:                   if (lex->currCh>='0' && lex->currCh<='7') {",
          "414:                     buf[n++] = lex->currCh; jslGetNextCh();",
          "415:                   }",
          "416:                 }",
          "417:                 buf[n]=0;",
          "418:                 ch = (char)stringToInt(buf);",
          "419:               } else {",
          "421:                 jslGetNextCh();",
          "422:               }",
          "423:               break;",
          "424:             }",
          "425:             jslTokenAppendChar(ch);",
          "426:             jsvStringIteratorAppend(&it, ch);",
          "427:           } else if (lex->currCh=='\\n' && delim!='`') {",
          "430:             break;",
          "431:           } else {",
          "432:             jslTokenAppendChar(lex->currCh);",
          "433:             jsvStringIteratorAppend(&it, lex->currCh);",
          "434:             jslGetNextCh();",
          "435:           }",
          "436:         }",
          "437:         jsvStringIteratorFree(&it);",
          "438:         if (lex->currCh==delim) {",
          "439:           lex->tk =  delim=='`' ? LEX_TEMPLATE_LITERAL : LEX_STR;",
          "440:         } else",
          "441:           lex->tk =  delim=='`' ? LEX_UNFINISHED_TEMPLATE_LITERAL : LEX_UNFINISHED_STR;",
          "442:         jslGetNextCh();",
          "443:       } break;",
          "",
          "[Added Lines]",
          "490:       case JSLJT_STRING: jslLexString(); break;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "492:         lex->tk = LEX_MULEQUAL;",
          "493:         jslGetNextCh();",
          "494:       } break;",
          "499:       } break;",
          "500:       case JSLJT_PERCENT: jslSingleChar();",
          "501:       if (lex->currCh=='=') {",
          "",
          "[Removed Lines]",
          "495:       case JSLJT_FORWARDSLASH: jslSingleChar();",
          "496:       if (lex->currCh=='=') {",
          "497:         lex->tk = LEX_DIVEQUAL;",
          "498:         jslGetNextCh();",
          "",
          "[Added Lines]",
          "542:       case JSLJT_FORWARDSLASH:",
          "544:       if (lastToken==LEX_EOF ||",
          "545:           lastToken=='!' ||",
          "546:           lastToken=='%' ||",
          "547:           lastToken=='&' ||",
          "548:           lastToken=='*' ||",
          "549:           lastToken=='+' ||",
          "550:           lastToken=='-' ||",
          "551:           lastToken=='/' ||",
          "552:           lastToken=='<' ||",
          "553:           lastToken=='=' ||",
          "554:           lastToken=='>' ||",
          "555:           lastToken=='?' ||",
          "556:           (lastToken>=_LEX_OPERATOR_START && lastToken<=_LEX_OPERATOR_END) ||",
          "557:           (lastToken>=_LEX_R_LIST_START && lastToken<=_LEX_R_LIST_END) || // keywords",
          "558:           lastToken==LEX_R_CASE ||",
          "559:           lastToken==LEX_R_NEW ||",
          "560:           lastToken=='[' ||",
          "561:           lastToken=='{' ||",
          "562:           lastToken=='}' ||",
          "563:           lastToken=='(' ||",
          "564:           lastToken==',' ||",
          "565:           lastToken==';' ||",
          "566:           lastToken==':' ||",
          "567:           lastToken==LEX_ARROW_FUNCTION) {",
          "570:         jslLexRegex();",
          "571:       } else {",
          "572:         jslSingleChar();",
          "573:         if (lex->currCh=='=') {",
          "574:           lex->tk = LEX_DIVEQUAL;",
          "575:           jslGetNextCh();",
          "576:         }",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "631:   case LEX_INT : strncpy(str, \"INT\", len); return;",
          "632:   case LEX_FLOAT : strncpy(str, \"FLOAT\", len); return;",
          "633:   case LEX_STR : strncpy(str, \"STRING\", len); return;",
          "635:   case LEX_UNFINISHED_STR : strncpy(str, \"UNFINISHED STRING\", len); return;",
          "636:   case LEX_UNFINISHED_TEMPLATE_LITERAL : strncpy(str, \"UNFINISHED TEMPLATE LITERAL\", len); return;",
          "637:   case LEX_UNFINISHED_COMMENT : strncpy(str, \"UNFINISHED COMMENT\", len); return;",
          "638:   }",
          "640:     const char tokenNames[] =",
          "",
          "[Removed Lines]",
          "634:   case LEX_TEMPLATE_LITERAL : strncpy(str, \"TEMPLATE LITERAL\", len); return;",
          "639:   if (token>=LEX_EQUAL && token<LEX_R_LIST_END) {",
          "",
          "[Added Lines]",
          "713:   case LEX_TEMPLATE_LITERAL : strncpy(str, \"TEMPLATE LITERAL\", len); return;",
          "715:   case LEX_REGEX : strncpy(str, \"REGEX\", len); return;",
          "716:   case LEX_UNFINISHED_REGEX : strncpy(str, \"UNFINISHED REGEX\", len); return;",
          "719:   if (token>=_LEX_OPERATOR_START && token<_LEX_R_LIST_END) {",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "699:         ;",
          "700:     unsigned int p = 0;",
          "702:     while (n>0 && p<sizeof(tokenNames)) {",
          "703:       while (tokenNames[p] && p<sizeof(tokenNames)) p++;",
          "704:       p++; // skip the zero",
          "",
          "[Removed Lines]",
          "701:     int n = token-LEX_EQUAL;",
          "",
          "[Added Lines]",
          "781:     int n = token-_LEX_OPERATOR_START;",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "750: bool jslIsIDOrReservedWord() {",
          "751:   return lex->tk == LEX_ID ||",
          "753: }",
          "",
          "[Removed Lines]",
          "752:          lex->tk >= LEX_R_LIST_START;",
          "",
          "[Added Lines]",
          "832:          (lex->tk >= _LEX_R_LIST_START && lex->tk <= _LEX_R_LIST_END);",
          "",
          "---------------"
        ],
        "src/jslex.h||src/jslex.h": [
          "File: src/jslex.h -> src/jslex.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "24:     LEX_INT,",
          "25:     LEX_FLOAT,",
          "26:     LEX_STR,",
          "27:     LEX_TEMPLATE_LITERAL,",
          "30:     LEX_UNFINISHED_COMMENT,",
          "33:     LEX_TYPEEQUAL,",
          "34:     LEX_NEQUAL,",
          "35:     LEX_NTYPEEQUAL,",
          "",
          "[Removed Lines]",
          "28:     LEX_UNFINISHED_STR,",
          "29:     LEX_UNFINISHED_TEMPLATE_LITERAL,",
          "32:     LEX_EQUAL,",
          "",
          "[Added Lines]",
          "27:     LEX_UNFINISHED_STR, // always after LEX_STR",
          "29:     LEX_UNFINISHED_TEMPLATE_LITERAL, // always after LEX_TEMPLATE_LITERAL",
          "30:     LEX_REGEX,",
          "31:     LEX_UNFINISHED_REGEX, // always after LEX_REGEX",
          "34: _LEX_OPERATOR_START,",
          "35:     LEX_EQUAL = _LEX_OPERATOR_START,",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "53:     LEX_OREQUAL,",
          "54:     LEX_OROR,",
          "55:     LEX_XOREQUAL,",
          "56:     LEX_ARROW_FUNCTION,",
          "60:     LEX_R_ELSE,",
          "61:     LEX_R_DO,",
          "62:     LEX_R_WHILE,",
          "",
          "[Removed Lines]",
          "58: #define LEX_R_LIST_START LEX_R_IF",
          "59:     LEX_R_IF,",
          "",
          "[Added Lines]",
          "60: _LEX_OPERATOR_END = LEX_XOREQUAL,",
          "64: _LEX_R_LIST_START,",
          "65:     LEX_R_IF = _LEX_R_LIST_START,",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "108:   JslCharPos tokenStart; ///< Position in the data at the beginning of the token we have here",
          "109:   size_t tokenLastStart; ///< Position in the data of the first character of the last token",
          "110:   char token[JSLEX_MAX_TOKEN_LENGTH]; ///< Data contained in the token we have here",
          "112:   unsigned char tokenl; ///< the current length of token",
          "",
          "[Removed Lines]",
          "111:   JsVar *tokenValue; ///< JsVar containing the current token - used only for strings",
          "",
          "[Added Lines]",
          "117:   JsVar *tokenValue; ///< JsVar containing the current token - used only for strings/regex",
          "",
          "---------------"
        ]
      }
    }
  ]
}
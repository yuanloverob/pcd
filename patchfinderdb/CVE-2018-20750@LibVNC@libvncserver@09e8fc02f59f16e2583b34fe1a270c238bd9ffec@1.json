{
  "cve_id": "CVE-2018-20750",
  "cve_desc": "LibVNC through 0.9.12 contains a heap out-of-bounds write vulnerability in libvncserver/rfbserver.c. The fix for CVE-2018-15127 was incomplete.",
  "repo": "LibVNC/libvncserver",
  "patch_hash": "09e8fc02f59f16e2583b34fe1a270c238bd9ffec",
  "patch_info": {
    "commit_hash": "09e8fc02f59f16e2583b34fe1a270c238bd9ffec",
    "repo": "LibVNC/libvncserver",
    "commit_url": "https://github.com/LibVNC/libvncserver/commit/09e8fc02f59f16e2583b34fe1a270c238bd9ffec",
    "files": [
      "libvncserver/rfbserver.c"
    ],
    "message": "Limit lenght to INT_MAX bytes in rfbProcessFileTransferReadBuffer()\n\nThis ammends 15bb719c03cc70f14c36a843dcb16ed69b405707 fix for a heap\nout-of-bound write access in rfbProcessFileTransferReadBuffer() when\nreading a transfered file content in a server. The former fix did not\nwork on platforms with a 32-bit int type (expected by rfbReadExact()).\n\nCVE-2018-15127\n<https://github.com/LibVNC/libvncserver/issues/243>\n<https://github.com/LibVNC/libvncserver/issues/273>",
    "before_after_code_files": [
      "libvncserver/rfbserver.c||libvncserver/rfbserver.c"
    ]
  },
  "patch_diff": {
    "libvncserver/rfbserver.c||libvncserver/rfbserver.c": [
      "File: libvncserver/rfbserver.c -> libvncserver/rfbserver.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "88: #include <errno.h>",
      "90: #include <time.h>",
      "92: #ifdef LIBVNCSERVER_WITH_WEBSOCKETS",
      "93: #include \"rfbssl.h\"",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "92: #include <limits.h>",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "1472:        0XFFFFFFFF, i.e. SIZE_MAX for 32-bit systems. On 64-bit systems, a length of 0XFFFFFFFF",
      "1473:        will safely be allocated since this check will never trigger and malloc() can digest length+1",
      "1474:        without problems as length is a uint32_t.",
      "1477:  rfbErr(\"rfbProcessFileTransferReadBuffer: too big file transfer length requested: %u\", (unsigned int)length);",
      "1478:  rfbCloseClient(cl);",
      "1479:  return NULL;",
      "",
      "[Removed Lines]",
      "1476:     if(length == SIZE_MAX) {",
      "",
      "[Added Lines]",
      "1477:        We also later pass length to rfbReadExact() that expects a signed int type and",
      "1478:        that might wrap on platforms with a 32-bit int type if length is bigger",
      "1479:        than 0X7FFFFFFF.",
      "1481:     if(length == SIZE_MAX || length > INT_MAX) {",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "15bb719c03cc70f14c36a843dcb16ed69b405707",
      "candidate_info": {
        "commit_hash": "15bb719c03cc70f14c36a843dcb16ed69b405707",
        "repo": "LibVNC/libvncserver",
        "commit_url": "https://github.com/LibVNC/libvncserver/commit/15bb719c03cc70f14c36a843dcb16ed69b405707",
        "files": [
          "libvncserver/rfbserver.c"
        ],
        "message": "Error out in rfbProcessFileTransferReadBuffer if length can not be allocated\n\nre #273",
        "before_after_code_files": [
          "libvncserver/rfbserver.c||libvncserver/rfbserver.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "libvncserver/rfbserver.c||libvncserver/rfbserver.c"
          ],
          "candidate": [
            "libvncserver/rfbserver.c||libvncserver/rfbserver.c"
          ]
        }
      },
      "candidate_diff": {
        "libvncserver/rfbserver.c||libvncserver/rfbserver.c": [
          "File: libvncserver/rfbserver.c -> libvncserver/rfbserver.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1461:     int   n=0;",
          "1463:     FILEXFER_ALLOWED_OR_CLOSE_AND_RETURN(\"\", cl, NULL);",
          "1467:     if (length>0) {",
          "1469:         if (buffer!=NULL) {",
          "1470:             if ((n = rfbReadExact(cl, (char *)buffer, length)) <= 0) {",
          "1471:                 if (n != 0)",
          "",
          "[Removed Lines]",
          "1465:     rfbLog(\"rfbProcessFileTransferReadBuffer(%dlen)\\n\", length);",
          "1468:         buffer=malloc((uint64_t)length+1);",
          "",
          "[Added Lines]",
          "1466:        We later alloc length+1, which might wrap around on 32-bit systems if length equals",
          "1467:        0XFFFFFFFF, i.e. SIZE_MAX for 32-bit systems. On 64-bit systems, a length of 0XFFFFFFFF",
          "1468:        will safely be allocated since this check will never trigger and malloc() can digest length+1",
          "1469:        without problems as length is a uint32_t.",
          "1471:     if(length == SIZE_MAX) {",
          "1472:  rfbErr(\"rfbProcessFileTransferReadBuffer: too big file transfer length requested: %u\", (unsigned int)length);",
          "1473:  rfbCloseClient(cl);",
          "1474:  return NULL;",
          "1475:     }",
          "1478:         buffer=malloc((size_t)length+1);",
          "",
          "---------------"
        ]
      }
    }
  ]
}
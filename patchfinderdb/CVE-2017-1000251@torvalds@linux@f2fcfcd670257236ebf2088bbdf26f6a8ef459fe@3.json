{
  "cve_id": "CVE-2017-1000251",
  "cve_desc": "The native Bluetooth stack in the Linux Kernel (BlueZ), starting at the Linux kernel version 2.6.32 and up to and including 4.13.1, are vulnerable to a stack overflow vulnerability in the processing of L2CAP configuration responses resulting in Remote code execution in kernel space.",
  "repo": "torvalds/linux",
  "patch_hash": "f2fcfcd670257236ebf2088bbdf26f6a8ef459fe",
  "patch_info": {
    "commit_hash": "f2fcfcd670257236ebf2088bbdf26f6a8ef459fe",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/f2fcfcd670257236ebf2088bbdf26f6a8ef459fe",
    "files": [
      "include/net/bluetooth/l2cap.h",
      "net/bluetooth/l2cap.c"
    ],
    "message": "Bluetooth: Add configuration support for ERTM and Streaming mode\n\nAdd support to config_req and config_rsp to configure ERTM and Streaming\nmode. If the remote device specifies ERTM or Streaming mode, then the\nsame mode is proposed. Otherwise ERTM or Basic mode is used. And in case\nof a state 2 device, the remote device should propose the same mode. If\nnot, then the channel gets disconnected.\n\nSigned-off-by: Gustavo F. Padovan <gustavo@las.ic.unicamp.br>\nSigned-off-by: Marcel Holtmann <marcel@holtmann.org>",
    "before_after_code_files": [
      "include/net/bluetooth/l2cap.h||include/net/bluetooth/l2cap.h",
      "net/bluetooth/l2cap.c||net/bluetooth/l2cap.c"
    ]
  },
  "patch_diff": {
    "include/net/bluetooth/l2cap.h||include/net/bluetooth/l2cap.h": [
      "File: include/net/bluetooth/l2cap.h -> include/net/bluetooth/l2cap.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "29: #define L2CAP_DEFAULT_MTU  672",
      "30: #define L2CAP_DEFAULT_FLUSH_TO  0xffff",
      "32: #define L2CAP_DEFAULT_MAX_RECEIVE 1",
      "",
      "[Removed Lines]",
      "31: #define L2CAP_DEFAULT_RX_WINDOW  1",
      "",
      "[Added Lines]",
      "30: #define L2CAP_DEFAULT_MIN_MTU  48",
      "32: #define L2CAP_DEFAULT_TX_WINDOW  1",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "272:  __u16  omtu;",
      "273:  __u16  flush_to;",
      "274:  __u8  mode;",
      "275:  __u8  fcs;",
      "276:  __u8  sec_level;",
      "277:  __u8  role_switch;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "276:  __u8  num_conf_req;",
      "277:  __u8  num_conf_rsp;",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "280:  __u8  conf_req[64];",
      "281:  __u8  conf_len;",
      "282:  __u8  conf_state;",
      "285:  __u8  ident;",
      "287:  __le16  sport;",
      "289:  struct l2cap_conn *conn;",
      "",
      "[Removed Lines]",
      "283:  __u8  conf_retry;",
      "",
      "[Added Lines]",
      "290:  __u8  remote_tx_win;",
      "291:  __u8  remote_max_tx;",
      "292:  __u16  retrans_timeout;",
      "293:  __u16  monitor_timeout;",
      "294:  __u16  max_pdu_size;",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "291:  struct sock  *prev_c;",
      "292: };",
      "301: void l2cap_load(void);",
      "",
      "[Removed Lines]",
      "294: #define L2CAP_CONF_REQ_SENT 0x01",
      "295: #define L2CAP_CONF_INPUT_DONE 0x02",
      "296: #define L2CAP_CONF_OUTPUT_DONE 0x04",
      "297: #define L2CAP_CONF_CONNECT_PEND 0x80",
      "299: #define L2CAP_CONF_MAX_RETRIES 2",
      "",
      "[Added Lines]",
      "303: #define L2CAP_CONF_REQ_SENT       0x01",
      "304: #define L2CAP_CONF_INPUT_DONE     0x02",
      "305: #define L2CAP_CONF_OUTPUT_DONE    0x04",
      "306: #define L2CAP_CONF_MTU_DONE       0x08",
      "307: #define L2CAP_CONF_MODE_DONE      0x10",
      "308: #define L2CAP_CONF_CONNECT_PEND   0x20",
      "309: #define L2CAP_CONF_STATE2_DEVICE  0x80",
      "311: #define L2CAP_CONF_MAX_CONF_REQ 2",
      "312: #define L2CAP_CONF_MAX_CONF_RSP 2",
      "",
      "---------------"
    ],
    "net/bluetooth/l2cap.c||net/bluetooth/l2cap.c": [
      "File: net/bluetooth/l2cap.c -> net/bluetooth/l2cap.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "966:  case L2CAP_MODE_BASIC:",
      "967:   break;",
      "968:  case L2CAP_MODE_ERTM:",
      "969:   if (enable_ertm)",
      "970:    break;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "969:  case L2CAP_MODE_STREAMING:",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "1029:  case L2CAP_MODE_BASIC:",
      "1030:   break;",
      "1031:  case L2CAP_MODE_ERTM:",
      "1032:   if (enable_ertm)",
      "1033:    break;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1033:  case L2CAP_MODE_STREAMING:",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "1740: }",
      "1742: static int l2cap_build_conf_req(struct sock *sk, void *data)",
      "1743: {",
      "1744:  struct l2cap_pinfo *pi = l2cap_pi(sk);",
      "1745:  struct l2cap_conf_req *req = data;",
      "1747:  void *ptr = req->data;",
      "1749:  BT_DBG(\"sk %p\", sk);",
      "1751:  switch (pi->mode) {",
      "1752:  case L2CAP_MODE_BASIC:",
      "1753:   if (pi->imtu != L2CAP_DEFAULT_MTU)",
      "",
      "[Removed Lines]",
      "1746:  struct l2cap_conf_rfc rfc = { .mode = L2CAP_MODE_BASIC };",
      "",
      "[Added Lines]",
      "1744: static int l2cap_mode_supported(__u8 mode, __u32 feat_mask)",
      "1745: {",
      "1746:  u32 local_feat_mask = l2cap_feat_mask;",
      "1747:  if (enable_ertm)",
      "1748:   local_feat_mask |= L2CAP_FEAT_ERTM;",
      "1750:  switch (mode) {",
      "1751:  case L2CAP_MODE_ERTM:",
      "1752:   return L2CAP_FEAT_ERTM & feat_mask & local_feat_mask;",
      "1753:  case L2CAP_MODE_STREAMING:",
      "1754:   return L2CAP_FEAT_STREAMING & feat_mask & local_feat_mask;",
      "1755:  default:",
      "1756:   return 0x00;",
      "1757:  }",
      "1758: }",
      "1760: static inline __u8 l2cap_select_mode(__u8 mode, __u16 remote_feat_mask)",
      "1761: {",
      "1762:  switch (mode) {",
      "1763:  case L2CAP_MODE_STREAMING:",
      "1764:  case L2CAP_MODE_ERTM:",
      "1765:   if (l2cap_mode_supported(mode, remote_feat_mask))",
      "1766:    return mode;",
      "1768:  default:",
      "1769:   return L2CAP_MODE_BASIC;",
      "1770:  }",
      "1771: }",
      "1777:  struct l2cap_conf_rfc rfc = { .mode = L2CAP_MODE_ERTM };",
      "1782:  if (pi->num_conf_req || pi->num_conf_rsp)",
      "1783:   goto done;",
      "1785:  switch (pi->mode) {",
      "1786:  case L2CAP_MODE_STREAMING:",
      "1787:  case L2CAP_MODE_ERTM:",
      "1788:   pi->conf_state |= L2CAP_CONF_STATE2_DEVICE;",
      "1789:   if (!l2cap_mode_supported(pi->mode, pi->conn->feat_mask)) {",
      "1790:    struct l2cap_disconn_req req;",
      "1791:    req.dcid = cpu_to_le16(pi->dcid);",
      "1792:    req.scid = cpu_to_le16(pi->scid);",
      "1793:    l2cap_send_cmd(pi->conn, l2cap_get_ident(pi->conn),",
      "1794:      L2CAP_DISCONN_REQ, sizeof(req), &req);",
      "1795:   }",
      "1796:   break;",
      "1797:  default:",
      "1798:   pi->mode = l2cap_select_mode(rfc.mode, pi->conn->feat_mask);",
      "1799:   break;",
      "1800:  }",
      "1802: done:",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "1757:  case L2CAP_MODE_ERTM:",
      "1758:   rfc.mode            = L2CAP_MODE_ERTM;",
      "1760:   rfc.max_transmit    = L2CAP_DEFAULT_MAX_RECEIVE;",
      "1763:   rfc.max_pdu_size    = cpu_to_le16(L2CAP_DEFAULT_MAX_RX_APDU);",
      "1765:   l2cap_add_conf_opt(&ptr, L2CAP_CONF_RFC,",
      "",
      "[Removed Lines]",
      "1759:   rfc.txwin_size      = L2CAP_DEFAULT_RX_WINDOW;",
      "1761:   rfc.retrans_timeout = cpu_to_le16(L2CAP_DEFAULT_RETRANS_TO);",
      "1762:   rfc.monitor_timeout = cpu_to_le16(L2CAP_DEFAULT_MONITOR_TO);",
      "",
      "[Added Lines]",
      "1811:   rfc.txwin_size      = L2CAP_DEFAULT_TX_WINDOW;",
      "1813:   rfc.retrans_timeout = 0;",
      "1814:   rfc.monitor_timeout = 0;",
      "1815:   rfc.max_pdu_size    = cpu_to_le16(L2CAP_DEFAULT_MAX_RX_APDU);",
      "1817:   l2cap_add_conf_opt(&ptr, L2CAP_CONF_RFC,",
      "1818:      sizeof(rfc), (unsigned long) &rfc);",
      "1819:   break;",
      "1821:  case L2CAP_MODE_STREAMING:",
      "1822:   rfc.mode            = L2CAP_MODE_STREAMING;",
      "1823:   rfc.txwin_size      = 0;",
      "1824:   rfc.max_transmit    = 0;",
      "1825:   rfc.retrans_timeout = 0;",
      "1826:   rfc.monitor_timeout = 0;",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "1825:   }",
      "1826:  }",
      "1828:  if (result == L2CAP_CONF_SUCCESS) {",
      "1842:    result = L2CAP_CONF_UNACCEPT;",
      "1844:    memset(&rfc, 0, sizeof(rfc));",
      "1848:      sizeof(rfc), (unsigned long) &rfc);",
      "1852:  rsp->scid   = cpu_to_le16(pi->dcid);",
      "1853:  rsp->result = cpu_to_le16(result);",
      "1854:  rsp->flags  = cpu_to_le16(0x0000);",
      "",
      "[Removed Lines]",
      "1832:   if (rfc.mode == L2CAP_MODE_BASIC) {",
      "1833:    if (mtu < pi->omtu)",
      "1834:     result = L2CAP_CONF_UNACCEPT;",
      "1835:    else {",
      "1836:     pi->omtu = mtu;",
      "1837:     pi->conf_state |= L2CAP_CONF_OUTPUT_DONE;",
      "1838:    }",
      "1840:    l2cap_add_conf_opt(&ptr, L2CAP_CONF_MTU, 2, pi->omtu);",
      "1841:   } else {",
      "1845:    rfc.mode = L2CAP_MODE_BASIC;",
      "1847:    l2cap_add_conf_opt(&ptr, L2CAP_CONF_RFC,",
      "1849:   }",
      "1850:  }",
      "",
      "[Added Lines]",
      "1892:  if (pi->num_conf_rsp || pi->num_conf_req)",
      "1893:   goto done;",
      "1895:  switch (pi->mode) {",
      "1896:  case L2CAP_MODE_STREAMING:",
      "1897:  case L2CAP_MODE_ERTM:",
      "1898:   pi->conf_state |= L2CAP_CONF_STATE2_DEVICE;",
      "1899:   if (!l2cap_mode_supported(pi->mode, pi->conn->feat_mask))",
      "1900:    return -ECONNREFUSED;",
      "1901:   break;",
      "1902:  default:",
      "1903:   pi->mode = l2cap_select_mode(rfc.mode, pi->conn->feat_mask);",
      "1904:   break;",
      "1905:  }",
      "1907: done:",
      "1908:  if (pi->mode != rfc.mode) {",
      "1909:   result = L2CAP_CONF_UNACCEPT;",
      "1910:   rfc.mode = pi->mode;",
      "1912:   if (pi->num_conf_rsp == 1)",
      "1913:    return -ECONNREFUSED;",
      "1915:   l2cap_add_conf_opt(&ptr, L2CAP_CONF_RFC,",
      "1916:      sizeof(rfc), (unsigned long) &rfc);",
      "1917:  }",
      "1924:   if (mtu < L2CAP_DEFAULT_MIN_MTU)",
      "1925:    result = L2CAP_CONF_UNACCEPT;",
      "1926:   else {",
      "1927:    pi->omtu = mtu;",
      "1928:    pi->conf_state |= L2CAP_CONF_MTU_DONE;",
      "1929:   }",
      "1930:   l2cap_add_conf_opt(&ptr, L2CAP_CONF_MTU, 2, pi->omtu);",
      "1932:   switch (rfc.mode) {",
      "1933:   case L2CAP_MODE_BASIC:",
      "1934:    pi->fcs = L2CAP_FCS_NONE;",
      "1935:    pi->conf_state |= L2CAP_CONF_MODE_DONE;",
      "1936:    break;",
      "1938:   case L2CAP_MODE_ERTM:",
      "1939:    pi->remote_tx_win = rfc.txwin_size;",
      "1940:    pi->remote_max_tx = rfc.max_transmit;",
      "1941:    pi->max_pdu_size = rfc.max_pdu_size;",
      "1943:    rfc.retrans_timeout = L2CAP_DEFAULT_RETRANS_TO;",
      "1944:    rfc.monitor_timeout = L2CAP_DEFAULT_MONITOR_TO;",
      "1946:    pi->conf_state |= L2CAP_CONF_MODE_DONE;",
      "1947:    break;",
      "1949:   case L2CAP_MODE_STREAMING:",
      "1950:    pi->remote_tx_win = rfc.txwin_size;",
      "1951:    pi->max_pdu_size = rfc.max_pdu_size;",
      "1953:    pi->conf_state |= L2CAP_CONF_MODE_DONE;",
      "1954:    break;",
      "1956:   default:",
      "1960:    rfc.mode = pi->mode;",
      "1961:   }",
      "1963:   l2cap_add_conf_opt(&ptr, L2CAP_CONF_RFC,",
      "1966:   if (result == L2CAP_CONF_SUCCESS)",
      "1967:    pi->conf_state |= L2CAP_CONF_OUTPUT_DONE;",
      "1968:  }",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "1856:  return ptr - data;",
      "1857: }",
      "1859: static int l2cap_build_conf_rsp(struct sock *sk, void *data, u16 result, u16 flags)",
      "1860: {",
      "1861:  struct l2cap_conf_rsp *rsp = data;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1976: static int l2cap_parse_conf_rsp(struct sock *sk, void *rsp, int len, void *data, u16 *result)",
      "1977: {",
      "1978:  struct l2cap_pinfo *pi = l2cap_pi(sk);",
      "1979:  struct l2cap_conf_req *req = data;",
      "1980:  void *ptr = req->data;",
      "1981:  int type, olen;",
      "1982:  unsigned long val;",
      "1983:  struct l2cap_conf_rfc rfc;",
      "1985:  BT_DBG(\"sk %p, rsp %p, len %d, req %p\", sk, rsp, len, data);",
      "1987:  while (len >= L2CAP_CONF_OPT_SIZE) {",
      "1988:   len -= l2cap_get_conf_opt(&rsp, &type, &olen, &val);",
      "1990:   switch (type) {",
      "1991:   case L2CAP_CONF_MTU:",
      "1992:    if (val < L2CAP_DEFAULT_MIN_MTU) {",
      "1994:     pi->omtu = L2CAP_DEFAULT_MIN_MTU;",
      "1995:    } else",
      "1996:     pi->omtu = val;",
      "1997:    l2cap_add_conf_opt(&ptr, L2CAP_CONF_MTU, 2, pi->omtu);",
      "1998:    break;",
      "2000:   case L2CAP_CONF_FLUSH_TO:",
      "2001:    pi->flush_to = val;",
      "2002:    l2cap_add_conf_opt(&ptr, L2CAP_CONF_FLUSH_TO,",
      "2003:        2, pi->flush_to);",
      "2004:    break;",
      "2006:   case L2CAP_CONF_RFC:",
      "2007:    if (olen == sizeof(rfc))",
      "2008:     memcpy(&rfc, (void *)val, olen);",
      "2010:    if ((pi->conf_state & L2CAP_CONF_STATE2_DEVICE) &&",
      "2011:        rfc.mode != pi->mode)",
      "2012:     return -ECONNREFUSED;",
      "2014:    pi->mode = rfc.mode;",
      "2015:    pi->fcs = 0;",
      "2017:    l2cap_add_conf_opt(&ptr, L2CAP_CONF_RFC,",
      "2018:      sizeof(rfc), (unsigned long) &rfc);",
      "2019:    break;",
      "2020:   }",
      "2021:  }",
      "2023:  if (*result == L2CAP_CONF_SUCCESS) {",
      "2024:   switch (rfc.mode) {",
      "2025:   case L2CAP_MODE_ERTM:",
      "2026:    pi->remote_tx_win   = rfc.txwin_size;",
      "2027:    pi->retrans_timeout = rfc.retrans_timeout;",
      "2028:    pi->monitor_timeout = rfc.monitor_timeout;",
      "2029:    pi->max_pdu_size    = le16_to_cpu(rfc.max_pdu_size);",
      "2030:    break;",
      "2031:   case L2CAP_MODE_STREAMING:",
      "2032:    pi->max_pdu_size    = le16_to_cpu(rfc.max_pdu_size);",
      "2033:    break;",
      "2034:   }",
      "2035:  }",
      "2037:  req->dcid   = cpu_to_le16(pi->dcid);",
      "2038:  req->flags  = cpu_to_le16(0x0000);",
      "2040:  return ptr - data;",
      "2041: }",
      "",
      "---------------",
      "--- Hunk 7 ---",
      "[Context before]",
      "2043:   l2cap_send_cmd(conn, l2cap_get_ident(conn), L2CAP_CONF_REQ,",
      "2044:      l2cap_build_conf_req(sk, req), req);",
      "2045:   break;",
      "2047:  case L2CAP_CR_PEND:",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "2229:   l2cap_pi(sk)->num_conf_req++;",
      "",
      "---------------",
      "--- Hunk 8 ---",
      "[Context before]",
      "2102:  len = l2cap_parse_conf_req(sk, rsp);",
      "2104:   goto unlock;",
      "2106:  l2cap_send_cmd(conn, cmd->ident, L2CAP_CONF_RSP, len, rsp);",
      "2109:  l2cap_pi(sk)->conf_len = 0;",
      "",
      "[Removed Lines]",
      "2103:  if (len < 0)",
      "",
      "[Added Lines]",
      "2288:  if (len < 0) {",
      "2289:   struct l2cap_disconn_req req;",
      "2290:   req.dcid = cpu_to_le16(l2cap_pi(sk)->dcid);",
      "2291:   req.scid = cpu_to_le16(l2cap_pi(sk)->scid);",
      "2292:   l2cap_send_cmd(conn, l2cap_get_ident(conn),",
      "2293:      L2CAP_DISCONN_REQ, sizeof(req), &req);",
      "2295:  }",
      "2298:  l2cap_pi(sk)->num_conf_rsp++;",
      "",
      "---------------",
      "--- Hunk 9 ---",
      "[Context before]",
      "2121:   u8 buf[64];",
      "2122:   l2cap_send_cmd(conn, l2cap_get_ident(conn), L2CAP_CONF_REQ,",
      "2123:      l2cap_build_conf_req(sk, buf), buf);",
      "2124:  }",
      "2126: unlock:",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "2316:   l2cap_pi(sk)->num_conf_req++;",
      "",
      "---------------",
      "--- Hunk 10 ---",
      "[Context before]",
      "2150:   break;",
      "2152:  case L2CAP_CONF_UNACCEPT:",
      "2163:   }",
      "2165:  default:",
      "",
      "[Removed Lines]",
      "2153:   if (++l2cap_pi(sk)->conf_retry < L2CAP_CONF_MAX_RETRIES) {",
      "2154:    char req[128];",
      "2160:    l2cap_send_cmd(conn, l2cap_get_ident(conn), L2CAP_CONF_REQ,",
      "2161:       l2cap_build_conf_req(sk, req), req);",
      "2162:    goto done;",
      "",
      "[Added Lines]",
      "2346:   if (l2cap_pi(sk)->num_conf_rsp <= L2CAP_CONF_MAX_CONF_RSP) {",
      "2347:    int len = cmd->len - sizeof(*rsp);",
      "2348:    char req[64];",
      "2351:    result = L2CAP_CONF_SUCCESS;",
      "2352:    len = l2cap_parse_conf_rsp(sk, rsp->data,",
      "2353:        len, req, &result);",
      "2354:    if (len < 0) {",
      "2355:     struct l2cap_disconn_req req;",
      "2356:     req.dcid = cpu_to_le16(l2cap_pi(sk)->dcid);",
      "2357:     req.scid = cpu_to_le16(l2cap_pi(sk)->scid);",
      "2358:     l2cap_send_cmd(conn, l2cap_get_ident(conn),",
      "2359:      L2CAP_DISCONN_REQ, sizeof(req), &req);",
      "2360:     goto done;",
      "2361:    }",
      "2363:    l2cap_send_cmd(conn, l2cap_get_ident(conn),",
      "2364:       L2CAP_CONF_REQ, len, req);",
      "2365:    l2cap_pi(sk)->num_conf_req++;",
      "2366:    if (result != L2CAP_CONF_SUCCESS)",
      "2367:     goto done;",
      "2368:    break;",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "742e519b0db4a470008118b48f0baea6126e2122",
      "candidate_info": {
        "commit_hash": "742e519b0db4a470008118b48f0baea6126e2122",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/742e519b0db4a470008118b48f0baea6126e2122",
        "files": [
          "net/bluetooth/l2cap.c"
        ],
        "message": "Bluetooth: Disconnect the channel if we don't want the proposed mode\n\nIf the device is a STATE 2 then it should disconnect the channel if the\nremote device propose a mode different from its mandatory mode.\n\nSigned-off-by: Gustavo F. Padovan <padovan@profusion.mobi>\nSigned-off-by: Marcel Holtmann <marcel@holtmann.org>",
        "before_after_code_files": [
          "net/bluetooth/l2cap.c||net/bluetooth/l2cap.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "net/bluetooth/l2cap.c||net/bluetooth/l2cap.c"
          ],
          "candidate": [
            "net/bluetooth/l2cap.c||net/bluetooth/l2cap.c"
          ]
        }
      },
      "candidate_diff": {
        "net/bluetooth/l2cap.c||net/bluetooth/l2cap.c": [
          "File: net/bluetooth/l2cap.c -> net/bluetooth/l2cap.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "2617:    break;",
          "2618:   }",
          "2621:    return -ECONNREFUSED;",
          "2622:   break;",
          "2623:  default:",
          "2624:   pi->mode = l2cap_select_mode(rfc.mode, pi->conn->feat_mask);",
          "",
          "[Removed Lines]",
          "2620:   if (!l2cap_mode_supported(pi->mode, pi->conn->feat_mask))",
          "",
          "[Added Lines]",
          "2620:   if (pi->mode != rfc.mode)",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "14b5aa71ec506f4e38ca6a1dc02ecd668ecfd902",
      "candidate_info": {
        "commit_hash": "14b5aa71ec506f4e38ca6a1dc02ecd668ecfd902",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/14b5aa71ec506f4e38ca6a1dc02ecd668ecfd902",
        "files": [
          "include/net/bluetooth/l2cap.h",
          "net/bluetooth/l2cap.c"
        ],
        "message": "Bluetooth: Add sockopt configuration for txWindow on L2CAP\n\nNow we can set/get Transmission Window size via sockopt.\n\nSigned-off-by: Gustavo F. Padovan <padovan@profusion.mobi>\nReviewed-by: Jo\u00e3o Paulo Rechi Vita <jprvita@profusion.mobi>\nSigned-off-by: Marcel Holtmann <marcel@holtmann.org>",
        "before_after_code_files": [
          "include/net/bluetooth/l2cap.h||include/net/bluetooth/l2cap.h",
          "net/bluetooth/l2cap.c||net/bluetooth/l2cap.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "include/net/bluetooth/l2cap.h||include/net/bluetooth/l2cap.h",
            "net/bluetooth/l2cap.c||net/bluetooth/l2cap.c"
          ],
          "candidate": [
            "include/net/bluetooth/l2cap.h||include/net/bluetooth/l2cap.h",
            "net/bluetooth/l2cap.c||net/bluetooth/l2cap.c"
          ]
        }
      },
      "candidate_diff": {
        "include/net/bluetooth/l2cap.h||include/net/bluetooth/l2cap.h": [
          "File: include/net/bluetooth/l2cap.h -> include/net/bluetooth/l2cap.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "56:  __u16 flush_to;",
          "57:  __u8  mode;",
          "58:  __u8  fcs;",
          "59: };",
          "61: #define L2CAP_CONNINFO 0x02",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "59:  __u16 txwin_size;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "340:  __u8  ident;",
          "342:  __u8  remote_tx_win;",
          "343:  __u8  remote_max_tx;",
          "344:  __u16  retrans_timeout;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "343:  __u8  tx_win;",
          "",
          "---------------"
        ],
        "net/bluetooth/l2cap.c||net/bluetooth/l2cap.c": [
          "File: net/bluetooth/l2cap.c -> net/bluetooth/l2cap.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "782:   pi->omtu = l2cap_pi(parent)->omtu;",
          "783:   pi->mode = l2cap_pi(parent)->mode;",
          "784:   pi->fcs  = l2cap_pi(parent)->fcs;",
          "785:   pi->sec_level = l2cap_pi(parent)->sec_level;",
          "786:   pi->role_switch = l2cap_pi(parent)->role_switch;",
          "787:   pi->force_reliable = l2cap_pi(parent)->force_reliable;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "785:   pi->tx_win = l2cap_pi(parent)->tx_win;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "790:   pi->omtu = 0;",
          "791:   pi->mode = L2CAP_MODE_BASIC;",
          "792:   pi->fcs  = L2CAP_FCS_CRC16;",
          "793:   pi->sec_level = BT_SECURITY_LOW;",
          "794:   pi->role_switch = 0;",
          "795:   pi->force_reliable = 0;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "794:   pi->tx_win = L2CAP_DEFAULT_TX_WINDOW;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1782:   opts.flush_to = l2cap_pi(sk)->flush_to;",
          "1783:   opts.mode     = l2cap_pi(sk)->mode;",
          "1784:   opts.fcs      = l2cap_pi(sk)->fcs;",
          "1786:   len = min_t(unsigned int, sizeof(opts), optlen);",
          "1787:   if (copy_from_user((char *) &opts, optval, len)) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1787:   opts.txwin_size = (__u16)l2cap_pi(sk)->tx_win;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1793:   l2cap_pi(sk)->omtu = opts.omtu;",
          "1794:   l2cap_pi(sk)->mode = opts.mode;",
          "1795:   l2cap_pi(sk)->fcs  = opts.fcs;",
          "1796:   break;",
          "1798:  case L2CAP_LM:",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1799:   l2cap_pi(sk)->tx_win = (__u8)opts.txwin_size;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1907:   opts.flush_to = l2cap_pi(sk)->flush_to;",
          "1908:   opts.mode     = l2cap_pi(sk)->mode;",
          "1909:   opts.fcs      = l2cap_pi(sk)->fcs;",
          "1911:   len = min_t(unsigned int, len, sizeof(opts));",
          "1912:   if (copy_to_user(optval, (char *) &opts, len))",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1914:   opts.txwin_size = (__u16)l2cap_pi(sk)->tx_win;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "2325:  case L2CAP_MODE_ERTM:",
          "2326:   rfc.mode            = L2CAP_MODE_ERTM;",
          "2328:   rfc.max_transmit    = max_transmit;",
          "2329:   rfc.retrans_timeout = 0;",
          "2330:   rfc.monitor_timeout = 0;",
          "",
          "[Removed Lines]",
          "2327:   rfc.txwin_size      = L2CAP_DEFAULT_TX_WINDOW;",
          "",
          "[Added Lines]",
          "2332:   rfc.txwin_size      = pi->tx_win;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "1c7621596d11b9c3e19eb88a818758dee4901c95",
      "candidate_info": {
        "commit_hash": "1c7621596d11b9c3e19eb88a818758dee4901c95",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/1c7621596d11b9c3e19eb88a818758dee4901c95",
        "files": [
          "include/net/bluetooth/l2cap.h",
          "net/bluetooth/l2cap.c"
        ],
        "message": "Bluetooth: Fix configuration of the MPS value\n\nWe were accepting values bigger than we can accept. This was leading\nERTM to drop packets because of wrong FCS checks.\n\nSigned-off-by: Gustavo F. Padovan <padovan@profusion.mobi>\nReviewed-by: Jo\u00e3o Paulo Rechi Vita <jprvita@profusion.mobi>\nSigned-off-by: Marcel Holtmann <marcel@holtmann.org>",
        "before_after_code_files": [
          "include/net/bluetooth/l2cap.h||include/net/bluetooth/l2cap.h",
          "net/bluetooth/l2cap.c||net/bluetooth/l2cap.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "include/net/bluetooth/l2cap.h||include/net/bluetooth/l2cap.h",
            "net/bluetooth/l2cap.c||net/bluetooth/l2cap.c"
          ],
          "candidate": [
            "include/net/bluetooth/l2cap.h||include/net/bluetooth/l2cap.h",
            "net/bluetooth/l2cap.c||net/bluetooth/l2cap.c"
          ]
        }
      },
      "candidate_diff": {
        "include/net/bluetooth/l2cap.h||include/net/bluetooth/l2cap.h": [
          "File: include/net/bluetooth/l2cap.h -> include/net/bluetooth/l2cap.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "343:  __u8  remote_max_tx;",
          "344:  __u16  retrans_timeout;",
          "345:  __u16  monitor_timeout;",
          "348:  __le16  sport;",
          "",
          "[Removed Lines]",
          "346:  __u16  max_pdu_size;",
          "",
          "[Added Lines]",
          "346:  __u16  remote_mps;",
          "347:  __u16  mps;",
          "",
          "---------------"
        ],
        "net/bluetooth/l2cap.c||net/bluetooth/l2cap.c": [
          "File: net/bluetooth/l2cap.c -> net/bluetooth/l2cap.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1607:  __skb_queue_head_init(&sar_queue);",
          "1608:  control = L2CAP_SDU_START;",
          "1610:  if (IS_ERR(skb))",
          "1611:   return PTR_ERR(skb);",
          "1613:  __skb_queue_tail(&sar_queue, skb);",
          "1616:  control = 0;",
          "1618:  while (len > 0) {",
          "1619:   size_t buflen;",
          "1622:    control |= L2CAP_SDU_CONTINUE;",
          "1624:   } else {",
          "1625:    control |= L2CAP_SDU_END;",
          "1626:    buflen = len;",
          "",
          "[Removed Lines]",
          "1609:  skb = l2cap_create_iframe_pdu(sk, msg, pi->max_pdu_size, control, len);",
          "1614:  len -= pi->max_pdu_size;",
          "1615:  size +=pi->max_pdu_size;",
          "1621:   if (len > pi->max_pdu_size) {",
          "1623:    buflen = pi->max_pdu_size;",
          "",
          "[Added Lines]",
          "1609:  skb = l2cap_create_iframe_pdu(sk, msg, pi->remote_mps, control, len);",
          "1614:  len -= pi->remote_mps;",
          "1615:  size += pi->remote_mps;",
          "1621:   if (len > pi->remote_mps) {",
          "1623:    buflen = pi->remote_mps;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1701:  case L2CAP_MODE_ERTM:",
          "1702:  case L2CAP_MODE_STREAMING:",
          "1705:    control = L2CAP_SDU_UNSEGMENTED;",
          "1706:    skb = l2cap_create_iframe_pdu(sk, msg, len, control, 0);",
          "1707:    if (IS_ERR(skb)) {",
          "",
          "[Removed Lines]",
          "1704:   if (len <= pi->max_pdu_size) {",
          "",
          "[Added Lines]",
          "1704:   if (len <= pi->remote_mps) {",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "2330:   rfc.monitor_timeout = 0;",
          "2331:   rfc.max_pdu_size    = cpu_to_le16(L2CAP_DEFAULT_MAX_PDU_SIZE);",
          "2332:   if (L2CAP_DEFAULT_MAX_PDU_SIZE > pi->conn->mtu - 10)",
          "2335:   l2cap_add_conf_opt(&ptr, L2CAP_CONF_RFC,",
          "2336:      sizeof(rfc), (unsigned long) &rfc);",
          "",
          "[Removed Lines]",
          "2333:    rfc.max_pdu_size = pi->conn->mtu - 10;",
          "",
          "[Added Lines]",
          "2333:    rfc.max_pdu_size = cpu_to_le16(pi->conn->mtu - 10);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "2353:   rfc.monitor_timeout = 0;",
          "2354:   rfc.max_pdu_size    = cpu_to_le16(L2CAP_DEFAULT_MAX_PDU_SIZE);",
          "2355:   if (L2CAP_DEFAULT_MAX_PDU_SIZE > pi->conn->mtu - 10)",
          "2358:   l2cap_add_conf_opt(&ptr, L2CAP_CONF_RFC,",
          "2359:      sizeof(rfc), (unsigned long) &rfc);",
          "",
          "[Removed Lines]",
          "2356:    rfc.max_pdu_size = pi->conn->mtu - 10;",
          "",
          "[Added Lines]",
          "2356:    rfc.max_pdu_size = cpu_to_le16(pi->conn->mtu - 10);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "2482:   case L2CAP_MODE_ERTM:",
          "2483:    pi->remote_tx_win = rfc.txwin_size;",
          "2484:    pi->remote_max_tx = rfc.max_transmit;",
          "2487:    rfc.retrans_timeout = L2CAP_DEFAULT_RETRANS_TO;",
          "2488:    rfc.monitor_timeout = L2CAP_DEFAULT_MONITOR_TO;",
          "",
          "[Removed Lines]",
          "2485:    pi->max_pdu_size = rfc.max_pdu_size;",
          "",
          "[Added Lines]",
          "2485:    if (rfc.max_pdu_size > pi->conn->mtu - 10)",
          "2486:     rfc.max_pdu_size = le16_to_cpu(pi->conn->mtu - 10);",
          "2488:    pi->remote_mps = le16_to_cpu(rfc.max_pdu_size);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "2495:    break;",
          "2497:   case L2CAP_MODE_STREAMING:",
          "2500:    pi->conf_state |= L2CAP_CONF_MODE_DONE;",
          "",
          "[Removed Lines]",
          "2498:    pi->max_pdu_size = rfc.max_pdu_size;",
          "",
          "[Added Lines]",
          "2501:    if (rfc.max_pdu_size > pi->conn->mtu - 10)",
          "2502:     rfc.max_pdu_size = le16_to_cpu(pi->conn->mtu - 10);",
          "2504:    pi->remote_mps = le16_to_cpu(rfc.max_pdu_size);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "2574:    pi->remote_tx_win   = rfc.txwin_size;",
          "2575:    pi->retrans_timeout = rfc.retrans_timeout;",
          "2576:    pi->monitor_timeout = rfc.monitor_timeout;",
          "2578:    break;",
          "2579:   case L2CAP_MODE_STREAMING:",
          "2582:   }",
          "2583:  }",
          "",
          "[Removed Lines]",
          "2577:    pi->max_pdu_size    = le16_to_cpu(rfc.max_pdu_size);",
          "2580:    pi->max_pdu_size    = le16_to_cpu(rfc.max_pdu_size);",
          "2581:    break;",
          "",
          "[Added Lines]",
          "2583:    pi->mps    = le16_to_cpu(rfc.max_pdu_size);",
          "2586:    pi->mps    = le16_to_cpu(rfc.max_pdu_size);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "3757:    goto drop;",
          "3759:   if (l2cap_check_fcs(pi, skb))",
          "",
          "[Removed Lines]",
          "3756:   if (len > L2CAP_DEFAULT_MAX_PDU_SIZE)",
          "",
          "[Added Lines]",
          "3761:   if (len > pi->mps)",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "3784:   if (pi->fcs == L2CAP_FCS_CRC16)",
          "3785:    len -= 2;",
          "3789:    goto drop;",
          "3791:   if (l2cap_check_fcs(pi, skb))",
          "",
          "[Removed Lines]",
          "3787:   if (len > L2CAP_DEFAULT_MAX_PDU_SIZE || len < 4",
          "3788:     || __is_sframe(control))",
          "",
          "[Added Lines]",
          "3792:   if (len > pi->mps || len < 4 || __is_sframe(control))",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "c74e560cd0101455f1889515e1527e4c2e266113",
      "candidate_info": {
        "commit_hash": "c74e560cd0101455f1889515e1527e4c2e266113",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/c74e560cd0101455f1889515e1527e4c2e266113",
        "files": [
          "include/net/bluetooth/l2cap.h",
          "net/bluetooth/l2cap.c"
        ],
        "message": "Bluetooth: Add support for Segmentation and Reassembly of SDUs\n\nERTM should use Segmentation and Reassembly to break down a SDU in many\nPDUs on sending data to the other side.\n\nOn sending packets we queue all 'segments' until end of segmentation and\njust the add them to the queue for sending. On receiving we create a new\nSKB with the SDU reassembled.\n\nInitially based on a patch from Nathan Holstein <nathan@lampreynetworks.com>\n\nSigned-off-by: Gustavo F. Padovan <gustavo@las.ic.unicamp.br>\nSigned-off-by: Marcel Holtmann <marcel@holtmann.org>",
        "before_after_code_files": [
          "include/net/bluetooth/l2cap.h||include/net/bluetooth/l2cap.h",
          "net/bluetooth/l2cap.c||net/bluetooth/l2cap.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "include/net/bluetooth/l2cap.h||include/net/bluetooth/l2cap.h",
            "net/bluetooth/l2cap.c||net/bluetooth/l2cap.c"
          ],
          "candidate": [
            "include/net/bluetooth/l2cap.h||include/net/bluetooth/l2cap.h",
            "net/bluetooth/l2cap.c||net/bluetooth/l2cap.c"
          ]
        }
      },
      "candidate_diff": {
        "include/net/bluetooth/l2cap.h||include/net/bluetooth/l2cap.h": [
          "File: include/net/bluetooth/l2cap.h -> include/net/bluetooth/l2cap.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "34: #define L2CAP_DEFAULT_MAX_RECEIVE 1",
          "",
          "[Removed Lines]",
          "37: #define L2CAP_DEFAULT_MAX_RX_APDU 0xfff7",
          "",
          "[Added Lines]",
          "37: #define L2CAP_DEFAULT_MAX_PDU_SIZE 672",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "311:  __u8  conf_req[64];",
          "312:  __u8  conf_len;",
          "313:  __u8  conf_state;",
          "315:  __u8  next_tx_seq;",
          "316:  __u8  expected_ack_seq;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "314:  __u8  conn_state;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "318:  __u8  expected_tx_seq;",
          "319:  __u8  unacked_frames;",
          "320:  __u8  num_to_ack;",
          "322:  __u8  ident;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "322:  __u16  sdu_len;",
          "323:  __u16  partial_sdu_len;",
          "324:  struct sk_buff *sdu;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "346: #define L2CAP_CONF_MAX_CONF_REQ 2",
          "347: #define L2CAP_CONF_MAX_CONF_RSP 2",
          "349: static inline int l2cap_tx_window_full(struct sock *sk)",
          "350: {",
          "351:  struct l2cap_pinfo *pi = l2cap_pi(sk);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "353: #define L2CAP_CONN_SAR_SDU         0x01",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "363: #define __get_reqseq(ctrl) ((ctrl) & L2CAP_CTRL_REQSEQ) >> 8",
          "364: #define __is_iframe(ctrl) !((ctrl) & L2CAP_CTRL_FRAME_TYPE)",
          "365: #define __is_sframe(ctrl) (ctrl) & L2CAP_CTRL_FRAME_TYPE",
          "367: void l2cap_load(void);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "372: #define __is_sar_start(ctrl) ((ctrl) & L2CAP_CTRL_SAR) == L2CAP_SDU_START",
          "",
          "---------------"
        ],
        "net/bluetooth/l2cap.c||net/bluetooth/l2cap.c": [
          "File: net/bluetooth/l2cap.c -> net/bluetooth/l2cap.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1334:  return skb;",
          "1335: }",
          "1338: {",
          "1339:  struct l2cap_conn *conn = l2cap_pi(sk)->conn;",
          "1340:  struct sk_buff *skb;",
          "",
          "[Removed Lines]",
          "1337: static struct sk_buff *l2cap_create_ertm_pdu(struct sock *sk, struct msghdr *msg, size_t len, u16 control)",
          "",
          "[Added Lines]",
          "1337: static struct sk_buff *l2cap_create_ertm_pdu(struct sock *sk, struct msghdr *msg, size_t len, u16 control, u16 sdulen)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1344:  BT_DBG(\"sk %p len %d\", sk, (int)len);",
          "1346:  count = min_t(unsigned int, (conn->mtu - hlen), len);",
          "1347:  skb = bt_skb_send_alloc(sk, count + hlen,",
          "1348:    msg->msg_flags & MSG_DONTWAIT, &err);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1346:  if (sdulen)",
          "1347:   hlen += 2;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1354:  lh->cid = cpu_to_le16(l2cap_pi(sk)->dcid);",
          "1355:  lh->len = cpu_to_le16(len + (hlen - L2CAP_HDR_SIZE));",
          "1356:  put_unaligned_le16(control, skb_put(skb, 2));",
          "1358:  err = l2cap_skbuff_fromiovec(sk, msg, len, count, skb);",
          "1359:  if (unlikely(err < 0)) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1360:  if (sdulen)",
          "1361:   put_unaligned_le16(sdulen, skb_put(skb, 2));",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1363:  return skb;",
          "1364: }",
          "1366: static int l2cap_sock_sendmsg(struct kiocb *iocb, struct socket *sock, struct msghdr *msg, size_t len)",
          "1367: {",
          "1368:  struct sock *sk = sock->sk;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1371: static inline int l2cap_sar_segment_sdu(struct sock *sk, struct msghdr *msg, size_t len)",
          "1372: {",
          "1373:  struct l2cap_pinfo *pi = l2cap_pi(sk);",
          "1374:  struct sk_buff *skb;",
          "1375:  struct sk_buff_head sar_queue;",
          "1376:  u16 control;",
          "1377:  size_t size = 0;",
          "1379:  __skb_queue_head_init(&sar_queue);",
          "1380:  control = L2CAP_SDU_START;",
          "1381:  skb = l2cap_create_ertm_pdu(sk, msg, pi->max_pdu_size, control, len);",
          "1382:  if (IS_ERR(skb))",
          "1383:   return PTR_ERR(skb);",
          "1385:  __skb_queue_tail(&sar_queue, skb);",
          "1386:  len -= pi->max_pdu_size;",
          "1387:  size +=pi->max_pdu_size;",
          "1388:  control = 0;",
          "1390:  while (len > 0) {",
          "1391:   size_t buflen;",
          "1393:   if (len > pi->max_pdu_size) {",
          "1394:    control |= L2CAP_SDU_CONTINUE;",
          "1395:    buflen = pi->max_pdu_size;",
          "1396:   } else {",
          "1397:    control |= L2CAP_SDU_END;",
          "1398:    buflen = len;",
          "1399:   }",
          "1401:   skb = l2cap_create_ertm_pdu(sk, msg, buflen, control, 0);",
          "1402:   if (IS_ERR(skb)) {",
          "1403:    skb_queue_purge(&sar_queue);",
          "1404:    return PTR_ERR(skb);",
          "1405:   }",
          "1407:   __skb_queue_tail(&sar_queue, skb);",
          "1408:   len -= buflen;",
          "1409:   size += buflen;",
          "1410:   control = 0;",
          "1411:  }",
          "1412:  skb_queue_splice_tail(&sar_queue, TX_QUEUE(sk));",
          "1413:  if (sk->sk_send_head == NULL)",
          "1414:   sk->sk_send_head = sar_queue.next;",
          "1416:  return size;",
          "1417: }",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1416:  case L2CAP_MODE_ERTM:",
          "1419:    control = L2CAP_SDU_UNSEGMENTED;",
          "1421:    if (IS_ERR(skb)) {",
          "1422:     err = PTR_ERR(skb);",
          "1423:     goto done;",
          "1424:    }",
          "1425:   } else {",
          "1429:   }",
          "1434:   err = l2cap_ertm_send(sk);",
          "1435:   if (!err)",
          "",
          "[Removed Lines]",
          "1418:   if (len <= pi->omtu) {",
          "1420:    skb = l2cap_create_ertm_pdu(sk, msg, len, control);",
          "1427:    err = -EINVAL;",
          "1428:    goto done;",
          "1430:   __skb_queue_tail(TX_QUEUE(sk), skb);",
          "1431:   if (sk->sk_send_head == NULL)",
          "1432:    sk->sk_send_head = skb;",
          "",
          "[Added Lines]",
          "1471:   if (len <= pi->max_pdu_size) {",
          "1473:    skb = l2cap_create_ertm_pdu(sk, msg, len, control, 0);",
          "1478:    __skb_queue_tail(TX_QUEUE(sk), skb);",
          "1479:    if (sk->sk_send_head == NULL)",
          "1480:     sk->sk_send_head = skb;",
          "1483:    err = l2cap_sar_segment_sdu(sk, msg, len);",
          "1484:    if (err < 0)",
          "1485:     goto done;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "2007:   rfc.max_transmit    = L2CAP_DEFAULT_MAX_RECEIVE;",
          "2008:   rfc.retrans_timeout = 0;",
          "2009:   rfc.monitor_timeout = 0;",
          "2012:   l2cap_add_conf_opt(&ptr, L2CAP_CONF_RFC,",
          "2013:      sizeof(rfc), (unsigned long) &rfc);",
          "",
          "[Removed Lines]",
          "2010:   rfc.max_pdu_size    = cpu_to_le16(L2CAP_DEFAULT_MAX_RX_APDU);",
          "",
          "[Added Lines]",
          "2064:   rfc.max_pdu_size    = cpu_to_le16(L2CAP_DEFAULT_MAX_PDU_SIZE);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "2019:   rfc.max_transmit    = 0;",
          "2020:   rfc.retrans_timeout = 0;",
          "2021:   rfc.monitor_timeout = 0;",
          "2024:   l2cap_add_conf_opt(&ptr, L2CAP_CONF_RFC,",
          "2025:      sizeof(rfc), (unsigned long) &rfc);",
          "",
          "[Removed Lines]",
          "2022:   rfc.max_pdu_size    = cpu_to_le16(L2CAP_DEFAULT_MAX_RX_APDU);",
          "",
          "[Added Lines]",
          "2076:   rfc.max_pdu_size    = cpu_to_le16(L2CAP_DEFAULT_MAX_PDU_SIZE);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "2808:  kfree_skb(skb);",
          "2809: }",
          "2811: static inline int l2cap_data_channel_iframe(struct sock *sk, u16 rx_control, struct sk_buff *skb)",
          "2812: {",
          "2813:  struct l2cap_pinfo *pi = l2cap_pi(sk);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2865: static int l2cap_sar_reassembly_sdu(struct sock *sk, struct sk_buff *skb, u16 control)",
          "2866: {",
          "2867:  struct l2cap_pinfo *pi = l2cap_pi(sk);",
          "2868:  struct sk_buff *_skb;",
          "2869:  int err = -EINVAL;",
          "2871:  switch (control & L2CAP_CTRL_SAR) {",
          "2872:  case L2CAP_SDU_UNSEGMENTED:",
          "2873:   if (pi->conn_state & L2CAP_CONN_SAR_SDU) {",
          "2874:    kfree_skb(pi->sdu);",
          "2875:    break;",
          "2876:   }",
          "2878:   err = sock_queue_rcv_skb(sk, skb);",
          "2879:   if (!err)",
          "2880:    return 0;",
          "2882:   break;",
          "2884:  case L2CAP_SDU_START:",
          "2885:   if (pi->conn_state & L2CAP_CONN_SAR_SDU) {",
          "2886:    kfree_skb(pi->sdu);",
          "2887:    break;",
          "2888:   }",
          "2890:   pi->sdu_len = get_unaligned_le16(skb->data);",
          "2891:   skb_pull(skb, 2);",
          "2893:   pi->sdu = bt_skb_alloc(pi->sdu_len, GFP_ATOMIC);",
          "2894:   if (!pi->sdu) {",
          "2895:    err = -ENOMEM;",
          "2896:    break;",
          "2897:   }",
          "2899:   memcpy(skb_put(pi->sdu, skb->len), skb->data, skb->len);",
          "2901:   pi->conn_state |= L2CAP_CONN_SAR_SDU;",
          "2902:   pi->partial_sdu_len = skb->len;",
          "2903:   err = 0;",
          "2904:   break;",
          "2906:  case L2CAP_SDU_CONTINUE:",
          "2907:   if (!(pi->conn_state & L2CAP_CONN_SAR_SDU))",
          "2908:    break;",
          "2910:   memcpy(skb_put(pi->sdu, skb->len), skb->data, skb->len);",
          "2912:   pi->partial_sdu_len += skb->len;",
          "2913:   if (pi->partial_sdu_len > pi->sdu_len)",
          "2914:    kfree_skb(pi->sdu);",
          "2915:   else",
          "2916:    err = 0;",
          "2918:   break;",
          "2920:  case L2CAP_SDU_END:",
          "2921:   if (!(pi->conn_state & L2CAP_CONN_SAR_SDU))",
          "2922:    break;",
          "2924:   memcpy(skb_put(pi->sdu, skb->len), skb->data, skb->len);",
          "2926:   pi->conn_state &= ~L2CAP_CONN_SAR_SDU;",
          "2927:   pi->partial_sdu_len += skb->len;",
          "2929:   if (pi->partial_sdu_len == pi->sdu_len) {",
          "2930:    _skb = skb_clone(pi->sdu, GFP_ATOMIC);",
          "2931:    err = sock_queue_rcv_skb(sk, _skb);",
          "2932:    if (err < 0)",
          "2933:     kfree_skb(_skb);",
          "2934:   }",
          "2935:   kfree_skb(pi->sdu);",
          "2936:   err = 0;",
          "2938:   break;",
          "2939:  }",
          "2941:  kfree_skb(skb);",
          "2942:  return err;",
          "2943: }",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "2820:  if (tx_seq != pi->expected_tx_seq)",
          "2821:   return -EINVAL;",
          "2826:   return err;",
          "2828:  pi->num_to_ack = (pi->num_to_ack + 1) % L2CAP_DEFAULT_NUM_TO_ACK;",
          "2829:  if (pi->num_to_ack == L2CAP_DEFAULT_NUM_TO_ACK - 1) {",
          "2830:   tx_control |= L2CAP_CTRL_FRAME_TYPE;",
          "",
          "[Removed Lines]",
          "2823:  pi->expected_tx_seq = (pi->expected_tx_seq + 1) % 64;",
          "2824:  err = sock_queue_rcv_skb(sk, skb);",
          "2825:  if (err)",
          "",
          "[Added Lines]",
          "2957:  err = l2cap_sar_reassembly_sdu(sk, skb, rx_control);",
          "2958:  if (err < 0)",
          "2961:  pi->expected_tx_seq = (pi->expected_tx_seq + 1) % 64;",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "2860: static inline int l2cap_data_channel(struct l2cap_conn *conn, u16 cid, struct sk_buff *skb)",
          "2861: {",
          "2862:  struct sock *sk;",
          "2864:  int err;",
          "2866:  sk = l2cap_get_chan_by_scid(&conn->chan_list, cid);",
          "",
          "[Removed Lines]",
          "2863:  u16 control;",
          "",
          "[Added Lines]",
          "2997:  u16 control, len;",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "2891:  case L2CAP_MODE_ERTM:",
          "2892:   control = get_unaligned_le16(skb->data);",
          "2893:   skb_pull(skb, 2);",
          "2896:    goto drop;",
          "2898:   if (__is_iframe(control))",
          "",
          "[Removed Lines]",
          "2895:   if (l2cap_pi(sk)->imtu < skb->len)",
          "",
          "[Added Lines]",
          "3028:   len = skb->len;",
          "3030:   if (__is_sar_start(control))",
          "3031:    len -= 2;",
          "3033:   if (len > L2CAP_DEFAULT_MAX_PDU_SIZE)",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2016-5418",
  "cve_desc": "The sandboxing code in libarchive 3.2.0 and earlier mishandles hardlink archive entries of non-zero data size, which might allow remote attackers to write to arbitrary files via a crafted archive file.",
  "repo": "libarchive/libarchive",
  "patch_hash": "dfd6b54ce33960e420fb206d8872fb759b577ad9",
  "patch_info": {
    "commit_hash": "dfd6b54ce33960e420fb206d8872fb759b577ad9",
    "repo": "libarchive/libarchive",
    "commit_url": "https://github.com/libarchive/libarchive/commit/dfd6b54ce33960e420fb206d8872fb759b577ad9",
    "files": [
      "libarchive/archive_write_disk_posix.c"
    ],
    "message": "Fixes for Issue #745 and Issue #746 from Doran Moppert.",
    "before_after_code_files": [
      "libarchive/archive_write_disk_posix.c||libarchive/archive_write_disk_posix.c"
    ]
  },
  "patch_diff": {
    "libarchive/archive_write_disk_posix.c||libarchive/archive_write_disk_posix.c": [
      "File: libarchive/archive_write_disk_posix.c -> libarchive/archive_write_disk_posix.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "327: #define HFS_BLOCKS(s) ((s) >> 12)",
      "329: static int check_symlinks(struct archive_write_disk *);",
      "330: static int create_filesystem_object(struct archive_write_disk *);",
      "331: static struct fixup_entry *current_fixup(struct archive_write_disk *, const char *pathname);",
      "332: #if defined(HAVE_FCHDIR) && defined(PATH_MAX)",
      "333: static void edit_deep_directories(struct archive_write_disk *ad);",
      "334: #endif",
      "335: static int cleanup_pathname(struct archive_write_disk *);",
      "336: static int create_dir(struct archive_write_disk *, char *);",
      "337: static int create_parent_dir(struct archive_write_disk *, char *);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "329: static int check_symlinks_fsobj(char *path, int *error_number, struct archive_string *error_string, int flags);",
      "336: static int cleanup_pathname_fsobj(char *path, int *error_number, struct archive_string *error_string, int flags);",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "2014:  const char *linkname;",
      "2015:  mode_t final_mode, mode;",
      "2016:  int r;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "2021:  struct archive_string error_string;",
      "2022:  int error_number;",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "2022: #if !HAVE_LINK",
      "2023:   return (EPERM);",
      "2024: #else",
      "2025:   r = link(linkname, a->name) ? errno : 0;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "2031:   archive_string_init(&error_string);",
      "2032:   linkname_copy = strdup(linkname);",
      "2033:   if (linkname_copy == NULL) {",
      "2034:       return (EPERM);",
      "2035:   }",
      "2037:   r = cleanup_pathname_fsobj(linkname_copy, &error_number, &error_string, a->flags);",
      "2038:   if (r != ARCHIVE_OK) {",
      "2039:    archive_set_error(&a->archive, error_number, \"%s\", error_string.s);",
      "2040:    free(linkname_copy);",
      "2042:    return (EPERM);",
      "2043:   }",
      "2044:   r = check_symlinks_fsobj(linkname_copy, &error_number, &error_string, a->flags);",
      "2045:   if (r != ARCHIVE_OK) {",
      "2046:    archive_set_error(&a->archive, error_number, \"%s\", error_string.s);",
      "2047:    free(linkname_copy);",
      "2049:    return (EPERM);",
      "2050:   }",
      "2051:   free(linkname_copy);",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "2365: static int",
      "2367: {",
      "2368: #if !defined(HAVE_LSTAT)",
      "2371:  return (ARCHIVE_OK);",
      "2372: #else",
      "2374:  char c;",
      "2375:  int r;",
      "2376:  struct stat st;",
      "2402:   if (r != 0) {",
      "2404:    if (errno == ENOENT) {",
      "2405:     break;",
      "2406:    } else {",
      "2415:    }",
      "2416:   } else if (S_ISLNK(st.st_mode)) {",
      "2429:     }",
      "2441:     }",
      "2453:     }",
      "2455:    } else {",
      "2461:    }",
      "2462:   }",
      "2466:  }",
      "2471: #endif",
      "2472: }",
      "2474: #if defined(__CYGWIN__)",
      "",
      "[Removed Lines]",
      "2366: check_symlinks(struct archive_write_disk *a)",
      "2373:  char *pn;",
      "2383:  pn = a->name;",
      "2384:  if (archive_strlen(&(a->path_safe)) > 0) {",
      "2385:   char *p = a->path_safe.s;",
      "2386:   while ((*pn != '\\0') && (*p == *pn))",
      "2387:    ++p, ++pn;",
      "2388:  }",
      "2390:  if(pn == a->name && pn[0] == '/')",
      "2391:   ++pn;",
      "2392:  c = pn[0];",
      "2394:  while (pn[0] != '\\0' && (pn[0] != '/' || pn[1] != '\\0')) {",
      "2396:   while (*pn != '\\0' && *pn != '/')",
      "2397:    ++pn;",
      "2398:   c = pn[0];",
      "2399:   pn[0] = '\\0';",
      "2401:   r = lstat(a->name, &st);",
      "2414:     return (ARCHIVE_FAILED);",
      "2417:    if (c == '\\0') {",
      "2423:     if (unlink(a->name)) {",
      "2424:      archive_set_error(&a->archive, errno,",
      "2425:          \"Could not remove symlink %s\",",
      "2426:          a->name);",
      "2427:      pn[0] = c;",
      "2428:      return (ARCHIVE_FAILED);",
      "2430:     a->pst = NULL;",
      "2437:     if (!S_ISLNK(a->mode)) {",
      "2438:      archive_set_error(&a->archive, 0,",
      "2439:          \"Removing symlink %s\",",
      "2440:          a->name);",
      "2443:     pn[0] = c;",
      "2444:     return (0);",
      "2445:    } else if (a->flags & ARCHIVE_EXTRACT_UNLINK) {",
      "2447:     if (unlink(a->name) != 0) {",
      "2448:      archive_set_error(&a->archive, 0,",
      "2449:          \"Cannot remove intervening symlink %s\",",
      "2450:          a->name);",
      "2451:      pn[0] = c;",
      "2452:      return (ARCHIVE_FAILED);",
      "2454:     a->pst = NULL;",
      "2456:     archive_set_error(&a->archive, 0,",
      "2457:         \"Cannot extract through symlink %s\",",
      "2458:         a->name);",
      "2459:     pn[0] = c;",
      "2460:     return (ARCHIVE_FAILED);",
      "2463:   pn[0] = c;",
      "2464:   if (pn[0] != '\\0')",
      "2467:  pn[0] = c;",
      "2469:  archive_strcpy(&a->path_safe, a->name);",
      "2470:  return (ARCHIVE_OK);",
      "",
      "[Added Lines]",
      "2398: check_symlinks_fsobj(char *path, int *error_number, struct archive_string *error_string, int flags)",
      "2409:  int res = ARCHIVE_OK;",
      "2410:  char *tail;",
      "2411:  char *head;",
      "2412:  int last;",
      "2416:  int restore_pwd;",
      "2419:  if(path[0] == '\\0')",
      "2420:      return (ARCHIVE_OK);",
      "2436:  restore_pwd = open(\".\", O_RDONLY | O_BINARY | O_CLOEXEC);",
      "2437:  __archive_ensure_cloexec_flag(restore_pwd);",
      "2438:  if (restore_pwd < 0)",
      "2439:   return (ARCHIVE_FATAL);",
      "2440:  head = path;",
      "2441:  tail = path;",
      "2442:  last = 0;",
      "2445:  if(tail == path && tail[0] == '/')",
      "2446:   ++tail;",
      "2453:  while (!last) {",
      "2455:   while (*tail == '/')",
      "2456:       ++tail;",
      "2458:   while (*tail != '\\0' && *tail != '/')",
      "2459:    ++tail;",
      "2461:   last = (tail[0] == '\\0') || (tail[0] == '/' && tail[1] == '\\0');",
      "2463:   c = tail[0];",
      "2464:   tail[0] = '\\0';",
      "2466:   r = lstat(head, &st);",
      "2468:    tail[0] = c;",
      "2481:     if (error_number) *error_number = errno;",
      "2482:     if (error_string)",
      "2483:      archive_string_sprintf(error_string,",
      "2484:        \"Could not stat %s\",",
      "2485:        path);",
      "2486:     res = ARCHIVE_FAILED;",
      "2487:     break;",
      "2488:    }",
      "2489:   } else if (S_ISDIR(st.st_mode)) {",
      "2490:    if (!last) {",
      "2491:     if (chdir(head) != 0) {",
      "2492:      tail[0] = c;",
      "2493:      if (error_number) *error_number = errno;",
      "2494:      if (error_string)",
      "2495:       archive_string_sprintf(error_string,",
      "2496:         \"Could not chdir %s\",",
      "2497:         path);",
      "2498:      res = (ARCHIVE_FATAL);",
      "2499:      break;",
      "2500:     }",
      "2502:     head = tail + 1;",
      "2505:    if (last) {",
      "2511:     if (unlink(head)) {",
      "2512:      tail[0] = c;",
      "2513:      if (error_number) *error_number = errno;",
      "2514:      if (error_string)",
      "2515:       archive_string_sprintf(error_string,",
      "2516:         \"Could not remove symlink %s\",",
      "2517:         path);",
      "2518:      res = ARCHIVE_FAILED;",
      "2519:      break;",
      "2527:     tail[0] = c;",
      "2529:     if (!S_ISLNK(path)) {",
      "2530:      if (error_number) *error_number = 0;",
      "2531:      if (error_string)",
      "2532:       archive_string_sprintf(error_string,",
      "2533:         \"Removing symlink %s\",",
      "2534:         path);",
      "2538:     res = ARCHIVE_OK;",
      "2539:     break;",
      "2540:    } else if (flags & ARCHIVE_EXTRACT_UNLINK) {",
      "2542:     if (unlink(head) != 0) {",
      "2543:      tail[0] = c;",
      "2544:      if (error_number) *error_number = 0;",
      "2545:      if (error_string)",
      "2546:       archive_string_sprintf(error_string,",
      "2547:         \"Cannot remove intervening symlink %s\",",
      "2548:         path);",
      "2549:      res = ARCHIVE_FAILED;",
      "2550:      break;",
      "2552:     tail[0] = c;",
      "2554:     tail[0] = c;",
      "2555:     if (error_number) *error_number = 0;",
      "2556:     if (error_string)",
      "2557:      archive_string_sprintf(error_string,",
      "2558:        \"Cannot extract through symlink %s\",",
      "2559:        path);",
      "2560:     res = ARCHIVE_FAILED;",
      "2561:     break;",
      "2565:   tail[0] = c;",
      "2566:   if (tail[0] != '\\0')",
      "2568:  }",
      "2570:  tail[0] = c;",
      "2571: #ifdef HAVE_FCHDIR",
      "2573:  if (restore_pwd >= 0) {",
      "2574:   r = fchdir(restore_pwd);",
      "2575:   if (r != 0) {",
      "2576:    if(error_number) *error_number = errno;",
      "2577:    if(error_string)",
      "2578:     archive_string_sprintf(error_string,",
      "2579:       \"chdir() failure\");",
      "2580:   }",
      "2581:   close(restore_pwd);",
      "2582:   restore_pwd = -1;",
      "2583:   if (r != 0) {",
      "2584:    res = (ARCHIVE_FATAL);",
      "2585:   }",
      "2587: #endif",
      "2589:  return res;",
      "2597: static int",
      "2598: check_symlinks(struct archive_write_disk *a)",
      "2599: {",
      "2600:  struct archive_string error_string;",
      "2601:  int error_number;",
      "2602:  int rc;",
      "2603:  archive_string_init(&error_string);",
      "2604:  rc = check_symlinks_fsobj(a->name, &error_number, &error_string, a->flags);",
      "2605:  if (rc != ARCHIVE_OK) {",
      "2606:   archive_set_error(&a->archive, error_number, \"%s\", error_string.s);",
      "2607:  }",
      "2608:  archive_string_free(&error_string);",
      "2610:  return rc;",
      "2611: }",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "2546: static int",
      "2548: {",
      "2549:  char *dest, *src;",
      "2550:  char separator = '\\0';",
      "2553:  if (*src == '\\0') {",
      "2556:   return (ARCHIVE_FAILED);",
      "2557:  }",
      "",
      "[Removed Lines]",
      "2547: cleanup_pathname(struct archive_write_disk *a)",
      "2552:  dest = src = a->name;",
      "2554:   archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,",
      "2555:       \"Invalid empty pathname\");",
      "",
      "[Added Lines]",
      "2687: cleanup_pathname_fsobj(char *path, int *error_number, struct archive_string *error_string, int flags)",
      "2692:  dest = src = path;",
      "2694:   if (error_number) *error_number = ARCHIVE_ERRNO_MISC;",
      "2695:   if (error_string)",
      "2696:       archive_string_sprintf(error_string,",
      "2697:        \"Invalid empty pathname\");",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "2561: #endif",
      "2563:  if (*src == '/') {",
      "2567:    return (ARCHIVE_FAILED);",
      "2568:   }",
      "",
      "[Removed Lines]",
      "2564:   if (a->flags & ARCHIVE_EXTRACT_SECURE_NOABSOLUTEPATHS) {",
      "2565:    archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,",
      "2566:                      \"Path is absolute\");",
      "",
      "[Added Lines]",
      "2706:   if (flags & ARCHIVE_EXTRACT_SECURE_NOABSOLUTEPATHS) {",
      "2707:    if (error_number) *error_number = ARCHIVE_ERRNO_MISC;",
      "2708:    if (error_string)",
      "2709:        archive_string_sprintf(error_string,",
      "2710:         \"Path is absolute\");",
      "",
      "---------------",
      "--- Hunk 7 ---",
      "[Context before]",
      "2590:    } else if (src[1] == '.') {",
      "2591:     if (src[2] == '/' || src[2] == '\\0') {",
      "2597:       return (ARCHIVE_FAILED);",
      "2598:      }",
      "2599:     }",
      "",
      "[Removed Lines]",
      "2593:      if (a->flags & ARCHIVE_EXTRACT_SECURE_NODOTDOT) {",
      "2594:       archive_set_error(&a->archive,",
      "2595:           ARCHIVE_ERRNO_MISC,",
      "2596:           \"Path contains '..'\");",
      "",
      "[Added Lines]",
      "2737:      if (flags & ARCHIVE_EXTRACT_SECURE_NODOTDOT) {",
      "2738:       if (error_number) *error_number = ARCHIVE_ERRNO_MISC;",
      "2739:       if (error_string)",
      "2740:           archive_string_sprintf(error_string,",
      "2741:            \"Path contains '..'\");",
      "",
      "---------------",
      "--- Hunk 8 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "2627:  if (dest == a->name) {",
      "",
      "[Added Lines]",
      "2772:  if (dest == path) {",
      "",
      "---------------",
      "--- Hunk 9 ---",
      "[Context before]",
      "2639:  return (ARCHIVE_OK);",
      "2640: }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "2787: static int",
      "2788: cleanup_pathname(struct archive_write_disk *a)",
      "2789: {",
      "2790:  struct archive_string error_string;",
      "2791:  int error_number;",
      "2792:  int rc;",
      "2793:  archive_string_init(&error_string);",
      "2794:  rc = cleanup_pathname_fsobj(a->name, &error_number, &error_string, a->flags);",
      "2795:  if (rc != ARCHIVE_OK) {",
      "2796:   archive_set_error(&a->archive, error_number, \"%s\", error_string.s);",
      "2797:  }",
      "2798:  archive_string_free(&error_string);",
      "2799:  return rc;",
      "2800: }",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "6a7b8adb9c70593159831161659de2d2898045f0",
      "candidate_info": {
        "commit_hash": "6a7b8adb9c70593159831161659de2d2898045f0",
        "repo": "libarchive/libarchive",
        "commit_url": "https://github.com/libarchive/libarchive/commit/6a7b8adb9c70593159831161659de2d2898045f0",
        "files": [
          "libarchive/archive_write_disk_posix.c"
        ],
        "message": "Restore modified path after lstat\n\ncheck_symlinks is intended to check each component of a path, but failed\nto restore the stripped trailing components after each iteration,\nleaving a NUL byte in the middle of the path.",
        "before_after_code_files": [
          "libarchive/archive_write_disk_posix.c||libarchive/archive_write_disk_posix.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "libarchive/archive_write_disk_posix.c||libarchive/archive_write_disk_posix.c"
          ],
          "candidate": [
            "libarchive/archive_write_disk_posix.c||libarchive/archive_write_disk_posix.c"
          ]
        }
      },
      "candidate_diff": {
        "libarchive/archive_write_disk_posix.c||libarchive/archive_write_disk_posix.c": [
          "File: libarchive/archive_write_disk_posix.c -> libarchive/archive_write_disk_posix.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "2447:     return (ARCHIVE_FAILED);",
          "2448:    }",
          "2449:   }",
          "2450:  }",
          "2451:  pn[0] = c;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2450:   pn[0] = c;",
          "2451:   if (pn[0] != '\\0')",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "cc9cbbb1c45a7ef881d7806a6faf9c9c1f581e18",
      "candidate_info": {
        "commit_hash": "cc9cbbb1c45a7ef881d7806a6faf9c9c1f581e18",
        "repo": "libarchive/libarchive",
        "commit_url": "https://github.com/libarchive/libarchive/commit/cc9cbbb1c45a7ef881d7806a6faf9c9c1f581e18",
        "files": [
          "libarchive/archive_write_disk_posix.c"
        ],
        "message": "Style fixes in archive_write_disk_posix.c",
        "before_after_code_files": [
          "libarchive/archive_write_disk_posix.c||libarchive/archive_write_disk_posix.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "libarchive/archive_write_disk_posix.c||libarchive/archive_write_disk_posix.c"
          ],
          "candidate": [
            "libarchive/archive_write_disk_posix.c||libarchive/archive_write_disk_posix.c"
          ]
        }
      },
      "candidate_diff": {
        "libarchive/archive_write_disk_posix.c||libarchive/archive_write_disk_posix.c": [
          "File: libarchive/archive_write_disk_posix.c -> libarchive/archive_write_disk_posix.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "337: #define HFS_BLOCKS(s) ((s) >> 12)",
          "340: static int check_symlinks(struct archive_write_disk *);",
          "341: static int create_filesystem_object(struct archive_write_disk *);",
          "343: #if defined(HAVE_FCHDIR) && defined(PATH_MAX)",
          "344: static void edit_deep_directories(struct archive_write_disk *ad);",
          "345: #endif",
          "347: static int cleanup_pathname(struct archive_write_disk *);",
          "348: static int create_dir(struct archive_write_disk *, char *);",
          "349: static int create_parent_dir(struct archive_write_disk *, char *);",
          "",
          "[Removed Lines]",
          "339: static int check_symlinks_fsobj(char *path, int *error_number, struct archive_string *error_string, int flags);",
          "342: static struct fixup_entry *current_fixup(struct archive_write_disk *, const char *pathname);",
          "346: static int cleanup_pathname_fsobj(char *path, int *error_number, struct archive_string *error_string, int flags);",
          "",
          "[Added Lines]",
          "339: static int check_symlinks_fsobj(char *path, int *error_number,",
          "340:       struct archive_string *error_string, int flags);",
          "343: static struct fixup_entry *current_fixup(struct archive_write_disk *,",
          "344:       const char *pathname);",
          "348: static int cleanup_pathname_fsobj(char *path, int *error_number,",
          "349:       struct archive_string *error_string, int flags);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "375: static int _archive_write_disk_close(struct archive *);",
          "376: static int _archive_write_disk_free(struct archive *);",
          "378: static int64_t _archive_write_disk_filter_bytes(struct archive *, int);",
          "379: static int _archive_write_disk_finish_entry(struct archive *);",
          "383: static int",
          "384: lazy_stat(struct archive_write_disk *a)",
          "",
          "[Removed Lines]",
          "377: static int _archive_write_disk_header(struct archive *, struct archive_entry *);",
          "380: static ssize_t _archive_write_disk_data(struct archive *, const void *, size_t);",
          "381: static ssize_t _archive_write_disk_data_block(struct archive *, const void *, size_t, int64_t);",
          "",
          "[Added Lines]",
          "380: static int _archive_write_disk_header(struct archive *,",
          "381:       struct archive_entry *);",
          "384: static ssize_t _archive_write_disk_data(struct archive *, const void *,",
          "385:       size_t);",
          "386: static ssize_t _archive_write_disk_data_block(struct archive *, const void *,",
          "387:       size_t, int64_t);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "649:  if (a->restore_pwd >= 0) {",
          "650:   r = fchdir(a->restore_pwd);",
          "651:   if (r != 0) {",
          "653:    ret = ARCHIVE_FATAL;",
          "654:   }",
          "655:   close(a->restore_pwd);",
          "",
          "[Removed Lines]",
          "652:    archive_set_error(&a->archive, errno, \"chdir() failure\");",
          "",
          "[Added Lines]",
          "658:    archive_set_error(&a->archive, errno,",
          "659:        \"chdir() failure\");",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "697:   }",
          "698:   if (archive_entry_birthtime_is_set(entry)) {",
          "699:    fe->birthtime = archive_entry_birthtime(entry);",
          "701:   } else {",
          "703:    fe->birthtime = fe->mtime;",
          "",
          "[Removed Lines]",
          "700:    fe->birthtime_nanos = archive_entry_birthtime_nsec(entry);",
          "",
          "[Added Lines]",
          "707:    fe->birthtime_nanos = archive_entry_birthtime_nsec(",
          "708:        entry);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "723:     return (ARCHIVE_FATAL);",
          "724:    fe->mac_metadata = malloc(metadata_size);",
          "725:    if (fe->mac_metadata != NULL) {",
          "727:     fe->mac_metadata_size = metadata_size;",
          "728:     fe->fixup |= TODO_MAC_METADATA;",
          "729:    }",
          "",
          "[Removed Lines]",
          "726:     memcpy(fe->mac_metadata, metadata, metadata_size);",
          "",
          "[Added Lines]",
          "734:     memcpy(fe->mac_metadata, metadata,",
          "735:         metadata_size);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1480:   return (r);",
          "1481:  if ((size_t)r < size) {",
          "1482:   archive_set_error(&a->archive, 0,",
          "1484:   return (ARCHIVE_WARN);",
          "1485:  }",
          "1486: #if ARCHIVE_VERSION_NUMBER < 3999000",
          "",
          "[Removed Lines]",
          "1483:       \"Too much data: Truncating file at %ju bytes\", (uintmax_t)a->filesize);",
          "",
          "[Added Lines]",
          "1492:       \"Too much data: Truncating file at %ju bytes\",",
          "1493:       (uintmax_t)a->filesize);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "2043:   if (linkname_copy == NULL) {",
          "2044:       return (EPERM);",
          "2045:   }",
          "2048:   if (r != ARCHIVE_OK) {",
          "2050:    free(linkname_copy);",
          "2052:    return (EPERM);",
          "2053:   }",
          "2055:   if (r != ARCHIVE_OK) {",
          "2057:    free(linkname_copy);",
          "2059:    return (EPERM);",
          "2060:   }",
          "2061:   free(linkname_copy);",
          "",
          "[Removed Lines]",
          "2047:   r = cleanup_pathname_fsobj(linkname_copy, &error_number, &error_string, a->flags);",
          "2049:    archive_set_error(&a->archive, error_number, \"%s\", error_string.s);",
          "2054:   r = check_symlinks_fsobj(linkname_copy, &error_number, &error_string, a->flags);",
          "2056:    archive_set_error(&a->archive, error_number, \"%s\", error_string.s);",
          "",
          "[Added Lines]",
          "2060:   r = cleanup_pathname_fsobj(linkname_copy, &error_number,",
          "2061:       &error_string, a->flags);",
          "2063:    archive_set_error(&a->archive, error_number, \"%s\",",
          "2064:        error_string.s);",
          "2072:   r = check_symlinks_fsobj(linkname_copy, &error_number,",
          "2073:       &error_string, a->flags);",
          "2075:    archive_set_error(&a->archive, error_number, \"%s\",",
          "2076:        error_string.s);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "2076:    a->todo = 0;",
          "2077:    a->deferred = 0;",
          "2078:   } else if (r == 0 && a->filesize > 0) {",
          "2081:    __archive_ensure_cloexec_flag(a->fd);",
          "2082:    if (a->fd < 0)",
          "2083:     r = errno;",
          "",
          "[Removed Lines]",
          "2079:    a->fd = open(a->name,",
          "2080:          O_WRONLY | O_TRUNC | O_BINARY | O_CLOEXEC | O_NOFOLLOW);",
          "",
          "[Added Lines]",
          "2102:    a->fd = open(a->name, O_WRONLY | O_TRUNC | O_BINARY",
          "2103:        | O_CLOEXEC | O_NOFOLLOW);",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "2402: static int",
          "2404: {",
          "2405: #if !defined(HAVE_LSTAT)",
          "",
          "[Removed Lines]",
          "2403: check_symlinks_fsobj(char *path, int *error_number, struct archive_string *error_string, int flags)",
          "",
          "[Added Lines]",
          "2426: check_symlinks_fsobj(char *path, int *error_number,",
          "2427:     struct archive_string *error_string, int flags)",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "2474:    if (errno == ENOENT) {",
          "2475:     break;",
          "2476:    } else {",
          "2487:      archive_string_sprintf(error_string,",
          "2490:     res = ARCHIVE_FAILED;",
          "2491:     break;",
          "2492:    }",
          "",
          "[Removed Lines]",
          "2485:     if (error_number) *error_number = errno;",
          "2486:     if (error_string)",
          "2488:        \"Could not stat %s\",",
          "2489:        path);",
          "",
          "[Added Lines]",
          "2516:     if (error_number)",
          "2518:     if (error_string) {",
          "2520:          \"Could not stat %s\",",
          "2521:          path);",
          "2522:     }",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "2494:    if (!last) {",
          "2495:     if (chdir(head) != 0) {",
          "2496:      tail[0] = c;",
          "2502:      res = (ARCHIVE_FATAL);",
          "2503:      break;",
          "2504:     }",
          "",
          "[Removed Lines]",
          "2497:      if (error_number) *error_number = errno;",
          "2498:      if (error_string)",
          "2499:       archive_string_sprintf(error_string,",
          "2500:         \"Could not chdir %s\",",
          "2501:         path);",
          "",
          "[Added Lines]",
          "2530:      if (error_number)",
          "2532:      if (error_string) {",
          "2533:       archive_string_sprintf(",
          "2534:           error_string,",
          "2535:           \"Could not chdir %s\",",
          "2536:           path);",
          "2537:      }",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "2515:     if (unlink(head)) {",
          "2516:      tail[0] = c;",
          "2518:      if (error_string)",
          "2522:      res = ARCHIVE_FAILED;",
          "2523:      break;",
          "2524:     }",
          "",
          "[Removed Lines]",
          "2517:      if (error_number) *error_number = errno;",
          "2519:       archive_string_sprintf(error_string,",
          "2520:         \"Could not remove symlink %s\",",
          "2521:         path);",
          "",
          "[Added Lines]",
          "2553:      if (error_number)",
          "2556:       archive_string_sprintf(",
          "2557:           error_string,",
          "2558:           \"Could not remove \"",
          "2559:           \"symlink %s\", path);",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "2531:     tail[0] = c;",
          "2533:     if (!S_ISLNK(path)) {",
          "2539:     }",
          "",
          "[Removed Lines]",
          "2534:      if (error_number) *error_number = 0;",
          "2535:      if (error_string)",
          "2536:       archive_string_sprintf(error_string,",
          "2537:         \"Removing symlink %s\",",
          "2538:         path);",
          "",
          "[Added Lines]",
          "2576:      if (error_number)",
          "2578:      if (error_string) {",
          "2579:       archive_string_sprintf(",
          "2580:           error_string,",
          "2581:           \"Removing symlink %s\",",
          "2582:           path);",
          "2583:      }",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "2546:     if (unlink(head) != 0) {",
          "2547:      tail[0] = c;",
          "2553:      res = ARCHIVE_FAILED;",
          "2554:      break;",
          "2555:     }",
          "2556:     tail[0] = c;",
          "2557:    } else {",
          "2558:     tail[0] = c;",
          "2561:      archive_string_sprintf(error_string,",
          "2564:     res = ARCHIVE_FAILED;",
          "2565:     break;",
          "2566:    }",
          "",
          "[Removed Lines]",
          "2548:      if (error_number) *error_number = 0;",
          "2549:      if (error_string)",
          "2550:       archive_string_sprintf(error_string,",
          "2551:         \"Cannot remove intervening symlink %s\",",
          "2552:         path);",
          "2559:     if (error_number) *error_number = 0;",
          "2560:     if (error_string)",
          "2562:        \"Cannot extract through symlink %s\",",
          "2563:        path);",
          "",
          "[Added Lines]",
          "2593:      if (error_number)",
          "2595:      if (error_string) {",
          "2596:       archive_string_sprintf(",
          "2597:           error_string,",
          "2598:           \"Cannot remove \"",
          "2599:           \"intervening symlink %s\",",
          "2600:           path);",
          "2601:      }",
          "2608:     if (error_number)",
          "2610:     if (error_string) {",
          "2612:          \"Cannot extract through \"",
          "2613:          \"symlink %s\", path);",
          "2614:     }",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "2577:  if (restore_pwd >= 0) {",
          "2578:   r = fchdir(restore_pwd);",
          "2579:   if (r != 0) {",
          "2582:     archive_string_sprintf(error_string,",
          "2583:       \"chdir() failure\");",
          "2584:   }",
          "2585:   close(restore_pwd);",
          "2586:   restore_pwd = -1;",
          "",
          "[Removed Lines]",
          "2580:    if(error_number) *error_number = errno;",
          "2581:    if(error_string)",
          "",
          "[Added Lines]",
          "2631:    if (error_number)",
          "2633:    if (error_string) {",
          "2636:    }",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "2605:  int error_number;",
          "2606:  int rc;",
          "2607:  archive_string_init(&error_string);",
          "2609:  if (rc != ARCHIVE_OK) {",
          "2611:  }",
          "2612:  archive_string_free(&error_string);",
          "",
          "[Removed Lines]",
          "2608:  rc = check_symlinks_fsobj(a->name, &error_number, &error_string, a->flags);",
          "2610:   archive_set_error(&a->archive, error_number, \"%s\", error_string.s);",
          "",
          "[Added Lines]",
          "2661:  rc = check_symlinks_fsobj(a->name, &error_number, &error_string,",
          "2662:      a->flags);",
          "2664:   archive_set_error(&a->archive, error_number, \"%s\",",
          "2665:       error_string.s);",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "2690: static int",
          "2692: {",
          "2693:  char *dest, *src;",
          "2694:  char separator = '\\0';",
          "2696:  dest = src = path;",
          "2697:  if (*src == '\\0') {",
          "2701:        \"Invalid empty pathname\");",
          "2702:   return (ARCHIVE_FAILED);",
          "2703:  }",
          "",
          "[Removed Lines]",
          "2691: cleanup_pathname_fsobj(char *path, int *error_number, struct archive_string *error_string, int flags)",
          "2698:   if (error_number) *error_number = ARCHIVE_ERRNO_MISC;",
          "2699:   if (error_string)",
          "2700:       archive_string_sprintf(error_string,",
          "",
          "[Added Lines]",
          "2746: cleanup_pathname_fsobj(char *path, int *error_number,",
          "2747:     struct archive_string *error_string, int flags)",
          "2754:   if (error_number)",
          "2756:   if (error_string) {",
          "2757:    archive_string_sprintf(error_string,",
          "2759:   }",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "2709:  if (*src == '/') {",
          "2710:   if (flags & ARCHIVE_EXTRACT_SECURE_NOABSOLUTEPATHS) {",
          "2714:         \"Path is absolute\");",
          "2715:    return (ARCHIVE_FAILED);",
          "2716:   }",
          "",
          "[Removed Lines]",
          "2711:    if (error_number) *error_number = ARCHIVE_ERRNO_MISC;",
          "2712:    if (error_string)",
          "2713:        archive_string_sprintf(error_string,",
          "",
          "[Added Lines]",
          "2769:    if (error_number)",
          "2771:    if (error_string) {",
          "2772:     archive_string_sprintf(error_string,",
          "2774:    }",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "2738:    } else if (src[1] == '.') {",
          "2739:     if (src[2] == '/' || src[2] == '\\0') {",
          "2746:       return (ARCHIVE_FAILED);",
          "2747:      }",
          "2748:     }",
          "",
          "[Removed Lines]",
          "2741:      if (flags & ARCHIVE_EXTRACT_SECURE_NODOTDOT) {",
          "2742:       if (error_number) *error_number = ARCHIVE_ERRNO_MISC;",
          "2743:       if (error_string)",
          "2744:           archive_string_sprintf(error_string,",
          "2745:            \"Path contains '..'\");",
          "",
          "[Added Lines]",
          "2801:      if (flags",
          "2802:          & ARCHIVE_EXTRACT_SECURE_NODOTDOT) {",
          "2803:       if (error_number) {",
          "2805:            ARCHIVE_ERRNO_MISC;",
          "2806:       }",
          "2807:       if (error_string) {",
          "2808:        archive_string_sprintf(",
          "2809:            error_string,",
          "2810:            \"Path \"",
          "2811:            \"contains '..'\");",
          "2812:       }",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "2795:  int error_number;",
          "2796:  int rc;",
          "2797:  archive_string_init(&error_string);",
          "2799:  if (rc != ARCHIVE_OK) {",
          "2801:  }",
          "2802:  archive_string_free(&error_string);",
          "2803:  return rc;",
          "",
          "[Removed Lines]",
          "2798:  rc = cleanup_pathname_fsobj(a->name, &error_number, &error_string, a->flags);",
          "2800:   archive_set_error(&a->archive, error_number, \"%s\", error_string.s);",
          "",
          "[Added Lines]",
          "2865:  rc = cleanup_pathname_fsobj(a->name, &error_number, &error_string,",
          "2866:      a->flags);",
          "2868:   archive_set_error(&a->archive, error_number, \"%s\",",
          "2869:       error_string.s);",
          "",
          "---------------",
          "--- Hunk 21 ---",
          "[Context before]",
          "2881:   }",
          "2882:  } else if (errno != ENOENT && errno != ENOTDIR) {",
          "2885:   return (ARCHIVE_FAILED);",
          "2886:  } else if (slash != NULL) {",
          "",
          "[Removed Lines]",
          "2884:   archive_set_error(&a->archive, errno, \"Can't test directory '%s'\", path);",
          "",
          "[Added Lines]",
          "2953:   archive_set_error(&a->archive, errno,",
          "2954:       \"Can't test directory '%s'\", path);",
          "",
          "---------------",
          "--- Hunk 22 ---",
          "[Context before]",
          "3406:  nochange_flags |= EXT2_IMMUTABLE_FL;",
          "3407: #endif",
          "3410: }",
          "",
          "[Removed Lines]",
          "3409:  return (set_fflags_platform(a, a->fd, a->name, mode, 0, nochange_flags));",
          "",
          "[Added Lines]",
          "3479:  return (set_fflags_platform(a, a->fd, a->name, mode, 0,",
          "3480:      nochange_flags));",
          "",
          "---------------",
          "--- Hunk 23 ---",
          "[Context before]",
          "3931:     if (errno == ENOTSUP || errno == ENOSYS) {",
          "3932:      if (!warning_done) {",
          "3933:       warning_done = 1;",
          "3935:           \"Cannot restore extended \"",
          "3936:           \"attributes on this file \"",
          "3937:           \"system\");",
          "",
          "[Removed Lines]",
          "3934:       archive_set_error(&a->archive, errno,",
          "",
          "[Added Lines]",
          "4005:       archive_set_error(&a->archive,",
          "4006:           errno,",
          "",
          "---------------",
          "--- Hunk 24 ---",
          "[Context before]",
          "3942:     ret = ARCHIVE_WARN;",
          "3943:    }",
          "3944:   } else {",
          "3946:        \"Invalid extended attribute encountered\");",
          "3947:    ret = ARCHIVE_WARN;",
          "3948:   }",
          "",
          "[Removed Lines]",
          "3945:    archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,",
          "",
          "[Added Lines]",
          "4017:    archive_set_error(&a->archive,",
          "4018:        ARCHIVE_ERRNO_FILE_FORMAT,",
          "",
          "---------------",
          "--- Hunk 25 ---",
          "[Context before]",
          "3986:    errno = 0;",
          "3987: #if HAVE_EXTATTR_SET_FD",
          "3988:    if (a->fd >= 0)",
          "3990:    else",
          "3991: #endif",
          "3993:    {",
          "3996:    }",
          "3997:    if (e != (int)size) {",
          "3998:     if (errno == ENOTSUP || errno == ENOSYS) {",
          "3999:      if (!warning_done) {",
          "4000:       warning_done = 1;",
          "4002:           \"Cannot restore extended \"",
          "4003:           \"attributes on this file \"",
          "4004:           \"system\");",
          "",
          "[Removed Lines]",
          "3989:     e = extattr_set_fd(a->fd, namespace, name, value, size);",
          "3994:     e = extattr_set_file(archive_entry_pathname(entry),",
          "3995:         namespace, name, value, size);",
          "4001:       archive_set_error(&a->archive, errno,",
          "",
          "[Added Lines]",
          "4062:     e = extattr_set_fd(a->fd, namespace, name,",
          "4063:         value, size);",
          "4068:     e = extattr_set_file(",
          "4069:         archive_entry_pathname(entry), namespace,",
          "4070:         name, value, size);",
          "4076:       archive_set_error(&a->archive,",
          "4077:           errno,",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "dce4ade52288e4642487165388a94dd13836a04d",
      "candidate_info": {
        "commit_hash": "dce4ade52288e4642487165388a94dd13836a04d",
        "repo": "libarchive/libarchive",
        "commit_url": "https://github.com/libarchive/libarchive/commit/dce4ade52288e4642487165388a94dd13836a04d",
        "files": [
          "libarchive/archive_write_disk_posix.c"
        ],
        "message": "Be more friendly to format string checkers.",
        "before_after_code_files": [
          "libarchive/archive_write_disk_posix.c||libarchive/archive_write_disk_posix.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "libarchive/archive_write_disk_posix.c||libarchive/archive_write_disk_posix.c"
          ],
          "candidate": [
            "libarchive/archive_write_disk_posix.c||libarchive/archive_write_disk_posix.c"
          ]
        }
      },
      "candidate_diff": {
        "libarchive/archive_write_disk_posix.c||libarchive/archive_write_disk_posix.c": [
          "File: libarchive/archive_write_disk_posix.c -> libarchive/archive_write_disk_posix.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "2467:  if (a_eno)",
          "2469:  if (a_estr)",
          "2471: }",
          "",
          "[Removed Lines]",
          "2470:   archive_string_sprintf(a_estr, errstr, path);",
          "",
          "[Added Lines]",
          "2470:   archive_string_sprintf(a_estr, \"%s%s\", errstr, path);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2575:     fsobj_error(a_eno, a_estr, errno,",
          "2577:     res = ARCHIVE_FAILED;",
          "2578:     break;",
          "2579:    }",
          "",
          "[Removed Lines]",
          "2576:         \"Could not stat %s\", path);",
          "",
          "[Added Lines]",
          "2576:         \"Could not stat \", path);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "2582:     if (chdir(head) != 0) {",
          "2583:      tail[0] = c;",
          "2584:      fsobj_error(a_eno, a_estr, errno,",
          "2586:      res = (ARCHIVE_FATAL);",
          "2587:      break;",
          "2588:     }",
          "",
          "[Removed Lines]",
          "2585:          \"Could not chdir %s\", path);",
          "",
          "[Added Lines]",
          "2585:          \"Could not chdir \", path);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "2599:     if (unlink(head)) {",
          "2600:      tail[0] = c;",
          "2601:      fsobj_error(a_eno, a_estr, errno,",
          "2603:          path);",
          "2604:      res = ARCHIVE_FAILED;",
          "2605:      break;",
          "",
          "[Removed Lines]",
          "2602:          \"Could not remove symlink %s\",",
          "",
          "[Added Lines]",
          "2602:          \"Could not remove symlink \",",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "2619:     if (!S_ISLNK(path)) {",
          "2620:      fsobj_error(a_eno, a_estr, 0,",
          "2622:     }",
          "",
          "[Removed Lines]",
          "2621:          \"Removing symlink %s\", path);",
          "",
          "[Added Lines]",
          "2621:          \"Removing symlink \", path);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "2630:      tail[0] = c;",
          "2631:      fsobj_error(a_eno, a_estr, 0,",
          "2632:          \"Cannot remove intervening \"",
          "2634:      res = ARCHIVE_FAILED;",
          "2635:      break;",
          "2636:     }",
          "",
          "[Removed Lines]",
          "2633:          \"symlink %s\", path);",
          "",
          "[Added Lines]",
          "2633:          \"symlink \", path);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "2652:      } else {",
          "2653:       fsobj_error(a_eno, a_estr,",
          "2654:           errno,",
          "2656:       res = (ARCHIVE_FAILED);",
          "2657:       break;",
          "2658:      }",
          "",
          "[Removed Lines]",
          "2655:           \"Could not stat %s\", path);",
          "",
          "[Added Lines]",
          "2655:           \"Could not stat \", path);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "2661:       tail[0] = c;",
          "2662:       fsobj_error(a_eno, a_estr,",
          "2663:           errno,",
          "2665:       res = (ARCHIVE_FATAL);",
          "2666:       break;",
          "2667:      }",
          "",
          "[Removed Lines]",
          "2664:           \"Could not chdir %s\", path);",
          "",
          "[Added Lines]",
          "2664:           \"Could not chdir \", path);",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "2674:      tail[0] = c;",
          "2675:      fsobj_error(a_eno, a_estr, 0,",
          "2676:          \"Cannot extract through \"",
          "2678:      res = ARCHIVE_FAILED;",
          "2679:      break;",
          "2680:     }",
          "2681:    } else {",
          "2682:     tail[0] = c;",
          "2683:     fsobj_error(a_eno, a_estr, 0,",
          "2685:     res = ARCHIVE_FAILED;",
          "2686:     break;",
          "2687:    }",
          "",
          "[Removed Lines]",
          "2677:          \"symlink %s\", path);",
          "2684:         \"Cannot extract through symlink %s\", path);",
          "",
          "[Added Lines]",
          "2677:          \"symlink \", path);",
          "2684:         \"Cannot extract through symlink \", path);",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2017-6874",
  "cve_desc": "Race condition in kernel/ucount.c in the Linux kernel through 4.10.2 allows local users to cause a denial of service (use-after-free and system crash) or possibly have unspecified other impact via crafted system calls that leverage certain decrement behavior that causes incorrect interaction between put_ucounts and get_ucounts.",
  "repo": "torvalds/linux",
  "patch_hash": "040757f738e13caaa9c5078bca79aa97e11dde88",
  "patch_info": {
    "commit_hash": "040757f738e13caaa9c5078bca79aa97e11dde88",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/040757f738e13caaa9c5078bca79aa97e11dde88",
    "files": [
      "include/linux/user_namespace.h",
      "kernel/ucount.c"
    ],
    "message": "ucount: Remove the atomicity from ucount->count\n\nAlways increment/decrement ucount->count under the ucounts_lock.  The\nincrements are there already and moving the decrements there means the\nlocking logic of the code is simpler.  This simplification in the\nlocking logic fixes a race between put_ucounts and get_ucounts that\ncould result in a use-after-free because the count could go zero then\nbe found by get_ucounts and then be freed by put_ucounts.\n\nA bug presumably this one was found by a combination of syzkaller and\nKASAN.  JongWhan Kim reported the syzkaller failure and Dmitry Vyukov\nspotted the race in the code.\n\nCc: stable@vger.kernel.org\nFixes: f6b2db1a3e8d (\"userns: Make the count of user namespaces per user\")\nReported-by: JongHwan Kim <zzoru007@gmail.com>\nReported-by: Dmitry Vyukov <dvyukov@google.com>\nReviewed-by: Andrei Vagin <avagin@gmail.com>\nSigned-off-by: \"Eric W. Biederman\" <ebiederm@xmission.com>",
    "before_after_code_files": [
      "include/linux/user_namespace.h||include/linux/user_namespace.h",
      "kernel/ucount.c||kernel/ucount.c"
    ]
  },
  "patch_diff": {
    "include/linux/user_namespace.h||include/linux/user_namespace.h": [
      "File: include/linux/user_namespace.h -> include/linux/user_namespace.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "72:  struct hlist_node node;",
      "73:  struct user_namespace *ns;",
      "74:  kuid_t uid;",
      "76:  atomic_t ucount[UCOUNT_COUNTS];",
      "77: };",
      "",
      "[Removed Lines]",
      "75:  atomic_t count;",
      "",
      "[Added Lines]",
      "75:  int count;",
      "",
      "---------------"
    ],
    "kernel/ucount.c||kernel/ucount.c": [
      "File: kernel/ucount.c -> kernel/ucount.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "145:   new->ns = ns;",
      "146:   new->uid = uid;",
      "149:   spin_lock_irq(&ucounts_lock);",
      "150:   ucounts = find_ucounts(ns, uid, hashent);",
      "",
      "[Removed Lines]",
      "147:   atomic_set(&new->count, 0);",
      "",
      "[Added Lines]",
      "147:   new->count = 0;",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "155:    ucounts = new;",
      "156:   }",
      "157:  }",
      "159:   ucounts = NULL;",
      "160:  spin_unlock_irq(&ucounts_lock);",
      "161:  return ucounts;",
      "162: }",
      "",
      "[Removed Lines]",
      "158:  if (!atomic_add_unless(&ucounts->count, 1, INT_MAX))",
      "",
      "[Added Lines]",
      "158:  if (ucounts->count == INT_MAX)",
      "160:  else",
      "161:   ucounts->count += 1;",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "165: {",
      "166:  unsigned long flags;",
      "170:   hlist_del_init(&ucounts->node);",
      "175: }",
      "177: static inline bool atomic_inc_below(atomic_t *v, int u)",
      "",
      "[Removed Lines]",
      "168:  if (atomic_dec_and_test(&ucounts->count)) {",
      "169:   spin_lock_irqsave(&ucounts_lock, flags);",
      "171:   spin_unlock_irqrestore(&ucounts_lock, flags);",
      "173:   kfree(ucounts);",
      "174:  }",
      "",
      "[Added Lines]",
      "170:  spin_lock_irqsave(&ucounts_lock, flags);",
      "171:  ucounts->count -= 1;",
      "172:  if (!ucounts->count)",
      "174:  else",
      "175:   ucounts = NULL;",
      "176:  spin_unlock_irqrestore(&ucounts_lock, flags);",
      "178:  kfree(ucounts);",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "f6b2db1a3e8d141dd144df58900fb0444d5d7c53",
      "candidate_info": {
        "commit_hash": "f6b2db1a3e8d141dd144df58900fb0444d5d7c53",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/f6b2db1a3e8d141dd144df58900fb0444d5d7c53",
        "files": [
          "include/linux/user_namespace.h",
          "kernel/fork.c",
          "kernel/ucount.c",
          "kernel/user_namespace.c"
        ],
        "message": "userns: Make the count of user namespaces per user\n\nAdd a structure that is per user and per user ns and use it to hold\nthe count of user namespaces.  This makes prevents one user from\ncreating denying service to another user by creating the maximum\nnumber of user namespaces.\n\nRename the sysctl export of the maximum count from\n/proc/sys/userns/max_user_namespaces to /proc/sys/user/max_user_namespaces\nto reflect that the count is now per user.\n\nSigned-off-by: \"Eric W. Biederman\" <ebiederm@xmission.com>",
        "before_after_code_files": [
          "include/linux/user_namespace.h||include/linux/user_namespace.h",
          "kernel/fork.c||kernel/fork.c",
          "kernel/ucount.c||kernel/ucount.c",
          "kernel/user_namespace.c||kernel/user_namespace.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "include/linux/user_namespace.h||include/linux/user_namespace.h",
            "kernel/ucount.c||kernel/ucount.c"
          ],
          "candidate": [
            "include/linux/user_namespace.h||include/linux/user_namespace.h",
            "kernel/ucount.c||kernel/ucount.c"
          ]
        }
      },
      "candidate_diff": {
        "include/linux/user_namespace.h||include/linux/user_namespace.h": [
          "File: include/linux/user_namespace.h -> include/linux/user_namespace.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "23: #define USERNS_INIT_FLAGS USERNS_SETGROUPS_ALLOWED",
          "25: struct user_namespace {",
          "26:  struct uid_gid_map uid_map;",
          "27:  struct uid_gid_map gid_map;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "25: struct ucounts;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "44:  struct ctl_table_set set;",
          "45:  struct ctl_table_header *sysctls;",
          "46: #endif",
          "47:  int max_user_namespaces;",
          "48:  atomic_t user_namespaces;",
          "49: };",
          "51: extern struct user_namespace init_user_ns;",
          "57: #ifdef CONFIG_USER_NS",
          "",
          "[Removed Lines]",
          "52: extern bool setup_userns_sysctls(struct user_namespace *ns);",
          "53: extern void retire_userns_sysctls(struct user_namespace *ns);",
          "54: extern bool inc_user_namespaces(struct user_namespace *ns);",
          "55: extern void dec_user_namespaces(struct user_namespace *ns);",
          "",
          "[Added Lines]",
          "48:  struct ucounts  *ucounts;",
          "50: };",
          "52: struct ucounts {",
          "53:  struct hlist_node node;",
          "54:  struct user_namespace *ns;",
          "55:  kuid_t uid;",
          "56:  atomic_t count;",
          "62: bool setup_userns_sysctls(struct user_namespace *ns);",
          "63: void retire_userns_sysctls(struct user_namespace *ns);",
          "64: struct ucounts *inc_user_namespaces(struct user_namespace *ns, kuid_t uid);",
          "65: void dec_user_namespaces(struct ucounts *ucounts);",
          "",
          "---------------"
        ],
        "kernel/fork.c||kernel/fork.c": [
          "File: kernel/fork.c -> kernel/fork.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "322:  init_task.signal->rlim[RLIMIT_SIGPENDING] =",
          "323:   init_task.signal->rlim[RLIMIT_NPROC];",
          "326: }",
          "328: int __weak arch_dup_task_struct(struct task_struct *dst,",
          "",
          "[Removed Lines]",
          "325:  init_user_ns.max_user_namespaces = max_threads;",
          "",
          "[Added Lines]",
          "325:  init_user_ns.max_user_namespaces = max_threads/2;",
          "",
          "---------------"
        ],
        "kernel/ucount.c||kernel/ucount.c": [
          "File: kernel/ucount.c -> kernel/ucount.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "8: #include <linux/stat.h>",
          "9: #include <linux/sysctl.h>",
          "10: #include <linux/slab.h>",
          "11: #include <linux/user_namespace.h>",
          "13: #ifdef CONFIG_SYSCTL",
          "14: static struct ctl_table_set *",
          "15: set_lookup(struct ctl_table_root *root)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "11: #include <linux/hash.h>",
          "14: #define UCOUNTS_HASHTABLE_BITS 10",
          "15: static struct hlist_head ucounts_hashtable[(1 << UCOUNTS_HASHTABLE_BITS)];",
          "16: static DEFINE_SPINLOCK(ucounts_lock);",
          "18: #define ucounts_hashfn(ns, uid)      \\",
          "19:  hash_long((unsigned long)__kuid_val(uid) + (unsigned long)(ns), \\",
          "20:     UCOUNTS_HASHTABLE_BITS)",
          "21: #define ucounts_hashentry(ns, uid) \\",
          "22:  (ucounts_hashtable + ucounts_hashfn(ns, uid))",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "46: static int zero = 0;",
          "47: static int int_max = INT_MAX;",
          "49:  {",
          "50:   .procname = \"max_user_namespaces\",",
          "51:   .data  = &init_user_ns.max_user_namespaces,",
          "",
          "[Removed Lines]",
          "48: static struct ctl_table userns_table[] = {",
          "",
          "[Added Lines]",
          "60: static struct ctl_table user_table[] = {",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "64: #ifdef CONFIG_SYSCTL",
          "65:  struct ctl_table *tbl;",
          "66:  setup_sysctl_set(&ns->set, &set_root, set_is_seen);",
          "68:  if (tbl) {",
          "69:   tbl[0].data = &ns->max_user_namespaces;",
          "72:  }",
          "73:  if (!ns->sysctls) {",
          "74:   kfree(tbl);",
          "",
          "[Removed Lines]",
          "67:  tbl = kmemdup(userns_table, sizeof(userns_table), GFP_KERNEL);",
          "71:   ns->sysctls = __register_sysctl_table(&ns->set, \"userns\", tbl);",
          "",
          "[Added Lines]",
          "79:  tbl = kmemdup(user_table, sizeof(user_table), GFP_KERNEL);",
          "83:   ns->sysctls = __register_sysctl_table(&ns->set, \"user\", tbl);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "91: #endif",
          "92: }",
          "94: static inline bool atomic_inc_below(atomic_t *v, int u)",
          "95: {",
          "96:  int c, old;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "106: static struct ucounts *find_ucounts(struct user_namespace *ns, kuid_t uid, struct hlist_head *hashent)",
          "107: {",
          "108:  struct ucounts *ucounts;",
          "110:  hlist_for_each_entry(ucounts, hashent, node) {",
          "111:   if (uid_eq(ucounts->uid, uid) && (ucounts->ns == ns))",
          "112:    return ucounts;",
          "113:  }",
          "114:  return NULL;",
          "115: }",
          "117: static struct ucounts *get_ucounts(struct user_namespace *ns, kuid_t uid)",
          "118: {",
          "119:  struct hlist_head *hashent = ucounts_hashentry(ns, uid);",
          "120:  struct ucounts *ucounts, *new;",
          "122:  spin_lock(&ucounts_lock);",
          "123:  ucounts = find_ucounts(ns, uid, hashent);",
          "124:  if (!ucounts) {",
          "125:   spin_unlock(&ucounts_lock);",
          "127:   new = kzalloc(sizeof(*new), GFP_KERNEL);",
          "128:   if (!new)",
          "129:    return NULL;",
          "131:   new->ns = ns;",
          "132:   new->uid = uid;",
          "133:   atomic_set(&new->count, 0);",
          "135:   spin_lock(&ucounts_lock);",
          "136:   ucounts = find_ucounts(ns, uid, hashent);",
          "137:   if (ucounts) {",
          "138:    kfree(new);",
          "139:   } else {",
          "140:    hlist_add_head(&new->node, hashent);",
          "141:    ucounts = new;",
          "142:   }",
          "143:  }",
          "144:  if (!atomic_add_unless(&ucounts->count, 1, INT_MAX))",
          "145:   ucounts = NULL;",
          "146:  spin_unlock(&ucounts_lock);",
          "147:  return ucounts;",
          "148: }",
          "150: static void put_ucounts(struct ucounts *ucounts)",
          "151: {",
          "152:  if (atomic_dec_and_test(&ucounts->count)) {",
          "153:   spin_lock(&ucounts_lock);",
          "154:   hlist_del_init(&ucounts->node);",
          "155:   spin_unlock(&ucounts_lock);",
          "157:   kfree(ucounts);",
          "158:  }",
          "159: }",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "105:  }",
          "106: }",
          "109: {",
          "114:    goto fail;",
          "115:  }",
          "117: fail:",
          "123: }",
          "126: {",
          "130:   WARN_ON_ONCE(dec < 0);",
          "131:  }",
          "132: }",
          "134: static __init int user_namespace_sysctl_init(void)",
          "135: {",
          "136: #ifdef CONFIG_SYSCTL",
          "138:  static struct ctl_table empty[1];",
          "146:  BUG_ON(!setup_userns_sysctls(&init_user_ns));",
          "147: #endif",
          "148:  return 0;",
          "",
          "[Removed Lines]",
          "108: bool inc_user_namespaces(struct user_namespace *ns)",
          "110:  struct user_namespace *pos, *bad;",
          "111:  for (pos = ns; pos; pos = pos->parent) {",
          "112:   int max = READ_ONCE(pos->max_user_namespaces);",
          "113:   if (!atomic_inc_below(&pos->user_namespaces, max))",
          "116:  return true;",
          "118:  bad = pos;",
          "119:  for (pos = ns; pos != bad; pos = pos->parent)",
          "120:   atomic_dec(&pos->user_namespaces);",
          "122:  return false;",
          "125: void dec_user_namespaces(struct user_namespace *ns)",
          "127:  struct user_namespace *pos;",
          "128:  for (pos = ns; pos; pos = pos->parent) {",
          "129:   int dec = atomic_dec_if_positive(&pos->user_namespaces);",
          "137:  static struct ctl_table_header *userns_header;",
          "144:  userns_header = register_sysctl(\"userns\", empty);",
          "145:  BUG_ON(!userns_header);",
          "",
          "[Added Lines]",
          "175: struct ucounts *inc_user_namespaces(struct user_namespace *ns, kuid_t uid)",
          "177:  struct ucounts *ucounts, *iter, *bad;",
          "178:  struct user_namespace *tns;",
          "179:  ucounts = get_ucounts(ns, uid);",
          "180:  for (iter = ucounts; iter; iter = tns->ucounts) {",
          "181:   int max;",
          "182:   tns = iter->ns;",
          "183:   max = READ_ONCE(tns->max_user_namespaces);",
          "184:   if (!atomic_inc_below(&iter->user_namespaces, max))",
          "187:  return ucounts;",
          "189:  bad = iter;",
          "190:  for (iter = ucounts; iter != bad; iter = iter->ns->ucounts)",
          "191:   atomic_dec(&iter->user_namespaces);",
          "193:  put_ucounts(ucounts);",
          "194:  return NULL;",
          "197: void dec_user_namespaces(struct ucounts *ucounts)",
          "199:  struct ucounts *iter;",
          "200:  for (iter = ucounts; iter; iter = iter->ns->ucounts) {",
          "201:   int dec = atomic_dec_if_positive(&iter->user_namespaces);",
          "204:  put_ucounts(ucounts);",
          "211:  static struct ctl_table_header *user_header;",
          "218:  user_header = register_sysctl(\"user\", empty);",
          "219:  BUG_ON(!user_header);",
          "",
          "---------------"
        ],
        "kernel/user_namespace.c||kernel/user_namespace.c": [
          "File: kernel/user_namespace.c -> kernel/user_namespace.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "64:  struct user_namespace *ns, *parent_ns = new->user_ns;",
          "65:  kuid_t owner = new->euid;",
          "66:  kgid_t group = new->egid;",
          "67:  int ret;",
          "69:  ret = -EUSERS;",
          "70:  if (parent_ns->level > 32)",
          "71:   goto fail;",
          "74:   goto fail;",
          "",
          "[Removed Lines]",
          "73:  if (!inc_user_namespaces(parent_ns))",
          "",
          "[Added Lines]",
          "66:  struct ucounts *ucounts;",
          "73:  ucounts = inc_user_namespaces(parent_ns, owner);",
          "74:  if (!ucounts)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "110:  ns->group = group;",
          "111:  INIT_WORK(&ns->work, free_user_ns);",
          "112:  ns->max_user_namespaces = INT_MAX;",
          "115:  mutex_lock(&userns_state_mutex);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "114:  ns->ucounts = ucounts;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "133: fail_free:",
          "134:  kmem_cache_free(user_ns_cachep, ns);",
          "135: fail_dec:",
          "137: fail:",
          "138:  return ret;",
          "139: }",
          "",
          "[Removed Lines]",
          "136:  dec_user_namespaces(parent_ns);",
          "",
          "[Added Lines]",
          "138:  dec_user_namespaces(ucounts);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "164:   container_of(work, struct user_namespace, work);",
          "166:  do {",
          "167:   parent = ns->parent;",
          "168:   retire_userns_sysctls(ns);",
          "169: #ifdef CONFIG_PERSISTENT_KEYRINGS",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "169:   struct ucounts *ucounts = ns->ucounts;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "171: #endif",
          "172:   ns_free_inum(&ns->ns);",
          "173:   kmem_cache_free(user_ns_cachep, ns);",
          "175:   ns = parent;",
          "176:  } while (atomic_dec_and_test(&parent->count));",
          "177: }",
          "",
          "[Removed Lines]",
          "174:   dec_user_namespaces(parent);",
          "",
          "[Added Lines]",
          "177:   dec_user_namespaces(ucounts);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "880a38547ff08715ce4f1daf9a4bb30c87676e68",
      "candidate_info": {
        "commit_hash": "880a38547ff08715ce4f1daf9a4bb30c87676e68",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/880a38547ff08715ce4f1daf9a4bb30c87676e68",
        "files": [
          "kernel/ucount.c"
        ],
        "message": "userns: Make ucounts lock irq-safe\n\nThe ucounts_lock is being used to protect various ucounts lifecycle\nmanagement functionalities. However, those services can also be invoked\nwhen a pidns is being freed in an RCU callback (e.g. softirq context).\nThis can lead to deadlocks. There were already efforts trying to\nprevent similar deadlocks in add7c65ca426 (\"pid: fix lockdep deadlock\nwarning due to ucount_lock\"), however they just moved the context\nfrom hardirq to softrq. Fix this issue once and for all by explictly\nmaking the lock disable irqs altogether.\n\nDmitry Vyukov <dvyukov@google.com> reported:\n\n> I've got the following deadlock report while running syzkaller fuzzer\n> on eec0d3d065bfcdf9cd5f56dd2a36b94d12d32297 of linux-next (on odroid\n> device if it matters):\n>\n> =================================\n> [ INFO: inconsistent lock state ]\n> 4.10.0-rc3-next-20170112-xc2-dirty #6 Not tainted\n> ---------------------------------\n> inconsistent {SOFTIRQ-ON-W} -> {IN-SOFTIRQ-W} usage.\n> swapper/2/0 [HC0[0]:SC1[1]:HE1:SE0] takes:\n>  (ucounts_lock){+.?...}, at: [<     inline     >] spin_lock\n> ./include/linux/spinlock.h:302\n>  (ucounts_lock){+.?...}, at: [<ffff2000081678c8>]\n> put_ucounts+0x60/0x138 kernel/ucount.c:162\n> {SOFTIRQ-ON-W} state was registered at:\n> [<ffff2000081c82d8>] mark_lock+0x220/0xb60 kernel/locking/lockdep.c:3054\n> [<     inline     >] mark_irqflags kernel/locking/lockdep.c:2941\n> [<ffff2000081c97a8>] __lock_acquire+0x388/0x3260 kernel/locking/lockdep.c:3295\n> [<ffff2000081cce24>] lock_acquire+0xa4/0x138 kernel/locking/lockdep.c:3753\n> [<     inline     >] __raw_spin_lock ./include/linux/spinlock_api_smp.h:144\n> [<ffff200009798128>] _raw_spin_lock+0x90/0xd0 kernel/locking/spinlock.c:151\n> [<     inline     >] spin_lock ./include/linux/spinlock.h:302\n> [<     inline     >] get_ucounts kernel/ucount.c:131\n> [<ffff200008167c28>] inc_ucount+0x80/0x6c8 kernel/ucount.c:189\n> [<     inline     >] inc_mnt_namespaces fs/namespace.c:2818\n> [<ffff200008481850>] alloc_mnt_ns+0x78/0x3a8 fs/namespace.c:2849\n> [<ffff200008487298>] create_mnt_ns+0x28/0x200 fs/namespace.c:2959\n> [<     inline     >] init_mount_tree fs/namespace.c:3199\n> [<ffff200009bd6674>] mnt_init+0x258/0x384 fs/namespace.c:3251\n> [<ffff200009bd60bc>] vfs_caches_init+0x6c/0x80 fs/dcache.c:3626\n> [<ffff200009bb1114>] start_kernel+0x414/0x460 init/main.c:648\n> [<ffff200009bb01e8>] __primary_switched+0x6c/0x70 arch/arm64/kernel/head.S:456\n> irq event stamp: 2316924\n> hardirqs last  enabled at (2316924): [<     inline     >] rcu_do_batch\n> kernel/rcu/tree.c:2911\n> hardirqs last  enabled at (2316924): [<     inline     >]\n> invoke_rcu_callbacks kernel/rcu/tree.c:3182\n> hardirqs last  enabled at (2316924): [<     inline     >]\n> __rcu_process_callbacks kernel/rcu/tree.c:3149\n> hardirqs last  enabled at (2316924): [<ffff200008210414>]\n> rcu_process_callbacks+0x7a4/0xc28 kernel/rcu/tree.c:3166\n> hardirqs last disabled at (2316923): [<     inline     >] rcu_do_batch\n> kernel/rcu/tree.c:2900\n> hardirqs last disabled at (2316923): [<     inline     >]\n> invoke_rcu_callbacks kernel/rcu/tree.c:3182\n> hardirqs last disabled at (2316923): [<     inline     >]\n> __rcu_process_callbacks kernel/rcu/tree.c:3149\n> hardirqs last disabled at (2316923): [<ffff20000820fe80>]\n> rcu_process_callbacks+0x210/0xc28 kernel/rcu/tree.c:3166\n> softirqs last  enabled at (2316912): [<ffff20000811b4c4>]\n> _local_bh_enable+0x4c/0x80 kernel/softirq.c:155\n> softirqs last disabled at (2316913): [<     inline     >]\n> do_softirq_own_stack ./include/linux/interrupt.h:488\n> softirqs last disabled at (2316913): [<     inline     >]\n> invoke_softirq kernel/softirq.c:371\n> softirqs last disabled at (2316913): [<ffff20000811c994>]\n> irq_exit+0x264/0x308 kernel/softirq.c:405\n>\n> other info that might help us debug this:\n>  Possible unsafe locking scenario:\n>\n>        CPU0\n>        ----\n>   lock(ucounts_lock);\n>   <Interrupt>\n>     lock(ucounts_lock);\n>\n>  *** DEADLOCK ***\n>\n> 1 lock held by swapper/2/0:\n>  #0:  (rcu_callback){......}, at: [<     inline     >] __rcu_reclaim\n> kernel/rcu/rcu.h:108\n>  #0:  (rcu_callback){......}, at: [<     inline     >] rcu_do_batch\n> kernel/rcu/tree.c:2919\n>  #0:  (rcu_callback){......}, at: [<     inline     >]\n> invoke_rcu_callbacks kernel/rcu/tree.c:3182\n>  #0:  (rcu_callback){......}, at: [<     inline     >]\n> __rcu_process_callbacks kernel/rcu/tree.c:3149\n>  #0:  (rcu_callback){......}, at: [<ffff200008210390>]\n> rcu_process_callbacks+0x720/0xc28 kernel/rcu/tree.c:3166\n>\n> stack backtrace:\n> CPU: 2 PID: 0 Comm: swapper/2 Not tainted 4.10.0-rc3-next-20170112-xc2-dirty #6\n> Hardware name: Hardkernel ODROID-C2 (DT)\n> Call trace:\n> [<ffff20000808fa60>] dump_backtrace+0x0/0x440 arch/arm64/kernel/traps.c:500\n> [<ffff20000808fec0>] show_stack+0x20/0x30 arch/arm64/kernel/traps.c:225\n> [<ffff2000088a99e0>] dump_stack+0x110/0x168\n> [<ffff2000082fa2b4>] print_usage_bug.part.27+0x49c/0x4bc\n> kernel/locking/lockdep.c:2387\n> [<     inline     >] print_usage_bug kernel/locking/lockdep.c:2357\n> [<     inline     >] valid_state kernel/locking/lockdep.c:2400\n> [<     inline     >] mark_lock_irq kernel/locking/lockdep.c:2617\n> [<ffff2000081c89ec>] mark_lock+0x934/0xb60 kernel/locking/lockdep.c:3065\n> [<     inline     >] mark_irqflags kernel/locking/lockdep.c:2923\n> [<ffff2000081c9a60>] __lock_acquire+0x640/0x3260 kernel/locking/lockdep.c:3295\n> [<ffff2000081cce24>] lock_acquire+0xa4/0x138 kernel/locking/lockdep.c:3753\n> [<     inline     >] __raw_spin_lock ./include/linux/spinlock_api_smp.h:144\n> [<ffff200009798128>] _raw_spin_lock+0x90/0xd0 kernel/locking/spinlock.c:151\n> [<     inline     >] spin_lock ./include/linux/spinlock.h:302\n> [<ffff2000081678c8>] put_ucounts+0x60/0x138 kernel/ucount.c:162\n> [<ffff200008168364>] dec_ucount+0xf4/0x158 kernel/ucount.c:214\n> [<     inline     >] dec_pid_namespaces kernel/pid_namespace.c:89\n> [<ffff200008293dc8>] delayed_free_pidns+0x40/0xe0 kernel/pid_namespace.c:156\n> [<     inline     >] __rcu_reclaim kernel/rcu/rcu.h:118\n> [<     inline     >] rcu_do_batch kernel/rcu/tree.c:2919\n> [<     inline     >] invoke_rcu_callbacks kernel/rcu/tree.c:3182\n> [<     inline     >] __rcu_process_callbacks kernel/rcu/tree.c:3149\n> [<ffff2000082103d8>] rcu_process_callbacks+0x768/0xc28 kernel/rcu/tree.c:3166\n> [<ffff2000080821dc>] __do_softirq+0x324/0x6e0 kernel/softirq.c:284\n> [<     inline     >] do_softirq_own_stack ./include/linux/interrupt.h:488\n> [<     inline     >] invoke_softirq kernel/softirq.c:371\n> [<ffff20000811c994>] irq_exit+0x264/0x308 kernel/softirq.c:405\n> [<ffff2000081ecc28>] __handle_domain_irq+0xc0/0x150 kernel/irq/irqdesc.c:636\n> [<ffff200008081c80>] gic_handle_irq+0x68/0xd8\n> Exception stack(0xffff8000648e7dd0 to 0xffff8000648e7f00)\n> 7dc0:                                   ffff8000648d4b3c 0000000000000007\n> 7de0: 0000000000000000 1ffff0000c91a967 1ffff0000c91a967 1ffff0000c91a967\n> 7e00: ffff20000a4b6b68 0000000000000001 0000000000000007 0000000000000001\n> 7e20: 1fffe4000149ae90 ffff200009d35000 0000000000000000 0000000000000002\n> 7e40: 0000000000000000 0000000000000000 0000000002624a1a 0000000000000000\n> 7e60: 0000000000000000 ffff200009cbcd88 000060006d2ed000 0000000000000140\n> 7e80: ffff200009cff000 ffff200009cb6000 ffff200009cc2020 ffff200009d2159d\n> 7ea0: 0000000000000000 ffff8000648d4380 0000000000000000 ffff8000648e7f00\n> 7ec0: ffff20000820a478 ffff8000648e7f00 ffff20000820a47c 0000000010000145\n> 7ee0: 0000000000000140 dfff200000000000 ffffffffffffffff ffff20000820a478\n> [<ffff2000080837f8>] el1_irq+0xb8/0x130 arch/arm64/kernel/entry.S:486\n> [<     inline     >] arch_local_irq_restore\n> ./arch/arm64/include/asm/irqflags.h:81\n> [<ffff20000820a47c>] rcu_idle_exit+0x64/0xa8 kernel/rcu/tree.c:1030\n> [<     inline     >] cpuidle_idle_call kernel/sched/idle.c:200\n> [<ffff2000081bcbfc>] do_idle+0x1dc/0x2d0 kernel/sched/idle.c:243\n> [<ffff2000081bd1cc>] cpu_startup_entry+0x24/0x28 kernel/sched/idle.c:345\n> [<ffff200008099f8c>] secondary_start_kernel+0x2cc/0x358\n> arch/arm64/kernel/smp.c:276\n> [<000000000279f1a4>] 0x279f1a4\n\nReported-by: Dmitry Vyukov <dvyukov@google.com>\nTested-by: Dmitry Vyukov <dvyukov@google.com>\nFixes: add7c65ca426 (\"pid: fix lockdep deadlock warning due to ucount_lock\")\nFixes: f333c700c610 (\"pidns: Add a limit on the number of pid namespaces\")\nCc: stable@vger.kernel.org\nLink: https://www.spinics.net/lists/kernel/msg2426637.html\nSigned-off-by: Nikolay Borisov <n.borisov.lkml@gmail.com>\nSigned-off-by: Eric W. Biederman <ebiederm@xmission.com>",
        "before_after_code_files": [
          "kernel/ucount.c||kernel/ucount.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "kernel/ucount.c||kernel/ucount.c"
          ],
          "candidate": [
            "kernel/ucount.c||kernel/ucount.c"
          ]
        }
      },
      "candidate_diff": {
        "kernel/ucount.c||kernel/ucount.c": [
          "File: kernel/ucount.c -> kernel/ucount.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "128:  struct hlist_head *hashent = ucounts_hashentry(ns, uid);",
          "129:  struct ucounts *ucounts, *new;",
          "132:  ucounts = find_ucounts(ns, uid, hashent);",
          "133:  if (!ucounts) {",
          "136:   new = kzalloc(sizeof(*new), GFP_KERNEL);",
          "137:   if (!new)",
          "",
          "[Removed Lines]",
          "131:  spin_lock(&ucounts_lock);",
          "134:   spin_unlock(&ucounts_lock);",
          "",
          "[Added Lines]",
          "131:  spin_lock_irq(&ucounts_lock);",
          "134:   spin_unlock_irq(&ucounts_lock);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "141:   new->uid = uid;",
          "142:   atomic_set(&new->count, 0);",
          "145:   ucounts = find_ucounts(ns, uid, hashent);",
          "146:   if (ucounts) {",
          "147:    kfree(new);",
          "",
          "[Removed Lines]",
          "144:   spin_lock(&ucounts_lock);",
          "",
          "[Added Lines]",
          "144:   spin_lock_irq(&ucounts_lock);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "152:  }",
          "153:  if (!atomic_add_unless(&ucounts->count, 1, INT_MAX))",
          "154:   ucounts = NULL;",
          "156:  return ucounts;",
          "157: }",
          "159: static void put_ucounts(struct ucounts *ucounts)",
          "160: {",
          "161:  if (atomic_dec_and_test(&ucounts->count)) {",
          "163:   hlist_del_init(&ucounts->node);",
          "166:   kfree(ucounts);",
          "167:  }",
          "",
          "[Removed Lines]",
          "155:  spin_unlock(&ucounts_lock);",
          "162:   spin_lock(&ucounts_lock);",
          "164:   spin_unlock(&ucounts_lock);",
          "",
          "[Added Lines]",
          "155:  spin_unlock_irq(&ucounts_lock);",
          "161:  unsigned long flags;",
          "164:   spin_lock_irqsave(&ucounts_lock, flags);",
          "166:   spin_unlock_irqrestore(&ucounts_lock, flags);",
          "",
          "---------------"
        ]
      }
    }
  ]
}
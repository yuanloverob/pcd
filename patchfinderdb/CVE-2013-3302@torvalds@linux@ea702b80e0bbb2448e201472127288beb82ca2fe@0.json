{
  "cve_id": "CVE-2013-3302",
  "cve_desc": "Race condition in the smb_send_rqst function in fs/cifs/transport.c in the Linux kernel before 3.7.2 allows local users to cause a denial of service (NULL pointer dereference and OOPS) or possibly have unspecified other impact via vectors involving a reconnection event.",
  "repo": "torvalds/linux",
  "patch_hash": "ea702b80e0bbb2448e201472127288beb82ca2fe",
  "patch_info": {
    "commit_hash": "ea702b80e0bbb2448e201472127288beb82ca2fe",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/ea702b80e0bbb2448e201472127288beb82ca2fe",
    "files": [
      "fs/cifs/transport.c"
    ],
    "message": "cifs: move check for NULL socket into smb_send_rqst\n\nCai reported this oops:\n\n[90701.616664] BUG: unable to handle kernel NULL pointer dereference at 0000000000000028\n[90701.625438] IP: [<ffffffff814a343e>] kernel_setsockopt+0x2e/0x60\n[90701.632167] PGD fea319067 PUD 103fda4067 PMD 0\n[90701.637255] Oops: 0000 [#1] SMP\n[90701.640878] Modules linked in: des_generic md4 nls_utf8 cifs dns_resolver binfmt_misc tun sg igb iTCO_wdt iTCO_vendor_support lpc_ich pcspkr i2c_i801 i2c_core i7core_edac edac_core ioatdma dca mfd_core coretemp kvm_intel kvm crc32c_intel microcode sr_mod cdrom ata_generic sd_mod pata_acpi crc_t10dif ata_piix libata megaraid_sas dm_mirror dm_region_hash dm_log dm_mod\n[90701.677655] CPU 10\n[90701.679808] Pid: 9627, comm: ls Tainted: G        W    3.7.1+ #10 QCI QSSC-S4R/QSSC-S4R\n[90701.688950] RIP: 0010:[<ffffffff814a343e>]  [<ffffffff814a343e>] kernel_setsockopt+0x2e/0x60\n[90701.698383] RSP: 0018:ffff88177b431bb8  EFLAGS: 00010206\n[90701.704309] RAX: ffff88177b431fd8 RBX: 00007ffffffff000 RCX: ffff88177b431bec\n[90701.712271] RDX: 0000000000000003 RSI: 0000000000000006 RDI: 0000000000000000\n[90701.720223] RBP: ffff88177b431bc8 R08: 0000000000000004 R09: 0000000000000000\n[90701.728185] R10: 0000000000000001 R11: 0000000000000000 R12: 0000000000000001\n[90701.736147] R13: ffff88184ef92000 R14: 0000000000000023 R15: ffff88177b431c88\n[90701.744109] FS:  00007fd56a1a47c0(0000) GS:ffff88105fc40000(0000) knlGS:0000000000000000\n[90701.753137] CS:  0010 DS: 0000 ES: 0000 CR0: 000000008005003b\n[90701.759550] CR2: 0000000000000028 CR3: 000000104f15f000 CR4: 00000000000007e0\n[90701.767512] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\n[90701.775465] DR3: 0000000000000000 DR6: 00000000ffff0ff0 DR7: 0000000000000400\n[90701.783428] Process ls (pid: 9627, threadinfo ffff88177b430000, task ffff88185ca4cb60)\n[90701.792261] Stack:\n[90701.794505]  0000000000000023 ffff88177b431c50 ffff88177b431c38 ffffffffa014fcb1\n[90701.802809]  ffff88184ef921bc 0000000000000000 00000001ffffffff ffff88184ef921c0\n[90701.811123]  ffff88177b431c08 ffffffff815ca3d9 ffff88177b431c18 ffff880857758000\n[90701.819433] Call Trace:\n[90701.822183]  [<ffffffffa014fcb1>] smb_send_rqst+0x71/0x1f0 [cifs]\n[90701.828991]  [<ffffffff815ca3d9>] ? schedule+0x29/0x70\n[90701.834736]  [<ffffffffa014fe6d>] smb_sendv+0x3d/0x40 [cifs]\n[90701.841062]  [<ffffffffa014fe96>] smb_send+0x26/0x30 [cifs]\n[90701.847291]  [<ffffffffa015801f>] send_nt_cancel+0x6f/0xd0 [cifs]\n[90701.854102]  [<ffffffffa015075e>] SendReceive+0x18e/0x360 [cifs]\n[90701.860814]  [<ffffffffa0134a78>] CIFSFindFirst+0x1a8/0x3f0 [cifs]\n[90701.867724]  [<ffffffffa013f731>] ? build_path_from_dentry+0xf1/0x260 [cifs]\n[90701.875601]  [<ffffffffa013f731>] ? build_path_from_dentry+0xf1/0x260 [cifs]\n[90701.883477]  [<ffffffffa01578e6>] cifs_query_dir_first+0x26/0x30 [cifs]\n[90701.890869]  [<ffffffffa015480d>] initiate_cifs_search+0xed/0x250 [cifs]\n[90701.898354]  [<ffffffff81195970>] ? fillonedir+0x100/0x100\n[90701.904486]  [<ffffffffa01554cb>] cifs_readdir+0x45b/0x8f0 [cifs]\n[90701.911288]  [<ffffffff81195970>] ? fillonedir+0x100/0x100\n[90701.917410]  [<ffffffff81195970>] ? fillonedir+0x100/0x100\n[90701.923533]  [<ffffffff81195970>] ? fillonedir+0x100/0x100\n[90701.929657]  [<ffffffff81195848>] vfs_readdir+0xb8/0xe0\n[90701.935490]  [<ffffffff81195b9f>] sys_getdents+0x8f/0x110\n[90701.941521]  [<ffffffff815d3b99>] system_call_fastpath+0x16/0x1b\n[90701.948222] Code: 66 90 55 65 48 8b 04 25 f0 c6 00 00 48 89 e5 53 48 83 ec 08 83 fe 01 48 8b 98 48 e0 ff ff 48 c7 80 48 e0 ff ff ff ff ff ff 74 22 <48> 8b 47 28 ff 50 68 65 48 8b 14 25 f0 c6 00 00 48 89 9a 48 e0\n[90701.970313] RIP  [<ffffffff814a343e>] kernel_setsockopt+0x2e/0x60\n[90701.977125]  RSP <ffff88177b431bb8>\n[90701.981018] CR2: 0000000000000028\n[90701.984809] ---[ end trace 24bd602971110a43 ]---\n\nThis is likely due to a race vs. a reconnection event.\n\nThe current code checks for a NULL socket in smb_send_kvec, but that's\ntoo late. By the time that check is done, the socket will already have\nbeen passed to kernel_setsockopt. Move the check into smb_send_rqst, so\nthat it's checked earlier.\n\nIn truth, this is a bit of a half-assed fix. The -ENOTSOCK error\nreturn here looks like it could bubble back up to userspace. The locking\nrules around the ssocket pointer are really unclear as well. There are\ncases where the ssocket pointer is changed without holding the srv_mutex,\nbut I'm not clear whether there's a potential race here yet or not.\n\nThis code seems like it could benefit from some fundamental re-think of\nhow the socket handling should behave. Until then though, this patch\nshould at least fix the above oops in most cases.\n\nCc: <stable@vger.kernel.org> # 3.7+\nReported-and-Tested-by: CAI Qian <caiqian@redhat.com>\nSigned-off-by: Jeff Layton <jlayton@redhat.com>\nSigned-off-by: Steve French <smfrench@gmail.com>",
    "before_after_code_files": [
      "fs/cifs/transport.c||fs/cifs/transport.c"
    ]
  },
  "patch_diff": {
    "fs/cifs/transport.c||fs/cifs/transport.c": [
      "File: fs/cifs/transport.c -> fs/cifs/transport.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "150:  smb_msg.msg_name = (struct sockaddr *) &server->dstaddr;",
      "151:  smb_msg.msg_namelen = sizeof(struct sockaddr);",
      "152:  smb_msg.msg_control = NULL;",
      "",
      "[Removed Lines]",
      "147:  if (ssocket == NULL)",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "291:  struct socket *ssocket = server->ssocket;",
      "292:  int val = 1;",
      "294:  cFYI(1, \"Sending smb: smb_len=%u\", smb_buf_length);",
      "295:  dump_smb(iov[0].iov_base, iov[0].iov_len);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "291:  if (ssocket == NULL)",
      "292:   return -ENOTSOCK;",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "1c069100c1f5577ecde06b3a366b73f520854c4e",
      "candidate_info": {
        "commit_hash": "1c069100c1f5577ecde06b3a366b73f520854c4e",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/1c069100c1f5577ecde06b3a366b73f520854c4e",
        "files": [
          "drivers/edac/edac_pci_sysfs.c"
        ],
        "message": "i7core_edac: fix kernel crash on unloading i7core_edac.\n\nIt is easy to trigger this crash on 3.7.0:\n\nroot@intel_westmere_ep-3:~# modprobe -r i7core_edac\nEDAC PCI: Removed device 0 for i7core_edac EDAC PCI controller: DEV 0000:fe:03.0\nEDAC MC: Removed device 1 for i7core_edac.c i7 core #1: DEV 0000:fe:03.0\nEDAC PCI: Removed device 1 for i7core_edac EDAC PCI controller: DEV 0000:ff:03.0\nEDAC MC: Removed device 0 for i7core_edac.c i7 core #0: DEV 0000:ff:03.0\nBUG: unable to handle kernel NULL pointer dereference at 0000000000000110\nIP: [<ffffffff82069ee9>] __blocking_notifier_call_chain+0x29/0x80\nPGD 1eaae7067 PUD 1e96e4067 PMD 0\nOops: 0000 [#1] PREEMPT SMP\nModules linked in: minix acpi_cpufreq freq_table mperf ioatdma processor edac_core(-) iTCO_wdt coretemp evdev hwmon lpc_ich dca mfd_core crc32c_intel ioapic [last unloaded: i7core_edac]\nCPU 3\nPid: 1268, comm: modprobe Not tainted 3.7.0-WR5.0.1.0_standard+ #30 Intel Corporation S5520HC/S5520HC\nRIP: 0010:[<ffffffff82069ee9>]  [<ffffffff82069ee9>] __blocking_notifier_call_chain+0x29/0x80\nRSP: 0018:ffff8801eb12de28  EFLAGS: 00010246\nRAX: 0000000000000000 RBX: 00000000000000f0 RCX: 00000000ffffffff\nRDX: ffff88012b452800 RSI: 0000000000000002 RDI: 00000000000000f0\nRBP: ffff8801eb12de68 R08: 0000000000000000 R09: ffffea0004ad1118\nR10: 0000000000000000 R11: 0000000000000000 R12: 0000000000000000\nR13: ffff8801eb12dee8 R14: ffff88012b452800 R15: 000000000060e518\nFS:  00007f9ea95a9700(0000) GS:ffff8801efc20000(0000) knlGS:0000000000000000\nCS:  0010 DS: 0000 ES: 0000 CR0: 000000008005003b\nCR2: 0000000000000110 CR3: 00000001262f1000 CR4: 00000000000007e0\nDR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\nDR3: 0000000000000000 DR6: 00000000ffff0ff0 DR7: 0000000000000400\nProcess modprobe (pid: 1268, threadinfo ffff8801eb12c000, task ffff8801e8421690)\nStack:\n  ffff88012c802a00 ffff88012b445ec0 ffff88012c802300 ffff88012b452800\n  0000000000000000 ffff8801eb12dee8 000000000060e080 000000000060e518\n  ffff8801eb12de78 ffffffff82069f56 ffff8801eb12dea8 ffffffff824ead7c\nCall Trace:\n  [<ffffffff82069f56>] blocking_notifier_call_chain+0x16/0x20\n  [<ffffffff824ead7c>] device_del+0x3c/0x1d0\n  [<ffffffffa00095a8>] edac_mc_sysfs_exit+0x1c/0x2f [edac_core]\n  [<ffffffffa000961c>] edac_exit+0x4f/0x56 [edac_core]\n  [<ffffffff820a3d2a>] sys_delete_module+0x17a/0x240\n  [<ffffffff8212da7c>] ? vm_munmap+0x5c/0x80\n  [<ffffffff82877682>] system_call_fastpath+0x16/0x1b\nCode: 90 90 55 48 89 e5 48 83 ec 40 48 89 5d d8 4c 89 65 e0 4c 89 6d e8 4c 89 75 f0 4c 89 7d f8 66 66 66 66 90 31 c0 49 89 d6 48 89 fb <48> 8b 57 20 49 89 f5 41 89 cf 4c 8d 67 20 48 85 d2 74 2c 4c 89\nRIP  [<ffffffff82069ee9>] __blocking_notifier_call_chain+0x29/0x80\n  RSP <ffff8801eb12de28>\nCR2: 0000000000000110\n---[ end trace b69acf12ccad1c0d ]---\n\nUsually, edac_subsys is grabbed one time by pci at initialization.\nBut edac_subsys may be released several times if multiple pci MCs exist.\nThe fix just makes the operations balanced.\n\nSigned-off-by: Lans Zhang <jia.zhang@windriver.com>\nSigned-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>",
        "before_after_code_files": [
          "drivers/edac/edac_pci_sysfs.c||drivers/edac/edac_pci_sysfs.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "drivers/edac/edac_pci_sysfs.c||drivers/edac/edac_pci_sysfs.c": [
          "File: drivers/edac/edac_pci_sysfs.c -> drivers/edac/edac_pci_sysfs.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "429:  if (atomic_dec_return(&edac_pci_sysfs_refcount) == 0) {",
          "430:   edac_dbg(0, \"called kobject_put on main kobj\\n\");",
          "431:   kobject_put(edac_pci_top_main_kobj);",
          "432:  }",
          "434: }",
          "",
          "[Removed Lines]",
          "433:  edac_put_sysfs_subsys();",
          "",
          "[Added Lines]",
          "432:   edac_put_sysfs_subsys();",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "154b454edaf6d94a69016db6c342c57fa935bbe9",
      "candidate_info": {
        "commit_hash": "154b454edaf6d94a69016db6c342c57fa935bbe9",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/154b454edaf6d94a69016db6c342c57fa935bbe9",
        "files": [
          "mm/memcontrol.c"
        ],
        "message": "memcg: don't register hotcpu notifier from ->css_alloc()\n\nCommit 648bb56d076b (\"cgroup: lock cgroup_mutex in cgroup_init_subsys()\")\nmade cgroup_init_subsys() grab cgroup_mutex before invoking\n->css_alloc() for the root css.  Because memcg registers hotcpu notifier\nfrom ->css_alloc() for the root css, this introduced circular locking\ndependency between cgroup_mutex and cpu hotplug.\n\nFix it by moving hotcpu notifier registration to a subsys initcall.\n\n  ======================================================\n  [ INFO: possible circular locking dependency detected ]\n  3.7.0-rc4-work+ #42 Not tainted\n  -------------------------------------------------------\n  bash/645 is trying to acquire lock:\n   (cgroup_mutex){+.+.+.}, at: [<ffffffff8110c5b7>] cgroup_lock+0x17/0x20\n\n  but task is already holding lock:\n   (cpu_hotplug.lock){+.+.+.}, at: [<ffffffff8109300f>] cpu_hotplug_begin+0x2f/0x60\n\n  which lock already depends on the new lock.\n\n  the existing dependency chain (in reverse order) is:\n\n -> #1 (cpu_hotplug.lock){+.+.+.}:\n         lock_acquire+0x97/0x1e0\n         mutex_lock_nested+0x61/0x3b0\n         get_online_cpus+0x3c/0x60\n         rebuild_sched_domains_locked+0x1b/0x70\n         cpuset_write_resmask+0x298/0x2c0\n         cgroup_file_write+0x1ef/0x300\n         vfs_write+0xa8/0x160\n         sys_write+0x52/0xa0\n         system_call_fastpath+0x16/0x1b\n\n -> #0 (cgroup_mutex){+.+.+.}:\n         __lock_acquire+0x14ce/0x1d20\n         lock_acquire+0x97/0x1e0\n         mutex_lock_nested+0x61/0x3b0\n         cgroup_lock+0x17/0x20\n         cpuset_handle_hotplug+0x1b/0x560\n         cpuset_update_active_cpus+0xe/0x10\n         cpuset_cpu_inactive+0x47/0x50\n         notifier_call_chain+0x66/0x150\n         __raw_notifier_call_chain+0xe/0x10\n         __cpu_notify+0x20/0x40\n         _cpu_down+0x7e/0x2f0\n         cpu_down+0x36/0x50\n         store_online+0x5d/0xe0\n         dev_attr_store+0x18/0x30\n         sysfs_write_file+0xe0/0x150\n         vfs_write+0xa8/0x160\n         sys_write+0x52/0xa0\n         system_call_fastpath+0x16/0x1b\n  other info that might help us debug this:\n\n   Possible unsafe locking scenario:\n\n         CPU0                    CPU1\n         ----                    ----\n    lock(cpu_hotplug.lock);\n                                 lock(cgroup_mutex);\n                                 lock(cpu_hotplug.lock);\n    lock(cgroup_mutex);\n\n   *** DEADLOCK ***\n\n  5 locks held by bash/645:\n   #0:  (&buffer->mutex){+.+.+.}, at: [<ffffffff8123bab8>] sysfs_write_file+0x48/0x150\n   #1:  (s_active#42){.+.+.+}, at: [<ffffffff8123bb38>] sysfs_write_file+0xc8/0x150\n   #2:  (x86_cpu_hotplug_driver_mutex){+.+...}, at: [<ffffffff81079277>] cpu_hotplug_driver_lock+0x1\n+7/0x20\n   #3:  (cpu_add_remove_lock){+.+.+.}, at: [<ffffffff81093157>] cpu_maps_update_begin+0x17/0x20\n   #4:  (cpu_hotplug.lock){+.+.+.}, at: [<ffffffff8109300f>] cpu_hotplug_begin+0x2f/0x60\n\n  stack backtrace:\n  Pid: 645, comm: bash Not tainted 3.7.0-rc4-work+ #42\n  Call Trace:\n   print_circular_bug+0x28e/0x29f\n   __lock_acquire+0x14ce/0x1d20\n   lock_acquire+0x97/0x1e0\n   mutex_lock_nested+0x61/0x3b0\n   cgroup_lock+0x17/0x20\n   cpuset_handle_hotplug+0x1b/0x560\n   cpuset_update_active_cpus+0xe/0x10\n   cpuset_cpu_inactive+0x47/0x50\n   notifier_call_chain+0x66/0x150\n   __raw_notifier_call_chain+0xe/0x10\n   __cpu_notify+0x20/0x40\n   _cpu_down+0x7e/0x2f0\n   cpu_down+0x36/0x50\n   store_online+0x5d/0xe0\n   dev_attr_store+0x18/0x30\n   sysfs_write_file+0xe0/0x150\n   vfs_write+0xa8/0x160\n   sys_write+0x52/0xa0\n   system_call_fastpath+0x16/0x1b\n\nSigned-off-by: Tejun Heo <tj@kernel.org>\nReported-by: Fengguang Wu <fengguang.wu@intel.com>\nAcked-by: Michal Hocko <mhocko@suse.cz>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
        "before_after_code_files": [
          "mm/memcontrol.c||mm/memcontrol.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "mm/memcontrol.c||mm/memcontrol.c": [
          "File: mm/memcontrol.c -> mm/memcontrol.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "6090:       &per_cpu(memcg_stock, cpu);",
          "6091:    INIT_WORK(&stock->work, drain_local_stock);",
          "6092:   }",
          "6094:  } else {",
          "6095:   parent = mem_cgroup_from_cont(cont->parent);",
          "6096:   memcg->use_hierarchy = parent->use_hierarchy;",
          "",
          "[Removed Lines]",
          "6093:   hotcpu_notifier(memcg_cpu_hotplug_callback, 0);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "6756:  .use_id = 1,",
          "6757: };",
          "6759: #ifdef CONFIG_MEMCG_SWAP",
          "6760: static int __init enable_swap_account(char *s)",
          "6761: {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "6764: static int __init mem_cgroup_init(void)",
          "6765: {",
          "6766:  hotcpu_notifier(memcg_cpu_hotplug_callback, 0);",
          "6767:  return 0;",
          "6768: }",
          "6769: subsys_initcall(mem_cgroup_init);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "8d76349d359064859217dc292dc8733e209705af",
      "candidate_info": {
        "commit_hash": "8d76349d359064859217dc292dc8733e209705af",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/8d76349d359064859217dc292dc8733e209705af",
        "files": [
          "fs/fscache/internal.h",
          "fs/fscache/object.c",
          "fs/fscache/operation.c"
        ],
        "message": "FS-Cache: Exclusive op submission can BUG if there's been an I/O error\n\nThe function to submit an exclusive op (fscache_submit_exclusive_op()) can BUG\nif there's been an I/O error because it may see the parent cache object in an\nunexpected state.  It should only BUG if there hasn't been an I/O error.\n\nIn this case the problem was produced by remounting the cache partition to be\nR/O.  The EROFS state was detected and the cache was aborted, but not\neverything handled the aborting correctly.\n\nSysRq : Emergency Remount R/O\nEXT4-fs (sda6): re-mounted. Opts: (null)\nEmergency Remount complete\nCacheFiles: I/O Error: Failed to update xattr with error -30\nFS-Cache: Cache cachefiles stopped due to I/O error\n------------[ cut here ]------------\nkernel BUG at fs/fscache/operation.c:128!\ninvalid opcode: 0000 [#1] SMP \nCPU 0 \nModules linked in: cachefiles nfs fscache auth_rpcgss nfs_acl lockd sunrpc\n\nPid: 6612, comm: kworker/u:2 Not tainted 3.1.0-rc8-fsdevel+ #1093                  /DG965RY\nRIP: 0010:[<ffffffffa00739c0>]  [<ffffffffa00739c0>] fscache_submit_exclusive_op+0x2ad/0x2c2 [fscache]\nRSP: 0018:ffff880000853d40  EFLAGS: 00010206\nRAX: ffff880038ac72a8 RBX: ffff8800181f2260 RCX: ffffffff81f2b2b0\nRDX: 0000000000000001 RSI: ffffffff8179a478 RDI: ffff8800181f2280\nRBP: ffff880000853d60 R08: 0000000000000002 R09: 0000000000000000\nR10: 0000000000000001 R11: 0000000000000001 R12: ffff880038ac7268\nR13: ffff8800181f2280 R14: ffff88003a359190 R15: 000000010122b162\nFS:  0000000000000000(0000) GS:ffff88003bc00000(0000) knlGS:0000000000000000\nCS:  0010 DS: 0000 ES: 0000 CR0: 000000008005003b\nCR2: 00000034cc4a77f0 CR3: 0000000010e96000 CR4: 00000000000006f0\nDR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\nDR3: 0000000000000000 DR6: 00000000ffff0ff0 DR7: 0000000000000400\nProcess kworker/u:2 (pid: 6612, threadinfo ffff880000852000, task ffff880014c3c040)\nStack:\n ffff8800181f2260 ffff8800181f2310 ffff880038ac7268 ffff8800181f2260\n ffff880000853dc0 ffffffffa0072375 ffff880037ecfe00 ffff88003a359198\n ffff880000853dc0 0000000000000246 0000000000000000 ffff88000a91d308\nCall Trace:\n [<ffffffffa0072375>] fscache_object_work_func+0x792/0xe65 [fscache]\n [<ffffffff81047e44>] process_one_work+0x1eb/0x37f\n [<ffffffff81047de6>] ? process_one_work+0x18d/0x37f\n [<ffffffffa0071be3>] ? fscache_enqueue_dependents+0xd8/0xd8 [fscache]\n [<ffffffff810482e4>] worker_thread+0x15a/0x21a\n [<ffffffff8104818a>] ? rescuer_thread+0x188/0x188\n [<ffffffff8104bf96>] kthread+0x7f/0x87\n [<ffffffff813ad6f4>] kernel_thread_helper+0x4/0x10\n [<ffffffff81026b98>] ? finish_task_switch+0x45/0xc0\n [<ffffffff813abd1d>] ? retint_restore_args+0xe/0xe\n [<ffffffff8104bf17>] ? __init_kthread_worker+0x53/0x53\n [<ffffffff813ad6f0>] ? gs_change+0xb/0xb\n\n\nSigned-off-by: David Howells <dhowells@redhat.com>",
        "before_after_code_files": [
          "fs/fscache/internal.h||fs/fscache/internal.h",
          "fs/fscache/object.c||fs/fscache/object.c",
          "fs/fscache/operation.c||fs/fscache/operation.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "fs/fscache/internal.h||fs/fscache/internal.h": [
          "File: fs/fscache/internal.h -> fs/fscache/internal.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "288: static inline void fscache_raise_event(struct fscache_object *object,",
          "289:            unsigned event)",
          "290: {",
          "291:  if (!test_and_set_bit(event, &object->events) &&",
          "292:      test_bit(event, &object->event_mask))",
          "293:   fscache_enqueue_object(object);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "291:  BUG_ON(event >= NR_FSCACHE_OBJECT_EVENTS);",
          "",
          "---------------"
        ],
        "fs/fscache/object.c||fs/fscache/object.c": [
          "File: fs/fscache/object.c -> fs/fscache/object.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "103: {",
          "104:  enum fscache_object_state new_state;",
          "105:  struct fscache_cookie *cookie;",
          "107:  ASSERT(object != NULL);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "106:  int event;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "277: lookup_transit:",
          "279:  case FSCACHE_OBJECT_EV_WITHDRAW:",
          "280:  case FSCACHE_OBJECT_EV_RETIRE:",
          "281:  case FSCACHE_OBJECT_EV_RELEASE:",
          "",
          "[Removed Lines]",
          "278:  switch (fls(object->events & object->event_mask) - 1) {",
          "",
          "[Added Lines]",
          "279:  event = fls(object->events & object->event_mask) - 1;",
          "280:  switch (event) {",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "294: active_transit:",
          "296:  case FSCACHE_OBJECT_EV_WITHDRAW:",
          "297:  case FSCACHE_OBJECT_EV_RETIRE:",
          "298:  case FSCACHE_OBJECT_EV_RELEASE:",
          "",
          "[Removed Lines]",
          "295:  switch (fls(object->events & object->event_mask) - 1) {",
          "",
          "[Added Lines]",
          "297:  event = fls(object->events & object->event_mask) - 1;",
          "298:  switch (event) {",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "316: terminal_transit:",
          "318:  case FSCACHE_OBJECT_EV_WITHDRAW:",
          "319:   new_state = FSCACHE_OBJECT_WITHDRAWING;",
          "320:   goto change_state;",
          "",
          "[Removed Lines]",
          "317:  switch (fls(object->events & object->event_mask) - 1) {",
          "",
          "[Added Lines]",
          "320:  event = fls(object->events & object->event_mask) - 1;",
          "321:  switch (event) {",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "348: unsupported_event:",
          "349:  printk(KERN_ERR \"FS-Cache:\"",
          "352:         fscache_object_states[object->state]);",
          "353:  BUG();",
          "354: }",
          "",
          "[Removed Lines]",
          "350:         \" Unsupported event %lx [mask %lx] in state %s\\n\",",
          "351:         object->events, object->event_mask,",
          "",
          "[Added Lines]",
          "354:         \" Unsupported event %d [%lx/%lx] in state %s\\n\",",
          "355:         event, object->events, object->event_mask,",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "946:  spin_lock(&cookie->lock);",
          "947:  if (fscache_submit_exclusive_op(object, op) < 0)",
          "949:  spin_unlock(&cookie->lock);",
          "950:  fscache_put_operation(op);",
          "",
          "[Removed Lines]",
          "948:   BUG();",
          "",
          "[Added Lines]",
          "952:   goto submit_op_failed;",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "961:  fscache_invalidation_complete(cookie);",
          "962:  _leave(\"\");",
          "963: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "967:  return;",
          "969: submit_op_failed:",
          "970:  spin_unlock(&cookie->lock);",
          "971:  kfree(op);",
          "972:  fscache_raise_event(object, FSCACHE_OBJECT_EV_ERROR);",
          "973:  _leave(\" [EIO]\");",
          "",
          "---------------"
        ],
        "fs/fscache/operation.c||fs/fscache/operation.c": [
          "File: fs/fscache/operation.c -> fs/fscache/operation.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "84: int fscache_submit_exclusive_op(struct fscache_object *object,",
          "85:     struct fscache_operation *op)",
          "86: {",
          "87:  _enter(\"{OBJ%x OP%x},\", object->debug_id, op->debug_id);",
          "89:  ASSERTCMP(op->state, ==, FSCACHE_OP_ST_INITIALISED);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "87:  int ret;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "118:   clear_bit(FSCACHE_OBJECT_PENDING_WRITE, &object->flags);",
          "119:  } else if (object->state == FSCACHE_OBJECT_CREATING) {",
          "120:   op->object = object;",
          "121:   object->n_ops++;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "121:   ret = 0;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "123:   atomic_inc(&op->usage);",
          "124:   list_add_tail(&op->pend_link, &object->pending_ops);",
          "125:   fscache_stat(&fscache_n_op_pend);",
          "126:  } else {",
          "129:  }",
          "131:  spin_unlock(&object->lock);",
          "133: }",
          "",
          "[Removed Lines]",
          "128:   BUG();",
          "132:  return 0;",
          "",
          "[Added Lines]",
          "129:   ret = 0;",
          "134:   ASSERT(test_bit(FSCACHE_IOERROR, &object->cache->flags));",
          "135:   ret = -EIO;",
          "139:  return ret;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "8c209ce721444a61b61d9e772746c721e4d8d1e8",
      "candidate_info": {
        "commit_hash": "8c209ce721444a61b61d9e772746c721e4d8d1e8",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/8c209ce721444a61b61d9e772746c721e4d8d1e8",
        "files": [
          "fs/fscache/internal.h",
          "fs/fscache/page.c",
          "fs/fscache/stats.c",
          "fs/nfs/write.c"
        ],
        "message": "NFS: nfs_migrate_page() does not wait for FS-Cache to finish with a page\n\nnfs_migrate_page() does not wait for FS-Cache to finish with a page, probably\nleading to the following bad-page-state:\n\n BUG: Bad page state in process python-bin  pfn:17d39b\n page:ffffea00053649e8 flags:004000000000100c count:0 mapcount:0 mapping:(null)\nindex:38686 (Tainted: G    B      ---------------- )\n Pid: 31053, comm: python-bin Tainted: G    B      ----------------\n2.6.32-71.24.1.el6.x86_64 #1\n Call Trace:\n [<ffffffff8111bfe7>] bad_page+0x107/0x160\n [<ffffffff8111ee69>] free_hot_cold_page+0x1c9/0x220\n [<ffffffff8111ef19>] __pagevec_free+0x59/0xb0\n [<ffffffff8104b988>] ? flush_tlb_others_ipi+0x128/0x130\n [<ffffffff8112230c>] release_pages+0x21c/0x250\n [<ffffffff8115b92a>] ? remove_migration_pte+0x28a/0x2b0\n [<ffffffff8115f3f8>] ? mem_cgroup_get_reclaim_stat_from_page+0x18/0x70\n [<ffffffff81122687>] ____pagevec_lru_add+0x167/0x180\n [<ffffffff811226f8>] __lru_cache_add+0x58/0x70\n [<ffffffff81122731>] lru_cache_add_lru+0x21/0x40\n [<ffffffff81123f49>] putback_lru_page+0x69/0x100\n [<ffffffff8115c0bd>] migrate_pages+0x13d/0x5d0\n [<ffffffff81122687>] ? ____pagevec_lru_add+0x167/0x180\n [<ffffffff81152ab0>] ? compaction_alloc+0x0/0x370\n [<ffffffff8115255c>] compact_zone+0x4cc/0x600\n [<ffffffff8111cfac>] ? get_page_from_freelist+0x15c/0x820\n [<ffffffff810672f4>] ? check_preempt_wakeup+0x1c4/0x3c0\n [<ffffffff8115290e>] compact_zone_order+0x7e/0xb0\n [<ffffffff81152a49>] try_to_compact_pages+0x109/0x170\n [<ffffffff8111e94d>] __alloc_pages_nodemask+0x5ed/0x850\n [<ffffffff814c9136>] ? thread_return+0x4e/0x778\n [<ffffffff81150d43>] alloc_pages_vma+0x93/0x150\n [<ffffffff81167ea5>] do_huge_pmd_anonymous_page+0x135/0x340\n [<ffffffff814cb6f6>] ? rwsem_down_read_failed+0x26/0x30\n [<ffffffff81136755>] handle_mm_fault+0x245/0x2b0\n [<ffffffff814ce383>] do_page_fault+0x123/0x3a0\n [<ffffffff814cbdf5>] page_fault+0x25/0x30\n\nnfs_migrate_page() calls nfs_fscache_release_page() which doesn't actually wait\n- even if __GFP_WAIT is set.  The reason that doesn't wait is that\nfscache_maybe_release_page() might deadlock the allocator as the work threads\nwriting to the cache may all end up sleeping on memory allocation.\n\nHowever, I wonder if that is actually a problem.  There are a number of things\nI can do to deal with this:\n\n (1) Make nfs_migrate_page() wait.\n\n (2) Make fscache_maybe_release_page() honour the __GFP_WAIT flag.\n\n (3) Set a timeout around the wait.\n\n (4) Make nfs_migrate_page() return an error if the page is still busy.\n\nFor the moment, I'll select (2) and (4).\n\nSigned-off-by: David Howells <dhowells@redhat.com>\nAcked-by: Jeff Layton <jlayton@redhat.com>",
        "before_after_code_files": [
          "fs/fscache/internal.h||fs/fscache/internal.h",
          "fs/fscache/page.c||fs/fscache/page.c",
          "fs/fscache/stats.c||fs/fscache/stats.c",
          "fs/nfs/write.c||fs/nfs/write.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "fs/fscache/internal.h||fs/fscache/internal.h": [
          "File: fs/fscache/internal.h -> fs/fscache/internal.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "200: extern atomic_t fscache_n_store_vmscan_gone;",
          "201: extern atomic_t fscache_n_store_vmscan_busy;",
          "202: extern atomic_t fscache_n_store_vmscan_cancelled;",
          "204: extern atomic_t fscache_n_marks;",
          "205: extern atomic_t fscache_n_uncaches;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "203: extern atomic_t fscache_n_store_vmscan_wait;",
          "",
          "---------------"
        ],
        "fs/fscache/page.c||fs/fscache/page.c": [
          "File: fs/fscache/page.c -> fs/fscache/page.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "57:  _enter(\"%p,%p,%x\", cookie, page, gfp);",
          "59:  rcu_read_lock();",
          "60:  val = radix_tree_lookup(&cookie->stores, page->index);",
          "61:  if (!val) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "59: try_again:",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "104:  return true;",
          "106: page_busy:",
          "112: }",
          "113: EXPORT_SYMBOL(__fscache_maybe_release_page);",
          "",
          "[Removed Lines]",
          "110:  fscache_stat(&fscache_n_store_vmscan_busy);",
          "111:  return false;",
          "",
          "[Added Lines]",
          "112:  if (!(gfp & __GFP_WAIT)) {",
          "113:   fscache_stat(&fscache_n_store_vmscan_busy);",
          "114:   return false;",
          "115:  }",
          "117:  fscache_stat(&fscache_n_store_vmscan_wait);",
          "118:  __fscache_wait_on_page_write(cookie, page);",
          "119:  gfp &= ~__GFP_WAIT;",
          "120:  goto try_again;",
          "",
          "---------------"
        ],
        "fs/fscache/stats.c||fs/fscache/stats.c": [
          "File: fs/fscache/stats.c -> fs/fscache/stats.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "69: atomic_t fscache_n_store_vmscan_gone;",
          "70: atomic_t fscache_n_store_vmscan_busy;",
          "71: atomic_t fscache_n_store_vmscan_cancelled;",
          "73: atomic_t fscache_n_marks;",
          "74: atomic_t fscache_n_uncaches;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "72: atomic_t fscache_n_store_vmscan_wait;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "232:      atomic_read(&fscache_n_store_radix_deletes),",
          "233:      atomic_read(&fscache_n_store_pages_over_limit));",
          "236:      atomic_read(&fscache_n_store_vmscan_not_storing),",
          "237:      atomic_read(&fscache_n_store_vmscan_gone),",
          "238:      atomic_read(&fscache_n_store_vmscan_busy),",
          "241:  seq_printf(m, \"Ops    : pend=%u run=%u enq=%u can=%u rej=%u\\n\",",
          "242:      atomic_read(&fscache_n_op_pend),",
          "",
          "[Removed Lines]",
          "235:  seq_printf(m, \"VmScan : nos=%u gon=%u bsy=%u can=%u\\n\",",
          "239:      atomic_read(&fscache_n_store_vmscan_cancelled));",
          "",
          "[Added Lines]",
          "236:  seq_printf(m, \"VmScan : nos=%u gon=%u bsy=%u can=%u wt=%u\\n\",",
          "240:      atomic_read(&fscache_n_store_vmscan_cancelled),",
          "241:      atomic_read(&fscache_n_store_vmscan_wait));",
          "",
          "---------------"
        ],
        "fs/nfs/write.c||fs/nfs/write.c": [
          "File: fs/nfs/write.c -> fs/nfs/write.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1794:  if (PagePrivate(page))",
          "1795:   return -EBUSY;",
          "1799:  return migrate_page(mapping, newpage, page, mode);",
          "1800: }",
          "",
          "[Removed Lines]",
          "1797:  nfs_fscache_release_page(page, GFP_KERNEL);",
          "",
          "[Added Lines]",
          "1797:  if (!nfs_fscache_release_page(page, GFP_KERNEL))",
          "1798:   return -EBUSY;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "9c04caa81b876faee5f1cc6eaad76dd7021ab8ff",
      "candidate_info": {
        "commit_hash": "9c04caa81b876faee5f1cc6eaad76dd7021ab8ff",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/9c04caa81b876faee5f1cc6eaad76dd7021ab8ff",
        "files": [
          "fs/fscache/page.c"
        ],
        "message": "FS-Cache: Fix signal handling during waits\n\nwait_on_bit() with TASK_INTERRUPTIBLE returns 1 rather than a negative error\ncode, so change what we check for.  This means that the signal handling in\nfscache_wait_for_retrieval_activation()  should now work properly.\n\nWithout this, the following bug can be seen if CTRL-C is pressed during\nfscache read operation:\n\nFS-Cache: Assertion failed\n2 == 3 is false\n------------[ cut here ]------------\nkernel BUG at fs/fscache/page.c:347!\ninvalid opcode: 0000 [#1] SMP\nModules linked in: cachefiles(F) nfsv4(F) nfsv3(F) nfsv2(F) nfs(F) fscache(F) auth_rpcgss(F) nfs_acl(F) lockd(F) sunrpc(F)\nCPU 1\nPid: 15006, comm: slurp-q Tainted: GF            3.7.0-rc8-fsdevel+ #411                  /DG965RY\nRIP: 0010:[<ffffffffa007fcb4>]  [<ffffffffa007fcb4>] fscache_wait_for_retrieval_activation+0x167/0x177 [fscache]\nRSP: 0018:ffff88002a4c39a8  EFLAGS: 00010292\nRAX: 000000000000001a RBX: ffff88002d3dc158 RCX: 0000000000008685\nRDX: ffffffff8102ccd6 RSI: 0000000000000001 RDI: ffffffff8102d1d6\nRBP: ffff88002a4c39c8 R08: 0000000000000002 R09: 0000000000000000\nR10: ffffffff8163afa0 R11: ffff88003bd11900 R12: ffffffffa00868c8\nR13: ffff880028306458 R14: ffff88002d3dc1b0 R15: ffff88001372e538\nFS:  00007f17426a0700(0000) GS:ffff88003bd00000(0000) knlGS:0000000000000000\nCS:  0010 DS: 0000 ES: 0000 CR0: 000000008005003b\nCR2: 00007f1742494a44 CR3: 0000000031bd7000 CR4: 00000000000007e0\nDR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\nDR3: 0000000000000000 DR6: 00000000ffff0ff0 DR7: 0000000000000400\nProcess slurp-q (pid: 15006, threadinfo ffff88002a4c2000, task ffff880023de3040)\nStack:\n ffff88002d3dc158 ffff88001372e538 ffff88002a4c3ab4 ffff8800283064e0\n ffff88002a4c3a38 ffffffffa0080f6d 0000000000000000 ffff880023de3040\n ffff88002a4c3ac8 ffffffff810ac8ae ffff880028306458 ffff88002a4c3bc8\nCall Trace:\n [<ffffffffa0080f6d>] __fscache_read_or_alloc_pages+0x24f/0x4bc [fscache]\n [<ffffffff810ac8ae>] ? __alloc_pages_nodemask+0x195/0x75c\n [<ffffffffa00aab0f>] __nfs_readpages_from_fscache+0x86/0x13d [nfs]\n [<ffffffffa00a5fe0>] nfs_readpages+0x186/0x1bd [nfs]\n [<ffffffff810d23c8>] ? alloc_pages_current+0xc7/0xe4\n [<ffffffff810a68b5>] ? __page_cache_alloc+0x84/0x91\n [<ffffffff810af912>] ? __do_page_cache_readahead+0xa6/0x2e0\n [<ffffffff810afaa3>] __do_page_cache_readahead+0x237/0x2e0\n [<ffffffff810af912>] ? __do_page_cache_readahead+0xa6/0x2e0\n [<ffffffff810afe3e>] ra_submit+0x1c/0x20\n [<ffffffff810b019b>] ondemand_readahead+0x359/0x382\n [<ffffffff810b0279>] page_cache_sync_readahead+0x38/0x3a\n [<ffffffff810a77b5>] generic_file_aio_read+0x26b/0x637\n [<ffffffffa00f1852>] ? nfs_mark_delegation_referenced+0xb/0xb [nfsv4]\n [<ffffffffa009cc85>] nfs_file_read+0xaa/0xcf [nfs]\n [<ffffffff810db5b3>] do_sync_read+0x91/0xd1\n [<ffffffff810dbb8b>] vfs_read+0x9b/0x144\n [<ffffffff810dbc78>] sys_read+0x44/0x75\n [<ffffffff81422892>] system_call_fastpath+0x16/0x1b\n\nSigned-off-by: David Howells <dhowells@redhat.com>",
        "before_after_code_files": [
          "fs/fscache/page.c||fs/fscache/page.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "fs/fscache/page.c||fs/fscache/page.c": [
          "File: fs/fscache/page.c -> fs/fscache/page.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "319:  fscache_stat(stat_op_waits);",
          "320:  if (wait_on_bit(&op->op.flags, FSCACHE_OP_WAITING,",
          "321:    fscache_wait_bit_interruptible,",
          "323:   ret = fscache_cancel_op(&op->op);",
          "324:   if (ret == 0)",
          "325:    return -ERESTARTSYS;",
          "",
          "[Removed Lines]",
          "322:    TASK_INTERRUPTIBLE) < 0) {",
          "",
          "[Added Lines]",
          "322:    TASK_INTERRUPTIBLE) != 0) {",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2015-8746",
  "cve_desc": "fs/nfs/nfs4proc.c in the NFS client in the Linux kernel before 4.2.2 does not properly initialize memory for migration recovery operations, which allows remote NFS servers to cause a denial of service (NULL pointer dereference and panic) via crafted network traffic.",
  "repo": "torvalds/linux",
  "patch_hash": "18e3b739fdc826481c6a1335ce0c5b19b3d415da",
  "patch_info": {
    "commit_hash": "18e3b739fdc826481c6a1335ce0c5b19b3d415da",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/18e3b739fdc826481c6a1335ce0c5b19b3d415da",
    "files": [
      "fs/nfs/nfs4proc.c"
    ],
    "message": "NFS: Fix a NULL pointer dereference of migration recovery ops for v4.2 client\n\n---Steps to Reproduce--\n<nfs-server>\n# cat /etc/exports\n/nfs/referal  *(rw,insecure,no_subtree_check,no_root_squash,crossmnt)\n/nfs/old      *(ro,insecure,subtree_check,root_squash,crossmnt)\n\n<nfs-client>\n# mount -t nfs nfs-server:/nfs/ /mnt/\n# ll /mnt/*/\n\n<nfs-server>\n# cat /etc/exports\n/nfs/referal   *(rw,insecure,no_subtree_check,no_root_squash,crossmnt,refer=/nfs/old/@nfs-server)\n/nfs/old       *(ro,insecure,subtree_check,root_squash,crossmnt)\n# service nfs restart\n\n<nfs-client>\n# ll /mnt/*/    --->>>>> oops here\n\n[ 5123.102925] BUG: unable to handle kernel NULL pointer dereference at           (null)\n[ 5123.103363] IP: [<ffffffffa03ed38b>] nfs4_proc_get_locations+0x9b/0x120 [nfsv4]\n[ 5123.103752] PGD 587b9067 PUD 3cbf5067 PMD 0\n[ 5123.104131] Oops: 0000 [#1]\n[ 5123.104529] Modules linked in: nfsv4(OE) nfs(OE) fscache(E) nfsd(OE) xfs libcrc32c iscsi_tcp libiscsi_tcp libiscsi scsi_transport_iscsi coretemp crct10dif_pclmul crc32_pclmul crc32c_intel ghash_clmulni_intel ppdev vmw_balloon parport_pc parport i2c_piix4 shpchp auth_rpcgss nfs_acl vmw_vmci lockd grace sunrpc vmwgfx drm_kms_helper ttm drm mptspi serio_raw scsi_transport_spi e1000 mptscsih mptbase ata_generic pata_acpi [last unloaded: nfsd]\n[ 5123.105887] CPU: 0 PID: 15853 Comm: ::1-manager Tainted: G           OE   4.2.0-rc6+ #214\n[ 5123.106358] Hardware name: VMware, Inc. VMware Virtual Platform/440BX Desktop Reference Platform, BIOS 6.00 05/20/2014\n[ 5123.106860] task: ffff88007620f300 ti: ffff88005877c000 task.ti: ffff88005877c000\n[ 5123.107363] RIP: 0010:[<ffffffffa03ed38b>]  [<ffffffffa03ed38b>] nfs4_proc_get_locations+0x9b/0x120 [nfsv4]\n[ 5123.107909] RSP: 0018:ffff88005877fdb8  EFLAGS: 00010246\n[ 5123.108435] RAX: ffff880053f3bc00 RBX: ffff88006ce6c908 RCX: ffff880053a0d240\n[ 5123.108968] RDX: ffffea0000e6d940 RSI: ffff8800399a0000 RDI: ffff88006ce6c908\n[ 5123.109503] RBP: ffff88005877fe28 R08: ffffffff81c708a0 R09: 0000000000000000\n[ 5123.110045] R10: 00000000000001a2 R11: ffff88003ba7f5c8 R12: ffff880054c55800\n[ 5123.110618] R13: 0000000000000000 R14: ffff880053a0d240 R15: ffff880053a0d240\n[ 5123.111169] FS:  0000000000000000(0000) GS:ffffffff81c27000(0000) knlGS:0000000000000000\n[ 5123.111726] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n[ 5123.112286] CR2: 0000000000000000 CR3: 0000000054cac000 CR4: 00000000001406f0\n[ 5123.112888] Stack:\n[ 5123.113458]  ffffea0000e6d940 ffff8800399a0000 00000000000167d0 0000000000000000\n[ 5123.114049]  0000000000000000 0000000000000000 0000000000000000 00000000a7ec82c6\n[ 5123.114662]  ffff88005877fe18 ffffea0000e6d940 ffff8800399a0000 ffff880054c55800\n[ 5123.115264] Call Trace:\n[ 5123.115868]  [<ffffffffa03fb44b>] nfs4_try_migration+0xbb/0x220 [nfsv4]\n[ 5123.116487]  [<ffffffffa03fcb3b>] nfs4_run_state_manager+0x4ab/0x7b0 [nfsv4]\n[ 5123.117104]  [<ffffffffa03fc690>] ? nfs4_do_reclaim+0x510/0x510 [nfsv4]\n[ 5123.117813]  [<ffffffff810a4527>] kthread+0xd7/0xf0\n[ 5123.118456]  [<ffffffff810a4450>] ? kthread_worker_fn+0x160/0x160\n[ 5123.119108]  [<ffffffff816d9cdf>] ret_from_fork+0x3f/0x70\n[ 5123.119723]  [<ffffffff810a4450>] ? kthread_worker_fn+0x160/0x160\n[ 5123.120329] Code: 4c 8b 6a 58 74 17 eb 52 48 8d 55 a8 89 c6 4c 89 e7 e8 4a b5 ff ff 8b 45 b0 85 c0 74 1c 4c 89 f9 48 8b 55 90 48 8b 75 98 48 89 df <41> ff 55 00 3d e8 d8 ff ff 41 89 c6 74 cf 48 8b 4d c8 65 48 33\n[ 5123.121643] RIP  [<ffffffffa03ed38b>] nfs4_proc_get_locations+0x9b/0x120 [nfsv4]\n[ 5123.122308]  RSP <ffff88005877fdb8>\n[ 5123.122942] CR2: 0000000000000000\n\nFixes: ec011fe847 (\"NFS: Introduce a vector of migration recovery ops\")\nCc: stable@vger.kernel.org # v3.13+\nSigned-off-by: Kinglong Mee <kinglongmee@gmail.com>\nSigned-off-by: Trond Myklebust <trond.myklebust@primarydata.com>",
    "before_after_code_files": [
      "fs/nfs/nfs4proc.c||fs/nfs/nfs4proc.c"
    ]
  },
  "patch_diff": {
    "fs/nfs/nfs4proc.c||fs/nfs/nfs4proc.c": [
      "File: fs/nfs/nfs4proc.c -> fs/nfs/nfs4proc.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "8661:  .reboot_recovery_ops = &nfs41_reboot_recovery_ops,",
      "8662:  .nograce_recovery_ops = &nfs41_nograce_recovery_ops,",
      "8663:  .state_renewal_ops = &nfs41_state_renewal_ops,",
      "8664: };",
      "8665: #endif",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "8664:  .mig_recovery_ops = &nfs41_mig_recovery_ops,",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "18041e31743d278b6323518d20a2ef656c3cc689",
      "candidate_info": {
        "commit_hash": "18041e31743d278b6323518d20a2ef656c3cc689",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/18041e31743d278b6323518d20a2ef656c3cc689",
        "files": [
          "include/net/vrf.h",
          "net/ipv4/icmp.c"
        ],
        "message": "vrf: vrf_master_ifindex_rcu is not always called with rcu read lock\n\nWhile running net-next I hit this:\n[  634.073119] ===============================\n[  634.073150] [ INFO: suspicious RCU usage. ]\n[  634.073182] 4.2.0-rc6+ #45 Not tainted\n[  634.073213] -------------------------------\n[  634.073244] include/net/vrf.h:38 suspicious rcu_dereference_check()\nusage!\n[  634.073274]\n               other info that might help us debug this:\n\n[  634.073307]\n               rcu_scheduler_active = 1, debug_locks = 1\n[  634.073338] 2 locks held by swapper/0/0:\n[  634.073369]  #0:  (((&n->timer))){+.-...}, at: [<ffffffff8112bc35>]\ncall_timer_fn+0x5/0x480\n[  634.073412]  #1:  (slock-AF_INET){+.-...}, at: [<ffffffff8174f0f5>]\nicmp_send+0x155/0x5f0\n[  634.073450]\n               stack backtrace:\n[  634.073483] CPU: 0 PID: 0 Comm: swapper/0 Not tainted 4.2.0-rc6+ #45\n[  634.073514] Hardware name: innotek GmbH VirtualBox/VirtualBox, BIOS\nVirtualBox 12/01/2006\n[  634.073545]  0000000000000000 0593ba8242d9ace4 ffff88002fc03b48\nffffffff81803f1b\n[  634.073612]  0000000000000000 ffffffff81e12500 ffff88002fc03b78\nffffffff811003c5\n[  634.073642]  0000000000000000 ffff88002ec4e600 ffffffff81f00f80\nffff88002fc03cf0\n[  634.073669] Call Trace:\n[  634.073694]  <IRQ>  [<ffffffff81803f1b>] dump_stack+0x4c/0x65\n[  634.073728]  [<ffffffff811003c5>] lockdep_rcu_suspicious+0xc5/0x100\n[  634.073763]  [<ffffffff8174eb56>] icmp_route_lookup+0x176/0x5c0\n[  634.073793]  [<ffffffff8174f2fb>] ? icmp_send+0x35b/0x5f0\n[  634.073818]  [<ffffffff8174f274>] ? icmp_send+0x2d4/0x5f0\n[  634.073844]  [<ffffffff8174f3ce>] icmp_send+0x42e/0x5f0\n[  634.073873]  [<ffffffff8170b662>] ipv4_link_failure+0x22/0xa0\n[  634.073899]  [<ffffffff8174bdda>] arp_error_report+0x3a/0x80\n[  634.073926]  [<ffffffff816d6100>] ? neigh_lookup+0x2c0/0x2c0\n[  634.073952]  [<ffffffff816d396e>] neigh_invalidate+0x8e/0x110\n[  634.073984]  [<ffffffff816d62ae>] neigh_timer_handler+0x1ae/0x290\n[  634.074013]  [<ffffffff816d6100>] ? neigh_lookup+0x2c0/0x2c0\n[  634.074013]  [<ffffffff8112bce3>] call_timer_fn+0xb3/0x480\n[  634.074013]  [<ffffffff8112bc35>] ? call_timer_fn+0x5/0x480\n[  634.074013]  [<ffffffff816d6100>] ? neigh_lookup+0x2c0/0x2c0\n[  634.074013]  [<ffffffff8112c2bc>] run_timer_softirq+0x20c/0x430\n[  634.074013]  [<ffffffff810af50e>] __do_softirq+0xde/0x630\n[  634.074013]  [<ffffffff810afc97>] irq_exit+0x117/0x120\n[  634.074013]  [<ffffffff81810976>] smp_apic_timer_interrupt+0x46/0x60\n[  634.074013]  [<ffffffff8180e950>] apic_timer_interrupt+0x70/0x80\n[  634.074013]  <EOI>  [<ffffffff8106b9d6>] ? native_safe_halt+0x6/0x10\n[  634.074013]  [<ffffffff81101d8d>] ? trace_hardirqs_on+0xd/0x10\n[  634.074013]  [<ffffffff81027d43>] default_idle+0x23/0x200\n[  634.074013]  [<ffffffff8102852f>] arch_cpu_idle+0xf/0x20\n[  634.074013]  [<ffffffff810f89ba>] default_idle_call+0x2a/0x40\n[  634.074013]  [<ffffffff810f8dcc>] cpu_startup_entry+0x39c/0x4c0\n[  634.074013]  [<ffffffff817f9cad>] rest_init+0x13d/0x150\n[  634.074013]  [<ffffffff81f69038>] start_kernel+0x4a8/0x4c9\n[  634.074013]  [<ffffffff81f68120>] ?\nearly_idt_handler_array+0x120/0x120\n[  634.074013]  [<ffffffff81f68339>] x86_64_start_reservations+0x2a/0x2c\n[  634.074013]  [<ffffffff81f68485>] x86_64_start_kernel+0x14a/0x16d\n\nIt would seem vrf_master_ifindex_rcu() can be called without RCU held in\nother contexts as well so introduce a new helper which acquires rcu and\nreturns the ifindex.\nAlso add curly braces around both the \"if\" and \"else\" parts as per the\nstyle guide.\n\nSigned-off-by: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "before_after_code_files": [
          "include/net/vrf.h||include/net/vrf.h",
          "net/ipv4/icmp.c||net/ipv4/icmp.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "include/net/vrf.h||include/net/vrf.h": [
          "File: include/net/vrf.h -> include/net/vrf.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "43:  if (!dev)",
          "44:   return 0;",
          "47:   ifindex = dev->ifindex;",
          "49:   vrf_ptr = rcu_dereference(dev->vrf_ptr);",
          "50:   if (vrf_ptr)",
          "51:    ifindex = vrf_ptr->ifindex;",
          "",
          "[Removed Lines]",
          "46:  if (netif_is_vrf(dev))",
          "48:  else {",
          "",
          "[Added Lines]",
          "46:  if (netif_is_vrf(dev)) {",
          "48:  } else {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "54:  return ifindex;",
          "55: }",
          "58: static inline int vrf_dev_table_rcu(const struct net_device *dev)",
          "59: {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "57: static inline int vrf_master_ifindex(const struct net_device *dev)",
          "58: {",
          "59:  int ifindex;",
          "61:  rcu_read_lock();",
          "62:  ifindex = vrf_master_ifindex_rcu(dev);",
          "63:  rcu_read_unlock();",
          "65:  return ifindex;",
          "66: }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "133:  return 0;",
          "134: }",
          "136: static inline int vrf_dev_table_rcu(const struct net_device *dev)",
          "137: {",
          "138:  return 0;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "147: static inline int vrf_master_ifindex(const struct net_device *dev)",
          "148: {",
          "149:  return 0;",
          "150: }",
          "",
          "---------------"
        ],
        "net/ipv4/icmp.c||net/ipv4/icmp.c": [
          "File: net/ipv4/icmp.c -> net/ipv4/icmp.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "426:  fl4.flowi4_mark = mark;",
          "427:  fl4.flowi4_tos = RT_TOS(ip_hdr(skb)->tos);",
          "428:  fl4.flowi4_proto = IPPROTO_ICMP;",
          "430:  security_skb_classify_flow(skb, flowi4_to_flowi(&fl4));",
          "431:  rt = ip_route_output_key(net, &fl4);",
          "432:  if (IS_ERR(rt))",
          "",
          "[Removed Lines]",
          "429:  fl4.flowi4_oif = vrf_master_ifindex_rcu(skb->dev) ? : skb->dev->ifindex;",
          "",
          "[Added Lines]",
          "429:  fl4.flowi4_oif = vrf_master_ifindex(skb->dev) ? : skb->dev->ifindex;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "460:  fl4->flowi4_proto = IPPROTO_ICMP;",
          "461:  fl4->fl4_icmp_type = type;",
          "462:  fl4->fl4_icmp_code = code;",
          "465:  security_skb_classify_flow(skb_in, flowi4_to_flowi(fl4));",
          "466:  rt = __ip_route_output_key(net, fl4);",
          "",
          "[Removed Lines]",
          "463:  fl4->flowi4_oif = vrf_master_ifindex_rcu(skb_in->dev) ? : skb_in->dev->ifindex;",
          "",
          "[Added Lines]",
          "463:  fl4->flowi4_oif = vrf_master_ifindex(skb_in->dev) ? : skb_in->dev->ifindex;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "a0a8bcf4670c2c696e6e83742539a5e0dd7a62d6",
      "candidate_info": {
        "commit_hash": "a0a8bcf4670c2c696e6e83742539a5e0dd7a62d6",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/a0a8bcf4670c2c696e6e83742539a5e0dd7a62d6",
        "files": [
          "drivers/gpio/gpiolib.c",
          "include/linux/gpio/driver.h"
        ],
        "message": "gpiolib: irqchip: use different lockdep class for each gpio irqchip\n\nSince IRQ chip helpers were introduced drivers lose ability to\nregister separate lockdep classes for each registered GPIO IRQ\nchip and the gpiolib now is using shared lockdep class for\nall GPIO IRQ chips (gpiochip_irq_lock_class).\nAs result, lockdep will produce warning when there are min two\nstacked GPIO chips and all of them are interrupt controllers.\n\nHW configuration which generates lockdep warning (TI dra7-evm):\n\n[SOC GPIO bankA.gpioX]\n  <- irq - [pcf875x.gpioY]\n            <- irq - DevZ.enable_irq_wake(pcf_gpioY_irq);\nThe issue was reported in [1] and discussed [2].\n\n=============================================\n[ INFO: possible recursive locking detected ]\n4.2.0-rc6-00013-g5d050ed-dirty #55 Not tainted\n---------------------------------------------\nsh/63 is trying to acquire lock:\n (class){......}, at: [<c009b91c>] __irq_get_desc_lock+0x50/0x94\n\nbut task is already holding lock:\n (class){......}, at: [<c009b91c>] __irq_get_desc_lock+0x50/0x94\n\nother info that might help us debug this:\n Possible unsafe locking scenario:\n\n       CPU0\n       ----\n  lock(class);\n  lock(class);\n\n *** DEADLOCK ***\n\n May be due to missing lock nesting notation\n\n7 locks held by sh/63:\n #0:  (sb_writers#4){.+.+.+}, at: [<c016bbb8>] vfs_write+0x13c/0x164\n #1:  (&of->mutex){+.+.+.}, at: [<c01debf4>] kernfs_fop_write+0x4c/0x1a0\n #2:  (s_active#36){.+.+.+}, at: [<c01debfc>] kernfs_fop_write+0x54/0x1a0\n #3:  (pm_mutex){+.+.+.}, at: [<c009758c>] pm_suspend+0xec/0x4c4\n #4:  (&dev->mutex){......}, at: [<c03f77f8>] __device_suspend+0xd4/0x398\n #5:  (&gpio->lock){+.+.+.}, at: [<c009b940>] __irq_get_desc_lock+0x74/0x94\n #6:  (class){......}, at: [<c009b91c>] __irq_get_desc_lock+0x50/0x94\n\nstack backtrace:\nCPU: 0 PID: 63 Comm: sh Not tainted 4.2.0-rc6-00013-g5d050ed-dirty #55\nHardware name: Generic DRA74X (Flattened Device Tree)\n[<c0016e24>] (unwind_backtrace) from [<c0013338>] (show_stack+0x10/0x14)\n[<c0013338>] (show_stack) from [<c05f6b24>] (dump_stack+0x84/0x9c)\n[<c05f6b24>] (dump_stack) from [<c00903f4>] (__lock_acquire+0x19c0/0x1e20)\n[<c00903f4>] (__lock_acquire) from [<c0091098>] (lock_acquire+0xa8/0x128)\n[<c0091098>] (lock_acquire) from [<c05fd61c>] (_raw_spin_lock_irqsave+0x38/0x4c)\n[<c05fd61c>] (_raw_spin_lock_irqsave) from [<c009b91c>] (__irq_get_desc_lock+0x50/0x94)\n[<c009b91c>] (__irq_get_desc_lock) from [<c009c4f4>] (irq_set_irq_wake+0x20/0xfc)\n[<c009c4f4>] (irq_set_irq_wake) from [<c0393ac4>] (pcf857x_irq_set_wake+0x24/0x54)\n[<c0393ac4>] (pcf857x_irq_set_wake) from [<c009c560>] (irq_set_irq_wake+0x8c/0xfc)\n[<c009c560>] (irq_set_irq_wake) from [<c04a02ac>] (gpio_keys_suspend+0x70/0xd4)\n[<c04a02ac>] (gpio_keys_suspend) from [<c03f6a00>] (dpm_run_callback+0x50/0x124)\n[<c03f6a00>] (dpm_run_callback) from [<c03f7830>] (__device_suspend+0x10c/0x398)\n[<c03f7830>] (__device_suspend) from [<c03f90f0>] (dpm_suspend+0x134/0x2f4)\n[<c03f90f0>] (dpm_suspend) from [<c0096e20>] (suspend_devices_and_enter+0xa8/0x728)\n[<c0096e20>] (suspend_devices_and_enter) from [<c00977cc>] (pm_suspend+0x32c/0x4c4)\n[<c00977cc>] (pm_suspend) from [<c0096060>] (state_store+0x64/0xb8)\n[<c0096060>] (state_store) from [<c01dec64>] (kernfs_fop_write+0xbc/0x1a0)\n[<c01dec64>] (kernfs_fop_write) from [<c016b280>] (__vfs_write+0x20/0xd8)\n[<c016b280>] (__vfs_write) from [<c016bb0c>] (vfs_write+0x90/0x164)\n[<c016bb0c>] (vfs_write) from [<c016c330>] (SyS_write+0x44/0x9c)\n[<c016c330>] (SyS_write) from [<c000f500>] (ret_fast_syscall+0x0/0x54)\n\nLets fix it by using separate lockdep class for each registered GPIO\nIRQ Chip. This is done by wrapping gpiochip_irqchip_add call into macros.\n\nThe implementation of this patch inspired by solution done by Nicolas\nBoichat for regmap [3]\n\n[1] http://www.spinics.net/lists/linux-gpio/msg05844.html\n[2] http://www.spinics.net/lists/linux-gpio/msg06021.html\n[3] http://www.spinics.net/lists/arm-kernel/msg429834.html\n\nCc: Geert Uytterhoeven <geert@linux-m68k.org>\nCc: Roger Quadros <rogerq@ti.com>\nReported-by: Roger Quadros <rogerq@ti.com>\nTested-by: Roger Quadros <rogerq@ti.com>\nSigned-off-by: Grygorii Strashko <grygorii.strashko@ti.com>\nSigned-off-by: Linus Walleij <linus.walleij@linaro.org>",
        "before_after_code_files": [
          "drivers/gpio/gpiolib.c||drivers/gpio/gpiolib.c",
          "include/linux/gpio/driver.h||include/linux/gpio/driver.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "drivers/gpio/gpiolib.c||drivers/gpio/gpiolib.c": [
          "File: drivers/gpio/gpiolib.c -> drivers/gpio/gpiolib.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "462: }",
          "463: EXPORT_SYMBOL_GPL(gpiochip_set_chained_irqchip);",
          "",
          "[Removed Lines]",
          "469: static struct lock_class_key gpiochip_irq_lock_class;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "484:  struct gpio_chip *chip = d->host_data;",
          "486:  irq_set_chip_data(irq, chip);",
          "488:  irq_set_chip_and_handler(irq, chip->irqchip, chip->irq_handler);",
          "490:  if (chip->can_sleep && !chip->irq_not_threaded)",
          "",
          "[Removed Lines]",
          "487:  irq_set_lockdep_class(irq, &gpiochip_irq_lock_class);",
          "",
          "[Added Lines]",
          "485:  irq_set_lockdep_class(irq, chip->lock_key);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "612: {",
          "613:  struct device_node *of_node;",
          "614:  unsigned int offset;",
          "",
          "[Removed Lines]",
          "607: int gpiochip_irqchip_add(struct gpio_chip *gpiochip,",
          "608:     struct irq_chip *irqchip,",
          "609:     unsigned int first_irq,",
          "610:     irq_flow_handler_t handler,",
          "611:     unsigned int type)",
          "",
          "[Added Lines]",
          "606: int _gpiochip_irqchip_add(struct gpio_chip *gpiochip,",
          "607:      struct irq_chip *irqchip,",
          "608:      unsigned int first_irq,",
          "609:      irq_flow_handler_t handler,",
          "610:      unsigned int type,",
          "611:      struct lock_class_key *lock_key)",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "634:  gpiochip->irq_handler = handler;",
          "635:  gpiochip->irq_default_type = type;",
          "636:  gpiochip->to_irq = gpiochip_to_irq;",
          "637:  gpiochip->irqdomain = irq_domain_add_simple(of_node,",
          "638:      gpiochip->ngpio, first_irq,",
          "639:      &gpiochip_domain_ops, gpiochip);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "637:  gpiochip->lock_key = lock_key;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "672:  return 0;",
          "673: }",
          "",
          "[Removed Lines]",
          "674: EXPORT_SYMBOL_GPL(gpiochip_irqchip_add);",
          "",
          "[Added Lines]",
          "675: EXPORT_SYMBOL_GPL(_gpiochip_irqchip_add);",
          "",
          "---------------"
        ],
        "include/linux/gpio/driver.h||include/linux/gpio/driver.h": [
          "File: include/linux/gpio/driver.h -> include/linux/gpio/driver.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "6: #include <linux/irq.h>",
          "7: #include <linux/irqchip/chained_irq.h>",
          "8: #include <linux/irqdomain.h>",
          "9: #include <linux/pinctrl/pinctrl.h>",
          "11: struct device;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "9: #include <linux/lockdep.h>",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "126:  irq_flow_handler_t irq_handler;",
          "127:  unsigned int  irq_default_type;",
          "128:  int   irq_parent;",
          "129: #endif",
          "131: #if defined(CONFIG_OF_GPIO)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "130:  struct lock_class_key *lock_key;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "171:   int parent_irq,",
          "172:   irq_flow_handler_t parent_handler);",
          "",
          "[Removed Lines]",
          "174: int gpiochip_irqchip_add(struct gpio_chip *gpiochip,",
          "175:   struct irq_chip *irqchip,",
          "176:   unsigned int first_irq,",
          "177:   irq_flow_handler_t handler,",
          "178:   unsigned int type);",
          "",
          "[Added Lines]",
          "176: int _gpiochip_irqchip_add(struct gpio_chip *gpiochip,",
          "177:      struct irq_chip *irqchip,",
          "178:      unsigned int first_irq,",
          "179:      irq_flow_handler_t handler,",
          "180:      unsigned int type,",
          "181:      struct lock_class_key *lock_key);",
          "183: #ifdef CONFIG_LOCKDEP",
          "184: #define gpiochip_irqchip_add(...)    \\",
          "185: (        \\",
          "186:  ({       \\",
          "187:   static struct lock_class_key _key;  \\",
          "188:   _gpiochip_irqchip_add(__VA_ARGS__, &_key); \\",
          "189:  })       \\",
          "190: )",
          "191: #else",
          "192: #define gpiochip_irqchip_add(...)    \\",
          "193:  _gpiochip_irqchip_add(__VA_ARGS__, NULL)",
          "194: #endif",
          "",
          "---------------"
        ]
      }
    }
  ]
}
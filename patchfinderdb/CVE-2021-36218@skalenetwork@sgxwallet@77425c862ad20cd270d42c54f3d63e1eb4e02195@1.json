{
  "cve_id": "CVE-2021-36218",
  "cve_desc": "An issue was discovered in SKALE sgxwallet 1.58.3. sgx_disp_ippsAES_GCMEncrypt allows an out-of-bounds write, resulting in a segfault and compromised enclave. This issue describes a buffer overflow, which was resolved prior to v1.77.0 and not reproducible in latest sgxwallet v1.77.0",
  "repo": "skalenetwork/sgxwallet",
  "patch_hash": "77425c862ad20cd270d42c54f3d63e1eb4e02195",
  "patch_info": {
    "commit_hash": "77425c862ad20cd270d42c54f3d63e1eb4e02195",
    "repo": "skalenetwork/sgxwallet",
    "commit_url": "https://github.com/skalenetwork/sgxwallet/commit/77425c862ad20cd270d42c54f3d63e1eb4e02195",
    "files": [
      "BLSCrypto.cpp",
      "DKGCrypto.cpp",
      "ECDSACrypto.cpp",
      "SEKManager.cpp",
      "SGXWalletServer.cpp",
      "secure_enclave/AESUtils.c",
      "secure_enclave/AESUtils.h",
      "secure_enclave/secure_enclave.c",
      "secure_enclave/secure_enclave.edl",
      "testw.cpp"
    ],
    "message": "SKALE-3205-restart",
    "before_after_code_files": [
      "BLSCrypto.cpp||BLSCrypto.cpp",
      "DKGCrypto.cpp||DKGCrypto.cpp",
      "ECDSACrypto.cpp||ECDSACrypto.cpp",
      "SEKManager.cpp||SEKManager.cpp",
      "SGXWalletServer.cpp||SGXWalletServer.cpp",
      "secure_enclave/AESUtils.c||secure_enclave/AESUtils.c",
      "secure_enclave/AESUtils.h||secure_enclave/AESUtils.h",
      "secure_enclave/secure_enclave.c||secure_enclave/secure_enclave.c",
      "secure_enclave/secure_enclave.edl||secure_enclave/secure_enclave.edl",
      "testw.cpp||testw.cpp"
    ]
  },
  "patch_diff": {
    "BLSCrypto.cpp||BLSCrypto.cpp": [
      "File: BLSCrypto.cpp -> BLSCrypto.cpp",
      "--- Hunk 1 ---",
      "[Context before]",
      "87:     CHECK_STATE(_hexArrayLen > 2 * _len);",
      "90:         _hexArray[j * 2] = hexval[((d[j] >> 4) & 0xF)];",
      "91:         _hexArray[j * 2 + 1] = hexval[(d[j]) & 0x0F];",
      "92:     }",
      "",
      "[Removed Lines]",
      "89:     for (int j = 0; j < _len; j++) {",
      "",
      "[Added Lines]",
      "89:     for (uint64_t j = 0; j < _len; j++) {",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "105:     CHECK_STATE(_bin_len)",
      "110:     CHECK_STATE(len != 2 * _max_length + 1);",
      "",
      "[Removed Lines]",
      "108:     int len = strnlen(_hex, 2 * _max_length + 1);",
      "",
      "[Added Lines]",
      "108:     uint64_t len = strnlen(_hex, 2 * _max_length + 1);",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "121:         int high = char2int((char) _hex[i * 2]);",
      "122:         int low = char2int((char) _hex[i * 2 + 1]);",
      "",
      "[Removed Lines]",
      "120:     for (int i = 0; i < len / 2; i++) {",
      "",
      "[Added Lines]",
      "120:     for (uint64_t i = 0; i < len / 2; i++) {",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "248:     strncpy(keyArray->data(), _key, BUF_LEN);",
      "252:     sgx_status_t status = trustedEncryptKeyAES(eid, errStatus, errMsg.data(), keyArray->data(), encryptedKey->data(), &encryptedLen);",
      "",
      "[Removed Lines]",
      "250:     unsigned int encryptedLen = 0;",
      "",
      "[Added Lines]",
      "251:     uint64_t encryptedLen = 0;",
      "",
      "---------------"
    ],
    "DKGCrypto.cpp||DKGCrypto.cpp": [
      "File: DKGCrypto.cpp -> DKGCrypto.cpp",
      "--- Hunk 1 ---",
      "[Context before]",
      "135: string gen_dkg_poly(int _t) {",
      "136:     vector<char> errMsg(BUF_LEN, 0);",
      "137:     int errStatus = 0;",
      "140:     vector <uint8_t> encrypted_dkg_secret(BUF_LEN, 0);",
      "145:     HANDLE_TRUSTED_FUNCTION_ERROR(status, errStatus, errMsg.data());",
      "147:     uint64_t length = enc_len;;",
      "",
      "[Removed Lines]",
      "138:     uint32_t enc_len = 0;",
      "144:     sgx_status_t status = trustedGenDkgSecretAES(eid, &errStatus, errMsg.data(), encrypted_dkg_secret.data(), &enc_len, _t);",
      "",
      "[Added Lines]",
      "138:     uint64_t enc_len = 0;",
      "142:     sgx_status_t status = trustedGenDkgSecretAES(",
      "143:             eid, &errStatus,errMsg.data(), encrypted_dkg_secret.data(), &enc_len, _t);",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "215:     for (int i = 0; i < _n; i++) {",
      "216:         vector <uint8_t> encryptedSkey(BUF_LEN, 0);",
      "218:         vector<char> currentShare(193, 0);",
      "219:         vector<char> sShareG2(320, 0);",
      "",
      "[Removed Lines]",
      "217:         uint32_t decLen;",
      "",
      "[Added Lines]",
      "217:         uint64_t decLen;",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "300:         throw SGXException(INVALID_HEX, \"Invalid encryptedKeyHex\");",
      "301:     }",
      "305:     sgx_status_t status = trustedCreateBlsKeyAES(eid, &errStatus, errMsg.data(), s_shares, encr_key, decKeyLen, encr_bls_key,",
      "306:                                                  &enc_bls_len);",
      "",
      "[Removed Lines]",
      "303:     uint32_t enc_bls_len = 0;",
      "",
      "[Added Lines]",
      "303:     uint64_t enc_bls_len = 0;",
      "",
      "---------------"
    ],
    "ECDSACrypto.cpp||ECDSACrypto.cpp": [
      "File: ECDSACrypto.cpp -> ECDSACrypto.cpp",
      "--- Hunk 1 ---",
      "[Context before]",
      "54:     vector<char> pub_key_x(BUF_LEN, 0);",
      "55:     vector<char> pub_key_y(BUF_LEN, 0);",
      "59:     sgx_status_t status = trustedGenerateEcdsaKeyAES(eid, &errStatus,",
      "60:                                         errMsg.data(), encr_pr_key.data(), &enc_len,",
      "",
      "[Removed Lines]",
      "57:     uint32_t enc_len = 0;",
      "",
      "[Added Lines]",
      "57:     uint64_t enc_len = 0;",
      "",
      "---------------"
    ],
    "SEKManager.cpp||SEKManager.cpp": [
      "File: SEKManager.cpp -> SEKManager.cpp",
      "--- Hunk 1 ---",
      "[Context before]",
      "52: void create_test_key() {",
      "53:     int errStatus = 0;",
      "54:     vector<char> errMsg(1024, 0);",
      "57:     SAFE_UINT8_BUF(encrypted_key, BUF_LEN);",
      "",
      "[Removed Lines]",
      "55:     uint32_t enc_len;",
      "",
      "[Added Lines]",
      "55:     uint64_t enc_len;",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "110:     auto encrypted_SEK = make_shared < vector < uint8_t >> (BUF_LEN, 0);",
      "114:     sgx_status_t status = trustedSetSEK_backup(eid, &err_status, errMsg.data(), encrypted_SEK->data(), &l,",
      "115:                                                SEK.c_str());",
      "",
      "[Removed Lines]",
      "112:     uint32_t l = 0;",
      "",
      "[Added Lines]",
      "112:     uint64_t l = 0;",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "127:     vector<char> errMsg(1024, 0);",
      "128:     int err_status = 0;",
      "129:     vector <uint8_t> encrypted_SEK(1024, 0);",
      "132:     SAFE_CHAR_BUF(SEK, 65);",
      "",
      "[Removed Lines]",
      "130:     uint32_t enc_len = 0;",
      "",
      "[Added Lines]",
      "130:     uint64_t enc_len = 0;",
      "",
      "---------------"
    ],
    "SGXWalletServer.cpp||SGXWalletServer.cpp": [
      "File: SGXWalletServer.cpp -> SGXWalletServer.cpp",
      "--- Hunk 1 ---",
      "[Context before]",
      "564:         vector<string> public_keys = calculateAllBlsPublicKeys(public_shares);",
      "567:             throw SGXException(UNKNOWN_ERROR, \"\");",
      "568:         }",
      "",
      "[Removed Lines]",
      "566:         if (public_keys.size() != n) {",
      "",
      "[Added Lines]",
      "566:         if (public_keys.size() != (uint64_t)n) {",
      "",
      "---------------"
    ],
    "secure_enclave/AESUtils.c||secure_enclave/AESUtils.c": [
      "File: secure_enclave/AESUtils.c -> secure_enclave/AESUtils.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "27: #include \"stdlib.h\"",
      "28: #include <string.h>",
      "30: #include \"AESUtils.h\"",
      "32: sgx_aes_gcm_128bit_key_t AES_key;",
      "33: sgx_aes_gcm_128bit_key_t AES_DH_key;",
      "37:     if (!message) {",
      "38:         LOG_ERROR(\"Null message in AES_encrypt\");",
      "",
      "[Removed Lines]",
      "35: int AES_encrypt(char *message, uint8_t *encr_message, uint64_t encrLen) {",
      "",
      "[Added Lines]",
      "37: #define SAFE_CHAR_BUF(__X__, __Y__)  ;char __X__ [ __Y__ ]; memset(__X__, 0, __Y__);",
      "39: int AES_encrypt(char *message, uint8_t *encr_message, uint64_t encrBufLen, unsigned  char type,",
      "40:                 unsigned char decryptable, uint64_t* resultLen) {",
      "44:     if (!type) {",
      "45:         LOG_ERROR(\"Null type in AES_encrypt\");",
      "46:         return -1;",
      "47:     }",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "47:     uint64_t len = strlen(message) + 1;",
      "50:         LOG_ERROR(\"Output buffer too small\");",
      "51:         return -3;",
      "52:     }",
      "54:     sgx_read_rand(encr_message + SGX_AESGCM_MAC_SIZE, SGX_AESGCM_IV_SIZE);",
      "57:                                                      encr_message + SGX_AESGCM_MAC_SIZE + SGX_AESGCM_IV_SIZE,",
      "58:                                                      encr_message + SGX_AESGCM_MAC_SIZE, SGX_AESGCM_IV_SIZE,",
      "59:                                                      NULL, 0,",
      "60:                                                      (sgx_aes_gcm_128bit_tag_t *) encr_message);",
      "62:     return status;",
      "63: }",
      "",
      "[Removed Lines]",
      "49:     if (len + SGX_AESGCM_MAC_SIZE + SGX_AESGCM_IV_SIZE > encrLen ) {",
      "56:     sgx_status_t status = sgx_rijndael128GCM_encrypt(&AES_key, (uint8_t*)message, strlen(message),",
      "",
      "[Added Lines]",
      "61:     if (2 + len + SGX_AESGCM_MAC_SIZE + SGX_AESGCM_IV_SIZE > encrBufLen ) {",
      "66:     SAFE_CHAR_BUF(fullMessage, len + 2);",
      "68:     fullMessage[0] = type;",
      "69:     fullMessage[1] = decryptable;",
      "71:     strncpy(fullMessage + 2, message, len );",
      "73:     len = len + 2;",
      "74:     message = fullMessage;",
      "78:     sgx_status_t status = sgx_rijndael128GCM_encrypt(&AES_key, (uint8_t*)message, len,",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "96:                                                    NULL, 0,",
      "97:                                                    (sgx_aes_gcm_128bit_tag_t *)encr_message);",
      "133: }",
      "",
      "[Removed Lines]",
      "99:   return status;",
      "100: }",
      "105: int AES_encrypt_DH(char *message, uint8_t *encr_message, uint64_t encrLen) {",
      "107:     if (!message) {",
      "108:         LOG_ERROR(\"Null message in AES_encrypt_DH\");",
      "109:         return -1;",
      "110:     }",
      "112:     if (!encr_message) {",
      "113:         LOG_ERROR(\"Null encr message in AES_encrypt_DH\");",
      "114:         return -2;",
      "115:     }",
      "117:     uint64_t len = strlen(message) + 1;",
      "119:     if (len + SGX_AESGCM_MAC_SIZE + SGX_AESGCM_IV_SIZE > encrLen ) {",
      "120:         LOG_ERROR(\"Output buffer too small\");",
      "121:         return -3;",
      "122:     }",
      "124:     sgx_read_rand(encr_message + SGX_AESGCM_MAC_SIZE, SGX_AESGCM_IV_SIZE);",
      "126:     sgx_status_t status = sgx_rijndael128GCM_encrypt(&AES_DH_key, (uint8_t*)message, strlen(message),",
      "127:                                                      encr_message + SGX_AESGCM_MAC_SIZE + SGX_AESGCM_IV_SIZE,",
      "128:                                                      encr_message + SGX_AESGCM_MAC_SIZE, SGX_AESGCM_IV_SIZE,",
      "129:                                                      NULL, 0,",
      "130:                                                      (sgx_aes_gcm_128bit_tag_t *) encr_message);",
      "132:     return status;",
      "135: int AES_decrypt_DH(uint8_t *encr_message, uint64_t length, char *message, uint64_t msgLen) {",
      "137:     if (!message) {",
      "138:         LOG_ERROR(\"Null message in AES_encrypt_DH\");",
      "139:         return -1;",
      "140:     }",
      "142:     if (!encr_message) {",
      "143:         LOG_ERROR(\"Null encr message in AES_encrypt_DH\");",
      "144:         return -2;",
      "145:     }",
      "148:     if (length < SGX_AESGCM_MAC_SIZE + SGX_AESGCM_IV_SIZE) {",
      "149:         LOG_ERROR(\"length < SGX_AESGCM_MAC_SIZE - SGX_AESGCM_IV_SIZE\");",
      "150:         return -1;",
      "151:     }",
      "155:     uint64_t len = length - SGX_AESGCM_MAC_SIZE - SGX_AESGCM_IV_SIZE;",
      "157:     if (msgLen < len) {",
      "158:         LOG_ERROR(\"Output buffer not large enough\");",
      "159:         return -2;",
      "160:     }",
      "162:     sgx_status_t status = sgx_rijndael128GCM_decrypt(&AES_DH_key,",
      "163:                                                      encr_message + SGX_AESGCM_MAC_SIZE + SGX_AESGCM_IV_SIZE, len,",
      "164:                                                      (unsigned char*) message,",
      "165:                                                      encr_message + SGX_AESGCM_MAC_SIZE, SGX_AESGCM_IV_SIZE,",
      "166:                                                      NULL, 0,",
      "167:                                                      (sgx_aes_gcm_128bit_tag_t *)encr_message);",
      "169:     return status;",
      "170: }",
      "",
      "[Added Lines]",
      "123:   for (int i = 2; i < strlen(message) + 1; i++) {",
      "124:       message[i - 2 ] = message[i];",
      "125:   }",
      "127:   return status;",
      "",
      "---------------"
    ],
    "secure_enclave/AESUtils.h||secure_enclave/AESUtils.h": [
      "File: secure_enclave/AESUtils.h -> secure_enclave/AESUtils.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "27: extern sgx_aes_gcm_128bit_key_t AES_key;",
      "28: extern sgx_aes_gcm_128bit_key_t AES_DH_key;",
      "31: int AES_decrypt(uint8_t *encr_message, uint64_t length, char *message, uint64_t msgLen) ;",
      "33: int AES_encrypt_DH(char *message, uint8_t *encr_message, uint64_t encrLen);",
      "",
      "[Removed Lines]",
      "30: int AES_encrypt(char *message, uint8_t *encr_message, uint64_t encrLen);",
      "",
      "[Added Lines]",
      "30: int AES_encrypt(char *message, uint8_t *encr_message, uint64_t encrLen,",
      "31:                 unsigned char type, unsigned char decryptable, uint64_t* resultLen);",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "36: void derive_DH_Key();",
      "39: #endif //SGXD_AESUTILS_H",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "39: #define ECDSA '1'",
      "40: #define BLS '2'",
      "41: #define DKG '3'",
      "43: #define DECRYPTABLE '1'",
      "44: #define NON_DECRYPTABLE '2'",
      "",
      "---------------"
    ],
    "secure_enclave/secure_enclave.c||secure_enclave/secure_enclave.c": [
      "File: secure_enclave/secure_enclave.c -> secure_enclave/secure_enclave.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "122:         abort(); \\",
      "123:     } else {called = true;};",
      "126:     CALL_ONCE",
      "127:     LOG_INFO(__FUNCTION__);",
      "",
      "[Removed Lines]",
      "125: void trustedEnclaveInit(uint32_t _logLevel) {",
      "",
      "[Added Lines]",
      "125: void trustedEnclaveInit(uint64_t _logLevel) {",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "234: void sealHexSEK(int *errStatus, char *errString,",
      "236:     CALL_ONCE",
      "237:     LOG_INFO(__FUNCTION__);",
      "238:     INIT_ERROR_STATE",
      "",
      "[Removed Lines]",
      "235:                         uint8_t *encrypted_sek, uint32_t *enc_len, char *sek_hex) {",
      "",
      "[Added Lines]",
      "235:                         uint8_t *encrypted_sek, uint64_t *enc_len, char *sek_hex) {",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "255:                                            (sgx_sealed_data_t *) encrypted_sek);",
      "256:     CHECK_STATUS(\"seal SEK failed after SEK generation\");",
      "260:     CHECK_STATE(encrypt_text_length = plaintextLen);",
      "",
      "[Removed Lines]",
      "258:     uint32_t encrypt_text_length = sgx_get_encrypt_txt_len((const sgx_sealed_data_t *)encrypted_sek);",
      "",
      "[Added Lines]",
      "258:     uint64_t encrypt_text_length = sgx_get_encrypt_txt_len((const sgx_sealed_data_t *)encrypted_sek);",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "263:     SAFE_CHAR_BUF(unsealedKey, BUF_LEN);",
      "264:     uint32_t decLen = BUF_LEN;",
      "267:     CHECK_STATE(add_text_length == 0);",
      "268:     CHECK_STATE(sgx_is_within_enclave(encrypted_sek,sizeof(sgx_sealed_data_t)));",
      "269:     status = sgx_unseal_data((const sgx_sealed_data_t *)encrypted_sek, NULL, NULL,",
      "",
      "[Removed Lines]",
      "266:     uint32_t add_text_length = sgx_get_add_mac_txt_len((const sgx_sealed_data_t *)encrypted_sek);",
      "",
      "[Added Lines]",
      "266:     uint64_t add_text_length = sgx_get_add_mac_txt_len((const sgx_sealed_data_t *)encrypted_sek);",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "279: }",
      "281: void trustedGenerateSEK(int *errStatus, char *errString,",
      "283:     CALL_ONCE",
      "284:     LOG_INFO(__FUNCTION__);",
      "285:     INIT_ERROR_STATE",
      "",
      "[Removed Lines]",
      "282:                         uint8_t *encrypted_sek, uint32_t *enc_len, char *sek_hex) {",
      "",
      "[Added Lines]",
      "282:                         uint8_t *encrypted_sek, uint64_t *enc_len, char *sek_hex) {",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "341: }",
      "343: void trustedSetSEK_backup(int *errStatus, char *errString,",
      "345:     CALL_ONCE",
      "346:     LOG_INFO(__FUNCTION__);",
      "347:     INIT_ERROR_STATE",
      "",
      "[Removed Lines]",
      "344:                           uint8_t *encrypted_sek, uint32_t *enc_len, const char *sek_hex) {",
      "",
      "[Added Lines]",
      "344:                           uint8_t *encrypted_sek, uint64_t *enc_len, const char *sek_hex) {",
      "",
      "---------------",
      "--- Hunk 7 ---",
      "[Context before]",
      "372: void trustedGenerateEcdsaKeyAES(int *errStatus, char *errString,",
      "374:     LOG_INFO(__FUNCTION__);",
      "375:     INIT_ERROR_STATE",
      "",
      "[Removed Lines]",
      "373:                                 uint8_t *encryptedPrivateKey, uint32_t *enc_len, char *pub_key_x, char *pub_key_y) {",
      "",
      "[Added Lines]",
      "373:                                 uint8_t *encryptedPrivateKey, uint64_t *enc_len, char *pub_key_x, char *pub_key_y) {",
      "",
      "---------------",
      "--- Hunk 8 ---",
      "[Context before]",
      "410:     }",
      "411:     strncpy(pub_key_y + n_zeroes, arr_y, 1024 - n_zeroes);",
      "414:     mpz_get_str(arr_skey_str, ECDSA_SKEY_BASE, skey);",
      "415:     n_zeroes = 64 - strlen(arr_skey_str);",
      "416:     for (int i = 0; i < n_zeroes; i++) {",
      "417:         skey_str[i] = '0';",
      "418:     }",
      "419:     strncpy(skey_str + n_zeroes, arr_skey_str, 65 - n_zeroes);",
      "421:     snprintf(errString, BUF_LEN, \"skey len is %d\\n\", (int) strlen(skey_str));",
      "424:     CHECK_STATUS(\"ecdsa private key encryption failed\");",
      "430:     CHECK_STATUS2(\"ecdsa private key decr failed with status %d\");",
      "",
      "[Removed Lines]",
      "413:     SAFE_CHAR_BUF(skey_str, ECDSA_SKEY_LEN);SAFE_CHAR_BUF(arr_skey_str, mpz_sizeinbase(skey, ECDSA_SKEY_BASE) + 2);",
      "420:     skey_str[ECDSA_SKEY_LEN - 1] = 0;",
      "423:     int status = AES_encrypt((char *) skey_str, encryptedPrivateKey, BUF_LEN);",
      "428:     status = AES_decrypt(encryptedPrivateKey, *enc_len, skey_str, ECDSA_SKEY_LEN);",
      "",
      "[Added Lines]",
      "413:     SAFE_CHAR_BUF(skey_str, BUF_LEN);",
      "414:     SAFE_CHAR_BUF(arr_skey_str, mpz_sizeinbase(skey, ECDSA_SKEY_BASE) + 2);",
      "423:     int status = AES_encrypt((char *) skey_str, encryptedPrivateKey, BUF_LEN,",
      "424:                              ECDSA, NON_DECRYPTABLE, enc_len);",
      "427:     status = AES_decrypt(encryptedPrivateKey, *enc_len, skey_str, BUF_LEN);",
      "",
      "---------------",
      "--- Hunk 9 ---",
      "[Context before]",
      "439: }",
      "441: void trustedGetPublicEcdsaKeyAES(int *errStatus, char *errString,",
      "443:     LOG_DEBUG(__FUNCTION__);",
      "444:     INIT_ERROR_STATE",
      "448:     mpz_t privateKeyMpz;",
      "449:     mpz_init(privateKeyMpz);",
      "",
      "[Removed Lines]",
      "442:                                  uint8_t *encryptedPrivateKey, uint32_t enc_len, char *pub_key_x, char *pub_key_y) {",
      "446:     SAFE_CHAR_BUF(skey, ECDSA_SKEY_LEN);",
      "",
      "[Added Lines]",
      "441:                                  uint8_t *encryptedPrivateKey, uint64_t enc_len, char *pub_key_x, char *pub_key_y) {",
      "445:     SAFE_CHAR_BUF(skey, BUF_LEN);",
      "",
      "---------------",
      "--- Hunk 10 ---",
      "[Context before]",
      "455:     CHECK_STATE(pub_key_x);",
      "456:     CHECK_STATE(pub_key_y);",
      "459:     CHECK_STATUS2(\"AES_decrypt failed with status %d\");",
      "461:     skey[enc_len - SGX_AESGCM_MAC_SIZE - SGX_AESGCM_IV_SIZE] = '\\0';",
      "",
      "[Removed Lines]",
      "458:     int status = AES_decrypt(encryptedPrivateKey, enc_len, skey, ECDSA_SKEY_LEN);",
      "",
      "[Added Lines]",
      "457:     int status = AES_decrypt(encryptedPrivateKey, enc_len, skey, BUF_LEN);",
      "",
      "---------------",
      "--- Hunk 11 ---",
      "[Context before]",
      "516: static uint64_t sigCounter = 0;",
      "519:                          const char *hash, char *sigR, char *sigS, uint8_t *sig_v, int base) {",
      "520:     LOG_DEBUG(__FUNCTION__);",
      "",
      "[Removed Lines]",
      "518: void trustedEcdsaSignAES(int *errStatus, char *errString, uint8_t *encryptedPrivateKey, uint32_t enc_len,",
      "",
      "[Added Lines]",
      "517: void trustedEcdsaSignAES(int *errStatus, char *errString, uint8_t *encryptedPrivateKey, uint64_t enc_len,",
      "",
      "---------------",
      "--- Hunk 12 ---",
      "[Context before]",
      "526:     CHECK_STATE(sigR);",
      "527:     CHECK_STATE(sigS);",
      "531:     mpz_t privateKeyMpz;",
      "532:     mpz_init(privateKeyMpz);",
      "",
      "[Removed Lines]",
      "529:     SAFE_CHAR_BUF(skey, ECDSA_SKEY_LEN);",
      "",
      "[Added Lines]",
      "528:     SAFE_CHAR_BUF(skey, BUF_LEN);",
      "",
      "---------------",
      "--- Hunk 13 ---",
      "[Context before]",
      "534:     mpz_init(msgMpz);",
      "535:     signature sign = signature_init();",
      "539:     CHECK_STATUS2(\"aes decrypt failed with status %d\");",
      "",
      "[Removed Lines]",
      "537:     int status = AES_decrypt(encryptedPrivateKey, enc_len, skey, ECDSA_SKEY_LEN);",
      "",
      "[Added Lines]",
      "536:     int status = AES_decrypt(encryptedPrivateKey, enc_len, skey, BUF_LEN);",
      "",
      "---------------",
      "--- Hunk 14 ---",
      "[Context before]",
      "602: void trustedDecryptKeyAES(int *errStatus, char *errString, uint8_t *encryptedPrivateKey,",
      "605:     LOG_DEBUG(__FUNCTION__);",
      "606:     INIT_ERROR_STATE",
      "",
      "[Removed Lines]",
      "603:                           uint32_t enc_len, char *key) {",
      "",
      "[Added Lines]",
      "602:                           uint64_t enc_len, char *key) {",
      "",
      "---------------",
      "--- Hunk 15 ---",
      "[Context before]",
      "615:     if (status != 0) {",
      "",
      "[Removed Lines]",
      "613:     int status = AES_decrypt_DH(encryptedPrivateKey, enc_len, key, 3072);",
      "",
      "[Added Lines]",
      "612:     int status = AES_decrypt(encryptedPrivateKey, enc_len, key, 3072);",
      "",
      "---------------",
      "--- Hunk 16 ---",
      "[Context before]",
      "638: void trustedEncryptKeyAES(int *errStatus, char *errString, const char *key,",
      "640:     LOG_INFO(__FUNCTION__);",
      "",
      "[Removed Lines]",
      "639:                           uint8_t *encryptedPrivateKey, uint32_t *enc_len) {",
      "",
      "[Added Lines]",
      "638:                           uint8_t *encryptedPrivateKey, uint64_t *enc_len) {",
      "",
      "---------------",
      "--- Hunk 17 ---",
      "[Context before]",
      "652:     CHECK_STATUS2(\"AES encrypt failed with status %d\");",
      "656:     SAFE_CHAR_BUF(decryptedKey, BUF_LEN);",
      "660:     CHECK_STATUS2(\"trustedDecryptKey failed with status %d\");",
      "",
      "[Removed Lines]",
      "650:     int status = AES_encrypt_DH((char *)key, encryptedPrivateKey, BUF_LEN);",
      "658:     status = AES_decrypt_DH(encryptedPrivateKey, *enc_len, decryptedKey, BUF_LEN);",
      "",
      "[Added Lines]",
      "649:     int status = AES_encrypt((char *)key, encryptedPrivateKey, BUF_LEN,",
      "650:                              DKG, DECRYPTABLE, enc_len);",
      "656:     status = AES_decrypt(encryptedPrivateKey, *enc_len, decryptedKey, BUF_LEN);",
      "",
      "---------------",
      "--- Hunk 18 ---",
      "[Context before]",
      "672:     if (strncmp(key, decryptedKey, MAX_KEY_LENGTH) != 0) {",
      "673:         snprintf(errString, BUF_LEN, \"Decrypted key does not match original key\");",
      "674:         LOG_ERROR(errString);",
      "675:         goto clean;",
      "676:     }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "672:         LOG_ERROR(key);",
      "673:         LOG_ERROR(decryptedKey);",
      "",
      "---------------",
      "--- Hunk 19 ---",
      "[Context before]",
      "686: void trustedBlsSignMessageAES(int *errStatus, char *errString, uint8_t *encryptedPrivateKey,",
      "688:                               char *_hashY, char *signature) {",
      "689:     LOG_DEBUG(__FUNCTION__);",
      "690:     INIT_ERROR_STATE",
      "",
      "[Removed Lines]",
      "687:                               uint32_t enc_len, char *_hashX,",
      "",
      "[Added Lines]",
      "687:                               uint64_t enc_len, char *_hashX,",
      "",
      "---------------",
      "--- Hunk 20 ---",
      "[Context before]",
      "726: }",
      "728: void",
      "730:     LOG_INFO(__FUNCTION__);",
      "731:     INIT_ERROR_STATE",
      "",
      "[Removed Lines]",
      "729: trustedGenDkgSecretAES(int *errStatus, char *errString, uint8_t *encrypted_dkg_secret, uint32_t *enc_len, size_t _t) {",
      "",
      "[Added Lines]",
      "729: trustedGenDkgSecretAES(int *errStatus, char *errString, uint8_t *encrypted_dkg_secret, uint64_t *enc_len, size_t _t) {",
      "",
      "---------------",
      "--- Hunk 21 ---",
      "[Context before]",
      "739:     CHECK_STATUS(\"gen_dkg_poly failed\")",
      "743:     CHECK_STATUS(\"SGX AES encrypt DKG poly failed\");",
      "747:     SAFE_CHAR_BUF(decr_dkg_secret, DKG_BUFER_LENGTH);",
      "",
      "[Removed Lines]",
      "741:     status = AES_encrypt(dkg_secret, encrypted_dkg_secret, 3 * BUF_LEN);",
      "",
      "[Added Lines]",
      "741:     status = AES_encrypt(dkg_secret, encrypted_dkg_secret, 3 * BUF_LEN,",
      "742:                          DKG, DECRYPTABLE, enc_len);",
      "",
      "---------------",
      "--- Hunk 22 ---",
      "[Context before]",
      "769: void",
      "770: trustedDecryptDkgSecretAES(int *errStatus, char *errString, uint8_t *encrypted_dkg_secret,",
      "772:                            uint8_t *decrypted_dkg_secret) {",
      "773:     LOG_INFO(__FUNCTION__);",
      "774:     INIT_ERROR_STATE",
      "",
      "[Removed Lines]",
      "771:                            uint32_t enc_len,",
      "",
      "[Added Lines]",
      "772:                            uint64_t enc_len,",
      "",
      "---------------",
      "--- Hunk 23 ---",
      "[Context before]",
      "790: }",
      "794:     LOG_INFO(__FUNCTION__);",
      "795:     INIT_ERROR_STATE",
      "",
      "[Removed Lines]",
      "793: void trustedSetEncryptedDkgPolyAES(int *errStatus, char *errString, uint8_t *encrypted_poly, uint32_t enc_len) {",
      "",
      "[Added Lines]",
      "794: void trustedSetEncryptedDkgPolyAES(int *errStatus, char *errString, uint8_t *encrypted_poly, uint64_t enc_len) {",
      "",
      "---------------",
      "--- Hunk 24 ---",
      "[Context before]",
      "810:     LOG_INFO(\"SGX call completed\");",
      "811: }",
      "814:                                        char *result_str, char *s_shareG2, char *pub_keyB, uint8_t _t, uint8_t _n,",
      "815:                                        uint8_t ind) {",
      "817:     LOG_INFO(__FUNCTION__);",
      "818:     INIT_ERROR_STATE",
      "821:     int status;",
      "823:     CHECK_STATE(encrypted_skey);",
      "",
      "[Removed Lines]",
      "813: void trustedGetEncryptedSecretShareAES(int *errStatus, char *errString, uint8_t *encrypted_skey, uint32_t *dec_len,",
      "820:     uint32_t enc_len;",
      "",
      "[Added Lines]",
      "814: void trustedGetEncryptedSecretShareAES(int *errStatus, char *errString, uint8_t *encrypted_skey, uint64_t *dec_len,",
      "821:     uint64_t enc_len;",
      "",
      "---------------",
      "--- Hunk 25 ---",
      "[Context before]",
      "828:     LOG_DEBUG(__FUNCTION__);",
      "832:     SAFE_CHAR_BUF(pub_key_x, BUF_LEN);SAFE_CHAR_BUF(pub_key_y, BUF_LEN);",
      "",
      "[Removed Lines]",
      "830:     SAFE_CHAR_BUF(skey, ECDSA_SKEY_LEN);",
      "",
      "[Added Lines]",
      "831:     SAFE_CHAR_BUF(skey, BUF_LEN);",
      "",
      "---------------",
      "--- Hunk 26 ---",
      "[Context before]",
      "836:     CHECK_STATUS(\"trustedGenerateEcdsaKeyAES failed\");",
      "840:     skey[ECDSA_SKEY_LEN - 1] = 0;",
      "",
      "[Removed Lines]",
      "838:     status = AES_decrypt(encrypted_skey, enc_len, skey, ECDSA_SKEY_LEN);",
      "",
      "[Added Lines]",
      "839:     status = AES_decrypt(encrypted_skey, enc_len, skey, BUF_LEN);",
      "",
      "---------------",
      "--- Hunk 27 ---",
      "[Context before]",
      "848:     status = gen_session_key(skey, pub_keyB, common_key);",
      "850:     CHECK_STATUS(\"gen_session_key failed\")",
      "854:     status = calc_secret_share(getThreadLocalDecryptedDkgPoly(), s_share, _t, _n, ind);",
      "855:     CHECK_STATUS(\"calc secret share failed\")",
      "",
      "[Removed Lines]",
      "846:     SAFE_CHAR_BUF(common_key, ECDSA_SKEY_LEN);",
      "852:     SAFE_CHAR_BUF(s_share, ECDSA_SKEY_LEN);",
      "",
      "[Added Lines]",
      "847:     SAFE_CHAR_BUF(common_key, BUF_LEN);",
      "853:     SAFE_CHAR_BUF(s_share, BUF_LEN);",
      "",
      "---------------",
      "--- Hunk 28 ---",
      "[Context before]",
      "858:     status = calc_secret_shareG2(s_share, s_shareG2);",
      "859:     CHECK_STATUS(\"invalid decr secret share\");",
      "862:     status=xor_encrypt(common_key, s_share, cypher);",
      "864:     CHECK_STATUS(\"xor_encrypt failed\")",
      "",
      "[Removed Lines]",
      "861:     SAFE_CHAR_BUF(cypher, ECDSA_SKEY_LEN);",
      "",
      "[Added Lines]",
      "862:     SAFE_CHAR_BUF(cypher, BUF_LEN);",
      "",
      "---------------",
      "--- Hunk 29 ---",
      "[Context before]",
      "875:     LOG_INFO(\"SGX call completed\");",
      "876: }",
      "879:                                char *public_shares,",
      "880:                                unsigned _t, unsigned _n) {",
      "881:     LOG_INFO(__FUNCTION__);",
      "",
      "[Removed Lines]",
      "878: void trustedGetPublicSharesAES(int *errStatus, char *errString, uint8_t *encrypted_dkg_secret, uint32_t enc_len,",
      "",
      "[Added Lines]",
      "879: void trustedGetPublicSharesAES(int *errStatus, char *errString, uint8_t *encrypted_dkg_secret, uint64_t enc_len,",
      "",
      "---------------",
      "--- Hunk 30 ---",
      "[Context before]",
      "913:     CHECK_STATE(s_share);",
      "914:     CHECK_STATE(encryptedPrivateKey);",
      "918:     mpz_t s;",
      "919:     mpz_init(s);",
      "923:     CHECK_STATUS2(\"AES_decrypt failed (in trustedDkgVerifyAES) with status %d\");",
      "927:     strncpy(encr_sshare, s_share, ECDSA_SKEY_LEN - 1);",
      "931:     status = session_key_recover(skey, s_share, common_key);",
      "933:     CHECK_STATUS(\"session_key_recover failed\");",
      "937:     status=xor_decrypt(common_key, encr_sshare, decr_sshare);",
      "",
      "[Removed Lines]",
      "916:     SAFE_CHAR_BUF(skey, ECDSA_SKEY_LEN);",
      "921:     int status = AES_decrypt(encryptedPrivateKey, enc_len, skey, ECDSA_SKEY_LEN);",
      "925:     SAFE_CHAR_BUF(encr_sshare, ECDSA_SKEY_LEN);",
      "929:     SAFE_CHAR_BUF(common_key, ECDSA_SKEY_LEN);",
      "935:     SAFE_CHAR_BUF(decr_sshare, ECDSA_SKEY_LEN);",
      "",
      "[Added Lines]",
      "917:     SAFE_CHAR_BUF(skey,BUF_LEN);",
      "922:     int status = AES_decrypt(encryptedPrivateKey, enc_len, skey, BUF_LEN);",
      "926:     SAFE_CHAR_BUF(encr_sshare, BUF_LEN);",
      "930:     SAFE_CHAR_BUF(common_key, BUF_LEN);",
      "936:     SAFE_CHAR_BUF(decr_sshare, BUF_LEN);",
      "",
      "---------------",
      "--- Hunk 31 ---",
      "[Context before]",
      "955: void trustedCreateBlsKeyAES(int *errStatus, char *errString, const char *s_shares,",
      "956:                             uint8_t *encryptedPrivateKey, uint64_t key_len, uint8_t *encr_bls_key,",
      "959:     LOG_INFO(__FUNCTION__);",
      "",
      "[Removed Lines]",
      "957:                             uint32_t *enc_bls_key_len) {",
      "",
      "[Added Lines]",
      "958:                             uint64_t *enc_bls_key_len) {",
      "",
      "---------------",
      "--- Hunk 32 ---",
      "[Context before]",
      "964:     CHECK_STATE(encryptedPrivateKey);",
      "965:     CHECK_STATE(encr_bls_key);",
      "969:     mpz_t sum;",
      "970:     mpz_init(sum);",
      "",
      "[Removed Lines]",
      "967:     SAFE_CHAR_BUF(skey, ECDSA_SKEY_LEN);",
      "",
      "[Added Lines]",
      "968:     SAFE_CHAR_BUF(skey, BUF_LEN);",
      "",
      "---------------",
      "--- Hunk 33 ---",
      "[Context before]",
      "978:     mpz_init(bls_key);",
      "982:     CHECK_STATUS2(\"aes decrypt failed with status %d\");",
      "984:     skey[ECDSA_SKEY_LEN - 1] = 0;",
      "",
      "[Removed Lines]",
      "981:     int status = AES_decrypt(encryptedPrivateKey, key_len, skey, ECDSA_SKEY_LEN);",
      "",
      "[Added Lines]",
      "982:     int status = AES_decrypt(encryptedPrivateKey, key_len, skey, BUF_LEN);",
      "",
      "---------------",
      "--- Hunk 34 ---",
      "[Context before]",
      "1038:     strncpy(key_share + n_zeroes, arr_skey_str, 65 - n_zeroes);",
      "1039:     key_share[BLS_KEY_LENGTH - 1] = 0;",
      "1043:     CHECK_STATUS2(\"aes encrypt bls private key failed with status %d \");",
      "1047:     SET_SUCCESS",
      "1048:     clean:",
      "",
      "[Removed Lines]",
      "1041:     status = AES_encrypt(key_share, encr_bls_key, BUF_LEN);",
      "",
      "[Added Lines]",
      "1042:     status = AES_encrypt(key_share, encr_bls_key, BUF_LEN, BLS, NON_DECRYPTABLE, enc_bls_key_len);",
      "",
      "---------------",
      "--- Hunk 35 ---",
      "[Context before]",
      "1064:     CHECK_STATE(bls_pub_key);",
      "1065:     CHECK_STATE(encryptedPrivateKey);",
      "1071:     CHECK_STATUS2(\"AES decrypt failed %d\");",
      "",
      "[Removed Lines]",
      "1067:     SAFE_CHAR_BUF(skey_hex, ECDSA_SKEY_LEN);",
      "1069:     int status = AES_decrypt(encryptedPrivateKey, key_len, skey_hex, ECDSA_SKEY_LEN);",
      "",
      "[Added Lines]",
      "1066:     SAFE_CHAR_BUF(skey_hex, BUF_LEN);",
      "1068:     int status = AES_decrypt(encryptedPrivateKey, key_len, skey_hex, BUF_LEN);",
      "",
      "---------------"
    ],
    "secure_enclave/secure_enclave.edl||secure_enclave/secure_enclave.edl": [
      "File: secure_enclave/secure_enclave.edl -> secure_enclave/secure_enclave.edl",
      "--- Hunk 1 ---",
      "[Context before]",
      "11:  trusted {",
      "12:   include \"sgx_tgmp.h\"",
      "17:         public void trustedGenerateSEK(",
      "18:                                 [out] int *errStatus,",
      "19:                                 [out, count = SMALL_BUF_SIZE] char *err_string,",
      "20:                                 [out, count = SMALL_BUF_SIZE] uint8_t *encrypted_SEK,",
      "22:                                 [out, count = 65] char* hex_SEK);",
      "24:         public void trustedSetSEK(",
      "",
      "[Removed Lines]",
      "14:   public void trustedEnclaveInit(uint32_t _logLevel);",
      "21:                                 [out] uint32_t *enc_len,",
      "",
      "[Added Lines]",
      "14:   public void trustedEnclaveInit(uint64_t _logLevel);",
      "21:                                 [out] uint64_t *enc_len,",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "30:                                 [out] int *errStatus,",
      "31:                                 [out, count = SMALL_BUF_SIZE] char *err_string,",
      "32:                                 [out, count = SMALL_BUF_SIZE] uint8_t *encrypted_SEK,",
      "34:                                 [in, string] const char* SEK_hex);",
      "36:         public void trustedGenerateEcdsaKeyAES (",
      "37:                                 [out] int *errStatus,",
      "38:                                 [out, count = SMALL_BUF_SIZE] char* err_string,",
      "39:                                 [out, count = SMALL_BUF_SIZE] uint8_t* encrypted_key,",
      "41:                                 [out, count = SMALL_BUF_SIZE] char * pub_key_x,",
      "42:                                 [out, count = SMALL_BUF_SIZE] char * pub_key_y);",
      "",
      "[Removed Lines]",
      "33:                                 [out] uint32_t *enc_len,",
      "40:                                 [out] uint32_t *enc_len,",
      "",
      "[Added Lines]",
      "33:                                 [out] uint64_t *enc_len,",
      "40:                                 [out] uint64_t *enc_len,",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "45:                                 [out] int *errStatus,",
      "46:                                 [out, count = SMALL_BUF_SIZE] char* err_string,",
      "47:                                 [in, count = SMALL_BUF_SIZE] uint8_t* encrypted_key,",
      "49:                                 [out, count = SMALL_BUF_SIZE] char * pub_key_x,",
      "50:                                 [out, count = SMALL_BUF_SIZE] char * pub_key_y);",
      "",
      "[Removed Lines]",
      "48:                                 uint32_t dec_len,",
      "",
      "[Added Lines]",
      "48:                                 uint64_t dec_len,",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "53:                                 [out] int *errStatus,",
      "54:                                 [out, count = SMALL_BUF_SIZE] char* err_string,",
      "55:                                 [in, count = SMALL_BUF_SIZE] uint8_t* encrypted_key,",
      "57:                                 [in, string] const char* hash,",
      "58:                                 [out, count = SMALL_BUF_SIZE] char* sig_r,",
      "59:                                 [out, count = SMALL_BUF_SIZE] char* sig_s,",
      "",
      "[Removed Lines]",
      "56:                                 uint32_t enc_len,",
      "",
      "[Added Lines]",
      "56:                                 uint64_t enc_len,",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "65:                                 [out, count = SMALL_BUF_SIZE] char* err_string,",
      "66:                                 [in, count = SMALL_BUF_SIZE] const char* key,",
      "67:                                 [out, count = SMALL_BUF_SIZE] uint8_t* encrypted_key,",
      "70:         public void trustedDecryptKeyAES (",
      "71:                                 [out] int *errStatus,",
      "72:                                 [out, count = SMALL_BUF_SIZE] char* err_string,",
      "73:                                 [in, count = SMALL_BUF_SIZE] uint8_t* encrypted_key,",
      "75:                                 [out, count = SMALL_BUF_SIZE] char* key );",
      "77:         public void trustedGenDkgSecretAES (",
      "78:                                 [out] int *errStatus,",
      "79:                                 [out, count = SMALL_BUF_SIZE] char* err_string,",
      "80:                                 [out, count = 3072] uint8_t* encrypted_dkg_secret,",
      "83:         public void trustedDecryptDkgSecretAES (",
      "84:                                 [out] int *errStatus,",
      "85:                                 [out, count = SMALL_BUF_SIZE] char* err_string,",
      "86:                                 [in, count = 3050] uint8_t* encrypted_dkg_secret,",
      "88:                                 [out, count = 3072] uint8_t* decrypted_dkg_secret",
      "89:                                 );",
      "",
      "[Removed Lines]",
      "68:                                 [out] uint32_t *enc_len);",
      "74:                                 uint32_t enc_len,",
      "81:                                 [out] uint32_t * enc_len, size_t _t);",
      "87:                                 uint32_t enc_len,",
      "",
      "[Added Lines]",
      "68:                                 [out] uint64_t *enc_len);",
      "74:                                 uint64_t enc_len,",
      "81:                                 [out] uint64_t * enc_len, size_t _t);",
      "87:                                 uint64_t enc_len,",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "92:                                 [out] int *errStatus,",
      "93:                                 [out, count = SMALL_BUF_SIZE] char* err_string,",
      "94:                                 [in, count = 3050] uint8_t* encrypted_poly,",
      "97:         public void trustedGetEncryptedSecretShareAES(",
      "98:                                 [out]int *errStatus,",
      "99:                                 [out, count = SMALL_BUF_SIZE] char *err_string,",
      "100:                                 [out, count = SMALL_BUF_SIZE] uint8_t *encrypted_skey,",
      "102:                                 [out, count = 193] char* result_str,",
      "103:                                 [out, count = 320] char* s_shareG2,",
      "104:                                 [in, string] char* pub_keyB,",
      "",
      "[Removed Lines]",
      "95:                                 uint32_t enc_len);",
      "101:                                 [out] uint32_t* dec_len,",
      "",
      "[Added Lines]",
      "95:                                 uint64_t enc_len);",
      "101:                                 [out] uint64_t* dec_len,",
      "",
      "---------------",
      "--- Hunk 7 ---",
      "[Context before]",
      "110:                                 [out] int *errStatus,",
      "111:                                 [out, count = SMALL_BUF_SIZE] char* err_string,",
      "112:                                 [in, count = 3050] uint8_t* encrypted_dkg_secret,",
      "114:                                 [out, count = 10000] char* public_shares,",
      "115:                                 unsigned _t,",
      "116:                                 unsigned _n);",
      "",
      "[Removed Lines]",
      "113:                                 uint32_t enc_len,",
      "",
      "[Added Lines]",
      "113:                                 uint64_t enc_len,",
      "",
      "---------------",
      "--- Hunk 8 ---",
      "[Context before]",
      "133:                                 [in, count = SMALL_BUF_SIZE] uint8_t* encrypted_key,",
      "134:                                 uint64_t key_len,",
      "135:                                 [out, count = SMALL_BUF_SIZE] uint8_t * encr_bls_key,",
      "138:         public void trustedBlsSignMessageAES (",
      "139:                                 [out] int *errStatus,",
      "140:                                 [out, count = TINY_BUF_SIZE] char* err_string,",
      "141:                                 [in, count = TINY_BUF_SIZE] uint8_t* encrypted_key,",
      "143:                                 [in, string] char* hashX ,",
      "144:                                 [in, string] char* hashY,",
      "145:                                 [out, count = SMALL_BUF_SIZE] char* signature);",
      "",
      "[Removed Lines]",
      "136:                                 [out] uint32_t *enc_bls_key_len);",
      "142:                                 uint32_t enc_len,",
      "",
      "[Added Lines]",
      "136:                                 [out] uint64_t *enc_bls_key_len);",
      "142:                                 uint64_t enc_len,",
      "",
      "---------------"
    ],
    "testw.cpp||testw.cpp": [
      "File: testw.cpp -> testw.cpp",
      "--- Hunk 1 ---",
      "[Context before]",
      "127:     vector<char> pubKeyX(BUF_LEN, 0);",
      "128:     vector<char> pubKeyY(BUF_LEN, 0);",
      "131:     PRINT_SRC_LINE",
      "132:     auto status = trustedGenerateEcdsaKeyAES(eid, &errStatus, errMsg.data(), encrPrivKey.data(), &encLen,",
      "133:                                              pubKeyX.data(),",
      "",
      "[Removed Lines]",
      "130:     uint32_t encLen = 0;",
      "",
      "[Added Lines]",
      "130:     uint64_t encLen = 0;",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "160:     vector <uint8_t> encrPrivKey(BUF_LEN, 0);",
      "161:     vector<char> pubKeyX(BUF_LEN, 0);",
      "162:     vector<char> pubKeyY(BUF_LEN, 0);",
      "164:     PRINT_SRC_LINE",
      "165:     auto status = trustedGenerateEcdsaKeyAES(eid, &errStatus, errMsg.data(), encrPrivKey.data(), &encLen,",
      "166:                                              pubKeyX.data(),",
      "",
      "[Removed Lines]",
      "163:     uint32_t encLen = 0;",
      "",
      "[Added Lines]",
      "163:     uint64_t encLen = 0;",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "177:     vector <uint8_t> encPrivKey(BUF_LEN, 0);",
      "178:     vector<char> pubKeyX(BUF_LEN, 0);",
      "179:     vector<char> pubKeyY(BUF_LEN, 0);",
      "182:     PRINT_SRC_LINE",
      "183:     auto status = trustedGenerateEcdsaKeyAES(eid, &errStatus, errMsg.data(), encPrivKey.data(), &encLen, pubKeyX.data(),",
      "",
      "[Removed Lines]",
      "180:     uint32_t encLen = 0;",
      "",
      "[Added Lines]",
      "181:     uint64_t encLen = 0;",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "291:     vector<char> errMsg(BUF_LEN, 0);",
      "293:     int errStatus = 0;",
      "296:     PRINT_SRC_LINE",
      "297:     auto status = trustedGenDkgSecretAES(eid, &errStatus, errMsg.data(), encryptedDKGSecret.data(), &encLen, 32);",
      "",
      "[Removed Lines]",
      "294:     uint32_t encLen = 0;",
      "",
      "[Added Lines]",
      "295:     uint64_t encLen = 0;",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "314:     vector<char> errMsg(BUF_LEN, 0);",
      "316:     int errStatus = 0;",
      "319:     unsigned t = 32, n = 32;",
      "320:     PRINT_SRC_LINE",
      "",
      "[Removed Lines]",
      "317:     uint32_t encLen = 0;",
      "",
      "[Added Lines]",
      "318:     uint64_t encLen = 0;",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "363:     vector<char> result(BUF_LEN, 0);",
      "365:     int errStatus = 0;",
      "368:     vector <uint8_t> encryptedDKGSecret(BUF_LEN, 0);",
      "369:     PRINT_SRC_LINE",
      "",
      "[Removed Lines]",
      "366:     uint32_t encLen = 0;",
      "",
      "[Added Lines]",
      "367:     uint64_t encLen = 0;",
      "",
      "---------------",
      "--- Hunk 7 ---",
      "[Context before]",
      "694: TEST_CASE_METHOD(TestFixture, \"AES encrypt/decrypt\", \"[aes-encrypt-decrypt]\") {",
      "695:     int errStatus = 0;",
      "696:     vector<char> errMsg(BUF_LEN, 0);",
      "698:     string key = SAMPLE_AES_KEY;",
      "699:     vector <uint8_t> encrypted_key(BUF_LEN, 0);",
      "",
      "[Removed Lines]",
      "697:     uint32_t encLen;",
      "",
      "[Added Lines]",
      "698:     uint64_t encLen;",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "24667d66f96de917af1ebf93ac174ed22f45a31e",
      "candidate_info": {
        "commit_hash": "24667d66f96de917af1ebf93ac174ed22f45a31e",
        "repo": "skalenetwork/sgxwallet",
        "commit_url": "https://github.com/skalenetwork/sgxwallet/commit/24667d66f96de917af1ebf93ac174ed22f45a31e",
        "files": [
          "ECDSACrypto.cpp",
          "sgxwallet_common.h"
        ],
        "message": "SKALE-3205",
        "before_after_code_files": [
          "ECDSACrypto.cpp||ECDSACrypto.cpp",
          "sgxwallet_common.h||sgxwallet_common.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/skalenetwork/sgxwallet/pull/176"
        ],
        "olp_code_files": {
          "patch": [
            "ECDSACrypto.cpp||ECDSACrypto.cpp"
          ],
          "candidate": [
            "ECDSACrypto.cpp||ECDSACrypto.cpp"
          ]
        }
      },
      "candidate_diff": {
        "ECDSACrypto.cpp||ECDSACrypto.cpp": [
          "File: ECDSACrypto.cpp -> ECDSACrypto.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "39: #include \"BLSCrypto.h\"",
          "41: #include \"ECDSACrypto.h\"",
          "43: void fillRandomBuffer(vector<unsigned char> &_buffer) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "41: #include \"SEKManager.h\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "59:     sgx_status_t status = SGX_SUCCESS;",
          "63:         status = trustedGenerateEcdsaKeyAES(eid, &errStatus,",
          "64:                                    errMsg.data(), encr_pr_key.data(), &enc_len,",
          "65:                                    pub_key_x.data(), pub_key_y.data());",
          "68:     HANDLE_TRUSTED_FUNCTION_ERROR(status, errStatus,errMsg.data());",
          "",
          "[Removed Lines]",
          "61:     {",
          "62:         READ_LOCK(initMutex);",
          "66:     }",
          "",
          "[Added Lines]",
          "62:     RESTART_BEGIN",
          "66:     RESTART_END",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "107:     sgx_status_t status = SGX_SUCCESS;",
          "111:         status = trustedGetPublicEcdsaKeyAES(eid, &errStatus,",
          "112:                                              errMsg.data(), encrPrKey.data(), enc_len, pubKeyX.data(), pubKeyY.data());",
          "115:     HANDLE_TRUSTED_FUNCTION_ERROR(status, errStatus, errMsg.data())",
          "",
          "[Removed Lines]",
          "109:     {",
          "110:         READ_LOCK(initMutex);",
          "113:     }",
          "",
          "[Added Lines]",
          "109:     RESTART_BEGIN",
          "112:     RESTART_END",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "197:     sgx_status_t status = SGX_SUCCESS;",
          "201:         status = trustedEcdsaSignAES(eid, &errStatus,",
          "202:                             errMsg.data(), encryptedKey.data(), decLen, hashHex,",
          "203:                             signatureR.data(),",
          "204:                             signatureS.data(), &signatureV, base);",
          "207:     HANDLE_TRUSTED_FUNCTION_ERROR(status, errStatus, errMsg.data());",
          "",
          "[Removed Lines]",
          "199:     {",
          "200:         READ_LOCK(initMutex);",
          "205:     }",
          "",
          "[Added Lines]",
          "198:     RESTART_BEGIN",
          "203:     RESTART_END",
          "",
          "---------------"
        ],
        "sgxwallet_common.h||sgxwallet_common.h": [
          "File: sgxwallet_common.h -> sgxwallet_common.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "124: spdlog::error(\"Restarting sgx ...\"); \\",
          "125: reinitEnclave(); \\",
          "126: } \\",
          "",
          "[Removed Lines]",
          "127: } while (__ATTEMPTS__ < 2);",
          "",
          "[Added Lines]",
          "127: } while (status != SGX_SUCCESS && __ATTEMPTS__ < 2);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "395a86cfb2b5009391f6d0e887711822600bf1c1",
      "candidate_info": {
        "commit_hash": "395a86cfb2b5009391f6d0e887711822600bf1c1",
        "repo": "skalenetwork/sgxwallet",
        "commit_url": "https://github.com/skalenetwork/sgxwallet/commit/395a86cfb2b5009391f6d0e887711822600bf1c1",
        "files": [
          "BLSCrypto.cpp",
          "sgxwallet_common.h"
        ],
        "message": "SKALE-3205",
        "before_after_code_files": [
          "BLSCrypto.cpp||BLSCrypto.cpp",
          "sgxwallet_common.h||sgxwallet_common.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/skalenetwork/sgxwallet/pull/176"
        ],
        "olp_code_files": {
          "patch": [
            "BLSCrypto.cpp||BLSCrypto.cpp"
          ],
          "candidate": [
            "BLSCrypto.cpp||BLSCrypto.cpp"
          ]
        }
      },
      "candidate_diff": {
        "BLSCrypto.cpp||BLSCrypto.cpp": [
          "File: BLSCrypto.cpp -> BLSCrypto.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "217:     sgx_status_t status = SGX_SUCCESS;",
          "224:             status = trustedBlsSignMessageAES(eid, &errStatus, errMsg.data(), encryptedKey,",
          "225:                                               sz, xStrArg, yStrArg, signature);",
          "238:     HANDLE_TRUSTED_FUNCTION_ERROR(status, errStatus, errMsg.data());",
          "",
          "[Removed Lines]",
          "218:     int attempts = 0;",
          "219:     do {",
          "220:         attempts++;",
          "221:         {",
          "222:             READ_LOCK(initMutex);",
          "227:         }",
          "228:         if (status != SGX_SUCCESS) {",
          "229:             spdlog::error(__FUNCTION__);",
          "230:             spdlog::error(\"Restarting sgx ...\");",
          "231:             reinitEnclave();",
          "232:         }",
          "233:     } while (attempts < 2);",
          "",
          "[Added Lines]",
          "219:     RESTART_BEGIN",
          "222:     RESTART_END",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "270:     uint64_t encryptedLen = 0;",
          "272:     sgx_status_t status = SGX_SUCCESS;",
          "275:         status = trustedEncryptKeyAES(eid, errStatus, errMsg.data(), keyArray->data(), encryptedKey->data(),",
          "276:                                       &encryptedLen);",
          "279:     HANDLE_TRUSTED_FUNCTION_ERROR(status, *errStatus, errMsg.data());",
          "281:     SAFE_CHAR_BUF(resultBuf, 2 * BUF_LEN + 1);",
          "",
          "[Removed Lines]",
          "273:     {",
          "274:         READ_LOCK(initMutex);",
          "278:     }",
          "",
          "[Added Lines]",
          "261:     RESTART_BEGIN",
          "264:     RESTART_END",
          "",
          "---------------"
        ],
        "sgxwallet_common.h||sgxwallet_common.h": [
          "File: sgxwallet_common.h -> sgxwallet_common.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "110: #define TEST_VALUE \"1234567890\"",
          "112: #endif //SGXWALLET_SGXWALLET_COMMON_H",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "113: #define RESTART_BEGIN \\",
          "114: int __ATTEMPTS__ = 0; \\",
          "115: do {\\",
          "116: __ATTEMPTS__++; \\",
          "117: {\\",
          "118: READ_LOCK(initMutex);",
          "120: #define RESTART_END \\",
          "121: } \\",
          "122: if (status != SGX_SUCCESS) { \\",
          "123: spdlog::error(__FUNCTION__); \\",
          "124: spdlog::error(\"Restarting sgx ...\"); \\",
          "125: reinitEnclave(); \\",
          "126: } \\",
          "127: } while (__ATTEMPTS__ < 2);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "3ca5236e9bd041facec62f698242b9ca8407170f",
      "candidate_info": {
        "commit_hash": "3ca5236e9bd041facec62f698242b9ca8407170f",
        "repo": "skalenetwork/sgxwallet",
        "commit_url": "https://github.com/skalenetwork/sgxwallet/commit/3ca5236e9bd041facec62f698242b9ca8407170f",
        "files": [
          "BLSPrivateKeyShareSGX.cpp"
        ],
        "message": "quit@ :qui",
        "before_after_code_files": [
          "BLSPrivateKeyShareSGX.cpp||BLSPrivateKeyShareSGX.cpp"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/skalenetwork/sgxwallet/pull/176"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "BLSPrivateKeyShareSGX.cpp||BLSPrivateKeyShareSGX.cpp": [
          "File: BLSPrivateKeyShareSGX.cpp -> BLSPrivateKeyShareSGX.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "149:     }",
          "151:     sgx_status_t status = SGX_SUCCESS;",
          "154:         status = trustedBlsSignMessageAES(eid, &errStatus, errMsg.data(), encryptedKey,",
          "155:                                           encryptedKeyHex->size() / 2, xStrArg, yStrArg, signature);",
          "158:     HANDLE_TRUSTED_FUNCTION_ERROR(status, errStatus, errMsg.data());",
          "",
          "[Removed Lines]",
          "152:     {",
          "153:         READ_LOCK(initMutex);",
          "156:     }",
          "",
          "[Added Lines]",
          "153:     RESTART_BEGIN",
          "156:     RESTART_END",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "9e2d76c5d05be742d6cb92a271c923390e1afdba",
      "candidate_info": {
        "commit_hash": "9e2d76c5d05be742d6cb92a271c923390e1afdba",
        "repo": "skalenetwork/sgxwallet",
        "commit_url": "https://github.com/skalenetwork/sgxwallet/commit/9e2d76c5d05be742d6cb92a271c923390e1afdba",
        "files": [
          "SGXWALLET_VERSION",
          "secure_enclave/EnclaveCommon.cpp",
          "secure_enclave/EnclaveCommon.h",
          "secure_enclave/secure_enclave.c"
        ],
        "message": "Fixed docs",
        "before_after_code_files": [
          "secure_enclave/EnclaveCommon.cpp||secure_enclave/EnclaveCommon.cpp",
          "secure_enclave/EnclaveCommon.h||secure_enclave/EnclaveCommon.h",
          "secure_enclave/secure_enclave.c||secure_enclave/secure_enclave.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "secure_enclave/secure_enclave.c||secure_enclave/secure_enclave.c"
          ],
          "candidate": [
            "secure_enclave/secure_enclave.c||secure_enclave/secure_enclave.c"
          ]
        }
      },
      "candidate_diff": {
        "secure_enclave/EnclaveCommon.cpp||secure_enclave/EnclaveCommon.cpp": [
          "File: secure_enclave/EnclaveCommon.cpp -> secure_enclave/EnclaveCommon.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "298: EXTERNC void LOG_INFO(char* _msg) {",
          "299:     logMsg(L_INFO, _msg);",
          "300: };",
          "302:     logMsg(L_WARNING, _msg);",
          "303: };",
          "",
          "[Removed Lines]",
          "301: EXTERNC void LOG_WARNING(char* _msg) {",
          "",
          "[Added Lines]",
          "301: EXTERNC void LOG_WARN(char* _msg) {",
          "",
          "---------------"
        ],
        "secure_enclave/EnclaveCommon.h||secure_enclave/EnclaveCommon.h": [
          "File: secure_enclave/EnclaveCommon.h -> secure_enclave/EnclaveCommon.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "55: EXTERNC void LOG_INFO(char* msg);",
          "57: EXTERNC void LOG_ERROR(char* _msg);",
          "58: EXTERNC void LOG_DEBUG(char* _msg);",
          "59: EXTERNC void LOG_TRACE(char* _msg);",
          "",
          "[Removed Lines]",
          "56: EXTERNC void LOG_WARNING(char* _msg);",
          "",
          "[Added Lines]",
          "56: EXTERNC void LOG_WARN(char* _msg);",
          "",
          "---------------"
        ],
        "secure_enclave/secure_enclave.c||secure_enclave/secure_enclave.c": [
          "File: secure_enclave/secure_enclave.c -> secure_enclave/secure_enclave.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "137: void trustedEMpfDiv(mpf_t *c_un, mpf_t *a_un, mpf_t *b_un) {}",
          "143:     LOG_DEBUG (__FUNCTION__);",
          "",
          "[Removed Lines]",
          "140: void trustedGenerateEcdsaKey(int *errStatus, char *err_string,",
          "141:                         uint8_t *encrypted_key, uint32_t *enc_len, char *pub_key_x, char *pub_key_y) {",
          "",
          "[Added Lines]",
          "140: void trustedGenerateEcdsaKey(int *errStatus, char *errString,",
          "141:                         uint8_t *encryptedPrivateKey, uint32_t *enc_len, char *pub_key_x, char *pub_key_y) {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "194:     strncpy(pub_key_y + n_zeroes, arr_y, 1024 - n_zeroes);",
          "195:     char skey_str[mpz_sizeinbase(skey, ECDSA_SKEY_BASE) + 2];",
          "196:     char *s = mpz_get_str(skey_str, ECDSA_SKEY_BASE, skey);",
          "199:     uint32_t sealedLen = sgx_calc_sealed_data_size(0, ECDSA_SKEY_LEN);",
          "201:     sgx_status_t status = sgx_seal_data(0, NULL, ECDSA_SKEY_LEN, (uint8_t *) skey_str, sealedLen,",
          "203:     if (status != SGX_SUCCESS) {",
          "206:         return;",
          "207:     }",
          "",
          "[Removed Lines]",
          "197:     snprintf(err_string, BUF_LEN, \"skey is %s len %d\\n\", skey_str, strlen(skey_str));",
          "202:                                         (sgx_sealed_data_t *) encrypted_key);",
          "204:         snprintf(err_string, BUF_LEN, \"seal ecsdsa private key failed\");",
          "",
          "[Added Lines]",
          "197:     snprintf(errString, BUF_LEN, \"skey is %s len %d\\n\", skey_str, strlen(skey_str));",
          "202:                                         (sgx_sealed_data_t *) encryptedPrivateKey);",
          "204:         snprintf(errString, BUF_LEN, \"seal ecsdsa private key failed\");",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "214: }",
          "220:     LOG_DEBUG (__FUNCTION__);",
          "",
          "[Removed Lines]",
          "217: void trustedGetPublicEcdsaKey(int *errStatus, char *err_string,",
          "218:                           uint8_t *encrypted_key, uint32_t dec_len, char *pub_key_x, char *pub_key_y) {",
          "",
          "[Added Lines]",
          "217: void trustedGetPublicEcdsaKey(int *errStatus, char *errString,",
          "218:                           uint8_t *encryptedPrivateKey, uint32_t dec_len, char *pub_key_x, char *pub_key_y) {",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "225:     char skey[ECDSA_SKEY_LEN];",
          "227:     sgx_status_t status = sgx_unseal_data(",
          "230:     if (status != SGX_SUCCESS) {",
          "233:         return;",
          "234:     }",
          "245:         return;",
          "246:     }",
          "249:     point Pkey = point_init();",
          "253:     point Pkey_test = point_init();",
          "256:     if (!point_cmp(Pkey, Pkey_test)) {",
          "259:         return;",
          "260:     }",
          "",
          "[Removed Lines]",
          "228:             (const sgx_sealed_data_t *) encrypted_key, NULL, 0, (uint8_t *) skey, &dec_len);",
          "231:         snprintf(err_string, BUF_LEN, \"sgx_unseal_data failed with status %d\", status);",
          "238:     mpz_t secretKeyMpz;",
          "239:     mpz_init(secretKeyMpz);",
          "241:     if (mpz_set_str(secretKeyMpz, skey, ECDSA_SKEY_BASE) == -1) {",
          "242:         snprintf(err_string, BUF_LEN, \"wrong string to init private key\");",
          "244:         mpz_clear(secretKeyMpz);",
          "251:     signature_extract_public_key(Pkey, secretKeyMpz, curve);",
          "254:     point_multiplication(Pkey_test, secretKeyMpz, curve->G, curve);",
          "257:         snprintf(err_string, BUF_LEN, \"Points are not equal\");",
          "",
          "[Added Lines]",
          "228:             (const sgx_sealed_data_t *) encryptedPrivateKey, NULL, 0, (uint8_t *) skey, &dec_len);",
          "231:         snprintf(errString, BUF_LEN, \"sgx_unseal_data failed with status %d\", status);",
          "238:     mpz_t privateKeyMpz;",
          "239:     mpz_init(privateKeyMpz);",
          "241:     if (mpz_set_str(privateKeyMpz, skey, ECDSA_SKEY_BASE) == -1) {",
          "242:         snprintf(errString, BUF_LEN, \"wrong string to init private key\");",
          "244:         mpz_clear(privateKeyMpz);",
          "251:     signature_extract_public_key(Pkey, privateKeyMpz, curve);",
          "254:     point_multiplication(Pkey_test, privateKeyMpz, curve->G, curve);",
          "257:         snprintf(errString, BUF_LEN, \"Points are not equal\");",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "281:     }",
          "282:     strncpy(pub_key_y + n_zeroes, arr_y, 1024 - n_zeroes);",
          "285:     domain_parameters_clear(curve);",
          "286:     point_clear(Pkey);",
          "287: }",
          "290:                  unsigned char *hash, char *sigR, char *sigS, uint8_t *sig_v, int base) {",
          "292:     LOG_DEBUG (__FUNCTION__);",
          "",
          "[Removed Lines]",
          "284:     mpz_clear(secretKeyMpz);",
          "289: void trustedEcdsaSign(int *errStatus, char *err_string, uint8_t *encrypted_key, uint32_t dec_len,",
          "",
          "[Added Lines]",
          "284:     mpz_clear(privateKeyMpz);",
          "289: void trustedEcdsaSign(int *errStatus, char *errString, uint8_t *encryptedPrivateKey, uint32_t dec_len,",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "295:     char* arrR = NULL;",
          "296:     char* arrS = NULL;",
          "302:     mpz_t msgMpz;",
          "303:     mpz_init(msgMpz);",
          "",
          "[Removed Lines]",
          "298:     char* secretKey = calloc(ECDSA_SKEY_LEN,1);",
          "300:     mpz_t secretKeyMpz;",
          "301:     mpz_init(secretKeyMpz);",
          "",
          "[Added Lines]",
          "298:     char* privateKey = calloc(ECDSA_SKEY_LEN,1);",
          "300:     mpz_t privateKeyMpz;",
          "301:     mpz_init(privateKeyMpz);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "310:     point publicKey = point_init();",
          "314:     sgx_status_t status = sgx_unseal_data(",
          "317:     if (status != SGX_SUCCESS) {",
          "320:         goto clean;",
          "321:     }",
          "328:         goto clean;",
          "329:     }",
          "331:     if (mpz_set_str(msgMpz, hash, 16) == -1) {",
          "334:         goto clean;",
          "335:     }",
          "341:     if (!signature_verify(msgMpz, sign, publicKey, curve)) {",
          "344:         goto clean;",
          "345:     }",
          "",
          "[Removed Lines]",
          "315:             (const sgx_sealed_data_t *) encrypted_key, NULL, 0, secretKey, &dec_len);",
          "319:         snprintf(err_string, BUF_LEN, \"sgx_unseal_data failed - encrypted_key with status %d\", status);",
          "325:     if (mpz_set_str(secretKeyMpz, secretKey, ECDSA_SKEY_BASE) == -1) {",
          "327:         snprintf(err_string, BUF_LEN, \"invalid secret key\");",
          "333:         snprintf(err_string, BUF_LEN, \"invalid message hash\");",
          "337:     signature_sign(sign, msgMpz, secretKeyMpz, curve);",
          "339:     signature_extract_public_key(publicKey, secretKeyMpz, curve);",
          "343:         snprintf(err_string, BUF_LEN, \"signature is not verified\");",
          "",
          "[Added Lines]",
          "313:     if (!hash) {",
          "315:         LOG_WARN(\"NULL message hash\");",
          "316:         snprintf(errString, BUF_LEN, \"NULL message hash\");",
          "317:         goto clean;",
          "318:     }",
          "320:     if (!hash) {",
          "322:         char* msg = \"NULL message hash\";",
          "323:         LOG_ERROR(msg);",
          "324:         snprintf(errString, BUF_LEN, msg);",
          "325:         goto clean;",
          "326:     }",
          "328:     if (!encryptedPrivateKey) {",
          "330:         snprintf(errString, BUF_LEN, \"NULL encrypted ECDSA private key\");",
          "331:         LOG_ERROR(errString);",
          "332:         goto clean;",
          "333:     }",
          "338:             (const sgx_sealed_data_t *) encryptedPrivateKey, NULL, 0, privateKey, &dec_len);",
          "342:         snprintf(errString, BUF_LEN,",
          "343:                 \"sgx_unseal_data failed for encryptedPrivateKey:status %d\", status);",
          "344:         LOG_ERROR(errString);",
          "349:     if (mpz_set_str(privateKeyMpz, privateKey, ECDSA_SKEY_BASE) == -1) {",
          "351:         snprintf(errString, BUF_LEN, \"mpz_set_str(privateKeyMpz ...) failed\");",
          "352:         LOG_ERROR(errString);",
          "359:         snprintf(errString, BUF_LEN, \"invalid message hash %s\", hash);",
          "360:         LOG_WARN(errString);",
          "364:     signature_sign(sign, msgMpz, privateKeyMpz, curve);",
          "366:     signature_extract_public_key(publicKey, privateKeyMpz, curve);",
          "370:         snprintf(errString, BUF_LEN, \"ECDSA sig not verified\");",
          "371:         LOG_WARN(errString);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "360:     clean:",
          "363:     mpz_clear(msgMpz);",
          "364:     domain_parameters_clear(curve);",
          "365:     point_clear(publicKey);",
          "369:     signature_free(sign);",
          "374:     if (arrM) {",
          "375:         free(arrM);",
          "",
          "[Removed Lines]",
          "362:     mpz_clear(secretKeyMpz);",
          "371:     if (secretKey)",
          "372:         free(secretKey);",
          "",
          "[Added Lines]",
          "389:     mpz_clear(privateKeyMpz);",
          "396:     if (privateKey)",
          "397:         free(privateKey);",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "387: }",
          "393:     LOG_DEBUG (__FUNCTION__);",
          "401:     if (*errStatus != 0) {",
          "403:         return;",
          "404:     }",
          "",
          "[Removed Lines]",
          "390: void trustedEncryptKey(int *errStatus, char *err_string, char *key,",
          "391:                  uint8_t *encrypted_key, uint32_t *enc_len) {",
          "397:     memset(err_string, 0, BUF_LEN);",
          "399:     checkKey(errStatus, err_string, key);",
          "402:         snprintf(err_string + strlen(err_string), BUF_LEN, \"check_key failed\");",
          "",
          "[Added Lines]",
          "415: void trustedEncryptKey(int *errStatus, char *errString, char *key,",
          "416:                  uint8_t *encryptedPrivateKey, uint32_t *enc_len) {",
          "422:     memset(errString, 0, BUF_LEN);",
          "424:     checkKey(errStatus, errString, key);",
          "427:         snprintf(errString + strlen(errString), BUF_LEN, \"check_key failed\");",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "409:     if (sealedLen > BUF_LEN) {",
          "412:         return;",
          "413:     }",
          "418:     sgx_status_t status = sgx_seal_data(0, NULL, MAX_KEY_LENGTH, (uint8_t *) key, sealedLen,",
          "420:     if (status != SGX_SUCCESS) {",
          "423:         return;",
          "424:     }",
          "",
          "[Removed Lines]",
          "411:         snprintf(err_string, BUF_LEN, \"sealedLen > MAX_ENCRYPTED_KEY_LENGTH\");",
          "416:     memset(encrypted_key, 0, BUF_LEN);",
          "419:                                         (sgx_sealed_data_t *) encrypted_key);",
          "422:         snprintf(err_string, BUF_LEN, \"SGX seal data failed with status %d\", status);",
          "",
          "[Added Lines]",
          "436:         snprintf(errString, BUF_LEN, \"sealedLen > MAX_ENCRYPTED_KEY_LENGTH\");",
          "441:     memset(encryptedPrivateKey, 0, BUF_LEN);",
          "444:                                         (sgx_sealed_data_t *) encryptedPrivateKey);",
          "447:         snprintf(errString, BUF_LEN, \"SGX seal data failed with status %d\", status);",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "428:     char decryptedKey[BUF_LEN];",
          "429:     memset(decryptedKey, 0, BUF_LEN);",
          "433:     if (*errStatus != 0) {",
          "435:         return;",
          "436:     }",
          "438:     uint64_t decryptedKeyLen = strnlen(decryptedKey, MAX_KEY_LENGTH);",
          "440:     if (decryptedKeyLen == MAX_KEY_LENGTH) {",
          "442:         return;",
          "443:     }",
          "",
          "[Removed Lines]",
          "431:     trustedDecryptKey(errStatus, err_string, encrypted_key, sealedLen, decryptedKey);",
          "434:         snprintf(err_string + strlen(err_string), BUF_LEN, \":trustedDecryptKey failed\");",
          "441:         snprintf(err_string, BUF_LEN, \"Decrypted key is not null terminated\");",
          "",
          "[Added Lines]",
          "456:     trustedDecryptKey(errStatus, errString, encryptedPrivateKey, sealedLen, decryptedKey);",
          "459:         snprintf(errString + strlen(errString), BUF_LEN, \":trustedDecryptKey failed\");",
          "466:         snprintf(errString, BUF_LEN, \"Decrypted key is not null terminated\");",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "448:     if (strncmp(key, decryptedKey, MAX_KEY_LENGTH) != 0) {",
          "450:         return;",
          "451:     }",
          "454: }",
          "457:                  uint32_t enc_len, char *key) {",
          "459:     LOG_DEBUG (__FUNCTION__);",
          "",
          "[Removed Lines]",
          "449:         snprintf(err_string, BUF_LEN, \"Decrypted key does not match original key\");",
          "456: void trustedDecryptKey(int *errStatus, char *err_string, uint8_t *encrypted_key,",
          "",
          "[Added Lines]",
          "474:         snprintf(errString, BUF_LEN, \"Decrypted key does not match original key\");",
          "481: void trustedDecryptKey(int *errStatus, char *errString, uint8_t *encryptedPrivateKey,",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "465:     sgx_status_t status = sgx_unseal_data(",
          "468:     if (status != SGX_SUCCESS) {",
          "471:         return;",
          "472:     }",
          "476:     if (decLen > MAX_KEY_LENGTH) {",
          "478:         return;",
          "479:     }",
          "",
          "[Removed Lines]",
          "466:             (const sgx_sealed_data_t *) encrypted_key, NULL, 0, (uint8_t *) key, &decLen);",
          "470:         snprintf(err_string, BUF_LEN, \"sgx_unseal_data failed with status %d\", status);",
          "477:         snprintf(err_string, BUF_LEN, \"wrong decLen\");//\"decLen != MAX_KEY_LENGTH\");",
          "",
          "[Added Lines]",
          "491:             (const sgx_sealed_data_t *) encryptedPrivateKey, NULL, 0, (uint8_t *) key, &decLen);",
          "495:         snprintf(errString, BUF_LEN, \"sgx_unseal_data failed with status %d\", status);",
          "502:         snprintf(errString, BUF_LEN, \"wrong decLen\");//\"decLen != MAX_KEY_LENGTH\");",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "487:     if (keyLen == MAX_KEY_LENGTH) {",
          "489:         return;",
          "490:     }",
          "",
          "[Removed Lines]",
          "488:         snprintf(err_string, BUF_LEN, \"Key is not null terminated\");",
          "",
          "[Added Lines]",
          "513:         snprintf(errString, BUF_LEN, \"Key is not null terminated\");",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "495: }",
          "499:                       uint32_t enc_len, char *_hashX,",
          "500:                       char *_hashY, char *signature) {",
          "",
          "[Removed Lines]",
          "498: void trustedBlsSignMessage(int *errStatus, char *err_string, uint8_t *encrypted_key,",
          "",
          "[Added Lines]",
          "523: void trustedBlsSignMessage(int *errStatus, char *errString, uint8_t *encryptedPrivateKey,",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "513:     if (*errStatus != 0) {",
          "515:         return;",
          "516:     }",
          "",
          "[Removed Lines]",
          "511:     trustedDecryptKey(errStatus, err_string, encrypted_key, enc_len, key);",
          "514:         strncpy(signature, err_string, BUF_LEN);",
          "",
          "[Added Lines]",
          "536:     trustedDecryptKey(errStatus, errString, encryptedPrivateKey, enc_len, key);",
          "539:         strncpy(signature, errString, BUF_LEN);",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "527:     free(sig);",
          "528: }",
          "532:     LOG_DEBUG (__FUNCTION__);",
          "",
          "[Removed Lines]",
          "530: void trustedGenDkgSecret(int *errStatus, char *err_string, uint8_t *encrypted_dkg_secret, uint32_t *enc_len, size_t _t) {",
          "",
          "[Added Lines]",
          "555: void trustedGenDkgSecret(int *errStatus, char *errString, uint8_t *encrypted_dkg_secret, uint32_t *enc_len, size_t _t) {",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "538:         return;",
          "539:     }",
          "543:     uint32_t sealedLen = sgx_calc_sealed_data_size(0,",
          "544:                                                    DKG_BUFER_LENGTH);//sizeof(sgx_sealed_data_t) +  sizeof(dkg_secret);",
          "",
          "[Removed Lines]",
          "541:     snprintf(err_string, BUF_LEN, \"poly is %s \", dkg_secret);",
          "",
          "[Added Lines]",
          "566:     snprintf(errString, BUF_LEN, \"poly is %s \", dkg_secret);",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "547:                                         (sgx_sealed_data_t *) encrypted_dkg_secret);",
          "549:     if (status != SGX_SUCCESS) {",
          "552:         return;",
          "553:     }",
          "",
          "[Removed Lines]",
          "550:         snprintf(err_string, BUF_LEN, \"SGX seal data failed\");",
          "",
          "[Added Lines]",
          "575:         snprintf(errString, BUF_LEN, \"SGX seal data failed\");",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "557: }",
          "560:                         uint32_t *dec_len) {",
          "562:     LOG_DEBUG (__FUNCTION__);",
          "",
          "[Removed Lines]",
          "559: void trustedDecryptDkgSecret(int *errStatus, char *err_string, uint8_t *encrypted_dkg_secret, uint8_t *decrypted_dkg_secret,",
          "",
          "[Added Lines]",
          "584: void trustedDecryptDkgSecret(int *errStatus, char *errString, uint8_t *encrypted_dkg_secret, uint8_t *decrypted_dkg_secret,",
          "",
          "---------------",
          "--- Hunk 21 ---",
          "[Context before]",
          "567:             (const sgx_sealed_data_t *) encrypted_dkg_secret, NULL, 0, decrypted_dkg_secret, &decr_len);",
          "569:     if (status != SGX_SUCCESS) {",
          "572:         return;",
          "573:     }",
          "",
          "[Removed Lines]",
          "570:         snprintf(err_string, BUF_LEN, \"sgx_unseal_data - encrypted_dkg_secret failed with status %d\", status);",
          "",
          "[Added Lines]",
          "595:         snprintf(errString, BUF_LEN, \"sgx_unseal_data - encrypted_dkg_secret failed with status %d\", status);",
          "",
          "---------------",
          "--- Hunk 22 ---",
          "[Context before]",
          "576: }",
          "579:                        char *secret_shares,",
          "580:                        unsigned _t, unsigned _n) {",
          "",
          "[Removed Lines]",
          "578: void trustedGetSecretShares(int *errStatus, char *err_string, uint8_t *encrypted_dkg_secret, uint32_t *dec_len,",
          "",
          "[Added Lines]",
          "603: void trustedGetSecretShares(int *errStatus, char *errString, uint8_t *encrypted_dkg_secret, uint32_t *dec_len,",
          "",
          "---------------",
          "--- Hunk 23 ---",
          "[Context before]",
          "584:     char decrypted_dkg_secret[DKG_BUFER_LENGTH];",
          "586:     uint32_t decr_len;",
          "589:     if (*errStatus != 0) {",
          "591:         return;",
          "592:     }",
          "597:     calc_secret_shares(decrypted_dkg_secret, secret_shares, _t, _n);",
          "599: }",
          "602:                        char *public_shares,",
          "603:                        unsigned _t, unsigned _n) {",
          "",
          "[Removed Lines]",
          "587:     trustedDecryptDkgSecret(errStatus, err_string, encrypted_dkg_secret, (uint8_t *) decrypted_dkg_secret, &decr_len);",
          "590:         snprintf(err_string, BUF_LEN, \"sgx_unseal_data - encrypted_dkg_secret failed with status %d\", *errStatus);",
          "601: void trustedGetPublicShares(int *errStatus, char *err_string, uint8_t *encrypted_dkg_secret, uint32_t enc_len,",
          "",
          "[Added Lines]",
          "612:     trustedDecryptDkgSecret(errStatus, errString, encrypted_dkg_secret, (uint8_t *) decrypted_dkg_secret, &decr_len);",
          "615:         snprintf(errString, BUF_LEN, \"sgx_unseal_data - encrypted_dkg_secret failed with status %d\", *errStatus);",
          "626: void trustedGetPublicShares(int *errStatus, char *errString, uint8_t *encrypted_dkg_secret, uint32_t enc_len,",
          "",
          "---------------",
          "--- Hunk 24 ---",
          "[Context before]",
          "607:     char *decrypted_dkg_secret = (char *) calloc(DKG_MAX_SEALED_LEN, 1);",
          "608:     uint32_t decr_len;",
          "610:     if (*errStatus != 0) {",
          "612:         return;",
          "613:     }",
          "616:     if (calc_public_shares(decrypted_dkg_secret, public_shares, _t) != 0) {",
          "619:         return;",
          "620:     }",
          "621:     free(decrypted_dkg_secret);",
          "622: }",
          "626:     memset(decryptedDkgPoly, 0, DKG_BUFER_LENGTH);",
          "627:     uint32_t decr_len;",
          "628:     sgx_status_t status = sgx_unseal_data(",
          "",
          "[Removed Lines]",
          "609:     trustedDecryptDkgSecret(errStatus, err_string, (uint8_t *) encrypted_dkg_secret, decrypted_dkg_secret, &decr_len);",
          "611:         snprintf(err_string, BUF_LEN, \"trustedDecryptDkgSecret failed with status %d\", *errStatus);",
          "618:         snprintf(err_string, BUF_LEN, \"t does not match polynomial in db\");",
          "625: void trustedSetEncryptedDkgPoly(int *errStatus, char *err_string, uint8_t *encrypted_poly) {",
          "",
          "[Added Lines]",
          "634:     trustedDecryptDkgSecret(errStatus, errString, (uint8_t *) encrypted_dkg_secret, decrypted_dkg_secret, &decr_len);",
          "636:         snprintf(errString, BUF_LEN, \"trustedDecryptDkgSecret failed with status %d\", *errStatus);",
          "643:         snprintf(errString, BUF_LEN, \"t does not match polynomial in db\");",
          "650: void trustedSetEncryptedDkgPoly(int *errStatus, char *errString, uint8_t *encrypted_poly) {",
          "",
          "---------------",
          "--- Hunk 25 ---",
          "[Context before]",
          "631:     if (status != SGX_SUCCESS) {",
          "634:         return;",
          "635:     }",
          "637: }",
          "640:                      char *result_str, char *s_shareG2, char *pub_keyB, uint8_t _t, uint8_t _n, uint8_t ind) {",
          "642:     LOG_DEBUG (__FUNCTION__);",
          "",
          "[Removed Lines]",
          "633:         snprintf(err_string, BUF_LEN, \"sgx_unseal_data - encrypted_poly failed with status %d\", status);",
          "639: void trustedGetEncryptedSecretShare(int *errStatus, char *err_string, uint8_t *encrypted_skey, uint32_t *dec_len,",
          "",
          "[Added Lines]",
          "658:         snprintf(errString, BUF_LEN, \"sgx_unseal_data - encrypted_poly failed with status %d\", status);",
          "664: void trustedGetEncryptedSecretShare(int *errStatus, char *errString, uint8_t *encrypted_skey, uint32_t *dec_len,",
          "",
          "---------------",
          "--- Hunk 26 ---",
          "[Context before]",
          "652:     uint32_t enc_len;",
          "655:     if (*errStatus != 0) {",
          "656:         return;",
          "657:     }",
          "",
          "[Removed Lines]",
          "654:     trustedGenerateEcdsaKey(errStatus, err_string, encrypted_skey, &enc_len, pub_key_x, pub_key_y);",
          "",
          "[Added Lines]",
          "679:     trustedGenerateEcdsaKey(errStatus, errString, encrypted_skey, &enc_len, pub_key_x, pub_key_y);",
          "",
          "---------------",
          "--- Hunk 27 ---",
          "[Context before]",
          "662:             (const sgx_sealed_data_t *) encrypted_skey, NULL, 0, (uint8_t *) skey, &enc_len);",
          "664:     if (status != SGX_SUCCESS) {",
          "667:         return;",
          "668:     }",
          "671:     char *common_key[ECDSA_SKEY_LEN];",
          "672:     gen_session_key(skey, pub_keyB, common_key);",
          "",
          "[Removed Lines]",
          "665:         snprintf(err_string, BUF_LEN, \"sgx_unseal_data failed - encrypted_skey with status %d\", status);",
          "669:     snprintf(err_string, BUF_LEN, \"unsealed random skey is %s\\n\", skey);",
          "",
          "[Added Lines]",
          "690:         snprintf(errString, BUF_LEN, \"sgx_unseal_data failed - encrypted_skey with status %d\", status);",
          "694:     snprintf(errString, BUF_LEN, \"unsealed random skey is %s\\n\", skey);",
          "",
          "---------------",
          "--- Hunk 28 ---",
          "[Context before]",
          "676:     if (calc_secret_share(decryptedDkgPoly, s_share, _t, _n, ind) != 0) {",
          "679:         return;",
          "680:     }",
          "683:     if (calc_secret_shareG2(s_share, s_shareG2) != 0) {",
          "686:         return;",
          "687:     }",
          "",
          "[Removed Lines]",
          "678:         snprintf(err_string, BUF_LEN, \"\\nt does not match poly degree\\n\");",
          "681:     snprintf(err_string + 88, BUF_LEN, \"\\nsecret share is %s\", s_share);",
          "685:         snprintf(err_string, BUF_LEN, \"invalid decr secret share\\n\");",
          "",
          "[Added Lines]",
          "703:         snprintf(errString, BUF_LEN, \"\\nt does not match poly degree\\n\");",
          "706:     snprintf(errString + 88, BUF_LEN, \"\\nsecret share is %s\", s_share);",
          "710:         snprintf(errString, BUF_LEN, \"invalid decr secret share\\n\");",
          "",
          "---------------",
          "--- Hunk 29 ---",
          "[Context before]",
          "690:     xor_encrypt(common_key, s_share, cypher);",
          "691:     if (cypher == NULL) {",
          "694:         return;",
          "695:     }",
          "",
          "[Removed Lines]",
          "693:         snprintf(err_string, BUF_LEN, \"invalid common_key\");",
          "",
          "[Added Lines]",
          "718:         snprintf(errString, BUF_LEN, \"invalid common_key\");",
          "",
          "---------------",
          "--- Hunk 30 ---",
          "[Context before]",
          "702: }",
          "705:                         uint32_t *dec_len,",
          "706:                         char *DH_key, char *s_shareG2, uint8_t _t, uint8_t _n, uint8_t ind1) {",
          "",
          "[Removed Lines]",
          "704: void trustedComplaintResponse(int *errStatus, char *err_string, uint8_t *encryptedDHKey, uint8_t *encrypted_dkg_secret,",
          "",
          "[Added Lines]",
          "729: void trustedComplaintResponse(int *errStatus, char *errString, uint8_t *encryptedDHKey, uint8_t *encrypted_dkg_secret,",
          "",
          "---------------",
          "--- Hunk 31 ---",
          "[Context before]",
          "713:     char decrypted_dkg_secret[DKG_BUFER_LENGTH];",
          "714:     uint32_t decr_len;",
          "716:     if (*errStatus != 0) {",
          "718:         return;",
          "719:     }",
          "",
          "[Removed Lines]",
          "715:     trustedDecryptDkgSecret(errStatus, err_string, encrypted_dkg_secret, (uint8_t *) decrypted_dkg_secret, &decr_len);",
          "717:         snprintf(err_string, BUF_LEN, \"sgx_unseal_data - encrypted_dkg_secret failed with status %d\", *errStatus);",
          "",
          "[Added Lines]",
          "740:     trustedDecryptDkgSecret(errStatus, errString, encrypted_dkg_secret, (uint8_t *) decrypted_dkg_secret, &decr_len);",
          "742:         snprintf(errString, BUF_LEN, \"sgx_unseal_data - encrypted_dkg_secret failed with status %d\", *errStatus);",
          "",
          "---------------",
          "--- Hunk 32 ---",
          "[Context before]",
          "723: }",
          "729:     LOG_DEBUG (__FUNCTION__);",
          "731:     char skey[ECDSA_SKEY_LEN];",
          "732:     sgx_status_t status = sgx_unseal_data(",
          "734:     if (status != SGX_SUCCESS) {",
          "737:         return;",
          "738:     }",
          "",
          "[Removed Lines]",
          "725: void trustedDkgVerify(int *errStatus, char *err_string, const char *public_shares, const char *s_share,",
          "726:                       uint8_t *encrypted_key, uint64_t key_len, unsigned _t, int _ind, int *result) {",
          "733:             (const sgx_sealed_data_t *) encrypted_key, NULL, 0, (uint8_t *) skey, &key_len);",
          "736:         snprintf(err_string, BUF_LEN, \"sgx_unseal_key failed with status %d\", status);",
          "",
          "[Added Lines]",
          "750: void trustedDkgVerify(int *errStatus, char *errString, const char *public_shares, const char *s_share,",
          "751:                       uint8_t *encryptedPrivateKey, uint64_t key_len, unsigned _t, int _ind, int *result) {",
          "758:             (const sgx_sealed_data_t *) encryptedPrivateKey, NULL, 0, (uint8_t *) skey, &key_len);",
          "761:         snprintf(errString, BUF_LEN, \"sgx_unseal_key failed with status %d\", status);",
          "",
          "---------------",
          "--- Hunk 33 ---",
          "[Context before]",
          "747:     common_key[ECDSA_SKEY_LEN - 1] = 0;",
          "748:     if (common_key == NULL) {",
          "751:         return;",
          "752:     }",
          "754:     xor_decrypt(common_key, encr_sshare, decr_sshare);",
          "755:     if (decr_sshare == NULL) {",
          "758:         return;",
          "759:     }",
          "",
          "[Removed Lines]",
          "750:         snprintf(err_string, BUF_LEN, \"invalid common_key\");",
          "757:         snprintf(err_string, BUF_LEN, \"invalid common_key\");",
          "",
          "[Added Lines]",
          "775:         snprintf(errString, BUF_LEN, \"invalid common_key\");",
          "782:         snprintf(errString, BUF_LEN, \"invalid common_key\");",
          "",
          "---------------",
          "--- Hunk 34 ---",
          "[Context before]",
          "766:     mpz_init(s);",
          "767:     if (mpz_set_str(s, decr_sshare, 16) == -1) {",
          "770:         mpz_clear(s);",
          "771:         return;",
          "772:     }",
          "778: }",
          "783:     LOG_DEBUG (__FUNCTION__);",
          "785:     char skey[ECDSA_SKEY_LEN];",
          "786:     sgx_status_t status = sgx_unseal_data(",
          "788:     if (status != SGX_SUCCESS) {",
          "791:         return;",
          "792:     }",
          "",
          "[Removed Lines]",
          "769:         snprintf(err_string, BUF_LEN, \"invalid decr secret share\");",
          "776:     snprintf(err_string, BUF_LEN, \"common_key in verification is %s\", common_key);",
          "780: void trustedCreateBlsKey(int *errStatus, char *err_string, const char *s_shares,",
          "781:                     uint8_t *encrypted_key, uint64_t key_len, uint8_t *encr_bls_key, uint32_t *enc_bls_key_len) {",
          "787:             (const sgx_sealed_data_t *) encrypted_key, NULL, 0, (uint8_t *) skey, &key_len);",
          "790:         snprintf(err_string, BUF_LEN, \"sgx_unseal_key failed with status %d\", status);",
          "",
          "[Added Lines]",
          "794:         snprintf(errString, BUF_LEN, \"invalid decr secret share\");",
          "801:     snprintf(errString, BUF_LEN, \"common_key in verification is %s\", common_key);",
          "805: void trustedCreateBlsKey(int *errStatus, char *errString, const char *s_shares,",
          "806:                     uint8_t *encryptedPrivateKey, uint64_t key_len, uint8_t *encr_bls_key, uint32_t *enc_bls_key_len) {",
          "812:             (const sgx_sealed_data_t *) encryptedPrivateKey, NULL, 0, (uint8_t *) skey, &key_len);",
          "815:         snprintf(errString, BUF_LEN, \"sgx_unseal_key failed with status %d\", status);",
          "",
          "---------------",
          "--- Hunk 35 ---",
          "[Context before]",
          "814:         if (common_key == NULL) {",
          "817:             mpz_clear(sum);",
          "818:             return;",
          "819:         }",
          "",
          "[Removed Lines]",
          "816:             snprintf(err_string, BUF_LEN, \"invalid common_key\");",
          "",
          "[Added Lines]",
          "841:             snprintf(errString, BUF_LEN, \"invalid common_key\");",
          "",
          "---------------",
          "--- Hunk 36 ---",
          "[Context before]",
          "823:         xor_decrypt(common_key, encr_sshare, decr_sshare);",
          "824:         if (decr_sshare == NULL) {",
          "827:             mpz_clear(sum);",
          "828:             return;",
          "829:         }",
          "",
          "[Removed Lines]",
          "826:             snprintf(err_string, BUF_LEN, \"invalid common_key\");",
          "",
          "[Added Lines]",
          "851:             snprintf(errString, BUF_LEN, \"invalid common_key\");",
          "",
          "---------------",
          "--- Hunk 37 ---",
          "[Context before]",
          "832:         mpz_init(decr_secret_share);",
          "833:         if (mpz_set_str(decr_secret_share, decr_sshare, 16) == -1) {",
          "836:             mpz_clear(decr_secret_share);",
          "837:             return;",
          "838:         }",
          "",
          "[Removed Lines]",
          "835:             snprintf(err_string, BUF_LEN, \"invalid decrypted secret share\");",
          "",
          "[Added Lines]",
          "860:             snprintf(errString, BUF_LEN, \"invalid decrypted secret share\");",
          "",
          "---------------",
          "--- Hunk 38 ---",
          "[Context before]",
          "853:     char key_share[mpz_sizeinbase(bls_key, 16) + 2];",
          "854:     char *key = mpz_get_str(key_share, 16, bls_key);",
          "856:     uint32_t sealedLen = sgx_calc_sealed_data_size(0, ECDSA_SKEY_LEN);",
          "",
          "[Removed Lines]",
          "855:     snprintf(err_string, BUF_LEN, \" bls private key is %s\", key_share);",
          "",
          "[Added Lines]",
          "880:     snprintf(errString, BUF_LEN, \" bls private key is %s\", key_share);",
          "",
          "---------------",
          "--- Hunk 39 ---",
          "[Context before]",
          "860:                            (sgx_sealed_data_t *) encr_bls_key);",
          "861:     if (status != SGX_SUCCESS) {",
          "864:         mpz_clear(bls_key);",
          "865:         mpz_clear(sum);",
          "866:         mpz_clear(q);",
          "",
          "[Removed Lines]",
          "863:         snprintf(err_string, BUF_LEN, \"seal bls private key failed with status %d \", status);",
          "",
          "[Added Lines]",
          "888:         snprintf(errString, BUF_LEN, \"seal bls private key failed with status %d \", status);",
          "",
          "---------------",
          "--- Hunk 40 ---",
          "[Context before]",
          "874:     mpz_clear(q);",
          "875: }",
          "879:     LOG_DEBUG (__FUNCTION__);",
          "",
          "[Removed Lines]",
          "877: void trustedGetBlsPubKey(int *errStatus, char *err_string, uint8_t *encrypted_key, uint64_t key_len, char *bls_pub_key) {",
          "",
          "[Added Lines]",
          "902: void trustedGetBlsPubKey(int *errStatus, char *errString, uint8_t *encryptedPrivateKey, uint64_t key_len, char *bls_pub_key) {",
          "",
          "---------------",
          "--- Hunk 41 ---",
          "[Context before]",
          "883:     uint32_t len = key_len;",
          "885:     sgx_status_t status = sgx_unseal_data(",
          "887:     if (status != SGX_SUCCESS) {",
          "890:         return;",
          "891:     }",
          "893:     if (calc_bls_public_key(skey_hex, bls_pub_key) != 0) {",
          "896:         return;",
          "897:     }",
          "898: }",
          "901:                   uint8_t *encrypted_SEK, uint32_t *enc_len, char *SEK_hex) {",
          "903:     LOG_DEBUG (__FUNCTION__);",
          "",
          "[Removed Lines]",
          "886:             (const sgx_sealed_data_t *) encrypted_key, NULL, 0, (uint8_t *) skey_hex, &len);",
          "889:         snprintf(err_string, BUF_LEN, \"sgx_unseal_data failed with status %d\", status);",
          "895:         snprintf(err_string, BUF_LEN, \"could not calculate bls public key\");",
          "900: void trustedGenerateSEK(int *errStatus, char *err_string,",
          "",
          "[Added Lines]",
          "911:             (const sgx_sealed_data_t *) encryptedPrivateKey, NULL, 0, (uint8_t *) skey_hex, &len);",
          "914:         snprintf(errString, BUF_LEN, \"sgx_unseal_data failed with status %d\", status);",
          "920:         snprintf(errString, BUF_LEN, \"could not calculate bls public key\");",
          "925: void trustedGenerateSEK(int *errStatus, char *errString,",
          "",
          "---------------",
          "--- Hunk 42 ---",
          "[Context before]",
          "918:     sgx_status_t status = sgx_seal_data(0, NULL, hex_aes_key_length + 1, SEK_hex, sealedLen,",
          "919:                                         (sgx_sealed_data_t *) encrypted_SEK);",
          "920:     if (status != SGX_SUCCESS) {",
          "923:         return;",
          "924:     }",
          "",
          "[Removed Lines]",
          "921:         snprintf(err_string, BUF_LEN, \"seal SEK failed\");",
          "",
          "[Added Lines]",
          "946:         snprintf(errString, BUF_LEN, \"seal SEK failed\");",
          "",
          "---------------",
          "--- Hunk 43 ---",
          "[Context before]",
          "929: }",
          "933:     LOG_DEBUG (__FUNCTION__);",
          "",
          "[Removed Lines]",
          "931: void trustedSetSEK(int *errStatus, char *err_string, uint8_t *encrypted_SEK, uint64_t encr_len) {",
          "",
          "[Added Lines]",
          "956: void trustedSetSEK(int *errStatus, char *errString, uint8_t *encrypted_SEK, uint64_t encr_len) {",
          "",
          "---------------",
          "--- Hunk 44 ---",
          "[Context before]",
          "939:             (const sgx_sealed_data_t *) encrypted_SEK, NULL, 0, aes_key_hex, &encr_len);",
          "940:     if (status != SGX_SUCCESS) {",
          "943:         return;",
          "944:     }",
          "",
          "[Removed Lines]",
          "942:         snprintf(err_string, BUF_LEN, \"sgx unseal SEK failed with status %d\", status);",
          "",
          "[Added Lines]",
          "967:         snprintf(errString, BUF_LEN, \"sgx unseal SEK failed with status %d\", status);",
          "",
          "---------------",
          "--- Hunk 45 ---",
          "[Context before]",
          "949: }",
          "952:                     uint8_t *encrypted_SEK, uint32_t *enc_len, const char *SEK_hex) {",
          "954:     LOG_DEBUG (__FUNCTION__);",
          "",
          "[Removed Lines]",
          "951: void trustedSetSEK_backup(int *errStatus, char *err_string,",
          "",
          "[Added Lines]",
          "976: void trustedSetSEK_backup(int *errStatus, char *errString,",
          "",
          "---------------",
          "--- Hunk 46 ---",
          "[Context before]",
          "961:     sgx_status_t status = sgx_seal_data(0, NULL, strlen(SEK_hex) + 1, SEK_hex, sealedLen,",
          "962:                                         (sgx_sealed_data_t *) encrypted_SEK);",
          "963:     if (status != SGX_SUCCESS) {",
          "966:         return;",
          "967:     }",
          "",
          "[Removed Lines]",
          "964:         snprintf(err_string, BUF_LEN, \"seal SEK failed with status %d\", status);",
          "",
          "[Added Lines]",
          "989:         snprintf(errString, BUF_LEN, \"seal SEK failed with status %d\", status);",
          "",
          "---------------",
          "--- Hunk 47 ---",
          "[Context before]",
          "970: }",
          "975:     LOG_DEBUG (__FUNCTION__);",
          "",
          "[Removed Lines]",
          "972: void trustedGenerateEcdsaKeyAES(int *errStatus, char *err_string,",
          "973:                             uint8_t *encrypted_key, uint32_t *enc_len, char *pub_key_x, char *pub_key_y) {",
          "",
          "[Added Lines]",
          "997: void trustedGenerateEcdsaKeyAES(int *errStatus, char *errString,",
          "998:                             uint8_t *encryptedPrivateKey, uint32_t *enc_len, char *pub_key_x, char *pub_key_y) {",
          "",
          "---------------",
          "--- Hunk 48 ---",
          "[Context before]",
          "1019:     strncpy(pub_key_y + n_zeroes, arr_y, 1024 - n_zeroes);",
          "1020:     char skey_str[mpz_sizeinbase(skey, ECDSA_SKEY_BASE) + 2];",
          "1021:     char *s = mpz_get_str(skey_str, ECDSA_SKEY_BASE, skey);",
          "1026:     if (stat != 0) {",
          "1029:         return;",
          "1030:     }",
          "1035:     if (stat != 0) {",
          "1038:         return;",
          "1039:     }",
          "",
          "[Removed Lines]",
          "1022:     snprintf(err_string, BUF_LEN, \"skey is %s len %d\\n\", skey_str, strlen(skey_str));",
          "1024:     int stat = AES_encrypt(skey_str, encrypted_key);",
          "1027:         snprintf(err_string, BUF_LEN, \"ecdsa private key encryption failed\");",
          "1034:     stat = AES_decrypt(encrypted_key, *enc_len, skey_str);",
          "1036:         snprintf(err_string + 19 + strlen(skey_str), BUF_LEN, \"ecdsa private key decr failed with status %d\", stat);",
          "",
          "[Added Lines]",
          "1047:     snprintf(errString, BUF_LEN, \"skey is %s len %d\\n\", skey_str, strlen(skey_str));",
          "1049:     int stat = AES_encrypt(skey_str, encryptedPrivateKey);",
          "1052:         snprintf(errString, BUF_LEN, \"ecdsa private key encryption failed\");",
          "1059:     stat = AES_decrypt(encryptedPrivateKey, *enc_len, skey_str);",
          "1061:         snprintf(errString + 19 + strlen(skey_str), BUF_LEN, \"ecdsa private key decr failed with status %d\", stat);",
          "",
          "---------------",
          "--- Hunk 49 ---",
          "[Context before]",
          "1043:     point_clear(Pkey);",
          "1044: }",
          "1049:     LOG_DEBUG (__FUNCTION__);",
          "",
          "[Removed Lines]",
          "1046: void trustedGetPublicEcdsaKeyAES(int *errStatus, char *err_string,",
          "1047:                               uint8_t *encrypted_key, uint32_t enc_len, char *pub_key_x, char *pub_key_y) {",
          "",
          "[Added Lines]",
          "1071: void trustedGetPublicEcdsaKeyAES(int *errStatus, char *errString,",
          "1072:                               uint8_t *encryptedPrivateKey, uint32_t enc_len, char *pub_key_x, char *pub_key_y) {",
          "",
          "---------------",
          "--- Hunk 50 ---",
          "[Context before]",
          "1054:     char skey[ECDSA_SKEY_LEN];",
          "1058:     if (status != 0) {",
          "1061:         return;",
          "1062:     }",
          "1064:     skey[enc_len - SGX_AESGCM_MAC_SIZE - SGX_AESGCM_IV_SIZE] = '\\0';",
          "1075:         return;",
          "1076:     }",
          "1079:     point Pkey = point_init();",
          "1083:     point Pkey_test = point_init();",
          "1086:     if (!point_cmp(Pkey, Pkey_test)) {",
          "1089:         return;",
          "1090:     }",
          "",
          "[Removed Lines]",
          "1056:     int status = AES_decrypt(encrypted_key, enc_len, skey);",
          "1059:         snprintf(err_string, BUF_LEN, \"AES_decrypt failed with status %d\", status);",
          "1066:     strncpy(err_string, skey, 1024);",
          "1068:     mpz_t secretKeyMpz;",
          "1069:     mpz_init(secretKeyMpz);",
          "1071:     if (mpz_set_str(secretKeyMpz, skey, ECDSA_SKEY_BASE) == -1) {",
          "1072:         snprintf(err_string, BUF_LEN, \"wrong string to init private key  - %s\", skey);",
          "1074:         mpz_clear(secretKeyMpz);",
          "1081:     signature_extract_public_key(Pkey, secretKeyMpz, curve);",
          "1084:     point_multiplication(Pkey_test, secretKeyMpz, curve->G, curve);",
          "1087:         snprintf(err_string, BUF_LEN, \"Points are not equal\");",
          "",
          "[Added Lines]",
          "1081:     int status = AES_decrypt(encryptedPrivateKey, enc_len, skey);",
          "1084:         snprintf(errString, BUF_LEN, \"AES_decrypt failed with status %d\", status);",
          "1091:     strncpy(errString, skey, 1024);",
          "1093:     mpz_t privateKeyMpz;",
          "1094:     mpz_init(privateKeyMpz);",
          "1096:     if (mpz_set_str(privateKeyMpz, skey, ECDSA_SKEY_BASE) == -1) {",
          "1097:         snprintf(errString, BUF_LEN, \"wrong string to init private key  - %s\", skey);",
          "1099:         mpz_clear(privateKeyMpz);",
          "1106:     signature_extract_public_key(Pkey, privateKeyMpz, curve);",
          "1109:     point_multiplication(Pkey_test, privateKeyMpz, curve->G, curve);",
          "1112:         snprintf(errString, BUF_LEN, \"Points are not equal\");",
          "",
          "---------------",
          "--- Hunk 51 ---",
          "[Context before]",
          "1111:     }",
          "1112:     strncpy(pub_key_y + n_zeroes, arr_y, 1024 - n_zeroes);",
          "1115:     domain_parameters_clear(curve);",
          "1116:     point_clear(Pkey);",
          "1117: }",
          "1120:                     unsigned char *hash, char *sigR, char *sigS, uint8_t *sig_v, int base) {",
          "1122:     LOG_DEBUG (__FUNCTION__);",
          "",
          "[Removed Lines]",
          "1114:     mpz_clear(secretKeyMpz);",
          "1119: void trustedEcdsaSignAES(int *errStatus, char *err_string, uint8_t *encrypted_key, uint32_t enc_len,",
          "",
          "[Added Lines]",
          "1139:     mpz_clear(privateKeyMpz);",
          "1144: void trustedEcdsaSignAES(int *errStatus, char *errString, uint8_t *encryptedPrivateKey, uint32_t enc_len,",
          "",
          "---------------",
          "--- Hunk 52 ---",
          "[Context before]",
          "1127:     char skey[ECDSA_SKEY_LEN];",
          "1131:     if (status != 0) {",
          "1134:         return;",
          "1135:     }",
          "1137:     skey[enc_len - SGX_AESGCM_MAC_SIZE - SGX_AESGCM_IV_SIZE - 1] = '\\0';",
          "1146:         return;",
          "1147:     }",
          "",
          "[Removed Lines]",
          "1129:     int status = AES_decrypt(encrypted_key, enc_len, skey);",
          "1133:         snprintf(err_string, BUF_LEN, \"aes decrypt failed with status %d\", status);",
          "1139:     snprintf(err_string, BUF_LEN, \"pr key is %s length %d \", skey, strlen(skey));",
          "1140:     mpz_t secretKeyMpz;",
          "1141:     mpz_init(secretKeyMpz);",
          "1142:     if (mpz_set_str(secretKeyMpz, skey, ECDSA_SKEY_BASE) == -1) {",
          "1144:         snprintf(err_string, BUF_LEN, \"invalid secret key\");",
          "1145:         mpz_clear(secretKeyMpz);",
          "",
          "[Added Lines]",
          "1154:     int status = AES_decrypt(encryptedPrivateKey, enc_len, skey);",
          "1158:         snprintf(errString, BUF_LEN, \"aes decrypt failed with status %d\", status);",
          "1164:     snprintf(errString, BUF_LEN, \"pr key is %s length %d \", skey, strlen(skey));",
          "1165:     mpz_t privateKeyMpz;",
          "1166:     mpz_init(privateKeyMpz);",
          "1167:     if (mpz_set_str(privateKeyMpz, skey, ECDSA_SKEY_BASE) == -1) {",
          "1169:         snprintf(errString, BUF_LEN, \"invalid secret key\");",
          "1170:         mpz_clear(privateKeyMpz);",
          "",
          "---------------",
          "--- Hunk 53 ---",
          "[Context before]",
          "1151:     mpz_init(msgMpz);",
          "1152:     if (mpz_set_str(msgMpz, hash, 16) == -1) {",
          "1155:         mpz_clear(msgMpz);",
          "1156:         return;",
          "1157:     }",
          "1159:     signature sign = signature_init();",
          "1163:     point Pkey = point_init();",
          "1167:     if (!signature_verify(msgMpz, sign, Pkey, curve)) {",
          "1170:         return;",
          "1171:     }",
          "1174:     char arrM[mpz_sizeinbase(msgMpz, 16) + 2];",
          "1175:     char *msg = mpz_get_str(arrM, 16, msgMpz);",
          "1178:     char arrR[mpz_sizeinbase(sign->r, base) + 2];",
          "1179:     char *r = mpz_get_str(arrR, base, sign->r);",
          "",
          "[Removed Lines]",
          "1154:         snprintf(err_string, BUF_LEN, \"invalid message hash\");",
          "1161:     signature_sign(sign, msgMpz, secretKeyMpz, curve);",
          "1165:     signature_extract_public_key(Pkey, secretKeyMpz, curve);",
          "1169:         snprintf(err_string, BUF_LEN, \"signature is not verified! \");",
          "1176:     snprintf(err_string, BUF_LEN, \"message is %s \", arrM);",
          "",
          "[Added Lines]",
          "1179:         snprintf(errString, BUF_LEN, \"invalid message hash\");",
          "1186:     signature_sign(sign, msgMpz, privateKeyMpz, curve);",
          "1190:     signature_extract_public_key(Pkey, privateKeyMpz, curve);",
          "1194:         snprintf(errString, BUF_LEN, \"signature is not verified! \");",
          "1201:     snprintf(errString, BUF_LEN, \"message is %s \", arrM);",
          "",
          "---------------",
          "--- Hunk 54 ---",
          "[Context before]",
          "1189:     mpz_clear(msgMpz);",
          "1190:     domain_parameters_clear(curve);",
          "1191:     signature_free(sign);",
          "",
          "[Removed Lines]",
          "1188:     mpz_clear(secretKeyMpz);",
          "",
          "[Added Lines]",
          "1213:     mpz_clear(privateKeyMpz);",
          "",
          "---------------",
          "--- Hunk 55 ---",
          "[Context before]",
          "1194: }",
          "1199:     LOG_DEBUG (__FUNCTION__);",
          "1208:     if (stat != 0) {",
          "1211:         return;",
          "1212:     }",
          "",
          "[Removed Lines]",
          "1196: void trustedEncryptKeyAES(int *errStatus, char *err_string, const char *key,",
          "1197:                      uint8_t *encrypted_key, uint32_t *enc_len) {",
          "1203:     memset(err_string, 0, BUF_LEN);",
          "1205:     memset(encrypted_key, 0, BUF_LEN);",
          "1207:     int stat = AES_encrypt(key, encrypted_key);",
          "1210:         snprintf(err_string, BUF_LEN, \"AES encrypt failed with status %d\", stat);",
          "",
          "[Added Lines]",
          "1221: void trustedEncryptKeyAES(int *errStatus, char *errString, const char *key,",
          "1222:                      uint8_t *encryptedPrivateKey, uint32_t *enc_len) {",
          "1228:     memset(errString, 0, BUF_LEN);",
          "1230:     memset(encryptedPrivateKey, 0, BUF_LEN);",
          "1232:     int stat = AES_encrypt(key, encryptedPrivateKey);",
          "1235:         snprintf(errString, BUF_LEN, \"AES encrypt failed with status %d\", stat);",
          "",
          "---------------",
          "--- Hunk 56 ---",
          "[Context before]",
          "1216:     char decryptedKey[BUF_LEN];",
          "1217:     memset(decryptedKey, 0, BUF_LEN);",
          "1221:     if (stat != 0) {",
          "1224:         return;",
          "1225:     }",
          "1227:     uint64_t decryptedKeyLen = strnlen(decryptedKey, MAX_KEY_LENGTH);",
          "1229:     if (decryptedKeyLen == MAX_KEY_LENGTH) {",
          "1231:         return;",
          "1232:     }",
          "",
          "[Removed Lines]",
          "1219:     stat = AES_decrypt(encrypted_key, *enc_len, decryptedKey);",
          "1223:         snprintf(err_string, BUF_LEN, \":trustedDecryptKey failed with status %d\", stat);",
          "1230:         snprintf(err_string, BUF_LEN, \"Decrypted key is not null terminated\");",
          "",
          "[Added Lines]",
          "1244:     stat = AES_decrypt(encryptedPrivateKey, *enc_len, decryptedKey);",
          "1248:         snprintf(errString, BUF_LEN, \":trustedDecryptKey failed with status %d\", stat);",
          "1255:         snprintf(errString, BUF_LEN, \"Decrypted key is not null terminated\");",
          "",
          "---------------",
          "--- Hunk 57 ---",
          "[Context before]",
          "1237:     if (strncmp(key, decryptedKey, MAX_KEY_LENGTH) != 0) {",
          "1239:         return;",
          "1240:     }",
          "1243: }",
          "1246:                      uint32_t enc_len, char *key) {",
          "1248:     uint32_t decLen;",
          "1254:     if (status != 0) {",
          "1257:         return;",
          "1258:     }",
          "1261:     if (decLen > MAX_KEY_LENGTH) {",
          "1264:         return;",
          "1265:     }",
          "",
          "[Removed Lines]",
          "1238:         snprintf(err_string, BUF_LEN, \"Decrypted key does not match original key\");",
          "1245: void trustedDecryptKeyAES(int *errStatus, char *err_string, uint8_t *encrypted_key,",
          "1252:     int status = AES_decrypt(encrypted_key, enc_len, key);",
          "1256:         snprintf(err_string, BUF_LEN, \"aes decrypt failed with status %d\", status);",
          "1263:         snprintf(err_string, BUF_LEN, \"wrong decLen\");//\"decLen != MAX_KEY_LENGTH\");",
          "",
          "[Added Lines]",
          "1263:         snprintf(errString, BUF_LEN, \"Decrypted key does not match original key\");",
          "1270: void trustedDecryptKeyAES(int *errStatus, char *errString, uint8_t *encryptedPrivateKey,",
          "1277:     int status = AES_decrypt(encryptedPrivateKey, enc_len, key);",
          "1281:         snprintf(errString, BUF_LEN, \"aes decrypt failed with status %d\", status);",
          "1288:         snprintf(errString, BUF_LEN, \"wrong decLen\");//\"decLen != MAX_KEY_LENGTH\");",
          "",
          "---------------",
          "--- Hunk 58 ---",
          "[Context before]",
          "1273:     if (keyLen == MAX_KEY_LENGTH) {",
          "1275:         return;",
          "1276:     }",
          "1281: }",
          "1284:                           uint32_t enc_len, char *_hashX,",
          "1285:                           char *_hashY, char *signature) {",
          "",
          "[Removed Lines]",
          "1274:         snprintf(err_string, BUF_LEN, \"Key is not null terminated\");",
          "1279:     memcpy(err_string, AES_key, 1024);",
          "1283: void trustedBlsSignMessageAES(int *errStatus, char *err_string, uint8_t *encrypted_key,",
          "",
          "[Added Lines]",
          "1299:         snprintf(errString, BUF_LEN, \"Key is not null terminated\");",
          "1304:     memcpy(errString, AES_key, 1024);",
          "1308: void trustedBlsSignMessageAES(int *errStatus, char *errString, uint8_t *encryptedPrivateKey,",
          "",
          "---------------",
          "--- Hunk 59 ---",
          "[Context before]",
          "1291:     char sig[BUF_LEN];",
          "1292:     memset(sig, 0, BUF_LEN);",
          "1296:     if (stat != 0) {",
          "1299:         return;",
          "1300:     }",
          "",
          "[Removed Lines]",
          "1294:     int stat = AES_decrypt(encrypted_key, enc_len, key);",
          "1298:         strncpy(signature, err_string, BUF_LEN);",
          "",
          "[Added Lines]",
          "1319:     int stat = AES_decrypt(encryptedPrivateKey, enc_len, key);",
          "1323:         strncpy(signature, errString, BUF_LEN);",
          "",
          "---------------",
          "--- Hunk 60 ---",
          "[Context before]",
          "1311: }",
          "1313: void",
          "1316:     LOG_DEBUG (__FUNCTION__);",
          "",
          "[Removed Lines]",
          "1314: trustedGenDkgSecretAES(int *errStatus, char *err_string, uint8_t *encrypted_dkg_secret, uint32_t *enc_len, size_t _t) {",
          "",
          "[Added Lines]",
          "1339: trustedGenDkgSecretAES(int *errStatus, char *errString, uint8_t *encrypted_dkg_secret, uint32_t *enc_len, size_t _t) {",
          "",
          "---------------",
          "--- Hunk 61 ---",
          "[Context before]",
          "1323:         return;",
          "1324:     }",
          "1328:     int status = AES_encrypt(dkg_secret, encrypted_dkg_secret);",
          "1330:     if (status != SGX_SUCCESS) {",
          "1333:         return;",
          "1334:     }",
          "",
          "[Removed Lines]",
          "1326:     snprintf(err_string, BUF_LEN, \"poly is %s \", dkg_secret);",
          "1331:         snprintf(err_string, BUF_LEN, \"SGX AES encrypt DKG poly failed\");",
          "",
          "[Added Lines]",
          "1351:     snprintf(errString, BUF_LEN, \"poly is %s \", dkg_secret);",
          "1356:         snprintf(errString, BUF_LEN, \"SGX AES encrypt DKG poly failed\");",
          "",
          "---------------",
          "--- Hunk 62 ---",
          "[Context before]",
          "1342:     status = AES_decrypt(encrypted_dkg_secret, *enc_len, decr_dkg_secret);",
          "1343:     if (status != SGX_SUCCESS) {",
          "1346:         return;",
          "1347:     }",
          "1349:     if (strcmp(dkg_secret, decr_dkg_secret) != 0) {",
          "1352:                  \"encrypted poly is not equal to decrypted poly\");",
          "1354:     }",
          "",
          "[Removed Lines]",
          "1344:         snprintf(err_string, BUF_LEN, \"aes decrypt  dkg poly failed\");",
          "1350:         snprintf(err_string, BUF_LEN, \"poly is %s \", dkg_secret);",
          "1351:         snprintf(err_string + strlen(dkg_secret) + 8, BUF_LEN - strlen(dkg_secret) - 8,",
          "",
          "[Added Lines]",
          "1369:         snprintf(errString, BUF_LEN, \"aes decrypt  dkg poly failed\");",
          "1375:         snprintf(errString, BUF_LEN, \"poly is %s \", dkg_secret);",
          "1376:         snprintf(errString + strlen(dkg_secret) + 8, BUF_LEN - strlen(dkg_secret) - 8,",
          "",
          "---------------",
          "--- Hunk 63 ---",
          "[Context before]",
          "1357: }",
          "1359: void",
          "1361:                        uint32_t *dec_len) {",
          "1363:     LOG_DEBUG (__FUNCTION__);",
          "",
          "[Removed Lines]",
          "1360: trustedDecryptDkgSecretAES(int *errStatus, char *err_string, uint8_t *encrypted_dkg_secret, uint8_t *decrypted_dkg_secret,",
          "",
          "[Added Lines]",
          "1385: trustedDecryptDkgSecretAES(int *errStatus, char *errString, uint8_t *encrypted_dkg_secret, uint8_t *decrypted_dkg_secret,",
          "",
          "---------------",
          "--- Hunk 64 ---",
          "[Context before]",
          "1365:     int status = AES_decrypt(encrypted_dkg_secret, dec_len, decrypted_dkg_secret);",
          "1367:     if (status != SGX_SUCCESS) {",
          "1370:         return;",
          "1371:     }",
          "1373: }",
          "1377:     LOG_DEBUG (__FUNCTION__);",
          "",
          "[Removed Lines]",
          "1368:         snprintf(err_string, BUF_LEN, \"aes decrypt data - encrypted_dkg_secret failed with status %d\", status);",
          "1375: void trustedSetEncryptedDkgPolyAES(int *errStatus, char *err_string, uint8_t *encrypted_poly, uint64_t *enc_len) {",
          "",
          "[Added Lines]",
          "1393:         snprintf(errString, BUF_LEN, \"aes decrypt data - encrypted_dkg_secret failed with status %d\", status);",
          "1400: void trustedSetEncryptedDkgPolyAES(int *errStatus, char *errString, uint8_t *encrypted_poly, uint64_t *enc_len) {",
          "",
          "---------------",
          "--- Hunk 65 ---",
          "[Context before]",
          "1382:     if (status != SGX_SUCCESS) {",
          "1385:         return;",
          "1386:     }",
          "1387: }",
          "1390:                          char *result_str, char *s_shareG2, char *pub_keyB, uint8_t _t, uint8_t _n, uint8_t ind) {",
          "1392:     char skey[ECDSA_SKEY_LEN];",
          "",
          "[Removed Lines]",
          "1384:         snprintf(err_string, BUF_LEN, \"sgx_unseal_data - encrypted_poly failed with status %d\", status);",
          "1389: void trustedGetEncryptedSecretShareAES(int *errStatus, char *err_string, uint8_t *encrypted_skey, uint32_t *dec_len,",
          "",
          "[Added Lines]",
          "1409:         snprintf(errString, BUF_LEN, \"sgx_unseal_data - encrypted_poly failed with status %d\", status);",
          "1414: void trustedGetEncryptedSecretShareAES(int *errStatus, char *errString, uint8_t *encrypted_skey, uint32_t *dec_len,",
          "",
          "---------------",
          "--- Hunk 66 ---",
          "[Context before]",
          "1399:     uint32_t enc_len;",
          "1402:     if (*errStatus != 0) {",
          "1403:         return;",
          "1404:     }",
          "",
          "[Removed Lines]",
          "1401:     trustedGenerateEcdsaKeyAES(errStatus, err_string, encrypted_skey, &enc_len, pub_key_x, pub_key_y);",
          "",
          "[Added Lines]",
          "1426:     trustedGenerateEcdsaKeyAES(errStatus, errString, encrypted_skey, &enc_len, pub_key_x, pub_key_y);",
          "",
          "---------------",
          "--- Hunk 67 ---",
          "[Context before]",
          "1408:     skey[ECDSA_SKEY_LEN - 1] = 0;",
          "1410:     if (status != SGX_SUCCESS) {",
          "1413:         return;",
          "1414:     }",
          "",
          "[Removed Lines]",
          "1411:         snprintf(err_string, BUF_LEN, \"AES_decrypt failed (in trustedGetEncryptedSecretShareAES)  with status %d\", status);",
          "1415:     snprintf(err_string, BUF_LEN, \"unsealed random skey is %s\\n\", skey);",
          "",
          "[Added Lines]",
          "1436:         snprintf(errString, BUF_LEN, \"AES_decrypt failed (in trustedGetEncryptedSecretShareAES)  with status %d\", status);",
          "1440:     snprintf(errString, BUF_LEN, \"unsealed random skey is %s\\n\", skey);",
          "",
          "---------------",
          "--- Hunk 68 ---",
          "[Context before]",
          "1425:     if (calc_secret_share(decryptedDkgPoly, s_share, _t, _n, ind) != 0) {",
          "1429:         return;",
          "1430:     }",
          "1433:     if (calc_secret_shareG2(s_share, s_shareG2) != 0) {",
          "1436:         return;",
          "1437:     }",
          "",
          "[Removed Lines]",
          "1428:         snprintf(err_string, BUF_LEN, decryptedDkgPoly);",
          "1431:     snprintf(err_string + 88, BUF_LEN, \"\\nsecret share is %s\", s_share);",
          "1435:         snprintf(err_string, BUF_LEN, \"invalid decr secret share\");",
          "",
          "[Added Lines]",
          "1453:         snprintf(errString, BUF_LEN, decryptedDkgPoly);",
          "1456:     snprintf(errString + 88, BUF_LEN, \"\\nsecret share is %s\", s_share);",
          "1460:         snprintf(errString, BUF_LEN, \"invalid decr secret share\");",
          "",
          "---------------",
          "--- Hunk 69 ---",
          "[Context before]",
          "1440:     xor_encrypt(common_key, s_share, cypher);",
          "1441:     if (cypher == NULL) {",
          "1444:         return;",
          "1445:     }",
          "",
          "[Removed Lines]",
          "1443:         snprintf(err_string, BUF_LEN, \"invalid common_key\");",
          "",
          "[Added Lines]",
          "1468:         snprintf(errString, BUF_LEN, \"invalid common_key\");",
          "",
          "---------------",
          "--- Hunk 70 ---",
          "[Context before]",
          "1453: }",
          "1456:                            char *public_shares,",
          "1457:                            unsigned _t, unsigned _n) {",
          "",
          "[Removed Lines]",
          "1455: void trustedGetPublicSharesAES(int *errStatus, char *err_string, uint8_t *encrypted_dkg_secret, uint32_t enc_len,",
          "",
          "[Added Lines]",
          "1480: void trustedGetPublicSharesAES(int *errStatus, char *errString, uint8_t *encrypted_dkg_secret, uint32_t enc_len,",
          "",
          "---------------",
          "--- Hunk 71 ---",
          "[Context before]",
          "1468:     if (status != SGX_SUCCESS) {",
          "1471:         return;",
          "1472:     }",
          "1474:     if (calc_public_shares(decrypted_dkg_secret, public_shares, _t) != 0) {",
          "1477:         return;",
          "1478:     }",
          "1481: }",
          "1487:     LOG_DEBUG (__FUNCTION__);",
          "1489:     char skey[ECDSA_SKEY_LEN];",
          "1490:     memset(skey, 0, ECDSA_SKEY_LEN);",
          "1494:     if (status != SGX_SUCCESS) {",
          "1497:         return;",
          "1498:     }",
          "",
          "[Removed Lines]",
          "1469:         snprintf(err_string, BUF_LEN, \"aes decrypt data - encrypted_dkg_secret failed with status %d\", status);",
          "1476:         snprintf(err_string, BUF_LEN, \"t does not match polynomial in db\");",
          "1483: void trustedDkgVerifyAES(int *errStatus, char *err_string, const char *public_shares, const char *s_share,",
          "1484:                           uint8_t *encrypted_key, uint64_t enc_len, unsigned _t, int _ind, int *result) {",
          "1491:     int status = AES_decrypt(encrypted_key, enc_len, skey);",
          "1495:         snprintf(err_string, BUF_LEN, \"AES_decrypt failed (in trustedDkgVerifyAES)  with status %d\", status);",
          "",
          "[Added Lines]",
          "1494:         snprintf(errString, BUF_LEN, \"aes decrypt data - encrypted_dkg_secret failed with status %d\", status);",
          "1501:         snprintf(errString, BUF_LEN, \"t does not match polynomial in db\");",
          "1508: void trustedDkgVerifyAES(int *errStatus, char *errString, const char *public_shares, const char *s_share,",
          "1509:                           uint8_t *encryptedPrivateKey, uint64_t enc_len, unsigned _t, int _ind, int *result) {",
          "1516:     int status = AES_decrypt(encryptedPrivateKey, enc_len, skey);",
          "1520:         snprintf(errString, BUF_LEN, \"AES_decrypt failed (in trustedDkgVerifyAES)  with status %d\", status);",
          "",
          "---------------",
          "--- Hunk 72 ---",
          "[Context before]",
          "1510:     if (common_key == NULL || strlen(common_key) == 0) {",
          "1513:         return;",
          "1514:     }",
          "",
          "[Removed Lines]",
          "1512:         snprintf(err_string, BUF_LEN, \"invalid common_key\");",
          "",
          "[Added Lines]",
          "1537:         snprintf(errString, BUF_LEN, \"invalid common_key\");",
          "",
          "---------------",
          "--- Hunk 73 ---",
          "[Context before]",
          "1518:     xor_decrypt(common_key, encr_sshare, decr_sshare);",
          "1519:     if (decr_sshare == NULL) {",
          "1522:         return;",
          "1523:     }",
          "",
          "[Removed Lines]",
          "1521:         snprintf(err_string, BUF_LEN, \"invalid common_key\");",
          "",
          "[Added Lines]",
          "1546:         snprintf(errString, BUF_LEN, \"invalid common_key\");",
          "",
          "---------------",
          "--- Hunk 74 ---",
          "[Context before]",
          "1526:     mpz_init(s);",
          "1527:     if (mpz_set_str(s, decr_sshare, 16) == -1) {",
          "1530:         mpz_clear(s);",
          "1531:         return;",
          "1532:     }",
          "1538: }",
          "1543:     LOG_DEBUG (__FUNCTION__);",
          "1545:     char skey[ECDSA_SKEY_LEN];",
          "1547:     if (status != SGX_SUCCESS) {",
          "1550:         return;",
          "1551:     }",
          "1552:     skey[ECDSA_SKEY_LEN - 1] = 0;",
          "",
          "[Removed Lines]",
          "1529:         snprintf(err_string, BUF_LEN, \"invalid decr secret share\");",
          "1536:     snprintf(err_string, BUF_LEN, \"secret share dec %s\", public_shares);",
          "1540: void trustedCreateBlsKeyAES(int *errStatus, char *err_string, const char *s_shares,",
          "1541:                         uint8_t *encrypted_key, uint64_t key_len, uint8_t *encr_bls_key, uint32_t *enc_bls_key_len) {",
          "1546:     int status = AES_decrypt(encrypted_key, key_len, skey);",
          "1549:         snprintf(err_string, BUF_LEN, \"aes decrypt failed with status %d\", status);",
          "",
          "[Added Lines]",
          "1554:         snprintf(errString, BUF_LEN, \"invalid decr secret share\");",
          "1561:     snprintf(errString, BUF_LEN, \"secret share dec %s\", public_shares);",
          "1565: void trustedCreateBlsKeyAES(int *errStatus, char *errString, const char *s_shares,",
          "1566:                         uint8_t *encryptedPrivateKey, uint64_t key_len, uint8_t *encr_bls_key, uint32_t *enc_bls_key_len) {",
          "1571:     int status = AES_decrypt(encryptedPrivateKey, key_len, skey);",
          "1574:         snprintf(errString, BUF_LEN, \"aes decrypt failed with status %d\", status);",
          "",
          "---------------",
          "--- Hunk 75 ---",
          "[Context before]",
          "1575:         if (common_key == NULL) {",
          "1578:             mpz_clear(sum);",
          "1579:             return;",
          "1580:         }",
          "",
          "[Removed Lines]",
          "1577:             snprintf(err_string, BUF_LEN, \"invalid common_key\");",
          "",
          "[Added Lines]",
          "1602:             snprintf(errString, BUF_LEN, \"invalid common_key\");",
          "",
          "---------------",
          "--- Hunk 76 ---",
          "[Context before]",
          "1584:         xor_decrypt(common_key, encr_sshare, decr_sshare);",
          "1585:         if (decr_sshare == NULL) {",
          "1588:             mpz_clear(sum);",
          "1589:             return;",
          "1590:         }",
          "",
          "[Removed Lines]",
          "1587:             snprintf(err_string, BUF_LEN, \"invalid common_key\");",
          "",
          "[Added Lines]",
          "1612:             snprintf(errString, BUF_LEN, \"invalid common_key\");",
          "",
          "---------------",
          "--- Hunk 77 ---",
          "[Context before]",
          "1594:         mpz_init(decr_secret_share);",
          "1595:         if (mpz_set_str(decr_secret_share, decr_sshare, 16) == -1) {",
          "1599:             mpz_clear(decr_secret_share);",
          "1600:             return;",
          "1601:         }",
          "",
          "[Removed Lines]",
          "1598:             snprintf(err_string, BUF_LEN, decr_sshare);",
          "",
          "[Added Lines]",
          "1623:             snprintf(errString, BUF_LEN, decr_sshare);",
          "",
          "---------------",
          "--- Hunk 78 ---",
          "[Context before]",
          "1616:     char key_share[mpz_sizeinbase(bls_key, 16) + 2];",
          "1617:     char *key = mpz_get_str(key_share, 16, bls_key);",
          "1619:     uint32_t sealedLen = sgx_calc_sealed_data_size(0, ECDSA_SKEY_LEN);",
          "",
          "[Removed Lines]",
          "1618:     snprintf(err_string, BUF_LEN, \" bls private key is %s\", key_share);",
          "",
          "[Added Lines]",
          "1643:     snprintf(errString, BUF_LEN, \" bls private key is %s\", key_share);",
          "",
          "---------------",
          "--- Hunk 79 ---",
          "[Context before]",
          "1624:     if (status != SGX_SUCCESS) {",
          "1627:         mpz_clear(bls_key);",
          "1628:         mpz_clear(sum);",
          "1629:         mpz_clear(q);",
          "",
          "[Removed Lines]",
          "1626:         snprintf(err_string, BUF_LEN, \"aes encrypt bls private key failed with status %d \", status);",
          "",
          "[Added Lines]",
          "1651:         snprintf(errString, BUF_LEN, \"aes encrypt bls private key failed with status %d \", status);",
          "",
          "---------------",
          "--- Hunk 80 ---",
          "[Context before]",
          "1637: }",
          "1639: void",
          "1642:     LOG_DEBUG (__FUNCTION__);",
          "",
          "[Removed Lines]",
          "1640: trustedGetBlsPubKeyAES(int *errStatus, char *err_string, uint8_t *encrypted_key, uint64_t key_len, char *bls_pub_key) {",
          "",
          "[Added Lines]",
          "1665: trustedGetBlsPubKeyAES(int *errStatus, char *errString, uint8_t *encryptedPrivateKey, uint64_t key_len, char *bls_pub_key) {",
          "",
          "---------------",
          "--- Hunk 81 ---",
          "[Context before]",
          "1646:     uint32_t len = key_len;",
          "1649:     if (status != SGX_SUCCESS) {",
          "1652:         return;",
          "1653:     }",
          "",
          "[Removed Lines]",
          "1648:     int status = AES_decrypt(encrypted_key, key_len, skey_hex);",
          "1651:         snprintf(err_string, BUF_LEN, \"aes_decrypt failed with status %d\", status);",
          "",
          "[Added Lines]",
          "1673:     int status = AES_decrypt(encryptedPrivateKey, key_len, skey_hex);",
          "1676:         snprintf(errString, BUF_LEN, \"aes_decrypt failed with status %d\", status);",
          "",
          "---------------",
          "--- Hunk 82 ---",
          "[Context before]",
          "1657:     if (calc_bls_public_key(skey_hex, bls_pub_key) != 0) {",
          "1660:         return;",
          "1661:     }",
          "1662: }",
          "",
          "[Removed Lines]",
          "1659:         snprintf(err_string, BUF_LEN, \"could not calculate bls public key\");",
          "",
          "[Added Lines]",
          "1684:         snprintf(errString, BUF_LEN, \"could not calculate bls public key\");",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "c81d11281062fef59a2e5d24235b67eb961ce20f",
      "candidate_info": {
        "commit_hash": "c81d11281062fef59a2e5d24235b67eb961ce20f",
        "repo": "skalenetwork/sgxwallet",
        "commit_url": "https://github.com/skalenetwork/sgxwallet/commit/c81d11281062fef59a2e5d24235b67eb961ce20f",
        "files": [
          "BLSPrivateKeyShareSGX.cpp",
          "DKGCrypto.cpp",
          "DKGCrypto.h",
          "ECDSACrypto.cpp",
          "SGXWalletServer.cpp",
          "SGXWalletServer.hpp",
          "docker/start.sh",
          "sgxwallet_common.h",
          "testw.cpp"
        ],
        "message": "SKALE-2341 Added tags for older commits",
        "before_after_code_files": [
          "BLSPrivateKeyShareSGX.cpp||BLSPrivateKeyShareSGX.cpp",
          "DKGCrypto.cpp||DKGCrypto.cpp",
          "DKGCrypto.h||DKGCrypto.h",
          "ECDSACrypto.cpp||ECDSACrypto.cpp",
          "SGXWalletServer.cpp||SGXWalletServer.cpp",
          "SGXWalletServer.hpp||SGXWalletServer.hpp",
          "docker/start.sh||docker/start.sh",
          "sgxwallet_common.h||sgxwallet_common.h",
          "testw.cpp||testw.cpp"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "DKGCrypto.cpp||DKGCrypto.cpp",
            "ECDSACrypto.cpp||ECDSACrypto.cpp",
            "SGXWalletServer.cpp||SGXWalletServer.cpp",
            "testw.cpp||testw.cpp"
          ],
          "candidate": [
            "DKGCrypto.cpp||DKGCrypto.cpp",
            "ECDSACrypto.cpp||ECDSACrypto.cpp",
            "SGXWalletServer.cpp||SGXWalletServer.cpp",
            "testw.cpp||testw.cpp"
          ]
        }
      },
      "candidate_diff": {
        "BLSPrivateKeyShareSGX.cpp||BLSPrivateKeyShareSGX.cpp": [
          "File: BLSPrivateKeyShareSGX.cpp -> BLSPrivateKeyShareSGX.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "80:   requiredSigners = _requiredSigners;",
          "81:   totalSigners = _totalSigners;",
          "85:   if (requiredSigners > totalSigners) {",
          "87:     throw std::invalid_argument(\"requiredSigners > totalSigners\");",
          "88:   }",
          "",
          "[Removed Lines]",
          "83:   std::cerr <<   \"ENTER BLSPrivateKeyShareSGX CONSTRUCTOR\" << std::endl;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "DKGCrypto.cpp||DKGCrypto.cpp": [
          "File: DKGCrypto.cpp -> DKGCrypto.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "36: #include \"spdlog/spdlog.h\"",
          "37: #include \"common.h\"",
          "40:     string str(koefs);",
          "41:     string delim;",
          "42:     delim.push_back(symbol);",
          "",
          "[Removed Lines]",
          "39: vector<string> SplitString(const char *koefs, const char symbol) {",
          "",
          "[Added Lines]",
          "39: #define  DKG_MAX_SEALED_LEN 3100",
          "41: vector<string> splitString(const char *koefs, const char symbol) {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "77:     vector<char> errMsg(1024, 0);",
          "78:     int err_status = 0;",
          "82:     uint32_t enc_len = 0;",
          "",
          "[Removed Lines]",
          "80:     vector<uint8_t> encrypted_dkg_secret(DKG_MAX_SEALED_LEN, 0);",
          "",
          "[Added Lines]",
          "82:     vector<uint8_t> encrypted_dkg_secret(BUF_LEN, 0);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "111: vector<vector<string>> get_verif_vect(const char *encryptedPolyHex, int t, int n) {",
          "118:     spdlog::debug(\"got encr poly size {}\", char_traits<char>::length(encryptedPolyHex));",
          "132:         throw RPCException(INVALID_HEX, \"Invalid encryptedPolyHex\");",
          "133:     }",
          "136:     spdlog::debug(\"hex_encr_poly length is {}\", strlen(encryptedPolyHex));",
          "140:     uint32_t len = 0;",
          "142:     if (!encryptKeys)",
          "144:     else {",
          "147:     }",
          "150:     }",
          "155:     spdlog::debug(\"public_shares:\");",
          "164:     }",
          "171: }",
          "186:         throw RPCException(INVALID_HEX, \"Invalid encryptedPolyHex\");",
          "187:     }",
          "191:     if (!encryptKeys)",
          "193:     else",
          "198:     }",
          "200:     string result;",
          "218:         spdlog::debug(\"pubKeyB is {}\", pub_keyB);",
          "221:         if (!encryptKeys)",
          "224:         else",
          "229:         }",
          "244:         spdlog::debug(\"name to write to db is {}\", dhKeyName);",
          "245:         spdlog::debug(\"name to write to db is {}\", shareG2_name);",
          "252:     }",
          "259:     return result;",
          "260: }",
          "262: bool",
          "265:     char errMsg1[BUF_LEN];",
          "266:     int err_status = 0;",
          "",
          "[Removed Lines]",
          "113:     char *errMsg1 = (char *) calloc(1024, 1);",
          "115:     int err_status = 0;",
          "121:     char *public_shares = (char *) calloc(10000, 1);",
          "122:     memset(public_shares, 0, 10000);",
          "125:     uint64_t enc_len = 0;",
          "127:     uint8_t *encr_dkg_poly = (uint8_t *) calloc(DKG_MAX_SEALED_LEN * 2, 1);",
          "128:     memset(encr_dkg_poly, 0, DKG_MAX_SEALED_LEN * 2);",
          "131:     if (!hex2carray2(encryptedPolyHex, &enc_len, encr_dkg_poly, 6100)) {",
          "137:     spdlog::debug(\"enc len {}\", enc_len);",
          "143:         status = get_public_shares(eid, &err_status, errMsg1, encr_dkg_poly, len, public_shares, t, n);",
          "146:         status = get_public_shares_aes(eid, &err_status, errMsg1, encr_dkg_poly, enc_len, public_shares, t, n);",
          "148:     if (err_status != 0) {",
          "149:         throw RPCException(-666, errMsg1);",
          "153:     spdlog::debug(\"err msg is {}\", errMsg1);",
          "156:     spdlog::debug(\"{}\", public_shares);;",
          "157:     spdlog::debug(\"get_public_shares status: {}\", err_status);",
          "159:     vector<string> G2_strings = SplitString(public_shares, ',');",
          "160:     vector<vector<string>> pub_shares_vect;",
          "161:     for (uint64_t i = 0; i < G2_strings.size(); i++) {",
          "162:         vector<string> koef_str = SplitString(G2_strings.at(i).c_str(), ':');",
          "163:         pub_shares_vect.push_back(koef_str);",
          "166:     free(errMsg1);",
          "167:     free(public_shares);",
          "168:     free(encr_dkg_poly);",
          "170:     return pub_shares_vect;",
          "173: string get_secret_shares(const string &polyName, const char *encryptedPolyHex, const vector<string> &publicKeys, int t,",
          "174:                          int n) {",
          "176:     char errMsg1[BUF_LEN];",
          "177:     int err_status = 0;",
          "178:     char hexEncrKey[BUF_LEN];",
          "179:     memset(hexEncrKey, 0, BUF_LEN);",
          "180:     uint64_t enc_len = 0;",
          "183:     uint8_t encr_dkg_poly[DKG_MAX_SEALED_LEN];",
          "184:     memset(encr_dkg_poly, 0, DKG_MAX_SEALED_LEN);",
          "185:     if (!hex2carray2(encryptedPolyHex, &enc_len, encr_dkg_poly, 6100)) {",
          "189:     std::cerr << \"enc_len is \" << enc_len << std::endl;",
          "192:         status = set_encrypted_dkg_poly(eid, &err_status, errMsg1, encr_dkg_poly);",
          "194:         status = set_encrypted_dkg_poly_aes(eid, &err_status, errMsg1, encr_dkg_poly, &enc_len);",
          "196:     if (status != SGX_SUCCESS || err_status != 0) {",
          "197:         throw RPCException(-666, errMsg1);",
          "203:     for (int i = 0; i < n; i++) {",
          "204:         uint8_t encryptedSkey[BUF_LEN];",
          "205:         memset(encryptedSkey, 0, BUF_LEN);",
          "206:         uint32_t dec_len;",
          "208:         char cur_share[193];",
          "209:         char s_shareG2[320];",
          "210:         string pub_keyB = publicKeys.at(i);//publicKeys.substr(128*i, 128*i + 128);",
          "214:         char pubKeyB[129];",
          "215:         strncpy(pubKeyB, pub_keyB.c_str(), 128);",
          "216:         pubKeyB[128] = 0;",
          "222:             get_encr_sshare(eid, &err_status, errMsg1, encryptedSkey, &dec_len,",
          "223:                             cur_share, s_shareG2, pubKeyB, t, n, i + 1);",
          "225:             get_encr_sshare_aes(eid, &err_status, errMsg1, encryptedSkey, &dec_len,",
          "226:                                 cur_share, s_shareG2, pubKeyB, t, n, i + 1);",
          "227:         if (err_status != 0) {",
          "228:             throw RPCException(-666, errMsg1);",
          "231:         spdlog::debug(\"cur_share is {}\", cur_share);",
          "234:         result += cur_share;",
          "236:         spdlog::debug(\"dec len is {}\", dec_len);",
          "237:         carray2Hex(encryptedSkey, dec_len, hexEncrKey);",
          "238:         string dhKeyName = \"DKG_DH_KEY_\" + polyName + \"_\" + to_string(i) + \":\";",
          "240:         spdlog::debug(\"hexEncr DH Key: { }\", hexEncrKey);",
          "241:         SGXWalletServer::writeDataToDB(dhKeyName, hexEncrKey);",
          "243:         string shareG2_name = \"shareG2_\" + polyName + \"_\" + to_string(i) + \":\";",
          "246:         spdlog::debug(\"s_shareG2: {}\", s_shareG2);",
          "248:         SGXWalletServer::writeDataToDB(shareG2_name, s_shareG2);",
          "250:         spdlog::debug(\"errMsg: {}\", errMsg1);",
          "263: VerifyShares(const char *publicShares, const char *encr_sshare, const char *encryptedKeyHex, int t, int n, int ind) {",
          "",
          "[Added Lines]",
          "115:     vector<char> errMsg1(BUF_LEN, 0);",
          "117:     int errStatus = 0;",
          "123:     vector<char> pubShares(10000, 0);",
          "125:     uint64_t encLen = 0;",
          "127:     vector<uint8_t> encrDKGPoly(2 * BUF_LEN, 0);",
          "129:     if (!hex2carray2(encryptedPolyHex, &encLen, encrDKGPoly.data(), 6100)) {",
          "135:     spdlog::debug(\"enc len {}\", encLen);",
          "141:         status = get_public_shares(eid, &errStatus, errMsg1.data(), encrDKGPoly.data(), len, pubShares.data(), t, n);",
          "144:         status = get_public_shares_aes(eid, &errStatus, errMsg1.data(), encrDKGPoly.data(), encLen, pubShares.data(), t, n);",
          "146:     if (errStatus != 0) {",
          "147:         throw RPCException(-666, errMsg1.data());",
          "151:     spdlog::debug(\"err msg is {}\", errMsg1.data());",
          "154:     spdlog::debug(\"{}\", pubShares.data());;",
          "155:     spdlog::debug(\"get_public_shares status: {}\", errStatus);",
          "157:     vector<string> g2Strings = splitString(pubShares.data(), ',');",
          "158:     vector<vector<string>> pubSharesVect;",
          "159:     for (uint64_t i = 0; i < g2Strings.size(); i++) {",
          "160:         vector<string> coeffStr = splitString(g2Strings.at(i).c_str(), ':');",
          "161:         pubSharesVect.push_back(coeffStr);",
          "164:     return pubSharesVect;",
          "167: string get_secret_shares(const string &_polyName, const char *_encryptedPolyHex, const vector<string> &_publicKeys, int _t,",
          "168:                          int _n) {",
          "170:     vector<char> errMsg1(BUF_LEN, 0);",
          "171:     vector<char> hexEncrKey(BUF_LEN, 0);",
          "172:     int errStatus = 0;",
          "173:     uint64_t encLen = 0;",
          "176:     vector<uint8_t > encrDKGPoly(BUF_LEN, 0);",
          "178:     if (!hex2carray2(_encryptedPolyHex, &encLen, encrDKGPoly.data(), 6100)) {",
          "185:         status = set_encrypted_dkg_poly(eid, &errStatus, errMsg1.data(), encrDKGPoly.data());",
          "187:         status = set_encrypted_dkg_poly_aes(eid, &errStatus, errMsg1.data(), encrDKGPoly.data(), &encLen);",
          "189:     if (status != SGX_SUCCESS || errStatus != 0) {",
          "190:         throw RPCException(-666, errMsg1.data());",
          "196:     for (int i = 0; i < _n; i++) {",
          "197:         vector<uint8_t > encryptedSkey(BUF_LEN, 0);",
          "198:         uint32_t decLen;",
          "199:         vector<char> currentShare(193, 0);",
          "200:         vector<char> sShareG2(320, 0);",
          "202:         string pub_keyB = _publicKeys.at(i);",
          "203:         vector<char> pubKeyB(129,0);",
          "205:         strncpy(pubKeyB.data(), pub_keyB.c_str(), 128);",
          "206:         pubKeyB.at(128) = 0;",
          "212:             get_encr_sshare(eid, &errStatus, errMsg1.data(), encryptedSkey.data(), &decLen,",
          "213:                             currentShare.data(), sShareG2.data(), pubKeyB.data(), _t, _n, i + 1);",
          "215:             get_encr_sshare_aes(eid, &errStatus, errMsg1.data(), encryptedSkey.data(), &decLen,",
          "216:                                 currentShare.data(), sShareG2.data(), pubKeyB.data(), _t, _n, i + 1);",
          "217:         if (errStatus != 0) {",
          "218:             throw RPCException(-666, errMsg1.data());",
          "221:         spdlog::debug(\"cur_share is {}\", currentShare.data());",
          "223:         result += string(currentShare.data());",
          "225:         spdlog::debug(\"dec len is {}\", decLen);",
          "226:         carray2Hex(encryptedSkey.data(), decLen, hexEncrKey.data());",
          "227:         string dhKeyName = \"DKG_DH_KEY_\" + _polyName + \"_\" + to_string(i) + \":\";",
          "229:         spdlog::debug(\"hexEncr DH Key: { }\", hexEncrKey.data());",
          "230:         SGXWalletServer::writeDataToDB(dhKeyName, hexEncrKey.data());",
          "232:         string shareG2_name = \"shareG2_\" + _polyName + \"_\" + to_string(i) + \":\";",
          "235:         spdlog::debug(\"s_shareG2: {}\", sShareG2.data());",
          "237:         SGXWalletServer::writeDataToDB(shareG2_name, sShareG2.data());",
          "239:         spdlog::debug(\"errMsg: {}\", errMsg1.data());",
          "247: verifyShares(const char *publicShares, const char *encr_sshare, const char *encryptedKeyHex, int t, int n, int ind) {",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "272:         throw RPCException(INVALID_HEX, \"Invalid encryptedPolyHex\");",
          "273:     }",
          "274:     int result;",
          "279:     spdlog::debug(\"publicShares length is {}\", char_traits<char>::length(publicShares));",
          "281:     char pshares[8193];",
          "",
          "[Removed Lines]",
          "275:     cerr << \"encryptedKeyHex \" << encryptedKeyHex << endl;",
          "276:     cerr << \"dec_key_len \" << dec_key_len << endl;",
          "277:     cerr << \"encr_sshare length is \" << strlen(encr_sshare) << endl;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "320:     uint32_t enc_bls_len = 0;",
          "323:     if (!encryptKeys)",
          "324:         create_bls_key(eid, &err_status, errMsg1, s_shares, encr_key, dec_key_len, encr_bls_key, &enc_bls_len);",
          "325:     else",
          "326:         create_bls_key_aes(eid, &err_status, errMsg1, s_shares, encr_key, dec_key_len, encr_bls_key, &enc_bls_len);",
          "328:     if (err_status != 0) {",
          "330:         spdlog::error(errMsg1);",
          "331:         spdlog::error(\"status {}\", err_status);",
          "332:         throw RPCException(ERROR_IN_ENCLAVE, \"Create BLS private key failed in enclave\");",
          "333:     } else {",
          "335:         char hexBLSKey[2 * BUF_LEN];",
          "339:         carray2Hex(encr_bls_key, enc_bls_len, hexBLSKey);",
          "347:         return true;",
          "348:     }",
          "",
          "[Removed Lines]",
          "341:         SGXWalletServer::writeDataToDB(blsKeyName, hexBLSKey);",
          "343:         spdlog::debug(\"hexBLSKey length is {}\", char_traits<char>::length(hexBLSKey));",
          "344:         spdlog::debug(\"bls key {}\", blsKeyName, \" is \", hexBLSKey);",
          "",
          "[Added Lines]",
          "321:         SGXWalletServer::writeDataToDB(blsKeyName, hexBLSKey);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "369:     else",
          "370:         get_bls_pub_key_aes(eid, &err_status, errMsg1, encr_key, dec_key_len, pub_key);",
          "371:     if (err_status != 0) {",
          "373:         throw RPCException(ERROR_IN_ENCLAVE, \"Failed to get BLS public key in enclave\");",
          "374:     }",
          "377:     spdlog::debug(\"errMsg1 is {}\", errMsg1);",
          "378:     spdlog::debug(\"pub key is \");",
          "",
          "[Removed Lines]",
          "372:         std::cerr << errMsg1 << \" status is \" << err_status << std::endl;",
          "375:     vector<string> pub_key_vect = SplitString(pub_key, ':');",
          "",
          "[Added Lines]",
          "348:         spdlog::error(string(errMsg1) + \" . Status is  {}\", err_status);",
          "351:     vector<string> pub_key_vect = splitString(pub_key, ':');",
          "",
          "---------------"
        ],
        "DKGCrypto.h||DKGCrypto.h": [
          "File: DKGCrypto.h -> DKGCrypto.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "32: std::vector <std::vector<std::string>> get_verif_vect(const char* encryptedPolyHex, int t, int n);",
          "40: std::string decrypt_DHKey(const std::string& polyName, int ind);",
          "",
          "[Removed Lines]",
          "34: std::vector<std::string> SplitString(const char* koefs, const char symbol);",
          "36: std::string get_secret_shares(const std::string& polyName, const char* encryptedPolyHex, const std::vector<std::string>& publicKeys, int t, int n);",
          "38: bool VerifyShares(const char* publicShares, const char* encr_sshare, const char * encryptedKeyHex,  int t, int n, int ind);",
          "",
          "[Added Lines]",
          "34: std::vector<std::string> splitString(const char* koefs, const char symbol);",
          "36: std::string get_secret_shares(const std::string& _polyName, const char* _encryptedPolyHex, const std::vector<std::string>& _publicKeys, int _t, int _n);",
          "38: bool verifyShares(const char* publicShares, const char* encr_sshare, const char * encryptedKeyHex, int t, int n, int ind);",
          "",
          "---------------"
        ],
        "ECDSACrypto.cpp||ECDSACrypto.cpp": [
          "File: ECDSACrypto.cpp -> ECDSACrypto.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "34: #include \"spdlog/spdlog.h\"",
          "43:     return result;",
          "44: }",
          "",
          "[Removed Lines]",
          "37: static std::default_random_engine randGen((unsigned int) time(0));",
          "39: std::string concatPubKeyWith0x(char *pub_key_x, char *pub_key_y) {",
          "40:     std::string px = pub_key_x;",
          "41:     std::string py = pub_key_y;",
          "42:     std::string result = \"0x\" + px + py;// + std::to_string(pub_key_x) + std::to_string(pub_key_y);",
          "",
          "[Added Lines]",
          "37: static default_random_engine randGen((unsigned int) time(0));",
          "39: string concatPubKeyWith0x(char *pub_key_x, char *pub_key_y) {",
          "40:     string px = pub_key_x;",
          "41:     string py = pub_key_y;",
          "42:     string result = \"0x\" + px + py;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "57:         status = generate_ecdsa_key_aes(eid, &err_status, errMsg, encr_pr_key, &enc_len, pub_key_x, pub_key_y);",
          "59:     if (status != SGX_SUCCESS || err_status != 0) {",
          "61:         throw RPCException(status, errMsg);",
          "62:     }",
          "63:     std::vector<std::string> keys(3);",
          "68:     char *hexEncrKey = (char *) calloc(BUF_LEN * 2, 1);",
          "69:     carray2Hex(encr_pr_key, enc_len, hexEncrKey);",
          "70:     keys.at(0) = hexEncrKey;",
          "71:     keys.at(1) = std::string(pub_key_x) + std::string(pub_key_y);//concatPubKeyWith0x(pub_key_x, pub_key_y);//",
          "76:     unsigned long seed = randGen();",
          "79:     gmp_randstate_t state;",
          "80:     gmp_randinit_default(state);",
          "",
          "[Removed Lines]",
          "60:         std::cerr << \"RPCException thrown with status\" << status << std::endl;",
          "64:         std::cerr << \"account key is \" << errMsg << std::endl;",
          "65:         std::cerr << \"enc_len is \" << enc_len << std::endl;",
          "77:         spdlog::debug(\"seed is {}\", seed);",
          "78:         std::cerr << \"strlen is \" << strlen(hexEncrKey) << std::endl;",
          "",
          "[Added Lines]",
          "60:         spdlog::error(\"RPCException thrown with status {}\", status);",
          "74:     spdlog::debug(\"seed is {}\", seed);",
          "",
          "---------------"
        ],
        "SGXWalletServer.cpp||SGXWalletServer.cpp": [
          "File: SGXWalletServer.cpp -> SGXWalletServer.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "48: void setFullOptions(int _printDebugInfo, int _useHTTPS, int _autoconfirm, int _encryptKeys) {",
          "49:     if (_printDebugInfo)",
          "52:         spdlog::set_level(spdlog::level::debug);",
          "53:     }",
          "54:     printDebugInfo = _printDebugInfo;",
          "55:     useHTTPS = _useHTTPS;",
          "",
          "[Removed Lines]",
          "50:         spdlog::set_level(spdlog::level::info);",
          "51:     else {",
          "",
          "[Added Lines]",
          "51:     else {",
          "52:         spdlog::set_level(spdlog::level::info);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "481:     return result;",
          "482: }",
          "485:     Json::Value result;",
          "486:     result[\"status\"] = 0;",
          "487:     result[\"errorMessage\"] = \"\";",
          "489:     try {",
          "491:             throw RPCException(INVALID_DKG_PARAMS, \"invalid number of public keys\");",
          "492:         }",
          "493:         if (!checkName(_polyName, \"POLY\")) {",
          "",
          "[Removed Lines]",
          "484: Json::Value SGXWalletServer::getSecretShareImpl(const string &_polyName, const Json::Value &_publicKeys, int _t, int _n) {",
          "490:         if (_publicKeys.size() != (uint64_t) _n) {",
          "",
          "[Added Lines]",
          "484: Json::Value SGXWalletServer::getSecretShareImpl(const string &_polyName, const Json::Value &_pubKeys, int _t, int _n) {",
          "490:         if (_pubKeys.size() != (uint64_t) _n) {",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "500:         shared_ptr<string> encr_poly_ptr = readFromDb(_polyName);",
          "503:         for (int i = 0; i < _n; i++) {",
          "506:                 throw RPCException(INVALID_HEX, \"Invalid public key\");",
          "507:             }",
          "509:         }",
          "513:         result[\"secretShare\"] = s;",
          "",
          "[Removed Lines]",
          "502:         vector<string> pubKeys_vect;",
          "504:             std::cerr << \"publicKeys \" << i << \" is \" << _publicKeys[i].asString() << std::endl;",
          "505:             if (!checkHex(_publicKeys[i].asString(), 64)) {",
          "508:             pubKeys_vect.push_back(_publicKeys[i].asString());",
          "511:         string s = get_secret_shares(_polyName, encr_poly_ptr->c_str(), pubKeys_vect, _t, _n);",
          "",
          "[Added Lines]",
          "502:         vector<string> pubKeysStrs;",
          "504:             if (!checkHex(_pubKeys[i].asString(), 64)) {",
          "507:             pubKeysStrs.push_back(_pubKeys[i].asString());",
          "510:         string s = get_secret_shares(_polyName, encr_poly_ptr->c_str(), pubKeysStrs, _t, _n);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "548:         shared_ptr<string> encryptedKeyHex_ptr = readFromDb(_ethKeyName);",
          "551:             result[\"result\"] = false;",
          "552:         }",
          "",
          "[Removed Lines]",
          "550:         if (!VerifyShares(_publicShares.c_str(), _secretShare.c_str(), encryptedKeyHex_ptr->c_str(), _t, _n, _index)) {",
          "",
          "[Added Lines]",
          "549:         if (!verifyShares(_publicShares.c_str(), _secretShare.c_str(), encryptedKeyHex_ptr->c_str(), _t, _n, _index)) {",
          "",
          "---------------"
        ],
        "SGXWalletServer.hpp||SGXWalletServer.hpp": [
          "File: SGXWalletServer.hpp -> SGXWalletServer.hpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "113:     static Json::Value getVerificationVectorImpl(const string &_polyName, int _t, int _n);",
          "117:     static Json::Value",
          "118:     dkgVerificationImpl(const string &_publicShares, const string &_ethKeyName, const string &_secretShare,",
          "",
          "[Removed Lines]",
          "115:     static Json::Value getSecretShareImpl(const string &_polyName, const Json::Value &_publicKeys, int _t, int _n);",
          "",
          "[Added Lines]",
          "115:     static Json::Value getSecretShareImpl(const string &_polyName, const Json::Value &_pubKeys, int _t, int _n);",
          "",
          "---------------"
        ],
        "docker/start.sh||docker/start.sh": [
          "File: docker/start.sh -> docker/start.sh",
          "--- Hunk 1 ---",
          "[Context before]",
          "5: echo $1",
          "6: if [ \"$1\" = -t ]; then",
          "7:   set -e",
          "27: else",
          "28:    ./sgxwallet $1 $2 $3 $4",
          "29: fi",
          "",
          "[Removed Lines]",
          "8: #  ./testw [bls-key-encrypt]",
          "9: #  ./testw [bls-key-encrypt-decrypt]",
          "10: #  ./testw [dkg-gen]",
          "11: #  ./testw [dkg-pub_shares]",
          "12: #  ./testw [dkg-verify]",
          "13: #  ./testw [ecdsa_test]",
          "14: #  ./testw [test_test]",
          "15: #  ./testw [get_pub_ecdsa_key_test]",
          "16: #  ./testw [bls_dkg]",
          "17: #  ./testw [api_test]",
          "18: #  ./testw [getServerStatus_test]",
          "19: #  ./testw [dkg_api_test]",
          "20: #  ./testw [is_poly_test]",
          "21: #  ./testw [AES-encrypt-decrypt]",
          "22: #./testw [ecdsa_api_test]",
          "23: #./testw [dkg-encr_sshares]",
          "24:  #./testw [bls_sign]",
          "25: #./testw [many_threads_test]",
          "26: #  ./testw [aes_dkg]",
          "",
          "[Added Lines]",
          "8: ./testw [bls-key-encrypt]",
          "9: ./testw [bls-key-encrypt-decrypt]",
          "10: ./testw [dkg-gen]",
          "11: ./testw [dkg-pub_shares]",
          "12: ./testw [dkg-verify]",
          "13: ./testw [ecdsa_test]",
          "14: ./testw [test_test]",
          "15: ./testw [get_pub_ecdsa_key_test]",
          "16: ./testw [bls_dkg]",
          "17: ./testw [api_test]",
          "18: ./testw [getServerStatus_test]",
          "19: ./testw [dkg_api_test]",
          "20: ./testw [is_poly_test]",
          "21: ./testw [AES-encrypt-decrypt]",
          "22: ./testw [ecdsa_api_test]",
          "23: ./testw [dkg-encr_sshares]",
          "24: #./testw [bls_sign]",
          "25: /testw [many_threads_test]",
          "26: ./testw [aes_dkg]",
          "",
          "---------------"
        ],
        "sgxwallet_common.h||sgxwallet_common.h": [
          "File: sgxwallet_common.h -> sgxwallet_common.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "51: #define  MAX_KEY_LENGTH 128",
          "52: #define  MAX_COMPONENT_LENGTH 80",
          "",
          "[Removed Lines]",
          "49: #define BUF_LEN 1024",
          "",
          "[Added Lines]",
          "49: #define BUF_LEN 4096",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "59: #define ADD_ENTROPY_SIZE 32",
          "64: #define SECRET_SHARE_NUM_BYTES 96",
          "66: #define ECDSA_SKEY_LEN 65",
          "",
          "[Removed Lines]",
          "61: #define  DKG_BUFER_LENGTH 2490//3060",
          "62: #define  DKG_MAX_SEALED_LEN 3050",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "testw.cpp||testw.cpp": [
          "File: testw.cpp -> testw.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "179:     initAll(false, true);",
          "183:     vector<char> errMsg(BUF_LEN, 0);",
          "185:     int err_status = 0;",
          "186:     uint32_t enc_len = 0;",
          "189:     REQUIRE(status == SGX_SUCCESS);",
          "195:     vector<char> errMsg1(BUF_LEN, 0);",
          "197:     uint32_t dec_len;",
          "199:                                 (uint8_t *) secret.data(), &dec_len);",
          "201:     REQUIRE(status == SGX_SUCCESS);",
          "",
          "[Removed Lines]",
          "182:     vector<uint8_t> encrypted_dkg_secret(DKG_MAX_SEALED_LEN, 0);",
          "188:     status = gen_dkg_secret(eid, &err_status, errMsg.data(), encrypted_dkg_secret.data(), &enc_len, 32);",
          "193:     vector<char> secret(DKG_BUFER_LENGTH, 0);",
          "198:     status = decrypt_dkg_secret(eid, &err_status, errMsg1.data(), encrypted_dkg_secret.data(),",
          "",
          "[Added Lines]",
          "182:     vector<uint8_t> encryptedDKGSecret(BUF_LEN, 0);",
          "188:     status = gen_dkg_secret(eid, &err_status, errMsg.data(), encryptedDKGSecret.data(), &enc_len, 32);",
          "193:     vector<char> secret(BUF_LEN, 0);",
          "197:     status = decrypt_dkg_secret(eid, &err_status, errMsg1.data(), encryptedDKGSecret.data(),",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "271:     libff::init_alt_bn128_params();",
          "274:     vector<char> errMsg(BUF_LEN, 0);",
          "276:     int err_status = 0;",
          "",
          "[Removed Lines]",
          "273:     vector<uint8_t> encrypted_dkg_secret(DKG_MAX_SEALED_LEN, 0);",
          "",
          "[Added Lines]",
          "272:     vector<uint8_t> encrypted_dkg_secret(BUF_LEN, 0);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "299:     vector<libff::alt_bn128_G2> pub_shares_G2;",
          "300:     for (u_int64_t i = 0; i < G2_strings.size(); i++) {",
          "305:         pub_shares_G2.push_back(VectStringToG2(koef_str));",
          "306:     }",
          "310:     status = decrypt_dkg_secret(eid, &err_status, errMsg1.data(), encrypted_dkg_secret.data(),",
          "311:                                 (uint8_t *) secret.data(), &enc_len);",
          "",
          "[Removed Lines]",
          "298:     vector<string> G2_strings = SplitString(public_shares.data(), ',');",
          "301:         vector<string> koef_str = SplitString(G2_strings.at(i).c_str(), ':');",
          "308:     vector<char> secret(DKG_MAX_SEALED_LEN, 0);",
          "",
          "[Added Lines]",
          "297:     vector<string> G2_strings = splitString(public_shares.data(), ',');",
          "300:         vector<string> koef_str = splitString(G2_strings.at(i).c_str(), ':');",
          "307:     vector<char> secret(BUF_LEN, 0);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "348:     int err_status = 0;",
          "349:     uint32_t enc_len = 0;",
          "352:     status = gen_dkg_secret(eid, &err_status, errMsg.data(), encrypted_dkg_secret.data(), &enc_len, 2);",
          "353:     REQUIRE(status == SGX_SUCCESS);",
          "",
          "[Removed Lines]",
          "351:     vector<uint8_t> encrypted_dkg_secret(DKG_MAX_SEALED_LEN, 0);",
          "",
          "[Added Lines]",
          "350:     vector<uint8_t> encrypted_dkg_secret(BUF_LEN, 0);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "385:     int err_status = 0;",
          "386:     uint32_t enc_len = 0;",
          "390:     status = gen_dkg_secret(eid, &err_status, errMsg.data(), encrypted_dkg_secret.data(), &enc_len, 2);",
          "391:     REQUIRE(status == SGX_SUCCESS);",
          "",
          "[Removed Lines]",
          "388:     vector<uint8_t> encrypted_dkg_secret(DKG_MAX_SEALED_LEN, 1);",
          "",
          "[Added Lines]",
          "387:     vector<uint8_t> encrypted_dkg_secret(BUF_LEN, 0);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "485:     setOptions(false, false, true);",
          "486:     initAll(false, true);",
          "489:     vector<char> errMsg(BUF_LEN, 0);",
          "513:     REQUIRE(status == SGX_SUCCESS);",
          "",
          "[Removed Lines]",
          "488:     int err_status = 0;",
          "490:     vector<uint8_t> encr_pr_key(BUF_LEN, 0);",
          "491:     vector<char> pub_key_x(BUF_LEN, 0);",
          "492:     vector<char> pub_key_y(BUF_LEN, 0);",
          "493:     uint32_t enc_len = 0;",
          "496:     status = generate_ecdsa_key(eid, &err_status, errMsg.data(), encr_pr_key.data(), &enc_len, pub_key_x.data(),",
          "497:                                 pub_key_y.data());",
          "499:     REQUIRE(status == SGX_SUCCESS);",
          "505:     for ( int i = 0; i < BUF_LEN ; i++)",
          "508:     vector<char> got_pub_key_x(BUF_LEN, 0);",
          "509:     vector<char> got_pub_key_y(BUF_LEN, 0);",
          "511:     status = get_public_ecdsa_key(eid, &err_status, errMsg.data(), encr_pr_key.data(), enc_len, got_pub_key_x.data(),",
          "512:                                   got_pub_key_y.data());",
          "",
          "[Added Lines]",
          "487:     int errStatus = 0;",
          "489:     vector<uint8_t> encPrivKey(BUF_LEN, 0);",
          "490:     vector<char> pubKeyX(BUF_LEN, 0);",
          "491:     vector<char> pubKeyY(BUF_LEN, 0);",
          "492:     uint32_t encLen = 0;",
          "495:     status = generate_ecdsa_key(eid, &errStatus, errMsg.data(), encPrivKey.data(), &encLen, pubKeyX.data(),",
          "496:                                 pubKeyY.data());",
          "498:     REQUIRE(status == SGX_SUCCESS);",
          "500:     vector<char> receivedPubKeyX(BUF_LEN, 0);",
          "501:     vector<char> receivedPubKeyY(BUF_LEN, 0);",
          "503:     status = get_public_ecdsa_key(eid, &errStatus, errMsg.data(), encPrivKey.data(), encLen, receivedPubKeyX.data(),",
          "504:                                   receivedPubKeyY.data());",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2022-1725",
  "cve_desc": "NULL Pointer Dereference in GitHub repository vim/vim prior to 8.2.4959.",
  "repo": "vim/vim",
  "patch_hash": "b62dc5e7825bc195efe3041d5b3a9f1528359e1c",
  "patch_info": {
    "commit_hash": "b62dc5e7825bc195efe3041d5b3a9f1528359e1c",
    "repo": "vim/vim",
    "commit_url": "https://github.com/vim/vim/commit/b62dc5e7825bc195efe3041d5b3a9f1528359e1c",
    "files": [
      "src/buffer.c",
      "src/testdir/test_buffer.vim",
      "src/version.c"
    ],
    "message": "patch 8.2.4959: using NULL regexp program\n\nProblem:    Using NULL regexp program.\nSolution:   Check for regexp program becoming NULL in more places.",
    "before_after_code_files": [
      "src/buffer.c||src/buffer.c",
      "src/testdir/test_buffer.vim||src/testdir/test_buffer.vim",
      "src/version.c||src/version.c"
    ]
  },
  "patch_diff": {
    "src/buffer.c||src/buffer.c": [
      "File: src/buffer.c -> src/buffer.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "2642:   if (*p == '^' && !(attempt & 1))  // add/remove '^'",
      "2643:       ++p;",
      "2644:   regmatch.regprog = vim_regcomp(p, magic_isset() ? RE_MAGIC : 0);",
      "2651:   FOR_ALL_BUFS_FROM_LAST(buf)",
      "2652:       if (buf->b_p_bl == find_listed",
      "2653: #ifdef FEAT_DIFF",
      "2654:        && (!diffmode || diff_mode_buf(buf))",
      "",
      "[Removed Lines]",
      "2645:   if (regmatch.regprog == NULL)",
      "2646:   {",
      "2647:       vim_free(pat);",
      "2648:       return -1;",
      "2649:   }",
      "",
      "[Added Lines]",
      "2647:   {",
      "2648:       if (regmatch.regprog == NULL)",
      "2649:       {",
      "2651:    vim_free(pat);",
      "2652:    return -1;",
      "2653:       }",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "2674:    }",
      "2675:    match = buf->b_fnum; // remember first match",
      "2676:       }",
      "2678:   vim_regfree(regmatch.regprog);",
      "2679:   if (match >= 0)   // found one match",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "2679:   }",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "2766:      if (attempt > 0 && patc == pat)",
      "2767:   break; // there was no anchor, no need to try again",
      "2768:      regmatch.regprog = vim_regcomp(patc + attempt * 11, RE_MAGIC);",
      "2775:  }",
      "",
      "[Removed Lines]",
      "2769:      if (regmatch.regprog == NULL)",
      "2770:      {",
      "2771:   if (patc != pat)",
      "2772:       vim_free(patc);",
      "2773:   return FAIL;",
      "2774:      }",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "2792: #endif",
      "2794:   if (!fuzzy)",
      "2795:       p = buflist_match(&regmatch, buf, p_wic);",
      "2796:   else",
      "2797:   {",
      "2798:       p = NULL;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "2792:   {",
      "2793:       if (regmatch.regprog == NULL)",
      "2794:       {",
      "2796:    if (patc != pat)",
      "2797:        vim_free(patc);",
      "2798:    return FAIL;",
      "2799:       }",
      "2801:   }",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "2951:     char_u *match = NULL;",
      "2952:     char_u *p;",
      "2955:     {",
      "2957:  rmp->rm_ic = p_fic || ignore_case;",
      "",
      "[Removed Lines]",
      "2954:     if (name != NULL)",
      "",
      "[Added Lines]",
      "2963:     if (name != NULL && rmp->regprog != NULL)",
      "",
      "---------------"
    ],
    "src/testdir/test_buffer.vim||src/testdir/test_buffer.vim": [
      "File: src/testdir/test_buffer.vim -> src/testdir/test_buffer.vim",
      "--- Hunk 1 ---",
      "[Context before]",
      "419:   vsplit 00000000000000000000000000",
      "420:   silent! buf [0--]\\&\\zs*\\zs*e",
      "421:   bwipe!",
      "422: endfunc",
      "424: \" Test for the 'maxmem' and 'maxmemtot' options",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "423:   \" similar case with different code path",
      "424:   split 0",
      "425:   edit \u00ff",
      "426:   silent! buf [0--]\\&\\zs*\\zs*0",
      "427:   bwipe!",
      "",
      "---------------"
    ],
    "src/version.c||src/version.c": [
      "File: src/version.c -> src/version.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "747: static int included_patches[] =",
      "750:     4958,",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "750:     4959,",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "1cfb14aa972ccf3235ac67f07b7db1175b7c5384",
      "candidate_info": {
        "commit_hash": "1cfb14aa972ccf3235ac67f07b7db1175b7c5384",
        "repo": "vim/vim",
        "commit_url": "https://github.com/vim/vim/commit/1cfb14aa972ccf3235ac67f07b7db1175b7c5384",
        "files": [
          "src/autocmd.c",
          "src/buffer.c",
          "src/charset.c",
          "src/cindent.c",
          "src/clientserver.c",
          "src/cmdexpand.c",
          "src/debugger.c",
          "src/dict.c",
          "src/diff.c",
          "src/digraph.c",
          "src/edit.c",
          "src/evalfunc.c",
          "src/evalwindow.c",
          "src/ex_cmds.c",
          "src/ex_cmds2.c",
          "src/ex_getln.c",
          "src/filepath.c",
          "src/findfile.c",
          "src/fold.c",
          "src/hardcopy.c",
          "src/highlight.c",
          "src/version.c"
        ],
        "message": "patch 9.0.1166: code is indented more than necessary\n\nProblem:    Code is indented more than necessary.\nSolution:   Use an early return where it makes sense. (Yegappan Lakshmanan,\n            closes #11792)",
        "before_after_code_files": [
          "src/autocmd.c||src/autocmd.c",
          "src/buffer.c||src/buffer.c",
          "src/charset.c||src/charset.c",
          "src/cindent.c||src/cindent.c",
          "src/clientserver.c||src/clientserver.c",
          "src/cmdexpand.c||src/cmdexpand.c",
          "src/debugger.c||src/debugger.c",
          "src/dict.c||src/dict.c",
          "src/diff.c||src/diff.c",
          "src/digraph.c||src/digraph.c",
          "src/edit.c||src/edit.c",
          "src/evalfunc.c||src/evalfunc.c",
          "src/evalwindow.c||src/evalwindow.c",
          "src/ex_cmds.c||src/ex_cmds.c",
          "src/ex_cmds2.c||src/ex_cmds2.c",
          "src/ex_getln.c||src/ex_getln.c",
          "src/filepath.c||src/filepath.c",
          "src/findfile.c||src/findfile.c",
          "src/fold.c||src/fold.c",
          "src/hardcopy.c||src/hardcopy.c",
          "src/highlight.c||src/highlight.c",
          "src/version.c||src/version.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/buffer.c||src/buffer.c",
            "src/version.c||src/version.c"
          ],
          "candidate": [
            "src/buffer.c||src/buffer.c",
            "src/version.c||src/version.c"
          ]
        }
      },
      "candidate_diff": {
        "src/autocmd.c||src/autocmd.c": [
          "File: src/autocmd.c -> src/autocmd.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1064:     for (p = arg; *p && !VIM_ISWHITE(*p) && *p != '|'; ++p)",
          "1065:  ;",
          "1078:     return group;",
          "1079: }",
          "",
          "[Removed Lines]",
          "1066:     if (p > arg)",
          "1067:     {",
          "1068:  group_name = vim_strnsave(arg, p - arg);",
          "1069:  if (group_name == NULL)  // out of memory",
          "1070:      return AUGROUP_ERROR;",
          "1071:  group = au_find_group(group_name);",
          "1072:  if (group == AUGROUP_ERROR)",
          "1073:      group = AUGROUP_ALL; // no match, use all groups",
          "1074:  else",
          "1076:  vim_free(group_name);",
          "1077:     }",
          "",
          "[Added Lines]",
          "1066:     if (p <= arg)",
          "1067:  return AUGROUP_ALL;",
          "1069:     group_name = vim_strnsave(arg, p - arg);",
          "1070:     if (group_name == NULL)  // out of memory",
          "1071:  return AUGROUP_ERROR;",
          "1072:     group = au_find_group(group_name);",
          "1073:     if (group == AUGROUP_ERROR)",
          "1074:  group = AUGROUP_ALL; // no match, use all groups",
          "1075:     else",
          "1077:     vim_free(group_name);",
          "",
          "---------------"
        ],
        "src/buffer.c||src/buffer.c": [
          "File: src/buffer.c -> src/buffer.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "357:     apply_autocmds(EVENT_BUFENTER, NULL, NULL, FALSE, curbuf);",
          "358: #endif",
          "361:     {",
          "377: #ifdef FEAT_EVAL",
          "380: #else",
          "383: #endif",
          "388:  }",
          "389:     }",
          "",
          "[Removed Lines]",
          "360:     if (retval == OK)",
          "364:  if (bufref_valid(&old_curbuf) && old_curbuf.br_buf->b_ml.ml_mfp != NULL)",
          "365:  {",
          "366:      aco_save_T aco;",
          "370:      aucmd_prepbuf(&aco, old_curbuf.br_buf);",
          "371:      if (curbuf == old_curbuf.br_buf)",
          "372:      {",
          "373:   do_modelines(0);",
          "374:   curbuf->b_flags &= ~(BF_CHECK_RO | BF_NEVERLOADED);",
          "376:   if ((flags & READ_NOWINENTER) == 0)",
          "378:       apply_autocmds_retval(EVENT_BUFWINENTER, NULL, NULL,",
          "379:              FALSE, curbuf, &retval);",
          "381:       apply_autocmds(EVENT_BUFWINENTER, NULL, NULL,",
          "382:         FALSE, curbuf);",
          "386:   aucmd_restbuf(&aco);",
          "387:      }",
          "",
          "[Added Lines]",
          "360:     if (retval != OK)",
          "361:  return retval;",
          "365:     if (bufref_valid(&old_curbuf) && old_curbuf.br_buf->b_ml.ml_mfp != NULL)",
          "367:  aco_save_T aco;",
          "371:  aucmd_prepbuf(&aco, old_curbuf.br_buf);",
          "372:  if (curbuf == old_curbuf.br_buf)",
          "373:  {",
          "374:      do_modelines(0);",
          "375:      curbuf->b_flags &= ~(BF_CHECK_RO | BF_NEVERLOADED);",
          "377:      if ((flags & READ_NOWINENTER) == 0)",
          "379:   apply_autocmds_retval(EVENT_BUFWINENTER, NULL, NULL,",
          "380:    FALSE, curbuf, &retval);",
          "382:      apply_autocmds(EVENT_BUFWINENTER, NULL, NULL,",
          "383:       FALSE, curbuf);",
          "387:      aucmd_restbuf(&aco);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "3019:     char_u *p;",
          "3023:     {",
          "3027:      match = name;",
          "3036:     }",
          "3038:     return match;",
          "",
          "[Removed Lines]",
          "3022:     if (name != NULL && rmp->regprog != NULL)",
          "3025:  rmp->rm_ic = p_fic || ignore_case;",
          "3026:  if (vim_regexec(rmp, name, (colnr_T)0))",
          "3028:  else if (rmp->regprog != NULL)",
          "3029:  {",
          "3031:      p = home_replace_save(NULL, name);",
          "3032:      if (p != NULL && vim_regexec(rmp, p, (colnr_T)0))",
          "3033:   match = name;",
          "3034:      vim_free(p);",
          "3035:  }",
          "",
          "[Added Lines]",
          "3021:     if (name == NULL || rmp->regprog == NULL)",
          "3022:  return NULL;",
          "3025:     rmp->rm_ic = p_fic || ignore_case;",
          "3026:     if (vim_regexec(rmp, name, (colnr_T)0))",
          "3027:  match = name;",
          "3028:     else if (rmp->regprog != NULL)",
          "3031:  p = home_replace_save(NULL, name);",
          "3032:  if (p != NULL && vim_regexec(rmp, p, (colnr_T)0))",
          "3034:  vim_free(p);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "3160: {",
          "3161:     win_T *wp;",
          "3173: }",
          "3174: #endif",
          "",
          "[Removed Lines]",
          "3163:     if (wip->wi_opt.wo_diff)",
          "3164:     {",
          "3165:  FOR_ALL_WINDOWS(wp)",
          "3168:      if (wip->wi_win == wp)",
          "3169:   return FALSE;",
          "3170:  return TRUE;",
          "3171:     }",
          "3172:     return FALSE;",
          "",
          "[Added Lines]",
          "3162:     if (!wip->wi_opt.wo_diff)",
          "3163:  return FALSE;",
          "3165:     FOR_ALL_WINDOWS(wp)",
          "3168:  if (wip->wi_win == wp)",
          "3169:      return FALSE;",
          "3170:     return TRUE;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "3198:   && (!need_options || wip->wi_optset))",
          "3199:      break;",
          "3208: #ifdef FEAT_DIFF",
          "3221:     }",
          "3222:     return wip;",
          "3223: }",
          "",
          "[Removed Lines]",
          "3206:     if (wip == NULL)",
          "3207:     {",
          "3209:  if (skip_diff_buffer)",
          "3210:  {",
          "3211:      FOR_ALL_BUF_WININFO(buf, wip)",
          "3212:   if (!wininfo_other_tab_diff(wip)",
          "3213:    && (!need_options || wip->wi_optset",
          "3214:        || (wip->wi_win != NULL",
          "3215:           && wip->wi_win->w_buffer == buf)))",
          "3216:       break;",
          "3217:  }",
          "3218:  else",
          "3219: #endif",
          "3220:      wip = buf->b_wininfo;",
          "",
          "[Added Lines]",
          "3199:     if (wip != NULL)",
          "3200:  return wip;",
          "3208:     if (skip_diff_buffer)",
          "3209:     {",
          "3210:  FOR_ALL_BUF_WININFO(buf, wip)",
          "3211:      if (!wininfo_other_tab_diff(wip)",
          "3212:       && (!need_options || wip->wi_optset",
          "3213:    || (wip->wi_win != NULL",
          "3214:        && wip->wi_win->w_buffer == buf)))",
          "3215:   break;",
          "3217:     else",
          "3218: #endif",
          "3219:  wip = buf->b_wininfo;",
          "",
          "---------------"
        ],
        "src/charset.c||src/charset.c": [
          "File: src/charset.c -> src/charset.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "345:     }",
          "346:     else",
          "347:  res = alloc(vim_strsize(s) + 1);",
          "349:     {",
          "353:  {",
          "363:      else",
          "365:  }",
          "366:     }",
          "367:     return res;",
          "368: }",
          "",
          "[Removed Lines]",
          "348:     if (res != NULL)",
          "351:  p = s;",
          "352:  while (*p != NUL)",
          "354:      if (has_mbyte && (l = (*mb_ptr2len)(p)) > 1)",
          "355:      {",
          "356:   c = (*mb_ptr2char)(p);",
          "357:   if (vim_isprintc(c))",
          "358:       STRNCAT(res, p, l); // append printable multi-byte char",
          "359:   else",
          "360:       transchar_hex(res + STRLEN(res), c);",
          "361:   p += l;",
          "362:      }",
          "364:   STRCAT(res, transchar_byte(*p++));",
          "",
          "[Added Lines]",
          "349:     if (res == NULL)",
          "350:  return NULL;",
          "353:     p = s;",
          "354:     while (*p != NUL)",
          "356:  if (has_mbyte && (l = (*mb_ptr2len)(p)) > 1)",
          "358:      c = (*mb_ptr2char)(p);",
          "359:      if (vim_isprintc(c))",
          "360:   STRNCAT(res, p, l); // append printable multi-byte char",
          "362:   transchar_hex(res + STRLEN(res), c);",
          "363:      p += l;",
          "365:  else",
          "366:      STRCAT(res, transchar_byte(*p++));",
          "",
          "---------------"
        ],
        "src/cindent.c||src/cindent.c": [
          "File: src/cindent.c -> src/cindent.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "47:     cinw_len = (int)STRLEN(curbuf->b_p_cinw) + 1;",
          "48:     cinw_buf = alloc(cinw_len);",
          "50:     {",
          "53:  {",
          "61:  }",
          "63:     }",
          "64:     return retval;",
          "65: }",
          "",
          "[Removed Lines]",
          "49:     if (cinw_buf != NULL)",
          "51:  line = skipwhite(line);",
          "52:  for (cinw = curbuf->b_p_cinw; *cinw; )",
          "54:      len = copy_option_part(&cinw, cinw_buf, cinw_len, \",\");",
          "55:      if (STRNCMP(line, cinw_buf, len) == 0",
          "56:       && (!vim_iswordc(line[len]) || !vim_iswordc(line[len - 1])))",
          "57:      {",
          "58:   retval = TRUE;",
          "59:   break;",
          "60:      }",
          "62:  vim_free(cinw_buf);",
          "",
          "[Added Lines]",
          "49:     if (cinw_buf == NULL)",
          "50:  return FALSE;",
          "52:     line = skipwhite(line);",
          "53:     for (cinw = curbuf->b_p_cinw; *cinw; )",
          "55:  len = copy_option_part(&cinw, cinw_buf, cinw_len, \",\");",
          "56:  if (STRNCMP(line, cinw_buf, len) == 0",
          "57:   && (!vim_iswordc(line[len]) || !vim_iswordc(line[len - 1])))",
          "59:      retval = TRUE;",
          "60:      break;",
          "63:     vim_free(cinw_buf);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "644:     if (cin_isscopedecl(s))",
          "645:  return FALSE;",
          "680:  curwin->w_cursor = cursor_save;",
          "682:     }",
          "684: }",
          "",
          "[Removed Lines]",
          "647:     if (cin_islabel_skip(&s))",
          "648:     {",
          "651:  pos_T cursor_save;",
          "652:  pos_T *trypos;",
          "653:  char_u *line;",
          "655:  cursor_save = curwin->w_cursor;",
          "656:  while (curwin->w_cursor.lnum > 1)",
          "657:  {",
          "658:      --curwin->w_cursor.lnum;",
          "662:      curwin->w_cursor.col = 0;",
          "663:      if ((trypos = ind_find_start_CORS(NULL)) != NULL) // XXX",
          "664:   curwin->w_cursor = *trypos;",
          "666:      line = ml_get_curline();",
          "667:      if (cin_ispreproc(line)) // ignore #defines, #if, etc.",
          "668:   continue;",
          "669:      if (*(line = cin_skipcomment(line)) == NUL)",
          "670:   continue;",
          "672:      curwin->w_cursor = cursor_save;",
          "673:      if (cin_isterminated(line, TRUE, FALSE)",
          "674:       || cin_isscopedecl(line)",
          "675:       || cin_iscase(line, TRUE)",
          "676:       || (cin_islabel_skip(&line) && cin_nocode(line)))",
          "677:   return TRUE;",
          "678:      return FALSE;",
          "679:  }",
          "681:  return TRUE;  // label at start of file???",
          "683:     return FALSE;",
          "",
          "[Added Lines]",
          "647:     if (!cin_islabel_skip(&s))",
          "648:  return FALSE;",
          "652:     pos_T cursor_save;",
          "653:     pos_T *trypos;",
          "654:     char_u *line;",
          "656:     cursor_save = curwin->w_cursor;",
          "657:     while (curwin->w_cursor.lnum > 1)",
          "658:     {",
          "659:  --curwin->w_cursor.lnum;",
          "663:  curwin->w_cursor.col = 0;",
          "664:  if ((trypos = ind_find_start_CORS(NULL)) != NULL) // XXX",
          "665:      curwin->w_cursor = *trypos;",
          "667:  line = ml_get_curline();",
          "668:  if (cin_ispreproc(line)) // ignore #defines, #if, etc.",
          "669:      continue;",
          "670:  if (*(line = cin_skipcomment(line)) == NUL)",
          "671:      continue;",
          "674:  if (cin_isterminated(line, TRUE, FALSE)",
          "675:   || cin_isscopedecl(line)",
          "676:   || cin_iscase(line, TRUE)",
          "677:   || (cin_islabel_skip(&line) && cin_nocode(line)))",
          "678:      return TRUE;",
          "679:  return FALSE;",
          "681:     curwin->w_cursor = cursor_save;",
          "682:     return TRUE;  // label at start of file???",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1688: {",
          "1689:     pos_T *trypos = find_match_paren(ind_maxparen);",
          "1703:     return trypos;",
          "1704: }",
          "",
          "[Removed Lines]",
          "1691:     if (trypos != NULL)",
          "1692:     {",
          "1693:  pos_T *tryposBrace = find_start_brace();",
          "1697:  if (tryposBrace != NULL",
          "1698:   && (trypos->lnum != tryposBrace->lnum",
          "1699:       ? trypos->lnum < tryposBrace->lnum",
          "1700:       : trypos->col < tryposBrace->col))",
          "1701:      trypos = NULL;",
          "1702:     }",
          "",
          "[Added Lines]",
          "1690:     if (trypos == NULL)",
          "1691:  return NULL;",
          "1693:     pos_T *tryposBrace = find_start_brace();",
          "1697:     if (tryposBrace != NULL",
          "1698:      && (trypos->lnum != tryposBrace->lnum",
          "1699:   ? trypos->lnum < tryposBrace->lnum",
          "1700:   : trypos->col < tryposBrace->col))",
          "1701:  trypos = NULL;",
          "",
          "---------------"
        ],
        "src/clientserver.c||src/clientserver.c": [
          "File: src/clientserver.c -> src/clientserver.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "157:     char_u *res = data;",
          "175:     }",
          "176:     return res;",
          "177: }",
          "178: #endif",
          "",
          "[Removed Lines]",
          "160:     if (client_enc != NULL && p_enc != NULL)",
          "161:     {",
          "162:  vimconv_T vimconv;",
          "164:  vimconv.vc_type = CONV_NONE;",
          "165:  if (convert_setup(&vimconv, client_enc, p_enc) != FAIL",
          "166:            && vimconv.vc_type != CONV_NONE)",
          "167:  {",
          "168:      res = string_convert(&vimconv, data, NULL);",
          "169:      if (res == NULL)",
          "170:   res = data;",
          "171:      else",
          "173:  }",
          "174:  convert_setup(&vimconv, NULL, NULL);",
          "",
          "[Added Lines]",
          "160:     if (client_enc == NULL || p_enc == NULL)",
          "161:  return res;",
          "163:     vimconv_T vimconv;",
          "165:     vimconv.vc_type = CONV_NONE;",
          "166:     if (convert_setup(&vimconv, client_enc, p_enc) != FAIL",
          "167:      && vimconv.vc_type != CONV_NONE)",
          "168:     {",
          "169:  res = string_convert(&vimconv, data, NULL);",
          "170:  if (res == NULL)",
          "171:      res = data;",
          "172:  else",
          "175:     convert_setup(&vimconv, NULL, NULL);",
          "",
          "---------------"
        ],
        "src/cmdexpand.c||src/cmdexpand.c": [
          "File: src/cmdexpand.c -> src/cmdexpand.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1850: find_cmd_after_isearch_cmd(expand_T *xp, char_u *arg)",
          "1851: {",
          "1852:     arg = skipwhite(skipdigits(arg));     // skip count",
          "1854:     {",
          "1868:     }",
          "1870:     return NULL;",
          "",
          "[Removed Lines]",
          "1853:     if (*arg == '/') // Match regexp, not just whole words",
          "1855:  for (++arg; *arg && *arg != '/'; arg++)",
          "1856:      if (*arg == '\\\\' && arg[1] != NUL)",
          "1857:   arg++;",
          "1858:  if (*arg)",
          "1859:  {",
          "1860:      arg = skipwhite(arg + 1);",
          "1863:      if (*arg == NUL || vim_strchr((char_u *)\"|\\\"\\n\", *arg) == NULL)",
          "1864:   xp->xp_context = EXPAND_NOTHING;",
          "1865:      else",
          "1866:   return arg;",
          "1867:  }",
          "",
          "[Added Lines]",
          "1853:     if (*arg != '/')",
          "1854:  return NULL;",
          "1857:     for (++arg; *arg && *arg != '/'; arg++)",
          "1858:  if (*arg == '\\\\' && arg[1] != NUL)",
          "1859:      arg++;",
          "1860:     if (*arg)",
          "1862:  arg = skipwhite(arg + 1);",
          "1865:  if (*arg == NUL || vim_strchr((char_u *)\"|\\\"\\n\", *arg) == NULL)",
          "1866:      xp->xp_context = EXPAND_NOTHING;",
          "1867:  else",
          "1868:      return arg;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2780: {",
          "2781:     char *opts[] = {\"expr\", \"file\", \"func\", \"here\"};",
          "2784:     {",
          "2786:  if (breakpt_expand_what == EXP_BREAKPT_ADD)",
          "",
          "[Removed Lines]",
          "2783:     if (idx >=0 && idx <= 3)",
          "",
          "[Added Lines]",
          "2784:     if (idx >= 0 && idx <= 3)",
          "",
          "---------------"
        ],
        "src/debugger.c||src/debugger.c": [
          "File: src/debugger.c -> src/debugger.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "315:     char *p, *q;",
          "316:     int  maxbacktrace = 0;",
          "319:     {",
          "326:     }",
          "327:     return maxbacktrace;",
          "328: }",
          "",
          "[Removed Lines]",
          "318:     if (sname != NULL)",
          "320:  p = (char *)sname;",
          "321:  while ((q = strstr(p, \"..\")) != NULL)",
          "322:  {",
          "323:      p = q + 2;",
          "324:      maxbacktrace++;",
          "325:  }",
          "",
          "[Added Lines]",
          "318:     if (sname == NULL)",
          "319:  return 0;",
          "321:     p = (char *)sname;",
          "322:     while ((q = strstr(p, \"..\")) != NULL)",
          "324:  p = q + 2;",
          "325:  maxbacktrace++;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "486: {",
          "487:     int  prev_got_int;",
          "504: }",
          "",
          "[Removed Lines]",
          "489:     if (debug_skipped)",
          "490:     {",
          "493:  prev_got_int = got_int;",
          "494:  got_int = FALSE;",
          "495:  debug_breakpoint_name = debug_skipped_name;",
          "497:  eap->skip = FALSE;",
          "498:  (void)dbg_check_breakpoint(eap);",
          "499:  eap->skip = TRUE;",
          "500:  got_int |= prev_got_int;",
          "501:  return TRUE;",
          "502:     }",
          "503:     return FALSE;",
          "",
          "[Added Lines]",
          "489:     if (!debug_skipped)",
          "490:  return FALSE;",
          "494:     prev_got_int = got_int;",
          "495:     got_int = FALSE;",
          "496:     debug_breakpoint_name = debug_skipped_name;",
          "498:     eap->skip = FALSE;",
          "499:     (void)dbg_check_breakpoint(eap);",
          "500:     eap->skip = TRUE;",
          "501:     got_int |= prev_got_int;",
          "502:     return TRUE;",
          "",
          "---------------"
        ],
        "src/dict.c||src/dict.c": [
          "File: src/dict.c -> src/dict.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "30:     dict_T *d;",
          "32:     d = ALLOC_CLEAR_ONE(dict_T);",
          "48:     return d;",
          "49: }",
          "",
          "[Removed Lines]",
          "33:     if (d != NULL)",
          "34:     {",
          "36:  if (first_dict != NULL)",
          "37:      first_dict->dv_used_prev = d;",
          "38:  d->dv_used_next = first_dict;",
          "39:  d->dv_used_prev = NULL;",
          "40:  first_dict = d;",
          "42:  hash_init(&d->dv_hashtab);",
          "43:  d->dv_lock = 0;",
          "44:  d->dv_scope = 0;",
          "45:  d->dv_refcount = 0;",
          "46:  d->dv_copyID = 0;",
          "47:     }",
          "",
          "[Added Lines]",
          "33:     if (d == NULL)",
          "34:  return NULL;",
          "37:     if (first_dict != NULL)",
          "38:  first_dict->dv_used_prev = d;",
          "39:     d->dv_used_next = first_dict;",
          "40:     d->dv_used_prev = NULL;",
          "41:     first_dict = d;",
          "43:     hash_init(&d->dv_hashtab);",
          "44:     d->dv_lock = 0;",
          "45:     d->dv_scope = 0;",
          "46:     d->dv_refcount = 0;",
          "47:     d->dv_copyID = 0;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "228:     size_t len = STRLEN(key);",
          "230:     di = alloc(offsetof(dictitem_T, di_key) + len + 1);",
          "238:     return di;",
          "239: }",
          "",
          "[Removed Lines]",
          "231:     if (di != NULL)",
          "232:     {",
          "233:  mch_memmove(di->di_key, key, len + 1);",
          "234:  di->di_flags = DI_FLAGS_ALLOC;",
          "235:  di->di_tv.v_lock = 0;",
          "236:  di->di_tv.v_type = VAR_UNKNOWN;",
          "237:     }",
          "",
          "[Added Lines]",
          "231:     if (di == NULL)",
          "232:  return NULL;",
          "234:     mch_memmove(di->di_key, key, len + 1);",
          "235:     di->di_flags = DI_FLAGS_ALLOC;",
          "236:     di->di_tv.v_lock = 0;",
          "237:     di->di_tv.v_type = VAR_UNKNOWN;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "248:     size_t len = STRLEN(org->di_key);",
          "250:     di = alloc(offsetof(dictitem_T, di_key) + len + 1);",
          "257:     return di;",
          "258: }",
          "",
          "[Removed Lines]",
          "251:     if (di != NULL)",
          "252:     {",
          "253:  mch_memmove(di->di_key, org->di_key, len + 1);",
          "254:  di->di_flags = DI_FLAGS_ALLOC;",
          "255:  copy_tv(&org->di_tv, &di->di_tv);",
          "256:     }",
          "",
          "[Added Lines]",
          "251:     if (di == NULL)",
          "252:  return NULL;",
          "254:     mch_memmove(di->di_key, org->di_key, len + 1);",
          "255:     di->di_flags = DI_FLAGS_ALLOC;",
          "256:     copy_tv(&org->di_tv, &di->di_tv);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "303:  return NULL;",
          "305:     copy = dict_alloc();",
          "307:     {",
          "320:  {",
          "340:   {",
          "342:       break;",
          "343:   }",
          "344:      }",
          "345:  }",
          "353:     }",
          "355:     return copy;",
          "",
          "[Removed Lines]",
          "306:     if (copy != NULL)",
          "308:  if (copyID != 0)",
          "309:  {",
          "310:      orig->dv_copyID = copyID;",
          "311:      orig->dv_copydict = copy;",
          "312:  }",
          "313:  if (orig->dv_type == NULL || top || deep)",
          "314:      copy->dv_type = NULL;",
          "315:  else",
          "316:      copy->dv_type = alloc_type(orig->dv_type);",
          "318:  todo = (int)orig->dv_hashtab.ht_used;",
          "319:  for (hi = orig->dv_hashtab.ht_array; todo > 0 && !got_int; ++hi)",
          "321:      if (!HASHITEM_EMPTY(hi))",
          "322:      {",
          "323:   --todo;",
          "325:   di = dictitem_alloc(hi->hi_key);",
          "326:   if (di == NULL)",
          "327:       break;",
          "328:   if (deep)",
          "329:   {",
          "330:       if (item_copy(&HI2DI(hi)->di_tv, &di->di_tv,",
          "331:         deep, FALSE, copyID) == FAIL)",
          "332:       {",
          "333:    vim_free(di);",
          "334:    break;",
          "335:       }",
          "336:   }",
          "337:   else",
          "338:       copy_tv(&HI2DI(hi)->di_tv, &di->di_tv);",
          "339:   if (dict_add(copy, di) == FAIL)",
          "341:       dictitem_free(di);",
          "347:  ++copy->dv_refcount;",
          "348:  if (todo > 0)",
          "349:  {",
          "350:      dict_unref(copy);",
          "351:      copy = NULL;",
          "352:  }",
          "",
          "[Added Lines]",
          "306:     if (copy == NULL)",
          "307:  return NULL;",
          "309:     if (copyID != 0)",
          "311:  orig->dv_copyID = copyID;",
          "312:  orig->dv_copydict = copy;",
          "313:     }",
          "314:     if (orig->dv_type == NULL || top || deep)",
          "315:  copy->dv_type = NULL;",
          "316:     else",
          "317:  copy->dv_type = alloc_type(orig->dv_type);",
          "319:     todo = (int)orig->dv_hashtab.ht_used;",
          "320:     for (hi = orig->dv_hashtab.ht_array; todo > 0 && !got_int; ++hi)",
          "321:     {",
          "322:  if (!HASHITEM_EMPTY(hi))",
          "324:      --todo;",
          "326:      di = dictitem_alloc(hi->hi_key);",
          "327:      if (di == NULL)",
          "328:   break;",
          "329:      if (deep)",
          "330:      {",
          "331:   if (item_copy(&HI2DI(hi)->di_tv, &di->di_tv,",
          "332:        deep, FALSE, copyID) == FAIL)",
          "334:       vim_free(di);",
          "338:      else",
          "339:   copy_tv(&HI2DI(hi)->di_tv, &di->di_tv);",
          "340:      if (dict_add(copy, di) == FAIL)",
          "341:      {",
          "342:   dictitem_free(di);",
          "343:   break;",
          "344:      }",
          "346:     }",
          "348:     ++copy->dv_refcount;",
          "349:     if (todo > 0)",
          "350:     {",
          "351:  dict_unref(copy);",
          "352:  copy = NULL;",
          "",
          "---------------"
        ],
        "src/diff.c||src/diff.c": [
          "File: src/diff.c -> src/diff.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "559:     diff_T *dnew;",
          "561:     dnew = ALLOC_ONE(diff_T);",
          "570:     return dnew;",
          "571: }",
          "",
          "[Removed Lines]",
          "562:     if (dnew != NULL)",
          "563:     {",
          "564:  dnew->df_next = dp;",
          "565:  if (dprev == NULL)",
          "566:      tp->tp_first_diff = dnew;",
          "567:  else",
          "568:      dprev->df_next = dnew;",
          "569:     }",
          "",
          "[Added Lines]",
          "562:     if (dnew == NULL)",
          "563:  return NULL;",
          "565:     dnew->df_next = dp;",
          "566:     if (dprev == NULL)",
          "567:  tp->tp_first_diff = dnew;",
          "568:     else",
          "569:  dprev->df_next = dnew;",
          "",
          "---------------"
        ],
        "src/digraph.c||src/digraph.c": [
          "File: src/digraph.c -> src/digraph.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1533:     c = plain_vgetc();",
          "1534:     --no_mapping;",
          "1535:     --allow_keys;",
          "1537:     {",
          "1543: #if defined(FEAT_CRYPT) || defined(FEAT_EVAL)",
          "1545: #endif",
          "1558:     }",
          "1559:     return NUL;",
          "1560: }",
          "",
          "[Removed Lines]",
          "1536:     if (c != ESC)  // ESC cancels CTRL-K",
          "1538:  if (IS_SPECIAL(c)) // insert special key code",
          "1539:      return c;",
          "1540:  if (cmdline)",
          "1541:  {",
          "1542:      if (char2cells(c) == 1",
          "1544:       && cmdline_star == 0",
          "1546:       )",
          "1547:   putcmdline(c, TRUE);",
          "1548:  }",
          "1549:  else",
          "1550:      add_to_showcmd(c);",
          "1551:  ++no_mapping;",
          "1552:  ++allow_keys;",
          "1553:  cc = plain_vgetc();",
          "1554:  --no_mapping;",
          "1555:  --allow_keys;",
          "1556:  if (cc != ESC)     // ESC cancels CTRL-K",
          "1557:      return digraph_get(c, cc, TRUE);",
          "",
          "[Added Lines]",
          "1537:     if (c == ESC)  // ESC cancels CTRL-K",
          "1538:  return NUL;",
          "1540:     if (IS_SPECIAL(c)) // insert special key code",
          "1541:  return c;",
          "1542:     if (cmdline)",
          "1544:  if (char2cells(c) == 1",
          "1546:   && cmdline_star == 0",
          "1548:     )",
          "1549:      putcmdline(c, TRUE);",
          "1551:     else",
          "1552:  add_to_showcmd(c);",
          "1553:     ++no_mapping;",
          "1554:     ++allow_keys;",
          "1555:     cc = plain_vgetc();",
          "1556:     --no_mapping;",
          "1557:     --allow_keys;",
          "1558:     if (cc != ESC)     // ESC cancels CTRL-K",
          "1559:  return digraph_get(c, cc, TRUE);",
          "",
          "---------------"
        ],
        "src/edit.c||src/edit.c": [
          "File: src/edit.c -> src/edit.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "2970:     if (last_insert == NULL)",
          "2971:  return NULL;",
          "2972:     s = vim_strsave(last_insert + last_insert_skip);",
          "2979:     return s;",
          "2980: }",
          "",
          "[Removed Lines]",
          "2973:     if (s != NULL)",
          "2974:     {",
          "2975:  len = (int)STRLEN(s);",
          "2976:  if (len > 0 && s[len - 1] == ESC) // remove trailing ESC",
          "2977:      s[len - 1] = NUL;",
          "2978:     }",
          "",
          "[Added Lines]",
          "2973:     if (s == NULL)",
          "2974:  return NULL;",
          "2976:     len = (int)STRLEN(s);",
          "2977:     if (len > 0 && s[len - 1] == ESC) // remove trailing ESC",
          "2978:  s[len - 1] = NUL;",
          "",
          "---------------"
        ],
        "src/evalfunc.c||src/evalfunc.c": [
          "File: src/evalfunc.c -> src/evalfunc.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "2950: {",
          "2951:     argcheck_T *argchecks = global_functions[idx].f_argcheck;",
          "2969:     return OK;",
          "2970: }",
          "",
          "[Removed Lines]",
          "2953:     if (argchecks != NULL)",
          "2954:     {",
          "2955:  argcontext_T context;",
          "2957:  context.arg_count = argcount;",
          "2958:  context.arg_types = types;",
          "2959:  context.arg_cctx = cctx;",
          "2960:  for (int i = 0; i < argcount; ++i)",
          "2961:      if (argchecks[i] != NULL)",
          "2962:      {",
          "2963:   context.arg_idx = i;",
          "2964:   if (argchecks[i](types[i].type_curr, types[i].type_decl,",
          "2965:             &context) == FAIL)",
          "2966:       return FAIL;",
          "2967:      }",
          "2968:     }",
          "",
          "[Added Lines]",
          "2953:     if (argchecks == NULL)",
          "2954:  return OK;",
          "2956:     argcontext_T context;",
          "2958:     context.arg_count = argcount;",
          "2959:     context.arg_types = types;",
          "2960:     context.arg_cctx = cctx;",
          "2961:     for (int i = 0; i < argcount; ++i)",
          "2962:  if (argchecks[i] != NULL)",
          "2963:  {",
          "2964:      context.arg_idx = i;",
          "2965:      if (argchecks[i](types[i].type_curr, types[i].type_decl,",
          "2966:    &context) == FAIL)",
          "2967:   return FAIL;",
          "2968:  }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "3475: {",
          "3476:     win_T   *win = curwin;",
          "3479:     {",
          "3486:     }",
          "3487:     return win;",
          "3488: }",
          "",
          "[Removed Lines]",
          "3478:     if (argvars[idx].v_type != VAR_UNKNOWN)",
          "3480:  win = find_win_by_nr_or_id(&argvars[idx]);",
          "3481:  if (win == NULL)",
          "3482:  {",
          "3483:      emsg(_(e_invalid_window_number));",
          "3484:      return NULL;",
          "3485:  }",
          "",
          "[Added Lines]",
          "3478:     if (argvars[idx].v_type == VAR_UNKNOWN)",
          "3479:  return curwin;",
          "3481:     win = find_win_by_nr_or_id(&argvars[idx]);",
          "3482:     if (win == NULL)",
          "3484:  emsg(_(e_invalid_window_number));",
          "3485:  return NULL;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "8624:     char_u nbuf[NUMBUFLEN];",
          "8625:     int  mask;",
          "8628:     {",
          "8633:  {",
          "8653:      {",
          "8656:      }",
          "8663:  }",
          "8664:     }",
          "8665:     return dir;",
          "8666: }",
          "",
          "[Removed Lines]",
          "8627:     if (varp->v_type != VAR_UNKNOWN)",
          "8629:  flags = tv_get_string_buf_chk(varp, nbuf);",
          "8630:  if (flags == NULL)",
          "8631:      return 0;  // type error; errmsg already given",
          "8632:  while (*flags != NUL)",
          "8634:      switch (*flags)",
          "8635:      {",
          "8636:   case 'b': dir = BACKWARD; break;",
          "8637:   case 'w': p_ws = TRUE; break;",
          "8638:   case 'W': p_ws = FALSE; break;",
          "8639:   default:  mask = 0;",
          "8640:      if (flagsp != NULL)",
          "8641:         switch (*flags)",
          "8642:         {",
          "8643:      case 'c': mask = SP_START; break;",
          "8644:      case 'e': mask = SP_END; break;",
          "8645:      case 'm': mask = SP_RETCOUNT; break;",
          "8646:      case 'n': mask = SP_NOMOVE; break;",
          "8647:      case 'p': mask = SP_SUBPAT; break;",
          "8648:      case 'r': mask = SP_REPEAT; break;",
          "8649:      case 's': mask = SP_SETPCMARK; break;",
          "8650:      case 'z': mask = SP_COLUMN; break;",
          "8651:         }",
          "8652:      if (mask == 0)",
          "8654:          semsg(_(e_invalid_argument_str), flags);",
          "8655:          dir = 0;",
          "8657:      else",
          "8659:      }",
          "8660:      if (dir == 0)",
          "8661:   break;",
          "8662:      ++flags;",
          "",
          "[Added Lines]",
          "8627:     if (varp->v_type == VAR_UNKNOWN)",
          "8628:  return FORWARD;",
          "8630:     flags = tv_get_string_buf_chk(varp, nbuf);",
          "8631:     if (flags == NULL)",
          "8632:  return 0;  // type error; errmsg already given",
          "8633:     while (*flags != NUL)",
          "8635:  switch (*flags)",
          "8637:      case 'b': dir = BACKWARD; break;",
          "8638:      case 'w': p_ws = TRUE; break;",
          "8639:      case 'W': p_ws = FALSE; break;",
          "8640:      default:  mask = 0;",
          "8641:         if (flagsp != NULL)",
          "8642:      switch (*flags)",
          "8644:          case 'c': mask = SP_START; break;",
          "8645:          case 'e': mask = SP_END; break;",
          "8646:          case 'm': mask = SP_RETCOUNT; break;",
          "8647:          case 'n': mask = SP_NOMOVE; break;",
          "8648:          case 'p': mask = SP_SUBPAT; break;",
          "8649:          case 'r': mask = SP_REPEAT; break;",
          "8650:          case 's': mask = SP_SETPCMARK; break;",
          "8651:          case 'z': mask = SP_COLUMN; break;",
          "8653:         if (mask == 0)",
          "8654:         {",
          "8655:      semsg(_(e_invalid_argument_str), flags);",
          "8656:      dir = 0;",
          "8657:         }",
          "8658:         else",
          "8661:  if (dir == 0)",
          "8662:      break;",
          "8663:  ++flags;",
          "",
          "---------------"
        ],
        "src/evalwindow.c||src/evalwindow.c": [
          "File: src/evalwindow.c -> src/evalwindow.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "24:     if (argvars[0].v_type == VAR_UNKNOWN)",
          "25:  return curwin->w_id;",
          "26:     winnr = tv_get_number(&argvars[0]);",
          "28:     {",
          "30:      wp = firstwin;",
          "31:  else",
          "49:     }",
          "50:     return 0;",
          "51: }",
          "",
          "[Removed Lines]",
          "27:     if (winnr > 0)",
          "29:  if (argvars[1].v_type == VAR_UNKNOWN)",
          "32:  {",
          "33:      tabpage_T *tp;",
          "34:      int  tabnr = tv_get_number(&argvars[1]);",
          "36:      FOR_ALL_TABPAGES(tp)",
          "37:   if (--tabnr == 0)",
          "38:       break;",
          "39:      if (tp == NULL)",
          "40:   return -1;",
          "41:      if (tp == curtab)",
          "42:   wp = firstwin;",
          "43:      else",
          "44:   wp = tp->tp_firstwin;",
          "45:  }",
          "46:  for ( ; wp != NULL; wp = wp->w_next)",
          "47:      if (--winnr == 0)",
          "48:   return wp->w_id;",
          "",
          "[Added Lines]",
          "27:     if (winnr <= 0)",
          "28:  return 0;",
          "30:     if (argvars[1].v_type == VAR_UNKNOWN)",
          "31:  wp = firstwin;",
          "32:     else",
          "34:  tabpage_T *tp;",
          "35:  int  tabnr = tv_get_number(&argvars[1]);",
          "37:  FOR_ALL_TABPAGES(tp)",
          "38:      if (--tabnr == 0)",
          "39:   break;",
          "40:  if (tp == NULL)",
          "41:      return -1;",
          "42:  if (tp == curtab)",
          "45:      wp = tp->tp_firstwin;",
          "47:     for ( ; wp != NULL; wp = wp->w_next)",
          "48:  if (--winnr == 0)",
          "49:      return wp->w_id;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "380:  }",
          "381:     }",
          "386:  {",
          "394:  }",
          "395:     return nr;",
          "396: }",
          "",
          "[Removed Lines]",
          "383:     if (nr > 0)",
          "384:  for (wp = (tp == curtab) ? firstwin : tp->tp_firstwin;",
          "385:            wp != twin; wp = wp->w_next)",
          "387:      if (wp == NULL)",
          "388:      {",
          "390:   nr = 0;",
          "391:   break;",
          "392:      }",
          "393:      ++nr;",
          "",
          "[Added Lines]",
          "383:     if (nr <= 0)",
          "384:  return 0;",
          "386:     for (wp = (tp == curtab) ? firstwin : tp->tp_firstwin;",
          "387:      wp != twin; wp = wp->w_next)",
          "388:     {",
          "389:  if (wp == NULL)",
          "392:      nr = 0;",
          "393:      break;",
          "395:  ++nr;",
          "396:     }",
          "",
          "---------------"
        ],
        "src/ex_cmds.c||src/ex_cmds.c": [
          "File: src/ex_cmds.c -> src/ex_cmds.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "5279:     need_mouse_correct = TRUE;",
          "5280: # endif",
          "5287: # ifdef FEAT_PROP_POPUP",
          "5295:  {",
          "5307:  }",
          "5309: # endif",
          "5322: # ifdef FEAT_PROP_POPUP",
          "5326: # endif",
          "5333: # ifdef FEAT_DIFF",
          "5335: # endif",
          "5336: # ifdef FEAT_FOLDING",
          "5338: # endif",
          "5343: }",
          "5345: #endif",
          "",
          "[Removed Lines]",
          "5285:     if (!curwin->w_p_pvw)",
          "5286:     {",
          "5288:  if (use_previewpopup && *p_pvp != NUL)",
          "5289:  {",
          "5290:      wp = popup_find_preview_window();",
          "5291:      if (wp != NULL)",
          "5292:   popup_set_wantpos_cursor(wp, wp->w_minwidth, NULL);",
          "5293:  }",
          "5294:  else if (use_popup != USEPOPUP_NONE)",
          "5296:      wp = popup_find_info_window();",
          "5297:      if (wp != NULL)",
          "5298:      {",
          "5299:   if (use_popup == USEPOPUP_NORMAL)",
          "5300:       popup_show(wp);",
          "5301:   else",
          "5302:       popup_hide(wp);",
          "5305:   redraw_all_later(UPD_NOT_VALID);",
          "5306:      }",
          "5308:  else",
          "5310:  {",
          "5311:      FOR_ALL_WINDOWS(wp)",
          "5312:   if (wp->w_p_pvw)",
          "5313:       break;",
          "5314:  }",
          "5315:  if (wp != NULL)",
          "5316:      win_enter(wp, undo_sync);",
          "5317:  else",
          "5318:  {",
          "5323:      if ((use_previewpopup && *p_pvp != NUL)",
          "5324:        || use_popup != USEPOPUP_NONE)",
          "5325:   return popup_create_preview_window(use_popup != USEPOPUP_NONE);",
          "5327:      if (win_split(g_do_tagpreview > 0 ? g_do_tagpreview : 0, 0) == FAIL)",
          "5328:   return FALSE;",
          "5329:      curwin->w_p_pvw = TRUE;",
          "5330:      curwin->w_p_wfh = TRUE;",
          "5331:      RESET_BINDING(curwin);     // don't take over 'scrollbind'",
          "5334:      curwin->w_p_diff = FALSE;     // no 'diff'",
          "5337:      curwin->w_p_fdc = 0;     // no 'foldcolumn'",
          "5339:      return TRUE;",
          "5340:  }",
          "5341:     }",
          "5342:     return FALSE;",
          "",
          "[Added Lines]",
          "5282:     if (curwin->w_p_pvw)",
          "5283:  return FALSE;",
          "5289:     if (use_previewpopup && *p_pvp != NUL)",
          "5290:     {",
          "5291:  wp = popup_find_preview_window();",
          "5292:  if (wp != NULL)",
          "5293:      popup_set_wantpos_cursor(wp, wp->w_minwidth, NULL);",
          "5294:     }",
          "5295:     else if (use_popup != USEPOPUP_NONE)",
          "5296:     {",
          "5297:  wp = popup_find_info_window();",
          "5298:  if (wp != NULL)",
          "5300:      if (use_popup == USEPOPUP_NORMAL)",
          "5301:   popup_show(wp);",
          "5302:      else",
          "5303:   popup_hide(wp);",
          "5306:      redraw_all_later(UPD_NOT_VALID);",
          "5308:     }",
          "5309:     else",
          "5311:     {",
          "5312:  FOR_ALL_WINDOWS(wp)",
          "5313:      if (wp->w_p_pvw)",
          "5314:   break;",
          "5315:     }",
          "5316:     if (wp != NULL)",
          "5317:     {",
          "5318:  win_enter(wp, undo_sync);",
          "5319:  return FALSE;",
          "5320:     }",
          "5326:     if ((use_previewpopup && *p_pvp != NUL)",
          "5327:      || use_popup != USEPOPUP_NONE)",
          "5328:  return popup_create_preview_window(use_popup != USEPOPUP_NONE);",
          "5330:     if (win_split(g_do_tagpreview > 0 ? g_do_tagpreview : 0, 0) == FAIL)",
          "5331:  return FALSE;",
          "5332:     curwin->w_p_pvw = TRUE;",
          "5333:     curwin->w_p_wfh = TRUE;",
          "5334:     RESET_BINDING(curwin);     // don't take over 'scrollbind'",
          "5337:     curwin->w_p_diff = FALSE;     // no 'diff'",
          "5340:     curwin->w_p_fdc = 0;     // no 'foldcolumn'",
          "5342:     return TRUE;",
          "",
          "---------------"
        ],
        "src/ex_cmds2.c||src/ex_cmds2.c": [
          "File: src/ex_cmds2.c -> src/ex_cmds2.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "828:  lines = 5;",
          "830:     file = mch_fopen((char *)filename, \"r\");",
          "832:     {",
          "834:  {",
          "853:      {",
          "854:   requires_py_version = 2;",
          "855:   break;",
          "856:      }",
          "858:      {",
          "859:   requires_py_version = 3;",
          "860:   break;",
          "861:      }",
          "862:  }",
          "864:     }",
          "865:     return requires_py_version;",
          "866: }",
          "",
          "[Removed Lines]",
          "831:     if (file != NULL)",
          "833:  for (i = 0; i < lines; i++)",
          "835:      if (vim_fgets(IObuff, IOSIZE, file))",
          "836:   break;",
          "837:      if (i == 0 && IObuff[0] == '#' && IObuff[1] == '!')",
          "838:      {",
          "840:   if (strstr((char *)IObuff + 2, \"python2\") != NULL)",
          "841:   {",
          "842:       requires_py_version = 2;",
          "843:       break;",
          "844:   }",
          "845:   if (strstr((char *)IObuff + 2, \"python3\") != NULL)",
          "846:   {",
          "847:       requires_py_version = 3;",
          "848:       break;",
          "849:   }",
          "850:      }",
          "851:      IObuff[21] = '\\0';",
          "852:      if (STRCMP(\"# requires python 2.x\", IObuff) == 0)",
          "857:      if (STRCMP(\"# requires python 3.x\", IObuff) == 0)",
          "863:  fclose(file);",
          "",
          "[Added Lines]",
          "831:     if (file == NULL)",
          "832:  return 0;",
          "834:     for (i = 0; i < lines; i++)",
          "836:  if (vim_fgets(IObuff, IOSIZE, file))",
          "837:      break;",
          "838:  if (i == 0 && IObuff[0] == '#' && IObuff[1] == '!')",
          "841:      if (strstr((char *)IObuff + 2, \"python2\") != NULL)",
          "846:      if (strstr((char *)IObuff + 2, \"python3\") != NULL)",
          "852:  IObuff[21] = '\\0';",
          "853:  if (STRCMP(\"# requires python 2.x\", IObuff) == 0)",
          "854:  {",
          "855:      requires_py_version = 2;",
          "856:      break;",
          "857:  }",
          "858:  if (STRCMP(\"# requires python 3.x\", IObuff) == 0)",
          "859:  {",
          "860:      requires_py_version = 3;",
          "861:      break;",
          "862:  }",
          "864:     fclose(file);",
          "",
          "---------------"
        ],
        "src/ex_getln.c||src/ex_getln.c": [
          "File: src/ex_getln.c -> src/ex_getln.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "4146:  return NULL;",
          "4148:     p = get_ccline_ptr();",
          "4160:     return NULL;",
          "4161: }",
          "",
          "[Removed Lines]",
          "4149:     if (p != NULL && p->xpc != NULL)",
          "4150:     {",
          "4151:  char_u *cmd_compl;",
          "4153:  set_expand_context(p->xpc);",
          "4155:  cmd_compl = cmdcomplete_type_to_str(p->xpc->xp_context);",
          "4156:  if (cmd_compl != NULL)",
          "4157:      return vim_strsave(cmd_compl);",
          "4158:     }",
          "",
          "[Added Lines]",
          "4149:     if (p == NULL || p->xpc == NULL)",
          "4150:  return NULL;",
          "4152:     char_u *cmd_compl;",
          "4154:     set_expand_context(p->xpc);",
          "4156:     cmd_compl = cmdcomplete_type_to_str(p->xpc->xp_context);",
          "4157:     if (cmd_compl != NULL)",
          "4158:  return vim_strsave(cmd_compl);",
          "",
          "---------------"
        ],
        "src/filepath.c||src/filepath.c": [
          "File: src/filepath.c -> src/filepath.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "3084:     char_u  *dest;",
          "3086:     dest = alloc(STRLEN(fname1) + STRLEN(fname2) + 3);",
          "3094:     return dest;",
          "3095: }",
          "",
          "[Removed Lines]",
          "3087:     if (dest != NULL)",
          "3088:     {",
          "3089:  STRCPY(dest, fname1);",
          "3090:  if (sep)",
          "3091:      add_pathsep(dest);",
          "3092:  STRCAT(dest, fname2);",
          "3093:     }",
          "",
          "[Added Lines]",
          "3087:     if (dest == NULL)",
          "3088:  return NULL;",
          "3090:     STRCPY(dest, fname1);",
          "3091:     if (sep)",
          "3092:  add_pathsep(dest);",
          "3093:     STRCAT(dest, fname2);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "3122:  return NULL;",
          "3124:     buf = alloc(MAXPATHL);",
          "3133:     return new_fname;",
          "3134: }",
          "",
          "[Removed Lines]",
          "3125:     if (buf != NULL)",
          "3126:     {",
          "3127:  if (vim_FullName(fname, buf, MAXPATHL, force) != FAIL)",
          "3128:      new_fname = vim_strsave(buf);",
          "3129:  else",
          "3130:      new_fname = vim_strsave(fname);",
          "3131:  vim_free(buf);",
          "3132:     }",
          "",
          "[Added Lines]",
          "3125:     if (buf == NULL)",
          "3126:  return NULL;",
          "3128:     if (vim_FullName(fname, buf, MAXPATHL, force) != FAIL)",
          "3129:  new_fname = vim_strsave(buf);",
          "3130:     else",
          "3131:  new_fname = vim_strsave(fname);",
          "3132:     vim_free(buf);",
          "",
          "---------------"
        ],
        "src/findfile.c||src/findfile.c": [
          "File: src/findfile.c -> src/findfile.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1347:     vp = alloc(sizeof(ff_visited_T) + STRLEN(ff_expand_buffer));",
          "1351: #ifdef UNIX",
          "1362: #endif",
          "1364: #ifdef UNIX",
          "1366: #endif",
          "1376:     return OK;",
          "1377: }",
          "",
          "[Removed Lines]",
          "1349:     if (vp != NULL)",
          "1350:     {",
          "1352:  if (!url)",
          "1353:  {",
          "1354:      vp->ffv_dev_valid = TRUE;",
          "1355:      vp->ffv_ino = st.st_ino;",
          "1356:      vp->ffv_dev = st.st_dev;",
          "1357:      vp->ffv_fname[0] = NUL;",
          "1358:  }",
          "1359:  else",
          "1360:  {",
          "1361:      vp->ffv_dev_valid = FALSE;",
          "1363:      STRCPY(vp->ffv_fname, ff_expand_buffer);",
          "1365:  }",
          "1367:  if (wc_path != NULL)",
          "1368:      vp->ffv_wc_path = vim_strsave(wc_path);",
          "1369:  else",
          "1370:      vp->ffv_wc_path = NULL;",
          "1372:  vp->ffv_next = *visited_list;",
          "1374:     }",
          "",
          "[Added Lines]",
          "1348:     if (vp == NULL)",
          "1349:  return OK;",
          "1352:     if (!url)",
          "1353:     {",
          "1354:  vp->ffv_dev_valid = TRUE;",
          "1355:  vp->ffv_ino = st.st_ino;",
          "1356:  vp->ffv_dev = st.st_dev;",
          "1357:  vp->ffv_fname[0] = NUL;",
          "1358:     }",
          "1359:     else",
          "1360:     {",
          "1361:  vp->ffv_dev_valid = FALSE;",
          "1363:  STRCPY(vp->ffv_fname, ff_expand_buffer);",
          "1365:     }",
          "1367:     if (wc_path != NULL)",
          "1368:  vp->ffv_wc_path = vim_strsave(wc_path);",
          "1369:     else",
          "1370:  vp->ffv_wc_path = NULL;",
          "1372:     vp->ffv_next = *visited_list;",
          "",
          "---------------"
        ],
        "src/fold.c||src/fold.c": [
          "File: src/fold.c -> src/fold.c"
        ],
        "src/hardcopy.c||src/hardcopy.c": [
          "File: src/hardcopy.c -> src/hardcopy.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "334:     static void",
          "335: prt_set_fg(long_u fg)",
          "336: {",
          "342: }",
          "344:     static void",
          "345: prt_set_bg(long_u bg)",
          "346: {",
          "352: }",
          "354:     static void",
          "355: prt_set_font(int bold, int italic, int underline)",
          "356: {",
          "366: }",
          "",
          "[Removed Lines]",
          "337:     if (fg != curr_fg)",
          "338:     {",
          "339:  curr_fg = fg;",
          "340:  mch_print_set_fg(fg);",
          "341:     }",
          "347:     if (bg != curr_bg)",
          "348:     {",
          "349:  curr_bg = bg;",
          "350:  mch_print_set_bg(bg);",
          "351:     }",
          "357:     if (curr_bold != bold",
          "358:      || curr_italic != italic",
          "359:      || curr_underline != underline)",
          "360:     {",
          "361:  curr_underline = underline;",
          "362:  curr_italic = italic;",
          "363:  curr_bold = bold;",
          "364:  mch_print_set_font(bold, italic, underline);",
          "365:     }",
          "",
          "[Added Lines]",
          "337:     if (fg == curr_fg)",
          "338:  return;",
          "340:     curr_fg = fg;",
          "341:     mch_print_set_fg(fg);",
          "347:     if (bg == curr_bg)",
          "348:  return;",
          "350:     curr_bg = bg;",
          "351:     mch_print_set_bg(bg);",
          "357:     if (curr_bold == bold",
          "358:      && curr_italic == italic",
          "359:      && curr_underline == underline)",
          "360:  return;",
          "362:     curr_underline = underline;",
          "363:     curr_italic = italic;",
          "364:     curr_bold = bold;",
          "365:     mch_print_set_font(bold, italic, underline);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "434:     int  i;",
          "435:     static char *(units[4]) = PRT_UNIT_NAMES;",
          "444:     return u;",
          "445: }",
          "",
          "[Removed Lines]",
          "437:     if (printer_opts[idx].present)",
          "438:  for (i = 0; i < 4; ++i)",
          "439:      if (STRNICMP(printer_opts[idx].string, units[i], 2) == 0)",
          "440:      {",
          "441:   u = i;",
          "442:   break;",
          "443:      }",
          "",
          "[Added Lines]",
          "437:     if (!printer_opts[idx].present)",
          "438:  return PRT_UNIT_NONE;",
          "440:     for (i = 0; i < 4; ++i)",
          "441:  if (STRNICMP(printer_opts[idx].string, units[i], 2) == 0)",
          "442:  {",
          "443:      u = i;",
          "444:      break;",
          "445:  }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1574:     static void",
          "1575: prt_flush_buffer(void)",
          "1576: {",
          "1608:  {",
          "1620:  }",
          "1632:  if (prt_do_moveto)",
          "1633:  {",
          "1634:      prt_write_real(prt_pos_x_moveto, 2);",
          "1635:      prt_write_real(prt_pos_y_moveto, 2);",
          "1638:      prt_do_moveto = FALSE;",
          "1639:  }",
          "1645:     }",
          "1646: }",
          "",
          "[Removed Lines]",
          "1577:     if (prt_ps_buffer.ga_len > 0)",
          "1578:     {",
          "1580:  if (prt_do_bgcol && (prt_new_bgcol != PRCOLOR_WHITE))",
          "1581:  {",
          "1582:      int     r, g, b;",
          "1584:      if (prt_do_moveto)",
          "1585:      {",
          "1586:   prt_write_real(prt_pos_x_moveto, 2);",
          "1587:   prt_write_real(prt_pos_y_moveto, 2);",
          "1588:   prt_write_string(\"m\\n\");",
          "1589:   prt_do_moveto = FALSE;",
          "1590:      }",
          "1593:      prt_write_real(prt_text_run, 2);",
          "1594:      prt_write_real(prt_line_height, 2);",
          "1597:      r = ((unsigned)prt_new_bgcol & 0xff0000) >> 16;",
          "1598:      g = ((unsigned)prt_new_bgcol & 0xff00) >> 8;",
          "1599:      b = prt_new_bgcol & 0xff;",
          "1600:      prt_write_real(r / 255.0, 3);",
          "1601:      prt_write_real(g / 255.0, 3);",
          "1602:      prt_write_real(b / 255.0, 3);",
          "1603:      prt_write_string(\"bg\\n\");",
          "1604:  }",
          "1607:  if (prt_do_underline)",
          "1609:      if (prt_do_moveto)",
          "1610:      {",
          "1611:   prt_write_real(prt_pos_x_moveto, 2);",
          "1612:   prt_write_real(prt_pos_y_moveto, 2);",
          "1613:   prt_write_string(\"m\\n\");",
          "1614:   prt_do_moveto = FALSE;",
          "1615:      }",
          "1618:      prt_write_real(prt_text_run, 2);",
          "1619:      prt_write_string(\"ul\\n\");",
          "1622:  if (prt_out_mbyte)",
          "1623:      prt_write_string(\"<\");",
          "1624:  else",
          "1625:      prt_write_string(\"(\");",
          "1626:  prt_write_file_raw_len(prt_ps_buffer.ga_data, prt_ps_buffer.ga_len);",
          "1627:  if (prt_out_mbyte)",
          "1628:      prt_write_string(\">\");",
          "1629:  else",
          "1630:      prt_write_string(\")\");",
          "1637:      prt_write_string(\"ms\\n\");",
          "1640:  else // Simple show",
          "1641:      prt_write_string(\"s\\n\");",
          "1643:  ga_clear(&prt_ps_buffer);",
          "1644:  ga_init2(&prt_ps_buffer, sizeof(char), prt_bufsiz);",
          "",
          "[Added Lines]",
          "1579:     if (prt_ps_buffer.ga_len <= 0)",
          "1580:  return;",
          "1583:     if (prt_do_bgcol && (prt_new_bgcol != PRCOLOR_WHITE))",
          "1584:     {",
          "1585:  int     r, g, b;",
          "1587:  if (prt_do_moveto)",
          "1589:      prt_write_real(prt_pos_x_moveto, 2);",
          "1590:      prt_write_real(prt_pos_y_moveto, 2);",
          "1591:      prt_write_string(\"m\\n\");",
          "1592:      prt_do_moveto = FALSE;",
          "1596:  prt_write_real(prt_text_run, 2);",
          "1597:  prt_write_real(prt_line_height, 2);",
          "1600:  r = ((unsigned)prt_new_bgcol & 0xff0000) >> 16;",
          "1601:  g = ((unsigned)prt_new_bgcol & 0xff00) >> 8;",
          "1602:  b = prt_new_bgcol & 0xff;",
          "1603:  prt_write_real(r / 255.0, 3);",
          "1604:  prt_write_real(g / 255.0, 3);",
          "1605:  prt_write_real(b / 255.0, 3);",
          "1606:  prt_write_string(\"bg\\n\");",
          "1607:     }",
          "1610:     if (prt_do_underline)",
          "1611:     {",
          "1616:      prt_write_string(\"m\\n\");",
          "1621:  prt_write_real(prt_text_run, 2);",
          "1622:  prt_write_string(\"ul\\n\");",
          "1625:     if (prt_out_mbyte)",
          "1626:  prt_write_string(\"<\");",
          "1627:     else",
          "1628:  prt_write_string(\"(\");",
          "1629:     prt_write_file_raw_len(prt_ps_buffer.ga_data, prt_ps_buffer.ga_len);",
          "1630:     if (prt_out_mbyte)",
          "1631:  prt_write_string(\">\");",
          "1632:     else",
          "1633:  prt_write_string(\")\");",
          "1635:     if (prt_do_moveto)",
          "1636:     {",
          "1637:  prt_write_real(prt_pos_x_moveto, 2);",
          "1638:  prt_write_real(prt_pos_y_moveto, 2);",
          "1640:  prt_write_string(\"ms\\n\");",
          "1641:  prt_do_moveto = FALSE;",
          "1642:     }",
          "1643:     else // Simple show",
          "1644:  prt_write_string(\"s\\n\");",
          "1646:     ga_clear(&prt_ps_buffer);",
          "1647:     ga_init2(&prt_ps_buffer, sizeof(char), prt_bufsiz);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "3447:     void",
          "3448: mch_print_set_fg(long_u fgcol)",
          "3449: {",
          "3456: }",
          "3458: # endif //FEAT_POSTSCRIPT",
          "",
          "[Removed Lines]",
          "3450:     if (fgcol != (long_u)prt_fgcol)",
          "3451:     {",
          "3452:  prt_fgcol = (int)fgcol;",
          "3453:  prt_attribute_change = TRUE;",
          "3454:  prt_need_fgcol = TRUE;",
          "3455:     }",
          "",
          "[Added Lines]",
          "3452:     if (fgcol == (long_u)prt_fgcol)",
          "3453:  return;",
          "3455:     prt_fgcol = (int)fgcol;",
          "3456:     prt_attribute_change = TRUE;",
          "3457:     prt_need_fgcol = TRUE;",
          "",
          "---------------"
        ],
        "src/highlight.c||src/highlight.c": [
          "File: src/highlight.c -> src/highlight.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "920: }",
          "921: #endif",
          "927:     static void",
          "928: highlight_set_ctermfg(int idx, int color, int is_normal_group)",
          "929: {",
          "930:     HL_TABLE()[idx].sg_cterm_fg = color + 1;",
          "931:     if (is_normal_group)",
          "935: #ifdef FEAT_GUI",
          "938: #endif",
          "943:  }",
          "944:     }",
          "945: }",
          "951:     static void",
          "952: highlight_set_ctermbg(int idx, int color, int is_normal_group)",
          "953: {",
          "954:     HL_TABLE()[idx].sg_cterm_bg = color + 1;",
          "955:     if (is_normal_group)",
          "958: #ifdef FEAT_GUI",
          "961: #endif",
          "987:     }",
          "988: }",
          "994:     static void",
          "995: highlight_set_ctermul(int idx, int color, int is_normal_group)",
          "996: {",
          "997:     HL_TABLE()[idx].sg_cterm_ul = color + 1;",
          "998:     if (is_normal_group)",
          "1011: }",
          "",
          "[Removed Lines]",
          "932:     {",
          "933:  cterm_normal_fg_color = color + 1;",
          "934:  cterm_normal_fg_bold = (HL_TABLE()[idx].sg_cterm & HL_BOLD);",
          "937:  if (!gui.in_use && !gui.starting)",
          "939:  {",
          "940:      set_must_redraw(UPD_CLEAR);",
          "941:      if (termcap_active && color >= 0)",
          "942:   term_fg_color(color);",
          "956:     {",
          "957:  cterm_normal_bg_color = color + 1;",
          "960:  if (!gui.in_use && !gui.starting)",
          "962:  {",
          "963:      set_must_redraw(UPD_CLEAR);",
          "964:      if (color >= 0)",
          "965:      {",
          "966:   int dark = -1;",
          "968:   if (termcap_active)",
          "969:       term_bg_color(color);",
          "970:   if (t_colors < 16)",
          "971:       dark = (color == 0 || color == 4);",
          "973:   else if (color < 16)",
          "974:       dark = (color < 7 || color == 8);",
          "977:   if (dark != -1",
          "978:    && dark != (*p_bg == 'd')",
          "979:    && !option_was_set((char_u *)\"bg\"))",
          "980:   {",
          "981:       set_option_value_give_err((char_u *)\"bg\",",
          "982:        0L, (char_u *)(dark ? \"dark\" : \"light\"), 0);",
          "983:       reset_option_was_set((char_u *)\"bg\");",
          "984:   }",
          "985:      }",
          "986:  }",
          "999:     {",
          "1000:  cterm_normal_ul_color = color + 1;",
          "1001: #ifdef FEAT_GUI",
          "1003:  if (!gui.in_use && !gui.starting)",
          "1004: #endif",
          "1005:  {",
          "1006:      set_must_redraw(UPD_CLEAR);",
          "1007:      if (termcap_active && color >= 0)",
          "1008:   term_ul_color(color);",
          "1009:  }",
          "1010:     }",
          "",
          "[Added Lines]",
          "927:     static void",
          "928: hl_set_ctermfg_normal_group(int color, int bold)",
          "929: {",
          "930:     cterm_normal_fg_color = color + 1;",
          "931:     cterm_normal_fg_bold = bold;",
          "932: #ifdef FEAT_GUI",
          "934:     if (!gui.in_use && !gui.starting)",
          "935: #endif",
          "936:     {",
          "937:  set_must_redraw(UPD_CLEAR);",
          "938:  if (termcap_active && color >= 0)",
          "939:      term_fg_color(color);",
          "940:     }",
          "941: }",
          "951:  hl_set_ctermfg_normal_group(color,",
          "952:      (HL_TABLE()[idx].sg_cterm & HL_BOLD));",
          "953: }",
          "958:     static void",
          "959: hl_set_ctermbg_normal_group(int color)",
          "960: {",
          "961:     cterm_normal_bg_color = color + 1;",
          "964:     if (!gui.in_use && !gui.starting)",
          "966:     {",
          "967:  set_must_redraw(UPD_CLEAR);",
          "968:  if (color >= 0)",
          "969:  {",
          "970:      int dark = -1;",
          "972:      if (termcap_active)",
          "973:   term_bg_color(color);",
          "974:      if (t_colors < 16)",
          "975:   dark = (color == 0 || color == 4);",
          "977:      else if (color < 16)",
          "978:   dark = (color < 7 || color == 8);",
          "981:      if (dark != -1",
          "982:       && dark != (*p_bg == 'd')",
          "983:       && !option_was_set((char_u *)\"bg\"))",
          "984:      {",
          "985:   set_option_value_give_err((char_u *)\"bg\",",
          "986:    0L, (char_u *)(dark ? \"dark\" : \"light\"), 0);",
          "987:   reset_option_was_set((char_u *)\"bg\");",
          "988:      }",
          "1001:  hl_set_ctermbg_normal_group(color);",
          "1002: }",
          "1007:     static void",
          "1008: hl_set_ctermul_normal_group(int color)",
          "1009: {",
          "1010:     cterm_normal_ul_color = color + 1;",
          "1013:     if (!gui.in_use && !gui.starting)",
          "1015:     {",
          "1016:  set_must_redraw(UPD_CLEAR);",
          "1017:  if (termcap_active && color >= 0)",
          "1018:      term_ul_color(color);",
          "1030:  hl_set_ctermul_normal_group(color);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1034:     long i;",
          "1035:     int  off;",
          "1038:     {",
          "1045:  {",
          "1048:  }",
          "1053:  {",
          "1061:  }",
          "1063:  {",
          "1071:  }",
          "1073:  {",
          "1081:  }",
          "1109:  }",
          "1119:     }",
          "1121:     return TRUE;",
          "1122: }",
          "",
          "[Removed Lines]",
          "1037:     if (!init || !(HL_TABLE()[idx].sg_set & SG_CTERM))",
          "1039:  if (!init)",
          "1040:      HL_TABLE()[idx].sg_set |= SG_CTERM;",
          "1044:  if (key[5] == 'F' && HL_TABLE()[idx].sg_cterm_bold)",
          "1046:      HL_TABLE()[idx].sg_cterm &= ~HL_BOLD;",
          "1047:      HL_TABLE()[idx].sg_cterm_bold = FALSE;",
          "1050:  if (VIM_ISDIGIT(*arg))",
          "1051:      color = atoi((char *)arg);",
          "1052:  else if (STRICMP(arg, \"fg\") == 0)",
          "1054:      if (cterm_normal_fg_color)",
          "1055:   color = cterm_normal_fg_color - 1;",
          "1056:      else",
          "1057:      {",
          "1058:   emsg(_(e_fg_color_unknown));",
          "1059:   return FALSE;",
          "1060:      }",
          "1062:  else if (STRICMP(arg, \"bg\") == 0)",
          "1064:      if (cterm_normal_bg_color > 0)",
          "1065:   color = cterm_normal_bg_color - 1;",
          "1066:      else",
          "1067:      {",
          "1068:   emsg(_(e_bg_color_unknown));",
          "1069:   return FALSE;",
          "1070:      }",
          "1072:  else if (STRICMP(arg, \"ul\") == 0)",
          "1074:      if (cterm_normal_ul_color > 0)",
          "1075:   color = cterm_normal_ul_color - 1;",
          "1076:      else",
          "1077:      {",
          "1078:   emsg(_(e_ul_color_unknown));",
          "1079:   return FALSE;",
          "1080:      }",
          "1082:  else",
          "1083:  {",
          "1084:      int bold = MAYBE;",
          "1087:      off = TOUPPER_ASC(*arg);",
          "1088:      for (i = ARRAY_LENGTH(color_names); --i >= 0; )",
          "1089:   if (off == color_names[i][0]",
          "1090:    && STRICMP(arg + 1, color_names[i] + 1) == 0)",
          "1091:       break;",
          "1092:      if (i < 0)",
          "1093:      {",
          "1094:   semsg(_(e_color_name_or_number_not_recognized_str), key_start);",
          "1095:   return FALSE;",
          "1096:      }",
          "1098:      color = lookup_color(i, key[5] == 'F', &bold);",
          "1102:      if (bold == TRUE)",
          "1103:      {",
          "1104:   HL_TABLE()[idx].sg_cterm |= HL_BOLD;",
          "1105:   HL_TABLE()[idx].sg_cterm_bold = TRUE;",
          "1106:      }",
          "1107:      else if (bold == FALSE)",
          "1108:   HL_TABLE()[idx].sg_cterm &= ~HL_BOLD;",
          "1113:  if (key[5] == 'F')",
          "1114:      highlight_set_ctermfg(idx, color, is_normal_group);",
          "1115:  else if (key[5] == 'B')",
          "1116:      highlight_set_ctermbg(idx, color, is_normal_group);",
          "1117:  else // ctermul",
          "1118:      highlight_set_ctermul(idx, color, is_normal_group);",
          "",
          "[Added Lines]",
          "1057:     if (init && (HL_TABLE()[idx].sg_set & SG_CTERM))",
          "1058:  return FALSE;",
          "1060:     if (!init)",
          "1061:  HL_TABLE()[idx].sg_set |= SG_CTERM;",
          "1065:     if (key[5] == 'F' && HL_TABLE()[idx].sg_cterm_bold)",
          "1067:  HL_TABLE()[idx].sg_cterm &= ~HL_BOLD;",
          "1068:  HL_TABLE()[idx].sg_cterm_bold = FALSE;",
          "1069:     }",
          "1071:     if (VIM_ISDIGIT(*arg))",
          "1072:  color = atoi((char *)arg);",
          "1073:     else if (STRICMP(arg, \"fg\") == 0)",
          "1074:     {",
          "1075:  if (cterm_normal_fg_color)",
          "1076:      color = cterm_normal_fg_color - 1;",
          "1077:  else",
          "1079:      emsg(_(e_fg_color_unknown));",
          "1080:      return FALSE;",
          "1082:     }",
          "1083:     else if (STRICMP(arg, \"bg\") == 0)",
          "1084:     {",
          "1085:  if (cterm_normal_bg_color > 0)",
          "1086:      color = cterm_normal_bg_color - 1;",
          "1087:  else",
          "1089:      emsg(_(e_bg_color_unknown));",
          "1090:      return FALSE;",
          "1092:     }",
          "1093:     else if (STRICMP(arg, \"ul\") == 0)",
          "1094:     {",
          "1095:  if (cterm_normal_ul_color > 0)",
          "1096:      color = cterm_normal_ul_color - 1;",
          "1097:  else",
          "1099:      emsg(_(e_ul_color_unknown));",
          "1100:      return FALSE;",
          "1102:     }",
          "1103:     else",
          "1104:     {",
          "1105:  int bold = MAYBE;",
          "1108:  off = TOUPPER_ASC(*arg);",
          "1109:  for (i = ARRAY_LENGTH(color_names); --i >= 0; )",
          "1110:      if (off == color_names[i][0]",
          "1111:       && STRICMP(arg + 1, color_names[i] + 1) == 0)",
          "1112:   break;",
          "1113:  if (i < 0)",
          "1115:      semsg(_(e_color_name_or_number_not_recognized_str), key_start);",
          "1116:      return FALSE;",
          "1119:  color = lookup_color(i, key[5] == 'F', &bold);",
          "1123:  if (bold == TRUE)",
          "1124:  {",
          "1125:      HL_TABLE()[idx].sg_cterm |= HL_BOLD;",
          "1126:      HL_TABLE()[idx].sg_cterm_bold = TRUE;",
          "1128:  else if (bold == FALSE)",
          "1129:      HL_TABLE()[idx].sg_cterm &= ~HL_BOLD;",
          "1134:     if (key[5] == 'F')",
          "1135:  highlight_set_ctermfg(idx, color, is_normal_group);",
          "1136:     else if (key[5] == 'B')",
          "1137:  highlight_set_ctermbg(idx, color, is_normal_group);",
          "1138:     else // ctermul",
          "1139:  highlight_set_ctermul(idx, color, is_normal_group);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1142:     char_u **namep;",
          "1143:     int  did_change = FALSE;",
          "1145:     namep = &HL_TABLE()[idx].sg_gui_fg_name;",
          "1151: # if defined(FEAT_GUI) || defined(FEAT_TERMGUICOLORS)",
          "1157: # endif",
          "1167: # if defined(FEAT_GUI) || defined(FEAT_TERMGUICOLORS)",
          "1168: #  ifdef FEAT_GUI_X11",
          "1179: #   ifdef FEAT_BEVAL_GUI",
          "1185: #   endif",
          "1186: #  endif",
          "1189:     }",
          "1191:     return did_change;",
          "1192: }",
          "",
          "[Removed Lines]",
          "1146:     if (!init || !(HL_TABLE()[idx].sg_set & SG_GUI))",
          "1147:     {",
          "1148:  if (!init)",
          "1149:      HL_TABLE()[idx].sg_set |= SG_GUI;",
          "1153:  i = color_name2handle(arg);",
          "1154:  if (i != INVALCOLOR || STRCMP(arg, \"NONE\") == 0 || !USE_24BIT)",
          "1155:  {",
          "1156:      HL_TABLE()[idx].sg_gui_fg = i;",
          "1158:      if (*namep == NULL || STRCMP(*namep, arg) != 0)",
          "1159:      {",
          "1160:   vim_free(*namep);",
          "1161:   if (STRCMP(arg, \"NONE\") != 0)",
          "1163:   else",
          "1165:   did_change = TRUE;",
          "1166:      }",
          "1169:      if (is_menu_group && gui.menu_fg_pixel != i)",
          "1170:      {",
          "1171:   gui.menu_fg_pixel = i;",
          "1173:      }",
          "1174:      if (is_scrollbar_group && gui.scroll_fg_pixel != i)",
          "1175:      {",
          "1176:   gui.scroll_fg_pixel = i;",
          "1178:      }",
          "1180:      if (is_tooltip_group && gui.tooltip_fg_pixel != i)",
          "1181:      {",
          "1182:   gui.tooltip_fg_pixel = i;",
          "1184:      }",
          "1187:  }",
          "1188: # endif",
          "",
          "[Added Lines]",
          "1165:     if (init && (HL_TABLE()[idx].sg_set & SG_GUI))",
          "1166:  return FALSE;",
          "1169:     if (!init)",
          "1170:  HL_TABLE()[idx].sg_set |= SG_GUI;",
          "1174:     i = color_name2handle(arg);",
          "1175:     if (i != INVALCOLOR || STRCMP(arg, \"NONE\") == 0 || !USE_24BIT)",
          "1176:     {",
          "1177:  HL_TABLE()[idx].sg_gui_fg = i;",
          "1179:  if (*namep == NULL || STRCMP(*namep, arg) != 0)",
          "1180:  {",
          "1181:      vim_free(*namep);",
          "1182:      if (STRCMP(arg, \"NONE\") != 0)",
          "1184:      else",
          "1186:      did_change = TRUE;",
          "1187:  }",
          "1190:  if (is_menu_group && gui.menu_fg_pixel != i)",
          "1191:  {",
          "1192:      gui.menu_fg_pixel = i;",
          "1194:  }",
          "1195:  if (is_scrollbar_group && gui.scroll_fg_pixel != i)",
          "1196:  {",
          "1197:      gui.scroll_fg_pixel = i;",
          "1199:  }",
          "1201:  if (is_tooltip_group && gui.tooltip_fg_pixel != i)",
          "1202:  {",
          "1203:      gui.tooltip_fg_pixel = i;",
          "1205:  }",
          "1209: # endif",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1211:     char_u **namep;",
          "1212:     int  did_change = FALSE;",
          "1214:     namep = &HL_TABLE()[idx].sg_gui_bg_name;",
          "1220: # if defined(FEAT_GUI) || defined(FEAT_TERMGUICOLORS)",
          "1226: # endif",
          "1236: # if defined(FEAT_GUI) || defined(FEAT_TERMGUICOLORS)",
          "1237: #  ifdef FEAT_GUI_X11",
          "1248: #   ifdef FEAT_BEVAL_GUI",
          "1254: #   endif",
          "1255: #  endif",
          "1258:     }",
          "1260:     return did_change;",
          "1261: }",
          "",
          "[Removed Lines]",
          "1215:     if (!init || !(HL_TABLE()[idx].sg_set & SG_GUI))",
          "1216:     {",
          "1217:  if (!init)",
          "1218:      HL_TABLE()[idx].sg_set |= SG_GUI;",
          "1222:  i = color_name2handle(arg);",
          "1223:  if (i != INVALCOLOR || STRCMP(arg, \"NONE\") == 0 || !USE_24BIT)",
          "1224:  {",
          "1225:      HL_TABLE()[idx].sg_gui_bg = i;",
          "1227:      if (*namep == NULL || STRCMP(*namep, arg) != 0)",
          "1228:      {",
          "1229:   vim_free(*namep);",
          "1230:   if (STRCMP(arg, \"NONE\") != 0)",
          "1232:   else",
          "1234:   did_change = TRUE;",
          "1235:      }",
          "1238:      if (is_menu_group && gui.menu_bg_pixel != i)",
          "1239:      {",
          "1240:   gui.menu_bg_pixel = i;",
          "1242:      }",
          "1243:      if (is_scrollbar_group && gui.scroll_bg_pixel != i)",
          "1244:      {",
          "1245:   gui.scroll_bg_pixel = i;",
          "1247:      }",
          "1249:      if (is_tooltip_group && gui.tooltip_bg_pixel != i)",
          "1250:      {",
          "1251:   gui.tooltip_bg_pixel = i;",
          "1253:      }",
          "1256:  }",
          "1257: # endif",
          "",
          "[Added Lines]",
          "1234:     if (init && (HL_TABLE()[idx].sg_set & SG_GUI))",
          "1235:  return FALSE;",
          "1238:     if (!init)",
          "1239:  HL_TABLE()[idx].sg_set |= SG_GUI;",
          "1243:     i = color_name2handle(arg);",
          "1244:     if (i != INVALCOLOR || STRCMP(arg, \"NONE\") == 0 || !USE_24BIT)",
          "1245:     {",
          "1246:  HL_TABLE()[idx].sg_gui_bg = i;",
          "1248:  if (*namep == NULL || STRCMP(*namep, arg) != 0)",
          "1249:  {",
          "1250:      vim_free(*namep);",
          "1251:      if (STRCMP(arg, \"NONE\") != 0)",
          "1253:      else",
          "1255:      did_change = TRUE;",
          "1256:  }",
          "1259:  if (is_menu_group && gui.menu_bg_pixel != i)",
          "1260:  {",
          "1261:      gui.menu_bg_pixel = i;",
          "1263:  }",
          "1264:  if (is_scrollbar_group && gui.scroll_bg_pixel != i)",
          "1265:  {",
          "1266:      gui.scroll_bg_pixel = i;",
          "1268:  }",
          "1270:  if (is_tooltip_group && gui.tooltip_bg_pixel != i)",
          "1271:  {",
          "1272:      gui.tooltip_bg_pixel = i;",
          "1274:  }",
          "1278: # endif",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1273:     int  did_change = FALSE;",
          "1274:     char_u **namep;",
          "1276:     namep = &HL_TABLE()[idx].sg_gui_sp_name;",
          "1282: # if defined(FEAT_GUI) || defined(FEAT_TERMGUICOLORS)",
          "1288: # endif",
          "1299:  }",
          "1301:     }",
          "1303:     return did_change;",
          "1304: }",
          "",
          "[Removed Lines]",
          "1277:     if (!init || !(HL_TABLE()[idx].sg_set & SG_GUI))",
          "1278:     {",
          "1279:  if (!init)",
          "1280:      HL_TABLE()[idx].sg_set |= SG_GUI;",
          "1284:  i = color_name2handle(arg);",
          "1285:  if (i != INVALCOLOR || STRCMP(arg, \"NONE\") == 0 || !USE_24BIT)",
          "1286:  {",
          "1287:      HL_TABLE()[idx].sg_gui_sp = i;",
          "1289:      if (*namep == NULL || STRCMP(*namep, arg) != 0)",
          "1290:      {",
          "1291:   vim_free(*namep);",
          "1292:   if (STRCMP(arg, \"NONE\") != 0)",
          "1294:   else",
          "1296:   did_change = TRUE;",
          "1297:      }",
          "1298: # if defined(FEAT_GUI) || defined(FEAT_TERMGUICOLORS)",
          "1300: # endif",
          "",
          "[Added Lines]",
          "1296:     if (init && (HL_TABLE()[idx].sg_set & SG_GUI))",
          "1297:  return FALSE;",
          "1300:     if (!init)",
          "1301:  HL_TABLE()[idx].sg_set |= SG_GUI;",
          "1305:     i = color_name2handle(arg);",
          "1306:     if (i != INVALCOLOR || STRCMP(arg, \"NONE\") == 0 || !USE_24BIT)",
          "1307:     {",
          "1308:  HL_TABLE()[idx].sg_gui_sp = i;",
          "1310:  if (*namep == NULL || STRCMP(*namep, arg) != 0)",
          "1311:  {",
          "1312:      vim_free(*namep);",
          "1313:      if (STRCMP(arg, \"NONE\") != 0)",
          "1315:      else",
          "1317:      did_change = TRUE;",
          "1319: # if defined(FEAT_GUI) || defined(FEAT_TERMGUICOLORS)",
          "1321: # endif",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1995:     int  idx;",
          "1997:     idx = syn_name2id(name) - 1;",
          "2013: }",
          "",
          "[Removed Lines]",
          "1998:     if (idx >= 0)",
          "1999:     {",
          "2000:  gui_do_one_color(idx, do_menu, do_tooltip);",
          "2002:  if (HL_TABLE()[idx].sg_gui_fg != INVALCOLOR)",
          "2004:  else if (use_norm)",
          "2006:  if (HL_TABLE()[idx].sg_gui_bg != INVALCOLOR)",
          "2008:  else if (use_norm)",
          "2010:  return TRUE;",
          "2011:     }",
          "2012:     return FALSE;",
          "",
          "[Added Lines]",
          "2018:     if (idx < 0)",
          "2019:  return FALSE;",
          "2021:     gui_do_one_color(idx, do_menu, do_tooltip);",
          "2023:     if (HL_TABLE()[idx].sg_gui_fg != INVALCOLOR)",
          "2025:     else if (use_norm)",
          "2027:     if (HL_TABLE()[idx].sg_gui_bg != INVALCOLOR)",
          "2029:     else if (use_norm)",
          "2031:     return TRUE;",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "2042:     int     id;",
          "2044:     id = syn_name2id((char_u *)\"Normal\");",
          "2050: }",
          "",
          "[Removed Lines]",
          "2045:     if (id > 0)",
          "2046:     {",
          "2047:  vim_free(HL_TABLE()[id - 1].sg_font_name);",
          "2048:  HL_TABLE()[id - 1].sg_font_name = vim_strsave(font_name);",
          "2049:     }",
          "",
          "[Added Lines]",
          "2064:     if (id <= 0)",
          "2065:  return;",
          "2067:     vim_free(HL_TABLE()[id - 1].sg_font_name);",
          "2068:     HL_TABLE()[id - 1].sg_font_name = vim_strsave(font_name);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "2059: {",
          "2060:     int     id;",
          "2071: }",
          "",
          "[Removed Lines]",
          "2062:     if (name != NULL)",
          "2063:     {",
          "2064:  id = syn_name2id((char_u *)\"Normal\");",
          "2065:  if (id > 0)",
          "2066:  {",
          "2067:      vim_free(HL_TABLE()[id - 1].sg_gui_bg_name);",
          "2068:      HL_TABLE()[id - 1].sg_gui_bg_name = name;",
          "2069:  }",
          "2070:     }",
          "",
          "[Added Lines]",
          "2081:     if (name == NULL)",
          "2082:  return;",
          "2084:     id = syn_name2id((char_u *)\"Normal\");",
          "2085:     if (id <= 0)",
          "2086:  return;",
          "2088:     vim_free(HL_TABLE()[id - 1].sg_gui_bg_name);",
          "2089:     HL_TABLE()[id - 1].sg_gui_bg_name = name;",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "2080: {",
          "2081:     int     id;",
          "2092: }",
          "",
          "[Removed Lines]",
          "2083:     if (name != NULL)",
          "2084:     {",
          "2085:  id = syn_name2id((char_u *)\"Normal\");",
          "2086:  if (id > 0)",
          "2087:  {",
          "2088:      vim_free(HL_TABLE()[id - 1].sg_gui_fg_name);",
          "2089:      HL_TABLE()[id - 1].sg_gui_fg_name = name;",
          "2090:  }",
          "2091:     }",
          "",
          "[Added Lines]",
          "2102:     if (name == NULL)",
          "2103:  return;",
          "2105:     id = syn_name2id((char_u *)\"Normal\");",
          "2106:     if (id <= 0)",
          "2107:  return;",
          "2109:     vim_free(HL_TABLE()[id - 1].sg_gui_fg_name);",
          "2110:     HL_TABLE()[id - 1].sg_gui_fg_name = name;",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "2974:     if (got_int)",
          "2975:  return FALSE;",
          "2977:     {",
          "2984:  {",
          "2987:      {",
          "2995:      }",
          "2996:  }",
          "3002:  {",
          "3009:  }",
          "3010:     }",
          "3011:     return didh;",
          "3012: }",
          "",
          "[Removed Lines]",
          "2976:     if (type == LIST_STRING ? (sarg != NULL) : (iarg != 0))",
          "2978:  ts = buf;",
          "2979:  if (type == LIST_INT)",
          "2980:      sprintf((char *)buf, \"%d\", iarg - 1);",
          "2981:  else if (type == LIST_STRING)",
          "2982:      ts = sarg;",
          "2983:  else // type == LIST_ATTR",
          "2985:      buf[0] = NUL;",
          "2986:      for (i = 0; hl_attr_table[i] != 0; ++i)",
          "2988:   if (iarg & hl_attr_table[i])",
          "2989:   {",
          "2990:       if (buf[0] != NUL)",
          "2991:    vim_strcat(buf, (char_u *)\",\", MAX_ATTR_LEN);",
          "2992:       vim_strcat(buf, (char_u *)hl_name_table[i], MAX_ATTR_LEN);",
          "2993:       iarg &= ~hl_attr_table[i];     // don't want \"inverse\"",
          "2994:   }",
          "2998:  (void)syn_list_header(didh,",
          "2999:           (int)(vim_strsize(ts) + STRLEN(name) + 1), id);",
          "3000:  didh = TRUE;",
          "3001:  if (!got_int)",
          "3003:      if (*name != NUL)",
          "3004:      {",
          "3005:   msg_puts_attr(name, HL_ATTR(HLF_D));",
          "3006:   msg_puts_attr(\"=\", HL_ATTR(HLF_D));",
          "3007:      }",
          "3008:      msg_outtrans(ts);",
          "",
          "[Added Lines]",
          "2996:     if (type == LIST_STRING ? (sarg == NULL) : (iarg == 0))",
          "2997:  return didh;",
          "2999:     ts = buf;",
          "3000:     if (type == LIST_INT)",
          "3001:  sprintf((char *)buf, \"%d\", iarg - 1);",
          "3002:     else if (type == LIST_STRING)",
          "3003:  ts = sarg;",
          "3004:     else // type == LIST_ATTR",
          "3006:  buf[0] = NUL;",
          "3007:  for (i = 0; hl_attr_table[i] != 0; ++i)",
          "3009:      if (iarg & hl_attr_table[i])",
          "3011:   if (buf[0] != NUL)",
          "3012:       vim_strcat(buf, (char_u *)\",\", MAX_ATTR_LEN);",
          "3013:   vim_strcat(buf, (char_u *)hl_name_table[i], MAX_ATTR_LEN);",
          "3014:   iarg &= ~hl_attr_table[i];     // don't want \"inverse\"",
          "3017:     }",
          "3019:     (void)syn_list_header(didh,",
          "3020:      (int)(vim_strsize(ts) + STRLEN(name) + 1), id);",
          "3021:     didh = TRUE;",
          "3022:     if (!got_int)",
          "3023:     {",
          "3024:  if (*name != NUL)",
          "3026:      msg_puts_attr(name, HL_ATTR(HLF_D));",
          "3027:      msg_puts_attr(\"=\", HL_ATTR(HLF_D));",
          "3029:  msg_outtrans(ts);",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "3380:     int     id = 0;",
          "3382:     name = vim_strnsave(linep, len);",
          "3388:     return id;",
          "3389: }",
          "",
          "[Removed Lines]",
          "3383:     if (name != NULL)",
          "3384:     {",
          "3385:  id = syn_name2id(name);",
          "3386:  vim_free(name);",
          "3387:     }",
          "",
          "[Added Lines]",
          "3403:     if (name == NULL)",
          "3404:  return 0;",
          "3406:     id = syn_name2id(name);",
          "3407:     vim_free(name);",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "3927:     include_link = 2;",
          "3928:     include_default = 1;",
          "3932:     {",
          "3933:  p = skiptowhite(arg);",
          "3935:  {",
          "3962:  }",
          "3963:     }",
          "3964: }",
          "",
          "[Removed Lines]",
          "3931:     if (*arg != NUL)",
          "3934:  if (*p != NUL)   // past \"default\" or group name",
          "3936:      include_default = 0;",
          "3937:      if (STRNCMP(\"default\", arg, p - arg) == 0)",
          "3938:      {",
          "3939:   arg = skipwhite(p);",
          "3940:   xp->xp_pattern = arg;",
          "3941:   p = skiptowhite(arg);",
          "3942:      }",
          "3943:      if (*p != NUL)   // past group name",
          "3944:      {",
          "3945:   include_link = 0;",
          "3946:   if (arg[1] == 'i' && arg[0] == 'N')",
          "3947:       highlight_list();",
          "3948:   if (STRNCMP(\"link\", arg, p - arg) == 0",
          "3949:    || STRNCMP(\"clear\", arg, p - arg) == 0)",
          "3950:   {",
          "3951:       xp->xp_pattern = skipwhite(p);",
          "3952:       p = skiptowhite(xp->xp_pattern);",
          "3953:       if (*p != NUL)  // past first group name",
          "3954:       {",
          "3955:    xp->xp_pattern = skipwhite(p);",
          "3956:    p = skiptowhite(xp->xp_pattern);",
          "3957:       }",
          "3958:   }",
          "3959:   if (*p != NUL)   // past group name(s)",
          "3960:       xp->xp_context = EXPAND_NOTHING;",
          "3961:      }",
          "",
          "[Added Lines]",
          "3950:     if (*arg == NUL)",
          "3951:  return;",
          "3954:     p = skiptowhite(arg);",
          "3955:     if (*p == NUL)",
          "3956:  return;",
          "3959:     include_default = 0;",
          "3960:     if (STRNCMP(\"default\", arg, p - arg) == 0)",
          "3962:  arg = skipwhite(p);",
          "3963:  xp->xp_pattern = arg;",
          "3965:     }",
          "3966:     if (*p == NUL)",
          "3967:  return;",
          "3970:     include_link = 0;",
          "3971:     if (arg[1] == 'i' && arg[0] == 'N')",
          "3972:  highlight_list();",
          "3973:     if (STRNCMP(\"link\", arg, p - arg) == 0",
          "3974:      || STRNCMP(\"clear\", arg, p - arg) == 0)",
          "3975:     {",
          "3976:  xp->xp_pattern = skipwhite(p);",
          "3977:  p = skiptowhite(xp->xp_pattern);",
          "3978:  if (*p != NUL)  // past first group name",
          "3980:      xp->xp_pattern = skipwhite(p);",
          "3981:      p = skiptowhite(xp->xp_pattern);",
          "3984:     if (*p != NUL)   // past group name(s)",
          "3985:  xp->xp_context = EXPAND_NOTHING;",
          "",
          "---------------"
        ],
        "src/version.c||src/version.c": [
          "File: src/version.c -> src/version.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "696: static int included_patches[] =",
          "699:     1165,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "699:     1166,",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "38b85cb4d7216705058708bacbc25ab90cd61595",
      "candidate_info": {
        "commit_hash": "38b85cb4d7216705058708bacbc25ab90cd61595",
        "repo": "vim/vim",
        "commit_url": "https://github.com/vim/vim/commit/38b85cb4d7216705058708bacbc25ab90cd61595",
        "files": [
          "runtime/doc/options.txt",
          "src/buffer.c",
          "src/cmdexpand.c",
          "src/option.c",
          "src/option.h",
          "src/optionstr.c",
          "src/proto/cmdexpand.pro",
          "src/proto/option.pro",
          "src/proto/search.pro",
          "src/search.c",
          "src/structs.h",
          "src/testdir/gen_opt_test.vim",
          "src/testdir/test_cmdline.vim",
          "src/version.c"
        ],
        "message": "patch 8.2.4463: completion only uses strict matching\n\nProblem:    Completion only uses strict matching.\nSolution:   Add the \"fuzzy\" item for 'wildoptions'. (Yegappan Lakshmanan,\n            closes #9803)",
        "before_after_code_files": [
          "src/buffer.c||src/buffer.c",
          "src/cmdexpand.c||src/cmdexpand.c",
          "src/option.c||src/option.c",
          "src/option.h||src/option.h",
          "src/optionstr.c||src/optionstr.c",
          "src/proto/cmdexpand.pro||src/proto/cmdexpand.pro",
          "src/proto/option.pro||src/proto/option.pro",
          "src/proto/search.pro||src/proto/search.pro",
          "src/search.c||src/search.c",
          "src/structs.h||src/structs.h",
          "src/testdir/gen_opt_test.vim||src/testdir/gen_opt_test.vim",
          "src/testdir/test_cmdline.vim||src/testdir/test_cmdline.vim",
          "src/version.c||src/version.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/buffer.c||src/buffer.c",
            "src/version.c||src/version.c"
          ],
          "candidate": [
            "src/buffer.c||src/buffer.c",
            "src/version.c||src/version.c"
          ]
        }
      },
      "candidate_diff": {
        "src/buffer.c||src/buffer.c": [
          "File: src/buffer.c -> src/buffer.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "2728:     int  round;",
          "2729:     char_u *p;",
          "2730:     int  attempt;",
          "2732: #ifdef FEAT_VIMINFO",
          "2733:     bufmatch_T *matches = NULL;",
          "2734: #endif",
          "",
          "[Removed Lines]",
          "2731:     char_u *patc;",
          "",
          "[Added Lines]",
          "2731:     char_u *patc = NULL;",
          "2735:     int  fuzzy;",
          "2736:     fuzmatch_str_T  *fuzmatch = NULL;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2741:  return FAIL;",
          "2742: #endif",
          "2746:     {",
          "2752:     }",
          "2759:     {",
          "2760:  regmatch_T regmatch;",
          "2766:  {",
          "2770:  }",
          "",
          "[Removed Lines]",
          "2745:     if (*pat == '^')",
          "2747:  patc = alloc(STRLEN(pat) + 11);",
          "2748:  if (patc == NULL)",
          "2749:      return FAIL;",
          "2750:  STRCPY(patc, \"\\\\(^\\\\|[\\\\/]\\\\)\");",
          "2751:  STRCPY(patc + 11, pat + 1);",
          "2753:     else",
          "2754:  patc = pat;",
          "2758:     for (attempt = 0; attempt <= 1; ++attempt)",
          "2762:  if (attempt > 0 && patc == pat)",
          "2763:      break; // there was no anchor, no need to try again",
          "2764:  regmatch.regprog = vim_regcomp(patc + attempt * 11, RE_MAGIC);",
          "2765:  if (regmatch.regprog == NULL)",
          "2767:      if (patc != pat)",
          "2768:   vim_free(patc);",
          "2769:      return FAIL;",
          "",
          "[Added Lines]",
          "2746:     fuzzy = cmdline_fuzzy_complete(pat);",
          "2750:     if (!fuzzy)",
          "2752:  if (*pat == '^')",
          "2753:  {",
          "2754:      patc = alloc(STRLEN(pat) + 11);",
          "2755:      if (patc == NULL)",
          "2756:   return FAIL;",
          "2757:      STRCPY(patc, \"\\\\(^\\\\|[\\\\/]\\\\)\");",
          "2758:      STRCPY(patc + 11, pat + 1);",
          "2759:  }",
          "2760:  else",
          "2761:      patc = pat;",
          "2766:     for (attempt = 0; attempt <= (fuzzy ? 0 : 1); ++attempt)",
          "2769:  int  score = 0;",
          "2771:  if (!fuzzy)",
          "2773:      if (attempt > 0 && patc == pat)",
          "2774:   break; // there was no anchor, no need to try again",
          "2775:      regmatch.regprog = vim_regcomp(patc + attempt * 11, RE_MAGIC);",
          "2776:      if (regmatch.regprog == NULL)",
          "2777:      {",
          "2778:   if (patc != pat)",
          "2779:       vim_free(patc);",
          "2780:   return FAIL;",
          "2781:      }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "2786:    continue;",
          "2787: #endif",
          "2790:   if (p != NULL)",
          "2791:   {",
          "2792:       if (round == 1)",
          "",
          "[Removed Lines]",
          "2789:   p = buflist_match(&regmatch, buf, p_wic);",
          "",
          "[Added Lines]",
          "2801:   if (!fuzzy)",
          "2802:       p = buflist_match(&regmatch, buf, p_wic);",
          "2803:   else",
          "2804:   {",
          "2805:       p = NULL;",
          "2807:       if ((score = fuzzy_match_str(buf->b_sfname, pat)) != 0)",
          "2808:    p = buf->b_sfname;",
          "2809:       if (p == NULL)",
          "2810:       {",
          "2812:    if ((score = fuzzy_match_str(buf->b_ffname, pat)) != 0)",
          "2813:        p = buf->b_ffname;",
          "2814:       }",
          "2815:   }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "2797:        p = home_replace_save(buf, p);",
          "2798:    else",
          "2799:        p = vim_strsave(p);",
          "2800: #ifdef FEAT_VIMINFO",
          "2802:    {",
          "2805:        count++;",
          "2806:    }",
          "2810:       }",
          "2811:   }",
          "2812:      }",
          "",
          "[Removed Lines]",
          "2801:    if (matches != NULL)",
          "2803:        matches[count].buf = buf;",
          "2804:        matches[count].match = p;",
          "2807:    else",
          "2808: #endif",
          "2809:        (*file)[count++] = p;",
          "",
          "[Added Lines]",
          "2828:    if (!fuzzy)",
          "2829:    {",
          "2831:        if (matches != NULL)",
          "2832:        {",
          "2833:     matches[count].buf = buf;",
          "2834:     matches[count].match = p;",
          "2835:     count++;",
          "2836:        }",
          "2837:        else",
          "2838: #endif",
          "2839:     (*file)[count++] = p;",
          "2840:    }",
          "2841:    else",
          "2843:        fuzmatch[count].idx = count;",
          "2844:        fuzmatch[count].str = p;",
          "2845:        fuzmatch[count].score = score;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "2814:   break;",
          "2815:      if (round == 1)",
          "2816:      {",
          "2819:   {",
          "2825: #ifdef FEAT_VIMINFO",
          "2828: #endif",
          "2829:      }",
          "2830:  }",
          "2834:     }",
          "2837:  vim_free(patc);",
          "2839: #ifdef FEAT_VIMINFO",
          "2841:     {",
          "2847:  {",
          "2856:  }",
          "2858:     }",
          "2859: #endif",
          "",
          "[Removed Lines]",
          "2818:   if (*file == NULL)",
          "2820:       vim_regfree(regmatch.regprog);",
          "2821:       if (patc != pat)",
          "2822:    vim_free(patc);",
          "2823:       return FAIL;",
          "2824:   }",
          "2826:   if (options & WILD_BUFLASTUSED)",
          "2827:       matches = ALLOC_MULT(bufmatch_T, count);",
          "2831:  vim_regfree(regmatch.regprog);",
          "2832:  if (count)  // match(es) found, break here",
          "2833:      break;",
          "2836:     if (patc != pat)",
          "2840:     if (matches != NULL)",
          "2842:  int i;",
          "2843:  if (count > 1)",
          "2844:      qsort(matches, count, sizeof(bufmatch_T), buf_compare);",
          "2846:  if (matches[0].buf == curbuf)",
          "2848:      for (i = 1; i < count; i++)",
          "2849:   (*file)[i-1] = matches[i].match;",
          "2850:      (*file)[count-1] = matches[0].match;",
          "2851:  }",
          "2852:  else",
          "2853:  {",
          "2854:      for (i = 0; i < count; i++)",
          "2855:   (*file)[i] = matches[i].match;",
          "2857:  vim_free(matches);",
          "",
          "[Added Lines]",
          "2855:   if (!fuzzy)",
          "2858:       if (*file == NULL)",
          "2859:       {",
          "2860:    vim_regfree(regmatch.regprog);",
          "2861:    if (patc != pat)",
          "2862:        vim_free(patc);",
          "2863:    return FAIL;",
          "2864:       }",
          "2866:       if (options & WILD_BUFLASTUSED)",
          "2867:    matches = ALLOC_MULT(bufmatch_T, count);",
          "2869:   }",
          "2870:   else",
          "2871:   {",
          "2872:       fuzmatch = ALLOC_MULT(fuzmatch_str_T, count);",
          "2873:       if (fuzmatch == NULL)",
          "2874:       {",
          "2877:    return FAIL;",
          "2878:       }",
          "2879:   }",
          "2883:  if (!fuzzy)",
          "2884:  {",
          "2885:      vim_regfree(regmatch.regprog);",
          "2886:      if (count)  // match(es) found, break here",
          "2887:   break;",
          "2888:  }",
          "2891:     if (!fuzzy && patc != pat)",
          "2895:     if (!fuzzy)",
          "2897:  if (matches != NULL)",
          "2899:      int i;",
          "2900:      if (count > 1)",
          "2901:   qsort(matches, count, sizeof(bufmatch_T), buf_compare);",
          "2903:      if (matches[0].buf == curbuf)",
          "2904:      {",
          "2905:   for (i = 1; i < count; i++)",
          "2906:       (*file)[i-1] = matches[i].match;",
          "2907:   (*file)[count-1] = matches[0].match;",
          "2908:      }",
          "2909:      else",
          "2910:      {",
          "2911:   for (i = 0; i < count; i++)",
          "2912:       (*file)[i] = matches[i].match;",
          "2913:      }",
          "2914:      vim_free(matches);",
          "2916:     }",
          "2917:     else",
          "2918:     {",
          "2919:  if (fuzzymatches_to_strmatches(fuzmatch, file, count, FALSE) == FAIL)",
          "2920:      return FAIL;",
          "",
          "---------------"
        ],
        "src/cmdexpand.c||src/cmdexpand.c": [
          "File: src/cmdexpand.c -> src/cmdexpand.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "18: static void set_expand_context(expand_T *xp);",
          "19: static int      ExpandGeneric(expand_T *xp, regmatch_T *regmatch,",
          "20:          char_u ***matches, int *numMatches,",
          "22: static int ExpandFromContext(expand_T *xp, char_u *, char_u ***, int *, int);",
          "23: static int expand_showtail(expand_T *xp);",
          "24: static int expand_shellcmd(char_u *filepat, char_u ***matches, int *numMatches, int flagsarg);",
          "",
          "[Removed Lines]",
          "21:          char_u *((*func)(expand_T *, int)), int escaped);",
          "",
          "[Added Lines]",
          "21:          char_u *((*func)(expand_T *, int)), int escaped,",
          "22:          char_u *fuzzystr);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "40: #define SHOW_FILE_TEXT(m) (showtail ? sm_gettail(matches[m]) : matches[m])",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "47:     static int",
          "48: cmdline_fuzzy_completion_supported(expand_T *xp)",
          "49: {",
          "50:     return (vim_strchr(p_wop, WOP_FUZZY) != NULL",
          "51:      && xp->xp_context != EXPAND_BOOL_SETTINGS",
          "52:      && xp->xp_context != EXPAND_COLORS",
          "53:      && xp->xp_context != EXPAND_COMPILER",
          "54:      && xp->xp_context != EXPAND_DIRECTORIES",
          "55:      && xp->xp_context != EXPAND_FILES",
          "56:      && xp->xp_context != EXPAND_FILES_IN_PATH",
          "57:      && xp->xp_context != EXPAND_FILETYPE",
          "58:      && xp->xp_context != EXPAND_HELP",
          "59:      && xp->xp_context != EXPAND_MAPPINGS",
          "60:      && xp->xp_context != EXPAND_OLD_SETTING",
          "61:      && xp->xp_context != EXPAND_OWNSYNTAX",
          "62:      && xp->xp_context != EXPAND_PACKADD",
          "63:      && xp->xp_context != EXPAND_SHELLCMD",
          "64:      && xp->xp_context != EXPAND_TAGS",
          "65:      && xp->xp_context != EXPAND_TAGS_LISTFILES",
          "66:      && xp->xp_context != EXPAND_USER_DEFINED",
          "67:      && xp->xp_context != EXPAND_USER_LIST);",
          "68: }",
          "74:     int",
          "75: cmdline_fuzzy_complete(char_u *fuzzystr)",
          "76: {",
          "77:     return vim_strchr(p_wop, WOP_FUZZY) != NULL && *fuzzystr != NUL;",
          "78: }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "195:     }",
          "196:     else",
          "197:     {",
          "201:      p2 = NULL;",
          "202:  else",
          "203:  {",
          "",
          "[Removed Lines]",
          "199:  if ((p1 = addstar(xp->xp_pattern, xp->xp_pattern_len,",
          "200:            xp->xp_context)) == NULL)",
          "",
          "[Added Lines]",
          "236:  if (cmdline_fuzzy_completion_supported(xp))",
          "238:      p1 = vim_strsave(xp->xp_pattern);",
          "239:  else",
          "240:      p1 = addstar(xp->xp_pattern, xp->xp_pattern_len, xp->xp_context);",
          "243:  if (p1 == NULL)",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "2190:     xp->xp_pattern_len = (int)(str + col - xp->xp_pattern);",
          "2195:     if (p_wic)",
          "2196:  options += WILD_ICASE;",
          "",
          "[Removed Lines]",
          "2191:     file_str = addstar(xp->xp_pattern, xp->xp_pattern_len, xp->xp_context);",
          "2192:     if (file_str == NULL)",
          "2193:  return EXPAND_UNSUCCESSFUL;",
          "",
          "[Added Lines]",
          "2234:     if (cmdline_fuzzy_completion_supported(xp))",
          "2236:  file_str = vim_strsave(xp->xp_pattern);",
          "2237:     else",
          "2238:     {",
          "2239:  file_str = addstar(xp->xp_pattern, xp->xp_pattern_len, xp->xp_context);",
          "2240:  if (file_str == NULL)",
          "2241:      return EXPAND_UNSUCCESSFUL;",
          "2242:     }",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "2318:     static int",
          "2319: ExpandOther(",
          "2320:  expand_T *xp,",
          "2321:  regmatch_T *rmp,",
          "2322:  char_u  ***matches,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2369:  char_u  *pat,",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "2386:     {",
          "2387:  if (xp->xp_context == tab[i].context)",
          "2388:  {",
          "2389:      if (tab[i].ic)",
          "2390:   rmp->rm_ic = TRUE;",
          "2391:      ret = ExpandGeneric(xp, rmp, matches, numMatches,",
          "2393:      break;",
          "2394:  }",
          "2395:     }",
          "",
          "[Removed Lines]",
          "2392:       tab[i].func, tab[i].escaped);",
          "",
          "[Added Lines]",
          "2442:      int fuzzy = cmdline_fuzzy_complete(pat);",
          "2447:       tab[i].func, tab[i].escaped,",
          "2448:       fuzzy ? pat : NULL);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "2531:     if (xp->xp_context == EXPAND_SETTINGS",
          "2532:      || xp->xp_context == EXPAND_BOOL_SETTINGS)",
          "2534:     else if (xp->xp_context == EXPAND_MAPPINGS)",
          "2535:  ret = ExpandMappings(&regmatch, numMatches, matches);",
          "2536: # if defined(FEAT_EVAL)",
          "",
          "[Removed Lines]",
          "2533:  ret = ExpandSettings(xp, &regmatch, numMatches, matches);",
          "",
          "[Added Lines]",
          "2589:  ret = ExpandSettings(xp, &regmatch, pat, numMatches, matches);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "2538:  ret = ExpandUserDefined(xp, &regmatch, matches, numMatches);",
          "2539: # endif",
          "2540:     else",
          "2543:     vim_regfree(regmatch.regprog);",
          "2544:     vim_free(tofree);",
          "",
          "[Removed Lines]",
          "2541:  ret = ExpandOther(xp, &regmatch, matches, numMatches);",
          "",
          "[Added Lines]",
          "2597:  ret = ExpandOther(pat, xp, &regmatch, matches, numMatches);",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "2563:     int  *numMatches,",
          "2564:     char_u *((*func)(expand_T *, int)),",
          "2567: {",
          "2568:     int  i;",
          "2569:     int  count = 0;",
          "2570:     int  round;",
          "2571:     char_u *str;",
          "",
          "[Removed Lines]",
          "2566:     int  escaped)",
          "",
          "[Added Lines]",
          "2625:     int  escaped,",
          "2626:     char_u *fuzzystr)",
          "2632:     fuzmatch_str_T *fuzmatch = NULL;",
          "2633:     int   score = 0;",
          "2634:     int  fuzzy = (fuzzystr != NULL);",
          "2635:     int  funcsort = FALSE;",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "2583:      if (*str == NUL)     // skip empty strings",
          "2584:   continue;",
          "2587:      {",
          "2588:   if (round)",
          "2589:   {",
          "",
          "[Removed Lines]",
          "2586:      if (vim_regexec(regmatch, str, (colnr_T)0))",
          "",
          "[Added Lines]",
          "2650:      if (vim_regexec(regmatch, str, (colnr_T)0) ||",
          "2651:       (fuzzy && ((score = fuzzy_match_str(str, fuzzystr)) != 0)))",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "2594:       if (str == NULL)",
          "2595:       {",
          "2596:    FreeWild(count, *matches);",
          "2599:    return FAIL;",
          "2600:       }",
          "2602: # ifdef FEAT_MENU",
          "2603:       if (func == get_menu_names && str != NULL)",
          "2604:       {",
          "",
          "[Removed Lines]",
          "2601:       (*matches)[count] = str;",
          "",
          "[Added Lines]",
          "2662:    if (fuzzy)",
          "2663:        fuzmatch_str_free(fuzmatch, count);",
          "2668:       if (fuzzy)",
          "2669:       {",
          "2670:    fuzmatch[count].idx = count;",
          "2671:    fuzmatch[count].str = str;",
          "2672:    fuzmatch[count].score = score;",
          "2673:       }",
          "2674:       else",
          "2675:    (*matches)[count] = str;",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "2616:  {",
          "2617:      if (count == 0)",
          "2618:   return OK;",
          "2621:      {",
          "",
          "[Removed Lines]",
          "2620:      if (*matches == NULL)",
          "",
          "[Added Lines]",
          "2693:      if (fuzzy)",
          "2694:   fuzmatch = ALLOC_MULT(fuzmatch_str_T, count);",
          "2695:      else",
          "2697:      if ((fuzzy && (fuzmatch == NULL)) || (*matches == NULL))",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "2635:   || xp->xp_context == EXPAND_FUNCTIONS",
          "2636:   || xp->xp_context == EXPAND_USER_FUNC",
          "2637:   || xp->xp_context == EXPAND_DISASSEMBLE)",
          "2640:           sort_func_compare);",
          "2641:  else",
          "2643:     }",
          "2645: #if defined(FEAT_SYN_HL)",
          "",
          "[Removed Lines]",
          "2639:      qsort((void *)*matches, (size_t)*numMatches, sizeof(char_u *),",
          "2642:      sort_strings(*matches, *numMatches);",
          "",
          "[Added Lines]",
          "2715:  {",
          "2717:      funcsort = TRUE;",
          "2718:      if (!fuzzy)",
          "2719:   qsort((void *)*matches, (size_t)*numMatches, sizeof(char_u *),",
          "2721:  }",
          "2723:  {",
          "2724:      if (!fuzzy)",
          "2725:   sort_strings(*matches, *numMatches);",
          "2726:  }",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "2648:     reset_expand_highlight();",
          "2649: #endif",
          "2650:     return OK;",
          "2651: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2735:     if (fuzzy && fuzzymatches_to_strmatches(fuzmatch, matches, count,",
          "2736:        funcsort) == FAIL)",
          "2737:  return FAIL;",
          "",
          "---------------"
        ],
        "src/option.c||src/option.c": [
          "File: src/option.c -> src/option.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "6447:     }",
          "6448: }",
          "6450:     int",
          "6451: ExpandSettings(",
          "6452:     expand_T *xp,",
          "6453:     regmatch_T *regmatch,",
          "6456: {",
          "6457:     int  num_normal = 0;     // Nr of matching non-term-code settings",
          "6458:     int  num_term = 0;     // Nr of matching terminal code settings",
          "",
          "[Removed Lines]",
          "6454:     int  *num_file,",
          "6455:     char_u ***file)",
          "",
          "[Added Lines]",
          "6466:     static int",
          "6467: match_str(",
          "6468:  char_u  *str,",
          "6469:  regmatch_T *regmatch,",
          "6470:  char_u  **matches,",
          "6471:  int  idx,",
          "6472:  int  test_only,",
          "6473:  int  fuzzy,",
          "6474:  char_u  *fuzzystr,",
          "6475:  fuzmatch_str_T  *fuzmatch)",
          "6476: {",
          "6477:     if (!fuzzy)",
          "6478:     {",
          "6479:  if (vim_regexec(regmatch, str, (colnr_T)0))",
          "6480:  {",
          "6481:      if (!test_only)",
          "6482:   matches[idx] = vim_strsave(str);",
          "6483:      return TRUE;",
          "6484:  }",
          "6485:     }",
          "6486:     else",
          "6487:     {",
          "6488:  int score;",
          "6490:  score = fuzzy_match_str(str, fuzzystr);",
          "6491:  if (score != 0)",
          "6492:  {",
          "6493:      if (!test_only)",
          "6494:      {",
          "6495:   fuzmatch[idx].idx = idx;",
          "6496:   fuzmatch[idx].str = vim_strsave(str);",
          "6497:   fuzmatch[idx].score = score;",
          "6498:      }",
          "6500:      return TRUE;",
          "6501:  }",
          "6502:     }",
          "6504:     return FALSE;",
          "6505: }",
          "6511:     char_u *fuzzystr,",
          "6512:     int  *numMatches,",
          "6513:     char_u ***matches)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "6465:     char_u name_buf[MAX_KEY_NAME_LEN];",
          "6466:     static char *(names[]) = {\"all\", \"termcap\"};",
          "6467:     int  ic = regmatch->rm_ic; // remember the ignore-case flag",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "6526:     int  fuzzy;",
          "6527:     fuzmatch_str_T  *fuzmatch = NULL;",
          "6529:     fuzzy = cmdline_fuzzy_complete(fuzzystr);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "6475:  if (xp->xp_context != EXPAND_BOOL_SETTINGS)",
          "6476:  {",
          "6477:      for (match = 0; match < (int)ARRAY_LENGTH(names); ++match)",
          "6479:   {",
          "6480:       if (loop == 0)",
          "6481:    num_normal++;",
          "6482:       else",
          "6484:   }",
          "6485:  }",
          "6486:  for (opt_idx = 0; (str = (char_u *)options[opt_idx].fullname) != NULL;",
          "6487:             opt_idx++)",
          "",
          "[Removed Lines]",
          "6478:   if (vim_regexec(regmatch, (char_u *)names[match], (colnr_T)0))",
          "6483:    (*file)[count++] = vim_strsave((char_u *)names[match]);",
          "",
          "[Added Lines]",
          "6540:      {",
          "6541:   if (match_str((char_u *)names[match], regmatch, *matches,",
          "6542:        count, (loop == 0), fuzzy, fuzzystr, fuzmatch))",
          "6547:    count++;",
          "6549:      }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "6494:      is_term_opt = istermoption_idx(opt_idx);",
          "6495:      if (is_term_opt && num_normal > 0)",
          "6496:   continue;",
          "6500:    && vim_regexec(regmatch,",
          "6503:      else if (is_term_opt)",
          "6504:      {",
          "6505:   name_buf[0] = '<';",
          "",
          "[Removed Lines]",
          "6497:      match = FALSE;",
          "6498:      if (vim_regexec(regmatch, str, (colnr_T)0)",
          "6499:       || (options[opt_idx].shortname != NULL",
          "6501:       (char_u *)options[opt_idx].shortname, (colnr_T)0)))",
          "6502:   match = TRUE;",
          "",
          "[Added Lines]",
          "6563:      if (match_str(str, regmatch, *matches, count, (loop == 0),",
          "6564:       fuzzy, fuzzystr, fuzmatch))",
          "6565:      {",
          "6566:   if (loop == 0)",
          "6567:   {",
          "6568:       if (is_term_opt)",
          "6569:    num_term++;",
          "6570:       else",
          "6571:    num_normal++;",
          "6572:   }",
          "6573:   else",
          "6574:       count++;",
          "6575:      }",
          "6576:      else if (!fuzzy && options[opt_idx].shortname != NULL",
          "6578:                              (char_u *)options[opt_idx].shortname, (colnr_T)0))",
          "6579:      {",
          "6583:   if (loop == 0)",
          "6584:   {",
          "6585:       if (is_term_opt)",
          "6586:    num_term++;",
          "6587:       else",
          "6588:    num_normal++;",
          "6589:   }",
          "6590:   else",
          "6591:       (*matches)[count++] = vim_strsave(str);",
          "6592:      }",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "6509:   name_buf[4] = str[3];",
          "6510:   name_buf[5] = '>';",
          "6511:   name_buf[6] = NUL;",
          "6521:   {",
          "6523:    num_term++;",
          "6524:       else",
          "6526:   }",
          "6529:      }",
          "6530:  }",
          "",
          "[Removed Lines]",
          "6512:   if (vim_regexec(regmatch, name_buf, (colnr_T)0))",
          "6513:   {",
          "6514:       match = TRUE;",
          "6515:       str = name_buf;",
          "6516:   }",
          "6517:      }",
          "6518:      if (match)",
          "6519:      {",
          "6520:   if (loop == 0)",
          "6522:       if (is_term_opt)",
          "6525:    num_normal++;",
          "6527:   else",
          "6528:       (*file)[count++] = vim_strsave(str);",
          "",
          "[Added Lines]",
          "6603:   if (match_str(name_buf, regmatch, *matches, count, (loop == 0),",
          "6604:        fuzzy, fuzzystr, fuzmatch))",
          "6606:       if (loop == 0)",
          "6609:    count++;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "6544:   name_buf[3] = str[1];",
          "6545:   name_buf[4] = NUL;",
          "6550:   else",
          "6551:   {",
          "6552:       name_buf[0] = '<';",
          "",
          "[Removed Lines]",
          "6547:   match = FALSE;",
          "6548:   if (vim_regexec(regmatch, name_buf, (colnr_T)0))",
          "6549:       match = TRUE;",
          "",
          "[Added Lines]",
          "6630:   if (match_str(name_buf, regmatch, *matches, count,",
          "6631:      (loop == 0), fuzzy, fuzzystr, fuzmatch))",
          "6632:   {",
          "6633:       if (loop == 0)",
          "6634:    num_term++;",
          "6635:       else",
          "6636:    count++;",
          "6637:   }",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "6557:       name_buf[5] = '>';",
          "6558:       name_buf[6] = NUL;",
          "6569:   }",
          "6570:      }",
          "",
          "[Removed Lines]",
          "6560:       if (vim_regexec(regmatch, name_buf, (colnr_T)0))",
          "6561:    match = TRUE;",
          "6562:   }",
          "6563:   if (match)",
          "6564:   {",
          "6565:       if (loop == 0)",
          "6566:    num_term++;",
          "6567:       else",
          "6568:    (*file)[count++] = vim_strsave(name_buf);",
          "",
          "[Added Lines]",
          "6648:       if (match_str(name_buf, regmatch, *matches, count,",
          "6649:          (loop == 0), fuzzy, fuzzystr,",
          "6650:          fuzmatch))",
          "6651:       {",
          "6652:    if (loop == 0)",
          "6653:        num_term++;",
          "6654:    else",
          "6655:        count++;",
          "6656:       }",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "6579:   STRCPY(name_buf + 1, str);",
          "6580:   STRCAT(name_buf, \">\");",
          "6583:   {",
          "6584:       if (loop == 0)",
          "6585:    num_term++;",
          "6586:       else",
          "6588:   }",
          "6589:      }",
          "6590:  }",
          "6591:  if (loop == 0)",
          "6592:  {",
          "6593:      if (num_normal > 0)",
          "6595:      else if (num_term > 0)",
          "6597:      else",
          "6598:   return OK;",
          "6601:      {",
          "6604:      }",
          "6605:  }",
          "6606:     }",
          "6607:     return OK;",
          "6608: }",
          "",
          "[Removed Lines]",
          "6582:   if (vim_regexec(regmatch, name_buf, (colnr_T)0))",
          "6587:    (*file)[count++] = vim_strsave(name_buf);",
          "6600:      if (*file == NULL)",
          "6603:   return FAIL;",
          "",
          "[Added Lines]",
          "6670:   if (match_str(name_buf, regmatch, *matches, count, (loop == 0),",
          "6671:        fuzzy, fuzzystr, fuzmatch))",
          "6676:    count++;",
          "6688:      if (!fuzzy)",
          "6691:   if (*matches == NULL)",
          "6692:   {",
          "6694:       return FAIL;",
          "6695:   }",
          "6696:      }",
          "6697:      else",
          "6698:      {",
          "6699:   fuzmatch = ALLOC_MULT(fuzmatch_str_T, *numMatches);",
          "6700:   if (fuzmatch == NULL)",
          "6701:   {",
          "6703:       return FAIL;",
          "6704:   }",
          "6709:     if (fuzzy &&",
          "6710:  fuzzymatches_to_strmatches(fuzmatch, matches, count, FALSE) == FAIL)",
          "6711:  return FAIL;",
          "",
          "---------------"
        ],
        "src/option.h||src/option.h": [
          "File: src/option.h -> src/option.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "361: #define WOP_TAGFILE 't'",
          "362: #define WOP_PUM  'p'",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "361: #define WOP_FUZZY 'z'",
          "",
          "---------------"
        ],
        "src/optionstr.c||src/optionstr.c": [
          "File: src/optionstr.c -> src/optionstr.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "57: static char *(p_ttym_values[]) = {\"xterm\", \"xterm2\", \"dec\", \"netterm\", \"jsbterm\", \"pterm\", \"urxvt\", \"sgr\", NULL};",
          "58: #endif",
          "59: static char *(p_ve_values[]) = {\"block\", \"insert\", \"all\", \"onemore\", \"none\", \"NONE\", NULL};",
          "61: #ifdef FEAT_WAK",
          "62: static char *(p_wak_values[]) = {\"yes\", \"menu\", \"no\", NULL};",
          "63: #endif",
          "",
          "[Removed Lines]",
          "60: static char *(p_wop_values[]) = {\"tagfile\", \"pum\", NULL};",
          "",
          "[Added Lines]",
          "60: static char *(p_wop_values[]) = {\"fuzzy\", \"tagfile\", \"pum\", NULL};",
          "",
          "---------------"
        ],
        "src/proto/cmdexpand.pro||src/proto/cmdexpand.pro": [
          "File: src/proto/cmdexpand.pro -> src/proto/cmdexpand.pro",
          "--- Hunk 1 ---",
          "[Context before]",
          "2: int nextwild(expand_T *xp, int type, int options, int escape);",
          "3: char_u *ExpandOne(expand_T *xp, char_u *str, char_u *orig, int options, int mode);",
          "4: void ExpandInit(expand_T *xp);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2: int cmdline_fuzzy_complete(char_u *fuzzystr);",
          "",
          "---------------"
        ],
        "src/proto/option.pro||src/proto/option.pro": [
          "File: src/proto/option.pro -> src/proto/option.pro",
          "--- Hunk 1 ---",
          "[Context before]",
          "63: void set_iminsert_global(void);",
          "64: void set_imsearch_global(void);",
          "65: void set_context_in_set_cmd(expand_T *xp, char_u *arg, int opt_flags);",
          "67: int ExpandOldSetting(int *num_file, char_u ***file);",
          "68: int shortmess(int x);",
          "69: void vimrc_found(char_u *fname, char_u *envname);",
          "",
          "[Removed Lines]",
          "66: int ExpandSettings(expand_T *xp, regmatch_T *regmatch, int *num_file, char_u ***file);",
          "",
          "[Added Lines]",
          "66: int ExpandSettings(expand_T *xp, regmatch_T *regmatch, char_u *pat, int *numMatches, char_u ***matches);",
          "",
          "---------------"
        ],
        "src/proto/search.pro||src/proto/search.pro": [
          "File: src/proto/search.pro -> src/proto/search.pro",
          "--- Hunk 1 ---",
          "[Context before]",
          "40: int fuzzy_match(char_u *str, char_u *pat_arg, int matchseq, int *outScore, int_u *matches, int maxMatches);",
          "41: void f_matchfuzzy(typval_T *argvars, typval_T *rettv);",
          "42: void f_matchfuzzypos(typval_T *argvars, typval_T *rettv);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "43: int fuzzy_match_str(char_u *str, char_u *pat);",
          "44: int fuzzymatches_to_strmatches(fuzmatch_str_T *fuzmatch, char_u ***matches, int count, int funcsort);",
          "45: void fuzmatch_str_free(fuzmatch_str_T *fuzmatch, int count);",
          "",
          "---------------"
        ],
        "src/search.c||src/search.c": [
          "File: src/search.c -> src/search.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1166:     return submatch + 1;",
          "1167: }",
          "1170:     void",
          "1171: set_search_direction(int cdir)",
          "1172: {",
          "",
          "[Removed Lines]",
          "1169: #ifdef FEAT_EVAL",
          "",
          "[Added Lines]",
          "1169: #if defined(FEAT_EVAL) || defined(FEAT_PROTO)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "4107: }",
          "4108: #endif",
          "",
          "[Removed Lines]",
          "4110: #ifdef FEAT_EVAL",
          "",
          "[Added Lines]",
          "4110: #if defined(FEAT_EVAL) || defined(FEAT_PROTO)",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "4230:     restore_incsearch_state();",
          "4231: #endif",
          "4232: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4233: #endif",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "4611:     return numMatches != 0;",
          "4612: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4615: #if defined(FEAT_EVAL) || defined(FEAT_PROTO)",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "4933: {",
          "4934:     do_fuzzymatch(argvars, rettv, TRUE);",
          "4935: }",
          "4937: #endif",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4943:     static int",
          "4944: fuzzy_match_str_compare(const void *s1, const void *s2)",
          "4945: {",
          "4946:     int  v1 = ((fuzmatch_str_T *)s1)->score;",
          "4947:     int  v2 = ((fuzmatch_str_T *)s2)->score;",
          "4948:     int  idx1 = ((fuzmatch_str_T *)s1)->idx;",
          "4949:     int  idx2 = ((fuzmatch_str_T *)s2)->idx;",
          "4951:     return v1 == v2 ? (idx1 - idx2) : v1 > v2 ? -1 : 1;",
          "4952: }",
          "4957:     static void",
          "4958: fuzzy_match_str_sort(fuzmatch_str_T *fm, int sz)",
          "4959: {",
          "4961:     qsort((void *)fm, (size_t)sz, sizeof(fuzmatch_str_T),",
          "4962:      fuzzy_match_str_compare);",
          "4963: }",
          "4969:     static int",
          "4970: fuzzy_match_func_compare(const void *s1, const void *s2)",
          "4971: {",
          "4972:     int  v1 = ((fuzmatch_str_T *)s1)->score;",
          "4973:     int  v2 = ((fuzmatch_str_T *)s2)->score;",
          "4974:     int  idx1 = ((fuzmatch_str_T *)s1)->idx;",
          "4975:     int  idx2 = ((fuzmatch_str_T *)s2)->idx;",
          "4976:     char_u *str1 = ((fuzmatch_str_T *)s1)->str;",
          "4977:     char_u *str2 = ((fuzmatch_str_T *)s2)->str;",
          "4979:     if (*str1 != '<' && *str2 == '<') return -1;",
          "4980:     if (*str1 == '<' && *str2 != '<') return 1;",
          "4981:     return v1 == v2 ? (idx1 - idx2) : v1 > v2 ? -1 : 1;",
          "4982: }",
          "4988:     static void",
          "4989: fuzzy_match_func_sort(fuzmatch_str_T *fm, int sz)",
          "4990: {",
          "4992:     qsort((void *)fm, (size_t)sz, sizeof(fuzmatch_str_T),",
          "4993:   fuzzy_match_func_compare);",
          "4994: }",
          "5000:     int",
          "5001: fuzzy_match_str(char_u *str, char_u *pat)",
          "5002: {",
          "5003:     int  score = 0;",
          "5004:     int_u matchpos[256];",
          "5006:     if (str == NULL || pat == NULL)",
          "5007:  return 0;",
          "5009:     fuzzy_match(str, pat, FALSE, &score, matchpos,",
          "5010:     sizeof(matchpos) / sizeof(matchpos[0]));",
          "5012:     return score;",
          "5013: }",
          "5020:     int",
          "5021: fuzzymatches_to_strmatches(",
          "5022:  fuzmatch_str_T *fuzmatch,",
          "5023:  char_u  ***matches,",
          "5024:  int  count,",
          "5025:  int  funcsort)",
          "5026: {",
          "5027:     int  i;",
          "5029:     if (count <= 0)",
          "5030:  return OK;",
          "5033:     if (*matches == NULL)",
          "5034:     {",
          "5035:  for (i = 0; i < count; i++)",
          "5036:      vim_free(fuzmatch[i].str);",
          "5037:  vim_free(fuzmatch);",
          "5038:  return FAIL;",
          "5039:     }",
          "5042:     if (funcsort)",
          "5043:  fuzzy_match_func_sort((void *)fuzmatch, (size_t)count);",
          "5044:     else",
          "5045:  fuzzy_match_str_sort((void *)fuzmatch, (size_t)count);",
          "5047:     for (i = 0; i < count; i++)",
          "5048:  (*matches)[i] = fuzmatch[i].str;",
          "5049:     vim_free(fuzmatch);",
          "5051:     return OK;",
          "5052: }",
          "5057:     void",
          "5058: fuzmatch_str_free(fuzmatch_str_T *fuzmatch, int count)",
          "5059: {",
          "5060:     if (count <= 0 || fuzmatch == NULL)",
          "5061:  return;",
          "5062:     while (count--)",
          "5063:  vim_free(fuzmatch[count].str);",
          "5064:     vim_free(fuzmatch);",
          "5065: }",
          "",
          "---------------"
        ],
        "src/structs.h||src/structs.h": [
          "File: src/structs.h -> src/structs.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "4516:     int  sw_same_win;     // VIsual_active was not reset",
          "4517:     int  sw_visual_active;",
          "4518: } switchwin_T;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4522: typedef struct {",
          "4523:     int  idx;",
          "4524:     char_u *str;",
          "4525:     int  score;",
          "4526: } fuzmatch_str_T;",
          "",
          "---------------"
        ],
        "src/testdir/gen_opt_test.vim||src/testdir/gen_opt_test.vim": [
          "File: src/testdir/gen_opt_test.vim -> src/testdir/gen_opt_test.vim",
          "--- Hunk 1 ---",
          "[Context before]",
          "11: \" Clear out t_WS, we don't want to resize the actual terminal.",
          "12: let script = [",
          "13:       \\ '\" DO NOT EDIT: Generated with gen_opt_test.vim',",
          "14:       \\ '',",
          "15:       \\ 'let save_columns = &columns',",
          "16:       \\ 'let save_lines = &lines',",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "14:       \\ '\" Used by test_options.vim.',",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "152:       \\ 'virtualedit': [['', 'all', 'all,block'], ['xxx']],",
          "153:       \\ 'whichwrap': [['', 'b,s', 'bs'], ['xxx']],",
          "154:       \\ 'wildmode': [['', 'full', 'list:full', 'full,longest'], ['xxx', 'a4', 'full,full,full,full,full']],",
          "156:       \\ 'winaltkeys': [['menu', 'no'], ['', 'xxx']],",
          "157:       \\",
          "158:       \\ 'luadll': [[], []],",
          "",
          "[Removed Lines]",
          "155:       \\ 'wildoptions': [['', 'tagfile'], ['xxx']],",
          "",
          "[Added Lines]",
          "156:       \\ 'wildoptions': [['', 'tagfile', 'pum', 'fuzzy'], ['xxx']],",
          "",
          "---------------"
        ],
        "src/testdir/test_cmdline.vim||src/testdir/test_cmdline.vim": [
          "File: src/testdir/test_cmdline.vim -> src/testdir/test_cmdline.vim",
          "--- Hunk 1 ---",
          "[Context before]",
          "1574:   call assert_equal(1, winnr('$'))",
          "1575: endfunc",
          "1577: func Test_cmdwin_interrupted()",
          "1578:   CheckFeature cmdwin",
          "1579:   CheckScreendump",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1577: func Test_cmdwin_tabpage()",
          "1578:   tabedit",
          "1579:   call assert_fails(\"silent norm q/g :I\\<Esc>\", 'E11:')",
          "1580:   tabclose!",
          "1581: endfunc",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2438:   call assert_equal(\"\\\"dlist 10 /pat/ | chistory\", @:)",
          "2439: endfunc",
          "2441: \" vim: shiftwidth=2 sts=2 expandtab",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2447: \" Test for 'fuzzy' in 'wildoptions' (fuzzy completion)",
          "2448: func Test_wildoptions_fuzzy()",
          "2449:   \" argument list (only for :argdel)",
          "2450:   argadd change.py count.py charge.py",
          "2451:   set wildoptions&",
          "2452:   call feedkeys(\":argdel cge\\<C-A>\\<C-B>\\\"\\<CR>\", 'tx')",
          "2453:   call assert_equal('\"argdel cge', @:)",
          "2454:   set wildoptions=fuzzy",
          "2455:   call feedkeys(\":argdel cge\\<C-A>\\<C-B>\\\"\\<CR>\", 'tx')",
          "2456:   call assert_equal('\"argdel change.py charge.py', @:)",
          "2457:   %argdelete",
          "2459:   \" autocmd group name fuzzy completion",
          "2460:   set wildoptions&",
          "2461:   augroup MyFuzzyGroup",
          "2462:   augroup END",
          "2463:   call feedkeys(\":augroup mfg\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')",
          "2464:   call assert_equal('\"augroup mfg', @:)",
          "2465:   call feedkeys(\":augroup My*p\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')",
          "2466:   call assert_equal('\"augroup MyFuzzyGroup', @:)",
          "2467:   set wildoptions=fuzzy",
          "2468:   call feedkeys(\":augroup mfg\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')",
          "2469:   call assert_equal('\"augroup MyFuzzyGroup', @:)",
          "2470:   call feedkeys(\":augroup My*p\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')",
          "2471:   call assert_equal('\"augroup My*p', @:)",
          "2472:   augroup! MyFuzzyGroup",
          "2474:   \" buffer name fuzzy completion",
          "2475:   set wildoptions&",
          "2476:   edit SomeFile.txt",
          "2477:   enew",
          "2478:   call feedkeys(\":b SF\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')",
          "2479:   call assert_equal('\"b SF', @:)",
          "2480:   call feedkeys(\":b S*File.txt\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')",
          "2481:   call assert_equal('\"b SomeFile.txt', @:)",
          "2482:   set wildoptions=fuzzy",
          "2483:   call feedkeys(\":b SF\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')",
          "2484:   call assert_equal('\"b SomeFile.txt', @:)",
          "2485:   call feedkeys(\":b S*File.txt\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')",
          "2486:   call assert_equal('\"b S*File.txt', @:)",
          "2487:   %bw!",
          "2489:   \" buffer name (full path) fuzzy completion",
          "2490:   if has('unix')",
          "2491:     set wildoptions&",
          "2492:     call mkdir('Xcmd/Xstate/Xfile.js', 'p')",
          "2493:     edit Xcmd/Xstate/Xfile.js",
          "2494:     cd Xcmd/Xstate",
          "2495:     enew",
          "2496:     call feedkeys(\":b CmdStateFile\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')",
          "2497:     call assert_equal('\"b CmdStateFile', @:)",
          "2498:     set wildoptions=fuzzy",
          "2499:     call feedkeys(\":b CmdStateFile\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')",
          "2500:     call assert_match('Xcmd/Xstate/Xfile.js$', @:)",
          "2501:     cd -",
          "2502:     call delete('Xcmd', 'rf')",
          "2503:   endif",
          "2505:   \" :behave suboptions fuzzy completion",
          "2506:   set wildoptions&",
          "2507:   call feedkeys(\":behave xm\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')",
          "2508:   call assert_equal('\"behave xm', @:)",
          "2509:   call feedkeys(\":behave xt*m\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')",
          "2510:   call assert_equal('\"behave xterm', @:)",
          "2511:   set wildoptions=fuzzy",
          "2512:   call feedkeys(\":behave xm\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')",
          "2513:   call assert_equal('\"behave xterm', @:)",
          "2514:   call feedkeys(\":behave xt*m\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')",
          "2515:   call assert_equal('\"behave xt*m', @:)",
          "2516:   let g:Sline = ''",
          "2517:   call feedkeys(\":behave win\\<C-D>\\<F4>\\<C-B>\\\"\\<CR>\", 'tx')",
          "2518:   call assert_equal('mswin', g:Sline)",
          "2519:   call assert_equal('\"behave win', @:)",
          "2521:   \" colorscheme name fuzzy completion - NOT supported",
          "2523:   \" built-in command name fuzzy completion",
          "2524:   set wildoptions&",
          "2525:   call feedkeys(\":sbwin\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')",
          "2526:   call assert_equal('\"sbwin', @:)",
          "2527:   call feedkeys(\":sbr*d\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')",
          "2528:   call assert_equal('\"sbrewind', @:)",
          "2529:   set wildoptions=fuzzy",
          "2530:   call feedkeys(\":sbwin\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')",
          "2531:   call assert_equal('\"sbrewind', @:)",
          "2532:   call feedkeys(\":sbr*d\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')",
          "2533:   call assert_equal('\"sbr*d', @:)",
          "2535:   \" compiler name fuzzy completion - NOT supported",
          "2537:   \" :cscope suboptions fuzzy completion",
          "2538:   if has('cscope')",
          "2539:     set wildoptions&",
          "2540:     call feedkeys(\":cscope ret\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')",
          "2541:     call assert_equal('\"cscope ret', @:)",
          "2542:     call feedkeys(\":cscope re*t\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')",
          "2543:     call assert_equal('\"cscope reset', @:)",
          "2544:     set wildoptions=fuzzy",
          "2545:     call feedkeys(\":cscope ret\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')",
          "2546:     call assert_equal('\"cscope reset', @:)",
          "2547:     call feedkeys(\":cscope re*t\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')",
          "2548:     call assert_equal('\"cscope re*t', @:)",
          "2549:   endif",
          "2551:   \" :diffget/:diffput buffer name fuzzy completion",
          "2552:   new SomeBuffer",
          "2553:   diffthis",
          "2554:   new OtherBuffer",
          "2555:   diffthis",
          "2556:   set wildoptions&",
          "2557:   call feedkeys(\":diffget sbuf\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')",
          "2558:   call assert_equal('\"diffget sbuf', @:)",
          "2559:   call feedkeys(\":diffput sbuf\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')",
          "2560:   call assert_equal('\"diffput sbuf', @:)",
          "2561:   set wildoptions=fuzzy",
          "2562:   call feedkeys(\":diffget sbuf\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')",
          "2563:   call assert_equal('\"diffget SomeBuffer', @:)",
          "2564:   call feedkeys(\":diffput sbuf\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')",
          "2565:   call assert_equal('\"diffput SomeBuffer', @:)",
          "2566:   %bw!",
          "2568:   \" directory name fuzzy completion - NOT supported",
          "2570:   \" environment variable name fuzzy completion",
          "2571:   set wildoptions&",
          "2572:   call feedkeys(\":echo $VUT\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')",
          "2573:   call assert_equal('\"echo $VUT', @:)",
          "2574:   set wildoptions=fuzzy",
          "2575:   call feedkeys(\":echo $VUT\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')",
          "2576:   call assert_equal('\"echo $VIMRUNTIME', @:)",
          "2578:   \" autocmd event fuzzy completion",
          "2579:   set wildoptions&",
          "2580:   call feedkeys(\":autocmd BWout\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')",
          "2581:   call assert_equal('\"autocmd BWout', @:)",
          "2582:   set wildoptions=fuzzy",
          "2583:   call feedkeys(\":autocmd BWout\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')",
          "2584:   call assert_equal('\"autocmd BufWipeout', @:)",
          "2586:   \" vim expression fuzzy completion",
          "2587:   let g:PerPlaceCount = 10",
          "2588:   set wildoptions&",
          "2589:   call feedkeys(\":let c = ppc\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')",
          "2590:   call assert_equal('\"let c = ppc', @:)",
          "2591:   set wildoptions=fuzzy",
          "2592:   call feedkeys(\":let c = ppc\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')",
          "2593:   call assert_equal('\"let c = PerPlaceCount', @:)",
          "2595:   \" file name fuzzy completion - NOT supported",
          "2597:   \" files in path fuzzy completion - NOT supported",
          "2599:   \" filetype name fuzzy completion - NOT supported",
          "2601:   \" user defined function name completion",
          "2602:   set wildoptions&",
          "2603:   call feedkeys(\":call Test_w_fuz\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')",
          "2604:   call assert_equal('\"call Test_w_fuz', @:)",
          "2605:   set wildoptions=fuzzy",
          "2606:   call feedkeys(\":call Test_w_fuz\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')",
          "2607:   call assert_equal('\"call Test_wildoptions_fuzzy()', @:)",
          "2609:   \" user defined command name completion",
          "2610:   set wildoptions&",
          "2611:   call feedkeys(\":MsFeat\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')",
          "2612:   call assert_equal('\"MsFeat', @:)",
          "2613:   set wildoptions=fuzzy",
          "2614:   call feedkeys(\":MsFeat\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')",
          "2615:   call assert_equal('\"MissingFeature', @:)",
          "2617:   \" :help tag fuzzy completion - NOT supported",
          "2619:   \" highlight group name fuzzy completion",
          "2620:   set wildoptions&",
          "2621:   call feedkeys(\":highlight SKey\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')",
          "2622:   call assert_equal('\"highlight SKey', @:)",
          "2623:   call feedkeys(\":highlight Sp*Key\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')",
          "2624:   call assert_equal('\"highlight SpecialKey', @:)",
          "2625:   set wildoptions=fuzzy",
          "2626:   call feedkeys(\":highlight SKey\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')",
          "2627:   call assert_equal('\"highlight SpecialKey', @:)",
          "2628:   call feedkeys(\":highlight Sp*Key\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')",
          "2629:   call assert_equal('\"highlight Sp*Key', @:)",
          "2631:   \" :history suboptions fuzzy completion",
          "2632:   set wildoptions&",
          "2633:   call feedkeys(\":history dg\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')",
          "2634:   call assert_equal('\"history dg', @:)",
          "2635:   call feedkeys(\":history se*h\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')",
          "2636:   call assert_equal('\"history search', @:)",
          "2637:   set wildoptions=fuzzy",
          "2638:   call feedkeys(\":history dg\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')",
          "2639:   call assert_equal('\"history debug', @:)",
          "2640:   call feedkeys(\":history se*h\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')",
          "2641:   call assert_equal('\"history se*h', @:)",
          "2643:   \" :language locale name fuzzy completion",
          "2644:   if has('unix')",
          "2645:     set wildoptions&",
          "2646:     call feedkeys(\":lang psx\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')",
          "2647:     call assert_equal('\"lang psx', @:)",
          "2648:     set wildoptions=fuzzy",
          "2649:     call feedkeys(\":lang psx\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')",
          "2650:     call assert_equal('\"lang POSIX', @:)",
          "2651:   endif",
          "2653:   \" :mapclear buffer argument fuzzy completion",
          "2654:   set wildoptions&",
          "2655:   call feedkeys(\":mapclear buf\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')",
          "2656:   call assert_equal('\"mapclear buf', @:)",
          "2657:   set wildoptions=fuzzy",
          "2658:   call feedkeys(\":mapclear buf\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')",
          "2659:   call assert_equal('\"mapclear <buffer>', @:)",
          "2661:   \" map name fuzzy completion - NOT supported",
          "2663:   \" menu name fuzzy completion",
          "2664:   if has('gui_running')",
          "2665:     set wildoptions&",
          "2666:     call feedkeys(\":menu pup\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')",
          "2667:     call assert_equal('\"menu pup', @:)",
          "2668:     set wildoptions=fuzzy",
          "2669:     call feedkeys(\":menu pup\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')",
          "2670:     call assert_equal('\"menu PopUp.', @:)",
          "2671:   endif",
          "2673:   \" :messages suboptions fuzzy completion",
          "2674:   set wildoptions&",
          "2675:   call feedkeys(\":messages clr\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')",
          "2676:   call assert_equal('\"messages clr', @:)",
          "2677:   set wildoptions=fuzzy",
          "2678:   call feedkeys(\":messages clr\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')",
          "2679:   call assert_equal('\"messages clear', @:)",
          "2681:   \" :set option name fuzzy completion",
          "2682:   set wildoptions&",
          "2683:   call feedkeys(\":set brkopt\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')",
          "2684:   call assert_equal('\"set brkopt', @:)",
          "2685:   set wildoptions=fuzzy",
          "2686:   call feedkeys(\":set brkopt\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')",
          "2687:   call assert_equal('\"set breakindentopt', @:)",
          "2688:   set wildoptions&",
          "2689:   call feedkeys(\":set fixeol\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')",
          "2690:   call assert_equal('\"set fixendofline', @:)",
          "2691:   set wildoptions=fuzzy",
          "2692:   call feedkeys(\":set fixeol\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')",
          "2693:   call assert_equal('\"set fixendofline', @:)",
          "2695:   \" :set <term_option>",
          "2696:   set wildoptions&",
          "2697:   call feedkeys(\":set t_E\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')",
          "2698:   call assert_equal('\"set t_EC', @:)",
          "2699:   call feedkeys(\":set <t_E\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')",
          "2700:   call assert_equal('\"set <t_EC>', @:)",
          "2701:   set wildoptions=fuzzy",
          "2702:   call feedkeys(\":set t_E\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')",
          "2703:   call assert_equal('\"set t_EC', @:)",
          "2704:   call feedkeys(\":set <t_E\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')",
          "2705:   call assert_equal('\"set <t_EC>', @:)",
          "2707:   \" :packadd directory name fuzzy completion - NOT supported",
          "2709:   \" shell command name fuzzy completion - NOT supported",
          "2711:   \" :sign suboptions fuzzy completion",
          "2712:   set wildoptions&",
          "2713:   call feedkeys(\":sign ufe\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')",
          "2714:   call assert_equal('\"sign ufe', @:)",
          "2715:   set wildoptions=fuzzy",
          "2716:   call feedkeys(\":sign ufe\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')",
          "2717:   call assert_equal('\"sign undefine', @:)",
          "2719:   \" :syntax suboptions fuzzy completion",
          "2720:   set wildoptions&",
          "2721:   call feedkeys(\":syntax kwd\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')",
          "2722:   call assert_equal('\"syntax kwd', @:)",
          "2723:   set wildoptions=fuzzy",
          "2724:   call feedkeys(\":syntax kwd\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')",
          "2725:   call assert_equal('\"syntax keyword', @:)",
          "2727:   \" syntax group name fuzzy completion",
          "2728:   set wildoptions&",
          "2729:   call feedkeys(\":syntax list mpar\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')",
          "2730:   call assert_equal('\"syntax list mpar', @:)",
          "2731:   set wildoptions=fuzzy",
          "2732:   call feedkeys(\":syntax list mpar\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')",
          "2733:   call assert_equal('\"syntax list MatchParen', @:)",
          "2735:   \" :syntime suboptions fuzzy completion",
          "2736:   if has('profile')",
          "2737:     set wildoptions&",
          "2738:     call feedkeys(\":syntime clr\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')",
          "2739:     call assert_equal('\"syntime clr', @:)",
          "2740:     set wildoptions=fuzzy",
          "2741:     call feedkeys(\":syntime clr\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')",
          "2742:     call assert_equal('\"syntime clear', @:)",
          "2743:   endif",
          "2745:   \" tag name fuzzy completion - NOT supported",
          "2747:   \" tag name and file fuzzy completion - NOT supported",
          "2749:   \" user names fuzzy completion - how to test this functionality?",
          "2751:   \" user defined variable name fuzzy completion",
          "2752:   let g:SomeVariable=10",
          "2753:   set wildoptions&",
          "2754:   call feedkeys(\":let SVar\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')",
          "2755:   call assert_equal('\"let SVar', @:)",
          "2756:   set wildoptions=fuzzy",
          "2757:   call feedkeys(\":let SVar\\<Tab>\\<C-B>\\\"\\<CR>\", 'tx')",
          "2758:   call assert_equal('\"let SomeVariable', @:)",
          "2760:   set wildoptions&",
          "2761:   %bw!",
          "2762: endfunc",
          "",
          "---------------"
        ],
        "src/version.c||src/version.c": [
          "File: src/version.c -> src/version.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "755: static int included_patches[] =",
          "758:     4462,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "758:     4463,",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "c5935a859ee31d56a565878d7a231fc59b7ddc01",
      "candidate_info": {
        "commit_hash": "c5935a859ee31d56a565878d7a231fc59b7ddc01",
        "repo": "vim/vim",
        "commit_url": "https://github.com/vim/vim/commit/c5935a859ee31d56a565878d7a231fc59b7ddc01",
        "files": [
          "src/buffer.c",
          "src/version.c"
        ],
        "message": "patch 8.2.3542: too many comments are old style\n\nProblem:    Too many comments are old style.\nSolution:   Change comments to // style. (closes #9021)",
        "before_after_code_files": [
          "src/buffer.c||src/buffer.c",
          "src/version.c||src/version.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/buffer.c||src/buffer.c",
            "src/version.c||src/version.c"
          ],
          "candidate": [
            "src/buffer.c||src/buffer.c",
            "src/version.c||src/version.c"
          ]
        }
      },
      "candidate_diff": {
        "src/buffer.c||src/buffer.c": [
          "File: src/buffer.c -> src/buffer.c"
        ],
        "src/version.c||src/version.c": [
          "File: src/version.c -> src/version.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "758: static int included_patches[] =",
          "761:     3541,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "761:     3542,",
          "",
          "---------------"
        ]
      }
    }
  ]
}
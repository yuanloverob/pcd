{
  "cve_id": "CVE-2017-0152",
  "cve_desc": "A remote code execution vulnerability exists in the way affected Microsoft scripting engine render when handling objects in memory in Microsoft browsers. The vulnerability could corrupt memory in such a way that an attacker could execute arbitrary code in the context of the current user. An attacker who successfully exploited the vulnerability could gain the same user rights as the current user, aka \"Scripting Engine Memory Corruption Vulnerability.\"",
  "repo": "Microsoft/ChakraCore",
  "patch_hash": "9da019424601325a6e95e6be0fa03d7d21d0b517",
  "patch_info": {
    "commit_hash": "9da019424601325a6e95e6be0fa03d7d21d0b517",
    "repo": "Microsoft/ChakraCore",
    "commit_url": "https://github.com/Microsoft/ChakraCore/commit/9da019424601325a6e95e6be0fa03d7d21d0b517",
    "files": [
      "lib/Parser/Parse.cpp",
      "lib/Runtime/ByteCode/ByteCodeEmitter.cpp",
      "test/es6/default-splitscope.js"
    ],
    "message": "[CVE-2017-0152] MSFT: 10592731 : Issue with Function name capturing in param scope\n\nIn a function expression with name, where the name is captured in one\nof the param scope functions, if there is a function or var declaration\nwith the same name as the function expression name we were marking the\nfunction expression name as shadowed. In non-eval case this causes\nissue because the name symbol won't get added to the body. This change is to\nfix it in such a way if the name is captured in the param scope then we\nsplit the param and body scope such that the name symbol is added to the\nparam scope not body scope.",
    "before_after_code_files": [
      "lib/Parser/Parse.cpp||lib/Parser/Parse.cpp",
      "lib/Runtime/ByteCode/ByteCodeEmitter.cpp||lib/Runtime/ByteCode/ByteCodeEmitter.cpp",
      "test/es6/default-splitscope.js||test/es6/default-splitscope.js"
    ]
  },
  "patch_diff": {
    "lib/Parser/Parse.cpp||lib/Parser/Parse.cpp": [
      "File: lib/Parser/Parse.cpp -> lib/Parser/Parse.cpp",
      "--- Hunk 1 ---",
      "[Context before]",
      "5198:                         paramScope->SetCannotMergeWithBodyScope();",
      "5199:                     }",
      "5200:                 }",
      "5201:             }",
      "5202:         }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "5201:                 if (paramScope->GetCanMergeWithBodyScope() && !fDeclaration && pnodeFnc->sxFnc.pnodeName != nullptr)",
      "5202:                 {",
      "5203:                     Symbol* funcSym = pnodeFnc->sxFnc.pnodeName->sxVar.sym;",
      "5204:                     if (funcSym->GetPid()->GetTopRef()->GetFuncScopeId() > pnodeFnc->sxFnc.functionId)",
      "5205:                     {",
      "5210:                         paramScope->SetCannotMergeWithBodyScope();",
      "5211:                     }",
      "5212:                 }",
      "",
      "---------------"
    ],
    "lib/Runtime/ByteCode/ByteCodeEmitter.cpp||lib/Runtime/ByteCode/ByteCodeEmitter.cpp": [
      "File: lib/Runtime/ByteCode/ByteCodeEmitter.cpp -> lib/Runtime/ByteCode/ByteCodeEmitter.cpp",
      "--- Hunk 1 ---",
      "[Context before]",
      "3319:         {",
      "3322:             paramScope->ForEachSymbol([&](Symbol* param) {",
      "3323:                 Symbol* varSym = funcInfo->GetBodyScope()->FindLocalSymbol(param->GetName());",
      "3324:                 Assert(varSym || pnode->sxFnc.pnodeName->sxVar.sym == param);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "3322:             Symbol* funcSym = funcInfo->root->sxFnc.GetFuncSymbol();",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "3327:                 {",
      "3329:                 }",
      "3331:                 {",
      "",
      "[Removed Lines]",
      "3330:                 else if (varSym && varSym->GetSymbolType() == STVariable && (varSym->IsInSlot(funcInfo) || varSym->GetLocation() != Js::Constants::NoRegister))",
      "",
      "[Added Lines]",
      "3331:                 else if ((funcSym == nullptr || funcSym != param)    // Do not copy the symbol over to body as the function expression symbol",
      "3333:                     && (varSym && varSym->GetSymbolType() == STVariable && (varSym->IsInSlot(funcInfo) || varSym->GetLocation() != Js::Constants::NoRegister)))",
      "",
      "---------------"
    ],
    "test/es6/default-splitscope.js||test/es6/default-splitscope.js": [
      "File: test/es6/default-splitscope.js -> test/es6/default-splitscope.js",
      "--- Hunk 1 ---",
      "[Context before]",
      "159:             return a;",
      "160:         }",
      "161:         assert.areEqual(10, f11()(), \"Recursive call to the function from the body scope returns the right value when eval is there in the body\");",
      "162:     }",
      "163:  },",
      "164:  {",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "163:         function f13() {",
      "164:             var a = function jnvgfg(sfgnmj = function ccunlk() { jnvgfg(undefined, 1); }, b) {",
      "165:                 if (b) {",
      "166:                     assert.areEqual(undefined, jnvgfg, \"This refers to the instance in the body and the value of the function expression is not copied over\");",
      "167:                 }",
      "168:                 var jnvgfg = 10;",
      "169:                 if (!b) {",
      "170:                     sfgnmj();",
      "171:                     return 100;",
      "172:                 }",
      "173:             };",
      "174:             assert.areEqual(100, a(), \"After the recursion the right value is returned by the split scoped function\");",
      "175:         };",
      "176:         f13();",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "e701fc77a1c867ffa90a039fc69cf0b82e401240",
      "candidate_info": {
        "commit_hash": "e701fc77a1c867ffa90a039fc69cf0b82e401240",
        "repo": "Microsoft/ChakraCore",
        "commit_url": "https://github.com/Microsoft/ChakraCore/commit/e701fc77a1c867ffa90a039fc69cf0b82e401240",
        "files": [
          "lib/Backend/Lower.cpp"
        ],
        "message": "[CVE-2017-0151] fix issue with using wrong size reg when lowering bound check",
        "before_after_code_files": [
          "lib/Backend/Lower.cpp||lib/Backend/Lower.cpp"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/chakra-core/ChakraCore/pull/2697"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "lib/Backend/Lower.cpp||lib/Backend/Lower.cpp": [
          "File: lib/Backend/Lower.cpp -> lib/Backend/Lower.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "12848:         Assert(!offsetOpnd || offsetOpnd->GetValue() == offset);",
          "12850:         autoReuseAddResultOpnd.Initialize(addResultOpnd, func);",
          "12851:         InsertAdd(",
          "12852:             true,",
          "12853:             addResultOpnd,",
          "12854:             rightOpnd,",
          "12856:             insertBeforeInstr);",
          "12857:         InsertBranch(LowererMD::MDOverflowBranchOpcode, bailOutLabel, insertBeforeInstr);",
          "",
          "[Removed Lines]",
          "12849:         IR::RegOpnd *const addResultOpnd = IR::RegOpnd::New(TyMachReg, func);",
          "12855:             offsetOpnd ? offsetOpnd->UseWithNewType(TyMachReg, func) : IR::IntConstOpnd::New(offset, TyMachReg, func, true),",
          "",
          "[Added Lines]",
          "12849:         IR::RegOpnd *const addResultOpnd = IR::RegOpnd::New(TyInt32, func);",
          "12855:             offsetOpnd ? offsetOpnd->UseWithNewType(TyInt32, func) : IR::IntConstOpnd::New(offset, TyInt32, func, true),",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "fb08c4d98775977297c3c44e6b804fb770b41f4d",
      "candidate_info": {
        "commit_hash": "fb08c4d98775977297c3c44e6b804fb770b41f4d",
        "repo": "Microsoft/ChakraCore",
        "commit_url": "https://github.com/Microsoft/ChakraCore/commit/fb08c4d98775977297c3c44e6b804fb770b41f4d",
        "files": [
          "lib/Runtime/Library/ArrayBuffer.cpp"
        ],
        "message": "ArrayBuffer.Transfer needs Detached ArrayBuffer check",
        "before_after_code_files": [
          "lib/Runtime/Library/ArrayBuffer.cpp||lib/Runtime/Library/ArrayBuffer.cpp"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/chakra-core/ChakraCore/pull/2697"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "lib/Runtime/Library/ArrayBuffer.cpp||lib/Runtime/Library/ArrayBuffer.cpp": [
          "File: lib/Runtime/Library/ArrayBuffer.cpp -> lib/Runtime/Library/ArrayBuffer.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "292:         if (args.Info.Count >= 3)",
          "293:         {",
          "294:             newBufferLength = ToIndex(args[2], JSERR_ArrayLengthConstructIncorrect, scriptContext, MaxArrayBufferLength);",
          "295:         }",
          "297:         return arrayBuffer->TransferInternal(newBufferLength);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "297:             if (arrayBuffer->IsDetached())",
          "298:             {",
          "299:                 JavascriptError::ThrowTypeError(scriptContext, JSERR_DetachedTypedArray, _u(\"ArrayBuffer.transfer\"));",
          "300:             }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "05af363cd3ff6d5558615bff235356c316936d44",
      "candidate_info": {
        "commit_hash": "05af363cd3ff6d5558615bff235356c316936d44",
        "repo": "Microsoft/ChakraCore",
        "commit_url": "https://github.com/Microsoft/ChakraCore/commit/05af363cd3ff6d5558615bff235356c316936d44",
        "files": [
          "lib/Runtime/Library/JavascriptArray.cpp"
        ],
        "message": "add few missing CopyOnAccessNativeIntArray conversions",
        "before_after_code_files": [
          "lib/Runtime/Library/JavascriptArray.cpp||lib/Runtime/Library/JavascriptArray.cpp"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/chakra-core/ChakraCore/pull/2697"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "lib/Runtime/Library/JavascriptArray.cpp||lib/Runtime/Library/JavascriptArray.cpp": [
          "File: lib/Runtime/Library/JavascriptArray.cpp -> lib/Runtime/Library/JavascriptArray.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "9841:                 if (JavascriptArray::Is(newObj))",
          "9842:                 {",
          "9843:                     newArr = JavascriptArray::FromVar(newObj);",
          "9844:                 }",
          "9845:             }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "9843: #if ENABLE_COPYONACCESS_ARRAY",
          "9844:                     JavascriptLibrary::CheckAndConvertCopyOnAccessNativeIntArray<Var>(newObj);",
          "9845: #endif",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "9891:                 if (JavascriptArray::Is(newObj))",
          "9892:                 {",
          "9893:                     newArr = JavascriptArray::FromVar(newObj);",
          "9894:                 }",
          "9895:             }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "9896: #if ENABLE_COPYONACCESS_ARRAY",
          "9897:                     JavascriptLibrary::CheckAndConvertCopyOnAccessNativeIntArray<Var>(newObj);",
          "9898: #endif",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "10001:             if (JavascriptArray::Is(newObj))",
          "10002:             {",
          "10003:                 newArr = JavascriptArray::FromVar(newObj);",
          "10004:             }",
          "10005:             else if (TypedArrayBase::Is(newObj))",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "10009: #if ENABLE_COPYONACCESS_ARRAY",
          "10010:                 JavascriptLibrary::CheckAndConvertCopyOnAccessNativeIntArray<Var>(newObj);",
          "10011: #endif",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "b7854cdc7b54251868163ce33327de6158dd8bea",
      "candidate_info": {
        "commit_hash": "b7854cdc7b54251868163ce33327de6158dd8bea",
        "repo": "Microsoft/ChakraCore",
        "commit_url": "https://github.com/Microsoft/ChakraCore/commit/b7854cdc7b54251868163ce33327de6158dd8bea",
        "files": [
          "lib/Runtime/Language/AsmJsModule.cpp"
        ],
        "message": "[CVE-2017-0035] Asm.Js: Assign function number in order using internal list instead of parse node index.",
        "before_after_code_files": [
          "lib/Runtime/Language/AsmJsModule.cpp||lib/Runtime/Language/AsmJsModule.cpp"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/chakra-core/ChakraCore/pull/2697"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "lib/Runtime/Language/AsmJsModule.cpp||lib/Runtime/Language/AsmJsModule.cpp": [
          "File: lib/Runtime/Language/AsmJsModule.cpp -> lib/Runtime/Language/AsmJsModule.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "1086:         {",
          "1087:             if( DefineIdentifier( name, func ) )",
          "1088:             {",
          "1092:                 return func;",
          "1093:             }",
          "",
          "[Removed Lines]",
          "1089:                 func->SetFunctionIndex( pnodeFnc->sxFnc.nestedIndex );",
          "1091:                 mFunctionArray.SetItem( func->GetFunctionIndex(), func );",
          "",
          "[Added Lines]",
          "1089:                 uint index = (uint)mFunctionArray.Count();",
          "1090:                 if (pnodeFnc->sxFnc.nestedIndex != index)",
          "1091:                 {",
          "1092:                     return nullptr;",
          "1093:                 }",
          "1094:                 func->SetFunctionIndex( (RegSlot)index );",
          "1095:                 mFunctionArray.Add( func );",
          "1096:                 Assert(index + 1 == (uint)mFunctionArray.Count());",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "c30253bd38e1f49cbfef0e8b39fe4299f0d42d3d",
      "candidate_info": {
        "commit_hash": "c30253bd38e1f49cbfef0e8b39fe4299f0d42d3d",
        "repo": "Microsoft/ChakraCore",
        "commit_url": "https://github.com/Microsoft/ChakraCore/commit/c30253bd38e1f49cbfef0e8b39fe4299f0d42d3d",
        "files": [
          "test/es6/proxybugs.js"
        ],
        "message": "Add test for proxy type confusion",
        "before_after_code_files": [
          "test/es6/proxybugs.js||test/es6/proxybugs.js"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/chakra-core/ChakraCore/pull/2697"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "test/es6/proxybugs.js||test/es6/proxybugs.js": [
          "File: test/es6/proxybugs.js -> test/es6/proxybugs.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "6: WScript.LoadScriptFile(\"..\\\\UnitTestFramework\\\\UnitTestFramework.js\");",
          "8: var tests = [",
          "9:     {",
          "10:         name: \"Setting proxy object on Map and WeakMap\",",
          "11:         body() {",
          "12:             [WeakMap, Map].forEach(function(ctor) {",
          "13:                 var target = {};",
          "14:                 let p = new Proxy(target, {});",
          "15:                 let map = new ctor();",
          "16:                 map.set(p, 101);",
          "17:                 assert.areEqual(map.get(p), 101, ctor.name + \" map should be able to set and get the proxy object\");",
          "18:                 p.x = 20;",
          "19:                 assert.areEqual(target.x, 20, \"target object should work as expected even after proxy object is added to map\");",
          "20:             });",
          "21:         }",
          "22:     },",
          "23:     {",
          "24:         name: \"Setting proxy object on Map and WeakMap - multiple sets and delete\",",
          "25:         body() {",
          "26:             [WeakMap, Map].forEach(function(ctor) {",
          "27:                 var target = {};",
          "28:                 let p = new Proxy(target, {});",
          "29:                 let map = new ctor();",
          "30:                 map.set(p, 101);",
          "31:                 assert.areEqual(map.get(p), 101);",
          "32:                 map.delete(p);",
          "33:                 assert.areEqual(map.get(p), undefined, ctor.name + \" map can remove the proxy object properly\");",
          "34:                 map.set(p, 102);",
          "35:                 assert.areEqual(map.get(p), 102, ctor.name + \" proxy object can be set again and it returns 102\");",
          "36:                 p.x = 20;",
          "37:                 assert.areEqual(target.x, 20, \"target object should work as expected even after proxy object is added to map\");",
          "38:             });",
          "39:         }",
          "40:     },",
          "41:     {",
          "42:         name: \"Assertion validation : returning descriptor during getOwnPropertyDescriptor should not pollute the descriptor\",",
          "43:         body() {",
          "44:             var target = {};",
          "45:             var handler = {};",
          "46:             var getOwnPropertyDescriptorCalled = false;",
          "47:             handler['defineProperty'] = function () {",
          "48:                 assert.fail(\"This function will not be called as 'getOwnPropertyDescriptor' will add accessor\");",
          "49:             };",
          "51:             handler['getOwnPropertyDescriptor'] = function (t, property) {",
          "52:                 getOwnPropertyDescriptorCalled = true;",
          "53:                 Object.defineProperty(t, 'abc', { set: function () { } });",
          "54:                 return Reflect.getOwnPropertyDescriptor(t, property);",
          "55:             };",
          "57:             var proxy = new Proxy(target, handler);",
          "58:             proxy.abc = undefined;",
          "59:             assert.isTrue(getOwnPropertyDescriptorCalled);",
          "60:         }",
          "61:     },",
          "62:     {",
          "63:         name: \"Assertion validation : returning descriptor with writable false should not defineProperty again.\",",
          "64:         body() {",
          "65:             var target = {};",
          "66:             var handler = {};",
          "67:             var getOwnPropertyDescriptorCalled = false;",
          "68:             handler['defineProperty'] = function () {",
          "69:                 assert.fail(\"This function will not be called as 'getOwnPropertyDescriptor' will add property with writable false\");",
          "70:             };",
          "72:             handler['getOwnPropertyDescriptor'] = function (t, property) {",
          "73:                 getOwnPropertyDescriptorCalled = true;",
          "74:                 Object.defineProperty(t, 'abc', { value : 1, writable : false });",
          "75:                 return Reflect.getOwnPropertyDescriptor(t, property);",
          "76:             };",
          "78:             var proxy = new Proxy(target, handler);",
          "79:             proxy.abc = undefined;",
          "80:             assert.isTrue(getOwnPropertyDescriptorCalled);",
          "81:         }",
          "82:     },",
          "83:     {",
          "84:         name: \"No property found at getOwnPropertyDescriptor will call defineProperty\",",
          "85:         body() {",
          "86:             var target = {};",
          "87:             var handler = {};",
          "88:             var definePropertyCalled = false;",
          "89:             var getOwnPropertyDescriptorCalled = false;",
          "90:             handler['defineProperty'] = function () {",
          "91:                 definePropertyCalled = true;",
          "92:             };",
          "94:             handler['getOwnPropertyDescriptor'] = function (t, property) {",
          "95:                 getOwnPropertyDescriptorCalled = true;",
          "96:                 return Reflect.getOwnPropertyDescriptor(t, property);",
          "97:             };",
          "99:             var proxy = new Proxy(target, handler);",
          "100:             proxy.abc = undefined;",
          "101:             assert.isTrue(definePropertyCalled);",
          "102:             assert.isTrue(getOwnPropertyDescriptorCalled);",
          "103:         }",
          "104:     }",
          "105: ];",
          "107: testRunner.runTests(tests, { verbose: WScript.Arguments[0] != \"summary\" });",
          "",
          "[Added Lines]",
          "6: WScript.LoadScriptFile(\"..\\\\UnitTestFramework\\\\UnitTestFramework.js\");",
          "8: var tests = [",
          "9:     {",
          "10:         name: \"Setting proxy object on Map and WeakMap\",",
          "11:         body() {",
          "12:             [WeakMap, Map].forEach(function(ctor) {",
          "13:                 var target = {};",
          "14:                 let p = new Proxy(target, {});",
          "15:                 let map = new ctor();",
          "16:                 map.set(p, 101);",
          "17:                 assert.areEqual(map.get(p), 101, ctor.name + \" map should be able to set and get the proxy object\");",
          "18:                 p.x = 20;",
          "19:                 assert.areEqual(target.x, 20, \"target object should work as expected even after proxy object is added to map\");",
          "20:             });",
          "21:         }",
          "22:     },",
          "23:     {",
          "24:         name: \"Setting proxy object on Map and WeakMap - multiple sets and delete\",",
          "25:         body() {",
          "26:             [WeakMap, Map].forEach(function(ctor) {",
          "27:                 var target = {};",
          "28:                 let p = new Proxy(target, {});",
          "29:                 let map = new ctor();",
          "30:                 map.set(p, 101);",
          "31:                 assert.areEqual(map.get(p), 101);",
          "32:                 map.delete(p);",
          "33:                 assert.areEqual(map.get(p), undefined, ctor.name + \" map can remove the proxy object properly\");",
          "34:                 map.set(p, 102);",
          "35:                 assert.areEqual(map.get(p), 102, ctor.name + \" proxy object can be set again and it returns 102\");",
          "36:                 p.x = 20;",
          "37:                 assert.areEqual(target.x, 20, \"target object should work as expected even after proxy object is added to map\");",
          "38:             });",
          "39:         }",
          "40:     },",
          "41:     {",
          "42:         name: \"Assertion validation : returning descriptor during getOwnPropertyDescriptor should not pollute the descriptor\",",
          "43:         body() {",
          "44:             var target = {};",
          "45:             var handler = {};",
          "46:             var getOwnPropertyDescriptorCalled = false;",
          "47:             handler['defineProperty'] = function () {",
          "48:                 assert.fail(\"This function will not be called as 'getOwnPropertyDescriptor' will add accessor\");",
          "49:             };",
          "51:             handler['getOwnPropertyDescriptor'] = function (t, property) {",
          "52:                 getOwnPropertyDescriptorCalled = true;",
          "53:                 Object.defineProperty(t, 'abc', { set: function () { } });",
          "54:                 return Reflect.getOwnPropertyDescriptor(t, property);",
          "55:             };",
          "57:             var proxy = new Proxy(target, handler);",
          "58:             proxy.abc = undefined;",
          "59:             assert.isTrue(getOwnPropertyDescriptorCalled);",
          "60:         }",
          "61:     },",
          "62:     {",
          "63:         name: \"Assertion validation : returning descriptor with writable false should not defineProperty again.\",",
          "64:         body() {",
          "65:             var target = {};",
          "66:             var handler = {};",
          "67:             var getOwnPropertyDescriptorCalled = false;",
          "68:             handler['defineProperty'] = function () {",
          "69:                 assert.fail(\"This function will not be called as 'getOwnPropertyDescriptor' will add property with writable false\");",
          "70:             };",
          "72:             handler['getOwnPropertyDescriptor'] = function (t, property) {",
          "73:                 getOwnPropertyDescriptorCalled = true;",
          "74:                 Object.defineProperty(t, 'abc', { value : 1, writable : false });",
          "75:                 return Reflect.getOwnPropertyDescriptor(t, property);",
          "76:             };",
          "78:             var proxy = new Proxy(target, handler);",
          "79:             proxy.abc = undefined;",
          "80:             assert.isTrue(getOwnPropertyDescriptorCalled);",
          "81:         }",
          "82:     },",
          "83:     {",
          "84:         name: \"No property found at getOwnPropertyDescriptor will call defineProperty\",",
          "85:         body() {",
          "86:             var target = {};",
          "87:             var handler = {};",
          "88:             var definePropertyCalled = false;",
          "89:             var getOwnPropertyDescriptorCalled = false;",
          "90:             handler['defineProperty'] = function () {",
          "91:                 definePropertyCalled = true;",
          "92:             };",
          "94:             handler['getOwnPropertyDescriptor'] = function (t, property) {",
          "95:                 getOwnPropertyDescriptorCalled = true;",
          "96:                 return Reflect.getOwnPropertyDescriptor(t, property);",
          "97:             };",
          "99:             var proxy = new Proxy(target, handler);",
          "100:             proxy.abc = undefined;",
          "101:             assert.isTrue(definePropertyCalled);",
          "102:             assert.isTrue(getOwnPropertyDescriptorCalled);",
          "103:         }",
          "104:     },",
          "105:     {",
          "106:         name: \"Type confusion in JavascriptProxy::SetPropertyTrap when using a Symbol\",",
          "107:         body: function () {",
          "108:             try{ Reflect.set((new Proxy({}, {has: function(){ return true; }})), 'abc', 0x44444444, new Uint32Array); } catch(e){}",
          "109:             try{ Reflect.set((new Proxy({}, {has: function(){ return true; }})), 'abc', 0x44444444, new Uint32Array); } catch(e){}",
          "111:             var obj1 = Object.create(new Proxy({}, {}));",
          "112:             obj1[Symbol.species] = 0;",
          "113:         }",
          "114:     }",
          "115: ];",
          "117: testRunner.runTests(tests, { verbose: WScript.Arguments[0] != \"summary\" });",
          "",
          "---------------"
        ]
      }
    }
  ]
}
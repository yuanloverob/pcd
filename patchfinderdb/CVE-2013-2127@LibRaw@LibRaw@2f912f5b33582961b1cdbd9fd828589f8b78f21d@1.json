{
  "cve_id": "CVE-2013-2127",
  "cve_desc": "Buffer overflow in the exposure correction code in LibRaw before 0.15.1 allows context-dependent attackers to cause a denial of service (crash) and possibly execute arbitrary code via unspecified vectors.",
  "repo": "LibRaw/LibRaw",
  "patch_hash": "2f912f5b33582961b1cdbd9fd828589f8b78f21d",
  "patch_info": {
    "commit_hash": "2f912f5b33582961b1cdbd9fd828589f8b78f21d",
    "repo": "LibRaw/LibRaw",
    "commit_url": "https://github.com/LibRaw/LibRaw/commit/2f912f5b33582961b1cdbd9fd828589f8b78f21d",
    "files": [
      "src/libraw_cxx.cpp"
    ],
    "message": "fixed wrong data_maximum calcluation; prevent out-of-buffer in exp_bef",
    "before_after_code_files": [
      "src/libraw_cxx.cpp||src/libraw_cxx.cpp"
    ]
  },
  "patch_diff": {
    "src/libraw_cxx.cpp||src/libraw_cxx.cpp": [
      "File: src/libraw_cxx.cpp -> src/libraw_cxx.cpp",
      "--- Hunk 1 ---",
      "[Context before]",
      "2336: #define MAX(a,b) ((a) > (b) ? (a) : (b))",
      "2337: #define LIM(x,min,max) MAX(min,MIN(x,max))",
      "2338: #define CLIP(x) LIM(x,0,65535)",
      "2341:               {",
      "2342:                 int val = imgdata.image[0][i];",
      "2343:                 val -= cblk[i & 3];",
      "2344:                 imgdata.image[0][i] = CLIP(val);",
      "2346:               }",
      "2347: #undef MIN",
      "2348: #undef MAX",
      "2349: #undef LIM",
      "",
      "[Removed Lines]",
      "2340:             for(i=0; i< size*4; i++)",
      "2345:                 if(C.data_maximum < val) C.data_maximum = val;",
      "",
      "[Added Lines]",
      "2339:    int dmax = 0;",
      "2340:    for(i=0; i< size*4; i++)",
      "2345:                 if(dmax < val) dmax = val;",
      "2347:    C.data_maximum = dmax & 0xffff;",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "2360:           int idx;",
      "2361:           ushort *p = (ushort*)imgdata.image;",
      "2363:           for(idx=0;idx<S.iheight*S.iwidth*4;idx++)",
      "2365:         }",
      "2366:   return 0;",
      "2367:  }",
      "",
      "[Removed Lines]",
      "2362:           C.data_maximum = 0;",
      "2364:             if(C.data_maximum < p[idx]) C.data_maximum = p[idx];",
      "",
      "[Added Lines]",
      "2363:     int dmax = 0;",
      "2365:             if(dmax < p[idx]) dmax = p[idx];",
      "2366:     C.data_maximum = dmax;",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "2421:             imgdata.image[i][3] = lut[imgdata.image[i][3]];",
      "2422:         }",
      "2427:     free(lut);",
      "2428: }",
      "",
      "[Removed Lines]",
      "2424:     C.data_maximum = lut[C.data_maximum];",
      "2425:     C.maximum = lut[C.maximum];",
      "",
      "[Added Lines]",
      "2426:  if(C.data_maximum <=TBLN)",
      "2427:   C.data_maximum = lut[C.data_maximum];",
      "2428:  if(C.maximum <= TBLN)",
      "2429:   C.maximum = lut[C.maximum];",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "2531:         raw2image_ex(subtract_inline); // allocate imgdata.image and copy data!",
      "2535:         if (IO.zero_is_bad)",
      "2536:           {",
      "",
      "[Removed Lines]",
      "2533:         int save_4color = O.four_color_rgb;",
      "",
      "[Added Lines]",
      "2537:   int save_4color = O.four_color_rgb;",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "530bbbc41b82c630352d476d747f381e6cf59373",
      "candidate_info": {
        "commit_hash": "530bbbc41b82c630352d476d747f381e6cf59373",
        "repo": "LibRaw/LibRaw",
        "commit_url": "https://github.com/LibRaw/LibRaw/commit/530bbbc41b82c630352d476d747f381e6cf59373",
        "files": [
          "Changelog.txt",
          "dcraw/dcraw.c",
          "internal/dcraw_common.cpp",
          "internal/dcraw_fileio.cpp",
          "src/libraw_cxx.cpp"
        ],
        "message": "openmp AHD and wavelet denoise",
        "before_after_code_files": [
          "dcraw/dcraw.c||dcraw/dcraw.c",
          "internal/dcraw_common.cpp||internal/dcraw_common.cpp",
          "internal/dcraw_fileio.cpp||internal/dcraw_fileio.cpp",
          "src/libraw_cxx.cpp||src/libraw_cxx.cpp"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/libraw_cxx.cpp||src/libraw_cxx.cpp"
          ],
          "candidate": [
            "src/libraw_cxx.cpp||src/libraw_cxx.cpp"
          ]
        }
      },
      "candidate_diff": {
        "dcraw/dcraw.c||dcraw/dcraw.c": [
          "File: dcraw/dcraw.c -> dcraw/dcraw.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "4069:     temp[i] = 2*base[st*i] + base[st*(i-sc)] + base[st*(2*size-2-(i+sc))];",
          "4070: }",
          "4072: void CLASS wavelet_denoise()",
          "4073: {",
          "4074:   float *fimg=0, *temp, thold, mul[2], avg, diff;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4072: #if !defined(LIBRAW_USE_OPENMP)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "4148:   }",
          "4149:   free (fimg);",
          "4150: }",
          "4153: void CLASS green_matching()",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4153: void CLASS wavelet_denoise()",
          "4154: {",
          "4155:   float *fimg=0, *temp, thold, mul[2], avg, diff;",
          "4156:    int scale=1, size, lev, hpass, lpass, row, col, nc, c, i, wlast, blk[2];",
          "4157:   ushort *window[4];",
          "4158:   static const float noise[] =",
          "4159:   { 0.8002,0.2735,0.1202,0.0585,0.0291,0.0152,0.0080,0.0044 };",
          "4161: #ifdef DCRAW_VERBOSE",
          "4162:   if (verbose) fprintf (stderr,_(\"Wavelet denoising...\\n\"));",
          "4163: #endif",
          "4165:   while (maximum << scale < 0x10000) scale++;",
          "4166:   maximum <<= --scale;",
          "4167:   black <<= scale;",
          "4168:   FORC4 cblack[c] <<= scale;",
          "4169:   if ((size = iheight*iwidth) < 0x15550000)",
          "4170:     fimg = (float *) malloc ((size*3 + iheight + iwidth) * sizeof *fimg);",
          "4171:   merror (fimg, \"wavelet_denoise()\");",
          "4172:   temp = fimg + size*3;",
          "4173:   if ((nc = colors) == 3 && filters) nc++;",
          "4174: #ifdef LIBRAW_LIBRARY_BUILD",
          "4175: #pragma omp parallel default(shared) private(i,col,row,thold,lev,lpass,hpass,temp,c) firstprivate(scale,size)",
          "4176: #endif",
          "4177:   {",
          "4178:       temp = (float*)malloc( (iheight + iwidth) * sizeof *fimg);",
          "4180: #ifdef LIBRAW_LIBRARY_BUILD",
          "4181: #pragma omp for",
          "4182: #endif",
          "4183:       for (i=0; i < size; i++)",
          "4184:         fimg[i] = 256 * sqrt((double)(image[i][c] << scale));",
          "4185:       for (hpass=lev=0; lev < 5; lev++) {",
          "4186:  lpass = size*((lev & 1)+1);",
          "4187: #ifdef LIBRAW_LIBRARY_BUILD",
          "4188: #pragma omp for",
          "4189: #endif",
          "4190:  for (row=0; row < iheight; row++) {",
          "4191:    hat_transform (temp, fimg+hpass+row*iwidth, 1, iwidth, 1 << lev);",
          "4192:    for (col=0; col < iwidth; col++)",
          "4193:      fimg[lpass + row*iwidth + col] = temp[col] * 0.25;",
          "4194:  }",
          "4195: #ifdef LIBRAW_LIBRARY_BUILD",
          "4196: #pragma omp for",
          "4197: #endif",
          "4198:  for (col=0; col < iwidth; col++) {",
          "4199:    hat_transform (temp, fimg+lpass+col, iwidth, iheight, 1 << lev);",
          "4200:    for (row=0; row < iheight; row++)",
          "4201:      fimg[lpass + row*iwidth + col] = temp[row] * 0.25;",
          "4202:  }",
          "4203:  thold = threshold * noise[lev];",
          "4204: #ifdef LIBRAW_LIBRARY_BUILD",
          "4205: #pragma omp for",
          "4206: #endif",
          "4207:  for (i=0; i < size; i++) {",
          "4208:    fimg[hpass+i] -= fimg[lpass+i];",
          "4209:    if (fimg[hpass+i] < -thold) fimg[hpass+i] += thold;",
          "4210:    else if (fimg[hpass+i] >  thold) fimg[hpass+i] -= thold;",
          "4211:    else  fimg[hpass+i] = 0;",
          "4212:    if (hpass) fimg[i] += fimg[hpass+i];",
          "4213:  }",
          "4214:  hpass = lpass;",
          "4215:       }",
          "4216: #ifdef LIBRAW_LIBRARY_BUILD",
          "4217: #pragma omp for",
          "4218: #endif",
          "4219:       for (i=0; i < size; i++)",
          "4220:  image[i][c] = CLIP(SQR(fimg[i]+fimg[lpass+i])/0x10000);",
          "4221:     }",
          "4222:     free(temp);",
          "4229:    for (row=0; row < 2; row++){",
          "4230:       mul[row] = 0.125 * pre_mul[FC(row+1,0) | 1] / pre_mul[FC(row,0) | 1];",
          "4231:       blk[row] = cblack[FC(row,0) | 1];",
          "4232:    }",
          "4233:     for (i=0; i < 4; i++)",
          "4234:       window[i] = (ushort *) fimg + width*i;",
          "4235:     for (wlast=-1, row=1; row < height-1; row++) {",
          "4236:       while (wlast < row+1) {",
          "4237:  for (wlast++, i=0; i < 4; i++)",
          "4238:    window[(i+3) & 3] = window[i];",
          "4239:  for (col = FC(wlast,1) & 1; col < width; col+=2)",
          "4240:    window[2][col] = BAYER(wlast,col);",
          "4241:       }",
          "4242:       thold = threshold/512;",
          "4243:       for (col = (FC(row,0) & 1)+1; col < width-1; col+=2) {",
          "4244:  avg = ( window[0][col-1] + window[0][col+1] +",
          "4245:   window[2][col-1] + window[2][col+1] - blk[~row & 1]*4 )",
          "4247:  avg = avg < 0 ? 0 : sqrt(avg);",
          "4248:  diff = sqrt((double)BAYER(row,col)) - avg;",
          "4249:  if      (diff < -thold) diff += thold;",
          "4250:  else if (diff >  thold) diff -= thold;",
          "4251:  else diff = 0;",
          "4252:  BAYER(row,col) = CLIP(SQR(avg+diff) + 0.5);",
          "4253:       }",
          "4254:     }",
          "4255:   }",
          "4256:   free (fimg);",
          "4257: }",
          "4259: #endif",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "4651:     }",
          "4652: }",
          "4655:    Adaptive Homogeneity-Directed interpolation is based on",
          "4656:    the work of Keigo Hirakawa, Thomas Parks, and Paul Lee.",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4763: #ifndef LIBRAW_LIBRARY_BUILD",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "4783:   free (buffer);",
          "4784: }",
          "4785: #undef TS",
          "4787: void CLASS median_filter()",
          "4788: {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4896: #else",
          "4898: static float dcraw_cbrt[0x10000] = {-1.0f};",
          "4900: static inline float calc_64cbrt(float f)",
          "4901: {",
          "4902:   unsigned u;",
          "4903:   static float lower = dcraw_cbrt[0];",
          "4904:   static float upper = dcraw_cbrt[0xffff];",
          "4906:   if (f <= 0) {",
          "4907:     return lower;",
          "4908:   }",
          "4910:   u = (unsigned) f;",
          "4911:   if (u >= 0xffff) {",
          "4912:     return upper;",
          "4913:   }",
          "4914:   return dcraw_cbrt[u];",
          "4915: }",
          "4916: void CLASS ahd_interpolate_green_h_and_v(int top, int left, ushort (*out_rgb)[TS][TS][3])",
          "4917: {",
          "4918:   int row, col;",
          "4919:   int c, val;",
          "4920:   ushort (*pix)[4];",
          "4921:   const int rowlimit = MIN(top+TS, height-2);",
          "4922:   const int collimit = MIN(left+TS, width-2);",
          "4924:   for (row = top; row < rowlimit; row++) {",
          "4925:     col = left + (FC(row,left) & 1);",
          "4926:     for (c = FC(row,col); col < collimit; col+=2) {",
          "4927:       pix = image + row*width+col;",
          "4928:       val = ((pix[-1][1] + pix[0][c] + pix[1][1]) * 2",
          "4929:             - pix[-2][c] - pix[2][c]) >> 2;",
          "4930:       out_rgb[0][row-top][col-left][1] = ULIM(val,pix[-1][1],pix[1][1]);",
          "4931:       val = ((pix[-width][1] + pix[0][c] + pix[width][1]) * 2",
          "4932:             - pix[-2*width][c] - pix[2*width][c]) >> 2;",
          "4933:       out_rgb[1][row-top][col-left][1] = ULIM(val,pix[-width][1],pix[width][1]);",
          "4934:     }",
          "4935:   }",
          "4936: }",
          "4937: void CLASS ahd_interpolate_r_and_b_in_rgb_and_convert_to_cielab(int top, int left, ushort (*inout_rgb)[TS][3], short (*out_lab)[TS][3], const float (&xyz_cam)[3][4])",
          "4938: {",
          "4939:   unsigned row, col;",
          "4940:   int c, val;",
          "4941:   ushort (*pix)[4];",
          "4942:   ushort (*rix)[3];",
          "4943:   short (*lix)[3];",
          "4944:   float xyz[3];",
          "4945:   const unsigned num_pix_per_row = 4*width;",
          "4946:   const unsigned rowlimit = MIN(top+TS-1, height-3);",
          "4947:   const unsigned collimit = MIN(left+TS-1, width-3);",
          "4948:   ushort *pix_above;",
          "4949:   ushort *pix_below;",
          "4950:   int t1, t2;",
          "4952:   for (row = top+1; row < rowlimit; row++) {",
          "4953:     pix = image + row*width + left;",
          "4954:     rix = &inout_rgb[row-top][0];",
          "4955:     lix = &out_lab[row-top][0];",
          "4957:     for (col = left+1; col < collimit; col++) {",
          "4958:       pix++;",
          "4959:       pix_above = &pix[0][0] - num_pix_per_row;",
          "4960:       pix_below = &pix[0][0] + num_pix_per_row;",
          "4961:       rix++;",
          "4962:       lix++;",
          "4964:       c = 2 - FC(row, col);",
          "4966:       if (c == 1) {",
          "4967:         c = FC(row+1,col);",
          "4968:  t1 = 2-c;",
          "4969:         val = pix[0][1] + (( pix[-1][t1] + pix[1][t1]",
          "4970:               - rix[-1][1] - rix[1][1] ) >> 1);",
          "4971:         rix[0][t1] = CLIP(val);",
          "4972:         val = pix[0][1] + (( pix_above[c] + pix_below[c]",
          "4973:               - rix[-TS][1] - rix[TS][1] ) >> 1);",
          "4974:       } else {",
          "4977:         val = rix[0][1] + (( pix_above[t1] + pix_above[t2]",
          "4978:               + pix_below[t1] + pix_below[t2]",
          "4979:               - rix[-TS-1][1] - rix[-TS+1][1]",
          "4980:               - rix[+TS-1][1] - rix[+TS+1][1] + 1) >> 2);",
          "4981:       }",
          "4982:       rix[0][c] = CLIP(val);",
          "4983:       c = FC(row,col);",
          "4984:       rix[0][c] = pix[0][c];",
          "4985:       xyz[0] = xyz[1] = xyz[2] = 0.5;",
          "4986:       FORC3 {",
          "4991:         xyz[0] += xyz_cam[0][c] * rix[0][c];",
          "4992:         xyz[1] += xyz_cam[1][c] * rix[0][c];",
          "4993:         xyz[2] += xyz_cam[2][c] * rix[0][c];",
          "4994:       }",
          "4995:       FORC3 {",
          "4996:  xyz[c] = calc_64cbrt(xyz[c]);",
          "4997:       }",
          "4998:       lix[0][0] = (116 * xyz[1] - 16);",
          "4999:       lix[0][1] = 500 * (xyz[0] - xyz[1]);",
          "5000:       lix[0][2] = 200 * (xyz[1] - xyz[2]);",
          "5001:     }",
          "5002:   }",
          "5003: }",
          "5004: void CLASS ahd_interpolate_r_and_b_and_convert_to_cielab(int top, int left, ushort (*inout_rgb)[TS][TS][3], short (*out_lab)[TS][TS][3], const float (&xyz_cam)[3][4])",
          "5005: {",
          "5006:   int direction;",
          "5007:   for (direction = 0; direction < 2; direction++) {",
          "5008:     ahd_interpolate_r_and_b_in_rgb_and_convert_to_cielab(top, left, inout_rgb[direction], out_lab[direction], xyz_cam);",
          "5009:   }",
          "5010: }",
          "5011: void CLASS ahd_interpolate_build_homogeneity_map(int top, int left, short (*lab)[TS][TS][3], char (*out_homogeneity_map)[TS][2])",
          "5012: {",
          "5013:   int row, col;",
          "5014:   int tr, tc;",
          "5015:   int direction;",
          "5016:   int i;",
          "5017:   short (*lix)[3];",
          "5018:   short (*lixs[2])[3];",
          "5019:   short *adjacent_lix;",
          "5020:   unsigned ldiff[2][4], abdiff[2][4], leps, abeps;",
          "5021:   static const int dir[4] = { -1, 1, -TS, TS };",
          "5022:   const int rowlimit = MIN(top+TS-2, height-4);",
          "5023:   const int collimit = MIN(left+TS-2, width-4);",
          "5024:   int homogeneity;",
          "5025:   char (*homogeneity_map_p)[2];",
          "5027:   memset (out_homogeneity_map, 0, 2*TS*TS);",
          "5029:   for (row=top+2; row < rowlimit; row++) {",
          "5030:     tr = row-top;",
          "5031:     homogeneity_map_p = &out_homogeneity_map[tr][1];",
          "5032:     for (direction=0; direction < 2; direction++) {",
          "5033:       lixs[direction] = &lab[direction][tr][1];",
          "5034:     }",
          "5036:     for (col=left+2; col < collimit; col++) {",
          "5037:       tc = col-left;",
          "5038:       homogeneity_map_p++;",
          "5040:       for (direction=0; direction < 2; direction++) {",
          "5041:         lix = ++lixs[direction];",
          "5042:         for (i=0; i < 4; i++) {",
          "5043:    adjacent_lix = lix[dir[i]];",
          "5044:           ldiff[direction][i] = ABS(lix[0][0]-adjacent_lix[0]);",
          "5045:           abdiff[direction][i] = SQR(lix[0][1]-adjacent_lix[1])",
          "5046:             + SQR(lix[0][2]-adjacent_lix[2]);",
          "5047:         }",
          "5048:       }",
          "5049:       leps = MIN(MAX(ldiff[0][0],ldiff[0][1]),",
          "5050:           MAX(ldiff[1][2],ldiff[1][3]));",
          "5051:       abeps = MIN(MAX(abdiff[0][0],abdiff[0][1]),",
          "5052:           MAX(abdiff[1][2],abdiff[1][3]));",
          "5053:       for (direction=0; direction < 2; direction++) {",
          "5054:  homogeneity = 0;",
          "5055:         for (i=0; i < 4; i++) {",
          "5056:           if (ldiff[direction][i] <= leps && abdiff[direction][i] <= abeps) {",
          "5057:      homogeneity++;",
          "5058:    }",
          "5059:  }",
          "5060:  homogeneity_map_p[0][direction] = homogeneity;",
          "5061:       }",
          "5062:     }",
          "5063:   }",
          "5064: }",
          "5065: void CLASS ahd_interpolate_combine_homogeneous_pixels(int top, int left, ushort (*rgb)[TS][TS][3], char (*homogeneity_map)[TS][2])",
          "5066: {",
          "5067:   int row, col;",
          "5068:   int tr, tc;",
          "5069:   int i, j;",
          "5070:   int direction;",
          "5071:   int hm[2];",
          "5072:   int c;",
          "5073:   const int rowlimit = MIN(top+TS-3, height-5);",
          "5074:   const int collimit = MIN(left+TS-3, width-5);",
          "5076:   ushort (*pix)[4];",
          "5077:   ushort (*rix[2])[3];",
          "5079:   for (row=top+3; row < rowlimit; row++) {",
          "5080:     tr = row-top;",
          "5081:     pix = &image[row*width+left+2];",
          "5082:     for (direction = 0; direction < 2; direction++) {",
          "5083:       rix[direction] = &rgb[direction][tr][2];",
          "5084:     }",
          "5086:     for (col=left+3; col < collimit; col++) {",
          "5087:       tc = col-left;",
          "5088:       pix++;",
          "5089:       for (direction = 0; direction < 2; direction++) {",
          "5090:         rix[direction]++;",
          "5091:       }",
          "5093:       for (direction=0; direction < 2; direction++) {",
          "5094:         hm[direction] = 0;",
          "5095:         for (i=tr-1; i <= tr+1; i++) {",
          "5096:           for (j=tc-1; j <= tc+1; j++) {",
          "5097:             hm[direction] += homogeneity_map[i][j][direction];",
          "5098:           }",
          "5099:         }",
          "5100:       }",
          "5101:       if (hm[0] != hm[1]) {",
          "5102:         memcpy(pix[0], rix[hm[1] > hm[0]][0], 3 * sizeof(ushort));",
          "5103:       } else {",
          "5104:         FORC3 {",
          "5105:           pix[0][c] = (rix[0][0][c] + rix[1][0][c]) >> 1;",
          "5106:         }",
          "5107:       }",
          "5108:     }",
          "5109:   }",
          "5110: }",
          "5111: void CLASS ahd_interpolate()",
          "5112: {",
          "5113:   int i, j, k, top, left;",
          "5114:   float xyz_cam[3][4],r;",
          "5115:   char *buffer;",
          "5116:   ushort (*rgb)[TS][TS][3];",
          "5117:   short (*lab)[TS][TS][3];",
          "5118:   char (*homo)[TS][2];",
          "5119:   int terminate_flag = 0;",
          "5121:   if(dcraw_cbrt[0]<-0.1){",
          "5122:       for (i=0x10000-1; i >=0; i--) {",
          "5123:           r = i / 65535.0;",
          "5124:           dcraw_cbrt[i] = 64.0*(r > 0.008856 ? pow((double)r,1/3.0) : 7.787*r + 16/116.0);",
          "5125:       }",
          "5126:   }",
          "5127: #ifdef DCRAW_VERBOSE",
          "5128:   if (verbose) fprintf (stderr,_(\"AHD interpolation...\\n\"));",
          "5129: #endif",
          "5131:   for (i=0; i < 3; i++) {",
          "5132:     for (j=0; j < colors; j++) {",
          "5133:       xyz_cam[i][j] = 0;",
          "5134:       for (k=0; k < 3; k++) {",
          "5135:         xyz_cam[i][j] += xyz_rgb[i][k] * rgb_cam[k][j] / d65_white[i];",
          "5136:       }",
          "5137:     }",
          "5138:   }",
          "5140:   border_interpolate(5);",
          "5142: #ifdef LIBRAW_LIBRARY_BUILD",
          "5143: #ifdef LIBRAW_USE_OPENMP",
          "5144: #pragma omp parallel private(buffer,rgb,lab,homo,top,left,i,j,k) shared(xyz_cam,terminate_flag)",
          "5145: #endif",
          "5146: #endif",
          "5147:   {",
          "5149:     merror (buffer, \"ahd_interpolate()\");",
          "5150:     rgb  = (ushort(*)[TS][TS][3]) buffer;",
          "5151:     lab  = (short (*)[TS][TS][3])(buffer + 12*TS*TS);",
          "5152:     homo = (char  (*)[TS][2])    (buffer + 24*TS*TS);",
          "5154: #ifdef LIBRAW_LIBRARY_BUILD",
          "5155: #ifdef LIBRAW_USE_OPENMP",
          "5156: #pragma omp for schedule(dynamic)",
          "5157: #endif",
          "5158: #endif",
          "5159:     for (top=2; top < height-5; top += TS-6){",
          "5160: #ifdef LIBRAW_LIBRARY_BUILD",
          "5161: #ifdef LIBRAW_USE_OPENMP",
          "5162:         if(0== omp_get_thread_num())",
          "5163: #endif",
          "5164:            if(callbacks.progress_cb) {",
          "5165:                int rr = (*callbacks.progress_cb)(callbacks.progresscb_data,LIBRAW_PROGRESS_INTERPOLATE,top-2,height-7);",
          "5166:                if(rr)",
          "5167:                    terminate_flag = 1;",
          "5168:            }",
          "5169: #endif",
          "5170:         for (left=2; !terminate_flag && (left < width-5); left += TS-6) {",
          "5171:             ahd_interpolate_green_h_and_v(top, left, rgb);",
          "5172:             ahd_interpolate_r_and_b_and_convert_to_cielab(top, left, rgb, lab, xyz_cam);",
          "5173:             ahd_interpolate_build_homogeneity_map(top, left, lab, homo);",
          "5174:             ahd_interpolate_combine_homogeneous_pixels(top, left, rgb, homo);",
          "5175:       }",
          "5176:     }",
          "5177:     free (buffer);",
          "5178:   }",
          "5179: #ifdef LIBRAW_LIBRARY_BUILD",
          "5180:   if(terminate_flag)",
          "5181:       throw LIBRAW_EXCEPTION_CANCELLED_BY_CALLBACK;",
          "5182: #endif",
          "5183: }",
          "5184: #undef TS",
          "5186: #endif",
          "",
          "---------------"
        ],
        "internal/dcraw_common.cpp||internal/dcraw_common.cpp": [
          "File: internal/dcraw_common.cpp -> internal/dcraw_common.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "2929:     temp[i] = 2*base[st*i] + base[st*(i-sc)] + base[st*(2*size-2-(i+sc))];",
          "2930: }",
          "2932: void CLASS wavelet_denoise()",
          "2933: {",
          "2934:   float *fimg=0, *temp, thold, mul[2], avg, diff;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2932: #if !defined(LIBRAW_USE_OPENMP)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "3008:   }",
          "3009:   free (fimg);",
          "3010: }",
          "3013: void CLASS green_matching()",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3013: void CLASS wavelet_denoise()",
          "3014: {",
          "3015:   float *fimg=0, *temp, thold, mul[2], avg, diff;",
          "3016:    int scale=1, size, lev, hpass, lpass, row, col, nc, c, i, wlast, blk[2];",
          "3017:   ushort *window[4];",
          "3018:   static const float noise[] =",
          "3019:   { 0.8002,0.2735,0.1202,0.0585,0.0291,0.0152,0.0080,0.0044 };",
          "3021: #ifdef DCRAW_VERBOSE",
          "3022:   if (verbose) fprintf (stderr,_(\"Wavelet denoising...\\n\"));",
          "3023: #endif",
          "3025:   while (maximum << scale < 0x10000) scale++;",
          "3026:   maximum <<= --scale;",
          "3027:   black <<= scale;",
          "3028:   FORC4 cblack[c] <<= scale;",
          "3029:   if ((size = iheight*iwidth) < 0x15550000)",
          "3030:     fimg = (float *) malloc ((size*3 + iheight + iwidth) * sizeof *fimg);",
          "3031:   merror (fimg, \"wavelet_denoise()\");",
          "3032:   temp = fimg + size*3;",
          "3033:   if ((nc = colors) == 3 && filters) nc++;",
          "3034: #ifdef LIBRAW_LIBRARY_BUILD",
          "3035: #pragma omp parallel default(shared) private(i,col,row,thold,lev,lpass,hpass,temp,c) firstprivate(scale,size)",
          "3036: #endif",
          "3037:   {",
          "3038:       temp = (float*)malloc( (iheight + iwidth) * sizeof *fimg);",
          "3040: #ifdef LIBRAW_LIBRARY_BUILD",
          "3041: #pragma omp for",
          "3042: #endif",
          "3043:       for (i=0; i < size; i++)",
          "3044:         fimg[i] = 256 * sqrt((double)(image[i][c] << scale));",
          "3045:       for (hpass=lev=0; lev < 5; lev++) {",
          "3046:  lpass = size*((lev & 1)+1);",
          "3047: #ifdef LIBRAW_LIBRARY_BUILD",
          "3048: #pragma omp for",
          "3049: #endif",
          "3050:  for (row=0; row < iheight; row++) {",
          "3051:    hat_transform (temp, fimg+hpass+row*iwidth, 1, iwidth, 1 << lev);",
          "3052:    for (col=0; col < iwidth; col++)",
          "3053:      fimg[lpass + row*iwidth + col] = temp[col] * 0.25;",
          "3054:  }",
          "3055: #ifdef LIBRAW_LIBRARY_BUILD",
          "3056: #pragma omp for",
          "3057: #endif",
          "3058:  for (col=0; col < iwidth; col++) {",
          "3059:    hat_transform (temp, fimg+lpass+col, iwidth, iheight, 1 << lev);",
          "3060:    for (row=0; row < iheight; row++)",
          "3061:      fimg[lpass + row*iwidth + col] = temp[row] * 0.25;",
          "3062:  }",
          "3063:  thold = threshold * noise[lev];",
          "3064: #ifdef LIBRAW_LIBRARY_BUILD",
          "3065: #pragma omp for",
          "3066: #endif",
          "3067:  for (i=0; i < size; i++) {",
          "3068:    fimg[hpass+i] -= fimg[lpass+i];",
          "3069:    if (fimg[hpass+i] < -thold) fimg[hpass+i] += thold;",
          "3070:    else if (fimg[hpass+i] >  thold) fimg[hpass+i] -= thold;",
          "3071:    else  fimg[hpass+i] = 0;",
          "3072:    if (hpass) fimg[i] += fimg[hpass+i];",
          "3073:  }",
          "3074:  hpass = lpass;",
          "3075:       }",
          "3076: #ifdef LIBRAW_LIBRARY_BUILD",
          "3077: #pragma omp for",
          "3078: #endif",
          "3079:       for (i=0; i < size; i++)",
          "3080:  image[i][c] = CLIP(SQR(fimg[i]+fimg[lpass+i])/0x10000);",
          "3081:     }",
          "3082:     free(temp);",
          "3089:    for (row=0; row < 2; row++){",
          "3090:       mul[row] = 0.125 * pre_mul[FC(row+1,0) | 1] / pre_mul[FC(row,0) | 1];",
          "3091:       blk[row] = cblack[FC(row,0) | 1];",
          "3092:    }",
          "3093:     for (i=0; i < 4; i++)",
          "3094:       window[i] = (ushort *) fimg + width*i;",
          "3095:     for (wlast=-1, row=1; row < height-1; row++) {",
          "3096:       while (wlast < row+1) {",
          "3097:  for (wlast++, i=0; i < 4; i++)",
          "3098:    window[(i+3) & 3] = window[i];",
          "3099:  for (col = FC(wlast,1) & 1; col < width; col+=2)",
          "3100:    window[2][col] = BAYER(wlast,col);",
          "3101:       }",
          "3102:       thold = threshold/512;",
          "3103:       for (col = (FC(row,0) & 1)+1; col < width-1; col+=2) {",
          "3104:  avg = ( window[0][col-1] + window[0][col+1] +",
          "3105:   window[2][col-1] + window[2][col+1] - blk[~row & 1]*4 )",
          "3107:  avg = avg < 0 ? 0 : sqrt(avg);",
          "3108:  diff = sqrt((double)BAYER(row,col)) - avg;",
          "3109:  if      (diff < -thold) diff += thold;",
          "3110:  else if (diff >  thold) diff -= thold;",
          "3111:  else diff = 0;",
          "3112:  BAYER(row,col) = CLIP(SQR(avg+diff) + 0.5);",
          "3113:       }",
          "3114:     }",
          "3115:   }",
          "3116:   free (fimg);",
          "3117: }",
          "3119: #endif",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "3511:     }",
          "3512: }",
          "3515:    Adaptive Homogeneity-Directed interpolation is based on",
          "3516:    the work of Keigo Hirakawa, Thomas Parks, and Paul Lee.",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3623: #ifndef LIBRAW_LIBRARY_BUILD",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "3643:   free (buffer);",
          "3644: }",
          "3645: #undef TS",
          "3647: void CLASS median_filter()",
          "3648: {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3756: #else",
          "3758: static float dcraw_cbrt[0x10000] = {-1.0f};",
          "3760: static inline float calc_64cbrt(float f)",
          "3761: {",
          "3762:   unsigned u;",
          "3763:   static float lower = dcraw_cbrt[0];",
          "3764:   static float upper = dcraw_cbrt[0xffff];",
          "3766:   if (f <= 0) {",
          "3767:     return lower;",
          "3768:   }",
          "3770:   u = (unsigned) f;",
          "3771:   if (u >= 0xffff) {",
          "3772:     return upper;",
          "3773:   }",
          "3774:   return dcraw_cbrt[u];",
          "3775: }",
          "3776: void CLASS ahd_interpolate_green_h_and_v(int top, int left, ushort (*out_rgb)[TS][TS][3])",
          "3777: {",
          "3778:   int row, col;",
          "3779:   int c, val;",
          "3780:   ushort (*pix)[4];",
          "3781:   const int rowlimit = MIN(top+TS, height-2);",
          "3782:   const int collimit = MIN(left+TS, width-2);",
          "3784:   for (row = top; row < rowlimit; row++) {",
          "3785:     col = left + (FC(row,left) & 1);",
          "3786:     for (c = FC(row,col); col < collimit; col+=2) {",
          "3787:       pix = image + row*width+col;",
          "3788:       val = ((pix[-1][1] + pix[0][c] + pix[1][1]) * 2",
          "3789:             - pix[-2][c] - pix[2][c]) >> 2;",
          "3790:       out_rgb[0][row-top][col-left][1] = ULIM(val,pix[-1][1],pix[1][1]);",
          "3791:       val = ((pix[-width][1] + pix[0][c] + pix[width][1]) * 2",
          "3792:             - pix[-2*width][c] - pix[2*width][c]) >> 2;",
          "3793:       out_rgb[1][row-top][col-left][1] = ULIM(val,pix[-width][1],pix[width][1]);",
          "3794:     }",
          "3795:   }",
          "3796: }",
          "3797: void CLASS ahd_interpolate_r_and_b_in_rgb_and_convert_to_cielab(int top, int left, ushort (*inout_rgb)[TS][3], short (*out_lab)[TS][3], const float (&xyz_cam)[3][4])",
          "3798: {",
          "3799:   unsigned row, col;",
          "3800:   int c, val;",
          "3801:   ushort (*pix)[4];",
          "3802:   ushort (*rix)[3];",
          "3803:   short (*lix)[3];",
          "3804:   float xyz[3];",
          "3805:   const unsigned num_pix_per_row = 4*width;",
          "3806:   const unsigned rowlimit = MIN(top+TS-1, height-3);",
          "3807:   const unsigned collimit = MIN(left+TS-1, width-3);",
          "3808:   ushort *pix_above;",
          "3809:   ushort *pix_below;",
          "3810:   int t1, t2;",
          "3812:   for (row = top+1; row < rowlimit; row++) {",
          "3813:     pix = image + row*width + left;",
          "3814:     rix = &inout_rgb[row-top][0];",
          "3815:     lix = &out_lab[row-top][0];",
          "3817:     for (col = left+1; col < collimit; col++) {",
          "3818:       pix++;",
          "3819:       pix_above = &pix[0][0] - num_pix_per_row;",
          "3820:       pix_below = &pix[0][0] + num_pix_per_row;",
          "3821:       rix++;",
          "3822:       lix++;",
          "3824:       c = 2 - FC(row, col);",
          "3826:       if (c == 1) {",
          "3827:         c = FC(row+1,col);",
          "3828:  t1 = 2-c;",
          "3829:         val = pix[0][1] + (( pix[-1][t1] + pix[1][t1]",
          "3830:               - rix[-1][1] - rix[1][1] ) >> 1);",
          "3831:         rix[0][t1] = CLIP(val);",
          "3832:         val = pix[0][1] + (( pix_above[c] + pix_below[c]",
          "3833:               - rix[-TS][1] - rix[TS][1] ) >> 1);",
          "3834:       } else {",
          "3837:         val = rix[0][1] + (( pix_above[t1] + pix_above[t2]",
          "3838:               + pix_below[t1] + pix_below[t2]",
          "3839:               - rix[-TS-1][1] - rix[-TS+1][1]",
          "3840:               - rix[+TS-1][1] - rix[+TS+1][1] + 1) >> 2);",
          "3841:       }",
          "3842:       rix[0][c] = CLIP(val);",
          "3843:       c = FC(row,col);",
          "3844:       rix[0][c] = pix[0][c];",
          "3845:       xyz[0] = xyz[1] = xyz[2] = 0.5;",
          "3846:       FORC3 {",
          "3851:         xyz[0] += xyz_cam[0][c] * rix[0][c];",
          "3852:         xyz[1] += xyz_cam[1][c] * rix[0][c];",
          "3853:         xyz[2] += xyz_cam[2][c] * rix[0][c];",
          "3854:       }",
          "3855:       FORC3 {",
          "3856:  xyz[c] = calc_64cbrt(xyz[c]);",
          "3857:       }",
          "3858:       lix[0][0] = (116 * xyz[1] - 16);",
          "3859:       lix[0][1] = 500 * (xyz[0] - xyz[1]);",
          "3860:       lix[0][2] = 200 * (xyz[1] - xyz[2]);",
          "3861:     }",
          "3862:   }",
          "3863: }",
          "3864: void CLASS ahd_interpolate_r_and_b_and_convert_to_cielab(int top, int left, ushort (*inout_rgb)[TS][TS][3], short (*out_lab)[TS][TS][3], const float (&xyz_cam)[3][4])",
          "3865: {",
          "3866:   int direction;",
          "3867:   for (direction = 0; direction < 2; direction++) {",
          "3868:     ahd_interpolate_r_and_b_in_rgb_and_convert_to_cielab(top, left, inout_rgb[direction], out_lab[direction], xyz_cam);",
          "3869:   }",
          "3870: }",
          "3871: void CLASS ahd_interpolate_build_homogeneity_map(int top, int left, short (*lab)[TS][TS][3], char (*out_homogeneity_map)[TS][2])",
          "3872: {",
          "3873:   int row, col;",
          "3874:   int tr, tc;",
          "3875:   int direction;",
          "3876:   int i;",
          "3877:   short (*lix)[3];",
          "3878:   short (*lixs[2])[3];",
          "3879:   short *adjacent_lix;",
          "3880:   unsigned ldiff[2][4], abdiff[2][4], leps, abeps;",
          "3881:   static const int dir[4] = { -1, 1, -TS, TS };",
          "3882:   const int rowlimit = MIN(top+TS-2, height-4);",
          "3883:   const int collimit = MIN(left+TS-2, width-4);",
          "3884:   int homogeneity;",
          "3885:   char (*homogeneity_map_p)[2];",
          "3887:   memset (out_homogeneity_map, 0, 2*TS*TS);",
          "3889:   for (row=top+2; row < rowlimit; row++) {",
          "3890:     tr = row-top;",
          "3891:     homogeneity_map_p = &out_homogeneity_map[tr][1];",
          "3892:     for (direction=0; direction < 2; direction++) {",
          "3893:       lixs[direction] = &lab[direction][tr][1];",
          "3894:     }",
          "3896:     for (col=left+2; col < collimit; col++) {",
          "3897:       tc = col-left;",
          "3898:       homogeneity_map_p++;",
          "3900:       for (direction=0; direction < 2; direction++) {",
          "3901:         lix = ++lixs[direction];",
          "3902:         for (i=0; i < 4; i++) {",
          "3903:    adjacent_lix = lix[dir[i]];",
          "3904:           ldiff[direction][i] = ABS(lix[0][0]-adjacent_lix[0]);",
          "3905:           abdiff[direction][i] = SQR(lix[0][1]-adjacent_lix[1])",
          "3906:             + SQR(lix[0][2]-adjacent_lix[2]);",
          "3907:         }",
          "3908:       }",
          "3909:       leps = MIN(MAX(ldiff[0][0],ldiff[0][1]),",
          "3910:           MAX(ldiff[1][2],ldiff[1][3]));",
          "3911:       abeps = MIN(MAX(abdiff[0][0],abdiff[0][1]),",
          "3912:           MAX(abdiff[1][2],abdiff[1][3]));",
          "3913:       for (direction=0; direction < 2; direction++) {",
          "3914:  homogeneity = 0;",
          "3915:         for (i=0; i < 4; i++) {",
          "3916:           if (ldiff[direction][i] <= leps && abdiff[direction][i] <= abeps) {",
          "3917:      homogeneity++;",
          "3918:    }",
          "3919:  }",
          "3920:  homogeneity_map_p[0][direction] = homogeneity;",
          "3921:       }",
          "3922:     }",
          "3923:   }",
          "3924: }",
          "3925: void CLASS ahd_interpolate_combine_homogeneous_pixels(int top, int left, ushort (*rgb)[TS][TS][3], char (*homogeneity_map)[TS][2])",
          "3926: {",
          "3927:   int row, col;",
          "3928:   int tr, tc;",
          "3929:   int i, j;",
          "3930:   int direction;",
          "3931:   int hm[2];",
          "3932:   int c;",
          "3933:   const int rowlimit = MIN(top+TS-3, height-5);",
          "3934:   const int collimit = MIN(left+TS-3, width-5);",
          "3936:   ushort (*pix)[4];",
          "3937:   ushort (*rix[2])[3];",
          "3939:   for (row=top+3; row < rowlimit; row++) {",
          "3940:     tr = row-top;",
          "3941:     pix = &image[row*width+left+2];",
          "3942:     for (direction = 0; direction < 2; direction++) {",
          "3943:       rix[direction] = &rgb[direction][tr][2];",
          "3944:     }",
          "3946:     for (col=left+3; col < collimit; col++) {",
          "3947:       tc = col-left;",
          "3948:       pix++;",
          "3949:       for (direction = 0; direction < 2; direction++) {",
          "3950:         rix[direction]++;",
          "3951:       }",
          "3953:       for (direction=0; direction < 2; direction++) {",
          "3954:         hm[direction] = 0;",
          "3955:         for (i=tr-1; i <= tr+1; i++) {",
          "3956:           for (j=tc-1; j <= tc+1; j++) {",
          "3957:             hm[direction] += homogeneity_map[i][j][direction];",
          "3958:           }",
          "3959:         }",
          "3960:       }",
          "3961:       if (hm[0] != hm[1]) {",
          "3962:         memcpy(pix[0], rix[hm[1] > hm[0]][0], 3 * sizeof(ushort));",
          "3963:       } else {",
          "3964:         FORC3 {",
          "3965:           pix[0][c] = (rix[0][0][c] + rix[1][0][c]) >> 1;",
          "3966:         }",
          "3967:       }",
          "3968:     }",
          "3969:   }",
          "3970: }",
          "3971: void CLASS ahd_interpolate()",
          "3972: {",
          "3973:   int i, j, k, top, left;",
          "3974:   float xyz_cam[3][4],r;",
          "3975:   char *buffer;",
          "3976:   ushort (*rgb)[TS][TS][3];",
          "3977:   short (*lab)[TS][TS][3];",
          "3978:   char (*homo)[TS][2];",
          "3979:   int terminate_flag = 0;",
          "3981:   if(dcraw_cbrt[0]<-0.1){",
          "3982:       for (i=0x10000-1; i >=0; i--) {",
          "3983:           r = i / 65535.0;",
          "3984:           dcraw_cbrt[i] = 64.0*(r > 0.008856 ? pow((double)r,1/3.0) : 7.787*r + 16/116.0);",
          "3985:       }",
          "3986:   }",
          "3987: #ifdef DCRAW_VERBOSE",
          "3988:   if (verbose) fprintf (stderr,_(\"AHD interpolation...\\n\"));",
          "3989: #endif",
          "3991:   for (i=0; i < 3; i++) {",
          "3992:     for (j=0; j < colors; j++) {",
          "3993:       xyz_cam[i][j] = 0;",
          "3994:       for (k=0; k < 3; k++) {",
          "3995:         xyz_cam[i][j] += xyz_rgb[i][k] * rgb_cam[k][j] / d65_white[i];",
          "3996:       }",
          "3997:     }",
          "3998:   }",
          "4000:   border_interpolate(5);",
          "4002: #ifdef LIBRAW_LIBRARY_BUILD",
          "4003: #ifdef LIBRAW_USE_OPENMP",
          "4004: #pragma omp parallel private(buffer,rgb,lab,homo,top,left,i,j,k) shared(xyz_cam,terminate_flag)",
          "4005: #endif",
          "4006: #endif",
          "4007:   {",
          "4009:     merror (buffer, \"ahd_interpolate()\");",
          "4010:     rgb  = (ushort(*)[TS][TS][3]) buffer;",
          "4011:     lab  = (short (*)[TS][TS][3])(buffer + 12*TS*TS);",
          "4012:     homo = (char  (*)[TS][2])    (buffer + 24*TS*TS);",
          "4014: #ifdef LIBRAW_LIBRARY_BUILD",
          "4015: #ifdef LIBRAW_USE_OPENMP",
          "4016: #pragma omp for schedule(dynamic)",
          "4017: #endif",
          "4018: #endif",
          "4019:     for (top=2; top < height-5; top += TS-6){",
          "4020: #ifdef LIBRAW_LIBRARY_BUILD",
          "4021: #ifdef LIBRAW_USE_OPENMP",
          "4022:         if(0== omp_get_thread_num())",
          "4023: #endif",
          "4024:            if(callbacks.progress_cb) {",
          "4025:                int rr = (*callbacks.progress_cb)(callbacks.progresscb_data,LIBRAW_PROGRESS_INTERPOLATE,top-2,height-7);",
          "4026:                if(rr)",
          "4027:                    terminate_flag = 1;",
          "4028:            }",
          "4029: #endif",
          "4030:         for (left=2; !terminate_flag && (left < width-5); left += TS-6) {",
          "4031:             ahd_interpolate_green_h_and_v(top, left, rgb);",
          "4032:             ahd_interpolate_r_and_b_and_convert_to_cielab(top, left, rgb, lab, xyz_cam);",
          "4033:             ahd_interpolate_build_homogeneity_map(top, left, lab, homo);",
          "4034:             ahd_interpolate_combine_homogeneous_pixels(top, left, rgb, homo);",
          "4035:       }",
          "4036:     }",
          "4037:     free (buffer);",
          "4038:   }",
          "4039: #ifdef LIBRAW_LIBRARY_BUILD",
          "4040:   if(terminate_flag)",
          "4041:       throw LIBRAW_EXCEPTION_CANCELLED_BY_CALLBACK;",
          "4042: #endif",
          "4043: }",
          "4044: #undef TS",
          "4046: #endif",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "3828:     fseek (ifp, save, SEEK_SET);",
          "3829:   }",
          "3830: }",
          "3832: void CLASS parse_makernote (int base, int uptag)",
          "3833: {",
          "3834:   static const uchar xlat[2][256] = {",
          "",
          "[Removed Lines]",
          "3831: #line 4976 \"dcraw/dcraw.c\"",
          "",
          "[Added Lines]",
          "4232: #line 5377 \"dcraw/dcraw.c\"",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "4343:     fseek (ifp, save, SEEK_SET);",
          "4344:   }",
          "4345: }",
          "4347: int CLASS parse_tiff_ifd (int base)",
          "4348: {",
          "4349:   unsigned entries, tag, type, len, plen=16, save;",
          "",
          "[Removed Lines]",
          "4346: #line 5496 \"dcraw/dcraw.c\"",
          "",
          "[Added Lines]",
          "4747: #line 5897 \"dcraw/dcraw.c\"",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "5587:     data_offset = get4();",
          "5588:   }",
          "5589: }",
          "5591: char * CLASS foveon_gets (int offset, char *str, int len)",
          "5592: {",
          "5593:   int i;",
          "",
          "[Removed Lines]",
          "5590: #line 6742 \"dcraw/dcraw.c\"",
          "",
          "[Added Lines]",
          "5991: #line 7143 \"dcraw/dcraw.c\"",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "5688:   }",
          "5689:   is_foveon = 1;",
          "5690: }",
          "5693:    All matrices are from Adobe DNG Converter unless otherwise noted.",
          "",
          "[Removed Lines]",
          "5691: #line 6845 \"dcraw/dcraw.c\"",
          "",
          "[Added Lines]",
          "6092: #line 7246 \"dcraw/dcraw.c\"",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "8131: }",
          "8135: void CLASS convert_to_rgb()",
          "8136: {",
          "8137: #ifndef LIBRAW_LIBRARY_BUILD",
          "",
          "[Removed Lines]",
          "8134: #line 9377 \"dcraw/dcraw.c\"",
          "",
          "[Added Lines]",
          "8535: #line 9778 \"dcraw/dcraw.c\"",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "8361:   if (flip & 1) col = iwidth  - 1 - col;",
          "8362:   return row * iwidth + col;",
          "8363: }",
          "8365: void CLASS tiff_set (ushort *ntag,",
          "8366:  ushort tag, ushort type, int count, int val)",
          "8367: {",
          "",
          "[Removed Lines]",
          "8364: #line 9632 \"dcraw/dcraw.c\"",
          "",
          "[Added Lines]",
          "8765: #line 10033 \"dcraw/dcraw.c\"",
          "",
          "---------------"
        ],
        "internal/dcraw_fileio.cpp||internal/dcraw_fileio.cpp": [
          "File: internal/dcraw_fileio.cpp -> internal/dcraw_fileio.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "154:   RUN_CALLBACK(LIBRAW_PROGRESS_DARK_FRAME,1,2);",
          "155: #endif",
          "156: }",
          "158: #ifndef NO_LCMS",
          "159: void CLASS apply_profile (const char *input, const char *output)",
          "160: {",
          "",
          "[Removed Lines]",
          "157: #line 9290 \"dcraw/dcraw.c\"",
          "",
          "[Added Lines]",
          "157: #line 9691 \"dcraw/dcraw.c\"",
          "",
          "---------------"
        ],
        "src/libraw_cxx.cpp||src/libraw_cxx.cpp": [
          "File: src/libraw_cxx.cpp -> src/libraw_cxx.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "1620: void LibRaw::subtract_black()",
          "1621: {",
          "1623: #define BAYERC(row,col,c) imgdata.image[((row) >> IO.shrink)*S.iwidth + ((col) >> IO.shrink)][c]",
          "1626:         {",
          "1627:             int cblk[4],i,row,col,val,cc;",
          "1628:             for(i=0;i<4;i++)",
          "1630:             ZERO(C.channel_maximum);",
          "1632:             for(row=0;row<S.height;row++)",
          "",
          "[Removed Lines]",
          "1622: #if 0",
          "1625:     if((C.black || C.cblack[0] || C.cblack[1] || C.cblack[2] || C.cblack[3]))",
          "1629:                 cblk[i] = C.cblack[i]+C.black;",
          "",
          "[Added Lines]",
          "1622: #if 1",
          "1625:     if((C.cblack[0] || C.cblack[1] || C.cblack[2] || C.cblack[3]))",
          "1629:                 cblk[i] = C.cblack[i];",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1647:         }",
          "1648:     else",
          "1649:         {",
          "1651:             int row,col,cc;",
          "1652:             ZERO(C.channel_maximum);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1651: #if 0",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1657:                             int val = BAYERC(row,col,cc);",
          "1658:                             if(C.channel_maximum[cc] < val) C.channel_maximum[cc] = val;",
          "1659:                         }",
          "1661:         }",
          "1662: #undef BAYERC",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1662: #endif",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1827:         if (O.user_black >= 0) C.black = O.user_black;",
          "1828:         for(c=0;c<4;c++) C.cblack[c] += C.black;",
          "1832: #endif",
          "1834:         adjust_maximum();",
          "",
          "[Removed Lines]",
          "1830: #else",
          "1831:         subtract_black();",
          "",
          "[Added Lines]",
          "1833:         printf(\"I'm here!\\n\");",
          "1834: #endif",
          "1836: #if 1",
          "1837:         if(!IO.fuji_width)",
          "1838:           subtract_black();",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "a667bb32cf9c8a7e553af91e25f84303a5caf7ad",
      "candidate_info": {
        "commit_hash": "a667bb32cf9c8a7e553af91e25f84303a5caf7ad",
        "repo": "LibRaw/LibRaw",
        "commit_url": "https://github.com/LibRaw/LibRaw/commit/a667bb32cf9c8a7e553af91e25f84303a5caf7ad",
        "files": [
          "Changelog.txt",
          "dcraw/dcraw.c",
          "internal/dcraw_common.cpp",
          "libraw/libraw_types.h",
          "src/libraw_cxx.cpp"
        ],
        "message": "improved substract_black code, fixed minor problem in lossy DNG tone curve generation",
        "before_after_code_files": [
          "dcraw/dcraw.c||dcraw/dcraw.c",
          "internal/dcraw_common.cpp||internal/dcraw_common.cpp",
          "libraw/libraw_types.h||libraw/libraw_types.h",
          "src/libraw_cxx.cpp||src/libraw_cxx.cpp"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/libraw_cxx.cpp||src/libraw_cxx.cpp"
          ],
          "candidate": [
            "src/libraw_cxx.cpp||src/libraw_cxx.cpp"
          ]
        }
      },
      "candidate_diff": {
        "dcraw/dcraw.c||dcraw/dcraw.c": [
          "File: dcraw/dcraw.c -> dcraw/dcraw.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "2345:       coeff[i] = getreal(12);",
          "2346:     for (i=0; i < 256; i++) {",
          "2347:       for (tot=j=0; j <= deg; j++)",
          "2349:       t_curve[c][i] = tot*0xffff;",
          "2350:     }",
          "2351:   }",
          "",
          "[Removed Lines]",
          "2348:  tot += coeff[j] * pow(i/255.0f, (int)j);",
          "",
          "[Added Lines]",
          "2348:  tot += coeff[j] * pow(i/255.0, (int)j);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "4389:   }",
          "4390: #endif",
          "4391:   size = iheight*iwidth;",
          "4393:   scale_colors_loop(scale_mul);",
          "4394: #else",
          "4395:   for (i=0; i < size*4; i++) {",
          "",
          "[Removed Lines]",
          "4392: #ifdef LIBRAW_LIBRARY_BUILD__1",
          "",
          "[Added Lines]",
          "4392: #ifdef LIBRAW_LIBRARY_BUILD",
          "",
          "---------------"
        ],
        "internal/dcraw_common.cpp||internal/dcraw_common.cpp": [
          "File: internal/dcraw_common.cpp -> internal/dcraw_common.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "2076:       coeff[i] = getreal(12);",
          "2077:     for (i=0; i < 256; i++) {",
          "2078:       for (tot=j=0; j <= deg; j++)",
          "2080:       t_curve[c][i] = tot*0xffff;",
          "2081:     }",
          "2082:   }",
          "",
          "[Removed Lines]",
          "2079:  tot += coeff[j] * pow(i/255.0f, (int)j);",
          "",
          "[Added Lines]",
          "2079:  tot += coeff[j] * pow(i/255.0, (int)j);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "3249:   }",
          "3250: #endif",
          "3251:   size = iheight*iwidth;",
          "3253:   scale_colors_loop(scale_mul);",
          "3254: #else",
          "3255:   for (i=0; i < size*4; i++) {",
          "",
          "[Removed Lines]",
          "3252: #ifdef LIBRAW_LIBRARY_BUILD__1",
          "",
          "[Added Lines]",
          "3252: #ifdef LIBRAW_LIBRARY_BUILD",
          "",
          "---------------"
        ],
        "libraw/libraw_types.h||libraw/libraw_types.h": [
          "File: libraw/libraw_types.h -> libraw/libraw_types.h"
        ],
        "src/libraw_cxx.cpp||src/libraw_cxx.cpp": [
          "File: src/libraw_cxx.cpp -> src/libraw_cxx.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "189:     memmove(&imgdata.params.aber,&aber,sizeof(aber));",
          "190:     memmove(&imgdata.params.gamm,&gamm,sizeof(gamm));",
          "191:     memmove(&imgdata.params.greybox,&greybox,sizeof(greybox));",
          "194:     imgdata.params.bright=1;",
          "195:     imgdata.params.use_camera_matrix=-1;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "192:     memmove(&imgdata.params.cropbox,&cropbox,sizeof(cropbox));",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "522: int LibRaw::adjust_maximum()",
          "523: {",
          "525:     ushort real_max;",
          "526:     float  auto_threshold;",
          "",
          "[Removed Lines]",
          "524:     int i;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1638:     if((C.cblack[0] || C.cblack[1] || C.cblack[2] || C.cblack[3]))",
          "1639:         {",
          "1640: #define BAYERC(row,col,c) imgdata.image[((row) >> IO.shrink)*S.iwidth + ((col) >> IO.shrink)][c]",
          "1642:             for(i=0;i<4;i++)",
          "1643:                 cblk[i] = C.cblack[i];",
          "1657:             C.maximum -= C.black;",
          "1658:             ZERO(C.cblack);",
          "1659:             C.black = 0;",
          "",
          "[Removed Lines]",
          "1641:             int cblk[4],i,row,col,val,cc;",
          "1645:             for(row=0;row<S.height;row++)",
          "1646:                 for(col=0;col<S.width;col++)",
          "1647:                     {",
          "1648:                         cc=fcol(row,col);",
          "1649:                         val = BAYERC(row,col,cc);",
          "1650:                         if(val > cblk[cc])",
          "1651:                             val -= cblk[cc];",
          "1652:                         else",
          "1653:                             val = 0;",
          "1654:                         if(C.data_maximum < val) C.data_maximum = val;",
          "1655:                         BAYERC(row,col,cc) = val;",
          "1656:                     }",
          "",
          "[Added Lines]",
          "1641:             int cblk[4],i;",
          "1645:             int size = S.iheight * S.iwidth;",
          "1646: #define MIN(a,b) ((a) < (b) ? (a) : (b))",
          "1647: #define MAX(a,b) ((a) > (b) ? (a) : (b))",
          "1648: #define LIM(x,min,max) MAX(min,MIN(x,max))",
          "1649: #define CLIP(x) LIM(x,0,65535)",
          "1651:             for(i=0; i< size*4; i++)",
          "1652:               {",
          "1653:                 int val = imgdata.image[0][i];",
          "1654:                 val -= cblk[i & 3];",
          "1655:                 imgdata.image[0][i] = CLIP(val);",
          "1656:                 if(C.data_maximum < val) C.data_maximum = val;",
          "1657:               }",
          "1658: #undef MIN",
          "1659: #undef MAX",
          "1660: #undef LIM",
          "1661: #undef CLIP",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1662:     else",
          "1663:         {",
          "1671:         }",
          "1672: }",
          "",
          "[Removed Lines]",
          "1666:             int idx;",
          "1667:             ushort *p = (ushort*)imgdata.image;",
          "1668:             C.data_maximum = 0;",
          "1669:             for(idx=0;idx<S.height*S.width*4;idx++)",
          "1670:               if(C.data_maximum < p[idx]) C.data_maximum = p[idx];",
          "",
          "[Added Lines]",
          "1671:           int idx;",
          "1672:           ushort *p = (ushort*)imgdata.image;",
          "1673:           C.data_maximum = 0;",
          "1674:           for(idx=0;idx<S.iheight*S.iwidth*4;idx++)",
          "1675:             if(C.data_maximum < p[idx]) C.data_maximum = p[idx];",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1758: void LibRaw::scale_colors_loop(float scale_mul[4])",
          "1759: {",
          "1768: }",
          "1770: int LibRaw::dcraw_process(void)",
          "",
          "[Removed Lines]",
          "1760:  unsigned size = S.iheight*S.iwidth;",
          "1761:  for (unsigned i=0; i < size*4; i++) {",
          "1762:   int val = imgdata.image[0][i];",
          "1763:   if (!val) continue;",
          "1764:   val -= C.cblack[i & 3];",
          "1765:   val *= scale_mul[i & 3];",
          "1766:   imgdata.image[0][i] = CLIP(val);",
          "1767:  }",
          "",
          "[Added Lines]",
          "1765:   unsigned size = S.iheight*S.iwidth;",
          "1767:   if(C.cblack[0]||C.cblack[1]||C.cblack[2]||C.cblack[3])",
          "1768:     {",
          "1769:       for (unsigned i=0; i < size*4; i++)",
          "1770:         {",
          "1771:           int val = imgdata.image[0][i];",
          "1772:           if (!val) continue;",
          "1773:           val -= C.cblack[i & 3];",
          "1774:           val *= scale_mul[i & 3];",
          "1775:           imgdata.image[0][i] = CLIP(val);",
          "1776:         }",
          "1777:     }",
          "1778:   else // BL is zero",
          "1779:     {",
          "1780:       for (unsigned i=0; i < size*4; i++)",
          "1781:         {",
          "1782:           int val = imgdata.image[0][i];",
          "1783:           val *= scale_mul[i & 3];",
          "1784:           imgdata.image[0][i] = CLIP(val);",
          "1785:         }",
          "1786:     }",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1834:         C.black += i;",
          "1835:         if (O.user_black >= 0) C.black = O.user_black;",
          "1836:         for(c=0;c<4;c++) C.cblack[c] += C.black;",
          "1840:         subtract_black();",
          "",
          "[Removed Lines]",
          "1838:         printf(\"cblack calculated again: %d %d %d %d\\n\",C.cblack[0],C.cblack[1],C.cblack[2],C.cblack[3]);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "49d4152191a54c4e8f07a316329999d69dd9ddd1",
      "candidate_info": {
        "commit_hash": "49d4152191a54c4e8f07a316329999d69dd9ddd1",
        "repo": "LibRaw/LibRaw",
        "commit_url": "https://github.com/LibRaw/LibRaw/commit/49d4152191a54c4e8f07a316329999d69dd9ddd1",
        "files": [
          "dcraw/dcraw.c",
          "internal/dcraw_common.cpp",
          "internal/dcraw_fileio.cpp",
          "src/libraw_cxx.cpp"
        ],
        "message": "phase1d - restored RESTRICTED code for dcraw.c compilation alone",
        "before_after_code_files": [
          "dcraw/dcraw.c||dcraw/dcraw.c",
          "internal/dcraw_common.cpp||internal/dcraw_common.cpp",
          "internal/dcraw_fileio.cpp||internal/dcraw_fileio.cpp",
          "src/libraw_cxx.cpp||src/libraw_cxx.cpp"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/libraw_cxx.cpp||src/libraw_cxx.cpp"
          ],
          "candidate": [
            "src/libraw_cxx.cpp||src/libraw_cxx.cpp"
          ]
        }
      },
      "candidate_diff": {
        "dcraw/dcraw.c||dcraw/dcraw.c": [
          "File: dcraw/dcraw.c -> dcraw/dcraw.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "2861: #endif",
          "2862: }",
          "2865: void CLASS crop_masked_pixels()",
          "2866: {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2866: void CLASS foveon_decoder (unsigned size, unsigned code)",
          "2867: {",
          "2868:   static unsigned huff[1024];",
          "2869:   struct decode *cur;",
          "2870:   int i, len;",
          "2872:   if (!code) {",
          "2873:     for (i=0; i < size; i++)",
          "2874:       huff[i] = get4();",
          "2875:     memset (first_decode, 0, sizeof first_decode);",
          "2876:     free_decode = first_decode;",
          "2877:   }",
          "2878:   cur = free_decode++;",
          "2879:   if (free_decode > first_decode+2048) {",
          "2880:     fprintf (stderr,_(\"%s: decoder table overflow\\n\"), ifname);",
          "2881:     longjmp (failure, 2);",
          "2882:   }",
          "2883:   if (code)",
          "2884:     for (i=0; i < size; i++)",
          "2885:       if (huff[i] == code) {",
          "2886:  cur->leaf = i;",
          "2887:  return;",
          "2888:       }",
          "2889:   if ((len = code >> 27) > 26) return;",
          "2890:   code = (len+1) << 27 | (code & 0x3ffffff) << 1;",
          "2892:   cur->branch[0] = free_decode;",
          "2893:   foveon_decoder (size, code);",
          "2894:   cur->branch[1] = free_decode;",
          "2895:   foveon_decoder (size, code+1);",
          "2896: }",
          "2898: void CLASS foveon_thumb()",
          "2899: {",
          "2900:   unsigned bwide, row, col, bitbuf=0, bit=1, c, i;",
          "2901:   char *buf;",
          "2902:   struct decode *dindex;",
          "2903:   short pred[3];",
          "2905:   bwide = get4();",
          "2906:   fprintf (ofp, \"P6\\n%d %d\\n255\\n\", thumb_width, thumb_height);",
          "2907:   if (bwide > 0) {",
          "2908:     if (bwide < thumb_width*3) return;",
          "2909:     buf = (char *) malloc (bwide);",
          "2910:     merror (buf, \"foveon_thumb()\");",
          "2911:     for (row=0; row < thumb_height; row++) {",
          "2912:       fread  (buf, 1, bwide, ifp);",
          "2913:       fwrite (buf, 3, thumb_width, ofp);",
          "2914:     }",
          "2915:     free (buf);",
          "2916:     return;",
          "2917:   }",
          "2918:   foveon_decoder (256, 0);",
          "2920:   for (row=0; row < thumb_height; row++) {",
          "2921:     memset (pred, 0, sizeof pred);",
          "2922:     if (!bit) get4();",
          "2923:     for (bit=col=0; col < thumb_width; col++)",
          "2924:       FORC3 {",
          "2925:  for (dindex=first_decode; dindex->branch[0]; ) {",
          "2926:    if ((bit = (bit-1) & 31) == 31)",
          "2927:      for (i=0; i < 4; i++)",
          "2928:        bitbuf = (bitbuf << 8) + fgetc(ifp);",
          "2929:    dindex = dindex->branch[bitbuf >> bit & 1];",
          "2930:  }",
          "2931:  pred[c] += dindex->leaf;",
          "2932:  fputc (pred[c], ofp);",
          "2933:       }",
          "2934:   }",
          "2935: }",
          "2937: void CLASS foveon_sd_load_raw()",
          "2938: {",
          "2939:   struct decode *dindex;",
          "2940:   short diff[1024];",
          "2941:   unsigned bitbuf=0;",
          "2942:   int pred[3], row, col, bit=-1, c, i;",
          "2944:   read_shorts ((ushort *) diff, 1024);",
          "2945:   if (!load_flags) foveon_decoder (1024, 0);",
          "2947:   for (row=0; row < height; row++) {",
          "2948:     memset (pred, 0, sizeof pred);",
          "2949:     if (!bit && !load_flags && atoi(model+2) < 14) get4();",
          "2950:     for (col=bit=0; col < width; col++) {",
          "2951:       if (load_flags) {",
          "2952:  bitbuf = get4();",
          "2953:  FORC3 pred[2-c] += diff[bitbuf >> c*10 & 0x3ff];",
          "2954:       }",
          "2955:       else FORC3 {",
          "2956:  for (dindex=first_decode; dindex->branch[0]; ) {",
          "2957:    if ((bit = (bit-1) & 31) == 31)",
          "2958:      for (i=0; i < 4; i++)",
          "2959:        bitbuf = (bitbuf << 8) + fgetc(ifp);",
          "2960:    dindex = dindex->branch[bitbuf >> bit & 1];",
          "2961:  }",
          "2962:  pred[c] += diff[dindex->leaf];",
          "2963:  if (pred[c] >> 16 && ~pred[c] >> 16) derror();",
          "2964:       }",
          "2965:       FORC3 image[row*width+col][c] = pred[c];",
          "2966:     }",
          "2967:   }",
          "2968: }",
          "2970: void CLASS foveon_huff (ushort *huff)",
          "2971: {",
          "2972:   int i, j, clen, code;",
          "2974:   huff[0] = 8;",
          "2975:   for (i=0; i < 13; i++) {",
          "2976:     clen = getc(ifp);",
          "2977:     code = getc(ifp);",
          "2978:     for (j=0; j < 256 >> clen; )",
          "2979:       huff[code+ ++j] = clen << 8 | i;",
          "2980:   }",
          "2981:   get2();",
          "2982: }",
          "2984: void CLASS foveon_dp_load_raw()",
          "2985: {",
          "2986:   unsigned c, roff[4], row, col, diff;",
          "2987:   ushort huff[258], vpred, hpred;",
          "2989:   fseek (ifp, 8, SEEK_CUR);",
          "2990:   foveon_huff (huff);",
          "2991:   roff[0] = 48;",
          "2992:   FORC3 roff[c+1] = -(-(roff[c] + get4()) & -16);",
          "2993:   FORC3 {",
          "2994:     fseek (ifp, data_offset+roff[c], SEEK_SET);",
          "2995:     getbits(-1);",
          "2996:     vpred = 1024;",
          "2997:     for (row=0; row < height; row++) {",
          "2998:       for (col=0; col < width; col++) {",
          "2999:  diff = ljpeg_diff(huff);",
          "3000:  if (col) hpred += diff;",
          "3001:  else hpred = vpred += diff;",
          "3002:  image[row*width+col][c] = hpred;",
          "3003:       }",
          "3004:     }",
          "3005:   }",
          "3006: }",
          "3008: void CLASS foveon_load_camf()",
          "3009: {",
          "3010:   unsigned type, wide, high, i, j, row, col, diff;",
          "3011:   ushort huff[258], vpred[2][2] = {{512,512},{512,512}}, hpred[2];",
          "3013:   fseek (ifp, meta_offset, SEEK_SET);",
          "3014:   type = get4();  get4();  get4();",
          "3015:   wide = get4();",
          "3016:   high = get4();",
          "3017:   if (type == 2) {",
          "3018:     fread (meta_data, 1, meta_length, ifp);",
          "3019:     for (i=0; i < meta_length; i++) {",
          "3020:       high = (high * 1597 + 51749) % 244944;",
          "3021:       wide = high * (INT64) 301593171 >> 24;",
          "3022:       meta_data[i] ^= ((((high << 8) - wide) >> 1) + wide) >> 17;",
          "3023:     }",
          "3024:   } else if (type == 4) {",
          "3025:     free (meta_data);",
          "3026:     meta_data = (char *) malloc (meta_length = wide*high*3/2);",
          "3027:     merror (meta_data, \"foveon_load_camf()\");",
          "3028:     foveon_huff (huff);",
          "3029:     get4();",
          "3030:     getbits(-1);",
          "3031:     for (j=row=0; row < high; row++) {",
          "3032:       for (col=0; col < wide; col++) {",
          "3033:  diff = ljpeg_diff(huff);",
          "3034:  if (col < 2) hpred[col] = vpred[row & 1][col] += diff;",
          "3035:  else         hpred[col & 1] += diff;",
          "3036:  if (col & 1) {",
          "3037:    meta_data[j++] = hpred[0] >> 4;",
          "3038:    meta_data[j++] = hpred[0] << 4 | hpred[1] >> 8;",
          "3039:    meta_data[j++] = hpred[1];",
          "3040:         }",
          "3041:       }",
          "3042:     }",
          "3043:   } else",
          "3044:     fprintf (stderr,_(\"%s has unknown CAMF type %d.\\n\"), ifname, type);",
          "3045: }",
          "3047: const char * CLASS foveon_camf_param (const char *block, const char *param)",
          "3048: {",
          "3049:   unsigned idx, num;",
          "3050:   char *pos, *cp, *dp;",
          "3052:   for (idx=0; idx < meta_length; idx += sget4(pos+8)) {",
          "3053:     pos = meta_data + idx;",
          "3054:     if (strncmp (pos, \"CMb\", 3)) break;",
          "3055:     if (pos[3] != 'P') continue;",
          "3056:     if (strcmp (block, pos+sget4(pos+12))) continue;",
          "3057:     cp = pos + sget4(pos+16);",
          "3058:     num = sget4(cp);",
          "3059:     dp = pos + sget4(cp+4);",
          "3060:     while (num--) {",
          "3061:       cp += 8;",
          "3062:       if (!strcmp (param, dp+sget4(cp)))",
          "3063:  return dp+sget4(cp+4);",
          "3064:     }",
          "3065:   }",
          "3066:   return 0;",
          "3067: }",
          "3069: void * CLASS foveon_camf_matrix (unsigned dim[3], const char *name)",
          "3070: {",
          "3071:   unsigned i, idx, type, ndim, size, *mat;",
          "3072:   char *pos, *cp, *dp;",
          "3073:   double dsize;",
          "3075:   for (idx=0; idx < meta_length; idx += sget4(pos+8)) {",
          "3076:     pos = meta_data + idx;",
          "3077:     if (strncmp (pos, \"CMb\", 3)) break;",
          "3078:     if (pos[3] != 'M') continue;",
          "3079:     if (strcmp (name, pos+sget4(pos+12))) continue;",
          "3080:     dim[0] = dim[1] = dim[2] = 1;",
          "3081:     cp = pos + sget4(pos+16);",
          "3082:     type = sget4(cp);",
          "3083:     if ((ndim = sget4(cp+4)) > 3) break;",
          "3084:     dp = pos + sget4(cp+8);",
          "3085:     for (i=ndim; i--; ) {",
          "3086:       cp += 12;",
          "3087:       dim[i] = sget4(cp);",
          "3088:     }",
          "3089:     if ((dsize = (double) dim[0]*dim[1]*dim[2]) > meta_length/4) break;",
          "3090:     mat = (unsigned *) malloc ((size = dsize) * 4);",
          "3091:     merror (mat, \"foveon_camf_matrix()\");",
          "3092:     for (i=0; i < size; i++)",
          "3093:       if (type && type != 6)",
          "3094:  mat[i] = sget4(dp + i*4);",
          "3095:       else",
          "3096:  mat[i] = sget4(dp + i*2) & 0xffff;",
          "3097:     return mat;",
          "3098:   }",
          "3099:   fprintf (stderr,_(\"%s: \\\"%s\\\" matrix not found!\\n\"), ifname, name);",
          "3100:   return 0;",
          "3101: }",
          "3103: int CLASS foveon_fixed (void *ptr, int size, const char *name)",
          "3104: {",
          "3105:   void *dp;",
          "3106:   unsigned dim[3];",
          "3108:   if (!name) return 0;",
          "3109:   dp = foveon_camf_matrix (dim, name);",
          "3110:   if (!dp) return 0;",
          "3111:   memcpy (ptr, dp, size*4);",
          "3112:   free (dp);",
          "3113:   return 1;",
          "3114: }",
          "3116: float CLASS foveon_avg (short *pix, int range[2], float cfilt)",
          "3117: {",
          "3118:   int i;",
          "3119:   float val, min=FLT_MAX, max=-FLT_MAX, sum=0;",
          "3121:   for (i=range[0]; i <= range[1]; i++) {",
          "3122:     sum += val = pix[i*4] + (pix[i*4]-pix[(i-1)*4]) * cfilt;",
          "3123:     if (min > val) min = val;",
          "3124:     if (max < val) max = val;",
          "3125:   }",
          "3126:   if (range[1] - range[0] == 1) return sum/2;",
          "3127:   return (sum - min - max) / (range[1] - range[0] - 1);",
          "3128: }",
          "3130: short * CLASS foveon_make_curve (double max, double mul, double filt)",
          "3131: {",
          "3132:   short *curve;",
          "3133:   unsigned i, size;",
          "3134:   double x;",
          "3136:   if (!filt) filt = 0.8;",
          "3137:   size = 4*M_PI*max / filt;",
          "3138:   if (size == UINT_MAX) size--;",
          "3139:   curve = (short *) calloc (size+1, sizeof *curve);",
          "3140:   merror (curve, \"foveon_make_curve()\");",
          "3141:   curve[0] = size;",
          "3142:   for (i=0; i < size; i++) {",
          "3143:     x = i*filt/max/4;",
          "3144:     curve[i+1] = (cos(x)+1)/2 * tanh(i*filt/mul) * mul + 0.5;",
          "3145:   }",
          "3146:   return curve;",
          "3147: }",
          "3149: void CLASS foveon_make_curves",
          "3150:  (short **curvep, float dq[3], float div[3], float filt)",
          "3151: {",
          "3152:   double mul[3], max=0;",
          "3153:   int c;",
          "3155:   FORC3 mul[c] = dq[c]/div[c];",
          "3156:   FORC3 if (max < mul[c]) max = mul[c];",
          "3157:   FORC3 curvep[c] = foveon_make_curve (max, mul[c], filt);",
          "3158: }",
          "3160: int CLASS foveon_apply_curve (short *curve, int i)",
          "3161: {",
          "3162:   if (abs(i) >= curve[0]) return 0;",
          "3163:   return i < 0 ? -curve[1-i] : curve[1+i];",
          "3164: }",
          "3166: #define image ((short (*)[4]) image)",
          "3168: void CLASS foveon_interpolate()",
          "3169: {",
          "3170:   static const short hood[] = { -1,-1, -1,0, -1,1, 0,-1, 0,1, 1,-1, 1,0, 1,1 };",
          "3171:   short *pix, prev[3], *curve[8], (*shrink)[3];",
          "3172:   float cfilt=0, ddft[3][3][2], ppm[3][3][3];",
          "3173:   float cam_xyz[3][3], correct[3][3], last[3][3], trans[3][3];",
          "3174:   float chroma_dq[3], color_dq[3], diag[3][3], div[3];",
          "3175:   float (*black)[3], (*sgain)[3], (*sgrow)[3];",
          "3176:   float fsum[3], val, frow, num;",
          "3177:   int row, col, c, i, j, diff, sgx, irow, sum, min, max, limit;",
          "3178:   int dscr[2][2], dstb[4], (*smrow[7])[3], total[4], ipix[3];",
          "3179:   int work[3][3], smlast, smred, smred_p=0, dev[3];",
          "3180:   int satlev[3], keep[4], active[4];",
          "3181:   unsigned dim[3], *badpix;",
          "3182:   double dsum=0, trsum[3];",
          "3183:   char str[128];",
          "3184:   const char* cp;",
          "3186:   if (verbose)",
          "3187:     fprintf (stderr,_(\"Foveon interpolation...\\n\"));",
          "3189:   foveon_load_camf();",
          "3190:   foveon_fixed (dscr, 4, \"DarkShieldColRange\");",
          "3191:   foveon_fixed (ppm[0][0], 27, \"PostPolyMatrix\");",
          "3192:   foveon_fixed (satlev, 3, \"SaturationLevel\");",
          "3193:   foveon_fixed (keep, 4, \"KeepImageArea\");",
          "3194:   foveon_fixed (active, 4, \"ActiveImageArea\");",
          "3195:   foveon_fixed (chroma_dq, 3, \"ChromaDQ\");",
          "3196:   foveon_fixed (color_dq, 3,",
          "3197:  foveon_camf_param (\"IncludeBlocks\", \"ColorDQ\") ?",
          "3198:   \"ColorDQ\" : \"ColorDQCamRGB\");",
          "3199:   if (foveon_camf_param (\"IncludeBlocks\", \"ColumnFilter\"))",
          "3200:      foveon_fixed (&cfilt, 1, \"ColumnFilter\");",
          "3202:   memset (ddft, 0, sizeof ddft);",
          "3203:   if (!foveon_camf_param (\"IncludeBlocks\", \"DarkDrift\")",
          "3204:   || !foveon_fixed (ddft[1][0], 12, \"DarkDrift\"))",
          "3205:     for (i=0; i < 2; i++) {",
          "3206:       foveon_fixed (dstb, 4, i ? \"DarkShieldBottom\":\"DarkShieldTop\");",
          "3207:       for (row = dstb[1]; row <= dstb[3]; row++)",
          "3208:  for (col = dstb[0]; col <= dstb[2]; col++)",
          "3209:    FORC3 ddft[i+1][c][1] += (short) image[row*width+col][c];",
          "3210:       FORC3 ddft[i+1][c][1] /= (dstb[3]-dstb[1]+1) * (dstb[2]-dstb[0]+1);",
          "3211:     }",
          "3213:   if (!(cp = foveon_camf_param (\"WhiteBalanceIlluminants\", model2)))",
          "3214:   { fprintf (stderr,_(\"%s: Invalid white balance \\\"%s\\\"\\n\"), ifname, model2);",
          "3215:     return; }",
          "3216:   foveon_fixed (cam_xyz, 9, cp);",
          "3217:   foveon_fixed (correct, 9,",
          "3218:  foveon_camf_param (\"WhiteBalanceCorrections\", model2));",
          "3219:   memset (last, 0, sizeof last);",
          "3220:   for (i=0; i < 3; i++)",
          "3221:     for (j=0; j < 3; j++)",
          "3222:       FORC3 last[i][j] += correct[i][c] * cam_xyz[c][j];",
          "3224:   #define LAST(x,y) last[(i+x)%3][(c+y)%3]",
          "3225:   for (i=0; i < 3; i++)",
          "3226:     FORC3 diag[c][i] = LAST(1,1)*LAST(2,2) - LAST(1,2)*LAST(2,1);",
          "3227:   #undef LAST",
          "3228:   FORC3 div[c] = diag[c][0]*0.3127 + diag[c][1]*0.329 + diag[c][2]*0.3583;",
          "3229:   sprintf (str, \"%sRGBNeutral\", model2);",
          "3230:   if (foveon_camf_param (\"IncludeBlocks\", str))",
          "3231:     foveon_fixed (div, 3, str);",
          "3232:   num = 0;",
          "3233:   FORC3 if (num < div[c]) num = div[c];",
          "3234:   FORC3 div[c] /= num;",
          "3236:   memset (trans, 0, sizeof trans);",
          "3237:   for (i=0; i < 3; i++)",
          "3238:     for (j=0; j < 3; j++)",
          "3239:       FORC3 trans[i][j] += rgb_cam[i][c] * last[c][j] * div[j];",
          "3240:   FORC3 trsum[c] = trans[c][0] + trans[c][1] + trans[c][2];",
          "3241:   dsum = (6*trsum[0] + 11*trsum[1] + 3*trsum[2]) / 20;",
          "3242:   for (i=0; i < 3; i++)",
          "3243:     FORC3 last[i][c] = trans[i][c] * dsum / trsum[i];",
          "3244:   memset (trans, 0, sizeof trans);",
          "3245:   for (i=0; i < 3; i++)",
          "3246:     for (j=0; j < 3; j++)",
          "3247:       FORC3 trans[i][j] += (i==c ? 32 : -1) * last[c][j] / 30;",
          "3249:   foveon_make_curves (curve, color_dq, div, cfilt);",
          "3250:   FORC3 chroma_dq[c] /= 3;",
          "3251:   foveon_make_curves (curve+3, chroma_dq, div, cfilt);",
          "3252:   FORC3 dsum += chroma_dq[c] / div[c];",
          "3253:   curve[6] = foveon_make_curve (dsum, dsum, cfilt);",
          "3254:   curve[7] = foveon_make_curve (dsum*2, dsum*2, cfilt);",
          "3256:   sgain = (float (*)[3]) foveon_camf_matrix (dim, \"SpatialGain\");",
          "3257:   if (!sgain) return;",
          "3258:   sgrow = (float (*)[3]) calloc (dim[1], sizeof *sgrow);",
          "3259:   sgx = (width + dim[1]-2) / (dim[1]-1);",
          "3261:   black = (float (*)[3]) calloc (height, sizeof *black);",
          "3262:   for (row=0; row < height; row++) {",
          "3263:     for (i=0; i < 6; i++)",
          "3264:       ddft[0][0][i] = ddft[1][0][i] +",
          "3265:  row / (height-1.0) * (ddft[2][0][i] - ddft[1][0][i]);",
          "3266:     FORC3 black[row][c] =",
          "3267:   ( foveon_avg (image[row*width]+c, dscr[0], cfilt) +",
          "3268:    foveon_avg (image[row*width]+c, dscr[1], cfilt) * 3",
          "3269:    - ddft[0][c][0] ) / 4 - ddft[0][c][1];",
          "3270:   }",
          "3271:   memcpy (black, black+8, sizeof *black*8);",
          "3272:   memcpy (black+height-11, black+height-22, 11*sizeof *black);",
          "3273:   memcpy (last, black, sizeof last);",
          "3275:   for (row=1; row < height-1; row++) {",
          "3276:     FORC3 if (last[1][c] > last[0][c]) {",
          "3277:  if (last[1][c] > last[2][c])",
          "3278:    black[row][c] = (last[0][c] > last[2][c]) ? last[0][c]:last[2][c];",
          "3279:       } else",
          "3280:  if (last[1][c] < last[2][c])",
          "3281:    black[row][c] = (last[0][c] < last[2][c]) ? last[0][c]:last[2][c];",
          "3282:     memmove (last, last+1, 2*sizeof last[0]);",
          "3283:     memcpy (last[2], black[row+1], sizeof last[2]);",
          "3284:   }",
          "3285:   FORC3 black[row][c] = (last[0][c] + last[1][c])/2;",
          "3286:   FORC3 black[0][c] = (black[1][c] + black[3][c])/2;",
          "3288:   val = 1 - exp(-1/24.0);",
          "3289:   memcpy (fsum, black, sizeof fsum);",
          "3290:   for (row=1; row < height; row++)",
          "3291:     FORC3 fsum[c] += black[row][c] =",
          "3292:  (black[row][c] - black[row-1][c])*val + black[row-1][c];",
          "3293:   memcpy (last[0], black[height-1], sizeof last[0]);",
          "3294:   FORC3 fsum[c] /= height;",
          "3295:   for (row = height; row--; )",
          "3296:     FORC3 last[0][c] = black[row][c] =",
          "3297:  (black[row][c] - fsum[c] - last[0][c])*val + last[0][c];",
          "3299:   memset (total, 0, sizeof total);",
          "3300:   for (row=2; row < height; row+=4)",
          "3301:     for (col=2; col < width; col+=4) {",
          "3302:       FORC3 total[c] += (short) image[row*width+col][c];",
          "3303:       total[3]++;",
          "3304:     }",
          "3305:   for (row=0; row < height; row++)",
          "3306:     FORC3 black[row][c] += fsum[c]/2 + total[c]/(total[3]*100.0);",
          "3308:   for (row=0; row < height; row++) {",
          "3309:     for (i=0; i < 6; i++)",
          "3310:       ddft[0][0][i] = ddft[1][0][i] +",
          "3311:  row / (height-1.0) * (ddft[2][0][i] - ddft[1][0][i]);",
          "3312:     pix = image[row*width];",
          "3313:     memcpy (prev, pix, sizeof prev);",
          "3314:     frow = row / (height-1.0) * (dim[2]-1);",
          "3315:     if ((irow = frow) == dim[2]-1) irow--;",
          "3316:     frow -= irow;",
          "3317:     for (i=0; i < dim[1]; i++)",
          "3318:       FORC3 sgrow[i][c] = sgain[ irow   *dim[1]+i][c] * (1-frow) +",
          "3319:      sgain[(irow+1)*dim[1]+i][c] *    frow;",
          "3320:     for (col=0; col < width; col++) {",
          "3321:       FORC3 {",
          "3322:  diff = pix[c] - prev[c];",
          "3323:  prev[c] = pix[c];",
          "3324:  ipix[c] = pix[c] + floor ((diff + (diff*diff >> 14)) * cfilt",
          "3325:   - ddft[0][c][1] - ddft[0][c][0] * ((float) col/width - 0.5)",
          "3326:   - black[row][c] );",
          "3327:       }",
          "3328:       FORC3 {",
          "3329:  work[0][c] = ipix[c] * ipix[c] >> 14;",
          "3330:  work[2][c] = ipix[c] * work[0][c] >> 14;",
          "3331:  work[1][2-c] = ipix[(c+1) % 3] * ipix[(c+2) % 3] >> 14;",
          "3332:       }",
          "3333:       FORC3 {",
          "3334:  for (val=i=0; i < 3; i++)",
          "3335:    for (  j=0; j < 3; j++)",
          "3336:      val += ppm[c][i][j] * work[i][j];",
          "3337:  ipix[c] = floor ((ipix[c] + floor(val)) *",
          "3338:   ( sgrow[col/sgx  ][c] * (sgx - col%sgx) +",
          "3339:     sgrow[col/sgx+1][c] * (col%sgx) ) / sgx / div[c]);",
          "3340:  if (ipix[c] > 32000) ipix[c] = 32000;",
          "3341:  pix[c] = ipix[c];",
          "3342:       }",
          "3343:       pix += 4;",
          "3344:     }",
          "3345:   }",
          "3346:   free (black);",
          "3347:   free (sgrow);",
          "3348:   free (sgain);",
          "3350:   if ((badpix = (unsigned int *) foveon_camf_matrix (dim, \"BadPixels\"))) {",
          "3351:     for (i=0; i < dim[0]; i++) {",
          "3352:       col = (badpix[i] >> 8 & 0xfff) - keep[0];",
          "3353:       row = (badpix[i] >> 20       ) - keep[1];",
          "3354:       if ((unsigned)(row-1) > height-3 || (unsigned)(col-1) > width-3)",
          "3355:  continue;",
          "3356:       memset (fsum, 0, sizeof fsum);",
          "3357:       for (sum=j=0; j < 8; j++)",
          "3358:  if (badpix[i] & (1 << j)) {",
          "3359:    FORC3 fsum[c] += (short)",
          "3360:   image[(row+hood[j*2])*width+col+hood[j*2+1]][c];",
          "3361:    sum++;",
          "3362:  }",
          "3363:       if (sum) FORC3 image[row*width+col][c] = fsum[c]/sum;",
          "3364:     }",
          "3365:     free (badpix);",
          "3366:   }",
          "3369:   smrow[6] = (int (*)[3]) calloc (width*5, sizeof **smrow);",
          "3370:   merror (smrow[6], \"foveon_interpolate()\");",
          "3371:   for (i=0; i < 5; i++)",
          "3372:     smrow[i] = smrow[6] + i*width;",
          "3375:   for (smlast=-1, row=2; row < height-2; row++) {",
          "3376:     while (smlast < row+2) {",
          "3377:       for (i=0; i < 6; i++)",
          "3378:  smrow[(i+5) % 6] = smrow[i];",
          "3379:       pix = image[++smlast*width+2];",
          "3380:       for (col=2; col < width-2; col++) {",
          "3381:  smrow[4][col][0] =",
          "3382:    (pix[0]*6 + (pix[-4]+pix[4])*4 + pix[-8]+pix[8] + 8) >> 4;",
          "3383:  pix += 4;",
          "3384:       }",
          "3385:     }",
          "3386:     pix = image[row*width+2];",
          "3387:     for (col=2; col < width-2; col++) {",
          "3388:       smred = ( 6 *  smrow[2][col][0]",
          "3389:        + 4 * (smrow[1][col][0] + smrow[3][col][0])",
          "3390:        +      smrow[0][col][0] + smrow[4][col][0] + 8 ) >> 4;",
          "3391:       if (col == 2)",
          "3392:  smred_p = smred;",
          "3393:       i = pix[0] + ((pix[0] - ((smred*7 + smred_p) >> 3)) >> 3);",
          "3394:       if (i > 32000) i = 32000;",
          "3395:       pix[0] = i;",
          "3396:       smred_p = smred;",
          "3397:       pix += 4;",
          "3398:     }",
          "3399:   }",
          "3402:   min = 0xffff;",
          "3403:   FORC3 {",
          "3404:     i = satlev[c] / div[c];",
          "3405:     if (min > i) min = i;",
          "3406:   }",
          "3407:   limit = min * 9 >> 4;",
          "3408:   for (pix=image[0]; pix < image[height*width]; pix+=4) {",
          "3409:     if (pix[0] <= limit || pix[1] <= limit || pix[2] <= limit)",
          "3410:       continue;",
          "3411:     min = max = pix[0];",
          "3412:     for (c=1; c < 3; c++) {",
          "3413:       if (min > pix[c]) min = pix[c];",
          "3414:       if (max < pix[c]) max = pix[c];",
          "3415:     }",
          "3416:     if (min >= limit*2) {",
          "3417:       pix[0] = pix[1] = pix[2] = max;",
          "3418:     } else {",
          "3419:       i = 0x4000 - ((min - limit) << 14) / limit;",
          "3420:       i = 0x4000 - (i*i >> 14);",
          "3421:       i = i*i >> 14;",
          "3422:       FORC3 pix[c] += (max - pix[c]) * i >> 14;",
          "3423:     }",
          "3424:   }",
          "3426:    Because photons that miss one detector often hit another,",
          "3427:    the sum R+G+B is much less noisy than the individual colors.",
          "3428:    So smooth the hues without smoothing the total.",
          "3430:   for (smlast=-1, row=2; row < height-2; row++) {",
          "3431:     while (smlast < row+2) {",
          "3432:       for (i=0; i < 6; i++)",
          "3433:  smrow[(i+5) % 6] = smrow[i];",
          "3434:       pix = image[++smlast*width+2];",
          "3435:       for (col=2; col < width-2; col++) {",
          "3436:  FORC3 smrow[4][col][c] = (pix[c-4]+2*pix[c]+pix[c+4]+2) >> 2;",
          "3437:  pix += 4;",
          "3438:       }",
          "3439:     }",
          "3440:     pix = image[row*width+2];",
          "3441:     for (col=2; col < width-2; col++) {",
          "3442:       FORC3 dev[c] = -foveon_apply_curve (curve[7], pix[c] -",
          "3443:  ((smrow[1][col][c] + 2*smrow[2][col][c] + smrow[3][col][c]) >> 2));",
          "3444:       sum = (dev[0] + dev[1] + dev[2]) >> 3;",
          "3445:       FORC3 pix[c] += dev[c] - sum;",
          "3446:       pix += 4;",
          "3447:     }",
          "3448:   }",
          "3449:   for (smlast=-1, row=2; row < height-2; row++) {",
          "3450:     while (smlast < row+2) {",
          "3451:       for (i=0; i < 6; i++)",
          "3452:  smrow[(i+5) % 6] = smrow[i];",
          "3453:       pix = image[++smlast*width+2];",
          "3454:       for (col=2; col < width-2; col++) {",
          "3455:  FORC3 smrow[4][col][c] =",
          "3456:   (pix[c-8]+pix[c-4]+pix[c]+pix[c+4]+pix[c+8]+2) >> 2;",
          "3457:  pix += 4;",
          "3458:       }",
          "3459:     }",
          "3460:     pix = image[row*width+2];",
          "3461:     for (col=2; col < width-2; col++) {",
          "3462:       for (total[3]=375, sum=60, c=0; c < 3; c++) {",
          "3463:  for (total[c]=i=0; i < 5; i++)",
          "3464:    total[c] += smrow[i][col][c];",
          "3465:  total[3] += total[c];",
          "3466:  sum += pix[c];",
          "3467:       }",
          "3468:       if (sum < 0) sum = 0;",
          "3469:       j = total[3] > 375 ? (sum << 16) / total[3] : sum * 174;",
          "3470:       FORC3 pix[c] += foveon_apply_curve (curve[6],",
          "3471:   ((j*total[c] + 0x8000) >> 16) - pix[c]);",
          "3472:       pix += 4;",
          "3473:     }",
          "3474:   }",
          "3477:   for (pix=image[0]; pix < image[height*width]; pix+=4) {",
          "3478:     FORC3 pix[c] -= foveon_apply_curve (curve[c], pix[c]);",
          "3479:     sum = (pix[0]+pix[1]+pix[1]+pix[2]) >> 2;",
          "3480:     FORC3 pix[c] -= foveon_apply_curve (curve[c], pix[c]-sum);",
          "3481:     FORC3 {",
          "3482:       for (dsum=i=0; i < 3; i++)",
          "3483:  dsum += trans[c][i] * pix[i];",
          "3484:       if (dsum < 0)  dsum = 0;",
          "3485:       if (dsum > 24000) dsum = 24000;",
          "3486:       ipix[c] = dsum + 0.5;",
          "3487:     }",
          "3488:     FORC3 pix[c] = ipix[c];",
          "3489:   }",
          "3492:   shrink = (short (*)[3]) calloc ((width/4) * (height/4), sizeof *shrink);",
          "3493:   merror (shrink, \"foveon_interpolate()\");",
          "3494:   for (row = height/4; row--; )",
          "3495:     for (col=0; col < width/4; col++) {",
          "3496:       ipix[0] = ipix[1] = ipix[2] = 0;",
          "3497:       for (i=0; i < 4; i++)",
          "3498:  for (j=0; j < 4; j++)",
          "3499:    FORC3 ipix[c] += image[(row*4+i)*width+col*4+j][c];",
          "3500:       FORC3",
          "3501:  if (row+2 > height/4)",
          "3502:    shrink[row*(width/4)+col][c] = ipix[c] >> 4;",
          "3503:  else",
          "3504:    shrink[row*(width/4)+col][c] =",
          "3505:      (shrink[(row+1)*(width/4)+col][c]*1840 + ipix[c]*141 + 2048) >> 12;",
          "3506:     }",
          "3508:   for (row=0; row < (height & ~3); row++) {",
          "3509:     ipix[0] = ipix[1] = ipix[2] = 0;",
          "3510:     if ((row & 3) == 0)",
          "3511:       for (col = width & ~3 ; col--; )",
          "3512:  FORC3 smrow[0][col][c] = ipix[c] =",
          "3513:    (shrink[(row/4)*(width/4)+col/4][c]*1485 + ipix[c]*6707 + 4096) >> 13;",
          "3516:     ipix[0] = ipix[1] = ipix[2] = 0;",
          "3517:     for (col=0; col < (width & ~3); col++)",
          "3518:       FORC3 smrow[1][col][c] = ipix[c] =",
          "3519:  (smrow[0][col][c]*1485 + ipix[c]*6707 + 4096) >> 13;",
          "3522:     if (row == 0)",
          "3523:       memcpy (smrow[2], smrow[1], sizeof **smrow * width);",
          "3524:     else",
          "3525:       for (col=0; col < (width & ~3); col++)",
          "3526:  FORC3 smrow[2][col][c] =",
          "3527:    (smrow[2][col][c]*6707 + smrow[1][col][c]*1485 + 4096) >> 13;",
          "3530:     for (col=0; col < (width & ~3); col++) {",
          "3531:       for (i=j=30, c=0; c < 3; c++) {",
          "3532:  i += smrow[2][col][c];",
          "3533:  j += image[row*width+col][c];",
          "3534:       }",
          "3535:       j = (j << 16) / i;",
          "3536:       for (sum=c=0; c < 3; c++) {",
          "3537:  ipix[c] = foveon_apply_curve (curve[c+3],",
          "3538:    ((smrow[2][col][c] * j + 0x8000) >> 16) - image[row*width+col][c]);",
          "3539:  sum += ipix[c];",
          "3540:       }",
          "3541:       sum >>= 3;",
          "3542:       FORC3 {",
          "3543:  i = image[row*width+col][c] + ipix[c] - sum;",
          "3544:  if (i < 0) i = 0;",
          "3545:  image[row*width+col][c] = i;",
          "3546:       }",
          "3547:     }",
          "3548:   }",
          "3549:   free (shrink);",
          "3550:   free (smrow[6]);",
          "3551:   for (i=0; i < 8; i++)",
          "3552:     free (curve[i]);",
          "3555:   active[1] -= keep[1];",
          "3556:   active[3] -= 2;",
          "3557:   i = active[2] - active[0];",
          "3558:   for (row=0; row < active[3]-active[1]; row++)",
          "3559:     memcpy (image[row*i], image[(row+active[1])*width+active[0]],",
          "3560:   i * sizeof *image);",
          "3561:   width = i;",
          "3562:   height = row;",
          "3563: }",
          "3564: #undef image",
          "",
          "---------------"
        ],
        "internal/dcraw_common.cpp||internal/dcraw_common.cpp": [
          "File: internal/dcraw_common.cpp -> internal/dcraw_common.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "2591:   jas_stream_close (in);",
          "2592: #endif",
          "2593: }",
          "2595: void CLASS remove_zeroes()",
          "2596: {",
          "2597:   unsigned row, col, tot, n, r, c;",
          "",
          "[Removed Lines]",
          "2594: #line 2937 \"dcraw/dcraw.c\"",
          "",
          "[Added Lines]",
          "2594: #line 3640 \"dcraw/dcraw.c\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2608:  if (n) BAYER(row,col) = tot/n;",
          "2609:       }",
          "2610: }",
          "2612: void CLASS gamma_curve (double pwr, double ts, int mode, int imax)",
          "2613: {",
          "2614:   int i;",
          "",
          "[Removed Lines]",
          "2611: #line 3117 \"dcraw/dcraw.c\"",
          "",
          "[Added Lines]",
          "2611: #line 3820 \"dcraw/dcraw.c\"",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "3676:     fseek (ifp, save, SEEK_SET);",
          "3677:   }",
          "3678: }",
          "3680: void CLASS parse_makernote (int base, int uptag)",
          "3681: {",
          "3682:   static const uchar xlat[2][256] = {",
          "",
          "[Removed Lines]",
          "3679: #line 4189 \"dcraw/dcraw.c\"",
          "",
          "[Added Lines]",
          "3679: #line 4892 \"dcraw/dcraw.c\"",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "4191:     fseek (ifp, save, SEEK_SET);",
          "4192:   }",
          "4193: }",
          "4195: int CLASS parse_tiff_ifd (int base)",
          "4196: {",
          "4197:   unsigned entries, tag, type, len, plen=16, save;",
          "",
          "[Removed Lines]",
          "4194: #line 4709 \"dcraw/dcraw.c\"",
          "",
          "[Added Lines]",
          "4194: #line 5412 \"dcraw/dcraw.c\"",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "5428:     data_offset = get4();",
          "5429:   }",
          "5430: }",
          "5433:    All matrices are from Adobe DNG Converter unless otherwise noted.",
          "",
          "[Removed Lines]",
          "5431: #line 6052 \"dcraw/dcraw.c\"",
          "",
          "[Added Lines]",
          "5431: #line 6755 \"dcraw/dcraw.c\"",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "7803:   RUN_CALLBACK(LIBRAW_PROGRESS_IDENTIFY,1,2);",
          "7804: #endif",
          "7805: }",
          "7807: void CLASS convert_to_rgb()",
          "7808: {",
          "7809: #ifndef LIBRAW_LIBRARY_BUILD",
          "",
          "[Removed Lines]",
          "7806: #line 8516 \"dcraw/dcraw.c\"",
          "",
          "[Added Lines]",
          "7806: #line 9219 \"dcraw/dcraw.c\"",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "8026:   if (flip & 1) col = iwidth  - 1 - col;",
          "8027:   return row * iwidth + col;",
          "8028: }",
          "8030: void CLASS tiff_set (ushort *ntag,",
          "8031:  ushort tag, ushort type, int count, int val)",
          "8032: {",
          "",
          "[Removed Lines]",
          "8029: #line 8764 \"dcraw/dcraw.c\"",
          "",
          "[Added Lines]",
          "8029: #line 9467 \"dcraw/dcraw.c\"",
          "",
          "---------------"
        ],
        "internal/dcraw_fileio.cpp||internal/dcraw_fileio.cpp": [
          "File: internal/dcraw_fileio.cpp -> internal/dcraw_fileio.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "21:    for more information",
          "25: #include <math.h>",
          "26: #define CLASS LibRaw::",
          "27: #include \"libraw/libraw_types.h\"",
          "",
          "[Removed Lines]",
          "24: #line 2956 \"dcraw/dcraw.c\"",
          "",
          "[Added Lines]",
          "24: #line 3659 \"dcraw/dcraw.c\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "29: #include \"libraw/libraw.h\"",
          "30: #include \"internal/defines.h\"",
          "31: #include \"internal/var_defines.h\"",
          "34:    Seach from the current directory up to the root looking for",
          "35:    a \".badpixels\" file, and fix those pixels now.",
          "",
          "[Removed Lines]",
          "32: #line 2967 \"dcraw/dcraw.c\"",
          "",
          "[Added Lines]",
          "32: #line 3670 \"dcraw/dcraw.c\"",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "54: #endif",
          "55:   if (cfname)",
          "56:     fp = fopen (cfname, \"r\");",
          "58:   if (!fp)",
          "59:       {",
          "60: #ifdef LIBRAW_LIBRARY_BUILD",
          "",
          "[Removed Lines]",
          "57: #line 3017 \"dcraw/dcraw.c\"",
          "",
          "[Added Lines]",
          "57: #line 3720 \"dcraw/dcraw.c\"",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "152:   RUN_CALLBACK(LIBRAW_PROGRESS_DARK_FRAME,1,2);",
          "153: #endif",
          "154: }",
          "156: #ifndef NO_LCMS",
          "157: void CLASS apply_profile (const char *input, const char *output)",
          "158: {",
          "",
          "[Removed Lines]",
          "155: #line 8429 \"dcraw/dcraw.c\"",
          "",
          "[Added Lines]",
          "155: #line 9132 \"dcraw/dcraw.c\"",
          "",
          "---------------"
        ],
        "src/libraw_cxx.cpp||src/libraw_cxx.cpp": [
          "File: src/libraw_cxx.cpp -> src/libraw_cxx.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "2060:     else",
          "2061:         {",
          "2064:             ZERO(C.channel_maximum);",
          "2065:             for(row=0;row<S.height;row++)",
          "2066:                 for(col=0;col<S.width;col++)",
          "",
          "[Removed Lines]",
          "2063:             int row,col,cc,val;",
          "",
          "[Added Lines]",
          "2063:             int row,col,cc;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "78562255c443f904b69364564ac8e0ce561ca36a",
      "candidate_info": {
        "commit_hash": "78562255c443f904b69364564ac8e0ce561ca36a",
        "repo": "LibRaw/LibRaw",
        "commit_url": "https://github.com/LibRaw/LibRaw/commit/78562255c443f904b69364564ac8e0ce561ca36a",
        "files": [
          "Changelog.rus",
          "Changelog.txt",
          "libraw/libraw_version.h",
          "src/libraw_cxx.cpp"
        ],
        "message": "LibRaw 0.15.1",
        "before_after_code_files": [
          "Changelog.rus||Changelog.rus",
          "libraw/libraw_version.h||libraw/libraw_version.h",
          "src/libraw_cxx.cpp||src/libraw_cxx.cpp"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "diff_branch_olp_changes": 1,
        "olp_code_files": {
          "patch": [
            "src/libraw_cxx.cpp||src/libraw_cxx.cpp"
          ],
          "candidate": [
            "src/libraw_cxx.cpp||src/libraw_cxx.cpp"
          ]
        }
      },
      "candidate_diff": {
        "Changelog.rus||Changelog.rus": [
          "File: Changelog.rus -> Changelog.rus",
          "--- Hunk 1 ---",
          "[Context before]",
          "3:   LibRaw 0.15.0 Release:",
          "",
          "[Removed Lines]",
          "1: \ufeff2013-05-23 Alex Tutubalin <lexa@lexa.ru>",
          "",
          "[Added Lines]",
          "1: \ufeff2013-05-25 Alex Tutubalin <lexa@lexa.ru>",
          "6: 2013-05-23 Alex Tutubalin <lexa@lexa.ru>",
          "",
          "---------------"
        ],
        "libraw/libraw_version.h||libraw/libraw_version.h": [
          "File: libraw/libraw_version.h -> libraw/libraw_version.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "26: #define LIBRAW_MAJOR_VERSION  0",
          "27: #define LIBRAW_MINOR_VERSION  15",
          "29: #define LIBRAW_VERSION_TAIL   Release",
          "31: #define LIBRAW_SHLIB_CURRENT   9",
          "",
          "[Removed Lines]",
          "28: #define LIBRAW_PATCH_VERSION  0",
          "",
          "[Added Lines]",
          "28: #define LIBRAW_PATCH_VERSION  1",
          "",
          "---------------"
        ],
        "src/libraw_cxx.cpp||src/libraw_cxx.cpp": [
          "File: src/libraw_cxx.cpp -> src/libraw_cxx.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "2336: #define MAX(a,b) ((a) > (b) ? (a) : (b))",
          "2337: #define LIM(x,min,max) MAX(min,MIN(x,max))",
          "2338: #define CLIP(x) LIM(x,0,65535)",
          "2341:               {",
          "2342:                 int val = imgdata.image[0][i];",
          "2343:                 val -= cblk[i & 3];",
          "2344:                 imgdata.image[0][i] = CLIP(val);",
          "2346:               }",
          "2347: #undef MIN",
          "2348: #undef MAX",
          "2349: #undef LIM",
          "",
          "[Removed Lines]",
          "2340:             for(i=0; i< size*4; i++)",
          "2345:                 if(C.data_maximum < val) C.data_maximum = val;",
          "",
          "[Added Lines]",
          "2339:       int dmax = 0;",
          "2340:       for(i=0; i< size*4; i++)",
          "2345:                 if(dmax < val) dmax = val;",
          "2347:              C.data_maximum = dmax & 0xffff;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2360:           int idx;",
          "2361:           ushort *p = (ushort*)imgdata.image;",
          "2363:           for(idx=0;idx<S.iheight*S.iwidth*4;idx++)",
          "2365:         }",
          "2366:   return 0;",
          "2367:  }",
          "",
          "[Removed Lines]",
          "2362:           C.data_maximum = 0;",
          "2364:             if(C.data_maximum < p[idx]) C.data_maximum = p[idx];",
          "",
          "[Added Lines]",
          "2363:           int dmax = 0;",
          "2365:             if(dmax < p[idx]) dmax = p[idx];",
          "2366:    C.data_maximum = dmax;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "2421:             imgdata.image[i][3] = lut[imgdata.image[i][3]];",
          "2422:         }",
          "2427:     free(lut);",
          "2428: }",
          "",
          "[Removed Lines]",
          "2424:     C.data_maximum = lut[C.data_maximum];",
          "2425:     C.maximum = lut[C.maximum];",
          "",
          "[Added Lines]",
          "2426:     if(C.data_maximum <=TBLN)",
          "2427:       C.data_maximum = lut[C.data_maximum];",
          "2428:     if(C.maximum <= TBLN)",
          "2429:       C.maximum = lut[C.maximum];",
          "",
          "---------------"
        ]
      }
    }
  ]
}
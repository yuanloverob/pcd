{
  "cve_id": "CVE-2020-13143",
  "cve_desc": "gadget_dev_desc_UDC_store in drivers/usb/gadget/configfs.c in the Linux kernel 3.16 through 5.6.13 relies on kstrdup without considering the possibility of an internal '\\0' value, which allows attackers to trigger an out-of-bounds read, aka CID-15753588bcd4.",
  "repo": "torvalds/linux",
  "patch_hash": "15753588bcd4bbffae1cca33c8ced5722477fe1f",
  "patch_info": {
    "commit_hash": "15753588bcd4bbffae1cca33c8ced5722477fe1f",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/15753588bcd4bbffae1cca33c8ced5722477fe1f",
    "files": [
      "drivers/usb/gadget/configfs.c"
    ],
    "message": "USB: gadget: fix illegal array access in binding with UDC\n\nFuzzUSB (a variant of syzkaller) found an illegal array access\nusing an incorrect index while binding a gadget with UDC.\n\nReference: https://www.spinics.net/lists/linux-usb/msg194331.html\n\nThis bug occurs when a size variable used for a buffer\nis misused to access its strcpy-ed buffer.\nGiven a buffer along with its size variable (taken from user input),\nfrom which, a new buffer is created using kstrdup().\nDue to the original buffer containing 0 value in the middle,\nthe size of the kstrdup-ed buffer becomes smaller than that of the original.\nSo accessing the kstrdup-ed buffer with the same size variable\ntriggers memory access violation.\n\nThe fix makes sure no zero value in the buffer,\nby comparing the strlen() of the orignal buffer with the size variable,\nso that the access to the kstrdup-ed buffer is safe.\n\nBUG: KASAN: slab-out-of-bounds in gadget_dev_desc_UDC_store+0x1ba/0x200\ndrivers/usb/gadget/configfs.c:266\nRead of size 1 at addr ffff88806a55dd7e by task syz-executor.0/17208\n\nCPU: 2 PID: 17208 Comm: syz-executor.0 Not tainted 5.6.8 #1\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS Bochs 01/01/2011\nCall Trace:\n __dump_stack lib/dump_stack.c:77 [inline]\n dump_stack+0xce/0x128 lib/dump_stack.c:118\n print_address_description.constprop.4+0x21/0x3c0 mm/kasan/report.c:374\n __kasan_report+0x131/0x1b0 mm/kasan/report.c:506\n kasan_report+0x12/0x20 mm/kasan/common.c:641\n __asan_report_load1_noabort+0x14/0x20 mm/kasan/generic_report.c:132\n gadget_dev_desc_UDC_store+0x1ba/0x200 drivers/usb/gadget/configfs.c:266\n flush_write_buffer fs/configfs/file.c:251 [inline]\n configfs_write_file+0x2f1/0x4c0 fs/configfs/file.c:283\n __vfs_write+0x85/0x110 fs/read_write.c:494\n vfs_write+0x1cd/0x510 fs/read_write.c:558\n ksys_write+0x18a/0x220 fs/read_write.c:611\n __do_sys_write fs/read_write.c:623 [inline]\n __se_sys_write fs/read_write.c:620 [inline]\n __x64_sys_write+0x73/0xb0 fs/read_write.c:620\n do_syscall_64+0x9e/0x510 arch/x86/entry/common.c:294\n entry_SYSCALL_64_after_hwframe+0x49/0xbe\n\nSigned-off-by: Kyungtae Kim <kt0755@gmail.com>\nReported-and-tested-by: Kyungtae Kim <kt0755@gmail.com>\nCc: Felipe Balbi <balbi@kernel.org>\nCc: stable <stable@vger.kernel.org>\nLink: https://lore.kernel.org/r/20200510054326.GA19198@pizza01\nSigned-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>",
    "before_after_code_files": [
      "drivers/usb/gadget/configfs.c||drivers/usb/gadget/configfs.c"
    ]
  },
  "patch_diff": {
    "drivers/usb/gadget/configfs.c||drivers/usb/gadget/configfs.c": [
      "File: drivers/usb/gadget/configfs.c -> drivers/usb/gadget/configfs.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "260:  char *name;",
      "261:  int ret;",
      "263:  name = kstrdup(page, GFP_KERNEL);",
      "264:  if (!name)",
      "265:   return -ENOMEM;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "263:  if (strlen(page) < len)",
      "264:   return -EOVERFLOW;",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "4a0ca47a8e2fdfb7c9f5b23bba79fa632a5cd8fc",
      "candidate_info": {
        "commit_hash": "4a0ca47a8e2fdfb7c9f5b23bba79fa632a5cd8fc",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/4a0ca47a8e2fdfb7c9f5b23bba79fa632a5cd8fc",
        "files": [
          "drivers/gpu/drm/i915/gt/intel_gt_pm.c"
        ],
        "message": "drm/i915/gt: Suspend tasklets before resume sanitization\n\nIt is possible for a residual tasklet to be pending execution as we\nresume (whether that's some prior test kicking off the tasklet, or if we\nare in a suspend/resume stress test). As such, we do not want that\ntasklet to execute in the middle of our sanitization, such that it sees\nthe poisoned state. For example,\n\n<4>[  449.386553] invalid opcode: 0000 [#1] PREEMPT SMP NOPTI\n<4>[  449.386555] CPU: 1 PID: 5115 Comm: i915_selftest Tainted: G     U  W         5.7.0-rc4-CI-CI_DRM_8472+ #1\n<4>[  449.386556] Hardware name: Intel Corporation Ice Lake Client Platform/IceLake U DDR4 SODIMM PD RVP TLC, BIOS ICLSFWR1.R00.3183.A00.1905020411 05/02/2019\n<4>[  449.386585] RIP: 0010:process_csb+0x6bf/0x830 [i915]\n<4>[  449.386588] Code: 00 48 c7 c2 10 bc 4c a0 48 c7 c7 d4 75 34 a0 e8 87 0e e6 e0 bf 01 00 00 00 e8 9d e0 e5 e0 31 f6 bf 09 00 00 00 e8 e1 ba d6 e0 <0f> 0b 8b 87 10 05 00 00 85 c0 0f 85 5f f9 ff ff 48 c7 c1 70 a5 4f\n<4>[  449.386591] RSP: 0018:ffffc90000170ea0 EFLAGS: 00010297\n<4>[  449.386594] RAX: 0000000080000101 RBX: 0000000000000000 RCX: 0000000000000000\n<4>[  449.386596] RDX: ffff88849d5bc040 RSI: 0000000000000000 RDI: 0000000000000009\n<4>[  449.386598] RBP: ffffc90000170f00 R08: 0000000000000000 R09: 0000000000000000\n<4>[  449.386600] R10: 0000000000000000 R11: 0000000000000000 R12: ffff88843ccea018\n<4>[  449.386602] R13: ffff88843ccea658 R14: ffff88843ccea640 R15: ffff88843ccea000\n<4>[  449.386605] FS:  00007f826a813300(0000) GS:ffff88849fe80000(0000) knlGS:0000000000000000\n<4>[  449.386607] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n<4>[  449.386609] CR2: 0000560366b94280 CR3: 000000048ba02002 CR4: 0000000000760ee0\n<4>[  449.386611] PKRU: 55555554\n<4>[  449.386613] Call Trace:\n<4>[  449.386616]  <IRQ>\n<4>[  449.386646]  ? execlists_submission_tasklet+0xcf/0x140 [i915]\n<4>[  449.386674]  execlists_submission_tasklet+0x2f/0x140 [i915]\n<4>[  449.386679]  tasklet_action_common.isra.16+0x6c/0x1c0\n<4>[  449.386684]  __do_softirq+0xdf/0x49e\n<4>[  449.386687]  irq_exit+0xba/0xc0\n<4>[  449.386690]  smp_apic_timer_interrupt+0xb7/0x280\n<4>[  449.386693]  apic_timer_interrupt+0xf/0x20\n<4>[  449.386695]  </IRQ>\n<4>[  449.386698] RIP: 0010:_raw_spin_unlock_irqrestore+0x49/0x60\n<4>[  449.386701] Code: c7 02 75 1f 53 9d e8 26 ab 75 ff bf 01 00 00 00 e8 7c a3 69 ff 65 8b 05 7d 9b 5c 7e 85 c0 74 0c 5b 5d c3 e8 09 aa 75 ff 53 9d <eb> df e8 ca 39 5b ff 5b 5d c3 0f 1f 00 66 2e 0f 1f 84 00 00 00 00\n<4>[  449.386703] RSP: 0018:ffffc90000a6b950 EFLAGS: 00000202 ORIG_RAX: ffffffffffffff13\n<4>[  449.386706] RAX: 0000000080000001 RBX: 0000000000000202 RCX: 0000000000000000\n<4>[  449.386708] RDX: ffff88849d5bc040 RSI: ffff88849d5bc900 RDI: ffffffff82386f12\n<4>[  449.386710] RBP: ffff88847d400f00 R08: ffff88849d5bc900 R09: 0000000000000000\n<4>[  449.386712] R10: 0000000000000000 R11: 0000000000000000 R12: 00000000ffff0b0b\n<4>[  449.386714] R13: 000000000000000c R14: ffff88847d40bf70 R15: ffff88847d40cef8\n<4>[  449.386742]  reset_csb_pointers+0x59/0x140 [i915]\n<4>[  449.386769]  execlists_sanitize+0x3e/0x60 [i915]\n<4>[  449.386797]  gt_sanitize+0xd6/0x260 [i915]\n\nAs part of the reset preparation, engine->reset.prepare() prevents the\ntasklet from running, so pull the sanitization inside the critical\nsection for reset.\n\nCloses: https://gitlab.freedesktop.org/drm/intel/-/issues/1812\nFixes: 23122a4d992b (\"drm/i915/gt: Scrub execlists state on resume\")\nSigned-off-by: Chris Wilson <chris@chris-wilson.co.uk>\nCc: Mika Kuoppala <mika.kuoppala@linux.intel.com>\nReviewed-by: Mika Kuoppala <mika.kuoppala@linux.intel.com>\nLink: https://patchwork.freedesktop.org/patch/msgid/20200513122826.27484-1-chris@chris-wilson.co.uk",
        "before_after_code_files": [
          "drivers/gpu/drm/i915/gt/intel_gt_pm.c||drivers/gpu/drm/i915/gt/intel_gt_pm.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "drivers/gpu/drm/i915/gt/intel_gt_pm.c||drivers/gpu/drm/i915/gt/intel_gt_pm.c": [
          "File: drivers/gpu/drm/i915/gt/intel_gt_pm.c -> drivers/gpu/drm/i915/gt/intel_gt_pm.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "150:  if (intel_gt_is_wedged(gt))",
          "151:   intel_gt_unset_wedged(gt);",
          "157:  intel_uc_sanitize(&gt->uc);",
          "159:  for_each_engine(engine, gt, id)",
          "",
          "[Removed Lines]",
          "153:  for_each_engine(engine, gt, id)",
          "154:   if (engine->sanitize)",
          "155:    engine->sanitize(engine);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "163:  intel_uc_reset_prepare(&gt->uc);",
          "165:  if (reset_engines(gt) || force) {",
          "166:   for_each_engine(engine, gt, id)",
          "167:    __intel_engine_reset(engine, false);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "161:  for_each_engine(engine, gt, id)",
          "162:   if (engine->sanitize)",
          "163:    engine->sanitize(engine);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "3c6f8cb92c9178fc0c66b580ea3df1fa3ac1155a",
      "candidate_info": {
        "commit_hash": "3c6f8cb92c9178fc0c66b580ea3df1fa3ac1155a",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/3c6f8cb92c9178fc0c66b580ea3df1fa3ac1155a",
        "files": [
          "drivers/usb/host/xhci-ring.c"
        ],
        "message": "usb: xhci: Fix NULL pointer dereference when enqueuing trbs from urb sg list\n\nOn platforms with IOMMU enabled, multiple SGs can be coalesced into one\nby the IOMMU driver. In that case the SG list processing as part of the\ncompletion of a urb on a bulk endpoint can result into a NULL pointer\ndereference with the below stack dump.\n\n<6> Unable to handle kernel NULL pointer dereference at virtual address 0000000c\n<6> pgd = c0004000\n<6> [0000000c] *pgd=00000000\n<6> Internal error: Oops: 5 [#1] PREEMPT SMP ARM\n<2> PC is at xhci_queue_bulk_tx+0x454/0x80c\n<2> LR is at xhci_queue_bulk_tx+0x44c/0x80c\n<2> pc : [<c08907c4>]    lr : [<c08907bc>]    psr: 000000d3\n<2> sp : ca337c80  ip : 00000000  fp : ffffffff\n<2> r10: 00000000  r9 : 50037000  r8 : 00004000\n<2> r7 : 00000000  r6 : 00004000  r5 : 00000000  r4 : 00000000\n<2> r3 : 00000000  r2 : 00000082  r1 : c2c1a200  r0 : 00000000\n<2> Flags: nzcv  IRQs off  FIQs off  Mode SVC_32  ISA ARM  Segment none\n<2> Control: 10c0383d  Table: b412c06a  DAC: 00000051\n<6> Process usb-storage (pid: 5961, stack limit = 0xca336210)\n<snip>\n<2> [<c08907c4>] (xhci_queue_bulk_tx)\n<2> [<c0881b3c>] (xhci_urb_enqueue)\n<2> [<c0831068>] (usb_hcd_submit_urb)\n<2> [<c08350b4>] (usb_sg_wait)\n<2> [<c089f384>] (usb_stor_bulk_transfer_sglist)\n<2> [<c089f2c0>] (usb_stor_bulk_srb)\n<2> [<c089fe38>] (usb_stor_Bulk_transport)\n<2> [<c089f468>] (usb_stor_invoke_transport)\n<2> [<c08a11b4>] (usb_stor_control_thread)\n<2> [<c014a534>] (kthread)\n\nThe above NULL pointer dereference is the result of block_len and the\nsent_len set to zero after the first SG of the list when IOMMU driver\nis enabled. Because of this the loop of processing the SGs has run\nmore than num_sgs which resulted in a sg_next on the last SG of the\nlist which has SG_END set.\n\nFix this by check for the sg before any attributes of the sg are\naccessed.\n\n[modified reason for null pointer dereference in commit message subject -Mathias]\nFixes: f9c589e142d04 (\"xhci: TD-fragment, align the unsplittable case with a bounce buffer\")\nCc: stable@vger.kernel.org\nSigned-off-by: Sriharsha Allenki <sallenki@codeaurora.org>\nSigned-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>\nLink: https://lore.kernel.org/r/20200514110432.25564-2-mathias.nyman@linux.intel.com\nSigned-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>",
        "before_after_code_files": [
          "drivers/usb/host/xhci-ring.c||drivers/usb/host/xhci-ring.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "drivers/usb/host/xhci-ring.c||drivers/usb/host/xhci-ring.c": [
          "File: drivers/usb/host/xhci-ring.c -> drivers/usb/host/xhci-ring.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "3434:    --num_sgs;",
          "3435:    sent_len -= block_len;",
          "3438:     block_len = sg_dma_len(sg);",
          "3439:     addr = (u64) sg_dma_address(sg);",
          "3440:     addr += sent_len;",
          "",
          "[Removed Lines]",
          "3436:    if (num_sgs != 0) {",
          "3437:     sg = sg_next(sg);",
          "",
          "[Added Lines]",
          "3436:    sg = sg_next(sg);",
          "3437:    if (num_sgs != 0 && sg) {",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "7c47a219b95d0e06b5ef5fcc7bad807895015eac",
      "candidate_info": {
        "commit_hash": "7c47a219b95d0e06b5ef5fcc7bad807895015eac",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/7c47a219b95d0e06b5ef5fcc7bad807895015eac",
        "files": [
          "drivers/char/ipmi/ipmi_msghandler.c"
        ],
        "message": "ipmi: use vzalloc instead of kmalloc for user creation\n\nWe met mulitple times of failure of staring bmc-watchdog,\ndue to the runtime memory allocation failure of order 4.\n\n     bmc-watchdog: page allocation failure: order:4, mode:0x40cc0(GFP_KERNEL|__GFP_COMP), nodemask=(null),cpuset=/,mems_allowed=0-1\n     CPU: 1 PID: 2571 Comm: bmc-watchdog Not tainted 5.5.0-00045-g7d6bb61d6188c #1\n     Hardware name: Intel Corporation S2600WFT/S2600WFT, BIOS SE5C620.86B.00.01.0015.110720180833 11/07/2018\n     Call Trace:\n      dump_stack+0x66/0x8b\n      warn_alloc+0xfe/0x160\n      __alloc_pages_slowpath+0xd3e/0xd80\n      __alloc_pages_nodemask+0x2f0/0x340\n      kmalloc_order+0x18/0x70\n      kmalloc_order_trace+0x1d/0xb0\n      ipmi_create_user+0x55/0x2c0 [ipmi_msghandler]\n      ipmi_open+0x72/0x110 [ipmi_devintf]\n      chrdev_open+0xcb/0x1e0\n      do_dentry_open+0x1ce/0x380\n      path_openat+0x305/0x14f0\n      do_filp_open+0x9b/0x110\n      do_sys_open+0x1bd/0x250\n      do_syscall_64+0x5b/0x1f0\n      entry_SYSCALL_64_after_hwframe+0x44/0xa9\n\nUsing vzalloc/vfree for creating ipmi_user heals the\nproblem\n\nThanks to Stephen Rothwell for finding the vmalloc.h\ninclusion issue.\n\nSigned-off-by: Feng Tang <feng.tang@intel.com>\nSigned-off-by: Corey Minyard <cminyard@mvista.com>",
        "before_after_code_files": [
          "drivers/char/ipmi/ipmi_msghandler.c||drivers/char/ipmi/ipmi_msghandler.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "drivers/char/ipmi/ipmi_msghandler.c||drivers/char/ipmi/ipmi_msghandler.c": [
          "File: drivers/char/ipmi/ipmi_msghandler.c -> drivers/char/ipmi/ipmi_msghandler.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "33: #include <linux/workqueue.h>",
          "34: #include <linux/uuid.h>",
          "35: #include <linux/nospec.h>",
          "37: #define IPMI_DRIVER_VERSION \"39.2\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "36: #include <linux/vmalloc.h>",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1153:            remove_work);",
          "1155:  cleanup_srcu_struct(&user->release_barrier);",
          "1157: }",
          "1159: int ipmi_create_user(unsigned int          if_num,",
          "",
          "[Removed Lines]",
          "1156:  kfree(user);",
          "",
          "[Added Lines]",
          "1157:  vfree(user);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1185:  if (rv)",
          "1186:   return rv;",
          "1189:  if (!new_user)",
          "1190:   return -ENOMEM;",
          "",
          "[Removed Lines]",
          "1188:  new_user = kmalloc(sizeof(*new_user), GFP_KERNEL);",
          "",
          "[Added Lines]",
          "1189:  new_user = vzalloc(sizeof(*new_user));",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1233: out_kfree:",
          "1234:  srcu_read_unlock(&ipmi_interfaces_srcu, index);",
          "1236:  return rv;",
          "1237: }",
          "1238: EXPORT_SYMBOL(ipmi_create_user);",
          "",
          "[Removed Lines]",
          "1235:  kfree(new_user);",
          "",
          "[Added Lines]",
          "1236:  vfree(new_user);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "8e7c2a023ac04e04c72cd7b640329511dda92672",
      "candidate_info": {
        "commit_hash": "8e7c2a023ac04e04c72cd7b640329511dda92672",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/8e7c2a023ac04e04c72cd7b640329511dda92672",
        "files": [
          "tools/testing/selftests/bpf/.gitignore",
          "tools/testing/selftests/bpf/Makefile",
          "tools/testing/selftests/bpf/bench.c",
          "tools/testing/selftests/bpf/bench.h",
          "tools/testing/selftests/bpf/benchs/bench_count.c"
        ],
        "message": "selftests/bpf: Add benchmark runner infrastructure\n\nWhile working on BPF ringbuf implementation, testing, and benchmarking, I've\ndeveloped a pretty generic and modular benchmark runner, which seems to be\ngenerically useful, as I've already used it for one more purpose (testing\nfastest way to trigger BPF program, to minimize overhead of in-kernel code).\n\nThis patch adds generic part of benchmark runner and sets up Makefile for\nextending it with more sets of benchmarks.\n\nBenchmarker itself operates by spinning up specified number of producer and\nconsumer threads, setting up interval timer sending SIGALARM signal to\napplication once a second. Every second, current snapshot with hits/drops\ncounters are collected and stored in an array. Drops are useful for\nproducer/consumer benchmarks in which producer might overwhelm consumers.\n\nOnce test finishes after given amount of warm-up and testing seconds, mean and\nstddev are calculated (ignoring warm-up results) and is printed out to stdout.\nThis setup seems to give consistent and accurate results.\n\nTo validate behavior, I added two atomic counting tests: global and local.\nFor global one, all the producer threads are atomically incrementing same\ncounter as fast as possible. This, of course, leads to huge drop of\nperformance once there is more than one producer thread due to CPUs fighting\nfor the same memory location.\n\nLocal counting, on the other hand, maintains one counter per each producer\nthread, incremented independently. Once per second, all counters are read and\nadded together to form final \"counting throughput\" measurement. As expected,\nsuch setup demonstrates linear scalability with number of producers (as long\nas there are enough physical CPU cores, of course). See example output below.\nAlso, this setup can nicely demonstrate disastrous effects of false sharing,\nif care is not taken to take those per-producer counters apart into\nindependent cache lines.\n\nDemo output shows global counter first with 1 producer, then with 4. Both\ntotal and per-producer performance significantly drop. The last run is local\ncounter with 4 producers, demonstrating near-perfect scalability.\n\n$ ./bench -a -w1 -d2 -p1 count-global\nSetting up benchmark 'count-global'...\nBenchmark 'count-global' started.\nIter   0 ( 24.822us): hits  148.179M/s (148.179M/prod), drops    0.000M/s\nIter   1 ( 37.939us): hits  149.308M/s (149.308M/prod), drops    0.000M/s\nIter   2 (-10.774us): hits  150.717M/s (150.717M/prod), drops    0.000M/s\nIter   3 (  3.807us): hits  151.435M/s (151.435M/prod), drops    0.000M/s\nSummary: hits  150.488 \u00b1 1.079M/s (150.488M/prod), drops    0.000 \u00b1 0.000M/s\n\n$ ./bench -a -w1 -d2 -p4 count-global\nSetting up benchmark 'count-global'...\nBenchmark 'count-global' started.\nIter   0 ( 60.659us): hits   53.910M/s ( 13.477M/prod), drops    0.000M/s\nIter   1 (-17.658us): hits   53.722M/s ( 13.431M/prod), drops    0.000M/s\nIter   2 (  5.865us): hits   53.495M/s ( 13.374M/prod), drops    0.000M/s\nIter   3 (  0.104us): hits   53.606M/s ( 13.402M/prod), drops    0.000M/s\nSummary: hits   53.608 \u00b1 0.113M/s ( 13.402M/prod), drops    0.000 \u00b1 0.000M/s\n\n$ ./bench -a -w1 -d2 -p4 count-local\nSetting up benchmark 'count-local'...\nBenchmark 'count-local' started.\nIter   0 ( 23.388us): hits  640.450M/s (160.113M/prod), drops    0.000M/s\nIter   1 (  2.291us): hits  605.661M/s (151.415M/prod), drops    0.000M/s\nIter   2 ( -6.415us): hits  607.092M/s (151.773M/prod), drops    0.000M/s\nIter   3 ( -1.361us): hits  601.796M/s (150.449M/prod), drops    0.000M/s\nSummary: hits  604.849 \u00b1 2.739M/s (151.212M/prod), drops    0.000 \u00b1 0.000M/s\n\nBenchmark runner supports setting thread affinity for producer and consumer\nthreads. You can use -a flag for default CPU selection scheme, where first\nconsumer gets CPU #0, next one gets CPU #1, and so on. Then producer threads\npick up next CPU and increment one-by-one as well. But user can also specify\na set of CPUs independently for producers and consumers with --prod-affinity\n1,2-10,15 and --cons-affinity <set-of-cpus>. The latter allows to force\nproducers and consumers to share same set of CPUs, if necessary.\n\nSigned-off-by: Andrii Nakryiko <andriin@fb.com>\nSigned-off-by: Alexei Starovoitov <ast@kernel.org>\nAcked-by: Yonghong Song <yhs@fb.com>\nLink: https://lore.kernel.org/bpf/20200512192445.2351848-3-andriin@fb.com",
        "before_after_code_files": [
          "tools/testing/selftests/bpf/bench.c||tools/testing/selftests/bpf/bench.c",
          "tools/testing/selftests/bpf/bench.h||tools/testing/selftests/bpf/bench.h",
          "tools/testing/selftests/bpf/benchs/bench_count.c||tools/testing/selftests/bpf/benchs/bench_count.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "tools/testing/selftests/bpf/bench.c||tools/testing/selftests/bpf/bench.c": [
          "File: tools/testing/selftests/bpf/bench.c -> tools/testing/selftests/bpf/bench.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3: #define _GNU_SOURCE",
          "4: #include <argp.h>",
          "5: #include <linux/compiler.h>",
          "6: #include <sys/time.h>",
          "7: #include <sched.h>",
          "8: #include <fcntl.h>",
          "9: #include <pthread.h>",
          "10: #include <sys/sysinfo.h>",
          "11: #include <sys/resource.h>",
          "12: #include <signal.h>",
          "13: #include \"bench.h\"",
          "14: #include \"testing_helpers.h\"",
          "16: struct env env = {",
          "17:  .warmup_sec = 1,",
          "18:  .duration_sec = 5,",
          "19:  .affinity = false,",
          "20:  .consumer_cnt = 1,",
          "21:  .producer_cnt = 1,",
          "22: };",
          "24: static int libbpf_print_fn(enum libbpf_print_level level,",
          "25:       const char *format, va_list args)",
          "26: {",
          "27:  if (level == LIBBPF_DEBUG && !env.verbose)",
          "28:   return 0;",
          "29:  return vfprintf(stderr, format, args);",
          "30: }",
          "32: static int bump_memlock_rlimit(void)",
          "33: {",
          "34:  struct rlimit rlim_new = {",
          "35:   .rlim_cur = RLIM_INFINITY,",
          "36:   .rlim_max = RLIM_INFINITY,",
          "37:  };",
          "39:  return setrlimit(RLIMIT_MEMLOCK, &rlim_new);",
          "40: }",
          "42: void setup_libbpf()",
          "43: {",
          "44:  int err;",
          "46:  libbpf_set_print(libbpf_print_fn);",
          "48:  err = bump_memlock_rlimit();",
          "49:  if (err)",
          "50:   fprintf(stderr, \"failed to increase RLIMIT_MEMLOCK: %d\", err);",
          "51: }",
          "53: void hits_drops_report_progress(int iter, struct bench_res *res, long delta_ns)",
          "54: {",
          "55:  double hits_per_sec, drops_per_sec;",
          "56:  double hits_per_prod;",
          "58:  hits_per_sec = res->hits / 1000000.0 / (delta_ns / 1000000000.0);",
          "59:  hits_per_prod = hits_per_sec / env.producer_cnt;",
          "60:  drops_per_sec = res->drops / 1000000.0 / (delta_ns / 1000000000.0);",
          "62:  printf(\"Iter %3d (%7.3lfus): \",",
          "63:         iter, (delta_ns - 1000000000) / 1000.0);",
          "65:  printf(\"hits %8.3lfM/s (%7.3lfM/prod), drops %8.3lfM/s\\n\",",
          "66:         hits_per_sec, hits_per_prod, drops_per_sec);",
          "67: }",
          "69: void hits_drops_report_final(struct bench_res res[], int res_cnt)",
          "70: {",
          "71:  int i;",
          "72:  double hits_mean = 0.0, drops_mean = 0.0;",
          "73:  double hits_stddev = 0.0, drops_stddev = 0.0;",
          "75:  for (i = 0; i < res_cnt; i++) {",
          "76:   hits_mean += res[i].hits / 1000000.0 / (0.0 + res_cnt);",
          "77:   drops_mean += res[i].drops / 1000000.0 / (0.0 + res_cnt);",
          "78:  }",
          "80:  if (res_cnt > 1)  {",
          "81:   for (i = 0; i < res_cnt; i++) {",
          "82:    hits_stddev += (hits_mean - res[i].hits / 1000000.0) *",
          "83:            (hits_mean - res[i].hits / 1000000.0) /",
          "84:            (res_cnt - 1.0);",
          "85:    drops_stddev += (drops_mean - res[i].drops / 1000000.0) *",
          "86:      (drops_mean - res[i].drops / 1000000.0) /",
          "87:      (res_cnt - 1.0);",
          "88:   }",
          "89:   hits_stddev = sqrt(hits_stddev);",
          "90:   drops_stddev = sqrt(drops_stddev);",
          "91:  }",
          "92:  printf(\"Summary: hits %8.3lf \\u00B1 %5.3lfM/s (%7.3lfM/prod), \",",
          "93:         hits_mean, hits_stddev, hits_mean / env.producer_cnt);",
          "94:  printf(\"drops %8.3lf \\u00B1 %5.3lfM/s\\n\",",
          "95:         drops_mean, drops_stddev);",
          "96: }",
          "98: const char *argp_program_version = \"benchmark\";",
          "99: const char *argp_program_bug_address = \"<bpf@vger.kernel.org>\";",
          "100: const char argp_program_doc[] =",
          "101: \"benchmark    Generic benchmarking framework.\\n\"",
          "102: \"\\n\"",
          "103: \"This tool runs benchmarks.\\n\"",
          "104: \"\\n\"",
          "105: \"USAGE: benchmark <bench-name>\\n\"",
          "106: \"\\n\"",
          "107: \"EXAMPLES:\\n\"",
          "108: \"    # run 'count-local' benchmark with 1 producer and 1 consumer\\n\"",
          "109: \"    benchmark count-local\\n\"",
          "110: \"    # run 'count-local' with 16 producer and 8 consumer thread, pinned to CPUs\\n\"",
          "111: \"    benchmark -p16 -c8 -a count-local\\n\";",
          "113: enum {",
          "114:  ARG_PROD_AFFINITY_SET = 1000,",
          "115:  ARG_CONS_AFFINITY_SET = 1001,",
          "116: };",
          "118: static const struct argp_option opts[] = {",
          "119:  { \"list\", 'l', NULL, 0, \"List available benchmarks\"},",
          "120:  { \"duration\", 'd', \"SEC\", 0, \"Duration of benchmark, seconds\"},",
          "121:  { \"warmup\", 'w', \"SEC\", 0, \"Warm-up period, seconds\"},",
          "122:  { \"producers\", 'p', \"NUM\", 0, \"Number of producer threads\"},",
          "123:  { \"consumers\", 'c', \"NUM\", 0, \"Number of consumer threads\"},",
          "124:  { \"verbose\", 'v', NULL, 0, \"Verbose debug output\"},",
          "125:  { \"affinity\", 'a', NULL, 0, \"Set consumer/producer thread affinity\"},",
          "126:  { \"prod-affinity\", ARG_PROD_AFFINITY_SET, \"CPUSET\", 0,",
          "127:    \"Set of CPUs for producer threads; implies --affinity\"},",
          "128:  { \"cons-affinity\", ARG_CONS_AFFINITY_SET, \"CPUSET\", 0,",
          "129:    \"Set of CPUs for consumer threads; implies --affinity\"},",
          "130:  {},",
          "131: };",
          "133: static error_t parse_arg(int key, char *arg, struct argp_state *state)",
          "134: {",
          "135:  static int pos_args;",
          "137:  switch (key) {",
          "138:  case 'v':",
          "139:   env.verbose = true;",
          "140:   break;",
          "141:  case 'l':",
          "142:   env.list = true;",
          "143:   break;",
          "144:  case 'd':",
          "145:   env.duration_sec = strtol(arg, NULL, 10);",
          "146:   if (env.duration_sec <= 0) {",
          "147:    fprintf(stderr, \"Invalid duration: %s\\n\", arg);",
          "148:    argp_usage(state);",
          "149:   }",
          "150:   break;",
          "151:  case 'w':",
          "152:   env.warmup_sec = strtol(arg, NULL, 10);",
          "153:   if (env.warmup_sec <= 0) {",
          "154:    fprintf(stderr, \"Invalid warm-up duration: %s\\n\", arg);",
          "155:    argp_usage(state);",
          "156:   }",
          "157:   break;",
          "158:  case 'p':",
          "159:   env.producer_cnt = strtol(arg, NULL, 10);",
          "160:   if (env.producer_cnt <= 0) {",
          "161:    fprintf(stderr, \"Invalid producer count: %s\\n\", arg);",
          "162:    argp_usage(state);",
          "163:   }",
          "164:   break;",
          "165:  case 'c':",
          "166:   env.consumer_cnt = strtol(arg, NULL, 10);",
          "167:   if (env.consumer_cnt <= 0) {",
          "168:    fprintf(stderr, \"Invalid consumer count: %s\\n\", arg);",
          "169:    argp_usage(state);",
          "170:   }",
          "171:   break;",
          "172:  case 'a':",
          "173:   env.affinity = true;",
          "174:   break;",
          "175:  case ARG_PROD_AFFINITY_SET:",
          "176:   env.affinity = true;",
          "177:   if (parse_num_list(arg, &env.prod_cpus.cpus,",
          "178:        &env.prod_cpus.cpus_len)) {",
          "179:    fprintf(stderr, \"Invalid format of CPU set for producers.\");",
          "180:    argp_usage(state);",
          "181:   }",
          "182:   break;",
          "183:  case ARG_CONS_AFFINITY_SET:",
          "184:   env.affinity = true;",
          "185:   if (parse_num_list(arg, &env.cons_cpus.cpus,",
          "186:        &env.cons_cpus.cpus_len)) {",
          "187:    fprintf(stderr, \"Invalid format of CPU set for consumers.\");",
          "188:    argp_usage(state);",
          "189:   }",
          "190:   break;",
          "191:  case ARGP_KEY_ARG:",
          "192:   if (pos_args++) {",
          "193:    fprintf(stderr,",
          "194:     \"Unrecognized positional argument: %s\\n\", arg);",
          "195:    argp_usage(state);",
          "196:   }",
          "197:   env.bench_name = strdup(arg);",
          "198:   break;",
          "199:  default:",
          "200:   return ARGP_ERR_UNKNOWN;",
          "201:  }",
          "202:  return 0;",
          "203: }",
          "205: static void parse_cmdline_args(int argc, char **argv)",
          "206: {",
          "207:  static const struct argp argp = {",
          "208:   .options = opts,",
          "209:   .parser = parse_arg,",
          "210:   .doc = argp_program_doc,",
          "211:  };",
          "212:  if (argp_parse(&argp, argc, argv, 0, NULL, NULL))",
          "213:   exit(1);",
          "214:  if (!env.list && !env.bench_name) {",
          "215:   argp_help(&argp, stderr, ARGP_HELP_DOC, \"bench\");",
          "216:   exit(1);",
          "217:  }",
          "218: }",
          "220: static void collect_measurements(long delta_ns);",
          "222: static __u64 last_time_ns;",
          "223: static void sigalarm_handler(int signo)",
          "224: {",
          "225:  long new_time_ns = get_time_ns();",
          "226:  long delta_ns = new_time_ns - last_time_ns;",
          "228:  collect_measurements(delta_ns);",
          "230:  last_time_ns = new_time_ns;",
          "231: }",
          "234: static void setup_timer()",
          "235: {",
          "236:  static struct sigaction sigalarm_action = {",
          "237:   .sa_handler = sigalarm_handler,",
          "238:  };",
          "239:  struct itimerval timer_settings = {};",
          "240:  int err;",
          "242:  last_time_ns = get_time_ns();",
          "243:  err = sigaction(SIGALRM, &sigalarm_action, NULL);",
          "244:  if (err < 0) {",
          "245:   fprintf(stderr, \"failed to install SIGALARM handler: %d\\n\", -errno);",
          "246:   exit(1);",
          "247:  }",
          "248:  timer_settings.it_interval.tv_sec = 1;",
          "249:  timer_settings.it_value.tv_sec = 1;",
          "250:  err = setitimer(ITIMER_REAL, &timer_settings, NULL);",
          "251:  if (err < 0) {",
          "252:   fprintf(stderr, \"failed to arm interval timer: %d\\n\", -errno);",
          "253:   exit(1);",
          "254:  }",
          "255: }",
          "257: static void set_thread_affinity(pthread_t thread, int cpu)",
          "258: {",
          "259:  cpu_set_t cpuset;",
          "261:  CPU_ZERO(&cpuset);",
          "262:  CPU_SET(cpu, &cpuset);",
          "263:  if (pthread_setaffinity_np(thread, sizeof(cpuset), &cpuset)) {",
          "264:   fprintf(stderr, \"setting affinity to CPU #%d failed: %d\\n\",",
          "265:    cpu, errno);",
          "266:   exit(1);",
          "267:  }",
          "268: }",
          "270: static int next_cpu(struct cpu_set *cpu_set)",
          "271: {",
          "272:  if (cpu_set->cpus) {",
          "273:   int i;",
          "276:   for (i = cpu_set->next_cpu; i < cpu_set->cpus_len; i++) {",
          "277:    if (cpu_set->cpus[i]) {",
          "278:     cpu_set->next_cpu = i + 1;",
          "279:     return i;",
          "280:    }",
          "281:   }",
          "282:   fprintf(stderr, \"Not enough CPUs specified, need CPU #%d or higher.\\n\", i);",
          "283:   exit(1);",
          "284:  }",
          "286:  return cpu_set->next_cpu++;",
          "287: }",
          "289: static struct bench_state {",
          "290:  int res_cnt;",
          "291:  struct bench_res *results;",
          "292:  pthread_t *consumers;",
          "293:  pthread_t *producers;",
          "294: } state;",
          "296: const struct bench *bench = NULL;",
          "298: extern const struct bench bench_count_global;",
          "299: extern const struct bench bench_count_local;",
          "301: static const struct bench *benchs[] = {",
          "302:  &bench_count_global,",
          "303:  &bench_count_local,",
          "304: };",
          "306: static void setup_benchmark()",
          "307: {",
          "308:  int i, err;",
          "310:  if (!env.bench_name) {",
          "311:   fprintf(stderr, \"benchmark name is not specified\\n\");",
          "312:   exit(1);",
          "313:  }",
          "315:  for (i = 0; i < ARRAY_SIZE(benchs); i++) {",
          "316:   if (strcmp(benchs[i]->name, env.bench_name) == 0) {",
          "317:    bench = benchs[i];",
          "318:    break;",
          "319:   }",
          "320:  }",
          "321:  if (!bench) {",
          "322:   fprintf(stderr, \"benchmark '%s' not found\\n\", env.bench_name);",
          "323:   exit(1);",
          "324:  }",
          "326:  printf(\"Setting up benchmark '%s'...\\n\", bench->name);",
          "328:  state.producers = calloc(env.producer_cnt, sizeof(*state.producers));",
          "329:  state.consumers = calloc(env.consumer_cnt, sizeof(*state.consumers));",
          "330:  state.results = calloc(env.duration_sec + env.warmup_sec + 2,",
          "331:           sizeof(*state.results));",
          "332:  if (!state.producers || !state.consumers || !state.results)",
          "333:   exit(1);",
          "335:  if (bench->validate)",
          "336:   bench->validate();",
          "337:  if (bench->setup)",
          "338:   bench->setup();",
          "340:  for (i = 0; i < env.consumer_cnt; i++) {",
          "341:   err = pthread_create(&state.consumers[i], NULL,",
          "342:          bench->consumer_thread, (void *)(long)i);",
          "343:   if (err) {",
          "344:    fprintf(stderr, \"failed to create consumer thread #%d: %d\\n\",",
          "345:     i, -errno);",
          "346:    exit(1);",
          "347:   }",
          "348:   if (env.affinity)",
          "349:    set_thread_affinity(state.consumers[i],",
          "350:          next_cpu(&env.cons_cpus));",
          "351:  }",
          "356:  if (!env.prod_cpus.cpus)",
          "357:   env.prod_cpus.next_cpu = env.cons_cpus.next_cpu;",
          "359:  for (i = 0; i < env.producer_cnt; i++) {",
          "360:   err = pthread_create(&state.producers[i], NULL,",
          "361:          bench->producer_thread, (void *)(long)i);",
          "362:   if (err) {",
          "363:    fprintf(stderr, \"failed to create producer thread #%d: %d\\n\",",
          "364:     i, -errno);",
          "365:    exit(1);",
          "366:   }",
          "367:   if (env.affinity)",
          "368:    set_thread_affinity(state.producers[i],",
          "369:          next_cpu(&env.prod_cpus));",
          "370:  }",
          "372:  printf(\"Benchmark '%s' started.\\n\", bench->name);",
          "373: }",
          "375: static pthread_mutex_t bench_done_mtx = PTHREAD_MUTEX_INITIALIZER;",
          "376: static pthread_cond_t bench_done = PTHREAD_COND_INITIALIZER;",
          "378: static void collect_measurements(long delta_ns) {",
          "379:  int iter = state.res_cnt++;",
          "380:  struct bench_res *res = &state.results[iter];",
          "382:  bench->measure(res);",
          "384:  if (bench->report_progress)",
          "385:   bench->report_progress(iter, res, delta_ns);",
          "387:  if (iter == env.duration_sec + env.warmup_sec) {",
          "388:   pthread_mutex_lock(&bench_done_mtx);",
          "389:   pthread_cond_signal(&bench_done);",
          "390:   pthread_mutex_unlock(&bench_done_mtx);",
          "391:  }",
          "392: }",
          "394: int main(int argc, char **argv)",
          "395: {",
          "396:  parse_cmdline_args(argc, argv);",
          "398:  if (env.list) {",
          "399:   int i;",
          "401:   printf(\"Available benchmarks:\\n\");",
          "402:   for (i = 0; i < ARRAY_SIZE(benchs); i++) {",
          "403:    printf(\"- %s\\n\", benchs[i]->name);",
          "404:   }",
          "405:   return 0;",
          "406:  }",
          "408:  setup_benchmark();",
          "410:  setup_timer();",
          "412:  pthread_mutex_lock(&bench_done_mtx);",
          "413:  pthread_cond_wait(&bench_done, &bench_done_mtx);",
          "414:  pthread_mutex_unlock(&bench_done_mtx);",
          "416:  if (bench->report_final)",
          "418:   bench->report_final(state.results + env.warmup_sec,",
          "419:         state.res_cnt - env.warmup_sec);",
          "421:  return 0;",
          "422: }",
          "",
          "---------------"
        ],
        "tools/testing/selftests/bpf/bench.h||tools/testing/selftests/bpf/bench.h": [
          "File: tools/testing/selftests/bpf/bench.h -> tools/testing/selftests/bpf/bench.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2: #pragma once",
          "3: #include <stdlib.h>",
          "4: #include <stdbool.h>",
          "5: #include <linux/err.h>",
          "6: #include <errno.h>",
          "7: #include <unistd.h>",
          "8: #include <bpf/bpf.h>",
          "9: #include <bpf/libbpf.h>",
          "10: #include <math.h>",
          "11: #include <time.h>",
          "12: #include <sys/syscall.h>",
          "14: struct cpu_set {",
          "15:  bool *cpus;",
          "16:  int cpus_len;",
          "17:  int next_cpu;",
          "18: };",
          "20: struct env {",
          "21:  char *bench_name;",
          "22:  int duration_sec;",
          "23:  int warmup_sec;",
          "24:  bool verbose;",
          "25:  bool list;",
          "26:  bool affinity;",
          "27:  int consumer_cnt;",
          "28:  int producer_cnt;",
          "29:  struct cpu_set prod_cpus;",
          "30:  struct cpu_set cons_cpus;",
          "31: };",
          "33: struct bench_res {",
          "34:  long hits;",
          "35:  long drops;",
          "36: };",
          "38: struct bench {",
          "39:  const char *name;",
          "40:  void (*validate)();",
          "41:  void (*setup)();",
          "42:  void *(*producer_thread)(void *ctx);",
          "43:  void *(*consumer_thread)(void *ctx);",
          "44:  void (*measure)(struct bench_res* res);",
          "45:  void (*report_progress)(int iter, struct bench_res* res, long delta_ns);",
          "46:  void (*report_final)(struct bench_res res[], int res_cnt);",
          "47: };",
          "49: struct counter {",
          "50:  long value;",
          "51: } __attribute__((aligned(128)));",
          "53: extern struct env env;",
          "54: extern const struct bench *bench;",
          "56: void setup_libbpf();",
          "57: void hits_drops_report_progress(int iter, struct bench_res *res, long delta_ns);",
          "58: void hits_drops_report_final(struct bench_res res[], int res_cnt);",
          "60: static inline __u64 get_time_ns() {",
          "61:  struct timespec t;",
          "63:  clock_gettime(CLOCK_MONOTONIC, &t);",
          "65:  return (u64)t.tv_sec * 1000000000 + t.tv_nsec;",
          "66: }",
          "68: static inline void atomic_inc(long *value)",
          "69: {",
          "70:  (void)__atomic_add_fetch(value, 1, __ATOMIC_RELAXED);",
          "71: }",
          "73: static inline void atomic_add(long *value, long n)",
          "74: {",
          "75:  (void)__atomic_add_fetch(value, n, __ATOMIC_RELAXED);",
          "76: }",
          "78: static inline long atomic_swap(long *value, long n)",
          "79: {",
          "80:  return __atomic_exchange_n(value, n, __ATOMIC_RELAXED);",
          "81: }",
          "",
          "---------------"
        ],
        "tools/testing/selftests/bpf/benchs/bench_count.c||tools/testing/selftests/bpf/benchs/bench_count.c": [
          "File: tools/testing/selftests/bpf/benchs/bench_count.c -> tools/testing/selftests/bpf/benchs/bench_count.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3: #include \"bench.h\"",
          "7: static struct count_global_ctx {",
          "8:  struct counter hits;",
          "9: } count_global_ctx;",
          "11: static void *count_global_producer(void *input)",
          "12: {",
          "13:  struct count_global_ctx *ctx = &count_global_ctx;",
          "15:  while (true) {",
          "16:   atomic_inc(&ctx->hits.value);",
          "17:  }",
          "18:  return NULL;",
          "19: }",
          "21: static void *count_global_consumer(void *input)",
          "22: {",
          "23:  return NULL;",
          "24: }",
          "26: static void count_global_measure(struct bench_res *res)",
          "27: {",
          "28:  struct count_global_ctx *ctx = &count_global_ctx;",
          "30:  res->hits = atomic_swap(&ctx->hits.value, 0);",
          "31: }",
          "35: static struct count_local_ctx {",
          "36:  struct counter *hits;",
          "37: } count_local_ctx;",
          "39: static void count_local_setup()",
          "40: {",
          "41:  struct count_local_ctx *ctx = &count_local_ctx;",
          "43:  ctx->hits = calloc(env.consumer_cnt, sizeof(*ctx->hits));",
          "44:  if (!ctx->hits)",
          "45:   exit(1);",
          "46: }",
          "48: static void *count_local_producer(void *input)",
          "49: {",
          "50:  struct count_local_ctx *ctx = &count_local_ctx;",
          "51:  int idx = (long)input;",
          "53:  while (true) {",
          "54:   atomic_inc(&ctx->hits[idx].value);",
          "55:  }",
          "56:  return NULL;",
          "57: }",
          "59: static void *count_local_consumer(void *input)",
          "60: {",
          "61:  return NULL;",
          "62: }",
          "64: static void count_local_measure(struct bench_res *res)",
          "65: {",
          "66:  struct count_local_ctx *ctx = &count_local_ctx;",
          "67:  int i;",
          "69:  for (i = 0; i < env.producer_cnt; i++) {",
          "70:   res->hits += atomic_swap(&ctx->hits[i].value, 0);",
          "71:  }",
          "72: }",
          "74: const struct bench bench_count_global = {",
          "75:  .name = \"count-global\",",
          "76:  .producer_thread = count_global_producer,",
          "77:  .consumer_thread = count_global_consumer,",
          "78:  .measure = count_global_measure,",
          "79:  .report_progress = hits_drops_report_progress,",
          "80:  .report_final = hits_drops_report_final,",
          "81: };",
          "83: const struct bench bench_count_local = {",
          "84:  .name = \"count-local\",",
          "85:  .setup = count_local_setup,",
          "86:  .producer_thread = count_local_producer,",
          "87:  .consumer_thread = count_local_consumer,",
          "88:  .measure = count_local_measure,",
          "89:  .report_progress = hits_drops_report_progress,",
          "90:  .report_final = hits_drops_report_final,",
          "91: };",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "59566b0b622e3e6ea928c0b8cac8a5601b00b383",
      "candidate_info": {
        "commit_hash": "59566b0b622e3e6ea928c0b8cac8a5601b00b383",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/59566b0b622e3e6ea928c0b8cac8a5601b00b383",
        "files": [
          "arch/x86/include/asm/ftrace.h",
          "arch/x86/kernel/ftrace.c",
          "arch/x86/mm/init_64.c",
          "include/linux/ftrace.h",
          "kernel/trace/ftrace_internal.h"
        ],
        "message": "x86/ftrace: Have ftrace trampolines turn read-only at the end of system boot up\n\nBooting one of my machines, it triggered the following crash:\n\n Kernel/User page tables isolation: enabled\n ftrace: allocating 36577 entries in 143 pages\n Starting tracer 'function'\n BUG: unable to handle page fault for address: ffffffffa000005c\n #PF: supervisor write access in kernel mode\n #PF: error_code(0x0003) - permissions violation\n PGD 2014067 P4D 2014067 PUD 2015063 PMD 7b253067 PTE 7b252061\n Oops: 0003 [#1] PREEMPT SMP PTI\n CPU: 0 PID: 0 Comm: swapper Not tainted 5.4.0-test+ #24\n Hardware name: To Be Filled By O.E.M. To Be Filled By O.E.M./To be filled by O.E.M., BIOS SDBLI944.86P 05/08/2007\n RIP: 0010:text_poke_early+0x4a/0x58\n Code: 34 24 48 89 54 24 08 e8 bf 72 0b 00 48 8b 34 24 48 8b 4c 24 08 84 c0 74 0b 48 89 df f3 a4 48 83 c4 10 5b c3 9c 58 fa 48 89 df <f3> a4 50 9d 48 83 c4 10 5b e9 d6 f9 ff ff\n0 41 57 49\n RSP: 0000:ffffffff82003d38 EFLAGS: 00010046\n RAX: 0000000000000046 RBX: ffffffffa000005c RCX: 0000000000000005\n RDX: 0000000000000005 RSI: ffffffff825b9a90 RDI: ffffffffa000005c\n RBP: ffffffffa000005c R08: 0000000000000000 R09: ffffffff8206e6e0\n R10: ffff88807b01f4c0 R11: ffffffff8176c106 R12: ffffffff8206e6e0\n R13: ffffffff824f2440 R14: 0000000000000000 R15: ffffffff8206eac0\n FS:  0000000000000000(0000) GS:ffff88807d400000(0000) knlGS:0000000000000000\n CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n CR2: ffffffffa000005c CR3: 0000000002012000 CR4: 00000000000006b0\n Call Trace:\n  text_poke_bp+0x27/0x64\n  ? mutex_lock+0x36/0x5d\n  arch_ftrace_update_trampoline+0x287/0x2d5\n  ? ftrace_replace_code+0x14b/0x160\n  ? ftrace_update_ftrace_func+0x65/0x6c\n  __register_ftrace_function+0x6d/0x81\n  ftrace_startup+0x23/0xc1\n  register_ftrace_function+0x20/0x37\n  func_set_flag+0x59/0x77\n  __set_tracer_option.isra.19+0x20/0x3e\n  trace_set_options+0xd6/0x13e\n  apply_trace_boot_options+0x44/0x6d\n  register_tracer+0x19e/0x1ac\n  early_trace_init+0x21b/0x2c9\n  start_kernel+0x241/0x518\n  ? load_ucode_intel_bsp+0x21/0x52\n  secondary_startup_64+0xa4/0xb0\n\nI was able to trigger it on other machines, when I added to the kernel\ncommand line of both \"ftrace=function\" and \"trace_options=func_stack_trace\".\n\nThe cause is the \"ftrace=function\" would register the function tracer\nand create a trampoline, and it will set it as executable and\nread-only. Then the \"trace_options=func_stack_trace\" would then update\nthe same trampoline to include the stack tracer version of the function\ntracer. But since the trampoline already exists, it updates it with\ntext_poke_bp(). The problem is that text_poke_bp() called while\nsystem_state == SYSTEM_BOOTING, it will simply do a memcpy() and not\nthe page mapping, as it would think that the text is still read-write.\nBut in this case it is not, and we take a fault and crash.\n\nInstead, lets keep the ftrace trampolines read-write during boot up,\nand then when the kernel executable text is set to read-only, the\nftrace trampolines get set to read-only as well.\n\nLink: https://lkml.kernel.org/r/20200430202147.4dc6e2de@oasis.local.home\n\nCc: Ingo Molnar <mingo@kernel.org>\nCc: Thomas Gleixner <tglx@linutronix.de>\nCc: Andy Lutomirski <luto@amacapital.net>\nCc: Borislav Petkov <bp@alien8.de>\nCc: Josh Poimboeuf <jpoimboe@redhat.com>\nCc: \"H. Peter Anvin\" <hpa@zytor.com>\nCc: stable@vger.kernel.org\nFixes: 768ae4406a5c (\"x86/ftrace: Use text_poke()\")\nAcked-by: Peter Zijlstra <peterz@infradead.org>\nSigned-off-by: Steven Rostedt (VMware) <rostedt@goodmis.org>",
        "before_after_code_files": [
          "arch/x86/include/asm/ftrace.h||arch/x86/include/asm/ftrace.h",
          "arch/x86/kernel/ftrace.c||arch/x86/kernel/ftrace.c",
          "arch/x86/mm/init_64.c||arch/x86/mm/init_64.c",
          "include/linux/ftrace.h||include/linux/ftrace.h",
          "kernel/trace/ftrace_internal.h||kernel/trace/ftrace_internal.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "arch/x86/include/asm/ftrace.h||arch/x86/include/asm/ftrace.h": [
          "File: arch/x86/include/asm/ftrace.h -> arch/x86/include/asm/ftrace.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "57: #ifndef __ASSEMBLY__",
          "59: #define ARCH_HAS_SYSCALL_MATCH_SYM_NAME",
          "60: static inline bool arch_syscall_match_sym_name(const char *sym, const char *name)",
          "61: {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "59: #if defined(CONFIG_FUNCTION_TRACER) && defined(CONFIG_DYNAMIC_FTRACE)",
          "60: extern void set_ftrace_ops_ro(void);",
          "61: #else",
          "62: static inline void set_ftrace_ops_ro(void) { }",
          "63: #endif",
          "",
          "---------------"
        ],
        "arch/x86/kernel/ftrace.c||arch/x86/kernel/ftrace.c": [
          "File: arch/x86/kernel/ftrace.c -> arch/x86/kernel/ftrace.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "408:  set_vm_flush_reset_perms(trampoline);",
          "411:  set_memory_x((unsigned long)trampoline, npages);",
          "412:  return (unsigned long)trampoline;",
          "413: fail:",
          "",
          "[Removed Lines]",
          "410:  set_memory_ro((unsigned long)trampoline, npages);",
          "",
          "[Added Lines]",
          "410:  if (likely(system_state != SYSTEM_BOOTING))",
          "411:   set_memory_ro((unsigned long)trampoline, npages);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "415:  return 0;",
          "416: }",
          "418: static unsigned long calc_trampoline_call_offset(bool save_regs)",
          "419: {",
          "420:  unsigned long start_offset;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "419: void set_ftrace_ops_ro(void)",
          "420: {",
          "421:  struct ftrace_ops *ops;",
          "422:  unsigned long start_offset;",
          "423:  unsigned long end_offset;",
          "424:  unsigned long npages;",
          "425:  unsigned long size;",
          "427:  do_for_each_ftrace_op(ops, ftrace_ops_list) {",
          "428:   if (!(ops->flags & FTRACE_OPS_FL_ALLOC_TRAMP))",
          "429:    continue;",
          "431:   if (ops->flags & FTRACE_OPS_FL_SAVE_REGS) {",
          "432:    start_offset = (unsigned long)ftrace_regs_caller;",
          "433:    end_offset = (unsigned long)ftrace_regs_caller_end;",
          "434:   } else {",
          "435:    start_offset = (unsigned long)ftrace_caller;",
          "436:    end_offset = (unsigned long)ftrace_epilogue;",
          "437:   }",
          "438:   size = end_offset - start_offset;",
          "439:   size = size + RET_SIZE + sizeof(void *);",
          "440:   npages = DIV_ROUND_UP(size, PAGE_SIZE);",
          "441:   set_memory_ro((unsigned long)ops->trampoline, npages);",
          "442:  } while_for_each_ftrace_op(ops);",
          "443: }",
          "",
          "---------------"
        ],
        "arch/x86/mm/init_64.c||arch/x86/mm/init_64.c": [
          "File: arch/x86/mm/init_64.c -> arch/x86/mm/init_64.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "54: #include <asm/init.h>",
          "55: #include <asm/uv/uv.h>",
          "56: #include <asm/setup.h>",
          "58: #include \"mm_internal.h\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "57: #include <asm/ftrace.h>",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1291:  all_end = roundup((unsigned long)_brk_end, PMD_SIZE);",
          "1292:  set_memory_nx(text_end, (all_end - text_end) >> PAGE_SHIFT);",
          "1294: #ifdef CONFIG_CPA_DEBUG",
          "1295:  printk(KERN_INFO \"Testing CPA: undo %lx-%lx\\n\", start, end);",
          "1296:  set_memory_rw(start, (end-start) >> PAGE_SHIFT);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1295:  set_ftrace_ops_ro();",
          "",
          "---------------"
        ],
        "include/linux/ftrace.h||include/linux/ftrace.h": [
          "File: include/linux/ftrace.h -> include/linux/ftrace.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "210: #endif",
          "211: };",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "213: extern struct ftrace_ops __rcu *ftrace_ops_list;",
          "214: extern struct ftrace_ops ftrace_list_end;",
          "225: #define do_for_each_ftrace_op(op, list)   \\",
          "226:  op = rcu_dereference_raw_check(list);   \\",
          "227:  do",
          "232: #define while_for_each_ftrace_op(op)    \\",
          "233:  while (likely(op = rcu_dereference_raw_check((op)->next)) && \\",
          "234:         unlikely((op) != &ftrace_list_end))",
          "",
          "---------------"
        ],
        "kernel/trace/ftrace_internal.h||kernel/trace/ftrace_internal.h": [
          "File: kernel/trace/ftrace_internal.h -> kernel/trace/ftrace_internal.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "5: #ifdef CONFIG_FUNCTION_TRACER",
          "29: extern struct mutex ftrace_lock;",
          "30: extern struct ftrace_ops global_ops;",
          "",
          "[Removed Lines]",
          "16: #define do_for_each_ftrace_op(op, list)   \\",
          "17:  op = rcu_dereference_raw_check(list);   \\",
          "18:  do",
          "23: #define while_for_each_ftrace_op(op)    \\",
          "24:  while (likely(op = rcu_dereference_raw_check((op)->next)) && \\",
          "25:         unlikely((op) != &ftrace_list_end))",
          "27: extern struct ftrace_ops __rcu *ftrace_ops_list;",
          "28: extern struct ftrace_ops ftrace_list_end;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    }
  ]
}
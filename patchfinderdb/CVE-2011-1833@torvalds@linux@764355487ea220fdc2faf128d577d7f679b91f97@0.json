{
  "cve_id": "CVE-2011-1833",
  "cve_desc": "Race condition in the ecryptfs_mount function in fs/ecryptfs/main.c in the eCryptfs subsystem in the Linux kernel before 3.1 allows local users to bypass intended file permissions via a mount.ecryptfs_private mount with a mismatched uid.",
  "repo": "torvalds/linux",
  "patch_hash": "764355487ea220fdc2faf128d577d7f679b91f97",
  "patch_info": {
    "commit_hash": "764355487ea220fdc2faf128d577d7f679b91f97",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/764355487ea220fdc2faf128d577d7f679b91f97",
    "files": [
      "fs/ecryptfs/main.c"
    ],
    "message": "Ecryptfs: Add mount option to check uid of device being mounted = expect uid\n\nClose a TOCTOU race for mounts done via ecryptfs-mount-private.  The mount\nsource (device) can be raced when the ownership test is done in userspace.\nProvide Ecryptfs a means to force the uid check at mount time.\n\nSigned-off-by: John Johansen <john.johansen@canonical.com>\nCc: <stable@kernel.org>\nSigned-off-by: Tyler Hicks <tyhicks@linux.vnet.ibm.com>",
    "before_after_code_files": [
      "fs/ecryptfs/main.c||fs/ecryptfs/main.c"
    ]
  },
  "patch_diff": {
    "fs/ecryptfs/main.c||fs/ecryptfs/main.c": [
      "File: fs/ecryptfs/main.c -> fs/ecryptfs/main.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "175:        ecryptfs_opt_encrypted_view, ecryptfs_opt_fnek_sig,",
      "176:        ecryptfs_opt_fn_cipher, ecryptfs_opt_fn_cipher_key_bytes,",
      "177:        ecryptfs_opt_unlink_sigs, ecryptfs_opt_mount_auth_tok_only,",
      "178:        ecryptfs_opt_err };",
      "180: static const match_table_t tokens = {",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "178:        ecryptfs_opt_check_dev_ruid,",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "191:  {ecryptfs_opt_fn_cipher_key_bytes, \"ecryptfs_fn_key_bytes=%u\"},",
      "192:  {ecryptfs_opt_unlink_sigs, \"ecryptfs_unlink_sigs\"},",
      "193:  {ecryptfs_opt_mount_auth_tok_only, \"ecryptfs_mount_auth_tok_only\"},",
      "194:  {ecryptfs_opt_err, NULL}",
      "195: };",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "195:  {ecryptfs_opt_check_dev_ruid, \"ecryptfs_check_dev_ruid\"},",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "255: {",
      "256:  char *p;",
      "257:  int rc = 0;",
      "",
      "[Removed Lines]",
      "254: static int ecryptfs_parse_options(struct ecryptfs_sb_info *sbi, char *options)",
      "",
      "[Added Lines]",
      "257: static int ecryptfs_parse_options(struct ecryptfs_sb_info *sbi, char *options,",
      "258:       uid_t *check_ruid)",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "380:    mount_crypt_stat->flags |=",
      "381:     ECRYPTFS_GLOBAL_MOUNT_AUTH_TOK_ONLY;",
      "382:    break;",
      "383:   case ecryptfs_opt_err:",
      "384:   default:",
      "385:    printk(KERN_WARNING",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "389:   case ecryptfs_opt_check_dev_ruid:",
      "391:    break;",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "475:  const char *err = \"Getting sb failed\";",
      "476:  struct inode *inode;",
      "477:  struct path path;",
      "478:  int rc;",
      "480:  sbi = kmem_cache_zalloc(ecryptfs_sb_info_cache, GFP_KERNEL);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "487:  uid_t check_ruid;",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "483:   goto out;",
      "484:  }",
      "487:  if (rc) {",
      "488:   err = \"Error parsing options\";",
      "489:   goto out;",
      "",
      "[Removed Lines]",
      "486:  rc = ecryptfs_parse_options(sbi, raw_data);",
      "",
      "[Added Lines]",
      "496:  rc = ecryptfs_parse_options(sbi, raw_data, &check_ruid);",
      "",
      "---------------",
      "--- Hunk 7 ---",
      "[Context before]",
      "521:    \"known incompatibilities\\n\");",
      "522:   goto out_free;",
      "523:  }",
      "524:  ecryptfs_set_superblock_lower(s, path.dentry->d_sb);",
      "525:  s->s_maxbytes = path.dentry->d_sb->s_maxbytes;",
      "526:  s->s_blocksize = path.dentry->d_sb->s_blocksize;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "535:  if (check_ruid && path.dentry->d_inode->i_uid != current_uid()) {",
      "536:   rc = -EPERM;",
      "537:   printk(KERN_ERR \"Mount of device (uid: %d) not owned by \"",
      "538:          \"requested user (uid: %d)\\n\",",
      "539:          path.dentry->d_inode->i_uid, current_uid());",
      "540:   goto out_free;",
      "541:  }",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "66cb76666d69502fe982990b2cff5b6d607fd3b1",
      "candidate_info": {
        "commit_hash": "66cb76666d69502fe982990b2cff5b6d607fd3b1",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/66cb76666d69502fe982990b2cff5b6d607fd3b1",
        "files": [
          "fs/ecryptfs/inode.c",
          "fs/ecryptfs/main.c"
        ],
        "message": "sanitize ecryptfs ->mount()\n\nkill ecryptfs_read_super(), reorder code allowing to use\nnormal d_alloc_root() instead of opencoding it.\n\nSigned-off-by: Al Viro <viro@zeniv.linux.org.uk>",
        "before_after_code_files": [
          "fs/ecryptfs/inode.c||fs/ecryptfs/inode.c",
          "fs/ecryptfs/main.c||fs/ecryptfs/main.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "fs/ecryptfs/main.c||fs/ecryptfs/main.c"
          ],
          "candidate": [
            "fs/ecryptfs/main.c||fs/ecryptfs/main.c"
          ]
        }
      },
      "candidate_diff": {
        "fs/ecryptfs/inode.c||fs/ecryptfs/inode.c": [
          "File: fs/ecryptfs/inode.c -> fs/ecryptfs/inode.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "441:  struct qstr lower_name;",
          "442:  int rc = 0;",
          "445:  if ((ecryptfs_dentry->d_name.len == 1",
          "446:       && !strcmp(ecryptfs_dentry->d_name.name, \".\"))",
          "447:      || (ecryptfs_dentry->d_name.len == 2",
          "",
          "[Removed Lines]",
          "444:  d_set_d_op(ecryptfs_dentry, &ecryptfs_dops);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "fs/ecryptfs/main.c||fs/ecryptfs/main.c": [
          "File: fs/ecryptfs/main.c -> fs/ecryptfs/main.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "141:  return rc;",
          "142: }",
          "157: {",
          "159:  struct inode *inode;",
          "160:  int rc = 0;",
          "",
          "[Removed Lines]",
          "155: int ecryptfs_interpose(struct dentry *lower_dentry, struct dentry *dentry,",
          "156:          struct super_block *sb, u32 flags)",
          "158:  struct inode *lower_inode;",
          "",
          "[Added Lines]",
          "144: static inode *ecryptfs_get_inode(struct inode *lower_inode,",
          "145:          struct super_block *sb)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "189:  if (special_file(lower_inode->i_mode))",
          "190:   init_special_inode(inode, lower_inode->i_mode,",
          "191:        lower_inode->i_rdev);",
          "193:  fsstack_copy_attr_all(inode, lower_inode);",
          "196:  fsstack_copy_inode_size(inode, lower_inode);",
          "197:  if (flags & ECRYPTFS_INTERPOSE_FLAG_D_ADD)",
          "198:   d_add(dentry, inode);",
          "199:  else",
          "200:   d_instantiate(dentry, inode);",
          "203: }",
          "205: enum { ecryptfs_opt_sig, ecryptfs_opt_ecryptfs_sig,",
          "",
          "[Removed Lines]",
          "192:  d_set_d_op(dentry, &ecryptfs_dops);",
          "201: out:",
          "202:  return rc;",
          "",
          "[Added Lines]",
          "184:  return inode;",
          "185: out:",
          "186:  return ERR_PTR(rc);",
          "187: }",
          "200: int ecryptfs_interpose(struct dentry *lower_dentry, struct dentry *dentry,",
          "201:          struct super_block *sb, u32 flags)",
          "202: {",
          "203:  struct inode *lower_inode = lower_dentry->d_inode;",
          "204:  struct inode *inode = ecryptfs_get_inode(lower_inode, sb);",
          "205:  if (IS_ERR(inode)",
          "206:   return PTR_ERR(inode);",
          "211:  return 0;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "491: struct kmem_cache *ecryptfs_sb_info_cache;",
          "492: static struct file_system_type ecryptfs_fs_type;",
          "549: static struct dentry *ecryptfs_mount(struct file_system_type *fs_type, int flags,",
          "550:    const char *dev_name, void *raw_data)",
          "",
          "[Removed Lines]",
          "503: static int ecryptfs_read_super(struct super_block *sb, const char *dev_name)",
          "504: {",
          "505:  struct path path;",
          "506:  int rc;",
          "508:  rc = kern_path(dev_name, LOOKUP_FOLLOW | LOOKUP_DIRECTORY, &path);",
          "509:  if (rc) {",
          "510:   ecryptfs_printk(KERN_WARNING, \"path_lookup() failed\\n\");",
          "511:   goto out;",
          "512:  }",
          "513:  if (path.dentry->d_sb->s_type == &ecryptfs_fs_type) {",
          "514:   rc = -EINVAL;",
          "515:   printk(KERN_ERR \"Mount on filesystem of type \"",
          "516:    \"eCryptfs explicitly disallowed due to \"",
          "517:    \"known incompatibilities\\n\");",
          "518:   goto out_free;",
          "519:  }",
          "520:  ecryptfs_set_superblock_lower(sb, path.dentry->d_sb);",
          "521:  sb->s_maxbytes = path.dentry->d_sb->s_maxbytes;",
          "522:  sb->s_blocksize = path.dentry->d_sb->s_blocksize;",
          "523:  ecryptfs_set_dentry_lower(sb->s_root, path.dentry);",
          "524:  ecryptfs_set_dentry_lower_mnt(sb->s_root, path.mnt);",
          "525:  rc = ecryptfs_interpose(path.dentry, sb->s_root, sb, 0);",
          "526:  if (rc)",
          "527:   goto out_free;",
          "528:  rc = 0;",
          "529:  goto out;",
          "530: out_free:",
          "531:  path_put(&path);",
          "532: out:",
          "533:  return rc;",
          "534: }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "553:  struct ecryptfs_sb_info *sbi;",
          "554:  struct ecryptfs_dentry_info *root_info;",
          "555:  const char *err = \"Getting sb failed\";",
          "556:  int rc;",
          "558:  sbi = kmem_cache_zalloc(ecryptfs_sb_info_cache, GFP_KERNEL);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "517:  struct inode *inode;",
          "518:  struct path path;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "576:  s->s_flags = flags;",
          "577:  rc = bdi_setup_and_register(&sbi->bdi, \"ecryptfs\", BDI_CAP_MAP_COPY);",
          "583:  ecryptfs_set_superblock_private(s, sbi);",
          "584:  s->s_bdi = &sbi->bdi;",
          "",
          "[Removed Lines]",
          "578:  if (rc) {",
          "579:   deactivate_locked_super(s);",
          "580:   goto out;",
          "581:  }",
          "",
          "[Added Lines]",
          "541:  if (rc)",
          "542:   goto out1;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "587:  sbi = NULL;",
          "588:  s->s_op = &ecryptfs_sops;",
          "593:  if (!s->s_root) {",
          "596:  }",
          "601:  root_info = kmem_cache_zalloc(ecryptfs_dentry_info_cache, GFP_KERNEL);",
          "607:  ecryptfs_set_dentry_private(s->s_root, root_info);",
          "608:  s->s_flags |= MS_ACTIVE;",
          "615:  return dget(s->s_root);",
          "617: out:",
          "618:  if (sbi) {",
          "619:   ecryptfs_destroy_mount_crypt_stat(&sbi->mount_crypt_stat);",
          "",
          "[Removed Lines]",
          "590:  rc = -ENOMEM;",
          "591:  s->s_root = d_alloc(NULL, &(const struct qstr) {",
          "592:         .hash = 0,.name = \"/\",.len = 1});",
          "594:   deactivate_locked_super(s);",
          "595:   goto out;",
          "597:  d_set_d_op(s->s_root, &ecryptfs_dops);",
          "598:  s->s_root->d_sb = s;",
          "599:  s->s_root->d_parent = s->s_root;",
          "602:  if (!root_info) {",
          "603:   deactivate_locked_super(s);",
          "604:   goto out;",
          "605:  }",
          "609:  rc = ecryptfs_read_super(s, dev_name);",
          "610:  if (rc) {",
          "611:   deactivate_locked_super(s);",
          "612:   err = \"Reading sb failed\";",
          "613:   goto out;",
          "614:  }",
          "",
          "[Added Lines]",
          "550:  s->s_d_op = &ecryptfs_dops;",
          "552:  err = \"Reading sb failed\";",
          "553:  rc = kern_path(dev_name, LOOKUP_FOLLOW | LOOKUP_DIRECTORY, &path);",
          "554:  if (rc) {",
          "555:   ecryptfs_printk(KERN_WARNING, \"kern_path() failed\\n\");",
          "556:   goto out1;",
          "557:  }",
          "558:  if (path.dentry->d_sb->s_type == &ecryptfs_fs_type) {",
          "559:   rc = -EINVAL;",
          "560:   printk(KERN_ERR \"Mount on filesystem of type \"",
          "561:    \"eCryptfs explicitly disallowed due to \"",
          "562:    \"known incompatibilities\\n\");",
          "563:   goto out_free;",
          "564:  }",
          "565:  ecryptfs_set_superblock_lower(s, path.dentry->d_sb);",
          "566:  s->s_maxbytes = path.dentry->d_sb->s_maxbytes;",
          "567:  s->s_blocksize = path.dentry->d_sb->s_blocksize;",
          "569:  inode = ecryptfs_get_inode(path.dentry->d_inode, s);",
          "570:  rc = PTR_ERR(inode);",
          "571:  if (IS_ERR(inode))",
          "572:   goto out_free;",
          "574:  s->s_root = d_alloc_root(inode);",
          "576:   iput(inode);",
          "577:   rc = -ENOMEM;",
          "578:   goto out_free;",
          "581:  rc = -ENOMEM;",
          "583:  if (!root_info)",
          "584:   goto out_free;",
          "588:  ecryptfs_set_dentry_lower(s->s_root, path.dentry);",
          "589:  ecryptfs_set_dentry_lower_mnt(s->s_root, path.mnt);",
          "594: out_free:",
          "595:  path_put(&path);",
          "596: out1:",
          "597:  deactivate_locked_super(s);",
          "",
          "---------------"
        ]
      }
    }
  ]
}
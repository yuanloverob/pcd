{
  "cve_id": "CVE-2020-24371",
  "cve_desc": "lgc.c in Lua 5.4.0 mishandles the interaction between barriers and the sweep phase, leading to a memory access violation involving collectgarbage.",
  "repo": "lua/lua",
  "patch_hash": "a6da1472c0c5e05ff249325f979531ad51533110",
  "patch_info": {
    "commit_hash": "a6da1472c0c5e05ff249325f979531ad51533110",
    "repo": "lua/lua",
    "commit_url": "https://github.com/lua/lua/commit/a6da1472c0c5e05ff249325f979531ad51533110",
    "files": [
      "lgc.c",
      "testes/gengc.lua"
    ],
    "message": "Fixed bug: barriers cannot be active during sweep\n\nBarriers cannot be active during sweep, even in generational mode.\n(Although gen. mode is not incremental, it can hit a barrier when\ndeleting a thread and closing its upvalues.)  The colors of objects are\nbeing changed during sweep and, therefore, cannot be trusted.",
    "before_after_code_files": [
      "lgc.c||lgc.c",
      "testes/gengc.lua||testes/gengc.lua"
    ]
  },
  "patch_diff": {
    "lgc.c||lgc.c": [
      "File: lgc.c -> lgc.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "342:       UpVal *uv;",
      "345:       for (uv = thread->openupval; uv != NULL; uv = uv->u.open.next) {",
      "346:         work++;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "352:       lua_assert(!isold(thread) || thread->openupval == NULL);",
      "356:         lua_assert(getage(uv) <= getage(thread));",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "1143:   atomic(L);",
      "1146:   psurvival = sweepgen(L, g, &g->allgc, g->survival);",
      "1148:   sweepgen(L, g, psurvival, g->reallyold);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1160:   g->gcstate = GCSswpallgc;",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "1167: static void atomic2gen (lua_State *L, global_State *g) {",
      "1169:   sweep2old(L, &g->allgc);",
      "1171:   g->reallyold = g->old = g->survival = g->allgc;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1184:   g->gcstate = GCSswpallgc;",
      "",
      "---------------"
    ],
    "testes/gengc.lua||testes/gengc.lua": [
      "File: testes/gengc.lua -> testes/gengc.lua",
      "--- Hunk 1 ---",
      "[Context before]",
      "57:   local obj = {}     -- create a new object",
      "58:   collectgarbage(\"step\", 0)   -- make it a survival",
      "59:   assert(not T or T.gcage(obj) == \"survival\")",
      "61:   assert(not T or T.gcage(getmetatable(obj)) == \"new\")",
      "62:   obj = nil   -- clear object",
      "63:   collectgarbage(\"step\", 0)   -- will call obj's finalizer",
      "64: end",
      "67: if T == nil then",
      "68:   (Message or print)('\\n >>> testC not active: \\z",
      "69:                              skipping some generational tests <<<\\n')",
      "",
      "[Removed Lines]",
      "60:   setmetatable(obj, {__gc = gcf, x = \"ok\"})   -- create its metatable",
      "",
      "[Added Lines]",
      "60:   setmetatable(obj, {__gc = gcf, x = \"+\"})   -- create its metatable",
      "67: do   -- another bug in 5.4.0",
      "68:   local old = {10}",
      "69:   collectgarbage()   -- make 'old' old",
      "70:   local co = coroutine.create(",
      "71:     function ()",
      "72:       local x = nil",
      "73:       local f = function ()",
      "74:                   return x[1]",
      "75:                 end",
      "76:       x = coroutine.yield(f)",
      "77:       coroutine.yield()",
      "78:     end",
      "79:   )",
      "80:   local _, f = coroutine.resume(co)   -- create closure over 'x' in coroutine",
      "81:   collectgarbage(\"step\", 0)   -- make upvalue a survival",
      "82:   old[1] = {\"hello\"}    -- 'old' go to grayagain as 'touched1'",
      "83:   coroutine.resume(co, {123})     -- its value will be new",
      "84:   co = nil",
      "85:   collectgarbage(\"step\", 0)   -- hit the barrier",
      "86:   assert(f() == 123 and old[1][1] == \"hello\")",
      "87:   collectgarbage(\"step\", 0)   -- run the collector once more",
      "88:   -- make sure old[1] was not collected",
      "89:   assert(f() == 123 and old[1][1] == \"hello\")",
      "90: end",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "0f1cd0eba99ea6d383e75b9ae488d00ad541c210",
      "candidate_info": {
        "commit_hash": "0f1cd0eba99ea6d383e75b9ae488d00ad541c210",
        "repo": "lua/lua",
        "commit_url": "https://github.com/lua/lua/commit/0f1cd0eba99ea6d383e75b9ae488d00ad541c210",
        "files": [
          "testes/gengc.lua"
        ],
        "message": "Added test for fix 127e7a6c894",
        "before_after_code_files": [
          "testes/gengc.lua||testes/gengc.lua"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "testes/gengc.lua||testes/gengc.lua"
          ],
          "candidate": [
            "testes/gengc.lua||testes/gengc.lua"
          ]
        }
      },
      "candidate_diff": {
        "testes/gengc.lua||testes/gengc.lua": [
          "File: testes/gengc.lua -> testes/gengc.lua",
          "--- Hunk 1 ---",
          "[Context before]",
          "37: end",
          "40: if T == nil then",
          "41:   (Message or print)('\\n >>> testC not active: \\z",
          "42:                              skipping some generational tests <<<\\n')",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "40: do   -- bug in 5.4.0",
          "41: -- When an object aged OLD1 is finalized, it is moved from the list",
          "42: -- 'finobj' to the *beginning* of the list 'allgc', but that part of the",
          "43: -- list was not being visited by 'markold'.",
          "44:   local A = {}",
          "45:   A[1] = false     -- old anchor for object",
          "47:   -- obj finalizer",
          "48:   local function gcf (obj)",
          "49:     A[1] = obj     -- anchor object",
          "50:     assert(not T or T.gcage(obj) == \"old1\")",
          "51:     obj = nil      -- remove it from the stack",
          "52:     collectgarbage(\"step\", 0)   -- do a young collection",
          "53:     print(getmetatable(A[1]).x)   -- metatable was collected",
          "54:   end",
          "56:   collectgarbage()   -- make A old",
          "57:   local obj = {}     -- create a new object",
          "58:   collectgarbage(\"step\", 0)   -- make it a survival",
          "59:   assert(not T or T.gcage(obj) == \"survival\")",
          "60:   setmetatable(obj, {__gc = gcf, x = \"ok\"})   -- create its metatable",
          "61:   assert(not T or T.gcage(getmetatable(obj)) == \"new\")",
          "62:   obj = nil   -- clear object",
          "63:   collectgarbage(\"step\", 0)   -- will call obj's finalizer",
          "64: end",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "72:   assert(debug.getuservalue(U).x[1] == 234)",
          "73: end",
          "77: -- just to make sure",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "102: -- just to make sure",
          "103: assert(collectgarbage'isrunning')",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "663f83f647f9199541ce1b60a6496b4124b4fdd3",
      "candidate_info": {
        "commit_hash": "663f83f647f9199541ce1b60a6496b4124b4fdd3",
        "repo": "lua/lua",
        "commit_url": "https://github.com/lua/lua/commit/663f83f647f9199541ce1b60a6496b4124b4fdd3",
        "files": [
          "lgc.c"
        ],
        "message": "Same changes around 'correctgraylist'\n\nInstead of adding all tables and userdata back to the 'grayagain' list\nto be checked by 'correctgraylist', the collector adds only the objects\nthat will remain in that list (objects aged TOUCHED1). This commit\nalso rewrites 'correctgraylist' with a clearer logic.",
        "before_after_code_files": [
          "lgc.c||lgc.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "lgc.c||lgc.c"
          ],
          "candidate": [
            "lgc.c||lgc.c"
          ]
        }
      },
      "candidate_diff": {
        "lgc.c||lgc.c": [
          "File: lgc.c -> lgc.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "404: #define genlink(g,o) genlink_(g, obj2gco(o), &(o)->gclist)",
          "406: static void genlink_ (global_State *g, GCObject *o, GCObject **pnext) {",
          "407:   lua_assert(isblack(o));",
          "410:     g->grayagain = o;",
          "411:     black2gray(o);",
          "413:   else if (getage(o) == G_TOUCHED2)",
          "415: }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "472:   return marked;",
          "473: }",
          "",
          "[Removed Lines]",
          "468:   else if (g->gckind == KGC_GEN)",
          "470:   else",
          "471:     gray2black(h);",
          "",
          "[Added Lines]",
          "495:   else {",
          "498:   }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "488:       markvalue(g, gval(n));",
          "489:     }",
          "490:   }",
          "495: }",
          "",
          "[Removed Lines]",
          "491:   if (g->gckind == KGC_GEN) {",
          "493:     black2gray(h);",
          "494:   }",
          "",
          "[Added Lines]",
          "518:   genlink(g, h);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "523:   for (i = 0; i < u->nuvalue; i++)",
          "524:     markvalue(g, &u->uv[i].uv);",
          "529:   return 1 + u->nuvalue;",
          "530: }",
          "",
          "[Removed Lines]",
          "525:   if (g->gckind == KGC_GEN) {",
          "527:     black2gray(u);",
          "528:   }",
          "",
          "[Added Lines]",
          "549:   genlink(g, u);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1066: static GCObject **correctgraylist (GCObject **p) {",
          "1067:   GCObject *curr;",
          "1068:   while ((curr = *p) != NULL) {",
          "1100:     }",
          "1101:   }",
          "1102:   return p;",
          "1103: }",
          "",
          "[Removed Lines]",
          "1069:     switch (curr->tt) {",
          "1070:       case LUA_VTABLE: case LUA_VUSERDATA: {",
          "1071:         GCObject **next = getgclist(curr);",
          "1073:           lua_assert(isgray(curr));",
          "1075:           changeage(curr, G_TOUCHED1, G_TOUCHED2);",
          "1077:         }",
          "1081:             lua_assert(isold(curr));",
          "1085:           }",
          "1087:         }",
          "1088:         break;",
          "1089:       }",
          "1090:       case LUA_VTHREAD: {",
          "1091:         lua_State *th = gco2th(curr);",
          "1092:         lua_assert(!isblack(th));",
          "1097:         break;",
          "1098:       }",
          "",
          "[Added Lines]",
          "1092:     GCObject **next = getgclist(curr);",
          "1093:     if (iswhite(curr))",
          "1096:       lua_assert(isgray(curr));",
          "1098:       changeage(curr, G_TOUCHED1, G_TOUCHED2);",
          "1100:     }",
          "1101:     else if (curr->tt == LUA_VTHREAD) {",
          "1102:       lua_assert(isgray(curr));",
          "1104:     }",
          "1110:       goto remove;",
          "1112:     remove: *p = *next; continue;",
          "1113:     remain: p = next; continue;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "9cf3299fafa41718e3cb260cc94d1d29bba6335b",
      "candidate_info": {
        "commit_hash": "9cf3299fafa41718e3cb260cc94d1d29bba6335b",
        "repo": "lua/lua",
        "commit_url": "https://github.com/lua/lua/commit/9cf3299fafa41718e3cb260cc94d1d29bba6335b",
        "files": [
          "lgc.c"
        ],
        "message": "Threads don't need to always go to 'grayagain'\n\nIn incremental mode, threads don't need to be visited again once\nvisited in the atomic phase. In generational mode (where all visits\nare in the atomic phase), only old threads need to be kept in the\n'grayagain' list for the next cycle.",
        "before_after_code_files": [
          "lgc.c||lgc.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "lgc.c||lgc.c"
          ],
          "candidate": [
            "lgc.c||lgc.c"
          ]
        }
      },
      "candidate_diff": {
        "lgc.c||lgc.c": [
          "File: lgc.c -> lgc.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "349:   while ((thread = *p) != NULL) {",
          "350:     work++;",
          "355:       UpVal *uv;",
          "",
          "[Removed Lines]",
          "352:     if (isgray(thread) && thread->openupval != NULL)",
          "",
          "[Added Lines]",
          "351:     if (!iswhite(thread) && thread->openupval != NULL)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "606: static int traversethread (global_State *g, lua_State *th) {",
          "607:   UpVal *uv;",
          "608:   StkId o = th->stack;",
          "609:   if (o == NULL)",
          "611:   lua_assert(g->gcstate == GCSatomic ||",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "615:   if (isold(th) || g->gcstate == GCSpropagate) {",
          "617:     black2gray(th);",
          "618:   }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "644:     case LUA_VLCL: return traverseLclosure(g, gco2lcl(o));",
          "645:     case LUA_VCCL: return traverseCclosure(g, gco2ccl(o));",
          "646:     case LUA_VPROTO: return traverseproto(g, gco2p(o));",
          "653:     default: lua_assert(0); return 0;",
          "654:   }",
          "655: }",
          "",
          "[Removed Lines]",
          "647:     case LUA_VTHREAD: {",
          "648:       lua_State *th = gco2th(o);",
          "650:       black2gray(o);",
          "651:       return traversethread(g, th);",
          "652:     }",
          "",
          "[Added Lines]",
          "657:     case LUA_VTHREAD: return traversethread(g, gco2th(o));",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1140:     }",
          "1146:       goto remove;",
          "1147:     }",
          "1148:     remove: *p = *next; continue;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1150:       }",
          "1151:       else {",
          "1153:         lua_assert(isgray(curr));",
          "1155:       }",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1209:   lua_assert(g->gcstate == GCSpropagate);",
          "1213:   }",
          "1214:   markold(g, g->finobj, g->finobjrold);",
          "1215:   atomic(L);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1225:   markold(g, g->tobefnz, NULL);",
          "",
          "---------------"
        ]
      }
    }
  ]
}
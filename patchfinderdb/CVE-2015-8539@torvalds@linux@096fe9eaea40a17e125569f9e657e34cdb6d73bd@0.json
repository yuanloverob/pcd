{
  "cve_id": "CVE-2015-8539",
  "cve_desc": "The KEYS subsystem in the Linux kernel before 4.4 allows local users to gain privileges or cause a denial of service (BUG) via crafted keyctl commands that negatively instantiate a key, related to security/keys/encrypted-keys/encrypted.c, security/keys/trusted.c, and security/keys/user_defined.c.",
  "repo": "torvalds/linux",
  "patch_hash": "096fe9eaea40a17e125569f9e657e34cdb6d73bd",
  "patch_info": {
    "commit_hash": "096fe9eaea40a17e125569f9e657e34cdb6d73bd",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/096fe9eaea40a17e125569f9e657e34cdb6d73bd",
    "files": [
      "security/keys/encrypted-keys/encrypted.c",
      "security/keys/trusted.c",
      "security/keys/user_defined.c"
    ],
    "message": "KEYS: Fix handling of stored error in a negatively instantiated user key\n\nIf a user key gets negatively instantiated, an error code is cached in the\npayload area.  A negatively instantiated key may be then be positively\ninstantiated by updating it with valid data.  However, the ->update key\ntype method must be aware that the error code may be there.\n\nThe following may be used to trigger the bug in the user key type:\n\n    keyctl request2 user user \"\" @u\n    keyctl add user user \"a\" @u\n\nwhich manifests itself as:\n\n\tBUG: unable to handle kernel paging request at 00000000ffffff8a\n\tIP: [<ffffffff810a376f>] __call_rcu.constprop.76+0x1f/0x280 kernel/rcu/tree.c:3046\n\tPGD 7cc30067 PUD 0\n\tOops: 0002 [#1] SMP\n\tModules linked in:\n\tCPU: 3 PID: 2644 Comm: a.out Not tainted 4.3.0+ #49\n\tHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS Bochs 01/01/2011\n\ttask: ffff88003ddea700 ti: ffff88003dd88000 task.ti: ffff88003dd88000\n\tRIP: 0010:[<ffffffff810a376f>]  [<ffffffff810a376f>] __call_rcu.constprop.76+0x1f/0x280\n\t [<ffffffff810a376f>] __call_rcu.constprop.76+0x1f/0x280 kernel/rcu/tree.c:3046\n\tRSP: 0018:ffff88003dd8bdb0  EFLAGS: 00010246\n\tRAX: 00000000ffffff82 RBX: 0000000000000000 RCX: 0000000000000001\n\tRDX: ffffffff81e3fe40 RSI: 0000000000000000 RDI: 00000000ffffff82\n\tRBP: ffff88003dd8bde0 R08: ffff88007d2d2da0 R09: 0000000000000000\n\tR10: 0000000000000000 R11: ffff88003e8073c0 R12: 00000000ffffff82\n\tR13: ffff88003dd8be68 R14: ffff88007d027600 R15: ffff88003ddea700\n\tFS:  0000000000b92880(0063) GS:ffff88007fd00000(0000) knlGS:0000000000000000\n\tCS:  0010 DS: 0000 ES: 0000 CR0: 000000008005003b\n\tCR2: 00000000ffffff8a CR3: 000000007cc5f000 CR4: 00000000000006e0\n\tStack:\n\t ffff88003dd8bdf0 ffffffff81160a8a 0000000000000000 00000000ffffff82\n\t ffff88003dd8be68 ffff88007d027600 ffff88003dd8bdf0 ffffffff810a39e5\n\t ffff88003dd8be20 ffffffff812a31ab ffff88007d027600 ffff88007d027620\n\tCall Trace:\n\t [<ffffffff810a39e5>] kfree_call_rcu+0x15/0x20 kernel/rcu/tree.c:3136\n\t [<ffffffff812a31ab>] user_update+0x8b/0xb0 security/keys/user_defined.c:129\n\t [<     inline     >] __key_update security/keys/key.c:730\n\t [<ffffffff8129e5c1>] key_create_or_update+0x291/0x440 security/keys/key.c:908\n\t [<     inline     >] SYSC_add_key security/keys/keyctl.c:125\n\t [<ffffffff8129fc21>] SyS_add_key+0x101/0x1e0 security/keys/keyctl.c:60\n\t [<ffffffff8185f617>] entry_SYSCALL_64_fastpath+0x12/0x6a arch/x86/entry/entry_64.S:185\n\nNote the error code (-ENOKEY) in EDX.\n\nA similar bug can be tripped by:\n\n    keyctl request2 trusted user \"\" @u\n    keyctl add trusted user \"a\" @u\n\nThis should also affect encrypted keys - but that has to be correctly\nparameterised or it will fail with EINVAL before getting to the bit that\nwill crashes.\n\nReported-by: Dmitry Vyukov <dvyukov@google.com>\nSigned-off-by: David Howells <dhowells@redhat.com>\nAcked-by: Mimi Zohar <zohar@linux.vnet.ibm.com>\nSigned-off-by: James Morris <james.l.morris@oracle.com>",
    "before_after_code_files": [
      "security/keys/encrypted-keys/encrypted.c||security/keys/encrypted-keys/encrypted.c",
      "security/keys/trusted.c||security/keys/trusted.c",
      "security/keys/user_defined.c||security/keys/user_defined.c"
    ]
  },
  "patch_diff": {
    "security/keys/encrypted-keys/encrypted.c||security/keys/encrypted-keys/encrypted.c": [
      "File: security/keys/encrypted-keys/encrypted.c -> security/keys/encrypted-keys/encrypted.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "845:  size_t datalen = prep->datalen;",
      "846:  int ret = 0;",
      "848:  if (datalen <= 0 || datalen > 32767 || !prep->data)",
      "849:   return -EINVAL;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "848:  if (test_bit(KEY_FLAG_NEGATIVE, &key->flags))",
      "849:   return -ENOKEY;",
      "",
      "---------------"
    ],
    "security/keys/trusted.c||security/keys/trusted.c": [
      "File: security/keys/trusted.c -> security/keys/trusted.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "1008: static int trusted_update(struct key *key, struct key_preparsed_payload *prep)",
      "1009: {",
      "1011:  struct trusted_key_payload *new_p;",
      "1012:  struct trusted_key_options *new_o;",
      "1013:  size_t datalen = prep->datalen;",
      "1014:  char *datablob;",
      "1015:  int ret = 0;",
      "1017:  if (!p->migratable)",
      "1018:   return -EPERM;",
      "1019:  if (datalen <= 0 || datalen > 32767 || !prep->data)",
      "",
      "[Removed Lines]",
      "1010:  struct trusted_key_payload *p = key->payload.data[0];",
      "",
      "[Added Lines]",
      "1010:  struct trusted_key_payload *p;",
      "1017:  if (test_bit(KEY_FLAG_NEGATIVE, &key->flags))",
      "1018:   return -ENOKEY;",
      "1019:  p = key->payload.data[0];",
      "",
      "---------------"
    ],
    "security/keys/user_defined.c||security/keys/user_defined.c": [
      "File: security/keys/user_defined.c -> security/keys/user_defined.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "121:  if (ret == 0) {",
      "124:   rcu_assign_keypointer(key, upayload);",
      "125:   key->expiry = 0;",
      "126:  }",
      "",
      "[Removed Lines]",
      "123:   zap = key->payload.data[0];",
      "",
      "[Added Lines]",
      "123:   if (!test_bit(KEY_FLAG_NEGATIVE, &key->flags))",
      "124:    zap = key->payload.data[0];",
      "125:   else",
      "126:    zap = NULL;",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "e37df6c76cb19971f1228bfaff504d8a3ea6f748",
      "candidate_info": {
        "commit_hash": "e37df6c76cb19971f1228bfaff504d8a3ea6f748",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/e37df6c76cb19971f1228bfaff504d8a3ea6f748",
        "files": [
          "tools/perf/util/parse-events.c"
        ],
        "message": "perf list: Robustify event printing routine\n\nWhen a43eec304259 (\"bpf: introduce bpf_perf_event_output() helper\") added\nPERF_COUNT_SW_BPF_OUTPUT we ended up with a new entry in the event_symbols_sw\narray that wasn't initialized, thus set to NULL, fix print_symbol_events()\nto check for that case so that we don't crash if this happens again.\n\n  (gdb) bt\n  #0  __match_glob (ignore_space=false, pat=<optimized out>, str=<optimized out>) at util/string.c:198\n  #1  strglobmatch (str=<optimized out>, pat=pat@entry=0x7fffffffe61d \"stall\") at util/string.c:252\n  #2  0x00000000004993a5 in print_symbol_events (type=1, syms=0x872880 <event_symbols_sw+160>, max=11, name_only=false, event_glob=0x7fffffffe61d \"stall\")\n      at util/parse-events.c:1615\n  #3  print_events (event_glob=event_glob@entry=0x7fffffffe61d \"stall\", name_only=false) at util/parse-events.c:1675\n  #4  0x000000000042c79e in cmd_list (argc=1, argv=0x7fffffffe390, prefix=<optimized out>) at builtin-list.c:68\n  #5  0x00000000004788a5 in run_builtin (p=p@entry=0x871758 <commands+120>, argc=argc@entry=2, argv=argv@entry=0x7fffffffe390) at perf.c:370\n  #6  0x0000000000420ab0 in handle_internal_command (argv=0x7fffffffe390, argc=2) at perf.c:429\n  #7  run_argv (argv=0x7fffffffe110, argcp=0x7fffffffe11c) at perf.c:473\n  #8  main (argc=2, argv=0x7fffffffe390) at perf.c:588\n  (gdb) p event_symbols_sw[PERF_COUNT_SW_BPF_OUTPUT]\n  $4 = {symbol = 0x0, alias = 0x0}\n  (gdb)\n\nA patch to robustify perf to not segfault when the next counter gets added in\nthe kernel will follow this one.\n\nReported-by: Ingo Molnar <mingo@kernel.org>\nCc: Adrian Hunter <adrian.hunter@intel.com>\nCc: Alexei Starovoitov <ast@kernel.org>\nCc: David Ahern <dsahern@gmail.com>\nCc: Jiri Olsa <jolsa@redhat.com>\nCc: Namhyung Kim <namhyung@kernel.org>\nCc: Wang Nan <wangnan0@huawei.com>\nLink: http://lkml.kernel.org/n/tip-57wysblcjfrseb0zg5u7ek10@git.kernel.org\nSigned-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>",
        "before_after_code_files": [
          "tools/perf/util/parse-events.c||tools/perf/util/parse-events.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "tools/perf/util/parse-events.c||tools/perf/util/parse-events.c": [
          "File: tools/perf/util/parse-events.c -> tools/perf/util/parse-events.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1884:  for (i = 0; i < max; i++, syms++) {",
          "1887:       !(strglobmatch(syms->symbol, event_glob) ||",
          "1888:         (syms->alias && strglobmatch(syms->alias, event_glob))))",
          "1889:    continue;",
          "",
          "[Removed Lines]",
          "1886:   if (event_glob != NULL &&",
          "",
          "[Added Lines]",
          "1886:   if (event_glob != NULL && syms->symbol != NULL &&",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "53254f900bd9ff1e3cc5628e76126bb403d9d160",
      "candidate_info": {
        "commit_hash": "53254f900bd9ff1e3cc5628e76126bb403d9d160",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/53254f900bd9ff1e3cc5628e76126bb403d9d160",
        "files": [
          "kernel/cgroup.c"
        ],
        "message": "cgroup: make css_set pin its css's to avoid use-afer-free\n\nA css_set represents the relationship between a set of tasks and\ncss's.  css_set never pinned the associated css's.  This was okay\nbecause tasks used to always disassociate immediately (in RCU sense) -\neither a task is moved to a different css_set or exits and never\naccesses css_set again.\n\nUnfortunately, afcf6c8b7544 (\"cgroup: add cgroup_subsys->free() method\nand use it to fix pids controller\") and patches leading up to it made\na zombie hold onto its css_set and deref the associated css's on its\nrelease.  Nothing pins the css's after exit and it might have already\nbeen freed leading to use-after-free.\n\n general protection fault: 0000 [#1] PREEMPT SMP\n task: ffffffff81bf2500 ti: ffffffff81be4000 task.ti: ffffffff81be4000\n RIP: 0010:[<ffffffff810fa205>]  [<ffffffff810fa205>] pids_cancel.constprop.4+0x5/0x40\n ...\n Call Trace:\n  <IRQ>\n  [<ffffffff810fb02d>] ? pids_free+0x3d/0xa0\n  [<ffffffff810f8893>] cgroup_free+0x53/0xe0\n  [<ffffffff8104ed62>] __put_task_struct+0x42/0x130\n  [<ffffffff81053557>] delayed_put_task_struct+0x77/0x130\n  [<ffffffff810c6b34>] rcu_process_callbacks+0x2f4/0x820\n  [<ffffffff810c6af3>] ? rcu_process_callbacks+0x2b3/0x820\n  [<ffffffff81056e54>] __do_softirq+0xd4/0x460\n  [<ffffffff81057369>] irq_exit+0x89/0xa0\n  [<ffffffff81876212>] smp_apic_timer_interrupt+0x42/0x50\n  [<ffffffff818747f4>] apic_timer_interrupt+0x84/0x90\n  <EOI>\n ...\n Code: 5b 5d c3 48 89 df 48 c7 c2 c9 f9 ae 81 48 c7 c6 91 2c ae 81 e8 1d 94 0e 00 31 c0 5b 5d c3 0f 1f 84 00 00 00 00 00 0f 1f 44 00 00 <f0> 48 83 87 e0 00 00 00 ff 78 01 c3 80 3d 08 7a c1 00 00 74 02\n RIP  [<ffffffff810fa205>] pids_cancel.constprop.4+0x5/0x40\n  RSP <ffff88001fc03e20>\n ---[ end trace 89a4a4b916b90c49 ]---\n Kernel panic - not syncing: Fatal exception in interrupt\n Kernel Offset: disabled\n ---[ end Kernel panic - not syncing: Fatal exception in interrupt\n\nFix it by making css_set pin the associate css's until its release.\n\nSigned-off-by: Tejun Heo <tj@kernel.org>\nReported-by: Dave Jones <davej@codemonkey.org.uk>\nReported-by: Daniel Wagner <daniel.wagner@bmw-carit.de>\nLink: http://lkml.kernel.org/g/20151120041836.GA18390@codemonkey.org.uk\nLink: http://lkml.kernel.org/g/5652D448.3080002@bmw-carit.de\nFixes: afcf6c8b7544 (\"cgroup: add cgroup_subsys->free() method and use it to fix pids controller\")",
        "before_after_code_files": [
          "kernel/cgroup.c||kernel/cgroup.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "kernel/cgroup.c||kernel/cgroup.c": [
          "File: kernel/cgroup.c -> kernel/cgroup.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "760:  if (!atomic_dec_and_test(&cset->refcount))",
          "761:   return;",
          "765:   list_del(&cset->e_cset_node[ssid]);",
          "766:  hash_del(&cset->hlist);",
          "767:  css_set_count--;",
          "",
          "[Removed Lines]",
          "764:  for_each_subsys(ss, ssid)",
          "",
          "[Added Lines]",
          "764:  for_each_subsys(ss, ssid) {",
          "766:   css_put(cset->subsys[ssid]);",
          "767:  }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1062:  key = css_set_hash(cset->subsys);",
          "1063:  hash_add(css_set_table, &cset->hlist, key);",
          "1066:   list_add_tail(&cset->e_cset_node[ssid],",
          "1069:  spin_unlock_bh(&css_set_lock);",
          "",
          "[Removed Lines]",
          "1065:  for_each_subsys(ss, ssid)",
          "1067:          &cset->subsys[ssid]->cgroup->e_csets[ssid]);",
          "",
          "[Added Lines]",
          "1067:  for_each_subsys(ss, ssid) {",
          "1068:   struct cgroup_subsys_state *css = cset->subsys[ssid];",
          "1071:          &css->cgroup->e_csets[ssid]);",
          "1072:   css_get(css);",
          "1073:  }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "d0fe5258e6be609dab7e53335d845818684d1dcf",
      "candidate_info": {
        "commit_hash": "d0fe5258e6be609dab7e53335d845818684d1dcf",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/d0fe5258e6be609dab7e53335d845818684d1dcf",
        "files": [
          "drivers/i2c/busses/i2c-xiic.c"
        ],
        "message": "i2c: xiic: Prevent concurrent running of the IRQ handler and __xiic_start_xfer()\n\nPrior to commit e6c9a037bc8a (\"i2c: xiic: Remove the disabling of\ninterrupts\") IRQs where disabled when the initial __xiic_start_xfer() was\ncalled. After the commit the interrupt is enabled while the function is\nrunning, this means it is possible for the interrupt to be triggered while\nthe function is still running. When this happens the internal data\nstructures get corrupted and undefined behavior can occur like the\nfollowing crash:\n\n\tInternal error: Oops: 17 [#1] PREEMPT SMP ARM\n\tModules linked in:\n\tCPU: 0 PID: 2040 Comm: i2cdetect Not tainted 4.0.0-02856-g047a308 #10956\n\tHardware name: Xilinx Zynq Platform\n\ttask: ee0c9500 ti: e99a2000 task.ti: e99a2000\n\tPC is at __xiic_start_xfer+0x6c4/0x7c8\n\tLR is at __xiic_start_xfer+0x690/0x7c8\n\tpc : [<c02bbffc>]    lr : [<c02bbfc8>]    psr: 800f0013\n\tsp : e99a3da8  ip : 00000000  fp : 00000000\n\tr10: 00000001  r9 : 600f0013  r8 : f0180000\n\tr7 : f0180000  r6 : c064e444  r5 : 00000017  r4 : ee031010\n\tr3 : 00000000  r2 : 00000000  r1 : 600f0013  r0 : 0000000f\n\tFlags: Nzcv  IRQs on  FIQs on  Mode SVC_32  ISA ARM  Segment user\n\tControl: 18c5387d  Table: 29a5404a  DAC: 00000015\n\tProcess i2cdetect (pid: 2040, stack limit = 0xe99a2210)\n\tStack: (0xe99a3da8 to 0xe99a4000)\n\t3da0:                   ee031010 00000000 00000001 ee031020 ee031224 c02bc5ec\n\t3dc0: ee34c604 00000000 ee0c9500 e99a3dcc e99a3dd0 e99a3dd0 e99a3dd8 c069f0e8\n\t3de0: 00000000 ee031020 c064e100 ffff90bb e99a3e48 c02b6590 ee031020 00000001\n\t3e00: e99a3e48 ee031020 00000000 e99a3e63 00000001 c02b6ec4 00000000 00000000\n\t3e20: 00000000 c02b7320 e99a3ef0 00000000 00000000 e99e3df0 00000000 00000000\n\t3e40: 00000103 2814575f 0000003e c00a0000 e99a3e85 0001003e ee0c0000 e99a3e63\n\t3e60: eefd3578 c064e61c ee0c9500 c0041e04 0000056c e9a56db8 00006e5a b6f5c000\n\t3e80: ee0c9548 eefd0040 00000001 eefd3540 ee0c9500 eefd39a0 c064b540 ee0c9500\n\t3ea0: 00000000 ee92b000 00000000 bef4862c ee34c600 e99ecdc0 00000720 00000003\n\t3ec0: e99a2000 00000000 00000000 c02b8b30 00000000 00000000 00000000 e99a3f24\n\t3ee0: b6e80000 00000000 00000000 c04257e8 00000000 e99a3f24 c02b8f08 00000703\n\t3f00: 00000003 c02116bc ee935300 00000000 bef4862c ee34c600 e99ecdc0 c02b91f0\n\t3f20: e99ecdc0 00000720 bef4862c eeb725f8 e99ecdc0 c00c9e2c 00000003 00000003\n\t3f40: ee248dc0 00000000 ee248dc8 00000002 eeb7c1a8 00000000 00000000 c00bb360\n\t3f60: 00000000 00000000 00000003 ee248dc0 bef4862c e99ecdc0 e99ecdc0 00000720\n\t3f80: 00000003 e99a2000 00000000 c00c9f68 00000000 00000000 b6f22000 00000036\n\t3fa0: c000dfa4 c000de20 00000000 00000000 00000003 00000720 bef4862c bef4862c\n\t3fc0: 00000000 00000000 b6f22000 00000036 00000000 00000000 b6f60000 00000000\n\t3fe0: 00013040 bef48614 00008cab b6ecdbe6 400f0030 00000003 2f7fd821 2f7fdc21\n\t[<c02bbffc>] (__xiic_start_xfer) from [<c02bc5ec>] (xiic_xfer+0x94/0x168)\n\t[<c02bc5ec>] (xiic_xfer) from [<c02b6590>] (__i2c_transfer+0x4c/0x7c)\n\t[<c02b6590>] (__i2c_transfer) from [<c02b6ec4>] (i2c_transfer+0x9c/0xc4)\n\t[<c02b6ec4>] (i2c_transfer) from [<c02b7320>] (i2c_smbus_xfer+0x3a0/0x4ec)\n\t[<c02b7320>] (i2c_smbus_xfer) from [<c02b8b30>] (i2cdev_ioctl_smbus+0xb0/0x214)\n\t[<c02b8b30>] (i2cdev_ioctl_smbus) from [<c02b91f0>] (i2cdev_ioctl+0xa0/0x1d4)\n\t[<c02b91f0>] (i2cdev_ioctl) from [<c00c9e2c>] (do_vfs_ioctl+0x4b0/0x5b8)\n\t[<c00c9e2c>] (do_vfs_ioctl) from [<c00c9f68>] (SyS_ioctl+0x34/0x5c)\n\t[<c00c9f68>] (SyS_ioctl) from [<c000de20>] (ret_fast_syscall+0x0/0x34)\n\tCode: e283300c e5843210 eafffe64 e5943210 (e1d320b4)\n\nThe issue can easily be reproduced by performing I2C access under high\nsystem load or IO load.\n\nTo fix the issue protect the invocation to __xiic_start_xfer() form\nxiic_start_xfer() with the same lock that is used to protect the interrupt\nhandler.\n\nFixes: e6c9a037bc8a (\"i2c: xiic: Remove the disabling of interrupts\")\nSigned-off-by: Lars-Peter Clausen <lars@metafoo.de>\nReviewed-by: Shubhrajyoti Datta <shubhraj@xilinx.com>\nSigned-off-by: Wolfram Sang <wsa@the-dreams.de>",
        "before_after_code_files": [
          "drivers/i2c/busses/i2c-xiic.c||drivers/i2c/busses/i2c-xiic.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "drivers/i2c/busses/i2c-xiic.c||drivers/i2c/busses/i2c-xiic.c": [
          "File: drivers/i2c/busses/i2c-xiic.c -> drivers/i2c/busses/i2c-xiic.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "664: {",
          "665:  spin_lock(&i2c->lock);",
          "666:  xiic_reinit(i2c);",
          "669:  __xiic_start_xfer(i2c);",
          "670: }",
          "672: static int xiic_xfer(struct i2c_adapter *adap, struct i2c_msg *msgs, int num)",
          "",
          "[Removed Lines]",
          "667:  spin_unlock(&i2c->lock);",
          "",
          "[Added Lines]",
          "668:  spin_unlock(&i2c->lock);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "2e6edc95382cc36423aff18a237173ad62d5ab52",
      "candidate_info": {
        "commit_hash": "2e6edc95382cc36423aff18a237173ad62d5ab52",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/2e6edc95382cc36423aff18a237173ad62d5ab52",
        "files": [
          "block/blk.h",
          "fs/block_dev.c",
          "include/linux/blkdev.h"
        ],
        "message": "block: protect rw_page against device teardown\n\nFix use after free crashes like the following:\n\n general protection fault: 0000 [#1] SMP\n Call Trace:\n  [<ffffffffa0050216>] ? pmem_do_bvec.isra.12+0xa6/0xf0 [nd_pmem]\n  [<ffffffffa0050ba2>] pmem_rw_page+0x42/0x80 [nd_pmem]\n  [<ffffffff8128fd90>] bdev_read_page+0x50/0x60\n  [<ffffffff812972f0>] do_mpage_readpage+0x510/0x770\n  [<ffffffff8128fd20>] ? I_BDEV+0x20/0x20\n  [<ffffffff811d86dc>] ? lru_cache_add+0x1c/0x50\n  [<ffffffff81297657>] mpage_readpages+0x107/0x170\n  [<ffffffff8128fd20>] ? I_BDEV+0x20/0x20\n  [<ffffffff8128fd20>] ? I_BDEV+0x20/0x20\n  [<ffffffff8129058d>] blkdev_readpages+0x1d/0x20\n  [<ffffffff811d615f>] __do_page_cache_readahead+0x28f/0x310\n  [<ffffffff811d6039>] ? __do_page_cache_readahead+0x169/0x310\n  [<ffffffff811c5abd>] ? pagecache_get_page+0x2d/0x1d0\n  [<ffffffff811c76f6>] filemap_fault+0x396/0x530\n  [<ffffffff811f816e>] __do_fault+0x4e/0xf0\n  [<ffffffff811fce7d>] handle_mm_fault+0x11bd/0x1b50\n\nCc: <stable@vger.kernel.org>\nCc: Jens Axboe <axboe@fb.com>\nCc: Alexander Viro <viro@zeniv.linux.org.uk>\nReported-by: kbuild test robot <lkp@intel.com>\nAcked-by: Matthew Wilcox <willy@linux.intel.com>\n[willy: symmetry fixups]\nSigned-off-by: Dan Williams <dan.j.williams@intel.com>",
        "before_after_code_files": [
          "block/blk.h||block/blk.h",
          "fs/block_dev.c||fs/block_dev.c",
          "include/linux/blkdev.h||include/linux/blkdev.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "block/blk.h||block/blk.h": [
          "File: block/blk.h -> block/blk.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "72: void __blk_queue_free_tags(struct request_queue *q);",
          "73: bool __blk_end_bidi_request(struct request *rq, int error,",
          "74:        unsigned int nr_bytes, unsigned int bidi_bytes);",
          "77: void blk_freeze_queue(struct request_queue *q);",
          "79: static inline void blk_queue_enter_live(struct request_queue *q)",
          "",
          "[Removed Lines]",
          "75: int blk_queue_enter(struct request_queue *q, gfp_t gfp);",
          "76: void blk_queue_exit(struct request_queue *q);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "fs/block_dev.c||fs/block_dev.c": [
          "File: fs/block_dev.c -> fs/block_dev.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "390:    struct page *page)",
          "391: {",
          "392:  const struct block_device_operations *ops = bdev->bd_disk->fops;",
          "393:  if (!ops->rw_page || bdev_get_integrity(bdev))",
          "396: }",
          "397: EXPORT_SYMBOL_GPL(bdev_read_page);",
          "",
          "[Removed Lines]",
          "394:   return -EOPNOTSUPP;",
          "395:  return ops->rw_page(bdev, sector + get_start_sect(bdev), page, READ);",
          "",
          "[Added Lines]",
          "393:  int result = -EOPNOTSUPP;",
          "396:   return result;",
          "398:  result = blk_queue_enter(bdev->bd_queue, GFP_KERNEL);",
          "399:  if (result)",
          "400:   return result;",
          "401:  result = ops->rw_page(bdev, sector + get_start_sect(bdev), page, READ);",
          "402:  blk_queue_exit(bdev->bd_queue);",
          "403:  return result;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "421:  int result;",
          "422:  int rw = (wbc->sync_mode == WB_SYNC_ALL) ? WRITE_SYNC : WRITE;",
          "423:  const struct block_device_operations *ops = bdev->bd_disk->fops;",
          "424:  if (!ops->rw_page || bdev_get_integrity(bdev))",
          "425:   return -EOPNOTSUPP;",
          "426:  set_page_writeback(page);",
          "427:  result = ops->rw_page(bdev, sector + get_start_sect(bdev), page, rw);",
          "428:  if (result)",
          "429:   end_page_writeback(page);",
          "430:  else",
          "431:   unlock_page(page);",
          "432:  return result;",
          "433: }",
          "434: EXPORT_SYMBOL_GPL(bdev_write_page);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "435:  result = blk_queue_enter(bdev->bd_queue, GFP_KERNEL);",
          "436:  if (result)",
          "437:   return result;",
          "445:  blk_queue_exit(bdev->bd_queue);",
          "",
          "---------------"
        ],
        "include/linux/blkdev.h||include/linux/blkdev.h": [
          "File: include/linux/blkdev.h -> include/linux/blkdev.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "794: extern int sg_scsi_ioctl(struct request_queue *, struct gendisk *, fmode_t,",
          "795:     struct scsi_ioctl_command __user *);",
          "797: extern void blk_start_queue(struct request_queue *q);",
          "798: extern void blk_stop_queue(struct request_queue *q);",
          "799: extern void blk_sync_queue(struct request_queue *q);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "797: extern int blk_queue_enter(struct request_queue *q, gfp_t gfp);",
          "798: extern void blk_queue_exit(struct request_queue *q);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "918af9f941af9995fcaa7ef1eb67c433a492e2b3",
      "candidate_info": {
        "commit_hash": "918af9f941af9995fcaa7ef1eb67c433a492e2b3",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/918af9f941af9995fcaa7ef1eb67c433a492e2b3",
        "files": [
          "arch/arm/mach-omap2/omap-smp.c"
        ],
        "message": "ARM: OMAP4+: SMP: use lockless clkdm/pwrdm api in omap4_boot_secondary\n\nOMAP CPU hotplug uses cpu1's clocks and power domains for CPU1 wake up\nfrom low power states (or turn on CPU1). This part of code is also\npart of system suspend (disable_nonboot_cpus()).\n>From other side, cpu1's clocks and power domains are used by CPUIdle. All above\nfunctionality is mutually exclusive and, therefore, lockless clkdm/pwrdm api\ncan be used in omap4_boot_secondary().\n\nThis fixes below back-trace on -RT which is triggered by\npwrdm_lock/unlock():\n\nBUG: sleeping function called from invalid context at kernel/locking/rtmutex.c:917\n in_atomic(): 1, irqs_disabled(): 0, pid: 118, name: sh\n 9 locks held by sh/118:\n  #0:  (sb_writers#4){.+.+.+}, at: [<c0144a6c>] vfs_write+0x13c/0x164\n  #1:  (&of->mutex){+.+.+.}, at: [<c01b4c70>] kernfs_fop_write+0x48/0x19c\n  #2:  (s_active#24){.+.+.+}, at: [<c01b4c78>] kernfs_fop_write+0x50/0x19c\n  #3:  (device_hotplug_lock){+.+.+.}, at: [<c03cbff0>] lock_device_hotplug_sysfs+0xc/0x4c\n  #4:  (&dev->mutex){......}, at: [<c03cd284>] device_online+0x14/0x88\n  #5:  (cpu_add_remove_lock){+.+.+.}, at: [<c003af90>] cpu_up+0x50/0x1a0\n  #6:  (cpu_hotplug.lock){++++++}, at: [<c003ae48>] cpu_hotplug_begin+0x0/0xc4\n  #7:  (cpu_hotplug.lock#2){+.+.+.}, at: [<c003aec0>] cpu_hotplug_begin+0x78/0xc4\n  #8:  (boot_lock){+.+...}, at: [<c002b254>] omap4_boot_secondary+0x1c/0x178\n Preemption disabled at:[<  (null)>]   (null)\n\n CPU: 0 PID: 118 Comm: sh Not tainted 4.1.12-rt11-01998-gb4a62c3-dirty #137\n Hardware name: Generic DRA74X (Flattened Device Tree)\n [<c0017574>] (unwind_backtrace) from [<c0013be8>] (show_stack+0x10/0x14)\n [<c0013be8>] (show_stack) from [<c05a8670>] (dump_stack+0x80/0x94)\n [<c05a8670>] (dump_stack) from [<c05ad158>] (rt_spin_lock+0x24/0x54)\n [<c05ad158>] (rt_spin_lock) from [<c0030dac>] (clkdm_wakeup+0x10/0x2c)\n [<c0030dac>] (clkdm_wakeup) from [<c002b2c0>] (omap4_boot_secondary+0x88/0x178)\n [<c002b2c0>] (omap4_boot_secondary) from [<c0015d00>] (__cpu_up+0xc4/0x164)\n [<c0015d00>] (__cpu_up) from [<c003b09c>] (cpu_up+0x15c/0x1a0)\n [<c003b09c>] (cpu_up) from [<c03cd2d4>] (device_online+0x64/0x88)\n [<c03cd2d4>] (device_online) from [<c03cd360>] (online_store+0x68/0x74)\n [<c03cd360>] (online_store) from [<c01b4ce0>] (kernfs_fop_write+0xb8/0x19c)\n [<c01b4ce0>] (kernfs_fop_write) from [<c0144124>] (__vfs_write+0x20/0xd8)\n [<c0144124>] (__vfs_write) from [<c01449c0>] (vfs_write+0x90/0x164)\n [<c01449c0>] (vfs_write) from [<c01451e4>] (SyS_write+0x44/0x9c)\n [<c01451e4>] (SyS_write) from [<c0010240>] (ret_fast_syscall+0x0/0x54)\n CPU1: smp_ops.cpu_die() returned, trying to resuscitate\n\nCc: Tero Kristo <t-kristo@ti.com>\nSigned-off-by: Grygorii Strashko <grygorii.strashko@ti.com>\nSigned-off-by: Tony Lindgren <tony@atomide.com>",
        "before_after_code_files": [
          "arch/arm/mach-omap2/omap-smp.c||arch/arm/mach-omap2/omap-smp.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "arch/arm/mach-omap2/omap-smp.c||arch/arm/mach-omap2/omap-smp.c": [
          "File: arch/arm/mach-omap2/omap-smp.c -> arch/arm/mach-omap2/omap-smp.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "150:   if (IS_PM44XX_ERRATUM(PM_OMAP4_ROM_SMP_BOOT_ERRATUM_GICD)) {",
          "151:    while (gic_dist_disabled()) {",
          "",
          "[Removed Lines]",
          "146:   clkdm_wakeup(cpu1_clkdm);",
          "147:   omap_set_pwrdm_state(cpu1_pwrdm, PWRDM_POWER_ON);",
          "148:   clkdm_allow_idle(cpu1_clkdm);",
          "",
          "[Added Lines]",
          "146:   clkdm_wakeup_nolock(cpu1_clkdm);",
          "147:   pwrdm_set_next_pwrst(cpu1_pwrdm, PWRDM_POWER_ON);",
          "148:   clkdm_allow_idle_nolock(cpu1_clkdm);",
          "",
          "---------------"
        ]
      }
    }
  ]
}
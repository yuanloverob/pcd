{
  "cve_id": "CVE-2013-1767",
  "cve_desc": "Use-after-free vulnerability in the shmem_remount_fs function in mm/shmem.c in the Linux kernel before 3.7.10 allows local users to gain privileges or cause a denial of service (system crash) by remounting a tmpfs filesystem without specifying a required mpol (aka mempolicy) mount option.",
  "repo": "torvalds/linux",
  "patch_hash": "5f00110f7273f9ff04ac69a5f85bb535a4fd0987",
  "patch_info": {
    "commit_hash": "5f00110f7273f9ff04ac69a5f85bb535a4fd0987",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/5f00110f7273f9ff04ac69a5f85bb535a4fd0987",
    "files": [
      "mm/shmem.c"
    ],
    "message": "tmpfs: fix use-after-free of mempolicy object\n\nThe tmpfs remount logic preserves filesystem mempolicy if the mpol=M\noption is not specified in the remount request.  A new policy can be\nspecified if mpol=M is given.\n\nBefore this patch remounting an mpol bound tmpfs without specifying\nmpol= mount option in the remount request would set the filesystem's\nmempolicy object to a freed mempolicy object.\n\nTo reproduce the problem boot a DEBUG_PAGEALLOC kernel and run:\n    # mkdir /tmp/x\n\n    # mount -t tmpfs -o size=100M,mpol=interleave nodev /tmp/x\n\n    # grep /tmp/x /proc/mounts\n    nodev /tmp/x tmpfs rw,relatime,size=102400k,mpol=interleave:0-3 0 0\n\n    # mount -o remount,size=200M nodev /tmp/x\n\n    # grep /tmp/x /proc/mounts\n    nodev /tmp/x tmpfs rw,relatime,size=204800k,mpol=??? 0 0\n        # note ? garbage in mpol=... output above\n\n    # dd if=/dev/zero of=/tmp/x/f count=1\n        # panic here\n\nPanic:\n    BUG: unable to handle kernel NULL pointer dereference at           (null)\n    IP: [<          (null)>]           (null)\n    [...]\n    Oops: 0010 [#1] SMP DEBUG_PAGEALLOC\n    Call Trace:\n      mpol_shared_policy_init+0xa5/0x160\n      shmem_get_inode+0x209/0x270\n      shmem_mknod+0x3e/0xf0\n      shmem_create+0x18/0x20\n      vfs_create+0xb5/0x130\n      do_last+0x9a1/0xea0\n      path_openat+0xb3/0x4d0\n      do_filp_open+0x42/0xa0\n      do_sys_open+0xfe/0x1e0\n      compat_sys_open+0x1b/0x20\n      cstar_dispatch+0x7/0x1f\n\nNon-debug kernels will not crash immediately because referencing the\ndangling mpol will not cause a fault.  Instead the filesystem will\nreference a freed mempolicy object, which will cause unpredictable\nbehavior.\n\nThe problem boils down to a dropped mpol reference below if\nshmem_parse_options() does not allocate a new mpol:\n\n    config = *sbinfo\n    shmem_parse_options(data, &config, true)\n    mpol_put(sbinfo->mpol)\n    sbinfo->mpol = config.mpol  /* BUG: saves unreferenced mpol */\n\nThis patch avoids the crash by not releasing the mempolicy if\nshmem_parse_options() doesn't create a new mpol.\n\nHow far back does this issue go? I see it in both 2.6.36 and 3.3.  I did\nnot look back further.\n\nSigned-off-by: Greg Thelen <gthelen@google.com>\nAcked-by: Hugh Dickins <hughd@google.com>\nCc: <stable@vger.kernel.org>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
    "before_after_code_files": [
      "mm/shmem.c||mm/shmem.c"
    ]
  },
  "patch_diff": {
    "mm/shmem.c||mm/shmem.c": [
      "File: mm/shmem.c -> mm/shmem.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "2486:  unsigned long inodes;",
      "2487:  int error = -EINVAL;",
      "2489:  if (shmem_parse_options(data, &config, true))",
      "2490:   return error;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "2489:  config.mpol = NULL;",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "2510:  sbinfo->max_inodes  = config.max_inodes;",
      "2511:  sbinfo->free_inodes = config.max_inodes - inodes;",
      "2515: out:",
      "2516:  spin_unlock(&sbinfo->stat_lock);",
      "2517:  return error;",
      "",
      "[Removed Lines]",
      "2513:  mpol_put(sbinfo->mpol);",
      "",
      "[Added Lines]",
      "2517:  if (config.mpol) {",
      "2518:   mpol_put(sbinfo->mpol);",
      "2520:  }",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "c4c605246452d0e578945ea95a8e72877e97e8c6",
      "candidate_info": {
        "commit_hash": "c4c605246452d0e578945ea95a8e72877e97e8c6",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/c4c605246452d0e578945ea95a8e72877e97e8c6",
        "files": [
          "arch/x86/kernel/acpi/boot.c",
          "arch/x86/mm/numa.c"
        ],
        "message": "cpu_hotplug: clear apicid to node when the cpu is hotremoved\n\nWhen a cpu is hotpluged, we call acpi_map_cpu2node() in\n_acpi_map_lsapic() to store the cpu's node and apicid's node.  But we\ndon't clear the cpu's node in acpi_unmap_lsapic() when this cpu is\nhotremoved.  If the node is also hotremoved, we will get the following\nmessages:\n\n  kernel BUG at include/linux/gfp.h:329!\n  invalid opcode: 0000 [#1] SMP\n  Modules linked in: ebtable_nat ebtables ipt_MASQUERADE iptable_nat nf_nat xt_CHECKSUM iptable_mangle bridge stp llc sunrpc ipt_REJECT nf_conntrack_ipv4 nf_defrag_ipv4 iptable_filter ip_tables ip6t_REJECT nf_conntrack_ipv6 nf_defrag_ipv6 xt_state nf_conntrack ip6table_filter ip6_tables binfmt_misc dm_mirror dm_region_hash dm_log dm_mod vhost_net macvtap macvlan tun uinput iTCO_wdt iTCO_vendor_support coretemp kvm_intel kvm crc32c_intel microcode pcspkr i2c_i801 i2c_core lpc_ich mfd_core ioatdma e1000e i7core_edac edac_core sg acpi_memhotplug igb dca sd_mod crc_t10dif megaraid_sas mptsas mptscsih mptbase scsi_transport_sas scsi_mod\n  Pid: 3126, comm: init Not tainted 3.6.0-rc3-tangchen-hostbridge+ #13 FUJITSU-SV PRIMEQUEST 1800E/SB\n  RIP: 0010:[<ffffffff811bc3fd>]  [<ffffffff811bc3fd>] allocate_slab+0x28d/0x300\n  RSP: 0018:ffff88078a049cf8  EFLAGS: 00010246\n  RAX: 0000000000000000 RBX: 0000000000000001 RCX: 0000000000000000\n  RDX: 0000000000000001 RSI: 0000000000000001 RDI: 0000000000000246\n  RBP: ffff88078a049d38 R08: 00000000000040d0 R09: 0000000000000001\n  R10: 0000000000000000 R11: 0000000000000b5f R12: 00000000000052d0\n  R13: ffff8807c1417300 R14: 0000000000030038 R15: 0000000000000003\n  FS:  00007fa9b1b44700(0000) GS:ffff8807c3800000(0000) knlGS:0000000000000000\n  CS:  0010 DS: 0000 ES: 0000 CR0: 000000008005003b\n  CR2: 00007fa9b09acca0 CR3: 000000078b855000 CR4: 00000000000007e0\n  DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\n  DR3: 0000000000000000 DR6: 00000000ffff0ff0 DR7: 0000000000000400\n  Process init (pid: 3126, threadinfo ffff88078a048000, task ffff8807bb6f2650)\n  Call Trace:\n    new_slab+0x30/0x1b0\n    __slab_alloc+0x358/0x4c0\n    kmem_cache_alloc_node_trace+0xb4/0x1e0\n    alloc_fair_sched_group+0xd0/0x1b0\n    sched_create_group+0x3e/0x110\n    sched_autogroup_create_attach+0x4d/0x180\n    sys_setsid+0xd4/0xf0\n    system_call_fastpath+0x16/0x1b\n  Code: 89 c4 e9 73 fe ff ff 31 c0 89 de 48 c7 c7 45 de 9e 81 44 89 45 c8 e8 22 05 4b 00 85 db 44 8b 45 c8 0f 89 4f ff ff ff 0f 0b eb fe <0f> 0b 90 eb fd 0f 0b eb fe 89 de 48 c7 c7 45 de 9e 81 31 c0 44\n  RIP  [<ffffffff811bc3fd>] allocate_slab+0x28d/0x300\n   RSP <ffff88078a049cf8>\n  ---[ end trace adf84c90f3fea3e5 ]---\n\nThe reason is that the cpu's node is not NUMA_NO_NODE, we will call\nalloc_pages_exact_node() to alloc memory on the node, but the node is\nofflined.\n\nIf the node is onlined, we still need cpu's node.  For example: a task\non the cpu is sleeped when the cpu is hotremoved.  We will choose\nanother cpu to run this task when it is waked up.  If we know the cpu's\nnode, we will choose the cpu on the same node first.  So we should clear\ncpu-to-node mapping when the node is offlined.\n\nThis patch only clears apicid-to-node mapping when the cpu is\nhotremoved.\n\n[akpm@linux-foundation.org: fix section error]\nSigned-off-by: Wen Congyang <wency@cn.fujitsu.com>\nSigned-off-by: Tang Chen <tangchen@cn.fujitsu.com>\nCc: Yasuaki Ishimatsu <isimatu.yasuaki@jp.fujitsu.com>\nCc: David Rientjes <rientjes@google.com>\nCc: Jiang Liu <liuj97@gmail.com>\nCc: Minchan Kim <minchan.kim@gmail.com>\nCc: KOSAKI Motohiro <kosaki.motohiro@jp.fujitsu.com>\nCc: Mel Gorman <mel@csn.ul.ie>\nCc: Thomas Gleixner <tglx@linutronix.de>\nCc: Ingo Molnar <mingo@redhat.com>\nCc: \"H. Peter Anvin\" <hpa@zytor.com>\nCc: Peter Zijlstra <peterz@infradead.org>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
        "before_after_code_files": [
          "arch/x86/kernel/acpi/boot.c||arch/x86/kernel/acpi/boot.c",
          "arch/x86/mm/numa.c||arch/x86/mm/numa.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "arch/x86/kernel/acpi/boot.c||arch/x86/kernel/acpi/boot.c": [
          "File: arch/x86/kernel/acpi/boot.c -> arch/x86/kernel/acpi/boot.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "697: int acpi_unmap_lsapic(int cpu)",
          "698: {",
          "699:  per_cpu(x86_cpu_to_apicid, cpu) = -1;",
          "700:  set_cpu_present(cpu, false);",
          "701:  num_processors--;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "699: #ifdef CONFIG_ACPI_NUMA",
          "700:  set_apicid_to_node(per_cpu(x86_cpu_to_apicid, cpu), NUMA_NO_NODE);",
          "701: #endif",
          "",
          "---------------"
        ],
        "arch/x86/mm/numa.c||arch/x86/mm/numa.c": [
          "File: arch/x86/mm/numa.c -> arch/x86/mm/numa.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "60:  [0 ... MAX_LOCAL_APIC-1] = NUMA_NO_NODE",
          "61: };",
          "",
          "[Removed Lines]",
          "59: s16 __apicid_to_node[MAX_LOCAL_APIC] __cpuinitdata = {",
          "",
          "[Added Lines]",
          "59: s16 __apicid_to_node[MAX_LOCAL_APIC] = {",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "f6488c9ba51d65410e2dbc4345413c0d9120971e",
      "candidate_info": {
        "commit_hash": "f6488c9ba51d65410e2dbc4345413c0d9120971e",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/f6488c9ba51d65410e2dbc4345413c0d9120971e",
        "files": [
          "fs/nfs/inode.c"
        ],
        "message": "nfs: don't allow nfs_find_actor to match inodes of the wrong type\n\nBenny Halevy reported the following oops when testing RHEL6:\n\n<7>nfs_update_inode: inode 892950 mode changed, 0040755 to 0100644\n<1>BUG: unable to handle kernel NULL pointer dereference at (null)\n<1>IP: [<ffffffffa02a52c5>] nfs_closedir+0x15/0x30 [nfs]\n<4>PGD 81448a067 PUD 831632067 PMD 0\n<4>Oops: 0000 [#1] SMP\n<4>last sysfs file: /sys/kernel/mm/redhat_transparent_hugepage/enabled\n<4>CPU 6\n<4>Modules linked in: fuse bonding 8021q garp ebtable_nat ebtables be2iscsi iscsi_boot_sysfs bnx2i cnic uio cxgb4i cxgb4 cxgb3i libcxgbi cxgb3 mdio ib_iser rdma_cm ib_cm iw_cm ib_sa ib_mad ib_core ib_addr iscsi_tcp libiscsi_tcp libiscsi scsi_transport_iscsi softdog bridge stp llc xt_physdev ipt_REJECT nf_conntrack_ipv4 nf_defrag_ipv4 xt_multiport iptable_filter ip_tables ip6t_REJECT nf_conntrack_ipv6 nf_defrag_ipv6 xt_state nf_conntrack ip6table_filter ip6_tables ipv6 dm_round_robin dm_multipath objlayoutdriver2(U) nfs(U) lockd fscache auth_rpcgss nfs_acl sunrpc vhost_net macvtap macvlan tun kvm_intel kvm be2net igb dca ptp pps_core microcode serio_raw sg iTCO_wdt iTCO_vendor_support i7core_edac edac_core shpchp ext4 mbcache jbd2 sd_mod crc_t10dif ahci dm_mirror dm_region_hash dm_log dm_mod [last unloaded: scsi_wait_scan]\n<4>\n<4>Pid: 6332, comm: dd Not tainted 2.6.32-358.el6.x86_64 #1 HP ProLiant DL170e G6  /ProLiant DL170e G6\n<4>RIP: 0010:[<ffffffffa02a52c5>]  [<ffffffffa02a52c5>] nfs_closedir+0x15/0x30 [nfs]\n<4>RSP: 0018:ffff88081458bb98  EFLAGS: 00010292\n<4>RAX: ffffffffa02a52b0 RBX: 0000000000000000 RCX: 0000000000000003\n<4>RDX: ffffffffa02e45a0 RSI: ffff88081440b300 RDI: ffff88082d5f5760\n<4>RBP: ffff88081458bba8 R08: 0000000000000000 R09: 0000000000000000\n<4>R10: 0000000000000772 R11: 0000000000400004 R12: 0000000040000008\n<4>R13: ffff88082d5f5760 R14: ffff88082d6e8800 R15: ffff88082f12d780\n<4>FS:  00007f728f37e700(0000) GS:ffff8800456c0000(0000) knlGS:0000000000000000\n<4>CS:  0010 DS: 0000 ES: 0000 CR0: 000000008005003b\n<4>CR2: 0000000000000000 CR3: 0000000831279000 CR4: 00000000000007e0\n<4>DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\n<4>DR3: 0000000000000000 DR6: 00000000ffff0ff0 DR7: 0000000000000400\n<4>Process dd (pid: 6332, threadinfo ffff88081458a000, task ffff88082fa0e040)\n<4>Stack:\n<4> 0000000040000008 ffff88081440b300 ffff88081458bbf8 ffffffff81182745\n<4><d> ffff88082d5f5760 ffff88082d6e8800 ffff88081458bbf8 ffffffffffffffea\n<4><d> ffff88082f12d780 ffff88082d6e8800 ffffffffa02a50a0 ffff88082d5f5760\n<4>Call Trace:\n<4> [<ffffffff81182745>] __fput+0xf5/0x210\n<4> [<ffffffffa02a50a0>] ? do_open+0x0/0x20 [nfs]\n<4> [<ffffffff81182885>] fput+0x25/0x30\n<4> [<ffffffff8117e23e>] __dentry_open+0x27e/0x360\n<4> [<ffffffff811c397a>] ? inotify_d_instantiate+0x2a/0x60\n<4> [<ffffffff8117e4b9>] lookup_instantiate_filp+0x69/0x90\n<4> [<ffffffffa02a6679>] nfs_intent_set_file+0x59/0x90 [nfs]\n<4> [<ffffffffa02a686b>] nfs_atomic_lookup+0x1bb/0x310 [nfs]\n<4> [<ffffffff8118e0c2>] __lookup_hash+0x102/0x160\n<4> [<ffffffff81225052>] ? selinux_inode_permission+0x72/0xb0\n<4> [<ffffffff8118e76a>] lookup_hash+0x3a/0x50\n<4> [<ffffffff81192a4b>] do_filp_open+0x2eb/0xdd0\n<4> [<ffffffff8104757c>] ? __do_page_fault+0x1ec/0x480\n<4> [<ffffffff8119f562>] ? alloc_fd+0x92/0x160\n<4> [<ffffffff8117de79>] do_sys_open+0x69/0x140\n<4> [<ffffffff811811f6>] ? sys_lseek+0x66/0x80\n<4> [<ffffffff8117df90>] sys_open+0x20/0x30\n<4> [<ffffffff8100b072>] system_call_fastpath+0x16/0x1b\n<4>Code: 65 48 8b 04 25 c8 cb 00 00 83 a8 44 e0 ff ff 01 5b 41 5c c9 c3 90 55 48 89 e5 53 48 83 ec 08 0f 1f 44 00 00 48 8b 9e a0 00 00 00 <48> 8b 3b e8 13 0c f7 ff 48 89 df e8 ab 3d ec e0 48 83 c4 08 31\n<1>RIP  [<ffffffffa02a52c5>] nfs_closedir+0x15/0x30 [nfs]\n<4> RSP <ffff88081458bb98>\n<4>CR2: 0000000000000000\n\nI think this is ultimately due to a bug on the server. The client had\npreviously found a directory dentry. It then later tried to do an atomic\nopen on a new (regular file) dentry. The attributes it got back had the\nsame filehandle as the previously found directory inode. It then tried\nto put the filp because it failed the aops tests for O_DIRECT opens, and\noopsed here because the ctx was still NULL.\n\nObviously the root cause here is a server issue, but we can take steps\nto mitigate this on the client. When nfs_fhget is called, we always know\nwhat type of inode it is. In the event that there's a broken or\nmalicious server on the other end of the wire, the client can end up\ncrashing because the wrong ops are set on it.\n\nHave nfs_find_actor check that the inode type is correct after checking\nthe fileid. The fileid check should rarely ever match, so it should only\nrarely ever get to this check. In the case where we have a broken\nserver, we may see two different inodes with the same i_ino, but the\nclient should be able to cope with them without crashing.\n\nThis should fix the oops reported here:\n\n    https://bugzilla.redhat.com/show_bug.cgi?id=913660\n\nReported-by: Benny Halevy <bhalevy@tonian.com>\nSigned-off-by: Jeff Layton <jlayton@redhat.com>\nSigned-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>",
        "before_after_code_files": [
          "fs/nfs/inode.c||fs/nfs/inode.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "fs/nfs/inode.c||fs/nfs/inode.c": [
          "File: fs/nfs/inode.c -> fs/nfs/inode.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "238:  if (NFS_FILEID(inode) != fattr->fileid)",
          "239:   return 0;",
          "240:  if (nfs_compare_fh(NFS_FH(inode), fh))",
          "241:   return 0;",
          "242:  if (is_bad_inode(inode) || NFS_STALE(inode))",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "240:  if ((S_IFMT & inode->i_mode) != (S_IFMT & fattr->mode))",
          "241:   return 0;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "7992ae6df9733677fcc2e63c40b97854c605c399",
      "candidate_info": {
        "commit_hash": "7992ae6df9733677fcc2e63c40b97854c605c399",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/7992ae6df9733677fcc2e63c40b97854c605c399",
        "files": [
          "net/ipv4/ip_gre.c"
        ],
        "message": "Revert \"ip_gre: propogate target device GSO capability to the tunnel device\"\n\nThis reverts commit eb6b9a8cad65e820b145547844b108117cece3a0.\n\nAbove commit limits GSO capability of gre device to just TSO, but\nsoftware GRE-GSO is capable of handling all GSO capabilities.\n\nThis patch also fixes following panic which reverted commit introduced:-\n\nBUG: unable to handle kernel NULL pointer dereference at 00000000000000a2\nIP: [<ffffffffa0680fd1>] ipgre_tunnel_bind_dev+0x161/0x1f0 [ip_gre]\nPGD 42bc19067 PUD 42bca9067 PMD 0\nOops: 0000 [#1] SMP\nPid: 2636, comm: ip Tainted: GF            3.8.0+ #83 Dell Inc. PowerEdge R620/0KCKR5\nRIP: 0010:[<ffffffffa0680fd1>]  [<ffffffffa0680fd1>] ipgre_tunnel_bind_dev+0x161/0x1f0 [ip_gre]\nRSP: 0018:ffff88042bfcb708  EFLAGS: 00010246\nRAX: 00000000000005b6 RBX: ffff88042d2fa000 RCX: 0000000000000044\nRDX: 0000000000000018 RSI: 0000000000000078 RDI: 0000000000000060\nRBP: ffff88042bfcb748 R08: 0000000000000018 R09: 000000000000000c\nR10: 0000000000000020 R11: 000000000101010a R12: ffff88042d2fa800\nR13: 0000000000000000 R14: ffff88042d2fa800 R15: ffff88042cd7f650\nFS:  00007fa784f55700(0000) GS:ffff88043fd20000(0000) knlGS:0000000000000000\nCS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nCR2: 00000000000000a2 CR3: 000000042d8b9000 CR4: 00000000000407e0\nDR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\nDR3: 0000000000000000 DR6: 00000000ffff0ff0 DR7: 0000000000000400\nProcess ip (pid: 2636, threadinfo ffff88042bfca000, task ffff88042d142a80)\nStack:\n 0000000100000000 002f000000000000 0a01010100000000 000000000b010101\n ffff88042d2fa800 ffff88042d2fa000 ffff88042bfcb858 ffff88042f418c00\n ffff88042bfcb798 ffffffffa068199a ffff88042bfcb798 ffff88042d2fa830\nCall Trace:\n [<ffffffffa068199a>] ipgre_newlink+0xca/0x160 [ip_gre]\n [<ffffffff8143b692>] rtnl_newlink+0x532/0x5f0\n [<ffffffff8143b2fc>] ? rtnl_newlink+0x19c/0x5f0\n [<ffffffff81438978>] rtnetlink_rcv_msg+0x2c8/0x340\n [<ffffffff814386b0>] ? rtnetlink_rcv+0x40/0x40\n [<ffffffff814560f9>] netlink_rcv_skb+0xa9/0xd0\n [<ffffffff81438695>] rtnetlink_rcv+0x25/0x40\n [<ffffffff81455ddc>] netlink_unicast+0x1ac/0x230\n [<ffffffff81456a45>] netlink_sendmsg+0x265/0x380\n [<ffffffff814138c0>] sock_sendmsg+0xb0/0xe0\n [<ffffffff8141141e>] ? move_addr_to_kernel+0x4e/0x90\n [<ffffffff81420445>] ? verify_iovec+0x85/0xf0\n [<ffffffff81414ffd>] __sys_sendmsg+0x3fd/0x420\n [<ffffffff8114b701>] ? handle_mm_fault+0x251/0x3b0\n [<ffffffff8114f39f>] ? vma_link+0xcf/0xe0\n [<ffffffff81415239>] sys_sendmsg+0x49/0x90\n [<ffffffff814ffd19>] system_call_fastpath+0x16/0x1b\n\nCC: Dmitry Kravkov <dmitry@broadcom.com>\nSigned-off-by: Pravin B Shelar <pshelar@nicira.com>\nAcked-by: Dmitry Kravkov <dmitry@broadcom.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "before_after_code_files": [
          "net/ipv4/ip_gre.c||net/ipv4/ip_gre.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "net/ipv4/ip_gre.c||net/ipv4/ip_gre.c": [
          "File: net/ipv4/ip_gre.c -> net/ipv4/ip_gre.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1106:  tunnel->hlen = addend;",
          "1108:  if (!(tunnel->parms.o_flags & GRE_SEQ)) {",
          "1117:  }",
          "1119:  return mtu;",
          "",
          "[Removed Lines]",
          "1110:   if (tdev->hw_enc_features & NETIF_F_GRE_GSO) {",
          "1111:    dev->features  |= NETIF_F_TSO;",
          "1112:    dev->hw_features |= NETIF_F_TSO;",
          "1113:   } else {",
          "1114:    dev->features  |= NETIF_F_GSO_SOFTWARE;",
          "1115:    dev->hw_features |= NETIF_F_GSO_SOFTWARE;",
          "1116:   }",
          "",
          "[Added Lines]",
          "1109:   dev->features  |= NETIF_F_GSO_SOFTWARE;",
          "1110:   dev->hw_features |= NETIF_F_GSO_SOFTWARE;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "7b74e912785a11572da43292786ed07ada7e3e0c",
      "candidate_info": {
        "commit_hash": "7b74e912785a11572da43292786ed07ada7e3e0c",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/7b74e912785a11572da43292786ed07ada7e3e0c",
        "files": [
          "block/genhd.c",
          "block/partition-generic.c"
        ],
        "message": "block: fix ext_devt_idr handling\n\nWhile adding and removing a lot of disks disks and partitions this\nsometimes shows up:\n\n  WARNING: at fs/sysfs/dir.c:512 sysfs_add_one+0xc9/0x130() (Not tainted)\n  Hardware name:\n  sysfs: cannot create duplicate filename '/dev/block/259:751'\n  Modules linked in: raid1 autofs4 bnx2fc cnic uio fcoe libfcoe libfc 8021q scsi_transport_fc scsi_tgt garp stp llc sunrpc cpufreq_ondemand powernow_k8 freq_table mperf ipv6 dm_mirror dm_region_hash dm_log power_meter microcode dcdbas serio_raw amd64_edac_mod edac_core edac_mce_amd i2c_piix4 i2c_core k10temp bnx2 sg ixgbe dca mdio ext4 mbcache jbd2 dm_round_robin sr_mod cdrom sd_mod crc_t10dif ata_generic pata_acpi pata_atiixp ahci mptsas mptscsih mptbase scsi_transport_sas dm_multipath dm_mod [last unloaded: scsi_wait_scan]\n  Pid: 44103, comm: async/16 Not tainted 2.6.32-195.el6.x86_64 #1\n  Call Trace:\n    warn_slowpath_common+0x87/0xc0\n    warn_slowpath_fmt+0x46/0x50\n    sysfs_add_one+0xc9/0x130\n    sysfs_do_create_link+0x12b/0x170\n    sysfs_create_link+0x13/0x20\n    device_add+0x317/0x650\n    idr_get_new+0x13/0x50\n    add_partition+0x21c/0x390\n    rescan_partitions+0x32b/0x470\n    sd_open+0x81/0x1f0 [sd_mod]\n    __blkdev_get+0x1b6/0x3c0\n    blkdev_get+0x10/0x20\n    register_disk+0x155/0x170\n    add_disk+0xa6/0x160\n    sd_probe_async+0x13b/0x210 [sd_mod]\n    add_wait_queue+0x46/0x60\n    async_thread+0x102/0x250\n    default_wake_function+0x0/0x20\n    async_thread+0x0/0x250\n    kthread+0x96/0xa0\n    child_rip+0xa/0x20\n    kthread+0x0/0xa0\n    child_rip+0x0/0x20\n\nThis most likely happens because dev_t is freed while the number is\nstill used and idr_get_new() is not protected on every use.  The fix\nadds a mutex where it wasn't before and moves the dev_t free function so\nit is called after device del.\n\nSigned-off-by: Tomas Henzl <thenzl@redhat.com>\nCc: Jens Axboe <axboe@kernel.dk>\nCc: <stable@vger.kernel.org>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
        "before_after_code_files": [
          "block/genhd.c||block/genhd.c",
          "block/partition-generic.c||block/partition-generic.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "block/genhd.c||block/genhd.c": [
          "File: block/genhd.c -> block/genhd.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "423:  do {",
          "424:   if (!idr_pre_get(&ext_devt_idr, GFP_KERNEL))",
          "425:    return -ENOMEM;",
          "426:   rc = idr_get_new(&ext_devt_idr, part, &idx);",
          "427:  } while (rc == -EAGAIN);",
          "429:  if (rc)",
          "430:   return rc;",
          "432:  if (idx > MAX_EXT_DEVT) {",
          "433:   idr_remove(&ext_devt_idr, idx);",
          "434:   return -EBUSY;",
          "435:  }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "426:   mutex_lock(&ext_devt_mutex);",
          "428:   mutex_unlock(&ext_devt_mutex);",
          "435:   mutex_lock(&ext_devt_mutex);",
          "437:   mutex_unlock(&ext_devt_mutex);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "655:  disk_part_iter_exit(&piter);",
          "657:  invalidate_partition(disk, 0);",
          "659:  set_capacity(disk, 0);",
          "660:  disk->flags &= ~GENHD_FL_UP;",
          "",
          "[Removed Lines]",
          "658:  blk_free_devt(disk_to_dev(disk)->devt);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "674:   sysfs_remove_link(block_depr, dev_name(disk_to_dev(disk)));",
          "675:  pm_runtime_set_memalloc_noio(disk_to_dev(disk), false);",
          "676:  device_del(disk_to_dev(disk));",
          "677: }",
          "678: EXPORT_SYMBOL(del_gendisk);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "680:  blk_free_devt(disk_to_dev(disk)->devt);",
          "",
          "---------------"
        ],
        "block/partition-generic.c||block/partition-generic.c": [
          "File: block/partition-generic.c -> block/partition-generic.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "249:  if (!part)",
          "250:   return;",
          "253:  rcu_assign_pointer(ptbl->part[partno], NULL);",
          "254:  rcu_assign_pointer(ptbl->last_lookup, NULL);",
          "255:  kobject_put(part->holder_dir);",
          "256:  device_del(part_to_dev(part));",
          "258:  hd_struct_put(part);",
          "259: }",
          "",
          "[Removed Lines]",
          "252:  blk_free_devt(part_devt(part));",
          "",
          "[Added Lines]",
          "256:  blk_free_devt(part_devt(part));",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "ce2ac52105aa663056dfc17966ebed1bf93e6e64",
      "candidate_info": {
        "commit_hash": "ce2ac52105aa663056dfc17966ebed1bf93e6e64",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/ce2ac52105aa663056dfc17966ebed1bf93e6e64",
        "files": [
          "fs/cifs/cifsfs.c"
        ],
        "message": "cifs: ensure that cifs_get_root() only traverses directories\n\nKjell Braden reported this oops:\n\n[  833.211970] BUG: unable to handle kernel NULL pointer dereference at           (null)\n[  833.212816] IP: [<          (null)>]           (null)\n[  833.213280] PGD 1b9b2067 PUD e9f7067 PMD 0\n[  833.213874] Oops: 0010 [#1] SMP\n[  833.214344] CPU 0\n[  833.214458] Modules linked in: des_generic md4 nls_utf8 cifs vboxvideo drm snd_intel8x0 snd_ac97_codec ac97_bus snd_pcm snd_seq_midi snd_rawmidi snd_seq_midi_event snd_seq bnep rfcomm snd_timer bluetooth snd_seq_device ppdev snd vboxguest parport_pc joydev mac_hid soundcore snd_page_alloc psmouse i2c_piix4 serio_raw lp parport usbhid hid e1000\n[  833.215629]\n[  833.215629] Pid: 1752, comm: mount.cifs Not tainted 3.0.0-rc7-bisectcifs-fec11dd9a0+ #18 innotek GmbH VirtualBox/VirtualBox\n[  833.215629] RIP: 0010:[<0000000000000000>]  [<          (null)>]           (null)\n[  833.215629] RSP: 0018:ffff8800119c9c50  EFLAGS: 00010282\n[  833.215629] RAX: ffffffffa02186c0 RBX: ffff88000c427780 RCX: 0000000000000000\n[  833.215629] RDX: 0000000000000000 RSI: ffff88000c427780 RDI: ffff88000c4362e8\n[  833.215629] RBP: ffff8800119c9c88 R08: ffff88001fc15e30 R09: 00000000d69515c7\n[  833.215629] R10: ffffffffa0201972 R11: ffff88000e8f6a28 R12: ffff88000c4362e8\n[  833.215629] R13: 0000000000000000 R14: 0000000000000000 R15: ffff88001181aaa6\n[  833.215629] FS:  00007f2986171700(0000) GS:ffff88001fc00000(0000) knlGS:0000000000000000\n[  833.215629] CS:  0010 DS: 0000 ES: 0000 CR0: 000000008005003b\n[  833.215629] CR2: 0000000000000000 CR3: 000000001b982000 CR4: 00000000000006f0\n[  833.215629] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\n[  833.215629] DR3: 0000000000000000 DR6: 00000000ffff0ff0 DR7: 0000000000000400\n[  833.215629] Process mount.cifs (pid: 1752, threadinfo ffff8800119c8000, task ffff88001c1c16f0)\n[  833.215629] Stack:\n[  833.215629]  ffffffff8116a9b5 ffff8800119c9c88 ffffffff81178075 0000000000000286\n[  833.215629]  0000000000000000 ffff88000c4276c0 ffff8800119c9ce8 ffff8800119c9cc8\n[  833.215629]  ffffffff8116b06e ffff88001bc6fc00 ffff88000c4276c0 ffff88000c4276c0\n[  833.215629] Call Trace:\n[  833.215629]  [<ffffffff8116a9b5>] ? d_alloc_and_lookup+0x45/0x90\n[  833.215629]  [<ffffffff81178075>] ? d_lookup+0x35/0x60\n[  833.215629]  [<ffffffff8116b06e>] __lookup_hash.part.14+0x9e/0xc0\n[  833.215629]  [<ffffffff8116b1d6>] lookup_one_len+0x146/0x1e0\n[  833.215629]  [<ffffffff815e4f7e>] ? _raw_spin_lock+0xe/0x20\n[  833.215629]  [<ffffffffa01eef0d>] cifs_do_mount+0x26d/0x500 [cifs]\n[  833.215629]  [<ffffffff81163bd3>] mount_fs+0x43/0x1b0\n[  833.215629]  [<ffffffff8117d41a>] vfs_kern_mount+0x6a/0xd0\n[  833.215629]  [<ffffffff8117e584>] do_kern_mount+0x54/0x110\n[  833.215629]  [<ffffffff8117fdc2>] do_mount+0x262/0x840\n[  833.215629]  [<ffffffff81108a0e>] ? __get_free_pages+0xe/0x50\n[  833.215629]  [<ffffffff8117f9ca>] ? copy_mount_options+0x3a/0x180\n[  833.215629]  [<ffffffff8118075d>] sys_mount+0x8d/0xe0\n[  833.215629]  [<ffffffff815ece82>] system_call_fastpath+0x16/0x1b\n[  833.215629] Code:  Bad RIP value.\n[  833.215629] RIP  [<          (null)>]           (null)\n[  833.215629]  RSP <ffff8800119c9c50>\n[  833.215629] CR2: 0000000000000000\n[  833.238525] ---[ end trace ec00758b8d44f529 ]---\n\nWhen walking down the path on the server, it's possible to hit a\nsymlink. The path walking code assumes that the caller will handle that\nsituation properly, but cifs_get_root() isn't set up for it. This patch\nprevents the oops by simply returning an error.\n\nA better solution would be to try and chase the symlinks here, but that's\nfairly complicated to handle.\n\nFixes:\n\n    https://bugzilla.kernel.org/show_bug.cgi?id=53221\n\nReported-and-tested-by: Kjell Braden <afflux@pentabarf.de>\nCc: stable <stable@vger.kernel.org>\nSigned-off-by: Jeff Layton <jlayton@redhat.com>\nSigned-off-by: Steve French <sfrench@us.ibm.com>",
        "before_after_code_files": [
          "fs/cifs/cifsfs.c||fs/cifs/cifsfs.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "fs/cifs/cifsfs.c||fs/cifs/cifsfs.c": [
          "File: fs/cifs/cifsfs.c -> fs/cifs/cifsfs.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "564:    dentry = ERR_PTR(-ENOENT);",
          "565:    break;",
          "566:   }",
          "569:   while (*s == sep)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "567:   if (!S_ISDIR(dir->i_mode)) {",
          "568:    dput(dentry);",
          "569:    dentry = ERR_PTR(-ENOTDIR);",
          "570:    break;",
          "571:   }",
          "",
          "---------------"
        ]
      }
    }
  ]
}
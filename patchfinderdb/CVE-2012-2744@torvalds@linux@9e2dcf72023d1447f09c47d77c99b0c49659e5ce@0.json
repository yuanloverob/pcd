{
  "cve_id": "CVE-2012-2744",
  "cve_desc": "net/ipv6/netfilter/nf_conntrack_reasm.c in the Linux kernel before 2.6.34, when the nf_conntrack_ipv6 module is enabled, allows remote attackers to cause a denial of service (NULL pointer dereference and system crash) via certain types of fragmented IPv6 packets.",
  "repo": "torvalds/linux",
  "patch_hash": "9e2dcf72023d1447f09c47d77c99b0c49659e5ce",
  "patch_info": {
    "commit_hash": "9e2dcf72023d1447f09c47d77c99b0c49659e5ce",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/9e2dcf72023d1447f09c47d77c99b0c49659e5ce",
    "files": [
      "net/ipv6/netfilter/nf_conntrack_reasm.c"
    ],
    "message": "netfilter: nf_conntrack_reasm: properly handle packets fragmented into a single fragment\n\nWhen an ICMPV6_PKT_TOOBIG message is received with a MTU below 1280,\nall further packets include a fragment header.\n\nUnlike regular defragmentation, conntrack also needs to \"reassemble\"\nthose fragments in order to obtain a packet without the fragment\nheader for connection tracking. Currently nf_conntrack_reasm checks\nwhether a fragment has either IP6_MF set or an offset != 0, which\nmakes it ignore those fragments.\n\nRemove the invalid check and make reassembly handle fragment queues\ncontaining only a single fragment.\n\nReported-and-tested-by: Ulrich Weber <uweber@astaro.com>\nSigned-off-by: Patrick McHardy <kaber@trash.net>",
    "before_after_code_files": [
      "net/ipv6/netfilter/nf_conntrack_reasm.c||net/ipv6/netfilter/nf_conntrack_reasm.c"
    ]
  },
  "patch_diff": {
    "net/ipv6/netfilter/nf_conntrack_reasm.c||net/ipv6/netfilter/nf_conntrack_reasm.c": [
      "File: net/ipv6/netfilter/nf_conntrack_reasm.c -> net/ipv6/netfilter/nf_conntrack_reasm.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "471:  fp = skb_shinfo(head)->frag_list;",
      "474:   fp = fp->next;",
      "",
      "[Removed Lines]",
      "472:  if (NFCT_FRAG6_CB(fp)->orig == NULL)",
      "",
      "[Added Lines]",
      "472:  if (fp && NFCT_FRAG6_CB(fp)->orig == NULL)",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "595:  hdr = ipv6_hdr(clone);",
      "596:  fhdr = (struct frag_hdr *)skb_transport_header(clone);",
      "604:  if (atomic_read(&nf_init_frags.mem) > nf_init_frags.high_thresh)",
      "605:   nf_ct_frag6_evictor();",
      "",
      "[Removed Lines]",
      "598:  if (!(fhdr->frag_off & htons(0xFFF9))) {",
      "599:   pr_debug(\"Invalid fragment offset\\n\");",
      "601:   goto ret_orig;",
      "602:  }",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "0b5ccb2ee250136dd7385b1c7da28417d0d4d32d",
      "candidate_info": {
        "commit_hash": "0b5ccb2ee250136dd7385b1c7da28417d0d4d32d",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/0b5ccb2ee250136dd7385b1c7da28417d0d4d32d",
        "files": [
          "include/net/ipv6.h",
          "include/net/netfilter/ipv6/nf_conntrack_ipv6.h",
          "net/ipv6/netfilter/nf_conntrack_l3proto_ipv6.c",
          "net/ipv6/netfilter/nf_conntrack_reasm.c",
          "net/ipv6/reassembly.c"
        ],
        "message": "ipv6: reassembly: use seperate reassembly queues for conntrack and local delivery\n\nCurrently the same reassembly queue might be used for packets reassembled\nby conntrack in different positions in the stack (PREROUTING/LOCAL_OUT),\nas well as local delivery. This can cause \"packet jumps\" when the fragment\ncompleting a reassembled packet is queued from a different position in the\nstack than the previous ones.\n\nAdd a \"user\" identifier to the reassembly queue key to seperate the queues\nof each caller, similar to what we do for IPv4.\n\nSigned-off-by: Patrick McHardy <kaber@trash.net>",
        "before_after_code_files": [
          "include/net/ipv6.h||include/net/ipv6.h",
          "include/net/netfilter/ipv6/nf_conntrack_ipv6.h||include/net/netfilter/ipv6/nf_conntrack_ipv6.h",
          "net/ipv6/netfilter/nf_conntrack_l3proto_ipv6.c||net/ipv6/netfilter/nf_conntrack_l3proto_ipv6.c",
          "net/ipv6/netfilter/nf_conntrack_reasm.c||net/ipv6/netfilter/nf_conntrack_reasm.c",
          "net/ipv6/reassembly.c||net/ipv6/reassembly.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "net/ipv6/netfilter/nf_conntrack_reasm.c||net/ipv6/netfilter/nf_conntrack_reasm.c"
          ],
          "candidate": [
            "net/ipv6/netfilter/nf_conntrack_reasm.c||net/ipv6/netfilter/nf_conntrack_reasm.c"
          ]
        }
      },
      "candidate_diff": {
        "include/net/ipv6.h||include/net/ipv6.h": [
          "File: include/net/ipv6.h -> include/net/ipv6.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "351: struct inet_frag_queue;",
          "353: struct ip6_create_arg {",
          "354:  __be32 id;",
          "355:  struct in6_addr *src;",
          "356:  struct in6_addr *dst;",
          "357: };",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "353: enum ip6_defrag_users {",
          "354:  IP6_DEFRAG_LOCAL_DELIVER,",
          "355:  IP6_DEFRAG_CONNTRACK_IN,",
          "356:  IP6_DEFRAG_CONNTRACK_OUT,",
          "357: };",
          "361:  u32 user;",
          "",
          "---------------"
        ],
        "include/net/netfilter/ipv6/nf_conntrack_ipv6.h||include/net/netfilter/ipv6/nf_conntrack_ipv6.h": [
          "File: include/net/netfilter/ipv6/nf_conntrack_ipv6.h -> include/net/netfilter/ipv6/nf_conntrack_ipv6.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "10: extern int nf_ct_frag6_init(void);",
          "11: extern void nf_ct_frag6_cleanup(void);",
          "13: extern void nf_ct_frag6_output(unsigned int hooknum, struct sk_buff *skb,",
          "14:           struct net_device *in,",
          "15:           struct net_device *out,",
          "",
          "[Removed Lines]",
          "12: extern struct sk_buff *nf_ct_frag6_gather(struct sk_buff *skb);",
          "",
          "[Added Lines]",
          "12: extern struct sk_buff *nf_ct_frag6_gather(struct sk_buff *skb, u32 user);",
          "",
          "---------------"
        ],
        "net/ipv6/netfilter/nf_conntrack_l3proto_ipv6.c||net/ipv6/netfilter/nf_conntrack_l3proto_ipv6.c": [
          "File: net/ipv6/netfilter/nf_conntrack_l3proto_ipv6.c -> net/ipv6/netfilter/nf_conntrack_l3proto_ipv6.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "187:  return nf_conntrack_confirm(skb);",
          "188: }",
          "190: static unsigned int ipv6_defrag(unsigned int hooknum,",
          "191:     struct sk_buff *skb,",
          "192:     const struct net_device *in,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "190: static enum ip6_defrag_users nf_ct6_defrag_user(unsigned int hooknum,",
          "191:       struct sk_buff *skb)",
          "192: {",
          "193:  if (hooknum == NF_INET_PRE_ROUTING)",
          "194:   return IP6_DEFRAG_CONNTRACK_IN;",
          "195:  else",
          "196:   return IP6_DEFRAG_CONNTRACK_OUT;",
          "198: }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "199:  if (skb->nfct)",
          "200:   return NF_ACCEPT;",
          "205:  if (reasm == NULL)",
          "206:   return NF_STOLEN;",
          "",
          "[Removed Lines]",
          "202:  reasm = nf_ct_frag6_gather(skb);",
          "",
          "[Added Lines]",
          "212:  reasm = nf_ct_frag6_gather(skb, nf_ct6_defrag_user(hooknum, skb));",
          "",
          "---------------"
        ],
        "net/ipv6/netfilter/nf_conntrack_reasm.c||net/ipv6/netfilter/nf_conntrack_reasm.c": [
          "File: net/ipv6/netfilter/nf_conntrack_reasm.c -> net/ipv6/netfilter/nf_conntrack_reasm.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "170: static __inline__ struct nf_ct_frag6_queue *",
          "172: {",
          "173:  struct inet_frag_queue *q;",
          "174:  struct ip6_create_arg arg;",
          "175:  unsigned int hash;",
          "177:  arg.id = id;",
          "178:  arg.src = src;",
          "179:  arg.dst = dst;",
          "",
          "[Removed Lines]",
          "171: fq_find(__be32 id, struct in6_addr *src, struct in6_addr *dst)",
          "",
          "[Added Lines]",
          "171: fq_find(__be32 id, u32 user, struct in6_addr *src, struct in6_addr *dst)",
          "178:  arg.user = user;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "559:  return 0;",
          "560: }",
          "563: {",
          "564:  struct sk_buff *clone;",
          "565:  struct net_device *dev = skb->dev;",
          "",
          "[Removed Lines]",
          "562: struct sk_buff *nf_ct_frag6_gather(struct sk_buff *skb)",
          "",
          "[Added Lines]",
          "563: struct sk_buff *nf_ct_frag6_gather(struct sk_buff *skb, u32 user)",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "605:  if (atomic_read(&nf_init_frags.mem) > nf_init_frags.high_thresh)",
          "606:   nf_ct_frag6_evictor();",
          "609:  if (fq == NULL) {",
          "610:   pr_debug(\"Can't find and can't create new queue\\n\");",
          "611:   goto ret_orig;",
          "",
          "[Removed Lines]",
          "608:  fq = fq_find(fhdr->identification, &hdr->saddr, &hdr->daddr);",
          "",
          "[Added Lines]",
          "609:  fq = fq_find(fhdr->identification, user, &hdr->saddr, &hdr->daddr);",
          "",
          "---------------"
        ],
        "net/ipv6/reassembly.c||net/ipv6/reassembly.c": [
          "File: net/ipv6/reassembly.c -> net/ipv6/reassembly.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "72:  struct inet_frag_queue q;",
          "75:  struct in6_addr  saddr;",
          "76:  struct in6_addr  daddr;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "75:  u32   user;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "141:  struct ip6_create_arg *arg = a;",
          "143:  fq = container_of(q, struct frag_queue, q);",
          "145:    ipv6_addr_equal(&fq->saddr, arg->src) &&",
          "146:    ipv6_addr_equal(&fq->daddr, arg->dst));",
          "147: }",
          "",
          "[Removed Lines]",
          "144:  return (fq->id == arg->id &&",
          "",
          "[Added Lines]",
          "145:  return (fq->id == arg->id && fq->user == arg->user &&",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "163:  struct ip6_create_arg *arg = a;",
          "165:  fq->id = arg->id;",
          "166:  ipv6_addr_copy(&fq->saddr, arg->src);",
          "167:  ipv6_addr_copy(&fq->daddr, arg->dst);",
          "168: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "167:  fq->user = arg->user;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "243:  unsigned int hash;",
          "245:  arg.id = id;",
          "246:  arg.src = src;",
          "247:  arg.dst = dst;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "248:  arg.user = IP6_DEFRAG_LOCAL_DELIVER;",
          "",
          "---------------"
        ]
      }
    }
  ]
}
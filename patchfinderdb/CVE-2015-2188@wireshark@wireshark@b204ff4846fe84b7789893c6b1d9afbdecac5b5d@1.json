{
  "cve_id": "CVE-2015-2188",
  "cve_desc": "epan/dissectors/packet-wcp.c in the WCP dissector in Wireshark 1.10.x before 1.10.13 and 1.12.x before 1.12.4 does not properly initialize a data structure, which allows remote attackers to cause a denial of service (out-of-bounds read and application crash) via a crafted packet that is improperly handled during decompression.",
  "repo": "wireshark/wireshark",
  "patch_hash": "b204ff4846fe84b7789893c6b1d9afbdecac5b5d",
  "patch_info": {
    "commit_hash": "b204ff4846fe84b7789893c6b1d9afbdecac5b5d",
    "repo": "wireshark/wireshark",
    "commit_url": "https://github.com/wireshark/wireshark/commit/b204ff4846fe84b7789893c6b1d9afbdecac5b5d",
    "files": [
      "epan/dissectors/packet-wcp.c"
    ],
    "message": "Do bounds checking when decompressing WCP packets.\n\nExtract the data offset and count only once, and make sure we don't run\npast the end of the data we've copied from the packet; have\ndecompressed_entry() just do the decompression, rather than also\nfetching the data offset and count.\n\nAdd some comments while we're at it.\n\nBug: 10844\nChange-Id: I2dc2f9594422ffa8f15fd5c57c9dac2e30e363f4\nReviewed-on: https://code.wireshark.org/review/6514\nReviewed-by: Guy Harris <guy@alum.mit.edu>",
    "before_after_code_files": [
      "epan/dissectors/packet-wcp.c||epan/dissectors/packet-wcp.c"
    ]
  },
  "patch_diff": {
    "epan/dissectors/packet-wcp.c||epan/dissectors/packet-wcp.c": [
      "File: epan/dissectors/packet-wcp.c -> epan/dissectors/packet-wcp.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "104: #include <epan/etypes.h>",
      "105: #include <epan/nlpid.h>",
      "106: #include <epan/expert.h>",
      "112: void proto_register_wcp(void);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "107: #include <epan/exceptions.h>",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "393: }",
      "416:  src = (dst - 1 - data_offset);",
      "417:  if ( src < buf_start)",
      "418:   src += MAX_WIN_BUF_LEN;",
      "",
      "[Removed Lines]",
      "396: static guint8 *decompressed_entry( guint8 *src, guint8 *dst, int *len, guint8 * buf_start, guint8 *buf_end){",
      "400:  guint16 data_offset, data_cnt;",
      "401:  guint8 tmp = *src;",
      "407:   data_cnt = *src;",
      "408:   data_cnt++;",
      "411:   data_cnt = tmp >> 4;",
      "412:   data_cnt++;",
      "413:  }",
      "",
      "[Added Lines]",
      "397: static guint8 *",
      "398: decompressed_entry(guint8 *dst, guint16 data_offset,",
      "399:     guint16 data_cnt, int *len, guint8 * buf_start, guint8 *buf_end)",
      "400: {",
      "401:  const guint8 *src;",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "478:  guint8 *dst, *src, *buf_start, *buf_end, comp_flag_bits = 0;",
      "479:  guint8 src_buf[ MAX_WCP_BUF_LEN];",
      "480:  tvbuff_t *tvb;",
      "481:  wcp_window_t *buf_ptr = 0;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "468:  guint16 data_offset, data_cnt;",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "496:   return NULL;",
      "497:  }",
      "499:  src = (guint8 *)tvb_memcpy(src_tvb, src_buf, offset, cnt - offset);",
      "500:  dst = buf_ptr->buf_cur;",
      "501:  len = 0;",
      "502:  i = -1;",
      "504:  while( offset < cnt){",
      "506:   if ( --i >= 0){",
      "517:     }",
      "518:     if ((*src & 0xf0) == 0x10){",
      "519:      if ( tree) {",
      "520:       ti = proto_tree_add_item( cd_tree, hf_wcp_long_run, src_tvb,",
      "521:         offset, 3, ENC_NA);",
      "522:       sub_tree = proto_item_add_subtree(ti, ett_wcp_field);",
      "523:       proto_tree_add_uint(sub_tree, hf_wcp_offset, src_tvb,",
      "526:       proto_tree_add_item( sub_tree, hf_wcp_long_len, src_tvb,",
      "527:         offset+2, 1, ENC_BIG_ENDIAN);",
      "",
      "[Removed Lines]",
      "510:      dst = decompressed_entry( src, dst, &len, buf_start, buf_end);",
      "511:      if (dst == NULL){",
      "512:       expert_add_info_format(pinfo, cd_item, &ei_wcp_uncompressed_data_exceeds,",
      "513:        \"Uncompressed data exceeds maximum buffer length (%d > %d)\",",
      "514:        len, MAX_WCP_BUF_LEN);",
      "515:       return NULL;",
      "516:      }",
      "524:         offset, 2, pntoh16(src));",
      "",
      "[Added Lines]",
      "509:    if ( comp_flag_bits & 0x80){",
      "511:     if (!(offset + 1 < cnt)) {",
      "516:      THROW(ReportedBoundsError);",
      "518:     data_offset = pntoh16(src) & WCP_OFFSET_MASK;",
      "525:      if (!(offset + 2 < cnt)) {",
      "530:       THROW(ReportedBoundsError);",
      "531:      }",
      "532:      data_cnt = *(src + 2) + 1;",
      "538:         offset, 2, data_offset);",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "529:      src += 3;",
      "530:      offset += 3;",
      "531:     }else{",
      "532:      if ( tree) {",
      "533:       ti = proto_tree_add_item( cd_tree, hf_wcp_short_run, src_tvb,",
      "534:         offset, 2, ENC_NA);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "552:      data_cnt = (*src >> 4) + 1;",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "536:       proto_tree_add_uint( sub_tree, hf_wcp_short_len, src_tvb,",
      "537:         offset, 1, *src);",
      "538:       proto_tree_add_uint(sub_tree, hf_wcp_offset, src_tvb,",
      "540:      }",
      "541:      src += 2;",
      "542:      offset += 2;",
      "543:     }",
      "544:    }else {",
      "545:     if ( ++len >MAX_WCP_BUF_LEN){",
      "546:      expert_add_info_format(pinfo, cd_item, &ei_wcp_uncompressed_data_exceeds,",
      "547:       \"Uncompressed data exceeds maximum buffer length (%d > %d)\",",
      "548:       len, MAX_WCP_BUF_LEN);",
      "549:      return NULL;",
      "550:     }",
      "554:      if ( dst++ == buf_end)",
      "555:       dst = buf_start;",
      "",
      "[Removed Lines]",
      "539:         offset, 2, pntoh16(src));",
      "",
      "[Added Lines]",
      "560:         offset, 2, data_offset);",
      "566:      dst = decompressed_entry(dst,",
      "567:          data_offset, data_cnt, &len,",
      "568:          buf_start, buf_end);",
      "569:      if (dst == NULL){",
      "570:       expert_add_info_format(pinfo, cd_item, &ei_wcp_uncompressed_data_exceeds,",
      "571:        \"Uncompressed data exceeds maximum buffer length (%d > %d)\",",
      "572:        len, MAX_WCP_BUF_LEN);",
      "573:       return NULL;",
      "574:      }",
      "575:     }",
      "590:     if ( !pinfo->fd->flags.visited){",
      "",
      "---------------",
      "--- Hunk 7 ---",
      "[Context before]",
      "558:     ++offset;",
      "559:    }",
      "561:    comp_flag_bits <<= 1;",
      "565:    comp_flag_bits = *src++;",
      "566:    if (cd_tree)",
      "567:     proto_tree_add_uint(cd_tree, hf_wcp_comp_bits,  src_tvb, offset, 1,",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "607:   }else {",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "abebbb99519cbf920ea4c495741ed9c7b5774def",
      "candidate_info": {
        "commit_hash": "abebbb99519cbf920ea4c495741ed9c7b5774def",
        "repo": "wireshark/wireshark",
        "commit_url": "https://github.com/wireshark/wireshark/commit/abebbb99519cbf920ea4c495741ed9c7b5774def",
        "files": [
          "epan/dissectors/packet-wcp.c"
        ],
        "message": "Do bounds checking when decompressing WCP packets.\n\nExtract the data offset and count only once, and make sure we don't run\npast the end of the data we've copied from the packet; have\ndecompressed_entry() just do the decompression, rather than also\nfetching the data offset and count.\n\nAdd some comments while we're at it.\n\nBug: 10844\nChange-Id: I6cd720461603e9ad9ec61d2f615ce892a491617c\nReviewed-on: https://code.wireshark.org/review/6516\nReviewed-by: Guy Harris <guy@alum.mit.edu>",
        "before_after_code_files": [
          "epan/dissectors/packet-wcp.c||epan/dissectors/packet-wcp.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_message": 1,
        "olp_code_files": {
          "patch": [
            "epan/dissectors/packet-wcp.c||epan/dissectors/packet-wcp.c"
          ],
          "candidate": [
            "epan/dissectors/packet-wcp.c||epan/dissectors/packet-wcp.c"
          ]
        }
      },
      "candidate_diff": {
        "epan/dissectors/packet-wcp.c||epan/dissectors/packet-wcp.c": [
          "File: epan/dissectors/packet-wcp.c -> epan/dissectors/packet-wcp.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "392: }",
          "415:  src = (dst - 1 - data_offset);",
          "416:  if ( src < buf_start)",
          "417:   src += MAX_WIN_BUF_LEN;",
          "",
          "[Removed Lines]",
          "395: static guint8 *decompressed_entry( guint8 *src, guint8 *dst, int *len, guint8 * buf_start, guint8 *buf_end){",
          "399:  guint16 data_offset, data_cnt;",
          "400:  guint8 tmp = *src;",
          "406:   data_cnt = *src;",
          "407:   data_cnt++;",
          "410:   data_cnt = tmp >> 4;",
          "411:   data_cnt++;",
          "412:  }",
          "",
          "[Added Lines]",
          "395: static guint8 *",
          "396: decompressed_entry(guint8 *dst, guint16 data_offset,",
          "397:     guint16 data_cnt, int *len, guint8 * buf_start, guint8 *buf_end)",
          "398: {",
          "399:  const guint8 *src;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "477:  guint8 *dst, *src, *buf_start, *buf_end, comp_flag_bits = 0;",
          "478:  guint8 src_buf[ MAX_WCP_BUF_LEN];",
          "479:  tvbuff_t *tvb;",
          "480:  wcp_window_t *buf_ptr = 0;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "466:  guint16 data_offset, data_cnt;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "495:   return NULL;",
          "496:  }",
          "498:  src = (guint8 *)tvb_memcpy(src_tvb, src_buf, offset, cnt - offset);",
          "499:  dst = buf_ptr->buf_cur;",
          "500:  len = 0;",
          "501:  i = -1;",
          "503:  while( offset < cnt){",
          "505:   if ( --i >= 0){",
          "516:     }",
          "517:     if ((*src & 0xf0) == 0x10){",
          "518:      if ( tree) {",
          "519:       ti = proto_tree_add_item( cd_tree, hf_wcp_long_run, src_tvb,",
          "520:         offset, 3, ENC_NA);",
          "521:       sub_tree = proto_item_add_subtree(ti, ett_wcp_field);",
          "522:       proto_tree_add_uint(sub_tree, hf_wcp_offset, src_tvb,",
          "525:       proto_tree_add_item( sub_tree, hf_wcp_long_len, src_tvb,",
          "526:         offset+2, 1, ENC_BIG_ENDIAN);",
          "",
          "[Removed Lines]",
          "509:      dst = decompressed_entry( src, dst, &len, buf_start, buf_end);",
          "510:      if (dst == NULL){",
          "511:       expert_add_info_format(pinfo, cd_item, PI_MALFORMED, PI_ERROR,",
          "512:        \"Uncompressed data exceeds maximum buffer length (%d > %d)\",",
          "513:        len, MAX_WCP_BUF_LEN);",
          "514:       return NULL;",
          "515:      }",
          "523:         offset, 2, pntohs(src));",
          "",
          "[Added Lines]",
          "507:    if ( comp_flag_bits & 0x80){",
          "509:     if (!(offset + 1 < cnt)) {",
          "514:      THROW(ReportedBoundsError);",
          "516:     data_offset = pntoh16(src) & WCP_OFFSET_MASK;",
          "523:      if (!(offset + 2 < cnt)) {",
          "528:       THROW(ReportedBoundsError);",
          "529:      }",
          "530:      data_cnt = *(src + 2) + 1;",
          "536:         offset, 2, data_offset);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "528:      src += 3;",
          "529:      offset += 3;",
          "530:     }else{",
          "531:      if ( tree) {",
          "532:       ti = proto_tree_add_item( cd_tree, hf_wcp_short_run, src_tvb,",
          "533:         offset, 2, ENC_NA);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "550:      data_cnt = (*src >> 4) + 1;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "535:       proto_tree_add_uint( sub_tree, hf_wcp_short_len, src_tvb,",
          "536:         offset, 1, *src);",
          "537:       proto_tree_add_uint(sub_tree, hf_wcp_offset, src_tvb,",
          "539:      }",
          "540:      src += 2;",
          "541:      offset += 2;",
          "542:     }",
          "543:    }else {",
          "544:     if ( ++len >MAX_WCP_BUF_LEN){",
          "545:      expert_add_info_format(pinfo, cd_item, PI_MALFORMED, PI_ERROR,",
          "546:       \"Uncompressed data exceeds maximum buffer length (%d > %d)\",",
          "547:       len, MAX_WCP_BUF_LEN);",
          "548:      return NULL;",
          "549:     }",
          "553:      if ( dst++ == buf_end)",
          "554:       dst = buf_start;",
          "",
          "[Removed Lines]",
          "538:         offset, 2, pntohs(src));",
          "",
          "[Added Lines]",
          "558:         offset, 2, data_offset);",
          "564:      dst = decompressed_entry(dst,",
          "565:          data_offset, data_cnt, &len,",
          "566:          buf_start, buf_end);",
          "567:      if (dst == NULL){",
          "568:       expert_add_info_format(pinfo, cd_item, PI_MALFORMED, PI_ERROR,",
          "569:        \"Uncompressed data exceeds maximum buffer length (%d > %d)\",",
          "570:        len, MAX_WCP_BUF_LEN);",
          "571:       return NULL;",
          "572:      }",
          "573:     }",
          "588:     if ( !pinfo->fd->flags.visited){",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "557:     ++offset;",
          "558:    }",
          "560:    comp_flag_bits <<= 1;",
          "564:    comp_flag_bits = *src++;",
          "565:    if (cd_tree)",
          "566:     proto_tree_add_uint(cd_tree, hf_wcp_comp_bits,  src_tvb, offset, 1,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "605:   }else {",
          "",
          "---------------"
        ]
      }
    }
  ]
}
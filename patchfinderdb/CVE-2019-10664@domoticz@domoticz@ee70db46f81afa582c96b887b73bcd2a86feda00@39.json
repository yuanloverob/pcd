{
  "cve_id": "CVE-2019-10664",
  "cve_desc": "Domoticz before 4.10578 allows SQL Injection via the idx parameter in CWebServer::GetFloorplanImage in WebServer.cpp.",
  "repo": "domoticz/domoticz",
  "patch_hash": "ee70db46f81afa582c96b887b73bcd2a86feda00",
  "patch_info": {
    "commit_hash": "ee70db46f81afa582c96b887b73bcd2a86feda00",
    "repo": "domoticz/domoticz",
    "commit_url": "https://github.com/domoticz/domoticz/commit/ee70db46f81afa582c96b887b73bcd2a86feda00",
    "files": [
      "main/WebServer.cpp"
    ],
    "message": "Fixed possible SQL Injection Vulnerability (Thanks to Fabio Carretto!)",
    "before_after_code_files": [
      "main/WebServer.cpp||main/WebServer.cpp"
    ]
  },
  "patch_diff": {
    "main/WebServer.cpp||main/WebServer.cpp": [
      "File: main/WebServer.cpp -> main/WebServer.cpp",
      "--- Hunk 1 ---",
      "[Context before]",
      "10772:     return;",
      "10773:    }",
      "10774:    std::vector<std::vector<std::string> > result;",
      "10776:    if (result.empty())",
      "10777:     return;",
      "10778:    reply::set_content(&rep, result[0][0].begin(), result[0][0].end());",
      "",
      "[Removed Lines]",
      "10775:    result = m_sql.safe_queryBlob(\"SELECT Image FROM Floorplans WHERE ID=%s\", idx.c_str());",
      "",
      "[Added Lines]",
      "10775:    result = m_sql.safe_queryBlob(\"SELECT Image FROM Floorplans WHERE ID=%d\", atol(idx.c_str()));",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "d1895a2eade5b309e4cc70c7fe916b04b7e8da34",
      "candidate_info": {
        "commit_hash": "d1895a2eade5b309e4cc70c7fe916b04b7e8da34",
        "repo": "domoticz/domoticz",
        "commit_url": "https://github.com/domoticz/domoticz/commit/d1895a2eade5b309e4cc70c7fe916b04b7e8da34",
        "files": [
          "hardware/Rtl433.cpp",
          "hardware/Rtl433.h"
        ],
        "message": "RTL433, redone, added WGR800,PCR800",
        "before_after_code_files": [
          "hardware/Rtl433.cpp||hardware/Rtl433.cpp",
          "hardware/Rtl433.h||hardware/Rtl433.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/domoticz/domoticz/pull/3180"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "hardware/Rtl433.cpp||hardware/Rtl433.cpp": [
          "File: hardware/Rtl433.cpp -> hardware/Rtl433.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "27:  removeCharsFromString(m_cmdline, \":;/$()`<>|&\");",
          "28:  m_HwdID = ID;",
          "29:  m_hPipe = NULL;",
          "30: }",
          "32: CRtl433::~CRtl433()",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "31: #ifdef _DEBUG",
          "32:  std::string headerline = \"time,msg,codes,model,button,id,channel,battery,temperature_C,mic,rid,humidity,state,status,brand,rain_rate,rain_total,gust,average,direction,pressure_hPa,uv,power_W,energy_kWh,unit,group_call,command,dim,dim_value,wind_speed,wind_gust,wind_direction,dipswitch,rbutton,device,temperature_F,rc,brandmodelidtemperature_C,setpoint_C,switch,cmd,cmd_id,modelidcmd,tristate,direction_str,direction_deg,speed,rain,msg_type,signal,hours,minutes,seconds,year,month,day,sensor_code,uv_status,uv_index,lux,wm,fc,ws_id,rainfall_mm,wind_speed_ms,gust_speed_ms,current,interval,learn,sensor_id,battery_low,sequence_num,message_type,wind_speed_mph,wind_dir_deg,wind_dir,rainfall_accumulation_inch,raincounter_raw,windstrength,winddirection,flags,maybetemp,binding_countdown,depth,dev_id,power0,power1,power2,node,ct1,ct2,ct3,ct4,Vrms/batt,temp1_C,temp2_C,temp3_C,temp4_C,temp5_C,temp6_C,pulse,address,button1,button2,button3,button4,data,sid,transmit,moisture,type,pressure_PSI,battery_mV,pressure_bar,pulses,energy,device id,code,len,to,from,payload,event,heartbeat,brandmodelidstatus,temperature_C1,temperature_C2,test,probe,water,ptemperature_C,phumidity,newbattery,heating,heating_temp,uvi,light_lux,counter,alarm,depth_cm,repeat,temperature_1_C,temperature_2_C,device_type,raw_message,switch1,switch2,switch3,switch4,switch5,seq,extradata,house_id,module_id,sensor_type,sensor_count,alarms,sensor_value,battery_voltage,failed,pressure_kPa\";",
          "35:  std::vector<std::string> headers = ParseCSVLine(headerline.c_str());",
          "36:  ParseLine(headers, line.c_str());",
          "37: #endif",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "87:  return line;",
          "88: }",
          "90: void CRtl433::Do_Work()",
          "91: {",
          "92:  sleep_milliseconds(1000);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "99: bool CRtl433::FindField(const std::map<std::string, std::string> &data, const std::string &field)",
          "100: {",
          "101:  return (data.find(field) != data.end());",
          "102: }",
          "104: bool CRtl433::ParseLine(const std::vector<std::string> &headers, const char *line)",
          "105: {",
          "106:  time_t atime = time(NULL);",
          "107:  std::string slineRaw(line);",
          "108:  if (slineRaw.find(',') != std::string::npos)",
          "109:  {",
          "110:   slineRaw = slineRaw.substr(slineRaw.find(',') + 1);",
          "111:   if (slineRaw == m_sLastLine)",
          "112:   {",
          "113:    if (atime - m_time_last_received < 2)",
          "114:     return true; //skip duplicate RF frames",
          "115:   }",
          "116:   m_sLastLine = slineRaw;",
          "117:  }",
          "118:  m_time_last_received = atime;",
          "119:  std::vector<std::string> values = ParseCSVLine(line);",
          "121:  if (values.size() != headers.size())",
          "122:   return false; //should be equal",
          "125:  std::map<std::string, std::string> data;",
          "126:  std::vector<std::string>::const_iterator h = headers.begin();",
          "127:  for (std::vector<std::string>::iterator vi = values.begin(); vi != values.end(); ++vi)",
          "128:  {",
          "129:   if (!(*vi).empty())",
          "130:    data[*(h)] = *vi;",
          "131:   h++;",
          "132:  }",
          "133:  int id = 0;",
          "134:  int unit = 0;",
          "135:  bool hasunit = false;",
          "136:  int channel = 0;",
          "137:  bool haschannel = false;",
          "138:  int batterylevel = 255;",
          "139:  bool hasbattery = false;",
          "140:  float tempC;",
          "141:  bool hastempC = false;",
          "142:  int humidity;",
          "143:  bool hashumidity = false;",
          "144:  float pressure;",
          "145:  bool haspressure = false;",
          "146:  float rain;",
          "147:  bool hasrain = false;",
          "148:  float depth_cm;",
          "149:  bool hasdepth_cm = false;",
          "150:  float depth;",
          "151:  bool hasdepth = false;",
          "152:  float wind_str;",
          "153:  bool haswind_str = false;",
          "154:  float wind_gst;",
          "155:  bool haswind_gst = false;",
          "156:  int wind_dir;",
          "157:  bool haswind_dir = false;",
          "161:  if (data[\"id\"].empty())",
          "162:   return false; //we should have at least an ID",
          "164:  id = atoi(data[\"id\"].c_str());",
          "167:  if (FindField(data, \"unit\"))",
          "168:  {",
          "169:   unit = atoi(data[\"unit\"].c_str());",
          "170:   hasunit = true;",
          "171:  }",
          "172:  if (FindField(data, \"channel\"))",
          "173:  {",
          "174:   channel = atoi(data[\"channel\"].c_str());",
          "175:   haschannel = true;",
          "176:  }",
          "177:  if (FindField(data, \"battery\"))",
          "178:  {",
          "179:   if (data[\"battery\"] == \"LOW\") {",
          "180:    batterylevel = 10;",
          "181:    hasbattery = true;",
          "182:   }",
          "183:   else if (data[\"battery\"] == \"OK\") {",
          "184:    batterylevel = 100;",
          "185:    hasbattery = true;",
          "186:   }",
          "187:  }",
          "189:  if (FindField(data, \"temperature_C\"))",
          "190:  {",
          "191:   tempC = (float)atof(data[\"temperature_C\"].c_str());",
          "192:   hastempC = true;",
          "193:  }",
          "195:  if (FindField(data, \"humidity\"))",
          "196:  {",
          "197:   if (data[\"humidity\"] == \"HH\")",
          "198:   {",
          "199:    humidity = 90;",
          "200:    hashumidity = true;",
          "201:   }",
          "202:   else if (data[\"humidity\"] == \"LL\")",
          "203:   {",
          "204:    humidity = 10;",
          "205:    hashumidity = true;",
          "206:   }",
          "207:   else",
          "208:   {",
          "209:    humidity = atoi(data[\"humidity\"].c_str());",
          "210:    hashumidity = true;",
          "211:   }",
          "212:  }",
          "214:  if (FindField(data, \"pressure_hPa\"))",
          "215:  {",
          "216:   pressure = (float)atof(data[\"pressure_hPa\"].c_str());",
          "217:   haspressure = true;",
          "218:  }",
          "220:  if (FindField(data, \"rain\"))",
          "221:  {",
          "222:   rain = (float)atof(data[\"rain\"].c_str());",
          "223:   hasrain = true;",
          "224:  }",
          "225:  if (FindField(data, \"rain_total\"))",
          "226:  {",
          "227:   rain = (float)atof(data[\"rain_total\"].c_str());",
          "228:   hasrain = true;",
          "229:  }",
          "231:  if (FindField(data, \"depth_cm\"))",
          "232:  {",
          "233:   depth_cm = (float)atof(data[\"depth_cm\"].c_str());",
          "234:   hasdepth_cm = true;",
          "235:  }",
          "237:  if (FindField(data, \"depth\"))",
          "238:  {",
          "239:   depth = (float)atof(data[\"depth\"].c_str());",
          "240:   hasdepth = true;",
          "241:  }",
          "243:  if (FindField(data, \"windstrength\") || FindField(data, \"wind_speed\"))",
          "244:  {",
          "246:   if (FindField(data, \"windstrength\"))",
          "247:   {",
          "248:    wind_str = (float)atof(data[\"windstrength\"].c_str());",
          "249:   }",
          "250:   else if (FindField(data, \"wind_speed\"))",
          "251:   {",
          "252:    wind_str = (float)atof(data[\"wind_speed\"].c_str());",
          "253:   }",
          "254:   haswind_str = true;",
          "255:  }",
          "256:  else if (FindField(data, \"average\"))",
          "257:  {",
          "258:   wind_str = (float)atof(data[\"average\"].c_str());",
          "259:   haswind_str = true;",
          "260:  }",
          "262:  if (FindField(data, \"winddirection\") || FindField(data, \"wind_direction\"))",
          "263:  {",
          "265:   if (FindField(data, \"winddirection\"))",
          "266:   {",
          "267:    wind_dir = atoi(data[\"winddirection\"].c_str());",
          "268:   }",
          "269:   else if (FindField(data, \"wind_direction\"))",
          "270:   {",
          "271:    wind_dir = atoi(data[\"wind_direction\"].c_str());",
          "272:   }",
          "273:   haswind_dir = true;",
          "274:  }",
          "275:  else if (FindField(data, \"direction\"))",
          "276:  {",
          "277:   wind_dir = atoi(data[\"direction\"].c_str());",
          "278:   haswind_dir = true;",
          "279:  }",
          "281:  if (FindField(data, \"wind_gust\"))",
          "282:  {",
          "283:   wind_gst = (float)atof(data[\"wind_gust\"].c_str());",
          "284:   haswind_gst = true;",
          "285:  }",
          "286:  else if (FindField(data, \"gust\"))",
          "287:  {",
          "288:   wind_gst = (float)atof(data[\"gust\"].c_str());",
          "289:   haswind_gst = true;",
          "290:  }",
          "292:  std::string model = data[\"model\"];",
          "294:  bool hasstate = FindField(data, \"state\") || FindField(data, \"command\");",
          "296:  if (hasstate)",
          "297:  {",
          "298:   bool state = false;",
          "299:   if (FindField(data, \"state\"))",
          "300:    state = data[\"state\"] == \"ON\";",
          "301:   else if (FindField(data, \"command\"))",
          "302:    state = data[\"command\"] == \"On\";",
          "303:   unsigned int switchidx = (id & 0xfffffff) | ((channel & 0xf) << 28);",
          "304:   SendSwitch(switchidx,",
          "305:    unit,",
          "306:    batterylevel,",
          "307:    state,",
          "308:    0,",
          "309:    model);",
          "310:   return true;",
          "311:  }",
          "313:  unsigned int sensoridx = (id & 0xff) | ((channel & 0xff) << 8);",
          "315:  bool bValidTempHum = false;",
          "316:  if (hastempC && hashumidity)",
          "317:  {",
          "318:   bValidTempHum = !((tempC == 0) && (humidity == 0));",
          "319:  }",
          "321:  bool bHaveSend = false;",
          "322:  if (hastempC && hashumidity && haspressure && bValidTempHum)",
          "323:  {",
          "324:   int iForecast = 0;",
          "325:   SendTempHumBaroSensor(sensoridx,",
          "326:    batterylevel,",
          "327:    tempC,",
          "328:    humidity,",
          "329:    pressure,",
          "330:    iForecast,",
          "331:    model);",
          "332:   bHaveSend = true;",
          "333:  }",
          "334:  else if (haswind_str && haswind_dir && !haswind_gst && hastempC)",
          "335:  {",
          "336:   SendWind(sensoridx,",
          "337:    batterylevel,",
          "338:    wind_dir,",
          "339:    wind_str,",
          "340:    0,",
          "341:    tempC,",
          "342:    0,",
          "343:    true,",
          "344:    model);",
          "345:   bHaveSend = true;",
          "346:  }",
          "347:  else if (haswind_str && haswind_dir && !haswind_gst && !hastempC)",
          "348:  {",
          "349:   SendWind(sensoridx,",
          "350:    batterylevel,",
          "351:    wind_dir,",
          "352:    wind_str,",
          "353:    0,",
          "354:    0,",
          "355:    0,",
          "356:    false,",
          "357:    model);",
          "358:   bHaveSend = true;",
          "359:  }",
          "360:  else if (haswind_str && haswind_gst && haswind_dir && hastempC)",
          "361:  {",
          "362:   SendWind(sensoridx,",
          "363:    batterylevel,",
          "364:    wind_dir,",
          "365:    wind_str,",
          "366:    wind_gst,",
          "367:    tempC,",
          "368:    0,",
          "369:    true,",
          "370:    model);",
          "371:   bHaveSend = true;",
          "372:  }",
          "373:  else if (haswind_str && haswind_gst && haswind_dir && !hastempC)",
          "374:  {",
          "375:   SendWind(sensoridx,",
          "376:    batterylevel,",
          "377:    wind_dir,",
          "378:    wind_str,",
          "379:    wind_gst,",
          "380:    0,",
          "381:    0,",
          "382:    false,",
          "383:    model);",
          "384:   bHaveSend = true;",
          "385:  }",
          "386:  else if (hastempC && hashumidity && bValidTempHum)",
          "387:  {",
          "388:   SendTempHumSensor(sensoridx,",
          "389:    batterylevel,",
          "390:    tempC,",
          "391:    humidity,",
          "392:    model);",
          "393:   bHaveSend = true;",
          "394:  }",
          "395:  else if (hastempC && !hashumidity)",
          "396:  {",
          "397:   SendTempSensor(sensoridx,",
          "398:    batterylevel,",
          "399:    tempC,",
          "400:    model);",
          "401:   bHaveSend = true;",
          "402:  }",
          "403:  else if (!hastempC && hashumidity)",
          "404:  {",
          "405:   SendHumiditySensor(sensoridx,",
          "406:    batterylevel,",
          "407:    humidity,",
          "408:    model);",
          "409:   bHaveSend = true;",
          "410:  }",
          "412:  if (hasrain)",
          "413:  {",
          "414:   SendRainSensor(sensoridx,",
          "415:    batterylevel,",
          "416:    rain,",
          "417:    model);",
          "418:   bHaveSend = true;",
          "419:  }",
          "420:  if (hasdepth_cm)",
          "421:  {",
          "422:   SendDistanceSensor(sensoridx, unit,",
          "423:    batterylevel, depth_cm, model);",
          "424:   bHaveSend = true;",
          "425:  }",
          "426:  if (hasdepth)",
          "427:  {",
          "428:   SendDistanceSensor(sensoridx, unit,",
          "429:    batterylevel, depth, model);",
          "430:   bHaveSend = true;",
          "431:  }",
          "433:  return bHaveSend;",
          "434: }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "101:   char line[2048];",
          "102:   std::vector<std::string> headers;",
          "103:   std::string headerLine = \"\";",
          "106:   std::string szFlags = \"-F csv -q -I 2 \" + m_cmdline; // -f 433.92e6 -f 868.24e6 -H 60 -d 0",
          "107: #ifdef WIN32",
          "",
          "[Removed Lines]",
          "104:   std::string sLastLine = \"\";",
          "",
          "[Added Lines]",
          "450:   m_sLastLine = \"\";",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "138:   fcntl(fd, F_SETFL, flags);",
          "139: #endif",
          "140:   bool bFirstTime = true;",
          "142:   while (!IsStopRequested(100))",
          "143:   {",
          "144:    if (m_hPipe == NULL)",
          "",
          "[Removed Lines]",
          "141:   time_t time_last_received = time(NULL);",
          "",
          "[Added Lines]",
          "487:   m_time_last_received = time(NULL);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "156:      headers = ParseCSVLine(line);",
          "157:      continue;",
          "158:     }",
          "465:     {",
          "467:      _log.Log(LOG_STATUS, \"Rtl433: Unhandled sensor reading, please report: (%s|%s)\", headerLine.c_str(), line);",
          "468:     }",
          "474:    }",
          "475:    else { //fgets",
          "476:     if ((errno == EWOULDBLOCK)|| (errno == EAGAIN)) {",
          "",
          "[Removed Lines]",
          "159:     time_t atime = time(NULL);",
          "160:     std::string slineRaw(line);",
          "161:     if (slineRaw.find(',') != std::string::npos)",
          "162:     {",
          "163:      slineRaw = slineRaw.substr(slineRaw.find(',') + 1);",
          "164:      if (slineRaw == sLastLine)",
          "165:      {",
          "166:       if (atime - time_last_received < 2)",
          "167:        continue; //skip duplicate RF frames",
          "168:      }",
          "169:      sLastLine = slineRaw;",
          "170:     }",
          "171:     time_last_received = atime;",
          "172:     std::vector<std::string> values = ParseCSVLine(line);",
          "174:     std::map<std::string, std::string> data;",
          "175:     std::vector<std::string>::iterator h = headers.begin();",
          "176:     for (std::vector<std::string>::iterator vi = values.begin(); vi != values.end(); ++vi)",
          "177:     {",
          "178:      std::string header = *(h++);",
          "179:      data[header] = *vi;",
          "180:     }",
          "181:     int id = 0;",
          "182:     bool hasid = false;",
          "183:     int unit = 0;",
          "184:     bool hasunit = false;",
          "185:     int channel = 0;",
          "186:     bool haschannel = false;",
          "187:     int batterylevel = 255;",
          "188:     bool hasbattery = false;",
          "189:     float tempC;",
          "190:     bool hastempC = false;",
          "191:     int humidity;",
          "192:     bool hashumidity = false;",
          "193:     float pressure;",
          "194:     bool haspressure = false;",
          "195:     float rain;",
          "196:     bool hasrain = false;",
          "197:     float depth_cm;",
          "198:     bool hasdepth_cm = false;",
          "199:     float depth;",
          "200:     bool hasdepth = false;",
          "201:     float wind_str;",
          "202:     bool haswind_str = false;",
          "203:     float wind_gst;",
          "204:     bool haswind_gst = false;",
          "205:     int wind_dir;",
          "206:     bool haswind_dir = false;",
          "210:     if (!data[\"id\"].empty()) {",
          "211:      id = atoi(data[\"id\"].c_str());",
          "212:      hasid = true;",
          "213:     }",
          "216:     if (!data[\"unit\"].empty())",
          "217:     {",
          "218:      unit = atoi(data[\"unit\"].c_str());",
          "219:      hasunit = true;",
          "220:     }",
          "223:     if (!data[\"channel\"].empty())",
          "224:     {",
          "225:      channel = atoi(data[\"channel\"].c_str());",
          "226:      haschannel = true;",
          "227:     }",
          "229:     if (!data[\"battery\"].empty())",
          "230:     {",
          "231:      if (data[\"battery\"] == \"LOW\") {",
          "232:       batterylevel = 10;",
          "233:       hasbattery = true;",
          "234:      }",
          "235:      if (data[\"battery\"] == \"OK\") {",
          "236:       batterylevel = 100;",
          "237:       hasbattery = true;",
          "238:      }",
          "239:     }",
          "241:     if (!data[\"temperature_C\"].empty())",
          "242:     {",
          "243:      tempC = (float)atof(data[\"temperature_C\"].c_str());",
          "244:      hastempC = true;",
          "245:     }",
          "247:     if (!data[\"humidity\"].empty())",
          "248:      {",
          "249:      if (data[\"humidity\"] == \"HH\")",
          "250:      {",
          "251:       humidity = 90;",
          "252:       hashumidity = true;",
          "253:      }",
          "254:      else if (data[\"humidity\"] == \"LL\")",
          "255:      {",
          "256:       humidity = 10;",
          "257:       hashumidity = true;",
          "258:      }",
          "259:      else",
          "260:      {",
          "261:       humidity = atoi(data[\"humidity\"].c_str());",
          "262:       hashumidity = true;",
          "263:      }",
          "264:     }",
          "266:     if (!data[\"pressure_hPa\"].empty())",
          "267:     {",
          "268:      pressure = (float)atof(data[\"pressure_hPa\"].c_str());",
          "269:      haspressure = true;",
          "270:     }",
          "272:     if (!data[\"rain\"].empty())",
          "273:     {",
          "274:      rain = (float)atof(data[\"rain\"].c_str());",
          "275:      hasrain = true;",
          "276:     }",
          "277:     if (!data[\"depth_cm\"].empty())",
          "278:     {",
          "279:      depth_cm = (float)atof(data[\"depth_cm\"].c_str());",
          "280:      hasdepth_cm = true;",
          "281:     }",
          "283:     if (!data[\"depth\"].empty())",
          "284:     {",
          "285:      depth = (float)atof(data[\"depth\"].c_str());",
          "286:      hasdepth = true;",
          "287:     }",
          "289:     if (!data[\"windstrength\"].empty() || !data[\"wind_speed\"].empty())",
          "290:     {",
          "292:      if (!data[\"windstrength\"].empty())",
          "293:      {",
          "294:       wind_str = (float)atof(data[\"windstrength\"].c_str());",
          "295:      }",
          "296:      else if (!data[\"wind_speed\"].empty())",
          "297:      {",
          "298:       wind_str = (float)atof(data[\"wind_speed\"].c_str());",
          "299:      }",
          "300:      haswind_str = true;",
          "301:     }",
          "303:     if (!data[\"winddirection\"].empty() || !data[\"wind_direction\"].empty())",
          "304:     {",
          "306:      if (!data[\"winddirection\"].empty())",
          "307:      {",
          "308:       wind_dir = atoi(data[\"winddirection\"].c_str());",
          "309:      }",
          "310:      else if (!data[\"wind_direction\"].empty())",
          "311:      {",
          "312:       wind_dir = atoi(data[\"wind_direction\"].c_str());",
          "313:      }",
          "314:      haswind_dir = true;",
          "315:     }",
          "317:     if (!data[\"wind_gust\"].empty())",
          "318:     {",
          "319:      wind_gst = (float)atof(data[\"wind_gust\"].c_str());",
          "320:      haswind_gst = true;",
          "321:     }",
          "323:     std::string model = data[\"model\"];",
          "325:     bool hasstate =",
          "326:      (!data[\"state\"].empty()) ||",
          "327:      (!data[\"command\"].empty());",
          "328:     bool state =",
          "329:      data[\"state\"] == \"ON\" ||",
          "330:      data[\"command\"] == \"On\";",
          "332:     if (hasstate)",
          "333:     {",
          "334:      unsigned int switchidx = (id & 0xfffffff) | ((channel & 0xf) << 28);",
          "335:      SendSwitch(switchidx,",
          "336:       unit,",
          "337:       batterylevel,",
          "338:       state,",
          "339:       0,",
          "340:       model);",
          "341:      continue;",
          "342:     }",
          "344:     unsigned int sensoridx = (id & 0xff) | ((channel & 0xff) << 8);",
          "346:     bool bValidTempHum = false;",
          "347:     if (hastempC && hashumidity)",
          "348:     {",
          "349:      bValidTempHum = !((tempC == 0) && (humidity == 0));",
          "350:     }",
          "352:     bool bHaveSend = false;",
          "353:     if (hastempC && hashumidity && haspressure && bValidTempHum)",
          "354:     {",
          "355:      int iForecast = 0;",
          "356:      SendTempHumBaroSensor(sensoridx,",
          "357:       batterylevel,",
          "358:       tempC,",
          "359:       humidity,",
          "360:       pressure,",
          "361:       iForecast,",
          "362:       model);",
          "363:      bHaveSend = true;",
          "364:     }",
          "365:     else if (haswind_str && haswind_dir && !haswind_gst && hastempC)",
          "366:     {",
          "367:      SendWind(sensoridx,",
          "368:       batterylevel,",
          "369:       wind_dir,",
          "370:       wind_str,",
          "371:       0,",
          "372:       tempC,",
          "373:       0,",
          "374:       true,",
          "375:       model);",
          "376:      bHaveSend = true;",
          "377:     }",
          "378:     else if (haswind_str && haswind_dir && !haswind_gst && !hastempC)",
          "379:     {",
          "380:      SendWind(sensoridx,",
          "381:       batterylevel,",
          "382:       wind_dir,",
          "383:       wind_str,",
          "384:       0,",
          "385:       0,",
          "386:       0,",
          "387:       false,",
          "388:       model);",
          "389:      bHaveSend = true;",
          "390:     }",
          "391:     else if (haswind_str && haswind_gst && haswind_dir && hastempC)",
          "392:     {",
          "393:      SendWind(sensoridx,",
          "394:       batterylevel,",
          "395:       wind_dir,",
          "396:       wind_str,",
          "397:       wind_gst,",
          "398:       tempC,",
          "399:       0,",
          "400:       true,",
          "401:       model);",
          "402:      bHaveSend = true;",
          "403:     }",
          "404:     else if (haswind_str && haswind_gst && haswind_dir && !hastempC)",
          "405:     {",
          "406:      SendWind(sensoridx,",
          "407:       batterylevel,",
          "408:       wind_dir,",
          "409:       wind_str,",
          "410:       wind_gst,",
          "411:       0,",
          "412:       0,",
          "413:       false,",
          "414:       model);",
          "415:      bHaveSend = true;",
          "416:     }",
          "417:     else if (hastempC && hashumidity && bValidTempHum)",
          "418:     {",
          "419:      SendTempHumSensor(sensoridx,",
          "420:       batterylevel,",
          "421:       tempC,",
          "422:       humidity,",
          "423:       model);",
          "424:      bHaveSend = true;",
          "425:     }",
          "426:     else if (hastempC && !hashumidity)",
          "427:     {",
          "428:      SendTempSensor(sensoridx,",
          "429:       batterylevel,",
          "430:       tempC,",
          "431:       model);",
          "432:      bHaveSend = true;",
          "433:     }",
          "434:     else if (!hastempC && hashumidity)",
          "435:     {",
          "436:      SendHumiditySensor(sensoridx,",
          "437:       batterylevel,",
          "438:       humidity,",
          "439:       model);",
          "440:      bHaveSend = true;",
          "441:     }",
          "443:     if (hasrain)",
          "444:     {",
          "445:      SendRainSensor(sensoridx,",
          "446:       batterylevel,",
          "447:       rain,",
          "448:       model);",
          "449:      bHaveSend = true;",
          "450:     }",
          "451:     if (hasdepth_cm)",
          "452:     {",
          "453:      SendDistanceSensor(sensoridx, unit,",
          "454:       batterylevel, depth_cm, model);",
          "455:      bHaveSend = true;",
          "456:     }",
          "457:     if (hasdepth)",
          "458:     {",
          "459:      SendDistanceSensor(sensoridx, unit,",
          "460:       batterylevel, depth, model);",
          "461:      bHaveSend = true;",
          "462:     }",
          "464:     if (!bHaveSend)",
          "469:     else",
          "470:     {",
          "473:     }",
          "",
          "[Added Lines]",
          "505:     if (!ParseLine(headers, line))",
          "",
          "---------------"
        ],
        "hardware/Rtl433.h||hardware/Rtl433.h": [
          "File: hardware/Rtl433.h -> hardware/Rtl433.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "13:  bool StopHardware() override;",
          "14:  void Do_Work();",
          "15:  static std::vector<std::string> ParseCSVLine(const char *input);",
          "16: private:",
          "17:  std::shared_ptr<std::thread> m_thread;",
          "18:  std::mutex m_pipe_mutex;",
          "19:  FILE *m_hPipe;",
          "20:  std::string m_cmdline;",
          "21: };",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "16:  bool ParseLine(const std::vector<std::string> &headers, const char *line);",
          "17:  bool FindField(const std::map<std::string, std::string> &data, const std::string &field);",
          "23:  std::string m_sLastLine;",
          "24:  time_t m_time_last_received;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "55086d5c14aa11bd7710b522ba8625216ccace41",
      "candidate_info": {
        "commit_hash": "55086d5c14aa11bd7710b522ba8625216ccace41",
        "repo": "domoticz/domoticz",
        "commit_url": "https://github.com/domoticz/domoticz/commit/55086d5c14aa11bd7710b522ba8625216ccace41",
        "files": [
          "hardware/RFLinkBase.cpp"
        ],
        "message": "RFLink getting correct ID",
        "before_after_code_files": [
          "hardware/RFLinkBase.cpp||hardware/RFLinkBase.cpp"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/domoticz/domoticz/pull/3180"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "hardware/RFLinkBase.cpp||hardware/RFLinkBase.cpp": [
          "File: hardware/RFLinkBase.cpp -> hardware/RFLinkBase.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "343:    char szUnit[10];",
          "344:    sprintf(szUnit, \"%c%c\", (pSwitch->id & 0xFF00) >> 8, pSwitch->id & 0xFF);",
          "346:   }",
          "348:   _log.Log(LOG_STATUS, \"RFLink Sending: %s\", sstr.str().c_str());",
          "",
          "[Removed Lines]",
          "345:    sstr << switchtype << \";\" << std::hex << std::nouppercase << std::setw(6) << std::setfill('0') << (pSwitch->id >> 16) << \";\" << szUnit << \";\" << switchcmnd << \";\";",
          "",
          "[Added Lines]",
          "345:    sstr << switchtype << \";\" << std::hex << std::nouppercase << std::setw(6) << std::setfill('0') << ((pSwitch->id & 0xFFFF0000) >> 16) << \";\" << szUnit << \";\" << switchcmnd << \";\";",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "18671433e65e37e47ede273227189bc5ef1dffb8",
      "candidate_info": {
        "commit_hash": "18671433e65e37e47ede273227189bc5ef1dffb8",
        "repo": "domoticz/domoticz",
        "commit_url": "https://github.com/domoticz/domoticz/commit/18671433e65e37e47ede273227189bc5ef1dffb8",
        "files": [
          "main/EventSystem.cpp"
        ],
        "message": "Eventsystem, logging setpoint value",
        "before_after_code_files": [
          "main/EventSystem.cpp||main/EventSystem.cpp"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/domoticz/domoticz/pull/3180"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "main/EventSystem.cpp||main/EventSystem.cpp": [
          "File: main/EventSystem.cpp -> main/EventSystem.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "3744:    (devType == pTypeRadiator1 && !sValue.empty())",
          "3745:    )",
          "3746:   {",
          "3748:    m_mainworker.SetSetPoint(std::to_string(idx), static_cast<float>(atof(sValue.c_str())));",
          "3749:   }",
          "3750:   else if ((devType == pTypeGeneral) && (subType == sTypeZWaveThermostatMode) && nValue != -1)",
          "",
          "[Removed Lines]",
          "3747:    _log.Log(LOG_NORM, \"EventSystem: Sending SetPoint to device '%s' ....\", dname.c_str());",
          "",
          "[Added Lines]",
          "3747:    _log.Log(LOG_NORM, \"EventSystem: Sending SetPoint to device '%s' (%g) ....\", dname.c_str(), static_cast<float>(atof(sValue.c_str())));",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "c7e556ab00875fa06a8d93f1881dea29ec8334a2",
      "candidate_info": {
        "commit_hash": "c7e556ab00875fa06a8d93f1881dea29ec8334a2",
        "repo": "domoticz/domoticz",
        "commit_url": "https://github.com/domoticz/domoticz/commit/c7e556ab00875fa06a8d93f1881dea29ec8334a2",
        "files": [
          "hardware/EnOceanESP3.cpp"
        ],
        "message": "Added support for NodeOn Soft Button TSB-2-1-01",
        "before_after_code_files": [
          "hardware/EnOceanESP3.cpp||hardware/EnOceanESP3.cpp"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/domoticz/domoticz/pull/3180"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "hardware/EnOceanESP3.cpp||hardware/EnOceanESP3.cpp": [
          "File: hardware/EnOceanESP3.cpp -> hardware/EnOceanESP3.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "1943:     unsigned char func = (m_buffer[1] >> 2) & 0x3F;",
          "1944:     unsigned char type = ((m_buffer[2] >> 3) & 0x1F) | ((m_buffer[1] & 0x03) << 5);",
          "1948:     {",
          "1951:      {",
          "1952:       case 0x0C: // D2-01-0C",
          "1993: #ifdef ENOCEAN_BUTTON_DEBUG",
          "2000: #endif //ENOCEAN_BUTTON_DEBUG",
          "2013:      }",
          "2014:     }",
          "2015:    }",
          "2017:   default:",
          "2018:    _log.Log(LOG_NORM, \"EnOcean: Unhandled RORG (%02x)\", m_buffer[0]);",
          "2019:    break;",
          "",
          "[Removed Lines]",
          "1946:     _log.Log(LOG_NORM, \"EnOcean message VLD: func: %02X Type: %02X\", func, type);",
          "1947:     if(func == 0x01)",
          "1950:      switch(type)",
          "1953:          {",
          "1954:           unsigned char channel = m_buffer[2] & 0x7;",
          "1956:           unsigned char dim_power = m_buffer[3] & 0x7F;  // 0=off, 0x64=100%",
          "1958:           unsigned char ID_BYTE3=m_buffer[4];",
          "1959:           unsigned char ID_BYTE2=m_buffer[5];",
          "1960:           unsigned char ID_BYTE1=m_buffer[6];",
          "1961:           unsigned char ID_BYTE0=m_buffer[7];",
          "1962:           long id = (ID_BYTE3 << 24) + (ID_BYTE2 << 16) + (ID_BYTE1 << 8) + ID_BYTE0;",
          "1965:           char szDeviceID[20];",
          "1966:           std::vector<std::vector<std::string> > result;",
          "1967:           sprintf(szDeviceID,\"%08X\",(unsigned int)id);",
          "1969:           result = m_sql.safe_query(\"SELECT ID, Manufacturer, Profile, [Type] FROM EnoceanSensors WHERE (HardwareID==%d) AND (DeviceID=='%q')\", m_HwdID, szDeviceID);",
          "1970:           if (result.size()<1)",
          "1971:           {",
          "1972:            _log.Log(LOG_NORM, \"EnOcean: Need Teach-In for %s\", szDeviceID);",
          "1973:            return;",
          "1974:           }",
          "1976:           RBUF tsen;",
          "1977:           memset(&tsen,0,sizeof(RBUF));",
          "1978:           tsen.LIGHTING2.packetlength=sizeof(tsen.LIGHTING2)-1;",
          "1979:           tsen.LIGHTING2.packettype=pTypeLighting2;",
          "1980:           tsen.LIGHTING2.subtype=sTypeAC;",
          "1981:           tsen.LIGHTING2.seqnbr=0;",
          "1983:           tsen.LIGHTING2.id1=(BYTE)ID_BYTE3;",
          "1984:           tsen.LIGHTING2.id2=(BYTE)ID_BYTE2;",
          "1985:           tsen.LIGHTING2.id3=(BYTE)ID_BYTE1;",
          "1986:           tsen.LIGHTING2.id4=(BYTE)ID_BYTE0;",
          "1987:           tsen.LIGHTING2.level=dim_power;",
          "1988:           tsen.LIGHTING2.rssi=12;",
          "1990:           tsen.LIGHTING2.unitcode = channel + 1;",
          "1991:           tsen.LIGHTING2.cmnd     = (dim_power>0) ? light2_sOn : light2_sOff;",
          "1994:           _log.Log(LOG_NORM, \"EnOcean message: 0x%02X Node 0x%08x UnitID: %02X cmd: %02X \",",
          "1995:            DATA_BYTE3,",
          "1996:            id,",
          "1997:            tsen.LIGHTING2.unitcode,",
          "1998:            tsen.LIGHTING2.cmnd",
          "1999:           );",
          "2003:           sDecodeRXMessage(this, (const unsigned char *)&tsen.LIGHTING2, NULL, 255);",
          "2010:           return;",
          "2011:          }",
          "2012:          break;",
          "",
          "[Added Lines]",
          "1946:     if ((m_buffer[1] == 0x61) || (m_buffer[1] == 0x63))",
          "1948:      _log.Log(LOG_NORM, \"EnOcean message VLD %02X\", m_buffer[1]);",
          "1950:      unsigned char DATA_BYTE0 = m_buffer[2]; //1 = simple press, 2=double press, 3=long press, 4=press release",
          "1952:      unsigned char ID_BYTE3 = m_buffer[3];",
          "1953:      unsigned char ID_BYTE2 = m_buffer[4];",
          "1954:      unsigned char ID_BYTE1 = m_buffer[5];",
          "1955:      unsigned char ID_BYTE0 = m_buffer[6];",
          "1957:      unsigned long id = (ID_BYTE3 << 24) + (ID_BYTE2 << 16) + (ID_BYTE1 << 8) + ID_BYTE0;",
          "1958:      SendGeneralSwitch(id, DATA_BYTE0, 255, 1, 0, \"Switch\", 12);",
          "1959:      return;",
          "1960:     }",
          "1961:     else",
          "1962:     {",
          "1963:      _log.Log(LOG_NORM, \"EnOcean message VLD: func: %02X Type: %02X\", func, type);",
          "1964:      if (func == 0x01)",
          "1967:       switch (type)",
          "1968:       {",
          "1970:       {",
          "1971:        unsigned char channel = m_buffer[2] & 0x7;",
          "1973:        unsigned char dim_power = m_buffer[3] & 0x7F;  // 0=off, 0x64=100%",
          "1975:        unsigned char ID_BYTE3 = m_buffer[4];",
          "1976:        unsigned char ID_BYTE2 = m_buffer[5];",
          "1977:        unsigned char ID_BYTE1 = m_buffer[6];",
          "1978:        unsigned char ID_BYTE0 = m_buffer[7];",
          "1979:        long id = (ID_BYTE3 << 24) + (ID_BYTE2 << 16) + (ID_BYTE1 << 8) + ID_BYTE0;",
          "1982:        char szDeviceID[20];",
          "1983:        std::vector<std::vector<std::string> > result;",
          "1984:        sprintf(szDeviceID, \"%08X\", (unsigned int)id);",
          "1986:        result = m_sql.safe_query(\"SELECT ID, Manufacturer, Profile, [Type] FROM EnoceanSensors WHERE (HardwareID==%d) AND (DeviceID=='%q')\", m_HwdID, szDeviceID);",
          "1987:        if (result.size() < 1)",
          "1988:        {",
          "1989:         _log.Log(LOG_NORM, \"EnOcean: Need Teach-In for %s\", szDeviceID);",
          "1990:         return;",
          "1991:        }",
          "1993:        RBUF tsen;",
          "1994:        memset(&tsen, 0, sizeof(RBUF));",
          "1995:        tsen.LIGHTING2.packetlength = sizeof(tsen.LIGHTING2) - 1;",
          "1996:        tsen.LIGHTING2.packettype = pTypeLighting2;",
          "1997:        tsen.LIGHTING2.subtype = sTypeAC;",
          "1998:        tsen.LIGHTING2.seqnbr = 0;",
          "2000:        tsen.LIGHTING2.id1 = (BYTE)ID_BYTE3;",
          "2001:        tsen.LIGHTING2.id2 = (BYTE)ID_BYTE2;",
          "2002:        tsen.LIGHTING2.id3 = (BYTE)ID_BYTE1;",
          "2003:        tsen.LIGHTING2.id4 = (BYTE)ID_BYTE0;",
          "2004:        tsen.LIGHTING2.level = dim_power;",
          "2005:        tsen.LIGHTING2.rssi = 12;",
          "2007:        tsen.LIGHTING2.unitcode = channel + 1;",
          "2008:        tsen.LIGHTING2.cmnd = (dim_power > 0) ? light2_sOn : light2_sOff;",
          "2011:        _log.Log(LOG_NORM, \"EnOcean message: 0x%02X Node 0x%08x UnitID: %02X cmd: %02X \",",
          "2012:         DATA_BYTE3,",
          "2013:         id,",
          "2014:         tsen.LIGHTING2.unitcode,",
          "2015:         tsen.LIGHTING2.cmnd",
          "2016:        );",
          "2020:        sDecodeRXMessage(this, (const unsigned char *)&tsen.LIGHTING2, NULL, 255);",
          "2027:        return;",
          "2028:       }",
          "2029:       break;",
          "2030:       }",
          "2031:      }",
          "2032:      else if (func == 0x02)",
          "2033:      {",
          "2035:      }",
          "2036:      else if (func == 0x03)",
          "2037:      {",
          "2039:       switch (type)",
          "2040:       {",
          "2041:       case 0x00: // D3-03-00 Light, Switching and Blind Control Type",
          "2042:        break;",
          "2043:       case 0x0A: // D3-03-0A Push Button \u2013 Single Button",
          "2044:        while (1 == 0);",
          "2045:        break;",
          "2046:       case 0x10: // D3-03-10 Mechanical Handle",
          "2047:        break;",
          "2048:       case 0x20: // D3-03-20 Beacon with Vibration Detection",
          "2049:        break;",
          "2050:       }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "77917fd7da445a89b077e59988aa4d8232da97f1",
      "candidate_info": {
        "commit_hash": "77917fd7da445a89b077e59988aa4d8232da97f1",
        "repo": "domoticz/domoticz",
        "commit_url": "https://github.com/domoticz/domoticz/commit/77917fd7da445a89b077e59988aa4d8232da97f1",
        "files": [
          "main/EventSystem.cpp"
        ],
        "message": "CEventSystem::SetEventTrigger, Fixed CPPCheck warning",
        "before_after_code_files": [
          "main/EventSystem.cpp||main/EventSystem.cpp"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/domoticz/domoticz/pull/3180"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "main/EventSystem.cpp||main/EventSystem.cpp": [
          "File: main/EventSystem.cpp -> main/EventSystem.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "1254:  if (m_eventtrigger.size() > 0)",
          "1255:  {",
          "1256:   time_t atime = mytime(NULL) + static_cast<int>(fDelayTime);",
          "1259:   {",
          "1262:   }",
          "1263:  }",
          "1264:  _tEventTrigger item;",
          "",
          "[Removed Lines]",
          "1257:   std::vector<_tEventTrigger>::iterator itt;",
          "1258:   for (itt = m_eventtrigger.begin(); itt != m_eventtrigger.end(); ++itt)",
          "1260:    if (itt->ID == ulDevID && itt->reason == reason && itt->timestamp >= atime) // cancel later queued items",
          "1261:     itt = m_eventtrigger.erase(itt) - 1;",
          "",
          "[Added Lines]",
          "1257:   for (auto itt = m_eventtrigger.begin(); itt != m_eventtrigger.end(); ++itt)",
          "1259:    if (itt->ID == ulDevID && itt->reason == reason && itt->timestamp >= atime) // cancel later or equal queued items",
          "1260:    {",
          "1261:     m_eventtrigger.erase(itt--);",
          "1262:    }",
          "",
          "---------------"
        ]
      }
    }
  ]
}
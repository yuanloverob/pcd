{
  "cve_id": "CVE-2017-9763",
  "cve_desc": "The grub_ext2_read_block function in fs/ext2.c in GNU GRUB before 2013-11-12, as used in shlr/grub/fs/ext2.c in radare2 1.5.0, allows remote attackers to cause a denial of service (excessive stack use and application crash) via a crafted binary file, related to use of a variable-size stack array.",
  "repo": "radare/radare2",
  "patch_hash": "65000a7fd9eea62359e6d6714f17b94a99a82edd",
  "patch_info": {
    "commit_hash": "65000a7fd9eea62359e6d6714f17b94a99a82edd",
    "repo": "radare/radare2",
    "commit_url": "https://github.com/radare/radare2/commit/65000a7fd9eea62359e6d6714f17b94a99a82edd",
    "files": [
      "libr/core/cmd_mount.c",
      "shlr/grub/fs/ext2.c",
      "shlr/grub/fs/fshelp.c",
      "shlr/grub/grubfs.c",
      "sys/rebuild.sh"
    ],
    "message": "Fix #7723 - crash in ext2 GRUB code because of variable size array in stack",
    "before_after_code_files": [
      "libr/core/cmd_mount.c||libr/core/cmd_mount.c",
      "shlr/grub/fs/ext2.c||shlr/grub/fs/ext2.c",
      "shlr/grub/fs/fshelp.c||shlr/grub/fs/fshelp.c",
      "shlr/grub/grubfs.c||shlr/grub/grubfs.c",
      "sys/rebuild.sh||sys/rebuild.sh"
    ]
  },
  "patch_diff": {
    "libr/core/cmd_mount.c||libr/core/cmd_mount.c": [
      "File: libr/core/cmd_mount.c -> libr/core/cmd_mount.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "35:  switch (*input) {",
      "36:  case ' ':",
      "37:   input++;",
      "39:    input++;",
      "40:   ptr = strchr (input, ' ');",
      "41:   if (ptr) {",
      "",
      "[Removed Lines]",
      "38:   if (input[0]==' ')",
      "",
      "[Added Lines]",
      "38:   if (input[0]==' ') {",
      "40:   }",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "47:     off = r_num_math (core->num, ptr2+1);",
      "48:    }",
      "50:     eprintf (\"Cannot mount %s\\n\", input);",
      "51:   } else {",
      "53:     eprintf (\"Unknown filesystem type\\n\");",
      "55:     eprintf (\"Cannot mount %s\\n\", input);",
      "56:    free (ptr);",
      "57:   }",
      "58:   break;",
      "",
      "[Removed Lines]",
      "49:    if (!r_fs_mount (core->fs, ptr, input, off))",
      "52:    if (!(ptr = r_fs_name (core->fs, core->offset)))",
      "54:    else if (!r_fs_mount (core->fs, ptr, input, core->offset))",
      "",
      "[Added Lines]",
      "50:    if (!r_fs_mount (core->fs, ptr, input, off)) {",
      "52:    }",
      "54:    if (!(ptr = r_fs_name (core->fs, core->offset))) {",
      "56:    } else if (!r_fs_mount (core->fs, ptr, input, core->offset)) {",
      "58:    }",
      "",
      "---------------"
    ],
    "shlr/grub/fs/ext2.c||shlr/grub/fs/ext2.c": [
      "File: shlr/grub/fs/ext2.c -> shlr/grub/fs/ext2.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "42: #define FILETYPE_INO_DIRECTORY 0040000",
      "43: #define FILETYPE_INO_SYMLINK 0120000",
      "45: #include <grub/err.h>",
      "46: #include <grub/file.h>",
      "47: #include <grub/mm.h>",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "45: #include <stdlib.h>",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "367:       block = grub_le_to_cpu16 (index[i].leaf_hi);",
      "368:       block = (block << 32) + grub_le_to_cpu32 (index[i].leaf);",
      "369:       if (grub_disk_read (data->disk,",
      "371:                           0, EXT2_BLOCK_SIZE(data), buf))",
      "372:         return 0;",
      "374:       ext_block = (struct grub_ext4_extent_header *) buf;",
      "",
      "[Removed Lines]",
      "370:                           block << LOG2_EXT2_BLOCK_SIZE (data),",
      "",
      "[Added Lines]",
      "371:                           block << LOG2_EXT2_BLOCK_SIZE (data),",
      "373:         return 0;",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "385:   int log2_blksz = LOG2_EXT2_BLOCK_SIZE (data);",
      "387:   if (grub_le_to_cpu32(inode->flags) & EXT4_EXTENTS_FLAG)",
      "393: #endif",
      "394:       struct grub_ext4_extent_header *leaf;",
      "395:       struct grub_ext4_extent *ext;",
      "",
      "[Removed Lines]",
      "388:     {",
      "389: #ifndef _MSC_VER",
      "390:    char buf[EXT2_BLOCK_SIZE (data)];",
      "391: #else",
      "392:    char * buf = grub_malloc (EXT2_BLOCK_SIZE(data));",
      "",
      "[Added Lines]",
      "390:     {",
      "391:    char * buf = grub_malloc (EXT2_BLOCK_SIZE (data));",
      "392:           if (!buf) {",
      "393:               return -1;",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "400:     fileblock);",
      "401:       if (! leaf)",
      "402:         {",
      "403:           grub_error (GRUB_ERR_BAD_FS, \"invalid extent\");",
      "404:           return -1;",
      "405:         }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "404:           grub_error (GRUB_ERR_BAD_FS, \"invalid extent\");",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "414:       if (--i >= 0)",
      "415:         {",
      "417:           if (fileblock >= grub_le_to_cpu16 (ext[i].len))",
      "419:           else",
      "420:             {",
      "421:               grub_disk_addr_t start;",
      "423:               start = grub_le_to_cpu16 (ext[i].start_hi);",
      "424:               start = (start << 32) + grub_le_to_cpu32 (ext[i].start);",
      "426:               return fileblock + start;",
      "",
      "[Removed Lines]",
      "416:           fileblock -= grub_le_to_cpu32 (ext[i].block);",
      "418:             return 0;",
      "",
      "[Added Lines]",
      "418:           fileblock -= grub_le_to_cpu32 (ext[i].block);",
      "419:           if (fileblock >= grub_le_to_cpu16 (ext[i].len)) {",
      "421:             return 0;",
      "427:               start = (start << 32) + grub_le_to_cpu32 (ext[i].start);",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "428:         }",
      "429:       else",
      "430:         {",
      "431:           grub_error (GRUB_ERR_BAD_FS, \"something wrong with extent\");",
      "432:           return -1;",
      "433:         }",
      "434:     }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "435:           grub_error (GRUB_ERR_BAD_FS, \"something wrong with extent\");",
      "438:         }",
      "",
      "---------------",
      "--- Hunk 7 ---",
      "[Context before]",
      "440:     {",
      "441:       grub_uint32_t *indir;",
      "444:       if (! indir)",
      "445:  return grub_errno;",
      "447:       if (grub_disk_read (data->disk,",
      "448:      ((grub_disk_addr_t)",
      "449:       grub_le_to_cpu32 (inode->blocks.indir_block))",
      "451:      0, blksz, indir))",
      "452:  return grub_errno;",
      "454:       blknr = grub_le_to_cpu32 (indir[fileblock - INDIRECT_BLOCKS]);",
      "",
      "[Removed Lines]",
      "443:       indir = grub_malloc (blksz);",
      "450:      << log2_blksz,",
      "",
      "[Added Lines]",
      "449:       indir = grub_malloc (blksz);",
      "451:  return grub_errno;",
      "457:      << log2_blksz,",
      "459:  return grub_errno;",
      "",
      "---------------",
      "--- Hunk 8 ---",
      "[Context before]",
      "463:       + blksz / 4);",
      "464:       grub_uint32_t *indir;",
      "467:       if (! indir)",
      "468:  return grub_errno;",
      "470:       if (grub_disk_read (data->disk,",
      "471:      ((grub_disk_addr_t)",
      "472:       grub_le_to_cpu32 (inode->blocks.double_indir_block))",
      "474:      0, blksz, indir))",
      "475:  return grub_errno;",
      "477:       if (grub_disk_read (data->disk,",
      "478:      ((grub_disk_addr_t)",
      "479:       grub_le_to_cpu32 (indir[rblock / perblock]))",
      "481:      0, blksz, indir))",
      "482:  return grub_errno;",
      "484:       blknr = grub_le_to_cpu32 (indir[rblock % perblock]);",
      "",
      "[Removed Lines]",
      "466:       indir = grub_malloc (blksz);",
      "473:      << log2_blksz,",
      "480:      << log2_blksz,",
      "",
      "[Added Lines]",
      "474:       indir = grub_malloc (blksz);",
      "476:  return grub_errno;",
      "482:      << log2_blksz,",
      "484:  return grub_errno;",
      "490:      << log2_blksz,",
      "492:  return grub_errno;",
      "",
      "---------------"
    ],
    "shlr/grub/fs/fshelp.c||shlr/grub/fs/fshelp.c": [
      "File: shlr/grub/fs/fshelp.c -> shlr/grub/fs/fshelp.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "91:     grub_fshelp_node_t *currfound,",
      "92:     struct grub_fshelp_find_file_closure *c)",
      "93: {",
      "97:  char *fpath = grub_malloc (grub_strlen (currpath) + 1);",
      "99:   char *name = fpath;",
      "100:   char *next;",
      "101:   enum grub_fshelp_filetype type = GRUB_FSHELP_DIR;",
      "",
      "[Removed Lines]",
      "94: #ifndef _MSC_VER",
      "95:  char fpath[grub_strlen (currpath) + 1];",
      "96: #else",
      "98: #endif",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "113:   if (! *name)",
      "114:     {",
      "116:       return 0;",
      "117:     }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "112: free (fpath);",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "135:       if (type != GRUB_FSHELP_DIR)",
      "136:  {",
      "137:    free_node (currnode, c);",
      "138:    return grub_error (GRUB_ERR_BAD_FILE_TYPE, \"not a directory\");",
      "139:  }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "135: free (fpath);",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "146:       found = c->iterate_dir (currnode, iterate, &cc);",
      "147:       if (! found)",
      "148:  {",
      "150:      return grub_errno;",
      "152:    break;",
      "153:  }",
      "",
      "[Removed Lines]",
      "149:    if (grub_errno)",
      "",
      "[Added Lines]",
      "147:    if (grub_errno) {",
      "148: free (fpath);",
      "150: }",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "162:      {",
      "163:        free_node (currnode, c);",
      "164:        free_node (oldnode, c);",
      "165:        return grub_error (GRUB_ERR_SYMLINK_LOOP,",
      "166:      \"too deep nesting of symlinks\");",
      "167:      }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "165: free (fpath);",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "172:    if (!symlink)",
      "173:      {",
      "174:        free_node (oldnode, c);",
      "175:        return grub_errno;",
      "176:      }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "176: free (fpath);",
      "",
      "---------------",
      "--- Hunk 7 ---",
      "[Context before]",
      "190:    if (grub_errno)",
      "191:      {",
      "192:        free_node (oldnode, c);",
      "193:        return grub_errno;",
      "194:      }",
      "195:  }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "195: free (fpath);",
      "",
      "---------------",
      "--- Hunk 8 ---",
      "[Context before]",
      "201:  {",
      "203:    c->foundtype = type;",
      "204:    return 0;",
      "205:  }",
      "207:       name = next;",
      "208:     }",
      "210:   return grub_error (GRUB_ERR_FILE_NOT_FOUND, \"file not found\");",
      "211: }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "207: free (fpath);",
      "214: free (fpath);",
      "",
      "---------------"
    ],
    "shlr/grub/grubfs.c||shlr/grub/grubfs.c": [
      "File: shlr/grub/grubfs.c -> shlr/grub/grubfs.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "17: }",
      "19: static grub_err_t read_foo (struct grub_disk *disk, grub_disk_addr_t sector, grub_size_t size, char *buf) {",
      "34: }",
      "36: GrubFS *grubfs_new (struct grub_fs *myfs, void *data) {",
      "",
      "[Removed Lines]",
      "20:  if (disk != NULL) {",
      "21:   const int blocksize = 512; // unhardcode 512",
      "22:   int ret;",
      "23:   RIOBind *iob = disk->data;",
      "24:   if (bio) iob = bio;",
      "26:   ret = iob->read_at (iob->io, delta+(blocksize*sector),",
      "27:    (ut8*)buf, size*blocksize);",
      "28:   if (ret == -1)",
      "29:    return 1;",
      "32:  } else eprintf (\"oops. no disk\\n\");",
      "33:  return 0; // 0 is ok",
      "",
      "[Added Lines]",
      "20:  if (!disk) {",
      "21:   eprintf (\"oops. no disk\\n\");",
      "22:   return 1;",
      "23:  }",
      "24:  const int blocksize = 512; // TODO unhardcode 512",
      "25:  RIOBind *iob = disk->data;",
      "26:  if (bio) {",
      "27:   iob = bio;",
      "28:  }",
      "30:  if (iob->read_at (iob->io, delta+(blocksize*sector), (ut8*)buf, size*blocksize) == -1) {",
      "31:   return 1;",
      "32:  }",
      "33:  return 0;",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "59: void grubfs_free (GrubFS *gf) {",
      "60:  if (gf) {",
      "62:    free (gf->file->device->disk);",
      "64:   free (gf->file);",
      "65:   free (gf);",
      "",
      "[Removed Lines]",
      "61:   if (gf->file && gf->file->device)",
      "",
      "[Added Lines]",
      "61:   if (gf->file && gf->file->device) {",
      "63:   }",
      "",
      "---------------"
    ],
    "sys/rebuild.sh||sys/rebuild.sh": [
      "File: sys/rebuild.sh -> sys/rebuild.sh",
      "--- Hunk 1 ---",
      "[Context before]",
      "72: }",
      "74: case \"$1\" in",
      "76: bin)    RebuildBin ; ;;",
      "77: gdb)    RebuildGdb ; ;;",
      "78: sdb)    RebuildSdb ; ;;",
      "",
      "[Removed Lines]",
      "75: fs)     RebuildFs; ;;",
      "",
      "[Added Lines]",
      "75: grub|fs)RebuildFs; ;;",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "796dd28aaa6b9fa76d99c42c4d5ff8b257cc2191",
      "candidate_info": {
        "commit_hash": "796dd28aaa6b9fa76d99c42c4d5ff8b257cc2191",
        "repo": "radare/radare2",
        "commit_url": "https://github.com/radare/radare2/commit/796dd28aaa6b9fa76d99c42c4d5ff8b257cc2191",
        "files": [
          "shlr/Makefile",
          "shlr/gdb/src/gdbserver/core.c",
          "shlr/grub/fs/ext2.c",
          "shlr/grub/fs/fshelp.c",
          "sys/rebuild.sh"
        ],
        "message": "Fix ext2 buffer overflow in r2_sbu_grub_memmove",
        "before_after_code_files": [
          "shlr/gdb/src/gdbserver/core.c||shlr/gdb/src/gdbserver/core.c",
          "shlr/grub/fs/ext2.c||shlr/grub/fs/ext2.c",
          "shlr/grub/fs/fshelp.c||shlr/grub/fs/fshelp.c",
          "sys/rebuild.sh||sys/rebuild.sh"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "shlr/grub/fs/ext2.c||shlr/grub/fs/ext2.c",
            "shlr/grub/fs/fshelp.c||shlr/grub/fs/fshelp.c",
            "sys/rebuild.sh||sys/rebuild.sh"
          ],
          "candidate": [
            "shlr/grub/fs/ext2.c||shlr/grub/fs/ext2.c",
            "shlr/grub/fs/fshelp.c||shlr/grub/fs/fshelp.c",
            "sys/rebuild.sh||sys/rebuild.sh"
          ]
        }
      },
      "candidate_diff": {
        "shlr/gdb/src/gdbserver/core.c||shlr/gdb/src/gdbserver/core.c": [
          "File: shlr/gdb/src/gdbserver/core.c -> shlr/gdb/src/gdbserver/core.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "182:    return send_msg (g, \"E01\");",
          "183:   }",
          "184:  }",
          "185: }",
          "187: static int _server_handle_qAttached(libgdbr_t *g, int (*cmd_cb) (void*, const char*, char*, size_t), void *core_ptr) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "185:  return -1;",
          "",
          "---------------"
        ],
        "shlr/grub/fs/ext2.c||shlr/grub/fs/ext2.c": [
          "File: shlr/grub/fs/ext2.c -> shlr/grub/fs/ext2.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "432:           return -1;",
          "433:         }",
          "434:     }",
          "436:   if (fileblock < INDIRECT_BLOCKS)",
          "437:     blknr = grub_le_to_cpu32 (inode->blocks.dir_blocks[fileblock]);",
          "439:   else if (fileblock < INDIRECT_BLOCKS + blksz / 4)",
          "440:     {",
          "441:       grub_uint32_t *indir;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "679:         return 0;",
          "681:       if (dirent.namelen != 0)",
          "685: #else",
          "687: #endif",
          "688:    struct grub_fshelp_node *fdiro;",
          "689:    enum grub_fshelp_filetype type = GRUB_FSHELP_UNKNOWN;",
          "691:    grub_ext2_read_file (diro, 0, 0, 0,",
          "692:           fpos + sizeof (struct ext2_dirent),",
          "694:    if (grub_errno)",
          "695:      return 0;",
          "698:    if (! fdiro)",
          "699:      return 0;",
          "701:    fdiro->data = diro->data;",
          "",
          "[Removed Lines]",
          "682:  {",
          "683: #ifndef _MSC_VER",
          "684:    char filename[dirent.namelen + 1];",
          "686:    char * filename = grub_malloc (dirent.namelen + 1);",
          "693:           dirent.namelen, filename);",
          "697:    fdiro = grub_malloc (sizeof (struct grub_fshelp_node));",
          "",
          "[Added Lines]",
          "687: if (!filename) {",
          "688: break;",
          "692:           dirent.namelen, filename);",
          "693:    if (grub_errno) {",
          "695:      return 0;",
          "698:    fdiro = grub_malloc (sizeof (struct grub_fshelp_node));",
          "699:    if (! fdiro) {",
          "701:      return 0;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "721:        grub_ext2_read_inode (diro->data,",
          "722:                                     grub_le_to_cpu32 (dirent.inode),",
          "725:   {",
          "726:     grub_free (fdiro);",
          "727:     return 0;",
          "",
          "[Removed Lines]",
          "723:         &fdiro->inode);",
          "724:        if (grub_errno)",
          "",
          "[Added Lines]",
          "726:         &fdiro->inode);",
          "727:        if (grub_errno) {",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "739:    & FILETYPE_INO_MASK) == FILETYPE_INO_REG)",
          "740:   type = GRUB_FSHELP_REG;",
          "741:      }",
          "743:    if (hook (filename, type, fdiro, closure))",
          "744:      return 1;",
          "745:  }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "746:    if (hook (filename, type, fdiro, closure)) {",
          "748:      return 1;",
          "749:           }",
          "",
          "---------------"
        ],
        "shlr/grub/fs/fshelp.c||shlr/grub/fs/fshelp.c": [
          "File: shlr/grub/fs/fshelp.c -> shlr/grub/fs/fshelp.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "287:   if (pos + len > filesize)",
          "288:     len = filesize - pos;",
          "290:   blockcnt = ((len + pos) + blocksize - 1) >>",
          "291:     (log2blocksize + GRUB_DISK_SECTOR_BITS);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "290:   if (len < 1 || len == 0xffffffff) {",
          "291:     return -1;",
          "292:   }",
          "",
          "---------------"
        ],
        "sys/rebuild.sh||sys/rebuild.sh": [
          "File: sys/rebuild.sh -> sys/rebuild.sh",
          "--- Hunk 1 ---",
          "[Context before]",
          "55:  Rebuild libr/util",
          "56: }",
          "58: RebuildBin() {",
          "59:  Rebuild libr/bin",
          "60:  Rebuild libr/core",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "58: RebuildFs() {",
          "59:  Rebuild shlr/grub",
          "60:  Rebuild libr/fs",
          "61: }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "67: }",
          "69: case \"$1\" in",
          "70: bin)    RebuildBin ; ;;",
          "71: gdb)    RebuildGdb ; ;;",
          "72: sdb)    RebuildSdb ; ;;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "75: fs)     RebuildFs; ;;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "5fc5137c70499d8e5ebf8da85736ef3ef6c492e1",
      "candidate_info": {
        "commit_hash": "5fc5137c70499d8e5ebf8da85736ef3ef6c492e1",
        "repo": "radare/radare2",
        "commit_url": "https://github.com/radare/radare2/commit/5fc5137c70499d8e5ebf8da85736ef3ef6c492e1",
        "files": [
          "binr/radare2/radare2.c",
          "libr/bin/p/bin_fs.c",
          "libr/core/cmd_mount.c",
          "libr/fs/fs.c",
          "libr/fs/types.h"
        ],
        "message": "Autodetect and mount ISO9660 partitions",
        "before_after_code_files": [
          "binr/radare2/radare2.c||binr/radare2/radare2.c",
          "libr/bin/p/bin_fs.c||libr/bin/p/bin_fs.c",
          "libr/core/cmd_mount.c||libr/core/cmd_mount.c",
          "libr/fs/fs.c||libr/fs/fs.c",
          "libr/fs/types.h||libr/fs/types.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "libr/core/cmd_mount.c||libr/core/cmd_mount.c"
          ],
          "candidate": [
            "libr/core/cmd_mount.c||libr/core/cmd_mount.c"
          ]
        }
      },
      "candidate_diff": {
        "binr/radare2/radare2.c||binr/radare2/radare2.c": [
          "File: binr/radare2/radare2.c -> binr/radare2/radare2.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1102:    return 1;",
          "1103:   }",
          "1104:   if (r.bin->cur && r.bin->cur->o && r.bin->cur->o->info && r.bin->cur->o->info->rclass && !strcmp (\"fs\", r.bin->cur->o->info->rclass)) {",
          "1106:   }",
          "1107:   iod = r.io ? r_io_desc_get (r.io, fh->fd) : NULL;",
          "1108: #if USE_THREADS",
          "",
          "[Removed Lines]",
          "1105:    r_core_cmd0 (&r, \"m /root @ 0\");",
          "",
          "[Added Lines]",
          "1105:    const char *fstype = r.bin->cur->o->info->bclass;",
          "1106:    r_core_cmdf (&r, \"m /root %s @ 0\", fstype);",
          "",
          "---------------"
        ],
        "libr/bin/p/bin_fs.c||libr/bin/p/bin_fs.c": [
          "File: libr/bin/p/bin_fs.c -> libr/bin/p/bin_fs.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "16:   len = R_MIN (f->buflen, sizeof (fs_lbuf));",
          "17:   memset (fs_lbuf, 0, sizeof (fs_lbuf));",
          "20:   memcpy (fs_lbuf, buf + f->bufoff, len);",
          "23:    int min = R_MIN (f->buflen, sizeof (fs_lbuf));",
          "24:    if (!memcmp (fs_lbuf, f->buf, min)) {",
          "25:     ret = true;",
          "26:     len = R_MIN (f->bytelen, sizeof (fs_lbuf));",
          "29:     memcpy (fs_lbuf, buf + f->byteoff, len);",
          "32:      if (fs_lbuf[j] != f->byte) {",
          "33:       ret = false;",
          "34:       break;",
          "",
          "[Removed Lines]",
          "19:   if (f->bufoff + len > length) break;",
          "22:   if ((f->buflen > 0) && (len >= f->buflen)) {",
          "28:     if (f->byteoff + len > length) break;",
          "31:     for (j = 0; j < f->bytelen; j++) {",
          "",
          "[Added Lines]",
          "18:   if (f->bufoff + len > length) {",
          "19:    break;",
          "20:   }",
          "22:   if ((f->buflen > 0) && len >= f->buflen) {",
          "27:     if (f->byteoff + len > length) {",
          "28:      break;",
          "29:     }",
          "32:     for (j = 0; j < len; j++) {",
          "",
          "---------------"
        ],
        "libr/core/cmd_mount.c||libr/core/cmd_mount.c": [
          "File: libr/core/cmd_mount.c -> libr/core/cmd_mount.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "77:   } else {",
          "78:    if (!(ptr = r_fs_name (core->fs, core->offset))) {",
          "79:     eprintf (\"Unknown filesystem type\\n\");",
          "81:     eprintf (\"Cannot mount %s\\n\", input);",
          "82:    }",
          "83:    free (ptr);",
          "",
          "[Removed Lines]",
          "80:    } else if (!r_fs_mount (core->fs, ptr, input, core->offset)) {",
          "",
          "[Added Lines]",
          "80:    }",
          "81:    if (!r_fs_mount (core->fs, ptr, input, core->offset)) {",
          "",
          "---------------"
        ],
        "libr/fs/fs.c||libr/fs/fs.c": [
          "File: libr/fs/fs.c -> libr/fs/fs.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "109:   eprintf (\"r_fs_mount: invalid mountpoint %s\\n\", path);",
          "110:   return NULL;",
          "111:  }",
          "114:  }",
          "115:  if (!(p = r_fs_plugin_get (fs, fstype))) {",
          "",
          "[Removed Lines]",
          "112:  if (!fstype) {",
          "113:   fstype = r_fs_name(fs, delta);",
          "",
          "[Added Lines]",
          "112:  if (!fstype || !*fstype) {",
          "113:   fstype = r_fs_name (fs, delta);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "645:    ret = true;",
          "646:    len = R_MIN (f->bytelen, sizeof (buf));",
          "647:    fs->iob.read_at (fs->iob.io, offset + f->byteoff, buf, len);",
          "649:     if (buf[j] != f->byte) {",
          "650:      ret = false;",
          "651:      break;",
          "",
          "[Removed Lines]",
          "648:    for (j = 0; j < f->bytelen; j++) {",
          "",
          "[Added Lines]",
          "649:    for (j = 0; j < len; j++) {",
          "",
          "---------------"
        ],
        "libr/fs/types.h||libr/fs/types.h": [
          "File: libr/fs/types.h -> libr/fs/types.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "15:  { \"fat\", 0x52, \"FAT32\", 5, 0, 0, 0 },",
          "16:  { \"ext2\", 0x438, \"\\x53\\xef\", 2, 0, 0, 0 },",
          "17:  { \"btrfs\", 0x10040, \"_BHRfS_M\", 8, 0, 0, 0x0 },",
          "18:  { NULL }",
          "19: };",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "18:  { \"iso9660\", 0x8000, \"\\x01\" \"CD0\", 4, 0, 0, 0x8000 },",
          "",
          "---------------"
        ]
      }
    }
  ]
}
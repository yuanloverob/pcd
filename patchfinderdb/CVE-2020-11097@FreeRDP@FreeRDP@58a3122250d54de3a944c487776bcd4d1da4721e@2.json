{
  "cve_id": "CVE-2020-11097",
  "cve_desc": "In FreeRDP before version 2.1.2, an out of bounds read occurs resulting in accessing a memory location that is outside of the boundaries of the static array PRIMARY_DRAWING_ORDER_FIELD_BYTES. This is fixed in version 2.1.2.",
  "repo": "FreeRDP/FreeRDP",
  "patch_hash": "58a3122250d54de3a944c487776bcd4d1da4721e",
  "patch_info": {
    "commit_hash": "58a3122250d54de3a944c487776bcd4d1da4721e",
    "repo": "FreeRDP/FreeRDP",
    "commit_url": "https://github.com/FreeRDP/FreeRDP/commit/58a3122250d54de3a944c487776bcd4d1da4721e",
    "files": [
      "winpr/libwinpr/sspi/NTLM/ntlm_av_pairs.c"
    ],
    "message": "Fixed OOB read in ntlm_av_pair_get\n\nCVE-2020-11097 thanks to @antonio-morales for finding this.",
    "before_after_code_files": [
      "winpr/libwinpr/sspi/NTLM/ntlm_av_pairs.c||winpr/libwinpr/sspi/NTLM/ntlm_av_pairs.c"
    ]
  },
  "patch_diff": {
    "winpr/libwinpr/sspi/NTLM/ntlm_av_pairs.c||winpr/libwinpr/sspi/NTLM/ntlm_av_pairs.c": [
      "File: winpr/libwinpr/sspi/NTLM/ntlm_av_pairs.c -> winpr/libwinpr/sspi/NTLM/ntlm_av_pairs.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "39: #include \"../../log.h\"",
      "40: #define TAG WINPR_TAG(\"sspi.NTLM\")",
      "49: static NTLM_AV_PAIR* ntlm_av_pair_next(NTLM_AV_PAIR* pAvPairList, size_t* pcbAvPairList);",
      "51: static INLINE void ntlm_av_pair_set_id(NTLM_AV_PAIR* pAvPair, UINT16 id)",
      "",
      "[Removed Lines]",
      "42: static const char* const AV_PAIR_STRINGS[] = {",
      "43:  \"MsvAvEOL\",           \"MsvAvNbComputerName\", \"MsvAvNbDomainName\", \"MsvAvDnsComputerName\",",
      "44:  \"MsvAvDnsDomainName\", \"MsvAvDnsTreeName\",    \"MsvAvFlags\",        \"MsvAvTimestamp\",",
      "45:  \"MsvAvRestrictions\",  \"MsvAvTargetName\",     \"MsvChannelBindings\"",
      "46: };",
      "48: static BOOL ntlm_av_pair_check(NTLM_AV_PAIR* pAvPair, size_t cbAvPair);",
      "",
      "[Added Lines]",
      "42: static BOOL ntlm_av_pair_get_next_offset(const NTLM_AV_PAIR* pAvPair, size_t size, size_t* pOffset);",
      "44: static BOOL ntlm_av_pair_check_data(const NTLM_AV_PAIR* pAvPair, size_t cbAvPair, size_t size)",
      "45: {",
      "46:  size_t offset;",
      "47:  if (!pAvPair || cbAvPair < sizeof(NTLM_AV_PAIR) + size)",
      "48:   return FALSE;",
      "49:  if (!ntlm_av_pair_get_next_offset(pAvPair, cbAvPair, &offset))",
      "50:   return FALSE;",
      "51:  return cbAvPair >= offset;",
      "52: }",
      "54: static const char* get_av_pair_string(UINT16 pair)",
      "55: {",
      "56:  switch (pair)",
      "57:  {",
      "58:   case MsvAvEOL:",
      "59:    return \"MsvAvEOL\";",
      "60:   case MsvAvNbComputerName:",
      "61:    return \"MsvAvNbComputerName\";",
      "62:   case MsvAvNbDomainName:",
      "63:    return \"MsvAvNbDomainName\";",
      "64:   case MsvAvDnsComputerName:",
      "65:    return \"MsvAvDnsComputerName\";",
      "66:   case MsvAvDnsDomainName:",
      "67:    return \"MsvAvDnsDomainName\";",
      "68:   case MsvAvDnsTreeName:",
      "69:    return \"MsvAvDnsTreeName\";",
      "70:   case MsvAvFlags:",
      "71:    return \"MsvAvFlags\";",
      "72:   case MsvAvTimestamp:",
      "73:    return \"MsvAvTimestamp\";",
      "74:   case MsvAvSingleHost:",
      "75:    return \"MsvAvSingleHost\";",
      "76:   case MsvAvTargetName:",
      "77:    return \"MsvAvTargetName\";",
      "78:   case MsvChannelBindings:",
      "79:    return \"MsvChannelBindings\";",
      "80:   default:",
      "81:    return \"UNKNOWN\";",
      "82:  }",
      "83: }",
      "85: static BOOL ntlm_av_pair_check(const NTLM_AV_PAIR* pAvPair, size_t cbAvPair);",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "70:  return TRUE;",
      "71: }",
      "74: {",
      "75:  UINT16 AvId;",
      "77:  Data_Read_UINT16(&pAvPair->AvId, AvId);",
      "80: }",
      "82: ULONG ntlm_av_pair_list_length(NTLM_AV_PAIR* pAvPairList, size_t cbAvPairList)",
      "",
      "[Removed Lines]",
      "73: static INLINE UINT16 ntlm_av_pair_get_id(const NTLM_AV_PAIR* pAvPair)",
      "79:  return AvId;",
      "",
      "[Added Lines]",
      "110: static INLINE BOOL ntlm_av_pair_get_id(const NTLM_AV_PAIR* pAvPair, size_t size, UINT16* pair)",
      "113:  if (!pAvPair || !pair)",
      "114:   return FALSE;",
      "116:  if (size < sizeof(NTLM_AV_PAIR))",
      "117:   return FALSE;",
      "122:  return TRUE;",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "91:  return ((PBYTE)pAvPair - (PBYTE)pAvPairList) + sizeof(NTLM_AV_PAIR);",
      "92: }",
      "95: {",
      "96:  UINT16 AvLen;",
      "98:  Data_Read_UINT16(&pAvPair->AvLen, AvLen);",
      "101: }",
      "103: void ntlm_print_av_pair_list(NTLM_AV_PAIR* pAvPairList, size_t cbAvPairList)",
      "104: {",
      "105:  size_t cbAvPair = cbAvPairList;",
      "106:  NTLM_AV_PAIR* pAvPair = pAvPairList;",
      "",
      "[Removed Lines]",
      "94: static INLINE SIZE_T ntlm_av_pair_get_len(const NTLM_AV_PAIR* pAvPair)",
      "100:  return AvLen;",
      "",
      "[Added Lines]",
      "137: static INLINE BOOL ntlm_av_pair_get_len(const NTLM_AV_PAIR* pAvPair, size_t size, size_t* pAvLen)",
      "140:  if (!pAvPair)",
      "141:   return FALSE;",
      "143:  if (size < sizeof(NTLM_AV_PAIR))",
      "144:   return FALSE;",
      "149:  return TRUE;",
      "154:  UINT16 pair;",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "111:  WLog_INFO(TAG, \"AV_PAIRs =\");",
      "114:  {",
      "121:   pAvPair = ntlm_av_pair_next(pAvPair, &cbAvPair);",
      "122:  }",
      "",
      "[Removed Lines]",
      "113:  while (pAvPair && ntlm_av_pair_get_id(pAvPair) != MsvAvEOL)",
      "115:   WLog_INFO(TAG, \"\\t%s AvId: %\" PRIu16 \" AvLen: %\" PRIu16 \"\",",
      "116:             AV_PAIR_STRINGS[ntlm_av_pair_get_id(pAvPair)], ntlm_av_pair_get_id(pAvPair),",
      "117:             ntlm_av_pair_get_len(pAvPair));",
      "118:   winpr_HexDump(TAG, WLOG_INFO, ntlm_av_pair_get_value_pointer(pAvPair),",
      "119:                 ntlm_av_pair_get_len(pAvPair));",
      "",
      "[Added Lines]",
      "163:  while (pAvPair && ntlm_av_pair_get_id(pAvPair, cbAvPair, &pair) && (pair != MsvAvEOL))",
      "165:   size_t cbLen = 0;",
      "166:   ntlm_av_pair_get_len(pAvPair, cbAvPair, &cbLen);",
      "168:   WLog_INFO(TAG, \"\\t%s AvId: %\" PRIu16 \" AvLen: %\" PRIu16 \"\", get_av_pair_string(pair), pair);",
      "169:   winpr_HexDump(TAG, WLOG_INFO, ntlm_av_pair_get_value_pointer(pAvPair), cbLen);",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "133:  return (PBYTE)pAvPair + sizeof(NTLM_AV_PAIR);",
      "134: }",
      "137: {",
      "139: }",
      "142: {",
      "146: }",
      "148: static NTLM_AV_PAIR* ntlm_av_pair_next(NTLM_AV_PAIR* pAvPair, size_t* pcbAvPair)",
      "",
      "[Removed Lines]",
      "136: static size_t ntlm_av_pair_get_next_offset(NTLM_AV_PAIR* pAvPair)",
      "138:  return ntlm_av_pair_get_len(pAvPair) + sizeof(NTLM_AV_PAIR);",
      "141: static BOOL ntlm_av_pair_check(NTLM_AV_PAIR* pAvPair, size_t cbAvPair)",
      "143:  if (!pAvPair || cbAvPair < sizeof(NTLM_AV_PAIR))",
      "144:   return FALSE;",
      "145:  return cbAvPair >= ntlm_av_pair_get_next_offset(pAvPair);",
      "",
      "[Added Lines]",
      "186: static BOOL ntlm_av_pair_get_next_offset(const NTLM_AV_PAIR* pAvPair, size_t size, size_t* pOffset)",
      "188:  size_t avLen;",
      "189:  if (!pOffset)",
      "190:   return FALSE;",
      "192:  if (!ntlm_av_pair_get_len(pAvPair, size, &avLen))",
      "193:   return FALSE;",
      "195:  return TRUE;",
      "198: static BOOL ntlm_av_pair_check(const NTLM_AV_PAIR* pAvPair, size_t cbAvPair)",
      "200:  return ntlm_av_pair_check_data(pAvPair, cbAvPair, 0);",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "154:  if (!ntlm_av_pair_check(pAvPair, *pcbAvPair))",
      "155:   return NULL;",
      "159:  return (NTLM_AV_PAIR*)((PBYTE)pAvPair + offset);",
      "160: }",
      "",
      "[Removed Lines]",
      "157:  offset = ntlm_av_pair_get_next_offset(pAvPair);",
      "",
      "[Added Lines]",
      "212:  if (!ntlm_av_pair_get_next_offset(pAvPair, *pcbAvPair, &offset))",
      "213:   return NULL;",
      "",
      "---------------",
      "--- Hunk 7 ---",
      "[Context before]",
      "162: NTLM_AV_PAIR* ntlm_av_pair_get(NTLM_AV_PAIR* pAvPairList, size_t cbAvPairList, NTLM_AV_ID AvId,",
      "163:                                size_t* pcbAvPairListRemaining)",
      "164: {",
      "165:  size_t cbAvPair = cbAvPairList;",
      "166:  NTLM_AV_PAIR* pAvPair = pAvPairList;",
      "168:  if (!ntlm_av_pair_check(pAvPair, cbAvPair))",
      "169:   pAvPair = NULL;",
      "172:  {",
      "175:   if (id == AvId)",
      "176:    break;",
      "177:   if (id == MsvAvEOL)",
      "",
      "[Removed Lines]",
      "171:  while (pAvPair)",
      "173:   UINT16 id = ntlm_av_pair_get_id(pAvPair);",
      "",
      "[Added Lines]",
      "222:  UINT16 id;",
      "229:  while (pAvPair && ntlm_av_pair_get_id(pAvPair, cbAvPair, &id))",
      "",
      "---------------",
      "--- Hunk 8 ---",
      "[Context before]",
      "218: static BOOL ntlm_av_pair_add_copy(NTLM_AV_PAIR* pAvPairList, size_t cbAvPairList,",
      "219:                                   NTLM_AV_PAIR* pAvPair, size_t cbAvPair)",
      "220: {",
      "221:  if (!ntlm_av_pair_check(pAvPair, cbAvPair))",
      "222:   return FALSE;",
      "226: }",
      "228: static int ntlm_get_target_computer_name(PUNICODE_STRING pName, COMPUTER_NAME_FORMAT type)",
      "",
      "[Removed Lines]",
      "224:  return ntlm_av_pair_add(pAvPairList, cbAvPairList, ntlm_av_pair_get_id(pAvPair),",
      "225:                          ntlm_av_pair_get_value_pointer(pAvPair), ntlm_av_pair_get_len(pAvPair));",
      "",
      "[Added Lines]",
      "277:  UINT16 pair;",
      "278:  size_t avLen;",
      "283:  if (!ntlm_av_pair_get_id(pAvPair, cbAvPair, &pair))",
      "284:   return FALSE;",
      "286:  if (!ntlm_av_pair_get_len(pAvPair, cbAvPair, &avLen))",
      "287:   return FALSE;",
      "289:  return ntlm_av_pair_add(pAvPairList, cbAvPairList, pair,",
      "290:                          ntlm_av_pair_get_value_pointer(pAvPair), avLen);",
      "",
      "---------------",
      "--- Hunk 9 ---",
      "[Context before]",
      "501:  if (AvNbDomainName)",
      "502:  {",
      "505:  }",
      "507:  if (AvNbComputerName)",
      "508:  {",
      "511:  }",
      "513:  if (AvDnsDomainName)",
      "514:  {",
      "517:  }",
      "519:  if (AvDnsComputerName)",
      "520:  {",
      "523:  }",
      "525:  if (AvDnsTreeName)",
      "526:  {",
      "529:  }",
      "",
      "[Removed Lines]",
      "504:   AvPairsValueLength += ntlm_av_pair_get_len(AvNbDomainName);",
      "510:   AvPairsValueLength += ntlm_av_pair_get_len(AvNbComputerName);",
      "516:   AvPairsValueLength += ntlm_av_pair_get_len(AvDnsDomainName);",
      "522:   AvPairsValueLength += ntlm_av_pair_get_len(AvDnsComputerName);",
      "528:   AvPairsValueLength += ntlm_av_pair_get_len(AvDnsTreeName);",
      "",
      "[Added Lines]",
      "568:   size_t avLen;",
      "569:   if (!ntlm_av_pair_get_len(AvNbDomainName, cbAvNbDomainName, &avLen))",
      "570:    goto fail;",
      "572:   AvPairsValueLength += avLen;",
      "577:   size_t avLen;",
      "578:   if (!ntlm_av_pair_get_len(AvNbComputerName, cbAvNbComputerName, &avLen))",
      "579:    goto fail;",
      "581:   AvPairsValueLength += avLen;",
      "586:   size_t avLen;",
      "587:   if (!ntlm_av_pair_get_len(AvDnsDomainName, cbAvDnsDomainName, &avLen))",
      "588:    goto fail;",
      "590:   AvPairsValueLength += avLen;",
      "595:   size_t avLen;",
      "596:   if (!ntlm_av_pair_get_len(AvDnsComputerName, cbAvDnsComputerName, &avLen))",
      "597:    goto fail;",
      "599:   AvPairsValueLength += avLen;",
      "604:   size_t avLen;",
      "605:   if (!ntlm_av_pair_get_len(AvDnsTreeName, cbAvDnsTreeName, &avLen))",
      "606:    goto fail;",
      "608:   AvPairsValueLength += avLen;",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "0a98c450c58ec150e44781c89aa6f8e7e0f571f5",
      "candidate_info": {
        "commit_hash": "0a98c450c58ec150e44781c89aa6f8e7e0f571f5",
        "repo": "FreeRDP/FreeRDP",
        "commit_url": "https://github.com/FreeRDP/FreeRDP/commit/0a98c450c58ec150e44781c89aa6f8e7e0f571f5",
        "files": [
          "libfreerdp/codec/include/bitmap.c"
        ],
        "message": "Fixed out of bound read in RLEDECOMPRESS\n\nCVE-2020-4033 thanks to @antonio-morales for finding this.",
        "before_after_code_files": [
          "libfreerdp/codec/include/bitmap.c||libfreerdp/codec/include/bitmap.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/FreeRDP/FreeRDP/pull/6295"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "libfreerdp/codec/include/bitmap.c||libfreerdp/codec/include/bitmap.c": [
          "File: libfreerdp/codec/include/bitmap.c -> libfreerdp/codec/include/bitmap.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "202:     if (code == LITE_SET_FG_FG_RUN || code == MEGA_MEGA_SET_FG_RUN)",
          "203:     {",
          "204:      SRCREADPIXEL(fgPel, pbSrc);",
          "205:      SRCNEXTPIXEL(pbSrc);",
          "206:     }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "204:      if (pbSrc >= pbEnd)",
          "205:       return FALSE;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "231:    case MEGA_MEGA_DITHERED_RUN:",
          "232:     runLength = ExtractRunLength(code, pbSrc, &advance);",
          "233:     pbSrc = pbSrc + advance;",
          "234:     SRCREADPIXEL(pixelA, pbSrc);",
          "235:     SRCNEXTPIXEL(pbSrc);",
          "236:     SRCREADPIXEL(pixelB, pbSrc);",
          "237:     SRCNEXTPIXEL(pbSrc);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "236:     if (pbSrc >= pbEnd)",
          "237:      return FALSE;",
          "240:     if (pbSrc >= pbEnd)",
          "241:      return FALSE;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "252:    case MEGA_MEGA_COLOR_RUN:",
          "253:     runLength = ExtractRunLength(code, pbSrc, &advance);",
          "254:     pbSrc = pbSrc + advance;",
          "255:     SRCREADPIXEL(pixelA, pbSrc);",
          "256:     SRCNEXTPIXEL(pbSrc);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "261:     if (pbSrc >= pbEnd)",
          "262:      return FALSE;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "272:     runLength = ExtractRunLength(code, pbSrc, &advance);",
          "273:     pbSrc = pbSrc + advance;",
          "275:     if (code == LITE_SET_FG_FGBG_IMAGE || code == MEGA_MEGA_SET_FGBG_IMAGE)",
          "276:     {",
          "277:      SRCREADPIXEL(fgPel, pbSrc);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "283:     if (pbSrc >= pbEnd)",
          "284:      return FALSE;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "338:      return FALSE;",
          "340:     UNROLL(runLength, {",
          "341:      SRCREADPIXEL(temp, pbSrc);",
          "342:      SRCNEXTPIXEL(pbSrc);",
          "343:      DESTWRITEPIXEL(pbDest, temp);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "351:      if (pbSrc >= pbEnd)",
          "352:       return FALSE;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "3ac7bb5d6a743b19e8686410d5ec6dcf74869ebe",
      "candidate_info": {
        "commit_hash": "3ac7bb5d6a743b19e8686410d5ec6dcf74869ebe",
        "repo": "FreeRDP/FreeRDP",
        "commit_url": "https://github.com/FreeRDP/FreeRDP/commit/3ac7bb5d6a743b19e8686410d5ec6dcf74869ebe",
        "files": [
          "libfreerdp/utils/pcap.c"
        ],
        "message": "Fixed pcap cleanup",
        "before_after_code_files": [
          "libfreerdp/utils/pcap.c||libfreerdp/utils/pcap.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/FreeRDP/FreeRDP/pull/6295"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "libfreerdp/utils/pcap.c||libfreerdp/utils/pcap.c": [
          "File: libfreerdp/utils/pcap.c -> libfreerdp/utils/pcap.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "170: {",
          "171:  rdpPcap* pcap;",
          "181:  pcap = (rdpPcap*)calloc(1, sizeof(rdpPcap));",
          "182:  if (!pcap)",
          "185:  pcap->name = name;",
          "186:  pcap->write = write;",
          "187:  pcap->record_count = 0;",
          "190:  if (write)",
          "191:  {",
          "",
          "[Removed Lines]",
          "173:  FILE* pcap_fp = fopen(name, write ? \"w+b\" : \"rb\");",
          "175:  if (pcap_fp == NULL)",
          "176:  {",
          "177:   WLog_ERR(TAG, \"opening pcap dump\");",
          "178:   return NULL;",
          "179:  }",
          "183:   goto fail_close;",
          "188:  pcap->fp = pcap_fp;",
          "",
          "[Added Lines]",
          "175:   goto fail;",
          "180:  pcap->fp = fopen(name, write ? \"w+b\" : \"rb\");",
          "182:  if (pcap->fp == NULL)",
          "183:   goto fail;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "211:  return pcap;",
          "213: fail:",
          "217:  return NULL;",
          "218: }",
          "",
          "[Removed Lines]",
          "214:  free(pcap);",
          "215: fail_close:",
          "216:  fclose(pcap_fp);",
          "",
          "[Added Lines]",
          "209:  pcap_close(pcap);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "232: void pcap_close(rdpPcap* pcap)",
          "233: {",
          "234:  pcap_flush(pcap);",
          "236:  if (pcap->fp != NULL)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "227:  if (!pcap)",
          "228:   return;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "1c6a6923f87dcfb295c508963f21bebbbc4292ae",
      "candidate_info": {
        "commit_hash": "1c6a6923f87dcfb295c508963f21bebbbc4292ae",
        "repo": "FreeRDP/FreeRDP",
        "commit_url": "https://github.com/FreeRDP/FreeRDP/commit/1c6a6923f87dcfb295c508963f21bebbbc4292ae",
        "files": [
          "channels/rdpdr/client/rdpdr_main.c"
        ],
        "message": "Fixed broken const variable.",
        "before_after_code_files": [
          "channels/rdpdr/client/rdpdr_main.c||channels/rdpdr/client/rdpdr_main.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/FreeRDP/FreeRDP/pull/6295"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "channels/rdpdr/client/rdpdr_main.c||channels/rdpdr/client/rdpdr_main.c": [
          "File: channels/rdpdr/client/rdpdr_main.c -> channels/rdpdr/client/rdpdr_main.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "598:  size_t x;",
          "599:  char buffer[MAX_PATH];",
          "600:  uid_t uid = getuid();",
          "603:  if (getlogin_r(uname, sizeof(uname)) != 0)",
          "604:   return FALSE;",
          "",
          "[Removed Lines]",
          "601:  const char uname[MAX_PATH] = { 0 };",
          "",
          "[Added Lines]",
          "601:  char uname[MAX_PATH] = { 0 };",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "c0fd449ec0870b050d350d6d844b1ea6dad4bc7d",
      "candidate_info": {
        "commit_hash": "c0fd449ec0870b050d350d6d844b1ea6dad4bc7d",
        "repo": "FreeRDP/FreeRDP",
        "commit_url": "https://github.com/FreeRDP/FreeRDP/commit/c0fd449ec0870b050d350d6d844b1ea6dad4bc7d",
        "files": [
          "libfreerdp/cache/glyph.c"
        ],
        "message": "Fixed Out-of-bound read in glyph_cache_put\n\nCVE-2020-11098 thanks to @antonio-morales for finding this.",
        "before_after_code_files": [
          "libfreerdp/cache/glyph.c||libfreerdp/cache/glyph.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/FreeRDP/FreeRDP/pull/6295"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "libfreerdp/cache/glyph.c||libfreerdp/cache/glyph.c": [
          "File: libfreerdp/cache/glyph.c -> libfreerdp/cache/glyph.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "579:   return FALSE;",
          "580:  }",
          "583:  {",
          "584:   WLog_ERR(TAG, \"invalid glyph cache index: %\" PRIu32 \" in cache id: %\" PRIu32 \"\", index, id);",
          "585:   return FALSE;",
          "",
          "[Removed Lines]",
          "582:  if (index > glyphCache->glyphCache[id].number)",
          "",
          "[Added Lines]",
          "582:  if (index >= glyphCache->glyphCache[id].number)",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "a45afe9db77a19e5a177fe1dc3e85119013f9587",
      "candidate_info": {
        "commit_hash": "a45afe9db77a19e5a177fe1dc3e85119013f9587",
        "repo": "FreeRDP/FreeRDP",
        "commit_url": "https://github.com/FreeRDP/FreeRDP/commit/a45afe9db77a19e5a177fe1dc3e85119013f9587",
        "files": [
          "winpr/libwinpr/sysinfo/sysinfo.c"
        ],
        "message": "Replaced gmtime with gmtime_r",
        "before_after_code_files": [
          "winpr/libwinpr/sysinfo/sysinfo.c||winpr/libwinpr/sysinfo/sysinfo.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/FreeRDP/FreeRDP/pull/6295"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "winpr/libwinpr/sysinfo/sysinfo.c||winpr/libwinpr/sysinfo/sysinfo.c": [
          "File: winpr/libwinpr/sysinfo/sysinfo.c -> winpr/libwinpr/sysinfo/sysinfo.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "213: void GetSystemTime(LPSYSTEMTIME lpSystemTime)",
          "214: {",
          "215:  time_t ct = 0;",
          "216:  struct tm* stm = NULL;",
          "217:  WORD wMilliseconds = 0;",
          "218:  ct = time(NULL);",
          "219:  wMilliseconds = (WORD)(GetTickCount() % 1000);",
          "221:  ZeroMemory(lpSystemTime, sizeof(SYSTEMTIME));",
          "223:  if (stm)",
          "",
          "[Removed Lines]",
          "220:  stm = gmtime(&ct);",
          "",
          "[Added Lines]",
          "216:  struct tm tres;",
          "221:  stm = gmtime_r(&ct, &tres);",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2014-4655",
  "cve_desc": "The snd_ctl_elem_add function in sound/core/control.c in the ALSA control implementation in the Linux kernel before 3.15.2 does not properly maintain the user_ctl_count value, which allows local users to cause a denial of service (integer overflow and limit bypass) by leveraging /dev/snd/controlCX access for a large number of SNDRV_CTL_IOCTL_ELEM_REPLACE ioctl calls.",
  "repo": "torvalds/linux",
  "patch_hash": "82262a46627bebb0febcc26664746c25cef08563",
  "patch_info": {
    "commit_hash": "82262a46627bebb0febcc26664746c25cef08563",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/82262a46627bebb0febcc26664746c25cef08563",
    "files": [
      "sound/core/control.c"
    ],
    "message": "ALSA: control: Fix replacing user controls\n\nThere are two issues with the current implementation for replacing user\ncontrols. The first is that the code does not check if the control is actually a\nuser control and neither does it check if the control is owned by the process\nthat tries to remove it. That allows userspace applications to remove arbitrary\ncontrols, which can cause a user after free if a for example a driver does not\nexpect a control to be removed from under its feed.\n\nThe second issue is that on one hand when a control is replaced the\nuser_ctl_count limit is not checked and on the other hand the user_ctl_count is\nincreased (even though the number of user controls does not change). This allows\nuserspace, once the user_ctl_count limit as been reached, to repeatedly replace\na control until user_ctl_count overflows. Once that happens new controls can be\nadded effectively bypassing the user_ctl_count limit.\n\nBoth issues can be fixed by instead of open-coding the removal of the control\nthat is to be replaced to use snd_ctl_remove_user_ctl(). This function does\nproper permission checks as well as decrements user_ctl_count after the control\nhas been removed.\n\nNote that by using snd_ctl_remove_user_ctl() the check which returns -EBUSY at\nbeginning of the function if the control already exists is removed. This is not\na problem though since the check is quite useless, because the lock that is\nprotecting the control list is released between the check and before adding the\nnew control to the list, which means that it is possible that a different\ncontrol with the same settings is added to the list after the check. Luckily\nthere is another check that is done while holding the lock in snd_ctl_add(), so\nwe'll rely on that to make sure that the same control is not added twice.\n\nSigned-off-by: Lars-Peter Clausen <lars@metafoo.de>\nAcked-by: Jaroslav Kysela <perex@perex.cz>\nCc: <stable@vger.kernel.org>\nSigned-off-by: Takashi Iwai <tiwai@suse.de>",
    "before_after_code_files": [
      "sound/core/control.c||sound/core/control.c"
    ]
  },
  "patch_diff": {
    "sound/core/control.c||sound/core/control.c": [
      "File: sound/core/control.c -> sound/core/control.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "1154:  struct user_element *ue;",
      "1155:  int idx, err;",
      "1159:  if (info->count < 1)",
      "1160:   return -EINVAL;",
      "1161:  access = info->access == 0 ? SNDRV_CTL_ELEM_ACCESS_READWRITE :",
      "",
      "[Removed Lines]",
      "1157:  if (!replace && card->user_ctl_count >= MAX_USER_CONTROLS)",
      "1158:   return -ENOMEM;",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "1164:      SNDRV_CTL_ELEM_ACCESS_TLV_READWRITE));",
      "1165:  info->id.numid = 0;",
      "1166:  memset(&kctl, 0, sizeof(kctl));",
      "1178:  }",
      "1182:  memcpy(&kctl.id, &info->id, sizeof(info->id));",
      "1183:  kctl.count = info->owner ? info->owner : 1;",
      "1184:  access |= SNDRV_CTL_ELEM_ACCESS_USER;",
      "",
      "[Removed Lines]",
      "1167:  down_write(&card->controls_rwsem);",
      "1168:  _kctl = snd_ctl_find_id(card, &info->id);",
      "1169:  err = 0;",
      "1170:  if (_kctl) {",
      "1171:   if (replace)",
      "1172:    err = snd_ctl_remove(card, _kctl);",
      "1173:   else",
      "1174:    err = -EBUSY;",
      "1175:  } else {",
      "1176:   if (replace)",
      "1177:    err = -ENOENT;",
      "1179:  up_write(&card->controls_rwsem);",
      "1180:  if (err < 0)",
      "1181:   return err;",
      "",
      "[Added Lines]",
      "1166:  if (replace) {",
      "1167:   err = snd_ctl_remove_user_ctl(file, &info->id);",
      "1168:   if (err)",
      "1169:    return err;",
      "1172:  if (card->user_ctl_count >= MAX_USER_CONTROLS)",
      "1173:   return -ENOMEM;",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "4ed56666b7fc98c750a23b5263350b75e742b534",
      "candidate_info": {
        "commit_hash": "4ed56666b7fc98c750a23b5263350b75e742b534",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/4ed56666b7fc98c750a23b5263350b75e742b534",
        "files": [
          "sound/core/control.c"
        ],
        "message": "ALSA: core: use precomputed table to check userspace control params\n\nThe parameters can be decided in compile time.\n\nThis commit adds precomputed table to reduce calculating time.\n\nSigned-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>\nSigned-off-by: Takashi Iwai <tiwai@suse.de>",
        "before_after_code_files": [
          "sound/core/control.c||sound/core/control.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "sound/core/control.c||sound/core/control.c"
          ],
          "candidate": [
            "sound/core/control.c||sound/core/control.c"
          ]
        }
      },
      "candidate_diff": {
        "sound/core/control.c||sound/core/control.c": [
          "File: sound/core/control.c -> sound/core/control.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1161: static int snd_ctl_elem_add(struct snd_ctl_file *file,",
          "1162:        struct snd_ctl_elem_info *info, int replace)",
          "1163: {",
          "1164:  struct snd_card *card = file->card;",
          "1165:  struct snd_kcontrol kctl, *_kctl;",
          "1166:  unsigned int access;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1165:  static const unsigned int value_sizes[] = {",
          "1166:   [SNDRV_CTL_ELEM_TYPE_BOOLEAN] = sizeof(long),",
          "1167:   [SNDRV_CTL_ELEM_TYPE_INTEGER] = sizeof(long),",
          "1168:   [SNDRV_CTL_ELEM_TYPE_ENUMERATED] = sizeof(unsigned int),",
          "1169:   [SNDRV_CTL_ELEM_TYPE_BYTES] = sizeof(unsigned char),",
          "1170:   [SNDRV_CTL_ELEM_TYPE_IEC958] = sizeof(struct snd_aes_iec958),",
          "1171:   [SNDRV_CTL_ELEM_TYPE_INTEGER64] = sizeof(long long),",
          "1172:  };",
          "1173:  static const unsigned int max_value_counts[] = {",
          "1174:   [SNDRV_CTL_ELEM_TYPE_BOOLEAN] = 128,",
          "1175:   [SNDRV_CTL_ELEM_TYPE_INTEGER] = 128,",
          "1176:   [SNDRV_CTL_ELEM_TYPE_ENUMERATED] = 128,",
          "1177:   [SNDRV_CTL_ELEM_TYPE_BYTES] = 512,",
          "1178:   [SNDRV_CTL_ELEM_TYPE_IEC958] = 1,",
          "1179:   [SNDRV_CTL_ELEM_TYPE_INTEGER64] = 64,",
          "1180:  };",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1168:  struct user_element *ue;",
          "1169:  int idx, err;",
          "1173:  access = info->access == 0 ? SNDRV_CTL_ELEM_ACCESS_READWRITE :",
          "1174:   (info->access & (SNDRV_CTL_ELEM_ACCESS_READWRITE|",
          "1175:      SNDRV_CTL_ELEM_ACCESS_INACTIVE|",
          "",
          "[Removed Lines]",
          "1171:  if (info->count < 1)",
          "1172:   return -EINVAL;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1201:   kctl.tlv.c = snd_ctl_elem_user_tlv;",
          "1202:   access |= SNDRV_CTL_ELEM_ACCESS_TLV_CALLBACK;",
          "1203:  }",
          "1232:   return -EINVAL;",
          "1235:  ue = kzalloc(sizeof(struct user_element) + private_size, GFP_KERNEL);",
          "1236:  if (ue == NULL)",
          "1237:   return -ENOMEM;",
          "",
          "[Removed Lines]",
          "1204:  switch (info->type) {",
          "1205:  case SNDRV_CTL_ELEM_TYPE_BOOLEAN:",
          "1206:  case SNDRV_CTL_ELEM_TYPE_INTEGER:",
          "1207:   private_size = sizeof(long);",
          "1208:   if (info->count > 128)",
          "1209:    return -EINVAL;",
          "1210:   break;",
          "1211:  case SNDRV_CTL_ELEM_TYPE_INTEGER64:",
          "1212:   private_size = sizeof(long long);",
          "1213:   if (info->count > 64)",
          "1214:    return -EINVAL;",
          "1215:   break;",
          "1216:  case SNDRV_CTL_ELEM_TYPE_ENUMERATED:",
          "1217:   private_size = sizeof(unsigned int);",
          "1218:   if (info->count > 128 || info->value.enumerated.items == 0)",
          "1219:    return -EINVAL;",
          "1220:   break;",
          "1221:  case SNDRV_CTL_ELEM_TYPE_BYTES:",
          "1222:   private_size = sizeof(unsigned char);",
          "1223:   if (info->count > 512)",
          "1224:    return -EINVAL;",
          "1225:   break;",
          "1226:  case SNDRV_CTL_ELEM_TYPE_IEC958:",
          "1227:   private_size = sizeof(struct snd_aes_iec958);",
          "1228:   if (info->count != 1)",
          "1229:    return -EINVAL;",
          "1230:   break;",
          "1231:  default:",
          "1233:  }",
          "1234:  private_size *= info->count;",
          "",
          "[Added Lines]",
          "1220:  if (info->type < SNDRV_CTL_ELEM_TYPE_BOOLEAN ||",
          "1221:      info->type > SNDRV_CTL_ELEM_TYPE_INTEGER64)",
          "1223:  if (info->type == SNDRV_CTL_ELEM_TYPE_ENUMERATED &&",
          "1224:      info->value.enumerated.items == 0)",
          "1225:   return -EINVAL;",
          "1226:  if (info->count < 1 ||",
          "1227:      info->count > max_value_counts[info->type])",
          "1228:   return -EINVAL;",
          "1230:  private_size = value_sizes[info->type] * info->count;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "2225e79b9b0370bc179f44756bee809b5e7b4d06",
      "candidate_info": {
        "commit_hash": "2225e79b9b0370bc179f44756bee809b5e7b4d06",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/2225e79b9b0370bc179f44756bee809b5e7b4d06",
        "files": [
          "sound/core/control.c"
        ],
        "message": "ALSA: core: reduce stack usage related to snd_ctl_new()\n\nThe callers of snd_ctl_new() need to have 'struct snd_kcontrol' data,\nand pass the data as template. Then, the function allocates the structure\ndata again and copy from the template. This is a waste of resources.\nEspecially, the callers use large stack for the template.\n\nThis commit removes a need of template for the function, thus, changes\nthe prototype of snd_ctl_new(). Furthermore, this commit changes\nthe code of callers, snd_ctl_new1() and snd_ctl_elem_add() for better\nshape.\n\nSigned-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>\nSigned-off-by: Takashi Iwai <tiwai@suse.de>",
        "before_after_code_files": [
          "sound/core/control.c||sound/core/control.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "sound/core/control.c||sound/core/control.c"
          ],
          "candidate": [
            "sound/core/control.c||sound/core/control.c"
          ]
        }
      },
      "candidate_diff": {
        "sound/core/control.c||sound/core/control.c": [
          "File: sound/core/control.c -> sound/core/control.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "192: EXPORT_SYMBOL(snd_ctl_notify);",
          "206: {",
          "208:  unsigned int idx;",
          "218:   pr_err(\"ALSA: Cannot allocate control instance\\n\");",
          "220:  }",
          "225: }",
          "",
          "[Removed Lines]",
          "204: static struct snd_kcontrol *snd_ctl_new(struct snd_kcontrol *control,",
          "205:      unsigned int access)",
          "207:  struct snd_kcontrol *kctl;",
          "210:  if (snd_BUG_ON(!control || !control->count))",
          "211:   return NULL;",
          "213:  if (control->count > MAX_CONTROL_COUNT)",
          "214:   return NULL;",
          "216:  kctl = kzalloc(sizeof(*kctl) + sizeof(struct snd_kcontrol_volatile) * control->count, GFP_KERNEL);",
          "217:  if (kctl == NULL) {",
          "219:   return NULL;",
          "222:  for (idx = 0; idx < kctl->count; idx++)",
          "223:   kctl->vd[idx].access = access;",
          "224:  return kctl;",
          "",
          "[Added Lines]",
          "207: static int snd_ctl_new(struct snd_kcontrol **kctl, unsigned int count,",
          "208:          unsigned int access, struct snd_ctl_file *file)",
          "210:  unsigned int size;",
          "213:  if (count == 0 || count > MAX_CONTROL_COUNT)",
          "214:   return -EINVAL;",
          "216:  size  = sizeof(struct snd_kcontrol);",
          "217:  size += sizeof(struct snd_kcontrol_volatile) * count;",
          "220:  if (*kctl == NULL) {",
          "222:   return -ENOMEM;",
          "225:  for (idx = 0; idx < count; idx++) {",
          "226:   (*kctl)->vd[idx].access = access;",
          "227:   (*kctl)->vd[idx].owner = file;",
          "228:  }",
          "229:  (*kctl)->count = count;",
          "231:  return 0;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "238: struct snd_kcontrol *snd_ctl_new1(const struct snd_kcontrol_new *ncontrol,",
          "239:       void *private_data)",
          "240: {",
          "242:  unsigned int access;",
          "244:  if (snd_BUG_ON(!ncontrol || !ncontrol->info))",
          "245:   return NULL;",
          "250:  if (ncontrol->name) {",
          "253:    pr_warn(\"ALSA: Control name '%s' truncated to '%s'\\n\",",
          "255:  }",
          "272: }",
          "273: EXPORT_SYMBOL(snd_ctl_new1);",
          "",
          "[Removed Lines]",
          "241:  struct snd_kcontrol kctl;",
          "246:  memset(&kctl, 0, sizeof(kctl));",
          "247:  kctl.id.iface = ncontrol->iface;",
          "248:  kctl.id.device = ncontrol->device;",
          "249:  kctl.id.subdevice = ncontrol->subdevice;",
          "251:   strlcpy(kctl.id.name, ncontrol->name, sizeof(kctl.id.name));",
          "252:   if (strcmp(ncontrol->name, kctl.id.name) != 0)",
          "254:     ncontrol->name, kctl.id.name);",
          "256:  kctl.id.index = ncontrol->index;",
          "257:  kctl.count = ncontrol->count ? ncontrol->count : 1;",
          "258:  access = ncontrol->access == 0 ? SNDRV_CTL_ELEM_ACCESS_READWRITE :",
          "259:    (ncontrol->access & (SNDRV_CTL_ELEM_ACCESS_READWRITE|",
          "260:           SNDRV_CTL_ELEM_ACCESS_VOLATILE|",
          "261:           SNDRV_CTL_ELEM_ACCESS_INACTIVE|",
          "262:           SNDRV_CTL_ELEM_ACCESS_TLV_READWRITE|",
          "263:           SNDRV_CTL_ELEM_ACCESS_TLV_COMMAND|",
          "264:           SNDRV_CTL_ELEM_ACCESS_TLV_CALLBACK));",
          "265:  kctl.info = ncontrol->info;",
          "266:  kctl.get = ncontrol->get;",
          "267:  kctl.put = ncontrol->put;",
          "268:  kctl.tlv.p = ncontrol->tlv.p;",
          "269:  kctl.private_value = ncontrol->private_value;",
          "270:  kctl.private_data = private_data;",
          "271:  return snd_ctl_new(&kctl, access);",
          "",
          "[Added Lines]",
          "248:  struct snd_kcontrol *kctl;",
          "249:  unsigned int count;",
          "251:  int err;",
          "256:  count = ncontrol->count;",
          "257:  if (count == 0)",
          "258:   count = 1;",
          "260:  access = ncontrol->access;",
          "261:  if (access == 0)",
          "262:   access = SNDRV_CTL_ELEM_ACCESS_READWRITE;",
          "263:  access &= (SNDRV_CTL_ELEM_ACCESS_READWRITE |",
          "264:      SNDRV_CTL_ELEM_ACCESS_VOLATILE |",
          "265:      SNDRV_CTL_ELEM_ACCESS_INACTIVE |",
          "266:      SNDRV_CTL_ELEM_ACCESS_TLV_READWRITE |",
          "267:      SNDRV_CTL_ELEM_ACCESS_TLV_COMMAND |",
          "268:      SNDRV_CTL_ELEM_ACCESS_TLV_CALLBACK);",
          "270:  err = snd_ctl_new(&kctl, count, access, NULL);",
          "271:  if (err < 0)",
          "272:   return NULL;",
          "275:  kctl->id.iface = ncontrol->iface;",
          "276:  kctl->id.device = ncontrol->device;",
          "277:  kctl->id.subdevice = ncontrol->subdevice;",
          "279:   strlcpy(kctl->id.name, ncontrol->name, sizeof(kctl->id.name));",
          "280:   if (strcmp(ncontrol->name, kctl->id.name) != 0)",
          "282:     ncontrol->name, kctl->id.name);",
          "284:  kctl->id.index = ncontrol->index;",
          "286:  kctl->info = ncontrol->info;",
          "287:  kctl->get = ncontrol->get;",
          "288:  kctl->put = ncontrol->put;",
          "289:  kctl->tlv.p = ncontrol->tlv.p;",
          "291:  kctl->private_value = ncontrol->private_value;",
          "292:  kctl->private_data = private_data;",
          "294:  return kctl;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1179:   [SNDRV_CTL_ELEM_TYPE_INTEGER64] = 64,",
          "1180:  };",
          "1181:  struct snd_card *card = file->card;",
          "1183:  unsigned int access;",
          "1184:  long private_size;",
          "1185:  struct user_element *ue;",
          "1195:  if (replace) {",
          "1196:   err = snd_ctl_remove_user_ctl(file, &info->id);",
          "1197:   if (err)",
          "1198:    return err;",
          "1199:  }",
          "1202:   return -ENOMEM;",
          "1217:   access |= SNDRV_CTL_ELEM_ACCESS_TLV_CALLBACK;",
          "1220:  if (info->type < SNDRV_CTL_ELEM_TYPE_BOOLEAN ||",
          "1221:      info->type > SNDRV_CTL_ELEM_TYPE_INTEGER64)",
          "1222:   return -EINVAL;",
          "",
          "[Removed Lines]",
          "1182:  struct snd_kcontrol kctl, *_kctl;",
          "1186:  int idx, err;",
          "1188:  access = info->access == 0 ? SNDRV_CTL_ELEM_ACCESS_READWRITE :",
          "1189:   (info->access & (SNDRV_CTL_ELEM_ACCESS_READWRITE|",
          "1190:      SNDRV_CTL_ELEM_ACCESS_INACTIVE|",
          "1191:      SNDRV_CTL_ELEM_ACCESS_TLV_READWRITE));",
          "1192:  info->id.numid = 0;",
          "1193:  memset(&kctl, 0, sizeof(kctl));",
          "1201:  if (card->user_ctl_count >= MAX_USER_CONTROLS)",
          "1204:  memcpy(&kctl.id, &info->id, sizeof(info->id));",
          "1205:  kctl.count = info->owner ? info->owner : 1;",
          "1206:  access |= SNDRV_CTL_ELEM_ACCESS_USER;",
          "1207:  if (info->type == SNDRV_CTL_ELEM_TYPE_ENUMERATED)",
          "1208:   kctl.info = snd_ctl_elem_user_enum_info;",
          "1209:  else",
          "1210:   kctl.info = snd_ctl_elem_user_info;",
          "1211:  if (access & SNDRV_CTL_ELEM_ACCESS_READ)",
          "1212:   kctl.get = snd_ctl_elem_user_get;",
          "1213:  if (access & SNDRV_CTL_ELEM_ACCESS_WRITE)",
          "1214:   kctl.put = snd_ctl_elem_user_put;",
          "1215:  if (access & SNDRV_CTL_ELEM_ACCESS_TLV_READWRITE) {",
          "1216:   kctl.tlv.c = snd_ctl_elem_user_tlv;",
          "1218:  }",
          "",
          "[Added Lines]",
          "1205:  struct snd_kcontrol *kctl;",
          "1206:  unsigned int count;",
          "1210:  int err;",
          "1214:   info->id.numid = 0;",
          "1224:  if (card->user_ctl_count + 1 > MAX_USER_CONTROLS)",
          "1228:  count = info->owner;",
          "1229:  if (count == 0)",
          "1230:   count = 1;",
          "1233:  access = info->access;",
          "1234:  if (access == 0)",
          "1235:   access = SNDRV_CTL_ELEM_ACCESS_READWRITE;",
          "1236:  access &= (SNDRV_CTL_ELEM_ACCESS_READWRITE |",
          "1237:      SNDRV_CTL_ELEM_ACCESS_INACTIVE |",
          "1238:      SNDRV_CTL_ELEM_ACCESS_TLV_READWRITE);",
          "1239:  if (access & SNDRV_CTL_ELEM_ACCESS_TLV_READWRITE)",
          "1241:  access |= SNDRV_CTL_ELEM_ACCESS_USER;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1226:  if (info->count < 1 ||",
          "1227:      info->count > max_value_counts[info->type])",
          "1228:   return -EINVAL;",
          "1230:  private_size = value_sizes[info->type] * info->count;",
          "1233:   return -ENOMEM;",
          "1234:  ue->card = card;",
          "1235:  ue->info = *info;",
          "1236:  ue->info.access = 0;",
          "",
          "[Removed Lines]",
          "1231:  ue = kzalloc(sizeof(struct user_element) + private_size, GFP_KERNEL);",
          "1232:  if (ue == NULL)",
          "",
          "[Added Lines]",
          "1264:  err = snd_ctl_new(&kctl, count, access, file);",
          "1265:  if (err < 0)",
          "1266:   return err;",
          "1267:  kctl->private_data = kzalloc(sizeof(struct user_element) + private_size,",
          "1268:          GFP_KERNEL);",
          "1269:  if (kctl->private_data == NULL) {",
          "1270:   kfree(kctl);",
          "1272:  }",
          "1273:  kctl->private_free = snd_ctl_elem_user_free;",
          "1276:  ue = (struct user_element *)kctl->private_data;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1239:  if (ue->info.type == SNDRV_CTL_ELEM_TYPE_ENUMERATED) {",
          "1240:   err = snd_ctl_elem_init_enum_names(ue);",
          "1241:   if (err < 0) {",
          "1243:    return err;",
          "1244:   }",
          "1245:  }",
          "1257:  if (err < 0)",
          "1258:   return err;",
          "",
          "[Removed Lines]",
          "1242:    kfree(ue);",
          "1246:  kctl.private_free = snd_ctl_elem_user_free;",
          "1247:  _kctl = snd_ctl_new(&kctl, access);",
          "1248:  if (_kctl == NULL) {",
          "1249:   kfree(ue->priv_data);",
          "1250:   kfree(ue);",
          "1251:   return -ENOMEM;",
          "1252:  }",
          "1253:  _kctl->private_data = ue;",
          "1254:  for (idx = 0; idx < _kctl->count; idx++)",
          "1255:   _kctl->vd[idx].owner = file;",
          "1256:  err = snd_ctl_add(card, _kctl);",
          "",
          "[Added Lines]",
          "1285:    snd_ctl_free_one(kctl);",
          "1291:  if (info->type == SNDRV_CTL_ELEM_TYPE_ENUMERATED)",
          "1292:   kctl->info = snd_ctl_elem_user_enum_info;",
          "1293:  else",
          "1294:   kctl->info = snd_ctl_elem_user_info;",
          "1295:  if (access & SNDRV_CTL_ELEM_ACCESS_READ)",
          "1296:   kctl->get = snd_ctl_elem_user_get;",
          "1297:  if (access & SNDRV_CTL_ELEM_ACCESS_WRITE)",
          "1298:   kctl->put = snd_ctl_elem_user_put;",
          "1299:  if (access & SNDRV_CTL_ELEM_ACCESS_TLV_READWRITE)",
          "1300:   kctl->tlv.c = snd_ctl_elem_user_tlv;",
          "1303:  err = snd_ctl_add(card, kctl);",
          "",
          "---------------"
        ]
      }
    }
  ]
}
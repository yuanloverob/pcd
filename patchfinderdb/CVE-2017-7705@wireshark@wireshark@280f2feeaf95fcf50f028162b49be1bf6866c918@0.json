{
  "cve_id": "CVE-2017-7705",
  "cve_desc": "In Wireshark 2.2.0 to 2.2.5 and 2.0.0 to 2.0.11, the RPC over RDMA dissector could go into an infinite loop, triggered by packet injection or a malformed capture file. This was addressed in epan/dissectors/packet-rpcrdma.c by correctly checking for going beyond the maximum offset.",
  "repo": "wireshark/wireshark",
  "patch_hash": "280f2feeaf95fcf50f028162b49be1bf6866c918",
  "patch_info": {
    "commit_hash": "280f2feeaf95fcf50f028162b49be1bf6866c918",
    "repo": "wireshark/wireshark",
    "commit_url": "https://github.com/wireshark/wireshark/commit/280f2feeaf95fcf50f028162b49be1bf6866c918",
    "files": [
      "epan/dissectors/packet-rpcrdma.c"
    ],
    "message": "RPC-over-RDMA: protect against a variable overflow\n\nBug: 13558\nChange-Id: I0cb379df1a6c40a3c4a84f18c631d9239550c3ab\nReviewed-on: https://code.wireshark.org/review/20941\nReviewed-by: Pascal Quantin <pascal.quantin@gmail.com>\nPetri-Dish: Pascal Quantin <pascal.quantin@gmail.com>\nTested-by: Petri Dish Buildbot <buildbot-no-reply@wireshark.org>\nReviewed-by: Anders Broman <a.broman58@gmail.com>",
    "before_after_code_files": [
      "epan/dissectors/packet-rpcrdma.c||epan/dissectors/packet-rpcrdma.c"
    ]
  },
  "patch_diff": {
    "epan/dissectors/packet-rpcrdma.c||epan/dissectors/packet-rpcrdma.c": [
      "File: epan/dissectors/packet-rpcrdma.c -> epan/dissectors/packet-rpcrdma.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "168: static guint get_write_list_size(tvbuff_t *tvb, guint max_offset, guint offset)",
      "169: {",
      "170:     guint32 value_follows;",
      "173:     while (1) {",
      "174:         value_follows = tvb_get_ntohl(tvb, offset);",
      "",
      "[Removed Lines]",
      "171:     guint start = offset;",
      "",
      "[Added Lines]",
      "171:     guint chunk_size, start = offset;",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "178:         if (!value_follows)",
      "179:             break;",
      "183:             return 0;",
      "184:     }",
      "186:     return offset - start;",
      "",
      "[Removed Lines]",
      "181:         offset += get_write_chunk_size(tvb, offset);",
      "182:         if (offset > max_offset)",
      "",
      "[Added Lines]",
      "181:         chunk_size = get_write_chunk_size(tvb, offset);",
      "182:         if ((offset + chunk_size) < offset ||",
      "183:             (offset + chunk_size) > max_offset)",
      "185:         offset += chunk_size;",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "189: static guint get_write_list_chunk_count(tvbuff_t *tvb, guint offset)",
      "190: {",
      "191:     guint32 value_follows;",
      "194:     num_chunks = 0;",
      "195:     while (1) {",
      "",
      "[Removed Lines]",
      "192:     guint num_chunks;",
      "",
      "[Added Lines]",
      "194:     guint num_chunks, chunk_size;",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "199:             break;",
      "201:         num_chunks++;",
      "203:     }",
      "205:    return num_chunks;",
      "",
      "[Removed Lines]",
      "202:         offset += get_write_chunk_size(tvb, offset);",
      "",
      "[Added Lines]",
      "204:         chunk_size = get_write_chunk_size(tvb, offset);",
      "205:         if ((offset + chunk_size) < offset)",
      "206:             break;",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "08d392bbecc8fb666bf979e70a34536007b83ea2",
      "candidate_info": {
        "commit_hash": "08d392bbecc8fb666bf979e70a34536007b83ea2",
        "repo": "wireshark/wireshark",
        "commit_url": "https://github.com/wireshark/wireshark/commit/08d392bbecc8fb666bf979e70a34536007b83ea2",
        "files": [
          "epan/dissectors/packet-rpcrdma.c"
        ],
        "message": "RPC-over-RDMA: protect against a variable overflow\n\nBug: 13558\nChange-Id: I0cb379df1a6c40a3c4a84f18c631d9239550c3ab\nReviewed-on: https://code.wireshark.org/review/20941\nReviewed-by: Pascal Quantin <pascal.quantin@gmail.com>\nPetri-Dish: Pascal Quantin <pascal.quantin@gmail.com>\nTested-by: Petri Dish Buildbot <buildbot-no-reply@wireshark.org>\nReviewed-by: Anders Broman <a.broman58@gmail.com>\n(cherry picked from commit 280f2feeaf95fcf50f028162b49be1bf6866c918)\nConflicts:\n\tepan/dissectors/packet-rpcrdma.c\nReviewed-on: https://code.wireshark.org/review/20951",
        "before_after_code_files": [
          "epan/dissectors/packet-rpcrdma.c||epan/dissectors/packet-rpcrdma.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_cherry_pick": 1,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "epan/dissectors/packet-rpcrdma.c||epan/dissectors/packet-rpcrdma.c"
          ],
          "candidate": [
            "epan/dissectors/packet-rpcrdma.c||epan/dissectors/packet-rpcrdma.c"
          ]
        }
      },
      "candidate_diff": {
        "epan/dissectors/packet-rpcrdma.c||epan/dissectors/packet-rpcrdma.c": [
          "File: epan/dissectors/packet-rpcrdma.c -> epan/dissectors/packet-rpcrdma.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "170:         offset += 4;",
          "171:         if (offset > max_offset)",
          "172:             return 0;",
          "175:             return 0;",
          "176:     }",
          "178:     return offset - start;",
          "",
          "[Removed Lines]",
          "173:         offset += (segment_count * 16);",
          "174:         if (offset > max_offset)",
          "",
          "[Added Lines]",
          "173:         if ((offset + (segment_count * 16)) < offset ||",
          "174:             (offset + (segment_count * 16)) > max_offset)",
          "176:         offset += (segment_count * 16);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "d686f6eb5d6ead7ae659b1bbd5b561e580d0e03d",
      "candidate_info": {
        "commit_hash": "d686f6eb5d6ead7ae659b1bbd5b561e580d0e03d",
        "repo": "wireshark/wireshark",
        "commit_url": "https://github.com/wireshark/wireshark/commit/d686f6eb5d6ead7ae659b1bbd5b561e580d0e03d",
        "files": [
          "epan/dissectors/packet-rpcrdma.c"
        ],
        "message": "RPC-over-RDMA: protect against a variable overflow\n\nBug: 13558\nChange-Id: I0cb379df1a6c40a3c4a84f18c631d9239550c3ab\nReviewed-on: https://code.wireshark.org/review/20941\nReviewed-by: Pascal Quantin <pascal.quantin@gmail.com>\nPetri-Dish: Pascal Quantin <pascal.quantin@gmail.com>\nTested-by: Petri Dish Buildbot <buildbot-no-reply@wireshark.org>\nReviewed-by: Anders Broman <a.broman58@gmail.com>\n(cherry picked from commit 280f2feeaf95fcf50f028162b49be1bf6866c918)\nReviewed-on: https://code.wireshark.org/review/20950",
        "before_after_code_files": [
          "epan/dissectors/packet-rpcrdma.c||epan/dissectors/packet-rpcrdma.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_cherry_pick": 1,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "epan/dissectors/packet-rpcrdma.c||epan/dissectors/packet-rpcrdma.c"
          ],
          "candidate": [
            "epan/dissectors/packet-rpcrdma.c||epan/dissectors/packet-rpcrdma.c"
          ]
        }
      },
      "candidate_diff": {
        "epan/dissectors/packet-rpcrdma.c||epan/dissectors/packet-rpcrdma.c": [
          "File: epan/dissectors/packet-rpcrdma.c -> epan/dissectors/packet-rpcrdma.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "186: static guint get_write_list_size(tvbuff_t *tvb, guint max_offset, guint offset)",
          "187: {",
          "188:     guint32 value_follows;",
          "191:     while (1) {",
          "192:         value_follows = tvb_get_ntohl(tvb, offset);",
          "",
          "[Removed Lines]",
          "189:     guint start = offset;",
          "",
          "[Added Lines]",
          "189:     guint chunk_size, start = offset;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "196:         if (!value_follows)",
          "197:             break;",
          "201:             return 0;",
          "202:     }",
          "204:     return offset - start;",
          "",
          "[Removed Lines]",
          "199:         offset += get_write_chunk_size(tvb, offset);",
          "200:         if (offset > max_offset)",
          "",
          "[Added Lines]",
          "199:         chunk_size = get_write_chunk_size(tvb, offset);",
          "200:         if ((offset + chunk_size) < offset ||",
          "201:             (offset + chunk_size) > max_offset)",
          "203:         offset += chunk_size;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "207: static guint get_write_list_chunk_count(tvbuff_t *tvb, guint offset)",
          "208: {",
          "209:     guint32 value_follows;",
          "212:     num_chunks = 0;",
          "213:     while (1) {",
          "",
          "[Removed Lines]",
          "210:     guint num_chunks;",
          "",
          "[Added Lines]",
          "212:     guint num_chunks, chunk_size;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "217:             break;",
          "219:         num_chunks++;",
          "221:     }",
          "223:    return num_chunks;",
          "",
          "[Removed Lines]",
          "220:         offset += get_write_chunk_size(tvb, offset);",
          "",
          "[Added Lines]",
          "222:         chunk_size = get_write_chunk_size(tvb, offset);",
          "223:         if ((offset + chunk_size) < offset)",
          "224:             break;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "2da2a36a8b42ef530a4706c6ea88731eb95126a8",
      "candidate_info": {
        "commit_hash": "2da2a36a8b42ef530a4706c6ea88731eb95126a8",
        "repo": "wireshark/wireshark",
        "commit_url": "https://github.com/wireshark/wireshark/commit/2da2a36a8b42ef530a4706c6ea88731eb95126a8",
        "files": [
          "epan/dissectors/packet-rpcrdma.c"
        ],
        "message": "RPCoRDMA: Set an upper bound for our chunk size.\n\nMake sure our write chunk size doesn't exceed our tvbuff. Adjust a few\nlength checks.\n\nBug: 14449\nChange-Id: If9dd8a6094830c5b47adfff0acb3ff726168e801\nReviewed-on: https://code.wireshark.org/review/25944\nPetri-Dish: Michael Mann <mmann78@netscape.net>\nTested-by: Petri Dish Buildbot\nReviewed-by: Michael Mann <mmann78@netscape.net>",
        "before_after_code_files": [
          "epan/dissectors/packet-rpcrdma.c||epan/dissectors/packet-rpcrdma.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "epan/dissectors/packet-rpcrdma.c||epan/dissectors/packet-rpcrdma.c"
          ],
          "candidate": [
            "epan/dissectors/packet-rpcrdma.c||epan/dissectors/packet-rpcrdma.c"
          ]
        }
      },
      "candidate_diff": {
        "epan/dissectors/packet-rpcrdma.c||epan/dissectors/packet-rpcrdma.c": [
          "File: epan/dissectors/packet-rpcrdma.c -> epan/dissectors/packet-rpcrdma.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "160: static guint get_write_chunk_size(tvbuff_t *tvb, guint offset)",
          "161: {",
          "162:     guint segment_count;",
          "164:     segment_count = tvb_get_ntohl(tvb, offset);",
          "165:     return 4 + (segment_count * 16);",
          "166: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "163:     guint max_count = (guint)tvb_reported_length_remaining(tvb, offset + 4) / 16;",
          "166:     if (segment_count > max_count) {",
          "168:         segment_count = max_count;",
          "169:     }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "179:             break;",
          "181:         chunk_size = get_write_chunk_size(tvb, offset);",
          "184:             return 0;",
          "185:         offset += chunk_size;",
          "186:     }",
          "",
          "[Removed Lines]",
          "182:         if ((offset + chunk_size) < offset ||",
          "183:             (offset + chunk_size) > max_offset)",
          "",
          "[Added Lines]",
          "187:         if ((offset > max_offset) ||",
          "188:             (max_offset - offset < chunk_size))",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "203:         num_chunks++;",
          "204:         chunk_size = get_write_chunk_size(tvb, offset);",
          "206:             break;",
          "207:         offset += chunk_size;",
          "208:     }",
          "",
          "[Removed Lines]",
          "205:         if ((offset + chunk_size) < offset)",
          "",
          "[Added Lines]",
          "210:         if (chunk_size == 0)",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "677a543e48eed5921d44ceb53ea6101b43a98ad2",
      "candidate_info": {
        "commit_hash": "677a543e48eed5921d44ceb53ea6101b43a98ad2",
        "repo": "wireshark/wireshark",
        "commit_url": "https://github.com/wireshark/wireshark/commit/677a543e48eed5921d44ceb53ea6101b43a98ad2",
        "files": [
          "epan/dissectors/packet-rpcrdma.c"
        ],
        "message": "packet-rpcrdma: Fix Write list dissection\n\nThe current mechanism of dissecting RPC-over-RDMA chunk lists is not\nworking. It treats the Write list as a list of RDMA segments (it's a\nlist of counted arrays).\n\nBug: 13197\nChange-Id: I6f8e788d66eefd17d6c1995e238a9ff9fa1e81f2\nSigned-off-by: Chuck Lever <chuck.lever@oracle.com>\nReviewed-on: https://code.wireshark.org/review/19100\nReviewed-by: Michael Mann <mmann78@netscape.net>",
        "before_after_code_files": [
          "epan/dissectors/packet-rpcrdma.c||epan/dissectors/packet-rpcrdma.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "epan/dissectors/packet-rpcrdma.c||epan/dissectors/packet-rpcrdma.c"
          ],
          "candidate": [
            "epan/dissectors/packet-rpcrdma.c||epan/dissectors/packet-rpcrdma.c"
          ]
        }
      },
      "candidate_diff": {
        "epan/dissectors/packet-rpcrdma.c||epan/dissectors/packet-rpcrdma.c": [
          "File: epan/dissectors/packet-rpcrdma.c -> epan/dissectors/packet-rpcrdma.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "88: static gint ett_rpcordma_chunk = -1;",
          "89: static gint ett_rpcordma_read_list = -1;",
          "90: static gint ett_rpcordma_read_chunk = -1;",
          "93: static gboolean gPREF_MAN_EN    = FALSE;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "91: static gint ett_rpcordma_write_list = -1;",
          "92: static gint ett_rpcordma_write_chunk = -1;",
          "93: static gint ett_rpcordma_segment = -1;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "171:     return num_chunks;",
          "172: }",
          "174: static guint get_write_list_size(tvbuff_t *tvb, guint max_offset, guint offset)",
          "175: {",
          "177:     guint start = offset;",
          "179:     while (1) {",
          "",
          "[Removed Lines]",
          "176:     guint32 value_follows, segment_count;",
          "",
          "[Added Lines]",
          "177: static guint get_write_chunk_size(tvbuff_t *tvb, guint offset)",
          "178: {",
          "179:     guint segment_count;",
          "181:     segment_count = tvb_get_ntohl(tvb, offset);",
          "182:     return 4 + (segment_count * 16);",
          "183: }",
          "187:     guint32 value_follows;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "184:         if (!value_follows)",
          "185:             break;",
          "192:         if (offset > max_offset)",
          "193:             return 0;",
          "194:     }",
          "",
          "[Removed Lines]",
          "187:         segment_count = tvb_get_ntohl(tvb, offset);",
          "188:         offset += 4;",
          "189:         if (offset > max_offset)",
          "190:             return 0;",
          "191:         offset += (segment_count * 16);",
          "",
          "[Added Lines]",
          "198:         offset += get_write_chunk_size(tvb, offset);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "196:     return offset - start;",
          "197: }",
          "199: static guint get_reply_chunk_size(tvbuff_t *tvb, guint max_offset, guint offset)",
          "200: {",
          "202:     guint start = offset;",
          "204:     value_follows = tvb_get_ntohl(tvb, offset);",
          "",
          "[Removed Lines]",
          "201:     guint32 value_follows, segment_count;",
          "",
          "[Added Lines]",
          "206: static guint get_write_list_chunk_count(tvbuff_t *tvb, guint offset)",
          "207: {",
          "208:     guint32 value_follows;",
          "209:     guint num_chunks;",
          "211:     num_chunks = 0;",
          "212:     while (1) {",
          "213:         value_follows = tvb_get_ntohl(tvb, offset);",
          "214:         offset += 4;",
          "215:         if (!value_follows)",
          "216:             break;",
          "218:         num_chunks++;",
          "219:         offset += get_write_chunk_size(tvb, offset);",
          "220:     }",
          "222:    return num_chunks;",
          "223: }",
          "227:     guint32 value_follows;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "207:         return 0;",
          "209:     if (value_follows) {",
          "212:         if (offset > max_offset)",
          "213:             return 0;",
          "214:     }",
          "",
          "[Removed Lines]",
          "210:         segment_count = tvb_get_ntohl(tvb, offset);",
          "211:         offset += segment_count * 16 + 4;",
          "",
          "[Added Lines]",
          "236:         offset += get_write_chunk_size(tvb, offset);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "270:     return offset;",
          "271: }",
          "273: static guint parse_list(tvbuff_t *tvb, guint offset, proto_tree *tree,",
          "274:         int hf_item, const char* msg, gboolean have_position)",
          "275: {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "298: static guint dissect_rpcrdma_segment(proto_tree *write_chunk, tvbuff_t *tvb,",
          "299:         guint offset, guint32 i)",
          "300: {",
          "301:     proto_tree *segment;",
          "303:     segment = proto_tree_add_subtree_format(write_chunk, tvb,",
          "304:                     offset, 16, ett_rpcordma_segment, NULL,",
          "305:                     \"RDMA segment %u\", i);",
          "307:     proto_tree_add_item(segment, hf_rpcordma_rdma_handle, tvb,",
          "308:                 offset, 4, ENC_BIG_ENDIAN);",
          "309:     offset += 4;",
          "310:     proto_tree_add_item(segment, hf_rpcordma_rdma_length, tvb,",
          "311:                 offset, 4, ENC_BIG_ENDIAN);",
          "312:     offset += 4;",
          "313:     proto_tree_add_item(segment, hf_rpcordma_rdma_offset, tvb,",
          "314:                 offset, 8, ENC_BIG_ENDIAN);",
          "315:     return offset + 8;",
          "316: }",
          "318: static guint dissect_rpcrdma_write_chunk(proto_tree *write_list,",
          "319:         tvbuff_t *tvb, guint offset)",
          "320: {",
          "321:     guint32 i, segment_count;",
          "322:     proto_tree *write_chunk;",
          "323:     guint selection_size;",
          "325:     selection_size = get_write_chunk_size(tvb, offset);",
          "326:     segment_count = tvb_get_ntohl(tvb, offset);",
          "327:     write_chunk = proto_tree_add_subtree_format(write_list, tvb,",
          "328:                         offset, selection_size,",
          "329:                         ett_rpcordma_write_chunk, NULL,",
          "330:                         \"Write chunk (%u segment%s)\", segment_count,",
          "331:                         segment_count == 1 ? \"\" : \"s\");",
          "332:     offset += 4;",
          "334:     for (i = 0; i < segment_count; ++i)",
          "335:         offset = dissect_rpcrdma_segment(write_chunk, tvb, offset, i);",
          "337:     return offset;",
          "338: }",
          "340: static guint dissect_rpcrdma_write_list(tvbuff_t *tvb, guint offset,",
          "341:         proto_tree *tree)",
          "342: {",
          "343:     guint reported_length = tvb_reported_length(tvb);",
          "344:     guint selection_size, chunk_count;",
          "345:     proto_tree *write_list;",
          "346:     guint32 value_follows;",
          "347:     proto_item *item;",
          "349:     selection_size = get_write_list_size(tvb, reported_length, offset);",
          "350:     chunk_count = get_write_list_chunk_count(tvb, offset);",
          "351:     item = proto_tree_add_uint_format(tree, hf_rpcordma_writes_count,",
          "352:                         tvb, offset, selection_size, chunk_count,",
          "353:                         \"Write list (count: %u)\", chunk_count);",
          "355:     write_list = proto_item_add_subtree(item, ett_rpcordma_write_list);",
          "357:     while (1) {",
          "358:         value_follows = tvb_get_ntohl(tvb, offset);",
          "359:         offset += 4;",
          "360:         if (!value_follows)",
          "361:             break;",
          "363:         offset = dissect_rpcrdma_write_chunk(write_list, tvb, offset);",
          "364:     }",
          "366:     return offset;",
          "367: }",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "313: static guint parse_rdma_header(tvbuff_t *tvb, guint offset, proto_tree *tree)",
          "314: {",
          "315:     offset = dissect_rpcrdma_read_list(tvb, offset, tree);",
          "317:     offset = parse_list(tvb, offset, tree, hf_rpcordma_reply_count,  \"Reply\",  FALSE);",
          "318:     return offset;",
          "319: }",
          "",
          "[Removed Lines]",
          "316:     offset = parse_list(tvb, offset, tree, hf_rpcordma_writes_count, \"Writes\", FALSE);",
          "",
          "[Added Lines]",
          "412:     offset = dissect_rpcrdma_write_list(tvb, offset, tree);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "658:         &ett_rpcordma_chunk,",
          "659:         &ett_rpcordma_read_list,",
          "660:         &ett_rpcordma_read_chunk,",
          "661:     };",
          "663:     proto_rpcordma = proto_register_protocol (",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "757:         &ett_rpcordma_write_list,",
          "758:         &ett_rpcordma_write_chunk,",
          "759:         &ett_rpcordma_segment,",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "65aa59d28ab5f41a06dbfcf25b191f2b3547b78e",
      "candidate_info": {
        "commit_hash": "65aa59d28ab5f41a06dbfcf25b191f2b3547b78e",
        "repo": "wireshark/wireshark",
        "commit_url": "https://github.com/wireshark/wireshark/commit/65aa59d28ab5f41a06dbfcf25b191f2b3547b78e",
        "files": [
          "epan/dissectors/packet-rpcrdma.c"
        ],
        "message": "RPCoRDMA: Set an upper bound for our chunk size.\n\nMake sure our write chunk size doesn't exceed our tvbuff. Adjust a few\nlength checks.\n\nBug: 14449\nChange-Id: If9dd8a6094830c5b47adfff0acb3ff726168e801\nReviewed-on: https://code.wireshark.org/review/25943\nReviewed-by: Gerald Combs <gerald@wireshark.org>\nPetri-Dish: Gerald Combs <gerald@wireshark.org>\nTested-by: Petri Dish Buildbot\nReviewed-by: Michael Mann <mmann78@netscape.net>",
        "before_after_code_files": [
          "epan/dissectors/packet-rpcrdma.c||epan/dissectors/packet-rpcrdma.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "epan/dissectors/packet-rpcrdma.c||epan/dissectors/packet-rpcrdma.c"
          ],
          "candidate": [
            "epan/dissectors/packet-rpcrdma.c||epan/dissectors/packet-rpcrdma.c"
          ]
        }
      },
      "candidate_diff": {
        "epan/dissectors/packet-rpcrdma.c||epan/dissectors/packet-rpcrdma.c": [
          "File: epan/dissectors/packet-rpcrdma.c -> epan/dissectors/packet-rpcrdma.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "148: static guint get_write_chunk_size(tvbuff_t *tvb, guint offset)",
          "149: {",
          "150:     guint segment_count;",
          "152:     segment_count = tvb_get_ntohl(tvb, offset);",
          "153:     return 4 + (segment_count * 16);",
          "154: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "151:     guint max_count = (guint)tvb_reported_length_remaining(tvb, offset + 4) / 16;",
          "154:     if (segment_count > max_count) {",
          "156:         segment_count = max_count;",
          "157:     }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "167:             break;",
          "169:         chunk_size = get_write_chunk_size(tvb, offset);",
          "172:             return 0;",
          "173:         offset += chunk_size;",
          "174:     }",
          "",
          "[Removed Lines]",
          "170:         if ((offset + chunk_size) < offset ||",
          "171:             (offset + chunk_size) > max_offset)",
          "",
          "[Added Lines]",
          "175:         if ((offset > max_offset) ||",
          "176:             (max_offset - offset < chunk_size))",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "191:         num_chunks++;",
          "192:         chunk_size = get_write_chunk_size(tvb, offset);",
          "194:             break;",
          "195:         offset += chunk_size;",
          "196:     }",
          "",
          "[Removed Lines]",
          "193:         if ((offset + chunk_size) < offset)",
          "",
          "[Added Lines]",
          "198:         if (chunk_size == 0)",
          "",
          "---------------"
        ]
      }
    }
  ]
}
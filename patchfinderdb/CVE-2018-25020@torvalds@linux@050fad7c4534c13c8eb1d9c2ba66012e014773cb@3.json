{
  "cve_id": "CVE-2018-25020",
  "cve_desc": "The BPF subsystem in the Linux kernel before 4.17 mishandles situations with a long jump over an instruction sequence where inner instructions require substantial expansions into multiple BPF instructions, leading to an overflow. This affects kernel/bpf/core.c and net/core/filter.c.",
  "repo": "torvalds/linux",
  "patch_hash": "050fad7c4534c13c8eb1d9c2ba66012e014773cb",
  "patch_info": {
    "commit_hash": "050fad7c4534c13c8eb1d9c2ba66012e014773cb",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/050fad7c4534c13c8eb1d9c2ba66012e014773cb",
    "files": [
      "kernel/bpf/core.c",
      "net/core/filter.c"
    ],
    "message": "bpf: fix truncated jump targets on heavy expansions\n\nRecently during testing, I ran into the following panic:\n\n  [  207.892422] Internal error: Accessing user space memory outside uaccess.h routines: 96000004 [#1] SMP\n  [  207.901637] Modules linked in: binfmt_misc [...]\n  [  207.966530] CPU: 45 PID: 2256 Comm: test_verifier Tainted: G        W         4.17.0-rc3+ #7\n  [  207.974956] Hardware name: FOXCONN R2-1221R-A4/C2U4N_MB, BIOS G31FB18A 03/31/2017\n  [  207.982428] pstate: 60400005 (nZCv daif +PAN -UAO)\n  [  207.987214] pc : bpf_skb_load_helper_8_no_cache+0x34/0xc0\n  [  207.992603] lr : 0xffff000000bdb754\n  [  207.996080] sp : ffff000013703ca0\n  [  207.999384] x29: ffff000013703ca0 x28: 0000000000000001\n  [  208.004688] x27: 0000000000000001 x26: 0000000000000000\n  [  208.009992] x25: ffff000013703ce0 x24: ffff800fb4afcb00\n  [  208.015295] x23: ffff00007d2f5038 x22: ffff00007d2f5000\n  [  208.020599] x21: fffffffffeff2a6f x20: 000000000000000a\n  [  208.025903] x19: ffff000009578000 x18: 0000000000000a03\n  [  208.031206] x17: 0000000000000000 x16: 0000000000000000\n  [  208.036510] x15: 0000ffff9de83000 x14: 0000000000000000\n  [  208.041813] x13: 0000000000000000 x12: 0000000000000000\n  [  208.047116] x11: 0000000000000001 x10: ffff0000089e7f18\n  [  208.052419] x9 : fffffffffeff2a6f x8 : 0000000000000000\n  [  208.057723] x7 : 000000000000000a x6 : 00280c6160000000\n  [  208.063026] x5 : 0000000000000018 x4 : 0000000000007db6\n  [  208.068329] x3 : 000000000008647a x2 : 19868179b1484500\n  [  208.073632] x1 : 0000000000000000 x0 : ffff000009578c08\n  [  208.078938] Process test_verifier (pid: 2256, stack limit = 0x0000000049ca7974)\n  [  208.086235] Call trace:\n  [  208.088672]  bpf_skb_load_helper_8_no_cache+0x34/0xc0\n  [  208.093713]  0xffff000000bdb754\n  [  208.096845]  bpf_test_run+0x78/0xf8\n  [  208.100324]  bpf_prog_test_run_skb+0x148/0x230\n  [  208.104758]  sys_bpf+0x314/0x1198\n  [  208.108064]  el0_svc_naked+0x30/0x34\n  [  208.111632] Code: 91302260 f9400001 f9001fa1 d2800001 (29500680)\n  [  208.117717] ---[ end trace 263cb8a59b5bf29f ]---\n\nThe program itself which caused this had a long jump over the whole\ninstruction sequence where all of the inner instructions required\nheavy expansions into multiple BPF instructions. Additionally, I also\nhad BPF hardening enabled which requires once more rewrites of all\nconstant values in order to blind them. Each time we rewrite insns,\nbpf_adj_branches() would need to potentially adjust branch targets\nwhich cross the patchlet boundary to accommodate for the additional\ndelta. Eventually that lead to the case where the target offset could\nnot fit into insn->off's upper 0x7fff limit anymore where then offset\nwraps around becoming negative (in s16 universe), or vice versa\ndepending on the jump direction.\n\nTherefore it becomes necessary to detect and reject any such occasions\nin a generic way for native eBPF and cBPF to eBPF migrations. For\nthe latter we can simply check bounds in the bpf_convert_filter()'s\nBPF_EMIT_JMP helper macro and bail out once we surpass limits. The\nbpf_patch_insn_single() for native eBPF (and cBPF to eBPF in case\nof subsequent hardening) is a bit more complex in that we need to\ndetect such truncations before hitting the bpf_prog_realloc(). Thus\nthe latter is split into an extra pass to probe problematic offsets\non the original program in order to fail early. With that in place\nand carefully tested I no longer hit the panic and the rewrites are\nrejected properly. The above example panic I've seen on bpf-next,\nthough the issue itself is generic in that a guard against this issue\nin bpf seems more appropriate in this case.\n\nSigned-off-by: Daniel Borkmann <daniel@iogearbox.net>\nAcked-by: Martin KaFai Lau <kafai@fb.com>\nSigned-off-by: Alexei Starovoitov <ast@kernel.org>",
    "before_after_code_files": [
      "kernel/bpf/core.c||kernel/bpf/core.c",
      "net/core/filter.c||net/core/filter.c"
    ]
  },
  "patch_diff": {
    "kernel/bpf/core.c||kernel/bpf/core.c": [
      "File: kernel/bpf/core.c -> kernel/bpf/core.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "218:  return 0;",
      "219: }",
      "222: {",
      "223:  struct bpf_insn *insn = prog->insnsi;",
      "229:  for (i = 0; i < insn_cnt; i++, insn++) {",
      "230:   code = insn->code;",
      "234:    continue;",
      "235:   if (BPF_OP(code) == BPF_CALL) {",
      "239:     continue;",
      "240:   } else {",
      "242:   }",
      "255:  }",
      "256: }",
      "258: struct bpf_prog *bpf_patch_insn_single(struct bpf_prog *prog, u32 off,",
      "259:            const struct bpf_insn *patch, u32 len)",
      "260: {",
      "261:  u32 insn_adj_cnt, insn_rest, insn_delta = len - 1;",
      "262:  struct bpf_prog *prog_adj;",
      "",
      "[Removed Lines]",
      "221: static void bpf_adj_branches(struct bpf_prog *prog, u32 pos, u32 delta)",
      "224:  u32 i, insn_cnt = prog->len;",
      "225:  bool pseudo_call;",
      "226:  u8 code;",
      "227:  int off;",
      "231:   if (BPF_CLASS(code) != BPF_JMP)",
      "232:    continue;",
      "233:   if (BPF_OP(code) == BPF_EXIT)",
      "236:    if (insn->src_reg == BPF_PSEUDO_CALL)",
      "237:     pseudo_call = true;",
      "238:    else",
      "241:    pseudo_call = false;",
      "243:   off = pseudo_call ? insn->imm : insn->off;",
      "246:   if (i < pos && i + off + 1 > pos)",
      "247:    off += delta;",
      "248:   else if (i > pos + delta && i + off + 1 <= pos + delta)",
      "249:    off -= delta;",
      "251:   if (pseudo_call)",
      "252:    insn->imm = off;",
      "253:   else",
      "254:    insn->off = off;",
      "",
      "[Added Lines]",
      "221: static int bpf_adj_delta_to_imm(struct bpf_insn *insn, u32 pos, u32 delta,",
      "222:     u32 curr, const bool probe_pass)",
      "224:  const s64 imm_min = S32_MIN, imm_max = S32_MAX;",
      "225:  s64 imm = insn->imm;",
      "227:  if (curr < pos && curr + imm + 1 > pos)",
      "228:   imm += delta;",
      "229:  else if (curr > pos + delta && curr + imm + 1 <= pos + delta)",
      "230:   imm -= delta;",
      "231:  if (imm < imm_min || imm > imm_max)",
      "232:   return -ERANGE;",
      "233:  if (!probe_pass)",
      "234:   insn->imm = imm;",
      "235:  return 0;",
      "236: }",
      "238: static int bpf_adj_delta_to_off(struct bpf_insn *insn, u32 pos, u32 delta,",
      "239:     u32 curr, const bool probe_pass)",
      "240: {",
      "241:  const s32 off_min = S16_MIN, off_max = S16_MAX;",
      "242:  s32 off = insn->off;",
      "244:  if (curr < pos && curr + off + 1 > pos)",
      "245:   off += delta;",
      "246:  else if (curr > pos + delta && curr + off + 1 <= pos + delta)",
      "247:   off -= delta;",
      "248:  if (off < off_min || off > off_max)",
      "249:   return -ERANGE;",
      "250:  if (!probe_pass)",
      "251:   insn->off = off;",
      "252:  return 0;",
      "253: }",
      "255: static int bpf_adj_branches(struct bpf_prog *prog, u32 pos, u32 delta,",
      "256:        const bool probe_pass)",
      "257: {",
      "258:  u32 i, insn_cnt = prog->len + (probe_pass ? delta : 0);",
      "260:  int ret = 0;",
      "263:   u8 code;",
      "269:   if (probe_pass && i == pos) {",
      "270:    i += delta + 1;",
      "271:    insn++;",
      "272:   }",
      "274:   if (BPF_CLASS(code) != BPF_JMP ||",
      "275:       BPF_OP(code) == BPF_EXIT)",
      "279:    if (insn->src_reg != BPF_PSEUDO_CALL)",
      "281:    ret = bpf_adj_delta_to_imm(insn, pos, delta, i,",
      "282:          probe_pass);",
      "284:    ret = bpf_adj_delta_to_off(insn, pos, delta, i,",
      "285:          probe_pass);",
      "287:   if (ret)",
      "288:    break;",
      "291:  return ret;",
      "298:  const u32 cnt_max = S16_MAX;",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "270:  insn_adj_cnt = prog->len + insn_delta;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "314:  if (insn_adj_cnt > cnt_max &&",
      "315:      bpf_adj_branches(prog, off, insn_delta, true))",
      "316:   return NULL;",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "294:   sizeof(*patch) * insn_rest);",
      "295:  memcpy(prog_adj->insnsi + off, patch, sizeof(*patch) * len);",
      "299:  return prog_adj;",
      "300: }",
      "",
      "[Removed Lines]",
      "297:  bpf_adj_branches(prog_adj, off, insn_delta);",
      "",
      "[Added Lines]",
      "347:  BUG_ON(bpf_adj_branches(prog_adj, off, insn_delta, false));",
      "",
      "---------------"
    ],
    "net/core/filter.c||net/core/filter.c": [
      "File: net/core/filter.c -> net/core/filter.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "482: #define BPF_EMIT_JMP       \\",
      "483:  do {        \\",
      "484:   if (target >= len || target < 0)   \\",
      "485:    goto err;     \\",
      "489:  } while (0)",
      "491:   case BPF_JMP | BPF_JA:",
      "",
      "[Removed Lines]",
      "486:   insn->off = addrs ? addrs[target] - addrs[i] - 1 : 0; \\",
      "488:   insn->off -= insn - tmp_insns;    \\",
      "",
      "[Added Lines]",
      "484:   const s32 off_min = S16_MIN, off_max = S16_MAX;  \\",
      "485:   s32 off;      \\",
      "486:          \\",
      "489:   off = addrs ? addrs[target] - addrs[i] - 1 : 0;  \\",
      "491:   off -= insn - tmp_insns;    \\",
      "493:   if (off < off_min || off > off_max)   \\",
      "494:    goto err;     \\",
      "495:   insn->off = off;     \\",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "af959b18fd447170a10865283ba691af4353cc7f",
      "candidate_info": {
        "commit_hash": "af959b18fd447170a10865283ba691af4353cc7f",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/af959b18fd447170a10865283ba691af4353cc7f",
        "files": [
          "kernel/bpf/core.c"
        ],
        "message": "bpf: fix out of bounds backwards jmps due to dead code removal\n\nsystemtap folks reported the following splat recently:\n\n  [ 7790.862212] WARNING: CPU: 3 PID: 26759 at arch/x86/kernel/kprobes/core.c:1022 kprobe_fault_handler+0xec/0xf0\n  [...]\n  [ 7790.864113] CPU: 3 PID: 26759 Comm: sshd Not tainted 5.1.0-0.rc7.git1.1.fc31.x86_64 #1\n  [ 7790.864198] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS[...]\n  [ 7790.864314] RIP: 0010:kprobe_fault_handler+0xec/0xf0\n  [ 7790.864375] Code: 48 8b 50 [...]\n  [ 7790.864714] RSP: 0018:ffffc06800bdbb48 EFLAGS: 00010082\n  [ 7790.864812] RAX: ffff9e2b75a16320 RBX: 0000000000000000 RCX: 0000000000000000\n  [ 7790.865306] RDX: ffffffffffffffff RSI: 000000000000000e RDI: ffffc06800bdbbf8\n  [ 7790.865514] RBP: ffffc06800bdbbf8 R08: 0000000000000000 R09: 0000000000000000\n  [ 7790.865960] R10: 0000000000000000 R11: 0000000000000000 R12: ffffc06800bdbbf8\n  [ 7790.866037] R13: ffff9e2ab56a0418 R14: ffff9e2b6d0bb400 R15: ffff9e2b6d268000\n  [ 7790.866114] FS:  00007fde49937d80(0000) GS:ffff9e2b75a00000(0000) knlGS:0000000000000000\n  [ 7790.866193] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n  [ 7790.866318] CR2: 0000000000000000 CR3: 000000012f312000 CR4: 00000000000006e0\n  [ 7790.866419] Call Trace:\n  [ 7790.866677]  do_user_addr_fault+0x64/0x480\n  [ 7790.867513]  do_page_fault+0x33/0x210\n  [ 7790.868002]  async_page_fault+0x1e/0x30\n  [ 7790.868071] RIP: 0010:          (null)\n  [ 7790.868144] Code: Bad RIP value.\n  [ 7790.868229] RSP: 0018:ffffc06800bdbca8 EFLAGS: 00010282\n  [ 7790.868362] RAX: ffff9e2b598b60f8 RBX: ffffc06800bdbe48 RCX: 0000000000000004\n  [ 7790.868629] RDX: 0000000000000004 RSI: ffffc06800bdbc6c RDI: ffff9e2b598b60f0\n  [ 7790.868834] RBP: ffffc06800bdbcf8 R08: 0000000000000000 R09: 0000000000000004\n  [ 7790.870432] R10: 00000000ff6f7a03 R11: 0000000000000000 R12: 0000000000000001\n  [ 7790.871859] R13: ffffc06800bdbcb8 R14: 0000000000000000 R15: ffff9e2acd0a5310\n  [ 7790.873455]  ? vfs_read+0x5/0x170\n  [ 7790.874639]  ? vfs_read+0x1/0x170\n  [ 7790.875834]  ? trace_call_bpf+0xf6/0x260\n  [ 7790.877044]  ? vfs_read+0x1/0x170\n  [ 7790.878208]  ? vfs_read+0x5/0x170\n  [ 7790.879345]  ? kprobe_perf_func+0x233/0x260\n  [ 7790.880503]  ? vfs_read+0x1/0x170\n  [ 7790.881632]  ? vfs_read+0x5/0x170\n  [ 7790.882751]  ? kprobe_ftrace_handler+0x92/0xf0\n  [ 7790.883926]  ? __vfs_read+0x30/0x30\n  [ 7790.885050]  ? ftrace_ops_assist_func+0x94/0x100\n  [ 7790.886183]  ? vfs_read+0x1/0x170\n  [ 7790.887283]  ? vfs_read+0x5/0x170\n  [ 7790.888348]  ? ksys_read+0x5a/0xe0\n  [ 7790.889389]  ? do_syscall_64+0x5c/0xa0\n  [ 7790.890401]  ? entry_SYSCALL_64_after_hwframe+0x49/0xbe\n\nAfter some debugging, turns out that the logic in 2cbd95a5c4fb\n(\"bpf: change parameters of call/branch offset adjustment\") has\na bug that is exposed after 52875a04f4b2 (\"bpf: verifier: remove\ndead code\") in that we miss some of the jump offset adjustments\nafter code patching when we remove dead code, more concretely,\nupon backward jump spanning over the area that is being removed.\n\nBPF insns of a case that was hit pre 52875a04f4b2:\n\n  [...]\n  676: (85) call bpf_perf_event_output#-47616\n  677: (05) goto pc-636\n  678: (62) *(u32 *)(r10 -64) = 0\n  679: (bf) r7 = r10\n  680: (07) r7 += -64\n  681: (05) goto pc-44\n  682: (05) goto pc-1\n  683: (05) goto pc-1\n\nBPF insns afterwards:\n\n  [...]\n  618: (85) call bpf_perf_event_output#-47616\n  619: (05) goto pc-638\n  620: (62) *(u32 *)(r10 -64) = 0\n  621: (bf) r7 = r10\n  622: (07) r7 += -64\n  623: (05) goto pc-44\n\nTo illustrate the bug, situation looks as follows:\n     ____\n  0 |    | <-- foo: [...]\n  1 |____|\n  2 |____| <-- pos / end_new  ^\n  3 |    |                    |\n  4 |    |                    |  len\n  5 |____|                    |  (remove region)\n  6 |    | <-- end_old        v\n  7 |    |\n  8 |    | <-- curr  (jmp foo)\n  9 |____|\n\nThe condition curr >= end_new && curr + off + 1 < end_new in the\nbranch delta adjustments is never hit because curr + off + 1 <\nend_new is compared as unsigned and therefore curr + off + 1 >\nend_new in unsigned realm as curr + off + 1 becomes negative\nsince the insns are memmove()'d before the offset adjustments.\n\nCorrect BPF insns after this fix:\n\n  [...]\n  618: (85) call bpf_perf_event_output#-47216\n  619: (05) goto pc-578\n  620: (62) *(u32 *)(r10 -64) = 0\n  621: (bf) r7 = r10\n  622: (07) r7 += -64\n  623: (05) goto pc-44\n\nNote that unprivileged case is not affected from this.\n\nFixes: 52875a04f4b2 (\"bpf: verifier: remove dead code\")\nFixes: 2cbd95a5c4fb (\"bpf: change parameters of call/branch offset adjustment\")\nReported-by: Frank Ch. Eigler <fche@redhat.com>\nSigned-off-by: Daniel Borkmann <daniel@iogearbox.net>\nReviewed-by: Jakub Kicinski <jakub.kicinski@netronome.com>\nSigned-off-by: Alexei Starovoitov <ast@kernel.org>",
        "before_after_code_files": [
          "kernel/bpf/core.c||kernel/bpf/core.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "kernel/bpf/core.c||kernel/bpf/core.c"
          ],
          "candidate": [
            "kernel/bpf/core.c||kernel/bpf/core.c"
          ]
        }
      },
      "candidate_diff": {
        "kernel/bpf/core.c||kernel/bpf/core.c": [
          "File: kernel/bpf/core.c -> kernel/bpf/core.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "338: }",
          "340: static int bpf_adj_delta_to_imm(struct bpf_insn *insn, u32 pos, s32 end_old,",
          "342: {",
          "343:  const s64 imm_min = S32_MIN, imm_max = S32_MAX;",
          "344:  s32 delta = end_new - end_old;",
          "",
          "[Removed Lines]",
          "341:     s32 end_new, u32 curr, const bool probe_pass)",
          "",
          "[Added Lines]",
          "341:     s32 end_new, s32 curr, const bool probe_pass)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "356: }",
          "358: static int bpf_adj_delta_to_off(struct bpf_insn *insn, u32 pos, s32 end_old,",
          "360: {",
          "361:  const s32 off_min = S16_MIN, off_max = S16_MAX;",
          "362:  s32 delta = end_new - end_old;",
          "",
          "[Removed Lines]",
          "359:     s32 end_new, u32 curr, const bool probe_pass)",
          "",
          "[Added Lines]",
          "359:     s32 end_new, s32 curr, const bool probe_pass)",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "4f73379ec5c2891598aa715c6df7ac9afdc86fbf",
      "candidate_info": {
        "commit_hash": "4f73379ec5c2891598aa715c6df7ac9afdc86fbf",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/4f73379ec5c2891598aa715c6df7ac9afdc86fbf",
        "files": [
          "kernel/bpf/core.c",
          "kernel/bpf/verifier.c"
        ],
        "message": "bpf: verbose jump offset overflow check\n\nLarger programs may trigger 16-bit jump offset overflow check\nduring instruction patching. Make this error verbose otherwise\nusers cannot decipher error code without printks in the verifier.\n\nSigned-off-by: Alexei Starovoitov <ast@kernel.org>\nSigned-off-by: Daniel Borkmann <daniel@iogearbox.net>",
        "before_after_code_files": [
          "kernel/bpf/core.c||kernel/bpf/core.c",
          "kernel/bpf/verifier.c||kernel/bpf/verifier.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "kernel/bpf/core.c||kernel/bpf/core.c"
          ],
          "candidate": [
            "kernel/bpf/core.c||kernel/bpf/core.c"
          ]
        }
      },
      "candidate_diff": {
        "kernel/bpf/core.c||kernel/bpf/core.c": [
          "File: kernel/bpf/core.c -> kernel/bpf/core.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "438:  u32 insn_adj_cnt, insn_rest, insn_delta = len - 1;",
          "439:  const u32 cnt_max = S16_MAX;",
          "440:  struct bpf_prog *prog_adj;",
          "443:  if (insn_delta == 0) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "441:  int err;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "455:  if (insn_adj_cnt > cnt_max &&",
          "",
          "[Removed Lines]",
          "456:      bpf_adj_branches(prog, off, off + 1, off + len, true))",
          "457:   return NULL;",
          "",
          "[Added Lines]",
          "457:      (err = bpf_adj_branches(prog, off, off + 1, off + len, true)))",
          "458:   return ERR_PTR(err);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "463:  prog_adj = bpf_prog_realloc(prog, bpf_prog_size(insn_adj_cnt),",
          "464:         GFP_USER);",
          "465:  if (!prog_adj)",
          "468:  prog_adj->len = insn_adj_cnt;",
          "",
          "[Removed Lines]",
          "466:   return NULL;",
          "",
          "[Added Lines]",
          "467:   return ERR_PTR(-ENOMEM);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1096:    continue;",
          "1098:   tmp = bpf_patch_insn_single(clone, i, insn_buff, rewritten);",
          "1104:    bpf_jit_prog_release_other(prog, clone);",
          "1106:   }",
          "1108:   clone = tmp;",
          "",
          "[Removed Lines]",
          "1099:   if (!tmp) {",
          "1105:    return ERR_PTR(-ENOMEM);",
          "",
          "[Added Lines]",
          "1100:   if (IS_ERR(tmp)) {",
          "1106:    return tmp;",
          "",
          "---------------"
        ],
        "kernel/bpf/verifier.c||kernel/bpf/verifier.c": [
          "File: kernel/bpf/verifier.c -> kernel/bpf/verifier.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "6932:  struct bpf_prog *new_prog;",
          "6934:  new_prog = bpf_patch_insn_single(env->prog, off, patch, len);",
          "6936:   return NULL;",
          "6937:  if (adjust_insn_aux_data(env, new_prog->len, off, len))",
          "6938:   return NULL;",
          "6939:  adjust_subprog_starts(env, off, len);",
          "",
          "[Removed Lines]",
          "6935:  if (!new_prog)",
          "",
          "[Added Lines]",
          "6935:  if (IS_ERR(new_prog)) {",
          "6936:   if (PTR_ERR(new_prog) == -ERANGE)",
          "6937:    verbose(env,",
          "6938:     \"insn %d cannot be patched due to 16-bit range\\n\",",
          "6939:     env->insn_aux_data[off].orig_idx);",
          "6941:  }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "2cbd95a5c4fb855a4177c0343a880cc2091f500d",
      "candidate_info": {
        "commit_hash": "2cbd95a5c4fb855a4177c0343a880cc2091f500d",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/2cbd95a5c4fb855a4177c0343a880cc2091f500d",
        "files": [
          "kernel/bpf/core.c"
        ],
        "message": "bpf: change parameters of call/branch offset adjustment\n\nIn preparation for code removal change parameters to branch\nand call adjustment functions to be more universal.  The\ncurrent parameters assume we are patching a single instruction\nwith a longer set.\n\nA diagram may help reading the change, this is for the patch\nsingle case, patching instruction 1 with a replacement of 4:\n   ____\n0 |____|\n1 |____| <-- pos                ^\n2 |    | <-- end old  ^         |\n3 |    |              |  delta  |  len\n4 |____|              |         |  (patch region)\n5 |    | <-- end new  v         v\n6 |____|\n\nend_old = pos + 1\nend_new = pos + delta + 1\n\nIf we are before the patch region - curr variable and the target\nare fully in old coordinates (hence comparing against end_old).\nIf we are after the region curr is in new coordinates (hence\nthe comparison to end_new) but target is in mixed coordinates,\nso we just check if it falls before end_new, and if so it needs\nthe adjustment.\n\nNote that we will not fix up branches which land in removed region\nin case of removal, which should be okay, as we are only going to\nremove dead code.\n\nSigned-off-by: Jakub Kicinski <jakub.kicinski@netronome.com>\nAcked-by: Yonghong Song <yhs@fb.com>\nSigned-off-by: Alexei Starovoitov <ast@kernel.org>",
        "before_after_code_files": [
          "kernel/bpf/core.c||kernel/bpf/core.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "kernel/bpf/core.c||kernel/bpf/core.c"
          ],
          "candidate": [
            "kernel/bpf/core.c||kernel/bpf/core.c"
          ]
        }
      },
      "candidate_diff": {
        "kernel/bpf/core.c||kernel/bpf/core.c": [
          "File: kernel/bpf/core.c -> kernel/bpf/core.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "307:  return 0;",
          "308: }",
          "312: {",
          "313:  const s64 imm_min = S32_MIN, imm_max = S32_MAX;",
          "314:  s64 imm = insn->imm;",
          "317:   imm += delta;",
          "319:   imm -= delta;",
          "320:  if (imm < imm_min || imm > imm_max)",
          "321:   return -ERANGE;",
          "",
          "[Removed Lines]",
          "310: static int bpf_adj_delta_to_imm(struct bpf_insn *insn, u32 pos, u32 delta,",
          "311:     u32 curr, const bool probe_pass)",
          "316:  if (curr < pos && curr + imm + 1 > pos)",
          "318:  else if (curr > pos + delta && curr + imm + 1 <= pos + delta)",
          "",
          "[Added Lines]",
          "310: static int bpf_adj_delta_to_imm(struct bpf_insn *insn, u32 pos, s32 end_old,",
          "311:     s32 end_new, u32 curr, const bool probe_pass)",
          "314:  s32 delta = end_new - end_old;",
          "317:  if (curr < pos && curr + imm + 1 >= end_old)",
          "319:  else if (curr >= end_new && curr + imm + 1 < end_new)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "324:  return 0;",
          "325: }",
          "329: {",
          "330:  const s32 off_min = S16_MIN, off_max = S16_MAX;",
          "331:  s32 off = insn->off;",
          "334:   off += delta;",
          "336:   off -= delta;",
          "337:  if (off < off_min || off > off_max)",
          "338:   return -ERANGE;",
          "",
          "[Removed Lines]",
          "327: static int bpf_adj_delta_to_off(struct bpf_insn *insn, u32 pos, u32 delta,",
          "328:     u32 curr, const bool probe_pass)",
          "333:  if (curr < pos && curr + off + 1 > pos)",
          "335:  else if (curr > pos + delta && curr + off + 1 <= pos + delta)",
          "",
          "[Added Lines]",
          "328: static int bpf_adj_delta_to_off(struct bpf_insn *insn, u32 pos, s32 end_old,",
          "329:     s32 end_new, u32 curr, const bool probe_pass)",
          "332:  s32 delta = end_new - end_old;",
          "335:  if (curr < pos && curr + off + 1 >= end_old)",
          "337:  else if (curr >= end_new && curr + off + 1 < end_new)",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "341:  return 0;",
          "342: }",
          "346: {",
          "348:  struct bpf_insn *insn = prog->insnsi;",
          "349:  int ret = 0;",
          "",
          "[Removed Lines]",
          "344: static int bpf_adj_branches(struct bpf_prog *prog, u32 pos, u32 delta,",
          "345:        const bool probe_pass)",
          "347:  u32 i, insn_cnt = prog->len + (probe_pass ? delta : 0);",
          "",
          "[Added Lines]",
          "346: static int bpf_adj_branches(struct bpf_prog *prog, u32 pos, s32 end_old,",
          "347:        s32 end_new, const bool probe_pass)",
          "349:  u32 i, insn_cnt = prog->len + (probe_pass ? end_new - end_old : 0);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "358:   if (probe_pass && i == pos) {",
          "361:   }",
          "362:   code = insn->code;",
          "363:   if (BPF_CLASS(code) != BPF_JMP ||",
          "",
          "[Removed Lines]",
          "359:    i += delta + 1;",
          "360:    insn++;",
          "",
          "[Added Lines]",
          "361:    i = end_new;",
          "362:    insn = prog->insnsi + end_old;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "367:   if (BPF_OP(code) == BPF_CALL) {",
          "368:    if (insn->src_reg != BPF_PSEUDO_CALL)",
          "369:     continue;",
          "372:   } else {",
          "375:   }",
          "376:   if (ret)",
          "377:    break;",
          "",
          "[Removed Lines]",
          "370:    ret = bpf_adj_delta_to_imm(insn, pos, delta, i,",
          "371:          probe_pass);",
          "373:    ret = bpf_adj_delta_to_off(insn, pos, delta, i,",
          "374:          probe_pass);",
          "",
          "[Added Lines]",
          "372:    ret = bpf_adj_delta_to_imm(insn, pos, end_old,",
          "373:          end_new, i, probe_pass);",
          "375:    ret = bpf_adj_delta_to_off(insn, pos, end_old,",
          "376:          end_new, i, probe_pass);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "423:  if (insn_adj_cnt > cnt_max &&",
          "425:   return NULL;",
          "",
          "[Removed Lines]",
          "424:      bpf_adj_branches(prog, off, insn_delta, true))",
          "",
          "[Added Lines]",
          "426:      bpf_adj_branches(prog, off, off + 1, off + len, true))",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "458:  bpf_adj_linfo(prog_adj, off, insn_delta);",
          "",
          "[Removed Lines]",
          "456:  BUG_ON(bpf_adj_branches(prog_adj, off, insn_delta, false));",
          "",
          "[Added Lines]",
          "458:  BUG_ON(bpf_adj_branches(prog_adj, off, off + 1, off + len, false));",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "092ed0968bb648cd18e8a0430cd0a8a71727315c",
      "candidate_info": {
        "commit_hash": "092ed0968bb648cd18e8a0430cd0a8a71727315c",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/092ed0968bb648cd18e8a0430cd0a8a71727315c",
        "files": [
          "kernel/bpf/core.c",
          "kernel/bpf/verifier.c"
        ],
        "message": "bpf: verifier support JMP32\n\nThis patch teach verifier about the new BPF_JMP32 instruction class.\nVerifier need to treat it similar as the existing BPF_JMP class.\nA BPF_JMP32 insn needs to go through all checks that have been done on\nBPF_JMP.\n\nAlso, verifier is doing runtime optimizations based on the extra info\nconditional jump instruction could offer, especially when the comparison is\nbetween constant and register that the value range of the register could be\nimproved based on the comparison results. These code are updated\naccordingly.\n\nAcked-by: Jakub Kicinski <jakub.kicinski@netronome.com>\nSigned-off-by: Jiong Wang <jiong.wang@netronome.com>\nSigned-off-by: Alexei Starovoitov <ast@kernel.org>",
        "before_after_code_files": [
          "kernel/bpf/core.c||kernel/bpf/core.c",
          "kernel/bpf/verifier.c||kernel/bpf/verifier.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "kernel/bpf/core.c||kernel/bpf/core.c"
          ],
          "candidate": [
            "kernel/bpf/core.c||kernel/bpf/core.c"
          ]
        }
      },
      "candidate_diff": {
        "kernel/bpf/core.c||kernel/bpf/core.c": [
          "File: kernel/bpf/core.c -> kernel/bpf/core.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "362:    insn = prog->insnsi + end_old;",
          "363:   }",
          "364:   code = insn->code;",
          "366:       BPF_OP(code) == BPF_EXIT)",
          "367:    continue;",
          "",
          "[Removed Lines]",
          "365:   if (BPF_CLASS(code) != BPF_JMP ||",
          "",
          "[Added Lines]",
          "365:   if ((BPF_CLASS(code) != BPF_JMP &&",
          "366:        BPF_CLASS(code) != BPF_JMP32) ||",
          "",
          "---------------"
        ],
        "kernel/bpf/verifier.c||kernel/bpf/verifier.c": [
          "File: kernel/bpf/verifier.c -> kernel/bpf/verifier.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1095:  for (i = 0; i < insn_cnt; i++) {",
          "1096:   u8 code = insn[i].code;",
          "1099:    goto next;",
          "1100:   if (BPF_OP(code) == BPF_EXIT || BPF_OP(code) == BPF_CALL)",
          "1101:    goto next;",
          "",
          "[Removed Lines]",
          "1098:   if (BPF_CLASS(code) != BPF_JMP)",
          "",
          "[Added Lines]",
          "1098:   if (BPF_CLASS(code) != BPF_JMP && BPF_CLASS(code) != BPF_JMP32)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "4035: {",
          "4036:  s64 sval;",
          "4038:  if (__is_pointer_value(false, reg))",
          "4039:   return -1;",
          "4043:  switch (opcode) {",
          "4044:  case BPF_JEQ:",
          "",
          "[Removed Lines]",
          "4034: static int is_branch_taken(struct bpf_reg_state *reg, u64 val, u8 opcode)",
          "4041:  sval = (s64)val;",
          "",
          "[Added Lines]",
          "4034: static int is_branch_taken(struct bpf_reg_state *reg, u64 val, u8 opcode,",
          "4035:       bool is_jmp32)",
          "4037:  struct bpf_reg_state reg_lo;",
          "4043:  if (is_jmp32) {",
          "4044:   reg_lo = *reg;",
          "4045:   reg = &reg_lo;",
          "4050:   coerce_reg_to_size(reg, 4);",
          "4064:   if ((reg->umax_value ^ reg->umin_value) &",
          "4065:       (1ULL << 31)) {",
          "4066:    reg->smin_value = S32_MIN;",
          "4067:    reg->smax_value = S32_MAX;",
          "4068:   }",
          "4069:   reg->smin_value = (s64)(s32)reg->smin_value;",
          "4070:   reg->smax_value = (s64)(s32)reg->smax_value;",
          "4072:   val = (u32)val;",
          "4073:   sval = (s64)(s32)val;",
          "4074:  } else {",
          "4075:   sval = (s64)val;",
          "4076:  }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "4108:  return -1;",
          "4109: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4147: static u64 gen_hi_min(struct tnum var)",
          "4148: {",
          "4149:  return var.value & ~0xffffffffULL;",
          "4150: }",
          "4153: static u64 gen_hi_max(struct tnum var)",
          "4154: {",
          "4155:  return (var.value | var.mask) & ~0xffffffffULL;",
          "4156: }",
          "4161: static bool cmp_val_with_extended_s64(s64 sval, struct bpf_reg_state *reg)",
          "4162: {",
          "4163:  return ((s32)sval >= 0 &&",
          "4164:   reg->smin_value >= 0 && reg->smax_value <= S32_MAX) ||",
          "4165:         ((s32)sval < 0 &&",
          "4166:   reg->smax_value <= 0 && reg->smin_value >= S32_MIN);",
          "4167: }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "4116: static void reg_set_min_max(struct bpf_reg_state *true_reg,",
          "4117:        struct bpf_reg_state *false_reg, u64 val,",
          "4119: {",
          "4120:  s64 sval;",
          "",
          "[Removed Lines]",
          "4118:        u8 opcode)",
          "",
          "[Added Lines]",
          "4176:        u8 opcode, bool is_jmp32)",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "4128:  if (__is_pointer_value(false, false_reg))",
          "4129:   return;",
          "4133:  switch (opcode) {",
          "4134:  case BPF_JEQ:",
          "",
          "[Removed Lines]",
          "4131:  sval = (s64)val;",
          "",
          "[Added Lines]",
          "4189:  val = is_jmp32 ? (u32)val : val;",
          "4190:  sval = is_jmp32 ? (s64)(s32)val : (s64)val;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "4145:   break;",
          "4146:  }",
          "4147:  case BPF_JSET:",
          "",
          "[Removed Lines]",
          "4144:   __mark_reg_known(reg, val);",
          "",
          "[Added Lines]",
          "4203:   if (is_jmp32) {",
          "4204:    u64 old_v = reg->var_off.value;",
          "4205:    u64 hi_mask = ~0xffffffffULL;",
          "4207:    reg->var_off.value = (old_v & hi_mask) | val;",
          "4208:    reg->var_off.mask &= hi_mask;",
          "4209:   } else {",
          "4210:    __mark_reg_known(reg, val);",
          "4211:   }",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "4157:   u64 false_umax = opcode == BPF_JGT ? val    : val - 1;",
          "4158:   u64 true_umin = opcode == BPF_JGT ? val + 1 : val;",
          "4160:   false_reg->umax_value = min(false_reg->umax_value, false_umax);",
          "4161:   true_reg->umin_value = max(true_reg->umin_value, true_umin);",
          "4162:   break;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4227:   if (is_jmp32) {",
          "4228:    false_umax += gen_hi_max(false_reg->var_off);",
          "4229:    true_umin += gen_hi_min(true_reg->var_off);",
          "4230:   }",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "4167:   s64 false_smax = opcode == BPF_JSGT ? sval    : sval - 1;",
          "4168:   s64 true_smin = opcode == BPF_JSGT ? sval + 1 : sval;",
          "4170:   false_reg->smax_value = min(false_reg->smax_value, false_smax);",
          "4171:   true_reg->smin_value = max(true_reg->smin_value, true_smin);",
          "4172:   break;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4244:   if (is_jmp32 && !cmp_val_with_extended_s64(sval, false_reg))",
          "4245:    break;",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "4177:   u64 false_umin = opcode == BPF_JLT ? val    : val + 1;",
          "4178:   u64 true_umax = opcode == BPF_JLT ? val - 1 : val;",
          "4180:   false_reg->umin_value = max(false_reg->umin_value, false_umin);",
          "4181:   true_reg->umax_value = min(true_reg->umax_value, true_umax);",
          "4182:   break;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4256:   if (is_jmp32) {",
          "4257:    false_umin += gen_hi_min(false_reg->var_off);",
          "4258:    true_umax += gen_hi_max(true_reg->var_off);",
          "4259:   }",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "4187:   s64 false_smin = opcode == BPF_JSLT ? sval    : sval + 1;",
          "4188:   s64 true_smax = opcode == BPF_JSLT ? sval - 1 : sval;",
          "4190:   false_reg->smin_value = max(false_reg->smin_value, false_smin);",
          "4191:   true_reg->smax_value = min(true_reg->smax_value, true_smax);",
          "4192:   break;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4270:   if (is_jmp32 && !cmp_val_with_extended_s64(sval, false_reg))",
          "4271:    break;",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "4214: static void reg_set_min_max_inv(struct bpf_reg_state *true_reg,",
          "4215:     struct bpf_reg_state *false_reg, u64 val,",
          "4217: {",
          "4218:  s64 sval;",
          "4220:  if (__is_pointer_value(false, false_reg))",
          "4221:   return;",
          "4225:  switch (opcode) {",
          "4226:  case BPF_JEQ:",
          "",
          "[Removed Lines]",
          "4216:     u8 opcode)",
          "4223:  sval = (s64)val;",
          "",
          "[Added Lines]",
          "4298:     u8 opcode, bool is_jmp32)",
          "4305:  val = is_jmp32 ? (u32)val : val;",
          "4306:  sval = is_jmp32 ? (s64)(s32)val : (s64)val;",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "4229:   struct bpf_reg_state *reg =",
          "4230:    opcode == BPF_JEQ ? true_reg : false_reg;",
          "4233:   break;",
          "4234:  }",
          "4235:  case BPF_JSET:",
          "",
          "[Removed Lines]",
          "4232:   __mark_reg_known(reg, val);",
          "",
          "[Added Lines]",
          "4315:   if (is_jmp32) {",
          "4316:    u64 old_v = reg->var_off.value;",
          "4317:    u64 hi_mask = ~0xffffffffULL;",
          "4319:    reg->var_off.value = (old_v & hi_mask) | val;",
          "4320:    reg->var_off.mask &= hi_mask;",
          "4321:   } else {",
          "4322:    __mark_reg_known(reg, val);",
          "4323:   }",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "4245:   u64 false_umin = opcode == BPF_JGT ? val    : val + 1;",
          "4246:   u64 true_umax = opcode == BPF_JGT ? val - 1 : val;",
          "4248:   false_reg->umin_value = max(false_reg->umin_value, false_umin);",
          "4249:   true_reg->umax_value = min(true_reg->umax_value, true_umax);",
          "4250:   break;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4339:   if (is_jmp32) {",
          "4340:    false_umin += gen_hi_min(false_reg->var_off);",
          "4341:    true_umax += gen_hi_max(true_reg->var_off);",
          "4342:   }",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "4255:   s64 false_smin = opcode == BPF_JSGT ? sval    : sval + 1;",
          "4256:   s64 true_smax = opcode == BPF_JSGT ? sval - 1 : sval;",
          "4258:   false_reg->smin_value = max(false_reg->smin_value, false_smin);",
          "4259:   true_reg->smax_value = min(true_reg->smax_value, true_smax);",
          "4260:   break;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4353:   if (is_jmp32 && !cmp_val_with_extended_s64(sval, false_reg))",
          "4354:    break;",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "4265:   u64 false_umax = opcode == BPF_JLT ? val    : val - 1;",
          "4266:   u64 true_umin = opcode == BPF_JLT ? val + 1 : val;",
          "4268:   false_reg->umax_value = min(false_reg->umax_value, false_umax);",
          "4269:   true_reg->umin_value = max(true_reg->umin_value, true_umin);",
          "4270:   break;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4365:   if (is_jmp32) {",
          "4366:    false_umax += gen_hi_max(false_reg->var_off);",
          "4367:    true_umin += gen_hi_min(true_reg->var_off);",
          "4368:   }",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "4275:   s64 false_smax = opcode == BPF_JSLT ? sval    : sval - 1;",
          "4276:   s64 true_smin = opcode == BPF_JSLT ? sval + 1 : sval;",
          "4278:   false_reg->smax_value = min(false_reg->smax_value, false_smax);",
          "4279:   true_reg->smin_value = max(true_reg->smin_value, true_smin);",
          "4280:   break;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4379:   if (is_jmp32 && !cmp_val_with_extended_s64(sval, false_reg))",
          "4380:    break;",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "4416:  if (BPF_SRC(insn->code) != BPF_X)",
          "4417:   return false;",
          "4419:  switch (BPF_OP(insn->code)) {",
          "4420:  case BPF_JGT:",
          "4421:   if ((dst_reg->type == PTR_TO_PACKET &&",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4523:  if (BPF_CLASS(insn->code) == BPF_JMP32)",
          "4524:   return false;",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "4508:  struct bpf_reg_state *regs = this_branch->frame[this_branch->curframe]->regs;",
          "4509:  struct bpf_reg_state *dst_reg, *other_branch_regs;",
          "4510:  u8 opcode = BPF_OP(insn->code);",
          "4511:  int err;",
          "4515:   return -EINVAL;",
          "4516:  }",
          "4518:  if (BPF_SRC(insn->code) == BPF_X) {",
          "4519:   if (insn->imm != 0) {",
          "4521:    return -EINVAL;",
          "4522:   }",
          "",
          "[Removed Lines]",
          "4513:  if (opcode > BPF_JSLE) {",
          "4514:   verbose(env, \"invalid BPF_JMP opcode %x\\n\", opcode);",
          "4520:    verbose(env, \"BPF_JMP uses reserved fields\\n\");",
          "",
          "[Added Lines]",
          "4618:  bool is_jmp32;",
          "4622:  if (opcode == BPF_JA || opcode > BPF_JSLE) {",
          "4623:   verbose(env, \"invalid BPF_JMP/JMP32 opcode %x\\n\", opcode);",
          "4629:    verbose(env, \"BPF_JMP/JMP32 uses reserved fields\\n\");",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "4533:   }",
          "4534:  } else {",
          "4535:   if (insn->src_reg != BPF_REG_0) {",
          "4537:    return -EINVAL;",
          "4538:   }",
          "4539:  }",
          "",
          "[Removed Lines]",
          "4536:    verbose(env, \"BPF_JMP uses reserved fields\\n\");",
          "",
          "[Added Lines]",
          "4645:    verbose(env, \"BPF_JMP/JMP32 uses reserved fields\\n\");",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "4544:   return err;",
          "4546:  dst_reg = &regs[insn->dst_reg];",
          "4548:  if (BPF_SRC(insn->code) == BPF_K) {",
          "4551:   if (pred == 1) {",
          "",
          "[Removed Lines]",
          "4549:   int pred = is_branch_taken(dst_reg, insn->imm, opcode);",
          "",
          "[Added Lines]",
          "4656:  is_jmp32 = BPF_CLASS(insn->code) == BPF_JMP32;",
          "4659:   int pred = is_branch_taken(dst_reg, insn->imm, opcode,",
          "4660:         is_jmp32);",
          "",
          "---------------",
          "--- Hunk 21 ---",
          "[Context before]",
          "4576:  if (BPF_SRC(insn->code) == BPF_X) {",
          "4577:   if (dst_reg->type == SCALAR_VALUE &&",
          "4580:     reg_set_min_max(&other_branch_regs[insn->dst_reg],",
          "4584:     reg_set_min_max_inv(&other_branch_regs[insn->src_reg],",
          "4589:     reg_combine_min_max(&other_branch_regs[insn->src_reg],",
          "4590:           &other_branch_regs[insn->dst_reg],",
          "4593:   }",
          "4594:  } else if (dst_reg->type == SCALAR_VALUE) {",
          "4595:   reg_set_min_max(&other_branch_regs[insn->dst_reg],",
          "4597:  }",
          "4601:      insn->imm == 0 && (opcode == BPF_JEQ || opcode == BPF_JNE) &&",
          "4602:      reg_type_may_be_null(dst_reg->type)) {",
          "",
          "[Removed Lines]",
          "4578:       regs[insn->src_reg].type == SCALAR_VALUE) {",
          "4579:    if (tnum_is_const(regs[insn->src_reg].var_off))",
          "4581:       dst_reg, regs[insn->src_reg].var_off.value,",
          "4582:       opcode);",
          "4583:    else if (tnum_is_const(dst_reg->var_off))",
          "4585:           &regs[insn->src_reg],",
          "4586:           dst_reg->var_off.value, opcode);",
          "4587:    else if (opcode == BPF_JEQ || opcode == BPF_JNE)",
          "4591:           &regs[insn->src_reg],",
          "4592:           &regs[insn->dst_reg], opcode);",
          "4596:      dst_reg, insn->imm, opcode);",
          "4600:  if (BPF_SRC(insn->code) == BPF_K &&",
          "",
          "[Added Lines]",
          "4688:   struct bpf_reg_state *src_reg = &regs[insn->src_reg];",
          "4689:   struct bpf_reg_state lo_reg0 = *dst_reg;",
          "4690:   struct bpf_reg_state lo_reg1 = *src_reg;",
          "4691:   struct bpf_reg_state *src_lo, *dst_lo;",
          "4693:   dst_lo = &lo_reg0;",
          "4694:   src_lo = &lo_reg1;",
          "4695:   coerce_reg_to_size(dst_lo, 4);",
          "4696:   coerce_reg_to_size(src_lo, 4);",
          "4699:       src_reg->type == SCALAR_VALUE) {",
          "4700:    if (tnum_is_const(src_reg->var_off) ||",
          "4701:        (is_jmp32 && tnum_is_const(src_lo->var_off)))",
          "4703:       dst_reg,",
          "4704:       is_jmp32",
          "4705:       ? src_lo->var_off.value",
          "4706:       : src_reg->var_off.value,",
          "4707:       opcode, is_jmp32);",
          "4708:    else if (tnum_is_const(dst_reg->var_off) ||",
          "4709:      (is_jmp32 && tnum_is_const(dst_lo->var_off)))",
          "4711:           src_reg,",
          "4712:           is_jmp32",
          "4713:           ? dst_lo->var_off.value",
          "4714:           : dst_reg->var_off.value,",
          "4715:           opcode, is_jmp32);",
          "4716:    else if (!is_jmp32 &&",
          "4717:      (opcode == BPF_JEQ || opcode == BPF_JNE))",
          "4721:           src_reg, dst_reg, opcode);",
          "4725:      dst_reg, insn->imm, opcode, is_jmp32);",
          "4732:  if (!is_jmp32 && BPF_SRC(insn->code) == BPF_K &&",
          "",
          "---------------",
          "--- Hunk 22 ---",
          "[Context before]",
          "4926:   goto check_state;",
          "4927:  t = insn_stack[cur_stack - 1];",
          "4930:   u8 opcode = BPF_OP(insns[t].code);",
          "4932:   if (opcode == BPF_EXIT) {",
          "",
          "[Removed Lines]",
          "4929:  if (BPF_CLASS(insns[t].code) == BPF_JMP) {",
          "",
          "[Added Lines]",
          "5061:  if (BPF_CLASS(insns[t].code) == BPF_JMP ||",
          "5062:      BPF_CLASS(insns[t].code) == BPF_JMP32) {",
          "",
          "---------------",
          "--- Hunk 23 ---",
          "[Context before]",
          "6082:    if (err)",
          "6083:     return err;",
          "6086:    u8 opcode = BPF_OP(insn->code);",
          "6088:    if (opcode == BPF_CALL) {",
          "",
          "[Removed Lines]",
          "6085:   } else if (class == BPF_JMP) {",
          "",
          "[Added Lines]",
          "6218:   } else if (class == BPF_JMP || class == BPF_JMP32) {",
          "",
          "---------------",
          "--- Hunk 24 ---",
          "[Context before]",
          "6090:         insn->off != 0 ||",
          "6091:         (insn->src_reg != BPF_REG_0 &&",
          "6092:          insn->src_reg != BPF_PSEUDO_CALL) ||",
          "6094:      verbose(env, \"BPF_CALL uses reserved fields\\n\");",
          "6095:      return -EINVAL;",
          "6096:     }",
          "",
          "[Removed Lines]",
          "6093:         insn->dst_reg != BPF_REG_0) {",
          "",
          "[Added Lines]",
          "6226:         insn->dst_reg != BPF_REG_0 ||",
          "6227:         class == BPF_JMP32) {",
          "",
          "---------------",
          "--- Hunk 25 ---",
          "[Context before]",
          "6106:     if (BPF_SRC(insn->code) != BPF_K ||",
          "6107:         insn->imm != 0 ||",
          "6108:         insn->src_reg != BPF_REG_0 ||",
          "6110:      verbose(env, \"BPF_JA uses reserved fields\\n\");",
          "6111:      return -EINVAL;",
          "6112:     }",
          "",
          "[Removed Lines]",
          "6109:         insn->dst_reg != BPF_REG_0) {",
          "",
          "[Added Lines]",
          "6243:         insn->dst_reg != BPF_REG_0 ||",
          "6244:         class == BPF_JMP32) {",
          "",
          "---------------",
          "--- Hunk 26 ---",
          "[Context before]",
          "6118:     if (BPF_SRC(insn->code) != BPF_K ||",
          "6119:         insn->imm != 0 ||",
          "6120:         insn->src_reg != BPF_REG_0 ||",
          "6122:      verbose(env, \"BPF_EXIT uses reserved fields\\n\");",
          "6123:      return -EINVAL;",
          "6124:     }",
          "",
          "[Removed Lines]",
          "6121:         insn->dst_reg != BPF_REG_0) {",
          "",
          "[Added Lines]",
          "6256:         insn->dst_reg != BPF_REG_0 ||",
          "6257:         class == BPF_JMP32) {",
          "",
          "---------------",
          "--- Hunk 27 ---",
          "[Context before]",
          "6635: {",
          "6636:  u8 op;",
          "6638:  if (BPF_CLASS(code) != BPF_JMP)",
          "6639:   return false;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "6774:  if (BPF_CLASS(code) == BPF_JMP32)",
          "6775:   return true;",
          "",
          "---------------"
        ]
      }
    }
  ]
}
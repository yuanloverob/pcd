{
  "cve_id": "CVE-2017-6346",
  "cve_desc": "Race condition in net/packet/af_packet.c in the Linux kernel before 4.9.13 allows local users to cause a denial of service (use-after-free) or possibly have unspecified other impact via a multithreaded application that makes PACKET_FANOUT setsockopt system calls.",
  "repo": "torvalds/linux",
  "patch_hash": "d199fab63c11998a602205f7ee7ff7c05c97164b",
  "patch_info": {
    "commit_hash": "d199fab63c11998a602205f7ee7ff7c05c97164b",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/d199fab63c11998a602205f7ee7ff7c05c97164b",
    "files": [
      "net/packet/af_packet.c"
    ],
    "message": "packet: fix races in fanout_add()\n\nMultiple threads can call fanout_add() at the same time.\n\nWe need to grab fanout_mutex earlier to avoid races that could\nlead to one thread freeing po->rollover that was set by another thread.\n\nDo the same in fanout_release(), for peace of mind, and to help us\nfinding lockdep issues earlier.\n\nFixes: dc99f600698d (\"packet: Add fanout support.\")\nFixes: 0648ab70afe6 (\"packet: rollover prepare: per-socket state\")\nSigned-off-by: Eric Dumazet <edumazet@google.com>\nCc: Willem de Bruijn <willemb@google.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
    "before_after_code_files": [
      "net/packet/af_packet.c||net/packet/af_packet.c"
    ]
  },
  "patch_diff": {
    "net/packet/af_packet.c||net/packet/af_packet.c": [
      "File: net/packet/af_packet.c -> net/packet/af_packet.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "1620: static int fanout_add(struct sock *sk, u16 id, u16 type_flags)",
      "1621: {",
      "1622:  struct packet_sock *po = pkt_sk(sk);",
      "1623:  struct packet_fanout *f, *match;",
      "1624:  u8 type = type_flags & 0xff;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1622:  struct packet_rollover *rollover = NULL;",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "1641:   return -EINVAL;",
      "1642:  }",
      "1644:  if (!po->running)",
      "1647:  if (po->fanout)",
      "1650:  if (type == PACKET_FANOUT_ROLLOVER ||",
      "1651:      (type_flags & PACKET_FANOUT_FLAG_ROLLOVER)) {",
      "1658:  }",
      "1661:  match = NULL;",
      "1662:  list_for_each_entry(f, &fanout_list, list) {",
      "1663:   if (f->id == id &&",
      "",
      "[Removed Lines]",
      "1645:   return -EINVAL;",
      "1648:   return -EALREADY;",
      "1652:   po->rollover = kzalloc(sizeof(*po->rollover), GFP_KERNEL);",
      "1653:   if (!po->rollover)",
      "1654:    return -ENOMEM;",
      "1655:   atomic_long_set(&po->rollover->num, 0);",
      "1656:   atomic_long_set(&po->rollover->num_huge, 0);",
      "1657:   atomic_long_set(&po->rollover->num_failed, 0);",
      "1660:  mutex_lock(&fanout_mutex);",
      "",
      "[Added Lines]",
      "1645:  mutex_lock(&fanout_mutex);",
      "1647:  err = -EINVAL;",
      "1649:   goto out;",
      "1651:  err = -EALREADY;",
      "1653:   goto out;",
      "1657:   err = -ENOMEM;",
      "1658:   rollover = kzalloc(sizeof(*rollover), GFP_KERNEL);",
      "1659:   if (!rollover)",
      "1660:    goto out;",
      "1661:   atomic_long_set(&rollover->num, 0);",
      "1662:   atomic_long_set(&rollover->num_huge, 0);",
      "1663:   atomic_long_set(&rollover->num_failed, 0);",
      "1664:   po->rollover = rollover;",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "1704:   }",
      "1705:  }",
      "1706: out:",
      "1710:   po->rollover = NULL;",
      "1711:  }",
      "1712:  return err;",
      "1713: }",
      "",
      "[Removed Lines]",
      "1707:  mutex_unlock(&fanout_mutex);",
      "1708:  if (err) {",
      "1709:   kfree(po->rollover);",
      "",
      "[Added Lines]",
      "1713:  if (err && rollover) {",
      "1714:   kfree(rollover);",
      "1717:  mutex_unlock(&fanout_mutex);",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "1717:  struct packet_sock *po = pkt_sk(sk);",
      "1718:  struct packet_fanout *f;",
      "1724:  mutex_lock(&fanout_mutex);",
      "1732:  }",
      "1733:  mutex_unlock(&fanout_mutex);",
      "1737: }",
      "1739: static bool packet_extra_vlan_len_allowed(const struct net_device *dev,",
      "",
      "[Removed Lines]",
      "1720:  f = po->fanout;",
      "1721:  if (!f)",
      "1722:   return;",
      "1725:  po->fanout = NULL;",
      "1727:  if (atomic_dec_and_test(&f->sk_ref)) {",
      "1728:   list_del(&f->list);",
      "1729:   dev_remove_pack(&f->prot_hook);",
      "1730:   fanout_release_data(f);",
      "1731:   kfree(f);",
      "1735:  if (po->rollover)",
      "1736:   kfree_rcu(po->rollover, rcu);",
      "",
      "[Added Lines]",
      "1727:  f = po->fanout;",
      "1728:  if (f) {",
      "1729:   po->fanout = NULL;",
      "1731:   if (atomic_dec_and_test(&f->sk_ref)) {",
      "1732:    list_del(&f->list);",
      "1733:    dev_remove_pack(&f->prot_hook);",
      "1734:    fanout_release_data(f);",
      "1735:    kfree(f);",
      "1736:   }",
      "1738:   if (po->rollover)",
      "1739:    kfree_rcu(po->rollover, rcu);",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "fb5c2c17a556d9b00798d6a6b9e624281ee2eb28",
      "candidate_info": {
        "commit_hash": "fb5c2c17a556d9b00798d6a6b9e624281ee2eb28",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/fb5c2c17a556d9b00798d6a6b9e624281ee2eb28",
        "files": [
          "net/packet/af_packet.c",
          "net/packet/internal.h"
        ],
        "message": "net: convert packet_fanout.sk_ref from atomic_t to refcount_t\n\nrefcount_t type and corresponding API should be\nused instead of atomic_t when the variable is used as\na reference counter. This allows to avoid accidental\nrefcounter overflows that might lead to use-after-free\nsituations.\n\nSigned-off-by: Elena Reshetova <elena.reshetova@intel.com>\nSigned-off-by: Hans Liljestrand <ishkamiel@gmail.com>\nSigned-off-by: Kees Cook <keescook@chromium.org>\nSigned-off-by: David Windsor <dwindsor@gmail.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "before_after_code_files": [
          "net/packet/af_packet.c||net/packet/af_packet.c",
          "net/packet/internal.h||net/packet/internal.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "net/packet/af_packet.c||net/packet/af_packet.c"
          ],
          "candidate": [
            "net/packet/af_packet.c||net/packet/af_packet.c"
          ]
        }
      },
      "candidate_diff": {
        "net/packet/af_packet.c||net/packet/af_packet.c": [
          "File: net/packet/af_packet.c -> net/packet/af_packet.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1739:   match->flags = flags;",
          "1740:   INIT_LIST_HEAD(&match->list);",
          "1741:   spin_lock_init(&match->lock);",
          "1743:   fanout_init_data(match);",
          "1744:   match->prot_hook.type = po->prot_hook.type;",
          "1745:   match->prot_hook.dev = po->prot_hook.dev;",
          "",
          "[Removed Lines]",
          "1742:   atomic_set(&match->sk_ref, 0);",
          "",
          "[Added Lines]",
          "1742:   refcount_set(&match->sk_ref, 0);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1753:      match->prot_hook.type == po->prot_hook.type &&",
          "1754:      match->prot_hook.dev == po->prot_hook.dev) {",
          "1755:   err = -ENOSPC;",
          "1757:    __dev_remove_pack(&po->prot_hook);",
          "1758:    po->fanout = match;",
          "1760:    __fanout_link(sk, po);",
          "1761:    err = 0;",
          "1762:   }",
          "",
          "[Removed Lines]",
          "1756:   if (atomic_read(&match->sk_ref) < PACKET_FANOUT_MAX) {",
          "1759:    atomic_inc(&match->sk_ref);",
          "",
          "[Added Lines]",
          "1756:   if (refcount_read(&match->sk_ref) < PACKET_FANOUT_MAX) {",
          "1759:    refcount_set(&match->sk_ref, refcount_read(&match->sk_ref) + 1);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1785:  if (f) {",
          "1786:   po->fanout = NULL;",
          "1789:    list_del(&f->list);",
          "1790:   else",
          "1791:    f = NULL;",
          "",
          "[Removed Lines]",
          "1788:   if (atomic_dec_and_test(&f->sk_ref))",
          "",
          "[Added Lines]",
          "1788:   if (refcount_dec_and_test(&f->sk_ref))",
          "",
          "---------------"
        ],
        "net/packet/internal.h||net/packet/internal.h": [
          "File: net/packet/internal.h -> net/packet/internal.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "1: #ifndef __PACKET_INTERNAL_H__",
          "2: #define __PACKET_INTERNAL_H__",
          "4: struct packet_mclist {",
          "5:  struct packet_mclist *next;",
          "6:  int   ifindex;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4: #include <linux/refcount.h>",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "86:  struct list_head list;",
          "87:  struct sock  *arr[PACKET_FANOUT_MAX];",
          "88:  spinlock_t  lock;",
          "90:  struct packet_type prot_hook ____cacheline_aligned_in_smp;",
          "91: };",
          "",
          "[Removed Lines]",
          "89:  atomic_t  sk_ref;",
          "",
          "[Added Lines]",
          "91:  refcount_t  sk_ref;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "509c7a1ecc8601f94ffba8a00889fefb239c00c6",
      "candidate_info": {
        "commit_hash": "509c7a1ecc8601f94ffba8a00889fefb239c00c6",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/509c7a1ecc8601f94ffba8a00889fefb239c00c6",
        "files": [
          "net/packet/af_packet.c"
        ],
        "message": "packet: avoid panic in packet_getsockopt()\n\nsyzkaller got crashes in packet_getsockopt() processing\nPACKET_ROLLOVER_STATS command while another thread was managing\nto change po->rollover\n\nUsing RCU will fix this bug. We might later add proper RCU annotations\nfor sparse sake.\n\nIn v2: I replaced kfree(rollover) in fanout_add() to kfree_rcu()\nvariant, as spotted by John.\n\nFixes: a9b6391814d5 (\"packet: rollover statistics\")\nSigned-off-by: Eric Dumazet <edumazet@google.com>\nCc: Willem de Bruijn <willemb@google.com>\nCc: John Sperbeck <jsperbeck@google.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "before_after_code_files": [
          "net/packet/af_packet.c||net/packet/af_packet.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "net/packet/af_packet.c||net/packet/af_packet.c"
          ],
          "candidate": [
            "net/packet/af_packet.c||net/packet/af_packet.c"
          ]
        }
      },
      "candidate_diff": {
        "net/packet/af_packet.c||net/packet/af_packet.c": [
          "File: net/packet/af_packet.c -> net/packet/af_packet.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1770: out:",
          "1771:  if (err && rollover) {",
          "1773:   po->rollover = NULL;",
          "1774:  }",
          "1775:  mutex_unlock(&fanout_mutex);",
          "",
          "[Removed Lines]",
          "1772:   kfree(rollover);",
          "",
          "[Added Lines]",
          "1772:   kfree_rcu(rollover, rcu);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1796:   else",
          "1797:    f = NULL;",
          "1800:    kfree_rcu(po->rollover, rcu);",
          "1801:  }",
          "1802:  mutex_unlock(&fanout_mutex);",
          "",
          "[Removed Lines]",
          "1799:   if (po->rollover)",
          "",
          "[Added Lines]",
          "1799:   if (po->rollover) {",
          "1801:    po->rollover = NULL;",
          "1802:   }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "3851:  void *data = &val;",
          "3852:  union tpacket_stats_u st;",
          "3853:  struct tpacket_rollover_stats rstats;",
          "3855:  if (level != SOL_PACKET)",
          "3856:   return -ENOPROTOOPT;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3856:  struct packet_rollover *rollover;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "3929:          0);",
          "3930:   break;",
          "3931:  case PACKET_ROLLOVER_STATS:",
          "3933:    return -EINVAL;",
          "3939:   break;",
          "3940:  case PACKET_TX_HAS_OFF:",
          "3941:   val = po->tp_tx_has_off;",
          "",
          "[Removed Lines]",
          "3932:   if (!po->rollover)",
          "3934:   rstats.tp_all = atomic_long_read(&po->rollover->num);",
          "3935:   rstats.tp_huge = atomic_long_read(&po->rollover->num_huge);",
          "3936:   rstats.tp_failed = atomic_long_read(&po->rollover->num_failed);",
          "3937:   data = &rstats;",
          "3938:   lv = sizeof(rstats);",
          "",
          "[Added Lines]",
          "3935:   rcu_read_lock();",
          "3936:   rollover = rcu_dereference(po->rollover);",
          "3937:   if (rollover) {",
          "3938:    rstats.tp_all = atomic_long_read(&rollover->num);",
          "3939:    rstats.tp_huge = atomic_long_read(&rollover->num_huge);",
          "3940:    rstats.tp_failed = atomic_long_read(&rollover->num_failed);",
          "3941:    data = &rstats;",
          "3942:    lv = sizeof(rstats);",
          "3943:   }",
          "3944:   rcu_read_unlock();",
          "3945:   if (!rollover)",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "57f015f5eccf25fd4a3336fe3cbbee920a8fba6f",
      "candidate_info": {
        "commit_hash": "57f015f5eccf25fd4a3336fe3cbbee920a8fba6f",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/57f015f5eccf25fd4a3336fe3cbbee920a8fba6f",
        "files": [
          "net/packet/af_packet.c",
          "net/packet/internal.h"
        ],
        "message": "packet: fix crash in fanout_demux_rollover()\n\nsyzkaller found a race condition fanout_demux_rollover() while removing\na packet socket from a fanout group.\n\npo->rollover is read and operated on during packet_rcv_fanout(), via\nfanout_demux_rollover(), but the pointer is currently cleared before the\nsynchronization in packet_release().   It is safer to delay the cleanup\nuntil after synchronize_net() has been called, ensuring all calls to\npacket_rcv_fanout() for this socket have finished.\n\nTo further simplify synchronization around the rollover structure, set\npo->rollover in fanout_add() only if there are no errors.  This removes\nthe need for rcu in the struct and in the call to\npacket_getsockopt(..., PACKET_ROLLOVER_STATS, ...).\n\nCrashing stack trace:\n fanout_demux_rollover+0xb6/0x4d0 net/packet/af_packet.c:1392\n packet_rcv_fanout+0x649/0x7c8 net/packet/af_packet.c:1487\n dev_queue_xmit_nit+0x835/0xc10 net/core/dev.c:1953\n xmit_one net/core/dev.c:2975 [inline]\n dev_hard_start_xmit+0x16b/0xac0 net/core/dev.c:2995\n __dev_queue_xmit+0x17a4/0x2050 net/core/dev.c:3476\n dev_queue_xmit+0x17/0x20 net/core/dev.c:3509\n neigh_connected_output+0x489/0x720 net/core/neighbour.c:1379\n neigh_output include/net/neighbour.h:482 [inline]\n ip6_finish_output2+0xad1/0x22a0 net/ipv6/ip6_output.c:120\n ip6_finish_output+0x2f9/0x920 net/ipv6/ip6_output.c:146\n NF_HOOK_COND include/linux/netfilter.h:239 [inline]\n ip6_output+0x1f4/0x850 net/ipv6/ip6_output.c:163\n dst_output include/net/dst.h:459 [inline]\n NF_HOOK.constprop.35+0xff/0x630 include/linux/netfilter.h:250\n mld_sendpack+0x6a8/0xcc0 net/ipv6/mcast.c:1660\n mld_send_initial_cr.part.24+0x103/0x150 net/ipv6/mcast.c:2072\n mld_send_initial_cr net/ipv6/mcast.c:2056 [inline]\n ipv6_mc_dad_complete+0x99/0x130 net/ipv6/mcast.c:2079\n addrconf_dad_completed+0x595/0x970 net/ipv6/addrconf.c:4039\n addrconf_dad_work+0xac9/0x1160 net/ipv6/addrconf.c:3971\n process_one_work+0xbf0/0x1bc0 kernel/workqueue.c:2113\n worker_thread+0x223/0x1990 kernel/workqueue.c:2247\n kthread+0x35e/0x430 kernel/kthread.c:231\n ret_from_fork+0x2a/0x40 arch/x86/entry/entry_64.S:432\n\nFixes: 0648ab70afe6 (\"packet: rollover prepare: per-socket state\")\nFixes: 509c7a1ecc860 (\"packet: avoid panic in packet_getsockopt()\")\nReported-by: syzbot <syzkaller@googlegroups.com>\nSigned-off-by: Mike Maloney <maloney@google.com>\nReviewed-by: Eric Dumazet <edumazet@google.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "before_after_code_files": [
          "net/packet/af_packet.c||net/packet/af_packet.c",
          "net/packet/internal.h||net/packet/internal.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "net/packet/af_packet.c||net/packet/af_packet.c"
          ],
          "candidate": [
            "net/packet/af_packet.c||net/packet/af_packet.c"
          ]
        }
      },
      "candidate_diff": {
        "net/packet/af_packet.c||net/packet/af_packet.c": [
          "File: net/packet/af_packet.c -> net/packet/af_packet.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1687:   atomic_long_set(&rollover->num, 0);",
          "1688:   atomic_long_set(&rollover->num_huge, 0);",
          "1689:   atomic_long_set(&rollover->num_failed, 0);",
          "1691:  }",
          "1693:  if (type_flags & PACKET_FANOUT_FLAG_UNIQUEID) {",
          "",
          "[Removed Lines]",
          "1690:   po->rollover = rollover;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1745:   if (refcount_read(&match->sk_ref) < PACKET_FANOUT_MAX) {",
          "1746:    __dev_remove_pack(&po->prot_hook);",
          "1747:    po->fanout = match;",
          "1748:    refcount_set(&match->sk_ref, refcount_read(&match->sk_ref) + 1);",
          "1749:    __fanout_link(sk, po);",
          "1750:    err = 0;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1747:    po->rollover = rollover;",
          "1748:    rollover = NULL;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1758:  }",
          "1760: out:",
          "1765:  mutex_unlock(&fanout_mutex);",
          "1766:  return err;",
          "1767: }",
          "",
          "[Removed Lines]",
          "1761:  if (err && rollover) {",
          "1762:   kfree_rcu(rollover, rcu);",
          "1763:   po->rollover = NULL;",
          "1764:  }",
          "",
          "[Added Lines]",
          "1762:  kfree(rollover);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1785:    list_del(&f->list);",
          "1786:   else",
          "1787:    f = NULL;",
          "1793:  }",
          "1794:  mutex_unlock(&fanout_mutex);",
          "",
          "[Removed Lines]",
          "1789:   if (po->rollover) {",
          "1790:    kfree_rcu(po->rollover, rcu);",
          "1791:    po->rollover = NULL;",
          "1792:   }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "3029:  synchronize_net();",
          "3031:  if (f) {",
          "3032:   fanout_release_data(f);",
          "3033:   kfree(f);",
          "3034:  }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3025:   kfree(po->rollover);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "3843:  void *data = &val;",
          "3844:  union tpacket_stats_u st;",
          "3845:  struct tpacket_rollover_stats rstats;",
          "3848:  if (level != SOL_PACKET)",
          "3849:   return -ENOPROTOOPT;",
          "",
          "[Removed Lines]",
          "3846:  struct packet_rollover *rollover;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "3922:          0);",
          "3923:   break;",
          "3924:  case PACKET_ROLLOVER_STATS:",
          "3936:    return -EINVAL;",
          "3937:   break;",
          "3938:  case PACKET_TX_HAS_OFF:",
          "3939:   val = po->tp_tx_has_off;",
          "",
          "[Removed Lines]",
          "3925:   rcu_read_lock();",
          "3926:   rollover = rcu_dereference(po->rollover);",
          "3927:   if (rollover) {",
          "3928:    rstats.tp_all = atomic_long_read(&rollover->num);",
          "3929:    rstats.tp_huge = atomic_long_read(&rollover->num_huge);",
          "3930:    rstats.tp_failed = atomic_long_read(&rollover->num_failed);",
          "3931:    data = &rstats;",
          "3932:    lv = sizeof(rstats);",
          "3933:   }",
          "3934:   rcu_read_unlock();",
          "3935:   if (!rollover)",
          "",
          "[Added Lines]",
          "3918:   if (!po->rollover)",
          "3920:   rstats.tp_all = atomic_long_read(&po->rollover->num);",
          "3921:   rstats.tp_huge = atomic_long_read(&po->rollover->num_huge);",
          "3922:   rstats.tp_failed = atomic_long_read(&po->rollover->num_failed);",
          "3923:   data = &rstats;",
          "3924:   lv = sizeof(rstats);",
          "",
          "---------------"
        ],
        "net/packet/internal.h||net/packet/internal.h": [
          "File: net/packet/internal.h -> net/packet/internal.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "96: struct packet_rollover {",
          "97:  int   sock;",
          "99:  atomic_long_t  num;",
          "100:  atomic_long_t  num_huge;",
          "101:  atomic_long_t  num_failed;",
          "",
          "[Removed Lines]",
          "98:  struct rcu_head  rcu;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "2bd624b4611ffee36422782d16e1c944d1351e98",
      "candidate_info": {
        "commit_hash": "2bd624b4611ffee36422782d16e1c944d1351e98",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/2bd624b4611ffee36422782d16e1c944d1351e98",
        "files": [
          "net/packet/af_packet.c"
        ],
        "message": "packet: Do not call fanout_release from atomic contexts\n\nCommit 6664498280cf (\"packet: call fanout_release, while UNREGISTERING a\nnetdev\"), unfortunately, introduced the following issues.\n\n1. calling mutex_lock(&fanout_mutex) (fanout_release()) from inside\nrcu_read-side critical section. rcu_read_lock disables preemption, most often,\nwhich prohibits calling sleeping functions.\n\n[  ] include/linux/rcupdate.h:560 Illegal context switch in RCU read-side critical section!\n[  ]\n[  ] rcu_scheduler_active = 1, debug_locks = 0\n[  ] 4 locks held by ovs-vswitchd/1969:\n[  ]  #0:  (cb_lock){++++++}, at: [<ffffffff8158a6c9>] genl_rcv+0x19/0x40\n[  ]  #1:  (ovs_mutex){+.+.+.}, at: [<ffffffffa04878ca>] ovs_vport_cmd_del+0x4a/0x100 [openvswitch]\n[  ]  #2:  (rtnl_mutex){+.+.+.}, at: [<ffffffff81564157>] rtnl_lock+0x17/0x20\n[  ]  #3:  (rcu_read_lock){......}, at: [<ffffffff81614165>] packet_notifier+0x5/0x3f0\n[  ]\n[  ] Call Trace:\n[  ]  [<ffffffff813770c1>] dump_stack+0x85/0xc4\n[  ]  [<ffffffff810c9077>] lockdep_rcu_suspicious+0x107/0x110\n[  ]  [<ffffffff810a2da7>] ___might_sleep+0x57/0x210\n[  ]  [<ffffffff810a2fd0>] __might_sleep+0x70/0x90\n[  ]  [<ffffffff8162e80c>] mutex_lock_nested+0x3c/0x3a0\n[  ]  [<ffffffff810de93f>] ? vprintk_default+0x1f/0x30\n[  ]  [<ffffffff81186e88>] ? printk+0x4d/0x4f\n[  ]  [<ffffffff816106dd>] fanout_release+0x1d/0xe0\n[  ]  [<ffffffff81614459>] packet_notifier+0x2f9/0x3f0\n\n2. calling mutex_lock(&fanout_mutex) inside spin_lock(&po->bind_lock).\n\"sleeping function called from invalid context\"\n\n[  ] BUG: sleeping function called from invalid context at kernel/locking/mutex.c:620\n[  ] in_atomic(): 1, irqs_disabled(): 0, pid: 1969, name: ovs-vswitchd\n[  ] INFO: lockdep is turned off.\n[  ] Call Trace:\n[  ]  [<ffffffff813770c1>] dump_stack+0x85/0xc4\n[  ]  [<ffffffff810a2f52>] ___might_sleep+0x202/0x210\n[  ]  [<ffffffff810a2fd0>] __might_sleep+0x70/0x90\n[  ]  [<ffffffff8162e80c>] mutex_lock_nested+0x3c/0x3a0\n[  ]  [<ffffffff816106dd>] fanout_release+0x1d/0xe0\n[  ]  [<ffffffff81614459>] packet_notifier+0x2f9/0x3f0\n\n3. calling dev_remove_pack(&fanout->prot_hook), from inside\nspin_lock(&po->bind_lock) or rcu_read-side critical-section. dev_remove_pack()\n-> synchronize_net(), which might sleep.\n\n[  ] BUG: scheduling while atomic: ovs-vswitchd/1969/0x00000002\n[  ] INFO: lockdep is turned off.\n[  ] Call Trace:\n[  ]  [<ffffffff813770c1>] dump_stack+0x85/0xc4\n[  ]  [<ffffffff81186274>] __schedule_bug+0x64/0x73\n[  ]  [<ffffffff8162b8cb>] __schedule+0x6b/0xd10\n[  ]  [<ffffffff8162c5db>] schedule+0x6b/0x80\n[  ]  [<ffffffff81630b1d>] schedule_timeout+0x38d/0x410\n[  ]  [<ffffffff810ea3fd>] synchronize_sched_expedited+0x53d/0x810\n[  ]  [<ffffffff810ea6de>] synchronize_rcu_expedited+0xe/0x10\n[  ]  [<ffffffff8154eab5>] synchronize_net+0x35/0x50\n[  ]  [<ffffffff8154eae3>] dev_remove_pack+0x13/0x20\n[  ]  [<ffffffff8161077e>] fanout_release+0xbe/0xe0\n[  ]  [<ffffffff81614459>] packet_notifier+0x2f9/0x3f0\n\n4. fanout_release() races with calls from different CPU.\n\nTo fix the above problems, remove the call to fanout_release() under\nrcu_read_lock(). Instead, call __dev_remove_pack(&fanout->prot_hook) and\nnetdev_run_todo will be happy that &dev->ptype_specific list is empty. In order\nto achieve this, I moved dev_{add,remove}_pack() out of fanout_{add,release} to\n__fanout_{link,unlink}. So, call to {,__}unregister_prot_hook() will make sure\nfanout->prot_hook is removed as well.\n\nFixes: 6664498280cf (\"packet: call fanout_release, while UNREGISTERING a netdev\")\nReported-by: Eric Dumazet <edumazet@google.com>\nSigned-off-by: Anoob Soman <anoob.soman@citrix.com>\nAcked-by: Eric Dumazet <edumazet@google.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "before_after_code_files": [
          "net/packet/af_packet.c||net/packet/af_packet.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "net/packet/af_packet.c||net/packet/af_packet.c"
          ],
          "candidate": [
            "net/packet/af_packet.c||net/packet/af_packet.c"
          ]
        }
      },
      "candidate_diff": {
        "net/packet/af_packet.c||net/packet/af_packet.c": [
          "File: net/packet/af_packet.c -> net/packet/af_packet.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1497:  f->arr[f->num_members] = sk;",
          "1498:  smp_wmb();",
          "1499:  f->num_members++;",
          "1500:  spin_unlock(&f->lock);",
          "1501: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1500:  if (f->num_members == 1)",
          "1501:   dev_add_pack(&f->prot_hook);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1513:  BUG_ON(i >= f->num_members);",
          "1514:  f->arr[i] = f->arr[f->num_members - 1];",
          "1515:  f->num_members--;",
          "1516:  spin_unlock(&f->lock);",
          "1517: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1518:  if (f->num_members == 0)",
          "1519:   __dev_remove_pack(&f->prot_hook);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1693:   match->prot_hook.func = packet_rcv_fanout;",
          "1694:   match->prot_hook.af_packet_priv = match;",
          "1695:   match->prot_hook.id_match = match_fanout_group;",
          "1697:   list_add(&match->list, &fanout_list);",
          "1698:  }",
          "1699:  err = -EINVAL;",
          "",
          "[Removed Lines]",
          "1696:   dev_add_pack(&match->prot_hook);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1718:  return err;",
          "1719: }",
          "1722: {",
          "1723:  struct packet_sock *po = pkt_sk(sk);",
          "1724:  struct packet_fanout *f;",
          "",
          "[Removed Lines]",
          "1721: static void fanout_release(struct sock *sk)",
          "",
          "[Added Lines]",
          "1729: static struct packet_fanout *fanout_release(struct sock *sk)",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1728:  if (f) {",
          "1729:   po->fanout = NULL;",
          "1732:    list_del(&f->list);",
          "1738:   if (po->rollover)",
          "1739:    kfree_rcu(po->rollover, rcu);",
          "1740:  }",
          "1741:  mutex_unlock(&fanout_mutex);",
          "1742: }",
          "1744: static bool packet_extra_vlan_len_allowed(const struct net_device *dev,",
          "",
          "[Removed Lines]",
          "1731:   if (atomic_dec_and_test(&f->sk_ref)) {",
          "1733:    dev_remove_pack(&f->prot_hook);",
          "1734:    fanout_release_data(f);",
          "1735:    kfree(f);",
          "1736:   }",
          "",
          "[Added Lines]",
          "1739:   if (atomic_dec_and_test(&f->sk_ref))",
          "1741:   else",
          "1742:    f = NULL;",
          "1749:  return f;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "2912: {",
          "2913:  struct sock *sk = sock->sk;",
          "2914:  struct packet_sock *po;",
          "2915:  struct net *net;",
          "2916:  union tpacket_req_u req_u;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2923:  struct packet_fanout *f;",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "2951:   packet_set_ring(sk, &req_u, 1, 1);",
          "2952:  }",
          "2956:  synchronize_net();",
          "",
          "[Removed Lines]",
          "2954:  fanout_release(sk);",
          "",
          "[Added Lines]",
          "2963:  f = fanout_release(sk);",
          "2967:  if (f) {",
          "2968:   fanout_release_data(f);",
          "2969:   kfree(f);",
          "2970:  }",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "3905:     }",
          "3906:     if (msg == NETDEV_UNREGISTER) {",
          "3907:      packet_cached_dev_reset(po);",
          "3909:      po->ifindex = -1;",
          "3910:      if (po->prot_hook.dev)",
          "3911:       dev_put(po->prot_hook.dev);",
          "",
          "[Removed Lines]",
          "3908:      fanout_release(sk);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2017-0196",
  "cve_desc": "An information disclosure vulnerability in Microsoft scripting engine allows remote attackers to obtain sensitive information from process memory via a crafted web site, aka \"Microsoft Browser Information Disclosure Vulnerability.\"",
  "repo": "Microsoft/ChakraCore",
  "patch_hash": "065b7978c40ded35c356ced6cd922a40156c9c46",
  "patch_info": {
    "commit_hash": "065b7978c40ded35c356ced6cd922a40156c9c46",
    "repo": "Microsoft/ChakraCore",
    "commit_url": "https://github.com/Microsoft/ChakraCore/commit/065b7978c40ded35c356ced6cd922a40156c9c46",
    "files": [
      "lib/Runtime/Library/JavascriptArray.cpp",
      "test/Array/Array_TypeConfusion_bugs.js"
    ],
    "message": "[CVE-2017-0196] Fixing an heap overread during slice.\n\nThe MissingItem check is happening on the array in a loop. It is possible that we get called into script and that mutates the array. So the Array's head is newly created with length.\nHowever the loop is still performing over the old length.\nFixed this by checking the length In IsMissingItem function.\nAdded a unittest.",
    "before_after_code_files": [
      "lib/Runtime/Library/JavascriptArray.cpp||lib/Runtime/Library/JavascriptArray.cpp",
      "test/Array/Array_TypeConfusion_bugs.js||test/Array/Array_TypeConfusion_bugs.js"
    ]
  },
  "patch_diff": {
    "lib/Runtime/Library/JavascriptArray.cpp||lib/Runtime/Library/JavascriptArray.cpp": [
      "File: lib/Runtime/Library/JavascriptArray.cpp -> lib/Runtime/Library/JavascriptArray.cpp",
      "--- Hunk 1 ---",
      "[Context before]",
      "478:     bool JavascriptArray::IsMissingItem(uint32 index)",
      "479:     {",
      "480:         bool isIntArray = false, isFloatArray = false;",
      "481:         this->GetArrayTypeAndConvert(&isIntArray, &isFloatArray);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "480:         if (this->length <= index)",
      "481:         {",
      "482:             return false;",
      "483:         }",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "5768:         if (!pArr->HasNoMissingValues())",
      "5769:         {",
      "5771:             {",
      "",
      "[Removed Lines]",
      "5770:             for (uint32 i = 0; i < newLen; i++)",
      "",
      "[Added Lines]",
      "5775:             for (uint32 i = 0; i < newLen && (i + start) < pArr->length; i++)",
      "",
      "---------------"
    ],
    "test/Array/Array_TypeConfusion_bugs.js||test/Array/Array_TypeConfusion_bugs.js": [
      "File: test/Array/Array_TypeConfusion_bugs.js -> test/Array/Array_TypeConfusion_bugs.js",
      "--- Hunk 1 ---",
      "[Context before]",
      "593:             assert.areEqual(101, arr.length);",
      "594:         }",
      "595:     },",
      "596: ];",
      "597: testRunner.runTests(tests, { verbose: WScript.Arguments[0] != \"summary\" });",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "596:     {",
      "597:         name: \"Heap overread when splice mutates the array when executing slice\",",
      "598:         body: function ()",
      "599:         {",
      "600:             var getterCalled = false;",
      "601:             var a = [1, 2];",
      "602:             for (var i = 0; i < 100 * 1024; i++) {",
      "603:                 a.push(i);",
      "604:             }",
      "605:             delete a[0]; // Make a missing item",
      "606:             var protoObj = [11];",
      "607:             Object.defineProperty(protoObj, '0', {",
      "608:                 get : function () {",
      "609:                     getterCalled = true;",
      "610:                     Object.setPrototypeOf(a, Array.prototype);",
      "611:                     a.splice(0); // head seg is now length=0",
      "612:                     return 42;",
      "613:                 },",
      "614:                 configurable : true",
      "615:             });",
      "616:             Object.setPrototypeOf(a, protoObj);",
      "617:             var b = a.slice();",
      "618:             assert.isTrue(getterCalled);",
      "619:             assert.areEqual(0, a.length, \"Getter will splice the array to zero length\");",
      "620:             assert.areEqual(100 * 1024 + 2, b.length, \"Validating that slice will return the full array even though splice is deleting the whole array\");",
      "621:         }",
      "622:     },",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "a745c465fbabc67ef2b7dce38172a1309473aa58",
      "candidate_info": {
        "commit_hash": "a745c465fbabc67ef2b7dce38172a1309473aa58",
        "repo": "Microsoft/ChakraCore",
        "commit_url": "https://github.com/Microsoft/ChakraCore/commit/a745c465fbabc67ef2b7dce38172a1309473aa58",
        "files": [
          "lib/Runtime/Language/JavascriptConversion.cpp",
          "lib/Runtime/Language/JavascriptExceptionOperators.cpp",
          "lib/Runtime/Language/JavascriptOperators.cpp",
          "lib/Runtime/Language/JavascriptOperators.h",
          "lib/Runtime/Library/BoundFunction.cpp",
          "lib/Runtime/Library/JavascriptArray.cpp",
          "lib/Runtime/Library/JavascriptError.cpp",
          "lib/Runtime/Library/JavascriptExternalFunction.cpp",
          "lib/Runtime/Library/JavascriptFunction.cpp",
          "lib/Runtime/Library/JavascriptLibrary.cpp",
          "lib/Runtime/Library/JavascriptMap.cpp",
          "lib/Runtime/Library/JavascriptNumber.cpp",
          "lib/Runtime/Library/JavascriptObject.cpp",
          "lib/Runtime/Library/JavascriptPromise.cpp",
          "lib/Runtime/Library/JavascriptSet.cpp",
          "lib/Runtime/Library/JavascriptString.cpp",
          "lib/Runtime/Library/TypedArray.cpp"
        ],
        "message": "perf: Improve internal type discovery and getProperty\n\n - Fast path for IsNull / IsUndefined (in case the argument is\n    recyclableObject, or we know for sure object's context). Especially\nNullCheck was pretty common within the internal loops\n\n    - Introduce internal GetProperty calls by introducing\n    GetPropertyNoCache that serves only for RecyclableObject+ and when\ninfo == nullptr.\n\n - Improve logic in related places. (i.e. use less GetTypeId calls,\nGetPropertyName calls...)",
        "before_after_code_files": [
          "lib/Runtime/Language/JavascriptConversion.cpp||lib/Runtime/Language/JavascriptConversion.cpp",
          "lib/Runtime/Language/JavascriptExceptionOperators.cpp||lib/Runtime/Language/JavascriptExceptionOperators.cpp",
          "lib/Runtime/Language/JavascriptOperators.cpp||lib/Runtime/Language/JavascriptOperators.cpp",
          "lib/Runtime/Language/JavascriptOperators.h||lib/Runtime/Language/JavascriptOperators.h",
          "lib/Runtime/Library/BoundFunction.cpp||lib/Runtime/Library/BoundFunction.cpp",
          "lib/Runtime/Library/JavascriptArray.cpp||lib/Runtime/Library/JavascriptArray.cpp",
          "lib/Runtime/Library/JavascriptError.cpp||lib/Runtime/Library/JavascriptError.cpp",
          "lib/Runtime/Library/JavascriptExternalFunction.cpp||lib/Runtime/Library/JavascriptExternalFunction.cpp",
          "lib/Runtime/Library/JavascriptFunction.cpp||lib/Runtime/Library/JavascriptFunction.cpp",
          "lib/Runtime/Library/JavascriptLibrary.cpp||lib/Runtime/Library/JavascriptLibrary.cpp",
          "lib/Runtime/Library/JavascriptMap.cpp||lib/Runtime/Library/JavascriptMap.cpp",
          "lib/Runtime/Library/JavascriptNumber.cpp||lib/Runtime/Library/JavascriptNumber.cpp",
          "lib/Runtime/Library/JavascriptObject.cpp||lib/Runtime/Library/JavascriptObject.cpp",
          "lib/Runtime/Library/JavascriptPromise.cpp||lib/Runtime/Library/JavascriptPromise.cpp",
          "lib/Runtime/Library/JavascriptSet.cpp||lib/Runtime/Library/JavascriptSet.cpp",
          "lib/Runtime/Library/JavascriptString.cpp||lib/Runtime/Library/JavascriptString.cpp",
          "lib/Runtime/Library/TypedArray.cpp||lib/Runtime/Library/TypedArray.cpp"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "lib/Runtime/Library/JavascriptArray.cpp||lib/Runtime/Library/JavascriptArray.cpp"
          ],
          "candidate": [
            "lib/Runtime/Library/JavascriptArray.cpp||lib/Runtime/Library/JavascriptArray.cpp"
          ]
        }
      },
      "candidate_diff": {
        "lib/Runtime/Language/JavascriptConversion.cpp||lib/Runtime/Language/JavascriptConversion.cpp": [
          "File: lib/Runtime/Language/JavascriptConversion.cpp -> lib/Runtime/Language/JavascriptConversion.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "23:     BOOL JavascriptConversion::CheckObjectCoercible(Var aValue, ScriptContext* scriptContext)",
          "24:     {",
          "31:     }",
          "",
          "[Removed Lines]",
          "25:         TypeId typeId = JavascriptOperators::GetTypeId(aValue);",
          "26:         if (typeId == TypeIds_Null || typeId == TypeIds_Undefined)",
          "27:         {",
          "28:             return FALSE;",
          "29:         }",
          "30:         return TRUE;",
          "",
          "[Added Lines]",
          "25:         return !JavascriptOperators::IsUndefinedOrNull(aValue);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "63:         TypeId leftType = JavascriptOperators::GetTypeId(aLeft);",
          "64:         TypeId rightType = JavascriptOperators::GetTypeId(aRight);",
          "73:         {",
          "75:         }",
          "77:         double dblLeft, dblRight;",
          "",
          "[Removed Lines]",
          "67:         if (leftType == TypeIds_Undefined )",
          "68:         {",
          "69:             return rightType == TypeIds_Undefined;",
          "70:         }",
          "72:         if (leftType == TypeIds_Null)",
          "74:             return rightType == TypeIds_Null;",
          "",
          "[Added Lines]",
          "61:         if (JavascriptOperators::IsUndefinedOrNullType(leftType))",
          "63:             return leftType == rightType;",
          "",
          "---------------"
        ],
        "lib/Runtime/Language/JavascriptExceptionOperators.cpp||lib/Runtime/Language/JavascriptExceptionOperators.cpp": [
          "File: lib/Runtime/Language/JavascriptExceptionOperators.cpp -> lib/Runtime/Language/JavascriptExceptionOperators.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "1452:             }",
          "1454:             Var var = nullptr;",
          "1456:             {",
          "1458:                 switch (JavascriptOperators::GetTypeId(var))",
          "",
          "[Removed Lines]",
          "1455:             if (JavascriptOperators::GetProperty(error, PropertyIds::stackTraceLimit, &var, scriptContext))",
          "",
          "[Added Lines]",
          "1455:             if (JavascriptOperators::GetPropertyNoCache(error, PropertyIds::stackTraceLimit, &var, scriptContext))",
          "",
          "---------------"
        ],
        "lib/Runtime/Language/JavascriptOperators.cpp||lib/Runtime/Language/JavascriptOperators.cpp": [
          "File: lib/Runtime/Language/JavascriptOperators.cpp -> lib/Runtime/Language/JavascriptOperators.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "1484:     BOOL JavascriptOperators::HasProperty(RecyclableObject* instance, PropertyId propertyId)",
          "1485:     {",
          "1487:         {",
          "1488:             PropertyQueryFlags result = instance->HasPropertyQuery(propertyId);",
          "1489:             if (result != PropertyQueryFlags::Property_NotFound)",
          "",
          "[Removed Lines]",
          "1486:         while (JavascriptOperators::GetTypeId(instance) != TypeIds_Null)",
          "",
          "[Added Lines]",
          "1486:         while (!JavascriptOperators::IsNull(instance))",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1675:         return GetProperty_Internal<false>(instance, RecyclableObject::FromVar(instance), true, propertyId, value, requestContext, info);",
          "1676:     }",
          "1678:     template <bool unscopables>",
          "1679:     BOOL JavascriptOperators::GetProperty_Internal(Var instance, RecyclableObject* propertyObject, const bool isRoot, PropertyId propertyId, Var* value, ScriptContext* requestContext, PropertyValueInfo* info)",
          "1680:     {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1678:     BOOL JavascriptOperators::GetProperty_InternalSimple(Var instance, RecyclableObject* object, PropertyId propertyId, _Outptr_result_maybenull_ Var* value, ScriptContext* requestContext)",
          "1679:     {",
          "1680:         BOOL foundProperty = FALSE;",
          "1681:         Assert(value != nullptr);",
          "1683:         while (!JavascriptOperators::IsNull(object))",
          "1684:         {",
          "1685:             PropertyQueryFlags result = object->GetPropertyQuery(instance, propertyId, value, nullptr, requestContext);",
          "1686:             if (result != PropertyQueryFlags::Property_NotFound)",
          "1687:             {",
          "1688:                 foundProperty = JavascriptConversion::PropertyQueryFlagsToBoolean(result);",
          "1689:                 break;",
          "1690:             }",
          "1692:             if (object->SkipsPrototype())",
          "1693:             {",
          "1694:                 break;",
          "1695:             }",
          "1697:             object = JavascriptOperators::GetPrototypeNoTrap(object);",
          "1698:         }",
          "1700:         if (!foundProperty)",
          "1701:         {",
          "1703:         }",
          "1705:         return foundProperty;",
          "1706:     }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1692:             foundProperty = rootObject->GetRootProperty(instance, propertyId, value, info, requestContext);",
          "1693:         }",
          "1696:         {",
          "1697:             if (unscopables && IsPropertyUnscopable(object, propertyId))",
          "1698:             {",
          "",
          "[Removed Lines]",
          "1695:         while (!foundProperty && JavascriptOperators::GetTypeId(object) != TypeIds_Null)",
          "",
          "[Added Lines]",
          "1725:         while (!foundProperty && !JavascriptOperators::IsNull(object))",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1795:     BOOL JavascriptOperators::GetPropertyWPCache(Var instance, RecyclableObject* propertyObject, PropertyKeyType propertyKey, Var* value, ScriptContext* requestContext, _Inout_ PropertyValueInfo * info)",
          "1796:     {",
          "1797:         RecyclableObject* object = propertyObject;",
          "1799:         {",
          "1800:             PropertyQueryFlags result = object->GetPropertyQuery(instance, propertyKey, value, info, requestContext);",
          "1801:             if (result != PropertyQueryFlags::Property_NotFound)",
          "",
          "[Removed Lines]",
          "1798:         while (JavascriptOperators::GetTypeId(object) != TypeIds_Null)",
          "",
          "[Added Lines]",
          "1828:         while (!JavascriptOperators::IsNull(object))",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1832:             return TRUE;",
          "1833:         }",
          "1834:         RecyclableObject* object = RecyclableObject::FromVar(instance);",
          "1838:         {",
          "1839:             return FALSE;",
          "1840:         }",
          "",
          "[Removed Lines]",
          "1835:         TypeId typeId = object->GetTypeId();",
          "1837:         if (typeId == TypeIds_Null || typeId == TypeIds_Undefined)",
          "",
          "[Added Lines]",
          "1866:         if (JavascriptOperators::IsUndefinedOrNull(object))",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1864:             }",
          "1865:         }",
          "1868:         AssertMsg(result != nullptr, \"result null in OP_GetProperty\");",
          "1869:         return result;",
          "1870:     }",
          "",
          "[Removed Lines]",
          "1867:         Var result = JavascriptOperators::GetProperty(instance, object, propertyId, scriptContext);",
          "",
          "[Added Lines]",
          "1896:         Var result = JavascriptOperators::GetPropertyNoCache(instance, object, propertyId, scriptContext);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "1998:     {",
          "1999:         BOOL foundProperty = false;",
          "2000:         RecyclableObject* object = *propertyObject;",
          "2002:         {",
          "2003:             if (unscopables && JavascriptOperators::IsPropertyUnscopable(object, propertyId))",
          "2004:             {",
          "",
          "[Removed Lines]",
          "2001:         while (!foundProperty && JavascriptOperators::GetTypeId(object) != TypeIds_Null)",
          "",
          "[Added Lines]",
          "2030:         while (!foundProperty && !JavascriptOperators::IsNull(object))",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "2085:     {",
          "2086:         DescriptorFlags flags = None;",
          "2087:         RecyclableObject* object = instance;",
          "2089:         {",
          "2091:             if (unscopable && IsPropertyUnscopable(object, propertyKey))",
          "2092:             {",
          "2093:                 break;",
          "2094:             }",
          "2095:             else",
          "2096:             {",
          "2098:                 flags = object->GetSetter(propertyKey, setterValue, info, scriptContext);",
          "2099:                 if (flags != None)",
          "2100:                 {",
          "",
          "[Removed Lines]",
          "2088:         while (flags == None && JavascriptOperators::GetTypeId(object) != TypeIds_Null)",
          "",
          "[Added Lines]",
          "2117:         while (flags == None && !JavascriptOperators::IsNull(object))",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "2144:         }",
          "2146:         RecyclableObject* object = instance;",
          "2148:         {",
          "2150:             if (*flags != None || skipPrototypeCheck)",
          "",
          "[Removed Lines]",
          "2147:         while (JavascriptOperators::GetTypeId(object) != TypeIds_Null)",
          "",
          "[Added Lines]",
          "2174:         while (!JavascriptOperators::IsNull(object))",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "2468:             else",
          "2469:             {",
          "2470:                 RecyclableObject* instanceObject = RecyclableObject::FromVar(receiver);",
          "2472:                 {",
          "2473:                     if (unscopables && JavascriptOperators::IsPropertyUnscopable(instanceObject, propertyId))",
          "2474:                     {",
          "",
          "[Removed Lines]",
          "2471:                 while (JavascriptOperators::GetTypeId(instanceObject) != TypeIds_Null)",
          "",
          "[Added Lines]",
          "2498:                 while (!JavascriptOperators::IsNull(instanceObject))",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "2532:     BOOL JavascriptOperators::GetAccessors(RecyclableObject* instance, PropertyId propertyId, ScriptContext* requestContext, Var* getter, Var* setter)",
          "2533:     {",
          "2534:         RecyclableObject* object = instance;",
          "2537:         {",
          "2538:             if (object->GetAccessors(propertyId, getter, setter, requestContext))",
          "2539:             {",
          "",
          "[Removed Lines]",
          "2536:         while (JavascriptOperators::GetTypeId(object) != TypeIds_Null)",
          "",
          "[Added Lines]",
          "2562:         while (!JavascriptOperators::IsNull(object))",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "2566:         }",
          "2567:         TypeId typeId = JavascriptOperators::GetTypeId(thisInstance);",
          "2570:         {",
          "2571:             if (scriptContext->GetThreadContext()->RecordImplicitException())",
          "2572:             {",
          "",
          "[Removed Lines]",
          "2569:         if (typeId == TypeIds_Null || typeId == TypeIds_Undefined)",
          "",
          "[Added Lines]",
          "2595:         if (JavascriptOperators::IsUndefinedOrNullType(typeId))",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "2774:             return scriptContext->GetLibrary()->GetTrue();",
          "2775:         }",
          "2779:         {",
          "2780:             JavascriptError::ThrowTypeError(scriptContext, JSERR_Property_CannotDelete_NullOrUndefined,",
          "2781:                 scriptContext->GetPropertyName(propertyId)->GetBuffer());",
          "2782:         }",
          "2786:         return scriptContext->GetLibrary()->CreateBoolean(",
          "2787:             JavascriptOperators::DeleteProperty(recyclableObject, propertyId, propertyOperationFlags));",
          "2788:     }",
          "",
          "[Removed Lines]",
          "2777:         TypeId typeId = JavascriptOperators::GetTypeId(instance);",
          "2778:         if (typeId == TypeIds_Null || typeId == TypeIds_Undefined)",
          "2784:         RecyclableObject *recyclableObject = RecyclableObject::FromVar(instance);",
          "",
          "[Added Lines]",
          "2803:         RecyclableObject* recyclableObject = RecyclableObject::FromVar(instance);",
          "2804:         if (JavascriptOperators::IsUndefinedOrNull(recyclableObject))",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "3066: #if ENABLE_COPYONACCESS_ARRAY",
          "3067:         JavascriptLibrary::CheckAndConvertCopyOnAccessNativeIntArray<Var>(object);",
          "3068: #endif",
          "3070:         {",
          "3071:             PropertyQueryFlags result;",
          "3072:             if ((result = object->HasItemQuery(index)) != PropertyQueryFlags::Property_NotFound)",
          "",
          "[Removed Lines]",
          "3069:         while (JavascriptOperators::GetTypeId(object) != TypeIds_Null)",
          "",
          "[Added Lines]",
          "3093:         while (!JavascriptOperators::IsNull(object))",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "3088:     BOOL JavascriptOperators::GetItem(Var instance, RecyclableObject* propertyObject, uint32 index, Var* value, ScriptContext* requestContext)",
          "3089:     {",
          "3090:         RecyclableObject* object = propertyObject;",
          "3092:         {",
          "3093:             PropertyQueryFlags result;",
          "3094:             if ((result = object->GetItemQuery(instance, index, value, requestContext)) != PropertyQueryFlags::Property_NotFound)",
          "",
          "[Removed Lines]",
          "3091:         while (JavascriptOperators::GetTypeId(object) != TypeIds_Null)",
          "",
          "[Added Lines]",
          "3115:         while (!JavascriptOperators::IsNull(object))",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "3108:     BOOL JavascriptOperators::GetItemReference(Var instance, RecyclableObject* propertyObject, uint32 index, Var* value, ScriptContext* requestContext)",
          "3109:     {",
          "3110:         RecyclableObject* object = propertyObject;",
          "3112:         {",
          "3113:             PropertyQueryFlags result;",
          "3114:             if ((result = object->GetItemReferenceQuery(instance, index, value, requestContext)) != PropertyQueryFlags::Property_NotFound)",
          "",
          "[Removed Lines]",
          "3111:         while (JavascriptOperators::GetTypeId(object) != TypeIds_Null)",
          "",
          "[Added Lines]",
          "3135:         while (!JavascriptOperators::IsNull(object))",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "4886: #if ENABLE_COPYONACCESS_ARRAY",
          "4887:         JavascriptLibrary::CheckAndConvertCopyOnAccessNativeIntArray<Var>(instance);",
          "4888: #endif",
          "4891:         {",
          "4892:             JavascriptError::ThrowTypeError(scriptContext, JSERR_Property_CannotDelete_NullOrUndefined, GetPropertyDisplayNameForError(index, scriptContext));",
          "4893:         }",
          "4897:         uint32 indexVal;",
          "4898:         PropertyRecord const * propertyRecord = nullptr;",
          "4899:         JavascriptString * propertyNameString = nullptr;",
          "",
          "[Removed Lines]",
          "4889:         TypeId typeId = JavascriptOperators::GetTypeId(instance);",
          "4890:         if (typeId == TypeIds_Null || typeId == TypeIds_Undefined)",
          "4895:         RecyclableObject* object = RecyclableObject::FromVar(instance);",
          "",
          "[Added Lines]",
          "4913:         RecyclableObject* object = RecyclableObject::FromVar(instance);",
          "4914:         if (JavascriptOperators::IsUndefinedOrNull(object))",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "5165:     bool JavascriptOperators::CanShortcutPrototypeChainOnUnknownPropertyName(RecyclableObject *prototype)",
          "5166:     {",
          "5167:         Assert(prototype);",
          "5170:         {",
          "5171:             if (!CanShortcutInstanceOnUnknownPropertyName(prototype))",
          "5172:             {",
          "",
          "[Removed Lines]",
          "5169:         for (; prototype->GetTypeId() != TypeIds_Null; prototype = prototype->GetPrototype())",
          "",
          "[Added Lines]",
          "5190:         for (; !JavascriptOperators::IsNull(prototype); prototype = prototype->GetPrototype())",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "5191:         {",
          "5192:             return scriptContext->GetLibrary()->GetNumberPrototype();",
          "5193:         }",
          "5198:         else",
          "5199:         {",
          "5201:         }",
          "5202:     }",
          "",
          "[Removed Lines]",
          "5194:         else if (JavascriptOperators::GetTypeId(instance) != TypeIds_Null)",
          "5195:         {",
          "5196:             return JavascriptOperators::GetPrototype(RecyclableObject::FromVar(instance));",
          "5197:         }",
          "5200:             return scriptContext->GetLibrary()->GetNull();",
          "",
          "[Added Lines]",
          "5217:             RecyclableObject* object = RecyclableObject::FromVar(instance);",
          "5218:             if (JavascriptOperators::IsNull(object))",
          "5219:             {",
          "5220:                 return object;",
          "5221:             }",
          "5223:             return JavascriptOperators::GetPrototype(object);",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "7018:         RecyclableObject* constructor = RecyclableObject::FromVar(aClass);",
          "7019:         if (scriptContext->GetConfig()->IsES6HasInstanceEnabled())",
          "7020:         {",
          "7022:             if (JavascriptOperators::IsUndefinedObject(instOfHandler)",
          "7023:                 || instOfHandler == scriptContext->GetBuiltInLibraryFunction(JavascriptFunction::EntryInfo::SymbolHasInstance.GetOriginalEntryPoint()))",
          "7024:             {",
          "",
          "[Removed Lines]",
          "7021:             Var instOfHandler = JavascriptOperators::GetProperty(constructor, PropertyIds::_symbolHasInstance, scriptContext);",
          "",
          "[Added Lines]",
          "7044:             Var instOfHandler = JavascriptOperators::GetPropertyNoCache(constructor,",
          "7045:               PropertyIds::_symbolHasInstance, scriptContext);",
          "",
          "---------------",
          "--- Hunk 21 ---",
          "[Context before]",
          "7098:                         JavascriptError::ThrowTypeError(scriptContext, JSERR_InvalidPrototype);",
          "7099:                     }",
          "7102:                     uint extendsProtoTypeId = JavascriptOperators::GetTypeId(extendsProto);",
          "7103:                     if (extendsProtoTypeId <= Js::TypeId::TypeIds_LastJavascriptPrimitiveType && extendsProtoTypeId != Js::TypeId::TypeIds_Null)",
          "7104:                     {",
          "7105:                         JavascriptError::ThrowTypeError(scriptContext, JSERR_InvalidPrototype);",
          "7106:                     }",
          "7109:                     RecyclableObject * ctorProtoObj = RecyclableObject::FromVar(ctorProto);",
          "7111:                     ctorProtoObj->SetPrototype(RecyclableObject::FromVar(extendsProto));",
          "",
          "[Removed Lines]",
          "7101:                     Var extendsProto = JavascriptOperators::GetProperty(extends, extendsObj, Js::PropertyIds::prototype, scriptContext);",
          "7108:                     Var ctorProto = JavascriptOperators::GetProperty(constructor, ctor, Js::PropertyIds::prototype, scriptContext);",
          "",
          "[Added Lines]",
          "7125:                     Var extendsProto = JavascriptOperators::GetPropertyNoCache(extends, extendsObj, Js::PropertyIds::prototype, scriptContext);",
          "7132:                     Var ctorProto = JavascriptOperators::GetPropertyNoCache(constructor, ctor, Js::PropertyIds::prototype, scriptContext);",
          "",
          "---------------",
          "--- Hunk 22 ---",
          "[Context before]",
          "7113:                     ctorProtoObj->EnsureProperty(Js::PropertyIds::constructor);",
          "7114:                     ctorProtoObj->SetEnumerable(Js::PropertyIds::constructor, FALSE);",
          "7117:                     RecyclableObject * protoCtorObj = RecyclableObject::FromVar(protoCtor);",
          "7118:                     protoCtorObj->SetPrototype(extendsObj);",
          "",
          "[Removed Lines]",
          "7116:                     Var protoCtor = JavascriptOperators::GetProperty(ctorProto, ctorProtoObj, Js::PropertyIds::constructor, scriptContext);",
          "",
          "[Added Lines]",
          "7140:                     Var protoCtor = JavascriptOperators::GetPropertyNoCache(ctorProto, ctorProtoObj, Js::PropertyIds::constructor, scriptContext);",
          "",
          "---------------",
          "--- Hunk 23 ---",
          "[Context before]",
          "8994:         Var value;",
          "8995:         RecyclableObject* propertySpecObj = RecyclableObject::FromVar(propertySpec);",
          "8998:         {",
          "8999:             descriptor->SetEnumerable(JavascriptConversion::ToBoolean(value, scriptContext) ? true : false);",
          "9000:         }",
          "9003:         {",
          "9004:             descriptor->SetConfigurable(JavascriptConversion::ToBoolean(value, scriptContext) ? true : false);",
          "9005:         }",
          "9008:         {",
          "9009:             descriptor->SetValue(value);",
          "9010:         }",
          "9013:         {",
          "9014:             descriptor->SetWritable(JavascriptConversion::ToBoolean(value, scriptContext) ? true : false);",
          "9015:         }",
          "9018:         {",
          "9019:             if (JavascriptOperators::GetTypeId(value) != TypeIds_Undefined && (false == JavascriptConversion::IsCallable(value)))",
          "9020:             {",
          "",
          "[Removed Lines]",
          "8997:         if (JavascriptOperators::GetProperty(propertySpecObj, PropertyIds::enumerable, &value, scriptContext))",
          "9002:         if (JavascriptOperators::GetProperty(propertySpecObj, PropertyIds::configurable, &value, scriptContext))",
          "9007:         if (JavascriptOperators::GetProperty(propertySpecObj, PropertyIds::value, &value, scriptContext))",
          "9012:         if (JavascriptOperators::GetProperty(propertySpecObj, PropertyIds::writable, &value, scriptContext))",
          "9017:         if (JavascriptOperators::GetProperty(propertySpecObj, PropertyIds::get, &value, scriptContext))",
          "",
          "[Added Lines]",
          "9021:         if (JavascriptOperators::GetPropertyNoCache(propertySpecObj, PropertyIds::enumerable, &value, scriptContext))",
          "9026:         if (JavascriptOperators::GetPropertyNoCache(propertySpecObj, PropertyIds::configurable, &value, scriptContext))",
          "9031:         if (JavascriptOperators::GetPropertyNoCache(propertySpecObj, PropertyIds::value, &value, scriptContext))",
          "9036:         if (JavascriptOperators::GetPropertyNoCache(propertySpecObj, PropertyIds::writable, &value, scriptContext))",
          "9041:         if (JavascriptOperators::GetPropertyNoCache(propertySpecObj, PropertyIds::get, &value, scriptContext))",
          "",
          "---------------",
          "--- Hunk 24 ---",
          "[Context before]",
          "9023:             descriptor->SetGetter(value);",
          "9024:         }",
          "9027:         {",
          "9028:             if (JavascriptOperators::GetTypeId(value) != TypeIds_Undefined && (false == JavascriptConversion::IsCallable(value)))",
          "9029:             {",
          "",
          "[Removed Lines]",
          "9026:         if (JavascriptOperators::GetProperty(propertySpecObj, PropertyIds::set, &value, scriptContext))",
          "",
          "[Added Lines]",
          "9050:         if (JavascriptOperators::GetPropertyNoCache(propertySpecObj, PropertyIds::set, &value, scriptContext))",
          "",
          "---------------",
          "--- Hunk 25 ---",
          "[Context before]",
          "10062:             Var species = nullptr;",
          "10064:                 || JavascriptOperators::IsUndefinedOrNull(species))",
          "10065:             {",
          "",
          "[Removed Lines]",
          "10063:             if (!JavascriptOperators::GetProperty(RecyclableObject::FromVar(constructor), PropertyIds::_symbolSpecies, &species, scriptContext)",
          "",
          "[Added Lines]",
          "10087:             if (!JavascriptOperators::GetProperty(RecyclableObject::FromVar(constructor),",
          "10088:                 PropertyIds::_symbolSpecies, &species, scriptContext)",
          "",
          "---------------",
          "--- Hunk 26 ---",
          "[Context before]",
          "10423:         return IsUndefinedOrNullType(JavascriptOperators::GetTypeId(instance));",
          "10424:     }",
          "10426:     BOOL JavascriptOperators::IsNull(Var instance)",
          "10427:     {",
          "10428:         return JavascriptOperators::GetTypeId(instance) == TypeIds_Null;",
          "10429:     }",
          "10431:     BOOL JavascriptOperators::IsSpecialObjectType(TypeId typeId)",
          "10432:     {",
          "10433:         return typeId > TypeIds_LastTrueJavascriptObjectType;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "10451:     BOOL JavascriptOperators::IsUndefinedOrNull(RecyclableObject* instance)",
          "10452:     {",
          "10453:         return JavascriptOperators::IsUndefinedOrNullType(instance->GetTypeId());",
          "10454:     }",
          "10456:     BOOL JavascriptOperators::IsUndefinedOrNull(Var instance, ScriptContext* scriptContext)",
          "10457:     {",
          "10458:         JavascriptLibrary* library = scriptContext->GetLibrary();",
          "10459:         return IsUndefinedObject(instance, library) || IsNull(instance, library);",
          "10460:     }",
          "10462:     BOOL JavascriptOperators::IsUndefinedOrNull(Var instance, JavascriptLibrary* library)",
          "10463:     {",
          "10464:         return IsUndefinedObject(instance, library) || IsNull(instance, library);",
          "10465:     }",
          "10472:     BOOL JavascriptOperators::IsNull(Var instance, ScriptContext* scriptContext)",
          "10473:     {",
          "10474:         return JavascriptOperators::IsNull(instance, scriptContext->GetLibrary());",
          "10475:     }",
          "10477:     BOOL JavascriptOperators::IsNull(Var instance, JavascriptLibrary* library)",
          "10478:     {",
          "10479:         Assert(!RecyclableObject::Is(instance) ? TRUE : ((RecyclableObject*)instance)->GetScriptContext()->GetLibrary() == library );",
          "10480:         return library->GetNull() == instance;",
          "10481:     }",
          "10483:     BOOL JavascriptOperators::IsNull(RecyclableObject* instance)",
          "10484:     {",
          "10485:         return instance->GetType()->GetTypeId() == TypeIds_Null;",
          "10486:     }",
          "",
          "---------------",
          "--- Hunk 27 ---",
          "[Context before]",
          "10438:         return JavascriptOperators::GetTypeId(instance) == TypeIds_Undefined;",
          "10439:     }",
          "10442:     {",
          "10445:         return instance == libraryUndefined;",
          "10446:     }",
          "10448:     BOOL JavascriptOperators::IsUndefinedObject(Var instance, ScriptContext *scriptContext)",
          "10449:     {",
          "10451:     }",
          "10453:     BOOL JavascriptOperators::IsUndefinedObject(Var instance, JavascriptLibrary* library)",
          "10454:     {",
          "10455:         return JavascriptOperators::IsUndefinedObject(instance, library->GetUndefined());",
          "10456:     }",
          "",
          "[Removed Lines]",
          "10441:     BOOL JavascriptOperators::IsUndefinedObject(Var instance, RecyclableObject *libraryUndefined)",
          "10443:         Assert(JavascriptOperators::IsUndefinedObject(libraryUndefined));",
          "10450:         return JavascriptOperators::IsUndefinedObject(instance, scriptContext->GetLibrary()->GetUndefined());",
          "",
          "[Added Lines]",
          "10498:     BOOL JavascriptOperators::IsUndefinedObject(RecyclableObject* instance)",
          "10500:         return instance->GetType()->GetTypeId() == TypeIds_Undefined;",
          "10501:     }",
          "10503:     BOOL JavascriptOperators::IsUndefinedObject(Var instance, RecyclableObject* libraryUndefined)",
          "10504:     {",
          "10505:         Assert(JavascriptOperators::IsUndefinedObject(libraryUndefined));",
          "10506:         AssertMsg((instance == libraryUndefined)",
          "10507:           == JavascriptOperators::IsUndefinedObject(instance), \"Wrong ScriptContext?\");",
          "10513:         return JavascriptOperators::IsUndefinedObject(instance, scriptContext->GetLibrary());",
          "10518:         Assert(!RecyclableObject::Is(instance) ? TRUE : ((RecyclableObject*)instance)->GetScriptContext()->GetLibrary() == library );",
          "",
          "---------------",
          "--- Hunk 28 ---",
          "[Context before]",
          "10477:     RecyclableObject* JavascriptOperators::GetIteratorFunction(RecyclableObject* instance, ScriptContext * scriptContext, bool optional)",
          "10478:     {",
          "10481:         if (optional && JavascriptOperators::IsUndefinedOrNull(func))",
          "10482:         {",
          "",
          "[Removed Lines]",
          "10479:         Var func = JavascriptOperators::GetProperty(instance, PropertyIds::_symbolIterator, scriptContext);",
          "",
          "[Added Lines]",
          "10543:         Var func = JavascriptOperators::GetPropertyNoCache(instance, PropertyIds::_symbolIterator, scriptContext);",
          "",
          "---------------",
          "--- Hunk 29 ---",
          "[Context before]",
          "10538:     RecyclableObject* JavascriptOperators::IteratorNext(RecyclableObject* iterator, ScriptContext* scriptContext, Var value)",
          "10539:     {",
          "10542:         ThreadContext *threadContext = scriptContext->GetThreadContext();",
          "10543:         if (!JavascriptConversion::IsCallable(func))",
          "",
          "[Removed Lines]",
          "10540:         Var func = JavascriptOperators::GetProperty(iterator, PropertyIds::next, scriptContext);",
          "",
          "[Added Lines]",
          "10604:         Var func = JavascriptOperators::GetPropertyNoCache(iterator, PropertyIds::next, scriptContext);",
          "",
          "---------------",
          "--- Hunk 30 ---",
          "[Context before]",
          "10573:     bool JavascriptOperators::IteratorComplete(RecyclableObject* iterResult, ScriptContext* scriptContext)",
          "10574:     {",
          "10577:         return JavascriptConversion::ToBool(done, scriptContext);",
          "10578:     }",
          "",
          "[Removed Lines]",
          "10575:         Var done = JavascriptOperators::GetProperty(iterResult, Js::PropertyIds::done, scriptContext);",
          "",
          "[Added Lines]",
          "10639:         Var done = JavascriptOperators::GetPropertyNoCache(iterResult, Js::PropertyIds::done, scriptContext);",
          "",
          "---------------",
          "--- Hunk 31 ---",
          "[Context before]",
          "10581:     Var JavascriptOperators::IteratorValue(RecyclableObject* iterResult, ScriptContext* scriptContext)",
          "10582:     {",
          "10584:     }",
          "",
          "[Removed Lines]",
          "10583:         return JavascriptOperators::GetProperty(iterResult, Js::PropertyIds::value, scriptContext);",
          "",
          "[Added Lines]",
          "10647:         return JavascriptOperators::GetPropertyNoCache(iterResult, Js::PropertyIds::value, scriptContext);",
          "",
          "---------------",
          "--- Hunk 32 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "10620:         Var proto = JavascriptOperators::GetProperty(constructor, Js::PropertyIds::prototype, scriptContext);",
          "",
          "[Added Lines]",
          "10684:         Var proto = JavascriptOperators::GetPropertyNoCache(constructor, Js::PropertyIds::prototype, scriptContext);",
          "",
          "---------------",
          "--- Hunk 33 ---",
          "[Context before]",
          "10650:         return requestContext->GetMissingPropertyResult();",
          "10651:     }",
          "10653:     Var JavascriptOperators::GetRootProperty(RecyclableObject* instance, PropertyId propertyId, ScriptContext* requestContext, PropertyValueInfo* info)",
          "10654:     {",
          "10655:         Var value;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "10717:     Var JavascriptOperators::GetPropertyNoCache(RecyclableObject* instance, PropertyId propertyId, ScriptContext* requestContext)",
          "10718:     {",
          "10719:         return JavascriptOperators::GetPropertyNoCache(instance, instance, propertyId, requestContext);",
          "10720:     }",
          "10722:     Var JavascriptOperators::GetPropertyNoCache(Var instance, RecyclableObject* propertyObject, PropertyId propertyId, ScriptContext* requestContext)",
          "10723:     {",
          "10724:         Var value;",
          "10725:         JavascriptOperators::GetProperty_InternalSimple(instance, propertyObject, propertyId, &value, requestContext);",
          "10726:         return value;",
          "10727:     }",
          "10729:     BOOL JavascriptOperators::GetPropertyNoCache(RecyclableObject* instance, PropertyId propertyId, Var* value, ScriptContext* requestContext)",
          "10730:     {",
          "10731:         return JavascriptOperators::GetPropertyNoCache(instance, instance, propertyId, value, requestContext);",
          "10732:     }",
          "10734:     BOOL JavascriptOperators::GetPropertyNoCache(Var instance, RecyclableObject* propertyObject, PropertyId propertyId, Var* value, ScriptContext* requestContext)",
          "10735:     {",
          "10736:         return JavascriptOperators::GetProperty_InternalSimple(instance, propertyObject, propertyId, value, requestContext);",
          "10737:     }",
          "",
          "---------------"
        ],
        "lib/Runtime/Language/JavascriptOperators.h||lib/Runtime/Language/JavascriptOperators.h": [
          "File: lib/Runtime/Language/JavascriptOperators.h -> lib/Runtime/Language/JavascriptOperators.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "179:         static Var  GetProperty(RecyclableObject* instance, PropertyId propertyId, ScriptContext* requestContext, PropertyValueInfo* info = NULL);",
          "180:         static BOOL GetProperty(RecyclableObject* instance, PropertyId propertyId, Var* value, ScriptContext* requestContext, PropertyValueInfo* info = NULL);",
          "181:         static Var  GetProperty(Var instance, RecyclableObject* propertyObject, PropertyId propertyId, ScriptContext* requestContext, PropertyValueInfo* info = NULL);",
          "182:         static BOOL GetProperty(Var instance, RecyclableObject* propertyObject, PropertyId propertyId, Var* value, ScriptContext* requestContext, PropertyValueInfo* info = NULL);",
          "183:         static BOOL GetPropertyObject(Var instance, ScriptContext * scriptContext, RecyclableObject** propertyObject);",
          "184:         static BOOL GetRootProperty(Var instance, PropertyId propertyId, Var* value, ScriptContext* requestContext, PropertyValueInfo* info = NULL);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "183:         static Var  GetPropertyNoCache(Var instance, RecyclableObject* propertyObject, PropertyId propertyId, ScriptContext* requestContext);",
          "184:         static Var  GetPropertyNoCache(RecyclableObject* instance, PropertyId propertyId, ScriptContext* requestContext);",
          "185:         static BOOL GetPropertyNoCache(RecyclableObject* instance, PropertyId propertyId, Var* value, ScriptContext* requestContext);",
          "186:         static BOOL GetPropertyNoCache(Var instance, RecyclableObject* propertyObject, PropertyId propertyId, Var* value, ScriptContext* requestContext);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "209:         static BOOL IsObjectType(TypeId typeId);",
          "210:         static BOOL IsObjectOrNull(Var instance);",
          "211:         static BOOL IsUndefined(Var instance);",
          "212:         static BOOL IsUndefinedOrNullType(TypeId);",
          "213:         static BOOL IsUndefinedOrNull(Var instance);",
          "214:         static BOOL IsNull(Var instance);",
          "215:         static BOOL IsSpecialObjectType(TypeId typeId);",
          "216:         static BOOL IsJsNativeObject(Var instance);",
          "217:         static BOOL IsUndefinedObject(Var instance);",
          "221:         static BOOL IsAnyNumberValue(Var instance);",
          "222:         static BOOL IsClassConstructor(Var instance);",
          "223:         static BOOL IsBaseConstructorKind(Var instance);",
          "225:         static bool CanShortcutOnUnknownPropertyName(RecyclableObject * instance);",
          "226:         static bool CanShortcutInstanceOnUnknownPropertyName(RecyclableObject *instance);",
          "227:         static bool CanShortcutPrototypeChainOnUnknownPropertyName(RecyclableObject *instance);",
          "",
          "[Removed Lines]",
          "218:         static BOOL IsUndefinedObject(Var instance, ScriptContext *scriptContext);",
          "219:         static BOOL IsUndefinedObject(Var instance, RecyclableObject *libraryUndefined);",
          "220:         static BOOL IsUndefinedObject(Var instance, JavascriptLibrary* library);",
          "",
          "[Added Lines]",
          "218:         static BOOL IsUndefinedObject(RecyclableObject* instance);",
          "221:         static BOOL IsUndefinedOrNull(RecyclableObject* instance);",
          "223:         static BOOL IsNull(RecyclableObject* instance);",
          "232:         static BOOL IsUndefinedOrNull(Var instance, JavascriptLibrary* library);",
          "233:         static BOOL IsUndefinedOrNull(Var instance, ScriptContext* scriptContext);",
          "234:         static BOOL IsNull(Var instance, ScriptContext* scriptContext);",
          "235:         static BOOL IsNull(Var instance, JavascriptLibrary* library);",
          "236:         static BOOL IsUndefinedObject(Var instance, ScriptContext* scriptContext);",
          "237:         static BOOL IsUndefinedObject(Var instance, RecyclableObject* libraryUndefined);",
          "238:         static BOOL IsUndefinedObject(Var instance, JavascriptLibrary* library);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "643:         static void BuildHandlerScope(Var argThis, RecyclableObject * hostObject, FrameDisplay * pScopes, ScriptContext * scriptContext);",
          "644:         static void TryLoadRoot(Var& thisVar, TypeId typeId, int moduleID, ScriptContextInfo* scriptContext);",
          "646:         template <bool unscopables>",
          "647:         static BOOL GetProperty_Internal(Var instance, RecyclableObject* propertyObject, const bool isRoot, PropertyId propertyId, Var* value, ScriptContext* requestContext, PropertyValueInfo* info);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "661:         static BOOL GetProperty_InternalSimple(Var instance, RecyclableObject* object, PropertyId propertyId, _Outptr_result_maybenull_ Var* value, ScriptContext* requestContext);",
          "",
          "---------------"
        ],
        "lib/Runtime/Library/BoundFunction.cpp||lib/Runtime/Library/BoundFunction.cpp": [
          "File: lib/Runtime/Library/BoundFunction.cpp -> lib/Runtime/Library/BoundFunction.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "275:         JavascriptString* displayName = GetLibrary()->GetEmptyString();",
          "276:         if (targetFunction != nullptr)",
          "277:         {",
          "279:             if (JavascriptString::Is(value))",
          "280:             {",
          "281:                 displayName = JavascriptString::FromVar(value);",
          "",
          "[Removed Lines]",
          "278:             Var value = JavascriptOperators::GetProperty(targetFunction, PropertyIds::name, targetFunction->GetScriptContext());",
          "",
          "[Added Lines]",
          "278:             Var value = JavascriptOperators::GetPropertyNoCache(targetFunction, PropertyIds::name, targetFunction->GetScriptContext());",
          "",
          "---------------"
        ],
        "lib/Runtime/Library/JavascriptArray.cpp||lib/Runtime/Library/JavascriptArray.cpp": [
          "File: lib/Runtime/Library/JavascriptArray.cpp -> lib/Runtime/Library/JavascriptArray.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "825:     void JavascriptArray::InternalFillFromPrototype(JavascriptArray *dstArray, uint32 dstIndex, JavascriptArray *srcArray, uint32 start, uint32 end, uint32 count)",
          "826:     {",
          "827:         RecyclableObject* prototype = srcArray->GetPrototype();",
          "829:         {",
          "830:             ForEachOwnMissingArrayIndexOfObject(srcArray, dstArray, prototype, start, end, dstIndex, [&](uint32 index, Var value) {",
          "831:                 uint32 n = dstIndex + (index - start);",
          "",
          "[Removed Lines]",
          "828:         while (start + count != end && JavascriptOperators::GetTypeId(prototype) != TypeIds_Null)",
          "",
          "[Added Lines]",
          "828:         while (start + count != end && !JavascriptOperators::IsNull(prototype))",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "4336:     JavascriptString* JavascriptArray::JoinToString(Var value, ScriptContext* scriptContext)",
          "4337:     {",
          "4338:         TypeId typeId = JavascriptOperators::GetTypeId(value);",
          "4340:         {",
          "4341:             return scriptContext->GetLibrary()->GetEmptyString();",
          "4342:         }",
          "",
          "[Removed Lines]",
          "4339:         if (typeId == TypeIds_Null || typeId == TypeIds_Undefined)",
          "",
          "[Added Lines]",
          "4339:         if (typeId <= TypeIds_UndefinedOrNull)",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "5334:         if (forceCheckProtoChain || arr->IsFillFromPrototypes())",
          "5335:         {",
          "5336:             RecyclableObject* prototype = arr->GetPrototype();",
          "5339:             {",
          "5340:                 RecyclableObject* protoObj = prototype;",
          "",
          "[Removed Lines]",
          "5338:             while (JavascriptOperators::GetTypeId(prototype) != TypeIds_Null)",
          "",
          "[Added Lines]",
          "5337:             while (!JavascriptOperators::IsNull(prototype))",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "8018:         }",
          "8022:         if (JavascriptConversion::IsCallable(join))",
          "8023:         {",
          "8024:             RecyclableObject* func = RecyclableObject::FromVar(join);",
          "",
          "[Removed Lines]",
          "8021:         JS_REENTRANT(jsReentLock, Var join = JavascriptOperators::GetProperty(obj, PropertyIds::join, scriptContext));",
          "",
          "[Added Lines]",
          "8020:         JS_REENTRANT(jsReentLock, Var join = JavascriptOperators::GetPropertyNoCache(obj, PropertyIds::join, scriptContext));",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "10451:     JavascriptString* JavascriptArray::ToLocaleStringHelper(Var value, ScriptContext* scriptContext)",
          "10452:     {",
          "10453:         TypeId typeId = JavascriptOperators::GetTypeId(value);",
          "10455:         {",
          "10456:             return scriptContext->GetLibrary()->GetEmptyString();",
          "10457:         }",
          "",
          "[Removed Lines]",
          "10454:         if (typeId == TypeIds_Null || typeId == TypeIds_Undefined)",
          "",
          "[Added Lines]",
          "10453:         if (typeId <= TypeIds_UndefinedOrNull)",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "10491:         }",
          "10493:         RecyclableObject* prototype = this->GetPrototype();",
          "10497:         {",
          "10498:             ForEachOwnMissingArrayIndexOfObject(this, nullptr, prototype, startIndex, limitIndex,0, [this](uint32 index, Var value) {",
          "10499:                 this->SetItem(index, value, PropertyOperation_None);",
          "",
          "[Removed Lines]",
          "10496:         while (JavascriptOperators::GetTypeId(prototype) != TypeIds_Null)",
          "",
          "[Added Lines]",
          "10494:         while (!JavascriptOperators::IsNull(prototype))",
          "",
          "---------------"
        ],
        "lib/Runtime/Library/JavascriptError.cpp||lib/Runtime/Library/JavascriptError.cpp": [
          "File: lib/Runtime/Library/JavascriptError.cpp -> lib/Runtime/Library/JavascriptError.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "186:         JavascriptString *outputStr, *message;",
          "190:             JavascriptOperators::GetTypeId(value) != TypeIds_Undefined;",
          "192:         if (hasName)",
          "",
          "[Removed Lines]",
          "189:         BOOL hasName = JavascriptOperators::GetProperty(thisError, PropertyIds::name, &value, scriptContext, NULL) &&",
          "",
          "[Added Lines]",
          "189:         BOOL hasName = JavascriptOperators::GetPropertyNoCache(thisError, PropertyIds::name, &value, scriptContext) &&",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "199:         }",
          "203:             && JavascriptOperators::GetTypeId(value) != TypeIds_Undefined)",
          "204:         {",
          "205:             message = JavascriptConversion::ToString(value, scriptContext);",
          "",
          "[Removed Lines]",
          "202:         if (JavascriptOperators::GetProperty(thisError, PropertyIds::message, &value, scriptContext, NULL)",
          "",
          "[Added Lines]",
          "202:         if (JavascriptOperators::GetPropertyNoCache(thisError, PropertyIds::message, &value, scriptContext)",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "528:         Assert(scriptContext->GetThreadContext()->IsScriptActive());",
          "531:         if (TaggedInt::Is(number))",
          "532:         {",
          "533:             hr = TaggedInt::ToInt32(number);",
          "",
          "[Removed Lines]",
          "530:         Var number = JavascriptOperators::GetProperty(errorObject, Js::PropertyIds::number, scriptContext, NULL);",
          "",
          "[Added Lines]",
          "530:         Var number = JavascriptOperators::GetPropertyNoCache(errorObject, Js::PropertyIds::number, scriptContext);",
          "",
          "---------------"
        ],
        "lib/Runtime/Library/JavascriptExternalFunction.cpp||lib/Runtime/Library/JavascriptExternalFunction.cpp": [
          "File: lib/Runtime/Library/JavascriptExternalFunction.cpp -> lib/Runtime/Library/JavascriptExternalFunction.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "249:     Var JavascriptExternalFunction::DefaultExternalFunctionThunk(RecyclableObject* function, CallInfo callInfo, ...)",
          "250:     {",
          "251:         TypeId typeId = function->GetTypeId();",
          "253:         JavascriptError::ThrowTypeError(function->GetScriptContext(), err);",
          "254:     }",
          "",
          "[Removed Lines]",
          "252:         rtErrors err = typeId == TypeIds_Undefined || typeId == TypeIds_Null ? JSERR_NeedObject : JSERR_NeedFunction;",
          "",
          "[Added Lines]",
          "252:         rtErrors err = typeId <= TypeIds_UndefinedOrNull ? JSERR_NeedObject : JSERR_NeedFunction;",
          "",
          "---------------"
        ],
        "lib/Runtime/Library/JavascriptFunction.cpp||lib/Runtime/Library/JavascriptFunction.cpp": [
          "File: lib/Runtime/Library/JavascriptFunction.cpp -> lib/Runtime/Library/JavascriptFunction.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "469:         {",
          "470:             bool isArray = JavascriptArray::Is(argArray);",
          "471:             TypeId typeId = JavascriptOperators::GetTypeId(argArray);",
          "474:             if (!isNullOrUndefined && !JavascriptOperators::IsObject(argArray)) // ES5: throw if Type(argArray) is not Object",
          "475:             {",
          "",
          "[Removed Lines]",
          "472:             bool isNullOrUndefined = (typeId == TypeIds_Null || typeId == TypeIds_Undefined);",
          "",
          "[Added Lines]",
          "472:             bool isNullOrUndefined = typeId <= TypeIds_UndefinedOrNull;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "3348:         }",
          "3349:         else",
          "3350:         {",
          "3352:         }",
          "3353:         funcPrototype = CrossSite::MarshalVar(scriptContext, funcPrototype);",
          "3354:         return JavascriptFunction::HasInstance(funcPrototype, instance, scriptContext, inlineCache, this);",
          "",
          "[Removed Lines]",
          "3351:             funcPrototype = JavascriptOperators::GetProperty(this, PropertyIds::prototype, scriptContext, nullptr);",
          "",
          "[Added Lines]",
          "3351:             funcPrototype = JavascriptOperators::GetPropertyNoCache(this, PropertyIds::prototype, scriptContext);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "3421:         if (!JavascriptOperators::IsObject(funcPrototype))",
          "3422:         {",
          "",
          "[Removed Lines]",
          "3419:         Var prototype = JavascriptOperators::GetPrototype(RecyclableObject::FromVar(instance));",
          "",
          "[Added Lines]",
          "3419:         RecyclableObject* instanceObject = RecyclableObject::FromVar(instance);",
          "3420:         Var prototype = JavascriptOperators::GetPrototype(instanceObject);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "3429:         {",
          "3430:             if (prototype == funcPrototype)",
          "3431:             {",
          "",
          "[Removed Lines]",
          "3428:         while (JavascriptOperators::GetTypeId(prototype) != TypeIds_Null)",
          "",
          "[Added Lines]",
          "3429:         while (!JavascriptOperators::IsNull(prototype))",
          "",
          "---------------"
        ],
        "lib/Runtime/Library/JavascriptLibrary.cpp||lib/Runtime/Library/JavascriptLibrary.cpp": [
          "File: lib/Runtime/Library/JavascriptLibrary.cpp -> lib/Runtime/Library/JavascriptLibrary.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "4021:     {",
          "4022:         Var arrayIteratorPrototypeNext = nullptr;",
          "4023:         ImplicitCallFlags flags = scriptContext->GetThreadContext()->TryWithDisabledImplicitCall(",
          "4026:         return (flags != ImplicitCall_None) || arrayIteratorPrototypeNext != scriptContext->GetLibrary()->GetArrayIteratorPrototypeBuiltinNextFunction();",
          "4027:     }",
          "",
          "[Removed Lines]",
          "4024:             [&]() { arrayIteratorPrototypeNext = JavascriptOperators::GetProperty(scriptContext->GetLibrary()->GetArrayIteratorPrototype(), PropertyIds::next, scriptContext); });",
          "",
          "[Added Lines]",
          "4024:             [&]() { arrayIteratorPrototypeNext = JavascriptOperators::GetPropertyNoCache(scriptContext->GetLibrary()->GetArrayIteratorPrototype(), PropertyIds::next, scriptContext); });",
          "",
          "---------------"
        ],
        "lib/Runtime/Library/JavascriptMap.cpp||lib/Runtime/Library/JavascriptMap.cpp": [
          "File: lib/Runtime/Library/JavascriptMap.cpp -> lib/Runtime/Library/JavascriptMap.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "80:         if (JavascriptConversion::CheckObjectCoercible(iterable, scriptContext))",
          "81:         {",
          "82:             iter = JavascriptOperators::GetIterator(iterable, scriptContext);",
          "84:             if (!JavascriptConversion::IsCallable(adderVar))",
          "85:             {",
          "86:                 JavascriptError::ThrowTypeError(scriptContext, JSERR_NeedFunction);",
          "",
          "[Removed Lines]",
          "83:             Var adderVar = JavascriptOperators::GetProperty(mapObject, PropertyIds::set, scriptContext);",
          "",
          "[Added Lines]",
          "83:             Var adderVar = JavascriptOperators::GetPropertyNoCache(mapObject, PropertyIds::set, scriptContext);",
          "",
          "---------------"
        ],
        "lib/Runtime/Library/JavascriptNumber.cpp||lib/Runtime/Library/JavascriptNumber.cpp": [
          "File: lib/Runtime/Library/JavascriptNumber.cpp -> lib/Runtime/Library/JavascriptNumber.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "997:     {",
          "998:         TypeId typeId = JavascriptOperators::GetTypeId(aValue);",
          "1001:         {",
          "1002:             return FALSE;",
          "1003:         }",
          "1006:         {",
          "1008:             return TRUE;",
          "1009:         }",
          "1011:         {",
          "1013:             return TRUE;",
          "1014:         }",
          "1016:         {",
          "1018:             return TRUE;",
          "",
          "[Removed Lines]",
          "1000:         if (typeId == TypeIds_Null || typeId == TypeIds_Undefined)",
          "1005:         if (TaggedInt::Is(aValue))",
          "1010:         else if (Js::JavascriptOperators::GetTypeId(aValue) == TypeIds_Int64Number)",
          "1015:         else if (Js::JavascriptOperators::GetTypeId(aValue) == TypeIds_UInt64Number)",
          "",
          "[Added Lines]",
          "1000:         if (typeId <= TypeIds_UndefinedOrNull)",
          "1005:         if (typeId == TypeIds_Integer)",
          "1010:         else if (typeId == TypeIds_Int64Number)",
          "1015:         else if (typeId == TypeIds_UInt64Number)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1023:             return TRUE;",
          "1024:         }",
          "1026:         {",
          "1027:             JavascriptNumberObject* obj = JavascriptNumberObject::FromVar(aValue);",
          "",
          "[Removed Lines]",
          "1025:         else if (JavascriptNumberObject::Is(aValue))",
          "",
          "[Added Lines]",
          "1025:         else if (typeId == TypeIds_NumberObject)",
          "",
          "---------------"
        ],
        "lib/Runtime/Library/JavascriptObject.cpp||lib/Runtime/Library/JavascriptObject.cpp": [
          "File: lib/Runtime/Library/JavascriptObject.cpp -> lib/Runtime/Library/JavascriptObject.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "304:             dynamicObject = RecyclableObject::FromVar(static_cast<Js::GlobalObject*>(dynamicObject)->ToThis());",
          "305:         }",
          "308:         {",
          "309:             value = JavascriptOperators::GetPrototype(value);",
          "310:             if (dynamicObject == value)",
          "",
          "[Removed Lines]",
          "307:         while (JavascriptOperators::GetTypeId(value) != TypeIds_Null)",
          "",
          "[Added Lines]",
          "307:         while (!JavascriptOperators::IsNull(value))",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "377:         RecyclableObject *thisArgAsObject = RecyclableObject::FromVar(JavascriptOperators::ToObject(thisArg, scriptContext));",
          "387:         auto buildToString = [&scriptContext](Var tag) {",
          "",
          "[Removed Lines]",
          "381:         BOOL isArray = JavascriptOperators::IsArray(thisArgAsObject);",
          "384:         Var tag = JavascriptOperators::GetProperty(thisArgAsObject, PropertyIds::_symbolToStringTag, scriptContext); // Let tag be the result of Get(O, @@toStringTag).",
          "",
          "[Added Lines]",
          "380:         Var tag = JavascriptOperators::GetPropertyNoCache(thisArgAsObject, PropertyIds::_symbolToStringTag, scriptContext); // Let tag be the result of Get(O, @@toStringTag).",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "402:             return buildToString(tag);",
          "403:         }",
          "406:         if (isArray)",
          "407:         {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "403:         BOOL isArray = JavascriptOperators::IsArray(thisArgAsObject);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "537:         AssertMsg(args.Info.Count > 0, \"Should always have implicit 'this'\");",
          "544:         {",
          "545:             JavascriptError::ThrowTypeError(scriptContext, JSERR_This_NullOrUndefined, _u(\"Object.prototype.valueOf\"));",
          "546:         }",
          "",
          "[Removed Lines]",
          "539:         TypeId argType = JavascriptOperators::GetTypeId(args[0]);",
          "543:         if ((argType == TypeIds_Null) || (argType == TypeIds_Undefined))",
          "",
          "[Added Lines]",
          "540:         if (JavascriptOperators::IsUndefinedOrNull(args[0]))",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1495:             RecyclableObject* from = nullptr;",
          "1496:             if (!JavascriptConversion::ToObject(args[i], scriptContext, &from))",
          "1497:             {",
          "1498:                 JavascriptError::ThrowTypeError(scriptContext, JSERR_FunctionArgument_NeedObject, _u(\"Object.assign\"));",
          "1499:             }",
          "",
          "[Removed Lines]",
          "1490:             if (JavascriptOperators::IsUndefinedOrNull(args[i]))",
          "1491:             {",
          "1492:                 continue;",
          "1493:             }",
          "",
          "[Added Lines]",
          "1491:                 if (JavascriptOperators::IsUndefinedOrNull(args[i]))",
          "1492:                 {",
          "1493:                     continue;",
          "1494:                 }",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1695:             }",
          "1696:             else",
          "1697:             {",
          "1699:             }",
          "1701:             if (descCount == descSize)",
          "",
          "[Removed Lines]",
          "1698:                 propertyRecord = scriptContext->GetPropertyName(propId);",
          "",
          "[Added Lines]",
          "1695:                 propertyRecord = ((PropertyString*)propertyName)->GetPropertyRecord();",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "1712:                 descriptors = temp;",
          "1713:             }",
          "1717:             AnalysisAssert(descCount < descSize);",
          "1718:             if (!JavascriptOperators::ToPropertyDescriptor(tempVar, &descriptors[descCount].descriptor, scriptContext))",
          "",
          "[Removed Lines]",
          "1715:             Var tempVar = JavascriptOperators::GetProperty(props, propId, scriptContext);",
          "",
          "[Added Lines]",
          "1712:             Var tempVar = JavascriptOperators::GetPropertyNoCache(props, propId, scriptContext);",
          "",
          "---------------"
        ],
        "lib/Runtime/Library/JavascriptPromise.cpp||lib/Runtime/Library/JavascriptPromise.cpp": [
          "File: lib/Runtime/Library/JavascriptPromise.cpp -> lib/Runtime/Library/JavascriptPromise.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "622:                 try",
          "623:                 {",
          "624:                     RecyclableObject* thenable = RecyclableObject::FromVar(resolution);",
          "627:                     if (JavascriptConversion::IsCallable(then))",
          "628:                     {",
          "",
          "[Removed Lines]",
          "625:                     Var then = JavascriptOperators::GetProperty(thenable, Js::PropertyIds::then, scriptContext);",
          "",
          "[Added Lines]",
          "625:                     Var then = JavascriptOperators::GetPropertyNoCache(thenable, Js::PropertyIds::then, scriptContext);",
          "",
          "---------------"
        ],
        "lib/Runtime/Library/JavascriptSet.cpp||lib/Runtime/Library/JavascriptSet.cpp": [
          "File: lib/Runtime/Library/JavascriptSet.cpp -> lib/Runtime/Library/JavascriptSet.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "77:         if (JavascriptConversion::CheckObjectCoercible(iterable, scriptContext))",
          "78:         {",
          "79:             iter = JavascriptOperators::GetIterator(iterable, scriptContext);",
          "81:             if (!JavascriptConversion::IsCallable(adderVar))",
          "82:             {",
          "83:                 JavascriptError::ThrowTypeError(scriptContext, JSERR_NeedFunction);",
          "",
          "[Removed Lines]",
          "80:             Var adderVar = JavascriptOperators::GetProperty(setObject, PropertyIds::add, scriptContext);",
          "",
          "[Added Lines]",
          "80:             Var adderVar = JavascriptOperators::GetPropertyNoCache(setObject, PropertyIds::add, scriptContext);",
          "",
          "---------------"
        ],
        "lib/Runtime/Library/JavascriptString.cpp||lib/Runtime/Library/JavascriptString.cpp": [
          "File: lib/Runtime/Library/JavascriptString.cpp -> lib/Runtime/Library/JavascriptString.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "1759:     Var JavascriptString::GetRegExSymbolFunction(Var regExp, PropertyId propertyId, ScriptContext* scriptContext)",
          "1760:     {",
          "1762:             RecyclableObject::FromVar(JavascriptOperators::ToObject(regExp, scriptContext)),",
          "1763:             propertyId,",
          "1764:             scriptContext);",
          "",
          "[Removed Lines]",
          "1761:         return JavascriptOperators::GetProperty(",
          "",
          "[Added Lines]",
          "1761:         return JavascriptOperators::GetPropertyNoCache(",
          "",
          "---------------"
        ],
        "lib/Runtime/Library/TypedArray.cpp||lib/Runtime/Library/TypedArray.cpp": [
          "File: lib/Runtime/Library/TypedArray.cpp -> lib/Runtime/Library/TypedArray.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "672:     PropertyQueryFlags TypedArrayBase::GetPropertyQuery(Var originalInstance, PropertyId propertyId, Var* value, PropertyValueInfo* info, ScriptContext* requestContext)",
          "673:     {",
          "676:         {",
          "678:             if (JavascriptOperators::GetTypeId(*value) == Js::TypeIds_Undefined)",
          "679:             {",
          "680:                 return PropertyQueryFlags::Property_NotFound;",
          "681:             }",
          "682:             return PropertyQueryFlags::Property_Found;",
          "683:         }",
          "686:         {",
          "688:             return PropertyQueryFlags::Property_NotFound_NoProto;",
          "",
          "[Removed Lines]",
          "674:         uint32 index = 0;",
          "675:         if (GetScriptContext()->IsNumericPropertyId(propertyId, &index))",
          "685:         if (!requestContext->GetPropertyName(propertyId)->IsSymbol() && CanonicalNumericIndexString(propertyId, requestContext))",
          "",
          "[Added Lines]",
          "674:         const Js::PropertyRecord* propertyRecord = requestContext->GetPropertyName(propertyId);",
          "675:         if (propertyRecord->IsNumeric())",
          "684:         if (!propertyRecord->IsSymbol() && CanonicalNumericIndexString(propertyId, requestContext))",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "735:     BOOL TypedArrayBase::SetProperty(PropertyId propertyId, Var value, PropertyOperationFlags flags, PropertyValueInfo* info)",
          "736:     {",
          "738:         ScriptContext *scriptContext = GetScriptContext();",
          "741:         {",
          "743:             return true;",
          "744:         }",
          "747:         {",
          "748:             return FALSE;",
          "749:         }",
          "",
          "[Removed Lines]",
          "737:         uint32 index;",
          "740:         if (GetScriptContext()->IsNumericPropertyId(propertyId, &index))",
          "742:             this->DirectSetItem(index, value);",
          "746:         if (!scriptContext->GetPropertyName(propertyId)->IsSymbol() && CanonicalNumericIndexString(propertyId, scriptContext))",
          "",
          "[Added Lines]",
          "738:         const PropertyRecord* propertyRecord = scriptContext->GetPropertyName(propertyId);",
          "739:         if (propertyRecord->IsNumeric())",
          "741:             this->DirectSetItem(propertyRecord->GetNumericValue(), value);",
          "745:         if (!propertyRecord->IsSymbol() && CanonicalNumericIndexString(propertyId, scriptContext))",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "947:     {",
          "948:         ScriptContext* scriptContext = GetScriptContext();",
          "953:         {",
          "954:             VerifySetItemAttributes(propertyId, attributes);",
          "956:         }",
          "959:         {",
          "960:             return FALSE;",
          "961:         }",
          "",
          "[Removed Lines]",
          "950:         uint32 index;",
          "952:         if (scriptContext->IsNumericPropertyId(propertyId, &index))",
          "955:             return SetItem(index, value);",
          "958:         if (!scriptContext->GetPropertyName(propertyId)->IsSymbol() && CanonicalNumericIndexString(propertyId, scriptContext))",
          "",
          "[Added Lines]",
          "949:         const PropertyRecord* propertyRecord = scriptContext->GetPropertyName(propertyId);",
          "950:         if (propertyRecord->IsNumeric())",
          "953:             return SetItem(propertyRecord->GetNumericValue(), value);",
          "956:         if (!propertyRecord->IsSymbol() && CanonicalNumericIndexString(propertyId, scriptContext))",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "80137812bfb9b72d89d57a3171cff69789a59f08",
      "candidate_info": {
        "commit_hash": "80137812bfb9b72d89d57a3171cff69789a59f08",
        "repo": "Microsoft/ChakraCore",
        "commit_url": "https://github.com/Microsoft/ChakraCore/commit/80137812bfb9b72d89d57a3171cff69789a59f08",
        "files": [
          "lib/Runtime/Library/JavascriptArray.cpp"
        ],
        "message": "[CVE-2017-8739] buffer overread IsMissingItem.\n\nThis is the case where array's length is bigger than head segment's length.\nFixed that by putting proper check.",
        "before_after_code_files": [
          "lib/Runtime/Library/JavascriptArray.cpp||lib/Runtime/Library/JavascriptArray.cpp"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "lib/Runtime/Library/JavascriptArray.cpp||lib/Runtime/Library/JavascriptArray.cpp"
          ],
          "candidate": [
            "lib/Runtime/Library/JavascriptArray.cpp||lib/Runtime/Library/JavascriptArray.cpp"
          ]
        }
      },
      "candidate_diff": {
        "lib/Runtime/Library/JavascriptArray.cpp||lib/Runtime/Library/JavascriptArray.cpp": [
          "File: lib/Runtime/Library/JavascriptArray.cpp -> lib/Runtime/Library/JavascriptArray.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "484:     bool JavascriptArray::IsMissingItem(uint32 index)",
          "485:     {",
          "487:         {",
          "488:             return false;",
          "489:         }",
          "",
          "[Removed Lines]",
          "486:         if (this->length <= index)",
          "",
          "[Added Lines]",
          "486:         if (!(this->head->left <= index && index < (this->head->left+ this->head->length)))",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "5981:         if (!pArr->HasNoMissingValues())",
          "5982:         {",
          "5984:             {",
          "5987:                 if (pArr->IsMissingItem(i + start))",
          "",
          "[Removed Lines]",
          "5983:             for (uint32 i = 0; i < newLen && (i + start) < pArr->length; i++)",
          "",
          "[Added Lines]",
          "5983:             for (uint32 i = 0; i < newLen; i++)",
          "5985:                 if (!(pArr->head->left <= (i + start) && (i + start) <  (pArr->head->left + pArr->head->length)))",
          "5986:                 {",
          "5987:                     break;",
          "5988:                 }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "5be7a19151c5a399e10e717e132e52245f4d8c6e",
      "candidate_info": {
        "commit_hash": "5be7a19151c5a399e10e717e132e52245f4d8c6e",
        "repo": "Microsoft/ChakraCore",
        "commit_url": "https://github.com/Microsoft/ChakraCore/commit/5be7a19151c5a399e10e717e132e52245f4d8c6e",
        "files": [
          "lib/Runtime/Library/JavascriptArray.cpp",
          "lib/Runtime/Library/JavascriptArray.h",
          "test/Array/array_splice2.baseline",
          "test/Bugs/misc_bugs.js"
        ],
        "message": "Fix for re-entrancy in splice and unshift\n\n When we have getter/setter at 4294967295, we go out in the user code and we end up throwing the re-entrancy error.\nFor splice we now take the slow path for the overflow case.\nfor unshift - just put the re-entrant macro around it and also handle the es5 array case.",
        "before_after_code_files": [
          "lib/Runtime/Library/JavascriptArray.cpp||lib/Runtime/Library/JavascriptArray.cpp",
          "lib/Runtime/Library/JavascriptArray.h||lib/Runtime/Library/JavascriptArray.h",
          "test/Array/array_splice2.baseline||test/Array/array_splice2.baseline",
          "test/Bugs/misc_bugs.js||test/Bugs/misc_bugs.js"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "lib/Runtime/Library/JavascriptArray.cpp||lib/Runtime/Library/JavascriptArray.cpp"
          ],
          "candidate": [
            "lib/Runtime/Library/JavascriptArray.cpp||lib/Runtime/Library/JavascriptArray.cpp"
          ]
        }
      },
      "candidate_diff": {
        "lib/Runtime/Library/JavascriptArray.cpp||lib/Runtime/Library/JavascriptArray.cpp": [
          "File: lib/Runtime/Library/JavascriptArray.cpp -> lib/Runtime/Library/JavascriptArray.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "7373:         ::Math::RecordOverflowPolicy newLenOverflow;",
          "7374:         uint32 newLen = UInt32Math::Add(len - deleteLen, insertLen, newLenOverflow); // new length of the array after splice",
          "7378:         if (deleteLen == insertLen)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "7377:         if (newLenOverflow.HasOverflowed())",
          "7378:         {",
          "7379:             pArr = EnsureNonNativeArray(pArr);",
          "7380:             JS_REENTRANT_UNLOCK(jsReentLock, return ObjectSpliceHelper<uint64>(pArr, len, start, deleteLen, insertArgs, insertLen, scriptContext, newObj));",
          "7381:         }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "7384:             JS_REENTRANT(jsReentLock, pArr->FillFromPrototypes(start, len));",
          "7385:         }",
          "7425:         if (insertArgs)",
          "7426:         {",
          "7427:             pArr = EnsureNonNativeArray(pArr);",
          "",
          "[Removed Lines]",
          "7391:         if (newLenOverflow.HasOverflowed())",
          "7392:         {",
          "7393:             pArr = EnsureNonNativeArray(pArr);",
          "7394:             BigIndex dstIndex = MaxArrayLength;",
          "7396:             uint32 maxInsertLen = MaxArrayLength - start;",
          "7397:             if (insertLen > maxInsertLen)",
          "7398:             {",
          "7400:                 for (uint32 i = maxInsertLen; i < insertLen; i++)",
          "7401:                 {",
          "7402:                     pArr->GenericDirectSetItemAt(dstIndex, insertArgs[i]);",
          "7403:                     ++dstIndex;",
          "7404:                 }",
          "7406:                 insertLen = maxInsertLen; // update",
          "7409:                 if (start + deleteLen < len)",
          "7410:                 {",
          "7411:                     pArr->TruncateToProperties(dstIndex, start + deleteLen);",
          "7412:                 }",
          "7413:             }",
          "7414:             else",
          "7415:             {",
          "7417:                 pArr->TruncateToProperties(dstIndex, MaxArrayLength - insertLen + deleteLen);",
          "7418:             }",
          "7420:             len = pArr->length; // update",
          "7421:             newLen = len - deleteLen + insertLen;",
          "7422:             Assert(newLen == MaxArrayLength);",
          "7423:         }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "7576:             newArr->ValidateArray();",
          "7577:             pArr->ValidateArray();",
          "7578: #endif",
          "7585:             return newArr;",
          "7586:         }",
          "7599:     template<typename T>",
          "7600:     RecyclableObject* JavascriptArray::ObjectSpliceHelper(RecyclableObject* pObj, T len, T start,",
          "",
          "[Removed Lines]",
          "7579:             if (newLenOverflow.HasOverflowed())",
          "7580:             {",
          "7582:                 JavascriptError::ThrowRangeError(scriptContext, JSERR_ArrayLengthAssignIncorrect);",
          "7583:             }",
          "7588:         if (newLenOverflow.HasOverflowed())",
          "7589:         {",
          "7590:             JS_REENTRANT_UNLOCK(jsReentLock, return ObjectSpliceHelper<uint64>(pArr, len, start, deleteLen, insertArgs, insertLen, scriptContext, newObj));",
          "7591:         }",
          "7592:         else // Use uint32 version if no overflow",
          "7593:         {",
          "7594:             JS_REENTRANT_UNLOCK(jsReentLock, return ObjectSpliceHelper<uint32>(pArr, len, start, deleteLen, insertArgs, insertLen, scriptContext, newObj));",
          "7595:         }",
          "7597:     }",
          "",
          "[Added Lines]",
          "7551:         JS_REENTRANT_UNLOCK(jsReentLock, return ObjectSpliceHelper<uint32>(pArr, len, start, deleteLen, insertArgs, insertLen, scriptContext, newObj));",
          "7552:    }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "7847:         pArr->SetHasNoMissingValues(hasNoMissingValues);",
          "7848:     }",
          "7850:     Var JavascriptArray::EntryUnshift(RecyclableObject* function, CallInfo callInfo, ...)",
          "7851:     {",
          "7852:         PROBE_STACK(function->GetScriptContext(), Js::Constants::MinStackDefault);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "7805:     Var JavascriptArray::UnshiftObjectHelper(Js::Arguments& args, ScriptContext * scriptContext)",
          "7806:     {",
          "7807:         JS_REENTRANCY_LOCK(jsReentLock, scriptContext->GetThreadContext());",
          "7808:         Assert(args.Info.Count >= 1);",
          "7810:         RecyclableObject* dynamicObject = nullptr;",
          "7811:         if (FALSE == JavascriptConversion::ToObject(args[0], scriptContext, &dynamicObject))",
          "7812:         {",
          "7813:             JavascriptError::ThrowTypeError(scriptContext, JSERR_This_NullOrUndefined, _u(\"Array.prototype.unshift\"));",
          "7814:         }",
          "7815:         uint32 unshiftElements = args.Info.Count - 1;",
          "7817:         JS_REENTRANT(jsReentLock, BigIndex length = OP_GetLength(dynamicObject, scriptContext));",
          "7818:         if (unshiftElements > 0)",
          "7819:         {",
          "7820:             uint32 MaxSpaceUint32 = MaxArrayLength - unshiftElements;",
          "7823:             BigIndex end = length > MaxSpaceUint32 ? MaxSpaceUint32 : length;",
          "7824:             if (end < length)",
          "7825:             {",
          "7828:                 if (length.IsSmallIndex())",
          "7829:                 {",
          "7830:                     JS_REENTRANT(jsReentLock, Unshift<BigIndex>(dynamicObject, MaxArrayLength, end.GetSmallIndex(), length.GetSmallIndex(), scriptContext));",
          "7831:                 }",
          "7832:                 else",
          "7833:                 {",
          "7834:                     JS_REENTRANT(jsReentLock, Unshift<BigIndex, uint64>(dynamicObject, MaxArrayLength, (uint64)end.GetSmallIndex(), length.GetBigIndex(), scriptContext));",
          "7835:                 }",
          "7836:             }",
          "7840:             JS_REENTRANT(jsReentLock, Unshift<uint32>(dynamicObject, unshiftElements, (uint32)0, end.GetSmallIndex(), scriptContext));",
          "7842:             for (uint32 i = 0; i < unshiftElements; i++)",
          "7843:             {",
          "7844:                 JS_REENTRANT(jsReentLock,",
          "7845:                     JavascriptOperators::SetItem(dynamicObject, dynamicObject, i, args[i + 1], scriptContext, PropertyOperation_ThrowIfNotExtensible, true));",
          "7846:             }",
          "7847:         }",
          "7849:         ThrowTypeErrorOnFailureHelper h(scriptContext, _u(\"Array.prototype.unshift\"));",
          "7852:         BigIndex newLen = length + unshiftElements;",
          "7853:         Var res = JavascriptNumber::ToVar(newLen.IsSmallIndex() ? newLen.GetSmallIndex() : newLen.GetBigIndex(), scriptContext);",
          "7854:         JS_REENTRANT(jsReentLock,",
          "7855:             BOOL setLength = JavascriptOperators::SetProperty(dynamicObject, dynamicObject, PropertyIds::length, res, scriptContext, PropertyOperation_ThrowIfNotExtensible));",
          "7856:         h.ThrowTypeErrorOnFailure(setLength);",
          "7857:         return res;",
          "7858:     }",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "7904:                     newLenOverflowed = true;",
          "7906:                     EnsureNonNativeArray(pArr);",
          "7908:                     Assert(pArr->length + unshiftElements == MaxArrayLength);",
          "7909:                 }",
          "7911:                 pArr->ClearSegmentMap(); // Dump segmentMap on unshift (before any possible allocation and throw)",
          "",
          "[Removed Lines]",
          "7907:                     pArr->TruncateToProperties(MaxArrayLength, maxLen);",
          "",
          "[Added Lines]",
          "7917:                     JS_REENTRANT(jsReentLock, pArr->TruncateToProperties(MaxArrayLength, maxLen));",
          "7919:                     if (ES5Array::Is(pArr))",
          "7920:                     {",
          "7921:                         JS_REENTRANT_UNLOCK(jsReentLock, return UnshiftObjectHelper(args, scriptContext));",
          "7922:                     }",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "7990:         }",
          "7991:         else",
          "7992:         {",
          "8039:         }",
          "8040:         return res;",
          "",
          "[Removed Lines]",
          "7993:             RecyclableObject* dynamicObject = nullptr;",
          "7994:             if (FALSE == JavascriptConversion::ToObject(args[0], scriptContext, &dynamicObject))",
          "7995:             {",
          "7996:                 JavascriptError::ThrowTypeError(scriptContext, JSERR_This_NullOrUndefined, _u(\"Array.prototype.unshift\"));",
          "7997:             }",
          "7999:             JS_REENTRANT(jsReentLock, BigIndex length = OP_GetLength(dynamicObject, scriptContext));",
          "8000:             if (unshiftElements > 0)",
          "8001:             {",
          "8002:                 uint32 MaxSpaceUint32 = MaxArrayLength - unshiftElements;",
          "8005:                 BigIndex end = length > MaxSpaceUint32 ? MaxSpaceUint32 : length;",
          "8006:                 if (end < length)",
          "8007:                 {",
          "8010:                     if (length.IsSmallIndex())",
          "8011:                     {",
          "8012:                         JS_REENTRANT(jsReentLock, Unshift<BigIndex>(dynamicObject, MaxArrayLength, end.GetSmallIndex(), length.GetSmallIndex(), scriptContext));",
          "8013:                     }",
          "8014:                     else",
          "8015:                     {",
          "8016:                         JS_REENTRANT(jsReentLock, Unshift<BigIndex, uint64>(dynamicObject, MaxArrayLength, (uint64)end.GetSmallIndex(), length.GetBigIndex(), scriptContext));",
          "8017:                     }",
          "8018:                 }",
          "8022:                 JS_REENTRANT(jsReentLock, Unshift<uint32>(dynamicObject, unshiftElements, (uint32)0, end.GetSmallIndex(), scriptContext));",
          "8024:                 for (uint32 i = 0; i < unshiftElements; i++)",
          "8025:                 {",
          "8026:                     JS_REENTRANT(jsReentLock,",
          "8027:                         JavascriptOperators::SetItem(dynamicObject, dynamicObject, i, args[i + 1], scriptContext, PropertyOperation_ThrowIfNotExtensible, true));",
          "8028:                 }",
          "8029:             }",
          "8031:             ThrowTypeErrorOnFailureHelper h(scriptContext, _u(\"Array.prototype.unshift\"));",
          "8034:             BigIndex newLen = length + unshiftElements;",
          "8035:             res = JavascriptNumber::ToVar(newLen.IsSmallIndex() ? newLen.GetSmallIndex() : newLen.GetBigIndex(), scriptContext);",
          "8036:             JS_REENTRANT(jsReentLock,",
          "8037:                 BOOL setLength = JavascriptOperators::SetProperty(dynamicObject, dynamicObject, PropertyIds::length, res, scriptContext, PropertyOperation_ThrowIfNotExtensible));",
          "8038:             h.ThrowTypeErrorOnFailure(setLength);",
          "",
          "[Added Lines]",
          "8007:             JS_REENTRANT_UNLOCK(jsReentLock, res = UnshiftObjectHelper(args, scriptContext));",
          "",
          "---------------"
        ],
        "lib/Runtime/Library/JavascriptArray.h||lib/Runtime/Library/JavascriptArray.h": [
          "File: lib/Runtime/Library/JavascriptArray.h -> lib/Runtime/Library/JavascriptArray.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "569:         template<typename T>",
          "570:         static void UnshiftHelper(JavascriptArray* pArr, uint32 unshiftElements, Js::Var * elements);",
          "572:         template<typename T>",
          "573:         static void GrowArrayHeadHelperForUnshift(JavascriptArray* pArr, uint32 unshiftElements, ScriptContext * scriptContext);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "571:         static Var UnshiftObjectHelper(Js::Arguments& args, ScriptContext * scriptContext);",
          "",
          "---------------"
        ],
        "test/Array/array_splice2.baseline||test/Array/array_splice2.baseline": [
          "File: test/Array/array_splice2.baseline -> test/Array/array_splice2.baseline",
          "--- Hunk 1 ---",
          "[Context before]",
          "74:   4294967297: 100",
          "75:   4294967298: 101",
          "76:   4294967299: 102",
          "78:   4294967301: 104",
          "79: --- splice overflow 3",
          "80: RangeError : Array length must be assigned a finite positive integer",
          "81: length: 4294967295",
          "",
          "[Removed Lines]",
          "77:   4294967300: 103",
          "",
          "[Added Lines]",
          "78:   4294967300: 103",
          "",
          "---------------"
        ],
        "test/Bugs/misc_bugs.js||test/Bugs/misc_bugs.js": [
          "File: test/Bugs/misc_bugs.js -> test/Bugs/misc_bugs.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "83:       {",
          "84:       }",
          "85:     }",
          "86:   }",
          "87: ];",
          "89: testRunner.runTests(tests, { verbose: WScript.Arguments[0] != \"summary\" });",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "86:   },",
          "87:   {",
          "88:     name: \"splice an array which has getter/setter at 4294967295 should not fail due to re-entrancy error\",",
          "89:     body: function () {",
          "90:         var base = 4294967290;",
          "91:         var arr = [];",
          "92:         for (var i = 0; i < 10; i++) {",
          "93:             arr[base + i] = 100 + i;",
          "94:         }",
          "95:         Object.defineProperty(arr, 4294967295, {",
          "96:           get: function () { }, set : function(b) {  }",
          "97:             }",
          "98:         );",
          "100:         assert.throws(()=> {arr.splice(4294967290, 0, 200, 201, 202, 203, 204, 205, 206);});",
          "101:     }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "2454f0015814d66463c6d1fb2f89d8deef8af06a",
      "candidate_info": {
        "commit_hash": "2454f0015814d66463c6d1fb2f89d8deef8af06a",
        "repo": "Microsoft/ChakraCore",
        "commit_url": "https://github.com/Microsoft/ChakraCore/commit/2454f0015814d66463c6d1fb2f89d8deef8af06a",
        "files": [
          "lib/Common/ConfigFlagsList.h",
          "lib/Common/Memory/LargeHeapBlock.cpp",
          "lib/Runtime/Base/FunctionBody.h",
          "lib/Runtime/Base/ScriptContext.cpp",
          "lib/Runtime/Base/ScriptContext.h",
          "lib/Runtime/Library/ArrayBuffer.cpp",
          "lib/Runtime/Library/ArrayBuffer.h",
          "lib/Runtime/Library/JavascriptArray.cpp",
          "lib/Runtime/Library/JavascriptLibrary.h",
          "lib/Runtime/Library/JavascriptLibraryBase.h",
          "lib/Runtime/Types/SpreadArgument.h"
        ],
        "message": "fix line ending after merge",
        "before_after_code_files": [
          "lib/Common/ConfigFlagsList.h||lib/Common/ConfigFlagsList.h",
          "lib/Common/Memory/LargeHeapBlock.cpp||lib/Common/Memory/LargeHeapBlock.cpp",
          "lib/Runtime/Base/FunctionBody.h||lib/Runtime/Base/FunctionBody.h",
          "lib/Runtime/Base/ScriptContext.cpp||lib/Runtime/Base/ScriptContext.cpp",
          "lib/Runtime/Base/ScriptContext.h||lib/Runtime/Base/ScriptContext.h",
          "lib/Runtime/Library/ArrayBuffer.cpp||lib/Runtime/Library/ArrayBuffer.cpp",
          "lib/Runtime/Library/ArrayBuffer.h||lib/Runtime/Library/ArrayBuffer.h",
          "lib/Runtime/Library/JavascriptArray.cpp||lib/Runtime/Library/JavascriptArray.cpp",
          "lib/Runtime/Library/JavascriptLibrary.h||lib/Runtime/Library/JavascriptLibrary.h",
          "lib/Runtime/Library/JavascriptLibraryBase.h||lib/Runtime/Library/JavascriptLibraryBase.h",
          "lib/Runtime/Types/SpreadArgument.h||lib/Runtime/Types/SpreadArgument.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "lib/Runtime/Library/JavascriptArray.cpp||lib/Runtime/Library/JavascriptArray.cpp"
          ],
          "candidate": [
            "lib/Runtime/Library/JavascriptArray.cpp||lib/Runtime/Library/JavascriptArray.cpp"
          ]
        }
      },
      "candidate_diff": {
        "lib/Common/ConfigFlagsList.h||lib/Common/ConfigFlagsList.h": [
          "File: lib/Common/ConfigFlagsList.h -> lib/Common/ConfigFlagsList.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "5: #ifdef PHASE",
          "6: PHASE(All)",
          "7:     PHASE(BGJit)",
          "8:     PHASE(LibInit)",
          "9:         PHASE(JsLibInit)",
          "10:     PHASE(Parse)",
          "11:         PHASE(RegexCompile)",
          "12:         PHASE(DeferParse)",
          "13:         PHASE(Redeferral)",
          "14:         PHASE(DeferEventHandlers)",
          "15:         PHASE(FunctionSourceInfoParse)",
          "16:         PHASE(StringTemplateParse)",
          "17:         PHASE(SkipNestedDeferred)",
          "18:         PHASE(CacheScopeInfoNames)",
          "19:         PHASE(ScanAhead)",
          "20:         PHASE(ParallelParse)",
          "21:         PHASE(EarlyReferenceErrors)",
          "22:     PHASE(ByteCode)",
          "23:         PHASE(CachedScope)",
          "24:         PHASE(StackFunc)",
          "25:         PHASE(StackClosure)",
          "26:         PHASE(DisableStackFuncOnDeferredEscape)",
          "27:         PHASE(DelayCapture)",
          "28:         PHASE(DebuggerScope)",
          "29:         PHASE(ByteCodeSerialization)",
          "30:             PHASE(VariableIntEncoding)",
          "31:         PHASE(NativeCodeSerialization)",
          "32:         PHASE(OptimizeBlockScope)",
          "33:     PHASE(Delay)",
          "34:         PHASE(Speculation)",
          "35:         PHASE(GatherCodeGenData)",
          "36:     PHASE(WasmBytecode)",
          "37:         PHASE(WasmParser)",
          "38:         PHASE(WasmReader)",
          "39:         PHASE(WasmSection)",
          "40:         PHASE(WasmLEB128)",
          "41:         PHASE(WasmFunctionBody)",
          "42:         PHASE(WasmDeferred)",
          "43:         PHASE(WasmValidatePrejit)",
          "44:     PHASE(Asmjs)",
          "45:         PHASE(AsmjsTmpRegisterAllocation)",
          "46:         PHASE(AsmjsEncoder)",
          "47:         PHASE(AsmjsInterpreter)",
          "48:         PHASE(AsmJsJITTemplate)",
          "49:         PHASE(AsmjsFunctionEntry)",
          "50:         PHASE(AsmjsInterpreterStack)",
          "51:         PHASE(AsmjsEntryPointInfo)",
          "52:         PHASE(AsmjsCallDebugBreak)",
          "53:         PHASE(BackEnd)",
          "54:         PHASE(IRBuilder)",
          "55:             PHASE(SwitchOpt)",
          "56:             PHASE(BailOnNoProfile)",
          "57:             PHASE(BackendConcatExprOpt)",
          "58:             PHASE(ClosureRangeCheck)",
          "59:             PHASE(ClosureRegCheck)",
          "60:         PHASE(Inline)",
          "61:             PHASE(InlineRecursive)",
          "62:             PHASE(InlineAtEveryCaller)      //Inlines a function, say, foo at every caller of foo. Doesn't guarantee all the calls within foo are inlined too.",
          "63:             PHASE(InlineTree)               //Inlines every function within a top function, say, foo (which needs to be top function) Note: -force:inline achieves the effect of both -force:InlineTree & -force:InlineAtEveryCaller",
          "64:             PHASE(TryAggressiveInlining)",
          "65:             PHASE(InlineConstructors)",
          "66:             PHASE(InlineBuiltIn)",
          "67:             PHASE(InlineInJitLoopBody)",
          "68:             PHASE(InlineAccessors)",
          "69:             PHASE(InlineGetters)",
          "70:             PHASE(InlineSetters)",
          "71:             PHASE(InlineApply)",
          "72:             PHASE(InlineApplyTarget)",
          "73:             PHASE(InlineApplyWithoutArrayArg)",
          "74:             PHASE(BailOutOnNotStackArgs)",
          "75:             PHASE(InlineCall)",
          "76:             PHASE(InlineCallTarget)",
          "77:             PHASE(PartialPolymorphicInline)",
          "78:             PHASE(PolymorphicInline)",
          "79:             PHASE(PolymorphicInlineFixedMethods)",
          "80:             PHASE(InlineOutsideLoops)",
          "81:             PHASE(InlineFunctionsWithLoops)",
          "82:             PHASE(EliminateArgoutForInlinee)",
          "83:             PHASE(InlineBuiltInCaller)",
          "84:             PHASE(InlineArgsOpt)",
          "85:                 PHASE(RemoveInlineFrame)",
          "86:             PHASE(InlinerConstFold)",
          "87:     PHASE(ExecBOIFastPath)",
          "88:         PHASE(FGBuild)",
          "89:             PHASE(RemoveBreakBlock)",
          "90:             PHASE(TailDup)",
          "91:         PHASE(FGPeeps)",
          "92:         PHASE(GlobOpt)",
          "93:             PHASE(OptimizeTryCatch)",
          "94:             PHASE(Backward)",
          "95:                 PHASE(TrackIntUsage)",
          "96:                 PHASE(TrackNegativeZero)",
          "97:                 PHASE(TypedArrayVirtual)",
          "98:                 PHASE(TrackIntOverflow)",
          "99:                 PHASE(TrackCompoundedIntOverflow)",
          "100:             PHASE(Forward)",
          "101:                 PHASE(ValueTable)",
          "102:                 PHASE(PathDependentValues)",
          "103:                     PHASE(TrackRelativeIntBounds)",
          "104:                         PHASE(BoundCheckElimination)",
          "105:                             PHASE(BoundCheckHoist)",
          "106:                                 PHASE(LoopCountBasedBoundCheckHoist)",
          "107:                 PHASE(CopyProp)",
          "108:                     PHASE(ObjPtrCopyProp)",
          "109:                 PHASE(ConstProp)",
          "110:                 PHASE(ConstFold)",
          "111:                 PHASE(CSE)",
          "112:                 PHASE(HoistConstInt)",
          "113:                 PHASE(TypeSpec)",
          "114:                 PHASE(AggressiveIntTypeSpec)",
          "115:                 PHASE(AggressiveMulIntTypeSpec)",
          "116:                 PHASE(LossyIntTypeSpec)",
          "117:                 PHASE(FloatTypeSpec)",
          "118:                 PHASE(StringTypeSpec)",
          "119:                 PHASE(InductionVars)",
          "120:                 PHASE(Invariants)",
          "121:                 PHASE(FieldCopyProp)",
          "122:                 PHASE(FieldHoist)",
          "123:                 PHASE(FieldPRE)",
          "124:                 PHASE(HostOpt)",
          "125:                 PHASE(ObjTypeSpec)",
          "126:                     PHASE(ObjTypeSpecNewObj)",
          "127:                     PHASE(ObjTypeSpecIsolatedFldOps)",
          "128:                     PHASE(ObjTypeSpecIsolatedFldOpsWithBailOut)",
          "129:                     PHASE(ObjTypeSpecStore)",
          "130:                     PHASE(EquivObjTypeSpec)",
          "131:                     PHASE(EquivObjTypeSpecByDefault)",
          "132:                     PHASE(TraceObjTypeSpecTypeGuards)",
          "133:                     PHASE(TraceObjTypeSpecWriteGuards)",
          "134:                     PHASE(LiveOutFields)",
          "135:                     PHASE(DisabledObjTypeSpec)",
          "136:                     #if DBG",
          "137:                         PHASE(SimulatePolyCacheWithOneTypeForFunction)",
          "138:                     #endif",
          "139:                 PHASE(CheckThis)",
          "140:                 PHASE(StackArgOpt)",
          "141:                 PHASE(StackArgFormalsOpt)",
          "142:                 PHASE(IndirCopyProp)",
          "143:                 PHASE(ArrayCheckHoist)",
          "144:                     PHASE(ArrayMissingValueCheckHoist)",
          "145:                     PHASE(ArraySegmentHoist)",
          "146:                         PHASE(JsArraySegmentHoist)",
          "147:                     PHASE(ArrayLengthHoist)",
          "148:                     PHASE(EliminateArrayAccessHelperCall)",
          "149:                 PHASE(NativeArray)",
          "150:                     PHASE(NativeNewScArray)",
          "151:                     PHASE(NativeArrayConversion)",
          "152:                     PHASE(CopyOnAccessArray)",
          "153:                     PHASE(NativeArrayLeafSegment)",
          "154:                 PHASE(TypedArrayTypeSpec)",
          "155:                 PHASE(LdLenIntSpec)",
          "156:                 PHASE(FixDataProps)",
          "157:                 PHASE(FixMethodProps)",
          "158:                 PHASE(FixAccessorProps)",
          "159:                 PHASE(FixDataVarProps)",
          "160:                 PHASE(UseFixedDataProps)",
          "161:                 PHASE(UseFixedDataPropsInInliner)",
          "162:                 PHASE(LazyBailout)",
          "163:                     PHASE(LazyFixedDataBailout)",
          "164:                     PHASE(LazyFixedTypeBailout)",
          "165:                 PHASE(FixedMethods)",
          "166:                     PHASE(FEFixedMethods)",
          "167:                     PHASE(FixedFieldGuardCheck)",
          "168:                     PHASE(FixedNewObj)",
          "169:                         PHASE(JitAllocNewObj)",
          "170:                     PHASE(FixedCtorInlining)",
          "171:                     PHASE(FixedCtorCalls)",
          "172:                     PHASE(FixedScriptMethodInlining)",
          "173:                     PHASE(FixedScriptMethodCalls)",
          "174:                     PHASE(FixedBuiltInMethodInlining)",
          "175:                     PHASE(FixedBuiltInMethodCalls)",
          "176:                     PHASE(SplitNewScObject)",
          "177:                 PHASE(OptTagChecks)",
          "178:                 PHASE(MemOp)",
          "179:                     PHASE(MemSet)",
          "180:                     PHASE(MemCopy)",
          "181:                 PHASE(IncrementalBailout)",
          "182:             PHASE(DeadStore)",
          "183:                 PHASE(ReverseCopyProp)",
          "184:                 PHASE(MarkTemp)",
          "185:                     PHASE(MarkTempNumber)",
          "186:                     PHASE(MarkTempObject)",
          "187:                     PHASE(MarkTempNumberOnTempObject)",
          "188:         PHASE(Lowerer)",
          "189:             PHASE(FastPath)",
          "190:                 PHASE(LoopFastPath)",
          "191:                 PHASE(MathFastPath)",
          "192:                 PHASE(Atom)",
          "193:                     PHASE(MulStrengthReduction)",
          "194:                     PHASE(AgenPeeps)",
          "195:                 PHASE(BranchFastPath)",
          "196:                 PHASE(CallFastPath)",
          "197:                 PHASE(BitopsFastPath)",
          "198:                 PHASE(OtherFastPath)",
          "199:                 PHASE(ObjectFastPath)",
          "200:                 PHASE(ProfileBasedFldFastPath)",
          "201:                 PHASE(AddFldFastPath)",
          "202:                 PHASE(RootObjectFldFastPath)",
          "203:                 PHASE(ArrayLiteralFastPath)",
          "204:                 PHASE(ArrayCtorFastPath)",
          "205:                 PHASE(NewScopeSlotFastPath)",
          "206:                 PHASE(FrameDisplayFastPath)",
          "207:                 PHASE(HoistMarkTempInit)",
          "208:                 PHASE(HoistConstAddr)",
          "209:             PHASE(JitWriteBarrier)",
          "210:             PHASE(PreLowererPeeps)",
          "211:             PHASE(CFGInJit)",
          "212:             PHASE(TypedArray)",
          "213:             PHASE(TracePinnedTypes)",
          "214:         PHASE(InterruptProbe)",
          "215:         PHASE(EncodeConstants)",
          "216:         PHASE(RegAlloc)",
          "217:             PHASE(Liveness)",
          "218:                 PHASE(RegParams)",
          "219:             PHASE(LinearScan)",
          "220:                 PHASE(OpHelperRegOpt)",
          "221:                 PHASE(StackPack)",
          "222:                 PHASE(SecondChance)",
          "223:                 PHASE(RegionUseCount)",
          "224:                 PHASE(RegHoistLoads)",
          "225:                 PHASE(ClearRegLoopExit)",
          "226:         PHASE(Peeps)",
          "227:         PHASE(Layout)",
          "228:         PHASE(EHBailoutPatchUp)",
          "229:         PHASE(FinalLower)",
          "230:         PHASE(PrologEpilog)",
          "231:         PHASE(InsertNOPs)",
          "232:         PHASE(Encoder)",
          "233:             PHASE(Emitter)",
          "234: #if defined(_M_IX86) || defined(_M_X64)",
          "235:             PHASE(BrShorten)",
          "236:                 PHASE(LoopAlign)",
          "237: #endif",
          "239: #ifdef RECYCLER_WRITE_BARRIER",
          "240: #if DBG_DUMP",
          "241:     PHASE(SWB)",
          "242: #endif",
          "243: #endif",
          "244:     PHASE(Run)",
          "245:         PHASE(Interpreter)",
          "246:         PHASE(EvalCompile)",
          "247:             PHASE(FastIndirectEval)",
          "248:         PHASE(IdleDecommit)",
          "249:         PHASE(IdleCollect)",
          "250:         PHASE(MemoryAllocation)",
          "251: #ifdef RECYCLER_PAGE_HEAP",
          "252:             PHASE(PageHeap)",
          "253: #endif",
          "254:             PHASE(LargeMemoryAllocation)",
          "255:             PHASE(PageAllocatorAlloc)",
          "256:         PHASE(Recycler)",
          "257:             PHASE(ThreadCollect)",
          "258:             PHASE(ExplicitFree)",
          "259:             PHASE(ExpirableCollect)",
          "260:             PHASE(GarbageCollect)",
          "261:             PHASE(ConcurrentCollect)",
          "262:                 PHASE(BackgroundResetMarks)",
          "263:                 PHASE(BackgroundFindRoots)",
          "264:                 PHASE(BackgroundRescan)",
          "265:                 PHASE(BackgroundRepeatMark)",
          "266:                 PHASE(BackgroundFinishMark)",
          "267:             PHASE(ConcurrentPartialCollect)",
          "268:             PHASE(ParallelMark)",
          "269:             PHASE(PartialCollect)",
          "270:                 PHASE(ResetMarks)",
          "271:                 PHASE(ResetWriteWatch)",
          "272:                 PHASE(FindRoot)",
          "273:                     PHASE(FindRootArena)",
          "274:                     PHASE(FindImplicitRoot)",
          "275:                     PHASE(FindRootExt)",
          "276:                 PHASE(ScanStack)",
          "277:                 PHASE(ConcurrentMark)",
          "278:                 PHASE(ConcurrentWait)",
          "279:                 PHASE(Rescan)",
          "280:                 PHASE(Mark)",
          "281:                 PHASE(Sweep)",
          "282:                     PHASE(SweepWeak)",
          "283:                     PHASE(SweepSmall)",
          "284:                     PHASE(SweepLarge)",
          "285:                     PHASE(SweepPartialReuse)",
          "286:                 PHASE(ConcurrentSweep)",
          "287:                 PHASE(Finalize)",
          "288:                 PHASE(Dispose)",
          "289:                 PHASE(FinishPartial)",
          "290:         PHASE(Host)",
          "291:         PHASE(BailOut)",
          "292:         PHASE(RegexQc)",
          "293:         PHASE(RegexOptBT)",
          "294:         PHASE(InlineCache)",
          "295:         PHASE(PolymorphicInlineCache)",
          "296:         PHASE(MissingPropertyCache)",
          "297:         PHASE(CloneCacheInCollision)",
          "298:         PHASE(ConstructorCache)",
          "299:         PHASE(InlineCandidate)",
          "300:         PHASE(InlineHostCandidate)",
          "301:         PHASE(ScriptFunctionWithInlineCache)",
          "302:         PHASE(IsConcatSpreadableCache)",
          "303:         PHASE(Arena)",
          "304:         PHASE(ApplyUsage)",
          "305:         PHASE(ObjectHeaderInlining)",
          "306:             PHASE(ObjectHeaderInliningForConstructors)",
          "307:             PHASE(ObjectHeaderInliningForObjectLiterals)",
          "308:             PHASE(ObjectHeaderInliningForEmptyObjects)",
          "309:         PHASE(OptUnknownElementName)",
          "310: #if DBG_DUMP",
          "311:         PHASE(TypePropertyCache)",
          "312:         PHASE(InlineSlots)",
          "313: #endif",
          "314:         PHASE(DynamicProfile)",
          "315: #ifdef DYNAMIC_PROFILE_STORAGE",
          "316:         PHASE(DynamicProfileStorage)",
          "317: #endif",
          "318:         PHASE(JITLoopBody)",
          "319:         PHASE(JITLoopBodyInTryCatch)",
          "320:         PHASE(ReJIT)",
          "321:         PHASE(ExecutionMode)",
          "322:         PHASE(SimpleJitDynamicProfile)",
          "323:         PHASE(SimpleJit)",
          "324:         PHASE(FullJit)",
          "325:         PHASE(FailNativeCodeInstall)",
          "326:         PHASE(PixelArray)",
          "327:         PHASE(Etw)",
          "328:         PHASE(Profiler)",
          "329:         PHASE(CustomHeap)",
          "330:         PHASE(XDataAllocator)",
          "331:         PHASE(PageAllocator)",
          "332:         PHASE(StringConcat)",
          "333: #if DBG_DUMP",
          "334:         PHASE(PRNG)",
          "335: #endif",
          "336:         PHASE(PreReservedHeapAlloc)",
          "337:         PHASE(CFG)",
          "338:         PHASE(ExceptionStackTrace)",
          "339:         PHASE(ExtendedExceptionInfoStackTrace)",
          "340:         PHASE(ProjectionMetadata)",
          "341:         PHASE(TypeHandlerTransition)",
          "342:         PHASE(Debugger)",
          "343:             PHASE(ENC)",
          "344:         PHASE(ConsoleScope)",
          "345:         PHASE(ScriptProfiler)",
          "346:         PHASE(JSON)",
          "347:         PHASE(RegexResultNotUsed)",
          "348:         PHASE(Error)",
          "349:         PHASE(PropertyRecord)",
          "350:         PHASE(TypePathDynamicSize)",
          "351:         PHASE(ConditionalCompilation)",
          "352:         PHASE(InterpreterProfile)",
          "353:         PHASE(InterpreterAutoProfile)",
          "354:         PHASE(ByteCodeConcatExprOpt)",
          "355:         PHASE(TraceInlineCacheInvalidation)",
          "356:         PHASE(TracePropertyGuards)",
          "357: #ifdef ENABLE_JS_ETW",
          "358:         PHASE(StackFramesEvent)",
          "359: #endif",
          "360:         PHASE(PerfHint)",
          "361:         PHASE(TypeShareForChangePrototype)",
          "362:         PHASE(DeferSourceLoad)",
          "363:         PHASE(ObjectMutationBreakpoint)",
          "364:         PHASE(NativeCodeData)",
          "365: #undef PHASE",
          "366: #endif",
          "368: #ifndef DEFAULT_CONFIG_BgJitDelay",
          "369: #if _M_ARM",
          "370: #define DEFAULT_CONFIG_BgJitDelay           (70)",
          "371: #else",
          "372: #define DEFAULT_CONFIG_BgJitDelay           (30)",
          "373: #endif",
          "374: #define DEFAULT_CONFIG_ASMJS                (true)",
          "375: #define DEFAULT_CONFIG_AsmJsEdge            (false)",
          "376: #define DEFAULT_CONFIG_AsmJsStopOnError     (false)",
          "377: #ifdef COMPILE_DISABLE_Simdjs",
          "379:     #define DEFAULT_CONFIG_SIMDJS               (false)",
          "380: #else",
          "381:     #define DEFAULT_CONFIG_SIMDJS               (false)",
          "382: #endif",
          "383: #define DEFAULT_CONFIG_WASM               (false)",
          "384: #define DEFAULT_CONFIG_WasmI64            (false)",
          "385: #if ENABLE_FAST_ARRAYBUFFER",
          "386:     #define DEFAULT_CONFIG_WasmFastArray    (true)",
          "387: #else",
          "388:     #define DEFAULT_CONFIG_WasmFastArray    (false)",
          "389: #endif",
          "390: #define DEFAULT_CONFIG_BgJitDelayFgBuffer   (0)",
          "391: #define DEFAULT_CONFIG_BgJitPendingFuncCap  (31)",
          "392: #define DEFAULT_CONFIG_CurrentSourceInfo     (true)",
          "393: #define DEFAULT_CONFIG_CreateFunctionProxy  (true)",
          "394: #define DEFAULT_CONFIG_HybridFgJit          (false)",
          "395: #define DEFAULT_CONFIG_HybridFgJitBgQueueLengthThreshold (32)",
          "396: #define DEFAULT_CONFIG_Prejit               (false)",
          "397: #define DEFAULT_CONFIG_DeferNested          (true)",
          "398: #define DEFAULT_CONFIG_DeferTopLevelTillFirstCall (true)",
          "399: #define DEFAULT_CONFIG_DirectCallTelemetryStats (false)",
          "400: #define DEFAULT_CONFIG_errorStackTrace      (true)",
          "401: #define DEFAULT_CONFIG_FastLineColumnCalculation (true)",
          "402: #define DEFAULT_CONFIG_PrintLineColumnInfo (false)",
          "403: #define DEFAULT_CONFIG_ForceDecommitOnCollect (false)",
          "404: #define DEFAULT_CONFIG_ForceDeferParse      (false)",
          "405: #define DEFAULT_CONFIG_NoDeferParse         (false)",
          "406: #define DEFAULT_CONFIG_ForceDynamicProfile  (false)",
          "407: #define DEFAULT_CONFIG_ForceExpireOnNonCacheCollect (false)",
          "408: #define DEFAULT_CONFIG_ForceFastPath        (false)",
          "409: #define DEFAULT_CONFIG_ForceJITLoopBody     (false)",
          "410: #define DEFAULT_CONFIG_ForceCleanPropertyOnCollect (false)",
          "411: #define DEFAULT_CONFIG_ForceCleanCacheOnCollect (false)",
          "412: #define DEFAULT_CONFIG_ForceGCAfterJSONParse (false)",
          "413: #define DEFAULT_CONFIG_ForceSerialized      (false)",
          "414: #define DEFAULT_CONFIG_ForceES5Array        (false)",
          "415: #define DEFAULT_CONFIG_ForceAsmJsLinkFail   (false)",
          "416: #define DEFAULT_CONFIG_DumpCommentsFromReferencedFiles (false)",
          "417: #define DEFAULT_CONFIG_ExtendedErrorStackForTestHost (false)",
          "418: #define DEFAULT_CONFIG_ForceSplitScope      (false)",
          "419: #define DEFAULT_CONFIG_DelayFullJITSmallFunc (0)",
          "423: #define DEFAULT_CONFIG_InlineThreshold      (35)            //Default start",
          "424: #define DEFAULT_CONFIG_AggressiveInlineThreshold  (80)      //Limit for aggressive inlining.",
          "425: #define DEFAULT_CONFIG_InlineThresholdAdjustCountInLargeFunction  (20)",
          "426: #define DEFAULT_CONFIG_InlineThresholdAdjustCountInMediumSizedFunction  (6)",
          "427: #define DEFAULT_CONFIG_InlineThresholdAdjustCountInSmallFunction  (10)",
          "428: #define DEFAULT_CONFIG_ConstructorInlineThreshold (21)      //Monomorphic constructor threshold",
          "429: #define DEFAULT_CONFIG_ConstructorCallsRequiredToFinalizeCachedType (2)",
          "430: #define DEFAULT_CONFIG_OutsideLoopInlineThreshold (16)      //Threshold to inline outside loops",
          "431: #define DEFAULT_CONFIG_LeafInlineThreshold  (60)            //Inlinee threshold for function which is leaf (irrespective of it has loops or not)",
          "432: #define DEFAULT_CONFIG_LoopInlineThreshold  (25)            //Inlinee threshold for function with loops",
          "433: #define DEFAULT_CONFIG_PolymorphicInlineThreshold  (35)     //Polymorphic inline threshold",
          "434: #define DEFAULT_CONFIG_InlineCountMax       (1200)          //Max sum of bytecodes of inlinees inlined into a function (excluding built-ins)",
          "435: #define DEFAULT_CONFIG_InlineCountMaxInLoopBodies (500)     // Max sum of bytecodes of inlinees that can be inlined into a jitted loop body (excluding built-ins)",
          "436: #define DEFAULT_CONFIG_AggressiveInlineCountMax       (8000)          //Max sum of bytecodes of inlinees inlined into a function (excluding built-ins) when inlined aggressively",
          "437: #define DEFAULT_CONFIG_MaxFuncInlineDepth   (2)             //Maximum number of times a function can be inlined within a top function",
          "438: #define DEFAULT_CONFIG_MaxNumberOfInlineesWithLoop   (40) //Inlinee with a loop is controlled by LoopInlineThreshold, though we don't want to inline lot of inlinees with loop, this ensures a limit.",
          "439: #define DEFAULT_CONFIG_ConstantArgumentInlineThreshold   (157)      // Bytecode threshold for functions with constant arguments which are used for branching",
          "440: #define DEFAULT_CONFIG_RecursiveInlineThreshold     (2000)      // Bytecode threshold recursive call at a call site",
          "441: #define DEFAULT_CONFIG_RecursiveInlineDepthMax      (8)      // Maximum inline depth for recursive calls",
          "442: #define DEFAULT_CONFIG_RecursiveInlineDepthMin      (2)      // Minimum inline depth for recursive call",
          "443: #define DEFAULT_CONFIG_InlineInLoopBodyScaleDownFactor    (4)",
          "445: #define DEFAULT_CONFIG_CloneInlinedPolymorphicCaches (true)",
          "446: #define DEFAULT_CONFIG_HighPrecisionDate    (false)",
          "447: #define DEFAULT_CONFIG_ForceOldDateAPI      (false)",
          "448: #define DEFAULT_CONFIG_Loop                 (1)",
          "449: #define DEFAULT_CONFIG_ForceDiagnosticsMode (false)",
          "450: #define DEFAULT_CONFIG_EnableJitInDiagMode  (true)",
          "451: #define DEFAULT_CONFIG_UseFullName          (true)",
          "452: #define DEFAULT_CONFIG_EnableContinueAfterExceptionWrappersForHelpers  (true)",
          "453: #define DEFAULT_CONFIG_EnableContinueAfterExceptionWrappersForBuiltIns  (true)",
          "454: #define DEFAULT_CONFIG_EnableFunctionSourceReportForHeapEnum (true)",
          "455: #define DEFAULT_CONFIG_LoopInterpretCount   (150)",
          "456: #define DEFAULT_CONFIG_LoopProfileIterations (25)",
          "457: #define DEFAULT_CONFIG_JitLoopBodyHotLoopThreshold (20000)",
          "458: #define DEFAULT_CONFIG_LoopBodySizeThresholdToDisableOpts (255)",
          "460: #define DEFAULT_CONFIG_MaxJitThreadCount        (2)",
          "461: #define DEFAULT_CONFIG_ForceMaxJitThreadCount   (false)",
          "463: #ifdef RECYCLER_PAGE_HEAP",
          "464: #define DEFAULT_CONFIG_PageHeap             ((Js::Number) PageHeapMode::PageHeapModeOff)",
          "465: #define DEFAULT_CONFIG_PageHeapAllocStack   (false)",
          "466: #define DEFAULT_CONFIG_PageHeapFreeStack    (false)",
          "467: #define DEFAULT_CONFIG_PageHeapBlockType    ((Js::Number) PageHeapBlockTypeFilter::PageHeapBlockTypeFilterAll)",
          "468: #endif",
          "470: #define DEFAULT_CONFIG_LowMemoryCap         (0xB900000) // 185 MB - based on memory cap for process on low-capacity device",
          "471: #define DEFAULT_CONFIG_NewPagesCapDuringBGSweeping    (15000)",
          "473: #define DEFAULT_CONFIG_MaxCodeFill          (500)",
          "474: #define DEFAULT_CONFIG_MaxLoopsPerFunction  (10)",
          "475: #define DEFAULT_CONFIG_NopFrequency         (8)",
          "476: #define DEFAULT_CONFIG_SpeculationCap       (1)         // Needs to be 1 and not 0 since the compiler complains about a condition being always false",
          "477: #define DEFAULT_CONFIG_ProfileBasedSpeculationCap (1600)",
          "478: #define DEFAULT_CONFIG_Verbose              (false)",
          "479: #define DEFAULT_CONFIG_ForceStrictMode      (false)",
          "480: #define DEFAULT_CONFIG_EnableEvalMapCleanup (true)",
          "481: #define DEFAULT_CONFIG_ExpirableCollectionGCCount (5)  // Number of GCs during which entry point profiling occurs",
          "482: #define DEFAULT_CONFIG_ExpirableCollectionTriggerThreshold (50)  // Threshold at which Entry Point Collection is triggered",
          "483: #define DEFAULT_CONFIG_RegexTracing         (false)",
          "484: #define DEFAULT_CONFIG_RegexProfile         (false)",
          "485: #define DEFAULT_CONFIG_RegexDebug           (false)",
          "486: #define DEFAULT_CONFIG_RegexOptimize        (true)",
          "487: #define DEFAULT_CONFIG_DynamicRegexMruListSize (16)",
          "488: #define DEFAULT_CONFIG_GoptCleanupThreshold  (25)",
          "489: #define DEFAULT_CONFIG_AsmGoptCleanupThreshold  (500)",
          "490: #define DEFAULT_CONFIG_OptimizeForManyInstances (false)",
          "492: #define DEFAULT_CONFIG_DeferParseThreshold             (4 * 1024) // Unit is number of characters",
          "493: #define DEFAULT_CONFIG_ProfileBasedDeferParseThreshold (100)      // Unit is number of characters",
          "495: #define DEFAULT_CONFIG_ProfileBasedSpeculativeJit (true)",
          "496: #define DEFAULT_CONFIG_WininetProfileCache        (true)",
          "497: #define DEFAULT_CONFIG_MinProfileCacheSize        (5)   // Minimum number of functions before profile is saved.",
          "498: #define DEFAULT_CONFIG_ProfileDifferencePercent   (15)  // If 15% of the functions have different profile we will trigger a save.",
          "500: #define DEFAULT_CONFIG_Intl                    (true)",
          "501: #define DEFAULT_CONFIG_IntlBuiltIns            (true)",
          "504: #define DEFAULT_CONFIG_ES6                     (true)  // master flag to gate all P0-spec-test compliant ES6 features",
          "507: #define DEFAULT_CONFIG_CollectGarbage          (false)",
          "510: #define DEFAULT_CONFIG_ES6Species              (true)",
          "511: #define DEFAULT_CONFIG_ES6Classes              (true)",
          "512: #define DEFAULT_CONFIG_ES6DateParseFix         (true)",
          "513: #define DEFAULT_CONFIG_ES6DefaultArgs          (true)",
          "514: #define DEFAULT_CONFIG_ES6Destructuring        (true)",
          "515: #define DEFAULT_CONFIG_ES6ForLoopSemantics     (true)",
          "516: #define DEFAULT_CONFIG_ES6FunctionName         (true)",
          "517: #ifdef COMPILE_DISABLE_ES6FunctionNameFull",
          "519:     #define DEFAULT_CONFIG_ES6FunctionNameFull     (false)",
          "520: #else",
          "521:     #define DEFAULT_CONFIG_ES6FunctionNameFull     (false)",
          "522: #endif",
          "523: #define DEFAULT_CONFIG_ES6Generators           (true)",
          "524: #define DEFAULT_CONFIG_ES6IsConcatSpreadable   (true)",
          "525: #define DEFAULT_CONFIG_ES6Math                 (true)",
          "526: #ifdef COMPILE_DISABLE_ES6Module",
          "528:     #define DEFAULT_CONFIG_ES6Module               (false)",
          "529: #else",
          "530:     #define DEFAULT_CONFIG_ES6Module               (false)",
          "531: #endif",
          "532: #define DEFAULT_CONFIG_ES6Object               (true)",
          "533: #define DEFAULT_CONFIG_ES6Number               (true)",
          "534: #define DEFAULT_CONFIG_ES6ObjectLiterals       (true)",
          "535: #define DEFAULT_CONFIG_ES6Promise              (true)",
          "536: #define DEFAULT_CONFIG_ES6Proxy                (true)",
          "537: #define DEFAULT_CONFIG_ES6Rest                 (true)",
          "538: #define DEFAULT_CONFIG_ES6Spread               (true)",
          "539: #define DEFAULT_CONFIG_ES6String               (true)",
          "540: #define DEFAULT_CONFIG_ES6StringPrototypeFixes (true)",
          "541: #ifdef COMPILE_DISABLE_ES6PrototypeChain",
          "543:     #define DEFAULT_CONFIG_ES6PrototypeChain       (false)",
          "544: #else",
          "545:     #define DEFAULT_CONFIG_ES6PrototypeChain       (false)",
          "546: #endif",
          "547: #define DEFAULT_CONFIG_ES6ToPrimitive          (true)",
          "548: #define DEFAULT_CONFIG_ES6ToLength             (true)",
          "549: #define DEFAULT_CONFIG_ES6ToStringTag          (true)",
          "550: #define DEFAULT_CONFIG_ES6Unicode              (true)",
          "551: #define DEFAULT_CONFIG_ES6UnicodeVerbose       (true)",
          "552: #define DEFAULT_CONFIG_ES6Unscopables          (true)",
          "553: #define DEFAULT_CONFIG_ES6RegExSticky          (true)",
          "554: #ifdef COMPILE_DISABLE_ES6RegExPrototypeProperties",
          "556:     #define DEFAULT_CONFIG_ES6RegExPrototypeProperties (false)",
          "557: #else",
          "558:     #define DEFAULT_CONFIG_ES6RegExPrototypeProperties (false)",
          "559: #endif",
          "560: #ifdef COMPILE_DISABLE_ES6RegExSymbols",
          "562:     #define DEFAULT_CONFIG_ES6RegExSymbols         (false)",
          "563: #else",
          "564:     #define DEFAULT_CONFIG_ES6RegExSymbols         (false)",
          "565: #endif",
          "566: #define DEFAULT_CONFIG_ES6HasInstance          (true)",
          "567: #ifdef COMPILE_DISABLE_ArrayBufferTransfer",
          "569:     #define DEFAULT_CONFIG_ArrayBufferTransfer     (false)",
          "570: #else",
          "571:     #define DEFAULT_CONFIG_ArrayBufferTransfer     (false)",
          "572: #endif",
          "573: #define DEFAULT_CONFIG_ES7AsyncAwait           (true)",
          "574: #define DEFAULT_CONFIG_ES7ExponentionOperator  (true)",
          "575: #define DEFAULT_CONFIG_ES7TrailingComma        (true)",
          "576: #define DEFAULT_CONFIG_ES7ValuesEntries        (true)",
          "577: #define DEFAULT_CONFIG_ESObjectGetOwnPropertyDescriptors (true)",
          "579: #ifdef COMPILE_DISABLE_ESSharedArrayBuffer",
          "580: #define DEFAULT_CONFIG_ESSharedArrayBuffer     (false)",
          "581: #else",
          "582: #define DEFAULT_CONFIG_ESSharedArrayBuffer     (false)",
          "583: #endif",
          "584: #define DEFAULT_CONFIG_ES6Verbose              (false)",
          "585: #define DEFAULT_CONFIG_ES6All                  (false)",
          "588: #define DEFAULT_CONFIG_AsyncDebugging           (true)",
          "589: #define DEFAULT_CONFIG_TraceAsyncDebugCalls     (false)",
          "590: #define DEFAULT_CONFIG_ForcePostLowerGlobOptInstrString (false)",
          "591: #define DEFAULT_CONFIG_EnumerateSpecialPropertiesInDebugger (true)",
          "592: #endif",
          "594: #define DEFAULT_CONFIG_MaxJITFunctionBytecodeSize (120000)",
          "596: #define DEFAULT_CONFIG_JitQueueThreshold      (6)",
          "598: #define DEFAULT_CONFIG_FullJitRequeueThreshold (25)     // Minimum number of times a function needs to be executed before it is re-added to the jit queue",
          "600: #define DEFAULT_CONFIG_MinTemplatizedJitRunCount      (100)     // Minimum number of times a function needs to be interpreted before it is jitted",
          "601: #define DEFAULT_CONFIG_MinAsmJsInterpreterRunCount      (10)     // Minimum number of times a function needs to be Asm interpreted before it is jitted",
          "602: #define DEFAULT_CONFIG_MinTemplatizedJitLoopRunCount      (500)     // Minimum number of times a function needs to be interpreted before it is jitted",
          "603: #define DEFAULT_CONFIG_MaxTemplatizedJitRunCount      (-1)     // Maximum number of times a function can be TJ before it is jitted",
          "604: #define DEFAULT_CONFIG_MaxAsmJsInterpreterRunCount      (-1)     // Maximum number of times a function can be Asm interpreted before it is jitted",
          "608: #define DEFAULT_CONFIG_AutoProfilingInterpreter0Limit (12)",
          "609: #define DEFAULT_CONFIG_ProfilingInterpreter0Limit (4)",
          "610: #define DEFAULT_CONFIG_AutoProfilingInterpreter1Limit (0)",
          "611: #define DEFAULT_CONFIG_SimpleJitLimit (132)",
          "612: #define DEFAULT_CONFIG_ProfilingInterpreter1Limit (12)",
          "615: #define DEFAULT_CONFIG_AutoProfilingInterpreterLimit_OldSimpleJit (80)",
          "616: #define DEFAULT_CONFIG_SimpleJitLimit_OldSimpleJit (25)",
          "618: #define DEFAULT_CONFIG_MinProfileIterations (16)",
          "619: #define DEFAULT_CONFIG_MinProfileIterations_OldSimpleJit (25)",
          "620: #define DEFAULT_CONFIG_MinSimpleJitIterations (16)",
          "621: #define DEFAULT_CONFIG_NewSimpleJit (false)",
          "623: #define DEFAULT_CONFIG_MaxLinearIntCaseCount     (3)       // Maximum number of cases (in switch statement) for which instructions can be generated linearly.",
          "624: #define DEFAULT_CONFIG_MaxSingleCharStrJumpTableRatio  (2)       // Maximum single char string jump table size as multiples of the actual case arm",
          "625: #define DEFAULT_CONFIG_MaxSingleCharStrJumpTableSize  (128)       // Maximum single char string jump table size",
          "626: #define DEFAULT_CONFIG_MinSwitchJumpTableSize   (9)     // Minimum number of case target entries in the jump table(this may also include values that are missing in the consecutive set of integer case arms)",
          "627: #define DEFAULT_CONFIG_SwitchOptHolesThreshold  (50)     // Maximum percentage of holes (missing case values in a switch statement) with which a jump table can be created",
          "628: #define DEFAULT_CONFIG_MaxLinearStringCaseCount (4)     // Maximum number of String cases (in switch statement) for which instructions can be generated linearly.",
          "630: #define DEFAULT_CONFIG_MinDeferredFuncTokenCount (20)   // Minimum size in tokens of a defer-parsed function",
          "632: #if DBG",
          "633: #define DEFAULT_CONFIG_SkipFuncCountForBailOnNoProfile (0) //Initial Number of functions in a func body to be skipped from forcibly inserting BailOnNoProfile.",
          "634: #endif",
          "635: #define DEFAULT_CONFIG_BailOnNoProfileLimit    200      // The limit of bailout on no profile info before triggering a rejit",
          "636: #define DEFAULT_CONFIG_BailOnNoProfileRejitLimit (50)   // The limit of bailout on no profile info before disable all the no profile bailouts",
          "637: #define DEFAULT_CONFIG_CallsToBailoutsRatioForRejit 10   // Ratio of function calls to bailouts above which a rejit is considered",
          "638: #define DEFAULT_CONFIG_LoopIterationsToBailoutsRatioForRejit 50 // Ratio of loop iteration count to bailouts above which a rejit of the loop body is considered",
          "639: #define DEFAULT_CONFIG_MinBailOutsBeforeRejit 2         // Minimum number of bailouts for a single bailout record after which a rejit is considered",
          "640: #define DEFAULT_CONFIG_MinBailOutsBeforeRejitForLoops 2         // Minimum number of bailouts for a single bailout record after which a rejit is considered",
          "641: #define DEFAULT_CONFIG_RejitMaxBailOutCount 500         // Maximum number of bailouts for a single bailout record after which rejit is forced.",
          "644: #define DEFAULT_CONFIG_Sse                  (-1)",
          "646: #define DEFAULT_CONFIG_DeletedPropertyReuseThreshold (32)",
          "647: #define DEFAULT_CONFIG_BigDictionaryTypeHandlerThreshold (0xffff)",
          "648: #define DEFAULT_CONFIG_ForceStringKeyedSimpleDictionaryTypeHandler (false)",
          "649: #define DEFAULT_CONFIG_TypeSnapshotEnumeration (true)",
          "650: #define DEFAULT_CONFIG_EnumerationCompat    (false)",
          "651: #define DEFAULT_CONFIG_ConcurrentRuntime (false)",
          "652: #define DEFAULT_CONFIG_PrimeRecycler     (false)",
          "653: #if defined(_WIN32)",
          "654: #define DEFAULT_CONFIG_PrivateHeap       (true)",
          "655: #else // defined(_WIN32)",
          "657: #define DEFAULT_CONFIG_PrivateHeap       (false)",
          "658: #endif // defined(_WIN32)",
          "659: #define DEFAULT_CONFIG_DisableRentalThreading (false)",
          "660: #define DEFAULT_CONFIG_DisableDebugObject (false)",
          "661: #define DEFAULT_CONFIG_DumpHeap (false)",
          "662: #define DEFAULT_CONFIG_PerfHintLevel (1)",
          "663: #define DEFAULT_CONFIG_OOPJITMissingOpts (true)",
          "664: #define DEFAULT_CONFIG_OOPCFGRegistration (true)",
          "665: #define DEFAULT_CONFIG_RPCFailFastWait (3000)",
          "667: #define DEFAULT_CONFIG_FailFastIfDisconnectedDelegate    (false)",
          "669: #define DEFAULT_CONFIG_IsolatePrototypes    (true)",
          "670: #define DEFAULT_CONFIG_ChangeTypeOnProto    (true)",
          "671: #define DEFAULT_CONFIG_FixPropsOnPathTypes    (true)",
          "672: #define DEFAULT_CONFIG_BailoutTraceFilter (-1)",
          "673: #define DEFAULT_CONFIG_TempMin    (0)",
          "674: #define DEFAULT_CONFIG_TempMax    (INT_MAX)",
          "676: #define DEFAULT_CONFIG_LibraryStackFrame            (true)",
          "677: #define DEFAULT_CONFIG_LibraryStackFrameDebugger    (false)",
          "679: #define DEFAULT_CONFIG_FuncObjectInlineCacheThreshold   (2) // Maximum number of inline caches a function body may have to allow for inline caches to be allocated on the function object.",
          "680: #define DEFAULT_CONFIG_ShareInlineCaches (true)",
          "681: #define DEFAULT_CONFIG_InlineCacheInvalidationListCompactionThreshold (4)",
          "682: #define DEFAULT_CONFIG_ConstructorCacheInvalidationThreshold (500)",
          "684: #define DEFAULT_CONFIG_InMemoryTrace                (false)",
          "685: #define DEFAULT_CONFIG_InMemoryTraceBufferSize      (1024)",
          "686: #define DEFAULT_CONFIG_RichTraceFormat              (false)",
          "687: #define DEFAULT_CONFIG_TraceWithStack               (false)",
          "689: #define DEFAULT_CONFIG_InjectPartiallyInitializedInterpreterFrameError (0)",
          "690: #define DEFAULT_CONFIG_InjectPartiallyInitializedInterpreterFrameErrorType (0)",
          "692: #define DEFAULT_CONFIG_InvalidateSolutionContextsForGetStructure (true)",
          "694: #define DEFAULT_CONFIG_DeferLoadingAvailableSource  (false)",
          "695: #ifdef ENABLE_PROJECTION",
          "696: #define DEFAULT_CONFIG_NoWinRTFastSig       (false)",
          "697: #define DEFAULT_CONFIG_TargetWinRTVersion   (1)",
          "698: #define DEFAULT_CONFIG_WinRTDelegateInterfaces      (false)",
          "699: #define DEFAULT_CONFIG_WinRTAdaptiveApps            (true)",
          "700: #endif",
          "702: #define DEFAULT_CONFIG_RecyclerForceMarkInterior (false)",
          "704: #define DEFAULT_CONFIG_MemProtectHeap (false)",
          "706: #define DEFAULT_CONFIG_InduceCodeGenFailure (30) // When -InduceCodeGenFailure is passed in, 30% of JIT allocations will fail",
          "708: #define DEFAULT_CONFIG_SkipSplitWhenResultIgnored (false)",
          "710: #define DEFAULT_CONFIG_MinMemOpCount (16U)",
          "712: #if ENABLE_COPYONACCESS_ARRAY",
          "713: #define DEFAULT_CONFIG_MaxCopyOnAccessArrayLength (32U)",
          "714: #define DEFAULT_CONFIG_MinCopyOnAccessArrayLength (5U)",
          "715: #define DEFAULT_CONFIG_CopyOnAccessArraySegmentCacheSize (16U)",
          "716: #endif",
          "718: #if defined(_M_IX86) || defined(_M_X64)",
          "719: #define DEFAULT_CONFIG_LoopAlignNopLimit (6)",
          "720: #endif",
          "722: #if defined(_M_IX86) || defined(_M_X64)",
          "723: #define DEFAULT_CONFIG_ZeroMemoryWithNonTemporalStore (true)",
          "724: #endif",
          "726: #define DEFAULT_CONFIG_StrictWriteBarrierCheck  (false)",
          "727: #define DEFAULT_CONFIG_KeepRecyclerTrackData  (false)",
          "728: #define DEFAULT_CONFIG_EnableBGFreeZero (true)",
          "730: #if !GLOBAL_ENABLE_WRITE_BARRIER",
          "731: #define DEFAULT_CONFIG_ForceSoftwareWriteBarrier  (false)",
          "732: #else",
          "733: #define DEFAULT_CONFIG_ForceSoftwareWriteBarrier  (true)",
          "734: #endif",
          "735: #define DEFAULT_CONFIG_WriteBarrierTest (false)",
          "736: #define DEFAULT_CONFIG_VerifyBarrierBit  (false)",
          "738: #define TraceLevel_Error        (1)",
          "739: #define TraceLevel_Warning      (2)",
          "740: #define TraceLevel_Info         (3)",
          "742: #define TEMP_ENABLE_FLAG_FOR_APPX_BETA_ONLY 1",
          "744: #define INMEMORY_CACHE_MAX_URL                    (5)             // This is the max number of URLs that the in-memory profile cache can hold.",
          "745: #define INMEMORY_CACHE_MAX_PROFILE_MANAGER        (50)            // This is the max number of dynamic scripts that the in-memory profile cache can have",
          "747: #ifdef SUPPORT_INTRUSIVE_TESTTRACES",
          "748: #define INTRUSIVE_TESTTRACE_PolymorphicInlineCache (1)",
          "749: #endif",
          "765: #if defined(FLAG) || defined(FLAG_REGOVR_EXP)",
          "767: #ifndef FLAG",
          "768: #define FLAG(...)",
          "769: #endif",
          "771: #ifndef FLAG_REGOVR_ASMJS",
          "772: #define FLAG_REGOVR_ASMJS FLAG",
          "773: #endif",
          "775: #ifndef FLAG_REGOVR_EXP",
          "776: #define FLAG_REGOVR_EXP FLAG",
          "777: #endif",
          "780: #ifdef ENABLE_DEBUG_CONFIG_OPTIONS",
          "783: #define FLAGNR(Type, Name, String, Default)                 FLAG(Type, Name, String, Default, NoParent, FALSE)",
          "786: #ifndef FLAGNRA",
          "787:     #define FLAGNRA(Type, Name, Acronym, String, Default) \\",
          "788:         FLAGNR(Type, Name, String, Default) \\",
          "789:         FLAGNR(Type, Acronym, String, Default)",
          "790: #endif",
          "793: #define FLAGPNR(Type, ParentName, Name, String, Default)    FLAG(Type, Name, String, Default, ParentName, FALSE)",
          "796: #define FLAGNRC(Type, Name, String, Default)                FLAG(Type, Name, String, Default, NoParent, TRUE)",
          "798: #else",
          "799: #define FLAGNR(Type, Name, String, Default)",
          "801: #ifdef FLAGNRA",
          "802:     #undef FLAGNRA",
          "803: #endif",
          "804: #define FLAGNRA(Type, Name, Acronym, String, Default)",
          "806: #define FLAGPNR(Type, ParentName, Name, String, Default)",
          "807: #define FLAGNRC(Type, Name, String, Default)",
          "808: #endif",
          "811: #define FLAGPR(Type, ParentName, Name, String, Default)     FLAG(Type, Name, String, Default, ParentName, FALSE)",
          "812: #define FLAGR(Type, Name, String, Default)                  FLAG(Type, Name, String, Default, NoParent, FALSE)",
          "815: #ifndef FLAGPRA",
          "816: #define FLAGPRA(Type, ParentName, Name, Acronym, String, Default) \\",
          "817:         FLAG_REGOVR_EXP(Type, Name, String, Default, ParentName, FALSE) \\",
          "818:         FLAGNR(Type, Acronym, String, Default)",
          "819: #endif",
          "823: #define FLAGPR_REGOVR_ASMJS(Type, ParentName, Name, String, Default) FLAG_REGOVR_ASMJS(Type, Name, String, Default, ParentName, FALSE)",
          "824: #define FLAGPR_REGOVR_EXP(Type, ParentName, Name, String, Default)   FLAG_REGOVR_EXP(Type, Name, String, Default, ParentName, FALSE)",
          "827: #ifndef FLAGRA",
          "828:     #define FLAGRA(Type, Name, Acronym, String, Default) \\",
          "829:         FLAGR(Type, Name, String, Default) \\",
          "830:         FLAGNR(Type, Acronym, String, Default)",
          "831: #endif",
          "835: #if DBG",
          "836: FLAGNR(Boolean, ArrayValidate         , \"Validate each array for valid elements (default: false)\", false)",
          "837: FLAGNR(Boolean, MemOpMissingValueValidate, \"Validate Missing Value Tracking on memset/memcopy\", false)",
          "838: #endif",
          "839: #ifdef ARENA_MEMORY_VERIFY",
          "840: FLAGNR(Boolean, ArenaNoFreeList       , \"Do not free list in arena\", false)",
          "841: FLAGNR(Boolean, ArenaNoPageReuse      , \"Do not reuse page in arena\", false)",
          "842: FLAGNR(Boolean, ArenaUseHeapAlloc     , \"Arena use heap to allocate memory instead of page allocator\", false)",
          "843: #endif",
          "844: FLAGNR(Boolean, ValidateInlineStack, \"Does a stack walk on helper calls to validate inline stack is correctly restored\", false)",
          "845: FLAGNR(Boolean, AsmDiff               , \"Dump the IR without memory locations and varying parameters.\", false)",
          "846: FLAGNR(String,  AsmDumpMode           , \"Dump the final assembly to a file without memory locations and varying parameters\\n\\t\\t\\t\\t\\tThe 'filename' is the file where the assembly will be dumped. Dump to console if no file is specified\", nullptr)",
          "847: FLAGR (Boolean, Asmjs                 , \"Enable Asmjs\", DEFAULT_CONFIG_ASMJS)",
          "848: FLAGNR(Boolean, AsmJsStopOnError      , \"Stop execution on any AsmJs validation errors\", DEFAULT_CONFIG_AsmJsStopOnError)",
          "849: FLAGNR(Boolean, AsmJsEdge             , \"Enable asm.js features which may have backward incompatible changes or not validate on old demos\", DEFAULT_CONFIG_AsmJsEdge)",
          "850: FLAGNR(Boolean, WasmI64               , \"Enable Int64 testing for WebAssembly. ArgIns can be [number,string,{low:number,high:number}]. Return values will be {low:number,high:number}\", DEFAULT_CONFIG_WasmI64)",
          "851: FLAGNR(Boolean, WasmFastArray         , \"Enable fast array implementation for WebAssembly\", DEFAULT_CONFIG_WasmFastArray)",
          "853: #ifndef COMPILE_DISABLE_Simdjs",
          "854:     #define COMPILE_DISABLE_Simdjs 0",
          "855: #endif",
          "856: FLAGPR_REGOVR_EXP(Boolean, ES6, Simdjs, \"Enable Simdjs\", DEFAULT_CONFIG_SIMDJS)",
          "858: FLAGR(Boolean, Simd128TypeSpec, \"Enable type-specialization of Simd128 symbols\", false)",
          "860: FLAGNR(Boolean, AssertBreak           , \"Debug break on assert\", false)",
          "861: FLAGNR(Boolean, AssertPopUp           , \"Pop up asserts (default: false)\", false)",
          "862: FLAGNR(Boolean, AssertIgnore          , \"Ignores asserts if set\", false)",
          "863: FLAGNR(Boolean, AsyncDebugging, \"Enable async debugging feature (default: false)\", DEFAULT_CONFIG_AsyncDebugging)",
          "864: FLAGNR(Number,  BailOnNoProfileLimit,   \"The limit of bailout on no profile info before triggering a rejit\", DEFAULT_CONFIG_BailOnNoProfileLimit)",
          "865: FLAGNR(Number,  BailOnNoProfileRejitLimit, \"The limit of bailout on no profile info before we disable the bailouts\", DEFAULT_CONFIG_BailOnNoProfileRejitLimit)",
          "866: FLAGNR(Boolean, BaselineMode          , \"Dump only stable content that can be used for baseline comparison\", false)",
          "867: FLAGNR(String,  DumpOnCrash           , \"generate heap dump on asserts or unhandled exception if set\", nullptr)",
          "868: FLAGNR(String,  FullMemoryDump        , \"Will perform a full memory dump when -DumpOnCrash is supplied.\", nullptr)",
          "869: #ifdef BAILOUT_INJECTION",
          "870: FLAGR (NumberPairSet, BailOut         , \"Source location to insert BailOut\", )",
          "871: FLAGNR(Boolean, BailOutAtEveryLine    , \"Inserts BailOut at every line of source (default: false)\", false)",
          "872: FLAGNR(Boolean, BailOutAtEveryByteCode, \"Inserts BailOut at every Byte code (default: false)\", false)",
          "873: FLAGNR(Boolean, BailOutAtEveryImplicitCall, \"Force generating implicit call bailout even when we don't need it\", false)",
          "874: FLAGR (NumberSet, BailOutByteCode     , \"Byte code location to insert BailOut. Use with -prejit only\", )",
          "875: #endif",
          "876: FLAGNR(Boolean, Benchmark             , \"Disable security code which introduce variability in benchmarks\", false)",
          "877: FLAGR (Boolean, BgJit                 , \"Background JIT. Disable to force heuristic-based foreground JITting. (default: true)\", true)",
          "878: FLAGNR(Number,  BgJitDelay            , \"Delay to wait for speculative jitting before starting script execution\", DEFAULT_CONFIG_BgJitDelay)",
          "879: FLAGNR(Number,  BgJitDelayFgBuffer    , \"When speculatively jitting in the foreground thread, do so for (BgJitDelay - BgJitDelayBuffer) milliseconds\", DEFAULT_CONFIG_BgJitDelayFgBuffer)",
          "880: FLAGNR(Number,  BgJitPendingFuncCap   , \"Disable delay if pending function count larger then cap\", DEFAULT_CONFIG_BgJitPendingFuncCap)",
          "882: FLAGNR(Boolean, CreateFunctionProxy   , \"Create function proxies instead of full function bodies\", DEFAULT_CONFIG_CreateFunctionProxy)",
          "883: FLAGNR(Boolean, HybridFgJit           , \"When background JIT is enabled, enable jitting in the foreground based on heuristics. This flag is only effective when OptimizeForManyInstances is disabled (UI threads).\", DEFAULT_CONFIG_HybridFgJit)",
          "884: FLAGNR(Number,  HybridFgJitBgQueueLengthThreshold, \"The background job queue length must exceed this threshold to consider jitting in the foreground\", DEFAULT_CONFIG_HybridFgJitBgQueueLengthThreshold)",
          "885: FLAGNR(Boolean, BytecodeHist          , \"Provide a histogram of the bytecodes run by the script. (NoNative required).\", false)",
          "886: FLAGNR(Boolean, CurrentSourceInfo     , \"Enable IASD get current script source info\", DEFAULT_CONFIG_CurrentSourceInfo)",
          "887: FLAGNR(Boolean, CFGLog                , \"Log CFG checks\", false)",
          "888: FLAGNR(Boolean, CheckAlignment        , \"Insert checks in the native code to verify 8-byte alignment of stack\", false)",
          "889: FLAGNR(Boolean, CheckEmitBufferPermissions, \"Check JIT code buffers at commit and decommit time to ensure no PAGE_EXECUTE_READWRITE pages.\", false)",
          "890: #ifdef CHECK_MEMORY_LEAK",
          "891: FLAGR (Boolean, CheckMemoryLeak       , \"Check for heap memory leak\", false)",
          "892: FLAGR (String,  DumpOnLeak            , \"Create a dump on failed memory leak check\", nullptr)",
          "893: #endif",
          "894: FLAGNR(Boolean, CheckOpHelpers        , \"Verify opHelper labels in the JIT are set properly\", false)",
          "895: FLAGNR(Boolean, CloneInlinedPolymorphicCaches, \"Clones polymorphic inline caches in inlined functions\", DEFAULT_CONFIG_CloneInlinedPolymorphicCaches)",
          "896: FLAGNR(Boolean, ConcurrentRuntime     , \"Enable Concurrent GC and background JIT when creating runtime\", DEFAULT_CONFIG_ConcurrentRuntime)",
          "897: #if CONFIG_CONSOLE_AVAILABLE",
          "898: FLAGNR(Boolean, Console               , \"Create console window in GUI app\", false)",
          "899: FLAGNR(Boolean, ConsoleExitPause      , \"Pause on exit when a console window is created in GUI app\", false)",
          "900: #endif",
          "901: FLAGNR(Number,  ConstructorInlineThreshold      , \"Maximum size in bytecodes of a constructor inline candidate with monomorphic field access\", DEFAULT_CONFIG_ConstructorInlineThreshold)",
          "902: FLAGNR(Number,  ConstructorCallsRequiredToFinalizeCachedType, \"Number of calls to a constructor required before the type cached in the constructor cache is finalized\", DEFAULT_CONFIG_ConstructorCallsRequiredToFinalizeCachedType)",
          "903: #ifdef SECURITY_TESTING",
          "904: FLAGNR(Boolean, CrashOnException      , \"Removes the top-level exception handler, allowing jc.exe to crash on an unhandled exception.  No effect on IE. (default: false)\", false)",
          "905: #endif",
          "906: FLAGNR(Boolean, Debug                 , \"Disable phases (layout, security code, etc) which makes JIT output harder to debug\", false)",
          "907: FLAGNR(NumberSet,  DebugBreak         , \"Index of the function where you want to break\", )",
          "908: FLAGNR(Boolean, DebugWindow           , \"Send console output to debugger window\", false)",
          "909: FLAGNR(Boolean, DeferNested           , \"Enable deferred parsing of nested function\", DEFAULT_CONFIG_DeferNested)",
          "910: FLAGNR(Boolean, DeferTopLevelTillFirstCall      , \"Enable tracking of deferred top level functions in a script file, until the first function of the script context is parsed.\", DEFAULT_CONFIG_DeferTopLevelTillFirstCall)",
          "911: FLAGNR(Number,  DeferParse            , \"Minimum size of defer-parsed script (non-zero only: use /nodeferparse do disable\", 0)",
          "912: FLAGNR(Boolean, DirectCallTelemetryStats, \"Enables logging stats for direct call telemetry\", DEFAULT_CONFIG_DirectCallTelemetryStats)",
          "913: FLAGNR(Boolean, DisableArrayBTree     , \"Disable creation of BTree for Arrays\", false)",
          "914: FLAGNR(Boolean, DisableRentalThreading, \"Disable rental threading when creating runtime\", DEFAULT_CONFIG_DisableRentalThreading)",
          "915: FLAGNR(Boolean, DisableVTuneSourceLineInfo, \"Disable VTune Source line info for Dynamic JITted code\", false)",
          "916: FLAGNR(Boolean, DisplayMemStats, \"Display memory usage statistics\", false)",
          "917: FLAGNR(Phases,  Dump                  , \"What All to dump\", )",
          "918: #ifdef DUMP_FRAGMENTATION_STATS",
          "919: FLAGR (Boolean, DumpFragmentationStats, \"Dump bucket state after every GC\", false)",
          "920: #endif",
          "921: FLAGNR(Boolean, DumpIRAddresses,   \"Print addresses in IR dumps\", false)",
          "922: FLAGNR(Boolean, DumpLineNoInColor, \"Print the source code in high intensity color for better readability\", false)",
          "923: #ifdef RECYCLER_DUMP_OBJECT_GRAPH",
          "924: FLAGR (Boolean, DumpObjectGraphOnExit , \"Dump object graph on recycler destructor\", false)",
          "925: FLAGR (Boolean, DumpObjectGraphOnCollect, \"Dump object graph on recycler destructor\", false)",
          "926: #endif",
          "927: FLAGNR(Boolean, DumpEvalStringOnRemoval, \"Dumps an eval string when its being removed from the eval map\", false)",
          "928: FLAGNR(Boolean, DumpObjectGraphOnEnum, \"Dump object graph on recycler heap enumeration\", false)",
          "929: #ifdef DYNAMIC_PROFILE_STORAGE",
          "930: FLAGNRA(String, DynamicProfileCache   , Dpc, \"File to cache dynamic profile information\", nullptr)",
          "931: FLAGNR(String,  DynamicProfileCacheDir, \"Directory to cache dynamic profile information\", nullptr)",
          "932: FLAGNRA(String, DynamicProfileInput   , Dpi, \"Read only file containing dynamic profile information\", nullptr)",
          "933: #endif",
          "934: #ifdef EDIT_AND_CONTINUE",
          "935: FLAGNR(Boolean, EditTest              , \"Enable edit and continue test tools\", false)",
          "936: #endif",
          "937: FLAGNR(Boolean, WininetProfileCache, \"Use the WININET cache to save the profile information\", DEFAULT_CONFIG_WininetProfileCache)",
          "938: FLAGNR(Boolean, NoDynamicProfileInMemoryCache, \"Enable in-memory cache for dynamic sources\", false)",
          "939: FLAGNR(Boolean, ProfileBasedSpeculativeJit, \"Enable dynamic profile based speculative JIT\", DEFAULT_CONFIG_ProfileBasedSpeculativeJit)",
          "940: FLAGNR(Number,  ProfileBasedSpeculationCap, \"In the presence of dynamic profile speculative JIT is capped to this many bytecode instructions\", DEFAULT_CONFIG_ProfileBasedSpeculationCap)",
          "941: #ifdef DYNAMIC_PROFILE_MUTATOR",
          "942: FLAGNR(String,  DynamicProfileMutatorDll , \"Path of the mutator DLL\", _u(\"DynamicProfileMutatorImpl.dll\"))",
          "943: FLAGNR(String,  DynamicProfileMutator , \"Type of local, temp, return, param, loop implicit flag and implicit flag. \\n\\t\\t\\t\\t\\ti.e local=LikelyArray_NoMissingValues_NonInts_NonFloats;temp=Int8Array;param=LikelyNumber;return=LikelyString;loopimplicitflag=ImplicitCall_ToPrimitive;implicitflag=ImplicitCall_None\\n\\t\\t\\t\\t\\tor pass DynamicProfileMutator:random\\n\\t\\t\\t\\t\\tSee DynamicProfileInfo.h for enum values\", nullptr)",
          "944: #endif",
          "945: FLAGNR(Boolean, ExecuteByteCodeBufferReturnsInvalidByteCode, \"Serialized byte code execution always returns SCRIPT_E_INVALID_BYTECODE\", false)",
          "946: FLAGR(Number, ExpirableCollectionGCCount, \"Number of GCs during which Expirable object profiling occurs\", DEFAULT_CONFIG_ExpirableCollectionGCCount)",
          "947: FLAGR (Number,  ExpirableCollectionTriggerThreshold, \"Threshold at which Expirable Object Collection is triggered (In Percentage)\", DEFAULT_CONFIG_ExpirableCollectionTriggerThreshold)",
          "948: FLAGR(Boolean, SkipSplitOnNoResult, \"If the result of Regex split isn't used, skip executing the regex. (Perf optimization)\", DEFAULT_CONFIG_SkipSplitWhenResultIgnored)",
          "949: #ifdef TEST_ETW_EVENTS",
          "950: FLAGNR(String,  TestEtwDll            , \"Path of the TestEtwEventSink DLL\", nullptr)",
          "951: #endif",
          "953: FLAGNR(Boolean, CollectGarbage        , \"Enable CollectGarbage API\", DEFAULT_CONFIG_CollectGarbage)",
          "955: FLAGR (Boolean, Intl                  , \"Intl object support\", DEFAULT_CONFIG_Intl)",
          "956: FLAGNR(Boolean, IntlBuiltIns          , \"Intl built-in function support\", DEFAULT_CONFIG_IntlBuiltIns)",
          "961: FLAGR(Boolean, ES6                         , \"Enable ES6 stable features\",                        DEFAULT_CONFIG_ES6)",
          "964: FLAGNRC(Boolean, ES6All                    , \"Enable all ES6 features, both stable and unstable\", DEFAULT_CONFIG_ES6All)",
          "967: FLAGNRC(Boolean, ES6Experimental           , \"Enable all experimental features\",                  DEFAULT_CONFIG_ES6All)",
          "971: FLAGPR           (Boolean, ES6, ES6Species             , \"Enable ES6 '@@species' properties and built-in behaviors\" , DEFAULT_CONFIG_ES6Species)",
          "973: FLAGPR           (Boolean, ES6, ES7AsyncAwait          , \"Enable ES7 'async' and 'await' keywords\"                  , DEFAULT_CONFIG_ES7AsyncAwait)",
          "974: FLAGPR           (Boolean, ES6, ES6Classes             , \"Enable ES6 'class' and 'extends' keywords\"                , DEFAULT_CONFIG_ES6Classes)",
          "975: FLAGPR           (Boolean, ES6, ES6DateParseFix        , \"Enable ES6 Date.parse fixes\"                              , DEFAULT_CONFIG_ES6DateParseFix)",
          "976: FLAGPR           (Boolean, ES6, ES6DefaultArgs         , \"Enable ES6 Default Arguments\"                             , DEFAULT_CONFIG_ES6DefaultArgs)",
          "977: FLAGPR           (Boolean, ES6, ES6Destructuring       , \"Enable ES6 Destructuring\"                                 , DEFAULT_CONFIG_ES6Destructuring)",
          "978: FLAGPR           (Boolean, ES6, ES6ForLoopSemantics    , \"Enable ES6 for loop per iteration bindings\"               , DEFAULT_CONFIG_ES6ForLoopSemantics)",
          "979: FLAGPR           (Boolean, ES6, ES6FunctionName        , \"Enable ES6 function.name\"                                 , DEFAULT_CONFIG_ES6FunctionName)",
          "981: #ifndef COMPILE_DISABLE_ES6FunctionNameFull",
          "982:     #define COMPILE_DISABLE_ES6FunctionNameFull 0",
          "983: #endif",
          "984: FLAGPR_REGOVR_EXP(Boolean, ES6, ES6FunctionNameFull    , \"Enable ES6 Full function.name\"                            , DEFAULT_CONFIG_ES6FunctionNameFull)",
          "985: FLAGPR           (Boolean, ES6, ES6Generators          , \"Enable ES6 generators\"                                    , DEFAULT_CONFIG_ES6Generators)",
          "986: FLAGPR           (Boolean, ES6, ES7ExponentiationOperator, \"Enable ES7 exponentiation operator (**)\"                , DEFAULT_CONFIG_ES7ExponentionOperator)",
          "988: FLAGPR           (Boolean, ES6, ES7ValuesEntries       , \"Enable ES7 Object.values and Object.entries\"              , DEFAULT_CONFIG_ES7ValuesEntries)",
          "989: FLAGPR           (Boolean, ES6, ES7TrailingComma       , \"Enable ES7 trailing comma in function\"                    , DEFAULT_CONFIG_ES7TrailingComma)",
          "990: FLAGPR           (Boolean, ES6, ES6IsConcatSpreadable  , \"Enable ES6 isConcatSpreadable Symbol\"                     , DEFAULT_CONFIG_ES6IsConcatSpreadable)",
          "991: FLAGPR           (Boolean, ES6, ES6Math                , \"Enable ES6 Math extensions\"                               , DEFAULT_CONFIG_ES6Math)",
          "993: #ifndef COMPILE_DISABLE_ES6Module",
          "994:     #define COMPILE_DISABLE_ES6Module 0",
          "995: #endif",
          "996: FLAGPR_REGOVR_EXP(Boolean, ES6, ES6Module              , \"Enable ES6 Modules\"                                       , DEFAULT_CONFIG_ES6Module)",
          "997: FLAGPR           (Boolean, ES6, ES6Object              , \"Enable ES6 Object extensions\"                             , DEFAULT_CONFIG_ES6Object)",
          "998: FLAGPR           (Boolean, ES6, ES6Number              , \"Enable ES6 Number extensions\"                             , DEFAULT_CONFIG_ES6Number)",
          "999: FLAGPR           (Boolean, ES6, ES6ObjectLiterals      , \"Enable ES6 Object literal extensions\"                     , DEFAULT_CONFIG_ES6ObjectLiterals)",
          "1000: FLAGPR           (Boolean, ES6, ES6Promise             , \"Enable ES6 Promise feature\"                               , DEFAULT_CONFIG_ES6Promise)",
          "1001: FLAGPR           (Boolean, ES6, ES6Proxy               , \"Enable ES6 Proxy feature\"                                 , DEFAULT_CONFIG_ES6Proxy)",
          "1002: FLAGPR           (Boolean, ES6, ES6Rest                , \"Enable ES6 Rest parameters\"                               , DEFAULT_CONFIG_ES6Rest)",
          "1003: FLAGPR           (Boolean, ES6, ES6Spread              , \"Enable ES6 Spread support\"                                , DEFAULT_CONFIG_ES6Spread)",
          "1004: FLAGPR           (Boolean, ES6, ES6String              , \"Enable ES6 String extensions\"                             , DEFAULT_CONFIG_ES6String)",
          "1005: FLAGPR           (Boolean, ES6, ES6StringPrototypeFixes, \"Enable ES6 String.prototype fixes\"                        , DEFAULT_CONFIG_ES6StringPrototypeFixes)",
          "1007: #ifndef COMPILE_DISABLE_ES6PrototypeChain",
          "1008:     #define COMPILE_DISABLE_ES6PrototypeChain 0",
          "1009: #endif",
          "1010: FLAGPR_REGOVR_EXP(Boolean, ES6, ES6PrototypeChain      , \"Enable ES6 prototypes (Example: Date prototype is object)\", DEFAULT_CONFIG_ES6PrototypeChain)",
          "1011: FLAGPR           (Boolean, ES6, ES6ToPrimitive         , \"Enable ES6 ToPrimitive symbol\"                            , DEFAULT_CONFIG_ES6ToPrimitive)",
          "1012: FLAGPR           (Boolean, ES6, ES6ToLength            , \"Enable ES6 ToLength fixes\"                                , DEFAULT_CONFIG_ES6ToLength)",
          "1013: FLAGPR           (Boolean, ES6, ES6ToStringTag         , \"Enable ES6 ToStringTag symbol\"                            , DEFAULT_CONFIG_ES6ToStringTag)",
          "1014: FLAGPR           (Boolean, ES6, ES6Unicode             , \"Enable ES6 Unicode 6.0 extensions\"                        , DEFAULT_CONFIG_ES6Unicode)",
          "1015: FLAGPR           (Boolean, ES6, ES6UnicodeVerbose      , \"Enable ES6 Unicode 6.0 verbose failure output\"            , DEFAULT_CONFIG_ES6UnicodeVerbose)",
          "1016: FLAGPR           (Boolean, ES6, ES6Unscopables         , \"Enable ES6 With Statement Unscopables\"                    , DEFAULT_CONFIG_ES6Unscopables)",
          "1017: FLAGPR           (Boolean, ES6, ES6RegExSticky         , \"Enable ES6 RegEx sticky flag\"                             , DEFAULT_CONFIG_ES6RegExSticky)",
          "1019: #ifndef COMPILE_DISABLE_ES6RegExPrototypeProperties",
          "1020:     #define COMPILE_DISABLE_ES6RegExPrototypeProperties 0",
          "1021: #endif",
          "1022: FLAGPR_REGOVR_EXP(Boolean, ES6, ES6RegExPrototypeProperties, \"Enable ES6 properties on the RegEx prototype\"         , DEFAULT_CONFIG_ES6RegExPrototypeProperties)",
          "1024: #ifndef COMPILE_DISABLE_ES6RegExSymbols",
          "1025:     #define COMPILE_DISABLE_ES6RegExSymbols 0",
          "1026: #endif",
          "1027: FLAGPR_REGOVR_EXP(Boolean, ES6, ES6RegExSymbols        , \"Enable ES6 RegExp symbols\"                                , DEFAULT_CONFIG_ES6RegExSymbols)",
          "1029: FLAGPR           (Boolean, ES6, ES6HasInstance         , \"Enable ES6 @@hasInstance symbol\"                          , DEFAULT_CONFIG_ES6HasInstance)",
          "1030: FLAGPR           (Boolean, ES6, ES6Verbose             , \"Enable ES6 verbose trace\"                                 , DEFAULT_CONFIG_ES6Verbose)",
          "1032: #ifndef COMPILE_DISABLE_ArrayBufferTransfer",
          "1033:     #define COMPILE_DISABLE_ArrayBufferTransfer 0",
          "1034: #endif",
          "1035: FLAGPR_REGOVR_EXP(Boolean, ES6, ArrayBufferTransfer    , \"Enable ArrayBuffer.transfer\"                              , DEFAULT_CONFIG_ArrayBufferTransfer)",
          "1037: FLAGPR           (Boolean, ES6, ESObjectGetOwnPropertyDescriptors, \"Enable Object.getOwnPropertyDescriptors\"        , DEFAULT_CONFIG_ESObjectGetOwnPropertyDescriptors)",
          "1039: #ifndef COMPILE_DISABLE_ESSharedArrayBuffer",
          "1040:     #define COMPILE_DISABLE_ESSharedArrayBuffer 0",
          "1041: #endif",
          "1042: FLAGPRA          (Boolean, ES6, ESSharedArrayBuffer    , sab     , \"Enable SharedArrayBuffer\"                       , DEFAULT_CONFIG_ESSharedArrayBuffer)",
          "1046: #ifndef COMPILE_DISABLE_Wasm",
          "1047: #define COMPILE_DISABLE_Wasm 0",
          "1048: #endif",
          "1049: FLAGPR_REGOVR_EXP(Boolean, ES6, Wasm, \"Enable WebAssembly\", DEFAULT_CONFIG_WASM)",
          "1051: #ifdef ENABLE_PROJECTION",
          "1052: FLAGNR(Boolean, WinRTDelegateInterfaces , \"Treat WinRT Delegates as Interfaces when determining their resolvability.\", DEFAULT_CONFIG_WinRTDelegateInterfaces)",
          "1053: FLAGR(Boolean, WinRTAdaptiveApps        , \"Enable the adaptive apps feature, allowing for variable projection.\"      , DEFAULT_CONFIG_WinRTAdaptiveApps)",
          "1054: #endif",
          "1057: FLAGNR(Boolean, JitES6Generators        , \"Enable JITing of ES6 generators\", false)",
          "1059: FLAGNR(Boolean, FastLineColumnCalculation, \"Enable fast calculation of line/column numbers from the source.\", DEFAULT_CONFIG_FastLineColumnCalculation)",
          "1060: FLAGR (String,  Filename              , \"Jscript source file\", nullptr)",
          "1061: FLAGNR(Boolean, FreeRejittedCode      , \"Free rejitted code\", true)",
          "1062: FLAGNR(Boolean, ForceGuardPages       , \"Force the addition of guard pages\", false)",
          "1063: FLAGNR(Boolean, PrintGuardPageBounds  , \"Prints the bounds of a guard page\", false)",
          "1064: FLAGNR(Boolean, ForceLegacyEngine     , \"Force a jscrip9 dll load\", false)",
          "1065: FLAGNR(Phases,  Force                 , \"Force certain phase to run ignoring heuristics\", )",
          "1066: FLAGNR(Phases,  Stress                , \"Stress certain phases by making them kick in even if they normally would not.\", )",
          "1067: FLAGNR(Boolean, ForceArrayBTree       , \"Force enable creation of BTree for Arrays\", false)",
          "1068: FLAGNR(Boolean, ForceCleanPropertyOnCollect, \"Force cleaning of property on collection\", DEFAULT_CONFIG_ForceCleanPropertyOnCollect)",
          "1069: FLAGNR(Boolean, ForceCleanCacheOnCollect, \"Force cleaning of dynamic caches on collection\", DEFAULT_CONFIG_ForceCleanCacheOnCollect)",
          "1070: FLAGNR(Boolean, ForceGCAfterJSONParse, \"Force GC to happen after JSON parsing\", DEFAULT_CONFIG_ForceGCAfterJSONParse)",
          "1071: FLAGNR(Boolean, ForceDecommitOnCollect, \"Force decommit collect\", DEFAULT_CONFIG_ForceDecommitOnCollect)",
          "1072: FLAGNR(Boolean, ForceDeferParse       , \"Defer parsing of all function bodies\", DEFAULT_CONFIG_ForceDeferParse)",
          "1073: FLAGNR(Boolean, ForceDiagnosticsMode  , \"Enable diagnostics mode and debug interpreter loop\", false)",
          "1074: FLAGNR(Boolean, ForceGetWriteWatchOOM , \"Force GetWriteWatch to go into OOM codepath in HeapBlockMap rescan\", false)",
          "1075: FLAGNR(Boolean, ForcePostLowerGlobOptInstrString, \"Force tracking of globopt instr string post lower\", DEFAULT_CONFIG_ForcePostLowerGlobOptInstrString)",
          "1076: FLAGNR(Boolean, ForceSplitScope       , \"All functions will have unmerged body and param scopes\", DEFAULT_CONFIG_ForceSplitScope)",
          "1077: FLAGNR(Boolean, EnumerateSpecialPropertiesInDebugger, \"Enable enumeration of special debug properties\", DEFAULT_CONFIG_EnumerateSpecialPropertiesInDebugger)",
          "1078: FLAGNR(Boolean, EnableJitInDiagMode   , \"Enable Fast F12 (only applicable with ForceDiagnosticsMode or while under debugger)\", DEFAULT_CONFIG_EnableJitInDiagMode)",
          "1079: FLAGNR(Boolean, EnableContinueAfterExceptionWrappersForHelpers, \"Enable wrapper over helper methods in debugger, Fast F12 only\", DEFAULT_CONFIG_EnableContinueAfterExceptionWrappersForHelpers)",
          "1080: FLAGNR(Boolean, EnableContinueAfterExceptionWrappersForBuiltIns, \"Enable wrapper over library calls in debugger, Fast F12 only\", DEFAULT_CONFIG_EnableContinueAfterExceptionWrappersForBuiltIns)",
          "1081: FLAGNR(Boolean, EnableFunctionSourceReportForHeapEnum, \"During HeapEnum, whether to report function source info (url/row/col)\", DEFAULT_CONFIG_EnableFunctionSourceReportForHeapEnum)",
          "1082: FLAGNR(Number,  ForceFragmentAddressSpace , \"Fragment the address space\", 128 * 1024 * 1024)",
          "1083: FLAGNR(Number,  ForceOOMOnEBCommit, \"Force CommitBuffer to return OOM\", 0)",
          "1084: FLAGR (Boolean, ForceDynamicProfile   , \"Force to always generate profiling byte code\", DEFAULT_CONFIG_ForceDynamicProfile)",
          "1085: FLAGNR(Boolean, ForceES5Array         , \"Force using ES5Array\", DEFAULT_CONFIG_ForceES5Array)",
          "1086: FLAGNR(Boolean, ForceAsmJsLinkFail    , \"Force asm.js link time validation to fail\", DEFAULT_CONFIG_ForceAsmJsLinkFail)",
          "1087: FLAGNR(Boolean, ForceExpireOnNonCacheCollect, \"Allow expiration collect outside of cache collection cleanups\", DEFAULT_CONFIG_ForceExpireOnNonCacheCollect)",
          "1088: FLAGNR(Boolean, ForceFastPath         , \"Force fast-paths in native codegen\", DEFAULT_CONFIG_ForceFastPath)",
          "1089: FLAGNR(Boolean, ForceFloatPref        , \"Force float preferencing (JIT only)\", false)",
          "1090: FLAGNR(Boolean, ForceJITLoopBody      , \"Force jit loop body only\", DEFAULT_CONFIG_ForceJITLoopBody)",
          "1091: FLAGNR(Boolean, DumpCommentsFromReferencedFiles, \"Allow printing comments of comment-table of the referenced file as well (use with -trace:CommentTable)\", DEFAULT_CONFIG_DumpCommentsFromReferencedFiles)",
          "1092: FLAGNR(Number,  DelayFullJITSmallFunc , \"Scale Full JIT threshold for small functions which are going to be inlined soon. To provide fraction scale, the final scale is scale following this option devided by 10\", DEFAULT_CONFIG_DelayFullJITSmallFunc)",
          "1094: #ifdef _M_ARM",
          "1095: FLAGNR(Boolean, ForceLocalsPtr        , \"Force use of alternative locals pointer (JIT only)\", false)",
          "1096: #endif",
          "1097: FLAGNR(Boolean, DeferLoadingAvailableSource, \"Treat available source code as a dummy defer-mappable object to go through that code path.\", DEFAULT_CONFIG_DeferLoadingAvailableSource)",
          "1098: FLAGR (Boolean, ForceNative           , \"Force JIT everything that is called before running it, ignoring limits\", false)",
          "1099: FLAGNR(Boolean, ForceSerialized       , \"Always serialize and deserialize byte codes before execution\", DEFAULT_CONFIG_ForceSerialized)",
          "1100: FLAGNR(Number,  ForceSerializedBytecodeMajorVersion, \"Force the byte code serializer to write this major version number\", 0)",
          "1101: FLAGNR(Number,  ForceSerializedBytecodeVersionSchema, \"Force the byte code serializer to write this kind of version. Decimal 10 is engineering, 20 is release mode, and 0 means use the default setting.\", 0)",
          "1102: FLAGNR(Boolean, ForceStrictMode, \"Force strict mode checks on all functions\", false)",
          "1103: FLAGNR(Boolean, ForceUndoDefer        , \"Defer parsing of all function bodies, but undo deferral\", false)",
          "1104: FLAGNR(Boolean, ForceBlockingConcurrentCollect, \"Force doing in-thread GC on concurrent thread- this will skip doing concurrent collect\", false)",
          "1105: FLAGNR(Boolean, FreTestDiagMode, \"Enabled collection of diagnostic information on fretest builds\", false)",
          "1106: #ifdef BYTECODE_TESTING",
          "1107: FLAGNR(Number,  ByteCodeBranchLimit,    \"Short branch limit before we use the branch island\", 128)",
          "1108: FLAGNR(Boolean, MediumByteCodeLayout  , \"Always use medium layout for bytecodes\", false)",
          "1109: FLAGNR(Boolean, LargeByteCodeLayout   , \"Always use large layout for bytecodes\", false)",
          "1110: #endif",
          "1111: #ifdef FAULT_INJECTION",
          "1112: FLAGNR(Number,  FaultInjection        , \"FaultInjectMode - 0 (count only), 1 (count equal), 2 (count at or above), 3 (stackhashing)\",-1)",
          "1113: FLAGNR(Number,  FaultInjectionCount   , \"Injects an out of memory at the specified allocation\", -1)",
          "1114: FLAGNR(String,  FaultInjectionType    , \"FaultType (flag values) -  1 (Throw), 2 (NoThrow), 4 (MarkThrow), 8 (MarkNoThrow), FFFFFFFF (All)\", nullptr)",
          "1115: FLAGNR(String,  FaultInjectionFilter  , \"A string to restrict the fault injection, the string can be like ArenaAllocator name\", nullptr)",
          "1116: FLAGNR(Number,  FaultInjectionAllocSize, \"Do fault injection only this size\", -1)",
          "1117: FLAGNR(String,  FaultInjectionStackFile   , \"Stacks to match, default: stack.txt in current directory\", _u(\"stack.txt\"))",
          "1118: FLAGNR(Number,  FaultInjectionStackLineCount   , \"Count of lines in the stack file used for matching\", -1)",
          "1119: FLAGNR(String,  FaultInjectionStackHash, \"Match stacks hash on Chakra frames to inject the fault, hex string\", _u(\"0\"))",
          "1120: FLAGNR(Number,  FaultInjectionScriptContextToTerminateCount, \"Script context# COUNT % (Number of script contexts) to terminate\", 1)",
          "1121: #endif",
          "1122: FLAGNR(Number, InduceCodeGenFailure, \"Probability of a codegen job failing.\", DEFAULT_CONFIG_InduceCodeGenFailure)",
          "1123: FLAGNR(Number, InduceCodeGenFailureSeed, \"Seed used while calculating codegen failure probability\", 0)",
          "1124: FLAGNR(Number, InjectPartiallyInitializedInterpreterFrameError, \"The number of interpreter stack frame (with 1 being bottom-most) to inject error before the frame is initialized.\", DEFAULT_CONFIG_InjectPartiallyInitializedInterpreterFrameError)",
          "1125: FLAGNR(Number, InjectPartiallyInitializedInterpreterFrameErrorType, \"Type of error to inject: 0 - debug break, 1 - exception.\", DEFAULT_CONFIG_InjectPartiallyInitializedInterpreterFrameErrorType)",
          "1126: FLAGNR(Boolean, GenerateByteCodeBufferReturnsCantGenerate, \"Serialized byte code generation always returns SCRIPT_E_CANT_GENERATE\", false)",
          "1127: FLAGNR(Number, GoptCleanupThreshold, \"Number of instructions seen before we cleanup the value table\", DEFAULT_CONFIG_GoptCleanupThreshold)",
          "1128: FLAGNR(Number, AsmGoptCleanupThreshold, \"Number of instructions seen before we cleanup the value table\", DEFAULT_CONFIG_AsmGoptCleanupThreshold)",
          "1129: FLAGNR(Boolean, HighPrecisionDate, \"Enable sub-millisecond resolution in Javascript Date for benchmark timing\", DEFAULT_CONFIG_HighPrecisionDate)",
          "1130: FLAGNR(Number,  InlineCountMax        , \"Maximum count in bytecodes to inline in a given function\", DEFAULT_CONFIG_InlineCountMax)",
          "1131: FLAGNRA(Number, InlineCountMaxInLoopBodies, icminlb, \"Maximum count in bytecodes to inline in a given function\", DEFAULT_CONFIG_InlineCountMaxInLoopBodies)",
          "1132: FLAGNRA(Number, InlineInLoopBodyScaleDownFactor, iilbsdf, \"Maximum depth of a recursive inline call\", DEFAULT_CONFIG_InlineInLoopBodyScaleDownFactor)",
          "1133: FLAGNR(Number,  InlineThreshold       , \"Maximum size in bytecodes of an inline candidate\", DEFAULT_CONFIG_InlineThreshold)",
          "1134: FLAGNR(Number,  AggressiveInlineCountMax, \"Maximum count in bytecodes to inline in a given function\", DEFAULT_CONFIG_AggressiveInlineCountMax)",
          "1135: FLAGNR(Number,  AggressiveInlineThreshold, \"Maximum size in bytecodes of an inline candidate for aggressive inlining\", DEFAULT_CONFIG_AggressiveInlineThreshold)",
          "1136: FLAGNR(Number,  InlineThresholdAdjustCountInLargeFunction       , \"Adjustment in the maximum size in bytecodes of an inline candidate in a large function\", DEFAULT_CONFIG_InlineThresholdAdjustCountInLargeFunction)",
          "1137: FLAGNR(Number,  InlineThresholdAdjustCountInMediumSizedFunction , \"Adjustment in the maximum size in bytecodes of an inline candidate in a medium sized function\", DEFAULT_CONFIG_InlineThresholdAdjustCountInMediumSizedFunction)",
          "1138: FLAGNR(Number,  InlineThresholdAdjustCountInSmallFunction       , \"Adjustment in the maximum size in bytecodes of an inline candidate in a small function\", DEFAULT_CONFIG_InlineThresholdAdjustCountInSmallFunction)",
          "1139: FLAGNR(String,  Interpret             , \"List of functions to interpret\", nullptr)",
          "1140: FLAGNR(Phases,  Instrument            , \"Instrument the generated code from the given phase\", )",
          "1141: FLAGNR(Number,  JitQueueThreshold     , \"Max number of work items/script context in the jit queue\", DEFAULT_CONFIG_JitQueueThreshold)",
          "1142: #ifdef LEAK_REPORT",
          "1143: FLAGNR(String,  LeakReport            , \"File name for the leak report\", nullptr)",
          "1144: #endif",
          "1145: FLAGNR(Number,  LoopInlineThreshold   , \"Maximum size in bytecodes of an inline candidate with loops or not enough profile data\", DEFAULT_CONFIG_LoopInlineThreshold)",
          "1146: FLAGNR(Number,  LeafInlineThreshold   , \"Maximum size in bytecodes of an inline candidate with loops or not enough profile data\", DEFAULT_CONFIG_LeafInlineThreshold)",
          "1147: FLAGNR(Number,  ConstantArgumentInlineThreshold, \"Maximum size in bytecodes of an inline candidate with constant argument and the argument being used for a branch\", DEFAULT_CONFIG_ConstantArgumentInlineThreshold)",
          "1148: FLAGNR(Number,  RecursiveInlineThreshold, \"Maximum size in bytecodes of an inline candidate to inline recursively\", DEFAULT_CONFIG_RecursiveInlineThreshold)",
          "1149: FLAGNR(Number,  RecursiveInlineDepthMax, \"Maximum depth of a recursive inline call\", DEFAULT_CONFIG_RecursiveInlineDepthMax)",
          "1150: FLAGNR(Number,  RecursiveInlineDepthMin, \"Maximum depth of a recursive inline call\", DEFAULT_CONFIG_RecursiveInlineDepthMin)",
          "1151: FLAGNR(Number,  Loop                  , \"Number of times to execute the script (useful for profiling short benchmarks and finding leaks)\", DEFAULT_CONFIG_Loop)",
          "1152: FLAGRA(Number,  LoopInterpretCount    , lic, \"Number of times loop has to be interpreted before JIT Loop body\", DEFAULT_CONFIG_LoopInterpretCount)",
          "1153: FLAGNR(Number,  LoopProfileIterations , \"Number of iterations of a loop that must be profiled before jitting the loop body\", DEFAULT_CONFIG_LoopProfileIterations)",
          "1154: FLAGNR(Number,  OutsideLoopInlineThreshold     , \"Maximum size in bytecodes of an inline candidate outside a loop in inliner\", DEFAULT_CONFIG_OutsideLoopInlineThreshold)",
          "1155: FLAGNR(Number,  MaxFuncInlineDepth    , \"Number of times to allow inlining a function recursively, plus one (min: 1, max: 255)\", DEFAULT_CONFIG_MaxFuncInlineDepth)",
          "1156: FLAGNR(Number,  MaxNumberOfInlineesWithLoop, \"Number of times to allow inlinees with a loop in a top function\", DEFAULT_CONFIG_MaxNumberOfInlineesWithLoop)",
          "1157: #ifdef MEMSPECT_TRACKING",
          "1158: FLAGNR(Phases,  Memspect,              \"Enables memspect tracking to perform memory investigations.\", )",
          "1159: #endif",
          "1160: FLAGNR(Number,  PolymorphicInlineThreshold     , \"Maximum size in bytecodes of a polymorphic inline candidate\", DEFAULT_CONFIG_PolymorphicInlineThreshold)",
          "1161: FLAGNR(Boolean, PrimeRecycler         , \"Prime the recycler first\", DEFAULT_CONFIG_PrimeRecycler)",
          "1162: FLAGNR(Boolean, PrivateHeap           , \"Use HeapAlloc with a private heap\", DEFAULT_CONFIG_PrivateHeap)",
          "1163: #if defined(CHECK_MEMORY_LEAK) || defined(LEAK_REPORT)",
          "1164: FLAGNR(Boolean, LeakStackTrace ,        \"Include stack trace on leaked pinned object and heap objects\", false)",
          "1165: FLAGNR(Boolean, ForceMemoryLeak ,       \"Fake leak some memory to test leak report and check memory leak\", false)",
          "1166: #endif",
          "1167: FLAGNR(Boolean, ForceOldDateAPI       , \"Force Chakra to use old dates API regardless of availability of a new one\", DEFAULT_CONFIG_ForceOldDateAPI)",
          "1169: FLAGNR(Number,  JitLoopBodyHotLoopThreshold    , \"Number of times loop has to be iterated in jitloopbody before it is determined as hot\", DEFAULT_CONFIG_JitLoopBodyHotLoopThreshold)",
          "1170: FLAGNR(Number,  LoopBodySizeThresholdToDisableOpts, \"Minimum bytecode size of a loop body, above which we might consider switching off optimizations in jit loop body to avoid rejits\", DEFAULT_CONFIG_LoopBodySizeThresholdToDisableOpts)",
          "1172: FLAGNR(Number,  MaxJitThreadCount     , \"Number of maximum allowed parallel jit threads (actual number is factor of number of processors and other heuristics)\", DEFAULT_CONFIG_MaxJitThreadCount)",
          "1173: FLAGNR(Boolean, ForceMaxJitThreadCount, \"Force the number of parallel jit threads as specified by MaxJitThreadCount flag (creation guaranteed)\", DEFAULT_CONFIG_ForceMaxJitThreadCount)",
          "1175: FLAGNR(Number,  MinInterpretCount     , \"Minimum number of times a function must be interpreted\", 0)",
          "1176: FLAGNR(Number,  MinSimpleJitRunCount  , \"Minimum number of times a function must be run in simple jit\", 0)",
          "1177: FLAGNRA(Number, MaxInterpretCount     , Mic, \"Maximum number of times a function can be interpreted\", 0)",
          "1178: FLAGNRA(Number, MaxSimpleJitRunCount  , Msjrc, \"Maximum number of times a function will be run in SimpleJitted code\", 0)",
          "1179: FLAGNRA(Number, MinMemOpCount         , Mmoc, \"Minimum count of a loop to activate MemOp\", DEFAULT_CONFIG_MinMemOpCount)",
          "1181: #if ENABLE_COPYONACCESS_ARRAY",
          "1182: FLAGNR(Number,  MaxCopyOnAccessArrayLength, \"Maximum length of copy-on-access array\", DEFAULT_CONFIG_MaxCopyOnAccessArrayLength)",
          "1183: FLAGNR(Number,  MinCopyOnAccessArrayLength, \"Minimum length of copy-on-access array\", DEFAULT_CONFIG_MinCopyOnAccessArrayLength)",
          "1184: FLAGNR(Number,  CopyOnAccessArraySegmentCacheSize, \"Size of copy-on-access array segment cache (1-32)\", DEFAULT_CONFIG_CopyOnAccessArraySegmentCacheSize)",
          "1185: #endif",
          "1187: FLAGNR(Number, MinTemplatizedJitRunCount, \"Minimum number of times a function must be Templatized Jitted\", DEFAULT_CONFIG_MinTemplatizedJitRunCount)",
          "1188: FLAGNR(Number, MinAsmJsInterpreterRunCount, \"Minimum number of times a function must be Asm Interpreted\", DEFAULT_CONFIG_MinAsmJsInterpreterRunCount)",
          "1190: FLAGNR(Number, MinTemplatizedJitLoopRunCount, \"Minimum LoopCount run of the Templatized Jit function to run FullJited\", DEFAULT_CONFIG_MinTemplatizedJitLoopRunCount)",
          "1191: FLAGNRA(Number, MaxTemplatizedJitRunCount, Mtjrc, \"Maximum number of times a function must be templatized jit\", DEFAULT_CONFIG_MaxTemplatizedJitRunCount)",
          "1192: FLAGNRA(Number, MaxAsmJsInterpreterRunCount, Maic, \"Maximum number of times a function must be interpreted in asmjs\", DEFAULT_CONFIG_MaxAsmJsInterpreterRunCount)",
          "1194: FLAGR (Number,  AutoProfilingInterpreter0Limit, \"Limit after which to transition to the next execution mode\", DEFAULT_CONFIG_AutoProfilingInterpreter0Limit)",
          "1195: FLAGR (Number,  ProfilingInterpreter0Limit, \"Limit after which to transition to the next execution mode\", DEFAULT_CONFIG_ProfilingInterpreter0Limit)",
          "1196: FLAGR (Number,  AutoProfilingInterpreter1Limit, \"Limit after which to transition to the next execution mode\", DEFAULT_CONFIG_AutoProfilingInterpreter1Limit)",
          "1197: FLAGR (Number,  SimpleJitLimit, \"Limit after which to transition to the next execution mode\", DEFAULT_CONFIG_SimpleJitLimit)",
          "1198: FLAGR (Number,  ProfilingInterpreter1Limit, \"Limit after which to transition to the next execution mode\", DEFAULT_CONFIG_ProfilingInterpreter1Limit)",
          "1200: FLAGNRA(String, ExecutionModeLimits,        Eml,  \"Execution mode limits in th form: AutoProfilingInterpreter0.ProfilingInterpreter0.AutoProfilingInterpreter1.SimpleJit.ProfilingInterpreter1 - Example: -ExecutionModeLimits:12.4.0.132.12\", _u(\"\"))",
          "1201: FLAGRA(Boolean, EnforceExecutionModeLimits, Eeml, \"Enforces the execution mode limits such that they are never exceeded.\", false)",
          "1203: FLAGNRA(Number, SimpleJitAfter        , Sja, \"Number of calls to a function after which to simple-JIT the function\", 0)",
          "1204: FLAGNRA(Number, FullJitAfter          , Fja, \"Number of calls to a function after which to full-JIT the function. The function will be profiled for every iteration.\", 0)",
          "1206: FLAGNR(Boolean, NewSimpleJit          , \"Uses the new simple JIT\", DEFAULT_CONFIG_NewSimpleJit)",
          "1208: FLAGNR(Number,  MaxLinearIntCaseCount , \"Maximum number of cases(in switch statement) for which instructions can be generated linearly\",DEFAULT_CONFIG_MaxLinearIntCaseCount)",
          "1209: FLAGNR(Number,  MaxSingleCharStrJumpTableSize, \"Maximum single char string jump table size\", DEFAULT_CONFIG_MaxSingleCharStrJumpTableSize)",
          "1210: FLAGNR(Number,  MaxSingleCharStrJumpTableRatio, \"Maximum single char string jump table size as multiples of the actual case arm\", DEFAULT_CONFIG_MaxSingleCharStrJumpTableRatio)",
          "1211: FLAGNR(Number,  MinSwitchJumpTableSize , \"Minimum size of the jump table, that is created for consecutive integer case arms in a Switch Statement\",DEFAULT_CONFIG_MinSwitchJumpTableSize)",
          "1212: FLAGNR(Number,  MaxLinearStringCaseCount,  \"Maximum number of string cases(in switch statement) for which instructions can be generated linearly\",DEFAULT_CONFIG_MaxLinearStringCaseCount)",
          "1213: FLAGR(Number,   MinDeferredFuncTokenCount, \"Minimum length in tokens of defer-parsed function\", DEFAULT_CONFIG_MinDeferredFuncTokenCount)",
          "1214: #if DBG",
          "1215: FLAGNR(Number,  SkipFuncCountForBailOnNoProfile,  \"Initial Number of functions in a func body to be skipped from forcibly inserting BailOnNoProfile.\", DEFAULT_CONFIG_SkipFuncCountForBailOnNoProfile)",
          "1216: #endif",
          "1217: FLAGNR(Number,  MaxJITFunctionBytecodeSize, \"The biggest function we'll JIT (bytecode size)\", DEFAULT_CONFIG_MaxJITFunctionBytecodeSize)",
          "1218: FLAGNR(Number,  MaxLoopsPerFunction   , \"Maximum number of loops in any function in the script\", DEFAULT_CONFIG_MaxLoopsPerFunction)",
          "1219: FLAGNR(Number,  FuncObjectInlineCacheThreshold  , \"Maximum number of inline caches a function body may have to allow for inline caches to be allocated on the function object\", DEFAULT_CONFIG_FuncObjectInlineCacheThreshold)",
          "1220: FLAGNR(Boolean, NoDeferParse          , \"Disable deferred parsing\", false)",
          "1221: FLAGNR(Boolean, NoLogo                , \"No logo, which we don't display anyways\", false)",
          "1222: FLAGNR(Boolean, OOPJITMissingOpts     , \"Use optimizations that are missing from OOP JIT\", DEFAULT_CONFIG_OOPJITMissingOpts)",
          "1223: FLAGNR(Boolean, OOPCFGRegistration    , \"Do CFG registration OOP (under OOP JIT)\", DEFAULT_CONFIG_OOPCFGRegistration)",
          "1224: FLAGNR(Number,  RPCFailFastWait       , \"Wait time for JIT process termination before triggering failfast on RPC failure\", DEFAULT_CONFIG_RPCFailFastWait)",
          "1225: #ifdef _ARM64_",
          "1226: FLAGR (Boolean, NoNative              , \"Disable native codegen\", true)",
          "1227: #else",
          "1228: FLAGR (Boolean, NoNative              , \"Disable native codegen\", false)",
          "1229: #endif",
          "1231: FLAGNR(Number,  NopFrequency          , \"Frequency of NOPs inserted by NOP insertion phase.  A NOP is guaranteed to be inserted within a range of (1<<n) instrs (default=8)\", DEFAULT_CONFIG_NopFrequency)",
          "1232: FLAGNR(Boolean, NoStrictMode          , \"Disable strict mode checks on all functions\", false)",
          "1233: FLAGNR(Boolean, NormalizeStats        , \"When dumping stats, do some normalization (used with -instrument:linearscan)\", false)",
          "1234: #ifdef ENABLE_PROJECTION",
          "1235: FLAGNR(Boolean, NoWinRTFastSig        , \"Disable fast call for common WinRT function signatures\", false)",
          "1236: #endif",
          "1237: FLAGNR(Phases,  Off                   , \"Turn off specific phases or feature.(Might not work for all phases)\", )",
          "1238: FLAGNR(Phases,  OffProfiledByteCode   , \"Turn off specific byte code for phases or feature.(Might not work for all phases)\", )",
          "1239: FLAGNR(Phases,  On                    , \"Turn on specific phases or feature.(Might not work for all phases)\", )",
          "1240: FLAGNR(String,  OutputFile            , \"Log the output to a specified file. Default: output.log in the working directory.\", _u(\"output.log\"))",
          "1241: FLAGNR(String,  OutputFileOpenMode    , \"File open mode for OutputFile. Default: wt, specify 'at' for append\", _u(\"wt\"))",
          "1242: #ifdef ENABLE_TRACE",
          "1243: FLAGNR(Boolean, InMemoryTrace         , \"Enable in-memory trace (investigate crash using trace in dump file). Use !jd.dumptrace to print it.\", DEFAULT_CONFIG_InMemoryTrace)",
          "1244: FLAGNR(Number,  InMemoryTraceBufferSize, \"The size of circular buffer for in-memory trace (the units used is: number of trace calls). \", DEFAULT_CONFIG_InMemoryTraceBufferSize)",
          "1245: #if CONFIG_RICH_TRACE_FORMAT",
          "1246: FLAGNR(Boolean, RichTraceFormat, \"Whether to use extra data in Output/Trace header.\", DEFAULT_CONFIG_RichTraceFormat)",
          "1247: #endif",
          "1248: #ifdef STACK_BACK_TRACE",
          "1249: FLAGNR(Boolean, TraceWithStack, \"Whether the trace need to include stack trace (for each trace entry).\", DEFAULT_CONFIG_TraceWithStack)",
          "1250: #endif // STACK_BACK_TRACE",
          "1251: #endif // ENABLE_TRACE",
          "1252: FLAGNR(Boolean, PrintRunTimeDataCollectionTrace, \"Print traces needed for runtime data collection\", false)",
          "1253: #ifdef ENABLE_PREJIT",
          "1254: FLAGR (Boolean, Prejit                , \"Prejit everything, including things that are not called, ignoring limits (default: false)\", DEFAULT_CONFIG_Prejit)",
          "1255: #endif",
          "1256: FLAGNR(Boolean, PrintSrcInDump        , \"Print the lineno and the source code in the intermediate dumps\", true)",
          "1257: #if PROFILE_DICTIONARY",
          "1258: FLAGNR(Number,  ProfileDictionary     , \"Profile dictionary usage. Only dictionaries with max depth of <number> or above are displayed (0=no filter).\", -1)",
          "1259: #endif",
          "1260: #ifdef PROFILE_EXEC",
          "1261: FLAGNR(Phases,  Profile               , \"Profile the given phase\", )",
          "1262: FLAGNR(Number,  ProfileThreshold      , \"A phase is displayed in the profiler report only if its contribution is more than this threshold\", 0)",
          "1263: #endif",
          "1264: #ifdef PROFILE_OBJECT_LITERALS",
          "1265: FLAGNR(Boolean, ProfileObjectLiteral  , \"Profile Object literal usage\", false)",
          "1266: #endif",
          "1267: #ifdef PROFILE_MEM",
          "1268: FLAGNR(String,  ProfileMemory         , \"Profile memory usage\", )",
          "1269: #endif",
          "1270: #ifdef PROFILE_STRINGS",
          "1271: FLAGNR(Boolean, ProfileStrings        , \"Profile string statistics\", false)",
          "1272: #endif",
          "1273: #ifdef PROFILE_TYPES",
          "1274: FLAGNR(Boolean, ProfileTypes          , \"Profile type statistics\", false)",
          "1275: #endif",
          "1276: #ifdef PROFILE_EVALMAP",
          "1277: FLAGNR(Boolean, ProfileEvalMap        , \"Profile eval map statistics\", false)",
          "1278: #endif",
          "1280: #ifdef PROFILE_BAILOUT_RECORD_MEMORY",
          "1281: FLAGNR(Boolean, ProfileBailOutRecordMemory, \"Profile bailout record memory statistics\", false)",
          "1282: #endif",
          "1284: FLAGNR(Number,  RejitMaxBailOutCount, \"Maximum number of bailouts for a bailout record after which rejit is forced\", DEFAULT_CONFIG_RejitMaxBailOutCount)",
          "1285: FLAGNR(Number,  CallsToBailoutsRatioForRejit, \"Ratio of function calls to bailouts above which a rejit is considered\", DEFAULT_CONFIG_CallsToBailoutsRatioForRejit)",
          "1286: FLAGNR(Number,  LoopIterationsToBailoutsRatioForRejit, \"Ratio of loop iteration count to bailouts above which a rejit of the loop body is considered\", DEFAULT_CONFIG_LoopIterationsToBailoutsRatioForRejit)",
          "1287: FLAGNR(Number,  MinBailOutsBeforeRejit, \"Minimum number of bailouts for a single bailout record after which a rejit is considered\", DEFAULT_CONFIG_MinBailOutsBeforeRejit)",
          "1288: FLAGNR(Number,  MinBailOutsBeforeRejitForLoops, \"Minimum number of bailouts for a single bailout record after which a rejit is considered\", DEFAULT_CONFIG_MinBailOutsBeforeRejitForLoops)",
          "1289: FLAGNR(Boolean, LibraryStackFrame           , \"Display library stack frame\", DEFAULT_CONFIG_LibraryStackFrame)",
          "1290: FLAGNR(Boolean, LibraryStackFrameDebugger   , \"Assume debugger support for library stack frame\", DEFAULT_CONFIG_LibraryStackFrameDebugger)",
          "1291: #ifdef RECYCLER_STRESS",
          "1292: FLAGNR(Boolean, RecyclerStress        , \"Stress the recycler by collect on every allocation call\", false)",
          "1293: #if ENABLE_CONCURRENT_GC",
          "1294: FLAGNR(Boolean, RecyclerBackgroundStress        , \"Stress the recycler by collect in the background thread on every allocation call\", false)",
          "1295: FLAGNR(Boolean, RecyclerConcurrentStress        , \"Stress the concurrent recycler by concurrent collect on every allocation call\", false)",
          "1296: FLAGNR(Boolean, RecyclerConcurrentRepeatStress  , \"Stress the concurrent recycler by concurrent collect on every allocation call and repeat mark and rescan in the background thread\", false)",
          "1297: #endif",
          "1298: #if ENABLE_PARTIAL_GC",
          "1299: FLAGNR(Boolean, RecyclerPartialStress , \"Stress the partial recycler by partial collect on every allocation call\", false)",
          "1300: #endif",
          "1301: FLAGNR(Boolean, RecyclerTrackStress, \"Stress tracked object handling by simulating tracked objects for regular allocations\", false)",
          "1302: FLAGNR(Boolean, RecyclerInduceFalsePositives, \"Stress recycler by forcing false positive object marks\", false)",
          "1303: #endif // RECYCLER_STRESS",
          "1304: FLAGNR(Boolean, RecyclerForceMarkInterior, \"Force all the mark as interior\", DEFAULT_CONFIG_RecyclerForceMarkInterior)",
          "1305: #if ENABLE_CONCURRENT_GC",
          "1306: FLAGNR(Number,  RecyclerPriorityBoostTimeout, \"Adjust priority boost timeout\", 5000)",
          "1307: FLAGNR(Number,  RecyclerThreadCollectTimeout, \"Adjust thread collect timeout\", 1000)",
          "1308: #endif",
          "1309: #ifdef RECYCLER_PAGE_HEAP",
          "1310: FLAGNR(Number,      PageHeap,             \"Use full page for heap allocations\", DEFAULT_CONFIG_PageHeap)",
          "1311: FLAGNR(Boolean,     PageHeapAllocStack,   \"Capture alloc stack under page heap mode\", DEFAULT_CONFIG_PageHeapAllocStack)",
          "1312: FLAGNR(Boolean,     PageHeapFreeStack,    \"Capture free stack under page heap mode\", DEFAULT_CONFIG_PageHeapFreeStack)",
          "1313: FLAGNR(NumberRange, PageHeapBucketNumber, \"Bucket numbers to be used for page heap allocations\", )",
          "1314: FLAGNR(Number,      PageHeapBlockType,    \"Type of blocks to use page heap for\", DEFAULT_CONFIG_PageHeapBlockType)",
          "1315: #endif",
          "1316: #ifdef RECYCLER_NO_PAGE_REUSE",
          "1317: FLAGNR(Boolean, RecyclerNoPageReuse,     \"Do not reuse page in recycler\", false)",
          "1318: #endif",
          "1319: #ifdef RECYCLER_MEMORY_VERIFY",
          "1320: FLAGNR(Phases,  RecyclerVerify         , \"Verify recycler memory\", )",
          "1321: FLAGNR(Number,  RecyclerVerifyPadSize  , \"Padding size to verify recycler memory\", 12)",
          "1322: #endif",
          "1323: FLAGNR(Boolean, RecyclerTest           , \"Run recycler tests instead of executing script\", false)",
          "1324: FLAGNR(Boolean, RecyclerProtectPagesOnRescan, \"Temporarily switch all pages to read only during rescan\", false)",
          "1325: #ifdef RECYCLER_VERIFY_MARK",
          "1326: FLAGNR(Boolean, RecyclerVerifyMark    , \"verify concurrent gc\", false)",
          "1327: #endif",
          "1328: FLAGR (Number,  LowMemoryCap          , \"Memory cap indicating a low-memory process\", DEFAULT_CONFIG_LowMemoryCap)",
          "1329: FLAGNR(Number,  NewPagesCapDuringBGSweeping, \"New pages count allowed to be allocated during background sweeping\", DEFAULT_CONFIG_NewPagesCapDuringBGSweeping)",
          "1330: #ifdef RUNTIME_DATA_COLLECTION",
          "1331: FLAGNR(String,  RuntimeDataOutputFile, \"Filename to write the dynamic profile info\", nullptr)",
          "1332: #endif",
          "1333: FLAGNR(Boolean, ReportErrors          , \"Enable reporting of syntax errors\", false)",
          "1334: FLAGR (Number,  SpeculationCap        , \"How much bytecode we'll speculatively JIT\", DEFAULT_CONFIG_SpeculationCap)",
          "1335: #if DBG_DUMP || defined(BGJIT_STATS) || defined(RECYCLER_STATS)",
          "1336: FLAGNR(Phases,  Stats                 , \"Stats the given phase\", )",
          "1337: #endif",
          "1338: #if EXCEPTION_RECOVERY",
          "1339: FLAGNR(Boolean, SwallowExceptions     , \"Force a try/catch around every statement\", false)",
          "1340: #endif",
          "1341: FLAGNR(Boolean, PrintSystemException  , \"Always print a message when there's OOM or OOS\", false)",
          "1342: FLAGNR(Number,  SwitchOptHolesThreshold,  \"Maximum percentage of holes (missing case values in a switch statement) with which a jump table can be created\",DEFAULT_CONFIG_SwitchOptHolesThreshold)",
          "1343: FLAGR (Number,  TempMin                  , \"Temp number switch which code can temporarily use for debugging\", DEFAULT_CONFIG_TempMin)",
          "1344: FLAGR (Number,  TempMax                  , \"Temp number switch which code can temporarily use for debugging\", DEFAULT_CONFIG_TempMax)",
          "1345: FLAGNR(Phases,  Trace                 , \"Trace the given phase\", )",
          "1347: #if defined(_M_IX86) || defined(_M_X64)",
          "1348: FLAGR(Number,   LoopAlignNopLimit       , \"Max number of nops for loop alignment\", DEFAULT_CONFIG_LoopAlignNopLimit)",
          "1349: #endif",
          "1351: #ifdef PROFILE_MEM",
          "1352: FLAGNR(Phases,  TraceMemory           , \"Trace memory usage\", )",
          "1353: #endif",
          "1354: #if DBG_DUMP || defined(RECYCLER_TRACE)",
          "1361: FLAGNR(Number,  TraceMetaDataParsing  , \"Trace metadata parsing for generating JS projections. [Levels 1-5, with 5 corresponding to most detailed]\", 5)",
          "1362: FLAGNR(Boolean, TraceWin8Allocations  , \"Trace the win8 memory allocations\", false)",
          "1363: FLAGNR(Boolean, TraceWin8DeallocationsImmediate  , \"Trace the win8 memory deallocations immediately\", false)",
          "1364: FLAGNR(Boolean, PrintWin8StatsDetailed  , \"Print the detailed memory trace report\", false)",
          "1365: FLAGNR(Boolean, TraceProtectPages     , \"Trace calls to protecting pages of custom heap allocated pages\", false)",
          "1370: FLAGNR(Number, TraceProjection       , \"Trace projection related activities, [Levels 1-3, with 3 corresponding to most detailed]\", 3)",
          "1371: #endif",
          "1372: FLAGNR(Boolean, TraceAsyncDebugCalls  , \"Trace calls to async debugging API (default: false)\", DEFAULT_CONFIG_TraceAsyncDebugCalls)",
          "1373: #ifdef TRACK_DISPATCH",
          "1374: FLAGNR(Boolean, TrackDispatch         , \"Save stack traces of where JavascriptDispatch/HostVariant are created\", false)",
          "1375: #endif",
          "1376: FLAGNR(Boolean, Verbose               , \"Dump details\", DEFAULT_CONFIG_Verbose)",
          "1377: FLAGNR(Boolean, UseFullName           , \"Enable fully qualified name\", DEFAULT_CONFIG_UseFullName)",
          "1378: FLAGNR(Boolean, UseFunctionIdForTrace , \"Use function id instead of function number for trace output\", false)",
          "1379: FLAGNR(Boolean, Utf8                  , \"Use UTF8 for file output\", false)",
          "1380: FLAGR (Number,  Version               , \"Version in which to run the jscript engine. [one of 1,2,3,4,5,6]. Default is latest for jc/jshost, 1 for IE\", 6 )",
          "1381: #ifdef ENABLE_PROJECTION",
          "1382: FLAGR (Number,  HostType              , \"Host type in which to run the jscript engine. [one of 1,2]. Default is 1 = Browser.\", 1)",
          "1383: #endif",
          "1384: FLAGR(Boolean, WERExceptionSupport    , \"WER feature for extended exception support. Enabled when WinRT is enabled\", false)",
          "1385: #ifdef ENABLE_PROJECTION",
          "1386: FLAGR (Boolean, WinRTConstructorAllowed, \"Whether WinRT constructors is allowed in WebView host type. Constructor is always allowed in other host type \", false)",
          "1387: #endif",
          "1388: FLAGNR(Boolean, ExtendedErrorStackForTestHost, \"Enable passing extended error stack string to test host.\", DEFAULT_CONFIG_ExtendedErrorStackForTestHost)",
          "1389: FLAGNR(Boolean, errorStackTrace       , \"error.StackTrace feature. Remove when feature complete\", DEFAULT_CONFIG_errorStackTrace)",
          "1390: FLAGNR(Boolean, DoHeapEnumOnEngineShutdown, \"Perform a heap enumeration whenever shut a script engine down\", false)",
          "1391: #ifdef HEAP_ENUMERATION_VALIDATION",
          "1392: FLAGNR(Boolean, ValidateHeapEnum      , \"Validate that heap enumeration is reporting all Js::RecyclableObjects in the heap\", false)",
          "1393: #endif",
          "1395: #if ENABLE_REGEX_CONFIG_OPTIONS",
          "1399: FLAGR (Boolean, RegexTracing          , \"Trace all Regex invocations to the output.\", DEFAULT_CONFIG_RegexTracing)",
          "1400: FLAGR (Boolean, RegexProfile          , \"Collect usage statistics on all Regex invocations.\", DEFAULT_CONFIG_RegexProfile)",
          "1401: FLAGR (Boolean, RegexDebug            , \"Trace compilation of UnifiedRegex expressions.\", DEFAULT_CONFIG_RegexDebug)",
          "1402: FLAGR (Boolean, RegexOptimize         , \"Optimize regular expressions in the unified Regex system (default: true)\", DEFAULT_CONFIG_RegexOptimize)",
          "1403: FLAGR (Number,  DynamicRegexMruListSize, \"Size of the MRU list for dynamic regexes\", DEFAULT_CONFIG_DynamicRegexMruListSize)",
          "1404: #endif",
          "1406: FLAGR (Boolean, OptimizeForManyInstances, \"Optimize script engine for many instances (low memory footprint per engine, assume low spare CPU cycles) (default: false)\", DEFAULT_CONFIG_OptimizeForManyInstances)",
          "1407: FLAGNR(Phases,  TestTrace             , \"Test trace for the given phase\", )",
          "1408: FLAGNR(Boolean, EnableEvalMapCleanup, \"Enable cleaning up the eval map\", true)",
          "1409: #ifdef PROFILE_MEM",
          "1410: FLAGNR(Boolean, TraceObjectAllocation, \"Enable cleaning up the eval map\", false)",
          "1411: #endif",
          "1412: #ifdef ENABLE_PROJECTION",
          "1413: FLAGNR(Boolean, EnableThirdPartyGCPressure, \"Enable use of GCPressure attribute value on 3rd party WinRT objects (not in Windows namespace) (default: false)\", false)",
          "1414: FLAGNR(Number, TargetWinRTVersion, \"Specifies WinRT version number to target. [one of 0,1,2,3,4]. Default is 1 = NTDDI_WIN8\", DEFAULT_CONFIG_TargetWinRTVersion)",
          "1415: FLAGNR(Boolean, EnableVersioningAllAssemblies, \"Enable versioning behavior for all assemblies, regardless of host flag (default: false)\", false)",
          "1416: FLAGR(Boolean, FailFastIfDisconnectedDelegate, \"When set fail fast if disconnected delegate is invoked\", DEFAULT_CONFIG_FailFastIfDisconnectedDelegate)",
          "1417: #endif",
          "1418: FLAGNR(Number, Sse, \"Virtually disables SSE-based optimizations above the specified SSE level in the Chakra JIT (does not affect CRT SSE usage)\", DEFAULT_CONFIG_Sse)",
          "1419: FLAGNR(Number,  DeletedPropertyReuseThreshold, \"Start reusing deleted property indexes after this many properties are deleted. Zero to disable reuse.\", DEFAULT_CONFIG_DeletedPropertyReuseThreshold)",
          "1420: FLAGNR(Boolean, ForceStringKeyedSimpleDictionaryTypeHandler, \"Force switch to string keyed version of SimpleDictionaryTypeHandler on first new property added to a SimpleDictionaryTypeHandler\", DEFAULT_CONFIG_ForceStringKeyedSimpleDictionaryTypeHandler)",
          "1421: FLAGNR(Number,  BigDictionaryTypeHandlerThreshold, \"Min Slot Capacity required to convert DictionaryTypeHandler to BigDictionaryTypeHandler.(Advisable to give more than 15 - to avoid false positive cases)\", DEFAULT_CONFIG_BigDictionaryTypeHandlerThreshold)",
          "1422: FLAGNR(Boolean, TypeSnapshotEnumeration, \"Create a true snapshot of the type of an object before enumeration and enumerate only those properties.\", DEFAULT_CONFIG_TypeSnapshotEnumeration)",
          "1423: FLAGR (Boolean, EnumerationCompat,      \"When set in IE10 mode, restores enumeration behavior to RC behavior\", DEFAULT_CONFIG_EnumerationCompat)",
          "1424: FLAGNR(Boolean, IsolatePrototypes, \"Should prototypes get unique types not shared with other objects (default: true)?\", DEFAULT_CONFIG_IsolatePrototypes)",
          "1425: FLAGNR(Boolean, ChangeTypeOnProto, \"When becoming a prototype should the object switch to a new type (default: true)?\", DEFAULT_CONFIG_ChangeTypeOnProto)",
          "1426: FLAGNR(Boolean, ShareInlineCaches, \"Determines whether inline caches are shared between all loads (or all stores) of the same property ID\", DEFAULT_CONFIG_ShareInlineCaches)",
          "1427: FLAGNR(Boolean, DisableDebugObject, \"Disable test only Debug object properties\", DEFAULT_CONFIG_DisableDebugObject)",
          "1428: FLAGNR(Boolean, DumpHeap, \"enable Debug.dumpHeap even when DisableDebugObject is set\", DEFAULT_CONFIG_DumpHeap)",
          "1429: FLAGNR(String, autoProxy, \"enable creating proxy for each object creation\", _u(\"__msTestHandler\"))",
          "1430: FLAGNR(Number,  PerfHintLevel, \"Specifies the perf-hint level (1,2) 1 == critical, 2 == only noisy\", DEFAULT_CONFIG_PerfHintLevel)",
          "1431: #ifdef INTERNAL_MEM_PROTECT_HEAP_ALLOC",
          "1432: FLAGNR(Boolean, MemProtectHeap, \"Use the mem protect heap as the default heap\", DEFAULT_CONFIG_MemProtectHeap)",
          "1433: #endif",
          "1434: #ifdef RECYCLER_STRESS",
          "1435: FLAGNR(Boolean, MemProtectHeapStress, \"Stress the recycler by collect on every allocation call\", false)",
          "1436: #if ENABLE_CONCURRENT_GC",
          "1437: FLAGNR(Boolean, MemProtectHeapBackgroundStress, \"Stress the recycler by collect in the background thread on every allocation call\", false)",
          "1438: FLAGNR(Boolean, MemProtectHeapConcurrentStress, \"Stress the concurrent recycler by concurrent collect on every allocation call\", false)",
          "1439: FLAGNR(Boolean, MemProtectHeapConcurrentRepeatStress, \"Stress the concurrent recycler by concurrent collect on every allocation call and repeat mark and rescan in the background thread\", false)",
          "1440: #endif",
          "1441: #if ENABLE_PARTIAL_GC",
          "1442: FLAGNR(Boolean, MemProtectHeapPartialStress, \"Stress the partial recycler by partial collect on every allocation call\", false)",
          "1443: #endif",
          "1444: #endif",
          "1445: #ifdef SUPPORT_FIXED_FIELDS_ON_PATH_TYPES",
          "1446: FLAGNR(Boolean, FixPropsOnPathTypes, \"Mark properties as fixed on path types (default: false).\", DEFAULT_CONFIG_FixPropsOnPathTypes)",
          "1447: #endif",
          "1448: FLAGNR(NumberSet, BailoutTraceFilter, \"Filter the bailout trace messages to specific bailout kinds.\", )",
          "1449: FLAGNR(NumberSet, RejitTraceFilter, \"Filter the rejit trace messages to specific bailout kinds.\", )",
          "1452: FLAGNR(Number,  MaxBackgroundFinishMarkCount, \"Maximum number of background finish mark\", 1)",
          "1453: FLAGNR(Number,  BackgroundFinishMarkWaitTime, \"Millisecond to wait for background finish mark\", 15)",
          "1454: FLAGNR(Number,  MinBackgroundRepeatMarkRescanBytes, \"Minimum number of bytes rescan to trigger background finish mark\",  -1)",
          "1456: #if defined(_M_IX86) || defined(_M_X64)",
          "1457: FLAGNR(Boolean, ZeroMemoryWithNonTemporalStore, \"Zero free memory with non-temporal stores to avoid evicting other content from processor cache\", DEFAULT_CONFIG_ZeroMemoryWithNonTemporalStore)",
          "1458: #endif",
          "1461: FLAGNR(Number,  MaxMarkStackPageCount , \"Restrict recycler mark stack size (in pages)\", -1)",
          "1462: FLAGNR(Number,  MaxTrackedObjectListCount,  \"Restrict recycler tracked object count during GC\", -1)",
          "1465: FLAGNR(Number, NumberAllocPlusSize, \"Additional bytes to allocate with JavascriptNumber from number allocator (0~496)\", 0)",
          "1467: #if DBG",
          "1468: FLAGNR(Boolean, InitializeInterpreterSlotsWithInvalidStackVar, \"Enable the initialization of the interpreter local slots with invalid stack vars\", false)",
          "1469: #endif",
          "1471: #if DBG",
          "1472: FLAGNR(Number, PRNGSeed0, \"Override seed0 for Math.Random()\", 0)",
          "1473: FLAGNR(Number, PRNGSeed1, \"Override seed1 for Math.Random()\", 0)",
          "1474: #endif",
          "1476: FLAGNR(Boolean, ClearInlineCachesOnCollect, \"Clear all inline caches on every garbage collection\", false)",
          "1477: FLAGNR(Number, InlineCacheInvalidationListCompactionThreshold, \"Compact inline cache invalidation lists if their utilization falls below this threshold\", DEFAULT_CONFIG_InlineCacheInvalidationListCompactionThreshold)",
          "1478: FLAGNR(Number, ConstructorCacheInvalidationThreshold, \"Clear uniquePropertyGuard entries from recyclableData if number of invalidations of constructor caches happened are more than the threshold.\", DEFAULT_CONFIG_ConstructorCacheInvalidationThreshold)",
          "1480: #ifdef IR_VIEWER",
          "1481: FLAGNR(Boolean, IRViewer, \"Enable IRViewer functionality (improved UI for various stages of IR generation)\", false)",
          "1484: FLAGNR(Boolean, InvalidateSolutionContextsForGetStructure, \"To reduce memory consumption, in the end of GetStructure call, invalidate script contexts used only for GetStructure -- this would invalidate ones associated with solution files (not top-most references such as helpers.js)\", DEFAULT_CONFIG_InvalidateSolutionContextsForGetStructure)",
          "1485: FLAGNR(Boolean, ES5LangTel, \"Print ES5 language telemetry output.\", false)",
          "1486: FLAGNR(Boolean, ES6LangTel, \"Print ES6 language telemetry output.\", false)",
          "1487: FLAGNR(Boolean, ESBLangTel, \"Print ES built-ins telemetry output.\", false)",
          "1488: FLAGNR(Boolean, DateParseTel, \"Print Date.parse telemetry output.\", false)",
          "1490: FLAGNR(Number,  GCMemoryThreshold, \"Threshold for allocation-based GC initiation (in MB)\", 0)",
          "1492: #ifdef _CONTROL_FLOW_GUARD",
          "1493: FLAGNR(Boolean, PreReservedHeapAlloc, \"Enable Pre-reserved Heap Page Allocator\", true)",
          "1494: FLAGNR(Boolean, CFGInJit, \"Enable CFG check in JIT\", true)",
          "1495: FLAGNR(Boolean, CFG, \"Force enable CFG on jshost. version in the jshost's manifest file disables CFG\", true)",
          "1496: #endif",
          "1498: #if DBG",
          "1499:     FLAGNR(Number, SimulatePolyCacheWithOneTypeForInlineCacheIndex, \"Use with SimulatePolyCacheWithOneTypeForFunction to simulate creating a polymorphic inline cache containing only one type due to a collision, for testing ObjTypeSpec\", -1)",
          "1500: #endif",
          "1502: FLAGR(Number, JITServerIdleTimeout, \"Idle timeout in milliseconds to do the cleanup in JIT server\", 500)",
          "1503: FLAGR(Number, JITServerMaxInactivePageAllocatorCount, \"Max inactive page allocators to keep before schedule a cleanup\", 10)",
          "1505: FLAGNR(Boolean, StrictWriteBarrierCheck, \"Check write barrier setting on none write barrier pages\", DEFAULT_CONFIG_StrictWriteBarrierCheck)",
          "1506: FLAGNR(Boolean, WriteBarrierTest, \"Always return true while checking barrier to test recycler regardless of annotation\", DEFAULT_CONFIG_WriteBarrierTest)",
          "1507: FLAGNR(Boolean, ForceSoftwareWriteBarrier, \"Use to turn off write watch to test software write barrier on windows\", DEFAULT_CONFIG_ForceSoftwareWriteBarrier)",
          "1508: FLAGNR(Boolean, VerifyBarrierBit, \"Verify software write barrier bit is set while marking\", DEFAULT_CONFIG_VerifyBarrierBit)",
          "1509: FLAGNR(Boolean, EnableBGFreeZero, \"Use to turn off background freeing and zeroing to simulate linux\", DEFAULT_CONFIG_EnableBGFreeZero)",
          "1510: FLAGNR(Boolean, KeepRecyclerTrackData, \"Keep recycler track data after sweep until reuse\", DEFAULT_CONFIG_KeepRecyclerTrackData)",
          "1512: #undef FLAG_REGOVR_EXP",
          "1513: #undef FLAG_REGOVR_ASMJS",
          "1515: #undef FLAG",
          "1516: #undef FLAGP",
          "1518: #undef FLAGRA",
          "1520: #undef FLAGNR",
          "1521: #undef FLAGNRA",
          "1522: #undef FLAGPNR",
          "1523: #undef FLAGPRA",
          "1525: #endif",
          "",
          "[Added Lines]",
          "5: #ifdef PHASE",
          "6: PHASE(All)",
          "7:     PHASE(BGJit)",
          "8:     PHASE(LibInit)",
          "9:         PHASE(JsLibInit)",
          "10:     PHASE(Parse)",
          "11:         PHASE(RegexCompile)",
          "12:         PHASE(DeferParse)",
          "13:         PHASE(Redeferral)",
          "14:         PHASE(DeferEventHandlers)",
          "15:         PHASE(FunctionSourceInfoParse)",
          "16:         PHASE(StringTemplateParse)",
          "17:         PHASE(SkipNestedDeferred)",
          "18:         PHASE(CacheScopeInfoNames)",
          "19:         PHASE(ScanAhead)",
          "20:         PHASE(ParallelParse)",
          "21:         PHASE(EarlyReferenceErrors)",
          "22:     PHASE(ByteCode)",
          "23:         PHASE(CachedScope)",
          "24:         PHASE(StackFunc)",
          "25:         PHASE(StackClosure)",
          "26:         PHASE(DisableStackFuncOnDeferredEscape)",
          "27:         PHASE(DelayCapture)",
          "28:         PHASE(DebuggerScope)",
          "29:         PHASE(ByteCodeSerialization)",
          "30:             PHASE(VariableIntEncoding)",
          "31:         PHASE(NativeCodeSerialization)",
          "32:         PHASE(OptimizeBlockScope)",
          "33:     PHASE(Delay)",
          "34:         PHASE(Speculation)",
          "35:         PHASE(GatherCodeGenData)",
          "36:     PHASE(WasmBytecode)",
          "37:         PHASE(WasmParser)",
          "38:         PHASE(WasmReader)",
          "39:         PHASE(WasmSection)",
          "40:         PHASE(WasmLEB128)",
          "41:         PHASE(WasmFunctionBody)",
          "42:         PHASE(WasmDeferred)",
          "43:         PHASE(WasmValidatePrejit)",
          "44:     PHASE(Asmjs)",
          "45:         PHASE(AsmjsTmpRegisterAllocation)",
          "46:         PHASE(AsmjsEncoder)",
          "47:         PHASE(AsmjsInterpreter)",
          "48:         PHASE(AsmJsJITTemplate)",
          "49:         PHASE(AsmjsFunctionEntry)",
          "50:         PHASE(AsmjsInterpreterStack)",
          "51:         PHASE(AsmjsEntryPointInfo)",
          "52:         PHASE(AsmjsCallDebugBreak)",
          "53:         PHASE(BackEnd)",
          "54:         PHASE(IRBuilder)",
          "55:             PHASE(SwitchOpt)",
          "56:             PHASE(BailOnNoProfile)",
          "57:             PHASE(BackendConcatExprOpt)",
          "58:             PHASE(ClosureRangeCheck)",
          "59:             PHASE(ClosureRegCheck)",
          "60:         PHASE(Inline)",
          "61:             PHASE(InlineRecursive)",
          "62:             PHASE(InlineAtEveryCaller)      //Inlines a function, say, foo at every caller of foo. Doesn't guarantee all the calls within foo are inlined too.",
          "63:             PHASE(InlineTree)               //Inlines every function within a top function, say, foo (which needs to be top function) Note: -force:inline achieves the effect of both -force:InlineTree & -force:InlineAtEveryCaller",
          "64:             PHASE(TryAggressiveInlining)",
          "65:             PHASE(InlineConstructors)",
          "66:             PHASE(InlineBuiltIn)",
          "67:             PHASE(InlineInJitLoopBody)",
          "68:             PHASE(InlineAccessors)",
          "69:             PHASE(InlineGetters)",
          "70:             PHASE(InlineSetters)",
          "71:             PHASE(InlineApply)",
          "72:             PHASE(InlineApplyTarget)",
          "73:             PHASE(InlineApplyWithoutArrayArg)",
          "74:             PHASE(BailOutOnNotStackArgs)",
          "75:             PHASE(InlineCall)",
          "76:             PHASE(InlineCallTarget)",
          "77:             PHASE(PartialPolymorphicInline)",
          "78:             PHASE(PolymorphicInline)",
          "79:             PHASE(PolymorphicInlineFixedMethods)",
          "80:             PHASE(InlineOutsideLoops)",
          "81:             PHASE(InlineFunctionsWithLoops)",
          "82:             PHASE(EliminateArgoutForInlinee)",
          "83:             PHASE(InlineBuiltInCaller)",
          "84:             PHASE(InlineArgsOpt)",
          "85:                 PHASE(RemoveInlineFrame)",
          "86:             PHASE(InlinerConstFold)",
          "87:     PHASE(ExecBOIFastPath)",
          "88:         PHASE(FGBuild)",
          "89:             PHASE(RemoveBreakBlock)",
          "90:             PHASE(TailDup)",
          "91:         PHASE(FGPeeps)",
          "92:         PHASE(GlobOpt)",
          "93:             PHASE(OptimizeTryCatch)",
          "94:             PHASE(Backward)",
          "95:                 PHASE(TrackIntUsage)",
          "96:                 PHASE(TrackNegativeZero)",
          "97:                 PHASE(TypedArrayVirtual)",
          "98:                 PHASE(TrackIntOverflow)",
          "99:                 PHASE(TrackCompoundedIntOverflow)",
          "100:             PHASE(Forward)",
          "101:                 PHASE(ValueTable)",
          "102:                 PHASE(PathDependentValues)",
          "103:                     PHASE(TrackRelativeIntBounds)",
          "104:                         PHASE(BoundCheckElimination)",
          "105:                             PHASE(BoundCheckHoist)",
          "106:                                 PHASE(LoopCountBasedBoundCheckHoist)",
          "107:                 PHASE(CopyProp)",
          "108:                     PHASE(ObjPtrCopyProp)",
          "109:                 PHASE(ConstProp)",
          "110:                 PHASE(ConstFold)",
          "111:                 PHASE(CSE)",
          "112:                 PHASE(HoistConstInt)",
          "113:                 PHASE(TypeSpec)",
          "114:                 PHASE(AggressiveIntTypeSpec)",
          "115:                 PHASE(AggressiveMulIntTypeSpec)",
          "116:                 PHASE(LossyIntTypeSpec)",
          "117:                 PHASE(FloatTypeSpec)",
          "118:                 PHASE(StringTypeSpec)",
          "119:                 PHASE(InductionVars)",
          "120:                 PHASE(Invariants)",
          "121:                 PHASE(FieldCopyProp)",
          "122:                 PHASE(FieldHoist)",
          "123:                 PHASE(FieldPRE)",
          "124:                 PHASE(HostOpt)",
          "125:                 PHASE(ObjTypeSpec)",
          "126:                     PHASE(ObjTypeSpecNewObj)",
          "127:                     PHASE(ObjTypeSpecIsolatedFldOps)",
          "128:                     PHASE(ObjTypeSpecIsolatedFldOpsWithBailOut)",
          "129:                     PHASE(ObjTypeSpecStore)",
          "130:                     PHASE(EquivObjTypeSpec)",
          "131:                     PHASE(EquivObjTypeSpecByDefault)",
          "132:                     PHASE(TraceObjTypeSpecTypeGuards)",
          "133:                     PHASE(TraceObjTypeSpecWriteGuards)",
          "134:                     PHASE(LiveOutFields)",
          "135:                     PHASE(DisabledObjTypeSpec)",
          "136:                     #if DBG",
          "137:                         PHASE(SimulatePolyCacheWithOneTypeForFunction)",
          "138:                     #endif",
          "139:                 PHASE(CheckThis)",
          "140:                 PHASE(StackArgOpt)",
          "141:                 PHASE(StackArgFormalsOpt)",
          "142:                 PHASE(IndirCopyProp)",
          "143:                 PHASE(ArrayCheckHoist)",
          "144:                     PHASE(ArrayMissingValueCheckHoist)",
          "145:                     PHASE(ArraySegmentHoist)",
          "146:                         PHASE(JsArraySegmentHoist)",
          "147:                     PHASE(ArrayLengthHoist)",
          "148:                     PHASE(EliminateArrayAccessHelperCall)",
          "149:                 PHASE(NativeArray)",
          "150:                     PHASE(NativeNewScArray)",
          "151:                     PHASE(NativeArrayConversion)",
          "152:                     PHASE(CopyOnAccessArray)",
          "153:                     PHASE(NativeArrayLeafSegment)",
          "154:                 PHASE(TypedArrayTypeSpec)",
          "155:                 PHASE(LdLenIntSpec)",
          "156:                 PHASE(FixDataProps)",
          "157:                 PHASE(FixMethodProps)",
          "158:                 PHASE(FixAccessorProps)",
          "159:                 PHASE(FixDataVarProps)",
          "160:                 PHASE(UseFixedDataProps)",
          "161:                 PHASE(UseFixedDataPropsInInliner)",
          "162:                 PHASE(LazyBailout)",
          "163:                     PHASE(LazyFixedDataBailout)",
          "164:                     PHASE(LazyFixedTypeBailout)",
          "165:                 PHASE(FixedMethods)",
          "166:                     PHASE(FEFixedMethods)",
          "167:                     PHASE(FixedFieldGuardCheck)",
          "168:                     PHASE(FixedNewObj)",
          "169:                         PHASE(JitAllocNewObj)",
          "170:                     PHASE(FixedCtorInlining)",
          "171:                     PHASE(FixedCtorCalls)",
          "172:                     PHASE(FixedScriptMethodInlining)",
          "173:                     PHASE(FixedScriptMethodCalls)",
          "174:                     PHASE(FixedBuiltInMethodInlining)",
          "175:                     PHASE(FixedBuiltInMethodCalls)",
          "176:                     PHASE(SplitNewScObject)",
          "177:                 PHASE(OptTagChecks)",
          "178:                 PHASE(MemOp)",
          "179:                     PHASE(MemSet)",
          "180:                     PHASE(MemCopy)",
          "181:                 PHASE(IncrementalBailout)",
          "182:             PHASE(DeadStore)",
          "183:                 PHASE(ReverseCopyProp)",
          "184:                 PHASE(MarkTemp)",
          "185:                     PHASE(MarkTempNumber)",
          "186:                     PHASE(MarkTempObject)",
          "187:                     PHASE(MarkTempNumberOnTempObject)",
          "188:         PHASE(Lowerer)",
          "189:             PHASE(FastPath)",
          "190:                 PHASE(LoopFastPath)",
          "191:                 PHASE(MathFastPath)",
          "192:                 PHASE(Atom)",
          "193:                     PHASE(MulStrengthReduction)",
          "194:                     PHASE(AgenPeeps)",
          "195:                 PHASE(BranchFastPath)",
          "196:                 PHASE(CallFastPath)",
          "197:                 PHASE(BitopsFastPath)",
          "198:                 PHASE(OtherFastPath)",
          "199:                 PHASE(ObjectFastPath)",
          "200:                 PHASE(ProfileBasedFldFastPath)",
          "201:                 PHASE(AddFldFastPath)",
          "202:                 PHASE(RootObjectFldFastPath)",
          "203:                 PHASE(ArrayLiteralFastPath)",
          "204:                 PHASE(ArrayCtorFastPath)",
          "205:                 PHASE(NewScopeSlotFastPath)",
          "206:                 PHASE(FrameDisplayFastPath)",
          "207:                 PHASE(HoistMarkTempInit)",
          "208:                 PHASE(HoistConstAddr)",
          "209:             PHASE(JitWriteBarrier)",
          "210:             PHASE(PreLowererPeeps)",
          "211:             PHASE(CFGInJit)",
          "212:             PHASE(TypedArray)",
          "213:             PHASE(TracePinnedTypes)",
          "214:         PHASE(InterruptProbe)",
          "215:         PHASE(EncodeConstants)",
          "216:         PHASE(RegAlloc)",
          "217:             PHASE(Liveness)",
          "218:                 PHASE(RegParams)",
          "219:             PHASE(LinearScan)",
          "220:                 PHASE(OpHelperRegOpt)",
          "221:                 PHASE(StackPack)",
          "222:                 PHASE(SecondChance)",
          "223:                 PHASE(RegionUseCount)",
          "224:                 PHASE(RegHoistLoads)",
          "225:                 PHASE(ClearRegLoopExit)",
          "226:         PHASE(Peeps)",
          "227:         PHASE(Layout)",
          "228:         PHASE(EHBailoutPatchUp)",
          "229:         PHASE(FinalLower)",
          "230:         PHASE(PrologEpilog)",
          "231:         PHASE(InsertNOPs)",
          "232:         PHASE(Encoder)",
          "233:             PHASE(Emitter)",
          "234: #if defined(_M_IX86) || defined(_M_X64)",
          "235:             PHASE(BrShorten)",
          "236:                 PHASE(LoopAlign)",
          "237: #endif",
          "239: #ifdef RECYCLER_WRITE_BARRIER",
          "240: #if DBG_DUMP",
          "241:     PHASE(SWB)",
          "242: #endif",
          "243: #endif",
          "244:     PHASE(Run)",
          "245:         PHASE(Interpreter)",
          "246:         PHASE(EvalCompile)",
          "247:             PHASE(FastIndirectEval)",
          "248:         PHASE(IdleDecommit)",
          "249:         PHASE(IdleCollect)",
          "250:         PHASE(MemoryAllocation)",
          "251: #ifdef RECYCLER_PAGE_HEAP",
          "252:             PHASE(PageHeap)",
          "253: #endif",
          "254:             PHASE(LargeMemoryAllocation)",
          "255:             PHASE(PageAllocatorAlloc)",
          "256:         PHASE(Recycler)",
          "257:             PHASE(ThreadCollect)",
          "258:             PHASE(ExplicitFree)",
          "259:             PHASE(ExpirableCollect)",
          "260:             PHASE(GarbageCollect)",
          "261:             PHASE(ConcurrentCollect)",
          "262:                 PHASE(BackgroundResetMarks)",
          "263:                 PHASE(BackgroundFindRoots)",
          "264:                 PHASE(BackgroundRescan)",
          "265:                 PHASE(BackgroundRepeatMark)",
          "266:                 PHASE(BackgroundFinishMark)",
          "267:             PHASE(ConcurrentPartialCollect)",
          "268:             PHASE(ParallelMark)",
          "269:             PHASE(PartialCollect)",
          "270:                 PHASE(ResetMarks)",
          "271:                 PHASE(ResetWriteWatch)",
          "272:                 PHASE(FindRoot)",
          "273:                     PHASE(FindRootArena)",
          "274:                     PHASE(FindImplicitRoot)",
          "275:                     PHASE(FindRootExt)",
          "276:                 PHASE(ScanStack)",
          "277:                 PHASE(ConcurrentMark)",
          "278:                 PHASE(ConcurrentWait)",
          "279:                 PHASE(Rescan)",
          "280:                 PHASE(Mark)",
          "281:                 PHASE(Sweep)",
          "282:                     PHASE(SweepWeak)",
          "283:                     PHASE(SweepSmall)",
          "284:                     PHASE(SweepLarge)",
          "285:                     PHASE(SweepPartialReuse)",
          "286:                 PHASE(ConcurrentSweep)",
          "287:                 PHASE(Finalize)",
          "288:                 PHASE(Dispose)",
          "289:                 PHASE(FinishPartial)",
          "290:         PHASE(Host)",
          "291:         PHASE(BailOut)",
          "292:         PHASE(RegexQc)",
          "293:         PHASE(RegexOptBT)",
          "294:         PHASE(InlineCache)",
          "295:         PHASE(PolymorphicInlineCache)",
          "296:         PHASE(MissingPropertyCache)",
          "297:         PHASE(CloneCacheInCollision)",
          "298:         PHASE(ConstructorCache)",
          "299:         PHASE(InlineCandidate)",
          "300:         PHASE(InlineHostCandidate)",
          "301:         PHASE(ScriptFunctionWithInlineCache)",
          "302:         PHASE(IsConcatSpreadableCache)",
          "303:         PHASE(Arena)",
          "304:         PHASE(ApplyUsage)",
          "305:         PHASE(ObjectHeaderInlining)",
          "306:             PHASE(ObjectHeaderInliningForConstructors)",
          "307:             PHASE(ObjectHeaderInliningForObjectLiterals)",
          "308:             PHASE(ObjectHeaderInliningForEmptyObjects)",
          "309:         PHASE(OptUnknownElementName)",
          "310: #if DBG_DUMP",
          "311:         PHASE(TypePropertyCache)",
          "312:         PHASE(InlineSlots)",
          "313: #endif",
          "314:         PHASE(DynamicProfile)",
          "315: #ifdef DYNAMIC_PROFILE_STORAGE",
          "316:         PHASE(DynamicProfileStorage)",
          "317: #endif",
          "318:         PHASE(JITLoopBody)",
          "319:         PHASE(JITLoopBodyInTryCatch)",
          "320:         PHASE(ReJIT)",
          "321:         PHASE(ExecutionMode)",
          "322:         PHASE(SimpleJitDynamicProfile)",
          "323:         PHASE(SimpleJit)",
          "324:         PHASE(FullJit)",
          "325:         PHASE(FailNativeCodeInstall)",
          "326:         PHASE(PixelArray)",
          "327:         PHASE(Etw)",
          "328:         PHASE(Profiler)",
          "329:         PHASE(CustomHeap)",
          "330:         PHASE(XDataAllocator)",
          "331:         PHASE(PageAllocator)",
          "332:         PHASE(StringConcat)",
          "333: #if DBG_DUMP",
          "334:         PHASE(PRNG)",
          "335: #endif",
          "336:         PHASE(PreReservedHeapAlloc)",
          "337:         PHASE(CFG)",
          "338:         PHASE(ExceptionStackTrace)",
          "339:         PHASE(ExtendedExceptionInfoStackTrace)",
          "340:         PHASE(ProjectionMetadata)",
          "341:         PHASE(TypeHandlerTransition)",
          "342:         PHASE(Debugger)",
          "343:             PHASE(ENC)",
          "344:         PHASE(ConsoleScope)",
          "345:         PHASE(ScriptProfiler)",
          "346:         PHASE(JSON)",
          "347:         PHASE(RegexResultNotUsed)",
          "348:         PHASE(Error)",
          "349:         PHASE(PropertyRecord)",
          "350:         PHASE(TypePathDynamicSize)",
          "351:         PHASE(ConditionalCompilation)",
          "352:         PHASE(InterpreterProfile)",
          "353:         PHASE(InterpreterAutoProfile)",
          "354:         PHASE(ByteCodeConcatExprOpt)",
          "355:         PHASE(TraceInlineCacheInvalidation)",
          "356:         PHASE(TracePropertyGuards)",
          "357: #ifdef ENABLE_JS_ETW",
          "358:         PHASE(StackFramesEvent)",
          "359: #endif",
          "360:         PHASE(PerfHint)",
          "361:         PHASE(TypeShareForChangePrototype)",
          "362:         PHASE(DeferSourceLoad)",
          "363:         PHASE(ObjectMutationBreakpoint)",
          "364:         PHASE(NativeCodeData)",
          "365: #undef PHASE",
          "366: #endif",
          "368: #ifndef DEFAULT_CONFIG_BgJitDelay",
          "369: #if _M_ARM",
          "370: #define DEFAULT_CONFIG_BgJitDelay           (70)",
          "371: #else",
          "372: #define DEFAULT_CONFIG_BgJitDelay           (30)",
          "373: #endif",
          "374: #define DEFAULT_CONFIG_ASMJS                (true)",
          "375: #define DEFAULT_CONFIG_AsmJsEdge            (false)",
          "376: #define DEFAULT_CONFIG_AsmJsStopOnError     (false)",
          "377: #ifdef COMPILE_DISABLE_Simdjs",
          "379:     #define DEFAULT_CONFIG_SIMDJS               (false)",
          "380: #else",
          "381:     #define DEFAULT_CONFIG_SIMDJS               (false)",
          "382: #endif",
          "383: #define DEFAULT_CONFIG_WASM               (false)",
          "384: #define DEFAULT_CONFIG_WasmI64            (false)",
          "385: #if ENABLE_FAST_ARRAYBUFFER",
          "386:     #define DEFAULT_CONFIG_WasmFastArray    (true)",
          "387: #else",
          "388:     #define DEFAULT_CONFIG_WasmFastArray    (false)",
          "389: #endif",
          "390: #define DEFAULT_CONFIG_BgJitDelayFgBuffer   (0)",
          "391: #define DEFAULT_CONFIG_BgJitPendingFuncCap  (31)",
          "392: #define DEFAULT_CONFIG_CurrentSourceInfo     (true)",
          "393: #define DEFAULT_CONFIG_CreateFunctionProxy  (true)",
          "394: #define DEFAULT_CONFIG_HybridFgJit          (false)",
          "395: #define DEFAULT_CONFIG_HybridFgJitBgQueueLengthThreshold (32)",
          "396: #define DEFAULT_CONFIG_Prejit               (false)",
          "397: #define DEFAULT_CONFIG_DeferNested          (true)",
          "398: #define DEFAULT_CONFIG_DeferTopLevelTillFirstCall (true)",
          "399: #define DEFAULT_CONFIG_DirectCallTelemetryStats (false)",
          "400: #define DEFAULT_CONFIG_errorStackTrace      (true)",
          "401: #define DEFAULT_CONFIG_FastLineColumnCalculation (true)",
          "402: #define DEFAULT_CONFIG_PrintLineColumnInfo (false)",
          "403: #define DEFAULT_CONFIG_ForceDecommitOnCollect (false)",
          "404: #define DEFAULT_CONFIG_ForceDeferParse      (false)",
          "405: #define DEFAULT_CONFIG_NoDeferParse         (false)",
          "406: #define DEFAULT_CONFIG_ForceDynamicProfile  (false)",
          "407: #define DEFAULT_CONFIG_ForceExpireOnNonCacheCollect (false)",
          "408: #define DEFAULT_CONFIG_ForceFastPath        (false)",
          "409: #define DEFAULT_CONFIG_ForceJITLoopBody     (false)",
          "410: #define DEFAULT_CONFIG_ForceCleanPropertyOnCollect (false)",
          "411: #define DEFAULT_CONFIG_ForceCleanCacheOnCollect (false)",
          "412: #define DEFAULT_CONFIG_ForceGCAfterJSONParse (false)",
          "413: #define DEFAULT_CONFIG_ForceSerialized      (false)",
          "414: #define DEFAULT_CONFIG_ForceES5Array        (false)",
          "415: #define DEFAULT_CONFIG_ForceAsmJsLinkFail   (false)",
          "416: #define DEFAULT_CONFIG_DumpCommentsFromReferencedFiles (false)",
          "417: #define DEFAULT_CONFIG_ExtendedErrorStackForTestHost (false)",
          "418: #define DEFAULT_CONFIG_ForceSplitScope      (false)",
          "419: #define DEFAULT_CONFIG_DelayFullJITSmallFunc (0)",
          "423: #define DEFAULT_CONFIG_InlineThreshold      (35)            //Default start",
          "424: #define DEFAULT_CONFIG_AggressiveInlineThreshold  (80)      //Limit for aggressive inlining.",
          "425: #define DEFAULT_CONFIG_InlineThresholdAdjustCountInLargeFunction  (20)",
          "426: #define DEFAULT_CONFIG_InlineThresholdAdjustCountInMediumSizedFunction  (6)",
          "427: #define DEFAULT_CONFIG_InlineThresholdAdjustCountInSmallFunction  (10)",
          "428: #define DEFAULT_CONFIG_ConstructorInlineThreshold (21)      //Monomorphic constructor threshold",
          "429: #define DEFAULT_CONFIG_ConstructorCallsRequiredToFinalizeCachedType (2)",
          "430: #define DEFAULT_CONFIG_OutsideLoopInlineThreshold (16)      //Threshold to inline outside loops",
          "431: #define DEFAULT_CONFIG_LeafInlineThreshold  (60)            //Inlinee threshold for function which is leaf (irrespective of it has loops or not)",
          "432: #define DEFAULT_CONFIG_LoopInlineThreshold  (25)            //Inlinee threshold for function with loops",
          "433: #define DEFAULT_CONFIG_PolymorphicInlineThreshold  (35)     //Polymorphic inline threshold",
          "434: #define DEFAULT_CONFIG_InlineCountMax       (1200)          //Max sum of bytecodes of inlinees inlined into a function (excluding built-ins)",
          "435: #define DEFAULT_CONFIG_InlineCountMaxInLoopBodies (500)     // Max sum of bytecodes of inlinees that can be inlined into a jitted loop body (excluding built-ins)",
          "436: #define DEFAULT_CONFIG_AggressiveInlineCountMax       (8000)          //Max sum of bytecodes of inlinees inlined into a function (excluding built-ins) when inlined aggressively",
          "437: #define DEFAULT_CONFIG_MaxFuncInlineDepth   (2)             //Maximum number of times a function can be inlined within a top function",
          "438: #define DEFAULT_CONFIG_MaxNumberOfInlineesWithLoop   (40) //Inlinee with a loop is controlled by LoopInlineThreshold, though we don't want to inline lot of inlinees with loop, this ensures a limit.",
          "439: #define DEFAULT_CONFIG_ConstantArgumentInlineThreshold   (157)      // Bytecode threshold for functions with constant arguments which are used for branching",
          "440: #define DEFAULT_CONFIG_RecursiveInlineThreshold     (2000)      // Bytecode threshold recursive call at a call site",
          "441: #define DEFAULT_CONFIG_RecursiveInlineDepthMax      (8)      // Maximum inline depth for recursive calls",
          "442: #define DEFAULT_CONFIG_RecursiveInlineDepthMin      (2)      // Minimum inline depth for recursive call",
          "443: #define DEFAULT_CONFIG_InlineInLoopBodyScaleDownFactor    (4)",
          "445: #define DEFAULT_CONFIG_CloneInlinedPolymorphicCaches (true)",
          "446: #define DEFAULT_CONFIG_HighPrecisionDate    (false)",
          "447: #define DEFAULT_CONFIG_ForceOldDateAPI      (false)",
          "448: #define DEFAULT_CONFIG_Loop                 (1)",
          "449: #define DEFAULT_CONFIG_ForceDiagnosticsMode (false)",
          "450: #define DEFAULT_CONFIG_EnableJitInDiagMode  (true)",
          "451: #define DEFAULT_CONFIG_UseFullName          (true)",
          "452: #define DEFAULT_CONFIG_EnableContinueAfterExceptionWrappersForHelpers  (true)",
          "453: #define DEFAULT_CONFIG_EnableContinueAfterExceptionWrappersForBuiltIns  (true)",
          "454: #define DEFAULT_CONFIG_EnableFunctionSourceReportForHeapEnum (true)",
          "455: #define DEFAULT_CONFIG_LoopInterpretCount   (150)",
          "456: #define DEFAULT_CONFIG_LoopProfileIterations (25)",
          "457: #define DEFAULT_CONFIG_JitLoopBodyHotLoopThreshold (20000)",
          "458: #define DEFAULT_CONFIG_LoopBodySizeThresholdToDisableOpts (255)",
          "460: #define DEFAULT_CONFIG_MaxJitThreadCount        (2)",
          "461: #define DEFAULT_CONFIG_ForceMaxJitThreadCount   (false)",
          "463: #ifdef RECYCLER_PAGE_HEAP",
          "464: #define DEFAULT_CONFIG_PageHeap             ((Js::Number) PageHeapMode::PageHeapModeOff)",
          "465: #define DEFAULT_CONFIG_PageHeapAllocStack   (false)",
          "466: #define DEFAULT_CONFIG_PageHeapFreeStack    (false)",
          "467: #define DEFAULT_CONFIG_PageHeapBlockType    ((Js::Number) PageHeapBlockTypeFilter::PageHeapBlockTypeFilterAll)",
          "468: #endif",
          "470: #define DEFAULT_CONFIG_LowMemoryCap         (0xB900000) // 185 MB - based on memory cap for process on low-capacity device",
          "471: #define DEFAULT_CONFIG_NewPagesCapDuringBGSweeping    (15000)",
          "473: #define DEFAULT_CONFIG_MaxCodeFill          (500)",
          "474: #define DEFAULT_CONFIG_MaxLoopsPerFunction  (10)",
          "475: #define DEFAULT_CONFIG_NopFrequency         (8)",
          "476: #define DEFAULT_CONFIG_SpeculationCap       (1)         // Needs to be 1 and not 0 since the compiler complains about a condition being always false",
          "477: #define DEFAULT_CONFIG_ProfileBasedSpeculationCap (1600)",
          "478: #define DEFAULT_CONFIG_Verbose              (false)",
          "479: #define DEFAULT_CONFIG_ForceStrictMode      (false)",
          "480: #define DEFAULT_CONFIG_EnableEvalMapCleanup (true)",
          "481: #define DEFAULT_CONFIG_ExpirableCollectionGCCount (5)  // Number of GCs during which entry point profiling occurs",
          "482: #define DEFAULT_CONFIG_ExpirableCollectionTriggerThreshold (50)  // Threshold at which Entry Point Collection is triggered",
          "483: #define DEFAULT_CONFIG_RegexTracing         (false)",
          "484: #define DEFAULT_CONFIG_RegexProfile         (false)",
          "485: #define DEFAULT_CONFIG_RegexDebug           (false)",
          "486: #define DEFAULT_CONFIG_RegexOptimize        (true)",
          "487: #define DEFAULT_CONFIG_DynamicRegexMruListSize (16)",
          "488: #define DEFAULT_CONFIG_GoptCleanupThreshold  (25)",
          "489: #define DEFAULT_CONFIG_AsmGoptCleanupThreshold  (500)",
          "490: #define DEFAULT_CONFIG_OptimizeForManyInstances (false)",
          "492: #define DEFAULT_CONFIG_DeferParseThreshold             (4 * 1024) // Unit is number of characters",
          "493: #define DEFAULT_CONFIG_ProfileBasedDeferParseThreshold (100)      // Unit is number of characters",
          "495: #define DEFAULT_CONFIG_ProfileBasedSpeculativeJit (true)",
          "496: #define DEFAULT_CONFIG_WininetProfileCache        (true)",
          "497: #define DEFAULT_CONFIG_MinProfileCacheSize        (5)   // Minimum number of functions before profile is saved.",
          "498: #define DEFAULT_CONFIG_ProfileDifferencePercent   (15)  // If 15% of the functions have different profile we will trigger a save.",
          "500: #define DEFAULT_CONFIG_Intl                    (true)",
          "501: #define DEFAULT_CONFIG_IntlBuiltIns            (true)",
          "504: #define DEFAULT_CONFIG_ES6                     (true)  // master flag to gate all P0-spec-test compliant ES6 features",
          "507: #define DEFAULT_CONFIG_CollectGarbage          (false)",
          "510: #define DEFAULT_CONFIG_ES6Species              (true)",
          "511: #define DEFAULT_CONFIG_ES6Classes              (true)",
          "512: #define DEFAULT_CONFIG_ES6DateParseFix         (true)",
          "513: #define DEFAULT_CONFIG_ES6DefaultArgs          (true)",
          "514: #define DEFAULT_CONFIG_ES6Destructuring        (true)",
          "515: #define DEFAULT_CONFIG_ES6ForLoopSemantics     (true)",
          "516: #define DEFAULT_CONFIG_ES6FunctionName         (true)",
          "517: #ifdef COMPILE_DISABLE_ES6FunctionNameFull",
          "519:     #define DEFAULT_CONFIG_ES6FunctionNameFull     (false)",
          "520: #else",
          "521:     #define DEFAULT_CONFIG_ES6FunctionNameFull     (false)",
          "522: #endif",
          "523: #define DEFAULT_CONFIG_ES6Generators           (true)",
          "524: #define DEFAULT_CONFIG_ES6IsConcatSpreadable   (true)",
          "525: #define DEFAULT_CONFIG_ES6Math                 (true)",
          "526: #ifdef COMPILE_DISABLE_ES6Module",
          "528:     #define DEFAULT_CONFIG_ES6Module               (false)",
          "529: #else",
          "530:     #define DEFAULT_CONFIG_ES6Module               (false)",
          "531: #endif",
          "532: #define DEFAULT_CONFIG_ES6Object               (true)",
          "533: #define DEFAULT_CONFIG_ES6Number               (true)",
          "534: #define DEFAULT_CONFIG_ES6ObjectLiterals       (true)",
          "535: #define DEFAULT_CONFIG_ES6Promise              (true)",
          "536: #define DEFAULT_CONFIG_ES6Proxy                (true)",
          "537: #define DEFAULT_CONFIG_ES6Rest                 (true)",
          "538: #define DEFAULT_CONFIG_ES6Spread               (true)",
          "539: #define DEFAULT_CONFIG_ES6String               (true)",
          "540: #define DEFAULT_CONFIG_ES6StringPrototypeFixes (true)",
          "541: #ifdef COMPILE_DISABLE_ES6PrototypeChain",
          "543:     #define DEFAULT_CONFIG_ES6PrototypeChain       (false)",
          "544: #else",
          "545:     #define DEFAULT_CONFIG_ES6PrototypeChain       (false)",
          "546: #endif",
          "547: #define DEFAULT_CONFIG_ES6ToPrimitive          (true)",
          "548: #define DEFAULT_CONFIG_ES6ToLength             (true)",
          "549: #define DEFAULT_CONFIG_ES6ToStringTag          (true)",
          "550: #define DEFAULT_CONFIG_ES6Unicode              (true)",
          "551: #define DEFAULT_CONFIG_ES6UnicodeVerbose       (true)",
          "552: #define DEFAULT_CONFIG_ES6Unscopables          (true)",
          "553: #define DEFAULT_CONFIG_ES6RegExSticky          (true)",
          "554: #ifdef COMPILE_DISABLE_ES6RegExPrototypeProperties",
          "556:     #define DEFAULT_CONFIG_ES6RegExPrototypeProperties (false)",
          "557: #else",
          "558:     #define DEFAULT_CONFIG_ES6RegExPrototypeProperties (false)",
          "559: #endif",
          "560: #ifdef COMPILE_DISABLE_ES6RegExSymbols",
          "562:     #define DEFAULT_CONFIG_ES6RegExSymbols         (false)",
          "563: #else",
          "564:     #define DEFAULT_CONFIG_ES6RegExSymbols         (false)",
          "565: #endif",
          "566: #define DEFAULT_CONFIG_ES6HasInstance          (true)",
          "567: #ifdef COMPILE_DISABLE_ArrayBufferTransfer",
          "569:     #define DEFAULT_CONFIG_ArrayBufferTransfer     (false)",
          "570: #else",
          "571:     #define DEFAULT_CONFIG_ArrayBufferTransfer     (false)",
          "572: #endif",
          "573: #define DEFAULT_CONFIG_ES7AsyncAwait           (true)",
          "574: #define DEFAULT_CONFIG_ES7ExponentionOperator  (true)",
          "575: #define DEFAULT_CONFIG_ES7TrailingComma        (true)",
          "576: #define DEFAULT_CONFIG_ES7ValuesEntries        (true)",
          "577: #define DEFAULT_CONFIG_ESObjectGetOwnPropertyDescriptors (true)",
          "579: #ifdef COMPILE_DISABLE_ESSharedArrayBuffer",
          "580: #define DEFAULT_CONFIG_ESSharedArrayBuffer     (false)",
          "581: #else",
          "582: #define DEFAULT_CONFIG_ESSharedArrayBuffer     (false)",
          "583: #endif",
          "584: #define DEFAULT_CONFIG_ES6Verbose              (false)",
          "585: #define DEFAULT_CONFIG_ES6All                  (false)",
          "588: #define DEFAULT_CONFIG_AsyncDebugging           (true)",
          "589: #define DEFAULT_CONFIG_TraceAsyncDebugCalls     (false)",
          "590: #define DEFAULT_CONFIG_ForcePostLowerGlobOptInstrString (false)",
          "591: #define DEFAULT_CONFIG_EnumerateSpecialPropertiesInDebugger (true)",
          "592: #endif",
          "594: #define DEFAULT_CONFIG_MaxJITFunctionBytecodeSize (120000)",
          "596: #define DEFAULT_CONFIG_JitQueueThreshold      (6)",
          "598: #define DEFAULT_CONFIG_FullJitRequeueThreshold (25)     // Minimum number of times a function needs to be executed before it is re-added to the jit queue",
          "600: #define DEFAULT_CONFIG_MinTemplatizedJitRunCount      (100)     // Minimum number of times a function needs to be interpreted before it is jitted",
          "601: #define DEFAULT_CONFIG_MinAsmJsInterpreterRunCount      (10)     // Minimum number of times a function needs to be Asm interpreted before it is jitted",
          "602: #define DEFAULT_CONFIG_MinTemplatizedJitLoopRunCount      (500)     // Minimum number of times a function needs to be interpreted before it is jitted",
          "603: #define DEFAULT_CONFIG_MaxTemplatizedJitRunCount      (-1)     // Maximum number of times a function can be TJ before it is jitted",
          "604: #define DEFAULT_CONFIG_MaxAsmJsInterpreterRunCount      (-1)     // Maximum number of times a function can be Asm interpreted before it is jitted",
          "608: #define DEFAULT_CONFIG_AutoProfilingInterpreter0Limit (12)",
          "609: #define DEFAULT_CONFIG_ProfilingInterpreter0Limit (4)",
          "610: #define DEFAULT_CONFIG_AutoProfilingInterpreter1Limit (0)",
          "611: #define DEFAULT_CONFIG_SimpleJitLimit (132)",
          "612: #define DEFAULT_CONFIG_ProfilingInterpreter1Limit (12)",
          "615: #define DEFAULT_CONFIG_AutoProfilingInterpreterLimit_OldSimpleJit (80)",
          "616: #define DEFAULT_CONFIG_SimpleJitLimit_OldSimpleJit (25)",
          "618: #define DEFAULT_CONFIG_MinProfileIterations (16)",
          "619: #define DEFAULT_CONFIG_MinProfileIterations_OldSimpleJit (25)",
          "620: #define DEFAULT_CONFIG_MinSimpleJitIterations (16)",
          "621: #define DEFAULT_CONFIG_NewSimpleJit (false)",
          "623: #define DEFAULT_CONFIG_MaxLinearIntCaseCount     (3)       // Maximum number of cases (in switch statement) for which instructions can be generated linearly.",
          "624: #define DEFAULT_CONFIG_MaxSingleCharStrJumpTableRatio  (2)       // Maximum single char string jump table size as multiples of the actual case arm",
          "625: #define DEFAULT_CONFIG_MaxSingleCharStrJumpTableSize  (128)       // Maximum single char string jump table size",
          "626: #define DEFAULT_CONFIG_MinSwitchJumpTableSize   (9)     // Minimum number of case target entries in the jump table(this may also include values that are missing in the consecutive set of integer case arms)",
          "627: #define DEFAULT_CONFIG_SwitchOptHolesThreshold  (50)     // Maximum percentage of holes (missing case values in a switch statement) with which a jump table can be created",
          "628: #define DEFAULT_CONFIG_MaxLinearStringCaseCount (4)     // Maximum number of String cases (in switch statement) for which instructions can be generated linearly.",
          "630: #define DEFAULT_CONFIG_MinDeferredFuncTokenCount (20)   // Minimum size in tokens of a defer-parsed function",
          "632: #if DBG",
          "633: #define DEFAULT_CONFIG_SkipFuncCountForBailOnNoProfile (0) //Initial Number of functions in a func body to be skipped from forcibly inserting BailOnNoProfile.",
          "634: #endif",
          "635: #define DEFAULT_CONFIG_BailOnNoProfileLimit    200      // The limit of bailout on no profile info before triggering a rejit",
          "636: #define DEFAULT_CONFIG_BailOnNoProfileRejitLimit (50)   // The limit of bailout on no profile info before disable all the no profile bailouts",
          "637: #define DEFAULT_CONFIG_CallsToBailoutsRatioForRejit 10   // Ratio of function calls to bailouts above which a rejit is considered",
          "638: #define DEFAULT_CONFIG_LoopIterationsToBailoutsRatioForRejit 50 // Ratio of loop iteration count to bailouts above which a rejit of the loop body is considered",
          "639: #define DEFAULT_CONFIG_MinBailOutsBeforeRejit 2         // Minimum number of bailouts for a single bailout record after which a rejit is considered",
          "640: #define DEFAULT_CONFIG_MinBailOutsBeforeRejitForLoops 2         // Minimum number of bailouts for a single bailout record after which a rejit is considered",
          "641: #define DEFAULT_CONFIG_RejitMaxBailOutCount 500         // Maximum number of bailouts for a single bailout record after which rejit is forced.",
          "644: #define DEFAULT_CONFIG_Sse                  (-1)",
          "646: #define DEFAULT_CONFIG_DeletedPropertyReuseThreshold (32)",
          "647: #define DEFAULT_CONFIG_BigDictionaryTypeHandlerThreshold (0xffff)",
          "648: #define DEFAULT_CONFIG_ForceStringKeyedSimpleDictionaryTypeHandler (false)",
          "649: #define DEFAULT_CONFIG_TypeSnapshotEnumeration (true)",
          "650: #define DEFAULT_CONFIG_EnumerationCompat    (false)",
          "651: #define DEFAULT_CONFIG_ConcurrentRuntime (false)",
          "652: #define DEFAULT_CONFIG_PrimeRecycler     (false)",
          "653: #if defined(_WIN32)",
          "654: #define DEFAULT_CONFIG_PrivateHeap       (true)",
          "655: #else // defined(_WIN32)",
          "657: #define DEFAULT_CONFIG_PrivateHeap       (false)",
          "658: #endif // defined(_WIN32)",
          "659: #define DEFAULT_CONFIG_DisableRentalThreading (false)",
          "660: #define DEFAULT_CONFIG_DisableDebugObject (false)",
          "661: #define DEFAULT_CONFIG_DumpHeap (false)",
          "662: #define DEFAULT_CONFIG_PerfHintLevel (1)",
          "663: #define DEFAULT_CONFIG_OOPJITMissingOpts (true)",
          "664: #define DEFAULT_CONFIG_OOPCFGRegistration (true)",
          "665: #define DEFAULT_CONFIG_RPCFailFastWait (3000)",
          "667: #define DEFAULT_CONFIG_FailFastIfDisconnectedDelegate    (false)",
          "669: #define DEFAULT_CONFIG_IsolatePrototypes    (true)",
          "670: #define DEFAULT_CONFIG_ChangeTypeOnProto    (true)",
          "671: #define DEFAULT_CONFIG_FixPropsOnPathTypes    (true)",
          "672: #define DEFAULT_CONFIG_BailoutTraceFilter (-1)",
          "673: #define DEFAULT_CONFIG_TempMin    (0)",
          "674: #define DEFAULT_CONFIG_TempMax    (INT_MAX)",
          "676: #define DEFAULT_CONFIG_LibraryStackFrame            (true)",
          "677: #define DEFAULT_CONFIG_LibraryStackFrameDebugger    (false)",
          "679: #define DEFAULT_CONFIG_FuncObjectInlineCacheThreshold   (2) // Maximum number of inline caches a function body may have to allow for inline caches to be allocated on the function object.",
          "680: #define DEFAULT_CONFIG_ShareInlineCaches (true)",
          "681: #define DEFAULT_CONFIG_InlineCacheInvalidationListCompactionThreshold (4)",
          "682: #define DEFAULT_CONFIG_ConstructorCacheInvalidationThreshold (500)",
          "684: #define DEFAULT_CONFIG_InMemoryTrace                (false)",
          "685: #define DEFAULT_CONFIG_InMemoryTraceBufferSize      (1024)",
          "686: #define DEFAULT_CONFIG_RichTraceFormat              (false)",
          "687: #define DEFAULT_CONFIG_TraceWithStack               (false)",
          "689: #define DEFAULT_CONFIG_InjectPartiallyInitializedInterpreterFrameError (0)",
          "690: #define DEFAULT_CONFIG_InjectPartiallyInitializedInterpreterFrameErrorType (0)",
          "692: #define DEFAULT_CONFIG_InvalidateSolutionContextsForGetStructure (true)",
          "694: #define DEFAULT_CONFIG_DeferLoadingAvailableSource  (false)",
          "695: #ifdef ENABLE_PROJECTION",
          "696: #define DEFAULT_CONFIG_NoWinRTFastSig       (false)",
          "697: #define DEFAULT_CONFIG_TargetWinRTVersion   (1)",
          "698: #define DEFAULT_CONFIG_WinRTDelegateInterfaces      (false)",
          "699: #define DEFAULT_CONFIG_WinRTAdaptiveApps            (true)",
          "700: #endif",
          "702: #define DEFAULT_CONFIG_RecyclerForceMarkInterior (false)",
          "704: #define DEFAULT_CONFIG_MemProtectHeap (false)",
          "706: #define DEFAULT_CONFIG_InduceCodeGenFailure (30) // When -InduceCodeGenFailure is passed in, 30% of JIT allocations will fail",
          "708: #define DEFAULT_CONFIG_SkipSplitWhenResultIgnored (false)",
          "710: #define DEFAULT_CONFIG_MinMemOpCount (16U)",
          "712: #if ENABLE_COPYONACCESS_ARRAY",
          "713: #define DEFAULT_CONFIG_MaxCopyOnAccessArrayLength (32U)",
          "714: #define DEFAULT_CONFIG_MinCopyOnAccessArrayLength (5U)",
          "715: #define DEFAULT_CONFIG_CopyOnAccessArraySegmentCacheSize (16U)",
          "716: #endif",
          "718: #if defined(_M_IX86) || defined(_M_X64)",
          "719: #define DEFAULT_CONFIG_LoopAlignNopLimit (6)",
          "720: #endif",
          "722: #if defined(_M_IX86) || defined(_M_X64)",
          "723: #define DEFAULT_CONFIG_ZeroMemoryWithNonTemporalStore (true)",
          "724: #endif",
          "726: #define DEFAULT_CONFIG_StrictWriteBarrierCheck  (false)",
          "727: #define DEFAULT_CONFIG_KeepRecyclerTrackData  (false)",
          "728: #define DEFAULT_CONFIG_EnableBGFreeZero (true)",
          "730: #if !GLOBAL_ENABLE_WRITE_BARRIER",
          "731: #define DEFAULT_CONFIG_ForceSoftwareWriteBarrier  (false)",
          "732: #else",
          "733: #define DEFAULT_CONFIG_ForceSoftwareWriteBarrier  (true)",
          "734: #endif",
          "735: #define DEFAULT_CONFIG_WriteBarrierTest (false)",
          "736: #define DEFAULT_CONFIG_VerifyBarrierBit  (false)",
          "738: #define TraceLevel_Error        (1)",
          "739: #define TraceLevel_Warning      (2)",
          "740: #define TraceLevel_Info         (3)",
          "742: #define TEMP_ENABLE_FLAG_FOR_APPX_BETA_ONLY 1",
          "744: #define INMEMORY_CACHE_MAX_URL                    (5)             // This is the max number of URLs that the in-memory profile cache can hold.",
          "745: #define INMEMORY_CACHE_MAX_PROFILE_MANAGER        (50)            // This is the max number of dynamic scripts that the in-memory profile cache can have",
          "747: #ifdef SUPPORT_INTRUSIVE_TESTTRACES",
          "748: #define INTRUSIVE_TESTTRACE_PolymorphicInlineCache (1)",
          "749: #endif",
          "765: #if defined(FLAG) || defined(FLAG_REGOVR_EXP)",
          "767: #ifndef FLAG",
          "768: #define FLAG(...)",
          "769: #endif",
          "771: #ifndef FLAG_REGOVR_ASMJS",
          "772: #define FLAG_REGOVR_ASMJS FLAG",
          "773: #endif",
          "775: #ifndef FLAG_REGOVR_EXP",
          "776: #define FLAG_REGOVR_EXP FLAG",
          "777: #endif",
          "780: #ifdef ENABLE_DEBUG_CONFIG_OPTIONS",
          "783: #define FLAGNR(Type, Name, String, Default)                 FLAG(Type, Name, String, Default, NoParent, FALSE)",
          "786: #ifndef FLAGNRA",
          "787:     #define FLAGNRA(Type, Name, Acronym, String, Default) \\",
          "788:         FLAGNR(Type, Name, String, Default) \\",
          "789:         FLAGNR(Type, Acronym, String, Default)",
          "790: #endif",
          "793: #define FLAGPNR(Type, ParentName, Name, String, Default)    FLAG(Type, Name, String, Default, ParentName, FALSE)",
          "796: #define FLAGNRC(Type, Name, String, Default)                FLAG(Type, Name, String, Default, NoParent, TRUE)",
          "798: #else",
          "799: #define FLAGNR(Type, Name, String, Default)",
          "801: #ifdef FLAGNRA",
          "802:     #undef FLAGNRA",
          "803: #endif",
          "804: #define FLAGNRA(Type, Name, Acronym, String, Default)",
          "806: #define FLAGPNR(Type, ParentName, Name, String, Default)",
          "807: #define FLAGNRC(Type, Name, String, Default)",
          "808: #endif",
          "811: #define FLAGPR(Type, ParentName, Name, String, Default)     FLAG(Type, Name, String, Default, ParentName, FALSE)",
          "812: #define FLAGR(Type, Name, String, Default)                  FLAG(Type, Name, String, Default, NoParent, FALSE)",
          "815: #ifndef FLAGPRA",
          "816: #define FLAGPRA(Type, ParentName, Name, Acronym, String, Default) \\",
          "817:         FLAG_REGOVR_EXP(Type, Name, String, Default, ParentName, FALSE) \\",
          "818:         FLAGNR(Type, Acronym, String, Default)",
          "819: #endif",
          "823: #define FLAGPR_REGOVR_ASMJS(Type, ParentName, Name, String, Default) FLAG_REGOVR_ASMJS(Type, Name, String, Default, ParentName, FALSE)",
          "824: #define FLAGPR_REGOVR_EXP(Type, ParentName, Name, String, Default)   FLAG_REGOVR_EXP(Type, Name, String, Default, ParentName, FALSE)",
          "827: #ifndef FLAGRA",
          "828:     #define FLAGRA(Type, Name, Acronym, String, Default) \\",
          "829:         FLAGR(Type, Name, String, Default) \\",
          "830:         FLAGNR(Type, Acronym, String, Default)",
          "831: #endif",
          "835: #if DBG",
          "836: FLAGNR(Boolean, ArrayValidate         , \"Validate each array for valid elements (default: false)\", false)",
          "837: FLAGNR(Boolean, MemOpMissingValueValidate, \"Validate Missing Value Tracking on memset/memcopy\", false)",
          "838: #endif",
          "839: #ifdef ARENA_MEMORY_VERIFY",
          "840: FLAGNR(Boolean, ArenaNoFreeList       , \"Do not free list in arena\", false)",
          "841: FLAGNR(Boolean, ArenaNoPageReuse      , \"Do not reuse page in arena\", false)",
          "842: FLAGNR(Boolean, ArenaUseHeapAlloc     , \"Arena use heap to allocate memory instead of page allocator\", false)",
          "843: #endif",
          "844: FLAGNR(Boolean, ValidateInlineStack, \"Does a stack walk on helper calls to validate inline stack is correctly restored\", false)",
          "845: FLAGNR(Boolean, AsmDiff               , \"Dump the IR without memory locations and varying parameters.\", false)",
          "846: FLAGNR(String,  AsmDumpMode           , \"Dump the final assembly to a file without memory locations and varying parameters\\n\\t\\t\\t\\t\\tThe 'filename' is the file where the assembly will be dumped. Dump to console if no file is specified\", nullptr)",
          "847: FLAGR (Boolean, Asmjs                 , \"Enable Asmjs\", DEFAULT_CONFIG_ASMJS)",
          "848: FLAGNR(Boolean, AsmJsStopOnError      , \"Stop execution on any AsmJs validation errors\", DEFAULT_CONFIG_AsmJsStopOnError)",
          "849: FLAGNR(Boolean, AsmJsEdge             , \"Enable asm.js features which may have backward incompatible changes or not validate on old demos\", DEFAULT_CONFIG_AsmJsEdge)",
          "850: FLAGNR(Boolean, WasmI64               , \"Enable Int64 testing for WebAssembly. ArgIns can be [number,string,{low:number,high:number}]. Return values will be {low:number,high:number}\", DEFAULT_CONFIG_WasmI64)",
          "851: FLAGNR(Boolean, WasmFastArray         , \"Enable fast array implementation for WebAssembly\", DEFAULT_CONFIG_WasmFastArray)",
          "853: #ifndef COMPILE_DISABLE_Simdjs",
          "854:     #define COMPILE_DISABLE_Simdjs 0",
          "855: #endif",
          "856: FLAGPR_REGOVR_EXP(Boolean, ES6, Simdjs, \"Enable Simdjs\", DEFAULT_CONFIG_SIMDJS)",
          "858: FLAGR(Boolean, Simd128TypeSpec, \"Enable type-specialization of Simd128 symbols\", false)",
          "860: FLAGNR(Boolean, AssertBreak           , \"Debug break on assert\", false)",
          "861: FLAGNR(Boolean, AssertPopUp           , \"Pop up asserts (default: false)\", false)",
          "862: FLAGNR(Boolean, AssertIgnore          , \"Ignores asserts if set\", false)",
          "863: FLAGNR(Boolean, AsyncDebugging, \"Enable async debugging feature (default: false)\", DEFAULT_CONFIG_AsyncDebugging)",
          "864: FLAGNR(Number,  BailOnNoProfileLimit,   \"The limit of bailout on no profile info before triggering a rejit\", DEFAULT_CONFIG_BailOnNoProfileLimit)",
          "865: FLAGNR(Number,  BailOnNoProfileRejitLimit, \"The limit of bailout on no profile info before we disable the bailouts\", DEFAULT_CONFIG_BailOnNoProfileRejitLimit)",
          "866: FLAGNR(Boolean, BaselineMode          , \"Dump only stable content that can be used for baseline comparison\", false)",
          "867: FLAGNR(String,  DumpOnCrash           , \"generate heap dump on asserts or unhandled exception if set\", nullptr)",
          "868: FLAGNR(String,  FullMemoryDump        , \"Will perform a full memory dump when -DumpOnCrash is supplied.\", nullptr)",
          "869: #ifdef BAILOUT_INJECTION",
          "870: FLAGR (NumberPairSet, BailOut         , \"Source location to insert BailOut\", )",
          "871: FLAGNR(Boolean, BailOutAtEveryLine    , \"Inserts BailOut at every line of source (default: false)\", false)",
          "872: FLAGNR(Boolean, BailOutAtEveryByteCode, \"Inserts BailOut at every Byte code (default: false)\", false)",
          "873: FLAGNR(Boolean, BailOutAtEveryImplicitCall, \"Force generating implicit call bailout even when we don't need it\", false)",
          "874: FLAGR (NumberSet, BailOutByteCode     , \"Byte code location to insert BailOut. Use with -prejit only\", )",
          "875: #endif",
          "876: FLAGNR(Boolean, Benchmark             , \"Disable security code which introduce variability in benchmarks\", false)",
          "877: FLAGR (Boolean, BgJit                 , \"Background JIT. Disable to force heuristic-based foreground JITting. (default: true)\", true)",
          "878: FLAGNR(Number,  BgJitDelay            , \"Delay to wait for speculative jitting before starting script execution\", DEFAULT_CONFIG_BgJitDelay)",
          "879: FLAGNR(Number,  BgJitDelayFgBuffer    , \"When speculatively jitting in the foreground thread, do so for (BgJitDelay - BgJitDelayBuffer) milliseconds\", DEFAULT_CONFIG_BgJitDelayFgBuffer)",
          "880: FLAGNR(Number,  BgJitPendingFuncCap   , \"Disable delay if pending function count larger then cap\", DEFAULT_CONFIG_BgJitPendingFuncCap)",
          "882: FLAGNR(Boolean, CreateFunctionProxy   , \"Create function proxies instead of full function bodies\", DEFAULT_CONFIG_CreateFunctionProxy)",
          "883: FLAGNR(Boolean, HybridFgJit           , \"When background JIT is enabled, enable jitting in the foreground based on heuristics. This flag is only effective when OptimizeForManyInstances is disabled (UI threads).\", DEFAULT_CONFIG_HybridFgJit)",
          "884: FLAGNR(Number,  HybridFgJitBgQueueLengthThreshold, \"The background job queue length must exceed this threshold to consider jitting in the foreground\", DEFAULT_CONFIG_HybridFgJitBgQueueLengthThreshold)",
          "885: FLAGNR(Boolean, BytecodeHist          , \"Provide a histogram of the bytecodes run by the script. (NoNative required).\", false)",
          "886: FLAGNR(Boolean, CurrentSourceInfo     , \"Enable IASD get current script source info\", DEFAULT_CONFIG_CurrentSourceInfo)",
          "887: FLAGNR(Boolean, CFGLog                , \"Log CFG checks\", false)",
          "888: FLAGNR(Boolean, CheckAlignment        , \"Insert checks in the native code to verify 8-byte alignment of stack\", false)",
          "889: FLAGNR(Boolean, CheckEmitBufferPermissions, \"Check JIT code buffers at commit and decommit time to ensure no PAGE_EXECUTE_READWRITE pages.\", false)",
          "890: #ifdef CHECK_MEMORY_LEAK",
          "891: FLAGR (Boolean, CheckMemoryLeak       , \"Check for heap memory leak\", false)",
          "892: FLAGR (String,  DumpOnLeak            , \"Create a dump on failed memory leak check\", nullptr)",
          "893: #endif",
          "894: FLAGNR(Boolean, CheckOpHelpers        , \"Verify opHelper labels in the JIT are set properly\", false)",
          "895: FLAGNR(Boolean, CloneInlinedPolymorphicCaches, \"Clones polymorphic inline caches in inlined functions\", DEFAULT_CONFIG_CloneInlinedPolymorphicCaches)",
          "896: FLAGNR(Boolean, ConcurrentRuntime     , \"Enable Concurrent GC and background JIT when creating runtime\", DEFAULT_CONFIG_ConcurrentRuntime)",
          "897: #if CONFIG_CONSOLE_AVAILABLE",
          "898: FLAGNR(Boolean, Console               , \"Create console window in GUI app\", false)",
          "899: FLAGNR(Boolean, ConsoleExitPause      , \"Pause on exit when a console window is created in GUI app\", false)",
          "900: #endif",
          "901: FLAGNR(Number,  ConstructorInlineThreshold      , \"Maximum size in bytecodes of a constructor inline candidate with monomorphic field access\", DEFAULT_CONFIG_ConstructorInlineThreshold)",
          "902: FLAGNR(Number,  ConstructorCallsRequiredToFinalizeCachedType, \"Number of calls to a constructor required before the type cached in the constructor cache is finalized\", DEFAULT_CONFIG_ConstructorCallsRequiredToFinalizeCachedType)",
          "903: #ifdef SECURITY_TESTING",
          "904: FLAGNR(Boolean, CrashOnException      , \"Removes the top-level exception handler, allowing jc.exe to crash on an unhandled exception.  No effect on IE. (default: false)\", false)",
          "905: #endif",
          "906: FLAGNR(Boolean, Debug                 , \"Disable phases (layout, security code, etc) which makes JIT output harder to debug\", false)",
          "907: FLAGNR(NumberSet,  DebugBreak         , \"Index of the function where you want to break\", )",
          "908: FLAGNR(Boolean, DebugWindow           , \"Send console output to debugger window\", false)",
          "909: FLAGNR(Boolean, DeferNested           , \"Enable deferred parsing of nested function\", DEFAULT_CONFIG_DeferNested)",
          "910: FLAGNR(Boolean, DeferTopLevelTillFirstCall      , \"Enable tracking of deferred top level functions in a script file, until the first function of the script context is parsed.\", DEFAULT_CONFIG_DeferTopLevelTillFirstCall)",
          "911: FLAGNR(Number,  DeferParse            , \"Minimum size of defer-parsed script (non-zero only: use /nodeferparse do disable\", 0)",
          "912: FLAGNR(Boolean, DirectCallTelemetryStats, \"Enables logging stats for direct call telemetry\", DEFAULT_CONFIG_DirectCallTelemetryStats)",
          "913: FLAGNR(Boolean, DisableArrayBTree     , \"Disable creation of BTree for Arrays\", false)",
          "914: FLAGNR(Boolean, DisableRentalThreading, \"Disable rental threading when creating runtime\", DEFAULT_CONFIG_DisableRentalThreading)",
          "915: FLAGNR(Boolean, DisableVTuneSourceLineInfo, \"Disable VTune Source line info for Dynamic JITted code\", false)",
          "916: FLAGNR(Boolean, DisplayMemStats, \"Display memory usage statistics\", false)",
          "917: FLAGNR(Phases,  Dump                  , \"What All to dump\", )",
          "918: #ifdef DUMP_FRAGMENTATION_STATS",
          "919: FLAGR (Boolean, DumpFragmentationStats, \"Dump bucket state after every GC\", false)",
          "920: #endif",
          "921: FLAGNR(Boolean, DumpIRAddresses,   \"Print addresses in IR dumps\", false)",
          "922: FLAGNR(Boolean, DumpLineNoInColor, \"Print the source code in high intensity color for better readability\", false)",
          "923: #ifdef RECYCLER_DUMP_OBJECT_GRAPH",
          "924: FLAGR (Boolean, DumpObjectGraphOnExit , \"Dump object graph on recycler destructor\", false)",
          "925: FLAGR (Boolean, DumpObjectGraphOnCollect, \"Dump object graph on recycler destructor\", false)",
          "926: #endif",
          "927: FLAGNR(Boolean, DumpEvalStringOnRemoval, \"Dumps an eval string when its being removed from the eval map\", false)",
          "928: FLAGNR(Boolean, DumpObjectGraphOnEnum, \"Dump object graph on recycler heap enumeration\", false)",
          "929: #ifdef DYNAMIC_PROFILE_STORAGE",
          "930: FLAGNRA(String, DynamicProfileCache   , Dpc, \"File to cache dynamic profile information\", nullptr)",
          "931: FLAGNR(String,  DynamicProfileCacheDir, \"Directory to cache dynamic profile information\", nullptr)",
          "932: FLAGNRA(String, DynamicProfileInput   , Dpi, \"Read only file containing dynamic profile information\", nullptr)",
          "933: #endif",
          "934: #ifdef EDIT_AND_CONTINUE",
          "935: FLAGNR(Boolean, EditTest              , \"Enable edit and continue test tools\", false)",
          "936: #endif",
          "937: FLAGNR(Boolean, WininetProfileCache, \"Use the WININET cache to save the profile information\", DEFAULT_CONFIG_WininetProfileCache)",
          "938: FLAGNR(Boolean, NoDynamicProfileInMemoryCache, \"Enable in-memory cache for dynamic sources\", false)",
          "939: FLAGNR(Boolean, ProfileBasedSpeculativeJit, \"Enable dynamic profile based speculative JIT\", DEFAULT_CONFIG_ProfileBasedSpeculativeJit)",
          "940: FLAGNR(Number,  ProfileBasedSpeculationCap, \"In the presence of dynamic profile speculative JIT is capped to this many bytecode instructions\", DEFAULT_CONFIG_ProfileBasedSpeculationCap)",
          "941: #ifdef DYNAMIC_PROFILE_MUTATOR",
          "942: FLAGNR(String,  DynamicProfileMutatorDll , \"Path of the mutator DLL\", _u(\"DynamicProfileMutatorImpl.dll\"))",
          "943: FLAGNR(String,  DynamicProfileMutator , \"Type of local, temp, return, param, loop implicit flag and implicit flag. \\n\\t\\t\\t\\t\\ti.e local=LikelyArray_NoMissingValues_NonInts_NonFloats;temp=Int8Array;param=LikelyNumber;return=LikelyString;loopimplicitflag=ImplicitCall_ToPrimitive;implicitflag=ImplicitCall_None\\n\\t\\t\\t\\t\\tor pass DynamicProfileMutator:random\\n\\t\\t\\t\\t\\tSee DynamicProfileInfo.h for enum values\", nullptr)",
          "944: #endif",
          "945: FLAGNR(Boolean, ExecuteByteCodeBufferReturnsInvalidByteCode, \"Serialized byte code execution always returns SCRIPT_E_INVALID_BYTECODE\", false)",
          "946: FLAGR(Number, ExpirableCollectionGCCount, \"Number of GCs during which Expirable object profiling occurs\", DEFAULT_CONFIG_ExpirableCollectionGCCount)",
          "947: FLAGR (Number,  ExpirableCollectionTriggerThreshold, \"Threshold at which Expirable Object Collection is triggered (In Percentage)\", DEFAULT_CONFIG_ExpirableCollectionTriggerThreshold)",
          "948: FLAGR(Boolean, SkipSplitOnNoResult, \"If the result of Regex split isn't used, skip executing the regex. (Perf optimization)\", DEFAULT_CONFIG_SkipSplitWhenResultIgnored)",
          "949: #ifdef TEST_ETW_EVENTS",
          "950: FLAGNR(String,  TestEtwDll            , \"Path of the TestEtwEventSink DLL\", nullptr)",
          "951: #endif",
          "953: FLAGNR(Boolean, CollectGarbage        , \"Enable CollectGarbage API\", DEFAULT_CONFIG_CollectGarbage)",
          "955: FLAGR (Boolean, Intl                  , \"Intl object support\", DEFAULT_CONFIG_Intl)",
          "956: FLAGNR(Boolean, IntlBuiltIns          , \"Intl built-in function support\", DEFAULT_CONFIG_IntlBuiltIns)",
          "961: FLAGR(Boolean, ES6                         , \"Enable ES6 stable features\",                        DEFAULT_CONFIG_ES6)",
          "964: FLAGNRC(Boolean, ES6All                    , \"Enable all ES6 features, both stable and unstable\", DEFAULT_CONFIG_ES6All)",
          "967: FLAGNRC(Boolean, ES6Experimental           , \"Enable all experimental features\",                  DEFAULT_CONFIG_ES6All)",
          "971: FLAGPR           (Boolean, ES6, ES6Species             , \"Enable ES6 '@@species' properties and built-in behaviors\" , DEFAULT_CONFIG_ES6Species)",
          "973: FLAGPR           (Boolean, ES6, ES7AsyncAwait          , \"Enable ES7 'async' and 'await' keywords\"                  , DEFAULT_CONFIG_ES7AsyncAwait)",
          "974: FLAGPR           (Boolean, ES6, ES6Classes             , \"Enable ES6 'class' and 'extends' keywords\"                , DEFAULT_CONFIG_ES6Classes)",
          "975: FLAGPR           (Boolean, ES6, ES6DateParseFix        , \"Enable ES6 Date.parse fixes\"                              , DEFAULT_CONFIG_ES6DateParseFix)",
          "976: FLAGPR           (Boolean, ES6, ES6DefaultArgs         , \"Enable ES6 Default Arguments\"                             , DEFAULT_CONFIG_ES6DefaultArgs)",
          "977: FLAGPR           (Boolean, ES6, ES6Destructuring       , \"Enable ES6 Destructuring\"                                 , DEFAULT_CONFIG_ES6Destructuring)",
          "978: FLAGPR           (Boolean, ES6, ES6ForLoopSemantics    , \"Enable ES6 for loop per iteration bindings\"               , DEFAULT_CONFIG_ES6ForLoopSemantics)",
          "979: FLAGPR           (Boolean, ES6, ES6FunctionName        , \"Enable ES6 function.name\"                                 , DEFAULT_CONFIG_ES6FunctionName)",
          "981: #ifndef COMPILE_DISABLE_ES6FunctionNameFull",
          "982:     #define COMPILE_DISABLE_ES6FunctionNameFull 0",
          "983: #endif",
          "984: FLAGPR_REGOVR_EXP(Boolean, ES6, ES6FunctionNameFull    , \"Enable ES6 Full function.name\"                            , DEFAULT_CONFIG_ES6FunctionNameFull)",
          "985: FLAGPR           (Boolean, ES6, ES6Generators          , \"Enable ES6 generators\"                                    , DEFAULT_CONFIG_ES6Generators)",
          "986: FLAGPR           (Boolean, ES6, ES7ExponentiationOperator, \"Enable ES7 exponentiation operator (**)\"                , DEFAULT_CONFIG_ES7ExponentionOperator)",
          "988: FLAGPR           (Boolean, ES6, ES7ValuesEntries       , \"Enable ES7 Object.values and Object.entries\"              , DEFAULT_CONFIG_ES7ValuesEntries)",
          "989: FLAGPR           (Boolean, ES6, ES7TrailingComma       , \"Enable ES7 trailing comma in function\"                    , DEFAULT_CONFIG_ES7TrailingComma)",
          "990: FLAGPR           (Boolean, ES6, ES6IsConcatSpreadable  , \"Enable ES6 isConcatSpreadable Symbol\"                     , DEFAULT_CONFIG_ES6IsConcatSpreadable)",
          "991: FLAGPR           (Boolean, ES6, ES6Math                , \"Enable ES6 Math extensions\"                               , DEFAULT_CONFIG_ES6Math)",
          "993: #ifndef COMPILE_DISABLE_ES6Module",
          "994:     #define COMPILE_DISABLE_ES6Module 0",
          "995: #endif",
          "996: FLAGPR_REGOVR_EXP(Boolean, ES6, ES6Module              , \"Enable ES6 Modules\"                                       , DEFAULT_CONFIG_ES6Module)",
          "997: FLAGPR           (Boolean, ES6, ES6Object              , \"Enable ES6 Object extensions\"                             , DEFAULT_CONFIG_ES6Object)",
          "998: FLAGPR           (Boolean, ES6, ES6Number              , \"Enable ES6 Number extensions\"                             , DEFAULT_CONFIG_ES6Number)",
          "999: FLAGPR           (Boolean, ES6, ES6ObjectLiterals      , \"Enable ES6 Object literal extensions\"                     , DEFAULT_CONFIG_ES6ObjectLiterals)",
          "1000: FLAGPR           (Boolean, ES6, ES6Promise             , \"Enable ES6 Promise feature\"                               , DEFAULT_CONFIG_ES6Promise)",
          "1001: FLAGPR           (Boolean, ES6, ES6Proxy               , \"Enable ES6 Proxy feature\"                                 , DEFAULT_CONFIG_ES6Proxy)",
          "1002: FLAGPR           (Boolean, ES6, ES6Rest                , \"Enable ES6 Rest parameters\"                               , DEFAULT_CONFIG_ES6Rest)",
          "1003: FLAGPR           (Boolean, ES6, ES6Spread              , \"Enable ES6 Spread support\"                                , DEFAULT_CONFIG_ES6Spread)",
          "1004: FLAGPR           (Boolean, ES6, ES6String              , \"Enable ES6 String extensions\"                             , DEFAULT_CONFIG_ES6String)",
          "1005: FLAGPR           (Boolean, ES6, ES6StringPrototypeFixes, \"Enable ES6 String.prototype fixes\"                        , DEFAULT_CONFIG_ES6StringPrototypeFixes)",
          "1007: #ifndef COMPILE_DISABLE_ES6PrototypeChain",
          "1008:     #define COMPILE_DISABLE_ES6PrototypeChain 0",
          "1009: #endif",
          "1010: FLAGPR_REGOVR_EXP(Boolean, ES6, ES6PrototypeChain      , \"Enable ES6 prototypes (Example: Date prototype is object)\", DEFAULT_CONFIG_ES6PrototypeChain)",
          "1011: FLAGPR           (Boolean, ES6, ES6ToPrimitive         , \"Enable ES6 ToPrimitive symbol\"                            , DEFAULT_CONFIG_ES6ToPrimitive)",
          "1012: FLAGPR           (Boolean, ES6, ES6ToLength            , \"Enable ES6 ToLength fixes\"                                , DEFAULT_CONFIG_ES6ToLength)",
          "1013: FLAGPR           (Boolean, ES6, ES6ToStringTag         , \"Enable ES6 ToStringTag symbol\"                            , DEFAULT_CONFIG_ES6ToStringTag)",
          "1014: FLAGPR           (Boolean, ES6, ES6Unicode             , \"Enable ES6 Unicode 6.0 extensions\"                        , DEFAULT_CONFIG_ES6Unicode)",
          "1015: FLAGPR           (Boolean, ES6, ES6UnicodeVerbose      , \"Enable ES6 Unicode 6.0 verbose failure output\"            , DEFAULT_CONFIG_ES6UnicodeVerbose)",
          "1016: FLAGPR           (Boolean, ES6, ES6Unscopables         , \"Enable ES6 With Statement Unscopables\"                    , DEFAULT_CONFIG_ES6Unscopables)",
          "1017: FLAGPR           (Boolean, ES6, ES6RegExSticky         , \"Enable ES6 RegEx sticky flag\"                             , DEFAULT_CONFIG_ES6RegExSticky)",
          "1019: #ifndef COMPILE_DISABLE_ES6RegExPrototypeProperties",
          "1020:     #define COMPILE_DISABLE_ES6RegExPrototypeProperties 0",
          "1021: #endif",
          "1022: FLAGPR_REGOVR_EXP(Boolean, ES6, ES6RegExPrototypeProperties, \"Enable ES6 properties on the RegEx prototype\"         , DEFAULT_CONFIG_ES6RegExPrototypeProperties)",
          "1024: #ifndef COMPILE_DISABLE_ES6RegExSymbols",
          "1025:     #define COMPILE_DISABLE_ES6RegExSymbols 0",
          "1026: #endif",
          "1027: FLAGPR_REGOVR_EXP(Boolean, ES6, ES6RegExSymbols        , \"Enable ES6 RegExp symbols\"                                , DEFAULT_CONFIG_ES6RegExSymbols)",
          "1029: FLAGPR           (Boolean, ES6, ES6HasInstance         , \"Enable ES6 @@hasInstance symbol\"                          , DEFAULT_CONFIG_ES6HasInstance)",
          "1030: FLAGPR           (Boolean, ES6, ES6Verbose             , \"Enable ES6 verbose trace\"                                 , DEFAULT_CONFIG_ES6Verbose)",
          "1032: #ifndef COMPILE_DISABLE_ArrayBufferTransfer",
          "1033:     #define COMPILE_DISABLE_ArrayBufferTransfer 0",
          "1034: #endif",
          "1035: FLAGPR_REGOVR_EXP(Boolean, ES6, ArrayBufferTransfer    , \"Enable ArrayBuffer.transfer\"                              , DEFAULT_CONFIG_ArrayBufferTransfer)",
          "1037: FLAGPR           (Boolean, ES6, ESObjectGetOwnPropertyDescriptors, \"Enable Object.getOwnPropertyDescriptors\"        , DEFAULT_CONFIG_ESObjectGetOwnPropertyDescriptors)",
          "1039: #ifndef COMPILE_DISABLE_ESSharedArrayBuffer",
          "1040:     #define COMPILE_DISABLE_ESSharedArrayBuffer 0",
          "1041: #endif",
          "1042: FLAGPRA          (Boolean, ES6, ESSharedArrayBuffer    , sab     , \"Enable SharedArrayBuffer\"                       , DEFAULT_CONFIG_ESSharedArrayBuffer)",
          "1046: #ifndef COMPILE_DISABLE_Wasm",
          "1047: #define COMPILE_DISABLE_Wasm 0",
          "1048: #endif",
          "1049: FLAGPR_REGOVR_EXP(Boolean, ES6, Wasm, \"Enable WebAssembly\", DEFAULT_CONFIG_WASM)",
          "1051: #ifdef ENABLE_PROJECTION",
          "1052: FLAGNR(Boolean, WinRTDelegateInterfaces , \"Treat WinRT Delegates as Interfaces when determining their resolvability.\", DEFAULT_CONFIG_WinRTDelegateInterfaces)",
          "1053: FLAGR(Boolean, WinRTAdaptiveApps        , \"Enable the adaptive apps feature, allowing for variable projection.\"      , DEFAULT_CONFIG_WinRTAdaptiveApps)",
          "1054: #endif",
          "1057: FLAGNR(Boolean, JitES6Generators        , \"Enable JITing of ES6 generators\", false)",
          "1059: FLAGNR(Boolean, FastLineColumnCalculation, \"Enable fast calculation of line/column numbers from the source.\", DEFAULT_CONFIG_FastLineColumnCalculation)",
          "1060: FLAGR (String,  Filename              , \"Jscript source file\", nullptr)",
          "1061: FLAGNR(Boolean, FreeRejittedCode      , \"Free rejitted code\", true)",
          "1062: FLAGNR(Boolean, ForceGuardPages       , \"Force the addition of guard pages\", false)",
          "1063: FLAGNR(Boolean, PrintGuardPageBounds  , \"Prints the bounds of a guard page\", false)",
          "1064: FLAGNR(Boolean, ForceLegacyEngine     , \"Force a jscrip9 dll load\", false)",
          "1065: FLAGNR(Phases,  Force                 , \"Force certain phase to run ignoring heuristics\", )",
          "1066: FLAGNR(Phases,  Stress                , \"Stress certain phases by making them kick in even if they normally would not.\", )",
          "1067: FLAGNR(Boolean, ForceArrayBTree       , \"Force enable creation of BTree for Arrays\", false)",
          "1068: FLAGNR(Boolean, ForceCleanPropertyOnCollect, \"Force cleaning of property on collection\", DEFAULT_CONFIG_ForceCleanPropertyOnCollect)",
          "1069: FLAGNR(Boolean, ForceCleanCacheOnCollect, \"Force cleaning of dynamic caches on collection\", DEFAULT_CONFIG_ForceCleanCacheOnCollect)",
          "1070: FLAGNR(Boolean, ForceGCAfterJSONParse, \"Force GC to happen after JSON parsing\", DEFAULT_CONFIG_ForceGCAfterJSONParse)",
          "1071: FLAGNR(Boolean, ForceDecommitOnCollect, \"Force decommit collect\", DEFAULT_CONFIG_ForceDecommitOnCollect)",
          "1072: FLAGNR(Boolean, ForceDeferParse       , \"Defer parsing of all function bodies\", DEFAULT_CONFIG_ForceDeferParse)",
          "1073: FLAGNR(Boolean, ForceDiagnosticsMode  , \"Enable diagnostics mode and debug interpreter loop\", false)",
          "1074: FLAGNR(Boolean, ForceGetWriteWatchOOM , \"Force GetWriteWatch to go into OOM codepath in HeapBlockMap rescan\", false)",
          "1075: FLAGNR(Boolean, ForcePostLowerGlobOptInstrString, \"Force tracking of globopt instr string post lower\", DEFAULT_CONFIG_ForcePostLowerGlobOptInstrString)",
          "1076: FLAGNR(Boolean, ForceSplitScope       , \"All functions will have unmerged body and param scopes\", DEFAULT_CONFIG_ForceSplitScope)",
          "1077: FLAGNR(Boolean, EnumerateSpecialPropertiesInDebugger, \"Enable enumeration of special debug properties\", DEFAULT_CONFIG_EnumerateSpecialPropertiesInDebugger)",
          "1078: FLAGNR(Boolean, EnableJitInDiagMode   , \"Enable Fast F12 (only applicable with ForceDiagnosticsMode or while under debugger)\", DEFAULT_CONFIG_EnableJitInDiagMode)",
          "1079: FLAGNR(Boolean, EnableContinueAfterExceptionWrappersForHelpers, \"Enable wrapper over helper methods in debugger, Fast F12 only\", DEFAULT_CONFIG_EnableContinueAfterExceptionWrappersForHelpers)",
          "1080: FLAGNR(Boolean, EnableContinueAfterExceptionWrappersForBuiltIns, \"Enable wrapper over library calls in debugger, Fast F12 only\", DEFAULT_CONFIG_EnableContinueAfterExceptionWrappersForBuiltIns)",
          "1081: FLAGNR(Boolean, EnableFunctionSourceReportForHeapEnum, \"During HeapEnum, whether to report function source info (url/row/col)\", DEFAULT_CONFIG_EnableFunctionSourceReportForHeapEnum)",
          "1082: FLAGNR(Number,  ForceFragmentAddressSpace , \"Fragment the address space\", 128 * 1024 * 1024)",
          "1083: FLAGNR(Number,  ForceOOMOnEBCommit, \"Force CommitBuffer to return OOM\", 0)",
          "1084: FLAGR (Boolean, ForceDynamicProfile   , \"Force to always generate profiling byte code\", DEFAULT_CONFIG_ForceDynamicProfile)",
          "1085: FLAGNR(Boolean, ForceES5Array         , \"Force using ES5Array\", DEFAULT_CONFIG_ForceES5Array)",
          "1086: FLAGNR(Boolean, ForceAsmJsLinkFail    , \"Force asm.js link time validation to fail\", DEFAULT_CONFIG_ForceAsmJsLinkFail)",
          "1087: FLAGNR(Boolean, ForceExpireOnNonCacheCollect, \"Allow expiration collect outside of cache collection cleanups\", DEFAULT_CONFIG_ForceExpireOnNonCacheCollect)",
          "1088: FLAGNR(Boolean, ForceFastPath         , \"Force fast-paths in native codegen\", DEFAULT_CONFIG_ForceFastPath)",
          "1089: FLAGNR(Boolean, ForceFloatPref        , \"Force float preferencing (JIT only)\", false)",
          "1090: FLAGNR(Boolean, ForceJITLoopBody      , \"Force jit loop body only\", DEFAULT_CONFIG_ForceJITLoopBody)",
          "1091: FLAGNR(Boolean, DumpCommentsFromReferencedFiles, \"Allow printing comments of comment-table of the referenced file as well (use with -trace:CommentTable)\", DEFAULT_CONFIG_DumpCommentsFromReferencedFiles)",
          "1092: FLAGNR(Number,  DelayFullJITSmallFunc , \"Scale Full JIT threshold for small functions which are going to be inlined soon. To provide fraction scale, the final scale is scale following this option devided by 10\", DEFAULT_CONFIG_DelayFullJITSmallFunc)",
          "1094: #ifdef _M_ARM",
          "1095: FLAGNR(Boolean, ForceLocalsPtr        , \"Force use of alternative locals pointer (JIT only)\", false)",
          "1096: #endif",
          "1097: FLAGNR(Boolean, DeferLoadingAvailableSource, \"Treat available source code as a dummy defer-mappable object to go through that code path.\", DEFAULT_CONFIG_DeferLoadingAvailableSource)",
          "1098: FLAGR (Boolean, ForceNative           , \"Force JIT everything that is called before running it, ignoring limits\", false)",
          "1099: FLAGNR(Boolean, ForceSerialized       , \"Always serialize and deserialize byte codes before execution\", DEFAULT_CONFIG_ForceSerialized)",
          "1100: FLAGNR(Number,  ForceSerializedBytecodeMajorVersion, \"Force the byte code serializer to write this major version number\", 0)",
          "1101: FLAGNR(Number,  ForceSerializedBytecodeVersionSchema, \"Force the byte code serializer to write this kind of version. Decimal 10 is engineering, 20 is release mode, and 0 means use the default setting.\", 0)",
          "1102: FLAGNR(Boolean, ForceStrictMode, \"Force strict mode checks on all functions\", false)",
          "1103: FLAGNR(Boolean, ForceUndoDefer        , \"Defer parsing of all function bodies, but undo deferral\", false)",
          "1104: FLAGNR(Boolean, ForceBlockingConcurrentCollect, \"Force doing in-thread GC on concurrent thread- this will skip doing concurrent collect\", false)",
          "1105: FLAGNR(Boolean, FreTestDiagMode, \"Enabled collection of diagnostic information on fretest builds\", false)",
          "1106: #ifdef BYTECODE_TESTING",
          "1107: FLAGNR(Number,  ByteCodeBranchLimit,    \"Short branch limit before we use the branch island\", 128)",
          "1108: FLAGNR(Boolean, MediumByteCodeLayout  , \"Always use medium layout for bytecodes\", false)",
          "1109: FLAGNR(Boolean, LargeByteCodeLayout   , \"Always use large layout for bytecodes\", false)",
          "1110: #endif",
          "1111: #ifdef FAULT_INJECTION",
          "1112: FLAGNR(Number,  FaultInjection        , \"FaultInjectMode - 0 (count only), 1 (count equal), 2 (count at or above), 3 (stackhashing)\",-1)",
          "1113: FLAGNR(Number,  FaultInjectionCount   , \"Injects an out of memory at the specified allocation\", -1)",
          "1114: FLAGNR(String,  FaultInjectionType    , \"FaultType (flag values) -  1 (Throw), 2 (NoThrow), 4 (MarkThrow), 8 (MarkNoThrow), FFFFFFFF (All)\", nullptr)",
          "1115: FLAGNR(String,  FaultInjectionFilter  , \"A string to restrict the fault injection, the string can be like ArenaAllocator name\", nullptr)",
          "1116: FLAGNR(Number,  FaultInjectionAllocSize, \"Do fault injection only this size\", -1)",
          "1117: FLAGNR(String,  FaultInjectionStackFile   , \"Stacks to match, default: stack.txt in current directory\", _u(\"stack.txt\"))",
          "1118: FLAGNR(Number,  FaultInjectionStackLineCount   , \"Count of lines in the stack file used for matching\", -1)",
          "1119: FLAGNR(String,  FaultInjectionStackHash, \"Match stacks hash on Chakra frames to inject the fault, hex string\", _u(\"0\"))",
          "1120: FLAGNR(Number,  FaultInjectionScriptContextToTerminateCount, \"Script context# COUNT % (Number of script contexts) to terminate\", 1)",
          "1121: #endif",
          "1122: FLAGNR(Number, InduceCodeGenFailure, \"Probability of a codegen job failing.\", DEFAULT_CONFIG_InduceCodeGenFailure)",
          "1123: FLAGNR(Number, InduceCodeGenFailureSeed, \"Seed used while calculating codegen failure probability\", 0)",
          "1124: FLAGNR(Number, InjectPartiallyInitializedInterpreterFrameError, \"The number of interpreter stack frame (with 1 being bottom-most) to inject error before the frame is initialized.\", DEFAULT_CONFIG_InjectPartiallyInitializedInterpreterFrameError)",
          "1125: FLAGNR(Number, InjectPartiallyInitializedInterpreterFrameErrorType, \"Type of error to inject: 0 - debug break, 1 - exception.\", DEFAULT_CONFIG_InjectPartiallyInitializedInterpreterFrameErrorType)",
          "1126: FLAGNR(Boolean, GenerateByteCodeBufferReturnsCantGenerate, \"Serialized byte code generation always returns SCRIPT_E_CANT_GENERATE\", false)",
          "1127: FLAGNR(Number, GoptCleanupThreshold, \"Number of instructions seen before we cleanup the value table\", DEFAULT_CONFIG_GoptCleanupThreshold)",
          "1128: FLAGNR(Number, AsmGoptCleanupThreshold, \"Number of instructions seen before we cleanup the value table\", DEFAULT_CONFIG_AsmGoptCleanupThreshold)",
          "1129: FLAGNR(Boolean, HighPrecisionDate, \"Enable sub-millisecond resolution in Javascript Date for benchmark timing\", DEFAULT_CONFIG_HighPrecisionDate)",
          "1130: FLAGNR(Number,  InlineCountMax        , \"Maximum count in bytecodes to inline in a given function\", DEFAULT_CONFIG_InlineCountMax)",
          "1131: FLAGNRA(Number, InlineCountMaxInLoopBodies, icminlb, \"Maximum count in bytecodes to inline in a given function\", DEFAULT_CONFIG_InlineCountMaxInLoopBodies)",
          "1132: FLAGNRA(Number, InlineInLoopBodyScaleDownFactor, iilbsdf, \"Maximum depth of a recursive inline call\", DEFAULT_CONFIG_InlineInLoopBodyScaleDownFactor)",
          "1133: FLAGNR(Number,  InlineThreshold       , \"Maximum size in bytecodes of an inline candidate\", DEFAULT_CONFIG_InlineThreshold)",
          "1134: FLAGNR(Number,  AggressiveInlineCountMax, \"Maximum count in bytecodes to inline in a given function\", DEFAULT_CONFIG_AggressiveInlineCountMax)",
          "1135: FLAGNR(Number,  AggressiveInlineThreshold, \"Maximum size in bytecodes of an inline candidate for aggressive inlining\", DEFAULT_CONFIG_AggressiveInlineThreshold)",
          "1136: FLAGNR(Number,  InlineThresholdAdjustCountInLargeFunction       , \"Adjustment in the maximum size in bytecodes of an inline candidate in a large function\", DEFAULT_CONFIG_InlineThresholdAdjustCountInLargeFunction)",
          "1137: FLAGNR(Number,  InlineThresholdAdjustCountInMediumSizedFunction , \"Adjustment in the maximum size in bytecodes of an inline candidate in a medium sized function\", DEFAULT_CONFIG_InlineThresholdAdjustCountInMediumSizedFunction)",
          "1138: FLAGNR(Number,  InlineThresholdAdjustCountInSmallFunction       , \"Adjustment in the maximum size in bytecodes of an inline candidate in a small function\", DEFAULT_CONFIG_InlineThresholdAdjustCountInSmallFunction)",
          "1139: FLAGNR(String,  Interpret             , \"List of functions to interpret\", nullptr)",
          "1140: FLAGNR(Phases,  Instrument            , \"Instrument the generated code from the given phase\", )",
          "1141: FLAGNR(Number,  JitQueueThreshold     , \"Max number of work items/script context in the jit queue\", DEFAULT_CONFIG_JitQueueThreshold)",
          "1142: #ifdef LEAK_REPORT",
          "1143: FLAGNR(String,  LeakReport            , \"File name for the leak report\", nullptr)",
          "1144: #endif",
          "1145: FLAGNR(Number,  LoopInlineThreshold   , \"Maximum size in bytecodes of an inline candidate with loops or not enough profile data\", DEFAULT_CONFIG_LoopInlineThreshold)",
          "1146: FLAGNR(Number,  LeafInlineThreshold   , \"Maximum size in bytecodes of an inline candidate with loops or not enough profile data\", DEFAULT_CONFIG_LeafInlineThreshold)",
          "1147: FLAGNR(Number,  ConstantArgumentInlineThreshold, \"Maximum size in bytecodes of an inline candidate with constant argument and the argument being used for a branch\", DEFAULT_CONFIG_ConstantArgumentInlineThreshold)",
          "1148: FLAGNR(Number,  RecursiveInlineThreshold, \"Maximum size in bytecodes of an inline candidate to inline recursively\", DEFAULT_CONFIG_RecursiveInlineThreshold)",
          "1149: FLAGNR(Number,  RecursiveInlineDepthMax, \"Maximum depth of a recursive inline call\", DEFAULT_CONFIG_RecursiveInlineDepthMax)",
          "1150: FLAGNR(Number,  RecursiveInlineDepthMin, \"Maximum depth of a recursive inline call\", DEFAULT_CONFIG_RecursiveInlineDepthMin)",
          "1151: FLAGNR(Number,  Loop                  , \"Number of times to execute the script (useful for profiling short benchmarks and finding leaks)\", DEFAULT_CONFIG_Loop)",
          "1152: FLAGRA(Number,  LoopInterpretCount    , lic, \"Number of times loop has to be interpreted before JIT Loop body\", DEFAULT_CONFIG_LoopInterpretCount)",
          "1153: FLAGNR(Number,  LoopProfileIterations , \"Number of iterations of a loop that must be profiled before jitting the loop body\", DEFAULT_CONFIG_LoopProfileIterations)",
          "1154: FLAGNR(Number,  OutsideLoopInlineThreshold     , \"Maximum size in bytecodes of an inline candidate outside a loop in inliner\", DEFAULT_CONFIG_OutsideLoopInlineThreshold)",
          "1155: FLAGNR(Number,  MaxFuncInlineDepth    , \"Number of times to allow inlining a function recursively, plus one (min: 1, max: 255)\", DEFAULT_CONFIG_MaxFuncInlineDepth)",
          "1156: FLAGNR(Number,  MaxNumberOfInlineesWithLoop, \"Number of times to allow inlinees with a loop in a top function\", DEFAULT_CONFIG_MaxNumberOfInlineesWithLoop)",
          "1157: #ifdef MEMSPECT_TRACKING",
          "1158: FLAGNR(Phases,  Memspect,              \"Enables memspect tracking to perform memory investigations.\", )",
          "1159: #endif",
          "1160: FLAGNR(Number,  PolymorphicInlineThreshold     , \"Maximum size in bytecodes of a polymorphic inline candidate\", DEFAULT_CONFIG_PolymorphicInlineThreshold)",
          "1161: FLAGNR(Boolean, PrimeRecycler         , \"Prime the recycler first\", DEFAULT_CONFIG_PrimeRecycler)",
          "1162: FLAGNR(Boolean, PrivateHeap           , \"Use HeapAlloc with a private heap\", DEFAULT_CONFIG_PrivateHeap)",
          "1163: #if defined(CHECK_MEMORY_LEAK) || defined(LEAK_REPORT)",
          "1164: FLAGNR(Boolean, LeakStackTrace ,        \"Include stack trace on leaked pinned object and heap objects\", false)",
          "1165: FLAGNR(Boolean, ForceMemoryLeak ,       \"Fake leak some memory to test leak report and check memory leak\", false)",
          "1166: #endif",
          "1167: FLAGNR(Boolean, ForceOldDateAPI       , \"Force Chakra to use old dates API regardless of availability of a new one\", DEFAULT_CONFIG_ForceOldDateAPI)",
          "1169: FLAGNR(Number,  JitLoopBodyHotLoopThreshold    , \"Number of times loop has to be iterated in jitloopbody before it is determined as hot\", DEFAULT_CONFIG_JitLoopBodyHotLoopThreshold)",
          "1170: FLAGNR(Number,  LoopBodySizeThresholdToDisableOpts, \"Minimum bytecode size of a loop body, above which we might consider switching off optimizations in jit loop body to avoid rejits\", DEFAULT_CONFIG_LoopBodySizeThresholdToDisableOpts)",
          "1172: FLAGNR(Number,  MaxJitThreadCount     , \"Number of maximum allowed parallel jit threads (actual number is factor of number of processors and other heuristics)\", DEFAULT_CONFIG_MaxJitThreadCount)",
          "1173: FLAGNR(Boolean, ForceMaxJitThreadCount, \"Force the number of parallel jit threads as specified by MaxJitThreadCount flag (creation guaranteed)\", DEFAULT_CONFIG_ForceMaxJitThreadCount)",
          "1175: FLAGNR(Number,  MinInterpretCount     , \"Minimum number of times a function must be interpreted\", 0)",
          "1176: FLAGNR(Number,  MinSimpleJitRunCount  , \"Minimum number of times a function must be run in simple jit\", 0)",
          "1177: FLAGNRA(Number, MaxInterpretCount     , Mic, \"Maximum number of times a function can be interpreted\", 0)",
          "1178: FLAGNRA(Number, MaxSimpleJitRunCount  , Msjrc, \"Maximum number of times a function will be run in SimpleJitted code\", 0)",
          "1179: FLAGNRA(Number, MinMemOpCount         , Mmoc, \"Minimum count of a loop to activate MemOp\", DEFAULT_CONFIG_MinMemOpCount)",
          "1181: #if ENABLE_COPYONACCESS_ARRAY",
          "1182: FLAGNR(Number,  MaxCopyOnAccessArrayLength, \"Maximum length of copy-on-access array\", DEFAULT_CONFIG_MaxCopyOnAccessArrayLength)",
          "1183: FLAGNR(Number,  MinCopyOnAccessArrayLength, \"Minimum length of copy-on-access array\", DEFAULT_CONFIG_MinCopyOnAccessArrayLength)",
          "1184: FLAGNR(Number,  CopyOnAccessArraySegmentCacheSize, \"Size of copy-on-access array segment cache (1-32)\", DEFAULT_CONFIG_CopyOnAccessArraySegmentCacheSize)",
          "1185: #endif",
          "1187: FLAGNR(Number, MinTemplatizedJitRunCount, \"Minimum number of times a function must be Templatized Jitted\", DEFAULT_CONFIG_MinTemplatizedJitRunCount)",
          "1188: FLAGNR(Number, MinAsmJsInterpreterRunCount, \"Minimum number of times a function must be Asm Interpreted\", DEFAULT_CONFIG_MinAsmJsInterpreterRunCount)",
          "1190: FLAGNR(Number, MinTemplatizedJitLoopRunCount, \"Minimum LoopCount run of the Templatized Jit function to run FullJited\", DEFAULT_CONFIG_MinTemplatizedJitLoopRunCount)",
          "1191: FLAGNRA(Number, MaxTemplatizedJitRunCount, Mtjrc, \"Maximum number of times a function must be templatized jit\", DEFAULT_CONFIG_MaxTemplatizedJitRunCount)",
          "1192: FLAGNRA(Number, MaxAsmJsInterpreterRunCount, Maic, \"Maximum number of times a function must be interpreted in asmjs\", DEFAULT_CONFIG_MaxAsmJsInterpreterRunCount)",
          "1194: FLAGR (Number,  AutoProfilingInterpreter0Limit, \"Limit after which to transition to the next execution mode\", DEFAULT_CONFIG_AutoProfilingInterpreter0Limit)",
          "1195: FLAGR (Number,  ProfilingInterpreter0Limit, \"Limit after which to transition to the next execution mode\", DEFAULT_CONFIG_ProfilingInterpreter0Limit)",
          "1196: FLAGR (Number,  AutoProfilingInterpreter1Limit, \"Limit after which to transition to the next execution mode\", DEFAULT_CONFIG_AutoProfilingInterpreter1Limit)",
          "1197: FLAGR (Number,  SimpleJitLimit, \"Limit after which to transition to the next execution mode\", DEFAULT_CONFIG_SimpleJitLimit)",
          "1198: FLAGR (Number,  ProfilingInterpreter1Limit, \"Limit after which to transition to the next execution mode\", DEFAULT_CONFIG_ProfilingInterpreter1Limit)",
          "1200: FLAGNRA(String, ExecutionModeLimits,        Eml,  \"Execution mode limits in th form: AutoProfilingInterpreter0.ProfilingInterpreter0.AutoProfilingInterpreter1.SimpleJit.ProfilingInterpreter1 - Example: -ExecutionModeLimits:12.4.0.132.12\", _u(\"\"))",
          "1201: FLAGRA(Boolean, EnforceExecutionModeLimits, Eeml, \"Enforces the execution mode limits such that they are never exceeded.\", false)",
          "1203: FLAGNRA(Number, SimpleJitAfter        , Sja, \"Number of calls to a function after which to simple-JIT the function\", 0)",
          "1204: FLAGNRA(Number, FullJitAfter          , Fja, \"Number of calls to a function after which to full-JIT the function. The function will be profiled for every iteration.\", 0)",
          "1206: FLAGNR(Boolean, NewSimpleJit          , \"Uses the new simple JIT\", DEFAULT_CONFIG_NewSimpleJit)",
          "1208: FLAGNR(Number,  MaxLinearIntCaseCount , \"Maximum number of cases(in switch statement) for which instructions can be generated linearly\",DEFAULT_CONFIG_MaxLinearIntCaseCount)",
          "1209: FLAGNR(Number,  MaxSingleCharStrJumpTableSize, \"Maximum single char string jump table size\", DEFAULT_CONFIG_MaxSingleCharStrJumpTableSize)",
          "1210: FLAGNR(Number,  MaxSingleCharStrJumpTableRatio, \"Maximum single char string jump table size as multiples of the actual case arm\", DEFAULT_CONFIG_MaxSingleCharStrJumpTableRatio)",
          "1211: FLAGNR(Number,  MinSwitchJumpTableSize , \"Minimum size of the jump table, that is created for consecutive integer case arms in a Switch Statement\",DEFAULT_CONFIG_MinSwitchJumpTableSize)",
          "1212: FLAGNR(Number,  MaxLinearStringCaseCount,  \"Maximum number of string cases(in switch statement) for which instructions can be generated linearly\",DEFAULT_CONFIG_MaxLinearStringCaseCount)",
          "1213: FLAGR(Number,   MinDeferredFuncTokenCount, \"Minimum length in tokens of defer-parsed function\", DEFAULT_CONFIG_MinDeferredFuncTokenCount)",
          "1214: #if DBG",
          "1215: FLAGNR(Number,  SkipFuncCountForBailOnNoProfile,  \"Initial Number of functions in a func body to be skipped from forcibly inserting BailOnNoProfile.\", DEFAULT_CONFIG_SkipFuncCountForBailOnNoProfile)",
          "1216: #endif",
          "1217: FLAGNR(Number,  MaxJITFunctionBytecodeSize, \"The biggest function we'll JIT (bytecode size)\", DEFAULT_CONFIG_MaxJITFunctionBytecodeSize)",
          "1218: FLAGNR(Number,  MaxLoopsPerFunction   , \"Maximum number of loops in any function in the script\", DEFAULT_CONFIG_MaxLoopsPerFunction)",
          "1219: FLAGNR(Number,  FuncObjectInlineCacheThreshold  , \"Maximum number of inline caches a function body may have to allow for inline caches to be allocated on the function object\", DEFAULT_CONFIG_FuncObjectInlineCacheThreshold)",
          "1220: FLAGNR(Boolean, NoDeferParse          , \"Disable deferred parsing\", false)",
          "1221: FLAGNR(Boolean, NoLogo                , \"No logo, which we don't display anyways\", false)",
          "1222: FLAGNR(Boolean, OOPJITMissingOpts     , \"Use optimizations that are missing from OOP JIT\", DEFAULT_CONFIG_OOPJITMissingOpts)",
          "1223: FLAGNR(Boolean, OOPCFGRegistration    , \"Do CFG registration OOP (under OOP JIT)\", DEFAULT_CONFIG_OOPCFGRegistration)",
          "1224: FLAGNR(Number,  RPCFailFastWait       , \"Wait time for JIT process termination before triggering failfast on RPC failure\", DEFAULT_CONFIG_RPCFailFastWait)",
          "1225: #ifdef _ARM64_",
          "1226: FLAGR (Boolean, NoNative              , \"Disable native codegen\", true)",
          "1227: #else",
          "1228: FLAGR (Boolean, NoNative              , \"Disable native codegen\", false)",
          "1229: #endif",
          "1231: FLAGNR(Number,  NopFrequency          , \"Frequency of NOPs inserted by NOP insertion phase.  A NOP is guaranteed to be inserted within a range of (1<<n) instrs (default=8)\", DEFAULT_CONFIG_NopFrequency)",
          "1232: FLAGNR(Boolean, NoStrictMode          , \"Disable strict mode checks on all functions\", false)",
          "1233: FLAGNR(Boolean, NormalizeStats        , \"When dumping stats, do some normalization (used with -instrument:linearscan)\", false)",
          "1234: #ifdef ENABLE_PROJECTION",
          "1235: FLAGNR(Boolean, NoWinRTFastSig        , \"Disable fast call for common WinRT function signatures\", false)",
          "1236: #endif",
          "1237: FLAGNR(Phases,  Off                   , \"Turn off specific phases or feature.(Might not work for all phases)\", )",
          "1238: FLAGNR(Phases,  OffProfiledByteCode   , \"Turn off specific byte code for phases or feature.(Might not work for all phases)\", )",
          "1239: FLAGNR(Phases,  On                    , \"Turn on specific phases or feature.(Might not work for all phases)\", )",
          "1240: FLAGNR(String,  OutputFile            , \"Log the output to a specified file. Default: output.log in the working directory.\", _u(\"output.log\"))",
          "1241: FLAGNR(String,  OutputFileOpenMode    , \"File open mode for OutputFile. Default: wt, specify 'at' for append\", _u(\"wt\"))",
          "1242: #ifdef ENABLE_TRACE",
          "1243: FLAGNR(Boolean, InMemoryTrace         , \"Enable in-memory trace (investigate crash using trace in dump file). Use !jd.dumptrace to print it.\", DEFAULT_CONFIG_InMemoryTrace)",
          "1244: FLAGNR(Number,  InMemoryTraceBufferSize, \"The size of circular buffer for in-memory trace (the units used is: number of trace calls). \", DEFAULT_CONFIG_InMemoryTraceBufferSize)",
          "1245: #if CONFIG_RICH_TRACE_FORMAT",
          "1246: FLAGNR(Boolean, RichTraceFormat, \"Whether to use extra data in Output/Trace header.\", DEFAULT_CONFIG_RichTraceFormat)",
          "1247: #endif",
          "1248: #ifdef STACK_BACK_TRACE",
          "1249: FLAGNR(Boolean, TraceWithStack, \"Whether the trace need to include stack trace (for each trace entry).\", DEFAULT_CONFIG_TraceWithStack)",
          "1250: #endif // STACK_BACK_TRACE",
          "1251: #endif // ENABLE_TRACE",
          "1252: FLAGNR(Boolean, PrintRunTimeDataCollectionTrace, \"Print traces needed for runtime data collection\", false)",
          "1253: #ifdef ENABLE_PREJIT",
          "1254: FLAGR (Boolean, Prejit                , \"Prejit everything, including things that are not called, ignoring limits (default: false)\", DEFAULT_CONFIG_Prejit)",
          "1255: #endif",
          "1256: FLAGNR(Boolean, PrintSrcInDump        , \"Print the lineno and the source code in the intermediate dumps\", true)",
          "1257: #if PROFILE_DICTIONARY",
          "1258: FLAGNR(Number,  ProfileDictionary     , \"Profile dictionary usage. Only dictionaries with max depth of <number> or above are displayed (0=no filter).\", -1)",
          "1259: #endif",
          "1260: #ifdef PROFILE_EXEC",
          "1261: FLAGNR(Phases,  Profile               , \"Profile the given phase\", )",
          "1262: FLAGNR(Number,  ProfileThreshold      , \"A phase is displayed in the profiler report only if its contribution is more than this threshold\", 0)",
          "1263: #endif",
          "1264: #ifdef PROFILE_OBJECT_LITERALS",
          "1265: FLAGNR(Boolean, ProfileObjectLiteral  , \"Profile Object literal usage\", false)",
          "1266: #endif",
          "1267: #ifdef PROFILE_MEM",
          "1268: FLAGNR(String,  ProfileMemory         , \"Profile memory usage\", )",
          "1269: #endif",
          "1270: #ifdef PROFILE_STRINGS",
          "1271: FLAGNR(Boolean, ProfileStrings        , \"Profile string statistics\", false)",
          "1272: #endif",
          "1273: #ifdef PROFILE_TYPES",
          "1274: FLAGNR(Boolean, ProfileTypes          , \"Profile type statistics\", false)",
          "1275: #endif",
          "1276: #ifdef PROFILE_EVALMAP",
          "1277: FLAGNR(Boolean, ProfileEvalMap        , \"Profile eval map statistics\", false)",
          "1278: #endif",
          "1280: #ifdef PROFILE_BAILOUT_RECORD_MEMORY",
          "1281: FLAGNR(Boolean, ProfileBailOutRecordMemory, \"Profile bailout record memory statistics\", false)",
          "1282: #endif",
          "1284: FLAGNR(Number,  RejitMaxBailOutCount, \"Maximum number of bailouts for a bailout record after which rejit is forced\", DEFAULT_CONFIG_RejitMaxBailOutCount)",
          "1285: FLAGNR(Number,  CallsToBailoutsRatioForRejit, \"Ratio of function calls to bailouts above which a rejit is considered\", DEFAULT_CONFIG_CallsToBailoutsRatioForRejit)",
          "1286: FLAGNR(Number,  LoopIterationsToBailoutsRatioForRejit, \"Ratio of loop iteration count to bailouts above which a rejit of the loop body is considered\", DEFAULT_CONFIG_LoopIterationsToBailoutsRatioForRejit)",
          "1287: FLAGNR(Number,  MinBailOutsBeforeRejit, \"Minimum number of bailouts for a single bailout record after which a rejit is considered\", DEFAULT_CONFIG_MinBailOutsBeforeRejit)",
          "1288: FLAGNR(Number,  MinBailOutsBeforeRejitForLoops, \"Minimum number of bailouts for a single bailout record after which a rejit is considered\", DEFAULT_CONFIG_MinBailOutsBeforeRejitForLoops)",
          "1289: FLAGNR(Boolean, LibraryStackFrame           , \"Display library stack frame\", DEFAULT_CONFIG_LibraryStackFrame)",
          "1290: FLAGNR(Boolean, LibraryStackFrameDebugger   , \"Assume debugger support for library stack frame\", DEFAULT_CONFIG_LibraryStackFrameDebugger)",
          "1291: #ifdef RECYCLER_STRESS",
          "1292: FLAGNR(Boolean, RecyclerStress        , \"Stress the recycler by collect on every allocation call\", false)",
          "1293: #if ENABLE_CONCURRENT_GC",
          "1294: FLAGNR(Boolean, RecyclerBackgroundStress        , \"Stress the recycler by collect in the background thread on every allocation call\", false)",
          "1295: FLAGNR(Boolean, RecyclerConcurrentStress        , \"Stress the concurrent recycler by concurrent collect on every allocation call\", false)",
          "1296: FLAGNR(Boolean, RecyclerConcurrentRepeatStress  , \"Stress the concurrent recycler by concurrent collect on every allocation call and repeat mark and rescan in the background thread\", false)",
          "1297: #endif",
          "1298: #if ENABLE_PARTIAL_GC",
          "1299: FLAGNR(Boolean, RecyclerPartialStress , \"Stress the partial recycler by partial collect on every allocation call\", false)",
          "1300: #endif",
          "1301: FLAGNR(Boolean, RecyclerTrackStress, \"Stress tracked object handling by simulating tracked objects for regular allocations\", false)",
          "1302: FLAGNR(Boolean, RecyclerInduceFalsePositives, \"Stress recycler by forcing false positive object marks\", false)",
          "1303: #endif // RECYCLER_STRESS",
          "1304: FLAGNR(Boolean, RecyclerForceMarkInterior, \"Force all the mark as interior\", DEFAULT_CONFIG_RecyclerForceMarkInterior)",
          "1305: #if ENABLE_CONCURRENT_GC",
          "1306: FLAGNR(Number,  RecyclerPriorityBoostTimeout, \"Adjust priority boost timeout\", 5000)",
          "1307: FLAGNR(Number,  RecyclerThreadCollectTimeout, \"Adjust thread collect timeout\", 1000)",
          "1308: #endif",
          "1309: #ifdef RECYCLER_PAGE_HEAP",
          "1310: FLAGNR(Number,      PageHeap,             \"Use full page for heap allocations\", DEFAULT_CONFIG_PageHeap)",
          "1311: FLAGNR(Boolean,     PageHeapAllocStack,   \"Capture alloc stack under page heap mode\", DEFAULT_CONFIG_PageHeapAllocStack)",
          "1312: FLAGNR(Boolean,     PageHeapFreeStack,    \"Capture free stack under page heap mode\", DEFAULT_CONFIG_PageHeapFreeStack)",
          "1313: FLAGNR(NumberRange, PageHeapBucketNumber, \"Bucket numbers to be used for page heap allocations\", )",
          "1314: FLAGNR(Number,      PageHeapBlockType,    \"Type of blocks to use page heap for\", DEFAULT_CONFIG_PageHeapBlockType)",
          "1315: #endif",
          "1316: #ifdef RECYCLER_NO_PAGE_REUSE",
          "1317: FLAGNR(Boolean, RecyclerNoPageReuse,     \"Do not reuse page in recycler\", false)",
          "1318: #endif",
          "1319: #ifdef RECYCLER_MEMORY_VERIFY",
          "1320: FLAGNR(Phases,  RecyclerVerify         , \"Verify recycler memory\", )",
          "1321: FLAGNR(Number,  RecyclerVerifyPadSize  , \"Padding size to verify recycler memory\", 12)",
          "1322: #endif",
          "1323: FLAGNR(Boolean, RecyclerTest           , \"Run recycler tests instead of executing script\", false)",
          "1324: FLAGNR(Boolean, RecyclerProtectPagesOnRescan, \"Temporarily switch all pages to read only during rescan\", false)",
          "1325: #ifdef RECYCLER_VERIFY_MARK",
          "1326: FLAGNR(Boolean, RecyclerVerifyMark    , \"verify concurrent gc\", false)",
          "1327: #endif",
          "1328: FLAGR (Number,  LowMemoryCap          , \"Memory cap indicating a low-memory process\", DEFAULT_CONFIG_LowMemoryCap)",
          "1329: FLAGNR(Number,  NewPagesCapDuringBGSweeping, \"New pages count allowed to be allocated during background sweeping\", DEFAULT_CONFIG_NewPagesCapDuringBGSweeping)",
          "1330: #ifdef RUNTIME_DATA_COLLECTION",
          "1331: FLAGNR(String,  RuntimeDataOutputFile, \"Filename to write the dynamic profile info\", nullptr)",
          "1332: #endif",
          "1333: FLAGNR(Boolean, ReportErrors          , \"Enable reporting of syntax errors\", false)",
          "1334: FLAGR (Number,  SpeculationCap        , \"How much bytecode we'll speculatively JIT\", DEFAULT_CONFIG_SpeculationCap)",
          "1335: #if DBG_DUMP || defined(BGJIT_STATS) || defined(RECYCLER_STATS)",
          "1336: FLAGNR(Phases,  Stats                 , \"Stats the given phase\", )",
          "1337: #endif",
          "1338: #if EXCEPTION_RECOVERY",
          "1339: FLAGNR(Boolean, SwallowExceptions     , \"Force a try/catch around every statement\", false)",
          "1340: #endif",
          "1341: FLAGNR(Boolean, PrintSystemException  , \"Always print a message when there's OOM or OOS\", false)",
          "1342: FLAGNR(Number,  SwitchOptHolesThreshold,  \"Maximum percentage of holes (missing case values in a switch statement) with which a jump table can be created\",DEFAULT_CONFIG_SwitchOptHolesThreshold)",
          "1343: FLAGR (Number,  TempMin                  , \"Temp number switch which code can temporarily use for debugging\", DEFAULT_CONFIG_TempMin)",
          "1344: FLAGR (Number,  TempMax                  , \"Temp number switch which code can temporarily use for debugging\", DEFAULT_CONFIG_TempMax)",
          "1345: FLAGNR(Phases,  Trace                 , \"Trace the given phase\", )",
          "1347: #if defined(_M_IX86) || defined(_M_X64)",
          "1348: FLAGR(Number,   LoopAlignNopLimit       , \"Max number of nops for loop alignment\", DEFAULT_CONFIG_LoopAlignNopLimit)",
          "1349: #endif",
          "1351: #ifdef PROFILE_MEM",
          "1352: FLAGNR(Phases,  TraceMemory           , \"Trace memory usage\", )",
          "1353: #endif",
          "1354: #if DBG_DUMP || defined(RECYCLER_TRACE)",
          "1361: FLAGNR(Number,  TraceMetaDataParsing  , \"Trace metadata parsing for generating JS projections. [Levels 1-5, with 5 corresponding to most detailed]\", 5)",
          "1362: FLAGNR(Boolean, TraceWin8Allocations  , \"Trace the win8 memory allocations\", false)",
          "1363: FLAGNR(Boolean, TraceWin8DeallocationsImmediate  , \"Trace the win8 memory deallocations immediately\", false)",
          "1364: FLAGNR(Boolean, PrintWin8StatsDetailed  , \"Print the detailed memory trace report\", false)",
          "1365: FLAGNR(Boolean, TraceProtectPages     , \"Trace calls to protecting pages of custom heap allocated pages\", false)",
          "1370: FLAGNR(Number, TraceProjection       , \"Trace projection related activities, [Levels 1-3, with 3 corresponding to most detailed]\", 3)",
          "1371: #endif",
          "1372: FLAGNR(Boolean, TraceAsyncDebugCalls  , \"Trace calls to async debugging API (default: false)\", DEFAULT_CONFIG_TraceAsyncDebugCalls)",
          "1373: #ifdef TRACK_DISPATCH",
          "1374: FLAGNR(Boolean, TrackDispatch         , \"Save stack traces of where JavascriptDispatch/HostVariant are created\", false)",
          "1375: #endif",
          "1376: FLAGNR(Boolean, Verbose               , \"Dump details\", DEFAULT_CONFIG_Verbose)",
          "1377: FLAGNR(Boolean, UseFullName           , \"Enable fully qualified name\", DEFAULT_CONFIG_UseFullName)",
          "1378: FLAGNR(Boolean, UseFunctionIdForTrace , \"Use function id instead of function number for trace output\", false)",
          "1379: FLAGNR(Boolean, Utf8                  , \"Use UTF8 for file output\", false)",
          "1380: FLAGR (Number,  Version               , \"Version in which to run the jscript engine. [one of 1,2,3,4,5,6]. Default is latest for jc/jshost, 1 for IE\", 6 )",
          "1381: #ifdef ENABLE_PROJECTION",
          "1382: FLAGR (Number,  HostType              , \"Host type in which to run the jscript engine. [one of 1,2]. Default is 1 = Browser.\", 1)",
          "1383: #endif",
          "1384: FLAGR(Boolean, WERExceptionSupport    , \"WER feature for extended exception support. Enabled when WinRT is enabled\", false)",
          "1385: #ifdef ENABLE_PROJECTION",
          "1386: FLAGR (Boolean, WinRTConstructorAllowed, \"Whether WinRT constructors is allowed in WebView host type. Constructor is always allowed in other host type \", false)",
          "1387: #endif",
          "1388: FLAGNR(Boolean, ExtendedErrorStackForTestHost, \"Enable passing extended error stack string to test host.\", DEFAULT_CONFIG_ExtendedErrorStackForTestHost)",
          "1389: FLAGNR(Boolean, errorStackTrace       , \"error.StackTrace feature. Remove when feature complete\", DEFAULT_CONFIG_errorStackTrace)",
          "1390: FLAGNR(Boolean, DoHeapEnumOnEngineShutdown, \"Perform a heap enumeration whenever shut a script engine down\", false)",
          "1391: #ifdef HEAP_ENUMERATION_VALIDATION",
          "1392: FLAGNR(Boolean, ValidateHeapEnum      , \"Validate that heap enumeration is reporting all Js::RecyclableObjects in the heap\", false)",
          "1393: #endif",
          "1395: #if ENABLE_REGEX_CONFIG_OPTIONS",
          "1399: FLAGR (Boolean, RegexTracing          , \"Trace all Regex invocations to the output.\", DEFAULT_CONFIG_RegexTracing)",
          "1400: FLAGR (Boolean, RegexProfile          , \"Collect usage statistics on all Regex invocations.\", DEFAULT_CONFIG_RegexProfile)",
          "1401: FLAGR (Boolean, RegexDebug            , \"Trace compilation of UnifiedRegex expressions.\", DEFAULT_CONFIG_RegexDebug)",
          "1402: FLAGR (Boolean, RegexOptimize         , \"Optimize regular expressions in the unified Regex system (default: true)\", DEFAULT_CONFIG_RegexOptimize)",
          "1403: FLAGR (Number,  DynamicRegexMruListSize, \"Size of the MRU list for dynamic regexes\", DEFAULT_CONFIG_DynamicRegexMruListSize)",
          "1404: #endif",
          "1406: FLAGR (Boolean, OptimizeForManyInstances, \"Optimize script engine for many instances (low memory footprint per engine, assume low spare CPU cycles) (default: false)\", DEFAULT_CONFIG_OptimizeForManyInstances)",
          "1407: FLAGNR(Phases,  TestTrace             , \"Test trace for the given phase\", )",
          "1408: FLAGNR(Boolean, EnableEvalMapCleanup, \"Enable cleaning up the eval map\", true)",
          "1409: #ifdef PROFILE_MEM",
          "1410: FLAGNR(Boolean, TraceObjectAllocation, \"Enable cleaning up the eval map\", false)",
          "1411: #endif",
          "1412: #ifdef ENABLE_PROJECTION",
          "1413: FLAGNR(Boolean, EnableThirdPartyGCPressure, \"Enable use of GCPressure attribute value on 3rd party WinRT objects (not in Windows namespace) (default: false)\", false)",
          "1414: FLAGNR(Number, TargetWinRTVersion, \"Specifies WinRT version number to target. [one of 0,1,2,3,4]. Default is 1 = NTDDI_WIN8\", DEFAULT_CONFIG_TargetWinRTVersion)",
          "1415: FLAGNR(Boolean, EnableVersioningAllAssemblies, \"Enable versioning behavior for all assemblies, regardless of host flag (default: false)\", false)",
          "1416: FLAGR(Boolean, FailFastIfDisconnectedDelegate, \"When set fail fast if disconnected delegate is invoked\", DEFAULT_CONFIG_FailFastIfDisconnectedDelegate)",
          "1417: #endif",
          "1418: FLAGNR(Number, Sse, \"Virtually disables SSE-based optimizations above the specified SSE level in the Chakra JIT (does not affect CRT SSE usage)\", DEFAULT_CONFIG_Sse)",
          "1419: FLAGNR(Number,  DeletedPropertyReuseThreshold, \"Start reusing deleted property indexes after this many properties are deleted. Zero to disable reuse.\", DEFAULT_CONFIG_DeletedPropertyReuseThreshold)",
          "1420: FLAGNR(Boolean, ForceStringKeyedSimpleDictionaryTypeHandler, \"Force switch to string keyed version of SimpleDictionaryTypeHandler on first new property added to a SimpleDictionaryTypeHandler\", DEFAULT_CONFIG_ForceStringKeyedSimpleDictionaryTypeHandler)",
          "1421: FLAGNR(Number,  BigDictionaryTypeHandlerThreshold, \"Min Slot Capacity required to convert DictionaryTypeHandler to BigDictionaryTypeHandler.(Advisable to give more than 15 - to avoid false positive cases)\", DEFAULT_CONFIG_BigDictionaryTypeHandlerThreshold)",
          "1422: FLAGNR(Boolean, TypeSnapshotEnumeration, \"Create a true snapshot of the type of an object before enumeration and enumerate only those properties.\", DEFAULT_CONFIG_TypeSnapshotEnumeration)",
          "1423: FLAGR (Boolean, EnumerationCompat,      \"When set in IE10 mode, restores enumeration behavior to RC behavior\", DEFAULT_CONFIG_EnumerationCompat)",
          "1424: FLAGNR(Boolean, IsolatePrototypes, \"Should prototypes get unique types not shared with other objects (default: true)?\", DEFAULT_CONFIG_IsolatePrototypes)",
          "1425: FLAGNR(Boolean, ChangeTypeOnProto, \"When becoming a prototype should the object switch to a new type (default: true)?\", DEFAULT_CONFIG_ChangeTypeOnProto)",
          "1426: FLAGNR(Boolean, ShareInlineCaches, \"Determines whether inline caches are shared between all loads (or all stores) of the same property ID\", DEFAULT_CONFIG_ShareInlineCaches)",
          "1427: FLAGNR(Boolean, DisableDebugObject, \"Disable test only Debug object properties\", DEFAULT_CONFIG_DisableDebugObject)",
          "1428: FLAGNR(Boolean, DumpHeap, \"enable Debug.dumpHeap even when DisableDebugObject is set\", DEFAULT_CONFIG_DumpHeap)",
          "1429: FLAGNR(String, autoProxy, \"enable creating proxy for each object creation\", _u(\"__msTestHandler\"))",
          "1430: FLAGNR(Number,  PerfHintLevel, \"Specifies the perf-hint level (1,2) 1 == critical, 2 == only noisy\", DEFAULT_CONFIG_PerfHintLevel)",
          "1431: #ifdef INTERNAL_MEM_PROTECT_HEAP_ALLOC",
          "1432: FLAGNR(Boolean, MemProtectHeap, \"Use the mem protect heap as the default heap\", DEFAULT_CONFIG_MemProtectHeap)",
          "1433: #endif",
          "1434: #ifdef RECYCLER_STRESS",
          "1435: FLAGNR(Boolean, MemProtectHeapStress, \"Stress the recycler by collect on every allocation call\", false)",
          "1436: #if ENABLE_CONCURRENT_GC",
          "1437: FLAGNR(Boolean, MemProtectHeapBackgroundStress, \"Stress the recycler by collect in the background thread on every allocation call\", false)",
          "1438: FLAGNR(Boolean, MemProtectHeapConcurrentStress, \"Stress the concurrent recycler by concurrent collect on every allocation call\", false)",
          "1439: FLAGNR(Boolean, MemProtectHeapConcurrentRepeatStress, \"Stress the concurrent recycler by concurrent collect on every allocation call and repeat mark and rescan in the background thread\", false)",
          "1440: #endif",
          "1441: #if ENABLE_PARTIAL_GC",
          "1442: FLAGNR(Boolean, MemProtectHeapPartialStress, \"Stress the partial recycler by partial collect on every allocation call\", false)",
          "1443: #endif",
          "1444: #endif",
          "1445: #ifdef SUPPORT_FIXED_FIELDS_ON_PATH_TYPES",
          "1446: FLAGNR(Boolean, FixPropsOnPathTypes, \"Mark properties as fixed on path types (default: false).\", DEFAULT_CONFIG_FixPropsOnPathTypes)",
          "1447: #endif",
          "1448: FLAGNR(NumberSet, BailoutTraceFilter, \"Filter the bailout trace messages to specific bailout kinds.\", )",
          "1449: FLAGNR(NumberSet, RejitTraceFilter, \"Filter the rejit trace messages to specific bailout kinds.\", )",
          "1452: FLAGNR(Number,  MaxBackgroundFinishMarkCount, \"Maximum number of background finish mark\", 1)",
          "1453: FLAGNR(Number,  BackgroundFinishMarkWaitTime, \"Millisecond to wait for background finish mark\", 15)",
          "1454: FLAGNR(Number,  MinBackgroundRepeatMarkRescanBytes, \"Minimum number of bytes rescan to trigger background finish mark\",  -1)",
          "1456: #if defined(_M_IX86) || defined(_M_X64)",
          "1457: FLAGNR(Boolean, ZeroMemoryWithNonTemporalStore, \"Zero free memory with non-temporal stores to avoid evicting other content from processor cache\", DEFAULT_CONFIG_ZeroMemoryWithNonTemporalStore)",
          "1458: #endif",
          "1461: FLAGNR(Number,  MaxMarkStackPageCount , \"Restrict recycler mark stack size (in pages)\", -1)",
          "1462: FLAGNR(Number,  MaxTrackedObjectListCount,  \"Restrict recycler tracked object count during GC\", -1)",
          "1465: FLAGNR(Number, NumberAllocPlusSize, \"Additional bytes to allocate with JavascriptNumber from number allocator (0~496)\", 0)",
          "1467: #if DBG",
          "1468: FLAGNR(Boolean, InitializeInterpreterSlotsWithInvalidStackVar, \"Enable the initialization of the interpreter local slots with invalid stack vars\", false)",
          "1469: #endif",
          "1471: #if DBG",
          "1472: FLAGNR(Number, PRNGSeed0, \"Override seed0 for Math.Random()\", 0)",
          "1473: FLAGNR(Number, PRNGSeed1, \"Override seed1 for Math.Random()\", 0)",
          "1474: #endif",
          "1476: FLAGNR(Boolean, ClearInlineCachesOnCollect, \"Clear all inline caches on every garbage collection\", false)",
          "1477: FLAGNR(Number, InlineCacheInvalidationListCompactionThreshold, \"Compact inline cache invalidation lists if their utilization falls below this threshold\", DEFAULT_CONFIG_InlineCacheInvalidationListCompactionThreshold)",
          "1478: FLAGNR(Number, ConstructorCacheInvalidationThreshold, \"Clear uniquePropertyGuard entries from recyclableData if number of invalidations of constructor caches happened are more than the threshold.\", DEFAULT_CONFIG_ConstructorCacheInvalidationThreshold)",
          "1480: #ifdef IR_VIEWER",
          "1481: FLAGNR(Boolean, IRViewer, \"Enable IRViewer functionality (improved UI for various stages of IR generation)\", false)",
          "1484: FLAGNR(Boolean, InvalidateSolutionContextsForGetStructure, \"To reduce memory consumption, in the end of GetStructure call, invalidate script contexts used only for GetStructure -- this would invalidate ones associated with solution files (not top-most references such as helpers.js)\", DEFAULT_CONFIG_InvalidateSolutionContextsForGetStructure)",
          "1485: FLAGNR(Boolean, ES5LangTel, \"Print ES5 language telemetry output.\", false)",
          "1486: FLAGNR(Boolean, ES6LangTel, \"Print ES6 language telemetry output.\", false)",
          "1487: FLAGNR(Boolean, ESBLangTel, \"Print ES built-ins telemetry output.\", false)",
          "1488: FLAGNR(Boolean, DateParseTel, \"Print Date.parse telemetry output.\", false)",
          "1490: FLAGNR(Number,  GCMemoryThreshold, \"Threshold for allocation-based GC initiation (in MB)\", 0)",
          "1492: #ifdef _CONTROL_FLOW_GUARD",
          "1493: FLAGNR(Boolean, PreReservedHeapAlloc, \"Enable Pre-reserved Heap Page Allocator\", true)",
          "1494: FLAGNR(Boolean, CFGInJit, \"Enable CFG check in JIT\", true)",
          "1495: FLAGNR(Boolean, CFG, \"Force enable CFG on jshost. version in the jshost's manifest file disables CFG\", true)",
          "1496: #endif",
          "1498: #if DBG",
          "1499:     FLAGNR(Number, SimulatePolyCacheWithOneTypeForInlineCacheIndex, \"Use with SimulatePolyCacheWithOneTypeForFunction to simulate creating a polymorphic inline cache containing only one type due to a collision, for testing ObjTypeSpec\", -1)",
          "1500: #endif",
          "1502: FLAGR(Number, JITServerIdleTimeout, \"Idle timeout in milliseconds to do the cleanup in JIT server\", 500)",
          "1503: FLAGR(Number, JITServerMaxInactivePageAllocatorCount, \"Max inactive page allocators to keep before schedule a cleanup\", 10)",
          "1505: FLAGNR(Boolean, StrictWriteBarrierCheck, \"Check write barrier setting on none write barrier pages\", DEFAULT_CONFIG_StrictWriteBarrierCheck)",
          "1506: FLAGNR(Boolean, WriteBarrierTest, \"Always return true while checking barrier to test recycler regardless of annotation\", DEFAULT_CONFIG_WriteBarrierTest)",
          "1507: FLAGNR(Boolean, ForceSoftwareWriteBarrier, \"Use to turn off write watch to test software write barrier on windows\", DEFAULT_CONFIG_ForceSoftwareWriteBarrier)",
          "1508: FLAGNR(Boolean, VerifyBarrierBit, \"Verify software write barrier bit is set while marking\", DEFAULT_CONFIG_VerifyBarrierBit)",
          "1509: FLAGNR(Boolean, EnableBGFreeZero, \"Use to turn off background freeing and zeroing to simulate linux\", DEFAULT_CONFIG_EnableBGFreeZero)",
          "1510: FLAGNR(Boolean, KeepRecyclerTrackData, \"Keep recycler track data after sweep until reuse\", DEFAULT_CONFIG_KeepRecyclerTrackData)",
          "1512: #undef FLAG_REGOVR_EXP",
          "1513: #undef FLAG_REGOVR_ASMJS",
          "1515: #undef FLAG",
          "1516: #undef FLAGP",
          "1518: #undef FLAGRA",
          "1520: #undef FLAGNR",
          "1521: #undef FLAGNRA",
          "1522: #undef FLAGPNR",
          "1523: #undef FLAGPRA",
          "1525: #endif",
          "",
          "---------------"
        ],
        "lib/Common/Memory/LargeHeapBlock.cpp||lib/Common/Memory/LargeHeapBlock.cpp": [
          "File: lib/Common/Memory/LargeHeapBlock.cpp -> lib/Common/Memory/LargeHeapBlock.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "5: #include \"CommonMemoryPch.h\"",
          "7: CompileAssert(",
          "8:     sizeof(LargeObjectHeader) == HeapConstants::ObjectGranularity ||",
          "9:     sizeof(LargeObjectHeader) == HeapConstants::ObjectGranularity * 2);",
          "11: #ifdef STACK_BACK_TRACE",
          "12: const StackBackTrace* LargeHeapBlock::s_StackTraceAllocFailed = (StackBackTrace*)1;",
          "13: #endif",
          "15: void *",
          "16: LargeObjectHeader::GetAddress() { return ((char *)this) + sizeof(LargeObjectHeader); }",
          "18: #ifdef LARGEHEAPBLOCK_ENCODING",
          "24: unsigned char",
          "25: LargeObjectHeader::CalculateCheckSum(LargeObjectHeader* decodedNext, unsigned char decodedAttributes)",
          "26: {",
          "27:     unsigned char checksum = 0;",
          "28:     byte *nextField = (byte *)&decodedNext;",
          "30:     checksum = nextField[0] ^ nextField[1] ^ nextField[2] ^ nextField[3] ^ decodedAttributes;",
          "31:     return checksum;",
          "32: }",
          "34: LargeObjectHeader*",
          "35: LargeObjectHeader::EncodeNext(uint cookie, LargeObjectHeader* next)",
          "36: {",
          "37:     return (LargeObjectHeader *)((uintptr_t)next ^ cookie);",
          "38: }",
          "40: ushort",
          "41: LargeObjectHeader::EncodeAttributesAndChecksum(uint cookie, ushort attributesAndChecksum)",
          "42: {",
          "43:     return attributesAndChecksum ^ (ushort)cookie;",
          "44: }",
          "46: LargeObjectHeader*",
          "47: LargeObjectHeader::DecodeNext(uint cookie, LargeObjectHeader* next) { return EncodeNext(cookie, next); }",
          "49: ushort",
          "50: LargeObjectHeader::DecodeAttributesAndChecksum(uint cookie) { return EncodeAttributesAndChecksum(cookie, this->attributesAndChecksum); }",
          "52: #else",
          "56: unsigned char *",
          "57: LargeObjectHeader::GetAttributesPtr()",
          "58: {",
          "59:     return &this->attributes;",
          "60: }",
          "61: #endif",
          "63: void",
          "64: LargeObjectHeader::SetNext(uint cookie, LargeObjectHeader* next)",
          "65: {",
          "66: #ifdef LARGEHEAPBLOCK_ENCODING",
          "67:     ushort decodedAttributesAndChecksum = this->DecodeAttributesAndChecksum(cookie);",
          "70:     unsigned char newCheckSumValue = this->CalculateCheckSum(next, (unsigned char)(decodedAttributesAndChecksum >> 8));",
          "72:     ushort newAttributeWithCheckSum = (decodedAttributesAndChecksum & 0xFF00) | newCheckSumValue;",
          "75:     this->attributesAndChecksum = this->EncodeAttributesAndChecksum(cookie, newAttributeWithCheckSum);",
          "76:     this->next = this->EncodeNext(cookie, next);",
          "77: #else",
          "78:     this->next = next;",
          "79: #endif",
          "80: }",
          "82: LargeObjectHeader *",
          "83: LargeObjectHeader::GetNext(uint cookie)",
          "84: {",
          "85: #ifdef LARGEHEAPBLOCK_ENCODING",
          "86:     LargeObjectHeader *decodedNext = this->DecodeNext(cookie, this->next);",
          "87:     ushort decodedAttributesAndChecksum = this->DecodeAttributesAndChecksum(cookie);",
          "89:     unsigned char checkSum = (unsigned char)(decodedAttributesAndChecksum & 0xFF);",
          "90:     unsigned char calculatedCheckSumField = this->CalculateCheckSum(decodedNext, (unsigned char)(decodedAttributesAndChecksum >> 8));",
          "91:     if (checkSum != calculatedCheckSumField)",
          "92:     {",
          "93:         LargeHeapBlock_Metadata_Corrupted((ULONG_PTR)this, calculatedCheckSumField);",
          "94:     }",
          "97:     return this->DecodeNext(cookie, this->next);",
          "99: #else",
          "100:     return this->next;",
          "101: #endif",
          "102: }",
          "104: void",
          "105: LargeObjectHeader::SetAttributes(uint cookie, unsigned char attributes)",
          "106: {",
          "107: #ifdef LARGEHEAPBLOCK_ENCODING",
          "108:     LargeObjectHeader *decodedNext = this->DecodeNext(cookie, this->next);",
          "111:     unsigned char newCheckSumValue = this->CalculateCheckSum(decodedNext, attributes);",
          "113:     ushort newAttributeWithCheckSum = ((ushort)attributes << 8) | newCheckSumValue;",
          "115:     this->attributesAndChecksum = this->EncodeAttributesAndChecksum(cookie, newAttributeWithCheckSum);",
          "116: #else",
          "117:     this->attributes = attributes;",
          "118: #endif",
          "119: }",
          "121: unsigned char",
          "122: LargeObjectHeader::GetAttributes(uint cookie)",
          "123: {",
          "124: #ifdef LARGEHEAPBLOCK_ENCODING",
          "126:     LargeObjectHeader *decodedNext = this->DecodeNext(cookie, this->next);",
          "127:     ushort decodedAttributesAndChecksum = this->DecodeAttributesAndChecksum(cookie);",
          "129:     unsigned char checkSum = (unsigned char)(decodedAttributesAndChecksum & 0xFF);",
          "130:     unsigned char calculatedCheckSumField = this->CalculateCheckSum(decodedNext, (unsigned char)(decodedAttributesAndChecksum >> 8));",
          "131:     if (checkSum != calculatedCheckSumField)",
          "132:     {",
          "133:         LargeHeapBlock_Metadata_Corrupted((ULONG_PTR)this, calculatedCheckSumField);",
          "134:     }",
          "138:     return this->DecodeAttributesAndChecksum(cookie) >> 8;",
          "139: #else",
          "140:     return this->attributes;",
          "141: #endif",
          "142: }",
          "144: size_t",
          "145: LargeHeapBlock::GetAllocPlusSize(uint objectCount)",
          "146: {",
          "151:     size_t allocPlusSize = objectCount * (sizeof(LargeObjectHeader *));",
          "152: #ifdef PROFILE_RECYCLER_ALLOC",
          "153:     if (Recycler::DoProfileAllocTracker())",
          "154:     {",
          "155:         allocPlusSize += objectCount * sizeof(void *);",
          "156:     }",
          "157: #endif",
          "158:     return allocPlusSize;",
          "159: }",
          "161: LargeHeapBlock *",
          "162: LargeHeapBlock::New(__in char * address, size_t pageCount, Segment * segment, uint objectCount, LargeHeapBucket* bucket)",
          "163: {",
          "164:     return NoMemProtectHeapNewNoThrowPlusZ(GetAllocPlusSize(objectCount), LargeHeapBlock, address, pageCount, segment, objectCount, bucket);",
          "165: }",
          "167: void",
          "168: LargeHeapBlock::Delete(LargeHeapBlock * heapBlock)",
          "169: {",
          "170:     NoMemProtectHeapDeletePlus(GetAllocPlusSize(heapBlock->objectCount), heapBlock);",
          "171: }",
          "173: LargeHeapBlock::LargeHeapBlock(__in char * address, size_t pageCount, Segment * segment, uint objectCount, LargeHeapBucket* bucket)",
          "174:     : HeapBlock(LargeBlockType), pageCount(pageCount), allocAddressEnd(address), objectCount(objectCount), bucket(bucket), freeList(this)",
          "175: #if defined(RECYCLER_PAGE_HEAP) && defined(STACK_BACK_TRACE)",
          "176:     , pageHeapAllocStack(nullptr), pageHeapFreeStack(nullptr)",
          "177: #endif",
          "178: #if DBG && GLOBAL_ENABLE_WRITE_BARRIER",
          "179:     ,wbVerifyBits(&HeapAllocator::Instance)",
          "180: #endif",
          "181: {",
          "182:     Assert(address != nullptr);",
          "183:     Assert(pageCount != 0);",
          "184:     Assert(objectCount != 0);",
          "185:     Assert(lastCollectAllocCount == 0);",
          "186:     Assert(finalizeCount == 0);",
          "187:     Assert(next == nullptr);",
          "188:     Assert(!hasPartialFreeObjects);",
          "190:     this->address = address;",
          "191:     this->segment = segment;",
          "192: #if ENABLE_CONCURRENT_GC",
          "193:     this->isPendingConcurrentSweep = false;",
          "194: #endif",
          "195:     this->addressEnd = this->address + this->pageCount * AutoSystemInfo::PageSize;",
          "197:     RECYCLER_PERF_COUNTER_INC(LargeHeapBlockCount);",
          "198:     RECYCLER_PERF_COUNTER_ADD(LargeHeapBlockPageSize, pageCount * AutoSystemInfo::PageSize);",
          "199: }",
          "201: LargeHeapBlock::~LargeHeapBlock()",
          "202: {",
          "203:     AssertMsg(this->segment == nullptr || this->heapInfo->recycler->recyclerLargeBlockPageAllocator.IsClosed(),",
          "204:         \"ReleasePages needs to be called before delete\");",
          "205:     RECYCLER_PERF_COUNTER_DEC(LargeHeapBlockCount);",
          "207: #if defined(RECYCLER_PAGE_HEAP) && defined(STACK_BACK_TRACE)",
          "208:     if (this->pageHeapAllocStack != nullptr)",
          "209:     {",
          "210:         if (this->pageHeapAllocStack != s_StackTraceAllocFailed)",
          "211:         {",
          "212:             this->pageHeapAllocStack->Delete(&NoThrowHeapAllocator::Instance);",
          "213:         }",
          "214:         this->pageHeapAllocStack = nullptr;",
          "215:     }",
          "219:     if (this->pageHeapFreeStack != nullptr)",
          "220:     {",
          "221:         this->pageHeapFreeStack->Delete(&NoThrowHeapAllocator::Instance);",
          "222:         this->pageHeapFreeStack = nullptr;",
          "223:     }",
          "224: #endif",
          "225: }",
          "227: Recycler *",
          "228: LargeHeapBlock::GetRecycler() const",
          "229: {",
          "230:     return this->bucket->heapInfo->recycler;",
          "231: }",
          "233: LargeObjectHeader **",
          "234: LargeHeapBlock::HeaderList()",
          "235: {",
          "237:     return (LargeObjectHeader **)(((byte *)this) + sizeof(LargeHeapBlock));",
          "238: }",
          "240: void",
          "241: LargeHeapBlock::FinalizeAllObjects()",
          "242: {",
          "243:     if (this->finalizeCount != 0)",
          "244:     {",
          "245:         DebugOnly(uint processedCount = 0);",
          "246:         for (uint i = 0; i < allocCount; i++)",
          "247:         {",
          "248:             LargeObjectHeader * header = this->GetHeader(i);",
          "249:             if (header == nullptr || ((header->GetAttributes(this->heapInfo->recycler->Cookie) & FinalizeBit) == 0))",
          "250:             {",
          "251:                 continue;",
          "252:             }",
          "254:             FinalizableObject * finalizableObject = ((FinalizableObject *)header->GetAddress());",
          "256:             finalizableObject->Finalize(true);",
          "257:             finalizableObject->Dispose(true);",
          "258: #ifdef RECYCLER_FINALIZE_CHECK",
          "259:             this->heapInfo->liveFinalizableObjectCount--;",
          "260: #endif",
          "261:             DebugOnly(processedCount++);",
          "262:         }",
          "264:         while (pendingDisposeObject != nullptr)",
          "265:         {",
          "266:             LargeObjectHeader * header = pendingDisposeObject;",
          "267:             pendingDisposeObject = header->GetNext(this->heapInfo->recycler->Cookie);",
          "268:             Assert(header->GetAttributes(this->heapInfo->recycler->Cookie) & FinalizeBit);",
          "269:             Assert(this->HeaderList()[header->objectIndex] == nullptr);",
          "271:             void * objectAddress = header->GetAddress();",
          "272:             ((FinalizableObject *)objectAddress)->Dispose(true);",
          "273: #ifdef RECYCLER_FINALIZE_CHECK",
          "274:             this->heapInfo->liveFinalizableObjectCount--;",
          "275:             this->heapInfo->pendingDisposableObjectCount--;",
          "276: #endif",
          "277:             DebugOnly(processedCount++);",
          "278:         }",
          "280:         Assert(this->finalizeCount == processedCount);",
          "281:     }",
          "282: }",
          "285: void",
          "286: LargeHeapBlock::ReleasePagesShutdown(Recycler * recycler)",
          "287: {",
          "288: #if DBG",
          "289:     recycler->heapBlockMap.ClearHeapBlock(this->address, this->pageCount);",
          "292:     Assert(recycler->recyclerLargeBlockPageAllocator.IsClosed());",
          "293: #endif",
          "294: }",
          "296: void",
          "297: LargeHeapBlock::ReleasePagesSweep(Recycler * recycler)",
          "298: {",
          "299:     recycler->heapBlockMap.ClearHeapBlock(this->address, this->pageCount);",
          "301:     ReleasePages(recycler);",
          "302: }",
          "304: #ifdef RECYCLER_PAGE_HEAP",
          "305: _NOINLINE",
          "306: void LargeHeapBlock::VerifyPageHeapPattern()",
          "307: {",
          "308:     Assert(InPageHeapMode());",
          "309:     Assert(this->allocCount > 0);",
          "310:     byte* objectEndAddress = (byte*)this->allocAddressEnd;",
          "311:     byte* addrEnd = (byte*)this->addressEnd;",
          "313:     for (int i = 0; objectEndAddress + i < (byte*)addrEnd; i++)",
          "314:     {",
          "315:         byte current = objectEndAddress[i];",
          "316:         if (current != 0xF0u)",
          "317:         {",
          "318:             Assert(false);",
          "319:             ReportFatalException(NULL, E_FAIL, Fatal_Recycler_MemoryCorruption, 2);",
          "320:         }",
          "321:     }",
          "323: }",
          "324: #endif",
          "326: void",
          "327: LargeHeapBlock::ReleasePages(Recycler * recycler)",
          "328: {",
          "329:     Assert(segment != nullptr);",
          "331:     char* blockStartAddress = this->address;",
          "332:     size_t realPageCount = this->pageCount;",
          "333: #ifdef RECYCLER_PAGE_HEAP",
          "334:     if (InPageHeapMode())",
          "335:     {",
          "336:         Assert(((LargeObjectHeader*)this->address)->isPageHeapFillVerified || this->allocCount == 0);",
          "337:         if (this->allocCount > 0) // in case OOM while adding heapblock to heapBlockMap, we release page before setting the pattern",
          "338:         {",
          "339:             Assert(this->allocCount == 1); // one object per heapblock in pageheap",
          "340:             VerifyPageHeapPattern();",
          "341:         }",
          "343:         if (guardPageAddress != nullptr)",
          "344:         {",
          "345:             if (this->pageHeapMode == PageHeapMode::PageHeapModeBlockStart)",
          "346:             {",
          "347:                 blockStartAddress = guardPageAddress;",
          "348:             }",
          "349:             realPageCount = this->actualPageCount;",
          "350:             size_t guardPageCount = this->actualPageCount - this->pageCount;",
          "352:             DWORD oldProtect;",
          "353:             BOOL ret = ::VirtualProtect(guardPageAddress, AutoSystemInfo::PageSize * guardPageCount, PAGE_READWRITE, &oldProtect);",
          "354:             Assert(ret && oldProtect == PAGE_NOACCESS);",
          "355:         }",
          "356:     }",
          "357: #endif",
          "359: #ifdef RECYCLER_FREE_MEM_FILL",
          "360:     memset(this->address, DbgMemFill, AutoSystemInfo::PageSize * pageCount);",
          "361: #endif",
          "362:     IdleDecommitPageAllocator* pageAllocator = recycler->GetRecyclerLargeBlockPageAllocator();",
          "363:     pageAllocator->Release(blockStartAddress, realPageCount, segment);",
          "364:     RECYCLER_PERF_COUNTER_SUB(LargeHeapBlockPageSize, pageCount * AutoSystemInfo::PageSize);",
          "366:     this->segment = nullptr;",
          "367: }",
          "369: BOOL",
          "370: LargeHeapBlock::IsValidObject(void* objectAddress)",
          "371: {",
          "372:     LargeObjectHeader * header = GetHeader(objectAddress);",
          "373:     return ((char *)header >= this->address && header->objectIndex < this->allocCount && this->HeaderList()[header->objectIndex] == header);",
          "374: }",
          "376: #if DBG",
          "377: BOOL",
          "378: LargeHeapBlock::IsFreeObject(void * objectAddress)",
          "379: {",
          "380:     LargeObjectHeader * header = GetHeader(objectAddress);",
          "381:     return ((char *)header >= this->address && header->objectIndex < this->allocCount && this->GetHeader(header->objectIndex) == nullptr);",
          "382: }",
          "383: #endif",
          "385: bool",
          "386: LargeHeapBlock::TryGetAttributes(void* objectAddress, unsigned char * pAttr)",
          "387: {",
          "388:     return this->TryGetAttributes(GetHeader(objectAddress), pAttr);",
          "389: }",
          "391: bool",
          "392: LargeHeapBlock::TryGetAttributes(LargeObjectHeader * header, unsigned char * pAttr)",
          "393: {",
          "394:     if ((char *)header < this->address)",
          "395:     {",
          "396:         return false;",
          "397:     }",
          "399:     uint index = header->objectIndex;",
          "401:     if (index >= this->allocCount)",
          "402:     {",
          "404:         return false;",
          "405:     }",
          "407:     if (this->HeaderList()[index] != header)",
          "408:     {",
          "410:         return false;",
          "411:     }",
          "413:     if (this->InPageHeapMode())",
          "414:     {",
          "415:         this->VerifyPageHeapPattern();",
          "416:     }",
          "419:     return true;",
          "420: }",
          "422: size_t",
          "423: LargeHeapBlock::GetPagesNeeded(size_t size, bool multiplyRequest)",
          "424: {",
          "425:     if (multiplyRequest)",
          "426:     {",
          "427:         size = AllocSizeMath::Mul(size, 4);",
          "428:     }",
          "430:     uint pageSize = AutoSystemInfo::PageSize;",
          "431:     size = AllocSizeMath::Add(size, sizeof(LargeObjectHeader) + (pageSize - 1));",
          "432:     if (size == (size_t)-1)",
          "433:     {",
          "434:         return 0;",
          "435:     }",
          "436:     size_t pageCount = size / pageSize;",
          "437:     return pageCount;",
          "438: }",
          "440: char*",
          "441: LargeHeapBlock::TryAllocFromFreeList(size_t size, ObjectInfoBits attributes)",
          "442: {",
          "443:     Assert((attributes & InternalObjectInfoBitMask) == attributes);",
          "445:     LargeHeapBlockFreeListEntry** prev = &this->freeList.entries;",
          "446:     LargeHeapBlockFreeListEntry* freeListEntry = this->freeList.entries;",
          "448:     char* memBlock = nullptr;",
          "451:     while (freeListEntry)",
          "452:     {",
          "453:         LargeHeapBlockFreeListEntry* next = freeListEntry->next;",
          "454:         LargeHeapBlock* heapBlock = freeListEntry->heapBlock;",
          "456:         if (freeListEntry->objectSize >= size)",
          "457:         {",
          "458:             memBlock = heapBlock->AllocFreeListEntry(size, attributes, freeListEntry);",
          "459:             if (memBlock)",
          "460:             {",
          "461:                 (*prev) = next;",
          "463:                 break;",
          "464:             }",
          "465:         }",
          "467:         prev = &freeListEntry->next;",
          "468:         freeListEntry = freeListEntry->next;",
          "469:     }",
          "471:     if (this->freeList.entries == nullptr)",
          "472:     {",
          "473:         this->bucket->UnregisterFreeList(&this->freeList);",
          "474:     }",
          "476:     return memBlock;",
          "477: }",
          "479: char*",
          "480: LargeHeapBlock::AllocFreeListEntry(size_t size, ObjectInfoBits attributes, LargeHeapBlockFreeListEntry* entry)",
          "481: {",
          "482:     Assert((attributes & InternalObjectInfoBitMask) == attributes);",
          "483:     Assert(HeapInfo::IsAlignedSize(size));",
          "484:     AssertMsg((attributes & TrackBit) == 0, \"Large tracked object collection not implemented\");",
          "485:     Assert(entry->heapBlock == this);",
          "486:     Assert(entry->headerIndex < this->objectCount);",
          "487:     Assert(this->HeaderList()[entry->headerIndex] == nullptr);",
          "489:     uint headerIndex = entry->headerIndex;",
          "490:     size_t originalSize = entry->objectSize;",
          "492:     LargeObjectHeader * header = (LargeObjectHeader *) entry;",
          "494:     char * allocObject = ((char*) entry) + sizeof(LargeObjectHeader);       // shouldn't overflow",
          "495:     char * newAllocAddressEnd = allocObject + size;",
          "496:     char * originalAllocEnd = allocObject + originalSize;",
          "497:     if (newAllocAddressEnd > addressEnd || newAllocAddressEnd < allocObject || (originalAllocEnd < newAllocAddressEnd))",
          "498:     {",
          "499:         return nullptr;",
          "500:     }",
          "502: #ifdef RECYCLER_MEMORY_VERIFY",
          "503:     if (this->heapInfo->recycler->VerifyEnabled())",
          "504:     {",
          "505:         this->heapInfo->recycler->VerifyCheckFill(allocObject , originalSize);",
          "506:     }",
          "507: #endif",
          "509:     memset(entry, 0, sizeof(LargeObjectHeader) + originalSize);",
          "511: #ifdef RECYCLER_MEMORY_VERIFY",
          "514:     if (this->heapInfo->recycler->VerifyEnabled())",
          "515:     {",
          "516:         memset(allocObject, Recycler::VerifyMemFill, originalSize);",
          "517:     }",
          "518: #endif",
          "520: #if DBG",
          "521:     LargeAllocationVerboseTrace(this->heapInfo->recycler->GetRecyclerFlagsTable(), _u(\"Allocated object of size 0x%x in from free list entry at address 0x%p\\n\"), size, allocObject);",
          "522: #endif",
          "524:     Assert(allocCount <= objectCount);",
          "526:     header->objectIndex = headerIndex;",
          "527:     header->objectSize = originalSize;",
          "528: #ifdef RECYCLER_WRITE_BARRIER",
          "529:     header->hasWriteBarrier = (attributes & WithBarrierBit) == WithBarrierBit;",
          "530: #endif",
          "531:     header->SetAttributes(this->heapInfo->recycler->Cookie, (attributes & StoredObjectInfoBitMask));",
          "532:     header->markOnOOMRescan = false;",
          "533:     header->SetNext(this->heapInfo->recycler->Cookie, nullptr);",
          "535:     HeaderList()[headerIndex] = header;",
          "536:     finalizeCount += ((attributes & FinalizeBit) != 0);",
          "538: #ifdef RECYCLER_FINALIZE_CHECK",
          "539:     if (attributes & FinalizeBit)",
          "540:     {",
          "541:         HeapInfo * heapInfo = this->heapInfo;",
          "542:         heapInfo->liveFinalizableObjectCount++;",
          "543:         heapInfo->newFinalizableObjectCount++;",
          "544:     }",
          "545: #endif",
          "547:     return allocObject;",
          "548: }",
          "550: char*",
          "551: LargeHeapBlock::Alloc(size_t size, ObjectInfoBits attributes)",
          "552: {",
          "553:     Assert(HeapInfo::IsAlignedSize(size) || InPageHeapMode());",
          "554:     Assert((attributes & InternalObjectInfoBitMask) == attributes);",
          "555:     AssertMsg((attributes & TrackBit) == 0, \"Large tracked object collection not implemented\");",
          "557:     LargeObjectHeader * header = (LargeObjectHeader *)allocAddressEnd;",
          "558: #if ENABLE_PARTIAL_GC && ENABLE_CONCURRENT_GC",
          "559:     Assert(!IsPartialSweptHeader(header));",
          "560: #endif",
          "561:     char * allocObject = allocAddressEnd + sizeof(LargeObjectHeader);       // shouldn't overflow",
          "562:     char * newAllocAddressEnd = allocObject + size;",
          "563:     if (newAllocAddressEnd > addressEnd || newAllocAddressEnd < allocObject)",
          "564:     {",
          "565:         return nullptr;",
          "566:     }",
          "568:     Recycler* recycler = this->heapInfo->recycler;",
          "569: #if DBG",
          "570:     LargeAllocationVerboseTrace(recycler->GetRecyclerFlagsTable(), _u(\"Allocated object of size 0x%x in existing heap block at address 0x%p\\n\"), size, allocObject);",
          "571: #endif",
          "573:     Assert(allocCount < objectCount);",
          "574:     allocAddressEnd = newAllocAddressEnd;",
          "575: #ifdef RECYCLER_ZERO_MEM_CHECK",
          "576:     recycler->VerifyZeroFill(header, sizeof(LargeObjectHeader));",
          "577: #endif",
          "578: #ifdef RECYCLER_MEMORY_VERIFY",
          "579:     if (recycler->VerifyEnabled())",
          "580:     {",
          "581:         memset(header, 0, sizeof(LargeObjectHeader));",
          "582:     }",
          "583: #endif",
          "585:     header->objectIndex = allocCount;",
          "586:     header->objectSize = size;",
          "587: #ifdef RECYCLER_WRITE_BARRIER",
          "588:     header->hasWriteBarrier = (attributes&WithBarrierBit) == WithBarrierBit;",
          "589: #endif",
          "590:     header->SetAttributes(recycler->Cookie, (attributes & StoredObjectInfoBitMask));",
          "591:     HeaderList()[allocCount++] = header;",
          "592:     finalizeCount += ((attributes & FinalizeBit) != 0);",
          "594: #ifdef RECYCLER_FINALIZE_CHECK",
          "595:     if (attributes & FinalizeBit)",
          "596:     {",
          "597:         HeapInfo * heapInfo = this->heapInfo;",
          "598:         heapInfo->liveFinalizableObjectCount++;",
          "599:         heapInfo->newFinalizableObjectCount++;",
          "600:     }",
          "601: #endif",
          "603:     return allocObject;",
          "604: }",
          "606: template <bool doSpecialMark>",
          "607: _NOINLINE",
          "608: void",
          "609: LargeHeapBlock::Mark(void* objectAddress, MarkContext * markContext)",
          "610: {",
          "611:     LargeObjectHeader * header = GetHeader(objectAddress);",
          "613:     unsigned char attributes = ObjectInfoBits::NoBit;",
          "614:     if (!this->TryGetAttributes(header, &attributes))",
          "615:     {",
          "616:         return;",
          "617:     }",
          "619:     DUMP_OBJECT_REFERENCE(markContext->GetRecycler(), objectAddress);",
          "621:     size_t objectSize = header->objectSize;",
          "622:     if (this->InPageHeapMode())",
          "623:     {",
          "625:         objectSize = HeapInfo::RoundObjectSize(objectSize);",
          "626:         if (objectSize == 0)",
          "627:         {",
          "629:             Assert((attributes & FinalizeBit) == 0);",
          "630:             return;",
          "631:         }",
          "632:     }",
          "634:     if (!UpdateAttributesOfMarkedObjects<doSpecialMark>(markContext, objectAddress, objectSize, attributes,",
          "635:         [&](unsigned char attributes) { header->SetAttributes(this->heapInfo->recycler->Cookie, attributes); }))",
          "636:     {",
          "638:         this->SetNeedOOMRescan(markContext->GetRecycler());",
          "641:         if (this->GetPageCount() != 1)",
          "642:         {",
          "645:             header->markOnOOMRescan = true;",
          "646:         }",
          "647:     }",
          "648: }",
          "650: template void LargeHeapBlock::Mark<true>(void* objectAddress, MarkContext * markContext);",
          "651: template void LargeHeapBlock::Mark<false>(void* objectAddress, MarkContext * markContext);",
          "653: bool",
          "654: LargeHeapBlock::TestObjectMarkedBit(void* objectAddress)",
          "655: {",
          "656:     Assert(IsValidObject(objectAddress));",
          "658:     LargeObjectHeader* pHeader = nullptr;",
          "660:     if (GetObjectHeader(objectAddress, &pHeader))",
          "661:     {",
          "662:         Recycler* recycler = this->heapInfo->recycler;",
          "664:         return recycler->heapBlockMap.IsMarked(objectAddress);",
          "665:     }",
          "667:     return FALSE;",
          "668: }",
          "670: void",
          "671: LargeHeapBlock::SetObjectMarkedBit(void* objectAddress)",
          "672: {",
          "673:     Assert(IsValidObject(objectAddress));",
          "675:     LargeObjectHeader* pHeader = nullptr;",
          "677:     if (GetObjectHeader(objectAddress, &pHeader))",
          "678:     {",
          "679:         Recycler* recycler = this->heapInfo->recycler;",
          "681:         recycler->heapBlockMap.SetMark(objectAddress);",
          "682:     }",
          "683: }",
          "685: bool",
          "686: LargeHeapBlock::FindImplicitRootObject(void* objectAddress, Recycler * recycler, RecyclerHeapObjectInfo& heapObject)",
          "687: {",
          "688:     if (!IsValidObject(objectAddress))",
          "689:     {",
          "690:         return false;",
          "691:     }",
          "693:     LargeObjectHeader* pHeader = nullptr;",
          "695:     if (!GetObjectHeader(objectAddress, &pHeader))",
          "696:     {",
          "697:         return false;",
          "698:     }",
          "700: #ifdef LARGEHEAPBLOCK_ENCODING",
          "701:     heapObject = RecyclerHeapObjectInfo(objectAddress, recycler, this, nullptr);",
          "702:     heapObject.SetLargeHeapBlockHeader(pHeader);",
          "703: #else",
          "704:     heapObject = RecyclerHeapObjectInfo(objectAddress, recycler, this, pHeader->GetAttributesPtr());",
          "705: #endif",
          "706:     return true;",
          "707: }",
          "709: bool",
          "710: LargeHeapBlock::FindHeapObject(void* objectAddress, Recycler * recycler, FindHeapObjectFlags, RecyclerHeapObjectInfo& heapObject)",
          "711: {",
          "713:     return FindImplicitRootObject(objectAddress, recycler, heapObject);",
          "714: }",
          "716: bool",
          "717: LargeHeapBlock::GetObjectHeader(void* objectAddress, LargeObjectHeader** ppHeader)",
          "718: {",
          "719:     (*ppHeader) = nullptr;",
          "721:     LargeObjectHeader * header = GetHeader(objectAddress);",
          "722:     if ((char *)header < this->address)",
          "723:     {",
          "724:         return false;",
          "725:     }",
          "727:     uint index = header->objectIndex;",
          "729:     if (this->HeaderList()[index] != header)",
          "730:     {",
          "732:         return false;",
          "733:     }",
          "735:     Assert(index < this->allocCount);",
          "736:     (*ppHeader) = header;",
          "737:     return true;",
          "738: }",
          "740: void",
          "741: LargeHeapBlock::ResetMarks(ResetMarkFlags flags, Recycler* recycler)",
          "742: {",
          "743:     Assert(!this->needOOMRescan);",
          "746:     this->lastCollectAllocCount = this->allocCount;",
          "748:     Assert(this->GetMarkCount() == 0);",
          "750: #if ENABLE_CONCURRENT_GC",
          "751:     Assert(!this->isPendingConcurrentSweep);",
          "752: #endif",
          "754:     if (flags & ResetMarkFlags_ScanImplicitRoot)",
          "755:     {",
          "756:         for (uint objectIndex = 0; objectIndex < allocCount; objectIndex++)",
          "757:         {",
          "759:             LargeObjectHeader * header = this->GetHeader(objectIndex);",
          "761:             if (header == nullptr)",
          "762:             {",
          "763:                 continue;",
          "764:             }",
          "767:             if ((header->GetAttributes(this->heapInfo->recycler->Cookie) & ImplicitRootBit) != 0)",
          "768:             {",
          "769:                 recycler->heapBlockMap.SetMark(header->GetAddress());",
          "770:             }",
          "771:         }",
          "772:     }",
          "773: }",
          "775: LargeObjectHeader *",
          "776: LargeHeapBlock::GetHeader(void * objectAddress)",
          "777: {",
          "778:     Assert(objectAddress >= this->address && objectAddress < this->addressEnd);",
          "779:     return GetHeaderFromAddress(objectAddress);",
          "780: }",
          "782: LargeObjectHeader *",
          "783: LargeHeapBlock::GetHeaderFromAddress(void * objectAddress)",
          "784: {",
          "785:     return (LargeObjectHeader*)(((char *)objectAddress) - sizeof(LargeObjectHeader));",
          "786: }",
          "788: byte *",
          "789: LargeHeapBlock::GetRealAddressFromInterior(void * interiorAddress)",
          "790: {",
          "791:     for (uint i = 0; i < allocCount; i++)",
          "792:     {",
          "793:         LargeObjectHeader * header = this->HeaderList()[i];",
          "795: #if ENABLE_PARTIAL_GC && ENABLE_CONCURRENT_GC",
          "796:         if (header != nullptr && !IsPartialSweptHeader(header))",
          "797: #else",
          "798:         if (header != nullptr)",
          "799: #endif",
          "800:         {",
          "801:             Assert(header->objectIndex == i);",
          "802:             byte * startAddress = (byte *)header->GetAddress();",
          "803:             if (startAddress <= interiorAddress && (startAddress + header->objectSize > interiorAddress))",
          "804:             {",
          "805:                 return startAddress;",
          "806:             }",
          "807:         }",
          "808:     }",
          "810:     return nullptr;",
          "811: }",
          "813: #ifdef RECYCLER_VERIFY_MARK",
          "815: void",
          "816: LargeHeapBlock::VerifyMark()",
          "817: {",
          "818:     Assert(!this->needOOMRescan);",
          "819:     Recycler* recycler = this->heapInfo->recycler;",
          "821:     for (uint i = 0; i < allocCount; i++)",
          "822:     {",
          "823:         LargeObjectHeader * header = this->GetHeader(i);",
          "824:         if (header == nullptr)",
          "825:         {",
          "826:             continue;",
          "827:         }",
          "829:         char * objectAddress = (char *)header->GetAddress();",
          "830:         if (!recycler->heapBlockMap.IsMarked(objectAddress))",
          "831:         {",
          "832:             continue;",
          "833:         }",
          "835:         unsigned char attributes = header->GetAttributes(this->heapInfo->recycler->Cookie);",
          "837:         Assert((attributes & NewFinalizeBit) == 0);",
          "839:         if ((attributes & LeafBit) != 0)",
          "840:         {",
          "841:             continue;",
          "842:         }",
          "844:         Assert(!header->markOnOOMRescan);",
          "846:         char * objectAddressEnd = objectAddress + header->objectSize;",
          "848:         while (objectAddress + sizeof(void *) <= objectAddressEnd)",
          "849:         {",
          "850:             void* target = *(void **)objectAddress;",
          "852:             if (recycler->VerifyMark(objectAddress, target))",
          "853:             {",
          "854: #if DBG && GLOBAL_ENABLE_WRITE_BARRIER",
          "855:                 if (CONFIG_FLAG(ForceSoftwareWriteBarrier) && CONFIG_FLAG(VerifyBarrierBit))",
          "856:                 {",
          "857:                     this->WBVerifyBitIsSet(objectAddress);",
          "858:                 }",
          "859: #endif",
          "860:             }",
          "862:             objectAddress += sizeof(void *);",
          "863:         }",
          "864:     }",
          "865: }",
          "867: bool",
          "868: LargeHeapBlock::VerifyMark(void * objectAddress, void* target)",
          "869: {",
          "870:     LargeObjectHeader * header = GetHeader(target);",
          "872:     if ((char *)header < this->address)",
          "873:     {",
          "874:         return false;",
          "875:     }",
          "877:     uint index = header->objectIndex;",
          "879:     if (index >= this->allocCount)",
          "880:     {",
          "882:         return false;",
          "883:     }",
          "885:     if (this->HeaderList()[index] != header)",
          "886:     {",
          "888:         return false;",
          "889:     }",
          "891:     bool isMarked = this->heapInfo->recycler->heapBlockMap.IsMarked(target);",
          "893: #if DBG",
          "894:     if (!isMarked)",
          "895:     {",
          "896:         PrintVerifyMarkFailure(this->GetRecycler(), (char*)objectAddress, (char*)target);",
          "897:     }",
          "898: #else",
          "899:     if (!isMarked)",
          "900:     {",
          "901:         DebugBreak();",
          "902:     }",
          "903: #endif",
          "904:     return isMarked;",
          "905: }",
          "907: #endif",
          "909: void",
          "910: LargeHeapBlock::ScanInitialImplicitRoots(Recycler * recycler)",
          "911: {",
          "912:     Assert(recycler->enableScanImplicitRoots);",
          "913:     const HeapBlockMap& heapBlockMap = recycler->heapBlockMap;",
          "914:     for (uint objectIndex = 0; objectIndex < allocCount; objectIndex++)",
          "915:     {",
          "917:         LargeObjectHeader * header = this->GetHeader(objectIndex);",
          "919:         if (header == nullptr)",
          "920:         {",
          "921:             continue;",
          "922:         }",
          "925:         if ((header->GetAttributes(this->heapInfo->recycler->Cookie) & LeafBit) != 0)",
          "926:         {",
          "927:             continue;",
          "928:         }",
          "930:         char * objectAddress = (char *)header->GetAddress();",
          "933:         if (!heapBlockMap.IsMarked(objectAddress))",
          "934:         {",
          "935:             continue;",
          "936:         }",
          "939:         DUMP_IMPLICIT_ROOT(recycler, objectAddress);",
          "941:         if (this->InPageHeapMode())",
          "942:         {",
          "943:             size_t objectSize = header->objectSize;",
          "945:             objectSize = HeapInfo::RoundObjectSize(objectSize);",
          "946:             if (objectSize > 0) // otherwize the object total size is less than a pointer size",
          "947:             {",
          "948:                 recycler->ScanObjectInlineInterior((void **)objectAddress, objectSize);",
          "949:             }",
          "950:         }",
          "951:         else",
          "952:         {",
          "953:             recycler->ScanObjectInlineInterior((void **)objectAddress, header->objectSize);",
          "954:         }",
          "955:     }",
          "956: }",
          "958: void",
          "959: LargeHeapBlock::ScanNewImplicitRoots(Recycler * recycler)",
          "960: {",
          "961:     Assert(recycler->enableScanImplicitRoots);",
          "963:     uint objectIndex = 0;",
          "964:     HeapBlockMap& heapBlockMap = recycler->heapBlockMap;",
          "965:     while (objectIndex < allocCount)",
          "966:     {",
          "968:         LargeObjectHeader * header = this->GetHeader(objectIndex);",
          "969:         objectIndex++;",
          "972:         if (header == nullptr)",
          "973:         {",
          "974:             continue;",
          "975:         }",
          "978:         if ((header->GetAttributes(this->heapInfo->recycler->Cookie) & ImplicitRootBit) == 0)",
          "979:         {",
          "980:             continue;",
          "981:         }",
          "983:         char * objectAddress = (char *)header->GetAddress();",
          "985:         bool marked = heapBlockMap.TestAndSetMark(objectAddress);",
          "986:         if (!marked)",
          "987:         {",
          "988:             DUMP_IMPLICIT_ROOT(recycler, objectAddress);",
          "991:             if ((header->GetAttributes(this->heapInfo->recycler->Cookie) & LeafBit) != 0)",
          "992:             {",
          "993:                 continue;",
          "994:             }",
          "996:             if (this->InPageHeapMode())",
          "997:             {",
          "998:                 size_t objectSize = header->objectSize;",
          "1000:                 objectSize = HeapInfo::RoundObjectSize(objectSize);",
          "1001:                 if (objectSize > 0) // otherwize the object total size is less than a pointer size",
          "1002:                 {",
          "1003:                     recycler->ScanObjectInlineInterior((void **)objectAddress, objectSize);",
          "1004:                 }",
          "1005:             }",
          "1006:             else",
          "1007:             {",
          "1009:                 recycler->ScanObjectInlineInterior((void **)objectAddress, header->objectSize);",
          "1010:             }",
          "1011:         }",
          "1012:     }",
          "1013: }",
          "1015: #if ENABLE_CONCURRENT_GC",
          "1016: bool LargeHeapBlock::IsPageDirty(char* page, RescanFlags flags, bool isWriteBarrier)",
          "1017: {",
          "1018: #ifdef RECYCLER_WRITE_BARRIER",
          "1020:     if (CONFIG_FLAG(WriteBarrierTest))",
          "1021:     {",
          "1022:         Assert(isWriteBarrier);",
          "1023:     }",
          "1024:     if (isWriteBarrier)",
          "1025:     {",
          "1026:         return (RecyclerWriteBarrierManager::GetWriteBarrier(page) & DIRTYBIT) == DIRTYBIT;",
          "1027:     }",
          "1028: #endif",
          "1030: #ifdef RECYCLER_WRITE_WATCH",
          "1031:     if (!CONFIG_FLAG(ForceSoftwareWriteBarrier))",
          "1032:     {",
          "1033:         ULONG_PTR count = 1;",
          "1034:         DWORD pageSize = AutoSystemInfo::PageSize;",
          "1035:         DWORD const writeWatchFlags = (flags & RescanFlags_ResetWriteWatch ? WRITE_WATCH_FLAG_RESET : 0);",
          "1036:         void * written = nullptr;",
          "1037:         UINT ret = GetWriteWatch(writeWatchFlags, page, AutoSystemInfo::PageSize, &written, &count, &pageSize);",
          "1038:         bool isDirty = (ret != 0) || (count == 1);",
          "1039:         return isDirty;",
          "1040:     }",
          "1041:     else",
          "1042:     {",
          "1043:         Js::Throw::FatalInternalError();",
          "1044:     }",
          "1045: #else",
          "1046:     Js::Throw::FatalInternalError();",
          "1047: #endif",
          "1048: }",
          "1049: #endif",
          "1051: #if ENABLE_CONCURRENT_GC",
          "1052: bool",
          "1053: LargeHeapBlock::RescanOnePage(Recycler * recycler, RescanFlags flags)",
          "1054: #else",
          "1055: bool",
          "1056: LargeHeapBlock::RescanOnePage(Recycler * recycler)",
          "1057: #endif",
          "1058: {",
          "1059:     Assert(this->GetPageCount() == 1);",
          "1060:     bool const oldNeedOOMRescan = this->needOOMRescan;",
          "1063:     this->needOOMRescan = false;",
          "1065: #if ENABLE_CONCURRENT_GC",
          "1067:     if (!oldNeedOOMRescan)",
          "1068:     {",
          "1069:         if (recycler->inEndMarkOnLowMemory)",
          "1070:         {",
          "1072:             return false;",
          "1073:         }",
          "1077:         LargeObjectHeader* header = this->GetHeader(0u);",
          "1078:         if ((header->GetAttributes(this->heapInfo->recycler->Cookie) & LeafBit) == LeafBit)",
          "1079:         {",
          "1080:             return false;",
          "1081:         }",
          "1082:         bool hasWriteBarrier = false;",
          "1083: #ifdef RECYCLER_WRITE_BARRIER",
          "1084:         hasWriteBarrier = header->hasWriteBarrier;",
          "1085: #endif",
          "1086:         if (!IsPageDirty(this->GetBeginAddress(), flags, hasWriteBarrier))",
          "1087:         {",
          "1088:             return false;",
          "1089:         }",
          "1090:     }",
          "1091: #else",
          "1093:     Assert(oldNeedOOMRescan);",
          "1094: #endif",
          "1096:     RECYCLER_STATS_INC(recycler, markData.rescanLargePageCount);",
          "1098:     for (uint objectIndex = 0; objectIndex < allocCount; objectIndex++)",
          "1099:     {",
          "1101:         LargeObjectHeader * header = this->GetHeader(objectIndex);",
          "1104:         if (header == nullptr)",
          "1105:         {",
          "1106:             continue;",
          "1107:         }",
          "1109:         char * objectAddress = (char *)header->GetAddress();",
          "1112:         if (!recycler->heapBlockMap.IsMarked(objectAddress))",
          "1113:         {",
          "1114:             continue;",
          "1115:         }",
          "1117:         unsigned char attributes = header->GetAttributes(this->heapInfo->recycler->Cookie);",
          "1119: #ifdef RECYCLER_STATS",
          "1120:         if (((attributes & FinalizeBit) != 0) && ((attributes & NewFinalizeBit) != 0))",
          "1121:         {",
          "1125:             RECYCLER_STATS_INC(recycler, finalizeCount);",
          "1126:             header->SetAttributes(this->heapInfo->recycler->Cookie, (attributes & ~NewFinalizeBit));",
          "1127:         }",
          "1128: #endif",
          "1131:         if ((attributes & LeafBit) != 0)",
          "1132:         {",
          "1133:             continue;",
          "1134:         }",
          "1136:         RECYCLER_STATS_INC(recycler, markData.rescanLargeObjectCount);",
          "1137:         RECYCLER_STATS_ADD(recycler, markData.rescanLargeByteCount, header->objectSize);",
          "1139:         size_t objectSize = header->objectSize;",
          "1140:         if (this->InPageHeapMode())",
          "1141:         {",
          "1143:             objectSize = HeapInfo::RoundObjectSize(objectSize);",
          "1144:         }",
          "1145:         if (objectSize > 0) // otherwize the object total size is less than a pointer size",
          "1146:         {",
          "1147:             if (!recycler->AddMark(objectAddress, objectSize))",
          "1148:             {",
          "1149:                 this->SetNeedOOMRescan(recycler);",
          "1150:             }",
          "1151:         }",
          "1152:     }",
          "1153:     return true;",
          "1154: }",
          "1156: size_t",
          "1157: LargeHeapBlock::Rescan(Recycler * recycler, bool isPartialSwept, RescanFlags flags)",
          "1158: {",
          "1160:     this->lastCollectAllocCount = this->allocCount;",
          "1162: #if ENABLE_CONCURRENT_GC",
          "1163:     Assert(recycler->collectionState != CollectionStateConcurrentFinishMark || (flags & RescanFlags_ResetWriteWatch));",
          "1164:     if (this->GetPageCount() == 1)",
          "1165:     {",
          "1166:         return RescanOnePage(recycler, flags);",
          "1167:     }",
          "1170:     if (recycler->collectionState != CollectionStateConcurrentFinishMark && recycler->IsConcurrentMarkState())",
          "1171:     {",
          "1174:         return 0;",
          "1175:     }",
          "1176:     return RescanMultiPage(recycler, flags);",
          "1177: #else",
          "1178:     return this->GetPageCount() == 1 ? RescanOnePage(recycler) : RescanMultiPage(recycler);",
          "1179: #endif",
          "1180: }",
          "1182: #if ENABLE_CONCURRENT_GC",
          "1183: size_t",
          "1184: LargeHeapBlock::RescanMultiPage(Recycler * recycler, RescanFlags flags)",
          "1185: #else",
          "1186: size_t",
          "1187: LargeHeapBlock::RescanMultiPage(Recycler * recycler)",
          "1188: #endif",
          "1189: {",
          "1190:     Assert(this->GetPageCount() != 1);",
          "1191:     DebugOnly(bool oldNeedOOMRescan = this->needOOMRescan);",
          "1194:     this->needOOMRescan = false;",
          "1196:     size_t rescanCount = 0;",
          "1197:     uint objectIndex = 0;",
          "1198: #if ENABLE_CONCURRENT_GC",
          "1199:     char * lastPageCheckedForWriteWatch = nullptr;",
          "1200:     bool isLastPageCheckedForWriteWatchDirty = false;",
          "1201: #endif",
          "1203:     const HeapBlockMap& heapBlockMap = recycler->heapBlockMap;",
          "1205:     while (objectIndex < allocCount)",
          "1206:     {",
          "1208:         LargeObjectHeader * header = this->GetHeader(objectIndex);",
          "1209:         objectIndex++;",
          "1212:         if (header == nullptr)",
          "1213:         {",
          "1214:             continue;",
          "1215:         }",
          "1217:         char * objectAddress = (char *)header->GetAddress();",
          "1220:         if (!heapBlockMap.IsMarked(objectAddress))",
          "1221:         {",
          "1222:             continue;",
          "1223:         }",
          "1225:         unsigned char attributes = header->GetAttributes(this->heapInfo->recycler->Cookie);",
          "1227: #ifdef RECYCLER_STATS",
          "1228:         if (((attributes & FinalizeBit) != 0) && ((attributes & NewFinalizeBit) != 0))",
          "1229:         {",
          "1233:             RECYCLER_STATS_INC(recycler, finalizeCount);",
          "1234:             header->SetAttributes(this->heapInfo->recycler->Cookie, (attributes & ~NewFinalizeBit));",
          "1235:         }",
          "1236: #endif",
          "1239:         if ((attributes & LeafBit) != 0)",
          "1240:         {",
          "1241:             continue;",
          "1242:         }",
          "1244: #ifdef RECYCLER_STATS",
          "1245:         bool objectScanned = false;",
          "1246: #endif",
          "1248:         size_t objectSize = header->objectSize;",
          "1249:         if (this->InPageHeapMode())",
          "1250:         {",
          "1252:             objectSize = HeapInfo::RoundObjectSize(objectSize);",
          "1253:         }",
          "1255:         Assert(objectSize > 0);",
          "1256:         Assert(oldNeedOOMRescan || !header->markOnOOMRescan);",
          "1258:         if (header->markOnOOMRescan)",
          "1259:         {",
          "1260:             if (!recycler->AddMark(objectAddress, objectSize))",
          "1261:             {",
          "1262:                 this->SetNeedOOMRescan(recycler);",
          "1263:                 header->markOnOOMRescan = true;",
          "1274:                 if (!recycler->inEndMarkOnLowMemory)",
          "1275:                 {",
          "1276:                     continue;",
          "1277:                 }",
          "1279:                 return rescanCount;",
          "1280:             }",
          "1281:             header->markOnOOMRescan = false;",
          "1282: #ifdef RECYCLER_STATS",
          "1283:             objectScanned = true;",
          "1284: #endif",
          "1285:         }",
          "1286: #if ENABLE_CONCURRENT_GC",
          "1287:         else if (!recycler->inEndMarkOnLowMemory)",
          "1288:         {",
          "1289:             char * objectAddressEnd = objectAddress + objectSize;",
          "1292:             do",
          "1293:             {",
          "1294:                 char * pageStart = (char *)(((size_t)objectAddress) & ~(size_t)(AutoSystemInfo::PageSize - 1));",
          "1308:                 if (lastPageCheckedForWriteWatch != pageStart)",
          "1309:                 {",
          "1310:                     lastPageCheckedForWriteWatch = pageStart;",
          "1311:                     isLastPageCheckedForWriteWatchDirty = true;",
          "1312:                     bool hasWriteBarrier = false;",
          "1313: #ifdef RECYCLER_WRITE_BARRIER",
          "1314:                     hasWriteBarrier = header->hasWriteBarrier;",
          "1315: #endif",
          "1316:                     if (!IsPageDirty(pageStart, flags, hasWriteBarrier))",
          "1317:                     {",
          "1319:                         isLastPageCheckedForWriteWatchDirty = false;",
          "1320:                     }",
          "1321:                 }",
          "1323:                 if (!isLastPageCheckedForWriteWatchDirty)",
          "1324:                 {",
          "1325:                     objectAddress = pageStart + AutoSystemInfo::PageSize;",
          "1326:                     continue;",
          "1327:                 }",
          "1331:                 char * checkEnd = min(pageStart + AutoSystemInfo::PageSize, objectAddressEnd);",
          "1332:                 if (!recycler->AddMark(objectAddress, (checkEnd - objectAddress)))",
          "1333:                 {",
          "1334:                     this->SetNeedOOMRescan(recycler);",
          "1335:                     header->markOnOOMRescan = true;",
          "1336:                 }",
          "1338: #ifdef RECYCLER_STATS",
          "1339:                 objectScanned = true;",
          "1340:                 recycler->collectionStats.markData.rescanLargePageCount++;",
          "1341:                 recycler->collectionStats.markData.rescanLargeByteCount += (checkEnd - objectAddress);",
          "1342: #endif",
          "1343:                 objectAddress = checkEnd;",
          "1344:                 rescanCount++;",
          "1345:             }",
          "1346:             while (objectAddress < objectAddressEnd);",
          "1347:         }",
          "1348: #else",
          "1349:         else",
          "1350:         {",
          "1351:             Assert(recycler->inEndMarkOnLowMemory);",
          "1352:         }",
          "1353: #endif",
          "1354:         RECYCLER_STATS_ADD(recycler, markData.rescanLargeObjectCount, objectScanned);",
          "1355:     }",
          "1357:     return rescanCount;",
          "1358: }",
          "1377: SweepState",
          "1378: LargeHeapBlock::Sweep(RecyclerSweep& recyclerSweep, bool queuePendingSweep)",
          "1379: {",
          "1380:     Recycler * recycler = recyclerSweep.GetRecycler();",
          "1382:     uint markCount = GetMarkCount();",
          "1383: #if DBG",
          "1384:     Assert(this->lastCollectAllocCount == this->allocCount);",
          "1385:     Assert(markCount <= allocCount);",
          "1386: #endif",
          "1388:     RECYCLER_STATS_INC(recycler, heapBlockCount[HeapBlock::LargeBlockType]);",
          "1390: #if DBG",
          "1391:     this->expectedSweepCount = allocCount - markCount;",
          "1392: #endif",
          "1394: #if ENABLE_CONCURRENT_GC",
          "1395:     Assert(!this->isPendingConcurrentSweep);",
          "1396: #endif",
          "1398:     bool isAllFreed = (finalizeCount == 0 && markCount == 0);",
          "1399:     if (isAllFreed)",
          "1400:     {",
          "1401:         recycler->NotifyFree(this);",
          "1402:         Assert(this->pendingDisposeObject == nullptr);",
          "1403:         return SweepStateEmpty;",
          "1404:     }",
          "1406:     RECYCLER_STATS_ADD(recycler, largeHeapBlockTotalByteCount, this->pageCount * AutoSystemInfo::PageSize);",
          "1407:     RECYCLER_STATS_ADD(recycler, heapBlockFreeByteCount[HeapBlock::LargeBlockType],",
          "1408:         addressEnd - allocAddressEnd <= HeapConstants::MaxSmallObjectSize? 0 : (size_t)(addressEnd - allocAddressEnd));",
          "1413:     if (markCount != allocCount)",
          "1414:     {",
          "1415:         Assert(this->expectedSweepCount != 0);",
          "1427:         Assert(!recyclerSweep.IsBackground());",
          "1428: #if ENABLE_CONCURRENT_GC",
          "1429:         if (queuePendingSweep && finalizeCount == 0)",
          "1430:         {",
          "1431:             this->isPendingConcurrentSweep = true;",
          "1432:             return SweepStatePendingSweep;",
          "1433:         }",
          "1434: #else",
          "1435:         Assert(!queuePendingSweep);",
          "1436: #endif",
          "1438:         SweepObjects<SweepMode_InThread>(recycler);",
          "1439:         if (TransferSweptObjects())",
          "1440:         {",
          "1441:             return SweepStatePendingDispose;",
          "1442:         }",
          "1443:     }",
          "1444: #ifdef RECYCLER_STATS",
          "1445:     else",
          "1446:     {",
          "1447:         Assert(expectedSweepCount == 0);",
          "1448:         isForceSweeping = true;",
          "1449:         SweepObjects<SweepMode_InThread>(recycler);",
          "1450:         isForceSweeping = false;",
          "1451:     }",
          "1452: #endif",
          "1453:     if (this->pendingDisposeObject != nullptr)",
          "1454:     {",
          "1455:         return SweepStatePendingDispose;",
          "1456:     }",
          "1457:     return (allocCount == objectCount || addressEnd - allocAddressEnd <= HeapConstants::MaxSmallObjectSize) && this->freeList.entries == nullptr ?",
          "1458:     SweepStateFull : SweepStateSwept;",
          "1459: }",
          "1461: bool",
          "1462: LargeHeapBlock::TrimObject(Recycler* recycler, LargeObjectHeader* header, size_t sizeOfObject, bool inDispose)",
          "1463: {",
          "1464:     IdleDecommitPageAllocator* pageAllocator = recycler->GetRecyclerLargeBlockPageAllocator();",
          "1465:     uint pageSize = AutoSystemInfo::PageSize ;",
          "1469:     Assert(this->allocCount > 1 || this->isForceSweeping || inDispose);",
          "1477:     if (sizeOfObject > pageSize &&",
          "1478:         this->segment->GetPageCount() <= pageAllocator->GetMaxAllocPageCount() &&",
          "1479:         this->allocCount > 1)",
          "1480:     {",
          "1481:         Assert(!this->hadTrimmed);",
          "1491:         char* objectAddress = (char*) header;",
          "1492:         char* objectEndAddress = objectAddress + sizeof(LargeObjectHeader) + header->objectSize;",
          "1494:         uintptr_t alignmentMask = ~((uintptr_t) (AutoSystemInfo::PageSize - 1));",
          "1496:         uintptr_t objectFreeAddress = (uintptr_t) objectAddress;",
          "1497:         uintptr_t objectFreeEndAddress = ((uintptr_t) objectEndAddress) & alignmentMask;",
          "1499:         size_t bytesToFree = (objectFreeEndAddress - objectFreeAddress);",
          "1507:         Assert(objectAddress == this->address);",
          "1508:         Assert(header->objectIndex == 0);",
          "1509:         Assert(objectFreeEndAddress <= (uintptr_t) objectEndAddress);",
          "1510:         Assert(objectFreeAddress <= objectFreeEndAddress);",
          "1511:         Assert(bytesToFree < sizeOfObject + sizeof(LargeObjectHeader) || (uintptr_t) objectEndAddress == objectFreeEndAddress);",
          "1517:         Assert(bytesToFree > 0);",
          "1518:         Assert((bytesToFree & (AutoSystemInfo::PageSize - 1)) == 0);",
          "1519:         size_t freePageCount = bytesToFree / AutoSystemInfo::PageSize;",
          "1520:         Assert(freePageCount > 0);",
          "1521:         Assert(freePageCount < this->pageCount);",
          "1526:         if (inDispose)",
          "1527:         {",
          "1528:             pageAllocator->SuspendIdleDecommit();",
          "1529:         }",
          "1531:         pageAllocator->Release((char*) objectFreeAddress, freePageCount, this->GetSegment());",
          "1533:         if (inDispose)",
          "1534:         {",
          "1535:             pageAllocator->ResumeIdleDecommit();",
          "1536:         }",
          "1541:         recycler->heapBlockMap.ClearHeapBlock(this->address, freePageCount);",
          "1543:         this->address = (char*) objectFreeEndAddress;",
          "1544:         this->pageCount -= freePageCount;",
          "1546:         FillFreeMemory(recycler, (void*) objectFreeEndAddress, (size_t) (objectEndAddress - objectFreeEndAddress));",
          "1548: #if DBG",
          "1549:         this->hadTrimmed = true;",
          "1550: #endif",
          "1551:         return true;",
          "1552:     }",
          "1554:     return false;",
          "1555: }",
          "1558: template <>",
          "1559: void",
          "1560: LargeHeapBlock::SweepObject<SweepMode_InThread>(Recycler * recycler, LargeObjectHeader * header)",
          "1561: {",
          "1562:     Assert(this->HeaderList()[header->objectIndex] == header);",
          "1566:     if ((header->GetAttributes(this->heapInfo->recycler->Cookie) & FinalizeBit) != FinalizeBit)",
          "1567:     {",
          "1568:         this->HeaderList()[header->objectIndex] = nullptr;",
          "1570:         size_t sizeOfObject = header->objectSize;",
          "1572:         bool objectTrimmed = false;",
          "1574:         if (!this->bucket->SupportFreeList())",
          "1575:         {",
          "1576:             objectTrimmed = TrimObject(recycler, header, sizeOfObject);",
          "1577:         }",
          "1579:         if (!objectTrimmed)",
          "1580:         {",
          "1581:             FillFreeMemory(recycler, header, sizeof(LargeObjectHeader) + sizeOfObject);",
          "1582:         }",
          "1583:     }",
          "1584: }",
          "1589: void",
          "1590: LargeHeapBlock::FinalizeObject(Recycler* recycler, LargeObjectHeader* header)",
          "1591: {",
          "1594:     Assert(this->HeaderList()[header->objectIndex] == header);",
          "1595:     Assert(header->GetAttributes(this->heapInfo->recycler->Cookie) & FinalizeBit);",
          "1601:     ((FinalizableObject *)header->GetAddress())->Finalize(false);",
          "1602:     header->SetNext(this->heapInfo->recycler->Cookie, this->pendingDisposeObject);",
          "1603:     this->pendingDisposeObject = header;",
          "1607:     this->HeaderList()[header->objectIndex] = nullptr;",
          "1609: #ifdef RECYCLER_FINALIZE_CHECK",
          "1610:     recycler->autoHeap.pendingDisposableObjectCount++;",
          "1611: #endif",
          "1612: }",
          "1615: template void LargeHeapBlock::SweepObjects<SweepMode_InThread>(Recycler * recycler);",
          "1616: #if ENABLE_CONCURRENT_GC",
          "1617: template <>",
          "1618: void",
          "1619: LargeHeapBlock::SweepObject<SweepMode_Concurrent>(Recycler * recycler, LargeObjectHeader * header)",
          "1620: {",
          "1621:     Assert(!(header->GetAttributes(this->heapInfo->recycler->Cookie) & FinalizeBit));",
          "1622:     Assert(this->HeaderList()[header->objectIndex] == header);",
          "1623:     this->HeaderList()[header->objectIndex] = nullptr;",
          "1624:     FillFreeMemory(recycler, header, sizeof(LargeObjectHeader) + header->objectSize);",
          "1625: }",
          "1628: template void LargeHeapBlock::SweepObjects<SweepMode_Concurrent>(Recycler * recycler);",
          "1629: #if ENABLE_PARTIAL_GC",
          "1630: template <>",
          "1631: void",
          "1632: LargeHeapBlock::SweepObject<SweepMode_ConcurrentPartial>(Recycler * recycler, LargeObjectHeader * header)",
          "1633: {",
          "1634:     Assert(!(header->GetAttributes(this->heapInfo->recycler->Cookie) & FinalizeBit));",
          "1635:     Assert(this->HeaderList()[header->objectIndex] == header);",
          "1636:     this->HeaderList()[header->objectIndex] = (LargeObjectHeader *)((size_t)header | PartialFreeBit);",
          "1637:     DebugOnly(this->hasPartialFreeObjects = true);",
          "1638: }",
          "1641: template void LargeHeapBlock::SweepObjects<SweepMode_ConcurrentPartial>(Recycler * recycler);",
          "1642: #endif",
          "1643: #endif",
          "1654: void LargeHeapBlock::FinalizeObjects(Recycler* recycler)",
          "1655: {",
          "1656:     const HeapBlockMap& heapBlockMap = recycler->heapBlockMap;",
          "1658:     for (uint i = 0; i < this->lastCollectAllocCount; i++)",
          "1659:     {",
          "1660:         LargeObjectHeader * header = this->GetHeader(i);",
          "1661:         if (header == nullptr)",
          "1662:         {",
          "1663:             continue;",
          "1664:         }",
          "1666:         Assert(header->objectIndex == i);",
          "1669:         if (heapBlockMap.IsMarked(header->GetAddress()))",
          "1670:         {",
          "1671:             continue;",
          "1672:         }",
          "1674:         if ((header->GetAttributes(this->heapInfo->recycler->Cookie) & FinalizeBit) == FinalizeBit)",
          "1675:         {",
          "1676:             recycler->NotifyFree((char *)header->GetAddress(), header->objectSize);",
          "1677:             FinalizeObject(recycler, header);",
          "1678:         }",
          "1679:     }",
          "1680: }",
          "1682: template <SweepMode mode>",
          "1683: void",
          "1684: LargeHeapBlock::SweepObjects(Recycler * recycler)",
          "1685: {",
          "1686: #if ENABLE_CONCURRENT_GC",
          "1687:     Assert(mode == SweepMode_InThread || this->isPendingConcurrentSweep);",
          "1688: #else",
          "1689:     Assert(mode == SweepMode_InThread);",
          "1690: #endif",
          "1692:     const HeapBlockMap& heapBlockMap = recycler->heapBlockMap;",
          "1693: #if DBG",
          "1694:     uint markCount = GetMarkCount();",
          "1697: #if ENABLE_CONCURRENT_GC",
          "1698:     Assert(expectedSweepCount == allocCount - markCount || recycler->collectionState == CollectionStateConcurrentSweep);",
          "1699: #else",
          "1700:     Assert(expectedSweepCount == allocCount - markCount);",
          "1701: #endif",
          "1702:     Assert(expectedSweepCount != 0 || isForceSweeping);",
          "1703:     uint sweepCount = 0;",
          "1704: #endif",
          "1706:     for (uint i = 0; i < lastCollectAllocCount; i++)",
          "1707:     {",
          "1708:         RECYCLER_STATS_ADD(recycler, objectSweepScanCount, !isForceSweeping);",
          "1709:         LargeObjectHeader * header = this->GetHeader(i);",
          "1710:         if (header == nullptr)",
          "1711:         {",
          "1712: #if DBG",
          "1713:             Assert(expectedSweepCount != 0);",
          "1714:             expectedSweepCount--;",
          "1715: #endif",
          "1716: #if DBG",
          "1717:             LargeAllocationVerboseTrace(recycler->GetRecyclerFlagsTable(), _u(\"Index %d empty\\n\"), i);",
          "1718: #endif",
          "1719:             continue;",
          "1720:         }",
          "1722:         Assert(header->objectIndex == i);",
          "1725:         if (heapBlockMap.IsMarked(header->GetAddress()))",
          "1726:         {",
          "1727: #if DBG",
          "1728:             Assert((header->GetAttributes(recycler->Cookie) & NewFinalizeBit) == 0);",
          "1729: #endif",
          "1731:             RECYCLER_STATS_ADD(recycler, largeHeapBlockUsedByteCount, this->GetHeader(i)->objectSize);",
          "1732:             continue;",
          "1733:         }",
          "1735:         size_t objectSize = header->objectSize;",
          "1736:         recycler->NotifyFree((char *)header->GetAddress(), objectSize);",
          "1738:         SweepObject<mode>(recycler, header);",
          "1740:         if (this->bucket->SupportFreeList()",
          "1741: #ifdef RECYCLER_STATS",
          "1742:             && !isForceSweeping",
          "1743: #endif",
          "1744:             )",
          "1745:         {",
          "1746:             LargeHeapBlockFreeListEntry* head = this->freeList.entries;",
          "1747:             LargeHeapBlockFreeListEntry* entry = (LargeHeapBlockFreeListEntry*) header;",
          "1748:             entry->headerIndex = i;",
          "1749:             entry->heapBlock = this;",
          "1750:             entry->next = head;",
          "1751:             entry->objectSize = objectSize;",
          "1752:             this->freeList.entries = entry;",
          "1753:         }",
          "1755: #if DBG",
          "1756:         sweepCount++;",
          "1757: #endif",
          "1758:     }",
          "1760:     Assert(sweepCount == expectedSweepCount);",
          "1761: #if ENABLE_CONCURRENT_GC",
          "1762:     this->isPendingConcurrentSweep = false;",
          "1763: #endif",
          "1764: }",
          "1766: bool",
          "1767: LargeHeapBlock::TransferSweptObjects()",
          "1768: {",
          "1770:     return pendingDisposeObject != nullptr;",
          "1771: }",
          "1773: void",
          "1774: LargeHeapBlock::DisposeObjects(Recycler * recycler)",
          "1775: {",
          "1776:     Assert(this->pendingDisposeObject != nullptr || this->hasDisposeBeenCalled);",
          "1778:     while (pendingDisposeObject != nullptr)",
          "1779:     {",
          "1780: #if DBG",
          "1781:         this->hasDisposeBeenCalled = true;",
          "1782: #endif",
          "1784:         LargeObjectHeader * header = pendingDisposeObject;",
          "1785:         pendingDisposeObject = header->GetNext(this->heapInfo->recycler->Cookie);",
          "1786:         Assert(header->GetAttributes(this->heapInfo->recycler->Cookie) & FinalizeBit);",
          "1787:         Assert(this->HeaderList()[header->objectIndex] == nullptr);",
          "1789:         void * objectAddress = header->GetAddress();",
          "1790:         ((FinalizableObject *)objectAddress)->Dispose(false);",
          "1792:         Assert(finalizeCount != 0);",
          "1793:         finalizeCount--;",
          "1795:         bool objectTrimmed = false;",
          "1797:         if (this->bucket->SupportFreeList())",
          "1798:         {",
          "1799:             objectTrimmed = TrimObject(recycler, header, header->objectSize, true /* need suspend */);",
          "1800:         }",
          "1805:         if (!objectTrimmed)",
          "1806:         {",
          "1807:             FillFreeMemory(recycler, header, sizeof(LargeObjectHeader) + header->objectSize);",
          "1808:         }",
          "1810:         RECYCLER_STATS_INC(recycler, finalizeSweepCount);",
          "1811: #ifdef RECYCLER_FINALIZE_CHECK",
          "1812:         this->heapInfo->liveFinalizableObjectCount--;",
          "1813:         this->heapInfo->pendingDisposableObjectCount--;",
          "1814: #endif",
          "1815:     }",
          "1816: }",
          "1818: #if ENABLE_PARTIAL_GC && ENABLE_CONCURRENT_GC",
          "1819: void",
          "1820: LargeHeapBlock::PartialTransferSweptObjects()",
          "1821: {",
          "1823:     Assert(this->hasPartialFreeObjects);",
          "1824: }",
          "1826: void",
          "1827: LargeHeapBlock::FinishPartialCollect(Recycler * recycler)",
          "1828: {",
          "1829:     Assert(this->hasPartialFreeObjects);",
          "1830:     for (uint i = 0; i < allocCount; i++)",
          "1831:     {",
          "1832:         LargeObjectHeader * header = this->HeaderList()[i];",
          "1834:         if (header != nullptr && IsPartialSweptHeader(header))",
          "1835:         {",
          "1836:             header = (LargeObjectHeader *)((size_t)header & ~PartialFreeBit);",
          "1837:             Assert(header->objectIndex == i);",
          "1838:             this->HeaderList()[i] = nullptr;",
          "1839:             FillFreeMemory(recycler, header, sizeof(LargeObjectHeader) + header->objectSize);",
          "1840:         }",
          "1841:     }",
          "1842:     DebugOnly(this->hasPartialFreeObjects = false);",
          "1843: }",
          "1844: #endif",
          "1846: void",
          "1847: LargeHeapBlock::EnumerateObjects(ObjectInfoBits infoBits, void (*CallBackFunction)(void * address, size_t size))",
          "1848: {",
          "1849:     for (uint i = 0; i < allocCount; i++)",
          "1850:     {",
          "1851:         LargeObjectHeader * header = this->GetHeader(i);",
          "1852:         if (header == nullptr)",
          "1853:         {",
          "1854:             continue;",
          "1855:         }",
          "1856:         if ((header->GetAttributes(this->heapInfo->recycler->Cookie) & infoBits) != 0)",
          "1857:         {",
          "1858:             CallBackFunction(header->GetAddress(), header->objectSize);",
          "1859:         }",
          "1860:     }",
          "1861: }",
          "1864: uint",
          "1865: LargeHeapBlock::GetMaxLargeObjectCount(size_t pageCount, size_t firstAllocationSize)",
          "1866: {",
          "1867:     size_t freeSize = (AutoSystemInfo::PageSize * pageCount) - firstAllocationSize - sizeof(LargeObjectHeader);",
          "1868:     Assert(freeSize < AutoSystemInfo::Data.dwAllocationGranularity);",
          "1869:     size_t objectCount = (freeSize / HeapConstants::MaxSmallObjectSize) + 1;",
          "1870:     Assert(objectCount <= UINT_MAX);",
          "1871:     return (uint)objectCount;",
          "1872: }",
          "1874: #ifdef RECYCLER_SLOW_CHECK_ENABLED",
          "1875: void",
          "1876: LargeHeapBlock::Check(bool expectFull, bool expectPending)",
          "1877: {",
          "1878:     for (uint i = 0; i < allocCount; i++)",
          "1879:     {",
          "1880:         LargeObjectHeader * header = this->HeaderList()[i];",
          "1881:         if (header == nullptr)",
          "1882:         {",
          "1883:             continue;",
          "1884:         }",
          "1885: #if ENABLE_PARTIAL_GC && ENABLE_CONCURRENT_GC",
          "1886:         header = (LargeObjectHeader *)((size_t)header & ~PartialFreeBit);",
          "1887:         Assert(this->hasPartialFreeObjects || header == this->HeaderList()[i]);",
          "1888: #endif",
          "1889:         Assert(header->objectIndex == i);",
          "1890:     }",
          "1891: }",
          "1892: #endif",
          "1894: void LargeHeapBlock::FillFreeMemory(Recycler * recycler, __in_bcount(size) void * address, size_t size)",
          "1895: {",
          "1899: #ifdef RECYCLER_MEMORY_VERIFY",
          "1900:     if (recycler->VerifyEnabled())",
          "1901:     {",
          "1902:         memset(address, Recycler::VerifyMemFill, size);",
          "1903:         return;",
          "1904:     }",
          "1905: #endif",
          "1906: #ifdef RECYCLER_FREE_MEM_FILL",
          "1907:     memset(address, DbgMemFill, size);",
          "1908: #endif",
          "1909: }",
          "1911: size_t LargeHeapBlock::GetObjectSize(void* objectAddress)",
          "1912: {",
          "1913:     LargeObjectHeader * header = GetHeader(objectAddress);",
          "1915:     Assert((char *)header >= this->address);",
          "1917:     return header->objectSize;",
          "1918: }",
          "1921: #ifdef RECYCLER_MEMORY_VERIFY",
          "1924: void",
          "1925: LargeHeapBlock::Verify(Recycler * recycler)",
          "1926: {",
          "1927:     char * lastAddress = this->address;",
          "1928:     uint verifyFinalizeCount = 0;",
          "1929:     for (uint i = 0; i < allocCount; i++)",
          "1930:     {",
          "1931:         LargeObjectHeader * header = this->HeaderList()[i];",
          "1932:         if (header == nullptr)",
          "1933:         {",
          "1935:             LargeHeapBlockFreeListEntry* current = this->freeList.entries;",
          "1937:             while (current != nullptr)",
          "1938:             {",
          "1940:                 if (current->headerIndex == i)",
          "1941:                 {",
          "1942:                     BYTE* objectAddress = (BYTE *)current + sizeof(LargeObjectHeader);",
          "1943:                     Recycler::VerifyCheck(current->heapBlock == this, _u(\"Invalid heap block\"), this, current->heapBlock);",
          "1944:                     Recycler::VerifyCheck((char *)current >= lastAddress, _u(\"LargeHeapBlock invalid object header order\"), this->address, current);",
          "1945:                     Recycler::VerifyCheckFill(lastAddress, (char *)current - lastAddress);",
          "1946:                     recycler->VerifyCheckPad(objectAddress, current->objectSize);",
          "1947:                     lastAddress = (char *) objectAddress + current->objectSize;",
          "1948:                     break;",
          "1949:                 }",
          "1951:                 current = current->next;",
          "1952:             }",
          "1954:             continue;",
          "1955:         }",
          "1957:         Recycler::VerifyCheck((char *)header >= lastAddress, _u(\"LargeHeapBlock invalid object header order\"), this->address, header);",
          "1958:         Recycler::VerifyCheckFill(lastAddress, (char *)header - lastAddress);",
          "1959:         Recycler::VerifyCheck(header->objectIndex == i, _u(\"LargeHeapBlock object index mismatch\"), this->address, &header->objectIndex);",
          "1960:         recycler->VerifyCheckPad((BYTE *)header->GetAddress(), header->objectSize);",
          "1962:         verifyFinalizeCount += ((header->GetAttributes(this->heapInfo->recycler->Cookie) & FinalizeBit) != 0);",
          "1963:         lastAddress = (char *)header->GetAddress() + header->objectSize;",
          "1964:     }",
          "1966:     Recycler::VerifyCheck(verifyFinalizeCount == this->finalizeCount, _u(\"LargeHeapBlock finalize object count mismatch\"), this->address, &this->finalizeCount);",
          "1967: }",
          "1968: #endif",
          "1970: uint",
          "1971: LargeHeapBlock::GetMarkCount()",
          "1972: {",
          "1973:     uint markCount = 0;",
          "1974:     const HeapBlockMap& heapBlockMap = this->heapInfo->recycler->heapBlockMap;",
          "1976:     for (uint i = 0; i < allocCount; i++)",
          "1977:     {",
          "1978:         LargeObjectHeader* header = this->HeaderList()[i];",
          "1979:         if (header && header->objectIndex == i && heapBlockMap.IsMarked(header->GetAddress()))",
          "1980:         {",
          "1981:             markCount++;",
          "1982:         }",
          "1983:     }",
          "1985:     return markCount;",
          "1986: }",
          "1988: #ifdef RECYCLER_PERF_COUNTERS",
          "1989: void",
          "1990: LargeHeapBlock::UpdatePerfCountersOnFree()",
          "1991: {",
          "1992:     Assert(GetMarkCount() == 0);",
          "1993:     size_t usedCount = 0;",
          "1994:     size_t usedBytes = 0;",
          "1995:     for (uint i = 0; i < allocCount; i++)",
          "1996:     {",
          "1997:         LargeObjectHeader * header = this->HeaderList()[i];",
          "1998:         if (header == nullptr)",
          "1999:         {",
          "2000:             continue;",
          "2001:         }",
          "2002:         usedCount++;",
          "2003:         usedBytes += header->objectSize;",
          "2004:     }",
          "2006:     RECYCLER_PERF_COUNTER_SUB(LargeHeapBlockLiveObject, usedCount);",
          "2007:     RECYCLER_PERF_COUNTER_SUB(LargeHeapBlockLiveObjectSize, usedBytes);",
          "2008:     RECYCLER_PERF_COUNTER_SUB(LargeHeapBlockFreeObjectSize, this->GetPageCount() * AutoSystemInfo::PageSize - usedBytes);",
          "2010:     RECYCLER_PERF_COUNTER_SUB(LiveObject, usedCount);",
          "2011:     RECYCLER_PERF_COUNTER_SUB(LiveObjectSize, usedBytes);",
          "2012:     RECYCLER_PERF_COUNTER_SUB(FreeObjectSize, this->GetPageCount() * AutoSystemInfo::PageSize - usedBytes);",
          "2013: }",
          "2014: #endif",
          "2016: #ifdef PROFILE_RECYCLER_ALLOC",
          "2017: void *",
          "2018: LargeHeapBlock::GetTrackerData(void * address)",
          "2019: {",
          "2020:     Assert(Recycler::DoProfileAllocTracker());",
          "2021:     LargeObjectHeader * header = GetHeader(address);",
          "2022:     Assert((char *)header >= this->address);",
          "2023:     uint index = header->objectIndex;",
          "2024:     Assert(index < this->allocCount);",
          "2025:     Assert(this->HeaderList()[index] == header);",
          "2026:     return this->GetTrackerDataArray()[index];",
          "2027: }",
          "2029: void",
          "2030: LargeHeapBlock::SetTrackerData(void * address, void * data)",
          "2031: {",
          "2032:     Assert(Recycler::DoProfileAllocTracker());",
          "2033:     LargeObjectHeader * header = GetHeader(address);",
          "2034:     Assert((char *)header >= this->address);",
          "2035:     uint index = header->objectIndex;",
          "2036:     Assert(index < this->allocCount);",
          "2037:     Assert(this->HeaderList()[index] == header);",
          "2038:     this->GetTrackerDataArray()[index] = data;",
          "2039: }",
          "2041: void **",
          "2042: LargeHeapBlock::GetTrackerDataArray()",
          "2043: {",
          "2045:     return (void **)((char *)(this + 1) + LargeHeapBlock::GetAllocPlusSize(this->objectCount) - this->objectCount * sizeof(void *));",
          "2046: }",
          "2047: #endif",
          "2049: #ifdef RECYCLER_PAGE_HEAP",
          "2050: void",
          "2051: LargeHeapBlock::CapturePageHeapAllocStack()",
          "2052: {",
          "2053: #ifdef STACK_BACK_TRACE",
          "2054:     if (this->InPageHeapMode()) // pageheap can be enabled only for some of the buckets",
          "2055:     {",
          "2058:         Assert(this->pageHeapFreeStack == nullptr);",
          "2059:         Assert(this->pageHeapAllocStack == nullptr);",
          "2063:         if (pageHeapAllocStack != nullptr && this->pageHeapAllocStack != s_StackTraceAllocFailed)",
          "2064:         {",
          "2065:             this->pageHeapAllocStack->Capture(Recycler::s_numFramesToSkipForPageHeapAlloc);",
          "2066:         }",
          "2067:         else",
          "2068:         {",
          "2069:             this->pageHeapAllocStack = StackBackTrace::Capture(&NoThrowHeapAllocator::Instance,",
          "2070:                 Recycler::s_numFramesToSkipForPageHeapAlloc, Recycler::s_numFramesToCaptureForPageHeap);",
          "2071:         }",
          "2073:         if (this->pageHeapAllocStack == nullptr)",
          "2074:         {",
          "2075:             this->pageHeapAllocStack = const_cast<StackBackTrace*>(s_StackTraceAllocFailed); // allocate failed, mark it we have tried",
          "2076:         }",
          "2077:     }",
          "2078: #endif",
          "2079: }",
          "2081: void",
          "2082: LargeHeapBlock::CapturePageHeapFreeStack()",
          "2083: {",
          "2084: #ifdef STACK_BACK_TRACE",
          "2085:     if (this->InPageHeapMode()) // pageheap can be enabled only for some of the buckets",
          "2086:     {",
          "2089:         Assert(this->pageHeapFreeStack == nullptr);",
          "2090:         Assert(this->pageHeapAllocStack != nullptr);",
          "2092:         if (this->pageHeapFreeStack != nullptr)",
          "2093:         {",
          "2094:             this->pageHeapFreeStack->Capture(Recycler::s_numFramesToSkipForPageHeapFree);",
          "2095:         }",
          "2096:         else",
          "2097:         {",
          "2098:             this->pageHeapFreeStack = StackBackTrace::Capture(&NoThrowHeapAllocator::Instance,",
          "2099:                 Recycler::s_numFramesToSkipForPageHeapFree, Recycler::s_numFramesToCaptureForPageHeap);",
          "2100:         }",
          "2101:     }",
          "2102: #endif",
          "2103: }",
          "2104: #endif",
          "2106: #if DBG && GLOBAL_ENABLE_WRITE_BARRIER",
          "2107: CriticalSection LargeHeapBlock::wbVerifyBitsLock;",
          "2108: void LargeHeapBlock::WBSetBit(char* addr)",
          "2109: {",
          "2110:     uint index = (uint)(addr - this->address) / sizeof(void*);",
          "2111:     try",
          "2112:     {",
          "2113:         AUTO_NESTED_HANDLED_EXCEPTION_TYPE(static_cast<ExceptionType>(ExceptionType_DisableCheck));",
          "2114:         AutoCriticalSection autoCs(&wbVerifyBitsLock);",
          "2115:         wbVerifyBits.Set(index);",
          "2116:     }",
          "2117:     catch (Js::OutOfMemoryException&)",
          "2118:     {",
          "2119:     }",
          "2120: }",
          "2121: void LargeHeapBlock::WBSetBitRange(char* addr, uint count)",
          "2122: {",
          "2123:     uint index = (uint)(addr - this->address) / sizeof(void*);",
          "2124:     try",
          "2125:     {",
          "2126:         AUTO_NESTED_HANDLED_EXCEPTION_TYPE(static_cast<ExceptionType>(ExceptionType_DisableCheck));",
          "2127:         AutoCriticalSection autoCs(&wbVerifyBitsLock);",
          "2128:         for (uint i = 0; i < count; i++)",
          "2129:         {",
          "2130:             wbVerifyBits.Set(index + i);",
          "2131:         }",
          "2132:     }",
          "2133:     catch (Js::OutOfMemoryException&)",
          "2134:     {",
          "2135:     }",
          "2136: }",
          "2137: void LargeHeapBlock::WBClearBit(char* addr)",
          "2138: {",
          "2139:     uint index = (uint)(addr - this->address) / sizeof(void*);",
          "2140:     AutoCriticalSection autoCs(&wbVerifyBitsLock);",
          "2141:     wbVerifyBits.Clear(index);",
          "2142: }",
          "2143: void LargeHeapBlock::WBVerifyBitIsSet(char* addr)",
          "2144: {",
          "2145:     uint index = (uint)(addr - this->address) / sizeof(void*);",
          "2146:     if (!wbVerifyBits.Test(index))",
          "2147:     {",
          "2148:         PrintVerifyMarkFailure(this->GetRecycler(), addr, *(char**)addr);",
          "2149:     }",
          "2150: }",
          "2151: void LargeHeapBlock::WBClearObject(char* addr)",
          "2152: {",
          "2153:     uint index = (uint)(addr - this->address) / sizeof(void*);",
          "2154:     size_t objectSize = this->GetHeader(addr)->objectSize;",
          "2155:     AutoCriticalSection autoCs(&wbVerifyBitsLock);",
          "2156:     for (uint i = 0; i < (uint)objectSize / sizeof(void*); i++)",
          "2157:     {",
          "2158:         wbVerifyBits.Clear(index + i);",
          "2159:     }",
          "2160: }",
          "2161: #endif",
          "",
          "[Added Lines]",
          "5: #include \"CommonMemoryPch.h\"",
          "7: CompileAssert(",
          "8:     sizeof(LargeObjectHeader) == HeapConstants::ObjectGranularity ||",
          "9:     sizeof(LargeObjectHeader) == HeapConstants::ObjectGranularity * 2);",
          "11: #ifdef STACK_BACK_TRACE",
          "12: const StackBackTrace* LargeHeapBlock::s_StackTraceAllocFailed = (StackBackTrace*)1;",
          "13: #endif",
          "15: void *",
          "16: LargeObjectHeader::GetAddress() { return ((char *)this) + sizeof(LargeObjectHeader); }",
          "18: #ifdef LARGEHEAPBLOCK_ENCODING",
          "24: unsigned char",
          "25: LargeObjectHeader::CalculateCheckSum(LargeObjectHeader* decodedNext, unsigned char decodedAttributes)",
          "26: {",
          "27:     unsigned char checksum = 0;",
          "28:     byte *nextField = (byte *)&decodedNext;",
          "30:     checksum = nextField[0] ^ nextField[1] ^ nextField[2] ^ nextField[3] ^ decodedAttributes;",
          "31:     return checksum;",
          "32: }",
          "34: LargeObjectHeader*",
          "35: LargeObjectHeader::EncodeNext(uint cookie, LargeObjectHeader* next)",
          "36: {",
          "37:     return (LargeObjectHeader *)((uintptr_t)next ^ cookie);",
          "38: }",
          "40: ushort",
          "41: LargeObjectHeader::EncodeAttributesAndChecksum(uint cookie, ushort attributesAndChecksum)",
          "42: {",
          "43:     return attributesAndChecksum ^ (ushort)cookie;",
          "44: }",
          "46: LargeObjectHeader*",
          "47: LargeObjectHeader::DecodeNext(uint cookie, LargeObjectHeader* next) { return EncodeNext(cookie, next); }",
          "49: ushort",
          "50: LargeObjectHeader::DecodeAttributesAndChecksum(uint cookie) { return EncodeAttributesAndChecksum(cookie, this->attributesAndChecksum); }",
          "52: #else",
          "56: unsigned char *",
          "57: LargeObjectHeader::GetAttributesPtr()",
          "58: {",
          "59:     return &this->attributes;",
          "60: }",
          "61: #endif",
          "63: void",
          "64: LargeObjectHeader::SetNext(uint cookie, LargeObjectHeader* next)",
          "65: {",
          "66: #ifdef LARGEHEAPBLOCK_ENCODING",
          "67:     ushort decodedAttributesAndChecksum = this->DecodeAttributesAndChecksum(cookie);",
          "70:     unsigned char newCheckSumValue = this->CalculateCheckSum(next, (unsigned char)(decodedAttributesAndChecksum >> 8));",
          "72:     ushort newAttributeWithCheckSum = (decodedAttributesAndChecksum & 0xFF00) | newCheckSumValue;",
          "75:     this->attributesAndChecksum = this->EncodeAttributesAndChecksum(cookie, newAttributeWithCheckSum);",
          "76:     this->next = this->EncodeNext(cookie, next);",
          "77: #else",
          "78:     this->next = next;",
          "79: #endif",
          "80: }",
          "82: LargeObjectHeader *",
          "83: LargeObjectHeader::GetNext(uint cookie)",
          "84: {",
          "85: #ifdef LARGEHEAPBLOCK_ENCODING",
          "86:     LargeObjectHeader *decodedNext = this->DecodeNext(cookie, this->next);",
          "87:     ushort decodedAttributesAndChecksum = this->DecodeAttributesAndChecksum(cookie);",
          "89:     unsigned char checkSum = (unsigned char)(decodedAttributesAndChecksum & 0xFF);",
          "90:     unsigned char calculatedCheckSumField = this->CalculateCheckSum(decodedNext, (unsigned char)(decodedAttributesAndChecksum >> 8));",
          "91:     if (checkSum != calculatedCheckSumField)",
          "92:     {",
          "93:         LargeHeapBlock_Metadata_Corrupted((ULONG_PTR)this, calculatedCheckSumField);",
          "94:     }",
          "97:     return this->DecodeNext(cookie, this->next);",
          "99: #else",
          "100:     return this->next;",
          "101: #endif",
          "102: }",
          "104: void",
          "105: LargeObjectHeader::SetAttributes(uint cookie, unsigned char attributes)",
          "106: {",
          "107: #ifdef LARGEHEAPBLOCK_ENCODING",
          "108:     LargeObjectHeader *decodedNext = this->DecodeNext(cookie, this->next);",
          "111:     unsigned char newCheckSumValue = this->CalculateCheckSum(decodedNext, attributes);",
          "113:     ushort newAttributeWithCheckSum = ((ushort)attributes << 8) | newCheckSumValue;",
          "115:     this->attributesAndChecksum = this->EncodeAttributesAndChecksum(cookie, newAttributeWithCheckSum);",
          "116: #else",
          "117:     this->attributes = attributes;",
          "118: #endif",
          "119: }",
          "121: unsigned char",
          "122: LargeObjectHeader::GetAttributes(uint cookie)",
          "123: {",
          "124: #ifdef LARGEHEAPBLOCK_ENCODING",
          "126:     LargeObjectHeader *decodedNext = this->DecodeNext(cookie, this->next);",
          "127:     ushort decodedAttributesAndChecksum = this->DecodeAttributesAndChecksum(cookie);",
          "129:     unsigned char checkSum = (unsigned char)(decodedAttributesAndChecksum & 0xFF);",
          "130:     unsigned char calculatedCheckSumField = this->CalculateCheckSum(decodedNext, (unsigned char)(decodedAttributesAndChecksum >> 8));",
          "131:     if (checkSum != calculatedCheckSumField)",
          "132:     {",
          "133:         LargeHeapBlock_Metadata_Corrupted((ULONG_PTR)this, calculatedCheckSumField);",
          "134:     }",
          "138:     return this->DecodeAttributesAndChecksum(cookie) >> 8;",
          "139: #else",
          "140:     return this->attributes;",
          "141: #endif",
          "142: }",
          "144: size_t",
          "145: LargeHeapBlock::GetAllocPlusSize(uint objectCount)",
          "146: {",
          "151:     size_t allocPlusSize = objectCount * (sizeof(LargeObjectHeader *));",
          "152: #ifdef PROFILE_RECYCLER_ALLOC",
          "153:     if (Recycler::DoProfileAllocTracker())",
          "154:     {",
          "155:         allocPlusSize += objectCount * sizeof(void *);",
          "156:     }",
          "157: #endif",
          "158:     return allocPlusSize;",
          "159: }",
          "161: LargeHeapBlock *",
          "162: LargeHeapBlock::New(__in char * address, size_t pageCount, Segment * segment, uint objectCount, LargeHeapBucket* bucket)",
          "163: {",
          "164:     return NoMemProtectHeapNewNoThrowPlusZ(GetAllocPlusSize(objectCount), LargeHeapBlock, address, pageCount, segment, objectCount, bucket);",
          "165: }",
          "167: void",
          "168: LargeHeapBlock::Delete(LargeHeapBlock * heapBlock)",
          "169: {",
          "170:     NoMemProtectHeapDeletePlus(GetAllocPlusSize(heapBlock->objectCount), heapBlock);",
          "171: }",
          "173: LargeHeapBlock::LargeHeapBlock(__in char * address, size_t pageCount, Segment * segment, uint objectCount, LargeHeapBucket* bucket)",
          "174:     : HeapBlock(LargeBlockType), pageCount(pageCount), allocAddressEnd(address), objectCount(objectCount), bucket(bucket), freeList(this)",
          "175: #if defined(RECYCLER_PAGE_HEAP) && defined(STACK_BACK_TRACE)",
          "176:     , pageHeapAllocStack(nullptr), pageHeapFreeStack(nullptr)",
          "177: #endif",
          "178: #if DBG && GLOBAL_ENABLE_WRITE_BARRIER",
          "179:     ,wbVerifyBits(&HeapAllocator::Instance)",
          "180: #endif",
          "181: {",
          "182:     Assert(address != nullptr);",
          "183:     Assert(pageCount != 0);",
          "184:     Assert(objectCount != 0);",
          "185:     Assert(lastCollectAllocCount == 0);",
          "186:     Assert(finalizeCount == 0);",
          "187:     Assert(next == nullptr);",
          "188:     Assert(!hasPartialFreeObjects);",
          "190:     this->address = address;",
          "191:     this->segment = segment;",
          "192: #if ENABLE_CONCURRENT_GC",
          "193:     this->isPendingConcurrentSweep = false;",
          "194: #endif",
          "195:     this->addressEnd = this->address + this->pageCount * AutoSystemInfo::PageSize;",
          "197:     RECYCLER_PERF_COUNTER_INC(LargeHeapBlockCount);",
          "198:     RECYCLER_PERF_COUNTER_ADD(LargeHeapBlockPageSize, pageCount * AutoSystemInfo::PageSize);",
          "199: }",
          "201: LargeHeapBlock::~LargeHeapBlock()",
          "202: {",
          "203:     AssertMsg(this->segment == nullptr || this->heapInfo->recycler->recyclerLargeBlockPageAllocator.IsClosed(),",
          "204:         \"ReleasePages needs to be called before delete\");",
          "205:     RECYCLER_PERF_COUNTER_DEC(LargeHeapBlockCount);",
          "207: #if defined(RECYCLER_PAGE_HEAP) && defined(STACK_BACK_TRACE)",
          "208:     if (this->pageHeapAllocStack != nullptr)",
          "209:     {",
          "210:         if (this->pageHeapAllocStack != s_StackTraceAllocFailed)",
          "211:         {",
          "212:             this->pageHeapAllocStack->Delete(&NoThrowHeapAllocator::Instance);",
          "213:         }",
          "214:         this->pageHeapAllocStack = nullptr;",
          "215:     }",
          "219:     if (this->pageHeapFreeStack != nullptr)",
          "220:     {",
          "221:         this->pageHeapFreeStack->Delete(&NoThrowHeapAllocator::Instance);",
          "222:         this->pageHeapFreeStack = nullptr;",
          "223:     }",
          "224: #endif",
          "225: }",
          "227: Recycler *",
          "228: LargeHeapBlock::GetRecycler() const",
          "229: {",
          "230:     return this->bucket->heapInfo->recycler;",
          "231: }",
          "233: LargeObjectHeader **",
          "234: LargeHeapBlock::HeaderList()",
          "235: {",
          "237:     return (LargeObjectHeader **)(((byte *)this) + sizeof(LargeHeapBlock));",
          "238: }",
          "240: void",
          "241: LargeHeapBlock::FinalizeAllObjects()",
          "242: {",
          "243:     if (this->finalizeCount != 0)",
          "244:     {",
          "245:         DebugOnly(uint processedCount = 0);",
          "246:         for (uint i = 0; i < allocCount; i++)",
          "247:         {",
          "248:             LargeObjectHeader * header = this->GetHeader(i);",
          "249:             if (header == nullptr || ((header->GetAttributes(this->heapInfo->recycler->Cookie) & FinalizeBit) == 0))",
          "250:             {",
          "251:                 continue;",
          "252:             }",
          "254:             FinalizableObject * finalizableObject = ((FinalizableObject *)header->GetAddress());",
          "256:             finalizableObject->Finalize(true);",
          "257:             finalizableObject->Dispose(true);",
          "258: #ifdef RECYCLER_FINALIZE_CHECK",
          "259:             this->heapInfo->liveFinalizableObjectCount--;",
          "260: #endif",
          "261:             DebugOnly(processedCount++);",
          "262:         }",
          "264:         while (pendingDisposeObject != nullptr)",
          "265:         {",
          "266:             LargeObjectHeader * header = pendingDisposeObject;",
          "267:             pendingDisposeObject = header->GetNext(this->heapInfo->recycler->Cookie);",
          "268:             Assert(header->GetAttributes(this->heapInfo->recycler->Cookie) & FinalizeBit);",
          "269:             Assert(this->HeaderList()[header->objectIndex] == nullptr);",
          "271:             void * objectAddress = header->GetAddress();",
          "272:             ((FinalizableObject *)objectAddress)->Dispose(true);",
          "273: #ifdef RECYCLER_FINALIZE_CHECK",
          "274:             this->heapInfo->liveFinalizableObjectCount--;",
          "275:             this->heapInfo->pendingDisposableObjectCount--;",
          "276: #endif",
          "277:             DebugOnly(processedCount++);",
          "278:         }",
          "280:         Assert(this->finalizeCount == processedCount);",
          "281:     }",
          "282: }",
          "285: void",
          "286: LargeHeapBlock::ReleasePagesShutdown(Recycler * recycler)",
          "287: {",
          "288: #if DBG",
          "289:     recycler->heapBlockMap.ClearHeapBlock(this->address, this->pageCount);",
          "292:     Assert(recycler->recyclerLargeBlockPageAllocator.IsClosed());",
          "293: #endif",
          "294: }",
          "296: void",
          "297: LargeHeapBlock::ReleasePagesSweep(Recycler * recycler)",
          "298: {",
          "299:     recycler->heapBlockMap.ClearHeapBlock(this->address, this->pageCount);",
          "301:     ReleasePages(recycler);",
          "302: }",
          "304: #ifdef RECYCLER_PAGE_HEAP",
          "305: _NOINLINE",
          "306: void LargeHeapBlock::VerifyPageHeapPattern()",
          "307: {",
          "308:     Assert(InPageHeapMode());",
          "309:     Assert(this->allocCount > 0);",
          "310:     byte* objectEndAddress = (byte*)this->allocAddressEnd;",
          "311:     byte* addrEnd = (byte*)this->addressEnd;",
          "313:     for (int i = 0; objectEndAddress + i < (byte*)addrEnd; i++)",
          "314:     {",
          "315:         byte current = objectEndAddress[i];",
          "316:         if (current != 0xF0u)",
          "317:         {",
          "318:             Assert(false);",
          "319:             ReportFatalException(NULL, E_FAIL, Fatal_Recycler_MemoryCorruption, 2);",
          "320:         }",
          "321:     }",
          "323: }",
          "324: #endif",
          "326: void",
          "327: LargeHeapBlock::ReleasePages(Recycler * recycler)",
          "328: {",
          "329:     Assert(segment != nullptr);",
          "331:     char* blockStartAddress = this->address;",
          "332:     size_t realPageCount = this->pageCount;",
          "333: #ifdef RECYCLER_PAGE_HEAP",
          "334:     if (InPageHeapMode())",
          "335:     {",
          "336:         Assert(((LargeObjectHeader*)this->address)->isPageHeapFillVerified || this->allocCount == 0);",
          "337:         if (this->allocCount > 0) // in case OOM while adding heapblock to heapBlockMap, we release page before setting the pattern",
          "338:         {",
          "339:             Assert(this->allocCount == 1); // one object per heapblock in pageheap",
          "340:             VerifyPageHeapPattern();",
          "341:         }",
          "343:         if (guardPageAddress != nullptr)",
          "344:         {",
          "345:             if (this->pageHeapMode == PageHeapMode::PageHeapModeBlockStart)",
          "346:             {",
          "347:                 blockStartAddress = guardPageAddress;",
          "348:             }",
          "349:             realPageCount = this->actualPageCount;",
          "350:             size_t guardPageCount = this->actualPageCount - this->pageCount;",
          "352:             DWORD oldProtect;",
          "353:             BOOL ret = ::VirtualProtect(guardPageAddress, AutoSystemInfo::PageSize * guardPageCount, PAGE_READWRITE, &oldProtect);",
          "354:             Assert(ret && oldProtect == PAGE_NOACCESS);",
          "355:         }",
          "356:     }",
          "357: #endif",
          "359: #ifdef RECYCLER_FREE_MEM_FILL",
          "360:     memset(this->address, DbgMemFill, AutoSystemInfo::PageSize * pageCount);",
          "361: #endif",
          "362:     IdleDecommitPageAllocator* pageAllocator = recycler->GetRecyclerLargeBlockPageAllocator();",
          "363:     pageAllocator->Release(blockStartAddress, realPageCount, segment);",
          "364:     RECYCLER_PERF_COUNTER_SUB(LargeHeapBlockPageSize, pageCount * AutoSystemInfo::PageSize);",
          "366:     this->segment = nullptr;",
          "367: }",
          "369: BOOL",
          "370: LargeHeapBlock::IsValidObject(void* objectAddress)",
          "371: {",
          "372:     LargeObjectHeader * header = GetHeader(objectAddress);",
          "373:     return ((char *)header >= this->address && header->objectIndex < this->allocCount && this->HeaderList()[header->objectIndex] == header);",
          "374: }",
          "376: #if DBG",
          "377: BOOL",
          "378: LargeHeapBlock::IsFreeObject(void * objectAddress)",
          "379: {",
          "380:     LargeObjectHeader * header = GetHeader(objectAddress);",
          "381:     return ((char *)header >= this->address && header->objectIndex < this->allocCount && this->GetHeader(header->objectIndex) == nullptr);",
          "382: }",
          "383: #endif",
          "385: bool",
          "386: LargeHeapBlock::TryGetAttributes(void* objectAddress, unsigned char * pAttr)",
          "387: {",
          "388:     return this->TryGetAttributes(GetHeader(objectAddress), pAttr);",
          "389: }",
          "391: bool",
          "392: LargeHeapBlock::TryGetAttributes(LargeObjectHeader * header, unsigned char * pAttr)",
          "393: {",
          "394:     if ((char *)header < this->address)",
          "395:     {",
          "396:         return false;",
          "397:     }",
          "399:     uint index = header->objectIndex;",
          "401:     if (index >= this->allocCount)",
          "402:     {",
          "404:         return false;",
          "405:     }",
          "407:     if (this->HeaderList()[index] != header)",
          "408:     {",
          "410:         return false;",
          "411:     }",
          "413:     if (this->InPageHeapMode())",
          "414:     {",
          "415:         this->VerifyPageHeapPattern();",
          "416:     }",
          "419:     return true;",
          "420: }",
          "422: size_t",
          "423: LargeHeapBlock::GetPagesNeeded(size_t size, bool multiplyRequest)",
          "424: {",
          "425:     if (multiplyRequest)",
          "426:     {",
          "427:         size = AllocSizeMath::Mul(size, 4);",
          "428:     }",
          "430:     uint pageSize = AutoSystemInfo::PageSize;",
          "431:     size = AllocSizeMath::Add(size, sizeof(LargeObjectHeader) + (pageSize - 1));",
          "432:     if (size == (size_t)-1)",
          "433:     {",
          "434:         return 0;",
          "435:     }",
          "436:     size_t pageCount = size / pageSize;",
          "437:     return pageCount;",
          "438: }",
          "440: char*",
          "441: LargeHeapBlock::TryAllocFromFreeList(size_t size, ObjectInfoBits attributes)",
          "442: {",
          "443:     Assert((attributes & InternalObjectInfoBitMask) == attributes);",
          "445:     LargeHeapBlockFreeListEntry** prev = &this->freeList.entries;",
          "446:     LargeHeapBlockFreeListEntry* freeListEntry = this->freeList.entries;",
          "448:     char* memBlock = nullptr;",
          "451:     while (freeListEntry)",
          "452:     {",
          "453:         LargeHeapBlockFreeListEntry* next = freeListEntry->next;",
          "454:         LargeHeapBlock* heapBlock = freeListEntry->heapBlock;",
          "456:         if (freeListEntry->objectSize >= size)",
          "457:         {",
          "458:             memBlock = heapBlock->AllocFreeListEntry(size, attributes, freeListEntry);",
          "459:             if (memBlock)",
          "460:             {",
          "461:                 (*prev) = next;",
          "463:                 break;",
          "464:             }",
          "465:         }",
          "467:         prev = &freeListEntry->next;",
          "468:         freeListEntry = freeListEntry->next;",
          "469:     }",
          "471:     if (this->freeList.entries == nullptr)",
          "472:     {",
          "473:         this->bucket->UnregisterFreeList(&this->freeList);",
          "474:     }",
          "476:     return memBlock;",
          "477: }",
          "479: char*",
          "480: LargeHeapBlock::AllocFreeListEntry(size_t size, ObjectInfoBits attributes, LargeHeapBlockFreeListEntry* entry)",
          "481: {",
          "482:     Assert((attributes & InternalObjectInfoBitMask) == attributes);",
          "483:     Assert(HeapInfo::IsAlignedSize(size));",
          "484:     AssertMsg((attributes & TrackBit) == 0, \"Large tracked object collection not implemented\");",
          "485:     Assert(entry->heapBlock == this);",
          "486:     Assert(entry->headerIndex < this->objectCount);",
          "487:     Assert(this->HeaderList()[entry->headerIndex] == nullptr);",
          "489:     uint headerIndex = entry->headerIndex;",
          "490:     size_t originalSize = entry->objectSize;",
          "492:     LargeObjectHeader * header = (LargeObjectHeader *) entry;",
          "494:     char * allocObject = ((char*) entry) + sizeof(LargeObjectHeader);       // shouldn't overflow",
          "495:     char * newAllocAddressEnd = allocObject + size;",
          "496:     char * originalAllocEnd = allocObject + originalSize;",
          "497:     if (newAllocAddressEnd > addressEnd || newAllocAddressEnd < allocObject || (originalAllocEnd < newAllocAddressEnd))",
          "498:     {",
          "499:         return nullptr;",
          "500:     }",
          "502: #ifdef RECYCLER_MEMORY_VERIFY",
          "503:     if (this->heapInfo->recycler->VerifyEnabled())",
          "504:     {",
          "505:         this->heapInfo->recycler->VerifyCheckFill(allocObject , originalSize);",
          "506:     }",
          "507: #endif",
          "509:     memset(entry, 0, sizeof(LargeObjectHeader) + originalSize);",
          "511: #ifdef RECYCLER_MEMORY_VERIFY",
          "514:     if (this->heapInfo->recycler->VerifyEnabled())",
          "515:     {",
          "516:         memset(allocObject, Recycler::VerifyMemFill, originalSize);",
          "517:     }",
          "518: #endif",
          "520: #if DBG",
          "521:     LargeAllocationVerboseTrace(this->heapInfo->recycler->GetRecyclerFlagsTable(), _u(\"Allocated object of size 0x%x in from free list entry at address 0x%p\\n\"), size, allocObject);",
          "522: #endif",
          "524:     Assert(allocCount <= objectCount);",
          "526:     header->objectIndex = headerIndex;",
          "527:     header->objectSize = originalSize;",
          "528: #ifdef RECYCLER_WRITE_BARRIER",
          "529:     header->hasWriteBarrier = (attributes & WithBarrierBit) == WithBarrierBit;",
          "530: #endif",
          "531:     header->SetAttributes(this->heapInfo->recycler->Cookie, (attributes & StoredObjectInfoBitMask));",
          "532:     header->markOnOOMRescan = false;",
          "533:     header->SetNext(this->heapInfo->recycler->Cookie, nullptr);",
          "535:     HeaderList()[headerIndex] = header;",
          "536:     finalizeCount += ((attributes & FinalizeBit) != 0);",
          "538: #ifdef RECYCLER_FINALIZE_CHECK",
          "539:     if (attributes & FinalizeBit)",
          "540:     {",
          "541:         HeapInfo * heapInfo = this->heapInfo;",
          "542:         heapInfo->liveFinalizableObjectCount++;",
          "543:         heapInfo->newFinalizableObjectCount++;",
          "544:     }",
          "545: #endif",
          "547:     return allocObject;",
          "548: }",
          "550: char*",
          "551: LargeHeapBlock::Alloc(size_t size, ObjectInfoBits attributes)",
          "552: {",
          "553:     Assert(HeapInfo::IsAlignedSize(size) || InPageHeapMode());",
          "554:     Assert((attributes & InternalObjectInfoBitMask) == attributes);",
          "555:     AssertMsg((attributes & TrackBit) == 0, \"Large tracked object collection not implemented\");",
          "557:     LargeObjectHeader * header = (LargeObjectHeader *)allocAddressEnd;",
          "558: #if ENABLE_PARTIAL_GC && ENABLE_CONCURRENT_GC",
          "559:     Assert(!IsPartialSweptHeader(header));",
          "560: #endif",
          "561:     char * allocObject = allocAddressEnd + sizeof(LargeObjectHeader);       // shouldn't overflow",
          "562:     char * newAllocAddressEnd = allocObject + size;",
          "563:     if (newAllocAddressEnd > addressEnd || newAllocAddressEnd < allocObject)",
          "564:     {",
          "565:         return nullptr;",
          "566:     }",
          "568:     Recycler* recycler = this->heapInfo->recycler;",
          "569: #if DBG",
          "570:     LargeAllocationVerboseTrace(recycler->GetRecyclerFlagsTable(), _u(\"Allocated object of size 0x%x in existing heap block at address 0x%p\\n\"), size, allocObject);",
          "571: #endif",
          "573:     Assert(allocCount < objectCount);",
          "574:     allocAddressEnd = newAllocAddressEnd;",
          "575: #ifdef RECYCLER_ZERO_MEM_CHECK",
          "576:     recycler->VerifyZeroFill(header, sizeof(LargeObjectHeader));",
          "577: #endif",
          "578: #ifdef RECYCLER_MEMORY_VERIFY",
          "579:     if (recycler->VerifyEnabled())",
          "580:     {",
          "581:         memset(header, 0, sizeof(LargeObjectHeader));",
          "582:     }",
          "583: #endif",
          "585:     header->objectIndex = allocCount;",
          "586:     header->objectSize = size;",
          "587: #ifdef RECYCLER_WRITE_BARRIER",
          "588:     header->hasWriteBarrier = (attributes&WithBarrierBit) == WithBarrierBit;",
          "589: #endif",
          "590:     header->SetAttributes(recycler->Cookie, (attributes & StoredObjectInfoBitMask));",
          "591:     HeaderList()[allocCount++] = header;",
          "592:     finalizeCount += ((attributes & FinalizeBit) != 0);",
          "594: #ifdef RECYCLER_FINALIZE_CHECK",
          "595:     if (attributes & FinalizeBit)",
          "596:     {",
          "597:         HeapInfo * heapInfo = this->heapInfo;",
          "598:         heapInfo->liveFinalizableObjectCount++;",
          "599:         heapInfo->newFinalizableObjectCount++;",
          "600:     }",
          "601: #endif",
          "603:     return allocObject;",
          "604: }",
          "606: template <bool doSpecialMark>",
          "607: _NOINLINE",
          "608: void",
          "609: LargeHeapBlock::Mark(void* objectAddress, MarkContext * markContext)",
          "610: {",
          "611:     LargeObjectHeader * header = GetHeader(objectAddress);",
          "613:     unsigned char attributes = ObjectInfoBits::NoBit;",
          "614:     if (!this->TryGetAttributes(header, &attributes))",
          "615:     {",
          "616:         return;",
          "617:     }",
          "619:     DUMP_OBJECT_REFERENCE(markContext->GetRecycler(), objectAddress);",
          "621:     size_t objectSize = header->objectSize;",
          "622:     if (this->InPageHeapMode())",
          "623:     {",
          "625:         objectSize = HeapInfo::RoundObjectSize(objectSize);",
          "626:         if (objectSize == 0)",
          "627:         {",
          "629:             Assert((attributes & FinalizeBit) == 0);",
          "630:             return;",
          "631:         }",
          "632:     }",
          "634:     if (!UpdateAttributesOfMarkedObjects<doSpecialMark>(markContext, objectAddress, objectSize, attributes,",
          "635:         [&](unsigned char attributes) { header->SetAttributes(this->heapInfo->recycler->Cookie, attributes); }))",
          "636:     {",
          "638:         this->SetNeedOOMRescan(markContext->GetRecycler());",
          "641:         if (this->GetPageCount() != 1)",
          "642:         {",
          "645:             header->markOnOOMRescan = true;",
          "646:         }",
          "647:     }",
          "648: }",
          "650: template void LargeHeapBlock::Mark<true>(void* objectAddress, MarkContext * markContext);",
          "651: template void LargeHeapBlock::Mark<false>(void* objectAddress, MarkContext * markContext);",
          "653: bool",
          "654: LargeHeapBlock::TestObjectMarkedBit(void* objectAddress)",
          "655: {",
          "656:     Assert(IsValidObject(objectAddress));",
          "658:     LargeObjectHeader* pHeader = nullptr;",
          "660:     if (GetObjectHeader(objectAddress, &pHeader))",
          "661:     {",
          "662:         Recycler* recycler = this->heapInfo->recycler;",
          "664:         return recycler->heapBlockMap.IsMarked(objectAddress);",
          "665:     }",
          "667:     return FALSE;",
          "668: }",
          "670: void",
          "671: LargeHeapBlock::SetObjectMarkedBit(void* objectAddress)",
          "672: {",
          "673:     Assert(IsValidObject(objectAddress));",
          "675:     LargeObjectHeader* pHeader = nullptr;",
          "677:     if (GetObjectHeader(objectAddress, &pHeader))",
          "678:     {",
          "679:         Recycler* recycler = this->heapInfo->recycler;",
          "681:         recycler->heapBlockMap.SetMark(objectAddress);",
          "682:     }",
          "683: }",
          "685: bool",
          "686: LargeHeapBlock::FindImplicitRootObject(void* objectAddress, Recycler * recycler, RecyclerHeapObjectInfo& heapObject)",
          "687: {",
          "688:     if (!IsValidObject(objectAddress))",
          "689:     {",
          "690:         return false;",
          "691:     }",
          "693:     LargeObjectHeader* pHeader = nullptr;",
          "695:     if (!GetObjectHeader(objectAddress, &pHeader))",
          "696:     {",
          "697:         return false;",
          "698:     }",
          "700: #ifdef LARGEHEAPBLOCK_ENCODING",
          "701:     heapObject = RecyclerHeapObjectInfo(objectAddress, recycler, this, nullptr);",
          "702:     heapObject.SetLargeHeapBlockHeader(pHeader);",
          "703: #else",
          "704:     heapObject = RecyclerHeapObjectInfo(objectAddress, recycler, this, pHeader->GetAttributesPtr());",
          "705: #endif",
          "706:     return true;",
          "707: }",
          "709: bool",
          "710: LargeHeapBlock::FindHeapObject(void* objectAddress, Recycler * recycler, FindHeapObjectFlags, RecyclerHeapObjectInfo& heapObject)",
          "711: {",
          "713:     return FindImplicitRootObject(objectAddress, recycler, heapObject);",
          "714: }",
          "716: bool",
          "717: LargeHeapBlock::GetObjectHeader(void* objectAddress, LargeObjectHeader** ppHeader)",
          "718: {",
          "719:     (*ppHeader) = nullptr;",
          "721:     LargeObjectHeader * header = GetHeader(objectAddress);",
          "722:     if ((char *)header < this->address)",
          "723:     {",
          "724:         return false;",
          "725:     }",
          "727:     uint index = header->objectIndex;",
          "729:     if (this->HeaderList()[index] != header)",
          "730:     {",
          "732:         return false;",
          "733:     }",
          "735:     Assert(index < this->allocCount);",
          "736:     (*ppHeader) = header;",
          "737:     return true;",
          "738: }",
          "740: void",
          "741: LargeHeapBlock::ResetMarks(ResetMarkFlags flags, Recycler* recycler)",
          "742: {",
          "743:     Assert(!this->needOOMRescan);",
          "746:     this->lastCollectAllocCount = this->allocCount;",
          "748:     Assert(this->GetMarkCount() == 0);",
          "750: #if ENABLE_CONCURRENT_GC",
          "751:     Assert(!this->isPendingConcurrentSweep);",
          "752: #endif",
          "754:     if (flags & ResetMarkFlags_ScanImplicitRoot)",
          "755:     {",
          "756:         for (uint objectIndex = 0; objectIndex < allocCount; objectIndex++)",
          "757:         {",
          "759:             LargeObjectHeader * header = this->GetHeader(objectIndex);",
          "761:             if (header == nullptr)",
          "762:             {",
          "763:                 continue;",
          "764:             }",
          "767:             if ((header->GetAttributes(this->heapInfo->recycler->Cookie) & ImplicitRootBit) != 0)",
          "768:             {",
          "769:                 recycler->heapBlockMap.SetMark(header->GetAddress());",
          "770:             }",
          "771:         }",
          "772:     }",
          "773: }",
          "775: LargeObjectHeader *",
          "776: LargeHeapBlock::GetHeader(void * objectAddress)",
          "777: {",
          "778:     Assert(objectAddress >= this->address && objectAddress < this->addressEnd);",
          "779:     return GetHeaderFromAddress(objectAddress);",
          "780: }",
          "782: LargeObjectHeader *",
          "783: LargeHeapBlock::GetHeaderFromAddress(void * objectAddress)",
          "784: {",
          "785:     return (LargeObjectHeader*)(((char *)objectAddress) - sizeof(LargeObjectHeader));",
          "786: }",
          "788: byte *",
          "789: LargeHeapBlock::GetRealAddressFromInterior(void * interiorAddress)",
          "790: {",
          "791:     for (uint i = 0; i < allocCount; i++)",
          "792:     {",
          "793:         LargeObjectHeader * header = this->HeaderList()[i];",
          "795: #if ENABLE_PARTIAL_GC && ENABLE_CONCURRENT_GC",
          "796:         if (header != nullptr && !IsPartialSweptHeader(header))",
          "797: #else",
          "798:         if (header != nullptr)",
          "799: #endif",
          "800:         {",
          "801:             Assert(header->objectIndex == i);",
          "802:             byte * startAddress = (byte *)header->GetAddress();",
          "803:             if (startAddress <= interiorAddress && (startAddress + header->objectSize > interiorAddress))",
          "804:             {",
          "805:                 return startAddress;",
          "806:             }",
          "807:         }",
          "808:     }",
          "810:     return nullptr;",
          "811: }",
          "813: #ifdef RECYCLER_VERIFY_MARK",
          "815: void",
          "816: LargeHeapBlock::VerifyMark()",
          "817: {",
          "818:     Assert(!this->needOOMRescan);",
          "819:     Recycler* recycler = this->heapInfo->recycler;",
          "821:     for (uint i = 0; i < allocCount; i++)",
          "822:     {",
          "823:         LargeObjectHeader * header = this->GetHeader(i);",
          "824:         if (header == nullptr)",
          "825:         {",
          "826:             continue;",
          "827:         }",
          "829:         char * objectAddress = (char *)header->GetAddress();",
          "830:         if (!recycler->heapBlockMap.IsMarked(objectAddress))",
          "831:         {",
          "832:             continue;",
          "833:         }",
          "835:         unsigned char attributes = header->GetAttributes(this->heapInfo->recycler->Cookie);",
          "837:         Assert((attributes & NewFinalizeBit) == 0);",
          "839:         if ((attributes & LeafBit) != 0)",
          "840:         {",
          "841:             continue;",
          "842:         }",
          "844:         Assert(!header->markOnOOMRescan);",
          "846:         char * objectAddressEnd = objectAddress + header->objectSize;",
          "848:         while (objectAddress + sizeof(void *) <= objectAddressEnd)",
          "849:         {",
          "850:             void* target = *(void **)objectAddress;",
          "852:             if (recycler->VerifyMark(objectAddress, target))",
          "853:             {",
          "854: #if DBG && GLOBAL_ENABLE_WRITE_BARRIER",
          "855:                 if (CONFIG_FLAG(ForceSoftwareWriteBarrier) && CONFIG_FLAG(VerifyBarrierBit))",
          "856:                 {",
          "857:                     this->WBVerifyBitIsSet(objectAddress);",
          "858:                 }",
          "859: #endif",
          "860:             }",
          "862:             objectAddress += sizeof(void *);",
          "863:         }",
          "864:     }",
          "865: }",
          "867: bool",
          "868: LargeHeapBlock::VerifyMark(void * objectAddress, void* target)",
          "869: {",
          "870:     LargeObjectHeader * header = GetHeader(target);",
          "872:     if ((char *)header < this->address)",
          "873:     {",
          "874:         return false;",
          "875:     }",
          "877:     uint index = header->objectIndex;",
          "879:     if (index >= this->allocCount)",
          "880:     {",
          "882:         return false;",
          "883:     }",
          "885:     if (this->HeaderList()[index] != header)",
          "886:     {",
          "888:         return false;",
          "889:     }",
          "891:     bool isMarked = this->heapInfo->recycler->heapBlockMap.IsMarked(target);",
          "893: #if DBG",
          "894:     if (!isMarked)",
          "895:     {",
          "896:         PrintVerifyMarkFailure(this->GetRecycler(), (char*)objectAddress, (char*)target);",
          "897:     }",
          "898: #else",
          "899:     if (!isMarked)",
          "900:     {",
          "901:         DebugBreak();",
          "902:     }",
          "903: #endif",
          "904:     return isMarked;",
          "905: }",
          "907: #endif",
          "909: void",
          "910: LargeHeapBlock::ScanInitialImplicitRoots(Recycler * recycler)",
          "911: {",
          "912:     Assert(recycler->enableScanImplicitRoots);",
          "913:     const HeapBlockMap& heapBlockMap = recycler->heapBlockMap;",
          "914:     for (uint objectIndex = 0; objectIndex < allocCount; objectIndex++)",
          "915:     {",
          "917:         LargeObjectHeader * header = this->GetHeader(objectIndex);",
          "919:         if (header == nullptr)",
          "920:         {",
          "921:             continue;",
          "922:         }",
          "925:         if ((header->GetAttributes(this->heapInfo->recycler->Cookie) & LeafBit) != 0)",
          "926:         {",
          "927:             continue;",
          "928:         }",
          "930:         char * objectAddress = (char *)header->GetAddress();",
          "933:         if (!heapBlockMap.IsMarked(objectAddress))",
          "934:         {",
          "935:             continue;",
          "936:         }",
          "939:         DUMP_IMPLICIT_ROOT(recycler, objectAddress);",
          "941:         if (this->InPageHeapMode())",
          "942:         {",
          "943:             size_t objectSize = header->objectSize;",
          "945:             objectSize = HeapInfo::RoundObjectSize(objectSize);",
          "946:             if (objectSize > 0) // otherwize the object total size is less than a pointer size",
          "947:             {",
          "948:                 recycler->ScanObjectInlineInterior((void **)objectAddress, objectSize);",
          "949:             }",
          "950:         }",
          "951:         else",
          "952:         {",
          "953:             recycler->ScanObjectInlineInterior((void **)objectAddress, header->objectSize);",
          "954:         }",
          "955:     }",
          "956: }",
          "958: void",
          "959: LargeHeapBlock::ScanNewImplicitRoots(Recycler * recycler)",
          "960: {",
          "961:     Assert(recycler->enableScanImplicitRoots);",
          "963:     uint objectIndex = 0;",
          "964:     HeapBlockMap& heapBlockMap = recycler->heapBlockMap;",
          "965:     while (objectIndex < allocCount)",
          "966:     {",
          "968:         LargeObjectHeader * header = this->GetHeader(objectIndex);",
          "969:         objectIndex++;",
          "972:         if (header == nullptr)",
          "973:         {",
          "974:             continue;",
          "975:         }",
          "978:         if ((header->GetAttributes(this->heapInfo->recycler->Cookie) & ImplicitRootBit) == 0)",
          "979:         {",
          "980:             continue;",
          "981:         }",
          "983:         char * objectAddress = (char *)header->GetAddress();",
          "985:         bool marked = heapBlockMap.TestAndSetMark(objectAddress);",
          "986:         if (!marked)",
          "987:         {",
          "988:             DUMP_IMPLICIT_ROOT(recycler, objectAddress);",
          "991:             if ((header->GetAttributes(this->heapInfo->recycler->Cookie) & LeafBit) != 0)",
          "992:             {",
          "993:                 continue;",
          "994:             }",
          "996:             if (this->InPageHeapMode())",
          "997:             {",
          "998:                 size_t objectSize = header->objectSize;",
          "1000:                 objectSize = HeapInfo::RoundObjectSize(objectSize);",
          "1001:                 if (objectSize > 0) // otherwize the object total size is less than a pointer size",
          "1002:                 {",
          "1003:                     recycler->ScanObjectInlineInterior((void **)objectAddress, objectSize);",
          "1004:                 }",
          "1005:             }",
          "1006:             else",
          "1007:             {",
          "1009:                 recycler->ScanObjectInlineInterior((void **)objectAddress, header->objectSize);",
          "1010:             }",
          "1011:         }",
          "1012:     }",
          "1013: }",
          "1015: #if ENABLE_CONCURRENT_GC",
          "1016: bool LargeHeapBlock::IsPageDirty(char* page, RescanFlags flags, bool isWriteBarrier)",
          "1017: {",
          "1018: #ifdef RECYCLER_WRITE_BARRIER",
          "1020:     if (CONFIG_FLAG(WriteBarrierTest))",
          "1021:     {",
          "1022:         Assert(isWriteBarrier);",
          "1023:     }",
          "1024:     if (isWriteBarrier)",
          "1025:     {",
          "1026:         return (RecyclerWriteBarrierManager::GetWriteBarrier(page) & DIRTYBIT) == DIRTYBIT;",
          "1027:     }",
          "1028: #endif",
          "1030: #ifdef RECYCLER_WRITE_WATCH",
          "1031:     if (!CONFIG_FLAG(ForceSoftwareWriteBarrier))",
          "1032:     {",
          "1033:         ULONG_PTR count = 1;",
          "1034:         DWORD pageSize = AutoSystemInfo::PageSize;",
          "1035:         DWORD const writeWatchFlags = (flags & RescanFlags_ResetWriteWatch ? WRITE_WATCH_FLAG_RESET : 0);",
          "1036:         void * written = nullptr;",
          "1037:         UINT ret = GetWriteWatch(writeWatchFlags, page, AutoSystemInfo::PageSize, &written, &count, &pageSize);",
          "1038:         bool isDirty = (ret != 0) || (count == 1);",
          "1039:         return isDirty;",
          "1040:     }",
          "1041:     else",
          "1042:     {",
          "1043:         Js::Throw::FatalInternalError();",
          "1044:     }",
          "1045: #else",
          "1046:     Js::Throw::FatalInternalError();",
          "1047: #endif",
          "1048: }",
          "1049: #endif",
          "1051: #if ENABLE_CONCURRENT_GC",
          "1052: bool",
          "1053: LargeHeapBlock::RescanOnePage(Recycler * recycler, RescanFlags flags)",
          "1054: #else",
          "1055: bool",
          "1056: LargeHeapBlock::RescanOnePage(Recycler * recycler)",
          "1057: #endif",
          "1058: {",
          "1059:     Assert(this->GetPageCount() == 1);",
          "1060:     bool const oldNeedOOMRescan = this->needOOMRescan;",
          "1063:     this->needOOMRescan = false;",
          "1065: #if ENABLE_CONCURRENT_GC",
          "1067:     if (!oldNeedOOMRescan)",
          "1068:     {",
          "1069:         if (recycler->inEndMarkOnLowMemory)",
          "1070:         {",
          "1072:             return false;",
          "1073:         }",
          "1077:         LargeObjectHeader* header = this->GetHeader(0u);",
          "1078:         if ((header->GetAttributes(this->heapInfo->recycler->Cookie) & LeafBit) == LeafBit)",
          "1079:         {",
          "1080:             return false;",
          "1081:         }",
          "1082:         bool hasWriteBarrier = false;",
          "1083: #ifdef RECYCLER_WRITE_BARRIER",
          "1084:         hasWriteBarrier = header->hasWriteBarrier;",
          "1085: #endif",
          "1086:         if (!IsPageDirty(this->GetBeginAddress(), flags, hasWriteBarrier))",
          "1087:         {",
          "1088:             return false;",
          "1089:         }",
          "1090:     }",
          "1091: #else",
          "1093:     Assert(oldNeedOOMRescan);",
          "1094: #endif",
          "1096:     RECYCLER_STATS_INC(recycler, markData.rescanLargePageCount);",
          "1098:     for (uint objectIndex = 0; objectIndex < allocCount; objectIndex++)",
          "1099:     {",
          "1101:         LargeObjectHeader * header = this->GetHeader(objectIndex);",
          "1104:         if (header == nullptr)",
          "1105:         {",
          "1106:             continue;",
          "1107:         }",
          "1109:         char * objectAddress = (char *)header->GetAddress();",
          "1112:         if (!recycler->heapBlockMap.IsMarked(objectAddress))",
          "1113:         {",
          "1114:             continue;",
          "1115:         }",
          "1117:         unsigned char attributes = header->GetAttributes(this->heapInfo->recycler->Cookie);",
          "1119: #ifdef RECYCLER_STATS",
          "1120:         if (((attributes & FinalizeBit) != 0) && ((attributes & NewFinalizeBit) != 0))",
          "1121:         {",
          "1125:             RECYCLER_STATS_INC(recycler, finalizeCount);",
          "1126:             header->SetAttributes(this->heapInfo->recycler->Cookie, (attributes & ~NewFinalizeBit));",
          "1127:         }",
          "1128: #endif",
          "1131:         if ((attributes & LeafBit) != 0)",
          "1132:         {",
          "1133:             continue;",
          "1134:         }",
          "1136:         RECYCLER_STATS_INC(recycler, markData.rescanLargeObjectCount);",
          "1137:         RECYCLER_STATS_ADD(recycler, markData.rescanLargeByteCount, header->objectSize);",
          "1139:         size_t objectSize = header->objectSize;",
          "1140:         if (this->InPageHeapMode())",
          "1141:         {",
          "1143:             objectSize = HeapInfo::RoundObjectSize(objectSize);",
          "1144:         }",
          "1145:         if (objectSize > 0) // otherwize the object total size is less than a pointer size",
          "1146:         {",
          "1147:             if (!recycler->AddMark(objectAddress, objectSize))",
          "1148:             {",
          "1149:                 this->SetNeedOOMRescan(recycler);",
          "1150:             }",
          "1151:         }",
          "1152:     }",
          "1153:     return true;",
          "1154: }",
          "1156: size_t",
          "1157: LargeHeapBlock::Rescan(Recycler * recycler, bool isPartialSwept, RescanFlags flags)",
          "1158: {",
          "1160:     this->lastCollectAllocCount = this->allocCount;",
          "1162: #if ENABLE_CONCURRENT_GC",
          "1163:     Assert(recycler->collectionState != CollectionStateConcurrentFinishMark || (flags & RescanFlags_ResetWriteWatch));",
          "1164:     if (this->GetPageCount() == 1)",
          "1165:     {",
          "1166:         return RescanOnePage(recycler, flags);",
          "1167:     }",
          "1170:     if (recycler->collectionState != CollectionStateConcurrentFinishMark && recycler->IsConcurrentMarkState())",
          "1171:     {",
          "1174:         return 0;",
          "1175:     }",
          "1176:     return RescanMultiPage(recycler, flags);",
          "1177: #else",
          "1178:     return this->GetPageCount() == 1 ? RescanOnePage(recycler) : RescanMultiPage(recycler);",
          "1179: #endif",
          "1180: }",
          "1182: #if ENABLE_CONCURRENT_GC",
          "1183: size_t",
          "1184: LargeHeapBlock::RescanMultiPage(Recycler * recycler, RescanFlags flags)",
          "1185: #else",
          "1186: size_t",
          "1187: LargeHeapBlock::RescanMultiPage(Recycler * recycler)",
          "1188: #endif",
          "1189: {",
          "1190:     Assert(this->GetPageCount() != 1);",
          "1191:     DebugOnly(bool oldNeedOOMRescan = this->needOOMRescan);",
          "1194:     this->needOOMRescan = false;",
          "1196:     size_t rescanCount = 0;",
          "1197:     uint objectIndex = 0;",
          "1198: #if ENABLE_CONCURRENT_GC",
          "1199:     char * lastPageCheckedForWriteWatch = nullptr;",
          "1200:     bool isLastPageCheckedForWriteWatchDirty = false;",
          "1201: #endif",
          "1203:     const HeapBlockMap& heapBlockMap = recycler->heapBlockMap;",
          "1205:     while (objectIndex < allocCount)",
          "1206:     {",
          "1208:         LargeObjectHeader * header = this->GetHeader(objectIndex);",
          "1209:         objectIndex++;",
          "1212:         if (header == nullptr)",
          "1213:         {",
          "1214:             continue;",
          "1215:         }",
          "1217:         char * objectAddress = (char *)header->GetAddress();",
          "1220:         if (!heapBlockMap.IsMarked(objectAddress))",
          "1221:         {",
          "1222:             continue;",
          "1223:         }",
          "1225:         unsigned char attributes = header->GetAttributes(this->heapInfo->recycler->Cookie);",
          "1227: #ifdef RECYCLER_STATS",
          "1228:         if (((attributes & FinalizeBit) != 0) && ((attributes & NewFinalizeBit) != 0))",
          "1229:         {",
          "1233:             RECYCLER_STATS_INC(recycler, finalizeCount);",
          "1234:             header->SetAttributes(this->heapInfo->recycler->Cookie, (attributes & ~NewFinalizeBit));",
          "1235:         }",
          "1236: #endif",
          "1239:         if ((attributes & LeafBit) != 0)",
          "1240:         {",
          "1241:             continue;",
          "1242:         }",
          "1244: #ifdef RECYCLER_STATS",
          "1245:         bool objectScanned = false;",
          "1246: #endif",
          "1248:         size_t objectSize = header->objectSize;",
          "1249:         if (this->InPageHeapMode())",
          "1250:         {",
          "1252:             objectSize = HeapInfo::RoundObjectSize(objectSize);",
          "1253:         }",
          "1255:         Assert(objectSize > 0);",
          "1256:         Assert(oldNeedOOMRescan || !header->markOnOOMRescan);",
          "1258:         if (header->markOnOOMRescan)",
          "1259:         {",
          "1260:             if (!recycler->AddMark(objectAddress, objectSize))",
          "1261:             {",
          "1262:                 this->SetNeedOOMRescan(recycler);",
          "1263:                 header->markOnOOMRescan = true;",
          "1274:                 if (!recycler->inEndMarkOnLowMemory)",
          "1275:                 {",
          "1276:                     continue;",
          "1277:                 }",
          "1279:                 return rescanCount;",
          "1280:             }",
          "1281:             header->markOnOOMRescan = false;",
          "1282: #ifdef RECYCLER_STATS",
          "1283:             objectScanned = true;",
          "1284: #endif",
          "1285:         }",
          "1286: #if ENABLE_CONCURRENT_GC",
          "1287:         else if (!recycler->inEndMarkOnLowMemory)",
          "1288:         {",
          "1289:             char * objectAddressEnd = objectAddress + objectSize;",
          "1292:             do",
          "1293:             {",
          "1294:                 char * pageStart = (char *)(((size_t)objectAddress) & ~(size_t)(AutoSystemInfo::PageSize - 1));",
          "1308:                 if (lastPageCheckedForWriteWatch != pageStart)",
          "1309:                 {",
          "1310:                     lastPageCheckedForWriteWatch = pageStart;",
          "1311:                     isLastPageCheckedForWriteWatchDirty = true;",
          "1312:                     bool hasWriteBarrier = false;",
          "1313: #ifdef RECYCLER_WRITE_BARRIER",
          "1314:                     hasWriteBarrier = header->hasWriteBarrier;",
          "1315: #endif",
          "1316:                     if (!IsPageDirty(pageStart, flags, hasWriteBarrier))",
          "1317:                     {",
          "1319:                         isLastPageCheckedForWriteWatchDirty = false;",
          "1320:                     }",
          "1321:                 }",
          "1323:                 if (!isLastPageCheckedForWriteWatchDirty)",
          "1324:                 {",
          "1325:                     objectAddress = pageStart + AutoSystemInfo::PageSize;",
          "1326:                     continue;",
          "1327:                 }",
          "1331:                 char * checkEnd = min(pageStart + AutoSystemInfo::PageSize, objectAddressEnd);",
          "1332:                 if (!recycler->AddMark(objectAddress, (checkEnd - objectAddress)))",
          "1333:                 {",
          "1334:                     this->SetNeedOOMRescan(recycler);",
          "1335:                     header->markOnOOMRescan = true;",
          "1336:                 }",
          "1338: #ifdef RECYCLER_STATS",
          "1339:                 objectScanned = true;",
          "1340:                 recycler->collectionStats.markData.rescanLargePageCount++;",
          "1341:                 recycler->collectionStats.markData.rescanLargeByteCount += (checkEnd - objectAddress);",
          "1342: #endif",
          "1343:                 objectAddress = checkEnd;",
          "1344:                 rescanCount++;",
          "1345:             }",
          "1346:             while (objectAddress < objectAddressEnd);",
          "1347:         }",
          "1348: #else",
          "1349:         else",
          "1350:         {",
          "1351:             Assert(recycler->inEndMarkOnLowMemory);",
          "1352:         }",
          "1353: #endif",
          "1354:         RECYCLER_STATS_ADD(recycler, markData.rescanLargeObjectCount, objectScanned);",
          "1355:     }",
          "1357:     return rescanCount;",
          "1358: }",
          "1377: SweepState",
          "1378: LargeHeapBlock::Sweep(RecyclerSweep& recyclerSweep, bool queuePendingSweep)",
          "1379: {",
          "1380:     Recycler * recycler = recyclerSweep.GetRecycler();",
          "1382:     uint markCount = GetMarkCount();",
          "1383: #if DBG",
          "1384:     Assert(this->lastCollectAllocCount == this->allocCount);",
          "1385:     Assert(markCount <= allocCount);",
          "1386: #endif",
          "1388:     RECYCLER_STATS_INC(recycler, heapBlockCount[HeapBlock::LargeBlockType]);",
          "1390: #if DBG",
          "1391:     this->expectedSweepCount = allocCount - markCount;",
          "1392: #endif",
          "1394: #if ENABLE_CONCURRENT_GC",
          "1395:     Assert(!this->isPendingConcurrentSweep);",
          "1396: #endif",
          "1398:     bool isAllFreed = (finalizeCount == 0 && markCount == 0);",
          "1399:     if (isAllFreed)",
          "1400:     {",
          "1401:         recycler->NotifyFree(this);",
          "1402:         Assert(this->pendingDisposeObject == nullptr);",
          "1403:         return SweepStateEmpty;",
          "1404:     }",
          "1406:     RECYCLER_STATS_ADD(recycler, largeHeapBlockTotalByteCount, this->pageCount * AutoSystemInfo::PageSize);",
          "1407:     RECYCLER_STATS_ADD(recycler, heapBlockFreeByteCount[HeapBlock::LargeBlockType],",
          "1408:         addressEnd - allocAddressEnd <= HeapConstants::MaxSmallObjectSize? 0 : (size_t)(addressEnd - allocAddressEnd));",
          "1413:     if (markCount != allocCount)",
          "1414:     {",
          "1415:         Assert(this->expectedSweepCount != 0);",
          "1427:         Assert(!recyclerSweep.IsBackground());",
          "1428: #if ENABLE_CONCURRENT_GC",
          "1429:         if (queuePendingSweep && finalizeCount == 0)",
          "1430:         {",
          "1431:             this->isPendingConcurrentSweep = true;",
          "1432:             return SweepStatePendingSweep;",
          "1433:         }",
          "1434: #else",
          "1435:         Assert(!queuePendingSweep);",
          "1436: #endif",
          "1438:         SweepObjects<SweepMode_InThread>(recycler);",
          "1439:         if (TransferSweptObjects())",
          "1440:         {",
          "1441:             return SweepStatePendingDispose;",
          "1442:         }",
          "1443:     }",
          "1444: #ifdef RECYCLER_STATS",
          "1445:     else",
          "1446:     {",
          "1447:         Assert(expectedSweepCount == 0);",
          "1448:         isForceSweeping = true;",
          "1449:         SweepObjects<SweepMode_InThread>(recycler);",
          "1450:         isForceSweeping = false;",
          "1451:     }",
          "1452: #endif",
          "1453:     if (this->pendingDisposeObject != nullptr)",
          "1454:     {",
          "1455:         return SweepStatePendingDispose;",
          "1456:     }",
          "1457:     return (allocCount == objectCount || addressEnd - allocAddressEnd <= HeapConstants::MaxSmallObjectSize) && this->freeList.entries == nullptr ?",
          "1458:     SweepStateFull : SweepStateSwept;",
          "1459: }",
          "1461: bool",
          "1462: LargeHeapBlock::TrimObject(Recycler* recycler, LargeObjectHeader* header, size_t sizeOfObject, bool inDispose)",
          "1463: {",
          "1464:     IdleDecommitPageAllocator* pageAllocator = recycler->GetRecyclerLargeBlockPageAllocator();",
          "1465:     uint pageSize = AutoSystemInfo::PageSize ;",
          "1469:     Assert(this->allocCount > 1 || this->isForceSweeping || inDispose);",
          "1477:     if (sizeOfObject > pageSize &&",
          "1478:         this->segment->GetPageCount() <= pageAllocator->GetMaxAllocPageCount() &&",
          "1479:         this->allocCount > 1)",
          "1480:     {",
          "1481:         Assert(!this->hadTrimmed);",
          "1491:         char* objectAddress = (char*) header;",
          "1492:         char* objectEndAddress = objectAddress + sizeof(LargeObjectHeader) + header->objectSize;",
          "1494:         uintptr_t alignmentMask = ~((uintptr_t) (AutoSystemInfo::PageSize - 1));",
          "1496:         uintptr_t objectFreeAddress = (uintptr_t) objectAddress;",
          "1497:         uintptr_t objectFreeEndAddress = ((uintptr_t) objectEndAddress) & alignmentMask;",
          "1499:         size_t bytesToFree = (objectFreeEndAddress - objectFreeAddress);",
          "1507:         Assert(objectAddress == this->address);",
          "1508:         Assert(header->objectIndex == 0);",
          "1509:         Assert(objectFreeEndAddress <= (uintptr_t) objectEndAddress);",
          "1510:         Assert(objectFreeAddress <= objectFreeEndAddress);",
          "1511:         Assert(bytesToFree < sizeOfObject + sizeof(LargeObjectHeader) || (uintptr_t) objectEndAddress == objectFreeEndAddress);",
          "1517:         Assert(bytesToFree > 0);",
          "1518:         Assert((bytesToFree & (AutoSystemInfo::PageSize - 1)) == 0);",
          "1519:         size_t freePageCount = bytesToFree / AutoSystemInfo::PageSize;",
          "1520:         Assert(freePageCount > 0);",
          "1521:         Assert(freePageCount < this->pageCount);",
          "1526:         if (inDispose)",
          "1527:         {",
          "1528:             pageAllocator->SuspendIdleDecommit();",
          "1529:         }",
          "1531:         pageAllocator->Release((char*) objectFreeAddress, freePageCount, this->GetSegment());",
          "1533:         if (inDispose)",
          "1534:         {",
          "1535:             pageAllocator->ResumeIdleDecommit();",
          "1536:         }",
          "1541:         recycler->heapBlockMap.ClearHeapBlock(this->address, freePageCount);",
          "1543:         this->address = (char*) objectFreeEndAddress;",
          "1544:         this->pageCount -= freePageCount;",
          "1546:         FillFreeMemory(recycler, (void*) objectFreeEndAddress, (size_t) (objectEndAddress - objectFreeEndAddress));",
          "1548: #if DBG",
          "1549:         this->hadTrimmed = true;",
          "1550: #endif",
          "1551:         return true;",
          "1552:     }",
          "1554:     return false;",
          "1555: }",
          "1558: template <>",
          "1559: void",
          "1560: LargeHeapBlock::SweepObject<SweepMode_InThread>(Recycler * recycler, LargeObjectHeader * header)",
          "1561: {",
          "1562:     Assert(this->HeaderList()[header->objectIndex] == header);",
          "1566:     if ((header->GetAttributes(this->heapInfo->recycler->Cookie) & FinalizeBit) != FinalizeBit)",
          "1567:     {",
          "1568:         this->HeaderList()[header->objectIndex] = nullptr;",
          "1570:         size_t sizeOfObject = header->objectSize;",
          "1572:         bool objectTrimmed = false;",
          "1574:         if (!this->bucket->SupportFreeList())",
          "1575:         {",
          "1576:             objectTrimmed = TrimObject(recycler, header, sizeOfObject);",
          "1577:         }",
          "1579:         if (!objectTrimmed)",
          "1580:         {",
          "1581:             FillFreeMemory(recycler, header, sizeof(LargeObjectHeader) + sizeOfObject);",
          "1582:         }",
          "1583:     }",
          "1584: }",
          "1589: void",
          "1590: LargeHeapBlock::FinalizeObject(Recycler* recycler, LargeObjectHeader* header)",
          "1591: {",
          "1594:     Assert(this->HeaderList()[header->objectIndex] == header);",
          "1595:     Assert(header->GetAttributes(this->heapInfo->recycler->Cookie) & FinalizeBit);",
          "1601:     ((FinalizableObject *)header->GetAddress())->Finalize(false);",
          "1602:     header->SetNext(this->heapInfo->recycler->Cookie, this->pendingDisposeObject);",
          "1603:     this->pendingDisposeObject = header;",
          "1607:     this->HeaderList()[header->objectIndex] = nullptr;",
          "1609: #ifdef RECYCLER_FINALIZE_CHECK",
          "1610:     recycler->autoHeap.pendingDisposableObjectCount++;",
          "1611: #endif",
          "1612: }",
          "1615: template void LargeHeapBlock::SweepObjects<SweepMode_InThread>(Recycler * recycler);",
          "1616: #if ENABLE_CONCURRENT_GC",
          "1617: template <>",
          "1618: void",
          "1619: LargeHeapBlock::SweepObject<SweepMode_Concurrent>(Recycler * recycler, LargeObjectHeader * header)",
          "1620: {",
          "1621:     Assert(!(header->GetAttributes(this->heapInfo->recycler->Cookie) & FinalizeBit));",
          "1622:     Assert(this->HeaderList()[header->objectIndex] == header);",
          "1623:     this->HeaderList()[header->objectIndex] = nullptr;",
          "1624:     FillFreeMemory(recycler, header, sizeof(LargeObjectHeader) + header->objectSize);",
          "1625: }",
          "1628: template void LargeHeapBlock::SweepObjects<SweepMode_Concurrent>(Recycler * recycler);",
          "1629: #if ENABLE_PARTIAL_GC",
          "1630: template <>",
          "1631: void",
          "1632: LargeHeapBlock::SweepObject<SweepMode_ConcurrentPartial>(Recycler * recycler, LargeObjectHeader * header)",
          "1633: {",
          "1634:     Assert(!(header->GetAttributes(this->heapInfo->recycler->Cookie) & FinalizeBit));",
          "1635:     Assert(this->HeaderList()[header->objectIndex] == header);",
          "1636:     this->HeaderList()[header->objectIndex] = (LargeObjectHeader *)((size_t)header | PartialFreeBit);",
          "1637:     DebugOnly(this->hasPartialFreeObjects = true);",
          "1638: }",
          "1641: template void LargeHeapBlock::SweepObjects<SweepMode_ConcurrentPartial>(Recycler * recycler);",
          "1642: #endif",
          "1643: #endif",
          "1654: void LargeHeapBlock::FinalizeObjects(Recycler* recycler)",
          "1655: {",
          "1656:     const HeapBlockMap& heapBlockMap = recycler->heapBlockMap;",
          "1658:     for (uint i = 0; i < this->lastCollectAllocCount; i++)",
          "1659:     {",
          "1660:         LargeObjectHeader * header = this->GetHeader(i);",
          "1661:         if (header == nullptr)",
          "1662:         {",
          "1663:             continue;",
          "1664:         }",
          "1666:         Assert(header->objectIndex == i);",
          "1669:         if (heapBlockMap.IsMarked(header->GetAddress()))",
          "1670:         {",
          "1671:             continue;",
          "1672:         }",
          "1674:         if ((header->GetAttributes(this->heapInfo->recycler->Cookie) & FinalizeBit) == FinalizeBit)",
          "1675:         {",
          "1676:             recycler->NotifyFree((char *)header->GetAddress(), header->objectSize);",
          "1677:             FinalizeObject(recycler, header);",
          "1678:         }",
          "1679:     }",
          "1680: }",
          "1682: template <SweepMode mode>",
          "1683: void",
          "1684: LargeHeapBlock::SweepObjects(Recycler * recycler)",
          "1685: {",
          "1686: #if ENABLE_CONCURRENT_GC",
          "1687:     Assert(mode == SweepMode_InThread || this->isPendingConcurrentSweep);",
          "1688: #else",
          "1689:     Assert(mode == SweepMode_InThread);",
          "1690: #endif",
          "1692:     const HeapBlockMap& heapBlockMap = recycler->heapBlockMap;",
          "1693: #if DBG",
          "1694:     uint markCount = GetMarkCount();",
          "1697: #if ENABLE_CONCURRENT_GC",
          "1698:     Assert(expectedSweepCount == allocCount - markCount || recycler->collectionState == CollectionStateConcurrentSweep);",
          "1699: #else",
          "1700:     Assert(expectedSweepCount == allocCount - markCount);",
          "1701: #endif",
          "1702:     Assert(expectedSweepCount != 0 || isForceSweeping);",
          "1703:     uint sweepCount = 0;",
          "1704: #endif",
          "1706:     for (uint i = 0; i < lastCollectAllocCount; i++)",
          "1707:     {",
          "1708:         RECYCLER_STATS_ADD(recycler, objectSweepScanCount, !isForceSweeping);",
          "1709:         LargeObjectHeader * header = this->GetHeader(i);",
          "1710:         if (header == nullptr)",
          "1711:         {",
          "1712: #if DBG",
          "1713:             Assert(expectedSweepCount != 0);",
          "1714:             expectedSweepCount--;",
          "1715: #endif",
          "1716: #if DBG",
          "1717:             LargeAllocationVerboseTrace(recycler->GetRecyclerFlagsTable(), _u(\"Index %d empty\\n\"), i);",
          "1718: #endif",
          "1719:             continue;",
          "1720:         }",
          "1722:         Assert(header->objectIndex == i);",
          "1725:         if (heapBlockMap.IsMarked(header->GetAddress()))",
          "1726:         {",
          "1727: #if DBG",
          "1728:             Assert((header->GetAttributes(recycler->Cookie) & NewFinalizeBit) == 0);",
          "1729: #endif",
          "1731:             RECYCLER_STATS_ADD(recycler, largeHeapBlockUsedByteCount, this->GetHeader(i)->objectSize);",
          "1732:             continue;",
          "1733:         }",
          "1735:         size_t objectSize = header->objectSize;",
          "1736:         recycler->NotifyFree((char *)header->GetAddress(), objectSize);",
          "1738:         SweepObject<mode>(recycler, header);",
          "1740:         if (this->bucket->SupportFreeList()",
          "1741: #ifdef RECYCLER_STATS",
          "1742:             && !isForceSweeping",
          "1743: #endif",
          "1744:             )",
          "1745:         {",
          "1746:             LargeHeapBlockFreeListEntry* head = this->freeList.entries;",
          "1747:             LargeHeapBlockFreeListEntry* entry = (LargeHeapBlockFreeListEntry*) header;",
          "1748:             entry->headerIndex = i;",
          "1749:             entry->heapBlock = this;",
          "1750:             entry->next = head;",
          "1751:             entry->objectSize = objectSize;",
          "1752:             this->freeList.entries = entry;",
          "1753:         }",
          "1755: #if DBG",
          "1756:         sweepCount++;",
          "1757: #endif",
          "1758:     }",
          "1760:     Assert(sweepCount == expectedSweepCount);",
          "1761: #if ENABLE_CONCURRENT_GC",
          "1762:     this->isPendingConcurrentSweep = false;",
          "1763: #endif",
          "1764: }",
          "1766: bool",
          "1767: LargeHeapBlock::TransferSweptObjects()",
          "1768: {",
          "1770:     return pendingDisposeObject != nullptr;",
          "1771: }",
          "1773: void",
          "1774: LargeHeapBlock::DisposeObjects(Recycler * recycler)",
          "1775: {",
          "1776:     Assert(this->pendingDisposeObject != nullptr || this->hasDisposeBeenCalled);",
          "1778:     while (pendingDisposeObject != nullptr)",
          "1779:     {",
          "1780: #if DBG",
          "1781:         this->hasDisposeBeenCalled = true;",
          "1782: #endif",
          "1784:         LargeObjectHeader * header = pendingDisposeObject;",
          "1785:         pendingDisposeObject = header->GetNext(this->heapInfo->recycler->Cookie);",
          "1786:         Assert(header->GetAttributes(this->heapInfo->recycler->Cookie) & FinalizeBit);",
          "1787:         Assert(this->HeaderList()[header->objectIndex] == nullptr);",
          "1789:         void * objectAddress = header->GetAddress();",
          "1790:         ((FinalizableObject *)objectAddress)->Dispose(false);",
          "1792:         Assert(finalizeCount != 0);",
          "1793:         finalizeCount--;",
          "1795:         bool objectTrimmed = false;",
          "1797:         if (this->bucket->SupportFreeList())",
          "1798:         {",
          "1799:             objectTrimmed = TrimObject(recycler, header, header->objectSize, true /* need suspend */);",
          "1800:         }",
          "1805:         if (!objectTrimmed)",
          "1806:         {",
          "1807:             FillFreeMemory(recycler, header, sizeof(LargeObjectHeader) + header->objectSize);",
          "1808:         }",
          "1810:         RECYCLER_STATS_INC(recycler, finalizeSweepCount);",
          "1811: #ifdef RECYCLER_FINALIZE_CHECK",
          "1812:         this->heapInfo->liveFinalizableObjectCount--;",
          "1813:         this->heapInfo->pendingDisposableObjectCount--;",
          "1814: #endif",
          "1815:     }",
          "1816: }",
          "1818: #if ENABLE_PARTIAL_GC && ENABLE_CONCURRENT_GC",
          "1819: void",
          "1820: LargeHeapBlock::PartialTransferSweptObjects()",
          "1821: {",
          "1823:     Assert(this->hasPartialFreeObjects);",
          "1824: }",
          "1826: void",
          "1827: LargeHeapBlock::FinishPartialCollect(Recycler * recycler)",
          "1828: {",
          "1829:     Assert(this->hasPartialFreeObjects);",
          "1830:     for (uint i = 0; i < allocCount; i++)",
          "1831:     {",
          "1832:         LargeObjectHeader * header = this->HeaderList()[i];",
          "1834:         if (header != nullptr && IsPartialSweptHeader(header))",
          "1835:         {",
          "1836:             header = (LargeObjectHeader *)((size_t)header & ~PartialFreeBit);",
          "1837:             Assert(header->objectIndex == i);",
          "1838:             this->HeaderList()[i] = nullptr;",
          "1839:             FillFreeMemory(recycler, header, sizeof(LargeObjectHeader) + header->objectSize);",
          "1840:         }",
          "1841:     }",
          "1842:     DebugOnly(this->hasPartialFreeObjects = false);",
          "1843: }",
          "1844: #endif",
          "1846: void",
          "1847: LargeHeapBlock::EnumerateObjects(ObjectInfoBits infoBits, void (*CallBackFunction)(void * address, size_t size))",
          "1848: {",
          "1849:     for (uint i = 0; i < allocCount; i++)",
          "1850:     {",
          "1851:         LargeObjectHeader * header = this->GetHeader(i);",
          "1852:         if (header == nullptr)",
          "1853:         {",
          "1854:             continue;",
          "1855:         }",
          "1856:         if ((header->GetAttributes(this->heapInfo->recycler->Cookie) & infoBits) != 0)",
          "1857:         {",
          "1858:             CallBackFunction(header->GetAddress(), header->objectSize);",
          "1859:         }",
          "1860:     }",
          "1861: }",
          "1864: uint",
          "1865: LargeHeapBlock::GetMaxLargeObjectCount(size_t pageCount, size_t firstAllocationSize)",
          "1866: {",
          "1867:     size_t freeSize = (AutoSystemInfo::PageSize * pageCount) - firstAllocationSize - sizeof(LargeObjectHeader);",
          "1868:     Assert(freeSize < AutoSystemInfo::Data.dwAllocationGranularity);",
          "1869:     size_t objectCount = (freeSize / HeapConstants::MaxSmallObjectSize) + 1;",
          "1870:     Assert(objectCount <= UINT_MAX);",
          "1871:     return (uint)objectCount;",
          "1872: }",
          "1874: #ifdef RECYCLER_SLOW_CHECK_ENABLED",
          "1875: void",
          "1876: LargeHeapBlock::Check(bool expectFull, bool expectPending)",
          "1877: {",
          "1878:     for (uint i = 0; i < allocCount; i++)",
          "1879:     {",
          "1880:         LargeObjectHeader * header = this->HeaderList()[i];",
          "1881:         if (header == nullptr)",
          "1882:         {",
          "1883:             continue;",
          "1884:         }",
          "1885: #if ENABLE_PARTIAL_GC && ENABLE_CONCURRENT_GC",
          "1886:         header = (LargeObjectHeader *)((size_t)header & ~PartialFreeBit);",
          "1887:         Assert(this->hasPartialFreeObjects || header == this->HeaderList()[i]);",
          "1888: #endif",
          "1889:         Assert(header->objectIndex == i);",
          "1890:     }",
          "1891: }",
          "1892: #endif",
          "1894: void LargeHeapBlock::FillFreeMemory(Recycler * recycler, __in_bcount(size) void * address, size_t size)",
          "1895: {",
          "1899: #ifdef RECYCLER_MEMORY_VERIFY",
          "1900:     if (recycler->VerifyEnabled())",
          "1901:     {",
          "1902:         memset(address, Recycler::VerifyMemFill, size);",
          "1903:         return;",
          "1904:     }",
          "1905: #endif",
          "1906: #ifdef RECYCLER_FREE_MEM_FILL",
          "1907:     memset(address, DbgMemFill, size);",
          "1908: #endif",
          "1909: }",
          "1911: size_t LargeHeapBlock::GetObjectSize(void* objectAddress)",
          "1912: {",
          "1913:     LargeObjectHeader * header = GetHeader(objectAddress);",
          "1915:     Assert((char *)header >= this->address);",
          "1917:     return header->objectSize;",
          "1918: }",
          "1921: #ifdef RECYCLER_MEMORY_VERIFY",
          "1924: void",
          "1925: LargeHeapBlock::Verify(Recycler * recycler)",
          "1926: {",
          "1927:     char * lastAddress = this->address;",
          "1928:     uint verifyFinalizeCount = 0;",
          "1929:     for (uint i = 0; i < allocCount; i++)",
          "1930:     {",
          "1931:         LargeObjectHeader * header = this->HeaderList()[i];",
          "1932:         if (header == nullptr)",
          "1933:         {",
          "1935:             LargeHeapBlockFreeListEntry* current = this->freeList.entries;",
          "1937:             while (current != nullptr)",
          "1938:             {",
          "1940:                 if (current->headerIndex == i)",
          "1941:                 {",
          "1942:                     BYTE* objectAddress = (BYTE *)current + sizeof(LargeObjectHeader);",
          "1943:                     Recycler::VerifyCheck(current->heapBlock == this, _u(\"Invalid heap block\"), this, current->heapBlock);",
          "1944:                     Recycler::VerifyCheck((char *)current >= lastAddress, _u(\"LargeHeapBlock invalid object header order\"), this->address, current);",
          "1945:                     Recycler::VerifyCheckFill(lastAddress, (char *)current - lastAddress);",
          "1946:                     recycler->VerifyCheckPad(objectAddress, current->objectSize);",
          "1947:                     lastAddress = (char *) objectAddress + current->objectSize;",
          "1948:                     break;",
          "1949:                 }",
          "1951:                 current = current->next;",
          "1952:             }",
          "1954:             continue;",
          "1955:         }",
          "1957:         Recycler::VerifyCheck((char *)header >= lastAddress, _u(\"LargeHeapBlock invalid object header order\"), this->address, header);",
          "1958:         Recycler::VerifyCheckFill(lastAddress, (char *)header - lastAddress);",
          "1959:         Recycler::VerifyCheck(header->objectIndex == i, _u(\"LargeHeapBlock object index mismatch\"), this->address, &header->objectIndex);",
          "1960:         recycler->VerifyCheckPad((BYTE *)header->GetAddress(), header->objectSize);",
          "1962:         verifyFinalizeCount += ((header->GetAttributes(this->heapInfo->recycler->Cookie) & FinalizeBit) != 0);",
          "1963:         lastAddress = (char *)header->GetAddress() + header->objectSize;",
          "1964:     }",
          "1966:     Recycler::VerifyCheck(verifyFinalizeCount == this->finalizeCount, _u(\"LargeHeapBlock finalize object count mismatch\"), this->address, &this->finalizeCount);",
          "1967: }",
          "1968: #endif",
          "1970: uint",
          "1971: LargeHeapBlock::GetMarkCount()",
          "1972: {",
          "1973:     uint markCount = 0;",
          "1974:     const HeapBlockMap& heapBlockMap = this->heapInfo->recycler->heapBlockMap;",
          "1976:     for (uint i = 0; i < allocCount; i++)",
          "1977:     {",
          "1978:         LargeObjectHeader* header = this->HeaderList()[i];",
          "1979:         if (header && header->objectIndex == i && heapBlockMap.IsMarked(header->GetAddress()))",
          "1980:         {",
          "1981:             markCount++;",
          "1982:         }",
          "1983:     }",
          "1985:     return markCount;",
          "1986: }",
          "1988: #ifdef RECYCLER_PERF_COUNTERS",
          "1989: void",
          "1990: LargeHeapBlock::UpdatePerfCountersOnFree()",
          "1991: {",
          "1992:     Assert(GetMarkCount() == 0);",
          "1993:     size_t usedCount = 0;",
          "1994:     size_t usedBytes = 0;",
          "1995:     for (uint i = 0; i < allocCount; i++)",
          "1996:     {",
          "1997:         LargeObjectHeader * header = this->HeaderList()[i];",
          "1998:         if (header == nullptr)",
          "1999:         {",
          "2000:             continue;",
          "2001:         }",
          "2002:         usedCount++;",
          "2003:         usedBytes += header->objectSize;",
          "2004:     }",
          "2006:     RECYCLER_PERF_COUNTER_SUB(LargeHeapBlockLiveObject, usedCount);",
          "2007:     RECYCLER_PERF_COUNTER_SUB(LargeHeapBlockLiveObjectSize, usedBytes);",
          "2008:     RECYCLER_PERF_COUNTER_SUB(LargeHeapBlockFreeObjectSize, this->GetPageCount() * AutoSystemInfo::PageSize - usedBytes);",
          "2010:     RECYCLER_PERF_COUNTER_SUB(LiveObject, usedCount);",
          "2011:     RECYCLER_PERF_COUNTER_SUB(LiveObjectSize, usedBytes);",
          "2012:     RECYCLER_PERF_COUNTER_SUB(FreeObjectSize, this->GetPageCount() * AutoSystemInfo::PageSize - usedBytes);",
          "2013: }",
          "2014: #endif",
          "2016: #ifdef PROFILE_RECYCLER_ALLOC",
          "2017: void *",
          "2018: LargeHeapBlock::GetTrackerData(void * address)",
          "2019: {",
          "2020:     Assert(Recycler::DoProfileAllocTracker());",
          "2021:     LargeObjectHeader * header = GetHeader(address);",
          "2022:     Assert((char *)header >= this->address);",
          "2023:     uint index = header->objectIndex;",
          "2024:     Assert(index < this->allocCount);",
          "2025:     Assert(this->HeaderList()[index] == header);",
          "2026:     return this->GetTrackerDataArray()[index];",
          "2027: }",
          "2029: void",
          "2030: LargeHeapBlock::SetTrackerData(void * address, void * data)",
          "2031: {",
          "2032:     Assert(Recycler::DoProfileAllocTracker());",
          "2033:     LargeObjectHeader * header = GetHeader(address);",
          "2034:     Assert((char *)header >= this->address);",
          "2035:     uint index = header->objectIndex;",
          "2036:     Assert(index < this->allocCount);",
          "2037:     Assert(this->HeaderList()[index] == header);",
          "2038:     this->GetTrackerDataArray()[index] = data;",
          "2039: }",
          "2041: void **",
          "2042: LargeHeapBlock::GetTrackerDataArray()",
          "2043: {",
          "2045:     return (void **)((char *)(this + 1) + LargeHeapBlock::GetAllocPlusSize(this->objectCount) - this->objectCount * sizeof(void *));",
          "2046: }",
          "2047: #endif",
          "2049: #ifdef RECYCLER_PAGE_HEAP",
          "2050: void",
          "2051: LargeHeapBlock::CapturePageHeapAllocStack()",
          "2052: {",
          "2053: #ifdef STACK_BACK_TRACE",
          "2054:     if (this->InPageHeapMode()) // pageheap can be enabled only for some of the buckets",
          "2055:     {",
          "2058:         Assert(this->pageHeapFreeStack == nullptr);",
          "2059:         Assert(this->pageHeapAllocStack == nullptr);",
          "2063:         if (pageHeapAllocStack != nullptr && this->pageHeapAllocStack != s_StackTraceAllocFailed)",
          "2064:         {",
          "2065:             this->pageHeapAllocStack->Capture(Recycler::s_numFramesToSkipForPageHeapAlloc);",
          "2066:         }",
          "2067:         else",
          "2068:         {",
          "2069:             this->pageHeapAllocStack = StackBackTrace::Capture(&NoThrowHeapAllocator::Instance,",
          "2070:                 Recycler::s_numFramesToSkipForPageHeapAlloc, Recycler::s_numFramesToCaptureForPageHeap);",
          "2071:         }",
          "2073:         if (this->pageHeapAllocStack == nullptr)",
          "2074:         {",
          "2075:             this->pageHeapAllocStack = const_cast<StackBackTrace*>(s_StackTraceAllocFailed); // allocate failed, mark it we have tried",
          "2076:         }",
          "2077:     }",
          "2078: #endif",
          "2079: }",
          "2081: void",
          "2082: LargeHeapBlock::CapturePageHeapFreeStack()",
          "2083: {",
          "2084: #ifdef STACK_BACK_TRACE",
          "2085:     if (this->InPageHeapMode()) // pageheap can be enabled only for some of the buckets",
          "2086:     {",
          "2089:         Assert(this->pageHeapFreeStack == nullptr);",
          "2090:         Assert(this->pageHeapAllocStack != nullptr);",
          "2092:         if (this->pageHeapFreeStack != nullptr)",
          "2093:         {",
          "2094:             this->pageHeapFreeStack->Capture(Recycler::s_numFramesToSkipForPageHeapFree);",
          "2095:         }",
          "2096:         else",
          "2097:         {",
          "2098:             this->pageHeapFreeStack = StackBackTrace::Capture(&NoThrowHeapAllocator::Instance,",
          "2099:                 Recycler::s_numFramesToSkipForPageHeapFree, Recycler::s_numFramesToCaptureForPageHeap);",
          "2100:         }",
          "2101:     }",
          "2102: #endif",
          "2103: }",
          "2104: #endif",
          "2106: #if DBG && GLOBAL_ENABLE_WRITE_BARRIER",
          "2107: CriticalSection LargeHeapBlock::wbVerifyBitsLock;",
          "2108: void LargeHeapBlock::WBSetBit(char* addr)",
          "2109: {",
          "2110:     uint index = (uint)(addr - this->address) / sizeof(void*);",
          "2111:     try",
          "2112:     {",
          "2113:         AUTO_NESTED_HANDLED_EXCEPTION_TYPE(static_cast<ExceptionType>(ExceptionType_DisableCheck));",
          "2114:         AutoCriticalSection autoCs(&wbVerifyBitsLock);",
          "2115:         wbVerifyBits.Set(index);",
          "2116:     }",
          "2117:     catch (Js::OutOfMemoryException&)",
          "2118:     {",
          "2119:     }",
          "2120: }",
          "2121: void LargeHeapBlock::WBSetBitRange(char* addr, uint count)",
          "2122: {",
          "2123:     uint index = (uint)(addr - this->address) / sizeof(void*);",
          "2124:     try",
          "2125:     {",
          "2126:         AUTO_NESTED_HANDLED_EXCEPTION_TYPE(static_cast<ExceptionType>(ExceptionType_DisableCheck));",
          "2127:         AutoCriticalSection autoCs(&wbVerifyBitsLock);",
          "2128:         for (uint i = 0; i < count; i++)",
          "2129:         {",
          "2130:             wbVerifyBits.Set(index + i);",
          "2131:         }",
          "2132:     }",
          "2133:     catch (Js::OutOfMemoryException&)",
          "2134:     {",
          "2135:     }",
          "2136: }",
          "2137: void LargeHeapBlock::WBClearBit(char* addr)",
          "2138: {",
          "2139:     uint index = (uint)(addr - this->address) / sizeof(void*);",
          "2140:     AutoCriticalSection autoCs(&wbVerifyBitsLock);",
          "2141:     wbVerifyBits.Clear(index);",
          "2142: }",
          "2143: void LargeHeapBlock::WBVerifyBitIsSet(char* addr)",
          "2144: {",
          "2145:     uint index = (uint)(addr - this->address) / sizeof(void*);",
          "2146:     if (!wbVerifyBits.Test(index))",
          "2147:     {",
          "2148:         PrintVerifyMarkFailure(this->GetRecycler(), addr, *(char**)addr);",
          "2149:     }",
          "2150: }",
          "2151: void LargeHeapBlock::WBClearObject(char* addr)",
          "2152: {",
          "2153:     uint index = (uint)(addr - this->address) / sizeof(void*);",
          "2154:     size_t objectSize = this->GetHeader(addr)->objectSize;",
          "2155:     AutoCriticalSection autoCs(&wbVerifyBitsLock);",
          "2156:     for (uint i = 0; i < (uint)objectSize / sizeof(void*); i++)",
          "2157:     {",
          "2158:         wbVerifyBits.Clear(index + i);",
          "2159:     }",
          "2160: }",
          "2161: #endif",
          "",
          "---------------"
        ],
        "lib/Runtime/Base/FunctionBody.h||lib/Runtime/Base/FunctionBody.h": [
          "File: lib/Runtime/Base/FunctionBody.h -> lib/Runtime/Base/FunctionBody.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "5: #pragma once",
          "7: #include \"AuxPtrs.h\"",
          "8: #include \"CompactCounters.h\"",
          "10: struct CodeGenWorkItem;",
          "11: class SourceContextInfo;",
          "12: struct DeferredFunctionStub;",
          "13: struct CodeGenNumberChunk;",
          "14: #ifdef DYNAMIC_PROFILE_MUTATOR",
          "15: class DynamicProfileMutator;",
          "16: class DynamicProfileMutatorImpl;",
          "17: #endif",
          "18: #define MAX_FUNCTION_BODY_DEBUG_STRING_SIZE 42 //11*3+8+1",
          "20: typedef BVSparse<ArenaAllocator> ActiveFunctionSet;",
          "22: namespace Js",
          "23: {",
          "24: #pragma region Class Forward Declarations",
          "25:     class ByteCodeBufferReader;",
          "26:     class ByteCodeBufferBuilder;",
          "27:     class ByteCodeCache;",
          "28:     class ScopeInfo;",
          "29:     class SmallSpanSequence;",
          "30:     struct StatementLocation;",
          "31:     class SmallSpanSequenceIter;",
          "32:     struct StatementData;",
          "33:     struct PropertyIdOnRegSlotsContainer;",
          "35:     struct InlineCache;",
          "36:     struct PolymorphicInlineCache;",
          "37:     struct IsInstInlineCache;",
          "38:     class ScopeObjectChain;",
          "39:     class EntryPointInfo;",
          "40:     class FunctionProxy;",
          "41:     class ParseableFunctionInfo;",
          "42:     class FunctionBody;",
          "44:     class DebuggerScopeProperty;",
          "45:     class DebuggerScope;",
          "46:     class FunctionEntryPointInfo;",
          "48: #ifdef ASMJS_PLAT",
          "49:     class AsmJsFunctionInfo;",
          "50:     class AmsJsModuleInfo;",
          "51: #endif",
          "52:     class ArrayBuffer;",
          "53:     class SharedArrayBuffer;",
          "54:     class FunctionCodeGenRuntimeData;",
          "55:     class JavascriptNumber;",
          "56: #pragma endregion",
          "58:     typedef JsUtil::BaseDictionary<Js::PropertyId, const Js::PropertyRecord*, RecyclerNonLeafAllocator, PowerOf2SizePolicy, DefaultComparer, JsUtil::SimpleDictionaryEntry> PropertyRecordList;",
          "59:     typedef JsUtil::BaseHashSet<void*, Recycler, PowerOf2SizePolicy> TypeRefSet;",
          "62:     enum DiagExtraScopesType",
          "63:     {",
          "64:         DiagUnknownScope,           // Unknown scope set when deserializing bytecode and the scope is not yet known.",
          "65:         DiagWithScope,              // With scope.",
          "66:         DiagCatchScopeDirect,       // Catch scope in regslot",
          "67:         DiagCatchScopeInSlot,       // Catch scope in slot array",
          "68:         DiagCatchScopeInObject,     // Catch scope in scope object",
          "69:         DiagBlockScopeDirect,       // Block scope in regslot",
          "70:         DiagBlockScopeInSlot,       // Block scope in slot array",
          "71:         DiagBlockScopeInObject,     // Block scope in activation object",
          "72:         DiagBlockScopeRangeEnd,     // Used to end a block scope range.",
          "73:         DiagParamScope,             // The scope represents symbols at formals",
          "74:         DiagParamScopeInObject,     // The scope represents symbols at formals and formal scope in activation object",
          "75:     };",
          "77:     struct ForInCache",
          "78:     {",
          "79:         Type * type;",
          "80:         void * data;",
          "81:     };",
          "82:     class PropertyGuard",
          "83:     {",
          "84:         friend class PropertyGuardValidator;",
          "86:     private:",
          "87:         Field(intptr_t) value; // value is address of Js::Type",
          "88: #if DBG",
          "89:         Field(bool) wasReincarnated = false;",
          "90: #endif",
          "91:     public:",
          "92:         static PropertyGuard* New(Recycler* recycler) { return RecyclerNewLeaf(recycler, Js::PropertyGuard); }",
          "93:         PropertyGuard() : value(GuardValue::Uninitialized) {}",
          "94:         PropertyGuard(intptr_t value) : value(value)",
          "95:         {",
          "98:             Assert(this->value != GuardValue::Invalidated && this->value != GuardValue::Invalidated_DuringSweep);",
          "99:         }",
          "101:         inline static size_t const GetSizeOfValue() { return sizeof(((PropertyGuard*)0)->value); }",
          "102:         inline static size_t const GetOffsetOfValue() { return offsetof(PropertyGuard, value); }",
          "104:         intptr_t GetValue() const { return this->value; }",
          "105:         bool IsValid()",
          "106:         {",
          "107:             return this->value != GuardValue::Invalidated && this->value != GuardValue::Invalidated_DuringSweep;",
          "108:         }",
          "109:         bool IsInvalidatedDuringSweep() { return this->value == GuardValue::Invalidated_DuringSweep; }",
          "110:         void SetValue(intptr_t value)",
          "111:         {",
          "114:             Assert(value != GuardValue::Invalidated && value != GuardValue::Invalidated_DuringSweep);",
          "115:             this->value = value;",
          "116:         }",
          "117:         intptr_t const* GetAddressOfValue() { return &this->value; }",
          "118:         void Invalidate() { this->value = GuardValue::Invalidated; }",
          "119:         void InvalidateDuringSweep()",
          "120:         {",
          "121: #if DBG",
          "122:             wasReincarnated = true;",
          "123: #endif",
          "124:             this->value = GuardValue::Invalidated_DuringSweep;",
          "125:         }",
          "126: #if DBG",
          "127:         bool WasReincarnated() { return this->wasReincarnated; }",
          "128: #endif",
          "129:         enum GuardValue : intptr_t",
          "130:         {",
          "131:             Invalidated = 0,",
          "132:             Uninitialized = 1,",
          "133:             Invalidated_DuringSweep = 2",
          "134:         };",
          "135:     };",
          "137:     class PropertyGuardValidator",
          "138:     {",
          "140:         CompileAssert(offsetof(PropertyGuard, value) == 0);",
          "141:         CompileAssert(offsetof(ConstructorCache, guard.value) == offsetof(PropertyGuard, value));",
          "142:     };",
          "144:     class JitIndexedPropertyGuard : public Js::PropertyGuard",
          "145:     {",
          "146:     private:",
          "147:         int index;",
          "149:     public:",
          "150:         JitIndexedPropertyGuard(intptr_t value, int index):",
          "151:             Js::PropertyGuard(value), index(index) {}",
          "153:         int GetIndex() const { return this->index; }",
          "154:     };",
          "156:     class JitTypePropertyGuard : public Js::JitIndexedPropertyGuard",
          "157:     {",
          "158:     public:",
          "159:         JitTypePropertyGuard(intptr_t typeAddr, int index):",
          "160:             JitIndexedPropertyGuard(typeAddr, index) {}",
          "162:         intptr_t GetTypeAddr() const { return this->GetValue(); }",
          "164:     };",
          "166:     struct TypeGuardTransferEntry",
          "167:     {",
          "168:         PropertyId propertyId;",
          "169:         JitIndexedPropertyGuard* guards[0];",
          "171:         TypeGuardTransferEntry(): propertyId(Js::Constants::NoProperty) {}",
          "172:     };",
          "174:     class FakePropertyGuardWeakReference: public RecyclerWeakReference<Js::PropertyGuard>",
          "175:     {",
          "176:     public:",
          "177:         static FakePropertyGuardWeakReference* New(Recycler* recycler, Js::PropertyGuard* guard)",
          "178:         {",
          "179:             Assert(guard != nullptr);",
          "180:             return RecyclerNewLeaf(recycler, Js::FakePropertyGuardWeakReference, guard);",
          "181:         }",
          "182:         FakePropertyGuardWeakReference(const Js::PropertyGuard* guard)",
          "183:         {",
          "184:             this->strongRef = (char*)guard;",
          "185:             this->strongRefHeapBlock = &CollectedRecyclerWeakRefHeapBlock::Instance;",
          "186:         }",
          "188:         void Zero()",
          "189:         {",
          "190:             Assert(this->strongRef != nullptr);",
          "191:             this->strongRef = nullptr;",
          "192:         }",
          "193:     };",
          "195:     struct CtorCacheGuardTransferEntry",
          "196:     {",
          "197:         PropertyId propertyId;",
          "198:         intptr_t caches[0];",
          "200:         CtorCacheGuardTransferEntry(): propertyId(Js::Constants::NoProperty) {}",
          "201:     };",
          "203:     struct EquivalentTypeCache",
          "204:     {",
          "205:         Js::Type* types[EQUIVALENT_TYPE_CACHE_SIZE];",
          "206:         PropertyGuard *guard;",
          "207:         TypeEquivalenceRecord record;",
          "208:         uint nextEvictionVictim;",
          "209:         bool isLoadedFromProto;",
          "210:         bool hasFixedValue;",
          "212:         EquivalentTypeCache(): nextEvictionVictim(EQUIVALENT_TYPE_CACHE_SIZE) {}",
          "213:         bool ClearUnusedTypes(Recycler *recycler);",
          "214:         void SetGuard(PropertyGuard *theGuard) { this->guard = theGuard; }",
          "215:         void SetIsLoadedFromProto() { this->isLoadedFromProto = true; }",
          "216:         bool IsLoadedFromProto() const { return this->isLoadedFromProto; }",
          "217:         void SetHasFixedValue() { this->hasFixedValue = true; }",
          "218:         bool HasFixedValue() const { return this->hasFixedValue; }",
          "219:     };",
          "221:     class JitEquivalentTypeGuard : public JitIndexedPropertyGuard",
          "222:     {",
          "225:         EquivalentTypeCache* cache;",
          "226:         uint32 objTypeSpecFldId;",
          "228: #if DBG && 0",
          "230:         intptr_t originalScriptContextValue = 0;",
          "231: #endif",
          "233:     public:",
          "234:         JitEquivalentTypeGuard(intptr_t typeAddr, int index, uint32 objTypeSpecFldId):",
          "235:             JitIndexedPropertyGuard(typeAddr, index), cache(nullptr), objTypeSpecFldId(objTypeSpecFldId)",
          "236:         {",
          "237: #if DBG && 0",
          "238:             originalScriptContextValue = reinterpret_cast<intptr_t>(type->GetScriptContext());",
          "239: #endif",
          "240:         }",
          "242:         intptr_t GetTypeAddr() const { return this->GetValue(); }",
          "244:         void SetTypeAddr(const intptr_t typeAddr)",
          "245:         {",
          "246: #if DBG && 0",
          "247:             if (originalScriptContextValue == 0)",
          "248:             {",
          "249:                 originalScriptContextValue = reinterpret_cast<intptr_t>(type->GetScriptContext());",
          "250:             }",
          "251:             else",
          "252:             {",
          "253:                 AssertMsg(originalScriptContextValue == reinterpret_cast<intptr_t>(type->GetScriptContext()), \"Trying to set guard type from different script context.\");",
          "254:             }",
          "255: #endif",
          "256:             this->SetValue(typeAddr);",
          "257:         }",
          "259:         uint32 GetObjTypeSpecFldId() const",
          "260:         {",
          "261:             return this->objTypeSpecFldId;",
          "262:         }",
          "264:         Js::EquivalentTypeCache* GetCache() const",
          "265:         {",
          "266:             return this->cache;",
          "267:         }",
          "269:         void SetCache(Js::EquivalentTypeCache* cache)",
          "270:         {",
          "271:             this->cache = cache;",
          "272:         }",
          "273:     };",
          "275: #pragma region Inline Cache Info class declarations",
          "276:     class PolymorphicCacheUtilizationArray",
          "277:     {",
          "278:     private:",
          "279:         Field(byte *) utilArray;",
          "281:     public:",
          "282:         PolymorphicCacheUtilizationArray()",
          "283:             : utilArray(nullptr)",
          "284:         {",
          "285:         }",
          "286:         void EnsureUtilArray(Recycler * const recycler, Js::FunctionBody * functionBody);",
          "287:         byte* GetByteArray() { return utilArray; }",
          "288:         void SetUtil(Js::FunctionBody* functionBody, uint index, byte util);",
          "289:         byte GetUtil(Js::FunctionBody* functionBody, uint index);",
          "290:     };",
          "292:     class PolymorphicInlineCacheInfo sealed",
          "293:     {",
          "294:     private:",
          "295:         Field(InlineCachePointerArray<PolymorphicInlineCache>) polymorphicInlineCaches;",
          "296:         Field(PolymorphicCacheUtilizationArray) polymorphicCacheUtilizationArray;",
          "297:         Field(FunctionBody *) functionBody;",
          "299:     public:",
          "300:         PolymorphicInlineCacheInfo(FunctionBody * functionBody)",
          "301:             : functionBody(functionBody)",
          "302:         {",
          "303:         }",
          "305:         InlineCachePointerArray<PolymorphicInlineCache> * GetPolymorphicInlineCaches() { return &polymorphicInlineCaches; }",
          "306:         PolymorphicCacheUtilizationArray * GetUtilArray() { return &polymorphicCacheUtilizationArray; }",
          "307:         byte * GetUtilByteArray() { return polymorphicCacheUtilizationArray.GetByteArray(); }",
          "308:         FunctionBody * GetFunctionBody() const { return functionBody; }",
          "309:     };",
          "311:     class EntryPointPolymorphicInlineCacheInfo sealed",
          "312:     {",
          "313:     private:",
          "314:         Field(PolymorphicInlineCacheInfo) selfInfo;",
          "316:         typedef SListCounted<PolymorphicInlineCacheInfo*, Recycler> PolymorphicInlineCacheInfoListType;",
          "317:         Field(PolymorphicInlineCacheInfoListType) inlineeInfo;",
          "319:         static void SetPolymorphicInlineCache(PolymorphicInlineCacheInfo * polymorphicInlineCacheInfo, FunctionBody * functionBody, uint index, PolymorphicInlineCache * polymorphicInlineCache, byte polyCacheUtil);",
          "321:     public:",
          "322:         EntryPointPolymorphicInlineCacheInfo(FunctionBody * functionBody);",
          "324:         PolymorphicInlineCacheInfo * GetSelfInfo() { return &selfInfo; }",
          "325:         PolymorphicInlineCacheInfo * EnsureInlineeInfo(Recycler * recycler, FunctionBody * inlineeFunctionBody);",
          "326:         PolymorphicInlineCacheInfo * GetInlineeInfo(FunctionBody * inlineeFunctionBody);",
          "327:         SListCounted<PolymorphicInlineCacheInfo*, Recycler> * GetInlineeInfo() { return &this->inlineeInfo; }",
          "329:         void SetPolymorphicInlineCache(FunctionBody * functionBody, uint index, PolymorphicInlineCache * polymorphicInlineCache, bool isInlinee, byte polyCacheUtil);",
          "331:         template <class Fn>",
          "332:         void MapInlinees(Fn fn)",
          "333:         {",
          "334:             SListCounted<PolymorphicInlineCacheInfo*, Recycler>::Iterator iter(&inlineeInfo);",
          "335:             while (iter.Next())",
          "336:             {",
          "337:                 fn(iter.Data());",
          "338:             }",
          "339:         }",
          "340:     };",
          "341: #pragma endregion",
          "343: #ifdef FIELD_ACCESS_STATS",
          "344:     struct FieldAccessStats",
          "345:     {",
          "346:         Field(uint) totalInlineCacheCount;",
          "347:         Field(uint) noInfoInlineCacheCount;",
          "348:         Field(uint) monoInlineCacheCount;",
          "349:         Field(uint) emptyMonoInlineCacheCount;",
          "350:         Field(uint) polyInlineCacheCount;",
          "351:         Field(uint) nullPolyInlineCacheCount;",
          "352:         Field(uint) emptyPolyInlineCacheCount;",
          "353:         Field(uint) ignoredPolyInlineCacheCount;",
          "354:         Field(uint) highUtilPolyInlineCacheCount;",
          "355:         Field(uint) lowUtilPolyInlineCacheCount;",
          "356:         Field(uint) equivPolyInlineCacheCount;",
          "357:         Field(uint) nonEquivPolyInlineCacheCount;",
          "358:         Field(uint) disabledPolyInlineCacheCount;",
          "359:         Field(uint) clonedMonoInlineCacheCount;",
          "360:         Field(uint) clonedPolyInlineCacheCount;",
          "362:         FieldAccessStats() :",
          "363:             totalInlineCacheCount(0), noInfoInlineCacheCount(0), monoInlineCacheCount(0), emptyMonoInlineCacheCount(0),",
          "364:             polyInlineCacheCount(0), nullPolyInlineCacheCount(0), emptyPolyInlineCacheCount(0), ignoredPolyInlineCacheCount(0),",
          "365:             highUtilPolyInlineCacheCount(0), lowUtilPolyInlineCacheCount(0),",
          "366:             equivPolyInlineCacheCount(0), nonEquivPolyInlineCacheCount(0), disabledPolyInlineCacheCount(0),",
          "367:             clonedMonoInlineCacheCount(0), clonedPolyInlineCacheCount(0) {}",
          "369:         void Add(FieldAccessStats* other);",
          "370:     };",
          "372:     typedef FieldAccessStats* FieldAccessStatsPtr;",
          "373: #else",
          "374:     typedef void* FieldAccessStatsPtr;",
          "375: #endif",
          "377: #pragma region Entry point class declarations",
          "378:     class ProxyEntryPointInfo:  public ExpirableObject",
          "379:     {",
          "380:     public:",
          "383:         FieldNoBarrier(Js::JavascriptMethod) jsMethod;",
          "385:         ProxyEntryPointInfo(Js::JavascriptMethod jsMethod, ThreadContext* context = nullptr):",
          "386:             ExpirableObject(context),",
          "387:             jsMethod(jsMethod)",
          "388:         {",
          "389:         }",
          "390:         static DWORD GetAddressOffset() { return offsetof(ProxyEntryPointInfo, jsMethod); }",
          "391:         virtual void Expire()",
          "392:         {",
          "393:             AssertMsg(false, \"Expire called on object that doesn't support expiration\");",
          "394:         }",
          "396:         virtual void EnterExpirableCollectMode()",
          "397:         {",
          "398:             AssertMsg(false, \"EnterExpirableCollectMode called on object that doesn't support expiration\");",
          "399:         }",
          "401:         virtual bool IsFunctionEntryPointInfo() const { return false; }",
          "402:     };",
          "405:     struct TypeGuardTransferData",
          "406:     {",
          "407:         Field(unsigned int) propertyGuardCount;",
          "408:         FieldNoBarrier(TypeGuardTransferEntryIDL*) entries;",
          "409:     };",
          "411:     struct CtorCacheTransferData",
          "412:     {",
          "413:         Field(unsigned int) ctorCachesCount;",
          "414:         FieldNoBarrier(CtorCacheTransferEntryIDL **) entries;",
          "415:     };",
          "422:     class EntryPointInfo : public ProxyEntryPointInfo",
          "423:     {",
          "424:     private:",
          "425:         enum State : BYTE",
          "426:         {",
          "427:             NotScheduled,       // code gen has not been scheduled",
          "428:             CodeGenPending,     // code gen job has been scheduled",
          "429:             CodeGenQueued,      // code gen has been queued and all the code gen data has been gathered.",
          "430:             CodeGenRecorded,    // backend completed, but job still pending",
          "431:             CodeGenDone,        // code gen job successfully completed",
          "432:             JITCapReached,      // workitem created but JIT cap reached",
          "433:             PendingCleanup,     // workitem needs to be cleaned up but couldn't for some reason- it'll be cleaned up at the next opportunity",
          "434:             CleanedUp           // the entry point has been cleaned up",
          "435:         };",
          "438:         Field(const bool)          tag : 1;",
          "439:         Field(bool)                isLoopBody : 1;",
          "440:         Field(bool)                hasJittedStackClosure : 1;",
          "441:         Field(bool)                isAsmJsFunction : 1; // true if entrypoint is for asmjs function",
          "442:         Field(State)               state; // Single state member so users can query state w/o a lock",
          "443: #if ENABLE_NATIVE_CODEGEN",
          "444:         Field(BYTE)                pendingInlinerVersion;",
          "445:         Field(ImplicitCallFlags)   pendingImplicitCallFlags;",
          "446:         Field(uint32)              pendingPolymorphicCacheState;",
          "448:         class JitTransferData",
          "449:         {",
          "450:             friend EntryPointInfo;",
          "452:         private:",
          "453:             Field(TypeRefSet*) jitTimeTypeRefs;",
          "455:             Field(PinnedTypeRefsIDL*) runtimeTypeRefs;",
          "458:             Field(int) propertyGuardCount;",
          "461:             FieldNoBarrier(TypeGuardTransferEntry*) propertyGuardsByPropertyId;",
          "462:             Field(size_t) propertyGuardsByPropertyIdPlusSize;",
          "466:             FieldNoBarrier(CtorCacheGuardTransferEntry*) ctorCacheGuardsByPropertyId;",
          "467:             Field(size_t) ctorCacheGuardsByPropertyIdPlusSize;",
          "469:             Field(int) equivalentTypeGuardCount;",
          "470:             Field(int) lazyBailoutPropertyCount;",
          "474:             FieldNoBarrier(JitEquivalentTypeGuard**) equivalentTypeGuards;",
          "475:             FieldNoBarrier(Js::PropertyId*) lazyBailoutProperties;",
          "476:             FieldNoBarrier(NativeCodeData*) jitTransferRawData;",
          "477:             FieldNoBarrier(EquivalentTypeGuardOffsets*) equivalentTypeGuardOffsets;",
          "478:             Field(TypeGuardTransferData) typeGuardTransferData;",
          "479:             Field(CtorCacheTransferData) ctorCacheTransferData;",
          "481:             Field(bool) falseReferencePreventionBit;",
          "482:             Field(bool) isReady;",
          "484:         public:",
          "485:             JitTransferData():",
          "486:                 jitTimeTypeRefs(nullptr), runtimeTypeRefs(nullptr),",
          "487:                 propertyGuardCount(0), propertyGuardsByPropertyId(nullptr), propertyGuardsByPropertyIdPlusSize(0),",
          "488:                 ctorCacheGuardsByPropertyId(nullptr), ctorCacheGuardsByPropertyIdPlusSize(0),",
          "489:                 equivalentTypeGuardCount(0), equivalentTypeGuards(nullptr), jitTransferRawData(nullptr),",
          "490:                 falseReferencePreventionBit(true), isReady(false), lazyBailoutProperties(nullptr), lazyBailoutPropertyCount(0){}",
          "492:             void SetRawData(NativeCodeData* rawData) { jitTransferRawData = rawData; }",
          "493:             void AddJitTimeTypeRef(void* typeRef, Recycler* recycler);",
          "495:             int GetRuntimeTypeRefCount() { return this->runtimeTypeRefs ? this->runtimeTypeRefs->count : 0; }",
          "496:             void** GetRuntimeTypeRefs() { return this->runtimeTypeRefs ? (void**)this->runtimeTypeRefs->typeRefs : nullptr; }",
          "497:             void SetRuntimeTypeRefs(PinnedTypeRefsIDL* pinnedTypeRefs) { this->runtimeTypeRefs = pinnedTypeRefs;}",
          "499:             JitEquivalentTypeGuard** GetEquivalentTypeGuards() const { return this->equivalentTypeGuards; }",
          "500:             void SetEquivalentTypeGuards(JitEquivalentTypeGuard** guards, int count)",
          "501:             {",
          "502:                 this->equivalentTypeGuardCount = count;",
          "503:                 this->equivalentTypeGuards = guards;",
          "504:             }",
          "505:             void SetLazyBailoutProperties(Js::PropertyId* properties, int count)",
          "506:             {",
          "507:                 this->lazyBailoutProperties = properties;",
          "508:                 this->lazyBailoutPropertyCount = count;",
          "509:             }",
          "510:             void SetEquivalentTypeGuardOffsets(EquivalentTypeGuardOffsets* offsets)",
          "511:             {",
          "512:                 equivalentTypeGuardOffsets = offsets;",
          "513:             }",
          "514:             void SetTypeGuardTransferData(JITOutputIDL* data)",
          "515:             {",
          "516:                 typeGuardTransferData.entries = data->typeGuardEntries;",
          "517:                 typeGuardTransferData.propertyGuardCount = data->propertyGuardCount;",
          "518:             }",
          "519:             void SetCtorCacheTransferData(JITOutputIDL * data)",
          "520:             {",
          "521:                 ctorCacheTransferData.entries = data->ctorCacheEntries;",
          "522:                 ctorCacheTransferData.ctorCachesCount = data->ctorCachesCount;",
          "523:             }",
          "524:             bool GetIsReady() { return this->isReady; }",
          "525:             void SetIsReady() { this->isReady = true; }",
          "527:         private:",
          "528:             void EnsureJitTimeTypeRefs(Recycler* recycler);",
          "529:         };",
          "531:         Field(NativeCodeData *) inProcJITNaticeCodedata;",
          "532:         FieldNoBarrier(char*) nativeDataBuffer;",
          "533:         union",
          "534:         {",
          "535:             Field(Field(JavascriptNumber*)*) numberArray;",
          "536:             Field(CodeGenNumberChunk*) numberChunks;",
          "537:         };",
          "538:         Field(XProcNumberPageSegment*) numberPageSegments;",
          "540:         FieldNoBarrier(SmallSpanSequence *) nativeThrowSpanSequence;",
          "541:         typedef JsUtil::BaseHashSet<RecyclerWeakReference<FunctionBody>*, Recycler, PowerOf2SizePolicy> WeakFuncRefSet;",
          "542:         Field(WeakFuncRefSet *) weakFuncRefSet;",
          "544:         typedef JsUtil::BaseDictionary<Js::PropertyId, PropertyGuard*, Recycler, PowerOf2SizePolicy> SharedPropertyGuardDictionary;",
          "545:         Field(SharedPropertyGuardDictionary*) sharedPropertyGuards;",
          "546:         typedef JsUtil::List<LazyBailOutRecord, HeapAllocator> BailOutRecordMap;",
          "547:         Field(BailOutRecordMap*) bailoutRecordMap;",
          "554:         Field(Field(FakePropertyGuardWeakReference*)*) propertyGuardWeakRefs;",
          "555:         Field(EquivalentTypeCache*) equivalentTypeCaches;",
          "556:         Field(EntryPointInfo **) registeredEquivalentTypeCacheRef;",
          "558:         Field(int) propertyGuardCount;",
          "559:         Field(int) equivalentTypeCacheCount;",
          "561:         Field(uint) inlineeFrameOffsetArrayOffset;",
          "562:         Field(uint) inlineeFrameOffsetArrayCount;",
          "564:         typedef SListCounted<ConstructorCache*, Recycler> ConstructorCacheList;",
          "565:         Field(ConstructorCacheList*) constructorCaches;",
          "567:         Field(EntryPointPolymorphicInlineCacheInfo *) polymorphicInlineCacheInfo;",
          "572:         Field(JitTransferData*) jitTransferData;",
          "575:         Field(Field(void*)*) runtimeTypeRefs;",
          "576:      protected:",
          "577: #if PDATA_ENABLED",
          "578:         Field(XDataAllocation *) xdataInfo;",
          "579: #endif",
          "580: #endif // ENABLE_NATIVE_CODEGEN",
          "582:         Field(CodeGenWorkItem *) workItem;",
          "583:         FieldNoBarrier(Js::JavascriptMethod) nativeAddress;",
          "584:         Field(ptrdiff_t) codeSize;",
          "586:     protected:",
          "587:         Field(JavascriptLibrary*) library;",
          "588: #if ENABLE_NATIVE_CODEGEN",
          "589:         typedef JsUtil::List<NativeOffsetInlineeFramePair, HeapAllocator> InlineeFrameMap;",
          "590:         Field(InlineeFrameMap*)   inlineeFrameMap;",
          "591: #endif",
          "592: #if ENABLE_DEBUG_STACK_BACK_TRACE",
          "593:         FieldNoBarrier(StackBackTrace*) cleanupStack;  // NoCheckHeapAllocator",
          "594: #endif",
          "595:     public:",
          "596:         Field(uint) frameHeight;",
          "597:         Field(bool) nativeEntryPointProcessed;",
          "599: #if ENABLE_DEBUG_CONFIG_OPTIONS",
          "600:     public:",
          "601:         enum CleanupReason",
          "602:         {",
          "603:             NotCleanedUp,",
          "604:             CodeGenFailedOOM,",
          "605:             CodeGenFailedStackOverflow,",
          "606:             CodeGenFailedAborted,",
          "607:             CodeGenFailedExceedJITLimit,",
          "608:             CodeGenFailedUnknown,",
          "609:             NativeCodeInstallFailure,",
          "610:             CleanUpForFinalize",
          "611:         };",
          "612:     private:",
          "613:         Field(CleanupReason) cleanupReason;",
          "614: #endif",
          "616: #ifdef FIELD_ACCESS_STATS",
          "617:     private:",
          "618:         Field(FieldAccessStatsPtr) fieldAccessStats;",
          "619: #endif",
          "621:     public:",
          "622:         virtual void Finalize(bool isShutdown) override;",
          "623:         virtual bool IsFunctionEntryPointInfo() const override { return true; }",
          "625: #if ENABLE_NATIVE_CODEGEN",
          "626:         char** GetNativeDataBufferRef() { return &nativeDataBuffer; }",
          "627:         char* GetNativeDataBuffer() { return nativeDataBuffer; }",
          "628:         void SetInProcJITNativeCodeData(NativeCodeData* nativeCodeData) { inProcJITNaticeCodedata = nativeCodeData; }",
          "629:         void SetNumberChunks(CodeGenNumberChunk* chunks)",
          "630:         {",
          "631:             Assert(numberPageSegments == nullptr);",
          "632:             numberChunks = chunks;",
          "633:         }",
          "634:         void SetNumberArray(Field(Js::JavascriptNumber*)* array)",
          "635:         {",
          "636:             Assert(numberPageSegments != nullptr);",
          "637:             numberArray = array;",
          "638:         }",
          "639:         void SetNumberPageSegment(XProcNumberPageSegment * segments)",
          "640:         {",
          "641:             Assert(numberPageSegments == nullptr);",
          "642:             numberPageSegments = segments;",
          "643:         }",
          "644: #endif",
          "646:     protected:",
          "647:         EntryPointInfo(Js::JavascriptMethod method, JavascriptLibrary* library, void* validationCookie, ThreadContext* context = nullptr, bool isLoopBody = false) :",
          "648:             ProxyEntryPointInfo(method, context), tag(1), nativeEntryPointProcessed(false),",
          "649: #if ENABLE_NATIVE_CODEGEN",
          "650:             nativeThrowSpanSequence(nullptr), workItem(nullptr), weakFuncRefSet(nullptr),",
          "651:             jitTransferData(nullptr), sharedPropertyGuards(nullptr), propertyGuardCount(0), propertyGuardWeakRefs(nullptr),",
          "652:             equivalentTypeCacheCount(0), equivalentTypeCaches(nullptr), constructorCaches(nullptr), state(NotScheduled), inProcJITNaticeCodedata(nullptr),",
          "653:             numberChunks(nullptr), numberPageSegments(nullptr), polymorphicInlineCacheInfo(nullptr), runtimeTypeRefs(nullptr),",
          "654:             isLoopBody(isLoopBody), hasJittedStackClosure(false), registeredEquivalentTypeCacheRef(nullptr), bailoutRecordMap(nullptr),",
          "655: #if PDATA_ENABLED",
          "656:             xdataInfo(nullptr),",
          "657: #endif",
          "658: #endif",
          "659:             library(library), codeSize(0), nativeAddress(nullptr), isAsmJsFunction(false), validationCookie(validationCookie)",
          "660: #if ENABLE_DEBUG_STACK_BACK_TRACE",
          "661:             , cleanupStack(nullptr)",
          "662: #endif",
          "663: #if ENABLE_DEBUG_CONFIG_OPTIONS",
          "664:             , cleanupReason(NotCleanedUp)",
          "665: #endif",
          "666: #if DBG_DUMP | defined(VTUNE_PROFILING)",
          "667:             , nativeOffsetMaps(&HeapAllocator::Instance)",
          "668: #endif",
          "669: #ifdef FIELD_ACCESS_STATS",
          "670:             , fieldAccessStats(nullptr)",
          "671: #endif",
          "672:         {}",
          "674:         virtual void ReleasePendingWorkItem() {};",
          "676:         virtual void OnCleanup(bool isShutdown) = 0;",
          "678: #ifdef PERF_COUNTERS",
          "679:         virtual void OnRecorded() = 0;",
          "680: #endif",
          "681:     private:",
          "682:         State GetState() const",
          "683:         {",
          "684:             Assert(this->state >= NotScheduled && this->state <= CleanedUp);",
          "685:             return this->state;",
          "686:         }",
          "688:     public:",
          "689:         ScriptContext* GetScriptContext();",
          "691:         virtual FunctionBody *GetFunctionBody() const = 0;",
          "692: #if ENABLE_NATIVE_CODEGEN",
          "693:         EntryPointPolymorphicInlineCacheInfo * EnsurePolymorphicInlineCacheInfo(Recycler * recycler, FunctionBody * functionBody);",
          "694:         EntryPointPolymorphicInlineCacheInfo * GetPolymorphicInlineCacheInfo() { return polymorphicInlineCacheInfo; }",
          "696:         JitTransferData* GetJitTransferData() { return this->jitTransferData; }",
          "697:         JitTransferData* EnsureJitTransferData(Recycler* recycler);",
          "698: #if PDATA_ENABLED",
          "699:         XDataAllocation* GetXDataInfo() { return this->xdataInfo; }",
          "700:         void SetXDataInfo(XDataAllocation* xdataInfo) { this->xdataInfo = xdataInfo; }",
          "701: #endif",
          "703: #ifdef FIELD_ACCESS_STATS",
          "704:         FieldAccessStats* GetFieldAccessStats() { return this->fieldAccessStats; }",
          "705:         FieldAccessStats* EnsureFieldAccessStats(Recycler* recycler);",
          "706: #endif",
          "708:         void PinTypeRefs(ScriptContext* scriptContext);",
          "709:         void InstallGuards(ScriptContext* scriptContext);",
          "710: #endif",
          "712:         void Cleanup(bool isShutdown, bool captureCleanupStack);",
          "714: #if ENABLE_DEBUG_STACK_BACK_TRACE",
          "715:         void CaptureCleanupStackTrace();",
          "716: #endif",
          "718:         bool IsNotScheduled() const",
          "719:         {",
          "720:             return this->GetState() == NotScheduled;",
          "721:         }",
          "723:         bool IsCodeGenPending() const",
          "724:         {",
          "725:             return this->GetState() == CodeGenPending;",
          "726:         }",
          "728:         bool IsCodeGenRecorded() const",
          "729:         {",
          "730:             return this->GetState() == CodeGenRecorded;",
          "731:         }",
          "733:         bool IsNativeCode() const",
          "734:         {",
          "735: #if ENABLE_NATIVE_CODEGEN",
          "736:             return this->GetState() == CodeGenRecorded ||",
          "737:                 this->GetState() == CodeGenDone;",
          "738: #else",
          "739:             return false;",
          "740: #endif",
          "741:         }",
          "743:         bool IsCodeGenDone() const",
          "744:         {",
          "745: #if ENABLE_NATIVE_CODEGEN",
          "746:             return this->GetState() == CodeGenDone;",
          "747: #else",
          "748:             return false;",
          "749: #endif",
          "750:         }",
          "752:         bool IsCodeGenQueued() const",
          "753:         {",
          "754: #if ENABLE_NATIVE_CODEGEN",
          "755:             return this->GetState() == CodeGenQueued;",
          "756: #else",
          "757:             return false;",
          "758: #endif",
          "759:         }",
          "761:         bool IsJITCapReached() const",
          "762:         {",
          "763: #if ENABLE_NATIVE_CODEGEN",
          "764:             return this->GetState() == JITCapReached;",
          "765: #else",
          "766:             return false;",
          "767: #endif",
          "768:         }",
          "770:         bool IsCleanedUp() const",
          "771:         {",
          "772:             return this->GetState() == CleanedUp;",
          "773:         }",
          "775:         bool IsPendingCleanup() const",
          "776:         {",
          "777:             return this->GetState() == PendingCleanup;",
          "778:         }",
          "780:         void SetPendingCleanup()",
          "781:         {",
          "782:             this->state = PendingCleanup;",
          "783:         }",
          "785: #if ENABLE_DEBUG_CONFIG_OPTIONS",
          "786:         void SetCleanupReason(CleanupReason reason)",
          "787:         {",
          "788:             this->cleanupReason = reason;",
          "789:         }",
          "790: #endif",
          "792:         bool IsLoopBody() const",
          "793:         {",
          "794:             return this->isLoopBody;",
          "795:         }",
          "797: #if ENABLE_NATIVE_CODEGEN",
          "798:         bool HasJittedStackClosure() const",
          "799:         {",
          "800:             return this->hasJittedStackClosure;",
          "801:         }",
          "803:         void SetHasJittedStackClosure()",
          "804:         {",
          "805:             this->hasJittedStackClosure = true;",
          "806:         }",
          "807: #endif",
          "809:         void Reset(bool resetStateToNotScheduled = true);",
          "811: #if ENABLE_NATIVE_CODEGEN",
          "812:         void SetCodeGenPending(CodeGenWorkItem * workItem)",
          "813:         {",
          "814:             Assert(this->GetState() == NotScheduled || this->GetState() == CleanedUp);",
          "815:             Assert(workItem != nullptr);",
          "816:             this->workItem = workItem;",
          "817:             this->state = CodeGenPending;",
          "818:         }",
          "820:         void SetCodeGenPending()",
          "821:         {",
          "822:             Assert(this->GetState() == CodeGenQueued);",
          "823:             this->state = CodeGenPending;",
          "824:         }",
          "826:         void SetCodeGenQueued()",
          "827:         {",
          "828:             Assert(this->GetState() == CodeGenPending);",
          "829:             this->state = CodeGenQueued;",
          "830:         }",
          "832:         void RevertToNotScheduled()",
          "833:         {",
          "834:             Assert(this->GetState() == CodeGenPending);",
          "835:             Assert(this->workItem != nullptr);",
          "836:             this->workItem = nullptr;",
          "837:             this->state = NotScheduled;",
          "838:         }",
          "840:         void SetCodeGenPendingWithStackAllocatedWorkItem()",
          "841:         {",
          "842:             Assert(this->GetState() == NotScheduled || this->GetState() == CleanedUp);",
          "843:             this->workItem = nullptr;",
          "844:             this->state = CodeGenPending;",
          "845:         }",
          "847:         void SetCodeGenRecorded(Js::JavascriptMethod nativeAddress, ptrdiff_t codeSize)",
          "848:         {",
          "849:             Assert(this->GetState() == CodeGenQueued);",
          "850:             Assert(codeSize > 0);",
          "851:             this->nativeAddress = nativeAddress;",
          "852:             this->codeSize = codeSize;",
          "853:             this->state = CodeGenRecorded;",
          "855: #ifdef PERF_COUNTERS",
          "856:             this->OnRecorded();",
          "857: #endif",
          "858:         }",
          "860:         void SetCodeGenDone()",
          "861:         {",
          "862:             Assert(this->GetState() == CodeGenRecorded);",
          "863:             this->state = CodeGenDone;",
          "864:             this->workItem = nullptr;",
          "865:         }",
          "867:         void SetJITCapReached()",
          "868:         {",
          "869:             Assert(this->GetState() == CodeGenQueued);",
          "870:             this->state = JITCapReached;",
          "871:             this->workItem = nullptr;",
          "872:         }",
          "874:         SmallSpanSequence* GetNativeThrowSpanSequence() const",
          "875:         {",
          "876:             Assert(this->GetState() != NotScheduled);",
          "877:             Assert(this->GetState() != CleanedUp);",
          "878:             return nativeThrowSpanSequence;",
          "879:         }",
          "881:         void SetNativeThrowSpanSequence(SmallSpanSequence* seq)",
          "882:         {",
          "883:             Assert(this->GetState() == CodeGenQueued);",
          "884:             Assert(this->nativeThrowSpanSequence == nullptr);",
          "886:             nativeThrowSpanSequence = seq;",
          "887:         }",
          "889:         bool IsInNativeAddressRange(DWORD_PTR codeAddress) {",
          "890:             return (IsNativeCode() &&",
          "891:                 codeAddress >= GetNativeAddress() &&",
          "892:                 codeAddress < GetNativeAddress() + GetCodeSize());",
          "893:         }",
          "894: #endif",
          "896:         DWORD_PTR GetNativeAddress() const",
          "897:         {",
          "899:             Assert(this->GetState() == CodeGenRecorded || this->GetState() == CodeGenDone || this->isAsmJsFunction);",
          "902:             return reinterpret_cast<DWORD_PTR>(this->nativeAddress);",
          "903:         }",
          "905:         ptrdiff_t GetCodeSize() const",
          "906:         {",
          "907:             Assert(this->GetState() == CodeGenRecorded || this->GetState() == CodeGenDone);",
          "908:             return codeSize;",
          "909:         }",
          "911:         CodeGenWorkItem * GetWorkItem() const",
          "912:         {",
          "913:             State state = this->GetState();",
          "914:             Assert(state != NotScheduled || this->workItem == nullptr);",
          "915:             Assert(state == CleanedUp && this->workItem == nullptr ||",
          "916:                 state != CleanedUp);",
          "918:             if (state == PendingCleanup)",
          "919:             {",
          "920:                 return nullptr;",
          "921:             }",
          "923:             return this->workItem;",
          "924:         }",
          "926: #ifdef ASMJS_PLAT",
          "928:         void SetCodeSize(ptrdiff_t size)",
          "929:         {",
          "930:             Assert(isAsmJsFunction);",
          "931:             this->codeSize = size;",
          "932:         }",
          "934:         void SetNativeAddress(Js::JavascriptMethod address)",
          "935:         {",
          "936:             Assert(isAsmJsFunction);",
          "937:             this->nativeAddress = address;",
          "938:         }",
          "940:         void SetIsAsmJSFunction(bool value)",
          "941:         {",
          "942:             this->isAsmJsFunction = value;",
          "943:         }",
          "944: #endif",
          "946:         bool GetIsAsmJSFunction()const",
          "947:         {",
          "948:             return this->isAsmJsFunction;",
          "949:         }",
          "951: #ifdef ASMJS_PLAT",
          "952:         void SetTJCodeGenDone()",
          "953:         {",
          "954:             Assert(isAsmJsFunction);",
          "955:             this->state = CodeGenDone;",
          "956:             this->workItem = nullptr;",
          "957:         }",
          "958: #endif",
          "960: #if ENABLE_NATIVE_CODEGEN",
          "961:         void AddWeakFuncRef(RecyclerWeakReference<FunctionBody> *weakFuncRef, Recycler *recycler);",
          "962:         WeakFuncRefSet *EnsureWeakFuncRefSet(Recycler *recycler);",
          "964:         void EnsureIsReadyToCall();",
          "965:         void ProcessJitTransferData();",
          "966:         void ResetOnLazyBailoutFailure();",
          "967:         void OnNativeCodeInstallFailure();",
          "968:         virtual void ResetOnNativeCodeInstallFailure() = 0;",
          "970:         Js::PropertyGuard* RegisterSharedPropertyGuard(Js::PropertyId propertyId, ScriptContext* scriptContext);",
          "971:         Js::PropertyId* GetSharedPropertyGuards(_Out_ unsigned int& count);",
          "973:         bool TryGetSharedPropertyGuard(Js::PropertyId propertyId, Js::PropertyGuard*& guard);",
          "974:         void RecordTypeGuards(int propertyGuardCount, TypeGuardTransferEntry* typeGuardTransferRecord, size_t typeGuardTransferPlusSize);",
          "975:         void RecordCtorCacheGuards(CtorCacheGuardTransferEntry* ctorCacheTransferRecord, size_t ctorCacheTransferPlusSize);",
          "976:         void FreePropertyGuards();",
          "977:         void FreeJitTransferData();",
          "978:         void RegisterEquivalentTypeCaches();",
          "979:         void UnregisterEquivalentTypeCaches();",
          "980:         bool ClearEquivalentTypeCaches();",
          "982:         void RegisterConstructorCache(Js::ConstructorCache* constructorCache, Recycler* recycler);",
          "983:         uint GetConstructorCacheCount() const { return this->constructorCaches != nullptr ? this->constructorCaches->Count() : 0; }",
          "984:         uint32 GetPendingPolymorphicCacheState() const { return this->pendingPolymorphicCacheState; }",
          "985:         void SetPendingPolymorphicCacheState(uint32 state) { this->pendingPolymorphicCacheState = state; }",
          "986:         BYTE GetPendingInlinerVersion() const { return this->pendingInlinerVersion; }",
          "987:         void SetPendingInlinerVersion(BYTE version) { this->pendingInlinerVersion = version; }",
          "988:         ImplicitCallFlags GetPendingImplicitCallFlags() const { return this->pendingImplicitCallFlags; }",
          "989:         void SetPendingImplicitCallFlags(ImplicitCallFlags flags) { this->pendingImplicitCallFlags = flags; }",
          "990:         virtual void Invalidate(bool prolongEntryPoint) { Assert(false); }",
          "991:         void RecordBailOutMap(JsUtil::List<LazyBailOutRecord, ArenaAllocator>* bailoutMap);",
          "992:         void RecordInlineeFrameMap(JsUtil::List<NativeOffsetInlineeFramePair, ArenaAllocator>* tempInlineeFrameMap);",
          "993:         void RecordInlineeFrameOffsetsInfo(unsigned int offsetsArrayOffset, unsigned int offsetsArrayCount);",
          "994:         InlineeFrameRecord* FindInlineeFrame(void* returnAddress);",
          "995:         bool HasInlinees() { return this->frameHeight > 0; }",
          "996:         void DoLazyBailout(BYTE** addressOfReturnAddress, Js::FunctionBody* functionBody, const PropertyRecord* propertyRecord);",
          "997: #endif",
          "998: #if DBG_DUMP",
          "999:     public:",
          "1000: #elif defined(VTUNE_PROFILING)",
          "1001:     private:",
          "1002: #endif",
          "1003: #if DBG_DUMP || defined(VTUNE_PROFILING)",
          "1005:         struct NativeOffsetMap",
          "1006:         {",
          "1007:             uint32 statementIndex;",
          "1008:             regex::Interval nativeOffsetSpan;",
          "1009:         };",
          "1011:     private:",
          "1012:         typedef JsUtil::List<NativeOffsetMap, HeapAllocator> NativeOffsetMapListType;",
          "1013:         Field(NativeOffsetMapListType) nativeOffsetMaps;",
          "1014:     public:",
          "1015:         void RecordNativeMap(uint32 offset, uint32 statementIndex);",
          "1017:         int GetNativeOffsetMapCount() const;",
          "1018: #endif",
          "1020: #if DBG_DUMP && ENABLE_NATIVE_CODEGEN",
          "1021:         void DumpNativeOffsetMaps();",
          "1022:         void DumpNativeThrowSpanSequence();",
          "1023:         NativeOffsetMap* GetNativeOffsetMap(int index)",
          "1024:         {",
          "1025:              Assert(index >= 0);",
          "1026:              Assert(index < GetNativeOffsetMapCount());",
          "1028:              return &nativeOffsetMaps.Item(index);",
          "1029:         }",
          "1030: #endif",
          "1032: #ifdef VTUNE_PROFILING",
          "1034:     public:",
          "1035:         uint PopulateLineInfo(void* pLineInfo, FunctionBody* body);",
          "1037: #endif",
          "1039:     protected:",
          "1040:         Field(void*) validationCookie;",
          "1041:     };",
          "1043:     class FunctionEntryPointInfo : public EntryPointInfo",
          "1044:     {",
          "1045:     public:",
          "1046:         Field(FunctionProxy *) functionProxy;",
          "1047:         Field(FunctionEntryPointInfo*) nextEntryPoint;",
          "1050:         Field(int32) localVarSlotsOffset;",
          "1052:         Field(int32) localVarChangedOffset;",
          "1053:         Field(uint) entryPointIndex;",
          "1055:         Field(uint32) callsCount;",
          "1056:         Field(uint32) lastCallsCount;",
          "1058:     private:",
          "1059:         Field(ExecutionMode) jitMode;",
          "1060:         Field(FunctionEntryPointInfo*) mOldFunctionEntryPointInfo; // strong ref to oldEntryPointInfo(Int or TJ) in asm to ensure we don't collect it before JIT is completed",
          "1061:         Field(bool)       mIsTemplatizedJitMode; // true only if in TJ mode, used only for debugging",
          "1062:     public:",
          "1063:         FunctionEntryPointInfo(FunctionProxy * functionInfo, Js::JavascriptMethod method, ThreadContext* context, void* validationCookie);",
          "1065: #ifdef ASMJS_PLAT",
          "1068:         void SetOldFunctionEntryPointInfo(FunctionEntryPointInfo* entrypointInfo);",
          "1069:         FunctionEntryPointInfo* GetOldFunctionEntryPointInfo()const;",
          "1070:         void SetIsTJMode(bool value);",
          "1071:         bool GetIsTJMode()const;",
          "1073: #endif",
          "1075:         bool ExecutedSinceCallCountCollection() const;",
          "1076:         void CollectCallCounts();",
          "1078:         virtual FunctionBody *GetFunctionBody() const override;",
          "1079: #if ENABLE_NATIVE_CODEGEN",
          "1080:         ExecutionMode GetJitMode() const;",
          "1081:         void SetJitMode(const ExecutionMode jitMode);",
          "1083:         virtual void Invalidate(bool prolongEntryPoint) override;",
          "1084:         virtual void Expire() override;",
          "1085:         virtual void EnterExpirableCollectMode() override;",
          "1086:         virtual void ResetOnNativeCodeInstallFailure() override;",
          "1087:         static const uint8 GetDecrCallCountPerBailout()",
          "1088:         {",
          "1089:             return (uint8)CONFIG_FLAG(CallsToBailoutsRatioForRejit) + 1;",
          "1090:         }",
          "1091: #endif",
          "1093:         virtual void OnCleanup(bool isShutdown) override;",
          "1095:         virtual void ReleasePendingWorkItem() override;",
          "1097: #ifdef PERF_COUNTERS",
          "1098:         virtual void OnRecorded() override;",
          "1099: #endif",
          "1101:     };",
          "1103:     class LoopEntryPointInfo : public EntryPointInfo",
          "1104:     {",
          "1105:     public:",
          "1106:         Field(LoopHeader*) loopHeader;",
          "1107:         Field(uint) jittedLoopIterationsSinceLastBailout; // number of times the loop iterated in the jitted code before bailing out",
          "1108:         Field(uint) totalJittedLoopIterations; // total number of times the loop has iterated in the jitted code for this entry point for a particular invocation of the loop",
          "1109:         LoopEntryPointInfo(LoopHeader* loopHeader, Js::JavascriptLibrary* library, void* validationCookie) :",
          "1110:             EntryPointInfo(nullptr, library, validationCookie, /*threadContext*/ nullptr, /*isLoopBody*/ true),",
          "1111:             loopHeader(loopHeader),",
          "1112:             jittedLoopIterationsSinceLastBailout(0),",
          "1113:             totalJittedLoopIterations(0),",
          "1114:             mIsTemplatizedJitMode(false)",
          "1115: #ifdef BGJIT_STATS",
          "1116:             ,used(false)",
          "1117: #endif",
          "1118:         { }",
          "1120:         virtual FunctionBody *GetFunctionBody() const override;",
          "1122:         virtual void OnCleanup(bool isShutdown) override;",
          "1124: #if ENABLE_NATIVE_CODEGEN",
          "1125:         virtual void ResetOnNativeCodeInstallFailure() override;",
          "1126:         static const uint8 GetDecrLoopCountPerBailout()",
          "1127:         {",
          "1128:             return (uint8)CONFIG_FLAG(LoopIterationsToBailoutsRatioForRejit) + 1;",
          "1129:         }",
          "1130: #endif",
          "1132: #ifdef ASMJS_PLAT",
          "1133:         void SetIsTJMode(bool value)",
          "1134:         {",
          "1135:             Assert(this->GetIsAsmJSFunction());",
          "1136:             mIsTemplatizedJitMode = value;",
          "1137:         }",
          "1139:         bool GetIsTJMode()const",
          "1140:         {",
          "1141:             return mIsTemplatizedJitMode;",
          "1142:         };",
          "1143: #endif",
          "1145: #ifdef PERF_COUNTERS",
          "1146:         virtual void OnRecorded() override;",
          "1147: #endif",
          "1149: #ifdef BGJIT_STATS",
          "1150:         bool IsUsed() const",
          "1151:         {",
          "1152:             return this->used;",
          "1153:         }",
          "1155:         void MarkAsUsed()",
          "1156:         {",
          "1157:             this->used = true;",
          "1158:         }",
          "1159: #endif",
          "1160:     private:",
          "1161: #ifdef BGJIT_STATS",
          "1162:         Field(bool) used;",
          "1163: #endif",
          "1164:         Field(bool)       mIsTemplatizedJitMode;",
          "1165:     };",
          "1167:     typedef RecyclerWeakReference<FunctionEntryPointInfo> FunctionEntryPointWeakRef;",
          "1169:     typedef SynchronizableList<FunctionEntryPointWeakRef*, JsUtil::List<FunctionEntryPointWeakRef*>> FunctionEntryPointList;",
          "1170:     typedef SynchronizableList<LoopEntryPointInfo*, JsUtil::List<LoopEntryPointInfo*>> LoopEntryPointList;",
          "1172: #pragma endregion",
          "1174:     struct LoopHeader",
          "1175:     {",
          "1176:     private:",
          "1177:         Field(LoopEntryPointList*) entryPoints;",
          "1179:     public:",
          "1180:         Field(uint) startOffset;",
          "1181:         Field(uint) endOffset;",
          "1182:         Field(uint) interpretCount;",
          "1183:         Field(uint) profiledLoopCounter;",
          "1184:         Field(bool) isNested;",
          "1185:         Field(bool) isInTry;",
          "1186:         Field(FunctionBody *) functionBody;",
          "1188: #if DBG_DUMP",
          "1189:         Field(uint) nativeCount;",
          "1190: #endif",
          "1191:         static const uint NoLoop = (uint)-1;",
          "1193:         static const uint GetOffsetOfProfiledLoopCounter() { return offsetof(LoopHeader, profiledLoopCounter); }",
          "1194:         static const uint GetOffsetOfInterpretCount() { return offsetof(LoopHeader, interpretCount); }",
          "1196:         bool Contains(Js::LoopHeader * loopHeader) const",
          "1197:         {",
          "1198:             return (this->startOffset <= loopHeader->startOffset && loopHeader->endOffset <= this->endOffset);",
          "1199:         }",
          "1201:         bool Contains(uint offset) const",
          "1202:         {",
          "1203:             return this->startOffset <= offset && offset < this->endOffset;",
          "1204:         }",
          "1206:         Js::JavascriptMethod GetCurrentEntryPoint() const",
          "1207:         {",
          "1208:             LoopEntryPointInfo * entryPoint = GetCurrentEntryPointInfo();",
          "1210:             if (entryPoint != nullptr)",
          "1211:             {",
          "1212:                 return this->entryPoints->Item(this->GetCurrentEntryPointIndex())->jsMethod;",
          "1213:             }",
          "1215:             return nullptr;",
          "1216:         }",
          "1218:         LoopEntryPointInfo * GetCurrentEntryPointInfo() const",
          "1219:         {",
          "1220:             Assert(this->entryPoints->Count() > 0);",
          "1221:             return this->entryPoints->Item(this->GetCurrentEntryPointIndex());",
          "1222:         }",
          "1224:         uint GetByteCodeCount()",
          "1225:         {",
          "1226:             return (endOffset - startOffset);",
          "1227:         }",
          "1229:         int GetCurrentEntryPointIndex() const",
          "1230:         {",
          "1231:            return this->entryPoints->Count() - 1;",
          "1232:         }",
          "1234:         LoopEntryPointInfo * GetEntryPointInfo(int index) const",
          "1235:         {",
          "1236:             return this->entryPoints->Item(index);",
          "1237:         }",
          "1239:         template <class Fn>",
          "1240:         void MapEntryPoints(Fn fn) const",
          "1241:         {",
          "1242:             if (this->entryPoints) // ETW rundown may call this before entryPoints initialization",
          "1243:             {",
          "1244:                 this->entryPoints->Map([&](int index, LoopEntryPointInfo * entryPoint)",
          "1245:                 {",
          "1246:                     if (entryPoint != nullptr)",
          "1247:                     {",
          "1248:                         fn(index, entryPoint);",
          "1249:                     }",
          "1250:                 });",
          "1251:             }",
          "1252:         }",
          "1254:         template <class Fn>",
          "1255:         bool MapEntryPointsUntil(Fn fn) const",
          "1256:         {",
          "1257:             if (this->entryPoints) // ETW rundown may call this before entryPoints initialization",
          "1258:             {",
          "1259:                 return this->entryPoints->MapUntil([&](int index, LoopEntryPointInfo * entryPoint)",
          "1260:                 {",
          "1261:                     if (entryPoint != nullptr)",
          "1262:                     {",
          "1263:                         return fn(index, entryPoint);",
          "1264:                     }",
          "1265:                     return false;",
          "1266:                 });",
          "1267:             }",
          "1268:             return false;",
          "1269:         }",
          "1271:         template <class DebugSite, class Fn>",
          "1272:         HRESULT MapEntryPoints(DebugSite site, Fn fn) const // external debugging version",
          "1273:         {",
          "1274:             return Map(site, PointerValue(this->entryPoints), [&](int index, LoopEntryPointInfo * entryPoint)",
          "1275:             {",
          "1276:                 if (entryPoint != nullptr)",
          "1277:                 {",
          "1278:                     fn(index, entryPoint);",
          "1279:                 }",
          "1280:             });",
          "1281:         }",
          "1283:         void Init(FunctionBody * functionBody);",
          "1285: #if ENABLE_NATIVE_CODEGEN",
          "1286:         int CreateEntryPoint();",
          "1287:         void ReleaseEntryPoints();",
          "1288: #endif",
          "1290:         void ResetInterpreterCount()",
          "1291:         {",
          "1292:             this->interpretCount = 0;",
          "1293:         }",
          "1294:         void ResetProfiledLoopCounter()",
          "1295:         {",
          "1296:             this->profiledLoopCounter = 0;",
          "1297:         }",
          "1299:     };",
          "1305:     class FunctionProxy;",
          "1307:     typedef Field(FunctionInfo*)* FunctionInfoArray;",
          "1308:     typedef Field(FunctionInfo*)* FunctionInfoPtrPtr;",
          "1316:     class FunctionProxy : public FinalizableObject",
          "1317:     {",
          "1318:         static CriticalSection GlobalLock;",
          "1319:     public:",
          "1320:         static CriticalSection* GetLock() { return &GlobalLock; }",
          "1321:         typedef RecyclerWeakReference<DynamicType> FunctionTypeWeakRef;",
          "1322:         typedef JsUtil::List<FunctionTypeWeakRef*, Recycler, false, WeakRefFreeListedRemovePolicy> FunctionTypeWeakRefList;",
          "1324:     protected:",
          "1325:         FunctionProxy(ScriptContext* scriptContext, Utf8SourceInfo* utf8SourceInfo, uint functionNumber);",
          "1326:         DEFINE_VTABLE_CTOR_NOBASE(FunctionProxy);",
          "1328:         enum class AuxPointerType : uint8 {",
          "1329:             DeferredStubs = 0,",
          "1330:             CachedSourceString = 1,",
          "1331:             AsmJsFunctionInfo = 2,",
          "1332:             AsmJsModuleInfo = 3,",
          "1333:             StatementMaps = 4,",
          "1334:             StackNestedFuncParent = 5,",
          "1335:             SimpleJitEntryPointInfo = 6,",
          "1336:             FunctionObjectTypeList = 7,           // Script function types not including the deferred prototype type",
          "1337:             CodeGenGetSetRuntimeData = 8,",
          "1338:             PropertyIdOnRegSlotsContainer = 9,    // This is used for showing locals for the current frame.",
          "1339:             LoopHeaderArray = 10,",
          "1340:             CodeGenRuntimeData = 11,",
          "1341:             PolymorphicInlineCachesHead = 12,     // DList of all polymorphic inline caches that aren't finalized yet",
          "1342:             PropertyIdsForScopeSlotArray = 13,    // For SourceInfo",
          "1343:             PolymorphicCallSiteInfoHead  = 14,",
          "1344:             AuxBlock = 15,                        // Optional auxiliary information",
          "1345:             AuxContextBlock = 16,                 // Optional auxiliary context specific information",
          "1346:             ReferencedPropertyIdMap = 17,",
          "1347:             LiteralRegexes = 18,",
          "1348:             ObjLiteralTypes = 19,",
          "1349:             ScopeInfo = 20,",
          "1350:             FormalsPropIdArray = 21,",
          "1351:             ForInCacheArray = 22,",
          "1353:             Max,",
          "1354:             Invalid = 0xff",
          "1355:         };",
          "1357:         typedef AuxPtrs<FunctionProxy, AuxPointerType> AuxPtrsT;",
          "1358:         friend AuxPtrsT;",
          "1359:         FieldWithBarrier(AuxPtrsT*) auxPtrs;",
          "1360:         void* GetAuxPtr(AuxPointerType e) const;",
          "1361:         void* GetAuxPtrWithLock(AuxPointerType e) const;",
          "1362:         void SetAuxPtr(AuxPointerType e, void* ptr);",
          "1364:         FieldWithBarrier(FunctionInfo *) functionInfo;",
          "1366:     public:",
          "1367:         enum SetDisplayNameFlags",
          "1368:         {",
          "1369:             SetDisplayNameFlagsNone = 0,",
          "1370:             SetDisplayNameFlagsDontCopy = 1,",
          "1371:             SetDisplayNameFlagsRecyclerAllocated = 2",
          "1372:         };",
          "1374:         virtual void Dispose(bool isShutdown) override",
          "1375:         {",
          "1376:         }",
          "1378:         virtual void Mark(Recycler *recycler) override { AssertMsg(false, \"Mark called on object that isn't TrackableObject\"); }",
          "1380:         static const uint GetOffsetOfFunctionInfo() { return offsetof(FunctionProxy, functionInfo); }",
          "1381:         FunctionInfo * GetFunctionInfo() const",
          "1382:         {",
          "1383:             return this->functionInfo;",
          "1384:         }",
          "1385:         void SetFunctionInfo(FunctionInfo * functionInfo)",
          "1386:         {",
          "1387:             this->functionInfo = functionInfo;",
          "1388:         }",
          "1390:         LocalFunctionId GetLocalFunctionId() const;",
          "1391:         void SetLocalFunctionId(LocalFunctionId functionId);",
          "1393:         ParseableFunctionInfo* GetParseableFunctionInfo() const;",
          "1394:         void SetParseableFunctionInfo(ParseableFunctionInfo* func);",
          "1395:         DeferDeserializeFunctionInfo* GetDeferDeserializeFunctionInfo() const;",
          "1396:         FunctionBody * GetFunctionBody() const;",
          "1398:         void VerifyOriginalEntryPoint() const;",
          "1399:         JavascriptMethod GetOriginalEntryPoint() const;",
          "1400:         JavascriptMethod GetOriginalEntryPoint_Unchecked() const;",
          "1401:         void SetOriginalEntryPoint(const JavascriptMethod originalEntryPoint);",
          "1403:         bool IsAsync() const;",
          "1404:         bool IsDeferred() const;",
          "1405:         bool IsLambda() const;",
          "1406:         bool IsConstructor() const;",
          "1407:         bool IsGenerator() const;",
          "1408:         bool IsClassConstructor() const;",
          "1409:         bool IsClassMethod() const;",
          "1410:         bool IsModule() const;",
          "1411:         bool IsWasmFunction() const;",
          "1412:         bool HasSuperReference() const;",
          "1413:         bool IsCoroutine() const;",
          "1414:         bool GetCapturesThis() const;",
          "1415:         void SetCapturesThis();",
          "1416:         bool GetEnclosedByGlobalFunc() const;",
          "1417:         void SetEnclosedByGlobalFunc();",
          "1418:         bool CanBeDeferred() const;",
          "1419:         BOOL IsDeferredDeserializeFunction() const;",
          "1420:         BOOL IsDeferredParseFunction() const;",
          "1421:         FunctionInfo::Attributes GetAttributes() const;",
          "1422:         void SetAttributes(FunctionInfo::Attributes attributes);",
          "1424:         Recycler* GetRecycler() const;",
          "1425:         uint32 GetSourceContextId() const;",
          "1426:         char16* GetDebugNumberSet(wchar(&bufferToWriteTo)[MAX_FUNCTION_BODY_DEBUG_STRING_SIZE]) const;",
          "1427:         bool GetIsTopLevel() { return m_isTopLevel; }",
          "1428:         void SetIsTopLevel(bool set) { m_isTopLevel = set; }",
          "1429:         bool GetIsAnonymousFunction() const { return this->GetDisplayName() == Js::Constants::AnonymousFunction; }",
          "1430:         void Copy(FunctionProxy* other);",
          "1431:         ParseableFunctionInfo* EnsureDeserialized();",
          "1432:         ScriptContext* GetScriptContext() const;",
          "1433:         Utf8SourceInfo* GetUtf8SourceInfo() const { return this->m_utf8SourceInfo; }",
          "1434:         void SetUtf8SourceInfo(Utf8SourceInfo* utf8SourceInfo) { m_utf8SourceInfo = utf8SourceInfo; }",
          "1435:         bool IsInDebugMode() const { return this->m_utf8SourceInfo->IsInDebugMode(); }",
          "1437:         DWORD_PTR GetSecondaryHostSourceContext() const;",
          "1438:         DWORD_PTR GetHostSourceContext() const;",
          "1439:         SourceContextInfo * GetSourceContextInfo() const;",
          "1440:         SRCINFO const * GetHostSrcInfo() const;",
          "1442:         uint GetFunctionNumber() const { return m_functionNumber; }",
          "1444:         virtual void Finalize(bool isShutdown) override;",
          "1446:         void UpdateFunctionBodyImpl(FunctionBody* body);",
          "1447:         bool IsFunctionBody() const;",
          "1448:         uint GetCompileCount() const;",
          "1449:         void SetCompileCount(uint count);",
          "1450:         ProxyEntryPointInfo* GetDefaultEntryPointInfo() const;",
          "1451:         ScriptFunctionType * GetDeferredPrototypeType() const;",
          "1452:         ScriptFunctionType * EnsureDeferredPrototypeType();",
          "1453:         JavascriptMethod GetDirectEntryPoint(ProxyEntryPointInfo* entryPoint) const;",
          "1456:         FunctionTypeWeakRefList* EnsureFunctionObjectTypeList();",
          "1457:         FunctionTypeWeakRefList* GetFunctionObjectTypeList() const;",
          "1458:         void SetFunctionObjectTypeList(FunctionTypeWeakRefList* list);",
          "1459:         void RegisterFunctionObjectType(DynamicType* functionType);",
          "1460:         template <typename Fn>",
          "1461:         void MapFunctionObjectTypes(Fn func);",
          "1463:         static uint GetOffsetOfDeferredPrototypeType() { return static_cast<uint>(offsetof(Js::FunctionProxy, deferredPrototypeType)); }",
          "1464:         static Js::ScriptFunctionType * EnsureFunctionProxyDeferredPrototypeType(FunctionProxy * proxy)",
          "1465:         {",
          "1466:             return proxy->EnsureDeferredPrototypeType();",
          "1467:         }",
          "1469:         void SetIsPublicLibraryCode() { m_isPublicLibraryCode = true; }",
          "1470:         bool IsPublicLibraryCode() const { return m_isPublicLibraryCode; }",
          "1472: #if DBG",
          "1473:         bool HasValidEntryPoint() const;",
          "1474: #if defined(ENABLE_SCRIPT_PROFILING) || defined(ENABLE_SCRIPT_DEBUGGING)",
          "1475:         bool HasValidProfileEntryPoint() const;",
          "1476: #endif",
          "1477:         bool HasValidNonProfileEntryPoint() const;",
          "1478: #endif",
          "1479:         virtual void SetDisplayName(const char16* displayName, uint displayNameLength, uint displayShortNameOffset, SetDisplayNameFlags flags = SetDisplayNameFlagsNone) = 0;",
          "1480:         virtual const char16* GetDisplayName() const = 0;",
          "1481:         virtual uint GetDisplayNameLength() const = 0;",
          "1482:         virtual uint GetShortDisplayNameOffset() const = 0;",
          "1483:         static const char16* WrapWithBrackets(const char16* name, charcount_t sz, ScriptContext* scriptContext);",
          "1488:         const char16* GetShortDisplayName(charcount_t * shortNameLength);",
          "1490:         bool GetDisplayNameIsRecyclerAllocated() { return m_displayNameIsRecyclerAllocated; }",
          "1492:         bool IsJitLoopBodyPhaseEnabled() const",
          "1493:         {",
          "1495:             return !PHASE_OFF(JITLoopBodyPhase, this) && !PHASE_OFF(FullJitPhase, this) && !this->IsCoroutine();",
          "1496:         }",
          "1498:         bool IsJitLoopBodyPhaseForced() const",
          "1499:         {",
          "1500:             return",
          "1501:                 IsJitLoopBodyPhaseEnabled() &&",
          "1502:                 (",
          "1503:                     PHASE_FORCE(JITLoopBodyPhase, this)",
          "1504:                 #ifdef ENABLE_PREJIT",
          "1505:                     || Configuration::Global.flags.Prejit",
          "1506:                 #endif",
          "1507:                 );",
          "1508:         }",
          "1510:         ULONG GetHostStartLine() const;",
          "1511:         ULONG GetHostStartColumn() const;",
          "1513:     protected:",
          "1515:         static bool SetDisplayName(const char16* srcName, FieldWithBarrier(const char16*)* destName, uint displayNameLength, ScriptContext * scriptContext, SetDisplayNameFlags flags = SetDisplayNameFlagsNone);",
          "1516:         static bool SetDisplayName(const char16* srcName, const char16** destName, uint displayNameLength, ScriptContext * scriptContext, SetDisplayNameFlags flags = SetDisplayNameFlagsNone);",
          "1517:         static bool IsConstantFunctionName(const char16* srcName);",
          "1519:     protected:",
          "1520:         FieldNoBarrier(ScriptContext*) m_scriptContext;   // Memory context for this function body",
          "1521:         FieldWithBarrier(Utf8SourceInfo*) m_utf8SourceInfo;",
          "1522:         FieldWithBarrier(ScriptFunctionType*) deferredPrototypeType;",
          "1523:         FieldWithBarrier(ProxyEntryPointInfo*) m_defaultEntryPointInfo; // The default entry point info for the function proxy",
          "1525:         FieldWithBarrier(uint) m_functionNumber;  // Per thread global function number",
          "1527:         FieldWithBarrier(bool) m_tag11 : 1;",
          "1529:         FieldWithBarrier(bool) m_isTopLevel : 1; // Indicates that this function is top-level function, currently being used in script profiler and debugger",
          "1530:         FieldWithBarrier(bool) m_isPublicLibraryCode: 1; // Indicates this function is public boundary library code that should be visible in JS stack",
          "1531:         FieldWithBarrier(bool) m_canBeDeferred : 1;",
          "1532:         FieldWithBarrier(bool) m_displayNameIsRecyclerAllocated : 1;",
          "1535:         void CleanupFunctionProxyCounters()",
          "1536:         {",
          "1537:             PERF_COUNTER_DEC(Code, TotalFunction);",
          "1538:         }",
          "1540:         ULONG ComputeAbsoluteLineNumber(ULONG relativeLineNumber) const;",
          "1541:         ULONG ComputeAbsoluteColumnNumber(ULONG relativeLineNumber, ULONG relativeColumnNumber) const;",
          "1542:         ULONG GetLineNumberInHostBuffer(ULONG relativeLineNumber) const;",
          "1544:     private:",
          "1545:         ScriptFunctionType * AllocDeferredPrototypeType();",
          "1546:     };",
          "1548:     inline Js::LocalFunctionId FunctionProxy::GetLocalFunctionId() const",
          "1549:     {",
          "1550:         Assert(GetFunctionInfo());",
          "1551:         return GetFunctionInfo()->GetLocalFunctionId();",
          "1552:     }",
          "1554:     inline void FunctionProxy::SetLocalFunctionId(LocalFunctionId functionId)",
          "1555:     {",
          "1556:         Assert(GetFunctionInfo());",
          "1557:         Assert(GetFunctionInfo()->GetFunctionProxy() == this);",
          "1558:         return GetFunctionInfo()->SetLocalFunctionId(functionId);",
          "1559:     }",
          "1561:     inline void FunctionProxy::VerifyOriginalEntryPoint() const",
          "1562:     {",
          "1563:         Assert(GetFunctionInfo());",
          "1564:         Assert(GetFunctionInfo()->GetFunctionProxy() == this);",
          "1565:         return GetFunctionInfo()->VerifyOriginalEntryPoint();",
          "1566:     }",
          "1568:     inline JavascriptMethod FunctionProxy::GetOriginalEntryPoint() const",
          "1569:     {",
          "1570:         Assert(GetFunctionInfo());",
          "1571:         Assert(GetFunctionInfo()->GetFunctionProxy() == this);",
          "1572:         return GetFunctionInfo()->GetOriginalEntryPoint();",
          "1573:     }",
          "1575:     inline JavascriptMethod FunctionProxy::GetOriginalEntryPoint_Unchecked() const",
          "1576:     {",
          "1577:         Assert(GetFunctionInfo());",
          "1578:         Assert(GetFunctionInfo()->GetFunctionProxy() == this);",
          "1579:         return GetFunctionInfo()->GetOriginalEntryPoint_Unchecked();",
          "1580:     }",
          "1582:     inline void FunctionProxy::SetOriginalEntryPoint(const JavascriptMethod originalEntryPoint)",
          "1583:     {",
          "1584:         Assert(GetFunctionInfo());",
          "1585:         Assert(GetFunctionInfo()->GetFunctionProxy() == this);",
          "1586:         GetFunctionInfo()->SetOriginalEntryPoint(originalEntryPoint);",
          "1587:     }",
          "1589:     inline bool FunctionProxy::IsAsync() const",
          "1590:     {",
          "1591:         Assert(GetFunctionInfo());",
          "1592:         Assert(GetFunctionInfo()->GetFunctionProxy() == this);",
          "1593:         return GetFunctionInfo()->IsAsync();",
          "1594:     }",
          "1596:     inline bool FunctionProxy::IsDeferred() const",
          "1597:     {",
          "1598:         Assert(GetFunctionInfo());",
          "1599:         Assert(GetFunctionInfo()->GetFunctionProxy() == this);",
          "1600:         return GetFunctionInfo()->IsDeferred();",
          "1601:     }",
          "1603:     inline bool FunctionProxy::IsConstructor() const",
          "1604:     {",
          "1605:         Assert(GetFunctionInfo());",
          "1606:         Assert(GetFunctionInfo()->GetFunctionProxy() == this);",
          "1607:         return GetFunctionInfo()->IsConstructor();",
          "1608:     }",
          "1610:     inline bool FunctionProxy::IsGenerator() const",
          "1611:     {",
          "1612:         Assert(GetFunctionInfo());",
          "1613:         Assert(GetFunctionInfo()->GetFunctionProxy() == this);",
          "1614:         return GetFunctionInfo()->IsGenerator();",
          "1615:     }",
          "1617:     inline bool FunctionProxy::HasSuperReference() const",
          "1618:     {",
          "1619:         Assert(GetFunctionInfo());",
          "1620:         Assert(GetFunctionInfo()->GetFunctionProxy() == this);",
          "1621:         return GetFunctionInfo()->HasSuperReference();",
          "1622:     }",
          "1624:     inline bool FunctionProxy::IsCoroutine() const",
          "1625:     {",
          "1626:         Assert(GetFunctionInfo());",
          "1627:         Assert(GetFunctionInfo()->GetFunctionProxy() == this);",
          "1628:         return GetFunctionInfo()->IsCoroutine();",
          "1629:     }",
          "1631:     inline bool FunctionProxy::GetCapturesThis() const",
          "1632:     {",
          "1633:         Assert(GetFunctionInfo());",
          "1634:         Assert(GetFunctionInfo()->GetFunctionProxy() == this);",
          "1635:         return GetFunctionInfo()->GetCapturesThis();",
          "1636:     }",
          "1638:     inline void FunctionProxy::SetCapturesThis()",
          "1639:     {",
          "1640:         Assert(GetFunctionInfo());",
          "1641:         Assert(GetFunctionInfo()->GetFunctionProxy() == this);",
          "1642:         GetFunctionInfo()->SetCapturesThis();",
          "1643:     }",
          "1645:     inline bool FunctionProxy::GetEnclosedByGlobalFunc() const",
          "1646:     {",
          "1647:         Assert(GetFunctionInfo());",
          "1648:         Assert(GetFunctionInfo()->GetFunctionProxy() == this);",
          "1649:         return GetFunctionInfo()->GetEnclosedByGlobalFunc();",
          "1650:     }",
          "1652:     inline void FunctionProxy::SetEnclosedByGlobalFunc()",
          "1653:     {",
          "1654:         Assert(GetFunctionInfo());",
          "1655:         Assert(GetFunctionInfo()->GetFunctionProxy() == this);",
          "1656:         GetFunctionInfo()->SetEnclosedByGlobalFunc();",
          "1657:     }",
          "1659:     inline BOOL FunctionProxy::IsDeferredDeserializeFunction() const",
          "1660:     {",
          "1661:         Assert(GetFunctionInfo());",
          "1662:         Assert(GetFunctionInfo()->GetFunctionProxy() == this);",
          "1663:         return GetFunctionInfo()->IsDeferredDeserializeFunction();",
          "1664:     }",
          "1666:     inline BOOL FunctionProxy::IsDeferredParseFunction() const",
          "1667:     {",
          "1668:         Assert(GetFunctionInfo());",
          "1669:         Assert(GetFunctionInfo()->GetFunctionProxy() == this);",
          "1670:         return GetFunctionInfo()->IsDeferredParseFunction();",
          "1671:     }",
          "1673:     inline FunctionInfo::Attributes FunctionProxy::GetAttributes() const",
          "1674:     {",
          "1675:         Assert(GetFunctionInfo());",
          "1676:         Assert(GetFunctionInfo()->GetFunctionProxy() == this);",
          "1677:         return GetFunctionInfo()->GetAttributes();",
          "1678:     }",
          "1680:     inline void FunctionProxy::SetAttributes(FunctionInfo::Attributes attributes)",
          "1681:     {",
          "1682:         Assert(GetFunctionInfo());",
          "1683:         Assert(GetFunctionInfo()->GetFunctionProxy() == this);",
          "1684:         GetFunctionInfo()->SetAttributes(attributes);",
          "1685:     }",
          "1687:     inline void FunctionProxy::SetParseableFunctionInfo(ParseableFunctionInfo* func)",
          "1688:     {",
          "1689:         Assert(GetFunctionInfo());",
          "1690:         Assert(GetFunctionInfo()->GetFunctionProxy() == this);",
          "1691:         GetFunctionInfo()->SetParseableFunctionInfo(func);",
          "1692:     }",
          "1694:     inline bool FunctionProxy::IsLambda() const",
          "1695:     {",
          "1696:         Assert(GetFunctionInfo());",
          "1697:         Assert(GetFunctionInfo()->GetFunctionProxy() == this);",
          "1698:         return GetFunctionInfo()->IsLambda();",
          "1699:     }",
          "1701:     inline bool FunctionProxy::CanBeDeferred() const",
          "1702:     {",
          "1703:         Assert(GetFunctionInfo());",
          "1704:         Assert(GetFunctionInfo()->GetFunctionProxy() == this);",
          "1705:         return GetFunctionInfo()->CanBeDeferred();",
          "1706:     }",
          "1708:     inline bool FunctionProxy::IsClassConstructor() const",
          "1709:     {",
          "1710:         Assert(GetFunctionInfo());",
          "1711:         Assert(GetFunctionInfo()->GetFunctionProxy() == this);",
          "1712:         return GetFunctionInfo()->IsClassConstructor();",
          "1713:     }",
          "1715:     inline bool FunctionProxy::IsClassMethod() const",
          "1716:     {",
          "1717:         Assert(GetFunctionInfo());",
          "1718:         Assert(GetFunctionInfo()->GetFunctionProxy() == this);",
          "1719:         return GetFunctionInfo()->IsClassMethod();",
          "1720:     }",
          "1722:     inline bool FunctionProxy::IsModule() const",
          "1723:     {",
          "1724:         Assert(GetFunctionInfo());",
          "1725:         Assert(GetFunctionInfo()->GetFunctionProxy() == this);",
          "1726:         return GetFunctionInfo()->IsModule();",
          "1727:     }",
          "1729:     inline uint FunctionProxy::GetCompileCount() const",
          "1730:     {",
          "1731:         Assert(GetFunctionInfo());",
          "1732:         Assert(GetFunctionInfo()->GetFunctionProxy() == this);",
          "1733:         return GetFunctionInfo()->GetCompileCount();",
          "1734:     }",
          "1736:     inline void FunctionProxy::SetCompileCount(uint count)",
          "1737:     {",
          "1738:         Assert(GetFunctionInfo());",
          "1739:         Assert(GetFunctionInfo()->GetFunctionProxy() == this);",
          "1740:         GetFunctionInfo()->SetCompileCount(count);",
          "1741:     }",
          "1743:     inline ParseableFunctionInfo* FunctionProxy::GetParseableFunctionInfo() const",
          "1744:     {",
          "1745:         Assert(!IsDeferredDeserializeFunction());",
          "1746:         return (ParseableFunctionInfo*)this;",
          "1747:     }",
          "1749:     inline DeferDeserializeFunctionInfo* FunctionProxy::GetDeferDeserializeFunctionInfo() const",
          "1750:     {",
          "1751:         Assert(IsDeferredDeserializeFunction());",
          "1752:         return (DeferDeserializeFunctionInfo*)this;",
          "1753:     }",
          "1755:     inline FunctionBody * FunctionProxy::GetFunctionBody() const",
          "1756:     {",
          "1757:         Assert(IsFunctionBody());",
          "1758:         return (FunctionBody*)this;",
          "1759:     }",
          "1763:     class DeferDeserializeFunctionInfo: public FunctionProxy",
          "1764:     {",
          "1765:         friend struct ByteCodeSerializer;",
          "1767:     private:",
          "1768:         DeferDeserializeFunctionInfo(int nestedFunctionCount, LocalFunctionId functionId, ByteCodeCache* byteCodeCache, const byte* serializedFunction, Utf8SourceInfo* sourceInfo, ScriptContext* scriptContext, uint functionNumber, const char16* displayName, uint displayNameLength, uint displayShortNameOffset, NativeModule *nativeModule, FunctionInfo::Attributes attributes);",
          "1769:     public:",
          "1770:         static DeferDeserializeFunctionInfo* New(ScriptContext* scriptContext, int nestedFunctionCount, LocalFunctionId functionId, ByteCodeCache* byteCodeCache, const byte* serializedFunction, Utf8SourceInfo* utf8SourceInfo, const char16* displayName, uint displayNameLength, uint displayShortNameOffset, NativeModule *nativeModule, FunctionInfo::Attributes attributes);",
          "1772:         virtual void Finalize(bool isShutdown) override;",
          "1773:         FunctionBody* Deserialize();",
          "1775:         virtual const char16* GetDisplayName() const override;",
          "1776:         void SetDisplayName(const char16* displayName);",
          "1777:         virtual void SetDisplayName(const char16* displayName, uint displayNameLength, uint displayShortNameOffset, SetDisplayNameFlags flags = SetDisplayNameFlagsNone) override;",
          "1778:         virtual uint GetDisplayNameLength() const { return m_displayNameLength; }",
          "1779:         virtual uint GetShortDisplayNameOffset() const { return m_displayShortNameOffset; }",
          "1780:         LPCWSTR GetSourceInfo(int& lineNumber, int& columnNumber) const;",
          "1781:     private:",
          "1782:         Field(const byte*) m_functionBytes;",
          "1783:         Field(ByteCodeCache*) m_cache;",
          "1784:         Field(const char16 *) m_displayName;  // Optional name",
          "1785:         Field(uint) m_displayNameLength;",
          "1786:         Field(uint) m_displayShortNameOffset;",
          "1787:         Field(NativeModule *) m_nativeModule;",
          "1788:     };",
          "1790:     class ParseableFunctionInfo: public FunctionProxy",
          "1791:     {",
          "1792:         friend class ByteCodeBufferReader;",
          "1794:     public:",
          "1796:         enum FunctionBodyFlags : byte",
          "1797:         {",
          "1798:             Flags_None                     = 0x00,",
          "1799:             Flags_StackNestedFunc          = 0x01,",
          "1800:             Flags_HasOrParentHasArguments  = 0x02,",
          "1801:             Flags_HasTry                   = 0x04,",
          "1802:             Flags_HasThis                  = 0x08,",
          "1803:             Flags_NonUserCode              = 0x10,",
          "1804:             Flags_HasOnlyThisStatements    = 0x20,",
          "1805:             Flags_HasNoExplicitReturnValue = 0x40,   // Returns undefined, i.e. has no return statements or return with no expression",
          "1806:             Flags_HasRestParameter         = 0x80",
          "1807:         };",
          "1809:     protected:",
          "1810:         ParseableFunctionInfo(JavascriptMethod method, int nestedFunctionCount, LocalFunctionId functionId, Utf8SourceInfo* sourceInfo, ScriptContext* scriptContext, uint functionNumber, const char16* displayName, uint m_displayNameLength, uint displayShortNameOffset, FunctionInfo::Attributes attributes, Js::PropertyRecordList* propertyRecordList, FunctionBodyFlags flags);",
          "1812:         ParseableFunctionInfo(ParseableFunctionInfo * proxy);",
          "1814:     public:",
          "1815:         struct NestedArray",
          "1816:         {",
          "1817:             NestedArray(uint32 count): nestedCount(count) {}",
          "1819:             Field(uint32) nestedCount;",
          "1820:             Field(FunctionInfo*) functionInfoArray[];",
          "1821:         };",
          "1823:         template<typename Fn>",
          "1824:         void ForEachNestedFunc(Fn fn)",
          "1825:         {",
          "1826:             NestedArray* nestedArray = GetNestedArray();",
          "1827:             if (nestedArray != nullptr)",
          "1828:             {",
          "1829:                 for (uint i = 0; i < nestedArray->nestedCount; i++)",
          "1830:                 {",
          "1831:                     if (!fn(nestedArray->functionInfoArray[i]->GetFunctionProxy(), i))",
          "1832:                     {",
          "1833:                         break;",
          "1834:                     }",
          "1835:                 }",
          "1836:             }",
          "1837:         }",
          "1839:         NestedArray* GetNestedArray() const { return nestedArray; }",
          "1840:         uint GetNestedCount() const { return nestedArray == nullptr ? 0 : nestedArray->nestedCount; }",
          "1842:     public:",
          "1843:         static ParseableFunctionInfo* New(ScriptContext* scriptContext, int nestedFunctionCount, LocalFunctionId functionId, Utf8SourceInfo* utf8SourceInfo, const char16* displayName, uint m_displayNameLength, uint displayShortNameOffset, Js::PropertyRecordList* propertyRecordList, FunctionInfo::Attributes attributes, FunctionBodyFlags flags);",
          "1844:         static ParseableFunctionInfo* NewDeferredFunctionFromFunctionBody(FunctionBody *functionBody);",
          "1846:         DEFINE_VTABLE_CTOR_NO_REGISTER(ParseableFunctionInfo, FunctionProxy);",
          "1847:         FunctionBody* Parse(ScriptFunction ** functionRef = nullptr, bool isByteCodeDeserialization = false);",
          "1848: #ifdef ASMJS_PLAT",
          "1849:         FunctionBody* ParseAsmJs(Parser * p, __out CompileScriptException * se, __out ParseNodePtr * ptree);",
          "1850: #endif",
          "1852:         FunctionBodyFlags GetFlags() const { return flags; }",
          "1854:         static bool GetHasThis(FunctionBodyFlags flags) { return (flags & Flags_HasThis) != 0; }",
          "1855:         bool GetHasThis() const { return GetHasThis(flags); }",
          "1856:         void SetHasThis(bool has) { SetFlags(has, Flags_HasThis); }",
          "1858:         static bool GetHasTry(FunctionBodyFlags flags) { return (flags & Flags_HasTry) != 0; }",
          "1859:         bool GetHasTry() const { return GetHasTry(flags); }",
          "1860:         void SetHasTry(bool has) { SetFlags(has, Flags_HasTry); }",
          "1862:         static bool GetHasOrParentHasArguments(FunctionBodyFlags flags) { return (flags & Flags_HasOrParentHasArguments) != 0; }",
          "1863:         bool GetHasOrParentHasArguments() const { return GetHasOrParentHasArguments(flags); }",
          "1864:         void SetHasOrParentHasArguments(bool has) { SetFlags(has, Flags_HasOrParentHasArguments); }",
          "1866:         static bool DoStackNestedFunc(FunctionBodyFlags flags) { return (flags & Flags_StackNestedFunc) != 0; }",
          "1867:         bool DoStackNestedFunc() const { return DoStackNestedFunc(flags); }",
          "1868:         void SetStackNestedFunc(bool does) { SetFlags(does, Flags_StackNestedFunc); }",
          "1870:         bool IsNonUserCode() const { return (flags & Flags_NonUserCode) != 0; }",
          "1871:         void SetIsNonUserCode(bool set);",
          "1873:         bool GetHasNoExplicitReturnValue() { return (flags & Flags_HasNoExplicitReturnValue) != 0; }",
          "1874:         void SetHasNoExplicitReturnValue(bool has) { SetFlags(has, Flags_HasNoExplicitReturnValue); }",
          "1876:         bool GetHasOnlyThisStmts() const { return (flags & Flags_HasOnlyThisStatements) != 0; }",
          "1877:         void SetHasOnlyThisStmts(bool has) { SetFlags(has, Flags_HasOnlyThisStatements); }",
          "1879:         static bool GetHasRestParameter(FunctionBodyFlags flags) { return (flags & Flags_HasRestParameter) != 0; }",
          "1880:         bool GetHasRestParameter() const { return GetHasRestParameter(flags); }",
          "1881:         void SetHasRestParameter() { SetFlags(true, Flags_HasRestParameter); }",
          "1883:         virtual uint GetDisplayNameLength() const { return m_displayNameLength; }",
          "1884:         virtual uint GetShortDisplayNameOffset() const { return m_displayShortNameOffset; }",
          "1885:         bool GetIsDeclaration() const { return m_isDeclaration; }",
          "1886:         void SetIsDeclaration(const bool is) { m_isDeclaration = is; }",
          "1887:         bool GetIsAccessor() const { return m_isAccessor; }",
          "1888:         void SetIsAccessor(const bool is) { m_isAccessor = is; }",
          "1889:         bool GetIsGlobalFunc() const { return m_isGlobalFunc; }",
          "1890:         void SetIsStaticNameFunction(const bool is) { m_isStaticNameFunction = is; }",
          "1891:         bool GetIsStaticNameFunction() const { return m_isStaticNameFunction; }",
          "1892:         void SetIsNamedFunctionExpression(const bool is) { m_isNamedFunctionExpression = is; }",
          "1893:         bool GetIsNamedFunctionExpression() const { return m_isNamedFunctionExpression; }",
          "1894:         void SetIsNameIdentifierRef (const bool is) { m_isNameIdentifierRef  = is; }",
          "1895:         bool GetIsNameIdentifierRef () const { return m_isNameIdentifierRef ; }",
          "1900:         bool IsFakeGlobalFunc(uint32 flags) const;",
          "1902:         void SetIsGlobalFunc(bool is) { m_isGlobalFunc = is; }",
          "1903:         bool GetIsStrictMode() const { return m_isStrictMode; }",
          "1904:         void SetIsStrictMode() { m_isStrictMode = true; }",
          "1905:         bool GetIsAsmjsMode() const { return m_isAsmjsMode; }",
          "1906:         void SetIsAsmjsMode(bool value)",
          "1907:         {",
          "1908:             m_isAsmjsMode = value;",
          "1909:     #if DBG",
          "1910:             if (value)",
          "1911:             {",
          "1912:                 m_wasEverAsmjsMode = true;",
          "1913:             }",
          "1914:     #endif",
          "1915:         }",
          "1917:         void SetIsWasmFunction(bool val)",
          "1918:         {",
          "1919:             m_isWasmFunction = val;",
          "1920:         }",
          "1921:         bool IsWasmFunction() const",
          "1922:         {",
          "1923:             return m_isWasmFunction;",
          "1924:         }",
          "1926:         bool GetHasImplicitArgIns() { return m_hasImplicitArgIns; }",
          "1927:         void SetHasImplicitArgIns(bool has) { m_hasImplicitArgIns = has; }",
          "1928:         uint32 GetGrfscr() const;",
          "1929:         void SetGrfscr(uint32 grfscr);",
          "1944:         ArgSlot GetInParamsCount() const { return m_inParamCount; }",
          "1946:         void SetInParamsCount(ArgSlot newInParamCount);",
          "1947:         ArgSlot GetReportedInParamsCount() const;",
          "1948:         void SetReportedInParamsCount(ArgSlot newReportedInParamCount);",
          "1949:         void ResetInParams();",
          "1950:         ScopeInfo* GetScopeInfo() const { return static_cast<ScopeInfo*>(this->GetAuxPtr(AuxPointerType::ScopeInfo)); }",
          "1951:         void SetScopeInfo(ScopeInfo* scopeInfo) {  this->SetAuxPtr(AuxPointerType::ScopeInfo, scopeInfo); }",
          "1952:         PropertyId GetOrAddPropertyIdTracked(JsUtil::CharacterBuffer<WCHAR> const& propName);",
          "1953:         bool IsTrackedPropertyId(PropertyId pid);",
          "1954:         Js::PropertyRecordList* GetBoundPropertyRecords() { return this->m_boundPropertyRecords; }",
          "1955:         void SetBoundPropertyRecords(Js::PropertyRecordList* boundPropertyRecords)",
          "1956:         {",
          "1957:             Assert(this->m_boundPropertyRecords == nullptr);",
          "1958:             this->m_boundPropertyRecords = boundPropertyRecords;",
          "1959:         }",
          "1960:         void ClearBoundPropertyRecords()",
          "1961:         {",
          "1962:             this->m_boundPropertyRecords = nullptr;",
          "1963:         }",
          "1965:         void SetInitialDefaultEntryPoint();",
          "1966:         void SetDeferredParsingEntryPoint();",
          "1968:         void SetEntryPoint(ProxyEntryPointInfo* entryPoint, Js::JavascriptMethod jsMethod) {",
          "1969:             entryPoint->jsMethod = jsMethod;",
          "1970:         }",
          "1972:         bool IsDynamicScript() const;",
          "1974:         uint LengthInBytes() const { return m_cbLength; }",
          "1975:         uint StartOffset() const;",
          "1976:         ULONG GetLineNumber() const;",
          "1977:         ULONG GetColumnNumber() const;",
          "1978:         template <class T>",
          "1979:         LPCWSTR GetSourceName(const T& sourceContextInfo) const;",
          "1980:         template <class T>",
          "1981:         static LPCWSTR GetSourceName(const T& sourceContextInfo, bool m_isEval, bool m_isDynamicFunction);",
          "1982:         LPCWSTR GetSourceName() const;",
          "1983:         ULONG GetRelativeLineNumber() const { return m_lineNumber; }",
          "1984:         ULONG GetRelativeColumnNumber() const { return m_columnNumber; }",
          "1985:         uint GetSourceIndex() const;",
          "1986:         LPCUTF8 GetSource(const  char16* reason = nullptr) const;",
          "1987:         charcount_t LengthInChars() const { return m_cchLength; }",
          "1988:         charcount_t StartInDocument() const;",
          "1989:         bool IsEval() const { return m_isEval; }",
          "1990:         bool IsDynamicFunction() const;",
          "1991:         bool GetDontInline() { return m_dontInline; }",
          "1992:         void SetDontInline(bool is) { m_dontInline = is; }",
          "1993:         LPCUTF8 GetStartOfDocument(const char16* reason = nullptr) const;",
          "1994:         bool IsReparsed() const { return m_reparsed; }",
          "1995:         void SetReparsed(bool set) { m_reparsed = set; }",
          "1996:         bool GetExternalDisplaySourceName(BSTR* sourceName);",
          "1998:         bool EndsAfter(size_t offset) const;",
          "2000:         void SetDoBackendArgumentsOptimization(bool set)",
          "2001:         {",
          "2002:             m_doBackendArgumentsOptimization = set;",
          "2003:         }",
          "2005:         bool GetDoBackendArgumentsOptimization()",
          "2006:         {",
          "2007:             return m_doBackendArgumentsOptimization;",
          "2008:         }",
          "2010:         void SetDoScopeObjectCreation(bool set)",
          "2011:         {",
          "2012:             m_doScopeObjectCreation = set;",
          "2013:         }",
          "2015:         bool GetDoScopeObjectCreation()",
          "2016:         {",
          "2017:             return m_doScopeObjectCreation;",
          "2018:         }",
          "2020:         void SetUsesArgumentsObject(bool set)",
          "2021:         {",
          "2022:             if (!m_usesArgumentsObject)",
          "2023:             {",
          "2024:                 m_usesArgumentsObject = set;",
          "2025:             }",
          "2026:         }",
          "2028:         bool GetUsesArgumentsObject()",
          "2029:         {",
          "2030:             return m_usesArgumentsObject;",
          "2031:         }",
          "2033:         bool IsFunctionParsed()",
          "2034:         {",
          "2035:             return !IsDeferredParseFunction() || m_hasBeenParsed;",
          "2036:         }",
          "2038:         void SetFunctionParsed(bool hasBeenParsed)",
          "2039:         {",
          "2040:             m_hasBeenParsed = hasBeenParsed;",
          "2041:         }",
          "2043:         void SetSourceInfo(uint sourceIndex, ParseNodePtr node, bool isEval, bool isDynamicFunction);",
          "2044:         void SetSourceInfo(uint sourceIndex);",
          "2045:         void Copy(ParseableFunctionInfo * other);",
          "2046:         void Copy(FunctionBody* other);",
          "2047:         void CopyNestedArray(ParseableFunctionInfo * other);",
          "2049:         const char16* GetExternalDisplayName() const;",
          "2055:         template <class T>",
          "2056:         static const char16* GetExternalDisplayName(const T* funcBody)",
          "2057:         {",
          "2058:             Assert(funcBody != nullptr);",
          "2059:             Assert(funcBody->GetDisplayName() != nullptr);",
          "2061:             return funcBody->GetDisplayName();",
          "2062:         }",
          "2064:         virtual const char16* GetDisplayName() const override;",
          "2065:         void SetDisplayName(const char16* displayName);",
          "2066:         virtual void SetDisplayName(const char16* displayName, uint displayNameLength, uint displayShortNameOffset, SetDisplayNameFlags flags = SetDisplayNameFlagsNone) override;",
          "2068:         virtual void Finalize(bool isShutdown) override;",
          "2070:         Var GetCachedSourceString() { return this->GetAuxPtr(AuxPointerType::CachedSourceString); }",
          "2071:         void SetCachedSourceString(Var sourceString)",
          "2072:         {",
          "2073:             Assert(this->GetCachedSourceString() == nullptr);",
          "2074:             this->SetAuxPtr(AuxPointerType::CachedSourceString, sourceString);",
          "2075:         }",
          "2077:         FunctionInfoArray GetNestedFuncArray();",
          "2078:         FunctionInfo* GetNestedFunc(uint index);",
          "2079:         FunctionInfoPtrPtr GetNestedFuncReference(uint index);",
          "2080:         FunctionProxy* GetNestedFunctionProxy(uint index);",
          "2081:         ParseableFunctionInfo* GetNestedFunctionForExecution(uint index);",
          "2082:         void SetNestedFunc(FunctionInfo* nestedFunc, uint index, uint32 flags);",
          "2083:         void BuildDeferredStubs(ParseNode *pnodeFnc);",
          "2084:         DeferredFunctionStub *GetDeferredStubs() const { return static_cast<DeferredFunctionStub *>(this->GetAuxPtr(AuxPointerType::DeferredStubs)); }",
          "2085:         void SetDeferredStubs(DeferredFunctionStub *stub) { this->SetAuxPtr(AuxPointerType::DeferredStubs, stub); }",
          "2086:         void RegisterFuncToDiag(ScriptContext * scriptContext, char16 const * pszTitle);",
          "2088:     protected:",
          "2089:         static HRESULT MapDeferredReparseError(HRESULT& hrParse, const CompileScriptException& se);",
          "2091:         void SetFlags(bool does, FunctionBodyFlags newFlags)",
          "2092:         {",
          "2093:             if (does)",
          "2094:             {",
          "2095:                 flags = (FunctionBodyFlags)(flags | newFlags);",
          "2096:             }",
          "2097:             else",
          "2098:             {",
          "2099:                 flags = (FunctionBodyFlags)(flags & ~newFlags);",
          "2100:             }",
          "2101:         }",
          "2103:         FieldWithBarrier(bool) m_tag21 : 1;",
          "2104:         FieldWithBarrier(bool) m_hasBeenParsed : 1;       // Has function body been parsed- true for actual function bodies, false for deferparse",
          "2105:         FieldWithBarrier(bool) m_isDeclaration : 1;",
          "2106:         FieldWithBarrier(bool) m_isAccessor : 1;          // Function is a property getter or setter",
          "2107:         FieldWithBarrier(bool) m_isStaticNameFunction : 1;",
          "2108:         FieldWithBarrier(bool) m_isNamedFunctionExpression : 1;",
          "2109:         FieldWithBarrier(bool) m_isNameIdentifierRef  : 1;",
          "2110:         FieldWithBarrier(bool) m_isClassMember : 1;",
          "2113:         FieldWithBarrier(bool) m_isStrictMode : 1;",
          "2114:         FieldWithBarrier(bool) m_isAsmjsMode : 1;",
          "2115:         FieldWithBarrier(bool) m_isAsmJsFunction : 1;",
          "2116:         FieldWithBarrier(bool) m_isWasmFunction : 1;",
          "2117:         FieldWithBarrier(bool) m_isGlobalFunc : 1;",
          "2118:         FieldWithBarrier(bool) m_doBackendArgumentsOptimization : 1;",
          "2119:         FieldWithBarrier(bool) m_doScopeObjectCreation : 1;",
          "2120:         FieldWithBarrier(bool) m_usesArgumentsObject : 1;",
          "2123:         FieldWithBarrier(bool) m_isEval : 1;              // Source code is in 'eval'",
          "2124:         FieldWithBarrier(bool) m_isDynamicFunction : 1;   // Source code is in 'Function'",
          "2125:         FieldWithBarrier(bool) m_hasImplicitArgIns : 1;",
          "2126:         FieldWithBarrier(bool) m_dontInline : 1;            // Used by the JIT's inliner",
          "2129:         FieldWithBarrier(bool) m_reparsed : 1;",
          "2135:         FieldWithBarrier(bool) m_utf8SourceHasBeenSet;          // start of UTF8-encoded source",
          "2136:         FieldWithBarrier(uint) m_sourceIndex;             // index into the scriptContext's list of saved sources",
          "2137: #if DYNAMIC_INTERPRETER_THUNK",
          "2138:         FieldNoBarrier(void*) m_dynamicInterpreterThunk;  // Unique 'thunk' for every interpreted function - used for ETW symbol decoding.",
          "2139: #endif",
          "2140:         FieldWithBarrier(uint) m_cbStartOffset;         // pUtf8Source is this many bytes from the start of the scriptContext's source buffer.",
          "2144: #define DEFINE_PARSEABLE_FUNCTION_INFO_FIELDS 1",
          "2145: #define DECLARE_TAG_FIELD(type, name, serializableType) Field(type) name",
          "2146: #define CURRENT_ACCESS_MODIFIER protected:",
          "2147: #include \"SerializableFunctionFields.h\"",
          "2149:         FieldWithBarrier(ULONG) m_lineNumber;",
          "2150:         FieldWithBarrier(ULONG) m_columnNumber;",
          "2151:         FieldWithBarrier(const char16*) m_displayName;  // Optional name",
          "2152:         FieldWithBarrier(uint) m_displayNameLength;",
          "2153:         FieldWithBarrier(PropertyRecordList*) m_boundPropertyRecords;",
          "2154:         FieldWithBarrier(NestedArray*) nestedArray;",
          "2156:     public:",
          "2157: #if DBG",
          "2158:         FieldWithBarrier(bool) m_wasEverAsmjsMode; // has m_isAsmjsMode ever been true",
          "2159:         FieldWithBarrier(Js::LocalFunctionId) deferredParseNextFunctionId;",
          "2160: #endif",
          "2161: #if DBG",
          "2162:         FieldWithBarrier(UINT) scopeObjectSize; // If the scope is an activation object - its size",
          "2163: #endif",
          "2164:     };",
          "2170:     template <class T>",
          "2171:     LPCWSTR ParseableFunctionInfo::GetSourceName(const T& sourceContextInfo) const",
          "2172:     {",
          "2173:         return GetSourceName<T>(sourceContextInfo, this->m_isEval, this->m_isDynamicFunction);",
          "2174:     }",
          "2176:     template <class T>",
          "2177:     LPCWSTR ParseableFunctionInfo::GetSourceName(const T& sourceContextInfo, bool m_isEval, bool m_isDynamicFunction)",
          "2178:     {",
          "2179:         if (sourceContextInfo->IsDynamic())",
          "2180:         {",
          "2181:             if (m_isEval)",
          "2182:             {",
          "2183:                 return Constants::EvalCode;",
          "2184:             }",
          "2185:             else if (m_isDynamicFunction)",
          "2186:             {",
          "2187:                 return Constants::FunctionCode;",
          "2188:             }",
          "2189:             else",
          "2190:             {",
          "2191:                 return Constants::UnknownScriptCode;",
          "2192:             }",
          "2193:         }",
          "2194:         else",
          "2195:         {",
          "2196:             return sourceContextInfo->url;",
          "2197:         }",
          "2198:     }",
          "2200:     class FunctionBody : public ParseableFunctionInfo",
          "2201:     {",
          "2202:         DEFINE_VTABLE_CTOR_NO_REGISTER(FunctionBody, ParseableFunctionInfo);",
          "2204:         friend class ByteCodeBufferBuilder;",
          "2205:         friend class ByteCodeBufferReader;",
          "2206: #ifdef DYNAMIC_PROFILE_MUTATOR",
          "2207:         friend class ::DynamicProfileMutator;",
          "2208:         friend class ::DynamicProfileMutatorImpl;",
          "2209: #endif",
          "2210:         friend class RemoteFunctionBody;",
          "2212:         public:",
          "2214:             static const uint DIAGLOCALSLOTSIZE = 8;",
          "2216:             enum class CounterFields : uint8",
          "2217:             {",
          "2218:                 VarCount                                = 0,",
          "2219:                 ConstantCount                           = 1,",
          "2220:                 OutParamMaxDepth                        = 2,",
          "2221:                 ByteCodeCount                           = 3,",
          "2222:                 ByteCodeWithoutLDACount                 = 4,",
          "2223:                 ByteCodeInLoopCount                     = 5,",
          "2224:                 LoopCount                               = 6,",
          "2225:                 ForInLoopDepth                          = 7,",
          "2226:                 ProfiledForInLoopCount                  = 8,",
          "2227:                 InlineCacheCount                        = 9,",
          "2228:                 RootObjectLoadInlineCacheStart          = 10,",
          "2229:                 RootObjectLoadMethodInlineCacheStart    = 11,",
          "2230:                 RootObjectStoreInlineCacheStart         = 12,",
          "2231:                 IsInstInlineCacheCount                  = 13,",
          "2232:                 ReferencedPropertyIdCount               = 14,",
          "2233:                 ObjLiteralCount                         = 15,",
          "2234:                 LiteralRegexCount                       = 16,",
          "2235:                 InnerScopeCount                         = 17,",
          "2238:                 LocalClosureRegister                    = 18,",
          "2239:                 ParamClosureRegister                    = 19,",
          "2240:                 LocalFrameDisplayRegister               = 20,",
          "2241:                 EnvRegister                             = 21,",
          "2242:                 ThisRegisterForEventHandler             = 22,",
          "2243:                 FirstInnerScopeRegister                 = 23,",
          "2244:                 FuncExprScopeRegister                   = 24,",
          "2245:                 FirstTmpRegister                        = 25,",
          "2247:                 Max",
          "2248:             };",
          "2250:             typedef CompactCounters<FunctionBody> CounterT;",
          "2251:             FieldWithBarrier(CounterT) counters;",
          "2253:             uint32 GetCountField(FunctionBody::CounterFields fieldEnum) const",
          "2254:             {",
          "2255:                 return counters.Get(fieldEnum);",
          "2256:             }",
          "2257:             uint32 SetCountField(FunctionBody::CounterFields fieldEnum, uint32 val)",
          "2258:             {",
          "2259:                 return counters.Set(fieldEnum, val, this);",
          "2260:             }",
          "2261:             uint32 IncreaseCountField(FunctionBody::CounterFields fieldEnum)",
          "2262:             {",
          "2263:                 return counters.Increase(fieldEnum, this);",
          "2264:             }",
          "2266:             struct StatementMap",
          "2267:             {",
          "2268:                 StatementMap() : isSubexpression(false) {}",
          "2270:                 static StatementMap * New(Recycler* recycler)",
          "2271:                 {",
          "2272:                     return RecyclerNew(recycler, StatementMap);",
          "2273:                 }",
          "2275:                 FieldWithBarrier(regex::Interval) sourceSpan;",
          "2276:                 FieldWithBarrier(regex::Interval) byteCodeSpan;",
          "2277:                 FieldWithBarrier(bool) isSubexpression;",
          "2278:             };",
          "2282:             enum StatementAdjustmentType : ushort",
          "2283:             {",
          "2284:                 SAT_None = 0,",
          "2291:                 SAT_FromCurrentToNext = 0x01,",
          "2296:                 SAT_NextStatementStart = 0x02,",
          "2298:                 SAT_All = SAT_FromCurrentToNext | SAT_NextStatementStart",
          "2299:             };",
          "2301:             class StatementAdjustmentRecord",
          "2302:             {",
          "2303:                 uint m_byteCodeOffset;",
          "2304:                 StatementAdjustmentType m_adjustmentType;",
          "2305:             public:",
          "2306:                 StatementAdjustmentRecord();",
          "2307:                 StatementAdjustmentRecord(StatementAdjustmentType type, int byteCodeOffset);",
          "2308:                 StatementAdjustmentRecord(const StatementAdjustmentRecord& other);",
          "2309:                 uint GetByteCodeOffset();",
          "2310:                 StatementAdjustmentType GetAdjustmentType();",
          "2311:             };",
          "2315:             class CrossFrameEntryExitRecord",
          "2316:             {",
          "2317:                 uint m_byteCodeOffset;",
          "2319:                 bool m_isEnterBlock;",
          "2320:             public:",
          "2321:                 CrossFrameEntryExitRecord();",
          "2322:                 CrossFrameEntryExitRecord(uint byteCodeOffset, bool isEnterBlock);",
          "2323:                 CrossFrameEntryExitRecord(const CrossFrameEntryExitRecord& other);",
          "2324:                 uint GetByteCodeOffset() const;",
          "2325:                 bool GetIsEnterBlock();",
          "2326:             };",
          "2328:             typedef JsUtil::List<Js::FunctionBody::StatementMap*, ArenaAllocator> ArenaStatementMapList;",
          "2329:             typedef JsUtil::List<Js::FunctionBody::StatementMap*> StatementMapList;",
          "2332:             typedef JsUtil::List<StatementAdjustmentRecord, Recycler, /* isLeaf = */ true> StatementAdjustmentRecordList;",
          "2333:             typedef JsUtil::List<CrossFrameEntryExitRecord, Recycler, /* isLeaf = */ true> CrossFrameEntryExitRecordList;",
          "2337:             struct AuxStatementData",
          "2338:             {",
          "2341:                 Field(StatementAdjustmentRecordList*) m_statementAdjustmentRecords;",
          "2344:                 Field(CrossFrameEntryExitRecordList*) m_crossFrameBlockEntryExisRecords;",
          "2346:                 AuxStatementData();",
          "2347:             };",
          "2349:             class SourceInfo",
          "2350:             {",
          "2351:                 friend class RemoteFunctionBody;",
          "2352:                 friend class ByteCodeBufferReader;",
          "2353:                 friend class ByteCodeBufferBuilder;",
          "2355:             public:",
          "2356:                 FieldNoBarrier(SmallSpanSequence*) pSpanSequence;",
          "2358:                 FieldWithBarrier(RegSlot)         frameDisplayRegister;   // this register slot cannot be 0 so we use that sentinel value to indicate invalid",
          "2359:                 FieldWithBarrier(RegSlot)         objectRegister;         // this register slot cannot be 0 so we use that sentinel value to indicate invalid",
          "2360:                 FieldWithBarrier(ScopeObjectChain*) pScopeObjectChain;",
          "2361:                 FieldWithBarrier(ByteBlock*) m_probeBackingBlock;  // NULL if no Probes, otherwise a copy of the unmodified the byte-codeblock //Delay",
          "2362:                 FieldWithBarrier(int32) m_probeCount;             // The number of installed probes (such as breakpoints).",
          "2365:                 FieldWithBarrier(AuxStatementData*) m_auxStatementData;",
          "2367:                 SourceInfo():",
          "2368:                     frameDisplayRegister(0),",
          "2369:                     objectRegister(0),",
          "2370:                     pScopeObjectChain(nullptr),",
          "2371:                     m_probeBackingBlock(nullptr),",
          "2372:                     m_probeCount(0),",
          "2373:                     m_auxStatementData(nullptr),",
          "2374:                     pSpanSequence(nullptr)",
          "2375:                 {",
          "2376:                 }",
          "2377:             };",
          "2379:     private:",
          "2380:         FieldWithBarrier(ByteBlock*) byteCodeBlock;                // Function byte-code for script functions",
          "2381:         FieldWithBarrier(FunctionEntryPointList*) entryPoints;",
          "2382:         FieldWithBarrier(Field(Var)*) m_constTable;",
          "2383:         FieldWithBarrier(void**) inlineCaches;",
          "2384:         FieldWithBarrier(InlineCachePointerArray<PolymorphicInlineCache>) polymorphicInlineCaches; // Contains the latest polymorphic inline caches",
          "2385:         FieldWithBarrier(PropertyId*) cacheIdToPropertyIdMap;",
          "2387: #if DBG",
          "2388: #define InlineCacheTypeNone         0x00",
          "2389: #define InlineCacheTypeInlineCache  0x01",
          "2390: #define InlineCacheTypeIsInst       0x02",
          "2391:             FieldWithBarrier(byte*) m_inlineCacheTypes;",
          "2392: #endif",
          "2393:     public:",
          "2394:         PropertyId * GetCacheIdToPropertyIdMap()",
          "2395:         {",
          "2396:             return cacheIdToPropertyIdMap;",
          "2397:         }",
          "2398:         static DWORD GetAsmJsTotalLoopCountOffset() { return offsetof(FunctionBody, m_asmJsTotalLoopCount); }",
          "2399: #if DBG",
          "2400:         FieldWithBarrier(int) m_DEBUG_executionCount;     // Count of outstanding on InterpreterStackFrame",
          "2401:         FieldWithBarrier(bool) m_nativeEntryPointIsInterpreterThunk; // NativeEntry entry point is in fact InterpreterThunk.",
          "2403: #endif",
          "2406:         FieldWithBarrier(uint) regAllocStoreCount;",
          "2407:         FieldWithBarrier(uint) regAllocLoadCount;",
          "2408:         FieldWithBarrier(uint) callCountStats;",
          "2416:         FieldWithBarrier(SourceInfo) m_sourceInfo; // position of the source",
          "2419:         FieldWithBarrier(uint) m_uScriptId; // Delay //Script Block it belongs to. This is function no. of the global function created by engine for each block",
          "2420: #if DBG",
          "2421:         FieldWithBarrier(int) m_iProfileSession; // Script profile session the meta data of this function is reported to.",
          "2422: #endif // DEBUG",
          "2425:         static const RegSlot ReturnValueRegSlot = 0;",
          "2426:         static const RegSlot RootObjectRegSlot = 1;",
          "2427:         static const RegSlot FirstRegSlot = 1;",
          "2429:         static const int LocalsChangeDirtyValue = 1;",
          "2431: #define DEFINE_FUNCTION_BODY_FIELDS 1",
          "2432: #define DECLARE_TAG_FIELD(type, name, serializableType) Field(type) name",
          "2433: #define CURRENT_ACCESS_MODIFIER public:",
          "2434: #include \"SerializableFunctionFields.h\"",
          "2436:     private:",
          "2437:         FieldWithBarrier(uint) inactiveCount;",
          "2440:         FieldWithBarrier(bool) m_tag32 : 1;",
          "2441:         FieldWithBarrier(bool) m_nativeEntryPointUsed : 1;    // Code might have been generated but not yet used.",
          "2442:         FieldWithBarrier(bool) hasDoneLoopBodyCodeGen : 1;    // Code generated for loop body, but not necessary available to execute yet.",
          "2443:         FieldWithBarrier(bool) m_isFuncRegistered : 1;",
          "2444:         FieldWithBarrier(bool) m_isFuncRegisteredToDiag : 1; // Mentions the function's context is registered with diagprobe.",
          "2445:         FieldWithBarrier(bool) funcEscapes : 1;",
          "2446:         FieldWithBarrier(bool) m_hasBailoutInstrInJittedCode : 1; // Indicates whether function has bailout instructions. Valid only if hasDoneCodeGen is true",
          "2447:         FieldWithBarrier(bool) m_pendingLoopHeaderRelease : 1; // Indicates whether loop headers need to be released",
          "2450:         FieldWithBarrier(bool) hasExecutionDynamicProfileInfo : 1;",
          "2451:         FieldWithBarrier(bool) cleanedUp: 1;",
          "2452:         FieldWithBarrier(bool) sourceInfoCleanedUp: 1;",
          "2453:         FieldWithBarrier(bool) dontRethunkAfterBailout : 1;",
          "2454:         FieldWithBarrier(bool) disableInlineApply : 1;",
          "2455:         FieldWithBarrier(bool) disableInlineSpread : 1;",
          "2456:         FieldWithBarrier(bool) hasHotLoop: 1;",
          "2457:         FieldWithBarrier(bool) wasCalledFromLoop : 1;",
          "2460:         FieldWithBarrier(bool) hasNestedLoop : 1;",
          "2461:         FieldWithBarrier(bool) recentlyBailedOutOfJittedLoopBody : 1;",
          "2462:         FieldWithBarrier(bool) m_firstFunctionObject: 1;",
          "2463:         FieldWithBarrier(bool) m_inlineCachesOnFunctionObject: 1;",
          "2466:         FieldWithBarrier(bool) m_hasSetIsObject : 1;",
          "2469:         FieldWithBarrier(bool) m_hasAllNonLocalReferenced : 1;",
          "2470:         FieldWithBarrier(bool) m_hasFunExprNameReference : 1;",
          "2471:         FieldWithBarrier(bool) m_ChildCallsEval : 1;",
          "2474:         FieldWithBarrier(bool) m_CallsEval : 1;",
          "2475:         FieldWithBarrier(bool) m_hasReferenceableBuiltInArguments : 1;",
          "2476:         FieldWithBarrier(bool) m_isParamAndBodyScopeMerged : 1;",
          "2478:         FieldWithBarrier(bool) m_hasDoneAllNonLocalReferenced : 1;",
          "2480:         FieldWithBarrier(bool) m_hasFunctionCompiledSent : 1;",
          "2481:         FieldWithBarrier(bool) m_isFromNativeCodeModule : 1;",
          "2482:         FieldWithBarrier(bool) m_isPartialDeserializedFunction : 1;",
          "2483:         FieldWithBarrier(bool) m_isAsmJsScheduledForFullJIT : 1;",
          "2486:         FieldWithBarrier(bool) m_tag33 : 1;",
          "2487:         FieldWithBarrier(bool) m_hasLocalClosureRegister : 1;",
          "2488:         FieldWithBarrier(bool) m_hasParamClosureRegister : 1;",
          "2489:         FieldWithBarrier(bool) m_hasLocalFrameDisplayRegister : 1;",
          "2490:         FieldWithBarrier(bool) m_hasEnvRegister : 1;",
          "2491:         FieldWithBarrier(bool) m_hasThisRegisterForEventHandler : 1;",
          "2492:         FieldWithBarrier(bool) m_hasFirstInnerScopeRegister : 1;",
          "2493:         FieldWithBarrier(bool) m_hasFuncExprScopeRegister : 1;",
          "2496:         FieldWithBarrier(bool) m_hasFirstTmpRegister : 1;",
          "2497:         FieldWithBarrier(bool) m_hasActiveReference : 1;",
          "2498: #if DBG",
          "2499:         FieldWithBarrier(bool) m_isSerialized : 1;",
          "2500: #endif",
          "2501: #ifdef PERF_COUNTERS",
          "2502:         FieldWithBarrier(bool) m_isDeserializedFunction : 1;",
          "2503: #endif",
          "2504: #if DBG",
          "2506:         FieldWithBarrier(bool) m_canDoStackNestedFunc : 1;",
          "2507: #endif",
          "2509: #if DBG",
          "2510:         FieldWithBarrier(bool) initializedExecutionModeAndLimits : 1;",
          "2511: #endif",
          "2513: #ifdef IR_VIEWER",
          "2515:         FieldWithBarrier(bool) m_isIRDumpEnabled : 1;",
          "2516:         FieldWithBarrier(Js::DynamicObject*) m_irDumpBaseObject;",
          "2519:         FieldWithBarrier(uint8) bailOnMisingProfileCount;",
          "2520:         FieldWithBarrier(uint8) bailOnMisingProfileRejitCount;",
          "2522:         FieldWithBarrier(byte) inlineDepth; // Used by inlining to avoid recursively inlining functions excessively",
          "2524:         FieldWithBarrier(ExecutionMode) executionMode;",
          "2525:         FieldWithBarrier(uint16) interpreterLimit;",
          "2526:         FieldWithBarrier(uint16) autoProfilingInterpreter0Limit;",
          "2527:         FieldWithBarrier(uint16) profilingInterpreter0Limit;",
          "2528:         FieldWithBarrier(uint16) autoProfilingInterpreter1Limit;",
          "2529:         FieldWithBarrier(uint16) simpleJitLimit;",
          "2530:         FieldWithBarrier(uint16) profilingInterpreter1Limit;",
          "2531:         FieldWithBarrier(uint16) fullJitThreshold;",
          "2532:         FieldWithBarrier(uint16) fullJitRequeueThreshold;",
          "2533:         FieldWithBarrier(uint16) committedProfiledIterations;",
          "2535:         FieldWithBarrier(uint) m_depth; // Indicates how many times the function has been entered (so increases by one on each recursive call, decreases by one when we're done)",
          "2537:         FieldWithBarrier(uint32) interpretedCount;",
          "2538:         FieldWithBarrier(uint32) lastInterpretedCount;",
          "2539:         FieldWithBarrier(uint32) loopInterpreterLimit;",
          "2540:         FieldWithBarrier(uint32) debuggerScopeIndex;",
          "2541:         FieldWithBarrier(uint32) savedPolymorphicCacheState;",
          "2549:         FieldNoBarrier(Js::ByteCodeCache*) byteCodeCache;   // Not GC allocated so naked pointer",
          "2550: #ifdef ENABLE_DEBUG_CONFIG_OPTIONS",
          "2551:         static bool shareInlineCaches;",
          "2552: #endif",
          "2553:         FieldWithBarrier(FunctionEntryPointInfo*) defaultFunctionEntryPointInfo;",
          "2555: #if ENABLE_PROFILE_INFO",
          "2556:         FieldWithBarrier(DynamicProfileInfo*) dynamicProfileInfo;",
          "2557: #endif",
          "2562:         FieldWithBarrier(BYTE) savedInlinerVersion;",
          "2563: #if ENABLE_NATIVE_CODEGEN",
          "2564:         FieldWithBarrier(ImplicitCallFlags) savedImplicitCallsFlags;",
          "2565: #endif",
          "2567:         FunctionBody(ScriptContext* scriptContext, const char16* displayName, uint displayNameLength, uint displayShortNameOffset, uint nestedCount, Utf8SourceInfo* sourceInfo,",
          "2568:             uint uFunctionNumber, uint uScriptId, Js::LocalFunctionId functionId, Js::PropertyRecordList* propRecordList, FunctionInfo::Attributes attributes, FunctionBodyFlags flags",
          "2569: #ifdef PERF_COUNTERS",
          "2570:             , bool isDeserializedFunction = false",
          "2571: #endif",
          "2572:             );",
          "2574:         FunctionBody(ParseableFunctionInfo * parseableFunctionInfo);",
          "2576:         void SetNativeEntryPoint(FunctionEntryPointInfo* entryPointInfo, JavascriptMethod originalEntryPoint, JavascriptMethod directEntryPoint);",
          "2577: #if DYNAMIC_INTERPRETER_THUNK",
          "2578:         void GenerateDynamicInterpreterThunk();",
          "2579: #endif",
          "2580:         void CloneByteCodeInto(ScriptContext * scriptContext, FunctionBody *newFunctionBody, uint sourceIndex);",
          "2581:         Js::JavascriptMethod GetEntryPoint(ProxyEntryPointInfo* entryPoint) const { return entryPoint->jsMethod; }",
          "2582:         void CaptureDynamicProfileState(FunctionEntryPointInfo* entryPointInfo);",
          "2583: #if ENABLE_DEBUG_CONFIG_OPTIONS",
          "2584:         void DumpRegStats(FunctionBody *funcBody);",
          "2585: #endif",
          "2587:     public:",
          "2588:         FunctionBody(ByteCodeCache* cache, Utf8SourceInfo* sourceInfo, ScriptContext* scriptContext):",
          "2589:             ParseableFunctionInfo((JavascriptMethod) nullptr, 0, (LocalFunctionId) 0, sourceInfo, scriptContext, 0, nullptr, 0, 0, FunctionInfo::Attributes::None, nullptr, Flags_None)",
          "2590:         {",
          "2594:         }",
          "2596:         static FunctionBody * NewFromRecycler(Js::ScriptContext * scriptContext, const char16 * displayName, uint displayNameLength, uint displayShortNameOffset, uint nestedCount,",
          "2597:             Utf8SourceInfo* sourceInfo, uint uScriptId, Js::LocalFunctionId functionId, Js::PropertyRecordList* boundPropertyRecords, FunctionInfo::Attributes attributes",
          "2598:             , FunctionBodyFlags flags",
          "2599: #ifdef PERF_COUNTERS",
          "2600:             , bool isDeserializedFunction",
          "2601: #endif",
          "2602:             );",
          "2603:         static FunctionBody * NewFromRecycler(Js::ScriptContext * scriptContext, const char16 * displayName, uint displayNameLength, uint displayShortNameOffset, uint nestedCount,",
          "2604:             Utf8SourceInfo* sourceInfo, uint uFunctionNumber, uint uScriptId, Js::LocalFunctionId functionId, Js::PropertyRecordList* boundPropertyRecords, FunctionInfo::Attributes attributes",
          "2605:             , FunctionBodyFlags flags",
          "2606: #ifdef PERF_COUNTERS",
          "2607:             , bool isDeserializedFunction",
          "2608: #endif",
          "2609:             );",
          "2611:         static FunctionBody * NewFromParseableFunctionInfo(ParseableFunctionInfo * info, PropertyRecordList *boundPropertyRecords);",
          "2613:         FunctionEntryPointInfo * GetEntryPointInfo(int index) const;",
          "2614:         FunctionEntryPointInfo * TryGetEntryPointInfo(int index) const;",
          "2616:         bool DoRedeferFunction(uint inactiveThreshold) const;",
          "2617:         void RedeferFunction();",
          "2618:         bool IsActiveFunction(ActiveFunctionSet * pActiveFuncs) const;",
          "2619:         bool TestAndUpdateActiveFunctions(ActiveFunctionSet * pActiveFuncs) const;",
          "2620:         void UpdateActiveFunctionSet(ActiveFunctionSet * pActiveFuncs, FunctionCodeGenRuntimeData *callSiteData) const;",
          "2621:         void UpdateActiveFunctionsForOneDataSet(ActiveFunctionSet *pActiveFuncs, FunctionCodeGenRuntimeData *parentData, Field(FunctionCodeGenRuntimeData*)* dataSet, uint count) const;",
          "2622:         uint GetInactiveCount() const { return inactiveCount; }",
          "2623:         void SetInactiveCount(uint count) { inactiveCount = count; }",
          "2624:         void IncrInactiveCount(uint increment);",
          "2625:         bool InterpretedSinceCallCountCollection() const;",
          "2626:         void CollectInterpretedCounts();",
          "2627:         void ResetRedeferralAttributes() { this->m_hasActiveReference = false; }",
          "2629:         Js::RootObjectBase * LoadRootObject() const;",
          "2630:         Js::RootObjectBase * GetRootObject() const;",
          "2631:         ByteBlock* GetAuxiliaryData() const { return static_cast<ByteBlock*>(this->GetAuxPtr(AuxPointerType::AuxBlock)); }",
          "2632:         ByteBlock* GetAuxiliaryDataWithLock() const { return static_cast<ByteBlock*>(this->GetAuxPtrWithLock(AuxPointerType::AuxBlock)); }",
          "2633:         void SetAuxiliaryData(ByteBlock* auxBlock) { this->SetAuxPtr(AuxPointerType::AuxBlock, auxBlock); }",
          "2634:         ByteBlock* GetAuxiliaryContextData()const { return static_cast<ByteBlock*>(this->GetAuxPtr(AuxPointerType::AuxContextBlock)); }",
          "2635:         ByteBlock* GetAuxiliaryContextDataWithLock()const { return static_cast<ByteBlock*>(this->GetAuxPtrWithLock(AuxPointerType::AuxContextBlock)); }",
          "2636:         void SetAuxiliaryContextData(ByteBlock* auxContextBlock) { this->SetAuxPtr(AuxPointerType::AuxContextBlock, auxContextBlock); }",
          "2637:         void SetFormalsPropIdArray(PropertyIdArray * propIdArray);",
          "2638:         PropertyIdArray* GetFormalsPropIdArray(bool checkForNull = true);",
          "2639:         Var GetFormalsPropIdArrayOrNullObj();",
          "2640:         ByteBlock* GetByteCode() const;",
          "2641:         ByteBlock* GetOriginalByteCode(); // Returns original bytecode without probes (such as BPs).",
          "2642:         Js::ByteCodeCache * GetByteCodeCache() const { return this->byteCodeCache; }",
          "2643:         void SetByteCodeCache(Js::ByteCodeCache *byteCodeCache)",
          "2644:         {",
          "2645:             if (byteCodeCache != nullptr)",
          "2646:             {",
          "2647:                 this->byteCodeCache = byteCodeCache;",
          "2648:             }",
          "2649:         }",
          "2650: #if DBG",
          "2651:         void SetIsSerialized(bool serialized) { m_isSerialized = serialized; }",
          "2652:         bool GetIsSerialized()const { return m_isSerialized; }",
          "2653: #endif",
          "2654:         uint GetByteCodeCount() const { return GetCountField(CounterFields::ByteCodeCount); }",
          "2655:         void SetByteCodeCount(uint count) { SetCountField(CounterFields::ByteCodeCount, count); }",
          "2656:         uint GetByteCodeWithoutLDACount() const { return GetCountField(CounterFields::ByteCodeWithoutLDACount); }",
          "2657:         void SetByteCodeWithoutLDACount(uint count) { SetCountField(CounterFields::ByteCodeWithoutLDACount, count); }",
          "2658:         uint GetByteCodeInLoopCount() const { return GetCountField(CounterFields::ByteCodeInLoopCount); }",
          "2659:         void SetByteCodeInLoopCount(uint count) { SetCountField(CounterFields::ByteCodeInLoopCount, count); }",
          "2660:         uint16 GetEnvDepth() const { return m_envDepth; }",
          "2661:         void SetEnvDepth(uint16 depth) { m_envDepth = depth; }",
          "2663:         void SetEnvRegister(RegSlot reg);",
          "2664:         void MapAndSetEnvRegister(RegSlot reg);",
          "2665:         RegSlot GetEnvRegister() const;",
          "2666:         void SetThisRegisterForEventHandler(RegSlot reg);",
          "2667:         void MapAndSetThisRegisterForEventHandler(RegSlot reg);",
          "2668:         RegSlot GetThisRegisterForEventHandler() const;",
          "2670:         void SetLocalClosureRegister(RegSlot reg);",
          "2671:         void MapAndSetLocalClosureRegister(RegSlot reg);",
          "2672:         RegSlot GetLocalClosureRegister() const;",
          "2673:         void SetParamClosureRegister(RegSlot reg);",
          "2674:         void MapAndSetParamClosureRegister(RegSlot reg);",
          "2675:         RegSlot GetParamClosureRegister() const;",
          "2677:         void SetLocalFrameDisplayRegister(RegSlot reg);",
          "2678:         void MapAndSetLocalFrameDisplayRegister(RegSlot reg);",
          "2679:         RegSlot GetLocalFrameDisplayRegister() const;",
          "2680:         void SetFirstInnerScopeRegister(RegSlot reg);",
          "2681:         void MapAndSetFirstInnerScopeRegister(RegSlot reg);",
          "2682:         RegSlot GetFirstInnerScopeRegister() const;",
          "2683:         void SetFuncExprScopeRegister(RegSlot reg);",
          "2684:         void MapAndSetFuncExprScopeRegister(RegSlot reg);",
          "2685:         RegSlot GetFuncExprScopeRegister() const;",
          "2687:         bool HasScopeObject() const { return hasScopeObject; }",
          "2688:         void SetHasScopeObject(bool has) { hasScopeObject = has; }",
          "2689:         uint GetInnerScopeCount() const { return GetCountField(CounterFields::InnerScopeCount); }",
          "2690:         void SetInnerScopeCount(uint count) { SetCountField(CounterFields::InnerScopeCount, count); }",
          "2691:         bool HasCachedScopePropIds() const { return hasCachedScopePropIds; }",
          "2692:         void SetHasCachedScopePropIds(bool has) { hasCachedScopePropIds = has; }",
          "2694:         uint32 GetInterpretedCount() const { return interpretedCount; }",
          "2695:         uint32 SetInterpretedCount(uint32 val) { return interpretedCount = val; }",
          "2696:         uint32 IncreaseInterpretedCount() { return interpretedCount++; }",
          "2698:         uint32 GetLoopInterpreterLimit() const { return loopInterpreterLimit; }",
          "2699:         uint32 SetLoopInterpreterLimit(uint32 val) { return loopInterpreterLimit = val; }",
          "2702:         uint32 GetNextDebuggerScopeIndex() { return debuggerScopeIndex++; }",
          "2703:         void SetDebuggerScopeIndex(uint32 index) { debuggerScopeIndex = index; }",
          "2705:         size_t GetLoopBodyName(uint loopNumber, _Out_writes_opt_z_(sizeInChars) WCHAR* displayName, _In_ size_t sizeInChars);",
          "2707:         void AllocateLoopHeaders();",
          "2708:         void ReleaseLoopHeaders();",
          "2709:         Js::LoopHeader * GetLoopHeader(uint index) const;",
          "2710:         Js::LoopHeader * GetLoopHeaderWithLock(uint index) const;",
          "2711:         Js::Var GetLoopHeaderArrayPtr() const",
          "2712:         {",
          "2713:             Assert(this->GetLoopHeaderArray() != nullptr);",
          "2714:             return this->GetLoopHeaderArray();",
          "2715:         }",
          "2716: #ifdef ASMJS_PLAT",
          "2717:         void SetIsAsmJsFullJitScheduled(bool val){ m_isAsmJsScheduledForFullJIT = val; }",
          "2718:         bool GetIsAsmJsFullJitScheduled(){ return m_isAsmJsScheduledForFullJIT; }",
          "2719:         uint32 GetAsmJSTotalLoopCount() const",
          "2720:         {",
          "2721:             return m_asmJsTotalLoopCount;",
          "2722:         }",
          "2724:         void SetIsAsmJsFunction(bool isAsmJsFunction)",
          "2725:         {",
          "2726:             m_isAsmJsFunction = isAsmJsFunction;",
          "2727:         }",
          "2728: #endif",
          "2730:         const bool GetIsAsmJsFunction() const",
          "2731:         {",
          "2732:             return m_isAsmJsFunction;",
          "2733:         }",
          "2735: #ifdef ASMJS_PLAT",
          "2736:         bool IsHotAsmJsLoop()",
          "2737:         {",
          "2739:             if (CONFIG_FLAG(MinTemplatizedJitLoopRunCount) < 0 || m_asmJsTotalLoopCount > static_cast<uint>(CONFIG_FLAG(MinTemplatizedJitLoopRunCount)))",
          "2740:             {",
          "2741:                 return true;",
          "2742:             }",
          "2743:             return false;",
          "2744:         }",
          "2745: #endif",
          "2747:     private:",
          "2748:         void ResetLoops();",
          "2750:     public:",
          "2751:         static bool Is(void* ptr);",
          "2752:         uint GetScriptId() const { return m_uScriptId; }",
          "2754:         void* GetAddressOfScriptId() const",
          "2755:         {",
          "2756:             return (void*)&m_uScriptId;",
          "2757:         }",
          "2760:         static uint *GetJittedLoopIterationsSinceLastBailoutAddress(EntryPointInfo* info)",
          "2761:         {",
          "2762:             LoopEntryPointInfo* entryPoint = (LoopEntryPointInfo*)info;",
          "2763:             return &entryPoint->jittedLoopIterationsSinceLastBailout;",
          "2764:         }",
          "2766:         FunctionEntryPointInfo* GetDefaultFunctionEntryPointInfo() const;",
          "2767:         void SetDefaultFunctionEntryPointInfo(FunctionEntryPointInfo* entryPointInfo, const JavascriptMethod originalEntryPoint);",
          "2769:         FunctionEntryPointInfo *GetSimpleJitEntryPointInfo() const;",
          "2770:         void SetSimpleJitEntryPointInfo(FunctionEntryPointInfo *const entryPointInfo);",
          "2772:     private:",
          "2773:         void VerifyExecutionMode(const ExecutionMode executionMode) const;",
          "2774:     public:",
          "2775:         ExecutionMode GetDefaultInterpreterExecutionMode() const;",
          "2776:         ExecutionMode GetExecutionMode() const;",
          "2777:         ExecutionMode GetInterpreterExecutionMode(const bool isPostBailout);",
          "2778:         void SetExecutionMode(const ExecutionMode executionMode);",
          "2779:     private:",
          "2780:         bool IsInterpreterExecutionMode() const;",
          "2782:     public:",
          "2783:         bool TryTransitionToNextExecutionMode();",
          "2784:         void TryTransitionToNextInterpreterExecutionMode();",
          "2785:         void SetIsSpeculativeJitCandidate();",
          "2786:         bool TryTransitionToJitExecutionMode();",
          "2787:         void TransitionToSimpleJitExecutionMode();",
          "2788:         void TransitionToFullJitExecutionMode();",
          "2790:     private:",
          "2791:         void VerifyExecutionModeLimits();",
          "2792:         void InitializeExecutionModeAndLimits();",
          "2793:     public:",
          "2794:         void ReinitializeExecutionModeAndLimits();",
          "2795:     private:",
          "2796:         void SetFullJitThreshold(const uint16 newFullJitThreshold, const bool skipSimpleJit = false);",
          "2797:         void CommitExecutedIterations();",
          "2798:         void CommitExecutedIterations(uint16 &limit, const uint executedIterations);",
          "2800:     private:",
          "2801:         uint16 GetSimpleJitExecutedIterations() const;",
          "2802:     public:",
          "2803:         void ResetSimpleJitLimitAndCallCount();",
          "2804:     private:",
          "2805:         void SetSimpleJitCallCount(const uint16 simpleJitLimit) const;",
          "2806:         void ResetSimpleJitCallCount();",
          "2807:     public:",
          "2808:         uint16 GetProfiledIterations() const;",
          "2810:     public:",
          "2811:         void OnFullJitDequeued(const FunctionEntryPointInfo *const entryPointInfo);",
          "2813:     public:",
          "2814:         void TraceExecutionMode(const char *const eventDescription = nullptr) const;",
          "2815:         void TraceInterpreterExecutionMode() const;",
          "2816:     private:",
          "2817:         void DoTraceExecutionMode(const char *const eventDescription) const;",
          "2819:     public:",
          "2820:         bool DoSimpleJit() const;",
          "2821:         bool DoSimpleJitWithLock() const;",
          "2822:         bool DoSimpleJitDynamicProfile() const;",
          "2824:     private:",
          "2825:         bool DoInterpreterProfile() const;",
          "2826:         bool DoInterpreterProfileWithLock() const;",
          "2827:         bool DoInterpreterAutoProfile() const;",
          "2829:     public:",
          "2830:         bool WasCalledFromLoop() const;",
          "2831:         void SetWasCalledFromLoop();",
          "2833:     public:",
          "2834:         bool RecentlyBailedOutOfJittedLoopBody() const;",
          "2835:         void SetRecentlyBailedOutOfJittedLoopBody(const bool value);",
          "2837:     private:",
          "2838:         static uint16 GetMinProfileIterations();",
          "2839:     public:",
          "2840:         static uint16 GetMinFunctionProfileIterations();",
          "2841:     private:",
          "2842:         static uint GetMinLoopProfileIterations(const uint loopInterpreterLimit);",
          "2843:     public:",
          "2844:         uint GetLoopProfileThreshold(const uint loopInterpreterLimit) const;",
          "2845:     private:",
          "2846:         static uint GetReducedLoopInterpretCount();",
          "2847:     public:",
          "2848:         uint GetLoopInterpretCount(LoopHeader* loopHeader) const;",
          "2850:     private:",
          "2851:         static bool DoObjectHeaderInlining();",
          "2852:         static bool DoObjectHeaderInliningForConstructors();",
          "2853:     public:",
          "2854:         static bool DoObjectHeaderInliningForConstructor(const uint32 inlineSlotCapacity);",
          "2855:     private:",
          "2856:         static bool DoObjectHeaderInliningForObjectLiterals();",
          "2857:     public:",
          "2858:         static bool DoObjectHeaderInliningForObjectLiteral(const uint32 inlineSlotCapacity);",
          "2859:         static bool DoObjectHeaderInliningForObjectLiteral(const PropertyIdArray *const propIds);",
          "2860:         static bool DoObjectHeaderInliningForEmptyObjects();",
          "2862:     public:",
          "2863: #if DBG",
          "2864:         int GetProfileSession() { return m_iProfileSession; }",
          "2865: #endif",
          "2866:         virtual void Finalize(bool isShutdown) override;",
          "2867:         virtual void OnMark() override;",
          "2869:         void Cleanup(bool isScriptContextClosing);",
          "2870:         void CleanupSourceInfo(bool isScriptContextClosing);",
          "2871:         template<bool IsScriptContextShutdown>",
          "2872:         void CleanUpInlineCaches();",
          "2873:         void CleanupRecyclerData(bool isRecyclerShutdown, bool doEntryPointCleanupCaptureStack);",
          "2875: #ifdef PERF_COUNTERS",
          "2876:         void CleanupPerfCounter();",
          "2877: #endif",
          "2879:         bool HasRejit() const",
          "2880:         {",
          "2881:             if(this->entryPoints)",
          "2882:             {",
          "2883:                 return this->entryPoints->Count() > 1;",
          "2884:             }",
          "2885:             return false;",
          "2886:         }",
          "2888: #pragma region SourceInfo Methods",
          "2889:         void CopySourceInfo(ParseableFunctionInfo* originalFunctionInfo);",
          "2890:         void FinishSourceInfo();",
          "2891:         RegSlot GetFrameDisplayRegister() const;",
          "2892:         void SetFrameDisplayRegister(RegSlot frameDisplayRegister);",
          "2894:         RegSlot GetObjectRegister() const;",
          "2895:         void SetObjectRegister(RegSlot objectRegister);",
          "2896:         bool HasObjectRegister() const { return GetObjectRegister() != 0; }",
          "2897:         ScopeObjectChain *GetScopeObjectChain() const;",
          "2898:         void SetScopeObjectChain(ScopeObjectChain *pScopeObjectChain);",
          "2901:         Js::DebuggerScope * GetDiagCatchScopeObjectAt(int byteCodeOffset);",
          "2903:         ByteBlock *GetProbeBackingBlock();",
          "2904:         void SetProbeBackingBlock(ByteBlock* probeBackingBlock);",
          "2906:         bool HasLineBreak() const;",
          "2907:         bool HasLineBreak(charcount_t start, charcount_t end) const;",
          "2909:         bool HasGeneratedFromByteCodeCache() const { return this->byteCodeCache != nullptr; }",
          "2911:         void TrackLoad(int ichMin);",
          "2913:         SmallSpanSequence* GetStatementMapSpanSequence() const { return m_sourceInfo.pSpanSequence; }",
          "2914:         void RecordStatementMap(StatementMap* statementMap);",
          "2915:         void RecordStatementMap(SmallSpanSequenceIter &iter, StatementData * data);",
          "2916:         void RecordLoad(int ichMin, int bytecodeAfterLoad);",
          "2917:         DebuggerScope* RecordStartScopeObject(DiagExtraScopesType scopeType, int start, RegSlot scopeLocation, int* index = nullptr);",
          "2918:         void RecordEndScopeObject(DebuggerScope* currentScope, int end);",
          "2919:         DebuggerScope* AddScopeObject(DiagExtraScopesType scopeType, int start, RegSlot scopeLocation);",
          "2920:         bool TryGetDebuggerScopeAt(int index, DebuggerScope*& debuggerScope);",
          "2922:         StatementMapList * GetStatementMaps() const { return static_cast<StatementMapList *>(this->GetAuxPtrWithLock(AuxPointerType::StatementMaps)); }",
          "2923:         void SetStatementMaps(StatementMapList *pStatementMaps) { this->SetAuxPtr(AuxPointerType::StatementMaps, pStatementMaps); }",
          "2925:         Field(FunctionCodeGenRuntimeData*)* GetCodeGenGetSetRuntimeData() const { return static_cast<Field(FunctionCodeGenRuntimeData*)*>(this->GetAuxPtr(AuxPointerType::CodeGenGetSetRuntimeData)); }",
          "2926:         Field(FunctionCodeGenRuntimeData*)* GetCodeGenGetSetRuntimeDataWithLock() const { return static_cast<Field(FunctionCodeGenRuntimeData*)*>(this->GetAuxPtrWithLock(AuxPointerType::CodeGenGetSetRuntimeData)); }",
          "2927:         void SetCodeGenGetSetRuntimeData(FunctionCodeGenRuntimeData** codeGenGetSetRuntimeData) { this->SetAuxPtr(AuxPointerType::CodeGenGetSetRuntimeData, codeGenGetSetRuntimeData); }",
          "2929:         Field(FunctionCodeGenRuntimeData*)* GetCodeGenRuntimeData() const { return static_cast<Field(FunctionCodeGenRuntimeData*)*>(this->GetAuxPtr(AuxPointerType::CodeGenRuntimeData)); }",
          "2930:         Field(FunctionCodeGenRuntimeData*)* GetCodeGenRuntimeDataWithLock() const { return static_cast<Field(FunctionCodeGenRuntimeData*)*>(this->GetAuxPtrWithLock(AuxPointerType::CodeGenRuntimeData)); }",
          "2931:         void SetCodeGenRuntimeData(FunctionCodeGenRuntimeData** codeGenRuntimeData) { this->SetAuxPtr(AuxPointerType::CodeGenRuntimeData, codeGenRuntimeData); }",
          "2933:         template <typename TStatementMapList>",
          "2934:         static StatementMap * GetNextNonSubexpressionStatementMap(TStatementMapList *statementMapList, int & startingAtIndex);",
          "2935:         static StatementMap * GetPrevNonSubexpressionStatementMap(StatementMapList *statementMapList, int & startingAtIndex);",
          "2936:         void RecordStatementAdjustment(uint offset, StatementAdjustmentType adjType);",
          "2937:         void RecordCrossFrameEntryExitRecord(uint byteCodeOffset, bool isEnterBlock);",
          "2940:         BOOL GetBranchOffsetWithin(uint start, uint end, StatementAdjustmentRecord* record);",
          "2941:         bool GetLineCharOffset(int byteCodeOffset, ULONG* line, LONG* charOffset, bool canAllocateLineCache = true);",
          "2942:         bool GetLineCharOffsetFromStartChar(int startCharOfStatement, ULONG* _line, LONG* _charOffset, bool canAllocateLineCache = true);",
          "2945:         bool GetStatementIndexAndLengthAt(int byteCodeOffset, UINT32* statementIndex, UINT32* statementLength);",
          "2948:         static charcount_t SkipByteOrderMark(__in_bcount_z(4) LPCUTF8& documentStart)",
          "2949:         {",
          "2950:             charcount_t retValue = 0;",
          "2952:             Assert(documentStart != nullptr);",
          "2954:             if (documentStart[0] == 0xEF &&",
          "2955:                 documentStart[1] == 0xBB &&",
          "2956:                 documentStart[2] == 0xBF)",
          "2957:             {",
          "2960:                 documentStart += 3;",
          "2961:                 retValue = 1;",
          "2962:             }",
          "2963:             else if ((documentStart[0] == 0xFF && documentStart[1] == 0xFE) ||",
          "2964:                     (documentStart[0] == 0xFE && documentStart[1] == 0xFF))",
          "2965:             {",
          "2969:                 documentStart += 2;",
          "2970:                 retValue = 1;",
          "2971:             }",
          "2973:             return retValue;",
          "2974:         }",
          "2976:         StatementMap* GetMatchingStatementMapFromByteCode(int byteCodeOffset, bool ignoreSubexpressions = false);",
          "2977:         int GetEnclosingStatementIndexFromByteCode(int byteCodeOffset, bool ignoreSubexpressions = false);",
          "2978:         StatementMap* GetEnclosingStatementMapFromByteCode(int byteCodeOffset, bool ignoreSubexpressions = false);",
          "2979:         StatementMap* GetMatchingStatementMapFromSource(int byteCodeOffset, int* pMapIndex = nullptr);",
          "2980:         void RecordFrameDisplayRegister(RegSlot slot);",
          "2981:         void RecordObjectRegister(RegSlot slot);",
          "2983:         CrossFrameEntryExitRecordList* GetCrossFrameEntryExitRecords();",
          "2985: #ifdef VTUNE_PROFILING",
          "2986:         uint GetStartOffset(uint statementIndex) const;",
          "2987:         ULONG GetSourceLineNumber(uint statementIndex);",
          "2988: #endif",
          "2990: #pragma endregion",
          "2993:         bool GetHasBailoutInstrInJittedCode() const { return this->m_hasBailoutInstrInJittedCode; }",
          "2994:         void SetHasBailoutInstrInJittedCode(bool hasBailout) { this->m_hasBailoutInstrInJittedCode = hasBailout; }",
          "2995:         bool GetCanDefer() const { return this->functionInfo->CanBeDeferred() && this->m_depth == 0 && !this->m_hasActiveReference; }",
          "2996:         bool GetCanReleaseLoopHeaders() const { return (this->m_depth == 0); }",
          "2997:         void SetPendingLoopHeaderRelease(bool pendingLoopHeaderRelease) { this->m_pendingLoopHeaderRelease = pendingLoopHeaderRelease; }",
          "2999:         bool GetIsFromNativeCodeModule() const { return m_isFromNativeCodeModule; }",
          "3000:         void SetIsFromNativeCodeModule(bool isFromNativeCodeModule) { m_isFromNativeCodeModule = isFromNativeCodeModule; }",
          "3002:         uint GetLoopNumber(LoopHeader const * loopHeader) const;",
          "3003:         uint GetLoopNumberWithLock(LoopHeader const * loopHeader) const;",
          "3004:         bool GetHasAllocatedLoopHeaders() { return this->GetLoopHeaderArray() != nullptr; }",
          "3005:         Js::LoopHeader* GetLoopHeaderArray() const { return static_cast<Js::LoopHeader*>(this->GetAuxPtr(AuxPointerType::LoopHeaderArray)); }",
          "3006:         Js::LoopHeader* GetLoopHeaderArrayWithLock() const { return static_cast<Js::LoopHeader*>(this->GetAuxPtrWithLock(AuxPointerType::LoopHeaderArray)); }",
          "3007:         void SetLoopHeaderArray(Js::LoopHeader* loopHeaderArray) { this->SetAuxPtr(AuxPointerType::LoopHeaderArray, loopHeaderArray); }",
          "3009: #if ENABLE_NATIVE_CODEGEN",
          "3010:         Js::JavascriptMethod GetLoopBodyEntryPoint(Js::LoopHeader * loopHeader, int entryPointIndex);",
          "3011:         void SetLoopBodyEntryPoint(Js::LoopHeader * loopHeader, EntryPointInfo* entryPointInfo, Js::JavascriptMethod entryPoint, uint loopNum);",
          "3012: #endif",
          "3014:         void RestoreOldDefaultEntryPoint(FunctionEntryPointInfo* oldEntryPoint, JavascriptMethod oldOriginalEntryPoint, FunctionEntryPointInfo* newEntryPoint);",
          "3015:         FunctionEntryPointInfo* CreateNewDefaultEntryPoint();",
          "3016:         void AddEntryPointToEntryPointList(FunctionEntryPointInfo* entryPoint);",
          "3019: #if DBG",
          "3020:         BOOL IsInterpreterThunk() const;",
          "3021:         BOOL IsDynamicInterpreterThunk() const;",
          "3022: #endif",
          "3023:         BOOL IsNativeOriginalEntryPoint() const;",
          "3024:         bool IsSimpleJitOriginalEntryPoint() const;",
          "3026: #if DYNAMIC_INTERPRETER_THUNK",
          "3027:         static BYTE GetOffsetOfDynamicInterpreterThunk() { return static_cast<BYTE>(offsetof(FunctionBody, m_dynamicInterpreterThunk)); }",
          "3028:         void* GetDynamicInterpreterEntryPoint() const",
          "3029:         {",
          "3030:             return m_dynamicInterpreterThunk;",
          "3031:         }",
          "3032:         bool HasInterpreterThunkGenerated() const",
          "3033:         {",
          "3034:             return m_dynamicInterpreterThunk != nullptr;",
          "3035:         }",
          "3037:         DWORD GetDynamicInterpreterThunkSize() const;",
          "3038: #endif",
          "3040:         bool GetHasHotLoop() const { return hasHotLoop; };",
          "3041:         void SetHasHotLoop();",
          "3043:         bool GetHasNestedLoop() const { return hasNestedLoop; };",
          "3044:         void SetHasNestedLoop(bool nest) { hasNestedLoop = nest; };",
          "3046:         bool IsInlineApplyDisabled();",
          "3047:         void InitDisableInlineApply();",
          "3048:         void SetDisableInlineApply(bool set);",
          "3050:         bool IsInlineSpreadDisabled()  const  { return disableInlineSpread; }",
          "3051:         void InitDisableInlineSpread()        { disableInlineSpread = this->GetLocalFunctionId() != Js::Constants::NoFunctionId && PHASE_OFF(Js::InlinePhase, this); }",
          "3052:         void SetDisableInlineSpread(bool set) { disableInlineSpread = set; }",
          "3054:         bool CheckCalleeContextForInlining(FunctionProxy* calleeFunctionProxy);",
          "3055: #if DBG",
          "3056:         bool HasValidSourceInfo();",
          "3057: #endif",
          "3058: #if DYNAMIC_INTERPRETER_THUNK",
          "3059:         JavascriptMethod EnsureDynamicInterpreterThunk(FunctionEntryPointInfo* entryPointInfo);",
          "3060: #endif",
          "3062:         void SetCheckCodeGenEntryPoint(FunctionEntryPointInfo* entryPointInfo, JavascriptMethod entryPoint);",
          "3064: #if ENABLE_NATIVE_CODEGEN",
          "3065:         typedef void (*SetNativeEntryPointFuncType)(FunctionEntryPointInfo* entryPointInfo, Js::FunctionBody * functionBody, Js::JavascriptMethod entryPoint);",
          "3066:         static void DefaultSetNativeEntryPoint(FunctionEntryPointInfo* entryPointInfo, FunctionBody * functionBody, JavascriptMethod entryPoint);",
          "3067:         static void ProfileSetNativeEntryPoint(FunctionEntryPointInfo* entryPointInfo, FunctionBody * functionBody, JavascriptMethod entryPoint);",
          "3069:         bool GetNativeEntryPointUsed() const { return m_nativeEntryPointUsed; }",
          "3070:         void SetNativeEntryPointUsed(bool nativeEntryPointUsed) { this->m_nativeEntryPointUsed = nativeEntryPointUsed; }",
          "3071: #endif",
          "3073:         bool GetIsFuncRegistered() { return m_isFuncRegistered; }",
          "3074:         void SetIsFuncRegistered(bool isRegistered) { m_isFuncRegistered = isRegistered; }",
          "3076:         bool GetHasLoops() const { return this->GetLoopCount() != 0; }",
          "3077:         uint IncrLoopCount() { return this->IncreaseCountField(CounterFields::LoopCount); }",
          "3078:         uint GetLoopCount() const { return this->GetCountField(CounterFields::LoopCount); }",
          "3079:         uint SetLoopCount(uint count) { return this->SetCountField(CounterFields::LoopCount, count); }",
          "3081:         uint GetForInLoopDepth() const { return this->GetCountField(CounterFields::ForInLoopDepth); }",
          "3082:         uint SetForInLoopDepth(uint count) { return this->SetCountField(CounterFields::ForInLoopDepth, count); }",
          "3084:         bool AllocProfiledForInLoopCount(ProfileId* profileId)",
          "3085:         {",
          "3086:             ProfileId profiledForInLoopCount = this->GetProfiledForInLoopCount();",
          "3087:             if (profiledForInLoopCount != Constants::NoProfileId)",
          "3088:             {",
          "3090:                 this->IncreaseCountField(CounterFields::ProfiledForInLoopCount);",
          "3091:                 return true;",
          "3092:             }",
          "3093:             return false;",
          "3094:         }",
          "3095:         ProfileId GetProfiledForInLoopCount() const { return (ProfileId)this->GetCountField(CounterFields::ProfiledForInLoopCount); }",
          "3096:         void SetProfiledForInLoopCount(ProfileId count) { this->SetCountField(CounterFields::ProfiledForInLoopCount, count); }",
          "3098:         bool AllocProfiledDivOrRem(ProfileId* profileId) { if (this->profiledDivOrRemCount != Constants::NoProfileId) { *profileId = this->profiledDivOrRemCount++; return true; } return false; }",
          "3099:         ProfileId GetProfiledDivOrRemCount() { return this->profiledDivOrRemCount; }",
          "3101:         bool AllocProfiledSwitch(ProfileId* profileId) { if (this->profiledSwitchCount != Constants::NoProfileId) { *profileId = this->profiledSwitchCount++; return true; } return false; }",
          "3102:         ProfileId GetProfiledSwitchCount() { return this->profiledSwitchCount; }",
          "3104:         bool AllocProfiledCallSiteId(ProfileId* profileId) { if (this->profiledCallSiteCount != Constants::NoProfileId) { *profileId = this->profiledCallSiteCount++; return true; } return false; }",
          "3105:         ProfileId GetProfiledCallSiteCount() const { return this->profiledCallSiteCount; }",
          "3106:         void SetProfiledCallSiteCount(ProfileId callSiteId)  { this->profiledCallSiteCount = callSiteId; }",
          "3108:         bool AllocProfiledArrayCallSiteId(ProfileId* profileId) { if (this->profiledArrayCallSiteCount != Constants::NoProfileId) { *profileId = this->profiledArrayCallSiteCount++; return true; } return false; }",
          "3109:         ProfileId GetProfiledArrayCallSiteCount() const { return this->profiledArrayCallSiteCount; }",
          "3111:         bool AllocProfiledReturnTypeId(ProfileId* profileId) { if (this->profiledReturnTypeCount != Constants::NoProfileId) { *profileId = this->profiledReturnTypeCount++; return true; } return false; }",
          "3112:         ProfileId GetProfiledReturnTypeCount() const { return this->profiledReturnTypeCount; }",
          "3114:         bool AllocProfiledSlotId(ProfileId* profileId) { if (this->profiledSlotCount != Constants::NoProfileId) { *profileId = this->profiledSlotCount++; return true; } return false; }",
          "3115:         ProfileId GetProfiledSlotCount() const { return this->profiledSlotCount; }",
          "3117:         ProfileId AllocProfiledLdElemId(ProfileId* profileId) { if (this->profiledLdElemCount != Constants::NoProfileId) { *profileId = this->profiledLdElemCount++; return true; } return false; }",
          "3118:         ProfileId GetProfiledLdElemCount() const { return this->profiledLdElemCount; }",
          "3120:         bool AllocProfiledStElemId(ProfileId* profileId) { if (this->profiledStElemCount != Constants::NoProfileId) { *profileId = this->profiledStElemCount++; return true; } return false; }",
          "3121:         ProfileId GetProfiledStElemCount() const { return this->profiledStElemCount; }",
          "3123:         uint GetProfiledFldCount() const { return this->GetInlineCacheCount(); }",
          "3125:         ArgSlot GetProfiledInParamsCount() const { return this->GetInParamsCount() > 1? this->GetInParamsCount() - 1 : 0; }",
          "3127:         bool IsPartialDeserializedFunction() { return this->m_isPartialDeserializedFunction; }",
          "3128: #ifdef PERF_COUNTERS",
          "3129:         bool IsDeserializedFunction() { return this->m_isDeserializedFunction; }",
          "3130: #endif",
          "3132: #ifdef IR_VIEWER",
          "3133:         bool IsIRDumpEnabled() const { return this->m_isIRDumpEnabled; }",
          "3134:         void SetIRDumpEnabled(bool enabled) { this->m_isIRDumpEnabled = enabled; }",
          "3135:         Js::DynamicObject * GetIRDumpBaseObject();",
          "3138: #if ENABLE_NATIVE_CODEGEN",
          "3139:         void SetPolymorphicCallSiteInfoHead(PolymorphicCallSiteInfo *polyCallSiteInfo) { this->SetAuxPtr(AuxPointerType::PolymorphicCallSiteInfoHead, polyCallSiteInfo); }",
          "3140:         PolymorphicCallSiteInfo * GetPolymorphicCallSiteInfoHead() { return static_cast<PolymorphicCallSiteInfo *>(this->GetAuxPtr(AuxPointerType::PolymorphicCallSiteInfoHead)); }",
          "3141: #endif",
          "3143:         PolymorphicInlineCache * GetPolymorphicInlineCachesHead() { return static_cast<PolymorphicInlineCache *>(this->GetAuxPtr(AuxPointerType::PolymorphicInlineCachesHead)); }",
          "3144:         void SetPolymorphicInlineCachesHead(PolymorphicInlineCache * cache) { this->SetAuxPtr(AuxPointerType::PolymorphicInlineCachesHead, cache); }",
          "3146:         bool PolyInliningUsingFixedMethodsAllowedByConfigFlags(FunctionBody* topFunctionBody)",
          "3147:         {",
          "3148:             return  !PHASE_OFF(Js::InlinePhase, this) && !PHASE_OFF(Js::InlinePhase, topFunctionBody) &&",
          "3149:                 !PHASE_OFF(Js::PolymorphicInlinePhase, this) && !PHASE_OFF(Js::PolymorphicInlinePhase, topFunctionBody) &&",
          "3150:                 !PHASE_OFF(Js::FixedMethodsPhase, this) && !PHASE_OFF(Js::FixedMethodsPhase, topFunctionBody) &&",
          "3151:                 !PHASE_OFF(Js::PolymorphicInlineFixedMethodsPhase, this) && !PHASE_OFF(Js::PolymorphicInlineFixedMethodsPhase, topFunctionBody);",
          "3152:         }",
          "3154:         void SetScopeSlotArraySizes(uint scopeSlotCount, uint scopeSlotCountForParamScope)",
          "3155:         {",
          "3156:             this->scopeSlotArraySize = scopeSlotCount;",
          "3157:             this->paramScopeSlotArraySize = scopeSlotCountForParamScope;",
          "3158:         }",
          "3160:         Js::PropertyId * GetPropertyIdsForScopeSlotArray() const { return static_cast<Js::PropertyId *>(this->GetAuxPtr(AuxPointerType::PropertyIdsForScopeSlotArray)); }",
          "3161:         void SetPropertyIdsForScopeSlotArray(Js::PropertyId * propertyIdsForScopeSlotArray, uint scopeSlotCount, uint scopeSlotCountForParamScope = 0)",
          "3162:         {",
          "3163:             SetScopeSlotArraySizes(scopeSlotCount, scopeSlotCountForParamScope);",
          "3164:             this->SetAuxPtr(AuxPointerType::PropertyIdsForScopeSlotArray, propertyIdsForScopeSlotArray);",
          "3165:         }",
          "3167:         Js::PropertyIdOnRegSlotsContainer * GetPropertyIdOnRegSlotsContainer() const",
          "3168:         {",
          "3169:             return static_cast<Js::PropertyIdOnRegSlotsContainer *>(this->GetAuxPtr(AuxPointerType::PropertyIdOnRegSlotsContainer));",
          "3170:         }",
          "3171:         Js::PropertyIdOnRegSlotsContainer * GetPropertyIdOnRegSlotsContainerWithLock() const",
          "3172:         {",
          "3173:             return static_cast<Js::PropertyIdOnRegSlotsContainer *>(this->GetAuxPtrWithLock(AuxPointerType::PropertyIdOnRegSlotsContainer));",
          "3174:         }",
          "3175:         void SetPropertyIdOnRegSlotsContainer(Js::PropertyIdOnRegSlotsContainer *propertyIdOnRegSlotsContainer)",
          "3176:         {",
          "3177:             this->SetAuxPtr(AuxPointerType::PropertyIdOnRegSlotsContainer, propertyIdOnRegSlotsContainer);",
          "3178:         }",
          "3179:     private:",
          "3180:         void ResetProfileIds();",
          "3182:     public:",
          "3183:         bool GetHasFinally() const { return m_hasFinally; }",
          "3184:         void SetHasFinally(bool has){ m_hasFinally = has; }",
          "3186:         bool GetFuncEscapes() const { return funcEscapes; }",
          "3187:         void SetFuncEscapes(bool does) { funcEscapes = does; }",
          "3189: #if DBG",
          "3190:         bool CanDoStackNestedFunc() const { return m_canDoStackNestedFunc; }",
          "3191:         void SetCanDoStackNestedFunc() { m_canDoStackNestedFunc = true; }",
          "3192: #endif",
          "3193:         RecyclerWeakReference<FunctionInfo> * GetStackNestedFuncParent();",
          "3194:         FunctionInfo * GetStackNestedFuncParentStrongRef();",
          "3195:         FunctionInfo * GetAndClearStackNestedFuncParent();",
          "3196:         void ClearStackNestedFuncParent();",
          "3197:         void SetStackNestedFuncParent(FunctionInfo * parentFunctionInfo);",
          "3199:         uint GetScopeSlotArraySize() const",
          "3200:         {",
          "3201:             return scopeSlotArraySize;",
          "3202:         }",
          "3204: #if defined(_M_IX86) || defined(_M_X64)",
          "3205:         template <typename T>",
          "3206:         static bool DoStackClosure(T functionBody)",
          "3207:         {",
          "3208:             return functionBody->DoStackNestedFunc()",
          "3209:                 && functionBody->GetNestedCount() != 0",
          "3210:                 && functionBody->GetScopeSlotArraySize() != 0",
          "3211:                 && functionBody->GetEnvDepth() != (uint16)-1;",
          "3212:         }",
          "3213: #else",
          "3214:         template <typename T>",
          "3215:         static bool DoStackClosure(T functionBody)",
          "3216:         {",
          "3217:             return false;",
          "3218:         }",
          "3219: #endif",
          "3220:         bool DoStackFrameDisplay() const { return DoStackClosure(this) && !PHASE_OFF(StackClosurePhase, this); }",
          "3221:         bool DoStackScopeSlots() const { return DoStackClosure(this) && !PHASE_OFF(StackClosurePhase, this); }",
          "3223:         bool GetIsFirstFunctionObject() const { return m_firstFunctionObject; }",
          "3224:         void SetIsNotFirstFunctionObject() { m_firstFunctionObject = false; }",
          "3226:         bool GetInlineCachesOnFunctionObject() { return m_inlineCachesOnFunctionObject; }",
          "3227:         void SetInlineCachesOnFunctionObject(bool has) { m_inlineCachesOnFunctionObject = has; }",
          "3229:         bool NeedScopeObjectForArguments(bool hasNonSimpleParams)",
          "3230:         {",
          "3231:             Assert(HasReferenceableBuiltInArguments());",
          "3233:             bool dontNeedScopeObject =",
          "3235:                 (GetIsStrictMode() || hasNonSimpleParams)",
          "3237:                 && !HasScopeObject();",
          "3239:             return",
          "3241:                 (GetInParamsCount() > 1 || GetHasRestParameter())",
          "3242:                 && !dontNeedScopeObject;",
          "3243:         }",
          "3245:         uint GetNumberOfRecursiveCallSites();",
          "3246:         bool CanInlineRecursively(uint depth, bool tryAggressive = true);",
          "3247:     public:",
          "3248:         bool CanInlineAgain() const",
          "3249:         {",
          "3251:             return inlineDepth < static_cast<byte>(max(1, min(0xff, CONFIG_FLAG(MaxFuncInlineDepth))));",
          "3252:         }",
          "3254:         void OnBeginInlineInto()",
          "3255:         {",
          "3256:             ++inlineDepth;",
          "3257:         }",
          "3259:         void OnEndInlineInto()",
          "3260:         {",
          "3261:             --inlineDepth;",
          "3262:         }",
          "3264:         uint8 IncrementBailOnMisingProfileCount() { return ++bailOnMisingProfileCount; }",
          "3265:         void ResetBailOnMisingProfileCount() { bailOnMisingProfileCount = 0; }",
          "3266:         uint8 IncrementBailOnMisingProfileRejitCount() { return ++bailOnMisingProfileRejitCount; }",
          "3267:         uint32 GetFrameHeight(EntryPointInfo* entryPointInfo) const;",
          "3268:         void SetFrameHeight(EntryPointInfo* entryPointInfo, uint32 frameHeight);",
          "3270:         RegSlot GetLocalsCount();",
          "3271:         RegSlot GetConstantCount() const { return this->GetCountField(CounterFields::ConstantCount); }",
          "3272:         void CheckAndSetConstantCount(RegSlot cNewConstants);",
          "3273:         void SetConstantCount(RegSlot cNewConstants);",
          "3274:         RegSlot GetVarCount();",
          "3275:         void SetVarCount(RegSlot cNewVars);",
          "3276:         void CheckAndSetVarCount(RegSlot cNewVars);",
          "3277:         RegSlot MapRegSlot(RegSlot reg)",
          "3278:         {",
          "3279:             if (this->RegIsConst(reg))",
          "3280:             {",
          "3281:                 reg = CONSTREG_TO_REGSLOT(reg);",
          "3282:                 Assert(reg < this->GetConstantCount());",
          "3283:             }",
          "3284:             else",
          "3285:             {",
          "3286:                 reg += this->GetConstantCount();",
          "3287:             }",
          "3289:             return reg;",
          "3290:         }",
          "3291:         bool RegIsConst(RegSlot reg) { return reg > REGSLOT_TO_CONSTREG(this->GetConstantCount()); }",
          "3293:         uint32 GetNonTempLocalVarCount();",
          "3294:         uint32 GetFirstNonTempLocalIndex();",
          "3295:         uint32 GetEndNonTempLocalIndex();",
          "3296:         bool IsNonTempLocalVar(uint32 varIndex);",
          "3297:         bool GetSlotOffset(RegSlot slotId, int32 * slotOffset, bool allowTemp = false);",
          "3299:         RegSlot GetOutParamMaxDepth();",
          "3300:         void SetOutParamMaxDepth(RegSlot cOutParamsDepth);",
          "3301:         void CheckAndSetOutParamMaxDepth(RegSlot cOutParamsDepth);",
          "3303:         RegSlot GetYieldRegister();",
          "3305:         RegSlot GetFirstTmpRegister() const;",
          "3306:         void SetFirstTmpRegister(RegSlot reg);",
          "3308:         RegSlot GetFirstTmpReg();",
          "3309:         void SetFirstTmpReg(RegSlot firstTmpReg);",
          "3310:         RegSlot GetTempCount();",
          "3312:         Js::ModuleID GetModuleID() const;",
          "3314:         void CreateConstantTable();",
          "3315:         void RecordNullObject(RegSlot location);",
          "3316:         void RecordUndefinedObject(RegSlot location);",
          "3317:         void RecordTrueObject(RegSlot location);",
          "3318:         void RecordFalseObject(RegSlot location);",
          "3319:         void RecordIntConstant(RegSlot location, unsigned int val);",
          "3320:         void RecordStrConstant(RegSlot location, LPCOLESTR psz, uint32 cch);",
          "3321:         void RecordFloatConstant(RegSlot location, double d);",
          "3322:         void RecordNullDisplayConstant(RegSlot location);",
          "3323:         void RecordStrictNullDisplayConstant(RegSlot location);",
          "3324:         void InitConstantSlots(Var *dstSlots);",
          "3325:         Var GetConstantVar(RegSlot location);",
          "3326:         Field(Js::Var)* GetConstTable() const { return this->m_constTable; }",
          "3327:         void SetConstTable(Field(Js::Var)* constTable) { this->m_constTable = constTable; }",
          "3329:         void MarkScript(ByteBlock * pblkByteCode, ByteBlock * pblkAuxiliaryData, ByteBlock* auxContextBlock,",
          "3330:             uint byteCodeCount, uint byteCodeInLoopCount, uint byteCodeWithoutLDACount);",
          "3332:         void         BeginExecution();",
          "3333:         void         EndExecution();",
          "3334:         SourceInfo * GetSourceInfo() { return &this->m_sourceInfo; }",
          "3336:         bool InstallProbe(int offset);",
          "3337:         bool UninstallProbe(int offset);",
          "3338:         bool ProbeAtOffset(int offset, OpCode* pOriginalOpcode);",
          "3340:         static bool ShouldShareInlineCaches() { return CONFIG_FLAG(ShareInlineCaches); }",
          "3342:         uint GetInlineCacheCount() const { return GetCountField(CounterFields::InlineCacheCount); }",
          "3343:         void SetInlineCacheCount(uint count) { SetCountField(CounterFields::InlineCacheCount, count); }",
          "3345:         uint GetRootObjectLoadInlineCacheStart() const { return GetCountField(CounterFields::RootObjectLoadInlineCacheStart); }",
          "3346:         void SetRootObjectLoadInlineCacheStart(uint count) { SetCountField(CounterFields::RootObjectLoadInlineCacheStart, count); }",
          "3348:         uint GetRootObjectLoadMethodInlineCacheStart() const { return GetCountField(CounterFields::RootObjectLoadMethodInlineCacheStart); }",
          "3349:         void SetRootObjectLoadMethodInlineCacheStart(uint count) { SetCountField(CounterFields::RootObjectLoadMethodInlineCacheStart, count); }",
          "3351:         uint GetRootObjectStoreInlineCacheStart() const { return GetCountField(CounterFields::RootObjectStoreInlineCacheStart); }",
          "3352:         void SetRootObjectStoreInlineCacheStart(uint count) { SetCountField(CounterFields::RootObjectStoreInlineCacheStart, count); }",
          "3354:         uint GetIsInstInlineCacheCount() const { return GetCountField(CounterFields::IsInstInlineCacheCount); }",
          "3355:         void SetIsInstInlineCacheCount(uint count) { SetCountField(CounterFields::IsInstInlineCacheCount, count); }",
          "3357:         uint GetReferencedPropertyIdCount() const { return GetCountField(CounterFields::ReferencedPropertyIdCount); }",
          "3358:         void SetReferencedPropertyIdCount(uint count) { SetCountField(CounterFields::ReferencedPropertyIdCount, count); }",
          "3360:         uint GetObjLiteralCount() const { return GetCountField(CounterFields::ObjLiteralCount); }",
          "3361:         void SetObjLiteralCount(uint count) { SetCountField(CounterFields::ObjLiteralCount, count); }",
          "3362:         uint IncObjLiteralCount() { return IncreaseCountField(CounterFields::ObjLiteralCount); }",
          "3364:         uint GetLiteralRegexCount() const { return GetCountField(CounterFields::LiteralRegexCount); }",
          "3365:         void SetLiteralRegexCount(uint count) { SetCountField(CounterFields::LiteralRegexCount, count); }",
          "3366:         uint IncLiteralRegexCount() { return IncreaseCountField(CounterFields::LiteralRegexCount); }",
          "3368:         void AllocateForInCache();",
          "3369:         ForInCache * GetForInCache(uint index);",
          "3370:         ForInCache * GetForInCacheArray();",
          "3371:         void CleanUpForInCache(bool isShutdown);",
          "3373:         void AllocateInlineCache();",
          "3374:         InlineCache * GetInlineCache(uint index);",
          "3375:         bool CanFunctionObjectHaveInlineCaches();",
          "3376:         void** GetInlineCaches();",
          "3378: #if DBG",
          "3379:         byte* GetInlineCacheTypes();",
          "3380: #endif",
          "3381:         IsInstInlineCache * GetIsInstInlineCache(uint index);",
          "3382:         PolymorphicInlineCache * GetPolymorphicInlineCache(uint index);",
          "3383:         PolymorphicInlineCache * CreateNewPolymorphicInlineCache(uint index, PropertyId propertyId, InlineCache * inlineCache);",
          "3384:         PolymorphicInlineCache * CreateBiggerPolymorphicInlineCache(uint index, PropertyId propertyId);",
          "3385:     private:",
          "3387:         void ResetInlineCaches();",
          "3388:         PolymorphicInlineCache * CreatePolymorphicInlineCache(uint index, uint16 size);",
          "3389:         FieldWithBarrier(uint32) m_asmJsTotalLoopCount;",
          "3390:     public:",
          "3391:         void CreateCacheIdToPropertyIdMap();",
          "3392:         void CreateCacheIdToPropertyIdMap(uint rootObjectLoadInlineCacheStart, uint rootObjectLoadMethodInlineCacheStart, uint rootObjectStoreInlineCacheStart,",
          "3393:             uint totalFieldAccessInlineCacheCount, uint isInstInlineCacheCount);",
          "3394:         void SetPropertyIdForCacheId(uint cacheId, PropertyId propertyId);",
          "3395:         PropertyId GetPropertyIdFromCacheId(uint cacheId)",
          "3396:         {",
          "3397:             Assert(this->cacheIdToPropertyIdMap);",
          "3398:             Assert(cacheId < this->GetInlineCacheCount());",
          "3399:             return this->cacheIdToPropertyIdMap[cacheId];",
          "3400:         }",
          "3401: #if DBG",
          "3402:         void VerifyCacheIdToPropertyIdMap();",
          "3403: #endif",
          "3404:         PropertyId* GetReferencedPropertyIdMap() const { return static_cast<PropertyId*>(this->GetAuxPtr(AuxPointerType::ReferencedPropertyIdMap)); }",
          "3405:         PropertyId* GetReferencedPropertyIdMapWithLock() const { return static_cast<PropertyId*>(this->GetAuxPtrWithLock(AuxPointerType::ReferencedPropertyIdMap)); }",
          "3406:         void SetReferencedPropertyIdMap(PropertyId* propIdMap) { this->SetAuxPtr(AuxPointerType::ReferencedPropertyIdMap, propIdMap); }",
          "3407:         void CreateReferencedPropertyIdMap(uint referencedPropertyIdCount);",
          "3408:         void CreateReferencedPropertyIdMap();",
          "3409:         PropertyId GetReferencedPropertyIdWithMapIndex(uint mapIndex);",
          "3410:         PropertyId GetReferencedPropertyIdWithMapIndexWithLock(uint mapIndex);",
          "3411:         void SetReferencedPropertyIdWithMapIndex(uint mapIndex, PropertyId propertyId);",
          "3412:         PropertyId GetReferencedPropertyId(uint index);",
          "3413:         PropertyId GetReferencedPropertyIdWithLock(uint index);",
          "3414: #if DBG",
          "3415:         void VerifyReferencedPropertyIdMap();",
          "3416: #endif",
          "3417: #ifdef ENABLE_DEBUG_CONFIG_OPTIONS",
          "3418:         void DumpFullFunctionName();",
          "3419:         void DumpFunctionId(bool pad);",
          "3420:         uint GetTraceFunctionNumber() const;",
          "3421: #endif",
          "3423:     public:",
          "3424:         uint NewObjectLiteral();",
          "3425:         void AllocateObjectLiteralTypeArray();",
          "3426:         Field(DynamicType*)* GetObjectLiteralTypeRef(uint index);",
          "3427:         Field(DynamicType*)* GetObjectLiteralTypeRefWithLock(uint index);",
          "3428:         uint NewLiteralRegex();",
          "3429:         void AllocateLiteralRegexArray();",
          "3430:         Field(UnifiedRegex::RegexPattern*)* GetLiteralRegexes() const { return static_cast<Field(UnifiedRegex::RegexPattern*)*>(this->GetAuxPtr(AuxPointerType::LiteralRegexes)); }",
          "3431:         Field(UnifiedRegex::RegexPattern*)* GetLiteralRegexesWithLock() const { return static_cast<Field(UnifiedRegex::RegexPattern*)*>(this->GetAuxPtrWithLock(AuxPointerType::LiteralRegexes)); }",
          "3432:         void SetLiteralRegexs(UnifiedRegex::RegexPattern ** literalRegexes) { this->SetAuxPtr(AuxPointerType::LiteralRegexes, literalRegexes); }",
          "3433:         UnifiedRegex::RegexPattern *GetLiteralRegex(const uint index);",
          "3434:         UnifiedRegex::RegexPattern *GetLiteralRegexWithLock(const uint index);",
          "3435: #ifdef ASMJS_PLAT",
          "3436:         AsmJsFunctionInfo* GetAsmJsFunctionInfo()const { return static_cast<AsmJsFunctionInfo*>(this->GetAuxPtr(AuxPointerType::AsmJsFunctionInfo)); }",
          "3437:         AsmJsFunctionInfo* GetAsmJsFunctionInfoWithLock()const { return static_cast<AsmJsFunctionInfo*>(this->GetAuxPtrWithLock(AuxPointerType::AsmJsFunctionInfo)); }",
          "3438:         AsmJsFunctionInfo* AllocateAsmJsFunctionInfo();",
          "3439:         AsmJsModuleInfo* GetAsmJsModuleInfo()const { return static_cast<AsmJsModuleInfo*>(this->GetAuxPtr(AuxPointerType::AsmJsModuleInfo)); }",
          "3440:         AsmJsModuleInfo* GetAsmJsModuleInfoWithLock()const { return static_cast<AsmJsModuleInfo*>(this->GetAuxPtrWithLock(AuxPointerType::AsmJsModuleInfo)); }",
          "3441:         void ResetAsmJsInfo()",
          "3442:         {",
          "3443:             SetAuxPtr(AuxPointerType::AsmJsFunctionInfo, nullptr);",
          "3444:             SetAuxPtr(AuxPointerType::AsmJsModuleInfo, nullptr);",
          "3445:         }",
          "3446:         bool IsAsmJSModule()const{ return this->GetAsmJsFunctionInfo() != nullptr; }",
          "3447:         AsmJsModuleInfo* AllocateAsmJsModuleInfo();",
          "3448: #endif",
          "3449:         void SetLiteralRegex(const uint index, UnifiedRegex::RegexPattern *const pattern);",
          "3450:         Field(DynamicType*)* GetObjectLiteralTypes() const { return static_cast<Field(DynamicType*)*>(this->GetAuxPtr(AuxPointerType::ObjLiteralTypes)); }",
          "3451:         Field(DynamicType*)* GetObjectLiteralTypesWithLock() const { return static_cast<Field(DynamicType*)*>(this->GetAuxPtrWithLock(AuxPointerType::ObjLiteralTypes)); }",
          "3452:     private:",
          "3453:         void ResetLiteralRegexes();",
          "3454:         void ResetObjectLiteralTypes();",
          "3455:         void SetObjectLiteralTypes(DynamicType** objLiteralTypes) { this->SetAuxPtr(AuxPointerType::ObjLiteralTypes, objLiteralTypes); };",
          "3456:     public:",
          "3458:         void ResetByteCodeGenState();",
          "3459:         void ResetByteCodeGenVisitState();",
          "3461:         void FindClosestStatements(int32 characterOffset, StatementLocation *firstStatementLocation, StatementLocation *secondStatementLocation);",
          "3462: #if ENABLE_NATIVE_CODEGEN",
          "3463:         const FunctionCodeGenRuntimeData *GetInlineeCodeGenRuntimeData(const ProfileId profiledCallSiteId) const;",
          "3464:         const FunctionCodeGenRuntimeData *GetInlineeCodeGenRuntimeDataForTargetInlinee(const ProfileId profiledCallSiteId, FunctionBody *inlineeFuncBody) const;",
          "3465:         FunctionCodeGenRuntimeData *EnsureInlineeCodeGenRuntimeData(",
          "3466:             Recycler *const recycler,",
          "3467:             __in_range(0, profiledCallSiteCount - 1) const ProfileId profiledCallSiteId,",
          "3468:             FunctionBody *const inlinee);",
          "3469:         const FunctionCodeGenRuntimeData *GetLdFldInlineeCodeGenRuntimeData(const InlineCacheIndex inlineCacheIndex) const;",
          "3470:         FunctionCodeGenRuntimeData *EnsureLdFldInlineeCodeGenRuntimeData(",
          "3471:             Recycler *const recycler,",
          "3472:             const InlineCacheIndex inlineCacheIndex,",
          "3473:             FunctionBody *const inlinee);",
          "3475:         void LoadDynamicProfileInfo();",
          "3476:         bool HasExecutionDynamicProfileInfo() const { return hasExecutionDynamicProfileInfo; }",
          "3477:         bool HasDynamicProfileInfo() const { return dynamicProfileInfo != nullptr; }",
          "3478:         bool NeedEnsureDynamicProfileInfo() const;",
          "3479:         DynamicProfileInfo * GetDynamicProfileInfo() const { Assert(HasExecutionDynamicProfileInfo()); return dynamicProfileInfo; }",
          "3480:         DynamicProfileInfo * GetAnyDynamicProfileInfo() const { Assert(HasDynamicProfileInfo()); return dynamicProfileInfo; }",
          "3481:         DynamicProfileInfo * EnsureDynamicProfileInfo();",
          "3482:         DynamicProfileInfo * AllocateDynamicProfile();",
          "3483:         BYTE GetSavedInlinerVersion() const;",
          "3484:         uint32 GetSavedPolymorphicCacheState() const;",
          "3485:         void SetSavedPolymorphicCacheState(uint32 state);",
          "3486:         ImplicitCallFlags GetSavedImplicitCallsFlags() const;",
          "3487:         bool HasNonBuiltInCallee();",
          "3489:         void RecordNativeThrowMap(SmallSpanSequenceIter& iter, uint32 offset, uint32 statementIndex, EntryPointInfo* entryPoint, uint loopNum);",
          "3490:         void SetNativeThrowSpanSequence(SmallSpanSequence *seq, uint loopNum, LoopEntryPointInfo* entryPoint);",
          "3492:         BOOL GetMatchingStatementMapFromNativeAddress(DWORD_PTR codeAddress, StatementData &data, uint loopNum, FunctionBody *inlinee = nullptr);",
          "3493:         BOOL GetMatchingStatementMapFromNativeOffset(DWORD_PTR codeAddress, uint32 offset, StatementData &data, uint loopNum, FunctionBody *inlinee = nullptr);",
          "3495:         FunctionEntryPointInfo * GetEntryPointFromNativeAddress(DWORD_PTR codeAddress);",
          "3496:         LoopEntryPointInfo * GetLoopEntryPointInfoFromNativeAddress(DWORD_PTR codeAddress, uint loopNum) const;",
          "3497: #endif",
          "3499:         void InsertSymbolToRegSlotList(JsUtil::CharacterBuffer<WCHAR> const& propName, RegSlot reg, RegSlot totalRegsCount);",
          "3500:         void InsertSymbolToRegSlotList(RegSlot reg, PropertyId propertyId, RegSlot totalRegsCount);",
          "3501:         void SetPropertyIdsOfFormals(PropertyIdArray * formalArgs);",
          "3502:         PropertyIdArray * AllocatePropertyIdArrayForFormals(uint32 size, uint32 count, byte extraSlots);",
          "3504:         bool DontRethunkAfterBailout() const { return dontRethunkAfterBailout; }",
          "3505:         void SetDontRethunkAfterBailout() { dontRethunkAfterBailout = true; }",
          "3506:         void ClearDontRethunkAfterBailout() { dontRethunkAfterBailout = false; }",
          "3508:         void SaveState(ParseNodePtr pnode);",
          "3509:         void RestoreState(ParseNodePtr pnode);",
          "3513:         bool HasAllNonLocalReferenced() const { return m_hasAllNonLocalReferenced; }",
          "3514:         void SetAllNonLocalReferenced(bool set) { m_hasAllNonLocalReferenced = set; }",
          "3516:         bool HasSetIsObject() const { return m_hasSetIsObject; }",
          "3517:         void SetHasSetIsObject(bool set) { m_hasSetIsObject = set; }",
          "3519:         bool HasFuncExprNameReference() const { return m_hasFunExprNameReference; }",
          "3520:         void SetFuncExprNameReference(bool value) { m_hasFunExprNameReference = value; }",
          "3522:         bool GetChildCallsEval() const { return m_ChildCallsEval; }",
          "3523:         void SetChildCallsEval(bool value) { m_ChildCallsEval = value; }",
          "3525:         bool GetCallsEval() const { return m_CallsEval; }",
          "3526:         void SetCallsEval(bool set) { m_CallsEval = set; }",
          "3528:         bool HasReferenceableBuiltInArguments() const { return m_hasReferenceableBuiltInArguments; }",
          "3529:         void SetHasReferenceableBuiltInArguments(bool value) { m_hasReferenceableBuiltInArguments = value; }",
          "3531:         bool IsParamAndBodyScopeMerged() const { return m_isParamAndBodyScopeMerged; }",
          "3532:         void SetParamAndBodyScopeNotMerged() { m_isParamAndBodyScopeMerged = false; }",
          "3535:         bool HasDoneAllNonLocalReferenced() const { return m_hasDoneAllNonLocalReferenced; }",
          "3536:         void SetHasDoneAllNonLocalReferenced(bool set) { m_hasDoneAllNonLocalReferenced = set; }",
          "3539:         bool HasFunctionCompiledSent() const { return m_hasFunctionCompiledSent; }",
          "3540:         void SetHasFunctionCompiledSent(bool set) { m_hasFunctionCompiledSent = set; }",
          "3542: #if DBG_DUMP",
          "3543:         void DumpStatementMaps();",
          "3544:         void Dump();",
          "3545:         void PrintStatementSourceLine(uint statementIndex);",
          "3546:         void PrintStatementSourceLineFromStartOffset(uint cchStartOffset);",
          "3547:         void DumpScopes();",
          "3548: #endif",
          "3550:         uint GetStatementStartOffset(const uint statementIndex);",
          "3552: #ifdef IR_VIEWER",
          "3553:         void GetSourceLineFromStartOffset(const uint startOffset, LPCUTF8 *sourceBegin, LPCUTF8 *sourceEnd,",
          "3554:             ULONG * line, LONG * col);",
          "3555:         void GetStatementSourceInfo(const uint statementIndex, LPCUTF8 *sourceBegin, LPCUTF8 *sourceEnd,",
          "3556:             ULONG * line, LONG * col);",
          "3557: #endif",
          "3559: #if ENABLE_TTD",
          "3560:         void GetSourceLineFromStartOffset_TTD(const uint startOffset, ULONG* line, LONG* col);",
          "3561: #endif",
          "3563: #ifdef ENABLE_SCRIPT_PROFILING",
          "3564:         HRESULT RegisterFunction(BOOL fChangeMode, BOOL fOnlyCurrent = FALSE);",
          "3565:         HRESULT ReportScriptCompiled();",
          "3566:         HRESULT ReportFunctionCompiled();",
          "3567:         void SetEntryToProfileMode();",
          "3568: #endif",
          "3570:         void CheckAndRegisterFuncToDiag(ScriptContext *scriptContext);",
          "3571:         void SetEntryToDeferParseForDebugger();",
          "3572:         void ClearEntryPoints();",
          "3573:         void ResetEntryPoint();",
          "3574:         void CleanupToReparse();",
          "3575:         void AddDeferParseAttribute();",
          "3576:         void RemoveDeferParseAttribute();",
          "3577: #if DBG",
          "3578:         void MustBeInDebugMode();",
          "3579: #endif",
          "3581:         static bool IsDummyGlobalRetStatement(const regex::Interval *sourceSpan)",
          "3582:         {",
          "3583:             Assert(sourceSpan != nullptr);",
          "3584:             return sourceSpan->begin == 0 && sourceSpan->end == 0;",
          "3585:         }",
          "3587:         static void GetShortNameFromUrl(__in LPCWSTR pchUrl, _Out_writes_z_(cchBuffer) LPWSTR pchShortName, __in size_t cchBuffer);",
          "3589:         template<class Fn>",
          "3590:         void MapLoopHeaders(Fn fn) const",
          "3591:         {",
          "3592:             Js::LoopHeader* loopHeaderArray = this->GetLoopHeaderArray();",
          "3593:             if(loopHeaderArray)",
          "3594:             {",
          "3595:                 uint loopCount = this->GetLoopCount();",
          "3596:                 for(uint i = 0; i < loopCount; i++)",
          "3597:                 {",
          "3598:                     fn(i , &loopHeaderArray[i]);",
          "3599:                 }",
          "3600:             }",
          "3601:         }",
          "3602:         template<class Fn>",
          "3603:         void MapLoopHeadersWithLock(Fn fn) const",
          "3604:         {",
          "3605:             Js::LoopHeader* loopHeaderArray = this->GetLoopHeaderArrayWithLock();",
          "3606:             if (loopHeaderArray)",
          "3607:             {",
          "3608:                 uint loopCount = this->GetLoopCount();",
          "3609:                 for (uint i = 0; i < loopCount; i++)",
          "3610:                 {",
          "3611:                     fn(i, &loopHeaderArray[i]);",
          "3612:                 }",
          "3613:             }",
          "3614:         }",
          "3616:         template<class Fn>",
          "3617:         bool MapLoopHeadersUntil(Fn fn) const",
          "3618:         {",
          "3619:             Js::LoopHeader* loopHeaderArray = this->GetLoopHeaderArray();",
          "3620:             if (loopHeaderArray)",
          "3621:             {",
          "3622:                 uint loopCount = this->GetLoopCount();",
          "3623:                 for (uint i = 0; i < loopCount; i++)",
          "3624:                 {",
          "3625:                     if (fn(i, &loopHeaderArray[i]))",
          "3626:                     {",
          "3627:                         return true;",
          "3628:                     }",
          "3629:                 }",
          "3630:                 return false;",
          "3631:             }",
          "3632:             return false;",
          "3633:         }",
          "3635:         template <class Fn>",
          "3636:         void MapEntryPoints(Fn fn) const",
          "3637:         {",
          "3638:             if (this->entryPoints)",
          "3639:             {",
          "3640:                 this->entryPoints->Map([&fn] (int index, RecyclerWeakReference<FunctionEntryPointInfo>* entryPoint) {",
          "3641:                     FunctionEntryPointInfo* strongRef = entryPoint->Get();",
          "3642:                     if (strongRef)",
          "3643:                     {",
          "3644:                         fn(index, strongRef);",
          "3645:                     }",
          "3646:                 });",
          "3647:             }",
          "3648:         }",
          "3650:         template <class Fn>",
          "3651:         bool MapEntryPointsUntil(Fn fn) const",
          "3652:         {",
          "3653:             if (this->entryPoints)",
          "3654:             {",
          "3655:                 return this->entryPoints->MapUntil([&fn](int index, RecyclerWeakReference<FunctionEntryPointInfo>* entryPoint) {",
          "3656:                     FunctionEntryPointInfo* strongRef = entryPoint->Get();",
          "3657:                     if (strongRef)",
          "3658:                     {",
          "3659:                         return fn(index, strongRef);",
          "3660:                     }",
          "3661:                     return false;",
          "3662:                 });",
          "3663:             }",
          "3664:             return false;",
          "3665:         }",
          "3667:         bool DoJITLoopBody() const",
          "3668:         {",
          "3669:             return IsJitLoopBodyPhaseEnabled() && this->GetLoopHeaderArrayWithLock() != nullptr;",
          "3670:         }",
          "3672:         bool ForceJITLoopBody() const",
          "3673:         {",
          "3674:             return IsJitLoopBodyPhaseForced() && !this->GetHasTry();",
          "3675:         }",
          "3677:         bool IsGeneratorAndJitIsDisabled()",
          "3678:         {",
          "3679:             return this->IsCoroutine() && !(CONFIG_ISENABLED(Js::JitES6GeneratorsFlag) && !this->GetHasTry());",
          "3680:         }",
          "3682:         FunctionBodyFlags * GetAddressOfFlags() { return &this->flags; }",
          "3683:         Js::RegSlot GetRestParamRegSlot();",
          "3685:     public:",
          "3686:         void RecordConstant(RegSlot location, Var var);",
          "3688:     private:",
          "3689:         inline  void            CheckEmpty();",
          "3690:         inline  void            CheckNotExecuting();",
          "3692:         BOOL               GetMatchingStatementMap(StatementData &data, int statementIndex, FunctionBody *inlinee);",
          "3694: #if ENABLE_NATIVE_CODEGEN",
          "3695:         int                GetStatementIndexFromNativeOffset(SmallSpanSequence *pThrowSpanSequence, uint32 nativeOffset);",
          "3696:         int                GetStatementIndexFromNativeAddress(SmallSpanSequence *pThrowSpanSequence, DWORD_PTR codeAddress, DWORD_PTR nativeBaseAddress);",
          "3697: #endif",
          "3699:         void EnsureAuxStatementData();",
          "3700:         StatementAdjustmentRecordList* GetStatementAdjustmentRecords();",
          "3701:     };",
          "3703:     class AutoRestoreFunctionInfo {",
          "3704:     public:",
          "3705:         AutoRestoreFunctionInfo(ParseableFunctionInfo *pfi, const JavascriptMethod originalEntryPoint) : pfi(pfi), funcBody(nullptr), originalEntryPoint(originalEntryPoint) {}",
          "3706:         ~AutoRestoreFunctionInfo() {",
          "3707:             if (this->pfi != nullptr && this->pfi->GetFunctionInfo()->GetFunctionProxy() != this->pfi)",
          "3708:             {",
          "3709:                 FunctionInfo *functionInfo = this->pfi->GetFunctionInfo();",
          "3710:                 functionInfo->SetAttributes(",
          "3711:                     (FunctionInfo::Attributes)(functionInfo->GetAttributes() | FunctionInfo::Attributes::DeferredParse));",
          "3712:                 functionInfo->SetFunctionProxy(this->pfi);",
          "3713:                 functionInfo->SetOriginalEntryPoint(originalEntryPoint);",
          "3714:             }",
          "3716:             Assert(this->pfi == nullptr || (this->pfi->GetFunctionInfo()->GetFunctionProxy() == this->pfi && !this->pfi->IsFunctionBody()));",
          "3717:         }",
          "3718:         void Clear() { pfi = nullptr; funcBody = nullptr; }",
          "3720:         ParseableFunctionInfo * pfi;",
          "3721:         FunctionBody          * funcBody;",
          "3722:         const JavascriptMethod originalEntryPoint;",
          "3723:     };",
          "3727:     typedef SynchronizableList<FunctionBody*, JsUtil::List<FunctionBody*, ArenaAllocator, false, Js::FreeListedRemovePolicy> > FunctionBodyList;",
          "3729:     struct ScopeSlots",
          "3730:     {",
          "3731:     public:",
          "3732:         static uint const MaxEncodedSlotCount = Constants::UShortMaxValue;",
          "3735:         static uint const EncodedSlotCountSlotIndex = 0;",
          "3736:         static uint const ScopeMetadataSlotIndex = 1;    // Either a FunctionBody* or DebuggerScope*",
          "3737:         static uint const FirstSlotIndex = 2;",
          "3738:     public:",
          "3739:         ScopeSlots(Var* slotArray) : slotArray((Field(Var)*)slotArray)",
          "3740:         {",
          "3741:         }",
          "3743:         bool IsFunctionScopeSlotArray()",
          "3744:         {",
          "3745:             return FunctionInfo::Is(slotArray[ScopeMetadataSlotIndex]);",
          "3746:         }",
          "3748:         FunctionInfo* GetFunctionInfo()",
          "3749:         {",
          "3750:             Assert(IsFunctionScopeSlotArray());",
          "3751:             return (FunctionInfo*)PointerValue(slotArray[ScopeMetadataSlotIndex]);",
          "3752:         }",
          "3754:         DebuggerScope* GetDebuggerScope()",
          "3755:         {",
          "3756:             Assert(!IsFunctionScopeSlotArray());",
          "3757:             return (DebuggerScope*)PointerValue(slotArray[ScopeMetadataSlotIndex]);",
          "3758:         }",
          "3760:         Var GetScopeMetadataRaw() const",
          "3761:         {",
          "3762:             return slotArray[ScopeMetadataSlotIndex];",
          "3763:         }",
          "3765:         void SetScopeMetadata(Var scopeMetadataObj)",
          "3766:         {",
          "3767:             slotArray[ScopeMetadataSlotIndex] = scopeMetadataObj;",
          "3768:         }",
          "3770:         uint GetCount() const",
          "3771:         {",
          "3772:             return ::Math::PointerCastToIntegralTruncate<uint>(slotArray[EncodedSlotCountSlotIndex]);",
          "3773:         }",
          "3775:         void SetCount(uint count)",
          "3776:         {",
          "3777:             slotArray[EncodedSlotCountSlotIndex] = (Var)min<uint>(count, ScopeSlots::MaxEncodedSlotCount);",
          "3778:         }",
          "3780:         Var Get(uint i) const",
          "3781:         {",
          "3782:             Assert(i < GetCount());",
          "3783:             return slotArray[i + FirstSlotIndex];",
          "3784:         }",
          "3786:         void Set(uint i, Var value)",
          "3787:         {",
          "3788:             Assert(i < GetCount());",
          "3789:             slotArray[i + FirstSlotIndex] = value;",
          "3790:         }",
          "3792:         template<class Fn>",
          "3793:         void Map(Fn fn)",
          "3794:         {",
          "3795:             uint count = GetCount();",
          "3796:             for(uint i = 0; i < count; i++)",
          "3797:             {",
          "3798:                 fn(GetSlot[i]);",
          "3799:             }",
          "3800:         }",
          "3807:         static bool Is(void* object)",
          "3808:         {",
          "3809:             size_t slotCount = *((size_t*)object);",
          "3810:             if(slotCount <= MaxEncodedSlotCount)",
          "3811:             {",
          "3812:                 return true;",
          "3813:             }",
          "3814:             return false;",
          "3815:         }",
          "3817:     private:",
          "3818:         Field(Field(Var)*) slotArray;",
          "3819:     };",
          "3822:     enum ScopeType",
          "3823:     {",
          "3824:         ScopeType_ActivationObject,",
          "3825:         ScopeType_SlotArray,",
          "3826:         ScopeType_WithScope",
          "3827:     };",
          "3832:     struct FrameDisplay",
          "3833:     {",
          "3834:         FrameDisplay(uint16 len, bool strictMode = false) :",
          "3835:             tag(true),",
          "3836:             length(len),",
          "3837:             strictMode(strictMode)",
          "3838: #if _M_X64",
          "3839:             , unused(0)",
          "3840: #endif",
          "3841:         {",
          "3842:         }",
          "3844:         void SetTag(bool tag) { this->tag = tag; }",
          "3845:         void SetItem(uint index, void* item);",
          "3846:         void *GetItem(uint index);",
          "3847:         uint16 GetLength() const { return length; }",
          "3848:         void SetLength(uint16 len) { this->length = len; }",
          "3850:         bool   GetStrictMode() const { return strictMode; }",
          "3851:         void   SetStrictMode(bool flag) { this->strictMode = flag; }",
          "3853:         void** GetDataAddress() { return (void**)&this->scopes; }",
          "3854:         static uint32 GetOffsetOfStrictMode() { return offsetof(FrameDisplay, strictMode); }",
          "3855:         static uint32 GetOffsetOfLength() { return offsetof(FrameDisplay, length); }",
          "3856:         static uint32 GetOffsetOfScopes() { return offsetof(FrameDisplay, scopes); }",
          "3857:         static ScopeType GetScopeType(void* scope);",
          "3859:     private:",
          "3860:         Field(bool) tag;              // Tag it so that the NativeCodeGenerator::IsValidVar would not think this is var",
          "3861:         Field(bool) strictMode;",
          "3862:         Field(uint16) length;",
          "3864: #if defined(_M_X64_OR_ARM64)",
          "3865:         Field(uint32) unused;",
          "3866: #endif",
          "3867:         Field(void*) scopes[];",
          "3868:     };",
          "3869: #pragma region Function Body helper classes",
          "3870: #pragma region Debugging related source classes",
          "3873:     struct StatementData",
          "3874:     {",
          "3875:         StatementData()",
          "3876:             : sourceBegin(0),",
          "3877:             bytecodeBegin(0)",
          "3878:         {",
          "3879:         }",
          "3881:         int sourceBegin;",
          "3882:         int bytecodeBegin;",
          "3883:     };",
          "3885:     struct StatementLocation",
          "3886:     {",
          "3887:         Js::FunctionBody* function;",
          "3888:         regex::Interval statement;",
          "3889:         regex::Interval bytecodeSpan;",
          "3890:     };",
          "3893:     struct SmallSpan",
          "3894:     {",
          "3895:         ushort sourceBegin;",
          "3896:         ushort bytecodeBegin;",
          "3898:         SmallSpan(uint32 val)",
          "3899:         {",
          "3900:             sourceBegin = (ushort)(val >> 16);",
          "3901:             bytecodeBegin = (ushort)(val & 0x0000FFFF);",
          "3902:         }",
          "3904:         operator unsigned int()",
          "3905:         {",
          "3906:             return (uint32)sourceBegin << 16 | bytecodeBegin;",
          "3907:         }",
          "3908:     };",
          "3912:     class SmallSpanSequenceIter",
          "3913:     {",
          "3914:         friend class SmallSpanSequence;",
          "3916:     public:",
          "3917:         SmallSpanSequenceIter()",
          "3918:             : accumulatedIndex(-1),",
          "3919:             accumulatedSourceBegin(0),",
          "3920:             accumulatedBytecodeBegin(0),",
          "3921:             indexOfActualOffset(0)",
          "3922:         {",
          "3924:         }",
          "3928:         int accumulatedIndex;",
          "3929:         int accumulatedSourceBegin;",
          "3930:         int accumulatedBytecodeBegin;",
          "3932:         int indexOfActualOffset;",
          "3933:     };",
          "3935:     struct ThrowMapEntry",
          "3936:     {",
          "3937:         uint32 nativeBufferOffset;",
          "3938:         uint32 statementIndex;",
          "3939:     };",
          "3946:     class SmallSpanSequence",
          "3947:     {",
          "3948:     private:",
          "3949:         BOOL GetRangeAt(int index, SmallSpanSequenceIter &iter, int * pCountOfMissed, StatementData & data);",
          "3950:         ushort GetDiff(int current, int prev);",
          "3952:     public:",
          "3957:         JsUtil::GrowingUint32HeapArray * pStatementBuffer;",
          "3960:         JsUtil::GrowingUint32HeapArray * pActualOffsetList;",
          "3963:         int baseValue;",
          "3965:         SmallSpanSequence();",
          "3967:         ~SmallSpanSequence()",
          "3968:         {",
          "3969:             Cleanup();",
          "3970:         }",
          "3972:         void Cleanup()",
          "3973:         {",
          "3974:             if (pStatementBuffer != nullptr)",
          "3975:             {",
          "3976:                 HeapDelete(pStatementBuffer);",
          "3977:                 pStatementBuffer = nullptr;",
          "3978:             }",
          "3980:             if (pActualOffsetList != nullptr)",
          "3981:             {",
          "3982:                 HeapDelete(pActualOffsetList);",
          "3983:                 pActualOffsetList = nullptr;",
          "3984:             }",
          "3985:         }",
          "3988:         BOOL GetMatchingStatementFromBytecode(int bytecode, SmallSpanSequenceIter &iter, StatementData & data);",
          "3991:         BOOL RecordARange(SmallSpanSequenceIter &iter, StatementData * data);",
          "3994:         void Reset(SmallSpanSequenceIter &iter);",
          "3996:         uint32 Count() const { return pStatementBuffer ? pStatementBuffer->Count() : 0; }",
          "3998:         BOOL Item(int index, SmallSpanSequenceIter &iter, StatementData &data);",
          "4001:         BOOL Seek(int index, StatementData & data);",
          "4002:     };",
          "4003: #pragma endregion",
          "4007:     struct PropertyIdOnRegSlotsContainer",
          "4008:     {",
          "4009:         Field(PropertyId *) propertyIdsForRegSlots;",
          "4010:         Field(uint) length;",
          "4014:         Field(RegSlot) formalsUpperBound;",
          "4016:         Field(PropertyIdArray *) propertyIdsForFormalArgs;",
          "4018:         PropertyIdOnRegSlotsContainer();",
          "4019:         static PropertyIdOnRegSlotsContainer * New(Recycler * recycler);",
          "4021:         void CreateRegSlotsArray(Recycler * recycler, uint _length);",
          "4022:         void SetFormalArgs(PropertyIdArray * formalArgs);",
          "4025:         void Insert(RegSlot reg, PropertyId propId);",
          "4026:         void FetchItemAt(uint index, FunctionBody *pFuncBody, __out PropertyId *pPropId, __out RegSlot *pRegSlot);",
          "4028:         bool IsRegSlotFormal(RegSlot reg);",
          "4029:     };",
          "4032:     typedef int DebuggerScopePropertyFlags;",
          "4033:     const int DebuggerScopePropertyFlags_None                   = 0x000000000;",
          "4034:     const int DebuggerScopePropertyFlags_Const                  = 0x000000001;",
          "4035:     const int DebuggerScopePropertyFlags_CatchObject            = 0x000000002;",
          "4036:     const int DebuggerScopePropertyFlags_WithObject             = 0x000000004;",
          "4037:     const int DebuggerScopePropertyFlags_ForInOrOfCollection    = 0x000000008;",
          "4038:     const int DebuggerScopePropertyFlags_HasDuplicateInBody     = 0x000000016;",
          "4042:     class DebuggerScopeProperty",
          "4043:     {",
          "4044:     public:",
          "4045:         Js::PropertyId propId;              // The property ID of the scope variable.",
          "4046:         RegSlot location;                   // Contains the location of the scope variable (regslot, slotarray, direct).",
          "4047:         int byteCodeInitializationOffset;   // The byte code offset used when comparing let/const variables for dead zone exclusion debugger side.",
          "4048:         DebuggerScopePropertyFlags flags;   // Flags for the property.",
          "4050:         bool IsConst() const { return (flags & DebuggerScopePropertyFlags_Const) != 0; }",
          "4051:         bool IsCatchObject() const { return (flags & DebuggerScopePropertyFlags_CatchObject) != 0; }",
          "4052:         bool IsWithObject() const { return (flags & DebuggerScopePropertyFlags_WithObject) != 0; }",
          "4053:         bool IsForInOrForOfCollectionScope() const { return (flags & DebuggerScopePropertyFlags_ForInOrOfCollection) != 0; }",
          "4055:     public:",
          "4059:         bool IsInDeadZone(int byteCodeOffset) const",
          "4060:         {",
          "4061:             if (IsForInOrForOfCollectionScope())",
          "4062:             {",
          "4066:                 return true;",
          "4067:             }",
          "4069:             if (this->byteCodeInitializationOffset == Constants::InvalidByteCodeOffset && !(IsCatchObject() || IsWithObject()))",
          "4070:             {",
          "4071:                 AssertMsg(false, \"Debug let/const property never had its initialization point updated.  This indicates that a Ld or St operation in ByteCodeGenerator was missed that needs to have DebuggerScope::UpdatePropertyInitializationOffset() added to it.\");",
          "4072:                 return false;",
          "4073:             }",
          "4075:             return byteCodeOffset < this->byteCodeInitializationOffset;",
          "4076:         }",
          "4077:     };",
          "4080:     class DebuggerScope",
          "4081:     {",
          "4082:     public:",
          "4083:         typedef JsUtil::List<DebuggerScopeProperty> DebuggerScopePropertyList;",
          "4085:         DebuggerScope(Recycler* recycler, DiagExtraScopesType scopeType, RegSlot scopeLocation, int rangeBegin)",
          "4086:             : scopeType(scopeType),",
          "4087:               scopeProperties(nullptr),",
          "4088:               parentScope(nullptr),",
          "4089:               siblingScope(nullptr),",
          "4090:               scopeLocation(scopeLocation),",
          "4091:               recycler(recycler)",
          "4092:         {",
          "4093:             this->range.begin = rangeBegin;",
          "4094:             this->range.end = -1;",
          "4095:         }",
          "4097:         DebuggerScope * GetSiblingScope(RegSlot location, FunctionBody *functionBody);",
          "4098:         void AddProperty(RegSlot location, Js::PropertyId propertyId, DebuggerScopePropertyFlags flags);",
          "4099:         bool GetPropertyIndex(Js::PropertyId propertyId, int& i);",
          "4100:         bool HasProperty(Js::PropertyId propertyId);",
          "4102:         bool IsOffsetInScope(int offset) const;",
          "4103:         bool Contains(Js::PropertyId propertyId, RegSlot location) const;",
          "4104:         bool IsBlockScope() const;",
          "4105:         bool IsBlockObjectScope() const",
          "4106:         {",
          "4107:             return this->scopeType == Js::DiagBlockScopeInObject;",
          "4108:         }",
          "4109:         bool IsCatchScope() const;",
          "4110:         bool IsWithScope() const;",
          "4111:         bool IsSlotScope() const;",
          "4112:         bool IsParamScope() const;",
          "4113:         bool HasProperties() const;",
          "4114:         bool IsAncestorOf(const DebuggerScope* potentialChildScope);",
          "4115:         bool AreAllPropertiesInDeadZone(int byteCodeOffset) const;",
          "4116:         RegSlot GetLocation() const { Assert(IsOwnScope()); return scopeLocation; }",
          "4117:         bool IsOwnScope() const { return scopeLocation != Js::Constants::NoRegister; }",
          "4118:         bool TryGetProperty(Js::PropertyId propertyId, RegSlot location, DebuggerScopeProperty* outScopeProperty) const;",
          "4119:         bool TryGetValidProperty(Js::PropertyId propertyId, RegSlot location, int offset, DebuggerScopeProperty* outScopeProperty, bool* isInDeadZone) const;",
          "4120:         bool UpdatePropertyInitializationOffset(RegSlot location, Js::PropertyId propertyId, int byteCodeOffset, bool isFunctionDeclaration = false);",
          "4121:         void UpdateDueToByteCodeRegeneration(DiagExtraScopesType scopeType, int start, RegSlot scopeLocation);",
          "4122:         void UpdatePropertiesInForInOrOfCollectionScope();",
          "4124:         void SetParentScope(DebuggerScope* parentScope) { this->parentScope = parentScope; }",
          "4125:         DebuggerScope* GetParentScope() const { return parentScope; }",
          "4126:         DebuggerScope* FindCommonAncestor(DebuggerScope* debuggerScope);",
          "4127:         int GetEnd() const { return range.end; }",
          "4128:         int GetStart() const { return range.begin; }",
          "4130:         void SetScopeLocation(RegSlot scopeLocation) { this->scopeLocation = scopeLocation; }",
          "4132:         void SetBegin(int begin);",
          "4133:         void SetEnd(int end);",
          "4134: #if DBG",
          "4135:         void Dump();",
          "4136:         PCWSTR GetDebuggerScopeTypeString(DiagExtraScopesType scopeType);",
          "4137: #endif",
          "4139: #if ENABLE_TTD",
          "4140:         Js::PropertyId GetPropertyIdForSlotIndex_TTD(uint32 slotIndex) const;",
          "4141: #endif",
          "4143:     public:",
          "4148:         Field(DebuggerScopePropertyList*) scopeProperties;",
          "4149:         Field(DiagExtraScopesType) scopeType; // The type of scope being represented (With, Catch, or Block scope).",
          "4150:         Field(DebuggerScope*) siblingScope;  // Valid only when current scope is slot/activationobject and symbols are on direct regslot",
          "4151:         static const int InvalidScopeIndex = -1;",
          "4152:     private:",
          "4153:         int GetScopeDepth() const;",
          "4154:         bool UpdatePropertyInitializationOffsetInternal(RegSlot location, Js::PropertyId propertyId, int byteCodeOffset, bool isFunctionDeclaration = false);",
          "4155:         void EnsurePropertyListIsAllocated();",
          "4157:     private:",
          "4158:         Field(DebuggerScope*) parentScope;",
          "4159:         Field(regex::Interval) range; // The start and end byte code writer offsets used when comparing where the debugger is currently stopped at (breakpoint location).",
          "4160:         Field(RegSlot) scopeLocation;",
          "4161:         FieldNoBarrier(Recycler*) recycler;",
          "4162:     };",
          "4164:     class ScopeObjectChain",
          "4165:     {",
          "4166:     public:",
          "4168:         typedef JsUtil::List<DebuggerScope*> ScopeObjectChainList;",
          "4170:         ScopeObjectChain(Recycler* recycler)",
          "4171:             : pScopeChain(nullptr)",
          "4172:         {",
          "4173:             pScopeChain = RecyclerNew(recycler, ScopeObjectChainList, recycler);",
          "4174:         }",
          "4180:         bool TryGetDebuggerScopePropertyInfo(PropertyId propertyId, RegSlot location, int offset, bool* isPropertyInDebuggerScope, bool *isConst, bool* isInDeadZone);",
          "4183:         Field(ScopeObjectChainList*) pScopeChain;",
          "4184:     };",
          "4185: #pragma endregion",
          "4186: } // namespace Js",
          "",
          "[Added Lines]",
          "5: #pragma once",
          "7: #include \"AuxPtrs.h\"",
          "8: #include \"CompactCounters.h\"",
          "10: struct CodeGenWorkItem;",
          "11: class SourceContextInfo;",
          "12: struct DeferredFunctionStub;",
          "13: struct CodeGenNumberChunk;",
          "14: #ifdef DYNAMIC_PROFILE_MUTATOR",
          "15: class DynamicProfileMutator;",
          "16: class DynamicProfileMutatorImpl;",
          "17: #endif",
          "18: #define MAX_FUNCTION_BODY_DEBUG_STRING_SIZE 42 //11*3+8+1",
          "20: typedef BVSparse<ArenaAllocator> ActiveFunctionSet;",
          "22: namespace Js",
          "23: {",
          "24: #pragma region Class Forward Declarations",
          "25:     class ByteCodeBufferReader;",
          "26:     class ByteCodeBufferBuilder;",
          "27:     class ByteCodeCache;",
          "28:     class ScopeInfo;",
          "29:     class SmallSpanSequence;",
          "30:     struct StatementLocation;",
          "31:     class SmallSpanSequenceIter;",
          "32:     struct StatementData;",
          "33:     struct PropertyIdOnRegSlotsContainer;",
          "35:     struct InlineCache;",
          "36:     struct PolymorphicInlineCache;",
          "37:     struct IsInstInlineCache;",
          "38:     class ScopeObjectChain;",
          "39:     class EntryPointInfo;",
          "40:     class FunctionProxy;",
          "41:     class ParseableFunctionInfo;",
          "42:     class FunctionBody;",
          "44:     class DebuggerScopeProperty;",
          "45:     class DebuggerScope;",
          "46:     class FunctionEntryPointInfo;",
          "48: #ifdef ASMJS_PLAT",
          "49:     class AsmJsFunctionInfo;",
          "50:     class AmsJsModuleInfo;",
          "51: #endif",
          "52:     class ArrayBuffer;",
          "53:     class SharedArrayBuffer;",
          "54:     class FunctionCodeGenRuntimeData;",
          "55:     class JavascriptNumber;",
          "56: #pragma endregion",
          "58:     typedef JsUtil::BaseDictionary<Js::PropertyId, const Js::PropertyRecord*, RecyclerNonLeafAllocator, PowerOf2SizePolicy, DefaultComparer, JsUtil::SimpleDictionaryEntry> PropertyRecordList;",
          "59:     typedef JsUtil::BaseHashSet<void*, Recycler, PowerOf2SizePolicy> TypeRefSet;",
          "62:     enum DiagExtraScopesType",
          "63:     {",
          "64:         DiagUnknownScope,           // Unknown scope set when deserializing bytecode and the scope is not yet known.",
          "65:         DiagWithScope,              // With scope.",
          "66:         DiagCatchScopeDirect,       // Catch scope in regslot",
          "67:         DiagCatchScopeInSlot,       // Catch scope in slot array",
          "68:         DiagCatchScopeInObject,     // Catch scope in scope object",
          "69:         DiagBlockScopeDirect,       // Block scope in regslot",
          "70:         DiagBlockScopeInSlot,       // Block scope in slot array",
          "71:         DiagBlockScopeInObject,     // Block scope in activation object",
          "72:         DiagBlockScopeRangeEnd,     // Used to end a block scope range.",
          "73:         DiagParamScope,             // The scope represents symbols at formals",
          "74:         DiagParamScopeInObject,     // The scope represents symbols at formals and formal scope in activation object",
          "75:     };",
          "77:     struct ForInCache",
          "78:     {",
          "79:         Type * type;",
          "80:         void * data;",
          "81:     };",
          "82:     class PropertyGuard",
          "83:     {",
          "84:         friend class PropertyGuardValidator;",
          "86:     private:",
          "87:         Field(intptr_t) value; // value is address of Js::Type",
          "88: #if DBG",
          "89:         Field(bool) wasReincarnated = false;",
          "90: #endif",
          "91:     public:",
          "92:         static PropertyGuard* New(Recycler* recycler) { return RecyclerNewLeaf(recycler, Js::PropertyGuard); }",
          "93:         PropertyGuard() : value(GuardValue::Uninitialized) {}",
          "94:         PropertyGuard(intptr_t value) : value(value)",
          "95:         {",
          "98:             Assert(this->value != GuardValue::Invalidated && this->value != GuardValue::Invalidated_DuringSweep);",
          "99:         }",
          "101:         inline static size_t const GetSizeOfValue() { return sizeof(((PropertyGuard*)0)->value); }",
          "102:         inline static size_t const GetOffsetOfValue() { return offsetof(PropertyGuard, value); }",
          "104:         intptr_t GetValue() const { return this->value; }",
          "105:         bool IsValid()",
          "106:         {",
          "107:             return this->value != GuardValue::Invalidated && this->value != GuardValue::Invalidated_DuringSweep;",
          "108:         }",
          "109:         bool IsInvalidatedDuringSweep() { return this->value == GuardValue::Invalidated_DuringSweep; }",
          "110:         void SetValue(intptr_t value)",
          "111:         {",
          "114:             Assert(value != GuardValue::Invalidated && value != GuardValue::Invalidated_DuringSweep);",
          "115:             this->value = value;",
          "116:         }",
          "117:         intptr_t const* GetAddressOfValue() { return &this->value; }",
          "118:         void Invalidate() { this->value = GuardValue::Invalidated; }",
          "119:         void InvalidateDuringSweep()",
          "120:         {",
          "121: #if DBG",
          "122:             wasReincarnated = true;",
          "123: #endif",
          "124:             this->value = GuardValue::Invalidated_DuringSweep;",
          "125:         }",
          "126: #if DBG",
          "127:         bool WasReincarnated() { return this->wasReincarnated; }",
          "128: #endif",
          "129:         enum GuardValue : intptr_t",
          "130:         {",
          "131:             Invalidated = 0,",
          "132:             Uninitialized = 1,",
          "133:             Invalidated_DuringSweep = 2",
          "134:         };",
          "135:     };",
          "137:     class PropertyGuardValidator",
          "138:     {",
          "140:         CompileAssert(offsetof(PropertyGuard, value) == 0);",
          "141:         CompileAssert(offsetof(ConstructorCache, guard.value) == offsetof(PropertyGuard, value));",
          "142:     };",
          "144:     class JitIndexedPropertyGuard : public Js::PropertyGuard",
          "145:     {",
          "146:     private:",
          "147:         int index;",
          "149:     public:",
          "150:         JitIndexedPropertyGuard(intptr_t value, int index):",
          "151:             Js::PropertyGuard(value), index(index) {}",
          "153:         int GetIndex() const { return this->index; }",
          "154:     };",
          "156:     class JitTypePropertyGuard : public Js::JitIndexedPropertyGuard",
          "157:     {",
          "158:     public:",
          "159:         JitTypePropertyGuard(intptr_t typeAddr, int index):",
          "160:             JitIndexedPropertyGuard(typeAddr, index) {}",
          "162:         intptr_t GetTypeAddr() const { return this->GetValue(); }",
          "164:     };",
          "166:     struct TypeGuardTransferEntry",
          "167:     {",
          "168:         PropertyId propertyId;",
          "169:         JitIndexedPropertyGuard* guards[0];",
          "171:         TypeGuardTransferEntry(): propertyId(Js::Constants::NoProperty) {}",
          "172:     };",
          "174:     class FakePropertyGuardWeakReference: public RecyclerWeakReference<Js::PropertyGuard>",
          "175:     {",
          "176:     public:",
          "177:         static FakePropertyGuardWeakReference* New(Recycler* recycler, Js::PropertyGuard* guard)",
          "178:         {",
          "179:             Assert(guard != nullptr);",
          "180:             return RecyclerNewLeaf(recycler, Js::FakePropertyGuardWeakReference, guard);",
          "181:         }",
          "182:         FakePropertyGuardWeakReference(const Js::PropertyGuard* guard)",
          "183:         {",
          "184:             this->strongRef = (char*)guard;",
          "185:             this->strongRefHeapBlock = &CollectedRecyclerWeakRefHeapBlock::Instance;",
          "186:         }",
          "188:         void Zero()",
          "189:         {",
          "190:             Assert(this->strongRef != nullptr);",
          "191:             this->strongRef = nullptr;",
          "192:         }",
          "193:     };",
          "195:     struct CtorCacheGuardTransferEntry",
          "196:     {",
          "197:         PropertyId propertyId;",
          "198:         intptr_t caches[0];",
          "200:         CtorCacheGuardTransferEntry(): propertyId(Js::Constants::NoProperty) {}",
          "201:     };",
          "203:     struct EquivalentTypeCache",
          "204:     {",
          "205:         Js::Type* types[EQUIVALENT_TYPE_CACHE_SIZE];",
          "206:         PropertyGuard *guard;",
          "207:         TypeEquivalenceRecord record;",
          "208:         uint nextEvictionVictim;",
          "209:         bool isLoadedFromProto;",
          "210:         bool hasFixedValue;",
          "212:         EquivalentTypeCache(): nextEvictionVictim(EQUIVALENT_TYPE_CACHE_SIZE) {}",
          "213:         bool ClearUnusedTypes(Recycler *recycler);",
          "214:         void SetGuard(PropertyGuard *theGuard) { this->guard = theGuard; }",
          "215:         void SetIsLoadedFromProto() { this->isLoadedFromProto = true; }",
          "216:         bool IsLoadedFromProto() const { return this->isLoadedFromProto; }",
          "217:         void SetHasFixedValue() { this->hasFixedValue = true; }",
          "218:         bool HasFixedValue() const { return this->hasFixedValue; }",
          "219:     };",
          "221:     class JitEquivalentTypeGuard : public JitIndexedPropertyGuard",
          "222:     {",
          "225:         EquivalentTypeCache* cache;",
          "226:         uint32 objTypeSpecFldId;",
          "228: #if DBG && 0",
          "230:         intptr_t originalScriptContextValue = 0;",
          "231: #endif",
          "233:     public:",
          "234:         JitEquivalentTypeGuard(intptr_t typeAddr, int index, uint32 objTypeSpecFldId):",
          "235:             JitIndexedPropertyGuard(typeAddr, index), cache(nullptr), objTypeSpecFldId(objTypeSpecFldId)",
          "236:         {",
          "237: #if DBG && 0",
          "238:             originalScriptContextValue = reinterpret_cast<intptr_t>(type->GetScriptContext());",
          "239: #endif",
          "240:         }",
          "242:         intptr_t GetTypeAddr() const { return this->GetValue(); }",
          "244:         void SetTypeAddr(const intptr_t typeAddr)",
          "245:         {",
          "246: #if DBG && 0",
          "247:             if (originalScriptContextValue == 0)",
          "248:             {",
          "249:                 originalScriptContextValue = reinterpret_cast<intptr_t>(type->GetScriptContext());",
          "250:             }",
          "251:             else",
          "252:             {",
          "253:                 AssertMsg(originalScriptContextValue == reinterpret_cast<intptr_t>(type->GetScriptContext()), \"Trying to set guard type from different script context.\");",
          "254:             }",
          "255: #endif",
          "256:             this->SetValue(typeAddr);",
          "257:         }",
          "259:         uint32 GetObjTypeSpecFldId() const",
          "260:         {",
          "261:             return this->objTypeSpecFldId;",
          "262:         }",
          "264:         Js::EquivalentTypeCache* GetCache() const",
          "265:         {",
          "266:             return this->cache;",
          "267:         }",
          "269:         void SetCache(Js::EquivalentTypeCache* cache)",
          "270:         {",
          "271:             this->cache = cache;",
          "272:         }",
          "273:     };",
          "275: #pragma region Inline Cache Info class declarations",
          "276:     class PolymorphicCacheUtilizationArray",
          "277:     {",
          "278:     private:",
          "279:         Field(byte *) utilArray;",
          "281:     public:",
          "282:         PolymorphicCacheUtilizationArray()",
          "283:             : utilArray(nullptr)",
          "284:         {",
          "285:         }",
          "286:         void EnsureUtilArray(Recycler * const recycler, Js::FunctionBody * functionBody);",
          "287:         byte* GetByteArray() { return utilArray; }",
          "288:         void SetUtil(Js::FunctionBody* functionBody, uint index, byte util);",
          "289:         byte GetUtil(Js::FunctionBody* functionBody, uint index);",
          "290:     };",
          "292:     class PolymorphicInlineCacheInfo sealed",
          "293:     {",
          "294:     private:",
          "295:         Field(InlineCachePointerArray<PolymorphicInlineCache>) polymorphicInlineCaches;",
          "296:         Field(PolymorphicCacheUtilizationArray) polymorphicCacheUtilizationArray;",
          "297:         Field(FunctionBody *) functionBody;",
          "299:     public:",
          "300:         PolymorphicInlineCacheInfo(FunctionBody * functionBody)",
          "301:             : functionBody(functionBody)",
          "302:         {",
          "303:         }",
          "305:         InlineCachePointerArray<PolymorphicInlineCache> * GetPolymorphicInlineCaches() { return &polymorphicInlineCaches; }",
          "306:         PolymorphicCacheUtilizationArray * GetUtilArray() { return &polymorphicCacheUtilizationArray; }",
          "307:         byte * GetUtilByteArray() { return polymorphicCacheUtilizationArray.GetByteArray(); }",
          "308:         FunctionBody * GetFunctionBody() const { return functionBody; }",
          "309:     };",
          "311:     class EntryPointPolymorphicInlineCacheInfo sealed",
          "312:     {",
          "313:     private:",
          "314:         Field(PolymorphicInlineCacheInfo) selfInfo;",
          "316:         typedef SListCounted<PolymorphicInlineCacheInfo*, Recycler> PolymorphicInlineCacheInfoListType;",
          "317:         Field(PolymorphicInlineCacheInfoListType) inlineeInfo;",
          "319:         static void SetPolymorphicInlineCache(PolymorphicInlineCacheInfo * polymorphicInlineCacheInfo, FunctionBody * functionBody, uint index, PolymorphicInlineCache * polymorphicInlineCache, byte polyCacheUtil);",
          "321:     public:",
          "322:         EntryPointPolymorphicInlineCacheInfo(FunctionBody * functionBody);",
          "324:         PolymorphicInlineCacheInfo * GetSelfInfo() { return &selfInfo; }",
          "325:         PolymorphicInlineCacheInfo * EnsureInlineeInfo(Recycler * recycler, FunctionBody * inlineeFunctionBody);",
          "326:         PolymorphicInlineCacheInfo * GetInlineeInfo(FunctionBody * inlineeFunctionBody);",
          "327:         SListCounted<PolymorphicInlineCacheInfo*, Recycler> * GetInlineeInfo() { return &this->inlineeInfo; }",
          "329:         void SetPolymorphicInlineCache(FunctionBody * functionBody, uint index, PolymorphicInlineCache * polymorphicInlineCache, bool isInlinee, byte polyCacheUtil);",
          "331:         template <class Fn>",
          "332:         void MapInlinees(Fn fn)",
          "333:         {",
          "334:             SListCounted<PolymorphicInlineCacheInfo*, Recycler>::Iterator iter(&inlineeInfo);",
          "335:             while (iter.Next())",
          "336:             {",
          "337:                 fn(iter.Data());",
          "338:             }",
          "339:         }",
          "340:     };",
          "341: #pragma endregion",
          "343: #ifdef FIELD_ACCESS_STATS",
          "344:     struct FieldAccessStats",
          "345:     {",
          "346:         Field(uint) totalInlineCacheCount;",
          "347:         Field(uint) noInfoInlineCacheCount;",
          "348:         Field(uint) monoInlineCacheCount;",
          "349:         Field(uint) emptyMonoInlineCacheCount;",
          "350:         Field(uint) polyInlineCacheCount;",
          "351:         Field(uint) nullPolyInlineCacheCount;",
          "352:         Field(uint) emptyPolyInlineCacheCount;",
          "353:         Field(uint) ignoredPolyInlineCacheCount;",
          "354:         Field(uint) highUtilPolyInlineCacheCount;",
          "355:         Field(uint) lowUtilPolyInlineCacheCount;",
          "356:         Field(uint) equivPolyInlineCacheCount;",
          "357:         Field(uint) nonEquivPolyInlineCacheCount;",
          "358:         Field(uint) disabledPolyInlineCacheCount;",
          "359:         Field(uint) clonedMonoInlineCacheCount;",
          "360:         Field(uint) clonedPolyInlineCacheCount;",
          "362:         FieldAccessStats() :",
          "363:             totalInlineCacheCount(0), noInfoInlineCacheCount(0), monoInlineCacheCount(0), emptyMonoInlineCacheCount(0),",
          "364:             polyInlineCacheCount(0), nullPolyInlineCacheCount(0), emptyPolyInlineCacheCount(0), ignoredPolyInlineCacheCount(0),",
          "365:             highUtilPolyInlineCacheCount(0), lowUtilPolyInlineCacheCount(0),",
          "366:             equivPolyInlineCacheCount(0), nonEquivPolyInlineCacheCount(0), disabledPolyInlineCacheCount(0),",
          "367:             clonedMonoInlineCacheCount(0), clonedPolyInlineCacheCount(0) {}",
          "369:         void Add(FieldAccessStats* other);",
          "370:     };",
          "372:     typedef FieldAccessStats* FieldAccessStatsPtr;",
          "373: #else",
          "374:     typedef void* FieldAccessStatsPtr;",
          "375: #endif",
          "377: #pragma region Entry point class declarations",
          "378:     class ProxyEntryPointInfo:  public ExpirableObject",
          "379:     {",
          "380:     public:",
          "383:         FieldNoBarrier(Js::JavascriptMethod) jsMethod;",
          "385:         ProxyEntryPointInfo(Js::JavascriptMethod jsMethod, ThreadContext* context = nullptr):",
          "386:             ExpirableObject(context),",
          "387:             jsMethod(jsMethod)",
          "388:         {",
          "389:         }",
          "390:         static DWORD GetAddressOffset() { return offsetof(ProxyEntryPointInfo, jsMethod); }",
          "391:         virtual void Expire()",
          "392:         {",
          "393:             AssertMsg(false, \"Expire called on object that doesn't support expiration\");",
          "394:         }",
          "396:         virtual void EnterExpirableCollectMode()",
          "397:         {",
          "398:             AssertMsg(false, \"EnterExpirableCollectMode called on object that doesn't support expiration\");",
          "399:         }",
          "401:         virtual bool IsFunctionEntryPointInfo() const { return false; }",
          "402:     };",
          "405:     struct TypeGuardTransferData",
          "406:     {",
          "407:         Field(unsigned int) propertyGuardCount;",
          "408:         FieldNoBarrier(TypeGuardTransferEntryIDL*) entries;",
          "409:     };",
          "411:     struct CtorCacheTransferData",
          "412:     {",
          "413:         Field(unsigned int) ctorCachesCount;",
          "414:         FieldNoBarrier(CtorCacheTransferEntryIDL **) entries;",
          "415:     };",
          "422:     class EntryPointInfo : public ProxyEntryPointInfo",
          "423:     {",
          "424:     private:",
          "425:         enum State : BYTE",
          "426:         {",
          "427:             NotScheduled,       // code gen has not been scheduled",
          "428:             CodeGenPending,     // code gen job has been scheduled",
          "429:             CodeGenQueued,      // code gen has been queued and all the code gen data has been gathered.",
          "430:             CodeGenRecorded,    // backend completed, but job still pending",
          "431:             CodeGenDone,        // code gen job successfully completed",
          "432:             JITCapReached,      // workitem created but JIT cap reached",
          "433:             PendingCleanup,     // workitem needs to be cleaned up but couldn't for some reason- it'll be cleaned up at the next opportunity",
          "434:             CleanedUp           // the entry point has been cleaned up",
          "435:         };",
          "438:         Field(const bool)          tag : 1;",
          "439:         Field(bool)                isLoopBody : 1;",
          "440:         Field(bool)                hasJittedStackClosure : 1;",
          "441:         Field(bool)                isAsmJsFunction : 1; // true if entrypoint is for asmjs function",
          "442:         Field(State)               state; // Single state member so users can query state w/o a lock",
          "443: #if ENABLE_NATIVE_CODEGEN",
          "444:         Field(BYTE)                pendingInlinerVersion;",
          "445:         Field(ImplicitCallFlags)   pendingImplicitCallFlags;",
          "446:         Field(uint32)              pendingPolymorphicCacheState;",
          "448:         class JitTransferData",
          "449:         {",
          "450:             friend EntryPointInfo;",
          "452:         private:",
          "453:             Field(TypeRefSet*) jitTimeTypeRefs;",
          "455:             Field(PinnedTypeRefsIDL*) runtimeTypeRefs;",
          "458:             Field(int) propertyGuardCount;",
          "461:             FieldNoBarrier(TypeGuardTransferEntry*) propertyGuardsByPropertyId;",
          "462:             Field(size_t) propertyGuardsByPropertyIdPlusSize;",
          "466:             FieldNoBarrier(CtorCacheGuardTransferEntry*) ctorCacheGuardsByPropertyId;",
          "467:             Field(size_t) ctorCacheGuardsByPropertyIdPlusSize;",
          "469:             Field(int) equivalentTypeGuardCount;",
          "470:             Field(int) lazyBailoutPropertyCount;",
          "474:             FieldNoBarrier(JitEquivalentTypeGuard**) equivalentTypeGuards;",
          "475:             FieldNoBarrier(Js::PropertyId*) lazyBailoutProperties;",
          "476:             FieldNoBarrier(NativeCodeData*) jitTransferRawData;",
          "477:             FieldNoBarrier(EquivalentTypeGuardOffsets*) equivalentTypeGuardOffsets;",
          "478:             Field(TypeGuardTransferData) typeGuardTransferData;",
          "479:             Field(CtorCacheTransferData) ctorCacheTransferData;",
          "481:             Field(bool) falseReferencePreventionBit;",
          "482:             Field(bool) isReady;",
          "484:         public:",
          "485:             JitTransferData():",
          "486:                 jitTimeTypeRefs(nullptr), runtimeTypeRefs(nullptr),",
          "487:                 propertyGuardCount(0), propertyGuardsByPropertyId(nullptr), propertyGuardsByPropertyIdPlusSize(0),",
          "488:                 ctorCacheGuardsByPropertyId(nullptr), ctorCacheGuardsByPropertyIdPlusSize(0),",
          "489:                 equivalentTypeGuardCount(0), equivalentTypeGuards(nullptr), jitTransferRawData(nullptr),",
          "490:                 falseReferencePreventionBit(true), isReady(false), lazyBailoutProperties(nullptr), lazyBailoutPropertyCount(0){}",
          "492:             void SetRawData(NativeCodeData* rawData) { jitTransferRawData = rawData; }",
          "493:             void AddJitTimeTypeRef(void* typeRef, Recycler* recycler);",
          "495:             int GetRuntimeTypeRefCount() { return this->runtimeTypeRefs ? this->runtimeTypeRefs->count : 0; }",
          "496:             void** GetRuntimeTypeRefs() { return this->runtimeTypeRefs ? (void**)this->runtimeTypeRefs->typeRefs : nullptr; }",
          "497:             void SetRuntimeTypeRefs(PinnedTypeRefsIDL* pinnedTypeRefs) { this->runtimeTypeRefs = pinnedTypeRefs;}",
          "499:             JitEquivalentTypeGuard** GetEquivalentTypeGuards() const { return this->equivalentTypeGuards; }",
          "500:             void SetEquivalentTypeGuards(JitEquivalentTypeGuard** guards, int count)",
          "501:             {",
          "502:                 this->equivalentTypeGuardCount = count;",
          "503:                 this->equivalentTypeGuards = guards;",
          "504:             }",
          "505:             void SetLazyBailoutProperties(Js::PropertyId* properties, int count)",
          "506:             {",
          "507:                 this->lazyBailoutProperties = properties;",
          "508:                 this->lazyBailoutPropertyCount = count;",
          "509:             }",
          "510:             void SetEquivalentTypeGuardOffsets(EquivalentTypeGuardOffsets* offsets)",
          "511:             {",
          "512:                 equivalentTypeGuardOffsets = offsets;",
          "513:             }",
          "514:             void SetTypeGuardTransferData(JITOutputIDL* data)",
          "515:             {",
          "516:                 typeGuardTransferData.entries = data->typeGuardEntries;",
          "517:                 typeGuardTransferData.propertyGuardCount = data->propertyGuardCount;",
          "518:             }",
          "519:             void SetCtorCacheTransferData(JITOutputIDL * data)",
          "520:             {",
          "521:                 ctorCacheTransferData.entries = data->ctorCacheEntries;",
          "522:                 ctorCacheTransferData.ctorCachesCount = data->ctorCachesCount;",
          "523:             }",
          "524:             bool GetIsReady() { return this->isReady; }",
          "525:             void SetIsReady() { this->isReady = true; }",
          "527:         private:",
          "528:             void EnsureJitTimeTypeRefs(Recycler* recycler);",
          "529:         };",
          "531:         Field(NativeCodeData *) inProcJITNaticeCodedata;",
          "532:         FieldNoBarrier(char*) nativeDataBuffer;",
          "533:         union",
          "534:         {",
          "535:             Field(Field(JavascriptNumber*)*) numberArray;",
          "536:             Field(CodeGenNumberChunk*) numberChunks;",
          "537:         };",
          "538:         Field(XProcNumberPageSegment*) numberPageSegments;",
          "540:         FieldNoBarrier(SmallSpanSequence *) nativeThrowSpanSequence;",
          "541:         typedef JsUtil::BaseHashSet<RecyclerWeakReference<FunctionBody>*, Recycler, PowerOf2SizePolicy> WeakFuncRefSet;",
          "542:         Field(WeakFuncRefSet *) weakFuncRefSet;",
          "544:         typedef JsUtil::BaseDictionary<Js::PropertyId, PropertyGuard*, Recycler, PowerOf2SizePolicy> SharedPropertyGuardDictionary;",
          "545:         Field(SharedPropertyGuardDictionary*) sharedPropertyGuards;",
          "546:         typedef JsUtil::List<LazyBailOutRecord, HeapAllocator> BailOutRecordMap;",
          "547:         Field(BailOutRecordMap*) bailoutRecordMap;",
          "554:         Field(Field(FakePropertyGuardWeakReference*)*) propertyGuardWeakRefs;",
          "555:         Field(EquivalentTypeCache*) equivalentTypeCaches;",
          "556:         Field(EntryPointInfo **) registeredEquivalentTypeCacheRef;",
          "558:         Field(int) propertyGuardCount;",
          "559:         Field(int) equivalentTypeCacheCount;",
          "561:         Field(uint) inlineeFrameOffsetArrayOffset;",
          "562:         Field(uint) inlineeFrameOffsetArrayCount;",
          "564:         typedef SListCounted<ConstructorCache*, Recycler> ConstructorCacheList;",
          "565:         Field(ConstructorCacheList*) constructorCaches;",
          "567:         Field(EntryPointPolymorphicInlineCacheInfo *) polymorphicInlineCacheInfo;",
          "572:         Field(JitTransferData*) jitTransferData;",
          "575:         Field(Field(void*)*) runtimeTypeRefs;",
          "576:      protected:",
          "577: #if PDATA_ENABLED",
          "578:         Field(XDataAllocation *) xdataInfo;",
          "579: #endif",
          "580: #endif // ENABLE_NATIVE_CODEGEN",
          "582:         Field(CodeGenWorkItem *) workItem;",
          "583:         FieldNoBarrier(Js::JavascriptMethod) nativeAddress;",
          "584:         Field(ptrdiff_t) codeSize;",
          "586:     protected:",
          "587:         Field(JavascriptLibrary*) library;",
          "588: #if ENABLE_NATIVE_CODEGEN",
          "589:         typedef JsUtil::List<NativeOffsetInlineeFramePair, HeapAllocator> InlineeFrameMap;",
          "590:         Field(InlineeFrameMap*)   inlineeFrameMap;",
          "591: #endif",
          "592: #if ENABLE_DEBUG_STACK_BACK_TRACE",
          "593:         FieldNoBarrier(StackBackTrace*) cleanupStack;  // NoCheckHeapAllocator",
          "594: #endif",
          "595:     public:",
          "596:         Field(uint) frameHeight;",
          "597:         Field(bool) nativeEntryPointProcessed;",
          "599: #if ENABLE_DEBUG_CONFIG_OPTIONS",
          "600:     public:",
          "601:         enum CleanupReason",
          "602:         {",
          "603:             NotCleanedUp,",
          "604:             CodeGenFailedOOM,",
          "605:             CodeGenFailedStackOverflow,",
          "606:             CodeGenFailedAborted,",
          "607:             CodeGenFailedExceedJITLimit,",
          "608:             CodeGenFailedUnknown,",
          "609:             NativeCodeInstallFailure,",
          "610:             CleanUpForFinalize",
          "611:         };",
          "612:     private:",
          "613:         Field(CleanupReason) cleanupReason;",
          "614: #endif",
          "616: #ifdef FIELD_ACCESS_STATS",
          "617:     private:",
          "618:         Field(FieldAccessStatsPtr) fieldAccessStats;",
          "619: #endif",
          "621:     public:",
          "622:         virtual void Finalize(bool isShutdown) override;",
          "623:         virtual bool IsFunctionEntryPointInfo() const override { return true; }",
          "625: #if ENABLE_NATIVE_CODEGEN",
          "626:         char** GetNativeDataBufferRef() { return &nativeDataBuffer; }",
          "627:         char* GetNativeDataBuffer() { return nativeDataBuffer; }",
          "628:         void SetInProcJITNativeCodeData(NativeCodeData* nativeCodeData) { inProcJITNaticeCodedata = nativeCodeData; }",
          "629:         void SetNumberChunks(CodeGenNumberChunk* chunks)",
          "630:         {",
          "631:             Assert(numberPageSegments == nullptr);",
          "632:             numberChunks = chunks;",
          "633:         }",
          "634:         void SetNumberArray(Field(Js::JavascriptNumber*)* array)",
          "635:         {",
          "636:             Assert(numberPageSegments != nullptr);",
          "637:             numberArray = array;",
          "638:         }",
          "639:         void SetNumberPageSegment(XProcNumberPageSegment * segments)",
          "640:         {",
          "641:             Assert(numberPageSegments == nullptr);",
          "642:             numberPageSegments = segments;",
          "643:         }",
          "644: #endif",
          "646:     protected:",
          "647:         EntryPointInfo(Js::JavascriptMethod method, JavascriptLibrary* library, void* validationCookie, ThreadContext* context = nullptr, bool isLoopBody = false) :",
          "648:             ProxyEntryPointInfo(method, context), tag(1), nativeEntryPointProcessed(false),",
          "649: #if ENABLE_NATIVE_CODEGEN",
          "650:             nativeThrowSpanSequence(nullptr), workItem(nullptr), weakFuncRefSet(nullptr),",
          "651:             jitTransferData(nullptr), sharedPropertyGuards(nullptr), propertyGuardCount(0), propertyGuardWeakRefs(nullptr),",
          "652:             equivalentTypeCacheCount(0), equivalentTypeCaches(nullptr), constructorCaches(nullptr), state(NotScheduled), inProcJITNaticeCodedata(nullptr),",
          "653:             numberChunks(nullptr), numberPageSegments(nullptr), polymorphicInlineCacheInfo(nullptr), runtimeTypeRefs(nullptr),",
          "654:             isLoopBody(isLoopBody), hasJittedStackClosure(false), registeredEquivalentTypeCacheRef(nullptr), bailoutRecordMap(nullptr),",
          "655: #if PDATA_ENABLED",
          "656:             xdataInfo(nullptr),",
          "657: #endif",
          "658: #endif",
          "659:             library(library), codeSize(0), nativeAddress(nullptr), isAsmJsFunction(false), validationCookie(validationCookie)",
          "660: #if ENABLE_DEBUG_STACK_BACK_TRACE",
          "661:             , cleanupStack(nullptr)",
          "662: #endif",
          "663: #if ENABLE_DEBUG_CONFIG_OPTIONS",
          "664:             , cleanupReason(NotCleanedUp)",
          "665: #endif",
          "666: #if DBG_DUMP | defined(VTUNE_PROFILING)",
          "667:             , nativeOffsetMaps(&HeapAllocator::Instance)",
          "668: #endif",
          "669: #ifdef FIELD_ACCESS_STATS",
          "670:             , fieldAccessStats(nullptr)",
          "671: #endif",
          "672:         {}",
          "674:         virtual void ReleasePendingWorkItem() {};",
          "676:         virtual void OnCleanup(bool isShutdown) = 0;",
          "678: #ifdef PERF_COUNTERS",
          "679:         virtual void OnRecorded() = 0;",
          "680: #endif",
          "681:     private:",
          "682:         State GetState() const",
          "683:         {",
          "684:             Assert(this->state >= NotScheduled && this->state <= CleanedUp);",
          "685:             return this->state;",
          "686:         }",
          "688:     public:",
          "689:         ScriptContext* GetScriptContext();",
          "691:         virtual FunctionBody *GetFunctionBody() const = 0;",
          "692: #if ENABLE_NATIVE_CODEGEN",
          "693:         EntryPointPolymorphicInlineCacheInfo * EnsurePolymorphicInlineCacheInfo(Recycler * recycler, FunctionBody * functionBody);",
          "694:         EntryPointPolymorphicInlineCacheInfo * GetPolymorphicInlineCacheInfo() { return polymorphicInlineCacheInfo; }",
          "696:         JitTransferData* GetJitTransferData() { return this->jitTransferData; }",
          "697:         JitTransferData* EnsureJitTransferData(Recycler* recycler);",
          "698: #if PDATA_ENABLED",
          "699:         XDataAllocation* GetXDataInfo() { return this->xdataInfo; }",
          "700:         void SetXDataInfo(XDataAllocation* xdataInfo) { this->xdataInfo = xdataInfo; }",
          "701: #endif",
          "703: #ifdef FIELD_ACCESS_STATS",
          "704:         FieldAccessStats* GetFieldAccessStats() { return this->fieldAccessStats; }",
          "705:         FieldAccessStats* EnsureFieldAccessStats(Recycler* recycler);",
          "706: #endif",
          "708:         void PinTypeRefs(ScriptContext* scriptContext);",
          "709:         void InstallGuards(ScriptContext* scriptContext);",
          "710: #endif",
          "712:         void Cleanup(bool isShutdown, bool captureCleanupStack);",
          "714: #if ENABLE_DEBUG_STACK_BACK_TRACE",
          "715:         void CaptureCleanupStackTrace();",
          "716: #endif",
          "718:         bool IsNotScheduled() const",
          "719:         {",
          "720:             return this->GetState() == NotScheduled;",
          "721:         }",
          "723:         bool IsCodeGenPending() const",
          "724:         {",
          "725:             return this->GetState() == CodeGenPending;",
          "726:         }",
          "728:         bool IsCodeGenRecorded() const",
          "729:         {",
          "730:             return this->GetState() == CodeGenRecorded;",
          "731:         }",
          "733:         bool IsNativeCode() const",
          "734:         {",
          "735: #if ENABLE_NATIVE_CODEGEN",
          "736:             return this->GetState() == CodeGenRecorded ||",
          "737:                 this->GetState() == CodeGenDone;",
          "738: #else",
          "739:             return false;",
          "740: #endif",
          "741:         }",
          "743:         bool IsCodeGenDone() const",
          "744:         {",
          "745: #if ENABLE_NATIVE_CODEGEN",
          "746:             return this->GetState() == CodeGenDone;",
          "747: #else",
          "748:             return false;",
          "749: #endif",
          "750:         }",
          "752:         bool IsCodeGenQueued() const",
          "753:         {",
          "754: #if ENABLE_NATIVE_CODEGEN",
          "755:             return this->GetState() == CodeGenQueued;",
          "756: #else",
          "757:             return false;",
          "758: #endif",
          "759:         }",
          "761:         bool IsJITCapReached() const",
          "762:         {",
          "763: #if ENABLE_NATIVE_CODEGEN",
          "764:             return this->GetState() == JITCapReached;",
          "765: #else",
          "766:             return false;",
          "767: #endif",
          "768:         }",
          "770:         bool IsCleanedUp() const",
          "771:         {",
          "772:             return this->GetState() == CleanedUp;",
          "773:         }",
          "775:         bool IsPendingCleanup() const",
          "776:         {",
          "777:             return this->GetState() == PendingCleanup;",
          "778:         }",
          "780:         void SetPendingCleanup()",
          "781:         {",
          "782:             this->state = PendingCleanup;",
          "783:         }",
          "785: #if ENABLE_DEBUG_CONFIG_OPTIONS",
          "786:         void SetCleanupReason(CleanupReason reason)",
          "787:         {",
          "788:             this->cleanupReason = reason;",
          "789:         }",
          "790: #endif",
          "792:         bool IsLoopBody() const",
          "793:         {",
          "794:             return this->isLoopBody;",
          "795:         }",
          "797: #if ENABLE_NATIVE_CODEGEN",
          "798:         bool HasJittedStackClosure() const",
          "799:         {",
          "800:             return this->hasJittedStackClosure;",
          "801:         }",
          "803:         void SetHasJittedStackClosure()",
          "804:         {",
          "805:             this->hasJittedStackClosure = true;",
          "806:         }",
          "807: #endif",
          "809:         void Reset(bool resetStateToNotScheduled = true);",
          "811: #if ENABLE_NATIVE_CODEGEN",
          "812:         void SetCodeGenPending(CodeGenWorkItem * workItem)",
          "813:         {",
          "814:             Assert(this->GetState() == NotScheduled || this->GetState() == CleanedUp);",
          "815:             Assert(workItem != nullptr);",
          "816:             this->workItem = workItem;",
          "817:             this->state = CodeGenPending;",
          "818:         }",
          "820:         void SetCodeGenPending()",
          "821:         {",
          "822:             Assert(this->GetState() == CodeGenQueued);",
          "823:             this->state = CodeGenPending;",
          "824:         }",
          "826:         void SetCodeGenQueued()",
          "827:         {",
          "828:             Assert(this->GetState() == CodeGenPending);",
          "829:             this->state = CodeGenQueued;",
          "830:         }",
          "832:         void RevertToNotScheduled()",
          "833:         {",
          "834:             Assert(this->GetState() == CodeGenPending);",
          "835:             Assert(this->workItem != nullptr);",
          "836:             this->workItem = nullptr;",
          "837:             this->state = NotScheduled;",
          "838:         }",
          "840:         void SetCodeGenPendingWithStackAllocatedWorkItem()",
          "841:         {",
          "842:             Assert(this->GetState() == NotScheduled || this->GetState() == CleanedUp);",
          "843:             this->workItem = nullptr;",
          "844:             this->state = CodeGenPending;",
          "845:         }",
          "847:         void SetCodeGenRecorded(Js::JavascriptMethod nativeAddress, ptrdiff_t codeSize)",
          "848:         {",
          "849:             Assert(this->GetState() == CodeGenQueued);",
          "850:             Assert(codeSize > 0);",
          "851:             this->nativeAddress = nativeAddress;",
          "852:             this->codeSize = codeSize;",
          "853:             this->state = CodeGenRecorded;",
          "855: #ifdef PERF_COUNTERS",
          "856:             this->OnRecorded();",
          "857: #endif",
          "858:         }",
          "860:         void SetCodeGenDone()",
          "861:         {",
          "862:             Assert(this->GetState() == CodeGenRecorded);",
          "863:             this->state = CodeGenDone;",
          "864:             this->workItem = nullptr;",
          "865:         }",
          "867:         void SetJITCapReached()",
          "868:         {",
          "869:             Assert(this->GetState() == CodeGenQueued);",
          "870:             this->state = JITCapReached;",
          "871:             this->workItem = nullptr;",
          "872:         }",
          "874:         SmallSpanSequence* GetNativeThrowSpanSequence() const",
          "875:         {",
          "876:             Assert(this->GetState() != NotScheduled);",
          "877:             Assert(this->GetState() != CleanedUp);",
          "878:             return nativeThrowSpanSequence;",
          "879:         }",
          "881:         void SetNativeThrowSpanSequence(SmallSpanSequence* seq)",
          "882:         {",
          "883:             Assert(this->GetState() == CodeGenQueued);",
          "884:             Assert(this->nativeThrowSpanSequence == nullptr);",
          "886:             nativeThrowSpanSequence = seq;",
          "887:         }",
          "889:         bool IsInNativeAddressRange(DWORD_PTR codeAddress) {",
          "890:             return (IsNativeCode() &&",
          "891:                 codeAddress >= GetNativeAddress() &&",
          "892:                 codeAddress < GetNativeAddress() + GetCodeSize());",
          "893:         }",
          "894: #endif",
          "896:         DWORD_PTR GetNativeAddress() const",
          "897:         {",
          "899:             Assert(this->GetState() == CodeGenRecorded || this->GetState() == CodeGenDone || this->isAsmJsFunction);",
          "902:             return reinterpret_cast<DWORD_PTR>(this->nativeAddress);",
          "903:         }",
          "905:         ptrdiff_t GetCodeSize() const",
          "906:         {",
          "907:             Assert(this->GetState() == CodeGenRecorded || this->GetState() == CodeGenDone);",
          "908:             return codeSize;",
          "909:         }",
          "911:         CodeGenWorkItem * GetWorkItem() const",
          "912:         {",
          "913:             State state = this->GetState();",
          "914:             Assert(state != NotScheduled || this->workItem == nullptr);",
          "915:             Assert(state == CleanedUp && this->workItem == nullptr ||",
          "916:                 state != CleanedUp);",
          "918:             if (state == PendingCleanup)",
          "919:             {",
          "920:                 return nullptr;",
          "921:             }",
          "923:             return this->workItem;",
          "924:         }",
          "926: #ifdef ASMJS_PLAT",
          "928:         void SetCodeSize(ptrdiff_t size)",
          "929:         {",
          "930:             Assert(isAsmJsFunction);",
          "931:             this->codeSize = size;",
          "932:         }",
          "934:         void SetNativeAddress(Js::JavascriptMethod address)",
          "935:         {",
          "936:             Assert(isAsmJsFunction);",
          "937:             this->nativeAddress = address;",
          "938:         }",
          "940:         void SetIsAsmJSFunction(bool value)",
          "941:         {",
          "942:             this->isAsmJsFunction = value;",
          "943:         }",
          "944: #endif",
          "946:         bool GetIsAsmJSFunction()const",
          "947:         {",
          "948:             return this->isAsmJsFunction;",
          "949:         }",
          "951: #ifdef ASMJS_PLAT",
          "952:         void SetTJCodeGenDone()",
          "953:         {",
          "954:             Assert(isAsmJsFunction);",
          "955:             this->state = CodeGenDone;",
          "956:             this->workItem = nullptr;",
          "957:         }",
          "958: #endif",
          "960: #if ENABLE_NATIVE_CODEGEN",
          "961:         void AddWeakFuncRef(RecyclerWeakReference<FunctionBody> *weakFuncRef, Recycler *recycler);",
          "962:         WeakFuncRefSet *EnsureWeakFuncRefSet(Recycler *recycler);",
          "964:         void EnsureIsReadyToCall();",
          "965:         void ProcessJitTransferData();",
          "966:         void ResetOnLazyBailoutFailure();",
          "967:         void OnNativeCodeInstallFailure();",
          "968:         virtual void ResetOnNativeCodeInstallFailure() = 0;",
          "970:         Js::PropertyGuard* RegisterSharedPropertyGuard(Js::PropertyId propertyId, ScriptContext* scriptContext);",
          "971:         Js::PropertyId* GetSharedPropertyGuards(_Out_ unsigned int& count);",
          "973:         bool TryGetSharedPropertyGuard(Js::PropertyId propertyId, Js::PropertyGuard*& guard);",
          "974:         void RecordTypeGuards(int propertyGuardCount, TypeGuardTransferEntry* typeGuardTransferRecord, size_t typeGuardTransferPlusSize);",
          "975:         void RecordCtorCacheGuards(CtorCacheGuardTransferEntry* ctorCacheTransferRecord, size_t ctorCacheTransferPlusSize);",
          "976:         void FreePropertyGuards();",
          "977:         void FreeJitTransferData();",
          "978:         void RegisterEquivalentTypeCaches();",
          "979:         void UnregisterEquivalentTypeCaches();",
          "980:         bool ClearEquivalentTypeCaches();",
          "982:         void RegisterConstructorCache(Js::ConstructorCache* constructorCache, Recycler* recycler);",
          "983:         uint GetConstructorCacheCount() const { return this->constructorCaches != nullptr ? this->constructorCaches->Count() : 0; }",
          "984:         uint32 GetPendingPolymorphicCacheState() const { return this->pendingPolymorphicCacheState; }",
          "985:         void SetPendingPolymorphicCacheState(uint32 state) { this->pendingPolymorphicCacheState = state; }",
          "986:         BYTE GetPendingInlinerVersion() const { return this->pendingInlinerVersion; }",
          "987:         void SetPendingInlinerVersion(BYTE version) { this->pendingInlinerVersion = version; }",
          "988:         ImplicitCallFlags GetPendingImplicitCallFlags() const { return this->pendingImplicitCallFlags; }",
          "989:         void SetPendingImplicitCallFlags(ImplicitCallFlags flags) { this->pendingImplicitCallFlags = flags; }",
          "990:         virtual void Invalidate(bool prolongEntryPoint) { Assert(false); }",
          "991:         void RecordBailOutMap(JsUtil::List<LazyBailOutRecord, ArenaAllocator>* bailoutMap);",
          "992:         void RecordInlineeFrameMap(JsUtil::List<NativeOffsetInlineeFramePair, ArenaAllocator>* tempInlineeFrameMap);",
          "993:         void RecordInlineeFrameOffsetsInfo(unsigned int offsetsArrayOffset, unsigned int offsetsArrayCount);",
          "994:         InlineeFrameRecord* FindInlineeFrame(void* returnAddress);",
          "995:         bool HasInlinees() { return this->frameHeight > 0; }",
          "996:         void DoLazyBailout(BYTE** addressOfReturnAddress, Js::FunctionBody* functionBody, const PropertyRecord* propertyRecord);",
          "997: #endif",
          "998: #if DBG_DUMP",
          "999:     public:",
          "1000: #elif defined(VTUNE_PROFILING)",
          "1001:     private:",
          "1002: #endif",
          "1003: #if DBG_DUMP || defined(VTUNE_PROFILING)",
          "1005:         struct NativeOffsetMap",
          "1006:         {",
          "1007:             uint32 statementIndex;",
          "1008:             regex::Interval nativeOffsetSpan;",
          "1009:         };",
          "1011:     private:",
          "1012:         typedef JsUtil::List<NativeOffsetMap, HeapAllocator> NativeOffsetMapListType;",
          "1013:         Field(NativeOffsetMapListType) nativeOffsetMaps;",
          "1014:     public:",
          "1015:         void RecordNativeMap(uint32 offset, uint32 statementIndex);",
          "1017:         int GetNativeOffsetMapCount() const;",
          "1018: #endif",
          "1020: #if DBG_DUMP && ENABLE_NATIVE_CODEGEN",
          "1021:         void DumpNativeOffsetMaps();",
          "1022:         void DumpNativeThrowSpanSequence();",
          "1023:         NativeOffsetMap* GetNativeOffsetMap(int index)",
          "1024:         {",
          "1025:              Assert(index >= 0);",
          "1026:              Assert(index < GetNativeOffsetMapCount());",
          "1028:              return &nativeOffsetMaps.Item(index);",
          "1029:         }",
          "1030: #endif",
          "1032: #ifdef VTUNE_PROFILING",
          "1034:     public:",
          "1035:         uint PopulateLineInfo(void* pLineInfo, FunctionBody* body);",
          "1037: #endif",
          "1039:     protected:",
          "1040:         Field(void*) validationCookie;",
          "1041:     };",
          "1043:     class FunctionEntryPointInfo : public EntryPointInfo",
          "1044:     {",
          "1045:     public:",
          "1046:         Field(FunctionProxy *) functionProxy;",
          "1047:         Field(FunctionEntryPointInfo*) nextEntryPoint;",
          "1050:         Field(int32) localVarSlotsOffset;",
          "1052:         Field(int32) localVarChangedOffset;",
          "1053:         Field(uint) entryPointIndex;",
          "1055:         Field(uint32) callsCount;",
          "1056:         Field(uint32) lastCallsCount;",
          "1058:     private:",
          "1059:         Field(ExecutionMode) jitMode;",
          "1060:         Field(FunctionEntryPointInfo*) mOldFunctionEntryPointInfo; // strong ref to oldEntryPointInfo(Int or TJ) in asm to ensure we don't collect it before JIT is completed",
          "1061:         Field(bool)       mIsTemplatizedJitMode; // true only if in TJ mode, used only for debugging",
          "1062:     public:",
          "1063:         FunctionEntryPointInfo(FunctionProxy * functionInfo, Js::JavascriptMethod method, ThreadContext* context, void* validationCookie);",
          "1065: #ifdef ASMJS_PLAT",
          "1068:         void SetOldFunctionEntryPointInfo(FunctionEntryPointInfo* entrypointInfo);",
          "1069:         FunctionEntryPointInfo* GetOldFunctionEntryPointInfo()const;",
          "1070:         void SetIsTJMode(bool value);",
          "1071:         bool GetIsTJMode()const;",
          "1073: #endif",
          "1075:         bool ExecutedSinceCallCountCollection() const;",
          "1076:         void CollectCallCounts();",
          "1078:         virtual FunctionBody *GetFunctionBody() const override;",
          "1079: #if ENABLE_NATIVE_CODEGEN",
          "1080:         ExecutionMode GetJitMode() const;",
          "1081:         void SetJitMode(const ExecutionMode jitMode);",
          "1083:         virtual void Invalidate(bool prolongEntryPoint) override;",
          "1084:         virtual void Expire() override;",
          "1085:         virtual void EnterExpirableCollectMode() override;",
          "1086:         virtual void ResetOnNativeCodeInstallFailure() override;",
          "1087:         static const uint8 GetDecrCallCountPerBailout()",
          "1088:         {",
          "1089:             return (uint8)CONFIG_FLAG(CallsToBailoutsRatioForRejit) + 1;",
          "1090:         }",
          "1091: #endif",
          "1093:         virtual void OnCleanup(bool isShutdown) override;",
          "1095:         virtual void ReleasePendingWorkItem() override;",
          "1097: #ifdef PERF_COUNTERS",
          "1098:         virtual void OnRecorded() override;",
          "1099: #endif",
          "1101:     };",
          "1103:     class LoopEntryPointInfo : public EntryPointInfo",
          "1104:     {",
          "1105:     public:",
          "1106:         Field(LoopHeader*) loopHeader;",
          "1107:         Field(uint) jittedLoopIterationsSinceLastBailout; // number of times the loop iterated in the jitted code before bailing out",
          "1108:         Field(uint) totalJittedLoopIterations; // total number of times the loop has iterated in the jitted code for this entry point for a particular invocation of the loop",
          "1109:         LoopEntryPointInfo(LoopHeader* loopHeader, Js::JavascriptLibrary* library, void* validationCookie) :",
          "1110:             EntryPointInfo(nullptr, library, validationCookie, /*threadContext*/ nullptr, /*isLoopBody*/ true),",
          "1111:             loopHeader(loopHeader),",
          "1112:             jittedLoopIterationsSinceLastBailout(0),",
          "1113:             totalJittedLoopIterations(0),",
          "1114:             mIsTemplatizedJitMode(false)",
          "1115: #ifdef BGJIT_STATS",
          "1116:             ,used(false)",
          "1117: #endif",
          "1118:         { }",
          "1120:         virtual FunctionBody *GetFunctionBody() const override;",
          "1122:         virtual void OnCleanup(bool isShutdown) override;",
          "1124: #if ENABLE_NATIVE_CODEGEN",
          "1125:         virtual void ResetOnNativeCodeInstallFailure() override;",
          "1126:         static const uint8 GetDecrLoopCountPerBailout()",
          "1127:         {",
          "1128:             return (uint8)CONFIG_FLAG(LoopIterationsToBailoutsRatioForRejit) + 1;",
          "1129:         }",
          "1130: #endif",
          "1132: #ifdef ASMJS_PLAT",
          "1133:         void SetIsTJMode(bool value)",
          "1134:         {",
          "1135:             Assert(this->GetIsAsmJSFunction());",
          "1136:             mIsTemplatizedJitMode = value;",
          "1137:         }",
          "1139:         bool GetIsTJMode()const",
          "1140:         {",
          "1141:             return mIsTemplatizedJitMode;",
          "1142:         };",
          "1143: #endif",
          "1145: #ifdef PERF_COUNTERS",
          "1146:         virtual void OnRecorded() override;",
          "1147: #endif",
          "1149: #ifdef BGJIT_STATS",
          "1150:         bool IsUsed() const",
          "1151:         {",
          "1152:             return this->used;",
          "1153:         }",
          "1155:         void MarkAsUsed()",
          "1156:         {",
          "1157:             this->used = true;",
          "1158:         }",
          "1159: #endif",
          "1160:     private:",
          "1161: #ifdef BGJIT_STATS",
          "1162:         Field(bool) used;",
          "1163: #endif",
          "1164:         Field(bool)       mIsTemplatizedJitMode;",
          "1165:     };",
          "1167:     typedef RecyclerWeakReference<FunctionEntryPointInfo> FunctionEntryPointWeakRef;",
          "1169:     typedef SynchronizableList<FunctionEntryPointWeakRef*, JsUtil::List<FunctionEntryPointWeakRef*>> FunctionEntryPointList;",
          "1170:     typedef SynchronizableList<LoopEntryPointInfo*, JsUtil::List<LoopEntryPointInfo*>> LoopEntryPointList;",
          "1172: #pragma endregion",
          "1174:     struct LoopHeader",
          "1175:     {",
          "1176:     private:",
          "1177:         Field(LoopEntryPointList*) entryPoints;",
          "1179:     public:",
          "1180:         Field(uint) startOffset;",
          "1181:         Field(uint) endOffset;",
          "1182:         Field(uint) interpretCount;",
          "1183:         Field(uint) profiledLoopCounter;",
          "1184:         Field(bool) isNested;",
          "1185:         Field(bool) isInTry;",
          "1186:         Field(FunctionBody *) functionBody;",
          "1188: #if DBG_DUMP",
          "1189:         Field(uint) nativeCount;",
          "1190: #endif",
          "1191:         static const uint NoLoop = (uint)-1;",
          "1193:         static const uint GetOffsetOfProfiledLoopCounter() { return offsetof(LoopHeader, profiledLoopCounter); }",
          "1194:         static const uint GetOffsetOfInterpretCount() { return offsetof(LoopHeader, interpretCount); }",
          "1196:         bool Contains(Js::LoopHeader * loopHeader) const",
          "1197:         {",
          "1198:             return (this->startOffset <= loopHeader->startOffset && loopHeader->endOffset <= this->endOffset);",
          "1199:         }",
          "1201:         bool Contains(uint offset) const",
          "1202:         {",
          "1203:             return this->startOffset <= offset && offset < this->endOffset;",
          "1204:         }",
          "1206:         Js::JavascriptMethod GetCurrentEntryPoint() const",
          "1207:         {",
          "1208:             LoopEntryPointInfo * entryPoint = GetCurrentEntryPointInfo();",
          "1210:             if (entryPoint != nullptr)",
          "1211:             {",
          "1212:                 return this->entryPoints->Item(this->GetCurrentEntryPointIndex())->jsMethod;",
          "1213:             }",
          "1215:             return nullptr;",
          "1216:         }",
          "1218:         LoopEntryPointInfo * GetCurrentEntryPointInfo() const",
          "1219:         {",
          "1220:             Assert(this->entryPoints->Count() > 0);",
          "1221:             return this->entryPoints->Item(this->GetCurrentEntryPointIndex());",
          "1222:         }",
          "1224:         uint GetByteCodeCount()",
          "1225:         {",
          "1226:             return (endOffset - startOffset);",
          "1227:         }",
          "1229:         int GetCurrentEntryPointIndex() const",
          "1230:         {",
          "1231:            return this->entryPoints->Count() - 1;",
          "1232:         }",
          "1234:         LoopEntryPointInfo * GetEntryPointInfo(int index) const",
          "1235:         {",
          "1236:             return this->entryPoints->Item(index);",
          "1237:         }",
          "1239:         template <class Fn>",
          "1240:         void MapEntryPoints(Fn fn) const",
          "1241:         {",
          "1242:             if (this->entryPoints) // ETW rundown may call this before entryPoints initialization",
          "1243:             {",
          "1244:                 this->entryPoints->Map([&](int index, LoopEntryPointInfo * entryPoint)",
          "1245:                 {",
          "1246:                     if (entryPoint != nullptr)",
          "1247:                     {",
          "1248:                         fn(index, entryPoint);",
          "1249:                     }",
          "1250:                 });",
          "1251:             }",
          "1252:         }",
          "1254:         template <class Fn>",
          "1255:         bool MapEntryPointsUntil(Fn fn) const",
          "1256:         {",
          "1257:             if (this->entryPoints) // ETW rundown may call this before entryPoints initialization",
          "1258:             {",
          "1259:                 return this->entryPoints->MapUntil([&](int index, LoopEntryPointInfo * entryPoint)",
          "1260:                 {",
          "1261:                     if (entryPoint != nullptr)",
          "1262:                     {",
          "1263:                         return fn(index, entryPoint);",
          "1264:                     }",
          "1265:                     return false;",
          "1266:                 });",
          "1267:             }",
          "1268:             return false;",
          "1269:         }",
          "1271:         template <class DebugSite, class Fn>",
          "1272:         HRESULT MapEntryPoints(DebugSite site, Fn fn) const // external debugging version",
          "1273:         {",
          "1274:             return Map(site, PointerValue(this->entryPoints), [&](int index, LoopEntryPointInfo * entryPoint)",
          "1275:             {",
          "1276:                 if (entryPoint != nullptr)",
          "1277:                 {",
          "1278:                     fn(index, entryPoint);",
          "1279:                 }",
          "1280:             });",
          "1281:         }",
          "1283:         void Init(FunctionBody * functionBody);",
          "1285: #if ENABLE_NATIVE_CODEGEN",
          "1286:         int CreateEntryPoint();",
          "1287:         void ReleaseEntryPoints();",
          "1288: #endif",
          "1290:         void ResetInterpreterCount()",
          "1291:         {",
          "1292:             this->interpretCount = 0;",
          "1293:         }",
          "1294:         void ResetProfiledLoopCounter()",
          "1295:         {",
          "1296:             this->profiledLoopCounter = 0;",
          "1297:         }",
          "1299:     };",
          "1305:     class FunctionProxy;",
          "1307:     typedef Field(FunctionInfo*)* FunctionInfoArray;",
          "1308:     typedef Field(FunctionInfo*)* FunctionInfoPtrPtr;",
          "1316:     class FunctionProxy : public FinalizableObject",
          "1317:     {",
          "1318:         static CriticalSection GlobalLock;",
          "1319:     public:",
          "1320:         static CriticalSection* GetLock() { return &GlobalLock; }",
          "1321:         typedef RecyclerWeakReference<DynamicType> FunctionTypeWeakRef;",
          "1322:         typedef JsUtil::List<FunctionTypeWeakRef*, Recycler, false, WeakRefFreeListedRemovePolicy> FunctionTypeWeakRefList;",
          "1324:     protected:",
          "1325:         FunctionProxy(ScriptContext* scriptContext, Utf8SourceInfo* utf8SourceInfo, uint functionNumber);",
          "1326:         DEFINE_VTABLE_CTOR_NOBASE(FunctionProxy);",
          "1328:         enum class AuxPointerType : uint8 {",
          "1329:             DeferredStubs = 0,",
          "1330:             CachedSourceString = 1,",
          "1331:             AsmJsFunctionInfo = 2,",
          "1332:             AsmJsModuleInfo = 3,",
          "1333:             StatementMaps = 4,",
          "1334:             StackNestedFuncParent = 5,",
          "1335:             SimpleJitEntryPointInfo = 6,",
          "1336:             FunctionObjectTypeList = 7,           // Script function types not including the deferred prototype type",
          "1337:             CodeGenGetSetRuntimeData = 8,",
          "1338:             PropertyIdOnRegSlotsContainer = 9,    // This is used for showing locals for the current frame.",
          "1339:             LoopHeaderArray = 10,",
          "1340:             CodeGenRuntimeData = 11,",
          "1341:             PolymorphicInlineCachesHead = 12,     // DList of all polymorphic inline caches that aren't finalized yet",
          "1342:             PropertyIdsForScopeSlotArray = 13,    // For SourceInfo",
          "1343:             PolymorphicCallSiteInfoHead  = 14,",
          "1344:             AuxBlock = 15,                        // Optional auxiliary information",
          "1345:             AuxContextBlock = 16,                 // Optional auxiliary context specific information",
          "1346:             ReferencedPropertyIdMap = 17,",
          "1347:             LiteralRegexes = 18,",
          "1348:             ObjLiteralTypes = 19,",
          "1349:             ScopeInfo = 20,",
          "1350:             FormalsPropIdArray = 21,",
          "1351:             ForInCacheArray = 22,",
          "1353:             Max,",
          "1354:             Invalid = 0xff",
          "1355:         };",
          "1357:         typedef AuxPtrs<FunctionProxy, AuxPointerType> AuxPtrsT;",
          "1358:         friend AuxPtrsT;",
          "1359:         FieldWithBarrier(AuxPtrsT*) auxPtrs;",
          "1360:         void* GetAuxPtr(AuxPointerType e) const;",
          "1361:         void* GetAuxPtrWithLock(AuxPointerType e) const;",
          "1362:         void SetAuxPtr(AuxPointerType e, void* ptr);",
          "1364:         FieldWithBarrier(FunctionInfo *) functionInfo;",
          "1366:     public:",
          "1367:         enum SetDisplayNameFlags",
          "1368:         {",
          "1369:             SetDisplayNameFlagsNone = 0,",
          "1370:             SetDisplayNameFlagsDontCopy = 1,",
          "1371:             SetDisplayNameFlagsRecyclerAllocated = 2",
          "1372:         };",
          "1374:         virtual void Dispose(bool isShutdown) override",
          "1375:         {",
          "1376:         }",
          "1378:         virtual void Mark(Recycler *recycler) override { AssertMsg(false, \"Mark called on object that isn't TrackableObject\"); }",
          "1380:         static const uint GetOffsetOfFunctionInfo() { return offsetof(FunctionProxy, functionInfo); }",
          "1381:         FunctionInfo * GetFunctionInfo() const",
          "1382:         {",
          "1383:             return this->functionInfo;",
          "1384:         }",
          "1385:         void SetFunctionInfo(FunctionInfo * functionInfo)",
          "1386:         {",
          "1387:             this->functionInfo = functionInfo;",
          "1388:         }",
          "1390:         LocalFunctionId GetLocalFunctionId() const;",
          "1391:         void SetLocalFunctionId(LocalFunctionId functionId);",
          "1393:         ParseableFunctionInfo* GetParseableFunctionInfo() const;",
          "1394:         void SetParseableFunctionInfo(ParseableFunctionInfo* func);",
          "1395:         DeferDeserializeFunctionInfo* GetDeferDeserializeFunctionInfo() const;",
          "1396:         FunctionBody * GetFunctionBody() const;",
          "1398:         void VerifyOriginalEntryPoint() const;",
          "1399:         JavascriptMethod GetOriginalEntryPoint() const;",
          "1400:         JavascriptMethod GetOriginalEntryPoint_Unchecked() const;",
          "1401:         void SetOriginalEntryPoint(const JavascriptMethod originalEntryPoint);",
          "1403:         bool IsAsync() const;",
          "1404:         bool IsDeferred() const;",
          "1405:         bool IsLambda() const;",
          "1406:         bool IsConstructor() const;",
          "1407:         bool IsGenerator() const;",
          "1408:         bool IsClassConstructor() const;",
          "1409:         bool IsClassMethod() const;",
          "1410:         bool IsModule() const;",
          "1411:         bool IsWasmFunction() const;",
          "1412:         bool HasSuperReference() const;",
          "1413:         bool IsCoroutine() const;",
          "1414:         bool GetCapturesThis() const;",
          "1415:         void SetCapturesThis();",
          "1416:         bool GetEnclosedByGlobalFunc() const;",
          "1417:         void SetEnclosedByGlobalFunc();",
          "1418:         bool CanBeDeferred() const;",
          "1419:         BOOL IsDeferredDeserializeFunction() const;",
          "1420:         BOOL IsDeferredParseFunction() const;",
          "1421:         FunctionInfo::Attributes GetAttributes() const;",
          "1422:         void SetAttributes(FunctionInfo::Attributes attributes);",
          "1424:         Recycler* GetRecycler() const;",
          "1425:         uint32 GetSourceContextId() const;",
          "1426:         char16* GetDebugNumberSet(wchar(&bufferToWriteTo)[MAX_FUNCTION_BODY_DEBUG_STRING_SIZE]) const;",
          "1427:         bool GetIsTopLevel() { return m_isTopLevel; }",
          "1428:         void SetIsTopLevel(bool set) { m_isTopLevel = set; }",
          "1429:         bool GetIsAnonymousFunction() const { return this->GetDisplayName() == Js::Constants::AnonymousFunction; }",
          "1430:         void Copy(FunctionProxy* other);",
          "1431:         ParseableFunctionInfo* EnsureDeserialized();",
          "1432:         ScriptContext* GetScriptContext() const;",
          "1433:         Utf8SourceInfo* GetUtf8SourceInfo() const { return this->m_utf8SourceInfo; }",
          "1434:         void SetUtf8SourceInfo(Utf8SourceInfo* utf8SourceInfo) { m_utf8SourceInfo = utf8SourceInfo; }",
          "1435:         bool IsInDebugMode() const { return this->m_utf8SourceInfo->IsInDebugMode(); }",
          "1437:         DWORD_PTR GetSecondaryHostSourceContext() const;",
          "1438:         DWORD_PTR GetHostSourceContext() const;",
          "1439:         SourceContextInfo * GetSourceContextInfo() const;",
          "1440:         SRCINFO const * GetHostSrcInfo() const;",
          "1442:         uint GetFunctionNumber() const { return m_functionNumber; }",
          "1444:         virtual void Finalize(bool isShutdown) override;",
          "1446:         void UpdateFunctionBodyImpl(FunctionBody* body);",
          "1447:         bool IsFunctionBody() const;",
          "1448:         uint GetCompileCount() const;",
          "1449:         void SetCompileCount(uint count);",
          "1450:         ProxyEntryPointInfo* GetDefaultEntryPointInfo() const;",
          "1451:         ScriptFunctionType * GetDeferredPrototypeType() const;",
          "1452:         ScriptFunctionType * EnsureDeferredPrototypeType();",
          "1453:         JavascriptMethod GetDirectEntryPoint(ProxyEntryPointInfo* entryPoint) const;",
          "1456:         FunctionTypeWeakRefList* EnsureFunctionObjectTypeList();",
          "1457:         FunctionTypeWeakRefList* GetFunctionObjectTypeList() const;",
          "1458:         void SetFunctionObjectTypeList(FunctionTypeWeakRefList* list);",
          "1459:         void RegisterFunctionObjectType(DynamicType* functionType);",
          "1460:         template <typename Fn>",
          "1461:         void MapFunctionObjectTypes(Fn func);",
          "1463:         static uint GetOffsetOfDeferredPrototypeType() { return static_cast<uint>(offsetof(Js::FunctionProxy, deferredPrototypeType)); }",
          "1464:         static Js::ScriptFunctionType * EnsureFunctionProxyDeferredPrototypeType(FunctionProxy * proxy)",
          "1465:         {",
          "1466:             return proxy->EnsureDeferredPrototypeType();",
          "1467:         }",
          "1469:         void SetIsPublicLibraryCode() { m_isPublicLibraryCode = true; }",
          "1470:         bool IsPublicLibraryCode() const { return m_isPublicLibraryCode; }",
          "1472: #if DBG",
          "1473:         bool HasValidEntryPoint() const;",
          "1474: #if defined(ENABLE_SCRIPT_PROFILING) || defined(ENABLE_SCRIPT_DEBUGGING)",
          "1475:         bool HasValidProfileEntryPoint() const;",
          "1476: #endif",
          "1477:         bool HasValidNonProfileEntryPoint() const;",
          "1478: #endif",
          "1479:         virtual void SetDisplayName(const char16* displayName, uint displayNameLength, uint displayShortNameOffset, SetDisplayNameFlags flags = SetDisplayNameFlagsNone) = 0;",
          "1480:         virtual const char16* GetDisplayName() const = 0;",
          "1481:         virtual uint GetDisplayNameLength() const = 0;",
          "1482:         virtual uint GetShortDisplayNameOffset() const = 0;",
          "1483:         static const char16* WrapWithBrackets(const char16* name, charcount_t sz, ScriptContext* scriptContext);",
          "1488:         const char16* GetShortDisplayName(charcount_t * shortNameLength);",
          "1490:         bool GetDisplayNameIsRecyclerAllocated() { return m_displayNameIsRecyclerAllocated; }",
          "1492:         bool IsJitLoopBodyPhaseEnabled() const",
          "1493:         {",
          "1495:             return !PHASE_OFF(JITLoopBodyPhase, this) && !PHASE_OFF(FullJitPhase, this) && !this->IsCoroutine();",
          "1496:         }",
          "1498:         bool IsJitLoopBodyPhaseForced() const",
          "1499:         {",
          "1500:             return",
          "1501:                 IsJitLoopBodyPhaseEnabled() &&",
          "1502:                 (",
          "1503:                     PHASE_FORCE(JITLoopBodyPhase, this)",
          "1504:                 #ifdef ENABLE_PREJIT",
          "1505:                     || Configuration::Global.flags.Prejit",
          "1506:                 #endif",
          "1507:                 );",
          "1508:         }",
          "1510:         ULONG GetHostStartLine() const;",
          "1511:         ULONG GetHostStartColumn() const;",
          "1513:     protected:",
          "1515:         static bool SetDisplayName(const char16* srcName, FieldWithBarrier(const char16*)* destName, uint displayNameLength, ScriptContext * scriptContext, SetDisplayNameFlags flags = SetDisplayNameFlagsNone);",
          "1516:         static bool SetDisplayName(const char16* srcName, const char16** destName, uint displayNameLength, ScriptContext * scriptContext, SetDisplayNameFlags flags = SetDisplayNameFlagsNone);",
          "1517:         static bool IsConstantFunctionName(const char16* srcName);",
          "1519:     protected:",
          "1520:         FieldNoBarrier(ScriptContext*) m_scriptContext;   // Memory context for this function body",
          "1521:         FieldWithBarrier(Utf8SourceInfo*) m_utf8SourceInfo;",
          "1522:         FieldWithBarrier(ScriptFunctionType*) deferredPrototypeType;",
          "1523:         FieldWithBarrier(ProxyEntryPointInfo*) m_defaultEntryPointInfo; // The default entry point info for the function proxy",
          "1525:         FieldWithBarrier(uint) m_functionNumber;  // Per thread global function number",
          "1527:         FieldWithBarrier(bool) m_tag11 : 1;",
          "1529:         FieldWithBarrier(bool) m_isTopLevel : 1; // Indicates that this function is top-level function, currently being used in script profiler and debugger",
          "1530:         FieldWithBarrier(bool) m_isPublicLibraryCode: 1; // Indicates this function is public boundary library code that should be visible in JS stack",
          "1531:         FieldWithBarrier(bool) m_canBeDeferred : 1;",
          "1532:         FieldWithBarrier(bool) m_displayNameIsRecyclerAllocated : 1;",
          "1535:         void CleanupFunctionProxyCounters()",
          "1536:         {",
          "1537:             PERF_COUNTER_DEC(Code, TotalFunction);",
          "1538:         }",
          "1540:         ULONG ComputeAbsoluteLineNumber(ULONG relativeLineNumber) const;",
          "1541:         ULONG ComputeAbsoluteColumnNumber(ULONG relativeLineNumber, ULONG relativeColumnNumber) const;",
          "1542:         ULONG GetLineNumberInHostBuffer(ULONG relativeLineNumber) const;",
          "1544:     private:",
          "1545:         ScriptFunctionType * AllocDeferredPrototypeType();",
          "1546:     };",
          "1548:     inline Js::LocalFunctionId FunctionProxy::GetLocalFunctionId() const",
          "1549:     {",
          "1550:         Assert(GetFunctionInfo());",
          "1551:         return GetFunctionInfo()->GetLocalFunctionId();",
          "1552:     }",
          "1554:     inline void FunctionProxy::SetLocalFunctionId(LocalFunctionId functionId)",
          "1555:     {",
          "1556:         Assert(GetFunctionInfo());",
          "1557:         Assert(GetFunctionInfo()->GetFunctionProxy() == this);",
          "1558:         return GetFunctionInfo()->SetLocalFunctionId(functionId);",
          "1559:     }",
          "1561:     inline void FunctionProxy::VerifyOriginalEntryPoint() const",
          "1562:     {",
          "1563:         Assert(GetFunctionInfo());",
          "1564:         Assert(GetFunctionInfo()->GetFunctionProxy() == this);",
          "1565:         return GetFunctionInfo()->VerifyOriginalEntryPoint();",
          "1566:     }",
          "1568:     inline JavascriptMethod FunctionProxy::GetOriginalEntryPoint() const",
          "1569:     {",
          "1570:         Assert(GetFunctionInfo());",
          "1571:         Assert(GetFunctionInfo()->GetFunctionProxy() == this);",
          "1572:         return GetFunctionInfo()->GetOriginalEntryPoint();",
          "1573:     }",
          "1575:     inline JavascriptMethod FunctionProxy::GetOriginalEntryPoint_Unchecked() const",
          "1576:     {",
          "1577:         Assert(GetFunctionInfo());",
          "1578:         Assert(GetFunctionInfo()->GetFunctionProxy() == this);",
          "1579:         return GetFunctionInfo()->GetOriginalEntryPoint_Unchecked();",
          "1580:     }",
          "1582:     inline void FunctionProxy::SetOriginalEntryPoint(const JavascriptMethod originalEntryPoint)",
          "1583:     {",
          "1584:         Assert(GetFunctionInfo());",
          "1585:         Assert(GetFunctionInfo()->GetFunctionProxy() == this);",
          "1586:         GetFunctionInfo()->SetOriginalEntryPoint(originalEntryPoint);",
          "1587:     }",
          "1589:     inline bool FunctionProxy::IsAsync() const",
          "1590:     {",
          "1591:         Assert(GetFunctionInfo());",
          "1592:         Assert(GetFunctionInfo()->GetFunctionProxy() == this);",
          "1593:         return GetFunctionInfo()->IsAsync();",
          "1594:     }",
          "1596:     inline bool FunctionProxy::IsDeferred() const",
          "1597:     {",
          "1598:         Assert(GetFunctionInfo());",
          "1599:         Assert(GetFunctionInfo()->GetFunctionProxy() == this);",
          "1600:         return GetFunctionInfo()->IsDeferred();",
          "1601:     }",
          "1603:     inline bool FunctionProxy::IsConstructor() const",
          "1604:     {",
          "1605:         Assert(GetFunctionInfo());",
          "1606:         Assert(GetFunctionInfo()->GetFunctionProxy() == this);",
          "1607:         return GetFunctionInfo()->IsConstructor();",
          "1608:     }",
          "1610:     inline bool FunctionProxy::IsGenerator() const",
          "1611:     {",
          "1612:         Assert(GetFunctionInfo());",
          "1613:         Assert(GetFunctionInfo()->GetFunctionProxy() == this);",
          "1614:         return GetFunctionInfo()->IsGenerator();",
          "1615:     }",
          "1617:     inline bool FunctionProxy::HasSuperReference() const",
          "1618:     {",
          "1619:         Assert(GetFunctionInfo());",
          "1620:         Assert(GetFunctionInfo()->GetFunctionProxy() == this);",
          "1621:         return GetFunctionInfo()->HasSuperReference();",
          "1622:     }",
          "1624:     inline bool FunctionProxy::IsCoroutine() const",
          "1625:     {",
          "1626:         Assert(GetFunctionInfo());",
          "1627:         Assert(GetFunctionInfo()->GetFunctionProxy() == this);",
          "1628:         return GetFunctionInfo()->IsCoroutine();",
          "1629:     }",
          "1631:     inline bool FunctionProxy::GetCapturesThis() const",
          "1632:     {",
          "1633:         Assert(GetFunctionInfo());",
          "1634:         Assert(GetFunctionInfo()->GetFunctionProxy() == this);",
          "1635:         return GetFunctionInfo()->GetCapturesThis();",
          "1636:     }",
          "1638:     inline void FunctionProxy::SetCapturesThis()",
          "1639:     {",
          "1640:         Assert(GetFunctionInfo());",
          "1641:         Assert(GetFunctionInfo()->GetFunctionProxy() == this);",
          "1642:         GetFunctionInfo()->SetCapturesThis();",
          "1643:     }",
          "1645:     inline bool FunctionProxy::GetEnclosedByGlobalFunc() const",
          "1646:     {",
          "1647:         Assert(GetFunctionInfo());",
          "1648:         Assert(GetFunctionInfo()->GetFunctionProxy() == this);",
          "1649:         return GetFunctionInfo()->GetEnclosedByGlobalFunc();",
          "1650:     }",
          "1652:     inline void FunctionProxy::SetEnclosedByGlobalFunc()",
          "1653:     {",
          "1654:         Assert(GetFunctionInfo());",
          "1655:         Assert(GetFunctionInfo()->GetFunctionProxy() == this);",
          "1656:         GetFunctionInfo()->SetEnclosedByGlobalFunc();",
          "1657:     }",
          "1659:     inline BOOL FunctionProxy::IsDeferredDeserializeFunction() const",
          "1660:     {",
          "1661:         Assert(GetFunctionInfo());",
          "1662:         Assert(GetFunctionInfo()->GetFunctionProxy() == this);",
          "1663:         return GetFunctionInfo()->IsDeferredDeserializeFunction();",
          "1664:     }",
          "1666:     inline BOOL FunctionProxy::IsDeferredParseFunction() const",
          "1667:     {",
          "1668:         Assert(GetFunctionInfo());",
          "1669:         Assert(GetFunctionInfo()->GetFunctionProxy() == this);",
          "1670:         return GetFunctionInfo()->IsDeferredParseFunction();",
          "1671:     }",
          "1673:     inline FunctionInfo::Attributes FunctionProxy::GetAttributes() const",
          "1674:     {",
          "1675:         Assert(GetFunctionInfo());",
          "1676:         Assert(GetFunctionInfo()->GetFunctionProxy() == this);",
          "1677:         return GetFunctionInfo()->GetAttributes();",
          "1678:     }",
          "1680:     inline void FunctionProxy::SetAttributes(FunctionInfo::Attributes attributes)",
          "1681:     {",
          "1682:         Assert(GetFunctionInfo());",
          "1683:         Assert(GetFunctionInfo()->GetFunctionProxy() == this);",
          "1684:         GetFunctionInfo()->SetAttributes(attributes);",
          "1685:     }",
          "1687:     inline void FunctionProxy::SetParseableFunctionInfo(ParseableFunctionInfo* func)",
          "1688:     {",
          "1689:         Assert(GetFunctionInfo());",
          "1690:         Assert(GetFunctionInfo()->GetFunctionProxy() == this);",
          "1691:         GetFunctionInfo()->SetParseableFunctionInfo(func);",
          "1692:     }",
          "1694:     inline bool FunctionProxy::IsLambda() const",
          "1695:     {",
          "1696:         Assert(GetFunctionInfo());",
          "1697:         Assert(GetFunctionInfo()->GetFunctionProxy() == this);",
          "1698:         return GetFunctionInfo()->IsLambda();",
          "1699:     }",
          "1701:     inline bool FunctionProxy::CanBeDeferred() const",
          "1702:     {",
          "1703:         Assert(GetFunctionInfo());",
          "1704:         Assert(GetFunctionInfo()->GetFunctionProxy() == this);",
          "1705:         return GetFunctionInfo()->CanBeDeferred();",
          "1706:     }",
          "1708:     inline bool FunctionProxy::IsClassConstructor() const",
          "1709:     {",
          "1710:         Assert(GetFunctionInfo());",
          "1711:         Assert(GetFunctionInfo()->GetFunctionProxy() == this);",
          "1712:         return GetFunctionInfo()->IsClassConstructor();",
          "1713:     }",
          "1715:     inline bool FunctionProxy::IsClassMethod() const",
          "1716:     {",
          "1717:         Assert(GetFunctionInfo());",
          "1718:         Assert(GetFunctionInfo()->GetFunctionProxy() == this);",
          "1719:         return GetFunctionInfo()->IsClassMethod();",
          "1720:     }",
          "1722:     inline bool FunctionProxy::IsModule() const",
          "1723:     {",
          "1724:         Assert(GetFunctionInfo());",
          "1725:         Assert(GetFunctionInfo()->GetFunctionProxy() == this);",
          "1726:         return GetFunctionInfo()->IsModule();",
          "1727:     }",
          "1729:     inline uint FunctionProxy::GetCompileCount() const",
          "1730:     {",
          "1731:         Assert(GetFunctionInfo());",
          "1732:         Assert(GetFunctionInfo()->GetFunctionProxy() == this);",
          "1733:         return GetFunctionInfo()->GetCompileCount();",
          "1734:     }",
          "1736:     inline void FunctionProxy::SetCompileCount(uint count)",
          "1737:     {",
          "1738:         Assert(GetFunctionInfo());",
          "1739:         Assert(GetFunctionInfo()->GetFunctionProxy() == this);",
          "1740:         GetFunctionInfo()->SetCompileCount(count);",
          "1741:     }",
          "1743:     inline ParseableFunctionInfo* FunctionProxy::GetParseableFunctionInfo() const",
          "1744:     {",
          "1745:         Assert(!IsDeferredDeserializeFunction());",
          "1746:         return (ParseableFunctionInfo*)this;",
          "1747:     }",
          "1749:     inline DeferDeserializeFunctionInfo* FunctionProxy::GetDeferDeserializeFunctionInfo() const",
          "1750:     {",
          "1751:         Assert(IsDeferredDeserializeFunction());",
          "1752:         return (DeferDeserializeFunctionInfo*)this;",
          "1753:     }",
          "1755:     inline FunctionBody * FunctionProxy::GetFunctionBody() const",
          "1756:     {",
          "1757:         Assert(IsFunctionBody());",
          "1758:         return (FunctionBody*)this;",
          "1759:     }",
          "1763:     class DeferDeserializeFunctionInfo: public FunctionProxy",
          "1764:     {",
          "1765:         friend struct ByteCodeSerializer;",
          "1767:     private:",
          "1768:         DeferDeserializeFunctionInfo(int nestedFunctionCount, LocalFunctionId functionId, ByteCodeCache* byteCodeCache, const byte* serializedFunction, Utf8SourceInfo* sourceInfo, ScriptContext* scriptContext, uint functionNumber, const char16* displayName, uint displayNameLength, uint displayShortNameOffset, NativeModule *nativeModule, FunctionInfo::Attributes attributes);",
          "1769:     public:",
          "1770:         static DeferDeserializeFunctionInfo* New(ScriptContext* scriptContext, int nestedFunctionCount, LocalFunctionId functionId, ByteCodeCache* byteCodeCache, const byte* serializedFunction, Utf8SourceInfo* utf8SourceInfo, const char16* displayName, uint displayNameLength, uint displayShortNameOffset, NativeModule *nativeModule, FunctionInfo::Attributes attributes);",
          "1772:         virtual void Finalize(bool isShutdown) override;",
          "1773:         FunctionBody* Deserialize();",
          "1775:         virtual const char16* GetDisplayName() const override;",
          "1776:         void SetDisplayName(const char16* displayName);",
          "1777:         virtual void SetDisplayName(const char16* displayName, uint displayNameLength, uint displayShortNameOffset, SetDisplayNameFlags flags = SetDisplayNameFlagsNone) override;",
          "1778:         virtual uint GetDisplayNameLength() const { return m_displayNameLength; }",
          "1779:         virtual uint GetShortDisplayNameOffset() const { return m_displayShortNameOffset; }",
          "1780:         LPCWSTR GetSourceInfo(int& lineNumber, int& columnNumber) const;",
          "1781:     private:",
          "1782:         Field(const byte*) m_functionBytes;",
          "1783:         Field(ByteCodeCache*) m_cache;",
          "1784:         Field(const char16 *) m_displayName;  // Optional name",
          "1785:         Field(uint) m_displayNameLength;",
          "1786:         Field(uint) m_displayShortNameOffset;",
          "1787:         Field(NativeModule *) m_nativeModule;",
          "1788:     };",
          "1790:     class ParseableFunctionInfo: public FunctionProxy",
          "1791:     {",
          "1792:         friend class ByteCodeBufferReader;",
          "1794:     public:",
          "1796:         enum FunctionBodyFlags : byte",
          "1797:         {",
          "1798:             Flags_None                     = 0x00,",
          "1799:             Flags_StackNestedFunc          = 0x01,",
          "1800:             Flags_HasOrParentHasArguments  = 0x02,",
          "1801:             Flags_HasTry                   = 0x04,",
          "1802:             Flags_HasThis                  = 0x08,",
          "1803:             Flags_NonUserCode              = 0x10,",
          "1804:             Flags_HasOnlyThisStatements    = 0x20,",
          "1805:             Flags_HasNoExplicitReturnValue = 0x40,   // Returns undefined, i.e. has no return statements or return with no expression",
          "1806:             Flags_HasRestParameter         = 0x80",
          "1807:         };",
          "1809:     protected:",
          "1810:         ParseableFunctionInfo(JavascriptMethod method, int nestedFunctionCount, LocalFunctionId functionId, Utf8SourceInfo* sourceInfo, ScriptContext* scriptContext, uint functionNumber, const char16* displayName, uint m_displayNameLength, uint displayShortNameOffset, FunctionInfo::Attributes attributes, Js::PropertyRecordList* propertyRecordList, FunctionBodyFlags flags);",
          "1812:         ParseableFunctionInfo(ParseableFunctionInfo * proxy);",
          "1814:     public:",
          "1815:         struct NestedArray",
          "1816:         {",
          "1817:             NestedArray(uint32 count): nestedCount(count) {}",
          "1819:             Field(uint32) nestedCount;",
          "1820:             Field(FunctionInfo*) functionInfoArray[];",
          "1821:         };",
          "1823:         template<typename Fn>",
          "1824:         void ForEachNestedFunc(Fn fn)",
          "1825:         {",
          "1826:             NestedArray* nestedArray = GetNestedArray();",
          "1827:             if (nestedArray != nullptr)",
          "1828:             {",
          "1829:                 for (uint i = 0; i < nestedArray->nestedCount; i++)",
          "1830:                 {",
          "1831:                     if (!fn(nestedArray->functionInfoArray[i]->GetFunctionProxy(), i))",
          "1832:                     {",
          "1833:                         break;",
          "1834:                     }",
          "1835:                 }",
          "1836:             }",
          "1837:         }",
          "1839:         NestedArray* GetNestedArray() const { return nestedArray; }",
          "1840:         uint GetNestedCount() const { return nestedArray == nullptr ? 0 : nestedArray->nestedCount; }",
          "1842:     public:",
          "1843:         static ParseableFunctionInfo* New(ScriptContext* scriptContext, int nestedFunctionCount, LocalFunctionId functionId, Utf8SourceInfo* utf8SourceInfo, const char16* displayName, uint m_displayNameLength, uint displayShortNameOffset, Js::PropertyRecordList* propertyRecordList, FunctionInfo::Attributes attributes, FunctionBodyFlags flags);",
          "1844:         static ParseableFunctionInfo* NewDeferredFunctionFromFunctionBody(FunctionBody *functionBody);",
          "1846:         DEFINE_VTABLE_CTOR_NO_REGISTER(ParseableFunctionInfo, FunctionProxy);",
          "1847:         FunctionBody* Parse(ScriptFunction ** functionRef = nullptr, bool isByteCodeDeserialization = false);",
          "1848: #ifdef ASMJS_PLAT",
          "1849:         FunctionBody* ParseAsmJs(Parser * p, __out CompileScriptException * se, __out ParseNodePtr * ptree);",
          "1850: #endif",
          "1852:         FunctionBodyFlags GetFlags() const { return flags; }",
          "1854:         static bool GetHasThis(FunctionBodyFlags flags) { return (flags & Flags_HasThis) != 0; }",
          "1855:         bool GetHasThis() const { return GetHasThis(flags); }",
          "1856:         void SetHasThis(bool has) { SetFlags(has, Flags_HasThis); }",
          "1858:         static bool GetHasTry(FunctionBodyFlags flags) { return (flags & Flags_HasTry) != 0; }",
          "1859:         bool GetHasTry() const { return GetHasTry(flags); }",
          "1860:         void SetHasTry(bool has) { SetFlags(has, Flags_HasTry); }",
          "1862:         static bool GetHasOrParentHasArguments(FunctionBodyFlags flags) { return (flags & Flags_HasOrParentHasArguments) != 0; }",
          "1863:         bool GetHasOrParentHasArguments() const { return GetHasOrParentHasArguments(flags); }",
          "1864:         void SetHasOrParentHasArguments(bool has) { SetFlags(has, Flags_HasOrParentHasArguments); }",
          "1866:         static bool DoStackNestedFunc(FunctionBodyFlags flags) { return (flags & Flags_StackNestedFunc) != 0; }",
          "1867:         bool DoStackNestedFunc() const { return DoStackNestedFunc(flags); }",
          "1868:         void SetStackNestedFunc(bool does) { SetFlags(does, Flags_StackNestedFunc); }",
          "1870:         bool IsNonUserCode() const { return (flags & Flags_NonUserCode) != 0; }",
          "1871:         void SetIsNonUserCode(bool set);",
          "1873:         bool GetHasNoExplicitReturnValue() { return (flags & Flags_HasNoExplicitReturnValue) != 0; }",
          "1874:         void SetHasNoExplicitReturnValue(bool has) { SetFlags(has, Flags_HasNoExplicitReturnValue); }",
          "1876:         bool GetHasOnlyThisStmts() const { return (flags & Flags_HasOnlyThisStatements) != 0; }",
          "1877:         void SetHasOnlyThisStmts(bool has) { SetFlags(has, Flags_HasOnlyThisStatements); }",
          "1879:         static bool GetHasRestParameter(FunctionBodyFlags flags) { return (flags & Flags_HasRestParameter) != 0; }",
          "1880:         bool GetHasRestParameter() const { return GetHasRestParameter(flags); }",
          "1881:         void SetHasRestParameter() { SetFlags(true, Flags_HasRestParameter); }",
          "1883:         virtual uint GetDisplayNameLength() const { return m_displayNameLength; }",
          "1884:         virtual uint GetShortDisplayNameOffset() const { return m_displayShortNameOffset; }",
          "1885:         bool GetIsDeclaration() const { return m_isDeclaration; }",
          "1886:         void SetIsDeclaration(const bool is) { m_isDeclaration = is; }",
          "1887:         bool GetIsAccessor() const { return m_isAccessor; }",
          "1888:         void SetIsAccessor(const bool is) { m_isAccessor = is; }",
          "1889:         bool GetIsGlobalFunc() const { return m_isGlobalFunc; }",
          "1890:         void SetIsStaticNameFunction(const bool is) { m_isStaticNameFunction = is; }",
          "1891:         bool GetIsStaticNameFunction() const { return m_isStaticNameFunction; }",
          "1892:         void SetIsNamedFunctionExpression(const bool is) { m_isNamedFunctionExpression = is; }",
          "1893:         bool GetIsNamedFunctionExpression() const { return m_isNamedFunctionExpression; }",
          "1894:         void SetIsNameIdentifierRef (const bool is) { m_isNameIdentifierRef  = is; }",
          "1895:         bool GetIsNameIdentifierRef () const { return m_isNameIdentifierRef ; }",
          "1900:         bool IsFakeGlobalFunc(uint32 flags) const;",
          "1902:         void SetIsGlobalFunc(bool is) { m_isGlobalFunc = is; }",
          "1903:         bool GetIsStrictMode() const { return m_isStrictMode; }",
          "1904:         void SetIsStrictMode() { m_isStrictMode = true; }",
          "1905:         bool GetIsAsmjsMode() const { return m_isAsmjsMode; }",
          "1906:         void SetIsAsmjsMode(bool value)",
          "1907:         {",
          "1908:             m_isAsmjsMode = value;",
          "1909:     #if DBG",
          "1910:             if (value)",
          "1911:             {",
          "1912:                 m_wasEverAsmjsMode = true;",
          "1913:             }",
          "1914:     #endif",
          "1915:         }",
          "1917:         void SetIsWasmFunction(bool val)",
          "1918:         {",
          "1919:             m_isWasmFunction = val;",
          "1920:         }",
          "1921:         bool IsWasmFunction() const",
          "1922:         {",
          "1923:             return m_isWasmFunction;",
          "1924:         }",
          "1926:         bool GetHasImplicitArgIns() { return m_hasImplicitArgIns; }",
          "1927:         void SetHasImplicitArgIns(bool has) { m_hasImplicitArgIns = has; }",
          "1928:         uint32 GetGrfscr() const;",
          "1929:         void SetGrfscr(uint32 grfscr);",
          "1944:         ArgSlot GetInParamsCount() const { return m_inParamCount; }",
          "1946:         void SetInParamsCount(ArgSlot newInParamCount);",
          "1947:         ArgSlot GetReportedInParamsCount() const;",
          "1948:         void SetReportedInParamsCount(ArgSlot newReportedInParamCount);",
          "1949:         void ResetInParams();",
          "1950:         ScopeInfo* GetScopeInfo() const { return static_cast<ScopeInfo*>(this->GetAuxPtr(AuxPointerType::ScopeInfo)); }",
          "1951:         void SetScopeInfo(ScopeInfo* scopeInfo) {  this->SetAuxPtr(AuxPointerType::ScopeInfo, scopeInfo); }",
          "1952:         PropertyId GetOrAddPropertyIdTracked(JsUtil::CharacterBuffer<WCHAR> const& propName);",
          "1953:         bool IsTrackedPropertyId(PropertyId pid);",
          "1954:         Js::PropertyRecordList* GetBoundPropertyRecords() { return this->m_boundPropertyRecords; }",
          "1955:         void SetBoundPropertyRecords(Js::PropertyRecordList* boundPropertyRecords)",
          "1956:         {",
          "1957:             Assert(this->m_boundPropertyRecords == nullptr);",
          "1958:             this->m_boundPropertyRecords = boundPropertyRecords;",
          "1959:         }",
          "1960:         void ClearBoundPropertyRecords()",
          "1961:         {",
          "1962:             this->m_boundPropertyRecords = nullptr;",
          "1963:         }",
          "1965:         void SetInitialDefaultEntryPoint();",
          "1966:         void SetDeferredParsingEntryPoint();",
          "1968:         void SetEntryPoint(ProxyEntryPointInfo* entryPoint, Js::JavascriptMethod jsMethod) {",
          "1969:             entryPoint->jsMethod = jsMethod;",
          "1970:         }",
          "1972:         bool IsDynamicScript() const;",
          "1974:         uint LengthInBytes() const { return m_cbLength; }",
          "1975:         uint StartOffset() const;",
          "1976:         ULONG GetLineNumber() const;",
          "1977:         ULONG GetColumnNumber() const;",
          "1978:         template <class T>",
          "1979:         LPCWSTR GetSourceName(const T& sourceContextInfo) const;",
          "1980:         template <class T>",
          "1981:         static LPCWSTR GetSourceName(const T& sourceContextInfo, bool m_isEval, bool m_isDynamicFunction);",
          "1982:         LPCWSTR GetSourceName() const;",
          "1983:         ULONG GetRelativeLineNumber() const { return m_lineNumber; }",
          "1984:         ULONG GetRelativeColumnNumber() const { return m_columnNumber; }",
          "1985:         uint GetSourceIndex() const;",
          "1986:         LPCUTF8 GetSource(const  char16* reason = nullptr) const;",
          "1987:         charcount_t LengthInChars() const { return m_cchLength; }",
          "1988:         charcount_t StartInDocument() const;",
          "1989:         bool IsEval() const { return m_isEval; }",
          "1990:         bool IsDynamicFunction() const;",
          "1991:         bool GetDontInline() { return m_dontInline; }",
          "1992:         void SetDontInline(bool is) { m_dontInline = is; }",
          "1993:         LPCUTF8 GetStartOfDocument(const char16* reason = nullptr) const;",
          "1994:         bool IsReparsed() const { return m_reparsed; }",
          "1995:         void SetReparsed(bool set) { m_reparsed = set; }",
          "1996:         bool GetExternalDisplaySourceName(BSTR* sourceName);",
          "1998:         bool EndsAfter(size_t offset) const;",
          "2000:         void SetDoBackendArgumentsOptimization(bool set)",
          "2001:         {",
          "2002:             m_doBackendArgumentsOptimization = set;",
          "2003:         }",
          "2005:         bool GetDoBackendArgumentsOptimization()",
          "2006:         {",
          "2007:             return m_doBackendArgumentsOptimization;",
          "2008:         }",
          "2010:         void SetDoScopeObjectCreation(bool set)",
          "2011:         {",
          "2012:             m_doScopeObjectCreation = set;",
          "2013:         }",
          "2015:         bool GetDoScopeObjectCreation()",
          "2016:         {",
          "2017:             return m_doScopeObjectCreation;",
          "2018:         }",
          "2020:         void SetUsesArgumentsObject(bool set)",
          "2021:         {",
          "2022:             if (!m_usesArgumentsObject)",
          "2023:             {",
          "2024:                 m_usesArgumentsObject = set;",
          "2025:             }",
          "2026:         }",
          "2028:         bool GetUsesArgumentsObject()",
          "2029:         {",
          "2030:             return m_usesArgumentsObject;",
          "2031:         }",
          "2033:         bool IsFunctionParsed()",
          "2034:         {",
          "2035:             return !IsDeferredParseFunction() || m_hasBeenParsed;",
          "2036:         }",
          "2038:         void SetFunctionParsed(bool hasBeenParsed)",
          "2039:         {",
          "2040:             m_hasBeenParsed = hasBeenParsed;",
          "2041:         }",
          "2043:         void SetSourceInfo(uint sourceIndex, ParseNodePtr node, bool isEval, bool isDynamicFunction);",
          "2044:         void SetSourceInfo(uint sourceIndex);",
          "2045:         void Copy(ParseableFunctionInfo * other);",
          "2046:         void Copy(FunctionBody* other);",
          "2047:         void CopyNestedArray(ParseableFunctionInfo * other);",
          "2049:         const char16* GetExternalDisplayName() const;",
          "2055:         template <class T>",
          "2056:         static const char16* GetExternalDisplayName(const T* funcBody)",
          "2057:         {",
          "2058:             Assert(funcBody != nullptr);",
          "2059:             Assert(funcBody->GetDisplayName() != nullptr);",
          "2061:             return funcBody->GetDisplayName();",
          "2062:         }",
          "2064:         virtual const char16* GetDisplayName() const override;",
          "2065:         void SetDisplayName(const char16* displayName);",
          "2066:         virtual void SetDisplayName(const char16* displayName, uint displayNameLength, uint displayShortNameOffset, SetDisplayNameFlags flags = SetDisplayNameFlagsNone) override;",
          "2068:         virtual void Finalize(bool isShutdown) override;",
          "2070:         Var GetCachedSourceString() { return this->GetAuxPtr(AuxPointerType::CachedSourceString); }",
          "2071:         void SetCachedSourceString(Var sourceString)",
          "2072:         {",
          "2073:             Assert(this->GetCachedSourceString() == nullptr);",
          "2074:             this->SetAuxPtr(AuxPointerType::CachedSourceString, sourceString);",
          "2075:         }",
          "2077:         FunctionInfoArray GetNestedFuncArray();",
          "2078:         FunctionInfo* GetNestedFunc(uint index);",
          "2079:         FunctionInfoPtrPtr GetNestedFuncReference(uint index);",
          "2080:         FunctionProxy* GetNestedFunctionProxy(uint index);",
          "2081:         ParseableFunctionInfo* GetNestedFunctionForExecution(uint index);",
          "2082:         void SetNestedFunc(FunctionInfo* nestedFunc, uint index, uint32 flags);",
          "2083:         void BuildDeferredStubs(ParseNode *pnodeFnc);",
          "2084:         DeferredFunctionStub *GetDeferredStubs() const { return static_cast<DeferredFunctionStub *>(this->GetAuxPtr(AuxPointerType::DeferredStubs)); }",
          "2085:         void SetDeferredStubs(DeferredFunctionStub *stub) { this->SetAuxPtr(AuxPointerType::DeferredStubs, stub); }",
          "2086:         void RegisterFuncToDiag(ScriptContext * scriptContext, char16 const * pszTitle);",
          "2088:     protected:",
          "2089:         static HRESULT MapDeferredReparseError(HRESULT& hrParse, const CompileScriptException& se);",
          "2091:         void SetFlags(bool does, FunctionBodyFlags newFlags)",
          "2092:         {",
          "2093:             if (does)",
          "2094:             {",
          "2095:                 flags = (FunctionBodyFlags)(flags | newFlags);",
          "2096:             }",
          "2097:             else",
          "2098:             {",
          "2099:                 flags = (FunctionBodyFlags)(flags & ~newFlags);",
          "2100:             }",
          "2101:         }",
          "2103:         FieldWithBarrier(bool) m_tag21 : 1;",
          "2104:         FieldWithBarrier(bool) m_hasBeenParsed : 1;       // Has function body been parsed- true for actual function bodies, false for deferparse",
          "2105:         FieldWithBarrier(bool) m_isDeclaration : 1;",
          "2106:         FieldWithBarrier(bool) m_isAccessor : 1;          // Function is a property getter or setter",
          "2107:         FieldWithBarrier(bool) m_isStaticNameFunction : 1;",
          "2108:         FieldWithBarrier(bool) m_isNamedFunctionExpression : 1;",
          "2109:         FieldWithBarrier(bool) m_isNameIdentifierRef  : 1;",
          "2110:         FieldWithBarrier(bool) m_isClassMember : 1;",
          "2113:         FieldWithBarrier(bool) m_isStrictMode : 1;",
          "2114:         FieldWithBarrier(bool) m_isAsmjsMode : 1;",
          "2115:         FieldWithBarrier(bool) m_isAsmJsFunction : 1;",
          "2116:         FieldWithBarrier(bool) m_isWasmFunction : 1;",
          "2117:         FieldWithBarrier(bool) m_isGlobalFunc : 1;",
          "2118:         FieldWithBarrier(bool) m_doBackendArgumentsOptimization : 1;",
          "2119:         FieldWithBarrier(bool) m_doScopeObjectCreation : 1;",
          "2120:         FieldWithBarrier(bool) m_usesArgumentsObject : 1;",
          "2123:         FieldWithBarrier(bool) m_isEval : 1;              // Source code is in 'eval'",
          "2124:         FieldWithBarrier(bool) m_isDynamicFunction : 1;   // Source code is in 'Function'",
          "2125:         FieldWithBarrier(bool) m_hasImplicitArgIns : 1;",
          "2126:         FieldWithBarrier(bool) m_dontInline : 1;            // Used by the JIT's inliner",
          "2129:         FieldWithBarrier(bool) m_reparsed : 1;",
          "2135:         FieldWithBarrier(bool) m_utf8SourceHasBeenSet;          // start of UTF8-encoded source",
          "2136:         FieldWithBarrier(uint) m_sourceIndex;             // index into the scriptContext's list of saved sources",
          "2137: #if DYNAMIC_INTERPRETER_THUNK",
          "2138:         FieldNoBarrier(void*) m_dynamicInterpreterThunk;  // Unique 'thunk' for every interpreted function - used for ETW symbol decoding.",
          "2139: #endif",
          "2140:         FieldWithBarrier(uint) m_cbStartOffset;         // pUtf8Source is this many bytes from the start of the scriptContext's source buffer.",
          "2144: #define DEFINE_PARSEABLE_FUNCTION_INFO_FIELDS 1",
          "2145: #define DECLARE_TAG_FIELD(type, name, serializableType) Field(type) name",
          "2146: #define CURRENT_ACCESS_MODIFIER protected:",
          "2147: #include \"SerializableFunctionFields.h\"",
          "2149:         FieldWithBarrier(ULONG) m_lineNumber;",
          "2150:         FieldWithBarrier(ULONG) m_columnNumber;",
          "2151:         FieldWithBarrier(const char16*) m_displayName;  // Optional name",
          "2152:         FieldWithBarrier(uint) m_displayNameLength;",
          "2153:         FieldWithBarrier(PropertyRecordList*) m_boundPropertyRecords;",
          "2154:         FieldWithBarrier(NestedArray*) nestedArray;",
          "2156:     public:",
          "2157: #if DBG",
          "2158:         FieldWithBarrier(bool) m_wasEverAsmjsMode; // has m_isAsmjsMode ever been true",
          "2159:         FieldWithBarrier(Js::LocalFunctionId) deferredParseNextFunctionId;",
          "2160: #endif",
          "2161: #if DBG",
          "2162:         FieldWithBarrier(UINT) scopeObjectSize; // If the scope is an activation object - its size",
          "2163: #endif",
          "2164:     };",
          "2170:     template <class T>",
          "2171:     LPCWSTR ParseableFunctionInfo::GetSourceName(const T& sourceContextInfo) const",
          "2172:     {",
          "2173:         return GetSourceName<T>(sourceContextInfo, this->m_isEval, this->m_isDynamicFunction);",
          "2174:     }",
          "2176:     template <class T>",
          "2177:     LPCWSTR ParseableFunctionInfo::GetSourceName(const T& sourceContextInfo, bool m_isEval, bool m_isDynamicFunction)",
          "2178:     {",
          "2179:         if (sourceContextInfo->IsDynamic())",
          "2180:         {",
          "2181:             if (m_isEval)",
          "2182:             {",
          "2183:                 return Constants::EvalCode;",
          "2184:             }",
          "2185:             else if (m_isDynamicFunction)",
          "2186:             {",
          "2187:                 return Constants::FunctionCode;",
          "2188:             }",
          "2189:             else",
          "2190:             {",
          "2191:                 return Constants::UnknownScriptCode;",
          "2192:             }",
          "2193:         }",
          "2194:         else",
          "2195:         {",
          "2196:             return sourceContextInfo->url;",
          "2197:         }",
          "2198:     }",
          "2200:     class FunctionBody : public ParseableFunctionInfo",
          "2201:     {",
          "2202:         DEFINE_VTABLE_CTOR_NO_REGISTER(FunctionBody, ParseableFunctionInfo);",
          "2204:         friend class ByteCodeBufferBuilder;",
          "2205:         friend class ByteCodeBufferReader;",
          "2206: #ifdef DYNAMIC_PROFILE_MUTATOR",
          "2207:         friend class ::DynamicProfileMutator;",
          "2208:         friend class ::DynamicProfileMutatorImpl;",
          "2209: #endif",
          "2210:         friend class RemoteFunctionBody;",
          "2212:         public:",
          "2214:             static const uint DIAGLOCALSLOTSIZE = 8;",
          "2216:             enum class CounterFields : uint8",
          "2217:             {",
          "2218:                 VarCount                                = 0,",
          "2219:                 ConstantCount                           = 1,",
          "2220:                 OutParamMaxDepth                        = 2,",
          "2221:                 ByteCodeCount                           = 3,",
          "2222:                 ByteCodeWithoutLDACount                 = 4,",
          "2223:                 ByteCodeInLoopCount                     = 5,",
          "2224:                 LoopCount                               = 6,",
          "2225:                 ForInLoopDepth                          = 7,",
          "2226:                 ProfiledForInLoopCount                  = 8,",
          "2227:                 InlineCacheCount                        = 9,",
          "2228:                 RootObjectLoadInlineCacheStart          = 10,",
          "2229:                 RootObjectLoadMethodInlineCacheStart    = 11,",
          "2230:                 RootObjectStoreInlineCacheStart         = 12,",
          "2231:                 IsInstInlineCacheCount                  = 13,",
          "2232:                 ReferencedPropertyIdCount               = 14,",
          "2233:                 ObjLiteralCount                         = 15,",
          "2234:                 LiteralRegexCount                       = 16,",
          "2235:                 InnerScopeCount                         = 17,",
          "2238:                 LocalClosureRegister                    = 18,",
          "2239:                 ParamClosureRegister                    = 19,",
          "2240:                 LocalFrameDisplayRegister               = 20,",
          "2241:                 EnvRegister                             = 21,",
          "2242:                 ThisRegisterForEventHandler             = 22,",
          "2243:                 FirstInnerScopeRegister                 = 23,",
          "2244:                 FuncExprScopeRegister                   = 24,",
          "2245:                 FirstTmpRegister                        = 25,",
          "2247:                 Max",
          "2248:             };",
          "2250:             typedef CompactCounters<FunctionBody> CounterT;",
          "2251:             FieldWithBarrier(CounterT) counters;",
          "2253:             uint32 GetCountField(FunctionBody::CounterFields fieldEnum) const",
          "2254:             {",
          "2255:                 return counters.Get(fieldEnum);",
          "2256:             }",
          "2257:             uint32 SetCountField(FunctionBody::CounterFields fieldEnum, uint32 val)",
          "2258:             {",
          "2259:                 return counters.Set(fieldEnum, val, this);",
          "2260:             }",
          "2261:             uint32 IncreaseCountField(FunctionBody::CounterFields fieldEnum)",
          "2262:             {",
          "2263:                 return counters.Increase(fieldEnum, this);",
          "2264:             }",
          "2266:             struct StatementMap",
          "2267:             {",
          "2268:                 StatementMap() : isSubexpression(false) {}",
          "2270:                 static StatementMap * New(Recycler* recycler)",
          "2271:                 {",
          "2272:                     return RecyclerNew(recycler, StatementMap);",
          "2273:                 }",
          "2275:                 FieldWithBarrier(regex::Interval) sourceSpan;",
          "2276:                 FieldWithBarrier(regex::Interval) byteCodeSpan;",
          "2277:                 FieldWithBarrier(bool) isSubexpression;",
          "2278:             };",
          "2282:             enum StatementAdjustmentType : ushort",
          "2283:             {",
          "2284:                 SAT_None = 0,",
          "2291:                 SAT_FromCurrentToNext = 0x01,",
          "2296:                 SAT_NextStatementStart = 0x02,",
          "2298:                 SAT_All = SAT_FromCurrentToNext | SAT_NextStatementStart",
          "2299:             };",
          "2301:             class StatementAdjustmentRecord",
          "2302:             {",
          "2303:                 uint m_byteCodeOffset;",
          "2304:                 StatementAdjustmentType m_adjustmentType;",
          "2305:             public:",
          "2306:                 StatementAdjustmentRecord();",
          "2307:                 StatementAdjustmentRecord(StatementAdjustmentType type, int byteCodeOffset);",
          "2308:                 StatementAdjustmentRecord(const StatementAdjustmentRecord& other);",
          "2309:                 uint GetByteCodeOffset();",
          "2310:                 StatementAdjustmentType GetAdjustmentType();",
          "2311:             };",
          "2315:             class CrossFrameEntryExitRecord",
          "2316:             {",
          "2317:                 uint m_byteCodeOffset;",
          "2319:                 bool m_isEnterBlock;",
          "2320:             public:",
          "2321:                 CrossFrameEntryExitRecord();",
          "2322:                 CrossFrameEntryExitRecord(uint byteCodeOffset, bool isEnterBlock);",
          "2323:                 CrossFrameEntryExitRecord(const CrossFrameEntryExitRecord& other);",
          "2324:                 uint GetByteCodeOffset() const;",
          "2325:                 bool GetIsEnterBlock();",
          "2326:             };",
          "2328:             typedef JsUtil::List<Js::FunctionBody::StatementMap*, ArenaAllocator> ArenaStatementMapList;",
          "2329:             typedef JsUtil::List<Js::FunctionBody::StatementMap*> StatementMapList;",
          "2332:             typedef JsUtil::List<StatementAdjustmentRecord, Recycler, /* isLeaf = */ true> StatementAdjustmentRecordList;",
          "2333:             typedef JsUtil::List<CrossFrameEntryExitRecord, Recycler, /* isLeaf = */ true> CrossFrameEntryExitRecordList;",
          "2337:             struct AuxStatementData",
          "2338:             {",
          "2341:                 Field(StatementAdjustmentRecordList*) m_statementAdjustmentRecords;",
          "2344:                 Field(CrossFrameEntryExitRecordList*) m_crossFrameBlockEntryExisRecords;",
          "2346:                 AuxStatementData();",
          "2347:             };",
          "2349:             class SourceInfo",
          "2350:             {",
          "2351:                 friend class RemoteFunctionBody;",
          "2352:                 friend class ByteCodeBufferReader;",
          "2353:                 friend class ByteCodeBufferBuilder;",
          "2355:             public:",
          "2356:                 FieldNoBarrier(SmallSpanSequence*) pSpanSequence;",
          "2358:                 FieldWithBarrier(RegSlot)         frameDisplayRegister;   // this register slot cannot be 0 so we use that sentinel value to indicate invalid",
          "2359:                 FieldWithBarrier(RegSlot)         objectRegister;         // this register slot cannot be 0 so we use that sentinel value to indicate invalid",
          "2360:                 FieldWithBarrier(ScopeObjectChain*) pScopeObjectChain;",
          "2361:                 FieldWithBarrier(ByteBlock*) m_probeBackingBlock;  // NULL if no Probes, otherwise a copy of the unmodified the byte-codeblock //Delay",
          "2362:                 FieldWithBarrier(int32) m_probeCount;             // The number of installed probes (such as breakpoints).",
          "2365:                 FieldWithBarrier(AuxStatementData*) m_auxStatementData;",
          "2367:                 SourceInfo():",
          "2368:                     frameDisplayRegister(0),",
          "2369:                     objectRegister(0),",
          "2370:                     pScopeObjectChain(nullptr),",
          "2371:                     m_probeBackingBlock(nullptr),",
          "2372:                     m_probeCount(0),",
          "2373:                     m_auxStatementData(nullptr),",
          "2374:                     pSpanSequence(nullptr)",
          "2375:                 {",
          "2376:                 }",
          "2377:             };",
          "2379:     private:",
          "2380:         FieldWithBarrier(ByteBlock*) byteCodeBlock;                // Function byte-code for script functions",
          "2381:         FieldWithBarrier(FunctionEntryPointList*) entryPoints;",
          "2382:         FieldWithBarrier(Field(Var)*) m_constTable;",
          "2383:         FieldWithBarrier(void**) inlineCaches;",
          "2384:         FieldWithBarrier(InlineCachePointerArray<PolymorphicInlineCache>) polymorphicInlineCaches; // Contains the latest polymorphic inline caches",
          "2385:         FieldWithBarrier(PropertyId*) cacheIdToPropertyIdMap;",
          "2387: #if DBG",
          "2388: #define InlineCacheTypeNone         0x00",
          "2389: #define InlineCacheTypeInlineCache  0x01",
          "2390: #define InlineCacheTypeIsInst       0x02",
          "2391:             FieldWithBarrier(byte*) m_inlineCacheTypes;",
          "2392: #endif",
          "2393:     public:",
          "2394:         PropertyId * GetCacheIdToPropertyIdMap()",
          "2395:         {",
          "2396:             return cacheIdToPropertyIdMap;",
          "2397:         }",
          "2398:         static DWORD GetAsmJsTotalLoopCountOffset() { return offsetof(FunctionBody, m_asmJsTotalLoopCount); }",
          "2399: #if DBG",
          "2400:         FieldWithBarrier(int) m_DEBUG_executionCount;     // Count of outstanding on InterpreterStackFrame",
          "2401:         FieldWithBarrier(bool) m_nativeEntryPointIsInterpreterThunk; // NativeEntry entry point is in fact InterpreterThunk.",
          "2403: #endif",
          "2406:         FieldWithBarrier(uint) regAllocStoreCount;",
          "2407:         FieldWithBarrier(uint) regAllocLoadCount;",
          "2408:         FieldWithBarrier(uint) callCountStats;",
          "2416:         FieldWithBarrier(SourceInfo) m_sourceInfo; // position of the source",
          "2419:         FieldWithBarrier(uint) m_uScriptId; // Delay //Script Block it belongs to. This is function no. of the global function created by engine for each block",
          "2420: #if DBG",
          "2421:         FieldWithBarrier(int) m_iProfileSession; // Script profile session the meta data of this function is reported to.",
          "2422: #endif // DEBUG",
          "2425:         static const RegSlot ReturnValueRegSlot = 0;",
          "2426:         static const RegSlot RootObjectRegSlot = 1;",
          "2427:         static const RegSlot FirstRegSlot = 1;",
          "2429:         static const int LocalsChangeDirtyValue = 1;",
          "2431: #define DEFINE_FUNCTION_BODY_FIELDS 1",
          "2432: #define DECLARE_TAG_FIELD(type, name, serializableType) Field(type) name",
          "2433: #define CURRENT_ACCESS_MODIFIER public:",
          "2434: #include \"SerializableFunctionFields.h\"",
          "2436:     private:",
          "2437:         FieldWithBarrier(uint) inactiveCount;",
          "2440:         FieldWithBarrier(bool) m_tag32 : 1;",
          "2441:         FieldWithBarrier(bool) m_nativeEntryPointUsed : 1;    // Code might have been generated but not yet used.",
          "2442:         FieldWithBarrier(bool) hasDoneLoopBodyCodeGen : 1;    // Code generated for loop body, but not necessary available to execute yet.",
          "2443:         FieldWithBarrier(bool) m_isFuncRegistered : 1;",
          "2444:         FieldWithBarrier(bool) m_isFuncRegisteredToDiag : 1; // Mentions the function's context is registered with diagprobe.",
          "2445:         FieldWithBarrier(bool) funcEscapes : 1;",
          "2446:         FieldWithBarrier(bool) m_hasBailoutInstrInJittedCode : 1; // Indicates whether function has bailout instructions. Valid only if hasDoneCodeGen is true",
          "2447:         FieldWithBarrier(bool) m_pendingLoopHeaderRelease : 1; // Indicates whether loop headers need to be released",
          "2450:         FieldWithBarrier(bool) hasExecutionDynamicProfileInfo : 1;",
          "2451:         FieldWithBarrier(bool) cleanedUp: 1;",
          "2452:         FieldWithBarrier(bool) sourceInfoCleanedUp: 1;",
          "2453:         FieldWithBarrier(bool) dontRethunkAfterBailout : 1;",
          "2454:         FieldWithBarrier(bool) disableInlineApply : 1;",
          "2455:         FieldWithBarrier(bool) disableInlineSpread : 1;",
          "2456:         FieldWithBarrier(bool) hasHotLoop: 1;",
          "2457:         FieldWithBarrier(bool) wasCalledFromLoop : 1;",
          "2460:         FieldWithBarrier(bool) hasNestedLoop : 1;",
          "2461:         FieldWithBarrier(bool) recentlyBailedOutOfJittedLoopBody : 1;",
          "2462:         FieldWithBarrier(bool) m_firstFunctionObject: 1;",
          "2463:         FieldWithBarrier(bool) m_inlineCachesOnFunctionObject: 1;",
          "2466:         FieldWithBarrier(bool) m_hasSetIsObject : 1;",
          "2469:         FieldWithBarrier(bool) m_hasAllNonLocalReferenced : 1;",
          "2470:         FieldWithBarrier(bool) m_hasFunExprNameReference : 1;",
          "2471:         FieldWithBarrier(bool) m_ChildCallsEval : 1;",
          "2474:         FieldWithBarrier(bool) m_CallsEval : 1;",
          "2475:         FieldWithBarrier(bool) m_hasReferenceableBuiltInArguments : 1;",
          "2476:         FieldWithBarrier(bool) m_isParamAndBodyScopeMerged : 1;",
          "2478:         FieldWithBarrier(bool) m_hasDoneAllNonLocalReferenced : 1;",
          "2480:         FieldWithBarrier(bool) m_hasFunctionCompiledSent : 1;",
          "2481:         FieldWithBarrier(bool) m_isFromNativeCodeModule : 1;",
          "2482:         FieldWithBarrier(bool) m_isPartialDeserializedFunction : 1;",
          "2483:         FieldWithBarrier(bool) m_isAsmJsScheduledForFullJIT : 1;",
          "2486:         FieldWithBarrier(bool) m_tag33 : 1;",
          "2487:         FieldWithBarrier(bool) m_hasLocalClosureRegister : 1;",
          "2488:         FieldWithBarrier(bool) m_hasParamClosureRegister : 1;",
          "2489:         FieldWithBarrier(bool) m_hasLocalFrameDisplayRegister : 1;",
          "2490:         FieldWithBarrier(bool) m_hasEnvRegister : 1;",
          "2491:         FieldWithBarrier(bool) m_hasThisRegisterForEventHandler : 1;",
          "2492:         FieldWithBarrier(bool) m_hasFirstInnerScopeRegister : 1;",
          "2493:         FieldWithBarrier(bool) m_hasFuncExprScopeRegister : 1;",
          "2496:         FieldWithBarrier(bool) m_hasFirstTmpRegister : 1;",
          "2497:         FieldWithBarrier(bool) m_hasActiveReference : 1;",
          "2498: #if DBG",
          "2499:         FieldWithBarrier(bool) m_isSerialized : 1;",
          "2500: #endif",
          "2501: #ifdef PERF_COUNTERS",
          "2502:         FieldWithBarrier(bool) m_isDeserializedFunction : 1;",
          "2503: #endif",
          "2504: #if DBG",
          "2506:         FieldWithBarrier(bool) m_canDoStackNestedFunc : 1;",
          "2507: #endif",
          "2509: #if DBG",
          "2510:         FieldWithBarrier(bool) initializedExecutionModeAndLimits : 1;",
          "2511: #endif",
          "2513: #ifdef IR_VIEWER",
          "2515:         FieldWithBarrier(bool) m_isIRDumpEnabled : 1;",
          "2516:         FieldWithBarrier(Js::DynamicObject*) m_irDumpBaseObject;",
          "2519:         FieldWithBarrier(uint8) bailOnMisingProfileCount;",
          "2520:         FieldWithBarrier(uint8) bailOnMisingProfileRejitCount;",
          "2522:         FieldWithBarrier(byte) inlineDepth; // Used by inlining to avoid recursively inlining functions excessively",
          "2524:         FieldWithBarrier(ExecutionMode) executionMode;",
          "2525:         FieldWithBarrier(uint16) interpreterLimit;",
          "2526:         FieldWithBarrier(uint16) autoProfilingInterpreter0Limit;",
          "2527:         FieldWithBarrier(uint16) profilingInterpreter0Limit;",
          "2528:         FieldWithBarrier(uint16) autoProfilingInterpreter1Limit;",
          "2529:         FieldWithBarrier(uint16) simpleJitLimit;",
          "2530:         FieldWithBarrier(uint16) profilingInterpreter1Limit;",
          "2531:         FieldWithBarrier(uint16) fullJitThreshold;",
          "2532:         FieldWithBarrier(uint16) fullJitRequeueThreshold;",
          "2533:         FieldWithBarrier(uint16) committedProfiledIterations;",
          "2535:         FieldWithBarrier(uint) m_depth; // Indicates how many times the function has been entered (so increases by one on each recursive call, decreases by one when we're done)",
          "2537:         FieldWithBarrier(uint32) interpretedCount;",
          "2538:         FieldWithBarrier(uint32) lastInterpretedCount;",
          "2539:         FieldWithBarrier(uint32) loopInterpreterLimit;",
          "2540:         FieldWithBarrier(uint32) debuggerScopeIndex;",
          "2541:         FieldWithBarrier(uint32) savedPolymorphicCacheState;",
          "2549:         FieldNoBarrier(Js::ByteCodeCache*) byteCodeCache;   // Not GC allocated so naked pointer",
          "2550: #ifdef ENABLE_DEBUG_CONFIG_OPTIONS",
          "2551:         static bool shareInlineCaches;",
          "2552: #endif",
          "2553:         FieldWithBarrier(FunctionEntryPointInfo*) defaultFunctionEntryPointInfo;",
          "2555: #if ENABLE_PROFILE_INFO",
          "2556:         FieldWithBarrier(DynamicProfileInfo*) dynamicProfileInfo;",
          "2557: #endif",
          "2562:         FieldWithBarrier(BYTE) savedInlinerVersion;",
          "2563: #if ENABLE_NATIVE_CODEGEN",
          "2564:         FieldWithBarrier(ImplicitCallFlags) savedImplicitCallsFlags;",
          "2565: #endif",
          "2567:         FunctionBody(ScriptContext* scriptContext, const char16* displayName, uint displayNameLength, uint displayShortNameOffset, uint nestedCount, Utf8SourceInfo* sourceInfo,",
          "2568:             uint uFunctionNumber, uint uScriptId, Js::LocalFunctionId functionId, Js::PropertyRecordList* propRecordList, FunctionInfo::Attributes attributes, FunctionBodyFlags flags",
          "2569: #ifdef PERF_COUNTERS",
          "2570:             , bool isDeserializedFunction = false",
          "2571: #endif",
          "2572:             );",
          "2574:         FunctionBody(ParseableFunctionInfo * parseableFunctionInfo);",
          "2576:         void SetNativeEntryPoint(FunctionEntryPointInfo* entryPointInfo, JavascriptMethod originalEntryPoint, JavascriptMethod directEntryPoint);",
          "2577: #if DYNAMIC_INTERPRETER_THUNK",
          "2578:         void GenerateDynamicInterpreterThunk();",
          "2579: #endif",
          "2580:         void CloneByteCodeInto(ScriptContext * scriptContext, FunctionBody *newFunctionBody, uint sourceIndex);",
          "2581:         Js::JavascriptMethod GetEntryPoint(ProxyEntryPointInfo* entryPoint) const { return entryPoint->jsMethod; }",
          "2582:         void CaptureDynamicProfileState(FunctionEntryPointInfo* entryPointInfo);",
          "2583: #if ENABLE_DEBUG_CONFIG_OPTIONS",
          "2584:         void DumpRegStats(FunctionBody *funcBody);",
          "2585: #endif",
          "2587:     public:",
          "2588:         FunctionBody(ByteCodeCache* cache, Utf8SourceInfo* sourceInfo, ScriptContext* scriptContext):",
          "2589:             ParseableFunctionInfo((JavascriptMethod) nullptr, 0, (LocalFunctionId) 0, sourceInfo, scriptContext, 0, nullptr, 0, 0, FunctionInfo::Attributes::None, nullptr, Flags_None)",
          "2590:         {",
          "2594:         }",
          "2596:         static FunctionBody * NewFromRecycler(Js::ScriptContext * scriptContext, const char16 * displayName, uint displayNameLength, uint displayShortNameOffset, uint nestedCount,",
          "2597:             Utf8SourceInfo* sourceInfo, uint uScriptId, Js::LocalFunctionId functionId, Js::PropertyRecordList* boundPropertyRecords, FunctionInfo::Attributes attributes",
          "2598:             , FunctionBodyFlags flags",
          "2599: #ifdef PERF_COUNTERS",
          "2600:             , bool isDeserializedFunction",
          "2601: #endif",
          "2602:             );",
          "2603:         static FunctionBody * NewFromRecycler(Js::ScriptContext * scriptContext, const char16 * displayName, uint displayNameLength, uint displayShortNameOffset, uint nestedCount,",
          "2604:             Utf8SourceInfo* sourceInfo, uint uFunctionNumber, uint uScriptId, Js::LocalFunctionId functionId, Js::PropertyRecordList* boundPropertyRecords, FunctionInfo::Attributes attributes",
          "2605:             , FunctionBodyFlags flags",
          "2606: #ifdef PERF_COUNTERS",
          "2607:             , bool isDeserializedFunction",
          "2608: #endif",
          "2609:             );",
          "2611:         static FunctionBody * NewFromParseableFunctionInfo(ParseableFunctionInfo * info, PropertyRecordList *boundPropertyRecords);",
          "2613:         FunctionEntryPointInfo * GetEntryPointInfo(int index) const;",
          "2614:         FunctionEntryPointInfo * TryGetEntryPointInfo(int index) const;",
          "2616:         bool DoRedeferFunction(uint inactiveThreshold) const;",
          "2617:         void RedeferFunction();",
          "2618:         bool IsActiveFunction(ActiveFunctionSet * pActiveFuncs) const;",
          "2619:         bool TestAndUpdateActiveFunctions(ActiveFunctionSet * pActiveFuncs) const;",
          "2620:         void UpdateActiveFunctionSet(ActiveFunctionSet * pActiveFuncs, FunctionCodeGenRuntimeData *callSiteData) const;",
          "2621:         void UpdateActiveFunctionsForOneDataSet(ActiveFunctionSet *pActiveFuncs, FunctionCodeGenRuntimeData *parentData, Field(FunctionCodeGenRuntimeData*)* dataSet, uint count) const;",
          "2622:         uint GetInactiveCount() const { return inactiveCount; }",
          "2623:         void SetInactiveCount(uint count) { inactiveCount = count; }",
          "2624:         void IncrInactiveCount(uint increment);",
          "2625:         bool InterpretedSinceCallCountCollection() const;",
          "2626:         void CollectInterpretedCounts();",
          "2627:         void ResetRedeferralAttributes() { this->m_hasActiveReference = false; }",
          "2629:         Js::RootObjectBase * LoadRootObject() const;",
          "2630:         Js::RootObjectBase * GetRootObject() const;",
          "2631:         ByteBlock* GetAuxiliaryData() const { return static_cast<ByteBlock*>(this->GetAuxPtr(AuxPointerType::AuxBlock)); }",
          "2632:         ByteBlock* GetAuxiliaryDataWithLock() const { return static_cast<ByteBlock*>(this->GetAuxPtrWithLock(AuxPointerType::AuxBlock)); }",
          "2633:         void SetAuxiliaryData(ByteBlock* auxBlock) { this->SetAuxPtr(AuxPointerType::AuxBlock, auxBlock); }",
          "2634:         ByteBlock* GetAuxiliaryContextData()const { return static_cast<ByteBlock*>(this->GetAuxPtr(AuxPointerType::AuxContextBlock)); }",
          "2635:         ByteBlock* GetAuxiliaryContextDataWithLock()const { return static_cast<ByteBlock*>(this->GetAuxPtrWithLock(AuxPointerType::AuxContextBlock)); }",
          "2636:         void SetAuxiliaryContextData(ByteBlock* auxContextBlock) { this->SetAuxPtr(AuxPointerType::AuxContextBlock, auxContextBlock); }",
          "2637:         void SetFormalsPropIdArray(PropertyIdArray * propIdArray);",
          "2638:         PropertyIdArray* GetFormalsPropIdArray(bool checkForNull = true);",
          "2639:         Var GetFormalsPropIdArrayOrNullObj();",
          "2640:         ByteBlock* GetByteCode() const;",
          "2641:         ByteBlock* GetOriginalByteCode(); // Returns original bytecode without probes (such as BPs).",
          "2642:         Js::ByteCodeCache * GetByteCodeCache() const { return this->byteCodeCache; }",
          "2643:         void SetByteCodeCache(Js::ByteCodeCache *byteCodeCache)",
          "2644:         {",
          "2645:             if (byteCodeCache != nullptr)",
          "2646:             {",
          "2647:                 this->byteCodeCache = byteCodeCache;",
          "2648:             }",
          "2649:         }",
          "2650: #if DBG",
          "2651:         void SetIsSerialized(bool serialized) { m_isSerialized = serialized; }",
          "2652:         bool GetIsSerialized()const { return m_isSerialized; }",
          "2653: #endif",
          "2654:         uint GetByteCodeCount() const { return GetCountField(CounterFields::ByteCodeCount); }",
          "2655:         void SetByteCodeCount(uint count) { SetCountField(CounterFields::ByteCodeCount, count); }",
          "2656:         uint GetByteCodeWithoutLDACount() const { return GetCountField(CounterFields::ByteCodeWithoutLDACount); }",
          "2657:         void SetByteCodeWithoutLDACount(uint count) { SetCountField(CounterFields::ByteCodeWithoutLDACount, count); }",
          "2658:         uint GetByteCodeInLoopCount() const { return GetCountField(CounterFields::ByteCodeInLoopCount); }",
          "2659:         void SetByteCodeInLoopCount(uint count) { SetCountField(CounterFields::ByteCodeInLoopCount, count); }",
          "2660:         uint16 GetEnvDepth() const { return m_envDepth; }",
          "2661:         void SetEnvDepth(uint16 depth) { m_envDepth = depth; }",
          "2663:         void SetEnvRegister(RegSlot reg);",
          "2664:         void MapAndSetEnvRegister(RegSlot reg);",
          "2665:         RegSlot GetEnvRegister() const;",
          "2666:         void SetThisRegisterForEventHandler(RegSlot reg);",
          "2667:         void MapAndSetThisRegisterForEventHandler(RegSlot reg);",
          "2668:         RegSlot GetThisRegisterForEventHandler() const;",
          "2670:         void SetLocalClosureRegister(RegSlot reg);",
          "2671:         void MapAndSetLocalClosureRegister(RegSlot reg);",
          "2672:         RegSlot GetLocalClosureRegister() const;",
          "2673:         void SetParamClosureRegister(RegSlot reg);",
          "2674:         void MapAndSetParamClosureRegister(RegSlot reg);",
          "2675:         RegSlot GetParamClosureRegister() const;",
          "2677:         void SetLocalFrameDisplayRegister(RegSlot reg);",
          "2678:         void MapAndSetLocalFrameDisplayRegister(RegSlot reg);",
          "2679:         RegSlot GetLocalFrameDisplayRegister() const;",
          "2680:         void SetFirstInnerScopeRegister(RegSlot reg);",
          "2681:         void MapAndSetFirstInnerScopeRegister(RegSlot reg);",
          "2682:         RegSlot GetFirstInnerScopeRegister() const;",
          "2683:         void SetFuncExprScopeRegister(RegSlot reg);",
          "2684:         void MapAndSetFuncExprScopeRegister(RegSlot reg);",
          "2685:         RegSlot GetFuncExprScopeRegister() const;",
          "2687:         bool HasScopeObject() const { return hasScopeObject; }",
          "2688:         void SetHasScopeObject(bool has) { hasScopeObject = has; }",
          "2689:         uint GetInnerScopeCount() const { return GetCountField(CounterFields::InnerScopeCount); }",
          "2690:         void SetInnerScopeCount(uint count) { SetCountField(CounterFields::InnerScopeCount, count); }",
          "2691:         bool HasCachedScopePropIds() const { return hasCachedScopePropIds; }",
          "2692:         void SetHasCachedScopePropIds(bool has) { hasCachedScopePropIds = has; }",
          "2694:         uint32 GetInterpretedCount() const { return interpretedCount; }",
          "2695:         uint32 SetInterpretedCount(uint32 val) { return interpretedCount = val; }",
          "2696:         uint32 IncreaseInterpretedCount() { return interpretedCount++; }",
          "2698:         uint32 GetLoopInterpreterLimit() const { return loopInterpreterLimit; }",
          "2699:         uint32 SetLoopInterpreterLimit(uint32 val) { return loopInterpreterLimit = val; }",
          "2702:         uint32 GetNextDebuggerScopeIndex() { return debuggerScopeIndex++; }",
          "2703:         void SetDebuggerScopeIndex(uint32 index) { debuggerScopeIndex = index; }",
          "2705:         size_t GetLoopBodyName(uint loopNumber, _Out_writes_opt_z_(sizeInChars) WCHAR* displayName, _In_ size_t sizeInChars);",
          "2707:         void AllocateLoopHeaders();",
          "2708:         void ReleaseLoopHeaders();",
          "2709:         Js::LoopHeader * GetLoopHeader(uint index) const;",
          "2710:         Js::LoopHeader * GetLoopHeaderWithLock(uint index) const;",
          "2711:         Js::Var GetLoopHeaderArrayPtr() const",
          "2712:         {",
          "2713:             Assert(this->GetLoopHeaderArray() != nullptr);",
          "2714:             return this->GetLoopHeaderArray();",
          "2715:         }",
          "2716: #ifdef ASMJS_PLAT",
          "2717:         void SetIsAsmJsFullJitScheduled(bool val){ m_isAsmJsScheduledForFullJIT = val; }",
          "2718:         bool GetIsAsmJsFullJitScheduled(){ return m_isAsmJsScheduledForFullJIT; }",
          "2719:         uint32 GetAsmJSTotalLoopCount() const",
          "2720:         {",
          "2721:             return m_asmJsTotalLoopCount;",
          "2722:         }",
          "2724:         void SetIsAsmJsFunction(bool isAsmJsFunction)",
          "2725:         {",
          "2726:             m_isAsmJsFunction = isAsmJsFunction;",
          "2727:         }",
          "2728: #endif",
          "2730:         const bool GetIsAsmJsFunction() const",
          "2731:         {",
          "2732:             return m_isAsmJsFunction;",
          "2733:         }",
          "2735: #ifdef ASMJS_PLAT",
          "2736:         bool IsHotAsmJsLoop()",
          "2737:         {",
          "2739:             if (CONFIG_FLAG(MinTemplatizedJitLoopRunCount) < 0 || m_asmJsTotalLoopCount > static_cast<uint>(CONFIG_FLAG(MinTemplatizedJitLoopRunCount)))",
          "2740:             {",
          "2741:                 return true;",
          "2742:             }",
          "2743:             return false;",
          "2744:         }",
          "2745: #endif",
          "2747:     private:",
          "2748:         void ResetLoops();",
          "2750:     public:",
          "2751:         static bool Is(void* ptr);",
          "2752:         uint GetScriptId() const { return m_uScriptId; }",
          "2754:         void* GetAddressOfScriptId() const",
          "2755:         {",
          "2756:             return (void*)&m_uScriptId;",
          "2757:         }",
          "2760:         static uint *GetJittedLoopIterationsSinceLastBailoutAddress(EntryPointInfo* info)",
          "2761:         {",
          "2762:             LoopEntryPointInfo* entryPoint = (LoopEntryPointInfo*)info;",
          "2763:             return &entryPoint->jittedLoopIterationsSinceLastBailout;",
          "2764:         }",
          "2766:         FunctionEntryPointInfo* GetDefaultFunctionEntryPointInfo() const;",
          "2767:         void SetDefaultFunctionEntryPointInfo(FunctionEntryPointInfo* entryPointInfo, const JavascriptMethod originalEntryPoint);",
          "2769:         FunctionEntryPointInfo *GetSimpleJitEntryPointInfo() const;",
          "2770:         void SetSimpleJitEntryPointInfo(FunctionEntryPointInfo *const entryPointInfo);",
          "2772:     private:",
          "2773:         void VerifyExecutionMode(const ExecutionMode executionMode) const;",
          "2774:     public:",
          "2775:         ExecutionMode GetDefaultInterpreterExecutionMode() const;",
          "2776:         ExecutionMode GetExecutionMode() const;",
          "2777:         ExecutionMode GetInterpreterExecutionMode(const bool isPostBailout);",
          "2778:         void SetExecutionMode(const ExecutionMode executionMode);",
          "2779:     private:",
          "2780:         bool IsInterpreterExecutionMode() const;",
          "2782:     public:",
          "2783:         bool TryTransitionToNextExecutionMode();",
          "2784:         void TryTransitionToNextInterpreterExecutionMode();",
          "2785:         void SetIsSpeculativeJitCandidate();",
          "2786:         bool TryTransitionToJitExecutionMode();",
          "2787:         void TransitionToSimpleJitExecutionMode();",
          "2788:         void TransitionToFullJitExecutionMode();",
          "2790:     private:",
          "2791:         void VerifyExecutionModeLimits();",
          "2792:         void InitializeExecutionModeAndLimits();",
          "2793:     public:",
          "2794:         void ReinitializeExecutionModeAndLimits();",
          "2795:     private:",
          "2796:         void SetFullJitThreshold(const uint16 newFullJitThreshold, const bool skipSimpleJit = false);",
          "2797:         void CommitExecutedIterations();",
          "2798:         void CommitExecutedIterations(uint16 &limit, const uint executedIterations);",
          "2800:     private:",
          "2801:         uint16 GetSimpleJitExecutedIterations() const;",
          "2802:     public:",
          "2803:         void ResetSimpleJitLimitAndCallCount();",
          "2804:     private:",
          "2805:         void SetSimpleJitCallCount(const uint16 simpleJitLimit) const;",
          "2806:         void ResetSimpleJitCallCount();",
          "2807:     public:",
          "2808:         uint16 GetProfiledIterations() const;",
          "2810:     public:",
          "2811:         void OnFullJitDequeued(const FunctionEntryPointInfo *const entryPointInfo);",
          "2813:     public:",
          "2814:         void TraceExecutionMode(const char *const eventDescription = nullptr) const;",
          "2815:         void TraceInterpreterExecutionMode() const;",
          "2816:     private:",
          "2817:         void DoTraceExecutionMode(const char *const eventDescription) const;",
          "2819:     public:",
          "2820:         bool DoSimpleJit() const;",
          "2821:         bool DoSimpleJitWithLock() const;",
          "2822:         bool DoSimpleJitDynamicProfile() const;",
          "2824:     private:",
          "2825:         bool DoInterpreterProfile() const;",
          "2826:         bool DoInterpreterProfileWithLock() const;",
          "2827:         bool DoInterpreterAutoProfile() const;",
          "2829:     public:",
          "2830:         bool WasCalledFromLoop() const;",
          "2831:         void SetWasCalledFromLoop();",
          "2833:     public:",
          "2834:         bool RecentlyBailedOutOfJittedLoopBody() const;",
          "2835:         void SetRecentlyBailedOutOfJittedLoopBody(const bool value);",
          "2837:     private:",
          "2838:         static uint16 GetMinProfileIterations();",
          "2839:     public:",
          "2840:         static uint16 GetMinFunctionProfileIterations();",
          "2841:     private:",
          "2842:         static uint GetMinLoopProfileIterations(const uint loopInterpreterLimit);",
          "2843:     public:",
          "2844:         uint GetLoopProfileThreshold(const uint loopInterpreterLimit) const;",
          "2845:     private:",
          "2846:         static uint GetReducedLoopInterpretCount();",
          "2847:     public:",
          "2848:         uint GetLoopInterpretCount(LoopHeader* loopHeader) const;",
          "2850:     private:",
          "2851:         static bool DoObjectHeaderInlining();",
          "2852:         static bool DoObjectHeaderInliningForConstructors();",
          "2853:     public:",
          "2854:         static bool DoObjectHeaderInliningForConstructor(const uint32 inlineSlotCapacity);",
          "2855:     private:",
          "2856:         static bool DoObjectHeaderInliningForObjectLiterals();",
          "2857:     public:",
          "2858:         static bool DoObjectHeaderInliningForObjectLiteral(const uint32 inlineSlotCapacity);",
          "2859:         static bool DoObjectHeaderInliningForObjectLiteral(const PropertyIdArray *const propIds);",
          "2860:         static bool DoObjectHeaderInliningForEmptyObjects();",
          "2862:     public:",
          "2863: #if DBG",
          "2864:         int GetProfileSession() { return m_iProfileSession; }",
          "2865: #endif",
          "2866:         virtual void Finalize(bool isShutdown) override;",
          "2867:         virtual void OnMark() override;",
          "2869:         void Cleanup(bool isScriptContextClosing);",
          "2870:         void CleanupSourceInfo(bool isScriptContextClosing);",
          "2871:         template<bool IsScriptContextShutdown>",
          "2872:         void CleanUpInlineCaches();",
          "2873:         void CleanupRecyclerData(bool isRecyclerShutdown, bool doEntryPointCleanupCaptureStack);",
          "2875: #ifdef PERF_COUNTERS",
          "2876:         void CleanupPerfCounter();",
          "2877: #endif",
          "2879:         bool HasRejit() const",
          "2880:         {",
          "2881:             if(this->entryPoints)",
          "2882:             {",
          "2883:                 return this->entryPoints->Count() > 1;",
          "2884:             }",
          "2885:             return false;",
          "2886:         }",
          "2888: #pragma region SourceInfo Methods",
          "2889:         void CopySourceInfo(ParseableFunctionInfo* originalFunctionInfo);",
          "2890:         void FinishSourceInfo();",
          "2891:         RegSlot GetFrameDisplayRegister() const;",
          "2892:         void SetFrameDisplayRegister(RegSlot frameDisplayRegister);",
          "2894:         RegSlot GetObjectRegister() const;",
          "2895:         void SetObjectRegister(RegSlot objectRegister);",
          "2896:         bool HasObjectRegister() const { return GetObjectRegister() != 0; }",
          "2897:         ScopeObjectChain *GetScopeObjectChain() const;",
          "2898:         void SetScopeObjectChain(ScopeObjectChain *pScopeObjectChain);",
          "2901:         Js::DebuggerScope * GetDiagCatchScopeObjectAt(int byteCodeOffset);",
          "2903:         ByteBlock *GetProbeBackingBlock();",
          "2904:         void SetProbeBackingBlock(ByteBlock* probeBackingBlock);",
          "2906:         bool HasLineBreak() const;",
          "2907:         bool HasLineBreak(charcount_t start, charcount_t end) const;",
          "2909:         bool HasGeneratedFromByteCodeCache() const { return this->byteCodeCache != nullptr; }",
          "2911:         void TrackLoad(int ichMin);",
          "2913:         SmallSpanSequence* GetStatementMapSpanSequence() const { return m_sourceInfo.pSpanSequence; }",
          "2914:         void RecordStatementMap(StatementMap* statementMap);",
          "2915:         void RecordStatementMap(SmallSpanSequenceIter &iter, StatementData * data);",
          "2916:         void RecordLoad(int ichMin, int bytecodeAfterLoad);",
          "2917:         DebuggerScope* RecordStartScopeObject(DiagExtraScopesType scopeType, int start, RegSlot scopeLocation, int* index = nullptr);",
          "2918:         void RecordEndScopeObject(DebuggerScope* currentScope, int end);",
          "2919:         DebuggerScope* AddScopeObject(DiagExtraScopesType scopeType, int start, RegSlot scopeLocation);",
          "2920:         bool TryGetDebuggerScopeAt(int index, DebuggerScope*& debuggerScope);",
          "2922:         StatementMapList * GetStatementMaps() const { return static_cast<StatementMapList *>(this->GetAuxPtrWithLock(AuxPointerType::StatementMaps)); }",
          "2923:         void SetStatementMaps(StatementMapList *pStatementMaps) { this->SetAuxPtr(AuxPointerType::StatementMaps, pStatementMaps); }",
          "2925:         Field(FunctionCodeGenRuntimeData*)* GetCodeGenGetSetRuntimeData() const { return static_cast<Field(FunctionCodeGenRuntimeData*)*>(this->GetAuxPtr(AuxPointerType::CodeGenGetSetRuntimeData)); }",
          "2926:         Field(FunctionCodeGenRuntimeData*)* GetCodeGenGetSetRuntimeDataWithLock() const { return static_cast<Field(FunctionCodeGenRuntimeData*)*>(this->GetAuxPtrWithLock(AuxPointerType::CodeGenGetSetRuntimeData)); }",
          "2927:         void SetCodeGenGetSetRuntimeData(FunctionCodeGenRuntimeData** codeGenGetSetRuntimeData) { this->SetAuxPtr(AuxPointerType::CodeGenGetSetRuntimeData, codeGenGetSetRuntimeData); }",
          "2929:         Field(FunctionCodeGenRuntimeData*)* GetCodeGenRuntimeData() const { return static_cast<Field(FunctionCodeGenRuntimeData*)*>(this->GetAuxPtr(AuxPointerType::CodeGenRuntimeData)); }",
          "2930:         Field(FunctionCodeGenRuntimeData*)* GetCodeGenRuntimeDataWithLock() const { return static_cast<Field(FunctionCodeGenRuntimeData*)*>(this->GetAuxPtrWithLock(AuxPointerType::CodeGenRuntimeData)); }",
          "2931:         void SetCodeGenRuntimeData(FunctionCodeGenRuntimeData** codeGenRuntimeData) { this->SetAuxPtr(AuxPointerType::CodeGenRuntimeData, codeGenRuntimeData); }",
          "2933:         template <typename TStatementMapList>",
          "2934:         static StatementMap * GetNextNonSubexpressionStatementMap(TStatementMapList *statementMapList, int & startingAtIndex);",
          "2935:         static StatementMap * GetPrevNonSubexpressionStatementMap(StatementMapList *statementMapList, int & startingAtIndex);",
          "2936:         void RecordStatementAdjustment(uint offset, StatementAdjustmentType adjType);",
          "2937:         void RecordCrossFrameEntryExitRecord(uint byteCodeOffset, bool isEnterBlock);",
          "2940:         BOOL GetBranchOffsetWithin(uint start, uint end, StatementAdjustmentRecord* record);",
          "2941:         bool GetLineCharOffset(int byteCodeOffset, ULONG* line, LONG* charOffset, bool canAllocateLineCache = true);",
          "2942:         bool GetLineCharOffsetFromStartChar(int startCharOfStatement, ULONG* _line, LONG* _charOffset, bool canAllocateLineCache = true);",
          "2945:         bool GetStatementIndexAndLengthAt(int byteCodeOffset, UINT32* statementIndex, UINT32* statementLength);",
          "2948:         static charcount_t SkipByteOrderMark(__in_bcount_z(4) LPCUTF8& documentStart)",
          "2949:         {",
          "2950:             charcount_t retValue = 0;",
          "2952:             Assert(documentStart != nullptr);",
          "2954:             if (documentStart[0] == 0xEF &&",
          "2955:                 documentStart[1] == 0xBB &&",
          "2956:                 documentStart[2] == 0xBF)",
          "2957:             {",
          "2960:                 documentStart += 3;",
          "2961:                 retValue = 1;",
          "2962:             }",
          "2963:             else if ((documentStart[0] == 0xFF && documentStart[1] == 0xFE) ||",
          "2964:                     (documentStart[0] == 0xFE && documentStart[1] == 0xFF))",
          "2965:             {",
          "2969:                 documentStart += 2;",
          "2970:                 retValue = 1;",
          "2971:             }",
          "2973:             return retValue;",
          "2974:         }",
          "2976:         StatementMap* GetMatchingStatementMapFromByteCode(int byteCodeOffset, bool ignoreSubexpressions = false);",
          "2977:         int GetEnclosingStatementIndexFromByteCode(int byteCodeOffset, bool ignoreSubexpressions = false);",
          "2978:         StatementMap* GetEnclosingStatementMapFromByteCode(int byteCodeOffset, bool ignoreSubexpressions = false);",
          "2979:         StatementMap* GetMatchingStatementMapFromSource(int byteCodeOffset, int* pMapIndex = nullptr);",
          "2980:         void RecordFrameDisplayRegister(RegSlot slot);",
          "2981:         void RecordObjectRegister(RegSlot slot);",
          "2983:         CrossFrameEntryExitRecordList* GetCrossFrameEntryExitRecords();",
          "2985: #ifdef VTUNE_PROFILING",
          "2986:         uint GetStartOffset(uint statementIndex) const;",
          "2987:         ULONG GetSourceLineNumber(uint statementIndex);",
          "2988: #endif",
          "2990: #pragma endregion",
          "2993:         bool GetHasBailoutInstrInJittedCode() const { return this->m_hasBailoutInstrInJittedCode; }",
          "2994:         void SetHasBailoutInstrInJittedCode(bool hasBailout) { this->m_hasBailoutInstrInJittedCode = hasBailout; }",
          "2995:         bool GetCanDefer() const { return this->functionInfo->CanBeDeferred() && this->m_depth == 0 && !this->m_hasActiveReference; }",
          "2996:         bool GetCanReleaseLoopHeaders() const { return (this->m_depth == 0); }",
          "2997:         void SetPendingLoopHeaderRelease(bool pendingLoopHeaderRelease) { this->m_pendingLoopHeaderRelease = pendingLoopHeaderRelease; }",
          "2999:         bool GetIsFromNativeCodeModule() const { return m_isFromNativeCodeModule; }",
          "3000:         void SetIsFromNativeCodeModule(bool isFromNativeCodeModule) { m_isFromNativeCodeModule = isFromNativeCodeModule; }",
          "3002:         uint GetLoopNumber(LoopHeader const * loopHeader) const;",
          "3003:         uint GetLoopNumberWithLock(LoopHeader const * loopHeader) const;",
          "3004:         bool GetHasAllocatedLoopHeaders() { return this->GetLoopHeaderArray() != nullptr; }",
          "3005:         Js::LoopHeader* GetLoopHeaderArray() const { return static_cast<Js::LoopHeader*>(this->GetAuxPtr(AuxPointerType::LoopHeaderArray)); }",
          "3006:         Js::LoopHeader* GetLoopHeaderArrayWithLock() const { return static_cast<Js::LoopHeader*>(this->GetAuxPtrWithLock(AuxPointerType::LoopHeaderArray)); }",
          "3007:         void SetLoopHeaderArray(Js::LoopHeader* loopHeaderArray) { this->SetAuxPtr(AuxPointerType::LoopHeaderArray, loopHeaderArray); }",
          "3009: #if ENABLE_NATIVE_CODEGEN",
          "3010:         Js::JavascriptMethod GetLoopBodyEntryPoint(Js::LoopHeader * loopHeader, int entryPointIndex);",
          "3011:         void SetLoopBodyEntryPoint(Js::LoopHeader * loopHeader, EntryPointInfo* entryPointInfo, Js::JavascriptMethod entryPoint, uint loopNum);",
          "3012: #endif",
          "3014:         void RestoreOldDefaultEntryPoint(FunctionEntryPointInfo* oldEntryPoint, JavascriptMethod oldOriginalEntryPoint, FunctionEntryPointInfo* newEntryPoint);",
          "3015:         FunctionEntryPointInfo* CreateNewDefaultEntryPoint();",
          "3016:         void AddEntryPointToEntryPointList(FunctionEntryPointInfo* entryPoint);",
          "3019: #if DBG",
          "3020:         BOOL IsInterpreterThunk() const;",
          "3021:         BOOL IsDynamicInterpreterThunk() const;",
          "3022: #endif",
          "3023:         BOOL IsNativeOriginalEntryPoint() const;",
          "3024:         bool IsSimpleJitOriginalEntryPoint() const;",
          "3026: #if DYNAMIC_INTERPRETER_THUNK",
          "3027:         static BYTE GetOffsetOfDynamicInterpreterThunk() { return static_cast<BYTE>(offsetof(FunctionBody, m_dynamicInterpreterThunk)); }",
          "3028:         void* GetDynamicInterpreterEntryPoint() const",
          "3029:         {",
          "3030:             return m_dynamicInterpreterThunk;",
          "3031:         }",
          "3032:         bool HasInterpreterThunkGenerated() const",
          "3033:         {",
          "3034:             return m_dynamicInterpreterThunk != nullptr;",
          "3035:         }",
          "3037:         DWORD GetDynamicInterpreterThunkSize() const;",
          "3038: #endif",
          "3040:         bool GetHasHotLoop() const { return hasHotLoop; };",
          "3041:         void SetHasHotLoop();",
          "3043:         bool GetHasNestedLoop() const { return hasNestedLoop; };",
          "3044:         void SetHasNestedLoop(bool nest) { hasNestedLoop = nest; };",
          "3046:         bool IsInlineApplyDisabled();",
          "3047:         void InitDisableInlineApply();",
          "3048:         void SetDisableInlineApply(bool set);",
          "3050:         bool IsInlineSpreadDisabled()  const  { return disableInlineSpread; }",
          "3051:         void InitDisableInlineSpread()        { disableInlineSpread = this->GetLocalFunctionId() != Js::Constants::NoFunctionId && PHASE_OFF(Js::InlinePhase, this); }",
          "3052:         void SetDisableInlineSpread(bool set) { disableInlineSpread = set; }",
          "3054:         bool CheckCalleeContextForInlining(FunctionProxy* calleeFunctionProxy);",
          "3055: #if DBG",
          "3056:         bool HasValidSourceInfo();",
          "3057: #endif",
          "3058: #if DYNAMIC_INTERPRETER_THUNK",
          "3059:         JavascriptMethod EnsureDynamicInterpreterThunk(FunctionEntryPointInfo* entryPointInfo);",
          "3060: #endif",
          "3062:         void SetCheckCodeGenEntryPoint(FunctionEntryPointInfo* entryPointInfo, JavascriptMethod entryPoint);",
          "3064: #if ENABLE_NATIVE_CODEGEN",
          "3065:         typedef void (*SetNativeEntryPointFuncType)(FunctionEntryPointInfo* entryPointInfo, Js::FunctionBody * functionBody, Js::JavascriptMethod entryPoint);",
          "3066:         static void DefaultSetNativeEntryPoint(FunctionEntryPointInfo* entryPointInfo, FunctionBody * functionBody, JavascriptMethod entryPoint);",
          "3067:         static void ProfileSetNativeEntryPoint(FunctionEntryPointInfo* entryPointInfo, FunctionBody * functionBody, JavascriptMethod entryPoint);",
          "3069:         bool GetNativeEntryPointUsed() const { return m_nativeEntryPointUsed; }",
          "3070:         void SetNativeEntryPointUsed(bool nativeEntryPointUsed) { this->m_nativeEntryPointUsed = nativeEntryPointUsed; }",
          "3071: #endif",
          "3073:         bool GetIsFuncRegistered() { return m_isFuncRegistered; }",
          "3074:         void SetIsFuncRegistered(bool isRegistered) { m_isFuncRegistered = isRegistered; }",
          "3076:         bool GetHasLoops() const { return this->GetLoopCount() != 0; }",
          "3077:         uint IncrLoopCount() { return this->IncreaseCountField(CounterFields::LoopCount); }",
          "3078:         uint GetLoopCount() const { return this->GetCountField(CounterFields::LoopCount); }",
          "3079:         uint SetLoopCount(uint count) { return this->SetCountField(CounterFields::LoopCount, count); }",
          "3081:         uint GetForInLoopDepth() const { return this->GetCountField(CounterFields::ForInLoopDepth); }",
          "3082:         uint SetForInLoopDepth(uint count) { return this->SetCountField(CounterFields::ForInLoopDepth, count); }",
          "3084:         bool AllocProfiledForInLoopCount(ProfileId* profileId)",
          "3085:         {",
          "3086:             ProfileId profiledForInLoopCount = this->GetProfiledForInLoopCount();",
          "3087:             if (profiledForInLoopCount != Constants::NoProfileId)",
          "3088:             {",
          "3090:                 this->IncreaseCountField(CounterFields::ProfiledForInLoopCount);",
          "3091:                 return true;",
          "3092:             }",
          "3093:             return false;",
          "3094:         }",
          "3095:         ProfileId GetProfiledForInLoopCount() const { return (ProfileId)this->GetCountField(CounterFields::ProfiledForInLoopCount); }",
          "3096:         void SetProfiledForInLoopCount(ProfileId count) { this->SetCountField(CounterFields::ProfiledForInLoopCount, count); }",
          "3098:         bool AllocProfiledDivOrRem(ProfileId* profileId) { if (this->profiledDivOrRemCount != Constants::NoProfileId) { *profileId = this->profiledDivOrRemCount++; return true; } return false; }",
          "3099:         ProfileId GetProfiledDivOrRemCount() { return this->profiledDivOrRemCount; }",
          "3101:         bool AllocProfiledSwitch(ProfileId* profileId) { if (this->profiledSwitchCount != Constants::NoProfileId) { *profileId = this->profiledSwitchCount++; return true; } return false; }",
          "3102:         ProfileId GetProfiledSwitchCount() { return this->profiledSwitchCount; }",
          "3104:         bool AllocProfiledCallSiteId(ProfileId* profileId) { if (this->profiledCallSiteCount != Constants::NoProfileId) { *profileId = this->profiledCallSiteCount++; return true; } return false; }",
          "3105:         ProfileId GetProfiledCallSiteCount() const { return this->profiledCallSiteCount; }",
          "3106:         void SetProfiledCallSiteCount(ProfileId callSiteId)  { this->profiledCallSiteCount = callSiteId; }",
          "3108:         bool AllocProfiledArrayCallSiteId(ProfileId* profileId) { if (this->profiledArrayCallSiteCount != Constants::NoProfileId) { *profileId = this->profiledArrayCallSiteCount++; return true; } return false; }",
          "3109:         ProfileId GetProfiledArrayCallSiteCount() const { return this->profiledArrayCallSiteCount; }",
          "3111:         bool AllocProfiledReturnTypeId(ProfileId* profileId) { if (this->profiledReturnTypeCount != Constants::NoProfileId) { *profileId = this->profiledReturnTypeCount++; return true; } return false; }",
          "3112:         ProfileId GetProfiledReturnTypeCount() const { return this->profiledReturnTypeCount; }",
          "3114:         bool AllocProfiledSlotId(ProfileId* profileId) { if (this->profiledSlotCount != Constants::NoProfileId) { *profileId = this->profiledSlotCount++; return true; } return false; }",
          "3115:         ProfileId GetProfiledSlotCount() const { return this->profiledSlotCount; }",
          "3117:         ProfileId AllocProfiledLdElemId(ProfileId* profileId) { if (this->profiledLdElemCount != Constants::NoProfileId) { *profileId = this->profiledLdElemCount++; return true; } return false; }",
          "3118:         ProfileId GetProfiledLdElemCount() const { return this->profiledLdElemCount; }",
          "3120:         bool AllocProfiledStElemId(ProfileId* profileId) { if (this->profiledStElemCount != Constants::NoProfileId) { *profileId = this->profiledStElemCount++; return true; } return false; }",
          "3121:         ProfileId GetProfiledStElemCount() const { return this->profiledStElemCount; }",
          "3123:         uint GetProfiledFldCount() const { return this->GetInlineCacheCount(); }",
          "3125:         ArgSlot GetProfiledInParamsCount() const { return this->GetInParamsCount() > 1? this->GetInParamsCount() - 1 : 0; }",
          "3127:         bool IsPartialDeserializedFunction() { return this->m_isPartialDeserializedFunction; }",
          "3128: #ifdef PERF_COUNTERS",
          "3129:         bool IsDeserializedFunction() { return this->m_isDeserializedFunction; }",
          "3130: #endif",
          "3132: #ifdef IR_VIEWER",
          "3133:         bool IsIRDumpEnabled() const { return this->m_isIRDumpEnabled; }",
          "3134:         void SetIRDumpEnabled(bool enabled) { this->m_isIRDumpEnabled = enabled; }",
          "3135:         Js::DynamicObject * GetIRDumpBaseObject();",
          "3138: #if ENABLE_NATIVE_CODEGEN",
          "3139:         void SetPolymorphicCallSiteInfoHead(PolymorphicCallSiteInfo *polyCallSiteInfo) { this->SetAuxPtr(AuxPointerType::PolymorphicCallSiteInfoHead, polyCallSiteInfo); }",
          "3140:         PolymorphicCallSiteInfo * GetPolymorphicCallSiteInfoHead() { return static_cast<PolymorphicCallSiteInfo *>(this->GetAuxPtr(AuxPointerType::PolymorphicCallSiteInfoHead)); }",
          "3141: #endif",
          "3143:         PolymorphicInlineCache * GetPolymorphicInlineCachesHead() { return static_cast<PolymorphicInlineCache *>(this->GetAuxPtr(AuxPointerType::PolymorphicInlineCachesHead)); }",
          "3144:         void SetPolymorphicInlineCachesHead(PolymorphicInlineCache * cache) { this->SetAuxPtr(AuxPointerType::PolymorphicInlineCachesHead, cache); }",
          "3146:         bool PolyInliningUsingFixedMethodsAllowedByConfigFlags(FunctionBody* topFunctionBody)",
          "3147:         {",
          "3148:             return  !PHASE_OFF(Js::InlinePhase, this) && !PHASE_OFF(Js::InlinePhase, topFunctionBody) &&",
          "3149:                 !PHASE_OFF(Js::PolymorphicInlinePhase, this) && !PHASE_OFF(Js::PolymorphicInlinePhase, topFunctionBody) &&",
          "3150:                 !PHASE_OFF(Js::FixedMethodsPhase, this) && !PHASE_OFF(Js::FixedMethodsPhase, topFunctionBody) &&",
          "3151:                 !PHASE_OFF(Js::PolymorphicInlineFixedMethodsPhase, this) && !PHASE_OFF(Js::PolymorphicInlineFixedMethodsPhase, topFunctionBody);",
          "3152:         }",
          "3154:         void SetScopeSlotArraySizes(uint scopeSlotCount, uint scopeSlotCountForParamScope)",
          "3155:         {",
          "3156:             this->scopeSlotArraySize = scopeSlotCount;",
          "3157:             this->paramScopeSlotArraySize = scopeSlotCountForParamScope;",
          "3158:         }",
          "3160:         Js::PropertyId * GetPropertyIdsForScopeSlotArray() const { return static_cast<Js::PropertyId *>(this->GetAuxPtr(AuxPointerType::PropertyIdsForScopeSlotArray)); }",
          "3161:         void SetPropertyIdsForScopeSlotArray(Js::PropertyId * propertyIdsForScopeSlotArray, uint scopeSlotCount, uint scopeSlotCountForParamScope = 0)",
          "3162:         {",
          "3163:             SetScopeSlotArraySizes(scopeSlotCount, scopeSlotCountForParamScope);",
          "3164:             this->SetAuxPtr(AuxPointerType::PropertyIdsForScopeSlotArray, propertyIdsForScopeSlotArray);",
          "3165:         }",
          "3167:         Js::PropertyIdOnRegSlotsContainer * GetPropertyIdOnRegSlotsContainer() const",
          "3168:         {",
          "3169:             return static_cast<Js::PropertyIdOnRegSlotsContainer *>(this->GetAuxPtr(AuxPointerType::PropertyIdOnRegSlotsContainer));",
          "3170:         }",
          "3171:         Js::PropertyIdOnRegSlotsContainer * GetPropertyIdOnRegSlotsContainerWithLock() const",
          "3172:         {",
          "3173:             return static_cast<Js::PropertyIdOnRegSlotsContainer *>(this->GetAuxPtrWithLock(AuxPointerType::PropertyIdOnRegSlotsContainer));",
          "3174:         }",
          "3175:         void SetPropertyIdOnRegSlotsContainer(Js::PropertyIdOnRegSlotsContainer *propertyIdOnRegSlotsContainer)",
          "3176:         {",
          "3177:             this->SetAuxPtr(AuxPointerType::PropertyIdOnRegSlotsContainer, propertyIdOnRegSlotsContainer);",
          "3178:         }",
          "3179:     private:",
          "3180:         void ResetProfileIds();",
          "3182:     public:",
          "3183:         bool GetHasFinally() const { return m_hasFinally; }",
          "3184:         void SetHasFinally(bool has){ m_hasFinally = has; }",
          "3186:         bool GetFuncEscapes() const { return funcEscapes; }",
          "3187:         void SetFuncEscapes(bool does) { funcEscapes = does; }",
          "3189: #if DBG",
          "3190:         bool CanDoStackNestedFunc() const { return m_canDoStackNestedFunc; }",
          "3191:         void SetCanDoStackNestedFunc() { m_canDoStackNestedFunc = true; }",
          "3192: #endif",
          "3193:         RecyclerWeakReference<FunctionInfo> * GetStackNestedFuncParent();",
          "3194:         FunctionInfo * GetStackNestedFuncParentStrongRef();",
          "3195:         FunctionInfo * GetAndClearStackNestedFuncParent();",
          "3196:         void ClearStackNestedFuncParent();",
          "3197:         void SetStackNestedFuncParent(FunctionInfo * parentFunctionInfo);",
          "3199:         uint GetScopeSlotArraySize() const",
          "3200:         {",
          "3201:             return scopeSlotArraySize;",
          "3202:         }",
          "3204: #if defined(_M_IX86) || defined(_M_X64)",
          "3205:         template <typename T>",
          "3206:         static bool DoStackClosure(T functionBody)",
          "3207:         {",
          "3208:             return functionBody->DoStackNestedFunc()",
          "3209:                 && functionBody->GetNestedCount() != 0",
          "3210:                 && functionBody->GetScopeSlotArraySize() != 0",
          "3211:                 && functionBody->GetEnvDepth() != (uint16)-1;",
          "3212:         }",
          "3213: #else",
          "3214:         template <typename T>",
          "3215:         static bool DoStackClosure(T functionBody)",
          "3216:         {",
          "3217:             return false;",
          "3218:         }",
          "3219: #endif",
          "3220:         bool DoStackFrameDisplay() const { return DoStackClosure(this) && !PHASE_OFF(StackClosurePhase, this); }",
          "3221:         bool DoStackScopeSlots() const { return DoStackClosure(this) && !PHASE_OFF(StackClosurePhase, this); }",
          "3223:         bool GetIsFirstFunctionObject() const { return m_firstFunctionObject; }",
          "3224:         void SetIsNotFirstFunctionObject() { m_firstFunctionObject = false; }",
          "3226:         bool GetInlineCachesOnFunctionObject() { return m_inlineCachesOnFunctionObject; }",
          "3227:         void SetInlineCachesOnFunctionObject(bool has) { m_inlineCachesOnFunctionObject = has; }",
          "3229:         bool NeedScopeObjectForArguments(bool hasNonSimpleParams)",
          "3230:         {",
          "3231:             Assert(HasReferenceableBuiltInArguments());",
          "3233:             bool dontNeedScopeObject =",
          "3235:                 (GetIsStrictMode() || hasNonSimpleParams)",
          "3237:                 && !HasScopeObject();",
          "3239:             return",
          "3241:                 (GetInParamsCount() > 1 || GetHasRestParameter())",
          "3242:                 && !dontNeedScopeObject;",
          "3243:         }",
          "3245:         uint GetNumberOfRecursiveCallSites();",
          "3246:         bool CanInlineRecursively(uint depth, bool tryAggressive = true);",
          "3247:     public:",
          "3248:         bool CanInlineAgain() const",
          "3249:         {",
          "3251:             return inlineDepth < static_cast<byte>(max(1, min(0xff, CONFIG_FLAG(MaxFuncInlineDepth))));",
          "3252:         }",
          "3254:         void OnBeginInlineInto()",
          "3255:         {",
          "3256:             ++inlineDepth;",
          "3257:         }",
          "3259:         void OnEndInlineInto()",
          "3260:         {",
          "3261:             --inlineDepth;",
          "3262:         }",
          "3264:         uint8 IncrementBailOnMisingProfileCount() { return ++bailOnMisingProfileCount; }",
          "3265:         void ResetBailOnMisingProfileCount() { bailOnMisingProfileCount = 0; }",
          "3266:         uint8 IncrementBailOnMisingProfileRejitCount() { return ++bailOnMisingProfileRejitCount; }",
          "3267:         uint32 GetFrameHeight(EntryPointInfo* entryPointInfo) const;",
          "3268:         void SetFrameHeight(EntryPointInfo* entryPointInfo, uint32 frameHeight);",
          "3270:         RegSlot GetLocalsCount();",
          "3271:         RegSlot GetConstantCount() const { return this->GetCountField(CounterFields::ConstantCount); }",
          "3272:         void CheckAndSetConstantCount(RegSlot cNewConstants);",
          "3273:         void SetConstantCount(RegSlot cNewConstants);",
          "3274:         RegSlot GetVarCount();",
          "3275:         void SetVarCount(RegSlot cNewVars);",
          "3276:         void CheckAndSetVarCount(RegSlot cNewVars);",
          "3277:         RegSlot MapRegSlot(RegSlot reg)",
          "3278:         {",
          "3279:             if (this->RegIsConst(reg))",
          "3280:             {",
          "3281:                 reg = CONSTREG_TO_REGSLOT(reg);",
          "3282:                 Assert(reg < this->GetConstantCount());",
          "3283:             }",
          "3284:             else",
          "3285:             {",
          "3286:                 reg += this->GetConstantCount();",
          "3287:             }",
          "3289:             return reg;",
          "3290:         }",
          "3291:         bool RegIsConst(RegSlot reg) { return reg > REGSLOT_TO_CONSTREG(this->GetConstantCount()); }",
          "3293:         uint32 GetNonTempLocalVarCount();",
          "3294:         uint32 GetFirstNonTempLocalIndex();",
          "3295:         uint32 GetEndNonTempLocalIndex();",
          "3296:         bool IsNonTempLocalVar(uint32 varIndex);",
          "3297:         bool GetSlotOffset(RegSlot slotId, int32 * slotOffset, bool allowTemp = false);",
          "3299:         RegSlot GetOutParamMaxDepth();",
          "3300:         void SetOutParamMaxDepth(RegSlot cOutParamsDepth);",
          "3301:         void CheckAndSetOutParamMaxDepth(RegSlot cOutParamsDepth);",
          "3303:         RegSlot GetYieldRegister();",
          "3305:         RegSlot GetFirstTmpRegister() const;",
          "3306:         void SetFirstTmpRegister(RegSlot reg);",
          "3308:         RegSlot GetFirstTmpReg();",
          "3309:         void SetFirstTmpReg(RegSlot firstTmpReg);",
          "3310:         RegSlot GetTempCount();",
          "3312:         Js::ModuleID GetModuleID() const;",
          "3314:         void CreateConstantTable();",
          "3315:         void RecordNullObject(RegSlot location);",
          "3316:         void RecordUndefinedObject(RegSlot location);",
          "3317:         void RecordTrueObject(RegSlot location);",
          "3318:         void RecordFalseObject(RegSlot location);",
          "3319:         void RecordIntConstant(RegSlot location, unsigned int val);",
          "3320:         void RecordStrConstant(RegSlot location, LPCOLESTR psz, uint32 cch);",
          "3321:         void RecordFloatConstant(RegSlot location, double d);",
          "3322:         void RecordNullDisplayConstant(RegSlot location);",
          "3323:         void RecordStrictNullDisplayConstant(RegSlot location);",
          "3324:         void InitConstantSlots(Var *dstSlots);",
          "3325:         Var GetConstantVar(RegSlot location);",
          "3326:         Field(Js::Var)* GetConstTable() const { return this->m_constTable; }",
          "3327:         void SetConstTable(Field(Js::Var)* constTable) { this->m_constTable = constTable; }",
          "3329:         void MarkScript(ByteBlock * pblkByteCode, ByteBlock * pblkAuxiliaryData, ByteBlock* auxContextBlock,",
          "3330:             uint byteCodeCount, uint byteCodeInLoopCount, uint byteCodeWithoutLDACount);",
          "3332:         void         BeginExecution();",
          "3333:         void         EndExecution();",
          "3334:         SourceInfo * GetSourceInfo() { return &this->m_sourceInfo; }",
          "3336:         bool InstallProbe(int offset);",
          "3337:         bool UninstallProbe(int offset);",
          "3338:         bool ProbeAtOffset(int offset, OpCode* pOriginalOpcode);",
          "3340:         static bool ShouldShareInlineCaches() { return CONFIG_FLAG(ShareInlineCaches); }",
          "3342:         uint GetInlineCacheCount() const { return GetCountField(CounterFields::InlineCacheCount); }",
          "3343:         void SetInlineCacheCount(uint count) { SetCountField(CounterFields::InlineCacheCount, count); }",
          "3345:         uint GetRootObjectLoadInlineCacheStart() const { return GetCountField(CounterFields::RootObjectLoadInlineCacheStart); }",
          "3346:         void SetRootObjectLoadInlineCacheStart(uint count) { SetCountField(CounterFields::RootObjectLoadInlineCacheStart, count); }",
          "3348:         uint GetRootObjectLoadMethodInlineCacheStart() const { return GetCountField(CounterFields::RootObjectLoadMethodInlineCacheStart); }",
          "3349:         void SetRootObjectLoadMethodInlineCacheStart(uint count) { SetCountField(CounterFields::RootObjectLoadMethodInlineCacheStart, count); }",
          "3351:         uint GetRootObjectStoreInlineCacheStart() const { return GetCountField(CounterFields::RootObjectStoreInlineCacheStart); }",
          "3352:         void SetRootObjectStoreInlineCacheStart(uint count) { SetCountField(CounterFields::RootObjectStoreInlineCacheStart, count); }",
          "3354:         uint GetIsInstInlineCacheCount() const { return GetCountField(CounterFields::IsInstInlineCacheCount); }",
          "3355:         void SetIsInstInlineCacheCount(uint count) { SetCountField(CounterFields::IsInstInlineCacheCount, count); }",
          "3357:         uint GetReferencedPropertyIdCount() const { return GetCountField(CounterFields::ReferencedPropertyIdCount); }",
          "3358:         void SetReferencedPropertyIdCount(uint count) { SetCountField(CounterFields::ReferencedPropertyIdCount, count); }",
          "3360:         uint GetObjLiteralCount() const { return GetCountField(CounterFields::ObjLiteralCount); }",
          "3361:         void SetObjLiteralCount(uint count) { SetCountField(CounterFields::ObjLiteralCount, count); }",
          "3362:         uint IncObjLiteralCount() { return IncreaseCountField(CounterFields::ObjLiteralCount); }",
          "3364:         uint GetLiteralRegexCount() const { return GetCountField(CounterFields::LiteralRegexCount); }",
          "3365:         void SetLiteralRegexCount(uint count) { SetCountField(CounterFields::LiteralRegexCount, count); }",
          "3366:         uint IncLiteralRegexCount() { return IncreaseCountField(CounterFields::LiteralRegexCount); }",
          "3368:         void AllocateForInCache();",
          "3369:         ForInCache * GetForInCache(uint index);",
          "3370:         ForInCache * GetForInCacheArray();",
          "3371:         void CleanUpForInCache(bool isShutdown);",
          "3373:         void AllocateInlineCache();",
          "3374:         InlineCache * GetInlineCache(uint index);",
          "3375:         bool CanFunctionObjectHaveInlineCaches();",
          "3376:         void** GetInlineCaches();",
          "3378: #if DBG",
          "3379:         byte* GetInlineCacheTypes();",
          "3380: #endif",
          "3381:         IsInstInlineCache * GetIsInstInlineCache(uint index);",
          "3382:         PolymorphicInlineCache * GetPolymorphicInlineCache(uint index);",
          "3383:         PolymorphicInlineCache * CreateNewPolymorphicInlineCache(uint index, PropertyId propertyId, InlineCache * inlineCache);",
          "3384:         PolymorphicInlineCache * CreateBiggerPolymorphicInlineCache(uint index, PropertyId propertyId);",
          "3385:     private:",
          "3387:         void ResetInlineCaches();",
          "3388:         PolymorphicInlineCache * CreatePolymorphicInlineCache(uint index, uint16 size);",
          "3389:         FieldWithBarrier(uint32) m_asmJsTotalLoopCount;",
          "3390:     public:",
          "3391:         void CreateCacheIdToPropertyIdMap();",
          "3392:         void CreateCacheIdToPropertyIdMap(uint rootObjectLoadInlineCacheStart, uint rootObjectLoadMethodInlineCacheStart, uint rootObjectStoreInlineCacheStart,",
          "3393:             uint totalFieldAccessInlineCacheCount, uint isInstInlineCacheCount);",
          "3394:         void SetPropertyIdForCacheId(uint cacheId, PropertyId propertyId);",
          "3395:         PropertyId GetPropertyIdFromCacheId(uint cacheId)",
          "3396:         {",
          "3397:             Assert(this->cacheIdToPropertyIdMap);",
          "3398:             Assert(cacheId < this->GetInlineCacheCount());",
          "3399:             return this->cacheIdToPropertyIdMap[cacheId];",
          "3400:         }",
          "3401: #if DBG",
          "3402:         void VerifyCacheIdToPropertyIdMap();",
          "3403: #endif",
          "3404:         PropertyId* GetReferencedPropertyIdMap() const { return static_cast<PropertyId*>(this->GetAuxPtr(AuxPointerType::ReferencedPropertyIdMap)); }",
          "3405:         PropertyId* GetReferencedPropertyIdMapWithLock() const { return static_cast<PropertyId*>(this->GetAuxPtrWithLock(AuxPointerType::ReferencedPropertyIdMap)); }",
          "3406:         void SetReferencedPropertyIdMap(PropertyId* propIdMap) { this->SetAuxPtr(AuxPointerType::ReferencedPropertyIdMap, propIdMap); }",
          "3407:         void CreateReferencedPropertyIdMap(uint referencedPropertyIdCount);",
          "3408:         void CreateReferencedPropertyIdMap();",
          "3409:         PropertyId GetReferencedPropertyIdWithMapIndex(uint mapIndex);",
          "3410:         PropertyId GetReferencedPropertyIdWithMapIndexWithLock(uint mapIndex);",
          "3411:         void SetReferencedPropertyIdWithMapIndex(uint mapIndex, PropertyId propertyId);",
          "3412:         PropertyId GetReferencedPropertyId(uint index);",
          "3413:         PropertyId GetReferencedPropertyIdWithLock(uint index);",
          "3414: #if DBG",
          "3415:         void VerifyReferencedPropertyIdMap();",
          "3416: #endif",
          "3417: #ifdef ENABLE_DEBUG_CONFIG_OPTIONS",
          "3418:         void DumpFullFunctionName();",
          "3419:         void DumpFunctionId(bool pad);",
          "3420:         uint GetTraceFunctionNumber() const;",
          "3421: #endif",
          "3423:     public:",
          "3424:         uint NewObjectLiteral();",
          "3425:         void AllocateObjectLiteralTypeArray();",
          "3426:         Field(DynamicType*)* GetObjectLiteralTypeRef(uint index);",
          "3427:         Field(DynamicType*)* GetObjectLiteralTypeRefWithLock(uint index);",
          "3428:         uint NewLiteralRegex();",
          "3429:         void AllocateLiteralRegexArray();",
          "3430:         Field(UnifiedRegex::RegexPattern*)* GetLiteralRegexes() const { return static_cast<Field(UnifiedRegex::RegexPattern*)*>(this->GetAuxPtr(AuxPointerType::LiteralRegexes)); }",
          "3431:         Field(UnifiedRegex::RegexPattern*)* GetLiteralRegexesWithLock() const { return static_cast<Field(UnifiedRegex::RegexPattern*)*>(this->GetAuxPtrWithLock(AuxPointerType::LiteralRegexes)); }",
          "3432:         void SetLiteralRegexs(UnifiedRegex::RegexPattern ** literalRegexes) { this->SetAuxPtr(AuxPointerType::LiteralRegexes, literalRegexes); }",
          "3433:         UnifiedRegex::RegexPattern *GetLiteralRegex(const uint index);",
          "3434:         UnifiedRegex::RegexPattern *GetLiteralRegexWithLock(const uint index);",
          "3435: #ifdef ASMJS_PLAT",
          "3436:         AsmJsFunctionInfo* GetAsmJsFunctionInfo()const { return static_cast<AsmJsFunctionInfo*>(this->GetAuxPtr(AuxPointerType::AsmJsFunctionInfo)); }",
          "3437:         AsmJsFunctionInfo* GetAsmJsFunctionInfoWithLock()const { return static_cast<AsmJsFunctionInfo*>(this->GetAuxPtrWithLock(AuxPointerType::AsmJsFunctionInfo)); }",
          "3438:         AsmJsFunctionInfo* AllocateAsmJsFunctionInfo();",
          "3439:         AsmJsModuleInfo* GetAsmJsModuleInfo()const { return static_cast<AsmJsModuleInfo*>(this->GetAuxPtr(AuxPointerType::AsmJsModuleInfo)); }",
          "3440:         AsmJsModuleInfo* GetAsmJsModuleInfoWithLock()const { return static_cast<AsmJsModuleInfo*>(this->GetAuxPtrWithLock(AuxPointerType::AsmJsModuleInfo)); }",
          "3441:         void ResetAsmJsInfo()",
          "3442:         {",
          "3443:             SetAuxPtr(AuxPointerType::AsmJsFunctionInfo, nullptr);",
          "3444:             SetAuxPtr(AuxPointerType::AsmJsModuleInfo, nullptr);",
          "3445:         }",
          "3446:         bool IsAsmJSModule()const{ return this->GetAsmJsFunctionInfo() != nullptr; }",
          "3447:         AsmJsModuleInfo* AllocateAsmJsModuleInfo();",
          "3448: #endif",
          "3449:         void SetLiteralRegex(const uint index, UnifiedRegex::RegexPattern *const pattern);",
          "3450:         Field(DynamicType*)* GetObjectLiteralTypes() const { return static_cast<Field(DynamicType*)*>(this->GetAuxPtr(AuxPointerType::ObjLiteralTypes)); }",
          "3451:         Field(DynamicType*)* GetObjectLiteralTypesWithLock() const { return static_cast<Field(DynamicType*)*>(this->GetAuxPtrWithLock(AuxPointerType::ObjLiteralTypes)); }",
          "3452:     private:",
          "3453:         void ResetLiteralRegexes();",
          "3454:         void ResetObjectLiteralTypes();",
          "3455:         void SetObjectLiteralTypes(DynamicType** objLiteralTypes) { this->SetAuxPtr(AuxPointerType::ObjLiteralTypes, objLiteralTypes); };",
          "3456:     public:",
          "3458:         void ResetByteCodeGenState();",
          "3459:         void ResetByteCodeGenVisitState();",
          "3461:         void FindClosestStatements(int32 characterOffset, StatementLocation *firstStatementLocation, StatementLocation *secondStatementLocation);",
          "3462: #if ENABLE_NATIVE_CODEGEN",
          "3463:         const FunctionCodeGenRuntimeData *GetInlineeCodeGenRuntimeData(const ProfileId profiledCallSiteId) const;",
          "3464:         const FunctionCodeGenRuntimeData *GetInlineeCodeGenRuntimeDataForTargetInlinee(const ProfileId profiledCallSiteId, FunctionBody *inlineeFuncBody) const;",
          "3465:         FunctionCodeGenRuntimeData *EnsureInlineeCodeGenRuntimeData(",
          "3466:             Recycler *const recycler,",
          "3467:             __in_range(0, profiledCallSiteCount - 1) const ProfileId profiledCallSiteId,",
          "3468:             FunctionBody *const inlinee);",
          "3469:         const FunctionCodeGenRuntimeData *GetLdFldInlineeCodeGenRuntimeData(const InlineCacheIndex inlineCacheIndex) const;",
          "3470:         FunctionCodeGenRuntimeData *EnsureLdFldInlineeCodeGenRuntimeData(",
          "3471:             Recycler *const recycler,",
          "3472:             const InlineCacheIndex inlineCacheIndex,",
          "3473:             FunctionBody *const inlinee);",
          "3475:         void LoadDynamicProfileInfo();",
          "3476:         bool HasExecutionDynamicProfileInfo() const { return hasExecutionDynamicProfileInfo; }",
          "3477:         bool HasDynamicProfileInfo() const { return dynamicProfileInfo != nullptr; }",
          "3478:         bool NeedEnsureDynamicProfileInfo() const;",
          "3479:         DynamicProfileInfo * GetDynamicProfileInfo() const { Assert(HasExecutionDynamicProfileInfo()); return dynamicProfileInfo; }",
          "3480:         DynamicProfileInfo * GetAnyDynamicProfileInfo() const { Assert(HasDynamicProfileInfo()); return dynamicProfileInfo; }",
          "3481:         DynamicProfileInfo * EnsureDynamicProfileInfo();",
          "3482:         DynamicProfileInfo * AllocateDynamicProfile();",
          "3483:         BYTE GetSavedInlinerVersion() const;",
          "3484:         uint32 GetSavedPolymorphicCacheState() const;",
          "3485:         void SetSavedPolymorphicCacheState(uint32 state);",
          "3486:         ImplicitCallFlags GetSavedImplicitCallsFlags() const;",
          "3487:         bool HasNonBuiltInCallee();",
          "3489:         void RecordNativeThrowMap(SmallSpanSequenceIter& iter, uint32 offset, uint32 statementIndex, EntryPointInfo* entryPoint, uint loopNum);",
          "3490:         void SetNativeThrowSpanSequence(SmallSpanSequence *seq, uint loopNum, LoopEntryPointInfo* entryPoint);",
          "3492:         BOOL GetMatchingStatementMapFromNativeAddress(DWORD_PTR codeAddress, StatementData &data, uint loopNum, FunctionBody *inlinee = nullptr);",
          "3493:         BOOL GetMatchingStatementMapFromNativeOffset(DWORD_PTR codeAddress, uint32 offset, StatementData &data, uint loopNum, FunctionBody *inlinee = nullptr);",
          "3495:         FunctionEntryPointInfo * GetEntryPointFromNativeAddress(DWORD_PTR codeAddress);",
          "3496:         LoopEntryPointInfo * GetLoopEntryPointInfoFromNativeAddress(DWORD_PTR codeAddress, uint loopNum) const;",
          "3497: #endif",
          "3499:         void InsertSymbolToRegSlotList(JsUtil::CharacterBuffer<WCHAR> const& propName, RegSlot reg, RegSlot totalRegsCount);",
          "3500:         void InsertSymbolToRegSlotList(RegSlot reg, PropertyId propertyId, RegSlot totalRegsCount);",
          "3501:         void SetPropertyIdsOfFormals(PropertyIdArray * formalArgs);",
          "3502:         PropertyIdArray * AllocatePropertyIdArrayForFormals(uint32 size, uint32 count, byte extraSlots);",
          "3504:         bool DontRethunkAfterBailout() const { return dontRethunkAfterBailout; }",
          "3505:         void SetDontRethunkAfterBailout() { dontRethunkAfterBailout = true; }",
          "3506:         void ClearDontRethunkAfterBailout() { dontRethunkAfterBailout = false; }",
          "3508:         void SaveState(ParseNodePtr pnode);",
          "3509:         void RestoreState(ParseNodePtr pnode);",
          "3513:         bool HasAllNonLocalReferenced() const { return m_hasAllNonLocalReferenced; }",
          "3514:         void SetAllNonLocalReferenced(bool set) { m_hasAllNonLocalReferenced = set; }",
          "3516:         bool HasSetIsObject() const { return m_hasSetIsObject; }",
          "3517:         void SetHasSetIsObject(bool set) { m_hasSetIsObject = set; }",
          "3519:         bool HasFuncExprNameReference() const { return m_hasFunExprNameReference; }",
          "3520:         void SetFuncExprNameReference(bool value) { m_hasFunExprNameReference = value; }",
          "3522:         bool GetChildCallsEval() const { return m_ChildCallsEval; }",
          "3523:         void SetChildCallsEval(bool value) { m_ChildCallsEval = value; }",
          "3525:         bool GetCallsEval() const { return m_CallsEval; }",
          "3526:         void SetCallsEval(bool set) { m_CallsEval = set; }",
          "3528:         bool HasReferenceableBuiltInArguments() const { return m_hasReferenceableBuiltInArguments; }",
          "3529:         void SetHasReferenceableBuiltInArguments(bool value) { m_hasReferenceableBuiltInArguments = value; }",
          "3531:         bool IsParamAndBodyScopeMerged() const { return m_isParamAndBodyScopeMerged; }",
          "3532:         void SetParamAndBodyScopeNotMerged() { m_isParamAndBodyScopeMerged = false; }",
          "3535:         bool HasDoneAllNonLocalReferenced() const { return m_hasDoneAllNonLocalReferenced; }",
          "3536:         void SetHasDoneAllNonLocalReferenced(bool set) { m_hasDoneAllNonLocalReferenced = set; }",
          "3539:         bool HasFunctionCompiledSent() const { return m_hasFunctionCompiledSent; }",
          "3540:         void SetHasFunctionCompiledSent(bool set) { m_hasFunctionCompiledSent = set; }",
          "3542: #if DBG_DUMP",
          "3543:         void DumpStatementMaps();",
          "3544:         void Dump();",
          "3545:         void PrintStatementSourceLine(uint statementIndex);",
          "3546:         void PrintStatementSourceLineFromStartOffset(uint cchStartOffset);",
          "3547:         void DumpScopes();",
          "3548: #endif",
          "3550:         uint GetStatementStartOffset(const uint statementIndex);",
          "3552: #ifdef IR_VIEWER",
          "3553:         void GetSourceLineFromStartOffset(const uint startOffset, LPCUTF8 *sourceBegin, LPCUTF8 *sourceEnd,",
          "3554:             ULONG * line, LONG * col);",
          "3555:         void GetStatementSourceInfo(const uint statementIndex, LPCUTF8 *sourceBegin, LPCUTF8 *sourceEnd,",
          "3556:             ULONG * line, LONG * col);",
          "3557: #endif",
          "3559: #if ENABLE_TTD",
          "3560:         void GetSourceLineFromStartOffset_TTD(const uint startOffset, ULONG* line, LONG* col);",
          "3561: #endif",
          "3563: #ifdef ENABLE_SCRIPT_PROFILING",
          "3564:         HRESULT RegisterFunction(BOOL fChangeMode, BOOL fOnlyCurrent = FALSE);",
          "3565:         HRESULT ReportScriptCompiled();",
          "3566:         HRESULT ReportFunctionCompiled();",
          "3567:         void SetEntryToProfileMode();",
          "3568: #endif",
          "3570:         void CheckAndRegisterFuncToDiag(ScriptContext *scriptContext);",
          "3571:         void SetEntryToDeferParseForDebugger();",
          "3572:         void ClearEntryPoints();",
          "3573:         void ResetEntryPoint();",
          "3574:         void CleanupToReparse();",
          "3575:         void AddDeferParseAttribute();",
          "3576:         void RemoveDeferParseAttribute();",
          "3577: #if DBG",
          "3578:         void MustBeInDebugMode();",
          "3579: #endif",
          "3581:         static bool IsDummyGlobalRetStatement(const regex::Interval *sourceSpan)",
          "3582:         {",
          "3583:             Assert(sourceSpan != nullptr);",
          "3584:             return sourceSpan->begin == 0 && sourceSpan->end == 0;",
          "3585:         }",
          "3587:         static void GetShortNameFromUrl(__in LPCWSTR pchUrl, _Out_writes_z_(cchBuffer) LPWSTR pchShortName, __in size_t cchBuffer);",
          "3589:         template<class Fn>",
          "3590:         void MapLoopHeaders(Fn fn) const",
          "3591:         {",
          "3592:             Js::LoopHeader* loopHeaderArray = this->GetLoopHeaderArray();",
          "3593:             if(loopHeaderArray)",
          "3594:             {",
          "3595:                 uint loopCount = this->GetLoopCount();",
          "3596:                 for(uint i = 0; i < loopCount; i++)",
          "3597:                 {",
          "3598:                     fn(i , &loopHeaderArray[i]);",
          "3599:                 }",
          "3600:             }",
          "3601:         }",
          "3602:         template<class Fn>",
          "3603:         void MapLoopHeadersWithLock(Fn fn) const",
          "3604:         {",
          "3605:             Js::LoopHeader* loopHeaderArray = this->GetLoopHeaderArrayWithLock();",
          "3606:             if (loopHeaderArray)",
          "3607:             {",
          "3608:                 uint loopCount = this->GetLoopCount();",
          "3609:                 for (uint i = 0; i < loopCount; i++)",
          "3610:                 {",
          "3611:                     fn(i, &loopHeaderArray[i]);",
          "3612:                 }",
          "3613:             }",
          "3614:         }",
          "3616:         template<class Fn>",
          "3617:         bool MapLoopHeadersUntil(Fn fn) const",
          "3618:         {",
          "3619:             Js::LoopHeader* loopHeaderArray = this->GetLoopHeaderArray();",
          "3620:             if (loopHeaderArray)",
          "3621:             {",
          "3622:                 uint loopCount = this->GetLoopCount();",
          "3623:                 for (uint i = 0; i < loopCount; i++)",
          "3624:                 {",
          "3625:                     if (fn(i, &loopHeaderArray[i]))",
          "3626:                     {",
          "3627:                         return true;",
          "3628:                     }",
          "3629:                 }",
          "3630:                 return false;",
          "3631:             }",
          "3632:             return false;",
          "3633:         }",
          "3635:         template <class Fn>",
          "3636:         void MapEntryPoints(Fn fn) const",
          "3637:         {",
          "3638:             if (this->entryPoints)",
          "3639:             {",
          "3640:                 this->entryPoints->Map([&fn] (int index, RecyclerWeakReference<FunctionEntryPointInfo>* entryPoint) {",
          "3641:                     FunctionEntryPointInfo* strongRef = entryPoint->Get();",
          "3642:                     if (strongRef)",
          "3643:                     {",
          "3644:                         fn(index, strongRef);",
          "3645:                     }",
          "3646:                 });",
          "3647:             }",
          "3648:         }",
          "3650:         template <class Fn>",
          "3651:         bool MapEntryPointsUntil(Fn fn) const",
          "3652:         {",
          "3653:             if (this->entryPoints)",
          "3654:             {",
          "3655:                 return this->entryPoints->MapUntil([&fn](int index, RecyclerWeakReference<FunctionEntryPointInfo>* entryPoint) {",
          "3656:                     FunctionEntryPointInfo* strongRef = entryPoint->Get();",
          "3657:                     if (strongRef)",
          "3658:                     {",
          "3659:                         return fn(index, strongRef);",
          "3660:                     }",
          "3661:                     return false;",
          "3662:                 });",
          "3663:             }",
          "3664:             return false;",
          "3665:         }",
          "3667:         bool DoJITLoopBody() const",
          "3668:         {",
          "3669:             return IsJitLoopBodyPhaseEnabled() && this->GetLoopHeaderArrayWithLock() != nullptr;",
          "3670:         }",
          "3672:         bool ForceJITLoopBody() const",
          "3673:         {",
          "3674:             return IsJitLoopBodyPhaseForced() && !this->GetHasTry();",
          "3675:         }",
          "3677:         bool IsGeneratorAndJitIsDisabled()",
          "3678:         {",
          "3679:             return this->IsCoroutine() && !(CONFIG_ISENABLED(Js::JitES6GeneratorsFlag) && !this->GetHasTry());",
          "3680:         }",
          "3682:         FunctionBodyFlags * GetAddressOfFlags() { return &this->flags; }",
          "3683:         Js::RegSlot GetRestParamRegSlot();",
          "3685:     public:",
          "3686:         void RecordConstant(RegSlot location, Var var);",
          "3688:     private:",
          "3689:         inline  void            CheckEmpty();",
          "3690:         inline  void            CheckNotExecuting();",
          "3692:         BOOL               GetMatchingStatementMap(StatementData &data, int statementIndex, FunctionBody *inlinee);",
          "3694: #if ENABLE_NATIVE_CODEGEN",
          "3695:         int                GetStatementIndexFromNativeOffset(SmallSpanSequence *pThrowSpanSequence, uint32 nativeOffset);",
          "3696:         int                GetStatementIndexFromNativeAddress(SmallSpanSequence *pThrowSpanSequence, DWORD_PTR codeAddress, DWORD_PTR nativeBaseAddress);",
          "3697: #endif",
          "3699:         void EnsureAuxStatementData();",
          "3700:         StatementAdjustmentRecordList* GetStatementAdjustmentRecords();",
          "3701:     };",
          "3703:     class AutoRestoreFunctionInfo {",
          "3704:     public:",
          "3705:         AutoRestoreFunctionInfo(ParseableFunctionInfo *pfi, const JavascriptMethod originalEntryPoint) : pfi(pfi), funcBody(nullptr), originalEntryPoint(originalEntryPoint) {}",
          "3706:         ~AutoRestoreFunctionInfo() {",
          "3707:             if (this->pfi != nullptr && this->pfi->GetFunctionInfo()->GetFunctionProxy() != this->pfi)",
          "3708:             {",
          "3709:                 FunctionInfo *functionInfo = this->pfi->GetFunctionInfo();",
          "3710:                 functionInfo->SetAttributes(",
          "3711:                     (FunctionInfo::Attributes)(functionInfo->GetAttributes() | FunctionInfo::Attributes::DeferredParse));",
          "3712:                 functionInfo->SetFunctionProxy(this->pfi);",
          "3713:                 functionInfo->SetOriginalEntryPoint(originalEntryPoint);",
          "3714:             }",
          "3716:             Assert(this->pfi == nullptr || (this->pfi->GetFunctionInfo()->GetFunctionProxy() == this->pfi && !this->pfi->IsFunctionBody()));",
          "3717:         }",
          "3718:         void Clear() { pfi = nullptr; funcBody = nullptr; }",
          "3720:         ParseableFunctionInfo * pfi;",
          "3721:         FunctionBody          * funcBody;",
          "3722:         const JavascriptMethod originalEntryPoint;",
          "3723:     };",
          "3727:     typedef SynchronizableList<FunctionBody*, JsUtil::List<FunctionBody*, ArenaAllocator, false, Js::FreeListedRemovePolicy> > FunctionBodyList;",
          "3729:     struct ScopeSlots",
          "3730:     {",
          "3731:     public:",
          "3732:         static uint const MaxEncodedSlotCount = Constants::UShortMaxValue;",
          "3735:         static uint const EncodedSlotCountSlotIndex = 0;",
          "3736:         static uint const ScopeMetadataSlotIndex = 1;    // Either a FunctionBody* or DebuggerScope*",
          "3737:         static uint const FirstSlotIndex = 2;",
          "3738:     public:",
          "3739:         ScopeSlots(Var* slotArray) : slotArray((Field(Var)*)slotArray)",
          "3740:         {",
          "3741:         }",
          "3743:         bool IsFunctionScopeSlotArray()",
          "3744:         {",
          "3745:             return FunctionInfo::Is(slotArray[ScopeMetadataSlotIndex]);",
          "3746:         }",
          "3748:         FunctionInfo* GetFunctionInfo()",
          "3749:         {",
          "3750:             Assert(IsFunctionScopeSlotArray());",
          "3751:             return (FunctionInfo*)PointerValue(slotArray[ScopeMetadataSlotIndex]);",
          "3752:         }",
          "3754:         DebuggerScope* GetDebuggerScope()",
          "3755:         {",
          "3756:             Assert(!IsFunctionScopeSlotArray());",
          "3757:             return (DebuggerScope*)PointerValue(slotArray[ScopeMetadataSlotIndex]);",
          "3758:         }",
          "3760:         Var GetScopeMetadataRaw() const",
          "3761:         {",
          "3762:             return slotArray[ScopeMetadataSlotIndex];",
          "3763:         }",
          "3765:         void SetScopeMetadata(Var scopeMetadataObj)",
          "3766:         {",
          "3767:             slotArray[ScopeMetadataSlotIndex] = scopeMetadataObj;",
          "3768:         }",
          "3770:         uint GetCount() const",
          "3771:         {",
          "3772:             return ::Math::PointerCastToIntegralTruncate<uint>(slotArray[EncodedSlotCountSlotIndex]);",
          "3773:         }",
          "3775:         void SetCount(uint count)",
          "3776:         {",
          "3777:             slotArray[EncodedSlotCountSlotIndex] = (Var)min<uint>(count, ScopeSlots::MaxEncodedSlotCount);",
          "3778:         }",
          "3780:         Var Get(uint i) const",
          "3781:         {",
          "3782:             Assert(i < GetCount());",
          "3783:             return slotArray[i + FirstSlotIndex];",
          "3784:         }",
          "3786:         void Set(uint i, Var value)",
          "3787:         {",
          "3788:             Assert(i < GetCount());",
          "3789:             slotArray[i + FirstSlotIndex] = value;",
          "3790:         }",
          "3792:         template<class Fn>",
          "3793:         void Map(Fn fn)",
          "3794:         {",
          "3795:             uint count = GetCount();",
          "3796:             for(uint i = 0; i < count; i++)",
          "3797:             {",
          "3798:                 fn(GetSlot[i]);",
          "3799:             }",
          "3800:         }",
          "3807:         static bool Is(void* object)",
          "3808:         {",
          "3809:             size_t slotCount = *((size_t*)object);",
          "3810:             if(slotCount <= MaxEncodedSlotCount)",
          "3811:             {",
          "3812:                 return true;",
          "3813:             }",
          "3814:             return false;",
          "3815:         }",
          "3817:     private:",
          "3818:         Field(Field(Var)*) slotArray;",
          "3819:     };",
          "3822:     enum ScopeType",
          "3823:     {",
          "3824:         ScopeType_ActivationObject,",
          "3825:         ScopeType_SlotArray,",
          "3826:         ScopeType_WithScope",
          "3827:     };",
          "3832:     struct FrameDisplay",
          "3833:     {",
          "3834:         FrameDisplay(uint16 len, bool strictMode = false) :",
          "3835:             tag(true),",
          "3836:             length(len),",
          "3837:             strictMode(strictMode)",
          "3838: #if _M_X64",
          "3839:             , unused(0)",
          "3840: #endif",
          "3841:         {",
          "3842:         }",
          "3844:         void SetTag(bool tag) { this->tag = tag; }",
          "3845:         void SetItem(uint index, void* item);",
          "3846:         void *GetItem(uint index);",
          "3847:         uint16 GetLength() const { return length; }",
          "3848:         void SetLength(uint16 len) { this->length = len; }",
          "3850:         bool   GetStrictMode() const { return strictMode; }",
          "3851:         void   SetStrictMode(bool flag) { this->strictMode = flag; }",
          "3853:         void** GetDataAddress() { return (void**)&this->scopes; }",
          "3854:         static uint32 GetOffsetOfStrictMode() { return offsetof(FrameDisplay, strictMode); }",
          "3855:         static uint32 GetOffsetOfLength() { return offsetof(FrameDisplay, length); }",
          "3856:         static uint32 GetOffsetOfScopes() { return offsetof(FrameDisplay, scopes); }",
          "3857:         static ScopeType GetScopeType(void* scope);",
          "3859:     private:",
          "3860:         Field(bool) tag;              // Tag it so that the NativeCodeGenerator::IsValidVar would not think this is var",
          "3861:         Field(bool) strictMode;",
          "3862:         Field(uint16) length;",
          "3864: #if defined(_M_X64_OR_ARM64)",
          "3865:         Field(uint32) unused;",
          "3866: #endif",
          "3867:         Field(void*) scopes[];",
          "3868:     };",
          "3869: #pragma region Function Body helper classes",
          "3870: #pragma region Debugging related source classes",
          "3873:     struct StatementData",
          "3874:     {",
          "3875:         StatementData()",
          "3876:             : sourceBegin(0),",
          "3877:             bytecodeBegin(0)",
          "3878:         {",
          "3879:         }",
          "3881:         int sourceBegin;",
          "3882:         int bytecodeBegin;",
          "3883:     };",
          "3885:     struct StatementLocation",
          "3886:     {",
          "3887:         Js::FunctionBody* function;",
          "3888:         regex::Interval statement;",
          "3889:         regex::Interval bytecodeSpan;",
          "3890:     };",
          "3893:     struct SmallSpan",
          "3894:     {",
          "3895:         ushort sourceBegin;",
          "3896:         ushort bytecodeBegin;",
          "3898:         SmallSpan(uint32 val)",
          "3899:         {",
          "3900:             sourceBegin = (ushort)(val >> 16);",
          "3901:             bytecodeBegin = (ushort)(val & 0x0000FFFF);",
          "3902:         }",
          "3904:         operator unsigned int()",
          "3905:         {",
          "3906:             return (uint32)sourceBegin << 16 | bytecodeBegin;",
          "3907:         }",
          "3908:     };",
          "3912:     class SmallSpanSequenceIter",
          "3913:     {",
          "3914:         friend class SmallSpanSequence;",
          "3916:     public:",
          "3917:         SmallSpanSequenceIter()",
          "3918:             : accumulatedIndex(-1),",
          "3919:             accumulatedSourceBegin(0),",
          "3920:             accumulatedBytecodeBegin(0),",
          "3921:             indexOfActualOffset(0)",
          "3922:         {",
          "3924:         }",
          "3928:         int accumulatedIndex;",
          "3929:         int accumulatedSourceBegin;",
          "3930:         int accumulatedBytecodeBegin;",
          "3932:         int indexOfActualOffset;",
          "3933:     };",
          "3935:     struct ThrowMapEntry",
          "3936:     {",
          "3937:         uint32 nativeBufferOffset;",
          "3938:         uint32 statementIndex;",
          "3939:     };",
          "3946:     class SmallSpanSequence",
          "3947:     {",
          "3948:     private:",
          "3949:         BOOL GetRangeAt(int index, SmallSpanSequenceIter &iter, int * pCountOfMissed, StatementData & data);",
          "3950:         ushort GetDiff(int current, int prev);",
          "3952:     public:",
          "3957:         JsUtil::GrowingUint32HeapArray * pStatementBuffer;",
          "3960:         JsUtil::GrowingUint32HeapArray * pActualOffsetList;",
          "3963:         int baseValue;",
          "3965:         SmallSpanSequence();",
          "3967:         ~SmallSpanSequence()",
          "3968:         {",
          "3969:             Cleanup();",
          "3970:         }",
          "3972:         void Cleanup()",
          "3973:         {",
          "3974:             if (pStatementBuffer != nullptr)",
          "3975:             {",
          "3976:                 HeapDelete(pStatementBuffer);",
          "3977:                 pStatementBuffer = nullptr;",
          "3978:             }",
          "3980:             if (pActualOffsetList != nullptr)",
          "3981:             {",
          "3982:                 HeapDelete(pActualOffsetList);",
          "3983:                 pActualOffsetList = nullptr;",
          "3984:             }",
          "3985:         }",
          "3988:         BOOL GetMatchingStatementFromBytecode(int bytecode, SmallSpanSequenceIter &iter, StatementData & data);",
          "3991:         BOOL RecordARange(SmallSpanSequenceIter &iter, StatementData * data);",
          "3994:         void Reset(SmallSpanSequenceIter &iter);",
          "3996:         uint32 Count() const { return pStatementBuffer ? pStatementBuffer->Count() : 0; }",
          "3998:         BOOL Item(int index, SmallSpanSequenceIter &iter, StatementData &data);",
          "4001:         BOOL Seek(int index, StatementData & data);",
          "4002:     };",
          "4003: #pragma endregion",
          "4007:     struct PropertyIdOnRegSlotsContainer",
          "4008:     {",
          "4009:         Field(PropertyId *) propertyIdsForRegSlots;",
          "4010:         Field(uint) length;",
          "4014:         Field(RegSlot) formalsUpperBound;",
          "4016:         Field(PropertyIdArray *) propertyIdsForFormalArgs;",
          "4018:         PropertyIdOnRegSlotsContainer();",
          "4019:         static PropertyIdOnRegSlotsContainer * New(Recycler * recycler);",
          "4021:         void CreateRegSlotsArray(Recycler * recycler, uint _length);",
          "4022:         void SetFormalArgs(PropertyIdArray * formalArgs);",
          "4025:         void Insert(RegSlot reg, PropertyId propId);",
          "4026:         void FetchItemAt(uint index, FunctionBody *pFuncBody, __out PropertyId *pPropId, __out RegSlot *pRegSlot);",
          "4028:         bool IsRegSlotFormal(RegSlot reg);",
          "4029:     };",
          "4032:     typedef int DebuggerScopePropertyFlags;",
          "4033:     const int DebuggerScopePropertyFlags_None                   = 0x000000000;",
          "4034:     const int DebuggerScopePropertyFlags_Const                  = 0x000000001;",
          "4035:     const int DebuggerScopePropertyFlags_CatchObject            = 0x000000002;",
          "4036:     const int DebuggerScopePropertyFlags_WithObject             = 0x000000004;",
          "4037:     const int DebuggerScopePropertyFlags_ForInOrOfCollection    = 0x000000008;",
          "4038:     const int DebuggerScopePropertyFlags_HasDuplicateInBody     = 0x000000016;",
          "4042:     class DebuggerScopeProperty",
          "4043:     {",
          "4044:     public:",
          "4045:         Js::PropertyId propId;              // The property ID of the scope variable.",
          "4046:         RegSlot location;                   // Contains the location of the scope variable (regslot, slotarray, direct).",
          "4047:         int byteCodeInitializationOffset;   // The byte code offset used when comparing let/const variables for dead zone exclusion debugger side.",
          "4048:         DebuggerScopePropertyFlags flags;   // Flags for the property.",
          "4050:         bool IsConst() const { return (flags & DebuggerScopePropertyFlags_Const) != 0; }",
          "4051:         bool IsCatchObject() const { return (flags & DebuggerScopePropertyFlags_CatchObject) != 0; }",
          "4052:         bool IsWithObject() const { return (flags & DebuggerScopePropertyFlags_WithObject) != 0; }",
          "4053:         bool IsForInOrForOfCollectionScope() const { return (flags & DebuggerScopePropertyFlags_ForInOrOfCollection) != 0; }",
          "4055:     public:",
          "4059:         bool IsInDeadZone(int byteCodeOffset) const",
          "4060:         {",
          "4061:             if (IsForInOrForOfCollectionScope())",
          "4062:             {",
          "4066:                 return true;",
          "4067:             }",
          "4069:             if (this->byteCodeInitializationOffset == Constants::InvalidByteCodeOffset && !(IsCatchObject() || IsWithObject()))",
          "4070:             {",
          "4071:                 AssertMsg(false, \"Debug let/const property never had its initialization point updated.  This indicates that a Ld or St operation in ByteCodeGenerator was missed that needs to have DebuggerScope::UpdatePropertyInitializationOffset() added to it.\");",
          "4072:                 return false;",
          "4073:             }",
          "4075:             return byteCodeOffset < this->byteCodeInitializationOffset;",
          "4076:         }",
          "4077:     };",
          "4080:     class DebuggerScope",
          "4081:     {",
          "4082:     public:",
          "4083:         typedef JsUtil::List<DebuggerScopeProperty> DebuggerScopePropertyList;",
          "4085:         DebuggerScope(Recycler* recycler, DiagExtraScopesType scopeType, RegSlot scopeLocation, int rangeBegin)",
          "4086:             : scopeType(scopeType),",
          "4087:               scopeProperties(nullptr),",
          "4088:               parentScope(nullptr),",
          "4089:               siblingScope(nullptr),",
          "4090:               scopeLocation(scopeLocation),",
          "4091:               recycler(recycler)",
          "4092:         {",
          "4093:             this->range.begin = rangeBegin;",
          "4094:             this->range.end = -1;",
          "4095:         }",
          "4097:         DebuggerScope * GetSiblingScope(RegSlot location, FunctionBody *functionBody);",
          "4098:         void AddProperty(RegSlot location, Js::PropertyId propertyId, DebuggerScopePropertyFlags flags);",
          "4099:         bool GetPropertyIndex(Js::PropertyId propertyId, int& i);",
          "4100:         bool HasProperty(Js::PropertyId propertyId);",
          "4102:         bool IsOffsetInScope(int offset) const;",
          "4103:         bool Contains(Js::PropertyId propertyId, RegSlot location) const;",
          "4104:         bool IsBlockScope() const;",
          "4105:         bool IsBlockObjectScope() const",
          "4106:         {",
          "4107:             return this->scopeType == Js::DiagBlockScopeInObject;",
          "4108:         }",
          "4109:         bool IsCatchScope() const;",
          "4110:         bool IsWithScope() const;",
          "4111:         bool IsSlotScope() const;",
          "4112:         bool IsParamScope() const;",
          "4113:         bool HasProperties() const;",
          "4114:         bool IsAncestorOf(const DebuggerScope* potentialChildScope);",
          "4115:         bool AreAllPropertiesInDeadZone(int byteCodeOffset) const;",
          "4116:         RegSlot GetLocation() const { Assert(IsOwnScope()); return scopeLocation; }",
          "4117:         bool IsOwnScope() const { return scopeLocation != Js::Constants::NoRegister; }",
          "4118:         bool TryGetProperty(Js::PropertyId propertyId, RegSlot location, DebuggerScopeProperty* outScopeProperty) const;",
          "4119:         bool TryGetValidProperty(Js::PropertyId propertyId, RegSlot location, int offset, DebuggerScopeProperty* outScopeProperty, bool* isInDeadZone) const;",
          "4120:         bool UpdatePropertyInitializationOffset(RegSlot location, Js::PropertyId propertyId, int byteCodeOffset, bool isFunctionDeclaration = false);",
          "4121:         void UpdateDueToByteCodeRegeneration(DiagExtraScopesType scopeType, int start, RegSlot scopeLocation);",
          "4122:         void UpdatePropertiesInForInOrOfCollectionScope();",
          "4124:         void SetParentScope(DebuggerScope* parentScope) { this->parentScope = parentScope; }",
          "4125:         DebuggerScope* GetParentScope() const { return parentScope; }",
          "4126:         DebuggerScope* FindCommonAncestor(DebuggerScope* debuggerScope);",
          "4127:         int GetEnd() const { return range.end; }",
          "4128:         int GetStart() const { return range.begin; }",
          "4130:         void SetScopeLocation(RegSlot scopeLocation) { this->scopeLocation = scopeLocation; }",
          "4132:         void SetBegin(int begin);",
          "4133:         void SetEnd(int end);",
          "4134: #if DBG",
          "4135:         void Dump();",
          "4136:         PCWSTR GetDebuggerScopeTypeString(DiagExtraScopesType scopeType);",
          "4137: #endif",
          "4139: #if ENABLE_TTD",
          "4140:         Js::PropertyId GetPropertyIdForSlotIndex_TTD(uint32 slotIndex) const;",
          "4141: #endif",
          "4143:     public:",
          "4148:         Field(DebuggerScopePropertyList*) scopeProperties;",
          "4149:         Field(DiagExtraScopesType) scopeType; // The type of scope being represented (With, Catch, or Block scope).",
          "4150:         Field(DebuggerScope*) siblingScope;  // Valid only when current scope is slot/activationobject and symbols are on direct regslot",
          "4151:         static const int InvalidScopeIndex = -1;",
          "4152:     private:",
          "4153:         int GetScopeDepth() const;",
          "4154:         bool UpdatePropertyInitializationOffsetInternal(RegSlot location, Js::PropertyId propertyId, int byteCodeOffset, bool isFunctionDeclaration = false);",
          "4155:         void EnsurePropertyListIsAllocated();",
          "4157:     private:",
          "4158:         Field(DebuggerScope*) parentScope;",
          "4159:         Field(regex::Interval) range; // The start and end byte code writer offsets used when comparing where the debugger is currently stopped at (breakpoint location).",
          "4160:         Field(RegSlot) scopeLocation;",
          "4161:         FieldNoBarrier(Recycler*) recycler;",
          "4162:     };",
          "4164:     class ScopeObjectChain",
          "4165:     {",
          "4166:     public:",
          "4168:         typedef JsUtil::List<DebuggerScope*> ScopeObjectChainList;",
          "4170:         ScopeObjectChain(Recycler* recycler)",
          "4171:             : pScopeChain(nullptr)",
          "4172:         {",
          "4173:             pScopeChain = RecyclerNew(recycler, ScopeObjectChainList, recycler);",
          "4174:         }",
          "4180:         bool TryGetDebuggerScopePropertyInfo(PropertyId propertyId, RegSlot location, int offset, bool* isPropertyInDebuggerScope, bool *isConst, bool* isInDeadZone);",
          "4183:         Field(ScopeObjectChainList*) pScopeChain;",
          "4184:     };",
          "4185: #pragma endregion",
          "4186: } // namespace Js",
          "",
          "---------------"
        ],
        "lib/Runtime/Base/ScriptContext.cpp||lib/Runtime/Base/ScriptContext.cpp": [
          "File: lib/Runtime/Base/ScriptContext.cpp -> lib/Runtime/Base/ScriptContext.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "5: #include \"RuntimeBasePch.h\"",
          "8: #include \"RegexCommon.h\"",
          "9: #include \"DebugWriter.h\"",
          "10: #include \"RegexStats.h\"",
          "12: #include \"ByteCode/ByteCodeApi.h\"",
          "13: #include \"Library/ProfileString.h\"",
          "14: #include \"Debug/DiagHelperMethodWrapper.h\"",
          "15: #include \"BackendApi.h\"",
          "16: #if PROFILE_DICTIONARY",
          "17: #include \"DictionaryStats.h\"",
          "18: #endif",
          "20: #include \"Base/ScriptContextProfiler.h\"",
          "21: #include \"Base/EtwTrace.h\"",
          "23: #include \"Language/InterpreterStackFrame.h\"",
          "24: #include \"Language/SourceDynamicProfileManager.h\"",
          "25: #include \"Language/JavascriptStackWalker.h\"",
          "26: #include \"Language/AsmJsTypes.h\"",
          "27: #include \"Language/AsmJsModule.h\"",
          "28: #ifdef ASMJS_PLAT",
          "29: #include \"Language/AsmJsEncoder.h\"",
          "30: #include \"Language/AsmJsCodeGenerator.h\"",
          "31: #include \"Language/AsmJsUtils.h\"",
          "32: #endif",
          "34: #ifdef ENABLE_BASIC_TELEMETRY",
          "35: #include \"ScriptContextTelemetry.h\"",
          "36: #endif",
          "38: namespace Js",
          "39: {",
          "40:     ScriptContext * ScriptContext::New(ThreadContext * threadContext)",
          "41:     {",
          "42:         AutoPtr<ScriptContext> scriptContext(HeapNew(ScriptContext, threadContext));",
          "43:         scriptContext->InitializeAllocations();",
          "44:         return scriptContext.Detach();",
          "45:     }",
          "47:     void ScriptContext::Delete(ScriptContext* scriptContext)",
          "48:     {",
          "49:         HeapDelete(scriptContext);",
          "50:     }",
          "52:     CriticalSection JITPageAddrToFuncRangeCache::cs;",
          "54:     ScriptContext::ScriptContext(ThreadContext* threadContext) :",
          "55:         ScriptContextBase(),",
          "56:         prev(nullptr),",
          "57:         next(nullptr),",
          "58:         interpreterArena(nullptr),",
          "59:         moduleSrcInfoCount(0),",
          "61: #if ENABLE_REGEX_CONFIG_OPTIONS",
          "62:         regexStatsDatabase(0),",
          "63:         regexDebugWriter(0),",
          "64: #endif",
          "65:         trigramAlphabet(nullptr),",
          "66:         regexStacks(nullptr),",
          "67:         arrayMatchInit(false),",
          "68:         config(threadContext->GetConfig(), threadContext->IsOptimizedForManyInstances()),",
          "69: #if ENABLE_BACKGROUND_PARSING",
          "70:         backgroundParser(nullptr),",
          "71: #endif",
          "72: #if ENABLE_NATIVE_CODEGEN",
          "73:         nativeCodeGen(nullptr),",
          "74:         m_domFastPathHelperMap(nullptr),",
          "75: #endif",
          "76:         threadContext(threadContext),",
          "77:         scriptStartEventHandler(nullptr),",
          "78:         scriptEndEventHandler(nullptr),",
          "79: #ifdef FAULT_INJECTION",
          "80:         disposeScriptByFaultInjectionEventHandler(nullptr),",
          "81: #endif",
          "82:         integerStringMap(this->GeneralAllocator()),",
          "83:         guestArena(nullptr),",
          "84:         raiseMessageToDebuggerFunctionType(nullptr),",
          "85:         transitionToDebugModeIfFirstSourceFn(nullptr),",
          "86:         sourceSize(0),",
          "87:         deferredBody(false),",
          "88:         isScriptContextActuallyClosed(false),",
          "89:         isFinalized(false),",
          "90:         isEvalRestricted(false),",
          "91:         isInvalidatedForHostObjects(false),",
          "92:         fastDOMenabled(false),",
          "93:         directHostTypeId(TypeIds_GlobalObject),",
          "94:         isPerformingNonreentrantWork(false),",
          "95:         isDiagnosticsScriptContext(false),",
          "96:         m_enumerateNonUserFunctionsOnly(false),",
          "97:         recycler(threadContext->EnsureRecycler()),",
          "98:         CurrentThunk(DefaultEntryThunk),",
          "99:         CurrentCrossSiteThunk(CrossSite::DefaultThunk),",
          "100:         DeferredParsingThunk(DefaultDeferredParsingThunk),",
          "101:         DeferredDeserializationThunk(DefaultDeferredDeserializeThunk),",
          "102:         DispatchDefaultInvoke(nullptr),",
          "103:         DispatchProfileInvoke(nullptr),",
          "104:         m_pBuiltinFunctionIdMap(nullptr),",
          "105:         diagnosticArena(nullptr),",
          "106:         hostScriptContext(nullptr),",
          "107:         scriptEngineHaltCallback(nullptr),",
          "108: #if DYNAMIC_INTERPRETER_THUNK",
          "109:         interpreterThunkEmitter(nullptr),",
          "110: #endif",
          "111: #ifdef ASMJS_PLAT",
          "112:         asmJsInterpreterThunkEmitter(nullptr),",
          "113:         asmJsCodeGenerator(nullptr),",
          "114: #endif",
          "115:         generalAllocator(_u(\"SC-General\"), threadContext->GetPageAllocator(), Throw::OutOfMemory),",
          "116: #ifdef ENABLE_BASIC_TELEMETRY",
          "117:         telemetryAllocator(_u(\"SC-Telemetry\"), threadContext->GetPageAllocator(), Throw::OutOfMemory),",
          "118: #endif",
          "119:         dynamicProfileInfoAllocator(_u(\"SC-DynProfileInfo\"), threadContext->GetPageAllocator(), Throw::OutOfMemory),",
          "120: #ifdef SEPARATE_ARENA",
          "121:         sourceCodeAllocator(_u(\"SC-Code\"), threadContext->GetPageAllocator(), Throw::OutOfMemory),",
          "122:         regexAllocator(_u(\"SC-Regex\"), threadContext->GetPageAllocator(), Throw::OutOfMemory),",
          "123: #endif",
          "124: #ifdef NEED_MISC_ALLOCATOR",
          "125:         miscAllocator(_u(\"GC-Misc\"), threadContext->GetPageAllocator(), Throw::OutOfMemory),",
          "126: #endif",
          "127:         inlineCacheAllocator(_u(\"SC-InlineCache\"), threadContext->GetPageAllocator(), Throw::OutOfMemory),",
          "128:         isInstInlineCacheAllocator(_u(\"SC-IsInstInlineCache\"), threadContext->GetPageAllocator(), Throw::OutOfMemory),",
          "129:         forInCacheAllocator(_u(\"SC-ForInCache\"), threadContext->GetPageAllocator(), Throw::OutOfMemory),",
          "130:         hasUsedInlineCache(false),",
          "131:         hasProtoOrStoreFieldInlineCache(false),",
          "132:         hasIsInstInlineCache(false),",
          "133:         registeredPrototypeChainEnsuredToHaveOnlyWritableDataPropertiesScriptContext(nullptr),",
          "134:         firstInterpreterFrameReturnAddress(nullptr),",
          "135:         builtInLibraryFunctions(nullptr),",
          "136:         m_remoteScriptContextAddr(nullptr),",
          "137:         isWeakReferenceDictionaryListCleared(false),",
          "138:         isDebugContextInitialized(false)",
          "139: #if ENABLE_PROFILE_INFO",
          "140:         , referencesSharedDynamicSourceContextInfo(false)",
          "141: #endif",
          "142: #if DBG",
          "143:         , isInitialized(false)",
          "144:         , isCloningGlobal(false)",
          "145:         , bindRef(MiscAllocator())",
          "146: #endif",
          "147: #if ENABLE_TTD",
          "148:         , TTDHostCallbackFunctor()",
          "149:         , ScriptContextLogTag(TTD_INVALID_LOG_PTR_ID)",
          "150:         , TTDWellKnownInfo(nullptr)",
          "151:         , TTDContextInfo(nullptr)",
          "152:         , TTDSnapshotOrInflateInProgress(false)",
          "153:         , TTDRecordOrReplayModeEnabled(false)",
          "154:         , TTDRecordModeEnabled(false)",
          "155:         , TTDReplayModeEnabled(false)",
          "156:         , TTDShouldPerformRecordOrReplayAction(false)",
          "157:         , TTDShouldPerformRecordAction(false)",
          "158:         , TTDShouldPerformReplayAction(false)",
          "159:         , TTDShouldPerformDebuggerAction(false)",
          "160:         , TTDShouldSuppressGetterInvocationForDebuggerEvaluation(false)",
          "161: #endif",
          "162: #ifdef REJIT_STATS",
          "163:         , rejitStatsMap(nullptr)",
          "164: #endif",
          "165: #ifdef ENABLE_BASIC_TELEMETRY",
          "166:         , telemetry(nullptr)",
          "167: #endif",
          "168: #ifdef INLINE_CACHE_STATS",
          "169:         , cacheDataMap(nullptr)",
          "170: #endif",
          "171: #ifdef FIELD_ACCESS_STATS",
          "172:         , fieldAccessStatsByFunctionNumber(nullptr)",
          "173: #endif",
          "174:         , webWorkerId(Js::Constants::NonWebWorkerContextId)",
          "175:         , url(_u(\"\"))",
          "176:         , startupComplete(false)",
          "177:         , isEnumeratingRecyclerObjects(false)",
          "178: #ifdef EDIT_AND_CONTINUE",
          "179:         , activeScriptEditQuery(nullptr)",
          "180: #endif",
          "181: #ifdef ENABLE_SCRIPT_PROFILING",
          "182:         , heapEnum(nullptr)",
          "183: #endif",
          "184: #ifdef RECYCLER_PERF_COUNTERS",
          "185:         , bindReferenceCount(0)",
          "186: #endif",
          "187:         , nextPendingClose(nullptr)",
          "188: #ifdef ENABLE_SCRIPT_PROFILING",
          "189:         , m_fTraceDomCall(FALSE)",
          "190: #endif",
          "191:         , intConstPropsOnGlobalObject(nullptr)",
          "192:         , intConstPropsOnGlobalUserObject(nullptr)",
          "193: #ifdef PROFILE_STRINGS",
          "194:         , stringProfiler(nullptr)",
          "195: #endif",
          "196: #ifdef PROFILE_BAILOUT_RECORD_MEMORY",
          "197:         , codeSize(0)",
          "198:         , bailOutRecordBytes(0)",
          "199:         , bailOutOffsetBytes(0)",
          "200: #endif",
          "201:         , debugContext(nullptr)",
          "202:         , jitFuncRangeCache(nullptr)",
          "203:     {",
          "206:        threadContext->EnsureDebugManager();",
          "210:        BEGIN_NO_EXCEPTION;",
          "212: #ifdef RUNTIME_DATA_COLLECTION",
          "213:         createTime = time(nullptr);",
          "214: #endif",
          "216: #ifdef BGJIT_STATS",
          "217:         interpretedCount = maxFuncInterpret = funcJITCount = bytecodeJITCount = interpretedCallsHighPri = jitCodeUsed = funcJitCodeUsed = loopJITCount = speculativeJitCount = 0;",
          "218: #endif",
          "220: #ifdef PROFILE_TYPES",
          "221:         convertNullToSimpleCount = 0;",
          "222:         convertNullToSimpleDictionaryCount = 0;",
          "223:         convertNullToDictionaryCount = 0;",
          "224:         convertDeferredToDictionaryCount = 0;",
          "225:         convertDeferredToSimpleDictionaryCount = 0;",
          "226:         convertSimpleToDictionaryCount = 0;",
          "227:         convertSimpleToSimpleDictionaryCount = 0;",
          "228:         convertPathToDictionaryCount1 = 0;",
          "229:         convertPathToDictionaryCount2 = 0;",
          "230:         convertPathToDictionaryCount3 = 0;",
          "231:         convertPathToDictionaryCount4 = 0;",
          "232:         convertPathToSimpleDictionaryCount = 0;",
          "233:         convertSimplePathToPathCount = 0;",
          "234:         convertSimpleDictionaryToDictionaryCount = 0;",
          "235:         convertSimpleSharedDictionaryToNonSharedCount = 0;",
          "236:         convertSimpleSharedToNonSharedCount = 0;",
          "237:         simplePathTypeHandlerCount = 0;",
          "238:         pathTypeHandlerCount = 0;",
          "239:         promoteCount = 0;",
          "240:         cacheCount = 0;",
          "241:         branchCount = 0;",
          "242:         maxPathLength = 0;",
          "243:         memset(typeCount, 0, sizeof(typeCount));",
          "244:         memset(instanceCount, 0, sizeof(instanceCount));",
          "245: #endif",
          "247: #ifdef PROFILE_OBJECT_LITERALS",
          "248:         objectLiteralInstanceCount = 0;",
          "249:         objectLiteralPathCount = 0;",
          "250:         memset(objectLiteralCount, 0, sizeof(objectLiteralCount));",
          "251:         objectLiteralSimpleDictionaryCount = 0;",
          "252:         objectLiteralMaxLength = 0;",
          "253:         objectLiteralPromoteCount = 0;",
          "254:         objectLiteralCacheCount = 0;",
          "255:         objectLiteralBranchCount = 0;",
          "256: #endif",
          "257: #if DBG_DUMP",
          "258:         byteCodeDataSize = 0;",
          "259:         byteCodeAuxiliaryDataSize = 0;",
          "260:         byteCodeAuxiliaryContextDataSize = 0;",
          "261:         memset(byteCodeHistogram, 0, sizeof(byteCodeHistogram));",
          "262: #endif",
          "264:         memset(propertyStrings, 0, sizeof(PropertyStringMap*)* 80);",
          "266: #if DBG || defined(RUNTIME_DATA_COLLECTION)",
          "267:         this->allocId = threadContext->GetScriptContextCount();",
          "268: #endif",
          "269: #if DBG",
          "270:         this->hadProfiled = false;",
          "271: #endif",
          "272: #if DBG_DUMP",
          "273:         forinCache = 0;",
          "274:         forinNoCache = 0;",
          "275: #endif",
          "277:         callCount = 0;",
          "279:         threadContext->GetHiResTimer()->Reset();",
          "281: #ifdef PROFILE_EXEC",
          "282:         profiler = nullptr;",
          "283:         isProfilerCreated = false;",
          "284:         disableProfiler = false;",
          "285:         ensureParentInfo = false;",
          "286: #endif",
          "288: #ifdef PROFILE_MEM",
          "289:         profileMemoryDump = true;",
          "290: #endif",
          "292: #ifdef ENABLE_SCRIPT_PROFILING",
          "293:         m_pProfileCallback = nullptr;",
          "294:         m_pProfileCallback2 = nullptr;",
          "295:         m_inProfileCallback = FALSE;",
          "296:         CleanupDocumentContext = nullptr;",
          "297: #endif",
          "300:         numberAllocator.Initialize(this->GetRecycler());",
          "302: #if DEBUG",
          "303:         m_iProfileSession = -1;",
          "304: #endif",
          "305: #ifdef LEAK_REPORT",
          "306:         this->urlRecord = nullptr;",
          "307:         this->isRootTrackerScriptContext = false;",
          "308: #endif",
          "310:         PERF_COUNTER_INC(Basic, ScriptContext);",
          "311:         PERF_COUNTER_INC(Basic, ScriptContextActive);",
          "313:         END_NO_EXCEPTION;",
          "314:     }",
          "316:     void ScriptContext::InitializeAllocations()",
          "317:     {",
          "318:         this->charClassifier = Anew(GeneralAllocator(), CharClassifier, this);",
          "320:         this->valueOfInlineCache = AllocatorNewZ(InlineCacheAllocator, GetInlineCacheAllocator(), InlineCache);",
          "321:         this->toStringInlineCache = AllocatorNewZ(InlineCacheAllocator, GetInlineCacheAllocator(), InlineCache);",
          "323: #ifdef REJIT_STATS",
          "324:         if (PHASE_STATS1(Js::ReJITPhase))",
          "325:         {",
          "326:             rejitReasonCounts = AnewArrayZ(GeneralAllocator(), uint, NumRejitReasons);",
          "327:             bailoutReasonCounts = Anew(GeneralAllocator(), BailoutStatsMap, GeneralAllocator());",
          "328:         }",
          "329: #endif",
          "331: #ifdef ENABLE_BASIC_TELEMETRY",
          "332:         this->telemetry = Anew(this->TelemetryAllocator(), ScriptContextTelemetry, *this);",
          "333: #endif",
          "335: #ifdef PROFILE_STRINGS",
          "336:         if (Js::Configuration::Global.flags.ProfileStrings)",
          "337:         {",
          "338:             stringProfiler = Anew(MiscAllocator(), StringProfiler, threadContext->GetPageAllocator());",
          "339:         }",
          "340: #endif",
          "341:         intConstPropsOnGlobalObject = Anew(GeneralAllocator(), PropIdSetForConstProp, GeneralAllocator());",
          "342:         intConstPropsOnGlobalUserObject = Anew(GeneralAllocator(), PropIdSetForConstProp, GeneralAllocator());",
          "344: #if ENABLE_NATIVE_CODEGEN",
          "345:         m_domFastPathHelperMap = HeapNew(JITDOMFastPathHelperMap, &HeapAllocator::Instance, 17);",
          "346: #endif",
          "348:         this->debugContext = HeapNew(DebugContext, this);",
          "349:     }",
          "351:     void ScriptContext::EnsureClearDebugDocument()",
          "352:     {",
          "353:         if (this->sourceList)",
          "354:         {",
          "355:             this->sourceList->Map([=](uint i, RecyclerWeakReference<Js::Utf8SourceInfo>* sourceInfoWeakRef) {",
          "356:                 Js::Utf8SourceInfo* sourceInfo = sourceInfoWeakRef->Get();",
          "357:                 if (sourceInfo)",
          "358:                 {",
          "359:                     sourceInfo->ClearDebugDocument();",
          "360:                 }",
          "361:             });",
          "362:         }",
          "363:     }",
          "365:     void ScriptContext::ShutdownClearSourceLists()",
          "366:     {",
          "367:         if (this->sourceList)",
          "368:         {",
          "373:             if (this->isClosed)",
          "374:             {",
          "375:                 this->MapFunction([this](Js::FunctionBody* functionBody) {",
          "376:                     Assert(functionBody->GetScriptContext() == this);",
          "377:                     functionBody->CleanupSourceInfo(true);",
          "378:                 });",
          "379:             }",
          "381:             EnsureClearDebugDocument();",
          "384:             this->sourceList.Unroot(this->GetRecycler());",
          "385:         }",
          "387:         if (this->calleeUtf8SourceInfoList)",
          "388:         {",
          "389:             this->calleeUtf8SourceInfoList.Unroot(this->GetRecycler());",
          "390:         }",
          "391:     }",
          "393:     ScriptContext::~ScriptContext()",
          "394:     {",
          "396:         AutoCriticalSection autocs(GetThreadContext()->GetEtwRundownCriticalSection());",
          "398: #if ENABLE_NATIVE_CODEGEN",
          "399:         if (m_domFastPathHelperMap != nullptr)",
          "400:         {",
          "401:             HeapDelete(m_domFastPathHelperMap);",
          "402:         }",
          "403: #endif",
          "406:         ClearHostScriptContext();",
          "408:         if (this->hasProtoOrStoreFieldInlineCache)",
          "409:         {",
          "418:             threadContext->ClearInlineCaches();",
          "420:             ClearInlineCaches();",
          "421:             Assert(!this->hasProtoOrStoreFieldInlineCache);",
          "422:         }",
          "424:         if (this->hasIsInstInlineCache)",
          "425:         {",
          "427:             threadContext->ClearIsInstInlineCaches();",
          "428:             ClearIsInstInlineCaches();",
          "429:             Assert(!this->hasIsInstInlineCache);",
          "430:         }",
          "433:         if (isClosed && !isScriptContextActuallyClosed)",
          "434:         {",
          "435:             threadContext->RemoveFromPendingClose(this);",
          "436:         }",
          "438:         SetIsClosed();",
          "439:         bool closed = Close(true);",
          "443:         numberAllocator.Uninitialize();",
          "445:         ShutdownClearSourceLists();",
          "447:         if (regexStacks)",
          "448:         {",
          "449:             Adelete(RegexAllocator(), regexStacks);",
          "450:             regexStacks = nullptr;",
          "451:         }",
          "453:         if (javascriptLibrary != nullptr)",
          "454:         {",
          "455:             javascriptLibrary->scriptContext = nullptr;",
          "456:             javascriptLibrary = nullptr;",
          "457:             if (closed)",
          "458:             {",
          "463: #if ENABLE_NATIVE_CODEGEN",
          "464:                 Assert(this->IsClosedNativeCodeGenerator());",
          "465: #endif",
          "466:                 if (!GetThreadContext()->IsJSRT())",
          "467:                 {",
          "468:                     this->recycler->RootRelease(globalObject);",
          "469:                 }",
          "470:             }",
          "471:         }",
          "475:         if (this->IsRegistered())",
          "476:         {",
          "477:             threadContext->UnregisterScriptContext(this);",
          "478:         }",
          "480: #if ENABLE_BACKGROUND_PARSING",
          "481:         if (this->backgroundParser != nullptr)",
          "482:         {",
          "483:             BackgroundParser::Delete(this->backgroundParser);",
          "484:             this->backgroundParser = nullptr;",
          "485:         }",
          "486: #endif",
          "488: #if ENABLE_NATIVE_CODEGEN",
          "489:         if (this->nativeCodeGen != nullptr)",
          "490:         {",
          "491:             DeleteNativeCodeGenerator(this->nativeCodeGen);",
          "492:             nativeCodeGen = NULL;",
          "493:         }",
          "494:         if (jitFuncRangeCache != nullptr)",
          "495:         {",
          "496:             HeapDelete(jitFuncRangeCache);",
          "497:             jitFuncRangeCache = nullptr;",
          "498:         }",
          "499: #endif",
          "501: #if DYNAMIC_INTERPRETER_THUNK",
          "502:         if (this->interpreterThunkEmitter != nullptr)",
          "503:         {",
          "504:             HeapDelete(interpreterThunkEmitter);",
          "505:             this->interpreterThunkEmitter = NULL;",
          "506:         }",
          "507: #endif",
          "509: #ifdef ASMJS_PLAT",
          "510:         if (this->asmJsInterpreterThunkEmitter != nullptr)",
          "511:         {",
          "512:             HeapDelete(asmJsInterpreterThunkEmitter);",
          "513:             this->asmJsInterpreterThunkEmitter = nullptr;",
          "514:         }",
          "516:         if (this->asmJsCodeGenerator != nullptr)",
          "517:         {",
          "518:             HeapDelete(asmJsCodeGenerator);",
          "519:             this->asmJsCodeGenerator = NULL;",
          "520:         }",
          "521: #endif",
          "524:         this->weakReferenceDictionaryList.Reset();",
          "526: #if ENABLE_NATIVE_CODEGEN",
          "527:         if (m_remoteScriptContextAddr)",
          "528:         {",
          "529:             Assert(JITManager::GetJITManager()->IsOOPJITEnabled());",
          "530:             if (JITManager::GetJITManager()->CleanupScriptContext(&m_remoteScriptContextAddr) == S_OK)",
          "531:             {",
          "532:                 Assert(m_remoteScriptContextAddr == nullptr);",
          "533:             }",
          "534:             m_remoteScriptContextAddr = nullptr;",
          "535:         }",
          "536: #endif",
          "538:         PERF_COUNTER_DEC(Basic, ScriptContext);",
          "539:     }",
          "541:     void ScriptContext::SetUrl(BSTR bstrUrl)",
          "542:     {",
          "544:         Assert(this->url != nullptr && wcslen(this->url) == 0);",
          "546:         charcount_t length = SysStringLen(bstrUrl) + 1; // Add 1 for the NULL.",
          "548:         char16* urlCopy = AnewArray(this->GeneralAllocator(), char16, length);",
          "549:         js_memcpy_s(urlCopy, (length - 1) * sizeof(char16), bstrUrl, (length - 1) * sizeof(char16));",
          "550:         urlCopy[length - 1] = _u('\\0');",
          "552:         this->url = urlCopy;",
          "553: #ifdef LEAK_REPORT",
          "554:         if (Js::Configuration::Global.flags.IsEnabled(Js::LeakReportFlag))",
          "555:         {",
          "556:             this->urlRecord = LeakReport::LogUrl(urlCopy, this->globalObject);",
          "557:         }",
          "558: #endif",
          "559:     }",
          "561:     uint ScriptContext::GetNextSourceContextId()",
          "562:     {",
          "564:         Assert(this->Cache()->sourceContextInfoMap ||",
          "565:             this->Cache()->dynamicSourceContextInfoMap);",
          "567:         uint nextSourceContextId = 0;",
          "569:         if (this->Cache()->sourceContextInfoMap)",
          "570:         {",
          "571:             nextSourceContextId = this->Cache()->sourceContextInfoMap->Count();",
          "572:         }",
          "574:         if (this->Cache()->dynamicSourceContextInfoMap)",
          "575:         {",
          "576:             nextSourceContextId += this->Cache()->dynamicSourceContextInfoMap->Count();",
          "577:         }",
          "579:         return nextSourceContextId + 1;",
          "580:     }",
          "583:     void ScriptContext::InternalClose()",
          "584:     {",
          "585:         isScriptContextActuallyClosed = true;",
          "587:         PERF_COUNTER_DEC(Basic, ScriptContextActive);",
          "589: #if DBG_DUMP",
          "590:         if (Js::Configuration::Global.flags.TraceWin8Allocations)",
          "591:         {",
          "592:             Output::Print(_u(\"MemoryTrace: ScriptContext Close\\n\"));",
          "593:             Output::Flush();",
          "594:         }",
          "595: #endif",
          "596:         JS_ETW_INTERNAL(EventWriteJSCRIPT_HOST_SCRIPT_CONTEXT_CLOSE(this));",
          "598: #if ENABLE_TTD",
          "599:         if(this->TTDWellKnownInfo != nullptr)",
          "600:         {",
          "601:             TT_HEAP_DELETE(TTD::RuntimeContextInfo, this->TTDWellKnownInfo);",
          "602:             this->TTDWellKnownInfo = nullptr;",
          "603:         }",
          "605:         if(this->TTDContextInfo != nullptr)",
          "606:         {",
          "607:             TT_HEAP_DELETE(TTD::ScriptContextTTD, this->TTDContextInfo);",
          "608:             this->TTDContextInfo = nullptr;",
          "609:         }",
          "610: #endif",
          "612: #if ENABLE_NATIVE_CODEGEN",
          "613:         if (nativeCodeGen != nullptr)",
          "614:         {",
          "615:             Assert(!isInitialized || this->globalObject != nullptr);",
          "616:             CloseNativeCodeGenerator(this->nativeCodeGen);",
          "617:         }",
          "618: #endif",
          "620:         if (this->sourceList)",
          "621:         {",
          "622:             bool hasFunctions = false;",
          "623:             this->sourceList->MapUntil([&hasFunctions](int, RecyclerWeakReference<Utf8SourceInfo>* sourceInfoWeakRef) -> bool",
          "624:             {",
          "625:                 Utf8SourceInfo* sourceInfo = sourceInfoWeakRef->Get();",
          "626:                 if (sourceInfo)",
          "627:                 {",
          "628:                     hasFunctions = sourceInfo->HasFunctions();",
          "629:                 }",
          "631:                 return hasFunctions;",
          "632:             });",
          "634:             if (hasFunctions)",
          "635:             {",
          "639:                 this->MapFunction([this](Js::FunctionBody* functionBody) {",
          "640:                     Assert(functionBody->GetScriptContext() == nullptr || functionBody->GetScriptContext() == this);",
          "641:                     functionBody->Cleanup(/* isScriptContextClosing */ true);",
          "642:                 });",
          "643:             }",
          "644:         }",
          "646:         this->GetThreadContext()->SubSourceSize(this->GetSourceSize());",
          "648: #if DYNAMIC_INTERPRETER_THUNK",
          "649:         if (this->interpreterThunkEmitter != nullptr)",
          "650:         {",
          "651:             this->interpreterThunkEmitter->Close();",
          "652:         }",
          "653: #endif",
          "655: #ifdef ASMJS_PLAT",
          "656:         if (this->asmJsInterpreterThunkEmitter != nullptr)",
          "657:         {",
          "658:             this->asmJsInterpreterThunkEmitter->Close();",
          "659:         }",
          "660: #endif",
          "662: #ifdef ENABLE_SCRIPT_PROFILING",
          "664:         DeRegisterProfileProbe(S_OK, nullptr);",
          "665: #endif",
          "667:         this->EnsureClearDebugDocument();",
          "668:         if (this->debugContext != nullptr)",
          "669:         {",
          "670:             if(this->debugContext->GetProbeContainer())",
          "671:             {",
          "672:                 this->debugContext->GetProbeContainer()->UninstallInlineBreakpointProbe(NULL);",
          "673:                 this->debugContext->GetProbeContainer()->UninstallDebuggerScriptOptionCallback();",
          "674:             }",
          "678:             AutoCriticalSection autoDebugContextCloseCS(&debugContextCloseCS);",
          "679:             DebugContext* tempDebugContext = this->debugContext;",
          "680:             this->debugContext = nullptr;",
          "681:             tempDebugContext->Close();",
          "682:             HeapDelete(tempDebugContext);",
          "683:         }",
          "685:         if (this->diagnosticArena != nullptr)",
          "686:         {",
          "687:             HeapDelete(this->diagnosticArena);",
          "688:             this->diagnosticArena = nullptr;",
          "689:         }",
          "694: #ifdef PROFILE_EXEC",
          "695:         if (Js::Configuration::Global.flags.IsEnabled(Js::ProfileFlag))",
          "696:         {",
          "697:             if (isProfilerCreated)",
          "698:             {",
          "699:                 this->ProfilePrint();",
          "700:             }",
          "702:             if (profiler != nullptr)",
          "703:             {",
          "704:                 profiler->Release();",
          "705:                 profiler = nullptr;",
          "706:             }",
          "707:         }",
          "708: #endif",
          "711: #if ENABLE_PROFILE_INFO",
          "716:         if (referencesSharedDynamicSourceContextInfo)",
          "717:         {",
          "719:             Assert(this->GetDynamicSourceContextInfoMap() != nullptr);",
          "720:             this->GetThreadContext()->ReleaseSourceDynamicProfileManagers(this->GetUrl());",
          "721:         }",
          "722: #endif",
          "724:         RECYCLER_PERF_COUNTER_SUB(BindReference, bindReferenceCount);",
          "726:         if (this->interpreterArena)",
          "727:         {",
          "728:             ReleaseInterpreterArena();",
          "729:             interpreterArena = nullptr;",
          "730:         }",
          "732:         if (this->guestArena)",
          "733:         {",
          "734:             ReleaseGuestArena();",
          "735:             guestArena = nullptr;",
          "736:         }",
          "738:         builtInLibraryFunctions = nullptr;",
          "740:         pActiveScriptDirect = nullptr;",
          "742:         isWeakReferenceDictionaryListCleared = true;",
          "743:         this->weakReferenceDictionaryList.Clear(this->GeneralAllocator());",
          "745:         if (registeredPrototypeChainEnsuredToHaveOnlyWritableDataPropertiesScriptContext != nullptr)",
          "746:         {",
          "748:             ScriptContext ** registeredScriptContext = registeredPrototypeChainEnsuredToHaveOnlyWritableDataPropertiesScriptContext;",
          "749:             ClearPrototypeChainEnsuredToHaveOnlyWritableDataPropertiesCaches();",
          "750:             Assert(registeredPrototypeChainEnsuredToHaveOnlyWritableDataPropertiesScriptContext == nullptr);",
          "751:             threadContext->UnregisterPrototypeChainEnsuredToHaveOnlyWritableDataPropertiesScriptContext(registeredScriptContext);",
          "752:         }",
          "754:         threadContext->ReleaseDebugManager();",
          "758:         if (javascriptLibrary != nullptr)",
          "759:         {",
          "760:             javascriptLibrary->CleanupForClose();",
          "761:             javascriptLibrary->Uninitialize();",
          "763:             this->ClearScriptContextCaches();",
          "764:         }",
          "765:     }",
          "767:     bool ScriptContext::Close(bool inDestructor)",
          "768:     {",
          "769:         if (isScriptContextActuallyClosed)",
          "770:             return false;",
          "773:         {",
          "775:             AutoCriticalSection autocs(GetThreadContext()->GetEtwRundownCriticalSection());",
          "776:             InternalClose();",
          "777:         }",
          "779:         if (!inDestructor && globalObject != nullptr)",
          "780:         {",
          "783: #if ENABLE_NATIVE_CODEGEN",
          "784:             Assert(this->IsClosedNativeCodeGenerator());",
          "785: #endif",
          "786:             if (!GetThreadContext()->IsJSRT())",
          "787:             {",
          "788:                 GetRecycler()->RootRelease(globalObject);",
          "789:             }",
          "790:             globalObject = nullptr;",
          "791:         }",
          "795:         this->threadContext->SetForceOneIdleCollection();",
          "797:         return true;",
          "798:     }",
          "800:     PropertyString* ScriptContext::GetPropertyString2(char16 ch1, char16 ch2)",
          "801:     {",
          "802:         if (ch1 < '0' || ch1 > 'z' || ch2 < '0' || ch2 > 'z')",
          "803:         {",
          "804:             return NULL;",
          "805:         }",
          "806:         const uint i = PropertyStringMap::PStrMapIndex(ch1);",
          "807:         if (propertyStrings[i] == NULL)",
          "808:         {",
          "809:             return NULL;",
          "810:         }",
          "811:         const uint j = PropertyStringMap::PStrMapIndex(ch2);",
          "812:         return propertyStrings[i]->strLen2[j];",
          "813:     }",
          "815:     void ScriptContext::FindPropertyRecord(JavascriptString *pstName, PropertyRecord const ** propertyRecord)",
          "816:     {",
          "817:         threadContext->FindPropertyRecord(pstName, propertyRecord);",
          "818:     }",
          "820:     void ScriptContext::FindPropertyRecord(__in LPCWSTR propertyName, __in int propertyNameLength, PropertyRecord const ** propertyRecord)",
          "821:     {",
          "822:         threadContext->FindPropertyRecord(propertyName, propertyNameLength, propertyRecord);",
          "823:     }",
          "825:     JsUtil::List<const RecyclerWeakReference<Js::PropertyRecord const>*>* ScriptContext::FindPropertyIdNoCase(__in LPCWSTR propertyName, __in int propertyNameLength)",
          "826:     {",
          "827:         return threadContext->FindPropertyIdNoCase(this, propertyName, propertyNameLength);",
          "828:     }",
          "830:     PropertyId ScriptContext::GetOrAddPropertyIdTracked(JsUtil::CharacterBuffer<WCHAR> const& propName)",
          "831:     {",
          "832:         Js::PropertyRecord const * propertyRecord;",
          "833:         threadContext->GetOrAddPropertyId(propName, &propertyRecord);",
          "835:         this->TrackPid(propertyRecord);",
          "837:         return propertyRecord->GetPropertyId();",
          "838:     }",
          "840:     void ScriptContext::GetOrAddPropertyRecord(JsUtil::CharacterBuffer<WCHAR> const& propertyName, PropertyRecord const ** propertyRecord)",
          "841:     {",
          "842:         threadContext->GetOrAddPropertyId(propertyName, propertyRecord);",
          "843:     }",
          "845:     PropertyId ScriptContext::GetOrAddPropertyIdTracked(__in_ecount(propertyNameLength) LPCWSTR propertyName, __in int propertyNameLength)",
          "846:     {",
          "847:         Js::PropertyRecord const * propertyRecord;",
          "848:         threadContext->GetOrAddPropertyId(propertyName, propertyNameLength, &propertyRecord);",
          "849:         if (propertyNameLength == 2)",
          "850:         {",
          "851:             CachePropertyString2(propertyRecord);",
          "852:         }",
          "853:         this->TrackPid(propertyRecord);",
          "855:         return propertyRecord->GetPropertyId();",
          "856:     }",
          "858:     void ScriptContext::GetOrAddPropertyRecord(__in_ecount(propertyNameLength) LPCWSTR propertyName, __in int propertyNameLength, PropertyRecord const ** propertyRecord)",
          "859:     {",
          "860:         threadContext->GetOrAddPropertyId(propertyName, propertyNameLength, propertyRecord);",
          "861:         if (propertyNameLength == 2)",
          "862:         {",
          "863:             CachePropertyString2(*propertyRecord);",
          "864:         }",
          "865:     }",
          "867:     BOOL ScriptContext::IsNumericPropertyId(PropertyId propertyId, uint32* value)",
          "868:     {",
          "869:         BOOL isNumericPropertyId = threadContext->IsNumericPropertyId(propertyId, value);",
          "871: #if DEBUG",
          "872:         PropertyRecord const * name = this->GetPropertyName(propertyId);",
          "874:         if (name != nullptr)",
          "875:         {",
          "877:             if (name->IsSymbol())",
          "878:             {",
          "879:                 return false;",
          "880:             }",
          "882:             uint32 index;",
          "883:             BOOL isIndex = JavascriptArray::GetIndex(name->GetBuffer(), &index);",
          "884:             if (isNumericPropertyId != isIndex)",
          "885:             {",
          "889:                 Assert((size_t)(name->GetLength()) != wcslen(name->GetBuffer()));",
          "890:             }",
          "891:             else if (isNumericPropertyId)",
          "892:             {",
          "893:                 Assert((uint32)*value == index);",
          "894:             }",
          "895:         }",
          "896: #endif",
          "898:         return isNumericPropertyId;",
          "899:     }",
          "901:     void ScriptContext::RegisterWeakReferenceDictionary(JsUtil::IWeakReferenceDictionary* weakReferenceDictionary)",
          "902:     {",
          "903:         this->weakReferenceDictionaryList.Prepend(this->GeneralAllocator(), weakReferenceDictionary);",
          "904:     }",
          "906:     RecyclableObject *ScriptContext::GetMissingPropertyResult()",
          "907:     {",
          "908:         return GetLibrary()->GetUndefined();",
          "909:     }",
          "911:     RecyclableObject *ScriptContext::GetMissingItemResult()",
          "912:     {",
          "913:         return GetLibrary()->GetUndefined();",
          "914:     }",
          "916:     SRCINFO *ScriptContext::AddHostSrcInfo(SRCINFO const *pSrcInfo)",
          "917:     {",
          "918:         Assert(pSrcInfo != nullptr);",
          "920:         return RecyclerNewZ(this->GetRecycler(), SRCINFO, *pSrcInfo);",
          "921:     }",
          "923: #ifdef PROFILE_TYPES",
          "924:     void ScriptContext::ProfileTypes()",
          "925:     {",
          "926:         Output::Print(_u(\"===============================================================================\\n\"));",
          "927:         Output::Print(_u(\"Types Profile %s\\n\"), this->url);",
          "928:         Output::Print(_u(\"-------------------------------------------------------------------------------\\n\"));",
          "929:         Output::Print(_u(\"Dynamic Type Conversions:\\n\"));",
          "930:         Output::Print(_u(\"    Null to Simple                 %8d\\n\"), convertNullToSimpleCount);",
          "931:         Output::Print(_u(\"    Deferred to SimpleMap          %8d\\n\"), convertDeferredToSimpleDictionaryCount);",
          "932:         Output::Print(_u(\"    Simple to Map                  %8d\\n\"), convertSimpleToDictionaryCount);",
          "933:         Output::Print(_u(\"    Simple to SimpleMap            %8d\\n\"), convertSimpleToSimpleDictionaryCount);",
          "934:         Output::Print(_u(\"    Path to SimpleMap (set)        %8d\\n\"), convertPathToDictionaryCount1);",
          "935:         Output::Print(_u(\"    Path to SimpleMap (delete)     %8d\\n\"), convertPathToDictionaryCount2);",
          "936:         Output::Print(_u(\"    Path to SimpleMap (attribute)  %8d\\n\"), convertPathToDictionaryCount3);",
          "937:         Output::Print(_u(\"    Path to SimpleMap              %8d\\n\"), convertPathToSimpleDictionaryCount);",
          "938:         Output::Print(_u(\"    SimplePath to Path             %8d\\n\"), convertSimplePathToPathCount);",
          "939:         Output::Print(_u(\"    Shared SimpleMap to non-shared %8d\\n\"), convertSimpleSharedDictionaryToNonSharedCount);",
          "940:         Output::Print(_u(\"    Deferred to Map                %8d\\n\"), convertDeferredToDictionaryCount);",
          "941:         Output::Print(_u(\"    Path to Map (accessor)         %8d\\n\"), convertPathToDictionaryCount4);",
          "942:         Output::Print(_u(\"    SimpleMap to Map               %8d\\n\"), convertSimpleDictionaryToDictionaryCount);",
          "943:         Output::Print(_u(\"    Path Cache Hits                %8d\\n\"), cacheCount);",
          "944:         Output::Print(_u(\"    Path Branches                  %8d\\n\"), branchCount);",
          "945:         Output::Print(_u(\"    Path Promotions                %8d\\n\"), promoteCount);",
          "946:         Output::Print(_u(\"    Path Length (max)              %8d\\n\"), maxPathLength);",
          "947:         Output::Print(_u(\"    SimplePathTypeHandlers         %8d\\n\"), simplePathTypeHandlerCount);",
          "948:         Output::Print(_u(\"    PathTypeHandlers               %8d\\n\"), pathTypeHandlerCount);",
          "949:         Output::Print(_u(\"\\n\"));",
          "950:         Output::Print(_u(\"Type Statistics:                   %8s   %8s\\n\"), _u(\"Types\"), _u(\"Instances\"));",
          "951:         Output::Print(_u(\"    Undefined                      %8d   %8d\\n\"), typeCount[TypeIds_Undefined], instanceCount[TypeIds_Undefined]);",
          "952:         Output::Print(_u(\"    Null                           %8d   %8d\\n\"), typeCount[TypeIds_Null], instanceCount[TypeIds_Null]);",
          "953:         Output::Print(_u(\"    Boolean                        %8d   %8d\\n\"), typeCount[TypeIds_Boolean], instanceCount[TypeIds_Boolean]);",
          "954:         Output::Print(_u(\"    Integer                        %8d   %8d\\n\"), typeCount[TypeIds_Integer], instanceCount[TypeIds_Integer]);",
          "955:         Output::Print(_u(\"    Number                         %8d   %8d\\n\"), typeCount[TypeIds_Number], instanceCount[TypeIds_Number]);",
          "956:         Output::Print(_u(\"    String                         %8d   %8d\\n\"), typeCount[TypeIds_String], instanceCount[TypeIds_String]);",
          "957:         Output::Print(_u(\"    Object                         %8d   %8d\\n\"), typeCount[TypeIds_Object], instanceCount[TypeIds_Object]);",
          "958:         Output::Print(_u(\"    Function                       %8d   %8d\\n\"), typeCount[TypeIds_Function], instanceCount[TypeIds_Function]);",
          "959:         Output::Print(_u(\"    Array                          %8d   %8d\\n\"), typeCount[TypeIds_Array], instanceCount[TypeIds_Array]);",
          "960:         Output::Print(_u(\"    Date                           %8d   %8d\\n\"), typeCount[TypeIds_Date], instanceCount[TypeIds_Date] + instanceCount[TypeIds_WinRTDate]);",
          "961:         Output::Print(_u(\"    Symbol                         %8d   %8d\\n\"), typeCount[TypeIds_Symbol], instanceCount[TypeIds_Symbol]);",
          "962:         Output::Print(_u(\"    RegEx                          %8d   %8d\\n\"), typeCount[TypeIds_RegEx], instanceCount[TypeIds_RegEx]);",
          "963:         Output::Print(_u(\"    Error                          %8d   %8d\\n\"), typeCount[TypeIds_Error], instanceCount[TypeIds_Error]);",
          "964:         Output::Print(_u(\"    Proxy                          %8d   %8d\\n\"), typeCount[TypeIds_Proxy], instanceCount[TypeIds_Proxy]);",
          "965:         Output::Print(_u(\"    BooleanObject                  %8d   %8d\\n\"), typeCount[TypeIds_BooleanObject], instanceCount[TypeIds_BooleanObject]);",
          "966:         Output::Print(_u(\"    NumberObject                   %8d   %8d\\n\"), typeCount[TypeIds_NumberObject], instanceCount[TypeIds_NumberObject]);",
          "967:         Output::Print(_u(\"    StringObject                   %8d   %8d\\n\"), typeCount[TypeIds_StringObject], instanceCount[TypeIds_StringObject]);",
          "968:         Output::Print(_u(\"    SymbolObject                   %8d   %8d\\n\"), typeCount[TypeIds_SymbolObject], instanceCount[TypeIds_SymbolObject]);",
          "969:         Output::Print(_u(\"    GlobalObject                   %8d   %8d\\n\"), typeCount[TypeIds_GlobalObject], instanceCount[TypeIds_GlobalObject]);",
          "970:         Output::Print(_u(\"    Enumerator                     %8d   %8d\\n\"), typeCount[TypeIds_Enumerator], instanceCount[TypeIds_Enumerator]);",
          "971:         Output::Print(_u(\"    Int8Array                      %8d   %8d\\n\"), typeCount[TypeIds_Int8Array], instanceCount[TypeIds_Int8Array]);",
          "972:         Output::Print(_u(\"    Uint8Array                     %8d   %8d\\n\"), typeCount[TypeIds_Uint8Array], instanceCount[TypeIds_Uint8Array]);",
          "973:         Output::Print(_u(\"    Uint8ClampedArray              %8d   %8d\\n\"), typeCount[TypeIds_Uint8ClampedArray], instanceCount[TypeIds_Uint8ClampedArray]);",
          "974:         Output::Print(_u(\"    Int16Array                     %8d   %8d\\n\"), typeCount[TypeIds_Int16Array], instanceCount[TypeIds_Int16Array]);",
          "975:         Output::Print(_u(\"    Int16Array                     %8d   %8d\\n\"), typeCount[TypeIds_Uint16Array], instanceCount[TypeIds_Uint16Array]);",
          "976:         Output::Print(_u(\"    Int32Array                     %8d   %8d\\n\"), typeCount[TypeIds_Int32Array], instanceCount[TypeIds_Int32Array]);",
          "977:         Output::Print(_u(\"    Uint32Array                    %8d   %8d\\n\"), typeCount[TypeIds_Uint32Array], instanceCount[TypeIds_Uint32Array]);",
          "978:         Output::Print(_u(\"    Float32Array                   %8d   %8d\\n\"), typeCount[TypeIds_Float32Array], instanceCount[TypeIds_Float32Array]);",
          "979:         Output::Print(_u(\"    Float64Array                   %8d   %8d\\n\"), typeCount[TypeIds_Float64Array], instanceCount[TypeIds_Float64Array]);",
          "980:         Output::Print(_u(\"    DataView                       %8d   %8d\\n\"), typeCount[TypeIds_DataView], instanceCount[TypeIds_DataView]);",
          "981:         Output::Print(_u(\"    ModuleRoot                     %8d   %8d\\n\"), typeCount[TypeIds_ModuleRoot], instanceCount[TypeIds_ModuleRoot]);",
          "982:         Output::Print(_u(\"    HostObject                     %8d   %8d\\n\"), typeCount[TypeIds_HostObject], instanceCount[TypeIds_HostObject]);",
          "983:         Output::Print(_u(\"    VariantDate                    %8d   %8d\\n\"), typeCount[TypeIds_VariantDate], instanceCount[TypeIds_VariantDate]);",
          "984:         Output::Print(_u(\"    HostDispatch                   %8d   %8d\\n\"), typeCount[TypeIds_HostDispatch], instanceCount[TypeIds_HostDispatch]);",
          "985:         Output::Print(_u(\"    Arguments                      %8d   %8d\\n\"), typeCount[TypeIds_Arguments], instanceCount[TypeIds_Arguments]);",
          "986:         Output::Print(_u(\"    ActivationObject               %8d   %8d\\n\"), typeCount[TypeIds_ActivationObject], instanceCount[TypeIds_ActivationObject]);",
          "987:         Output::Print(_u(\"    Map                            %8d   %8d\\n\"), typeCount[TypeIds_Map], instanceCount[TypeIds_Map]);",
          "988:         Output::Print(_u(\"    Set                            %8d   %8d\\n\"), typeCount[TypeIds_Set], instanceCount[TypeIds_Set]);",
          "989:         Output::Print(_u(\"    WeakMap                        %8d   %8d\\n\"), typeCount[TypeIds_WeakMap], instanceCount[TypeIds_WeakMap]);",
          "990:         Output::Print(_u(\"    WeakSet                        %8d   %8d\\n\"), typeCount[TypeIds_WeakSet], instanceCount[TypeIds_WeakSet]);",
          "991:         Output::Print(_u(\"    ArrayIterator                  %8d   %8d\\n\"), typeCount[TypeIds_ArrayIterator], instanceCount[TypeIds_ArrayIterator]);",
          "992:         Output::Print(_u(\"    MapIterator                    %8d   %8d\\n\"), typeCount[TypeIds_MapIterator], instanceCount[TypeIds_MapIterator]);",
          "993:         Output::Print(_u(\"    SetIterator                    %8d   %8d\\n\"), typeCount[TypeIds_SetIterator], instanceCount[TypeIds_SetIterator]);",
          "994:         Output::Print(_u(\"    StringIterator                 %8d   %8d\\n\"), typeCount[TypeIds_StringIterator], instanceCount[TypeIds_StringIterator]);",
          "995:         Output::Print(_u(\"    Generator                      %8d   %8d\\n\"), typeCount[TypeIds_Generator], instanceCount[TypeIds_Generator]);",
          "996: #if !DBG",
          "997:         Output::Print(_u(\"    ** Instance statistics only available on debug builds...\\n\"));",
          "998: #endif",
          "999:         Output::Flush();",
          "1000:     }",
          "1001: #endif",
          "1004: #ifdef PROFILE_OBJECT_LITERALS",
          "1005:     void ScriptContext::ProfileObjectLiteral()",
          "1006:     {",
          "1007:         Output::Print(_u(\"===============================================================================\\n\"));",
          "1008:         Output::Print(_u(\"    Object Lit Instances created.. %d\\n\"), objectLiteralInstanceCount);",
          "1009:         Output::Print(_u(\"    Object Lit Path Types......... %d\\n\"), objectLiteralPathCount);",
          "1010:         Output::Print(_u(\"    Object Lit Simple Map......... %d\\n\"), objectLiteralSimpleDictionaryCount);",
          "1011:         Output::Print(_u(\"    Object Lit Max # of properties %d\\n\"), objectLiteralMaxLength);",
          "1012:         Output::Print(_u(\"    Object Lit Promote count...... %d\\n\"), objectLiteralPromoteCount);",
          "1013:         Output::Print(_u(\"    Object Lit Cache Hits......... %d\\n\"), objectLiteralCacheCount);",
          "1014:         Output::Print(_u(\"    Object Lit Branch count....... %d\\n\"), objectLiteralBranchCount);",
          "1016:         for (int i = 0; i < TypePath::MaxPathTypeHandlerLength; i++)",
          "1017:         {",
          "1018:             if (objectLiteralCount[i] != 0)",
          "1019:             {",
          "1020:                 Output::Print(_u(\"    Object Lit properties [ %2d] .. %d\\n\"), i, objectLiteralCount[i]);",
          "1021:             }",
          "1022:         }",
          "1024:         Output::Flush();",
          "1025:     }",
          "1026: #endif",
          "1032: #if ENABLE_REGEX_CONFIG_OPTIONS",
          "1033:     UnifiedRegex::RegexStatsDatabase* ScriptContext::GetRegexStatsDatabase()",
          "1034:     {",
          "1035:         if (regexStatsDatabase == 0)",
          "1036:         {",
          "1037:             ArenaAllocator* allocator = MiscAllocator();",
          "1038:             regexStatsDatabase = Anew(allocator, UnifiedRegex::RegexStatsDatabase, allocator);",
          "1039:         }",
          "1040:         return regexStatsDatabase;",
          "1041:     }",
          "1043:     UnifiedRegex::DebugWriter* ScriptContext::GetRegexDebugWriter()",
          "1044:     {",
          "1045:         if (regexDebugWriter == 0)",
          "1046:         {",
          "1047:             ArenaAllocator* allocator = MiscAllocator();",
          "1048:             regexDebugWriter = Anew(allocator, UnifiedRegex::DebugWriter);",
          "1049:         }",
          "1050:         return regexDebugWriter;",
          "1051:     }",
          "1052: #endif",
          "1054:     void ScriptContext::RedeferFunctionBodies(ActiveFunctionSet *pActiveFuncs, uint inactiveThreshold)",
          "1055:     {",
          "1056:         Assert(!this->IsClosed());",
          "1058:         if (!this->IsScriptContextInNonDebugMode())",
          "1059:         {",
          "1060:             return;",
          "1061:         }",
          "1069:         auto fn = [&](FunctionBody *functionBody) {",
          "1070:             bool exec = functionBody->InterpretedSinceCallCountCollection();",
          "1071:             functionBody->CollectInterpretedCounts();",
          "1072:             functionBody->MapEntryPoints([&](int index, FunctionEntryPointInfo *entryPointInfo) {",
          "1073:                 if (!entryPointInfo->IsCleanedUp() && entryPointInfo->ExecutedSinceCallCountCollection())",
          "1074:                 {",
          "1075:                     exec = true;",
          "1076:                 }",
          "1077:                 entryPointInfo->CollectCallCounts();",
          "1078:             });",
          "1079:             if (exec)",
          "1080:             {",
          "1081:                 functionBody->SetInactiveCount(0);",
          "1082:             }",
          "1083:             else",
          "1084:             {",
          "1085:                 functionBody->IncrInactiveCount(inactiveThreshold);",
          "1086:             }",
          "1088:             if (pActiveFuncs)",
          "1089:             {",
          "1090:                 Assert(this->GetThreadContext()->DoRedeferFunctionBodies());",
          "1091:                 bool doRedefer = functionBody->DoRedeferFunction(inactiveThreshold);",
          "1092:                 if (!doRedefer)",
          "1093:                 {",
          "1094:                     functionBody->UpdateActiveFunctionSet(pActiveFuncs, nullptr);",
          "1095:                 }",
          "1096:             }",
          "1097:         };",
          "1099:         this->MapFunction(fn);",
          "1101:         if (!pActiveFuncs)",
          "1102:         {",
          "1103:             return;",
          "1104:         }",
          "1106:         auto fnRedefer = [&](FunctionBody * functionBody) {",
          "1107:             Assert(pActiveFuncs);",
          "1108:             if (!functionBody->IsActiveFunction(pActiveFuncs))",
          "1109:             {",
          "1110:                 Assert(functionBody->DoRedeferFunction(inactiveThreshold));",
          "1111:                 functionBody->RedeferFunction();",
          "1112:             }",
          "1113:             else",
          "1114:             {",
          "1115:                 functionBody->ResetRedeferralAttributes();",
          "1116:             }",
          "1117:         };",
          "1119:         this->MapFunction(fnRedefer);",
          "1120:     }",
          "1122:     bool ScriptContext::DoUndeferGlobalFunctions() const",
          "1123:     {",
          "1124:         return CONFIG_FLAG(DeferTopLevelTillFirstCall) && !AutoSystemInfo::Data.IsLowMemoryProcess();",
          "1125:     }",
          "1127:     RegexPatternMruMap* ScriptContext::GetDynamicRegexMap() const",
          "1128:     {",
          "1129:         Assert(!isScriptContextActuallyClosed);",
          "1130:         Assert(Cache()->dynamicRegexMap);",
          "1132:         return Cache()->dynamicRegexMap;",
          "1133:     }",
          "1135:     void ScriptContext::SetTrigramAlphabet(UnifiedRegex::TrigramAlphabet * trigramAlphabet)",
          "1136:     {",
          "1137:         this->trigramAlphabet = trigramAlphabet;",
          "1138:     }",
          "1140:     UnifiedRegex::RegexStacks *ScriptContext::RegexStacks()",
          "1141:     {",
          "1142:         UnifiedRegex::RegexStacks * stacks = regexStacks;",
          "1143:         if (stacks)",
          "1144:         {",
          "1145:             return stacks;",
          "1146:         }",
          "1147:         return AllocRegexStacks();",
          "1148:     }",
          "1150:     UnifiedRegex::RegexStacks * ScriptContext::AllocRegexStacks()",
          "1151:     {",
          "1152:         Assert(this->regexStacks == nullptr);",
          "1153:         UnifiedRegex::RegexStacks * stacks = Anew(RegexAllocator(), UnifiedRegex::RegexStacks, threadContext->GetPageAllocator());",
          "1154:         this->regexStacks = stacks;",
          "1155:         return stacks;",
          "1156:     }",
          "1158:     UnifiedRegex::RegexStacks *ScriptContext::SaveRegexStacks()",
          "1159:     {",
          "1160:         Assert(regexStacks);",
          "1162:         const auto saved = regexStacks;",
          "1163:         regexStacks = nullptr;",
          "1164:         return saved;",
          "1165:     }",
          "1167:     void ScriptContext::RestoreRegexStacks(UnifiedRegex::RegexStacks *const stacks)",
          "1168:     {",
          "1169:         Assert(stacks);",
          "1170:         Assert(stacks != regexStacks);",
          "1172:         if (regexStacks)",
          "1173:         {",
          "1174:             Adelete(RegexAllocator(), regexStacks);",
          "1175:         }",
          "1176:         regexStacks = stacks;",
          "1177:     }",
          "1179:     Js::TempArenaAllocatorObject* ScriptContext::GetTemporaryAllocator(LPCWSTR name)",
          "1180:     {",
          "1181:         return this->threadContext->GetTemporaryAllocator(name);",
          "1182:     }",
          "1184:     void ScriptContext::ReleaseTemporaryAllocator(Js::TempArenaAllocatorObject* tempAllocator)",
          "1185:     {",
          "1186:         AssertMsg(tempAllocator != nullptr, \"tempAllocator should not be null\");",
          "1188:         this->threadContext->ReleaseTemporaryAllocator(tempAllocator);",
          "1189:     }",
          "1191:     Js::TempGuestArenaAllocatorObject* ScriptContext::GetTemporaryGuestAllocator(LPCWSTR name)",
          "1192:     {",
          "1193:         return this->threadContext->GetTemporaryGuestAllocator(name);",
          "1194:     }",
          "1196:     void ScriptContext::ReleaseTemporaryGuestAllocator(Js::TempGuestArenaAllocatorObject* tempGuestAllocator)",
          "1197:     {",
          "1198:         AssertMsg(tempGuestAllocator != nullptr, \"tempAllocator should not be null\");",
          "1200:         this->threadContext->ReleaseTemporaryGuestAllocator(tempGuestAllocator);",
          "1201:     }",
          "1203:     void ScriptContext::InitializeCache()",
          "1204:     {",
          "1206: #if ENABLE_PROFILE_INFO",
          "1207: #if DBG_DUMP || defined(DYNAMIC_PROFILE_STORAGE) || defined(RUNTIME_DATA_COLLECTION)",
          "1208:         if (DynamicProfileInfo::NeedProfileInfoList())",
          "1209:         {",
          "1210:             this->Cache()->profileInfoList = RecyclerNew(this->GetRecycler(), DynamicProfileInfoList);",
          "1211:         }",
          "1212: #endif",
          "1213: #endif",
          "1215:         this->Cache()->dynamicRegexMap =",
          "1216:             RegexPatternMruMap::New(",
          "1217:                 recycler,",
          "1218:                 REGEX_CONFIG_FLAG(DynamicRegexMruListSize) <= 0 ? 16 : REGEX_CONFIG_FLAG(DynamicRegexMruListSize));",
          "1220:         SourceContextInfo* sourceContextInfo = RecyclerNewStructZ(this->GetRecycler(), SourceContextInfo);",
          "1221:         sourceContextInfo->dwHostSourceContext = Js::Constants::NoHostSourceContext;",
          "1222:         sourceContextInfo->isHostDynamicDocument = false;",
          "1223:         sourceContextInfo->sourceContextId = Js::Constants::NoSourceContext;",
          "1224:         this->Cache()->noContextSourceContextInfo = sourceContextInfo;",
          "1226:         SRCINFO* srcInfo = RecyclerNewStructZ(this->GetRecycler(), SRCINFO);",
          "1227:         srcInfo->sourceContextInfo = this->Cache()->noContextSourceContextInfo;",
          "1228:         srcInfo->moduleID = kmodGlobal;",
          "1229:         this->Cache()->noContextGlobalSourceInfo = srcInfo;",
          "1230:     }",
          "1232:     void ScriptContext::InitializePreGlobal()",
          "1233:     {",
          "1234:         this->guestArena = this->GetRecycler()->CreateGuestArena(_u(\"Guest\"), Throw::OutOfMemory);",
          "1236: #if ENABLE_BACKGROUND_PARSING",
          "1237:         if (PHASE_ON1(Js::ParallelParsePhase))",
          "1238:         {",
          "1239:             this->backgroundParser = BackgroundParser::New(this);",
          "1240:         }",
          "1241: #endif",
          "1243: #if ENABLE_NATIVE_CODEGEN",
          "1245:         this->nativeCodeGen = NewNativeCodeGenerator(this);",
          "1246:         this->jitFuncRangeCache = HeapNew(JITPageAddrToFuncRangeCache);",
          "1247: #endif",
          "1249: #ifdef PROFILE_EXEC",
          "1250:         this->CreateProfiler();",
          "1251: #endif",
          "1253:         this->operationStack = Anew(GeneralAllocator(), JsUtil::Stack<Var>, GeneralAllocator());",
          "1255:         Tick::InitType();",
          "1256:     }",
          "1258:     void ScriptContext::Initialize()",
          "1259:     {",
          "1260:         SmartFPUControl defaultControl;",
          "1262:         InitializePreGlobal();",
          "1264:         InitializeGlobalObject();",
          "1266:         InitializePostGlobal();",
          "1267:     }",
          "1269:     void ScriptContext::InitializePostGlobal()",
          "1270:     {",
          "1271:         this->GetDebugContext()->Initialize();",
          "1273:         this->GetDebugContext()->GetProbeContainer()->Initialize(this);",
          "1275:         isDebugContextInitialized = true;",
          "1277: #if defined(_M_ARM32_OR_ARM64)",
          "1279:         MemoryBarrier();",
          "1280: #endif",
          "1282:         AssertMsg(this->CurrentThunk == DefaultEntryThunk, \"Creating non default thunk while initializing\");",
          "1283:         AssertMsg(this->DeferredParsingThunk == DefaultDeferredParsingThunk, \"Creating non default thunk while initializing\");",
          "1284:         AssertMsg(this->DeferredDeserializationThunk == DefaultDeferredDeserializeThunk, \"Creating non default thunk while initializing\");",
          "1286: #ifdef FIELD_ACCESS_STATS",
          "1287:         this->fieldAccessStatsByFunctionNumber = RecyclerNew(this->recycler, FieldAccessStatsByFunctionNumberMap, recycler);",
          "1288:         BindReference(this->fieldAccessStatsByFunctionNumber);",
          "1289: #endif",
          "1291:         if (!sourceList)",
          "1292:         {",
          "1293:             AutoCriticalSection critSec(threadContext->GetEtwRundownCriticalSection());",
          "1294:             sourceList.Root(RecyclerNew(this->GetRecycler(), SourceList, this->GetRecycler()), this->GetRecycler());",
          "1295:         }",
          "1297: #if DYNAMIC_INTERPRETER_THUNK",
          "1298:         interpreterThunkEmitter = HeapNew(InterpreterThunkEmitter, this, SourceCodeAllocator(), this->GetThreadContext()->GetThunkPageAllocators());",
          "1299: #endif",
          "1301: #ifdef ASMJS_PLAT",
          "1302:         asmJsInterpreterThunkEmitter = HeapNew(InterpreterThunkEmitter, this, SourceCodeAllocator(), this->GetThreadContext()->GetThunkPageAllocators(),",
          "1303:             true);",
          "1304: #endif",
          "1306:         JS_ETW(EtwTrace::LogScriptContextLoadEvent(this));",
          "1307:         JS_ETW_INTERNAL(EventWriteJSCRIPT_HOST_SCRIPT_CONTEXT_START(this));",
          "1309: #ifdef PROFILE_EXEC",
          "1310:         if (profiler != nullptr)",
          "1311:         {",
          "1312:             this->threadContext->GetRecycler()->SetProfiler(profiler->GetProfiler(), profiler->GetBackgroundRecyclerProfiler());",
          "1313:         }",
          "1314: #endif",
          "1316: #if DBG",
          "1317:         this->javascriptLibrary->DumpLibraryByteCode();",
          "1319:         isInitialized = TRUE;",
          "1320: #endif",
          "1321:     }",
          "1324: #ifdef ASMJS_PLAT",
          "1325:     AsmJsCodeGenerator* ScriptContext::InitAsmJsCodeGenerator()",
          "1326:     {",
          "1327:         if( !asmJsCodeGenerator )",
          "1328:         {",
          "1329:             asmJsCodeGenerator = HeapNew( AsmJsCodeGenerator, this );",
          "1330:         }",
          "1331:         return asmJsCodeGenerator;",
          "1332:     }",
          "1333: #endif",
          "1334:     void ScriptContext::MarkForClose()",
          "1335:     {",
          "1336:         if (IsClosed())",
          "1337:         {",
          "1338:             return;",
          "1339:         }",
          "1341:         SaveStartupProfileAndRelease(true);",
          "1342:         SetIsClosed();",
          "1344: #ifdef LEAK_REPORT",
          "1345:         if (this->isRootTrackerScriptContext)",
          "1346:         {",
          "1347:             this->GetThreadContext()->ClearRootTrackerScriptContext(this);",
          "1348:         }",
          "1349: #endif",
          "1351:         if (!threadContext->IsInScript())",
          "1352:         {",
          "1353:             Close(FALSE);",
          "1354:         }",
          "1355:         else",
          "1356:         {",
          "1357:             threadContext->AddToPendingScriptContextCloseList(this);",
          "1358:         }",
          "1359:     }",
          "1361:     void ScriptContext::SetIsClosed()",
          "1362:     {",
          "1363:         if (!this->isClosed)",
          "1364:         {",
          "1365:             this->isClosed = true;",
          "1367:             if (this->javascriptLibrary)",
          "1368:             {",
          "1369:                 JS_ETW(EtwTrace::LogSourceUnloadEvents(this));",
          "1371: #if ENABLE_PROFILE_INFO",
          "1372: #if DBG_DUMP",
          "1373:                 DynamicProfileInfo::DumpScriptContext(this);",
          "1374: #endif",
          "1375: #ifdef RUNTIME_DATA_COLLECTION",
          "1376:                 DynamicProfileInfo::DumpScriptContextToFile(this);",
          "1377: #endif",
          "1378: #endif",
          "1380: #if ENABLE_PROFILE_INFO",
          "1381: #ifdef DYNAMIC_PROFILE_STORAGE",
          "1382:                 HRESULT hr = S_OK;",
          "1383:                 BEGIN_TRANSLATE_OOM_TO_HRESULT_NESTED",
          "1384:                 {",
          "1385:                     DynamicProfileInfo::Save(this);",
          "1386:                 }",
          "1387:                 END_TRANSLATE_OOM_TO_HRESULT(hr);",
          "1389:                 if (this->Cache()->sourceContextInfoMap)",
          "1390:                 {",
          "1391:                     this->Cache()->sourceContextInfoMap->Map([&](DWORD_PTR dwHostSourceContext, SourceContextInfo * sourceContextInfo)",
          "1392:                     {",
          "1393:                         if (sourceContextInfo->sourceDynamicProfileManager)",
          "1394:                         {",
          "1395:                             sourceContextInfo->sourceDynamicProfileManager->ClearSavingData();",
          "1396:                         }",
          "1397:                     });",
          "1398:                 }",
          "1399: #endif",
          "1401: #if DBG_DUMP || defined(DYNAMIC_PROFILE_STORAGE) || defined(RUNTIME_DATA_COLLECTION)",
          "1402:                 this->ClearDynamicProfileList();",
          "1403: #endif",
          "1404: #endif",
          "1405:             }",
          "1407: #if ENABLE_NATIVE_CODEGEN",
          "1408:             if (m_remoteScriptContextAddr)",
          "1409:             {",
          "1410:                 JITManager::GetJITManager()->CloseScriptContext(m_remoteScriptContextAddr);",
          "1411:             }",
          "1412: #endif",
          "1413:             this->PrintStats();",
          "1414:         }",
          "1415:     }",
          "1417:     void ScriptContext::InitializeGlobalObject()",
          "1418:     {",
          "1419:         GlobalObject * localGlobalObject = GlobalObject::New(this);",
          "1420:         GetRecycler()->RootAddRef(localGlobalObject);",
          "1423:         globalObject = localGlobalObject;",
          "1424:         globalObject->Initialize(this);",
          "1426:         this->GetThreadContext()->RegisterScriptContext(this);",
          "1427:     }",
          "1429:     ArenaAllocator* ScriptContext::AllocatorForDiagnostics()",
          "1430:     {",
          "1431:         if (this->diagnosticArena == nullptr)",
          "1432:         {",
          "1433:             this->diagnosticArena = HeapNew(ArenaAllocator, _u(\"Diagnostic\"), this->GetThreadContext()->GetDebugManager()->GetDiagnosticPageAllocator(), Throw::OutOfMemory);",
          "1434:         }",
          "1435:         Assert(this->diagnosticArena != nullptr);",
          "1436:         return this->diagnosticArena;",
          "1437:     }",
          "1439:     void ScriptContext::PushObject(Var object)",
          "1440:     {",
          "1441:         operationStack->Push(object);",
          "1442:     }",
          "1444:     Var ScriptContext::PopObject()",
          "1445:     {",
          "1446:         return operationStack->Pop();",
          "1447:     }",
          "1449:     BOOL ScriptContext::CheckObject(Var object)",
          "1450:     {",
          "1451:         return operationStack->Contains(object);",
          "1452:     }",
          "1454:     void ScriptContext::SetHostScriptContext(HostScriptContext *  hostScriptContext)",
          "1455:     {",
          "1456:         Assert(this->hostScriptContext == nullptr);",
          "1457:         this->hostScriptContext = hostScriptContext;",
          "1458: #ifdef PROFILE_EXEC",
          "1459:         this->ensureParentInfo = true;",
          "1460: #endif",
          "1461:     }",
          "1467:     void ScriptContext::SetScriptEngineHaltCallback(HaltCallback* scriptEngine)",
          "1468:     {",
          "1469:         Assert(this->scriptEngineHaltCallback == NULL);",
          "1470:         Assert(scriptEngine != NULL);",
          "1471:         this->scriptEngineHaltCallback = scriptEngine;",
          "1472:     }",
          "1474:     void ScriptContext::ClearHostScriptContext()",
          "1475:     {",
          "1476:         if (this->hostScriptContext != nullptr)",
          "1477:         {",
          "1478:             this->hostScriptContext->Delete();",
          "1479: #ifdef PROFILE_EXEC",
          "1480:             this->ensureParentInfo = false;",
          "1481: #endif",
          "1482:         }",
          "1483:     }",
          "1485:     IActiveScriptProfilerHeapEnum* ScriptContext::GetHeapEnum()",
          "1486:     {",
          "1487:         Assert(this->GetThreadContext());",
          "1488:         return this->GetThreadContext()->GetHeapEnum();",
          "1489:     }",
          "1491:     void ScriptContext::SetHeapEnum(IActiveScriptProfilerHeapEnum* newHeapEnum)",
          "1492:     {",
          "1493:         Assert(this->GetThreadContext());",
          "1494:         this->GetThreadContext()->SetHeapEnum(newHeapEnum);",
          "1495:     }",
          "1497:     void ScriptContext::ClearHeapEnum()",
          "1498:     {",
          "1499:         Assert(this->GetThreadContext());",
          "1500:         this->GetThreadContext()->ClearHeapEnum();",
          "1501:     }",
          "1503:     BOOL ScriptContext::VerifyAlive(BOOL isJSFunction, ScriptContext* requestScriptContext)",
          "1504:     {",
          "1505:         if (isClosed)",
          "1506:         {",
          "1507:             if (!requestScriptContext)",
          "1508:             {",
          "1509:                 requestScriptContext = this;",
          "1510:             }",
          "1512: #if ENABLE_PROFILE_INFO",
          "1513:             if (!GetThreadContext()->RecordImplicitException())",
          "1514:             {",
          "1515:                 return FALSE;",
          "1516:             }",
          "1517: #endif",
          "1518:             if (isJSFunction)",
          "1519:             {",
          "1520:                 Js::JavascriptError::MapAndThrowError(requestScriptContext, JSERR_CantExecute);",
          "1521:             }",
          "1522:             else",
          "1523:             {",
          "1524:                 Js::JavascriptError::MapAndThrowError(requestScriptContext, E_ACCESSDENIED);",
          "1525:             }",
          "1526:         }",
          "1527:         return TRUE;",
          "1528:     }",
          "1530:     void ScriptContext::VerifyAliveWithHostContext(BOOL isJSFunction, HostScriptContext* requestHostScriptContext)",
          "1531:     {",
          "1532:         if (requestHostScriptContext)",
          "1533:         {",
          "1534:             VerifyAlive(isJSFunction, requestHostScriptContext->GetScriptContext());",
          "1535:         }",
          "1536:         else",
          "1537:         {",
          "1538:             Assert(GetThreadContext()->IsJSRT() || !GetHostScriptContext()->HasCaller());",
          "1539:             VerifyAlive(isJSFunction, NULL);",
          "1540:         }",
          "1541:     }",
          "1544:     PropertyRecord const * ScriptContext::GetPropertyName(PropertyId propertyId)",
          "1545:     {",
          "1546:         return threadContext->GetPropertyName(propertyId);",
          "1547:     }",
          "1549:     PropertyRecord const * ScriptContext::GetPropertyNameLocked(PropertyId propertyId)",
          "1550:     {",
          "1551:         return threadContext->GetPropertyNameLocked(propertyId);",
          "1552:     }",
          "1554:     void ScriptContext::InitPropertyStringMap(int i)",
          "1555:     {",
          "1556:         propertyStrings[i] = AnewStruct(GeneralAllocator(), PropertyStringMap);",
          "1557:         memset(propertyStrings[i]->strLen2, 0, sizeof(PropertyString*)* 80);",
          "1558:     }",
          "1560:     void ScriptContext::TrackPid(const PropertyRecord* propertyRecord)",
          "1561:     {",
          "1562:         if (IsBuiltInPropertyId(propertyRecord->GetPropertyId()) || propertyRecord->IsBound())",
          "1563:         {",
          "1564:             return;",
          "1565:         }",
          "1567:         if (-1 != this->GetLibrary()->EnsureReferencedPropertyRecordList()->AddNew(propertyRecord))",
          "1568:         {",
          "1569:             RECYCLER_PERF_COUNTER_INC(PropertyRecordBindReference);",
          "1570:         }",
          "1571:     }",
          "1572:     void ScriptContext::TrackPid(PropertyId propertyId)",
          "1573:     {",
          "1574:         if (IsBuiltInPropertyId(propertyId))",
          "1575:         {",
          "1576:             return;",
          "1577:         }",
          "1578:         const PropertyRecord* propertyRecord = this->GetPropertyName(propertyId);",
          "1579:         Assert(propertyRecord != nullptr);",
          "1580:         this->TrackPid(propertyRecord);",
          "1581:     }",
          "1583:     bool ScriptContext::IsTrackedPropertyId(Js::PropertyId propertyId)",
          "1584:     {",
          "1585:         if (IsBuiltInPropertyId(propertyId))",
          "1586:         {",
          "1587:             return true;",
          "1588:         }",
          "1589:         const PropertyRecord* propertyRecord = this->GetPropertyName(propertyId);",
          "1590:         Assert(propertyRecord != nullptr);",
          "1591:         if (propertyRecord->IsBound())",
          "1592:         {",
          "1593:             return true;",
          "1594:         }",
          "1595:         JavascriptLibrary::ReferencedPropertyRecordHashSet * referencedPropertyRecords",
          "1596:             = this->GetLibrary()->GetReferencedPropertyRecordList();",
          "1597:         return referencedPropertyRecords && referencedPropertyRecords->Contains(propertyRecord);",
          "1598:     }",
          "1599:     PropertyString* ScriptContext::AddPropertyString2(const Js::PropertyRecord* propString)",
          "1600:     {",
          "1601:         const char16* buf = propString->GetBuffer();",
          "1602:         const uint i = PropertyStringMap::PStrMapIndex(buf[0]);",
          "1603:         if (propertyStrings[i] == NULL)",
          "1604:         {",
          "1605:             InitPropertyStringMap(i);",
          "1606:         }",
          "1607:         const uint j = PropertyStringMap::PStrMapIndex(buf[1]);",
          "1608:         if (propertyStrings[i]->strLen2[j] == NULL && !isClosed)",
          "1609:         {",
          "1610:             propertyStrings[i]->strLen2[j] = GetLibrary()->CreatePropertyString(propString, this->GeneralAllocator());",
          "1611:             this->TrackPid(propString);",
          "1612:         }",
          "1613:         return propertyStrings[i]->strLen2[j];",
          "1614:     }",
          "1616:     PropertyString* ScriptContext::CachePropertyString2(const PropertyRecord* propString)",
          "1617:     {",
          "1618:         Assert(propString->GetLength() == 2);",
          "1619:         const char16* propertyName = propString->GetBuffer();",
          "1620:         if ((propertyName[0] <= 'z') && (propertyName[1] <= 'z') && (propertyName[0] >= '0') && (propertyName[1] >= '0') && ((propertyName[0] > '9') || (propertyName[1] > '9')))",
          "1621:         {",
          "1622:             return AddPropertyString2(propString);",
          "1623:         }",
          "1624:         return NULL;",
          "1625:     }",
          "1627:     PropertyString* ScriptContext::TryGetPropertyString(PropertyId propertyId)",
          "1628:     {",
          "1629:         PropertyStringCacheMap* propertyStringMap = this->GetLibrary()->EnsurePropertyStringMap();",
          "1631:         RecyclerWeakReference<PropertyString>* stringReference;",
          "1632:         if (propertyStringMap->TryGetValue(propertyId, &stringReference))",
          "1633:         {",
          "1634:             PropertyString *string = stringReference->Get();",
          "1635:             if (string != nullptr)",
          "1636:             {",
          "1637:                 return string;",
          "1638:             }",
          "1639:         }",
          "1641:         return nullptr;",
          "1642:     }",
          "1644:     PropertyString* ScriptContext::GetPropertyString(PropertyId propertyId)",
          "1645:     {",
          "1646:         PropertyString *string = TryGetPropertyString(propertyId);",
          "1647:         if (string != nullptr)",
          "1648:         {",
          "1649:             return string;",
          "1650:         }",
          "1652:         PropertyStringCacheMap* propertyStringMap = this->GetLibrary()->EnsurePropertyStringMap();",
          "1654:         const Js::PropertyRecord* propertyName = this->GetPropertyName(propertyId);",
          "1655:         string = this->GetLibrary()->CreatePropertyString(propertyName);",
          "1656:         propertyStringMap->Item(propertyId, recycler->CreateWeakReferenceHandle(string));",
          "1658:         return string;",
          "1659:     }",
          "1661:     void ScriptContext::InvalidatePropertyStringCache(PropertyId propertyId, Type* type)",
          "1662:     {",
          "1663:         Assert(!isFinalized);",
          "1664:         PropertyStringCacheMap* propertyStringMap = this->javascriptLibrary->GetPropertyStringMap();",
          "1665:         if (propertyStringMap != nullptr)",
          "1666:         {",
          "1667:             PropertyString *string = nullptr;",
          "1668:             RecyclerWeakReference<PropertyString>* stringReference;",
          "1669:             if (propertyStringMap->TryGetValue(propertyId, &stringReference))",
          "1670:             {",
          "1671:                 string = stringReference->Get();",
          "1672:             }",
          "1673:             if (string)",
          "1674:             {",
          "1675:                 PropertyCache const* cache = string->GetPropertyCache();",
          "1676:                 if (cache->type == type)",
          "1677:                 {",
          "1678:                     string->ClearPropertyCache();",
          "1679:                 }",
          "1680:             }",
          "1681:         }",
          "1682:     }",
          "1684:     void ScriptContext::CleanupWeakReferenceDictionaries()",
          "1685:     {",
          "1686:         if (!isWeakReferenceDictionaryListCleared)",
          "1687:         {",
          "1688:             SListBase<JsUtil::IWeakReferenceDictionary*>::Iterator iter(&this->weakReferenceDictionaryList);",
          "1690:             while (iter.Next())",
          "1691:             {",
          "1692:                 JsUtil::IWeakReferenceDictionary* weakReferenceDictionary = iter.Data();",
          "1694:                 weakReferenceDictionary->Cleanup();",
          "1695:             }",
          "1696:         }",
          "1697:     }",
          "1699:     JavascriptString* ScriptContext::GetIntegerString(Var aValue)",
          "1700:     {",
          "1701:         return this->GetIntegerString(TaggedInt::ToInt32(aValue));",
          "1702:     }",
          "1704:     JavascriptString* ScriptContext::GetIntegerString(uint value)",
          "1705:     {",
          "1706:         if (value <= INT_MAX)",
          "1707:         {",
          "1708:             return this->GetIntegerString((int)value);",
          "1709:         }",
          "1710:         return TaggedInt::ToString(value, this);",
          "1711:     }",
          "1713:     JavascriptString* ScriptContext::GetIntegerString(int value)",
          "1714:     {",
          "1716:         if (0 <= value && value <= 9)",
          "1717:         {",
          "1718:             return GetLibrary()->GetCharStringCache().GetStringForCharA('0' + static_cast<char>(value));",
          "1719:         }",
          "1721:         JavascriptString *string;",
          "1723:         if (!this->integerStringMap.TryGetValue(value, &string))",
          "1724:         {",
          "1728:             if (this->integerStringMap.Count() > 1024)",
          "1729:             {",
          "1731:                 string = TaggedInt::ToString(value, this);",
          "1732:             }",
          "1733:             else",
          "1734:             {",
          "1735:                 char16 stringBuffer[20];",
          "1737:                 TaggedInt::ToBuffer(value, stringBuffer, _countof(stringBuffer));",
          "1738:                 string = JavascriptString::NewCopySzFromArena(stringBuffer, this, this->GeneralAllocator());",
          "1739:                 this->integerStringMap.AddNew(value, string);",
          "1740:             }",
          "1741:         }",
          "1743:         return string;",
          "1744:     }",
          "1746:     void ScriptContext::CheckEvalRestriction()",
          "1747:     {",
          "1748:         HRESULT hr = S_OK;",
          "1749:         Var domError = nullptr;",
          "1750:         HostScriptContext* hostScriptContext = this->GetHostScriptContext();",
          "1752:         BEGIN_LEAVE_SCRIPT(this)",
          "1753:         {",
          "1754:             if (!FAILED(hr = hostScriptContext->CheckEvalRestriction()))",
          "1755:             {",
          "1756:                 return;",
          "1757:             }",
          "1759:             hr = hostScriptContext->HostExceptionFromHRESULT(hr, &domError);",
          "1760:         }",
          "1761:         END_LEAVE_SCRIPT(this);",
          "1763:         if (FAILED(hr))",
          "1764:         {",
          "1765:             Js::JavascriptError::MapAndThrowError(this, hr);",
          "1766:         }",
          "1768:         if (domError != nullptr)",
          "1769:         {",
          "1770:             JavascriptExceptionOperators::Throw(domError, this);",
          "1771:         }",
          "1773:         AssertMsg(false, \"We should have thrown by now.\");",
          "1774:         Js::JavascriptError::MapAndThrowError(this, E_FAIL);",
          "1775:     }",
          "1777:     ParseNode* ScriptContext::ParseScript(Parser* parser,",
          "1778:         const byte* script,",
          "1779:         size_t cb,",
          "1780:         SRCINFO const * pSrcInfo,",
          "1781:         CompileScriptException * pse,",
          "1782:         Utf8SourceInfo** ppSourceInfo,",
          "1783:         const char16 *rootDisplayName,",
          "1784:         LoadScriptFlag loadScriptFlag,",
          "1785:         uint* sourceIndex,",
          "1786:         Js::Var scriptSource)",
          "1787:     {",
          "1788:         if (pSrcInfo == nullptr)",
          "1789:         {",
          "1790:             pSrcInfo = this->Cache()->noContextGlobalSourceInfo;",
          "1791:         }",
          "1793:         LPUTF8 utf8Script = nullptr;",
          "1794:         size_t length = cb;",
          "1795:         size_t cbNeeded = 0;",
          "1797:         bool isLibraryCode = ((loadScriptFlag & LoadScriptFlag_LibraryCode) == LoadScriptFlag_LibraryCode);",
          "1799:         if ((loadScriptFlag & LoadScriptFlag_Utf8Source) != LoadScriptFlag_Utf8Source)",
          "1800:         {",
          "1802:             length = cb / sizeof(char16);",
          "1803:             if (!IsValidCharCount(length))",
          "1804:             {",
          "1805:                 Js::Throw::OutOfMemory();",
          "1806:             }",
          "1807:             Assert(length < MAXLONG);",
          "1814:             size_t cbUtf8Buffer = AllocSizeMath::Mul(AllocSizeMath::Add(length, 1), 3);",
          "1816:             utf8Script = RecyclerNewArrayLeafTrace(this->GetRecycler(), utf8char_t, cbUtf8Buffer);",
          "1818:             cbNeeded = utf8::EncodeIntoAndNullTerminate(utf8Script, (const char16*)script, static_cast<charcount_t>(length));",
          "1820: #if DBG_DUMP && defined(PROFILE_MEM)",
          "1821:             if(Js::Configuration::Global.flags.TraceMemory.IsEnabled(Js::ParsePhase) && Configuration::Global.flags.Verbose)",
          "1822:             {",
          "1823:                 Output::Print(_u(\"Loading script.\\n\")",
          "1824:                     _u(\"  Unicode (in bytes)    %u\\n\")",
          "1825:                     _u(\"  UTF-8 size (in bytes) %u\\n\")",
          "1826:                     _u(\"  Expected savings      %d\\n\"), length * sizeof(char16), cbNeeded, length * sizeof(char16) - cbNeeded);",
          "1827:             }",
          "1828: #endif",
          "1831:             Assert(cbNeeded + 1 <= cbUtf8Buffer);",
          "1833:                 cbNeeded, pSrcInfo, isLibraryCode);",
          "1834:         }",
          "1835:         else",
          "1836:         {",
          "1838:             if(*ppSourceInfo == nullptr)",
          "1839:             {",
          "1840: #ifndef NTBUILD",
          "1841:                 if (loadScriptFlag & LoadScriptFlag_ExternalArrayBuffer)",
          "1842:                 {",
          "1844:                         script, (int)length, cb, pSrcInfo, isLibraryCode,",
          "1845:                         scriptSource);",
          "1846:                 }",
          "1847:                 else",
          "1848: #endif",
          "1849:                 {",
          "1853:                         (int)length, cb, pSrcInfo, isLibraryCode);",
          "1854:                 }",
          "1855:             }",
          "1856:         }",
          "1860:         HRESULT hr;",
          "1862:         SourceContextInfo * sourceContextInfo = pSrcInfo->sourceContextInfo;",
          "1867:         ULONG grfscr = fscrGlobalCode | ((loadScriptFlag & LoadScriptFlag_Expression) == LoadScriptFlag_Expression ? fscrReturnExpression : 0);",
          "1868:         if(((loadScriptFlag & LoadScriptFlag_disableDeferredParse) != LoadScriptFlag_disableDeferredParse) &&",
          "1869:             (length > Parser::GetDeferralThreshold(sourceContextInfo->IsSourceProfileLoaded())))",
          "1870:         {",
          "1871:             grfscr |= fscrDeferFncParse;",
          "1872:         }",
          "1874:         if((loadScriptFlag & LoadScriptFlag_disableAsmJs) == LoadScriptFlag_disableAsmJs)",
          "1875:         {",
          "1876:             grfscr |= fscrNoAsmJs;",
          "1877:         }",
          "1879:         if(PHASE_FORCE1(Js::EvalCompilePhase))",
          "1880:         {",
          "1882:             grfscr |= (fscrEval | fscrEvalCode);",
          "1883:         }",
          "1885:         if((loadScriptFlag & LoadScriptFlag_isByteCodeBufferForLibrary) == LoadScriptFlag_isByteCodeBufferForLibrary)",
          "1886:         {",
          "1887:             grfscr |= fscrNoPreJit;",
          "1888:         }",
          "1890:         if(((loadScriptFlag & LoadScriptFlag_Module) == LoadScriptFlag_Module) &&",
          "1891:             GetConfig()->IsES6ModuleEnabled())",
          "1892:         {",
          "1893:             grfscr |= fscrIsModuleCode;",
          "1894:         }",
          "1896:         if (isLibraryCode)",
          "1897:         {",
          "1898:             grfscr |= fscrIsLibraryCode;",
          "1899:         }",
          "1901:         ParseNodePtr parseTree;",
          "1902:         if((loadScriptFlag & LoadScriptFlag_Utf8Source) == LoadScriptFlag_Utf8Source)",
          "1903:         {",
          "1904:             hr = parser->ParseUtf8Source(&parseTree, script, cb, grfscr, pse,",
          "1905:                 &sourceContextInfo->nextLocalFunctionId, sourceContextInfo);",
          "1906:         }",
          "1907:         else",
          "1908:         {",
          "1909:             hr = parser->ParseCesu8Source(&parseTree, utf8Script, cbNeeded, grfscr,",
          "1910:                 pse, &sourceContextInfo->nextLocalFunctionId, sourceContextInfo);",
          "1911:         }",
          "1913:         if(FAILED(hr) || parseTree == nullptr)",
          "1914:         {",
          "1915:             return nullptr;",
          "1916:         }",
          "1918:         (*ppSourceInfo)->SetParseFlags(grfscr);",
          "1921:         if ((loadScriptFlag & LoadScriptFlag_Utf8Source) != LoadScriptFlag_Utf8Source)",
          "1922:         {",
          "1924:         }",
          "1925:         else",
          "1926:         {",
          "1928:             (*ppSourceInfo)->SetCchLength(parser->GetSourceIchLim());",
          "1930:         }",
          "1932:         return parseTree;",
          "1933:     }",
          "1935:     JavascriptFunction* ScriptContext::LoadScript(const byte* script, size_t cb,",
          "1936:         SRCINFO const * pSrcInfo, CompileScriptException * pse, Utf8SourceInfo** ppSourceInfo,",
          "1937:         const char16 *rootDisplayName, LoadScriptFlag loadScriptFlag, Js::Var scriptSource)",
          "1938:     {",
          "1939:         Assert(!this->threadContext->IsScriptActive());",
          "1940:         Assert(pse != nullptr);",
          "1941:         try",
          "1942:         {",
          "1943:             AUTO_NESTED_HANDLED_EXCEPTION_TYPE((ExceptionType)(ExceptionType_OutOfMemory | ExceptionType_StackOverflow));",
          "1944:             Js::AutoDynamicCodeReference dynamicFunctionReference(this);",
          "1945:             Parser parser(this);",
          "1946:             uint sourceIndex;",
          "1947:             JavascriptFunction * pFunction = nullptr;",
          "1949:             ParseNodePtr parseTree = ParseScript(&parser, script, cb, pSrcInfo,",
          "1950:                 pse, ppSourceInfo, rootDisplayName, loadScriptFlag,",
          "1951:                 &sourceIndex, scriptSource);",
          "1953:             if (parseTree != nullptr)",
          "1954:             {",
          "1955:                 pFunction = GenerateRootFunction(parseTree, sourceIndex, &parser, (*ppSourceInfo)->GetParseFlags(), pse, rootDisplayName);",
          "1956:             }",
          "1958:             if (pse->ei.scode == JSERR_AsmJsCompileError)",
          "1959:             {",
          "1960:                 Assert((loadScriptFlag & LoadScriptFlag_disableAsmJs) != LoadScriptFlag_disableAsmJs);",
          "1962:                 pse->Clear();",
          "1964:                 loadScriptFlag = (LoadScriptFlag)(loadScriptFlag | LoadScriptFlag_disableAsmJs);",
          "1965:                 return LoadScript(script, cb, pSrcInfo, pse, ppSourceInfo,",
          "1966:                     rootDisplayName, loadScriptFlag, scriptSource);",
          "1967:             }",
          "1969: #ifdef ENABLE_SCRIPT_PROFILING",
          "1970:             if (pFunction != nullptr && this->IsProfiling())",
          "1971:             {",
          "1972:                 RegisterScript(pFunction->GetFunctionProxy());",
          "1973:             }",
          "1974: #else",
          "1975:             Assert(!this->IsProfiling());",
          "1976: #endif",
          "1977:             return pFunction;",
          "1978:         }",
          "1979:         catch (Js::OutOfMemoryException)",
          "1980:         {",
          "1981:             pse->ProcessError(nullptr, E_OUTOFMEMORY, nullptr);",
          "1982:             return nullptr;",
          "1983:         }",
          "1984:         catch (Js::StackOverflowException)",
          "1985:         {",
          "1986:             pse->ProcessError(nullptr, VBSERR_OutOfStack, nullptr);",
          "1987:             return nullptr;",
          "1988:         }",
          "1989:     }",
          "1991:     JavascriptFunction* ScriptContext::GenerateRootFunction(ParseNodePtr parseTree, uint sourceIndex, Parser* parser, uint32 grfscr, CompileScriptException * pse, const char16 *rootDisplayName)",
          "1992:     {",
          "1993:         HRESULT hr;",
          "1996:         LPCUTF8 source = this->GetSource(sourceIndex)->GetSource(_u(\"ScriptContext::GenerateRootFunction\"));",
          "1997:         Assert(source != nullptr); // Source should not have been reclaimed by now",
          "2000:         ParseableFunctionInfo* body = NULL;",
          "2001:         hr = GenerateByteCode(parseTree, grfscr, this, &body, sourceIndex, false, parser, pse);",
          "2003:         this->GetSource(sourceIndex)->SetByteCodeGenerationFlags(grfscr);",
          "2004:         if(FAILED(hr))",
          "2005:         {",
          "2006:             return nullptr;",
          "2007:         }",
          "2009:         body->SetDisplayName(rootDisplayName);",
          "2010:         body->SetIsTopLevel(true);",
          "2012:         JavascriptFunction* rootFunction = javascriptLibrary->CreateScriptFunction(body);",
          "2013:         return rootFunction;",
          "2014:     }",
          "2016:     BOOL ScriptContext::ReserveStaticTypeIds(__in int first, __in int last)",
          "2017:     {",
          "2018:         return threadContext->ReserveStaticTypeIds(first, last);",
          "2019:     }",
          "2021:     TypeId ScriptContext::ReserveTypeIds(int count)",
          "2022:     {",
          "2023:         return threadContext->ReserveTypeIds(count);",
          "2024:     }",
          "2026:     TypeId ScriptContext::CreateTypeId()",
          "2027:     {",
          "2028:         return threadContext->CreateTypeId();",
          "2029:     }",
          "2031:     void ScriptContext::OnScriptStart(bool isRoot, bool isScript)",
          "2032:     {",
          "2033:         const bool isForcedEnter = this->GetDebugContext() != nullptr ? this->GetDebugContext()->GetProbeContainer()->isForcedToEnterScriptStart : false;",
          "2034:         if (this->scriptStartEventHandler != nullptr && ((isRoot && threadContext->GetCallRootLevel() == 1) || isForcedEnter))",
          "2035:         {",
          "2036:             if (this->GetDebugContext() != nullptr)",
          "2037:             {",
          "2038:                 this->GetDebugContext()->GetProbeContainer()->isForcedToEnterScriptStart = false;",
          "2039:             }",
          "2041:             this->scriptStartEventHandler(this);",
          "2042:         }",
          "2044: #if ENABLE_NATIVE_CODEGEN",
          "2046:         if (isScript)",
          "2047:         {",
          "2048:             NativeCodeGenEnterScriptStart(this->GetNativeCodeGenerator());",
          "2049:         }",
          "2050: #endif",
          "2051:     }",
          "2053:     void ScriptContext::OnScriptEnd(bool isRoot, bool isForcedEnd)",
          "2054:     {",
          "2055:         if ((isRoot && threadContext->GetCallRootLevel() == 1) || isForcedEnd)",
          "2056:         {",
          "2057:             if (this->scriptEndEventHandler != nullptr)",
          "2058:             {",
          "2059:                 this->scriptEndEventHandler(this);",
          "2060:             }",
          "2061:         }",
          "2062:     }",
          "2064: #ifdef FAULT_INJECTION",
          "2065:     void ScriptContext::DisposeScriptContextByFaultInjection() {",
          "2066:         if (this->disposeScriptByFaultInjectionEventHandler != nullptr)",
          "2067:         {",
          "2068:             this->disposeScriptByFaultInjectionEventHandler(this);",
          "2069:         }",
          "2070:     }",
          "2071: #endif",
          "2073:     template <bool stackProbe, bool leaveForHost>",
          "2074:     bool ScriptContext::LeaveScriptStart(void * frameAddress)",
          "2075:     {",
          "2076:         ThreadContext * threadContext = this->threadContext;",
          "2077:         if (!threadContext->IsScriptActive())",
          "2078:         {",
          "2080:             AssertMsg(FALSE, \"Leaving ScriptStart while script is not active.\");",
          "2081:             return false;",
          "2082:         }",
          "2085:         if (stackProbe)",
          "2086:         {",
          "2087:             threadContext->ProbeStack(Js::Constants::MinStackCallout, this);",
          "2088:         }",
          "2089:         else",
          "2090:         {",
          "2091:             AssertMsg(ExceptionCheck::HasStackProbe(), \"missing stack probe\");",
          "2092:         }",
          "2094:         threadContext->LeaveScriptStart<leaveForHost>(frameAddress);",
          "2095:         return true;",
          "2096:     }",
          "2098:     template <bool leaveForHost>",
          "2099:     void ScriptContext::LeaveScriptEnd(void * frameAddress)",
          "2100:     {",
          "2101:         this->threadContext->LeaveScriptEnd<leaveForHost>(frameAddress);",
          "2102:     }",
          "2105:     template bool ScriptContext::LeaveScriptStart<true, true>(void * frameAddress);",
          "2106:     template bool ScriptContext::LeaveScriptStart<true, false>(void * frameAddress);",
          "2107:     template bool ScriptContext::LeaveScriptStart<false, true>(void * frameAddress);",
          "2108:     template void ScriptContext::LeaveScriptEnd<true>(void * frameAddress);",
          "2109:     template void ScriptContext::LeaveScriptEnd<false>(void * frameAddress);",
          "2111:     bool ScriptContext::EnsureInterpreterArena(ArenaAllocator **ppAlloc)",
          "2112:     {",
          "2113:         bool fNew = false;",
          "2114:         if (this->interpreterArena == nullptr)",
          "2115:         {",
          "2116:             this->interpreterArena = this->GetRecycler()->CreateGuestArena(_u(\"Interpreter\"), Throw::OutOfMemory);",
          "2117:             fNew = true;",
          "2118:         }",
          "2120:         return fNew;",
          "2121:     }",
          "2123:     void ScriptContext::ReleaseInterpreterArena()",
          "2124:     {",
          "2125:         AssertMsg(this->interpreterArena, \"No interpreter arena to release\");",
          "2126:         if (this->interpreterArena)",
          "2127:         {",
          "2128:             this->GetRecycler()->DeleteGuestArena(this->interpreterArena);",
          "2129:             this->interpreterArena = nullptr;",
          "2130:         }",
          "2131:     }",
          "2134:     void ScriptContext::ReleaseGuestArena()",
          "2135:     {",
          "2136:         AssertMsg(this->guestArena, \"No guest arena to release\");",
          "2137:         if (this->guestArena)",
          "2138:         {",
          "2139:             this->GetRecycler()->DeleteGuestArena(this->guestArena);",
          "2140:             this->guestArena = nullptr;",
          "2141:         }",
          "2142:     }",
          "2144:     void ScriptContext::SetScriptStartEventHandler(ScriptContext::EventHandler eventHandler)",
          "2145:     {",
          "2146:         AssertMsg(this->scriptStartEventHandler == nullptr, \"Do not support multi-cast yet\");",
          "2147:         this->scriptStartEventHandler = eventHandler;",
          "2148:     }",
          "2149:     void ScriptContext::SetScriptEndEventHandler(ScriptContext::EventHandler eventHandler)",
          "2150:     {",
          "2151:         AssertMsg(this->scriptEndEventHandler == nullptr, \"Do not support multi-cast yet\");",
          "2152:         this->scriptEndEventHandler = eventHandler;",
          "2153:     }",
          "2155: #ifdef FAULT_INJECTION",
          "2156:     void ScriptContext::SetDisposeDisposeByFaultInjectionEventHandler(ScriptContext::EventHandler eventHandler)",
          "2157:     {",
          "2158:         AssertMsg(this->disposeScriptByFaultInjectionEventHandler == nullptr, \"Do not support multi-cast yet\");",
          "2159:         this->disposeScriptByFaultInjectionEventHandler = eventHandler;",
          "2160:     }",
          "2161: #endif",
          "2163:     bool ScriptContext::SaveSourceCopy(Utf8SourceInfo* const sourceInfo, int cchLength, bool isCesu8, uint * index)",
          "2164:     {",
          "2165:         HRESULT hr = S_OK;",
          "2166:         BEGIN_TRANSLATE_OOM_TO_HRESULT",
          "2167:         {",
          "2169:         }",
          "2170:         END_TRANSLATE_OOM_TO_HRESULT(hr);",
          "2171:         return hr == S_OK;",
          "2172:     }",
          "2174:     uint ScriptContext::SaveSourceCopy(Utf8SourceInfo* sourceInfo, int cchLength, bool isCesu8)",
          "2175:     {",
          "2176:         Utf8SourceInfo* newSource = Utf8SourceInfo::Clone(this, sourceInfo);",
          "2178:         return SaveSourceNoCopy(newSource, cchLength, isCesu8);",
          "2179:     }",
          "2182:     uint ScriptContext::SaveSourceNoCopy(Utf8SourceInfo* sourceInfo, int cchLength, bool isCesu8)",
          "2183:     {",
          "2184:         Assert(sourceInfo->GetScriptContext() == this);",
          "2186:         if (this->IsScriptContextInDebugMode() && !sourceInfo->GetIsLibraryCode() && !sourceInfo->IsInDebugMode())",
          "2187:         {",
          "2188:             sourceInfo->SetInDebugMode(true);",
          "2189:         }",
          "2191:         RecyclerWeakReference<Utf8SourceInfo>* sourceWeakRef = this->GetRecycler()->CreateWeakReferenceHandle<Utf8SourceInfo>(sourceInfo);",
          "2192:         sourceInfo->SetIsCesu8(isCesu8);",
          "2193:         {",
          "2196:             AutoCriticalSection autocs(GetThreadContext()->GetEtwRundownCriticalSection());",
          "2197:             return sourceList->SetAtFirstFreeSpot(sourceWeakRef);",
          "2198:         }",
          "2199:     }",
          "2201:     void ScriptContext::CloneSources(ScriptContext* sourceContext)",
          "2202:     {",
          "2203:         sourceContext->sourceList->Map([=](int index, RecyclerWeakReference<Utf8SourceInfo>* sourceInfo)",
          "2204:         {",
          "2205:             Utf8SourceInfo* info = sourceInfo->Get();",
          "2206:             if (info)",
          "2207:             {",
          "2208:                 CloneSource(info);",
          "2209:             }",
          "2210:         });",
          "2211:     }",
          "2213:     uint ScriptContext::CloneSource(Utf8SourceInfo* info)",
          "2214:     {",
          "2215:         return this->SaveSourceCopy(info, info->GetCchLength(), info->GetIsCesu8());",
          "2216:     }",
          "2218:     Utf8SourceInfo* ScriptContext::GetSource(uint index)",
          "2219:     {",
          "2220:         Assert(this->sourceList->IsItemValid(index)); // This assert should be a subset of info != null- if info was null, in the last collect, we'd have invalidated the item",
          "2221:         Utf8SourceInfo* info = this->sourceList->Item(index)->Get();",
          "2222:         Assert(info != nullptr); // Should still be alive if this method is being called",
          "2223:         return info;",
          "2224:     }",
          "2226:     bool ScriptContext::IsItemValidInSourceList(int index)",
          "2227:     {",
          "2228:         return (index < this->sourceList->Count()) && this->sourceList->IsItemValid(index);",
          "2229:     }",
          "2231:     void ScriptContext::RecordException(JavascriptExceptionObject * exceptionObject, bool propagateToDebugger)",
          "2232:     {",
          "2233:         Assert(this->threadContext->GetRecordedException() == nullptr || GetThreadContext()->HasUnhandledException());",
          "2234:         this->threadContext->SetRecordedException(exceptionObject, propagateToDebugger);",
          "2235: #if DBG && ENABLE_DEBUG_STACK_BACK_TRACE",
          "2236:         exceptionObject->FillStackBackTrace();",
          "2237: #endif",
          "2238:     }",
          "2240:     void ScriptContext::RethrowRecordedException(JavascriptExceptionObject::HostWrapperCreateFuncType hostWrapperCreateFunc)",
          "2241:     {",
          "2242:         bool considerPassingToDebugger = false;",
          "2243:         JavascriptExceptionObject * exceptionObject = this->GetAndClearRecordedException(&considerPassingToDebugger);",
          "2244:         if (hostWrapperCreateFunc)",
          "2245:         {",
          "2246:             exceptionObject->SetHostWrapperCreateFunc(exceptionObject->GetScriptContext() != this ? hostWrapperCreateFunc : nullptr);",
          "2247:         }",
          "2248:         JavascriptExceptionOperators::RethrowExceptionObject(exceptionObject, this, considerPassingToDebugger);",
          "2249:     }",
          "2251:     Js::JavascriptExceptionObject * ScriptContext::GetAndClearRecordedException(bool *considerPassingToDebugger)",
          "2252:     {",
          "2253:         JavascriptExceptionObject * exceptionObject = this->threadContext->GetRecordedException();",
          "2254:         Assert(exceptionObject != nullptr);",
          "2255:         if (considerPassingToDebugger)",
          "2256:         {",
          "2258:         }",
          "2259:         exceptionObject = exceptionObject->CloneIfStaticExceptionObject(this);",
          "2260:         this->threadContext->SetRecordedException(nullptr);",
          "2261:         return exceptionObject;",
          "2262:     }",
          "2264:     bool ScriptContext::IsInEvalMap(FastEvalMapString const& key, BOOL isIndirect, ScriptFunction **ppFuncScript)",
          "2265:     {",
          "2266:         EvalCacheDictionary *dict = isIndirect ? this->Cache()->indirectEvalCacheDictionary : this->Cache()->evalCacheDictionary;",
          "2267:         if (dict == nullptr)",
          "2268:         {",
          "2269:             return false;",
          "2270:         }",
          "2271: #ifdef PROFILE_EVALMAP",
          "2272:         if (Configuration::Global.flags.ProfileEvalMap)",
          "2273:         {",
          "2274:             charcount_t len = key.str.GetLength();",
          "2275:             if (dict->TryGetValue(key, ppFuncScript))",
          "2276:             {",
          "2277:                 Output::Print(_u(\"EvalMap cache hit:\\t source size = %d\\n\"), len);",
          "2278:             }",
          "2279:             else",
          "2280:             {",
          "2281:                 Output::Print(_u(\"EvalMap cache miss:\\t source size = %d\\n\"), len);",
          "2282:             }",
          "2283:         }",
          "2284: #endif",
          "2287:         bool success = dict->TryGetValue(key, ppFuncScript);",
          "2289:         if (success)",
          "2290:         {",
          "2291:             dict->NotifyAdd(key);",
          "2292: #ifdef VERBOSE_EVAL_MAP",
          "2293: #if DBG",
          "2294:             dict->DumpKeepAlives();",
          "2295: #endif",
          "2296: #endif",
          "2297:         }",
          "2299:         return success;",
          "2300:     }",
          "2302:     void ScriptContext::AddToEvalMap(FastEvalMapString const& key, BOOL isIndirect, ScriptFunction *pFuncScript)",
          "2303:     {",
          "2304:         EvalCacheDictionary *dict = isIndirect ? this->Cache()->indirectEvalCacheDictionary : this->Cache()->evalCacheDictionary;",
          "2305:         if (dict == nullptr)",
          "2306:         {",
          "2307:             EvalCacheTopLevelDictionary* evalTopDictionary = RecyclerNew(this->recycler, EvalCacheTopLevelDictionary, this->recycler);",
          "2308:             dict = RecyclerNew(this->recycler, EvalCacheDictionary, evalTopDictionary, recycler);",
          "2309:             if (isIndirect)",
          "2310:             {",
          "2311:                 this->Cache()->indirectEvalCacheDictionary = dict;",
          "2312:             }",
          "2313:             else",
          "2314:             {",
          "2315:                 this->Cache()->evalCacheDictionary = dict;",
          "2316:             }",
          "2317:         }",
          "2319:         dict->Add(key, pFuncScript);",
          "2320:     }",
          "2322:     bool ScriptContext::IsInNewFunctionMap(EvalMapString const& key, FunctionInfo **ppFuncInfo)",
          "2323:     {",
          "2324:         if (this->Cache()->newFunctionCache == nullptr)",
          "2325:         {",
          "2326:             return false;",
          "2327:         }",
          "2330:         bool success = this->Cache()->newFunctionCache->TryGetValue(key, ppFuncInfo);",
          "2331:         if (success)",
          "2332:         {",
          "2333:             this->Cache()->newFunctionCache->NotifyAdd(key);",
          "2334: #ifdef VERBOSE_EVAL_MAP",
          "2335: #if DBG",
          "2336:             this->Cache()->newFunctionCache->DumpKeepAlives();",
          "2337: #endif",
          "2338: #endif",
          "2339:         }",
          "2341:         return success;",
          "2342:     }",
          "2344:     void ScriptContext::AddToNewFunctionMap(EvalMapString const& key, FunctionInfo *pFuncInfo)",
          "2345:     {",
          "2346:         if (this->Cache()->newFunctionCache == nullptr)",
          "2347:         {",
          "2348:             this->Cache()->newFunctionCache = RecyclerNew(this->recycler, NewFunctionCache, this->recycler);",
          "2349:         }",
          "2350:         this->Cache()->newFunctionCache->Add(key, pFuncInfo);",
          "2351:     }",
          "2354:     void ScriptContext::EnsureSourceContextInfoMap()",
          "2355:     {",
          "2356:         if (this->Cache()->sourceContextInfoMap == nullptr)",
          "2357:         {",
          "2358:             this->Cache()->sourceContextInfoMap = RecyclerNew(this->GetRecycler(), SourceContextInfoMap, this->GetRecycler());",
          "2359:         }",
          "2360:     }",
          "2362:     void ScriptContext::EnsureDynamicSourceContextInfoMap()",
          "2363:     {",
          "2364:         if (this->Cache()->dynamicSourceContextInfoMap == nullptr)",
          "2365:         {",
          "2366:             this->Cache()->dynamicSourceContextInfoMap = RecyclerNew(this->GetRecycler(), DynamicSourceContextInfoMap, this->GetRecycler());",
          "2367:         }",
          "2368:     }",
          "2370:     SourceContextInfo* ScriptContext::GetSourceContextInfo(uint hash)",
          "2371:     {",
          "2372:         SourceContextInfo * sourceContextInfo;",
          "2373:         if (this->Cache()->dynamicSourceContextInfoMap && this->Cache()->dynamicSourceContextInfoMap->TryGetValue(hash, &sourceContextInfo))",
          "2374:         {",
          "2375:             return sourceContextInfo;",
          "2376:         }",
          "2377:         return nullptr;",
          "2378:     }",
          "2380:     SourceContextInfo* ScriptContext::CreateSourceContextInfo(uint hash, DWORD_PTR hostSourceContext)",
          "2381:     {",
          "2382:         EnsureDynamicSourceContextInfoMap();",
          "2383:         if (this->GetSourceContextInfo(hash) != nullptr)",
          "2384:         {",
          "2385:             return this->Cache()->noContextSourceContextInfo;",
          "2386:         }",
          "2388:         if (this->Cache()->dynamicSourceContextInfoMap->Count() > INMEMORY_CACHE_MAX_PROFILE_MANAGER)",
          "2389:         {",
          "2390:             OUTPUT_TRACE(Js::DynamicProfilePhase, _u(\"Max of dynamic script profile info reached.\\n\"));",
          "2391:             return this->Cache()->noContextSourceContextInfo;",
          "2392:         }",
          "2395:         SourceContextInfo * sourceContextInfo = RecyclerNewStructZ(this->GetRecycler(), SourceContextInfo);",
          "2396:         sourceContextInfo->sourceContextId = this->GetNextSourceContextId();",
          "2397:         sourceContextInfo->dwHostSourceContext = hostSourceContext;",
          "2398:         sourceContextInfo->isHostDynamicDocument = true;",
          "2399:         sourceContextInfo->hash = hash;",
          "2400: #if ENABLE_PROFILE_INFO",
          "2401:         sourceContextInfo->sourceDynamicProfileManager = this->threadContext->GetSourceDynamicProfileManager(this->GetUrl(), hash, &referencesSharedDynamicSourceContextInfo);",
          "2402: #endif",
          "2405:         if (hostSourceContext == Js::Constants::NoHostSourceContext)",
          "2406:         {",
          "2407:             this->Cache()->dynamicSourceContextInfoMap->Add(hash, sourceContextInfo);",
          "2408:         }",
          "2409:         return sourceContextInfo;",
          "2410:     }",
          "2415:     SourceContextInfo * ScriptContext::CreateSourceContextInfo(DWORD_PTR sourceContext, char16 const * url, size_t len,",
          "2416:         IActiveScriptDataCache* profileDataCache, char16 const * sourceMapUrl /*= NULL*/, size_t sourceMapUrlLen /*= 0*/)",
          "2417:     {",
          "2419:         AutoCriticalSection autocs(GetThreadContext()->GetEtwRundownCriticalSection());",
          "2421:         EnsureSourceContextInfoMap();",
          "2422:         Assert(this->GetSourceContextInfo(sourceContext, profileDataCache) == nullptr);",
          "2423:         SourceContextInfo * sourceContextInfo = RecyclerNewStructZ(this->GetRecycler(), SourceContextInfo);",
          "2424:         sourceContextInfo->sourceContextId = this->GetNextSourceContextId();",
          "2425:         sourceContextInfo->dwHostSourceContext = sourceContext;",
          "2426:         sourceContextInfo->isHostDynamicDocument = false;",
          "2427: #if ENABLE_PROFILE_INFO",
          "2428:         sourceContextInfo->sourceDynamicProfileManager = nullptr;",
          "2429: #endif",
          "2431:         if (url != nullptr)",
          "2432:         {",
          "2433:             sourceContextInfo->url = CopyString(url, len, this->SourceCodeAllocator());",
          "2434:             JS_ETW(EtwTrace::LogSourceModuleLoadEvent(this, sourceContext, url));",
          "2435:         }",
          "2436:         if (sourceMapUrl != nullptr && sourceMapUrlLen != 0)",
          "2437:         {",
          "2438:             sourceContextInfo->sourceMapUrl = CopyString(sourceMapUrl, sourceMapUrlLen, this->SourceCodeAllocator());",
          "2439:         }",
          "2441: #if ENABLE_PROFILE_INFO",
          "2442:         if (!this->startupComplete)",
          "2443:         {",
          "2444:             sourceContextInfo->sourceDynamicProfileManager = SourceDynamicProfileManager::LoadFromDynamicProfileStorage(sourceContextInfo, this, profileDataCache);",
          "2445:             Assert(sourceContextInfo->sourceDynamicProfileManager != NULL);",
          "2446:         }",
          "2448:         this->Cache()->sourceContextInfoMap->Add(sourceContext, sourceContextInfo);",
          "2449: #endif",
          "2450:         return sourceContextInfo;",
          "2451:     }",
          "2454:     const char16* ScriptContext::CopyString(const char16* str, size_t charCount, ArenaAllocator* alloc)",
          "2455:     {",
          "2456:         size_t length = charCount + 1; // Add 1 for the NULL.",
          "2457:         char16* copy = AnewArray(alloc, char16, length);",
          "2458:         js_wmemcpy_s(copy, length, str, charCount);",
          "2459:         copy[length - 1] = _u('\\0');",
          "2460:         return copy;",
          "2461:     }",
          "2463:     SourceContextInfo *  ScriptContext::GetSourceContextInfo(DWORD_PTR sourceContext, IActiveScriptDataCache* profileDataCache)",
          "2464:     {",
          "2465:         if (sourceContext == Js::Constants::NoHostSourceContext)",
          "2466:         {",
          "2467:             return this->Cache()->noContextSourceContextInfo;",
          "2468:         }",
          "2471:         EnsureSourceContextInfoMap();",
          "2472:         SourceContextInfo * sourceContextInfo;",
          "2473:         if (this->Cache()->sourceContextInfoMap->TryGetValue(sourceContext, &sourceContextInfo))",
          "2474:         {",
          "2475: #if ENABLE_PROFILE_INFO",
          "2476:             if (profileDataCache &&",
          "2477:                 sourceContextInfo->sourceDynamicProfileManager != nullptr &&",
          "2478:                 !sourceContextInfo->sourceDynamicProfileManager->IsProfileLoadedFromWinInet() &&",
          "2479:                 !this->startupComplete)",
          "2480:             {",
          "2481:                 bool profileLoaded = sourceContextInfo->sourceDynamicProfileManager->LoadFromProfileCache(profileDataCache, sourceContextInfo->url);",
          "2482:                 if (profileLoaded)",
          "2483:                 {",
          "2484:                     JS_ETW(EventWriteJSCRIPT_PROFILE_LOAD(sourceContextInfo->dwHostSourceContext, this));",
          "2485:                 }",
          "2486:             }",
          "2487: #endif",
          "2488:             return sourceContextInfo;",
          "2489:         }",
          "2490:         return nullptr;",
          "2491:     }",
          "2493:     SRCINFO const *",
          "2494:         ScriptContext::GetModuleSrcInfo(Js::ModuleID moduleID)",
          "2495:     {",
          "2496:             if (moduleSrcInfoCount <= moduleID)",
          "2497:             {",
          "2498:                 uint newCount = moduleID + 4;  // Preallocate 4 more slots, moduleID don't usually grow much",
          "2500:                 Field(SRCINFO const *)* newModuleSrcInfo = RecyclerNewArrayZ(this->GetRecycler(), Field(SRCINFO const*), newCount);",
          "2501:                 CopyArray(newModuleSrcInfo, newCount, Cache()->moduleSrcInfo, moduleSrcInfoCount);",
          "2502:                 Cache()->moduleSrcInfo = newModuleSrcInfo;",
          "2503:                 moduleSrcInfoCount = newCount;",
          "2504:                 Cache()->moduleSrcInfo[0] = this->Cache()->noContextGlobalSourceInfo;",
          "2505:             }",
          "2507:             SRCINFO const * si = Cache()->moduleSrcInfo[moduleID];",
          "2508:             if (si == nullptr)",
          "2509:             {",
          "2510:                 SRCINFO * newSrcInfo = RecyclerNewStructZ(this->GetRecycler(), SRCINFO);",
          "2511:                 newSrcInfo->sourceContextInfo = this->Cache()->noContextSourceContextInfo;",
          "2512:                 newSrcInfo->moduleID = moduleID;",
          "2513:                 Cache()->moduleSrcInfo[moduleID] = newSrcInfo;",
          "2514:                 si = newSrcInfo;",
          "2515:             }",
          "2516:             return si;",
          "2517:     }",
          "2519: #if ENABLE_TTD",
          "2520:     void ScriptContext::InitializeCoreImage_TTD()",
          "2521:     {",
          "2522:         TTDAssert(this->TTDWellKnownInfo == nullptr, \"This should only happen once!!!\");",
          "2524:         this->TTDContextInfo = TT_HEAP_NEW(TTD::ScriptContextTTD, this);",
          "2525:         this->TTDWellKnownInfo = TT_HEAP_NEW(TTD::RuntimeContextInfo);",
          "2527:         BEGIN_ENTER_SCRIPT(this, true, true, true)",
          "2528:         {",
          "2529:             this->TTDWellKnownInfo->GatherKnownObjectToPathMap(this);",
          "2530:         }",
          "2531:         END_ENTER_SCRIPT",
          "2532:     }",
          "2533: #endif",
          "2535: #ifdef PROFILE_EXEC",
          "2536:     void",
          "2537:         ScriptContext::DisableProfiler()",
          "2538:     {",
          "2539:             disableProfiler = true;",
          "2540:     }",
          "2542:     Profiler *",
          "2543:         ScriptContext::CreateProfiler()",
          "2544:     {",
          "2545:             Assert(profiler == nullptr);",
          "2546:             if (Js::Configuration::Global.flags.IsEnabled(Js::ProfileFlag))",
          "2547:             {",
          "2548:                 this->profiler = NoCheckHeapNew(ScriptContextProfiler);",
          "2549:                 this->profiler->Initialize(GetThreadContext()->GetPageAllocator(), threadContext->GetRecycler());",
          "2551: #if ENABLE_NATIVE_CODEGEN",
          "2552:                 CreateProfilerNativeCodeGen(this->nativeCodeGen, this->profiler);",
          "2553: #endif",
          "2555:                 this->isProfilerCreated = true;",
          "2556:                 Profiler * oldProfiler = this->threadContext->GetRecycler()->GetProfiler();",
          "2557:                 this->threadContext->GetRecycler()->SetProfiler(this->profiler->GetProfiler(), this->profiler->GetBackgroundRecyclerProfiler());",
          "2558:                 return oldProfiler;",
          "2559:             }",
          "2560:             return nullptr;",
          "2561:     }",
          "2563:     void",
          "2564:         ScriptContext::SetRecyclerProfiler()",
          "2565:     {",
          "2566:             Assert(Js::Configuration::Global.flags.IsEnabled(Js::ProfileFlag));",
          "2567:             AssertMsg(this->profiler != nullptr, \"Profiler tag is supplied but the profiler pointer is NULL\");",
          "2569:             if (this->ensureParentInfo)",
          "2570:             {",
          "2571:                 this->hostScriptContext->EnsureParentInfo();",
          "2572:                 this->ensureParentInfo = false;",
          "2573:             }",
          "2575:             this->GetRecycler()->SetProfiler(this->profiler->GetProfiler(), this->profiler->GetBackgroundRecyclerProfiler());",
          "2576:     }",
          "2578:     void",
          "2579:         ScriptContext::SetProfilerFromScriptContext(ScriptContext * scriptContext)",
          "2580:     {",
          "2583:             if (Js::Configuration::Global.flags.IsEnabled(Js::ProfileFlag))",
          "2584:             {",
          "2585:                 Assert(this->profiler != nullptr);",
          "2586:                 Assert(this->isProfilerCreated);",
          "2587:                 Assert(scriptContext->profiler != nullptr);",
          "2588:                 Assert(scriptContext->isProfilerCreated);",
          "2591:                 scriptContext->profiler->ProfileMerge(this->profiler);",
          "2593:                 this->profiler->Release();",
          "2594:                 this->profiler = scriptContext->profiler;",
          "2595:                 this->profiler->AddRef();",
          "2596:                 this->isProfilerCreated = false;",
          "2598: #if ENABLE_NATIVE_CODEGEN",
          "2599:                 SetProfilerFromNativeCodeGen(this->nativeCodeGen, scriptContext->GetNativeCodeGenerator());",
          "2600: #endif",
          "2602:                 this->threadContext->GetRecycler()->SetProfiler(this->profiler->GetProfiler(), this->profiler->GetBackgroundRecyclerProfiler());",
          "2603:             }",
          "2604:     }",
          "2606:     void",
          "2607:         ScriptContext::ProfileBegin(Js::Phase phase)",
          "2608:     {",
          "2609:             AssertMsg((this->profiler != nullptr) == Js::Configuration::Global.flags.IsEnabled(Js::ProfileFlag),",
          "2610:                 \"Profiler tag is supplied but the profiler pointer is NULL\");",
          "2611:             if (this->profiler)",
          "2612:             {",
          "2613:                 if (this->ensureParentInfo)",
          "2614:                 {",
          "2615:                     this->hostScriptContext->EnsureParentInfo();",
          "2616:                     this->ensureParentInfo = false;",
          "2617:                 }",
          "2618:                 this->profiler->ProfileBegin(phase);",
          "2619:             }",
          "2620:     }",
          "2622:     void",
          "2623:         ScriptContext::ProfileEnd(Js::Phase phase)",
          "2624:     {",
          "2625:             AssertMsg((this->profiler != nullptr) == Js::Configuration::Global.flags.IsEnabled(Js::ProfileFlag),",
          "2626:                 \"Profiler tag is supplied but the profiler pointer is NULL\");",
          "2627:             if (this->profiler)",
          "2628:             {",
          "2629:                 this->profiler->ProfileEnd(phase);",
          "2630:             }",
          "2631:     }",
          "2633:     void",
          "2634:         ScriptContext::ProfileSuspend(Js::Phase phase, Js::Profiler::SuspendRecord * suspendRecord)",
          "2635:     {",
          "2636:             AssertMsg((this->profiler != nullptr) == Js::Configuration::Global.flags.IsEnabled(Js::ProfileFlag),",
          "2637:                 \"Profiler tag is supplied but the profiler pointer is NULL\");",
          "2638:             if (this->profiler)",
          "2639:             {",
          "2640:                 this->profiler->ProfileSuspend(phase, suspendRecord);",
          "2641:             }",
          "2642:     }",
          "2644:     void",
          "2645:         ScriptContext::ProfileResume(Js::Profiler::SuspendRecord * suspendRecord)",
          "2646:     {",
          "2647:             AssertMsg((this->profiler != nullptr) == Js::Configuration::Global.flags.IsEnabled(Js::ProfileFlag),",
          "2648:                 \"Profiler tag is supplied but the profiler pointer is NULL\");",
          "2649:             if (this->profiler)",
          "2650:             {",
          "2651:                 this->profiler->ProfileResume(suspendRecord);",
          "2652:             }",
          "2653:     }",
          "2655:     void",
          "2656:         ScriptContext::ProfilePrint()",
          "2657:     {",
          "2658:             if (disableProfiler)",
          "2659:             {",
          "2660:                 return;",
          "2661:             }",
          "2663:             Assert(profiler != nullptr);",
          "2664:             recycler->EnsureNotCollecting();",
          "2665:             profiler->ProfilePrint(Js::Configuration::Global.flags.Profile.GetFirstPhase());",
          "2666: #if ENABLE_NATIVE_CODEGEN",
          "2667:             ProfilePrintNativeCodeGen(this->nativeCodeGen);",
          "2668: #endif",
          "2669:     }",
          "2670: #endif",
          "2672: #ifdef ENABLE_SCRIPT_PROFILING",
          "2673:     inline void ScriptContext::CoreSetProfileEventMask(DWORD dwEventMask)",
          "2674:     {",
          "2675:         AssertMsg(m_pProfileCallback != NULL, \"Assigning the event mask when there is no callback\");",
          "2676:         m_dwEventMask = dwEventMask;",
          "2677:         m_fTraceFunctionCall = (dwEventMask & PROFILER_EVENT_MASK_TRACE_SCRIPT_FUNCTION_CALL);",
          "2678:         m_fTraceNativeFunctionCall = (dwEventMask & PROFILER_EVENT_MASK_TRACE_NATIVE_FUNCTION_CALL);",
          "2680:         m_fTraceDomCall = (dwEventMask & PROFILER_EVENT_MASK_TRACE_DOM_FUNCTION_CALL);",
          "2681:     }",
          "2683:     HRESULT ScriptContext::RegisterProfileProbe(IActiveScriptProfilerCallback *pProfileCallback, DWORD dwEventMask, DWORD dwContext, RegisterExternalLibraryType RegisterExternalLibrary, JavascriptMethod dispatchInvoke)",
          "2684:     {",
          "2685:         if (m_pProfileCallback != NULL)",
          "2686:         {",
          "2687:             return ACTIVPROF_E_PROFILER_PRESENT;",
          "2688:         }",
          "2690:         OUTPUT_TRACE(Js::ScriptProfilerPhase, _u(\"ScriptContext::RegisterProfileProbe\\n\"));",
          "2691:         OUTPUT_TRACE(Js::ScriptProfilerPhase, _u(\"Info\\nThunks Address :\\n\"));",
          "2692:         OUTPUT_TRACE(Js::ScriptProfilerPhase, _u(\"DefaultEntryThunk : 0x%08X, CrossSite::DefaultThunk : 0x%08X, DefaultDeferredParsingThunk : 0x%08X\\n\"), DefaultEntryThunk, CrossSite::DefaultThunk, DefaultDeferredParsingThunk);",
          "2693:         OUTPUT_TRACE(Js::ScriptProfilerPhase, _u(\"ProfileEntryThunk : 0x%08X, CrossSite::ProfileThunk : 0x%08X, ProfileDeferredParsingThunk : 0x%08X, ProfileDeferredDeserializeThunk : 0x%08X,\\n\"), ProfileEntryThunk, CrossSite::ProfileThunk, ProfileDeferredParsingThunk, ProfileDeferredDeserializeThunk);",
          "2694:         OUTPUT_TRACE(Js::ScriptProfilerPhase, _u(\"ScriptType :\\n\"));",
          "2695:         OUTPUT_TRACE(Js::ScriptProfilerPhase, _u(\"PROFILER_SCRIPT_TYPE_USER : 0, PROFILER_SCRIPT_TYPE_DYNAMIC : 1, PROFILER_SCRIPT_TYPE_NATIVE : 2, PROFILER_SCRIPT_TYPE_DOM : 3\\n\"));",
          "2697:         HRESULT hr = pProfileCallback->Initialize(dwContext);",
          "2698:         if (SUCCEEDED(hr))",
          "2699:         {",
          "2700:             m_pProfileCallback = pProfileCallback;",
          "2701:             pProfileCallback->AddRef();",
          "2702:             CoreSetProfileEventMask(dwEventMask);",
          "2703:             if (m_fTraceDomCall)",
          "2704:             {",
          "2705:                 if (FAILED(pProfileCallback->QueryInterface(&m_pProfileCallback2)))",
          "2706:                 {",
          "2707:                     m_fTraceDomCall = FALSE;",
          "2708:                 }",
          "2709:             }",
          "2711:             if (webWorkerId != Js::Constants::NonWebWorkerContextId)",
          "2712:             {",
          "2713:                 IActiveScriptProfilerCallback3 * pProfilerCallback3;",
          "2714:                 if (SUCCEEDED(pProfileCallback->QueryInterface(&pProfilerCallback3)))",
          "2715:                 {",
          "2716:                     pProfilerCallback3->SetWebWorkerId(webWorkerId);",
          "2717:                     pProfilerCallback3->Release();",
          "2719:                 }",
          "2720:             }",
          "2722: #if DEBUG",
          "2723:             StartNewProfileSession();",
          "2724: #endif",
          "2726: #if ENABLE_NATIVE_CODEGEN",
          "2727:             NativeCodeGenerator *pNativeCodeGen = this->GetNativeCodeGenerator();",
          "2728:             AutoOptionalCriticalSection autoAcquireCodeGenQueue(GetNativeCodeGenCriticalSection(pNativeCodeGen));",
          "2729: #endif",
          "2731:             this->SetProfileMode(TRUE);",
          "2733: #if ENABLE_NATIVE_CODEGEN",
          "2734:             SetProfileModeNativeCodeGen(pNativeCodeGen, TRUE);",
          "2735: #endif",
          "2738:             if (m_fTraceNativeFunctionCall)",
          "2739:             {",
          "2740:                 hr = this->RegisterBuiltinFunctions(RegisterExternalLibrary);",
          "2741:                 if (FAILED(hr))",
          "2742:                 {",
          "2743:                     return hr;",
          "2744:                 }",
          "2745:             }",
          "2747:             this->RegisterAllScripts();",
          "2750:             this->SetDispatchProfile(TRUE, dispatchInvoke);",
          "2753:             this->SetFunctionInRecyclerToProfileMode();",
          "2754:         }",
          "2756:         return hr;",
          "2757:     }",
          "2759:     HRESULT ScriptContext::SetProfileEventMask(DWORD dwEventMask)",
          "2760:     {",
          "2761:         if (m_pProfileCallback == NULL)",
          "2762:         {",
          "2763:             return ACTIVPROF_E_PROFILER_ABSENT;",
          "2764:         }",
          "2766:         return ACTIVPROF_E_UNABLE_TO_APPLY_ACTION;",
          "2767:     }",
          "2769:     HRESULT ScriptContext::DeRegisterProfileProbe(HRESULT hrReason, JavascriptMethod dispatchInvoke)",
          "2770:     {",
          "2771:         if (m_pProfileCallback == NULL)",
          "2772:         {",
          "2773:             return ACTIVPROF_E_PROFILER_ABSENT;",
          "2774:         }",
          "2776:         OUTPUT_TRACE(Js::ScriptProfilerPhase, _u(\"ScriptContext::DeRegisterProfileProbe\\n\"));",
          "2778: #if ENABLE_NATIVE_CODEGEN",
          "2780:         NativeCodeGenerator *pNativeCodeGen = this->GetNativeCodeGenerator();",
          "2781:         Assert(pNativeCodeGen);",
          "2782:         {",
          "2783:             AutoOptionalCriticalSection lock(GetNativeCodeGenCriticalSection(pNativeCodeGen));",
          "2785:             this->SetProfileMode(FALSE);",
          "2786:             SetProfileModeNativeCodeGen(pNativeCodeGen, FALSE);",
          "2790:             if (dispatchInvoke != nullptr)",
          "2791:             {",
          "2792:                 this->SetDispatchProfile(FALSE, dispatchInvoke);",
          "2793:             }",
          "2794:         }",
          "2795: #endif",
          "2797:         m_inProfileCallback = TRUE;",
          "2798:         HRESULT hr = m_pProfileCallback->Shutdown(hrReason);",
          "2799:         m_inProfileCallback = FALSE;",
          "2800:         m_pProfileCallback->Release();",
          "2801:         m_pProfileCallback = NULL;",
          "2803:         if (m_pProfileCallback2 != NULL)",
          "2804:         {",
          "2805:             m_pProfileCallback2->Release();",
          "2806:             m_pProfileCallback2 = NULL;",
          "2807:         }",
          "2809: #if DEBUG",
          "2810:         StopProfileSession();",
          "2811: #endif",
          "2813:         return hr;",
          "2814:     }",
          "2816:     void ScriptContext::SetProfileMode(BOOL fSet)",
          "2817:     {",
          "2818: #ifdef ENABLE_SCRIPT_PROFILING",
          "2819:         if (fSet)",
          "2820:         {",
          "2821:             AssertMsg(m_pProfileCallback != NULL, \"In profile mode when there is no call back\");",
          "2822:             this->CurrentThunk = ProfileEntryThunk;",
          "2823:             this->CurrentCrossSiteThunk = CrossSite::ProfileThunk;",
          "2824:             this->DeferredParsingThunk = ProfileDeferredParsingThunk;",
          "2825:             this->DeferredDeserializationThunk = ProfileDeferredDeserializeThunk;",
          "2826:             this->globalObject->EvalHelper = &Js::GlobalObject::ProfileModeEvalHelper;",
          "2827: #if DBG",
          "2828:             this->hadProfiled = true;",
          "2829: #endif",
          "2830:         }",
          "2831:         else",
          "2832: #endif",
          "2833:         {",
          "2834:             Assert(!fSet);",
          "2835:             this->CurrentThunk = DefaultEntryThunk;",
          "2836:             this->CurrentCrossSiteThunk = CrossSite::DefaultThunk;",
          "2837:             this->DeferredParsingThunk = DefaultDeferredParsingThunk;",
          "2838:             this->globalObject->EvalHelper = &Js::GlobalObject::DefaultEvalHelper;",
          "2841:             if (!(this->IsScriptContextInDebugMode() && this->IsExceptionWrapperForBuiltInsEnabled()))",
          "2842:             {",
          "2843:                 this->javascriptLibrary->SetProfileMode(FALSE);",
          "2844:             }",
          "2845:         }",
          "2846:     }",
          "2848:     HRESULT ScriptContext::RegisterScript(Js::FunctionProxy * proxy, BOOL fRegisterScript /*default TRUE*/)",
          "2849:     {",
          "2850:         if (m_pProfileCallback == nullptr)",
          "2851:         {",
          "2852:             return ACTIVPROF_E_PROFILER_ABSENT;",
          "2853:         }",
          "2855:         OUTPUT_TRACE(Js::ScriptProfilerPhase, _u(\"ScriptContext::RegisterScript, fRegisterScript : %s, IsFunctionDefer : %s\\n\"), IsTrueOrFalse(fRegisterScript), IsTrueOrFalse(proxy->IsDeferred()));",
          "2857:         AssertMsg(proxy != nullptr, \"Function body cannot be null when calling reporting\");",
          "2858:         AssertMsg(proxy->GetScriptContext() == this, \"wrong script context while reporting the function?\");",
          "2860:         if (fRegisterScript)",
          "2861:         {",
          "2864:             HRESULT hr = proxy->EnsureDeserialized()->Parse()->ReportScriptCompiled();",
          "2865:             if (FAILED(hr))",
          "2866:             {",
          "2867:                 return hr;",
          "2868:             }",
          "2869:         }",
          "2871:         return !proxy->IsDeferred() ? proxy->GetFunctionBody()->RegisterFunction(false) : S_OK;",
          "2872:     }",
          "2874:     HRESULT ScriptContext::RegisterAllScripts()",
          "2875:     {",
          "2876:         AssertMsg(m_pProfileCallback != nullptr, \"Called register scripts when we don't have profile callback\");",
          "2878:         OUTPUT_TRACE(Js::ScriptProfilerPhase, _u(\"ScriptContext::RegisterAllScripts started\\n\"));",
          "2884:         this->MapScript([](Utf8SourceInfo* sourceInfo)",
          "2885:         {",
          "2886:             FunctionBody* functionBody = sourceInfo->GetAnyParsedFunction();",
          "2887:             if (functionBody)",
          "2888:             {",
          "2889:                 functionBody->ReportScriptCompiled();",
          "2890:             }",
          "2891:         });",
          "2894:         this->MapFunction([](Js::FunctionBody* pFuncBody)",
          "2895:         {",
          "2896:             if (!pFuncBody->GetIsTopLevel() && pFuncBody->GetIsGlobalFunc())",
          "2897:             {",
          "2899:                 return;",
          "2900:             }",
          "2902:             pFuncBody->RegisterFunction(TRUE, TRUE); // Ignore potential failure (worst case is not profiling).",
          "2903:         });",
          "2905:         OUTPUT_TRACE(Js::ScriptProfilerPhase, _u(\"ScriptContext::RegisterAllScripts ended\\n\"));",
          "2906:         return S_OK;",
          "2907:     }",
          "2908: #endif // ENABLE_SCRIPT_PROFILING",
          "2914: #if ENABLE_NATIVE_CODEGEN",
          "2915:     HRESULT ScriptContext::RecreateNativeCodeGenerator()",
          "2916:     {",
          "2917:         NativeCodeGenerator* oldCodeGen = this->nativeCodeGen;",
          "2919:         HRESULT hr = S_OK;",
          "2920:         BEGIN_TRANSLATE_OOM_TO_HRESULT_NESTED",
          "2921:             this->nativeCodeGen = NewNativeCodeGenerator(this);",
          "2922:         SetProfileModeNativeCodeGen(this->GetNativeCodeGenerator(), this->IsProfiling());",
          "2923:         END_TRANSLATE_OOM_TO_HRESULT(hr);",
          "2927:         CloseNativeCodeGenerator(oldCodeGen);",
          "2928:         DeleteNativeCodeGenerator(oldCodeGen);",
          "2930:         return hr;",
          "2931:     }",
          "2932: #endif",
          "2934:     HRESULT ScriptContext::OnDebuggerAttached()",
          "2935:     {",
          "2936:         OUTPUT_TRACE(Js::DebuggerPhase, _u(\"ScriptContext::OnDebuggerAttached: start 0x%p\\n\"), this);",
          "2938:         Js::StepController* stepController = &this->GetThreadContext()->GetDebugManager()->stepController;",
          "2939:         if (stepController->IsActive())",
          "2940:         {",
          "2941:             AssertMsg(stepController->GetActivatedContext() == nullptr, \"StepController should not be active when we attach.\");",
          "2942:             stepController->Deactivate(); // Defense in depth",
          "2943:         }",
          "2945:         bool shouldPerformSourceRundown = false;",
          "2946:         if (this->IsScriptContextInNonDebugMode())",
          "2947:         {",
          "2951:             this->GetDebugContext()->SetDebuggerMode(Js::DebuggerMode::SourceRundown);",
          "2954:             shouldPerformSourceRundown = true;",
          "2955:         }",
          "2959:         HRESULT hr = OnDebuggerAttachedDetached(/*attach*/ true);",
          "2962:         DEBUGGER_ATTACHDETACH_FATAL_ERROR_IF_FAILED(hr);",
          "2965:         AutoDisableInterrupt autoDisableInterrupt(this->threadContext->GetInterruptPoller(), true);",
          "2967:         hr = this->GetDebugContext()->RundownSourcesAndReparse(shouldPerformSourceRundown, /*shouldReparseFunctions*/ true);",
          "2969:         if (this->IsClosed())",
          "2970:         {",
          "2971:             return hr;",
          "2972:         }",
          "2975:         DEBUGGER_ATTACHDETACH_FATAL_ERROR_IF_FAILED(hr);",
          "2977:         HRESULT hrEntryPointUpdate = S_OK;",
          "2978:         BEGIN_TRANSLATE_OOM_TO_HRESULT_NESTED",
          "2979: #ifdef ASMJS_PLAT",
          "2980:             TempArenaAllocatorObject* tmpAlloc = GetTemporaryAllocator(_u(\"DebuggerTransition\"));",
          "2981:             debugTransitionAlloc = tmpAlloc->GetAllocator();",
          "2983:             asmJsEnvironmentMap = Anew(debugTransitionAlloc, AsmFunctionMap, debugTransitionAlloc);",
          "2984: #endif",
          "2987:             this->UpdateRecyclerFunctionEntryPointsForDebugger();",
          "2989: #ifdef ASMJS_PLAT",
          "2990:             auto asmEnvIter = asmJsEnvironmentMap->GetIterator();",
          "2991:             while (asmEnvIter.IsValid())",
          "2992:             {",
          "2994:                 SList<AsmJsScriptFunction *> * funcList = asmEnvIter.CurrentValue();",
          "2995:                 Assert(!funcList->Empty());",
          "2996:                 void* newEnv = AsmJsModuleInfo::ConvertFrameForJavascript(asmEnvIter.CurrentKey(), funcList->Head());",
          "2997:                 funcList->Iterate([&](AsmJsScriptFunction * func)",
          "2998:                 {",
          "2999:                     func->GetEnvironment()->SetItem(0, newEnv);",
          "3000:                 });",
          "3001:                 asmEnvIter.MoveNext();",
          "3002:             }",
          "3005:             auto asmCleanupIter = asmJsEnvironmentMap->GetIterator();",
          "3006:             while (asmCleanupIter.IsValid())",
          "3007:             {",
          "3008:                 SList<AsmJsScriptFunction *> * funcList = asmCleanupIter.CurrentValue();",
          "3009:                 Assert(!funcList->Empty());",
          "3010:                 funcList->Iterate([](AsmJsScriptFunction * func)",
          "3011:                 {",
          "3012:                     func->SetModuleMemory(nullptr);",
          "3013:                     func->GetFunctionBody()->ResetAsmJsInfo();",
          "3014:                 });",
          "3015:                 asmCleanupIter.MoveNext();",
          "3016:             }",
          "3018:             ReleaseTemporaryAllocator(tmpAlloc);",
          "3019: #endif",
          "3020:         END_TRANSLATE_OOM_TO_HRESULT(hrEntryPointUpdate);",
          "3022:         if (hrEntryPointUpdate != S_OK)",
          "3023:         {",
          "3025:             Assert(hrEntryPointUpdate == E_OUTOFMEMORY);",
          "3026:             return hrEntryPointUpdate;",
          "3027:         }",
          "3029:         OUTPUT_TRACE(Js::DebuggerPhase, _u(\"ScriptContext::OnDebuggerAttached: done 0x%p, hr = 0x%X\\n\"), this, hr);",
          "3031:         return hr;",
          "3032:     }",
          "3035:     HRESULT ScriptContext::OnDebuggerDetached()",
          "3036:     {",
          "3037:         OUTPUT_TRACE(Js::DebuggerPhase, _u(\"ScriptContext::OnDebuggerDetached: start 0x%p\\n\"), this);",
          "3039:         Js::StepController* stepController = &this->GetThreadContext()->GetDebugManager()->stepController;",
          "3040:         if (stepController->IsActive())",
          "3041:         {",
          "3045:             stepController->Deactivate();",
          "3046:         }",
          "3052:         HRESULT hr = OnDebuggerAttachedDetached(/*attach*/ false);",
          "3055:         DEBUGGER_ATTACHDETACH_FATAL_ERROR_IF_FAILED(hr);",
          "3058:         this->GetDebugContext()->SetDebuggerMode(Js::DebuggerMode::SourceRundown);",
          "3061:         AutoDisableInterrupt autoDisableInterrupt(this->threadContext->GetInterruptPoller(), true);",
          "3064:         hr = this->GetDebugContext()->RundownSourcesAndReparse(/*shouldPerformSourceRundown*/ false, /*shouldReparseFunctions*/ true);",
          "3066:         if (this->IsClosed())",
          "3067:         {",
          "3068:             return hr;",
          "3069:         }",
          "3072:         DEBUGGER_ATTACHDETACH_FATAL_ERROR_IF_FAILED(hr);",
          "3075:         this->UpdateRecyclerFunctionEntryPointsForDebugger();",
          "3077:         OUTPUT_TRACE(Js::DebuggerPhase, _u(\"ScriptContext::OnDebuggerDetached: done 0x%p, hr = 0x%X\\n\"), this, hr);",
          "3079:         return hr;",
          "3080:     }",
          "3082:     HRESULT ScriptContext::OnDebuggerAttachedDetached(bool attach)",
          "3083:     {",
          "3086:         struct AutoRestore",
          "3087:         {",
          "3088:             AutoRestore(ThreadContext* threadContext)",
          "3089:                 :threadContext(threadContext)",
          "3090:             {",
          "3091:                 this->threadContext->GetDebugManager()->SetDebuggerAttaching(true);",
          "3092:             }",
          "3093:             ~AutoRestore()",
          "3094:             {",
          "3095:                 this->threadContext->GetDebugManager()->SetDebuggerAttaching(false);",
          "3096:             }",
          "3098:         private:",
          "3099:             ThreadContext* threadContext;",
          "3101:         } autoRestore(this->GetThreadContext());",
          "3103:         if (!Js::Configuration::Global.EnableJitInDebugMode())",
          "3104:         {",
          "3105:             if (attach)",
          "3106:             {",
          "3108:                 ForceNoNative();",
          "3109:             }",
          "3110:             else",
          "3111:             {",
          "3114:                 this->ForceNative();",
          "3115:             }",
          "3116:         }",
          "3119:         this->threadContext->InvalidateAllProtoInlineCaches();",
          "3120:         this->threadContext->InvalidateAllStoreFieldInlineCaches();",
          "3121:         this->threadContext->InvalidateAllIsInstInlineCaches();",
          "3123:         if (!attach)",
          "3124:         {",
          "3125:             this->UnRegisterDebugThunk();",
          "3128:             this->GetDebugContext()->GetProbeContainer()->RemoveAllProbes();",
          "3129:         }",
          "3131:         HRESULT hr = S_OK;",
          "3133: #ifndef _WIN32",
          "3134:         BEGIN_TRANSLATE_OOM_TO_HRESULT_NESTED",
          "3135:         {",
          "3141:             this->sourceList->Map([=](uint i, RecyclerWeakReference<Js::Utf8SourceInfo>* sourceInfoWeakRef) {",
          "3142:                 Js::Utf8SourceInfo* sourceInfo = sourceInfoWeakRef->Get();",
          "3144:                 if (sourceInfo != nullptr)",
          "3145:                 {",
          "3146:                     sourceInfo->MapFunction([](Js::FunctionBody* functionBody) {",
          "3147:                         functionBody->ResetEntryPoint();",
          "3148:                     });",
          "3149:                 }",
          "3150:             });",
          "3151:         }",
          "3152:         END_TRANSLATE_OOM_TO_HRESULT(hr);",
          "3154:         if (FAILED(hr))",
          "3155:         {",
          "3156:             return hr;",
          "3157:         }",
          "3158: #endif",
          "3160:         if (!CONFIG_FLAG(ForceDiagnosticsMode))",
          "3161:         {",
          "3162: #if ENABLE_NATIVE_CODEGEN",
          "3165:             hr = RecreateNativeCodeGenerator();",
          "3166:             if (FAILED(hr))",
          "3167:             {",
          "3168:                 return hr;",
          "3169:             }",
          "3170: #endif",
          "3171:             if (attach)",
          "3172:             {",
          "3175:                 this->GetDebugContext()->SetDebuggerMode(Js::DebuggerMode::Debugging);",
          "3176: #if ENABLE_NATIVE_CODEGEN",
          "3177:                 UpdateNativeCodeGeneratorForDebugMode(this->nativeCodeGen);",
          "3178: #endif",
          "3179:             }",
          "3180:         }",
          "3181:         else if (attach)",
          "3182:         {",
          "3183:             this->GetDebugContext()->SetDebuggerMode(Js::DebuggerMode::Debugging);",
          "3184:         }",
          "3186:         BEGIN_TRANSLATE_OOM_TO_HRESULT_NESTED",
          "3187:         {",
          "3189:             this->sourceList->Map([=](uint i, RecyclerWeakReference<Js::Utf8SourceInfo>* sourceInfoWeakRef) {",
          "3190:                 Js::Utf8SourceInfo* sourceInfo = sourceInfoWeakRef->Get();",
          "3192:                 if (sourceInfo != nullptr)",
          "3193:                 {",
          "3194:                     if (!sourceInfo->GetIsLibraryCode())",
          "3195:                     {",
          "3196:                         sourceInfo->SetInDebugMode(attach);",
          "3198:                         sourceInfo->MapFunction([](Js::FunctionBody* functionBody) {",
          "3199:                             functionBody->SetEntryToDeferParseForDebugger();",
          "3200:                         });",
          "3201:                     }",
          "3202: #ifdef _WIN32",
          "3203:                     else",
          "3204:                     {",
          "3205:                         sourceInfo->MapFunction([](Js::FunctionBody* functionBody) {",
          "3206:                             functionBody->ResetEntryPoint();",
          "3207:                         });",
          "3208:                     }",
          "3209: #endif",
          "3210:                 }",
          "3211:             });",
          "3212:         }",
          "3213:         END_TRANSLATE_OOM_TO_HRESULT(hr);",
          "3215:         if (FAILED(hr))",
          "3216:         {",
          "3217:             return hr;",
          "3218:         }",
          "3220:         if (attach)",
          "3221:         {",
          "3222:             this->RegisterDebugThunk();",
          "3223:         }",
          "3225: #if ENABLE_PROFILE_INFO",
          "3226: #if DBG_DUMP || defined(DYNAMIC_PROFILE_STORAGE) || defined(RUNTIME_DATA_COLLECTION)",
          "3228:         if (this->Cache()->profileInfoList)",
          "3229:         {",
          "3230:             this->Cache()->profileInfoList->Reset();",
          "3231:         }",
          "3232: #endif",
          "3233: #endif",
          "3234:         return hr;",
          "3235:     }",
          "3237: #if defined(ENABLE_SCRIPT_DEBUGGING) || defined(ENABLE_SCRIPT_PROFILING)",
          "3239:     void ScriptContext::RegisterDebugThunk(bool calledDuringAttach /*= true*/)",
          "3240:     {",
          "3241:         if (this->IsExceptionWrapperForBuiltInsEnabled())",
          "3242:         {",
          "3243:             this->CurrentThunk = ProfileEntryThunk;",
          "3244:             this->CurrentCrossSiteThunk = CrossSite::ProfileThunk;",
          "3245: #if ENABLE_NATIVE_CODEGEN",
          "3246:             SetProfileModeNativeCodeGen(this->GetNativeCodeGenerator(), TRUE);",
          "3247: #endif",
          "3251:             this->javascriptLibrary->SetProfileMode(true);",
          "3252:             this->javascriptLibrary->SetDispatchProfile(true, DispatchProfileInvoke);",
          "3254: #ifdef ENABLE_SCRIPT_PROFILING",
          "3255:             if (!calledDuringAttach)",
          "3256:             {",
          "3257:                 m_fTraceDomCall = TRUE; // This flag is always needed in DebugMode to wrap external functions with DebugProfileThunk",
          "3259:                 this->SetFunctionInRecyclerToProfileMode(true/*enumerateNonUserFunctionsOnly*/);",
          "3260:             }",
          "3261: #endif",
          "3262:         }",
          "3263:     }",
          "3265:     void ScriptContext::UnRegisterDebugThunk()",
          "3266:     {",
          "3267:         if (!this->IsProfiling() && this->IsExceptionWrapperForBuiltInsEnabled())",
          "3268:         {",
          "3269:             this->CurrentThunk = DefaultEntryThunk;",
          "3270:             this->CurrentCrossSiteThunk = CrossSite::DefaultThunk;",
          "3271: #if ENABLE_NATIVE_CODEGEN",
          "3272:             SetProfileModeNativeCodeGen(this->GetNativeCodeGenerator(), FALSE);",
          "3273: #endif",
          "3275:             if (!this->IsProfiling())",
          "3276:             {",
          "3277:                 this->javascriptLibrary->SetProfileMode(false);",
          "3278:                 this->javascriptLibrary->SetDispatchProfile(false, DispatchDefaultInvoke);",
          "3279:             }",
          "3280:         }",
          "3281:     }",
          "3282: #endif // defined(ENABLE_SCRIPT_DEBUGGING) || defined(ENABLE_SCRIPT_PROFILING)",
          "3284: #ifdef ENABLE_SCRIPT_PROFILING",
          "3285:     HRESULT ScriptContext::RegisterBuiltinFunctions(RegisterExternalLibraryType RegisterExternalLibrary)",
          "3286:     {",
          "3287:         Assert(m_pProfileCallback != NULL);",
          "3289:         OUTPUT_TRACE(Js::ScriptProfilerPhase, _u(\"ScriptContext::RegisterBuiltinFunctions\\n\"));",
          "3291:         HRESULT hr = S_OK;",
          "3293:         if (m_pBuiltinFunctionIdMap == NULL)",
          "3294:         {",
          "3296:             m_pBuiltinFunctionIdMap = Anew(GeneralAllocator(), BuiltinFunctionIdDictionary,",
          "3297:                 GeneralAllocator(), 17);",
          "3298:         }",
          "3300:         this->javascriptLibrary->SetProfileMode(TRUE);",
          "3302:         if (FAILED(hr = OnScriptCompiled(BuiltInFunctionsScriptId, PROFILER_SCRIPT_TYPE_NATIVE, NULL)))",
          "3303:         {",
          "3304:             return hr;",
          "3305:         }",
          "3307:         if (FAILED(hr = this->javascriptLibrary->ProfilerRegisterBuiltIns()))",
          "3308:         {",
          "3309:             return hr;",
          "3310:         }",
          "3313:         if (RegisterExternalLibrary != NULL)",
          "3314:         {",
          "3315:             (*RegisterExternalLibrary)(this);",
          "3316:         }",
          "3318:         return hr;",
          "3319:     }",
          "3321:     void ScriptContext::SetFunctionInRecyclerToProfileMode(bool enumerateNonUserFunctionsOnly/* = false*/)",
          "3322:     {",
          "3323:         OUTPUT_TRACE(Js::ScriptProfilerPhase, _u(\"ScriptContext::SetFunctionInRecyclerToProfileMode started (m_fTraceDomCall : %s)\\n\"), IsTrueOrFalse(m_fTraceDomCall));",
          "3326:         AutoEnumeratingRecyclerObjects enumeratingRecyclerObjects(this);",
          "3328:         m_enumerateNonUserFunctionsOnly = enumerateNonUserFunctionsOnly;",
          "3330:         this->recycler->EnumerateObjects(JavascriptLibrary::EnumFunctionClass, &ScriptContext::RecyclerEnumClassEnumeratorCallback);",
          "3332:         OUTPUT_TRACE(Js::ScriptProfilerPhase, _u(\"ScriptContext::SetFunctionInRecyclerToProfileMode ended\\n\"));",
          "3333:     }",
          "3334: #endif // ENABLE_SCRIPT_PROFILING",
          "3336:     void ScriptContext::UpdateRecyclerFunctionEntryPointsForDebugger()",
          "3337:     {",
          "3339:         AutoEnumeratingRecyclerObjects enumeratingRecyclerObjects(this);",
          "3341:         this->recycler->EnumerateObjects(JavascriptLibrary::EnumFunctionClass, &ScriptContext::RecyclerFunctionCallbackForDebugger);",
          "3342:     }",
          "3344: #ifdef ASMJS_PLAT",
          "3345:     void ScriptContext::TransitionEnvironmentForDebugger(ScriptFunction * scriptFunction)",
          "3346:     {",
          "3347:         FunctionBody* functionBody = scriptFunction->GetFunctionBody();",
          "3348: #ifdef ENABLE_WASM",
          "3351:         if (functionBody->IsWasmFunction())",
          "3352:         {",
          "3354:             JavascriptMethod realThunk = CurrentThunk;",
          "3355:             CurrentThunk = AsmJsDefaultEntryThunk;",
          "3356:             functionBody->ResetEntryPoint();",
          "3357:             CurrentThunk = realThunk;",
          "3359:             bool isDeferred = functionBody->GetAsmJsFunctionInfo()->IsWasmDeferredParse();",
          "3361:             scriptFunction->ChangeEntryPoint(functionBody->GetDefaultEntryPointInfo(), AsmJsDefaultEntryThunk);",
          "3362:             WasmLibrary::SetWasmEntryPointToInterpreter(scriptFunction, isDeferred);",
          "3364:             functionBody->SetIsAsmJsFullJitScheduled(false);",
          "3365:             Assert(functionBody->HasValidEntryPoint());",
          "3366:         }",
          "3367:         else",
          "3368: #endif",
          "3369:         if (scriptFunction->GetScriptContext()->IsScriptContextInDebugMode())",
          "3370:         {",
          "3371:             if (functionBody->IsInDebugMode() &&",
          "3372:                 scriptFunction->GetFunctionBody()->GetAsmJsFunctionInfo() != nullptr &&",
          "3373:                 scriptFunction->GetFunctionBody()->GetAsmJsFunctionInfo()->GetModuleFunctionBody() != nullptr)",
          "3374:             {",
          "3375:                 void* env = scriptFunction->GetEnvironment()->GetItem(0);",
          "3376:                 SList<AsmJsScriptFunction*> * funcList = nullptr;",
          "3377:                 if (asmJsEnvironmentMap->TryGetValue(env, &funcList))",
          "3378:                 {",
          "3379:                     funcList->Push((AsmJsScriptFunction*)scriptFunction);",
          "3380:                 }",
          "3381:                 else",
          "3382:                 {",
          "3383:                     SList<AsmJsScriptFunction*> * newList = Anew(debugTransitionAlloc, SList<AsmJsScriptFunction*>, debugTransitionAlloc);",
          "3384:                     asmJsEnvironmentMap->AddNew(env, newList);",
          "3385:                     newList->Push((AsmJsScriptFunction*)scriptFunction);",
          "3386:                 }",
          "3387:             }",
          "3388:         }",
          "3389:     }",
          "3390: #endif",
          "3393:     void ScriptContext::RecyclerFunctionCallbackForDebugger(void *address, size_t size)",
          "3394:     {",
          "3395:         JavascriptFunction *pFunction = (JavascriptFunction *)address;",
          "3397:         ScriptContext* scriptContext = pFunction->GetScriptContext();",
          "3398:         if (scriptContext == nullptr || scriptContext->IsClosed())",
          "3399:         {",
          "3401:             return;",
          "3402:         }",
          "3404:         if (!scriptContext->IsEnumeratingRecyclerObjects())",
          "3405:         {",
          "3406:             return; // function not from enumerating script context",
          "3407:         }",
          "3410:         Assert(pFunction->GetFunctionInfo() != &JavascriptExternalFunction::EntryInfo::WrappedFunctionThunk);",
          "3412:         JavascriptMethod entryPoint = pFunction->GetEntryPoint();",
          "3413:         FunctionInfo * info = pFunction->GetFunctionInfo();",
          "3414:         FunctionProxy * proxy = info->GetFunctionProxy();",
          "3416:         if (proxy == nullptr)",
          "3417:         {",
          "3419:             if (!pFunction->IsScriptFunction() && IsExceptionWrapperForBuiltInsEnabled(scriptContext))",
          "3420:             {",
          "3421: #if defined(ENABLE_SCRIPT_DEBUGGING) || defined(ENABLE_SCRIPT_PROFILING)",
          "3422:                 if (scriptContext->IsScriptContextInDebugMode())",
          "3423:                 {",
          "3426:                     ScriptContext::SetEntryPointToProfileThunk(pFunction);",
          "3427:                 }",
          "3428:                 else",
          "3429:                 {",
          "3432:                     if (!scriptContext->IsProfiling())",
          "3433:                     {",
          "3434:                         ScriptContext::RestoreEntryPointFromProfileThunk(pFunction);",
          "3435:                     }",
          "3437:                 }",
          "3438: #else",
          "3439:                 AssertMsg(false, \"Debugging/Profiling needs to be enabled to change thunks\");",
          "3440: #endif",
          "3441:             }",
          "3443:             return;",
          "3444:         }",
          "3446:         Assert(proxy->GetFunctionInfo() == info);",
          "3448:         if (!proxy->IsFunctionBody())",
          "3449:         {",
          "3451:             return;",
          "3452:         }",
          "3453:         Assert(pFunction->IsScriptFunction());",
          "3456:         if (!proxy->GetUtf8SourceInfo()->GetIsLibraryCode())",
          "3457:         {",
          "3460:             pFunction->ResetConstructorCacheToDefault();",
          "3461:         }",
          "3463:         if (ScriptFunctionWithInlineCache::Is(pFunction))",
          "3464:         {",
          "3465:             ScriptFunctionWithInlineCache::FromVar(pFunction)->ClearInlineCacheOnFunctionObject();",
          "3466:         }",
          "3469:         FunctionBody * pBody = proxy->GetFunctionBody();",
          "3471: #ifdef ENABLE_DEBUG_CONFIG_OPTIONS",
          "3472:         if (scriptContext->IsScriptContextInDebugMode() &&",
          "3473:             !proxy->GetUtf8SourceInfo()->GetIsLibraryCode() &&",
          "3474: #ifdef ENABLE_WASM",
          "3475:             !pBody->IsWasmFunction() &&",
          "3476: #endif",
          "3477:             !pBody->IsInDebugMode())",
          "3478:         {",
          "3480:             Throw::FatalInternalError();",
          "3481:         }",
          "3482: #endif",
          "3484:         ScriptFunction * scriptFunction = ScriptFunction::FromVar(pFunction);",
          "3486: #ifdef ASMJS_PLAT",
          "3487:         scriptContext->TransitionEnvironmentForDebugger(scriptFunction);",
          "3488: #endif",
          "3490:         JavascriptMethod newEntryPoint;",
          "3491:         if (CrossSite::IsThunk(entryPoint))",
          "3492:         {",
          "3494:             newEntryPoint = entryPoint;",
          "3495:         }",
          "3496:         else",
          "3497:         {",
          "3498:             newEntryPoint = pBody->GetDirectEntryPoint(pBody->GetDefaultFunctionEntryPointInfo());",
          "3499:         }",
          "3501:         scriptFunction->ChangeEntryPoint(pBody->GetDefaultFunctionEntryPointInfo(), newEntryPoint);",
          "3502:     }",
          "3504: #if defined(ENABLE_SCRIPT_PROFILING) || defined(ENABLE_SCRIPT_DEBUGGING)",
          "3505:     void ScriptContext::RecyclerEnumClassEnumeratorCallback(void *address, size_t size)",
          "3506:     {",
          "3509:         JavascriptFunction *pFunction = (JavascriptFunction *)address;",
          "3511:         ScriptContext* scriptContext = pFunction->GetScriptContext();",
          "3512:         if (scriptContext == nullptr || scriptContext->IsClosed())",
          "3513:         {",
          "3515:             return;",
          "3516:         }",
          "3518:         if (!scriptContext->IsEnumeratingRecyclerObjects())",
          "3519:         {",
          "3520:             return; // function not from enumerating script context",
          "3521:         }",
          "3523:         if (!scriptContext->IsTraceDomCall() && (pFunction->IsExternalFunction() || pFunction->IsWinRTFunction()))",
          "3524:         {",
          "3525:             return;",
          "3526:         }",
          "3528:         if (scriptContext->IsEnumerateNonUserFunctionsOnly() && pFunction->IsScriptFunction())",
          "3529:         {",
          "3530:             return;",
          "3531:         }",
          "3534:         Assert(pFunction->GetFunctionInfo() != &JavascriptExternalFunction::EntryInfo::WrappedFunctionThunk);",
          "3536:         JavascriptMethod entryPoint = pFunction->GetEntryPoint();",
          "3537:         FunctionProxy *proxy = pFunction->GetFunctionProxy();",
          "3539:         if (proxy != NULL)",
          "3540:         {",
          "3541: #if ENABLE_DEBUG_CONFIG_OPTIONS",
          "3542:             char16 debugStringBuffer[MAX_FUNCTION_BODY_DEBUG_STRING_SIZE];",
          "3543: #endif",
          "3545: #if defined(ENABLE_SCRIPT_PROFILING)",
          "3546:             OUTPUT_TRACE(Js::ScriptProfilerPhase, _u(\"ScriptContext::RecyclerEnumClassEnumeratorCallback\\n\"));",
          "3547:             OUTPUT_TRACE(Js::ScriptProfilerPhase, _u(\"\\tFunctionProxy : 0x%08X, FunctionNumber : %s, DeferredParseAttributes : %d, EntryPoint : 0x%08X\"),",
          "3548:                 (DWORD_PTR)proxy, proxy->GetDebugNumberSet(debugStringBuffer), proxy->GetAttributes(), (DWORD_PTR)entryPoint);",
          "3549: #if ENABLE_NATIVE_CODEGEN",
          "3550:             OUTPUT_TRACE(Js::ScriptProfilerPhase, _u(\" (IsIntermediateCodeGenThunk : %s, isNative : %s)\\n\"),",
          "3551:                 IsTrueOrFalse(IsIntermediateCodeGenThunk(entryPoint)), IsTrueOrFalse(scriptContext->IsNativeAddress(entryPoint)));",
          "3552: #endif",
          "3553:             OUTPUT_TRACE(Js::ScriptProfilerPhase, _u(\"\\n\"));",
          "3554: #endif",
          "3556: #if ENABLE_NATIVE_CODEGEN",
          "3557:             if (!IsIntermediateCodeGenThunk(entryPoint) && entryPoint != DynamicProfileInfo::EnsureDynamicProfileInfoThunk)",
          "3558: #endif",
          "3559:             {",
          "3560:                 OUTPUT_TRACE(Js::ScriptProfilerPhase, _u(\"\\t\\tJs::ScriptContext::GetProfileModeThunk : 0x%08X\\n\"), (DWORD_PTR)Js::ScriptContext::GetProfileModeThunk(entryPoint));",
          "3562:                 ScriptFunction * scriptFunction = ScriptFunction::FromVar(pFunction);",
          "3563:                 scriptFunction->ChangeEntryPoint(proxy->GetDefaultEntryPointInfo(), Js::ScriptContext::GetProfileModeThunk(entryPoint));",
          "3565: #if ENABLE_NATIVE_CODEGEN && defined(ENABLE_SCRIPT_PROFILING)",
          "3566:                 OUTPUT_TRACE(Js::ScriptProfilerPhase, _u(\"\\tUpdated entrypoint : 0x%08X (isNative : %s)\\n\"), (DWORD_PTR)pFunction->GetEntryPoint(), IsTrueOrFalse(scriptContext->IsNativeAddress(entryPoint)));",
          "3567: #endif",
          "3568:             }",
          "3569:         }",
          "3570:         else",
          "3571:         {",
          "3572:             ScriptContext::SetEntryPointToProfileThunk(pFunction);",
          "3573:         }",
          "3574:     }",
          "3577:     void ScriptContext::SetEntryPointToProfileThunk(JavascriptFunction* function)",
          "3578:     {",
          "3579:         JavascriptMethod entryPoint = function->GetEntryPoint();",
          "3580:         if (entryPoint == Js::CrossSite::DefaultThunk)",
          "3581:         {",
          "3582:             function->SetEntryPoint(Js::CrossSite::ProfileThunk);",
          "3583:         }",
          "3584:         else if (entryPoint != Js::CrossSite::ProfileThunk && entryPoint != ProfileEntryThunk)",
          "3585:         {",
          "3586:             function->SetEntryPoint(ProfileEntryThunk);",
          "3587:         }",
          "3588:     }",
          "3591:     void ScriptContext::RestoreEntryPointFromProfileThunk(JavascriptFunction* function)",
          "3592:     {",
          "3593:         JavascriptMethod entryPoint = function->GetEntryPoint();",
          "3594:         if (entryPoint == Js::CrossSite::ProfileThunk)",
          "3595:         {",
          "3596:             function->SetEntryPoint(Js::CrossSite::DefaultThunk);",
          "3597:         }",
          "3598:         else if (entryPoint == ProfileEntryThunk)",
          "3599:         {",
          "3600:             function->SetEntryPoint(function->GetFunctionInfo()->GetOriginalEntryPoint());",
          "3601:         }",
          "3602:     }",
          "3604:     JavascriptMethod ScriptContext::GetProfileModeThunk(JavascriptMethod entryPoint)",
          "3605:     {",
          "3606:     #if ENABLE_NATIVE_CODEGEN",
          "3607:         Assert(!IsIntermediateCodeGenThunk(entryPoint));",
          "3608:     #endif",
          "3609:         if (entryPoint == DefaultDeferredParsingThunk || entryPoint == ProfileDeferredParsingThunk)",
          "3610:         {",
          "3611:             return ProfileDeferredParsingThunk;",
          "3612:         }",
          "3614:         if (entryPoint == DefaultDeferredDeserializeThunk || entryPoint == ProfileDeferredDeserializeThunk)",
          "3615:         {",
          "3616:             return ProfileDeferredDeserializeThunk;",
          "3617:         }",
          "3619:         if (CrossSite::IsThunk(entryPoint))",
          "3620:         {",
          "3621:             return CrossSite::ProfileThunk;",
          "3622:         }",
          "3623:         return ProfileEntryThunk;",
          "3624:     }",
          "3625: #endif // defined(ENABLE_SCRIPT_PROFILING) || defiend(ENABLE_SCRIPT_DEBUGGING)",
          "3627: #if _M_IX86",
          "3628:     __declspec(naked)",
          "3629:         Var ScriptContext::ProfileModeDeferredParsingThunk(RecyclableObject* function, CallInfo callInfo, ...)",
          "3630:     {",
          "3632:             __asm",
          "3633:             {",
          "3634:                 push ebp",
          "3635:                     mov ebp, esp",
          "3636:                     lea eax, [esp + 8]",
          "3637:                     push eax",
          "3638:                     call ScriptContext::ProfileModeDeferredParse",
          "3639: #ifdef _CONTROL_FLOW_GUARD",
          "3641:                     mov  ecx, eax",
          "3642:                     call[__guard_check_icall_fptr]",
          "3643:                     mov eax, ecx",
          "3644: #endif",
          "3645:                     pop ebp",
          "3647:                     jmp eax",
          "3648:             }",
          "3649:     }",
          "3650: #elif defined(_M_X64) || defined(_M_ARM32_OR_ARM64)",
          "3653: #else",
          "3654:     Var ScriptContext::ProfileModeDeferredParsingThunk(RecyclableObject* function, CallInfo callInfo, ...)",
          "3655:     {",
          "3656:         Js::Throw::NotImplemented();",
          "3657:         return nullptr;",
          "3658:     }",
          "3659: #endif",
          "3661:     Js::JavascriptMethod ScriptContext::ProfileModeDeferredParse(ScriptFunction ** functionRef)",
          "3662:     {",
          "3663: #if ENABLE_DEBUG_CONFIG_OPTIONS",
          "3664:         char16 debugStringBuffer[MAX_FUNCTION_BODY_DEBUG_STRING_SIZE];",
          "3665: #endif",
          "3667:         OUTPUT_TRACE(Js::ScriptProfilerPhase, _u(\"ScriptContext::ProfileModeDeferredParse FunctionNumber : %s, startEntrypoint : 0x%08X\\n\"), (*functionRef)->GetFunctionProxy()->GetDebugNumberSet(debugStringBuffer), (*functionRef)->GetEntryPoint());",
          "3669:         BOOL fParsed = FALSE;",
          "3670:         JavascriptMethod entryPoint = Js::JavascriptFunction::DeferredParseCore(functionRef, fParsed);",
          "3672: #ifdef ENABLE_SCRIPT_PROFILING",
          "3673:         OUTPUT_TRACE(Js::ScriptProfilerPhase, _u(\"\\t\\tIsParsed : %s, updatedEntrypoint : 0x%08X\\n\"), IsTrueOrFalse(fParsed), entryPoint);",
          "3676:         FunctionProxy *pRootBody = (*functionRef)->GetFunctionProxy();",
          "3677:         ScriptContext *pScriptContext = pRootBody->GetScriptContext();",
          "3678:         if (pScriptContext->IsProfiling() && !pRootBody->GetFunctionBody()->HasFunctionCompiledSent())",
          "3679:         {",
          "3680:             pScriptContext->RegisterScript(pRootBody, FALSE /*fRegisterScript*/);",
          "3681:         }",
          "3684:         Assert(!pScriptContext->IsProfiling() || (*functionRef)->GetFunctionBody()->GetProfileSession() == pScriptContext->GetProfileSession());",
          "3685: #endif",
          "3687:         return entryPoint;",
          "3688:     }",
          "3690: #if _M_IX86",
          "3691:     __declspec(naked)",
          "3692:         Var ScriptContext::ProfileModeDeferredDeserializeThunk(RecyclableObject* function, CallInfo callInfo, ...)",
          "3693:     {",
          "3695:             __asm",
          "3696:             {",
          "3697:                     push ebp",
          "3698:                     mov ebp, esp",
          "3699:                     push[esp + 8]",
          "3700:                     call ScriptContext::ProfileModeDeferredDeserialize",
          "3701: #ifdef _CONTROL_FLOW_GUARD",
          "3703:                     mov  ecx, eax",
          "3704:                     call[__guard_check_icall_fptr]",
          "3705:                     mov eax, ecx",
          "3706: #endif",
          "3707:                     pop ebp",
          "3709:                     jmp eax",
          "3710:             }",
          "3711:     }",
          "3712: #elif defined(_M_X64) || defined(_M_ARM32_OR_ARM64)",
          "3715: #endif",
          "3717:     Js::JavascriptMethod ScriptContext::ProfileModeDeferredDeserialize(ScriptFunction *function)",
          "3718:     {",
          "3719: #if ENABLE_DEBUG_CONFIG_OPTIONS",
          "3720:         char16 debugStringBuffer[MAX_FUNCTION_BODY_DEBUG_STRING_SIZE];",
          "3721: #endif",
          "3723:         OUTPUT_TRACE(Js::ScriptProfilerPhase, _u(\"ScriptContext::ProfileModeDeferredDeserialize FunctionNumber : %s\\n\"), function->GetFunctionProxy()->GetDebugNumberSet(debugStringBuffer));",
          "3725:         JavascriptMethod entryPoint = Js::JavascriptFunction::DeferredDeserialize(function);",
          "3727: #ifdef ENABLE_SCRIPT_PROFILING",
          "3729:         FunctionProxy *pRootBody = function->GetFunctionProxy();",
          "3730:         ScriptContext *pScriptContext = pRootBody->GetScriptContext();",
          "3731:         if (pScriptContext->IsProfiling() && !pRootBody->GetFunctionBody()->HasFunctionCompiledSent())",
          "3732:         {",
          "3733:             pScriptContext->RegisterScript(pRootBody, FALSE /*fRegisterScript*/);",
          "3734:         }",
          "3737:         Assert(!pScriptContext->IsProfiling() || function->GetFunctionBody()->GetProfileSession() == pScriptContext->GetProfileSession());",
          "3738: #endif",
          "3740:         return entryPoint;",
          "3741:     }",
          "3743: #ifdef ENABLE_SCRIPT_PROFILING",
          "3744:     BOOL ScriptContext::GetProfileInfo(",
          "3745:         JavascriptFunction* function,",
          "3746:         PROFILER_TOKEN &scriptId,",
          "3747:         PROFILER_TOKEN &functionId)",
          "3748:     {",
          "3749:         BOOL fCanProfile = (m_pProfileCallback != nullptr && m_fTraceFunctionCall);",
          "3750:         if (!fCanProfile)",
          "3751:         {",
          "3752:             return FALSE;",
          "3753:         }",
          "3755:         Js::FunctionInfo* functionInfo = function->GetFunctionInfo();",
          "3756:         if (functionInfo->GetAttributes() & FunctionInfo::DoNotProfile)",
          "3757:         {",
          "3758:             return FALSE;",
          "3759:         }",
          "3761:         Js::FunctionBody * functionBody = functionInfo->GetFunctionBody();",
          "3762:         if (functionBody == nullptr)",
          "3763:         {",
          "3764:             functionId = GetFunctionNumber(functionInfo->GetOriginalEntryPoint());",
          "3765:             if (functionId == -1)",
          "3766:             {",
          "3768:                 return m_fTraceDomCall && (m_pProfileCallback2 != nullptr);",
          "3769:             }",
          "3770:             else",
          "3771:             {",
          "3773:                 scriptId = BuiltInFunctionsScriptId;",
          "3774:                 return m_fTraceNativeFunctionCall;",
          "3775:             }",
          "3776:         }",
          "3777:         else if (!functionBody->GetUtf8SourceInfo()->GetIsLibraryCode() || functionBody->IsPublicLibraryCode()) // user script or public library code",
          "3778:         {",
          "3779:             scriptId = (PROFILER_TOKEN)functionBody->GetUtf8SourceInfo()->GetSourceInfoId();",
          "3780:             functionId = functionBody->GetFunctionNumber();",
          "3781:             return TRUE;",
          "3782:         }",
          "3784:         return FALSE;",
          "3785:     }",
          "3786: #endif // ENABLE_SCRIPT_PROFILING",
          "3788:     bool ScriptContext::IsForceNoNative()",
          "3789:     {",
          "3790:         bool forceNoNative = false;",
          "3791:         if (this->IsScriptContextInSourceRundownOrDebugMode())",
          "3792:         {",
          "3793:             forceNoNative = this->IsInterpreted();",
          "3794:         }",
          "3795:         else if (!Js::Configuration::Global.EnableJitInDebugMode())",
          "3796:         {",
          "3797:             forceNoNative = true;",
          "3798:             this->ForceNoNative();",
          "3799:         }",
          "3800:         return forceNoNative;",
          "3801:     }",
          "3803:     void ScriptContext::InitializeDebugging()",
          "3804:     {",
          "3805:         if (!this->IsScriptContextInDebugMode()) // If we already in debug mode, we would have done below changes already.",
          "3806:         {",
          "3807:             this->GetDebugContext()->SetDebuggerMode(Js::DebuggerMode::Debugging);",
          "3808:             if (this->IsScriptContextInDebugMode())",
          "3809:             {",
          "3813:                 this->RegisterDebugThunk(false/*calledDuringAttach*/);",
          "3818:             }",
          "3819:         }",
          "3820:     }",
          "3826:     Var ScriptContext::DebugProfileProbeThunk(RecyclableObject* callable, CallInfo callInfo, ...)",
          "3827:     {",
          "3828: #if defined(ENABLE_SCRIPT_DEBUGGING) || defined(ENABLE_SCRIPT_PROFILING)",
          "3829:         RUNTIME_ARGUMENTS(args, callInfo);",
          "3831:         Assert(!AsmJsScriptFunction::IsWasmScriptFunction(callable));",
          "3832:         JavascriptFunction* function = JavascriptFunction::FromVar(callable);",
          "3833:         ScriptContext* scriptContext = function->GetScriptContext();",
          "3834:         bool functionEnterEventSent = false;",
          "3835:         char16 *pwszExtractedFunctionName = NULL;",
          "3836:         size_t functionNameLen = 0;",
          "3837:         const char16 *pwszFunctionName = NULL;",
          "3838:         HRESULT hrOfEnterEvent = S_OK;",
          "3843: #if defined(ENABLE_SCRIPT_PROFILING)",
          "3844:         PROFILER_TOKEN scriptId = -1;",
          "3845:         PROFILER_TOKEN functionId = -1;",
          "3846:         const bool isProfilingUserCode = scriptContext->GetThreadContext()->IsProfilingUserCode();",
          "3847:         const bool isUserCode = !function->IsLibraryCode();",
          "3849:         const bool fProfile = (isUserCode || isProfilingUserCode) // Only report user code or entry library code",
          "3850:             && scriptContext->GetProfileInfo(function, scriptId, functionId);",
          "3852:         if (fProfile)",
          "3853:         {",
          "3854:             Js::FunctionBody *pBody = function->GetFunctionBody();",
          "3855:             if (pBody != nullptr && !pBody->HasFunctionCompiledSent())",
          "3856:             {",
          "3857:                 pBody->RegisterFunction(false/*changeThunk*/);",
          "3858:             }",
          "3860: #if DEBUG",
          "3861:             { // scope",
          "3863:                 Assert(scriptContext->IsProfiling());",
          "3865:                 if (pBody && pBody->GetProfileSession() != pBody->GetScriptContext()->GetProfileSession())",
          "3866:                 {",
          "3867:                     char16 debugStringBuffer[MAX_FUNCTION_BODY_DEBUG_STRING_SIZE];",
          "3868:                     OUTPUT_TRACE_DEBUGONLY(Js::ScriptProfilerPhase, _u(\"ScriptContext::ProfileProbeThunk, ProfileSession does not match (%d != %d), functionNumber : %s, functionName : %s\\n\"),",
          "3869:                         pBody->GetProfileSession(), pBody->GetScriptContext()->GetProfileSession(), pBody->GetDebugNumberSet(debugStringBuffer), pBody->GetDisplayName());",
          "3870:                 }",
          "3871:                 AssertMsg(pBody == NULL || pBody->GetProfileSession() == pBody->GetScriptContext()->GetProfileSession(), \"Function info wasn't reported for this profile session\");",
          "3872:             }",
          "3873: #endif // DEBUG",
          "3875:             if (functionId == -1)",
          "3876:             {",
          "3877:                 Var sourceString = function->GetSourceString();",
          "3880:                 if (sourceString != NULL)",
          "3881:                 {",
          "3882:                     if (TaggedInt::Is(sourceString))",
          "3883:                     {",
          "3884:                         PropertyId nameId = TaggedInt::ToInt32(sourceString);",
          "3885:                         pwszFunctionName = scriptContext->GetPropertyString(nameId)->GetSz();",
          "3886:                     }",
          "3887:                     else",
          "3888:                     {",
          "3890:                         Assert(JavascriptString::Is(sourceString));",
          "3891:                         const char16 *pwszToString = ((JavascriptString *)sourceString)->GetSz();",
          "3892:                         const char16 *pwszNameStart = wcsstr(pwszToString, _u(\" \"));",
          "3893:                         const char16 *pwszNameEnd = wcsstr(pwszToString, _u(\"(\"));",
          "3894:                         if (pwszNameStart == nullptr || pwszNameEnd == nullptr || ((int)(pwszNameEnd - pwszNameStart) <= 0))",
          "3895:                         {",
          "3896:                             functionNameLen = ((JavascriptString *)sourceString)->GetLength() + 1;",
          "3897:                             pwszExtractedFunctionName = HeapNewArray(char16, functionNameLen);",
          "3898:                             wcsncpy_s(pwszExtractedFunctionName, functionNameLen, pwszToString, _TRUNCATE);",
          "3899:                         }",
          "3900:                         else",
          "3901:                         {",
          "3902:                             functionNameLen = pwszNameEnd - pwszNameStart;",
          "3903:                             AssertMsg(functionNameLen < INT_MAX, \"Allocating array with zero or negative length?\");",
          "3904:                             pwszExtractedFunctionName = HeapNewArray(char16, functionNameLen);",
          "3905:                             wcsncpy_s(pwszExtractedFunctionName, functionNameLen, pwszNameStart + 1, _TRUNCATE);",
          "3906:                         }",
          "3907:                         pwszFunctionName = pwszExtractedFunctionName;",
          "3908:                     }",
          "3910:                     functionEnterEventSent = true;",
          "3911:                     Assert(pwszFunctionName != NULL);",
          "3912:                     hrOfEnterEvent = scriptContext->OnDispatchFunctionEnter(pwszFunctionName);",
          "3913:                 }",
          "3914:             }",
          "3915:             else",
          "3916:             {",
          "3917:                 hrOfEnterEvent = scriptContext->OnFunctionEnter(scriptId, functionId);",
          "3918:             }",
          "3920:             scriptContext->GetThreadContext()->SetIsProfilingUserCode(isUserCode); // Update IsProfilingUserCode state",
          "3921:         }",
          "3922: #endif // ENABLE_SCRIPT_PROFILING",
          "3924:         Var aReturn = NULL;",
          "3925:         JavascriptMethod origEntryPoint = function->GetFunctionInfo()->GetOriginalEntryPoint();",
          "3927:         if (scriptContext->IsEvalRestriction())",
          "3928:         {",
          "3929:             if (origEntryPoint == Js::GlobalObject::EntryEval)",
          "3930:             {",
          "3931:                 origEntryPoint = Js::GlobalObject::EntryEvalRestrictedMode;",
          "3932:             }",
          "3933:             else if (origEntryPoint == Js::JavascriptFunction::NewInstance)",
          "3934:             {",
          "3935:                 origEntryPoint = Js::JavascriptFunction::NewInstanceRestrictedMode;",
          "3936:             }",
          "3937:             else if (origEntryPoint == Js::JavascriptGeneratorFunction::NewInstance)",
          "3938:             {",
          "3939:                 origEntryPoint = Js::JavascriptGeneratorFunction::NewInstanceRestrictedMode;",
          "3940:             }",
          "3941:             else if (origEntryPoint == Js::JavascriptFunction::NewAsyncFunctionInstance)",
          "3942:             {",
          "3943:                 origEntryPoint = Js::JavascriptFunction::NewAsyncFunctionInstanceRestrictedMode;",
          "3944:             }",
          "3945:         }",
          "3948:         __TRY_FINALLY_BEGIN // SEH is not guaranteed, see the implementation",
          "3949:         {",
          "3950:             Assert(!function->IsScriptFunction() || function->GetFunctionProxy());",
          "3955:             bool isDebugWrapperEnabled = scriptContext->IsScriptContextInDebugMode() && IsExceptionWrapperForBuiltInsEnabled(scriptContext);",
          "3956:             bool useDebugWrapper =",
          "3957:                 isDebugWrapperEnabled &&",
          "3958:                 function->IsLibraryCode() &&",
          "3959:                 !AutoRegisterIgnoreExceptionWrapper::IsRegistered(scriptContext->GetThreadContext());",
          "3961:             OUTPUT_VERBOSE_TRACE(Js::DebuggerPhase, _u(\"DebugProfileProbeThunk: calling function: %s isWrapperRegistered=%d useDebugWrapper=%d\\n\"),",
          "3962:                 function->GetFunctionInfo()->HasBody() ? function->GetFunctionBody()->GetDisplayName() : _u(\"built-in/library\"), AutoRegisterIgnoreExceptionWrapper::IsRegistered(scriptContext->GetThreadContext()), useDebugWrapper);",
          "3964:             if (scriptContext->IsScriptContextInDebugMode())",
          "3965:             {",
          "3966:                 scriptContext->GetDebugContext()->GetProbeContainer()->StartRecordingCall();",
          "3967:             }",
          "3969:             if (useDebugWrapper)",
          "3970:             {",
          "3973:                 aReturn = ProfileModeThunk_DebugModeWrapper(function, scriptContext, origEntryPoint, args);",
          "3974:             }",
          "3975:             else",
          "3976:             {",
          "3977:                 if (isDebugWrapperEnabled && !function->IsLibraryCode())",
          "3978:                 {",
          "3983:                     ThreadContext* threadContext = scriptContext->GetThreadContext();",
          "3984:                     bool isOrigWrapperPresent = threadContext->GetDebugManager()->GetDebuggingFlags()->IsBuiltInWrapperPresent();",
          "3985:                     if (isOrigWrapperPresent)",
          "3986:                     {",
          "3987:                         threadContext->GetDebugManager()->GetDebuggingFlags()->SetIsBuiltInWrapperPresent(false);",
          "3988:                     }",
          "3989:                     __TRY_FINALLY_BEGIN // SEH is not guaranteed, see the implementation",
          "3990:                     {",
          "3991:                         aReturn = JavascriptFunction::CallFunction<true>(function, origEntryPoint, args);",
          "3992:                     }",
          "3993:                     __FINALLY",
          "3994:                     {",
          "3995:                         threadContext->GetDebugManager()->GetDebuggingFlags()->SetIsBuiltInWrapperPresent(isOrigWrapperPresent);",
          "3996:                     }",
          "3997:                     __TRY_FINALLY_END",
          "3998:                 }",
          "3999:                 else",
          "4000:                 {",
          "4004:                     aReturn = JavascriptFunction::CallFunction<true>(function, origEntryPoint, args);",
          "4005:                 }",
          "4006:             }",
          "4007:         }",
          "4008:         __FINALLY",
          "4009:         {",
          "4010: #if defined(ENABLE_SCRIPT_PROFILING)",
          "4011:             if (fProfile)",
          "4012:             {",
          "4013:                 if (hrOfEnterEvent != ACTIVPROF_E_PROFILER_ABSENT)",
          "4014:                 {",
          "4015:                     if (functionId == -1)",
          "4016:                     {",
          "4018:                         if (functionEnterEventSent)",
          "4019:                         {",
          "4020:                             scriptContext->OnDispatchFunctionExit(pwszFunctionName);",
          "4021:                             if (pwszExtractedFunctionName != NULL)",
          "4022:                             {",
          "4023:                                 HeapDeleteArray(functionNameLen, pwszExtractedFunctionName);",
          "4024:                             }",
          "4025:                         }",
          "4026:                     }",
          "4027:                     else",
          "4028:                     {",
          "4029:                         scriptContext->OnFunctionExit(scriptId, functionId);",
          "4030:                     }",
          "4031:                 }",
          "4033:                 scriptContext->GetThreadContext()->SetIsProfilingUserCode(isProfilingUserCode); // Restore IsProfilingUserCode state",
          "4034:             }",
          "4035: #endif",
          "4037:             if (scriptContext->IsScriptContextInDebugMode())",
          "4038:             {",
          "4039:                 scriptContext->GetDebugContext()->GetProbeContainer()->EndRecordingCall(aReturn, function);",
          "4040:             }",
          "4041:         }",
          "4042:         __TRY_FINALLY_END",
          "4044:         return aReturn;",
          "4045: #else",
          "4046:         return nullptr;",
          "4047: #endif // defined(ENABLE_SCRIPT_DEBUGGING) || defined(ENABLE_SCRIPT_PROFILING)",
          "4048:     }",
          "4050: #if defined(ENABLE_SCRIPT_DEBUGGING) || defined(ENABLE_SCRIPT_PROFILING)",
          "4052:     Var ScriptContext::ProfileModeThunk_DebugModeWrapper(JavascriptFunction* function, ScriptContext* scriptContext, JavascriptMethod entryPoint, Arguments& args)",
          "4053:     {",
          "4054:         AutoRegisterIgnoreExceptionWrapper autoWrapper(scriptContext->GetThreadContext());",
          "4056:         Var aReturn = HelperOrLibraryMethodWrapper<true>(scriptContext, [=] {",
          "4057:             return JavascriptFunction::CallFunction<true>(function, entryPoint, args);",
          "4058:         });",
          "4060:         return aReturn;",
          "4061:     }",
          "4062: #endif",
          "4064: #ifdef ENABLE_SCRIPT_PROFILING",
          "4065:     HRESULT ScriptContext::OnScriptCompiled(PROFILER_TOKEN scriptId, PROFILER_SCRIPT_TYPE type, IUnknown *pIDebugDocumentContext)",
          "4066:     {",
          "4068:         Assert(m_pProfileCallback != NULL);",
          "4070:         OUTPUT_TRACE(Js::ScriptProfilerPhase, _u(\"ScriptContext::OnScriptCompiled scriptId : %d, ScriptType : %d\\n\"), scriptId, type);",
          "4072:         HRESULT hr = S_OK;",
          "4074:         if ((type == PROFILER_SCRIPT_TYPE_NATIVE && m_fTraceNativeFunctionCall) ||",
          "4075:             (type != PROFILER_SCRIPT_TYPE_NATIVE && m_fTraceFunctionCall))",
          "4076:         {",
          "4077:             m_inProfileCallback = TRUE;",
          "4078:             hr = m_pProfileCallback->ScriptCompiled(scriptId, type, pIDebugDocumentContext);",
          "4079:             m_inProfileCallback = FALSE;",
          "4080:         }",
          "4081:         return hr;",
          "4082:     }",
          "4084:     HRESULT ScriptContext::OnFunctionCompiled(",
          "4085:         PROFILER_TOKEN functionId,",
          "4086:         PROFILER_TOKEN scriptId,",
          "4087:         const WCHAR *pwszFunctionName,",
          "4088:         const WCHAR *pwszFunctionNameHint,",
          "4089:         IUnknown *pIDebugDocumentContext)",
          "4090:     {",
          "4091:         Assert(m_pProfileCallback != NULL);",
          "4093: #ifdef ENABLE_DEBUG_CONFIG_OPTIONS",
          "4094:         if (scriptId != BuiltInFunctionsScriptId || Js::Configuration::Global.flags.Verbose)",
          "4095:         {",
          "4096:             OUTPUT_TRACE(Js::ScriptProfilerPhase, _u(\"ScriptContext::OnFunctionCompiled scriptId : %d, functionId : %d, FunctionName : %s, FunctionNameHint : %s\\n\"), scriptId, functionId, pwszFunctionName, pwszFunctionNameHint);",
          "4097:         }",
          "4098: #endif",
          "4100:         HRESULT hr = S_OK;",
          "4102:         if ((scriptId == BuiltInFunctionsScriptId && m_fTraceNativeFunctionCall) ||",
          "4103:             (scriptId != BuiltInFunctionsScriptId && m_fTraceFunctionCall))",
          "4104:         {",
          "4105:             m_inProfileCallback = TRUE;",
          "4106:             hr = m_pProfileCallback->FunctionCompiled(functionId, scriptId, pwszFunctionName, pwszFunctionNameHint, pIDebugDocumentContext);",
          "4107:             m_inProfileCallback = FALSE;",
          "4108:         }",
          "4109:         return hr;",
          "4110:     }",
          "4112:     HRESULT ScriptContext::OnFunctionEnter(PROFILER_TOKEN scriptId, PROFILER_TOKEN functionId)",
          "4113:     {",
          "4114:         if (m_pProfileCallback == NULL)",
          "4115:         {",
          "4116:             return ACTIVPROF_E_PROFILER_ABSENT;",
          "4117:         }",
          "4119:         OUTPUT_VERBOSE_TRACE(Js::ScriptProfilerPhase, _u(\"ScriptContext::OnFunctionEnter scriptId : %d, functionId : %d\\n\"), scriptId, functionId);",
          "4121:         HRESULT hr = S_OK;",
          "4123:         if ((scriptId == BuiltInFunctionsScriptId && m_fTraceNativeFunctionCall) ||",
          "4124:             (scriptId != BuiltInFunctionsScriptId && m_fTraceFunctionCall))",
          "4125:         {",
          "4126:             m_inProfileCallback = TRUE;",
          "4127:             hr = m_pProfileCallback->OnFunctionEnter(scriptId, functionId);",
          "4128:             m_inProfileCallback = FALSE;",
          "4129:         }",
          "4130:         return hr;",
          "4131:     }",
          "4133:     HRESULT ScriptContext::OnFunctionExit(PROFILER_TOKEN scriptId, PROFILER_TOKEN functionId)",
          "4134:     {",
          "4135:         if (m_pProfileCallback == NULL)",
          "4136:         {",
          "4137:             return ACTIVPROF_E_PROFILER_ABSENT;",
          "4138:         }",
          "4140:         OUTPUT_VERBOSE_TRACE(Js::ScriptProfilerPhase, _u(\"ScriptContext::OnFunctionExit scriptId : %d, functionId : %d\\n\"), scriptId, functionId);",
          "4142:         HRESULT hr = S_OK;",
          "4144:         if ((scriptId == BuiltInFunctionsScriptId && m_fTraceNativeFunctionCall) ||",
          "4145:             (scriptId != BuiltInFunctionsScriptId && m_fTraceFunctionCall))",
          "4146:         {",
          "4147:             m_inProfileCallback = TRUE;",
          "4148:             hr = m_pProfileCallback->OnFunctionExit(scriptId, functionId);",
          "4149:             m_inProfileCallback = FALSE;",
          "4150:         }",
          "4151:         return hr;",
          "4152:     }",
          "4154:     HRESULT ScriptContext::FunctionExitSenderThunk(PROFILER_TOKEN functionId, PROFILER_TOKEN scriptId, ScriptContext *pScriptContext)",
          "4155:     {",
          "4156:         return pScriptContext->OnFunctionExit(scriptId, functionId);",
          "4157:     }",
          "4159:     HRESULT ScriptContext::FunctionExitByNameSenderThunk(const char16 *pwszFunctionName, ScriptContext *pScriptContext)",
          "4160:     {",
          "4161:         return pScriptContext->OnDispatchFunctionExit(pwszFunctionName);",
          "4162:     }",
          "4163: #endif // ENABLE_SCRIPT_PROFILING",
          "4165:     Js::PropertyId ScriptContext::GetFunctionNumber(JavascriptMethod entryPoint)",
          "4166:     {",
          "4167:         return (m_pBuiltinFunctionIdMap == NULL) ? -1 : m_pBuiltinFunctionIdMap->Lookup(entryPoint, -1);",
          "4168:     }",
          "4170:     HRESULT ScriptContext::RegisterLibraryFunction(const char16 *pwszObjectName, const char16 *pwszFunctionName, Js::PropertyId functionPropertyId, JavascriptMethod entryPoint)",
          "4171:     {",
          "4172: #if defined(ENABLE_SCRIPT_PROFILING)",
          "4173: #if DEBUG",
          "4174:         const char16 *pwszObjectNameFromProperty = const_cast<char16 *>(GetPropertyName(functionPropertyId)->GetBuffer());",
          "4175:         if (GetPropertyName(functionPropertyId)->IsSymbol())",
          "4176:         {",
          "4179:             Assert(!wcsncmp(pwszFunctionName + 1, pwszObjectNameFromProperty, wcslen(pwszObjectNameFromProperty)));",
          "4180:             Assert(wcslen(pwszFunctionName) == wcslen(pwszObjectNameFromProperty) + 2);",
          "4181:         }",
          "4182:         else",
          "4183:         {",
          "4184:             Assert(!wcscmp(pwszFunctionName, pwszObjectNameFromProperty));",
          "4185:         }",
          "4186:         Assert(m_pBuiltinFunctionIdMap != NULL);",
          "4187: #endif",
          "4192:         char16 szTempName[70];",
          "4193:         if (pwszObjectName != NULL)",
          "4194:         {",
          "4196:             swprintf_s(szTempName, 70, _u(\"%s.%s\"), pwszObjectName, pwszFunctionName);",
          "4197:             functionPropertyId = GetOrAddPropertyIdTracked(szTempName, (uint)wcslen(szTempName));",
          "4198:         }",
          "4200:         Js::PropertyId cachedFunctionId;",
          "4201:         bool keyFound = m_pBuiltinFunctionIdMap->TryGetValue(entryPoint, &cachedFunctionId);",
          "4203:         if (keyFound)",
          "4204:         {",
          "4206:             if (cachedFunctionId != functionPropertyId)",
          "4207:             {",
          "4211:                 return S_OK;",
          "4212:             }",
          "4215:         }",
          "4216:         else",
          "4217:         {",
          "4218: #if DBG",
          "4219:             m_pBuiltinFunctionIdMap->MapUntil([&](JavascriptMethod, Js::PropertyId propertyId) -> bool",
          "4220:             {",
          "4221:                 if (functionPropertyId == propertyId)",
          "4222:                 {",
          "4223:                     Assert(false);",
          "4224:                     return true;",
          "4225:                 }",
          "4226:                 return false;",
          "4227:             });",
          "4228: #endif",
          "4231:             m_pBuiltinFunctionIdMap->Add(entryPoint, functionPropertyId);",
          "4232:         }",
          "4235:         if (pwszObjectName != NULL)",
          "4236:         {",
          "4237:             return OnFunctionCompiled(functionPropertyId, BuiltInFunctionsScriptId, szTempName, NULL, NULL);",
          "4238:         }",
          "4239:         else",
          "4240:         {",
          "4241:             return OnFunctionCompiled(functionPropertyId, BuiltInFunctionsScriptId, pwszFunctionName, NULL, NULL);",
          "4242:         }",
          "4243: #else",
          "4244:         return S_OK;",
          "4245: #endif // ENABLE_SCRIPT_PROFILING",
          "4246:     }",
          "4248:     void ScriptContext::BindReference(void * addr)",
          "4249:     {",
          "4250:         Assert(!this->isClosed);",
          "4251:         Assert(this->guestArena);",
          "4252:         Assert(recycler->IsValidObject(addr));",
          "4253: #if DBG",
          "4254:         Assert(!bindRef.ContainsKey(addr));     // Make sure we don't bind the same pointer twice",
          "4255:         bindRef.AddNew(addr);",
          "4256: #endif",
          "4257:         javascriptLibrary->BindReference(addr);",
          "4259: #ifdef RECYCLER_PERF_COUNTERS",
          "4260:         this->bindReferenceCount++;",
          "4261:         RECYCLER_PERF_COUNTER_INC(BindReference);",
          "4262: #endif",
          "4263:     }",
          "4265: #ifdef PROFILE_STRINGS",
          "4266:     StringProfiler* ScriptContext::GetStringProfiler()",
          "4267:     {",
          "4268:         return stringProfiler;",
          "4269:     }",
          "4270: #endif",
          "4272:     void ScriptContext::FreeFunctionEntryPoint(Js::JavascriptMethod method)",
          "4273:     {",
          "4274: #if ENABLE_NATIVE_CODEGEN",
          "4275:         FreeNativeCodeGenAllocation(this, method);",
          "4276: #endif",
          "4277:     }",
          "4279:     void ScriptContext::RegisterProtoInlineCache(InlineCache *pCache, PropertyId propId)",
          "4280:     {",
          "4281:         hasProtoOrStoreFieldInlineCache = true;",
          "4282:         threadContext->RegisterProtoInlineCache(pCache, propId);",
          "4283:     }",
          "4285:     void ScriptContext::InvalidateProtoCaches(const PropertyId propertyId)",
          "4286:     {",
          "4287:         threadContext->InvalidateProtoInlineCaches(propertyId);",
          "4290:         threadContext->InvalidateStoreFieldInlineCaches(propertyId);",
          "4291: #if ENABLE_NATIVE_CODEGEN",
          "4292:         threadContext->InvalidatePropertyGuards(propertyId);",
          "4293: #endif",
          "4294:         threadContext->InvalidateProtoTypePropertyCaches(propertyId);",
          "4295:     }",
          "4297:     void ScriptContext::InvalidateAllProtoCaches()",
          "4298:     {",
          "4299:         threadContext->InvalidateAllProtoInlineCaches();",
          "4302:         threadContext->InvalidateAllStoreFieldInlineCaches();",
          "4303: #if ENABLE_NATIVE_CODEGEN",
          "4304:         threadContext->InvalidateAllPropertyGuards();",
          "4305: #endif",
          "4306:         threadContext->InvalidateAllProtoTypePropertyCaches();",
          "4307:     }",
          "4309:     void ScriptContext::RegisterStoreFieldInlineCache(InlineCache *pCache, PropertyId propId)",
          "4310:     {",
          "4311:         hasProtoOrStoreFieldInlineCache = true;",
          "4312:         threadContext->RegisterStoreFieldInlineCache(pCache, propId);",
          "4313:     }",
          "4315:     void ScriptContext::InvalidateStoreFieldCaches(const PropertyId propertyId)",
          "4316:     {",
          "4317:         threadContext->InvalidateStoreFieldInlineCaches(propertyId);",
          "4318: #if ENABLE_NATIVE_CODEGEN",
          "4319:         threadContext->InvalidatePropertyGuards(propertyId);",
          "4320: #endif",
          "4321:     }",
          "4323:     void ScriptContext::InvalidateAllStoreFieldCaches()",
          "4324:     {",
          "4325:         threadContext->InvalidateAllStoreFieldInlineCaches();",
          "4326:     }",
          "4328:     void ScriptContext::RegisterIsInstInlineCache(Js::IsInstInlineCache * cache, Js::Var function)",
          "4329:     {",
          "4330:         Assert(JavascriptFunction::FromVar(function)->GetScriptContext() == this);",
          "4331:         hasIsInstInlineCache = true;",
          "4332:         threadContext->RegisterIsInstInlineCache(cache, function);",
          "4333:     }",
          "4335: #if DBG",
          "4336:     bool ScriptContext::IsIsInstInlineCacheRegistered(Js::IsInstInlineCache * cache, Js::Var function)",
          "4337:     {",
          "4338:         return threadContext->IsIsInstInlineCacheRegistered(cache, function);",
          "4339:     }",
          "4340: #endif",
          "4342:     void ScriptContext::CleanSourceListInternal(bool calledDuringMark)",
          "4343:     {",
          "4344:         bool fCleanupDocRequired = false;",
          "4345:         for (int i = 0; i < sourceList->Count(); i++)",
          "4346:         {",
          "4347:             if (this->sourceList->IsItemValid(i))",
          "4348:             {",
          "4349:                 RecyclerWeakReference<Utf8SourceInfo>* sourceInfoWeakRef = this->sourceList->Item(i);",
          "4350:                 Utf8SourceInfo* strongRef = nullptr;",
          "4352:                 if (calledDuringMark)",
          "4353:                 {",
          "4354:                     strongRef = sourceInfoWeakRef->FastGet();",
          "4355:                 }",
          "4356:                 else",
          "4357:                 {",
          "4358:                     strongRef = sourceInfoWeakRef->Get();",
          "4359:                 }",
          "4361:                 if (strongRef == nullptr)",
          "4362:                 {",
          "4363:                     this->sourceList->RemoveAt(i);",
          "4364:                     fCleanupDocRequired = true;",
          "4365:                 }",
          "4366:             }",
          "4367:         }",
          "4369: #ifdef ENABLE_SCRIPT_PROFILING",
          "4371:         if (fCleanupDocRequired && m_pProfileCallback != NULL)",
          "4372:         {",
          "4373:             Assert(CleanupDocumentContext != NULL);",
          "4374:             CleanupDocumentContext(this);",
          "4375:         }",
          "4376: #endif // ENABLE_SCRIPT_PROFILING",
          "4377:     }",
          "4379:     void ScriptContext::ClearScriptContextCaches()",
          "4380:     {",
          "4383:         if (this->isPerformingNonreentrantWork || !this->hasUsedInlineCache)",
          "4384:         {",
          "4385:             return;",
          "4386:         }",
          "4388:         class AutoCleanup",
          "4389:         {",
          "4390:         private:",
          "4391:             ScriptContext *const scriptContext;",
          "4393:         public:",
          "4394:             AutoCleanup(ScriptContext *const scriptContext) : scriptContext(scriptContext)",
          "4395:             {",
          "4396:                 scriptContext->isPerformingNonreentrantWork = true;",
          "4397:             }",
          "4399:             ~AutoCleanup()",
          "4400:             {",
          "4401:                 scriptContext->isPerformingNonreentrantWork = false;",
          "4402:             }",
          "4403:         } autoCleanup(this);",
          "4405:         if (this->isScriptContextActuallyClosed)",
          "4406:         {",
          "4407:             return;",
          "4408:         }",
          "4409:         Assert(this->guestArena);",
          "4411:         if (EnableEvalMapCleanup())",
          "4412:         {",
          "4415:             if (!this->IsScriptContextInDebugMode())",
          "4416:             {",
          "4417:                 if (this->Cache()->evalCacheDictionary != nullptr)",
          "4418:                 {",
          "4419:                     this->CleanDynamicFunctionCache<Js::EvalCacheTopLevelDictionary>(this->Cache()->evalCacheDictionary->GetDictionary());",
          "4420:                 }",
          "4421:                 if (this->Cache()->indirectEvalCacheDictionary != nullptr)",
          "4422:                 {",
          "4423:                     this->CleanDynamicFunctionCache<Js::EvalCacheTopLevelDictionary>(this->Cache()->indirectEvalCacheDictionary->GetDictionary());",
          "4424:                 }",
          "4425:                 if (this->Cache()->newFunctionCache != nullptr)",
          "4426:                 {",
          "4427:                     this->CleanDynamicFunctionCache<Js::NewFunctionCache>(this->Cache()->newFunctionCache);",
          "4428:                 }",
          "4429:                 if (this->hostScriptContext != nullptr)",
          "4430:                 {",
          "4431:                     this->hostScriptContext->CleanDynamicCodeCache();",
          "4432:                 }",
          "4434:             }",
          "4435:         }",
          "4437:         if (REGEX_CONFIG_FLAG(DynamicRegexMruListSize) > 0)",
          "4438:         {",
          "4439:             GetDynamicRegexMap()->RemoveRecentlyUnusedItems();",
          "4440:         }",
          "4442:         CleanSourceListInternal(true);",
          "4443:     }",
          "4445: void ScriptContext::ClearInlineCaches()",
          "4446: {",
          "4447:     if (this->hasUsedInlineCache)",
          "4448:     {",
          "4449:         GetInlineCacheAllocator()->ZeroAll();",
          "4450:         this->hasUsedInlineCache = false;",
          "4451:         this->hasProtoOrStoreFieldInlineCache = false;",
          "4452:     }",
          "4454:     Assert(GetInlineCacheAllocator()->IsAllZero());",
          "4455: }",
          "4457: void ScriptContext::ClearIsInstInlineCaches()",
          "4458: {",
          "4459:     if (this->hasIsInstInlineCache)",
          "4460:     {",
          "4461:         GetIsInstInlineCacheAllocator()->ZeroAll();",
          "4462:         this->hasIsInstInlineCache = false;",
          "4463:     }",
          "4465:     Assert(GetIsInstInlineCacheAllocator()->IsAllZero());",
          "4466: }",
          "4468: void ScriptContext::ClearForInCaches()",
          "4469: {",
          "4470:     ForInCacheAllocator()->ZeroAll();",
          "4471:     Assert(ForInCacheAllocator()->IsAllZero());",
          "4472: }",
          "4475: #ifdef PERSISTENT_INLINE_CACHES",
          "4476: void ScriptContext::ClearInlineCachesWithDeadWeakRefs()",
          "4477: {",
          "4478:     if (this->hasUsedInlineCache)",
          "4479:     {",
          "4480:         GetInlineCacheAllocator()->ClearCachesWithDeadWeakRefs(this->recycler);",
          "4481:         Assert(GetInlineCacheAllocator()->HasNoDeadWeakRefs(this->recycler));",
          "4482:     }",
          "4483: }",
          "4484: #endif",
          "4486: #if ENABLE_NATIVE_CODEGEN",
          "4487: void ScriptContext::RegisterConstructorCache(Js::PropertyId propertyId, Js::ConstructorCache* cache)",
          "4488: {",
          "4489:     this->threadContext->RegisterConstructorCache(propertyId, cache);",
          "4490: }",
          "4491: #endif",
          "4493: JITPageAddrToFuncRangeCache *",
          "4494: ScriptContext::GetJitFuncRangeCache()",
          "4495: {",
          "4496:     return jitFuncRangeCache;",
          "4497: }",
          "4499: void ScriptContext::RegisterPrototypeChainEnsuredToHaveOnlyWritableDataPropertiesScriptContext()",
          "4500: {",
          "4501:     Assert(!IsClosed());",
          "4503:     if (registeredPrototypeChainEnsuredToHaveOnlyWritableDataPropertiesScriptContext == nullptr)",
          "4504:     {",
          "4505:         DoRegisterPrototypeChainEnsuredToHaveOnlyWritableDataPropertiesScriptContext();",
          "4506:     }",
          "4507: }",
          "4509:     void ScriptContext::DoRegisterPrototypeChainEnsuredToHaveOnlyWritableDataPropertiesScriptContext()",
          "4510:     {",
          "4511:         Assert(!IsClosed());",
          "4512:         Assert(registeredPrototypeChainEnsuredToHaveOnlyWritableDataPropertiesScriptContext == nullptr);",
          "4515:         registeredPrototypeChainEnsuredToHaveOnlyWritableDataPropertiesScriptContext = threadContext->RegisterPrototypeChainEnsuredToHaveOnlyWritableDataPropertiesScriptContext(this);",
          "4516:     }",
          "4518:     void ScriptContext::ClearPrototypeChainEnsuredToHaveOnlyWritableDataPropertiesCaches()",
          "4519:     {",
          "4520:         Assert(registeredPrototypeChainEnsuredToHaveOnlyWritableDataPropertiesScriptContext != nullptr);",
          "4521:         if (!isFinalized)",
          "4522:         {",
          "4523:             javascriptLibrary->NoPrototypeChainsAreEnsuredToHaveOnlyWritableDataProperties();",
          "4524:         }",
          "4527:         registeredPrototypeChainEnsuredToHaveOnlyWritableDataPropertiesScriptContext = nullptr;",
          "4528:     }",
          "4530:     JavascriptString * ScriptContext::GetLastNumberToStringRadix10(double value)",
          "4531:     {",
          "4532:         if (value == lastNumberToStringRadix10)",
          "4533:         {",
          "4534:             return Cache()->lastNumberToStringRadix10String;",
          "4535:         }",
          "4536:         return nullptr;",
          "4537:     }",
          "4539:     void",
          "4540:         ScriptContext::SetLastNumberToStringRadix10(double value, JavascriptString * str)",
          "4541:     {",
          "4542:             lastNumberToStringRadix10 = value;",
          "4543:             Cache()->lastNumberToStringRadix10String = str;",
          "4544:     }",
          "4546:     bool ScriptContext::GetLastUtcTimeFromStr(JavascriptString * str, double& dbl)",
          "4547:     {",
          "4548:         Assert(str != nullptr);",
          "4549:         if (str != Cache()->lastUtcTimeFromStrString)",
          "4550:         {",
          "4551:             if (Cache()->lastUtcTimeFromStrString == nullptr",
          "4552:                 || !JavascriptString::Equals(str, Cache()->lastUtcTimeFromStrString))",
          "4553:             {",
          "4554:                 return false;",
          "4555:             }",
          "4556:         }",
          "4557:         dbl = lastUtcTimeFromStr;",
          "4558:         return true;",
          "4559:     }",
          "4561:     void",
          "4562:     ScriptContext::SetLastUtcTimeFromStr(JavascriptString * str, double value)",
          "4563:     {",
          "4564:             lastUtcTimeFromStr = value;",
          "4565:             Cache()->lastUtcTimeFromStrString = str;",
          "4566:     }",
          "4568: #if ENABLE_NATIVE_CODEGEN",
          "4569:     BOOL ScriptContext::IsNativeAddress(void * codeAddr)",
          "4570:     {",
          "4571:         return this->GetThreadContext()->IsNativeAddress(codeAddr, this);",
          "4572:     }",
          "4573: #endif",
          "4575:     bool ScriptContext::SetDispatchProfile(bool fSet, JavascriptMethod dispatchInvoke)",
          "4576:     {",
          "4577:         if (!fSet)",
          "4578:         {",
          "4579:             this->javascriptLibrary->SetDispatchProfile(false, dispatchInvoke);",
          "4580:             return true;",
          "4581:         }",
          "4582: #ifdef ENABLE_SCRIPT_PROFILING",
          "4583:         else if (m_fTraceDomCall)",
          "4584:         {",
          "4585:             this->javascriptLibrary->SetDispatchProfile(true, dispatchInvoke);",
          "4586:             return true;",
          "4587:         }",
          "4588: #endif // ENABLE_SCRIPT_PROFILING",
          "4590:         return false;",
          "4591:     }",
          "4593: #ifdef ENABLE_SCRIPT_PROFILING",
          "4594:     HRESULT ScriptContext::OnDispatchFunctionEnter(const WCHAR *pwszFunctionName)",
          "4595:     {",
          "4596:         if (m_pProfileCallback2 == NULL)",
          "4597:         {",
          "4598:             return ACTIVPROF_E_PROFILER_ABSENT;",
          "4599:         }",
          "4601:         HRESULT hr = S_OK;",
          "4603:         if (m_fTraceDomCall)",
          "4604:         {",
          "4605:             m_inProfileCallback = TRUE;",
          "4606:             hr = m_pProfileCallback2->OnFunctionEnterByName(pwszFunctionName, PROFILER_SCRIPT_TYPE_DOM);",
          "4607:             m_inProfileCallback = FALSE;",
          "4608:         }",
          "4609:         return hr;",
          "4610:     }",
          "4612:     HRESULT ScriptContext::OnDispatchFunctionExit(const WCHAR *pwszFunctionName)",
          "4613:     {",
          "4614:         if (m_pProfileCallback2 == NULL)",
          "4615:         {",
          "4616:             return ACTIVPROF_E_PROFILER_ABSENT;",
          "4617:         }",
          "4619:         HRESULT hr = S_OK;",
          "4621:         if (m_fTraceDomCall)",
          "4622:         {",
          "4623:             m_inProfileCallback = TRUE;",
          "4624:             hr = m_pProfileCallback2->OnFunctionExitByName(pwszFunctionName, PROFILER_SCRIPT_TYPE_DOM);",
          "4625:             m_inProfileCallback = FALSE;",
          "4626:         }",
          "4627:         return hr;",
          "4628:     }",
          "4629: #endif // ENABLE_SCRIPT_PROFILING",
          "4631:     void ScriptContext::SetBuiltInLibraryFunction(JavascriptMethod entryPoint, JavascriptFunction* function)",
          "4632:     {",
          "4633:         if (!isClosed)",
          "4634:         {",
          "4635:             if (builtInLibraryFunctions == NULL)",
          "4636:             {",
          "4637:                 Assert(this->recycler);",
          "4639:                 builtInLibraryFunctions = RecyclerNew(this->recycler, BuiltInLibraryFunctionMap, this->recycler);",
          "4640:                 Cache()->builtInLibraryFunctions = builtInLibraryFunctions;",
          "4641:             }",
          "4643:             builtInLibraryFunctions->Item(entryPoint, function);",
          "4644:         }",
          "4645:     }",
          "4647: #if ENABLE_NATIVE_CODEGEN",
          "4648:     void ScriptContext::InitializeRemoteScriptContext()",
          "4649:     {",
          "4650:         Assert(JITManager::GetJITManager()->IsOOPJITEnabled());",
          "4652:         if (!JITManager::GetJITManager()->IsConnected())",
          "4653:         {",
          "4654:             return;",
          "4655:         }",
          "4656:         ScriptContextDataIDL contextData;",
          "4657:         contextData.nullAddr = (intptr_t)GetLibrary()->GetNull();",
          "4658:         contextData.undefinedAddr = (intptr_t)GetLibrary()->GetUndefined();",
          "4659:         contextData.trueAddr = (intptr_t)GetLibrary()->GetTrue();",
          "4660:         contextData.falseAddr = (intptr_t)GetLibrary()->GetFalse();",
          "4661:         contextData.undeclBlockVarAddr = (intptr_t)GetLibrary()->GetUndeclBlockVar();",
          "4662:         contextData.scriptContextAddr = (intptr_t)this;",
          "4663:         contextData.emptyStringAddr = (intptr_t)GetLibrary()->GetEmptyString();",
          "4664:         contextData.negativeZeroAddr = (intptr_t)GetLibrary()->GetNegativeZero();",
          "4665:         contextData.numberTypeStaticAddr = (intptr_t)GetLibrary()->GetNumberTypeStatic();",
          "4666:         contextData.stringTypeStaticAddr = (intptr_t)GetLibrary()->GetStringTypeStatic();",
          "4667:         contextData.objectTypeAddr = (intptr_t)GetLibrary()->GetObjectType();",
          "4668:         contextData.objectHeaderInlinedTypeAddr = (intptr_t)GetLibrary()->GetObjectHeaderInlinedType();",
          "4669:         contextData.regexTypeAddr = (intptr_t)GetLibrary()->GetRegexType();",
          "4670:         contextData.arrayConstructorAddr = (intptr_t)GetLibrary()->GetArrayConstructor();",
          "4671:         contextData.arrayTypeAddr = (intptr_t)GetLibrary()->GetArrayType();",
          "4672:         contextData.nativeIntArrayTypeAddr = (intptr_t)GetLibrary()->GetNativeIntArrayType();",
          "4673:         contextData.nativeFloatArrayTypeAddr = (intptr_t)GetLibrary()->GetNativeFloatArrayType();",
          "4674:         contextData.charStringCacheAddr = (intptr_t)&GetLibrary()->GetCharStringCache();",
          "4675:         contextData.libraryAddr = (intptr_t)GetLibrary();",
          "4676:         contextData.globalObjectAddr = (intptr_t)GetLibrary()->GetGlobalObject();",
          "4677:         contextData.builtinFunctionsBaseAddr = (intptr_t)GetLibrary()->GetBuiltinFunctions();",
          "4678:         contextData.sideEffectsAddr = optimizationOverrides.GetAddressOfSideEffects();",
          "4679:         contextData.arraySetElementFastPathVtableAddr = (intptr_t)optimizationOverrides.GetAddressOfArraySetElementFastPathVtable();",
          "4680:         contextData.intArraySetElementFastPathVtableAddr = (intptr_t)optimizationOverrides.GetAddressOfIntArraySetElementFastPathVtable();",
          "4681:         contextData.floatArraySetElementFastPathVtableAddr = (intptr_t)optimizationOverrides.GetAddressOfFloatArraySetElementFastPathVtable();",
          "4682:         contextData.recyclerAddr = (intptr_t)GetRecycler();",
          "4683:         contextData.recyclerAllowNativeCodeBumpAllocation = GetRecycler()->AllowNativeCodeBumpAllocation();",
          "4684:         contextData.numberAllocatorAddr = (intptr_t)GetNumberAllocator();",
          "4685: #ifdef RECYCLER_MEMORY_VERIFY",
          "4686:         contextData.isRecyclerVerifyEnabled = (boolean)recycler->VerifyEnabled();",
          "4687:         contextData.recyclerVerifyPad = recycler->GetVerifyPad();",
          "4688: #else",
          "4690:         contextData.isRecyclerVerifyEnabled = FALSE;",
          "4691:         contextData.recyclerVerifyPad = 0;",
          "4692: #endif",
          "4693:         contextData.debuggingFlagsAddr = GetDebuggingFlagsAddr();",
          "4694:         contextData.debugStepTypeAddr = GetDebugStepTypeAddr();",
          "4695:         contextData.debugFrameAddressAddr = GetDebugFrameAddressAddr();",
          "4696:         contextData.debugScriptIdWhenSetAddr = GetDebugScriptIdWhenSetAddr();",
          "4698:         contextData.numberAllocatorAddr = (intptr_t)GetNumberAllocator();",
          "4699:         contextData.isSIMDEnabled = GetConfig()->IsSimdjsEnabled();",
          "4700:         CompileAssert(VTableValue::Count == VTABLE_COUNT); // need to update idl when this changes",
          "4702:         auto vtblAddresses = GetLibrary()->GetVTableAddresses();",
          "4703:         for (unsigned int i = 0; i < VTableValue::Count; i++)",
          "4704:         {",
          "4705:             contextData.vtableAddresses[i] = vtblAddresses[i];",
          "4706:         }",
          "4708:         bool allowPrereserveAlloc = true;",
          "4709: #if !_M_X64_OR_ARM64",
          "4710:         if (this->webWorkerId != Js::Constants::NonWebWorkerContextId)",
          "4711:         {",
          "4712:             allowPrereserveAlloc = false;",
          "4713:         }",
          "4714: #endif",
          "4715: #ifndef _CONTROL_FLOW_GUARD",
          "4716:         allowPrereserveAlloc = false;",
          "4717: #endif",
          "4719:         if (this->GetThreadContext()->EnsureJITThreadContext(allowPrereserveAlloc))",
          "4720:         {",
          "4721:             HRESULT hr = JITManager::GetJITManager()->InitializeScriptContext(&contextData, this->GetThreadContext()->GetRemoteThreadContextAddr(), &m_remoteScriptContextAddr);",
          "4722:             JITManager::HandleServerCallResult(hr, RemoteCallType::StateUpdate);",
          "4723:         }",
          "4724:     }",
          "4725: #endif",
          "4727:     intptr_t ScriptContext::GetNullAddr() const",
          "4728:     {",
          "4729:         return (intptr_t)GetLibrary()->GetNull();",
          "4730:     }",
          "4732:     intptr_t ScriptContext::GetUndefinedAddr() const",
          "4733:     {",
          "4734:         return (intptr_t)GetLibrary()->GetUndefined();",
          "4735:     }",
          "4737:     intptr_t ScriptContext::GetTrueAddr() const",
          "4738:     {",
          "4739:         return (intptr_t)GetLibrary()->GetTrue();",
          "4740:     }",
          "4742:     intptr_t ScriptContext::GetFalseAddr() const",
          "4743:     {",
          "4744:         return (intptr_t)GetLibrary()->GetFalse();",
          "4745:     }",
          "4747:     intptr_t ScriptContext::GetUndeclBlockVarAddr() const",
          "4748:     {",
          "4749:         return (intptr_t)GetLibrary()->GetUndeclBlockVar();",
          "4750:     }",
          "4752:     intptr_t ScriptContext::GetEmptyStringAddr() const",
          "4753:     {",
          "4754:         return (intptr_t)GetLibrary()->GetEmptyString();",
          "4755:     }",
          "4757:     intptr_t ScriptContext::GetNegativeZeroAddr() const",
          "4758:     {",
          "4759:         return (intptr_t)GetLibrary()->GetNegativeZero();",
          "4760:     }",
          "4762:     intptr_t ScriptContext::GetNumberTypeStaticAddr() const",
          "4763:     {",
          "4764:         return (intptr_t)GetLibrary()->GetNumberTypeStatic();",
          "4765:     }",
          "4767:     intptr_t ScriptContext::GetStringTypeStaticAddr() const",
          "4768:     {",
          "4769:         return (intptr_t)GetLibrary()->GetStringTypeStatic();",
          "4770:     }",
          "4772:     intptr_t ScriptContext::GetObjectTypeAddr() const",
          "4773:     {",
          "4774:         return (intptr_t)GetLibrary()->GetObjectType();",
          "4775:     }",
          "4777:     intptr_t ScriptContext::GetObjectHeaderInlinedTypeAddr() const",
          "4778:     {",
          "4779:         return (intptr_t)GetLibrary()->GetObjectHeaderInlinedType();",
          "4780:     }",
          "4782:     intptr_t ScriptContext::GetRegexTypeAddr() const",
          "4783:     {",
          "4784:         return (intptr_t)GetLibrary()->GetRegexType();",
          "4785:     }",
          "4787:     intptr_t ScriptContext::GetArrayTypeAddr() const",
          "4788:     {",
          "4789:         return (intptr_t)GetLibrary()->GetArrayType();",
          "4790:     }",
          "4792:     intptr_t ScriptContext::GetNativeIntArrayTypeAddr() const",
          "4793:     {",
          "4794:         return (intptr_t)GetLibrary()->GetNativeIntArrayType();",
          "4795:     }",
          "4797:     intptr_t ScriptContext::GetNativeFloatArrayTypeAddr() const",
          "4798:     {",
          "4799:         return (intptr_t)GetLibrary()->GetNativeFloatArrayType();",
          "4800:     }",
          "4802:     intptr_t ScriptContext::GetArrayConstructorAddr() const",
          "4803:     {",
          "4804:         return (intptr_t)GetLibrary()->GetArrayConstructor();",
          "4805:     }",
          "4807:     intptr_t ScriptContext::GetCharStringCacheAddr() const",
          "4808:     {",
          "4809:         return (intptr_t)&GetLibrary()->GetCharStringCache();",
          "4810:     }",
          "4812:     intptr_t ScriptContext::GetSideEffectsAddr() const",
          "4813:     {",
          "4814:         return optimizationOverrides.GetAddressOfSideEffects();",
          "4815:     }",
          "4817:     intptr_t ScriptContext::GetArraySetElementFastPathVtableAddr() const",
          "4818:     {",
          "4819:         return optimizationOverrides.GetArraySetElementFastPathVtableAddr();",
          "4820:     }",
          "4822:     intptr_t ScriptContext::GetIntArraySetElementFastPathVtableAddr() const",
          "4823:     {",
          "4824:         return optimizationOverrides.GetIntArraySetElementFastPathVtableAddr();",
          "4825:     }",
          "4827:     intptr_t ScriptContext::GetFloatArraySetElementFastPathVtableAddr() const",
          "4828:     {",
          "4829:         return optimizationOverrides.GetFloatArraySetElementFastPathVtableAddr();",
          "4830:     }",
          "4832:     intptr_t ScriptContext::GetBuiltinFunctionsBaseAddr() const",
          "4833:     {",
          "4834:         return (intptr_t)GetLibrary()->GetBuiltinFunctions();",
          "4835:     }",
          "4837:     intptr_t ScriptContext::GetLibraryAddr() const",
          "4838:     {",
          "4839:         return (intptr_t)GetLibrary();",
          "4840:     }",
          "4842:     intptr_t ScriptContext::GetGlobalObjectAddr() const",
          "4843:     {",
          "4844:         return (intptr_t)GetLibrary()->GetGlobalObject();",
          "4845:     }",
          "4847:     intptr_t ScriptContext::GetGlobalObjectThisAddr() const",
          "4848:     {",
          "4849:         return (intptr_t)GetLibrary()->GetGlobalObject()->ToThis();",
          "4850:     }",
          "4852:     intptr_t ScriptContext::GetNumberAllocatorAddr() const",
          "4853:     {",
          "4854:         return (intptr_t)&numberAllocator;",
          "4855:     }",
          "4857:     intptr_t ScriptContext::GetRecyclerAddr() const",
          "4858:     {",
          "4859:         return (intptr_t)GetRecycler();",
          "4860:     }",
          "4862:     intptr_t ScriptContext::GetDebuggingFlagsAddr() const",
          "4863:     {",
          "4864:         return this->threadContext->GetDebugManager()->GetDebuggingFlagsAddr();",
          "4865:     }",
          "4867:     intptr_t ScriptContext::GetDebugStepTypeAddr() const",
          "4868:     {",
          "4869:         return (intptr_t)this->threadContext->GetDebugManager()->stepController.GetAddressOfStepType();",
          "4870:     }",
          "4872:     intptr_t ScriptContext::GetDebugFrameAddressAddr() const",
          "4873:     {",
          "4874:         return (intptr_t)this->threadContext->GetDebugManager()->stepController.GetAddressOfFrameAddress();",
          "4875:     }",
          "4877:     intptr_t ScriptContext::GetDebugScriptIdWhenSetAddr() const",
          "4878:     {",
          "4879:         return (intptr_t)this->threadContext->GetDebugManager()->stepController.GetAddressOfScriptIdWhenSet();",
          "4880:     }",
          "4882:     bool ScriptContext::GetRecyclerAllowNativeCodeBumpAllocation() const",
          "4883:     {",
          "4884:         return GetRecycler()->AllowNativeCodeBumpAllocation();",
          "4885:     }",
          "4887:     bool ScriptContext::IsSIMDEnabled() const",
          "4888:     {",
          "4889:         return GetConfig()->IsSimdjsEnabled();",
          "4890:     }",
          "4892:     bool ScriptContext::IsPRNGSeeded() const",
          "4893:     {",
          "4894:         return GetLibrary()->IsPRNGSeeded();",
          "4895:     }",
          "4897:     intptr_t ScriptContext::GetAddr() const",
          "4898:     {",
          "4899:         return (intptr_t)this;",
          "4900:     }",
          "4902: #if ENABLE_NATIVE_CODEGEN",
          "4903:     void ScriptContext::AddToDOMFastPathHelperMap(intptr_t funcInfoAddr, IR::JnHelperMethod helper)",
          "4904:     {",
          "4905:         m_domFastPathHelperMap->Add(funcInfoAddr, helper);",
          "4906:     }",
          "4908:     IR::JnHelperMethod ScriptContext::GetDOMFastPathHelper(intptr_t funcInfoAddr)",
          "4909:     {",
          "4910:         IR::JnHelperMethod helper;",
          "4912:         m_domFastPathHelperMap->LockResize();",
          "4913:         bool found = m_domFastPathHelperMap->TryGetValue(funcInfoAddr, &helper);",
          "4914:         m_domFastPathHelperMap->UnlockResize();",
          "4916:         Assert(found);",
          "4917:         return helper;",
          "4918:     }",
          "4919: #endif",
          "4921:     intptr_t ScriptContext::GetVTableAddress(VTableValue vtableType) const",
          "4922:     {",
          "4923:         Assert(vtableType < VTableValue::Count);",
          "4924:         return GetLibrary()->GetVTableAddresses()[vtableType];",
          "4925:     }",
          "4927:     bool ScriptContext::IsRecyclerVerifyEnabled() const",
          "4928:     {",
          "4929: #ifdef RECYCLER_MEMORY_VERIFY",
          "4930:         return recycler->VerifyEnabled() != FALSE;",
          "4931: #else",
          "4932:         return false;",
          "4933: #endif",
          "4934:     }",
          "4936:     uint ScriptContext::GetRecyclerVerifyPad() const",
          "4937:     {",
          "4938: #ifdef RECYCLER_MEMORY_VERIFY",
          "4939:         return recycler->GetVerifyPad();",
          "4940: #else",
          "4941:         return 0;",
          "4942: #endif",
          "4943:     }",
          "4945:     JavascriptFunction* ScriptContext::GetBuiltInLibraryFunction(JavascriptMethod entryPoint)",
          "4946:     {",
          "4947:         JavascriptFunction * function = NULL;",
          "4948:         if (builtInLibraryFunctions)",
          "4949:         {",
          "4950:             builtInLibraryFunctions->TryGetValue(entryPoint, &function);",
          "4951:         }",
          "4952:         return function;",
          "4953:     }",
          "4955: #if ENABLE_PROFILE_INFO",
          "4956:     template<template<typename> class BarrierT>",
          "4957:     void ScriptContext::AddDynamicProfileInfo(",
          "4958:         FunctionBody * functionBody, BarrierT<DynamicProfileInfo>& dynamicProfileInfo)",
          "4959:     {",
          "4960:         Assert(functionBody->GetScriptContext() == this);",
          "4961:         Assert(functionBody->HasValidSourceInfo());",
          "4963:         DynamicProfileInfo * newDynamicProfileInfo = dynamicProfileInfo;",
          "4965:         SourceContextInfo* sourceContextInfo = functionBody->GetSourceContextInfo();",
          "4966:         SourceDynamicProfileManager* profileManager = sourceContextInfo->sourceDynamicProfileManager;",
          "4967:         if (sourceContextInfo->IsDynamic())",
          "4968:         {",
          "4969:             if (profileManager != nullptr)",
          "4970:             {",
          "4972:                 if (newDynamicProfileInfo == nullptr)",
          "4973:                 {",
          "4974:                     newDynamicProfileInfo = DynamicProfileInfo::New(this->GetRecycler(), functionBody, true /* persistsAcrossScriptContexts */);",
          "4975:                     profileManager->UpdateDynamicProfileInfo(functionBody->GetLocalFunctionId(), newDynamicProfileInfo);",
          "4976:                     dynamicProfileInfo = newDynamicProfileInfo;",
          "4977:                 }",
          "4978:                 profileManager->MarkAsExecuted(functionBody->GetLocalFunctionId());",
          "4979:                 newDynamicProfileInfo->UpdateFunctionInfo(functionBody, this->GetRecycler());",
          "4980:             }",
          "4981:             else",
          "4982:             {",
          "4983:                 if (newDynamicProfileInfo == nullptr)",
          "4984:                 {",
          "4985:                     newDynamicProfileInfo = functionBody->AllocateDynamicProfile();",
          "4986:                 }",
          "4987:                 dynamicProfileInfo = newDynamicProfileInfo;",
          "4988:             }",
          "4989:         }",
          "4990:         else",
          "4991:         {",
          "4992:             if (newDynamicProfileInfo == nullptr)",
          "4993:             {",
          "4994:                 newDynamicProfileInfo = functionBody->AllocateDynamicProfile();",
          "4995:                 dynamicProfileInfo = newDynamicProfileInfo;",
          "4996:             }",
          "4997:             Assert(functionBody->GetInterpretedCount() == 0);",
          "4998: #if DBG_DUMP || defined(DYNAMIC_PROFILE_STORAGE) || defined(RUNTIME_DATA_COLLECTION)",
          "5000:             if (this->Cache()->profileInfoList)",
          "5001:             {",
          "5002:                 this->Cache()->profileInfoList->Prepend(this->GetRecycler(), newDynamicProfileInfo);",
          "5003:             }",
          "5004: #endif",
          "5005:             if (!startupComplete)",
          "5006:             {",
          "5007:                 Assert(profileManager);",
          "5008:                 profileManager->MarkAsExecuted(functionBody->GetLocalFunctionId());",
          "5009:             }",
          "5010:         }",
          "5011:         Assert(dynamicProfileInfo != nullptr);",
          "5012:     }",
          "5013:     template void  ScriptContext::AddDynamicProfileInfo<WriteBarrierPtr>(FunctionBody *, WriteBarrierPtr<DynamicProfileInfo>&);",
          "5014: #endif",
          "5016:     CharClassifier const * ScriptContext::GetCharClassifier(void) const",
          "5017:     {",
          "5018:         return this->charClassifier;",
          "5019:     }",
          "5021:     void ScriptContext::OnStartupComplete()",
          "5022:     {",
          "5023:         JS_ETW(EventWriteJSCRIPT_ON_STARTUP_COMPLETE(this));",
          "5025:         SaveStartupProfileAndRelease();",
          "5026:     }",
          "5028:     void ScriptContext::SaveStartupProfileAndRelease(bool isSaveOnClose)",
          "5029:     {",
          "5031:         if (GetThreadContext()->IsJSRT())",
          "5032:         {",
          "5033:             return;",
          "5034:         }",
          "5035:         if (!startupComplete && this->Cache()->sourceContextInfoMap)",
          "5036:         {",
          "5037: #if ENABLE_PROFILE_INFO",
          "5038:             this->Cache()->sourceContextInfoMap->Map([&](DWORD_PTR dwHostSourceContext, SourceContextInfo* info)",
          "5039:             {",
          "5040:                 Assert(info->sourceDynamicProfileManager);",
          "5041:                 uint bytesWritten = info->sourceDynamicProfileManager->SaveToProfileCacheAndRelease(info);",
          "5042:                 if (bytesWritten > 0)",
          "5043:                 {",
          "5044:                     JS_ETW(EventWriteJSCRIPT_PROFILE_SAVE(info->dwHostSourceContext, this, bytesWritten, isSaveOnClose));",
          "5045:                     OUTPUT_TRACE(Js::DynamicProfilePhase, _u(\"Profile saving succeeded\\n\"));",
          "5046:                 }",
          "5047:             });",
          "5048: #endif",
          "5049:         }",
          "5050:         startupComplete = true;",
          "5051:     }",
          "5053:     void ScriptContext::SetFastDOMenabled()",
          "5054:     {",
          "5055:         fastDOMenabled = true; Assert(globalObject->GetDirectHostObject() != NULL);",
          "5056:     }",
          "5058: #if DYNAMIC_INTERPRETER_THUNK",
          "5059:     JavascriptMethod ScriptContext::GetNextDynamicAsmJsInterpreterThunk(PVOID* ppDynamicInterpreterThunk)",
          "5060:     {",
          "5061: #ifdef ASMJS_PLAT",
          "5062:         return (JavascriptMethod)this->asmJsInterpreterThunkEmitter->GetNextThunk(ppDynamicInterpreterThunk);",
          "5063: #else",
          "5064:         __debugbreak();",
          "5065:         return nullptr;",
          "5066: #endif",
          "5067:     }",
          "5069:     JavascriptMethod ScriptContext::GetNextDynamicInterpreterThunk(PVOID* ppDynamicInterpreterThunk)",
          "5070:     {",
          "5071:         return (JavascriptMethod)this->interpreterThunkEmitter->GetNextThunk(ppDynamicInterpreterThunk);",
          "5072:     }",
          "5074: #if DBG",
          "5075:     BOOL ScriptContext::IsDynamicInterpreterThunk(JavascriptMethod address)",
          "5076:     {",
          "5077:         return this->interpreterThunkEmitter->IsInHeap((void*)address);",
          "5078:     }",
          "5079: #endif",
          "5081:     void ScriptContext::ReleaseDynamicInterpreterThunk(BYTE* address, bool addtoFreeList)",
          "5082:     {",
          "5083:         this->interpreterThunkEmitter->Release(address, addtoFreeList);",
          "5084:     }",
          "5086:     void ScriptContext::ReleaseDynamicAsmJsInterpreterThunk(BYTE* address, bool addtoFreeList)",
          "5087:     {",
          "5088: #ifdef ASMJS_PLAT",
          "5089:         this->asmJsInterpreterThunkEmitter->Release(address, addtoFreeList);",
          "5090: #else",
          "5091:         Assert(UNREACHED);",
          "5092: #endif",
          "5093:     }",
          "5094: #endif",
          "5096:     bool ScriptContext::IsExceptionWrapperForBuiltInsEnabled()",
          "5097:     {",
          "5098:         return ScriptContext::IsExceptionWrapperForBuiltInsEnabled(this);",
          "5099:     }",
          "5102:     bool ScriptContext::IsExceptionWrapperForBuiltInsEnabled(ScriptContext* scriptContext)",
          "5103:     {",
          "5104:         Assert(scriptContext);",
          "5105:         return CONFIG_FLAG(EnableContinueAfterExceptionWrappersForBuiltIns);",
          "5106:     }",
          "5108:     bool ScriptContext::IsExceptionWrapperForHelpersEnabled(ScriptContext* scriptContext)",
          "5109:     {",
          "5110:         Assert(scriptContext);",
          "5111:         return  CONFIG_FLAG(EnableContinueAfterExceptionWrappersForHelpers);",
          "5112:     }",
          "5114:     void ScriptContextBase::SetGlobalObject(GlobalObject *globalObject)",
          "5115:     {",
          "5116: #if DBG",
          "5117:         ScriptContext* scriptContext = static_cast<ScriptContext*>(this);",
          "5118:         Assert(scriptContext->IsCloningGlobal() && !this->globalObject);",
          "5119: #endif",
          "5120:         this->globalObject = globalObject;",
          "5121:     }",
          "5123:     void ConvertKey(const FastEvalMapString& src, EvalMapString& dest)",
          "5124:     {",
          "5125:         dest.str = src.str;",
          "5126:         dest.strict = src.strict;",
          "5127:         dest.moduleID = src.moduleID;",
          "5128:         dest.hash = TAGHASH((hash_t)dest.str);",
          "5129:     }",
          "5131:     void ScriptContext::PrintStats()",
          "5132:     {",
          "5134: #ifdef PROFILE_TYPES",
          "5135:         if (Configuration::Global.flags.ProfileTypes)",
          "5136:         {",
          "5137:             ProfileTypes();",
          "5138:         }",
          "5139: #endif",
          "5141: #ifdef PROFILE_BAILOUT_RECORD_MEMORY",
          "5142:         if (Configuration::Global.flags.ProfileBailOutRecordMemory)",
          "5143:         {",
          "5144:             Output::Print(_u(\"CodeSize: %6d\\nBailOutRecord Size: %6d\\nLocalOffsets Size: %6d\\n\"), codeSize, bailOutRecordBytes, bailOutOffsetBytes);",
          "5145:         }",
          "5146: #endif",
          "5148: #ifdef PROFILE_OBJECT_LITERALS",
          "5149:         if (Configuration::Global.flags.ProfileObjectLiteral)",
          "5150:         {",
          "5151:             ProfileObjectLiteral();",
          "5152:         }",
          "5153: #endif",
          "5155: #ifdef PROFILE_STRINGS",
          "5156:         if (stringProfiler != nullptr)",
          "5157:         {",
          "5158:             stringProfiler->PrintAll();",
          "5159:             Adelete(MiscAllocator(), stringProfiler);",
          "5160:             stringProfiler = nullptr;",
          "5161:         }",
          "5162: #endif",
          "5164: #ifdef PROFILE_MEM",
          "5165:         if (profileMemoryDump && MemoryProfiler::IsTraceEnabled())",
          "5166:         {",
          "5167:             MemoryProfiler::PrintAll();",
          "5168: #ifdef PROFILE_RECYCLER_ALLOC",
          "5169:             if (Js::Configuration::Global.flags.TraceMemory.IsEnabled(Js::AllPhase)",
          "5170:                 || Js::Configuration::Global.flags.TraceMemory.IsEnabled(Js::RunPhase))",
          "5171:             {",
          "5172:                 GetRecycler()->PrintAllocStats();",
          "5173:             }",
          "5174: #endif",
          "5175:         }",
          "5176: #endif",
          "5177: #if DBG_DUMP",
          "5178:         if (PHASE_STATS1(Js::ByteCodePhase))",
          "5179:         {",
          "5180:             Output::Print(_u(\" Total Bytecode size: <%d, %d, %d> = %d\\n\"),",
          "5181:                 byteCodeDataSize,",
          "5182:                 byteCodeAuxiliaryDataSize,",
          "5183:                 byteCodeAuxiliaryContextDataSize,",
          "5184:                 byteCodeDataSize + byteCodeAuxiliaryDataSize + byteCodeAuxiliaryContextDataSize);",
          "5185:         }",
          "5187:         if (Configuration::Global.flags.BytecodeHist)",
          "5188:         {",
          "5189:             Output::Print(_u(\"ByteCode Histogram\\n\"));",
          "5190:             Output::Print(_u(\"\\n\"));",
          "5192:             uint total = 0;",
          "5193:             uint unique = 0;",
          "5194:             for (int j = 0; j < (int)OpCode::ByteCodeLast; j++)",
          "5195:             {",
          "5196:                 total += byteCodeHistogram[j];",
          "5197:                 if (byteCodeHistogram[j] > 0)",
          "5198:                 {",
          "5199:                     unique++;",
          "5200:                 }",
          "5201:             }",
          "5202:             Output::Print(_u(\"%9u                     Total executed ops\\n\"), total);",
          "5203:             Output::Print(_u(\"\\n\"));",
          "5205:             uint max = UINT_MAX;",
          "5206:             double pctcume = 0.0;",
          "5208:             while (true)",
          "5209:             {",
          "5210:                 uint upper = 0;",
          "5211:                 int index = -1;",
          "5212:                 for (int j = 0; j < (int)OpCode::ByteCodeLast; j++)",
          "5213:                 {",
          "5214:                     if (OpCodeUtil::IsValidOpcode((OpCode)j) && byteCodeHistogram[j] > upper && byteCodeHistogram[j] < max)",
          "5215:                     {",
          "5216:                         index = j;",
          "5217:                         upper = byteCodeHistogram[j];",
          "5218:                     }",
          "5219:                 }",
          "5221:                 if (index == -1)",
          "5222:                 {",
          "5223:                     break;",
          "5224:                 }",
          "5226:                 max = byteCodeHistogram[index];",
          "5228:                 for (OpCode j = (OpCode)0; j < OpCode::ByteCodeLast; j++)",
          "5229:                 {",
          "5230:                     if (OpCodeUtil::IsValidOpcode(j) && max == byteCodeHistogram[(int)j])",
          "5231:                     {",
          "5232:                         double pct = ((double)max) / total;",
          "5233:                         pctcume += pct;",
          "5235:                         Output::Print(_u(\"%9u  %5.1lf  %5.1lf  %04x %s\\n\"), max, pct * 100, pctcume * 100, j, OpCodeUtil::GetOpCodeName(j));",
          "5236:                     }",
          "5237:                 }",
          "5238:             }",
          "5239:             Output::Print(_u(\"\\n\"));",
          "5240:             Output::Print(_u(\"Unique opcodes: %d\\n\"), unique);",
          "5241:         }",
          "5243: #endif",
          "5245: #if ENABLE_NATIVE_CODEGEN",
          "5246: #ifdef BGJIT_STATS",
          "5248:         if (PHASE_STATS1(Js::BGJitPhase) && (this->interpretedCount > 50 || Js::Configuration::Global.flags.IsEnabled(Js::ForceFlag)))",
          "5249:         {",
          "5251: #define MAX_BUCKETS 15",
          "5252:             uint loopJitCodeUsed = 0;",
          "5253:             uint bucketSize1 = 20;",
          "5254:             uint bucketSize2 = 100;",
          "5255:             uint size1CutOffbucketId = 4;",
          "5256:             uint totalBuckets[MAX_BUCKETS] = { 0 };",
          "5257:             uint nativeCodeBuckets[MAX_BUCKETS] = { 0 };",
          "5258:             uint usedNativeCodeBuckets[MAX_BUCKETS] = { 0 };",
          "5259:             uint rejits[MAX_BUCKETS] = { 0 };",
          "5260:             uint zeroInterpretedFunctions = 0;",
          "5261:             uint oneInterpretedFunctions = 0;",
          "5262:             uint nonZeroBytecodeFunctions = 0;",
          "5263:             Output::Print(_u(\"Script Context: 0x%p Url: %s\\n\"), this, this->url);",
          "5265:             FunctionBody* anyFunctionBody = this->FindFunction([](FunctionBody* body) { return body != nullptr; });",
          "5267:             if (anyFunctionBody)",
          "5268:             {",
          "5269:                 OUTPUT_VERBOSE_STATS(Js::BGJitPhase, _u(\"Function list\\n\"));",
          "5270:                 OUTPUT_VERBOSE_STATS(Js::BGJitPhase, _u(\"===============================\\n\"));",
          "5271:                 OUTPUT_VERBOSE_STATS(Js::BGJitPhase, _u(\"%-24s, %-8s, %-10s, %-10s, %-10s, %-10s, %-10s\\n\"), _u(\"Function\"), _u(\"InterpretedCount\"), _u(\"ByteCodeInLoopSize\"), _u(\"ByteCodeSize\"), _u(\"IsJitted\"), _u(\"IsUsed\"), _u(\"NativeCodeSize\"));",
          "5273:                 this->MapFunction([&](FunctionBody* body)",
          "5274:                 {",
          "5275:                     bool isNativeCode = false;",
          "5278:                     if (body->GetInterpretedCount() > 1 || Js::Configuration::Global.flags.IsEnabled(Js::ForceFlag))",
          "5279:                     {",
          "5280:                         body->MapEntryPoints([&](uint entryPointIndex, FunctionEntryPointInfo* entryPoint)",
          "5281:                         {",
          "5282:                             char16 debugStringBuffer[MAX_FUNCTION_BODY_DEBUG_STRING_SIZE];",
          "5283:                             char rejit = entryPointIndex > 0 ? '*' : ' ';",
          "5284:                             isNativeCode = entryPoint->IsNativeCode() | isNativeCode;",
          "5285:                             OUTPUT_VERBOSE_STATS(Js::BGJitPhase, _u(\"%-20s %16s %c, %8d , %10d , %10d, %-10s, %-10s, %10d\\n\"),",
          "5286:                                 body->GetExternalDisplayName(),",
          "5287:                                 body->GetDebugNumberSet(debugStringBuffer),",
          "5288:                                 rejit,",
          "5289:                                 body->GetInterpretedCount(),",
          "5290:                                 body->GetByteCodeInLoopCount(),",
          "5291:                                 body->GetByteCodeCount(),",
          "5292:                                 entryPoint->IsNativeCode() ? _u(\"Jitted\") : _u(\"Interpreted\"),",
          "5293:                                 body->GetNativeEntryPointUsed() ? _u(\"Used\") : _u(\"NotUsed\"),",
          "5294:                                 entryPoint->IsNativeCode() ? entryPoint->GetCodeSize() : 0);",
          "5295:                         });",
          "5296:                     }",
          "5297:                     if (body->GetInterpretedCount() == 0)",
          "5298:                     {",
          "5299:                         zeroInterpretedFunctions++;",
          "5300:                         if (body->GetByteCodeCount() > 0)",
          "5301:                         {",
          "5302:                             nonZeroBytecodeFunctions++;",
          "5303:                         }",
          "5304:                     }",
          "5305:                     else if (body->GetInterpretedCount() == 1)",
          "5306:                     {",
          "5307:                         oneInterpretedFunctions++;",
          "5308:                     }",
          "5312:                     uint bucket;",
          "5313:                     uint intrpCount = body->GetInterpretedCount();",
          "5314:                     if (intrpCount < 100)",
          "5315:                     {",
          "5316:                         bucket = intrpCount / bucketSize1;",
          "5317:                     }",
          "5318:                     else if (intrpCount < 1000)",
          "5319:                     {",
          "5320:                         bucket = size1CutOffbucketId  + intrpCount / bucketSize2;",
          "5321:                     }",
          "5322:                     else",
          "5323:                     {",
          "5324:                         bucket = MAX_BUCKETS - 1;",
          "5325:                     }",
          "5329:                     __analysis_assume(bucket < MAX_BUCKETS);",
          "5331:                     totalBuckets[bucket]++;",
          "5332:                     if (isNativeCode)",
          "5333:                     {",
          "5334:                         nativeCodeBuckets[bucket]++;",
          "5335:                         if (body->GetNativeEntryPointUsed())",
          "5336:                         {",
          "5337:                             usedNativeCodeBuckets[bucket]++;",
          "5338:                         }",
          "5339:                         if (body->HasRejit())",
          "5340:                         {",
          "5341:                             rejits[bucket]++;",
          "5342:                         }",
          "5343:                     }",
          "5345:                     body->MapLoopHeaders([&](uint loopNumber, LoopHeader* header)",
          "5346:                     {",
          "5347:                         char16 loopBodyName[256];",
          "5348:                         body->GetLoopBodyName(loopNumber, loopBodyName, _countof(loopBodyName));",
          "5349:                         header->MapEntryPoints([&](int index, LoopEntryPointInfo * entryPoint)",
          "5350:                         {",
          "5351:                             if (entryPoint->IsNativeCode())",
          "5352:                             {",
          "5353:                                 char16 debugStringBuffer[MAX_FUNCTION_BODY_DEBUG_STRING_SIZE];",
          "5354:                                 char rejit = index > 0 ? '*' : ' ';",
          "5355:                                 OUTPUT_VERBOSE_STATS(Js::BGJitPhase, _u(\"%-20s %16s %c, %8d , %10d , %10d, %-10s, %-10s, %10d\\n\"),",
          "5356:                                     loopBodyName,",
          "5357:                                     body->GetDebugNumberSet(debugStringBuffer),",
          "5358:                                     rejit,",
          "5359:                                     header->interpretCount,",
          "5360:                                     header->GetByteCodeCount(),",
          "5361:                                     header->GetByteCodeCount(),",
          "5362:                                     _u(\"Jitted\"),",
          "5363:                                     entryPoint->IsUsed() ? _u(\"Used\") : _u(\"NotUsed\"),",
          "5364:                                     entryPoint->GetCodeSize());",
          "5365:                                 if (entryPoint->IsUsed())",
          "5366:                                 {",
          "5367:                                     loopJitCodeUsed++;",
          "5368:                                 }",
          "5369:                             }",
          "5370:                         });",
          "5371:                     });",
          "5372:                 });",
          "5373:             }",
          "5375:             Output::Print(_u(\"**  SpeculativelyJitted: %6d FunctionsJitted: %6d JittedUsed: %6d Usage:%f ByteCodesJitted: %6d JitCodeUsed: %6d Usage: %f \\n\"),",
          "5376:                 speculativeJitCount, funcJITCount, funcJitCodeUsed, ((float)(funcJitCodeUsed) / funcJITCount) * 100, bytecodeJITCount, jitCodeUsed, ((float)(jitCodeUsed) / bytecodeJITCount) * 100);",
          "5377:             Output::Print(_u(\"** LoopJITCount: %6d LoopJitCodeUsed: %6d Usage: %f\\n\"),",
          "5378:                 loopJITCount, loopJitCodeUsed, ((float)loopJitCodeUsed / loopJITCount) * 100);",
          "5379:             Output::Print(_u(\"** TotalInterpretedCalls: %6d MaxFuncInterp: %6d  InterpretedHighPri: %6d \\n\"),",
          "5380:                 interpretedCount, maxFuncInterpret, interpretedCallsHighPri);",
          "5381:             Output::Print(_u(\"** ZeroInterpretedFunctions: %6d OneInterpretedFunctions: %6d ZeroInterpretedWithNonZeroBytecode: %6d \\n \"), zeroInterpretedFunctions, oneInterpretedFunctions, nonZeroBytecodeFunctions);",
          "5382:             Output::Print(_u(\"** %-24s : %-10s %-10s %-10s %-10s %-10s\\n\"), _u(\"InterpretedCounts\"), _u(\"Total\"), _u(\"NativeCode\"), _u(\"Used\"), _u(\"Usage\"), _u(\"Rejits\"));",
          "5383:             uint low = 0;",
          "5384:             uint high = 0;",
          "5385:             for (uint i = 0; i < _countof(totalBuckets); i++)",
          "5386:             {",
          "5387:                 low = high;",
          "5388:                 if (i <= size1CutOffbucketId)",
          "5389:                 {",
          "5390:                     high = low + bucketSize1;",
          "5391:                 }",
          "5392:                 else if (i < (_countof(totalBuckets) - 1))",
          "5393:                 {",
          "5394:                     high = low + bucketSize2;               }",
          "5395:                 else",
          "5396:                 {",
          "5397:                     high = 100000;",
          "5398:                 }",
          "5399:                 Output::Print(_u(\"** %10d - %10d : %10d %10d %10d %7.2f %10d\\n\"), low, high, totalBuckets[i], nativeCodeBuckets[i], usedNativeCodeBuckets[i], ((float)usedNativeCodeBuckets[i] / nativeCodeBuckets[i]) * 100, rejits[i]);",
          "5400:             }",
          "5401:             Output::Print(_u(\"\\n\\n\"));",
          "5402:         }",
          "5403: #undef MAX_BUCKETS",
          "5404: #endif",
          "5406: #ifdef REJIT_STATS",
          "5407:         if (PHASE_STATS1(Js::ReJITPhase))",
          "5408:         {",
          "5409:             uint totalBailouts = 0;",
          "5410:             uint totalRejits = 0;",
          "5411:             WCHAR buf[256];",
          "5414:             Output::Print(_u(\"%-40s %6s\\n\"), _u(\"Bailout Reason,\"), _u(\"Count\"));",
          "5416:             bailoutReasonCounts->Map([&totalBailouts](uint kind, uint val) {",
          "5417:                 WCHAR buf[256];",
          "5418:                 totalBailouts += val;",
          "5419:                 if (val != 0)",
          "5420:                 {",
          "5421:                     swprintf_s(buf, _u(\"%S,\"), GetBailOutKindName((IR::BailOutKind)kind));",
          "5422:                     Output::Print(_u(\"%-40s %6d\\n\"), buf, val);",
          "5423:                 }",
          "5424:             });",
          "5427:             Output::Print(_u(\"%-40s %6d\\n\"), _u(\"TOTAL,\"), totalBailouts);",
          "5428:             Output::Print(_u(\"\\n\\n\"));",
          "5431:             Output::Print(_u(\"%-40s %6s\\n\"), _u(\"Rejit Reason,\"), _u(\"Count\"));",
          "5432:             for (uint i = 0; i < NumRejitReasons; ++i)",
          "5433:             {",
          "5434:                 totalRejits += rejitReasonCounts[i];",
          "5435:                 if (rejitReasonCounts[i] != 0)",
          "5436:                 {",
          "5437:                     swprintf_s(buf, _u(\"%S,\"), RejitReasonNames[i]);",
          "5438:                     Output::Print(_u(\"%-40s %6d\\n\"), buf, rejitReasonCounts[i]);",
          "5439:                 }",
          "5440:             }",
          "5441:             Output::Print(_u(\"%-40s %6d\\n\"), _u(\"TOTAL,\"), totalRejits);",
          "5442:             Output::Print(_u(\"\\n\\n\"));",
          "5445:             if (Configuration::Global.flags.Verbose && rejitStatsMap != NULL)",
          "5446:             {",
          "5448:                 Output::Print(_u(\"%-30s %14s %14s\\n\"), _u(\"Function (#),\"), _u(\"Bailout Count,\"), _u(\"Rejit Count\"));",
          "5449:                 rejitStatsMap->Map([](Js::FunctionBody const *body, RejitStats *stats, RecyclerWeakReference<const Js::FunctionBody> const*) {",
          "5450:                     char16 debugStringBuffer[MAX_FUNCTION_BODY_DEBUG_STRING_SIZE];",
          "5451:                     for (uint i = 0; i < NumRejitReasons; ++i)",
          "5452:                         stats->m_totalRejits += stats->m_rejitReasonCounts[i];",
          "5454:                     stats->m_bailoutReasonCounts->Map([stats](uint kind, uint val) {",
          "5455:                         stats->m_totalBailouts += val;",
          "5456:                     });",
          "5458:                     WCHAR buf[256];",
          "5460:                     swprintf_s(buf, _u(\"%s (%s),\"), body->GetExternalDisplayName(), (const_cast<Js::FunctionBody*>(body))->GetDebugNumberSet(debugStringBuffer)); //TODO Kount",
          "5461:                     Output::Print(_u(\"%-30s %14d, %14d\\n\"), buf, stats->m_totalBailouts, stats->m_totalRejits);",
          "5463:                 });",
          "5464:                 Output::Print(_u(\"\\n\\n\"));",
          "5467:                 rejitStatsMap->Map([](Js::FunctionBody const *body, RejitStats *stats, RecyclerWeakReference<const Js::FunctionBody> const *) {",
          "5468:                     char16 debugStringBuffer[MAX_FUNCTION_BODY_DEBUG_STRING_SIZE];",
          "5469:                     WCHAR buf[256];",
          "5471:                     swprintf_s(buf, _u(\"%s (%s),\"), body->GetExternalDisplayName(), (const_cast<Js::FunctionBody*>(body))->GetDebugNumberSet(debugStringBuffer)); //TODO Kount",
          "5472:                     Output::Print(_u(\"%-30s\\n\\n\"), buf);",
          "5475:                     if (stats->m_totalBailouts != 0)",
          "5476:                     {",
          "5477:                         Output::Print(_u(\"%10sBailouts:\\n\"), _u(\"\"));",
          "5479:                         stats->m_bailoutReasonCounts->Map([](uint kind, uint val) {",
          "5480:                             if (val != 0)",
          "5481:                             {",
          "5482:                                 WCHAR buf[256];",
          "5483:                                 swprintf_s(buf, _u(\"%S,\"), GetBailOutKindName((IR::BailOutKind)kind));",
          "5484:                                 Output::Print(_u(\"%10s%-40s %6d\\n\"), _u(\"\"), buf, val);",
          "5485:                             }",
          "5486:                         });",
          "5487:                     }",
          "5488:                     Output::Print(_u(\"\\n\"));",
          "5491:                     if (stats->m_totalRejits != 0)",
          "5492:                     {",
          "5493:                         Output::Print(_u(\"%10sRejits:\\n\"), _u(\"\"));",
          "5494:                         for (uint i = 0; i < NumRejitReasons; ++i)",
          "5495:                         {",
          "5496:                             if (stats->m_rejitReasonCounts[i] != 0)",
          "5497:                             {",
          "5498:                                 swprintf_s(buf, _u(\"%S,\"), RejitReasonNames[i]);",
          "5499:                                 Output::Print(_u(\"%10s%-40s %6d\\n\"), _u(\"\"), buf, stats->m_rejitReasonCounts[i]);",
          "5500:                             }",
          "5501:                         }",
          "5502:                         Output::Print(_u(\"\\n\\n\"));",
          "5503:                     }",
          "5504:                 });",
          "5506:             }",
          "5507:         }",
          "5508: #endif",
          "5510: #ifdef FIELD_ACCESS_STATS",
          "5511:     if (PHASE_STATS1(Js::ObjTypeSpecPhase))",
          "5512:     {",
          "5513:         FieldAccessStats globalStats;",
          "5514:         if (this->fieldAccessStatsByFunctionNumber != nullptr)",
          "5515:         {",
          "5516:             this->fieldAccessStatsByFunctionNumber->Map([&globalStats](uint functionNumber, FieldAccessStatsEntry* entry)",
          "5517:             {",
          "5518:                 FieldAccessStats functionStats;",
          "5519:                 entry->stats.Map([&functionStats](FieldAccessStatsPtr entryPointStats)",
          "5520:                 {",
          "5521:                     functionStats.Add(entryPointStats);",
          "5522:                 });",
          "5524:                 if (PHASE_VERBOSE_STATS1(Js::ObjTypeSpecPhase))",
          "5525:                 {",
          "5526:                     FunctionBody* functionBody = entry->functionBodyWeakRef->Get();",
          "5527:                     const char16* functionName = functionBody != nullptr ? functionBody->GetDisplayName() : _u(\"<unknown>\");",
          "5528:                     Output::Print(_u(\"FieldAccessStats: function %s (#%u): inline cache stats:\\n\"), functionName, functionNumber);",
          "5529:                     Output::Print(_u(\"    overall: total %u, no profile info %u\\n\"), functionStats.totalInlineCacheCount, functionStats.noInfoInlineCacheCount);",
          "5530:                     Output::Print(_u(\"    mono: total %u, empty %u, cloned %u\\n\"),",
          "5531:                         functionStats.monoInlineCacheCount, functionStats.emptyMonoInlineCacheCount, functionStats.clonedMonoInlineCacheCount);",
          "5532:                     Output::Print(_u(\"    poly: total %u (high %u, low %u), null %u, empty %u, ignored %u, disabled %u, equivalent %u, non-equivalent %u, cloned %u\\n\"),",
          "5533:                         functionStats.polyInlineCacheCount, functionStats.highUtilPolyInlineCacheCount, functionStats.lowUtilPolyInlineCacheCount,",
          "5534:                         functionStats.nullPolyInlineCacheCount, functionStats.emptyPolyInlineCacheCount, functionStats.ignoredPolyInlineCacheCount, functionStats.disabledPolyInlineCacheCount,",
          "5535:                         functionStats.equivPolyInlineCacheCount, functionStats.nonEquivPolyInlineCacheCount, functionStats.clonedPolyInlineCacheCount);",
          "5536:                 }",
          "5538:                 globalStats.Add(&functionStats);",
          "5539:             });",
          "5540:         }",
          "5542:         Output::Print(_u(\"FieldAccessStats: totals\\n\"));",
          "5543:         Output::Print(_u(\"    overall: total %u, no profile info %u\\n\"), globalStats.totalInlineCacheCount, globalStats.noInfoInlineCacheCount);",
          "5544:         Output::Print(_u(\"    mono: total %u, empty %u, cloned %u\\n\"),",
          "5545:             globalStats.monoInlineCacheCount, globalStats.emptyMonoInlineCacheCount, globalStats.clonedMonoInlineCacheCount);",
          "5546:         Output::Print(_u(\"    poly: total %u (high %u, low %u), null %u, empty %u, ignored %u, disabled %u, equivalent %u, non-equivalent %u, cloned %u\\n\"),",
          "5547:             globalStats.polyInlineCacheCount, globalStats.highUtilPolyInlineCacheCount, globalStats.lowUtilPolyInlineCacheCount,",
          "5548:             globalStats.nullPolyInlineCacheCount, globalStats.emptyPolyInlineCacheCount, globalStats.ignoredPolyInlineCacheCount, globalStats.disabledPolyInlineCacheCount,",
          "5549:             globalStats.equivPolyInlineCacheCount, globalStats.nonEquivPolyInlineCacheCount, globalStats.clonedPolyInlineCacheCount);",
          "5550:     }",
          "5551: #endif",
          "5553: #ifdef MISSING_PROPERTY_STATS",
          "5554:     if (PHASE_STATS1(Js::MissingPropertyCachePhase))",
          "5555:     {",
          "5556:         Output::Print(_u(\"MissingPropertyStats: hits = %d, misses = %d, cache attempts = %d.\\n\"),",
          "5557:             this->missingPropertyHits, this->missingPropertyMisses, this->missingPropertyCacheAttempts);",
          "5558:     }",
          "5559: #endif",
          "5562: #ifdef INLINE_CACHE_STATS",
          "5563:         if (PHASE_STATS1(Js::PolymorphicInlineCachePhase))",
          "5564:         {",
          "5565:             Output::Print(_u(\"%s,%s,%s,%s,%s,%s,%s,%s,%s\\n\"), _u(\"Function\"), _u(\"Property\"), _u(\"Kind\"), _u(\"Accesses\"), _u(\"Misses\"), _u(\"Miss Rate\"), _u(\"Collisions\"), _u(\"Collision Rate\"), _u(\"Slot Count\"));",
          "5566:             cacheDataMap->Map([this](Js::PolymorphicInlineCache const *cache, CacheData *data) {",
          "5567:                 char16 debugStringBuffer[MAX_FUNCTION_BODY_DEBUG_STRING_SIZE];",
          "5568:                 uint total = data->hits + data->misses;",
          "5569:                 char16 const *propName = this->threadContext->GetPropertyName(data->propertyId)->GetBuffer();",
          "5571:                 wchar funcName[1024];",
          "5573:                 swprintf_s(funcName, _u(\"%s (%s)\"), cache->functionBody->GetExternalDisplayName(), cache->functionBody->GetDebugNumberSet(debugStringBuffer));",
          "5575:                 Output::Print(_u(\"%s,%s,%s,%d,%d,%f,%d,%f,%d\\n\"),",
          "5576:                     funcName,",
          "5577:                     propName,",
          "5578:                     data->isGetCache ? _u(\"get\") : _u(\"set\"),",
          "5579:                     total,",
          "5580:                     data->misses,",
          "5581:                     static_cast<float>(data->misses) / total,",
          "5582:                     data->collisions,",
          "5583:                     static_cast<float>(data->collisions) / total,",
          "5584:                     cache->GetSize()",
          "5585:                     );",
          "5586:             });",
          "5587:         }",
          "5588: #endif",
          "5590: #if ENABLE_REGEX_CONFIG_OPTIONS",
          "5591:         if (regexStatsDatabase != 0)",
          "5592:             regexStatsDatabase->Print(GetRegexDebugWriter());",
          "5593: #endif",
          "5594:         OUTPUT_STATS(Js::EmitterPhase, _u(\"Script Context: 0x%p Url: %s\\n\"), this, this->url);",
          "5595:         OUTPUT_STATS(Js::EmitterPhase, _u(\"  Total thread committed code size = %d\\n\"), this->GetThreadContext()->GetCodeSize());",
          "5597:         OUTPUT_STATS(Js::ParsePhase, _u(\"Script Context: 0x%p Url: %s\\n\"), this, this->url);",
          "5598:         OUTPUT_STATS(Js::ParsePhase, _u(\"  Total ThreadContext source size %d\\n\"), this->GetThreadContext()->GetSourceSize());",
          "5599: #endif",
          "5601: #ifdef ENABLE_BASIC_TELEMETRY",
          "5602:         if (this->telemetry != nullptr)",
          "5603:         {",
          "5605:             this->telemetry->OutputPrint();",
          "5606:         }",
          "5607: #endif",
          "5609:         Output::Flush();",
          "5610:     }",
          "5611:     void ScriptContext::SetNextPendingClose(ScriptContext * nextPendingClose) {",
          "5612:         this->nextPendingClose = nextPendingClose;",
          "5613:     }",
          "5615: #ifdef ENABLE_MUTATION_BREAKPOINT",
          "5616:     bool ScriptContext::HasMutationBreakpoints()",
          "5617:     {",
          "5618:         if (this->GetDebugContext() != nullptr && this->GetDebugContext()->GetProbeContainer() != nullptr)",
          "5619:         {",
          "5620:             return this->GetDebugContext()->GetProbeContainer()->HasMutationBreakpoints();",
          "5621:         }",
          "5622:         return false;",
          "5623:     }",
          "5625:     void ScriptContext::InsertMutationBreakpoint(Js::MutationBreakpoint *mutationBreakpoint)",
          "5626:     {",
          "5627:         this->GetDebugContext()->GetProbeContainer()->InsertMutationBreakpoint(mutationBreakpoint);",
          "5628:     }",
          "5629: #endif",
          "5631: #ifdef REJIT_STATS",
          "5632:     void ScriptContext::LogDataForFunctionBody(Js::FunctionBody *body, uint idx, bool isRejit)",
          "5633:     {",
          "5634:         if (rejitStatsMap == NULL)",
          "5635:         {",
          "5636:             rejitStatsMap = RecyclerNew(this->recycler, RejitStatsMap, this->recycler);",
          "5637:             BindReference(rejitStatsMap);",
          "5638:         }",
          "5640:         RejitStats *stats = NULL;",
          "5641:         if (!rejitStatsMap->TryGetValue(body, &stats))",
          "5642:         {",
          "5643:             stats = Anew(GeneralAllocator(), RejitStats, this);",
          "5644:             rejitStatsMap->Item(body, stats);",
          "5645:         }",
          "5647:         if (isRejit)",
          "5648:         {",
          "5649:             stats->m_rejitReasonCounts[idx]++;",
          "5650:         }",
          "5651:         else",
          "5652:         {",
          "5653:             if (!stats->m_bailoutReasonCounts->ContainsKey(idx))",
          "5654:             {",
          "5655:                 stats->m_bailoutReasonCounts->Item(idx, 1);",
          "5656:             }",
          "5657:             else",
          "5658:             {",
          "5659:                 uint val = stats->m_bailoutReasonCounts->Item(idx);",
          "5660:                 ++val;",
          "5661:                 stats->m_bailoutReasonCounts->Item(idx, val);",
          "5662:             }",
          "5663:         }",
          "5664:     }",
          "5665:     void ScriptContext::LogRejit(Js::FunctionBody *body, uint reason)",
          "5666:     {",
          "5667:         Assert(reason < NumRejitReasons);",
          "5668:         rejitReasonCounts[reason]++;",
          "5670:         if (Js::Configuration::Global.flags.Verbose)",
          "5671:         {",
          "5672:             LogDataForFunctionBody(body, reason, true);",
          "5673:         }",
          "5674:     }",
          "5675:     void ScriptContext::LogBailout(Js::FunctionBody *body, uint kind)",
          "5676:     {",
          "5677:         if (!bailoutReasonCounts->ContainsKey(kind))",
          "5678:         {",
          "5679:             bailoutReasonCounts->Item(kind, 1);",
          "5680:         }",
          "5681:         else",
          "5682:         {",
          "5683:             uint val = bailoutReasonCounts->Item(kind);",
          "5684:             ++val;",
          "5685:             bailoutReasonCounts->Item(kind, val);",
          "5686:         }",
          "5688:         if (Js::Configuration::Global.flags.Verbose)",
          "5689:         {",
          "5690:             LogDataForFunctionBody(body, kind, false);",
          "5691:         }",
          "5692:     }",
          "5693: #endif",
          "5695: #ifdef ENABLE_BASIC_TELEMETRY",
          "5696:     ScriptContextTelemetry& ScriptContext::GetTelemetry()",
          "5697:     {",
          "5698:         return *this->telemetry;",
          "5699:     }",
          "5700:     bool ScriptContext::HasTelemetry()",
          "5701:     {",
          "5702:         return this->telemetry != nullptr;",
          "5703:     }",
          "5704: #endif",
          "5706:     bool ScriptContext::IsScriptContextInNonDebugMode() const",
          "5707:     {",
          "5708:         if (this->debugContext != nullptr)",
          "5709:         {",
          "5710:             return this->GetDebugContext()->IsDebugContextInNonDebugMode();",
          "5711:         }",
          "5712:         return true;",
          "5713:     }",
          "5715:     bool ScriptContext::IsScriptContextInDebugMode() const",
          "5716:     {",
          "5717:         if (this->debugContext != nullptr)",
          "5718:         {",
          "5719:             return this->GetDebugContext()->IsDebugContextInDebugMode();",
          "5720:         }",
          "5721:         return false;",
          "5722:     }",
          "5724:     bool ScriptContext::IsScriptContextInSourceRundownOrDebugMode() const",
          "5725:     {",
          "5726:         if (this->debugContext != nullptr)",
          "5727:         {",
          "5728:             return this->GetDebugContext()->IsDebugContextInSourceRundownOrDebugMode();",
          "5729:         }",
          "5730:         return false;",
          "5731:     }",
          "5733:     bool ScriptContext::IsIntlEnabled()",
          "5734:     {",
          "5735:         if (GetConfig()->IsIntlEnabled())",
          "5736:         {",
          "5737: #ifdef ENABLE_GLOBALIZATION",
          "5739:             Js::DelayLoadWindowsGlobalization* globLibrary = GetThreadContext()->GetWindowsGlobalizationLibrary();",
          "5740:             return globLibrary->HasGlobalizationDllLoaded();",
          "5741: #endif",
          "5742:         }",
          "5743:         return false;",
          "5744:     }",
          "5747: #ifdef INLINE_CACHE_STATS",
          "5748:     void ScriptContext::LogCacheUsage(Js::PolymorphicInlineCache *cache, bool isGetter, Js::PropertyId propertyId, bool hit, bool collision)",
          "5749:     {",
          "5750:         if (cacheDataMap == NULL)",
          "5751:         {",
          "5752:             cacheDataMap = RecyclerNew(this->recycler, CacheDataMap, this->recycler);",
          "5753:             BindReference(cacheDataMap);",
          "5754:         }",
          "5756:         CacheData *data = NULL;",
          "5757:         if (!cacheDataMap->TryGetValue(cache, &data))",
          "5758:         {",
          "5759:             data = Anew(GeneralAllocator(), CacheData);",
          "5760:             cacheDataMap->Item(cache, data);",
          "5761:             data->isGetCache = isGetter;",
          "5762:             data->propertyId = propertyId;",
          "5763:         }",
          "5765:         Assert(data->isGetCache == isGetter);",
          "5766:         Assert(data->propertyId == propertyId);",
          "5768:         if (hit)",
          "5769:         {",
          "5770:             data->hits++;",
          "5771:         }",
          "5772:         else",
          "5773:         {",
          "5774:             data->misses++;",
          "5775:         }",
          "5776:         if (collision)",
          "5777:         {",
          "5778:             data->collisions++;",
          "5779:         }",
          "5780:     }",
          "5781: #endif",
          "5783: #ifdef FIELD_ACCESS_STATS",
          "5784:     void ScriptContext::RecordFieldAccessStats(FunctionBody* functionBody, FieldAccessStatsPtr fieldAccessStats)",
          "5785:     {",
          "5786:         Assert(fieldAccessStats != nullptr);",
          "5788:         if (!PHASE_STATS1(Js::ObjTypeSpecPhase))",
          "5789:         {",
          "5790:             return;",
          "5791:         }",
          "5793:         FieldAccessStatsEntry* entry;",
          "5794:         if (!this->fieldAccessStatsByFunctionNumber->TryGetValue(functionBody->GetFunctionNumber(), &entry))",
          "5795:         {",
          "5796:             RecyclerWeakReference<FunctionBody>* functionBodyWeakRef;",
          "5797:             this->recycler->FindOrCreateWeakReferenceHandle(functionBody, &functionBodyWeakRef);",
          "5798:             entry = RecyclerNew(this->recycler, FieldAccessStatsEntry, functionBodyWeakRef, this->recycler);",
          "5800:             this->fieldAccessStatsByFunctionNumber->AddNew(functionBody->GetFunctionNumber(), entry);",
          "5801:         }",
          "5803:         entry->stats.Prepend(fieldAccessStats);",
          "5804:     }",
          "5805: #endif",
          "5807: #ifdef MISSING_PROPERTY_STATS",
          "5808:     void ScriptContext::RecordMissingPropertyMiss()",
          "5809:     {",
          "5810:         this->missingPropertyMisses++;",
          "5811:     }",
          "5813:     void ScriptContext::RecordMissingPropertyHit()",
          "5814:     {",
          "5815:         this->missingPropertyHits++;",
          "5816:     }",
          "5818:     void ScriptContext::RecordMissingPropertyCacheAttempt()",
          "5819:     {",
          "5820:         this->missingPropertyCacheAttempts++;",
          "5821:     }",
          "5822: #endif",
          "5824:     bool ScriptContext::IsIntConstPropertyOnGlobalObject(Js::PropertyId propId)",
          "5825:     {",
          "5826:         return intConstPropsOnGlobalObject->ContainsKey(propId);",
          "5827:     }",
          "5829:     void ScriptContext::TrackIntConstPropertyOnGlobalObject(Js::PropertyId propertyId)",
          "5830:     {",
          "5831:         intConstPropsOnGlobalObject->AddNew(propertyId);",
          "5832:     }",
          "5834:     bool ScriptContext::IsIntConstPropertyOnGlobalUserObject(Js::PropertyId propertyId)",
          "5835:     {",
          "5836:         return intConstPropsOnGlobalUserObject->ContainsKey(propertyId) != NULL;",
          "5837:     }",
          "5839:     void ScriptContext::TrackIntConstPropertyOnGlobalUserObject(Js::PropertyId propertyId)",
          "5840:     {",
          "5841:         intConstPropsOnGlobalUserObject->AddNew(propertyId);",
          "5842:     }",
          "5844:     void ScriptContext::AddCalleeSourceInfoToList(Utf8SourceInfo* sourceInfo)",
          "5845:     {",
          "5846:         Assert(sourceInfo);",
          "5848:         RecyclerWeakReference<Js::Utf8SourceInfo>* sourceInfoWeakRef = nullptr;",
          "5849:         this->GetRecycler()->FindOrCreateWeakReferenceHandle(sourceInfo, &sourceInfoWeakRef);",
          "5850:         Assert(sourceInfoWeakRef);",
          "5852:         if (!calleeUtf8SourceInfoList)",
          "5853:         {",
          "5854:             Recycler *recycler = this->GetRecycler();",
          "5855:             calleeUtf8SourceInfoList.Root(RecyclerNew(recycler, CalleeSourceList, recycler), recycler);",
          "5856:         }",
          "5858:         if (!calleeUtf8SourceInfoList->Contains(sourceInfoWeakRef))",
          "5859:         {",
          "5860:             calleeUtf8SourceInfoList->Add(sourceInfoWeakRef);",
          "5861:         }",
          "5862:     }",
          "5864: #ifdef ENABLE_JS_ETW",
          "5865:     void ScriptContext::EmitStackTraceEvent(__in UINT64 operationID, __in USHORT maxFrameCount, bool emitV2AsyncStackEvent)",
          "5866:     {",
          "5868:         if (GetThreadContext()->GetCallRootLevel() == 0)",
          "5869:         {",
          "5870:             return;",
          "5871:         }",
          "5873:         Assert(EventEnabledJSCRIPT_STACKTRACE() || EventEnabledJSCRIPT_ASYNCCAUSALITY_STACKTRACE_V2() || PHASE_TRACE1(Js::StackFramesEventPhase));",
          "5874:         BEGIN_TEMP_ALLOCATOR(tempAllocator, this, _u(\"StackTraceEvent\"))",
          "5875:         {",
          "5876:             JsUtil::List<StackFrameInfo, ArenaAllocator> stackFrames(tempAllocator);",
          "5877:             Js::JavascriptStackWalker walker(this);",
          "5878:             unsigned short nameBufferLength = 0;",
          "5879:             Js::StringBuilder<ArenaAllocator> nameBuffer(tempAllocator);",
          "5880:             nameBuffer.Reset();",
          "5882:             OUTPUT_TRACE(Js::StackFramesEventPhase, _u(\"\\nPosting stack trace via ETW:\\n\"));",
          "5884:             ushort frameCount = walker.WalkUntil((ushort)maxFrameCount, [&](Js::JavascriptFunction* function, ushort frameIndex) -> bool",
          "5885:             {",
          "5886:                 ULONG lineNumber = 0;",
          "5887:                 LONG columnNumber = 0;",
          "5888:                 UINT32 methodIdOrNameId = 0;",
          "5889:                 UINT8 isFrameIndex = 0; // FALSE",
          "5890:                 const WCHAR* name = nullptr;",
          "5891:                 if (function->IsScriptFunction() && !function->IsLibraryCode())",
          "5892:                 {",
          "5893:                     Js::FunctionBody * functionBody = function->GetFunctionBody();",
          "5894:                     functionBody->GetLineCharOffset(walker.GetByteCodeOffset(), &lineNumber, &columnNumber);",
          "5895:                     methodIdOrNameId = EtwTrace::GetFunctionId(functionBody);",
          "5896:                     name = functionBody->GetExternalDisplayName();",
          "5897:                 }",
          "5898:                 else",
          "5899:                 {",
          "5900:                     if (function->IsScriptFunction())",
          "5901:                     {",
          "5902:                         name = function->GetFunctionBody()->GetExternalDisplayName();",
          "5903:                     }",
          "5904:                     else",
          "5905:                     {",
          "5906:                         name = walker.GetCurrentNativeLibraryEntryName();",
          "5907:                     }",
          "5909:                     ushort nameLen = ProcessNameAndGetLength(&nameBuffer, name);",
          "5911:                     methodIdOrNameId = nameBufferLength;",
          "5914:                     nameBufferLength += nameLen;",
          "5916:                     isFrameIndex = 1; // TRUE;",
          "5917:                 }",
          "5919:                 StackFrameInfo frame((DWORD_PTR)function->GetScriptContext(),",
          "5920:                     (UINT32)lineNumber,",
          "5921:                     (UINT32)columnNumber,",
          "5922:                     methodIdOrNameId,",
          "5923:                     isFrameIndex);",
          "5925:                 OUTPUT_TRACE(Js::StackFramesEventPhase, _u(\"Frame : (%s : %u) (%s), LineNumber : %u, ColumnNumber : %u\\n\"),",
          "5926:                     (isFrameIndex == 1) ? (_u(\"NameBufferIndex\")) : (_u(\"MethodID\")),",
          "5927:                     methodIdOrNameId,",
          "5928:                     name,",
          "5929:                     lineNumber,",
          "5930:                     columnNumber);",
          "5932:                 stackFrames.Add(frame);",
          "5934:                 return false;",
          "5935:             });",
          "5937:             Assert(frameCount == (ushort)stackFrames.Count());",
          "5939:             if (frameCount > 0) // No need to emit event if there are no script frames.",
          "5940:             {",
          "5941:                 auto nameBufferString = nameBuffer.Detach();",
          "5943:                 if (nameBufferLength > 0)",
          "5944:                 {",
          "5946:                     nameBufferLength++;",
          "5947:                 }",
          "5949:                 if (emitV2AsyncStackEvent)",
          "5950:                 {",
          "5951:                     JS_ETW(EventWriteJSCRIPT_ASYNCCAUSALITY_STACKTRACE_V2(operationID, frameCount, nameBufferLength, sizeof(StackFrameInfo), &stackFrames.Item(0), nameBufferString));",
          "5952:                 }",
          "5953:                 else",
          "5954:                 {",
          "5955:                     JS_ETW(EventWriteJSCRIPT_STACKTRACE(operationID, frameCount, nameBufferLength, sizeof(StackFrameInfo), &stackFrames.Item(0), nameBufferString));",
          "5956:                 }",
          "5957:             }",
          "5958:         }",
          "5959:         END_TEMP_ALLOCATOR(tempAllocator, this);",
          "5961:         OUTPUT_FLUSH();",
          "5962:     }",
          "5963: #endif",
          "5973:     charcount_t ScriptContext::AppendWithEscapeCharacters(Js::StringBuilder<ArenaAllocator>* stringBuilder, const WCHAR* sourceString, charcount_t sourceStringLen, WCHAR escapeChar, WCHAR charToEscape)",
          "5974:     {",
          "5975:         const WCHAR* charToEscapePtr = wcschr(sourceString, charToEscape);",
          "5976:         charcount_t charsPadding = 0;",
          "5979:         if (charToEscapePtr)",
          "5980:         {",
          "5981:             charcount_t charsWritten = 0;",
          "5982:             charcount_t charsToAppend = 0;",
          "5984:             while (charToEscapePtr)",
          "5985:             {",
          "5986:                 charsToAppend = static_cast<charcount_t>(charToEscapePtr - sourceString) - charsWritten;",
          "5988:                 stringBuilder->Append(sourceString + charsWritten, charsToAppend);",
          "5989:                 stringBuilder->Append(escapeChar);",
          "5990:                 stringBuilder->Append(charToEscape);",
          "5993:                 charsPadding++;",
          "5996:                 charsWritten += charsToAppend + 1;",
          "5999:                 charToEscapePtr++;",
          "6000:                 charToEscapePtr = wcschr(charToEscapePtr, charToEscape);",
          "6001:             }",
          "6004:             if (charsWritten != sourceStringLen)",
          "6005:             {",
          "6006:                 charsToAppend = sourceStringLen - charsWritten;",
          "6007:                 stringBuilder->Append(sourceString + charsWritten, charsToAppend);",
          "6008:             }",
          "6009:         }",
          "6010:         else",
          "6011:         {",
          "6012:             stringBuilder->AppendSz(sourceString);",
          "6013:         }",
          "6015:         return sourceStringLen + charsPadding;",
          "6016:     }",
          "6019:     ushort ScriptContext::ProcessNameAndGetLength(Js::StringBuilder<ArenaAllocator>* nameBuffer, const WCHAR* name)",
          "6020:     {",
          "6021:         Assert(nameBuffer);",
          "6022:         Assert(name);",
          "6024:         ushort nameLen = (ushort)wcslen(name);",
          "6027:         nameBuffer->Append('\\\"');",
          "6030:         nameLen = (unsigned short)AppendWithEscapeCharacters(nameBuffer, name, nameLen, '\\\\', '\\\"');",
          "6032:         nameBuffer->AppendCppLiteral(_u(\"\\\";\"));",
          "6035:         nameLen += 3;",
          "6037:         return nameLen;",
          "6038:     }",
          "6040:     Field(Js::Var)* ScriptContext::GetModuleExportSlotArrayAddress(uint moduleIndex, uint slotIndex)",
          "6041:     {",
          "6042:         Js::SourceTextModuleRecord* moduleRecord = this->GetModuleRecord(moduleIndex);",
          "6043:         Assert(moduleRecord != nullptr);",
          "6046:         if (moduleRecord->GetLocalExportCount() + 1 <= slotIndex)",
          "6047:         {",
          "6048:             Js::Throw::FatalInternalError();",
          "6049:         }",
          "6051:         return moduleRecord->GetLocalExportSlots();",
          "6052:     }",
          "6054:     void JITPageAddrToFuncRangeCache::ClearCache()",
          "6055:     {",
          "6056:         if (jitPageAddrToFuncRangeMap != nullptr)",
          "6057:         {",
          "6058:             jitPageAddrToFuncRangeMap->Map(",
          "6059:                 [](void* key, RangeMap* value) {",
          "6060:                 HeapDelete(value);",
          "6061:             });",
          "6063:             HeapDelete(jitPageAddrToFuncRangeMap);",
          "6064:             jitPageAddrToFuncRangeMap = nullptr;",
          "6065:         }",
          "6067:         if (largeJitFuncToSizeMap != nullptr)",
          "6068:         {",
          "6069:             HeapDelete(largeJitFuncToSizeMap);",
          "6070:             largeJitFuncToSizeMap = nullptr;",
          "6071:         }",
          "6072:     }",
          "6074:     void JITPageAddrToFuncRangeCache::AddFuncRange(void * address, uint bytes)",
          "6075:     {",
          "6076:         AutoCriticalSection autocs(GetCriticalSection());",
          "6078:         if (bytes <= AutoSystemInfo::PageSize)",
          "6079:         {",
          "6080:             if (jitPageAddrToFuncRangeMap == nullptr)",
          "6081:             {",
          "6082:                 jitPageAddrToFuncRangeMap = HeapNew(JITPageAddrToFuncRangeMap, &HeapAllocator::Instance);",
          "6083:             }",
          "6085:             void * pageAddr = GetPageAddr(address);",
          "6086:             RangeMap * rangeMap = nullptr;",
          "6087:             bool isPageAddrFound = jitPageAddrToFuncRangeMap->TryGetValue(pageAddr, &rangeMap);",
          "6088:             if (rangeMap == nullptr)",
          "6089:             {",
          "6090:                 Assert(!isPageAddrFound);",
          "6091:                 rangeMap = HeapNew(RangeMap, &HeapAllocator::Instance);",
          "6092:                 jitPageAddrToFuncRangeMap->Add(pageAddr, rangeMap);",
          "6093:             }",
          "6094:             uint byteCount = 0;",
          "6095:             Assert(!rangeMap->TryGetValue(address, &byteCount));",
          "6096:             rangeMap->Add(address, bytes);",
          "6097:         }",
          "6098:         else",
          "6099:         {",
          "6100:             if (largeJitFuncToSizeMap == nullptr)",
          "6101:             {",
          "6102:                 largeJitFuncToSizeMap = HeapNew(LargeJITFuncAddrToSizeMap, &HeapAllocator::Instance);",
          "6103:             }",
          "6105:             uint byteCount = 0;",
          "6106:             Assert(!largeJitFuncToSizeMap->TryGetValue(address, &byteCount));",
          "6107:             largeJitFuncToSizeMap->Add(address, bytes);",
          "6108:         }",
          "6109:     }",
          "6111:     void* JITPageAddrToFuncRangeCache::GetPageAddr(void * address)",
          "6112:     {",
          "6113:         return (void*)((uintptr_t)address & ~(AutoSystemInfo::PageSize - 1));",
          "6114:     }",
          "6116:     void JITPageAddrToFuncRangeCache::RemoveFuncRange(void * address)",
          "6117:     {",
          "6118:         AutoCriticalSection autocs(GetCriticalSection());",
          "6120:         void * pageAddr = GetPageAddr(address);",
          "6122:         RangeMap * rangeMap = nullptr;",
          "6123:         uint bytes = 0;",
          "6124:         if (jitPageAddrToFuncRangeMap && jitPageAddrToFuncRangeMap->TryGetValue(pageAddr, &rangeMap))",
          "6125:         {",
          "6126:             Assert(rangeMap->Count() != 0);",
          "6127:             rangeMap->Remove(address);",
          "6129:             if (rangeMap->Count() == 0)",
          "6130:             {",
          "6131:                 HeapDelete(rangeMap);",
          "6132:                 rangeMap = nullptr;",
          "6133:                 jitPageAddrToFuncRangeMap->Remove(pageAddr);",
          "6134:             }",
          "6135:             return;",
          "6136:         }",
          "6137:         else if (largeJitFuncToSizeMap && largeJitFuncToSizeMap->TryGetValue(address, &bytes))",
          "6138:         {",
          "6139:             largeJitFuncToSizeMap->Remove(address);",
          "6140:         }",
          "6141:         else",
          "6142:         {",
          "6143:             AssertMsg(false, \"Page address not found to remove the func range\");",
          "6144:         }",
          "6145:     }",
          "6147:     bool JITPageAddrToFuncRangeCache::IsNativeAddr(void * address)",
          "6148:     {",
          "6149:         AutoCriticalSection autocs(GetCriticalSection());",
          "6151:         void * pageAddr = GetPageAddr(address);",
          "6152:         RangeMap * rangeMap = nullptr;",
          "6153:         if (jitPageAddrToFuncRangeMap && jitPageAddrToFuncRangeMap->TryGetValue(pageAddr, &rangeMap))",
          "6154:         {",
          "6155:             if (rangeMap->MapUntil(",
          "6156:                 [&](void* key, uint value) {",
          "6157:                 return (key <= address && (uintptr_t)address < ((uintptr_t)key + value));",
          "6158:             }))",
          "6159:             {",
          "6160:                 return true;",
          "6161:             }",
          "6162:         }",
          "6164:         return largeJitFuncToSizeMap && largeJitFuncToSizeMap->MapUntil(",
          "6165:             [&](void *key, uint value) {",
          "6166:             return (key <= address && (uintptr_t)address < ((uintptr_t)key + value));",
          "6167:         });",
          "6168:     }",
          "6170:     JITPageAddrToFuncRangeCache::JITPageAddrToFuncRangeMap * JITPageAddrToFuncRangeCache::GetJITPageAddrToFuncRangeMap()",
          "6171:     {",
          "6172:         return jitPageAddrToFuncRangeMap;",
          "6173:     }",
          "6175:     JITPageAddrToFuncRangeCache::LargeJITFuncAddrToSizeMap * JITPageAddrToFuncRangeCache::GetLargeJITFuncAddrToSizeMap()",
          "6176:     {",
          "6177:         return largeJitFuncToSizeMap;",
          "6178:     }",
          "6180: } // End namespace Js",
          "",
          "[Added Lines]",
          "5: #include \"RuntimeBasePch.h\"",
          "8: #include \"RegexCommon.h\"",
          "9: #include \"DebugWriter.h\"",
          "10: #include \"RegexStats.h\"",
          "12: #include \"ByteCode/ByteCodeApi.h\"",
          "13: #include \"Library/ProfileString.h\"",
          "14: #include \"Debug/DiagHelperMethodWrapper.h\"",
          "15: #include \"BackendApi.h\"",
          "16: #if PROFILE_DICTIONARY",
          "17: #include \"DictionaryStats.h\"",
          "18: #endif",
          "20: #include \"Base/ScriptContextProfiler.h\"",
          "21: #include \"Base/EtwTrace.h\"",
          "23: #include \"Language/InterpreterStackFrame.h\"",
          "24: #include \"Language/SourceDynamicProfileManager.h\"",
          "25: #include \"Language/JavascriptStackWalker.h\"",
          "26: #include \"Language/AsmJsTypes.h\"",
          "27: #include \"Language/AsmJsModule.h\"",
          "28: #ifdef ASMJS_PLAT",
          "29: #include \"Language/AsmJsEncoder.h\"",
          "30: #include \"Language/AsmJsCodeGenerator.h\"",
          "31: #include \"Language/AsmJsUtils.h\"",
          "32: #endif",
          "34: #ifdef ENABLE_BASIC_TELEMETRY",
          "35: #include \"ScriptContextTelemetry.h\"",
          "36: #endif",
          "38: namespace Js",
          "39: {",
          "40:     ScriptContext * ScriptContext::New(ThreadContext * threadContext)",
          "41:     {",
          "42:         AutoPtr<ScriptContext> scriptContext(HeapNew(ScriptContext, threadContext));",
          "43:         scriptContext->InitializeAllocations();",
          "44:         return scriptContext.Detach();",
          "45:     }",
          "47:     void ScriptContext::Delete(ScriptContext* scriptContext)",
          "48:     {",
          "49:         HeapDelete(scriptContext);",
          "50:     }",
          "52:     CriticalSection JITPageAddrToFuncRangeCache::cs;",
          "54:     ScriptContext::ScriptContext(ThreadContext* threadContext) :",
          "55:         ScriptContextBase(),",
          "56:         prev(nullptr),",
          "57:         next(nullptr),",
          "58:         interpreterArena(nullptr),",
          "59:         moduleSrcInfoCount(0),",
          "61: #if ENABLE_REGEX_CONFIG_OPTIONS",
          "62:         regexStatsDatabase(0),",
          "63:         regexDebugWriter(0),",
          "64: #endif",
          "65:         trigramAlphabet(nullptr),",
          "66:         regexStacks(nullptr),",
          "67:         arrayMatchInit(false),",
          "68:         config(threadContext->GetConfig(), threadContext->IsOptimizedForManyInstances()),",
          "69: #if ENABLE_BACKGROUND_PARSING",
          "70:         backgroundParser(nullptr),",
          "71: #endif",
          "72: #if ENABLE_NATIVE_CODEGEN",
          "73:         nativeCodeGen(nullptr),",
          "74:         m_domFastPathHelperMap(nullptr),",
          "75: #endif",
          "76:         threadContext(threadContext),",
          "77:         scriptStartEventHandler(nullptr),",
          "78:         scriptEndEventHandler(nullptr),",
          "79: #ifdef FAULT_INJECTION",
          "80:         disposeScriptByFaultInjectionEventHandler(nullptr),",
          "81: #endif",
          "82:         integerStringMap(this->GeneralAllocator()),",
          "83:         guestArena(nullptr),",
          "84:         raiseMessageToDebuggerFunctionType(nullptr),",
          "85:         transitionToDebugModeIfFirstSourceFn(nullptr),",
          "86:         sourceSize(0),",
          "87:         deferredBody(false),",
          "88:         isScriptContextActuallyClosed(false),",
          "89:         isFinalized(false),",
          "90:         isEvalRestricted(false),",
          "91:         isInvalidatedForHostObjects(false),",
          "92:         fastDOMenabled(false),",
          "93:         directHostTypeId(TypeIds_GlobalObject),",
          "94:         isPerformingNonreentrantWork(false),",
          "95:         isDiagnosticsScriptContext(false),",
          "96:         m_enumerateNonUserFunctionsOnly(false),",
          "97:         recycler(threadContext->EnsureRecycler()),",
          "98:         CurrentThunk(DefaultEntryThunk),",
          "99:         CurrentCrossSiteThunk(CrossSite::DefaultThunk),",
          "100:         DeferredParsingThunk(DefaultDeferredParsingThunk),",
          "101:         DeferredDeserializationThunk(DefaultDeferredDeserializeThunk),",
          "102:         DispatchDefaultInvoke(nullptr),",
          "103:         DispatchProfileInvoke(nullptr),",
          "104:         m_pBuiltinFunctionIdMap(nullptr),",
          "105:         diagnosticArena(nullptr),",
          "106:         hostScriptContext(nullptr),",
          "107:         scriptEngineHaltCallback(nullptr),",
          "108: #if DYNAMIC_INTERPRETER_THUNK",
          "109:         interpreterThunkEmitter(nullptr),",
          "110: #endif",
          "111: #ifdef ASMJS_PLAT",
          "112:         asmJsInterpreterThunkEmitter(nullptr),",
          "113:         asmJsCodeGenerator(nullptr),",
          "114: #endif",
          "115:         generalAllocator(_u(\"SC-General\"), threadContext->GetPageAllocator(), Throw::OutOfMemory),",
          "116: #ifdef ENABLE_BASIC_TELEMETRY",
          "117:         telemetryAllocator(_u(\"SC-Telemetry\"), threadContext->GetPageAllocator(), Throw::OutOfMemory),",
          "118: #endif",
          "119:         dynamicProfileInfoAllocator(_u(\"SC-DynProfileInfo\"), threadContext->GetPageAllocator(), Throw::OutOfMemory),",
          "120: #ifdef SEPARATE_ARENA",
          "121:         sourceCodeAllocator(_u(\"SC-Code\"), threadContext->GetPageAllocator(), Throw::OutOfMemory),",
          "122:         regexAllocator(_u(\"SC-Regex\"), threadContext->GetPageAllocator(), Throw::OutOfMemory),",
          "123: #endif",
          "124: #ifdef NEED_MISC_ALLOCATOR",
          "125:         miscAllocator(_u(\"GC-Misc\"), threadContext->GetPageAllocator(), Throw::OutOfMemory),",
          "126: #endif",
          "127:         inlineCacheAllocator(_u(\"SC-InlineCache\"), threadContext->GetPageAllocator(), Throw::OutOfMemory),",
          "128:         isInstInlineCacheAllocator(_u(\"SC-IsInstInlineCache\"), threadContext->GetPageAllocator(), Throw::OutOfMemory),",
          "129:         forInCacheAllocator(_u(\"SC-ForInCache\"), threadContext->GetPageAllocator(), Throw::OutOfMemory),",
          "130:         hasUsedInlineCache(false),",
          "131:         hasProtoOrStoreFieldInlineCache(false),",
          "132:         hasIsInstInlineCache(false),",
          "133:         registeredPrototypeChainEnsuredToHaveOnlyWritableDataPropertiesScriptContext(nullptr),",
          "134:         firstInterpreterFrameReturnAddress(nullptr),",
          "135:         builtInLibraryFunctions(nullptr),",
          "136:         m_remoteScriptContextAddr(nullptr),",
          "137:         isWeakReferenceDictionaryListCleared(false),",
          "138:         isDebugContextInitialized(false)",
          "139: #if ENABLE_PROFILE_INFO",
          "140:         , referencesSharedDynamicSourceContextInfo(false)",
          "141: #endif",
          "142: #if DBG",
          "143:         , isInitialized(false)",
          "144:         , isCloningGlobal(false)",
          "145:         , bindRef(MiscAllocator())",
          "146: #endif",
          "147: #if ENABLE_TTD",
          "148:         , TTDHostCallbackFunctor()",
          "149:         , ScriptContextLogTag(TTD_INVALID_LOG_PTR_ID)",
          "150:         , TTDWellKnownInfo(nullptr)",
          "151:         , TTDContextInfo(nullptr)",
          "152:         , TTDSnapshotOrInflateInProgress(false)",
          "153:         , TTDRecordOrReplayModeEnabled(false)",
          "154:         , TTDRecordModeEnabled(false)",
          "155:         , TTDReplayModeEnabled(false)",
          "156:         , TTDShouldPerformRecordOrReplayAction(false)",
          "157:         , TTDShouldPerformRecordAction(false)",
          "158:         , TTDShouldPerformReplayAction(false)",
          "159:         , TTDShouldPerformDebuggerAction(false)",
          "160:         , TTDShouldSuppressGetterInvocationForDebuggerEvaluation(false)",
          "161: #endif",
          "162: #ifdef REJIT_STATS",
          "163:         , rejitStatsMap(nullptr)",
          "164: #endif",
          "165: #ifdef ENABLE_BASIC_TELEMETRY",
          "166:         , telemetry(nullptr)",
          "167: #endif",
          "168: #ifdef INLINE_CACHE_STATS",
          "169:         , cacheDataMap(nullptr)",
          "170: #endif",
          "171: #ifdef FIELD_ACCESS_STATS",
          "172:         , fieldAccessStatsByFunctionNumber(nullptr)",
          "173: #endif",
          "174:         , webWorkerId(Js::Constants::NonWebWorkerContextId)",
          "175:         , url(_u(\"\"))",
          "176:         , startupComplete(false)",
          "177:         , isEnumeratingRecyclerObjects(false)",
          "178: #ifdef EDIT_AND_CONTINUE",
          "179:         , activeScriptEditQuery(nullptr)",
          "180: #endif",
          "181: #ifdef ENABLE_SCRIPT_PROFILING",
          "182:         , heapEnum(nullptr)",
          "183: #endif",
          "184: #ifdef RECYCLER_PERF_COUNTERS",
          "185:         , bindReferenceCount(0)",
          "186: #endif",
          "187:         , nextPendingClose(nullptr)",
          "188: #ifdef ENABLE_SCRIPT_PROFILING",
          "189:         , m_fTraceDomCall(FALSE)",
          "190: #endif",
          "191:         , intConstPropsOnGlobalObject(nullptr)",
          "192:         , intConstPropsOnGlobalUserObject(nullptr)",
          "193: #ifdef PROFILE_STRINGS",
          "194:         , stringProfiler(nullptr)",
          "195: #endif",
          "196: #ifdef PROFILE_BAILOUT_RECORD_MEMORY",
          "197:         , codeSize(0)",
          "198:         , bailOutRecordBytes(0)",
          "199:         , bailOutOffsetBytes(0)",
          "200: #endif",
          "201:         , debugContext(nullptr)",
          "202:         , jitFuncRangeCache(nullptr)",
          "203:     {",
          "206:        threadContext->EnsureDebugManager();",
          "210:        BEGIN_NO_EXCEPTION;",
          "212: #ifdef RUNTIME_DATA_COLLECTION",
          "213:         createTime = time(nullptr);",
          "214: #endif",
          "216: #ifdef BGJIT_STATS",
          "217:         interpretedCount = maxFuncInterpret = funcJITCount = bytecodeJITCount = interpretedCallsHighPri = jitCodeUsed = funcJitCodeUsed = loopJITCount = speculativeJitCount = 0;",
          "218: #endif",
          "220: #ifdef PROFILE_TYPES",
          "221:         convertNullToSimpleCount = 0;",
          "222:         convertNullToSimpleDictionaryCount = 0;",
          "223:         convertNullToDictionaryCount = 0;",
          "224:         convertDeferredToDictionaryCount = 0;",
          "225:         convertDeferredToSimpleDictionaryCount = 0;",
          "226:         convertSimpleToDictionaryCount = 0;",
          "227:         convertSimpleToSimpleDictionaryCount = 0;",
          "228:         convertPathToDictionaryCount1 = 0;",
          "229:         convertPathToDictionaryCount2 = 0;",
          "230:         convertPathToDictionaryCount3 = 0;",
          "231:         convertPathToDictionaryCount4 = 0;",
          "232:         convertPathToSimpleDictionaryCount = 0;",
          "233:         convertSimplePathToPathCount = 0;",
          "234:         convertSimpleDictionaryToDictionaryCount = 0;",
          "235:         convertSimpleSharedDictionaryToNonSharedCount = 0;",
          "236:         convertSimpleSharedToNonSharedCount = 0;",
          "237:         simplePathTypeHandlerCount = 0;",
          "238:         pathTypeHandlerCount = 0;",
          "239:         promoteCount = 0;",
          "240:         cacheCount = 0;",
          "241:         branchCount = 0;",
          "242:         maxPathLength = 0;",
          "243:         memset(typeCount, 0, sizeof(typeCount));",
          "244:         memset(instanceCount, 0, sizeof(instanceCount));",
          "245: #endif",
          "247: #ifdef PROFILE_OBJECT_LITERALS",
          "248:         objectLiteralInstanceCount = 0;",
          "249:         objectLiteralPathCount = 0;",
          "250:         memset(objectLiteralCount, 0, sizeof(objectLiteralCount));",
          "251:         objectLiteralSimpleDictionaryCount = 0;",
          "252:         objectLiteralMaxLength = 0;",
          "253:         objectLiteralPromoteCount = 0;",
          "254:         objectLiteralCacheCount = 0;",
          "255:         objectLiteralBranchCount = 0;",
          "256: #endif",
          "257: #if DBG_DUMP",
          "258:         byteCodeDataSize = 0;",
          "259:         byteCodeAuxiliaryDataSize = 0;",
          "260:         byteCodeAuxiliaryContextDataSize = 0;",
          "261:         memset(byteCodeHistogram, 0, sizeof(byteCodeHistogram));",
          "262: #endif",
          "264:         memset(propertyStrings, 0, sizeof(PropertyStringMap*)* 80);",
          "266: #if DBG || defined(RUNTIME_DATA_COLLECTION)",
          "267:         this->allocId = threadContext->GetScriptContextCount();",
          "268: #endif",
          "269: #if DBG",
          "270:         this->hadProfiled = false;",
          "271: #endif",
          "272: #if DBG_DUMP",
          "273:         forinCache = 0;",
          "274:         forinNoCache = 0;",
          "275: #endif",
          "277:         callCount = 0;",
          "279:         threadContext->GetHiResTimer()->Reset();",
          "281: #ifdef PROFILE_EXEC",
          "282:         profiler = nullptr;",
          "283:         isProfilerCreated = false;",
          "284:         disableProfiler = false;",
          "285:         ensureParentInfo = false;",
          "286: #endif",
          "288: #ifdef PROFILE_MEM",
          "289:         profileMemoryDump = true;",
          "290: #endif",
          "292: #ifdef ENABLE_SCRIPT_PROFILING",
          "293:         m_pProfileCallback = nullptr;",
          "294:         m_pProfileCallback2 = nullptr;",
          "295:         m_inProfileCallback = FALSE;",
          "296:         CleanupDocumentContext = nullptr;",
          "297: #endif",
          "300:         numberAllocator.Initialize(this->GetRecycler());",
          "302: #if DEBUG",
          "303:         m_iProfileSession = -1;",
          "304: #endif",
          "305: #ifdef LEAK_REPORT",
          "306:         this->urlRecord = nullptr;",
          "307:         this->isRootTrackerScriptContext = false;",
          "308: #endif",
          "310:         PERF_COUNTER_INC(Basic, ScriptContext);",
          "311:         PERF_COUNTER_INC(Basic, ScriptContextActive);",
          "313:         END_NO_EXCEPTION;",
          "314:     }",
          "316:     void ScriptContext::InitializeAllocations()",
          "317:     {",
          "318:         this->charClassifier = Anew(GeneralAllocator(), CharClassifier, this);",
          "320:         this->valueOfInlineCache = AllocatorNewZ(InlineCacheAllocator, GetInlineCacheAllocator(), InlineCache);",
          "321:         this->toStringInlineCache = AllocatorNewZ(InlineCacheAllocator, GetInlineCacheAllocator(), InlineCache);",
          "323: #ifdef REJIT_STATS",
          "324:         if (PHASE_STATS1(Js::ReJITPhase))",
          "325:         {",
          "326:             rejitReasonCounts = AnewArrayZ(GeneralAllocator(), uint, NumRejitReasons);",
          "327:             bailoutReasonCounts = Anew(GeneralAllocator(), BailoutStatsMap, GeneralAllocator());",
          "328:         }",
          "329: #endif",
          "331: #ifdef ENABLE_BASIC_TELEMETRY",
          "332:         this->telemetry = Anew(this->TelemetryAllocator(), ScriptContextTelemetry, *this);",
          "333: #endif",
          "335: #ifdef PROFILE_STRINGS",
          "336:         if (Js::Configuration::Global.flags.ProfileStrings)",
          "337:         {",
          "338:             stringProfiler = Anew(MiscAllocator(), StringProfiler, threadContext->GetPageAllocator());",
          "339:         }",
          "340: #endif",
          "341:         intConstPropsOnGlobalObject = Anew(GeneralAllocator(), PropIdSetForConstProp, GeneralAllocator());",
          "342:         intConstPropsOnGlobalUserObject = Anew(GeneralAllocator(), PropIdSetForConstProp, GeneralAllocator());",
          "344: #if ENABLE_NATIVE_CODEGEN",
          "345:         m_domFastPathHelperMap = HeapNew(JITDOMFastPathHelperMap, &HeapAllocator::Instance, 17);",
          "346: #endif",
          "348:         this->debugContext = HeapNew(DebugContext, this);",
          "349:     }",
          "351:     void ScriptContext::EnsureClearDebugDocument()",
          "352:     {",
          "353:         if (this->sourceList)",
          "354:         {",
          "355:             this->sourceList->Map([=](uint i, RecyclerWeakReference<Js::Utf8SourceInfo>* sourceInfoWeakRef) {",
          "356:                 Js::Utf8SourceInfo* sourceInfo = sourceInfoWeakRef->Get();",
          "357:                 if (sourceInfo)",
          "358:                 {",
          "359:                     sourceInfo->ClearDebugDocument();",
          "360:                 }",
          "361:             });",
          "362:         }",
          "363:     }",
          "365:     void ScriptContext::ShutdownClearSourceLists()",
          "366:     {",
          "367:         if (this->sourceList)",
          "368:         {",
          "373:             if (this->isClosed)",
          "374:             {",
          "375:                 this->MapFunction([this](Js::FunctionBody* functionBody) {",
          "376:                     Assert(functionBody->GetScriptContext() == this);",
          "377:                     functionBody->CleanupSourceInfo(true);",
          "378:                 });",
          "379:             }",
          "381:             EnsureClearDebugDocument();",
          "384:             this->sourceList.Unroot(this->GetRecycler());",
          "385:         }",
          "387:         if (this->calleeUtf8SourceInfoList)",
          "388:         {",
          "389:             this->calleeUtf8SourceInfoList.Unroot(this->GetRecycler());",
          "390:         }",
          "391:     }",
          "393:     ScriptContext::~ScriptContext()",
          "394:     {",
          "396:         AutoCriticalSection autocs(GetThreadContext()->GetEtwRundownCriticalSection());",
          "398: #if ENABLE_NATIVE_CODEGEN",
          "399:         if (m_domFastPathHelperMap != nullptr)",
          "400:         {",
          "401:             HeapDelete(m_domFastPathHelperMap);",
          "402:         }",
          "403: #endif",
          "406:         ClearHostScriptContext();",
          "408:         if (this->hasProtoOrStoreFieldInlineCache)",
          "409:         {",
          "418:             threadContext->ClearInlineCaches();",
          "420:             ClearInlineCaches();",
          "421:             Assert(!this->hasProtoOrStoreFieldInlineCache);",
          "422:         }",
          "424:         if (this->hasIsInstInlineCache)",
          "425:         {",
          "427:             threadContext->ClearIsInstInlineCaches();",
          "428:             ClearIsInstInlineCaches();",
          "429:             Assert(!this->hasIsInstInlineCache);",
          "430:         }",
          "433:         if (isClosed && !isScriptContextActuallyClosed)",
          "434:         {",
          "435:             threadContext->RemoveFromPendingClose(this);",
          "436:         }",
          "438:         SetIsClosed();",
          "439:         bool closed = Close(true);",
          "443:         numberAllocator.Uninitialize();",
          "445:         ShutdownClearSourceLists();",
          "447:         if (regexStacks)",
          "448:         {",
          "449:             Adelete(RegexAllocator(), regexStacks);",
          "450:             regexStacks = nullptr;",
          "451:         }",
          "453:         if (javascriptLibrary != nullptr)",
          "454:         {",
          "455:             javascriptLibrary->scriptContext = nullptr;",
          "456:             javascriptLibrary = nullptr;",
          "457:             if (closed)",
          "458:             {",
          "463: #if ENABLE_NATIVE_CODEGEN",
          "464:                 Assert(this->IsClosedNativeCodeGenerator());",
          "465: #endif",
          "466:                 if (!GetThreadContext()->IsJSRT())",
          "467:                 {",
          "468:                     this->recycler->RootRelease(globalObject);",
          "469:                 }",
          "470:             }",
          "471:         }",
          "475:         if (this->IsRegistered())",
          "476:         {",
          "477:             threadContext->UnregisterScriptContext(this);",
          "478:         }",
          "480: #if ENABLE_BACKGROUND_PARSING",
          "481:         if (this->backgroundParser != nullptr)",
          "482:         {",
          "483:             BackgroundParser::Delete(this->backgroundParser);",
          "484:             this->backgroundParser = nullptr;",
          "485:         }",
          "486: #endif",
          "488: #if ENABLE_NATIVE_CODEGEN",
          "489:         if (this->nativeCodeGen != nullptr)",
          "490:         {",
          "491:             DeleteNativeCodeGenerator(this->nativeCodeGen);",
          "492:             nativeCodeGen = NULL;",
          "493:         }",
          "494:         if (jitFuncRangeCache != nullptr)",
          "495:         {",
          "496:             HeapDelete(jitFuncRangeCache);",
          "497:             jitFuncRangeCache = nullptr;",
          "498:         }",
          "499: #endif",
          "501: #if DYNAMIC_INTERPRETER_THUNK",
          "502:         if (this->interpreterThunkEmitter != nullptr)",
          "503:         {",
          "504:             HeapDelete(interpreterThunkEmitter);",
          "505:             this->interpreterThunkEmitter = NULL;",
          "506:         }",
          "507: #endif",
          "509: #ifdef ASMJS_PLAT",
          "510:         if (this->asmJsInterpreterThunkEmitter != nullptr)",
          "511:         {",
          "512:             HeapDelete(asmJsInterpreterThunkEmitter);",
          "513:             this->asmJsInterpreterThunkEmitter = nullptr;",
          "514:         }",
          "516:         if (this->asmJsCodeGenerator != nullptr)",
          "517:         {",
          "518:             HeapDelete(asmJsCodeGenerator);",
          "519:             this->asmJsCodeGenerator = NULL;",
          "520:         }",
          "521: #endif",
          "524:         this->weakReferenceDictionaryList.Reset();",
          "526: #if ENABLE_NATIVE_CODEGEN",
          "527:         if (m_remoteScriptContextAddr)",
          "528:         {",
          "529:             Assert(JITManager::GetJITManager()->IsOOPJITEnabled());",
          "530:             if (JITManager::GetJITManager()->CleanupScriptContext(&m_remoteScriptContextAddr) == S_OK)",
          "531:             {",
          "532:                 Assert(m_remoteScriptContextAddr == nullptr);",
          "533:             }",
          "534:             m_remoteScriptContextAddr = nullptr;",
          "535:         }",
          "536: #endif",
          "538:         PERF_COUNTER_DEC(Basic, ScriptContext);",
          "539:     }",
          "541:     void ScriptContext::SetUrl(BSTR bstrUrl)",
          "542:     {",
          "544:         Assert(this->url != nullptr && wcslen(this->url) == 0);",
          "546:         charcount_t length = SysStringLen(bstrUrl) + 1; // Add 1 for the NULL.",
          "548:         char16* urlCopy = AnewArray(this->GeneralAllocator(), char16, length);",
          "549:         js_memcpy_s(urlCopy, (length - 1) * sizeof(char16), bstrUrl, (length - 1) * sizeof(char16));",
          "550:         urlCopy[length - 1] = _u('\\0');",
          "552:         this->url = urlCopy;",
          "553: #ifdef LEAK_REPORT",
          "554:         if (Js::Configuration::Global.flags.IsEnabled(Js::LeakReportFlag))",
          "555:         {",
          "556:             this->urlRecord = LeakReport::LogUrl(urlCopy, this->globalObject);",
          "557:         }",
          "558: #endif",
          "559:     }",
          "561:     uint ScriptContext::GetNextSourceContextId()",
          "562:     {",
          "564:         Assert(this->Cache()->sourceContextInfoMap ||",
          "565:             this->Cache()->dynamicSourceContextInfoMap);",
          "567:         uint nextSourceContextId = 0;",
          "569:         if (this->Cache()->sourceContextInfoMap)",
          "570:         {",
          "571:             nextSourceContextId = this->Cache()->sourceContextInfoMap->Count();",
          "572:         }",
          "574:         if (this->Cache()->dynamicSourceContextInfoMap)",
          "575:         {",
          "576:             nextSourceContextId += this->Cache()->dynamicSourceContextInfoMap->Count();",
          "577:         }",
          "579:         return nextSourceContextId + 1;",
          "580:     }",
          "583:     void ScriptContext::InternalClose()",
          "584:     {",
          "585:         isScriptContextActuallyClosed = true;",
          "587:         PERF_COUNTER_DEC(Basic, ScriptContextActive);",
          "589: #if DBG_DUMP",
          "590:         if (Js::Configuration::Global.flags.TraceWin8Allocations)",
          "591:         {",
          "592:             Output::Print(_u(\"MemoryTrace: ScriptContext Close\\n\"));",
          "593:             Output::Flush();",
          "594:         }",
          "595: #endif",
          "596:         JS_ETW_INTERNAL(EventWriteJSCRIPT_HOST_SCRIPT_CONTEXT_CLOSE(this));",
          "598: #if ENABLE_TTD",
          "599:         if(this->TTDWellKnownInfo != nullptr)",
          "600:         {",
          "601:             TT_HEAP_DELETE(TTD::RuntimeContextInfo, this->TTDWellKnownInfo);",
          "602:             this->TTDWellKnownInfo = nullptr;",
          "603:         }",
          "605:         if(this->TTDContextInfo != nullptr)",
          "606:         {",
          "607:             TT_HEAP_DELETE(TTD::ScriptContextTTD, this->TTDContextInfo);",
          "608:             this->TTDContextInfo = nullptr;",
          "609:         }",
          "610: #endif",
          "612: #if ENABLE_NATIVE_CODEGEN",
          "613:         if (nativeCodeGen != nullptr)",
          "614:         {",
          "615:             Assert(!isInitialized || this->globalObject != nullptr);",
          "616:             CloseNativeCodeGenerator(this->nativeCodeGen);",
          "617:         }",
          "618: #endif",
          "620:         if (this->sourceList)",
          "621:         {",
          "622:             bool hasFunctions = false;",
          "623:             this->sourceList->MapUntil([&hasFunctions](int, RecyclerWeakReference<Utf8SourceInfo>* sourceInfoWeakRef) -> bool",
          "624:             {",
          "625:                 Utf8SourceInfo* sourceInfo = sourceInfoWeakRef->Get();",
          "626:                 if (sourceInfo)",
          "627:                 {",
          "628:                     hasFunctions = sourceInfo->HasFunctions();",
          "629:                 }",
          "631:                 return hasFunctions;",
          "632:             });",
          "634:             if (hasFunctions)",
          "635:             {",
          "639:                 this->MapFunction([this](Js::FunctionBody* functionBody) {",
          "640:                     Assert(functionBody->GetScriptContext() == nullptr || functionBody->GetScriptContext() == this);",
          "641:                     functionBody->Cleanup(/* isScriptContextClosing */ true);",
          "642:                 });",
          "643:             }",
          "644:         }",
          "646:         this->GetThreadContext()->SubSourceSize(this->GetSourceSize());",
          "648: #if DYNAMIC_INTERPRETER_THUNK",
          "649:         if (this->interpreterThunkEmitter != nullptr)",
          "650:         {",
          "651:             this->interpreterThunkEmitter->Close();",
          "652:         }",
          "653: #endif",
          "655: #ifdef ASMJS_PLAT",
          "656:         if (this->asmJsInterpreterThunkEmitter != nullptr)",
          "657:         {",
          "658:             this->asmJsInterpreterThunkEmitter->Close();",
          "659:         }",
          "660: #endif",
          "662: #ifdef ENABLE_SCRIPT_PROFILING",
          "664:         DeRegisterProfileProbe(S_OK, nullptr);",
          "665: #endif",
          "667:         this->EnsureClearDebugDocument();",
          "668:         if (this->debugContext != nullptr)",
          "669:         {",
          "670:             if(this->debugContext->GetProbeContainer())",
          "671:             {",
          "672:                 this->debugContext->GetProbeContainer()->UninstallInlineBreakpointProbe(NULL);",
          "673:                 this->debugContext->GetProbeContainer()->UninstallDebuggerScriptOptionCallback();",
          "674:             }",
          "678:             AutoCriticalSection autoDebugContextCloseCS(&debugContextCloseCS);",
          "679:             DebugContext* tempDebugContext = this->debugContext;",
          "680:             this->debugContext = nullptr;",
          "681:             tempDebugContext->Close();",
          "682:             HeapDelete(tempDebugContext);",
          "683:         }",
          "685:         if (this->diagnosticArena != nullptr)",
          "686:         {",
          "687:             HeapDelete(this->diagnosticArena);",
          "688:             this->diagnosticArena = nullptr;",
          "689:         }",
          "694: #ifdef PROFILE_EXEC",
          "695:         if (Js::Configuration::Global.flags.IsEnabled(Js::ProfileFlag))",
          "696:         {",
          "697:             if (isProfilerCreated)",
          "698:             {",
          "699:                 this->ProfilePrint();",
          "700:             }",
          "702:             if (profiler != nullptr)",
          "703:             {",
          "704:                 profiler->Release();",
          "705:                 profiler = nullptr;",
          "706:             }",
          "707:         }",
          "708: #endif",
          "711: #if ENABLE_PROFILE_INFO",
          "716:         if (referencesSharedDynamicSourceContextInfo)",
          "717:         {",
          "719:             Assert(this->GetDynamicSourceContextInfoMap() != nullptr);",
          "720:             this->GetThreadContext()->ReleaseSourceDynamicProfileManagers(this->GetUrl());",
          "721:         }",
          "722: #endif",
          "724:         RECYCLER_PERF_COUNTER_SUB(BindReference, bindReferenceCount);",
          "726:         if (this->interpreterArena)",
          "727:         {",
          "728:             ReleaseInterpreterArena();",
          "729:             interpreterArena = nullptr;",
          "730:         }",
          "732:         if (this->guestArena)",
          "733:         {",
          "734:             ReleaseGuestArena();",
          "735:             guestArena = nullptr;",
          "736:         }",
          "738:         builtInLibraryFunctions = nullptr;",
          "740:         pActiveScriptDirect = nullptr;",
          "742:         isWeakReferenceDictionaryListCleared = true;",
          "743:         this->weakReferenceDictionaryList.Clear(this->GeneralAllocator());",
          "745:         if (registeredPrototypeChainEnsuredToHaveOnlyWritableDataPropertiesScriptContext != nullptr)",
          "746:         {",
          "748:             ScriptContext ** registeredScriptContext = registeredPrototypeChainEnsuredToHaveOnlyWritableDataPropertiesScriptContext;",
          "749:             ClearPrototypeChainEnsuredToHaveOnlyWritableDataPropertiesCaches();",
          "750:             Assert(registeredPrototypeChainEnsuredToHaveOnlyWritableDataPropertiesScriptContext == nullptr);",
          "751:             threadContext->UnregisterPrototypeChainEnsuredToHaveOnlyWritableDataPropertiesScriptContext(registeredScriptContext);",
          "752:         }",
          "754:         threadContext->ReleaseDebugManager();",
          "758:         if (javascriptLibrary != nullptr)",
          "759:         {",
          "760:             javascriptLibrary->CleanupForClose();",
          "761:             javascriptLibrary->Uninitialize();",
          "763:             this->ClearScriptContextCaches();",
          "764:         }",
          "765:     }",
          "767:     bool ScriptContext::Close(bool inDestructor)",
          "768:     {",
          "769:         if (isScriptContextActuallyClosed)",
          "770:             return false;",
          "773:         {",
          "775:             AutoCriticalSection autocs(GetThreadContext()->GetEtwRundownCriticalSection());",
          "776:             InternalClose();",
          "777:         }",
          "779:         if (!inDestructor && globalObject != nullptr)",
          "780:         {",
          "783: #if ENABLE_NATIVE_CODEGEN",
          "784:             Assert(this->IsClosedNativeCodeGenerator());",
          "785: #endif",
          "786:             if (!GetThreadContext()->IsJSRT())",
          "787:             {",
          "788:                 GetRecycler()->RootRelease(globalObject);",
          "789:             }",
          "790:             globalObject = nullptr;",
          "791:         }",
          "795:         this->threadContext->SetForceOneIdleCollection();",
          "797:         return true;",
          "798:     }",
          "800:     PropertyString* ScriptContext::GetPropertyString2(char16 ch1, char16 ch2)",
          "801:     {",
          "802:         if (ch1 < '0' || ch1 > 'z' || ch2 < '0' || ch2 > 'z')",
          "803:         {",
          "804:             return NULL;",
          "805:         }",
          "806:         const uint i = PropertyStringMap::PStrMapIndex(ch1);",
          "807:         if (propertyStrings[i] == NULL)",
          "808:         {",
          "809:             return NULL;",
          "810:         }",
          "811:         const uint j = PropertyStringMap::PStrMapIndex(ch2);",
          "812:         return propertyStrings[i]->strLen2[j];",
          "813:     }",
          "815:     void ScriptContext::FindPropertyRecord(JavascriptString *pstName, PropertyRecord const ** propertyRecord)",
          "816:     {",
          "817:         threadContext->FindPropertyRecord(pstName, propertyRecord);",
          "818:     }",
          "820:     void ScriptContext::FindPropertyRecord(__in LPCWSTR propertyName, __in int propertyNameLength, PropertyRecord const ** propertyRecord)",
          "821:     {",
          "822:         threadContext->FindPropertyRecord(propertyName, propertyNameLength, propertyRecord);",
          "823:     }",
          "825:     JsUtil::List<const RecyclerWeakReference<Js::PropertyRecord const>*>* ScriptContext::FindPropertyIdNoCase(__in LPCWSTR propertyName, __in int propertyNameLength)",
          "826:     {",
          "827:         return threadContext->FindPropertyIdNoCase(this, propertyName, propertyNameLength);",
          "828:     }",
          "830:     PropertyId ScriptContext::GetOrAddPropertyIdTracked(JsUtil::CharacterBuffer<WCHAR> const& propName)",
          "831:     {",
          "832:         Js::PropertyRecord const * propertyRecord;",
          "833:         threadContext->GetOrAddPropertyId(propName, &propertyRecord);",
          "835:         this->TrackPid(propertyRecord);",
          "837:         return propertyRecord->GetPropertyId();",
          "838:     }",
          "840:     void ScriptContext::GetOrAddPropertyRecord(JsUtil::CharacterBuffer<WCHAR> const& propertyName, PropertyRecord const ** propertyRecord)",
          "841:     {",
          "842:         threadContext->GetOrAddPropertyId(propertyName, propertyRecord);",
          "843:     }",
          "845:     PropertyId ScriptContext::GetOrAddPropertyIdTracked(__in_ecount(propertyNameLength) LPCWSTR propertyName, __in int propertyNameLength)",
          "846:     {",
          "847:         Js::PropertyRecord const * propertyRecord;",
          "848:         threadContext->GetOrAddPropertyId(propertyName, propertyNameLength, &propertyRecord);",
          "849:         if (propertyNameLength == 2)",
          "850:         {",
          "851:             CachePropertyString2(propertyRecord);",
          "852:         }",
          "853:         this->TrackPid(propertyRecord);",
          "855:         return propertyRecord->GetPropertyId();",
          "856:     }",
          "858:     void ScriptContext::GetOrAddPropertyRecord(__in_ecount(propertyNameLength) LPCWSTR propertyName, __in int propertyNameLength, PropertyRecord const ** propertyRecord)",
          "859:     {",
          "860:         threadContext->GetOrAddPropertyId(propertyName, propertyNameLength, propertyRecord);",
          "861:         if (propertyNameLength == 2)",
          "862:         {",
          "863:             CachePropertyString2(*propertyRecord);",
          "864:         }",
          "865:     }",
          "867:     BOOL ScriptContext::IsNumericPropertyId(PropertyId propertyId, uint32* value)",
          "868:     {",
          "869:         BOOL isNumericPropertyId = threadContext->IsNumericPropertyId(propertyId, value);",
          "871: #if DEBUG",
          "872:         PropertyRecord const * name = this->GetPropertyName(propertyId);",
          "874:         if (name != nullptr)",
          "875:         {",
          "877:             if (name->IsSymbol())",
          "878:             {",
          "879:                 return false;",
          "880:             }",
          "882:             uint32 index;",
          "883:             BOOL isIndex = JavascriptArray::GetIndex(name->GetBuffer(), &index);",
          "884:             if (isNumericPropertyId != isIndex)",
          "885:             {",
          "889:                 Assert((size_t)(name->GetLength()) != wcslen(name->GetBuffer()));",
          "890:             }",
          "891:             else if (isNumericPropertyId)",
          "892:             {",
          "893:                 Assert((uint32)*value == index);",
          "894:             }",
          "895:         }",
          "896: #endif",
          "898:         return isNumericPropertyId;",
          "899:     }",
          "901:     void ScriptContext::RegisterWeakReferenceDictionary(JsUtil::IWeakReferenceDictionary* weakReferenceDictionary)",
          "902:     {",
          "903:         this->weakReferenceDictionaryList.Prepend(this->GeneralAllocator(), weakReferenceDictionary);",
          "904:     }",
          "906:     RecyclableObject *ScriptContext::GetMissingPropertyResult()",
          "907:     {",
          "908:         return GetLibrary()->GetUndefined();",
          "909:     }",
          "911:     RecyclableObject *ScriptContext::GetMissingItemResult()",
          "912:     {",
          "913:         return GetLibrary()->GetUndefined();",
          "914:     }",
          "916:     SRCINFO *ScriptContext::AddHostSrcInfo(SRCINFO const *pSrcInfo)",
          "917:     {",
          "918:         Assert(pSrcInfo != nullptr);",
          "920:         return RecyclerNewZ(this->GetRecycler(), SRCINFO, *pSrcInfo);",
          "921:     }",
          "923: #ifdef PROFILE_TYPES",
          "924:     void ScriptContext::ProfileTypes()",
          "925:     {",
          "926:         Output::Print(_u(\"===============================================================================\\n\"));",
          "927:         Output::Print(_u(\"Types Profile %s\\n\"), this->url);",
          "928:         Output::Print(_u(\"-------------------------------------------------------------------------------\\n\"));",
          "929:         Output::Print(_u(\"Dynamic Type Conversions:\\n\"));",
          "930:         Output::Print(_u(\"    Null to Simple                 %8d\\n\"), convertNullToSimpleCount);",
          "931:         Output::Print(_u(\"    Deferred to SimpleMap          %8d\\n\"), convertDeferredToSimpleDictionaryCount);",
          "932:         Output::Print(_u(\"    Simple to Map                  %8d\\n\"), convertSimpleToDictionaryCount);",
          "933:         Output::Print(_u(\"    Simple to SimpleMap            %8d\\n\"), convertSimpleToSimpleDictionaryCount);",
          "934:         Output::Print(_u(\"    Path to SimpleMap (set)        %8d\\n\"), convertPathToDictionaryCount1);",
          "935:         Output::Print(_u(\"    Path to SimpleMap (delete)     %8d\\n\"), convertPathToDictionaryCount2);",
          "936:         Output::Print(_u(\"    Path to SimpleMap (attribute)  %8d\\n\"), convertPathToDictionaryCount3);",
          "937:         Output::Print(_u(\"    Path to SimpleMap              %8d\\n\"), convertPathToSimpleDictionaryCount);",
          "938:         Output::Print(_u(\"    SimplePath to Path             %8d\\n\"), convertSimplePathToPathCount);",
          "939:         Output::Print(_u(\"    Shared SimpleMap to non-shared %8d\\n\"), convertSimpleSharedDictionaryToNonSharedCount);",
          "940:         Output::Print(_u(\"    Deferred to Map                %8d\\n\"), convertDeferredToDictionaryCount);",
          "941:         Output::Print(_u(\"    Path to Map (accessor)         %8d\\n\"), convertPathToDictionaryCount4);",
          "942:         Output::Print(_u(\"    SimpleMap to Map               %8d\\n\"), convertSimpleDictionaryToDictionaryCount);",
          "943:         Output::Print(_u(\"    Path Cache Hits                %8d\\n\"), cacheCount);",
          "944:         Output::Print(_u(\"    Path Branches                  %8d\\n\"), branchCount);",
          "945:         Output::Print(_u(\"    Path Promotions                %8d\\n\"), promoteCount);",
          "946:         Output::Print(_u(\"    Path Length (max)              %8d\\n\"), maxPathLength);",
          "947:         Output::Print(_u(\"    SimplePathTypeHandlers         %8d\\n\"), simplePathTypeHandlerCount);",
          "948:         Output::Print(_u(\"    PathTypeHandlers               %8d\\n\"), pathTypeHandlerCount);",
          "949:         Output::Print(_u(\"\\n\"));",
          "950:         Output::Print(_u(\"Type Statistics:                   %8s   %8s\\n\"), _u(\"Types\"), _u(\"Instances\"));",
          "951:         Output::Print(_u(\"    Undefined                      %8d   %8d\\n\"), typeCount[TypeIds_Undefined], instanceCount[TypeIds_Undefined]);",
          "952:         Output::Print(_u(\"    Null                           %8d   %8d\\n\"), typeCount[TypeIds_Null], instanceCount[TypeIds_Null]);",
          "953:         Output::Print(_u(\"    Boolean                        %8d   %8d\\n\"), typeCount[TypeIds_Boolean], instanceCount[TypeIds_Boolean]);",
          "954:         Output::Print(_u(\"    Integer                        %8d   %8d\\n\"), typeCount[TypeIds_Integer], instanceCount[TypeIds_Integer]);",
          "955:         Output::Print(_u(\"    Number                         %8d   %8d\\n\"), typeCount[TypeIds_Number], instanceCount[TypeIds_Number]);",
          "956:         Output::Print(_u(\"    String                         %8d   %8d\\n\"), typeCount[TypeIds_String], instanceCount[TypeIds_String]);",
          "957:         Output::Print(_u(\"    Object                         %8d   %8d\\n\"), typeCount[TypeIds_Object], instanceCount[TypeIds_Object]);",
          "958:         Output::Print(_u(\"    Function                       %8d   %8d\\n\"), typeCount[TypeIds_Function], instanceCount[TypeIds_Function]);",
          "959:         Output::Print(_u(\"    Array                          %8d   %8d\\n\"), typeCount[TypeIds_Array], instanceCount[TypeIds_Array]);",
          "960:         Output::Print(_u(\"    Date                           %8d   %8d\\n\"), typeCount[TypeIds_Date], instanceCount[TypeIds_Date] + instanceCount[TypeIds_WinRTDate]);",
          "961:         Output::Print(_u(\"    Symbol                         %8d   %8d\\n\"), typeCount[TypeIds_Symbol], instanceCount[TypeIds_Symbol]);",
          "962:         Output::Print(_u(\"    RegEx                          %8d   %8d\\n\"), typeCount[TypeIds_RegEx], instanceCount[TypeIds_RegEx]);",
          "963:         Output::Print(_u(\"    Error                          %8d   %8d\\n\"), typeCount[TypeIds_Error], instanceCount[TypeIds_Error]);",
          "964:         Output::Print(_u(\"    Proxy                          %8d   %8d\\n\"), typeCount[TypeIds_Proxy], instanceCount[TypeIds_Proxy]);",
          "965:         Output::Print(_u(\"    BooleanObject                  %8d   %8d\\n\"), typeCount[TypeIds_BooleanObject], instanceCount[TypeIds_BooleanObject]);",
          "966:         Output::Print(_u(\"    NumberObject                   %8d   %8d\\n\"), typeCount[TypeIds_NumberObject], instanceCount[TypeIds_NumberObject]);",
          "967:         Output::Print(_u(\"    StringObject                   %8d   %8d\\n\"), typeCount[TypeIds_StringObject], instanceCount[TypeIds_StringObject]);",
          "968:         Output::Print(_u(\"    SymbolObject                   %8d   %8d\\n\"), typeCount[TypeIds_SymbolObject], instanceCount[TypeIds_SymbolObject]);",
          "969:         Output::Print(_u(\"    GlobalObject                   %8d   %8d\\n\"), typeCount[TypeIds_GlobalObject], instanceCount[TypeIds_GlobalObject]);",
          "970:         Output::Print(_u(\"    Enumerator                     %8d   %8d\\n\"), typeCount[TypeIds_Enumerator], instanceCount[TypeIds_Enumerator]);",
          "971:         Output::Print(_u(\"    Int8Array                      %8d   %8d\\n\"), typeCount[TypeIds_Int8Array], instanceCount[TypeIds_Int8Array]);",
          "972:         Output::Print(_u(\"    Uint8Array                     %8d   %8d\\n\"), typeCount[TypeIds_Uint8Array], instanceCount[TypeIds_Uint8Array]);",
          "973:         Output::Print(_u(\"    Uint8ClampedArray              %8d   %8d\\n\"), typeCount[TypeIds_Uint8ClampedArray], instanceCount[TypeIds_Uint8ClampedArray]);",
          "974:         Output::Print(_u(\"    Int16Array                     %8d   %8d\\n\"), typeCount[TypeIds_Int16Array], instanceCount[TypeIds_Int16Array]);",
          "975:         Output::Print(_u(\"    Int16Array                     %8d   %8d\\n\"), typeCount[TypeIds_Uint16Array], instanceCount[TypeIds_Uint16Array]);",
          "976:         Output::Print(_u(\"    Int32Array                     %8d   %8d\\n\"), typeCount[TypeIds_Int32Array], instanceCount[TypeIds_Int32Array]);",
          "977:         Output::Print(_u(\"    Uint32Array                    %8d   %8d\\n\"), typeCount[TypeIds_Uint32Array], instanceCount[TypeIds_Uint32Array]);",
          "978:         Output::Print(_u(\"    Float32Array                   %8d   %8d\\n\"), typeCount[TypeIds_Float32Array], instanceCount[TypeIds_Float32Array]);",
          "979:         Output::Print(_u(\"    Float64Array                   %8d   %8d\\n\"), typeCount[TypeIds_Float64Array], instanceCount[TypeIds_Float64Array]);",
          "980:         Output::Print(_u(\"    DataView                       %8d   %8d\\n\"), typeCount[TypeIds_DataView], instanceCount[TypeIds_DataView]);",
          "981:         Output::Print(_u(\"    ModuleRoot                     %8d   %8d\\n\"), typeCount[TypeIds_ModuleRoot], instanceCount[TypeIds_ModuleRoot]);",
          "982:         Output::Print(_u(\"    HostObject                     %8d   %8d\\n\"), typeCount[TypeIds_HostObject], instanceCount[TypeIds_HostObject]);",
          "983:         Output::Print(_u(\"    VariantDate                    %8d   %8d\\n\"), typeCount[TypeIds_VariantDate], instanceCount[TypeIds_VariantDate]);",
          "984:         Output::Print(_u(\"    HostDispatch                   %8d   %8d\\n\"), typeCount[TypeIds_HostDispatch], instanceCount[TypeIds_HostDispatch]);",
          "985:         Output::Print(_u(\"    Arguments                      %8d   %8d\\n\"), typeCount[TypeIds_Arguments], instanceCount[TypeIds_Arguments]);",
          "986:         Output::Print(_u(\"    ActivationObject               %8d   %8d\\n\"), typeCount[TypeIds_ActivationObject], instanceCount[TypeIds_ActivationObject]);",
          "987:         Output::Print(_u(\"    Map                            %8d   %8d\\n\"), typeCount[TypeIds_Map], instanceCount[TypeIds_Map]);",
          "988:         Output::Print(_u(\"    Set                            %8d   %8d\\n\"), typeCount[TypeIds_Set], instanceCount[TypeIds_Set]);",
          "989:         Output::Print(_u(\"    WeakMap                        %8d   %8d\\n\"), typeCount[TypeIds_WeakMap], instanceCount[TypeIds_WeakMap]);",
          "990:         Output::Print(_u(\"    WeakSet                        %8d   %8d\\n\"), typeCount[TypeIds_WeakSet], instanceCount[TypeIds_WeakSet]);",
          "991:         Output::Print(_u(\"    ArrayIterator                  %8d   %8d\\n\"), typeCount[TypeIds_ArrayIterator], instanceCount[TypeIds_ArrayIterator]);",
          "992:         Output::Print(_u(\"    MapIterator                    %8d   %8d\\n\"), typeCount[TypeIds_MapIterator], instanceCount[TypeIds_MapIterator]);",
          "993:         Output::Print(_u(\"    SetIterator                    %8d   %8d\\n\"), typeCount[TypeIds_SetIterator], instanceCount[TypeIds_SetIterator]);",
          "994:         Output::Print(_u(\"    StringIterator                 %8d   %8d\\n\"), typeCount[TypeIds_StringIterator], instanceCount[TypeIds_StringIterator]);",
          "995:         Output::Print(_u(\"    Generator                      %8d   %8d\\n\"), typeCount[TypeIds_Generator], instanceCount[TypeIds_Generator]);",
          "996: #if !DBG",
          "997:         Output::Print(_u(\"    ** Instance statistics only available on debug builds...\\n\"));",
          "998: #endif",
          "999:         Output::Flush();",
          "1000:     }",
          "1001: #endif",
          "1004: #ifdef PROFILE_OBJECT_LITERALS",
          "1005:     void ScriptContext::ProfileObjectLiteral()",
          "1006:     {",
          "1007:         Output::Print(_u(\"===============================================================================\\n\"));",
          "1008:         Output::Print(_u(\"    Object Lit Instances created.. %d\\n\"), objectLiteralInstanceCount);",
          "1009:         Output::Print(_u(\"    Object Lit Path Types......... %d\\n\"), objectLiteralPathCount);",
          "1010:         Output::Print(_u(\"    Object Lit Simple Map......... %d\\n\"), objectLiteralSimpleDictionaryCount);",
          "1011:         Output::Print(_u(\"    Object Lit Max # of properties %d\\n\"), objectLiteralMaxLength);",
          "1012:         Output::Print(_u(\"    Object Lit Promote count...... %d\\n\"), objectLiteralPromoteCount);",
          "1013:         Output::Print(_u(\"    Object Lit Cache Hits......... %d\\n\"), objectLiteralCacheCount);",
          "1014:         Output::Print(_u(\"    Object Lit Branch count....... %d\\n\"), objectLiteralBranchCount);",
          "1016:         for (int i = 0; i < TypePath::MaxPathTypeHandlerLength; i++)",
          "1017:         {",
          "1018:             if (objectLiteralCount[i] != 0)",
          "1019:             {",
          "1020:                 Output::Print(_u(\"    Object Lit properties [ %2d] .. %d\\n\"), i, objectLiteralCount[i]);",
          "1021:             }",
          "1022:         }",
          "1024:         Output::Flush();",
          "1025:     }",
          "1026: #endif",
          "1032: #if ENABLE_REGEX_CONFIG_OPTIONS",
          "1033:     UnifiedRegex::RegexStatsDatabase* ScriptContext::GetRegexStatsDatabase()",
          "1034:     {",
          "1035:         if (regexStatsDatabase == 0)",
          "1036:         {",
          "1037:             ArenaAllocator* allocator = MiscAllocator();",
          "1038:             regexStatsDatabase = Anew(allocator, UnifiedRegex::RegexStatsDatabase, allocator);",
          "1039:         }",
          "1040:         return regexStatsDatabase;",
          "1041:     }",
          "1043:     UnifiedRegex::DebugWriter* ScriptContext::GetRegexDebugWriter()",
          "1044:     {",
          "1045:         if (regexDebugWriter == 0)",
          "1046:         {",
          "1047:             ArenaAllocator* allocator = MiscAllocator();",
          "1048:             regexDebugWriter = Anew(allocator, UnifiedRegex::DebugWriter);",
          "1049:         }",
          "1050:         return regexDebugWriter;",
          "1051:     }",
          "1052: #endif",
          "1054:     void ScriptContext::RedeferFunctionBodies(ActiveFunctionSet *pActiveFuncs, uint inactiveThreshold)",
          "1055:     {",
          "1056:         Assert(!this->IsClosed());",
          "1058:         if (!this->IsScriptContextInNonDebugMode())",
          "1059:         {",
          "1060:             return;",
          "1061:         }",
          "1069:         auto fn = [&](FunctionBody *functionBody) {",
          "1070:             bool exec = functionBody->InterpretedSinceCallCountCollection();",
          "1071:             functionBody->CollectInterpretedCounts();",
          "1072:             functionBody->MapEntryPoints([&](int index, FunctionEntryPointInfo *entryPointInfo) {",
          "1073:                 if (!entryPointInfo->IsCleanedUp() && entryPointInfo->ExecutedSinceCallCountCollection())",
          "1074:                 {",
          "1075:                     exec = true;",
          "1076:                 }",
          "1077:                 entryPointInfo->CollectCallCounts();",
          "1078:             });",
          "1079:             if (exec)",
          "1080:             {",
          "1081:                 functionBody->SetInactiveCount(0);",
          "1082:             }",
          "1083:             else",
          "1084:             {",
          "1085:                 functionBody->IncrInactiveCount(inactiveThreshold);",
          "1086:             }",
          "1088:             if (pActiveFuncs)",
          "1089:             {",
          "1090:                 Assert(this->GetThreadContext()->DoRedeferFunctionBodies());",
          "1091:                 bool doRedefer = functionBody->DoRedeferFunction(inactiveThreshold);",
          "1092:                 if (!doRedefer)",
          "1093:                 {",
          "1094:                     functionBody->UpdateActiveFunctionSet(pActiveFuncs, nullptr);",
          "1095:                 }",
          "1096:             }",
          "1097:         };",
          "1099:         this->MapFunction(fn);",
          "1101:         if (!pActiveFuncs)",
          "1102:         {",
          "1103:             return;",
          "1104:         }",
          "1106:         auto fnRedefer = [&](FunctionBody * functionBody) {",
          "1107:             Assert(pActiveFuncs);",
          "1108:             if (!functionBody->IsActiveFunction(pActiveFuncs))",
          "1109:             {",
          "1110:                 Assert(functionBody->DoRedeferFunction(inactiveThreshold));",
          "1111:                 functionBody->RedeferFunction();",
          "1112:             }",
          "1113:             else",
          "1114:             {",
          "1115:                 functionBody->ResetRedeferralAttributes();",
          "1116:             }",
          "1117:         };",
          "1119:         this->MapFunction(fnRedefer);",
          "1120:     }",
          "1122:     bool ScriptContext::DoUndeferGlobalFunctions() const",
          "1123:     {",
          "1124:         return CONFIG_FLAG(DeferTopLevelTillFirstCall) && !AutoSystemInfo::Data.IsLowMemoryProcess();",
          "1125:     }",
          "1127:     RegexPatternMruMap* ScriptContext::GetDynamicRegexMap() const",
          "1128:     {",
          "1129:         Assert(!isScriptContextActuallyClosed);",
          "1130:         Assert(Cache()->dynamicRegexMap);",
          "1132:         return Cache()->dynamicRegexMap;",
          "1133:     }",
          "1135:     void ScriptContext::SetTrigramAlphabet(UnifiedRegex::TrigramAlphabet * trigramAlphabet)",
          "1136:     {",
          "1137:         this->trigramAlphabet = trigramAlphabet;",
          "1138:     }",
          "1140:     UnifiedRegex::RegexStacks *ScriptContext::RegexStacks()",
          "1141:     {",
          "1142:         UnifiedRegex::RegexStacks * stacks = regexStacks;",
          "1143:         if (stacks)",
          "1144:         {",
          "1145:             return stacks;",
          "1146:         }",
          "1147:         return AllocRegexStacks();",
          "1148:     }",
          "1150:     UnifiedRegex::RegexStacks * ScriptContext::AllocRegexStacks()",
          "1151:     {",
          "1152:         Assert(this->regexStacks == nullptr);",
          "1153:         UnifiedRegex::RegexStacks * stacks = Anew(RegexAllocator(), UnifiedRegex::RegexStacks, threadContext->GetPageAllocator());",
          "1154:         this->regexStacks = stacks;",
          "1155:         return stacks;",
          "1156:     }",
          "1158:     UnifiedRegex::RegexStacks *ScriptContext::SaveRegexStacks()",
          "1159:     {",
          "1160:         Assert(regexStacks);",
          "1162:         const auto saved = regexStacks;",
          "1163:         regexStacks = nullptr;",
          "1164:         return saved;",
          "1165:     }",
          "1167:     void ScriptContext::RestoreRegexStacks(UnifiedRegex::RegexStacks *const stacks)",
          "1168:     {",
          "1169:         Assert(stacks);",
          "1170:         Assert(stacks != regexStacks);",
          "1172:         if (regexStacks)",
          "1173:         {",
          "1174:             Adelete(RegexAllocator(), regexStacks);",
          "1175:         }",
          "1176:         regexStacks = stacks;",
          "1177:     }",
          "1179:     Js::TempArenaAllocatorObject* ScriptContext::GetTemporaryAllocator(LPCWSTR name)",
          "1180:     {",
          "1181:         return this->threadContext->GetTemporaryAllocator(name);",
          "1182:     }",
          "1184:     void ScriptContext::ReleaseTemporaryAllocator(Js::TempArenaAllocatorObject* tempAllocator)",
          "1185:     {",
          "1186:         AssertMsg(tempAllocator != nullptr, \"tempAllocator should not be null\");",
          "1188:         this->threadContext->ReleaseTemporaryAllocator(tempAllocator);",
          "1189:     }",
          "1191:     Js::TempGuestArenaAllocatorObject* ScriptContext::GetTemporaryGuestAllocator(LPCWSTR name)",
          "1192:     {",
          "1193:         return this->threadContext->GetTemporaryGuestAllocator(name);",
          "1194:     }",
          "1196:     void ScriptContext::ReleaseTemporaryGuestAllocator(Js::TempGuestArenaAllocatorObject* tempGuestAllocator)",
          "1197:     {",
          "1198:         AssertMsg(tempGuestAllocator != nullptr, \"tempAllocator should not be null\");",
          "1200:         this->threadContext->ReleaseTemporaryGuestAllocator(tempGuestAllocator);",
          "1201:     }",
          "1203:     void ScriptContext::InitializeCache()",
          "1204:     {",
          "1206: #if ENABLE_PROFILE_INFO",
          "1207: #if DBG_DUMP || defined(DYNAMIC_PROFILE_STORAGE) || defined(RUNTIME_DATA_COLLECTION)",
          "1208:         if (DynamicProfileInfo::NeedProfileInfoList())",
          "1209:         {",
          "1210:             this->Cache()->profileInfoList = RecyclerNew(this->GetRecycler(), DynamicProfileInfoList);",
          "1211:         }",
          "1212: #endif",
          "1213: #endif",
          "1215:         this->Cache()->dynamicRegexMap =",
          "1216:             RegexPatternMruMap::New(",
          "1217:                 recycler,",
          "1218:                 REGEX_CONFIG_FLAG(DynamicRegexMruListSize) <= 0 ? 16 : REGEX_CONFIG_FLAG(DynamicRegexMruListSize));",
          "1220:         SourceContextInfo* sourceContextInfo = RecyclerNewStructZ(this->GetRecycler(), SourceContextInfo);",
          "1221:         sourceContextInfo->dwHostSourceContext = Js::Constants::NoHostSourceContext;",
          "1222:         sourceContextInfo->isHostDynamicDocument = false;",
          "1223:         sourceContextInfo->sourceContextId = Js::Constants::NoSourceContext;",
          "1224:         this->Cache()->noContextSourceContextInfo = sourceContextInfo;",
          "1226:         SRCINFO* srcInfo = RecyclerNewStructZ(this->GetRecycler(), SRCINFO);",
          "1227:         srcInfo->sourceContextInfo = this->Cache()->noContextSourceContextInfo;",
          "1228:         srcInfo->moduleID = kmodGlobal;",
          "1229:         this->Cache()->noContextGlobalSourceInfo = srcInfo;",
          "1230:     }",
          "1232:     void ScriptContext::InitializePreGlobal()",
          "1233:     {",
          "1234:         this->guestArena = this->GetRecycler()->CreateGuestArena(_u(\"Guest\"), Throw::OutOfMemory);",
          "1236: #if ENABLE_BACKGROUND_PARSING",
          "1237:         if (PHASE_ON1(Js::ParallelParsePhase))",
          "1238:         {",
          "1239:             this->backgroundParser = BackgroundParser::New(this);",
          "1240:         }",
          "1241: #endif",
          "1243: #if ENABLE_NATIVE_CODEGEN",
          "1245:         this->nativeCodeGen = NewNativeCodeGenerator(this);",
          "1246:         this->jitFuncRangeCache = HeapNew(JITPageAddrToFuncRangeCache);",
          "1247: #endif",
          "1249: #ifdef PROFILE_EXEC",
          "1250:         this->CreateProfiler();",
          "1251: #endif",
          "1253:         this->operationStack = Anew(GeneralAllocator(), JsUtil::Stack<Var>, GeneralAllocator());",
          "1255:         Tick::InitType();",
          "1256:     }",
          "1258:     void ScriptContext::Initialize()",
          "1259:     {",
          "1260:         SmartFPUControl defaultControl;",
          "1262:         InitializePreGlobal();",
          "1264:         InitializeGlobalObject();",
          "1266:         InitializePostGlobal();",
          "1267:     }",
          "1269:     void ScriptContext::InitializePostGlobal()",
          "1270:     {",
          "1271:         this->GetDebugContext()->Initialize();",
          "1273:         this->GetDebugContext()->GetProbeContainer()->Initialize(this);",
          "1275:         isDebugContextInitialized = true;",
          "1277: #if defined(_M_ARM32_OR_ARM64)",
          "1279:         MemoryBarrier();",
          "1280: #endif",
          "1282:         AssertMsg(this->CurrentThunk == DefaultEntryThunk, \"Creating non default thunk while initializing\");",
          "1283:         AssertMsg(this->DeferredParsingThunk == DefaultDeferredParsingThunk, \"Creating non default thunk while initializing\");",
          "1284:         AssertMsg(this->DeferredDeserializationThunk == DefaultDeferredDeserializeThunk, \"Creating non default thunk while initializing\");",
          "1286: #ifdef FIELD_ACCESS_STATS",
          "1287:         this->fieldAccessStatsByFunctionNumber = RecyclerNew(this->recycler, FieldAccessStatsByFunctionNumberMap, recycler);",
          "1288:         BindReference(this->fieldAccessStatsByFunctionNumber);",
          "1289: #endif",
          "1291:         if (!sourceList)",
          "1292:         {",
          "1293:             AutoCriticalSection critSec(threadContext->GetEtwRundownCriticalSection());",
          "1294:             sourceList.Root(RecyclerNew(this->GetRecycler(), SourceList, this->GetRecycler()), this->GetRecycler());",
          "1295:         }",
          "1297: #if DYNAMIC_INTERPRETER_THUNK",
          "1298:         interpreterThunkEmitter = HeapNew(InterpreterThunkEmitter, this, SourceCodeAllocator(), this->GetThreadContext()->GetThunkPageAllocators());",
          "1299: #endif",
          "1301: #ifdef ASMJS_PLAT",
          "1302:         asmJsInterpreterThunkEmitter = HeapNew(InterpreterThunkEmitter, this, SourceCodeAllocator(), this->GetThreadContext()->GetThunkPageAllocators(),",
          "1303:             true);",
          "1304: #endif",
          "1306:         JS_ETW(EtwTrace::LogScriptContextLoadEvent(this));",
          "1307:         JS_ETW_INTERNAL(EventWriteJSCRIPT_HOST_SCRIPT_CONTEXT_START(this));",
          "1309: #ifdef PROFILE_EXEC",
          "1310:         if (profiler != nullptr)",
          "1311:         {",
          "1312:             this->threadContext->GetRecycler()->SetProfiler(profiler->GetProfiler(), profiler->GetBackgroundRecyclerProfiler());",
          "1313:         }",
          "1314: #endif",
          "1316: #if DBG",
          "1317:         this->javascriptLibrary->DumpLibraryByteCode();",
          "1319:         isInitialized = TRUE;",
          "1320: #endif",
          "1321:     }",
          "1324: #ifdef ASMJS_PLAT",
          "1325:     AsmJsCodeGenerator* ScriptContext::InitAsmJsCodeGenerator()",
          "1326:     {",
          "1327:         if( !asmJsCodeGenerator )",
          "1328:         {",
          "1329:             asmJsCodeGenerator = HeapNew( AsmJsCodeGenerator, this );",
          "1330:         }",
          "1331:         return asmJsCodeGenerator;",
          "1332:     }",
          "1333: #endif",
          "1334:     void ScriptContext::MarkForClose()",
          "1335:     {",
          "1336:         if (IsClosed())",
          "1337:         {",
          "1338:             return;",
          "1339:         }",
          "1341:         SaveStartupProfileAndRelease(true);",
          "1342:         SetIsClosed();",
          "1344: #ifdef LEAK_REPORT",
          "1345:         if (this->isRootTrackerScriptContext)",
          "1346:         {",
          "1347:             this->GetThreadContext()->ClearRootTrackerScriptContext(this);",
          "1348:         }",
          "1349: #endif",
          "1351:         if (!threadContext->IsInScript())",
          "1352:         {",
          "1353:             Close(FALSE);",
          "1354:         }",
          "1355:         else",
          "1356:         {",
          "1357:             threadContext->AddToPendingScriptContextCloseList(this);",
          "1358:         }",
          "1359:     }",
          "1361:     void ScriptContext::SetIsClosed()",
          "1362:     {",
          "1363:         if (!this->isClosed)",
          "1364:         {",
          "1365:             this->isClosed = true;",
          "1367:             if (this->javascriptLibrary)",
          "1368:             {",
          "1369:                 JS_ETW(EtwTrace::LogSourceUnloadEvents(this));",
          "1371: #if ENABLE_PROFILE_INFO",
          "1372: #if DBG_DUMP",
          "1373:                 DynamicProfileInfo::DumpScriptContext(this);",
          "1374: #endif",
          "1375: #ifdef RUNTIME_DATA_COLLECTION",
          "1376:                 DynamicProfileInfo::DumpScriptContextToFile(this);",
          "1377: #endif",
          "1378: #endif",
          "1380: #if ENABLE_PROFILE_INFO",
          "1381: #ifdef DYNAMIC_PROFILE_STORAGE",
          "1382:                 HRESULT hr = S_OK;",
          "1383:                 BEGIN_TRANSLATE_OOM_TO_HRESULT_NESTED",
          "1384:                 {",
          "1385:                     DynamicProfileInfo::Save(this);",
          "1386:                 }",
          "1387:                 END_TRANSLATE_OOM_TO_HRESULT(hr);",
          "1389:                 if (this->Cache()->sourceContextInfoMap)",
          "1390:                 {",
          "1391:                     this->Cache()->sourceContextInfoMap->Map([&](DWORD_PTR dwHostSourceContext, SourceContextInfo * sourceContextInfo)",
          "1392:                     {",
          "1393:                         if (sourceContextInfo->sourceDynamicProfileManager)",
          "1394:                         {",
          "1395:                             sourceContextInfo->sourceDynamicProfileManager->ClearSavingData();",
          "1396:                         }",
          "1397:                     });",
          "1398:                 }",
          "1399: #endif",
          "1401: #if DBG_DUMP || defined(DYNAMIC_PROFILE_STORAGE) || defined(RUNTIME_DATA_COLLECTION)",
          "1402:                 this->ClearDynamicProfileList();",
          "1403: #endif",
          "1404: #endif",
          "1405:             }",
          "1407: #if ENABLE_NATIVE_CODEGEN",
          "1408:             if (m_remoteScriptContextAddr)",
          "1409:             {",
          "1410:                 JITManager::GetJITManager()->CloseScriptContext(m_remoteScriptContextAddr);",
          "1411:             }",
          "1412: #endif",
          "1413:             this->PrintStats();",
          "1414:         }",
          "1415:     }",
          "1417:     void ScriptContext::InitializeGlobalObject()",
          "1418:     {",
          "1419:         GlobalObject * localGlobalObject = GlobalObject::New(this);",
          "1420:         GetRecycler()->RootAddRef(localGlobalObject);",
          "1423:         globalObject = localGlobalObject;",
          "1424:         globalObject->Initialize(this);",
          "1426:         this->GetThreadContext()->RegisterScriptContext(this);",
          "1427:     }",
          "1429:     ArenaAllocator* ScriptContext::AllocatorForDiagnostics()",
          "1430:     {",
          "1431:         if (this->diagnosticArena == nullptr)",
          "1432:         {",
          "1433:             this->diagnosticArena = HeapNew(ArenaAllocator, _u(\"Diagnostic\"), this->GetThreadContext()->GetDebugManager()->GetDiagnosticPageAllocator(), Throw::OutOfMemory);",
          "1434:         }",
          "1435:         Assert(this->diagnosticArena != nullptr);",
          "1436:         return this->diagnosticArena;",
          "1437:     }",
          "1439:     void ScriptContext::PushObject(Var object)",
          "1440:     {",
          "1441:         operationStack->Push(object);",
          "1442:     }",
          "1444:     Var ScriptContext::PopObject()",
          "1445:     {",
          "1446:         return operationStack->Pop();",
          "1447:     }",
          "1449:     BOOL ScriptContext::CheckObject(Var object)",
          "1450:     {",
          "1451:         return operationStack->Contains(object);",
          "1452:     }",
          "1454:     void ScriptContext::SetHostScriptContext(HostScriptContext *  hostScriptContext)",
          "1455:     {",
          "1456:         Assert(this->hostScriptContext == nullptr);",
          "1457:         this->hostScriptContext = hostScriptContext;",
          "1458: #ifdef PROFILE_EXEC",
          "1459:         this->ensureParentInfo = true;",
          "1460: #endif",
          "1461:     }",
          "1467:     void ScriptContext::SetScriptEngineHaltCallback(HaltCallback* scriptEngine)",
          "1468:     {",
          "1469:         Assert(this->scriptEngineHaltCallback == NULL);",
          "1470:         Assert(scriptEngine != NULL);",
          "1471:         this->scriptEngineHaltCallback = scriptEngine;",
          "1472:     }",
          "1474:     void ScriptContext::ClearHostScriptContext()",
          "1475:     {",
          "1476:         if (this->hostScriptContext != nullptr)",
          "1477:         {",
          "1478:             this->hostScriptContext->Delete();",
          "1479: #ifdef PROFILE_EXEC",
          "1480:             this->ensureParentInfo = false;",
          "1481: #endif",
          "1482:         }",
          "1483:     }",
          "1485:     IActiveScriptProfilerHeapEnum* ScriptContext::GetHeapEnum()",
          "1486:     {",
          "1487:         Assert(this->GetThreadContext());",
          "1488:         return this->GetThreadContext()->GetHeapEnum();",
          "1489:     }",
          "1491:     void ScriptContext::SetHeapEnum(IActiveScriptProfilerHeapEnum* newHeapEnum)",
          "1492:     {",
          "1493:         Assert(this->GetThreadContext());",
          "1494:         this->GetThreadContext()->SetHeapEnum(newHeapEnum);",
          "1495:     }",
          "1497:     void ScriptContext::ClearHeapEnum()",
          "1498:     {",
          "1499:         Assert(this->GetThreadContext());",
          "1500:         this->GetThreadContext()->ClearHeapEnum();",
          "1501:     }",
          "1503:     BOOL ScriptContext::VerifyAlive(BOOL isJSFunction, ScriptContext* requestScriptContext)",
          "1504:     {",
          "1505:         if (isClosed)",
          "1506:         {",
          "1507:             if (!requestScriptContext)",
          "1508:             {",
          "1509:                 requestScriptContext = this;",
          "1510:             }",
          "1512: #if ENABLE_PROFILE_INFO",
          "1513:             if (!GetThreadContext()->RecordImplicitException())",
          "1514:             {",
          "1515:                 return FALSE;",
          "1516:             }",
          "1517: #endif",
          "1518:             if (isJSFunction)",
          "1519:             {",
          "1520:                 Js::JavascriptError::MapAndThrowError(requestScriptContext, JSERR_CantExecute);",
          "1521:             }",
          "1522:             else",
          "1523:             {",
          "1524:                 Js::JavascriptError::MapAndThrowError(requestScriptContext, E_ACCESSDENIED);",
          "1525:             }",
          "1526:         }",
          "1527:         return TRUE;",
          "1528:     }",
          "1530:     void ScriptContext::VerifyAliveWithHostContext(BOOL isJSFunction, HostScriptContext* requestHostScriptContext)",
          "1531:     {",
          "1532:         if (requestHostScriptContext)",
          "1533:         {",
          "1534:             VerifyAlive(isJSFunction, requestHostScriptContext->GetScriptContext());",
          "1535:         }",
          "1536:         else",
          "1537:         {",
          "1538:             Assert(GetThreadContext()->IsJSRT() || !GetHostScriptContext()->HasCaller());",
          "1539:             VerifyAlive(isJSFunction, NULL);",
          "1540:         }",
          "1541:     }",
          "1544:     PropertyRecord const * ScriptContext::GetPropertyName(PropertyId propertyId)",
          "1545:     {",
          "1546:         return threadContext->GetPropertyName(propertyId);",
          "1547:     }",
          "1549:     PropertyRecord const * ScriptContext::GetPropertyNameLocked(PropertyId propertyId)",
          "1550:     {",
          "1551:         return threadContext->GetPropertyNameLocked(propertyId);",
          "1552:     }",
          "1554:     void ScriptContext::InitPropertyStringMap(int i)",
          "1555:     {",
          "1556:         propertyStrings[i] = AnewStruct(GeneralAllocator(), PropertyStringMap);",
          "1557:         memset(propertyStrings[i]->strLen2, 0, sizeof(PropertyString*)* 80);",
          "1558:     }",
          "1560:     void ScriptContext::TrackPid(const PropertyRecord* propertyRecord)",
          "1561:     {",
          "1562:         if (IsBuiltInPropertyId(propertyRecord->GetPropertyId()) || propertyRecord->IsBound())",
          "1563:         {",
          "1564:             return;",
          "1565:         }",
          "1567:         if (-1 != this->GetLibrary()->EnsureReferencedPropertyRecordList()->AddNew(propertyRecord))",
          "1568:         {",
          "1569:             RECYCLER_PERF_COUNTER_INC(PropertyRecordBindReference);",
          "1570:         }",
          "1571:     }",
          "1572:     void ScriptContext::TrackPid(PropertyId propertyId)",
          "1573:     {",
          "1574:         if (IsBuiltInPropertyId(propertyId))",
          "1575:         {",
          "1576:             return;",
          "1577:         }",
          "1578:         const PropertyRecord* propertyRecord = this->GetPropertyName(propertyId);",
          "1579:         Assert(propertyRecord != nullptr);",
          "1580:         this->TrackPid(propertyRecord);",
          "1581:     }",
          "1583:     bool ScriptContext::IsTrackedPropertyId(Js::PropertyId propertyId)",
          "1584:     {",
          "1585:         if (IsBuiltInPropertyId(propertyId))",
          "1586:         {",
          "1587:             return true;",
          "1588:         }",
          "1589:         const PropertyRecord* propertyRecord = this->GetPropertyName(propertyId);",
          "1590:         Assert(propertyRecord != nullptr);",
          "1591:         if (propertyRecord->IsBound())",
          "1592:         {",
          "1593:             return true;",
          "1594:         }",
          "1595:         JavascriptLibrary::ReferencedPropertyRecordHashSet * referencedPropertyRecords",
          "1596:             = this->GetLibrary()->GetReferencedPropertyRecordList();",
          "1597:         return referencedPropertyRecords && referencedPropertyRecords->Contains(propertyRecord);",
          "1598:     }",
          "1599:     PropertyString* ScriptContext::AddPropertyString2(const Js::PropertyRecord* propString)",
          "1600:     {",
          "1601:         const char16* buf = propString->GetBuffer();",
          "1602:         const uint i = PropertyStringMap::PStrMapIndex(buf[0]);",
          "1603:         if (propertyStrings[i] == NULL)",
          "1604:         {",
          "1605:             InitPropertyStringMap(i);",
          "1606:         }",
          "1607:         const uint j = PropertyStringMap::PStrMapIndex(buf[1]);",
          "1608:         if (propertyStrings[i]->strLen2[j] == NULL && !isClosed)",
          "1609:         {",
          "1610:             propertyStrings[i]->strLen2[j] = GetLibrary()->CreatePropertyString(propString, this->GeneralAllocator());",
          "1611:             this->TrackPid(propString);",
          "1612:         }",
          "1613:         return propertyStrings[i]->strLen2[j];",
          "1614:     }",
          "1616:     PropertyString* ScriptContext::CachePropertyString2(const PropertyRecord* propString)",
          "1617:     {",
          "1618:         Assert(propString->GetLength() == 2);",
          "1619:         const char16* propertyName = propString->GetBuffer();",
          "1620:         if ((propertyName[0] <= 'z') && (propertyName[1] <= 'z') && (propertyName[0] >= '0') && (propertyName[1] >= '0') && ((propertyName[0] > '9') || (propertyName[1] > '9')))",
          "1621:         {",
          "1622:             return AddPropertyString2(propString);",
          "1623:         }",
          "1624:         return NULL;",
          "1625:     }",
          "1627:     PropertyString* ScriptContext::TryGetPropertyString(PropertyId propertyId)",
          "1628:     {",
          "1629:         PropertyStringCacheMap* propertyStringMap = this->GetLibrary()->EnsurePropertyStringMap();",
          "1631:         RecyclerWeakReference<PropertyString>* stringReference;",
          "1632:         if (propertyStringMap->TryGetValue(propertyId, &stringReference))",
          "1633:         {",
          "1634:             PropertyString *string = stringReference->Get();",
          "1635:             if (string != nullptr)",
          "1636:             {",
          "1637:                 return string;",
          "1638:             }",
          "1639:         }",
          "1641:         return nullptr;",
          "1642:     }",
          "1644:     PropertyString* ScriptContext::GetPropertyString(PropertyId propertyId)",
          "1645:     {",
          "1646:         PropertyString *string = TryGetPropertyString(propertyId);",
          "1647:         if (string != nullptr)",
          "1648:         {",
          "1649:             return string;",
          "1650:         }",
          "1652:         PropertyStringCacheMap* propertyStringMap = this->GetLibrary()->EnsurePropertyStringMap();",
          "1654:         const Js::PropertyRecord* propertyName = this->GetPropertyName(propertyId);",
          "1655:         string = this->GetLibrary()->CreatePropertyString(propertyName);",
          "1656:         propertyStringMap->Item(propertyId, recycler->CreateWeakReferenceHandle(string));",
          "1658:         return string;",
          "1659:     }",
          "1661:     void ScriptContext::InvalidatePropertyStringCache(PropertyId propertyId, Type* type)",
          "1662:     {",
          "1663:         Assert(!isFinalized);",
          "1664:         PropertyStringCacheMap* propertyStringMap = this->javascriptLibrary->GetPropertyStringMap();",
          "1665:         if (propertyStringMap != nullptr)",
          "1666:         {",
          "1667:             PropertyString *string = nullptr;",
          "1668:             RecyclerWeakReference<PropertyString>* stringReference;",
          "1669:             if (propertyStringMap->TryGetValue(propertyId, &stringReference))",
          "1670:             {",
          "1671:                 string = stringReference->Get();",
          "1672:             }",
          "1673:             if (string)",
          "1674:             {",
          "1675:                 PropertyCache const* cache = string->GetPropertyCache();",
          "1676:                 if (cache->type == type)",
          "1677:                 {",
          "1678:                     string->ClearPropertyCache();",
          "1679:                 }",
          "1680:             }",
          "1681:         }",
          "1682:     }",
          "1684:     void ScriptContext::CleanupWeakReferenceDictionaries()",
          "1685:     {",
          "1686:         if (!isWeakReferenceDictionaryListCleared)",
          "1687:         {",
          "1688:             SListBase<JsUtil::IWeakReferenceDictionary*>::Iterator iter(&this->weakReferenceDictionaryList);",
          "1690:             while (iter.Next())",
          "1691:             {",
          "1692:                 JsUtil::IWeakReferenceDictionary* weakReferenceDictionary = iter.Data();",
          "1694:                 weakReferenceDictionary->Cleanup();",
          "1695:             }",
          "1696:         }",
          "1697:     }",
          "1699:     JavascriptString* ScriptContext::GetIntegerString(Var aValue)",
          "1700:     {",
          "1701:         return this->GetIntegerString(TaggedInt::ToInt32(aValue));",
          "1702:     }",
          "1704:     JavascriptString* ScriptContext::GetIntegerString(uint value)",
          "1705:     {",
          "1706:         if (value <= INT_MAX)",
          "1707:         {",
          "1708:             return this->GetIntegerString((int)value);",
          "1709:         }",
          "1710:         return TaggedInt::ToString(value, this);",
          "1711:     }",
          "1713:     JavascriptString* ScriptContext::GetIntegerString(int value)",
          "1714:     {",
          "1716:         if (0 <= value && value <= 9)",
          "1717:         {",
          "1718:             return GetLibrary()->GetCharStringCache().GetStringForCharA('0' + static_cast<char>(value));",
          "1719:         }",
          "1721:         JavascriptString *string;",
          "1723:         if (!this->integerStringMap.TryGetValue(value, &string))",
          "1724:         {",
          "1728:             if (this->integerStringMap.Count() > 1024)",
          "1729:             {",
          "1731:                 string = TaggedInt::ToString(value, this);",
          "1732:             }",
          "1733:             else",
          "1734:             {",
          "1735:                 char16 stringBuffer[20];",
          "1737:                 TaggedInt::ToBuffer(value, stringBuffer, _countof(stringBuffer));",
          "1738:                 string = JavascriptString::NewCopySzFromArena(stringBuffer, this, this->GeneralAllocator());",
          "1739:                 this->integerStringMap.AddNew(value, string);",
          "1740:             }",
          "1741:         }",
          "1743:         return string;",
          "1744:     }",
          "1746:     void ScriptContext::CheckEvalRestriction()",
          "1747:     {",
          "1748:         HRESULT hr = S_OK;",
          "1749:         Var domError = nullptr;",
          "1750:         HostScriptContext* hostScriptContext = this->GetHostScriptContext();",
          "1752:         BEGIN_LEAVE_SCRIPT(this)",
          "1753:         {",
          "1754:             if (!FAILED(hr = hostScriptContext->CheckEvalRestriction()))",
          "1755:             {",
          "1756:                 return;",
          "1757:             }",
          "1759:             hr = hostScriptContext->HostExceptionFromHRESULT(hr, &domError);",
          "1760:         }",
          "1761:         END_LEAVE_SCRIPT(this);",
          "1763:         if (FAILED(hr))",
          "1764:         {",
          "1765:             Js::JavascriptError::MapAndThrowError(this, hr);",
          "1766:         }",
          "1768:         if (domError != nullptr)",
          "1769:         {",
          "1770:             JavascriptExceptionOperators::Throw(domError, this);",
          "1771:         }",
          "1773:         AssertMsg(false, \"We should have thrown by now.\");",
          "1774:         Js::JavascriptError::MapAndThrowError(this, E_FAIL);",
          "1775:     }",
          "1777:     ParseNode* ScriptContext::ParseScript(Parser* parser,",
          "1778:         const byte* script,",
          "1779:         size_t cb,",
          "1780:         SRCINFO const * pSrcInfo,",
          "1781:         CompileScriptException * pse,",
          "1782:         Utf8SourceInfo** ppSourceInfo,",
          "1783:         const char16 *rootDisplayName,",
          "1784:         LoadScriptFlag loadScriptFlag,",
          "1785:         uint* sourceIndex,",
          "1786:         Js::Var scriptSource)",
          "1787:     {",
          "1788:         if (pSrcInfo == nullptr)",
          "1789:         {",
          "1790:             pSrcInfo = this->Cache()->noContextGlobalSourceInfo;",
          "1791:         }",
          "1793:         LPUTF8 utf8Script = nullptr;",
          "1794:         size_t length = cb;",
          "1795:         size_t cbNeeded = 0;",
          "1797:         bool isLibraryCode = ((loadScriptFlag & LoadScriptFlag_LibraryCode) == LoadScriptFlag_LibraryCode);",
          "1799:         if ((loadScriptFlag & LoadScriptFlag_Utf8Source) != LoadScriptFlag_Utf8Source)",
          "1800:         {",
          "1802:             length = cb / sizeof(char16);",
          "1803:             if (!IsValidCharCount(length))",
          "1804:             {",
          "1805:                 Js::Throw::OutOfMemory();",
          "1806:             }",
          "1807:             Assert(length < MAXLONG);",
          "1814:             size_t cbUtf8Buffer = AllocSizeMath::Mul(AllocSizeMath::Add(length, 1), 3);",
          "1816:             utf8Script = RecyclerNewArrayLeafTrace(this->GetRecycler(), utf8char_t, cbUtf8Buffer);",
          "1818:             cbNeeded = utf8::EncodeIntoAndNullTerminate(utf8Script, (const char16*)script, static_cast<charcount_t>(length));",
          "1820: #if DBG_DUMP && defined(PROFILE_MEM)",
          "1821:             if(Js::Configuration::Global.flags.TraceMemory.IsEnabled(Js::ParsePhase) && Configuration::Global.flags.Verbose)",
          "1822:             {",
          "1823:                 Output::Print(_u(\"Loading script.\\n\")",
          "1824:                     _u(\"  Unicode (in bytes)    %u\\n\")",
          "1825:                     _u(\"  UTF-8 size (in bytes) %u\\n\")",
          "1826:                     _u(\"  Expected savings      %d\\n\"), length * sizeof(char16), cbNeeded, length * sizeof(char16) - cbNeeded);",
          "1827:             }",
          "1828: #endif",
          "1831:             Assert(cbNeeded + 1 <= cbUtf8Buffer);",
          "1833:                 cbNeeded, pSrcInfo, isLibraryCode);",
          "1834:         }",
          "1835:         else",
          "1836:         {",
          "1838:             if(*ppSourceInfo == nullptr)",
          "1839:             {",
          "1840: #ifndef NTBUILD",
          "1841:                 if (loadScriptFlag & LoadScriptFlag_ExternalArrayBuffer)",
          "1842:                 {",
          "1844:                         script, (int)length, cb, pSrcInfo, isLibraryCode,",
          "1845:                         scriptSource);",
          "1846:                 }",
          "1847:                 else",
          "1848: #endif",
          "1849:                 {",
          "1853:                         (int)length, cb, pSrcInfo, isLibraryCode);",
          "1854:                 }",
          "1855:             }",
          "1856:         }",
          "1860:         HRESULT hr;",
          "1862:         SourceContextInfo * sourceContextInfo = pSrcInfo->sourceContextInfo;",
          "1867:         ULONG grfscr = fscrGlobalCode | ((loadScriptFlag & LoadScriptFlag_Expression) == LoadScriptFlag_Expression ? fscrReturnExpression : 0);",
          "1868:         if(((loadScriptFlag & LoadScriptFlag_disableDeferredParse) != LoadScriptFlag_disableDeferredParse) &&",
          "1869:             (length > Parser::GetDeferralThreshold(sourceContextInfo->IsSourceProfileLoaded())))",
          "1870:         {",
          "1871:             grfscr |= fscrDeferFncParse;",
          "1872:         }",
          "1874:         if((loadScriptFlag & LoadScriptFlag_disableAsmJs) == LoadScriptFlag_disableAsmJs)",
          "1875:         {",
          "1876:             grfscr |= fscrNoAsmJs;",
          "1877:         }",
          "1879:         if(PHASE_FORCE1(Js::EvalCompilePhase))",
          "1880:         {",
          "1882:             grfscr |= (fscrEval | fscrEvalCode);",
          "1883:         }",
          "1885:         if((loadScriptFlag & LoadScriptFlag_isByteCodeBufferForLibrary) == LoadScriptFlag_isByteCodeBufferForLibrary)",
          "1886:         {",
          "1887:             grfscr |= fscrNoPreJit;",
          "1888:         }",
          "1890:         if(((loadScriptFlag & LoadScriptFlag_Module) == LoadScriptFlag_Module) &&",
          "1891:             GetConfig()->IsES6ModuleEnabled())",
          "1892:         {",
          "1893:             grfscr |= fscrIsModuleCode;",
          "1894:         }",
          "1896:         if (isLibraryCode)",
          "1897:         {",
          "1898:             grfscr |= fscrIsLibraryCode;",
          "1899:         }",
          "1901:         ParseNodePtr parseTree;",
          "1902:         if((loadScriptFlag & LoadScriptFlag_Utf8Source) == LoadScriptFlag_Utf8Source)",
          "1903:         {",
          "1904:             hr = parser->ParseUtf8Source(&parseTree, script, cb, grfscr, pse,",
          "1905:                 &sourceContextInfo->nextLocalFunctionId, sourceContextInfo);",
          "1906:         }",
          "1907:         else",
          "1908:         {",
          "1909:             hr = parser->ParseCesu8Source(&parseTree, utf8Script, cbNeeded, grfscr,",
          "1910:                 pse, &sourceContextInfo->nextLocalFunctionId, sourceContextInfo);",
          "1911:         }",
          "1913:         if(FAILED(hr) || parseTree == nullptr)",
          "1914:         {",
          "1915:             return nullptr;",
          "1916:         }",
          "1918:         (*ppSourceInfo)->SetParseFlags(grfscr);",
          "1921:         if ((loadScriptFlag & LoadScriptFlag_Utf8Source) != LoadScriptFlag_Utf8Source)",
          "1922:         {",
          "1924:         }",
          "1925:         else",
          "1926:         {",
          "1928:             (*ppSourceInfo)->SetCchLength(parser->GetSourceIchLim());",
          "1930:         }",
          "1932:         return parseTree;",
          "1933:     }",
          "1935:     JavascriptFunction* ScriptContext::LoadScript(const byte* script, size_t cb,",
          "1936:         SRCINFO const * pSrcInfo, CompileScriptException * pse, Utf8SourceInfo** ppSourceInfo,",
          "1937:         const char16 *rootDisplayName, LoadScriptFlag loadScriptFlag, Js::Var scriptSource)",
          "1938:     {",
          "1939:         Assert(!this->threadContext->IsScriptActive());",
          "1940:         Assert(pse != nullptr);",
          "1941:         try",
          "1942:         {",
          "1943:             AUTO_NESTED_HANDLED_EXCEPTION_TYPE((ExceptionType)(ExceptionType_OutOfMemory | ExceptionType_StackOverflow));",
          "1944:             Js::AutoDynamicCodeReference dynamicFunctionReference(this);",
          "1945:             Parser parser(this);",
          "1946:             uint sourceIndex;",
          "1947:             JavascriptFunction * pFunction = nullptr;",
          "1949:             ParseNodePtr parseTree = ParseScript(&parser, script, cb, pSrcInfo,",
          "1950:                 pse, ppSourceInfo, rootDisplayName, loadScriptFlag,",
          "1951:                 &sourceIndex, scriptSource);",
          "1953:             if (parseTree != nullptr)",
          "1954:             {",
          "1955:                 pFunction = GenerateRootFunction(parseTree, sourceIndex, &parser, (*ppSourceInfo)->GetParseFlags(), pse, rootDisplayName);",
          "1956:             }",
          "1958:             if (pse->ei.scode == JSERR_AsmJsCompileError)",
          "1959:             {",
          "1960:                 Assert((loadScriptFlag & LoadScriptFlag_disableAsmJs) != LoadScriptFlag_disableAsmJs);",
          "1962:                 pse->Clear();",
          "1964:                 loadScriptFlag = (LoadScriptFlag)(loadScriptFlag | LoadScriptFlag_disableAsmJs);",
          "1965:                 return LoadScript(script, cb, pSrcInfo, pse, ppSourceInfo,",
          "1966:                     rootDisplayName, loadScriptFlag, scriptSource);",
          "1967:             }",
          "1969: #ifdef ENABLE_SCRIPT_PROFILING",
          "1970:             if (pFunction != nullptr && this->IsProfiling())",
          "1971:             {",
          "1972:                 RegisterScript(pFunction->GetFunctionProxy());",
          "1973:             }",
          "1974: #else",
          "1975:             Assert(!this->IsProfiling());",
          "1976: #endif",
          "1977:             return pFunction;",
          "1978:         }",
          "1979:         catch (Js::OutOfMemoryException)",
          "1980:         {",
          "1981:             pse->ProcessError(nullptr, E_OUTOFMEMORY, nullptr);",
          "1982:             return nullptr;",
          "1983:         }",
          "1984:         catch (Js::StackOverflowException)",
          "1985:         {",
          "1986:             pse->ProcessError(nullptr, VBSERR_OutOfStack, nullptr);",
          "1987:             return nullptr;",
          "1988:         }",
          "1989:     }",
          "1991:     JavascriptFunction* ScriptContext::GenerateRootFunction(ParseNodePtr parseTree, uint sourceIndex, Parser* parser, uint32 grfscr, CompileScriptException * pse, const char16 *rootDisplayName)",
          "1992:     {",
          "1993:         HRESULT hr;",
          "1996:         LPCUTF8 source = this->GetSource(sourceIndex)->GetSource(_u(\"ScriptContext::GenerateRootFunction\"));",
          "1997:         Assert(source != nullptr); // Source should not have been reclaimed by now",
          "2000:         ParseableFunctionInfo* body = NULL;",
          "2001:         hr = GenerateByteCode(parseTree, grfscr, this, &body, sourceIndex, false, parser, pse);",
          "2003:         this->GetSource(sourceIndex)->SetByteCodeGenerationFlags(grfscr);",
          "2004:         if(FAILED(hr))",
          "2005:         {",
          "2006:             return nullptr;",
          "2007:         }",
          "2009:         body->SetDisplayName(rootDisplayName);",
          "2010:         body->SetIsTopLevel(true);",
          "2012:         JavascriptFunction* rootFunction = javascriptLibrary->CreateScriptFunction(body);",
          "2013:         return rootFunction;",
          "2014:     }",
          "2016:     BOOL ScriptContext::ReserveStaticTypeIds(__in int first, __in int last)",
          "2017:     {",
          "2018:         return threadContext->ReserveStaticTypeIds(first, last);",
          "2019:     }",
          "2021:     TypeId ScriptContext::ReserveTypeIds(int count)",
          "2022:     {",
          "2023:         return threadContext->ReserveTypeIds(count);",
          "2024:     }",
          "2026:     TypeId ScriptContext::CreateTypeId()",
          "2027:     {",
          "2028:         return threadContext->CreateTypeId();",
          "2029:     }",
          "2031:     void ScriptContext::OnScriptStart(bool isRoot, bool isScript)",
          "2032:     {",
          "2033:         const bool isForcedEnter = this->GetDebugContext() != nullptr ? this->GetDebugContext()->GetProbeContainer()->isForcedToEnterScriptStart : false;",
          "2034:         if (this->scriptStartEventHandler != nullptr && ((isRoot && threadContext->GetCallRootLevel() == 1) || isForcedEnter))",
          "2035:         {",
          "2036:             if (this->GetDebugContext() != nullptr)",
          "2037:             {",
          "2038:                 this->GetDebugContext()->GetProbeContainer()->isForcedToEnterScriptStart = false;",
          "2039:             }",
          "2041:             this->scriptStartEventHandler(this);",
          "2042:         }",
          "2044: #if ENABLE_NATIVE_CODEGEN",
          "2046:         if (isScript)",
          "2047:         {",
          "2048:             NativeCodeGenEnterScriptStart(this->GetNativeCodeGenerator());",
          "2049:         }",
          "2050: #endif",
          "2051:     }",
          "2053:     void ScriptContext::OnScriptEnd(bool isRoot, bool isForcedEnd)",
          "2054:     {",
          "2055:         if ((isRoot && threadContext->GetCallRootLevel() == 1) || isForcedEnd)",
          "2056:         {",
          "2057:             if (this->scriptEndEventHandler != nullptr)",
          "2058:             {",
          "2059:                 this->scriptEndEventHandler(this);",
          "2060:             }",
          "2061:         }",
          "2062:     }",
          "2064: #ifdef FAULT_INJECTION",
          "2065:     void ScriptContext::DisposeScriptContextByFaultInjection() {",
          "2066:         if (this->disposeScriptByFaultInjectionEventHandler != nullptr)",
          "2067:         {",
          "2068:             this->disposeScriptByFaultInjectionEventHandler(this);",
          "2069:         }",
          "2070:     }",
          "2071: #endif",
          "2073:     template <bool stackProbe, bool leaveForHost>",
          "2074:     bool ScriptContext::LeaveScriptStart(void * frameAddress)",
          "2075:     {",
          "2076:         ThreadContext * threadContext = this->threadContext;",
          "2077:         if (!threadContext->IsScriptActive())",
          "2078:         {",
          "2080:             AssertMsg(FALSE, \"Leaving ScriptStart while script is not active.\");",
          "2081:             return false;",
          "2082:         }",
          "2085:         if (stackProbe)",
          "2086:         {",
          "2087:             threadContext->ProbeStack(Js::Constants::MinStackCallout, this);",
          "2088:         }",
          "2089:         else",
          "2090:         {",
          "2091:             AssertMsg(ExceptionCheck::HasStackProbe(), \"missing stack probe\");",
          "2092:         }",
          "2094:         threadContext->LeaveScriptStart<leaveForHost>(frameAddress);",
          "2095:         return true;",
          "2096:     }",
          "2098:     template <bool leaveForHost>",
          "2099:     void ScriptContext::LeaveScriptEnd(void * frameAddress)",
          "2100:     {",
          "2101:         this->threadContext->LeaveScriptEnd<leaveForHost>(frameAddress);",
          "2102:     }",
          "2105:     template bool ScriptContext::LeaveScriptStart<true, true>(void * frameAddress);",
          "2106:     template bool ScriptContext::LeaveScriptStart<true, false>(void * frameAddress);",
          "2107:     template bool ScriptContext::LeaveScriptStart<false, true>(void * frameAddress);",
          "2108:     template void ScriptContext::LeaveScriptEnd<true>(void * frameAddress);",
          "2109:     template void ScriptContext::LeaveScriptEnd<false>(void * frameAddress);",
          "2111:     bool ScriptContext::EnsureInterpreterArena(ArenaAllocator **ppAlloc)",
          "2112:     {",
          "2113:         bool fNew = false;",
          "2114:         if (this->interpreterArena == nullptr)",
          "2115:         {",
          "2116:             this->interpreterArena = this->GetRecycler()->CreateGuestArena(_u(\"Interpreter\"), Throw::OutOfMemory);",
          "2117:             fNew = true;",
          "2118:         }",
          "2120:         return fNew;",
          "2121:     }",
          "2123:     void ScriptContext::ReleaseInterpreterArena()",
          "2124:     {",
          "2125:         AssertMsg(this->interpreterArena, \"No interpreter arena to release\");",
          "2126:         if (this->interpreterArena)",
          "2127:         {",
          "2128:             this->GetRecycler()->DeleteGuestArena(this->interpreterArena);",
          "2129:             this->interpreterArena = nullptr;",
          "2130:         }",
          "2131:     }",
          "2134:     void ScriptContext::ReleaseGuestArena()",
          "2135:     {",
          "2136:         AssertMsg(this->guestArena, \"No guest arena to release\");",
          "2137:         if (this->guestArena)",
          "2138:         {",
          "2139:             this->GetRecycler()->DeleteGuestArena(this->guestArena);",
          "2140:             this->guestArena = nullptr;",
          "2141:         }",
          "2142:     }",
          "2144:     void ScriptContext::SetScriptStartEventHandler(ScriptContext::EventHandler eventHandler)",
          "2145:     {",
          "2146:         AssertMsg(this->scriptStartEventHandler == nullptr, \"Do not support multi-cast yet\");",
          "2147:         this->scriptStartEventHandler = eventHandler;",
          "2148:     }",
          "2149:     void ScriptContext::SetScriptEndEventHandler(ScriptContext::EventHandler eventHandler)",
          "2150:     {",
          "2151:         AssertMsg(this->scriptEndEventHandler == nullptr, \"Do not support multi-cast yet\");",
          "2152:         this->scriptEndEventHandler = eventHandler;",
          "2153:     }",
          "2155: #ifdef FAULT_INJECTION",
          "2156:     void ScriptContext::SetDisposeDisposeByFaultInjectionEventHandler(ScriptContext::EventHandler eventHandler)",
          "2157:     {",
          "2158:         AssertMsg(this->disposeScriptByFaultInjectionEventHandler == nullptr, \"Do not support multi-cast yet\");",
          "2159:         this->disposeScriptByFaultInjectionEventHandler = eventHandler;",
          "2160:     }",
          "2161: #endif",
          "2163:     bool ScriptContext::SaveSourceCopy(Utf8SourceInfo* const sourceInfo, int cchLength, bool isCesu8, uint * index)",
          "2164:     {",
          "2165:         HRESULT hr = S_OK;",
          "2166:         BEGIN_TRANSLATE_OOM_TO_HRESULT",
          "2167:         {",
          "2169:         }",
          "2170:         END_TRANSLATE_OOM_TO_HRESULT(hr);",
          "2171:         return hr == S_OK;",
          "2172:     }",
          "2174:     uint ScriptContext::SaveSourceCopy(Utf8SourceInfo* sourceInfo, int cchLength, bool isCesu8)",
          "2175:     {",
          "2176:         Utf8SourceInfo* newSource = Utf8SourceInfo::Clone(this, sourceInfo);",
          "2178:         return SaveSourceNoCopy(newSource, cchLength, isCesu8);",
          "2179:     }",
          "2182:     uint ScriptContext::SaveSourceNoCopy(Utf8SourceInfo* sourceInfo, int cchLength, bool isCesu8)",
          "2183:     {",
          "2184:         Assert(sourceInfo->GetScriptContext() == this);",
          "2186:         if (this->IsScriptContextInDebugMode() && !sourceInfo->GetIsLibraryCode() && !sourceInfo->IsInDebugMode())",
          "2187:         {",
          "2188:             sourceInfo->SetInDebugMode(true);",
          "2189:         }",
          "2191:         RecyclerWeakReference<Utf8SourceInfo>* sourceWeakRef = this->GetRecycler()->CreateWeakReferenceHandle<Utf8SourceInfo>(sourceInfo);",
          "2192:         sourceInfo->SetIsCesu8(isCesu8);",
          "2193:         {",
          "2196:             AutoCriticalSection autocs(GetThreadContext()->GetEtwRundownCriticalSection());",
          "2197:             return sourceList->SetAtFirstFreeSpot(sourceWeakRef);",
          "2198:         }",
          "2199:     }",
          "2201:     void ScriptContext::CloneSources(ScriptContext* sourceContext)",
          "2202:     {",
          "2203:         sourceContext->sourceList->Map([=](int index, RecyclerWeakReference<Utf8SourceInfo>* sourceInfo)",
          "2204:         {",
          "2205:             Utf8SourceInfo* info = sourceInfo->Get();",
          "2206:             if (info)",
          "2207:             {",
          "2208:                 CloneSource(info);",
          "2209:             }",
          "2210:         });",
          "2211:     }",
          "2213:     uint ScriptContext::CloneSource(Utf8SourceInfo* info)",
          "2214:     {",
          "2215:         return this->SaveSourceCopy(info, info->GetCchLength(), info->GetIsCesu8());",
          "2216:     }",
          "2218:     Utf8SourceInfo* ScriptContext::GetSource(uint index)",
          "2219:     {",
          "2220:         Assert(this->sourceList->IsItemValid(index)); // This assert should be a subset of info != null- if info was null, in the last collect, we'd have invalidated the item",
          "2221:         Utf8SourceInfo* info = this->sourceList->Item(index)->Get();",
          "2222:         Assert(info != nullptr); // Should still be alive if this method is being called",
          "2223:         return info;",
          "2224:     }",
          "2226:     bool ScriptContext::IsItemValidInSourceList(int index)",
          "2227:     {",
          "2228:         return (index < this->sourceList->Count()) && this->sourceList->IsItemValid(index);",
          "2229:     }",
          "2231:     void ScriptContext::RecordException(JavascriptExceptionObject * exceptionObject, bool propagateToDebugger)",
          "2232:     {",
          "2233:         Assert(this->threadContext->GetRecordedException() == nullptr || GetThreadContext()->HasUnhandledException());",
          "2234:         this->threadContext->SetRecordedException(exceptionObject, propagateToDebugger);",
          "2235: #if DBG && ENABLE_DEBUG_STACK_BACK_TRACE",
          "2236:         exceptionObject->FillStackBackTrace();",
          "2237: #endif",
          "2238:     }",
          "2240:     void ScriptContext::RethrowRecordedException(JavascriptExceptionObject::HostWrapperCreateFuncType hostWrapperCreateFunc)",
          "2241:     {",
          "2242:         bool considerPassingToDebugger = false;",
          "2243:         JavascriptExceptionObject * exceptionObject = this->GetAndClearRecordedException(&considerPassingToDebugger);",
          "2244:         if (hostWrapperCreateFunc)",
          "2245:         {",
          "2246:             exceptionObject->SetHostWrapperCreateFunc(exceptionObject->GetScriptContext() != this ? hostWrapperCreateFunc : nullptr);",
          "2247:         }",
          "2248:         JavascriptExceptionOperators::RethrowExceptionObject(exceptionObject, this, considerPassingToDebugger);",
          "2249:     }",
          "2251:     Js::JavascriptExceptionObject * ScriptContext::GetAndClearRecordedException(bool *considerPassingToDebugger)",
          "2252:     {",
          "2253:         JavascriptExceptionObject * exceptionObject = this->threadContext->GetRecordedException();",
          "2254:         Assert(exceptionObject != nullptr);",
          "2255:         if (considerPassingToDebugger)",
          "2256:         {",
          "2258:         }",
          "2259:         exceptionObject = exceptionObject->CloneIfStaticExceptionObject(this);",
          "2260:         this->threadContext->SetRecordedException(nullptr);",
          "2261:         return exceptionObject;",
          "2262:     }",
          "2264:     bool ScriptContext::IsInEvalMap(FastEvalMapString const& key, BOOL isIndirect, ScriptFunction **ppFuncScript)",
          "2265:     {",
          "2266:         EvalCacheDictionary *dict = isIndirect ? this->Cache()->indirectEvalCacheDictionary : this->Cache()->evalCacheDictionary;",
          "2267:         if (dict == nullptr)",
          "2268:         {",
          "2269:             return false;",
          "2270:         }",
          "2271: #ifdef PROFILE_EVALMAP",
          "2272:         if (Configuration::Global.flags.ProfileEvalMap)",
          "2273:         {",
          "2274:             charcount_t len = key.str.GetLength();",
          "2275:             if (dict->TryGetValue(key, ppFuncScript))",
          "2276:             {",
          "2277:                 Output::Print(_u(\"EvalMap cache hit:\\t source size = %d\\n\"), len);",
          "2278:             }",
          "2279:             else",
          "2280:             {",
          "2281:                 Output::Print(_u(\"EvalMap cache miss:\\t source size = %d\\n\"), len);",
          "2282:             }",
          "2283:         }",
          "2284: #endif",
          "2287:         bool success = dict->TryGetValue(key, ppFuncScript);",
          "2289:         if (success)",
          "2290:         {",
          "2291:             dict->NotifyAdd(key);",
          "2292: #ifdef VERBOSE_EVAL_MAP",
          "2293: #if DBG",
          "2294:             dict->DumpKeepAlives();",
          "2295: #endif",
          "2296: #endif",
          "2297:         }",
          "2299:         return success;",
          "2300:     }",
          "2302:     void ScriptContext::AddToEvalMap(FastEvalMapString const& key, BOOL isIndirect, ScriptFunction *pFuncScript)",
          "2303:     {",
          "2304:         EvalCacheDictionary *dict = isIndirect ? this->Cache()->indirectEvalCacheDictionary : this->Cache()->evalCacheDictionary;",
          "2305:         if (dict == nullptr)",
          "2306:         {",
          "2307:             EvalCacheTopLevelDictionary* evalTopDictionary = RecyclerNew(this->recycler, EvalCacheTopLevelDictionary, this->recycler);",
          "2308:             dict = RecyclerNew(this->recycler, EvalCacheDictionary, evalTopDictionary, recycler);",
          "2309:             if (isIndirect)",
          "2310:             {",
          "2311:                 this->Cache()->indirectEvalCacheDictionary = dict;",
          "2312:             }",
          "2313:             else",
          "2314:             {",
          "2315:                 this->Cache()->evalCacheDictionary = dict;",
          "2316:             }",
          "2317:         }",
          "2319:         dict->Add(key, pFuncScript);",
          "2320:     }",
          "2322:     bool ScriptContext::IsInNewFunctionMap(EvalMapString const& key, FunctionInfo **ppFuncInfo)",
          "2323:     {",
          "2324:         if (this->Cache()->newFunctionCache == nullptr)",
          "2325:         {",
          "2326:             return false;",
          "2327:         }",
          "2330:         bool success = this->Cache()->newFunctionCache->TryGetValue(key, ppFuncInfo);",
          "2331:         if (success)",
          "2332:         {",
          "2333:             this->Cache()->newFunctionCache->NotifyAdd(key);",
          "2334: #ifdef VERBOSE_EVAL_MAP",
          "2335: #if DBG",
          "2336:             this->Cache()->newFunctionCache->DumpKeepAlives();",
          "2337: #endif",
          "2338: #endif",
          "2339:         }",
          "2341:         return success;",
          "2342:     }",
          "2344:     void ScriptContext::AddToNewFunctionMap(EvalMapString const& key, FunctionInfo *pFuncInfo)",
          "2345:     {",
          "2346:         if (this->Cache()->newFunctionCache == nullptr)",
          "2347:         {",
          "2348:             this->Cache()->newFunctionCache = RecyclerNew(this->recycler, NewFunctionCache, this->recycler);",
          "2349:         }",
          "2350:         this->Cache()->newFunctionCache->Add(key, pFuncInfo);",
          "2351:     }",
          "2354:     void ScriptContext::EnsureSourceContextInfoMap()",
          "2355:     {",
          "2356:         if (this->Cache()->sourceContextInfoMap == nullptr)",
          "2357:         {",
          "2358:             this->Cache()->sourceContextInfoMap = RecyclerNew(this->GetRecycler(), SourceContextInfoMap, this->GetRecycler());",
          "2359:         }",
          "2360:     }",
          "2362:     void ScriptContext::EnsureDynamicSourceContextInfoMap()",
          "2363:     {",
          "2364:         if (this->Cache()->dynamicSourceContextInfoMap == nullptr)",
          "2365:         {",
          "2366:             this->Cache()->dynamicSourceContextInfoMap = RecyclerNew(this->GetRecycler(), DynamicSourceContextInfoMap, this->GetRecycler());",
          "2367:         }",
          "2368:     }",
          "2370:     SourceContextInfo* ScriptContext::GetSourceContextInfo(uint hash)",
          "2371:     {",
          "2372:         SourceContextInfo * sourceContextInfo;",
          "2373:         if (this->Cache()->dynamicSourceContextInfoMap && this->Cache()->dynamicSourceContextInfoMap->TryGetValue(hash, &sourceContextInfo))",
          "2374:         {",
          "2375:             return sourceContextInfo;",
          "2376:         }",
          "2377:         return nullptr;",
          "2378:     }",
          "2380:     SourceContextInfo* ScriptContext::CreateSourceContextInfo(uint hash, DWORD_PTR hostSourceContext)",
          "2381:     {",
          "2382:         EnsureDynamicSourceContextInfoMap();",
          "2383:         if (this->GetSourceContextInfo(hash) != nullptr)",
          "2384:         {",
          "2385:             return this->Cache()->noContextSourceContextInfo;",
          "2386:         }",
          "2388:         if (this->Cache()->dynamicSourceContextInfoMap->Count() > INMEMORY_CACHE_MAX_PROFILE_MANAGER)",
          "2389:         {",
          "2390:             OUTPUT_TRACE(Js::DynamicProfilePhase, _u(\"Max of dynamic script profile info reached.\\n\"));",
          "2391:             return this->Cache()->noContextSourceContextInfo;",
          "2392:         }",
          "2395:         SourceContextInfo * sourceContextInfo = RecyclerNewStructZ(this->GetRecycler(), SourceContextInfo);",
          "2396:         sourceContextInfo->sourceContextId = this->GetNextSourceContextId();",
          "2397:         sourceContextInfo->dwHostSourceContext = hostSourceContext;",
          "2398:         sourceContextInfo->isHostDynamicDocument = true;",
          "2399:         sourceContextInfo->hash = hash;",
          "2400: #if ENABLE_PROFILE_INFO",
          "2401:         sourceContextInfo->sourceDynamicProfileManager = this->threadContext->GetSourceDynamicProfileManager(this->GetUrl(), hash, &referencesSharedDynamicSourceContextInfo);",
          "2402: #endif",
          "2405:         if (hostSourceContext == Js::Constants::NoHostSourceContext)",
          "2406:         {",
          "2407:             this->Cache()->dynamicSourceContextInfoMap->Add(hash, sourceContextInfo);",
          "2408:         }",
          "2409:         return sourceContextInfo;",
          "2410:     }",
          "2415:     SourceContextInfo * ScriptContext::CreateSourceContextInfo(DWORD_PTR sourceContext, char16 const * url, size_t len,",
          "2416:         IActiveScriptDataCache* profileDataCache, char16 const * sourceMapUrl /*= NULL*/, size_t sourceMapUrlLen /*= 0*/)",
          "2417:     {",
          "2419:         AutoCriticalSection autocs(GetThreadContext()->GetEtwRundownCriticalSection());",
          "2421:         EnsureSourceContextInfoMap();",
          "2422:         Assert(this->GetSourceContextInfo(sourceContext, profileDataCache) == nullptr);",
          "2423:         SourceContextInfo * sourceContextInfo = RecyclerNewStructZ(this->GetRecycler(), SourceContextInfo);",
          "2424:         sourceContextInfo->sourceContextId = this->GetNextSourceContextId();",
          "2425:         sourceContextInfo->dwHostSourceContext = sourceContext;",
          "2426:         sourceContextInfo->isHostDynamicDocument = false;",
          "2427: #if ENABLE_PROFILE_INFO",
          "2428:         sourceContextInfo->sourceDynamicProfileManager = nullptr;",
          "2429: #endif",
          "2431:         if (url != nullptr)",
          "2432:         {",
          "2433:             sourceContextInfo->url = CopyString(url, len, this->SourceCodeAllocator());",
          "2434:             JS_ETW(EtwTrace::LogSourceModuleLoadEvent(this, sourceContext, url));",
          "2435:         }",
          "2436:         if (sourceMapUrl != nullptr && sourceMapUrlLen != 0)",
          "2437:         {",
          "2438:             sourceContextInfo->sourceMapUrl = CopyString(sourceMapUrl, sourceMapUrlLen, this->SourceCodeAllocator());",
          "2439:         }",
          "2441: #if ENABLE_PROFILE_INFO",
          "2442:         if (!this->startupComplete)",
          "2443:         {",
          "2444:             sourceContextInfo->sourceDynamicProfileManager = SourceDynamicProfileManager::LoadFromDynamicProfileStorage(sourceContextInfo, this, profileDataCache);",
          "2445:             Assert(sourceContextInfo->sourceDynamicProfileManager != NULL);",
          "2446:         }",
          "2448:         this->Cache()->sourceContextInfoMap->Add(sourceContext, sourceContextInfo);",
          "2449: #endif",
          "2450:         return sourceContextInfo;",
          "2451:     }",
          "2454:     const char16* ScriptContext::CopyString(const char16* str, size_t charCount, ArenaAllocator* alloc)",
          "2455:     {",
          "2456:         size_t length = charCount + 1; // Add 1 for the NULL.",
          "2457:         char16* copy = AnewArray(alloc, char16, length);",
          "2458:         js_wmemcpy_s(copy, length, str, charCount);",
          "2459:         copy[length - 1] = _u('\\0');",
          "2460:         return copy;",
          "2461:     }",
          "2463:     SourceContextInfo *  ScriptContext::GetSourceContextInfo(DWORD_PTR sourceContext, IActiveScriptDataCache* profileDataCache)",
          "2464:     {",
          "2465:         if (sourceContext == Js::Constants::NoHostSourceContext)",
          "2466:         {",
          "2467:             return this->Cache()->noContextSourceContextInfo;",
          "2468:         }",
          "2471:         EnsureSourceContextInfoMap();",
          "2472:         SourceContextInfo * sourceContextInfo;",
          "2473:         if (this->Cache()->sourceContextInfoMap->TryGetValue(sourceContext, &sourceContextInfo))",
          "2474:         {",
          "2475: #if ENABLE_PROFILE_INFO",
          "2476:             if (profileDataCache &&",
          "2477:                 sourceContextInfo->sourceDynamicProfileManager != nullptr &&",
          "2478:                 !sourceContextInfo->sourceDynamicProfileManager->IsProfileLoadedFromWinInet() &&",
          "2479:                 !this->startupComplete)",
          "2480:             {",
          "2481:                 bool profileLoaded = sourceContextInfo->sourceDynamicProfileManager->LoadFromProfileCache(profileDataCache, sourceContextInfo->url);",
          "2482:                 if (profileLoaded)",
          "2483:                 {",
          "2484:                     JS_ETW(EventWriteJSCRIPT_PROFILE_LOAD(sourceContextInfo->dwHostSourceContext, this));",
          "2485:                 }",
          "2486:             }",
          "2487: #endif",
          "2488:             return sourceContextInfo;",
          "2489:         }",
          "2490:         return nullptr;",
          "2491:     }",
          "2493:     SRCINFO const *",
          "2494:         ScriptContext::GetModuleSrcInfo(Js::ModuleID moduleID)",
          "2495:     {",
          "2496:             if (moduleSrcInfoCount <= moduleID)",
          "2497:             {",
          "2498:                 uint newCount = moduleID + 4;  // Preallocate 4 more slots, moduleID don't usually grow much",
          "2500:                 Field(SRCINFO const *)* newModuleSrcInfo = RecyclerNewArrayZ(this->GetRecycler(), Field(SRCINFO const*), newCount);",
          "2501:                 CopyArray(newModuleSrcInfo, newCount, Cache()->moduleSrcInfo, moduleSrcInfoCount);",
          "2502:                 Cache()->moduleSrcInfo = newModuleSrcInfo;",
          "2503:                 moduleSrcInfoCount = newCount;",
          "2504:                 Cache()->moduleSrcInfo[0] = this->Cache()->noContextGlobalSourceInfo;",
          "2505:             }",
          "2507:             SRCINFO const * si = Cache()->moduleSrcInfo[moduleID];",
          "2508:             if (si == nullptr)",
          "2509:             {",
          "2510:                 SRCINFO * newSrcInfo = RecyclerNewStructZ(this->GetRecycler(), SRCINFO);",
          "2511:                 newSrcInfo->sourceContextInfo = this->Cache()->noContextSourceContextInfo;",
          "2512:                 newSrcInfo->moduleID = moduleID;",
          "2513:                 Cache()->moduleSrcInfo[moduleID] = newSrcInfo;",
          "2514:                 si = newSrcInfo;",
          "2515:             }",
          "2516:             return si;",
          "2517:     }",
          "2519: #if ENABLE_TTD",
          "2520:     void ScriptContext::InitializeCoreImage_TTD()",
          "2521:     {",
          "2522:         TTDAssert(this->TTDWellKnownInfo == nullptr, \"This should only happen once!!!\");",
          "2524:         this->TTDContextInfo = TT_HEAP_NEW(TTD::ScriptContextTTD, this);",
          "2525:         this->TTDWellKnownInfo = TT_HEAP_NEW(TTD::RuntimeContextInfo);",
          "2527:         BEGIN_ENTER_SCRIPT(this, true, true, true)",
          "2528:         {",
          "2529:             this->TTDWellKnownInfo->GatherKnownObjectToPathMap(this);",
          "2530:         }",
          "2531:         END_ENTER_SCRIPT",
          "2532:     }",
          "2533: #endif",
          "2535: #ifdef PROFILE_EXEC",
          "2536:     void",
          "2537:         ScriptContext::DisableProfiler()",
          "2538:     {",
          "2539:             disableProfiler = true;",
          "2540:     }",
          "2542:     Profiler *",
          "2543:         ScriptContext::CreateProfiler()",
          "2544:     {",
          "2545:             Assert(profiler == nullptr);",
          "2546:             if (Js::Configuration::Global.flags.IsEnabled(Js::ProfileFlag))",
          "2547:             {",
          "2548:                 this->profiler = NoCheckHeapNew(ScriptContextProfiler);",
          "2549:                 this->profiler->Initialize(GetThreadContext()->GetPageAllocator(), threadContext->GetRecycler());",
          "2551: #if ENABLE_NATIVE_CODEGEN",
          "2552:                 CreateProfilerNativeCodeGen(this->nativeCodeGen, this->profiler);",
          "2553: #endif",
          "2555:                 this->isProfilerCreated = true;",
          "2556:                 Profiler * oldProfiler = this->threadContext->GetRecycler()->GetProfiler();",
          "2557:                 this->threadContext->GetRecycler()->SetProfiler(this->profiler->GetProfiler(), this->profiler->GetBackgroundRecyclerProfiler());",
          "2558:                 return oldProfiler;",
          "2559:             }",
          "2560:             return nullptr;",
          "2561:     }",
          "2563:     void",
          "2564:         ScriptContext::SetRecyclerProfiler()",
          "2565:     {",
          "2566:             Assert(Js::Configuration::Global.flags.IsEnabled(Js::ProfileFlag));",
          "2567:             AssertMsg(this->profiler != nullptr, \"Profiler tag is supplied but the profiler pointer is NULL\");",
          "2569:             if (this->ensureParentInfo)",
          "2570:             {",
          "2571:                 this->hostScriptContext->EnsureParentInfo();",
          "2572:                 this->ensureParentInfo = false;",
          "2573:             }",
          "2575:             this->GetRecycler()->SetProfiler(this->profiler->GetProfiler(), this->profiler->GetBackgroundRecyclerProfiler());",
          "2576:     }",
          "2578:     void",
          "2579:         ScriptContext::SetProfilerFromScriptContext(ScriptContext * scriptContext)",
          "2580:     {",
          "2583:             if (Js::Configuration::Global.flags.IsEnabled(Js::ProfileFlag))",
          "2584:             {",
          "2585:                 Assert(this->profiler != nullptr);",
          "2586:                 Assert(this->isProfilerCreated);",
          "2587:                 Assert(scriptContext->profiler != nullptr);",
          "2588:                 Assert(scriptContext->isProfilerCreated);",
          "2591:                 scriptContext->profiler->ProfileMerge(this->profiler);",
          "2593:                 this->profiler->Release();",
          "2594:                 this->profiler = scriptContext->profiler;",
          "2595:                 this->profiler->AddRef();",
          "2596:                 this->isProfilerCreated = false;",
          "2598: #if ENABLE_NATIVE_CODEGEN",
          "2599:                 SetProfilerFromNativeCodeGen(this->nativeCodeGen, scriptContext->GetNativeCodeGenerator());",
          "2600: #endif",
          "2602:                 this->threadContext->GetRecycler()->SetProfiler(this->profiler->GetProfiler(), this->profiler->GetBackgroundRecyclerProfiler());",
          "2603:             }",
          "2604:     }",
          "2606:     void",
          "2607:         ScriptContext::ProfileBegin(Js::Phase phase)",
          "2608:     {",
          "2609:             AssertMsg((this->profiler != nullptr) == Js::Configuration::Global.flags.IsEnabled(Js::ProfileFlag),",
          "2610:                 \"Profiler tag is supplied but the profiler pointer is NULL\");",
          "2611:             if (this->profiler)",
          "2612:             {",
          "2613:                 if (this->ensureParentInfo)",
          "2614:                 {",
          "2615:                     this->hostScriptContext->EnsureParentInfo();",
          "2616:                     this->ensureParentInfo = false;",
          "2617:                 }",
          "2618:                 this->profiler->ProfileBegin(phase);",
          "2619:             }",
          "2620:     }",
          "2622:     void",
          "2623:         ScriptContext::ProfileEnd(Js::Phase phase)",
          "2624:     {",
          "2625:             AssertMsg((this->profiler != nullptr) == Js::Configuration::Global.flags.IsEnabled(Js::ProfileFlag),",
          "2626:                 \"Profiler tag is supplied but the profiler pointer is NULL\");",
          "2627:             if (this->profiler)",
          "2628:             {",
          "2629:                 this->profiler->ProfileEnd(phase);",
          "2630:             }",
          "2631:     }",
          "2633:     void",
          "2634:         ScriptContext::ProfileSuspend(Js::Phase phase, Js::Profiler::SuspendRecord * suspendRecord)",
          "2635:     {",
          "2636:             AssertMsg((this->profiler != nullptr) == Js::Configuration::Global.flags.IsEnabled(Js::ProfileFlag),",
          "2637:                 \"Profiler tag is supplied but the profiler pointer is NULL\");",
          "2638:             if (this->profiler)",
          "2639:             {",
          "2640:                 this->profiler->ProfileSuspend(phase, suspendRecord);",
          "2641:             }",
          "2642:     }",
          "2644:     void",
          "2645:         ScriptContext::ProfileResume(Js::Profiler::SuspendRecord * suspendRecord)",
          "2646:     {",
          "2647:             AssertMsg((this->profiler != nullptr) == Js::Configuration::Global.flags.IsEnabled(Js::ProfileFlag),",
          "2648:                 \"Profiler tag is supplied but the profiler pointer is NULL\");",
          "2649:             if (this->profiler)",
          "2650:             {",
          "2651:                 this->profiler->ProfileResume(suspendRecord);",
          "2652:             }",
          "2653:     }",
          "2655:     void",
          "2656:         ScriptContext::ProfilePrint()",
          "2657:     {",
          "2658:             if (disableProfiler)",
          "2659:             {",
          "2660:                 return;",
          "2661:             }",
          "2663:             Assert(profiler != nullptr);",
          "2664:             recycler->EnsureNotCollecting();",
          "2665:             profiler->ProfilePrint(Js::Configuration::Global.flags.Profile.GetFirstPhase());",
          "2666: #if ENABLE_NATIVE_CODEGEN",
          "2667:             ProfilePrintNativeCodeGen(this->nativeCodeGen);",
          "2668: #endif",
          "2669:     }",
          "2670: #endif",
          "2672: #ifdef ENABLE_SCRIPT_PROFILING",
          "2673:     inline void ScriptContext::CoreSetProfileEventMask(DWORD dwEventMask)",
          "2674:     {",
          "2675:         AssertMsg(m_pProfileCallback != NULL, \"Assigning the event mask when there is no callback\");",
          "2676:         m_dwEventMask = dwEventMask;",
          "2677:         m_fTraceFunctionCall = (dwEventMask & PROFILER_EVENT_MASK_TRACE_SCRIPT_FUNCTION_CALL);",
          "2678:         m_fTraceNativeFunctionCall = (dwEventMask & PROFILER_EVENT_MASK_TRACE_NATIVE_FUNCTION_CALL);",
          "2680:         m_fTraceDomCall = (dwEventMask & PROFILER_EVENT_MASK_TRACE_DOM_FUNCTION_CALL);",
          "2681:     }",
          "2683:     HRESULT ScriptContext::RegisterProfileProbe(IActiveScriptProfilerCallback *pProfileCallback, DWORD dwEventMask, DWORD dwContext, RegisterExternalLibraryType RegisterExternalLibrary, JavascriptMethod dispatchInvoke)",
          "2684:     {",
          "2685:         if (m_pProfileCallback != NULL)",
          "2686:         {",
          "2687:             return ACTIVPROF_E_PROFILER_PRESENT;",
          "2688:         }",
          "2690:         OUTPUT_TRACE(Js::ScriptProfilerPhase, _u(\"ScriptContext::RegisterProfileProbe\\n\"));",
          "2691:         OUTPUT_TRACE(Js::ScriptProfilerPhase, _u(\"Info\\nThunks Address :\\n\"));",
          "2692:         OUTPUT_TRACE(Js::ScriptProfilerPhase, _u(\"DefaultEntryThunk : 0x%08X, CrossSite::DefaultThunk : 0x%08X, DefaultDeferredParsingThunk : 0x%08X\\n\"), DefaultEntryThunk, CrossSite::DefaultThunk, DefaultDeferredParsingThunk);",
          "2693:         OUTPUT_TRACE(Js::ScriptProfilerPhase, _u(\"ProfileEntryThunk : 0x%08X, CrossSite::ProfileThunk : 0x%08X, ProfileDeferredParsingThunk : 0x%08X, ProfileDeferredDeserializeThunk : 0x%08X,\\n\"), ProfileEntryThunk, CrossSite::ProfileThunk, ProfileDeferredParsingThunk, ProfileDeferredDeserializeThunk);",
          "2694:         OUTPUT_TRACE(Js::ScriptProfilerPhase, _u(\"ScriptType :\\n\"));",
          "2695:         OUTPUT_TRACE(Js::ScriptProfilerPhase, _u(\"PROFILER_SCRIPT_TYPE_USER : 0, PROFILER_SCRIPT_TYPE_DYNAMIC : 1, PROFILER_SCRIPT_TYPE_NATIVE : 2, PROFILER_SCRIPT_TYPE_DOM : 3\\n\"));",
          "2697:         HRESULT hr = pProfileCallback->Initialize(dwContext);",
          "2698:         if (SUCCEEDED(hr))",
          "2699:         {",
          "2700:             m_pProfileCallback = pProfileCallback;",
          "2701:             pProfileCallback->AddRef();",
          "2702:             CoreSetProfileEventMask(dwEventMask);",
          "2703:             if (m_fTraceDomCall)",
          "2704:             {",
          "2705:                 if (FAILED(pProfileCallback->QueryInterface(&m_pProfileCallback2)))",
          "2706:                 {",
          "2707:                     m_fTraceDomCall = FALSE;",
          "2708:                 }",
          "2709:             }",
          "2711:             if (webWorkerId != Js::Constants::NonWebWorkerContextId)",
          "2712:             {",
          "2713:                 IActiveScriptProfilerCallback3 * pProfilerCallback3;",
          "2714:                 if (SUCCEEDED(pProfileCallback->QueryInterface(&pProfilerCallback3)))",
          "2715:                 {",
          "2716:                     pProfilerCallback3->SetWebWorkerId(webWorkerId);",
          "2717:                     pProfilerCallback3->Release();",
          "2719:                 }",
          "2720:             }",
          "2722: #if DEBUG",
          "2723:             StartNewProfileSession();",
          "2724: #endif",
          "2726: #if ENABLE_NATIVE_CODEGEN",
          "2727:             NativeCodeGenerator *pNativeCodeGen = this->GetNativeCodeGenerator();",
          "2728:             AutoOptionalCriticalSection autoAcquireCodeGenQueue(GetNativeCodeGenCriticalSection(pNativeCodeGen));",
          "2729: #endif",
          "2731:             this->SetProfileMode(TRUE);",
          "2733: #if ENABLE_NATIVE_CODEGEN",
          "2734:             SetProfileModeNativeCodeGen(pNativeCodeGen, TRUE);",
          "2735: #endif",
          "2738:             if (m_fTraceNativeFunctionCall)",
          "2739:             {",
          "2740:                 hr = this->RegisterBuiltinFunctions(RegisterExternalLibrary);",
          "2741:                 if (FAILED(hr))",
          "2742:                 {",
          "2743:                     return hr;",
          "2744:                 }",
          "2745:             }",
          "2747:             this->RegisterAllScripts();",
          "2750:             this->SetDispatchProfile(TRUE, dispatchInvoke);",
          "2753:             this->SetFunctionInRecyclerToProfileMode();",
          "2754:         }",
          "2756:         return hr;",
          "2757:     }",
          "2759:     HRESULT ScriptContext::SetProfileEventMask(DWORD dwEventMask)",
          "2760:     {",
          "2761:         if (m_pProfileCallback == NULL)",
          "2762:         {",
          "2763:             return ACTIVPROF_E_PROFILER_ABSENT;",
          "2764:         }",
          "2766:         return ACTIVPROF_E_UNABLE_TO_APPLY_ACTION;",
          "2767:     }",
          "2769:     HRESULT ScriptContext::DeRegisterProfileProbe(HRESULT hrReason, JavascriptMethod dispatchInvoke)",
          "2770:     {",
          "2771:         if (m_pProfileCallback == NULL)",
          "2772:         {",
          "2773:             return ACTIVPROF_E_PROFILER_ABSENT;",
          "2774:         }",
          "2776:         OUTPUT_TRACE(Js::ScriptProfilerPhase, _u(\"ScriptContext::DeRegisterProfileProbe\\n\"));",
          "2778: #if ENABLE_NATIVE_CODEGEN",
          "2780:         NativeCodeGenerator *pNativeCodeGen = this->GetNativeCodeGenerator();",
          "2781:         Assert(pNativeCodeGen);",
          "2782:         {",
          "2783:             AutoOptionalCriticalSection lock(GetNativeCodeGenCriticalSection(pNativeCodeGen));",
          "2785:             this->SetProfileMode(FALSE);",
          "2786:             SetProfileModeNativeCodeGen(pNativeCodeGen, FALSE);",
          "2790:             if (dispatchInvoke != nullptr)",
          "2791:             {",
          "2792:                 this->SetDispatchProfile(FALSE, dispatchInvoke);",
          "2793:             }",
          "2794:         }",
          "2795: #endif",
          "2797:         m_inProfileCallback = TRUE;",
          "2798:         HRESULT hr = m_pProfileCallback->Shutdown(hrReason);",
          "2799:         m_inProfileCallback = FALSE;",
          "2800:         m_pProfileCallback->Release();",
          "2801:         m_pProfileCallback = NULL;",
          "2803:         if (m_pProfileCallback2 != NULL)",
          "2804:         {",
          "2805:             m_pProfileCallback2->Release();",
          "2806:             m_pProfileCallback2 = NULL;",
          "2807:         }",
          "2809: #if DEBUG",
          "2810:         StopProfileSession();",
          "2811: #endif",
          "2813:         return hr;",
          "2814:     }",
          "2816:     void ScriptContext::SetProfileMode(BOOL fSet)",
          "2817:     {",
          "2818: #ifdef ENABLE_SCRIPT_PROFILING",
          "2819:         if (fSet)",
          "2820:         {",
          "2821:             AssertMsg(m_pProfileCallback != NULL, \"In profile mode when there is no call back\");",
          "2822:             this->CurrentThunk = ProfileEntryThunk;",
          "2823:             this->CurrentCrossSiteThunk = CrossSite::ProfileThunk;",
          "2824:             this->DeferredParsingThunk = ProfileDeferredParsingThunk;",
          "2825:             this->DeferredDeserializationThunk = ProfileDeferredDeserializeThunk;",
          "2826:             this->globalObject->EvalHelper = &Js::GlobalObject::ProfileModeEvalHelper;",
          "2827: #if DBG",
          "2828:             this->hadProfiled = true;",
          "2829: #endif",
          "2830:         }",
          "2831:         else",
          "2832: #endif",
          "2833:         {",
          "2834:             Assert(!fSet);",
          "2835:             this->CurrentThunk = DefaultEntryThunk;",
          "2836:             this->CurrentCrossSiteThunk = CrossSite::DefaultThunk;",
          "2837:             this->DeferredParsingThunk = DefaultDeferredParsingThunk;",
          "2838:             this->globalObject->EvalHelper = &Js::GlobalObject::DefaultEvalHelper;",
          "2841:             if (!(this->IsScriptContextInDebugMode() && this->IsExceptionWrapperForBuiltInsEnabled()))",
          "2842:             {",
          "2843:                 this->javascriptLibrary->SetProfileMode(FALSE);",
          "2844:             }",
          "2845:         }",
          "2846:     }",
          "2848:     HRESULT ScriptContext::RegisterScript(Js::FunctionProxy * proxy, BOOL fRegisterScript /*default TRUE*/)",
          "2849:     {",
          "2850:         if (m_pProfileCallback == nullptr)",
          "2851:         {",
          "2852:             return ACTIVPROF_E_PROFILER_ABSENT;",
          "2853:         }",
          "2855:         OUTPUT_TRACE(Js::ScriptProfilerPhase, _u(\"ScriptContext::RegisterScript, fRegisterScript : %s, IsFunctionDefer : %s\\n\"), IsTrueOrFalse(fRegisterScript), IsTrueOrFalse(proxy->IsDeferred()));",
          "2857:         AssertMsg(proxy != nullptr, \"Function body cannot be null when calling reporting\");",
          "2858:         AssertMsg(proxy->GetScriptContext() == this, \"wrong script context while reporting the function?\");",
          "2860:         if (fRegisterScript)",
          "2861:         {",
          "2864:             HRESULT hr = proxy->EnsureDeserialized()->Parse()->ReportScriptCompiled();",
          "2865:             if (FAILED(hr))",
          "2866:             {",
          "2867:                 return hr;",
          "2868:             }",
          "2869:         }",
          "2871:         return !proxy->IsDeferred() ? proxy->GetFunctionBody()->RegisterFunction(false) : S_OK;",
          "2872:     }",
          "2874:     HRESULT ScriptContext::RegisterAllScripts()",
          "2875:     {",
          "2876:         AssertMsg(m_pProfileCallback != nullptr, \"Called register scripts when we don't have profile callback\");",
          "2878:         OUTPUT_TRACE(Js::ScriptProfilerPhase, _u(\"ScriptContext::RegisterAllScripts started\\n\"));",
          "2884:         this->MapScript([](Utf8SourceInfo* sourceInfo)",
          "2885:         {",
          "2886:             FunctionBody* functionBody = sourceInfo->GetAnyParsedFunction();",
          "2887:             if (functionBody)",
          "2888:             {",
          "2889:                 functionBody->ReportScriptCompiled();",
          "2890:             }",
          "2891:         });",
          "2894:         this->MapFunction([](Js::FunctionBody* pFuncBody)",
          "2895:         {",
          "2896:             if (!pFuncBody->GetIsTopLevel() && pFuncBody->GetIsGlobalFunc())",
          "2897:             {",
          "2899:                 return;",
          "2900:             }",
          "2902:             pFuncBody->RegisterFunction(TRUE, TRUE); // Ignore potential failure (worst case is not profiling).",
          "2903:         });",
          "2905:         OUTPUT_TRACE(Js::ScriptProfilerPhase, _u(\"ScriptContext::RegisterAllScripts ended\\n\"));",
          "2906:         return S_OK;",
          "2907:     }",
          "2908: #endif // ENABLE_SCRIPT_PROFILING",
          "2914: #if ENABLE_NATIVE_CODEGEN",
          "2915:     HRESULT ScriptContext::RecreateNativeCodeGenerator()",
          "2916:     {",
          "2917:         NativeCodeGenerator* oldCodeGen = this->nativeCodeGen;",
          "2919:         HRESULT hr = S_OK;",
          "2920:         BEGIN_TRANSLATE_OOM_TO_HRESULT_NESTED",
          "2921:             this->nativeCodeGen = NewNativeCodeGenerator(this);",
          "2922:         SetProfileModeNativeCodeGen(this->GetNativeCodeGenerator(), this->IsProfiling());",
          "2923:         END_TRANSLATE_OOM_TO_HRESULT(hr);",
          "2927:         CloseNativeCodeGenerator(oldCodeGen);",
          "2928:         DeleteNativeCodeGenerator(oldCodeGen);",
          "2930:         return hr;",
          "2931:     }",
          "2932: #endif",
          "2934:     HRESULT ScriptContext::OnDebuggerAttached()",
          "2935:     {",
          "2936:         OUTPUT_TRACE(Js::DebuggerPhase, _u(\"ScriptContext::OnDebuggerAttached: start 0x%p\\n\"), this);",
          "2938:         Js::StepController* stepController = &this->GetThreadContext()->GetDebugManager()->stepController;",
          "2939:         if (stepController->IsActive())",
          "2940:         {",
          "2941:             AssertMsg(stepController->GetActivatedContext() == nullptr, \"StepController should not be active when we attach.\");",
          "2942:             stepController->Deactivate(); // Defense in depth",
          "2943:         }",
          "2945:         bool shouldPerformSourceRundown = false;",
          "2946:         if (this->IsScriptContextInNonDebugMode())",
          "2947:         {",
          "2951:             this->GetDebugContext()->SetDebuggerMode(Js::DebuggerMode::SourceRundown);",
          "2954:             shouldPerformSourceRundown = true;",
          "2955:         }",
          "2959:         HRESULT hr = OnDebuggerAttachedDetached(/*attach*/ true);",
          "2962:         DEBUGGER_ATTACHDETACH_FATAL_ERROR_IF_FAILED(hr);",
          "2965:         AutoDisableInterrupt autoDisableInterrupt(this->threadContext->GetInterruptPoller(), true);",
          "2967:         hr = this->GetDebugContext()->RundownSourcesAndReparse(shouldPerformSourceRundown, /*shouldReparseFunctions*/ true);",
          "2969:         if (this->IsClosed())",
          "2970:         {",
          "2971:             return hr;",
          "2972:         }",
          "2975:         DEBUGGER_ATTACHDETACH_FATAL_ERROR_IF_FAILED(hr);",
          "2977:         HRESULT hrEntryPointUpdate = S_OK;",
          "2978:         BEGIN_TRANSLATE_OOM_TO_HRESULT_NESTED",
          "2979: #ifdef ASMJS_PLAT",
          "2980:             TempArenaAllocatorObject* tmpAlloc = GetTemporaryAllocator(_u(\"DebuggerTransition\"));",
          "2981:             debugTransitionAlloc = tmpAlloc->GetAllocator();",
          "2983:             asmJsEnvironmentMap = Anew(debugTransitionAlloc, AsmFunctionMap, debugTransitionAlloc);",
          "2984: #endif",
          "2987:             this->UpdateRecyclerFunctionEntryPointsForDebugger();",
          "2989: #ifdef ASMJS_PLAT",
          "2990:             auto asmEnvIter = asmJsEnvironmentMap->GetIterator();",
          "2991:             while (asmEnvIter.IsValid())",
          "2992:             {",
          "2994:                 SList<AsmJsScriptFunction *> * funcList = asmEnvIter.CurrentValue();",
          "2995:                 Assert(!funcList->Empty());",
          "2996:                 void* newEnv = AsmJsModuleInfo::ConvertFrameForJavascript(asmEnvIter.CurrentKey(), funcList->Head());",
          "2997:                 funcList->Iterate([&](AsmJsScriptFunction * func)",
          "2998:                 {",
          "2999:                     func->GetEnvironment()->SetItem(0, newEnv);",
          "3000:                 });",
          "3001:                 asmEnvIter.MoveNext();",
          "3002:             }",
          "3005:             auto asmCleanupIter = asmJsEnvironmentMap->GetIterator();",
          "3006:             while (asmCleanupIter.IsValid())",
          "3007:             {",
          "3008:                 SList<AsmJsScriptFunction *> * funcList = asmCleanupIter.CurrentValue();",
          "3009:                 Assert(!funcList->Empty());",
          "3010:                 funcList->Iterate([](AsmJsScriptFunction * func)",
          "3011:                 {",
          "3012:                     func->SetModuleMemory(nullptr);",
          "3013:                     func->GetFunctionBody()->ResetAsmJsInfo();",
          "3014:                 });",
          "3015:                 asmCleanupIter.MoveNext();",
          "3016:             }",
          "3018:             ReleaseTemporaryAllocator(tmpAlloc);",
          "3019: #endif",
          "3020:         END_TRANSLATE_OOM_TO_HRESULT(hrEntryPointUpdate);",
          "3022:         if (hrEntryPointUpdate != S_OK)",
          "3023:         {",
          "3025:             Assert(hrEntryPointUpdate == E_OUTOFMEMORY);",
          "3026:             return hrEntryPointUpdate;",
          "3027:         }",
          "3029:         OUTPUT_TRACE(Js::DebuggerPhase, _u(\"ScriptContext::OnDebuggerAttached: done 0x%p, hr = 0x%X\\n\"), this, hr);",
          "3031:         return hr;",
          "3032:     }",
          "3035:     HRESULT ScriptContext::OnDebuggerDetached()",
          "3036:     {",
          "3037:         OUTPUT_TRACE(Js::DebuggerPhase, _u(\"ScriptContext::OnDebuggerDetached: start 0x%p\\n\"), this);",
          "3039:         Js::StepController* stepController = &this->GetThreadContext()->GetDebugManager()->stepController;",
          "3040:         if (stepController->IsActive())",
          "3041:         {",
          "3045:             stepController->Deactivate();",
          "3046:         }",
          "3052:         HRESULT hr = OnDebuggerAttachedDetached(/*attach*/ false);",
          "3055:         DEBUGGER_ATTACHDETACH_FATAL_ERROR_IF_FAILED(hr);",
          "3058:         this->GetDebugContext()->SetDebuggerMode(Js::DebuggerMode::SourceRundown);",
          "3061:         AutoDisableInterrupt autoDisableInterrupt(this->threadContext->GetInterruptPoller(), true);",
          "3064:         hr = this->GetDebugContext()->RundownSourcesAndReparse(/*shouldPerformSourceRundown*/ false, /*shouldReparseFunctions*/ true);",
          "3066:         if (this->IsClosed())",
          "3067:         {",
          "3068:             return hr;",
          "3069:         }",
          "3072:         DEBUGGER_ATTACHDETACH_FATAL_ERROR_IF_FAILED(hr);",
          "3075:         this->UpdateRecyclerFunctionEntryPointsForDebugger();",
          "3077:         OUTPUT_TRACE(Js::DebuggerPhase, _u(\"ScriptContext::OnDebuggerDetached: done 0x%p, hr = 0x%X\\n\"), this, hr);",
          "3079:         return hr;",
          "3080:     }",
          "3082:     HRESULT ScriptContext::OnDebuggerAttachedDetached(bool attach)",
          "3083:     {",
          "3086:         struct AutoRestore",
          "3087:         {",
          "3088:             AutoRestore(ThreadContext* threadContext)",
          "3089:                 :threadContext(threadContext)",
          "3090:             {",
          "3091:                 this->threadContext->GetDebugManager()->SetDebuggerAttaching(true);",
          "3092:             }",
          "3093:             ~AutoRestore()",
          "3094:             {",
          "3095:                 this->threadContext->GetDebugManager()->SetDebuggerAttaching(false);",
          "3096:             }",
          "3098:         private:",
          "3099:             ThreadContext* threadContext;",
          "3101:         } autoRestore(this->GetThreadContext());",
          "3103:         if (!Js::Configuration::Global.EnableJitInDebugMode())",
          "3104:         {",
          "3105:             if (attach)",
          "3106:             {",
          "3108:                 ForceNoNative();",
          "3109:             }",
          "3110:             else",
          "3111:             {",
          "3114:                 this->ForceNative();",
          "3115:             }",
          "3116:         }",
          "3119:         this->threadContext->InvalidateAllProtoInlineCaches();",
          "3120:         this->threadContext->InvalidateAllStoreFieldInlineCaches();",
          "3121:         this->threadContext->InvalidateAllIsInstInlineCaches();",
          "3123:         if (!attach)",
          "3124:         {",
          "3125:             this->UnRegisterDebugThunk();",
          "3128:             this->GetDebugContext()->GetProbeContainer()->RemoveAllProbes();",
          "3129:         }",
          "3131:         HRESULT hr = S_OK;",
          "3133: #ifndef _WIN32",
          "3134:         BEGIN_TRANSLATE_OOM_TO_HRESULT_NESTED",
          "3135:         {",
          "3141:             this->sourceList->Map([=](uint i, RecyclerWeakReference<Js::Utf8SourceInfo>* sourceInfoWeakRef) {",
          "3142:                 Js::Utf8SourceInfo* sourceInfo = sourceInfoWeakRef->Get();",
          "3144:                 if (sourceInfo != nullptr)",
          "3145:                 {",
          "3146:                     sourceInfo->MapFunction([](Js::FunctionBody* functionBody) {",
          "3147:                         functionBody->ResetEntryPoint();",
          "3148:                     });",
          "3149:                 }",
          "3150:             });",
          "3151:         }",
          "3152:         END_TRANSLATE_OOM_TO_HRESULT(hr);",
          "3154:         if (FAILED(hr))",
          "3155:         {",
          "3156:             return hr;",
          "3157:         }",
          "3158: #endif",
          "3160:         if (!CONFIG_FLAG(ForceDiagnosticsMode))",
          "3161:         {",
          "3162: #if ENABLE_NATIVE_CODEGEN",
          "3165:             hr = RecreateNativeCodeGenerator();",
          "3166:             if (FAILED(hr))",
          "3167:             {",
          "3168:                 return hr;",
          "3169:             }",
          "3170: #endif",
          "3171:             if (attach)",
          "3172:             {",
          "3175:                 this->GetDebugContext()->SetDebuggerMode(Js::DebuggerMode::Debugging);",
          "3176: #if ENABLE_NATIVE_CODEGEN",
          "3177:                 UpdateNativeCodeGeneratorForDebugMode(this->nativeCodeGen);",
          "3178: #endif",
          "3179:             }",
          "3180:         }",
          "3181:         else if (attach)",
          "3182:         {",
          "3183:             this->GetDebugContext()->SetDebuggerMode(Js::DebuggerMode::Debugging);",
          "3184:         }",
          "3186:         BEGIN_TRANSLATE_OOM_TO_HRESULT_NESTED",
          "3187:         {",
          "3189:             this->sourceList->Map([=](uint i, RecyclerWeakReference<Js::Utf8SourceInfo>* sourceInfoWeakRef) {",
          "3190:                 Js::Utf8SourceInfo* sourceInfo = sourceInfoWeakRef->Get();",
          "3192:                 if (sourceInfo != nullptr)",
          "3193:                 {",
          "3194:                     if (!sourceInfo->GetIsLibraryCode())",
          "3195:                     {",
          "3196:                         sourceInfo->SetInDebugMode(attach);",
          "3198:                         sourceInfo->MapFunction([](Js::FunctionBody* functionBody) {",
          "3199:                             functionBody->SetEntryToDeferParseForDebugger();",
          "3200:                         });",
          "3201:                     }",
          "3202: #ifdef _WIN32",
          "3203:                     else",
          "3204:                     {",
          "3205:                         sourceInfo->MapFunction([](Js::FunctionBody* functionBody) {",
          "3206:                             functionBody->ResetEntryPoint();",
          "3207:                         });",
          "3208:                     }",
          "3209: #endif",
          "3210:                 }",
          "3211:             });",
          "3212:         }",
          "3213:         END_TRANSLATE_OOM_TO_HRESULT(hr);",
          "3215:         if (FAILED(hr))",
          "3216:         {",
          "3217:             return hr;",
          "3218:         }",
          "3220:         if (attach)",
          "3221:         {",
          "3222:             this->RegisterDebugThunk();",
          "3223:         }",
          "3225: #if ENABLE_PROFILE_INFO",
          "3226: #if DBG_DUMP || defined(DYNAMIC_PROFILE_STORAGE) || defined(RUNTIME_DATA_COLLECTION)",
          "3228:         if (this->Cache()->profileInfoList)",
          "3229:         {",
          "3230:             this->Cache()->profileInfoList->Reset();",
          "3231:         }",
          "3232: #endif",
          "3233: #endif",
          "3234:         return hr;",
          "3235:     }",
          "3237: #if defined(ENABLE_SCRIPT_DEBUGGING) || defined(ENABLE_SCRIPT_PROFILING)",
          "3239:     void ScriptContext::RegisterDebugThunk(bool calledDuringAttach /*= true*/)",
          "3240:     {",
          "3241:         if (this->IsExceptionWrapperForBuiltInsEnabled())",
          "3242:         {",
          "3243:             this->CurrentThunk = ProfileEntryThunk;",
          "3244:             this->CurrentCrossSiteThunk = CrossSite::ProfileThunk;",
          "3245: #if ENABLE_NATIVE_CODEGEN",
          "3246:             SetProfileModeNativeCodeGen(this->GetNativeCodeGenerator(), TRUE);",
          "3247: #endif",
          "3251:             this->javascriptLibrary->SetProfileMode(true);",
          "3252:             this->javascriptLibrary->SetDispatchProfile(true, DispatchProfileInvoke);",
          "3254: #ifdef ENABLE_SCRIPT_PROFILING",
          "3255:             if (!calledDuringAttach)",
          "3256:             {",
          "3257:                 m_fTraceDomCall = TRUE; // This flag is always needed in DebugMode to wrap external functions with DebugProfileThunk",
          "3259:                 this->SetFunctionInRecyclerToProfileMode(true/*enumerateNonUserFunctionsOnly*/);",
          "3260:             }",
          "3261: #endif",
          "3262:         }",
          "3263:     }",
          "3265:     void ScriptContext::UnRegisterDebugThunk()",
          "3266:     {",
          "3267:         if (!this->IsProfiling() && this->IsExceptionWrapperForBuiltInsEnabled())",
          "3268:         {",
          "3269:             this->CurrentThunk = DefaultEntryThunk;",
          "3270:             this->CurrentCrossSiteThunk = CrossSite::DefaultThunk;",
          "3271: #if ENABLE_NATIVE_CODEGEN",
          "3272:             SetProfileModeNativeCodeGen(this->GetNativeCodeGenerator(), FALSE);",
          "3273: #endif",
          "3275:             if (!this->IsProfiling())",
          "3276:             {",
          "3277:                 this->javascriptLibrary->SetProfileMode(false);",
          "3278:                 this->javascriptLibrary->SetDispatchProfile(false, DispatchDefaultInvoke);",
          "3279:             }",
          "3280:         }",
          "3281:     }",
          "3282: #endif // defined(ENABLE_SCRIPT_DEBUGGING) || defined(ENABLE_SCRIPT_PROFILING)",
          "3284: #ifdef ENABLE_SCRIPT_PROFILING",
          "3285:     HRESULT ScriptContext::RegisterBuiltinFunctions(RegisterExternalLibraryType RegisterExternalLibrary)",
          "3286:     {",
          "3287:         Assert(m_pProfileCallback != NULL);",
          "3289:         OUTPUT_TRACE(Js::ScriptProfilerPhase, _u(\"ScriptContext::RegisterBuiltinFunctions\\n\"));",
          "3291:         HRESULT hr = S_OK;",
          "3293:         if (m_pBuiltinFunctionIdMap == NULL)",
          "3294:         {",
          "3296:             m_pBuiltinFunctionIdMap = Anew(GeneralAllocator(), BuiltinFunctionIdDictionary,",
          "3297:                 GeneralAllocator(), 17);",
          "3298:         }",
          "3300:         this->javascriptLibrary->SetProfileMode(TRUE);",
          "3302:         if (FAILED(hr = OnScriptCompiled(BuiltInFunctionsScriptId, PROFILER_SCRIPT_TYPE_NATIVE, NULL)))",
          "3303:         {",
          "3304:             return hr;",
          "3305:         }",
          "3307:         if (FAILED(hr = this->javascriptLibrary->ProfilerRegisterBuiltIns()))",
          "3308:         {",
          "3309:             return hr;",
          "3310:         }",
          "3313:         if (RegisterExternalLibrary != NULL)",
          "3314:         {",
          "3315:             (*RegisterExternalLibrary)(this);",
          "3316:         }",
          "3318:         return hr;",
          "3319:     }",
          "3321:     void ScriptContext::SetFunctionInRecyclerToProfileMode(bool enumerateNonUserFunctionsOnly/* = false*/)",
          "3322:     {",
          "3323:         OUTPUT_TRACE(Js::ScriptProfilerPhase, _u(\"ScriptContext::SetFunctionInRecyclerToProfileMode started (m_fTraceDomCall : %s)\\n\"), IsTrueOrFalse(m_fTraceDomCall));",
          "3326:         AutoEnumeratingRecyclerObjects enumeratingRecyclerObjects(this);",
          "3328:         m_enumerateNonUserFunctionsOnly = enumerateNonUserFunctionsOnly;",
          "3330:         this->recycler->EnumerateObjects(JavascriptLibrary::EnumFunctionClass, &ScriptContext::RecyclerEnumClassEnumeratorCallback);",
          "3332:         OUTPUT_TRACE(Js::ScriptProfilerPhase, _u(\"ScriptContext::SetFunctionInRecyclerToProfileMode ended\\n\"));",
          "3333:     }",
          "3334: #endif // ENABLE_SCRIPT_PROFILING",
          "3336:     void ScriptContext::UpdateRecyclerFunctionEntryPointsForDebugger()",
          "3337:     {",
          "3339:         AutoEnumeratingRecyclerObjects enumeratingRecyclerObjects(this);",
          "3341:         this->recycler->EnumerateObjects(JavascriptLibrary::EnumFunctionClass, &ScriptContext::RecyclerFunctionCallbackForDebugger);",
          "3342:     }",
          "3344: #ifdef ASMJS_PLAT",
          "3345:     void ScriptContext::TransitionEnvironmentForDebugger(ScriptFunction * scriptFunction)",
          "3346:     {",
          "3347:         FunctionBody* functionBody = scriptFunction->GetFunctionBody();",
          "3348: #ifdef ENABLE_WASM",
          "3351:         if (functionBody->IsWasmFunction())",
          "3352:         {",
          "3354:             JavascriptMethod realThunk = CurrentThunk;",
          "3355:             CurrentThunk = AsmJsDefaultEntryThunk;",
          "3356:             functionBody->ResetEntryPoint();",
          "3357:             CurrentThunk = realThunk;",
          "3359:             bool isDeferred = functionBody->GetAsmJsFunctionInfo()->IsWasmDeferredParse();",
          "3361:             scriptFunction->ChangeEntryPoint(functionBody->GetDefaultEntryPointInfo(), AsmJsDefaultEntryThunk);",
          "3362:             WasmLibrary::SetWasmEntryPointToInterpreter(scriptFunction, isDeferred);",
          "3364:             functionBody->SetIsAsmJsFullJitScheduled(false);",
          "3365:             Assert(functionBody->HasValidEntryPoint());",
          "3366:         }",
          "3367:         else",
          "3368: #endif",
          "3369:         if (scriptFunction->GetScriptContext()->IsScriptContextInDebugMode())",
          "3370:         {",
          "3371:             if (functionBody->IsInDebugMode() &&",
          "3372:                 scriptFunction->GetFunctionBody()->GetAsmJsFunctionInfo() != nullptr &&",
          "3373:                 scriptFunction->GetFunctionBody()->GetAsmJsFunctionInfo()->GetModuleFunctionBody() != nullptr)",
          "3374:             {",
          "3375:                 void* env = scriptFunction->GetEnvironment()->GetItem(0);",
          "3376:                 SList<AsmJsScriptFunction*> * funcList = nullptr;",
          "3377:                 if (asmJsEnvironmentMap->TryGetValue(env, &funcList))",
          "3378:                 {",
          "3379:                     funcList->Push((AsmJsScriptFunction*)scriptFunction);",
          "3380:                 }",
          "3381:                 else",
          "3382:                 {",
          "3383:                     SList<AsmJsScriptFunction*> * newList = Anew(debugTransitionAlloc, SList<AsmJsScriptFunction*>, debugTransitionAlloc);",
          "3384:                     asmJsEnvironmentMap->AddNew(env, newList);",
          "3385:                     newList->Push((AsmJsScriptFunction*)scriptFunction);",
          "3386:                 }",
          "3387:             }",
          "3388:         }",
          "3389:     }",
          "3390: #endif",
          "3393:     void ScriptContext::RecyclerFunctionCallbackForDebugger(void *address, size_t size)",
          "3394:     {",
          "3395:         JavascriptFunction *pFunction = (JavascriptFunction *)address;",
          "3397:         ScriptContext* scriptContext = pFunction->GetScriptContext();",
          "3398:         if (scriptContext == nullptr || scriptContext->IsClosed())",
          "3399:         {",
          "3401:             return;",
          "3402:         }",
          "3404:         if (!scriptContext->IsEnumeratingRecyclerObjects())",
          "3405:         {",
          "3406:             return; // function not from enumerating script context",
          "3407:         }",
          "3410:         Assert(pFunction->GetFunctionInfo() != &JavascriptExternalFunction::EntryInfo::WrappedFunctionThunk);",
          "3412:         JavascriptMethod entryPoint = pFunction->GetEntryPoint();",
          "3413:         FunctionInfo * info = pFunction->GetFunctionInfo();",
          "3414:         FunctionProxy * proxy = info->GetFunctionProxy();",
          "3416:         if (proxy == nullptr)",
          "3417:         {",
          "3419:             if (!pFunction->IsScriptFunction() && IsExceptionWrapperForBuiltInsEnabled(scriptContext))",
          "3420:             {",
          "3421: #if defined(ENABLE_SCRIPT_DEBUGGING) || defined(ENABLE_SCRIPT_PROFILING)",
          "3422:                 if (scriptContext->IsScriptContextInDebugMode())",
          "3423:                 {",
          "3426:                     ScriptContext::SetEntryPointToProfileThunk(pFunction);",
          "3427:                 }",
          "3428:                 else",
          "3429:                 {",
          "3432:                     if (!scriptContext->IsProfiling())",
          "3433:                     {",
          "3434:                         ScriptContext::RestoreEntryPointFromProfileThunk(pFunction);",
          "3435:                     }",
          "3437:                 }",
          "3438: #else",
          "3439:                 AssertMsg(false, \"Debugging/Profiling needs to be enabled to change thunks\");",
          "3440: #endif",
          "3441:             }",
          "3443:             return;",
          "3444:         }",
          "3446:         Assert(proxy->GetFunctionInfo() == info);",
          "3448:         if (!proxy->IsFunctionBody())",
          "3449:         {",
          "3451:             return;",
          "3452:         }",
          "3453:         Assert(pFunction->IsScriptFunction());",
          "3456:         if (!proxy->GetUtf8SourceInfo()->GetIsLibraryCode())",
          "3457:         {",
          "3460:             pFunction->ResetConstructorCacheToDefault();",
          "3461:         }",
          "3463:         if (ScriptFunctionWithInlineCache::Is(pFunction))",
          "3464:         {",
          "3465:             ScriptFunctionWithInlineCache::FromVar(pFunction)->ClearInlineCacheOnFunctionObject();",
          "3466:         }",
          "3469:         FunctionBody * pBody = proxy->GetFunctionBody();",
          "3471: #ifdef ENABLE_DEBUG_CONFIG_OPTIONS",
          "3472:         if (scriptContext->IsScriptContextInDebugMode() &&",
          "3473:             !proxy->GetUtf8SourceInfo()->GetIsLibraryCode() &&",
          "3474: #ifdef ENABLE_WASM",
          "3475:             !pBody->IsWasmFunction() &&",
          "3476: #endif",
          "3477:             !pBody->IsInDebugMode())",
          "3478:         {",
          "3480:             Throw::FatalInternalError();",
          "3481:         }",
          "3482: #endif",
          "3484:         ScriptFunction * scriptFunction = ScriptFunction::FromVar(pFunction);",
          "3486: #ifdef ASMJS_PLAT",
          "3487:         scriptContext->TransitionEnvironmentForDebugger(scriptFunction);",
          "3488: #endif",
          "3490:         JavascriptMethod newEntryPoint;",
          "3491:         if (CrossSite::IsThunk(entryPoint))",
          "3492:         {",
          "3494:             newEntryPoint = entryPoint;",
          "3495:         }",
          "3496:         else",
          "3497:         {",
          "3498:             newEntryPoint = pBody->GetDirectEntryPoint(pBody->GetDefaultFunctionEntryPointInfo());",
          "3499:         }",
          "3501:         scriptFunction->ChangeEntryPoint(pBody->GetDefaultFunctionEntryPointInfo(), newEntryPoint);",
          "3502:     }",
          "3504: #if defined(ENABLE_SCRIPT_PROFILING) || defined(ENABLE_SCRIPT_DEBUGGING)",
          "3505:     void ScriptContext::RecyclerEnumClassEnumeratorCallback(void *address, size_t size)",
          "3506:     {",
          "3509:         JavascriptFunction *pFunction = (JavascriptFunction *)address;",
          "3511:         ScriptContext* scriptContext = pFunction->GetScriptContext();",
          "3512:         if (scriptContext == nullptr || scriptContext->IsClosed())",
          "3513:         {",
          "3515:             return;",
          "3516:         }",
          "3518:         if (!scriptContext->IsEnumeratingRecyclerObjects())",
          "3519:         {",
          "3520:             return; // function not from enumerating script context",
          "3521:         }",
          "3523:         if (!scriptContext->IsTraceDomCall() && (pFunction->IsExternalFunction() || pFunction->IsWinRTFunction()))",
          "3524:         {",
          "3525:             return;",
          "3526:         }",
          "3528:         if (scriptContext->IsEnumerateNonUserFunctionsOnly() && pFunction->IsScriptFunction())",
          "3529:         {",
          "3530:             return;",
          "3531:         }",
          "3534:         Assert(pFunction->GetFunctionInfo() != &JavascriptExternalFunction::EntryInfo::WrappedFunctionThunk);",
          "3536:         JavascriptMethod entryPoint = pFunction->GetEntryPoint();",
          "3537:         FunctionProxy *proxy = pFunction->GetFunctionProxy();",
          "3539:         if (proxy != NULL)",
          "3540:         {",
          "3541: #if ENABLE_DEBUG_CONFIG_OPTIONS",
          "3542:             char16 debugStringBuffer[MAX_FUNCTION_BODY_DEBUG_STRING_SIZE];",
          "3543: #endif",
          "3545: #if defined(ENABLE_SCRIPT_PROFILING)",
          "3546:             OUTPUT_TRACE(Js::ScriptProfilerPhase, _u(\"ScriptContext::RecyclerEnumClassEnumeratorCallback\\n\"));",
          "3547:             OUTPUT_TRACE(Js::ScriptProfilerPhase, _u(\"\\tFunctionProxy : 0x%08X, FunctionNumber : %s, DeferredParseAttributes : %d, EntryPoint : 0x%08X\"),",
          "3548:                 (DWORD_PTR)proxy, proxy->GetDebugNumberSet(debugStringBuffer), proxy->GetAttributes(), (DWORD_PTR)entryPoint);",
          "3549: #if ENABLE_NATIVE_CODEGEN",
          "3550:             OUTPUT_TRACE(Js::ScriptProfilerPhase, _u(\" (IsIntermediateCodeGenThunk : %s, isNative : %s)\\n\"),",
          "3551:                 IsTrueOrFalse(IsIntermediateCodeGenThunk(entryPoint)), IsTrueOrFalse(scriptContext->IsNativeAddress(entryPoint)));",
          "3552: #endif",
          "3553:             OUTPUT_TRACE(Js::ScriptProfilerPhase, _u(\"\\n\"));",
          "3554: #endif",
          "3556: #if ENABLE_NATIVE_CODEGEN",
          "3557:             if (!IsIntermediateCodeGenThunk(entryPoint) && entryPoint != DynamicProfileInfo::EnsureDynamicProfileInfoThunk)",
          "3558: #endif",
          "3559:             {",
          "3560:                 OUTPUT_TRACE(Js::ScriptProfilerPhase, _u(\"\\t\\tJs::ScriptContext::GetProfileModeThunk : 0x%08X\\n\"), (DWORD_PTR)Js::ScriptContext::GetProfileModeThunk(entryPoint));",
          "3562:                 ScriptFunction * scriptFunction = ScriptFunction::FromVar(pFunction);",
          "3563:                 scriptFunction->ChangeEntryPoint(proxy->GetDefaultEntryPointInfo(), Js::ScriptContext::GetProfileModeThunk(entryPoint));",
          "3565: #if ENABLE_NATIVE_CODEGEN && defined(ENABLE_SCRIPT_PROFILING)",
          "3566:                 OUTPUT_TRACE(Js::ScriptProfilerPhase, _u(\"\\tUpdated entrypoint : 0x%08X (isNative : %s)\\n\"), (DWORD_PTR)pFunction->GetEntryPoint(), IsTrueOrFalse(scriptContext->IsNativeAddress(entryPoint)));",
          "3567: #endif",
          "3568:             }",
          "3569:         }",
          "3570:         else",
          "3571:         {",
          "3572:             ScriptContext::SetEntryPointToProfileThunk(pFunction);",
          "3573:         }",
          "3574:     }",
          "3577:     void ScriptContext::SetEntryPointToProfileThunk(JavascriptFunction* function)",
          "3578:     {",
          "3579:         JavascriptMethod entryPoint = function->GetEntryPoint();",
          "3580:         if (entryPoint == Js::CrossSite::DefaultThunk)",
          "3581:         {",
          "3582:             function->SetEntryPoint(Js::CrossSite::ProfileThunk);",
          "3583:         }",
          "3584:         else if (entryPoint != Js::CrossSite::ProfileThunk && entryPoint != ProfileEntryThunk)",
          "3585:         {",
          "3586:             function->SetEntryPoint(ProfileEntryThunk);",
          "3587:         }",
          "3588:     }",
          "3591:     void ScriptContext::RestoreEntryPointFromProfileThunk(JavascriptFunction* function)",
          "3592:     {",
          "3593:         JavascriptMethod entryPoint = function->GetEntryPoint();",
          "3594:         if (entryPoint == Js::CrossSite::ProfileThunk)",
          "3595:         {",
          "3596:             function->SetEntryPoint(Js::CrossSite::DefaultThunk);",
          "3597:         }",
          "3598:         else if (entryPoint == ProfileEntryThunk)",
          "3599:         {",
          "3600:             function->SetEntryPoint(function->GetFunctionInfo()->GetOriginalEntryPoint());",
          "3601:         }",
          "3602:     }",
          "3604:     JavascriptMethod ScriptContext::GetProfileModeThunk(JavascriptMethod entryPoint)",
          "3605:     {",
          "3606:     #if ENABLE_NATIVE_CODEGEN",
          "3607:         Assert(!IsIntermediateCodeGenThunk(entryPoint));",
          "3608:     #endif",
          "3609:         if (entryPoint == DefaultDeferredParsingThunk || entryPoint == ProfileDeferredParsingThunk)",
          "3610:         {",
          "3611:             return ProfileDeferredParsingThunk;",
          "3612:         }",
          "3614:         if (entryPoint == DefaultDeferredDeserializeThunk || entryPoint == ProfileDeferredDeserializeThunk)",
          "3615:         {",
          "3616:             return ProfileDeferredDeserializeThunk;",
          "3617:         }",
          "3619:         if (CrossSite::IsThunk(entryPoint))",
          "3620:         {",
          "3621:             return CrossSite::ProfileThunk;",
          "3622:         }",
          "3623:         return ProfileEntryThunk;",
          "3624:     }",
          "3625: #endif // defined(ENABLE_SCRIPT_PROFILING) || defiend(ENABLE_SCRIPT_DEBUGGING)",
          "3627: #if _M_IX86",
          "3628:     __declspec(naked)",
          "3629:         Var ScriptContext::ProfileModeDeferredParsingThunk(RecyclableObject* function, CallInfo callInfo, ...)",
          "3630:     {",
          "3632:             __asm",
          "3633:             {",
          "3634:                 push ebp",
          "3635:                     mov ebp, esp",
          "3636:                     lea eax, [esp + 8]",
          "3637:                     push eax",
          "3638:                     call ScriptContext::ProfileModeDeferredParse",
          "3639: #ifdef _CONTROL_FLOW_GUARD",
          "3641:                     mov  ecx, eax",
          "3642:                     call[__guard_check_icall_fptr]",
          "3643:                     mov eax, ecx",
          "3644: #endif",
          "3645:                     pop ebp",
          "3647:                     jmp eax",
          "3648:             }",
          "3649:     }",
          "3650: #elif defined(_M_X64) || defined(_M_ARM32_OR_ARM64)",
          "3653: #else",
          "3654:     Var ScriptContext::ProfileModeDeferredParsingThunk(RecyclableObject* function, CallInfo callInfo, ...)",
          "3655:     {",
          "3656:         Js::Throw::NotImplemented();",
          "3657:         return nullptr;",
          "3658:     }",
          "3659: #endif",
          "3661:     Js::JavascriptMethod ScriptContext::ProfileModeDeferredParse(ScriptFunction ** functionRef)",
          "3662:     {",
          "3663: #if ENABLE_DEBUG_CONFIG_OPTIONS",
          "3664:         char16 debugStringBuffer[MAX_FUNCTION_BODY_DEBUG_STRING_SIZE];",
          "3665: #endif",
          "3667:         OUTPUT_TRACE(Js::ScriptProfilerPhase, _u(\"ScriptContext::ProfileModeDeferredParse FunctionNumber : %s, startEntrypoint : 0x%08X\\n\"), (*functionRef)->GetFunctionProxy()->GetDebugNumberSet(debugStringBuffer), (*functionRef)->GetEntryPoint());",
          "3669:         BOOL fParsed = FALSE;",
          "3670:         JavascriptMethod entryPoint = Js::JavascriptFunction::DeferredParseCore(functionRef, fParsed);",
          "3672: #ifdef ENABLE_SCRIPT_PROFILING",
          "3673:         OUTPUT_TRACE(Js::ScriptProfilerPhase, _u(\"\\t\\tIsParsed : %s, updatedEntrypoint : 0x%08X\\n\"), IsTrueOrFalse(fParsed), entryPoint);",
          "3676:         FunctionProxy *pRootBody = (*functionRef)->GetFunctionProxy();",
          "3677:         ScriptContext *pScriptContext = pRootBody->GetScriptContext();",
          "3678:         if (pScriptContext->IsProfiling() && !pRootBody->GetFunctionBody()->HasFunctionCompiledSent())",
          "3679:         {",
          "3680:             pScriptContext->RegisterScript(pRootBody, FALSE /*fRegisterScript*/);",
          "3681:         }",
          "3684:         Assert(!pScriptContext->IsProfiling() || (*functionRef)->GetFunctionBody()->GetProfileSession() == pScriptContext->GetProfileSession());",
          "3685: #endif",
          "3687:         return entryPoint;",
          "3688:     }",
          "3690: #if _M_IX86",
          "3691:     __declspec(naked)",
          "3692:         Var ScriptContext::ProfileModeDeferredDeserializeThunk(RecyclableObject* function, CallInfo callInfo, ...)",
          "3693:     {",
          "3695:             __asm",
          "3696:             {",
          "3697:                     push ebp",
          "3698:                     mov ebp, esp",
          "3699:                     push[esp + 8]",
          "3700:                     call ScriptContext::ProfileModeDeferredDeserialize",
          "3701: #ifdef _CONTROL_FLOW_GUARD",
          "3703:                     mov  ecx, eax",
          "3704:                     call[__guard_check_icall_fptr]",
          "3705:                     mov eax, ecx",
          "3706: #endif",
          "3707:                     pop ebp",
          "3709:                     jmp eax",
          "3710:             }",
          "3711:     }",
          "3712: #elif defined(_M_X64) || defined(_M_ARM32_OR_ARM64)",
          "3715: #endif",
          "3717:     Js::JavascriptMethod ScriptContext::ProfileModeDeferredDeserialize(ScriptFunction *function)",
          "3718:     {",
          "3719: #if ENABLE_DEBUG_CONFIG_OPTIONS",
          "3720:         char16 debugStringBuffer[MAX_FUNCTION_BODY_DEBUG_STRING_SIZE];",
          "3721: #endif",
          "3723:         OUTPUT_TRACE(Js::ScriptProfilerPhase, _u(\"ScriptContext::ProfileModeDeferredDeserialize FunctionNumber : %s\\n\"), function->GetFunctionProxy()->GetDebugNumberSet(debugStringBuffer));",
          "3725:         JavascriptMethod entryPoint = Js::JavascriptFunction::DeferredDeserialize(function);",
          "3727: #ifdef ENABLE_SCRIPT_PROFILING",
          "3729:         FunctionProxy *pRootBody = function->GetFunctionProxy();",
          "3730:         ScriptContext *pScriptContext = pRootBody->GetScriptContext();",
          "3731:         if (pScriptContext->IsProfiling() && !pRootBody->GetFunctionBody()->HasFunctionCompiledSent())",
          "3732:         {",
          "3733:             pScriptContext->RegisterScript(pRootBody, FALSE /*fRegisterScript*/);",
          "3734:         }",
          "3737:         Assert(!pScriptContext->IsProfiling() || function->GetFunctionBody()->GetProfileSession() == pScriptContext->GetProfileSession());",
          "3738: #endif",
          "3740:         return entryPoint;",
          "3741:     }",
          "3743: #ifdef ENABLE_SCRIPT_PROFILING",
          "3744:     BOOL ScriptContext::GetProfileInfo(",
          "3745:         JavascriptFunction* function,",
          "3746:         PROFILER_TOKEN &scriptId,",
          "3747:         PROFILER_TOKEN &functionId)",
          "3748:     {",
          "3749:         BOOL fCanProfile = (m_pProfileCallback != nullptr && m_fTraceFunctionCall);",
          "3750:         if (!fCanProfile)",
          "3751:         {",
          "3752:             return FALSE;",
          "3753:         }",
          "3755:         Js::FunctionInfo* functionInfo = function->GetFunctionInfo();",
          "3756:         if (functionInfo->GetAttributes() & FunctionInfo::DoNotProfile)",
          "3757:         {",
          "3758:             return FALSE;",
          "3759:         }",
          "3761:         Js::FunctionBody * functionBody = functionInfo->GetFunctionBody();",
          "3762:         if (functionBody == nullptr)",
          "3763:         {",
          "3764:             functionId = GetFunctionNumber(functionInfo->GetOriginalEntryPoint());",
          "3765:             if (functionId == -1)",
          "3766:             {",
          "3768:                 return m_fTraceDomCall && (m_pProfileCallback2 != nullptr);",
          "3769:             }",
          "3770:             else",
          "3771:             {",
          "3773:                 scriptId = BuiltInFunctionsScriptId;",
          "3774:                 return m_fTraceNativeFunctionCall;",
          "3775:             }",
          "3776:         }",
          "3777:         else if (!functionBody->GetUtf8SourceInfo()->GetIsLibraryCode() || functionBody->IsPublicLibraryCode()) // user script or public library code",
          "3778:         {",
          "3779:             scriptId = (PROFILER_TOKEN)functionBody->GetUtf8SourceInfo()->GetSourceInfoId();",
          "3780:             functionId = functionBody->GetFunctionNumber();",
          "3781:             return TRUE;",
          "3782:         }",
          "3784:         return FALSE;",
          "3785:     }",
          "3786: #endif // ENABLE_SCRIPT_PROFILING",
          "3788:     bool ScriptContext::IsForceNoNative()",
          "3789:     {",
          "3790:         bool forceNoNative = false;",
          "3791:         if (this->IsScriptContextInSourceRundownOrDebugMode())",
          "3792:         {",
          "3793:             forceNoNative = this->IsInterpreted();",
          "3794:         }",
          "3795:         else if (!Js::Configuration::Global.EnableJitInDebugMode())",
          "3796:         {",
          "3797:             forceNoNative = true;",
          "3798:             this->ForceNoNative();",
          "3799:         }",
          "3800:         return forceNoNative;",
          "3801:     }",
          "3803:     void ScriptContext::InitializeDebugging()",
          "3804:     {",
          "3805:         if (!this->IsScriptContextInDebugMode()) // If we already in debug mode, we would have done below changes already.",
          "3806:         {",
          "3807:             this->GetDebugContext()->SetDebuggerMode(Js::DebuggerMode::Debugging);",
          "3808:             if (this->IsScriptContextInDebugMode())",
          "3809:             {",
          "3813:                 this->RegisterDebugThunk(false/*calledDuringAttach*/);",
          "3818:             }",
          "3819:         }",
          "3820:     }",
          "3826:     Var ScriptContext::DebugProfileProbeThunk(RecyclableObject* callable, CallInfo callInfo, ...)",
          "3827:     {",
          "3828: #if defined(ENABLE_SCRIPT_DEBUGGING) || defined(ENABLE_SCRIPT_PROFILING)",
          "3829:         RUNTIME_ARGUMENTS(args, callInfo);",
          "3831:         Assert(!AsmJsScriptFunction::IsWasmScriptFunction(callable));",
          "3832:         JavascriptFunction* function = JavascriptFunction::FromVar(callable);",
          "3833:         ScriptContext* scriptContext = function->GetScriptContext();",
          "3834:         bool functionEnterEventSent = false;",
          "3835:         char16 *pwszExtractedFunctionName = NULL;",
          "3836:         size_t functionNameLen = 0;",
          "3837:         const char16 *pwszFunctionName = NULL;",
          "3838:         HRESULT hrOfEnterEvent = S_OK;",
          "3843: #if defined(ENABLE_SCRIPT_PROFILING)",
          "3844:         PROFILER_TOKEN scriptId = -1;",
          "3845:         PROFILER_TOKEN functionId = -1;",
          "3846:         const bool isProfilingUserCode = scriptContext->GetThreadContext()->IsProfilingUserCode();",
          "3847:         const bool isUserCode = !function->IsLibraryCode();",
          "3849:         const bool fProfile = (isUserCode || isProfilingUserCode) // Only report user code or entry library code",
          "3850:             && scriptContext->GetProfileInfo(function, scriptId, functionId);",
          "3852:         if (fProfile)",
          "3853:         {",
          "3854:             Js::FunctionBody *pBody = function->GetFunctionBody();",
          "3855:             if (pBody != nullptr && !pBody->HasFunctionCompiledSent())",
          "3856:             {",
          "3857:                 pBody->RegisterFunction(false/*changeThunk*/);",
          "3858:             }",
          "3860: #if DEBUG",
          "3861:             { // scope",
          "3863:                 Assert(scriptContext->IsProfiling());",
          "3865:                 if (pBody && pBody->GetProfileSession() != pBody->GetScriptContext()->GetProfileSession())",
          "3866:                 {",
          "3867:                     char16 debugStringBuffer[MAX_FUNCTION_BODY_DEBUG_STRING_SIZE];",
          "3868:                     OUTPUT_TRACE_DEBUGONLY(Js::ScriptProfilerPhase, _u(\"ScriptContext::ProfileProbeThunk, ProfileSession does not match (%d != %d), functionNumber : %s, functionName : %s\\n\"),",
          "3869:                         pBody->GetProfileSession(), pBody->GetScriptContext()->GetProfileSession(), pBody->GetDebugNumberSet(debugStringBuffer), pBody->GetDisplayName());",
          "3870:                 }",
          "3871:                 AssertMsg(pBody == NULL || pBody->GetProfileSession() == pBody->GetScriptContext()->GetProfileSession(), \"Function info wasn't reported for this profile session\");",
          "3872:             }",
          "3873: #endif // DEBUG",
          "3875:             if (functionId == -1)",
          "3876:             {",
          "3877:                 Var sourceString = function->GetSourceString();",
          "3880:                 if (sourceString != NULL)",
          "3881:                 {",
          "3882:                     if (TaggedInt::Is(sourceString))",
          "3883:                     {",
          "3884:                         PropertyId nameId = TaggedInt::ToInt32(sourceString);",
          "3885:                         pwszFunctionName = scriptContext->GetPropertyString(nameId)->GetSz();",
          "3886:                     }",
          "3887:                     else",
          "3888:                     {",
          "3890:                         Assert(JavascriptString::Is(sourceString));",
          "3891:                         const char16 *pwszToString = ((JavascriptString *)sourceString)->GetSz();",
          "3892:                         const char16 *pwszNameStart = wcsstr(pwszToString, _u(\" \"));",
          "3893:                         const char16 *pwszNameEnd = wcsstr(pwszToString, _u(\"(\"));",
          "3894:                         if (pwszNameStart == nullptr || pwszNameEnd == nullptr || ((int)(pwszNameEnd - pwszNameStart) <= 0))",
          "3895:                         {",
          "3896:                             functionNameLen = ((JavascriptString *)sourceString)->GetLength() + 1;",
          "3897:                             pwszExtractedFunctionName = HeapNewArray(char16, functionNameLen);",
          "3898:                             wcsncpy_s(pwszExtractedFunctionName, functionNameLen, pwszToString, _TRUNCATE);",
          "3899:                         }",
          "3900:                         else",
          "3901:                         {",
          "3902:                             functionNameLen = pwszNameEnd - pwszNameStart;",
          "3903:                             AssertMsg(functionNameLen < INT_MAX, \"Allocating array with zero or negative length?\");",
          "3904:                             pwszExtractedFunctionName = HeapNewArray(char16, functionNameLen);",
          "3905:                             wcsncpy_s(pwszExtractedFunctionName, functionNameLen, pwszNameStart + 1, _TRUNCATE);",
          "3906:                         }",
          "3907:                         pwszFunctionName = pwszExtractedFunctionName;",
          "3908:                     }",
          "3910:                     functionEnterEventSent = true;",
          "3911:                     Assert(pwszFunctionName != NULL);",
          "3912:                     hrOfEnterEvent = scriptContext->OnDispatchFunctionEnter(pwszFunctionName);",
          "3913:                 }",
          "3914:             }",
          "3915:             else",
          "3916:             {",
          "3917:                 hrOfEnterEvent = scriptContext->OnFunctionEnter(scriptId, functionId);",
          "3918:             }",
          "3920:             scriptContext->GetThreadContext()->SetIsProfilingUserCode(isUserCode); // Update IsProfilingUserCode state",
          "3921:         }",
          "3922: #endif // ENABLE_SCRIPT_PROFILING",
          "3924:         Var aReturn = NULL;",
          "3925:         JavascriptMethod origEntryPoint = function->GetFunctionInfo()->GetOriginalEntryPoint();",
          "3927:         if (scriptContext->IsEvalRestriction())",
          "3928:         {",
          "3929:             if (origEntryPoint == Js::GlobalObject::EntryEval)",
          "3930:             {",
          "3931:                 origEntryPoint = Js::GlobalObject::EntryEvalRestrictedMode;",
          "3932:             }",
          "3933:             else if (origEntryPoint == Js::JavascriptFunction::NewInstance)",
          "3934:             {",
          "3935:                 origEntryPoint = Js::JavascriptFunction::NewInstanceRestrictedMode;",
          "3936:             }",
          "3937:             else if (origEntryPoint == Js::JavascriptGeneratorFunction::NewInstance)",
          "3938:             {",
          "3939:                 origEntryPoint = Js::JavascriptGeneratorFunction::NewInstanceRestrictedMode;",
          "3940:             }",
          "3941:             else if (origEntryPoint == Js::JavascriptFunction::NewAsyncFunctionInstance)",
          "3942:             {",
          "3943:                 origEntryPoint = Js::JavascriptFunction::NewAsyncFunctionInstanceRestrictedMode;",
          "3944:             }",
          "3945:         }",
          "3948:         __TRY_FINALLY_BEGIN // SEH is not guaranteed, see the implementation",
          "3949:         {",
          "3950:             Assert(!function->IsScriptFunction() || function->GetFunctionProxy());",
          "3955:             bool isDebugWrapperEnabled = scriptContext->IsScriptContextInDebugMode() && IsExceptionWrapperForBuiltInsEnabled(scriptContext);",
          "3956:             bool useDebugWrapper =",
          "3957:                 isDebugWrapperEnabled &&",
          "3958:                 function->IsLibraryCode() &&",
          "3959:                 !AutoRegisterIgnoreExceptionWrapper::IsRegistered(scriptContext->GetThreadContext());",
          "3961:             OUTPUT_VERBOSE_TRACE(Js::DebuggerPhase, _u(\"DebugProfileProbeThunk: calling function: %s isWrapperRegistered=%d useDebugWrapper=%d\\n\"),",
          "3962:                 function->GetFunctionInfo()->HasBody() ? function->GetFunctionBody()->GetDisplayName() : _u(\"built-in/library\"), AutoRegisterIgnoreExceptionWrapper::IsRegistered(scriptContext->GetThreadContext()), useDebugWrapper);",
          "3964:             if (scriptContext->IsScriptContextInDebugMode())",
          "3965:             {",
          "3966:                 scriptContext->GetDebugContext()->GetProbeContainer()->StartRecordingCall();",
          "3967:             }",
          "3969:             if (useDebugWrapper)",
          "3970:             {",
          "3973:                 aReturn = ProfileModeThunk_DebugModeWrapper(function, scriptContext, origEntryPoint, args);",
          "3974:             }",
          "3975:             else",
          "3976:             {",
          "3977:                 if (isDebugWrapperEnabled && !function->IsLibraryCode())",
          "3978:                 {",
          "3983:                     ThreadContext* threadContext = scriptContext->GetThreadContext();",
          "3984:                     bool isOrigWrapperPresent = threadContext->GetDebugManager()->GetDebuggingFlags()->IsBuiltInWrapperPresent();",
          "3985:                     if (isOrigWrapperPresent)",
          "3986:                     {",
          "3987:                         threadContext->GetDebugManager()->GetDebuggingFlags()->SetIsBuiltInWrapperPresent(false);",
          "3988:                     }",
          "3989:                     __TRY_FINALLY_BEGIN // SEH is not guaranteed, see the implementation",
          "3990:                     {",
          "3991:                         aReturn = JavascriptFunction::CallFunction<true>(function, origEntryPoint, args);",
          "3992:                     }",
          "3993:                     __FINALLY",
          "3994:                     {",
          "3995:                         threadContext->GetDebugManager()->GetDebuggingFlags()->SetIsBuiltInWrapperPresent(isOrigWrapperPresent);",
          "3996:                     }",
          "3997:                     __TRY_FINALLY_END",
          "3998:                 }",
          "3999:                 else",
          "4000:                 {",
          "4004:                     aReturn = JavascriptFunction::CallFunction<true>(function, origEntryPoint, args);",
          "4005:                 }",
          "4006:             }",
          "4007:         }",
          "4008:         __FINALLY",
          "4009:         {",
          "4010: #if defined(ENABLE_SCRIPT_PROFILING)",
          "4011:             if (fProfile)",
          "4012:             {",
          "4013:                 if (hrOfEnterEvent != ACTIVPROF_E_PROFILER_ABSENT)",
          "4014:                 {",
          "4015:                     if (functionId == -1)",
          "4016:                     {",
          "4018:                         if (functionEnterEventSent)",
          "4019:                         {",
          "4020:                             scriptContext->OnDispatchFunctionExit(pwszFunctionName);",
          "4021:                             if (pwszExtractedFunctionName != NULL)",
          "4022:                             {",
          "4023:                                 HeapDeleteArray(functionNameLen, pwszExtractedFunctionName);",
          "4024:                             }",
          "4025:                         }",
          "4026:                     }",
          "4027:                     else",
          "4028:                     {",
          "4029:                         scriptContext->OnFunctionExit(scriptId, functionId);",
          "4030:                     }",
          "4031:                 }",
          "4033:                 scriptContext->GetThreadContext()->SetIsProfilingUserCode(isProfilingUserCode); // Restore IsProfilingUserCode state",
          "4034:             }",
          "4035: #endif",
          "4037:             if (scriptContext->IsScriptContextInDebugMode())",
          "4038:             {",
          "4039:                 scriptContext->GetDebugContext()->GetProbeContainer()->EndRecordingCall(aReturn, function);",
          "4040:             }",
          "4041:         }",
          "4042:         __TRY_FINALLY_END",
          "4044:         return aReturn;",
          "4045: #else",
          "4046:         return nullptr;",
          "4047: #endif // defined(ENABLE_SCRIPT_DEBUGGING) || defined(ENABLE_SCRIPT_PROFILING)",
          "4048:     }",
          "4050: #if defined(ENABLE_SCRIPT_DEBUGGING) || defined(ENABLE_SCRIPT_PROFILING)",
          "4052:     Var ScriptContext::ProfileModeThunk_DebugModeWrapper(JavascriptFunction* function, ScriptContext* scriptContext, JavascriptMethod entryPoint, Arguments& args)",
          "4053:     {",
          "4054:         AutoRegisterIgnoreExceptionWrapper autoWrapper(scriptContext->GetThreadContext());",
          "4056:         Var aReturn = HelperOrLibraryMethodWrapper<true>(scriptContext, [=] {",
          "4057:             return JavascriptFunction::CallFunction<true>(function, entryPoint, args);",
          "4058:         });",
          "4060:         return aReturn;",
          "4061:     }",
          "4062: #endif",
          "4064: #ifdef ENABLE_SCRIPT_PROFILING",
          "4065:     HRESULT ScriptContext::OnScriptCompiled(PROFILER_TOKEN scriptId, PROFILER_SCRIPT_TYPE type, IUnknown *pIDebugDocumentContext)",
          "4066:     {",
          "4068:         Assert(m_pProfileCallback != NULL);",
          "4070:         OUTPUT_TRACE(Js::ScriptProfilerPhase, _u(\"ScriptContext::OnScriptCompiled scriptId : %d, ScriptType : %d\\n\"), scriptId, type);",
          "4072:         HRESULT hr = S_OK;",
          "4074:         if ((type == PROFILER_SCRIPT_TYPE_NATIVE && m_fTraceNativeFunctionCall) ||",
          "4075:             (type != PROFILER_SCRIPT_TYPE_NATIVE && m_fTraceFunctionCall))",
          "4076:         {",
          "4077:             m_inProfileCallback = TRUE;",
          "4078:             hr = m_pProfileCallback->ScriptCompiled(scriptId, type, pIDebugDocumentContext);",
          "4079:             m_inProfileCallback = FALSE;",
          "4080:         }",
          "4081:         return hr;",
          "4082:     }",
          "4084:     HRESULT ScriptContext::OnFunctionCompiled(",
          "4085:         PROFILER_TOKEN functionId,",
          "4086:         PROFILER_TOKEN scriptId,",
          "4087:         const WCHAR *pwszFunctionName,",
          "4088:         const WCHAR *pwszFunctionNameHint,",
          "4089:         IUnknown *pIDebugDocumentContext)",
          "4090:     {",
          "4091:         Assert(m_pProfileCallback != NULL);",
          "4093: #ifdef ENABLE_DEBUG_CONFIG_OPTIONS",
          "4094:         if (scriptId != BuiltInFunctionsScriptId || Js::Configuration::Global.flags.Verbose)",
          "4095:         {",
          "4096:             OUTPUT_TRACE(Js::ScriptProfilerPhase, _u(\"ScriptContext::OnFunctionCompiled scriptId : %d, functionId : %d, FunctionName : %s, FunctionNameHint : %s\\n\"), scriptId, functionId, pwszFunctionName, pwszFunctionNameHint);",
          "4097:         }",
          "4098: #endif",
          "4100:         HRESULT hr = S_OK;",
          "4102:         if ((scriptId == BuiltInFunctionsScriptId && m_fTraceNativeFunctionCall) ||",
          "4103:             (scriptId != BuiltInFunctionsScriptId && m_fTraceFunctionCall))",
          "4104:         {",
          "4105:             m_inProfileCallback = TRUE;",
          "4106:             hr = m_pProfileCallback->FunctionCompiled(functionId, scriptId, pwszFunctionName, pwszFunctionNameHint, pIDebugDocumentContext);",
          "4107:             m_inProfileCallback = FALSE;",
          "4108:         }",
          "4109:         return hr;",
          "4110:     }",
          "4112:     HRESULT ScriptContext::OnFunctionEnter(PROFILER_TOKEN scriptId, PROFILER_TOKEN functionId)",
          "4113:     {",
          "4114:         if (m_pProfileCallback == NULL)",
          "4115:         {",
          "4116:             return ACTIVPROF_E_PROFILER_ABSENT;",
          "4117:         }",
          "4119:         OUTPUT_VERBOSE_TRACE(Js::ScriptProfilerPhase, _u(\"ScriptContext::OnFunctionEnter scriptId : %d, functionId : %d\\n\"), scriptId, functionId);",
          "4121:         HRESULT hr = S_OK;",
          "4123:         if ((scriptId == BuiltInFunctionsScriptId && m_fTraceNativeFunctionCall) ||",
          "4124:             (scriptId != BuiltInFunctionsScriptId && m_fTraceFunctionCall))",
          "4125:         {",
          "4126:             m_inProfileCallback = TRUE;",
          "4127:             hr = m_pProfileCallback->OnFunctionEnter(scriptId, functionId);",
          "4128:             m_inProfileCallback = FALSE;",
          "4129:         }",
          "4130:         return hr;",
          "4131:     }",
          "4133:     HRESULT ScriptContext::OnFunctionExit(PROFILER_TOKEN scriptId, PROFILER_TOKEN functionId)",
          "4134:     {",
          "4135:         if (m_pProfileCallback == NULL)",
          "4136:         {",
          "4137:             return ACTIVPROF_E_PROFILER_ABSENT;",
          "4138:         }",
          "4140:         OUTPUT_VERBOSE_TRACE(Js::ScriptProfilerPhase, _u(\"ScriptContext::OnFunctionExit scriptId : %d, functionId : %d\\n\"), scriptId, functionId);",
          "4142:         HRESULT hr = S_OK;",
          "4144:         if ((scriptId == BuiltInFunctionsScriptId && m_fTraceNativeFunctionCall) ||",
          "4145:             (scriptId != BuiltInFunctionsScriptId && m_fTraceFunctionCall))",
          "4146:         {",
          "4147:             m_inProfileCallback = TRUE;",
          "4148:             hr = m_pProfileCallback->OnFunctionExit(scriptId, functionId);",
          "4149:             m_inProfileCallback = FALSE;",
          "4150:         }",
          "4151:         return hr;",
          "4152:     }",
          "4154:     HRESULT ScriptContext::FunctionExitSenderThunk(PROFILER_TOKEN functionId, PROFILER_TOKEN scriptId, ScriptContext *pScriptContext)",
          "4155:     {",
          "4156:         return pScriptContext->OnFunctionExit(scriptId, functionId);",
          "4157:     }",
          "4159:     HRESULT ScriptContext::FunctionExitByNameSenderThunk(const char16 *pwszFunctionName, ScriptContext *pScriptContext)",
          "4160:     {",
          "4161:         return pScriptContext->OnDispatchFunctionExit(pwszFunctionName);",
          "4162:     }",
          "4163: #endif // ENABLE_SCRIPT_PROFILING",
          "4165:     Js::PropertyId ScriptContext::GetFunctionNumber(JavascriptMethod entryPoint)",
          "4166:     {",
          "4167:         return (m_pBuiltinFunctionIdMap == NULL) ? -1 : m_pBuiltinFunctionIdMap->Lookup(entryPoint, -1);",
          "4168:     }",
          "4170:     HRESULT ScriptContext::RegisterLibraryFunction(const char16 *pwszObjectName, const char16 *pwszFunctionName, Js::PropertyId functionPropertyId, JavascriptMethod entryPoint)",
          "4171:     {",
          "4172: #if defined(ENABLE_SCRIPT_PROFILING)",
          "4173: #if DEBUG",
          "4174:         const char16 *pwszObjectNameFromProperty = const_cast<char16 *>(GetPropertyName(functionPropertyId)->GetBuffer());",
          "4175:         if (GetPropertyName(functionPropertyId)->IsSymbol())",
          "4176:         {",
          "4179:             Assert(!wcsncmp(pwszFunctionName + 1, pwszObjectNameFromProperty, wcslen(pwszObjectNameFromProperty)));",
          "4180:             Assert(wcslen(pwszFunctionName) == wcslen(pwszObjectNameFromProperty) + 2);",
          "4181:         }",
          "4182:         else",
          "4183:         {",
          "4184:             Assert(!wcscmp(pwszFunctionName, pwszObjectNameFromProperty));",
          "4185:         }",
          "4186:         Assert(m_pBuiltinFunctionIdMap != NULL);",
          "4187: #endif",
          "4192:         char16 szTempName[70];",
          "4193:         if (pwszObjectName != NULL)",
          "4194:         {",
          "4196:             swprintf_s(szTempName, 70, _u(\"%s.%s\"), pwszObjectName, pwszFunctionName);",
          "4197:             functionPropertyId = GetOrAddPropertyIdTracked(szTempName, (uint)wcslen(szTempName));",
          "4198:         }",
          "4200:         Js::PropertyId cachedFunctionId;",
          "4201:         bool keyFound = m_pBuiltinFunctionIdMap->TryGetValue(entryPoint, &cachedFunctionId);",
          "4203:         if (keyFound)",
          "4204:         {",
          "4206:             if (cachedFunctionId != functionPropertyId)",
          "4207:             {",
          "4211:                 return S_OK;",
          "4212:             }",
          "4215:         }",
          "4216:         else",
          "4217:         {",
          "4218: #if DBG",
          "4219:             m_pBuiltinFunctionIdMap->MapUntil([&](JavascriptMethod, Js::PropertyId propertyId) -> bool",
          "4220:             {",
          "4221:                 if (functionPropertyId == propertyId)",
          "4222:                 {",
          "4223:                     Assert(false);",
          "4224:                     return true;",
          "4225:                 }",
          "4226:                 return false;",
          "4227:             });",
          "4228: #endif",
          "4231:             m_pBuiltinFunctionIdMap->Add(entryPoint, functionPropertyId);",
          "4232:         }",
          "4235:         if (pwszObjectName != NULL)",
          "4236:         {",
          "4237:             return OnFunctionCompiled(functionPropertyId, BuiltInFunctionsScriptId, szTempName, NULL, NULL);",
          "4238:         }",
          "4239:         else",
          "4240:         {",
          "4241:             return OnFunctionCompiled(functionPropertyId, BuiltInFunctionsScriptId, pwszFunctionName, NULL, NULL);",
          "4242:         }",
          "4243: #else",
          "4244:         return S_OK;",
          "4245: #endif // ENABLE_SCRIPT_PROFILING",
          "4246:     }",
          "4248:     void ScriptContext::BindReference(void * addr)",
          "4249:     {",
          "4250:         Assert(!this->isClosed);",
          "4251:         Assert(this->guestArena);",
          "4252:         Assert(recycler->IsValidObject(addr));",
          "4253: #if DBG",
          "4254:         Assert(!bindRef.ContainsKey(addr));     // Make sure we don't bind the same pointer twice",
          "4255:         bindRef.AddNew(addr);",
          "4256: #endif",
          "4257:         javascriptLibrary->BindReference(addr);",
          "4259: #ifdef RECYCLER_PERF_COUNTERS",
          "4260:         this->bindReferenceCount++;",
          "4261:         RECYCLER_PERF_COUNTER_INC(BindReference);",
          "4262: #endif",
          "4263:     }",
          "4265: #ifdef PROFILE_STRINGS",
          "4266:     StringProfiler* ScriptContext::GetStringProfiler()",
          "4267:     {",
          "4268:         return stringProfiler;",
          "4269:     }",
          "4270: #endif",
          "4272:     void ScriptContext::FreeFunctionEntryPoint(Js::JavascriptMethod method)",
          "4273:     {",
          "4274: #if ENABLE_NATIVE_CODEGEN",
          "4275:         FreeNativeCodeGenAllocation(this, method);",
          "4276: #endif",
          "4277:     }",
          "4279:     void ScriptContext::RegisterProtoInlineCache(InlineCache *pCache, PropertyId propId)",
          "4280:     {",
          "4281:         hasProtoOrStoreFieldInlineCache = true;",
          "4282:         threadContext->RegisterProtoInlineCache(pCache, propId);",
          "4283:     }",
          "4285:     void ScriptContext::InvalidateProtoCaches(const PropertyId propertyId)",
          "4286:     {",
          "4287:         threadContext->InvalidateProtoInlineCaches(propertyId);",
          "4290:         threadContext->InvalidateStoreFieldInlineCaches(propertyId);",
          "4291: #if ENABLE_NATIVE_CODEGEN",
          "4292:         threadContext->InvalidatePropertyGuards(propertyId);",
          "4293: #endif",
          "4294:         threadContext->InvalidateProtoTypePropertyCaches(propertyId);",
          "4295:     }",
          "4297:     void ScriptContext::InvalidateAllProtoCaches()",
          "4298:     {",
          "4299:         threadContext->InvalidateAllProtoInlineCaches();",
          "4302:         threadContext->InvalidateAllStoreFieldInlineCaches();",
          "4303: #if ENABLE_NATIVE_CODEGEN",
          "4304:         threadContext->InvalidateAllPropertyGuards();",
          "4305: #endif",
          "4306:         threadContext->InvalidateAllProtoTypePropertyCaches();",
          "4307:     }",
          "4309:     void ScriptContext::RegisterStoreFieldInlineCache(InlineCache *pCache, PropertyId propId)",
          "4310:     {",
          "4311:         hasProtoOrStoreFieldInlineCache = true;",
          "4312:         threadContext->RegisterStoreFieldInlineCache(pCache, propId);",
          "4313:     }",
          "4315:     void ScriptContext::InvalidateStoreFieldCaches(const PropertyId propertyId)",
          "4316:     {",
          "4317:         threadContext->InvalidateStoreFieldInlineCaches(propertyId);",
          "4318: #if ENABLE_NATIVE_CODEGEN",
          "4319:         threadContext->InvalidatePropertyGuards(propertyId);",
          "4320: #endif",
          "4321:     }",
          "4323:     void ScriptContext::InvalidateAllStoreFieldCaches()",
          "4324:     {",
          "4325:         threadContext->InvalidateAllStoreFieldInlineCaches();",
          "4326:     }",
          "4328:     void ScriptContext::RegisterIsInstInlineCache(Js::IsInstInlineCache * cache, Js::Var function)",
          "4329:     {",
          "4330:         Assert(JavascriptFunction::FromVar(function)->GetScriptContext() == this);",
          "4331:         hasIsInstInlineCache = true;",
          "4332:         threadContext->RegisterIsInstInlineCache(cache, function);",
          "4333:     }",
          "4335: #if DBG",
          "4336:     bool ScriptContext::IsIsInstInlineCacheRegistered(Js::IsInstInlineCache * cache, Js::Var function)",
          "4337:     {",
          "4338:         return threadContext->IsIsInstInlineCacheRegistered(cache, function);",
          "4339:     }",
          "4340: #endif",
          "4342:     void ScriptContext::CleanSourceListInternal(bool calledDuringMark)",
          "4343:     {",
          "4344:         bool fCleanupDocRequired = false;",
          "4345:         for (int i = 0; i < sourceList->Count(); i++)",
          "4346:         {",
          "4347:             if (this->sourceList->IsItemValid(i))",
          "4348:             {",
          "4349:                 RecyclerWeakReference<Utf8SourceInfo>* sourceInfoWeakRef = this->sourceList->Item(i);",
          "4350:                 Utf8SourceInfo* strongRef = nullptr;",
          "4352:                 if (calledDuringMark)",
          "4353:                 {",
          "4354:                     strongRef = sourceInfoWeakRef->FastGet();",
          "4355:                 }",
          "4356:                 else",
          "4357:                 {",
          "4358:                     strongRef = sourceInfoWeakRef->Get();",
          "4359:                 }",
          "4361:                 if (strongRef == nullptr)",
          "4362:                 {",
          "4363:                     this->sourceList->RemoveAt(i);",
          "4364:                     fCleanupDocRequired = true;",
          "4365:                 }",
          "4366:             }",
          "4367:         }",
          "4369: #ifdef ENABLE_SCRIPT_PROFILING",
          "4371:         if (fCleanupDocRequired && m_pProfileCallback != NULL)",
          "4372:         {",
          "4373:             Assert(CleanupDocumentContext != NULL);",
          "4374:             CleanupDocumentContext(this);",
          "4375:         }",
          "4376: #endif // ENABLE_SCRIPT_PROFILING",
          "4377:     }",
          "4379:     void ScriptContext::ClearScriptContextCaches()",
          "4380:     {",
          "4383:         if (this->isPerformingNonreentrantWork || !this->hasUsedInlineCache)",
          "4384:         {",
          "4385:             return;",
          "4386:         }",
          "4388:         class AutoCleanup",
          "4389:         {",
          "4390:         private:",
          "4391:             ScriptContext *const scriptContext;",
          "4393:         public:",
          "4394:             AutoCleanup(ScriptContext *const scriptContext) : scriptContext(scriptContext)",
          "4395:             {",
          "4396:                 scriptContext->isPerformingNonreentrantWork = true;",
          "4397:             }",
          "4399:             ~AutoCleanup()",
          "4400:             {",
          "4401:                 scriptContext->isPerformingNonreentrantWork = false;",
          "4402:             }",
          "4403:         } autoCleanup(this);",
          "4405:         if (this->isScriptContextActuallyClosed)",
          "4406:         {",
          "4407:             return;",
          "4408:         }",
          "4409:         Assert(this->guestArena);",
          "4411:         if (EnableEvalMapCleanup())",
          "4412:         {",
          "4415:             if (!this->IsScriptContextInDebugMode())",
          "4416:             {",
          "4417:                 if (this->Cache()->evalCacheDictionary != nullptr)",
          "4418:                 {",
          "4419:                     this->CleanDynamicFunctionCache<Js::EvalCacheTopLevelDictionary>(this->Cache()->evalCacheDictionary->GetDictionary());",
          "4420:                 }",
          "4421:                 if (this->Cache()->indirectEvalCacheDictionary != nullptr)",
          "4422:                 {",
          "4423:                     this->CleanDynamicFunctionCache<Js::EvalCacheTopLevelDictionary>(this->Cache()->indirectEvalCacheDictionary->GetDictionary());",
          "4424:                 }",
          "4425:                 if (this->Cache()->newFunctionCache != nullptr)",
          "4426:                 {",
          "4427:                     this->CleanDynamicFunctionCache<Js::NewFunctionCache>(this->Cache()->newFunctionCache);",
          "4428:                 }",
          "4429:                 if (this->hostScriptContext != nullptr)",
          "4430:                 {",
          "4431:                     this->hostScriptContext->CleanDynamicCodeCache();",
          "4432:                 }",
          "4434:             }",
          "4435:         }",
          "4437:         if (REGEX_CONFIG_FLAG(DynamicRegexMruListSize) > 0)",
          "4438:         {",
          "4439:             GetDynamicRegexMap()->RemoveRecentlyUnusedItems();",
          "4440:         }",
          "4442:         CleanSourceListInternal(true);",
          "4443:     }",
          "4445: void ScriptContext::ClearInlineCaches()",
          "4446: {",
          "4447:     if (this->hasUsedInlineCache)",
          "4448:     {",
          "4449:         GetInlineCacheAllocator()->ZeroAll();",
          "4450:         this->hasUsedInlineCache = false;",
          "4451:         this->hasProtoOrStoreFieldInlineCache = false;",
          "4452:     }",
          "4454:     Assert(GetInlineCacheAllocator()->IsAllZero());",
          "4455: }",
          "4457: void ScriptContext::ClearIsInstInlineCaches()",
          "4458: {",
          "4459:     if (this->hasIsInstInlineCache)",
          "4460:     {",
          "4461:         GetIsInstInlineCacheAllocator()->ZeroAll();",
          "4462:         this->hasIsInstInlineCache = false;",
          "4463:     }",
          "4465:     Assert(GetIsInstInlineCacheAllocator()->IsAllZero());",
          "4466: }",
          "4468: void ScriptContext::ClearForInCaches()",
          "4469: {",
          "4470:     ForInCacheAllocator()->ZeroAll();",
          "4471:     Assert(ForInCacheAllocator()->IsAllZero());",
          "4472: }",
          "4475: #ifdef PERSISTENT_INLINE_CACHES",
          "4476: void ScriptContext::ClearInlineCachesWithDeadWeakRefs()",
          "4477: {",
          "4478:     if (this->hasUsedInlineCache)",
          "4479:     {",
          "4480:         GetInlineCacheAllocator()->ClearCachesWithDeadWeakRefs(this->recycler);",
          "4481:         Assert(GetInlineCacheAllocator()->HasNoDeadWeakRefs(this->recycler));",
          "4482:     }",
          "4483: }",
          "4484: #endif",
          "4486: #if ENABLE_NATIVE_CODEGEN",
          "4487: void ScriptContext::RegisterConstructorCache(Js::PropertyId propertyId, Js::ConstructorCache* cache)",
          "4488: {",
          "4489:     this->threadContext->RegisterConstructorCache(propertyId, cache);",
          "4490: }",
          "4491: #endif",
          "4493: JITPageAddrToFuncRangeCache *",
          "4494: ScriptContext::GetJitFuncRangeCache()",
          "4495: {",
          "4496:     return jitFuncRangeCache;",
          "4497: }",
          "4499: void ScriptContext::RegisterPrototypeChainEnsuredToHaveOnlyWritableDataPropertiesScriptContext()",
          "4500: {",
          "4501:     Assert(!IsClosed());",
          "4503:     if (registeredPrototypeChainEnsuredToHaveOnlyWritableDataPropertiesScriptContext == nullptr)",
          "4504:     {",
          "4505:         DoRegisterPrototypeChainEnsuredToHaveOnlyWritableDataPropertiesScriptContext();",
          "4506:     }",
          "4507: }",
          "4509:     void ScriptContext::DoRegisterPrototypeChainEnsuredToHaveOnlyWritableDataPropertiesScriptContext()",
          "4510:     {",
          "4511:         Assert(!IsClosed());",
          "4512:         Assert(registeredPrototypeChainEnsuredToHaveOnlyWritableDataPropertiesScriptContext == nullptr);",
          "4515:         registeredPrototypeChainEnsuredToHaveOnlyWritableDataPropertiesScriptContext = threadContext->RegisterPrototypeChainEnsuredToHaveOnlyWritableDataPropertiesScriptContext(this);",
          "4516:     }",
          "4518:     void ScriptContext::ClearPrototypeChainEnsuredToHaveOnlyWritableDataPropertiesCaches()",
          "4519:     {",
          "4520:         Assert(registeredPrototypeChainEnsuredToHaveOnlyWritableDataPropertiesScriptContext != nullptr);",
          "4521:         if (!isFinalized)",
          "4522:         {",
          "4523:             javascriptLibrary->NoPrototypeChainsAreEnsuredToHaveOnlyWritableDataProperties();",
          "4524:         }",
          "4527:         registeredPrototypeChainEnsuredToHaveOnlyWritableDataPropertiesScriptContext = nullptr;",
          "4528:     }",
          "4530:     JavascriptString * ScriptContext::GetLastNumberToStringRadix10(double value)",
          "4531:     {",
          "4532:         if (value == lastNumberToStringRadix10)",
          "4533:         {",
          "4534:             return Cache()->lastNumberToStringRadix10String;",
          "4535:         }",
          "4536:         return nullptr;",
          "4537:     }",
          "4539:     void",
          "4540:         ScriptContext::SetLastNumberToStringRadix10(double value, JavascriptString * str)",
          "4541:     {",
          "4542:             lastNumberToStringRadix10 = value;",
          "4543:             Cache()->lastNumberToStringRadix10String = str;",
          "4544:     }",
          "4546:     bool ScriptContext::GetLastUtcTimeFromStr(JavascriptString * str, double& dbl)",
          "4547:     {",
          "4548:         Assert(str != nullptr);",
          "4549:         if (str != Cache()->lastUtcTimeFromStrString)",
          "4550:         {",
          "4551:             if (Cache()->lastUtcTimeFromStrString == nullptr",
          "4552:                 || !JavascriptString::Equals(str, Cache()->lastUtcTimeFromStrString))",
          "4553:             {",
          "4554:                 return false;",
          "4555:             }",
          "4556:         }",
          "4557:         dbl = lastUtcTimeFromStr;",
          "4558:         return true;",
          "4559:     }",
          "4561:     void",
          "4562:     ScriptContext::SetLastUtcTimeFromStr(JavascriptString * str, double value)",
          "4563:     {",
          "4564:             lastUtcTimeFromStr = value;",
          "4565:             Cache()->lastUtcTimeFromStrString = str;",
          "4566:     }",
          "4568: #if ENABLE_NATIVE_CODEGEN",
          "4569:     BOOL ScriptContext::IsNativeAddress(void * codeAddr)",
          "4570:     {",
          "4571:         return this->GetThreadContext()->IsNativeAddress(codeAddr, this);",
          "4572:     }",
          "4573: #endif",
          "4575:     bool ScriptContext::SetDispatchProfile(bool fSet, JavascriptMethod dispatchInvoke)",
          "4576:     {",
          "4577:         if (!fSet)",
          "4578:         {",
          "4579:             this->javascriptLibrary->SetDispatchProfile(false, dispatchInvoke);",
          "4580:             return true;",
          "4581:         }",
          "4582: #ifdef ENABLE_SCRIPT_PROFILING",
          "4583:         else if (m_fTraceDomCall)",
          "4584:         {",
          "4585:             this->javascriptLibrary->SetDispatchProfile(true, dispatchInvoke);",
          "4586:             return true;",
          "4587:         }",
          "4588: #endif // ENABLE_SCRIPT_PROFILING",
          "4590:         return false;",
          "4591:     }",
          "4593: #ifdef ENABLE_SCRIPT_PROFILING",
          "4594:     HRESULT ScriptContext::OnDispatchFunctionEnter(const WCHAR *pwszFunctionName)",
          "4595:     {",
          "4596:         if (m_pProfileCallback2 == NULL)",
          "4597:         {",
          "4598:             return ACTIVPROF_E_PROFILER_ABSENT;",
          "4599:         }",
          "4601:         HRESULT hr = S_OK;",
          "4603:         if (m_fTraceDomCall)",
          "4604:         {",
          "4605:             m_inProfileCallback = TRUE;",
          "4606:             hr = m_pProfileCallback2->OnFunctionEnterByName(pwszFunctionName, PROFILER_SCRIPT_TYPE_DOM);",
          "4607:             m_inProfileCallback = FALSE;",
          "4608:         }",
          "4609:         return hr;",
          "4610:     }",
          "4612:     HRESULT ScriptContext::OnDispatchFunctionExit(const WCHAR *pwszFunctionName)",
          "4613:     {",
          "4614:         if (m_pProfileCallback2 == NULL)",
          "4615:         {",
          "4616:             return ACTIVPROF_E_PROFILER_ABSENT;",
          "4617:         }",
          "4619:         HRESULT hr = S_OK;",
          "4621:         if (m_fTraceDomCall)",
          "4622:         {",
          "4623:             m_inProfileCallback = TRUE;",
          "4624:             hr = m_pProfileCallback2->OnFunctionExitByName(pwszFunctionName, PROFILER_SCRIPT_TYPE_DOM);",
          "4625:             m_inProfileCallback = FALSE;",
          "4626:         }",
          "4627:         return hr;",
          "4628:     }",
          "4629: #endif // ENABLE_SCRIPT_PROFILING",
          "4631:     void ScriptContext::SetBuiltInLibraryFunction(JavascriptMethod entryPoint, JavascriptFunction* function)",
          "4632:     {",
          "4633:         if (!isClosed)",
          "4634:         {",
          "4635:             if (builtInLibraryFunctions == NULL)",
          "4636:             {",
          "4637:                 Assert(this->recycler);",
          "4639:                 builtInLibraryFunctions = RecyclerNew(this->recycler, BuiltInLibraryFunctionMap, this->recycler);",
          "4640:                 Cache()->builtInLibraryFunctions = builtInLibraryFunctions;",
          "4641:             }",
          "4643:             builtInLibraryFunctions->Item(entryPoint, function);",
          "4644:         }",
          "4645:     }",
          "4647: #if ENABLE_NATIVE_CODEGEN",
          "4648:     void ScriptContext::InitializeRemoteScriptContext()",
          "4649:     {",
          "4650:         Assert(JITManager::GetJITManager()->IsOOPJITEnabled());",
          "4652:         if (!JITManager::GetJITManager()->IsConnected())",
          "4653:         {",
          "4654:             return;",
          "4655:         }",
          "4656:         ScriptContextDataIDL contextData;",
          "4657:         contextData.nullAddr = (intptr_t)GetLibrary()->GetNull();",
          "4658:         contextData.undefinedAddr = (intptr_t)GetLibrary()->GetUndefined();",
          "4659:         contextData.trueAddr = (intptr_t)GetLibrary()->GetTrue();",
          "4660:         contextData.falseAddr = (intptr_t)GetLibrary()->GetFalse();",
          "4661:         contextData.undeclBlockVarAddr = (intptr_t)GetLibrary()->GetUndeclBlockVar();",
          "4662:         contextData.scriptContextAddr = (intptr_t)this;",
          "4663:         contextData.emptyStringAddr = (intptr_t)GetLibrary()->GetEmptyString();",
          "4664:         contextData.negativeZeroAddr = (intptr_t)GetLibrary()->GetNegativeZero();",
          "4665:         contextData.numberTypeStaticAddr = (intptr_t)GetLibrary()->GetNumberTypeStatic();",
          "4666:         contextData.stringTypeStaticAddr = (intptr_t)GetLibrary()->GetStringTypeStatic();",
          "4667:         contextData.objectTypeAddr = (intptr_t)GetLibrary()->GetObjectType();",
          "4668:         contextData.objectHeaderInlinedTypeAddr = (intptr_t)GetLibrary()->GetObjectHeaderInlinedType();",
          "4669:         contextData.regexTypeAddr = (intptr_t)GetLibrary()->GetRegexType();",
          "4670:         contextData.arrayConstructorAddr = (intptr_t)GetLibrary()->GetArrayConstructor();",
          "4671:         contextData.arrayTypeAddr = (intptr_t)GetLibrary()->GetArrayType();",
          "4672:         contextData.nativeIntArrayTypeAddr = (intptr_t)GetLibrary()->GetNativeIntArrayType();",
          "4673:         contextData.nativeFloatArrayTypeAddr = (intptr_t)GetLibrary()->GetNativeFloatArrayType();",
          "4674:         contextData.charStringCacheAddr = (intptr_t)&GetLibrary()->GetCharStringCache();",
          "4675:         contextData.libraryAddr = (intptr_t)GetLibrary();",
          "4676:         contextData.globalObjectAddr = (intptr_t)GetLibrary()->GetGlobalObject();",
          "4677:         contextData.builtinFunctionsBaseAddr = (intptr_t)GetLibrary()->GetBuiltinFunctions();",
          "4678:         contextData.sideEffectsAddr = optimizationOverrides.GetAddressOfSideEffects();",
          "4679:         contextData.arraySetElementFastPathVtableAddr = (intptr_t)optimizationOverrides.GetAddressOfArraySetElementFastPathVtable();",
          "4680:         contextData.intArraySetElementFastPathVtableAddr = (intptr_t)optimizationOverrides.GetAddressOfIntArraySetElementFastPathVtable();",
          "4681:         contextData.floatArraySetElementFastPathVtableAddr = (intptr_t)optimizationOverrides.GetAddressOfFloatArraySetElementFastPathVtable();",
          "4682:         contextData.recyclerAddr = (intptr_t)GetRecycler();",
          "4683:         contextData.recyclerAllowNativeCodeBumpAllocation = GetRecycler()->AllowNativeCodeBumpAllocation();",
          "4684:         contextData.numberAllocatorAddr = (intptr_t)GetNumberAllocator();",
          "4685: #ifdef RECYCLER_MEMORY_VERIFY",
          "4686:         contextData.isRecyclerVerifyEnabled = (boolean)recycler->VerifyEnabled();",
          "4687:         contextData.recyclerVerifyPad = recycler->GetVerifyPad();",
          "4688: #else",
          "4690:         contextData.isRecyclerVerifyEnabled = FALSE;",
          "4691:         contextData.recyclerVerifyPad = 0;",
          "4692: #endif",
          "4693:         contextData.debuggingFlagsAddr = GetDebuggingFlagsAddr();",
          "4694:         contextData.debugStepTypeAddr = GetDebugStepTypeAddr();",
          "4695:         contextData.debugFrameAddressAddr = GetDebugFrameAddressAddr();",
          "4696:         contextData.debugScriptIdWhenSetAddr = GetDebugScriptIdWhenSetAddr();",
          "4698:         contextData.numberAllocatorAddr = (intptr_t)GetNumberAllocator();",
          "4699:         contextData.isSIMDEnabled = GetConfig()->IsSimdjsEnabled();",
          "4700:         CompileAssert(VTableValue::Count == VTABLE_COUNT); // need to update idl when this changes",
          "4702:         auto vtblAddresses = GetLibrary()->GetVTableAddresses();",
          "4703:         for (unsigned int i = 0; i < VTableValue::Count; i++)",
          "4704:         {",
          "4705:             contextData.vtableAddresses[i] = vtblAddresses[i];",
          "4706:         }",
          "4708:         bool allowPrereserveAlloc = true;",
          "4709: #if !_M_X64_OR_ARM64",
          "4710:         if (this->webWorkerId != Js::Constants::NonWebWorkerContextId)",
          "4711:         {",
          "4712:             allowPrereserveAlloc = false;",
          "4713:         }",
          "4714: #endif",
          "4715: #ifndef _CONTROL_FLOW_GUARD",
          "4716:         allowPrereserveAlloc = false;",
          "4717: #endif",
          "4719:         if (this->GetThreadContext()->EnsureJITThreadContext(allowPrereserveAlloc))",
          "4720:         {",
          "4721:             HRESULT hr = JITManager::GetJITManager()->InitializeScriptContext(&contextData, this->GetThreadContext()->GetRemoteThreadContextAddr(), &m_remoteScriptContextAddr);",
          "4722:             JITManager::HandleServerCallResult(hr, RemoteCallType::StateUpdate);",
          "4723:         }",
          "4724:     }",
          "4725: #endif",
          "4727:     intptr_t ScriptContext::GetNullAddr() const",
          "4728:     {",
          "4729:         return (intptr_t)GetLibrary()->GetNull();",
          "4730:     }",
          "4732:     intptr_t ScriptContext::GetUndefinedAddr() const",
          "4733:     {",
          "4734:         return (intptr_t)GetLibrary()->GetUndefined();",
          "4735:     }",
          "4737:     intptr_t ScriptContext::GetTrueAddr() const",
          "4738:     {",
          "4739:         return (intptr_t)GetLibrary()->GetTrue();",
          "4740:     }",
          "4742:     intptr_t ScriptContext::GetFalseAddr() const",
          "4743:     {",
          "4744:         return (intptr_t)GetLibrary()->GetFalse();",
          "4745:     }",
          "4747:     intptr_t ScriptContext::GetUndeclBlockVarAddr() const",
          "4748:     {",
          "4749:         return (intptr_t)GetLibrary()->GetUndeclBlockVar();",
          "4750:     }",
          "4752:     intptr_t ScriptContext::GetEmptyStringAddr() const",
          "4753:     {",
          "4754:         return (intptr_t)GetLibrary()->GetEmptyString();",
          "4755:     }",
          "4757:     intptr_t ScriptContext::GetNegativeZeroAddr() const",
          "4758:     {",
          "4759:         return (intptr_t)GetLibrary()->GetNegativeZero();",
          "4760:     }",
          "4762:     intptr_t ScriptContext::GetNumberTypeStaticAddr() const",
          "4763:     {",
          "4764:         return (intptr_t)GetLibrary()->GetNumberTypeStatic();",
          "4765:     }",
          "4767:     intptr_t ScriptContext::GetStringTypeStaticAddr() const",
          "4768:     {",
          "4769:         return (intptr_t)GetLibrary()->GetStringTypeStatic();",
          "4770:     }",
          "4772:     intptr_t ScriptContext::GetObjectTypeAddr() const",
          "4773:     {",
          "4774:         return (intptr_t)GetLibrary()->GetObjectType();",
          "4775:     }",
          "4777:     intptr_t ScriptContext::GetObjectHeaderInlinedTypeAddr() const",
          "4778:     {",
          "4779:         return (intptr_t)GetLibrary()->GetObjectHeaderInlinedType();",
          "4780:     }",
          "4782:     intptr_t ScriptContext::GetRegexTypeAddr() const",
          "4783:     {",
          "4784:         return (intptr_t)GetLibrary()->GetRegexType();",
          "4785:     }",
          "4787:     intptr_t ScriptContext::GetArrayTypeAddr() const",
          "4788:     {",
          "4789:         return (intptr_t)GetLibrary()->GetArrayType();",
          "4790:     }",
          "4792:     intptr_t ScriptContext::GetNativeIntArrayTypeAddr() const",
          "4793:     {",
          "4794:         return (intptr_t)GetLibrary()->GetNativeIntArrayType();",
          "4795:     }",
          "4797:     intptr_t ScriptContext::GetNativeFloatArrayTypeAddr() const",
          "4798:     {",
          "4799:         return (intptr_t)GetLibrary()->GetNativeFloatArrayType();",
          "4800:     }",
          "4802:     intptr_t ScriptContext::GetArrayConstructorAddr() const",
          "4803:     {",
          "4804:         return (intptr_t)GetLibrary()->GetArrayConstructor();",
          "4805:     }",
          "4807:     intptr_t ScriptContext::GetCharStringCacheAddr() const",
          "4808:     {",
          "4809:         return (intptr_t)&GetLibrary()->GetCharStringCache();",
          "4810:     }",
          "4812:     intptr_t ScriptContext::GetSideEffectsAddr() const",
          "4813:     {",
          "4814:         return optimizationOverrides.GetAddressOfSideEffects();",
          "4815:     }",
          "4817:     intptr_t ScriptContext::GetArraySetElementFastPathVtableAddr() const",
          "4818:     {",
          "4819:         return optimizationOverrides.GetArraySetElementFastPathVtableAddr();",
          "4820:     }",
          "4822:     intptr_t ScriptContext::GetIntArraySetElementFastPathVtableAddr() const",
          "4823:     {",
          "4824:         return optimizationOverrides.GetIntArraySetElementFastPathVtableAddr();",
          "4825:     }",
          "4827:     intptr_t ScriptContext::GetFloatArraySetElementFastPathVtableAddr() const",
          "4828:     {",
          "4829:         return optimizationOverrides.GetFloatArraySetElementFastPathVtableAddr();",
          "4830:     }",
          "4832:     intptr_t ScriptContext::GetBuiltinFunctionsBaseAddr() const",
          "4833:     {",
          "4834:         return (intptr_t)GetLibrary()->GetBuiltinFunctions();",
          "4835:     }",
          "4837:     intptr_t ScriptContext::GetLibraryAddr() const",
          "4838:     {",
          "4839:         return (intptr_t)GetLibrary();",
          "4840:     }",
          "4842:     intptr_t ScriptContext::GetGlobalObjectAddr() const",
          "4843:     {",
          "4844:         return (intptr_t)GetLibrary()->GetGlobalObject();",
          "4845:     }",
          "4847:     intptr_t ScriptContext::GetGlobalObjectThisAddr() const",
          "4848:     {",
          "4849:         return (intptr_t)GetLibrary()->GetGlobalObject()->ToThis();",
          "4850:     }",
          "4852:     intptr_t ScriptContext::GetNumberAllocatorAddr() const",
          "4853:     {",
          "4854:         return (intptr_t)&numberAllocator;",
          "4855:     }",
          "4857:     intptr_t ScriptContext::GetRecyclerAddr() const",
          "4858:     {",
          "4859:         return (intptr_t)GetRecycler();",
          "4860:     }",
          "4862:     intptr_t ScriptContext::GetDebuggingFlagsAddr() const",
          "4863:     {",
          "4864:         return this->threadContext->GetDebugManager()->GetDebuggingFlagsAddr();",
          "4865:     }",
          "4867:     intptr_t ScriptContext::GetDebugStepTypeAddr() const",
          "4868:     {",
          "4869:         return (intptr_t)this->threadContext->GetDebugManager()->stepController.GetAddressOfStepType();",
          "4870:     }",
          "4872:     intptr_t ScriptContext::GetDebugFrameAddressAddr() const",
          "4873:     {",
          "4874:         return (intptr_t)this->threadContext->GetDebugManager()->stepController.GetAddressOfFrameAddress();",
          "4875:     }",
          "4877:     intptr_t ScriptContext::GetDebugScriptIdWhenSetAddr() const",
          "4878:     {",
          "4879:         return (intptr_t)this->threadContext->GetDebugManager()->stepController.GetAddressOfScriptIdWhenSet();",
          "4880:     }",
          "4882:     bool ScriptContext::GetRecyclerAllowNativeCodeBumpAllocation() const",
          "4883:     {",
          "4884:         return GetRecycler()->AllowNativeCodeBumpAllocation();",
          "4885:     }",
          "4887:     bool ScriptContext::IsSIMDEnabled() const",
          "4888:     {",
          "4889:         return GetConfig()->IsSimdjsEnabled();",
          "4890:     }",
          "4892:     bool ScriptContext::IsPRNGSeeded() const",
          "4893:     {",
          "4894:         return GetLibrary()->IsPRNGSeeded();",
          "4895:     }",
          "4897:     intptr_t ScriptContext::GetAddr() const",
          "4898:     {",
          "4899:         return (intptr_t)this;",
          "4900:     }",
          "4902: #if ENABLE_NATIVE_CODEGEN",
          "4903:     void ScriptContext::AddToDOMFastPathHelperMap(intptr_t funcInfoAddr, IR::JnHelperMethod helper)",
          "4904:     {",
          "4905:         m_domFastPathHelperMap->Add(funcInfoAddr, helper);",
          "4906:     }",
          "4908:     IR::JnHelperMethod ScriptContext::GetDOMFastPathHelper(intptr_t funcInfoAddr)",
          "4909:     {",
          "4910:         IR::JnHelperMethod helper;",
          "4912:         m_domFastPathHelperMap->LockResize();",
          "4913:         bool found = m_domFastPathHelperMap->TryGetValue(funcInfoAddr, &helper);",
          "4914:         m_domFastPathHelperMap->UnlockResize();",
          "4916:         Assert(found);",
          "4917:         return helper;",
          "4918:     }",
          "4919: #endif",
          "4921:     intptr_t ScriptContext::GetVTableAddress(VTableValue vtableType) const",
          "4922:     {",
          "4923:         Assert(vtableType < VTableValue::Count);",
          "4924:         return GetLibrary()->GetVTableAddresses()[vtableType];",
          "4925:     }",
          "4927:     bool ScriptContext::IsRecyclerVerifyEnabled() const",
          "4928:     {",
          "4929: #ifdef RECYCLER_MEMORY_VERIFY",
          "4930:         return recycler->VerifyEnabled() != FALSE;",
          "4931: #else",
          "4932:         return false;",
          "4933: #endif",
          "4934:     }",
          "4936:     uint ScriptContext::GetRecyclerVerifyPad() const",
          "4937:     {",
          "4938: #ifdef RECYCLER_MEMORY_VERIFY",
          "4939:         return recycler->GetVerifyPad();",
          "4940: #else",
          "4941:         return 0;",
          "4942: #endif",
          "4943:     }",
          "4945:     JavascriptFunction* ScriptContext::GetBuiltInLibraryFunction(JavascriptMethod entryPoint)",
          "4946:     {",
          "4947:         JavascriptFunction * function = NULL;",
          "4948:         if (builtInLibraryFunctions)",
          "4949:         {",
          "4950:             builtInLibraryFunctions->TryGetValue(entryPoint, &function);",
          "4951:         }",
          "4952:         return function;",
          "4953:     }",
          "4955: #if ENABLE_PROFILE_INFO",
          "4956:     template<template<typename> class BarrierT>",
          "4957:     void ScriptContext::AddDynamicProfileInfo(",
          "4958:         FunctionBody * functionBody, BarrierT<DynamicProfileInfo>& dynamicProfileInfo)",
          "4959:     {",
          "4960:         Assert(functionBody->GetScriptContext() == this);",
          "4961:         Assert(functionBody->HasValidSourceInfo());",
          "4963:         DynamicProfileInfo * newDynamicProfileInfo = dynamicProfileInfo;",
          "4965:         SourceContextInfo* sourceContextInfo = functionBody->GetSourceContextInfo();",
          "4966:         SourceDynamicProfileManager* profileManager = sourceContextInfo->sourceDynamicProfileManager;",
          "4967:         if (sourceContextInfo->IsDynamic())",
          "4968:         {",
          "4969:             if (profileManager != nullptr)",
          "4970:             {",
          "4972:                 if (newDynamicProfileInfo == nullptr)",
          "4973:                 {",
          "4974:                     newDynamicProfileInfo = DynamicProfileInfo::New(this->GetRecycler(), functionBody, true /* persistsAcrossScriptContexts */);",
          "4975:                     profileManager->UpdateDynamicProfileInfo(functionBody->GetLocalFunctionId(), newDynamicProfileInfo);",
          "4976:                     dynamicProfileInfo = newDynamicProfileInfo;",
          "4977:                 }",
          "4978:                 profileManager->MarkAsExecuted(functionBody->GetLocalFunctionId());",
          "4979:                 newDynamicProfileInfo->UpdateFunctionInfo(functionBody, this->GetRecycler());",
          "4980:             }",
          "4981:             else",
          "4982:             {",
          "4983:                 if (newDynamicProfileInfo == nullptr)",
          "4984:                 {",
          "4985:                     newDynamicProfileInfo = functionBody->AllocateDynamicProfile();",
          "4986:                 }",
          "4987:                 dynamicProfileInfo = newDynamicProfileInfo;",
          "4988:             }",
          "4989:         }",
          "4990:         else",
          "4991:         {",
          "4992:             if (newDynamicProfileInfo == nullptr)",
          "4993:             {",
          "4994:                 newDynamicProfileInfo = functionBody->AllocateDynamicProfile();",
          "4995:                 dynamicProfileInfo = newDynamicProfileInfo;",
          "4996:             }",
          "4997:             Assert(functionBody->GetInterpretedCount() == 0);",
          "4998: #if DBG_DUMP || defined(DYNAMIC_PROFILE_STORAGE) || defined(RUNTIME_DATA_COLLECTION)",
          "5000:             if (this->Cache()->profileInfoList)",
          "5001:             {",
          "5002:                 this->Cache()->profileInfoList->Prepend(this->GetRecycler(), newDynamicProfileInfo);",
          "5003:             }",
          "5004: #endif",
          "5005:             if (!startupComplete)",
          "5006:             {",
          "5007:                 Assert(profileManager);",
          "5008:                 profileManager->MarkAsExecuted(functionBody->GetLocalFunctionId());",
          "5009:             }",
          "5010:         }",
          "5011:         Assert(dynamicProfileInfo != nullptr);",
          "5012:     }",
          "5013:     template void  ScriptContext::AddDynamicProfileInfo<WriteBarrierPtr>(FunctionBody *, WriteBarrierPtr<DynamicProfileInfo>&);",
          "5014: #endif",
          "5016:     CharClassifier const * ScriptContext::GetCharClassifier(void) const",
          "5017:     {",
          "5018:         return this->charClassifier;",
          "5019:     }",
          "5021:     void ScriptContext::OnStartupComplete()",
          "5022:     {",
          "5023:         JS_ETW(EventWriteJSCRIPT_ON_STARTUP_COMPLETE(this));",
          "5025:         SaveStartupProfileAndRelease();",
          "5026:     }",
          "5028:     void ScriptContext::SaveStartupProfileAndRelease(bool isSaveOnClose)",
          "5029:     {",
          "5031:         if (GetThreadContext()->IsJSRT())",
          "5032:         {",
          "5033:             return;",
          "5034:         }",
          "5035:         if (!startupComplete && this->Cache()->sourceContextInfoMap)",
          "5036:         {",
          "5037: #if ENABLE_PROFILE_INFO",
          "5038:             this->Cache()->sourceContextInfoMap->Map([&](DWORD_PTR dwHostSourceContext, SourceContextInfo* info)",
          "5039:             {",
          "5040:                 Assert(info->sourceDynamicProfileManager);",
          "5041:                 uint bytesWritten = info->sourceDynamicProfileManager->SaveToProfileCacheAndRelease(info);",
          "5042:                 if (bytesWritten > 0)",
          "5043:                 {",
          "5044:                     JS_ETW(EventWriteJSCRIPT_PROFILE_SAVE(info->dwHostSourceContext, this, bytesWritten, isSaveOnClose));",
          "5045:                     OUTPUT_TRACE(Js::DynamicProfilePhase, _u(\"Profile saving succeeded\\n\"));",
          "5046:                 }",
          "5047:             });",
          "5048: #endif",
          "5049:         }",
          "5050:         startupComplete = true;",
          "5051:     }",
          "5053:     void ScriptContext::SetFastDOMenabled()",
          "5054:     {",
          "5055:         fastDOMenabled = true; Assert(globalObject->GetDirectHostObject() != NULL);",
          "5056:     }",
          "5058: #if DYNAMIC_INTERPRETER_THUNK",
          "5059:     JavascriptMethod ScriptContext::GetNextDynamicAsmJsInterpreterThunk(PVOID* ppDynamicInterpreterThunk)",
          "5060:     {",
          "5061: #ifdef ASMJS_PLAT",
          "5062:         return (JavascriptMethod)this->asmJsInterpreterThunkEmitter->GetNextThunk(ppDynamicInterpreterThunk);",
          "5063: #else",
          "5064:         __debugbreak();",
          "5065:         return nullptr;",
          "5066: #endif",
          "5067:     }",
          "5069:     JavascriptMethod ScriptContext::GetNextDynamicInterpreterThunk(PVOID* ppDynamicInterpreterThunk)",
          "5070:     {",
          "5071:         return (JavascriptMethod)this->interpreterThunkEmitter->GetNextThunk(ppDynamicInterpreterThunk);",
          "5072:     }",
          "5074: #if DBG",
          "5075:     BOOL ScriptContext::IsDynamicInterpreterThunk(JavascriptMethod address)",
          "5076:     {",
          "5077:         return this->interpreterThunkEmitter->IsInHeap((void*)address);",
          "5078:     }",
          "5079: #endif",
          "5081:     void ScriptContext::ReleaseDynamicInterpreterThunk(BYTE* address, bool addtoFreeList)",
          "5082:     {",
          "5083:         this->interpreterThunkEmitter->Release(address, addtoFreeList);",
          "5084:     }",
          "5086:     void ScriptContext::ReleaseDynamicAsmJsInterpreterThunk(BYTE* address, bool addtoFreeList)",
          "5087:     {",
          "5088: #ifdef ASMJS_PLAT",
          "5089:         this->asmJsInterpreterThunkEmitter->Release(address, addtoFreeList);",
          "5090: #else",
          "5091:         Assert(UNREACHED);",
          "5092: #endif",
          "5093:     }",
          "5094: #endif",
          "5096:     bool ScriptContext::IsExceptionWrapperForBuiltInsEnabled()",
          "5097:     {",
          "5098:         return ScriptContext::IsExceptionWrapperForBuiltInsEnabled(this);",
          "5099:     }",
          "5102:     bool ScriptContext::IsExceptionWrapperForBuiltInsEnabled(ScriptContext* scriptContext)",
          "5103:     {",
          "5104:         Assert(scriptContext);",
          "5105:         return CONFIG_FLAG(EnableContinueAfterExceptionWrappersForBuiltIns);",
          "5106:     }",
          "5108:     bool ScriptContext::IsExceptionWrapperForHelpersEnabled(ScriptContext* scriptContext)",
          "5109:     {",
          "5110:         Assert(scriptContext);",
          "5111:         return  CONFIG_FLAG(EnableContinueAfterExceptionWrappersForHelpers);",
          "5112:     }",
          "5114:     void ScriptContextBase::SetGlobalObject(GlobalObject *globalObject)",
          "5115:     {",
          "5116: #if DBG",
          "5117:         ScriptContext* scriptContext = static_cast<ScriptContext*>(this);",
          "5118:         Assert(scriptContext->IsCloningGlobal() && !this->globalObject);",
          "5119: #endif",
          "5120:         this->globalObject = globalObject;",
          "5121:     }",
          "5123:     void ConvertKey(const FastEvalMapString& src, EvalMapString& dest)",
          "5124:     {",
          "5125:         dest.str = src.str;",
          "5126:         dest.strict = src.strict;",
          "5127:         dest.moduleID = src.moduleID;",
          "5128:         dest.hash = TAGHASH((hash_t)dest.str);",
          "5129:     }",
          "5131:     void ScriptContext::PrintStats()",
          "5132:     {",
          "5134: #ifdef PROFILE_TYPES",
          "5135:         if (Configuration::Global.flags.ProfileTypes)",
          "5136:         {",
          "5137:             ProfileTypes();",
          "5138:         }",
          "5139: #endif",
          "5141: #ifdef PROFILE_BAILOUT_RECORD_MEMORY",
          "5142:         if (Configuration::Global.flags.ProfileBailOutRecordMemory)",
          "5143:         {",
          "5144:             Output::Print(_u(\"CodeSize: %6d\\nBailOutRecord Size: %6d\\nLocalOffsets Size: %6d\\n\"), codeSize, bailOutRecordBytes, bailOutOffsetBytes);",
          "5145:         }",
          "5146: #endif",
          "5148: #ifdef PROFILE_OBJECT_LITERALS",
          "5149:         if (Configuration::Global.flags.ProfileObjectLiteral)",
          "5150:         {",
          "5151:             ProfileObjectLiteral();",
          "5152:         }",
          "5153: #endif",
          "5155: #ifdef PROFILE_STRINGS",
          "5156:         if (stringProfiler != nullptr)",
          "5157:         {",
          "5158:             stringProfiler->PrintAll();",
          "5159:             Adelete(MiscAllocator(), stringProfiler);",
          "5160:             stringProfiler = nullptr;",
          "5161:         }",
          "5162: #endif",
          "5164: #ifdef PROFILE_MEM",
          "5165:         if (profileMemoryDump && MemoryProfiler::IsTraceEnabled())",
          "5166:         {",
          "5167:             MemoryProfiler::PrintAll();",
          "5168: #ifdef PROFILE_RECYCLER_ALLOC",
          "5169:             if (Js::Configuration::Global.flags.TraceMemory.IsEnabled(Js::AllPhase)",
          "5170:                 || Js::Configuration::Global.flags.TraceMemory.IsEnabled(Js::RunPhase))",
          "5171:             {",
          "5172:                 GetRecycler()->PrintAllocStats();",
          "5173:             }",
          "5174: #endif",
          "5175:         }",
          "5176: #endif",
          "5177: #if DBG_DUMP",
          "5178:         if (PHASE_STATS1(Js::ByteCodePhase))",
          "5179:         {",
          "5180:             Output::Print(_u(\" Total Bytecode size: <%d, %d, %d> = %d\\n\"),",
          "5181:                 byteCodeDataSize,",
          "5182:                 byteCodeAuxiliaryDataSize,",
          "5183:                 byteCodeAuxiliaryContextDataSize,",
          "5184:                 byteCodeDataSize + byteCodeAuxiliaryDataSize + byteCodeAuxiliaryContextDataSize);",
          "5185:         }",
          "5187:         if (Configuration::Global.flags.BytecodeHist)",
          "5188:         {",
          "5189:             Output::Print(_u(\"ByteCode Histogram\\n\"));",
          "5190:             Output::Print(_u(\"\\n\"));",
          "5192:             uint total = 0;",
          "5193:             uint unique = 0;",
          "5194:             for (int j = 0; j < (int)OpCode::ByteCodeLast; j++)",
          "5195:             {",
          "5196:                 total += byteCodeHistogram[j];",
          "5197:                 if (byteCodeHistogram[j] > 0)",
          "5198:                 {",
          "5199:                     unique++;",
          "5200:                 }",
          "5201:             }",
          "5202:             Output::Print(_u(\"%9u                     Total executed ops\\n\"), total);",
          "5203:             Output::Print(_u(\"\\n\"));",
          "5205:             uint max = UINT_MAX;",
          "5206:             double pctcume = 0.0;",
          "5208:             while (true)",
          "5209:             {",
          "5210:                 uint upper = 0;",
          "5211:                 int index = -1;",
          "5212:                 for (int j = 0; j < (int)OpCode::ByteCodeLast; j++)",
          "5213:                 {",
          "5214:                     if (OpCodeUtil::IsValidOpcode((OpCode)j) && byteCodeHistogram[j] > upper && byteCodeHistogram[j] < max)",
          "5215:                     {",
          "5216:                         index = j;",
          "5217:                         upper = byteCodeHistogram[j];",
          "5218:                     }",
          "5219:                 }",
          "5221:                 if (index == -1)",
          "5222:                 {",
          "5223:                     break;",
          "5224:                 }",
          "5226:                 max = byteCodeHistogram[index];",
          "5228:                 for (OpCode j = (OpCode)0; j < OpCode::ByteCodeLast; j++)",
          "5229:                 {",
          "5230:                     if (OpCodeUtil::IsValidOpcode(j) && max == byteCodeHistogram[(int)j])",
          "5231:                     {",
          "5232:                         double pct = ((double)max) / total;",
          "5233:                         pctcume += pct;",
          "5235:                         Output::Print(_u(\"%9u  %5.1lf  %5.1lf  %04x %s\\n\"), max, pct * 100, pctcume * 100, j, OpCodeUtil::GetOpCodeName(j));",
          "5236:                     }",
          "5237:                 }",
          "5238:             }",
          "5239:             Output::Print(_u(\"\\n\"));",
          "5240:             Output::Print(_u(\"Unique opcodes: %d\\n\"), unique);",
          "5241:         }",
          "5243: #endif",
          "5245: #if ENABLE_NATIVE_CODEGEN",
          "5246: #ifdef BGJIT_STATS",
          "5248:         if (PHASE_STATS1(Js::BGJitPhase) && (this->interpretedCount > 50 || Js::Configuration::Global.flags.IsEnabled(Js::ForceFlag)))",
          "5249:         {",
          "5251: #define MAX_BUCKETS 15",
          "5252:             uint loopJitCodeUsed = 0;",
          "5253:             uint bucketSize1 = 20;",
          "5254:             uint bucketSize2 = 100;",
          "5255:             uint size1CutOffbucketId = 4;",
          "5256:             uint totalBuckets[MAX_BUCKETS] = { 0 };",
          "5257:             uint nativeCodeBuckets[MAX_BUCKETS] = { 0 };",
          "5258:             uint usedNativeCodeBuckets[MAX_BUCKETS] = { 0 };",
          "5259:             uint rejits[MAX_BUCKETS] = { 0 };",
          "5260:             uint zeroInterpretedFunctions = 0;",
          "5261:             uint oneInterpretedFunctions = 0;",
          "5262:             uint nonZeroBytecodeFunctions = 0;",
          "5263:             Output::Print(_u(\"Script Context: 0x%p Url: %s\\n\"), this, this->url);",
          "5265:             FunctionBody* anyFunctionBody = this->FindFunction([](FunctionBody* body) { return body != nullptr; });",
          "5267:             if (anyFunctionBody)",
          "5268:             {",
          "5269:                 OUTPUT_VERBOSE_STATS(Js::BGJitPhase, _u(\"Function list\\n\"));",
          "5270:                 OUTPUT_VERBOSE_STATS(Js::BGJitPhase, _u(\"===============================\\n\"));",
          "5271:                 OUTPUT_VERBOSE_STATS(Js::BGJitPhase, _u(\"%-24s, %-8s, %-10s, %-10s, %-10s, %-10s, %-10s\\n\"), _u(\"Function\"), _u(\"InterpretedCount\"), _u(\"ByteCodeInLoopSize\"), _u(\"ByteCodeSize\"), _u(\"IsJitted\"), _u(\"IsUsed\"), _u(\"NativeCodeSize\"));",
          "5273:                 this->MapFunction([&](FunctionBody* body)",
          "5274:                 {",
          "5275:                     bool isNativeCode = false;",
          "5278:                     if (body->GetInterpretedCount() > 1 || Js::Configuration::Global.flags.IsEnabled(Js::ForceFlag))",
          "5279:                     {",
          "5280:                         body->MapEntryPoints([&](uint entryPointIndex, FunctionEntryPointInfo* entryPoint)",
          "5281:                         {",
          "5282:                             char16 debugStringBuffer[MAX_FUNCTION_BODY_DEBUG_STRING_SIZE];",
          "5283:                             char rejit = entryPointIndex > 0 ? '*' : ' ';",
          "5284:                             isNativeCode = entryPoint->IsNativeCode() | isNativeCode;",
          "5285:                             OUTPUT_VERBOSE_STATS(Js::BGJitPhase, _u(\"%-20s %16s %c, %8d , %10d , %10d, %-10s, %-10s, %10d\\n\"),",
          "5286:                                 body->GetExternalDisplayName(),",
          "5287:                                 body->GetDebugNumberSet(debugStringBuffer),",
          "5288:                                 rejit,",
          "5289:                                 body->GetInterpretedCount(),",
          "5290:                                 body->GetByteCodeInLoopCount(),",
          "5291:                                 body->GetByteCodeCount(),",
          "5292:                                 entryPoint->IsNativeCode() ? _u(\"Jitted\") : _u(\"Interpreted\"),",
          "5293:                                 body->GetNativeEntryPointUsed() ? _u(\"Used\") : _u(\"NotUsed\"),",
          "5294:                                 entryPoint->IsNativeCode() ? entryPoint->GetCodeSize() : 0);",
          "5295:                         });",
          "5296:                     }",
          "5297:                     if (body->GetInterpretedCount() == 0)",
          "5298:                     {",
          "5299:                         zeroInterpretedFunctions++;",
          "5300:                         if (body->GetByteCodeCount() > 0)",
          "5301:                         {",
          "5302:                             nonZeroBytecodeFunctions++;",
          "5303:                         }",
          "5304:                     }",
          "5305:                     else if (body->GetInterpretedCount() == 1)",
          "5306:                     {",
          "5307:                         oneInterpretedFunctions++;",
          "5308:                     }",
          "5312:                     uint bucket;",
          "5313:                     uint intrpCount = body->GetInterpretedCount();",
          "5314:                     if (intrpCount < 100)",
          "5315:                     {",
          "5316:                         bucket = intrpCount / bucketSize1;",
          "5317:                     }",
          "5318:                     else if (intrpCount < 1000)",
          "5319:                     {",
          "5320:                         bucket = size1CutOffbucketId  + intrpCount / bucketSize2;",
          "5321:                     }",
          "5322:                     else",
          "5323:                     {",
          "5324:                         bucket = MAX_BUCKETS - 1;",
          "5325:                     }",
          "5329:                     __analysis_assume(bucket < MAX_BUCKETS);",
          "5331:                     totalBuckets[bucket]++;",
          "5332:                     if (isNativeCode)",
          "5333:                     {",
          "5334:                         nativeCodeBuckets[bucket]++;",
          "5335:                         if (body->GetNativeEntryPointUsed())",
          "5336:                         {",
          "5337:                             usedNativeCodeBuckets[bucket]++;",
          "5338:                         }",
          "5339:                         if (body->HasRejit())",
          "5340:                         {",
          "5341:                             rejits[bucket]++;",
          "5342:                         }",
          "5343:                     }",
          "5345:                     body->MapLoopHeaders([&](uint loopNumber, LoopHeader* header)",
          "5346:                     {",
          "5347:                         char16 loopBodyName[256];",
          "5348:                         body->GetLoopBodyName(loopNumber, loopBodyName, _countof(loopBodyName));",
          "5349:                         header->MapEntryPoints([&](int index, LoopEntryPointInfo * entryPoint)",
          "5350:                         {",
          "5351:                             if (entryPoint->IsNativeCode())",
          "5352:                             {",
          "5353:                                 char16 debugStringBuffer[MAX_FUNCTION_BODY_DEBUG_STRING_SIZE];",
          "5354:                                 char rejit = index > 0 ? '*' : ' ';",
          "5355:                                 OUTPUT_VERBOSE_STATS(Js::BGJitPhase, _u(\"%-20s %16s %c, %8d , %10d , %10d, %-10s, %-10s, %10d\\n\"),",
          "5356:                                     loopBodyName,",
          "5357:                                     body->GetDebugNumberSet(debugStringBuffer),",
          "5358:                                     rejit,",
          "5359:                                     header->interpretCount,",
          "5360:                                     header->GetByteCodeCount(),",
          "5361:                                     header->GetByteCodeCount(),",
          "5362:                                     _u(\"Jitted\"),",
          "5363:                                     entryPoint->IsUsed() ? _u(\"Used\") : _u(\"NotUsed\"),",
          "5364:                                     entryPoint->GetCodeSize());",
          "5365:                                 if (entryPoint->IsUsed())",
          "5366:                                 {",
          "5367:                                     loopJitCodeUsed++;",
          "5368:                                 }",
          "5369:                             }",
          "5370:                         });",
          "5371:                     });",
          "5372:                 });",
          "5373:             }",
          "5375:             Output::Print(_u(\"**  SpeculativelyJitted: %6d FunctionsJitted: %6d JittedUsed: %6d Usage:%f ByteCodesJitted: %6d JitCodeUsed: %6d Usage: %f \\n\"),",
          "5376:                 speculativeJitCount, funcJITCount, funcJitCodeUsed, ((float)(funcJitCodeUsed) / funcJITCount) * 100, bytecodeJITCount, jitCodeUsed, ((float)(jitCodeUsed) / bytecodeJITCount) * 100);",
          "5377:             Output::Print(_u(\"** LoopJITCount: %6d LoopJitCodeUsed: %6d Usage: %f\\n\"),",
          "5378:                 loopJITCount, loopJitCodeUsed, ((float)loopJitCodeUsed / loopJITCount) * 100);",
          "5379:             Output::Print(_u(\"** TotalInterpretedCalls: %6d MaxFuncInterp: %6d  InterpretedHighPri: %6d \\n\"),",
          "5380:                 interpretedCount, maxFuncInterpret, interpretedCallsHighPri);",
          "5381:             Output::Print(_u(\"** ZeroInterpretedFunctions: %6d OneInterpretedFunctions: %6d ZeroInterpretedWithNonZeroBytecode: %6d \\n \"), zeroInterpretedFunctions, oneInterpretedFunctions, nonZeroBytecodeFunctions);",
          "5382:             Output::Print(_u(\"** %-24s : %-10s %-10s %-10s %-10s %-10s\\n\"), _u(\"InterpretedCounts\"), _u(\"Total\"), _u(\"NativeCode\"), _u(\"Used\"), _u(\"Usage\"), _u(\"Rejits\"));",
          "5383:             uint low = 0;",
          "5384:             uint high = 0;",
          "5385:             for (uint i = 0; i < _countof(totalBuckets); i++)",
          "5386:             {",
          "5387:                 low = high;",
          "5388:                 if (i <= size1CutOffbucketId)",
          "5389:                 {",
          "5390:                     high = low + bucketSize1;",
          "5391:                 }",
          "5392:                 else if (i < (_countof(totalBuckets) - 1))",
          "5393:                 {",
          "5394:                     high = low + bucketSize2;               }",
          "5395:                 else",
          "5396:                 {",
          "5397:                     high = 100000;",
          "5398:                 }",
          "5399:                 Output::Print(_u(\"** %10d - %10d : %10d %10d %10d %7.2f %10d\\n\"), low, high, totalBuckets[i], nativeCodeBuckets[i], usedNativeCodeBuckets[i], ((float)usedNativeCodeBuckets[i] / nativeCodeBuckets[i]) * 100, rejits[i]);",
          "5400:             }",
          "5401:             Output::Print(_u(\"\\n\\n\"));",
          "5402:         }",
          "5403: #undef MAX_BUCKETS",
          "5404: #endif",
          "5406: #ifdef REJIT_STATS",
          "5407:         if (PHASE_STATS1(Js::ReJITPhase))",
          "5408:         {",
          "5409:             uint totalBailouts = 0;",
          "5410:             uint totalRejits = 0;",
          "5411:             WCHAR buf[256];",
          "5414:             Output::Print(_u(\"%-40s %6s\\n\"), _u(\"Bailout Reason,\"), _u(\"Count\"));",
          "5416:             bailoutReasonCounts->Map([&totalBailouts](uint kind, uint val) {",
          "5417:                 WCHAR buf[256];",
          "5418:                 totalBailouts += val;",
          "5419:                 if (val != 0)",
          "5420:                 {",
          "5421:                     swprintf_s(buf, _u(\"%S,\"), GetBailOutKindName((IR::BailOutKind)kind));",
          "5422:                     Output::Print(_u(\"%-40s %6d\\n\"), buf, val);",
          "5423:                 }",
          "5424:             });",
          "5427:             Output::Print(_u(\"%-40s %6d\\n\"), _u(\"TOTAL,\"), totalBailouts);",
          "5428:             Output::Print(_u(\"\\n\\n\"));",
          "5431:             Output::Print(_u(\"%-40s %6s\\n\"), _u(\"Rejit Reason,\"), _u(\"Count\"));",
          "5432:             for (uint i = 0; i < NumRejitReasons; ++i)",
          "5433:             {",
          "5434:                 totalRejits += rejitReasonCounts[i];",
          "5435:                 if (rejitReasonCounts[i] != 0)",
          "5436:                 {",
          "5437:                     swprintf_s(buf, _u(\"%S,\"), RejitReasonNames[i]);",
          "5438:                     Output::Print(_u(\"%-40s %6d\\n\"), buf, rejitReasonCounts[i]);",
          "5439:                 }",
          "5440:             }",
          "5441:             Output::Print(_u(\"%-40s %6d\\n\"), _u(\"TOTAL,\"), totalRejits);",
          "5442:             Output::Print(_u(\"\\n\\n\"));",
          "5445:             if (Configuration::Global.flags.Verbose && rejitStatsMap != NULL)",
          "5446:             {",
          "5448:                 Output::Print(_u(\"%-30s %14s %14s\\n\"), _u(\"Function (#),\"), _u(\"Bailout Count,\"), _u(\"Rejit Count\"));",
          "5449:                 rejitStatsMap->Map([](Js::FunctionBody const *body, RejitStats *stats, RecyclerWeakReference<const Js::FunctionBody> const*) {",
          "5450:                     char16 debugStringBuffer[MAX_FUNCTION_BODY_DEBUG_STRING_SIZE];",
          "5451:                     for (uint i = 0; i < NumRejitReasons; ++i)",
          "5452:                         stats->m_totalRejits += stats->m_rejitReasonCounts[i];",
          "5454:                     stats->m_bailoutReasonCounts->Map([stats](uint kind, uint val) {",
          "5455:                         stats->m_totalBailouts += val;",
          "5456:                     });",
          "5458:                     WCHAR buf[256];",
          "5460:                     swprintf_s(buf, _u(\"%s (%s),\"), body->GetExternalDisplayName(), (const_cast<Js::FunctionBody*>(body))->GetDebugNumberSet(debugStringBuffer)); //TODO Kount",
          "5461:                     Output::Print(_u(\"%-30s %14d, %14d\\n\"), buf, stats->m_totalBailouts, stats->m_totalRejits);",
          "5463:                 });",
          "5464:                 Output::Print(_u(\"\\n\\n\"));",
          "5467:                 rejitStatsMap->Map([](Js::FunctionBody const *body, RejitStats *stats, RecyclerWeakReference<const Js::FunctionBody> const *) {",
          "5468:                     char16 debugStringBuffer[MAX_FUNCTION_BODY_DEBUG_STRING_SIZE];",
          "5469:                     WCHAR buf[256];",
          "5471:                     swprintf_s(buf, _u(\"%s (%s),\"), body->GetExternalDisplayName(), (const_cast<Js::FunctionBody*>(body))->GetDebugNumberSet(debugStringBuffer)); //TODO Kount",
          "5472:                     Output::Print(_u(\"%-30s\\n\\n\"), buf);",
          "5475:                     if (stats->m_totalBailouts != 0)",
          "5476:                     {",
          "5477:                         Output::Print(_u(\"%10sBailouts:\\n\"), _u(\"\"));",
          "5479:                         stats->m_bailoutReasonCounts->Map([](uint kind, uint val) {",
          "5480:                             if (val != 0)",
          "5481:                             {",
          "5482:                                 WCHAR buf[256];",
          "5483:                                 swprintf_s(buf, _u(\"%S,\"), GetBailOutKindName((IR::BailOutKind)kind));",
          "5484:                                 Output::Print(_u(\"%10s%-40s %6d\\n\"), _u(\"\"), buf, val);",
          "5485:                             }",
          "5486:                         });",
          "5487:                     }",
          "5488:                     Output::Print(_u(\"\\n\"));",
          "5491:                     if (stats->m_totalRejits != 0)",
          "5492:                     {",
          "5493:                         Output::Print(_u(\"%10sRejits:\\n\"), _u(\"\"));",
          "5494:                         for (uint i = 0; i < NumRejitReasons; ++i)",
          "5495:                         {",
          "5496:                             if (stats->m_rejitReasonCounts[i] != 0)",
          "5497:                             {",
          "5498:                                 swprintf_s(buf, _u(\"%S,\"), RejitReasonNames[i]);",
          "5499:                                 Output::Print(_u(\"%10s%-40s %6d\\n\"), _u(\"\"), buf, stats->m_rejitReasonCounts[i]);",
          "5500:                             }",
          "5501:                         }",
          "5502:                         Output::Print(_u(\"\\n\\n\"));",
          "5503:                     }",
          "5504:                 });",
          "5506:             }",
          "5507:         }",
          "5508: #endif",
          "5510: #ifdef FIELD_ACCESS_STATS",
          "5511:     if (PHASE_STATS1(Js::ObjTypeSpecPhase))",
          "5512:     {",
          "5513:         FieldAccessStats globalStats;",
          "5514:         if (this->fieldAccessStatsByFunctionNumber != nullptr)",
          "5515:         {",
          "5516:             this->fieldAccessStatsByFunctionNumber->Map([&globalStats](uint functionNumber, FieldAccessStatsEntry* entry)",
          "5517:             {",
          "5518:                 FieldAccessStats functionStats;",
          "5519:                 entry->stats.Map([&functionStats](FieldAccessStatsPtr entryPointStats)",
          "5520:                 {",
          "5521:                     functionStats.Add(entryPointStats);",
          "5522:                 });",
          "5524:                 if (PHASE_VERBOSE_STATS1(Js::ObjTypeSpecPhase))",
          "5525:                 {",
          "5526:                     FunctionBody* functionBody = entry->functionBodyWeakRef->Get();",
          "5527:                     const char16* functionName = functionBody != nullptr ? functionBody->GetDisplayName() : _u(\"<unknown>\");",
          "5528:                     Output::Print(_u(\"FieldAccessStats: function %s (#%u): inline cache stats:\\n\"), functionName, functionNumber);",
          "5529:                     Output::Print(_u(\"    overall: total %u, no profile info %u\\n\"), functionStats.totalInlineCacheCount, functionStats.noInfoInlineCacheCount);",
          "5530:                     Output::Print(_u(\"    mono: total %u, empty %u, cloned %u\\n\"),",
          "5531:                         functionStats.monoInlineCacheCount, functionStats.emptyMonoInlineCacheCount, functionStats.clonedMonoInlineCacheCount);",
          "5532:                     Output::Print(_u(\"    poly: total %u (high %u, low %u), null %u, empty %u, ignored %u, disabled %u, equivalent %u, non-equivalent %u, cloned %u\\n\"),",
          "5533:                         functionStats.polyInlineCacheCount, functionStats.highUtilPolyInlineCacheCount, functionStats.lowUtilPolyInlineCacheCount,",
          "5534:                         functionStats.nullPolyInlineCacheCount, functionStats.emptyPolyInlineCacheCount, functionStats.ignoredPolyInlineCacheCount, functionStats.disabledPolyInlineCacheCount,",
          "5535:                         functionStats.equivPolyInlineCacheCount, functionStats.nonEquivPolyInlineCacheCount, functionStats.clonedPolyInlineCacheCount);",
          "5536:                 }",
          "5538:                 globalStats.Add(&functionStats);",
          "5539:             });",
          "5540:         }",
          "5542:         Output::Print(_u(\"FieldAccessStats: totals\\n\"));",
          "5543:         Output::Print(_u(\"    overall: total %u, no profile info %u\\n\"), globalStats.totalInlineCacheCount, globalStats.noInfoInlineCacheCount);",
          "5544:         Output::Print(_u(\"    mono: total %u, empty %u, cloned %u\\n\"),",
          "5545:             globalStats.monoInlineCacheCount, globalStats.emptyMonoInlineCacheCount, globalStats.clonedMonoInlineCacheCount);",
          "5546:         Output::Print(_u(\"    poly: total %u (high %u, low %u), null %u, empty %u, ignored %u, disabled %u, equivalent %u, non-equivalent %u, cloned %u\\n\"),",
          "5547:             globalStats.polyInlineCacheCount, globalStats.highUtilPolyInlineCacheCount, globalStats.lowUtilPolyInlineCacheCount,",
          "5548:             globalStats.nullPolyInlineCacheCount, globalStats.emptyPolyInlineCacheCount, globalStats.ignoredPolyInlineCacheCount, globalStats.disabledPolyInlineCacheCount,",
          "5549:             globalStats.equivPolyInlineCacheCount, globalStats.nonEquivPolyInlineCacheCount, globalStats.clonedPolyInlineCacheCount);",
          "5550:     }",
          "5551: #endif",
          "5553: #ifdef MISSING_PROPERTY_STATS",
          "5554:     if (PHASE_STATS1(Js::MissingPropertyCachePhase))",
          "5555:     {",
          "5556:         Output::Print(_u(\"MissingPropertyStats: hits = %d, misses = %d, cache attempts = %d.\\n\"),",
          "5557:             this->missingPropertyHits, this->missingPropertyMisses, this->missingPropertyCacheAttempts);",
          "5558:     }",
          "5559: #endif",
          "5562: #ifdef INLINE_CACHE_STATS",
          "5563:         if (PHASE_STATS1(Js::PolymorphicInlineCachePhase))",
          "5564:         {",
          "5565:             Output::Print(_u(\"%s,%s,%s,%s,%s,%s,%s,%s,%s\\n\"), _u(\"Function\"), _u(\"Property\"), _u(\"Kind\"), _u(\"Accesses\"), _u(\"Misses\"), _u(\"Miss Rate\"), _u(\"Collisions\"), _u(\"Collision Rate\"), _u(\"Slot Count\"));",
          "5566:             cacheDataMap->Map([this](Js::PolymorphicInlineCache const *cache, CacheData *data) {",
          "5567:                 char16 debugStringBuffer[MAX_FUNCTION_BODY_DEBUG_STRING_SIZE];",
          "5568:                 uint total = data->hits + data->misses;",
          "5569:                 char16 const *propName = this->threadContext->GetPropertyName(data->propertyId)->GetBuffer();",
          "5571:                 wchar funcName[1024];",
          "5573:                 swprintf_s(funcName, _u(\"%s (%s)\"), cache->functionBody->GetExternalDisplayName(), cache->functionBody->GetDebugNumberSet(debugStringBuffer));",
          "5575:                 Output::Print(_u(\"%s,%s,%s,%d,%d,%f,%d,%f,%d\\n\"),",
          "5576:                     funcName,",
          "5577:                     propName,",
          "5578:                     data->isGetCache ? _u(\"get\") : _u(\"set\"),",
          "5579:                     total,",
          "5580:                     data->misses,",
          "5581:                     static_cast<float>(data->misses) / total,",
          "5582:                     data->collisions,",
          "5583:                     static_cast<float>(data->collisions) / total,",
          "5584:                     cache->GetSize()",
          "5585:                     );",
          "5586:             });",
          "5587:         }",
          "5588: #endif",
          "5590: #if ENABLE_REGEX_CONFIG_OPTIONS",
          "5591:         if (regexStatsDatabase != 0)",
          "5592:             regexStatsDatabase->Print(GetRegexDebugWriter());",
          "5593: #endif",
          "5594:         OUTPUT_STATS(Js::EmitterPhase, _u(\"Script Context: 0x%p Url: %s\\n\"), this, this->url);",
          "5595:         OUTPUT_STATS(Js::EmitterPhase, _u(\"  Total thread committed code size = %d\\n\"), this->GetThreadContext()->GetCodeSize());",
          "5597:         OUTPUT_STATS(Js::ParsePhase, _u(\"Script Context: 0x%p Url: %s\\n\"), this, this->url);",
          "5598:         OUTPUT_STATS(Js::ParsePhase, _u(\"  Total ThreadContext source size %d\\n\"), this->GetThreadContext()->GetSourceSize());",
          "5599: #endif",
          "5601: #ifdef ENABLE_BASIC_TELEMETRY",
          "5602:         if (this->telemetry != nullptr)",
          "5603:         {",
          "5605:             this->telemetry->OutputPrint();",
          "5606:         }",
          "5607: #endif",
          "5609:         Output::Flush();",
          "5610:     }",
          "5611:     void ScriptContext::SetNextPendingClose(ScriptContext * nextPendingClose) {",
          "5612:         this->nextPendingClose = nextPendingClose;",
          "5613:     }",
          "5615: #ifdef ENABLE_MUTATION_BREAKPOINT",
          "5616:     bool ScriptContext::HasMutationBreakpoints()",
          "5617:     {",
          "5618:         if (this->GetDebugContext() != nullptr && this->GetDebugContext()->GetProbeContainer() != nullptr)",
          "5619:         {",
          "5620:             return this->GetDebugContext()->GetProbeContainer()->HasMutationBreakpoints();",
          "5621:         }",
          "5622:         return false;",
          "5623:     }",
          "5625:     void ScriptContext::InsertMutationBreakpoint(Js::MutationBreakpoint *mutationBreakpoint)",
          "5626:     {",
          "5627:         this->GetDebugContext()->GetProbeContainer()->InsertMutationBreakpoint(mutationBreakpoint);",
          "5628:     }",
          "5629: #endif",
          "5631: #ifdef REJIT_STATS",
          "5632:     void ScriptContext::LogDataForFunctionBody(Js::FunctionBody *body, uint idx, bool isRejit)",
          "5633:     {",
          "5634:         if (rejitStatsMap == NULL)",
          "5635:         {",
          "5636:             rejitStatsMap = RecyclerNew(this->recycler, RejitStatsMap, this->recycler);",
          "5637:             BindReference(rejitStatsMap);",
          "5638:         }",
          "5640:         RejitStats *stats = NULL;",
          "5641:         if (!rejitStatsMap->TryGetValue(body, &stats))",
          "5642:         {",
          "5643:             stats = Anew(GeneralAllocator(), RejitStats, this);",
          "5644:             rejitStatsMap->Item(body, stats);",
          "5645:         }",
          "5647:         if (isRejit)",
          "5648:         {",
          "5649:             stats->m_rejitReasonCounts[idx]++;",
          "5650:         }",
          "5651:         else",
          "5652:         {",
          "5653:             if (!stats->m_bailoutReasonCounts->ContainsKey(idx))",
          "5654:             {",
          "5655:                 stats->m_bailoutReasonCounts->Item(idx, 1);",
          "5656:             }",
          "5657:             else",
          "5658:             {",
          "5659:                 uint val = stats->m_bailoutReasonCounts->Item(idx);",
          "5660:                 ++val;",
          "5661:                 stats->m_bailoutReasonCounts->Item(idx, val);",
          "5662:             }",
          "5663:         }",
          "5664:     }",
          "5665:     void ScriptContext::LogRejit(Js::FunctionBody *body, uint reason)",
          "5666:     {",
          "5667:         Assert(reason < NumRejitReasons);",
          "5668:         rejitReasonCounts[reason]++;",
          "5670:         if (Js::Configuration::Global.flags.Verbose)",
          "5671:         {",
          "5672:             LogDataForFunctionBody(body, reason, true);",
          "5673:         }",
          "5674:     }",
          "5675:     void ScriptContext::LogBailout(Js::FunctionBody *body, uint kind)",
          "5676:     {",
          "5677:         if (!bailoutReasonCounts->ContainsKey(kind))",
          "5678:         {",
          "5679:             bailoutReasonCounts->Item(kind, 1);",
          "5680:         }",
          "5681:         else",
          "5682:         {",
          "5683:             uint val = bailoutReasonCounts->Item(kind);",
          "5684:             ++val;",
          "5685:             bailoutReasonCounts->Item(kind, val);",
          "5686:         }",
          "5688:         if (Js::Configuration::Global.flags.Verbose)",
          "5689:         {",
          "5690:             LogDataForFunctionBody(body, kind, false);",
          "5691:         }",
          "5692:     }",
          "5693: #endif",
          "5695: #ifdef ENABLE_BASIC_TELEMETRY",
          "5696:     ScriptContextTelemetry& ScriptContext::GetTelemetry()",
          "5697:     {",
          "5698:         return *this->telemetry;",
          "5699:     }",
          "5700:     bool ScriptContext::HasTelemetry()",
          "5701:     {",
          "5702:         return this->telemetry != nullptr;",
          "5703:     }",
          "5704: #endif",
          "5706:     bool ScriptContext::IsScriptContextInNonDebugMode() const",
          "5707:     {",
          "5708:         if (this->debugContext != nullptr)",
          "5709:         {",
          "5710:             return this->GetDebugContext()->IsDebugContextInNonDebugMode();",
          "5711:         }",
          "5712:         return true;",
          "5713:     }",
          "5715:     bool ScriptContext::IsScriptContextInDebugMode() const",
          "5716:     {",
          "5717:         if (this->debugContext != nullptr)",
          "5718:         {",
          "5719:             return this->GetDebugContext()->IsDebugContextInDebugMode();",
          "5720:         }",
          "5721:         return false;",
          "5722:     }",
          "5724:     bool ScriptContext::IsScriptContextInSourceRundownOrDebugMode() const",
          "5725:     {",
          "5726:         if (this->debugContext != nullptr)",
          "5727:         {",
          "5728:             return this->GetDebugContext()->IsDebugContextInSourceRundownOrDebugMode();",
          "5729:         }",
          "5730:         return false;",
          "5731:     }",
          "5733:     bool ScriptContext::IsIntlEnabled()",
          "5734:     {",
          "5735:         if (GetConfig()->IsIntlEnabled())",
          "5736:         {",
          "5737: #ifdef ENABLE_GLOBALIZATION",
          "5739:             Js::DelayLoadWindowsGlobalization* globLibrary = GetThreadContext()->GetWindowsGlobalizationLibrary();",
          "5740:             return globLibrary->HasGlobalizationDllLoaded();",
          "5741: #endif",
          "5742:         }",
          "5743:         return false;",
          "5744:     }",
          "5747: #ifdef INLINE_CACHE_STATS",
          "5748:     void ScriptContext::LogCacheUsage(Js::PolymorphicInlineCache *cache, bool isGetter, Js::PropertyId propertyId, bool hit, bool collision)",
          "5749:     {",
          "5750:         if (cacheDataMap == NULL)",
          "5751:         {",
          "5752:             cacheDataMap = RecyclerNew(this->recycler, CacheDataMap, this->recycler);",
          "5753:             BindReference(cacheDataMap);",
          "5754:         }",
          "5756:         CacheData *data = NULL;",
          "5757:         if (!cacheDataMap->TryGetValue(cache, &data))",
          "5758:         {",
          "5759:             data = Anew(GeneralAllocator(), CacheData);",
          "5760:             cacheDataMap->Item(cache, data);",
          "5761:             data->isGetCache = isGetter;",
          "5762:             data->propertyId = propertyId;",
          "5763:         }",
          "5765:         Assert(data->isGetCache == isGetter);",
          "5766:         Assert(data->propertyId == propertyId);",
          "5768:         if (hit)",
          "5769:         {",
          "5770:             data->hits++;",
          "5771:         }",
          "5772:         else",
          "5773:         {",
          "5774:             data->misses++;",
          "5775:         }",
          "5776:         if (collision)",
          "5777:         {",
          "5778:             data->collisions++;",
          "5779:         }",
          "5780:     }",
          "5781: #endif",
          "5783: #ifdef FIELD_ACCESS_STATS",
          "5784:     void ScriptContext::RecordFieldAccessStats(FunctionBody* functionBody, FieldAccessStatsPtr fieldAccessStats)",
          "5785:     {",
          "5786:         Assert(fieldAccessStats != nullptr);",
          "5788:         if (!PHASE_STATS1(Js::ObjTypeSpecPhase))",
          "5789:         {",
          "5790:             return;",
          "5791:         }",
          "5793:         FieldAccessStatsEntry* entry;",
          "5794:         if (!this->fieldAccessStatsByFunctionNumber->TryGetValue(functionBody->GetFunctionNumber(), &entry))",
          "5795:         {",
          "5796:             RecyclerWeakReference<FunctionBody>* functionBodyWeakRef;",
          "5797:             this->recycler->FindOrCreateWeakReferenceHandle(functionBody, &functionBodyWeakRef);",
          "5798:             entry = RecyclerNew(this->recycler, FieldAccessStatsEntry, functionBodyWeakRef, this->recycler);",
          "5800:             this->fieldAccessStatsByFunctionNumber->AddNew(functionBody->GetFunctionNumber(), entry);",
          "5801:         }",
          "5803:         entry->stats.Prepend(fieldAccessStats);",
          "5804:     }",
          "5805: #endif",
          "5807: #ifdef MISSING_PROPERTY_STATS",
          "5808:     void ScriptContext::RecordMissingPropertyMiss()",
          "5809:     {",
          "5810:         this->missingPropertyMisses++;",
          "5811:     }",
          "5813:     void ScriptContext::RecordMissingPropertyHit()",
          "5814:     {",
          "5815:         this->missingPropertyHits++;",
          "5816:     }",
          "5818:     void ScriptContext::RecordMissingPropertyCacheAttempt()",
          "5819:     {",
          "5820:         this->missingPropertyCacheAttempts++;",
          "5821:     }",
          "5822: #endif",
          "5824:     bool ScriptContext::IsIntConstPropertyOnGlobalObject(Js::PropertyId propId)",
          "5825:     {",
          "5826:         return intConstPropsOnGlobalObject->ContainsKey(propId);",
          "5827:     }",
          "5829:     void ScriptContext::TrackIntConstPropertyOnGlobalObject(Js::PropertyId propertyId)",
          "5830:     {",
          "5831:         intConstPropsOnGlobalObject->AddNew(propertyId);",
          "5832:     }",
          "5834:     bool ScriptContext::IsIntConstPropertyOnGlobalUserObject(Js::PropertyId propertyId)",
          "5835:     {",
          "5836:         return intConstPropsOnGlobalUserObject->ContainsKey(propertyId) != NULL;",
          "5837:     }",
          "5839:     void ScriptContext::TrackIntConstPropertyOnGlobalUserObject(Js::PropertyId propertyId)",
          "5840:     {",
          "5841:         intConstPropsOnGlobalUserObject->AddNew(propertyId);",
          "5842:     }",
          "5844:     void ScriptContext::AddCalleeSourceInfoToList(Utf8SourceInfo* sourceInfo)",
          "5845:     {",
          "5846:         Assert(sourceInfo);",
          "5848:         RecyclerWeakReference<Js::Utf8SourceInfo>* sourceInfoWeakRef = nullptr;",
          "5849:         this->GetRecycler()->FindOrCreateWeakReferenceHandle(sourceInfo, &sourceInfoWeakRef);",
          "5850:         Assert(sourceInfoWeakRef);",
          "5852:         if (!calleeUtf8SourceInfoList)",
          "5853:         {",
          "5854:             Recycler *recycler = this->GetRecycler();",
          "5855:             calleeUtf8SourceInfoList.Root(RecyclerNew(recycler, CalleeSourceList, recycler), recycler);",
          "5856:         }",
          "5858:         if (!calleeUtf8SourceInfoList->Contains(sourceInfoWeakRef))",
          "5859:         {",
          "5860:             calleeUtf8SourceInfoList->Add(sourceInfoWeakRef);",
          "5861:         }",
          "5862:     }",
          "5864: #ifdef ENABLE_JS_ETW",
          "5865:     void ScriptContext::EmitStackTraceEvent(__in UINT64 operationID, __in USHORT maxFrameCount, bool emitV2AsyncStackEvent)",
          "5866:     {",
          "5868:         if (GetThreadContext()->GetCallRootLevel() == 0)",
          "5869:         {",
          "5870:             return;",
          "5871:         }",
          "5873:         Assert(EventEnabledJSCRIPT_STACKTRACE() || EventEnabledJSCRIPT_ASYNCCAUSALITY_STACKTRACE_V2() || PHASE_TRACE1(Js::StackFramesEventPhase));",
          "5874:         BEGIN_TEMP_ALLOCATOR(tempAllocator, this, _u(\"StackTraceEvent\"))",
          "5875:         {",
          "5876:             JsUtil::List<StackFrameInfo, ArenaAllocator> stackFrames(tempAllocator);",
          "5877:             Js::JavascriptStackWalker walker(this);",
          "5878:             unsigned short nameBufferLength = 0;",
          "5879:             Js::StringBuilder<ArenaAllocator> nameBuffer(tempAllocator);",
          "5880:             nameBuffer.Reset();",
          "5882:             OUTPUT_TRACE(Js::StackFramesEventPhase, _u(\"\\nPosting stack trace via ETW:\\n\"));",
          "5884:             ushort frameCount = walker.WalkUntil((ushort)maxFrameCount, [&](Js::JavascriptFunction* function, ushort frameIndex) -> bool",
          "5885:             {",
          "5886:                 ULONG lineNumber = 0;",
          "5887:                 LONG columnNumber = 0;",
          "5888:                 UINT32 methodIdOrNameId = 0;",
          "5889:                 UINT8 isFrameIndex = 0; // FALSE",
          "5890:                 const WCHAR* name = nullptr;",
          "5891:                 if (function->IsScriptFunction() && !function->IsLibraryCode())",
          "5892:                 {",
          "5893:                     Js::FunctionBody * functionBody = function->GetFunctionBody();",
          "5894:                     functionBody->GetLineCharOffset(walker.GetByteCodeOffset(), &lineNumber, &columnNumber);",
          "5895:                     methodIdOrNameId = EtwTrace::GetFunctionId(functionBody);",
          "5896:                     name = functionBody->GetExternalDisplayName();",
          "5897:                 }",
          "5898:                 else",
          "5899:                 {",
          "5900:                     if (function->IsScriptFunction())",
          "5901:                     {",
          "5902:                         name = function->GetFunctionBody()->GetExternalDisplayName();",
          "5903:                     }",
          "5904:                     else",
          "5905:                     {",
          "5906:                         name = walker.GetCurrentNativeLibraryEntryName();",
          "5907:                     }",
          "5909:                     ushort nameLen = ProcessNameAndGetLength(&nameBuffer, name);",
          "5911:                     methodIdOrNameId = nameBufferLength;",
          "5914:                     nameBufferLength += nameLen;",
          "5916:                     isFrameIndex = 1; // TRUE;",
          "5917:                 }",
          "5919:                 StackFrameInfo frame((DWORD_PTR)function->GetScriptContext(),",
          "5920:                     (UINT32)lineNumber,",
          "5921:                     (UINT32)columnNumber,",
          "5922:                     methodIdOrNameId,",
          "5923:                     isFrameIndex);",
          "5925:                 OUTPUT_TRACE(Js::StackFramesEventPhase, _u(\"Frame : (%s : %u) (%s), LineNumber : %u, ColumnNumber : %u\\n\"),",
          "5926:                     (isFrameIndex == 1) ? (_u(\"NameBufferIndex\")) : (_u(\"MethodID\")),",
          "5927:                     methodIdOrNameId,",
          "5928:                     name,",
          "5929:                     lineNumber,",
          "5930:                     columnNumber);",
          "5932:                 stackFrames.Add(frame);",
          "5934:                 return false;",
          "5935:             });",
          "5937:             Assert(frameCount == (ushort)stackFrames.Count());",
          "5939:             if (frameCount > 0) // No need to emit event if there are no script frames.",
          "5940:             {",
          "5941:                 auto nameBufferString = nameBuffer.Detach();",
          "5943:                 if (nameBufferLength > 0)",
          "5944:                 {",
          "5946:                     nameBufferLength++;",
          "5947:                 }",
          "5949:                 if (emitV2AsyncStackEvent)",
          "5950:                 {",
          "5951:                     JS_ETW(EventWriteJSCRIPT_ASYNCCAUSALITY_STACKTRACE_V2(operationID, frameCount, nameBufferLength, sizeof(StackFrameInfo), &stackFrames.Item(0), nameBufferString));",
          "5952:                 }",
          "5953:                 else",
          "5954:                 {",
          "5955:                     JS_ETW(EventWriteJSCRIPT_STACKTRACE(operationID, frameCount, nameBufferLength, sizeof(StackFrameInfo), &stackFrames.Item(0), nameBufferString));",
          "5956:                 }",
          "5957:             }",
          "5958:         }",
          "5959:         END_TEMP_ALLOCATOR(tempAllocator, this);",
          "5961:         OUTPUT_FLUSH();",
          "5962:     }",
          "5963: #endif",
          "5973:     charcount_t ScriptContext::AppendWithEscapeCharacters(Js::StringBuilder<ArenaAllocator>* stringBuilder, const WCHAR* sourceString, charcount_t sourceStringLen, WCHAR escapeChar, WCHAR charToEscape)",
          "5974:     {",
          "5975:         const WCHAR* charToEscapePtr = wcschr(sourceString, charToEscape);",
          "5976:         charcount_t charsPadding = 0;",
          "5979:         if (charToEscapePtr)",
          "5980:         {",
          "5981:             charcount_t charsWritten = 0;",
          "5982:             charcount_t charsToAppend = 0;",
          "5984:             while (charToEscapePtr)",
          "5985:             {",
          "5986:                 charsToAppend = static_cast<charcount_t>(charToEscapePtr - sourceString) - charsWritten;",
          "5988:                 stringBuilder->Append(sourceString + charsWritten, charsToAppend);",
          "5989:                 stringBuilder->Append(escapeChar);",
          "5990:                 stringBuilder->Append(charToEscape);",
          "5993:                 charsPadding++;",
          "5996:                 charsWritten += charsToAppend + 1;",
          "5999:                 charToEscapePtr++;",
          "6000:                 charToEscapePtr = wcschr(charToEscapePtr, charToEscape);",
          "6001:             }",
          "6004:             if (charsWritten != sourceStringLen)",
          "6005:             {",
          "6006:                 charsToAppend = sourceStringLen - charsWritten;",
          "6007:                 stringBuilder->Append(sourceString + charsWritten, charsToAppend);",
          "6008:             }",
          "6009:         }",
          "6010:         else",
          "6011:         {",
          "6012:             stringBuilder->AppendSz(sourceString);",
          "6013:         }",
          "6015:         return sourceStringLen + charsPadding;",
          "6016:     }",
          "6019:     ushort ScriptContext::ProcessNameAndGetLength(Js::StringBuilder<ArenaAllocator>* nameBuffer, const WCHAR* name)",
          "6020:     {",
          "6021:         Assert(nameBuffer);",
          "6022:         Assert(name);",
          "6024:         ushort nameLen = (ushort)wcslen(name);",
          "6027:         nameBuffer->Append('\\\"');",
          "6030:         nameLen = (unsigned short)AppendWithEscapeCharacters(nameBuffer, name, nameLen, '\\\\', '\\\"');",
          "6032:         nameBuffer->AppendCppLiteral(_u(\"\\\";\"));",
          "6035:         nameLen += 3;",
          "6037:         return nameLen;",
          "6038:     }",
          "6040:     Field(Js::Var)* ScriptContext::GetModuleExportSlotArrayAddress(uint moduleIndex, uint slotIndex)",
          "6041:     {",
          "6042:         Js::SourceTextModuleRecord* moduleRecord = this->GetModuleRecord(moduleIndex);",
          "6043:         Assert(moduleRecord != nullptr);",
          "6046:         if (moduleRecord->GetLocalExportCount() + 1 <= slotIndex)",
          "6047:         {",
          "6048:             Js::Throw::FatalInternalError();",
          "6049:         }",
          "6051:         return moduleRecord->GetLocalExportSlots();",
          "6052:     }",
          "6054:     void JITPageAddrToFuncRangeCache::ClearCache()",
          "6055:     {",
          "6056:         if (jitPageAddrToFuncRangeMap != nullptr)",
          "6057:         {",
          "6058:             jitPageAddrToFuncRangeMap->Map(",
          "6059:                 [](void* key, RangeMap* value) {",
          "6060:                 HeapDelete(value);",
          "6061:             });",
          "6063:             HeapDelete(jitPageAddrToFuncRangeMap);",
          "6064:             jitPageAddrToFuncRangeMap = nullptr;",
          "6065:         }",
          "6067:         if (largeJitFuncToSizeMap != nullptr)",
          "6068:         {",
          "6069:             HeapDelete(largeJitFuncToSizeMap);",
          "6070:             largeJitFuncToSizeMap = nullptr;",
          "6071:         }",
          "6072:     }",
          "6074:     void JITPageAddrToFuncRangeCache::AddFuncRange(void * address, uint bytes)",
          "6075:     {",
          "6076:         AutoCriticalSection autocs(GetCriticalSection());",
          "6078:         if (bytes <= AutoSystemInfo::PageSize)",
          "6079:         {",
          "6080:             if (jitPageAddrToFuncRangeMap == nullptr)",
          "6081:             {",
          "6082:                 jitPageAddrToFuncRangeMap = HeapNew(JITPageAddrToFuncRangeMap, &HeapAllocator::Instance);",
          "6083:             }",
          "6085:             void * pageAddr = GetPageAddr(address);",
          "6086:             RangeMap * rangeMap = nullptr;",
          "6087:             bool isPageAddrFound = jitPageAddrToFuncRangeMap->TryGetValue(pageAddr, &rangeMap);",
          "6088:             if (rangeMap == nullptr)",
          "6089:             {",
          "6090:                 Assert(!isPageAddrFound);",
          "6091:                 rangeMap = HeapNew(RangeMap, &HeapAllocator::Instance);",
          "6092:                 jitPageAddrToFuncRangeMap->Add(pageAddr, rangeMap);",
          "6093:             }",
          "6094:             uint byteCount = 0;",
          "6095:             Assert(!rangeMap->TryGetValue(address, &byteCount));",
          "6096:             rangeMap->Add(address, bytes);",
          "6097:         }",
          "6098:         else",
          "6099:         {",
          "6100:             if (largeJitFuncToSizeMap == nullptr)",
          "6101:             {",
          "6102:                 largeJitFuncToSizeMap = HeapNew(LargeJITFuncAddrToSizeMap, &HeapAllocator::Instance);",
          "6103:             }",
          "6105:             uint byteCount = 0;",
          "6106:             Assert(!largeJitFuncToSizeMap->TryGetValue(address, &byteCount));",
          "6107:             largeJitFuncToSizeMap->Add(address, bytes);",
          "6108:         }",
          "6109:     }",
          "6111:     void* JITPageAddrToFuncRangeCache::GetPageAddr(void * address)",
          "6112:     {",
          "6113:         return (void*)((uintptr_t)address & ~(AutoSystemInfo::PageSize - 1));",
          "6114:     }",
          "6116:     void JITPageAddrToFuncRangeCache::RemoveFuncRange(void * address)",
          "6117:     {",
          "6118:         AutoCriticalSection autocs(GetCriticalSection());",
          "6120:         void * pageAddr = GetPageAddr(address);",
          "6122:         RangeMap * rangeMap = nullptr;",
          "6123:         uint bytes = 0;",
          "6124:         if (jitPageAddrToFuncRangeMap && jitPageAddrToFuncRangeMap->TryGetValue(pageAddr, &rangeMap))",
          "6125:         {",
          "6126:             Assert(rangeMap->Count() != 0);",
          "6127:             rangeMap->Remove(address);",
          "6129:             if (rangeMap->Count() == 0)",
          "6130:             {",
          "6131:                 HeapDelete(rangeMap);",
          "6132:                 rangeMap = nullptr;",
          "6133:                 jitPageAddrToFuncRangeMap->Remove(pageAddr);",
          "6134:             }",
          "6135:             return;",
          "6136:         }",
          "6137:         else if (largeJitFuncToSizeMap && largeJitFuncToSizeMap->TryGetValue(address, &bytes))",
          "6138:         {",
          "6139:             largeJitFuncToSizeMap->Remove(address);",
          "6140:         }",
          "6141:         else",
          "6142:         {",
          "6143:             AssertMsg(false, \"Page address not found to remove the func range\");",
          "6144:         }",
          "6145:     }",
          "6147:     bool JITPageAddrToFuncRangeCache::IsNativeAddr(void * address)",
          "6148:     {",
          "6149:         AutoCriticalSection autocs(GetCriticalSection());",
          "6151:         void * pageAddr = GetPageAddr(address);",
          "6152:         RangeMap * rangeMap = nullptr;",
          "6153:         if (jitPageAddrToFuncRangeMap && jitPageAddrToFuncRangeMap->TryGetValue(pageAddr, &rangeMap))",
          "6154:         {",
          "6155:             if (rangeMap->MapUntil(",
          "6156:                 [&](void* key, uint value) {",
          "6157:                 return (key <= address && (uintptr_t)address < ((uintptr_t)key + value));",
          "6158:             }))",
          "6159:             {",
          "6160:                 return true;",
          "6161:             }",
          "6162:         }",
          "6164:         return largeJitFuncToSizeMap && largeJitFuncToSizeMap->MapUntil(",
          "6165:             [&](void *key, uint value) {",
          "6166:             return (key <= address && (uintptr_t)address < ((uintptr_t)key + value));",
          "6167:         });",
          "6168:     }",
          "6170:     JITPageAddrToFuncRangeCache::JITPageAddrToFuncRangeMap * JITPageAddrToFuncRangeCache::GetJITPageAddrToFuncRangeMap()",
          "6171:     {",
          "6172:         return jitPageAddrToFuncRangeMap;",
          "6173:     }",
          "6175:     JITPageAddrToFuncRangeCache::LargeJITFuncAddrToSizeMap * JITPageAddrToFuncRangeCache::GetLargeJITFuncAddrToSizeMap()",
          "6176:     {",
          "6177:         return largeJitFuncToSizeMap;",
          "6178:     }",
          "6180: } // End namespace Js",
          "",
          "---------------"
        ],
        "lib/Runtime/Base/ScriptContext.h||lib/Runtime/Base/ScriptContext.h": [
          "File: lib/Runtime/Base/ScriptContext.h -> lib/Runtime/Base/ScriptContext.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "5: #pragma once",
          "7: #if defined(_WIN32) && defined(ENABLE_SCRIPT_PROFILING)",
          "8: #include \"activprof.h\"",
          "9: #endif",
          "11: #if DBG || ENABLE_REGEX_CONFIG_OPTIONS || defined(PROFILE_STRINGS)",
          "12: #define NEED_MISC_ALLOCATOR",
          "13: #endif",
          "15: #define BuiltInFunctionsScriptId 0",
          "17: using namespace PlatformAgnostic;",
          "19: class NativeCodeGenerator;",
          "20: class BackgroundParser;",
          "21: struct IActiveScriptDirect;",
          "22: #ifdef ENABLE_BASIC_TELEMETRY",
          "23: class ScriptContextTelemetry;",
          "24: #endif",
          "25: namespace Js",
          "26: {",
          "27:     class ScriptContext;",
          "28:     class ScriptEditQuery;",
          "29:     class MutationBreakpoint;",
          "30:     class StringProfiler;",
          "31:     class DebugContext;",
          "32:     struct HaltCallback;",
          "33:     struct DebuggerOptionsCallback;",
          "34:     class ModuleRecordBase;",
          "35: }",
          "39: class SRCINFO",
          "40: {",
          "44: public:",
          "45:     Field(SourceContextInfo *) sourceContextInfo;",
          "46:     Field(ULONG) dlnHost;             // Line number passed to ParseScriptText",
          "47:     Field(ULONG) ulColumnHost;        // Column number on the line where the parse script text started",
          "48:     Field(ULONG) lnMinHost;           // Line offset of first host-supplied line",
          "49:     Field(ULONG) ichMinHost;          // Range of host supplied characters",
          "50:     Field(ULONG) ichLimHost;",
          "51:     Field(ULONG) ulCharOffset;        // Char offset of the source text relative to the document. (Populated using IActiveScriptContext)",
          "52:     Field(Js::ModuleID) moduleID;",
          "53:     Field(ULONG) grfsi;",
          "55:     static SRCINFO* Copy(Recycler* recycler, const SRCINFO* srcInfo)",
          "56:     {",
          "57:         SRCINFO* copySrcInfo = RecyclerNew(recycler, SRCINFO, *srcInfo);",
          "58:         return copySrcInfo;",
          "59:     }",
          "61:     SRCINFO()",
          "62:     {",
          "63:     }",
          "64:     SRCINFO(const SRCINFO& other)",
          "65:         :sourceContextInfo(other.sourceContextInfo),",
          "66:         dlnHost(other.dlnHost),",
          "67:         ulColumnHost(other.ulColumnHost),",
          "68:         lnMinHost(other.lnMinHost),",
          "69:         ichMinHost(other.ichMinHost),",
          "70:         ichLimHost(other.ichLimHost),",
          "71:         ulCharOffset(other.ulCharOffset),",
          "72:         moduleID(other.moduleID),",
          "73:         grfsi(other.grfsi)",
          "74:     {",
          "75:     }",
          "76:     SRCINFO(",
          "77:         SourceContextInfo*sourceContextInfo,",
          "78:         ULONG dlnHost,",
          "79:         ULONG ulColumnHost,",
          "80:         ULONG lnMinHost,",
          "81:         ULONG ichMinHost,",
          "82:         ULONG ichLimHost,",
          "83:         ULONG ulCharOffset,",
          "84:         Js::ModuleID moduleID,",
          "85:         ULONG grfsi",
          "86:     ):sourceContextInfo(sourceContextInfo),",
          "87:         dlnHost(dlnHost),",
          "88:         ulColumnHost(ulColumnHost),",
          "89:         lnMinHost(lnMinHost),",
          "90:         ichMinHost(ichMinHost),",
          "91:         ichLimHost(ichLimHost),",
          "92:         ulCharOffset(ulCharOffset),",
          "93:         moduleID(moduleID),",
          "94:         grfsi(grfsi)",
          "95:     {",
          "96:     }",
          "97: };",
          "99: struct CustomExternalObjectOperations",
          "100: {",
          "101:     size_t offsetOfOperationsUsage;",
          "102:     DWORD operationFlagEquals;",
          "103:     DWORD operationFlagStrictEquals;",
          "104: };",
          "106: enum ExternalJitData",
          "107: {",
          "108:     ExternalJitData_CustomExternalObjectOperations",
          "109: };",
          "111: enum LoadScriptFlag",
          "112: {",
          "113:     LoadScriptFlag_None         = 0x0,",
          "114:     LoadScriptFlag_Expression   = 0x1,                  // the script returns a value.",
          "115:     LoadScriptFlag_disableDeferredParse = 0x2,          // do not defer-parse the code.",
          "116:     LoadScriptFlag_isByteCodeBufferForLibrary = 0x4,    // for bytecode buffer",
          "117:     LoadScriptFlag_disableAsmJs = 0x8,                  // disable parse as asmjs. The code is not conform to asmjs requirement.",
          "118:     LoadScriptFlag_Module = 0x10,                       // input script is module code.",
          "119:     LoadScriptFlag_isFunction = 0x20,                   // input script is in a function scope, not global code.",
          "120:     LoadScriptFlag_Utf8Source = 0x40,                   // input buffer is utf8 encoded.",
          "121:     LoadScriptFlag_LibraryCode = 0x80,                  // for debugger, indicating 'not my code'",
          "122:     LoadScriptFlag_ExternalArrayBuffer = 0x100          // for ExternalArrayBuffer",
          "123: };",
          "125: class HostScriptContext",
          "126: {",
          "127: public:",
          "128:     HostScriptContext(Js::ScriptContext* inScriptContext) { this->scriptContext = inScriptContext; }",
          "129:     virtual void Delete() = 0;",
          "130:     virtual HRESULT GetPreviousHostScriptContext(__deref_out HostScriptContext** ppUnkCaller) = 0;",
          "131:     virtual HRESULT PushHostScriptContext() = 0;",
          "132:     virtual void PopHostScriptContext() = 0;",
          "134:     virtual HRESULT SetCaller(IUnknown *punkNew, IUnknown **ppunkPrev) = 0;",
          "135:     virtual HRESULT GetDispatchExCaller(__deref_out void** dispatchExCaller) = 0;",
          "136:     virtual void ReleaseDispatchExCaller(__in void* dispatchExCaler) = 0;",
          "137:     virtual Js::ModuleRoot * GetModuleRoot(int moduleID) = 0;",
          "138:     virtual HRESULT CheckCrossDomainScriptContext(__in Js::ScriptContext* scriptContext) = 0;",
          "140:     virtual HRESULT GetHostContextUrl(__in DWORD_PTR hostSourceContext, __out BSTR& pUrl) = 0;",
          "141:     virtual BOOL HasCaller() = 0;",
          "142:     virtual void CleanDynamicCodeCache() = 0;",
          "143:     virtual HRESULT VerifyDOMSecurity(Js::ScriptContext* targetContext, Js::Var obj) = 0;",
          "145:     virtual HRESULT CheckEvalRestriction() = 0;",
          "146:     virtual HRESULT HostExceptionFromHRESULT(HRESULT hr, Js::Var* outError) = 0;",
          "148:     virtual HRESULT GetExternalJitData(ExternalJitData id, void *data) = 0;",
          "149:     virtual HRESULT SetDispatchInvoke(Js::JavascriptMethod dispatchInvoke) = 0;",
          "150:     virtual HRESULT ArrayBufferFromExternalObject(__in Js::RecyclableObject *obj,",
          "151:         __out Js::ArrayBuffer **ppArrayBuffer) = 0;",
          "152:     virtual Js::JavascriptError* CreateWinRTError(IErrorInfo* perrinfo, Js::RestrictedErrorStrings * proerrstr) = 0;",
          "153:     virtual HRESULT EnqueuePromiseTask(Js::Var varTask) = 0;",
          "155:     virtual HRESULT FetchImportedModule(Js::ModuleRecordBase* referencingModule, LPCOLESTR specifier, Js::ModuleRecordBase** dependentModuleRecord) = 0;",
          "156:     virtual HRESULT NotifyHostAboutModuleReady(Js::ModuleRecordBase* referencingModule, Js::Var exceptionVar) = 0;",
          "158:     Js::ScriptContext* GetScriptContext() { return scriptContext; }",
          "160:     virtual bool SetCrossSiteForFunctionType(Js::JavascriptFunction * function) = 0;",
          "161: #if DBG_DUMP || defined(PROFILE_EXEC) || defined(PROFILE_MEM)",
          "162:     virtual void EnsureParentInfo(Js::ScriptContext* scriptContext = NULL) = 0;",
          "163: #endif",
          "164: #if DBG",
          "165:     virtual bool IsHostCrossSiteThunk(Js::JavascriptMethod address) = 0;",
          "166: #endif",
          "167: private:",
          "168:     Js::ScriptContext* scriptContext;",
          "169: };",
          "171: #if ENABLE_TTD",
          "173: class HostScriptContextCallbackFunctor",
          "174: {",
          "175: public:",
          "176:     FinalizableObject* HostData;",
          "177:     void(*pfOnScriptLoadCallback)(FinalizableObject* hostData, Js::JavascriptFunction* scriptFunction, Js::Utf8SourceInfo* utf8SourceInfo, CompileScriptException* compileException);",
          "179:     HostScriptContextCallbackFunctor()",
          "180:         : HostData(nullptr), pfOnScriptLoadCallback(nullptr)",
          "181:     {",
          "182:         ;",
          "183:     }",
          "185:     HostScriptContextCallbackFunctor(FinalizableObject* callbackData, void(*pfcallbackOnScriptLoad)(FinalizableObject* hostData, Js::JavascriptFunction* scriptFunction, Js::Utf8SourceInfo* utf8SourceInfo, CompileScriptException* compileException))",
          "186:         : HostData(callbackData), pfOnScriptLoadCallback(pfcallbackOnScriptLoad)",
          "187:     {",
          "188:         ;",
          "189:     }",
          "190: };",
          "191: #endif",
          "193: namespace Js",
          "194: {",
          "196: #pragma pack(push, 1)",
          "197:     struct StackFrameInfo",
          "198:     {",
          "199:         StackFrameInfo() { }",
          "200:         StackFrameInfo(DWORD_PTR _scriptContextID",
          "201:             , UINT32 _sourceLocationLineNumber",
          "202:             , UINT32 _sourceLocationColumnNumber",
          "203:             , UINT32 _methodIDOrNameIndex",
          "204:             , UINT8 _isFrameIndex)",
          "205:             : scriptContextID(_scriptContextID)",
          "206:             , sourceLocationLineNumber(_sourceLocationLineNumber)",
          "207:             , sourceLocationColumnNumber(_sourceLocationColumnNumber)",
          "208:             , methodIDOrNameIndex(_methodIDOrNameIndex)",
          "209:             , isFrameIndex(_isFrameIndex)",
          "210:         { }",
          "212:         DWORD_PTR scriptContextID;",
          "213:         UINT32 sourceLocationLineNumber;",
          "214:         UINT32 sourceLocationColumnNumber;",
          "215:         UINT32 methodIDOrNameIndex;",
          "216:         UINT8  isFrameIndex;",
          "217:     };",
          "218: #pragma pack(pop)",
          "220: #ifdef ENABLE_PROJECTION",
          "221:     class ProjectionConfiguration",
          "222:     {",
          "223:     public:",
          "224:         ProjectionConfiguration() : targetVersion(0)",
          "225:         {",
          "226:         }",
          "228:         DWORD GetTargetVersion() const { return this->targetVersion; }",
          "229:         void SetTargetVersion(DWORD version) { this->targetVersion = version; }",
          "231:         bool IsTargetWindows8() const           { return this->targetVersion == NTDDI_WIN8; }",
          "232:         bool IsTargetWindowsBlueOrLater() const { return this->targetVersion >= NTDDI_WINBLUE; }",
          "234:     private:",
          "235:         DWORD targetVersion;",
          "236:     };",
          "237: #endif // ENABLE_PROJECTION",
          "239:     class ScriptConfiguration",
          "240:     {",
          "241:     public:",
          "242:         ScriptConfiguration(const ThreadConfiguration * const threadConfig, const bool isOptimizedForManyInstances) :",
          "243: #ifdef ENABLE_PROJECTION",
          "244:             HostType(Configuration::Global.flags.HostType),",
          "245:             WinRTConstructorAllowed(Configuration::Global.flags.WinRTConstructorAllowed),",
          "246: #endif",
          "247:             NoNative(Configuration::Global.flags.NoNative),",
          "248:             isOptimizedForManyInstances(isOptimizedForManyInstances),",
          "249:             threadConfig(threadConfig)",
          "250:         {",
          "251:         }",
          "254:         bool SupportsES3()                      const { return true; }",
          "255:         bool SupportsES3Extensions()            const {",
          "256: #ifdef ENABLE_PROJECTION",
          "257:             return HostType != HostTypeApplication;",
          "258: #else",
          "259:             return true;",
          "260: #endif",
          "261:         }",
          "263: #define FORWARD_THREAD_CONFIG(flag) inline bool flag() const { return threadConfig->flag(); }",
          "264: #define FLAG(threadFlag, globalFlag) FORWARD_THREAD_CONFIG(threadFlag)",
          "265: #define FLAG_RELEASE(threadFlag, globalFlag) FORWARD_THREAD_CONFIG(threadFlag)",
          "266: #include \"../Base/ThreadConfigFlagsList.h\"",
          "267: #undef FLAG_RELEASE",
          "268: #undef FLAG",
          "269: #undef FORWARD_THREAD_CONFIG",
          "271:         bool SupportsCollectGarbage() const { return true; }",
          "273:         void ForceNoNative() { this->NoNative = true; }",
          "274:         void ForceNative() { this->NoNative = false; }",
          "275:         bool IsNoNative() const { return this->NoNative; }",
          "277:         void SetCanOptimizeGlobalLookupFlag(BOOL f){ this->fCanOptimizeGlobalLookup = f;}",
          "278:         BOOL CanOptimizeGlobalLookup() const { return this->fCanOptimizeGlobalLookup;}",
          "279:         bool IsOptimizedForManyInstances() const { return isOptimizedForManyInstances; }",
          "280:         void CopyFrom(ScriptConfiguration& other)",
          "281:         {",
          "282:             this->NoNative = other.NoNative;",
          "283:             this->fCanOptimizeGlobalLookup = other.fCanOptimizeGlobalLookup;",
          "284: #ifdef ENABLE_PROJECTION",
          "285:             this->HostType = other.HostType;",
          "286:             this->WinRTConstructorAllowed = other.WinRTConstructorAllowed;",
          "287:             this->projectionConfiguration = other.projectionConfiguration;",
          "288: #endif",
          "289:         }",
          "291: #ifdef ENABLE_PROJECTION",
          "292:         Number GetHostType() const    // Returns one of enum HostType values (see ConfigFlagsTable.h).",
          "293:         {",
          "294:             AssertMsg(this->HostType >= HostTypeMin && this->HostType <= HostTypeMax, \"HostType value is out of valid range.\");",
          "295:             return this->HostType;",
          "296:         }",
          "298:         ProjectionConfiguration const * GetProjectionConfig() const",
          "299:         {",
          "300:             return &projectionConfiguration;",
          "301:         }",
          "302:         void SetHostType(int32 hostType) { this->HostType = hostType; }",
          "303:         void SetWinRTConstructorAllowed(bool allowed) { this->WinRTConstructorAllowed = allowed; }",
          "304:         void SetProjectionTargetVersion(DWORD version)",
          "305:         {",
          "306:             projectionConfiguration.SetTargetVersion(version);",
          "307:         }",
          "308:         bool IsWinRTEnabled()           const { return (GetHostType() == Js::HostTypeApplication) || (GetHostType() == Js::HostTypeWebview); }",
          "310:         bool IsWinRTConstructorAllowed() const { return (GetHostType() != Js::HostTypeWebview) || this->WinRTConstructorAllowed; }",
          "311: #endif",
          "312:     private:",
          "315:         bool NoNative;",
          "316:         BOOL fCanOptimizeGlobalLookup;",
          "317:         const bool isOptimizedForManyInstances;",
          "318:         const ThreadConfiguration * const threadConfig;",
          "320: #ifdef ENABLE_PROJECTION",
          "321:         Number HostType;    // One of enum HostType values (see ConfigFlagsTable.h).",
          "322:         bool WinRTConstructorAllowed;  // whether allow constructor in webview host type. Also note that this is not a security feature.",
          "323:         ProjectionConfiguration projectionConfiguration;",
          "324: #endif",
          "325:     };",
          "327:     struct ScriptEntryExitRecord",
          "328:     {",
          "329:         bool hasCaller : 1;",
          "330:         bool hasReentered : 1;",
          "331: #if DBG_DUMP",
          "332:         bool isCallRoot : 1;",
          "333: #endif",
          "334: #if DBG || defined(PROFILE_EXEC)",
          "335:         bool leaveForHost : 1;",
          "336: #endif",
          "337: #if DBG",
          "338:         bool leaveForAsyncHostOperation : 1;",
          "339: #endif",
          "340: #ifdef CHECK_STACKWALK_EXCEPTION",
          "341:         bool ignoreStackWalkException: 1;",
          "342: #endif",
          "343:         Js::ImplicitCallFlags savedImplicitCallFlags;",
          "345:         void * returnAddrOfScriptEntryFunction;",
          "346:         void * frameIdOfScriptExitFunction; // the frameAddres in x86, the return address in amd64/arm_soc",
          "347:         ScriptContext * scriptContext;",
          "348:         struct ScriptEntryExitRecord * next;",
          "350: #if defined(_M_IX86) && defined(DBG)",
          "351:         void * scriptEntryFS0;",
          "352: #endif",
          "353: #ifdef EXCEPTION_CHECK",
          "354:         ExceptionType handledExceptionType;",
          "355: #endif",
          "356:     };",
          "358:     struct PropertyStringMap",
          "359:     {",
          "360:         PropertyString* strLen2[80];",
          "362:         inline static uint PStrMapIndex(char16 ch)",
          "363:         {",
          "364:             Assert(ch >= '0' && ch <= 'z');",
          "365:             return ch - '0';",
          "366:         }",
          "367:     };",
          "374:     class JITPageAddrToFuncRangeCache",
          "375:     {",
          "376:     public:",
          "377:         typedef JsUtil::BaseDictionary<void *, uint, HeapAllocator> RangeMap;",
          "378:         typedef JsUtil::BaseDictionary<void *, RangeMap*, HeapAllocator> JITPageAddrToFuncRangeMap;",
          "379:         typedef JsUtil::BaseDictionary<void *, uint, HeapAllocator> LargeJITFuncAddrToSizeMap;",
          "381:     private:",
          "382:         JITPageAddrToFuncRangeMap * jitPageAddrToFuncRangeMap;",
          "383:         LargeJITFuncAddrToSizeMap * largeJitFuncToSizeMap;",
          "385:         static CriticalSection cs;",
          "387:     public:",
          "388:         JITPageAddrToFuncRangeCache() :jitPageAddrToFuncRangeMap(nullptr), largeJitFuncToSizeMap(nullptr) {}",
          "389:         ~JITPageAddrToFuncRangeCache()",
          "390:         {",
          "391:             ClearCache();",
          "392:         }",
          "393:         void ClearCache();",
          "394:         void AddFuncRange(void * address, uint bytes);",
          "395:         void RemoveFuncRange(void * address);",
          "396:         void * GetPageAddr(void * address);",
          "397:         bool IsNativeAddr(void * address);",
          "398:         JITPageAddrToFuncRangeMap * GetJITPageAddrToFuncRangeMap();",
          "399:         LargeJITFuncAddrToSizeMap * GetLargeJITFuncAddrToSizeMap();",
          "400:         static CriticalSection * GetCriticalSection() { return &cs; }",
          "401:     };",
          "403:     class ScriptContext : public ScriptContextBase, public ScriptContextInfo",
          "404:     {",
          "405:         friend class LowererMD;",
          "406:         friend class RemoteScriptContext;",
          "407:         friend class GlobalObject; // InitializeCache",
          "408:         friend class SourceTextModuleRecord; // for module bytecode gen.",
          "410:     public:",
          "411:         static DWORD GetThreadContextOffset() { return offsetof(ScriptContext, threadContext); }",
          "412:         static DWORD GetOptimizationOverridesOffset() { return offsetof(ScriptContext, optimizationOverrides); }",
          "413:         static DWORD GetRecyclerOffset() { return offsetof(ScriptContext, recycler); }",
          "414:         static DWORD GetNumberAllocatorOffset() { return offsetof(ScriptContext, numberAllocator); }",
          "416:         JITPageAddrToFuncRangeCache * GetJitFuncRangeCache();",
          "417:         JITPageAddrToFuncRangeCache * jitFuncRangeCache;",
          "419:         ScriptContext *next;",
          "420:         ScriptContext *prev;",
          "421:         bool IsRegistered() { return next != nullptr || prev != nullptr || threadContext->GetScriptContextList() == this; }",
          "422:         union",
          "423:         {",
          "424:             int64 int64Val; // stores the double & float result for Asm interpreter",
          "425:             double dbVal; // stores the double & float result for Asm interpreter",
          "426:             AsmJsSIMDValue simdVal; // stores raw simd result for Asm interpreter",
          "427:         } asmJsReturnValue;",
          "428:         static DWORD GetAsmJsReturnValueOffset() { return offsetof(ScriptContext, asmJsReturnValue); }",
          "430:         ScriptContextOptimizationOverrideInfo optimizationOverrides;",
          "432:         Js::JavascriptMethod CurrentThunk;",
          "433:         Js::JavascriptMethod CurrentCrossSiteThunk;",
          "434:         Js::JavascriptMethod DeferredParsingThunk;",
          "435:         Js::JavascriptMethod DeferredDeserializationThunk;",
          "436:         Js::JavascriptMethod DispatchDefaultInvoke;",
          "437:         Js::JavascriptMethod DispatchProfileInvoke;",
          "439: #ifdef ENABLE_SCRIPT_DEBUGGING",
          "440:         typedef HRESULT (*GetDocumentContextFunction)(",
          "441:             ScriptContext *pContext,",
          "442:             Js::FunctionBody *pFunctionBody,",
          "443:             IDebugDocumentContext **ppDebugDocumentContext);",
          "444:         GetDocumentContextFunction GetDocumentContext;",
          "445: #endif // ENABLE_SCRIPT_DEBUGGING",
          "447: #ifdef ENABLE_SCRIPT_PROFILING",
          "448:         typedef HRESULT (*CleanupDocumentContextFunction)(ScriptContext *pContext);",
          "449:         CleanupDocumentContextFunction CleanupDocumentContext;",
          "450: #endif",
          "452:         const ScriptContextBase* GetScriptContextBase() const { return static_cast<const ScriptContextBase*>(this); }",
          "454:         void RedeferFunctionBodies(ActiveFunctionSet *pActive, uint inactiveThreshold);",
          "455:         bool DoUndeferGlobalFunctions() const;",
          "457:         bool IsUndeclBlockVar(Var var) const { return this->javascriptLibrary->IsUndeclBlockVar(var); }",
          "459:         void TrackPid(const PropertyRecord* propertyRecord);",
          "460:         void TrackPid(PropertyId propertyId);",
          "462:         bool IsTrackedPropertyId(Js::PropertyId propertyId);",
          "463:         void InvalidateHostObjects()",
          "464:         {",
          "465:             AssertMsg(!isClosed, \"Host Object invalidation should occur before the engine is fully closed. Figure our how isClosed got set beforehand.\");",
          "466:             isInvalidatedForHostObjects = true;",
          "467:         }",
          "468:         bool IsInvalidatedForHostObjects()",
          "469:         {",
          "470:             return isInvalidatedForHostObjects;",
          "471:         }",
          "473: #if ENABLE_NATIVE_CODEGEN",
          "474:         void InitializeRemoteScriptContext();",
          "475: #endif",
          "477: #ifdef ENABLE_JS_ETW",
          "478:         void EmitStackTraceEvent(__in UINT64 operationID, __in USHORT maxFrameCount, bool emitV2AsyncStackEvent);",
          "479: #endif",
          "481:         void SetIsDiagnosticsScriptContext(bool set) { this->isDiagnosticsScriptContext = set; }",
          "482:         bool IsDiagnosticsScriptContext() const { return this->isDiagnosticsScriptContext; }",
          "484:         bool IsScriptContextInNonDebugMode() const;",
          "485:         bool IsScriptContextInDebugMode() const;",
          "486:         bool IsScriptContextInSourceRundownOrDebugMode() const;",
          "487:         bool IsRunningScript() const { return this->threadContext->GetScriptEntryExit() != nullptr; }",
          "489:         typedef JsUtil::List<RecyclerWeakReference<Utf8SourceInfo>*, Recycler, false, Js::WeakRefFreeListedRemovePolicy> CalleeSourceList;",
          "490:         RecyclerRootPtr<CalleeSourceList> calleeUtf8SourceInfoList;",
          "491:         void AddCalleeSourceInfoToList(Utf8SourceInfo* sourceInfo);",
          "492:         bool HaveCalleeSources() { return calleeUtf8SourceInfoList && !calleeUtf8SourceInfoList->Empty(); }",
          "494:         template<class TMapFunction>",
          "495:         void MapCalleeSources(TMapFunction map)",
          "496:         {",
          "497:             if (this->HaveCalleeSources())",
          "498:             {",
          "499:                 calleeUtf8SourceInfoList->Map([&](uint i, RecyclerWeakReference<Js::Utf8SourceInfo>* sourceInfoWeakRef)",
          "500:                 {",
          "501:                     if (calleeUtf8SourceInfoList->IsItemValid(i))",
          "502:                     {",
          "503:                         Js::Utf8SourceInfo* sourceInfo = sourceInfoWeakRef->Get();",
          "504:                         map(sourceInfo);",
          "505:                     }",
          "506:                 });",
          "507:             }",
          "508:             if (calleeUtf8SourceInfoList)",
          "509:             {",
          "510:                 calleeUtf8SourceInfoList.Unroot(this->GetRecycler());",
          "511:             }",
          "512:         }",
          "514: #ifdef ASMJS_PLAT",
          "515:         inline AsmJsCodeGenerator* GetAsmJsCodeGenerator() const{return asmJsCodeGenerator;}",
          "516:         AsmJsCodeGenerator* InitAsmJsCodeGenerator();",
          "517: #endif",
          "519:         bool IsExceptionWrapperForBuiltInsEnabled();",
          "520:         static bool IsExceptionWrapperForBuiltInsEnabled(ScriptContext* scriptContext);",
          "521:         static bool IsExceptionWrapperForHelpersEnabled(ScriptContext* scriptContext);",
          "522:         bool IsEnumerateNonUserFunctionsOnly() const { return m_enumerateNonUserFunctionsOnly; }",
          "523: #ifdef ENABLE_SCRIPT_PROFILING",
          "524:         bool IsTraceDomCall() const { return !!m_fTraceDomCall; }",
          "525: #elif defined(ENABLE_SCRIPT_DEBUGGING)",
          "526:         bool IsTraceDomCall() const { return false; }",
          "527: #endif",
          "529:         InlineCache * GetValueOfInlineCache() const { return valueOfInlineCache;}",
          "530:         InlineCache * GetToStringInlineCache() const { return toStringInlineCache; }",
          "532:     private:",
          "533:         PropertyStringMap* propertyStrings[80];",
          "535:         JavascriptFunction* GenerateRootFunction(ParseNodePtr parseTree, uint sourceIndex, Parser* parser, uint32 grfscr, CompileScriptException * pse, const char16 *rootDisplayName);",
          "537:         typedef void (*EventHandler)(ScriptContext *);",
          "538:         ScriptContext ** registeredPrototypeChainEnsuredToHaveOnlyWritableDataPropertiesScriptContext;",
          "540:         ArenaAllocator generalAllocator;",
          "541: #ifdef ENABLE_BASIC_TELEMETRY",
          "542:         ArenaAllocator telemetryAllocator;",
          "543: #endif",
          "545:         ArenaAllocator dynamicProfileInfoAllocator;",
          "546:         InlineCacheAllocator inlineCacheAllocator;",
          "547:         CacheAllocator isInstInlineCacheAllocator;",
          "548:         CacheAllocator forInCacheAllocator;",
          "550:         ArenaAllocator* interpreterArena;",
          "551:         ArenaAllocator* guestArena;",
          "553:         ArenaAllocator* diagnosticArena;",
          "555:         PSCRIPTCONTEXT_HANDLE m_remoteScriptContextAddr;",
          "557:         bool startupComplete; // Indicates if the heuristic startup phase for this script context is complete",
          "558:         bool isInvalidatedForHostObjects;  // Indicates that we've invalidate all objects in the host so stop calling them.",
          "559:         bool isEnumeratingRecyclerObjects; // Indicates this scriptContext is enumerating recycler objects. Used by recycler enumerating callbacks to filter out other unrelated scriptContexts.",
          "560:         bool m_enumerateNonUserFunctionsOnly; // Indicates that recycler enumeration callback will consider only non-user functions (which are built-ins, external, winrt etc).",
          "562:         ThreadContext* threadContext;",
          "563:         TypeId  directHostTypeId;",
          "565:         InlineCache * valueOfInlineCache;",
          "566:         InlineCache * toStringInlineCache;",
          "568:         typedef JsUtil::BaseHashSet<Js::PropertyId, ArenaAllocator> PropIdSetForConstProp;",
          "569:         PropIdSetForConstProp * intConstPropsOnGlobalObject;",
          "570:         PropIdSetForConstProp * intConstPropsOnGlobalUserObject;",
          "572:         void * firstInterpreterFrameReturnAddress;",
          "573: #ifdef SEPARATE_ARENA",
          "574:         ArenaAllocator sourceCodeAllocator;",
          "575:         ArenaAllocator regexAllocator;",
          "576: #endif",
          "577: #ifdef NEED_MISC_ALLOCATOR",
          "578:         ArenaAllocator miscAllocator;",
          "579: #endif",
          "581: #if DBG",
          "582:         JsUtil::BaseHashSet<void *, ArenaAllocator> bindRef;",
          "583:         int m_iProfileSession;",
          "584: #endif",
          "586: #ifdef PROFILE_EXEC",
          "587:         ScriptContextProfiler * profiler;",
          "588:         bool isProfilerCreated;",
          "589:         bool disableProfiler;",
          "590:         bool ensureParentInfo;",
          "592:         Profiler * CreateProfiler();",
          "593: #endif",
          "594: #ifdef PROFILE_MEM",
          "595:         bool profileMemoryDump;",
          "596: #endif",
          "597: #ifdef PROFILE_STRINGS",
          "598:         StringProfiler* stringProfiler;",
          "599: #endif",
          "602: public:",
          "603: #ifdef PROFILE_TYPES",
          "604:         int convertNullToSimpleCount;",
          "605:         int convertNullToSimpleDictionaryCount;",
          "606:         int convertNullToDictionaryCount;",
          "607:         int convertDeferredToDictionaryCount;",
          "608:         int convertDeferredToSimpleDictionaryCount;",
          "609:         int convertSimpleToDictionaryCount;",
          "610:         int convertSimpleToSimpleDictionaryCount;",
          "611:         int convertPathToDictionaryCount1;",
          "612:         int convertPathToDictionaryCount2;",
          "613:         int convertPathToDictionaryCount3;",
          "614:         int convertPathToDictionaryCount4;",
          "615:         int convertPathToSimpleDictionaryCount;",
          "616:         int convertSimplePathToPathCount;",
          "617:         int convertSimpleDictionaryToDictionaryCount;",
          "618:         int convertSimpleSharedDictionaryToNonSharedCount;",
          "619:         int convertSimpleSharedToNonSharedCount;",
          "620:         int simplePathTypeHandlerCount;",
          "621:         int pathTypeHandlerCount;",
          "622:         int promoteCount;",
          "623:         int cacheCount;",
          "624:         int branchCount;",
          "625:         int maxPathLength;",
          "626:         int typeCount[TypeIds_Limit];",
          "627:         int instanceCount[TypeIds_Limit];",
          "628: #endif",
          "631: #ifdef PROFILE_BAILOUT_RECORD_MEMORY",
          "632:         __int64 bailOutRecordBytes;",
          "633:         __int64 bailOutOffsetBytes;",
          "634:         __int64 codeSize;",
          "635: #endif",
          "637: #ifdef  PROFILE_OBJECT_LITERALS",
          "638:         int objectLiteralInstanceCount;",
          "639:         int objectLiteralPathCount;",
          "640:         int objectLiteralCount[TypePath::MaxPathTypeHandlerLength];",
          "641:         int objectLiteralSimpleDictionaryCount;",
          "642:         uint32 objectLiteralMaxLength;",
          "643:         int objectLiteralPromoteCount;",
          "644:         int objectLiteralCacheCount;",
          "645:         int objectLiteralBranchCount;",
          "646: #endif",
          "647: #if DBG_DUMP",
          "648:         uint byteCodeDataSize;",
          "649:         uint byteCodeAuxiliaryDataSize;",
          "650:         uint byteCodeAuxiliaryContextDataSize;",
          "651:         uint byteCodeHistogram[static_cast<uint>(OpCode::ByteCodeLast)];",
          "652:         uint32 forinCache;",
          "653:         uint32 forinNoCache;",
          "654: #endif",
          "655: #ifdef BGJIT_STATS",
          "656:         uint interpretedCount;",
          "657:         uint funcJITCount;",
          "658:         uint loopJITCount;",
          "659:         uint bytecodeJITCount;",
          "660:         uint interpretedCallsHighPri;",
          "661:         uint maxFuncInterpret;",
          "662:         uint jitCodeUsed;",
          "663:         uint funcJitCodeUsed;",
          "664:         uint speculativeJitCount;",
          "665: #endif",
          "667: #ifdef REJIT_STATS",
          "669:         typedef JsUtil::BaseDictionary<uint, uint, ArenaAllocator> BailoutStatsMap;",
          "671:         struct RejitStats",
          "672:         {",
          "673:             uint *m_rejitReasonCounts;",
          "674:             BailoutStatsMap* m_bailoutReasonCounts;",
          "676:             uint  m_totalRejits;",
          "677:             uint  m_totalBailouts;",
          "679:             RejitStats(ScriptContext *scriptContext) : m_totalRejits(0), m_totalBailouts(0)",
          "680:             {",
          "681:                 m_rejitReasonCounts = AnewArrayZ(scriptContext->GeneralAllocator(), uint, NumRejitReasons);",
          "682:                 m_bailoutReasonCounts = Anew(scriptContext->GeneralAllocator(), BailoutStatsMap, scriptContext->GeneralAllocator());",
          "683:             }",
          "684:         };",
          "686:         void LogDataForFunctionBody(Js::FunctionBody *body, uint idx, bool isRejit);",
          "688:         void LogRejit(Js::FunctionBody *body, uint reason);",
          "689:         void LogBailout(Js::FunctionBody *body, uint kind);",
          "692:         typedef JsUtil::WeaklyReferencedKeyDictionary<const Js::FunctionBody, RejitStats*> RejitStatsMap;",
          "693:         RejitStatsMap* rejitStatsMap;",
          "695:         BailoutStatsMap *bailoutReasonCounts;",
          "696:         uint *rejitReasonCounts;",
          "697: #endif",
          "698: #ifdef ENABLE_BASIC_TELEMETRY",
          "700:     private:",
          "701:         ScriptContextTelemetry* telemetry;",
          "702:     public:",
          "703:         ScriptContextTelemetry& GetTelemetry();",
          "704:         bool HasTelemetry();",
          "706: #endif",
          "707: #ifdef INLINE_CACHE_STATS",
          "710:         struct CacheData",
          "711:         {",
          "712:             uint hits;",
          "713:             uint misses;",
          "714:             uint collisions;",
          "715:             bool isGetCache;",
          "716:             Js::PropertyId propertyId;",
          "718:             CacheData() : hits(0), misses(0), collisions(0), isGetCache(false), propertyId(Js::PropertyIds::_none) { }",
          "719:         };",
          "722:         typedef JsUtil::BaseDictionary<const Js::PolymorphicInlineCache*, CacheData*, Recycler> CacheDataMap;",
          "723:         CacheDataMap *cacheDataMap;",
          "725:         void LogCacheUsage(Js::PolymorphicInlineCache *cache, bool isGet, Js::PropertyId propertyId, bool hit, bool collision);",
          "726: #endif",
          "728: #ifdef FIELD_ACCESS_STATS",
          "729:         typedef SList<FieldAccessStatsPtr, Recycler> FieldAccessStatsList;",
          "731:         struct FieldAccessStatsEntry",
          "732:         {",
          "733:             Field(RecyclerWeakReference<FunctionBody>*) functionBodyWeakRef;",
          "734:             Field(FieldAccessStatsList) stats;",
          "736:             FieldAccessStatsEntry(RecyclerWeakReference<FunctionBody>* functionBodyWeakRef, Recycler* recycler)",
          "737:                 : functionBodyWeakRef(functionBodyWeakRef), stats(recycler) {}",
          "738:         };",
          "740:         typedef JsUtil::BaseDictionary<uint, FieldAccessStatsEntry*, Recycler> FieldAccessStatsByFunctionNumberMap;",
          "742:         FieldAccessStatsByFunctionNumberMap* fieldAccessStatsByFunctionNumber;",
          "744:         void RecordFieldAccessStats(FunctionBody* functionBody, FieldAccessStatsPtr fieldAccessStats);",
          "745: #endif",
          "747: #ifdef MISSING_PROPERTY_STATS",
          "748:         int missingPropertyMisses;",
          "749:         int missingPropertyHits;",
          "750:         int missingPropertyCacheAttempts;",
          "752:         void RecordMissingPropertyMiss();",
          "753:         void RecordMissingPropertyHit();",
          "754:         void RecordMissingPropertyCacheAttempt();",
          "755: #endif",
          "757:         bool IsIntConstPropertyOnGlobalObject(Js::PropertyId propId);",
          "758:         void TrackIntConstPropertyOnGlobalObject(Js::PropertyId propId);",
          "759:         bool IsIntConstPropertyOnGlobalUserObject(Js::PropertyId propertyId);",
          "760:         void TrackIntConstPropertyOnGlobalUserObject(Js::PropertyId propertyId);",
          "762: private:",
          "766: #if ENABLE_REGEX_CONFIG_OPTIONS",
          "767:         UnifiedRegex::DebugWriter* regexDebugWriter;",
          "768:         UnifiedRegex::RegexStatsDatabase* regexStatsDatabase;",
          "769: #endif",
          "770:         UnifiedRegex::TrigramAlphabet* trigramAlphabet;",
          "771:         UnifiedRegex::RegexStacks *regexStacks;",
          "773:         JsUtil::Stack<Var>* operationStack;",
          "774:         Recycler* recycler;",
          "775:         RecyclerJavascriptNumberAllocator numberAllocator;",
          "777:         ScriptConfiguration config;",
          "778:         CharClassifier *charClassifier;",
          "781: #if ENABLE_NATIVE_CODEGEN",
          "782: #if DYNAMIC_INTERPRETER_THUNK",
          "783:         InterpreterThunkEmitter* interpreterThunkEmitter;",
          "784: #endif",
          "785:         BackgroundParser *backgroundParser;",
          "786: #ifdef ASMJS_PLAT",
          "787:         InterpreterThunkEmitter* asmJsInterpreterThunkEmitter;",
          "788:         AsmJsCodeGenerator* asmJsCodeGenerator;",
          "789:         typedef JsUtil::BaseDictionary<void *, SList<AsmJsScriptFunction *>*, ArenaAllocator> AsmFunctionMap;",
          "790:         AsmFunctionMap* asmJsEnvironmentMap;",
          "791:         ArenaAllocator* debugTransitionAlloc;",
          "792: #endif",
          "793:         NativeCodeGenerator* nativeCodeGen;",
          "794: #endif",
          "796:         DateTime::DaylightTimeHelper daylightTimeHelper;",
          "797:         DateTime::Utility dateTimeUtility;",
          "799: public:",
          "800:         inline const WCHAR *const GetStandardName(size_t *nameLength, DateTime::YMD *ymd = NULL)",
          "801:         {",
          "802:             return dateTimeUtility.GetStandardName(nameLength, ymd);",
          "803:         }",
          "805:         inline const WCHAR *const GetDaylightName(size_t *nameLength, DateTime::YMD *ymd = NULL)",
          "806:         {",
          "807:             return dateTimeUtility.GetDaylightName(nameLength, ymd);",
          "808:         }",
          "810: private:",
          "811:         HostScriptContext * hostScriptContext;",
          "812:         HaltCallback* scriptEngineHaltCallback;",
          "813:         EventHandler scriptStartEventHandler;",
          "814:         EventHandler scriptEndEventHandler;",
          "815: #ifdef FAULT_INJECTION",
          "816:         EventHandler disposeScriptByFaultInjectionEventHandler;",
          "817: #endif",
          "819:         JsUtil::BaseDictionary<uint, JavascriptString *, ArenaAllocator> integerStringMap;",
          "821:         double lastNumberToStringRadix10;",
          "822:         double lastUtcTimeFromStr;",
          "824: #if ENABLE_PROFILE_INFO",
          "825:         bool referencesSharedDynamicSourceContextInfo;",
          "826: #endif",
          "830:         bool isScriptContextActuallyClosed;",
          "831:         bool isFinalized;",
          "832:         bool isEvalRestricted;",
          "833: #if DBG",
          "834:         bool isInitialized;",
          "835:         bool isCloningGlobal;",
          "836: #endif",
          "837:         bool fastDOMenabled;",
          "838:         bool hasUsedInlineCache;",
          "839:         bool hasProtoOrStoreFieldInlineCache;",
          "840:         bool hasIsInstInlineCache;",
          "841:         bool deferredBody;",
          "842:         bool isPerformingNonreentrantWork;",
          "843:         bool isDiagnosticsScriptContext;   // mentions that current script context belongs to the diagnostics OM.",
          "845:         size_t sourceSize;",
          "847:         void CleanSourceListInternal(bool calledDuringMark);",
          "848:         typedef JsUtil::List<RecyclerWeakReference<Utf8SourceInfo>*, Recycler, false, Js::FreeListedRemovePolicy> SourceList;",
          "849:         RecyclerRootPtr<SourceList> sourceList;",
          "851: #ifdef ENABLE_SCRIPT_PROFILING",
          "852:         IActiveScriptProfilerHeapEnum* heapEnum;",
          "857:         IActiveScriptProfilerCallback *m_pProfileCallback;",
          "858:         BOOL m_fTraceFunctionCall;",
          "859:         BOOL m_fTraceNativeFunctionCall;",
          "860:         DWORD m_dwEventMask;",
          "862:         IActiveScriptProfilerCallback2 *m_pProfileCallback2;",
          "863:         BOOL m_fTraceDomCall;",
          "864:         BOOL m_inProfileCallback;",
          "865: #endif // ENABLE_SCRIPT_PROFILING",
          "873:         SListBase<JsUtil::IWeakReferenceDictionary*> weakReferenceDictionaryList;",
          "874:         bool isWeakReferenceDictionaryListCleared;",
          "876:         typedef void(*RaiseMessageToDebuggerFunctionType)(ScriptContext *, DEBUG_EVENT_INFO_TYPE, LPCWSTR, LPCWSTR);",
          "877:         RaiseMessageToDebuggerFunctionType raiseMessageToDebuggerFunctionType;",
          "879:         typedef void(*TransitionToDebugModeIfFirstSourceFn)(ScriptContext *, Utf8SourceInfo *);",
          "880:         TransitionToDebugModeIfFirstSourceFn transitionToDebugModeIfFirstSourceFn;",
          "882:         ScriptContext(ThreadContext* threadContext);",
          "883:         void InitializeAllocations();",
          "884:         void InitializePreGlobal();",
          "885:         void InitializePostGlobal();",
          "886:         void InitializeCache();",
          "888:         bool isDebugContextInitialized;",
          "891:         void EnsureSourceContextInfoMap();",
          "892:         void EnsureDynamicSourceContextInfoMap();",
          "894:         uint moduleSrcInfoCount;",
          "895: #ifdef RUNTIME_DATA_COLLECTION",
          "896:         time_t createTime;",
          "897: #endif",
          "898:         char16 const * url;",
          "900:         void PrintStats();",
          "901:         BOOL LeaveScriptStartCore(void * frameAddress, bool leaveForHost);",
          "903:         void InternalClose();",
          "905:         DebugContext* debugContext;",
          "906:         CriticalSection debugContextCloseCS;",
          "908:     public:",
          "909:         static const int kArrayMatchCh=72;",
          "910:         static const int kMaxArrayMatchIndex=8192;",
          "911:         short arrayMatchItems[kArrayMatchCh];",
          "912:         bool arrayMatchInit;",
          "914: #ifdef LEAK_REPORT",
          "915:         LeakReport::UrlRecord * urlRecord;",
          "916:         bool isRootTrackerScriptContext;",
          "917: #endif",
          "919:         DateTime::DaylightTimeHelper *GetDaylightTimeHelper() { return &daylightTimeHelper; }",
          "920:         DateTime::Utility *GetDateUtility() { return &dateTimeUtility; }",
          "922:         virtual bool IsClosed() const override { return isClosed; }",
          "923:         void SetIsClosed();",
          "925:         bool IsFinalized() const { return isFinalized; }",
          "926:         void SetIsFinalized() { isFinalized = true; }",
          "927:         bool IsActuallyClosed() const { return isScriptContextActuallyClosed; }",
          "928:         void SetEvalRestriction(bool set) { this->isEvalRestricted = set; }",
          "929:         bool IsEvalRestriction() const { return this->isEvalRestricted; }",
          "930: #if ENABLE_NATIVE_CODEGEN",
          "931:         bool IsClosedNativeCodeGenerator() const",
          "932:         {",
          "933:             return !nativeCodeGen || ::IsClosedNativeCodeGenerator(nativeCodeGen);",
          "934:         }",
          "935: #endif",
          "937:         void SetHasUsedInlineCache(bool value) { hasUsedInlineCache = value; }",
          "939:         void SetDirectHostTypeId(TypeId typeId) {directHostTypeId = typeId; }",
          "940:         TypeId GetDirectHostTypeId() const { return directHostTypeId; }",
          "942:         PSCRIPTCONTEXT_HANDLE GetRemoteScriptAddr(bool allowInitialize = true)",
          "943:         {",
          "944: #if ENABLE_OOP_NATIVE_CODEGEN",
          "945:             if (!m_remoteScriptContextAddr && allowInitialize)",
          "946:             {",
          "947:                 InitializeRemoteScriptContext();",
          "948:             }",
          "949: #endif",
          "950:             return m_remoteScriptContextAddr;",
          "951:         }",
          "953:         char16 const * GetUrl() const { return url; }",
          "954:         void SetUrl(BSTR bstr);",
          "955: #ifdef RUNTIME_DATA_COLLECTION",
          "956:         time_t GetCreateTime() const { return createTime; }",
          "957:         uint GetAllocId() const { return allocId; }",
          "958: #endif",
          "959:         void InitializeArrayMatch()",
          "960:         {",
          "961:             if (!arrayMatchInit)",
          "962:             {",
          "963:                 for (int i=0;i<kArrayMatchCh;i++)",
          "964:                 {",
          "965:                     arrayMatchItems[i]= -1;",
          "966:                 }",
          "967:                 arrayMatchInit=true;",
          "968:             }",
          "969:         }",
          "971: #ifdef HEAP_ENUMERATION_VALIDATION",
          "972:         bool IsInitialized() { return this->isInitialized; }",
          "973: #endif",
          "975:         bool IsDebugContextInitialized() const { return this->isDebugContextInitialized; }",
          "976:         DebugContext* GetDebugContext() const { return this->debugContext; }",
          "977:         CriticalSection* GetDebugContextCloseCS() { return &debugContextCloseCS; }",
          "979:         uint callCount;",
          "982:         DWORD webWorkerId;",
          "984:         static ScriptContext * New(ThreadContext * threadContext);",
          "985:         static void Delete(ScriptContext* scriptContext);",
          "987:         ~ScriptContext();",
          "989: #ifdef PROFILE_TYPES",
          "990:         void ProfileTypes();",
          "991: #endif",
          "993: #ifdef PROFILE_OBJECT_LITERALS",
          "994:         void ProfileObjectLiteral();",
          "995: #endif",
          "1000: #if ENABLE_REGEX_CONFIG_OPTIONS",
          "1001:         UnifiedRegex::RegexStatsDatabase* GetRegexStatsDatabase();",
          "1002:         UnifiedRegex::DebugWriter* GetRegexDebugWriter();",
          "1003: #endif",
          "1004:         RegexPatternMruMap* GetDynamicRegexMap() const;",
          "1006:         UnifiedRegex::TrigramAlphabet* GetTrigramAlphabet() { return trigramAlphabet; }",
          "1008:         void SetTrigramAlphabet(UnifiedRegex::TrigramAlphabet * trigramAlphabet);",
          "1010:         UnifiedRegex::RegexStacks *RegexStacks();",
          "1011:         UnifiedRegex::RegexStacks *AllocRegexStacks();",
          "1012:         UnifiedRegex::RegexStacks *SaveRegexStacks();",
          "1013:         void RestoreRegexStacks(UnifiedRegex::RegexStacks *const contStack);",
          "1015:         void InitializeGlobalObject();",
          "1016:         bool IsIntlEnabled();",
          "1017:         JavascriptLibrary* GetLibrary() const { return javascriptLibrary; }",
          "1018:         Js::Cache* Cache() const{ return &this->javascriptLibrary->cache; }",
          "1019:         const JavascriptLibraryBase* GetLibraryBase() const { return javascriptLibrary->GetLibraryBase(); }",
          "1020: #if DBG",
          "1021:         BOOL IsCloningGlobal() const { return isCloningGlobal;}",
          "1022: #endif",
          "1023:         void PushObject(Var object);",
          "1024:         Var PopObject();",
          "1025:         BOOL CheckObject(Var object);",
          "1027:         inline bool IsHeapEnumInProgress() { return GetRecycler()->IsHeapEnumInProgress(); }",
          "1029:         bool IsInterpreted() { return config.IsNoNative(); }",
          "1030:         void ForceNoNative() { config.ForceNoNative(); }",
          "1031:         void ForceNative() { config.ForceNative(); }",
          "1032:         ScriptConfiguration const * GetConfig(void) const { return &config; }",
          "1033:         CharClassifier const * GetCharClassifier(void) const;",
          "1035:         ThreadContext * GetThreadContext() const { return threadContext; }",
          "1037:         static const int MaxEvalSourceSize = 400;",
          "1039:         bool IsInEvalMap(FastEvalMapString const& key, BOOL isIndirect, ScriptFunction **ppFuncScript);",
          "1040:         void AddToEvalMap(FastEvalMapString const& key, BOOL isIndirect, ScriptFunction *pFuncScript);",
          "1042:         template <typename TCacheType>",
          "1043:         void CleanDynamicFunctionCache(TCacheType* cacheType);",
          "1044:         void CleanEvalMapCache(Js::EvalCacheTopLevelDictionary * cacheType);",
          "1046:         template <class TDelegate>",
          "1047:         void MapFunction(TDelegate mapper);",
          "1049:         template <class TDelegate>",
          "1050:         FunctionBody* FindFunction(TDelegate predicate);",
          "1052:         inline bool EnableEvalMapCleanup() { return CONFIG_FLAG(EnableEvalMapCleanup); };",
          "1053:         uint GetNextSourceContextId();",
          "1055:         bool IsInNewFunctionMap(EvalMapString const& key, FunctionInfo **ppFuncInfo);",
          "1056:         void AddToNewFunctionMap(EvalMapString const& key, FunctionInfo *pFuncInfo);",
          "1058:         SourceContextInfo * GetSourceContextInfo(DWORD_PTR hostSourceContext, IActiveScriptDataCache* profileDataCache);",
          "1059:         SourceContextInfo * GetSourceContextInfo(uint hash);",
          "1060:         SourceContextInfo * CreateSourceContextInfo(uint hash, DWORD_PTR hostSourceContext);",
          "1061:         SourceContextInfo * CreateSourceContextInfo(DWORD_PTR hostSourceContext, char16 const * url, size_t len,",
          "1062:             IActiveScriptDataCache* profileDataCache, char16 const * sourceMapUrl = nullptr, size_t sourceMapUrlLen = 0);",
          "1064: #if defined(LEAK_REPORT) || defined(CHECK_MEMORY_LEAK)",
          "1065:         void ClearSourceContextInfoMaps()",
          "1066:         {",
          "1067: #if ENABLE_PROFILE_INFO",
          "1068:               this->referencesSharedDynamicSourceContextInfo = false;",
          "1069: #endif",
          "1070:         }",
          "1071: #endif",
          "1073: #if ENABLE_PROFILE_INFO",
          "1074: #if DBG_DUMP || defined(DYNAMIC_PROFILE_STORAGE) || defined(RUNTIME_DATA_COLLECTION)",
          "1075:         void ClearDynamicProfileList()",
          "1076:         {",
          "1077:             if (this->Cache()->profileInfoList)",
          "1078:             {",
          "1079:                 this->Cache()->profileInfoList->Reset();",
          "1080:                 this->Cache()->profileInfoList = nullptr;",
          "1081:             }",
          "1082:         }",
          "1084:         DynamicProfileInfoList * GetProfileInfoList() { return this->Cache()->profileInfoList; }",
          "1085: #endif",
          "1086: #endif",
          "1088:         SRCINFO const * GetModuleSrcInfo(Js::ModuleID moduleID);",
          "1089:         SourceContextInfoMap* GetSourceContextInfoMap()",
          "1090:         {",
          "1091:             return this->Cache()->sourceContextInfoMap;",
          "1092:         }",
          "1093:         DynamicSourceContextInfoMap* GetDynamicSourceContextInfoMap()",
          "1094:         {",
          "1095:             return this->Cache()->dynamicSourceContextInfoMap;",
          "1096:         }",
          "1098: #if ENABLE_TTD",
          "1100:         HostScriptContextCallbackFunctor TTDHostCallbackFunctor;",
          "1103:         TTD_LOG_PTR_ID ScriptContextLogTag;",
          "1106:         TTD::RuntimeContextInfo* TTDWellKnownInfo;",
          "1109:         TTD::ScriptContextTTD* TTDContextInfo;",
          "1112:         bool TTDSnapshotOrInflateInProgress;",
          "1115:         bool IsTTDSnapshotOrInflateInProgress() const { return this->TTDSnapshotOrInflateInProgress; }",
          "1118:         bool TTDRecordOrReplayModeEnabled;",
          "1119:         bool TTDRecordModeEnabled;",
          "1120:         bool TTDReplayModeEnabled;",
          "1122:         bool TTDShouldPerformRecordOrReplayAction;",
          "1123:         bool TTDShouldPerformRecordAction;",
          "1124:         bool TTDShouldPerformReplayAction;",
          "1126:         bool TTDShouldPerformDebuggerAction;",
          "1127:         bool TTDShouldSuppressGetterInvocationForDebuggerEvaluation;",
          "1130:         bool IsTTDRecordOrReplayModeEnabled() const { return this->TTDRecordOrReplayModeEnabled; }",
          "1133:         bool IsTTDRecordModeEnabled() const { return this->TTDRecordModeEnabled; }",
          "1136:         bool IsTTDReplayModeEnabled() const { return this->TTDReplayModeEnabled; }",
          "1139:         bool ShouldPerformRecordOrReplayAction() const { return this->TTDShouldPerformRecordOrReplayAction; }",
          "1142:         bool ShouldPerformRecordAction() const { return this->TTDShouldPerformRecordAction; }",
          "1145:         bool ShouldPerformReplayAction() const { return this->TTDShouldPerformReplayAction; }",
          "1148:         bool ShouldPerformDebuggerAction() const { return this->TTDShouldPerformDebuggerAction; }",
          "1151:         bool ShouldSuppressGetterInvocationForDebuggerEvaluation() const { return this->TTDShouldSuppressGetterInvocationForDebuggerEvaluation; }",
          "1157:         void InitializeCoreImage_TTD();",
          "1158: #endif",
          "1160:         void SetFirstInterpreterFrameReturnAddress(void * returnAddress) { firstInterpreterFrameReturnAddress = returnAddress;}",
          "1161:         void *GetFirstInterpreterFrameReturnAddress() { return firstInterpreterFrameReturnAddress;}",
          "1163:         void CleanupWeakReferenceDictionaries();",
          "1165:         void Initialize();",
          "1166:         bool Close(bool inDestructor);",
          "1167:         void MarkForClose();",
          "1168: #ifdef ENABLE_PROJECTION",
          "1169:         void SetHostType(int32 hostType) { config.SetHostType(hostType); }",
          "1170:         void SetWinRTConstructorAllowed(bool allowed) { config.SetWinRTConstructorAllowed(allowed); }",
          "1171:         void SetProjectionTargetVersion(DWORD version) { config.SetProjectionTargetVersion(version); }",
          "1172: #endif",
          "1173:         void SetCanOptimizeGlobalLookupFlag(BOOL f){ config.SetCanOptimizeGlobalLookupFlag(f);}",
          "1174:         BOOL CanOptimizeGlobalLookup(){ return config.CanOptimizeGlobalLookup();}",
          "1176:         bool IsFastDOMEnabled() { return fastDOMenabled; }",
          "1177:         void SetFastDOMenabled();",
          "1178:         BOOL VerifyAlive(BOOL isJSFunction = FALSE, ScriptContext* requestScriptContext = nullptr);",
          "1179:         void VerifyAliveWithHostContext(BOOL isJSFunction, HostScriptContext* requestHostScriptContext);",
          "1180:         void AddFunctionBodyToPropIdMap(FunctionBody* body);",
          "1182:         void BindReference(void* addr);",
          "1184:         void InitPropertyStringMap(int i);",
          "1185:         PropertyString* AddPropertyString2(const Js::PropertyRecord* propertyRecord);",
          "1186:         PropertyString* CachePropertyString2(const Js::PropertyRecord* propertyRecord);",
          "1187:         PropertyString* GetPropertyString2(char16 ch1, char16 ch2);",
          "1188:         void FindPropertyRecord(__in LPCWSTR pszPropertyName, __in int propertyNameLength, PropertyRecord const** propertyRecord);",
          "1189:         JsUtil::List<const RecyclerWeakReference<Js::PropertyRecord const>*>* FindPropertyIdNoCase(__in LPCWSTR pszPropertyName, __in int propertyNameLength);",
          "1191:         void FindPropertyRecord(JavascriptString* pstName, PropertyRecord const** propertyRecord);",
          "1192:         PropertyRecord const * GetPropertyName(PropertyId propertyId);",
          "1193:         PropertyRecord const * GetPropertyNameLocked(PropertyId propertyId);",
          "1194:         void GetOrAddPropertyRecord(JsUtil::CharacterBuffer<WCHAR> const& propName, PropertyRecord const** propertyRecord);",
          "1195:         template <size_t N> void GetOrAddPropertyRecord(const char16(&propertyName)[N], PropertyRecord const** propertyRecord)",
          "1196:         {",
          "1197:             GetOrAddPropertyRecord(propertyName, N - 1, propertyRecord);",
          "1198:         }",
          "1199:         PropertyId GetOrAddPropertyIdTracked(JsUtil::CharacterBuffer<WCHAR> const& propName);",
          "1200:         template <size_t N> PropertyId GetOrAddPropertyIdTracked(const char16(&propertyName)[N])",
          "1201:         {",
          "1202:             return GetOrAddPropertyIdTracked(propertyName, N - 1);",
          "1203:         }",
          "1204:         PropertyId GetOrAddPropertyIdTracked(__in_ecount(propertyNameLength) LPCWSTR pszPropertyName, __in int propertyNameLength);",
          "1205:         void GetOrAddPropertyRecord(__in_ecount(propertyNameLength) LPCWSTR pszPropertyName, __in int propertyNameLength, PropertyRecord const** propertyRecord);",
          "1206:         BOOL IsNumericPropertyId(PropertyId propertyId, uint32* value);",
          "1208:         void RegisterWeakReferenceDictionary(JsUtil::IWeakReferenceDictionary* weakReferenceDictionary);",
          "1209:         void ResetWeakReferenceDictionaryList() { weakReferenceDictionaryList.Reset(); }",
          "1211:         BOOL ReserveStaticTypeIds(__in int first, __in int last);",
          "1212:         TypeId ReserveTypeIds(int count);",
          "1213:         TypeId CreateTypeId();",
          "1215:         WellKnownHostType GetWellKnownHostType(Js::TypeId typeId) { return threadContext->GetWellKnownHostType(typeId); }",
          "1216:         void SetWellKnownHostTypeId(WellKnownHostType wellKnownType, Js::TypeId typeId) { threadContext->SetWellKnownHostTypeId(wellKnownType, typeId); }",
          "1218:         ParseNodePtr ParseScript(Parser* parser, const byte* script,",
          "1219:             size_t cb, SRCINFO const * pSrcInfo,",
          "1220:             CompileScriptException * pse, Utf8SourceInfo** ppSourceInfo,",
          "1221:             const char16 *rootDisplayName, LoadScriptFlag loadScriptFlag,",
          "1222:             uint* sourceIndex, Js::Var scriptSource = nullptr);",
          "1224:         JavascriptFunction* LoadScript(const byte* script, size_t cb,",
          "1225:             SRCINFO const * pSrcInfo,",
          "1226:             CompileScriptException * pse, Utf8SourceInfo** ppSourceInfo,",
          "1227:             const char16 *rootDisplayName, LoadScriptFlag loadScriptFlag,",
          "1228:             Js::Var scriptSource = nullptr);",
          "1230:         ArenaAllocator* GeneralAllocator() { return &generalAllocator; }",
          "1232: #ifdef ENABLE_BASIC_TELEMETRY",
          "1233:         ArenaAllocator* TelemetryAllocator() { return &telemetryAllocator; }",
          "1234: #endif",
          "1236: #ifdef SEPARATE_ARENA",
          "1237:         ArenaAllocator* SourceCodeAllocator() { return &sourceCodeAllocator; }",
          "1238:         ArenaAllocator* RegexAllocator() { return &regexAllocator; }",
          "1239: #else",
          "1240:         ArenaAllocator* SourceCodeAllocator() { return &generalAllocator; }",
          "1241:         ArenaAllocator* RegexAllocator() { return &generalAllocator; }",
          "1242: #endif",
          "1243: #ifdef NEED_MISC_ALLOCATOR",
          "1244:         ArenaAllocator* MiscAllocator() { return &miscAllocator; }",
          "1245: #endif",
          "1246:         InlineCacheAllocator* GetInlineCacheAllocator() { return &inlineCacheAllocator; }",
          "1247:         CacheAllocator* GetIsInstInlineCacheAllocator() { return &isInstInlineCacheAllocator; }",
          "1248:         CacheAllocator * ForInCacheAllocator() { return &forInCacheAllocator; }",
          "1249:         ArenaAllocator* DynamicProfileInfoAllocator() { return &dynamicProfileInfoAllocator; }",
          "1251:         ArenaAllocator* AllocatorForDiagnostics();",
          "1253:         Js::TempArenaAllocatorObject* GetTemporaryAllocator(LPCWSTR name);",
          "1254:         void ReleaseTemporaryAllocator(Js::TempArenaAllocatorObject* tempAllocator);",
          "1255:         Js::TempGuestArenaAllocatorObject* GetTemporaryGuestAllocator(LPCWSTR name);",
          "1256:         void ReleaseTemporaryGuestAllocator(Js::TempGuestArenaAllocatorObject* tempAllocator);",
          "1258:         bool EnsureInterpreterArena(ArenaAllocator **);",
          "1259:         void ReleaseInterpreterArena();",
          "1261:         ArenaAllocator* GetGuestArena() const",
          "1262:         {",
          "1263:             return guestArena;",
          "1264:         }",
          "1266:         void ReleaseGuestArena();",
          "1268:         Recycler* GetRecycler() const { return recycler; }",
          "1269:         RecyclerJavascriptNumberAllocator * GetNumberAllocator() { return &numberAllocator; }",
          "1270: #if ENABLE_NATIVE_CODEGEN",
          "1271:         NativeCodeGenerator * GetNativeCodeGenerator() const { return nativeCodeGen; }",
          "1272: #endif",
          "1273: #if ENABLE_BACKGROUND_PARSING",
          "1274:         BackgroundParser * GetBackgroundParser() const { return backgroundParser; }",
          "1275: #endif",
          "1277:         void OnScriptStart(bool isRoot, bool isScript);",
          "1278:         void OnScriptEnd(bool isRoot, bool isForcedEnd);",
          "1280:         template <bool stackProbe, bool leaveForHost>",
          "1281:         bool LeaveScriptStart(void * frameAddress);",
          "1282:         template <bool leaveForHost>",
          "1283:         void LeaveScriptEnd(void * frameAddress);",
          "1285:         HostScriptContext * GetHostScriptContext() const { return hostScriptContext; }",
          "1286:         void SetHostScriptContext(HostScriptContext *  hostScriptContext);",
          "1287:         void SetScriptEngineHaltCallback(HaltCallback* scriptEngine);",
          "1288:         void ClearHostScriptContext();",
          "1290:         IActiveScriptProfilerHeapEnum* GetHeapEnum();",
          "1291:         void SetHeapEnum(IActiveScriptProfilerHeapEnum* newHeapEnum);",
          "1292:         void ClearHeapEnum();",
          "1294:         void SetScriptStartEventHandler(EventHandler eventHandler);",
          "1295:         void SetScriptEndEventHandler(EventHandler eventHandler);",
          "1296: #ifdef FAULT_INJECTION",
          "1297:         void DisposeScriptContextByFaultInjection();",
          "1298:         void SetDisposeDisposeByFaultInjectionEventHandler(EventHandler eventHandler);",
          "1299: #endif",
          "1300:         EnumeratedObjectCache* GetEnumeratedObjectCache() { return &(this->Cache()->enumObjCache); }",
          "1301:         PropertyString* TryGetPropertyString(PropertyId propertyId);",
          "1302:         PropertyString* GetPropertyString(PropertyId propertyId);",
          "1303:         void InvalidatePropertyStringCache(PropertyId propertyId, Type* type);",
          "1304:         JavascriptString* GetIntegerString(Var aValue);",
          "1305:         JavascriptString* GetIntegerString(int value);",
          "1306:         JavascriptString* GetIntegerString(uint value);",
          "1308:         void CheckEvalRestriction();",
          "1310:         RecyclableObject* GetMissingPropertyResult();",
          "1311:         RecyclableObject* GetMissingItemResult();",
          "1313:         bool HasRecordedException() const { return threadContext->GetRecordedException() != nullptr; }",
          "1314:         Js::JavascriptExceptionObject * GetAndClearRecordedException(bool *considerPassingToDebugger = nullptr);",
          "1315:         void RecordException(Js::JavascriptExceptionObject * exceptionObject, bool propagateToDebugger = false);",
          "1316:         __declspec(noreturn) void RethrowRecordedException(JavascriptExceptionObject::HostWrapperCreateFuncType hostWrapperCreateFunc);",
          "1318: #if ENABLE_NATIVE_CODEGEN",
          "1319:         BOOL IsNativeAddress(void * codeAddr);",
          "1320: #endif",
          "1322:         uint SaveSourceCopy(Utf8SourceInfo* sourceInfo, int cchLength, bool isCesu8);",
          "1323:         bool SaveSourceCopy(Utf8SourceInfo* const sourceInfo, int cchLength, bool isCesu8, uint * index);",
          "1325:         uint SaveSourceNoCopy(Utf8SourceInfo* sourceInfo, int cchLength, bool isCesu8);",
          "1327:         void CloneSources(ScriptContext* sourceContext);",
          "1328:         Utf8SourceInfo* GetSource(uint sourceIndex);",
          "1330:         uint SourceCount() const { return (uint)sourceList->Count(); }",
          "1331:         void CleanSourceList() { CleanSourceListInternal(false); }",
          "1332:         SourceList* GetSourceList() const { return sourceList; }",
          "1333:         bool IsItemValidInSourceList(int index);",
          "1335:         template <typename TFunction>",
          "1336:         void MapScript(TFunction mapper)",
          "1337:         {",
          "1338:             this->sourceList->Map([mapper] (int, RecyclerWeakReference<Utf8SourceInfo>* sourceInfoWeakReference)",
          "1339:             {",
          "1340:                 Utf8SourceInfo* strongRef = sourceInfoWeakReference->Get();",
          "1342:                 if (strongRef)",
          "1343:                 {",
          "1344:                     mapper(strongRef);",
          "1345:                 }",
          "1346:             });",
          "1347:         }",
          "1349: #ifdef CHECK_STACKWALK_EXCEPTION",
          "1350:         void SetIgnoreStackWalkException() {threadContext->GetScriptEntryExit()->ignoreStackWalkException = true; }",
          "1351: #endif",
          "1356:         void EnforceEERHasCaller() { threadContext->GetScriptEntryExit()->hasCaller = true; }",
          "1358:         void SetRaiseMessageToDebuggerFunction(RaiseMessageToDebuggerFunctionType function)",
          "1359:         {",
          "1360:             raiseMessageToDebuggerFunctionType = function;",
          "1361:         }",
          "1363:         void RaiseMessageToDebugger(DEBUG_EVENT_INFO_TYPE messageType, LPCWSTR message, LPCWSTR url)",
          "1364:         {",
          "1365:             if (raiseMessageToDebuggerFunctionType != nullptr)",
          "1366:             {",
          "1367:                 raiseMessageToDebuggerFunctionType(this, messageType, message, url);",
          "1368:             }",
          "1369:         }",
          "1371:         void SetTransitionToDebugModeIfFirstSourceFn(TransitionToDebugModeIfFirstSourceFn function)",
          "1372:         {",
          "1373:             transitionToDebugModeIfFirstSourceFn = function;",
          "1374:         }",
          "1376:         void TransitionToDebugModeIfFirstSource(Utf8SourceInfo *sourceInfo)",
          "1377:         {",
          "1378:             if (transitionToDebugModeIfFirstSourceFn != nullptr)",
          "1379:             {",
          "1380:                 transitionToDebugModeIfFirstSourceFn(this, sourceInfo);",
          "1381:             }",
          "1382:         }",
          "1384:         void AddSourceSize(size_t sourceSize)",
          "1385:         {",
          "1386:             this->sourceSize += sourceSize;",
          "1387:             this->threadContext->AddSourceSize(sourceSize);",
          "1388:         }",
          "1390:         size_t GetSourceSize()",
          "1391:         {",
          "1392:             return this->sourceSize;",
          "1393:         }",
          "1395:         BOOL SetDeferredBody(BOOL set)",
          "1396:         {",
          "1397:             bool old = this->deferredBody;",
          "1398:             this->deferredBody = !!set;",
          "1399:             return old;",
          "1400:         }",
          "1402:         BOOL GetDeferredBody(void) const",
          "1403:         {",
          "1404:             return this->deferredBody;",
          "1405:         }",
          "1407:     public:",
          "1408:         void FreeFunctionEntryPoint(Js::JavascriptMethod method);",
          "1410:     private:",
          "1411:         uint CloneSource(Utf8SourceInfo* info);",
          "1412:     public:",
          "1413:         void RegisterProtoInlineCache(InlineCache *pCache, PropertyId propId);",
          "1414:         void InvalidateProtoCaches(const PropertyId propertyId);",
          "1415:         void InvalidateAllProtoCaches();",
          "1416:         void RegisterStoreFieldInlineCache(InlineCache *pCache, PropertyId propId);",
          "1417:         void InvalidateStoreFieldCaches(const PropertyId propertyId);",
          "1418:         void InvalidateAllStoreFieldCaches();",
          "1419:         void RegisterIsInstInlineCache(Js::IsInstInlineCache * cache, Js::Var function);",
          "1420: #if DBG",
          "1421:         bool IsIsInstInlineCacheRegistered(Js::IsInstInlineCache * cache, Js::Var function);",
          "1422: #endif",
          "1423:         void ClearInlineCaches();",
          "1424:         void ClearIsInstInlineCaches();",
          "1425:         void ClearForInCaches();",
          "1426: #ifdef PERSISTENT_INLINE_CACHES",
          "1427:         void ClearInlineCachesWithDeadWeakRefs();",
          "1428: #endif",
          "1429:         void ClearScriptContextCaches();",
          "1430: #if ENABLE_NATIVE_CODEGEN",
          "1431:         void RegisterConstructorCache(Js::PropertyId propertyId, Js::ConstructorCache* cache);",
          "1432: #endif",
          "1434:     public:",
          "1435:         void RegisterPrototypeChainEnsuredToHaveOnlyWritableDataPropertiesScriptContext();",
          "1436:     private:",
          "1437:         void DoRegisterPrototypeChainEnsuredToHaveOnlyWritableDataPropertiesScriptContext();",
          "1438:     public:",
          "1439:         void ClearPrototypeChainEnsuredToHaveOnlyWritableDataPropertiesCaches();",
          "1441:     public:",
          "1442:         JavascriptString * GetLastNumberToStringRadix10(double value);",
          "1443:         void SetLastNumberToStringRadix10(double value, JavascriptString * str);",
          "1444:         bool GetLastUtcTimeFromStr(JavascriptString * str, double& dbl);",
          "1445:         void SetLastUtcTimeFromStr(JavascriptString * str, double value);",
          "1446:         bool IsNoContextSourceContextInfo(SourceContextInfo *sourceContextInfo) const",
          "1447:         {",
          "1448:             return sourceContextInfo == this->Cache()->noContextSourceContextInfo;",
          "1449:         }",
          "1451:         BOOL IsProfiling()",
          "1452:         {",
          "1453: #ifdef ENABLE_SCRIPT_PROFILING",
          "1454:             return (m_pProfileCallback != nullptr);",
          "1455: #else",
          "1456:             return FALSE;",
          "1457: #endif",
          "1458:         }",
          "1460:         BOOL IsInProfileCallback()",
          "1461:         {",
          "1462: #ifdef ENABLE_SCRIPT_PROFILING",
          "1463:             return m_inProfileCallback;",
          "1464: #else",
          "1465:             return FALSE;",
          "1466: #endif",
          "1467:         }",
          "1469: #if DBG",
          "1470:         SourceContextInfo const * GetNoContextSourceContextInfo() const { return this->Cache()->noContextSourceContextInfo; }",
          "1472: #ifdef ENABLE_SCRIPT_PROFILING",
          "1473:         int GetProfileSession()",
          "1474:         {",
          "1475:             AssertMsg(m_pProfileCallback != nullptr, \"Asking for profile session when we aren't in one.\");",
          "1476:             return m_iProfileSession;",
          "1477:         }",
          "1479:         void StartNewProfileSession()",
          "1480:         {",
          "1481:             AssertMsg(m_pProfileCallback != nullptr, \"New Session when the profiler isn't set to any callback.\");",
          "1482:             m_iProfileSession++;",
          "1483:         }",
          "1485:         void StopProfileSession()",
          "1486:         {",
          "1487:             AssertMsg(m_pProfileCallback == nullptr, \"How to stop when there is still the callback out there\");",
          "1488:         }",
          "1489: #endif // ENABLE_SCRIPT_PROFILING",
          "1491:         bool hadProfiled;",
          "1492:         bool HadProfiled() const { return hadProfiled; }",
          "1493: #endif",
          "1495:         SRCINFO *AddHostSrcInfo(SRCINFO const *pSrcInfo);",
          "1497:         inline void CoreSetProfileEventMask(DWORD dwEventMask);",
          "1498:         typedef HRESULT (*RegisterExternalLibraryType)(Js::ScriptContext *pScriptContext);",
          "1499: #ifdef ENABLE_SCRIPT_PROFILING",
          "1500:         HRESULT RegisterProfileProbe(IActiveScriptProfilerCallback *pProfileCallback, DWORD dwEventMask, DWORD dwContext, RegisterExternalLibraryType RegisterExternalLibrary, JavascriptMethod dispatchInvoke);",
          "1501:         HRESULT DeRegisterProfileProbe(HRESULT hrReason, JavascriptMethod dispatchInvoke);",
          "1502: #endif",
          "1503:         HRESULT SetProfileEventMask(DWORD dwEventMask);",
          "1505:         HRESULT RegisterScript(Js::FunctionProxy *pFunctionBody, BOOL fRegisterScript = TRUE);",
          "1508:         HRESULT RegisterAllScripts();",
          "1511:         void EnsureClearDebugDocument();",
          "1514:         void ShutdownClearSourceLists();",
          "1516:         HRESULT RegisterLibraryFunction(const char16 *pwszObjectName, const char16 *pwszFunctionName, Js::PropertyId functionPropertyId, JavascriptMethod entryPoint);",
          "1518:         HRESULT RegisterBuiltinFunctions(RegisterExternalLibraryType RegisterExternalLibrary);",
          "1519:         void UpdateRecyclerFunctionEntryPointsForDebugger();",
          "1520:         void SetFunctionInRecyclerToProfileMode(bool enumerateNonUserFunctionsOnly = false);",
          "1522: #if defined(ENABLE_SCRIPT_PROFILING) || defined(ENABLE_SCRIPT_DEBUGGING)",
          "1523:         void RegisterDebugThunk(bool calledDuringAttach = true);",
          "1524:         void UnRegisterDebugThunk();",
          "1525:         static void SetEntryPointToProfileThunk(JavascriptFunction* function);",
          "1526:         static void RestoreEntryPointFromProfileThunk(JavascriptFunction* function);",
          "1527:         static void RecyclerEnumClassEnumeratorCallback(void *address, size_t size);",
          "1528: #endif",
          "1529:         static void RecyclerFunctionCallbackForDebugger(void *address, size_t size);",
          "1531:         static ushort ProcessNameAndGetLength(Js::StringBuilder<ArenaAllocator>* nameBuffer, const WCHAR* name);",
          "1533: #ifdef ASMJS_PLAT",
          "1534:         void TransitionEnvironmentForDebugger(ScriptFunction * scriptFunction);",
          "1535: #endif",
          "1537: #if ENABLE_NATIVE_CODEGEN",
          "1538:         HRESULT RecreateNativeCodeGenerator();",
          "1539: #endif",
          "1541:         HRESULT OnDebuggerAttached();",
          "1542:         HRESULT OnDebuggerDetached();",
          "1543:         HRESULT OnDebuggerAttachedDetached(bool attach);",
          "1544:         void InitializeDebugging();",
          "1545:         bool IsForceNoNative();",
          "1546:         bool IsEnumeratingRecyclerObjects() const { return isEnumeratingRecyclerObjects; }",
          "1548:     private:",
          "1549:         class AutoEnumeratingRecyclerObjects",
          "1550:         {",
          "1551:         public:",
          "1552:             AutoEnumeratingRecyclerObjects(ScriptContext* scriptContext):",
          "1553:                 m_scriptContext(scriptContext)",
          "1554:             {",
          "1555:                 Assert(!m_scriptContext->IsEnumeratingRecyclerObjects());",
          "1556:                 m_scriptContext->isEnumeratingRecyclerObjects = true;",
          "1557:             }",
          "1559:             ~AutoEnumeratingRecyclerObjects()",
          "1560:             {",
          "1561:                 Assert(m_scriptContext->IsEnumeratingRecyclerObjects());",
          "1562:                 m_scriptContext->isEnumeratingRecyclerObjects = false;",
          "1563:             }",
          "1565:         private:",
          "1566:             ScriptContext* m_scriptContext;",
          "1567:         };",
          "1569: #ifdef EDIT_AND_CONTINUE",
          "1570:     private:",
          "1571:         ScriptEditQuery* activeScriptEditQuery;",
          "1573:         void BeginScriptEditEnumFunctions(ScriptEditQuery* scriptEditQuery) { Assert(!activeScriptEditQuery); activeScriptEditQuery = scriptEditQuery; }",
          "1574:         void EndScriptEditEnumFunctions() { Assert(activeScriptEditQuery); activeScriptEditQuery = nullptr; }",
          "1575:     public:",
          "1576:         ScriptEditQuery* GetActiveScriptEditQuery() const { return activeScriptEditQuery; }",
          "1578:         class AutoScriptEditEnumFunctions",
          "1579:         {",
          "1580:         public:",
          "1581:             AutoScriptEditEnumFunctions(ScriptContext* scriptContext, ScriptEditQuery* scriptEditQuery) : m_scriptContext(scriptContext)",
          "1582:             {",
          "1583:                 scriptContext->BeginScriptEditEnumFunctions(scriptEditQuery);",
          "1584:             }",
          "1585:             ~AutoScriptEditEnumFunctions() { m_scriptContext->EndScriptEditEnumFunctions(); }",
          "1586:         private:",
          "1587:             ScriptContext* m_scriptContext;",
          "1588:         };",
          "1589: #endif",
          "1591:     private:",
          "1592:         typedef JsUtil::BaseDictionary<JavascriptMethod, Js::PropertyId, ArenaAllocator, PrimeSizePolicy> BuiltinFunctionIdDictionary;",
          "1593:         BuiltinFunctionIdDictionary *m_pBuiltinFunctionIdMap;",
          "1594:         Js::PropertyId GetFunctionNumber(JavascriptMethod entryPoint);",
          "1596:         static const char16* CopyString(const char16* str, size_t charCount, ArenaAllocator* alloc);",
          "1597:         static charcount_t AppendWithEscapeCharacters(Js::StringBuilder<ArenaAllocator>* stringBuilder, const WCHAR* sourceString, charcount_t sourceStringLen, WCHAR escapeChar, WCHAR charToEscape);",
          "1599:     public:",
          "1600: #if DYNAMIC_INTERPRETER_THUNK",
          "1601:         JavascriptMethod GetNextDynamicAsmJsInterpreterThunk(PVOID* ppDynamicInterpreterThunk);",
          "1602:         JavascriptMethod GetNextDynamicInterpreterThunk(PVOID* ppDynamicInterpreterThunk);",
          "1603: #if DBG",
          "1604:         BOOL IsDynamicInterpreterThunk(JavascriptMethod address);",
          "1605: #endif",
          "1606:         void ReleaseDynamicInterpreterThunk(BYTE* address, bool addtoFreeList);",
          "1607:         void ReleaseDynamicAsmJsInterpreterThunk(BYTE* address, bool addtoFreeList);",
          "1608: #endif",
          "1610:         static Var DebugProfileProbeThunk(RecyclableObject* function, CallInfo callInfo, ...);",
          "1611:         static JavascriptMethod ProfileModeDeferredParse(ScriptFunction **function);",
          "1612:         static Var ProfileModeDeferredParsingThunk(RecyclableObject* function, CallInfo callInfo, ...);",
          "1615:         static JavascriptMethod ProfileModeDeferredDeserialize(ScriptFunction* function);",
          "1616:         static Var ProfileModeDeferredDeserializeThunk(RecyclableObject* function, CallInfo callInfo, ...);",
          "1618: #if defined(ENABLE_SCRIPT_DEBUGGING) || defined(ENABLE_SCRIPT_PROFILING)",
          "1619:         static Var ProfileModeThunk_DebugModeWrapper(JavascriptFunction* function, ScriptContext* scriptContext, JavascriptMethod entryPoint, Arguments& args);",
          "1620:         static JavascriptMethod GetProfileModeThunk(JavascriptMethod entryPoint);",
          "1621: #endif",
          "1623: #ifdef ENABLE_SCRIPT_PROFILING",
          "1624:         void SetProfileMode(BOOL fSet);",
          "1625:         BOOL GetProfileInfo(",
          "1626:             JavascriptFunction* function,",
          "1627:             PROFILER_TOKEN &scriptId,",
          "1628:             PROFILER_TOKEN &functionId);",
          "1630:         HRESULT OnScriptCompiled(PROFILER_TOKEN scriptId, PROFILER_SCRIPT_TYPE type, IUnknown *pIDebugDocumentContext);",
          "1631:         HRESULT OnFunctionCompiled(",
          "1632:             PROFILER_TOKEN functionId,",
          "1633:             PROFILER_TOKEN scriptId,",
          "1634:             const WCHAR *pwszFunctionName,",
          "1635:             const WCHAR *pwszFunctionNameHint,",
          "1636:             IUnknown *pIDebugDocumentContext);",
          "1637:         HRESULT OnFunctionEnter(PROFILER_TOKEN scriptId, PROFILER_TOKEN functionId);",
          "1638:         HRESULT OnFunctionExit(PROFILER_TOKEN scriptId, PROFILER_TOKEN functionId);",
          "1640:         static HRESULT FunctionExitSenderThunk(PROFILER_TOKEN functionId, PROFILER_TOKEN scriptId, ScriptContext *pScriptContext);",
          "1641:         static HRESULT FunctionExitByNameSenderThunk(const char16 *pwszFunctionName, ScriptContext *pScriptContext);",
          "1642: #endif // ENABLE_SCRIPT_PROFILING",
          "1644:         bool SetDispatchProfile(bool fSet, JavascriptMethod dispatchInvoke);",
          "1645:         HRESULT OnDispatchFunctionEnter(const WCHAR *pwszFunctionName);",
          "1646:         HRESULT OnDispatchFunctionExit(const WCHAR *pwszFunctionName);",
          "1648:         void OnStartupComplete();",
          "1649:         void SaveStartupProfileAndRelease(bool isSaveOnClose = false);",
          "1651: #if ENABLE_PROFILE_INFO",
          "1652:         template<template<typename> class BarrierT>",
          "1653:         void AddDynamicProfileInfo(FunctionBody * functionBody, BarrierT<DynamicProfileInfo>& dynamicProfileInfo);",
          "1654: #endif",
          "1655: #if DBG || defined(RUNTIME_DATA_COLLECTION)",
          "1656:         uint allocId;",
          "1657: #endif",
          "1659: #ifdef PROFILE_EXEC",
          "1660:         void DisableProfiler();",
          "1661:         void SetRecyclerProfiler();",
          "1662:         void SetProfilerFromScriptContext(ScriptContext * scriptContext);",
          "1663:         void ProfileBegin(Js::Phase);",
          "1664:         void ProfileEnd(Js::Phase);",
          "1665:         void ProfileSuspend(Js::Phase, Js::Profiler::SuspendRecord * suspendRecord);",
          "1666:         void ProfileResume(Js::Profiler::SuspendRecord * suspendRecord);",
          "1667:         void ProfilePrint();",
          "1668:         bool IsProfilerCreated() const { return isProfilerCreated; }",
          "1669: #endif",
          "1671: #ifdef PROFILE_MEM",
          "1672:         void DisableProfileMemoryDumpOnDelete() { profileMemoryDump = false; }",
          "1673: #endif",
          "1675: #ifdef PROFILE_STRINGS",
          "1676:         StringProfiler * GetStringProfiler(); // May be null if string profiling not enabled",
          "1677: #endif",
          "1679:     public:",
          "1680:         virtual intptr_t GetNullAddr() const override;",
          "1681:         virtual intptr_t GetUndefinedAddr() const override;",
          "1682:         virtual intptr_t GetTrueAddr() const override;",
          "1683:         virtual intptr_t GetFalseAddr() const override;",
          "1684:         virtual intptr_t GetUndeclBlockVarAddr() const override;",
          "1685:         virtual intptr_t GetEmptyStringAddr() const override;",
          "1686:         virtual intptr_t GetNegativeZeroAddr() const override;",
          "1687:         virtual intptr_t GetNumberTypeStaticAddr() const override;",
          "1688:         virtual intptr_t GetStringTypeStaticAddr() const override;",
          "1689:         virtual intptr_t GetObjectTypeAddr() const override;",
          "1690:         virtual intptr_t GetObjectHeaderInlinedTypeAddr() const override;",
          "1691:         virtual intptr_t GetRegexTypeAddr() const override;",
          "1692:         virtual intptr_t GetArrayTypeAddr() const override;",
          "1693:         virtual intptr_t GetNativeIntArrayTypeAddr() const override;",
          "1694:         virtual intptr_t GetNativeFloatArrayTypeAddr() const override;",
          "1695:         virtual intptr_t GetArrayConstructorAddr() const override;",
          "1696:         virtual intptr_t GetCharStringCacheAddr() const override;",
          "1697:         virtual intptr_t GetSideEffectsAddr() const override;",
          "1698:         virtual intptr_t GetArraySetElementFastPathVtableAddr() const override;",
          "1699:         virtual intptr_t GetIntArraySetElementFastPathVtableAddr() const override;",
          "1700:         virtual intptr_t GetFloatArraySetElementFastPathVtableAddr() const override;",
          "1701:         virtual intptr_t GetLibraryAddr() const override;",
          "1702:         virtual intptr_t GetGlobalObjectAddr() const override;",
          "1703:         virtual intptr_t GetGlobalObjectThisAddr() const override;",
          "1704:         virtual intptr_t GetNumberAllocatorAddr() const override;",
          "1705:         virtual intptr_t GetRecyclerAddr() const override;",
          "1706:         virtual bool GetRecyclerAllowNativeCodeBumpAllocation() const override;",
          "1707:         virtual bool IsSIMDEnabled() const override;",
          "1708:         virtual bool IsPRNGSeeded() const override;",
          "1709:         virtual intptr_t GetBuiltinFunctionsBaseAddr() const override;",
          "1711:         virtual intptr_t GetDebuggingFlagsAddr() const override;",
          "1712:         virtual intptr_t GetDebugStepTypeAddr() const override;",
          "1713:         virtual intptr_t GetDebugFrameAddressAddr() const override;",
          "1714:         virtual intptr_t GetDebugScriptIdWhenSetAddr() const override;",
          "1716: #if ENABLE_NATIVE_CODEGEN",
          "1717:         virtual void AddToDOMFastPathHelperMap(intptr_t funcInfoAddr, IR::JnHelperMethod helper) override;",
          "1718:         virtual IR::JnHelperMethod GetDOMFastPathHelper(intptr_t funcInfoAddr) override;",
          "1719: #endif",
          "1721:         virtual intptr_t GetAddr() const override;",
          "1723:         virtual intptr_t GetVTableAddress(VTableValue vtableType) const override;",
          "1725:         virtual bool IsRecyclerVerifyEnabled() const override;",
          "1726:         virtual uint GetRecyclerVerifyPad() const override;",
          "1728:         virtual Field(Js::Var)* GetModuleExportSlotArrayAddress(uint moduleIndex, uint slotIndex) override;",
          "1730:         Js::SourceTextModuleRecord* GetModuleRecord(uint moduleId) const",
          "1731:         {",
          "1732:             return javascriptLibrary->GetModuleRecord(moduleId);",
          "1733:         }",
          "1735:         void SetBuiltInLibraryFunction(JavascriptMethod entryPoint, JavascriptFunction* function);",
          "1736:         JavascriptFunction* GetBuiltInLibraryFunction(JavascriptMethod entryPoint);",
          "1738:     private:",
          "1739:         BuiltInLibraryFunctionMap* builtInLibraryFunctions;",
          "1741: #if ENABLE_NATIVE_CODEGEN",
          "1742:         JITDOMFastPathHelperMap * m_domFastPathHelperMap;",
          "1743: #endif",
          "1745: #ifdef RECYCLER_PERF_COUNTERS",
          "1746:         size_t bindReferenceCount;",
          "1747: #endif",
          "1749:         ScriptContext * nextPendingClose;",
          "1750:     public:",
          "1751:         void SetNextPendingClose(ScriptContext * nextPendingClose);",
          "1752:         inline ScriptContext * GetNextPendingClose() const { return nextPendingClose; }",
          "1754: #ifdef ENABLE_MUTATION_BREAKPOINT",
          "1756:         bool HasMutationBreakpoints();",
          "1757:         void InsertMutationBreakpoint(Js::MutationBreakpoint *mutationBreakpoint);",
          "1758: #endif",
          "1759:     };",
          "1761:     class AutoDynamicCodeReference",
          "1762:     {",
          "1763:     public:",
          "1764:         AutoDynamicCodeReference(ScriptContext* scriptContext):",
          "1765:           m_scriptContext(scriptContext)",
          "1766:           {",
          "1767:               scriptContext->GetLibrary()->BeginDynamicFunctionReferences();",
          "1768:           }",
          "1770:           ~AutoDynamicCodeReference()",
          "1771:           {",
          "1772:               m_scriptContext->GetLibrary()->EndDynamicFunctionReferences();",
          "1773:           }",
          "1775:     private:",
          "1776:         ScriptContext* m_scriptContext;",
          "1777:     };",
          "1779:     template <typename TCacheType>",
          "1780:     void ScriptContext::CleanDynamicFunctionCache(TCacheType* cacheType)",
          "1781:     {",
          "1785:         cacheType->Clean([this](const typename TCacheType::KeyType& key, typename TCacheType::ValueType value) {",
          "1786: #ifdef ENABLE_DEBUG_CONFIG_OPTIONS",
          "1787:             if (CONFIG_FLAG(DumpEvalStringOnRemoval))",
          "1788:             {",
          "1789:                 Output::Print(_u(\"EvalMap: Removing Dynamic Function String from dynamic function cache: %s\\n\"), key.str.GetBuffer()); Output::Flush();",
          "1790:             }",
          "1791: #endif",
          "1792:         });",
          "1793:     }",
          "1795:     template <class TDelegate>",
          "1796:     void ScriptContext::MapFunction(TDelegate mapper)",
          "1797:     {",
          "1798:         if (this->sourceList)",
          "1799:         {",
          "1800:             this->sourceList->Map([&mapper](int, RecyclerWeakReference<Js::Utf8SourceInfo>* sourceInfo)",
          "1801:             {",
          "1802:                 Utf8SourceInfo* sourceInfoStrongRef = sourceInfo->Get();",
          "1803:                 if (sourceInfoStrongRef)",
          "1804:                 {",
          "1805:                     sourceInfoStrongRef->MapFunction(mapper);",
          "1806:                 }",
          "1807:             });",
          "1808:         }",
          "1809:     }",
          "1811:     template <class TDelegate>",
          "1812:     FunctionBody* ScriptContext::FindFunction(TDelegate predicate)",
          "1813:     {",
          "1814:         FunctionBody* functionBody = nullptr;",
          "1816:         this->sourceList->MapUntil([&functionBody, &predicate](int, RecyclerWeakReference<Js::Utf8SourceInfo>* sourceInfo) -> bool",
          "1817:         {",
          "1818:             Utf8SourceInfo* sourceInfoStrongRef = sourceInfo->Get();",
          "1819:             if (sourceInfoStrongRef)",
          "1820:             {",
          "1821:                 functionBody = sourceInfoStrongRef->FindFunction(predicate);",
          "1822:                 if (functionBody)",
          "1823:                 {",
          "1824:                     return true;",
          "1825:                 }",
          "1826:             }",
          "1828:             return false;",
          "1829:         });",
          "1831:         return functionBody;",
          "1832:     }",
          "1834:     class AutoProfilingPhase",
          "1835:     {",
          "1836:     public:",
          "1837:         AutoProfilingPhase(ScriptContext* scriptcontext, Js::Phase phase) : scriptcontext(scriptcontext), phase(phase), isPhaseComplete(false)",
          "1838:         {",
          "1839:     #ifdef PROFILE_EXEC",
          "1840:             scriptcontext->ProfileBegin(phase);",
          "1841:     #endif",
          "1842:         }",
          "1844:         ~AutoProfilingPhase()",
          "1845:         {",
          "1846:             if(!this->isPhaseComplete)",
          "1847:             {",
          "1848:                 EndProfile();",
          "1849:             }",
          "1850:         }",
          "1852:         void EndProfile()",
          "1853:         {",
          "1854:             this->isPhaseComplete = true;",
          "1855: #ifdef PROFILE_EXEC",
          "1856:             scriptcontext->ProfileEnd(phase);",
          "1857: #endif",
          "1858:         }",
          "1859:     private:",
          "1860:         ScriptContext* scriptcontext;",
          "1861:         Js::Phase phase;",
          "1862:         bool isPhaseComplete;",
          "1863:     };",
          "1864: }",
          "1867: #define BEGIN_TEMP_ALLOCATOR(allocator, scriptContext, name) \\",
          "1868:     Js::TempArenaAllocatorObject *temp##allocator = scriptContext->GetTemporaryAllocator(name); \\",
          "1869:     ArenaAllocator * allocator = temp##allocator->GetAllocator();",
          "1871: #define END_TEMP_ALLOCATOR(allocator, scriptContext) \\",
          "1872:     scriptContext->ReleaseTemporaryAllocator(temp##allocator);",
          "1874: #define DECLARE_TEMP_ALLOCATOR(allocator) \\",
          "1875:     Js::TempArenaAllocatorObject *temp##allocator = nullptr; \\",
          "1876:     ArenaAllocator * allocator = nullptr;",
          "1878: #define ACQUIRE_TEMP_ALLOCATOR(allocator, scriptContext, name) \\",
          "1879:     temp##allocator = scriptContext->GetTemporaryAllocator(name); \\",
          "1880:     allocator = temp##allocator->GetAllocator();",
          "1882: #define RELEASE_TEMP_ALLOCATOR(allocator, scriptContext) \\",
          "1883:     if (temp##allocator) \\",
          "1884:     scriptContext->ReleaseTemporaryAllocator(temp##allocator);",
          "1886: #define DECLARE_TEMP_GUEST_ALLOCATOR(allocator) \\",
          "1887:     Js::TempGuestArenaAllocatorObject *tempGuest##allocator = nullptr; \\",
          "1888:     ArenaAllocator * allocator = nullptr;",
          "1890: #define ACQUIRE_TEMP_GUEST_ALLOCATOR(allocator, scriptContext, name) \\",
          "1891:     tempGuest##allocator = scriptContext->GetTemporaryGuestAllocator(name); \\",
          "1892:     allocator = tempGuest##allocator->GetAllocator();",
          "1894: #define RELEASE_TEMP_GUEST_ALLOCATOR(allocator, scriptContext) \\",
          "1895:     if (tempGuest##allocator) \\",
          "1896:     scriptContext->ReleaseTemporaryGuestAllocator(tempGuest##allocator);",
          "",
          "[Added Lines]",
          "5: #pragma once",
          "7: #if defined(_WIN32) && defined(ENABLE_SCRIPT_PROFILING)",
          "8: #include \"activprof.h\"",
          "9: #endif",
          "11: #if DBG || ENABLE_REGEX_CONFIG_OPTIONS || defined(PROFILE_STRINGS)",
          "12: #define NEED_MISC_ALLOCATOR",
          "13: #endif",
          "15: #define BuiltInFunctionsScriptId 0",
          "17: using namespace PlatformAgnostic;",
          "19: class NativeCodeGenerator;",
          "20: class BackgroundParser;",
          "21: struct IActiveScriptDirect;",
          "22: #ifdef ENABLE_BASIC_TELEMETRY",
          "23: class ScriptContextTelemetry;",
          "24: #endif",
          "25: namespace Js",
          "26: {",
          "27:     class ScriptContext;",
          "28:     class ScriptEditQuery;",
          "29:     class MutationBreakpoint;",
          "30:     class StringProfiler;",
          "31:     class DebugContext;",
          "32:     struct HaltCallback;",
          "33:     struct DebuggerOptionsCallback;",
          "34:     class ModuleRecordBase;",
          "35: }",
          "39: class SRCINFO",
          "40: {",
          "44: public:",
          "45:     Field(SourceContextInfo *) sourceContextInfo;",
          "46:     Field(ULONG) dlnHost;             // Line number passed to ParseScriptText",
          "47:     Field(ULONG) ulColumnHost;        // Column number on the line where the parse script text started",
          "48:     Field(ULONG) lnMinHost;           // Line offset of first host-supplied line",
          "49:     Field(ULONG) ichMinHost;          // Range of host supplied characters",
          "50:     Field(ULONG) ichLimHost;",
          "51:     Field(ULONG) ulCharOffset;        // Char offset of the source text relative to the document. (Populated using IActiveScriptContext)",
          "52:     Field(Js::ModuleID) moduleID;",
          "53:     Field(ULONG) grfsi;",
          "55:     static SRCINFO* Copy(Recycler* recycler, const SRCINFO* srcInfo)",
          "56:     {",
          "57:         SRCINFO* copySrcInfo = RecyclerNew(recycler, SRCINFO, *srcInfo);",
          "58:         return copySrcInfo;",
          "59:     }",
          "61:     SRCINFO()",
          "62:     {",
          "63:     }",
          "64:     SRCINFO(const SRCINFO& other)",
          "65:         :sourceContextInfo(other.sourceContextInfo),",
          "66:         dlnHost(other.dlnHost),",
          "67:         ulColumnHost(other.ulColumnHost),",
          "68:         lnMinHost(other.lnMinHost),",
          "69:         ichMinHost(other.ichMinHost),",
          "70:         ichLimHost(other.ichLimHost),",
          "71:         ulCharOffset(other.ulCharOffset),",
          "72:         moduleID(other.moduleID),",
          "73:         grfsi(other.grfsi)",
          "74:     {",
          "75:     }",
          "76:     SRCINFO(",
          "77:         SourceContextInfo*sourceContextInfo,",
          "78:         ULONG dlnHost,",
          "79:         ULONG ulColumnHost,",
          "80:         ULONG lnMinHost,",
          "81:         ULONG ichMinHost,",
          "82:         ULONG ichLimHost,",
          "83:         ULONG ulCharOffset,",
          "84:         Js::ModuleID moduleID,",
          "85:         ULONG grfsi",
          "86:     ):sourceContextInfo(sourceContextInfo),",
          "87:         dlnHost(dlnHost),",
          "88:         ulColumnHost(ulColumnHost),",
          "89:         lnMinHost(lnMinHost),",
          "90:         ichMinHost(ichMinHost),",
          "91:         ichLimHost(ichLimHost),",
          "92:         ulCharOffset(ulCharOffset),",
          "93:         moduleID(moduleID),",
          "94:         grfsi(grfsi)",
          "95:     {",
          "96:     }",
          "97: };",
          "99: struct CustomExternalObjectOperations",
          "100: {",
          "101:     size_t offsetOfOperationsUsage;",
          "102:     DWORD operationFlagEquals;",
          "103:     DWORD operationFlagStrictEquals;",
          "104: };",
          "106: enum ExternalJitData",
          "107: {",
          "108:     ExternalJitData_CustomExternalObjectOperations",
          "109: };",
          "111: enum LoadScriptFlag",
          "112: {",
          "113:     LoadScriptFlag_None         = 0x0,",
          "114:     LoadScriptFlag_Expression   = 0x1,                  // the script returns a value.",
          "115:     LoadScriptFlag_disableDeferredParse = 0x2,          // do not defer-parse the code.",
          "116:     LoadScriptFlag_isByteCodeBufferForLibrary = 0x4,    // for bytecode buffer",
          "117:     LoadScriptFlag_disableAsmJs = 0x8,                  // disable parse as asmjs. The code is not conform to asmjs requirement.",
          "118:     LoadScriptFlag_Module = 0x10,                       // input script is module code.",
          "119:     LoadScriptFlag_isFunction = 0x20,                   // input script is in a function scope, not global code.",
          "120:     LoadScriptFlag_Utf8Source = 0x40,                   // input buffer is utf8 encoded.",
          "121:     LoadScriptFlag_LibraryCode = 0x80,                  // for debugger, indicating 'not my code'",
          "122:     LoadScriptFlag_ExternalArrayBuffer = 0x100          // for ExternalArrayBuffer",
          "123: };",
          "125: class HostScriptContext",
          "126: {",
          "127: public:",
          "128:     HostScriptContext(Js::ScriptContext* inScriptContext) { this->scriptContext = inScriptContext; }",
          "129:     virtual void Delete() = 0;",
          "130:     virtual HRESULT GetPreviousHostScriptContext(__deref_out HostScriptContext** ppUnkCaller) = 0;",
          "131:     virtual HRESULT PushHostScriptContext() = 0;",
          "132:     virtual void PopHostScriptContext() = 0;",
          "134:     virtual HRESULT SetCaller(IUnknown *punkNew, IUnknown **ppunkPrev) = 0;",
          "135:     virtual HRESULT GetDispatchExCaller(__deref_out void** dispatchExCaller) = 0;",
          "136:     virtual void ReleaseDispatchExCaller(__in void* dispatchExCaler) = 0;",
          "137:     virtual Js::ModuleRoot * GetModuleRoot(int moduleID) = 0;",
          "138:     virtual HRESULT CheckCrossDomainScriptContext(__in Js::ScriptContext* scriptContext) = 0;",
          "140:     virtual HRESULT GetHostContextUrl(__in DWORD_PTR hostSourceContext, __out BSTR& pUrl) = 0;",
          "141:     virtual BOOL HasCaller() = 0;",
          "142:     virtual void CleanDynamicCodeCache() = 0;",
          "143:     virtual HRESULT VerifyDOMSecurity(Js::ScriptContext* targetContext, Js::Var obj) = 0;",
          "145:     virtual HRESULT CheckEvalRestriction() = 0;",
          "146:     virtual HRESULT HostExceptionFromHRESULT(HRESULT hr, Js::Var* outError) = 0;",
          "148:     virtual HRESULT GetExternalJitData(ExternalJitData id, void *data) = 0;",
          "149:     virtual HRESULT SetDispatchInvoke(Js::JavascriptMethod dispatchInvoke) = 0;",
          "150:     virtual HRESULT ArrayBufferFromExternalObject(__in Js::RecyclableObject *obj,",
          "151:         __out Js::ArrayBuffer **ppArrayBuffer) = 0;",
          "152:     virtual Js::JavascriptError* CreateWinRTError(IErrorInfo* perrinfo, Js::RestrictedErrorStrings * proerrstr) = 0;",
          "153:     virtual HRESULT EnqueuePromiseTask(Js::Var varTask) = 0;",
          "155:     virtual HRESULT FetchImportedModule(Js::ModuleRecordBase* referencingModule, LPCOLESTR specifier, Js::ModuleRecordBase** dependentModuleRecord) = 0;",
          "156:     virtual HRESULT NotifyHostAboutModuleReady(Js::ModuleRecordBase* referencingModule, Js::Var exceptionVar) = 0;",
          "158:     Js::ScriptContext* GetScriptContext() { return scriptContext; }",
          "160:     virtual bool SetCrossSiteForFunctionType(Js::JavascriptFunction * function) = 0;",
          "161: #if DBG_DUMP || defined(PROFILE_EXEC) || defined(PROFILE_MEM)",
          "162:     virtual void EnsureParentInfo(Js::ScriptContext* scriptContext = NULL) = 0;",
          "163: #endif",
          "164: #if DBG",
          "165:     virtual bool IsHostCrossSiteThunk(Js::JavascriptMethod address) = 0;",
          "166: #endif",
          "167: private:",
          "168:     Js::ScriptContext* scriptContext;",
          "169: };",
          "171: #if ENABLE_TTD",
          "173: class HostScriptContextCallbackFunctor",
          "174: {",
          "175: public:",
          "176:     FinalizableObject* HostData;",
          "177:     void(*pfOnScriptLoadCallback)(FinalizableObject* hostData, Js::JavascriptFunction* scriptFunction, Js::Utf8SourceInfo* utf8SourceInfo, CompileScriptException* compileException);",
          "179:     HostScriptContextCallbackFunctor()",
          "180:         : HostData(nullptr), pfOnScriptLoadCallback(nullptr)",
          "181:     {",
          "182:         ;",
          "183:     }",
          "185:     HostScriptContextCallbackFunctor(FinalizableObject* callbackData, void(*pfcallbackOnScriptLoad)(FinalizableObject* hostData, Js::JavascriptFunction* scriptFunction, Js::Utf8SourceInfo* utf8SourceInfo, CompileScriptException* compileException))",
          "186:         : HostData(callbackData), pfOnScriptLoadCallback(pfcallbackOnScriptLoad)",
          "187:     {",
          "188:         ;",
          "189:     }",
          "190: };",
          "191: #endif",
          "193: namespace Js",
          "194: {",
          "196: #pragma pack(push, 1)",
          "197:     struct StackFrameInfo",
          "198:     {",
          "199:         StackFrameInfo() { }",
          "200:         StackFrameInfo(DWORD_PTR _scriptContextID",
          "201:             , UINT32 _sourceLocationLineNumber",
          "202:             , UINT32 _sourceLocationColumnNumber",
          "203:             , UINT32 _methodIDOrNameIndex",
          "204:             , UINT8 _isFrameIndex)",
          "205:             : scriptContextID(_scriptContextID)",
          "206:             , sourceLocationLineNumber(_sourceLocationLineNumber)",
          "207:             , sourceLocationColumnNumber(_sourceLocationColumnNumber)",
          "208:             , methodIDOrNameIndex(_methodIDOrNameIndex)",
          "209:             , isFrameIndex(_isFrameIndex)",
          "210:         { }",
          "212:         DWORD_PTR scriptContextID;",
          "213:         UINT32 sourceLocationLineNumber;",
          "214:         UINT32 sourceLocationColumnNumber;",
          "215:         UINT32 methodIDOrNameIndex;",
          "216:         UINT8  isFrameIndex;",
          "217:     };",
          "218: #pragma pack(pop)",
          "220: #ifdef ENABLE_PROJECTION",
          "221:     class ProjectionConfiguration",
          "222:     {",
          "223:     public:",
          "224:         ProjectionConfiguration() : targetVersion(0)",
          "225:         {",
          "226:         }",
          "228:         DWORD GetTargetVersion() const { return this->targetVersion; }",
          "229:         void SetTargetVersion(DWORD version) { this->targetVersion = version; }",
          "231:         bool IsTargetWindows8() const           { return this->targetVersion == NTDDI_WIN8; }",
          "232:         bool IsTargetWindowsBlueOrLater() const { return this->targetVersion >= NTDDI_WINBLUE; }",
          "234:     private:",
          "235:         DWORD targetVersion;",
          "236:     };",
          "237: #endif // ENABLE_PROJECTION",
          "239:     class ScriptConfiguration",
          "240:     {",
          "241:     public:",
          "242:         ScriptConfiguration(const ThreadConfiguration * const threadConfig, const bool isOptimizedForManyInstances) :",
          "243: #ifdef ENABLE_PROJECTION",
          "244:             HostType(Configuration::Global.flags.HostType),",
          "245:             WinRTConstructorAllowed(Configuration::Global.flags.WinRTConstructorAllowed),",
          "246: #endif",
          "247:             NoNative(Configuration::Global.flags.NoNative),",
          "248:             isOptimizedForManyInstances(isOptimizedForManyInstances),",
          "249:             threadConfig(threadConfig)",
          "250:         {",
          "251:         }",
          "254:         bool SupportsES3()                      const { return true; }",
          "255:         bool SupportsES3Extensions()            const {",
          "256: #ifdef ENABLE_PROJECTION",
          "257:             return HostType != HostTypeApplication;",
          "258: #else",
          "259:             return true;",
          "260: #endif",
          "261:         }",
          "263: #define FORWARD_THREAD_CONFIG(flag) inline bool flag() const { return threadConfig->flag(); }",
          "264: #define FLAG(threadFlag, globalFlag) FORWARD_THREAD_CONFIG(threadFlag)",
          "265: #define FLAG_RELEASE(threadFlag, globalFlag) FORWARD_THREAD_CONFIG(threadFlag)",
          "266: #include \"../Base/ThreadConfigFlagsList.h\"",
          "267: #undef FLAG_RELEASE",
          "268: #undef FLAG",
          "269: #undef FORWARD_THREAD_CONFIG",
          "271:         bool SupportsCollectGarbage() const { return true; }",
          "273:         void ForceNoNative() { this->NoNative = true; }",
          "274:         void ForceNative() { this->NoNative = false; }",
          "275:         bool IsNoNative() const { return this->NoNative; }",
          "277:         void SetCanOptimizeGlobalLookupFlag(BOOL f){ this->fCanOptimizeGlobalLookup = f;}",
          "278:         BOOL CanOptimizeGlobalLookup() const { return this->fCanOptimizeGlobalLookup;}",
          "279:         bool IsOptimizedForManyInstances() const { return isOptimizedForManyInstances; }",
          "280:         void CopyFrom(ScriptConfiguration& other)",
          "281:         {",
          "282:             this->NoNative = other.NoNative;",
          "283:             this->fCanOptimizeGlobalLookup = other.fCanOptimizeGlobalLookup;",
          "284: #ifdef ENABLE_PROJECTION",
          "285:             this->HostType = other.HostType;",
          "286:             this->WinRTConstructorAllowed = other.WinRTConstructorAllowed;",
          "287:             this->projectionConfiguration = other.projectionConfiguration;",
          "288: #endif",
          "289:         }",
          "291: #ifdef ENABLE_PROJECTION",
          "292:         Number GetHostType() const    // Returns one of enum HostType values (see ConfigFlagsTable.h).",
          "293:         {",
          "294:             AssertMsg(this->HostType >= HostTypeMin && this->HostType <= HostTypeMax, \"HostType value is out of valid range.\");",
          "295:             return this->HostType;",
          "296:         }",
          "298:         ProjectionConfiguration const * GetProjectionConfig() const",
          "299:         {",
          "300:             return &projectionConfiguration;",
          "301:         }",
          "302:         void SetHostType(int32 hostType) { this->HostType = hostType; }",
          "303:         void SetWinRTConstructorAllowed(bool allowed) { this->WinRTConstructorAllowed = allowed; }",
          "304:         void SetProjectionTargetVersion(DWORD version)",
          "305:         {",
          "306:             projectionConfiguration.SetTargetVersion(version);",
          "307:         }",
          "308:         bool IsWinRTEnabled()           const { return (GetHostType() == Js::HostTypeApplication) || (GetHostType() == Js::HostTypeWebview); }",
          "310:         bool IsWinRTConstructorAllowed() const { return (GetHostType() != Js::HostTypeWebview) || this->WinRTConstructorAllowed; }",
          "311: #endif",
          "312:     private:",
          "315:         bool NoNative;",
          "316:         BOOL fCanOptimizeGlobalLookup;",
          "317:         const bool isOptimizedForManyInstances;",
          "318:         const ThreadConfiguration * const threadConfig;",
          "320: #ifdef ENABLE_PROJECTION",
          "321:         Number HostType;    // One of enum HostType values (see ConfigFlagsTable.h).",
          "322:         bool WinRTConstructorAllowed;  // whether allow constructor in webview host type. Also note that this is not a security feature.",
          "323:         ProjectionConfiguration projectionConfiguration;",
          "324: #endif",
          "325:     };",
          "327:     struct ScriptEntryExitRecord",
          "328:     {",
          "329:         bool hasCaller : 1;",
          "330:         bool hasReentered : 1;",
          "331: #if DBG_DUMP",
          "332:         bool isCallRoot : 1;",
          "333: #endif",
          "334: #if DBG || defined(PROFILE_EXEC)",
          "335:         bool leaveForHost : 1;",
          "336: #endif",
          "337: #if DBG",
          "338:         bool leaveForAsyncHostOperation : 1;",
          "339: #endif",
          "340: #ifdef CHECK_STACKWALK_EXCEPTION",
          "341:         bool ignoreStackWalkException: 1;",
          "342: #endif",
          "343:         Js::ImplicitCallFlags savedImplicitCallFlags;",
          "345:         void * returnAddrOfScriptEntryFunction;",
          "346:         void * frameIdOfScriptExitFunction; // the frameAddres in x86, the return address in amd64/arm_soc",
          "347:         ScriptContext * scriptContext;",
          "348:         struct ScriptEntryExitRecord * next;",
          "350: #if defined(_M_IX86) && defined(DBG)",
          "351:         void * scriptEntryFS0;",
          "352: #endif",
          "353: #ifdef EXCEPTION_CHECK",
          "354:         ExceptionType handledExceptionType;",
          "355: #endif",
          "356:     };",
          "358:     struct PropertyStringMap",
          "359:     {",
          "360:         PropertyString* strLen2[80];",
          "362:         inline static uint PStrMapIndex(char16 ch)",
          "363:         {",
          "364:             Assert(ch >= '0' && ch <= 'z');",
          "365:             return ch - '0';",
          "366:         }",
          "367:     };",
          "374:     class JITPageAddrToFuncRangeCache",
          "375:     {",
          "376:     public:",
          "377:         typedef JsUtil::BaseDictionary<void *, uint, HeapAllocator> RangeMap;",
          "378:         typedef JsUtil::BaseDictionary<void *, RangeMap*, HeapAllocator> JITPageAddrToFuncRangeMap;",
          "379:         typedef JsUtil::BaseDictionary<void *, uint, HeapAllocator> LargeJITFuncAddrToSizeMap;",
          "381:     private:",
          "382:         JITPageAddrToFuncRangeMap * jitPageAddrToFuncRangeMap;",
          "383:         LargeJITFuncAddrToSizeMap * largeJitFuncToSizeMap;",
          "385:         static CriticalSection cs;",
          "387:     public:",
          "388:         JITPageAddrToFuncRangeCache() :jitPageAddrToFuncRangeMap(nullptr), largeJitFuncToSizeMap(nullptr) {}",
          "389:         ~JITPageAddrToFuncRangeCache()",
          "390:         {",
          "391:             ClearCache();",
          "392:         }",
          "393:         void ClearCache();",
          "394:         void AddFuncRange(void * address, uint bytes);",
          "395:         void RemoveFuncRange(void * address);",
          "396:         void * GetPageAddr(void * address);",
          "397:         bool IsNativeAddr(void * address);",
          "398:         JITPageAddrToFuncRangeMap * GetJITPageAddrToFuncRangeMap();",
          "399:         LargeJITFuncAddrToSizeMap * GetLargeJITFuncAddrToSizeMap();",
          "400:         static CriticalSection * GetCriticalSection() { return &cs; }",
          "401:     };",
          "403:     class ScriptContext : public ScriptContextBase, public ScriptContextInfo",
          "404:     {",
          "405:         friend class LowererMD;",
          "406:         friend class RemoteScriptContext;",
          "407:         friend class GlobalObject; // InitializeCache",
          "408:         friend class SourceTextModuleRecord; // for module bytecode gen.",
          "410:     public:",
          "411:         static DWORD GetThreadContextOffset() { return offsetof(ScriptContext, threadContext); }",
          "412:         static DWORD GetOptimizationOverridesOffset() { return offsetof(ScriptContext, optimizationOverrides); }",
          "413:         static DWORD GetRecyclerOffset() { return offsetof(ScriptContext, recycler); }",
          "414:         static DWORD GetNumberAllocatorOffset() { return offsetof(ScriptContext, numberAllocator); }",
          "416:         JITPageAddrToFuncRangeCache * GetJitFuncRangeCache();",
          "417:         JITPageAddrToFuncRangeCache * jitFuncRangeCache;",
          "419:         ScriptContext *next;",
          "420:         ScriptContext *prev;",
          "421:         bool IsRegistered() { return next != nullptr || prev != nullptr || threadContext->GetScriptContextList() == this; }",
          "422:         union",
          "423:         {",
          "424:             int64 int64Val; // stores the double & float result for Asm interpreter",
          "425:             double dbVal; // stores the double & float result for Asm interpreter",
          "426:             AsmJsSIMDValue simdVal; // stores raw simd result for Asm interpreter",
          "427:         } asmJsReturnValue;",
          "428:         static DWORD GetAsmJsReturnValueOffset() { return offsetof(ScriptContext, asmJsReturnValue); }",
          "430:         ScriptContextOptimizationOverrideInfo optimizationOverrides;",
          "432:         Js::JavascriptMethod CurrentThunk;",
          "433:         Js::JavascriptMethod CurrentCrossSiteThunk;",
          "434:         Js::JavascriptMethod DeferredParsingThunk;",
          "435:         Js::JavascriptMethod DeferredDeserializationThunk;",
          "436:         Js::JavascriptMethod DispatchDefaultInvoke;",
          "437:         Js::JavascriptMethod DispatchProfileInvoke;",
          "439: #ifdef ENABLE_SCRIPT_DEBUGGING",
          "440:         typedef HRESULT (*GetDocumentContextFunction)(",
          "441:             ScriptContext *pContext,",
          "442:             Js::FunctionBody *pFunctionBody,",
          "443:             IDebugDocumentContext **ppDebugDocumentContext);",
          "444:         GetDocumentContextFunction GetDocumentContext;",
          "445: #endif // ENABLE_SCRIPT_DEBUGGING",
          "447: #ifdef ENABLE_SCRIPT_PROFILING",
          "448:         typedef HRESULT (*CleanupDocumentContextFunction)(ScriptContext *pContext);",
          "449:         CleanupDocumentContextFunction CleanupDocumentContext;",
          "450: #endif",
          "452:         const ScriptContextBase* GetScriptContextBase() const { return static_cast<const ScriptContextBase*>(this); }",
          "454:         void RedeferFunctionBodies(ActiveFunctionSet *pActive, uint inactiveThreshold);",
          "455:         bool DoUndeferGlobalFunctions() const;",
          "457:         bool IsUndeclBlockVar(Var var) const { return this->javascriptLibrary->IsUndeclBlockVar(var); }",
          "459:         void TrackPid(const PropertyRecord* propertyRecord);",
          "460:         void TrackPid(PropertyId propertyId);",
          "462:         bool IsTrackedPropertyId(Js::PropertyId propertyId);",
          "463:         void InvalidateHostObjects()",
          "464:         {",
          "465:             AssertMsg(!isClosed, \"Host Object invalidation should occur before the engine is fully closed. Figure our how isClosed got set beforehand.\");",
          "466:             isInvalidatedForHostObjects = true;",
          "467:         }",
          "468:         bool IsInvalidatedForHostObjects()",
          "469:         {",
          "470:             return isInvalidatedForHostObjects;",
          "471:         }",
          "473: #if ENABLE_NATIVE_CODEGEN",
          "474:         void InitializeRemoteScriptContext();",
          "475: #endif",
          "477: #ifdef ENABLE_JS_ETW",
          "478:         void EmitStackTraceEvent(__in UINT64 operationID, __in USHORT maxFrameCount, bool emitV2AsyncStackEvent);",
          "479: #endif",
          "481:         void SetIsDiagnosticsScriptContext(bool set) { this->isDiagnosticsScriptContext = set; }",
          "482:         bool IsDiagnosticsScriptContext() const { return this->isDiagnosticsScriptContext; }",
          "484:         bool IsScriptContextInNonDebugMode() const;",
          "485:         bool IsScriptContextInDebugMode() const;",
          "486:         bool IsScriptContextInSourceRundownOrDebugMode() const;",
          "487:         bool IsRunningScript() const { return this->threadContext->GetScriptEntryExit() != nullptr; }",
          "489:         typedef JsUtil::List<RecyclerWeakReference<Utf8SourceInfo>*, Recycler, false, Js::WeakRefFreeListedRemovePolicy> CalleeSourceList;",
          "490:         RecyclerRootPtr<CalleeSourceList> calleeUtf8SourceInfoList;",
          "491:         void AddCalleeSourceInfoToList(Utf8SourceInfo* sourceInfo);",
          "492:         bool HaveCalleeSources() { return calleeUtf8SourceInfoList && !calleeUtf8SourceInfoList->Empty(); }",
          "494:         template<class TMapFunction>",
          "495:         void MapCalleeSources(TMapFunction map)",
          "496:         {",
          "497:             if (this->HaveCalleeSources())",
          "498:             {",
          "499:                 calleeUtf8SourceInfoList->Map([&](uint i, RecyclerWeakReference<Js::Utf8SourceInfo>* sourceInfoWeakRef)",
          "500:                 {",
          "501:                     if (calleeUtf8SourceInfoList->IsItemValid(i))",
          "502:                     {",
          "503:                         Js::Utf8SourceInfo* sourceInfo = sourceInfoWeakRef->Get();",
          "504:                         map(sourceInfo);",
          "505:                     }",
          "506:                 });",
          "507:             }",
          "508:             if (calleeUtf8SourceInfoList)",
          "509:             {",
          "510:                 calleeUtf8SourceInfoList.Unroot(this->GetRecycler());",
          "511:             }",
          "512:         }",
          "514: #ifdef ASMJS_PLAT",
          "515:         inline AsmJsCodeGenerator* GetAsmJsCodeGenerator() const{return asmJsCodeGenerator;}",
          "516:         AsmJsCodeGenerator* InitAsmJsCodeGenerator();",
          "517: #endif",
          "519:         bool IsExceptionWrapperForBuiltInsEnabled();",
          "520:         static bool IsExceptionWrapperForBuiltInsEnabled(ScriptContext* scriptContext);",
          "521:         static bool IsExceptionWrapperForHelpersEnabled(ScriptContext* scriptContext);",
          "522:         bool IsEnumerateNonUserFunctionsOnly() const { return m_enumerateNonUserFunctionsOnly; }",
          "523: #ifdef ENABLE_SCRIPT_PROFILING",
          "524:         bool IsTraceDomCall() const { return !!m_fTraceDomCall; }",
          "525: #elif defined(ENABLE_SCRIPT_DEBUGGING)",
          "526:         bool IsTraceDomCall() const { return false; }",
          "527: #endif",
          "529:         InlineCache * GetValueOfInlineCache() const { return valueOfInlineCache;}",
          "530:         InlineCache * GetToStringInlineCache() const { return toStringInlineCache; }",
          "532:     private:",
          "533:         PropertyStringMap* propertyStrings[80];",
          "535:         JavascriptFunction* GenerateRootFunction(ParseNodePtr parseTree, uint sourceIndex, Parser* parser, uint32 grfscr, CompileScriptException * pse, const char16 *rootDisplayName);",
          "537:         typedef void (*EventHandler)(ScriptContext *);",
          "538:         ScriptContext ** registeredPrototypeChainEnsuredToHaveOnlyWritableDataPropertiesScriptContext;",
          "540:         ArenaAllocator generalAllocator;",
          "541: #ifdef ENABLE_BASIC_TELEMETRY",
          "542:         ArenaAllocator telemetryAllocator;",
          "543: #endif",
          "545:         ArenaAllocator dynamicProfileInfoAllocator;",
          "546:         InlineCacheAllocator inlineCacheAllocator;",
          "547:         CacheAllocator isInstInlineCacheAllocator;",
          "548:         CacheAllocator forInCacheAllocator;",
          "550:         ArenaAllocator* interpreterArena;",
          "551:         ArenaAllocator* guestArena;",
          "553:         ArenaAllocator* diagnosticArena;",
          "555:         PSCRIPTCONTEXT_HANDLE m_remoteScriptContextAddr;",
          "557:         bool startupComplete; // Indicates if the heuristic startup phase for this script context is complete",
          "558:         bool isInvalidatedForHostObjects;  // Indicates that we've invalidate all objects in the host so stop calling them.",
          "559:         bool isEnumeratingRecyclerObjects; // Indicates this scriptContext is enumerating recycler objects. Used by recycler enumerating callbacks to filter out other unrelated scriptContexts.",
          "560:         bool m_enumerateNonUserFunctionsOnly; // Indicates that recycler enumeration callback will consider only non-user functions (which are built-ins, external, winrt etc).",
          "562:         ThreadContext* threadContext;",
          "563:         TypeId  directHostTypeId;",
          "565:         InlineCache * valueOfInlineCache;",
          "566:         InlineCache * toStringInlineCache;",
          "568:         typedef JsUtil::BaseHashSet<Js::PropertyId, ArenaAllocator> PropIdSetForConstProp;",
          "569:         PropIdSetForConstProp * intConstPropsOnGlobalObject;",
          "570:         PropIdSetForConstProp * intConstPropsOnGlobalUserObject;",
          "572:         void * firstInterpreterFrameReturnAddress;",
          "573: #ifdef SEPARATE_ARENA",
          "574:         ArenaAllocator sourceCodeAllocator;",
          "575:         ArenaAllocator regexAllocator;",
          "576: #endif",
          "577: #ifdef NEED_MISC_ALLOCATOR",
          "578:         ArenaAllocator miscAllocator;",
          "579: #endif",
          "581: #if DBG",
          "582:         JsUtil::BaseHashSet<void *, ArenaAllocator> bindRef;",
          "583:         int m_iProfileSession;",
          "584: #endif",
          "586: #ifdef PROFILE_EXEC",
          "587:         ScriptContextProfiler * profiler;",
          "588:         bool isProfilerCreated;",
          "589:         bool disableProfiler;",
          "590:         bool ensureParentInfo;",
          "592:         Profiler * CreateProfiler();",
          "593: #endif",
          "594: #ifdef PROFILE_MEM",
          "595:         bool profileMemoryDump;",
          "596: #endif",
          "597: #ifdef PROFILE_STRINGS",
          "598:         StringProfiler* stringProfiler;",
          "599: #endif",
          "602: public:",
          "603: #ifdef PROFILE_TYPES",
          "604:         int convertNullToSimpleCount;",
          "605:         int convertNullToSimpleDictionaryCount;",
          "606:         int convertNullToDictionaryCount;",
          "607:         int convertDeferredToDictionaryCount;",
          "608:         int convertDeferredToSimpleDictionaryCount;",
          "609:         int convertSimpleToDictionaryCount;",
          "610:         int convertSimpleToSimpleDictionaryCount;",
          "611:         int convertPathToDictionaryCount1;",
          "612:         int convertPathToDictionaryCount2;",
          "613:         int convertPathToDictionaryCount3;",
          "614:         int convertPathToDictionaryCount4;",
          "615:         int convertPathToSimpleDictionaryCount;",
          "616:         int convertSimplePathToPathCount;",
          "617:         int convertSimpleDictionaryToDictionaryCount;",
          "618:         int convertSimpleSharedDictionaryToNonSharedCount;",
          "619:         int convertSimpleSharedToNonSharedCount;",
          "620:         int simplePathTypeHandlerCount;",
          "621:         int pathTypeHandlerCount;",
          "622:         int promoteCount;",
          "623:         int cacheCount;",
          "624:         int branchCount;",
          "625:         int maxPathLength;",
          "626:         int typeCount[TypeIds_Limit];",
          "627:         int instanceCount[TypeIds_Limit];",
          "628: #endif",
          "631: #ifdef PROFILE_BAILOUT_RECORD_MEMORY",
          "632:         __int64 bailOutRecordBytes;",
          "633:         __int64 bailOutOffsetBytes;",
          "634:         __int64 codeSize;",
          "635: #endif",
          "637: #ifdef  PROFILE_OBJECT_LITERALS",
          "638:         int objectLiteralInstanceCount;",
          "639:         int objectLiteralPathCount;",
          "640:         int objectLiteralCount[TypePath::MaxPathTypeHandlerLength];",
          "641:         int objectLiteralSimpleDictionaryCount;",
          "642:         uint32 objectLiteralMaxLength;",
          "643:         int objectLiteralPromoteCount;",
          "644:         int objectLiteralCacheCount;",
          "645:         int objectLiteralBranchCount;",
          "646: #endif",
          "647: #if DBG_DUMP",
          "648:         uint byteCodeDataSize;",
          "649:         uint byteCodeAuxiliaryDataSize;",
          "650:         uint byteCodeAuxiliaryContextDataSize;",
          "651:         uint byteCodeHistogram[static_cast<uint>(OpCode::ByteCodeLast)];",
          "652:         uint32 forinCache;",
          "653:         uint32 forinNoCache;",
          "654: #endif",
          "655: #ifdef BGJIT_STATS",
          "656:         uint interpretedCount;",
          "657:         uint funcJITCount;",
          "658:         uint loopJITCount;",
          "659:         uint bytecodeJITCount;",
          "660:         uint interpretedCallsHighPri;",
          "661:         uint maxFuncInterpret;",
          "662:         uint jitCodeUsed;",
          "663:         uint funcJitCodeUsed;",
          "664:         uint speculativeJitCount;",
          "665: #endif",
          "667: #ifdef REJIT_STATS",
          "669:         typedef JsUtil::BaseDictionary<uint, uint, ArenaAllocator> BailoutStatsMap;",
          "671:         struct RejitStats",
          "672:         {",
          "673:             uint *m_rejitReasonCounts;",
          "674:             BailoutStatsMap* m_bailoutReasonCounts;",
          "676:             uint  m_totalRejits;",
          "677:             uint  m_totalBailouts;",
          "679:             RejitStats(ScriptContext *scriptContext) : m_totalRejits(0), m_totalBailouts(0)",
          "680:             {",
          "681:                 m_rejitReasonCounts = AnewArrayZ(scriptContext->GeneralAllocator(), uint, NumRejitReasons);",
          "682:                 m_bailoutReasonCounts = Anew(scriptContext->GeneralAllocator(), BailoutStatsMap, scriptContext->GeneralAllocator());",
          "683:             }",
          "684:         };",
          "686:         void LogDataForFunctionBody(Js::FunctionBody *body, uint idx, bool isRejit);",
          "688:         void LogRejit(Js::FunctionBody *body, uint reason);",
          "689:         void LogBailout(Js::FunctionBody *body, uint kind);",
          "692:         typedef JsUtil::WeaklyReferencedKeyDictionary<const Js::FunctionBody, RejitStats*> RejitStatsMap;",
          "693:         RejitStatsMap* rejitStatsMap;",
          "695:         BailoutStatsMap *bailoutReasonCounts;",
          "696:         uint *rejitReasonCounts;",
          "697: #endif",
          "698: #ifdef ENABLE_BASIC_TELEMETRY",
          "700:     private:",
          "701:         ScriptContextTelemetry* telemetry;",
          "702:     public:",
          "703:         ScriptContextTelemetry& GetTelemetry();",
          "704:         bool HasTelemetry();",
          "706: #endif",
          "707: #ifdef INLINE_CACHE_STATS",
          "710:         struct CacheData",
          "711:         {",
          "712:             uint hits;",
          "713:             uint misses;",
          "714:             uint collisions;",
          "715:             bool isGetCache;",
          "716:             Js::PropertyId propertyId;",
          "718:             CacheData() : hits(0), misses(0), collisions(0), isGetCache(false), propertyId(Js::PropertyIds::_none) { }",
          "719:         };",
          "722:         typedef JsUtil::BaseDictionary<const Js::PolymorphicInlineCache*, CacheData*, Recycler> CacheDataMap;",
          "723:         CacheDataMap *cacheDataMap;",
          "725:         void LogCacheUsage(Js::PolymorphicInlineCache *cache, bool isGet, Js::PropertyId propertyId, bool hit, bool collision);",
          "726: #endif",
          "728: #ifdef FIELD_ACCESS_STATS",
          "729:         typedef SList<FieldAccessStatsPtr, Recycler> FieldAccessStatsList;",
          "731:         struct FieldAccessStatsEntry",
          "732:         {",
          "733:             Field(RecyclerWeakReference<FunctionBody>*) functionBodyWeakRef;",
          "734:             Field(FieldAccessStatsList) stats;",
          "736:             FieldAccessStatsEntry(RecyclerWeakReference<FunctionBody>* functionBodyWeakRef, Recycler* recycler)",
          "737:                 : functionBodyWeakRef(functionBodyWeakRef), stats(recycler) {}",
          "738:         };",
          "740:         typedef JsUtil::BaseDictionary<uint, FieldAccessStatsEntry*, Recycler> FieldAccessStatsByFunctionNumberMap;",
          "742:         FieldAccessStatsByFunctionNumberMap* fieldAccessStatsByFunctionNumber;",
          "744:         void RecordFieldAccessStats(FunctionBody* functionBody, FieldAccessStatsPtr fieldAccessStats);",
          "745: #endif",
          "747: #ifdef MISSING_PROPERTY_STATS",
          "748:         int missingPropertyMisses;",
          "749:         int missingPropertyHits;",
          "750:         int missingPropertyCacheAttempts;",
          "752:         void RecordMissingPropertyMiss();",
          "753:         void RecordMissingPropertyHit();",
          "754:         void RecordMissingPropertyCacheAttempt();",
          "755: #endif",
          "757:         bool IsIntConstPropertyOnGlobalObject(Js::PropertyId propId);",
          "758:         void TrackIntConstPropertyOnGlobalObject(Js::PropertyId propId);",
          "759:         bool IsIntConstPropertyOnGlobalUserObject(Js::PropertyId propertyId);",
          "760:         void TrackIntConstPropertyOnGlobalUserObject(Js::PropertyId propertyId);",
          "762: private:",
          "766: #if ENABLE_REGEX_CONFIG_OPTIONS",
          "767:         UnifiedRegex::DebugWriter* regexDebugWriter;",
          "768:         UnifiedRegex::RegexStatsDatabase* regexStatsDatabase;",
          "769: #endif",
          "770:         UnifiedRegex::TrigramAlphabet* trigramAlphabet;",
          "771:         UnifiedRegex::RegexStacks *regexStacks;",
          "773:         JsUtil::Stack<Var>* operationStack;",
          "774:         Recycler* recycler;",
          "775:         RecyclerJavascriptNumberAllocator numberAllocator;",
          "777:         ScriptConfiguration config;",
          "778:         CharClassifier *charClassifier;",
          "781: #if ENABLE_NATIVE_CODEGEN",
          "782: #if DYNAMIC_INTERPRETER_THUNK",
          "783:         InterpreterThunkEmitter* interpreterThunkEmitter;",
          "784: #endif",
          "785:         BackgroundParser *backgroundParser;",
          "786: #ifdef ASMJS_PLAT",
          "787:         InterpreterThunkEmitter* asmJsInterpreterThunkEmitter;",
          "788:         AsmJsCodeGenerator* asmJsCodeGenerator;",
          "789:         typedef JsUtil::BaseDictionary<void *, SList<AsmJsScriptFunction *>*, ArenaAllocator> AsmFunctionMap;",
          "790:         AsmFunctionMap* asmJsEnvironmentMap;",
          "791:         ArenaAllocator* debugTransitionAlloc;",
          "792: #endif",
          "793:         NativeCodeGenerator* nativeCodeGen;",
          "794: #endif",
          "796:         DateTime::DaylightTimeHelper daylightTimeHelper;",
          "797:         DateTime::Utility dateTimeUtility;",
          "799: public:",
          "800:         inline const WCHAR *const GetStandardName(size_t *nameLength, DateTime::YMD *ymd = NULL)",
          "801:         {",
          "802:             return dateTimeUtility.GetStandardName(nameLength, ymd);",
          "803:         }",
          "805:         inline const WCHAR *const GetDaylightName(size_t *nameLength, DateTime::YMD *ymd = NULL)",
          "806:         {",
          "807:             return dateTimeUtility.GetDaylightName(nameLength, ymd);",
          "808:         }",
          "810: private:",
          "811:         HostScriptContext * hostScriptContext;",
          "812:         HaltCallback* scriptEngineHaltCallback;",
          "813:         EventHandler scriptStartEventHandler;",
          "814:         EventHandler scriptEndEventHandler;",
          "815: #ifdef FAULT_INJECTION",
          "816:         EventHandler disposeScriptByFaultInjectionEventHandler;",
          "817: #endif",
          "819:         JsUtil::BaseDictionary<uint, JavascriptString *, ArenaAllocator> integerStringMap;",
          "821:         double lastNumberToStringRadix10;",
          "822:         double lastUtcTimeFromStr;",
          "824: #if ENABLE_PROFILE_INFO",
          "825:         bool referencesSharedDynamicSourceContextInfo;",
          "826: #endif",
          "830:         bool isScriptContextActuallyClosed;",
          "831:         bool isFinalized;",
          "832:         bool isEvalRestricted;",
          "833: #if DBG",
          "834:         bool isInitialized;",
          "835:         bool isCloningGlobal;",
          "836: #endif",
          "837:         bool fastDOMenabled;",
          "838:         bool hasUsedInlineCache;",
          "839:         bool hasProtoOrStoreFieldInlineCache;",
          "840:         bool hasIsInstInlineCache;",
          "841:         bool deferredBody;",
          "842:         bool isPerformingNonreentrantWork;",
          "843:         bool isDiagnosticsScriptContext;   // mentions that current script context belongs to the diagnostics OM.",
          "845:         size_t sourceSize;",
          "847:         void CleanSourceListInternal(bool calledDuringMark);",
          "848:         typedef JsUtil::List<RecyclerWeakReference<Utf8SourceInfo>*, Recycler, false, Js::FreeListedRemovePolicy> SourceList;",
          "849:         RecyclerRootPtr<SourceList> sourceList;",
          "851: #ifdef ENABLE_SCRIPT_PROFILING",
          "852:         IActiveScriptProfilerHeapEnum* heapEnum;",
          "857:         IActiveScriptProfilerCallback *m_pProfileCallback;",
          "858:         BOOL m_fTraceFunctionCall;",
          "859:         BOOL m_fTraceNativeFunctionCall;",
          "860:         DWORD m_dwEventMask;",
          "862:         IActiveScriptProfilerCallback2 *m_pProfileCallback2;",
          "863:         BOOL m_fTraceDomCall;",
          "864:         BOOL m_inProfileCallback;",
          "865: #endif // ENABLE_SCRIPT_PROFILING",
          "873:         SListBase<JsUtil::IWeakReferenceDictionary*> weakReferenceDictionaryList;",
          "874:         bool isWeakReferenceDictionaryListCleared;",
          "876:         typedef void(*RaiseMessageToDebuggerFunctionType)(ScriptContext *, DEBUG_EVENT_INFO_TYPE, LPCWSTR, LPCWSTR);",
          "877:         RaiseMessageToDebuggerFunctionType raiseMessageToDebuggerFunctionType;",
          "879:         typedef void(*TransitionToDebugModeIfFirstSourceFn)(ScriptContext *, Utf8SourceInfo *);",
          "880:         TransitionToDebugModeIfFirstSourceFn transitionToDebugModeIfFirstSourceFn;",
          "882:         ScriptContext(ThreadContext* threadContext);",
          "883:         void InitializeAllocations();",
          "884:         void InitializePreGlobal();",
          "885:         void InitializePostGlobal();",
          "886:         void InitializeCache();",
          "888:         bool isDebugContextInitialized;",
          "891:         void EnsureSourceContextInfoMap();",
          "892:         void EnsureDynamicSourceContextInfoMap();",
          "894:         uint moduleSrcInfoCount;",
          "895: #ifdef RUNTIME_DATA_COLLECTION",
          "896:         time_t createTime;",
          "897: #endif",
          "898:         char16 const * url;",
          "900:         void PrintStats();",
          "901:         BOOL LeaveScriptStartCore(void * frameAddress, bool leaveForHost);",
          "903:         void InternalClose();",
          "905:         DebugContext* debugContext;",
          "906:         CriticalSection debugContextCloseCS;",
          "908:     public:",
          "909:         static const int kArrayMatchCh=72;",
          "910:         static const int kMaxArrayMatchIndex=8192;",
          "911:         short arrayMatchItems[kArrayMatchCh];",
          "912:         bool arrayMatchInit;",
          "914: #ifdef LEAK_REPORT",
          "915:         LeakReport::UrlRecord * urlRecord;",
          "916:         bool isRootTrackerScriptContext;",
          "917: #endif",
          "919:         DateTime::DaylightTimeHelper *GetDaylightTimeHelper() { return &daylightTimeHelper; }",
          "920:         DateTime::Utility *GetDateUtility() { return &dateTimeUtility; }",
          "922:         virtual bool IsClosed() const override { return isClosed; }",
          "923:         void SetIsClosed();",
          "925:         bool IsFinalized() const { return isFinalized; }",
          "926:         void SetIsFinalized() { isFinalized = true; }",
          "927:         bool IsActuallyClosed() const { return isScriptContextActuallyClosed; }",
          "928:         void SetEvalRestriction(bool set) { this->isEvalRestricted = set; }",
          "929:         bool IsEvalRestriction() const { return this->isEvalRestricted; }",
          "930: #if ENABLE_NATIVE_CODEGEN",
          "931:         bool IsClosedNativeCodeGenerator() const",
          "932:         {",
          "933:             return !nativeCodeGen || ::IsClosedNativeCodeGenerator(nativeCodeGen);",
          "934:         }",
          "935: #endif",
          "937:         void SetHasUsedInlineCache(bool value) { hasUsedInlineCache = value; }",
          "939:         void SetDirectHostTypeId(TypeId typeId) {directHostTypeId = typeId; }",
          "940:         TypeId GetDirectHostTypeId() const { return directHostTypeId; }",
          "942:         PSCRIPTCONTEXT_HANDLE GetRemoteScriptAddr(bool allowInitialize = true)",
          "943:         {",
          "944: #if ENABLE_OOP_NATIVE_CODEGEN",
          "945:             if (!m_remoteScriptContextAddr && allowInitialize)",
          "946:             {",
          "947:                 InitializeRemoteScriptContext();",
          "948:             }",
          "949: #endif",
          "950:             return m_remoteScriptContextAddr;",
          "951:         }",
          "953:         char16 const * GetUrl() const { return url; }",
          "954:         void SetUrl(BSTR bstr);",
          "955: #ifdef RUNTIME_DATA_COLLECTION",
          "956:         time_t GetCreateTime() const { return createTime; }",
          "957:         uint GetAllocId() const { return allocId; }",
          "958: #endif",
          "959:         void InitializeArrayMatch()",
          "960:         {",
          "961:             if (!arrayMatchInit)",
          "962:             {",
          "963:                 for (int i=0;i<kArrayMatchCh;i++)",
          "964:                 {",
          "965:                     arrayMatchItems[i]= -1;",
          "966:                 }",
          "967:                 arrayMatchInit=true;",
          "968:             }",
          "969:         }",
          "971: #ifdef HEAP_ENUMERATION_VALIDATION",
          "972:         bool IsInitialized() { return this->isInitialized; }",
          "973: #endif",
          "975:         bool IsDebugContextInitialized() const { return this->isDebugContextInitialized; }",
          "976:         DebugContext* GetDebugContext() const { return this->debugContext; }",
          "977:         CriticalSection* GetDebugContextCloseCS() { return &debugContextCloseCS; }",
          "979:         uint callCount;",
          "982:         DWORD webWorkerId;",
          "984:         static ScriptContext * New(ThreadContext * threadContext);",
          "985:         static void Delete(ScriptContext* scriptContext);",
          "987:         ~ScriptContext();",
          "989: #ifdef PROFILE_TYPES",
          "990:         void ProfileTypes();",
          "991: #endif",
          "993: #ifdef PROFILE_OBJECT_LITERALS",
          "994:         void ProfileObjectLiteral();",
          "995: #endif",
          "1000: #if ENABLE_REGEX_CONFIG_OPTIONS",
          "1001:         UnifiedRegex::RegexStatsDatabase* GetRegexStatsDatabase();",
          "1002:         UnifiedRegex::DebugWriter* GetRegexDebugWriter();",
          "1003: #endif",
          "1004:         RegexPatternMruMap* GetDynamicRegexMap() const;",
          "1006:         UnifiedRegex::TrigramAlphabet* GetTrigramAlphabet() { return trigramAlphabet; }",
          "1008:         void SetTrigramAlphabet(UnifiedRegex::TrigramAlphabet * trigramAlphabet);",
          "1010:         UnifiedRegex::RegexStacks *RegexStacks();",
          "1011:         UnifiedRegex::RegexStacks *AllocRegexStacks();",
          "1012:         UnifiedRegex::RegexStacks *SaveRegexStacks();",
          "1013:         void RestoreRegexStacks(UnifiedRegex::RegexStacks *const contStack);",
          "1015:         void InitializeGlobalObject();",
          "1016:         bool IsIntlEnabled();",
          "1017:         JavascriptLibrary* GetLibrary() const { return javascriptLibrary; }",
          "1018:         Js::Cache* Cache() const{ return &this->javascriptLibrary->cache; }",
          "1019:         const JavascriptLibraryBase* GetLibraryBase() const { return javascriptLibrary->GetLibraryBase(); }",
          "1020: #if DBG",
          "1021:         BOOL IsCloningGlobal() const { return isCloningGlobal;}",
          "1022: #endif",
          "1023:         void PushObject(Var object);",
          "1024:         Var PopObject();",
          "1025:         BOOL CheckObject(Var object);",
          "1027:         inline bool IsHeapEnumInProgress() { return GetRecycler()->IsHeapEnumInProgress(); }",
          "1029:         bool IsInterpreted() { return config.IsNoNative(); }",
          "1030:         void ForceNoNative() { config.ForceNoNative(); }",
          "1031:         void ForceNative() { config.ForceNative(); }",
          "1032:         ScriptConfiguration const * GetConfig(void) const { return &config; }",
          "1033:         CharClassifier const * GetCharClassifier(void) const;",
          "1035:         ThreadContext * GetThreadContext() const { return threadContext; }",
          "1037:         static const int MaxEvalSourceSize = 400;",
          "1039:         bool IsInEvalMap(FastEvalMapString const& key, BOOL isIndirect, ScriptFunction **ppFuncScript);",
          "1040:         void AddToEvalMap(FastEvalMapString const& key, BOOL isIndirect, ScriptFunction *pFuncScript);",
          "1042:         template <typename TCacheType>",
          "1043:         void CleanDynamicFunctionCache(TCacheType* cacheType);",
          "1044:         void CleanEvalMapCache(Js::EvalCacheTopLevelDictionary * cacheType);",
          "1046:         template <class TDelegate>",
          "1047:         void MapFunction(TDelegate mapper);",
          "1049:         template <class TDelegate>",
          "1050:         FunctionBody* FindFunction(TDelegate predicate);",
          "1052:         inline bool EnableEvalMapCleanup() { return CONFIG_FLAG(EnableEvalMapCleanup); };",
          "1053:         uint GetNextSourceContextId();",
          "1055:         bool IsInNewFunctionMap(EvalMapString const& key, FunctionInfo **ppFuncInfo);",
          "1056:         void AddToNewFunctionMap(EvalMapString const& key, FunctionInfo *pFuncInfo);",
          "1058:         SourceContextInfo * GetSourceContextInfo(DWORD_PTR hostSourceContext, IActiveScriptDataCache* profileDataCache);",
          "1059:         SourceContextInfo * GetSourceContextInfo(uint hash);",
          "1060:         SourceContextInfo * CreateSourceContextInfo(uint hash, DWORD_PTR hostSourceContext);",
          "1061:         SourceContextInfo * CreateSourceContextInfo(DWORD_PTR hostSourceContext, char16 const * url, size_t len,",
          "1062:             IActiveScriptDataCache* profileDataCache, char16 const * sourceMapUrl = nullptr, size_t sourceMapUrlLen = 0);",
          "1064: #if defined(LEAK_REPORT) || defined(CHECK_MEMORY_LEAK)",
          "1065:         void ClearSourceContextInfoMaps()",
          "1066:         {",
          "1067: #if ENABLE_PROFILE_INFO",
          "1068:               this->referencesSharedDynamicSourceContextInfo = false;",
          "1069: #endif",
          "1070:         }",
          "1071: #endif",
          "1073: #if ENABLE_PROFILE_INFO",
          "1074: #if DBG_DUMP || defined(DYNAMIC_PROFILE_STORAGE) || defined(RUNTIME_DATA_COLLECTION)",
          "1075:         void ClearDynamicProfileList()",
          "1076:         {",
          "1077:             if (this->Cache()->profileInfoList)",
          "1078:             {",
          "1079:                 this->Cache()->profileInfoList->Reset();",
          "1080:                 this->Cache()->profileInfoList = nullptr;",
          "1081:             }",
          "1082:         }",
          "1084:         DynamicProfileInfoList * GetProfileInfoList() { return this->Cache()->profileInfoList; }",
          "1085: #endif",
          "1086: #endif",
          "1088:         SRCINFO const * GetModuleSrcInfo(Js::ModuleID moduleID);",
          "1089:         SourceContextInfoMap* GetSourceContextInfoMap()",
          "1090:         {",
          "1091:             return this->Cache()->sourceContextInfoMap;",
          "1092:         }",
          "1093:         DynamicSourceContextInfoMap* GetDynamicSourceContextInfoMap()",
          "1094:         {",
          "1095:             return this->Cache()->dynamicSourceContextInfoMap;",
          "1096:         }",
          "1098: #if ENABLE_TTD",
          "1100:         HostScriptContextCallbackFunctor TTDHostCallbackFunctor;",
          "1103:         TTD_LOG_PTR_ID ScriptContextLogTag;",
          "1106:         TTD::RuntimeContextInfo* TTDWellKnownInfo;",
          "1109:         TTD::ScriptContextTTD* TTDContextInfo;",
          "1112:         bool TTDSnapshotOrInflateInProgress;",
          "1115:         bool IsTTDSnapshotOrInflateInProgress() const { return this->TTDSnapshotOrInflateInProgress; }",
          "1118:         bool TTDRecordOrReplayModeEnabled;",
          "1119:         bool TTDRecordModeEnabled;",
          "1120:         bool TTDReplayModeEnabled;",
          "1122:         bool TTDShouldPerformRecordOrReplayAction;",
          "1123:         bool TTDShouldPerformRecordAction;",
          "1124:         bool TTDShouldPerformReplayAction;",
          "1126:         bool TTDShouldPerformDebuggerAction;",
          "1127:         bool TTDShouldSuppressGetterInvocationForDebuggerEvaluation;",
          "1130:         bool IsTTDRecordOrReplayModeEnabled() const { return this->TTDRecordOrReplayModeEnabled; }",
          "1133:         bool IsTTDRecordModeEnabled() const { return this->TTDRecordModeEnabled; }",
          "1136:         bool IsTTDReplayModeEnabled() const { return this->TTDReplayModeEnabled; }",
          "1139:         bool ShouldPerformRecordOrReplayAction() const { return this->TTDShouldPerformRecordOrReplayAction; }",
          "1142:         bool ShouldPerformRecordAction() const { return this->TTDShouldPerformRecordAction; }",
          "1145:         bool ShouldPerformReplayAction() const { return this->TTDShouldPerformReplayAction; }",
          "1148:         bool ShouldPerformDebuggerAction() const { return this->TTDShouldPerformDebuggerAction; }",
          "1151:         bool ShouldSuppressGetterInvocationForDebuggerEvaluation() const { return this->TTDShouldSuppressGetterInvocationForDebuggerEvaluation; }",
          "1157:         void InitializeCoreImage_TTD();",
          "1158: #endif",
          "1160:         void SetFirstInterpreterFrameReturnAddress(void * returnAddress) { firstInterpreterFrameReturnAddress = returnAddress;}",
          "1161:         void *GetFirstInterpreterFrameReturnAddress() { return firstInterpreterFrameReturnAddress;}",
          "1163:         void CleanupWeakReferenceDictionaries();",
          "1165:         void Initialize();",
          "1166:         bool Close(bool inDestructor);",
          "1167:         void MarkForClose();",
          "1168: #ifdef ENABLE_PROJECTION",
          "1169:         void SetHostType(int32 hostType) { config.SetHostType(hostType); }",
          "1170:         void SetWinRTConstructorAllowed(bool allowed) { config.SetWinRTConstructorAllowed(allowed); }",
          "1171:         void SetProjectionTargetVersion(DWORD version) { config.SetProjectionTargetVersion(version); }",
          "1172: #endif",
          "1173:         void SetCanOptimizeGlobalLookupFlag(BOOL f){ config.SetCanOptimizeGlobalLookupFlag(f);}",
          "1174:         BOOL CanOptimizeGlobalLookup(){ return config.CanOptimizeGlobalLookup();}",
          "1176:         bool IsFastDOMEnabled() { return fastDOMenabled; }",
          "1177:         void SetFastDOMenabled();",
          "1178:         BOOL VerifyAlive(BOOL isJSFunction = FALSE, ScriptContext* requestScriptContext = nullptr);",
          "1179:         void VerifyAliveWithHostContext(BOOL isJSFunction, HostScriptContext* requestHostScriptContext);",
          "1180:         void AddFunctionBodyToPropIdMap(FunctionBody* body);",
          "1182:         void BindReference(void* addr);",
          "1184:         void InitPropertyStringMap(int i);",
          "1185:         PropertyString* AddPropertyString2(const Js::PropertyRecord* propertyRecord);",
          "1186:         PropertyString* CachePropertyString2(const Js::PropertyRecord* propertyRecord);",
          "1187:         PropertyString* GetPropertyString2(char16 ch1, char16 ch2);",
          "1188:         void FindPropertyRecord(__in LPCWSTR pszPropertyName, __in int propertyNameLength, PropertyRecord const** propertyRecord);",
          "1189:         JsUtil::List<const RecyclerWeakReference<Js::PropertyRecord const>*>* FindPropertyIdNoCase(__in LPCWSTR pszPropertyName, __in int propertyNameLength);",
          "1191:         void FindPropertyRecord(JavascriptString* pstName, PropertyRecord const** propertyRecord);",
          "1192:         PropertyRecord const * GetPropertyName(PropertyId propertyId);",
          "1193:         PropertyRecord const * GetPropertyNameLocked(PropertyId propertyId);",
          "1194:         void GetOrAddPropertyRecord(JsUtil::CharacterBuffer<WCHAR> const& propName, PropertyRecord const** propertyRecord);",
          "1195:         template <size_t N> void GetOrAddPropertyRecord(const char16(&propertyName)[N], PropertyRecord const** propertyRecord)",
          "1196:         {",
          "1197:             GetOrAddPropertyRecord(propertyName, N - 1, propertyRecord);",
          "1198:         }",
          "1199:         PropertyId GetOrAddPropertyIdTracked(JsUtil::CharacterBuffer<WCHAR> const& propName);",
          "1200:         template <size_t N> PropertyId GetOrAddPropertyIdTracked(const char16(&propertyName)[N])",
          "1201:         {",
          "1202:             return GetOrAddPropertyIdTracked(propertyName, N - 1);",
          "1203:         }",
          "1204:         PropertyId GetOrAddPropertyIdTracked(__in_ecount(propertyNameLength) LPCWSTR pszPropertyName, __in int propertyNameLength);",
          "1205:         void GetOrAddPropertyRecord(__in_ecount(propertyNameLength) LPCWSTR pszPropertyName, __in int propertyNameLength, PropertyRecord const** propertyRecord);",
          "1206:         BOOL IsNumericPropertyId(PropertyId propertyId, uint32* value);",
          "1208:         void RegisterWeakReferenceDictionary(JsUtil::IWeakReferenceDictionary* weakReferenceDictionary);",
          "1209:         void ResetWeakReferenceDictionaryList() { weakReferenceDictionaryList.Reset(); }",
          "1211:         BOOL ReserveStaticTypeIds(__in int first, __in int last);",
          "1212:         TypeId ReserveTypeIds(int count);",
          "1213:         TypeId CreateTypeId();",
          "1215:         WellKnownHostType GetWellKnownHostType(Js::TypeId typeId) { return threadContext->GetWellKnownHostType(typeId); }",
          "1216:         void SetWellKnownHostTypeId(WellKnownHostType wellKnownType, Js::TypeId typeId) { threadContext->SetWellKnownHostTypeId(wellKnownType, typeId); }",
          "1218:         ParseNodePtr ParseScript(Parser* parser, const byte* script,",
          "1219:             size_t cb, SRCINFO const * pSrcInfo,",
          "1220:             CompileScriptException * pse, Utf8SourceInfo** ppSourceInfo,",
          "1221:             const char16 *rootDisplayName, LoadScriptFlag loadScriptFlag,",
          "1222:             uint* sourceIndex, Js::Var scriptSource = nullptr);",
          "1224:         JavascriptFunction* LoadScript(const byte* script, size_t cb,",
          "1225:             SRCINFO const * pSrcInfo,",
          "1226:             CompileScriptException * pse, Utf8SourceInfo** ppSourceInfo,",
          "1227:             const char16 *rootDisplayName, LoadScriptFlag loadScriptFlag,",
          "1228:             Js::Var scriptSource = nullptr);",
          "1230:         ArenaAllocator* GeneralAllocator() { return &generalAllocator; }",
          "1232: #ifdef ENABLE_BASIC_TELEMETRY",
          "1233:         ArenaAllocator* TelemetryAllocator() { return &telemetryAllocator; }",
          "1234: #endif",
          "1236: #ifdef SEPARATE_ARENA",
          "1237:         ArenaAllocator* SourceCodeAllocator() { return &sourceCodeAllocator; }",
          "1238:         ArenaAllocator* RegexAllocator() { return &regexAllocator; }",
          "1239: #else",
          "1240:         ArenaAllocator* SourceCodeAllocator() { return &generalAllocator; }",
          "1241:         ArenaAllocator* RegexAllocator() { return &generalAllocator; }",
          "1242: #endif",
          "1243: #ifdef NEED_MISC_ALLOCATOR",
          "1244:         ArenaAllocator* MiscAllocator() { return &miscAllocator; }",
          "1245: #endif",
          "1246:         InlineCacheAllocator* GetInlineCacheAllocator() { return &inlineCacheAllocator; }",
          "1247:         CacheAllocator* GetIsInstInlineCacheAllocator() { return &isInstInlineCacheAllocator; }",
          "1248:         CacheAllocator * ForInCacheAllocator() { return &forInCacheAllocator; }",
          "1249:         ArenaAllocator* DynamicProfileInfoAllocator() { return &dynamicProfileInfoAllocator; }",
          "1251:         ArenaAllocator* AllocatorForDiagnostics();",
          "1253:         Js::TempArenaAllocatorObject* GetTemporaryAllocator(LPCWSTR name);",
          "1254:         void ReleaseTemporaryAllocator(Js::TempArenaAllocatorObject* tempAllocator);",
          "1255:         Js::TempGuestArenaAllocatorObject* GetTemporaryGuestAllocator(LPCWSTR name);",
          "1256:         void ReleaseTemporaryGuestAllocator(Js::TempGuestArenaAllocatorObject* tempAllocator);",
          "1258:         bool EnsureInterpreterArena(ArenaAllocator **);",
          "1259:         void ReleaseInterpreterArena();",
          "1261:         ArenaAllocator* GetGuestArena() const",
          "1262:         {",
          "1263:             return guestArena;",
          "1264:         }",
          "1266:         void ReleaseGuestArena();",
          "1268:         Recycler* GetRecycler() const { return recycler; }",
          "1269:         RecyclerJavascriptNumberAllocator * GetNumberAllocator() { return &numberAllocator; }",
          "1270: #if ENABLE_NATIVE_CODEGEN",
          "1271:         NativeCodeGenerator * GetNativeCodeGenerator() const { return nativeCodeGen; }",
          "1272: #endif",
          "1273: #if ENABLE_BACKGROUND_PARSING",
          "1274:         BackgroundParser * GetBackgroundParser() const { return backgroundParser; }",
          "1275: #endif",
          "1277:         void OnScriptStart(bool isRoot, bool isScript);",
          "1278:         void OnScriptEnd(bool isRoot, bool isForcedEnd);",
          "1280:         template <bool stackProbe, bool leaveForHost>",
          "1281:         bool LeaveScriptStart(void * frameAddress);",
          "1282:         template <bool leaveForHost>",
          "1283:         void LeaveScriptEnd(void * frameAddress);",
          "1285:         HostScriptContext * GetHostScriptContext() const { return hostScriptContext; }",
          "1286:         void SetHostScriptContext(HostScriptContext *  hostScriptContext);",
          "1287:         void SetScriptEngineHaltCallback(HaltCallback* scriptEngine);",
          "1288:         void ClearHostScriptContext();",
          "1290:         IActiveScriptProfilerHeapEnum* GetHeapEnum();",
          "1291:         void SetHeapEnum(IActiveScriptProfilerHeapEnum* newHeapEnum);",
          "1292:         void ClearHeapEnum();",
          "1294:         void SetScriptStartEventHandler(EventHandler eventHandler);",
          "1295:         void SetScriptEndEventHandler(EventHandler eventHandler);",
          "1296: #ifdef FAULT_INJECTION",
          "1297:         void DisposeScriptContextByFaultInjection();",
          "1298:         void SetDisposeDisposeByFaultInjectionEventHandler(EventHandler eventHandler);",
          "1299: #endif",
          "1300:         EnumeratedObjectCache* GetEnumeratedObjectCache() { return &(this->Cache()->enumObjCache); }",
          "1301:         PropertyString* TryGetPropertyString(PropertyId propertyId);",
          "1302:         PropertyString* GetPropertyString(PropertyId propertyId);",
          "1303:         void InvalidatePropertyStringCache(PropertyId propertyId, Type* type);",
          "1304:         JavascriptString* GetIntegerString(Var aValue);",
          "1305:         JavascriptString* GetIntegerString(int value);",
          "1306:         JavascriptString* GetIntegerString(uint value);",
          "1308:         void CheckEvalRestriction();",
          "1310:         RecyclableObject* GetMissingPropertyResult();",
          "1311:         RecyclableObject* GetMissingItemResult();",
          "1313:         bool HasRecordedException() const { return threadContext->GetRecordedException() != nullptr; }",
          "1314:         Js::JavascriptExceptionObject * GetAndClearRecordedException(bool *considerPassingToDebugger = nullptr);",
          "1315:         void RecordException(Js::JavascriptExceptionObject * exceptionObject, bool propagateToDebugger = false);",
          "1316:         __declspec(noreturn) void RethrowRecordedException(JavascriptExceptionObject::HostWrapperCreateFuncType hostWrapperCreateFunc);",
          "1318: #if ENABLE_NATIVE_CODEGEN",
          "1319:         BOOL IsNativeAddress(void * codeAddr);",
          "1320: #endif",
          "1322:         uint SaveSourceCopy(Utf8SourceInfo* sourceInfo, int cchLength, bool isCesu8);",
          "1323:         bool SaveSourceCopy(Utf8SourceInfo* const sourceInfo, int cchLength, bool isCesu8, uint * index);",
          "1325:         uint SaveSourceNoCopy(Utf8SourceInfo* sourceInfo, int cchLength, bool isCesu8);",
          "1327:         void CloneSources(ScriptContext* sourceContext);",
          "1328:         Utf8SourceInfo* GetSource(uint sourceIndex);",
          "1330:         uint SourceCount() const { return (uint)sourceList->Count(); }",
          "1331:         void CleanSourceList() { CleanSourceListInternal(false); }",
          "1332:         SourceList* GetSourceList() const { return sourceList; }",
          "1333:         bool IsItemValidInSourceList(int index);",
          "1335:         template <typename TFunction>",
          "1336:         void MapScript(TFunction mapper)",
          "1337:         {",
          "1338:             this->sourceList->Map([mapper] (int, RecyclerWeakReference<Utf8SourceInfo>* sourceInfoWeakReference)",
          "1339:             {",
          "1340:                 Utf8SourceInfo* strongRef = sourceInfoWeakReference->Get();",
          "1342:                 if (strongRef)",
          "1343:                 {",
          "1344:                     mapper(strongRef);",
          "1345:                 }",
          "1346:             });",
          "1347:         }",
          "1349: #ifdef CHECK_STACKWALK_EXCEPTION",
          "1350:         void SetIgnoreStackWalkException() {threadContext->GetScriptEntryExit()->ignoreStackWalkException = true; }",
          "1351: #endif",
          "1356:         void EnforceEERHasCaller() { threadContext->GetScriptEntryExit()->hasCaller = true; }",
          "1358:         void SetRaiseMessageToDebuggerFunction(RaiseMessageToDebuggerFunctionType function)",
          "1359:         {",
          "1360:             raiseMessageToDebuggerFunctionType = function;",
          "1361:         }",
          "1363:         void RaiseMessageToDebugger(DEBUG_EVENT_INFO_TYPE messageType, LPCWSTR message, LPCWSTR url)",
          "1364:         {",
          "1365:             if (raiseMessageToDebuggerFunctionType != nullptr)",
          "1366:             {",
          "1367:                 raiseMessageToDebuggerFunctionType(this, messageType, message, url);",
          "1368:             }",
          "1369:         }",
          "1371:         void SetTransitionToDebugModeIfFirstSourceFn(TransitionToDebugModeIfFirstSourceFn function)",
          "1372:         {",
          "1373:             transitionToDebugModeIfFirstSourceFn = function;",
          "1374:         }",
          "1376:         void TransitionToDebugModeIfFirstSource(Utf8SourceInfo *sourceInfo)",
          "1377:         {",
          "1378:             if (transitionToDebugModeIfFirstSourceFn != nullptr)",
          "1379:             {",
          "1380:                 transitionToDebugModeIfFirstSourceFn(this, sourceInfo);",
          "1381:             }",
          "1382:         }",
          "1384:         void AddSourceSize(size_t sourceSize)",
          "1385:         {",
          "1386:             this->sourceSize += sourceSize;",
          "1387:             this->threadContext->AddSourceSize(sourceSize);",
          "1388:         }",
          "1390:         size_t GetSourceSize()",
          "1391:         {",
          "1392:             return this->sourceSize;",
          "1393:         }",
          "1395:         BOOL SetDeferredBody(BOOL set)",
          "1396:         {",
          "1397:             bool old = this->deferredBody;",
          "1398:             this->deferredBody = !!set;",
          "1399:             return old;",
          "1400:         }",
          "1402:         BOOL GetDeferredBody(void) const",
          "1403:         {",
          "1404:             return this->deferredBody;",
          "1405:         }",
          "1407:     public:",
          "1408:         void FreeFunctionEntryPoint(Js::JavascriptMethod method);",
          "1410:     private:",
          "1411:         uint CloneSource(Utf8SourceInfo* info);",
          "1412:     public:",
          "1413:         void RegisterProtoInlineCache(InlineCache *pCache, PropertyId propId);",
          "1414:         void InvalidateProtoCaches(const PropertyId propertyId);",
          "1415:         void InvalidateAllProtoCaches();",
          "1416:         void RegisterStoreFieldInlineCache(InlineCache *pCache, PropertyId propId);",
          "1417:         void InvalidateStoreFieldCaches(const PropertyId propertyId);",
          "1418:         void InvalidateAllStoreFieldCaches();",
          "1419:         void RegisterIsInstInlineCache(Js::IsInstInlineCache * cache, Js::Var function);",
          "1420: #if DBG",
          "1421:         bool IsIsInstInlineCacheRegistered(Js::IsInstInlineCache * cache, Js::Var function);",
          "1422: #endif",
          "1423:         void ClearInlineCaches();",
          "1424:         void ClearIsInstInlineCaches();",
          "1425:         void ClearForInCaches();",
          "1426: #ifdef PERSISTENT_INLINE_CACHES",
          "1427:         void ClearInlineCachesWithDeadWeakRefs();",
          "1428: #endif",
          "1429:         void ClearScriptContextCaches();",
          "1430: #if ENABLE_NATIVE_CODEGEN",
          "1431:         void RegisterConstructorCache(Js::PropertyId propertyId, Js::ConstructorCache* cache);",
          "1432: #endif",
          "1434:     public:",
          "1435:         void RegisterPrototypeChainEnsuredToHaveOnlyWritableDataPropertiesScriptContext();",
          "1436:     private:",
          "1437:         void DoRegisterPrototypeChainEnsuredToHaveOnlyWritableDataPropertiesScriptContext();",
          "1438:     public:",
          "1439:         void ClearPrototypeChainEnsuredToHaveOnlyWritableDataPropertiesCaches();",
          "1441:     public:",
          "1442:         JavascriptString * GetLastNumberToStringRadix10(double value);",
          "1443:         void SetLastNumberToStringRadix10(double value, JavascriptString * str);",
          "1444:         bool GetLastUtcTimeFromStr(JavascriptString * str, double& dbl);",
          "1445:         void SetLastUtcTimeFromStr(JavascriptString * str, double value);",
          "1446:         bool IsNoContextSourceContextInfo(SourceContextInfo *sourceContextInfo) const",
          "1447:         {",
          "1448:             return sourceContextInfo == this->Cache()->noContextSourceContextInfo;",
          "1449:         }",
          "1451:         BOOL IsProfiling()",
          "1452:         {",
          "1453: #ifdef ENABLE_SCRIPT_PROFILING",
          "1454:             return (m_pProfileCallback != nullptr);",
          "1455: #else",
          "1456:             return FALSE;",
          "1457: #endif",
          "1458:         }",
          "1460:         BOOL IsInProfileCallback()",
          "1461:         {",
          "1462: #ifdef ENABLE_SCRIPT_PROFILING",
          "1463:             return m_inProfileCallback;",
          "1464: #else",
          "1465:             return FALSE;",
          "1466: #endif",
          "1467:         }",
          "1469: #if DBG",
          "1470:         SourceContextInfo const * GetNoContextSourceContextInfo() const { return this->Cache()->noContextSourceContextInfo; }",
          "1472: #ifdef ENABLE_SCRIPT_PROFILING",
          "1473:         int GetProfileSession()",
          "1474:         {",
          "1475:             AssertMsg(m_pProfileCallback != nullptr, \"Asking for profile session when we aren't in one.\");",
          "1476:             return m_iProfileSession;",
          "1477:         }",
          "1479:         void StartNewProfileSession()",
          "1480:         {",
          "1481:             AssertMsg(m_pProfileCallback != nullptr, \"New Session when the profiler isn't set to any callback.\");",
          "1482:             m_iProfileSession++;",
          "1483:         }",
          "1485:         void StopProfileSession()",
          "1486:         {",
          "1487:             AssertMsg(m_pProfileCallback == nullptr, \"How to stop when there is still the callback out there\");",
          "1488:         }",
          "1489: #endif // ENABLE_SCRIPT_PROFILING",
          "1491:         bool hadProfiled;",
          "1492:         bool HadProfiled() const { return hadProfiled; }",
          "1493: #endif",
          "1495:         SRCINFO *AddHostSrcInfo(SRCINFO const *pSrcInfo);",
          "1497:         inline void CoreSetProfileEventMask(DWORD dwEventMask);",
          "1498:         typedef HRESULT (*RegisterExternalLibraryType)(Js::ScriptContext *pScriptContext);",
          "1499: #ifdef ENABLE_SCRIPT_PROFILING",
          "1500:         HRESULT RegisterProfileProbe(IActiveScriptProfilerCallback *pProfileCallback, DWORD dwEventMask, DWORD dwContext, RegisterExternalLibraryType RegisterExternalLibrary, JavascriptMethod dispatchInvoke);",
          "1501:         HRESULT DeRegisterProfileProbe(HRESULT hrReason, JavascriptMethod dispatchInvoke);",
          "1502: #endif",
          "1503:         HRESULT SetProfileEventMask(DWORD dwEventMask);",
          "1505:         HRESULT RegisterScript(Js::FunctionProxy *pFunctionBody, BOOL fRegisterScript = TRUE);",
          "1508:         HRESULT RegisterAllScripts();",
          "1511:         void EnsureClearDebugDocument();",
          "1514:         void ShutdownClearSourceLists();",
          "1516:         HRESULT RegisterLibraryFunction(const char16 *pwszObjectName, const char16 *pwszFunctionName, Js::PropertyId functionPropertyId, JavascriptMethod entryPoint);",
          "1518:         HRESULT RegisterBuiltinFunctions(RegisterExternalLibraryType RegisterExternalLibrary);",
          "1519:         void UpdateRecyclerFunctionEntryPointsForDebugger();",
          "1520:         void SetFunctionInRecyclerToProfileMode(bool enumerateNonUserFunctionsOnly = false);",
          "1522: #if defined(ENABLE_SCRIPT_PROFILING) || defined(ENABLE_SCRIPT_DEBUGGING)",
          "1523:         void RegisterDebugThunk(bool calledDuringAttach = true);",
          "1524:         void UnRegisterDebugThunk();",
          "1525:         static void SetEntryPointToProfileThunk(JavascriptFunction* function);",
          "1526:         static void RestoreEntryPointFromProfileThunk(JavascriptFunction* function);",
          "1527:         static void RecyclerEnumClassEnumeratorCallback(void *address, size_t size);",
          "1528: #endif",
          "1529:         static void RecyclerFunctionCallbackForDebugger(void *address, size_t size);",
          "1531:         static ushort ProcessNameAndGetLength(Js::StringBuilder<ArenaAllocator>* nameBuffer, const WCHAR* name);",
          "1533: #ifdef ASMJS_PLAT",
          "1534:         void TransitionEnvironmentForDebugger(ScriptFunction * scriptFunction);",
          "1535: #endif",
          "1537: #if ENABLE_NATIVE_CODEGEN",
          "1538:         HRESULT RecreateNativeCodeGenerator();",
          "1539: #endif",
          "1541:         HRESULT OnDebuggerAttached();",
          "1542:         HRESULT OnDebuggerDetached();",
          "1543:         HRESULT OnDebuggerAttachedDetached(bool attach);",
          "1544:         void InitializeDebugging();",
          "1545:         bool IsForceNoNative();",
          "1546:         bool IsEnumeratingRecyclerObjects() const { return isEnumeratingRecyclerObjects; }",
          "1548:     private:",
          "1549:         class AutoEnumeratingRecyclerObjects",
          "1550:         {",
          "1551:         public:",
          "1552:             AutoEnumeratingRecyclerObjects(ScriptContext* scriptContext):",
          "1553:                 m_scriptContext(scriptContext)",
          "1554:             {",
          "1555:                 Assert(!m_scriptContext->IsEnumeratingRecyclerObjects());",
          "1556:                 m_scriptContext->isEnumeratingRecyclerObjects = true;",
          "1557:             }",
          "1559:             ~AutoEnumeratingRecyclerObjects()",
          "1560:             {",
          "1561:                 Assert(m_scriptContext->IsEnumeratingRecyclerObjects());",
          "1562:                 m_scriptContext->isEnumeratingRecyclerObjects = false;",
          "1563:             }",
          "1565:         private:",
          "1566:             ScriptContext* m_scriptContext;",
          "1567:         };",
          "1569: #ifdef EDIT_AND_CONTINUE",
          "1570:     private:",
          "1571:         ScriptEditQuery* activeScriptEditQuery;",
          "1573:         void BeginScriptEditEnumFunctions(ScriptEditQuery* scriptEditQuery) { Assert(!activeScriptEditQuery); activeScriptEditQuery = scriptEditQuery; }",
          "1574:         void EndScriptEditEnumFunctions() { Assert(activeScriptEditQuery); activeScriptEditQuery = nullptr; }",
          "1575:     public:",
          "1576:         ScriptEditQuery* GetActiveScriptEditQuery() const { return activeScriptEditQuery; }",
          "1578:         class AutoScriptEditEnumFunctions",
          "1579:         {",
          "1580:         public:",
          "1581:             AutoScriptEditEnumFunctions(ScriptContext* scriptContext, ScriptEditQuery* scriptEditQuery) : m_scriptContext(scriptContext)",
          "1582:             {",
          "1583:                 scriptContext->BeginScriptEditEnumFunctions(scriptEditQuery);",
          "1584:             }",
          "1585:             ~AutoScriptEditEnumFunctions() { m_scriptContext->EndScriptEditEnumFunctions(); }",
          "1586:         private:",
          "1587:             ScriptContext* m_scriptContext;",
          "1588:         };",
          "1589: #endif",
          "1591:     private:",
          "1592:         typedef JsUtil::BaseDictionary<JavascriptMethod, Js::PropertyId, ArenaAllocator, PrimeSizePolicy> BuiltinFunctionIdDictionary;",
          "1593:         BuiltinFunctionIdDictionary *m_pBuiltinFunctionIdMap;",
          "1594:         Js::PropertyId GetFunctionNumber(JavascriptMethod entryPoint);",
          "1596:         static const char16* CopyString(const char16* str, size_t charCount, ArenaAllocator* alloc);",
          "1597:         static charcount_t AppendWithEscapeCharacters(Js::StringBuilder<ArenaAllocator>* stringBuilder, const WCHAR* sourceString, charcount_t sourceStringLen, WCHAR escapeChar, WCHAR charToEscape);",
          "1599:     public:",
          "1600: #if DYNAMIC_INTERPRETER_THUNK",
          "1601:         JavascriptMethod GetNextDynamicAsmJsInterpreterThunk(PVOID* ppDynamicInterpreterThunk);",
          "1602:         JavascriptMethod GetNextDynamicInterpreterThunk(PVOID* ppDynamicInterpreterThunk);",
          "1603: #if DBG",
          "1604:         BOOL IsDynamicInterpreterThunk(JavascriptMethod address);",
          "1605: #endif",
          "1606:         void ReleaseDynamicInterpreterThunk(BYTE* address, bool addtoFreeList);",
          "1607:         void ReleaseDynamicAsmJsInterpreterThunk(BYTE* address, bool addtoFreeList);",
          "1608: #endif",
          "1610:         static Var DebugProfileProbeThunk(RecyclableObject* function, CallInfo callInfo, ...);",
          "1611:         static JavascriptMethod ProfileModeDeferredParse(ScriptFunction **function);",
          "1612:         static Var ProfileModeDeferredParsingThunk(RecyclableObject* function, CallInfo callInfo, ...);",
          "1615:         static JavascriptMethod ProfileModeDeferredDeserialize(ScriptFunction* function);",
          "1616:         static Var ProfileModeDeferredDeserializeThunk(RecyclableObject* function, CallInfo callInfo, ...);",
          "1618: #if defined(ENABLE_SCRIPT_DEBUGGING) || defined(ENABLE_SCRIPT_PROFILING)",
          "1619:         static Var ProfileModeThunk_DebugModeWrapper(JavascriptFunction* function, ScriptContext* scriptContext, JavascriptMethod entryPoint, Arguments& args);",
          "1620:         static JavascriptMethod GetProfileModeThunk(JavascriptMethod entryPoint);",
          "1621: #endif",
          "1623: #ifdef ENABLE_SCRIPT_PROFILING",
          "1624:         void SetProfileMode(BOOL fSet);",
          "1625:         BOOL GetProfileInfo(",
          "1626:             JavascriptFunction* function,",
          "1627:             PROFILER_TOKEN &scriptId,",
          "1628:             PROFILER_TOKEN &functionId);",
          "1630:         HRESULT OnScriptCompiled(PROFILER_TOKEN scriptId, PROFILER_SCRIPT_TYPE type, IUnknown *pIDebugDocumentContext);",
          "1631:         HRESULT OnFunctionCompiled(",
          "1632:             PROFILER_TOKEN functionId,",
          "1633:             PROFILER_TOKEN scriptId,",
          "1634:             const WCHAR *pwszFunctionName,",
          "1635:             const WCHAR *pwszFunctionNameHint,",
          "1636:             IUnknown *pIDebugDocumentContext);",
          "1637:         HRESULT OnFunctionEnter(PROFILER_TOKEN scriptId, PROFILER_TOKEN functionId);",
          "1638:         HRESULT OnFunctionExit(PROFILER_TOKEN scriptId, PROFILER_TOKEN functionId);",
          "1640:         static HRESULT FunctionExitSenderThunk(PROFILER_TOKEN functionId, PROFILER_TOKEN scriptId, ScriptContext *pScriptContext);",
          "1641:         static HRESULT FunctionExitByNameSenderThunk(const char16 *pwszFunctionName, ScriptContext *pScriptContext);",
          "1642: #endif // ENABLE_SCRIPT_PROFILING",
          "1644:         bool SetDispatchProfile(bool fSet, JavascriptMethod dispatchInvoke);",
          "1645:         HRESULT OnDispatchFunctionEnter(const WCHAR *pwszFunctionName);",
          "1646:         HRESULT OnDispatchFunctionExit(const WCHAR *pwszFunctionName);",
          "1648:         void OnStartupComplete();",
          "1649:         void SaveStartupProfileAndRelease(bool isSaveOnClose = false);",
          "1651: #if ENABLE_PROFILE_INFO",
          "1652:         template<template<typename> class BarrierT>",
          "1653:         void AddDynamicProfileInfo(FunctionBody * functionBody, BarrierT<DynamicProfileInfo>& dynamicProfileInfo);",
          "1654: #endif",
          "1655: #if DBG || defined(RUNTIME_DATA_COLLECTION)",
          "1656:         uint allocId;",
          "1657: #endif",
          "1659: #ifdef PROFILE_EXEC",
          "1660:         void DisableProfiler();",
          "1661:         void SetRecyclerProfiler();",
          "1662:         void SetProfilerFromScriptContext(ScriptContext * scriptContext);",
          "1663:         void ProfileBegin(Js::Phase);",
          "1664:         void ProfileEnd(Js::Phase);",
          "1665:         void ProfileSuspend(Js::Phase, Js::Profiler::SuspendRecord * suspendRecord);",
          "1666:         void ProfileResume(Js::Profiler::SuspendRecord * suspendRecord);",
          "1667:         void ProfilePrint();",
          "1668:         bool IsProfilerCreated() const { return isProfilerCreated; }",
          "1669: #endif",
          "1671: #ifdef PROFILE_MEM",
          "1672:         void DisableProfileMemoryDumpOnDelete() { profileMemoryDump = false; }",
          "1673: #endif",
          "1675: #ifdef PROFILE_STRINGS",
          "1676:         StringProfiler * GetStringProfiler(); // May be null if string profiling not enabled",
          "1677: #endif",
          "1679:     public:",
          "1680:         virtual intptr_t GetNullAddr() const override;",
          "1681:         virtual intptr_t GetUndefinedAddr() const override;",
          "1682:         virtual intptr_t GetTrueAddr() const override;",
          "1683:         virtual intptr_t GetFalseAddr() const override;",
          "1684:         virtual intptr_t GetUndeclBlockVarAddr() const override;",
          "1685:         virtual intptr_t GetEmptyStringAddr() const override;",
          "1686:         virtual intptr_t GetNegativeZeroAddr() const override;",
          "1687:         virtual intptr_t GetNumberTypeStaticAddr() const override;",
          "1688:         virtual intptr_t GetStringTypeStaticAddr() const override;",
          "1689:         virtual intptr_t GetObjectTypeAddr() const override;",
          "1690:         virtual intptr_t GetObjectHeaderInlinedTypeAddr() const override;",
          "1691:         virtual intptr_t GetRegexTypeAddr() const override;",
          "1692:         virtual intptr_t GetArrayTypeAddr() const override;",
          "1693:         virtual intptr_t GetNativeIntArrayTypeAddr() const override;",
          "1694:         virtual intptr_t GetNativeFloatArrayTypeAddr() const override;",
          "1695:         virtual intptr_t GetArrayConstructorAddr() const override;",
          "1696:         virtual intptr_t GetCharStringCacheAddr() const override;",
          "1697:         virtual intptr_t GetSideEffectsAddr() const override;",
          "1698:         virtual intptr_t GetArraySetElementFastPathVtableAddr() const override;",
          "1699:         virtual intptr_t GetIntArraySetElementFastPathVtableAddr() const override;",
          "1700:         virtual intptr_t GetFloatArraySetElementFastPathVtableAddr() const override;",
          "1701:         virtual intptr_t GetLibraryAddr() const override;",
          "1702:         virtual intptr_t GetGlobalObjectAddr() const override;",
          "1703:         virtual intptr_t GetGlobalObjectThisAddr() const override;",
          "1704:         virtual intptr_t GetNumberAllocatorAddr() const override;",
          "1705:         virtual intptr_t GetRecyclerAddr() const override;",
          "1706:         virtual bool GetRecyclerAllowNativeCodeBumpAllocation() const override;",
          "1707:         virtual bool IsSIMDEnabled() const override;",
          "1708:         virtual bool IsPRNGSeeded() const override;",
          "1709:         virtual intptr_t GetBuiltinFunctionsBaseAddr() const override;",
          "1711:         virtual intptr_t GetDebuggingFlagsAddr() const override;",
          "1712:         virtual intptr_t GetDebugStepTypeAddr() const override;",
          "1713:         virtual intptr_t GetDebugFrameAddressAddr() const override;",
          "1714:         virtual intptr_t GetDebugScriptIdWhenSetAddr() const override;",
          "1716: #if ENABLE_NATIVE_CODEGEN",
          "1717:         virtual void AddToDOMFastPathHelperMap(intptr_t funcInfoAddr, IR::JnHelperMethod helper) override;",
          "1718:         virtual IR::JnHelperMethod GetDOMFastPathHelper(intptr_t funcInfoAddr) override;",
          "1719: #endif",
          "1721:         virtual intptr_t GetAddr() const override;",
          "1723:         virtual intptr_t GetVTableAddress(VTableValue vtableType) const override;",
          "1725:         virtual bool IsRecyclerVerifyEnabled() const override;",
          "1726:         virtual uint GetRecyclerVerifyPad() const override;",
          "1728:         virtual Field(Js::Var)* GetModuleExportSlotArrayAddress(uint moduleIndex, uint slotIndex) override;",
          "1730:         Js::SourceTextModuleRecord* GetModuleRecord(uint moduleId) const",
          "1731:         {",
          "1732:             return javascriptLibrary->GetModuleRecord(moduleId);",
          "1733:         }",
          "1735:         void SetBuiltInLibraryFunction(JavascriptMethod entryPoint, JavascriptFunction* function);",
          "1736:         JavascriptFunction* GetBuiltInLibraryFunction(JavascriptMethod entryPoint);",
          "1738:     private:",
          "1739:         BuiltInLibraryFunctionMap* builtInLibraryFunctions;",
          "1741: #if ENABLE_NATIVE_CODEGEN",
          "1742:         JITDOMFastPathHelperMap * m_domFastPathHelperMap;",
          "1743: #endif",
          "1745: #ifdef RECYCLER_PERF_COUNTERS",
          "1746:         size_t bindReferenceCount;",
          "1747: #endif",
          "1749:         ScriptContext * nextPendingClose;",
          "1750:     public:",
          "1751:         void SetNextPendingClose(ScriptContext * nextPendingClose);",
          "1752:         inline ScriptContext * GetNextPendingClose() const { return nextPendingClose; }",
          "1754: #ifdef ENABLE_MUTATION_BREAKPOINT",
          "1756:         bool HasMutationBreakpoints();",
          "1757:         void InsertMutationBreakpoint(Js::MutationBreakpoint *mutationBreakpoint);",
          "1758: #endif",
          "1759:     };",
          "1761:     class AutoDynamicCodeReference",
          "1762:     {",
          "1763:     public:",
          "1764:         AutoDynamicCodeReference(ScriptContext* scriptContext):",
          "1765:           m_scriptContext(scriptContext)",
          "1766:           {",
          "1767:               scriptContext->GetLibrary()->BeginDynamicFunctionReferences();",
          "1768:           }",
          "1770:           ~AutoDynamicCodeReference()",
          "1771:           {",
          "1772:               m_scriptContext->GetLibrary()->EndDynamicFunctionReferences();",
          "1773:           }",
          "1775:     private:",
          "1776:         ScriptContext* m_scriptContext;",
          "1777:     };",
          "1779:     template <typename TCacheType>",
          "1780:     void ScriptContext::CleanDynamicFunctionCache(TCacheType* cacheType)",
          "1781:     {",
          "1785:         cacheType->Clean([this](const typename TCacheType::KeyType& key, typename TCacheType::ValueType value) {",
          "1786: #ifdef ENABLE_DEBUG_CONFIG_OPTIONS",
          "1787:             if (CONFIG_FLAG(DumpEvalStringOnRemoval))",
          "1788:             {",
          "1789:                 Output::Print(_u(\"EvalMap: Removing Dynamic Function String from dynamic function cache: %s\\n\"), key.str.GetBuffer()); Output::Flush();",
          "1790:             }",
          "1791: #endif",
          "1792:         });",
          "1793:     }",
          "1795:     template <class TDelegate>",
          "1796:     void ScriptContext::MapFunction(TDelegate mapper)",
          "1797:     {",
          "1798:         if (this->sourceList)",
          "1799:         {",
          "1800:             this->sourceList->Map([&mapper](int, RecyclerWeakReference<Js::Utf8SourceInfo>* sourceInfo)",
          "1801:             {",
          "1802:                 Utf8SourceInfo* sourceInfoStrongRef = sourceInfo->Get();",
          "1803:                 if (sourceInfoStrongRef)",
          "1804:                 {",
          "1805:                     sourceInfoStrongRef->MapFunction(mapper);",
          "1806:                 }",
          "1807:             });",
          "1808:         }",
          "1809:     }",
          "1811:     template <class TDelegate>",
          "1812:     FunctionBody* ScriptContext::FindFunction(TDelegate predicate)",
          "1813:     {",
          "1814:         FunctionBody* functionBody = nullptr;",
          "1816:         this->sourceList->MapUntil([&functionBody, &predicate](int, RecyclerWeakReference<Js::Utf8SourceInfo>* sourceInfo) -> bool",
          "1817:         {",
          "1818:             Utf8SourceInfo* sourceInfoStrongRef = sourceInfo->Get();",
          "1819:             if (sourceInfoStrongRef)",
          "1820:             {",
          "1821:                 functionBody = sourceInfoStrongRef->FindFunction(predicate);",
          "1822:                 if (functionBody)",
          "1823:                 {",
          "1824:                     return true;",
          "1825:                 }",
          "1826:             }",
          "1828:             return false;",
          "1829:         });",
          "1831:         return functionBody;",
          "1832:     }",
          "1834:     class AutoProfilingPhase",
          "1835:     {",
          "1836:     public:",
          "1837:         AutoProfilingPhase(ScriptContext* scriptcontext, Js::Phase phase) : scriptcontext(scriptcontext), phase(phase), isPhaseComplete(false)",
          "1838:         {",
          "1839:     #ifdef PROFILE_EXEC",
          "1840:             scriptcontext->ProfileBegin(phase);",
          "1841:     #endif",
          "1842:         }",
          "1844:         ~AutoProfilingPhase()",
          "1845:         {",
          "1846:             if(!this->isPhaseComplete)",
          "1847:             {",
          "1848:                 EndProfile();",
          "1849:             }",
          "1850:         }",
          "1852:         void EndProfile()",
          "1853:         {",
          "1854:             this->isPhaseComplete = true;",
          "1855: #ifdef PROFILE_EXEC",
          "1856:             scriptcontext->ProfileEnd(phase);",
          "1857: #endif",
          "1858:         }",
          "1859:     private:",
          "1860:         ScriptContext* scriptcontext;",
          "1861:         Js::Phase phase;",
          "1862:         bool isPhaseComplete;",
          "1863:     };",
          "1864: }",
          "1867: #define BEGIN_TEMP_ALLOCATOR(allocator, scriptContext, name) \\",
          "1868:     Js::TempArenaAllocatorObject *temp##allocator = scriptContext->GetTemporaryAllocator(name); \\",
          "1869:     ArenaAllocator * allocator = temp##allocator->GetAllocator();",
          "1871: #define END_TEMP_ALLOCATOR(allocator, scriptContext) \\",
          "1872:     scriptContext->ReleaseTemporaryAllocator(temp##allocator);",
          "1874: #define DECLARE_TEMP_ALLOCATOR(allocator) \\",
          "1875:     Js::TempArenaAllocatorObject *temp##allocator = nullptr; \\",
          "1876:     ArenaAllocator * allocator = nullptr;",
          "1878: #define ACQUIRE_TEMP_ALLOCATOR(allocator, scriptContext, name) \\",
          "1879:     temp##allocator = scriptContext->GetTemporaryAllocator(name); \\",
          "1880:     allocator = temp##allocator->GetAllocator();",
          "1882: #define RELEASE_TEMP_ALLOCATOR(allocator, scriptContext) \\",
          "1883:     if (temp##allocator) \\",
          "1884:     scriptContext->ReleaseTemporaryAllocator(temp##allocator);",
          "1886: #define DECLARE_TEMP_GUEST_ALLOCATOR(allocator) \\",
          "1887:     Js::TempGuestArenaAllocatorObject *tempGuest##allocator = nullptr; \\",
          "1888:     ArenaAllocator * allocator = nullptr;",
          "1890: #define ACQUIRE_TEMP_GUEST_ALLOCATOR(allocator, scriptContext, name) \\",
          "1891:     tempGuest##allocator = scriptContext->GetTemporaryGuestAllocator(name); \\",
          "1892:     allocator = tempGuest##allocator->GetAllocator();",
          "1894: #define RELEASE_TEMP_GUEST_ALLOCATOR(allocator, scriptContext) \\",
          "1895:     if (tempGuest##allocator) \\",
          "1896:     scriptContext->ReleaseTemporaryGuestAllocator(tempGuest##allocator);",
          "",
          "---------------"
        ],
        "lib/Runtime/Library/ArrayBuffer.cpp||lib/Runtime/Library/ArrayBuffer.cpp": [
          "File: lib/Runtime/Library/ArrayBuffer.cpp -> lib/Runtime/Library/ArrayBuffer.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "5: #include \"RuntimeLibraryPch.h\"",
          "7: namespace Js",
          "8: {",
          "9:     bool ArrayBufferBase::Is(Var value)",
          "10:     {",
          "11:         return ArrayBuffer::Is(value) || SharedArrayBuffer::Is(value);",
          "12:     }",
          "14:     ArrayBufferBase* ArrayBufferBase::FromVar(Var value)",
          "15:     {",
          "16:         Assert(ArrayBufferBase::Is(value));",
          "17:         return static_cast<ArrayBuffer *> (value);",
          "18:     }",
          "20:     ArrayBuffer* ArrayBuffer::NewFromDetachedState(DetachedStateBase* state, JavascriptLibrary *library)",
          "21:     {",
          "22:         ArrayBufferDetachedStateBase* arrayBufferState = (ArrayBufferDetachedStateBase *)state;",
          "23:         ArrayBuffer *toReturn = nullptr;",
          "25:         switch (arrayBufferState->allocationType)",
          "26:         {",
          "27:         case ArrayBufferAllocationType::CoTask:",
          "28:             toReturn = library->CreateProjectionArraybuffer(arrayBufferState->buffer, arrayBufferState->bufferLength);",
          "29:             break;",
          "30:         case ArrayBufferAllocationType::Heap:",
          "31:         case ArrayBufferAllocationType::MemAlloc:",
          "32:             toReturn = library->CreateArrayBuffer(arrayBufferState->buffer, arrayBufferState->bufferLength);",
          "33:             break;",
          "34:         default:",
          "35:             AssertMsg(false, \"Unknown allocationType of ArrayBufferDetachedStateBase \");",
          "36:         }",
          "38:         return toReturn;",
          "39:     }",
          "41:     void ArrayBuffer::ClearParentsLength(ArrayBufferParent* parent)",
          "42:     {",
          "43:         if (parent == nullptr)",
          "44:         {",
          "45:             return;",
          "46:         }",
          "48:         switch (JavascriptOperators::GetTypeId(parent))",
          "49:         {",
          "50:         case TypeIds_Int8Array:",
          "51:         case TypeIds_Uint8Array:",
          "52:         case TypeIds_Uint8ClampedArray:",
          "53:         case TypeIds_Int16Array:",
          "54:         case TypeIds_Uint16Array:",
          "55:         case TypeIds_Int32Array:",
          "56:         case TypeIds_Uint32Array:",
          "57:         case TypeIds_Float32Array:",
          "58:         case TypeIds_Float64Array:",
          "59:         case TypeIds_Int64Array:",
          "60:         case TypeIds_Uint64Array:",
          "61:         case TypeIds_CharArray:",
          "62:         case TypeIds_BoolArray:",
          "63:             TypedArrayBase::FromVar(parent)->length = 0;",
          "64:             break;",
          "66:         case TypeIds_DataView:",
          "67:             DataView::FromVar(parent)->length = 0;",
          "68:             break;",
          "70:         default:",
          "71:             AssertMsg(false, \"We need an explicit case for any parent of ArrayBuffer.\");",
          "72:             break;",
          "73:         }",
          "74:     }",
          "76:     ArrayBufferDetachedStateBase* ArrayBuffer::DetachAndGetState()",
          "77:     {",
          "78:         Assert(!this->isDetached);",
          "80:         AutoPtr<ArrayBufferDetachedStateBase> arrayBufferState(this->CreateDetachedState(this->buffer, this->bufferLength));",
          "82:         this->buffer = nullptr;",
          "83:         this->bufferLength = 0;",
          "84:         this->isDetached = true;",
          "86:         if (this->primaryParent != nullptr && this->primaryParent->Get() == nullptr)",
          "87:         {",
          "88:             this->primaryParent = nullptr;",
          "89:         }",
          "91:         if (this->primaryParent != nullptr)",
          "92:         {",
          "93:             this->ClearParentsLength(this->primaryParent->Get());",
          "94:         }",
          "96:         if (this->otherParents != nullptr)",
          "97:         {",
          "98:             this->otherParents->Map([&](RecyclerWeakReference<ArrayBufferParent>* item)",
          "99:             {",
          "100:                 this->ClearParentsLength(item->Get());",
          "101:             });",
          "102:         }",
          "104:         return arrayBufferState.Detach();",
          "105:     }",
          "107:     void ArrayBuffer::AddParent(ArrayBufferParent* parent)",
          "108:     {",
          "109:         if (this->primaryParent == nullptr || this->primaryParent->Get() == nullptr)",
          "110:         {",
          "111:             this->primaryParent = this->GetRecycler()->CreateWeakReferenceHandle(parent);",
          "112:         }",
          "113:         else",
          "114:         {",
          "115:             if (this->otherParents == nullptr)",
          "116:             {",
          "117:                 this->otherParents = RecyclerNew(this->GetRecycler(), OtherParents, this->GetRecycler());",
          "118:             }",
          "120:             if (this->otherParents->increasedCount >= ParentsCleanupThreshold)",
          "121:             {",
          "122:                 auto iter = this->otherParents->GetEditingIterator();",
          "123:                 while (iter.Next())",
          "124:                 {",
          "125:                     if (iter.Data()->Get() == nullptr)",
          "126:                     {",
          "127:                         iter.RemoveCurrent();",
          "128:                     }",
          "129:                 }",
          "131:                 this->otherParents->increasedCount = 0;",
          "132:             }",
          "134:             this->otherParents->PrependNode(this->GetRecycler()->CreateWeakReferenceHandle(parent));",
          "135:             this->otherParents->increasedCount++;",
          "136:         }",
          "137:     }",
          "139:     uint32 ArrayBuffer::ToIndex(Var value, int32 errorCode, ScriptContext *scriptContext, uint32 MaxAllowedLength, bool checkSameValueZero)",
          "140:     {",
          "141:         if (JavascriptOperators::IsUndefined(value))",
          "142:         {",
          "143:             return 0;",
          "144:         }",
          "146:         if (TaggedInt::Is(value))",
          "147:         {",
          "148:             int64 index = TaggedInt::ToInt64(value);",
          "149:             if (index < 0 || index >(int64)MaxAllowedLength)",
          "150:             {",
          "151:                 JavascriptError::ThrowRangeError(scriptContext, errorCode);",
          "152:             }",
          "154:             return  (uint32)index;",
          "155:         }",
          "159:         double d = JavascriptConversion::ToInteger(value, scriptContext);",
          "160:         if (d < 0.0 || d >(double)MaxAllowedLength)",
          "161:         {",
          "162:             JavascriptError::ThrowRangeError(scriptContext, errorCode);",
          "163:         }",
          "165:         if (checkSameValueZero)",
          "166:         {",
          "167:             Var integerIndex = JavascriptNumber::ToVarNoCheck(d, scriptContext);",
          "168:             Var index = JavascriptNumber::ToVar(JavascriptConversion::ToLength(integerIndex, scriptContext), scriptContext);",
          "169:             if (!JavascriptConversion::SameValueZero(integerIndex, index))",
          "170:             {",
          "171:                 JavascriptError::ThrowRangeError(scriptContext, errorCode);",
          "172:             }",
          "173:         }",
          "175:         return (uint32)d;",
          "176:     }",
          "178:     Var ArrayBuffer::NewInstance(RecyclableObject* function, CallInfo callInfo, ...)",
          "179:     {",
          "180:         PROBE_STACK(function->GetScriptContext(), Js::Constants::MinStackDefault);",
          "182:         ARGUMENTS(args, callInfo);",
          "183:         ScriptContext* scriptContext = function->GetScriptContext();",
          "185:         AssertMsg(args.Info.Count > 0, \"Should always have implicit 'this'\");",
          "187:         Var newTarget = callInfo.Flags & CallFlags_NewTarget ? args.Values[args.Info.Count] : args[0];",
          "188:         bool isCtorSuperCall = (callInfo.Flags & CallFlags_New) && newTarget != nullptr && !JavascriptOperators::IsUndefined(newTarget);",
          "189:         Assert(isCtorSuperCall || !(callInfo.Flags & CallFlags_New) || args[0] == nullptr);",
          "191:         if (!(callInfo.Flags & CallFlags_New) || (newTarget && JavascriptOperators::IsUndefinedObject(newTarget)))",
          "192:         {",
          "193:             JavascriptError::ThrowTypeError(scriptContext, JSERR_ClassConstructorCannotBeCalledWithoutNew, _u(\"ArrayBuffer\"));",
          "194:         }",
          "196:         uint32 byteLength = 0;",
          "197:         if (args.Info.Count > 1)",
          "198:         {",
          "199:             byteLength = ToIndex(args[1], JSERR_ArrayLengthConstructIncorrect, scriptContext, MaxArrayBufferLength);",
          "200:         }",
          "202:         RecyclableObject* newArr = scriptContext->GetLibrary()->CreateArrayBuffer(byteLength);",
          "203:         Assert(ArrayBuffer::Is(newArr));",
          "204:         if (byteLength > 0 && !ArrayBuffer::FromVar(newArr)->GetByteLength())",
          "205:         {",
          "206:             JavascriptError::ThrowRangeError(scriptContext, JSERR_FunctionArgument_Invalid);",
          "207:         }",
          "208: #if ENABLE_DEBUG_CONFIG_OPTIONS",
          "209:         if (Js::Configuration::Global.flags.IsEnabled(Js::autoProxyFlag))",
          "210:         {",
          "211:             newArr = Js::JavascriptProxy::AutoProxyWrapper(newArr);",
          "212:         }",
          "213: #endif",
          "214:         return isCtorSuperCall ?",
          "215:             JavascriptOperators::OrdinaryCreateFromConstructor(RecyclableObject::FromVar(newTarget), newArr, nullptr, scriptContext) :",
          "216:             newArr;",
          "217:     }",
          "220:     Var ArrayBuffer::EntryGetterByteLength(RecyclableObject* function, CallInfo callInfo, ...)",
          "221:     {",
          "222:         PROBE_STACK(function->GetScriptContext(), Js::Constants::MinStackDefault);",
          "224:         ARGUMENTS(args, callInfo);",
          "225:         ScriptContext* scriptContext = function->GetScriptContext();",
          "227:         Assert(!(callInfo.Flags & CallFlags_New));",
          "229:         if (args.Info.Count == 0 || !ArrayBuffer::Is(args[0]))",
          "230:         {",
          "231:             JavascriptError::ThrowTypeError(scriptContext, JSERR_NeedArrayBufferObject);",
          "232:         }",
          "234:         ArrayBuffer* arrayBuffer = ArrayBuffer::FromVar(args[0]);",
          "235:         if (arrayBuffer->IsDetached())",
          "236:         {",
          "237:             return JavascriptNumber::ToVar(0, scriptContext);",
          "238:         }",
          "239:         return JavascriptNumber::ToVar(arrayBuffer->GetByteLength(), scriptContext);",
          "240:     }",
          "243:     Var ArrayBuffer::EntryIsView(RecyclableObject* function, CallInfo callInfo, ...)",
          "244:     {",
          "245:         PROBE_STACK(function->GetScriptContext(), Js::Constants::MinStackDefault);",
          "247:         ARGUMENTS(args, callInfo);",
          "249:         Assert(!(callInfo.Flags & CallFlags_New));",
          "251:         AssertMsg(args.Info.Count > 0, \"Should always have implicit 'this'\");",
          "253:         JavascriptLibrary* library = function->GetScriptContext()->GetLibrary();",
          "255:         Var arg = library->GetUndefined();",
          "257:         if (args.Info.Count > 1)",
          "258:         {",
          "259:             arg = args[1];",
          "260:         }",
          "263:         if (DataView::Is(arg) || TypedArrayBase::Is(arg))",
          "264:         {",
          "265:             return library->GetTrue();",
          "266:         }",
          "268:         return library->GetFalse();",
          "269:     }",
          "272:     Var ArrayBuffer::EntryTransfer(RecyclableObject* function, CallInfo callInfo, ...)",
          "273:     {",
          "274:         ScriptContext* scriptContext = function->GetScriptContext();",
          "276:         PROBE_STACK(scriptContext, Js::Constants::MinStackDefault);",
          "278:         ARGUMENTS(args, callInfo);",
          "280:         Assert(!(callInfo.Flags & CallFlags_New));",
          "282:         CHAKRATEL_LANGSTATS_INC_BUILTINCOUNT(ArrayBuffer_Constructor_transfer);",
          "284:         if (args.Info.Count < 2 || !ArrayBuffer::Is(args[1]))",
          "285:         {",
          "286:             JavascriptError::ThrowTypeError(scriptContext, JSERR_NeedArrayBufferObject);",
          "287:         }",
          "289:         ArrayBuffer* arrayBuffer = ArrayBuffer::FromVar(args[1]);",
          "291:         if (arrayBuffer->IsDetached())",
          "292:         {",
          "293:             JavascriptError::ThrowTypeError(scriptContext, JSERR_DetachedTypedArray, _u(\"ArrayBuffer.transfer\"));",
          "294:         }",
          "296:         uint32 newBufferLength = arrayBuffer->bufferLength;",
          "297:         if (args.Info.Count >= 3)",
          "298:         {",
          "299:             newBufferLength = ToIndex(args[2], JSERR_ArrayLengthConstructIncorrect, scriptContext, MaxArrayBufferLength);",
          "302:             if (arrayBuffer->IsDetached())",
          "303:             {",
          "304:                 JavascriptError::ThrowTypeError(scriptContext, JSERR_DetachedTypedArray, _u(\"ArrayBuffer.transfer\"));",
          "305:             }",
          "306:         }",
          "308:         return arrayBuffer->TransferInternal(newBufferLength);",
          "309:     }",
          "312:     Var ArrayBuffer::EntrySlice(RecyclableObject* function, CallInfo callInfo, ...)",
          "313:     {",
          "314:         ScriptContext* scriptContext = function->GetScriptContext();",
          "316:         PROBE_STACK(scriptContext, Js::Constants::MinStackDefault);",
          "318:         ARGUMENTS(args, callInfo);",
          "320:         AssertMsg(args.Info.Count > 0, \"Should always have implicit 'this'\");",
          "322:         Assert(!(callInfo.Flags & CallFlags_New));",
          "324:         if (!ArrayBuffer::Is(args[0]))",
          "325:         {",
          "326:             JavascriptError::ThrowTypeError(scriptContext, JSERR_NeedArrayBufferObject);",
          "327:         }",
          "329:         JavascriptLibrary* library = scriptContext->GetLibrary();",
          "330:         ArrayBuffer* arrayBuffer = ArrayBuffer::FromVar(args[0]);",
          "332:         if (arrayBuffer->IsDetached()) // 24.1.4.3: 5. If IsDetachedBuffer(O) is true, then throw a TypeError exception.",
          "333:         {",
          "334:             JavascriptError::ThrowTypeError(scriptContext, JSERR_DetachedTypedArray, _u(\"ArrayBuffer.prototype.slice\"));",
          "335:         }",
          "337:         int64 len = arrayBuffer->bufferLength;",
          "338:         int64 start = 0, end = 0;",
          "339:         int64 newLen;",
          "342:         if (args.Info.Count < 2)",
          "343:         {",
          "344:             newLen = len;",
          "345:         }",
          "346:         else",
          "347:         {",
          "348:             start = JavascriptArray::GetIndexFromVar(args[1], len, scriptContext);",
          "351:             if (args.Info.Count < 3 || args[2] == library->GetUndefined())",
          "352:             {",
          "353:                 end = len;",
          "354:             }",
          "355:             else",
          "356:             {",
          "357:                 end = JavascriptArray::GetIndexFromVar(args[2], len, scriptContext);",
          "358:             }",
          "360:             newLen = end > start ? end - start : 0;",
          "361:         }",
          "367:         Assert(newLen < MaxArrayBufferLength);",
          "368:         uint32 byteLength = static_cast<uint32>(newLen);",
          "370:         ArrayBuffer* newBuffer = nullptr;",
          "372:         if (scriptContext->GetConfig()->IsES6SpeciesEnabled())",
          "373:         {",
          "374:             Var constructorVar = JavascriptOperators::SpeciesConstructor(arrayBuffer, scriptContext->GetLibrary()->GetArrayBufferConstructor(), scriptContext);",
          "376:             JavascriptFunction* constructor = JavascriptFunction::FromVar(constructorVar);",
          "378:             Js::Var constructorArgs[] = {constructor, JavascriptNumber::ToVar(byteLength, scriptContext)};",
          "379:             Js::CallInfo constructorCallInfo(Js::CallFlags_New, _countof(constructorArgs));",
          "380:             Js::Var newVar = JavascriptOperators::NewScObject(constructor, Js::Arguments(constructorCallInfo, constructorArgs), scriptContext);",
          "382:             if (!ArrayBuffer::Is(newVar)) // 24.1.4.3: 19.If new does not have an [[ArrayBufferData]] internal slot throw a TypeError exception.",
          "383:             {",
          "384:                 JavascriptError::ThrowTypeError(scriptContext, JSERR_NeedArrayBufferObject);",
          "385:             }",
          "387:             newBuffer = ArrayBuffer::FromVar(newVar);",
          "389:             if (newBuffer->IsDetached()) // 24.1.4.3: 21. If IsDetachedBuffer(new) is true, then throw a TypeError exception.",
          "390:             {",
          "391:                 JavascriptError::ThrowTypeError(scriptContext, JSERR_DetachedTypedArray, _u(\"ArrayBuffer.prototype.slice\"));",
          "392:             }",
          "394:             if (newBuffer == arrayBuffer) // 24.1.4.3: 22. If SameValue(new, O) is true, then throw a TypeError exception.",
          "395:             {",
          "396:                 JavascriptError::ThrowTypeError(scriptContext, JSERR_NeedArrayBufferObject);",
          "397:             }",
          "399:             if (newBuffer->bufferLength < byteLength) // 24.1.4.3: 23.If the value of new's [[ArrayBufferByteLength]] internal slot < newLen, then throw a TypeError exception.",
          "400:             {",
          "401:                 JavascriptError::ThrowTypeError(scriptContext, JSERR_ArgumentOutOfRange, _u(\"ArrayBuffer.prototype.slice\"));",
          "402:             }",
          "403:         }",
          "404:         else",
          "405:         {",
          "406:             newBuffer = library->CreateArrayBuffer(byteLength);",
          "407:         }",
          "409:         Assert(newBuffer);",
          "410:         Assert(newBuffer->bufferLength >= byteLength);",
          "412:         if (arrayBuffer->IsDetached()) // 24.1.4.3: 24. NOTE: Side-effects of the above steps may have detached O. 25. If IsDetachedBuffer(O) is true, then throw a TypeError exception.",
          "413:         {",
          "414:             JavascriptError::ThrowTypeError(scriptContext, JSERR_DetachedTypedArray, _u(\"ArrayBuffer.prototype.slice\"));",
          "415:         }",
          "418:         if (byteLength > 0)",
          "419:         {",
          "420:             AssertMsg(arrayBuffer->buffer != nullptr, \"buffer must not be null when we copy from it\");",
          "422:             js_memcpy_s(newBuffer->buffer, byteLength, arrayBuffer->buffer + start, byteLength);",
          "423:         }",
          "425:         return newBuffer;",
          "426:     }",
          "428:     Var ArrayBuffer::EntryGetterSymbolSpecies(RecyclableObject* function, CallInfo callInfo, ...)",
          "429:     {",
          "430:         ARGUMENTS(args, callInfo);",
          "432:         Assert(args.Info.Count > 0);",
          "434:         return args[0];",
          "435:     }",
          "437:     ArrayBuffer* ArrayBuffer::FromVar(Var aValue)",
          "438:     {",
          "439:         AssertMsg(Is(aValue), \"var must be an ArrayBuffer\");",
          "441:         return static_cast<ArrayBuffer *>(RecyclableObject::FromVar(aValue));",
          "442:     }",
          "444:     bool  ArrayBuffer::Is(Var aValue)",
          "445:     {",
          "446:         return JavascriptOperators::GetTypeId(aValue) == TypeIds_ArrayBuffer;",
          "447:     }",
          "449:     template <class Allocator>",
          "450:     ArrayBuffer::ArrayBuffer(uint32 length, DynamicType * type, Allocator allocator) :",
          "451:         ArrayBufferBase(type)",
          "452:     {",
          "453:         buffer = nullptr;",
          "454:         bufferLength = 0;",
          "455:         if (length > MaxArrayBufferLength)",
          "456:         {",
          "457:             JavascriptError::ThrowTypeError(GetScriptContext(), JSERR_FunctionArgument_Invalid);",
          "458:         }",
          "459:         else if (length > 0)",
          "460:         {",
          "461:             Recycler* recycler = GetType()->GetLibrary()->GetRecycler();",
          "462:             if (recycler->ReportExternalMemoryAllocation(length))",
          "463:             {",
          "464:                 buffer = (BYTE*)allocator(length);",
          "465:                 if (buffer == nullptr)",
          "466:                 {",
          "467:                     recycler->ReportExternalMemoryFree(length);",
          "468:                 }",
          "469:             }",
          "471:             if (buffer == nullptr)",
          "472:             {",
          "473:                 recycler->CollectNow<CollectOnTypedArrayAllocation>();",
          "475:                 if (recycler->ReportExternalMemoryAllocation(length))",
          "476:                 {",
          "477:                     buffer = (BYTE*)allocator(length);",
          "478:                     if (buffer == nullptr)",
          "479:                     {",
          "480:                         recycler->ReportExternalMemoryFailure(length);",
          "481:                     }",
          "482:                 }",
          "483:                 else",
          "484:                 {",
          "485:                     JavascriptError::ThrowOutOfMemoryError(GetScriptContext());",
          "486:                 }",
          "487:             }",
          "489:             if (buffer != nullptr)",
          "490:             {",
          "491:                 bufferLength = length;",
          "492:                 ZeroMemory(buffer, bufferLength);",
          "493:             }",
          "494:         }",
          "495:     }",
          "497:     ArrayBuffer::ArrayBuffer(byte* buffer, uint32 length, DynamicType * type) :",
          "498:         buffer(buffer), bufferLength(length), ArrayBufferBase(type)",
          "499:     {",
          "500:         if (length > MaxArrayBufferLength)",
          "501:         {",
          "502:             JavascriptError::ThrowTypeError(GetScriptContext(), JSERR_FunctionArgument_Invalid);",
          "503:         }",
          "504:     }",
          "506:     BOOL ArrayBuffer::GetDiagTypeString(StringBuilder<ArenaAllocator>* stringBuilder, ScriptContext* requestContext)",
          "507:     {",
          "508:         stringBuilder->AppendCppLiteral(_u(\"Object, (ArrayBuffer)\"));",
          "509:         return TRUE;",
          "510:     }",
          "512:     BOOL ArrayBuffer::GetDiagValueString(StringBuilder<ArenaAllocator>* stringBuilder, ScriptContext* requestContext)",
          "513:     {",
          "514:         stringBuilder->AppendCppLiteral(_u(\"[object ArrayBuffer]\"));",
          "515:         return TRUE;",
          "516:     }",
          "518: #if ENABLE_TTD",
          "519:     void ArrayBufferParent::MarkVisitKindSpecificPtrs(TTD::SnapshotExtractor* extractor)",
          "520:     {",
          "521:         extractor->MarkVisitVar(this->arrayBuffer);",
          "522:     }",
          "524:     void ArrayBufferParent::ProcessCorePaths()",
          "525:     {",
          "526:         this->GetScriptContext()->TTDWellKnownInfo->EnqueueNewPathVarAsNeeded(this, this->arrayBuffer, _u(\"!buffer\"));",
          "527:     }",
          "528: #endif",
          "530:     JavascriptArrayBuffer::JavascriptArrayBuffer(uint32 length, DynamicType * type) :",
          "531:         ArrayBuffer(length, type, IsValidVirtualBufferLength(length) ? AsmJsVirtualAllocator : malloc)",
          "532:     {",
          "533:     }",
          "534:     JavascriptArrayBuffer::JavascriptArrayBuffer(byte* buffer, uint32 length, DynamicType * type) :",
          "535:         ArrayBuffer(buffer, length, type)",
          "536:     {",
          "537:     }",
          "539:     JavascriptArrayBuffer::JavascriptArrayBuffer(DynamicType * type) : ArrayBuffer(0, type, malloc)",
          "540:     {",
          "541:     }",
          "543:     JavascriptArrayBuffer* JavascriptArrayBuffer::Create(uint32 length, DynamicType * type)",
          "544:     {",
          "545:         Recycler* recycler = type->GetScriptContext()->GetRecycler();",
          "546:         JavascriptArrayBuffer* result = RecyclerNewFinalized(recycler, JavascriptArrayBuffer, length, type);",
          "547:         Assert(result);",
          "548:         recycler->AddExternalMemoryUsage(length);",
          "549:         return result;",
          "550:     }",
          "552:     JavascriptArrayBuffer* JavascriptArrayBuffer::Create(byte* buffer, uint32 length, DynamicType * type)",
          "553:     {",
          "554:         Recycler* recycler = type->GetScriptContext()->GetRecycler();",
          "555:         JavascriptArrayBuffer* result = RecyclerNewFinalized(recycler, JavascriptArrayBuffer, buffer, length, type);",
          "556:         Assert(result);",
          "557:         recycler->AddExternalMemoryUsage(length);",
          "558:         return result;",
          "559:     }",
          "561:     ArrayBufferDetachedStateBase* JavascriptArrayBuffer::CreateDetachedState(BYTE* buffer, uint32 bufferLength)",
          "562:     {",
          "563: #if ENABLE_FAST_ARRAYBUFFER",
          "564:         if (IsValidVirtualBufferLength(bufferLength))",
          "565:         {",
          "566:             return HeapNew(ArrayBufferDetachedState<FreeFn>, buffer, bufferLength, FreeMemAlloc, ArrayBufferAllocationType::MemAlloc);",
          "567:         }",
          "568:         else",
          "569:         {",
          "570:             return HeapNew(ArrayBufferDetachedState<FreeFn>, buffer, bufferLength, free, ArrayBufferAllocationType::Heap);",
          "571:         }",
          "572: #else",
          "573:         return HeapNew(ArrayBufferDetachedState<FreeFn>, buffer, bufferLength, free, ArrayBufferAllocationType::Heap);",
          "574: #endif",
          "575:     }",
          "577:     bool JavascriptArrayBuffer::IsValidAsmJsBufferLengthAlgo(uint length, bool forceCheck)",
          "578:     {",
          "580:         1. length >= 2^16",
          "581:         2. length is power of 2 or (length > 2^24 and length is multiple of 2^24)",
          "582:         3. length is a multiple of 4K",
          "584:         const bool isLongEnough = length >= 0x10000;",
          "585:         const bool isPow2 = ::Math::IsPow2(length);",
          "587:         const bool isMultipleOf2e24 = (length & 0xFFFFFF) == 0;",
          "588:         const bool isPageSizeMultiple = (length % AutoSystemInfo::PageSize) == 0;",
          "589:         return (",
          "590: #ifndef ENABLE_FAST_ARRAYBUFFER",
          "591:             forceCheck &&",
          "592: #endif",
          "593:             isLongEnough &&",
          "594:             (isPow2 || isMultipleOf2e24) &&",
          "595:             isPageSizeMultiple",
          "596:         );",
          "597:     }",
          "599:     bool JavascriptArrayBuffer::IsValidAsmJsBufferLength(uint length, bool forceCheck)",
          "600:     {",
          "601:         return IsValidAsmJsBufferLengthAlgo(length, forceCheck);",
          "602:     }",
          "604:     bool JavascriptArrayBuffer::IsValidVirtualBufferLength(uint length)",
          "605:     {",
          "606: #if ENABLE_FAST_ARRAYBUFFER",
          "607:         return !PHASE_OFF1(Js::TypedArrayVirtualPhase) && IsValidAsmJsBufferLengthAlgo(length, true);",
          "608: #else",
          "609:         return false;",
          "610: #endif",
          "611:     }",
          "613:     void JavascriptArrayBuffer::Finalize(bool isShutdown)",
          "614:     {",
          "624: #if ENABLE_FAST_ARRAYBUFFER",
          "626:         if (buffer && IsValidVirtualBufferLength(this->bufferLength))",
          "627:         {",
          "628:             FreeMemAlloc(buffer);",
          "629:         }",
          "630:         else",
          "631:         {",
          "632:             free(buffer);",
          "633:         }",
          "634: #else",
          "635:         free(buffer);",
          "636: #endif",
          "637:         Recycler* recycler = GetType()->GetLibrary()->GetRecycler();",
          "638:         recycler->ReportExternalMemoryFree(bufferLength);",
          "640:         buffer = nullptr;",
          "641:         bufferLength = 0;",
          "642:     }",
          "644:     void JavascriptArrayBuffer::Dispose(bool isShutdown)",
          "645:     {",
          "647:     }",
          "651:     static void MemCpyZero(__bcount(dstSize) BYTE* dst, size_t dstSize,",
          "652:         __in_bcount(count) const BYTE* src, size_t count)",
          "653:     {",
          "654:         js_memcpy_s(dst, dstSize, src, min(dstSize, count));",
          "655:         if (dstSize > count)",
          "656:         {",
          "657:             ZeroMemory(dst + count, dstSize - count);",
          "658:         }",
          "659:     }",
          "662:     static BYTE* ReallocZero(BYTE* ptr, size_t oldSize, size_t newSize)",
          "663:     {",
          "664:         BYTE* ptrNew = (BYTE*)realloc(ptr, newSize);",
          "665:         if (ptrNew && newSize > oldSize)",
          "666:         {",
          "667:             ZeroMemory(ptrNew + oldSize, newSize - oldSize);",
          "668:         }",
          "669:         return ptrNew;",
          "670:     }",
          "672:     ArrayBuffer * JavascriptArrayBuffer::TransferInternal(uint32 newBufferLength)",
          "673:     {",
          "674:         ArrayBuffer* newArrayBuffer;",
          "675:         Recycler* recycler = this->GetRecycler();",
          "677:         if (this->bufferLength > 0)",
          "678:         {",
          "679:             ReportDifferentialAllocation(newBufferLength);",
          "680:         }",
          "682:         if (newBufferLength == 0 || this->bufferLength == 0)",
          "683:         {",
          "684:             newArrayBuffer = GetLibrary()->CreateArrayBuffer(newBufferLength);",
          "685:             if (newBufferLength > 0 && !newArrayBuffer->GetByteLength())",
          "686:             {",
          "687:                 JavascriptError::ThrowOutOfMemoryError(GetScriptContext());",
          "688:             }",
          "689:         }",
          "690:         else",
          "691:         {",
          "692:             BYTE * newBuffer = nullptr;",
          "693:             if (IsValidVirtualBufferLength(this->bufferLength))",
          "694:             {",
          "695:                 if (IsValidVirtualBufferLength(newBufferLength))",
          "696:                 {",
          "698:                     if (newBufferLength < this->bufferLength)",
          "699:                     {",
          "700: #pragma prefast(suppress:6250, \"Calling 'VirtualFree' without the MEM_RELEASE flag might free memory but not address descriptors (VADs).\")",
          "701:                         VirtualFree(this->buffer + newBufferLength, this->bufferLength - newBufferLength, MEM_DECOMMIT);",
          "702:                     }",
          "703:                     else if (newBufferLength > this->bufferLength)",
          "704:                     {",
          "705:                         LPVOID newMem = VirtualAlloc(this->buffer + this->bufferLength, newBufferLength - this->bufferLength, MEM_COMMIT, PAGE_READWRITE);",
          "706:                         if (!newMem)",
          "707:                         {",
          "708:                             recycler->ReportExternalMemoryFailure(newBufferLength - this->bufferLength);",
          "709:                             JavascriptError::ThrowOutOfMemoryError(GetScriptContext());",
          "710:                         }",
          "711:                     }",
          "712:                     newBuffer = this->buffer;",
          "713:                 }",
          "714:                 else",
          "715:                 {",
          "717:                     newBuffer = (BYTE*)malloc(newBufferLength);",
          "718:                     if (!newBuffer)",
          "719:                     {",
          "720:                         recycler->ReportExternalMemoryFailure(newBufferLength - this->bufferLength);",
          "721:                         JavascriptError::ThrowOutOfMemoryError(GetScriptContext());",
          "722:                     }",
          "723:                     MemCpyZero(newBuffer, newBufferLength, this->buffer, this->bufferLength);",
          "724:                 }",
          "725:             }",
          "726:             else",
          "727:             {",
          "728:                 if (IsValidVirtualBufferLength(newBufferLength))",
          "729:                 {",
          "731:                     newBuffer = (BYTE*)AsmJsVirtualAllocator(newBufferLength);",
          "732:                     if (!newBuffer)",
          "733:                     {",
          "734:                         recycler->ReportExternalMemoryFailure(newBufferLength - this->bufferLength);",
          "735:                         JavascriptError::ThrowOutOfMemoryError(GetScriptContext());",
          "736:                     }",
          "737:                     MemCpyZero(newBuffer, newBufferLength, this->buffer, this->bufferLength);",
          "738:                 }",
          "739:                 else if (newBufferLength != this->bufferLength)",
          "740:                 {",
          "742:                     newBuffer = ReallocZero(this->buffer, this->bufferLength, newBufferLength);",
          "743:                     if (!newBuffer)",
          "744:                     {",
          "745:                         recycler->ReportExternalMemoryFailure(newBufferLength - this->bufferLength);",
          "746:                         JavascriptError::ThrowOutOfMemoryError(GetScriptContext());",
          "747:                     }",
          "748:                 }",
          "749:                 else",
          "750:                 {",
          "751:                     newBuffer = this->buffer;",
          "752:                 }",
          "753:             }",
          "754:             newArrayBuffer = GetLibrary()->CreateArrayBuffer(newBuffer, newBufferLength);",
          "756:         }",
          "757:         AutoDiscardPTR<Js::ArrayBufferDetachedStateBase> state(DetachAndGetState());",
          "758:         state->MarkAsClaimed();",
          "760:         return newArrayBuffer;",
          "761:     }",
          "763:     void JavascriptArrayBuffer::ReportDifferentialAllocation(uint32 newBufferLength)",
          "764:     {",
          "765:         Recycler* recycler = this->GetRecycler();",
          "770:         if (newBufferLength != this->bufferLength)",
          "771:         {",
          "773:             if (newBufferLength > this->bufferLength)",
          "774:             {",
          "775:                 if (!recycler->ReportExternalMemoryAllocation(newBufferLength - this->bufferLength))",
          "776:                 {",
          "777:                     recycler->CollectNow<CollectOnTypedArrayAllocation>();",
          "778:                     if (!recycler->ReportExternalMemoryAllocation(newBufferLength - this->bufferLength))",
          "779:                     {",
          "780:                         JavascriptError::ThrowOutOfMemoryError(GetScriptContext());",
          "781:                     }",
          "782:                 }",
          "783:             }",
          "785:             else",
          "786:             {",
          "787:                 recycler->ReportExternalMemoryFree(this->bufferLength - newBufferLength);",
          "788:             }",
          "789:         }",
          "790:     }",
          "792: #if ENABLE_TTD",
          "793:     TTD::NSSnapObjects::SnapObjectType JavascriptArrayBuffer::GetSnapTag_TTD() const",
          "794:     {",
          "795:         return TTD::NSSnapObjects::SnapObjectType::SnapArrayBufferObject;",
          "796:     }",
          "798:     void JavascriptArrayBuffer::ExtractSnapObjectDataInto(TTD::NSSnapObjects::SnapObject* objData, TTD::SlabAllocator& alloc)",
          "799:     {",
          "800:         TTD::NSSnapObjects::SnapArrayBufferInfo* sabi = alloc.SlabAllocateStruct<TTD::NSSnapObjects::SnapArrayBufferInfo>();",
          "802:         sabi->Length = this->GetByteLength();",
          "803:         if (sabi->Length == 0)",
          "804:         {",
          "805:             sabi->Buff = nullptr;",
          "806:         }",
          "807:         else",
          "808:         {",
          "809:             sabi->Buff = alloc.SlabAllocateArray<byte>(sabi->Length);",
          "810:             memcpy(sabi->Buff, this->GetBuffer(), sabi->Length);",
          "811:         }",
          "813:         TTD::NSSnapObjects::StdExtractSetKindSpecificInfo<TTD::NSSnapObjects::SnapArrayBufferInfo*, TTD::NSSnapObjects::SnapObjectType::SnapArrayBufferObject>(objData, sabi);",
          "814:     }",
          "815: #endif",
          "819:     WebAssemblyArrayBuffer::WebAssemblyArrayBuffer(uint32 length, DynamicType * type) :",
          "820: #ifndef ENABLE_FAST_ARRAYBUFFER",
          "822:         JavascriptArrayBuffer(length, type) {}",
          "823: #else",
          "824:         JavascriptArrayBuffer(length, type, WasmVirtualAllocator)",
          "825:     {",
          "827:         if (buffer == nullptr)",
          "828:         {",
          "830:             Assert(length == 0);",
          "831:             buffer = (BYTE*)WasmVirtualAllocator(0);",
          "832:             if (buffer == nullptr)",
          "833:             {",
          "834:                 JavascriptError::ThrowOutOfMemoryError(GetScriptContext());",
          "835:             }",
          "836:         }",
          "837:     }",
          "838: #endif",
          "840:     WebAssemblyArrayBuffer::WebAssemblyArrayBuffer(byte* buffer, uint32 length, DynamicType * type):",
          "841:         JavascriptArrayBuffer(buffer, length, type)",
          "842:     {",
          "844:     }",
          "846:     WebAssemblyArrayBuffer* WebAssemblyArrayBuffer::Create(byte* buffer, uint32 length, DynamicType * type)",
          "847:     {",
          "848:         Recycler* recycler = type->GetScriptContext()->GetRecycler();",
          "849:         WebAssemblyArrayBuffer* result;",
          "850:         if (buffer)",
          "851:         {",
          "852:             result = RecyclerNewFinalized(recycler, WebAssemblyArrayBuffer, buffer, length, type);",
          "853:         }",
          "854:         else",
          "855:         {",
          "856:             result = RecyclerNewFinalized(recycler, WebAssemblyArrayBuffer, length, type);",
          "857:         }",
          "858:         Assert(result);",
          "859:         recycler->AddExternalMemoryUsage(length);",
          "860:         return result;",
          "861:     }",
          "863:     bool WebAssemblyArrayBuffer::IsValidVirtualBufferLength(uint length)",
          "864:     {",
          "865: #if ENABLE_FAST_ARRAYBUFFER",
          "866:         return true;",
          "867: #else",
          "868:         return false;",
          "869: #endif",
          "870:     }",
          "872:     ArrayBuffer * WebAssemblyArrayBuffer::TransferInternal(uint32 newBufferLength)",
          "873:     {",
          "874: #if ENABLE_FAST_ARRAYBUFFER",
          "875:         ReportDifferentialAllocation(newBufferLength);",
          "876:         Assert(this->buffer);",
          "878:         AssertMsg(newBufferLength > this->bufferLength, \"The only supported scenario in WebAssembly is to grow the memory\");",
          "879:         if (newBufferLength > this->bufferLength)",
          "880:         {",
          "881:             LPVOID newMem = VirtualAlloc(this->buffer + this->bufferLength, newBufferLength - this->bufferLength, MEM_COMMIT, PAGE_READWRITE);",
          "882:             if (!newMem)",
          "883:             {",
          "884:                 Recycler* recycler = this->GetRecycler();",
          "885:                 recycler->ReportExternalMemoryFailure(newBufferLength);",
          "886:                 JavascriptError::ThrowOutOfMemoryError(GetScriptContext());",
          "887:             }",
          "888:         }",
          "889:         ArrayBuffer* newArrayBuffer = GetLibrary()->CreateWebAssemblyArrayBuffer(this->buffer, newBufferLength);",
          "891:         AutoDiscardPTR<Js::ArrayBufferDetachedStateBase> state(DetachAndGetState());",
          "892:         state->MarkAsClaimed();",
          "894:         return newArrayBuffer;",
          "895: #else",
          "896:         return JavascriptArrayBuffer::TransferInternal(newBufferLength);",
          "897: #endif",
          "898:     }",
          "900:     ProjectionArrayBuffer::ProjectionArrayBuffer(uint32 length, DynamicType * type) :",
          "901:         ArrayBuffer(length, type, CoTaskMemAlloc)",
          "902:     {",
          "903:     }",
          "905:     ProjectionArrayBuffer::ProjectionArrayBuffer(byte* buffer, uint32 length, DynamicType * type) :",
          "906:         ArrayBuffer(buffer, length, type)",
          "907:     {",
          "908:     }",
          "910:     ProjectionArrayBuffer* ProjectionArrayBuffer::Create(uint32 length, DynamicType * type)",
          "911:     {",
          "912:         Recycler* recycler = type->GetScriptContext()->GetRecycler();",
          "913:         recycler->AddExternalMemoryUsage(length);",
          "914:         return RecyclerNewFinalized(recycler, ProjectionArrayBuffer, length, type);",
          "915:     }",
          "917:     ProjectionArrayBuffer* ProjectionArrayBuffer::Create(byte* buffer, uint32 length, DynamicType * type)",
          "918:     {",
          "919:         Recycler* recycler = type->GetScriptContext()->GetRecycler();",
          "922:         recycler->AddExternalMemoryUsage(length);",
          "923:         return RecyclerNewFinalized(recycler, ProjectionArrayBuffer, buffer, length, type);",
          "924:     }",
          "926:     void ProjectionArrayBuffer::Dispose(bool isShutdown)",
          "927:     {",
          "928:         CoTaskMemFree(buffer);",
          "929:     }",
          "931:     ArrayBuffer * ProjectionArrayBuffer::TransferInternal(uint32 newBufferLength)",
          "932:     {",
          "933:         ArrayBuffer* newArrayBuffer;",
          "934:         if (newBufferLength == 0 || this->bufferLength == 0)",
          "935:         {",
          "936:             newArrayBuffer = GetLibrary()->CreateProjectionArraybuffer(newBufferLength);",
          "937:         }",
          "938:         else",
          "939:         {",
          "940:             BYTE * newBuffer = (BYTE*)CoTaskMemRealloc(this->buffer, newBufferLength);",
          "941:             if (!newBuffer)",
          "942:             {",
          "943:                 JavascriptError::ThrowOutOfMemoryError(GetScriptContext());",
          "944:             }",
          "945:             newArrayBuffer = GetLibrary()->CreateProjectionArraybuffer(newBuffer, newBufferLength);",
          "946:         }",
          "948:         AutoDiscardPTR<Js::ArrayBufferDetachedStateBase> state(DetachAndGetState());",
          "949:         state->MarkAsClaimed();",
          "951:         return newArrayBuffer;",
          "952:     }",
          "954:     ExternalArrayBuffer::ExternalArrayBuffer(byte *buffer, uint32 length, DynamicType *type)",
          "955:         : ArrayBuffer(buffer, length, type)",
          "956:     {",
          "957:     }",
          "959: #if ENABLE_TTD",
          "960:     TTD::NSSnapObjects::SnapObjectType ExternalArrayBuffer::GetSnapTag_TTD() const",
          "961:     {",
          "963:         return TTD::NSSnapObjects::SnapObjectType::SnapArrayBufferObject;",
          "964:     }",
          "966:     void ExternalArrayBuffer::ExtractSnapObjectDataInto(TTD::NSSnapObjects::SnapObject* objData, TTD::SlabAllocator& alloc)",
          "967:     {",
          "968:         TTD::NSSnapObjects::SnapArrayBufferInfo* sabi = alloc.SlabAllocateStruct<TTD::NSSnapObjects::SnapArrayBufferInfo>();",
          "970:         sabi->Length = this->GetByteLength();",
          "971:         if(sabi->Length == 0)",
          "972:         {",
          "973:             sabi->Buff = nullptr;",
          "974:         }",
          "975:         else",
          "976:         {",
          "977:             sabi->Buff = alloc.SlabAllocateArray<byte>(sabi->Length);",
          "978:             memcpy(sabi->Buff, this->GetBuffer(), sabi->Length);",
          "979:         }",
          "981:         TTD::NSSnapObjects::StdExtractSetKindSpecificInfo<TTD::NSSnapObjects::SnapArrayBufferInfo*, TTD::NSSnapObjects::SnapObjectType::SnapArrayBufferObject>(objData, sabi);",
          "982:     }",
          "983: #endif",
          "984: }",
          "",
          "[Added Lines]",
          "5: #include \"RuntimeLibraryPch.h\"",
          "7: namespace Js",
          "8: {",
          "9:     bool ArrayBufferBase::Is(Var value)",
          "10:     {",
          "11:         return ArrayBuffer::Is(value) || SharedArrayBuffer::Is(value);",
          "12:     }",
          "14:     ArrayBufferBase* ArrayBufferBase::FromVar(Var value)",
          "15:     {",
          "16:         Assert(ArrayBufferBase::Is(value));",
          "17:         return static_cast<ArrayBuffer *> (value);",
          "18:     }",
          "20:     ArrayBuffer* ArrayBuffer::NewFromDetachedState(DetachedStateBase* state, JavascriptLibrary *library)",
          "21:     {",
          "22:         ArrayBufferDetachedStateBase* arrayBufferState = (ArrayBufferDetachedStateBase *)state;",
          "23:         ArrayBuffer *toReturn = nullptr;",
          "25:         switch (arrayBufferState->allocationType)",
          "26:         {",
          "27:         case ArrayBufferAllocationType::CoTask:",
          "28:             toReturn = library->CreateProjectionArraybuffer(arrayBufferState->buffer, arrayBufferState->bufferLength);",
          "29:             break;",
          "30:         case ArrayBufferAllocationType::Heap:",
          "31:         case ArrayBufferAllocationType::MemAlloc:",
          "32:             toReturn = library->CreateArrayBuffer(arrayBufferState->buffer, arrayBufferState->bufferLength);",
          "33:             break;",
          "34:         default:",
          "35:             AssertMsg(false, \"Unknown allocationType of ArrayBufferDetachedStateBase \");",
          "36:         }",
          "38:         return toReturn;",
          "39:     }",
          "41:     void ArrayBuffer::ClearParentsLength(ArrayBufferParent* parent)",
          "42:     {",
          "43:         if (parent == nullptr)",
          "44:         {",
          "45:             return;",
          "46:         }",
          "48:         switch (JavascriptOperators::GetTypeId(parent))",
          "49:         {",
          "50:         case TypeIds_Int8Array:",
          "51:         case TypeIds_Uint8Array:",
          "52:         case TypeIds_Uint8ClampedArray:",
          "53:         case TypeIds_Int16Array:",
          "54:         case TypeIds_Uint16Array:",
          "55:         case TypeIds_Int32Array:",
          "56:         case TypeIds_Uint32Array:",
          "57:         case TypeIds_Float32Array:",
          "58:         case TypeIds_Float64Array:",
          "59:         case TypeIds_Int64Array:",
          "60:         case TypeIds_Uint64Array:",
          "61:         case TypeIds_CharArray:",
          "62:         case TypeIds_BoolArray:",
          "63:             TypedArrayBase::FromVar(parent)->length = 0;",
          "64:             break;",
          "66:         case TypeIds_DataView:",
          "67:             DataView::FromVar(parent)->length = 0;",
          "68:             break;",
          "70:         default:",
          "71:             AssertMsg(false, \"We need an explicit case for any parent of ArrayBuffer.\");",
          "72:             break;",
          "73:         }",
          "74:     }",
          "76:     ArrayBufferDetachedStateBase* ArrayBuffer::DetachAndGetState()",
          "77:     {",
          "78:         Assert(!this->isDetached);",
          "80:         AutoPtr<ArrayBufferDetachedStateBase> arrayBufferState(this->CreateDetachedState(this->buffer, this->bufferLength));",
          "82:         this->buffer = nullptr;",
          "83:         this->bufferLength = 0;",
          "84:         this->isDetached = true;",
          "86:         if (this->primaryParent != nullptr && this->primaryParent->Get() == nullptr)",
          "87:         {",
          "88:             this->primaryParent = nullptr;",
          "89:         }",
          "91:         if (this->primaryParent != nullptr)",
          "92:         {",
          "93:             this->ClearParentsLength(this->primaryParent->Get());",
          "94:         }",
          "96:         if (this->otherParents != nullptr)",
          "97:         {",
          "98:             this->otherParents->Map([&](RecyclerWeakReference<ArrayBufferParent>* item)",
          "99:             {",
          "100:                 this->ClearParentsLength(item->Get());",
          "101:             });",
          "102:         }",
          "104:         return arrayBufferState.Detach();",
          "105:     }",
          "107:     void ArrayBuffer::AddParent(ArrayBufferParent* parent)",
          "108:     {",
          "109:         if (this->primaryParent == nullptr || this->primaryParent->Get() == nullptr)",
          "110:         {",
          "111:             this->primaryParent = this->GetRecycler()->CreateWeakReferenceHandle(parent);",
          "112:         }",
          "113:         else",
          "114:         {",
          "115:             if (this->otherParents == nullptr)",
          "116:             {",
          "117:                 this->otherParents = RecyclerNew(this->GetRecycler(), OtherParents, this->GetRecycler());",
          "118:             }",
          "120:             if (this->otherParents->increasedCount >= ParentsCleanupThreshold)",
          "121:             {",
          "122:                 auto iter = this->otherParents->GetEditingIterator();",
          "123:                 while (iter.Next())",
          "124:                 {",
          "125:                     if (iter.Data()->Get() == nullptr)",
          "126:                     {",
          "127:                         iter.RemoveCurrent();",
          "128:                     }",
          "129:                 }",
          "131:                 this->otherParents->increasedCount = 0;",
          "132:             }",
          "134:             this->otherParents->PrependNode(this->GetRecycler()->CreateWeakReferenceHandle(parent));",
          "135:             this->otherParents->increasedCount++;",
          "136:         }",
          "137:     }",
          "139:     uint32 ArrayBuffer::ToIndex(Var value, int32 errorCode, ScriptContext *scriptContext, uint32 MaxAllowedLength, bool checkSameValueZero)",
          "140:     {",
          "141:         if (JavascriptOperators::IsUndefined(value))",
          "142:         {",
          "143:             return 0;",
          "144:         }",
          "146:         if (TaggedInt::Is(value))",
          "147:         {",
          "148:             int64 index = TaggedInt::ToInt64(value);",
          "149:             if (index < 0 || index >(int64)MaxAllowedLength)",
          "150:             {",
          "151:                 JavascriptError::ThrowRangeError(scriptContext, errorCode);",
          "152:             }",
          "154:             return  (uint32)index;",
          "155:         }",
          "159:         double d = JavascriptConversion::ToInteger(value, scriptContext);",
          "160:         if (d < 0.0 || d >(double)MaxAllowedLength)",
          "161:         {",
          "162:             JavascriptError::ThrowRangeError(scriptContext, errorCode);",
          "163:         }",
          "165:         if (checkSameValueZero)",
          "166:         {",
          "167:             Var integerIndex = JavascriptNumber::ToVarNoCheck(d, scriptContext);",
          "168:             Var index = JavascriptNumber::ToVar(JavascriptConversion::ToLength(integerIndex, scriptContext), scriptContext);",
          "169:             if (!JavascriptConversion::SameValueZero(integerIndex, index))",
          "170:             {",
          "171:                 JavascriptError::ThrowRangeError(scriptContext, errorCode);",
          "172:             }",
          "173:         }",
          "175:         return (uint32)d;",
          "176:     }",
          "178:     Var ArrayBuffer::NewInstance(RecyclableObject* function, CallInfo callInfo, ...)",
          "179:     {",
          "180:         PROBE_STACK(function->GetScriptContext(), Js::Constants::MinStackDefault);",
          "182:         ARGUMENTS(args, callInfo);",
          "183:         ScriptContext* scriptContext = function->GetScriptContext();",
          "185:         AssertMsg(args.Info.Count > 0, \"Should always have implicit 'this'\");",
          "187:         Var newTarget = callInfo.Flags & CallFlags_NewTarget ? args.Values[args.Info.Count] : args[0];",
          "188:         bool isCtorSuperCall = (callInfo.Flags & CallFlags_New) && newTarget != nullptr && !JavascriptOperators::IsUndefined(newTarget);",
          "189:         Assert(isCtorSuperCall || !(callInfo.Flags & CallFlags_New) || args[0] == nullptr);",
          "191:         if (!(callInfo.Flags & CallFlags_New) || (newTarget && JavascriptOperators::IsUndefinedObject(newTarget)))",
          "192:         {",
          "193:             JavascriptError::ThrowTypeError(scriptContext, JSERR_ClassConstructorCannotBeCalledWithoutNew, _u(\"ArrayBuffer\"));",
          "194:         }",
          "196:         uint32 byteLength = 0;",
          "197:         if (args.Info.Count > 1)",
          "198:         {",
          "199:             byteLength = ToIndex(args[1], JSERR_ArrayLengthConstructIncorrect, scriptContext, MaxArrayBufferLength);",
          "200:         }",
          "202:         RecyclableObject* newArr = scriptContext->GetLibrary()->CreateArrayBuffer(byteLength);",
          "203:         Assert(ArrayBuffer::Is(newArr));",
          "204:         if (byteLength > 0 && !ArrayBuffer::FromVar(newArr)->GetByteLength())",
          "205:         {",
          "206:             JavascriptError::ThrowRangeError(scriptContext, JSERR_FunctionArgument_Invalid);",
          "207:         }",
          "208: #if ENABLE_DEBUG_CONFIG_OPTIONS",
          "209:         if (Js::Configuration::Global.flags.IsEnabled(Js::autoProxyFlag))",
          "210:         {",
          "211:             newArr = Js::JavascriptProxy::AutoProxyWrapper(newArr);",
          "212:         }",
          "213: #endif",
          "214:         return isCtorSuperCall ?",
          "215:             JavascriptOperators::OrdinaryCreateFromConstructor(RecyclableObject::FromVar(newTarget), newArr, nullptr, scriptContext) :",
          "216:             newArr;",
          "217:     }",
          "220:     Var ArrayBuffer::EntryGetterByteLength(RecyclableObject* function, CallInfo callInfo, ...)",
          "221:     {",
          "222:         PROBE_STACK(function->GetScriptContext(), Js::Constants::MinStackDefault);",
          "224:         ARGUMENTS(args, callInfo);",
          "225:         ScriptContext* scriptContext = function->GetScriptContext();",
          "227:         Assert(!(callInfo.Flags & CallFlags_New));",
          "229:         if (args.Info.Count == 0 || !ArrayBuffer::Is(args[0]))",
          "230:         {",
          "231:             JavascriptError::ThrowTypeError(scriptContext, JSERR_NeedArrayBufferObject);",
          "232:         }",
          "234:         ArrayBuffer* arrayBuffer = ArrayBuffer::FromVar(args[0]);",
          "235:         if (arrayBuffer->IsDetached())",
          "236:         {",
          "237:             return JavascriptNumber::ToVar(0, scriptContext);",
          "238:         }",
          "239:         return JavascriptNumber::ToVar(arrayBuffer->GetByteLength(), scriptContext);",
          "240:     }",
          "243:     Var ArrayBuffer::EntryIsView(RecyclableObject* function, CallInfo callInfo, ...)",
          "244:     {",
          "245:         PROBE_STACK(function->GetScriptContext(), Js::Constants::MinStackDefault);",
          "247:         ARGUMENTS(args, callInfo);",
          "249:         Assert(!(callInfo.Flags & CallFlags_New));",
          "251:         AssertMsg(args.Info.Count > 0, \"Should always have implicit 'this'\");",
          "253:         JavascriptLibrary* library = function->GetScriptContext()->GetLibrary();",
          "255:         Var arg = library->GetUndefined();",
          "257:         if (args.Info.Count > 1)",
          "258:         {",
          "259:             arg = args[1];",
          "260:         }",
          "263:         if (DataView::Is(arg) || TypedArrayBase::Is(arg))",
          "264:         {",
          "265:             return library->GetTrue();",
          "266:         }",
          "268:         return library->GetFalse();",
          "269:     }",
          "272:     Var ArrayBuffer::EntryTransfer(RecyclableObject* function, CallInfo callInfo, ...)",
          "273:     {",
          "274:         ScriptContext* scriptContext = function->GetScriptContext();",
          "276:         PROBE_STACK(scriptContext, Js::Constants::MinStackDefault);",
          "278:         ARGUMENTS(args, callInfo);",
          "280:         Assert(!(callInfo.Flags & CallFlags_New));",
          "282:         CHAKRATEL_LANGSTATS_INC_BUILTINCOUNT(ArrayBuffer_Constructor_transfer);",
          "284:         if (args.Info.Count < 2 || !ArrayBuffer::Is(args[1]))",
          "285:         {",
          "286:             JavascriptError::ThrowTypeError(scriptContext, JSERR_NeedArrayBufferObject);",
          "287:         }",
          "289:         ArrayBuffer* arrayBuffer = ArrayBuffer::FromVar(args[1]);",
          "291:         if (arrayBuffer->IsDetached())",
          "292:         {",
          "293:             JavascriptError::ThrowTypeError(scriptContext, JSERR_DetachedTypedArray, _u(\"ArrayBuffer.transfer\"));",
          "294:         }",
          "296:         uint32 newBufferLength = arrayBuffer->bufferLength;",
          "297:         if (args.Info.Count >= 3)",
          "298:         {",
          "299:             newBufferLength = ToIndex(args[2], JSERR_ArrayLengthConstructIncorrect, scriptContext, MaxArrayBufferLength);",
          "302:             if (arrayBuffer->IsDetached())",
          "303:             {",
          "304:                 JavascriptError::ThrowTypeError(scriptContext, JSERR_DetachedTypedArray, _u(\"ArrayBuffer.transfer\"));",
          "305:             }",
          "306:         }",
          "308:         return arrayBuffer->TransferInternal(newBufferLength);",
          "309:     }",
          "312:     Var ArrayBuffer::EntrySlice(RecyclableObject* function, CallInfo callInfo, ...)",
          "313:     {",
          "314:         ScriptContext* scriptContext = function->GetScriptContext();",
          "316:         PROBE_STACK(scriptContext, Js::Constants::MinStackDefault);",
          "318:         ARGUMENTS(args, callInfo);",
          "320:         AssertMsg(args.Info.Count > 0, \"Should always have implicit 'this'\");",
          "322:         Assert(!(callInfo.Flags & CallFlags_New));",
          "324:         if (!ArrayBuffer::Is(args[0]))",
          "325:         {",
          "326:             JavascriptError::ThrowTypeError(scriptContext, JSERR_NeedArrayBufferObject);",
          "327:         }",
          "329:         JavascriptLibrary* library = scriptContext->GetLibrary();",
          "330:         ArrayBuffer* arrayBuffer = ArrayBuffer::FromVar(args[0]);",
          "332:         if (arrayBuffer->IsDetached()) // 24.1.4.3: 5. If IsDetachedBuffer(O) is true, then throw a TypeError exception.",
          "333:         {",
          "334:             JavascriptError::ThrowTypeError(scriptContext, JSERR_DetachedTypedArray, _u(\"ArrayBuffer.prototype.slice\"));",
          "335:         }",
          "337:         int64 len = arrayBuffer->bufferLength;",
          "338:         int64 start = 0, end = 0;",
          "339:         int64 newLen;",
          "342:         if (args.Info.Count < 2)",
          "343:         {",
          "344:             newLen = len;",
          "345:         }",
          "346:         else",
          "347:         {",
          "348:             start = JavascriptArray::GetIndexFromVar(args[1], len, scriptContext);",
          "351:             if (args.Info.Count < 3 || args[2] == library->GetUndefined())",
          "352:             {",
          "353:                 end = len;",
          "354:             }",
          "355:             else",
          "356:             {",
          "357:                 end = JavascriptArray::GetIndexFromVar(args[2], len, scriptContext);",
          "358:             }",
          "360:             newLen = end > start ? end - start : 0;",
          "361:         }",
          "367:         Assert(newLen < MaxArrayBufferLength);",
          "368:         uint32 byteLength = static_cast<uint32>(newLen);",
          "370:         ArrayBuffer* newBuffer = nullptr;",
          "372:         if (scriptContext->GetConfig()->IsES6SpeciesEnabled())",
          "373:         {",
          "374:             Var constructorVar = JavascriptOperators::SpeciesConstructor(arrayBuffer, scriptContext->GetLibrary()->GetArrayBufferConstructor(), scriptContext);",
          "376:             JavascriptFunction* constructor = JavascriptFunction::FromVar(constructorVar);",
          "378:             Js::Var constructorArgs[] = {constructor, JavascriptNumber::ToVar(byteLength, scriptContext)};",
          "379:             Js::CallInfo constructorCallInfo(Js::CallFlags_New, _countof(constructorArgs));",
          "380:             Js::Var newVar = JavascriptOperators::NewScObject(constructor, Js::Arguments(constructorCallInfo, constructorArgs), scriptContext);",
          "382:             if (!ArrayBuffer::Is(newVar)) // 24.1.4.3: 19.If new does not have an [[ArrayBufferData]] internal slot throw a TypeError exception.",
          "383:             {",
          "384:                 JavascriptError::ThrowTypeError(scriptContext, JSERR_NeedArrayBufferObject);",
          "385:             }",
          "387:             newBuffer = ArrayBuffer::FromVar(newVar);",
          "389:             if (newBuffer->IsDetached()) // 24.1.4.3: 21. If IsDetachedBuffer(new) is true, then throw a TypeError exception.",
          "390:             {",
          "391:                 JavascriptError::ThrowTypeError(scriptContext, JSERR_DetachedTypedArray, _u(\"ArrayBuffer.prototype.slice\"));",
          "392:             }",
          "394:             if (newBuffer == arrayBuffer) // 24.1.4.3: 22. If SameValue(new, O) is true, then throw a TypeError exception.",
          "395:             {",
          "396:                 JavascriptError::ThrowTypeError(scriptContext, JSERR_NeedArrayBufferObject);",
          "397:             }",
          "399:             if (newBuffer->bufferLength < byteLength) // 24.1.4.3: 23.If the value of new's [[ArrayBufferByteLength]] internal slot < newLen, then throw a TypeError exception.",
          "400:             {",
          "401:                 JavascriptError::ThrowTypeError(scriptContext, JSERR_ArgumentOutOfRange, _u(\"ArrayBuffer.prototype.slice\"));",
          "402:             }",
          "403:         }",
          "404:         else",
          "405:         {",
          "406:             newBuffer = library->CreateArrayBuffer(byteLength);",
          "407:         }",
          "409:         Assert(newBuffer);",
          "410:         Assert(newBuffer->bufferLength >= byteLength);",
          "412:         if (arrayBuffer->IsDetached()) // 24.1.4.3: 24. NOTE: Side-effects of the above steps may have detached O. 25. If IsDetachedBuffer(O) is true, then throw a TypeError exception.",
          "413:         {",
          "414:             JavascriptError::ThrowTypeError(scriptContext, JSERR_DetachedTypedArray, _u(\"ArrayBuffer.prototype.slice\"));",
          "415:         }",
          "418:         if (byteLength > 0)",
          "419:         {",
          "420:             AssertMsg(arrayBuffer->buffer != nullptr, \"buffer must not be null when we copy from it\");",
          "422:             js_memcpy_s(newBuffer->buffer, byteLength, arrayBuffer->buffer + start, byteLength);",
          "423:         }",
          "425:         return newBuffer;",
          "426:     }",
          "428:     Var ArrayBuffer::EntryGetterSymbolSpecies(RecyclableObject* function, CallInfo callInfo, ...)",
          "429:     {",
          "430:         ARGUMENTS(args, callInfo);",
          "432:         Assert(args.Info.Count > 0);",
          "434:         return args[0];",
          "435:     }",
          "437:     ArrayBuffer* ArrayBuffer::FromVar(Var aValue)",
          "438:     {",
          "439:         AssertMsg(Is(aValue), \"var must be an ArrayBuffer\");",
          "441:         return static_cast<ArrayBuffer *>(RecyclableObject::FromVar(aValue));",
          "442:     }",
          "444:     bool  ArrayBuffer::Is(Var aValue)",
          "445:     {",
          "446:         return JavascriptOperators::GetTypeId(aValue) == TypeIds_ArrayBuffer;",
          "447:     }",
          "449:     template <class Allocator>",
          "450:     ArrayBuffer::ArrayBuffer(uint32 length, DynamicType * type, Allocator allocator) :",
          "451:         ArrayBufferBase(type)",
          "452:     {",
          "453:         buffer = nullptr;",
          "454:         bufferLength = 0;",
          "455:         if (length > MaxArrayBufferLength)",
          "456:         {",
          "457:             JavascriptError::ThrowTypeError(GetScriptContext(), JSERR_FunctionArgument_Invalid);",
          "458:         }",
          "459:         else if (length > 0)",
          "460:         {",
          "461:             Recycler* recycler = GetType()->GetLibrary()->GetRecycler();",
          "462:             if (recycler->ReportExternalMemoryAllocation(length))",
          "463:             {",
          "464:                 buffer = (BYTE*)allocator(length);",
          "465:                 if (buffer == nullptr)",
          "466:                 {",
          "467:                     recycler->ReportExternalMemoryFree(length);",
          "468:                 }",
          "469:             }",
          "471:             if (buffer == nullptr)",
          "472:             {",
          "473:                 recycler->CollectNow<CollectOnTypedArrayAllocation>();",
          "475:                 if (recycler->ReportExternalMemoryAllocation(length))",
          "476:                 {",
          "477:                     buffer = (BYTE*)allocator(length);",
          "478:                     if (buffer == nullptr)",
          "479:                     {",
          "480:                         recycler->ReportExternalMemoryFailure(length);",
          "481:                     }",
          "482:                 }",
          "483:                 else",
          "484:                 {",
          "485:                     JavascriptError::ThrowOutOfMemoryError(GetScriptContext());",
          "486:                 }",
          "487:             }",
          "489:             if (buffer != nullptr)",
          "490:             {",
          "491:                 bufferLength = length;",
          "492:                 ZeroMemory(buffer, bufferLength);",
          "493:             }",
          "494:         }",
          "495:     }",
          "497:     ArrayBuffer::ArrayBuffer(byte* buffer, uint32 length, DynamicType * type) :",
          "498:         buffer(buffer), bufferLength(length), ArrayBufferBase(type)",
          "499:     {",
          "500:         if (length > MaxArrayBufferLength)",
          "501:         {",
          "502:             JavascriptError::ThrowTypeError(GetScriptContext(), JSERR_FunctionArgument_Invalid);",
          "503:         }",
          "504:     }",
          "506:     BOOL ArrayBuffer::GetDiagTypeString(StringBuilder<ArenaAllocator>* stringBuilder, ScriptContext* requestContext)",
          "507:     {",
          "508:         stringBuilder->AppendCppLiteral(_u(\"Object, (ArrayBuffer)\"));",
          "509:         return TRUE;",
          "510:     }",
          "512:     BOOL ArrayBuffer::GetDiagValueString(StringBuilder<ArenaAllocator>* stringBuilder, ScriptContext* requestContext)",
          "513:     {",
          "514:         stringBuilder->AppendCppLiteral(_u(\"[object ArrayBuffer]\"));",
          "515:         return TRUE;",
          "516:     }",
          "518: #if ENABLE_TTD",
          "519:     void ArrayBufferParent::MarkVisitKindSpecificPtrs(TTD::SnapshotExtractor* extractor)",
          "520:     {",
          "521:         extractor->MarkVisitVar(this->arrayBuffer);",
          "522:     }",
          "524:     void ArrayBufferParent::ProcessCorePaths()",
          "525:     {",
          "526:         this->GetScriptContext()->TTDWellKnownInfo->EnqueueNewPathVarAsNeeded(this, this->arrayBuffer, _u(\"!buffer\"));",
          "527:     }",
          "528: #endif",
          "530:     JavascriptArrayBuffer::JavascriptArrayBuffer(uint32 length, DynamicType * type) :",
          "531:         ArrayBuffer(length, type, IsValidVirtualBufferLength(length) ? AsmJsVirtualAllocator : malloc)",
          "532:     {",
          "533:     }",
          "534:     JavascriptArrayBuffer::JavascriptArrayBuffer(byte* buffer, uint32 length, DynamicType * type) :",
          "535:         ArrayBuffer(buffer, length, type)",
          "536:     {",
          "537:     }",
          "539:     JavascriptArrayBuffer::JavascriptArrayBuffer(DynamicType * type) : ArrayBuffer(0, type, malloc)",
          "540:     {",
          "541:     }",
          "543:     JavascriptArrayBuffer* JavascriptArrayBuffer::Create(uint32 length, DynamicType * type)",
          "544:     {",
          "545:         Recycler* recycler = type->GetScriptContext()->GetRecycler();",
          "546:         JavascriptArrayBuffer* result = RecyclerNewFinalized(recycler, JavascriptArrayBuffer, length, type);",
          "547:         Assert(result);",
          "548:         recycler->AddExternalMemoryUsage(length);",
          "549:         return result;",
          "550:     }",
          "552:     JavascriptArrayBuffer* JavascriptArrayBuffer::Create(byte* buffer, uint32 length, DynamicType * type)",
          "553:     {",
          "554:         Recycler* recycler = type->GetScriptContext()->GetRecycler();",
          "555:         JavascriptArrayBuffer* result = RecyclerNewFinalized(recycler, JavascriptArrayBuffer, buffer, length, type);",
          "556:         Assert(result);",
          "557:         recycler->AddExternalMemoryUsage(length);",
          "558:         return result;",
          "559:     }",
          "561:     ArrayBufferDetachedStateBase* JavascriptArrayBuffer::CreateDetachedState(BYTE* buffer, uint32 bufferLength)",
          "562:     {",
          "563: #if ENABLE_FAST_ARRAYBUFFER",
          "564:         if (IsValidVirtualBufferLength(bufferLength))",
          "565:         {",
          "566:             return HeapNew(ArrayBufferDetachedState<FreeFn>, buffer, bufferLength, FreeMemAlloc, ArrayBufferAllocationType::MemAlloc);",
          "567:         }",
          "568:         else",
          "569:         {",
          "570:             return HeapNew(ArrayBufferDetachedState<FreeFn>, buffer, bufferLength, free, ArrayBufferAllocationType::Heap);",
          "571:         }",
          "572: #else",
          "573:         return HeapNew(ArrayBufferDetachedState<FreeFn>, buffer, bufferLength, free, ArrayBufferAllocationType::Heap);",
          "574: #endif",
          "575:     }",
          "577:     bool JavascriptArrayBuffer::IsValidAsmJsBufferLengthAlgo(uint length, bool forceCheck)",
          "578:     {",
          "580:         1. length >= 2^16",
          "581:         2. length is power of 2 or (length > 2^24 and length is multiple of 2^24)",
          "582:         3. length is a multiple of 4K",
          "584:         const bool isLongEnough = length >= 0x10000;",
          "585:         const bool isPow2 = ::Math::IsPow2(length);",
          "587:         const bool isMultipleOf2e24 = (length & 0xFFFFFF) == 0;",
          "588:         const bool isPageSizeMultiple = (length % AutoSystemInfo::PageSize) == 0;",
          "589:         return (",
          "590: #ifndef ENABLE_FAST_ARRAYBUFFER",
          "591:             forceCheck &&",
          "592: #endif",
          "593:             isLongEnough &&",
          "594:             (isPow2 || isMultipleOf2e24) &&",
          "595:             isPageSizeMultiple",
          "596:         );",
          "597:     }",
          "599:     bool JavascriptArrayBuffer::IsValidAsmJsBufferLength(uint length, bool forceCheck)",
          "600:     {",
          "601:         return IsValidAsmJsBufferLengthAlgo(length, forceCheck);",
          "602:     }",
          "604:     bool JavascriptArrayBuffer::IsValidVirtualBufferLength(uint length)",
          "605:     {",
          "606: #if ENABLE_FAST_ARRAYBUFFER",
          "607:         return !PHASE_OFF1(Js::TypedArrayVirtualPhase) && IsValidAsmJsBufferLengthAlgo(length, true);",
          "608: #else",
          "609:         return false;",
          "610: #endif",
          "611:     }",
          "613:     void JavascriptArrayBuffer::Finalize(bool isShutdown)",
          "614:     {",
          "624: #if ENABLE_FAST_ARRAYBUFFER",
          "626:         if (buffer && IsValidVirtualBufferLength(this->bufferLength))",
          "627:         {",
          "628:             FreeMemAlloc(buffer);",
          "629:         }",
          "630:         else",
          "631:         {",
          "632:             free(buffer);",
          "633:         }",
          "634: #else",
          "635:         free(buffer);",
          "636: #endif",
          "637:         Recycler* recycler = GetType()->GetLibrary()->GetRecycler();",
          "638:         recycler->ReportExternalMemoryFree(bufferLength);",
          "640:         buffer = nullptr;",
          "641:         bufferLength = 0;",
          "642:     }",
          "644:     void JavascriptArrayBuffer::Dispose(bool isShutdown)",
          "645:     {",
          "647:     }",
          "651:     static void MemCpyZero(__bcount(dstSize) BYTE* dst, size_t dstSize,",
          "652:         __in_bcount(count) const BYTE* src, size_t count)",
          "653:     {",
          "654:         js_memcpy_s(dst, dstSize, src, min(dstSize, count));",
          "655:         if (dstSize > count)",
          "656:         {",
          "657:             ZeroMemory(dst + count, dstSize - count);",
          "658:         }",
          "659:     }",
          "662:     static BYTE* ReallocZero(BYTE* ptr, size_t oldSize, size_t newSize)",
          "663:     {",
          "664:         BYTE* ptrNew = (BYTE*)realloc(ptr, newSize);",
          "665:         if (ptrNew && newSize > oldSize)",
          "666:         {",
          "667:             ZeroMemory(ptrNew + oldSize, newSize - oldSize);",
          "668:         }",
          "669:         return ptrNew;",
          "670:     }",
          "672:     ArrayBuffer * JavascriptArrayBuffer::TransferInternal(uint32 newBufferLength)",
          "673:     {",
          "674:         ArrayBuffer* newArrayBuffer;",
          "675:         Recycler* recycler = this->GetRecycler();",
          "677:         if (this->bufferLength > 0)",
          "678:         {",
          "679:             ReportDifferentialAllocation(newBufferLength);",
          "680:         }",
          "682:         if (newBufferLength == 0 || this->bufferLength == 0)",
          "683:         {",
          "684:             newArrayBuffer = GetLibrary()->CreateArrayBuffer(newBufferLength);",
          "685:             if (newBufferLength > 0 && !newArrayBuffer->GetByteLength())",
          "686:             {",
          "687:                 JavascriptError::ThrowOutOfMemoryError(GetScriptContext());",
          "688:             }",
          "689:         }",
          "690:         else",
          "691:         {",
          "692:             BYTE * newBuffer = nullptr;",
          "693:             if (IsValidVirtualBufferLength(this->bufferLength))",
          "694:             {",
          "695:                 if (IsValidVirtualBufferLength(newBufferLength))",
          "696:                 {",
          "698:                     if (newBufferLength < this->bufferLength)",
          "699:                     {",
          "700: #pragma prefast(suppress:6250, \"Calling 'VirtualFree' without the MEM_RELEASE flag might free memory but not address descriptors (VADs).\")",
          "701:                         VirtualFree(this->buffer + newBufferLength, this->bufferLength - newBufferLength, MEM_DECOMMIT);",
          "702:                     }",
          "703:                     else if (newBufferLength > this->bufferLength)",
          "704:                     {",
          "705:                         LPVOID newMem = VirtualAlloc(this->buffer + this->bufferLength, newBufferLength - this->bufferLength, MEM_COMMIT, PAGE_READWRITE);",
          "706:                         if (!newMem)",
          "707:                         {",
          "708:                             recycler->ReportExternalMemoryFailure(newBufferLength - this->bufferLength);",
          "709:                             JavascriptError::ThrowOutOfMemoryError(GetScriptContext());",
          "710:                         }",
          "711:                     }",
          "712:                     newBuffer = this->buffer;",
          "713:                 }",
          "714:                 else",
          "715:                 {",
          "717:                     newBuffer = (BYTE*)malloc(newBufferLength);",
          "718:                     if (!newBuffer)",
          "719:                     {",
          "720:                         recycler->ReportExternalMemoryFailure(newBufferLength - this->bufferLength);",
          "721:                         JavascriptError::ThrowOutOfMemoryError(GetScriptContext());",
          "722:                     }",
          "723:                     MemCpyZero(newBuffer, newBufferLength, this->buffer, this->bufferLength);",
          "724:                 }",
          "725:             }",
          "726:             else",
          "727:             {",
          "728:                 if (IsValidVirtualBufferLength(newBufferLength))",
          "729:                 {",
          "731:                     newBuffer = (BYTE*)AsmJsVirtualAllocator(newBufferLength);",
          "732:                     if (!newBuffer)",
          "733:                     {",
          "734:                         recycler->ReportExternalMemoryFailure(newBufferLength - this->bufferLength);",
          "735:                         JavascriptError::ThrowOutOfMemoryError(GetScriptContext());",
          "736:                     }",
          "737:                     MemCpyZero(newBuffer, newBufferLength, this->buffer, this->bufferLength);",
          "738:                 }",
          "739:                 else if (newBufferLength != this->bufferLength)",
          "740:                 {",
          "742:                     newBuffer = ReallocZero(this->buffer, this->bufferLength, newBufferLength);",
          "743:                     if (!newBuffer)",
          "744:                     {",
          "745:                         recycler->ReportExternalMemoryFailure(newBufferLength - this->bufferLength);",
          "746:                         JavascriptError::ThrowOutOfMemoryError(GetScriptContext());",
          "747:                     }",
          "748:                 }",
          "749:                 else",
          "750:                 {",
          "751:                     newBuffer = this->buffer;",
          "752:                 }",
          "753:             }",
          "754:             newArrayBuffer = GetLibrary()->CreateArrayBuffer(newBuffer, newBufferLength);",
          "756:         }",
          "757:         AutoDiscardPTR<Js::ArrayBufferDetachedStateBase> state(DetachAndGetState());",
          "758:         state->MarkAsClaimed();",
          "760:         return newArrayBuffer;",
          "761:     }",
          "763:     void JavascriptArrayBuffer::ReportDifferentialAllocation(uint32 newBufferLength)",
          "764:     {",
          "765:         Recycler* recycler = this->GetRecycler();",
          "770:         if (newBufferLength != this->bufferLength)",
          "771:         {",
          "773:             if (newBufferLength > this->bufferLength)",
          "774:             {",
          "775:                 if (!recycler->ReportExternalMemoryAllocation(newBufferLength - this->bufferLength))",
          "776:                 {",
          "777:                     recycler->CollectNow<CollectOnTypedArrayAllocation>();",
          "778:                     if (!recycler->ReportExternalMemoryAllocation(newBufferLength - this->bufferLength))",
          "779:                     {",
          "780:                         JavascriptError::ThrowOutOfMemoryError(GetScriptContext());",
          "781:                     }",
          "782:                 }",
          "783:             }",
          "785:             else",
          "786:             {",
          "787:                 recycler->ReportExternalMemoryFree(this->bufferLength - newBufferLength);",
          "788:             }",
          "789:         }",
          "790:     }",
          "792: #if ENABLE_TTD",
          "793:     TTD::NSSnapObjects::SnapObjectType JavascriptArrayBuffer::GetSnapTag_TTD() const",
          "794:     {",
          "795:         return TTD::NSSnapObjects::SnapObjectType::SnapArrayBufferObject;",
          "796:     }",
          "798:     void JavascriptArrayBuffer::ExtractSnapObjectDataInto(TTD::NSSnapObjects::SnapObject* objData, TTD::SlabAllocator& alloc)",
          "799:     {",
          "800:         TTD::NSSnapObjects::SnapArrayBufferInfo* sabi = alloc.SlabAllocateStruct<TTD::NSSnapObjects::SnapArrayBufferInfo>();",
          "802:         sabi->Length = this->GetByteLength();",
          "803:         if (sabi->Length == 0)",
          "804:         {",
          "805:             sabi->Buff = nullptr;",
          "806:         }",
          "807:         else",
          "808:         {",
          "809:             sabi->Buff = alloc.SlabAllocateArray<byte>(sabi->Length);",
          "810:             memcpy(sabi->Buff, this->GetBuffer(), sabi->Length);",
          "811:         }",
          "813:         TTD::NSSnapObjects::StdExtractSetKindSpecificInfo<TTD::NSSnapObjects::SnapArrayBufferInfo*, TTD::NSSnapObjects::SnapObjectType::SnapArrayBufferObject>(objData, sabi);",
          "814:     }",
          "815: #endif",
          "819:     WebAssemblyArrayBuffer::WebAssemblyArrayBuffer(uint32 length, DynamicType * type) :",
          "820: #ifndef ENABLE_FAST_ARRAYBUFFER",
          "822:         JavascriptArrayBuffer(length, type) {}",
          "823: #else",
          "824:         JavascriptArrayBuffer(length, type, WasmVirtualAllocator)",
          "825:     {",
          "827:         if (buffer == nullptr)",
          "828:         {",
          "830:             Assert(length == 0);",
          "831:             buffer = (BYTE*)WasmVirtualAllocator(0);",
          "832:             if (buffer == nullptr)",
          "833:             {",
          "834:                 JavascriptError::ThrowOutOfMemoryError(GetScriptContext());",
          "835:             }",
          "836:         }",
          "837:     }",
          "838: #endif",
          "840:     WebAssemblyArrayBuffer::WebAssemblyArrayBuffer(byte* buffer, uint32 length, DynamicType * type):",
          "841:         JavascriptArrayBuffer(buffer, length, type)",
          "842:     {",
          "844:     }",
          "846:     WebAssemblyArrayBuffer* WebAssemblyArrayBuffer::Create(byte* buffer, uint32 length, DynamicType * type)",
          "847:     {",
          "848:         Recycler* recycler = type->GetScriptContext()->GetRecycler();",
          "849:         WebAssemblyArrayBuffer* result;",
          "850:         if (buffer)",
          "851:         {",
          "852:             result = RecyclerNewFinalized(recycler, WebAssemblyArrayBuffer, buffer, length, type);",
          "853:         }",
          "854:         else",
          "855:         {",
          "856:             result = RecyclerNewFinalized(recycler, WebAssemblyArrayBuffer, length, type);",
          "857:         }",
          "858:         Assert(result);",
          "859:         recycler->AddExternalMemoryUsage(length);",
          "860:         return result;",
          "861:     }",
          "863:     bool WebAssemblyArrayBuffer::IsValidVirtualBufferLength(uint length)",
          "864:     {",
          "865: #if ENABLE_FAST_ARRAYBUFFER",
          "866:         return true;",
          "867: #else",
          "868:         return false;",
          "869: #endif",
          "870:     }",
          "872:     ArrayBuffer * WebAssemblyArrayBuffer::TransferInternal(uint32 newBufferLength)",
          "873:     {",
          "874: #if ENABLE_FAST_ARRAYBUFFER",
          "875:         ReportDifferentialAllocation(newBufferLength);",
          "876:         Assert(this->buffer);",
          "878:         AssertMsg(newBufferLength > this->bufferLength, \"The only supported scenario in WebAssembly is to grow the memory\");",
          "879:         if (newBufferLength > this->bufferLength)",
          "880:         {",
          "881:             LPVOID newMem = VirtualAlloc(this->buffer + this->bufferLength, newBufferLength - this->bufferLength, MEM_COMMIT, PAGE_READWRITE);",
          "882:             if (!newMem)",
          "883:             {",
          "884:                 Recycler* recycler = this->GetRecycler();",
          "885:                 recycler->ReportExternalMemoryFailure(newBufferLength);",
          "886:                 JavascriptError::ThrowOutOfMemoryError(GetScriptContext());",
          "887:             }",
          "888:         }",
          "889:         ArrayBuffer* newArrayBuffer = GetLibrary()->CreateWebAssemblyArrayBuffer(this->buffer, newBufferLength);",
          "891:         AutoDiscardPTR<Js::ArrayBufferDetachedStateBase> state(DetachAndGetState());",
          "892:         state->MarkAsClaimed();",
          "894:         return newArrayBuffer;",
          "895: #else",
          "896:         return JavascriptArrayBuffer::TransferInternal(newBufferLength);",
          "897: #endif",
          "898:     }",
          "900:     ProjectionArrayBuffer::ProjectionArrayBuffer(uint32 length, DynamicType * type) :",
          "901:         ArrayBuffer(length, type, CoTaskMemAlloc)",
          "902:     {",
          "903:     }",
          "905:     ProjectionArrayBuffer::ProjectionArrayBuffer(byte* buffer, uint32 length, DynamicType * type) :",
          "906:         ArrayBuffer(buffer, length, type)",
          "907:     {",
          "908:     }",
          "910:     ProjectionArrayBuffer* ProjectionArrayBuffer::Create(uint32 length, DynamicType * type)",
          "911:     {",
          "912:         Recycler* recycler = type->GetScriptContext()->GetRecycler();",
          "913:         recycler->AddExternalMemoryUsage(length);",
          "914:         return RecyclerNewFinalized(recycler, ProjectionArrayBuffer, length, type);",
          "915:     }",
          "917:     ProjectionArrayBuffer* ProjectionArrayBuffer::Create(byte* buffer, uint32 length, DynamicType * type)",
          "918:     {",
          "919:         Recycler* recycler = type->GetScriptContext()->GetRecycler();",
          "922:         recycler->AddExternalMemoryUsage(length);",
          "923:         return RecyclerNewFinalized(recycler, ProjectionArrayBuffer, buffer, length, type);",
          "924:     }",
          "926:     void ProjectionArrayBuffer::Dispose(bool isShutdown)",
          "927:     {",
          "928:         CoTaskMemFree(buffer);",
          "929:     }",
          "931:     ArrayBuffer * ProjectionArrayBuffer::TransferInternal(uint32 newBufferLength)",
          "932:     {",
          "933:         ArrayBuffer* newArrayBuffer;",
          "934:         if (newBufferLength == 0 || this->bufferLength == 0)",
          "935:         {",
          "936:             newArrayBuffer = GetLibrary()->CreateProjectionArraybuffer(newBufferLength);",
          "937:         }",
          "938:         else",
          "939:         {",
          "940:             BYTE * newBuffer = (BYTE*)CoTaskMemRealloc(this->buffer, newBufferLength);",
          "941:             if (!newBuffer)",
          "942:             {",
          "943:                 JavascriptError::ThrowOutOfMemoryError(GetScriptContext());",
          "944:             }",
          "945:             newArrayBuffer = GetLibrary()->CreateProjectionArraybuffer(newBuffer, newBufferLength);",
          "946:         }",
          "948:         AutoDiscardPTR<Js::ArrayBufferDetachedStateBase> state(DetachAndGetState());",
          "949:         state->MarkAsClaimed();",
          "951:         return newArrayBuffer;",
          "952:     }",
          "954:     ExternalArrayBuffer::ExternalArrayBuffer(byte *buffer, uint32 length, DynamicType *type)",
          "955:         : ArrayBuffer(buffer, length, type)",
          "956:     {",
          "957:     }",
          "959: #if ENABLE_TTD",
          "960:     TTD::NSSnapObjects::SnapObjectType ExternalArrayBuffer::GetSnapTag_TTD() const",
          "961:     {",
          "963:         return TTD::NSSnapObjects::SnapObjectType::SnapArrayBufferObject;",
          "964:     }",
          "966:     void ExternalArrayBuffer::ExtractSnapObjectDataInto(TTD::NSSnapObjects::SnapObject* objData, TTD::SlabAllocator& alloc)",
          "967:     {",
          "968:         TTD::NSSnapObjects::SnapArrayBufferInfo* sabi = alloc.SlabAllocateStruct<TTD::NSSnapObjects::SnapArrayBufferInfo>();",
          "970:         sabi->Length = this->GetByteLength();",
          "971:         if(sabi->Length == 0)",
          "972:         {",
          "973:             sabi->Buff = nullptr;",
          "974:         }",
          "975:         else",
          "976:         {",
          "977:             sabi->Buff = alloc.SlabAllocateArray<byte>(sabi->Length);",
          "978:             memcpy(sabi->Buff, this->GetBuffer(), sabi->Length);",
          "979:         }",
          "981:         TTD::NSSnapObjects::StdExtractSetKindSpecificInfo<TTD::NSSnapObjects::SnapArrayBufferInfo*, TTD::NSSnapObjects::SnapObjectType::SnapArrayBufferObject>(objData, sabi);",
          "982:     }",
          "983: #endif",
          "984: }",
          "",
          "---------------"
        ],
        "lib/Runtime/Library/ArrayBuffer.h||lib/Runtime/Library/ArrayBuffer.h": [
          "File: lib/Runtime/Library/ArrayBuffer.h -> lib/Runtime/Library/ArrayBuffer.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "8: #pragma once",
          "9: namespace Js",
          "10: {",
          "11:     class ArrayBufferParent;",
          "12:     class ArrayBuffer;",
          "13:     class SharedArrayBuffer;",
          "14:     class ArrayBufferBase : public DynamicObject",
          "15:     {",
          "16:     protected:",
          "17: #if ENABLE_FAST_ARRAYBUFFER",
          "18: #define MAX_ASMJS_ARRAYBUFFER_LENGTH 0x100000000 // 4GB",
          "19: #define MAX_WASM__ARRAYBUFFER_LENGTH 0x200000000 // 8GB",
          "20:         typedef void*(*AllocWrapperType)(size_t);",
          "21: #define AsmJsVirtualAllocator ((AllocWrapperType)Js::ArrayBuffer::AllocWrapper<MAX_ASMJS_ARRAYBUFFER_LENGTH>)",
          "22: #define WasmVirtualAllocator ((AllocWrapperType)Js::ArrayBuffer::AllocWrapper<MAX_WASM__ARRAYBUFFER_LENGTH>)",
          "23:         template<size_t MaxVirtualSize = MAX_ASMJS_ARRAYBUFFER_LENGTH>",
          "24:         static void* __cdecl AllocWrapper(DECLSPEC_GUARD_OVERFLOW size_t length)",
          "25:         {",
          "26:             LPVOID address = VirtualAlloc(nullptr, MaxVirtualSize, MEM_RESERVE, PAGE_NOACCESS);",
          "28:             if (!address)",
          "29:             {",
          "30:                 return nullptr;",
          "31:             }",
          "33:             if (length == 0)",
          "34:             {",
          "35:                 return address;",
          "36:             }",
          "38:             LPVOID arrayAddress = VirtualAlloc(address, length, MEM_COMMIT, PAGE_READWRITE);",
          "39:             if (!arrayAddress)",
          "40:             {",
          "41:                 VirtualFree(address, 0, MEM_RELEASE);",
          "42:                 return nullptr;",
          "43:             }",
          "44:             return arrayAddress;",
          "45:         }",
          "47:         static void FreeMemAlloc(Var ptr)",
          "48:         {",
          "49:             BOOL fSuccess = VirtualFree((LPVOID)ptr, 0, MEM_RELEASE);",
          "50:             Assert(fSuccess);",
          "51:         }",
          "52: #else",
          "53:         static void* __cdecl AllocWrapper(DECLSPEC_GUARD_OVERFLOW size_t length)",
          "54:         {",
          "56:             Js::Throw::FatalInternalError();",
          "57:         }",
          "58: #define AsmJsVirtualAllocator Js::ArrayBuffer::AllocWrapper",
          "59: #define WasmVirtualAllocator Js::ArrayBuffer::AllocWrapper",
          "60: #endif",
          "61:     public:",
          "62:         DEFINE_VTABLE_CTOR_ABSTRACT(ArrayBufferBase, DynamicObject);",
          "64:         virtual void MarshalToScriptContext(Js::ScriptContext * scriptContext) = 0;",
          "66:         ArrayBufferBase(DynamicType *type) : DynamicObject(type), isDetached(false) { }",
          "67:         bool IsDetached() { return isDetached; }",
          "69: #if ENABLE_TTD",
          "70:         virtual void MarshalCrossSite_TTDInflate() = 0;",
          "71: #endif",
          "73:         virtual bool IsArrayBuffer() = 0;",
          "74:         virtual bool IsSharedArrayBuffer() = 0;",
          "75:         virtual ArrayBuffer * GetAsArrayBuffer() = 0;",
          "76:         virtual SharedArrayBuffer * GetAsSharedArrayBuffer() { return nullptr; }",
          "77:         virtual void AddParent(ArrayBufferParent* parent) { }",
          "78:         virtual uint32 GetByteLength() const = 0;",
          "79:         virtual BYTE* GetBuffer() const = 0;",
          "80:         virtual bool IsValidVirtualBufferLength(uint length) { return false; }",
          "82:         static bool Is(Var value);",
          "83:         static ArrayBufferBase* FromVar(Var value);",
          "84:         static int GetIsDetachedOffset() { return offsetof(ArrayBufferBase, isDetached); }",
          "86:     protected:",
          "87:         bool isDetached;",
          "88:     };",
          "90:     class ArrayBuffer : public ArrayBufferBase",
          "91:     {",
          "92:     public:",
          "95:         DEFINE_VTABLE_CTOR_ABSTRACT(ArrayBuffer, ArrayBufferBase);",
          "96:     private:",
          "97:         void ClearParentsLength(ArrayBufferParent* parent);",
          "98:     public:",
          "99:         template <typename FreeFN>",
          "100:         class ArrayBufferDetachedState : public ArrayBufferDetachedStateBase",
          "101:         {",
          "102:         public:",
          "103:             FreeFN* freeFunction;",
          "105:             ArrayBufferDetachedState(BYTE* buffer, uint32 bufferLength, FreeFN* freeFunction, ArrayBufferAllocationType allocationType)",
          "106:                 : ArrayBufferDetachedStateBase(TypeIds_ArrayBuffer, buffer, bufferLength, allocationType),",
          "107:                 freeFunction(freeFunction)",
          "108:             {}",
          "110:             virtual void ClearSelfOnly() override",
          "111:             {",
          "112:                 HeapDelete(this);",
          "113:             }",
          "115:             virtual void DiscardState() override",
          "116:             {",
          "117:                 if (this->buffer != nullptr)",
          "118:                 {",
          "119:                     freeFunction(this->buffer);",
          "120:                     this->buffer = nullptr;",
          "121:                 }",
          "122:                 this->bufferLength = 0;",
          "123:             }",
          "125:             virtual void Discard() override",
          "126:             {",
          "127:                 ClearSelfOnly();",
          "128:             }",
          "129:         };",
          "131:         template <typename Allocator>",
          "132:         ArrayBuffer(DECLSPEC_GUARD_OVERFLOW uint32 length, DynamicType * type, Allocator allocator);",
          "134:         ArrayBuffer(byte* buffer, DECLSPEC_GUARD_OVERFLOW uint32 length, DynamicType * type);",
          "136:         class EntryInfo",
          "137:         {",
          "138:         public:",
          "139:             static FunctionInfo NewInstance;",
          "140:             static FunctionInfo Slice;",
          "141:             static FunctionInfo IsView;",
          "142:             static FunctionInfo GetterByteLength;",
          "143:             static FunctionInfo GetterSymbolSpecies;",
          "144:             static FunctionInfo Transfer;",
          "145:         };",
          "147:         static Var NewInstance(RecyclableObject* function, CallInfo callInfo, ...);",
          "148:         static Var EntrySlice(RecyclableObject* function, CallInfo callInfo, ...);",
          "149:         static Var EntryIsView(RecyclableObject* function, CallInfo callInfo, ...);",
          "150:         static Var EntryGetterByteLength(RecyclableObject* function, CallInfo callInfo, ...);",
          "151:         static Var EntryGetterSymbolSpecies(RecyclableObject* function, CallInfo callInfo, ...);",
          "152:         static Var EntryTransfer(RecyclableObject* function, CallInfo callInfo, ...);",
          "154:         static bool Is(Var aValue);",
          "155:         static ArrayBuffer* NewFromDetachedState(DetachedStateBase* state, JavascriptLibrary *library);",
          "156:         static ArrayBuffer* FromVar(Var aValue);",
          "158:         virtual BOOL GetDiagTypeString(StringBuilder<ArenaAllocator>* stringBuilder, ScriptContext* requestContext) override;",
          "159:         virtual BOOL GetDiagValueString(StringBuilder<ArenaAllocator>* stringBuilder, ScriptContext* requestContext) override;",
          "161:         virtual ArrayBufferDetachedStateBase* DetachAndGetState();",
          "162:         virtual uint32 GetByteLength() const override { return bufferLength; }",
          "163:         virtual BYTE* GetBuffer() const override { return buffer; }",
          "165:         static int GetByteLengthOffset() { return offsetof(ArrayBuffer, bufferLength); }",
          "166:         static int GetBufferOffset() { return offsetof(ArrayBuffer, buffer); }",
          "168:         virtual void AddParent(ArrayBufferParent* parent) override;",
          "169: #if _WIN64",
          "171:         static const uint32 MaxArrayBufferLength = 0x7FFFFFFF;",
          "172: #else",
          "174:         static const uint32 MaxArrayBufferLength = 1 << 30;",
          "175: #endif",
          "176:         static const uint32 ParentsCleanupThreshold = 1000;",
          "178:         virtual bool IsValidAsmJsBufferLength(uint length, bool forceCheck = false) { return false; }",
          "179:         virtual bool IsArrayBuffer() override { return true; }",
          "180:         virtual bool IsSharedArrayBuffer() override { return false; }",
          "181:         virtual ArrayBuffer * GetAsArrayBuffer() override { return ArrayBuffer::FromVar(this); }",
          "183:         static uint32 ToIndex(Var value, int32 errorCode, ScriptContext *scriptContext, uint32 MaxAllowedLength, bool checkSameValueZero = true);",
          "185:         virtual ArrayBuffer * TransferInternal(DECLSPEC_GUARD_OVERFLOW uint32 newBufferLength) = 0;",
          "186:     protected:",
          "188:         typedef void __cdecl FreeFn(void* ptr);",
          "189:         virtual ArrayBufferDetachedStateBase* CreateDetachedState(BYTE* buffer, DECLSPEC_GUARD_OVERFLOW uint32 bufferLength) = 0;",
          "191:         static uint32 GetIndexFromVar(Js::Var arg, uint32 length, ScriptContext* scriptContext);",
          "194:         Field(RecyclerWeakReference<ArrayBufferParent>*) primaryParent;",
          "196:         struct OtherParents :public SList<RecyclerWeakReference<ArrayBufferParent>*, Recycler>",
          "197:         {",
          "198:             OtherParents(Recycler* recycler)",
          "199:                 :SList<RecyclerWeakReference<ArrayBufferParent>*, Recycler>(recycler), increasedCount(0)",
          "200:             {",
          "201:             }",
          "202:             Field(uint) increasedCount;",
          "203:         };",
          "205:         Field(OtherParents*) otherParents;",
          "207:         FieldNoBarrier(BYTE*) buffer;             // Points to a heap allocated RGBA buffer, can be null",
          "208:         Field(uint32) bufferLength;       // Number of bytes allocated",
          "209:     };",
          "211:     class ArrayBufferParent : public ArrayObject",
          "212:     {",
          "213:         friend ArrayBuffer;",
          "214:         friend ArrayBufferBase;",
          "216:     private:",
          "217:         Field(ArrayBufferBase*) arrayBuffer;",
          "219:     protected:",
          "220:         DEFINE_VTABLE_CTOR_ABSTRACT(ArrayBufferParent, ArrayObject);",
          "222:         ArrayBufferParent(DynamicType * type, uint32 length, ArrayBufferBase* arrayBuffer)",
          "223:             : ArrayObject(type, /*initSlots*/true, length),",
          "224:             arrayBuffer(arrayBuffer)",
          "225:         {",
          "226:             arrayBuffer->AddParent(this);",
          "227:         }",
          "229:     public:",
          "230:         ArrayBufferBase* GetArrayBuffer() const",
          "231:         {",
          "232:             return this->arrayBuffer;",
          "233:         }",
          "235: #if ENABLE_TTD",
          "236:     public:",
          "237:         virtual void MarkVisitKindSpecificPtrs(TTD::SnapshotExtractor* extractor) override;",
          "239:         virtual void ProcessCorePaths() override;",
          "240: #endif",
          "241:     };",
          "244:     class JavascriptArrayBuffer : public ArrayBuffer",
          "245:     {",
          "246:     protected:",
          "247:         DEFINE_VTABLE_CTOR(JavascriptArrayBuffer, ArrayBuffer);",
          "248:         DEFINE_MARSHAL_OBJECT_TO_SCRIPT_CONTEXT(JavascriptArrayBuffer);",
          "250:     public:",
          "251:         static JavascriptArrayBuffer* Create(DECLSPEC_GUARD_OVERFLOW uint32 length, DynamicType * type);",
          "252:         static JavascriptArrayBuffer* Create(byte* buffer, DECLSPEC_GUARD_OVERFLOW uint32 length, DynamicType * type);",
          "253:         virtual void Dispose(bool isShutdown) override;",
          "254:         virtual void Finalize(bool isShutdown) override;",
          "256:         static bool IsValidAsmJsBufferLengthAlgo(uint length, bool forceCheck);",
          "257:         virtual bool IsValidAsmJsBufferLength(uint length, bool forceCheck = false) override;",
          "258:         virtual bool IsValidVirtualBufferLength(uint length) override;",
          "260:         virtual ArrayBuffer * TransferInternal(DECLSPEC_GUARD_OVERFLOW uint32 newBufferLength) override;",
          "262:         void ReportDifferentialAllocation(uint32 newBufferLength);",
          "264:     protected:",
          "265:         JavascriptArrayBuffer(DynamicType * type);",
          "266:         virtual ArrayBufferDetachedStateBase* CreateDetachedState(BYTE* buffer, DECLSPEC_GUARD_OVERFLOW uint32 bufferLength) override;",
          "268:         template<typename Allocator>",
          "269:         JavascriptArrayBuffer(uint32 length, DynamicType * type, Allocator allocator): ArrayBuffer(length, type, allocator){}",
          "270:         JavascriptArrayBuffer(uint32 length, DynamicType * type);",
          "271:         JavascriptArrayBuffer(byte* buffer, uint32 length, DynamicType * type);",
          "273: #if ENABLE_TTD",
          "274:     public:",
          "275:         virtual TTD::NSSnapObjects::SnapObjectType GetSnapTag_TTD() const override;",
          "276:         virtual void ExtractSnapObjectDataInto(TTD::NSSnapObjects::SnapObject* objData, TTD::SlabAllocator& alloc) override;",
          "277: #endif",
          "278:     };",
          "280:     class WebAssemblyArrayBuffer : public JavascriptArrayBuffer",
          "281:     {",
          "282:         WebAssemblyArrayBuffer(uint32 length, DynamicType * type);",
          "283:         WebAssemblyArrayBuffer(byte* buffer, uint32 length, DynamicType * type);",
          "284:     protected:",
          "285:         DEFINE_VTABLE_CTOR(WebAssemblyArrayBuffer, JavascriptArrayBuffer);",
          "286:         DEFINE_MARSHAL_OBJECT_TO_SCRIPT_CONTEXT(WebAssemblyArrayBuffer);",
          "287:     public:",
          "288:         static WebAssemblyArrayBuffer* Create(byte* buffer, DECLSPEC_GUARD_OVERFLOW uint32 length, DynamicType * type);",
          "289:         virtual bool IsValidVirtualBufferLength(uint length) override;",
          "290:         virtual ArrayBuffer * TransferInternal(DECLSPEC_GUARD_OVERFLOW uint32 newBufferLength) override;",
          "291:     };",
          "294:     class ProjectionArrayBuffer : public ArrayBuffer",
          "295:     {",
          "296:     protected:",
          "297:         DEFINE_VTABLE_CTOR(ProjectionArrayBuffer, ArrayBuffer);",
          "298:         DEFINE_MARSHAL_OBJECT_TO_SCRIPT_CONTEXT(ProjectionArrayBuffer);",
          "300:         typedef void __stdcall FreeFn(LPVOID ptr);",
          "301:         virtual ArrayBufferDetachedStateBase* CreateDetachedState(BYTE* buffer, DECLSPEC_GUARD_OVERFLOW uint32 bufferLength) override",
          "302:         {",
          "303:             return HeapNew(ArrayBufferDetachedState<FreeFn>, buffer, bufferLength, CoTaskMemFree, ArrayBufferAllocationType::CoTask);",
          "304:         }",
          "306:     public:",
          "308:         static ProjectionArrayBuffer* Create(DECLSPEC_GUARD_OVERFLOW uint32 length, DynamicType * type);",
          "310:         static ProjectionArrayBuffer* Create(byte* buffer, DECLSPEC_GUARD_OVERFLOW uint32 length, DynamicType * type);",
          "311:         virtual void Dispose(bool isShutdown) override;",
          "312:         virtual void Finalize(bool isShutdown) override {};",
          "313:         virtual ArrayBuffer * TransferInternal(DECLSPEC_GUARD_OVERFLOW uint32 newBufferLength) override;",
          "314:     private:",
          "315:         ProjectionArrayBuffer(uint32 length, DynamicType * type);",
          "316:         ProjectionArrayBuffer(byte* buffer, uint32 length, DynamicType * type);",
          "317:     };",
          "320:     class ExternalArrayBuffer : public ArrayBuffer",
          "321:     {",
          "322:     protected:",
          "323:         DEFINE_VTABLE_CTOR(ExternalArrayBuffer, ArrayBuffer);",
          "324:         DEFINE_MARSHAL_OBJECT_TO_SCRIPT_CONTEXT(ExternalArrayBuffer);",
          "325:     public:",
          "326:         ExternalArrayBuffer(byte *buffer, DECLSPEC_GUARD_OVERFLOW uint32 length, DynamicType *type);",
          "327:         virtual ArrayBuffer * TransferInternal(DECLSPEC_GUARD_OVERFLOW uint32 newBufferLength) override { Assert(UNREACHED); Throw::InternalError(); };",
          "328:     protected:",
          "329:         virtual ArrayBufferDetachedStateBase* CreateDetachedState(BYTE* buffer, DECLSPEC_GUARD_OVERFLOW uint32 bufferLength) override { Assert(UNREACHED); Throw::InternalError(); };",
          "331: #if ENABLE_TTD",
          "332:     public:",
          "333:         virtual TTD::NSSnapObjects::SnapObjectType GetSnapTag_TTD() const override;",
          "334:         virtual void ExtractSnapObjectDataInto(TTD::NSSnapObjects::SnapObject* objData, TTD::SlabAllocator& alloc) override;",
          "335: #endif",
          "336:     };",
          "337: }",
          "",
          "[Added Lines]",
          "8: #pragma once",
          "9: namespace Js",
          "10: {",
          "11:     class ArrayBufferParent;",
          "12:     class ArrayBuffer;",
          "13:     class SharedArrayBuffer;",
          "14:     class ArrayBufferBase : public DynamicObject",
          "15:     {",
          "16:     protected:",
          "17: #if ENABLE_FAST_ARRAYBUFFER",
          "18: #define MAX_ASMJS_ARRAYBUFFER_LENGTH 0x100000000 // 4GB",
          "19: #define MAX_WASM__ARRAYBUFFER_LENGTH 0x200000000 // 8GB",
          "20:         typedef void*(*AllocWrapperType)(size_t);",
          "21: #define AsmJsVirtualAllocator ((AllocWrapperType)Js::ArrayBuffer::AllocWrapper<MAX_ASMJS_ARRAYBUFFER_LENGTH>)",
          "22: #define WasmVirtualAllocator ((AllocWrapperType)Js::ArrayBuffer::AllocWrapper<MAX_WASM__ARRAYBUFFER_LENGTH>)",
          "23:         template<size_t MaxVirtualSize = MAX_ASMJS_ARRAYBUFFER_LENGTH>",
          "24:         static void* __cdecl AllocWrapper(DECLSPEC_GUARD_OVERFLOW size_t length)",
          "25:         {",
          "26:             LPVOID address = VirtualAlloc(nullptr, MaxVirtualSize, MEM_RESERVE, PAGE_NOACCESS);",
          "28:             if (!address)",
          "29:             {",
          "30:                 return nullptr;",
          "31:             }",
          "33:             if (length == 0)",
          "34:             {",
          "35:                 return address;",
          "36:             }",
          "38:             LPVOID arrayAddress = VirtualAlloc(address, length, MEM_COMMIT, PAGE_READWRITE);",
          "39:             if (!arrayAddress)",
          "40:             {",
          "41:                 VirtualFree(address, 0, MEM_RELEASE);",
          "42:                 return nullptr;",
          "43:             }",
          "44:             return arrayAddress;",
          "45:         }",
          "47:         static void FreeMemAlloc(Var ptr)",
          "48:         {",
          "49:             BOOL fSuccess = VirtualFree((LPVOID)ptr, 0, MEM_RELEASE);",
          "50:             Assert(fSuccess);",
          "51:         }",
          "52: #else",
          "53:         static void* __cdecl AllocWrapper(DECLSPEC_GUARD_OVERFLOW size_t length)",
          "54:         {",
          "56:             Js::Throw::FatalInternalError();",
          "57:         }",
          "58: #define AsmJsVirtualAllocator Js::ArrayBuffer::AllocWrapper",
          "59: #define WasmVirtualAllocator Js::ArrayBuffer::AllocWrapper",
          "60: #endif",
          "61:     public:",
          "62:         DEFINE_VTABLE_CTOR_ABSTRACT(ArrayBufferBase, DynamicObject);",
          "64:         virtual void MarshalToScriptContext(Js::ScriptContext * scriptContext) = 0;",
          "66:         ArrayBufferBase(DynamicType *type) : DynamicObject(type), isDetached(false) { }",
          "67:         bool IsDetached() { return isDetached; }",
          "69: #if ENABLE_TTD",
          "70:         virtual void MarshalCrossSite_TTDInflate() = 0;",
          "71: #endif",
          "73:         virtual bool IsArrayBuffer() = 0;",
          "74:         virtual bool IsSharedArrayBuffer() = 0;",
          "75:         virtual ArrayBuffer * GetAsArrayBuffer() = 0;",
          "76:         virtual SharedArrayBuffer * GetAsSharedArrayBuffer() { return nullptr; }",
          "77:         virtual void AddParent(ArrayBufferParent* parent) { }",
          "78:         virtual uint32 GetByteLength() const = 0;",
          "79:         virtual BYTE* GetBuffer() const = 0;",
          "80:         virtual bool IsValidVirtualBufferLength(uint length) { return false; }",
          "82:         static bool Is(Var value);",
          "83:         static ArrayBufferBase* FromVar(Var value);",
          "84:         static int GetIsDetachedOffset() { return offsetof(ArrayBufferBase, isDetached); }",
          "86:     protected:",
          "87:         bool isDetached;",
          "88:     };",
          "90:     class ArrayBuffer : public ArrayBufferBase",
          "91:     {",
          "92:     public:",
          "95:         DEFINE_VTABLE_CTOR_ABSTRACT(ArrayBuffer, ArrayBufferBase);",
          "96:     private:",
          "97:         void ClearParentsLength(ArrayBufferParent* parent);",
          "98:     public:",
          "99:         template <typename FreeFN>",
          "100:         class ArrayBufferDetachedState : public ArrayBufferDetachedStateBase",
          "101:         {",
          "102:         public:",
          "103:             FreeFN* freeFunction;",
          "105:             ArrayBufferDetachedState(BYTE* buffer, uint32 bufferLength, FreeFN* freeFunction, ArrayBufferAllocationType allocationType)",
          "106:                 : ArrayBufferDetachedStateBase(TypeIds_ArrayBuffer, buffer, bufferLength, allocationType),",
          "107:                 freeFunction(freeFunction)",
          "108:             {}",
          "110:             virtual void ClearSelfOnly() override",
          "111:             {",
          "112:                 HeapDelete(this);",
          "113:             }",
          "115:             virtual void DiscardState() override",
          "116:             {",
          "117:                 if (this->buffer != nullptr)",
          "118:                 {",
          "119:                     freeFunction(this->buffer);",
          "120:                     this->buffer = nullptr;",
          "121:                 }",
          "122:                 this->bufferLength = 0;",
          "123:             }",
          "125:             virtual void Discard() override",
          "126:             {",
          "127:                 ClearSelfOnly();",
          "128:             }",
          "129:         };",
          "131:         template <typename Allocator>",
          "132:         ArrayBuffer(DECLSPEC_GUARD_OVERFLOW uint32 length, DynamicType * type, Allocator allocator);",
          "134:         ArrayBuffer(byte* buffer, DECLSPEC_GUARD_OVERFLOW uint32 length, DynamicType * type);",
          "136:         class EntryInfo",
          "137:         {",
          "138:         public:",
          "139:             static FunctionInfo NewInstance;",
          "140:             static FunctionInfo Slice;",
          "141:             static FunctionInfo IsView;",
          "142:             static FunctionInfo GetterByteLength;",
          "143:             static FunctionInfo GetterSymbolSpecies;",
          "144:             static FunctionInfo Transfer;",
          "145:         };",
          "147:         static Var NewInstance(RecyclableObject* function, CallInfo callInfo, ...);",
          "148:         static Var EntrySlice(RecyclableObject* function, CallInfo callInfo, ...);",
          "149:         static Var EntryIsView(RecyclableObject* function, CallInfo callInfo, ...);",
          "150:         static Var EntryGetterByteLength(RecyclableObject* function, CallInfo callInfo, ...);",
          "151:         static Var EntryGetterSymbolSpecies(RecyclableObject* function, CallInfo callInfo, ...);",
          "152:         static Var EntryTransfer(RecyclableObject* function, CallInfo callInfo, ...);",
          "154:         static bool Is(Var aValue);",
          "155:         static ArrayBuffer* NewFromDetachedState(DetachedStateBase* state, JavascriptLibrary *library);",
          "156:         static ArrayBuffer* FromVar(Var aValue);",
          "158:         virtual BOOL GetDiagTypeString(StringBuilder<ArenaAllocator>* stringBuilder, ScriptContext* requestContext) override;",
          "159:         virtual BOOL GetDiagValueString(StringBuilder<ArenaAllocator>* stringBuilder, ScriptContext* requestContext) override;",
          "161:         virtual ArrayBufferDetachedStateBase* DetachAndGetState();",
          "162:         virtual uint32 GetByteLength() const override { return bufferLength; }",
          "163:         virtual BYTE* GetBuffer() const override { return buffer; }",
          "165:         static int GetByteLengthOffset() { return offsetof(ArrayBuffer, bufferLength); }",
          "166:         static int GetBufferOffset() { return offsetof(ArrayBuffer, buffer); }",
          "168:         virtual void AddParent(ArrayBufferParent* parent) override;",
          "169: #if _WIN64",
          "171:         static const uint32 MaxArrayBufferLength = 0x7FFFFFFF;",
          "172: #else",
          "174:         static const uint32 MaxArrayBufferLength = 1 << 30;",
          "175: #endif",
          "176:         static const uint32 ParentsCleanupThreshold = 1000;",
          "178:         virtual bool IsValidAsmJsBufferLength(uint length, bool forceCheck = false) { return false; }",
          "179:         virtual bool IsArrayBuffer() override { return true; }",
          "180:         virtual bool IsSharedArrayBuffer() override { return false; }",
          "181:         virtual ArrayBuffer * GetAsArrayBuffer() override { return ArrayBuffer::FromVar(this); }",
          "183:         static uint32 ToIndex(Var value, int32 errorCode, ScriptContext *scriptContext, uint32 MaxAllowedLength, bool checkSameValueZero = true);",
          "185:         virtual ArrayBuffer * TransferInternal(DECLSPEC_GUARD_OVERFLOW uint32 newBufferLength) = 0;",
          "186:     protected:",
          "188:         typedef void __cdecl FreeFn(void* ptr);",
          "189:         virtual ArrayBufferDetachedStateBase* CreateDetachedState(BYTE* buffer, DECLSPEC_GUARD_OVERFLOW uint32 bufferLength) = 0;",
          "191:         static uint32 GetIndexFromVar(Js::Var arg, uint32 length, ScriptContext* scriptContext);",
          "194:         Field(RecyclerWeakReference<ArrayBufferParent>*) primaryParent;",
          "196:         struct OtherParents :public SList<RecyclerWeakReference<ArrayBufferParent>*, Recycler>",
          "197:         {",
          "198:             OtherParents(Recycler* recycler)",
          "199:                 :SList<RecyclerWeakReference<ArrayBufferParent>*, Recycler>(recycler), increasedCount(0)",
          "200:             {",
          "201:             }",
          "202:             Field(uint) increasedCount;",
          "203:         };",
          "205:         Field(OtherParents*) otherParents;",
          "207:         FieldNoBarrier(BYTE*) buffer;             // Points to a heap allocated RGBA buffer, can be null",
          "208:         Field(uint32) bufferLength;       // Number of bytes allocated",
          "209:     };",
          "211:     class ArrayBufferParent : public ArrayObject",
          "212:     {",
          "213:         friend ArrayBuffer;",
          "214:         friend ArrayBufferBase;",
          "216:     private:",
          "217:         Field(ArrayBufferBase*) arrayBuffer;",
          "219:     protected:",
          "220:         DEFINE_VTABLE_CTOR_ABSTRACT(ArrayBufferParent, ArrayObject);",
          "222:         ArrayBufferParent(DynamicType * type, uint32 length, ArrayBufferBase* arrayBuffer)",
          "223:             : ArrayObject(type, /*initSlots*/true, length),",
          "224:             arrayBuffer(arrayBuffer)",
          "225:         {",
          "226:             arrayBuffer->AddParent(this);",
          "227:         }",
          "229:     public:",
          "230:         ArrayBufferBase* GetArrayBuffer() const",
          "231:         {",
          "232:             return this->arrayBuffer;",
          "233:         }",
          "235: #if ENABLE_TTD",
          "236:     public:",
          "237:         virtual void MarkVisitKindSpecificPtrs(TTD::SnapshotExtractor* extractor) override;",
          "239:         virtual void ProcessCorePaths() override;",
          "240: #endif",
          "241:     };",
          "244:     class JavascriptArrayBuffer : public ArrayBuffer",
          "245:     {",
          "246:     protected:",
          "247:         DEFINE_VTABLE_CTOR(JavascriptArrayBuffer, ArrayBuffer);",
          "248:         DEFINE_MARSHAL_OBJECT_TO_SCRIPT_CONTEXT(JavascriptArrayBuffer);",
          "250:     public:",
          "251:         static JavascriptArrayBuffer* Create(DECLSPEC_GUARD_OVERFLOW uint32 length, DynamicType * type);",
          "252:         static JavascriptArrayBuffer* Create(byte* buffer, DECLSPEC_GUARD_OVERFLOW uint32 length, DynamicType * type);",
          "253:         virtual void Dispose(bool isShutdown) override;",
          "254:         virtual void Finalize(bool isShutdown) override;",
          "256:         static bool IsValidAsmJsBufferLengthAlgo(uint length, bool forceCheck);",
          "257:         virtual bool IsValidAsmJsBufferLength(uint length, bool forceCheck = false) override;",
          "258:         virtual bool IsValidVirtualBufferLength(uint length) override;",
          "260:         virtual ArrayBuffer * TransferInternal(DECLSPEC_GUARD_OVERFLOW uint32 newBufferLength) override;",
          "262:         void ReportDifferentialAllocation(uint32 newBufferLength);",
          "264:     protected:",
          "265:         JavascriptArrayBuffer(DynamicType * type);",
          "266:         virtual ArrayBufferDetachedStateBase* CreateDetachedState(BYTE* buffer, DECLSPEC_GUARD_OVERFLOW uint32 bufferLength) override;",
          "268:         template<typename Allocator>",
          "269:         JavascriptArrayBuffer(uint32 length, DynamicType * type, Allocator allocator): ArrayBuffer(length, type, allocator){}",
          "270:         JavascriptArrayBuffer(uint32 length, DynamicType * type);",
          "271:         JavascriptArrayBuffer(byte* buffer, uint32 length, DynamicType * type);",
          "273: #if ENABLE_TTD",
          "274:     public:",
          "275:         virtual TTD::NSSnapObjects::SnapObjectType GetSnapTag_TTD() const override;",
          "276:         virtual void ExtractSnapObjectDataInto(TTD::NSSnapObjects::SnapObject* objData, TTD::SlabAllocator& alloc) override;",
          "277: #endif",
          "278:     };",
          "280:     class WebAssemblyArrayBuffer : public JavascriptArrayBuffer",
          "281:     {",
          "282:         WebAssemblyArrayBuffer(uint32 length, DynamicType * type);",
          "283:         WebAssemblyArrayBuffer(byte* buffer, uint32 length, DynamicType * type);",
          "284:     protected:",
          "285:         DEFINE_VTABLE_CTOR(WebAssemblyArrayBuffer, JavascriptArrayBuffer);",
          "286:         DEFINE_MARSHAL_OBJECT_TO_SCRIPT_CONTEXT(WebAssemblyArrayBuffer);",
          "287:     public:",
          "288:         static WebAssemblyArrayBuffer* Create(byte* buffer, DECLSPEC_GUARD_OVERFLOW uint32 length, DynamicType * type);",
          "289:         virtual bool IsValidVirtualBufferLength(uint length) override;",
          "290:         virtual ArrayBuffer * TransferInternal(DECLSPEC_GUARD_OVERFLOW uint32 newBufferLength) override;",
          "291:     };",
          "294:     class ProjectionArrayBuffer : public ArrayBuffer",
          "295:     {",
          "296:     protected:",
          "297:         DEFINE_VTABLE_CTOR(ProjectionArrayBuffer, ArrayBuffer);",
          "298:         DEFINE_MARSHAL_OBJECT_TO_SCRIPT_CONTEXT(ProjectionArrayBuffer);",
          "300:         typedef void __stdcall FreeFn(LPVOID ptr);",
          "301:         virtual ArrayBufferDetachedStateBase* CreateDetachedState(BYTE* buffer, DECLSPEC_GUARD_OVERFLOW uint32 bufferLength) override",
          "302:         {",
          "303:             return HeapNew(ArrayBufferDetachedState<FreeFn>, buffer, bufferLength, CoTaskMemFree, ArrayBufferAllocationType::CoTask);",
          "304:         }",
          "306:     public:",
          "308:         static ProjectionArrayBuffer* Create(DECLSPEC_GUARD_OVERFLOW uint32 length, DynamicType * type);",
          "310:         static ProjectionArrayBuffer* Create(byte* buffer, DECLSPEC_GUARD_OVERFLOW uint32 length, DynamicType * type);",
          "311:         virtual void Dispose(bool isShutdown) override;",
          "312:         virtual void Finalize(bool isShutdown) override {};",
          "313:         virtual ArrayBuffer * TransferInternal(DECLSPEC_GUARD_OVERFLOW uint32 newBufferLength) override;",
          "314:     private:",
          "315:         ProjectionArrayBuffer(uint32 length, DynamicType * type);",
          "316:         ProjectionArrayBuffer(byte* buffer, uint32 length, DynamicType * type);",
          "317:     };",
          "320:     class ExternalArrayBuffer : public ArrayBuffer",
          "321:     {",
          "322:     protected:",
          "323:         DEFINE_VTABLE_CTOR(ExternalArrayBuffer, ArrayBuffer);",
          "324:         DEFINE_MARSHAL_OBJECT_TO_SCRIPT_CONTEXT(ExternalArrayBuffer);",
          "325:     public:",
          "326:         ExternalArrayBuffer(byte *buffer, DECLSPEC_GUARD_OVERFLOW uint32 length, DynamicType *type);",
          "327:         virtual ArrayBuffer * TransferInternal(DECLSPEC_GUARD_OVERFLOW uint32 newBufferLength) override { Assert(UNREACHED); Throw::InternalError(); };",
          "328:     protected:",
          "329:         virtual ArrayBufferDetachedStateBase* CreateDetachedState(BYTE* buffer, DECLSPEC_GUARD_OVERFLOW uint32 bufferLength) override { Assert(UNREACHED); Throw::InternalError(); };",
          "331: #if ENABLE_TTD",
          "332:     public:",
          "333:         virtual TTD::NSSnapObjects::SnapObjectType GetSnapTag_TTD() const override;",
          "334:         virtual void ExtractSnapObjectDataInto(TTD::NSSnapObjects::SnapObject* objData, TTD::SlabAllocator& alloc) override;",
          "335: #endif",
          "336:     };",
          "337: }",
          "",
          "---------------"
        ],
        "lib/Runtime/Library/JavascriptArray.cpp||lib/Runtime/Library/JavascriptArray.cpp": [
          "File: lib/Runtime/Library/JavascriptArray.cpp -> lib/Runtime/Library/JavascriptArray.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "6: #include \"RuntimeLibraryPch.h\"",
          "7: #include \"Types/PathTypeHandler.h\"",
          "8: #include \"Types/SpreadArgument.h\"",
          "11: #define AssertAndFailFast(x) if (!(x)) { Assert(x); Js::Throw::FatalInternalError(); }",
          "13: namespace Js",
          "14: {",
          "17:     static const char EmptySegmentData[sizeof(SparseArraySegmentBase)] = {0};",
          "18:     const SparseArraySegmentBase *JavascriptArray::EmptySegment = (SparseArraySegmentBase *)&EmptySegmentData;",
          "24:     uint JavascriptNativeFloatArray::allocationBuckets[][AllocationBucketsInfoSize] =",
          "25:     {",
          "26:         { 3, 0, 0 },    // allocate space for 3 elements for array of length 0,1,2,3",
          "27:         { 5, 0, 0 },    // allocate space for 5 elements for array of length 4,5",
          "28:         { 8, 0, 0 },    // allocate space for 8 elements for array of length 6,7,8",
          "29:     };",
          "30: #if defined(_M_X64_OR_ARM64)",
          "31:     const Var JavascriptArray::MissingItem = (Var)0x8000000280000002;",
          "32:     uint JavascriptNativeIntArray::allocationBuckets[][AllocationBucketsInfoSize] =",
          "33:     {",
          "35:         {2, 0, 0},",
          "36:         {6, 0, 0},",
          "37:         {8, 0, 0},",
          "38:     };",
          "39:     uint JavascriptArray::allocationBuckets[][AllocationBucketsInfoSize] =",
          "40:     {",
          "42:         {4, 0, 0},",
          "43:         {6, 0, 0},",
          "44:         {8, 0, 0},",
          "45:     };",
          "46: #else",
          "47:     const Var JavascriptArray::MissingItem = (Var)0x80000002;",
          "48:     uint JavascriptNativeIntArray::allocationBuckets[][AllocationBucketsInfoSize] =",
          "49:     {",
          "51:         { 3, 0, 0 },",
          "52:         { 7, 0, 0 },",
          "53:         { 8, 0, 0 },",
          "54:     };",
          "55:     uint JavascriptArray::allocationBuckets[][AllocationBucketsInfoSize] =",
          "56:     {",
          "58:         { 4, 0, 0 },",
          "59:         { 8, 0, 0 },",
          "60:     };",
          "61: #endif",
          "63:     const int32 JavascriptNativeIntArray::MissingItem = 0x80000002;",
          "64:     static const uint64 FloatMissingItemPattern = 0x8000000280000002ull;",
          "65:     const double JavascriptNativeFloatArray::MissingItem = *(double*)&FloatMissingItemPattern;",
          "68:     const size_t JavascriptArray::StackAllocationSize = DetermineAllocationSize<JavascriptArray, 4>(16);",
          "69:     const size_t JavascriptNativeIntArray::StackAllocationSize = DetermineAllocationSize<JavascriptNativeIntArray, 4>(16);",
          "70:     const size_t JavascriptNativeFloatArray::StackAllocationSize = DetermineAllocationSize<JavascriptNativeFloatArray, 4>(16);",
          "72:     SegmentBTree::SegmentBTree()",
          "73:         : segmentCount(0),",
          "74:           segments(nullptr),",
          "75:           keys(nullptr),",
          "76:           children(nullptr)",
          "77:     {",
          "78:     }",
          "80:     uint32 SegmentBTree::GetLazyCrossOverLimit()",
          "81:     {",
          "82: #ifdef ENABLE_DEBUG_CONFIG_OPTIONS",
          "83:         if (Js::Configuration::Global.flags.DisableArrayBTree)",
          "84:         {",
          "85:             return Js::JavascriptArray::InvalidIndex;",
          "86:         }",
          "87:         else if (Js::Configuration::Global.flags.ForceArrayBTree)",
          "88:         {",
          "89:             return ARRAY_CROSSOVER_FOR_VALIDATE;",
          "90:         }",
          "91: #endif",
          "92: #ifdef VALIDATE_ARRAY",
          "93:         if (Js::Configuration::Global.flags.ArrayValidate)",
          "94:         {",
          "95:             return ARRAY_CROSSOVER_FOR_VALIDATE;",
          "96:         }",
          "97: #endif",
          "98:         return SegmentBTree::MinDegree * 3;",
          "99:     }",
          "101:     BOOL SegmentBTree::IsLeaf() const",
          "102:     {",
          "103:         return children == NULL;",
          "104:     }",
          "105:     BOOL SegmentBTree::IsFullNode() const",
          "106:     {",
          "107:         return segmentCount == MaxKeys;",
          "108:     }",
          "110:     void SegmentBTree::InternalFind(SegmentBTree* node, uint32 itemIndex, SparseArraySegmentBase*& prev, SparseArraySegmentBase*& matchOrNext)",
          "111:     {",
          "112:         uint32 i = 0;",
          "114:         for(; i < node->segmentCount; i++)",
          "115:         {",
          "116:             Assert(node->keys[i] == node->segments[i]->left);",
          "117:             if (itemIndex <  node->keys[i])",
          "118:             {",
          "119:                 break;",
          "120:             }",
          "121:         }",
          "127:         bool matches = i > 0 && (itemIndex == node->keys[i-1] || itemIndex < node->keys[i-1] + node->segments[i-1]->length);",
          "129:         if (matches)",
          "130:         {",
          "132:             if (node->IsLeaf())",
          "133:             {",
          "134:                 if (i > 1)",
          "135:                 {",
          "137:                     prev = node->segments[i-2];",
          "138:                 }",
          "139:             }",
          "140:             else",
          "141:             {",
          "143:                 SegmentBTree* child = &node->children[i - 1];",
          "144:                 while (!child->IsLeaf())",
          "145:                 {",
          "146:                     child = &child->children[child->segmentCount];",
          "147:                 }",
          "148:                 prev = child->segments[child->segmentCount - 1];",
          "149:             }",
          "152:             matchOrNext = node->segments[i-1];",
          "153:         }",
          "154:         else // itemIndex in between segment i-1 and i",
          "155:         {",
          "156:             if (i > 0)",
          "157:             {",
          "159:                 prev = node->segments[i-1];",
          "160:             }",
          "162:             if (node->IsLeaf())",
          "163:             {",
          "164:                 matchOrNext = (i == 0 ? node->segments[0] : PointerValue(prev->next));",
          "165:             }",
          "166:             else",
          "167:             {",
          "168:                 InternalFind(node->children + i, itemIndex, prev, matchOrNext);",
          "169:             }",
          "170:         }",
          "171:     }",
          "173:     void SegmentBTreeRoot::Find(uint32 itemIndex, SparseArraySegmentBase*& prev, SparseArraySegmentBase*& matchOrNext)",
          "174:     {",
          "175:         prev = matchOrNext = NULL;",
          "176:         InternalFind(this, itemIndex, prev, matchOrNext);",
          "177:         Assert(prev == NULL || (prev->next == matchOrNext));// If prev exists it is immediately before matchOrNext in the list of arraysegments",
          "178:         Assert(prev == NULL || (prev->left < itemIndex && prev->left + prev->length <= itemIndex)); // prev should never be a match (left is a match if length == 0)",
          "179:         Assert(matchOrNext == NULL || (matchOrNext->left >= itemIndex || matchOrNext->left + matchOrNext->length > itemIndex));",
          "180:     }",
          "182:     void SegmentBTreeRoot::Add(Recycler* recycler, SparseArraySegmentBase* newSeg)",
          "183:     {",
          "185:         if (IsFullNode())",
          "186:         {",
          "187:             SegmentBTree * children = AllocatorNewArrayZ(Recycler, recycler, SegmentBTree, MaxDegree);",
          "188:             children[0] = *this;",
          "192:             this->segmentCount = 0;",
          "193:             this->segments = AllocatorNewArrayLeafZ(Recycler, recycler, SparseArraySegmentBase*, MaxKeys);",
          "194:             this->keys = AllocatorNewArrayLeafZ(Recycler,recycler,uint32,MaxKeys);",
          "195:             this->children = children;",
          "198:             SplitChild(recycler, this, 0, &children[0]);",
          "199:         }",
          "200:         InsertNonFullNode(recycler, this, newSeg);",
          "201:     }",
          "203:     void SegmentBTree::SwapSegment(uint32 originalKey, SparseArraySegmentBase* oldSeg, SparseArraySegmentBase* newSeg)",
          "204:     {",
          "206:         uint32 itemIndex = originalKey;",
          "207:         uint32 i = 0;",
          "209:         for(; i < segmentCount; i++)",
          "210:         {",
          "211:             Assert(keys[i] == segments[i]->left || (oldSeg == newSeg && newSeg == segments[i]));",
          "212:             if (itemIndex <  keys[i])",
          "213:             {",
          "214:                 break;",
          "215:             }",
          "216:         }",
          "220:         if (i > 0)",
          "221:         {",
          "222:             if (oldSeg == segments[i-1])",
          "223:             {",
          "224:                 segments[i-1] = newSeg;",
          "225:                 keys[i-1] = newSeg->left;",
          "226:                 return;",
          "227:             }",
          "228:         }",
          "230:         Assert(!IsLeaf());",
          "231:         children[i].SwapSegment(originalKey, oldSeg, newSeg);",
          "232:     }",
          "235:     void SegmentBTree::SplitChild(Recycler* recycler, SegmentBTree* parent, uint32 iChild, SegmentBTree* child)",
          "236:     {",
          "240:         Assert(child != NULL);",
          "241:         Assert(parent != NULL);",
          "242:         Assert(!parent->IsFullNode());",
          "243:         Assert(child->IsFullNode());",
          "245:         SegmentBTree newNode;",
          "246:         newNode.segmentCount = MinKeys;",
          "250:         newNode.segments = AllocatorNewArrayLeafZ(Recycler, recycler, SparseArraySegmentBase*, MaxKeys);",
          "251:         newNode.keys = AllocatorNewArrayLeafZ(Recycler,recycler,uint32,MaxKeys);",
          "254:         for(uint32 i = 0; i < MinKeys; i++)",
          "255:         {",
          "256:             newNode.segments[i] = child->segments[i+MinDegree];",
          "257:             newNode.keys[i] = child->keys[i+MinDegree];",
          "260:             child->segments[i+MinDegree] = nullptr;",
          "261:         }",
          "264:         if (!child->IsLeaf())",
          "265:         {",
          "266:             newNode.children = AllocatorNewArrayZ(Recycler, recycler, SegmentBTree, MaxDegree);",
          "267:             for(uint32 j = 0; j < MinDegree; j++)",
          "268:             {",
          "269:                 newNode.children[j] = child->children[j+MinDegree];",
          "272:                 child->children[j+MinDegree].segments = nullptr;",
          "273:                 child->children[j+MinDegree].children = nullptr;",
          "274:             }",
          "275:         }",
          "276:         child->segmentCount = MinKeys;",
          "279:         for(uint32 j = parent->segmentCount; j > iChild; j--)",
          "280:         {",
          "281:             parent->children[j+1] = parent->children[j];",
          "282:         }",
          "284:         parent->children[iChild+1] = newNode;",
          "287:         for(uint32 k = parent->segmentCount; k > iChild; k--)",
          "288:         {",
          "289:             parent->segments[k] = parent->segments[k-1];",
          "290:             parent->keys[k] = parent->keys[k-1];",
          "291:         }",
          "294:         parent->segments[iChild] = child->segments[MinKeys];",
          "295:         parent->keys[iChild] = child->keys[MinKeys];",
          "298:         child->segments[MinKeys] = nullptr;",
          "300:         parent->segmentCount++;",
          "301:     }",
          "303:     void SegmentBTree::InsertNonFullNode(Recycler* recycler, SegmentBTree* node, SparseArraySegmentBase* newSeg)",
          "304:     {",
          "305:         Assert(!node->IsFullNode());",
          "306:         AnalysisAssert(node->segmentCount < MaxKeys);       // Same as !node->IsFullNode()",
          "307:         Assert(newSeg != NULL);",
          "309:         if (node->IsLeaf())",
          "310:         {",
          "312:             uint32 i = node->segmentCount - 1;",
          "313:             while( (i != -1) && (newSeg->left < node->keys[i]))",
          "314:             {",
          "315:                 node->segments[i+1] = node->segments[i];",
          "316:                 node->keys[i+1] = node->keys[i];",
          "317:                 i--;",
          "318:             }",
          "319:             if (!node->segments)",
          "320:             {",
          "323:                 node->segments = AllocatorNewArrayLeafZ(Recycler, recycler, SparseArraySegmentBase*, MaxKeys);",
          "324:                 node->keys = AllocatorNewArrayLeafZ(Recycler, recycler, uint32, MaxKeys);",
          "325:             }",
          "326:             node->segments[i + 1] = newSeg;",
          "327:             node->keys[i + 1] = newSeg->left;",
          "328:             node->segmentCount++;",
          "329:         }",
          "330:         else",
          "331:         {",
          "333:             uint32 i = node->segmentCount-1;",
          "335:             while((i != -1) && (newSeg->left < node->keys[i]))",
          "336:             {",
          "337:                 i--;",
          "338:             }",
          "339:             i++;",
          "342:             if(node->children[i].IsFullNode())",
          "343:             {",
          "345:                 SplitChild(recycler, node, i, node->children+i);",
          "346:                 Assert(node->keys[i] == node->segments[i]->left);",
          "347:                 if (newSeg->left > node->keys[i])",
          "348:                 {",
          "349:                     i++;",
          "350:                 }",
          "351:             }",
          "352:             InsertNonFullNode(recycler, node->children+i, newSeg);",
          "353:         }",
          "354:     }",
          "356:     inline void ThrowTypeErrorOnFailureHelper::ThrowTypeErrorOnFailure(BOOL operationSucceeded)",
          "357:     {",
          "358:         if (IsThrowTypeError(operationSucceeded))",
          "359:         {",
          "360:             ThrowTypeErrorOnFailure();",
          "361:         }",
          "362:     }",
          "364:     inline void ThrowTypeErrorOnFailureHelper::ThrowTypeErrorOnFailure()",
          "365:     {",
          "366:         JavascriptError::ThrowTypeError(m_scriptContext, VBSERR_ActionNotSupported, m_functionName);",
          "367:     }",
          "369:     inline BOOL ThrowTypeErrorOnFailureHelper::IsThrowTypeError(BOOL operationSucceeded)",
          "370:     {",
          "371:         return !operationSucceeded;",
          "372:     }",
          "376:     JavascriptArray::JavascriptArray(DynamicType * type)",
          "377:         : ArrayObject(type, false, 0)",
          "378:     {",
          "379:         Assert(type->GetTypeId() == TypeIds_Array || type->GetTypeId() == TypeIds_NativeIntArray || type->GetTypeId() == TypeIds_NativeFloatArray || ((type->GetTypeId() == TypeIds_ES5Array || type->GetTypeId() == TypeIds_Object) && type->GetPrototype() == GetScriptContext()->GetLibrary()->GetArrayPrototype()));",
          "380:         Assert(EmptySegment->length == 0 && EmptySegment->size == 0 && EmptySegment->next == NULL);",
          "381:         InitArrayFlags(DynamicObjectFlags::InitialArrayValue);",
          "382:         SetHeadAndLastUsedSegment(const_cast<SparseArraySegmentBase *>(EmptySegment));",
          "384:     }",
          "386:     JavascriptArray::JavascriptArray(uint32 length, DynamicType * type)",
          "387:         : ArrayObject(type, false, length)",
          "388:     {",
          "389:         Assert(JavascriptArray::Is(type->GetTypeId()));",
          "390:         Assert(EmptySegment->length == 0 && EmptySegment->size == 0 && EmptySegment->next == NULL);",
          "391:         InitArrayFlags(DynamicObjectFlags::InitialArrayValue);",
          "392:         SetHeadAndLastUsedSegment(const_cast<SparseArraySegmentBase *>(EmptySegment));",
          "393:     }",
          "395:     JavascriptArray::JavascriptArray(uint32 length, uint32 size, DynamicType * type)",
          "396:         : ArrayObject(type, false, length)",
          "397:     {",
          "398:         Assert(type->GetTypeId() == TypeIds_Array);",
          "399:         InitArrayFlags(DynamicObjectFlags::InitialArrayValue);",
          "400:         Recycler* recycler = GetRecycler();",
          "401:         SetHeadAndLastUsedSegment(SparseArraySegment<Var>::AllocateSegment(recycler, 0, 0, size, nullptr));",
          "402:     }",
          "404:     JavascriptArray::JavascriptArray(DynamicType * type, uint32 size)",
          "405:         : ArrayObject(type, false)",
          "406:     {",
          "407:         InitArrayFlags(DynamicObjectFlags::InitialArrayValue);",
          "408:         SetHeadAndLastUsedSegment(DetermineInlineHeadSegmentPointer<JavascriptArray, 0, false>(this));",
          "409:         head->size = size;",
          "410:         Var fill = Js::JavascriptArray::MissingItem;",
          "411:         for (uint i = 0; i < size; i++)",
          "412:         {",
          "413:             SparseArraySegment<Var>::From(head)->elements[i] = fill;",
          "414:         }",
          "415:     }",
          "417:     JavascriptNativeIntArray::JavascriptNativeIntArray(uint32 length, uint32 size, DynamicType * type)",
          "418:         : JavascriptNativeArray(type)",
          "419:     {",
          "420:         Assert(type->GetTypeId() == TypeIds_NativeIntArray);",
          "421:         this->length = length;",
          "422:         Recycler* recycler = GetRecycler();",
          "423:         SetHeadAndLastUsedSegment(SparseArraySegment<int32>::AllocateSegment(recycler, 0, 0, size, nullptr));",
          "424:     }",
          "426:     JavascriptNativeIntArray::JavascriptNativeIntArray(DynamicType * type, uint32 size)",
          "427:         : JavascriptNativeArray(type)",
          "428:     {",
          "429:         SetHeadAndLastUsedSegment(DetermineInlineHeadSegmentPointer<JavascriptNativeIntArray, 0, false>(this));",
          "430:         head->size = size;",
          "431:         SparseArraySegment<int32>::From(head)->FillSegmentBuffer(0, size);",
          "432:     }",
          "434:     JavascriptNativeFloatArray::JavascriptNativeFloatArray(uint32 length, uint32 size, DynamicType * type)",
          "435:         : JavascriptNativeArray(type)",
          "436:     {",
          "437:         Assert(type->GetTypeId() == TypeIds_NativeFloatArray);",
          "438:         this->length = length;",
          "439:         Recycler* recycler = GetRecycler();",
          "440:         SetHeadAndLastUsedSegment(SparseArraySegment<double>::AllocateSegment(recycler, 0, 0, size, nullptr));",
          "441:     }",
          "443:     JavascriptNativeFloatArray::JavascriptNativeFloatArray(DynamicType * type, uint32 size)",
          "444:         : JavascriptNativeArray(type)",
          "445:     {",
          "446:         SetHeadAndLastUsedSegment(DetermineInlineHeadSegmentPointer<JavascriptNativeFloatArray, 0, false>(this));",
          "447:         head->size = size;",
          "448:         SparseArraySegment<double>::From(head)->FillSegmentBuffer(0, size);",
          "449:     }",
          "451:     bool JavascriptArray::Is(Var aValue)",
          "452:     {",
          "453:         TypeId typeId = JavascriptOperators::GetTypeId(aValue);",
          "454:         return JavascriptArray::Is(typeId);",
          "455:     }",
          "457:     bool JavascriptArray::Is(TypeId typeId)",
          "458:     {",
          "459:         return typeId >= TypeIds_ArrayFirst && typeId <= TypeIds_ArrayLast;",
          "460:     }",
          "462:     bool JavascriptArray::IsVarArray(Var aValue)",
          "463:     {",
          "464:         TypeId typeId = JavascriptOperators::GetTypeId(aValue);",
          "465:         return JavascriptArray::IsVarArray(typeId);",
          "466:     }",
          "468:     bool JavascriptArray::IsVarArray(TypeId typeId)",
          "469:     {",
          "470:         return typeId == TypeIds_Array;",
          "471:     }",
          "473:     template<typename T>",
          "474:     bool JavascriptArray::IsMissingItemAt(uint32 index) const",
          "475:     {",
          "476:         SparseArraySegment<T>* headSeg = SparseArraySegment<T>::From(this->head);",
          "478:         return SparseArraySegment<T>::IsMissingItem(&headSeg->elements[index]);",
          "479:     }",
          "481:     bool JavascriptArray::IsMissingItem(uint32 index)",
          "482:     {",
          "483:         if (this->length <= index)",
          "484:         {",
          "485:             return false;",
          "486:         }",
          "488:         bool isIntArray = false, isFloatArray = false;",
          "489:         this->GetArrayTypeAndConvert(&isIntArray, &isFloatArray);",
          "491:         if (isIntArray)",
          "492:         {",
          "493:             return IsMissingItemAt<int32>(index);",
          "494:         }",
          "495:         else if (isFloatArray)",
          "496:         {",
          "497:             return IsMissingItemAt<double>(index);",
          "498:         }",
          "499:         else",
          "500:         {",
          "501:             return IsMissingItemAt<Var>(index);",
          "502:         }",
          "503:     }",
          "505:     JavascriptArray* JavascriptArray::FromVar(Var aValue)",
          "506:     {",
          "507:         AssertMsg(Is(aValue), \"Ensure var is actually a 'JavascriptArray'\");",
          "509:         return static_cast<JavascriptArray *>(RecyclableObject::FromVar(aValue));",
          "510:     }",
          "513:     JavascriptArray* JavascriptArray::FromAnyArray(Var aValue)",
          "514:     {",
          "515:         AssertMsg(Is(aValue) || ES5Array::Is(aValue), \"Ensure var is actually a 'JavascriptArray' or 'ES5Array'\");",
          "517:         return static_cast<JavascriptArray *>(RecyclableObject::FromVar(aValue));",
          "518:     }",
          "521:     bool JavascriptArray::IsDirectAccessArray(Var aValue)",
          "522:     {",
          "523:         return RecyclableObject::Is(aValue) &&",
          "524:             (VirtualTableInfo<JavascriptArray>::HasVirtualTable(aValue) ||",
          "525:                 VirtualTableInfo<JavascriptNativeIntArray>::HasVirtualTable(aValue) ||",
          "526:                 VirtualTableInfo<JavascriptNativeFloatArray>::HasVirtualTable(aValue));",
          "527:     }",
          "529:     DynamicObjectFlags JavascriptArray::GetFlags() const",
          "530:     {",
          "531:         return GetArrayFlags();",
          "532:     }",
          "534:     DynamicObjectFlags JavascriptArray::GetFlags_Unchecked() const // do not use except in extreme circumstances",
          "535:     {",
          "536:         return GetArrayFlags_Unchecked();",
          "537:     }",
          "539:     void JavascriptArray::SetFlags(const DynamicObjectFlags flags)",
          "540:     {",
          "541:         SetArrayFlags(flags);",
          "542:     }",
          "544:     DynamicType * JavascriptArray::GetInitialType(ScriptContext * scriptContext)",
          "545:     {",
          "546:         return scriptContext->GetLibrary()->GetArrayType();",
          "547:     }",
          "549:     JavascriptArray *JavascriptArray::GetArrayForArrayOrObjectWithArray(const Var var)",
          "550:     {",
          "551:         bool isObjectWithArray;",
          "552:         TypeId arrayTypeId;",
          "553:         return GetArrayForArrayOrObjectWithArray(var, &isObjectWithArray, &arrayTypeId);",
          "554:     }",
          "556:     JavascriptArray *JavascriptArray::GetArrayForArrayOrObjectWithArray(",
          "557:         const Var var,",
          "558:         bool *const isObjectWithArrayRef,",
          "559:         TypeId *const arrayTypeIdRef)",
          "560:     {",
          "564:         Assert(var);",
          "565:         Assert(isObjectWithArrayRef);",
          "566:         Assert(arrayTypeIdRef);",
          "571:         if(!RecyclableObject::Is(var))",
          "572:         {",
          "573:             return nullptr;",
          "574:         }",
          "576:         JavascriptArray *array = nullptr;",
          "577:         INT_PTR vtable = VirtualTableInfoBase::GetVirtualTable(var);",
          "578:         if(vtable == VirtualTableInfo<DynamicObject>::Address)",
          "579:         {",
          "580:             ArrayObject* objectArray = DynamicObject::FromVar(var)->GetObjectArray();",
          "581:             array = (objectArray && Is(objectArray)) ? FromVar(objectArray) : nullptr;",
          "582:             if(!array)",
          "583:             {",
          "584:                 return nullptr;",
          "585:             }",
          "587:             vtable = VirtualTableInfoBase::GetVirtualTable(array);",
          "588:         }",
          "590:         if(vtable == VirtualTableInfo<JavascriptArray>::Address)",
          "591:         {",
          "593:         }",
          "594:         else if(vtable == VirtualTableInfo<JavascriptNativeIntArray>::Address)",
          "595:         {",
          "597:         }",
          "598:         else if(vtable == VirtualTableInfo<JavascriptNativeFloatArray>::Address)",
          "599:         {",
          "601:         }",
          "602:         else",
          "603:         {",
          "604:             return nullptr;",
          "605:         }",
          "607:         if(!array)",
          "608:         {",
          "609:             array = FromVar(var);",
          "610:         }",
          "611:         return array;",
          "612:     }",
          "614:     const SparseArraySegmentBase *JavascriptArray::Jit_GetArrayHeadSegmentForArrayOrObjectWithArray(const Var var)",
          "615:     {",
          "618:         JavascriptArray *const array = GetArrayForArrayOrObjectWithArray(var);",
          "619:         return array ? array->head : nullptr;",
          "620:     }",
          "622:     uint32 JavascriptArray::Jit_GetArrayHeadSegmentLength(const SparseArraySegmentBase *const headSegment)",
          "623:     {",
          "626:         return headSegment ? headSegment->length : 0;",
          "627:     }",
          "629:     bool JavascriptArray::Jit_OperationInvalidatedArrayHeadSegment(",
          "630:         const SparseArraySegmentBase *const headSegmentBeforeOperation,",
          "631:         const uint32 headSegmentLengthBeforeOperation,",
          "632:         const Var varAfterOperation)",
          "633:     {",
          "636:         Assert(varAfterOperation);",
          "638:         if(!headSegmentBeforeOperation)",
          "639:         {",
          "640:             return false;",
          "641:         }",
          "643:         const SparseArraySegmentBase *const headSegmentAfterOperation =",
          "644:             Jit_GetArrayHeadSegmentForArrayOrObjectWithArray(varAfterOperation);",
          "645:         return",
          "646:             headSegmentAfterOperation != headSegmentBeforeOperation ||",
          "647:             headSegmentAfterOperation->length != headSegmentLengthBeforeOperation;",
          "648:     }",
          "650:     uint32 JavascriptArray::Jit_GetArrayLength(const Var var)",
          "651:     {",
          "654:         bool isObjectWithArray;",
          "655:         TypeId arrayTypeId;",
          "656:         JavascriptArray *const array = GetArrayForArrayOrObjectWithArray(var, &isObjectWithArray, &arrayTypeId);",
          "657:         return array && !isObjectWithArray ? array->GetLength() : 0;",
          "658:     }",
          "660:     bool JavascriptArray::Jit_OperationInvalidatedArrayLength(const uint32 lengthBeforeOperation, const Var varAfterOperation)",
          "661:     {",
          "664:         return Jit_GetArrayLength(varAfterOperation) != lengthBeforeOperation;",
          "665:     }",
          "667:     DynamicObjectFlags JavascriptArray::Jit_GetArrayFlagsForArrayOrObjectWithArray(const Var var)",
          "668:     {",
          "671:         JavascriptArray *const array = GetArrayForArrayOrObjectWithArray(var);",
          "672:         return array && array->UsesObjectArrayOrFlagsAsFlags() ? array->GetFlags() : DynamicObjectFlags::None;",
          "673:     }",
          "675:     bool JavascriptArray::Jit_OperationCreatedFirstMissingValue(",
          "676:         const DynamicObjectFlags flagsBeforeOperation,",
          "677:         const Var varAfterOperation)",
          "678:     {",
          "681:         Assert(varAfterOperation);",
          "683:         return",
          "684:             !!(flagsBeforeOperation & DynamicObjectFlags::HasNoMissingValues) &&",
          "685:             !(Jit_GetArrayFlagsForArrayOrObjectWithArray(varAfterOperation) & DynamicObjectFlags::HasNoMissingValues);",
          "686:     }",
          "688:     bool JavascriptArray::HasNoMissingValues() const",
          "689:     {",
          "690:         return !!(GetFlags() & DynamicObjectFlags::HasNoMissingValues);",
          "691:     }",
          "693:     bool JavascriptArray::HasNoMissingValues_Unchecked() const // do not use except in extreme circumstances",
          "694:     {",
          "695:         return !!(GetFlags_Unchecked() & DynamicObjectFlags::HasNoMissingValues);",
          "696:     }",
          "698:     void JavascriptArray::SetHasNoMissingValues(const bool hasNoMissingValues)",
          "699:     {",
          "700:         SetFlags(",
          "701:             hasNoMissingValues",
          "702:                 ? GetFlags() | DynamicObjectFlags::HasNoMissingValues",
          "703:                 : GetFlags() & ~DynamicObjectFlags::HasNoMissingValues);",
          "704:     }",
          "706:     template<class T>",
          "707:     bool JavascriptArray::IsMissingHeadSegmentItemImpl(const uint32 index) const",
          "708:     {",
          "709:         Assert(index < head->length);",
          "711:         return SparseArraySegment<T>::IsMissingItem(&SparseArraySegment<T>::From(head)->elements[index]);",
          "712:     }",
          "714:     bool JavascriptArray::IsMissingHeadSegmentItem(const uint32 index) const",
          "715:     {",
          "716:         return IsMissingHeadSegmentItemImpl<Var>(index);",
          "717:     }",
          "719: #if ENABLE_COPYONACCESS_ARRAY",
          "720:     void JavascriptCopyOnAccessNativeIntArray::ConvertCopyOnAccessSegment()",
          "721:     {",
          "722:         Assert(this->GetScriptContext()->GetLibrary()->cacheForCopyOnAccessArraySegments->IsValidIndex(::Math::PointerCastToIntegral<uint32>(this->GetHead())));",
          "723:         SparseArraySegment<int32> *seg = this->GetScriptContext()->GetLibrary()->cacheForCopyOnAccessArraySegments->GetSegmentByIndex(::Math::PointerCastToIntegral<byte>(this->GetHead()));",
          "724:         SparseArraySegment<int32> *newSeg = SparseArraySegment<int32>::AllocateLiteralHeadSegment(this->GetRecycler(), seg->length);",
          "726: #if ENABLE_DEBUG_CONFIG_OPTIONS",
          "727:         if (Js::Configuration::Global.flags.TestTrace.IsEnabled(Js::CopyOnAccessArrayPhase))",
          "728:         {",
          "729:             Output::Print(_u(\"Convert copy-on-access array: index(%d) length(%d)\\n\"), this->GetHead(), seg->length);",
          "730:             Output::Flush();",
          "731:         }",
          "732: #endif",
          "734:         newSeg->CopySegment(this->GetRecycler(), newSeg, 0, seg, 0, seg->length);",
          "735:         this->SetHeadAndLastUsedSegment(newSeg);",
          "737:         VirtualTableInfo<JavascriptNativeIntArray>::SetVirtualTable(this);",
          "738:         this->type = JavascriptNativeIntArray::GetInitialType(this->GetScriptContext());",
          "740:         ArrayCallSiteInfo *arrayInfo = this->GetArrayCallSiteInfo();",
          "741:         if (arrayInfo && !arrayInfo->isNotCopyOnAccessArray)",
          "742:         {",
          "743:             arrayInfo->isNotCopyOnAccessArray = 1;",
          "744:         }",
          "745:     }",
          "747:     uint32 JavascriptCopyOnAccessNativeIntArray::GetNextIndex(uint32 index) const",
          "748:     {",
          "749:         if (this->length == 0 || (index != Js::JavascriptArray::InvalidIndex && index >= this->length))",
          "750:         {",
          "751:             return Js::JavascriptArray::InvalidIndex;",
          "752:         }",
          "753:         else if (index == Js::JavascriptArray::InvalidIndex)",
          "754:         {",
          "755:             return 0;",
          "756:         }",
          "757:         else",
          "758:         {",
          "759:             return index + 1;",
          "760:         }",
          "761:     }",
          "763:     BOOL JavascriptCopyOnAccessNativeIntArray::DirectGetItemAt(uint32 index, int* outVal)",
          "764:     {",
          "765:         Assert(this->GetScriptContext()->GetLibrary()->cacheForCopyOnAccessArraySegments->IsValidIndex(::Math::PointerCastToIntegral<uint32>(this->GetHead())));",
          "766:         SparseArraySegment<int32> *seg = this->GetScriptContext()->GetLibrary()->cacheForCopyOnAccessArraySegments->GetSegmentByIndex(::Math::PointerCastToIntegral<byte>(this->GetHead()));",
          "768:         if (this->length == 0 || index == Js::JavascriptArray::InvalidIndex || index >= this->length)",
          "769:         {",
          "770:             return FALSE;",
          "771:         }",
          "772:         else",
          "773:         {",
          "775:             return TRUE;",
          "776:         }",
          "777:     }",
          "778: #endif",
          "780:     bool JavascriptNativeIntArray::IsMissingHeadSegmentItem(const uint32 index) const",
          "781:     {",
          "782:         return IsMissingHeadSegmentItemImpl<int32>(index);",
          "783:     }",
          "785:     bool JavascriptNativeFloatArray::IsMissingHeadSegmentItem(const uint32 index) const",
          "786:     {",
          "787:         return IsMissingHeadSegmentItemImpl<double>(index);",
          "788:     }",
          "790:     template<typename T>",
          "791:     void JavascriptArray::InternalFillFromPrototype(JavascriptArray *dstArray, const T& dstIndex, JavascriptArray *srcArray, uint32 start, uint32 end, uint32 count)",
          "792:     {",
          "793:         RecyclableObject* prototype = srcArray->GetPrototype();",
          "794:         while (start + count != end && JavascriptOperators::GetTypeId(prototype) != TypeIds_Null)",
          "795:         {",
          "796:             ForEachOwnMissingArrayIndexOfObject(srcArray, dstArray, prototype, start, end, dstIndex, [&](uint32 index, Var value) {",
          "797:                 T n = dstIndex + (index - start);",
          "798:                 dstArray->DirectSetItemAt(n, value);",
          "800:                 count++;",
          "801:             });",
          "803:             prototype = prototype->GetPrototype();",
          "804:         }",
          "805:     }",
          "807:     template<>",
          "808:     void JavascriptArray::InternalFillFromPrototype(JavascriptArray *dstArray, const uint32& dstIndex, JavascriptArray *srcArray, uint32 start, uint32 end, uint32 count)",
          "809:     {",
          "810:         RecyclableObject* prototype = srcArray->GetPrototype();",
          "811:         while (start + count != end && JavascriptOperators::GetTypeId(prototype) != TypeIds_Null)",
          "812:         {",
          "813:             ForEachOwnMissingArrayIndexOfObject(srcArray, dstArray, prototype, start, end, dstIndex, [&](uint32 index, Var value) {",
          "814:                 uint32 n = dstIndex + (index - start);",
          "815:                 dstArray->SetItem(n, value, PropertyOperation_None);",
          "817:                 count++;",
          "818:             });",
          "820:             prototype = prototype->GetPrototype();",
          "821:         }",
          "822:     }",
          "825:     bool JavascriptArray::HasInlineHeadSegment(uint32 length)",
          "826:     {",
          "827:         return length <= SparseArraySegmentBase::INLINE_CHUNK_SIZE;",
          "828:     }",
          "830:     Var JavascriptArray::OP_NewScArray(uint32 elementCount, ScriptContext* scriptContext)",
          "831:     {",
          "833:         return scriptContext->GetLibrary()->CreateArrayLiteral(elementCount);",
          "834:     }",
          "836:     Var JavascriptArray::OP_NewScArrayWithElements(uint32 elementCount, Var *elements, ScriptContext* scriptContext)",
          "837:     {",
          "839:         JavascriptArray *arr = scriptContext->GetLibrary()->CreateArrayLiteral(elementCount);",
          "841:         SparseArraySegment<Var> *head = SparseArraySegment<Var>::From(arr->head);",
          "842:         Assert(elementCount <= head->length);",
          "843:         CopyArray(head->elements, head->length, elements, elementCount);",
          "845: #ifdef VALIDATE_ARRAY",
          "846:         arr->ValidateArray();",
          "847: #endif",
          "849:         return arr;",
          "850:     }",
          "852:     Var JavascriptArray::OP_NewScArrayWithMissingValues(uint32 elementCount, ScriptContext* scriptContext)",
          "853:     {",
          "855:         JavascriptArray *const array = static_cast<JavascriptArray *>(OP_NewScArray(elementCount, scriptContext));",
          "856:         array->SetHasNoMissingValues(false);",
          "857:         SparseArraySegment<Var> *head = SparseArraySegment<Var>::From(array->head);",
          "858:         head->FillSegmentBuffer(0, elementCount);",
          "860:         return array;",
          "861:     }",
          "863: #if ENABLE_PROFILE_INFO",
          "864:     Var JavascriptArray::ProfiledNewScArray(uint32 elementCount, ScriptContext *scriptContext, ArrayCallSiteInfo *arrayInfo, RecyclerWeakReference<FunctionBody> *weakFuncRef)",
          "865:     {",
          "866:         if (arrayInfo->IsNativeIntArray())",
          "867:         {",
          "868:             JavascriptNativeIntArray *arr = scriptContext->GetLibrary()->CreateNativeIntArrayLiteral(elementCount);",
          "869:             arr->SetArrayProfileInfo(weakFuncRef, arrayInfo);",
          "870:             return arr;",
          "871:         }",
          "873:         if (arrayInfo->IsNativeFloatArray())",
          "874:         {",
          "875:             JavascriptNativeFloatArray *arr = scriptContext->GetLibrary()->CreateNativeFloatArrayLiteral(elementCount);",
          "876:             arr->SetArrayProfileInfo(weakFuncRef, arrayInfo);",
          "877:             return arr;",
          "878:         }",
          "880:         JavascriptArray *arr = scriptContext->GetLibrary()->CreateArrayLiteral(elementCount);",
          "881:         return arr;",
          "882:     }",
          "883: #endif",
          "884:     Var JavascriptArray::OP_NewScIntArray(AuxArray<int32> *ints, ScriptContext* scriptContext)",
          "885:     {",
          "886:         uint32 count = ints->count;",
          "887:         JavascriptArray *arr = scriptContext->GetLibrary()->CreateArrayLiteral(count);",
          "888:         SparseArraySegment<Var> *head = SparseArraySegment<Var>::From(arr->head);",
          "889:         Assert(count > 0 && count == head->length);",
          "890:         for (uint i = 0; i < count; i++)",
          "891:         {",
          "892:             head->elements[i] = JavascriptNumber::ToVar(ints->elements[i], scriptContext);",
          "893:         }",
          "894:         return arr;",
          "895:     }",
          "897: #if ENABLE_PROFILE_INFO",
          "898:     Var JavascriptArray::ProfiledNewScIntArray(AuxArray<int32> *ints, ScriptContext* scriptContext, ArrayCallSiteInfo *arrayInfo, RecyclerWeakReference<FunctionBody> *weakFuncRef)",
          "899:     {",
          "901:         uint32 count = ints->count;",
          "903:         if (arrayInfo->IsNativeIntArray())",
          "904:         {",
          "905:             JavascriptNativeIntArray *arr;",
          "907: #if ENABLE_COPYONACCESS_ARRAY",
          "908:             JavascriptLibrary *lib = scriptContext->GetLibrary();",
          "909:             FunctionBody *functionBody = weakFuncRef->Get();",
          "911:             if (JavascriptLibrary::IsCopyOnAccessArrayCallSite(lib, arrayInfo, count))",
          "912:             {",
          "913:                 Assert(lib->cacheForCopyOnAccessArraySegments);",
          "914:                 arr = scriptContext->GetLibrary()->CreateCopyOnAccessNativeIntArrayLiteral(arrayInfo, functionBody, ints);",
          "915:             }",
          "916:             else",
          "917: #endif",
          "918:             {",
          "919:                 arr = scriptContext->GetLibrary()->CreateNativeIntArrayLiteral(count);",
          "920:                 SparseArraySegment<int32> *head = SparseArraySegment<int32>::From(arr->head);",
          "921:                 Assert(count > 0 && count == head->length);",
          "922:                 CopyArray(head->elements, head->length, ints->elements, count);",
          "923:             }",
          "925:             arr->SetArrayProfileInfo(weakFuncRef, arrayInfo);",
          "927:             return arr;",
          "928:         }",
          "930:         if (arrayInfo->IsNativeFloatArray())",
          "931:         {",
          "932:             JavascriptNativeFloatArray *arr = scriptContext->GetLibrary()->CreateNativeFloatArrayLiteral(count);",
          "933:             SparseArraySegment<double> *head = SparseArraySegment<double>::From(arr->head);",
          "934:             Assert(count > 0 && count == head->length);",
          "935:             for (uint i = 0; i < count; i++)",
          "936:             {",
          "937:                 head->elements[i] = (double)ints->elements[i];",
          "938:             }",
          "939:             arr->SetArrayProfileInfo(weakFuncRef, arrayInfo);",
          "941:             return arr;",
          "942:         }",
          "944:         return OP_NewScIntArray(ints, scriptContext);",
          "945:     }",
          "946: #endif",
          "948:     Var JavascriptArray::OP_NewScFltArray(AuxArray<double> *doubles, ScriptContext* scriptContext)",
          "949:     {",
          "950:         uint32 count = doubles->count;",
          "951:         JavascriptArray *arr = scriptContext->GetLibrary()->CreateArrayLiteral(count);",
          "952:         SparseArraySegment<Var> *head = SparseArraySegment<Var>::From(arr->head);",
          "953:         Assert(count > 0 && count == head->length);",
          "954:         for (uint i = 0; i < count; i++)",
          "955:         {",
          "956:             double dval = doubles->elements[i];",
          "957:             int32 ival;",
          "958:             if (JavascriptNumber::TryGetInt32Value(dval, &ival) && !TaggedInt::IsOverflow(ival))",
          "959:             {",
          "960:                 head->elements[i] = TaggedInt::ToVarUnchecked(ival);",
          "961:             }",
          "962:             else",
          "963:             {",
          "964:                 head->elements[i] = JavascriptNumber::ToVarNoCheck(dval, scriptContext);",
          "965:             }",
          "966:         }",
          "967:         return arr;",
          "968:     }",
          "970: #if ENABLE_PROFILE_INFO",
          "971:     Var JavascriptArray::ProfiledNewScFltArray(AuxArray<double> *doubles, ScriptContext* scriptContext, ArrayCallSiteInfo *arrayInfo, RecyclerWeakReference<FunctionBody> *weakFuncRef)",
          "972:     {",
          "974:         if (arrayInfo->IsNativeFloatArray())",
          "975:         {",
          "976:             arrayInfo->SetIsNotNativeIntArray();",
          "977:             uint32 count = doubles->count;",
          "978:             JavascriptNativeFloatArray *arr = scriptContext->GetLibrary()->CreateNativeFloatArrayLiteral(count);",
          "979:             SparseArraySegment<double> *head = SparseArraySegment<double>::From(arr->head);",
          "980:             Assert(count > 0 && count == head->length);",
          "981:             CopyArray(head->elements, head->length, doubles->elements, count);",
          "982:             arr->SetArrayProfileInfo(weakFuncRef, arrayInfo);",
          "984:             return arr;",
          "985:         }",
          "987:         return OP_NewScFltArray(doubles, scriptContext);",
          "988:     }",
          "990:     Var JavascriptArray::ProfiledNewInstance(RecyclableObject* function, CallInfo callInfo, ...)",
          "991:     {",
          "992:         ARGUMENTS(args, callInfo);",
          "994:         Assert(JavascriptFunction::Is(function) &&",
          "995:                JavascriptFunction::FromVar(function)->GetFunctionInfo() == &JavascriptArray::EntryInfo::NewInstance);",
          "996:         Assert(callInfo.Count >= 2);",
          "998:         ArrayCallSiteInfo *arrayInfo = (ArrayCallSiteInfo*)args[0];",
          "999:         JavascriptArray* pNew = nullptr;",
          "1001:         if (callInfo.Count == 2)",
          "1002:         {",
          "1004:             Var firstArgument = args[1];",
          "1005:             int elementCount;",
          "1006:             if (TaggedInt::Is(firstArgument))",
          "1007:             {",
          "1008:                 elementCount = TaggedInt::ToInt32(firstArgument);",
          "1009:                 if (elementCount < 0)",
          "1010:                 {",
          "1011:                     JavascriptError::ThrowRangeError(function->GetScriptContext(), JSERR_ArrayLengthConstructIncorrect);",
          "1012:                 }",
          "1013:                 if (arrayInfo && arrayInfo->IsNativeArray())",
          "1014:                 {",
          "1015:                     if (arrayInfo->IsNativeIntArray())",
          "1016:                     {",
          "1017:                         pNew = function->GetLibrary()->CreateNativeIntArray(elementCount);",
          "1018:                     }",
          "1019:                     else",
          "1020:                     {",
          "1021:                         pNew = function->GetLibrary()->CreateNativeFloatArray(elementCount);",
          "1022:                     }",
          "1023:                 }",
          "1024:                 else",
          "1025:                 {",
          "1026:                     pNew = function->GetLibrary()->CreateArray(elementCount);",
          "1027:                 }",
          "1028:             }",
          "1029:             else if (JavascriptNumber::Is_NoTaggedIntCheck(firstArgument))",
          "1030:             {",
          "1032:                 double value = JavascriptNumber::GetValue(firstArgument);",
          "1033:                 uint32 uvalue = JavascriptConversion::ToUInt32(value);",
          "1034:                 if (value != uvalue)",
          "1035:                 {",
          "1036:                     JavascriptError::ThrowRangeError(function->GetScriptContext(), JSERR_ArrayLengthConstructIncorrect);",
          "1037:                 }",
          "1038:                 if (arrayInfo && arrayInfo->IsNativeArray())",
          "1039:                 {",
          "1040:                     if (arrayInfo->IsNativeIntArray())",
          "1041:                     {",
          "1042:                         pNew = function->GetLibrary()->CreateNativeIntArray(uvalue);",
          "1043:                     }",
          "1044:                     else",
          "1045:                     {",
          "1046:                         pNew = function->GetLibrary()->CreateNativeFloatArray(uvalue);",
          "1047:                     }",
          "1048:                 }",
          "1049:                 else",
          "1050:                 {",
          "1051:                     pNew = function->GetLibrary()->CreateArray(uvalue);",
          "1052:                 }",
          "1053:             }",
          "1054:             else",
          "1055:             {",
          "1062:                 pNew = function->GetLibrary()->CreateArray(1);",
          "1063:                 pNew->DirectSetItemAt<Var>(0, firstArgument);",
          "1064:             }",
          "1065:         }",
          "1066:         else",
          "1067:         {",
          "1071:             if (arrayInfo && arrayInfo->IsNativeArray())",
          "1072:             {",
          "1073:                 if (arrayInfo->IsNativeIntArray())",
          "1074:                 {",
          "1075:                     pNew = function->GetLibrary()->CreateNativeIntArray(callInfo.Count - 1);",
          "1076:                 }",
          "1077:                 else",
          "1078:                 {",
          "1079:                     pNew = function->GetLibrary()->CreateNativeFloatArray(callInfo.Count - 1);",
          "1080:                 }",
          "1081:             }",
          "1082:             else",
          "1083:             {",
          "1084:                 pNew = function->GetLibrary()->CreateArray(callInfo.Count - 1);",
          "1085:             }",
          "1086:             pNew->FillFromArgs(callInfo.Count - 1, 0, args.Values, arrayInfo);",
          "1087:         }",
          "1089: #ifdef VALIDATE_ARRAY",
          "1090:         pNew->ValidateArray();",
          "1091: #endif",
          "1092:         return pNew;",
          "1093:     }",
          "1094: #endif",
          "1096:     Var JavascriptArray::NewInstance(RecyclableObject* function, CallInfo callInfo, ...)",
          "1097:     {",
          "1098:         ARGUMENTS(args, callInfo);",
          "1099:         return NewInstance(function, args);",
          "1100:     }",
          "1102:     Var JavascriptArray::NewInstance(RecyclableObject* function, Arguments args)",
          "1103:     {",
          "1105:         PROBE_STACK(function->GetScriptContext(), Js::Constants::MinStackDefault);",
          "1109:         const CallInfo &callInfo = args.Info;",
          "1110:         Var newTarget = callInfo.Flags & CallFlags_NewTarget ? args.Values[args.Info.Count] : args[0];",
          "1111:         bool isCtorSuperCall = (callInfo.Flags & CallFlags_New) && newTarget != nullptr && !JavascriptOperators::IsUndefined(newTarget);",
          "1112:         Assert( isCtorSuperCall || !(callInfo.Flags & CallFlags_New) || args[0] == nullptr",
          "1113:             || JavascriptOperators::GetTypeId(args[0]) == TypeIds_HostDispatch);",
          "1115:         ScriptContext* scriptContext = function->GetScriptContext();",
          "1116:         JavascriptArray* pNew = nullptr;",
          "1118:         if (callInfo.Count < 2)",
          "1119:         {",
          "1121:             pNew = CreateArrayFromConstructorNoArg(function, scriptContext);",
          "1123:             return isCtorSuperCall ?",
          "1124:                 JavascriptOperators::OrdinaryCreateFromConstructor(RecyclableObject::FromVar(newTarget), pNew, nullptr, scriptContext) :",
          "1125:                 pNew;",
          "1126:         }",
          "1128:         if (callInfo.Count == 2)",
          "1129:         {",
          "1131:             Var firstArgument = args[1];",
          "1132:             int elementCount;",
          "1134:             if (TaggedInt::Is(firstArgument))",
          "1135:             {",
          "1136:                 elementCount = TaggedInt::ToInt32(firstArgument);",
          "1137:                 if (elementCount < 0)",
          "1138:                 {",
          "1139:                     JavascriptError::ThrowRangeError(scriptContext, JSERR_ArrayLengthConstructIncorrect);",
          "1140:                 }",
          "1142:                 pNew = CreateArrayFromConstructor(function, elementCount, scriptContext);",
          "1143:             }",
          "1144:             else if (JavascriptNumber::Is_NoTaggedIntCheck(firstArgument))",
          "1145:             {",
          "1147:                 double value = JavascriptNumber::GetValue(firstArgument);",
          "1148:                 uint32 uvalue = JavascriptConversion::ToUInt32(value);",
          "1149:                 if (value != uvalue)",
          "1150:                 {",
          "1151:                     JavascriptError::ThrowRangeError(scriptContext, JSERR_ArrayLengthConstructIncorrect);",
          "1152:                 }",
          "1154:                 pNew = CreateArrayFromConstructor(function, uvalue, scriptContext);",
          "1155:             }",
          "1156:             else",
          "1157:             {",
          "1164:                 pNew = CreateArrayFromConstructor(function, 1, scriptContext);",
          "1166:                 JavascriptOperators::SetItem(pNew, pNew, 0u, firstArgument, scriptContext, PropertyOperation_ThrowIfNotExtensible);",
          "1173:                 pNew->SetLength(1);",
          "1174:             }",
          "1175:         }",
          "1176:         else",
          "1177:         {",
          "1180:             pNew = CreateArrayFromConstructor(function, callInfo.Count - 1, scriptContext);",
          "1181:             pNew->JavascriptArray::FillFromArgs(callInfo.Count - 1, 0, args.Values);",
          "1182:         }",
          "1184: #ifdef VALIDATE_ARRAY",
          "1185:         pNew->ValidateArray();",
          "1186: #endif",
          "1187:         return isCtorSuperCall ?",
          "1188:             JavascriptOperators::OrdinaryCreateFromConstructor(RecyclableObject::FromVar(newTarget), pNew, nullptr, scriptContext) :",
          "1189:             pNew;",
          "1190:     }",
          "1192:     JavascriptArray* JavascriptArray::CreateArrayFromConstructor(RecyclableObject* constructor, uint32 length, ScriptContext* scriptContext)",
          "1193:     {",
          "1194:         JavascriptLibrary* library = constructor->GetLibrary();",
          "1200:         return library->CreateArray(length);",
          "1201:     }",
          "1203:     JavascriptArray* JavascriptArray::CreateArrayFromConstructorNoArg(RecyclableObject* constructor, ScriptContext* scriptContext)",
          "1204:     {",
          "1205:         JavascriptLibrary* library = constructor->GetLibrary();",
          "1206:         return library->CreateArray();",
          "1207:     }",
          "1209: #if ENABLE_PROFILE_INFO",
          "1210:     Var JavascriptArray::ProfiledNewInstanceNoArg(RecyclableObject *function, ScriptContext *scriptContext, ArrayCallSiteInfo *arrayInfo, RecyclerWeakReference<FunctionBody> *weakFuncRef)",
          "1211:     {",
          "1212:         Assert(JavascriptFunction::Is(function) &&",
          "1213:                JavascriptFunction::FromVar(function)->GetFunctionInfo() == &JavascriptArray::EntryInfo::NewInstance);",
          "1215:         if (arrayInfo->IsNativeIntArray())",
          "1216:         {",
          "1217:             JavascriptNativeIntArray *arr = scriptContext->GetLibrary()->CreateNativeIntArray();",
          "1218:             arr->SetArrayProfileInfo(weakFuncRef, arrayInfo);",
          "1219:             return arr;",
          "1220:         }",
          "1222:         if (arrayInfo->IsNativeFloatArray())",
          "1223:         {",
          "1224:             JavascriptNativeFloatArray *arr = scriptContext->GetLibrary()->CreateNativeFloatArray();",
          "1225:             arr->SetArrayProfileInfo(weakFuncRef, arrayInfo);",
          "1226:             return arr;",
          "1227:         }",
          "1229:         return scriptContext->GetLibrary()->CreateArray();",
          "1230:     }",
          "1231: #endif",
          "1233:     Var JavascriptNativeIntArray::NewInstance(RecyclableObject* function, CallInfo callInfo, ...)",
          "1234:     {",
          "1235:         ARGUMENTS(args, callInfo);",
          "1236:         return NewInstance(function, args);",
          "1237:     }",
          "1239:     Var JavascriptNativeIntArray::NewInstance(RecyclableObject* function, Arguments args)",
          "1240:     {",
          "1241:         Assert(!PHASE_OFF1(NativeArrayPhase));",
          "1243:         PROBE_STACK(function->GetScriptContext(), Js::Constants::MinStackDefault);",
          "1245:         const CallInfo &callInfo = args.Info;",
          "1246:         if (callInfo.Count < 2)",
          "1247:         {",
          "1249:             return function->GetLibrary()->CreateNativeIntArray();",
          "1250:         }",
          "1252:         JavascriptArray* pNew = nullptr;",
          "1253:         if (callInfo.Count == 2)",
          "1254:         {",
          "1256:             Var firstArgument = args[1];",
          "1257:             int elementCount;",
          "1258:             if (TaggedInt::Is(firstArgument))",
          "1259:             {",
          "1260:                 elementCount = TaggedInt::ToInt32(firstArgument);",
          "1261:                 if (elementCount < 0)",
          "1262:                 {",
          "1263:                     JavascriptError::ThrowRangeError(",
          "1264:                         function->GetScriptContext(), JSERR_ArrayLengthConstructIncorrect);",
          "1265:                 }",
          "1266:                 pNew = function->GetLibrary()->CreateNativeIntArray(elementCount);",
          "1267:             }",
          "1268:             else if (JavascriptNumber::Is_NoTaggedIntCheck(firstArgument))",
          "1269:             {",
          "1271:                 double value = JavascriptNumber::GetValue(firstArgument);",
          "1272:                 uint32 uvalue = JavascriptConversion::ToUInt32(value);",
          "1273:                 if (value != uvalue)",
          "1274:                 {",
          "1275:                     JavascriptError::ThrowRangeError(",
          "1276:                         function->GetScriptContext(), JSERR_ArrayLengthConstructIncorrect);",
          "1277:                 }",
          "1278:                 pNew = function->GetLibrary()->CreateNativeIntArray(uvalue);",
          "1279:             }",
          "1280:             else",
          "1281:             {",
          "1288:                 pNew = function->GetLibrary()->CreateArray(1);",
          "1289:                 pNew->DirectSetItemAt<Var>(0, firstArgument);",
          "1290:             }",
          "1291:         }",
          "1292:         else",
          "1293:         {",
          "1297:             JavascriptNativeIntArray *arr = function->GetLibrary()->CreateNativeIntArray(callInfo.Count - 1);",
          "1298:             pNew = arr->FillFromArgs(callInfo.Count - 1, 0, args.Values);",
          "1299:         }",
          "1301: #ifdef VALIDATE_ARRAY",
          "1302:         pNew->ValidateArray();",
          "1303: #endif",
          "1305:         return pNew;",
          "1306:     }",
          "1308:     Var JavascriptNativeFloatArray::NewInstance(RecyclableObject* function, CallInfo callInfo, ...)",
          "1309:     {",
          "1310:         ARGUMENTS(args, callInfo);",
          "1311:         return NewInstance(function, args);",
          "1312:     }",
          "1314:     Var JavascriptNativeFloatArray::NewInstance(RecyclableObject* function, Arguments args)",
          "1315:     {",
          "1316:         Assert(!PHASE_OFF1(NativeArrayPhase));",
          "1318:         PROBE_STACK(function->GetScriptContext(), Js::Constants::MinStackDefault);",
          "1320:         const CallInfo &callInfo = args.Info;",
          "1321:         if (callInfo.Count < 2)",
          "1322:         {",
          "1324:             return function->GetLibrary()->CreateNativeFloatArray();",
          "1325:         }",
          "1327:         JavascriptArray* pNew = nullptr;",
          "1328:         if (callInfo.Count == 2)",
          "1329:         {",
          "1331:             Var firstArgument = args[1];",
          "1332:             int elementCount;",
          "1333:             if (TaggedInt::Is(firstArgument))",
          "1334:             {",
          "1335:                 elementCount = TaggedInt::ToInt32(firstArgument);",
          "1336:                 if (elementCount < 0)",
          "1337:                 {",
          "1338:                     JavascriptError::ThrowRangeError(",
          "1339:                         function->GetScriptContext(), JSERR_ArrayLengthConstructIncorrect);",
          "1340:                 }",
          "1341:                 pNew = function->GetLibrary()->CreateNativeFloatArray(elementCount);",
          "1342:             }",
          "1343:             else if (JavascriptNumber::Is_NoTaggedIntCheck(firstArgument))",
          "1344:             {",
          "1346:                 double value = JavascriptNumber::GetValue(firstArgument);",
          "1347:                 uint32 uvalue = JavascriptConversion::ToUInt32(value);",
          "1348:                 if (value != uvalue)",
          "1349:                 {",
          "1350:                     JavascriptError::ThrowRangeError(",
          "1351:                         function->GetScriptContext(), JSERR_ArrayLengthConstructIncorrect);",
          "1352:                 }",
          "1353:                 pNew = function->GetLibrary()->CreateNativeFloatArray(uvalue);",
          "1354:             }",
          "1355:             else",
          "1356:             {",
          "1363:                 pNew = function->GetLibrary()->CreateArray(1);",
          "1364:                 pNew->DirectSetItemAt<Var>(0, firstArgument);",
          "1365:             }",
          "1366:         }",
          "1367:         else",
          "1368:         {",
          "1372:             JavascriptNativeFloatArray *arr = function->GetLibrary()->CreateNativeFloatArray(callInfo.Count - 1);",
          "1373:             pNew = arr->FillFromArgs(callInfo.Count - 1, 0, args.Values);",
          "1374:         }",
          "1376: #ifdef VALIDATE_ARRAY",
          "1377:         pNew->ValidateArray();",
          "1378: #endif",
          "1380:         return pNew;",
          "1381:     }",
          "1384: #if ENABLE_PROFILE_INFO",
          "1385:     JavascriptArray * JavascriptNativeIntArray::FillFromArgs(uint length, uint start, Var *args, ArrayCallSiteInfo *arrayInfo, bool dontCreateNewArray)",
          "1386: #else",
          "1387:     JavascriptArray * JavascriptNativeIntArray::FillFromArgs(uint length, uint start, Var *args, bool dontCreateNewArray)",
          "1388: #endif",
          "1389:     {",
          "1390:         uint i;",
          "1391:         for (i = start; i < length; i++)",
          "1392:         {",
          "1393:             Var item = args[i + 1];",
          "1395:             bool isTaggedInt = TaggedInt::Is(item);",
          "1396:             bool isTaggedIntMissingValue = false;",
          "1397: #ifdef _M_AMD64",
          "1398:             if (isTaggedInt)",
          "1399:             {",
          "1400:                 int32 iValue = TaggedInt::ToInt32(item);",
          "1401:                 isTaggedIntMissingValue = Js::SparseArraySegment<int32>::IsMissingItem(&iValue);",
          "1402:             }",
          "1403: #endif",
          "1404:             if (isTaggedInt && !isTaggedIntMissingValue)",
          "1405:             {",
          "1407:                 this->DirectSetItemAt(i, TaggedInt::ToInt32(item));",
          "1408:             }",
          "1409:             else if (!isTaggedIntMissingValue && JavascriptNumber::Is_NoTaggedIntCheck(item))",
          "1410:             {",
          "1411:                 double dvalue = JavascriptNumber::GetValue(item);",
          "1412:                 int32 ivalue;",
          "1413:                 if (JavascriptNumber::TryGetInt32Value(dvalue, &ivalue) && !Js::SparseArraySegment<int32>::IsMissingItem(&ivalue))",
          "1414:                 {",
          "1415:                     this->DirectSetItemAt(i, ivalue);",
          "1416:                 }",
          "1417:                 else",
          "1418:                 {",
          "1419: #if ENABLE_PROFILE_INFO",
          "1420:                     if (arrayInfo)",
          "1421:                     {",
          "1422:                         arrayInfo->SetIsNotNativeIntArray();",
          "1423:                     }",
          "1424: #endif",
          "1426:                     if (HasInlineHeadSegment(length) && i < this->head->length && !dontCreateNewArray)",
          "1427:                     {",
          "1430:                         JavascriptNativeFloatArray *fArr =",
          "1431:                             this->GetScriptContext()->GetLibrary()->CreateNativeFloatArrayLiteral(length);",
          "1432:                         return fArr->JavascriptNativeFloatArray::FillFromArgs(length, 0, args);",
          "1433:                     }",
          "1435:                     JavascriptNativeFloatArray *fArr = JavascriptNativeIntArray::ToNativeFloatArray(this);",
          "1436:                     fArr->DirectSetItemAt(i, dvalue);",
          "1437: #if ENABLE_PROFILE_INFO",
          "1438:                     return fArr->JavascriptNativeFloatArray::FillFromArgs(length, i + 1, args, arrayInfo, dontCreateNewArray);",
          "1439: #else",
          "1440:                     return fArr->JavascriptNativeFloatArray::FillFromArgs(length, i + 1, args, dontCreateNewArray);",
          "1441: #endif",
          "1442:                 }",
          "1443:             }",
          "1444:             else",
          "1445:             {",
          "1446: #if ENABLE_PROFILE_INFO",
          "1447:                 if (arrayInfo)",
          "1448:                 {",
          "1449:                     arrayInfo->SetIsNotNativeArray();",
          "1450:                 }",
          "1451: #endif",
          "1453:                 #pragma prefast(suppress:6237, \"The right hand side condition does not have any side effects.\")",
          "1454:                 if (sizeof(int32) < sizeof(Var) && HasInlineHeadSegment(length) && i < this->head->length && !dontCreateNewArray)",
          "1455:                 {",
          "1458:                     JavascriptArray *arr = this->GetScriptContext()->GetLibrary()->CreateArrayLiteral(length);",
          "1459:                     return arr->JavascriptArray::FillFromArgs(length, 0, args);",
          "1460:                 }",
          "1462:                 JavascriptArray *arr = JavascriptNativeIntArray::ToVarArray(this);",
          "1463: #if ENABLE_PROFILE_INFO",
          "1464:                 return arr->JavascriptArray::FillFromArgs(length, i, args, nullptr, dontCreateNewArray);",
          "1465: #else",
          "1466:                 return arr->JavascriptArray::FillFromArgs(length, i, args, dontCreateNewArray);",
          "1467: #endif",
          "1468:             }",
          "1469:         }",
          "1471:         return this;",
          "1472:     }",
          "1474: #if ENABLE_PROFILE_INFO",
          "1475:     JavascriptArray * JavascriptNativeFloatArray::FillFromArgs(uint length, uint start, Var *args, ArrayCallSiteInfo *arrayInfo, bool dontCreateNewArray)",
          "1476: #else",
          "1477:     JavascriptArray * JavascriptNativeFloatArray::FillFromArgs(uint length, uint start, Var *args, bool dontCreateNewArray)",
          "1478: #endif",
          "1479:     {",
          "1480:         uint i;",
          "1481:         for (i = start; i < length; i++)",
          "1482:         {",
          "1483:             Var item = args[i + 1];",
          "1484:             if (TaggedInt::Is(item))",
          "1485:             {",
          "1486:                 this->DirectSetItemAt(i, TaggedInt::ToDouble(item));",
          "1487:             }",
          "1488:             else if (JavascriptNumber::Is_NoTaggedIntCheck(item))",
          "1489:             {",
          "1490:                 this->DirectSetItemAt(i, JavascriptNumber::GetValue(item));",
          "1491:             }",
          "1492:             else",
          "1493:             {",
          "1494:                 JavascriptArray *arr = JavascriptNativeFloatArray::ToVarArray(this);",
          "1495: #if ENABLE_PROFILE_INFO",
          "1496:                 if (arrayInfo)",
          "1497:                 {",
          "1498:                     arrayInfo->SetIsNotNativeArray();",
          "1499:                 }",
          "1500:                 return arr->JavascriptArray::FillFromArgs(length, i, args, nullptr, dontCreateNewArray);",
          "1501: #else",
          "1502:                 return arr->JavascriptArray::FillFromArgs(length, i, args, dontCreateNewArray);",
          "1503: #endif",
          "1504:             }",
          "1505:         }",
          "1507:         return this;",
          "1508:     }",
          "1510: #if ENABLE_PROFILE_INFO",
          "1511:     JavascriptArray * JavascriptArray::FillFromArgs(uint length, uint start, Var *args, ArrayCallSiteInfo *arrayInfo, bool dontCreateNewArray)",
          "1512: #else",
          "1513:     JavascriptArray * JavascriptArray::FillFromArgs(uint length, uint start, Var *args, bool dontCreateNewArray)",
          "1514: #endif",
          "1515:     {",
          "1516:         uint32 i;",
          "1517:         for (i = start; i < length; i++)",
          "1518:         {",
          "1519:             Var item = args[i + 1];",
          "1520:             this->DirectSetItemAt(i, item);",
          "1521:         }",
          "1523:         return this;",
          "1524:     }",
          "1526:     DynamicType * JavascriptNativeIntArray::GetInitialType(ScriptContext * scriptContext)",
          "1527:     {",
          "1528:         return scriptContext->GetLibrary()->GetNativeIntArrayType();",
          "1529:     }",
          "1531: #if ENABLE_COPYONACCESS_ARRAY",
          "1532:     DynamicType * JavascriptCopyOnAccessNativeIntArray::GetInitialType(ScriptContext * scriptContext)",
          "1533:     {",
          "1534:         return scriptContext->GetLibrary()->GetCopyOnAccessNativeIntArrayType();",
          "1535:     }",
          "1536: #endif",
          "1538:     JavascriptNativeFloatArray *JavascriptNativeIntArray::ToNativeFloatArray(JavascriptNativeIntArray *intArray)",
          "1539:     {",
          "1540: #if ENABLE_PROFILE_INFO",
          "1541:         ArrayCallSiteInfo *arrayInfo = intArray->GetArrayCallSiteInfo();",
          "1542:         if (arrayInfo)",
          "1543:         {",
          "1544: #if DBG",
          "1545:             Js::JavascriptStackWalker walker(intArray->GetScriptContext());",
          "1546:             Js::JavascriptFunction* caller = NULL;",
          "1547:             bool foundScriptCaller = false;",
          "1548:             while(walker.GetCaller(&caller))",
          "1549:             {",
          "1550:                 if(caller != NULL && Js::ScriptFunction::Is(caller))",
          "1551:                 {",
          "1552:                     foundScriptCaller = true;",
          "1553:                     break;",
          "1554:                 }",
          "1555:             }",
          "1557:             if(foundScriptCaller)",
          "1558:             {",
          "1559:                 Assert(caller);",
          "1560:                 Assert(caller->GetFunctionBody());",
          "1561:                 if(PHASE_TRACE(Js::NativeArrayConversionPhase, caller->GetFunctionBody()))",
          "1562:                 {",
          "1563:                     Output::Print(_u(\"Conversion: Int array to Float array    ArrayCreationFunctionNumber:%2d    CallSiteNumber:%2d \\n\"), arrayInfo->functionNumber, arrayInfo->callSiteNumber);",
          "1564:                     Output::Flush();",
          "1565:                 }",
          "1566:             }",
          "1567:             else",
          "1568:             {",
          "1569:                 if(PHASE_TRACE1(Js::NativeArrayConversionPhase))",
          "1570:                 {",
          "1571:                     Output::Print(_u(\"Conversion: Int array to Float array across ScriptContexts\"));",
          "1572:                     Output::Flush();",
          "1573:                 }",
          "1574:             }",
          "1575: #else",
          "1576:             if(PHASE_TRACE1(Js::NativeArrayConversionPhase))",
          "1577:             {",
          "1578:                 Output::Print(_u(\"Conversion: Int array to Float array\"));",
          "1579:                 Output::Flush();",
          "1580:             }",
          "1581: #endif",
          "1583:             arrayInfo->SetIsNotNativeIntArray();",
          "1584:         }",
          "1585: #endif",
          "1589:         ScriptContext *scriptContext = intArray->GetScriptContext();",
          "1590:         Recycler *recycler = scriptContext->GetRecycler();",
          "1591:         SparseArraySegmentBase *seg, *nextSeg, *prevSeg = nullptr;",
          "1592:         for (seg = intArray->head; seg; seg = nextSeg)",
          "1593:         {",
          "1594:             nextSeg = seg->next;",
          "1595:             uint32 size = seg->size;",
          "1596:             if (size == 0)",
          "1597:             {",
          "1598:                 continue;",
          "1599:             }",
          "1601:             uint32 left = seg->left;",
          "1602:             uint32 length = seg->length;",
          "1603:             int i;",
          "1604:             int32 ival;",
          "1607:             seg->size >>= 1;",
          "1608:             if (seg == intArray->head || seg->length > (seg->size >>= 1))",
          "1609:             {",
          "1611:                 SparseArraySegment<double> *newSeg =",
          "1612:                     SparseArraySegment<double>::AllocateSegment(recycler, left, length, nextSeg);",
          "1613:                 Assert(newSeg != nullptr);",
          "1614:                 Assert((prevSeg == nullptr) == (seg == intArray->head));",
          "1615:                 newSeg->next = nextSeg;",
          "1616:                 intArray->LinkSegments((SparseArraySegment<double>*)prevSeg, newSeg);",
          "1617:                 if (intArray->GetLastUsedSegment() == seg)",
          "1618:                 {",
          "1619:                     intArray->SetLastUsedSegment(newSeg);",
          "1620:                 }",
          "1621:                 prevSeg = newSeg;",
          "1622:                 SegmentBTree * segmentMap = intArray->GetSegmentMap();",
          "1623:                 if (segmentMap)",
          "1624:                 {",
          "1625:                     segmentMap->SwapSegment(left, seg, newSeg);",
          "1626:                 }",
          "1629:                 for (i = 0; (uint)i < newSeg->length; i++)",
          "1630:                 {",
          "1631:                     ival = ((SparseArraySegment<int32>*)seg)->elements[i /*+ seg->length*/];",
          "1632:                     if (ival == JavascriptNativeIntArray::MissingItem)",
          "1633:                     {",
          "1634:                         continue;",
          "1635:                     }",
          "1636:                     newSeg->elements[i] = (double)ival;",
          "1637:                 }",
          "1638:             }",
          "1639:             else",
          "1640:             {",
          "1642:                 for (i = seg->length - 1; i >= 0; i--)",
          "1643:                 {",
          "1644:                     ival = ((SparseArraySegment<int32>*)seg)->elements[i];",
          "1645:                     if (ival == JavascriptNativeIntArray::MissingItem)",
          "1646:                     {",
          "1647:                         ((SparseArraySegment<double>*)seg)->elements[i] = (double)JavascriptNativeFloatArray::MissingItem;",
          "1648:                     }",
          "1649:                     else",
          "1650:                     {",
          "1651:                         ((SparseArraySegment<double>*)seg)->elements[i] = (double)ival;",
          "1652:                     }",
          "1653:                 }",
          "1654:                 prevSeg = seg;",
          "1655:             }",
          "1656:         }",
          "1658:         if (intArray->GetType() == scriptContext->GetLibrary()->GetNativeIntArrayType())",
          "1659:         {",
          "1660:             intArray->type = scriptContext->GetLibrary()->GetNativeFloatArrayType();",
          "1661:         }",
          "1662:         else",
          "1663:         {",
          "1664:             if (intArray->GetDynamicType()->GetIsLocked())",
          "1665:             {",
          "1666:                 DynamicTypeHandler *typeHandler = intArray->GetDynamicType()->GetTypeHandler();",
          "1667:                 if (typeHandler->IsPathTypeHandler())",
          "1668:                 {",
          "1673:                     static_cast<PathTypeHandlerBase*>(typeHandler)->ResetTypeHandler(intArray);",
          "1674:                 }",
          "1675:                 else",
          "1676:                 {",
          "1677:                     intArray->ChangeType();",
          "1678:                 }",
          "1679:             }",
          "1680:             intArray->GetType()->SetTypeId(TypeIds_NativeFloatArray);",
          "1681:         }",
          "1683:         if (CrossSite::IsCrossSiteObjectTyped(intArray))",
          "1684:         {",
          "1685:             Assert(VirtualTableInfo<CrossSiteObject<JavascriptNativeIntArray>>::HasVirtualTable(intArray));",
          "1686:             VirtualTableInfo<CrossSiteObject<JavascriptNativeFloatArray>>::SetVirtualTable(intArray);",
          "1687:         }",
          "1688:         else",
          "1689:         {",
          "1690:             Assert(VirtualTableInfo<JavascriptNativeIntArray>::HasVirtualTable(intArray));",
          "1691:             VirtualTableInfo<JavascriptNativeFloatArray>::SetVirtualTable(intArray);",
          "1692:         }",
          "1694:         return (JavascriptNativeFloatArray*)intArray;",
          "1695:     }",
          "1702:     template<>",
          "1703:     void JavascriptArray::ChangeArrayTypeToNativeArray<double>(JavascriptArray * varArray, ScriptContext * scriptContext)",
          "1704:     {",
          "1705:         AssertMsg(!JavascriptNativeArray::Is(varArray), \"Ensure that the incoming Array is a Var array\");",
          "1707:         if (varArray->GetType() == scriptContext->GetLibrary()->GetArrayType())",
          "1708:         {",
          "1709:             varArray->type = scriptContext->GetLibrary()->GetNativeFloatArrayType();",
          "1710:         }",
          "1711:         else",
          "1712:         {",
          "1713:             if (varArray->GetDynamicType()->GetIsLocked())",
          "1714:             {",
          "1715:                 DynamicTypeHandler *typeHandler = varArray->GetDynamicType()->GetTypeHandler();",
          "1716:                 if (typeHandler->IsPathTypeHandler())",
          "1717:                 {",
          "1722:                     static_cast<PathTypeHandlerBase*>(typeHandler)->ResetTypeHandler(varArray);",
          "1723:                 }",
          "1724:                 else",
          "1725:                 {",
          "1726:                     varArray->ChangeType();",
          "1727:                 }",
          "1728:             }",
          "1729:             varArray->GetType()->SetTypeId(TypeIds_NativeFloatArray);",
          "1730:         }",
          "1732:         if (CrossSite::IsCrossSiteObjectTyped(varArray))",
          "1733:         {",
          "1734:             Assert(VirtualTableInfo<CrossSiteObject<JavascriptArray>>::HasVirtualTable(varArray));",
          "1735:             VirtualTableInfo<CrossSiteObject<JavascriptNativeFloatArray>>::SetVirtualTable(varArray);",
          "1736:         }",
          "1737:         else",
          "1738:         {",
          "1739:             Assert(VirtualTableInfo<JavascriptArray>::HasVirtualTable(varArray));",
          "1740:             VirtualTableInfo<JavascriptNativeFloatArray>::SetVirtualTable(varArray);",
          "1741:         }",
          "1742:     }",
          "1749:     template<>",
          "1750:     void JavascriptArray::ChangeArrayTypeToNativeArray<int32>(JavascriptArray * varArray, ScriptContext * scriptContext)",
          "1751:     {",
          "1752:         AssertMsg(!JavascriptNativeArray::Is(varArray), \"Ensure that the incoming Array is a Var array\");",
          "1754:         if (varArray->GetType() == scriptContext->GetLibrary()->GetArrayType())",
          "1755:         {",
          "1756:             varArray->type = scriptContext->GetLibrary()->GetNativeIntArrayType();",
          "1757:         }",
          "1758:         else",
          "1759:         {",
          "1760:             if (varArray->GetDynamicType()->GetIsLocked())",
          "1761:             {",
          "1762:                 DynamicTypeHandler *typeHandler = varArray->GetDynamicType()->GetTypeHandler();",
          "1763:                 if (typeHandler->IsPathTypeHandler())",
          "1764:                 {",
          "1769:                     static_cast<PathTypeHandlerBase*>(typeHandler)->ResetTypeHandler(varArray);",
          "1770:                 }",
          "1771:                 else",
          "1772:                 {",
          "1773:                     varArray->ChangeType();",
          "1774:                 }",
          "1775:             }",
          "1776:             varArray->GetType()->SetTypeId(TypeIds_NativeIntArray);",
          "1777:         }",
          "1779:         if (CrossSite::IsCrossSiteObjectTyped(varArray))",
          "1780:         {",
          "1781:             Assert(VirtualTableInfo<CrossSiteObject<JavascriptArray>>::HasVirtualTable(varArray));",
          "1782:             VirtualTableInfo<CrossSiteObject<JavascriptNativeIntArray>>::SetVirtualTable(varArray);",
          "1783:         }",
          "1784:         else",
          "1785:         {",
          "1786:             Assert(VirtualTableInfo<JavascriptArray>::HasVirtualTable(varArray));",
          "1787:             VirtualTableInfo<JavascriptNativeIntArray>::SetVirtualTable(varArray);",
          "1788:         }",
          "1789:     }",
          "1791:     template<>",
          "1792:     int32 JavascriptArray::GetNativeValue<int32>(Js::Var ival, ScriptContext * scriptContext)",
          "1793:     {",
          "1794:         return JavascriptConversion::ToInt32(ival, scriptContext);",
          "1795:     }",
          "1797:     template <>",
          "1798:     double JavascriptArray::GetNativeValue<double>(Var ival, ScriptContext * scriptContext)",
          "1799:     {",
          "1800:         return JavascriptConversion::ToNumber(ival, scriptContext);",
          "1801:     }",
          "1809:     template<typename NativeArrayType, typename T>",
          "1810:     NativeArrayType *JavascriptArray::ConvertToNativeArrayInPlace(JavascriptArray *varArray)",
          "1811:     {",
          "1812:         AssertMsg(!JavascriptNativeArray::Is(varArray), \"Ensure that the incoming Array is a Var array\");",
          "1814:         ScriptContext *scriptContext = varArray->GetScriptContext();",
          "1815:         SparseArraySegmentBase *seg, *nextSeg, *prevSeg = nullptr;",
          "1816:         for (seg = varArray->head; seg; seg = nextSeg)",
          "1817:         {",
          "1818:             nextSeg = seg->next;",
          "1819:             uint32 size = seg->size;",
          "1820:             if (size == 0)",
          "1821:             {",
          "1822:                 continue;",
          "1823:             }",
          "1825:             int i;",
          "1826:             Var ival;",
          "1828:             uint32 growFactor = sizeof(Var) / sizeof(T);",
          "1829:             AssertMsg(growFactor == 1, \"We support only in place conversion of Var array to Native Array\");",
          "1832:             for (i = seg->length - 1; i >= 0; i--)",
          "1833:             {",
          "1834:                 ival = ((SparseArraySegment<Var>*)seg)->elements[i];",
          "1835:                 if (ival == JavascriptArray::MissingItem)",
          "1836:                 {",
          "1837:                     ((SparseArraySegment<T>*)seg)->elements[i] = NativeArrayType::MissingItem;",
          "1838:                 }",
          "1839:                 else",
          "1840:                 {",
          "1841:                     ((SparseArraySegment<T>*)seg)->elements[i] = GetNativeValue<T>(ival, scriptContext);",
          "1842:                 }",
          "1843:             }",
          "1844:             prevSeg = seg;",
          "1845:         }",
          "1848:         ChangeArrayTypeToNativeArray<T>(varArray, scriptContext);",
          "1850:         return (NativeArrayType*)varArray;",
          "1851:     }",
          "1853:     JavascriptArray *JavascriptNativeIntArray::ConvertToVarArray(JavascriptNativeIntArray *intArray)",
          "1854:     {",
          "1855: #if ENABLE_COPYONACCESS_ARRAY",
          "1856:         JavascriptLibrary::CheckAndConvertCopyOnAccessNativeIntArray<Var>(intArray);",
          "1857: #endif",
          "1858:         ScriptContext *scriptContext = intArray->GetScriptContext();",
          "1859:         Recycler *recycler = scriptContext->GetRecycler();",
          "1860:         SparseArraySegmentBase *seg, *nextSeg, *prevSeg = nullptr;",
          "1861:         for (seg = intArray->head; seg; seg = nextSeg)",
          "1862:         {",
          "1863:             nextSeg = seg->next;",
          "1864:             uint32 size = seg->size;",
          "1865:             if (size == 0)",
          "1866:             {",
          "1867:                 continue;",
          "1868:             }",
          "1870:             uint32 left = seg->left;",
          "1871:             uint32 length = seg->length;",
          "1872:             int i;",
          "1873:             int32 ival;",
          "1876:             uint32 growFactor = sizeof(Var) / sizeof(int32);",
          "1877:             if ((growFactor != 1 && (seg == intArray->head || seg->length > (seg->size /= growFactor))) ||",
          "1878:                 (seg->next == nullptr && SparseArraySegmentBase::IsLeafSegment(seg, recycler)))",
          "1879:             {",
          "1882:                 SparseArraySegment<Var> *newSeg =",
          "1883:                     SparseArraySegment<Var>::AllocateSegment(recycler, left, length, nextSeg);",
          "1885:                 AnalysisAssert(newSeg);",
          "1886:                 Assert((prevSeg == nullptr) == (seg == intArray->head));",
          "1887:                 newSeg->next = nextSeg;",
          "1888:                 intArray->LinkSegments((SparseArraySegment<Var>*)prevSeg, newSeg);",
          "1889:                 if (intArray->GetLastUsedSegment() == seg)",
          "1890:                 {",
          "1891:                     intArray->SetLastUsedSegment(newSeg);",
          "1892:                 }",
          "1893:                 prevSeg = newSeg;",
          "1895:                 SegmentBTree * segmentMap = intArray->GetSegmentMap();",
          "1896:                 if (segmentMap)",
          "1897:                 {",
          "1898:                     segmentMap->SwapSegment(left, seg, newSeg);",
          "1899:                 }",
          "1902:                 for (i = 0; (uint)i < newSeg->length; i++)",
          "1903:                 {",
          "1904:                     ival = ((SparseArraySegment<int32>*)seg)->elements[i];",
          "1905:                     if (ival == JavascriptNativeIntArray::MissingItem)",
          "1906:                     {",
          "1907:                         continue;",
          "1908:                     }",
          "1909:                     newSeg->elements[i] = JavascriptNumber::ToVar(ival, scriptContext);",
          "1910:                 }",
          "1911:             }",
          "1912:             else",
          "1913:             {",
          "1916:                 for (i = seg->length - 1; i >= 0; i--)",
          "1917:                 {",
          "1918:                     ival = ((SparseArraySegment<int32>*)seg)->elements[i];",
          "1919:                     if (ival == JavascriptNativeIntArray::MissingItem)",
          "1920:                     {",
          "1921:                         ((SparseArraySegment<Var>*)seg)->elements[i] = (Var)JavascriptArray::MissingItem;",
          "1922:                     }",
          "1923:                     else",
          "1924:                     {",
          "1925:                         ((SparseArraySegment<Var>*)seg)->elements[i] = JavascriptNumber::ToVar(ival, scriptContext);",
          "1926:                     }",
          "1927:                 }",
          "1928:                 prevSeg = seg;",
          "1929:             }",
          "1930:         }",
          "1932:         if (intArray->GetType() == scriptContext->GetLibrary()->GetNativeIntArrayType())",
          "1933:         {",
          "1934:             intArray->type = scriptContext->GetLibrary()->GetArrayType();",
          "1935:         }",
          "1936:         else",
          "1937:         {",
          "1938:             if (intArray->GetDynamicType()->GetIsLocked())",
          "1939:             {",
          "1940:                 DynamicTypeHandler *typeHandler = intArray->GetDynamicType()->GetTypeHandler();",
          "1941:                 if (typeHandler->IsPathTypeHandler())",
          "1942:                 {",
          "1947:                     static_cast<PathTypeHandlerBase*>(typeHandler)->ResetTypeHandler(intArray);",
          "1948:                 }",
          "1949:                 else",
          "1950:                 {",
          "1951:                     intArray->ChangeType();",
          "1952:                 }",
          "1953:             }",
          "1954:             intArray->GetType()->SetTypeId(TypeIds_Array);",
          "1955:         }",
          "1957:         if (CrossSite::IsCrossSiteObjectTyped(intArray))",
          "1958:         {",
          "1959:             Assert(VirtualTableInfo<CrossSiteObject<JavascriptNativeIntArray>>::HasVirtualTable(intArray));",
          "1960:             VirtualTableInfo<CrossSiteObject<JavascriptArray>>::SetVirtualTable(intArray);",
          "1961:         }",
          "1962:         else",
          "1963:         {",
          "1964:             Assert(VirtualTableInfo<JavascriptNativeIntArray>::HasVirtualTable(intArray));",
          "1965:             VirtualTableInfo<JavascriptArray>::SetVirtualTable(intArray);",
          "1966:         }",
          "1968:         return intArray;",
          "1969:     }",
          "1970:     JavascriptArray *JavascriptNativeIntArray::ToVarArray(JavascriptNativeIntArray *intArray)",
          "1971:     {",
          "1972: #if ENABLE_PROFILE_INFO",
          "1973:         ArrayCallSiteInfo *arrayInfo = intArray->GetArrayCallSiteInfo();",
          "1974:         if (arrayInfo)",
          "1975:         {",
          "1976: #if DBG",
          "1977:             Js::JavascriptStackWalker walker(intArray->GetScriptContext());",
          "1978:             Js::JavascriptFunction* caller = NULL;",
          "1979:             bool foundScriptCaller = false;",
          "1980:             while(walker.GetCaller(&caller))",
          "1981:             {",
          "1982:                 if(caller != NULL && Js::ScriptFunction::Is(caller))",
          "1983:                 {",
          "1984:                     foundScriptCaller = true;",
          "1985:                     break;",
          "1986:                 }",
          "1987:             }",
          "1989:             if(foundScriptCaller)",
          "1990:             {",
          "1991:                 Assert(caller);",
          "1992:                 Assert(caller->GetFunctionBody());",
          "1993:                 if(PHASE_TRACE(Js::NativeArrayConversionPhase, caller->GetFunctionBody()))",
          "1994:                 {",
          "1995:                     Output::Print(_u(\"Conversion: Int array to Var array    ArrayCreationFunctionNumber:%2d    CallSiteNumber:%2d \\n\"), arrayInfo->functionNumber, arrayInfo->callSiteNumber);",
          "1996:                     Output::Flush();",
          "1997:                 }",
          "1998:             }",
          "1999:             else",
          "2000:             {",
          "2001:                 if(PHASE_TRACE1(Js::NativeArrayConversionPhase))",
          "2002:                 {",
          "2003:                     Output::Print(_u(\"Conversion: Int array to Var array across ScriptContexts\"));",
          "2004:                     Output::Flush();",
          "2005:                 }",
          "2006:             }",
          "2007: #else",
          "2008:             if(PHASE_TRACE1(Js::NativeArrayConversionPhase))",
          "2009:             {",
          "2010:                 Output::Print(_u(\"Conversion: Int array to Var array\"));",
          "2011:                 Output::Flush();",
          "2012:             }",
          "2013: #endif",
          "2015:             arrayInfo->SetIsNotNativeArray();",
          "2016:         }",
          "2017: #endif",
          "2019:         intArray->ClearArrayCallSiteIndex();",
          "2021:         return ConvertToVarArray(intArray);",
          "2022:     }",
          "2024:     DynamicType * JavascriptNativeFloatArray::GetInitialType(ScriptContext * scriptContext)",
          "2025:     {",
          "2026:         return scriptContext->GetLibrary()->GetNativeFloatArrayType();",
          "2027:     }",
          "2034:     JavascriptArray *JavascriptNativeFloatArray::ConvertToVarArray(JavascriptNativeFloatArray *fArray)",
          "2035:     {",
          "2037:         Assert(sizeof(double) >= sizeof(Var));",
          "2039:         uint32 shrinkFactor = sizeof(double) / sizeof(Var);",
          "2040:         ScriptContext *scriptContext = fArray->GetScriptContext();",
          "2041:         Recycler *recycler = scriptContext->GetRecycler();",
          "2042:         SparseArraySegmentBase *seg, *nextSeg, *prevSeg = nullptr;",
          "2043:         for (seg = fArray->head; seg; seg = nextSeg)",
          "2044:         {",
          "2045:             nextSeg = seg->next;",
          "2046:             if (seg->size == 0)",
          "2047:             {",
          "2048:                 continue;",
          "2049:             }",
          "2050:             uint32 left = seg->left;",
          "2051:             uint32 length = seg->length;",
          "2052:             SparseArraySegment<Var> *newSeg;",
          "2053:             if (seg->next == nullptr && SparseArraySegmentBase::IsLeafSegment(seg, recycler))",
          "2054:             {",
          "2056:                 newSeg =",
          "2057:                     SparseArraySegment<Var>::AllocateSegment(recycler, left, length, nextSeg);",
          "2058:                 Assert((prevSeg == nullptr) == (seg == fArray->head));",
          "2059:                 newSeg->next = nextSeg;",
          "2060:                 fArray->LinkSegments((SparseArraySegment<Var>*)prevSeg, newSeg);",
          "2061:                 if (fArray->GetLastUsedSegment() == seg)",
          "2062:                 {",
          "2063:                     fArray->SetLastUsedSegment(newSeg);",
          "2064:                 }",
          "2065:                 prevSeg = newSeg;",
          "2067:                 SegmentBTree * segmentMap = fArray->GetSegmentMap();",
          "2068:                 if (segmentMap)",
          "2069:                 {",
          "2070:                     segmentMap->SwapSegment(left, seg, newSeg);",
          "2071:                 }",
          "2072:             }",
          "2073:             else",
          "2074:             {",
          "2075:                 newSeg = (SparseArraySegment<Var>*)seg;",
          "2076:                 prevSeg = seg;",
          "2077:                 if (shrinkFactor != 1)",
          "2078:                 {",
          "2079:                     uint32 newSize = seg->size * shrinkFactor;",
          "2080:                     uint32 limit;",
          "2081:                     if (seg->next)",
          "2082:                     {",
          "2083:                         limit = seg->next->left;",
          "2084:                     }",
          "2085:                     else",
          "2086:                     {",
          "2087:                         limit = JavascriptArray::MaxArrayLength;",
          "2088:                     }",
          "2089:                     seg->size = min(newSize, limit - seg->left);",
          "2090:                 }",
          "2091:             }",
          "2092:             uint32 i;",
          "2093:             for (i = 0; i < seg->length; i++)",
          "2094:             {",
          "2095:                 if (SparseArraySegment<double>::IsMissingItem(&((SparseArraySegment<double>*)seg)->elements[i]))",
          "2096:                 {",
          "2097:                     if (seg == newSeg)",
          "2098:                     {",
          "2099:                         newSeg->elements[i] = (Var)JavascriptArray::MissingItem;",
          "2100:                     }",
          "2101:                     Assert(newSeg->elements[i] == (Var)JavascriptArray::MissingItem);",
          "2102:                 }",
          "2103:                 else if (*(uint64*)&(((SparseArraySegment<double>*)seg)->elements[i]) == 0ull)",
          "2104:                 {",
          "2105:                     newSeg->elements[i] = TaggedInt::ToVarUnchecked(0);",
          "2106:                 }",
          "2107:                 else",
          "2108:                 {",
          "2109:                     int32 ival;",
          "2110:                     double dval = ((SparseArraySegment<double>*)seg)->elements[i];",
          "2111:                     if (JavascriptNumber::TryGetInt32Value(dval, &ival) && !TaggedInt::IsOverflow(ival))",
          "2112:                     {",
          "2113:                         newSeg->elements[i] = TaggedInt::ToVarUnchecked(ival);",
          "2114:                     }",
          "2115:                     else",
          "2116:                     {",
          "2117:                         newSeg->elements[i] = JavascriptNumber::ToVarWithCheck(dval, scriptContext);",
          "2118:                     }",
          "2119:                 }",
          "2120:             }",
          "2121:             if (seg == newSeg && shrinkFactor != 1)",
          "2122:             {",
          "2124:                 newSeg->FillSegmentBuffer(i, seg->size);",
          "2125:             }",
          "2126:         }",
          "2128:         if (fArray->GetType() == scriptContext->GetLibrary()->GetNativeFloatArrayType())",
          "2129:         {",
          "2130:             fArray->type = scriptContext->GetLibrary()->GetArrayType();",
          "2131:         }",
          "2132:         else",
          "2133:         {",
          "2134:             if (fArray->GetDynamicType()->GetIsLocked())",
          "2135:             {",
          "2136:                 DynamicTypeHandler *typeHandler = fArray->GetDynamicType()->GetTypeHandler();",
          "2137:                 if (typeHandler->IsPathTypeHandler())",
          "2138:                 {",
          "2143:                     static_cast<PathTypeHandlerBase*>(typeHandler)->ResetTypeHandler(fArray);",
          "2144:                 }",
          "2145:                 else",
          "2146:                 {",
          "2147:                     fArray->ChangeType();",
          "2148:                 }",
          "2149:             }",
          "2150:             fArray->GetType()->SetTypeId(TypeIds_Array);",
          "2151:         }",
          "2153:         if (CrossSite::IsCrossSiteObjectTyped(fArray))",
          "2154:         {",
          "2155:             Assert(VirtualTableInfo<CrossSiteObject<JavascriptNativeFloatArray>>::HasVirtualTable(fArray));",
          "2156:             VirtualTableInfo<CrossSiteObject<JavascriptArray>>::SetVirtualTable(fArray);",
          "2157:         }",
          "2158:         else",
          "2159:         {",
          "2160:             Assert(VirtualTableInfo<JavascriptNativeFloatArray>::HasVirtualTable(fArray));",
          "2161:             VirtualTableInfo<JavascriptArray>::SetVirtualTable(fArray);",
          "2162:         }",
          "2164:         return fArray;",
          "2165:     }",
          "2167:     JavascriptArray *JavascriptNativeFloatArray::ToVarArray(JavascriptNativeFloatArray *fArray)",
          "2168:     {",
          "2169: #if ENABLE_PROFILE_INFO",
          "2170:         ArrayCallSiteInfo *arrayInfo = fArray->GetArrayCallSiteInfo();",
          "2171:         if (arrayInfo)",
          "2172:         {",
          "2173: #if DBG",
          "2174:             Js::JavascriptStackWalker walker(fArray->GetScriptContext());",
          "2175:             Js::JavascriptFunction* caller = NULL;",
          "2176:             bool foundScriptCaller = false;",
          "2177:             while(walker.GetCaller(&caller))",
          "2178:             {",
          "2179:                 if(caller != NULL && Js::ScriptFunction::Is(caller))",
          "2180:                 {",
          "2181:                     foundScriptCaller = true;",
          "2182:                     break;",
          "2183:                 }",
          "2184:             }",
          "2186:             if(foundScriptCaller)",
          "2187:             {",
          "2188:                 Assert(caller);",
          "2189:                 Assert(caller->GetFunctionBody());",
          "2190:                 if(PHASE_TRACE(Js::NativeArrayConversionPhase, caller->GetFunctionBody()))",
          "2191:                 {",
          "2192:                     Output::Print(_u(\"Conversion: Float array to Var array    ArrayCreationFunctionNumber:%2d    CallSiteNumber:%2d \\n\"), arrayInfo->functionNumber, arrayInfo->callSiteNumber);",
          "2193:                     Output::Flush();",
          "2194:                 }",
          "2195:             }",
          "2196:             else",
          "2197:             {",
          "2198:                 if(PHASE_TRACE1(Js::NativeArrayConversionPhase))",
          "2199:                 {",
          "2200:                     Output::Print(_u(\"Conversion: Float array to Var array across ScriptContexts\"));",
          "2201:                     Output::Flush();",
          "2202:                 }",
          "2203:             }",
          "2204: #else",
          "2205:             if(PHASE_TRACE1(Js::NativeArrayConversionPhase))",
          "2206:             {",
          "2207:                 Output::Print(_u(\"Conversion: Float array to Var array\"));",
          "2208:                 Output::Flush();",
          "2209:             }",
          "2210: #endif",
          "2212:             if(fArray->GetScriptContext()->IsScriptContextInNonDebugMode())",
          "2213:             {",
          "2214:                 Assert(!arrayInfo->IsNativeIntArray());",
          "2215:             }",
          "2217:             arrayInfo->SetIsNotNativeArray();",
          "2218:         }",
          "2219: #endif",
          "2221:         fArray->ClearArrayCallSiteIndex();",
          "2223:         return ConvertToVarArray(fArray);",
          "2225:     }",
          "2234:     int64 JavascriptArray::GetIndexFromVar(Js::Var arg, int64 length, ScriptContext* scriptContext)",
          "2235:     {",
          "2236:         int64 index;",
          "2238:         if (TaggedInt::Is(arg))",
          "2239:         {",
          "2240:             int intValue = TaggedInt::ToInt32(arg);",
          "2242:             if (intValue < 0)",
          "2243:             {",
          "2244:                 index = max<int64>(0, length + intValue);",
          "2245:             }",
          "2246:             else",
          "2247:             {",
          "2248:                 index = intValue;",
          "2249:             }",
          "2251:             if (index > length)",
          "2252:             {",
          "2253:                 index = length;",
          "2254:             }",
          "2255:         }",
          "2256:         else",
          "2257:         {",
          "2258:             double doubleValue = JavascriptConversion::ToInteger(arg, scriptContext);",
          "2261:             if (doubleValue > length)",
          "2262:             {",
          "2263:                 return length;",
          "2264:             }",
          "2266:             index = NumberUtilities::TryToInt64(doubleValue);",
          "2268:             if (index < 0)",
          "2269:             {",
          "2270:                 index = max<int64>(0, index + length);",
          "2271:             }",
          "2272:         }",
          "2274:         return index;",
          "2275:     }",
          "2277:     TypeId JavascriptArray::OP_SetNativeIntElementC(JavascriptNativeIntArray *arr, uint32 index, Var value, ScriptContext *scriptContext)",
          "2278:     {",
          "2279:         int32 iValue;",
          "2280:         double dValue;",
          "2282:         TypeId typeId = arr->TrySetNativeIntArrayItem(value, &iValue, &dValue);",
          "2283:         if (typeId == TypeIds_NativeIntArray)",
          "2284:         {",
          "2285:             arr->SetArrayLiteralItem(index, iValue);",
          "2286:         }",
          "2287:         else if (typeId == TypeIds_NativeFloatArray)",
          "2288:         {",
          "2289:             arr->SetArrayLiteralItem(index, dValue);",
          "2290:         }",
          "2291:         else",
          "2292:         {",
          "2293:             arr->SetArrayLiteralItem(index, value);",
          "2294:         }",
          "2295:         return typeId;",
          "2296:     }",
          "2298:     TypeId JavascriptArray::OP_SetNativeFloatElementC(JavascriptNativeFloatArray *arr, uint32 index, Var value, ScriptContext *scriptContext)",
          "2299:     {",
          "2300:         double dValue;",
          "2301:         TypeId typeId = arr->TrySetNativeFloatArrayItem(value, &dValue);",
          "2302:         if (typeId == TypeIds_NativeFloatArray)",
          "2303:         {",
          "2304:             arr->SetArrayLiteralItem(index, dValue);",
          "2305:         }",
          "2306:         else",
          "2307:         {",
          "2308:             arr->SetArrayLiteralItem(index, value);",
          "2309:         }",
          "2310:         return typeId;",
          "2311:     }",
          "2313:     template<typename T>",
          "2314:     void JavascriptArray::SetArrayLiteralItem(uint32 index, T value)",
          "2315:     {",
          "2316:         SparseArraySegment<T> * segment = SparseArraySegment<T>::From(this->head);",
          "2318:         Assert(segment->left == 0);",
          "2319:         Assert(index < segment->length);",
          "2321:         segment->elements[index] = value;",
          "2322:     }",
          "2324:     void JavascriptNativeIntArray::SetIsPrototype()",
          "2325:     {",
          "2327:         ToVarArray(this);",
          "2328:         __super::SetIsPrototype();",
          "2329:     }",
          "2331:     void JavascriptNativeFloatArray::SetIsPrototype()",
          "2332:     {",
          "2334:         ToVarArray(this);",
          "2335:         __super::SetIsPrototype();",
          "2336:     }",
          "2338: #if ENABLE_PROFILE_INFO",
          "2339:     ArrayCallSiteInfo *JavascriptNativeArray::GetArrayCallSiteInfo()",
          "2340:     {",
          "2341:         RecyclerWeakReference<FunctionBody> *weakRef = this->weakRefToFuncBody;",
          "2342:         if (weakRef)",
          "2343:         {",
          "2344:             FunctionBody *functionBody = weakRef->Get();",
          "2345:             if (functionBody)",
          "2346:             {",
          "2347:                 if (functionBody->HasDynamicProfileInfo())",
          "2348:                 {",
          "2349:                     Js::ProfileId profileId = this->GetArrayCallSiteIndex();",
          "2350:                     if (profileId < functionBody->GetProfiledArrayCallSiteCount())",
          "2351:                     {",
          "2352:                         return functionBody->GetAnyDynamicProfileInfo()->GetArrayCallSiteInfo(functionBody, profileId);",
          "2353:                     }",
          "2354:                 }",
          "2355:             }",
          "2356:             else",
          "2357:             {",
          "2358:                 this->ClearArrayCallSiteIndex();",
          "2359:             }",
          "2360:         }",
          "2361:         return nullptr;",
          "2362:     }",
          "2364:     void JavascriptNativeArray::SetArrayProfileInfo(RecyclerWeakReference<FunctionBody> *weakRef, ArrayCallSiteInfo *arrayInfo)",
          "2365:     {",
          "2366:         Assert(weakRef);",
          "2367:         FunctionBody *functionBody = weakRef->Get();",
          "2368:         if (functionBody && functionBody->HasDynamicProfileInfo())",
          "2369:         {",
          "2370:             ArrayCallSiteInfo *baseInfo = functionBody->GetAnyDynamicProfileInfo()->GetArrayCallSiteInfo(functionBody, 0);",
          "2371:             Js::ProfileId index = (Js::ProfileId)(arrayInfo - baseInfo);",
          "2372:             Assert(index < functionBody->GetProfiledArrayCallSiteCount());",
          "2373:             SetArrayCallSite(index, weakRef);",
          "2374:         }",
          "2375:     }",
          "2377:     void JavascriptNativeArray::CopyArrayProfileInfo(Js::JavascriptNativeArray* baseArray)",
          "2378:     {",
          "2379:         if (baseArray->weakRefToFuncBody)",
          "2380:         {",
          "2381:             if (baseArray->weakRefToFuncBody->Get())",
          "2382:             {",
          "2383:                 SetArrayCallSite(baseArray->GetArrayCallSiteIndex(), baseArray->weakRefToFuncBody);",
          "2384:             }",
          "2385:             else",
          "2386:             {",
          "2387:                 baseArray->ClearArrayCallSiteIndex();",
          "2388:             }",
          "2389:         }",
          "2390:     }",
          "2391: #endif",
          "2393:     Var JavascriptNativeArray::FindMinOrMax(Js::ScriptContext * scriptContext, bool findMax)",
          "2394:     {",
          "2395:         if (JavascriptNativeIntArray::Is(this))",
          "2396:         {",
          "2397:             return this->FindMinOrMax<int32, false>(scriptContext, findMax);",
          "2398:         }",
          "2399:         else",
          "2400:         {",
          "2401:             return this->FindMinOrMax<double, true>(scriptContext, findMax);",
          "2402:         }",
          "2403:     }",
          "2405:     template <typename T, bool checkNaNAndNegZero>",
          "2406:     Var JavascriptNativeArray::FindMinOrMax(Js::ScriptContext * scriptContext, bool findMax)",
          "2407:     {",
          "2408:         AssertMsg(this->HasNoMissingValues(), \"Fastpath is only for arrays with one segment and no missing values\");",
          "2409:         uint len = this->GetLength();",
          "2411:         Js::SparseArraySegment<T>* headSegment = ((Js::SparseArraySegment<T>*)this->GetHead());",
          "2412:         uint headSegLen = headSegment->length;",
          "2413:         Assert(headSegLen == len);",
          "2415:         if (headSegment->next == nullptr)",
          "2416:         {",
          "2417:             T currentRes = headSegment->elements[0];",
          "2418:             for (uint i = 0; i < headSegLen; i++)",
          "2419:             {",
          "2420:                 T compare = headSegment->elements[i];",
          "2421:                 if (checkNaNAndNegZero && JavascriptNumber::IsNan(double(compare)))",
          "2422:                 {",
          "2423:                     return scriptContext->GetLibrary()->GetNaN();",
          "2424:                 }",
          "2425:                 if (findMax ? currentRes < compare : currentRes > compare ||",
          "2426:                     (checkNaNAndNegZero && compare == 0 && Js::JavascriptNumber::IsNegZero(double(currentRes))))",
          "2427:                 {",
          "2428:                     currentRes = compare;",
          "2429:                 }",
          "2430:             }",
          "2431:             return Js::JavascriptNumber::ToVarNoCheck(currentRes, scriptContext);",
          "2432:         }",
          "2433:         else",
          "2434:         {",
          "2435:             AssertMsg(false, \"FindMinOrMax currently supports native arrays with only one segment\");",
          "2436:             Throw::FatalInternalError();",
          "2437:         }",
          "2438:     }",
          "2440:     SparseArraySegmentBase * JavascriptArray::GetLastUsedSegment() const",
          "2441:     {",
          "2442:         return HasSegmentMap() ?",
          "2443:             PointerValue(segmentUnion.segmentBTreeRoot->lastUsedSegment) :",
          "2444:             PointerValue(segmentUnion.lastUsedSegment);",
          "2445:     }",
          "2447:     void JavascriptArray::SetHeadAndLastUsedSegment(SparseArraySegmentBase * segment)",
          "2448:     {",
          "2450:         Assert(!HasSegmentMap());",
          "2451:         this->head = this->segmentUnion.lastUsedSegment = segment;",
          "2452:     }",
          "2454:     void JavascriptArray::SetLastUsedSegment(SparseArraySegmentBase * segment)",
          "2455:     {",
          "2456:         if (HasSegmentMap())",
          "2457:         {",
          "2458:             this->segmentUnion.segmentBTreeRoot->lastUsedSegment = segment;",
          "2459:         }",
          "2460:         else",
          "2461:         {",
          "2462:             this->segmentUnion.lastUsedSegment = segment;",
          "2463:         }",
          "2464:     }",
          "2465:     bool JavascriptArray::HasSegmentMap() const",
          "2466:     {",
          "2467:         return !!(GetFlags() & DynamicObjectFlags::HasSegmentMap);",
          "2468:     }",
          "2470:     SegmentBTreeRoot * JavascriptArray::GetSegmentMap() const",
          "2471:     {",
          "2472:         return (HasSegmentMap() ? segmentUnion.segmentBTreeRoot : nullptr);",
          "2473:     }",
          "2475:     void JavascriptArray::SetSegmentMap(SegmentBTreeRoot * segmentMap)",
          "2476:     {",
          "2477:         Assert(!HasSegmentMap());",
          "2478:         SparseArraySegmentBase * lastUsedSeg = this->segmentUnion.lastUsedSegment;",
          "2479:         SetFlags(GetFlags() | DynamicObjectFlags::HasSegmentMap);",
          "2480:         segmentUnion.segmentBTreeRoot = segmentMap;",
          "2481:         segmentMap->lastUsedSegment = lastUsedSeg;",
          "2482:     }",
          "2484:     void JavascriptArray::ClearSegmentMap()",
          "2485:     {",
          "2486:         if (HasSegmentMap())",
          "2487:         {",
          "2488:             SetFlags(GetFlags() & ~DynamicObjectFlags::HasSegmentMap);",
          "2489:             SparseArraySegmentBase * lastUsedSeg = segmentUnion.segmentBTreeRoot->lastUsedSegment;",
          "2490:             segmentUnion.segmentBTreeRoot = nullptr;",
          "2491:             segmentUnion.lastUsedSegment = lastUsedSeg;",
          "2492:         }",
          "2493:     }",
          "2495:     SegmentBTreeRoot * JavascriptArray::BuildSegmentMap()",
          "2496:     {",
          "2497:         Recycler* recycler = GetRecycler();",
          "2498:         SegmentBTreeRoot* tmpSegmentMap = AllocatorNewStruct(Recycler, recycler, SegmentBTreeRoot);",
          "2499:         ForEachSegment([recycler, tmpSegmentMap](SparseArraySegmentBase * current)",
          "2500:         {",
          "2501:             tmpSegmentMap->Add(recycler, current);",
          "2502:             return false;",
          "2503:         });",
          "2506:         SetSegmentMap(tmpSegmentMap);",
          "2507:         return tmpSegmentMap;",
          "2508:     }",
          "2510:     void JavascriptArray::TryAddToSegmentMap(Recycler* recycler, SparseArraySegmentBase* seg)",
          "2511:     {",
          "2512:         SegmentBTreeRoot * savedSegmentMap = GetSegmentMap();",
          "2513:         if (savedSegmentMap)",
          "2514:         {",
          "2520:             ClearSegmentMap();",
          "2521:             savedSegmentMap->Add(recycler, seg);",
          "2522:             SetSegmentMap(savedSegmentMap);",
          "2523:         }",
          "2524:     }",
          "2526:     void JavascriptArray::InvalidateLastUsedSegment()",
          "2527:     {",
          "2528:         this->SetLastUsedSegment(this->head);",
          "2529:     }",
          "2531:     DescriptorFlags JavascriptArray::GetSetter(PropertyId propertyId, Var *setterValue, PropertyValueInfo* info, ScriptContext* requestContext)",
          "2532:     {",
          "2533:         DescriptorFlags flags;",
          "2534:         if (GetSetterBuiltIns(propertyId, info, &flags))",
          "2535:         {",
          "2536:             return flags;",
          "2537:         }",
          "2538:         return __super::GetSetter(propertyId, setterValue, info, requestContext);",
          "2539:     }",
          "2541:     DescriptorFlags JavascriptArray::GetSetter(JavascriptString* propertyNameString, Var *setterValue, PropertyValueInfo* info, ScriptContext* requestContext)",
          "2542:     {",
          "2543:         DescriptorFlags flags;",
          "2544:         PropertyRecord const* propertyRecord;",
          "2545:         this->GetScriptContext()->FindPropertyRecord(propertyNameString, &propertyRecord);",
          "2547:         if (propertyRecord != nullptr && GetSetterBuiltIns(propertyRecord->GetPropertyId(), info, &flags))",
          "2548:         {",
          "2549:             return flags;",
          "2550:         }",
          "2552:         return __super::GetSetter(propertyNameString, setterValue, info, requestContext);",
          "2553:     }",
          "2555:     bool JavascriptArray::GetSetterBuiltIns(PropertyId propertyId, PropertyValueInfo* info, DescriptorFlags* descriptorFlags)",
          "2556:     {",
          "2557:         if (propertyId == PropertyIds::length)",
          "2558:         {",
          "2559:             PropertyValueInfo::SetNoCache(info, this);",
          "2561:             return true;",
          "2562:         }",
          "2563:         return false;",
          "2564:     }",
          "2566:     SparseArraySegmentBase * JavascriptArray::GetBeginLookupSegment(uint32 index, const bool useSegmentMap) const",
          "2567:     {",
          "2568:         SparseArraySegmentBase *seg = nullptr;",
          "2569:         SparseArraySegmentBase * lastUsedSeg = this->GetLastUsedSegment();",
          "2570:         if (lastUsedSeg != nullptr && lastUsedSeg->left <= index)",
          "2571:         {",
          "2572:             seg = lastUsedSeg;",
          "2573:             if(index - lastUsedSeg->left < lastUsedSeg->size)",
          "2574:             {",
          "2575:                 return seg;",
          "2576:             }",
          "2577:         }",
          "2579:         SegmentBTreeRoot * segmentMap = GetSegmentMap();",
          "2580:         if(!useSegmentMap || !segmentMap)",
          "2581:         {",
          "2582:             return seg ? seg : PointerValue(this->head);",
          "2583:         }",
          "2585:         if(seg)",
          "2586:         {",
          "2589:             SparseArraySegmentBase *const nextSeg = seg->next;",
          "2590:             if(nextSeg)",
          "2591:             {",
          "2592:                 if(index < nextSeg->left)",
          "2593:                 {",
          "2594:                     return seg;",
          "2595:                 }",
          "2596:                 else if(index - nextSeg->left < nextSeg->size)",
          "2597:                 {",
          "2598:                     return nextSeg;",
          "2599:                 }",
          "2600:             }",
          "2601:         }",
          "2603:         SparseArraySegmentBase *matchOrNextSeg;",
          "2604:         segmentMap->Find(index, seg, matchOrNextSeg);",
          "2605:         return seg ? seg : matchOrNextSeg;",
          "2606:     }",
          "2608:     uint32 JavascriptArray::GetNextIndex(uint32 index) const",
          "2609:     {",
          "2610:         if (JavascriptNativeIntArray::Is((Var)this))",
          "2611:         {",
          "2612:             return this->GetNextIndexHelper<int32>(index);",
          "2613:         }",
          "2614:         else if (JavascriptNativeFloatArray::Is((Var)this))",
          "2615:         {",
          "2616:             return this->GetNextIndexHelper<double>(index);",
          "2617:         }",
          "2618:         return this->GetNextIndexHelper<Var>(index);",
          "2619:     }",
          "2621:     template<typename T>",
          "2622:     uint32 JavascriptArray::GetNextIndexHelper(uint32 index) const",
          "2623:     {",
          "2624:         AssertMsg(this->head, \"array head should never be null\");",
          "2625:         uint candidateIndex;",
          "2627:         if (index == JavascriptArray::InvalidIndex)",
          "2628:         {",
          "2629:             candidateIndex = head->left;",
          "2630:         }",
          "2631:         else",
          "2632:         {",
          "2633:             candidateIndex = index + 1;",
          "2634:         }",
          "2636:         SparseArraySegment<T>* current = (SparseArraySegment<T>*)this->GetBeginLookupSegment(candidateIndex);",
          "2638:         while (current != nullptr)",
          "2639:         {",
          "2640:             if ((current->left <= candidateIndex) && ((candidateIndex - current->left) < current->length))",
          "2641:             {",
          "2642:                 for (uint i = candidateIndex - current->left; i < current->length; i++)",
          "2643:                 {",
          "2644:                     if (!SparseArraySegment<T>::IsMissingItem(&current->elements[i]))",
          "2645:                     {",
          "2646:                         return i + current->left;",
          "2647:                     }",
          "2648:                 }",
          "2649:             }",
          "2650:             current = SparseArraySegment<T>::From(current->next);",
          "2651:             if (current != NULL)",
          "2652:             {",
          "2653:                 if (candidateIndex < current->left)",
          "2654:                 {",
          "2655:                     candidateIndex = current->left;",
          "2656:                 }",
          "2657:             }",
          "2658:         }",
          "2659:         return JavascriptArray::InvalidIndex;",
          "2660:     }",
          "2664:     void JavascriptArray::SetLength(uint32 newLength)",
          "2665:     {",
          "2666:         if (newLength == length)",
          "2667:             return;",
          "2669:         if (head == EmptySegment)",
          "2670:         {",
          "2672:         }",
          "2673:         else if (newLength == 0)",
          "2674:         {",
          "2675:             this->ClearElements(head, 0);",
          "2676:             head->length = 0;",
          "2677:             head->next = nullptr;",
          "2678:             SetHasNoMissingValues();",
          "2680:             ClearSegmentMap();",
          "2681:             this->InvalidateLastUsedSegment();",
          "2682:         }",
          "2683:         else if (newLength < length)",
          "2684:         {",
          "2696:             SparseArraySegmentBase* next = GetBeginLookupSegment(newLength - 1); // head, or next.left < newLength",
          "2697:             Field(SparseArraySegmentBase*)* prev = &head;",
          "2699:             while(next != nullptr)",
          "2700:             {",
          "2701:                 if (newLength <= next->left)",
          "2702:                 {",
          "2703:                     ClearSegmentMap(); // truncate segments, null out segmentMap",
          "2705:                     break;",
          "2706:                 }",
          "2707:                 else if (newLength <= (next->left + next->length))",
          "2708:                 {",
          "2709:                     if (next->next)",
          "2710:                     {",
          "2711:                         ClearSegmentMap(); // Will truncate segments, null out segmentMap",
          "2712:                     }",
          "2714:                     uint32 newSegmentLength = newLength - next->left;",
          "2715:                     this->ClearElements(next, newSegmentLength);",
          "2716:                     next->next = nullptr;",
          "2717:                     next->length = newSegmentLength;",
          "2718:                     break;",
          "2719:                 }",
          "2720:                 else",
          "2721:                 {",
          "2722:                     prev = &next->next;",
          "2723:                     next = next->next;",
          "2724:                 }",
          "2725:             }",
          "2726:             this->InvalidateLastUsedSegment();",
          "2727:         }",
          "2728:         this->length = newLength;",
          "2730: #ifdef VALIDATE_ARRAY",
          "2731:         ValidateArray();",
          "2732: #endif",
          "2733:     }",
          "2735:     BOOL JavascriptArray::SetLength(Var newLength)",
          "2736:     {",
          "2737:         ScriptContext *scriptContext;",
          "2738:         if(TaggedInt::Is(newLength))",
          "2739:         {",
          "2740:             int32 lenValue = TaggedInt::ToInt32(newLength);",
          "2741:             if (lenValue < 0)",
          "2742:             {",
          "2743:                 scriptContext = GetScriptContext();",
          "2744:                 if (scriptContext->GetThreadContext()->RecordImplicitException())",
          "2745:                 {",
          "2746:                     JavascriptError::ThrowRangeError(scriptContext, JSERR_ArrayLengthAssignIncorrect);",
          "2747:                 }",
          "2748:             }",
          "2749:             else",
          "2750:             {",
          "2751:                 this->SetLength(lenValue);",
          "2752:             }",
          "2753:             return TRUE;",
          "2754:         }",
          "2756:         scriptContext = GetScriptContext();",
          "2757:         uint32 uintValue = JavascriptConversion::ToUInt32(newLength, scriptContext);",
          "2758:         double dblValue = JavascriptConversion::ToNumber(newLength, scriptContext);",
          "2759:         if (dblValue == uintValue)",
          "2760:         {",
          "2761:             this->SetLength(uintValue);",
          "2762:         }",
          "2763:         else",
          "2764:         {",
          "2765:             ThreadContext* threadContext = scriptContext->GetThreadContext();",
          "2766:             ImplicitCallFlags flags = threadContext->GetImplicitCallFlags();",
          "2767:             if (flags != ImplicitCall_None && threadContext->IsDisableImplicitCall())",
          "2768:             {",
          "2771:                 return TRUE;",
          "2772:             }",
          "2774:             if (threadContext->RecordImplicitException())",
          "2775:             {",
          "2776:                 JavascriptError::ThrowRangeError(scriptContext, JSERR_ArrayLengthAssignIncorrect);",
          "2777:             }",
          "2778:         }",
          "2780:         return TRUE;",
          "2781:     }",
          "2783:     void JavascriptArray::ClearElements(SparseArraySegmentBase *seg, uint32 newSegmentLength)",
          "2784:     {",
          "2785:         SparseArraySegment<Var>::ClearElements(((SparseArraySegment<Var>*)seg)->elements + newSegmentLength, seg->length - newSegmentLength);",
          "2786:     }",
          "2788:     void JavascriptNativeIntArray::ClearElements(SparseArraySegmentBase *seg, uint32 newSegmentLength)",
          "2789:     {",
          "2790:         SparseArraySegment<int32>::ClearElements(((SparseArraySegment<int32>*)seg)->elements + newSegmentLength, seg->length - newSegmentLength);",
          "2791:     }",
          "2793:     void JavascriptNativeFloatArray::ClearElements(SparseArraySegmentBase *seg, uint32 newSegmentLength)",
          "2794:     {",
          "2795:         SparseArraySegment<double>::ClearElements(((SparseArraySegment<double>*)seg)->elements + newSegmentLength, seg->length - newSegmentLength);",
          "2796:     }",
          "2798:     Var JavascriptArray::DirectGetItem(uint32 index)",
          "2799:     {",
          "2800:         SparseArraySegment<Var> *seg = (SparseArraySegment<Var>*)this->GetLastUsedSegment();",
          "2801:         uint32 offset = index - seg->left;",
          "2802:         if (index >= seg->left && offset < seg->length)",
          "2803:         {",
          "2804:             if (!SparseArraySegment<Var>::IsMissingItem(&seg->elements[offset]))",
          "2805:             {",
          "2806:                 return seg->elements[offset];",
          "2807:             }",
          "2808:         }",
          "2809:         Var element;",
          "2810:         if (DirectGetItemAtFull(index, &element))",
          "2811:         {",
          "2812:             return element;",
          "2813:         }",
          "2814:         return GetType()->GetLibrary()->GetUndefined();",
          "2815:     }",
          "2817:     Var JavascriptNativeIntArray::DirectGetItem(uint32 index)",
          "2818:     {",
          "2819: #if ENABLE_COPYONACCESS_ARRAY",
          "2820:         JavascriptLibrary::CheckAndConvertCopyOnAccessNativeIntArray<Var>(this);",
          "2821: #endif",
          "2822:         SparseArraySegment<int32> *seg = (SparseArraySegment<int32>*)this->GetLastUsedSegment();",
          "2823:         uint32 offset = index - seg->left;",
          "2824:         if (index >= seg->left && offset < seg->length)",
          "2825:         {",
          "2826:             if (!SparseArraySegment<int32>::IsMissingItem(&seg->elements[offset]))",
          "2827:             {",
          "2828:                 return JavascriptNumber::ToVar(seg->elements[offset], GetScriptContext());",
          "2829:             }",
          "2830:         }",
          "2831:         Var element;",
          "2832:         if (DirectGetItemAtFull(index, &element))",
          "2833:         {",
          "2834:             return element;",
          "2835:         }",
          "2836:         return GetType()->GetLibrary()->GetUndefined();",
          "2837:     }",
          "2839:     DescriptorFlags JavascriptNativeIntArray::GetItemSetter(uint32 index, Var* setterValue, ScriptContext* requestContext)",
          "2840:     {",
          "2841: #if ENABLE_COPYONACCESS_ARRAY",
          "2842:         JavascriptLibrary::CheckAndConvertCopyOnAccessNativeIntArray<Var>(this);",
          "2843: #endif",
          "2844:         int32 value = 0;",
          "2845:         return this->DirectGetItemAt(index, &value) ? WritableData : None;",
          "2846:     }",
          "2849:     Var JavascriptNativeFloatArray::DirectGetItem(uint32 index)",
          "2850:     {",
          "2851:         SparseArraySegment<double> *seg = (SparseArraySegment<double>*)this->GetLastUsedSegment();",
          "2852:         uint32 offset = index - seg->left;",
          "2853:         if (index >= seg->left && offset < seg->length)",
          "2854:         {",
          "2855:             if (!SparseArraySegment<double>::IsMissingItem(&seg->elements[offset]))",
          "2856:             {",
          "2857:                 return JavascriptNumber::ToVarWithCheck(seg->elements[offset], GetScriptContext());",
          "2858:             }",
          "2859:         }",
          "2860:         Var element;",
          "2861:         if (DirectGetItemAtFull(index, &element))",
          "2862:         {",
          "2863:             return element;",
          "2864:         }",
          "2865:         return GetType()->GetLibrary()->GetUndefined();",
          "2866:     }",
          "2868:     Var JavascriptArray::DirectGetItem(JavascriptString *propName, ScriptContext* scriptContext)",
          "2869:     {",
          "2870:         PropertyRecord const * propertyRecord;",
          "2871:         scriptContext->GetOrAddPropertyRecord(propName->GetString(), propName->GetLength(), &propertyRecord);",
          "2872:         return JavascriptOperators::GetProperty(this, propertyRecord->GetPropertyId(), scriptContext, NULL);",
          "2873:     }",
          "2875:     BOOL JavascriptArray::DirectGetItemAtFull(uint32 index, Var* outVal)",
          "2876:     {",
          "2877:         if (this->DirectGetItemAt(index, outVal))",
          "2878:         {",
          "2879:             return TRUE;",
          "2880:         }",
          "2882:         ScriptContext* requestContext = type->GetScriptContext();",
          "2883:         return JavascriptOperators::GetItem(this, this->GetPrototype(), index, outVal, requestContext);",
          "2884:     }",
          "2889:     void JavascriptArray::LinkSegmentsCommon(SparseArraySegmentBase* prev, SparseArraySegmentBase* current)",
          "2890:     {",
          "2891:         if (prev)",
          "2892:         {",
          "2893:             prev->next = current;",
          "2894:         }",
          "2895:         else",
          "2896:         {",
          "2897:             Assert(current);",
          "2898:             head = current;",
          "2899:         }",
          "2900:     }",
          "2902:     template<typename T>",
          "2903:     BOOL JavascriptArray::DirectDeleteItemAt(uint32 itemIndex)",
          "2904:     {",
          "2905:         if (itemIndex >= length)",
          "2906:         {",
          "2907:             return true;",
          "2908:         }",
          "2909:         SparseArraySegment<T>* next = (SparseArraySegment<T>*)GetBeginLookupSegment(itemIndex);",
          "2910:         while(next != nullptr && next->left <= itemIndex)",
          "2911:         {",
          "2912:             uint32 limit = next->left + next->length;",
          "2913:             if (itemIndex < limit)",
          "2914:             {",
          "2915:                 next->SetElement(GetRecycler(), itemIndex, SparseArraySegment<T>::GetMissingItem());",
          "2916:                 if(itemIndex - next->left == next->length - 1)",
          "2917:                 {",
          "2918:                     --next->length;",
          "2919:                 }",
          "2920:                 else if(next == head)",
          "2921:                 {",
          "2922:                     SetHasNoMissingValues(false);",
          "2923:                 }",
          "2924:                 break;",
          "2925:             }",
          "2926:             next = SparseArraySegment<T>::From(next->next);",
          "2927:         }",
          "2928: #ifdef VALIDATE_ARRAY",
          "2929:         ValidateArray();",
          "2930: #endif",
          "2931:         return true;",
          "2932:     }",
          "2934:     template <> Var JavascriptArray::ConvertToIndex(BigIndex idxDest, ScriptContext* scriptContext)",
          "2935:     {",
          "2936:         return idxDest.ToNumber(scriptContext);",
          "2937:     }",
          "2939:     template <> uint32 JavascriptArray::ConvertToIndex(BigIndex idxDest, ScriptContext* scriptContext)",
          "2940:     {",
          "2942:         return idxDest.IsSmallIndex() ? idxDest.GetSmallIndex() : UINT_MAX;",
          "2943:     }",
          "2945:     template <> Var JavascriptArray::ConvertToIndex(uint32 idxDest, ScriptContext* scriptContext)",
          "2946:     {",
          "2947:         return  JavascriptNumber::ToVar(idxDest, scriptContext);",
          "2948:     }",
          "2950:     void JavascriptArray::ThrowErrorOnFailure(BOOL succeeded, ScriptContext* scriptContext, uint32 index)",
          "2951:     {",
          "2952:         if (!succeeded)",
          "2953:         {",
          "2954:             JavascriptError::ThrowTypeError(scriptContext, JSERR_CantRedefineProp, JavascriptConversion::ToString(JavascriptNumber::ToVar(index, scriptContext), scriptContext)->GetSz());",
          "2955:         }",
          "2956:     }",
          "2958:     void JavascriptArray::ThrowErrorOnFailure(BOOL succeeded, ScriptContext* scriptContext, BigIndex index)",
          "2959:     {",
          "2960:         if (!succeeded)",
          "2961:         {",
          "2962:             uint64 i = (uint64)(index.IsSmallIndex() ? index.GetSmallIndex() : index.GetBigIndex());",
          "2963:             JavascriptError::ThrowTypeError(scriptContext, JSERR_CantRedefineProp, JavascriptConversion::ToString(JavascriptNumber::ToVar(i, scriptContext), scriptContext)->GetSz());",
          "2964:         }",
          "2965:     }",
          "2967:     BOOL JavascriptArray::SetArrayLikeObjects(RecyclableObject* pDestObj, uint32 idxDest, Var aItem)",
          "2968:     {",
          "2969:         return pDestObj->SetItem(idxDest, aItem, Js::PropertyOperation_ThrowIfNotExtensible);",
          "2970:     }",
          "2972:     uint64 JavascriptArray::OP_GetLength(Var obj, ScriptContext *scriptContext)",
          "2973:     {",
          "2974:         if (scriptContext->GetConfig()->IsES6ToLengthEnabled())",
          "2975:         {",
          "2977:             return (uint64)JavascriptConversion::ToLength(JavascriptOperators::OP_GetLength(obj, scriptContext), scriptContext);",
          "2978:         }",
          "2979:         else",
          "2980:         {",
          "2981:             return (uint64)JavascriptConversion::ToUInt32(JavascriptOperators::OP_GetLength(obj, scriptContext), scriptContext);",
          "2982:         }",
          "2983:     }",
          "2985:     template<typename T>",
          "2986:     void JavascriptArray::TryGetArrayAndLength(Var arg,",
          "2987:         ScriptContext *scriptContext,",
          "2988:         PCWSTR methodName,",
          "2989:         __out JavascriptArray** array,",
          "2990:         __out RecyclableObject** obj,",
          "2991:         __out T * length)",
          "2992:     {",
          "2993:         Assert(array != nullptr);",
          "2994:         Assert(obj != nullptr);",
          "2995:         Assert(length != nullptr);",
          "2997:         if (JavascriptArray::Is(arg) && !JavascriptArray::FromVar(arg)->IsCrossSiteObject())",
          "2998:         {",
          "2999: #if ENABLE_COPYONACCESS_ARRAY",
          "3000:             JavascriptLibrary::CheckAndConvertCopyOnAccessNativeIntArray<Var>(arg);",
          "3001: #endif",
          "3005:         }",
          "3006:         else",
          "3007:         {",
          "3008:             if (!JavascriptConversion::ToObject(arg, scriptContext, obj))",
          "3009:             {",
          "3010:                 JavascriptError::ThrowTypeError(scriptContext, JSERR_This_NullOrUndefined, methodName);",
          "3011:             }",
          "3014:         }",
          "3015:     }",
          "3017:     BOOL JavascriptArray::SetArrayLikeObjects(RecyclableObject* pDestObj, BigIndex idxDest, Var aItem)",
          "3018:     {",
          "3019:         ScriptContext* scriptContext = pDestObj->GetScriptContext();",
          "3021:         if (idxDest.IsSmallIndex())",
          "3022:         {",
          "3023:             return pDestObj->SetItem(idxDest.GetSmallIndex(), aItem, Js::PropertyOperation_ThrowIfNotExtensible);",
          "3024:         }",
          "3025:         PropertyRecord const * propertyRecord;",
          "3026:         JavascriptOperators::GetPropertyIdForInt(idxDest.GetBigIndex(), scriptContext, &propertyRecord);",
          "3027:         return pDestObj->SetProperty(propertyRecord->GetPropertyId(), aItem, PropertyOperation_ThrowIfNotExtensible, nullptr);",
          "3028:     }",
          "3030:     template<typename T>",
          "3031:     void JavascriptArray::ConcatArgs(RecyclableObject* pDestObj, TypeId* remoteTypeIds,",
          "3032:         Js::Arguments& args, ScriptContext* scriptContext, uint start, BigIndex startIdxDest,",
          "3033:         BOOL FirstPromotedItemIsSpreadable, BigIndex FirstPromotedItemLength, bool spreadableCheckedAndTrue)",
          "3034:     {",
          "3036:         Throw::InternalError();",
          "3037:     }",
          "3041:     template<typename T>",
          "3042:     void JavascriptArray::ConcatArgs(RecyclableObject* pDestObj, TypeId* remoteTypeIds,",
          "3043:         Js::Arguments& args, ScriptContext* scriptContext, uint start, uint startIdxDest,",
          "3044:         BOOL firstPromotedItemIsSpreadable, BigIndex firstPromotedItemLength, bool spreadableCheckedAndTrue)",
          "3045:     {",
          "3046:         JS_REENTRANCY_LOCK(jsReentLock, scriptContext->GetThreadContext());",
          "3047:         JavascriptArray* pDestArray = nullptr;",
          "3049:         if (JavascriptArray::Is(pDestObj))",
          "3050:         {",
          "3051:             pDestArray = JavascriptArray::FromVar(pDestObj);",
          "3052:         }",
          "3054:         T idxDest = startIdxDest;",
          "3055:         for (uint idxArg = start; idxArg < args.Info.Count; idxArg++)",
          "3056:         {",
          "3057:             Var aItem = args[idxArg];",
          "3058:             bool spreadable = spreadableCheckedAndTrue;",
          "3059:             if (!spreadable && scriptContext->GetConfig()->IsES6IsConcatSpreadableEnabled())",
          "3060:             {",
          "3064:                 JS_REENTRANT(jsReentLock, spreadable = firstPromotedItemIsSpreadable || JavascriptOperators::IsConcatSpreadable(aItem));",
          "3066:                 if (!spreadable)",
          "3067:                 {",
          "3068:                     JS_REENTRANT(jsReentLock, JavascriptArray::SetConcatItem<T>(aItem, idxArg, pDestArray, pDestObj, idxDest, scriptContext));",
          "3069:                     ++idxDest;",
          "3070:                     continue;",
          "3071:                 }",
          "3072:             }",
          "3073:             else",
          "3074:             {",
          "3075:                 spreadableCheckedAndTrue = false; // if it was `true`, reset after the first use",
          "3076:             }",
          "3078:             if (pDestArray && JavascriptArray::IsDirectAccessArray(aItem) && JavascriptArray::IsDirectAccessArray(pDestArray)",
          "3079:                 && BigIndex(idxDest + JavascriptArray::FromVar(aItem)->length).IsSmallIndex()) // Fast path",
          "3080:             {",
          "3081:                 if (JavascriptNativeIntArray::Is(aItem))",
          "3082:                 {",
          "3083:                     JavascriptNativeIntArray *pItemArray = JavascriptNativeIntArray::FromVar(aItem);",
          "3084:                     JS_REENTRANT(jsReentLock, CopyNativeIntArrayElementsToVar(pDestArray, idxDest, pItemArray));",
          "3085:                     idxDest = idxDest + pItemArray->length;",
          "3086:                 }",
          "3087:                 else if (JavascriptNativeFloatArray::Is(aItem))",
          "3088:                 {",
          "3089:                     JavascriptNativeFloatArray *pItemArray = JavascriptNativeFloatArray::FromVar(aItem);",
          "3090:                     JS_REENTRANT(jsReentLock, CopyNativeFloatArrayElementsToVar(pDestArray, idxDest, pItemArray));",
          "3091:                     idxDest = idxDest + pItemArray->length;",
          "3092:                 }",
          "3093:                 else",
          "3094:                 {",
          "3095:                     JavascriptArray* pItemArray = JavascriptArray::FromVar(aItem);",
          "3096:                     JS_REENTRANT(jsReentLock, CopyArrayElements(pDestArray, idxDest, pItemArray));",
          "3097:                     idxDest = idxDest + pItemArray->length;",
          "3098:                 }",
          "3099:             }",
          "3100:             else",
          "3101:             {",
          "3103:                 if (DynamicObject::IsAnyArray(aItem) || remoteTypeIds[idxArg] == TypeIds_Array || spreadable)",
          "3104:                 {",
          "3106:                     BigIndex length;",
          "3107:                     if (firstPromotedItemIsSpreadable)",
          "3108:                     {",
          "3109:                         firstPromotedItemIsSpreadable = false;",
          "3110:                         length = firstPromotedItemLength;",
          "3111:                     }",
          "3112:                     else",
          "3113:                     {",
          "3114:                         JS_REENTRANT(jsReentLock, length = OP_GetLength(aItem, scriptContext));",
          "3115:                     }",
          "3117:                     if (PromoteToBigIndex(length,idxDest))",
          "3118:                     {",
          "3123:                         ConcatArgs<BigIndex>(pDestArray, remoteTypeIds, args, scriptContext, idxArg, idxDest, /*firstPromotedItemIsSpreadable*/true, length);",
          "3124:                         return;",
          "3125:                     }",
          "3127:                     if (length + idxDest > FiftyThirdPowerOfTwoMinusOne) // 2^53-1: from ECMA 22.1.3.1 Array.prototype.concat(...arguments)",
          "3128:                     {",
          "3129:                         JavascriptError::ThrowTypeError(scriptContext, JSERR_IllegalArraySizeAndLength);",
          "3130:                     }",
          "3132:                     RecyclableObject* itemObject = RecyclableObject::FromVar(aItem);",
          "3133:                     Var subItem;",
          "3134:                     uint32 lengthToUin32Max = length.IsSmallIndex() ? length.GetSmallIndex() : MaxArrayLength;",
          "3135:                     for (uint32 idxSubItem = 0u; idxSubItem < lengthToUin32Max; ++idxSubItem)",
          "3136:                     {",
          "3137:                         JS_REENTRANT(jsReentLock, BOOL hasItem = JavascriptOperators::HasItem(itemObject, idxSubItem));",
          "3138:                         if (hasItem)",
          "3139:                         {",
          "3140:                             JS_REENTRANT(jsReentLock, subItem = JavascriptOperators::GetItem(itemObject, idxSubItem, scriptContext));",
          "3142:                             if (pDestArray)",
          "3143:                             {",
          "3144:                                 pDestArray->DirectSetItemAt(idxDest, subItem);",
          "3145:                             }",
          "3146:                             else",
          "3147:                             {",
          "3148:                                 JS_REENTRANT(jsReentLock, ThrowErrorOnFailure(SetArrayLikeObjects(pDestObj, idxDest, subItem), scriptContext, idxDest));",
          "3149:                             }",
          "3150:                         }",
          "3151:                         ++idxDest;",
          "3152:                     }",
          "3154:                     for (BigIndex idxSubItem = MaxArrayLength; idxSubItem < length; ++idxSubItem)",
          "3155:                     {",
          "3156:                         PropertyRecord const * propertyRecord;",
          "3157:                         JavascriptOperators::GetPropertyIdForInt(idxSubItem.GetBigIndex(), scriptContext, &propertyRecord);",
          "3158:                         JS_REENTRANT(jsReentLock, BOOL hasProp = JavascriptOperators::HasProperty(itemObject, propertyRecord->GetPropertyId()));",
          "3159:                         if (hasProp)",
          "3160:                         {",
          "3161:                             JS_REENTRANT(jsReentLock, subItem = JavascriptOperators::GetProperty(itemObject, propertyRecord->GetPropertyId(), scriptContext));",
          "3162:                             if (pDestArray)",
          "3163:                             {",
          "3164:                                 pDestArray->DirectSetItemAt(idxDest, subItem);",
          "3165:                             }",
          "3166:                             else",
          "3167:                             {",
          "3168:                                 JS_REENTRANT(jsReentLock, ThrowErrorOnFailure(SetArrayLikeObjects(pDestObj, idxDest, subItem), scriptContext, idxSubItem));",
          "3169:                             }",
          "3170:                         }",
          "3171:                         ++idxDest;",
          "3172:                     }",
          "3173:                 }",
          "3174:                 else // concat 1 item",
          "3175:                 {",
          "3176:                     JS_REENTRANT(jsReentLock, JavascriptArray::SetConcatItem<T>(aItem, idxArg, pDestArray, pDestObj, idxDest, scriptContext));",
          "3177:                     ++idxDest;",
          "3178:                 }",
          "3179:             }",
          "3180:         }",
          "3181:         if (!pDestArray)",
          "3182:         {",
          "3183:             JS_REENTRANT(jsReentLock, pDestObj->SetProperty(PropertyIds::length, ConvertToIndex<T, Var>(idxDest, scriptContext), Js::PropertyOperation_None, nullptr));",
          "3184:        }",
          "3185:         else if (pDestArray->GetLength() != ConvertToIndex<T, uint32>(idxDest, scriptContext))",
          "3186:         {",
          "3187:             pDestArray->SetLength(ConvertToIndex<T, uint32>(idxDest, scriptContext));",
          "3188:         }",
          "3189:     }",
          "3191:     bool JavascriptArray::PromoteToBigIndex(BigIndex lhs, BigIndex rhs)",
          "3192:     {",
          "3193:         return false; // already a big index",
          "3194:     }",
          "3196:     bool JavascriptArray::PromoteToBigIndex(BigIndex lhs, uint32 rhs)",
          "3197:     {",
          "3198:         ::Math::RecordOverflowPolicy destLengthOverflow;",
          "3199:         if (lhs.IsSmallIndex())",
          "3200:         {",
          "3201:             UInt32Math::Add(lhs.GetSmallIndex(), rhs, destLengthOverflow);",
          "3202:             return destLengthOverflow.HasOverflowed();",
          "3203:         }",
          "3204:         return true;",
          "3205:     }",
          "3207:     JavascriptArray* JavascriptArray::ConcatIntArgs(JavascriptNativeIntArray* pDestArray, TypeId *remoteTypeIds, Js::Arguments& args, ScriptContext* scriptContext)",
          "3208:     {",
          "3209:         JS_REENTRANCY_LOCK(jsReentLock, scriptContext->GetThreadContext());",
          "3210:         uint idxDest = 0u;",
          "3211:         for (uint idxArg = 0; idxArg < args.Info.Count; idxArg++)",
          "3212:         {",
          "3213:             Var aItem = args[idxArg];",
          "3214:             bool spreadableCheckedAndTrue = false;",
          "3216:             if (scriptContext->GetConfig()->IsES6IsConcatSpreadableEnabled())",
          "3217:             {",
          "3218:                 JS_REENTRANT(jsReentLock, spreadableCheckedAndTrue = !scriptContext->GetConfig()->IsES6IsConcatSpreadableEnabled() || JavascriptOperators::IsConcatSpreadable(aItem));",
          "3219:                 if (!JavascriptNativeIntArray::Is(pDestArray))",
          "3220:                 {",
          "3221:                     ConcatArgs<uint>(pDestArray, remoteTypeIds, args, scriptContext, idxArg, idxDest, spreadableCheckedAndTrue);",
          "3222:                     return pDestArray;",
          "3223:                 }",
          "3225:                 if(!spreadableCheckedAndTrue)",
          "3226:                 {",
          "3227:                     JS_REENTRANT(jsReentLock, pDestArray->SetItem(idxDest, aItem, PropertyOperation_ThrowIfNotExtensible));",
          "3228:                     idxDest = idxDest + 1;",
          "3229:                     if (!JavascriptNativeIntArray::Is(pDestArray)) // SetItem could convert pDestArray to a var array if aItem is not an integer if so fall back",
          "3230:                     {",
          "3231:                         JS_REENTRANT(jsReentLock, ConcatArgs<uint>(pDestArray, remoteTypeIds, args, scriptContext, idxArg + 1, idxDest));",
          "3232:                         return pDestArray;",
          "3233:                     }",
          "3234:                     continue;",
          "3235:                 }",
          "3236:             }",
          "3238:             if (JavascriptNativeIntArray::Is(aItem)) // Fast path",
          "3239:             {",
          "3240:                 JavascriptNativeIntArray* pItemArray = JavascriptNativeIntArray::FromVar(aItem);",
          "3242:                 JS_REENTRANT(jsReentLock, bool converted = CopyNativeIntArrayElements(pDestArray, idxDest, pItemArray));",
          "3244:                 idxDest = idxDest + pItemArray->length;",
          "3245:                 if (converted)",
          "3246:                 {",
          "3249:                     JS_REENTRANT(jsReentLock, ConcatArgs<uint>(pDestArray, remoteTypeIds, args, scriptContext, idxArg + 1, idxDest));",
          "3250:                     return pDestArray;",
          "3251:                 }",
          "3252:             }",
          "3253:             else if (!JavascriptArray::IsAnyArray(aItem) && remoteTypeIds[idxArg] != TypeIds_Array)",
          "3254:             {",
          "3255:                 if (TaggedInt::Is(aItem))",
          "3256:                 {",
          "3257:                     pDestArray->DirectSetItemAt(idxDest, TaggedInt::ToInt32(aItem));",
          "3258:                 }",
          "3259:                 else",
          "3260:                 {",
          "3261: #if DBG",
          "3262:                     int32 int32Value;",
          "3263:                     Assert(",
          "3264:                         JavascriptNumber::TryGetInt32Value(JavascriptNumber::GetValue(aItem), &int32Value) &&",
          "3265:                         !SparseArraySegment<int32>::IsMissingItem(&int32Value));",
          "3266: #endif",
          "3267:                     pDestArray->DirectSetItemAt(idxDest, static_cast<int32>(JavascriptNumber::GetValue(aItem)));",
          "3268:                 }",
          "3269:                 ++idxDest;",
          "3270:             }",
          "3271:             else",
          "3272:             {",
          "3273:                 JavascriptArray *pVarDestArray = JavascriptNativeIntArray::ConvertToVarArray(pDestArray);",
          "3274:                 JS_REENTRANT(jsReentLock, ConcatArgs<uint>(pVarDestArray, remoteTypeIds, args, scriptContext, idxArg, idxDest, spreadableCheckedAndTrue));",
          "3275:                 return pVarDestArray;",
          "3276:             }",
          "3277:         }",
          "3278:         if (pDestArray->GetLength() != idxDest)",
          "3279:         {",
          "3280:             pDestArray->SetLength(idxDest);",
          "3281:         }",
          "3282:         return pDestArray;",
          "3283:     }",
          "3285:     JavascriptArray* JavascriptArray::ConcatFloatArgs(JavascriptNativeFloatArray* pDestArray, TypeId *remoteTypeIds, Js::Arguments& args, ScriptContext* scriptContext)",
          "3286:     {",
          "3287:         JS_REENTRANCY_LOCK(jsReentLock, scriptContext->GetThreadContext());",
          "3288:         uint idxDest = 0u;",
          "3289:         for (uint idxArg = 0; idxArg < args.Info.Count; idxArg++)",
          "3290:         {",
          "3291:             Var aItem = args[idxArg];",
          "3293:             bool spreadableCheckedAndTrue = false;",
          "3295:             if (scriptContext->GetConfig()->IsES6IsConcatSpreadableEnabled())",
          "3296:             {",
          "3297:                 JS_REENTRANT(jsReentLock, spreadableCheckedAndTrue = !scriptContext->GetConfig()->IsES6IsConcatSpreadableEnabled() || JavascriptOperators::IsConcatSpreadable(aItem));",
          "3298:                 if (!JavascriptNativeFloatArray::Is(pDestArray))",
          "3299:                 {",
          "3300:                     ConcatArgs<uint>(pDestArray, remoteTypeIds, args, scriptContext, idxArg, idxDest, spreadableCheckedAndTrue);",
          "3301:                     return pDestArray;",
          "3302:                 }",
          "3304:                 if (!spreadableCheckedAndTrue)",
          "3305:                 {",
          "3306:                     JS_REENTRANT(jsReentLock, pDestArray->SetItem(idxDest, aItem, PropertyOperation_ThrowIfNotExtensible));",
          "3308:                     idxDest = idxDest + 1;",
          "3309:                     if (!JavascriptNativeFloatArray::Is(pDestArray)) // SetItem could convert pDestArray to a var array if aItem is not an integer if so fall back",
          "3310:                     {",
          "3311:                         JS_REENTRANT(jsReentLock, ConcatArgs<uint>(pDestArray, remoteTypeIds, args, scriptContext, idxArg + 1, idxDest));",
          "3312:                         return pDestArray;",
          "3313:                     }",
          "3314:                     continue;",
          "3315:                 }",
          "3316:             }",
          "3318:             bool converted;",
          "3319:             if (JavascriptArray::IsAnyArray(aItem) || remoteTypeIds[idxArg] == TypeIds_Array)",
          "3320:             {",
          "3321:                 if (JavascriptNativeIntArray::Is(aItem)) // Fast path",
          "3322:                 {",
          "3323:                     JavascriptNativeIntArray *pIntArray = JavascriptNativeIntArray::FromVar(aItem);",
          "3325:                     JS_REENTRANT(jsReentLock, converted = CopyNativeIntArrayElementsToFloat(pDestArray, idxDest, pIntArray));",
          "3327:                     idxDest = idxDest + pIntArray->length;",
          "3328:                 }",
          "3329:                 else if (JavascriptNativeFloatArray::Is(aItem))",
          "3330:                 {",
          "3331:                     JavascriptNativeFloatArray* pItemArray = JavascriptNativeFloatArray::FromVar(aItem);",
          "3333:                     JS_REENTRANT(jsReentLock, converted = CopyNativeFloatArrayElements(pDestArray, idxDest, pItemArray));",
          "3335:                     idxDest = idxDest + pItemArray->length;",
          "3336:                 }",
          "3337:                 else",
          "3338:                 {",
          "3339:                     JavascriptArray *pVarDestArray = JavascriptNativeFloatArray::ConvertToVarArray(pDestArray);",
          "3341:                     JS_REENTRANT(jsReentLock, ConcatArgs<uint>(pVarDestArray, remoteTypeIds, args, scriptContext, idxArg, idxDest, spreadableCheckedAndTrue));",
          "3343:                     return pVarDestArray;",
          "3344:                 }",
          "3346:                 if (converted)",
          "3347:                 {",
          "3351:                     JS_REENTRANT(jsReentLock, ConcatArgs<uint>(pDestArray, remoteTypeIds, args, scriptContext, idxArg + 1, idxDest));",
          "3353:                     return pDestArray;",
          "3354:                 }",
          "3355:             }",
          "3356:             else",
          "3357:             {",
          "3358:                 if (TaggedInt::Is(aItem))",
          "3359:                 {",
          "3360:                     pDestArray->DirectSetItemAt(idxDest, (double)TaggedInt::ToInt32(aItem));",
          "3361:                 }",
          "3362:                 else",
          "3363:                 {",
          "3364:                     Assert(JavascriptNumber::Is(aItem));",
          "3365:                     pDestArray->DirectSetItemAt(idxDest, JavascriptNumber::GetValue(aItem));",
          "3366:                 }",
          "3367:                 ++idxDest;",
          "3368:             }",
          "3369:         }",
          "3370:         if (pDestArray->GetLength() != idxDest)",
          "3371:         {",
          "3372:             pDestArray->SetLength(idxDest);",
          "3373:         }",
          "3375:         return pDestArray;",
          "3376:     }",
          "3378:     bool JavascriptArray::BoxConcatItem(Var aItem, uint idxArg, ScriptContext *scriptContext)",
          "3379:     {",
          "3380:         return idxArg == 0 && !JavascriptOperators::IsObject(aItem);",
          "3381:     }",
          "3383:     Var JavascriptArray::EntryConcat(RecyclableObject* function, CallInfo callInfo, ...)",
          "3384:     {",
          "3385:         PROBE_STACK(function->GetScriptContext(), Js::Constants::MinStackDefault);",
          "3387:         ARGUMENTS(args, callInfo);",
          "3388:         ScriptContext* scriptContext = function->GetScriptContext();",
          "3389:         JS_REENTRANCY_LOCK(jsReentLock, scriptContext->GetThreadContext());",
          "3391:         Assert(!(callInfo.Flags & CallFlags_New));",
          "3393:         if (args.Info.Count == 0)",
          "3394:         {",
          "3395:             JavascriptError::ThrowTypeError(scriptContext, JSERR_This_NullOrUndefined, _u(\"Array.prototype.concat\"));",
          "3396:         }",
          "3403:         uint32 cDestLength = 0;",
          "3404:         JavascriptArray * pDestArray = NULL;",
          "3406:         PROBE_STACK(function->GetScriptContext(), Js::Constants::MinStackDefault + (args.Info.Count * sizeof(TypeId*)));",
          "3407:         TypeId* remoteTypeIds = (TypeId*)_alloca(args.Info.Count * sizeof(TypeId*));",
          "3409:         bool isInt = true;",
          "3410:         bool isFloat = true;",
          "3411:         ::Math::RecordOverflowPolicy destLengthOverflow;",
          "3412:         for (uint idxArg = 0; idxArg < args.Info.Count; idxArg++)",
          "3413:         {",
          "3414:             Var aItem = args[idxArg];",
          "3415: #if ENABLE_COPYONACCESS_ARRAY",
          "3416:             JavascriptLibrary::CheckAndConvertCopyOnAccessNativeIntArray<Var>(aItem);",
          "3417: #endif",
          "3418:             if (DynamicObject::IsAnyArray(aItem)) // Get JavascriptArray or ES5Array length",
          "3419:             {",
          "3420:                 JavascriptArray * pItemArray = JavascriptArray::FromAnyArray(aItem);",
          "3421:                 if (isFloat)",
          "3422:                 {",
          "3423:                     if (!JavascriptNativeIntArray::Is(pItemArray))",
          "3424:                     {",
          "3425:                         isInt = false;",
          "3426:                         if (!JavascriptNativeFloatArray::Is(pItemArray))",
          "3427:                         {",
          "3428:                             isFloat = false;",
          "3429:                         }",
          "3430:                     }",
          "3431:                 }",
          "3432:                 cDestLength = UInt32Math::Add(cDestLength, pItemArray->GetLength(), destLengthOverflow);",
          "3433:             }",
          "3434:             else // Get remote array or object length",
          "3435:             {",
          "3438:                 if (JavascriptOperators::IsArray(aItem))",
          "3439:                 {",
          "3442:                     isInt = false;",
          "3443:                     isFloat = false;",
          "3444:                     if (!JavascriptProxy::Is(aItem))",
          "3445:                     {",
          "3446:                         if (scriptContext->GetConfig()->IsES6ToLengthEnabled())",
          "3447:                         {",
          "3448:                             JS_REENTRANT(jsReentLock,",
          "3449:                                 int64 len = JavascriptConversion::ToLength(JavascriptOperators::OP_GetLength(aItem, scriptContext), scriptContext));",
          "3451:                             cDestLength = UInt32Math::Add(cDestLength, len < MaxArrayLength ? (uint32)len : MaxArrayLength, destLengthOverflow);",
          "3452:                         }",
          "3453:                         else",
          "3454:                         {",
          "3455:                             JS_REENTRANT(jsReentLock,",
          "3456:                                 uint len = JavascriptConversion::ToUInt32(JavascriptOperators::OP_GetLength(aItem, scriptContext), scriptContext));",
          "3457:                             cDestLength = UInt32Math::Add(cDestLength, len, destLengthOverflow);",
          "3458:                         }",
          "3459:                     }",
          "3460:                     remoteTypeIds[idxArg] = TypeIds_Array; // Mark remote array, no matter remote JavascriptArray or ES5Array.",
          "3461:                 }",
          "3462:                 else",
          "3463:                 {",
          "3464:                     if (isFloat)",
          "3465:                     {",
          "3466:                         if (BoxConcatItem(aItem, idxArg, scriptContext))",
          "3467:                         {",
          "3469:                             isInt = false;",
          "3470:                             isFloat = false;",
          "3471:                         }",
          "3472:                         else if (!TaggedInt::Is(aItem))",
          "3473:                         {",
          "3474:                             if (!JavascriptNumber::Is(aItem))",
          "3475:                             {",
          "3476:                                 isInt = false;",
          "3477:                                 isFloat = false;",
          "3478:                             }",
          "3479:                             else if (isInt)",
          "3480:                             {",
          "3481:                                 int32 int32Value;",
          "3482:                                 if(!JavascriptNumber::TryGetInt32Value(JavascriptNumber::GetValue(aItem), &int32Value) ||",
          "3483:                                     SparseArraySegment<int32>::IsMissingItem(&int32Value))",
          "3484:                                 {",
          "3485:                                     isInt = false;",
          "3486:                                 }",
          "3487:                             }",
          "3488:                         }",
          "3489:                         else if(isInt)",
          "3490:                         {",
          "3491:                             int32 int32Value = TaggedInt::ToInt32(aItem);",
          "3492:                             if(SparseArraySegment<int32>::IsMissingItem(&int32Value))",
          "3493:                             {",
          "3494:                                 isInt = false;",
          "3495:                             }",
          "3496:                         }",
          "3497:                     }",
          "3499:                     remoteTypeIds[idxArg] = TypeIds_Limit;",
          "3500:                     cDestLength = UInt32Math::Add(cDestLength, 1, destLengthOverflow);",
          "3501:                 }",
          "3502:             }",
          "3503:         }",
          "3504:         if (destLengthOverflow.HasOverflowed())",
          "3505:         {",
          "3506:             cDestLength = MaxArrayLength;",
          "3507:             isInt = false;",
          "3508:             isFloat = false;",
          "3509:         }",
          "3514:         RecyclableObject* pDestObj = nullptr;",
          "3515:         bool isArray = false;",
          "3517:         JS_REENTRANT(jsReentLock, pDestObj = ArraySpeciesCreate(args[0], 0, scriptContext));",
          "3519:         if (pDestObj)",
          "3520:         {",
          "3521: #if ENABLE_COPYONACCESS_ARRAY",
          "3522:             JavascriptLibrary::CheckAndConvertCopyOnAccessNativeIntArray<Var>(pDestObj);",
          "3523: #endif",
          "3527:             if (isInt)",
          "3528:             {",
          "3529:                 if (JavascriptNativeIntArray::Is(pDestObj))",
          "3530:                 {",
          "3531:                     isArray = true;",
          "3532:                 }",
          "3533:                 else",
          "3534:                 {",
          "3535:                     isInt = false;",
          "3536:                     isFloat = JavascriptNativeFloatArray::Is(pDestObj);",
          "3537:                     isArray = JavascriptArray::Is(pDestObj);",
          "3538:                 }",
          "3539:             }",
          "3540:             else if (isFloat)",
          "3541:             {",
          "3542:                 if (JavascriptNativeIntArray::Is(pDestObj))",
          "3543:                 {",
          "3544:                     JavascriptNativeIntArray::ToNativeFloatArray(JavascriptNativeIntArray::FromVar(pDestObj));",
          "3545:                     isArray = true;",
          "3546:                 }",
          "3547:                 else",
          "3548:                 {",
          "3549:                     isFloat = JavascriptNativeFloatArray::Is(pDestObj);",
          "3550:                     isArray = JavascriptArray::Is(pDestObj);",
          "3551:                 }",
          "3552:             }",
          "3553:             else",
          "3554:             {",
          "3555:                 if (JavascriptNativeIntArray::Is(pDestObj))",
          "3556:                 {",
          "3557:                     JavascriptNativeIntArray::ToVarArray(JavascriptNativeIntArray::FromVar(pDestObj));",
          "3558:                     isArray = true;",
          "3559:                 }",
          "3560:                 else if (JavascriptNativeFloatArray::Is(pDestObj))",
          "3561:                 {",
          "3562:                     JavascriptNativeFloatArray::ToVarArray(JavascriptNativeFloatArray::FromVar(pDestObj));",
          "3563:                     isArray = true;",
          "3564:                 }",
          "3565:                 else",
          "3566:                 {",
          "3567:                     isArray = JavascriptArray::Is(pDestObj);",
          "3568:                 }",
          "3569:             }",
          "3571:         }",
          "3573:         if (pDestObj == nullptr || isArray)",
          "3574:         {",
          "3575:             if (isInt)",
          "3576:             {",
          "3577:                 JavascriptNativeIntArray *pIntArray = isArray ? JavascriptNativeIntArray::FromVar(pDestObj) : scriptContext->GetLibrary()->CreateNativeIntArray(cDestLength);",
          "3578:                 pIntArray->EnsureHead<int32>();",
          "3580:                 JS_REENTRANT(jsReentLock, pDestArray = ConcatIntArgs(pIntArray, remoteTypeIds, args, scriptContext));",
          "3581:             }",
          "3582:             else if (isFloat)",
          "3583:             {",
          "3584:                 JavascriptNativeFloatArray *pFArray = isArray ? JavascriptNativeFloatArray::FromVar(pDestObj) : scriptContext->GetLibrary()->CreateNativeFloatArray(cDestLength);",
          "3585:                 pFArray->EnsureHead<double>();",
          "3587:                 JS_REENTRANT(jsReentLock, pDestArray = ConcatFloatArgs(pFArray, remoteTypeIds, args, scriptContext));",
          "3588:             }",
          "3589:             else",
          "3590:             {",
          "3592:                 pDestArray = isArray ?  JavascriptArray::FromVar(pDestObj) : scriptContext->GetLibrary()->CreateArray(cDestLength);",
          "3594:                 pDestArray->EnsureHead<Var>();",
          "3596:                 JS_REENTRANT(jsReentLock, ConcatArgsCallingHelper(pDestArray, remoteTypeIds, args, scriptContext, destLengthOverflow));",
          "3597:             }",
          "3603: #ifdef VALIDATE_ARRAY",
          "3604:             pDestArray->ValidateArray();",
          "3605: #endif",
          "3607:             return pDestArray;",
          "3608:         }",
          "3610:         Assert(pDestObj);",
          "3611:         JS_REENTRANT(jsReentLock, ConcatArgsCallingHelper(pDestObj, remoteTypeIds, args, scriptContext, destLengthOverflow));",
          "3613:         return pDestObj;",
          "3614:     }",
          "3616:     void JavascriptArray::ConcatArgsCallingHelper(RecyclableObject* pDestObj, TypeId* remoteTypeIds, Js::Arguments& args, ScriptContext* scriptContext, ::Math::RecordOverflowPolicy &destLengthOverflow)",
          "3617:     {",
          "3618:         if (destLengthOverflow.HasOverflowed())",
          "3619:         {",
          "3620:             ConcatArgs<BigIndex>(pDestObj, remoteTypeIds, args, scriptContext);",
          "3621:         }",
          "3622:         else",
          "3623:         {",
          "3625:             ConcatArgs<uint32>(pDestObj, remoteTypeIds, args, scriptContext);",
          "3626:         }",
          "3627:     }",
          "3629:     template<typename T>",
          "3631:     {",
          "3632:         if (BoxConcatItem(aItem, idxArg, scriptContext))",
          "3633:         {",
          "3635:             RecyclableObject* pObj = nullptr;",
          "3636:             if (FALSE == JavascriptConversion::ToObject(aItem, scriptContext, &pObj))",
          "3637:             {",
          "3638:                 JavascriptError::ThrowTypeError(scriptContext, JSERR_This_NullOrUndefined, _u(\"Array.prototype.concat\"));",
          "3639:             }",
          "3640:             if (pDestArray)",
          "3641:             {",
          "3642:                 pDestArray->DirectSetItemAt(idxDest, pObj);",
          "3643:             }",
          "3644:             else",
          "3645:             {",
          "3646:                 SetArrayLikeObjects(pDestObj, idxDest, pObj);",
          "3647:             }",
          "3648:         }",
          "3649:         else",
          "3650:         {",
          "3651:             if (pDestArray)",
          "3652:             {",
          "3653:                 pDestArray->DirectSetItemAt(idxDest, aItem);",
          "3654:             }",
          "3655:             else",
          "3656:             {",
          "3657:                 SetArrayLikeObjects(pDestObj, idxDest, aItem);",
          "3658:             }",
          "3659:         }",
          "3660:     }",
          "3662:     int64 JavascriptArray::GetFromLastIndex(Var arg, int64 length, ScriptContext *scriptContext)",
          "3663:     {",
          "3664:         int64 fromIndex;",
          "3666:         if (TaggedInt::Is(arg))",
          "3667:         {",
          "3668:             int intValue = TaggedInt::ToInt32(arg);",
          "3670:             if (intValue >= 0)",
          "3671:             {",
          "3672:                 fromIndex = min<int64>(intValue, length - 1);",
          "3673:             }",
          "3674:             else if ((uint32)-intValue > length)",
          "3675:             {",
          "3676:                 return length;",
          "3677:             }",
          "3678:             else",
          "3679:             {",
          "3680:                 fromIndex = intValue + length;",
          "3681:             }",
          "3682:         }",
          "3683:         else",
          "3684:         {",
          "3685:             double value = JavascriptConversion::ToInteger(arg, scriptContext);",
          "3687:             if (value >= 0)",
          "3688:             {",
          "3689:                 fromIndex = (int64)min(value, (double)(length - 1));",
          "3690:             }",
          "3691:             else if (value + length < 0)",
          "3692:             {",
          "3693:                 return length;",
          "3694:             }",
          "3695:             else",
          "3696:             {",
          "3697:                 fromIndex = (int64)(value + length);",
          "3698:             }",
          "3699:         }",
          "3701:         return fromIndex;",
          "3702:     }",
          "3710:     template <bool includesAlgorithm>",
          "3711:     Var JavascriptArray::IndexOfHelper(Arguments const & args, ScriptContext *scriptContext)",
          "3712:     {",
          "3713:         JS_REENTRANCY_LOCK(jsReentLock, scriptContext->GetThreadContext());",
          "3715:         RecyclableObject* obj = nullptr;",
          "3716:         JavascriptArray* pArr = nullptr;",
          "3717:         BigIndex length;",
          "3718:         Var trueValue = scriptContext->GetLibrary()->GetTrue();",
          "3719:         Var falseValue = scriptContext->GetLibrary()->GetFalse();",
          "3721:         JS_REENTRANT(jsReentLock, TryGetArrayAndLength(args[0], scriptContext, _u(\"Array.prototype.indexOf\"), &pArr, &obj, &length));",
          "3723:         Var search;",
          "3724:         uint32 fromIndex = 0;",
          "3725:         uint64 fromIndex64 = 0;",
          "3730:         if ((pArr || TypedArrayBase::Is(obj)) && (length.IsSmallIndex() || length.IsUint32Max()))",
          "3731:         {",
          "3732:             uint32 len = length.IsUint32Max() ? MaxArrayLength : length.GetSmallIndex();",
          "3733:             JS_REENTRANT(jsReentLock, BOOL gotParam = GetParamForIndexOf(len, args, search, fromIndex, scriptContext));",
          "3734:             if (!gotParam)",
          "3735:             {",
          "3736:                 return includesAlgorithm ? falseValue : TaggedInt::ToVarUnchecked(-1);",
          "3737:             }",
          "3738:         }",
          "3739:         else if (length.IsSmallIndex())",
          "3740:         {",
          "3741:             JS_REENTRANT(jsReentLock, BOOL gotParam = GetParamForIndexOf(length.GetSmallIndex(), args, search, fromIndex, scriptContext));",
          "3742:             if (!gotParam)",
          "3743:             {",
          "3744:                 return includesAlgorithm ? falseValue : TaggedInt::ToVarUnchecked(-1);",
          "3745:             }",
          "3746:         }",
          "3747:         else",
          "3748:         {",
          "3749:             JS_REENTRANT(jsReentLock, BOOL gotParam = GetParamForIndexOf(length.GetBigIndex(), args, search, fromIndex64, scriptContext));",
          "3750:             if (!gotParam)",
          "3751:             {",
          "3752:                 return includesAlgorithm ? falseValue : TaggedInt::ToVarUnchecked(-1);",
          "3753:             }",
          "3754:         }",
          "3757:         if (pArr && !JavascriptArray::Is(obj))",
          "3758:         {",
          "3759:             AssertOrFailFastMsg(ES5Array::Is(obj), \"The array should have been converted to an ES5Array\");",
          "3760:             pArr = nullptr;",
          "3761:         }",
          "3763:         if (pArr)",
          "3764:         {",
          "3765:             if (length.IsSmallIndex() || length.IsUint32Max())",
          "3766:             {",
          "3767:                 uint32 len = length.IsUint32Max() ? MaxArrayLength : length.GetSmallIndex();",
          "3768:                 int32 index = pArr->HeadSegmentIndexOfHelper(search, fromIndex, len, includesAlgorithm, scriptContext);",
          "3772:                 if (index != -1 || fromIndex == -1)",
          "3773:                 {",
          "3774:                     if (includesAlgorithm)",
          "3775:                     {",
          "3777:                         return (index == -1) ? falseValue : trueValue;",
          "3778:                     }",
          "3779:                     else",
          "3780:                     {",
          "3782:                         return JavascriptNumber::ToVar(index, scriptContext);",
          "3783:                     }",
          "3784:                 }",
          "3787:                 switch (pArr->GetTypeId())",
          "3788:                 {",
          "3789:                 case Js::TypeIds_Array:",
          "3790:                 JS_REENTRANT_UNLOCK(jsReentLock, return TemplatedIndexOfHelper<includesAlgorithm>(pArr, search, fromIndex, len, scriptContext));",
          "3791:                 case Js::TypeIds_NativeIntArray:",
          "3792:                 JS_REENTRANT_UNLOCK(jsReentLock, return TemplatedIndexOfHelper<includesAlgorithm>(JavascriptNativeIntArray::FromVar(pArr), search, fromIndex, len, scriptContext));",
          "3793:                 case Js::TypeIds_NativeFloatArray:",
          "3794:                 JS_REENTRANT_UNLOCK(jsReentLock, return TemplatedIndexOfHelper<includesAlgorithm>(JavascriptNativeFloatArray::FromVar(pArr), search, fromIndex, len, scriptContext));",
          "3795:                 default:",
          "3796:                     AssertMsg(FALSE, \"invalid array typeid\");",
          "3797:                 JS_REENTRANT_UNLOCK(jsReentLock, return TemplatedIndexOfHelper<includesAlgorithm>(pArr, search, fromIndex, len, scriptContext));",
          "3798:                 }",
          "3799:             }",
          "3800:         }",
          "3803:         if (TypedArrayBase::Is(obj))",
          "3804:         {",
          "3805:             if (length.IsSmallIndex() || length.IsUint32Max())",
          "3806:             {",
          "3807:                 JS_REENTRANT_UNLOCK(jsReentLock, return TemplatedIndexOfHelper<includesAlgorithm>(TypedArrayBase::FromVar(obj), search, fromIndex, length.GetSmallIndex(), scriptContext));",
          "3808:             }",
          "3809:         }",
          "3810:         if (length.IsSmallIndex())",
          "3811:         {",
          "3812:             JS_REENTRANT_UNLOCK(jsReentLock, return TemplatedIndexOfHelper<includesAlgorithm>(obj, search, fromIndex, length.GetSmallIndex(), scriptContext));",
          "3813:         }",
          "3814:         else",
          "3815:         {",
          "3816:             JS_REENTRANT_UNLOCK(jsReentLock, return TemplatedIndexOfHelper<includesAlgorithm>(obj, search, fromIndex64, length.GetBigIndex(), scriptContext));",
          "3817:         }",
          "3818:     }",
          "3821:     Var JavascriptArray::EntryIndexOf(RecyclableObject* function, CallInfo callInfo, ...)",
          "3822:     {",
          "3823:         PROBE_STACK(function->GetScriptContext(), Js::Constants::MinStackDefault);",
          "3825:         ARGUMENTS(args, callInfo);",
          "3826:         ScriptContext* scriptContext = function->GetScriptContext();",
          "3827:         JS_REENTRANCY_LOCK(jsReentLock, scriptContext->GetThreadContext());",
          "3829:         Assert(!(callInfo.Flags & CallFlags_New));",
          "3831:         CHAKRATEL_LANGSTATS_INC_BUILTINCOUNT(Array_Prototype_indexOf);",
          "3833:         JS_REENTRANT_UNLOCK(jsReentLock, Var returnValue =  IndexOfHelper<false>(args, scriptContext));",
          "3836:         Assert(returnValue != scriptContext->GetLibrary()->GetTrue() && returnValue != scriptContext->GetLibrary()->GetFalse());",
          "3838:         return returnValue;",
          "3839:     }",
          "3841:     Var JavascriptArray::EntryIncludes(RecyclableObject* function, CallInfo callInfo, ...)",
          "3842:     {",
          "3843:         PROBE_STACK(function->GetScriptContext(), Js::Constants::MinStackDefault);",
          "3845:         ARGUMENTS(args, callInfo);",
          "3846:         ScriptContext* scriptContext = function->GetScriptContext();",
          "3847:         JS_REENTRANCY_LOCK(jsReentLock, scriptContext->GetThreadContext());",
          "3849:         Assert(!(callInfo.Flags & CallFlags_New));",
          "3851:         CHAKRATEL_LANGSTATS_INC_BUILTINCOUNT(Array_Prototype_includes);",
          "3853:         JS_REENTRANT(jsReentLock, Var returnValue = IndexOfHelper<true>(args, scriptContext));",
          "3854:         Assert(returnValue == scriptContext->GetLibrary()->GetTrue() || returnValue == scriptContext->GetLibrary()->GetFalse());",
          "3856:         return returnValue;",
          "3857:     }",
          "3860:     template<typename T>",
          "3861:     BOOL JavascriptArray::GetParamForIndexOf(T length, Arguments const& args, Var& search, T& fromIndex, ScriptContext * scriptContext)",
          "3862:     {",
          "3863:         if (length == 0)",
          "3864:         {",
          "3865:             return false;",
          "3866:         }",
          "3868:         if (args.Info.Count > 2)",
          "3869:         {",
          "3870:             fromIndex = GetFromIndex(args[2], length, scriptContext);",
          "3871:             if (fromIndex >= length)",
          "3872:             {",
          "3873:                 return false;",
          "3874:             }",
          "3875:             search = args[1];",
          "3876:         }",
          "3877:         else",
          "3878:         {",
          "3879:             fromIndex = 0;",
          "3880:             search = args.Info.Count > 1 ? args[1] : scriptContext->GetLibrary()->GetUndefined();",
          "3881:         }",
          "3882:         return true;",
          "3883:     }",
          "3885:     template <>",
          "3886:     BOOL JavascriptArray::TemplatedGetItem(RecyclableObject * obj, uint32 index, Var * element, ScriptContext * scriptContext, bool checkHasItem)",
          "3887:     {",
          "3889:         Assert(!VirtualTableInfo<JavascriptArray>::HasVirtualTable(obj)",
          "3890:             && !VirtualTableInfo<JavascriptNativeIntArray>::HasVirtualTable(obj)",
          "3891:             && !VirtualTableInfo<JavascriptNativeFloatArray>::HasVirtualTable(obj));",
          "3892:         if (checkHasItem && !JavascriptOperators::HasItem(obj, index))",
          "3893:         {",
          "3894:             return FALSE;",
          "3895:         }",
          "3896:         return JavascriptOperators::GetItem(obj, index, element, scriptContext);",
          "3897:     }",
          "3899:     template <>",
          "3900:     BOOL JavascriptArray::TemplatedGetItem(RecyclableObject * obj, uint64 index, Var * element, ScriptContext * scriptContext, bool checkHasItem)",
          "3901:     {",
          "3903:         Assert(!VirtualTableInfo<JavascriptArray>::HasVirtualTable(obj)",
          "3904:             && !VirtualTableInfo<JavascriptNativeIntArray>::HasVirtualTable(obj)",
          "3905:             && !VirtualTableInfo<JavascriptNativeFloatArray>::HasVirtualTable(obj));",
          "3906:         PropertyRecord const * propertyRecord;",
          "3907:         JavascriptOperators::GetPropertyIdForInt(index, scriptContext, &propertyRecord);",
          "3909:         if (checkHasItem && !JavascriptOperators::HasProperty(obj, propertyRecord->GetPropertyId()))",
          "3910:         {",
          "3911:             return FALSE;",
          "3912:         }",
          "3915:         return *element != scriptContext->GetLibrary()->GetUndefined();",
          "3916:     }",
          "3918:     template <>",
          "3919:     BOOL JavascriptArray::TemplatedGetItem(JavascriptArray *pArr, uint32 index, Var * element, ScriptContext * scriptContext, bool checkHasItem)",
          "3920:     {",
          "3921:         Assert(VirtualTableInfo<JavascriptArray>::HasVirtualTable(pArr)",
          "3922:             || VirtualTableInfo<CrossSiteObject<JavascriptArray>>::HasVirtualTable(pArr));",
          "3923:         return pArr->JavascriptArray::DirectGetItemAtFull(index, element);",
          "3924:     }",
          "3925:     template <>",
          "3926:     BOOL JavascriptArray::TemplatedGetItem(JavascriptArray *pArr, uint64 index, Var * element, ScriptContext * scriptContext, bool checkHasItem)",
          "3927:     {",
          "3929:         Assert(false);",
          "3930:         Throw::InternalError();",
          "3931:     }",
          "3933:     template <>",
          "3934:     BOOL JavascriptArray::TemplatedGetItem(JavascriptNativeIntArray *pArr, uint32 index, Var * element, ScriptContext * scriptContext, bool checkHasItem)",
          "3935:     {",
          "3936:         Assert(VirtualTableInfo<JavascriptNativeIntArray>::HasVirtualTable(pArr)",
          "3937:             || VirtualTableInfo<CrossSiteObject<JavascriptNativeIntArray>>::HasVirtualTable(pArr));",
          "3938:         return pArr->JavascriptNativeIntArray::DirectGetItemAtFull(index, element);",
          "3939:     }",
          "3941:     template <>",
          "3942:     BOOL JavascriptArray::TemplatedGetItem(JavascriptNativeIntArray *pArr, uint64 index, Var * element, ScriptContext * scriptContext, bool checkHasItem)",
          "3943:     {",
          "3945:         Assert(false);",
          "3946:         Throw::InternalError();",
          "3947:     }",
          "3949:     template <>",
          "3950:     BOOL JavascriptArray::TemplatedGetItem(JavascriptNativeFloatArray *pArr, uint32 index, Var * element, ScriptContext * scriptContext, bool checkHasItem)",
          "3951:     {",
          "3952:         Assert(VirtualTableInfo<JavascriptNativeFloatArray>::HasVirtualTable(pArr)",
          "3953:             || VirtualTableInfo<CrossSiteObject<JavascriptNativeFloatArray>>::HasVirtualTable(pArr));",
          "3954:         return pArr->JavascriptNativeFloatArray::DirectGetItemAtFull(index, element);",
          "3955:     }",
          "3957:     template <>",
          "3958:     BOOL JavascriptArray::TemplatedGetItem(JavascriptNativeFloatArray *pArr, uint64 index, Var * element, ScriptContext * scriptContext, bool checkHasItem)",
          "3959:     {",
          "3961:         Assert(false);",
          "3962:         Throw::InternalError();",
          "3963:     }",
          "3965:     template <>",
          "3966:     BOOL JavascriptArray::TemplatedGetItem(TypedArrayBase * typedArrayBase, uint32 index, Var * element, ScriptContext * scriptContext, bool checkHasItem)",
          "3967:     {",
          "3972:         if (checkHasItem && !typedArrayBase->HasItem(index))",
          "3973:         {",
          "3974:             return false;",
          "3975:         }",
          "3978:         return true;",
          "3979:     }",
          "3981:     template <>",
          "3982:     BOOL JavascriptArray::TemplatedGetItem(TypedArrayBase * typedArrayBase, uint64 index, Var * element, ScriptContext * scriptContext, bool checkHasItem)",
          "3983:     {",
          "3985:         Assert(false);",
          "3986:         Throw::InternalError();",
          "3987:     }",
          "3989:     template <bool includesAlgorithm, typename T, typename P>",
          "3990:     Var JavascriptArray::TemplatedIndexOfHelper(T * pArr, Var search, P fromIndex, P toIndex, ScriptContext * scriptContext)",
          "3991:     {",
          "3992:         Var element = nullptr;",
          "3993:         bool isSearchTaggedInt = TaggedInt::Is(search);",
          "3994:         bool doUndefinedSearch = includesAlgorithm && JavascriptOperators::GetTypeId(search) == TypeIds_Undefined;",
          "3996:         Var trueValue = scriptContext->GetLibrary()->GetTrue();",
          "3997:         Var falseValue = scriptContext->GetLibrary()->GetFalse();",
          "4000:         for (P i = fromIndex; i < toIndex; i++)",
          "4001:         {",
          "4002:             if (!TryTemplatedGetItem(pArr, i, &element, scriptContext, !includesAlgorithm))",
          "4003:             {",
          "4004:                 if (doUndefinedSearch)",
          "4005:                 {",
          "4006:                     return trueValue;",
          "4007:                 }",
          "4008:                 continue;",
          "4009:             }",
          "4011:             if (isSearchTaggedInt && TaggedInt::Is(element))",
          "4012:             {",
          "4013:                 if (element == search)",
          "4014:                 {",
          "4015:                     return includesAlgorithm? trueValue : JavascriptNumber::ToVar(i, scriptContext);",
          "4016:                 }",
          "4017:                 continue;",
          "4018:             }",
          "4020:             if (includesAlgorithm)",
          "4021:             {",
          "4023:                 if (JavascriptConversion::SameValueZero(element, search))",
          "4024:                 {",
          "4025:                     return trueValue;",
          "4026:                 }",
          "4027:             }",
          "4028:             else",
          "4029:             {",
          "4031:                 if (JavascriptOperators::StrictEqual(element, search, scriptContext))",
          "4032:                 {",
          "4033:                     return JavascriptNumber::ToVar(i, scriptContext);",
          "4034:                 }",
          "4035:             }",
          "4036:         }",
          "4038:         return includesAlgorithm ? falseValue :  TaggedInt::ToVarUnchecked(-1);",
          "4039:     }",
          "4041:     int32 JavascriptArray::HeadSegmentIndexOfHelper(Var search, uint32 &fromIndex, uint32 toIndex, bool includesAlgorithm, ScriptContext * scriptContext)",
          "4042:     {",
          "4043:         Assert(Is(GetTypeId()) && !JavascriptNativeArray::Is(GetTypeId()));",
          "4045:         if (!HasNoMissingValues() || fromIndex >= GetHead()->length)",
          "4046:         {",
          "4047:             return -1;",
          "4048:         }",
          "4050:         bool isSearchTaggedInt = TaggedInt::Is(search);",
          "4054:         SparseArraySegment<Var>* head = static_cast<SparseArraySegment<Var>*>(GetHead());",
          "4055:         uint32 toIndexTrimmed = toIndex <= head->length ? toIndex : head->length;",
          "4056:         for (uint32 i = fromIndex; i < toIndexTrimmed; i++)",
          "4057:         {",
          "4058:             Var element = head->GetElement(i);",
          "4059:             if (isSearchTaggedInt && TaggedInt::Is(element))",
          "4060:             {",
          "4061:                 if (search == element)",
          "4062:                 {",
          "4063:                     return i;",
          "4064:                 }",
          "4065:             }",
          "4066:             else if (includesAlgorithm && JavascriptConversion::SameValueZero(element, search))",
          "4067:             {",
          "4069:                 return i;",
          "4070:             }",
          "4071:             else if (JavascriptOperators::StrictEqual(element, search, scriptContext))",
          "4072:             {",
          "4074:                 return i;",
          "4075:             }",
          "4076:         }",
          "4080:         fromIndex = toIndex > GetHead()->length ? GetHead()->length : -1;",
          "4081:         return -1;",
          "4082:     }",
          "4084:     template<typename T>",
          "4085:     bool AreAllBytesEqual(T value)",
          "4086:     {",
          "4087:         byte* bValue = (byte*)&value;",
          "4088:         byte firstByte = *bValue++;",
          "4089:         for (int i = 1; i < sizeof(T); ++i)",
          "4090:         {",
          "4091:             if (*bValue++ != firstByte)",
          "4092:             {",
          "4093:                 return false;",
          "4094:             }",
          "4095:         }",
          "4096:         return true;",
          "4097:     }",
          "4099:     template<>",
          "4100:     void JavascriptArray::CopyValueToSegmentBuferNoCheck(Field(double)* buffer, uint32 length, double value)",
          "4101:     {",
          "4102:         if (JavascriptNumber::IsZero(value) && !JavascriptNumber::IsNegZero(value))",
          "4103:         {",
          "4104:             memset(buffer, 0, sizeof(double) * length);",
          "4105:         }",
          "4106:         else",
          "4107:         {",
          "4108:             for (uint32 i = 0; i < length; i++)",
          "4109:             {",
          "4110:                 buffer[i] = value;",
          "4111:             }",
          "4112:         }",
          "4113:     }",
          "4115:     template<>",
          "4116:     void JavascriptArray::CopyValueToSegmentBuferNoCheck(Field(int32)* buffer, uint32 length, int32 value)",
          "4117:     {",
          "4118:         if (value == 0 || AreAllBytesEqual(value))",
          "4119:         {",
          "4120:             memset(buffer, *(byte*)&value, sizeof(int32)* length);",
          "4121:         }",
          "4122:         else",
          "4123:         {",
          "4124:             for (uint32 i = 0; i < length; i++)",
          "4125:             {",
          "4126:                 buffer[i] = value;",
          "4127:             }",
          "4128:         }",
          "4129:     }",
          "4131:     template<>",
          "4132:     void JavascriptArray::CopyValueToSegmentBuferNoCheck(Field(Js::Var)* buffer, uint32 length, Js::Var value)",
          "4133:     {",
          "4134:         for (uint32 i = 0; i < length; i++)",
          "4135:         {",
          "4136:             buffer[i] = value;",
          "4137:         }",
          "4138:     }",
          "4140:     int32 JavascriptNativeIntArray::HeadSegmentIndexOfHelper(Var search, uint32 &fromIndex, uint32 toIndex, bool includesAlgorithm,  ScriptContext * scriptContext)",
          "4141:     {",
          "4149:         if (!HasNoMissingValues() || fromIndex >= GetHead()->length)",
          "4150:         {",
          "4151:             return -1;",
          "4152:         }",
          "4154:         bool isSearchTaggedInt = TaggedInt::Is(search);",
          "4155:         if (!isSearchTaggedInt && !JavascriptNumber::Is_NoTaggedIntCheck(search))",
          "4156:         {",
          "4159:             fromIndex = toIndex > GetHead()->length ? GetHead()->length : -1;",
          "4160:             return -1;",
          "4161:         }",
          "4162:         int32 searchAsInt32;",
          "4163:         if (isSearchTaggedInt)",
          "4164:         {",
          "4165:             searchAsInt32 = TaggedInt::ToInt32(search);",
          "4166:         }",
          "4167:         else if (!JavascriptNumber::TryGetInt32Value<true>(JavascriptNumber::GetValue(search), &searchAsInt32))",
          "4168:         {",
          "4171:             fromIndex = toIndex > GetHead()->length ? GetHead()->length : -1;",
          "4172:             return -1;",
          "4173:         }",
          "4179:         SparseArraySegment<int32> * head = static_cast<SparseArraySegment<int32>*>(GetHead());",
          "4180:         uint32 toIndexTrimmed = toIndex <= head->length ? toIndex : head->length;",
          "4181:         for (uint32 i = fromIndex; i < toIndexTrimmed; i++)",
          "4182:         {",
          "4183:             int32 element = head->GetElement(i);",
          "4184:             if (searchAsInt32 == element)",
          "4185:             {",
          "4186:                 return i;",
          "4187:             }",
          "4188:         }",
          "4192:         fromIndex = toIndex > GetHead()->length ? GetHead()->length : -1;",
          "4193:         return -1;",
          "4194:     }",
          "4196:     int32 JavascriptNativeFloatArray::HeadSegmentIndexOfHelper(Var search, uint32 &fromIndex, uint32 toIndex, bool includesAlgorithm, ScriptContext * scriptContext)",
          "4197:     {",
          "4205:         if (!HasNoMissingValues() || fromIndex >= GetHead()->length)",
          "4206:         {",
          "4207:             return -1;",
          "4208:         }",
          "4210:         bool isSearchTaggedInt = TaggedInt::Is(search);",
          "4211:         if (!isSearchTaggedInt && !JavascriptNumber::Is_NoTaggedIntCheck(search))",
          "4212:         {",
          "4215:             fromIndex = toIndex > GetHead()->length ? GetHead()->length : -1;",
          "4216:             return -1;",
          "4217:         }",
          "4219:         double searchAsDouble = isSearchTaggedInt ? TaggedInt::ToDouble(search) : JavascriptNumber::GetValue(search);",
          "4226:         SparseArraySegment<double> * head = static_cast<SparseArraySegment<double>*>(GetHead());",
          "4227:         uint32 toIndexTrimmed = toIndex <= head->length ? toIndex : head->length;",
          "4229:         bool matchNaN = includesAlgorithm && JavascriptNumber::IsNan(searchAsDouble);",
          "4231:         for (uint32 i = fromIndex; i < toIndexTrimmed; i++)",
          "4232:         {",
          "4233:             double element = head->GetElement(i);",
          "4235:             if (element == searchAsDouble)",
          "4236:             {",
          "4237:                 return i;",
          "4238:             }",
          "4241:             if (matchNaN && JavascriptNumber::IsNan(element))",
          "4242:             {",
          "4243:                 return i;",
          "4244:             }",
          "4246:         }",
          "4248:         fromIndex = toIndex > GetHead()->length ? GetHead()->length : -1;",
          "4249:         return -1;",
          "4250:     }",
          "4252:     Var JavascriptArray::EntryJoin(RecyclableObject* function, CallInfo callInfo, ...)",
          "4253:     {",
          "4254:         PROBE_STACK(function->GetScriptContext(), Js::Constants::MinStackDefault);",
          "4256:         ARGUMENTS(args, callInfo);",
          "4257:         ScriptContext* scriptContext = function->GetScriptContext();",
          "4258:         JS_REENTRANCY_LOCK(jsReentLock, scriptContext->GetThreadContext());",
          "4260:         Assert(!(callInfo.Flags & CallFlags_New));",
          "4262:         if (args.Info.Count == 0)",
          "4263:         {",
          "4264:             JavascriptError::ThrowTypeError(scriptContext, JSERR_This_NullOrUndefined, _u(\"Array.prototype.join\"));",
          "4265:         }",
          "4267:         JavascriptString* separator;",
          "4268:         if (args.Info.Count >= 2)",
          "4269:         {",
          "4270:             TypeId typeId = JavascriptOperators::GetTypeId(args[1]);",
          "4272:             if (TypeIds_Undefined != typeId)",
          "4273:             {",
          "4274:                 JS_REENTRANT(jsReentLock, separator = JavascriptConversion::ToString(args[1], scriptContext));",
          "4275:             }",
          "4276:             else",
          "4277:             {",
          "4278:                 separator = scriptContext->GetLibrary()->GetCommaDisplayString();",
          "4279:             }",
          "4280:         }",
          "4281:         else",
          "4282:         {",
          "4283:             separator = scriptContext->GetLibrary()->GetCommaDisplayString();",
          "4284:         }",
          "4286:         JS_REENTRANT_UNLOCK(jsReentLock, return JoinHelper(args[0], separator, scriptContext));",
          "4287:     }",
          "4289:     JavascriptString* JavascriptArray::JoinToString(Var value, ScriptContext* scriptContext)",
          "4290:     {",
          "4291:         TypeId typeId = JavascriptOperators::GetTypeId(value);",
          "4292:         if (typeId == TypeIds_Null || typeId == TypeIds_Undefined)",
          "4293:         {",
          "4294:             return scriptContext->GetLibrary()->GetEmptyString();",
          "4295:         }",
          "4296:         else",
          "4297:         {",
          "4298:             return JavascriptConversion::ToString(value, scriptContext);",
          "4299:         }",
          "4300:     }",
          "4302:     JavascriptString* JavascriptArray::JoinHelper(Var thisArg, JavascriptString* separator, ScriptContext* scriptContext)",
          "4303:     {",
          "4304:         JS_REENTRANCY_LOCK(jsReentLock, scriptContext->GetThreadContext());",
          "4306:         bool isArray = JavascriptArray::Is(thisArg) && (scriptContext == JavascriptArray::FromVar(thisArg)->GetScriptContext());",
          "4307:         bool isProxy = JavascriptProxy::Is(thisArg) && (scriptContext == JavascriptProxy::FromVar(thisArg)->GetScriptContext());",
          "4308:         Var target = NULL;",
          "4309:         bool isTargetObjectPushed = false;",
          "4312:         if (isProxy)",
          "4313:         {",
          "4314:             JavascriptProxy* proxy = JavascriptProxy::FromVar(thisArg);",
          "4315:             Assert(proxy);",
          "4316:             target = proxy->GetTarget();",
          "4317:             if (target != nullptr)",
          "4318:             {",
          "4320:                 if (scriptContext->CheckObject(target))",
          "4321:                 {",
          "4322:                     return scriptContext->GetLibrary()->GetEmptyString();",
          "4323:                 }",
          "4324:                 else",
          "4325:                 {",
          "4326:                     scriptContext->PushObject(target);",
          "4327:                     isTargetObjectPushed = true;",
          "4328:                 }",
          "4329:             }",
          "4330:         }",
          "4332:         else if (scriptContext->CheckObject(thisArg))",
          "4333:         {",
          "4334:             return scriptContext->GetLibrary()->GetEmptyString();",
          "4335:         }",
          "4337:         if (!isTargetObjectPushed)",
          "4338:         {",
          "4339:             scriptContext->PushObject(thisArg);",
          "4340:         }",
          "4342:         JavascriptString* res = nullptr;",
          "4344:         TryFinally([&]()",
          "4345:         {",
          "4346:             if (isArray)",
          "4347:             {",
          "4348: #if ENABLE_COPYONACCESS_ARRAY",
          "4349:                 JavascriptLibrary::CheckAndConvertCopyOnAccessNativeIntArray(thisArg);",
          "4350: #endif",
          "4351:                 JavascriptArray * arr = JavascriptArray::FromVar(thisArg);",
          "4352:                 switch (arr->GetTypeId())",
          "4353:                 {",
          "4354:                 case Js::TypeIds_Array:",
          "4355:                     JS_REENTRANT(jsReentLock, res = JoinArrayHelper(arr, separator, scriptContext));",
          "4356:                     break;",
          "4357:                 case Js::TypeIds_NativeIntArray:",
          "4358:                     JS_REENTRANT(jsReentLock, res = JoinArrayHelper(JavascriptNativeIntArray::FromVar(arr), separator, scriptContext));",
          "4359:                     break;",
          "4360:                 case Js::TypeIds_NativeFloatArray:",
          "4361:                     JS_REENTRANT(jsReentLock, res = JoinArrayHelper(JavascriptNativeFloatArray::FromVar(arr), separator, scriptContext));",
          "4362:                     break;",
          "4363:                 }",
          "4365:             }",
          "4366:             else if (RecyclableObject::Is(thisArg))",
          "4367:             {",
          "4368:                 JS_REENTRANT(jsReentLock, res = JoinOtherHelper(RecyclableObject::FromVar(thisArg), separator, scriptContext));",
          "4369:             }",
          "4370:             else",
          "4371:             {",
          "4372:                 JS_REENTRANT(jsReentLock, res = JoinOtherHelper(scriptContext->GetLibrary()->CreateNumberObject(thisArg), separator, scriptContext));",
          "4373:             }",
          "4374:         },",
          "4375:         [&](bool/*hasException*/)",
          "4376:         {",
          "4377:             Var top = scriptContext->PopObject();",
          "4378:             if (isProxy)",
          "4379:             {",
          "4380:                 AssertMsg(top == target, \"Unmatched operation stack\");",
          "4381:             }",
          "4382:             else",
          "4383:             {",
          "4384:                 AssertMsg(top == thisArg, \"Unmatched operation stack\");",
          "4385:             }",
          "4386:         });",
          "4388:         if (res == nullptr)",
          "4389:         {",
          "4390:             res = scriptContext->GetLibrary()->GetEmptyString();",
          "4391:         }",
          "4393:         return res;",
          "4394:     }",
          "4396:     static const charcount_t Join_MaxEstimatedAppendCount = static_cast<charcount_t>((64 << 20) / sizeof(void *)); // 64 MB worth of pointers",
          "4398:     template <typename T>",
          "4399:     JavascriptString* JavascriptArray::JoinArrayHelper(T * arr, JavascriptString* separator, ScriptContext* scriptContext)",
          "4400:     {",
          "4401:         JS_REENTRANCY_LOCK(jsReentLock, scriptContext->GetThreadContext());",
          "4403:         Assert(VirtualTableInfo<T>::HasVirtualTable(arr) || VirtualTableInfo<CrossSiteObject<T>>::HasVirtualTable(arr));",
          "4404:         const uint32 arrLength = arr->length;",
          "4405:         switch(arrLength)",
          "4406:         {",
          "4407:             default:",
          "4408:             {",
          "4409: CaseDefault:",
          "4410:                 bool hasSeparator = (separator->GetLength() != 0);",
          "4411:                 const charcount_t estimatedAppendCount =",
          "4412:                     min(",
          "4413:                         Join_MaxEstimatedAppendCount,",
          "4414:                         static_cast<charcount_t>(arrLength + (hasSeparator ? arrLength - 1 : 0)));",
          "4415:                 CompoundString *const cs =",
          "4416:                     CompoundString::NewWithPointerCapacity(estimatedAppendCount, scriptContext->GetLibrary());",
          "4417:                 Var item;",
          "4418:                 BOOL gotItem;",
          "4419:                 JS_REENTRANT(jsReentLock, gotItem = TemplatedGetItem(arr, 0u, &item, scriptContext));",
          "4420:                 if (gotItem)",
          "4421:                 {",
          "4422:                     JS_REENTRANT(jsReentLock, cs->Append(JavascriptArray::JoinToString(item, scriptContext)));",
          "4423:                 }",
          "4425:                 for (uint32 i = 1; i < arrLength; i++)",
          "4426:                 {",
          "4427:                     if (hasSeparator)",
          "4428:                     {",
          "4429:                         cs->Append(separator);",
          "4430:                     }",
          "4432:                     JS_REENTRANT(jsReentLock, gotItem = TryTemplatedGetItem(arr, i, &item, scriptContext));",
          "4433:                     if (gotItem)",
          "4434:                     {",
          "4435:                         JS_REENTRANT(jsReentLock, cs->Append(JavascriptArray::JoinToString(item, scriptContext)));",
          "4436:                     }",
          "4437:                 }",
          "4438:                 return cs;",
          "4439:             }",
          "4441:             case 2:",
          "4442:             {",
          "4443:                 bool hasSeparator = (separator->GetLength() != 0);",
          "4444:                 BOOL gotItem;",
          "4445:                 if(hasSeparator)",
          "4446:                 {",
          "4447:                     goto CaseDefault;",
          "4448:                 }",
          "4450:                 JavascriptString *res = nullptr;",
          "4451:                 Var item;",
          "4453:                 JS_REENTRANT(jsReentLock, gotItem = TemplatedGetItem(arr, 0u, &item, scriptContext));",
          "4454:                 if (gotItem)",
          "4455:                 {",
          "4456:                     JS_REENTRANT(jsReentLock, res = JavascriptArray::JoinToString(item, scriptContext));",
          "4457:                 }",
          "4458:                 JS_REENTRANT(jsReentLock, gotItem = TryTemplatedGetItem(arr, 1u, &item, scriptContext));",
          "4459:                 if (gotItem)",
          "4460:                 {",
          "4461:                     JS_REENTRANT(jsReentLock, JavascriptString *const itemString = JavascriptArray::JoinToString(item, scriptContext));",
          "4462:                     return res ? ConcatString::New(res, itemString) : itemString;",
          "4463:                 }",
          "4465:                 if(res)",
          "4466:                 {",
          "4467:                     return res;",
          "4468:                 }",
          "4470:                 goto Case0;",
          "4471:             }",
          "4473:             case 1:",
          "4474:             {",
          "4475:                 Var item;",
          "4476:                 BOOL gotItem;",
          "4477:                 JS_REENTRANT(jsReentLock, gotItem = TemplatedGetItem(arr, 0u, &item, scriptContext));",
          "4478:                 if (gotItem)",
          "4479:                 {",
          "4480:                     JS_REENTRANT_UNLOCK(jsReentLock, return JavascriptArray::JoinToString(item, scriptContext));",
          "4481:                 }",
          "4483:             }",
          "4485:             case 0:",
          "4486: Case0:",
          "4487:                 return scriptContext->GetLibrary()->GetEmptyString();",
          "4488:         }",
          "4489:     }",
          "4491:     JavascriptString* JavascriptArray::JoinOtherHelper(RecyclableObject* object, JavascriptString* separator, ScriptContext* scriptContext)",
          "4492:     {",
          "4493:         JS_REENTRANCY_LOCK(jsReentLock, scriptContext->GetThreadContext());",
          "4498:         JS_REENTRANT(jsReentLock,",
          "4499:             int64 cSrcLength = (int64)OP_GetLength(object, scriptContext));",
          "4501:         switch (cSrcLength)",
          "4502:         {",
          "4503:             default:",
          "4504:             {",
          "4505: CaseDefault:",
          "4506:                 bool hasSeparator = (separator->GetLength() != 0);",
          "4507:                 BOOL gotItem;",
          "4508:                 const charcount_t estimatedAppendCount =",
          "4509:                     min(",
          "4510:                         Join_MaxEstimatedAppendCount,",
          "4511:                         static_cast<charcount_t>(cSrcLength + (hasSeparator ? cSrcLength - 1 : 0)));",
          "4512:                 CompoundString *const cs =",
          "4513:                     CompoundString::NewWithPointerCapacity(estimatedAppendCount, scriptContext->GetLibrary());",
          "4514:                 Var value;",
          "4515:                 JS_REENTRANT(jsReentLock, gotItem = JavascriptOperators::GetItem(object, 0u, &value, scriptContext));",
          "4516:                 if (gotItem)",
          "4517:                 {",
          "4518:                     JS_REENTRANT(jsReentLock, cs->Append(JavascriptArray::JoinToString(value, scriptContext)));",
          "4519:                 }",
          "4520:                 for (uint32 i = 1; i < cSrcLength; i++)",
          "4521:                 {",
          "4522:                     if (hasSeparator)",
          "4523:                     {",
          "4524:                         cs->Append(separator);",
          "4525:                     }",
          "4526:                     JS_REENTRANT(jsReentLock, gotItem = JavascriptOperators::GetItem(object, i, &value, scriptContext));",
          "4527:                     if (gotItem)",
          "4528:                     {",
          "4529:                         JS_REENTRANT(jsReentLock, cs->Append(JavascriptArray::JoinToString(value, scriptContext)));",
          "4530:                     }",
          "4531:                 }",
          "4532:                 return cs;",
          "4533:             }",
          "4535:             case 2:",
          "4536:             {",
          "4537:                 bool hasSeparator = (separator->GetLength() != 0);",
          "4538:                 BOOL gotItem;",
          "4539:                 if(hasSeparator)",
          "4540:                 {",
          "4541:                     goto CaseDefault;",
          "4542:                 }",
          "4544:                 JavascriptString *res = nullptr;",
          "4545:                 Var value;",
          "4546:                 JS_REENTRANT(jsReentLock, gotItem = JavascriptOperators::GetItem(object, 0u, &value, scriptContext));",
          "4547:                 if (gotItem)",
          "4548:                 {",
          "4549:                     JS_REENTRANT(jsReentLock, res = JavascriptArray::JoinToString(value, scriptContext));",
          "4550:                 }",
          "4551:                 JS_REENTRANT(jsReentLock, gotItem = JavascriptOperators::GetItem(object, 1u, &value, scriptContext));",
          "4552:                 if (gotItem)",
          "4553:                 {",
          "4554:                     JS_REENTRANT(jsReentLock, JavascriptString *const valueString = JavascriptArray::JoinToString(value, scriptContext));",
          "4555:                     return res ? ConcatString::New(res, valueString) : valueString;",
          "4556:                 }",
          "4557:                 if(res)",
          "4558:                 {",
          "4559:                     return res;",
          "4560:                 }",
          "4561:                 goto Case0;",
          "4562:             }",
          "4564:             case 1:",
          "4565:             {",
          "4566:                 Var value;",
          "4567:                 JS_REENTRANT(jsReentLock, BOOL gotItem = JavascriptOperators::GetItem(object, 0u, &value, scriptContext));",
          "4568:                 if (gotItem)",
          "4569:                 {",
          "4570:                     JS_REENTRANT_UNLOCK(jsReentLock, return JavascriptArray::JoinToString(value, scriptContext));",
          "4571:                 }",
          "4573:             }",
          "4575:             case 0:",
          "4576: Case0:",
          "4577:                 return scriptContext->GetLibrary()->GetEmptyString();",
          "4578:         }",
          "4579:     }",
          "4581:     Var JavascriptArray::EntryLastIndexOf(RecyclableObject* function, CallInfo callInfo, ...)",
          "4582:     {",
          "4583:         PROBE_STACK(function->GetScriptContext(), Js::Constants::MinStackDefault);",
          "4585:         ARGUMENTS(args, callInfo);",
          "4586:         ScriptContext* scriptContext = function->GetScriptContext();",
          "4587:         JS_REENTRANCY_LOCK(jsReentLock, scriptContext->GetThreadContext());",
          "4589:         CHAKRATEL_LANGSTATS_INC_BUILTINCOUNT(Array_Prototype_lastIndexOf);",
          "4591:         Assert(!(callInfo.Flags & CallFlags_New));",
          "4593:         int64 length;",
          "4594:         JavascriptArray * pArr = nullptr;",
          "4595:         RecyclableObject* obj = nullptr;",
          "4597:         JS_REENTRANT(jsReentLock, TryGetArrayAndLength(args[0], scriptContext, _u(\"Array.prototype.lastIndexOf\"), &pArr, &obj, &length));",
          "4599:         Var search;",
          "4600:         int64 fromIndex;",
          "4601:         JS_REENTRANT(jsReentLock,",
          "4602:             BOOL gotParam = GetParamForLastIndexOf(length, args, search, fromIndex, scriptContext));",
          "4603:         if (!gotParam)",
          "4604:         {",
          "4605:             return TaggedInt::ToVarUnchecked(-1);",
          "4606:         }",
          "4609:         if (pArr && !JavascriptArray::Is(obj))",
          "4610:         {",
          "4611:             AssertOrFailFastMsg(ES5Array::Is(obj), \"The array should have been converted to an ES5Array\");",
          "4612:             pArr = nullptr;",
          "4613:         }",
          "4615:         if (pArr)",
          "4616:         {",
          "4617:             switch (pArr->GetTypeId())",
          "4618:             {",
          "4619:             case Js::TypeIds_Array:",
          "4620:                 JS_REENTRANT_UNLOCK(jsReentLock, return LastIndexOfHelper(pArr, search, fromIndex, scriptContext));",
          "4621:             case Js::TypeIds_NativeIntArray:",
          "4622:                 JS_REENTRANT_UNLOCK(jsReentLock, return LastIndexOfHelper(JavascriptNativeIntArray::FromVar(pArr), search, fromIndex, scriptContext));",
          "4623:             case Js::TypeIds_NativeFloatArray:",
          "4624:                 JS_REENTRANT_UNLOCK(jsReentLock, return LastIndexOfHelper(JavascriptNativeFloatArray::FromVar(pArr), search, fromIndex, scriptContext));",
          "4625:             default:",
          "4626:                 AssertMsg(FALSE, \"invalid array typeid\");",
          "4627:                 JS_REENTRANT_UNLOCK(jsReentLock, return LastIndexOfHelper(pArr, search, fromIndex, scriptContext));",
          "4628:             }",
          "4629:         }",
          "4632:         if (TypedArrayBase::Is(obj))",
          "4633:         {",
          "4634:             JS_REENTRANT_UNLOCK(jsReentLock, return LastIndexOfHelper(TypedArrayBase::FromVar(obj), search, fromIndex, scriptContext));",
          "4635:         }",
          "4637:         JS_REENTRANT_UNLOCK(jsReentLock, return LastIndexOfHelper(obj, search, fromIndex, scriptContext));",
          "4638:     }",
          "4641:     BOOL JavascriptArray::GetParamForLastIndexOf(int64 length, Arguments const & args, Var& search, int64& fromIndex, ScriptContext * scriptContext)",
          "4642:     {",
          "4643:         if (length == 0)",
          "4644:         {",
          "4645:             return false;",
          "4646:         }",
          "4648:         if (args.Info.Count > 2)",
          "4649:         {",
          "4650:             fromIndex = GetFromLastIndex(args[2], length, scriptContext);",
          "4652:             if (fromIndex >= length)",
          "4653:             {",
          "4654:                 return false;",
          "4655:             }",
          "4656:             search = args[1];",
          "4657:         }",
          "4658:         else",
          "4659:         {",
          "4660:             search = args.Info.Count > 1 ? args[1] : scriptContext->GetLibrary()->GetUndefined();",
          "4661:             fromIndex = length - 1;",
          "4662:         }",
          "4663:         return true;",
          "4664:     }",
          "4666:     template <typename T>",
          "4667:     Var JavascriptArray::LastIndexOfHelper(T* pArr, Var search, int64 fromIndex, ScriptContext * scriptContext)",
          "4668:     {",
          "4669:         Var element = nullptr;",
          "4670:         bool isSearchTaggedInt = TaggedInt::Is(search);",
          "4673:         while (fromIndex >= MaxArrayLength)",
          "4674:         {",
          "4675:             Var index = JavascriptNumber::ToVar(fromIndex, scriptContext);",
          "4677:             if (JavascriptOperators::OP_HasItem(pArr, index, scriptContext))",
          "4678:             {",
          "4679:                 element = JavascriptOperators::OP_GetElementI(pArr, index, scriptContext);",
          "4681:                 if (isSearchTaggedInt && TaggedInt::Is(element))",
          "4682:                 {",
          "4683:                     if (element == search)",
          "4684:                     {",
          "4685:                         return index;",
          "4686:                     }",
          "4687:                     fromIndex--;",
          "4688:                     continue;",
          "4689:                 }",
          "4691:                 if (JavascriptOperators::StrictEqual(element, search, scriptContext))",
          "4692:                 {",
          "4693:                     return index;",
          "4694:                 }",
          "4695:             }",
          "4697:             fromIndex--;",
          "4698:         }",
          "4700:         Assert(fromIndex < MaxArrayLength);",
          "4703:         uint32 end = static_cast<uint32>(fromIndex);",
          "4705:         for (uint32 i = 0; i <= end; i++)",
          "4706:         {",
          "4707:             uint32 index = end - i;",
          "4709:             if (!TryTemplatedGetItem(pArr, index, &element, scriptContext))",
          "4710:             {",
          "4711:                 continue;",
          "4712:             }",
          "4714:             if (isSearchTaggedInt && TaggedInt::Is(element))",
          "4715:             {",
          "4716:                 if (element == search)",
          "4717:                 {",
          "4718:                     return JavascriptNumber::ToVar(index, scriptContext);",
          "4719:                 }",
          "4720:                 continue;",
          "4721:             }",
          "4723:             if (JavascriptOperators::StrictEqual(element, search, scriptContext))",
          "4724:             {",
          "4725:                 return JavascriptNumber::ToVar(index, scriptContext);",
          "4726:             }",
          "4727:         }",
          "4729:         return TaggedInt::ToVarUnchecked(-1);",
          "4730:     }",
          "4736:     void JavascriptNativeArray::PopWithNoDst(Var nativeArray)",
          "4737:     {",
          "4738:         Assert(JavascriptNativeArray::Is(nativeArray));",
          "4739:         JavascriptArray * arr = JavascriptArray::FromVar(nativeArray);",
          "4742:         Assert(arr->GetLength() != 0);",
          "4744:         uint32 index = arr->GetLength() - 1;",
          "4745:         arr->SetLength(index);",
          "4746:     }",
          "4756:     int32 JavascriptNativeIntArray::Pop(ScriptContext * scriptContext, Var object)",
          "4757:     {",
          "4758:         Assert(JavascriptNativeIntArray::Is(object));",
          "4759:         JavascriptNativeIntArray * arr = JavascriptNativeIntArray::FromVar(object);",
          "4761:         Assert(arr->GetLength() != 0);",
          "4763:         uint32 index = arr->length - 1;",
          "4765:         int32 element = Js::JavascriptOperators::OP_GetNativeIntElementI_UInt32(object, index, scriptContext);",
          "4768:         if(!SparseArraySegment<int32>::IsMissingItem(&element))",
          "4769:         {",
          "4770:             arr->SetLength(index);",
          "4771:         }",
          "4772:         return element;",
          "4773:     }",
          "4783:     double JavascriptNativeFloatArray::Pop(ScriptContext * scriptContext, Var object)",
          "4784:     {",
          "4785:         Assert(JavascriptNativeFloatArray::Is(object));",
          "4786:         JavascriptNativeFloatArray * arr = JavascriptNativeFloatArray::FromVar(object);",
          "4788:         Assert(arr->GetLength() != 0);",
          "4790:         uint32 index = arr->length - 1;",
          "4792:         double element = Js::JavascriptOperators::OP_GetNativeFloatElementI_UInt32(object, index, scriptContext);",
          "4795:         if(!SparseArraySegment<double>::IsMissingItem(&element))",
          "4796:         {",
          "4797:             arr->SetLength(index);",
          "4798:         }",
          "4799:         return element;",
          "4800:     }",
          "4807:     Var JavascriptArray::Pop(ScriptContext * scriptContext, Var object)",
          "4808:     {",
          "4809:         if (JavascriptArray::Is(object))",
          "4810:         {",
          "4811:             return EntryPopJavascriptArray(scriptContext, object);",
          "4812:         }",
          "4813:         else",
          "4814:         {",
          "4815:             return EntryPopNonJavascriptArray(scriptContext, object);",
          "4816:         }",
          "4817:     }",
          "4819:     Var JavascriptArray::EntryPopJavascriptArray(ScriptContext * scriptContext, Var object)",
          "4820:     {",
          "4821:         JS_REENTRANCY_LOCK(jsReentLock, scriptContext->GetThreadContext());",
          "4822:         JavascriptArray * arr = JavascriptArray::FromVar(object);",
          "4823:         uint32 length = arr->length;",
          "4825:         if (length == 0)",
          "4826:         {",
          "4828:             return scriptContext->GetLibrary()->GetUndefined();",
          "4829:         }",
          "4831:         uint32 index = length - 1;",
          "4832:         Var element;",
          "4833:         JS_REENTRANT(jsReentLock, BOOL gotItem = arr->DirectGetItemAtFull(index, &element));",
          "4835:         if (!gotItem)",
          "4836:         {",
          "4837:             element = scriptContext->GetLibrary()->GetUndefined();",
          "4838:         }",
          "4839:         else",
          "4840:         {",
          "4841:             element = CrossSite::MarshalVar(scriptContext, element);",
          "4842:         }",
          "4843:         arr->SetLength(index); // SetLength will clear element at index",
          "4845: #ifdef VALIDATE_ARRAY",
          "4846:         arr->ValidateArray();",
          "4847: #endif",
          "4848:         return element;",
          "4849:     }",
          "4851:     Var JavascriptArray::EntryPopNonJavascriptArray(ScriptContext * scriptContext, Var object)",
          "4852:     {",
          "4853:         JS_REENTRANCY_LOCK(jsReentLock, scriptContext->GetThreadContext());",
          "4854:         RecyclableObject* dynamicObject = nullptr;",
          "4855:         if (FALSE == JavascriptConversion::ToObject(object, scriptContext, &dynamicObject))",
          "4856:         {",
          "4857:             JavascriptError::ThrowTypeError(scriptContext, JSERR_This_NullOrUndefined, _u(\"Array.prototype.pop\"));",
          "4858:         }",
          "4859:         JS_REENTRANT(jsReentLock, BigIndex length = OP_GetLength(dynamicObject, scriptContext));",
          "4861:         ThrowTypeErrorOnFailureHelper h(scriptContext, _u(\"Array.prototype.pop\"));",
          "4862:         if (length == 0u)",
          "4863:         {",
          "4865:             JS_REENTRANT(jsReentLock,",
          "4866:                 h.ThrowTypeErrorOnFailure(JavascriptOperators::SetProperty(dynamicObject, dynamicObject, PropertyIds::length, TaggedInt::ToVarUnchecked(0), scriptContext, PropertyOperation_ThrowIfNotExtensible)));",
          "4867:             return scriptContext->GetLibrary()->GetUndefined();",
          "4868:         }",
          "4869:         BigIndex index = length;",
          "4870:         --index;",
          "4871:         Var element;",
          "4872:         if (index.IsSmallIndex())",
          "4873:         {",
          "4874:             JS_REENTRANT(jsReentLock, BOOL gotItem = JavascriptOperators::GetItem(dynamicObject, index.GetSmallIndex(), &element, scriptContext));",
          "4875:             if (!gotItem)",
          "4876:             {",
          "4877:                 element = scriptContext->GetLibrary()->GetUndefined();",
          "4878:             }",
          "4879:             JS_REENTRANT(jsReentLock,",
          "4880:                 h.ThrowTypeErrorOnFailure(JavascriptOperators::DeleteItem(dynamicObject, index.GetSmallIndex(), PropertyOperation_ThrowOnDeleteIfNotConfig)),",
          "4882:                 h.ThrowTypeErrorOnFailure(JavascriptOperators::SetProperty(dynamicObject, dynamicObject, PropertyIds::length, JavascriptNumber::ToVar(index.GetSmallIndex(), scriptContext), scriptContext, PropertyOperation_ThrowIfNotExtensible)));",
          "4883:         }",
          "4884:         else",
          "4885:         {",
          "4886:             JS_REENTRANT(jsReentLock, BOOL gotItem = JavascriptOperators::GetItem(dynamicObject, index.GetBigIndex(), &element, scriptContext));",
          "4887:             if (!gotItem)",
          "4888:             {",
          "4889:                 element = scriptContext->GetLibrary()->GetUndefined();",
          "4890:             }",
          "4891:             JS_REENTRANT(jsReentLock, h.ThrowTypeErrorOnFailure(JavascriptOperators::DeleteItem(dynamicObject, index.GetBigIndex(), PropertyOperation_ThrowOnDeleteIfNotConfig)),",
          "4893:                 h.ThrowTypeErrorOnFailure(JavascriptOperators::SetProperty(dynamicObject, dynamicObject, PropertyIds::length, JavascriptNumber::ToVar(index.GetBigIndex(), scriptContext), scriptContext, PropertyOperation_ThrowIfNotExtensible)));",
          "4894:         }",
          "4895:         return element;",
          "4896:     }",
          "4898:     Var JavascriptArray::EntryPop(RecyclableObject* function, CallInfo callInfo, ...)",
          "4899:     {",
          "4900:         PROBE_STACK(function->GetScriptContext(), Js::Constants::MinStackDefault);",
          "4902:         ARGUMENTS(args, callInfo);",
          "4903:         ScriptContext* scriptContext = function->GetScriptContext();",
          "4904:         JS_REENTRANCY_LOCK(jsReentLock, scriptContext->GetThreadContext());",
          "4906:         Assert(!(callInfo.Flags & CallFlags_New));",
          "4908:         if (args.Info.Count == 0)",
          "4909:         {",
          "4910:             JavascriptError::ThrowTypeError(scriptContext, JSERR_This_NullOrUndefined, _u(\"Array.prototype.pop\"));",
          "4911:         }",
          "4913:         if (JavascriptArray::Is(args[0]))",
          "4914:         {",
          "4915:             JS_REENTRANT_UNLOCK(jsReentLock, return EntryPopJavascriptArray(scriptContext, args.Values[0]));",
          "4916:         }",
          "4917:         else",
          "4918:         {",
          "4920:             JS_REENTRANT_UNLOCK(jsReentLock, return EntryPopNonJavascriptArray(scriptContext, args.Values[0]));",
          "4921:         }",
          "4922:     }",
          "4929:     Var JavascriptNativeIntArray::Push(ScriptContext * scriptContext, Var array, int value)",
          "4930:     {",
          "4933:         if (JavascriptNativeIntArray::IsNonCrossSite(array))",
          "4934:         {",
          "4935:             JavascriptNativeIntArray * nativeIntArray = JavascriptNativeIntArray::FromVar(array);",
          "4936:             Assert(!nativeIntArray->IsCrossSiteObject());",
          "4937:             uint32 n = nativeIntArray->length;",
          "4939:             if(n < JavascriptArray::MaxArrayLength)",
          "4940:             {",
          "4941:                 nativeIntArray->SetItem(n, value);",
          "4943:                 n++;",
          "4945:                 AssertMsg(n == nativeIntArray->length, \"Wrong update to the length of the native Int array\");",
          "4947:                 return JavascriptNumber::ToVar(n, scriptContext);",
          "4948:             }",
          "4949:         }",
          "4950:         return JavascriptArray::Push(scriptContext, array, JavascriptNumber::ToVar(value, scriptContext));",
          "4951:     }",
          "4958:     Var JavascriptNativeFloatArray::Push(ScriptContext * scriptContext, Var * array, double value)",
          "4959:     {",
          "4962:         if(JavascriptNativeFloatArray::IsNonCrossSite(array))",
          "4963:         {",
          "4964:             JavascriptNativeFloatArray * nativeFloatArray = JavascriptNativeFloatArray::FromVar(array);",
          "4965:             Assert(!nativeFloatArray->IsCrossSiteObject());",
          "4966:             uint32 n = nativeFloatArray->length;",
          "4968:             if(n < JavascriptArray::MaxArrayLength)",
          "4969:             {",
          "4970:                 nativeFloatArray->SetItem(n, value);",
          "4972:                 n++;",
          "4974:                 AssertMsg(n == nativeFloatArray->length, \"Wrong update to the length of the native Float array\");",
          "4975:                 return JavascriptNumber::ToVar(n, scriptContext);",
          "4976:             }",
          "4977:         }",
          "4979:         return JavascriptArray::Push(scriptContext, array, JavascriptNumber::ToVarNoCheck(value, scriptContext));",
          "4980:     }",
          "4986:     Var JavascriptArray::Push(ScriptContext * scriptContext, Var object, Var value)",
          "4987:     {",
          "4988:         Var args[2];",
          "4989:         args[0] = object;",
          "4990:         args[1] = value;",
          "4992:         if (JavascriptArray::Is(object))",
          "4993:         {",
          "4994:             return EntryPushJavascriptArray(scriptContext, args, 2);",
          "4995:         }",
          "4996:         else",
          "4997:         {",
          "4998:             return EntryPushNonJavascriptArray(scriptContext, args, 2);",
          "4999:         }",
          "5001:     }",
          "5007:     Var JavascriptArray::EntryPushNonJavascriptArray(ScriptContext * scriptContext, Var * args, uint argCount)",
          "5008:     {",
          "5009:         JS_REENTRANCY_LOCK(jsReentLock, scriptContext->GetThreadContext());",
          "5011:         RecyclableObject* obj = nullptr;",
          "5012:         if (FALSE == JavascriptConversion::ToObject(args[0], scriptContext, &obj))",
          "5013:         {",
          "5014:             JavascriptError::ThrowTypeError(scriptContext, JSERR_This_NullOrUndefined, _u(\"Array.prototype.push\"));",
          "5015:         }",
          "5017:         JS_REENTRANT_UNLOCK(jsReentLock, Var length = JavascriptOperators::OP_GetLength(obj, scriptContext));",
          "5018:         if(JavascriptOperators::GetTypeId(length) == TypeIds_Undefined && scriptContext->GetThreadContext()->IsDisableImplicitCall() &&",
          "5019:             scriptContext->GetThreadContext()->GetImplicitCallFlags() != Js::ImplicitCall_None)",
          "5020:         {",
          "5021:             return length;",
          "5022:         }",
          "5024:         ThrowTypeErrorOnFailureHelper h(scriptContext, _u(\"Array.prototype.push\"));",
          "5025:         BigIndex n;",
          "5026:         if (scriptContext->GetConfig()->IsES6ToLengthEnabled())",
          "5027:         {",
          "5028:             n = (uint64) JavascriptConversion::ToLength(length, scriptContext);",
          "5029:         }",
          "5030:         else",
          "5031:         {",
          "5032:             n = JavascriptConversion::ToUInt32(length, scriptContext);",
          "5033:         }",
          "5035:         uint index;",
          "5036:         for (index=1; index < argCount && n < JavascriptArray::MaxArrayLength; ++index, ++n)",
          "5037:         {",
          "5038:             JS_REENTRANT(jsReentLock,",
          "5039:                 BOOL setItem = JavascriptOperators::SetItem(obj, obj, n.GetSmallIndex(), args[index], scriptContext, PropertyOperation_ThrowIfNotExtensible));",
          "5040:             if (h.IsThrowTypeError(setItem))",
          "5041:             {",
          "5042:                 if (scriptContext->GetThreadContext()->RecordImplicitException())",
          "5043:                 {",
          "5044:                     h.ThrowTypeErrorOnFailure();",
          "5045:                 }",
          "5046:                 else",
          "5047:                 {",
          "5048:                     return nullptr;",
          "5049:                 }",
          "5050:             }",
          "5051:         }",
          "5054:         if (index < argCount)",
          "5055:         {",
          "5056:             BigIndex big = n;",
          "5058:             for (; index < argCount; ++index, ++big)",
          "5059:             {",
          "5060:                 JS_REENTRANT(jsReentLock, BOOL setItem = big.SetItem(obj, args[index], PropertyOperation_ThrowIfNotExtensible));",
          "5061:                 if (h.IsThrowTypeError(setItem))",
          "5062:                 {",
          "5063:                     if(scriptContext->GetThreadContext()->RecordImplicitException())",
          "5064:                     {",
          "5065:                         h.ThrowTypeErrorOnFailure();",
          "5066:                     }",
          "5067:                     else",
          "5068:                     {",
          "5069:                         return nullptr;",
          "5070:                     }",
          "5071:                 }",
          "5073:             }",
          "5076:             JS_REENTRANT(jsReentLock,",
          "5077:                 BOOL setLength = JavascriptOperators::SetProperty(obj, obj, PropertyIds::length, big.ToNumber(scriptContext), scriptContext, PropertyOperation_ThrowIfNotExtensible));",
          "5078:             if (h.IsThrowTypeError(setLength))",
          "5079:             {",
          "5080:                 if(scriptContext->GetThreadContext()->RecordImplicitException())",
          "5081:                 {",
          "5082:                     h.ThrowTypeErrorOnFailure();",
          "5083:                 }",
          "5084:                 else",
          "5085:                 {",
          "5086:                     return nullptr;",
          "5087:                 }",
          "5088:             }",
          "5090:             return big.ToNumber(scriptContext);",
          "5091:         }",
          "5092:         else",
          "5093:         {",
          "5095:             Var lengthAsNUmberVar = JavascriptNumber::ToVar(n.IsSmallIndex() ? n.GetSmallIndex() : n.GetBigIndex(), scriptContext);",
          "5096:             JS_REENTRANT(jsReentLock,",
          "5097:                 BOOL setLength = JavascriptOperators::SetProperty(obj, obj, PropertyIds::length, lengthAsNUmberVar, scriptContext, PropertyOperation_ThrowIfNotExtensible));",
          "5098:             if (h.IsThrowTypeError(setLength))",
          "5099:             {",
          "5100:                 if(scriptContext->GetThreadContext()->RecordImplicitException())",
          "5101:                 {",
          "5102:                     h.ThrowTypeErrorOnFailure();",
          "5103:                 }",
          "5104:                 else",
          "5105:                 {",
          "5106:                     return nullptr;",
          "5107:                 }",
          "5108:             }",
          "5110:             return lengthAsNUmberVar;",
          "5111:         }",
          "5112:     }",
          "5119:     Var JavascriptArray::EntryPushJavascriptArray(ScriptContext * scriptContext, Var * args, uint argCount)",
          "5120:     {",
          "5121:         JavascriptArray * arr = JavascriptArray::FromAnyArray(args[0]);",
          "5122:         uint n = arr->length;",
          "5123:         ThrowTypeErrorOnFailureHelper h(scriptContext, _u(\"Array.prototype.push\"));",
          "5126:         if (argCount == 2 && n < JavascriptArray::MaxArrayLength)",
          "5127:         {",
          "5129:             h.ThrowTypeErrorOnFailure(arr->SetItem(n, args[1], PropertyOperation_None));",
          "5130:             return JavascriptNumber::ToVar(n + 1, scriptContext);",
          "5131:         }",
          "5134:         if (JavascriptArray::MaxArrayLength - argCount + 1 > n && JavascriptArray::IsVarArray(arr) && scriptContext == arr->GetScriptContext())",
          "5135:         {",
          "5136:             uint index;",
          "5137:             for (index = 1; index < argCount; ++index, ++n)",
          "5138:             {",
          "5139:                 Assert(n != JavascriptArray::MaxArrayLength);",
          "5141:                 arr->JavascriptArray::DirectSetItemAt(n, args[index]);",
          "5142:             }",
          "5143:             return JavascriptNumber::ToVar(n, scriptContext);",
          "5144:         }",
          "5146:         return EntryPushJavascriptArrayNoFastPath(scriptContext, args, argCount);",
          "5147:     }",
          "5149:     Var JavascriptArray::EntryPushJavascriptArrayNoFastPath(ScriptContext * scriptContext, Var * args, uint argCount)",
          "5150:     {",
          "5151:         JS_REENTRANCY_LOCK(jsReentLock, scriptContext->GetThreadContext());",
          "5152:         JavascriptArray * arr = JavascriptArray::FromAnyArray(args[0]);",
          "5153:         uint n = arr->length;",
          "5154:         ThrowTypeErrorOnFailureHelper h(scriptContext, _u(\"Array.prototype.push\"));",
          "5157:         uint index;",
          "5158:         for (index = 1; index < argCount && n < JavascriptArray::MaxArrayLength; ++index, ++n)",
          "5159:         {",
          "5161:             h.ThrowTypeErrorOnFailure(arr->SetItem(n, args[index], PropertyOperation_None));",
          "5162:         }",
          "5165:         if (index < argCount)",
          "5166:         {",
          "5168:             arr = EnsureNonNativeArray(arr);",
          "5169:             Assert(n == JavascriptArray::MaxArrayLength);",
          "5170:             for (BigIndex big = n; index < argCount; ++index, ++big)",
          "5171:             {",
          "5172:                 JS_REENTRANT(jsReentLock, h.ThrowTypeErrorOnFailure(big.SetItem(arr, args[index])));",
          "5173:             }",
          "5175: #ifdef VALIDATE_ARRAY",
          "5176:             arr->ValidateArray();",
          "5177: #endif",
          "5179:             JavascriptError::ThrowRangeError(scriptContext, JSERR_ArrayLengthAssignIncorrect);",
          "5180:         }",
          "5182: #ifdef VALIDATE_ARRAY",
          "5183:         arr->ValidateArray();",
          "5184: #endif",
          "5185:         return JavascriptNumber::ToVar(n, scriptContext);",
          "5186:     }",
          "5192:     Var JavascriptArray::EntryPush(RecyclableObject* function, CallInfo callInfo, ...)",
          "5193:     {",
          "5194:         PROBE_STACK(function->GetScriptContext(), Js::Constants::MinStackDefault);",
          "5196:         ARGUMENTS(args, callInfo);",
          "5197:         ScriptContext* scriptContext = function->GetScriptContext();",
          "5198:         Assert(!(callInfo.Flags & CallFlags_New));",
          "5200:         if (args.Info.Count == 0)",
          "5201:         {",
          "5202:             JavascriptError::ThrowTypeError(scriptContext, JSERR_This_NullOrUndefined, _u(\"Array.prototype.push\"));",
          "5203:         }",
          "5205:         if (JavascriptArray::Is(args[0]))",
          "5206:         {",
          "5207:             return EntryPushJavascriptArray(scriptContext, args.Values, args.Info.Count);",
          "5208:         }",
          "5209:         else",
          "5210:         {",
          "5211:             return EntryPushNonJavascriptArray(scriptContext, args.Values, args.Info.Count);",
          "5212:         }",
          "5213:     }",
          "5216:     Var JavascriptArray::EntryReverse(RecyclableObject* function, CallInfo callInfo, ...)",
          "5217:     {",
          "5218:         PROBE_STACK(function->GetScriptContext(), Js::Constants::MinStackDefault);",
          "5220:         ARGUMENTS(args, callInfo);",
          "5221:         ScriptContext* scriptContext = function->GetScriptContext();",
          "5222:         JS_REENTRANCY_LOCK(jsReentLock, scriptContext->GetThreadContext());",
          "5224:         Assert(!(callInfo.Flags & CallFlags_New));",
          "5226:         if (args.Info.Count == 0)",
          "5227:         {",
          "5228:             JavascriptError::ThrowTypeError(scriptContext, JSERR_This_NullOrUndefined, _u(\"Array.prototype.reverse\"));",
          "5229:         }",
          "5231:         BigIndex length = 0u;",
          "5232:         JavascriptArray* pArr = nullptr;",
          "5233:         RecyclableObject* obj = nullptr;",
          "5235:         JS_REENTRANT(jsReentLock, TryGetArrayAndLength(args[0], scriptContext, _u(\"Array.prototype.reverse\"), &pArr, &obj, &length));",
          "5237:         if (length.IsSmallIndex())",
          "5238:         {",
          "5239:             JS_REENTRANT_UNLOCK(jsReentLock, return JavascriptArray::ReverseHelper(pArr, nullptr, obj, length.GetSmallIndex(), scriptContext));",
          "5240:         }",
          "5241:         Assert(pArr == nullptr || length.IsUint32Max()); // if pArr is not null lets make sure length is safe to cast, which will only happen if length is a uint32max",
          "5243:         JS_REENTRANT_UNLOCK(jsReentLock, return JavascriptArray::ReverseHelper(pArr, nullptr, obj, length.GetBigIndex(), scriptContext));",
          "5244:     }",
          "5247:     template <typename T>",
          "5248:     Var JavascriptArray::ReverseHelper(JavascriptArray* pArr, Js::TypedArrayBase* typedArrayBase, RecyclableObject* obj, T length, ScriptContext* scriptContext)",
          "5249:     {",
          "5250:         JS_REENTRANCY_LOCK(jsReentLock, scriptContext->GetThreadContext());",
          "5252:         T middle = length / 2;",
          "5253:         Var lowerValue = nullptr, upperValue = nullptr;",
          "5254:         T lowerExists, upperExists;",
          "5255:         const char16* methodName;",
          "5256:         bool isTypedArrayEntryPoint = typedArrayBase != nullptr;",
          "5258:         if (isTypedArrayEntryPoint)",
          "5259:         {",
          "5260:             methodName = _u(\"[TypedArray].prototype.reverse\");",
          "5261:         }",
          "5262:         else",
          "5263:         {",
          "5264:             methodName = _u(\"Array.prototype.reverse\");",
          "5265:         }",
          "5268:         if (!isTypedArrayEntryPoint && pArr == nullptr && TypedArrayBase::Is(obj))",
          "5269:         {",
          "5270:             typedArrayBase = TypedArrayBase::FromVar(obj);",
          "5271:         }",
          "5273:         ThrowTypeErrorOnFailureHelper h(scriptContext, methodName);",
          "5275:         if (pArr)",
          "5276:         {",
          "5277:             Recycler * recycler = scriptContext->GetRecycler();",
          "5279:             if (length <= 1)",
          "5280:             {",
          "5281:                 return pArr;",
          "5282:             }",
          "5284:             if (pArr->IsFillFromPrototypes())",
          "5285:             {",
          "5288:                 if (length % 2 == 0)",
          "5289:                 {",
          "5290:                     JS_REENTRANT(jsReentLock, pArr->FillFromPrototypes(0, (uint32)length));",
          "5291:                 }",
          "5292:                 else",
          "5293:                 {",
          "5294:                     middle = length / 2;",
          "5295:                     JS_REENTRANT(jsReentLock,",
          "5296:                         pArr->FillFromPrototypes(0, (uint32)middle),",
          "5297:                         pArr->FillFromPrototypes(1 + (uint32)middle, (uint32)length));",
          "5298:                 }",
          "5299:             }",
          "5301:             if (pArr->HasNoMissingValues() && pArr->head && pArr->head->next)",
          "5302:             {",
          "5304:                 pArr->SetHasNoMissingValues(false);",
          "5305:             }",
          "5310:             length = pArr->length;",
          "5312:             SparseArraySegmentBase* seg = pArr->head;",
          "5313:             SparseArraySegmentBase *prevSeg = nullptr;",
          "5314:             SparseArraySegmentBase *nextSeg = nullptr;",
          "5315:             SparseArraySegmentBase *pinPrevSeg = nullptr;",
          "5317:             bool isIntArray = false;",
          "5318:             bool isFloatArray = false;",
          "5320:             if (JavascriptNativeIntArray::Is(pArr))",
          "5321:             {",
          "5322:                 isIntArray = true;",
          "5323:             }",
          "5324:             else if (JavascriptNativeFloatArray::Is(pArr))",
          "5325:             {",
          "5326:                 isFloatArray = true;",
          "5327:             }",
          "5329:             while (seg)",
          "5330:             {",
          "5331:                 nextSeg = seg->next;",
          "5335:                 if (seg->length > 0)",
          "5336:                 {",
          "5337:                     if (isIntArray)",
          "5338:                     {",
          "5339:                         ((SparseArraySegment<int32>*)seg)->ReverseSegment(recycler);",
          "5340:                     }",
          "5341:                     else if (isFloatArray)",
          "5342:                     {",
          "5343:                         ((SparseArraySegment<double>*)seg)->ReverseSegment(recycler);",
          "5344:                     }",
          "5345:                     else",
          "5346:                     {",
          "5347:                         ((SparseArraySegment<Var>*)seg)->ReverseSegment(recycler);",
          "5348:                     }",
          "5350:                     seg->left = ((uint32)length) > (seg->left + seg->length) ? ((uint32)length) - (seg->left + seg->length) : 0;",
          "5352:                     seg->next = prevSeg;",
          "5355:                     seg->EnsureSizeInBound();",
          "5359:                     pinPrevSeg = prevSeg;",
          "5360:                     prevSeg = seg;",
          "5361:                 }",
          "5363:                 seg = nextSeg;",
          "5364:             }",
          "5366:             pArr->head = prevSeg;",
          "5369:             pArr->ClearSegmentMap();",
          "5371:             if (isIntArray)",
          "5372:             {",
          "5373:                 if (pArr->head && pArr->head->next && SparseArraySegmentBase::IsLeafSegment(pArr->head, recycler))",
          "5374:                 {",
          "5375:                     pArr->ReallocNonLeafSegment(SparseArraySegment<int32>::From(pArr->head), pArr->head->next);",
          "5376:                 }",
          "5377:                 pArr->EnsureHeadStartsFromZero<int32>(recycler);",
          "5378:             }",
          "5379:             else if (isFloatArray)",
          "5380:             {",
          "5381:                 if (pArr->head && pArr->head->next && SparseArraySegmentBase::IsLeafSegment(pArr->head, recycler))",
          "5382:                 {",
          "5383:                     pArr->ReallocNonLeafSegment(SparseArraySegment<double>::From(pArr->head), pArr->head->next);",
          "5384:                 }",
          "5385:                 pArr->EnsureHeadStartsFromZero<double>(recycler);",
          "5386:             }",
          "5387:             else",
          "5388:             {",
          "5389:                 pArr->EnsureHeadStartsFromZero<Var>(recycler);",
          "5390:             }",
          "5392:             pArr->InvalidateLastUsedSegment(); // lastUsedSegment might be 0-length and discarded above",
          "5394: #ifdef VALIDATE_ARRAY",
          "5395:             pArr->ValidateArray();",
          "5396: #endif",
          "5397:         }",
          "5398:         else if (typedArrayBase)",
          "5399:         {",
          "5400:             Assert(length <= JavascriptArray::MaxArrayLength);",
          "5401:             if (typedArrayBase->GetLength() == length)",
          "5402:             {",
          "5405:                 for (uint32 lower = 0; lower < (uint32)middle; lower++)",
          "5406:                 {",
          "5407:                     uint32 upper = (uint32)length - lower - 1;",
          "5409:                     lowerValue = typedArrayBase->DirectGetItem(lower);",
          "5410:                     upperValue = typedArrayBase->DirectGetItem(upper);",
          "5414:                     lowerExists = typedArrayBase->HasItem(lower);",
          "5415:                     upperExists = typedArrayBase->HasItem(upper);",
          "5417:                     JS_REENTRANT(jsReentLock,",
          "5418:                         h.ThrowTypeErrorOnFailure(typedArrayBase->DirectSetItem(lower, upperValue)),",
          "5419:                         h.ThrowTypeErrorOnFailure(typedArrayBase->DirectSetItem(upper, lowerValue)));",
          "5420:                 }",
          "5421:             }",
          "5422:             else",
          "5423:             {",
          "5424:                 Assert(middle <= UINT_MAX);",
          "5425:                 for (uint32 lower = 0; lower < (uint32)middle; lower++)",
          "5426:                 {",
          "5427:                     uint32 upper = (uint32)length - lower - 1;",
          "5429:                     lowerValue = typedArrayBase->DirectGetItem(lower);",
          "5430:                     upperValue = typedArrayBase->DirectGetItem(upper);",
          "5432:                     lowerExists = typedArrayBase->HasItem(lower);",
          "5433:                     upperExists = typedArrayBase->HasItem(upper);",
          "5435:                     if (lowerExists)",
          "5436:                     {",
          "5437:                         if (upperExists)",
          "5438:                         {",
          "5439:                             JS_REENTRANT(jsReentLock,",
          "5440:                                 h.ThrowTypeErrorOnFailure(typedArrayBase->DirectSetItem(lower, upperValue)),",
          "5441:                                 h.ThrowTypeErrorOnFailure(typedArrayBase->DirectSetItem(upper, lowerValue)));",
          "5442:                         }",
          "5443:                         else",
          "5444:                         {",
          "5446:                             h.ThrowTypeErrorOnFailure(typedArrayBase->DeleteItem(lower, PropertyOperation_ThrowOnDeleteIfNotConfig));",
          "5447:                             JS_REENTRANT(jsReentLock, h.ThrowTypeErrorOnFailure(typedArrayBase->DirectSetItem(upper, lowerValue)));",
          "5448:                         }",
          "5449:                     }",
          "5450:                     else",
          "5451:                     {",
          "5452:                         if (upperExists)",
          "5453:                         {",
          "5454:                             JS_REENTRANT(jsReentLock, h.ThrowTypeErrorOnFailure(typedArrayBase->DirectSetItem(lower, upperValue)));",
          "5456:                             h.ThrowTypeErrorOnFailure(typedArrayBase->DeleteItem(upper, PropertyOperation_ThrowOnDeleteIfNotConfig));",
          "5457:                         }",
          "5458:                     }",
          "5459:                 }",
          "5460:             }",
          "5461:         }",
          "5462:         else",
          "5463:         {",
          "5464:             for (T lower = 0; lower < middle; lower++)",
          "5465:             {",
          "5466:                 T upper = length - lower - 1;",
          "5468:                 JS_REENTRANT(jsReentLock,",
          "5469:                     lowerExists = JavascriptOperators::HasItem(obj, lower) && JavascriptOperators::GetItem(obj, lower, &lowerValue, scriptContext),",
          "5470:                     upperExists = JavascriptOperators::HasItem(obj, upper) && JavascriptOperators::GetItem(obj, upper, &upperValue, scriptContext));",
          "5472:                 if (lowerExists)",
          "5473:                 {",
          "5474:                     if (upperExists)",
          "5475:                     {",
          "5476:                         JS_REENTRANT(jsReentLock,",
          "5477:                             h.ThrowTypeErrorOnFailure(JavascriptOperators::SetItem(obj, obj, lower, upperValue, scriptContext, PropertyOperation_ThrowIfNotExtensible)),",
          "5478:                             h.ThrowTypeErrorOnFailure(JavascriptOperators::SetItem(obj, obj, upper, lowerValue, scriptContext, PropertyOperation_ThrowIfNotExtensible)));",
          "5479:                     }",
          "5480:                     else",
          "5481:                     {",
          "5482:                         JS_REENTRANT(jsReentLock,",
          "5483:                             h.ThrowTypeErrorOnFailure(JavascriptOperators::DeleteItem(obj, lower, PropertyOperation_ThrowOnDeleteIfNotConfig)),",
          "5484:                             h.ThrowTypeErrorOnFailure(JavascriptOperators::SetItem(obj, obj, upper, lowerValue, scriptContext, PropertyOperation_ThrowIfNotExtensible)));",
          "5485:                     }",
          "5486:                 }",
          "5487:                 else",
          "5488:                 {",
          "5489:                     if (upperExists)",
          "5490:                     {",
          "5491:                         JS_REENTRANT(jsReentLock,",
          "5492:                             h.ThrowTypeErrorOnFailure(JavascriptOperators::SetItem(obj, obj, lower, upperValue, scriptContext, PropertyOperation_ThrowIfNotExtensible)),",
          "5493:                             h.ThrowTypeErrorOnFailure(JavascriptOperators::DeleteItem(obj, upper, PropertyOperation_ThrowOnDeleteIfNotConfig)));",
          "5494:                     }",
          "5495:                 }",
          "5496:             }",
          "5497:         }",
          "5499:         return obj;",
          "5500:     }",
          "5502:     template<typename T>",
          "5503:     void JavascriptArray::ShiftHelper(JavascriptArray* pArr, ScriptContext * scriptContext)",
          "5504:     {",
          "5505:         Recycler * recycler = scriptContext->GetRecycler();",
          "5507:         SparseArraySegment<T>* next = SparseArraySegment<T>::From(pArr->head->next);",
          "5508:         while (next)",
          "5509:         {",
          "5510:             next->left--;",
          "5511:             next = SparseArraySegment<T>::From(next->next);",
          "5512:         }",
          "5515:         next = SparseArraySegment<T>::From(pArr->head->next);",
          "5516:         if (next && (pArr->head->size > next->left))",
          "5517:         {",
          "5518:             AssertMsg(pArr->head->left == 0, \"Array always points to a head starting at index 0\");",
          "5519:             AssertMsg(pArr->head->size == next->left + 1, \"Shift next->left overlaps current segment by more than 1 element\");",
          "5521:             SparseArraySegment<T> *head = SparseArraySegment<T>::From(pArr->head);",
          "5523:             if (next->length != 0)",
          "5524:             {",
          "5525:                 uint32 offset = head->size - 1;",
          "5529:                 if (next->next)",
          "5530:                 {",
          "5536:                     Assert(next->next->left >= head->size);",
          "5537:                     uint32 maxGrowSize = next->next->left - head->size;",
          "5538:                     if (maxGrowSize != 0)",
          "5539:                     {",
          "5540:                         head = head->GrowByMinMax(recycler, next->length - 1, maxGrowSize); //-1 is to account for unshift",
          "5541:                     }",
          "5542:                     else",
          "5543:                     {",
          "5545:                         Assert(next->length == 1);",
          "5546:                     }",
          "5547:                 }",
          "5548:                 else",
          "5549:                 {",
          "5550:                     head = head->GrowByMin(recycler, next->length - 1); //-1 is to account for unshift",
          "5551:                 }",
          "5552:                 MoveArray(head->elements + offset, next->elements, next->length);",
          "5553:                 head->length = offset + next->length;",
          "5554:                 pArr->head = head;",
          "5555:             }",
          "5556:             head->next = next->next;",
          "5557:             pArr->InvalidateLastUsedSegment();",
          "5558:         }",
          "5560: #ifdef VALIDATE_ARRAY",
          "5561:             pArr->ValidateArray();",
          "5562: #endif",
          "5563:     }",
          "5565:     Var JavascriptArray::EntryShift(RecyclableObject* function, CallInfo callInfo, ...)",
          "5566:     {",
          "5567:         PROBE_STACK(function->GetScriptContext(), Js::Constants::MinStackDefault);",
          "5569:         ARGUMENTS(args, callInfo);",
          "5570:         ScriptContext* scriptContext = function->GetScriptContext();",
          "5571:         JS_REENTRANCY_LOCK(jsReentLock, scriptContext->GetThreadContext());",
          "5573:         Assert(!(callInfo.Flags & CallFlags_New));",
          "5575:         Var res = scriptContext->GetLibrary()->GetUndefined();",
          "5577:         if (args.Info.Count == 0)",
          "5578:         {",
          "5579:             return res;",
          "5580:         }",
          "5581:         if (JavascriptArray::Is(args[0]))",
          "5582:         {",
          "5583:             JavascriptArray * pArr = JavascriptArray::FromVar(args[0]);",
          "5584: #if ENABLE_COPYONACCESS_ARRAY",
          "5585:             JavascriptLibrary::CheckAndConvertCopyOnAccessNativeIntArray<Var>(pArr);",
          "5586: #endif",
          "5588:             if (pArr->length == 0)",
          "5589:             {",
          "5590:                 return res;",
          "5591:             }",
          "5593:             if(pArr->IsFillFromPrototypes())",
          "5594:             {",
          "5595:                 JS_REENTRANT(jsReentLock, pArr->FillFromPrototypes(0, pArr->length)); // We need find all missing value from [[proto]] object",
          "5596:             }",
          "5598:             if(pArr->HasNoMissingValues() && pArr->head && pArr->head->next)",
          "5599:             {",
          "5601:                 pArr->SetHasNoMissingValues(false);",
          "5602:             }",
          "5604:             pArr->length--;",
          "5606:             pArr->ClearSegmentMap(); // Dump segmentMap on shift (before any allocation)",
          "5608:             Recycler * recycler = scriptContext->GetRecycler();",
          "5610:             bool isIntArray = false;",
          "5611:             bool isFloatArray = false;",
          "5613:             if(JavascriptNativeIntArray::Is(pArr))",
          "5614:             {",
          "5615:                 isIntArray = true;",
          "5616:             }",
          "5617:             else if(JavascriptNativeFloatArray::Is(pArr))",
          "5618:             {",
          "5619:                 isFloatArray = true;",
          "5620:             }",
          "5622:             if (pArr->head->length != 0)",
          "5623:             {",
          "5624:                 if(isIntArray)",
          "5625:                 {",
          "5626:                     int32 nativeResult = SparseArraySegment<int32>::From(pArr->head)->GetElement(0);",
          "5628:                     if(SparseArraySegment<int32>::IsMissingItem(&nativeResult))",
          "5629:                     {",
          "5630:                         res = scriptContext->GetLibrary()->GetUndefined();",
          "5631:                     }",
          "5632:                     else",
          "5633:                     {",
          "5634:                         res = Js::JavascriptNumber::ToVar(nativeResult, scriptContext);",
          "5635:                     }",
          "5636:                     SparseArraySegment<int32>::From(pArr->head)->RemoveElement(recycler, 0);",
          "5637:                 }",
          "5638:                 else if (isFloatArray)",
          "5639:                 {",
          "5640:                     double nativeResult = SparseArraySegment<double>::From(pArr->head)->GetElement(0);",
          "5642:                     if(SparseArraySegment<double>::IsMissingItem(&nativeResult))",
          "5643:                     {",
          "5644:                         res = scriptContext->GetLibrary()->GetUndefined();",
          "5645:                     }",
          "5646:                     else",
          "5647:                     {",
          "5648:                         res = Js::JavascriptNumber::ToVarNoCheck(nativeResult, scriptContext);",
          "5649:                     }",
          "5650:                     SparseArraySegment<double>::From(pArr->head)->RemoveElement(recycler, 0);",
          "5651:                 }",
          "5652:                 else",
          "5653:                 {",
          "5654:                     res = SparseArraySegment<Var>::From(pArr->head)->GetElement(0);",
          "5656:                     if(SparseArraySegment<Var>::IsMissingItem(&res))",
          "5657:                     {",
          "5658:                         res = scriptContext->GetLibrary()->GetUndefined();",
          "5659:                     }",
          "5660:                     else",
          "5661:                     {",
          "5662:                         res = CrossSite::MarshalVar(scriptContext, res);",
          "5663:                     }",
          "5664:                     SparseArraySegment<Var>::From(pArr->head)->RemoveElement(recycler, 0);",
          "5665:                 }",
          "5666:             }",
          "5668:             if(isIntArray)",
          "5669:             {",
          "5670:                 ShiftHelper<int32>(pArr, scriptContext);",
          "5671:             }",
          "5672:             else if (isFloatArray)",
          "5673:             {",
          "5674:                 ShiftHelper<double>(pArr, scriptContext);",
          "5675:             }",
          "5676:             else",
          "5677:             {",
          "5678:                 ShiftHelper<Var>(pArr, scriptContext);",
          "5679:             }",
          "5680:         }",
          "5681:         else",
          "5682:         {",
          "5683:             RecyclableObject* dynamicObject = nullptr;",
          "5684:             if (FALSE == JavascriptConversion::ToObject(args[0], scriptContext, &dynamicObject))",
          "5685:             {",
          "5686:                 JavascriptError::ThrowTypeError(scriptContext, JSERR_This_NullOrUndefined, _u(\"Array.prototype.shift\"));",
          "5687:             }",
          "5689:             ThrowTypeErrorOnFailureHelper h(scriptContext, _u(\"Array.prototype.shift\"));",
          "5691:             JS_REENTRANT(jsReentLock, BigIndex length = OP_GetLength(dynamicObject, scriptContext));",
          "5693:             if (length == 0u)",
          "5694:             {",
          "5696:                 JS_REENTRANT(jsReentLock,",
          "5697:                     h.ThrowTypeErrorOnFailure(JavascriptOperators::SetProperty(dynamicObject, dynamicObject, PropertyIds::length, TaggedInt::ToVarUnchecked(0), scriptContext, PropertyOperation_ThrowIfNotExtensible)));",
          "5698:                 return scriptContext->GetLibrary()->GetUndefined();",
          "5699:             }",
          "5701:             JS_REENTRANT(jsReentLock,",
          "5702:                 BOOL gotItem = JavascriptOperators::GetItem(dynamicObject, 0u, &res, scriptContext));",
          "5703:             if (!gotItem)",
          "5704:             {",
          "5705:                 res = scriptContext->GetLibrary()->GetUndefined();",
          "5706:             }",
          "5707:             --length;",
          "5708:             uint32 lengthToUin32Max = length.IsSmallIndex() ? length.GetSmallIndex() : MaxArrayLength;",
          "5709:             for (uint32 i = 0u; i < lengthToUin32Max; i++)",
          "5710:             {",
          "5711:                 JS_REENTRANT(jsReentLock, BOOL hasItem = JavascriptOperators::HasItem(dynamicObject, i + 1));",
          "5712:                 if (hasItem)",
          "5713:                 {",
          "5714:                     Var element = nullptr;",
          "5715:                     JS_REENTRANT(jsReentLock,",
          "5716:                         element = JavascriptOperators::GetItem(dynamicObject, i + 1, scriptContext),",
          "5717:                         h.ThrowTypeErrorOnFailure(JavascriptOperators::SetItem(dynamicObject, dynamicObject, i, element, scriptContext, PropertyOperation_ThrowIfNotExtensible, /*skipPrototypeCheck*/ true)));",
          "5718:                 }",
          "5719:                 else",
          "5720:                 {",
          "5721:                     JS_REENTRANT(jsReentLock, h.ThrowTypeErrorOnFailure(JavascriptOperators::DeleteItem(dynamicObject, i, PropertyOperation_ThrowOnDeleteIfNotConfig)));",
          "5722:                 }",
          "5723:             }",
          "5725:             for (uint64 i = MaxArrayLength; length > i; i++)",
          "5726:             {",
          "5727:                 JS_REENTRANT(jsReentLock, BOOL hasItem = JavascriptOperators::HasItem(dynamicObject, i + 1));",
          "5728:                 if (hasItem)",
          "5729:                 {",
          "5730:                     Var element = nullptr;",
          "5731:                     JS_REENTRANT(jsReentLock,",
          "5732:                         element = JavascriptOperators::GetItem(dynamicObject, i + 1, scriptContext),",
          "5733:                         h.ThrowTypeErrorOnFailure(JavascriptOperators::SetItem(dynamicObject, dynamicObject, i, element, scriptContext, PropertyOperation_ThrowIfNotExtensible)));",
          "5734:                 }",
          "5735:                 else",
          "5736:                 {",
          "5737:                     JS_REENTRANT(jsReentLock, h.ThrowTypeErrorOnFailure(JavascriptOperators::DeleteItem(dynamicObject, i, PropertyOperation_ThrowOnDeleteIfNotConfig)));",
          "5738:                 }",
          "5739:             }",
          "5741:             if (length.IsSmallIndex())",
          "5742:             {",
          "5743:                 JS_REENTRANT(jsReentLock,",
          "5744:                     h.ThrowTypeErrorOnFailure(JavascriptOperators::DeleteItem(dynamicObject, length.GetSmallIndex(), PropertyOperation_ThrowOnDeleteIfNotConfig)),",
          "5745:                     h.ThrowTypeErrorOnFailure(JavascriptOperators::SetProperty(dynamicObject, dynamicObject, PropertyIds::length, JavascriptNumber::ToVar(length.GetSmallIndex(), scriptContext), scriptContext, PropertyOperation_ThrowIfNotExtensible)));",
          "5746:             }",
          "5747:             else",
          "5748:             {",
          "5749:                 JS_REENTRANT(jsReentLock,",
          "5750:                     h.ThrowTypeErrorOnFailure(JavascriptOperators::DeleteItem(dynamicObject, length.GetBigIndex(), PropertyOperation_ThrowOnDeleteIfNotConfig)),",
          "5751:                     h.ThrowTypeErrorOnFailure(JavascriptOperators::SetProperty(dynamicObject, dynamicObject, PropertyIds::length, JavascriptNumber::ToVar(length.GetBigIndex(), scriptContext), scriptContext, PropertyOperation_ThrowIfNotExtensible)));",
          "5752:             }",
          "5753:         }",
          "5754:         return res;",
          "5755:     }",
          "5757:     Js::JavascriptArray* JavascriptArray::CreateNewArrayHelper(uint32 len, bool isIntArray, bool isFloatArray,  Js::JavascriptArray* baseArray, ScriptContext* scriptContext)",
          "5758:     {",
          "5759:         if (isIntArray)",
          "5760:         {",
          "5761:             Js::JavascriptNativeIntArray *pnewArr = scriptContext->GetLibrary()->CreateNativeIntArray(len);",
          "5762:             pnewArr->EnsureHead<int32>();",
          "5763: #if ENABLE_PROFILE_INFO",
          "5764:             pnewArr->CopyArrayProfileInfo(Js::JavascriptNativeIntArray::FromVar(baseArray));",
          "5765: #endif",
          "5767:             return pnewArr;",
          "5768:         }",
          "5769:         else if (isFloatArray)",
          "5770:         {",
          "5771:             Js::JavascriptNativeFloatArray *pnewArr  = scriptContext->GetLibrary()->CreateNativeFloatArray(len);",
          "5772:             pnewArr->EnsureHead<double>();",
          "5773: #if ENABLE_PROFILE_INFO",
          "5774:             pnewArr->CopyArrayProfileInfo(Js::JavascriptNativeFloatArray::FromVar(baseArray));",
          "5775: #endif",
          "5777:             return pnewArr;",
          "5778:         }",
          "5779:         else",
          "5780:         {",
          "5781:             JavascriptArray *pnewArr = pnewArr = scriptContext->GetLibrary()->CreateArray(len);",
          "5782:             pnewArr->EnsureHead<Var>();",
          "5783:             return pnewArr;",
          "5784:         }",
          "5785:    }",
          "5787:     template<typename T>",
          "5788:     void JavascriptArray::SliceHelper(JavascriptArray* pArr,  JavascriptArray* pnewArr, uint32 start, uint32 newLen)",
          "5789:     {",
          "5790:         JS_REENTRANCY_LOCK(jsReentLock, pArr->GetScriptContext()->GetThreadContext());",
          "5792:         SparseArraySegment<T>* headSeg = SparseArraySegment<T>::From(pArr->head);",
          "5793:         SparseArraySegment<T>* pnewHeadSeg = SparseArraySegment<T>::From(pnewArr->head);",
          "5796:         CopyArray(pnewHeadSeg->elements, newLen, headSeg->elements + start, newLen);",
          "5797:         pnewHeadSeg->length = newLen;",
          "5799:         Assert(pnewHeadSeg->length <= pnewHeadSeg->size);",
          "5801:         if (!pArr->HasNoMissingValues())",
          "5802:         {",
          "5803:             for (uint32 i = 0; i < newLen && (i + start) < pArr->length; i++)",
          "5804:             {",
          "5807:                 if (pArr->IsMissingItem(i + start))",
          "5808:                 {",
          "5809:                     Var element;",
          "5810:                     pnewArr->SetHasNoMissingValues(false);",
          "5811:                     JS_REENTRANT(jsReentLock, BOOL gotItem = pArr->DirectGetItemAtFull(i + start, &element));",
          "5812:                     if (gotItem)",
          "5813:                     {",
          "5814:                         JS_REENTRANT(jsReentLock, pnewArr->SetItem(i, element, PropertyOperation_None));",
          "5815:                     }",
          "5816:                 }",
          "5817:             }",
          "5818:         }",
          "5819: #ifdef DBG",
          "5820:         else",
          "5821:         {",
          "5822:             for (uint32 i = 0; i < newLen; i++)",
          "5823:             {",
          "5824:                 AssertMsg(!SparseArraySegment<T>::IsMissingItem(&headSeg->elements[i+start]), \"Array marked incorrectly as having missing value\");",
          "5825:             }",
          "5826:         }",
          "5827: #endif",
          "5828:     }",
          "5832:     void JavascriptArray::GetArrayTypeAndConvert(bool* isIntArray, bool* isFloatArray)",
          "5833:     {",
          "5834:         if (JavascriptNativeIntArray::Is(this))",
          "5835:         {",
          "5836: #if ENABLE_PROFILE_INFO",
          "5837:             JavascriptNativeIntArray* nativeIntArray = JavascriptNativeIntArray::FromVar(this);",
          "5838:             ArrayCallSiteInfo* info = nativeIntArray->GetArrayCallSiteInfo();",
          "5839:             if(!info || info->IsNativeIntArray())",
          "5840:             {",
          "5842:             }",
          "5843:             else if(info->IsNativeFloatArray())",
          "5844:             {",
          "5845:                 JavascriptNativeIntArray::ToNativeFloatArray(nativeIntArray);",
          "5847:             }",
          "5848:             else",
          "5849:             {",
          "5850:                 JavascriptNativeIntArray::ToVarArray(nativeIntArray);",
          "5851:             }",
          "5852: #else",
          "5854: #endif",
          "5855:         }",
          "5856:         else if (JavascriptNativeFloatArray::Is(this))",
          "5857:         {",
          "5858: #if ENABLE_PROFILE_INFO",
          "5859:             JavascriptNativeFloatArray* nativeFloatArray = JavascriptNativeFloatArray::FromVar(this);",
          "5860:             ArrayCallSiteInfo* info = nativeFloatArray->GetArrayCallSiteInfo();",
          "5862:             if(info && !info->IsNativeArray())",
          "5863:             {",
          "5864:                 JavascriptNativeFloatArray::ToVarArray(nativeFloatArray);",
          "5865:             }",
          "5866:             else",
          "5867:             {",
          "5869:             }",
          "5870: #else",
          "5872: #endif",
          "5873:         }",
          "5874:     }",
          "5876:     Var JavascriptArray::EntrySlice(RecyclableObject* function, CallInfo callInfo, ...)",
          "5877:     {",
          "5878:         PROBE_STACK(function->GetScriptContext(), Js::Constants::MinStackDefault);",
          "5880:         ARGUMENTS(args, callInfo);",
          "5881:         ScriptContext* scriptContext = function->GetScriptContext();",
          "5882:         JS_REENTRANCY_LOCK(jsReentLock, scriptContext->GetThreadContext());",
          "5884:         Assert(!(callInfo.Flags & CallFlags_New));",
          "5886:         Var res = scriptContext->GetLibrary()->GetUndefined();",
          "5888:         if (args.Info.Count == 0)",
          "5889:         {",
          "5890:             return res;",
          "5891:         }",
          "5893:         BigIndex length;",
          "5894:         JavascriptArray* pArr = nullptr;",
          "5895:         RecyclableObject* obj = nullptr;",
          "5897:         JS_REENTRANT(jsReentLock, TryGetArrayAndLength(args[0], scriptContext, _u(\"Array.prototype.slice\"), &pArr, &obj, &length));",
          "5899:         if (length.IsSmallIndex())",
          "5900:         {",
          "5901:             JS_REENTRANT_UNLOCK(jsReentLock, return JavascriptArray::SliceHelper(pArr, nullptr, obj, length.GetSmallIndex(), args, scriptContext));",
          "5902:         }",
          "5904:         Assert(pArr == nullptr || length.IsUint32Max());",
          "5905:         JS_REENTRANT_UNLOCK(jsReentLock, return JavascriptArray::SliceHelper(pArr, nullptr, obj, length.GetBigIndex(), args, scriptContext));",
          "5906:     }",
          "5909:     template <typename T>",
          "5910:     Var JavascriptArray::SliceHelper(JavascriptArray* pArr, Js::TypedArrayBase* typedArrayBase, RecyclableObject* obj, T length, Arguments& args, ScriptContext* scriptContext)",
          "5911:     {",
          "5912:         JS_REENTRANCY_LOCK(jsReentLock, scriptContext->GetThreadContext());",
          "5914:         JavascriptArray* newArr = nullptr;",
          "5915:         RecyclableObject* newObj = nullptr;",
          "5916:         bool isIntArray = false;",
          "5917:         bool isFloatArray = false;",
          "5918:         bool isTypedArrayEntryPoint = typedArrayBase != nullptr;",
          "5919:         bool isBuiltinArrayCtor = true;",
          "5920:         T startT = 0;",
          "5921:         T newLenT = length;",
          "5922:         T endT = length;",
          "5924: #if ENABLE_COPYONACCESS_ARRAY",
          "5925:         JavascriptLibrary::CheckAndConvertCopyOnAccessNativeIntArray<Var>(pArr);",
          "5926: #endif",
          "5927:         if (args.Info.Count > 1)",
          "5928:         {",
          "5929:             JS_REENTRANT(jsReentLock, startT = GetFromIndex(args[1], length, scriptContext));",
          "5931:             if (args.Info.Count > 2 && JavascriptOperators::GetTypeId(args[2]) != TypeIds_Undefined)",
          "5932:             {",
          "5933:                 JS_REENTRANT(jsReentLock, endT = GetFromIndex(args[2], length, scriptContext));",
          "5934:             }",
          "5936:             newLenT = endT > startT ? endT - startT : 0;",
          "5937:         }",
          "5940:         if (pArr && !JavascriptArray::Is(obj))",
          "5941:         {",
          "5942:             AssertOrFailFastMsg(ES5Array::Is(obj), \"The array should have been converted to an ES5Array\");",
          "5943:             pArr = nullptr;",
          "5944:         }",
          "5946:         if (TypedArrayBase::IsDetachedTypedArray(obj))",
          "5947:         {",
          "5948:             JavascriptError::ThrowTypeError(scriptContext, JSERR_DetachedTypedArray, _u(\"Array.prototype.slice\"));",
          "5949:         }",
          "5952:         if (!isTypedArrayEntryPoint && pArr == nullptr && TypedArrayBase::Is(obj))",
          "5953:         {",
          "5954:             typedArrayBase = TypedArrayBase::FromVar(obj);",
          "5955:         }",
          "5959:         if (isTypedArrayEntryPoint)",
          "5960:         {",
          "5961:             JS_REENTRANT(jsReentLock,",
          "5962:                 Var constructor = JavascriptOperators::SpeciesConstructor(typedArrayBase, TypedArrayBase::GetDefaultConstructor(args[0], scriptContext), scriptContext));",
          "5963:             isBuiltinArrayCtor = false;",
          "5965:             AssertAndFailFast(pArr == nullptr);",
          "5966:             Assert(JavascriptOperators::IsConstructor(constructor));",
          "5968:             Js::Var constructorArgs[] = { constructor, JavascriptNumber::ToVar(newLenT, scriptContext) };",
          "5969:             Js::CallInfo constructorCallInfo(Js::CallFlags_New, _countof(constructorArgs));",
          "5970:             JS_REENTRANT(jsReentLock, newObj = RecyclableObject::FromVar(TypedArrayBase::TypedArrayCreate(constructor, &Js::Arguments(constructorCallInfo, constructorArgs), (uint32)newLenT, scriptContext)));",
          "5971:         }",
          "5973:         else if (pArr != nullptr)",
          "5974:         {",
          "5975:             JS_REENTRANT(jsReentLock, newObj = ArraySpeciesCreate(pArr, newLenT, scriptContext, &isIntArray, &isFloatArray, &isBuiltinArrayCtor));",
          "5976:         }",
          "5979:         else",
          "5980:         {",
          "5981:             JS_REENTRANT(jsReentLock, newObj = ArraySpeciesCreate(obj, newLenT, scriptContext, nullptr, nullptr, &isBuiltinArrayCtor));",
          "5982:         }",
          "5986:         if (newObj == nullptr)",
          "5987:         {",
          "5988:             if (pArr)",
          "5989:             {",
          "5990:                 pArr->GetArrayTypeAndConvert(&isIntArray, &isFloatArray);",
          "5991:             }",
          "5993:             if (newLenT > JavascriptArray::MaxArrayLength)",
          "5994:             {",
          "5995:                 JavascriptError::ThrowRangeError(scriptContext, JSERR_ArrayLengthConstructIncorrect);",
          "5996:             }",
          "5998:             newArr = CreateNewArrayHelper(static_cast<uint32>(newLenT), isIntArray, isFloatArray, pArr, scriptContext);",
          "5999: #if ENABLE_COPYONACCESS_ARRAY",
          "6000:             JavascriptLibrary::CheckAndConvertCopyOnAccessNativeIntArray<Var>(newArr);",
          "6001: #endif",
          "6002:             newObj = newArr;",
          "6003:         }",
          "6004:         else",
          "6005:         {",
          "6007:             if (JavascriptArray::Is(newObj))",
          "6008:             {",
          "6009: #if ENABLE_COPYONACCESS_ARRAY",
          "6010:                 JavascriptLibrary::CheckAndConvertCopyOnAccessNativeIntArray<Var>(newObj);",
          "6011: #endif",
          "6012:                 newArr = JavascriptArray::FromVar(newObj);",
          "6013:             }",
          "6014:         }",
          "6016:         uint32 start  = (uint32) startT;",
          "6017:         uint32 newLen = (uint32) newLenT;",
          "6020:         Assert(newObj);",
          "6023:         if (newLen == 0)",
          "6024:         {",
          "6025:             return newObj;",
          "6026:         }",
          "6030:         if (pArr && !JavascriptArray::Is(obj))",
          "6031:         {",
          "6032:             AssertOrFailFastMsg(ES5Array::Is(obj), \"The array should have been converted to an ES5Array\");",
          "6033:             pArr = nullptr;",
          "6034:         }",
          "6036:         if (pArr)",
          "6037:         {",
          "6039:             if (newArr && isBuiltinArrayCtor)",
          "6040:             {",
          "6041:                 if (JavascriptArray::IsDirectAccessArray(newArr))",
          "6042:                 {",
          "6043:                     if (((start + newLen) <= pArr->head->length) && newLen <= newArr->head->size) //Fast Path",
          "6044:                     {",
          "6045:                         if (isIntArray)",
          "6046:                         {",
          "6047:                             JS_REENTRANT(jsReentLock, SliceHelper<int32>(pArr, newArr, start, newLen));",
          "6048:                         }",
          "6049:                         else if (isFloatArray)",
          "6050:                         {",
          "6051:                             JS_REENTRANT(jsReentLock, SliceHelper<double>(pArr, newArr, start, newLen));",
          "6052:                         }",
          "6053:                         else",
          "6054:                         {",
          "6055:                             JS_REENTRANT(jsReentLock, SliceHelper<Var>(pArr, newArr, start, newLen));",
          "6056:                         }",
          "6057:                     }",
          "6058:                     else",
          "6059:                     {",
          "6060:                         if (isIntArray)",
          "6061:                         {",
          "6062:                             JS_REENTRANT(jsReentLock, CopyNativeIntArrayElements(JavascriptNativeIntArray::FromVar(newArr), 0, JavascriptNativeIntArray::FromVar(pArr), start, start + newLen));",
          "6063:                         }",
          "6064:                         else if (isFloatArray)",
          "6065:                         {",
          "6066:                             JS_REENTRANT(jsReentLock, CopyNativeFloatArrayElements(JavascriptNativeFloatArray::FromVar(newArr), 0, JavascriptNativeFloatArray::FromVar(pArr), start, start + newLen));",
          "6067:                         }",
          "6068:                         else",
          "6069:                         {",
          "6070:                             JS_REENTRANT(jsReentLock, CopyArrayElements(newArr, 0u, pArr, start, start + newLen));",
          "6071:                         }",
          "6072:                     }",
          "6073:                 }",
          "6074:                 else",
          "6075:                 {",
          "6076:                     AssertMsg(CONFIG_FLAG(ForceES5Array), \"newArr can only be ES5Array when it is forced\");",
          "6077:                     Var element;",
          "6078:                     for (uint32 i = 0; i < newLen; i++)",
          "6079:                     {",
          "6080:                         JS_REENTRANT(jsReentLock, BOOL gotItem = pArr->DirectGetItemAtFull(i + start, &element));",
          "6081:                         if (!gotItem)",
          "6082:                         {",
          "6083:                             continue;",
          "6084:                         }",
          "6086:                         newArr->SetItem(i, element, PropertyOperation_None);",
          "6090:                         if (!JavascriptArray::Is(obj))",
          "6091:                         {",
          "6092:                             AssertOrFailFastMsg(ES5Array::Is(obj), \"The array should have been converted to an ES5Array\");",
          "6093:                             JS_REENTRANT_UNLOCK(jsReentLock, return JavascriptArray::SliceObjectHelper(obj, start, i + 1, newArr, newObj, newLen, scriptContext));",
          "6094:                         }",
          "6095:                     }",
          "6096:                 }",
          "6097:             }",
          "6098:             else",
          "6099:             {",
          "6101:                 Var element;",
          "6103:                 for (uint32 i = 0; i < newLen; i++)",
          "6104:                 {",
          "6105:                     JS_REENTRANT(jsReentLock, BOOL gotItem = pArr->DirectGetItemAtFull(i + start, &element));",
          "6106:                     if (!gotItem)",
          "6107:                     {",
          "6108:                         continue;",
          "6109:                     }",
          "6111:                     JS_REENTRANT(jsReentLock, ThrowErrorOnFailure(JavascriptArray::SetArrayLikeObjects(newObj, i, element), scriptContext, i));",
          "6115:                     if (!JavascriptArray::Is(obj))",
          "6116:                     {",
          "6117:                         AssertOrFailFastMsg(ES5Array::Is(obj), \"The array should have been converted to an ES5Array\");",
          "6118:                         JS_REENTRANT_UNLOCK(jsReentLock, return JavascriptArray::SliceObjectHelper(obj, start, i + 1, newArr, newObj, newLen, scriptContext));",
          "6119:                     }",
          "6120:                 }",
          "6121:             }",
          "6122:         }",
          "6123:         else if (typedArrayBase)",
          "6124:         {",
          "6125:             AssertAndFailFast(TypedArrayBase::Is(typedArrayBase));",
          "6128:             TypedArrayBase* newTypedArray = nullptr;",
          "6130:             if (TypedArrayBase::Is(newObj))",
          "6131:             {",
          "6132:                 newTypedArray = TypedArrayBase::FromVar(newObj);",
          "6133:             }",
          "6134:             else",
          "6135:             {",
          "6136:                 AssertAndFailFast(newArr != nullptr);",
          "6137:             }",
          "6139:             Var element;",
          "6141:             for (uint32 i = 0; i < newLen; i++)",
          "6142:             {",
          "6144:                 if (!isTypedArrayEntryPoint && !typedArrayBase->HasItem(i + start))",
          "6145:                 {",
          "6146:                     continue;",
          "6147:                 }",
          "6149:                 element = typedArrayBase->DirectGetItem(i + start);",
          "6152:                 if (newTypedArray)",
          "6153:                 {",
          "6154:                     JS_REENTRANT(jsReentLock, newTypedArray->DirectSetItem(i, element));",
          "6155:                 }",
          "6156:                 else",
          "6157:                 {",
          "6158:                     newArr->SetItem(i, element, PropertyOperation_None);",
          "6159:                 }",
          "6160:             }",
          "6161:         }",
          "6162:         else",
          "6163:         {",
          "6164:             JS_REENTRANT_UNLOCK(jsReentLock, return JavascriptArray::SliceObjectHelper(obj, start, 0u, newArr, newObj, newLen, scriptContext));;",
          "6165:         }",
          "6167:         if (!isTypedArrayEntryPoint)",
          "6168:         {",
          "6169:             JavascriptOperators::SetProperty(newObj, newObj, Js::PropertyIds::length, JavascriptNumber::ToVar(newLen, scriptContext), scriptContext, PropertyOperation_ThrowIfNotExtensible);",
          "6170:         }",
          "6172: #ifdef VALIDATE_ARRAY",
          "6173:         if (JavascriptArray::Is(newObj))",
          "6174:         {",
          "6175:             JavascriptArray::FromVar(newObj)->ValidateArray();",
          "6176:         }",
          "6177: #endif",
          "6179:         return newObj;",
          "6180:     }",
          "6182:     Var JavascriptArray::SliceObjectHelper(RecyclableObject* obj, uint32 sliceStart, uint32 start, JavascriptArray* newArr, RecyclableObject* newObj, uint32 newLen, ScriptContext* scriptContext)",
          "6183:     {",
          "6184:         JS_REENTRANCY_LOCK(jsReentLock, scriptContext->GetThreadContext());",
          "6186:         for (uint32 i = start; i < newLen; i++)",
          "6187:         {",
          "6188:             JS_REENTRANT(jsReentLock, BOOL hasItem = JavascriptOperators::HasItem(obj, i + sliceStart));",
          "6189:                 if (hasItem)",
          "6190:             {",
          "6191:                 JS_REENTRANT(jsReentLock, Var element = JavascriptOperators::GetItem(obj, i + sliceStart, scriptContext));",
          "6192:                 if (newArr != nullptr)",
          "6193:                 {",
          "6194:                     newArr->SetItem(i, element, PropertyOperation_None);",
          "6195:                 }",
          "6196:                 else",
          "6197:                 {",
          "6198:                         JS_REENTRANT(jsReentLock, ThrowErrorOnFailure(JavascriptArray::SetArrayLikeObjects(newObj, i, element), scriptContext, i));",
          "6199:                 }",
          "6200:             }",
          "6201:         }",
          "6203:             JS_REENTRANT(jsReentLock,",
          "6204:                 JavascriptOperators::SetProperty(newObj, newObj, Js::PropertyIds::length, JavascriptNumber::ToVar(newLen, scriptContext), scriptContext, PropertyOperation_ThrowIfNotExtensible));",
          "6206: #ifdef VALIDATE_ARRAY",
          "6207:         if (JavascriptArray::Is(newObj))",
          "6208:         {",
          "6209:             JavascriptArray::FromVar(newObj)->ValidateArray();",
          "6210:         }",
          "6211: #endif",
          "6213:         return newObj;",
          "6214:     }",
          "6216:     struct CompareVarsInfo",
          "6217:     {",
          "6218:         ScriptContext* scriptContext;",
          "6219:         RecyclableObject* compFn;",
          "6220:     };",
          "6222:     int __cdecl compareVars(void* cvInfoV, const void* aRef, const void* bRef)",
          "6223:     {",
          "6224:         CompareVarsInfo* cvInfo=(CompareVarsInfo*)cvInfoV;",
          "6225:         ScriptContext* requestContext=cvInfo->scriptContext;",
          "6226:         RecyclableObject* compFn=cvInfo->compFn;",
          "6228:         AssertMsg(*(Var*)aRef, \"No null expected in sort\");",
          "6229:         AssertMsg(*(Var*)bRef, \"No null expected in sort\");",
          "6231:         if (compFn != nullptr)",
          "6232:         {",
          "6233:             ScriptContext* scriptContext = compFn->GetScriptContext();",
          "6236:             CallFlags flags = CallFlags_Value;",
          "6237:             Var undefined = scriptContext->GetLibrary()->GetUndefined();",
          "6238:             Var retVal;",
          "6239:             if (requestContext != scriptContext)",
          "6240:             {",
          "6241:                 Var leftVar = CrossSite::MarshalVar(scriptContext, *(Var*)aRef);",
          "6242:                 Var rightVar = CrossSite::MarshalVar(scriptContext, *(Var*)bRef);",
          "6243:                 retVal = CALL_FUNCTION(scriptContext->GetThreadContext(), compFn, CallInfo(flags, 3), undefined, leftVar, rightVar);",
          "6244:             }",
          "6245:             else",
          "6246:             {",
          "6247:                 retVal = CALL_FUNCTION(scriptContext->GetThreadContext(), compFn, CallInfo(flags, 3), undefined, *(Var*)aRef, *(Var*)bRef);",
          "6248:             }",
          "6250:             if (TaggedInt::Is(retVal))",
          "6251:             {",
          "6252:                 return TaggedInt::ToInt32(retVal);",
          "6253:             }",
          "6254:             double dblResult;",
          "6255:             if (JavascriptNumber::Is_NoTaggedIntCheck(retVal))",
          "6256:             {",
          "6257:                 dblResult = JavascriptNumber::GetValue(retVal);",
          "6258:             }",
          "6259:             else",
          "6260:             {",
          "6261:                 dblResult = JavascriptConversion::ToNumber_Full(retVal, scriptContext);",
          "6262:             }",
          "6263:             if (dblResult < 0)",
          "6264:             {",
          "6265:                 return -1;",
          "6266:             }",
          "6267:             return (dblResult > 0) ? 1 : 0;",
          "6268:         }",
          "6269:         else",
          "6270:         {",
          "6271:             JavascriptString* pStr1 = JavascriptConversion::ToString(*(Var*)aRef, requestContext);",
          "6272:             JavascriptString* pStr2 = JavascriptConversion::ToString(*(Var*)bRef, requestContext);",
          "6274:             return JavascriptString::strcmp(pStr1, pStr2);",
          "6275:         }",
          "6276:     }",
          "6278:     static void hybridSort(__inout_ecount(length) Field(Var) *elements, uint32 length, CompareVarsInfo* compareInfo)",
          "6279:     {",
          "6282:         if (length > 512)",
          "6283:         {",
          "6284:             qsort_s(elements, length, compareVars, compareInfo);",
          "6285:             return;",
          "6286:         }",
          "6288:         for (int i = 1; i < (int)length; i++)",
          "6289:         {",
          "6290:             if (compareVars(compareInfo, elements + i, elements + i - 1) < 0) {",
          "6292:                 int first = 0;",
          "6293:                 int last = i - 1;",
          "6294:                 while (first <= last)",
          "6295:                 {",
          "6296:                     int middle = (first + last) / 2;",
          "6297:                     if (compareVars(compareInfo, elements + i, elements + middle) < 0)",
          "6298:                     {",
          "6299:                         last = middle - 1;",
          "6300:                     }",
          "6301:                     else",
          "6302:                     {",
          "6303:                         first = middle + 1;",
          "6304:                     }",
          "6305:                 }",
          "6308:                 Var value = elements[i];",
          "6309:                 MoveArray(elements + first + 1, elements + first, (i - first));",
          "6310:                 elements[first] = value;",
          "6311:             }",
          "6312:         }",
          "6313:     }",
          "6315:     void JavascriptArray::Sort(RecyclableObject* compFn)",
          "6316:     {",
          "6317:         JS_REENTRANCY_LOCK(jsReentLock, this->GetScriptContext()->GetThreadContext());",
          "6319:         if (length <= 1)",
          "6320:         {",
          "6321:             return;",
          "6322:         }",
          "6324:         this->EnsureHead<Var>();",
          "6325:         ScriptContext* scriptContext = this->GetScriptContext();",
          "6326:         Recycler* recycler = scriptContext->GetRecycler();",
          "6328:         CompareVarsInfo cvInfo;",
          "6329:         cvInfo.scriptContext = scriptContext;",
          "6330:         cvInfo.compFn = compFn;",
          "6332:         Assert(head != nullptr);",
          "6335:         ClearSegmentMap();",
          "6337:         uint32 countUndefined = 0;",
          "6338:         SparseArraySegment<Var>* startSeg = SparseArraySegment<Var>::From(head);",
          "6341:         uint32 saveLength = length;",
          "6343:         head = const_cast<SparseArraySegmentBase*>(EmptySegment);",
          "6344:         SetFlags(DynamicObjectFlags::None);",
          "6345:         this->InvalidateLastUsedSegment();",
          "6346:         length = 0;",
          "6348:         TryFinally([&]()",
          "6349:         {",
          "6351:             if (startSeg->next == nullptr) // Single segment fast path",
          "6352:             {",
          "6353:                 if (compFn != nullptr)",
          "6354:                 {",
          "6355:                     countUndefined = startSeg->RemoveUndefined(scriptContext);",
          "6357: #ifdef VALIDATE_ARRAY",
          "6358:                     ValidateSegment(startSeg);",
          "6359: #endif",
          "6360:                     JS_REENTRANT(jsReentLock, hybridSort(startSeg->elements, startSeg->length, &cvInfo));",
          "6361:                 }",
          "6362:                 else",
          "6363:                 {",
          "6364:                     JS_REENTRANT(jsReentLock, countUndefined = sort(startSeg->elements, &startSeg->length, scriptContext));",
          "6365:                 }",
          "6366:                 head = startSeg;",
          "6367:             }",
          "6368:             else",
          "6369:             {",
          "6370:                 SparseArraySegment<Var>* allElements = SparseArraySegment<Var>::AllocateSegment(recycler, 0, 0, nullptr);",
          "6371:                 SparseArraySegment<Var>* next = startSeg;",
          "6373:                 uint32 nextIndex = 0;",
          "6375:                 while (next)",
          "6376:                 {",
          "6377:                     countUndefined += next->RemoveUndefined(scriptContext);",
          "6378:                     if (next->length != 0)",
          "6379:                     {",
          "6380:                         allElements = SparseArraySegment<Var>::CopySegment(recycler, allElements, nextIndex, next, next->left, next->length);",
          "6381:                     }",
          "6382:                     next = SparseArraySegment<Var>::From(next->next);",
          "6383:                     nextIndex = allElements->length;",
          "6385: #ifdef VALIDATE_ARRAY",
          "6386:                     ValidateSegment(allElements);",
          "6387: #endif",
          "6388:                 }",
          "6390:                 if (compFn != nullptr)",
          "6391:                 {",
          "6392:                     JS_REENTRANT(jsReentLock, hybridSort(allElements->elements, allElements->length, &cvInfo));",
          "6393:                 }",
          "6394:                 else",
          "6395:                 {",
          "6396:                     JS_REENTRANT(jsReentLock, sort(allElements->elements, &allElements->length, scriptContext));",
          "6397:                 }",
          "6399:                 head = allElements;",
          "6400:                 head->next = nullptr;",
          "6401:             }",
          "6402:         },",
          "6403:         [&](bool hasException)",
          "6404:         {",
          "6405:             length = saveLength;",
          "6406:             ClearSegmentMap(); // Dump the segmentMap again in case user compare function rebuilds it",
          "6407:             if (hasException)",
          "6408:             {",
          "6409:                 head = startSeg;",
          "6410:                 this->InvalidateLastUsedSegment();",
          "6411:             }",
          "6412:         });",
          "6414: #if DEBUG",
          "6415:         {",
          "6416:             uint32 countNull = 0;",
          "6417:             uint32 index = head->length - 1;",
          "6418:             while (countNull < head->length)",
          "6419:             {",
          "6420:                 if (SparseArraySegment<Var>::From(head)->elements[index] != NULL)",
          "6421:                 {",
          "6422:                     break;",
          "6423:                 }",
          "6424:                 index--;",
          "6425:                 countNull++;",
          "6426:             }",
          "6427:             AssertMsg(countNull == 0, \"No null expected at the end\");",
          "6428:         }",
          "6429: #endif",
          "6431:         if (countUndefined != 0)",
          "6432:         {",
          "6434:             uint32 newLength = head->length + countUndefined;",
          "6435:             if (newLength > head->size)",
          "6436:             {",
          "6437:                 head = SparseArraySegment<Var>::From(head)->GrowByMin(recycler, newLength - head->size);",
          "6438:             }",
          "6440:             Var undefined = scriptContext->GetLibrary()->GetUndefined();",
          "6441:             for (uint32 i = head->length; i < newLength; i++)",
          "6442:             {",
          "6443:                 SparseArraySegment<Var>::From(head)->elements[i] = undefined;",
          "6444:             }",
          "6445:             head->length = newLength;",
          "6446:         }",
          "6447:         SetHasNoMissingValues();",
          "6448:         this->InvalidateLastUsedSegment();",
          "6450: #ifdef VALIDATE_ARRAY",
          "6451:         ValidateArray();",
          "6452: #endif",
          "6453:         return;",
          "6454:     }",
          "6456:     uint32 JavascriptArray::sort(__inout_ecount(*len) Field(Var) *orig, uint32 *len, ScriptContext *scriptContext)",
          "6457:     {",
          "6458:         uint32 count = 0, countUndefined = 0;",
          "6459:         Element *elements = RecyclerNewArrayZ(scriptContext->GetRecycler(), Element, *len);",
          "6460:         RecyclableObject *undefined = scriptContext->GetLibrary()->GetUndefined();",
          "6466:         for (uint32 i = 0; i < *len; ++i)",
          "6467:         {",
          "6468:             if (!SparseArraySegment<Var>::IsMissingItem(&orig[i]))",
          "6469:             {",
          "6470:                 if (!JavascriptOperators::IsUndefinedObject(orig[i], undefined))",
          "6471:                 {",
          "6472:                     elements[count].Value = orig[i];",
          "6473:                     elements[count].StringValue =  JavascriptConversion::ToString(orig[i], scriptContext);",
          "6475:                     count++;",
          "6476:                 }",
          "6477:                 else",
          "6478:                 {",
          "6479:                     countUndefined++;",
          "6480:                 }",
          "6481:             }",
          "6482:         }",
          "6484:         if (count > 0)",
          "6485:         {",
          "6486:             SortElements(elements, 0, count - 1);",
          "6488:             for (uint32 i = 0; i < count; ++i)",
          "6489:             {",
          "6490:                 orig[i] = elements[i].Value;",
          "6491:             }",
          "6492:         }",
          "6494:         for (uint32 i = count + countUndefined; i < *len; ++i)",
          "6495:         {",
          "6496:             orig[i] = SparseArraySegment<Var>::GetMissingItem();",
          "6497:         }",
          "6500:         return countUndefined;",
          "6501:     }",
          "6503:     int __cdecl JavascriptArray::CompareElements(void* context, const void* elem1, const void* elem2)",
          "6504:     {",
          "6505:         const Element* element1 = static_cast<const Element*>(elem1);",
          "6506:         const Element* element2 = static_cast<const Element*>(elem2);",
          "6508:         Assert(element1 != NULL);",
          "6509:         Assert(element2 != NULL);",
          "6511:         return JavascriptString::strcmp(element1->StringValue, element2->StringValue);",
          "6512:     }",
          "6514:     void JavascriptArray::SortElements(Element* elements, uint32 left, uint32 right)",
          "6515:     {",
          "6517:         qsort_s<Element, Field(Var)>(elements, right - left + 1, CompareElements, this);",
          "6518:     }",
          "6520:     Var JavascriptArray::EntrySort(RecyclableObject* function, CallInfo callInfo, ...)",
          "6521:     {",
          "6522:         PROBE_STACK(function->GetScriptContext(), Js::Constants::MinStackDefault);",
          "6524:         ARGUMENTS(args, callInfo);",
          "6525:         ScriptContext* scriptContext = function->GetScriptContext();",
          "6526:         JS_REENTRANCY_LOCK(jsReentLock, scriptContext->GetThreadContext());",
          "6527:         AUTO_TAG_NATIVE_LIBRARY_ENTRY(function, callInfo, _u(\"Array.prototype.sort\"));",
          "6529:         Assert(!(callInfo.Flags & CallFlags_New));",
          "6531:         AssertMsg(args.Info.Count >= 1, \"Should have at least one argument\");",
          "6533:         RecyclableObject* compFn = NULL;",
          "6534:         if (args.Info.Count > 1)",
          "6535:         {",
          "6536:             if (JavascriptConversion::IsCallable(args[1]))",
          "6537:             {",
          "6538:                 compFn = RecyclableObject::FromVar(args[1]);",
          "6539:             }",
          "6540:             else",
          "6541:             {",
          "6542:                 TypeId typeId = JavascriptOperators::GetTypeId(args[1]);",
          "6546:                 bool useDefaultComparer = typeId == TypeIds_Undefined;",
          "6547:                 if (!useDefaultComparer)",
          "6548:                 {",
          "6549:                     JavascriptError::ThrowTypeError(scriptContext, JSERR_FunctionArgument_NeedInternalObject, _u(\"Array.prototype.sort\"));",
          "6550:                 }",
          "6551:             }",
          "6552:         }",
          "6554:         if (JavascriptArray::Is(args[0]))",
          "6555:         {",
          "6556: #if ENABLE_COPYONACCESS_ARRAY",
          "6557:             JavascriptLibrary::CheckAndConvertCopyOnAccessNativeIntArray<Var>(args[0]);",
          "6558: #endif",
          "6560:             JavascriptArray *arr = JavascriptArray::FromVar(args[0]);",
          "6562:             if (arr->length <= 1)",
          "6563:             {",
          "6564:                 return args[0];",
          "6565:             }",
          "6567:             if(arr->IsFillFromPrototypes())",
          "6568:             {",
          "6569:                 JS_REENTRANT(jsReentLock, arr->FillFromPrototypes(0, arr->length)); // We need find all missing value from [[proto]] object",
          "6570:             }",
          "6577: #if defined(_M_X64_OR_ARM64)",
          "6578:             if(compFn && JavascriptNativeFloatArray::Is(arr))",
          "6579:             {",
          "6580:                 arr = JavascriptNativeFloatArray::ConvertToVarArray((JavascriptNativeFloatArray*)arr);",
          "6581:                 JS_REENTRANT(jsReentLock, arr->Sort(compFn));",
          "6582:                 arr = arr->ConvertToNativeArrayInPlace<JavascriptNativeFloatArray, double>(arr);",
          "6583:             }",
          "6584:             else",
          "6585:             {",
          "6586:                 EnsureNonNativeArray(arr);",
          "6587:                 JS_REENTRANT(jsReentLock, arr->Sort(compFn));",
          "6588:             }",
          "6589: #else",
          "6590:             if(compFn && JavascriptNativeIntArray::Is(arr))",
          "6591:             {",
          "6593:                 arr = JavascriptNativeIntArray::ConvertToVarArray((JavascriptNativeIntArray*)arr);",
          "6594:                 JS_REENTRANT(jsReentLock, arr->Sort(compFn));",
          "6595:                 arr = arr->ConvertToNativeArrayInPlace<JavascriptNativeIntArray, int32>(arr);",
          "6596:             }",
          "6597:             else",
          "6598:             {",
          "6599:                 EnsureNonNativeArray(arr);",
          "6600:                 JS_REENTRANT(jsReentLock, arr->Sort(compFn));",
          "6601:             }",
          "6602: #endif",
          "6604:         }",
          "6605:         else",
          "6606:         {",
          "6607:             RecyclableObject* pObj = nullptr;",
          "6608:             if (FALSE == JavascriptConversion::ToObject(args[0], scriptContext, &pObj))",
          "6609:             {",
          "6610:                 JavascriptError::ThrowTypeError(scriptContext, JSERR_This_NullOrUndefined, _u(\"Array.prototype.sort\"));",
          "6611:             }",
          "6612:             JS_REENTRANT(jsReentLock,",
          "6613:                 uint32 len = JavascriptConversion::ToUInt32(JavascriptOperators::OP_GetLength(pObj, scriptContext), scriptContext));",
          "6614:             JavascriptArray* sortArray = scriptContext->GetLibrary()->CreateArray(len);",
          "6615:             sortArray->EnsureHead<Var>();",
          "6616:             ThrowTypeErrorOnFailureHelper h(scriptContext, _u(\"Array.prototype.sort\"));",
          "6618:             BEGIN_TEMP_ALLOCATOR(tempAlloc, scriptContext, _u(\"Runtime\"))",
          "6619:             {",
          "6620:                 JsUtil::List<uint32, ArenaAllocator>* indexList = JsUtil::List<uint32, ArenaAllocator>::New(tempAlloc);",
          "6622:                 for (uint32 i = 0; i < len; i++)",
          "6623:                 {",
          "6624:                     Var item;",
          "6625:                     JS_REENTRANT(jsReentLock, BOOL gotItem = JavascriptOperators::GetItem(pObj, i, &item, scriptContext));",
          "6626:                     if (gotItem)",
          "6627:                     {",
          "6628:                         indexList->Add(i);",
          "6629:                         sortArray->DirectSetItemAt(i, item);",
          "6630:                     }",
          "6631:                 }",
          "6632:                 if (indexList->Count() > 0)",
          "6633:                 {",
          "6634:                     if (sortArray->length > 1)",
          "6635:                     {",
          "6636:                         sortArray->FillFromPrototypes(0, sortArray->length); // We need find all missing value from [[proto]] object",
          "6637:                     }",
          "6638:                     JS_REENTRANT(jsReentLock, sortArray->Sort(compFn));",
          "6640:                     uint32 removeIndex = sortArray->head->length;",
          "6641:                     for (uint32 i = 0; i < removeIndex; i++)",
          "6642:                     {",
          "6643:                         AssertMsg(!SparseArraySegment<Var>::IsMissingItem(&SparseArraySegment<Var>::From(sortArray->head)->elements[i]), \"No gaps expected in sorted array\");",
          "6644:                         JS_REENTRANT(jsReentLock, h.ThrowTypeErrorOnFailure(JavascriptOperators::SetItem(pObj, pObj, i, SparseArraySegment<Var>::From(sortArray->head)->elements[i], scriptContext)));",
          "6645:                     }",
          "6646:                     for (int i = 0; i < indexList->Count(); i++)",
          "6647:                     {",
          "6648:                         uint32 value = indexList->Item(i);",
          "6649:                         if (value >= removeIndex)",
          "6650:                         {",
          "6651:                             JS_REENTRANT(jsReentLock, h.ThrowTypeErrorOnFailure((JavascriptOperators::DeleteItem(pObj, value))));",
          "6652:                         }",
          "6653:                     }",
          "6654:                 }",
          "6656:             }",
          "6657:             END_TEMP_ALLOCATOR(tempAlloc, scriptContext);",
          "6658:         }",
          "6659:         return args[0];",
          "6660:     }",
          "6662:     Var JavascriptArray::EntrySplice(RecyclableObject* function, CallInfo callInfo, ...)",
          "6663:     {",
          "6664:         PROBE_STACK(function->GetScriptContext(), Js::Constants::MinStackDefault);",
          "6666:         ARGUMENTS(args, callInfo);",
          "6667:         ScriptContext* scriptContext = function->GetScriptContext();",
          "6668:         JS_REENTRANCY_LOCK(jsReentLock, scriptContext->GetThreadContext());",
          "6670:         Assert(!(callInfo.Flags & CallFlags_New));",
          "6672:         AssertMsg(args.Info.Count >= 1, \"Should have at least one argument\");",
          "6674:         JavascriptArray* pArr = 0;",
          "6675:         RecyclableObject* pObj = 0;",
          "6676:         uint64 start = 0u;",
          "6677:         uint64 deleteLen = 0u;",
          "6678:         uint64 length = 0u;",
          "6680:         JS_REENTRANT(jsReentLock, TryGetArrayAndLength(args[0], scriptContext, _u(\"Array.prototype.splice\"), &pArr, &pObj, &length));",
          "6682:         switch (args.Info.Count)",
          "6683:         {",
          "6684:         case 1:",
          "6685:             start = length;",
          "6686:             deleteLen = 0u;",
          "6687:             break;",
          "6689:         case 2:",
          "6690:             JS_REENTRANT(jsReentLock, start = GetFromIndex(args[1], length, scriptContext));",
          "6691:             deleteLen = length - start;",
          "6692:             break;",
          "6694:         default:",
          "6695:             JS_REENTRANT(jsReentLock, start = GetFromIndex(args[1], length, scriptContext),",
          "6696:                 deleteLen = GetFromIndex(args[2], (length - start), scriptContext, false));",
          "6697:             break;",
          "6698:         }",
          "6701:         if (pArr && !JavascriptArray::Is(pObj))",
          "6702:         {",
          "6703:             AssertOrFailFastMsg(ES5Array::Is(pObj), \"The array should have been converted to an ES5Array\");",
          "6704:             pArr = nullptr;",
          "6705:         }",
          "6707:         Var* insertArgs = args.Info.Count > 3 ? &args.Values[3] : nullptr;",
          "6708:         uint32 insertLen = args.Info.Count > 3 ? args.Info.Count - 3 : 0;",
          "6710:         if (pArr != nullptr)",
          "6711:         {",
          "6713:             _Analysis_assume_(length <= UINT_MAX);",
          "6714:             JS_REENTRANT_UNLOCK(jsReentLock,",
          "6715:                 return TryArraySplice(pArr, (uint32)start, (uint32)length, (uint32)deleteLen, insertArgs, insertLen, scriptContext));",
          "6716:         }",
          "6718:         uint64 newLen = (length - deleteLen) + insertLen;",
          "6719:         if (newLen > UINT_MAX || length > UINT_MAX || (length + insertLen) > UINT_MAX)",
          "6720:         {",
          "6721:             JS_REENTRANT_UNLOCK(jsReentLock,",
          "6722:                 return ObjectSpliceHelper<uint64>(pObj, length, start, deleteLen, (Var*)insertArgs, insertLen, scriptContext, nullptr));",
          "6723:         }",
          "6724:         else",
          "6725:         {",
          "6726:             JS_REENTRANT_UNLOCK(jsReentLock,",
          "6727:                 return ObjectSpliceHelper<uint32>(pObj, (uint32)length, (uint32)start, (uint32)deleteLen, (Var*)insertArgs, insertLen, scriptContext, nullptr));",
          "6728:         }",
          "6729:     }",
          "6731:     inline BOOL JavascriptArray::IsSingleSegmentArray() const",
          "6732:     {",
          "6733:         return nullptr == head->next;",
          "6734:     }",
          "6736:     template<typename T>",
          "6737:     void JavascriptArray::ArraySegmentSpliceHelper(JavascriptArray *pnewArr, SparseArraySegment<T> *seg, SparseArraySegment<T> **prev,",
          "6738:                                                     uint32 start, uint32 deleteLen, Var* insertArgs, uint32 insertLen, Recycler *recycler)",
          "6739:     {",
          "6741:         uint32 relativeStart    = start - seg->left;  // This will be different from start when head->left is non zero -",
          "6744:         uint32 headDeleteLen    = min(start + deleteLen , seg->left + seg->length) - start;   // actual number of elements to delete in",
          "6747:         uint32 newHeadLen       = seg->length - headDeleteLen + insertLen;     // new length of the head after splice",
          "6750:         if (headDeleteLen != 0)",
          "6751:         {",
          "6752:             pnewArr->InvalidateLastUsedSegment();",
          "6753:             pnewArr->head = SparseArraySegment<T>::CopySegment(recycler, SparseArraySegment<T>::From(pnewArr->head), 0, seg, start, headDeleteLen);",
          "6754:         }",
          "6756:         if (newHeadLen != 0)",
          "6757:         {",
          "6758:             if (seg->size < newHeadLen)",
          "6759:             {",
          "6760:                 if (seg->next)",
          "6761:                 {",
          "6763:                     seg = seg->GrowByMinMax(recycler, newHeadLen - seg->size, seg->next->left - deleteLen + insertLen - seg->left - seg->size);",
          "6764:                 }",
          "6765:                 else",
          "6766:                 {",
          "6767:                     seg = seg->GrowByMin(recycler, newHeadLen - seg->size);",
          "6768:                 }",
          "6769: #ifdef VALIDATE_ARRAY",
          "6770:                 ValidateSegment(seg);",
          "6771: #endif",
          "6772:             }",
          "6775:             if (headDeleteLen != insertLen)",
          "6776:             {",
          "6777:                 uint32 noElementsToMove = seg->length - (relativeStart + headDeleteLen);",
          "6778:                 MoveArray(seg->elements + relativeStart + insertLen,",
          "6779:                             seg->elements + relativeStart + headDeleteLen,",
          "6780:                             noElementsToMove);",
          "6781:                 if (newHeadLen < seg->length) // truncate if necessary",
          "6782:                 {",
          "6783:                     seg->Truncate(seg->left + newHeadLen); // set end elements to null so that when we introduce null elements we are safe",
          "6784:                 }",
          "6785:                 seg->length = newHeadLen;",
          "6786:             }",
          "6788:             if (insertLen > 0)",
          "6789:             {",
          "6790:                 Assert(!VirtualTableInfo<JavascriptNativeIntArray>::HasVirtualTable(pnewArr) &&",
          "6791:                    !VirtualTableInfo<JavascriptNativeFloatArray>::HasVirtualTable(pnewArr));",
          "6794:                 CopyArray(seg->elements + relativeStart, insertLen,",
          "6795:                           reinterpret_cast<const T*>(insertArgs), insertLen);",
          "6796:             }",
          "6798:         }",
          "6799:         else",
          "6800:         {",
          "6802:         }",
          "6803:     }",
          "6805:     template<typename T>",
          "6806:     void JavascriptArray::ArraySpliceHelper(JavascriptArray* pnewArr, JavascriptArray* pArr, uint32 start, uint32 deleteLen, Var* insertArgs, uint32 insertLen, ScriptContext *scriptContext)",
          "6807:     {",
          "6809:         Recycler *recycler  = scriptContext->GetRecycler();",
          "6811:         Field(SparseArraySegmentBase*)* prevSeg  = &pArr->head;        // holds the next pointer of previous",
          "6812:         Field(SparseArraySegmentBase*)* prevPrevSeg  = &pArr->head;    // this holds the previous pointer to prevSeg dirty trick.",
          "6813:         SparseArraySegmentBase* savePrev = nullptr;",
          "6815:         Assert(pArr->head); // We should never have a null head.",
          "6816:         pArr->EnsureHead<T>();",
          "6817:         SparseArraySegment<T>* startSeg = SparseArraySegment<T>::From(pArr->head);",
          "6819:         const uint32 limit = start + deleteLen;",
          "6820:         uint32 rightLimit;",
          "6821:         if (UInt32Math::Add(startSeg->left, startSeg->size, &rightLimit))",
          "6822:         {",
          "6823:             rightLimit = JavascriptArray::MaxArrayLength;",
          "6824:         }",
          "6827:         while (startSeg && (rightLimit <= start))",
          "6828:         {",
          "6829:             savePrev = startSeg;",
          "6830:             prevPrevSeg = prevSeg;",
          "6831:             prevSeg = &startSeg->next;",
          "6832:             startSeg = SparseArraySegment<T>::From(startSeg->next);",
          "6834:             if (startSeg)",
          "6835:             {",
          "6836:                 if (UInt32Math::Add(startSeg->left, startSeg->size, &rightLimit))",
          "6837:                 {",
          "6838:                     rightLimit = JavascriptArray::MaxArrayLength;",
          "6839:                 }",
          "6840:             }",
          "6841:         }",
          "6844:         SparseArraySegmentBase* inlineHeadSegment = nullptr;",
          "6845:         bool hasInlineSegment = false;",
          "6847:         if (JavascriptNativeArray::Is(pArr))",
          "6848:         {",
          "6849:             if (JavascriptNativeFloatArray::Is(pArr))",
          "6850:             {",
          "6851:                 inlineHeadSegment = DetermineInlineHeadSegmentPointer<JavascriptNativeFloatArray, 0, true>((JavascriptNativeFloatArray*)pArr);",
          "6852:             }",
          "6853:             else if (JavascriptNativeIntArray::Is(pArr))",
          "6854:             {",
          "6855:                 inlineHeadSegment = DetermineInlineHeadSegmentPointer<JavascriptNativeIntArray, 0, true>((JavascriptNativeIntArray*)pArr);",
          "6856:             }",
          "6857:             Assert(inlineHeadSegment);",
          "6858:             hasInlineSegment = (startSeg == (SparseArraySegment<T>*)inlineHeadSegment);",
          "6859:         }",
          "6860:         else",
          "6861:         {",
          "6867:             hasInlineSegment = HasInlineHeadSegment(pArr->head->length);",
          "6868:         }",
          "6870:         if (startSeg)",
          "6871:         {",
          "6873:             if (startSeg->left <= start && (startSeg->left + startSeg->length) >= limit)",
          "6874:             {",
          "6876:                 SparseArraySegmentBase *nextSeg = startSeg->next;",
          "6878:                 JavascriptArray::ArraySegmentSpliceHelper(pnewArr, (SparseArraySegment<T>*)startSeg, (SparseArraySegment<T>**)prevSeg, start, deleteLen, insertArgs, insertLen, recycler);",
          "6879:                 while (nextSeg)",
          "6880:                 {",
          "6882:                     nextSeg->left = nextSeg->left - deleteLen + insertLen;",
          "6883:                     if (nextSeg->next == nullptr)",
          "6884:                     {",
          "6885:                         nextSeg->EnsureSizeInBound();",
          "6886:                     }",
          "6887:                     nextSeg = nextSeg->next;",
          "6888:                 }",
          "6889:                 if (*prevSeg)",
          "6890:                 {",
          "6891:                     (*prevSeg)->EnsureSizeInBound();",
          "6892:                 }",
          "6893:                 return;",
          "6894:             }",
          "6895:             else",
          "6896:             {",
          "6897:                 SparseArraySegment<T>* newHeadSeg = nullptr; // pnewArr->head is null",
          "6898:                 Field(SparseArraySegmentBase*)* prevNewHeadSeg = &pnewArr->head;",
          "6907:                 if (startSeg->left < start)",
          "6908:                 {",
          "6909:                     if (start < startSeg->left + startSeg->length)",
          "6910:                     {",
          "6911:                         uint32 headDeleteLen = startSeg->left + startSeg->length - start;",
          "6913:                         if (startSeg->next)",
          "6914:                         {",
          "6916:                             newHeadSeg = SparseArraySegment<T>::template AllocateSegmentImpl<false>(recycler, 0, headDeleteLen, headDeleteLen, nullptr);",
          "6917:                         }",
          "6918:                         else",
          "6919:                         {",
          "6920:                             newHeadSeg = SparseArraySegment<T>::AllocateSegment(recycler, 0, headDeleteLen, headDeleteLen, nullptr);",
          "6921:                         }",
          "6922:                         newHeadSeg = SparseArraySegment<T>::CopySegment(recycler, newHeadSeg, 0, startSeg, start, headDeleteLen);",
          "6923:                         newHeadSeg->next = nullptr;",
          "6925:                         prevNewHeadSeg = &newHeadSeg->next;",
          "6926:                         startSeg->Truncate(start);",
          "6927:                     }",
          "6928:                     savePrev = startSeg;",
          "6929:                     prevPrevSeg = prevSeg;",
          "6930:                     prevSeg = &startSeg->next;",
          "6931:                     startSeg = SparseArraySegment<T>::From(startSeg->next);",
          "6932:                 }",
          "6935:                 else if (hasInlineSegment && nullptr != startSeg)",
          "6936:                 {",
          "6938:                     if (startSeg->left  <= start && start < startSeg->left + startSeg->length)",
          "6939:                     {",
          "6940:                         uint32 headDeleteLen = startSeg->left + startSeg->length - start;",
          "6941:                         if (startSeg->next)",
          "6942:                         {",
          "6944:                             newHeadSeg = SparseArraySegment<T>::template AllocateSegmentImpl<false>(recycler, 0, headDeleteLen, headDeleteLen, nullptr);",
          "6945:                         }",
          "6946:                         else",
          "6947:                         {",
          "6948:                             newHeadSeg = SparseArraySegment<T>::AllocateSegment(recycler, 0, headDeleteLen, headDeleteLen, nullptr);",
          "6949:                         }",
          "6950:                         newHeadSeg = SparseArraySegment<T>::CopySegment(recycler, newHeadSeg, 0, startSeg, start, headDeleteLen);",
          "6952:                         prevNewHeadSeg = &newHeadSeg->next;",
          "6956:                         startSeg = SparseArraySegment<T>::From(startSeg->next);",
          "6957:                     }",
          "6959:                     else if (startSeg->left == 0 && startSeg->length == 0)",
          "6960:                     {",
          "6961:                         Assert(startSeg->size != 0);",
          "6963:                         startSeg = SparseArraySegment<T>::From(startSeg->next);",
          "6964:                     }",
          "6965:                 }",
          "6967:                 SparseArraySegmentBase *temp = nullptr;",
          "6968:                 while (startSeg && (startSeg->left + startSeg->length) <= limit)",
          "6969:                 {",
          "6970:                     temp = startSeg->next;",
          "6973:                     startSeg->left = startSeg->left - start;",
          "6974:                     startSeg->next = nullptr;",
          "6976:                     prevNewHeadSeg = &startSeg->next;",
          "6980:                     startSeg = (SparseArraySegment<T>*)temp;",
          "6981:                 }",
          "6986:                 bool dummyHeadNodeInserted = false;",
          "6987:                 if (!savePrev && (!startSeg || startSeg->left != 0))",
          "6988:                 {",
          "6989:                     Assert(pArr->head == startSeg);",
          "6990:                     pArr->EnsureHeadStartsFromZero<T>(recycler);",
          "6991:                     Assert(pArr->head && pArr->head->next == startSeg);",
          "6993:                     savePrev = pArr->head;",
          "6994:                     prevPrevSeg = prevSeg;",
          "6995:                     prevSeg = &pArr->head->next;",
          "6996:                     dummyHeadNodeInserted = true;",
          "6997:                 }",
          "7000:                 if (startSeg && (startSeg->left < limit))",
          "7001:                 {",
          "7003:                     uint32 headDeleteLen = start + deleteLen - startSeg->left ;",
          "7005:                     newHeadSeg = SparseArraySegment<T>::AllocateSegment(recycler, startSeg->left -  start, headDeleteLen, (SparseArraySegmentBase *)nullptr);",
          "7006:                     newHeadSeg = SparseArraySegment<T>::CopySegment(recycler, newHeadSeg, startSeg->left -  start, startSeg, startSeg->left, headDeleteLen);",
          "7007:                     newHeadSeg->next = nullptr;",
          "7009:                     prevNewHeadSeg = &newHeadSeg->next;",
          "7012:                     MoveArray(startSeg->elements, startSeg->elements + headDeleteLen, startSeg->length - headDeleteLen);",
          "7013:                     startSeg->left = startSeg->left + headDeleteLen; // We are moving the left ahead to point to the right index",
          "7014:                     startSeg->length = startSeg->length - headDeleteLen;",
          "7015:                     startSeg->Truncate(startSeg->left + startSeg->length);",
          "7016:                     startSeg->EnsureSizeInBound(); // Just truncated, size might exceed next.left",
          "7017:                 }",
          "7019:                 if (startSeg && ((startSeg->left - deleteLen + insertLen) == 0) && dummyHeadNodeInserted)",
          "7020:                 {",
          "7021:                     Assert(start + insertLen == 0);",
          "7023:                     pArr->head = startSeg;",
          "7024:                     savePrev = nullptr;",
          "7025:                     prevSeg = &pArr->head;",
          "7026:                 }",
          "7028:                 while (startSeg)",
          "7029:                 {",
          "7030:                     startSeg->left = startSeg->left - deleteLen + insertLen ;",
          "7031:                     if (startSeg->next == nullptr)",
          "7032:                     {",
          "7033:                         startSeg->EnsureSizeInBound();",
          "7034:                     }",
          "7035:                     startSeg = SparseArraySegment<T>::From(startSeg->next);",
          "7036:                 }",
          "7037:             }",
          "7038:         }",
          "7041:         pnewArr->head->EnsureSizeInBound();",
          "7042:         if (savePrev)",
          "7043:         {",
          "7044:             savePrev->EnsureSizeInBound();",
          "7045:         }",
          "7048:         if (insertLen > 0)",
          "7049:         {",
          "7050:             Assert(!JavascriptNativeIntArray::Is(pArr) && !JavascriptNativeFloatArray::Is(pArr));",
          "7053:             SparseArraySegment<T> *segInsert = nullptr;",
          "7056:             Assert(!savePrev || savePrev->left <= start);",
          "7057:             if (savePrev && (start - savePrev->left < savePrev->size))",
          "7058:             {",
          "7059:                 segInsert = (SparseArraySegment<T>*)savePrev;",
          "7060:                 uint32 spaceLeft = segInsert->size - (start - segInsert->left);",
          "7061:                 if(spaceLeft < insertLen)",
          "7062:                 {",
          "7063:                     if (!segInsert->next)",
          "7064:                     {",
          "7065:                         segInsert = segInsert->GrowByMin(recycler, insertLen - spaceLeft);",
          "7066:                     }",
          "7067:                     else",
          "7068:                     {",
          "7069:                         segInsert = segInsert->GrowByMinMax(recycler, insertLen - spaceLeft, segInsert->next->left - segInsert->left - segInsert->size);",
          "7070:                     }",
          "7071:                 }",
          "7073:                 segInsert->length = start + insertLen - segInsert->left;",
          "7074:             }",
          "7075:             else",
          "7076:             {",
          "7077:                 segInsert = SparseArraySegment<T>::AllocateSegment(recycler, start, insertLen, *prevSeg);",
          "7078:                 segInsert->next = *prevSeg;",
          "7080:                 savePrev = segInsert;",
          "7081:             }",
          "7083:             uint32 relativeStart = start - segInsert->left;",
          "7085:             CopyArray(segInsert->elements + relativeStart, insertLen,",
          "7086:                       reinterpret_cast<const T*>(insertArgs), insertLen);",
          "7087:         }",
          "7088:     }",
          "7090:     Var JavascriptArray::TryArraySplice(JavascriptArray* pArr, uint32 start, uint32 len, uint32 deleteLen,",
          "7091:         Var* insertArgs, uint32 insertLen, ScriptContext *scriptContext)",
          "7092:     {",
          "7093:         JS_REENTRANCY_LOCK(jsReentLock, scriptContext->GetThreadContext());",
          "7095:         Assert(pArr != nullptr);",
          "7097:         RecyclableObject* newObj = nullptr;",
          "7098:         Recycler *recycler = scriptContext->GetRecycler();",
          "7100:         ::Math::RecordOverflowPolicy newLenOverflow;",
          "7101:         uint32 newLen = UInt32Math::Add(len - deleteLen, insertLen, newLenOverflow); // new length of the array after splice",
          "7105:         if (deleteLen == insertLen)",
          "7106:         {",
          "7107:             JS_REENTRANT(jsReentLock, pArr->FillFromPrototypes(start, start + deleteLen));",
          "7108:         }",
          "7109:         else if (len)",
          "7110:         {",
          "7111:             JS_REENTRANT(jsReentLock, pArr->FillFromPrototypes(start, len));",
          "7112:         }",
          "7118:         if (newLenOverflow.HasOverflowed())",
          "7119:         {",
          "7120:             pArr = EnsureNonNativeArray(pArr);",
          "7121:             BigIndex dstIndex = MaxArrayLength;",
          "7123:             uint32 maxInsertLen = MaxArrayLength - start;",
          "7124:             if (insertLen > maxInsertLen)",
          "7125:             {",
          "7127:                 for (uint32 i = maxInsertLen; i < insertLen; i++)",
          "7128:                 {",
          "7129:                     pArr->DirectSetItemAt(dstIndex, insertArgs[i]);",
          "7130:                     ++dstIndex;",
          "7131:                 }",
          "7133:                 insertLen = maxInsertLen; // update",
          "7136:                 if (start + deleteLen < len)",
          "7137:                 {",
          "7138:                     pArr->TruncateToProperties(dstIndex, start + deleteLen);",
          "7139:                 }",
          "7140:             }",
          "7141:             else",
          "7142:             {",
          "7144:                 pArr->TruncateToProperties(dstIndex, MaxArrayLength - insertLen + deleteLen);",
          "7145:             }",
          "7147:             len = pArr->length; // update",
          "7148:             newLen = len - deleteLen + insertLen;",
          "7149:             Assert(newLen == MaxArrayLength);",
          "7150:         }",
          "7152:         if (insertArgs)",
          "7153:         {",
          "7154:             pArr = EnsureNonNativeArray(pArr);",
          "7155:         }",
          "7157:         bool isIntArray = false;",
          "7158:         bool isFloatArray = false;",
          "7159:         bool isBuiltinArrayCtor = true;",
          "7160:         JavascriptArray *newArr = nullptr;",
          "7163:         pArr->ClearSegmentMap();",
          "7167:         JS_REENTRANT(jsReentLock, newObj = ArraySpeciesCreate(pArr, deleteLen, scriptContext, nullptr, nullptr, &isBuiltinArrayCtor));",
          "7168:         if (newObj != nullptr)",
          "7169:         {",
          "7170:             pArr = EnsureNonNativeArray(pArr);",
          "7172:             if (JavascriptArray::Is(newObj))",
          "7173:             {",
          "7174: #if ENABLE_COPYONACCESS_ARRAY",
          "7175:                 JavascriptLibrary::CheckAndConvertCopyOnAccessNativeIntArray<Var>(newObj);",
          "7176: #endif",
          "7177:                 newArr = JavascriptArray::FromVar(newObj);",
          "7178:             }",
          "7179:         }",
          "7180:         else",
          "7182:         {",
          "7183:             pArr->GetArrayTypeAndConvert(&isIntArray, &isFloatArray);",
          "7184:             newArr = CreateNewArrayHelper(deleteLen, isIntArray, isFloatArray, pArr, scriptContext);",
          "7185: #if ENABLE_COPYONACCESS_ARRAY",
          "7186:             JavascriptLibrary::CheckAndConvertCopyOnAccessNativeIntArray<Var>(newArr);",
          "7187: #endif",
          "7188:         }",
          "7191:         if (newArr && isBuiltinArrayCtor && len == pArr->length)",
          "7192:         {",
          "7196:             if (pArr->IsSingleSegmentArray() && pArr->head->HasIndex(start))",
          "7197:             {",
          "7198:                 if (isIntArray)",
          "7199:                 {",
          "7200:                     ArraySegmentSpliceHelper<int32>(newArr, SparseArraySegment<int32>::From(pArr->head), (SparseArraySegment<int32>**)&pArr->head, start, deleteLen, insertArgs, insertLen, recycler);",
          "7201:                 }",
          "7202:                 else if (isFloatArray)",
          "7203:                 {",
          "7204:                     ArraySegmentSpliceHelper<double>(newArr, SparseArraySegment<double>::From(pArr->head), (SparseArraySegment<double>**)&pArr->head, start, deleteLen, insertArgs, insertLen, recycler);",
          "7205:                 }",
          "7206:                 else",
          "7207:                 {",
          "7208:                     ArraySegmentSpliceHelper<Var>(newArr, SparseArraySegment<Var>::From(pArr->head), (SparseArraySegment<Var>**)&pArr->head, start, deleteLen, insertArgs, insertLen, recycler);",
          "7209:                 }",
          "7215:                 newArr->SetHasNoMissingValues(pArr->HasNoMissingValues());",
          "7216:             }",
          "7217:             else",
          "7218:             {",
          "7219:                 if (isIntArray)",
          "7220:                 {",
          "7221:                     ArraySpliceHelper<int32>(newArr, pArr, start, deleteLen, insertArgs, insertLen, scriptContext);",
          "7222:                 }",
          "7223:                 else if (isFloatArray)",
          "7224:                 {",
          "7225:                     ArraySpliceHelper<double>(newArr, pArr, start, deleteLen, insertArgs, insertLen, scriptContext);",
          "7226:                 }",
          "7227:                 else",
          "7228:                 {",
          "7229:                     ArraySpliceHelper<Var>(newArr, pArr, start, deleteLen, insertArgs, insertLen, scriptContext);",
          "7230:                 }",
          "7233:                 pArr->SetHasNoMissingValues(false);",
          "7234:                 newArr->SetHasNoMissingValues(false);",
          "7235:             }",
          "7237:             if (isIntArray)",
          "7238:             {",
          "7239:                 pArr->EnsureHeadStartsFromZero<int32>(recycler);",
          "7240:                 newArr->EnsureHeadStartsFromZero<int32>(recycler);",
          "7241:             }",
          "7242:             else if (isFloatArray)",
          "7243:             {",
          "7244:                 pArr->EnsureHeadStartsFromZero<double>(recycler);",
          "7245:                 newArr->EnsureHeadStartsFromZero<double>(recycler);",
          "7246:             }",
          "7247:             else",
          "7248:             {",
          "7249:                 pArr->EnsureHeadStartsFromZero<Var>(recycler);",
          "7250:                 newArr->EnsureHeadStartsFromZero<Var>(recycler);",
          "7251:             }",
          "7253:             pArr->InvalidateLastUsedSegment();",
          "7261:             if (pArr->length != len)",
          "7262:             {",
          "7263:                 pArr->SetLength(newLen);",
          "7264:             }",
          "7265:             else",
          "7266:             {",
          "7267:                 pArr->length = newLen;",
          "7268:             }",
          "7270:             if (newArr->length != deleteLen)",
          "7271:             {",
          "7272:                 newArr->SetLength(deleteLen);",
          "7273:             }",
          "7274:             else",
          "7275:             {",
          "7276:                 newArr->length = deleteLen;",
          "7277:             }",
          "7279:             newArr->InvalidateLastUsedSegment();",
          "7281: #ifdef VALIDATE_ARRAY",
          "7282:             newArr->ValidateArray();",
          "7283:             pArr->ValidateArray();",
          "7284: #endif",
          "7285:             if (newLenOverflow.HasOverflowed())",
          "7286:             {",
          "7288:                 JavascriptError::ThrowRangeError(scriptContext, JSERR_ArrayLengthAssignIncorrect);",
          "7289:             }",
          "7291:             return newArr;",
          "7292:         }",
          "7294:         if (newLenOverflow.HasOverflowed())",
          "7295:         {",
          "7296:             JS_REENTRANT_UNLOCK(jsReentLock, return ObjectSpliceHelper<uint64>(pArr, len, start, deleteLen, insertArgs, insertLen, scriptContext, newObj));",
          "7297:         }",
          "7298:         else // Use uint32 version if no overflow",
          "7299:         {",
          "7300:             JS_REENTRANT_UNLOCK(jsReentLock, return ObjectSpliceHelper<uint32>(pArr, len, start, deleteLen, insertArgs, insertLen, scriptContext, newObj));",
          "7301:         }",
          "7303:     }",
          "7305:     template<typename T>",
          "7306:     RecyclableObject* JavascriptArray::ObjectSpliceHelper(RecyclableObject* pObj, T len, T start,",
          "7307:         T deleteLen, Var* insertArgs, uint32 insertLen, ScriptContext *scriptContext, RecyclableObject* pNewObj)",
          "7308:     {",
          "7309:         JS_REENTRANCY_LOCK(jsReentLock, scriptContext->GetThreadContext());",
          "7310:         JavascriptArray *pnewArr = nullptr;",
          "7312:         if (pNewObj == nullptr)",
          "7313:         {",
          "7314:             JS_REENTRANT(jsReentLock, pNewObj = ArraySpeciesCreate(pObj, deleteLen, scriptContext));",
          "7315:             if (pNewObj == nullptr)",
          "7316:             {",
          "7317:                 if (deleteLen > UINT_MAX)",
          "7318:                 {",
          "7319:                     JavascriptError::ThrowRangeError(scriptContext, JSERR_ArrayLengthConstructIncorrect);",
          "7320:                 }",
          "7322:                 pnewArr = scriptContext->GetLibrary()->CreateArray(static_cast<uint32>(deleteLen));",
          "7323:                 pnewArr->EnsureHead<Var>();",
          "7325:                 pNewObj = pnewArr;",
          "7326:             }",
          "7327:         }",
          "7329:         if (JavascriptArray::Is(pNewObj))",
          "7330:         {",
          "7331: #if ENABLE_COPYONACCESS_ARRAY",
          "7332:             JavascriptLibrary::CheckAndConvertCopyOnAccessNativeIntArray<Var>(pNewObj);",
          "7333: #endif",
          "7334:             pnewArr = JavascriptArray::FromVar(pNewObj);",
          "7335:         }",
          "7338:         if (pnewArr != nullptr)",
          "7339:         {",
          "7340:             for (uint32 i = 0; i < deleteLen; i++)",
          "7341:             {",
          "7342:                 JS_REENTRANT(jsReentLock, BOOL hasItem = JavascriptOperators::HasItem(pObj, start + i));",
          "7343:                 if (hasItem)",
          "7344:                 {",
          "7345:                     JS_REENTRANT(jsReentLock, Var element = JavascriptOperators::GetItem(pObj, start + i, scriptContext));",
          "7346:                     pnewArr->SetItem(i, element, PropertyOperation_None);",
          "7347:                 }",
          "7348:             }",
          "7349:         }",
          "7350:         else",
          "7351:         {",
          "7352:             BigIndex k = 0u;",
          "7353:             for (T i = 0u; i < deleteLen; i++)",
          "7354:             {",
          "7355:                 JS_REENTRANT(jsReentLock, BOOL hasItem = JavascriptOperators::HasItem(pObj, start + i));",
          "7356:                 if (hasItem)",
          "7357:                 {",
          "7358:                     Var element = nullptr;",
          "7359:                     JS_REENTRANT(jsReentLock, element = JavascriptOperators::GetItem(pObj, start + i, scriptContext),",
          "7360:                         ThrowErrorOnFailure(JavascriptArray::SetArrayLikeObjects(pNewObj, k, element), scriptContext, k));",
          "7361:                 }",
          "7362:                 ++k;",
          "7363:             }",
          "7364:         }",
          "7366:         ThrowTypeErrorOnFailureHelper h(scriptContext, _u(\"Array.prototype.splice\"));",
          "7369:         if (insertLen > deleteLen) // Might overflow max array length",
          "7370:         {",
          "7372:             JS_REENTRANT(jsReentLock, Unshift<BigIndex, T>(pObj, start + insertLen, start + deleteLen, len, scriptContext));",
          "7373:         }",
          "7374:         else if (insertLen < deleteLen) // Won't overflow max array length",
          "7375:         {",
          "7376:             T j = 0;",
          "7377:             for (T i = start + deleteLen; i < len; i++)",
          "7378:             {",
          "7379:                 JS_REENTRANT(jsReentLock, BOOL hasItem = JavascriptOperators::HasItem(pObj, i));",
          "7380:                 if (hasItem)",
          "7381:                 {",
          "7382:                     Var element = nullptr;",
          "7383:                     JS_REENTRANT(jsReentLock, element = JavascriptOperators::GetItem(pObj, i, scriptContext),",
          "7384:                         h.ThrowTypeErrorOnFailure(JavascriptOperators::SetItem(pObj, pObj, start + insertLen + j, element, scriptContext, PropertyOperation_ThrowIfNotExtensible)));",
          "7385:                 }",
          "7386:                 else",
          "7387:                 {",
          "7388:                     JS_REENTRANT(jsReentLock,",
          "7389:                         h.ThrowTypeErrorOnFailure(JavascriptOperators::DeleteItem(pObj, start + insertLen + j, PropertyOperation_ThrowOnDeleteIfNotConfig)));",
          "7390:                 }",
          "7391:                 j++;",
          "7392:             }",
          "7395:             for (T i = len; i > len - deleteLen + insertLen; i--)",
          "7396:             {",
          "7397:                 JS_REENTRANT(jsReentLock, h.ThrowTypeErrorOnFailure(JavascriptOperators::DeleteItem(pObj, i - 1, PropertyOperation_ThrowOnDeleteIfNotConfig)));",
          "7398:             }",
          "7399:         }",
          "7401:         if (insertLen > 0)",
          "7402:         {",
          "7403:             T dstIndex = start; // insert index might overflow max array length",
          "7404:             for (uint32 i = 0; i < insertLen; i++)",
          "7405:             {",
          "7406:                 JS_REENTRANT(jsReentLock,",
          "7407:                     h.ThrowTypeErrorOnFailure(IndexTrace<BigIndex>::SetItem(pObj, dstIndex, insertArgs[i], PropertyOperation_ThrowIfNotExtensible)));",
          "7408:                 ++dstIndex;",
          "7409:             }",
          "7410:         }",
          "7413:         T newLen = T(len - deleteLen) + insertLen;",
          "7414:         JS_REENTRANT(jsReentLock,",
          "7415:             h.ThrowTypeErrorOnFailure(JavascriptOperators::SetProperty(pObj, pObj, PropertyIds::length, IndexTrace<BigIndex>::ToNumber(newLen, scriptContext), scriptContext, PropertyOperation_ThrowIfNotExtensible)),",
          "7416:             h.ThrowTypeErrorOnFailure(JavascriptOperators::SetProperty(pNewObj, pNewObj, PropertyIds::length, IndexTrace<BigIndex>::ToNumber(deleteLen, scriptContext), scriptContext, PropertyOperation_ThrowIfNotExtensible)));",
          "7417: #ifdef VALIDATE_ARRAY",
          "7418:         if (pnewArr)",
          "7419:         {",
          "7420:             pnewArr->ValidateArray();",
          "7421:         }",
          "7422: #endif",
          "7423:         return pNewObj;",
          "7424:     }",
          "7426:     Var JavascriptArray::EntryToLocaleString(RecyclableObject* function, CallInfo callInfo, ...)",
          "7427:     {",
          "7428:         PROBE_STACK(function->GetScriptContext(), Js::Constants::MinStackDefault);",
          "7430:         ARGUMENTS(args, callInfo);",
          "7431:         ScriptContext* scriptContext = function->GetScriptContext();",
          "7432:         JS_REENTRANCY_LOCK(jsReentLock, scriptContext->GetThreadContext());",
          "7434:         Assert(!(callInfo.Flags & CallFlags_New));",
          "7436:         if (args.Info.Count == 0)",
          "7437:         {",
          "7438:             JavascriptError::ThrowTypeError(scriptContext, JSERR_This_NeedObject, _u(\"Array.prototype.toLocaleString\"));",
          "7439:         }",
          "7441:         if (JavascriptArray::IsDirectAccessArray(args[0]))",
          "7442:         {",
          "7443:             JavascriptArray* arr = JavascriptArray::FromVar(args[0]);",
          "7444:             JS_REENTRANT_UNLOCK(jsReentLock, return ToLocaleString(arr, scriptContext));",
          "7445:         }",
          "7446:         else",
          "7447:         {",
          "7448:             if (TypedArrayBase::IsDetachedTypedArray(args[0]))",
          "7449:             {",
          "7450:                 JavascriptError::ThrowTypeError(scriptContext, JSERR_DetachedTypedArray, _u(\"Array.prototype.toLocalString\"));",
          "7451:             }",
          "7453:             RecyclableObject* obj = nullptr;",
          "7454:             if (FALSE == JavascriptConversion::ToObject(args[0], scriptContext, &obj))",
          "7455:             {",
          "7456:                 JavascriptError::ThrowTypeError(scriptContext, JSERR_This_NullOrUndefined, _u(\"Array.prototype.toLocaleString\"));",
          "7457:             }",
          "7458:             JS_REENTRANT_UNLOCK(jsReentLock, return ToLocaleString(obj, scriptContext));",
          "7459:         }",
          "7460:     }",
          "7465:     template<typename T, typename P>",
          "7466:     void JavascriptArray::Unshift(RecyclableObject* obj, const T& toIndex, P start, P end, ScriptContext* scriptContext)",
          "7467:     {",
          "7468:         JS_REENTRANCY_LOCK(jsReentLock, scriptContext->GetThreadContext());",
          "7470:         typedef IndexTrace<T> index_trace;",
          "7472:         ThrowTypeErrorOnFailureHelper h(scriptContext, _u(\"Array.prototype.unshift\"));",
          "7473:         if (start < end)",
          "7474:         {",
          "7475:             T newEnd = (end - start - 1);// newEnd - 1",
          "7476:             T dst = toIndex + newEnd;",
          "7477:             for (P i = end; i > start; --i)",
          "7478:             {",
          "7479:                 JS_REENTRANT(jsReentLock, BOOL hasItem = JavascriptOperators::HasItem(obj, i - 1));",
          "7480:                 if (hasItem)",
          "7481:                 {",
          "7482:                     Var element = nullptr;",
          "7483:                     JS_REENTRANT(jsReentLock, element = JavascriptOperators::GetItem(obj, i - 1, scriptContext),",
          "7484:                         h.ThrowTypeErrorOnFailure(index_trace::SetItem(obj, dst, element, PropertyOperation_ThrowIfNotExtensible)));",
          "7485:                 }",
          "7486:                 else",
          "7487:                 {",
          "7488:                     JS_REENTRANT(jsReentLock, h.ThrowTypeErrorOnFailure(index_trace::DeleteItem(obj, dst, PropertyOperation_ThrowOnDeleteIfNotConfig)));",
          "7489:                 }",
          "7491:                 --dst;",
          "7492:             }",
          "7493:         }",
          "7494:     }",
          "7496:     template<typename T>",
          "7497:     void JavascriptArray::GrowArrayHeadHelperForUnshift(JavascriptArray* pArr, uint32 unshiftElements, ScriptContext * scriptContext)",
          "7498:     {",
          "7499:         SparseArraySegmentBase* nextToHeadSeg = pArr->head->next;",
          "7500:         Recycler* recycler = scriptContext->GetRecycler();",
          "7502:         if (nextToHeadSeg == nullptr)",
          "7503:         {",
          "7504:             pArr->EnsureHead<T>();",
          "7505:             pArr->head = SparseArraySegment<T>::From(pArr->head)->GrowByMin(recycler, unshiftElements);",
          "7506:         }",
          "7507:         else",
          "7508:         {",
          "7509:             pArr->head = SparseArraySegment<T>::From(pArr->head)->GrowByMinMax(recycler, unshiftElements, ((nextToHeadSeg->left + unshiftElements) - pArr->head->left - pArr->head->size));",
          "7510:         }",
          "7512:     }",
          "7514:     template<typename T>",
          "7515:     void JavascriptArray::UnshiftHelper(JavascriptArray* pArr, uint32 unshiftElements, Js::Var * elements)",
          "7516:     {",
          "7517:         SparseArraySegment<T>* head = SparseArraySegment<T>::From(pArr->head);",
          "7519:         MoveArray(head->elements + unshiftElements, head->elements, pArr->head->length);",
          "7520:         uint32 oldHeadLength = head->length;",
          "7521:         head->length += unshiftElements;",
          "7524:         pArr->InvalidateLastUsedSegment();",
          "7526:         bool hasNoMissingValues = pArr->HasNoMissingValues();",
          "7529:         if(unshiftElements > oldHeadLength)",
          "7530:         {",
          "7531:             pArr->SetHasNoMissingValues(false);",
          "7532:         }",
          "7534: #if ENABLE_PROFILE_INFO",
          "7535:         pArr->FillFromArgs(unshiftElements, 0, elements, nullptr, true/*dontCreateNewArray*/);",
          "7536: #else",
          "7537:         pArr->FillFromArgs(unshiftElements, 0, elements, true/*dontCreateNewArray*/);",
          "7538: #endif",
          "7541:         pArr->SetHasNoMissingValues(hasNoMissingValues);",
          "7542:     }",
          "7544:     Var JavascriptArray::EntryUnshift(RecyclableObject* function, CallInfo callInfo, ...)",
          "7545:     {",
          "7546:         PROBE_STACK(function->GetScriptContext(), Js::Constants::MinStackDefault);",
          "7548:         ARGUMENTS(args, callInfo);",
          "7549:         ScriptContext* scriptContext = function->GetScriptContext();",
          "7550:         JS_REENTRANCY_LOCK(jsReentLock, scriptContext->GetThreadContext());",
          "7552:         Assert(!(callInfo.Flags & CallFlags_New));",
          "7554:         Var res = scriptContext->GetLibrary()->GetUndefined();",
          "7556:         if (args.Info.Count == 0)",
          "7557:         {",
          "7558:            return res;",
          "7559:         }",
          "7560:         if (JavascriptArray::Is(args[0]) && !JavascriptArray::FromVar(args[0])->IsCrossSiteObject())",
          "7561:         {",
          "7562: #if ENABLE_COPYONACCESS_ARRAY",
          "7563:             JavascriptLibrary::CheckAndConvertCopyOnAccessNativeIntArray<Var>(args[0]);",
          "7564: #endif",
          "7565:             JavascriptArray * pArr = JavascriptArray::FromVar(args[0]);",
          "7567:             uint32 unshiftElements = args.Info.Count - 1;",
          "7569:             if (unshiftElements > 0)",
          "7570:             {",
          "7571:                 if (pArr->IsFillFromPrototypes())",
          "7572:                 {",
          "7573:                     JS_REENTRANT(jsReentLock, pArr->FillFromPrototypes(0, pArr->length)); // We need find all missing value from [[proto]] object",
          "7574:                 }",
          "7577:                 bool newLenOverflowed = false;",
          "7578:                 uint32 maxLen = MaxArrayLength - unshiftElements;",
          "7579:                 if (pArr->length > maxLen)",
          "7580:                 {",
          "7581:                     newLenOverflowed = true;",
          "7583:                     EnsureNonNativeArray(pArr);",
          "7584:                     pArr->TruncateToProperties(MaxArrayLength, maxLen);",
          "7585:                     Assert(pArr->length + unshiftElements == MaxArrayLength);",
          "7586:                 }",
          "7588:                 pArr->ClearSegmentMap(); // Dump segmentMap on unshift (before any possible allocation and throw)",
          "7590:                 Assert(pArr->length <= MaxArrayLength - unshiftElements);",
          "7592:                 SparseArraySegmentBase* renumberSeg = pArr->head->next;",
          "7594:                 bool isIntArray = false;",
          "7595:                 bool isFloatArray = false;",
          "7597:                 if (JavascriptNativeIntArray::Is(pArr))",
          "7598:                 {",
          "7599:                     isIntArray = true;",
          "7600:                 }",
          "7601:                 else if (JavascriptNativeFloatArray::Is(pArr))",
          "7602:                 {",
          "7603:                     isFloatArray = true;",
          "7604:                 }",
          "7608:                 if (pArr->head->size < pArr->head->length + unshiftElements)",
          "7609:                 {",
          "7610:                     if (isIntArray)",
          "7611:                     {",
          "7612:                         GrowArrayHeadHelperForUnshift<int32>(pArr, unshiftElements, scriptContext);",
          "7613:                     }",
          "7614:                     else if (isFloatArray)",
          "7615:                     {",
          "7616:                         GrowArrayHeadHelperForUnshift<double>(pArr, unshiftElements, scriptContext);",
          "7617:                     }",
          "7618:                     else",
          "7619:                     {",
          "7620:                         GrowArrayHeadHelperForUnshift<Var>(pArr, unshiftElements, scriptContext);",
          "7621:                     }",
          "7622:                 }",
          "7624:                 while (renumberSeg)",
          "7625:                 {",
          "7626:                     renumberSeg->left += unshiftElements;",
          "7627:                     if (renumberSeg->next == nullptr)",
          "7628:                     {",
          "7630:                         renumberSeg->EnsureSizeInBound();",
          "7631:                     }",
          "7632:                     renumberSeg = renumberSeg->next;",
          "7633:                 }",
          "7635:                 if (isIntArray)",
          "7636:                 {",
          "7637:                     UnshiftHelper<int32>(pArr, unshiftElements, args.Values);",
          "7638:                 }",
          "7639:                 else if (isFloatArray)",
          "7640:                 {",
          "7641:                     UnshiftHelper<double>(pArr, unshiftElements, args.Values);",
          "7642:                 }",
          "7643:                 else",
          "7644:                 {",
          "7645:                     UnshiftHelper<Var>(pArr, unshiftElements, args.Values);",
          "7646:                 }",
          "7648:                 pArr->InvalidateLastUsedSegment();",
          "7649:                 pArr->length += unshiftElements;",
          "7651: #ifdef VALIDATE_ARRAY",
          "7652:                 pArr->ValidateArray();",
          "7653: #endif",
          "7655:                 if (newLenOverflowed) // ES5: throw if new \"length\" exceeds max array length",
          "7656:                 {",
          "7657:                     JavascriptError::ThrowRangeError(scriptContext, JSERR_ArrayLengthAssignIncorrect);",
          "7658:                 }",
          "7659:             }",
          "7660:             res = JavascriptNumber::ToVar(pArr->length, scriptContext);",
          "7661:         }",
          "7662:         else",
          "7663:         {",
          "7664:             RecyclableObject* dynamicObject = nullptr;",
          "7665:             if (FALSE == JavascriptConversion::ToObject(args[0], scriptContext, &dynamicObject))",
          "7666:             {",
          "7667:                 JavascriptError::ThrowTypeError(scriptContext, JSERR_This_NullOrUndefined, _u(\"Array.prototype.unshift\"));",
          "7668:             }",
          "7670:             JS_REENTRANT(jsReentLock, BigIndex length = OP_GetLength(dynamicObject, scriptContext));",
          "7671:             uint32 unshiftElements = args.Info.Count - 1;",
          "7672:             if (unshiftElements > 0)",
          "7673:             {",
          "7674:                 uint32 MaxSpaceUint32 = MaxArrayLength - unshiftElements;",
          "7677:                 BigIndex end = length > MaxSpaceUint32 ? MaxSpaceUint32 : length;",
          "7678:                 if (end < length)",
          "7679:                 {",
          "7682:                     if (length.IsSmallIndex())",
          "7683:                     {",
          "7684:                         JS_REENTRANT(jsReentLock, Unshift<BigIndex>(dynamicObject, MaxArrayLength, end.GetSmallIndex(), length.GetSmallIndex(), scriptContext));",
          "7685:                     }",
          "7686:                     else",
          "7687:                     {",
          "7688:                         JS_REENTRANT(jsReentLock, Unshift<BigIndex, uint64>(dynamicObject, MaxArrayLength, (uint64)end.GetSmallIndex(), length.GetBigIndex(), scriptContext));",
          "7689:                     }",
          "7690:                 }",
          "7694:                 JS_REENTRANT(jsReentLock, Unshift<uint32>(dynamicObject, unshiftElements, (uint32)0, end.GetSmallIndex(), scriptContext));",
          "7696:                 for (uint32 i = 0; i < unshiftElements; i++)",
          "7697:                 {",
          "7698:                     JS_REENTRANT(jsReentLock,",
          "7699:                         JavascriptOperators::SetItem(dynamicObject, dynamicObject, i, args[i + 1], scriptContext, PropertyOperation_ThrowIfNotExtensible, true));",
          "7700:                 }",
          "7701:             }",
          "7703:             ThrowTypeErrorOnFailureHelper h(scriptContext, _u(\"Array.prototype.unshift\"));",
          "7706:             BigIndex newLen = length + unshiftElements;",
          "7707:             res = JavascriptNumber::ToVar(newLen.IsSmallIndex() ? newLen.GetSmallIndex() : newLen.GetBigIndex(), scriptContext);",
          "7708:             JS_REENTRANT(jsReentLock,",
          "7709:                 BOOL setLength = JavascriptOperators::SetProperty(dynamicObject, dynamicObject, PropertyIds::length, res, scriptContext, PropertyOperation_ThrowIfNotExtensible));",
          "7710:             h.ThrowTypeErrorOnFailure(setLength);",
          "7711:         }",
          "7712:         return res;",
          "7714:     }",
          "7716:     Var JavascriptArray::EntryToString(RecyclableObject* function, CallInfo callInfo, ...)",
          "7717:     {",
          "7718:         PROBE_STACK(function->GetScriptContext(), Js::Constants::MinStackDefault);",
          "7720:         ARGUMENTS(args, callInfo);",
          "7721:         ScriptContext* scriptContext = function->GetScriptContext();",
          "7722:         JS_REENTRANCY_LOCK(jsReentLock, scriptContext->GetThreadContext());",
          "7724:         Assert(!(callInfo.Flags & CallFlags_New));",
          "7726:         if (args.Info.Count == 0)",
          "7727:         {",
          "7728:             JavascriptError::ThrowTypeError(scriptContext, JSERR_NeedObject);",
          "7729:         }",
          "7733:         RecyclableObject* obj = nullptr;",
          "7734:         if (FALSE == JavascriptConversion::ToObject(args[0], scriptContext, &obj))",
          "7735:         {",
          "7736:             JavascriptError::ThrowTypeError(scriptContext, JSERR_This_NullOrUndefined, _u(\"Array.prototype.toString\"));",
          "7737:         }",
          "7740:         JS_REENTRANT(jsReentLock, Var join = JavascriptOperators::GetProperty(obj, PropertyIds::join, scriptContext));",
          "7741:         if (JavascriptConversion::IsCallable(join))",
          "7742:         {",
          "7743:             RecyclableObject* func = RecyclableObject::FromVar(join);",
          "7746:             ThreadContext * threadContext = scriptContext->GetThreadContext();",
          "7747:             JS_REENTRANT(jsReentLock,",
          "7748:                 Var result = threadContext->ExecuteImplicitCall(func, ImplicitCall_ToPrimitive, [=]() -> Js::Var",
          "7749:             {",
          "7751:                 Assert(!ThreadContext::IsOnStack(obj));",
          "7754:                 CallFlags flags = CallFlags_Value;",
          "7755:                 return CALL_FUNCTION(threadContext, func, CallInfo(flags, 1), obj);",
          "7756:             }));",
          "7758:             if(!result)",
          "7759:             {",
          "7761:                 Assert(threadContext->IsDisableImplicitCall());",
          "7762:                 result = scriptContext->GetLibrary()->GetNull();",
          "7763:             }",
          "7765:             return result;",
          "7766:         }",
          "7767:         else",
          "7768:         {",
          "7770:             JS_REENTRANT_UNLOCK(jsReentLock,",
          "7771:                 return CALL_ENTRYPOINT(scriptContext->GetThreadContext(), JavascriptObject::EntryToString, function, CallInfo(1), obj));",
          "7772:         }",
          "7773:     }",
          "7775: #if DEBUG",
          "7776:     BOOL JavascriptArray::GetIndex(const char16* propName, uint32 *pIndex)",
          "7777:     {",
          "7778:         uint32 lu, luDig;",
          "7780:         int32 cch = (int32)wcslen(propName);",
          "7781:         char16* pch = const_cast<char16 *>(propName);",
          "7783:         lu = *pch - '0';",
          "7784:         if (lu > 9)",
          "7785:             return FALSE;",
          "7787:         if (0 == lu)",
          "7788:         {",
          "7790:             return 1 == cch;",
          "7791:         }",
          "7793:         while ((luDig = *++pch - '0') < 10)",
          "7794:         {",
          "7796:             if (lu > 0x19999999)",
          "7797:                 return FALSE;",
          "7798:             lu *= 10;",
          "7799:             if(lu > (ULONG_MAX - luDig))",
          "7800:                 return FALSE;",
          "7801:             lu += luDig;",
          "7802:         }",
          "7804:         if (pch - propName != cch)",
          "7805:             return FALSE;",
          "7807:         if (lu == JavascriptArray::InvalidIndex)",
          "7808:         {",
          "7811:             return FALSE;",
          "7812:         }",
          "7815:         return TRUE;",
          "7816:     }",
          "7817: #endif",
          "7819:     JavascriptString* JavascriptArray::GetLocaleSeparator(ScriptContext* scriptContext)",
          "7820:     {",
          "7821: #ifdef ENABLE_GLOBALIZATION",
          "7822:         LCID lcid = GetUserDefaultLCID();",
          "7823:         int count = 0;",
          "7824:         char16 szSeparator[6];",
          "7827:         count = GetLocaleInfoW(lcid, LOCALE_SLIST, szSeparator, 5);",
          "7828:         if( !count)",
          "7829:         {",
          "7830:             AssertMsg(FALSE, \"GetLocaleInfo failed\");",
          "7831:             return scriptContext->GetLibrary()->GetCommaSpaceDisplayString();",
          "7832:         }",
          "7833:         else",
          "7834:         {",
          "7836:             if( count < 2 || szSeparator[count-2] != ' ')",
          "7837:             {",
          "7838:                 szSeparator[count-1] = ' ';",
          "7839:                 szSeparator[count] = '\\0';",
          "7840:             }",
          "7842:             return JavascriptString::NewCopyBuffer(szSeparator, count, scriptContext);",
          "7843:         }",
          "7844: #else",
          "7846:         return scriptContext->GetLibrary()->GetCommaSpaceDisplayString();",
          "7847: #endif",
          "7848:     }",
          "7850:     template <typename T>",
          "7851:     JavascriptString* JavascriptArray::ToLocaleString(T* arr, ScriptContext* scriptContext)",
          "7852:     {",
          "7853:         JS_REENTRANCY_LOCK(jsReentLock, scriptContext->GetThreadContext());",
          "7855:         uint32 length = 0;",
          "7856:         if (TypedArrayBase::Is(arr))",
          "7857:         {",
          "7859:             length = TypedArrayBase::FromVar(arr)->GetLength();",
          "7860:         }",
          "7861:         else",
          "7862:         {",
          "7864:             JS_REENTRANT(jsReentLock, length = ItemTrace<T>::GetLength(arr, scriptContext));",
          "7865:         }",
          "7867:         if (length == 0 || scriptContext->CheckObject(arr))",
          "7868:         {",
          "7869:             return scriptContext->GetLibrary()->GetEmptyString();",
          "7870:         }",
          "7872:         JavascriptString* res = scriptContext->GetLibrary()->GetEmptyString();",
          "7873:         bool pushedObject = false;",
          "7875:         TryFinally([&]()",
          "7876:         {",
          "7877:             scriptContext->PushObject(arr);",
          "7878:             pushedObject = true;",
          "7880:             Var element;",
          "7881:             JS_REENTRANT(jsReentLock, BOOL gotItem = ItemTrace<T>::GetItem(arr, 0, &element, scriptContext));",
          "7882:             if (gotItem)",
          "7883:             {",
          "7884:                 JS_REENTRANT(jsReentLock, res = JavascriptArray::ToLocaleStringHelper(element, scriptContext));",
          "7885:             }",
          "7887:             if (length > 1)",
          "7888:             {",
          "7889:                 JavascriptString* separator = GetLocaleSeparator(scriptContext);",
          "7891:                 for (uint32 i = 1; i < length; i++)",
          "7892:                 {",
          "7893:                     res = JavascriptString::Concat(res, separator);",
          "7894:                     JS_REENTRANT(jsReentLock, gotItem = ItemTrace<T>::GetItem(arr, i, &element, scriptContext));",
          "7895:                     if (gotItem)",
          "7896:                     {",
          "7897:                         JS_REENTRANT(jsReentLock, res = JavascriptString::Concat(res, JavascriptArray::ToLocaleStringHelper(element, scriptContext)));",
          "7898:                     }",
          "7899:                 }",
          "7900:             }",
          "7901:         },",
          "7902:         [&](bool/*hasException*/)",
          "7903:         {",
          "7904:             if (pushedObject)",
          "7905:             {",
          "7906:                 Var top = scriptContext->PopObject();",
          "7907:                 AssertMsg(top == arr, \"Unmatched operation stack\");",
          "7908:             }",
          "7909:         });",
          "7911:         if (res == nullptr)",
          "7912:         {",
          "7913:             res = scriptContext->GetLibrary()->GetEmptyString();",
          "7914:         }",
          "7916:         return res;",
          "7917:     }",
          "7919:     Var JavascriptArray::EntryIsArray(RecyclableObject* function, CallInfo callInfo, ...)",
          "7920:     {",
          "7921:         PROBE_STACK(function->GetScriptContext(), Js::Constants::MinStackDefault);",
          "7923:         ARGUMENTS(args, callInfo);",
          "7924:         ScriptContext* scriptContext = function->GetScriptContext();",
          "7925:         JS_REENTRANCY_LOCK(jsReentLock, scriptContext->GetThreadContext());",
          "7927:         Assert(!(callInfo.Flags & CallFlags_New));",
          "7929:         CHAKRATEL_LANGSTATS_INC_BUILTINCOUNT(Array_Constructor_isArray);",
          "7931:         if (args.Info.Count < 2)",
          "7932:         {",
          "7933:             return scriptContext->GetLibrary()->GetFalse();",
          "7934:         }",
          "7936: #if ENABLE_COPYONACCESS_ARRAY",
          "7937:         JavascriptLibrary::CheckAndConvertCopyOnAccessNativeIntArray<Var>(args[1]);",
          "7938: #endif",
          "7939:         if (JavascriptOperators::IsArray(args[1]))",
          "7940:         {",
          "7941:             return scriptContext->GetLibrary()->GetTrue();",
          "7942:         }",
          "7943:         return scriptContext->GetLibrary()->GetFalse();",
          "7944:     }",
          "7951:     Var JavascriptArray::EntryFind(RecyclableObject* function, CallInfo callInfo, ...)",
          "7952:     {",
          "7953:         PROBE_STACK(function->GetScriptContext(), Js::Constants::MinStackDefault);",
          "7955:         ARGUMENTS(args, callInfo);",
          "7956:         ScriptContext* scriptContext = function->GetScriptContext();",
          "7957:         JS_REENTRANCY_LOCK(jsReentLock, scriptContext->GetThreadContext());",
          "7959:         Assert(!(callInfo.Flags & CallFlags_New));",
          "7961:         if (args.Info.Count == 0)",
          "7962:         {",
          "7963:             JavascriptError::ThrowTypeError(scriptContext, JSERR_This_NullOrUndefined, _u(\"Array.prototype.find\"));",
          "7964:         }",
          "7966:         int64 length;",
          "7967:         JavascriptArray * pArr = nullptr;",
          "7968:         RecyclableObject* obj = nullptr;",
          "7970:         JS_REENTRANT_UNLOCK(jsReentLock, TryGetArrayAndLength(args[0], scriptContext, _u(\"Array.prototype.find\"), &pArr, &obj, &length));",
          "7972:             return JavascriptArray::FindHelper<false>(pArr, nullptr, obj, length, args, scriptContext);",
          "7973:     }",
          "7975:     template <bool findIndex>",
          "7976:     Var JavascriptArray::FindHelper(JavascriptArray* pArr, Js::TypedArrayBase* typedArrayBase, RecyclableObject* obj, int64 length, Arguments& args, ScriptContext* scriptContext)",
          "7977:     {",
          "7978:         JS_REENTRANCY_LOCK(jsReentLock, scriptContext->GetThreadContext());",
          "7980:         if (args.Info.Count < 2 || !JavascriptConversion::IsCallable(args[1]))",
          "7981:         {",
          "7983:             if (typedArrayBase != nullptr)",
          "7984:             {",
          "7985:                 JavascriptError::ThrowTypeError(scriptContext, JSERR_FunctionArgument_NeedFunction, findIndex ? _u(\"[TypedArray].prototype.findIndex\") : _u(\"[TypedArray].prototype.find\"));",
          "7986:             }",
          "7987:             else",
          "7988:             {",
          "7989:                 JavascriptError::ThrowTypeError(scriptContext, JSERR_FunctionArgument_NeedFunction, findIndex ? _u(\"Array.prototype.findIndex\") : _u(\"Array.prototype.find\"));",
          "7990:             }",
          "7991:         }",
          "7993:         RecyclableObject* callBackFn = RecyclableObject::FromVar(args[1]);",
          "7994:         Var thisArg;",
          "7996:         if (args.Info.Count > 2)",
          "7997:         {",
          "7998:             thisArg = args[2];",
          "7999:         }",
          "8000:         else",
          "8001:         {",
          "8002:             thisArg = scriptContext->GetLibrary()->GetUndefined();",
          "8003:         }",
          "8006:         if (typedArrayBase == nullptr && pArr == nullptr && TypedArrayBase::Is(obj))",
          "8007:         {",
          "8008:             typedArrayBase = TypedArrayBase::FromVar(obj);",
          "8009:         }",
          "8012:         CallFlags flags = CallFlags_Value;",
          "8013:         Var element = nullptr;",
          "8014:         Var testResult = nullptr;",
          "8016:         if (pArr)",
          "8017:         {",
          "8018:             Var undefined = scriptContext->GetLibrary()->GetUndefined();",
          "8020:             Assert(length <= UINT_MAX);",
          "8021:             for (uint32 k = 0; k < (uint32)length; k++)",
          "8022:             {",
          "8023:                 element = undefined;",
          "8024:                 JS_REENTRANT(jsReentLock, pArr->DirectGetItemAtFull(k, &element));",
          "8026:                 Var index = JavascriptNumber::ToVar(k, scriptContext);",
          "8028:                 JS_REENTRANT(jsReentLock,",
          "8029:                     testResult = CALL_FUNCTION(scriptContext->GetThreadContext(), callBackFn, CallInfo(flags, 4), thisArg,",
          "8030:                         element,",
          "8031:                         index,",
          "8032:                         pArr));",
          "8034:                 if (JavascriptConversion::ToBoolean(testResult, scriptContext))",
          "8035:                 {",
          "8036:                     return findIndex ? index : element;",
          "8037:                 }",
          "8041:                 if (!JavascriptArray::Is(obj))",
          "8042:                 {",
          "8043:                     AssertOrFailFastMsg(ES5Array::Is(obj), \"The array should have been converted to an ES5Array\");",
          "8044:                     JS_REENTRANT_UNLOCK(jsReentLock, return JavascriptArray::FindObjectHelper<findIndex>(obj, length, k + 1, callBackFn, thisArg, scriptContext));",
          "8045:                 }",
          "8046:             }",
          "8047:         }",
          "8048:         else if (typedArrayBase)",
          "8049:         {",
          "8050:             Assert(length <= UINT_MAX);",
          "8051:             for (uint32 k = 0; k < (uint32)length; k++)",
          "8052:             {",
          "8055:                 element = typedArrayBase->DirectGetItem(k);",
          "8057:                 Var index = JavascriptNumber::ToVar(k, scriptContext);",
          "8059:                 JS_REENTRANT(jsReentLock,",
          "8060:                     testResult = CALL_FUNCTION(scriptContext->GetThreadContext(), callBackFn, CallInfo(flags, 4), thisArg,",
          "8061:                         element,",
          "8062:                         index,",
          "8063:                         typedArrayBase));",
          "8065:                 if (JavascriptConversion::ToBoolean(testResult, scriptContext))",
          "8066:                 {",
          "8067:                     return findIndex ? index : element;",
          "8068:                 }",
          "8069:             }",
          "8070:         }",
          "8071:         else",
          "8072:         {",
          "8073:             JS_REENTRANT_UNLOCK(jsReentLock, return JavascriptArray::FindObjectHelper<findIndex>(obj, length, 0u, callBackFn, thisArg, scriptContext));",
          "8074:         }",
          "8076:         return findIndex ? JavascriptNumber::ToVar(-1, scriptContext) : scriptContext->GetLibrary()->GetUndefined();",
          "8077:     }",
          "8079:     template <bool findIndex>",
          "8080:     Var JavascriptArray::FindObjectHelper(RecyclableObject* obj, int64 length, int64 start, RecyclableObject* callBackFn, Var thisArg, ScriptContext* scriptContext)",
          "8081:     {",
          "8082:         JS_REENTRANCY_LOCK(jsReentLock, scriptContext->GetThreadContext());",
          "8085:         CallFlags flags = CallFlags_Value;",
          "8086:         Var element = nullptr;",
          "8087:         Var testResult = nullptr;",
          "8089:         for (int64 k = start; k < length; k++)",
          "8090:         {",
          "8091:             JS_REENTRANT(jsReentLock, element = JavascriptOperators::GetItem(obj, (uint64)k, scriptContext));",
          "8092:             Var index = JavascriptNumber::ToVar(k, scriptContext);",
          "8094:                 JS_REENTRANT(jsReentLock,",
          "8095:                     testResult = CALL_FUNCTION(scriptContext->GetThreadContext(), callBackFn, CallInfo(flags, 4), thisArg,",
          "8096:                     element,",
          "8097:                     index,",
          "8098:                         obj));",
          "8100:             if (JavascriptConversion::ToBoolean(testResult, scriptContext))",
          "8101:             {",
          "8102:                 return findIndex ? index : element;",
          "8103:             }",
          "8104:         }",
          "8106:         return findIndex ? JavascriptNumber::ToVar(-1, scriptContext) : scriptContext->GetLibrary()->GetUndefined();",
          "8107:     }",
          "8114:     Var JavascriptArray::EntryFindIndex(RecyclableObject* function, CallInfo callInfo, ...)",
          "8115:     {",
          "8116:         PROBE_STACK(function->GetScriptContext(), Js::Constants::MinStackDefault);",
          "8118:         ARGUMENTS(args, callInfo);",
          "8119:         ScriptContext* scriptContext = function->GetScriptContext();",
          "8120:         JS_REENTRANCY_LOCK(jsReentLock, scriptContext->GetThreadContext());",
          "8122:         Assert(!(callInfo.Flags & CallFlags_New));",
          "8124:         if (args.Info.Count == 0)",
          "8125:         {",
          "8126:             JavascriptError::ThrowTypeError(scriptContext, JSERR_This_NullOrUndefined, _u(\"Array.prototype.findIndex\"));",
          "8127:         }",
          "8129:         int64 length;",
          "8130:         JavascriptArray * pArr = nullptr;",
          "8131:         RecyclableObject* obj = nullptr;",
          "8133:         JS_REENTRANT_UNLOCK(jsReentLock,",
          "8134:             TryGetArrayAndLength(args[0], scriptContext, _u(\"Array.prototype.findIndex\"), &pArr, &obj, &length));",
          "8135:             return JavascriptArray::FindHelper<true>(pArr, nullptr, obj, length, args, scriptContext);",
          "8136:     }",
          "8143:     Var JavascriptArray::EntryEntries(RecyclableObject* function, CallInfo callInfo, ...)",
          "8144:     {",
          "8145:         PROBE_STACK(function->GetScriptContext(), Js::Constants::MinStackDefault);",
          "8147:         ARGUMENTS(args, callInfo);",
          "8148:         ScriptContext* scriptContext = function->GetScriptContext();",
          "8149:         JS_REENTRANCY_LOCK(jsReentLock, scriptContext->GetThreadContext());",
          "8151:         Assert(!(callInfo.Flags & CallFlags_New));",
          "8153:         if (args.Info.Count == 0)",
          "8154:         {",
          "8155:             JavascriptError::ThrowTypeError(scriptContext, JSERR_This_NullOrUndefined, _u(\"Array.prototype.entries\"));",
          "8156:         }",
          "8158:         RecyclableObject* thisObj = nullptr;",
          "8159:         if (FALSE == JavascriptConversion::ToObject(args[0], scriptContext, &thisObj))",
          "8160:         {",
          "8161:             JavascriptError::ThrowTypeError(scriptContext, JSERR_This_NullOrUndefined, _u(\"Array.prototype.entries\"));",
          "8162:         }",
          "8164: #if ENABLE_COPYONACCESS_ARRAY",
          "8165:         JavascriptLibrary::CheckAndConvertCopyOnAccessNativeIntArray<Var>(thisObj);",
          "8166: #endif",
          "8167:         JS_REENTRANT_UNLOCK(jsReentLock,",
          "8168:             return scriptContext->GetLibrary()->CreateArrayIterator(thisObj, JavascriptArrayIteratorKind::KeyAndValue));",
          "8169:     }",
          "8175:     Var JavascriptArray::EntryKeys(RecyclableObject* function, CallInfo callInfo, ...)",
          "8176:     {",
          "8177:         PROBE_STACK(function->GetScriptContext(), Js::Constants::MinStackDefault);",
          "8179:         ARGUMENTS(args, callInfo);",
          "8180:         ScriptContext* scriptContext = function->GetScriptContext();",
          "8181:         JS_REENTRANCY_LOCK(jsReentLock, scriptContext->GetThreadContext());",
          "8183:         Assert(!(callInfo.Flags & CallFlags_New));",
          "8185:         if (args.Info.Count == 0)",
          "8186:         {",
          "8187:             JavascriptError::ThrowTypeError(scriptContext, JSERR_This_NullOrUndefined, _u(\"Array.prototype.keys\"));",
          "8188:         }",
          "8190:         RecyclableObject* thisObj = nullptr;",
          "8191:         if (FALSE == JavascriptConversion::ToObject(args[0], scriptContext, &thisObj))",
          "8192:         {",
          "8193:             JavascriptError::ThrowTypeError(scriptContext, JSERR_This_NullOrUndefined, _u(\"Array.prototype.keys\"));",
          "8194:         }",
          "8196: #if ENABLE_COPYONACCESS_ARRAY",
          "8197:         JavascriptLibrary::CheckAndConvertCopyOnAccessNativeIntArray<Var>(thisObj);",
          "8198: #endif",
          "8199:         JS_REENTRANT_UNLOCK(jsReentLock,",
          "8200:             return scriptContext->GetLibrary()->CreateArrayIterator(thisObj, JavascriptArrayIteratorKind::Key));",
          "8201:     }",
          "8207:     Var JavascriptArray::EntryValues(RecyclableObject* function, CallInfo callInfo, ...)",
          "8208:     {",
          "8209:         PROBE_STACK(function->GetScriptContext(), Js::Constants::MinStackDefault);",
          "8211:         ARGUMENTS(args, callInfo);",
          "8212:         ScriptContext* scriptContext = function->GetScriptContext();",
          "8213:         JS_REENTRANCY_LOCK(jsReentLock, scriptContext->GetThreadContext());",
          "8215:         Assert(!(callInfo.Flags & CallFlags_New));",
          "8217:         if (args.Info.Count == 0)",
          "8218:         {",
          "8219:             JavascriptError::ThrowTypeError(scriptContext, JSERR_This_NullOrUndefined, _u(\"Array.prototype.values\"));",
          "8220:         }",
          "8222:         RecyclableObject* thisObj = nullptr;",
          "8223:         if (FALSE == JavascriptConversion::ToObject(args[0], scriptContext, &thisObj))",
          "8224:         {",
          "8225:             JavascriptError::ThrowTypeError(scriptContext, JSERR_This_NullOrUndefined, _u(\"Array.prototype.values\"));",
          "8226:         }",
          "8228: #if ENABLE_COPYONACCESS_ARRAY",
          "8229:         JavascriptLibrary::CheckAndConvertCopyOnAccessNativeIntArray<Var>(thisObj);",
          "8230: #endif",
          "8231:         JS_REENTRANT_UNLOCK(jsReentLock,",
          "8232:             return scriptContext->GetLibrary()->CreateArrayIterator(thisObj, JavascriptArrayIteratorKind::Value));",
          "8233:     }",
          "8235:     Var JavascriptArray::EntryEvery(RecyclableObject* function, CallInfo callInfo, ...)",
          "8236:     {",
          "8237:         PROBE_STACK(function->GetScriptContext(), Js::Constants::MinStackDefault);",
          "8239:         ARGUMENTS(args, callInfo);",
          "8240:         ScriptContext* scriptContext = function->GetScriptContext();",
          "8241:         JS_REENTRANCY_LOCK(jsReentLock, scriptContext->GetThreadContext());",
          "8242:         AUTO_TAG_NATIVE_LIBRARY_ENTRY(function, callInfo, _u(\"Array.prototype.every\"));",
          "8244:         Assert(!(callInfo.Flags & CallFlags_New));",
          "8246:         CHAKRATEL_LANGSTATS_INC_BUILTINCOUNT(Array_Prototype_every);",
          "8248:         if (args.Info.Count == 0)",
          "8249:         {",
          "8250:             JavascriptError::ThrowTypeError(scriptContext, JSERR_This_NullOrUndefined, _u(\"Array.prototype.every\"));",
          "8251:         }",
          "8253:         BigIndex length;",
          "8254:         JavascriptArray* pArr = nullptr;",
          "8255:         RecyclableObject* obj = nullptr;",
          "8257:         JS_REENTRANT(jsReentLock, TryGetArrayAndLength(args[0], scriptContext, _u(\"Array.prototype.every\"), &pArr, &obj, &length));",
          "8259:         if (length.IsSmallIndex())",
          "8260:         {",
          "8261:             JS_REENTRANT_UNLOCK(jsReentLock, return JavascriptArray::EveryHelper(pArr, nullptr, obj, length.GetSmallIndex(), args, scriptContext));",
          "8262:         }",
          "8263:         Assert(pArr == nullptr || length.IsUint32Max()); // if pArr is not null lets make sure length is safe to cast, which will only happen if length is a uint32max",
          "8264:         JS_REENTRANT_UNLOCK(jsReentLock, return JavascriptArray::EveryHelper(pArr, nullptr, obj, length.GetBigIndex(), args, scriptContext));",
          "8265:     }",
          "8268:     template <typename T>",
          "8269:     Var JavascriptArray::EveryHelper(JavascriptArray* pArr, Js::TypedArrayBase* typedArrayBase, RecyclableObject* obj, T length, Arguments& args, ScriptContext* scriptContext)",
          "8270:     {",
          "8271:         JS_REENTRANCY_LOCK(jsReentLock, scriptContext->GetThreadContext());",
          "8273:         if (args.Info.Count < 2 || !JavascriptConversion::IsCallable(args[1]))",
          "8274:         {",
          "8276:             if (typedArrayBase != nullptr)",
          "8277:             {",
          "8278:                 JavascriptError::ThrowTypeError(scriptContext, JSERR_FunctionArgument_NeedFunction, _u(\"[TypedArray].prototype.every\"));",
          "8279:             }",
          "8280:             else",
          "8281:             {",
          "8282:                 JavascriptError::ThrowTypeError(scriptContext, JSERR_FunctionArgument_NeedFunction, _u(\"Array.prototype.every\"));",
          "8283:             }",
          "8284:         }",
          "8286:         RecyclableObject* callBackFn = RecyclableObject::FromVar(args[1]);",
          "8287:         Var thisArg = nullptr;",
          "8290:         if (args.Info.Count > 2)",
          "8291:         {",
          "8292:             thisArg = args[2];",
          "8293:         }",
          "8294:         else",
          "8295:         {",
          "8296:             thisArg = scriptContext->GetLibrary()->GetUndefined();",
          "8297:         }",
          "8300:         if (typedArrayBase == nullptr && pArr == nullptr && TypedArrayBase::Is(obj))",
          "8301:         {",
          "8302:             typedArrayBase = TypedArrayBase::FromVar(obj);",
          "8303:         }",
          "8305:         Var element = nullptr;",
          "8306:         Var testResult = nullptr;",
          "8308:         CallFlags flags = CallFlags_Value;",
          "8310:         if (pArr)",
          "8311:         {",
          "8312:             Assert(length <= UINT_MAX);",
          "8313:             for (uint32 k = 0; k < (uint32)length; k++)",
          "8314:             {",
          "8315:                 JS_REENTRANT(jsReentLock, BOOL gotItem = pArr->DirectGetItemAtFull(k, &element));",
          "8316:                 if (!gotItem)",
          "8317:                 {",
          "8318:                     continue;",
          "8319:                 }",
          "8321:                 JS_REENTRANT(jsReentLock,",
          "8322:                     testResult = CALL_FUNCTION(scriptContext->GetThreadContext(), callBackFn, CallInfo(flags, 4), thisArg,",
          "8323:                         element,",
          "8324:                         JavascriptNumber::ToVar(k, scriptContext),",
          "8325:                         pArr));",
          "8327:                 if (!JavascriptConversion::ToBoolean(testResult, scriptContext))",
          "8328:                 {",
          "8329:                     return scriptContext->GetLibrary()->GetFalse();",
          "8330:                 }",
          "8334:                 if (!JavascriptArray::Is(obj))",
          "8335:                 {",
          "8336:                     AssertOrFailFastMsg(ES5Array::Is(obj), \"The array should have been converted to an ES5Array\");",
          "8337:                     JS_REENTRANT_UNLOCK(jsReentLock, return JavascriptArray::EveryObjectHelper<T>(obj, length, k + 1, callBackFn, thisArg, scriptContext));",
          "8338:                 }",
          "8339:             }",
          "8340:         }",
          "8341:         else if (typedArrayBase)",
          "8342:         {",
          "8343:             AssertAndFailFast(TypedArrayBase::Is(typedArrayBase));",
          "8344:             uint32 end = (uint32)min(length, (T)typedArrayBase->GetLength());",
          "8346:             for (uint32 k = 0; k < end; k++)",
          "8347:             {",
          "8350:                 element = typedArrayBase->DirectGetItem(k);",
          "8352:                 JS_REENTRANT(jsReentLock,",
          "8353:                     testResult = CALL_FUNCTION(scriptContext->GetThreadContext(), callBackFn, CallInfo(flags, 4), thisArg,",
          "8354:                         element,",
          "8355:                         JavascriptNumber::ToVar(k, scriptContext),",
          "8356:                         typedArrayBase));",
          "8358:                 if (!JavascriptConversion::ToBoolean(testResult, scriptContext))",
          "8359:                 {",
          "8360:                     return scriptContext->GetLibrary()->GetFalse();",
          "8361:                 }",
          "8362:             }",
          "8363:         }",
          "8364:         else",
          "8365:         {",
          "8366:             JS_REENTRANT_UNLOCK(jsReentLock, return JavascriptArray::EveryObjectHelper<T>(obj, length, 0u, callBackFn, thisArg, scriptContext));",
          "8367:         }",
          "8369:         return scriptContext->GetLibrary()->GetTrue();",
          "8370:     }",
          "8372:     template <typename T>",
          "8373:     Var JavascriptArray::EveryObjectHelper(RecyclableObject* obj, T length, T start, RecyclableObject* callBackFn, Var thisArg, ScriptContext* scriptContext)",
          "8374:     {",
          "8375:         JS_REENTRANCY_LOCK(jsReentLock, scriptContext->GetThreadContext());",
          "8378:         CallFlags flags = CallFlags_Value;",
          "8379:         Var element = nullptr;",
          "8380:         Var testResult = nullptr;",
          "8382:         for (T k = start; k < length; k++)",
          "8383:         {",
          "8385:                 JS_REENTRANT(jsReentLock, BOOL hasItem = JavascriptOperators::HasItem(obj, k));",
          "8386:                 if (hasItem)",
          "8387:             {",
          "8388:                     JS_REENTRANT(jsReentLock,",
          "8389:                         element = JavascriptOperators::GetItem(obj, k, scriptContext),",
          "8390:                         testResult = CALL_FUNCTION(scriptContext->GetThreadContext(), callBackFn, CallInfo(flags, 4), thisArg,",
          "8391:                         element,",
          "8392:                         JavascriptNumber::ToVar(k, scriptContext),",
          "8393:                             obj));",
          "8395:                 if (!JavascriptConversion::ToBoolean(testResult, scriptContext))",
          "8396:                 {",
          "8397:                     return scriptContext->GetLibrary()->GetFalse();",
          "8398:                 }",
          "8399:             }",
          "8400:         }",
          "8402:         return scriptContext->GetLibrary()->GetTrue();",
          "8403:     }",
          "8406:     Var JavascriptArray::EntrySome(RecyclableObject* function, CallInfo callInfo, ...)",
          "8407:     {",
          "8408:         PROBE_STACK(function->GetScriptContext(), Js::Constants::MinStackDefault);",
          "8410:         ARGUMENTS(args, callInfo);",
          "8411:         ScriptContext* scriptContext = function->GetScriptContext();",
          "8412:         JS_REENTRANCY_LOCK(jsReentLock, scriptContext->GetThreadContext());",
          "8414:         AUTO_TAG_NATIVE_LIBRARY_ENTRY(function, callInfo, _u(\"Array.prototype.some\"));",
          "8416:         CHAKRATEL_LANGSTATS_INC_BUILTINCOUNT(Array_Prototype_some);",
          "8418:         Assert(!(callInfo.Flags & CallFlags_New));",
          "8420:         if (args.Info.Count == 0)",
          "8421:         {",
          "8422:             JavascriptError::ThrowTypeError(scriptContext, JSERR_This_NullOrUndefined, _u(\"Array.prototype.some\"));",
          "8423:         }",
          "8425:         BigIndex length;",
          "8426:         JavascriptArray* pArr = nullptr;",
          "8427:         RecyclableObject* obj = nullptr;",
          "8429:         JS_REENTRANT(jsReentLock, TryGetArrayAndLength(args[0], scriptContext, _u(\"Array.prototype.some\"), &pArr, &obj, &length));",
          "8431:         if (length.IsSmallIndex())",
          "8432:         {",
          "8433:             JS_REENTRANT_UNLOCK(jsReentLock, return JavascriptArray::SomeHelper(pArr, nullptr, obj, length.GetSmallIndex(), args, scriptContext));",
          "8434:         }",
          "8435:         Assert(pArr == nullptr || length.IsUint32Max()); // if pArr is not null lets make sure length is safe to cast, which will only happen if length is a uint32max",
          "8436:         JS_REENTRANT_UNLOCK(jsReentLock, return JavascriptArray::SomeHelper(pArr, nullptr, obj, length.GetBigIndex(), args, scriptContext));",
          "8437:     }",
          "8440:     template <typename T>",
          "8441:     Var JavascriptArray::SomeHelper(JavascriptArray* pArr, Js::TypedArrayBase* typedArrayBase, RecyclableObject* obj, T length, Arguments& args, ScriptContext* scriptContext)",
          "8442:     {",
          "8443:         JS_REENTRANCY_LOCK(jsReentLock, scriptContext->GetThreadContext());",
          "8445:         if (args.Info.Count < 2 || !JavascriptConversion::IsCallable(args[1]))",
          "8446:         {",
          "8448:             if (typedArrayBase != nullptr)",
          "8449:             {",
          "8450:                 JavascriptError::ThrowTypeError(scriptContext, JSERR_FunctionArgument_NeedFunction, _u(\"[TypedArray].prototype.some\"));",
          "8451:             }",
          "8452:             else",
          "8453:             {",
          "8454:                 JavascriptError::ThrowTypeError(scriptContext, JSERR_FunctionArgument_NeedFunction, _u(\"Array.prototype.some\"));",
          "8455:             }",
          "8456:         }",
          "8458:         RecyclableObject* callBackFn = RecyclableObject::FromVar(args[1]);",
          "8459:         Var thisArg = nullptr;",
          "8461:         if (args.Info.Count > 2)",
          "8462:         {",
          "8463:             thisArg = args[2];",
          "8464:         }",
          "8465:         else",
          "8466:         {",
          "8467:             thisArg = scriptContext->GetLibrary()->GetUndefined();",
          "8468:         }",
          "8471:         if (typedArrayBase == nullptr && pArr == nullptr && TypedArrayBase::Is(obj))",
          "8472:         {",
          "8473:             typedArrayBase = TypedArrayBase::FromVar(obj);",
          "8474:         }",
          "8477:         CallFlags flags = CallFlags_Value;",
          "8478:         Var element = nullptr;",
          "8479:         Var testResult = nullptr;",
          "8481:         if (pArr)",
          "8482:         {",
          "8483:             Assert(length <= UINT_MAX);",
          "8484:             for (uint32 k = 0; k < (uint32)length; k++)",
          "8485:             {",
          "8486:                 JS_REENTRANT(jsReentLock, BOOL gotItem = pArr->DirectGetItemAtFull(k, &element));",
          "8487:                 if (!gotItem)",
          "8488:                 {",
          "8489:                     continue;",
          "8490:                 }",
          "8492:                 JS_REENTRANT_UNLOCK(jsReentLock,",
          "8493:                     testResult = CALL_FUNCTION(scriptContext->GetThreadContext(), callBackFn, CallInfo(flags, 4), thisArg,",
          "8494:                         element,",
          "8495:                         JavascriptNumber::ToVar(k, scriptContext),",
          "8496:                         pArr));",
          "8498:                 if (JavascriptConversion::ToBoolean(testResult, scriptContext))",
          "8499:                 {",
          "8500:                     return scriptContext->GetLibrary()->GetTrue();",
          "8501:                 }",
          "8505:                 if (!JavascriptArray::Is(obj))",
          "8506:                 {",
          "8507:                     AssertOrFailFastMsg(ES5Array::Is(obj), \"The array should have been converted to an ES5Array\");",
          "8508:                     JS_REENTRANT_UNLOCK(jsReentLock, return JavascriptArray::SomeObjectHelper<T>(obj, length, k + 1, callBackFn, thisArg, scriptContext));",
          "8509:                 }",
          "8510:             }",
          "8511:         }",
          "8512:         else if (typedArrayBase)",
          "8513:         {",
          "8514:             AssertAndFailFast(TypedArrayBase::Is(typedArrayBase));",
          "8515:             uint32 end = (uint32)min(length, (T)typedArrayBase->GetLength());",
          "8517:             for (uint32 k = 0; k < end; k++)",
          "8518:             {",
          "8521:                 element = typedArrayBase->DirectGetItem(k);",
          "8523:                 JS_REENTRANT_UNLOCK(jsReentLock,",
          "8524:                     testResult = CALL_FUNCTION(scriptContext->GetThreadContext(), callBackFn, CallInfo(flags, 4), thisArg,",
          "8525:                         element,",
          "8526:                         JavascriptNumber::ToVar(k, scriptContext),",
          "8527:                         typedArrayBase));",
          "8529:                 if (JavascriptConversion::ToBoolean(testResult, scriptContext))",
          "8530:                 {",
          "8531:                     return scriptContext->GetLibrary()->GetTrue();",
          "8532:                 }",
          "8533:             }",
          "8534:         }",
          "8535:         else",
          "8536:         {",
          "8537:             JS_REENTRANT_UNLOCK(jsReentLock, return JavascriptArray::SomeObjectHelper<T>(obj, length, 0u, callBackFn, thisArg, scriptContext));",
          "8538:         }",
          "8540:         return scriptContext->GetLibrary()->GetFalse();",
          "8541:     }",
          "8543:     template <typename T>",
          "8544:     Var JavascriptArray::SomeObjectHelper(RecyclableObject* obj, T length, T start, RecyclableObject* callBackFn, Var thisArg, ScriptContext* scriptContext)",
          "8545:     {",
          "8546:         JS_REENTRANCY_LOCK(jsReentLock, scriptContext->GetThreadContext());",
          "8549:         CallFlags flags = CallFlags_Value;",
          "8550:         Var element = nullptr;",
          "8551:         Var testResult = nullptr;",
          "8553:         for (T k = start; k < length; k++)",
          "8554:         {",
          "8555:             JS_REENTRANT(jsReentLock, BOOL hasItem = JavascriptOperators::HasItem(obj, k));",
          "8556:             if (hasItem)",
          "8557:             {",
          "8558:                 JS_REENTRANT_UNLOCK(jsReentLock,",
          "8559:                     element = JavascriptOperators::GetItem(obj, k, scriptContext),",
          "8560:                     testResult = CALL_FUNCTION(scriptContext->GetThreadContext(), callBackFn, CallInfo(flags, 4), thisArg,",
          "8561:                         element,",
          "8562:                         JavascriptNumber::ToVar(k, scriptContext),",
          "8563:                         obj));",
          "8565:                 if (JavascriptConversion::ToBoolean(testResult, scriptContext))",
          "8566:                 {",
          "8567:                     return scriptContext->GetLibrary()->GetTrue();",
          "8568:                 }",
          "8569:             }",
          "8570:         }",
          "8572:         return scriptContext->GetLibrary()->GetFalse();",
          "8573:     }",
          "8575:     Var JavascriptArray::EntryForEach(RecyclableObject* function, CallInfo callInfo, ...)",
          "8576:     {",
          "8577:         PROBE_STACK(function->GetScriptContext(), Js::Constants::MinStackDefault);",
          "8579:         ARGUMENTS(args, callInfo);",
          "8580:         ScriptContext* scriptContext = function->GetScriptContext();",
          "8581:         JS_REENTRANCY_LOCK(jsReentLock, scriptContext->GetThreadContext());",
          "8583:         AUTO_TAG_NATIVE_LIBRARY_ENTRY(function, callInfo, _u(\"Array.prototype.forEach\"));",
          "8585:         CHAKRATEL_LANGSTATS_INC_BUILTINCOUNT(Array_Prototype_forEach)",
          "8587:         Assert(!(callInfo.Flags & CallFlags_New));",
          "8589:         if (args.Info.Count == 0)",
          "8590:         {",
          "8591:             JavascriptError::ThrowTypeError(scriptContext, JSERR_This_NullOrUndefined, _u(\"Array.prototype.forEach\"));",
          "8592:         }",
          "8594:         BigIndex length;",
          "8595:         JavascriptArray* pArr = nullptr;",
          "8596:         RecyclableObject* dynamicObject = nullptr;",
          "8597:         RecyclableObject* callBackFn = nullptr;",
          "8598:         Var thisArg = nullptr;",
          "8600:         JS_REENTRANT(jsReentLock, TryGetArrayAndLength(args[0], scriptContext, _u(\"Array.prototype.forEach\"), &pArr, &dynamicObject, &length));",
          "8602:         if (args.Info.Count < 2 || !JavascriptConversion::IsCallable(args[1]))",
          "8603:         {",
          "8604:             JavascriptError::ThrowTypeError(scriptContext, JSERR_FunctionArgument_NeedFunction, _u(\"Array.prototype.forEach\"));",
          "8605:         }",
          "8606:         callBackFn = RecyclableObject::FromVar(args[1]);",
          "8608:         if (args.Info.Count > 2)",
          "8609:         {",
          "8610:             thisArg = args[2];",
          "8611:         }",
          "8612:         else",
          "8613:         {",
          "8614:             thisArg = scriptContext->GetLibrary()->GetUndefined();",
          "8615:         }",
          "8618:         CallFlags flags = CallFlags_Value;",
          "8620:         auto fn32 = [dynamicObject, callBackFn, flags, thisArg,",
          "8621:             scriptContext](uint32 k, Var element)",
          "8622:         {",
          "8623:             CALL_FUNCTION(scriptContext->GetThreadContext(), callBackFn, CallInfo(flags, 4), thisArg,",
          "8624:                 element,",
          "8625:                 JavascriptNumber::ToVar(k, scriptContext),",
          "8626:                 dynamicObject);",
          "8627:         };",
          "8629:         auto fn64 = [dynamicObject, callBackFn, flags, thisArg,",
          "8630:             scriptContext](uint64 k, Var element)",
          "8631:         {",
          "8632:             CALL_FUNCTION(scriptContext->GetThreadContext(), callBackFn, CallInfo(flags, 4), thisArg,",
          "8633:                 element,",
          "8634:                 JavascriptNumber::ToVar(k, scriptContext),",
          "8635:                 dynamicObject);",
          "8636:         };",
          "8638:         if (pArr)",
          "8639:         {",
          "8640:             Assert(pArr == dynamicObject);",
          "8641:             JS_REENTRANT(jsReentLock, pArr->ForEachItemInRange<true>(0, length.IsUint32Max() ? MaxArrayLength : length.GetSmallIndex(), scriptContext, fn32));",
          "8642:         }",
          "8643:         else",
          "8644:         {",
          "8645:             if (length.IsSmallIndex())",
          "8646:             {",
          "8647:                 JS_REENTRANT(jsReentLock, TemplatedForEachItemInRange<true>(dynamicObject, 0u, length.GetSmallIndex(), scriptContext, fn32));",
          "8648:             }",
          "8649:             else",
          "8650:             {",
          "8651:                 JS_REENTRANT(jsReentLock, TemplatedForEachItemInRange<true>(dynamicObject, 0ui64, length.GetBigIndex(), scriptContext, fn64));",
          "8652:             }",
          "8653:         }",
          "8654:         return scriptContext->GetLibrary()->GetUndefined();",
          "8655:     }",
          "8657:     Var JavascriptArray::EntryCopyWithin(RecyclableObject* function, CallInfo callInfo, ...)",
          "8658:     {",
          "8659:         PROBE_STACK(function->GetScriptContext(), Js::Constants::MinStackDefault);",
          "8661:         ARGUMENTS(args, callInfo);",
          "8662:         ScriptContext* scriptContext = function->GetScriptContext();",
          "8663:         JS_REENTRANCY_LOCK(jsReentLock, scriptContext->GetThreadContext());",
          "8665:         Assert(!(callInfo.Flags & CallFlags_New));",
          "8667:         RecyclableObject* obj = nullptr;",
          "8668:         JavascriptArray* pArr = nullptr;",
          "8669:         int64 length;",
          "8671:         JS_REENTRANT_UNLOCK(jsReentLock, TryGetArrayAndLength(args[0], scriptContext, _u(\"Array.prototype.copyWithin\"), &pArr, &obj, &length));",
          "8672:             return JavascriptArray::CopyWithinHelper(pArr, nullptr, obj, length, args, scriptContext);",
          "8673:     }",
          "8676:     Var JavascriptArray::CopyWithinHelper(JavascriptArray* pArr, Js::TypedArrayBase* typedArrayBase, RecyclableObject* obj, int64 length, Arguments& args, ScriptContext* scriptContext)",
          "8677:     {",
          "8678:         JS_REENTRANCY_LOCK(jsReentLock, scriptContext->GetThreadContext());",
          "8680:         Assert(args.Info.Count > 0);",
          "8682:         JavascriptLibrary* library = scriptContext->GetLibrary();",
          "8683:         int64 fromVal = 0;",
          "8684:         int64 toVal = 0;",
          "8685:         int64 finalVal = length;",
          "8688:         if (typedArrayBase == nullptr && pArr == nullptr && TypedArrayBase::Is(obj))",
          "8689:         {",
          "8690:             typedArrayBase = TypedArrayBase::FromVar(obj);",
          "8691:         }",
          "8693:         if (args.Info.Count > 1)",
          "8694:         {",
          "8695:             JS_REENTRANT(jsReentLock, toVal = JavascriptArray::GetIndexFromVar(args[1], length, scriptContext));",
          "8697:             if (args.Info.Count > 2)",
          "8698:             {",
          "8699:                 JS_REENTRANT(jsReentLock, fromVal = JavascriptArray::GetIndexFromVar(args[2], length, scriptContext));",
          "8701:                 if (args.Info.Count > 3 && args[3] != library->GetUndefined())",
          "8702:                 {",
          "8703:                     JS_REENTRANT(jsReentLock, finalVal = JavascriptArray::GetIndexFromVar(args[3], length, scriptContext));",
          "8704:                 }",
          "8705:             }",
          "8706:         }",
          "8709:         if (finalVal <= fromVal || length <= toVal)",
          "8710:         {",
          "8711:             return obj;",
          "8712:         }",
          "8715:         Assert(finalVal > fromVal && length > toVal);",
          "8717:         int64 count = min(finalVal - fromVal, length - toVal);",
          "8720:         Assert(count > 0);",
          "8722:         int direction;",
          "8724:         if (fromVal < toVal && toVal < (fromVal + count))",
          "8725:         {",
          "8726:             direction = -1;",
          "8727:             fromVal += count - 1;",
          "8728:             toVal += count - 1;",
          "8729:         }",
          "8730:         else",
          "8731:         {",
          "8732:             direction = 1;",
          "8733:         }",
          "8736:         if (pArr && !JavascriptArray::Is(obj))",
          "8737:         {",
          "8738:             AssertOrFailFastMsg(ES5Array::Is(obj), \"The array should have been converted to an ES5Array\");",
          "8739:             pArr = nullptr;",
          "8740:         }",
          "8744:         if ((direction == -1 && (fromVal >= MaxArrayLength || toVal >= MaxArrayLength))",
          "8745:             || (((fromVal + count) > MaxArrayLength) || ((toVal + count) > MaxArrayLength)))",
          "8746:         {",
          "8747:             while (count > 0)",
          "8748:             {",
          "8749:                 Var index = JavascriptNumber::ToVar(fromVal, scriptContext);",
          "8751:                 JS_REENTRANT(jsReentLock, BOOL hasItem = JavascriptOperators::OP_HasItem(obj, index, scriptContext));",
          "8752:                 if (hasItem)",
          "8753:                 {",
          "8754:                     Var val = nullptr;",
          "8755:                     JS_REENTRANT(jsReentLock,",
          "8756:                         val = JavascriptOperators::OP_GetElementI(obj, index, scriptContext),",
          "8757:                         JavascriptOperators::OP_SetElementI(obj, JavascriptNumber::ToVar(toVal, scriptContext), val, scriptContext, PropertyOperation_ThrowIfNotExtensible));",
          "8758:                 }",
          "8759:                 else",
          "8760:                 {",
          "8761:                     JavascriptOperators::OP_DeleteElementI(obj, JavascriptNumber::ToVar(toVal, scriptContext), scriptContext, PropertyOperation_ThrowOnDeleteIfNotConfig);",
          "8762:                 }",
          "8764:                 fromVal += direction;",
          "8765:                 toVal += direction;",
          "8766:                 count--;",
          "8767:             }",
          "8768:         }",
          "8769:         else",
          "8770:         {",
          "8771:             Assert(fromVal < MaxArrayLength);",
          "8772:             Assert(toVal < MaxArrayLength);",
          "8773:             Assert(direction == -1 || (fromVal + count < MaxArrayLength && toVal + count < MaxArrayLength));",
          "8775:             uint32 fromIndex = static_cast<uint32>(fromVal);",
          "8776:             uint32 toIndex = static_cast<uint32>(toVal);",
          "8778:             while (count > 0)",
          "8779:             {",
          "8780:                 JS_REENTRANT(jsReentLock, BOOL hasItem = obj->HasItem(fromIndex));",
          "8781:                 if (hasItem)",
          "8782:                 {",
          "8783:                     if (typedArrayBase)",
          "8784:                     {",
          "8785:                         Var val = typedArrayBase->DirectGetItem(fromIndex);",
          "8787:                         JS_REENTRANT(jsReentLock, typedArrayBase->DirectSetItem(toIndex, val));",
          "8788:                     }",
          "8789:                     else if (pArr)",
          "8790:                     {",
          "8791:                         JS_REENTRANT(jsReentLock, Var val = pArr->DirectGetItem(fromIndex));",
          "8792:                         pArr->SetItem(toIndex, val, Js::PropertyOperation_ThrowIfNotExtensible);",
          "8794:                         if (!JavascriptArray::Is(obj))",
          "8795:                         {",
          "8796:                             AssertOrFailFastMsg(ES5Array::Is(obj), \"The array should have been converted to an ES5Array\");",
          "8797:                             pArr = nullptr;",
          "8798:                         }",
          "8799:                     }",
          "8800:                     else",
          "8801:                     {",
          "8802:                         Var val = nullptr;",
          "8803:                         JS_REENTRANT(jsReentLock,",
          "8804:                             val = JavascriptOperators::OP_GetElementI_UInt32(obj, fromIndex, scriptContext),",
          "8805:                             JavascriptOperators::OP_SetElementI_UInt32(obj, toIndex, val, scriptContext, PropertyOperation_ThrowIfNotExtensible));",
          "8806:                     }",
          "8807:                 }",
          "8808:                 else",
          "8809:                 {",
          "8810:                     obj->DeleteItem(toIndex, PropertyOperation_ThrowOnDeleteIfNotConfig);",
          "8811:                 }",
          "8813:                 fromIndex += direction;",
          "8814:                 toIndex += direction;",
          "8815:                 count--;",
          "8816:             }",
          "8817:         }",
          "8819:         return obj;",
          "8820:     }",
          "8822:     Var JavascriptArray::EntryFill(RecyclableObject* function, CallInfo callInfo, ...)",
          "8823:     {",
          "8824:         PROBE_STACK(function->GetScriptContext(), Js::Constants::MinStackDefault);",
          "8826:         ARGUMENTS(args, callInfo);",
          "8827:         ScriptContext* scriptContext = function->GetScriptContext();",
          "8828:         JS_REENTRANCY_LOCK(jsReentLock, scriptContext->GetThreadContext());",
          "8830:         Assert(!(callInfo.Flags & CallFlags_New));",
          "8832:         RecyclableObject* obj = nullptr;",
          "8833:         JavascriptArray* pArr = nullptr;",
          "8834:         int64 length;",
          "8836:         JS_REENTRANT_UNLOCK(jsReentLock,",
          "8837:             TryGetArrayAndLength(args[0], scriptContext, _u(\"Array.prototype.fill\"), &pArr, &obj, &length));",
          "8838:             return JavascriptArray::FillHelper(pArr, nullptr, obj, length, args, scriptContext);",
          "8839:     }",
          "8842:     Var JavascriptArray::FillHelper(JavascriptArray* pArr, Js::TypedArrayBase* typedArrayBase, RecyclableObject* obj, int64 length, Arguments& args, ScriptContext* scriptContext)",
          "8843:     {",
          "8844:         JS_REENTRANCY_LOCK(jsReentLock, scriptContext->GetThreadContext());",
          "8846:         Assert(args.Info.Count > 0);",
          "8848:         JavascriptLibrary* library = scriptContext->GetLibrary();",
          "8851:         if (typedArrayBase == nullptr && pArr == nullptr && TypedArrayBase::Is(obj))",
          "8852:         {",
          "8853:             typedArrayBase = TypedArrayBase::FromVar(obj);",
          "8854:         }",
          "8856:         Var fillValue;",
          "8858:         if (args.Info.Count > 1)",
          "8859:         {",
          "8860:             fillValue = args[1];",
          "8861:         }",
          "8862:         else",
          "8863:         {",
          "8864:             fillValue = library->GetUndefined();",
          "8865:         }",
          "8867:         int64 k = 0;",
          "8868:         int64 finalVal = length;",
          "8870:         if (args.Info.Count > 2)",
          "8871:         {",
          "8872:             JS_REENTRANT_UNLOCK(jsReentLock, k = JavascriptArray::GetIndexFromVar(args[2], length, scriptContext));",
          "8874:             if (args.Info.Count > 3 && !JavascriptOperators::IsUndefinedObject(args[3]))",
          "8875:             {",
          "8876:                 JS_REENTRANT_UNLOCK(jsReentLock, finalVal = JavascriptArray::GetIndexFromVar(args[3], length, scriptContext));",
          "8877:             }",
          "8881:             if (pArr && !JavascriptArray::Is(obj))",
          "8882:             {",
          "8883:                 AssertOrFailFastMsg(ES5Array::Is(obj), \"The array should have been converted to an ES5Array\");",
          "8884:                 pArr = nullptr;",
          "8885:             }",
          "8886:         }",
          "8888:         if (k < MaxArrayLength)",
          "8889:         {",
          "8890:             int64 end = min<int64>(finalVal, MaxArrayLength);",
          "8891:             uint32 u32k = static_cast<uint32>(k);",
          "8893:             while (u32k < end)",
          "8894:             {",
          "8895:                 if (typedArrayBase)",
          "8896:                 {",
          "8897:                     JS_REENTRANT(jsReentLock, typedArrayBase->DirectSetItem(u32k, fillValue));",
          "8898:                 }",
          "8899:                 else if (pArr)",
          "8900:                 {",
          "8901:                     pArr->SetItem(u32k, fillValue, PropertyOperation_ThrowIfNotExtensible);",
          "8902:                 }",
          "8903:                 else",
          "8904:                 {",
          "8905:                     JS_REENTRANT(jsReentLock,",
          "8906:                         JavascriptOperators::OP_SetElementI_UInt32(obj, u32k, fillValue, scriptContext, Js::PropertyOperation_ThrowIfNotExtensible));",
          "8907:                 }",
          "8909:                 u32k++;",
          "8910:             }",
          "8912:             BigIndex dstIndex = MaxArrayLength;",
          "8914:             for (int64 i = end; i < finalVal; ++i)",
          "8915:             {",
          "8916:                 if (pArr)",
          "8917:                 {",
          "8918:                     pArr->DirectSetItemAt(dstIndex, fillValue);",
          "8919:                     ++dstIndex;",
          "8920:                 }",
          "8921:                 else",
          "8922:                 {",
          "8923:                     JS_REENTRANT(jsReentLock,",
          "8924:                         JavascriptOperators::OP_SetElementI(obj, JavascriptNumber::ToVar(i, scriptContext), fillValue, scriptContext, Js::PropertyOperation_ThrowIfNotExtensible));",
          "8925:                 }",
          "8926:             }",
          "8927:         }",
          "8928:         else",
          "8929:         {",
          "8930:             BigIndex dstIndex = static_cast<uint64>(k);",
          "8932:             for (int64 i = k; i < finalVal; i++)",
          "8933:             {",
          "8934:                 if (pArr)",
          "8935:                 {",
          "8936:                     pArr->DirectSetItemAt(dstIndex, fillValue);",
          "8937:                     ++dstIndex;",
          "8938:                 }",
          "8939:                 else",
          "8940:                 {",
          "8941:                     JS_REENTRANT(jsReentLock,",
          "8942:                         JavascriptOperators::OP_SetElementI(obj, JavascriptNumber::ToVar(i, scriptContext), fillValue, scriptContext, Js::PropertyOperation_ThrowIfNotExtensible));",
          "8943:                 }",
          "8944:             }",
          "8945:         }",
          "8947:         return obj;",
          "8948:     }",
          "8951:     Var JavascriptArray::EntryMap(RecyclableObject* function, CallInfo callInfo, ...)",
          "8952:     {",
          "8953:         PROBE_STACK(function->GetScriptContext(), Js::Constants::MinStackDefault);",
          "8955:         ARGUMENTS(args, callInfo);",
          "8956:         ScriptContext* scriptContext = function->GetScriptContext();",
          "8957:         JS_REENTRANCY_LOCK(jsReentLock, scriptContext->GetThreadContext());",
          "8958:         AUTO_TAG_NATIVE_LIBRARY_ENTRY(function, callInfo, _u(\"Array.prototype.map\"));",
          "8960:         CHAKRATEL_LANGSTATS_INC_BUILTINCOUNT(Array_Prototype_map);",
          "8962:         Assert(!(callInfo.Flags & CallFlags_New));",
          "8964:         if (args.Info.Count == 0)",
          "8965:         {",
          "8966:             JavascriptError::ThrowTypeError(scriptContext, JSERR_This_NullOrUndefined, _u(\"Array.prototype.map\"));",
          "8967:         }",
          "8969:         BigIndex length;",
          "8970:         JavascriptArray* pArr = nullptr;",
          "8971:         RecyclableObject* obj = nullptr;",
          "8973:         JS_REENTRANT(jsReentLock, TryGetArrayAndLength(args[0], scriptContext, _u(\"Array.prototype.map\"), &pArr, &obj, &length));",
          "8975:         if (length.IsSmallIndex())",
          "8976:         {",
          "8977:             JS_REENTRANT_UNLOCK(jsReentLock, return JavascriptArray::MapHelper(pArr, nullptr, obj, length.GetSmallIndex(), args, scriptContext));",
          "8978:         }",
          "8979:         Assert(pArr == nullptr || length.IsUint32Max()); // if pArr is not null lets make sure length is safe to cast, which will only happen if length is a uint32max",
          "8980:         JS_REENTRANT_UNLOCK(jsReentLock, return JavascriptArray::MapHelper(pArr, nullptr, obj, length.GetBigIndex(), args, scriptContext));",
          "8981:     }",
          "8984:     template<typename T>",
          "8985:     Var JavascriptArray::MapHelper(JavascriptArray* pArr, Js::TypedArrayBase* typedArrayBase, RecyclableObject* obj, T length, Arguments& args, ScriptContext* scriptContext)",
          "8986:     {",
          "8987:         JS_REENTRANCY_LOCK(jsReentLock, scriptContext->GetThreadContext());",
          "8989:         RecyclableObject* newObj = nullptr;",
          "8990:         JavascriptArray* newArr = nullptr;",
          "8991:         bool isTypedArrayEntryPoint = typedArrayBase != nullptr;",
          "8992:         bool isBuiltinArrayCtor = true;",
          "8994:         if (args.Info.Count < 2 || !JavascriptConversion::IsCallable(args[1]))",
          "8995:         {",
          "8996:             if (isTypedArrayEntryPoint)",
          "8997:             {",
          "8998:                 JavascriptError::ThrowTypeError(scriptContext, JSERR_FunctionArgument_NeedFunction, _u(\"[TypedArray].prototype.map\"));",
          "8999:             }",
          "9000:             else",
          "9001:             {",
          "9002:                 JavascriptError::ThrowTypeError(scriptContext, JSERR_FunctionArgument_NeedFunction, _u(\"Array.prototype.map\"));",
          "9003:             }",
          "9004:         }",
          "9006:         RecyclableObject* callBackFn = RecyclableObject::FromVar(args[1]);",
          "9007:         Var thisArg;",
          "9009:         if (args.Info.Count > 2)",
          "9010:         {",
          "9011:             thisArg = args[2];",
          "9012:         }",
          "9013:         else",
          "9014:         {",
          "9015:             thisArg = scriptContext->GetLibrary()->GetUndefined();",
          "9016:         }",
          "9019:         if (!isTypedArrayEntryPoint && pArr == nullptr && TypedArrayBase::Is(obj))",
          "9020:         {",
          "9021:             typedArrayBase = TypedArrayBase::FromVar(obj);",
          "9022:         }",
          "9026:         if (isTypedArrayEntryPoint)",
          "9027:         {",
          "9028:             JS_REENTRANT(jsReentLock,",
          "9029:                 Var constructor = JavascriptOperators::SpeciesConstructor(",
          "9030:                     typedArrayBase, TypedArrayBase::GetDefaultConstructor(args[0], scriptContext), scriptContext));",
          "9032:             isBuiltinArrayCtor = false;",
          "9034:             Assert(JavascriptOperators::IsConstructor(constructor));",
          "9036:             Js::Var constructorArgs[] = { constructor, JavascriptNumber::ToVar(length, scriptContext) };",
          "9037:             Js::CallInfo constructorCallInfo(Js::CallFlags_New, _countof(constructorArgs));",
          "9038:             JS_REENTRANT(jsReentLock, newObj = RecyclableObject::FromVar(TypedArrayBase::TypedArrayCreate(constructor, &Js::Arguments(constructorCallInfo, constructorArgs), (uint32)length, scriptContext)));",
          "9039:         }",
          "9041:         else if (pArr == nullptr || scriptContext->GetConfig()->IsES6SpeciesEnabled())",
          "9042:         {",
          "9043:             JS_REENTRANT(jsReentLock, newObj = ArraySpeciesCreate(obj, length, scriptContext, nullptr, nullptr, &isBuiltinArrayCtor));",
          "9044:         }",
          "9046:         if (newObj == nullptr)",
          "9047:         {",
          "9048:             if (length > UINT_MAX)",
          "9049:             {",
          "9050:                 JavascriptError::ThrowRangeError(scriptContext, JSERR_ArrayLengthConstructIncorrect);",
          "9051:             }",
          "9052:             newArr = scriptContext->GetLibrary()->CreateArray(static_cast<uint32>(length));",
          "9053:             newArr->EnsureHead<Var>();",
          "9054:             newObj = newArr;",
          "9055:         }",
          "9056:         else",
          "9057:         {",
          "9059:             if (JavascriptArray::Is(newObj))",
          "9060:             {",
          "9061: #if ENABLE_COPYONACCESS_ARRAY",
          "9062:                 JavascriptLibrary::CheckAndConvertCopyOnAccessNativeIntArray<Var>(newObj);",
          "9063: #endif",
          "9064:                 newArr = JavascriptArray::FromVar(newObj);",
          "9065:             }",
          "9066:         }",
          "9068:         Var element = nullptr;",
          "9069:         Var mappedValue = nullptr;",
          "9071:         CallFlags callBackFnflags = CallFlags_Value;",
          "9072:         CallInfo callBackFnInfo = CallInfo(callBackFnflags, 4);",
          "9075:         Assert(newObj);",
          "9079:         if (pArr && !JavascriptArray::Is(obj))",
          "9080:         {",
          "9081:             AssertOrFailFastMsg(ES5Array::Is(obj), \"The array should have been converted to an ES5Array\");",
          "9082:             pArr = nullptr;",
          "9083:         }",
          "9085:         if (pArr != nullptr)",
          "9086:         {",
          "9088:             Assert(length <= UINT_MAX);",
          "9089:             for (uint32 k = 0; k < (uint32)length; k++)",
          "9090:             {",
          "9091:                 JS_REENTRANT(jsReentLock, BOOL gotItem = pArr->DirectGetItemAtFull(k, &element));",
          "9092:                 if (!gotItem)",
          "9093:                 {",
          "9094:                     continue;",
          "9095:                 }",
          "9097:                 JS_REENTRANT(jsReentLock,",
          "9098:                     mappedValue = CALL_FUNCTION(scriptContext->GetThreadContext(), callBackFn, callBackFnInfo, thisArg,",
          "9099:                         element,",
          "9100:                         JavascriptNumber::ToVar(k, scriptContext),",
          "9101:                         pArr));",
          "9104:                 if (newArr && isBuiltinArrayCtor)",
          "9105:                 {",
          "9106:                     newArr->DirectSetItemAt(k, mappedValue);",
          "9107:                 }",
          "9108:                 else",
          "9109:                 {",
          "9110:                     JS_REENTRANT(jsReentLock, ThrowErrorOnFailure(JavascriptArray::SetArrayLikeObjects(newObj, k, mappedValue), scriptContext, k));",
          "9111:                 }",
          "9115:                 if (!JavascriptArray::Is(obj))",
          "9116:                 {",
          "9117:                     AssertOrFailFastMsg(ES5Array::Is(obj), \"The array should have been converted to an ES5Array\");",
          "9118:                     JS_REENTRANT_UNLOCK(jsReentLock, return JavascriptArray::MapObjectHelper<T>(obj, length, k + 1, newObj, newArr, isBuiltinArrayCtor, callBackFn, thisArg, scriptContext));",
          "9119:                 }",
          "9120:             }",
          "9121:         }",
          "9122:         else if (typedArrayBase != nullptr)",
          "9123:         {",
          "9124:             AssertAndFailFast(TypedArrayBase::Is(typedArrayBase));",
          "9127:             TypedArrayBase* newTypedArray = nullptr;",
          "9129:             if (TypedArrayBase::Is(newObj))",
          "9130:             {",
          "9131:                 newTypedArray = TypedArrayBase::FromVar(newObj);",
          "9132:             }",
          "9133:             else",
          "9134:             {",
          "9135:                 AssertAndFailFast(newArr != nullptr);",
          "9136:             }",
          "9138:             Assert(length <= UINT_MAX);",
          "9139:             uint32 end = (uint32)min(length, (T)typedArrayBase->GetLength());",
          "9141:             for (uint32 k = 0; k < end; k++)",
          "9142:             {",
          "9145:                 element = typedArrayBase->DirectGetItem(k);",
          "9146:                 JS_REENTRANT(jsReentLock,",
          "9147:                     mappedValue = CALL_FUNCTION(scriptContext->GetThreadContext(), callBackFn, callBackFnInfo, thisArg,",
          "9148:                         element,",
          "9149:                         JavascriptNumber::ToVar(k, scriptContext),",
          "9150:                         obj));",
          "9153:                 if (newTypedArray)",
          "9154:                 {",
          "9155:                     JS_REENTRANT(jsReentLock, newTypedArray->DirectSetItem(k, mappedValue));",
          "9156:                 }",
          "9157:                 else",
          "9158:                 {",
          "9159:                     newArr->SetItem(k, mappedValue, PropertyOperation_None);",
          "9160:                 }",
          "9161:             }",
          "9162:         }",
          "9163:         else",
          "9164:         {",
          "9165:             JS_REENTRANT_UNLOCK(jsReentLock, return JavascriptArray::MapObjectHelper<T>(obj, length, 0u, newObj, newArr, isBuiltinArrayCtor, callBackFn, thisArg, scriptContext));",
          "9166:         }",
          "9168: #ifdef VALIDATE_ARRAY",
          "9169:         if (JavascriptArray::Is(newObj))",
          "9170:         {",
          "9171:             newArr->ValidateArray();",
          "9172:         }",
          "9173: #endif",
          "9175:         return newObj;",
          "9176:     }",
          "9178:     template<typename T>",
          "9179:     Var JavascriptArray::MapObjectHelper(RecyclableObject* obj, T length, T start, RecyclableObject* newObj, JavascriptArray* newArr,",
          "9180:         bool isBuiltinArrayCtor, RecyclableObject* callBackFn, Var thisArg, ScriptContext* scriptContext)",
          "9181:     {",
          "9182:         JS_REENTRANCY_LOCK(jsReentLock, scriptContext->GetThreadContext());",
          "9185:         CallFlags callBackFnflags = CallFlags_Value;",
          "9186:         CallInfo callBackFnInfo = CallInfo(callBackFnflags, 4);",
          "9187:         Var element = nullptr;",
          "9188:         Var mappedValue = nullptr;",
          "9190:         for (T k = start; k < length; k++)",
          "9191:         {",
          "9192:                 JS_REENTRANT(jsReentLock, BOOL hasItem = JavascriptOperators::HasItem(obj, k));",
          "9193:                 if (hasItem)",
          "9194:             {",
          "9195:                     JS_REENTRANT(jsReentLock,",
          "9196:                         element = JavascriptOperators::GetItem(obj, k, scriptContext),",
          "9197:                         mappedValue = CALL_FUNCTION(scriptContext->GetThreadContext(), callBackFn, callBackFnInfo, thisArg,",
          "9198:                         element,",
          "9199:                         JavascriptNumber::ToVar(k, scriptContext),",
          "9200:                             obj));",
          "9202:                 if (newArr && isBuiltinArrayCtor)",
          "9203:                 {",
          "9204:                     newArr->SetItem((uint32)k, mappedValue, PropertyOperation_None);",
          "9205:                 }",
          "9206:                 else",
          "9207:                 {",
          "9208:                     JS_REENTRANT(jsReentLock, ThrowErrorOnFailure(JavascriptArray::SetArrayLikeObjects(newObj, BigIndex(k), mappedValue), scriptContext, BigIndex(k)));",
          "9209:                 }",
          "9210:             }",
          "9211:         }",
          "9213: #ifdef VALIDATE_ARRAY",
          "9214:         if (JavascriptArray::Is(newObj))",
          "9215:         {",
          "9216:             newArr->ValidateArray();",
          "9217:         }",
          "9218: #endif",
          "9220:         return newObj;",
          "9221:     }",
          "9223:     Var JavascriptArray::EntryFilter(RecyclableObject* function, CallInfo callInfo, ...)",
          "9224:     {",
          "9225:         PROBE_STACK(function->GetScriptContext(), Js::Constants::MinStackDefault);",
          "9227:         ARGUMENTS(args, callInfo);",
          "9228:         ScriptContext* scriptContext = function->GetScriptContext();",
          "9229:         JS_REENTRANCY_LOCK(jsReentLock, scriptContext->GetThreadContext());",
          "9231:         AUTO_TAG_NATIVE_LIBRARY_ENTRY(function, callInfo, _u(\"Array.prototype.filter\"));",
          "9233:         CHAKRATEL_LANGSTATS_INC_BUILTINCOUNT(Array_Prototype_filter);",
          "9235:         Assert(!(callInfo.Flags & CallFlags_New));",
          "9236:         if (args.Info.Count == 0)",
          "9237:         {",
          "9238:             JavascriptError::ThrowTypeError(scriptContext, JSERR_This_NullOrUndefined, _u(\"Array.prototype.filter\"));",
          "9239:         }",
          "9241:         BigIndex length;",
          "9242:         JavascriptArray* pArr = nullptr;",
          "9243:         RecyclableObject* obj = nullptr;",
          "9245:         JS_REENTRANT(jsReentLock, TryGetArrayAndLength(args[0], scriptContext, _u(\"Array.prototype.filter\"), &pArr, &obj, &length));",
          "9247:         if (length.IsSmallIndex())",
          "9248:         {",
          "9249:             JS_REENTRANT_UNLOCK(jsReentLock, return JavascriptArray::FilterHelper(pArr, obj, length.GetSmallIndex(), args, scriptContext));",
          "9250:         }",
          "9252:         JS_REENTRANT_UNLOCK(jsReentLock, return JavascriptArray::FilterHelper(pArr, obj, length.GetBigIndex(), args, scriptContext));",
          "9253:     }",
          "9255:     template <typename T>",
          "9256:     Var JavascriptArray::FilterHelper(JavascriptArray* pArr, RecyclableObject* obj, T length, Arguments& args, ScriptContext* scriptContext)",
          "9257:     {",
          "9258:         JS_REENTRANCY_LOCK(jsReentLock, scriptContext->GetThreadContext());",
          "9260:         if (args.Info.Count < 2 || !JavascriptConversion::IsCallable(args[1]))",
          "9261:         {",
          "9262:             JavascriptError::ThrowTypeError(scriptContext, JSERR_FunctionArgument_NeedFunction, _u(\"Array.prototype.filter\"));",
          "9263:         }",
          "9265:         RecyclableObject* callBackFn = RecyclableObject::FromVar(args[1]);",
          "9266:         Var thisArg = nullptr;",
          "9268:         if (args.Info.Count > 2)",
          "9269:         {",
          "9270:             thisArg = args[2];",
          "9271:         }",
          "9272:         else",
          "9273:         {",
          "9274:             thisArg = scriptContext->GetLibrary()->GetUndefined();",
          "9275:         }",
          "9278:         bool isBuiltinArrayCtor = true;",
          "9279:         JS_REENTRANT(jsReentLock, RecyclableObject* newObj = ArraySpeciesCreate(obj, 0, scriptContext, nullptr, nullptr, &isBuiltinArrayCtor));",
          "9280:         JavascriptArray* newArr = nullptr;",
          "9282:         if (newObj == nullptr)",
          "9283:         {",
          "9284:             newArr = scriptContext->GetLibrary()->CreateArray(0);",
          "9285:             newArr->EnsureHead<Var>();",
          "9286:             newObj = newArr;",
          "9287:         }",
          "9288:         else",
          "9289:         {",
          "9291:             if (JavascriptArray::Is(newObj))",
          "9292:             {",
          "9293: #if ENABLE_COPYONACCESS_ARRAY",
          "9294:                 JavascriptLibrary::CheckAndConvertCopyOnAccessNativeIntArray<Var>(newObj);",
          "9295: #endif",
          "9296:                 newArr = JavascriptArray::FromVar(newObj);",
          "9297:             }",
          "9298:         }",
          "9302:         if (pArr && !JavascriptArray::Is(obj))",
          "9303:         {",
          "9304:             AssertOrFailFastMsg(ES5Array::Is(obj), \"The array should have been converted to an ES5Array\");",
          "9305:             pArr = nullptr;",
          "9306:         }",
          "9308:         Var element = nullptr;",
          "9309:         Var selected = nullptr;",
          "9311:         if (pArr)",
          "9312:         {",
          "9313:             Assert(length <= MaxArrayLength);",
          "9314:             uint32 i = 0;",
          "9316:             Assert(length <= UINT_MAX);",
          "9317:             for (uint32 k = 0; k < (uint32)length; k++)",
          "9318:             {",
          "9319:                 JS_REENTRANT(jsReentLock, BOOL gotItem = pArr->DirectGetItemAtFull(k, &element));",
          "9320:                 if (!gotItem)",
          "9321:                 {",
          "9322:                     continue;",
          "9323:                 }",
          "9325:                 JS_REENTRANT(jsReentLock,",
          "9326:                     selected = CALL_ENTRYPOINT(scriptContext->GetThreadContext(),",
          "9327:                         callBackFn->GetEntryPoint(), callBackFn, CallInfo(CallFlags_Value, 4),",
          "9328:                         thisArg,",
          "9329:                         element,",
          "9330:                         JavascriptNumber::ToVar(k, scriptContext),",
          "9331:                         pArr));",
          "9333:                 if (JavascriptConversion::ToBoolean(selected, scriptContext))",
          "9334:                 {",
          "9336:                     if (newArr && isBuiltinArrayCtor)",
          "9337:                     {",
          "9338:                         newArr->DirectSetItemAt(i, element);",
          "9339:                     }",
          "9340:                     else",
          "9341:                     {",
          "9342:                         JS_REENTRANT(jsReentLock, ThrowErrorOnFailure(JavascriptArray::SetArrayLikeObjects(newObj, i, element), scriptContext, i));",
          "9343:                     }",
          "9344:                     ++i;",
          "9345:                 }",
          "9349:                 if (!JavascriptArray::Is(obj))",
          "9350:                 {",
          "9351:                     AssertOrFailFastMsg(ES5Array::Is(obj), \"The array should have been converted to an ES5Array\");",
          "9352:                     JS_REENTRANT_UNLOCK(jsReentLock, return JavascriptArray::FilterObjectHelper<T>(obj, length, k + 1, newArr, newObj, i, callBackFn, thisArg, scriptContext));",
          "9353:                 }",
          "9354:             }",
          "9355:         }",
          "9356:         else",
          "9357:         {",
          "9358:             JS_REENTRANT_UNLOCK(jsReentLock, return JavascriptArray::FilterObjectHelper<T>(obj, length, 0u, newArr, newObj, 0u, callBackFn, thisArg, scriptContext));",
          "9359:         }",
          "9361: #ifdef VALIDATE_ARRAY",
          "9362:         if (newArr)",
          "9363:         {",
          "9364:             newArr->ValidateArray();",
          "9365:         }",
          "9366: #endif",
          "9368:         return newObj;",
          "9369:     }",
          "9371:     template <typename T>",
          "9372:     Var JavascriptArray::FilterObjectHelper(RecyclableObject* obj, T length, T start, JavascriptArray* newArr, RecyclableObject* newObj, T newStart,",
          "9373:         RecyclableObject* callBackFn, Var thisArg, ScriptContext* scriptContext)",
          "9374:     {",
          "9375:         JS_REENTRANCY_LOCK(jsReentLock, scriptContext->GetThreadContext());",
          "9377:         Var element = nullptr;",
          "9378:         Var selected = nullptr;",
          "9379:         BigIndex i = BigIndex(newStart);",
          "9381:         for (T k = start; k < length; k++)",
          "9382:         {",
          "9383:                 JS_REENTRANT(jsReentLock, BOOL hasItem = JavascriptOperators::HasItem(obj, k));",
          "9384:                 if (hasItem)",
          "9385:             {",
          "9386:                     JS_REENTRANT(jsReentLock,",
          "9387:                         element = JavascriptOperators::GetItem(obj, k, scriptContext),",
          "9388:                         selected = CALL_ENTRYPOINT(scriptContext->GetThreadContext(),",
          "9389:                             callBackFn->GetEntryPoint(), callBackFn, CallInfo(CallFlags_Value, 4),",
          "9390:                         thisArg,",
          "9391:                         element,",
          "9392:                         JavascriptNumber::ToVar(k, scriptContext),",
          "9393:                             obj));",
          "9395:                 if (JavascriptConversion::ToBoolean(selected, scriptContext))",
          "9396:                 {",
          "9397:                     if (newArr)",
          "9398:                     {",
          "9399:                         newArr->DirectSetItemAt(i, element);",
          "9400:                     }",
          "9401:                     else",
          "9402:                     {",
          "9403:                             JS_REENTRANT(jsReentLock, ThrowErrorOnFailure(JavascriptArray::SetArrayLikeObjects(newObj, i, element), scriptContext, i));",
          "9404:                     }",
          "9406:                     ++i;",
          "9407:                 }",
          "9408:             }",
          "9409:         }",
          "9411: #ifdef VALIDATE_ARRAY",
          "9412:         if (newArr)",
          "9413:         {",
          "9414:             newArr->ValidateArray();",
          "9415:         }",
          "9416: #endif",
          "9418:         return newObj;",
          "9419:     }",
          "9421:     Var JavascriptArray::EntryReduce(RecyclableObject* function, CallInfo callInfo, ...)",
          "9422:     {",
          "9423:         PROBE_STACK(function->GetScriptContext(), Js::Constants::MinStackDefault);",
          "9425:         ARGUMENTS(args, callInfo);",
          "9426:         ScriptContext* scriptContext = function->GetScriptContext();",
          "9427:         JS_REENTRANCY_LOCK(jsReentLock, scriptContext->GetThreadContext());",
          "9429:         AUTO_TAG_NATIVE_LIBRARY_ENTRY(function, callInfo, _u(\"Array.prototype.reduce\"));",
          "9431:         CHAKRATEL_LANGSTATS_INC_BUILTINCOUNT(Array_Prototype_reduce);",
          "9433:         Assert(!(callInfo.Flags & CallFlags_New));",
          "9435:         if (args.Info.Count == 0)",
          "9436:         {",
          "9437:             JavascriptError::ThrowTypeError(scriptContext, JSERR_This_NullOrUndefined, _u(\"Array.prototype.reduce\"));",
          "9438:         }",
          "9440:         BigIndex length;",
          "9441:         JavascriptArray * pArr = nullptr;",
          "9442:         RecyclableObject* obj = nullptr;",
          "9443:         JS_REENTRANT(jsReentLock, TryGetArrayAndLength(args[0], scriptContext, _u(\"Array.prototype.reduce\"), &pArr, &obj, &length));",
          "9445:         if (length.IsSmallIndex())",
          "9446:         {",
          "9447:             JS_REENTRANT_UNLOCK(jsReentLock, return JavascriptArray::ReduceHelper(pArr, nullptr, obj, length.GetSmallIndex(), args, scriptContext));",
          "9448:         }",
          "9450:         JS_REENTRANT_UNLOCK(jsReentLock, return JavascriptArray::ReduceHelper(pArr, nullptr, obj, length.GetBigIndex(), args, scriptContext));",
          "9451:     }",
          "9454:     template <typename T>",
          "9455:     Var JavascriptArray::ReduceHelper(JavascriptArray* pArr, Js::TypedArrayBase* typedArrayBase, RecyclableObject* obj, T length, Arguments& args, ScriptContext* scriptContext)",
          "9456:     {",
          "9457:         JS_REENTRANCY_LOCK(jsReentLock, scriptContext->GetThreadContext());",
          "9459:         if (args.Info.Count < 2 || !JavascriptConversion::IsCallable(args[1]))",
          "9460:         {",
          "9461:             if (typedArrayBase != nullptr)",
          "9462:             {",
          "9463:                 JavascriptError::ThrowTypeError(scriptContext, JSERR_FunctionArgument_NeedFunction, _u(\"[TypedArray].prototype.reduce\"));",
          "9464:             }",
          "9465:             else",
          "9466:             {",
          "9467:                 JavascriptError::ThrowTypeError(scriptContext, JSERR_FunctionArgument_NeedFunction, _u(\"Array.prototype.reduce\"));",
          "9468:             }",
          "9469:         }",
          "9472:         if (typedArrayBase == nullptr && pArr == nullptr && TypedArrayBase::Is(obj))",
          "9473:         {",
          "9474:             typedArrayBase = TypedArrayBase::FromVar(obj);",
          "9475:         }",
          "9477:         T k = 0;",
          "9478:         RecyclableObject* callBackFn = RecyclableObject::FromVar(args[1]);",
          "9479:         Var accumulator = nullptr;",
          "9480:         Var element = nullptr;",
          "9482:         if (args.Info.Count > 2)",
          "9483:         {",
          "9484:             accumulator = args[2];",
          "9485:         }",
          "9486:         else",
          "9487:         {",
          "9488:             if (length == 0)",
          "9489:             {",
          "9490:                 JavascriptError::ThrowTypeError(scriptContext, VBSERR_ActionNotSupported);",
          "9491:             }",
          "9493:             bool bPresent = false;",
          "9495:             if (pArr)",
          "9496:             {",
          "9497:                 for (; k < length && bPresent == false; k++)",
          "9498:                 {",
          "9499:                     JS_REENTRANT(jsReentLock, BOOL gotItem = pArr->DirectGetItemAtFull((uint32)k, &element));",
          "9500:                     if (!gotItem)",
          "9501:                     {",
          "9502:                         continue;",
          "9503:                     }",
          "9505:                     bPresent = true;",
          "9506:                     accumulator = element;",
          "9507:                 }",
          "9511:                 if (!JavascriptArray::Is(obj))",
          "9512:                 {",
          "9513:                     AssertOrFailFastMsg(ES5Array::Is(obj), \"The array should have been converted to an ES5Array\");",
          "9514:                     pArr = nullptr;",
          "9515:                 }",
          "9516:             }",
          "9517:             else if (typedArrayBase)",
          "9518:             {",
          "9519:                 AssertAndFailFast(TypedArrayBase::Is(typedArrayBase));",
          "9520:                 uint32 end = (uint32)min(length, (T)typedArrayBase->GetLength());",
          "9522:                 for (; k < end && bPresent == false; k++)",
          "9523:                 {",
          "9526:                     element = typedArrayBase->DirectGetItem((uint32)k);",
          "9528:                     bPresent = true;",
          "9529:                     accumulator = element;",
          "9530:                 }",
          "9531:             }",
          "9532:             else",
          "9533:             {",
          "9534:                 for (; k < length && bPresent == false; k++)",
          "9535:                 {",
          "9536:                     JS_REENTRANT(jsReentLock, BOOL hasItem = JavascriptOperators::HasItem(obj, k));",
          "9537:                     if (hasItem)",
          "9538:                     {",
          "9539:                         JS_REENTRANT(jsReentLock, accumulator = JavascriptOperators::GetItem(obj, k, scriptContext));",
          "9540:                         bPresent = true;",
          "9541:                     }",
          "9542:                 }",
          "9543:             }",
          "9545:             if (bPresent == false)",
          "9546:             {",
          "9547:                 JavascriptError::ThrowTypeError(scriptContext, VBSERR_ActionNotSupported);",
          "9548:             }",
          "9549:         }",
          "9551:         Assert(accumulator);",
          "9553:         Var undefinedValue = scriptContext->GetLibrary()->GetUndefined();",
          "9555:         CallFlags flags = CallFlags_Value;",
          "9557:         if (pArr)",
          "9558:         {",
          "9559:             for (; k < length; k++)",
          "9560:             {",
          "9561:                 JS_REENTRANT(jsReentLock, BOOL gotItem = pArr->DirectGetItemAtFull((uint32)k, &element));",
          "9562:                 if (!gotItem)",
          "9563:                 {",
          "9564:                     continue;",
          "9565:                 }",
          "9567:                 JS_REENTRANT(jsReentLock,",
          "9568:                     accumulator = CALL_FUNCTION(scriptContext->GetThreadContext(), callBackFn, CallInfo(flags, 5), undefinedValue,",
          "9569:                         accumulator,",
          "9570:                         element,",
          "9571:                         JavascriptNumber::ToVar(k, scriptContext),",
          "9572:                         pArr));",
          "9576:                 if (!JavascriptArray::Is(obj))",
          "9577:                 {",
          "9578:                     AssertOrFailFastMsg(ES5Array::Is(obj), \"The array should have been converted to an ES5Array\");",
          "9579:                     JS_REENTRANT_UNLOCK(jsReentLock, return JavascriptArray::ReduceObjectHelper<T>(obj, length, k + 1, callBackFn, accumulator, scriptContext));",
          "9580:                 }",
          "9581:             }",
          "9582:         }",
          "9583:         else if (typedArrayBase)",
          "9584:         {",
          "9585:             AssertAndFailFast(TypedArrayBase::Is(typedArrayBase));",
          "9586:             uint32 end = (uint32)min(length, (T)typedArrayBase->GetLength());",
          "9588:             for (; k < end; k++)",
          "9589:             {",
          "9592:                 element = typedArrayBase->DirectGetItem((uint32)k);",
          "9594:                 JS_REENTRANT(jsReentLock,",
          "9595:                     accumulator = CALL_FUNCTION(scriptContext->GetThreadContext(), callBackFn, CallInfo(flags, 5), undefinedValue,",
          "9596:                         accumulator,",
          "9597:                         element,",
          "9598:                         JavascriptNumber::ToVar(k, scriptContext),",
          "9599:                         typedArrayBase));",
          "9600:             }",
          "9601:         }",
          "9602:         else",
          "9603:         {",
          "9604:             JS_REENTRANT_UNLOCK(jsReentLock, return JavascriptArray::ReduceObjectHelper<T>(obj, length, k, callBackFn, accumulator, scriptContext));",
          "9605:         }",
          "9607:         return accumulator;",
          "9608:     }",
          "9610:     template <typename T>",
          "9611:     Var JavascriptArray::ReduceObjectHelper(RecyclableObject* obj, T length, T start, RecyclableObject* callBackFn, Var accumulator, ScriptContext* scriptContext)",
          "9612:     {",
          "9613:         JS_REENTRANCY_LOCK(jsReentLock, scriptContext->GetThreadContext());",
          "9616:         CallFlags flags = CallFlags_Value;",
          "9617:         Var element = nullptr;",
          "9619:         for (T k = start; k < length; k++)",
          "9620:         {",
          "9621:                 JS_REENTRANT(jsReentLock, BOOL hasItem = JavascriptOperators::HasItem(obj, k));",
          "9622:                 if (hasItem)",
          "9623:             {",
          "9624:                     JS_REENTRANT(jsReentLock,",
          "9625:                         element = JavascriptOperators::GetItem(obj, k, scriptContext),",
          "9626:                         accumulator = CALL_FUNCTION(scriptContext->GetThreadContext(), callBackFn, CallInfo(flags, 5), scriptContext->GetLibrary()->GetUndefined(),",
          "9627:                             accumulator,",
          "9628:                             element,",
          "9629:                             JavascriptNumber::ToVar(k, scriptContext),",
          "9630:                             obj));",
          "9631:             }",
          "9632:         }",
          "9634:         return accumulator;",
          "9635:     }",
          "9637:     Var JavascriptArray::EntryReduceRight(RecyclableObject* function, CallInfo callInfo, ...)",
          "9638:     {",
          "9639:         PROBE_STACK(function->GetScriptContext(), Js::Constants::MinStackDefault);",
          "9641:         ARGUMENTS(args, callInfo);",
          "9642:         ScriptContext* scriptContext = function->GetScriptContext();",
          "9643:         JS_REENTRANCY_LOCK(jsReentLock, scriptContext->GetThreadContext());",
          "9645:         AUTO_TAG_NATIVE_LIBRARY_ENTRY(function, callInfo, _u(\"Array.prototype.reduceRight\"));",
          "9647:         CHAKRATEL_LANGSTATS_INC_BUILTINCOUNT(Array_Prototype_reduceRight);",
          "9649:         Assert(!(callInfo.Flags & CallFlags_New));",
          "9651:         if (args.Info.Count == 0)",
          "9652:         {",
          "9653:             JavascriptError::ThrowTypeError(scriptContext, JSERR_This_NullOrUndefined, _u(\"Array.prototype.reduceRight\"));",
          "9654:         }",
          "9656:         BigIndex length;",
          "9657:         JavascriptArray * pArr = nullptr;",
          "9658:         RecyclableObject* obj = nullptr;",
          "9659:         JS_REENTRANT(jsReentLock, TryGetArrayAndLength(args[0], scriptContext, _u(\"Array.prototype.reduceRight\"), &pArr, &obj, &length));",
          "9661:         if (length.IsSmallIndex())",
          "9662:         {",
          "9663:             JS_REENTRANT_UNLOCK(jsReentLock, return JavascriptArray::ReduceRightHelper(pArr, nullptr, obj, length.GetSmallIndex(), args, scriptContext));",
          "9664:         }",
          "9666:         JS_REENTRANT_UNLOCK(jsReentLock, return JavascriptArray::ReduceRightHelper(pArr, nullptr, obj, length.GetBigIndex(), args, scriptContext));",
          "9667:     }",
          "9670:     template <typename T>",
          "9671:     Var JavascriptArray::ReduceRightHelper(JavascriptArray* pArr, Js::TypedArrayBase* typedArrayBase, RecyclableObject* obj, T length, Arguments& args, ScriptContext* scriptContext)",
          "9672:     {",
          "9673:         JS_REENTRANCY_LOCK(jsReentLock, scriptContext->GetThreadContext());",
          "9675:         if (args.Info.Count < 2 || !JavascriptConversion::IsCallable(args[1]))",
          "9676:         {",
          "9677:             if (typedArrayBase != nullptr)",
          "9678:             {",
          "9679:                 JavascriptError::ThrowTypeError(scriptContext, JSERR_FunctionArgument_NeedFunction, _u(\"[TypedArray].prototype.reduceRight\"));",
          "9680:             }",
          "9681:             else",
          "9682:             {",
          "9683:                 JavascriptError::ThrowTypeError(scriptContext, JSERR_FunctionArgument_NeedFunction, _u(\"Array.prototype.reduceRight\"));",
          "9684:             }",
          "9685:         }",
          "9688:         if (typedArrayBase == nullptr && pArr == nullptr && TypedArrayBase::Is(obj))",
          "9689:         {",
          "9690:             typedArrayBase = TypedArrayBase::FromVar(obj);",
          "9691:         }",
          "9693:         RecyclableObject* callBackFn = RecyclableObject::FromVar(args[1]);",
          "9694:         Var accumulator = nullptr;",
          "9695:         Var element = nullptr;",
          "9696:         T k = 0;",
          "9697:         T index = 0;",
          "9699:         if (args.Info.Count > 2)",
          "9700:         {",
          "9701:             accumulator = args[2];",
          "9702:         }",
          "9703:         else",
          "9704:         {",
          "9705:             if (length == 0)",
          "9706:             {",
          "9707:                 JavascriptError::ThrowTypeError(scriptContext, VBSERR_ActionNotSupported);",
          "9708:             }",
          "9710:             bool bPresent = false;",
          "9711:             if (pArr)",
          "9712:             {",
          "9713:                 for (; k < length && bPresent == false; k++)",
          "9714:                 {",
          "9715:                     index = length - k - 1;",
          "9716:                     JS_REENTRANT(jsReentLock, BOOL gotItem = pArr->DirectGetItemAtFull((uint32)index, &element));",
          "9717:                     if (!gotItem)",
          "9718:                     {",
          "9719:                         continue;",
          "9720:                     }",
          "9721:                     bPresent = true;",
          "9722:                     accumulator = element;",
          "9723:                 }",
          "9727:                 if (!JavascriptArray::Is(obj))",
          "9728:                 {",
          "9729:                     AssertOrFailFastMsg(ES5Array::Is(obj), \"The array should have been converted to an ES5Array\");",
          "9730:                     pArr = nullptr;",
          "9731:                 }",
          "9732:             }",
          "9733:             else if (typedArrayBase)",
          "9734:             {",
          "9735:                 AssertAndFailFast(TypedArrayBase::Is(typedArrayBase));",
          "9736:                 uint32 end = (uint32)min(length, (T)typedArrayBase->GetLength());",
          "9738:                 for (; k < end && bPresent == false; k++)",
          "9739:                 {",
          "9742:                     index = length - k - 1;",
          "9743:                     element = typedArrayBase->DirectGetItem((uint32)index);",
          "9744:                     bPresent = true;",
          "9745:                     accumulator = element;",
          "9746:                 }",
          "9747:             }",
          "9748:             else",
          "9749:             {",
          "9750:                 for (; k < length && bPresent == false; k++)",
          "9751:                 {",
          "9752:                     index = length - k - 1;",
          "9753:                     JS_REENTRANT(jsReentLock, BOOL hasItem = JavascriptOperators::HasItem(obj, index));",
          "9754:                     if (hasItem)",
          "9755:                     {",
          "9756:                         JS_REENTRANT(jsReentLock, accumulator = JavascriptOperators::GetItem(obj, index, scriptContext));",
          "9757:                         bPresent = true;",
          "9758:                     }",
          "9759:                 }",
          "9760:             }",
          "9761:             if (bPresent == false)",
          "9762:             {",
          "9763:                 JavascriptError::ThrowTypeError(scriptContext, VBSERR_ActionNotSupported);",
          "9764:             }",
          "9765:         }",
          "9768:         CallFlags flags = CallFlags_Value;",
          "9769:         Var undefinedValue = scriptContext->GetLibrary()->GetUndefined();",
          "9771:         if (pArr)",
          "9772:         {",
          "9773:             for (; k < length; k++)",
          "9774:             {",
          "9775:                 index = length - k - 1;",
          "9776:                 JS_REENTRANT(jsReentLock, BOOL gotItem = pArr->DirectGetItemAtFull((uint32)index, &element));",
          "9777:                 if (!gotItem)",
          "9778:                 {",
          "9779:                     continue;",
          "9780:                 }",
          "9782:                 JS_REENTRANT(jsReentLock,",
          "9783:                     accumulator = CALL_FUNCTION(scriptContext->GetThreadContext(), callBackFn, CallInfo(flags, 5), undefinedValue,",
          "9784:                         accumulator,",
          "9785:                         element,",
          "9786:                         JavascriptNumber::ToVar(index, scriptContext),",
          "9787:                         pArr));",
          "9791:                 if (!JavascriptArray::Is(obj))",
          "9792:                 {",
          "9793:                     AssertOrFailFastMsg(ES5Array::Is(obj), \"The array should have been converted to an ES5Array\");",
          "9794:                     JS_REENTRANT_UNLOCK(jsReentLock, return JavascriptArray::ReduceRightObjectHelper<T>(obj, length, k + 1, callBackFn, accumulator, scriptContext));",
          "9795:                 }",
          "9796:             }",
          "9797:         }",
          "9798:         else if (typedArrayBase)",
          "9799:         {",
          "9800:             AssertAndFailFast(TypedArrayBase::Is(typedArrayBase));",
          "9801:             uint32 end = (uint32)min(length, (T)typedArrayBase->GetLength());",
          "9803:             for (; k < end; k++)",
          "9804:             {",
          "9807:                 index = length - k - 1;",
          "9808:                 element = typedArrayBase->DirectGetItem((uint32)index);",
          "9810:                 JS_REENTRANT(jsReentLock,",
          "9811:                     accumulator = CALL_FUNCTION(scriptContext->GetThreadContext(), callBackFn, CallInfo(flags, 5), undefinedValue,",
          "9812:                         accumulator,",
          "9813:                         element,",
          "9814:                         JavascriptNumber::ToVar(index, scriptContext),",
          "9815:                         typedArrayBase));",
          "9816:             }",
          "9817:         }",
          "9818:         else",
          "9819:         {",
          "9820:             JS_REENTRANT_UNLOCK(jsReentLock, return JavascriptArray::ReduceRightObjectHelper<T>(obj, length, k, callBackFn, accumulator, scriptContext));",
          "9821:         }",
          "9823:         return accumulator;",
          "9824:     }",
          "9826:     template <typename T>",
          "9827:     Var JavascriptArray::ReduceRightObjectHelper(RecyclableObject* obj, T length, T start, RecyclableObject* callBackFn, Var accumulator, ScriptContext* scriptContext)",
          "9828:     {",
          "9829:         JS_REENTRANCY_LOCK(jsReentLock, scriptContext->GetThreadContext());",
          "9832:         CallFlags flags = CallFlags_Value;",
          "9833:         Var element = nullptr;",
          "9834:         T index = 0;",
          "9836:         for (T k = start; k < length; k++)",
          "9837:         {",
          "9838:             index = length - k - 1;",
          "9839:             JS_REENTRANT(jsReentLock, BOOL hasItem = JavascriptOperators::HasItem(obj, index));",
          "9840:             if (hasItem)",
          "9841:             {",
          "9842:                 JS_REENTRANT(jsReentLock,",
          "9843:                     element = JavascriptOperators::GetItem(obj, index, scriptContext),",
          "9844:                     accumulator = CALL_FUNCTION(scriptContext->GetThreadContext(),",
          "9845:                         callBackFn, CallInfo(flags, 5), scriptContext->GetLibrary()->GetUndefined(),",
          "9846:                         accumulator,",
          "9847:                         element,",
          "9848:                         JavascriptNumber::ToVar(index, scriptContext),",
          "9849:                         obj));",
          "9850:             }",
          "9851:         }",
          "9853:         return accumulator;",
          "9854:     }",
          "9856:     Var JavascriptArray::EntryFrom(RecyclableObject* function, CallInfo callInfo, ...)",
          "9857:     {",
          "9858:         PROBE_STACK(function->GetScriptContext(), Js::Constants::MinStackDefault);",
          "9860:         ARGUMENTS(args, callInfo);",
          "9861:         ScriptContext* scriptContext = function->GetScriptContext();",
          "9862:         JS_REENTRANCY_LOCK(jsReentLock, scriptContext->GetThreadContext());",
          "9864:         AUTO_TAG_NATIVE_LIBRARY_ENTRY(function, callInfo, _u(\"Array.from\"));",
          "9866:         Assert(!(callInfo.Flags & CallFlags_New));",
          "9868:         JavascriptLibrary* library = scriptContext->GetLibrary();",
          "9869:         RecyclableObject* constructor = nullptr;",
          "9871:         if (JavascriptOperators::IsConstructor(args[0]))",
          "9872:         {",
          "9873:             constructor = RecyclableObject::FromVar(args[0]);",
          "9874:         }",
          "9876:         RecyclableObject* items = nullptr;",
          "9878:         if (args.Info.Count < 2 || !JavascriptConversion::ToObject(args[1], scriptContext, &items))",
          "9879:         {",
          "9880:             JavascriptError::ThrowTypeError(scriptContext, JSERR_FunctionArgument_NeedObject, _u(\"Array.from\"));",
          "9881:         }",
          "9883:         JavascriptArray* itemsArr = nullptr;",
          "9885:         if (JavascriptArray::Is(items))",
          "9886:         {",
          "9887: #if ENABLE_COPYONACCESS_ARRAY",
          "9888:             JavascriptLibrary::CheckAndConvertCopyOnAccessNativeIntArray<Var>(items);",
          "9889: #endif",
          "9890:             itemsArr = JavascriptArray::FromVar(items);",
          "9891:         }",
          "9893:         bool mapping = false;",
          "9894:         JavascriptFunction* mapFn = nullptr;",
          "9895:         Var mapFnThisArg = nullptr;",
          "9897:         if (args.Info.Count >= 3 && !JavascriptOperators::IsUndefinedObject(args[2]))",
          "9898:         {",
          "9899:             if (!JavascriptFunction::Is(args[2]))",
          "9900:             {",
          "9901:                 JavascriptError::ThrowTypeError(scriptContext, JSERR_FunctionArgument_NeedFunction, _u(\"Array.from\"));",
          "9902:             }",
          "9904:             mapFn = JavascriptFunction::FromVar(args[2]);",
          "9906:             if (args.Info.Count >= 4)",
          "9907:             {",
          "9908:                 mapFnThisArg = args[3];",
          "9909:             }",
          "9910:             else",
          "9911:             {",
          "9912:                 mapFnThisArg = library->GetUndefined();",
          "9913:             }",
          "9915:             mapping = true;",
          "9916:         }",
          "9918:         RecyclableObject* newObj = nullptr;",
          "9919:         JavascriptArray* newArr = nullptr;",
          "9921:         JS_REENTRANT(jsReentLock, RecyclableObject* iterator = JavascriptOperators::GetIterator(items, scriptContext, true /* optional */));",
          "9923:         if (iterator != nullptr)",
          "9924:         {",
          "9925:             if (constructor)",
          "9926:             {",
          "9927:                 Js::Var constructorArgs[] = { constructor };",
          "9928:                 Js::CallInfo constructorCallInfo(Js::CallFlags_New, _countof(constructorArgs));",
          "9929:                 JS_REENTRANT(jsReentLock, newObj = RecyclableObject::FromVar(JavascriptOperators::NewScObject(constructor, Js::Arguments(constructorCallInfo, constructorArgs), scriptContext)));",
          "9931:                 if (JavascriptArray::Is(newObj))",
          "9932:                 {",
          "9933: #if ENABLE_COPYONACCESS_ARRAY",
          "9934:                     JavascriptLibrary::CheckAndConvertCopyOnAccessNativeIntArray<Var>(newObj);",
          "9935: #endif",
          "9936:                     newArr = JavascriptArray::FromVar(newObj);",
          "9937:                 }",
          "9938:             }",
          "9939:             else",
          "9940:             {",
          "9941:                 newArr = scriptContext->GetLibrary()->CreateArray(0);",
          "9942:                 newArr->EnsureHead<Var>();",
          "9943:                 newObj = newArr;",
          "9944:             }",
          "9946:             uint32 k = 0;",
          "9948:             JS_REENTRANT(jsReentLock, JavascriptOperators::DoIteratorStepAndValue(iterator, scriptContext, [&](Var nextValue) {",
          "9949:                 if (mapping)",
          "9950:                 {",
          "9951:                     Assert(mapFn != nullptr);",
          "9952:                     Assert(mapFnThisArg != nullptr);",
          "9954:                     Js::Var mapFnArgs[] = { mapFnThisArg, nextValue, JavascriptNumber::ToVar(k, scriptContext) };",
          "9955:                     Js::CallInfo mapFnCallInfo(Js::CallFlags_Value, _countof(mapFnArgs));",
          "9956:                     nextValue = mapFn->CallFunction(Js::Arguments(mapFnCallInfo, mapFnArgs));",
          "9957:                 }",
          "9959:                 if (newArr)",
          "9960:                 {",
          "9961:                     newArr->SetItem(k, nextValue, PropertyOperation_None);",
          "9962:                 }",
          "9963:                 else",
          "9964:                 {",
          "9965:                     ThrowErrorOnFailure(JavascriptArray::SetArrayLikeObjects(newObj, k, nextValue), scriptContext, k);",
          "9966:                 }",
          "9968:                 k++;",
          "9969:             }));",
          "9971:             JS_REENTRANT(jsReentLock, JavascriptOperators::SetProperty(newObj, newObj, Js::PropertyIds::length, JavascriptNumber::ToVar(k, scriptContext), scriptContext, PropertyOperation_ThrowIfNotExtensible));",
          "9972:         }",
          "9973:         else",
          "9974:         {",
          "9975:             JS_REENTRANT(jsReentLock, int64 len = (int64)OP_GetLength(items, scriptContext));",
          "9977:             if (constructor)",
          "9978:             {",
          "9979:                 Js::Var constructorArgs[] = { constructor, JavascriptNumber::ToVar(len, scriptContext) };",
          "9980:                 Js::CallInfo constructorCallInfo(Js::CallFlags_New, _countof(constructorArgs));",
          "9981:                 JS_REENTRANT(jsReentLock, newObj = RecyclableObject::FromVar(JavascriptOperators::NewScObject(constructor, Js::Arguments(constructorCallInfo, constructorArgs), scriptContext)));",
          "9983:                 if (JavascriptArray::Is(newObj))",
          "9984:                 {",
          "9985: #if ENABLE_COPYONACCESS_ARRAY",
          "9986:                     JavascriptLibrary::CheckAndConvertCopyOnAccessNativeIntArray<Var>(newObj);",
          "9987: #endif",
          "9988:                     newArr = JavascriptArray::FromVar(newObj);",
          "9989:                 }",
          "9990:             }",
          "9991:             else",
          "9992:             {",
          "9994:                 if (len > MaxArrayLength)",
          "9995:                 {",
          "9996:                     JavascriptError::ThrowRangeError(scriptContext, JSERR_ArrayLengthAssignIncorrect, _u(\"Array.from\"));",
          "9997:                 }",
          "10000:                 newArr = scriptContext->GetLibrary()->CreateArray(static_cast<uint32>(len));",
          "10001:                 newArr->EnsureHead<Var>();",
          "10002:                 newObj = newArr;",
          "10003:             }",
          "10005:             uint32 k = 0;",
          "10007:             for ( ; k < len; k++)",
          "10008:             {",
          "10009:                 Var kValue;",
          "10011:                 if (itemsArr)",
          "10012:                 {",
          "10013:                     JS_REENTRANT(jsReentLock, kValue = itemsArr->DirectGetItem(k));",
          "10014:                 }",
          "10015:                 else",
          "10016:                 {",
          "10017:                     JS_REENTRANT(jsReentLock, kValue = JavascriptOperators::OP_GetElementI_UInt32(items, k, scriptContext));",
          "10018:                 }",
          "10020:                 if (mapping)",
          "10021:                 {",
          "10022:                     Assert(mapFn != nullptr);",
          "10023:                     Assert(mapFnThisArg != nullptr);",
          "10025:                     Js::Var mapFnArgs[] = { mapFnThisArg, kValue, JavascriptNumber::ToVar(k, scriptContext) };",
          "10026:                     Js::CallInfo mapFnCallInfo(Js::CallFlags_Value, _countof(mapFnArgs));",
          "10027:                     JS_REENTRANT(jsReentLock, kValue = mapFn->CallFunction(Js::Arguments(mapFnCallInfo, mapFnArgs)));",
          "10028:                 }",
          "10030:                 if (newArr)",
          "10031:                 {",
          "10032:                     newArr->SetItem(k, kValue, PropertyOperation_None);",
          "10033:                 }",
          "10034:                 else",
          "10035:                 {",
          "10036:                     JS_REENTRANT(jsReentLock, ThrowErrorOnFailure(JavascriptArray::SetArrayLikeObjects(newObj, k, kValue), scriptContext, k));",
          "10037:                 }",
          "10038:             }",
          "10040:             JS_REENTRANT(jsReentLock, JavascriptOperators::SetProperty(newObj, newObj, Js::PropertyIds::length, JavascriptNumber::ToVar(len, scriptContext), scriptContext, PropertyOperation_ThrowIfNotExtensible));",
          "10041:         }",
          "10043:         return newObj;",
          "10044:     }",
          "10046:     Var JavascriptArray::EntryOf(RecyclableObject* function, CallInfo callInfo, ...)",
          "10047:     {",
          "10048:         PROBE_STACK(function->GetScriptContext(), Js::Constants::MinStackDefault);",
          "10050:         ARGUMENTS(args, callInfo);",
          "10051:         ScriptContext* scriptContext = function->GetScriptContext();",
          "10052:         JS_REENTRANCY_LOCK(jsReentLock, scriptContext->GetThreadContext());",
          "10054:         Assert(!(callInfo.Flags & CallFlags_New));",
          "10056:         if (args.Info.Count == 0)",
          "10057:         {",
          "10058:             JavascriptError::ThrowTypeError(scriptContext, JSERR_This_NullOrUndefined, _u(\"Array.of\"));",
          "10059:         }",
          "10061:         JS_REENTRANT_UNLOCK(jsReentLock, return JavascriptArray::OfHelper(false, args, scriptContext));",
          "10062:     }",
          "10064:     Var JavascriptArray::EntryGetterSymbolSpecies(RecyclableObject* function, CallInfo callInfo, ...)",
          "10065:     {",
          "10066:         ARGUMENTS(args, callInfo);",
          "10068:         Assert(args.Info.Count > 0);",
          "10070:         return args[0];",
          "10071:     }",
          "10074:     Var JavascriptArray::OfHelper(bool isTypedArrayEntryPoint, Arguments& args, ScriptContext* scriptContext)",
          "10075:     {",
          "10076:         JS_REENTRANCY_LOCK(jsReentLock, scriptContext->GetThreadContext());",
          "10078:         Assert(args.Info.Count > 0);",
          "10081:         uint32 len = args.Info.Count - 1;",
          "10082:         Var newObj = nullptr;",
          "10083:         JavascriptArray* newArr = nullptr;",
          "10084:         TypedArrayBase* newTypedArray = nullptr;",
          "10085:         bool isBuiltinArrayCtor = true;",
          "10087:         if (JavascriptOperators::IsConstructor(args[0]))",
          "10088:         {",
          "10089:             RecyclableObject* constructor = RecyclableObject::FromVar(args[0]);",
          "10090:             isBuiltinArrayCtor = (constructor == scriptContext->GetLibrary()->GetArrayConstructor());",
          "10092:             Js::Var constructorArgs[] = { constructor, JavascriptNumber::ToVar(len, scriptContext) };",
          "10093:             Js::CallInfo constructorCallInfo(Js::CallFlags_New, _countof(constructorArgs));",
          "10094:             if (isTypedArrayEntryPoint)",
          "10095:             {",
          "10096:                 JS_REENTRANT(jsReentLock, newObj = TypedArrayBase::TypedArrayCreate(constructor, &Js::Arguments(constructorCallInfo, constructorArgs), len, scriptContext));",
          "10097:             }",
          "10098:             else",
          "10099:             {",
          "10100:                 JS_REENTRANT(jsReentLock, newObj = JavascriptOperators::NewScObject(constructor, Js::Arguments(constructorCallInfo, constructorArgs), scriptContext));",
          "10101:             }",
          "10104:             if (JavascriptArray::Is(newObj))",
          "10105:             {",
          "10106: #if ENABLE_COPYONACCESS_ARRAY",
          "10107:                 JavascriptLibrary::CheckAndConvertCopyOnAccessNativeIntArray<Var>(newObj);",
          "10108: #endif",
          "10109:                 newArr = JavascriptArray::FromVar(newObj);",
          "10110:             }",
          "10111:             else if (TypedArrayBase::Is(newObj))",
          "10112:             {",
          "10113:                 newTypedArray = TypedArrayBase::FromVar(newObj);",
          "10114:             }",
          "10115:         }",
          "10116:         else",
          "10117:         {",
          "10119:             if (isTypedArrayEntryPoint)",
          "10120:             {",
          "10121:                 JavascriptError::ThrowTypeError(scriptContext, JSERR_This_NeedFunction, _u(\"[TypedArray].of\"));",
          "10122:             }",
          "10124:             newArr = scriptContext->GetLibrary()->CreateArray(len);",
          "10125:             newArr->EnsureHead<Var>();",
          "10126:             newObj = newArr;",
          "10127:         }",
          "10130:         Assert(newObj);",
          "10132:         if (isBuiltinArrayCtor)",
          "10133:         {",
          "10134:             for (uint32 k = 0; k < len; k++)",
          "10135:             {",
          "10136:                 Var kValue = args[k + 1];",
          "10138:                 newArr->DirectSetItemAt(k, kValue);",
          "10139:             }",
          "10140:         }",
          "10141:         else if (newTypedArray)",
          "10142:         {",
          "10143:             for (uint32 k = 0; k < len; k++)",
          "10144:             {",
          "10145:                 Var kValue = args[k + 1];",
          "10147:                 JS_REENTRANT(jsReentLock, newTypedArray->DirectSetItem(k, kValue));",
          "10148:             }",
          "10149:         }",
          "10150:         else",
          "10151:         {",
          "10152:             for (uint32 k = 0; k < len; k++)",
          "10153:             {",
          "10154:                 Var kValue = args[k + 1];",
          "10155:                 JS_REENTRANT(jsReentLock, ThrowErrorOnFailure(JavascriptArray::SetArrayLikeObjects(RecyclableObject::FromVar(newObj), k, kValue), scriptContext, k));",
          "10156:             }",
          "10157:         }",
          "10159:         if (!isTypedArrayEntryPoint)",
          "10160:         {",
          "10162:             JS_REENTRANT(jsReentLock, JavascriptOperators::OP_SetProperty(newObj, Js::PropertyIds::length, JavascriptNumber::ToVar(len, scriptContext), scriptContext, nullptr, PropertyOperation_ThrowIfNotExtensible));",
          "10163:         }",
          "10165:         return newObj;",
          "10166:     }",
          "10168:     JavascriptString* JavascriptArray::ToLocaleStringHelper(Var value, ScriptContext* scriptContext)",
          "10169:     {",
          "10170:         TypeId typeId = JavascriptOperators::GetTypeId(value);",
          "10171:         if (typeId == TypeIds_Null || typeId == TypeIds_Undefined)",
          "10172:         {",
          "10173:             return scriptContext->GetLibrary()->GetEmptyString();",
          "10174:         }",
          "10175:         else",
          "10176:         {",
          "10177:             return JavascriptConversion::ToLocaleString(value, scriptContext);",
          "10178:         }",
          "10179:     }",
          "10181:     inline BOOL JavascriptArray::IsFullArray() const",
          "10182:     {",
          "10183:         if (head && head->length == length)",
          "10184:         {",
          "10185:             AssertMsg(head->next == 0 && head->left == 0, \"Invalid Array\");",
          "10186:             return true;",
          "10187:         }",
          "10188:         return (0 == length);",
          "10189:     }",
          "10196:     bool JavascriptArray::IsFillFromPrototypes()",
          "10197:     {",
          "10198:         return !(this->head->next == nullptr && this->HasNoMissingValues() && this->length == this->head->length);",
          "10199:     }",
          "10203:     void JavascriptArray::FillFromPrototypes(uint32 startIndex, uint32 limitIndex)",
          "10204:     {",
          "10205:         if (startIndex >= limitIndex)",
          "10206:         {",
          "10207:             return;",
          "10208:         }",
          "10210:         RecyclableObject* prototype = this->GetPrototype();",
          "10213:         while (JavascriptOperators::GetTypeId(prototype) != TypeIds_Null)",
          "10214:         {",
          "10215:             ForEachOwnMissingArrayIndexOfObject(this, nullptr, prototype, startIndex, limitIndex,0, [this](uint32 index, Var value) {",
          "10216:                 this->SetItem(index, value, PropertyOperation_None);",
          "10217:             });",
          "10219:             prototype = prototype->GetPrototype();",
          "10220:         }",
          "10221: #ifdef VALIDATE_ARRAY",
          "10222:         ValidateArray();",
          "10223: #endif",
          "10224:     }",
          "10229:     template<typename T>",
          "10230:     void JavascriptArray::EnsureHeadStartsFromZero(Recycler * recycler)",
          "10231:     {",
          "10232:         if (head == nullptr || head->left != 0)",
          "10233:         {",
          "10236:             ClearSegmentMap();",
          "10243:             SparseArraySegment<T>* savedHead = SparseArraySegment<T>::From(this->head);",
          "10244:             SparseArraySegment<T>* savedLastUsedSegment = (SparseArraySegment<T>*)this->GetLastUsedSegment();",
          "10245:             SetHeadAndLastUsedSegment(const_cast<SparseArraySegmentBase*>(EmptySegment));",
          "10247:             SparseArraySegment<T> *newSeg = SparseArraySegment<T>::AllocateSegment(recycler, 0, 0, savedHead);",
          "10248:             newSeg->next = savedHead;",
          "10249:             this->head = newSeg;",
          "10250:             SetHasNoMissingValues();",
          "10251:             this->SetLastUsedSegment(savedLastUsedSegment);",
          "10252:         }",
          "10253:     }",
          "10255: #ifdef ENABLE_DEBUG_CONFIG_OPTIONS",
          "10256:     void JavascriptArray::CheckForceES5Array()",
          "10257:     {",
          "10258:         if (Configuration::Global.flags.ForceES5Array)",
          "10259:         {",
          "10262:             if (PHASE_OFF1(NativeArrayPhase))",
          "10263:             {",
          "10264:                 GetTypeHandler()->ConvertToTypeWithItemAttributes(this);",
          "10265:             }",
          "10266:         }",
          "10267:     }",
          "10268: #endif",
          "10270:     template <typename T, typename Fn>",
          "10271:     void JavascriptArray::ForEachOwnMissingArrayIndexOfObject(JavascriptArray *baseArray, JavascriptArray *destArray, RecyclableObject* obj, uint32 startIndex, uint32 limitIndex, T destIndex, Fn fn)",
          "10272:     {",
          "10273:         JS_REENTRANCY_LOCK(jsReentLock, baseArray->GetScriptContext()->GetThreadContext());",
          "10274:         Assert(DynamicObject::IsAnyArray(obj) || JavascriptOperators::IsObject(obj));",
          "10276:         Var oldValue;",
          "10277:         JavascriptArray* arr = nullptr;",
          "10278:         if (DynamicObject::IsAnyArray(obj))",
          "10279:         {",
          "10280:             arr = JavascriptArray::FromAnyArray(obj);",
          "10281:         }",
          "10282:         else if (DynamicType::Is(obj->GetTypeId()))",
          "10283:         {",
          "10284:             DynamicObject* dynobj = DynamicObject::FromVar(obj);",
          "10285:             ArrayObject* objectArray = dynobj->GetObjectArray();",
          "10286:             arr = (objectArray && JavascriptArray::IsAnyArray(objectArray)) ? JavascriptArray::FromAnyArray(objectArray) : nullptr;",
          "10287:         }",
          "10289:         if (arr != nullptr)",
          "10290:         {",
          "10291:             if (JavascriptArray::Is(arr))",
          "10292:             {",
          "10293:                 arr = EnsureNonNativeArray(arr);",
          "10294:                 ArrayElementEnumerator e(arr, startIndex, limitIndex);",
          "10296:                 while(e.MoveNext<Var>())",
          "10297:                 {",
          "10298:                     uint32 index = e.GetIndex();",
          "10299:                     if (!baseArray->DirectGetVarItemAt(index, &oldValue, baseArray->GetScriptContext()))",
          "10300:                     {",
          "10301:                         T n = destIndex + (index - startIndex);",
          "10302:                         if (destArray == nullptr || !destArray->DirectGetItemAt(n, &oldValue))",
          "10303:                         {",
          "10304:                             JS_REENTRANT(jsReentLock, fn(index, e.GetItem<Var>()));",
          "10305:                         }",
          "10306:                     }",
          "10307:                 }",
          "10308:             }",
          "10309:             else",
          "10310:             {",
          "10311:                 ScriptContext* scriptContext = obj->GetScriptContext();",
          "10313:                 Assert(ES5Array::Is(arr));",
          "10315:                 ES5Array* es5Array = ES5Array::FromVar(arr);",
          "10316:                 ES5ArrayIndexStaticEnumerator<true> e(es5Array);",
          "10318:                 while (e.MoveNext())",
          "10319:                 {",
          "10320:                     uint32 index = e.GetIndex();",
          "10321:                     if (index < startIndex) continue;",
          "10322:                     else if (index >= limitIndex) break;",
          "10324:                     if (!baseArray->DirectGetVarItemAt(index, &oldValue, baseArray->GetScriptContext()))",
          "10325:                     {",
          "10326:                         T n = destIndex + (index - startIndex);",
          "10327:                         if (destArray == nullptr || !destArray->DirectGetItemAt(n, &oldValue))",
          "10328:                         {",
          "10329:                             Var value = nullptr;",
          "10330:                             JS_REENTRANT(jsReentLock, BOOL gotItem = JavascriptOperators::GetOwnItem(obj, index, &value, scriptContext));",
          "10331:                             if (gotItem)",
          "10332:                             {",
          "10333:                                 JS_REENTRANT(jsReentLock, fn(index, value));",
          "10334:                             }",
          "10335:                         }",
          "10336:                     }",
          "10337:                 }",
          "10338:             }",
          "10339:         }",
          "10340:     }",
          "10345:     JavascriptArray::ArrayElementEnumerator::ArrayElementEnumerator(JavascriptArray* arr, uint32 start, uint32 end)",
          "10346:         : start(start), end(min(end, arr->length))",
          "10347:     {",
          "10348:         Init(arr);",
          "10349:     }",
          "10354:     void JavascriptArray::ArrayElementEnumerator::Init(JavascriptArray* arr)",
          "10355:     {",
          "10357:         seg = (arr ? arr->GetBeginLookupSegment(start) : nullptr);",
          "10358:         while (seg && (seg->left + seg->length <= start))",
          "10359:         {",
          "10360:             seg = seg->next;",
          "10361:         }",
          "10364:         if (seg)",
          "10365:         {",
          "10366:             if (seg->left >= end)",
          "10367:             {",
          "10368:                 seg = nullptr;",
          "10369:             }",
          "10370:             else",
          "10371:             {",
          "10373:                 index = max(seg->left, start) - seg->left - 1;",
          "10374:                 endIndex = min(end - seg->left, seg->length);",
          "10375:             }",
          "10376:         }",
          "10377:     }",
          "10382:     template<typename T>",
          "10383:     inline bool JavascriptArray::ArrayElementEnumerator::MoveNext()",
          "10384:     {",
          "10385:         while (seg)",
          "10386:         {",
          "10388:             while (++index < endIndex)",
          "10389:             {",
          "10390:                 if (!SparseArraySegment<T>::IsMissingItem(&((SparseArraySegment<T>*)seg)->elements[index]))",
          "10391:                 {",
          "10392:                     return true;",
          "10393:                 }",
          "10394:             }",
          "10397:             seg = seg->next;",
          "10398:             if (seg)",
          "10399:             {",
          "10400:                 if (seg->left >= end)",
          "10401:                 {",
          "10402:                     seg = nullptr;",
          "10403:                     break;",
          "10404:                 }",
          "10405:                 else",
          "10406:                 {",
          "10407:                     index = static_cast<uint32>(-1);",
          "10408:                     endIndex = min(end - seg->left, seg->length);",
          "10409:                 }",
          "10410:             }",
          "10411:         }",
          "10413:         return false;",
          "10414:     }",
          "10419:     uint32 JavascriptArray::ArrayElementEnumerator::GetIndex() const",
          "10420:     {",
          "10421:         Assert(seg && index < seg->length && index < endIndex);",
          "10422:         return seg->left + index;",
          "10423:     }",
          "10428:     template<typename T>",
          "10429:     T JavascriptArray::ArrayElementEnumerator::GetItem() const",
          "10430:     {",
          "10431:         Assert(seg && index < seg->length && index < endIndex &&",
          "10432:                !SparseArraySegment<T>::IsMissingItem(&((SparseArraySegment<T>*)seg)->elements[index]));",
          "10433:         return ((SparseArraySegment<T>*)seg)->elements[index];",
          "10434:     }",
          "10439:     JavascriptArray::BigIndex::BigIndex(uint32 initIndex)",
          "10440:         : index(initIndex), bigIndex(InvalidIndex)",
          "10441:     {",
          "10443:     }",
          "10448:     JavascriptArray::BigIndex::BigIndex(uint64 initIndex)",
          "10449:         : index(InvalidIndex), bigIndex(initIndex)",
          "10450:     {",
          "10451:         if (bigIndex < InvalidIndex) // if it's actually small index",
          "10452:         {",
          "10453:             index = static_cast<uint32>(bigIndex);",
          "10454:             bigIndex = InvalidIndex;",
          "10455:         }",
          "10456:     }",
          "10458:     bool JavascriptArray::BigIndex::IsUint32Max() const",
          "10459:     {",
          "10460:         return index == InvalidIndex && bigIndex == InvalidIndex;",
          "10461:     }",
          "10462:     bool JavascriptArray::BigIndex::IsSmallIndex() const",
          "10463:     {",
          "10464:         return index < InvalidIndex;",
          "10465:     }",
          "10467:     uint32 JavascriptArray::BigIndex::GetSmallIndex() const",
          "10468:     {",
          "10469:         Assert(IsSmallIndex());",
          "10470:         return index;",
          "10471:     }",
          "10473:     uint64 JavascriptArray::BigIndex::GetBigIndex() const",
          "10474:     {",
          "10475:         Assert(!IsSmallIndex());",
          "10476:         return bigIndex;",
          "10477:     }",
          "10481:     Var JavascriptArray::BigIndex::ToNumber(ScriptContext* scriptContext) const",
          "10482:     {",
          "10483:         if (IsSmallIndex())",
          "10484:         {",
          "10485:             return small_index::ToNumber(index, scriptContext);",
          "10486:         }",
          "10487:         else",
          "10488:         {",
          "10489:             return JavascriptNumber::ToVar(bigIndex, scriptContext);",
          "10490:         }",
          "10491:     }",
          "10496:     const JavascriptArray::BigIndex& JavascriptArray::BigIndex::operator++()",
          "10497:     {",
          "10498:         if (IsSmallIndex())",
          "10499:         {",
          "10500:             ++index;",
          "10502:         }",
          "10503:         else",
          "10504:         {",
          "10505:             bigIndex = bigIndex + 1;",
          "10506:         }",
          "10508:         return *this;",
          "10509:     }",
          "10514:     const JavascriptArray::BigIndex& JavascriptArray::BigIndex::operator--()",
          "10515:     {",
          "10516:         if (IsSmallIndex())",
          "10517:         {",
          "10518:             --index;",
          "10519:         }",
          "10520:         else",
          "10521:         {",
          "10522:             Assert(index == InvalidIndex && bigIndex >= InvalidIndex);",
          "10524:             --bigIndex;",
          "10525:             if (bigIndex < InvalidIndex)",
          "10526:             {",
          "10527:                 index = InvalidIndex - 1;",
          "10528:                 bigIndex = InvalidIndex;",
          "10529:             }",
          "10530:         }",
          "10532:         return *this;",
          "10533:     }",
          "10535:     JavascriptArray::BigIndex JavascriptArray::BigIndex::operator+(const BigIndex& delta) const",
          "10536:     {",
          "10537:         if (delta.IsSmallIndex())",
          "10538:         {",
          "10539:             return operator+(delta.GetSmallIndex());",
          "10540:         }",
          "10541:         if (IsSmallIndex())",
          "10542:         {",
          "10543:             return index + delta.GetBigIndex();",
          "10544:         }",
          "10546:         return bigIndex + delta.GetBigIndex();",
          "10547:     }",
          "10552:     JavascriptArray::BigIndex JavascriptArray::BigIndex::operator+(uint32 delta) const",
          "10553:     {",
          "10554:         if (IsSmallIndex())",
          "10555:         {",
          "10556:             uint32 newIndex;",
          "10557:             if (UInt32Math::Add(index, delta, &newIndex))",
          "10558:             {",
          "10559:                 return static_cast<uint64>(index) + static_cast<uint64>(delta);",
          "10560:             }",
          "10561:             else",
          "10562:             {",
          "10563:                 return newIndex; // ok if newIndex == InvalidIndex",
          "10564:             }",
          "10565:         }",
          "10566:         else",
          "10567:         {",
          "10568:             return bigIndex + static_cast<uint64>(delta);",
          "10569:         }",
          "10570:     }",
          "10572:     bool JavascriptArray::BigIndex::operator==(const BigIndex& rhs) const",
          "10573:     {",
          "10574:         if (rhs.IsSmallIndex() && this->IsSmallIndex())",
          "10575:         {",
          "10576:             return this->GetSmallIndex() == rhs.GetSmallIndex();",
          "10577:         }",
          "10578:         else if (rhs.IsSmallIndex() && !this->IsSmallIndex())",
          "10579:         {",
          "10581:             return this->GetBigIndex() == (uint64) rhs.GetSmallIndex();",
          "10582:         }",
          "10583:         else if (!rhs.IsSmallIndex() && this->IsSmallIndex())",
          "10584:         {",
          "10586:             return ((uint64)this->GetSmallIndex()) == rhs.GetBigIndex();",
          "10587:         }",
          "10588:         return this->GetBigIndex() == rhs.GetBigIndex();",
          "10589:     }",
          "10591:     bool JavascriptArray::BigIndex::operator> (const BigIndex& rhs) const",
          "10592:     {",
          "10593:         if (rhs.IsSmallIndex() && this->IsSmallIndex())",
          "10594:         {",
          "10595:             return this->GetSmallIndex() > rhs.GetSmallIndex();",
          "10596:         }",
          "10597:         else if (rhs.IsSmallIndex() && !this->IsSmallIndex())",
          "10598:         {",
          "10600:             return this->GetBigIndex() > (uint64)rhs.GetSmallIndex();",
          "10601:         }",
          "10602:         else if (!rhs.IsSmallIndex() && this->IsSmallIndex())",
          "10603:         {",
          "10605:             return ((uint64)this->GetSmallIndex()) > rhs.GetBigIndex();",
          "10606:         }",
          "10607:         return this->GetBigIndex() > rhs.GetBigIndex();",
          "10608:     }",
          "10610:     bool JavascriptArray::BigIndex::operator< (const BigIndex& rhs) const",
          "10611:     {",
          "10612:         if (rhs.IsSmallIndex() && this->IsSmallIndex())",
          "10613:         {",
          "10614:             return this->GetSmallIndex() < rhs.GetSmallIndex();",
          "10615:         }",
          "10616:         else if (rhs.IsSmallIndex() && !this->IsSmallIndex())",
          "10617:         {",
          "10619:             return this->GetBigIndex() < (uint64)rhs.GetSmallIndex();",
          "10620:         }",
          "10621:         else if (!rhs.IsSmallIndex() && this->IsSmallIndex())",
          "10622:         {",
          "10624:             return ((uint64)this->GetSmallIndex()) < rhs.GetBigIndex();",
          "10625:         }",
          "10626:         return this->GetBigIndex() < rhs.GetBigIndex();",
          "10627:     }",
          "10629:     bool JavascriptArray::BigIndex::operator<=(const BigIndex& rhs) const",
          "10630:     {",
          "10631:         if (rhs.IsSmallIndex() && this->IsSmallIndex())",
          "10632:         {",
          "10633:             return this->GetSmallIndex() <= rhs.GetSmallIndex();",
          "10634:         }",
          "10635:         else if (rhs.IsSmallIndex() && !this->IsSmallIndex())",
          "10636:         {",
          "10638:             return this->GetBigIndex() <= (uint64)rhs.GetSmallIndex();",
          "10639:         }",
          "10640:         else if (!rhs.IsSmallIndex() && !this->IsSmallIndex())",
          "10641:         {",
          "10643:             return ((uint64)this->GetSmallIndex()) <= rhs.GetBigIndex();",
          "10644:         }",
          "10645:         return this->GetBigIndex() <= rhs.GetBigIndex();",
          "10646:     }",
          "10648:     bool JavascriptArray::BigIndex::operator>=(const BigIndex& rhs) const",
          "10649:     {",
          "10650:         if (rhs.IsSmallIndex() && this->IsSmallIndex())",
          "10651:         {",
          "10652:             return this->GetSmallIndex() >= rhs.GetSmallIndex();",
          "10653:         }",
          "10654:         else if (rhs.IsSmallIndex() && !this->IsSmallIndex())",
          "10655:         {",
          "10657:             return this->GetBigIndex() >= (uint64)rhs.GetSmallIndex();",
          "10658:         }",
          "10659:         else if (!rhs.IsSmallIndex() && this->IsSmallIndex())",
          "10660:         {",
          "10662:             return ((uint64)this->GetSmallIndex()) >= rhs.GetBigIndex();",
          "10663:         }",
          "10664:         return this->GetBigIndex() >= rhs.GetBigIndex();",
          "10665:     }",
          "10667:     BOOL JavascriptArray::BigIndex::GetItem(JavascriptArray* arr, Var* outVal) const",
          "10668:     {",
          "10669:         if (IsSmallIndex())",
          "10670:         {",
          "10671:             return small_index::GetItem(arr, index, outVal);",
          "10672:         }",
          "10673:         else",
          "10674:         {",
          "10675:             ScriptContext* scriptContext = arr->GetScriptContext();",
          "10676:             PropertyRecord const * propertyRecord;",
          "10677:             JavascriptOperators::GetPropertyIdForInt(bigIndex, scriptContext, &propertyRecord);",
          "10678:             return arr->GetProperty(arr, propertyRecord->GetPropertyId(), outVal, NULL, scriptContext);",
          "10679:         }",
          "10680:     }",
          "10682:     BOOL JavascriptArray::BigIndex::SetItem(JavascriptArray* arr, Var newValue) const",
          "10683:     {",
          "10684:         if (IsSmallIndex())",
          "10685:         {",
          "10686:             return small_index::SetItem(arr, index, newValue);",
          "10687:         }",
          "10688:         else",
          "10689:         {",
          "10690:             ScriptContext* scriptContext = arr->GetScriptContext();",
          "10691:             PropertyRecord const * propertyRecord;",
          "10692:             JavascriptOperators::GetPropertyIdForInt(bigIndex, scriptContext, &propertyRecord);",
          "10693:             return arr->SetProperty(propertyRecord->GetPropertyId(), newValue, PropertyOperation_None, NULL);",
          "10694:         }",
          "10695:     }",
          "10697:     void JavascriptArray::BigIndex::SetItemIfNotExist(JavascriptArray* arr, Var newValue) const",
          "10698:     {",
          "10699:         if (IsSmallIndex())",
          "10700:         {",
          "10701:             small_index::SetItemIfNotExist(arr, index, newValue);",
          "10702:         }",
          "10703:         else",
          "10704:         {",
          "10705:             ScriptContext* scriptContext = arr->GetScriptContext();",
          "10706:             PropertyRecord const * propertyRecord;",
          "10707:             JavascriptOperators::GetPropertyIdForInt(bigIndex, scriptContext, &propertyRecord);",
          "10708:             Var oldValue;",
          "10709:             PropertyId propertyId = propertyRecord->GetPropertyId();",
          "10710:             if (!arr->GetProperty(arr, propertyId, &oldValue, NULL, scriptContext))",
          "10711:             {",
          "10712:                 arr->SetProperty(propertyId, newValue, PropertyOperation_None, NULL);",
          "10713:             }",
          "10714:         }",
          "10715:     }",
          "10717:     BOOL JavascriptArray::BigIndex::DeleteItem(JavascriptArray* arr) const",
          "10718:     {",
          "10719:         if (IsSmallIndex())",
          "10720:         {",
          "10721:             return small_index::DeleteItem(arr, index);",
          "10722:         }",
          "10723:         else",
          "10724:         {",
          "10725:             ScriptContext* scriptContext = arr->GetScriptContext();",
          "10726:             PropertyRecord const * propertyRecord;",
          "10727:             JavascriptOperators::GetPropertyIdForInt(bigIndex, scriptContext, &propertyRecord);",
          "10728:             return arr->DeleteProperty(propertyRecord->GetPropertyId(), PropertyOperation_None);",
          "10729:         }",
          "10730:     }",
          "10732:     BOOL JavascriptArray::BigIndex::SetItem(RecyclableObject* obj, Var newValue, PropertyOperationFlags flags) const",
          "10733:     {",
          "10734:         if (IsSmallIndex())",
          "10735:         {",
          "10736:             return small_index::SetItem(obj, index, newValue, flags);",
          "10737:         }",
          "10738:         else",
          "10739:         {",
          "10740:             ScriptContext* scriptContext = obj->GetScriptContext();",
          "10741:             PropertyRecord const * propertyRecord;",
          "10742:             JavascriptOperators::GetPropertyIdForInt(bigIndex, scriptContext, &propertyRecord);",
          "10743:             return JavascriptOperators::SetProperty(obj, obj, propertyRecord->GetPropertyId(), newValue, scriptContext, flags);",
          "10744:         }",
          "10745:     }",
          "10747:     BOOL JavascriptArray::BigIndex::DeleteItem(RecyclableObject* obj, PropertyOperationFlags flags) const",
          "10748:     {",
          "10749:         if (IsSmallIndex())",
          "10750:         {",
          "10751:             return small_index::DeleteItem(obj, index, flags);",
          "10752:         }",
          "10753:         else",
          "10754:         {",
          "10755:             PropertyRecord const * propertyRecord;",
          "10756:             JavascriptOperators::GetPropertyIdForInt(bigIndex, obj->GetScriptContext(), &propertyRecord);",
          "10757:             return JavascriptOperators::DeleteProperty(obj, propertyRecord->GetPropertyId(), flags);",
          "10758:         }",
          "10759:     }",
          "10764:     void JavascriptArray::TruncateToProperties(const BigIndex& dstIndex, uint32 start)",
          "10765:     {",
          "10766:         Assert(!dstIndex.IsSmallIndex());",
          "10767:         typedef IndexTrace<BigIndex> index_trace;",
          "10769:         BigIndex dst = dstIndex;",
          "10770:         uint32 i = start;",
          "10772:         ArrayElementEnumerator e(this, start);",
          "10773:         while(e.MoveNext<Var>())",
          "10774:         {",
          "10776:             while (i < e.GetIndex())",
          "10777:             {",
          "10778:                 index_trace::DeleteItem(this, dst);",
          "10779:                 ++i;",
          "10780:                 ++dst;",
          "10781:             }",
          "10784:             index_trace::SetItem(this, dst, e.GetItem<Var>());",
          "10785:             ++i;",
          "10786:             ++dst;",
          "10787:         }",
          "10790:         while (i < this->length)",
          "10791:         {",
          "10792:             index_trace::DeleteItem(this, dst);",
          "10793:             ++i;",
          "10794:             ++dst;",
          "10795:         }",
          "10798:         SetLength(start);",
          "10799:     }",
          "10804:     template<typename T>",
          "10805:     void JavascriptArray::InternalCopyArrayElements(JavascriptArray* dstArray, const T& dstIndex, JavascriptArray* srcArray, uint32 start, uint32 end)",
          "10806:     {",
          "10807:         Assert(start < end && end <= srcArray->length);",
          "10809:         uint32 count = 0;",
          "10812:         ArrayElementEnumerator e(srcArray, start, end);",
          "10813:         while(e.MoveNext<Var>())",
          "10814:         {",
          "10815:             T n = dstIndex + (e.GetIndex() - start);",
          "10816:             dstArray->DirectSetItemAt(n, e.GetItem<Var>());",
          "10817:             count++;",
          "10818:         }",
          "10821:         if (start + count != end)",
          "10822:         {",
          "10823:             InternalFillFromPrototype(dstArray, dstIndex, srcArray, start, end, count);",
          "10824:         }",
          "10825:     }",
          "10831:     void JavascriptArray::CopyArrayElements(JavascriptArray* dstArray, const BigIndex& dstIndex, JavascriptArray* srcArray, uint32 start, uint32 end)",
          "10832:     {",
          "10833:         end = min(end, srcArray->length);",
          "10834:         if (start < end)",
          "10835:         {",
          "10836:             uint32 len = end - start;",
          "10837:             if (dstIndex.IsSmallIndex() && (len < MaxArrayLength - dstIndex.GetSmallIndex()))",
          "10838:             {",
          "10840:                 InternalCopyArrayElements(dstArray, dstIndex.GetSmallIndex(), srcArray, start, end);",
          "10841:             }",
          "10842:             else",
          "10843:             {",
          "10844:                 InternalCopyArrayElements(dstArray, dstIndex, srcArray, start, end);",
          "10845:             }",
          "10846:         }",
          "10847:     }",
          "10852:     void JavascriptArray::CopyArrayElements(JavascriptArray* dstArray, uint32 dstIndex, JavascriptArray* srcArray, uint32 start, uint32 end)",
          "10853:     {",
          "10854:         end = min(end, srcArray->length);",
          "10855:         if (start < end)",
          "10856:         {",
          "10857:             Assert(end - start <= MaxArrayLength - dstIndex);",
          "10858:             InternalCopyArrayElements(dstArray, dstIndex, srcArray, start, end);",
          "10859:         }",
          "10860:     }",
          "10862:     template <typename T>",
          "10863:     void JavascriptArray::CopyAnyArrayElementsToVar(JavascriptArray* dstArray, T dstIndex, JavascriptArray* srcArray, uint32 start, uint32 end)",
          "10864:     {",
          "10865: #if ENABLE_COPYONACCESS_ARRAY",
          "10866:         JavascriptLibrary::CheckAndConvertCopyOnAccessNativeIntArray<Var>(srcArray);",
          "10867: #endif",
          "10868: #if ENABLE_COPYONACCESS_ARRAY",
          "10869:         JavascriptLibrary::CheckAndConvertCopyOnAccessNativeIntArray<Var>(dstArray);",
          "10870: #endif",
          "10871:         if (JavascriptNativeIntArray::Is(srcArray))",
          "10872:         {",
          "10873:             CopyNativeIntArrayElementsToVar(dstArray, dstIndex, JavascriptNativeIntArray::FromVar(srcArray), start, end);",
          "10874:         }",
          "10875:         else if (JavascriptNativeFloatArray::Is(srcArray))",
          "10876:         {",
          "10877:             CopyNativeFloatArrayElementsToVar(dstArray, dstIndex, JavascriptNativeFloatArray::FromVar(srcArray), start, end);",
          "10878:         }",
          "10879:         else",
          "10880:         {",
          "10881:             CopyArrayElements(dstArray, dstIndex, srcArray, start, end);",
          "10882:         }",
          "10883:     }",
          "10885:     void JavascriptArray::CopyNativeIntArrayElementsToVar(JavascriptArray* dstArray, const BigIndex& dstIndex, JavascriptNativeIntArray* srcArray, uint32 start, uint32 end)",
          "10886:     {",
          "10887:         end = min(end, srcArray->length);",
          "10888:         if (start < end)",
          "10889:         {",
          "10890:             uint32 len = end - start;",
          "10891:             if (dstIndex.IsSmallIndex() && (len < MaxArrayLength - dstIndex.GetSmallIndex()))",
          "10892:             {",
          "10894:                 InternalCopyNativeIntArrayElements(dstArray, dstIndex.GetSmallIndex(), srcArray, start, end);",
          "10895:             }",
          "10896:             else",
          "10897:             {",
          "10898:                 InternalCopyNativeIntArrayElements(dstArray, dstIndex, srcArray, start, end);",
          "10899:             }",
          "10900:         }",
          "10901:     }",
          "10906:     void JavascriptArray::CopyNativeIntArrayElementsToVar(JavascriptArray* dstArray, uint32 dstIndex, JavascriptNativeIntArray* srcArray, uint32 start, uint32 end)",
          "10907:     {",
          "10908:         end = min(end, srcArray->length);",
          "10909:         if (start < end)",
          "10910:         {",
          "10911:             Assert(end - start <= MaxArrayLength - dstIndex);",
          "10912:             InternalCopyNativeIntArrayElements(dstArray, dstIndex, srcArray, start, end);",
          "10913:         }",
          "10914:     }",
          "10916:     bool JavascriptArray::CopyNativeIntArrayElements(JavascriptNativeIntArray* dstArray, uint32 dstIndex, JavascriptNativeIntArray* srcArray, uint32 start, uint32 end)",
          "10917:     {",
          "10918:         end = min(end, srcArray->length);",
          "10919:         if (start >= end)",
          "10920:         {",
          "10921:             return false;",
          "10922:         }",
          "10924:         Assert(end - start <= MaxArrayLength - dstIndex);",
          "10925:         Assert(start < end && end <= srcArray->length);",
          "10927:         uint32 count = 0;",
          "10930:         ArrayElementEnumerator e(srcArray, start, end);",
          "10931:         while(e.MoveNext<int32>())",
          "10932:         {",
          "10933:             uint n = dstIndex + (e.GetIndex() - start);",
          "10934:             dstArray->DirectSetItemAt(n, e.GetItem<int32>());",
          "10935:             count++;",
          "10936:         }",
          "10939:         if (start + count != end)",
          "10940:         {",
          "10941:             JavascriptArray *varArray = JavascriptNativeIntArray::ToVarArray(dstArray);",
          "10942:             InternalFillFromPrototype(varArray, dstIndex, srcArray, start, end, count);",
          "10943:             return true;",
          "10944:         }",
          "10946:         return false;",
          "10947:     }",
          "10949:     bool JavascriptArray::CopyNativeIntArrayElementsToFloat(JavascriptNativeFloatArray* dstArray, uint32 dstIndex, JavascriptNativeIntArray* srcArray, uint32 start, uint32 end)",
          "10950:     {",
          "10951:         end = min(end, srcArray->length);",
          "10952:         if (start >= end)",
          "10953:         {",
          "10954:             return false;",
          "10955:         }",
          "10957:         Assert(end - start <= MaxArrayLength - dstIndex);",
          "10958:         Assert(start < end && end <= srcArray->length);",
          "10960:         uint32 count = 0;",
          "10963:         ArrayElementEnumerator e(srcArray, start, end);",
          "10964:         while(e.MoveNext<int32>())",
          "10965:         {",
          "10966:             uint n = dstIndex + (e.GetIndex() - start);",
          "10967:             dstArray->DirectSetItemAt(n, (double)e.GetItem<int32>());",
          "10968:             count++;",
          "10969:         }",
          "10972:         if (start + count != end)",
          "10973:         {",
          "10974:             JavascriptArray *varArray = JavascriptNativeFloatArray::ToVarArray(dstArray);",
          "10975:             InternalFillFromPrototype(varArray, dstIndex, srcArray, start, end, count);",
          "10976:             return true;",
          "10977:         }",
          "10979:         return false;",
          "10980:     }",
          "10982:     void JavascriptArray::CopyNativeFloatArrayElementsToVar(JavascriptArray* dstArray, const BigIndex& dstIndex, JavascriptNativeFloatArray* srcArray, uint32 start, uint32 end)",
          "10983:     {",
          "10984:         end = min(end, srcArray->length);",
          "10985:         if (start < end)",
          "10986:         {",
          "10987:             uint32 len = end - start;",
          "10988:             if (dstIndex.IsSmallIndex() && (len < MaxArrayLength - dstIndex.GetSmallIndex()))",
          "10989:             {",
          "10991:                 InternalCopyNativeFloatArrayElements(dstArray, dstIndex.GetSmallIndex(), srcArray, start, end);",
          "10992:             }",
          "10993:             else",
          "10994:             {",
          "10995:                 InternalCopyNativeFloatArrayElements(dstArray, dstIndex, srcArray, start, end);",
          "10996:             }",
          "10997:         }",
          "10998:     }",
          "11003:     void JavascriptArray::CopyNativeFloatArrayElementsToVar(JavascriptArray* dstArray, uint32 dstIndex, JavascriptNativeFloatArray* srcArray, uint32 start, uint32 end)",
          "11004:     {",
          "11005:         end = min(end, srcArray->length);",
          "11006:         if (start < end)",
          "11007:         {",
          "11008:             Assert(end - start <= MaxArrayLength - dstIndex);",
          "11009:             InternalCopyNativeFloatArrayElements(dstArray, dstIndex, srcArray, start, end);",
          "11010:         }",
          "11011:     }",
          "11013:     bool JavascriptArray::CopyNativeFloatArrayElements(JavascriptNativeFloatArray* dstArray, uint32 dstIndex, JavascriptNativeFloatArray* srcArray, uint32 start, uint32 end)",
          "11014:     {",
          "11015:         end = min(end, srcArray->length);",
          "11016:         if (start >= end)",
          "11017:         {",
          "11018:             return false;",
          "11019:         }",
          "11021:         Assert(end - start <= MaxArrayLength - dstIndex);",
          "11022:         Assert(start < end && end <= srcArray->length);",
          "11024:         uint32 count = 0;",
          "11027:         ArrayElementEnumerator e(srcArray, start, end);",
          "11028:         while(e.MoveNext<double>())",
          "11029:         {",
          "11030:             uint n = dstIndex + (e.GetIndex() - start);",
          "11031:             dstArray->DirectSetItemAt(n, e.GetItem<double>());",
          "11032:             count++;",
          "11033:         }",
          "11036:         if (start + count != end)",
          "11037:         {",
          "11038:             JavascriptArray *varArray = JavascriptNativeFloatArray::ToVarArray(dstArray);",
          "11039:             InternalFillFromPrototype(varArray, dstIndex, srcArray, start, end, count);",
          "11040:             return true;",
          "11041:         }",
          "11043:         return false;",
          "11044:     }",
          "11046:     JavascriptArray *JavascriptArray::EnsureNonNativeArray(JavascriptArray *arr)",
          "11047:     {",
          "11048: #if ENABLE_COPYONACCESS_ARRAY",
          "11049:         JavascriptLibrary::CheckAndConvertCopyOnAccessNativeIntArray<Var>(arr);",
          "11050: #endif",
          "11051:         if (JavascriptNativeIntArray::Is(arr))",
          "11052:         {",
          "11053:             arr = JavascriptNativeIntArray::ToVarArray((JavascriptNativeIntArray*)arr);",
          "11054:         }",
          "11055:         else if (JavascriptNativeFloatArray::Is(arr))",
          "11056:         {",
          "11057:             arr = JavascriptNativeFloatArray::ToVarArray((JavascriptNativeFloatArray*)arr);",
          "11058:         }",
          "11060:         return arr;",
          "11061:     }",
          "11063:     BOOL JavascriptNativeIntArray::DirectGetItemAtFull(uint32 index, Var* outVal)",
          "11064:     {",
          "11065:         ScriptContext* requestContext = type->GetScriptContext();",
          "11066:         if (JavascriptNativeIntArray::GetItem(this, index, outVal, requestContext))",
          "11067:         {",
          "11068:             return TRUE;",
          "11069:         }",
          "11071:         return JavascriptOperators::GetItem(this, this->GetPrototype(), index, outVal, requestContext);",
          "11072:     }",
          "11074:     BOOL JavascriptNativeFloatArray::DirectGetItemAtFull(uint32 index, Var* outVal)",
          "11075:     {",
          "11076:         ScriptContext* requestContext = type->GetScriptContext();",
          "11077:         if (JavascriptNativeFloatArray::GetItem(this, index, outVal, requestContext))",
          "11078:         {",
          "11079:             return TRUE;",
          "11080:         }",
          "11082:         return JavascriptOperators::GetItem(this, this->GetPrototype(), index, outVal, requestContext);",
          "11083:     }",
          "11085:     template<typename T>",
          "11086:     void JavascriptArray::InternalCopyNativeIntArrayElements(JavascriptArray* dstArray, const T& dstIndex, JavascriptNativeIntArray* srcArray, uint32 start, uint32 end)",
          "11087:     {",
          "11088:         Assert(start < end && end <= srcArray->length);",
          "11090:         uint32 count = 0;",
          "11093:         ScriptContext *scriptContext = dstArray->GetScriptContext();",
          "11095:         ArrayElementEnumerator e(srcArray, start, end);",
          "11096:         while(e.MoveNext<int32>())",
          "11097:         {",
          "11098:             T n = dstIndex + (e.GetIndex() - start);",
          "11099:             dstArray->DirectSetItemAt(n, JavascriptNumber::ToVar(e.GetItem<int32>(), scriptContext));",
          "11100:             count++;",
          "11101:         }",
          "11104:         if (start + count != end)",
          "11105:         {",
          "11106:             InternalFillFromPrototype(dstArray, dstIndex, srcArray, start, end, count);",
          "11107:         }",
          "11108:     }",
          "11110:     template<typename T>",
          "11111:     void JavascriptArray::InternalCopyNativeFloatArrayElements(JavascriptArray* dstArray, const T& dstIndex, JavascriptNativeFloatArray* srcArray, uint32 start, uint32 end)",
          "11112:     {",
          "11113:         Assert(start < end && end <= srcArray->length);",
          "11115:         uint32 count = 0;",
          "11118:         ScriptContext *scriptContext = dstArray->GetScriptContext();",
          "11119:         ArrayElementEnumerator e(srcArray, start, end);",
          "11120:         while(e.MoveNext<double>())",
          "11121:         {",
          "11122:             T n = dstIndex + (e.GetIndex() - start);",
          "11123:             dstArray->DirectSetItemAt(n, JavascriptNumber::ToVarWithCheck(e.GetItem<double>(), scriptContext));",
          "11124:             count++;",
          "11125:         }",
          "11128:         if (start + count != end)",
          "11129:         {",
          "11130:             InternalFillFromPrototype(dstArray, dstIndex, srcArray, start, end, count);",
          "11131:         }",
          "11132:     }",
          "11134:     Var JavascriptArray::SpreadArrayArgs(Var arrayToSpread, const Js::AuxArray<uint32> *spreadIndices, ScriptContext *scriptContext)",
          "11135:     {",
          "11136:         JS_REENTRANCY_LOCK(jsReentLock, scriptContext->GetThreadContext());",
          "11140: #if ENABLE_COPYONACCESS_ARRAY",
          "11141:         JavascriptLibrary::CheckAndConvertCopyOnAccessNativeIntArray<Var>(arrayToSpread);",
          "11142: #endif",
          "11143:         JavascriptArray *array = FromVar(arrayToSpread);",
          "11144:         uint32 arrayLength = array->GetLength();",
          "11145:         uint32 actualLength = arrayLength;",
          "11147:         for (unsigned i = 0; i < spreadIndices->count; ++i)",
          "11148:         {",
          "11149:             JS_REENTRANT(jsReentLock,",
          "11150:                 actualLength = UInt32Math::Add(actualLength - 1, GetSpreadArgLen(array->DirectGetItem(spreadIndices->elements[i]), scriptContext)));",
          "11151:         }",
          "11153:         JavascriptArray *result = FromVar(OP_NewScArrayWithMissingValues(actualLength, scriptContext));",
          "11156:         for (unsigned i = 0, spreadArrIndex = 0, resultIndex = 0; i < arrayLength && resultIndex < actualLength; ++i)",
          "11157:         {",
          "11158:             uint32 spreadIndex = spreadIndices->elements[spreadArrIndex]; // The index of the next element to be spread.",
          "11161:             auto needArraySlowCopy = [&](Var instance) {",
          "11162:                 if (JavascriptArray::Is(instance))",
          "11163:                 {",
          "11164:                     JavascriptArray *arr = JavascriptArray::FromVar(instance);",
          "11165:                     JS_REENTRANT_UNLOCK(jsReentLock, return arr->IsCrossSiteObject() || arr->IsFillFromPrototypes());",
          "11166:                 }",
          "11167:                 return false;",
          "11168:             };",
          "11171:             auto slowCopy = [&scriptContext, &needArraySlowCopy",
          "11172:                 ](JavascriptArray *dstArray, unsigned dstIndex, Var srcArray, uint32 start, uint32 end) {",
          "11173:                 Assert(needArraySlowCopy(srcArray) || ArgumentsObject::Is(srcArray) || TypedArrayBase::Is(srcArray) || JavascriptString::Is(srcArray));",
          "11174:                 JS_REENTRANCY_LOCK(jsReentLock, scriptContext->GetThreadContext());",
          "11176:                 RecyclableObject *propertyObject;",
          "11177:                 if (!JavascriptOperators::GetPropertyObject(srcArray, scriptContext, &propertyObject))",
          "11178:                 {",
          "11179:                     JavascriptError::ThrowTypeError(scriptContext, JSERR_InvalidSpreadArgument);",
          "11180:                 }",
          "11182:                 for (uint32 j = start; j < end; j++)",
          "11183:                 {",
          "11184:                     Var element;",
          "11185:                     JS_REENTRANT(jsReentLock, BOOL gotItem = JavascriptOperators::GetItem(srcArray, propertyObject, j, &element, scriptContext));",
          "11186:                     if (!gotItem)",
          "11187:                     {",
          "11189:                         element = scriptContext->GetLibrary()->GetUndefined();",
          "11190:                     }",
          "11191:                     dstArray->DirectSetItemAt(dstIndex++, element);",
          "11192:                 }",
          "11193:             };",
          "11195:             if (i < spreadIndex)",
          "11196:             {",
          "11199:                 if (needArraySlowCopy(array))",
          "11200:                 {",
          "11201:                     slowCopy(result, resultIndex, (Var)array, i, spreadIndex);",
          "11202:                 }",
          "11203:                 else",
          "11204:                 {",
          "11205:                     JS_REENTRANT(jsReentLock, CopyAnyArrayElementsToVar(result, resultIndex, array, i, spreadIndex));",
          "11206:                 }",
          "11207:                 resultIndex += spreadIndex - i;",
          "11208:                 i = spreadIndex - 1;",
          "11209:                 continue;",
          "11210:             }",
          "11211:             else if (i > spreadIndex)",
          "11212:             {",
          "11214:                 Assert(spreadArrIndex == spreadIndices->count - 1);",
          "11215:                 if (needArraySlowCopy(array))",
          "11216:                 {",
          "11217:                     slowCopy(result, resultIndex, array, i, arrayLength);",
          "11218:                 }",
          "11219:                 else",
          "11220:                 {",
          "11221:                     JS_REENTRANT(jsReentLock, CopyAnyArrayElementsToVar(result, resultIndex, array, i, arrayLength));",
          "11222:                 }",
          "11223:                 break;",
          "11224:             }",
          "11225:             else",
          "11226:             {",
          "11227:                 JS_REENTRANT(jsReentLock, Var instance = array->DirectGetItem(i));",
          "11229:                 if (SpreadArgument::Is(instance))",
          "11230:                 {",
          "11231:                     SpreadArgument* spreadArgument = SpreadArgument::FromVar(instance);",
          "11232:                     uint32 len = spreadArgument->GetArgumentSpreadCount();",
          "11233:                     const Var*  spreadItems = spreadArgument->GetArgumentSpread();",
          "11234:                     for (uint32 j = 0; j < len; j++)",
          "11235:                     {",
          "11236:                         result->DirectSetItemAt(resultIndex++, spreadItems[j]);",
          "11237:                     }",
          "11239:                 }",
          "11240:                 else",
          "11241:                 {",
          "11242:                     Assert(JavascriptOperators::IsUndefinedObject(instance));",
          "11243:                     result->DirectSetItemAt(resultIndex++, instance);",
          "11244:                 }",
          "11246:                 if (spreadArrIndex < spreadIndices->count - 1)",
          "11247:                 {",
          "11248:                     spreadArrIndex++;",
          "11249:                 }",
          "11250:             }",
          "11251:         }",
          "11252:         AssertMsg(arrayLength == array->GetLength(), \"Array's length should not have changed\");",
          "11253:         return result;",
          "11254:     }",
          "11256:     uint32 JavascriptArray::GetSpreadArgLen(Var spreadArg, ScriptContext *scriptContext)",
          "11257:     {",
          "11260:         spreadArg = CrossSite::MarshalVar(scriptContext, spreadArg);",
          "11261:         if (JavascriptArray::Is(spreadArg))",
          "11262:         {",
          "11263:             JavascriptArray *arr = JavascriptArray::FromVar(spreadArg);",
          "11264:             return arr->GetLength();",
          "11265:         }",
          "11267:         if (TypedArrayBase::Is(spreadArg))",
          "11268:         {",
          "11269:             TypedArrayBase *tarr = TypedArrayBase::FromVar(spreadArg);",
          "11270:             return tarr->GetLength();",
          "11271:         }",
          "11273:         if (SpreadArgument::Is(spreadArg))",
          "11274:         {",
          "11275:             SpreadArgument *spreadFunctionArgs = SpreadArgument::FromVar(spreadArg);",
          "11276:             return spreadFunctionArgs->GetArgumentSpreadCount();",
          "11277:         }",
          "11279:         AssertMsg(false, \"LdCustomSpreadIteratorList should have converted the arg to one of the above types\");",
          "11280:         Throw::FatalInternalError();",
          "11281:     }",
          "11283: #ifdef VALIDATE_ARRAY",
          "11284:     class ArraySegmentsVisitor",
          "11285:     {",
          "11286:     private:",
          "11287:         SparseArraySegmentBase* seg;",
          "11289:     public:",
          "11290:         ArraySegmentsVisitor(SparseArraySegmentBase* head)",
          "11291:             : seg(head)",
          "11292:         {",
          "11293:         }",
          "11295:         void operator()(SparseArraySegmentBase* s)",
          "11296:         {",
          "11297:             Assert(seg == s);",
          "11298:             if (seg)",
          "11299:             {",
          "11300:                 seg = seg->next;",
          "11301:             }",
          "11302:         }",
          "11303:     };",
          "11305:     void JavascriptArray::ValidateArrayCommon()",
          "11306:     {",
          "11307:         SparseArraySegmentBase * lastUsedSegment = this->GetLastUsedSegment();",
          "11308:         AssertMsg(this != nullptr && head && lastUsedSegment, \"Array should not be null\");",
          "11309:         AssertMsg(head->left == 0, \"Array always should have a segment starting at zero\");",
          "11312:         bool foundLastUsedSegment = false;",
          "11313:         SparseArraySegmentBase *seg = head;",
          "11314:         while(seg != nullptr)",
          "11315:         {",
          "11316:             if (seg == lastUsedSegment)",
          "11317:             {",
          "11318:                 foundLastUsedSegment = true;",
          "11319:             }",
          "11321:             AssertMsg(seg->length <= seg->size , \"Length greater than size not possible\");",
          "11323:             SparseArraySegmentBase* next = seg->next;",
          "11324:             if (next != nullptr)",
          "11325:             {",
          "11326:                 AssertMsg(seg->left < next->left, \"Segment is adjacent to or overlaps with next segment\");",
          "11327:                 AssertMsg(seg->size <= (next->left - seg->left), \"Segment is adjacent to or overlaps with next segment\");",
          "11328:                 AssertMsg(!SparseArraySegmentBase::IsLeafSegment(seg, this->GetScriptContext()->GetRecycler()), \"Leaf segment with a next pointer\");",
          "11329:             }",
          "11330:             else",
          "11331:             {",
          "11332:                 AssertMsg(seg->length <= MaxArrayLength - seg->left, \"Segment index range overflow\");",
          "11333:                 AssertMsg(seg->left + seg->length <= this->length, \"Segment index range exceeds array length\");",
          "11334:             }",
          "11336:             seg = next;",
          "11337:         }",
          "11338:         AssertMsg(foundLastUsedSegment || HasSegmentMap(), \"Corrupt lastUsedSegment in array header\");",
          "11341:         if (HasSegmentMap())",
          "11342:         {",
          "11343:             ArraySegmentsVisitor visitor(head);",
          "11344:             GetSegmentMap()->Walk(visitor);",
          "11345:         }",
          "11346:     }",
          "11348:     void JavascriptArray::ValidateArray()",
          "11349:     {",
          "11350:         if (!Js::Configuration::Global.flags.ArrayValidate)",
          "11351:         {",
          "11352:             return;",
          "11353:         }",
          "11354:         ValidateArrayCommon();",
          "11356:         JavascriptArray::ValidateVarSegment(SparseArraySegment<Var>::From(head));",
          "11357:     }",
          "11359:     void JavascriptNativeIntArray::ValidateArray()",
          "11360:     {",
          "11361:         if (!Js::Configuration::Global.flags.ArrayValidate)",
          "11362:         {",
          "11363: #if DBG",
          "11364:             SparseArraySegmentBase *seg = head;",
          "11365:             while (seg)",
          "11366:             {",
          "11367:                 if (seg->next != nullptr)",
          "11368:                 {",
          "11369:                     AssertMsg(!SparseArraySegmentBase::IsLeafSegment(seg, this->GetScriptContext()->GetRecycler()), \"Leaf segment with a next pointer\");",
          "11370:                 }",
          "11371:                 seg = seg->next;",
          "11372:             }",
          "11373: #endif",
          "11374:             return;",
          "11375:         }",
          "11376:         ValidateArrayCommon();",
          "11378:         JavascriptArray::ValidateSegment<int32>(SparseArraySegment<int32>::From(head));",
          "11379:     }",
          "11381:     void JavascriptNativeFloatArray::ValidateArray()",
          "11382:     {",
          "11383:         if (!Js::Configuration::Global.flags.ArrayValidate)",
          "11384:         {",
          "11385: #if DBG",
          "11386:             SparseArraySegmentBase *seg = head;",
          "11387:             while (seg)",
          "11388:             {",
          "11389:                 if (seg->next != nullptr)",
          "11390:                 {",
          "11391:                     AssertMsg(!SparseArraySegmentBase::IsLeafSegment(seg, this->GetScriptContext()->GetRecycler()), \"Leaf segment with a next pointer\");",
          "11392:                 }",
          "11393:                 seg = seg->next;",
          "11394:             }",
          "11395: #endif",
          "11396:             return;",
          "11397:         }",
          "11398:         ValidateArrayCommon();",
          "11400:         JavascriptArray::ValidateSegment<double>(SparseArraySegment<double>::From(head));",
          "11401:     }",
          "11404:     void JavascriptArray::ValidateVarSegment(SparseArraySegment<Var>* seg)",
          "11405:     {",
          "11406:         if (!Js::Configuration::Global.flags.ArrayValidate)",
          "11407:         {",
          "11408:             return;",
          "11409:         }",
          "11410:         int32 inspect;",
          "11411:         double inspectDouble;",
          "11412:         while (seg)",
          "11413:         {",
          "11414:             uint32 i = 0;",
          "11415:             for (i = 0; i < seg->length; i++)",
          "11416:             {",
          "11417:                 if (SparseArraySegment<Var>::IsMissingItem(&seg->elements[i]))",
          "11418:                 {",
          "11419:                     continue;",
          "11420:                 }",
          "11421:                 if (TaggedInt::Is(seg->elements[i]))",
          "11422:                 {",
          "11423:                     inspect = TaggedInt::ToInt32(seg->elements[i]);",
          "11425:                 }",
          "11426:                 else if (JavascriptNumber::Is_NoTaggedIntCheck(seg->elements[i]))",
          "11427:                 {",
          "11428:                     inspectDouble = JavascriptNumber::GetValue(seg->elements[i]);",
          "11429:                 }",
          "11430:                 else",
          "11431:                 {",
          "11432:                     AssertMsg(RecyclableObject::Is(seg->elements[i]), \"Invalid entry in segment\");",
          "11433:                 }",
          "11434:             }",
          "11435:             ValidateSegment(seg);",
          "11437:             seg = SparseArraySegment<Var>::From(seg->next);",
          "11438:         }",
          "11439:     }",
          "11441:     template<typename T>",
          "11442:     void JavascriptArray::ValidateSegment(SparseArraySegment<T>* seg)",
          "11443:     {",
          "11444:         if (!Js::Configuration::Global.flags.ArrayValidate)",
          "11445:         {",
          "11446:             return;",
          "11447:         }",
          "11449:         while (seg)",
          "11450:         {",
          "11451:             uint32 i = seg->length;",
          "11452:             while (i < seg->size)",
          "11453:             {",
          "11454:                 AssertMsg(SparseArraySegment<T>::IsMissingItem(&seg->elements[i]), \"Non missing value the end of the segment\");",
          "11455:                 i++;",
          "11456:             }",
          "11458:             seg = SparseArraySegment<T>::From(seg->next);",
          "11459:         }",
          "11460:     }",
          "11461: #endif",
          "11463:     template <typename T>",
          "11464:     void JavascriptArray::InitBoxedInlineHeadSegment(SparseArraySegment<T> * dst, SparseArraySegment<T> * src)",
          "11465:     {",
          "11467:         SetFlags(GetFlags() & ~DynamicObjectFlags::HasSegmentMap);",
          "11469:         SetHeadAndLastUsedSegment(dst);",
          "11471:         dst->left = src->left;",
          "11472:         dst->length = src->length;",
          "11473:         dst->size = src->size;",
          "11474:         dst->next = src->next;",
          "11476:         CopyArray(dst->elements, dst->size, src->elements, src->size);",
          "11477:     }",
          "11479:     JavascriptArray::JavascriptArray(JavascriptArray * instance, bool boxHead)",
          "11480:         : ArrayObject(instance)",
          "11481:     {",
          "11482:         if (boxHead)",
          "11483:         {",
          "11484:             InitBoxedInlineHeadSegment(DetermineInlineHeadSegmentPointer<JavascriptArray, 0, true>(this), SparseArraySegment<Var>::From(instance->head));",
          "11485:         }",
          "11486:         else",
          "11487:         {",
          "11489:             SetFlags(GetFlags() & ~DynamicObjectFlags::HasSegmentMap);",
          "11490:             head = instance->head;",
          "11491:             SetLastUsedSegment(instance->GetLastUsedSegment());",
          "11492:         }",
          "11493:     }",
          "11495:     template <typename T>",
          "11496:     T * JavascriptArray::BoxStackInstance(T * instance)",
          "11497:     {",
          "11498:         Assert(ThreadContext::IsOnStack(instance));",
          "11500:         T ** boxedInstanceRef = ((T **)instance) - 1;",
          "11501:         T * boxedInstance = *boxedInstanceRef;",
          "11502:         if (boxedInstance)",
          "11503:         {",
          "11504:             return boxedInstance;",
          "11505:         }",
          "11507:         const size_t inlineSlotsSize = instance->GetTypeHandler()->GetInlineSlotsSize();",
          "11508:         if (ThreadContext::IsOnStack(instance->head))",
          "11509:         {",
          "11510:             boxedInstance = RecyclerNewPlusZ(instance->GetRecycler(),",
          "11511:                 inlineSlotsSize + sizeof(Js::SparseArraySegmentBase) + instance->head->size * sizeof(typename T::TElement),",
          "11512:                 T, instance, true);",
          "11513:         }",
          "11514:         else if(inlineSlotsSize)",
          "11515:         {",
          "11516:             boxedInstance = RecyclerNewPlusZ(instance->GetRecycler(), inlineSlotsSize, T, instance, false);",
          "11517:         }",
          "11518:         else",
          "11519:         {",
          "11520:             boxedInstance = RecyclerNew(instance->GetRecycler(), T, instance, false);",
          "11521:         }",
          "11524:         return boxedInstance;",
          "11525:     }",
          "11527:     JavascriptArray *",
          "11528:     JavascriptArray::BoxStackInstance(JavascriptArray * instance)",
          "11529:     {",
          "11530:         return BoxStackInstance<JavascriptArray>(instance);",
          "11531:     }",
          "11533: #if ENABLE_TTD",
          "11534:     void JavascriptArray::MarkVisitKindSpecificPtrs(TTD::SnapshotExtractor* extractor)",
          "11535:     {",
          "11536:         TTDAssert(this->GetTypeId() == Js::TypeIds_Array || this->GetTypeId() == Js::TypeIds_ES5Array, \"Should only be used on basic arrays (or called as super from ES5Array.\");",
          "11538:         ScriptContext* ctx = this->GetScriptContext();",
          "11540:         uint32 index = Js::JavascriptArray::InvalidIndex;",
          "11541:         while(true)",
          "11542:         {",
          "11543:             index = this->GetNextIndex(index);",
          "11544:             if(index == Js::JavascriptArray::InvalidIndex) // End of array",
          "11545:             {",
          "11546:                 break;",
          "11547:             }",
          "11549:             Js::Var aval = nullptr;",
          "11550:             if(this->DirectGetVarItemAt(index, &aval, ctx))",
          "11551:             {",
          "11552:                 extractor->MarkVisitVar(aval);",
          "11553:             }",
          "11554:         }",
          "11555:     }",
          "11557:     void JavascriptArray::ProcessCorePaths()",
          "11558:     {",
          "11559:         TTDAssert(this->GetTypeId() == Js::TypeIds_Array, \"Should only be used on basic arrays.\");",
          "11561:         ScriptContext* ctx = this->GetScriptContext();",
          "11563:         uint32 index = Js::JavascriptArray::InvalidIndex;",
          "11564:         while(true)",
          "11565:         {",
          "11566:             index = this->GetNextIndex(index);",
          "11567:             if(index == Js::JavascriptArray::InvalidIndex) // End of array",
          "11568:             {",
          "11569:                 break;",
          "11570:             }",
          "11572:             Js::Var aval = nullptr;",
          "11573:             if(this->DirectGetVarItemAt(index, &aval, ctx))",
          "11574:             {",
          "11575:                 TTD::UtilSupport::TTAutoString pathExt;",
          "11576:                 ctx->TTDWellKnownInfo->BuildArrayIndexBuffer(index, pathExt);",
          "11578:                 ctx->TTDWellKnownInfo->EnqueueNewPathVarAsNeeded(this, aval, pathExt.GetStrValue());",
          "11579:             }",
          "11580:         }",
          "11581:     }",
          "11583:     TTD::NSSnapObjects::SnapObjectType JavascriptArray::GetSnapTag_TTD() const",
          "11584:     {",
          "11585:         return TTD::NSSnapObjects::SnapObjectType::SnapArrayObject;",
          "11586:     }",
          "11588:     void JavascriptArray::ExtractSnapObjectDataInto(TTD::NSSnapObjects::SnapObject* objData, TTD::SlabAllocator& alloc)",
          "11589:     {",
          "11590:         TTDAssert(this->GetTypeId() == Js::TypeIds_Array, \"Should only be used on basic Js arrays.\");",
          "11592:         TTD::NSSnapObjects::SnapArrayInfo<TTD::TTDVar>* sai = TTD::NSSnapObjects::ExtractArrayValues<TTD::TTDVar>(this, alloc);",
          "11593:         TTD::NSSnapObjects::StdExtractSetKindSpecificInfo<TTD::NSSnapObjects::SnapArrayInfo<TTD::TTDVar>*, TTD::NSSnapObjects::SnapObjectType::SnapArrayObject>(objData, sai);",
          "11594:     }",
          "11595: #endif",
          "11597:     JavascriptNativeArray::JavascriptNativeArray(JavascriptNativeArray * instance) :",
          "11598:         JavascriptArray(instance, false),",
          "11599:         weakRefToFuncBody(instance->weakRefToFuncBody)",
          "11600:     {",
          "11601:     }",
          "11603:     JavascriptNativeIntArray::JavascriptNativeIntArray(JavascriptNativeIntArray * instance, bool boxHead) :",
          "11604:         JavascriptNativeArray(instance)",
          "11605:     {",
          "11606:         if (boxHead)",
          "11607:         {",
          "11608:             InitBoxedInlineHeadSegment(DetermineInlineHeadSegmentPointer<JavascriptNativeIntArray, 0, true>(this), SparseArraySegment<int>::From(instance->head));",
          "11609:         }",
          "11610:         else",
          "11611:         {",
          "11613:             Assert(head == instance->head);",
          "11614:             Assert(segmentUnion.lastUsedSegment == instance->GetLastUsedSegment());",
          "11615:         }",
          "11616:     }",
          "11618:     JavascriptNativeIntArray *",
          "11619:     JavascriptNativeIntArray::BoxStackInstance(JavascriptNativeIntArray * instance)",
          "11620:     {",
          "11621:         return JavascriptArray::BoxStackInstance<JavascriptNativeIntArray>(instance);",
          "11622:     }",
          "11624: #if ENABLE_TTD",
          "11625:     TTD::NSSnapObjects::SnapObjectType JavascriptNativeIntArray::GetSnapTag_TTD() const",
          "11626:     {",
          "11627:         return TTD::NSSnapObjects::SnapObjectType::SnapNativeIntArrayObject;",
          "11628:     }",
          "11630:     void JavascriptNativeIntArray::ExtractSnapObjectDataInto(TTD::NSSnapObjects::SnapObject* objData, TTD::SlabAllocator& alloc)",
          "11631:     {",
          "11632:         TTD::NSSnapObjects::SnapArrayInfo<int32>* sai = TTD::NSSnapObjects::ExtractArrayValues<int32>(this, alloc);",
          "11633:         TTD::NSSnapObjects::StdExtractSetKindSpecificInfo<TTD::NSSnapObjects::SnapArrayInfo<int32>*, TTD::NSSnapObjects::SnapObjectType::SnapNativeIntArrayObject>(objData, sai);",
          "11634:     }",
          "11636: #if ENABLE_COPYONACCESS_ARRAY",
          "11637:     TTD::NSSnapObjects::SnapObjectType JavascriptCopyOnAccessNativeIntArray::GetSnapTag_TTD() const",
          "11638:     {",
          "11639:         return TTD::NSSnapObjects::SnapObjectType::Invalid;",
          "11640:     }",
          "11642:     void JavascriptCopyOnAccessNativeIntArray::ExtractSnapObjectDataInto(TTD::NSSnapObjects::SnapObject* objData, TTD::SlabAllocator& alloc)",
          "11643:     {",
          "11644:         TTDAssert(false, \"Not implemented yet!!!\");",
          "11645:     }",
          "11646: #endif",
          "11647: #endif",
          "11649:     JavascriptNativeFloatArray::JavascriptNativeFloatArray(JavascriptNativeFloatArray * instance, bool boxHead) :",
          "11650:         JavascriptNativeArray(instance)",
          "11651:     {",
          "11652:         if (boxHead)",
          "11653:         {",
          "11654:             InitBoxedInlineHeadSegment(DetermineInlineHeadSegmentPointer<JavascriptNativeFloatArray, 0, true>(this), SparseArraySegment<double>::From(instance->head));",
          "11655:         }",
          "11656:         else",
          "11657:         {",
          "11659:             Assert(head == instance->head);",
          "11660:             Assert(segmentUnion.lastUsedSegment == instance->GetLastUsedSegment());",
          "11661:         }",
          "11662:     }",
          "11664:     JavascriptNativeFloatArray *",
          "11665:     JavascriptNativeFloatArray::BoxStackInstance(JavascriptNativeFloatArray * instance)",
          "11666:     {",
          "11667:         return JavascriptArray::BoxStackInstance<JavascriptNativeFloatArray>(instance);",
          "11668:     }",
          "11670: #if ENABLE_TTD",
          "11671:     TTD::NSSnapObjects::SnapObjectType JavascriptNativeFloatArray::GetSnapTag_TTD() const",
          "11672:     {",
          "11673:         return TTD::NSSnapObjects::SnapObjectType::SnapNativeFloatArrayObject;",
          "11674:     }",
          "11676:     void JavascriptNativeFloatArray::ExtractSnapObjectDataInto(TTD::NSSnapObjects::SnapObject* objData, TTD::SlabAllocator& alloc)",
          "11677:     {",
          "11678:         TTDAssert(this->GetTypeId() == Js::TypeIds_NativeFloatArray, \"Should only be used on native float arrays.\");",
          "11680:         TTD::NSSnapObjects::SnapArrayInfo<double>* sai = TTD::NSSnapObjects::ExtractArrayValues<double>(this, alloc);",
          "11681:         TTD::NSSnapObjects::StdExtractSetKindSpecificInfo<TTD::NSSnapObjects::SnapArrayInfo<double>*, TTD::NSSnapObjects::SnapObjectType::SnapNativeFloatArrayObject>(objData, sai);",
          "11682:     }",
          "11683: #endif",
          "11685:     template<typename T>",
          "11686:     RecyclableObject*",
          "11687:     JavascriptArray::ArraySpeciesCreate(Var originalArray, T length, ScriptContext* scriptContext, bool *pIsIntArray, bool *pIsFloatArray, bool *pIsBuiltinArrayCtor)",
          "11688:     {",
          "11689:         if (originalArray == nullptr || !scriptContext->GetConfig()->IsES6SpeciesEnabled())",
          "11690:         {",
          "11691:             return nullptr;",
          "11692:         }",
          "11694:         if (JavascriptArray::Is(originalArray)",
          "11695:             && !DynamicObject::FromVar(originalArray)->GetDynamicType()->GetTypeHandler()->GetIsNotPathTypeHandlerOrHasUserDefinedCtor()",
          "11696:             && DynamicObject::FromVar(originalArray)->GetPrototype() == scriptContext->GetLibrary()->GetArrayPrototype()",
          "11697:             && !scriptContext->GetLibrary()->GetArrayObjectHasUserDefinedSpecies())",
          "11698:         {",
          "11699:             return nullptr;",
          "11700:         }",
          "11702:         Var constructor = scriptContext->GetLibrary()->GetUndefined();",
          "11704:         if (JavascriptOperators::IsArray(originalArray))",
          "11705:         {",
          "11706:             if (!JavascriptOperators::GetProperty(RecyclableObject::FromVar(originalArray), PropertyIds::constructor, &constructor, scriptContext))",
          "11707:             {",
          "11708:                 return nullptr;",
          "11709:             }",
          "11711:             if (JavascriptOperators::IsConstructor(constructor))",
          "11712:             {",
          "11713:                 ScriptContext* constructorScriptContext = RecyclableObject::FromVar(constructor)->GetScriptContext();",
          "11714:                 if (constructorScriptContext != scriptContext)",
          "11715:                 {",
          "11716:                     if (constructorScriptContext->GetLibrary()->GetArrayConstructor() == constructor)",
          "11717:                     {",
          "11718:                         constructor = scriptContext->GetLibrary()->GetUndefined();",
          "11719:                     }",
          "11720:                 }",
          "11721:             }",
          "11723:             if (JavascriptOperators::IsObject(constructor))",
          "11724:             {",
          "11725:                 if (!JavascriptOperators::GetProperty((RecyclableObject*)constructor, PropertyIds::_symbolSpecies, &constructor, scriptContext))",
          "11726:                 {",
          "11727:                     if (pIsBuiltinArrayCtor != nullptr)",
          "11728:                     {",
          "11730:                     }",
          "11731:                     return nullptr;",
          "11732:                 }",
          "11733:                 if (constructor == scriptContext->GetLibrary()->GetNull())",
          "11734:                 {",
          "11735:                     constructor = scriptContext->GetLibrary()->GetUndefined();",
          "11736:                 }",
          "11737:             }",
          "11738:         }",
          "11740:         if (constructor == scriptContext->GetLibrary()->GetUndefined() || constructor == scriptContext->GetLibrary()->GetArrayConstructor())",
          "11741:         {",
          "11742:             if (length > UINT_MAX)",
          "11743:             {",
          "11744:                 JavascriptError::ThrowRangeError(scriptContext, JSERR_ArrayLengthConstructIncorrect);",
          "11745:             }",
          "11747:             if (nullptr == pIsIntArray)",
          "11748:             {",
          "11749:                 return scriptContext->GetLibrary()->CreateArray(static_cast<uint32>(length));",
          "11750:             }",
          "11751:             else",
          "11752:             {",
          "11754:                 JavascriptArray* pArr = JavascriptArray::FromVar(originalArray);",
          "11755:                 pArr->GetArrayTypeAndConvert(pIsIntArray, pIsFloatArray);",
          "11756:                 return CreateNewArrayHelper(static_cast<uint32>(length), *pIsIntArray, *pIsFloatArray, pArr, scriptContext);",
          "11757:             }",
          "11758:         }",
          "11760:         if (!JavascriptOperators::IsConstructor(constructor))",
          "11761:         {",
          "11762:             JavascriptError::ThrowTypeError(scriptContext, JSERR_NotAConstructor, _u(\"constructor[Symbol.species]\"));",
          "11763:         }",
          "11765:         if (pIsBuiltinArrayCtor != nullptr)",
          "11766:         {",
          "11768:         }",
          "11770:         Js::Var constructorArgs[] = { constructor, JavascriptNumber::ToVar(length, scriptContext) };",
          "11771:         Js::CallInfo constructorCallInfo(Js::CallFlags_New, _countof(constructorArgs));",
          "11773:         return RecyclableObject::FromVar(JavascriptOperators::NewScObject(constructor, Js::Arguments(constructorCallInfo, constructorArgs), scriptContext));",
          "11774:     }",
          "11776:     PropertyId const JavascriptArray::specialPropertyIds[] =",
          "11777:     {",
          "11778:         PropertyIds::length",
          "11779:     };",
          "11781:     BOOL JavascriptArray::DeleteProperty(PropertyId propertyId, PropertyOperationFlags flags)",
          "11782:     {",
          "11783:         if (propertyId == PropertyIds::length)",
          "11784:         {",
          "11785:             return false;",
          "11786:         }",
          "11787:         return DynamicObject::DeleteProperty(propertyId, flags);",
          "11788:     }",
          "11790:     BOOL JavascriptArray::DeleteProperty(JavascriptString *propertyNameString, PropertyOperationFlags flags)",
          "11791:     {",
          "11792:         JsUtil::CharacterBuffer<WCHAR> propertyName(propertyNameString->GetString(), propertyNameString->GetLength());",
          "11793:         if (BuiltInPropertyRecords::length.Equals(propertyName))",
          "11794:         {",
          "11795:             return false;",
          "11796:         }",
          "11797:         return DynamicObject::DeleteProperty(propertyNameString, flags);",
          "11798:     }",
          "11800:     BOOL JavascriptArray::HasProperty(PropertyId propertyId)",
          "11801:     {",
          "11802:         if (propertyId == PropertyIds::length)",
          "11803:         {",
          "11804:             return true;",
          "11805:         }",
          "11807:         ScriptContext* scriptContext = GetScriptContext();",
          "11808:         uint32 index;",
          "11809:         if (scriptContext->IsNumericPropertyId(propertyId, &index))",
          "11810:         {",
          "11811:             return this->HasItem(index);",
          "11812:         }",
          "11814:         return DynamicObject::HasProperty(propertyId);",
          "11815:     }",
          "11817:     BOOL JavascriptArray::IsEnumerable(PropertyId propertyId)",
          "11818:     {",
          "11819:         if (propertyId == PropertyIds::length)",
          "11820:         {",
          "11821:             return false;",
          "11822:         }",
          "11823:         return DynamicObject::IsEnumerable(propertyId);",
          "11824:     }",
          "11826:     BOOL JavascriptArray::IsConfigurable(PropertyId propertyId)",
          "11827:     {",
          "11828:         if (propertyId == PropertyIds::length)",
          "11829:         {",
          "11830:             return false;",
          "11831:         }",
          "11832:         return DynamicObject::IsConfigurable(propertyId);",
          "11833:     }",
          "11839:     BOOL JavascriptArray::SetEnumerable(PropertyId propertyId, BOOL value)",
          "11840:     {",
          "11841:         if (propertyId == PropertyIds::length)",
          "11842:         {",
          "11843:             Assert(!value); // Can't change array length enumerable",
          "11844:             return true;",
          "11845:         }",
          "11847:         ScriptContext* scriptContext = this->GetScriptContext();",
          "11849:         uint32 index;",
          "11850:         if (scriptContext->IsNumericPropertyId(propertyId, &index))",
          "11851:         {",
          "11852:             return GetTypeHandler()->ConvertToTypeWithItemAttributes(this)",
          "11853:                 ->SetEnumerable(this, propertyId, value);",
          "11854:         }",
          "11856:         return __super::SetEnumerable(propertyId, value);",
          "11857:     }",
          "11863:     BOOL JavascriptArray::SetWritable(PropertyId propertyId, BOOL value)",
          "11864:     {",
          "11865:         ScriptContext* scriptContext = this->GetScriptContext();",
          "11866:         uint32 index;",
          "11868:         bool setLengthNonWritable = (propertyId == PropertyIds::length && !value);",
          "11869:         if (setLengthNonWritable || scriptContext->IsNumericPropertyId(propertyId, &index))",
          "11870:         {",
          "11871:             return GetTypeHandler()->ConvertToTypeWithItemAttributes(this)",
          "11872:                 ->SetWritable(this, propertyId, value);",
          "11873:         }",
          "11875:         return __super::SetWritable(propertyId, value);",
          "11876:     }",
          "11882:     BOOL JavascriptArray::SetConfigurable(PropertyId propertyId, BOOL value)",
          "11883:     {",
          "11884:         if (propertyId == PropertyIds::length)",
          "11885:         {",
          "11886:             Assert(!value); // Can't change array length configurable",
          "11887:             return true;",
          "11888:         }",
          "11890:         ScriptContext* scriptContext = this->GetScriptContext();",
          "11892:         uint32 index;",
          "11893:         if (scriptContext->IsNumericPropertyId(propertyId, &index))",
          "11894:         {",
          "11895:             return GetTypeHandler()->ConvertToTypeWithItemAttributes(this)",
          "11896:                 ->SetConfigurable(this, propertyId, value);",
          "11897:         }",
          "11899:         return __super::SetConfigurable(propertyId, value);",
          "11900:     }",
          "11906:     BOOL JavascriptArray::SetAttributes(PropertyId propertyId, PropertyAttributes attributes)",
          "11907:     {",
          "11908:         ScriptContext* scriptContext = this->GetScriptContext();",
          "11912:         Assert(propertyId != PropertyIds::length);",
          "11914:         uint32 index;",
          "11915:         if (scriptContext->IsNumericPropertyId(propertyId, &index))",
          "11916:         {",
          "11917:             return GetTypeHandler()->ConvertToTypeWithItemAttributes(this)",
          "11918:                 ->SetItemAttributes(this, index, attributes);",
          "11919:         }",
          "11921:         return __super::SetAttributes(propertyId, attributes);",
          "11922:     }",
          "11928:     BOOL JavascriptArray::SetAccessors(PropertyId propertyId, Var getter, Var setter, PropertyOperationFlags flags)",
          "11929:     {",
          "11930:         ScriptContext* scriptContext = this->GetScriptContext();",
          "11932:         uint32 index;",
          "11933:         if (scriptContext->IsNumericPropertyId(propertyId, &index))",
          "11934:         {",
          "11935:             return GetTypeHandler()->ConvertToTypeWithItemAttributes(this)",
          "11936:                 ->SetItemAccessors(this, index, getter, setter);",
          "11937:         }",
          "11939:         return __super::SetAccessors(propertyId, getter, setter, flags);",
          "11940:     }",
          "11946:     BOOL JavascriptArray::SetItemWithAttributes(uint32 index, Var value, PropertyAttributes attributes)",
          "11947:     {",
          "11948:         return GetTypeHandler()->ConvertToTypeWithItemAttributes(this)",
          "11949:             ->SetItemWithAttributes(this, index, value, attributes);",
          "11950:     }",
          "11956:     BOOL JavascriptArray::SetItemAttributes(uint32 index, PropertyAttributes attributes)",
          "11957:     {",
          "11958:         return GetTypeHandler()->ConvertToTypeWithItemAttributes(this)",
          "11959:             ->SetItemAttributes(this, index, attributes);",
          "11960:     }",
          "11966:     BOOL JavascriptArray::SetItemAccessors(uint32 index, Var getter, Var setter)",
          "11967:     {",
          "11968:         return GetTypeHandler()->ConvertToTypeWithItemAttributes(this)",
          "11969:             ->SetItemAccessors(this, index, getter, setter);",
          "11970:     }",
          "11973:     BOOL JavascriptArray::IsObjectArrayFrozen()",
          "11974:     {",
          "11976:         return false;",
          "11977:     }",
          "11979:     JavascriptEnumerator * JavascriptArray::GetIndexEnumerator(EnumeratorFlags flags, ScriptContext* requestContext)",
          "11980:     {",
          "11981:         if (!!(flags & EnumeratorFlags::SnapShotSemantics))",
          "11982:         {",
          "11983:             return RecyclerNew(GetRecycler(), JavascriptArrayIndexSnapshotEnumerator, this, flags, requestContext);",
          "11984:         }",
          "11985:         return RecyclerNew(GetRecycler(), JavascriptArrayIndexEnumerator, this, flags, requestContext);",
          "11986:     }",
          "11988:     BOOL JavascriptArray::GetNonIndexEnumerator(JavascriptStaticEnumerator * enumerator, ScriptContext* requestContext)",
          "11989:     {",
          "11990:         return enumerator->Initialize(nullptr, nullptr, this, EnumeratorFlags::SnapShotSemantics, requestContext, nullptr);",
          "11991:     }",
          "11993:     BOOL JavascriptArray::IsItemEnumerable(uint32 index)",
          "11994:     {",
          "11995:         return true;",
          "11996:     }",
          "12002:     BOOL JavascriptArray::PreventExtensions()",
          "12003:     {",
          "12004:         return GetTypeHandler()->ConvertToTypeWithItemAttributes(this)->PreventExtensions(this);",
          "12005:     }",
          "12011:     BOOL JavascriptArray::Seal()",
          "12012:     {",
          "12013:         return GetTypeHandler()->ConvertToTypeWithItemAttributes(this)->Seal(this);",
          "12014:     }",
          "12020:     BOOL JavascriptArray::Freeze()",
          "12021:     {",
          "12022:         return GetTypeHandler()->ConvertToTypeWithItemAttributes(this)->Freeze(this);",
          "12023:     }",
          "12025:     BOOL JavascriptArray::GetSpecialPropertyName(uint32 index, Var *propertyName, ScriptContext * requestContext)",
          "12026:     {",
          "12027:         if (index == 0)",
          "12028:         {",
          "12030:             return true;",
          "12031:         }",
          "12032:         return false;",
          "12033:     }",
          "12036:     uint JavascriptArray::GetSpecialPropertyCount() const",
          "12037:     {",
          "12038:         return _countof(specialPropertyIds);",
          "12039:     }",
          "12042:     PropertyId const * JavascriptArray::GetSpecialPropertyIds() const",
          "12043:     {",
          "12044:         return specialPropertyIds;",
          "12045:     }",
          "12047:     BOOL JavascriptArray::GetPropertyReference(Var originalInstance, PropertyId propertyId, Var* value, PropertyValueInfo* info, ScriptContext* requestContext)",
          "12048:     {",
          "12049:         return JavascriptArray::GetProperty(originalInstance, propertyId, value, info, requestContext);",
          "12050:     }",
          "12052:     BOOL JavascriptArray::GetProperty(Var originalInstance, PropertyId propertyId, Var* value, PropertyValueInfo* info, ScriptContext* requestContext)",
          "12053:     {",
          "12054:         if (GetPropertyBuiltIns(propertyId, value))",
          "12055:         {",
          "12056:             return true;",
          "12057:         }",
          "12059:         ScriptContext* scriptContext = GetScriptContext();",
          "12060:         uint32 index;",
          "12061:         if (scriptContext->IsNumericPropertyId(propertyId, &index))",
          "12062:         {",
          "12063:             return this->GetItem(this, index, value, scriptContext);",
          "12064:         }",
          "12066:         return DynamicObject::GetProperty(originalInstance, propertyId, value, info, requestContext);",
          "12067:     }",
          "12069:     BOOL JavascriptArray::GetProperty(Var originalInstance, JavascriptString* propertyNameString, Var* value, PropertyValueInfo* info, ScriptContext* requestContext)",
          "12070:     {",
          "12071:         AssertMsg(!PropertyRecord::IsPropertyNameNumeric(propertyNameString->GetString(), propertyNameString->GetLength()),",
          "12072:             \"Numeric property names should have been converted to uint or PropertyRecord*\");",
          "12074:         PropertyRecord const* propertyRecord;",
          "12075:         this->GetScriptContext()->FindPropertyRecord(propertyNameString, &propertyRecord);",
          "12077:         if (propertyRecord != nullptr && GetPropertyBuiltIns(propertyRecord->GetPropertyId(), value))",
          "12078:         {",
          "12079:             return true;",
          "12080:         }",
          "12082:         return DynamicObject::GetProperty(originalInstance, propertyNameString, value, info, requestContext);",
          "12083:     }",
          "12085:     BOOL JavascriptArray::GetPropertyBuiltIns(PropertyId propertyId, Var* value)",
          "12086:     {",
          "12090:         if (propertyId == PropertyIds::length)",
          "12091:         {",
          "12093:             return true;",
          "12094:         }",
          "12096:         return false;",
          "12097:     }",
          "12099:     BOOL JavascriptArray::HasItem(uint32 index)",
          "12100:     {",
          "12101:         Var value;",
          "12102:         return this->DirectGetItemAt<Var>(index, &value);",
          "12103:     }",
          "12105:     BOOL JavascriptArray::GetItem(Var originalInstance, uint32 index, Var* value, ScriptContext* requestContext)",
          "12106:     {",
          "12107:         return this->DirectGetItemAt<Var>(index, value);",
          "12108:     }",
          "12110:     BOOL JavascriptArray::GetItemReference(Var originalInstance, uint32 index, Var* value, ScriptContext* requestContext)",
          "12111:     {",
          "12112:         return this->DirectGetItemAt<Var>(index, value);",
          "12113:     }",
          "12115:     BOOL JavascriptArray::DirectGetVarItemAt(uint32 index, Var *value, ScriptContext *requestContext)",
          "12116:     {",
          "12117:         return this->DirectGetItemAt<Var>(index, value);",
          "12118:     }",
          "12120:     BOOL JavascriptNativeIntArray::HasItem(uint32 index)",
          "12121:     {",
          "12122: #if ENABLE_COPYONACCESS_ARRAY",
          "12123:         JavascriptLibrary::CheckAndConvertCopyOnAccessNativeIntArray<Var>(this);",
          "12124: #endif",
          "12125:         int32 value;",
          "12126:         return this->DirectGetItemAt<int32>(index, &value);",
          "12127:     }",
          "12129:     BOOL JavascriptNativeFloatArray::HasItem(uint32 index)",
          "12130:     {",
          "12131:         double dvalue;",
          "12132:         return this->DirectGetItemAt<double>(index, &dvalue);",
          "12133:     }",
          "12135:     BOOL JavascriptNativeIntArray::GetItem(Var originalInstance, uint32 index, Var* value, ScriptContext* requestContext)",
          "12136:     {",
          "12137: #if ENABLE_COPYONACCESS_ARRAY",
          "12138:         JavascriptLibrary::CheckAndConvertCopyOnAccessNativeIntArray<Var>(this);",
          "12139: #endif",
          "12140:         return JavascriptNativeIntArray::DirectGetVarItemAt(index, value, requestContext);",
          "12141:     }",
          "12143:     BOOL JavascriptNativeIntArray::DirectGetVarItemAt(uint32 index, Var *value, ScriptContext *requestContext)",
          "12144:     {",
          "12145:         int32 intvalue;",
          "12146:         if (!this->DirectGetItemAt<int32>(index, &intvalue))",
          "12147:         {",
          "12148:             return FALSE;",
          "12149:         }",
          "12151:         return TRUE;",
          "12152:     }",
          "12154:     BOOL JavascriptNativeIntArray::GetItemReference(Var originalInstance, uint32 index, Var* value, ScriptContext* requestContext)",
          "12155:     {",
          "12156:         return JavascriptNativeIntArray::GetItem(originalInstance, index, value, requestContext);",
          "12157:     }",
          "12159:     BOOL JavascriptNativeFloatArray::GetItem(Var originalInstance, uint32 index, Var* value, ScriptContext* requestContext)",
          "12160:     {",
          "12161:         return JavascriptNativeFloatArray::DirectGetVarItemAt(index, value, requestContext);",
          "12162:     }",
          "12164:     BOOL JavascriptNativeFloatArray::DirectGetVarItemAt(uint32 index, Var *value, ScriptContext *requestContext)",
          "12165:     {",
          "12166:         double dvalue;",
          "12167:         int32 ivalue;",
          "12168:         if (!this->DirectGetItemAt<double>(index, &dvalue))",
          "12169:         {",
          "12170:             return FALSE;",
          "12171:         }",
          "12172:         if (*(uint64*)&dvalue == 0ull)",
          "12173:         {",
          "12175:         }",
          "12176:         else if (JavascriptNumber::TryGetInt32Value(dvalue, &ivalue) && !TaggedInt::IsOverflow(ivalue))",
          "12177:         {",
          "12179:         }",
          "12180:         else",
          "12181:         {",
          "12183:         }",
          "12184:         return TRUE;",
          "12185:     }",
          "12187:     BOOL JavascriptNativeFloatArray::GetItemReference(Var originalInstance, uint32 index, Var* value, ScriptContext* requestContext)",
          "12188:     {",
          "12189:         return JavascriptNativeFloatArray::GetItem(originalInstance, index, value, requestContext);",
          "12190:     }",
          "12192:     BOOL JavascriptArray::SetProperty(PropertyId propertyId, Var value, PropertyOperationFlags flags, PropertyValueInfo* info)",
          "12193:     {",
          "12194: #if ENABLE_COPYONACCESS_ARRAY",
          "12195:         JavascriptLibrary::CheckAndConvertCopyOnAccessNativeIntArray<Var>(this);",
          "12196: #endif",
          "12197:         uint32 indexValue;",
          "12198:         if (propertyId == PropertyIds::length)",
          "12199:         {",
          "12200:             return this->SetLength(value);",
          "12201:         }",
          "12202:         else if (GetScriptContext()->IsNumericPropertyId(propertyId, &indexValue))",
          "12203:         {",
          "12205:             return SetItem(indexValue, value, flags);",
          "12206:         }",
          "12207:         else",
          "12208:         {",
          "12209:             return DynamicObject::SetProperty(propertyId, value, flags, info);",
          "12210:         }",
          "12211:     }",
          "12213:     BOOL JavascriptArray::SetProperty(JavascriptString* propertyNameString, Var value, PropertyOperationFlags flags, PropertyValueInfo* info)",
          "12214:     {",
          "12215:         AssertMsg(!PropertyRecord::IsPropertyNameNumeric(propertyNameString->GetString(), propertyNameString->GetLength()),",
          "12216:             \"Numeric property names should have been converted to uint or PropertyRecord*\");",
          "12218: #if ENABLE_COPYONACCESS_ARRAY",
          "12219:         JavascriptLibrary::CheckAndConvertCopyOnAccessNativeIntArray<Var>(this);",
          "12220: #endif",
          "12221:         PropertyRecord const* propertyRecord;",
          "12222:         this->GetScriptContext()->FindPropertyRecord(propertyNameString, &propertyRecord);",
          "12224:         if (propertyRecord != nullptr && propertyRecord->GetPropertyId() == PropertyIds::length)",
          "12225:         {",
          "12226:             return this->SetLength(value);",
          "12227:         }",
          "12229:         return DynamicObject::SetProperty(propertyNameString, value, flags, info);",
          "12230:     }",
          "12232:     BOOL JavascriptArray::SetPropertyWithAttributes(PropertyId propertyId, Var value, PropertyAttributes attributes, PropertyValueInfo* info, PropertyOperationFlags flags, SideEffects possibleSideEffects)",
          "12233:     {",
          "12234: #if ENABLE_COPYONACCESS_ARRAY",
          "12235:         JavascriptLibrary::CheckAndConvertCopyOnAccessNativeIntArray<Var>(this);",
          "12236: #endif",
          "12237:         ScriptContext* scriptContext = GetScriptContext();",
          "12239:         if (propertyId == PropertyIds::length)",
          "12240:         {",
          "12241:             Assert(attributes == PropertyWritable);",
          "12242:             Assert(IsWritable(propertyId) && !IsConfigurable(propertyId) && !IsEnumerable(propertyId));",
          "12243:             return this->SetLength(value);",
          "12244:         }",
          "12246:         uint32 index;",
          "12247:         if (scriptContext->IsNumericPropertyId(propertyId, &index))",
          "12248:         {",
          "12250:             return SetItemWithAttributes(index, value, attributes);",
          "12251:         }",
          "12253:         return __super::SetPropertyWithAttributes(propertyId, value, attributes, info, flags, possibleSideEffects);",
          "12254:     }",
          "12256:     BOOL JavascriptArray::SetItem(uint32 index, Var value, PropertyOperationFlags flags)",
          "12257:     {",
          "12258:         this->DirectSetItemAt(index, value);",
          "12259:         return true;",
          "12260:     }",
          "12262:     BOOL JavascriptNativeIntArray::SetItem(uint32 index, Var value, PropertyOperationFlags flags)",
          "12263:     {",
          "12264:         int32 iValue;",
          "12265:         double dValue;",
          "12266: #if ENABLE_COPYONACCESS_ARRAY",
          "12267:         JavascriptLibrary::CheckAndConvertCopyOnAccessNativeIntArray<Var>(this);",
          "12268: #endif",
          "12269:         TypeId typeId = this->TrySetNativeIntArrayItem(value, &iValue, &dValue);",
          "12270:         if (typeId == TypeIds_NativeIntArray)",
          "12271:         {",
          "12272:             this->SetItem(index, iValue);",
          "12273:         }",
          "12274:         else if (typeId == TypeIds_NativeFloatArray)",
          "12275:         {",
          "12276:             reinterpret_cast<JavascriptNativeFloatArray*>(this)->DirectSetItemAt<double>(index, dValue);",
          "12277:         }",
          "12278:         else",
          "12279:         {",
          "12280:             this->DirectSetItemAt<Var>(index, value);",
          "12281:         }",
          "12283:         return TRUE;",
          "12284:     }",
          "12286:     TypeId JavascriptNativeIntArray::TrySetNativeIntArrayItem(Var value, int32 *iValue, double *dValue)",
          "12287:     {",
          "12288:         if (TaggedInt::Is(value))",
          "12289:         {",
          "12290:             int32 i = TaggedInt::ToInt32(value);",
          "12291:             if (i != JavascriptNativeIntArray::MissingItem)",
          "12292:             {",
          "12294:                 return TypeIds_NativeIntArray;",
          "12295:             }",
          "12296:         }",
          "12297:         if (JavascriptNumber::Is_NoTaggedIntCheck(value))",
          "12298:         {",
          "12299:             bool isInt32;",
          "12300:             int32 i;",
          "12301:             double d = JavascriptNumber::GetValue(value);",
          "12302:             if (JavascriptNumber::TryGetInt32OrUInt32Value(d, &i, &isInt32))",
          "12303:             {",
          "12304:                 if (isInt32 && i != JavascriptNativeIntArray::MissingItem)",
          "12305:                 {",
          "12307:                     return TypeIds_NativeIntArray;",
          "12308:                 }",
          "12309:             }",
          "12310:             else",
          "12311:             {",
          "12313:                 JavascriptNativeIntArray::ToNativeFloatArray(this);",
          "12314:                 return TypeIds_NativeFloatArray;",
          "12315:             }",
          "12316:         }",
          "12318:         JavascriptNativeIntArray::ToVarArray(this);",
          "12319:         return TypeIds_Array;",
          "12320:     }",
          "12322:     BOOL JavascriptNativeIntArray::SetItem(uint32 index, int32 iValue)",
          "12323:     {",
          "12324:         if (iValue == JavascriptNativeIntArray::MissingItem)",
          "12325:         {",
          "12326:             JavascriptArray *varArr = JavascriptNativeIntArray::ToVarArray(this);",
          "12327:             varArr->DirectSetItemAt(index, JavascriptNumber::ToVar(iValue, GetScriptContext()));",
          "12328:             return TRUE;",
          "12329:         }",
          "12331:         this->DirectSetItemAt(index, iValue);",
          "12332:         return TRUE;",
          "12333:     }",
          "12335:     BOOL JavascriptNativeFloatArray::SetItem(uint32 index, Var value, PropertyOperationFlags flags)",
          "12336:     {",
          "12337:         double dValue;",
          "12338:         TypeId typeId = this->TrySetNativeFloatArrayItem(value, &dValue);",
          "12339:         if (typeId == TypeIds_NativeFloatArray)",
          "12340:         {",
          "12341:             this->SetItem(index, dValue);",
          "12342:         }",
          "12343:         else",
          "12344:         {",
          "12345:             this->DirectSetItemAt(index, value);",
          "12346:         }",
          "12347:         return TRUE;",
          "12348:     }",
          "12350:     TypeId JavascriptNativeFloatArray::TrySetNativeFloatArrayItem(Var value, double *dValue)",
          "12351:     {",
          "12352:         if (TaggedInt::Is(value))",
          "12353:         {",
          "12355:             return TypeIds_NativeFloatArray;",
          "12356:         }",
          "12357:         else if (JavascriptNumber::Is_NoTaggedIntCheck(value))",
          "12358:         {",
          "12360:             return TypeIds_NativeFloatArray;",
          "12361:         }",
          "12363:         JavascriptNativeFloatArray::ToVarArray(this);",
          "12364:         return TypeIds_Array;",
          "12365:     }",
          "12367:     BOOL JavascriptNativeFloatArray::SetItem(uint32 index, double dValue)",
          "12368:     {",
          "12369:         if (*(uint64*)&dValue == *(uint64*)&JavascriptNativeFloatArray::MissingItem)",
          "12370:         {",
          "12371:             JavascriptArray *varArr = JavascriptNativeFloatArray::ToVarArray(this);",
          "12372:             varArr->DirectSetItemAt(index, JavascriptNumber::ToVarNoCheck(dValue, GetScriptContext()));",
          "12373:             return TRUE;",
          "12374:         }",
          "12376:         this->DirectSetItemAt<double>(index, dValue);",
          "12377:         return TRUE;",
          "12378:     }",
          "12380:     BOOL JavascriptArray::DeleteItem(uint32 index, PropertyOperationFlags flags)",
          "12381:     {",
          "12382:         return this->DirectDeleteItemAt<Var>(index);",
          "12383:     }",
          "12385:     BOOL JavascriptNativeIntArray::DeleteItem(uint32 index, PropertyOperationFlags flags)",
          "12386:     {",
          "12387:         return this->DirectDeleteItemAt<int32>(index);",
          "12388:     }",
          "12390:     BOOL JavascriptNativeFloatArray::DeleteItem(uint32 index, PropertyOperationFlags flags)",
          "12391:     {",
          "12392:         return this->DirectDeleteItemAt<double>(index);",
          "12393:     }",
          "12395:     BOOL JavascriptArray::GetEnumerator(JavascriptStaticEnumerator * enumerator, EnumeratorFlags flags, ScriptContext* requestContext, ForInCache * forInCache)",
          "12396:     {",
          "12397:         return enumerator->Initialize(nullptr, this, this, flags, requestContext, forInCache);",
          "12398:     }",
          "12400:     BOOL JavascriptArray::GetDiagValueString(StringBuilder<ArenaAllocator>* stringBuilder, ScriptContext* requestContext)",
          "12401:     {",
          "12402:         stringBuilder->Append(_u('['));",
          "12404:         if (this->length < 10)",
          "12405:         {",
          "12406:             auto funcPtr = [&]()",
          "12407:             {",
          "12408:                 ENTER_PINNED_SCOPE(JavascriptString, valueStr);",
          "12409:                 valueStr = JavascriptArray::JoinHelper(this, GetLibrary()->GetCommaDisplayString(), requestContext);",
          "12410:                 stringBuilder->Append(valueStr->GetString(), valueStr->GetLength());",
          "12411:                 LEAVE_PINNED_SCOPE();",
          "12412:             };",
          "12414:             if (!requestContext->GetThreadContext()->IsScriptActive())",
          "12415:             {",
          "12416:                 BEGIN_JS_RUNTIME_CALL(requestContext);",
          "12417:                 {",
          "12418:                     funcPtr();",
          "12419:                 }",
          "12420:                 END_JS_RUNTIME_CALL(requestContext);",
          "12421:             }",
          "12422:             else",
          "12423:             {",
          "12424:                 funcPtr();",
          "12425:             }",
          "12426:         }",
          "12427:         else",
          "12428:         {",
          "12429:             stringBuilder->AppendCppLiteral(_u(\"...\"));",
          "12430:         }",
          "12432:         stringBuilder->Append(_u(']'));",
          "12434:         return TRUE;",
          "12435:     }",
          "12437:     BOOL JavascriptArray::GetDiagTypeString(StringBuilder<ArenaAllocator>* stringBuilder, ScriptContext* requestContext)",
          "12438:     {",
          "12439:         stringBuilder->AppendCppLiteral(_u(\"Object, (Array)\"));",
          "12440:         return TRUE;",
          "12441:     }",
          "12443:     bool JavascriptNativeArray::Is(Var aValue)",
          "12444:     {",
          "12445:         TypeId typeId = JavascriptOperators::GetTypeId(aValue);",
          "12446:         return JavascriptNativeArray::Is(typeId);",
          "12447:     }",
          "12449:     bool JavascriptNativeArray::Is(TypeId typeId)",
          "12450:     {",
          "12451:         return JavascriptNativeIntArray::Is(typeId) || JavascriptNativeFloatArray::Is(typeId);",
          "12452:     }",
          "12454:     JavascriptNativeArray* JavascriptNativeArray::FromVar(Var aValue)",
          "12455:     {",
          "12456:         AssertMsg(Is(aValue), \"Ensure var is actually a 'JavascriptNativeArray'\");",
          "12458:         return static_cast<JavascriptNativeArray *>(RecyclableObject::FromVar(aValue));",
          "12459:     }",
          "12461:     bool JavascriptNativeIntArray::Is(Var aValue)",
          "12462:     {",
          "12463:         TypeId typeId = JavascriptOperators::GetTypeId(aValue);",
          "12464:         return JavascriptNativeIntArray::Is(typeId);",
          "12465:     }",
          "12467: #if ENABLE_COPYONACCESS_ARRAY",
          "12468:     bool JavascriptCopyOnAccessNativeIntArray::Is(Var aValue)",
          "12469:     {",
          "12470:         TypeId typeId = JavascriptOperators::GetTypeId(aValue);",
          "12471:         return JavascriptCopyOnAccessNativeIntArray::Is(typeId);",
          "12472:     }",
          "12473: #endif",
          "12475:     bool JavascriptNativeIntArray::Is(TypeId typeId)",
          "12476:     {",
          "12477:         return typeId == TypeIds_NativeIntArray;",
          "12478:     }",
          "12480: #if ENABLE_COPYONACCESS_ARRAY",
          "12481:     bool JavascriptCopyOnAccessNativeIntArray::Is(TypeId typeId)",
          "12482:     {",
          "12483:         return typeId == TypeIds_CopyOnAccessNativeIntArray;",
          "12484:     }",
          "12485: #endif",
          "12487:     bool JavascriptNativeIntArray::IsNonCrossSite(Var aValue)",
          "12488:     {",
          "12489:         bool ret = !TaggedInt::Is(aValue) && VirtualTableInfo<JavascriptNativeIntArray>::HasVirtualTable(aValue);",
          "12490:         Assert(ret == (JavascriptNativeIntArray::Is(aValue) && !JavascriptNativeIntArray::FromVar(aValue)->IsCrossSiteObject()));",
          "12491:         return ret;",
          "12492:     }",
          "12494:     JavascriptNativeIntArray* JavascriptNativeIntArray::FromVar(Var aValue)",
          "12495:     {",
          "12496:         AssertMsg(Is(aValue), \"Ensure var is actually a 'JavascriptNativeIntArray'\");",
          "12498:         return static_cast<JavascriptNativeIntArray *>(RecyclableObject::FromVar(aValue));",
          "12499:     }",
          "12501: #if ENABLE_COPYONACCESS_ARRAY",
          "12502:     JavascriptCopyOnAccessNativeIntArray* JavascriptCopyOnAccessNativeIntArray::FromVar(Var aValue)",
          "12503:     {",
          "12504:         AssertMsg(Is(aValue), \"Ensure var is actually a 'JavascriptCopyOnAccessNativeIntArray'\");",
          "12506:         return static_cast<JavascriptCopyOnAccessNativeIntArray *>(RecyclableObject::FromVar(aValue));",
          "12507:     }",
          "12508: #endif",
          "12510:     bool JavascriptNativeFloatArray::Is(Var aValue)",
          "12511:     {",
          "12512:         TypeId typeId = JavascriptOperators::GetTypeId(aValue);",
          "12513:         return JavascriptNativeFloatArray::Is(typeId);",
          "12514:     }",
          "12516:     bool JavascriptNativeFloatArray::Is(TypeId typeId)",
          "12517:     {",
          "12518:         return typeId == TypeIds_NativeFloatArray;",
          "12519:     }",
          "12521:     bool JavascriptNativeFloatArray::IsNonCrossSite(Var aValue)",
          "12522:     {",
          "12523:         bool ret = !TaggedInt::Is(aValue) && VirtualTableInfo<JavascriptNativeFloatArray>::HasVirtualTable(aValue);",
          "12524:         Assert(ret == (JavascriptNativeFloatArray::Is(aValue) && !JavascriptNativeFloatArray::FromVar(aValue)->IsCrossSiteObject()));",
          "12525:         return ret;",
          "12526:     }",
          "12528:     JavascriptNativeFloatArray* JavascriptNativeFloatArray::FromVar(Var aValue)",
          "12529:     {",
          "12530:         AssertMsg(Is(aValue), \"Ensure var is actually a 'JavascriptNativeFloatArray'\");",
          "12532:         return static_cast<JavascriptNativeFloatArray *>(RecyclableObject::FromVar(aValue));",
          "12533:     }",
          "12535:     template int   Js::JavascriptArray::GetParamForIndexOf<unsigned int>(unsigned int, Js::Arguments const&, void*&, unsigned int&, Js::ScriptContext*);",
          "12536:     template bool  Js::JavascriptArray::ArrayElementEnumerator::MoveNext<void*>();",
          "12537:     template void  Js::JavascriptArray::SetArrayLiteralItem<void*>(unsigned int, void*);",
          "12538:     template void* Js::JavascriptArray::TemplatedIndexOfHelper<false, Js::TypedArrayBase, unsigned int>(Js::TypedArrayBase*, void*, unsigned int, unsigned int, Js::ScriptContext*);",
          "12539:     template void* Js::JavascriptArray::TemplatedIndexOfHelper<true, Js::TypedArrayBase, unsigned int>(Js::TypedArrayBase*, void*, unsigned int, unsigned int, Js::ScriptContext*);",
          "12540: } //namespace Js",
          "",
          "[Added Lines]",
          "6: #include \"RuntimeLibraryPch.h\"",
          "7: #include \"Types/PathTypeHandler.h\"",
          "8: #include \"Types/SpreadArgument.h\"",
          "11: #define AssertAndFailFast(x) if (!(x)) { Assert(x); Js::Throw::FatalInternalError(); }",
          "13: namespace Js",
          "14: {",
          "17:     static const char EmptySegmentData[sizeof(SparseArraySegmentBase)] = {0};",
          "18:     const SparseArraySegmentBase *JavascriptArray::EmptySegment = (SparseArraySegmentBase *)&EmptySegmentData;",
          "24:     uint JavascriptNativeFloatArray::allocationBuckets[][AllocationBucketsInfoSize] =",
          "25:     {",
          "26:         { 3, 0, 0 },    // allocate space for 3 elements for array of length 0,1,2,3",
          "27:         { 5, 0, 0 },    // allocate space for 5 elements for array of length 4,5",
          "28:         { 8, 0, 0 },    // allocate space for 8 elements for array of length 6,7,8",
          "29:     };",
          "30: #if defined(_M_X64_OR_ARM64)",
          "31:     const Var JavascriptArray::MissingItem = (Var)0x8000000280000002;",
          "32:     uint JavascriptNativeIntArray::allocationBuckets[][AllocationBucketsInfoSize] =",
          "33:     {",
          "35:         {2, 0, 0},",
          "36:         {6, 0, 0},",
          "37:         {8, 0, 0},",
          "38:     };",
          "39:     uint JavascriptArray::allocationBuckets[][AllocationBucketsInfoSize] =",
          "40:     {",
          "42:         {4, 0, 0},",
          "43:         {6, 0, 0},",
          "44:         {8, 0, 0},",
          "45:     };",
          "46: #else",
          "47:     const Var JavascriptArray::MissingItem = (Var)0x80000002;",
          "48:     uint JavascriptNativeIntArray::allocationBuckets[][AllocationBucketsInfoSize] =",
          "49:     {",
          "51:         { 3, 0, 0 },",
          "52:         { 7, 0, 0 },",
          "53:         { 8, 0, 0 },",
          "54:     };",
          "55:     uint JavascriptArray::allocationBuckets[][AllocationBucketsInfoSize] =",
          "56:     {",
          "58:         { 4, 0, 0 },",
          "59:         { 8, 0, 0 },",
          "60:     };",
          "61: #endif",
          "63:     const int32 JavascriptNativeIntArray::MissingItem = 0x80000002;",
          "64:     static const uint64 FloatMissingItemPattern = 0x8000000280000002ull;",
          "65:     const double JavascriptNativeFloatArray::MissingItem = *(double*)&FloatMissingItemPattern;",
          "68:     const size_t JavascriptArray::StackAllocationSize = DetermineAllocationSize<JavascriptArray, 4>(16);",
          "69:     const size_t JavascriptNativeIntArray::StackAllocationSize = DetermineAllocationSize<JavascriptNativeIntArray, 4>(16);",
          "70:     const size_t JavascriptNativeFloatArray::StackAllocationSize = DetermineAllocationSize<JavascriptNativeFloatArray, 4>(16);",
          "72:     SegmentBTree::SegmentBTree()",
          "73:         : segmentCount(0),",
          "74:           segments(nullptr),",
          "75:           keys(nullptr),",
          "76:           children(nullptr)",
          "77:     {",
          "78:     }",
          "80:     uint32 SegmentBTree::GetLazyCrossOverLimit()",
          "81:     {",
          "82: #ifdef ENABLE_DEBUG_CONFIG_OPTIONS",
          "83:         if (Js::Configuration::Global.flags.DisableArrayBTree)",
          "84:         {",
          "85:             return Js::JavascriptArray::InvalidIndex;",
          "86:         }",
          "87:         else if (Js::Configuration::Global.flags.ForceArrayBTree)",
          "88:         {",
          "89:             return ARRAY_CROSSOVER_FOR_VALIDATE;",
          "90:         }",
          "91: #endif",
          "92: #ifdef VALIDATE_ARRAY",
          "93:         if (Js::Configuration::Global.flags.ArrayValidate)",
          "94:         {",
          "95:             return ARRAY_CROSSOVER_FOR_VALIDATE;",
          "96:         }",
          "97: #endif",
          "98:         return SegmentBTree::MinDegree * 3;",
          "99:     }",
          "101:     BOOL SegmentBTree::IsLeaf() const",
          "102:     {",
          "103:         return children == NULL;",
          "104:     }",
          "105:     BOOL SegmentBTree::IsFullNode() const",
          "106:     {",
          "107:         return segmentCount == MaxKeys;",
          "108:     }",
          "110:     void SegmentBTree::InternalFind(SegmentBTree* node, uint32 itemIndex, SparseArraySegmentBase*& prev, SparseArraySegmentBase*& matchOrNext)",
          "111:     {",
          "112:         uint32 i = 0;",
          "114:         for(; i < node->segmentCount; i++)",
          "115:         {",
          "116:             Assert(node->keys[i] == node->segments[i]->left);",
          "117:             if (itemIndex <  node->keys[i])",
          "118:             {",
          "119:                 break;",
          "120:             }",
          "121:         }",
          "127:         bool matches = i > 0 && (itemIndex == node->keys[i-1] || itemIndex < node->keys[i-1] + node->segments[i-1]->length);",
          "129:         if (matches)",
          "130:         {",
          "132:             if (node->IsLeaf())",
          "133:             {",
          "134:                 if (i > 1)",
          "135:                 {",
          "137:                     prev = node->segments[i-2];",
          "138:                 }",
          "139:             }",
          "140:             else",
          "141:             {",
          "143:                 SegmentBTree* child = &node->children[i - 1];",
          "144:                 while (!child->IsLeaf())",
          "145:                 {",
          "146:                     child = &child->children[child->segmentCount];",
          "147:                 }",
          "148:                 prev = child->segments[child->segmentCount - 1];",
          "149:             }",
          "152:             matchOrNext = node->segments[i-1];",
          "153:         }",
          "154:         else // itemIndex in between segment i-1 and i",
          "155:         {",
          "156:             if (i > 0)",
          "157:             {",
          "159:                 prev = node->segments[i-1];",
          "160:             }",
          "162:             if (node->IsLeaf())",
          "163:             {",
          "164:                 matchOrNext = (i == 0 ? node->segments[0] : PointerValue(prev->next));",
          "165:             }",
          "166:             else",
          "167:             {",
          "168:                 InternalFind(node->children + i, itemIndex, prev, matchOrNext);",
          "169:             }",
          "170:         }",
          "171:     }",
          "173:     void SegmentBTreeRoot::Find(uint32 itemIndex, SparseArraySegmentBase*& prev, SparseArraySegmentBase*& matchOrNext)",
          "174:     {",
          "175:         prev = matchOrNext = NULL;",
          "176:         InternalFind(this, itemIndex, prev, matchOrNext);",
          "177:         Assert(prev == NULL || (prev->next == matchOrNext));// If prev exists it is immediately before matchOrNext in the list of arraysegments",
          "178:         Assert(prev == NULL || (prev->left < itemIndex && prev->left + prev->length <= itemIndex)); // prev should never be a match (left is a match if length == 0)",
          "179:         Assert(matchOrNext == NULL || (matchOrNext->left >= itemIndex || matchOrNext->left + matchOrNext->length > itemIndex));",
          "180:     }",
          "182:     void SegmentBTreeRoot::Add(Recycler* recycler, SparseArraySegmentBase* newSeg)",
          "183:     {",
          "185:         if (IsFullNode())",
          "186:         {",
          "187:             SegmentBTree * children = AllocatorNewArrayZ(Recycler, recycler, SegmentBTree, MaxDegree);",
          "188:             children[0] = *this;",
          "192:             this->segmentCount = 0;",
          "193:             this->segments = AllocatorNewArrayLeafZ(Recycler, recycler, SparseArraySegmentBase*, MaxKeys);",
          "194:             this->keys = AllocatorNewArrayLeafZ(Recycler,recycler,uint32,MaxKeys);",
          "195:             this->children = children;",
          "198:             SplitChild(recycler, this, 0, &children[0]);",
          "199:         }",
          "200:         InsertNonFullNode(recycler, this, newSeg);",
          "201:     }",
          "203:     void SegmentBTree::SwapSegment(uint32 originalKey, SparseArraySegmentBase* oldSeg, SparseArraySegmentBase* newSeg)",
          "204:     {",
          "206:         uint32 itemIndex = originalKey;",
          "207:         uint32 i = 0;",
          "209:         for(; i < segmentCount; i++)",
          "210:         {",
          "211:             Assert(keys[i] == segments[i]->left || (oldSeg == newSeg && newSeg == segments[i]));",
          "212:             if (itemIndex <  keys[i])",
          "213:             {",
          "214:                 break;",
          "215:             }",
          "216:         }",
          "220:         if (i > 0)",
          "221:         {",
          "222:             if (oldSeg == segments[i-1])",
          "223:             {",
          "224:                 segments[i-1] = newSeg;",
          "225:                 keys[i-1] = newSeg->left;",
          "226:                 return;",
          "227:             }",
          "228:         }",
          "230:         Assert(!IsLeaf());",
          "231:         children[i].SwapSegment(originalKey, oldSeg, newSeg);",
          "232:     }",
          "235:     void SegmentBTree::SplitChild(Recycler* recycler, SegmentBTree* parent, uint32 iChild, SegmentBTree* child)",
          "236:     {",
          "240:         Assert(child != NULL);",
          "241:         Assert(parent != NULL);",
          "242:         Assert(!parent->IsFullNode());",
          "243:         Assert(child->IsFullNode());",
          "245:         SegmentBTree newNode;",
          "246:         newNode.segmentCount = MinKeys;",
          "250:         newNode.segments = AllocatorNewArrayLeafZ(Recycler, recycler, SparseArraySegmentBase*, MaxKeys);",
          "251:         newNode.keys = AllocatorNewArrayLeafZ(Recycler,recycler,uint32,MaxKeys);",
          "254:         for(uint32 i = 0; i < MinKeys; i++)",
          "255:         {",
          "256:             newNode.segments[i] = child->segments[i+MinDegree];",
          "257:             newNode.keys[i] = child->keys[i+MinDegree];",
          "260:             child->segments[i+MinDegree] = nullptr;",
          "261:         }",
          "264:         if (!child->IsLeaf())",
          "265:         {",
          "266:             newNode.children = AllocatorNewArrayZ(Recycler, recycler, SegmentBTree, MaxDegree);",
          "267:             for(uint32 j = 0; j < MinDegree; j++)",
          "268:             {",
          "269:                 newNode.children[j] = child->children[j+MinDegree];",
          "272:                 child->children[j+MinDegree].segments = nullptr;",
          "273:                 child->children[j+MinDegree].children = nullptr;",
          "274:             }",
          "275:         }",
          "276:         child->segmentCount = MinKeys;",
          "279:         for(uint32 j = parent->segmentCount; j > iChild; j--)",
          "280:         {",
          "281:             parent->children[j+1] = parent->children[j];",
          "282:         }",
          "284:         parent->children[iChild+1] = newNode;",
          "287:         for(uint32 k = parent->segmentCount; k > iChild; k--)",
          "288:         {",
          "289:             parent->segments[k] = parent->segments[k-1];",
          "290:             parent->keys[k] = parent->keys[k-1];",
          "291:         }",
          "294:         parent->segments[iChild] = child->segments[MinKeys];",
          "295:         parent->keys[iChild] = child->keys[MinKeys];",
          "298:         child->segments[MinKeys] = nullptr;",
          "300:         parent->segmentCount++;",
          "301:     }",
          "303:     void SegmentBTree::InsertNonFullNode(Recycler* recycler, SegmentBTree* node, SparseArraySegmentBase* newSeg)",
          "304:     {",
          "305:         Assert(!node->IsFullNode());",
          "306:         AnalysisAssert(node->segmentCount < MaxKeys);       // Same as !node->IsFullNode()",
          "307:         Assert(newSeg != NULL);",
          "309:         if (node->IsLeaf())",
          "310:         {",
          "312:             uint32 i = node->segmentCount - 1;",
          "313:             while( (i != -1) && (newSeg->left < node->keys[i]))",
          "314:             {",
          "315:                 node->segments[i+1] = node->segments[i];",
          "316:                 node->keys[i+1] = node->keys[i];",
          "317:                 i--;",
          "318:             }",
          "319:             if (!node->segments)",
          "320:             {",
          "323:                 node->segments = AllocatorNewArrayLeafZ(Recycler, recycler, SparseArraySegmentBase*, MaxKeys);",
          "324:                 node->keys = AllocatorNewArrayLeafZ(Recycler, recycler, uint32, MaxKeys);",
          "325:             }",
          "326:             node->segments[i + 1] = newSeg;",
          "327:             node->keys[i + 1] = newSeg->left;",
          "328:             node->segmentCount++;",
          "329:         }",
          "330:         else",
          "331:         {",
          "333:             uint32 i = node->segmentCount-1;",
          "335:             while((i != -1) && (newSeg->left < node->keys[i]))",
          "336:             {",
          "337:                 i--;",
          "338:             }",
          "339:             i++;",
          "342:             if(node->children[i].IsFullNode())",
          "343:             {",
          "345:                 SplitChild(recycler, node, i, node->children+i);",
          "346:                 Assert(node->keys[i] == node->segments[i]->left);",
          "347:                 if (newSeg->left > node->keys[i])",
          "348:                 {",
          "349:                     i++;",
          "350:                 }",
          "351:             }",
          "352:             InsertNonFullNode(recycler, node->children+i, newSeg);",
          "353:         }",
          "354:     }",
          "356:     inline void ThrowTypeErrorOnFailureHelper::ThrowTypeErrorOnFailure(BOOL operationSucceeded)",
          "357:     {",
          "358:         if (IsThrowTypeError(operationSucceeded))",
          "359:         {",
          "360:             ThrowTypeErrorOnFailure();",
          "361:         }",
          "362:     }",
          "364:     inline void ThrowTypeErrorOnFailureHelper::ThrowTypeErrorOnFailure()",
          "365:     {",
          "366:         JavascriptError::ThrowTypeError(m_scriptContext, VBSERR_ActionNotSupported, m_functionName);",
          "367:     }",
          "369:     inline BOOL ThrowTypeErrorOnFailureHelper::IsThrowTypeError(BOOL operationSucceeded)",
          "370:     {",
          "371:         return !operationSucceeded;",
          "372:     }",
          "376:     JavascriptArray::JavascriptArray(DynamicType * type)",
          "377:         : ArrayObject(type, false, 0)",
          "378:     {",
          "379:         Assert(type->GetTypeId() == TypeIds_Array || type->GetTypeId() == TypeIds_NativeIntArray || type->GetTypeId() == TypeIds_NativeFloatArray || ((type->GetTypeId() == TypeIds_ES5Array || type->GetTypeId() == TypeIds_Object) && type->GetPrototype() == GetScriptContext()->GetLibrary()->GetArrayPrototype()));",
          "380:         Assert(EmptySegment->length == 0 && EmptySegment->size == 0 && EmptySegment->next == NULL);",
          "381:         InitArrayFlags(DynamicObjectFlags::InitialArrayValue);",
          "382:         SetHeadAndLastUsedSegment(const_cast<SparseArraySegmentBase *>(EmptySegment));",
          "384:     }",
          "386:     JavascriptArray::JavascriptArray(uint32 length, DynamicType * type)",
          "387:         : ArrayObject(type, false, length)",
          "388:     {",
          "389:         Assert(JavascriptArray::Is(type->GetTypeId()));",
          "390:         Assert(EmptySegment->length == 0 && EmptySegment->size == 0 && EmptySegment->next == NULL);",
          "391:         InitArrayFlags(DynamicObjectFlags::InitialArrayValue);",
          "392:         SetHeadAndLastUsedSegment(const_cast<SparseArraySegmentBase *>(EmptySegment));",
          "393:     }",
          "395:     JavascriptArray::JavascriptArray(uint32 length, uint32 size, DynamicType * type)",
          "396:         : ArrayObject(type, false, length)",
          "397:     {",
          "398:         Assert(type->GetTypeId() == TypeIds_Array);",
          "399:         InitArrayFlags(DynamicObjectFlags::InitialArrayValue);",
          "400:         Recycler* recycler = GetRecycler();",
          "401:         SetHeadAndLastUsedSegment(SparseArraySegment<Var>::AllocateSegment(recycler, 0, 0, size, nullptr));",
          "402:     }",
          "404:     JavascriptArray::JavascriptArray(DynamicType * type, uint32 size)",
          "405:         : ArrayObject(type, false)",
          "406:     {",
          "407:         InitArrayFlags(DynamicObjectFlags::InitialArrayValue);",
          "408:         SetHeadAndLastUsedSegment(DetermineInlineHeadSegmentPointer<JavascriptArray, 0, false>(this));",
          "409:         head->size = size;",
          "410:         Var fill = Js::JavascriptArray::MissingItem;",
          "411:         for (uint i = 0; i < size; i++)",
          "412:         {",
          "413:             SparseArraySegment<Var>::From(head)->elements[i] = fill;",
          "414:         }",
          "415:     }",
          "417:     JavascriptNativeIntArray::JavascriptNativeIntArray(uint32 length, uint32 size, DynamicType * type)",
          "418:         : JavascriptNativeArray(type)",
          "419:     {",
          "420:         Assert(type->GetTypeId() == TypeIds_NativeIntArray);",
          "421:         this->length = length;",
          "422:         Recycler* recycler = GetRecycler();",
          "423:         SetHeadAndLastUsedSegment(SparseArraySegment<int32>::AllocateSegment(recycler, 0, 0, size, nullptr));",
          "424:     }",
          "426:     JavascriptNativeIntArray::JavascriptNativeIntArray(DynamicType * type, uint32 size)",
          "427:         : JavascriptNativeArray(type)",
          "428:     {",
          "429:         SetHeadAndLastUsedSegment(DetermineInlineHeadSegmentPointer<JavascriptNativeIntArray, 0, false>(this));",
          "430:         head->size = size;",
          "431:         SparseArraySegment<int32>::From(head)->FillSegmentBuffer(0, size);",
          "432:     }",
          "434:     JavascriptNativeFloatArray::JavascriptNativeFloatArray(uint32 length, uint32 size, DynamicType * type)",
          "435:         : JavascriptNativeArray(type)",
          "436:     {",
          "437:         Assert(type->GetTypeId() == TypeIds_NativeFloatArray);",
          "438:         this->length = length;",
          "439:         Recycler* recycler = GetRecycler();",
          "440:         SetHeadAndLastUsedSegment(SparseArraySegment<double>::AllocateSegment(recycler, 0, 0, size, nullptr));",
          "441:     }",
          "443:     JavascriptNativeFloatArray::JavascriptNativeFloatArray(DynamicType * type, uint32 size)",
          "444:         : JavascriptNativeArray(type)",
          "445:     {",
          "446:         SetHeadAndLastUsedSegment(DetermineInlineHeadSegmentPointer<JavascriptNativeFloatArray, 0, false>(this));",
          "447:         head->size = size;",
          "448:         SparseArraySegment<double>::From(head)->FillSegmentBuffer(0, size);",
          "449:     }",
          "451:     bool JavascriptArray::Is(Var aValue)",
          "452:     {",
          "453:         TypeId typeId = JavascriptOperators::GetTypeId(aValue);",
          "454:         return JavascriptArray::Is(typeId);",
          "455:     }",
          "457:     bool JavascriptArray::Is(TypeId typeId)",
          "458:     {",
          "459:         return typeId >= TypeIds_ArrayFirst && typeId <= TypeIds_ArrayLast;",
          "460:     }",
          "462:     bool JavascriptArray::IsVarArray(Var aValue)",
          "463:     {",
          "464:         TypeId typeId = JavascriptOperators::GetTypeId(aValue);",
          "465:         return JavascriptArray::IsVarArray(typeId);",
          "466:     }",
          "468:     bool JavascriptArray::IsVarArray(TypeId typeId)",
          "469:     {",
          "470:         return typeId == TypeIds_Array;",
          "471:     }",
          "473:     template<typename T>",
          "474:     bool JavascriptArray::IsMissingItemAt(uint32 index) const",
          "475:     {",
          "476:         SparseArraySegment<T>* headSeg = SparseArraySegment<T>::From(this->head);",
          "478:         return SparseArraySegment<T>::IsMissingItem(&headSeg->elements[index]);",
          "479:     }",
          "481:     bool JavascriptArray::IsMissingItem(uint32 index)",
          "482:     {",
          "483:         if (this->length <= index)",
          "484:         {",
          "485:             return false;",
          "486:         }",
          "488:         bool isIntArray = false, isFloatArray = false;",
          "489:         this->GetArrayTypeAndConvert(&isIntArray, &isFloatArray);",
          "491:         if (isIntArray)",
          "492:         {",
          "493:             return IsMissingItemAt<int32>(index);",
          "494:         }",
          "495:         else if (isFloatArray)",
          "496:         {",
          "497:             return IsMissingItemAt<double>(index);",
          "498:         }",
          "499:         else",
          "500:         {",
          "501:             return IsMissingItemAt<Var>(index);",
          "502:         }",
          "503:     }",
          "505:     JavascriptArray* JavascriptArray::FromVar(Var aValue)",
          "506:     {",
          "507:         AssertMsg(Is(aValue), \"Ensure var is actually a 'JavascriptArray'\");",
          "509:         return static_cast<JavascriptArray *>(RecyclableObject::FromVar(aValue));",
          "510:     }",
          "513:     JavascriptArray* JavascriptArray::FromAnyArray(Var aValue)",
          "514:     {",
          "515:         AssertMsg(Is(aValue) || ES5Array::Is(aValue), \"Ensure var is actually a 'JavascriptArray' or 'ES5Array'\");",
          "517:         return static_cast<JavascriptArray *>(RecyclableObject::FromVar(aValue));",
          "518:     }",
          "521:     bool JavascriptArray::IsDirectAccessArray(Var aValue)",
          "522:     {",
          "523:         return RecyclableObject::Is(aValue) &&",
          "524:             (VirtualTableInfo<JavascriptArray>::HasVirtualTable(aValue) ||",
          "525:                 VirtualTableInfo<JavascriptNativeIntArray>::HasVirtualTable(aValue) ||",
          "526:                 VirtualTableInfo<JavascriptNativeFloatArray>::HasVirtualTable(aValue));",
          "527:     }",
          "529:     DynamicObjectFlags JavascriptArray::GetFlags() const",
          "530:     {",
          "531:         return GetArrayFlags();",
          "532:     }",
          "534:     DynamicObjectFlags JavascriptArray::GetFlags_Unchecked() const // do not use except in extreme circumstances",
          "535:     {",
          "536:         return GetArrayFlags_Unchecked();",
          "537:     }",
          "539:     void JavascriptArray::SetFlags(const DynamicObjectFlags flags)",
          "540:     {",
          "541:         SetArrayFlags(flags);",
          "542:     }",
          "544:     DynamicType * JavascriptArray::GetInitialType(ScriptContext * scriptContext)",
          "545:     {",
          "546:         return scriptContext->GetLibrary()->GetArrayType();",
          "547:     }",
          "549:     JavascriptArray *JavascriptArray::GetArrayForArrayOrObjectWithArray(const Var var)",
          "550:     {",
          "551:         bool isObjectWithArray;",
          "552:         TypeId arrayTypeId;",
          "553:         return GetArrayForArrayOrObjectWithArray(var, &isObjectWithArray, &arrayTypeId);",
          "554:     }",
          "556:     JavascriptArray *JavascriptArray::GetArrayForArrayOrObjectWithArray(",
          "557:         const Var var,",
          "558:         bool *const isObjectWithArrayRef,",
          "559:         TypeId *const arrayTypeIdRef)",
          "560:     {",
          "564:         Assert(var);",
          "565:         Assert(isObjectWithArrayRef);",
          "566:         Assert(arrayTypeIdRef);",
          "571:         if(!RecyclableObject::Is(var))",
          "572:         {",
          "573:             return nullptr;",
          "574:         }",
          "576:         JavascriptArray *array = nullptr;",
          "577:         INT_PTR vtable = VirtualTableInfoBase::GetVirtualTable(var);",
          "578:         if(vtable == VirtualTableInfo<DynamicObject>::Address)",
          "579:         {",
          "580:             ArrayObject* objectArray = DynamicObject::FromVar(var)->GetObjectArray();",
          "581:             array = (objectArray && Is(objectArray)) ? FromVar(objectArray) : nullptr;",
          "582:             if(!array)",
          "583:             {",
          "584:                 return nullptr;",
          "585:             }",
          "587:             vtable = VirtualTableInfoBase::GetVirtualTable(array);",
          "588:         }",
          "590:         if(vtable == VirtualTableInfo<JavascriptArray>::Address)",
          "591:         {",
          "593:         }",
          "594:         else if(vtable == VirtualTableInfo<JavascriptNativeIntArray>::Address)",
          "595:         {",
          "597:         }",
          "598:         else if(vtable == VirtualTableInfo<JavascriptNativeFloatArray>::Address)",
          "599:         {",
          "601:         }",
          "602:         else",
          "603:         {",
          "604:             return nullptr;",
          "605:         }",
          "607:         if(!array)",
          "608:         {",
          "609:             array = FromVar(var);",
          "610:         }",
          "611:         return array;",
          "612:     }",
          "614:     const SparseArraySegmentBase *JavascriptArray::Jit_GetArrayHeadSegmentForArrayOrObjectWithArray(const Var var)",
          "615:     {",
          "618:         JavascriptArray *const array = GetArrayForArrayOrObjectWithArray(var);",
          "619:         return array ? array->head : nullptr;",
          "620:     }",
          "622:     uint32 JavascriptArray::Jit_GetArrayHeadSegmentLength(const SparseArraySegmentBase *const headSegment)",
          "623:     {",
          "626:         return headSegment ? headSegment->length : 0;",
          "627:     }",
          "629:     bool JavascriptArray::Jit_OperationInvalidatedArrayHeadSegment(",
          "630:         const SparseArraySegmentBase *const headSegmentBeforeOperation,",
          "631:         const uint32 headSegmentLengthBeforeOperation,",
          "632:         const Var varAfterOperation)",
          "633:     {",
          "636:         Assert(varAfterOperation);",
          "638:         if(!headSegmentBeforeOperation)",
          "639:         {",
          "640:             return false;",
          "641:         }",
          "643:         const SparseArraySegmentBase *const headSegmentAfterOperation =",
          "644:             Jit_GetArrayHeadSegmentForArrayOrObjectWithArray(varAfterOperation);",
          "645:         return",
          "646:             headSegmentAfterOperation != headSegmentBeforeOperation ||",
          "647:             headSegmentAfterOperation->length != headSegmentLengthBeforeOperation;",
          "648:     }",
          "650:     uint32 JavascriptArray::Jit_GetArrayLength(const Var var)",
          "651:     {",
          "654:         bool isObjectWithArray;",
          "655:         TypeId arrayTypeId;",
          "656:         JavascriptArray *const array = GetArrayForArrayOrObjectWithArray(var, &isObjectWithArray, &arrayTypeId);",
          "657:         return array && !isObjectWithArray ? array->GetLength() : 0;",
          "658:     }",
          "660:     bool JavascriptArray::Jit_OperationInvalidatedArrayLength(const uint32 lengthBeforeOperation, const Var varAfterOperation)",
          "661:     {",
          "664:         return Jit_GetArrayLength(varAfterOperation) != lengthBeforeOperation;",
          "665:     }",
          "667:     DynamicObjectFlags JavascriptArray::Jit_GetArrayFlagsForArrayOrObjectWithArray(const Var var)",
          "668:     {",
          "671:         JavascriptArray *const array = GetArrayForArrayOrObjectWithArray(var);",
          "672:         return array && array->UsesObjectArrayOrFlagsAsFlags() ? array->GetFlags() : DynamicObjectFlags::None;",
          "673:     }",
          "675:     bool JavascriptArray::Jit_OperationCreatedFirstMissingValue(",
          "676:         const DynamicObjectFlags flagsBeforeOperation,",
          "677:         const Var varAfterOperation)",
          "678:     {",
          "681:         Assert(varAfterOperation);",
          "683:         return",
          "684:             !!(flagsBeforeOperation & DynamicObjectFlags::HasNoMissingValues) &&",
          "685:             !(Jit_GetArrayFlagsForArrayOrObjectWithArray(varAfterOperation) & DynamicObjectFlags::HasNoMissingValues);",
          "686:     }",
          "688:     bool JavascriptArray::HasNoMissingValues() const",
          "689:     {",
          "690:         return !!(GetFlags() & DynamicObjectFlags::HasNoMissingValues);",
          "691:     }",
          "693:     bool JavascriptArray::HasNoMissingValues_Unchecked() const // do not use except in extreme circumstances",
          "694:     {",
          "695:         return !!(GetFlags_Unchecked() & DynamicObjectFlags::HasNoMissingValues);",
          "696:     }",
          "698:     void JavascriptArray::SetHasNoMissingValues(const bool hasNoMissingValues)",
          "699:     {",
          "700:         SetFlags(",
          "701:             hasNoMissingValues",
          "702:                 ? GetFlags() | DynamicObjectFlags::HasNoMissingValues",
          "703:                 : GetFlags() & ~DynamicObjectFlags::HasNoMissingValues);",
          "704:     }",
          "706:     template<class T>",
          "707:     bool JavascriptArray::IsMissingHeadSegmentItemImpl(const uint32 index) const",
          "708:     {",
          "709:         Assert(index < head->length);",
          "711:         return SparseArraySegment<T>::IsMissingItem(&SparseArraySegment<T>::From(head)->elements[index]);",
          "712:     }",
          "714:     bool JavascriptArray::IsMissingHeadSegmentItem(const uint32 index) const",
          "715:     {",
          "716:         return IsMissingHeadSegmentItemImpl<Var>(index);",
          "717:     }",
          "719: #if ENABLE_COPYONACCESS_ARRAY",
          "720:     void JavascriptCopyOnAccessNativeIntArray::ConvertCopyOnAccessSegment()",
          "721:     {",
          "722:         Assert(this->GetScriptContext()->GetLibrary()->cacheForCopyOnAccessArraySegments->IsValidIndex(::Math::PointerCastToIntegral<uint32>(this->GetHead())));",
          "723:         SparseArraySegment<int32> *seg = this->GetScriptContext()->GetLibrary()->cacheForCopyOnAccessArraySegments->GetSegmentByIndex(::Math::PointerCastToIntegral<byte>(this->GetHead()));",
          "724:         SparseArraySegment<int32> *newSeg = SparseArraySegment<int32>::AllocateLiteralHeadSegment(this->GetRecycler(), seg->length);",
          "726: #if ENABLE_DEBUG_CONFIG_OPTIONS",
          "727:         if (Js::Configuration::Global.flags.TestTrace.IsEnabled(Js::CopyOnAccessArrayPhase))",
          "728:         {",
          "729:             Output::Print(_u(\"Convert copy-on-access array: index(%d) length(%d)\\n\"), this->GetHead(), seg->length);",
          "730:             Output::Flush();",
          "731:         }",
          "732: #endif",
          "734:         newSeg->CopySegment(this->GetRecycler(), newSeg, 0, seg, 0, seg->length);",
          "735:         this->SetHeadAndLastUsedSegment(newSeg);",
          "737:         VirtualTableInfo<JavascriptNativeIntArray>::SetVirtualTable(this);",
          "738:         this->type = JavascriptNativeIntArray::GetInitialType(this->GetScriptContext());",
          "740:         ArrayCallSiteInfo *arrayInfo = this->GetArrayCallSiteInfo();",
          "741:         if (arrayInfo && !arrayInfo->isNotCopyOnAccessArray)",
          "742:         {",
          "743:             arrayInfo->isNotCopyOnAccessArray = 1;",
          "744:         }",
          "745:     }",
          "747:     uint32 JavascriptCopyOnAccessNativeIntArray::GetNextIndex(uint32 index) const",
          "748:     {",
          "749:         if (this->length == 0 || (index != Js::JavascriptArray::InvalidIndex && index >= this->length))",
          "750:         {",
          "751:             return Js::JavascriptArray::InvalidIndex;",
          "752:         }",
          "753:         else if (index == Js::JavascriptArray::InvalidIndex)",
          "754:         {",
          "755:             return 0;",
          "756:         }",
          "757:         else",
          "758:         {",
          "759:             return index + 1;",
          "760:         }",
          "761:     }",
          "763:     BOOL JavascriptCopyOnAccessNativeIntArray::DirectGetItemAt(uint32 index, int* outVal)",
          "764:     {",
          "765:         Assert(this->GetScriptContext()->GetLibrary()->cacheForCopyOnAccessArraySegments->IsValidIndex(::Math::PointerCastToIntegral<uint32>(this->GetHead())));",
          "766:         SparseArraySegment<int32> *seg = this->GetScriptContext()->GetLibrary()->cacheForCopyOnAccessArraySegments->GetSegmentByIndex(::Math::PointerCastToIntegral<byte>(this->GetHead()));",
          "768:         if (this->length == 0 || index == Js::JavascriptArray::InvalidIndex || index >= this->length)",
          "769:         {",
          "770:             return FALSE;",
          "771:         }",
          "772:         else",
          "773:         {",
          "775:             return TRUE;",
          "776:         }",
          "777:     }",
          "778: #endif",
          "780:     bool JavascriptNativeIntArray::IsMissingHeadSegmentItem(const uint32 index) const",
          "781:     {",
          "782:         return IsMissingHeadSegmentItemImpl<int32>(index);",
          "783:     }",
          "785:     bool JavascriptNativeFloatArray::IsMissingHeadSegmentItem(const uint32 index) const",
          "786:     {",
          "787:         return IsMissingHeadSegmentItemImpl<double>(index);",
          "788:     }",
          "790:     template<typename T>",
          "791:     void JavascriptArray::InternalFillFromPrototype(JavascriptArray *dstArray, const T& dstIndex, JavascriptArray *srcArray, uint32 start, uint32 end, uint32 count)",
          "792:     {",
          "793:         RecyclableObject* prototype = srcArray->GetPrototype();",
          "794:         while (start + count != end && JavascriptOperators::GetTypeId(prototype) != TypeIds_Null)",
          "795:         {",
          "796:             ForEachOwnMissingArrayIndexOfObject(srcArray, dstArray, prototype, start, end, dstIndex, [&](uint32 index, Var value) {",
          "797:                 T n = dstIndex + (index - start);",
          "798:                 dstArray->DirectSetItemAt(n, value);",
          "800:                 count++;",
          "801:             });",
          "803:             prototype = prototype->GetPrototype();",
          "804:         }",
          "805:     }",
          "807:     template<>",
          "808:     void JavascriptArray::InternalFillFromPrototype(JavascriptArray *dstArray, const uint32& dstIndex, JavascriptArray *srcArray, uint32 start, uint32 end, uint32 count)",
          "809:     {",
          "810:         RecyclableObject* prototype = srcArray->GetPrototype();",
          "811:         while (start + count != end && JavascriptOperators::GetTypeId(prototype) != TypeIds_Null)",
          "812:         {",
          "813:             ForEachOwnMissingArrayIndexOfObject(srcArray, dstArray, prototype, start, end, dstIndex, [&](uint32 index, Var value) {",
          "814:                 uint32 n = dstIndex + (index - start);",
          "815:                 dstArray->SetItem(n, value, PropertyOperation_None);",
          "817:                 count++;",
          "818:             });",
          "820:             prototype = prototype->GetPrototype();",
          "821:         }",
          "822:     }",
          "825:     bool JavascriptArray::HasInlineHeadSegment(uint32 length)",
          "826:     {",
          "827:         return length <= SparseArraySegmentBase::INLINE_CHUNK_SIZE;",
          "828:     }",
          "830:     Var JavascriptArray::OP_NewScArray(uint32 elementCount, ScriptContext* scriptContext)",
          "831:     {",
          "833:         return scriptContext->GetLibrary()->CreateArrayLiteral(elementCount);",
          "834:     }",
          "836:     Var JavascriptArray::OP_NewScArrayWithElements(uint32 elementCount, Var *elements, ScriptContext* scriptContext)",
          "837:     {",
          "839:         JavascriptArray *arr = scriptContext->GetLibrary()->CreateArrayLiteral(elementCount);",
          "841:         SparseArraySegment<Var> *head = SparseArraySegment<Var>::From(arr->head);",
          "842:         Assert(elementCount <= head->length);",
          "843:         CopyArray(head->elements, head->length, elements, elementCount);",
          "845: #ifdef VALIDATE_ARRAY",
          "846:         arr->ValidateArray();",
          "847: #endif",
          "849:         return arr;",
          "850:     }",
          "852:     Var JavascriptArray::OP_NewScArrayWithMissingValues(uint32 elementCount, ScriptContext* scriptContext)",
          "853:     {",
          "855:         JavascriptArray *const array = static_cast<JavascriptArray *>(OP_NewScArray(elementCount, scriptContext));",
          "856:         array->SetHasNoMissingValues(false);",
          "857:         SparseArraySegment<Var> *head = SparseArraySegment<Var>::From(array->head);",
          "858:         head->FillSegmentBuffer(0, elementCount);",
          "860:         return array;",
          "861:     }",
          "863: #if ENABLE_PROFILE_INFO",
          "864:     Var JavascriptArray::ProfiledNewScArray(uint32 elementCount, ScriptContext *scriptContext, ArrayCallSiteInfo *arrayInfo, RecyclerWeakReference<FunctionBody> *weakFuncRef)",
          "865:     {",
          "866:         if (arrayInfo->IsNativeIntArray())",
          "867:         {",
          "868:             JavascriptNativeIntArray *arr = scriptContext->GetLibrary()->CreateNativeIntArrayLiteral(elementCount);",
          "869:             arr->SetArrayProfileInfo(weakFuncRef, arrayInfo);",
          "870:             return arr;",
          "871:         }",
          "873:         if (arrayInfo->IsNativeFloatArray())",
          "874:         {",
          "875:             JavascriptNativeFloatArray *arr = scriptContext->GetLibrary()->CreateNativeFloatArrayLiteral(elementCount);",
          "876:             arr->SetArrayProfileInfo(weakFuncRef, arrayInfo);",
          "877:             return arr;",
          "878:         }",
          "880:         JavascriptArray *arr = scriptContext->GetLibrary()->CreateArrayLiteral(elementCount);",
          "881:         return arr;",
          "882:     }",
          "883: #endif",
          "884:     Var JavascriptArray::OP_NewScIntArray(AuxArray<int32> *ints, ScriptContext* scriptContext)",
          "885:     {",
          "886:         uint32 count = ints->count;",
          "887:         JavascriptArray *arr = scriptContext->GetLibrary()->CreateArrayLiteral(count);",
          "888:         SparseArraySegment<Var> *head = SparseArraySegment<Var>::From(arr->head);",
          "889:         Assert(count > 0 && count == head->length);",
          "890:         for (uint i = 0; i < count; i++)",
          "891:         {",
          "892:             head->elements[i] = JavascriptNumber::ToVar(ints->elements[i], scriptContext);",
          "893:         }",
          "894:         return arr;",
          "895:     }",
          "897: #if ENABLE_PROFILE_INFO",
          "898:     Var JavascriptArray::ProfiledNewScIntArray(AuxArray<int32> *ints, ScriptContext* scriptContext, ArrayCallSiteInfo *arrayInfo, RecyclerWeakReference<FunctionBody> *weakFuncRef)",
          "899:     {",
          "901:         uint32 count = ints->count;",
          "903:         if (arrayInfo->IsNativeIntArray())",
          "904:         {",
          "905:             JavascriptNativeIntArray *arr;",
          "907: #if ENABLE_COPYONACCESS_ARRAY",
          "908:             JavascriptLibrary *lib = scriptContext->GetLibrary();",
          "909:             FunctionBody *functionBody = weakFuncRef->Get();",
          "911:             if (JavascriptLibrary::IsCopyOnAccessArrayCallSite(lib, arrayInfo, count))",
          "912:             {",
          "913:                 Assert(lib->cacheForCopyOnAccessArraySegments);",
          "914:                 arr = scriptContext->GetLibrary()->CreateCopyOnAccessNativeIntArrayLiteral(arrayInfo, functionBody, ints);",
          "915:             }",
          "916:             else",
          "917: #endif",
          "918:             {",
          "919:                 arr = scriptContext->GetLibrary()->CreateNativeIntArrayLiteral(count);",
          "920:                 SparseArraySegment<int32> *head = SparseArraySegment<int32>::From(arr->head);",
          "921:                 Assert(count > 0 && count == head->length);",
          "922:                 CopyArray(head->elements, head->length, ints->elements, count);",
          "923:             }",
          "925:             arr->SetArrayProfileInfo(weakFuncRef, arrayInfo);",
          "927:             return arr;",
          "928:         }",
          "930:         if (arrayInfo->IsNativeFloatArray())",
          "931:         {",
          "932:             JavascriptNativeFloatArray *arr = scriptContext->GetLibrary()->CreateNativeFloatArrayLiteral(count);",
          "933:             SparseArraySegment<double> *head = SparseArraySegment<double>::From(arr->head);",
          "934:             Assert(count > 0 && count == head->length);",
          "935:             for (uint i = 0; i < count; i++)",
          "936:             {",
          "937:                 head->elements[i] = (double)ints->elements[i];",
          "938:             }",
          "939:             arr->SetArrayProfileInfo(weakFuncRef, arrayInfo);",
          "941:             return arr;",
          "942:         }",
          "944:         return OP_NewScIntArray(ints, scriptContext);",
          "945:     }",
          "946: #endif",
          "948:     Var JavascriptArray::OP_NewScFltArray(AuxArray<double> *doubles, ScriptContext* scriptContext)",
          "949:     {",
          "950:         uint32 count = doubles->count;",
          "951:         JavascriptArray *arr = scriptContext->GetLibrary()->CreateArrayLiteral(count);",
          "952:         SparseArraySegment<Var> *head = SparseArraySegment<Var>::From(arr->head);",
          "953:         Assert(count > 0 && count == head->length);",
          "954:         for (uint i = 0; i < count; i++)",
          "955:         {",
          "956:             double dval = doubles->elements[i];",
          "957:             int32 ival;",
          "958:             if (JavascriptNumber::TryGetInt32Value(dval, &ival) && !TaggedInt::IsOverflow(ival))",
          "959:             {",
          "960:                 head->elements[i] = TaggedInt::ToVarUnchecked(ival);",
          "961:             }",
          "962:             else",
          "963:             {",
          "964:                 head->elements[i] = JavascriptNumber::ToVarNoCheck(dval, scriptContext);",
          "965:             }",
          "966:         }",
          "967:         return arr;",
          "968:     }",
          "970: #if ENABLE_PROFILE_INFO",
          "971:     Var JavascriptArray::ProfiledNewScFltArray(AuxArray<double> *doubles, ScriptContext* scriptContext, ArrayCallSiteInfo *arrayInfo, RecyclerWeakReference<FunctionBody> *weakFuncRef)",
          "972:     {",
          "974:         if (arrayInfo->IsNativeFloatArray())",
          "975:         {",
          "976:             arrayInfo->SetIsNotNativeIntArray();",
          "977:             uint32 count = doubles->count;",
          "978:             JavascriptNativeFloatArray *arr = scriptContext->GetLibrary()->CreateNativeFloatArrayLiteral(count);",
          "979:             SparseArraySegment<double> *head = SparseArraySegment<double>::From(arr->head);",
          "980:             Assert(count > 0 && count == head->length);",
          "981:             CopyArray(head->elements, head->length, doubles->elements, count);",
          "982:             arr->SetArrayProfileInfo(weakFuncRef, arrayInfo);",
          "984:             return arr;",
          "985:         }",
          "987:         return OP_NewScFltArray(doubles, scriptContext);",
          "988:     }",
          "990:     Var JavascriptArray::ProfiledNewInstance(RecyclableObject* function, CallInfo callInfo, ...)",
          "991:     {",
          "992:         ARGUMENTS(args, callInfo);",
          "994:         Assert(JavascriptFunction::Is(function) &&",
          "995:                JavascriptFunction::FromVar(function)->GetFunctionInfo() == &JavascriptArray::EntryInfo::NewInstance);",
          "996:         Assert(callInfo.Count >= 2);",
          "998:         ArrayCallSiteInfo *arrayInfo = (ArrayCallSiteInfo*)args[0];",
          "999:         JavascriptArray* pNew = nullptr;",
          "1001:         if (callInfo.Count == 2)",
          "1002:         {",
          "1004:             Var firstArgument = args[1];",
          "1005:             int elementCount;",
          "1006:             if (TaggedInt::Is(firstArgument))",
          "1007:             {",
          "1008:                 elementCount = TaggedInt::ToInt32(firstArgument);",
          "1009:                 if (elementCount < 0)",
          "1010:                 {",
          "1011:                     JavascriptError::ThrowRangeError(function->GetScriptContext(), JSERR_ArrayLengthConstructIncorrect);",
          "1012:                 }",
          "1013:                 if (arrayInfo && arrayInfo->IsNativeArray())",
          "1014:                 {",
          "1015:                     if (arrayInfo->IsNativeIntArray())",
          "1016:                     {",
          "1017:                         pNew = function->GetLibrary()->CreateNativeIntArray(elementCount);",
          "1018:                     }",
          "1019:                     else",
          "1020:                     {",
          "1021:                         pNew = function->GetLibrary()->CreateNativeFloatArray(elementCount);",
          "1022:                     }",
          "1023:                 }",
          "1024:                 else",
          "1025:                 {",
          "1026:                     pNew = function->GetLibrary()->CreateArray(elementCount);",
          "1027:                 }",
          "1028:             }",
          "1029:             else if (JavascriptNumber::Is_NoTaggedIntCheck(firstArgument))",
          "1030:             {",
          "1032:                 double value = JavascriptNumber::GetValue(firstArgument);",
          "1033:                 uint32 uvalue = JavascriptConversion::ToUInt32(value);",
          "1034:                 if (value != uvalue)",
          "1035:                 {",
          "1036:                     JavascriptError::ThrowRangeError(function->GetScriptContext(), JSERR_ArrayLengthConstructIncorrect);",
          "1037:                 }",
          "1038:                 if (arrayInfo && arrayInfo->IsNativeArray())",
          "1039:                 {",
          "1040:                     if (arrayInfo->IsNativeIntArray())",
          "1041:                     {",
          "1042:                         pNew = function->GetLibrary()->CreateNativeIntArray(uvalue);",
          "1043:                     }",
          "1044:                     else",
          "1045:                     {",
          "1046:                         pNew = function->GetLibrary()->CreateNativeFloatArray(uvalue);",
          "1047:                     }",
          "1048:                 }",
          "1049:                 else",
          "1050:                 {",
          "1051:                     pNew = function->GetLibrary()->CreateArray(uvalue);",
          "1052:                 }",
          "1053:             }",
          "1054:             else",
          "1055:             {",
          "1062:                 pNew = function->GetLibrary()->CreateArray(1);",
          "1063:                 pNew->DirectSetItemAt<Var>(0, firstArgument);",
          "1064:             }",
          "1065:         }",
          "1066:         else",
          "1067:         {",
          "1071:             if (arrayInfo && arrayInfo->IsNativeArray())",
          "1072:             {",
          "1073:                 if (arrayInfo->IsNativeIntArray())",
          "1074:                 {",
          "1075:                     pNew = function->GetLibrary()->CreateNativeIntArray(callInfo.Count - 1);",
          "1076:                 }",
          "1077:                 else",
          "1078:                 {",
          "1079:                     pNew = function->GetLibrary()->CreateNativeFloatArray(callInfo.Count - 1);",
          "1080:                 }",
          "1081:             }",
          "1082:             else",
          "1083:             {",
          "1084:                 pNew = function->GetLibrary()->CreateArray(callInfo.Count - 1);",
          "1085:             }",
          "1086:             pNew->FillFromArgs(callInfo.Count - 1, 0, args.Values, arrayInfo);",
          "1087:         }",
          "1089: #ifdef VALIDATE_ARRAY",
          "1090:         pNew->ValidateArray();",
          "1091: #endif",
          "1092:         return pNew;",
          "1093:     }",
          "1094: #endif",
          "1096:     Var JavascriptArray::NewInstance(RecyclableObject* function, CallInfo callInfo, ...)",
          "1097:     {",
          "1098:         ARGUMENTS(args, callInfo);",
          "1099:         return NewInstance(function, args);",
          "1100:     }",
          "1102:     Var JavascriptArray::NewInstance(RecyclableObject* function, Arguments args)",
          "1103:     {",
          "1105:         PROBE_STACK(function->GetScriptContext(), Js::Constants::MinStackDefault);",
          "1109:         const CallInfo &callInfo = args.Info;",
          "1110:         Var newTarget = callInfo.Flags & CallFlags_NewTarget ? args.Values[args.Info.Count] : args[0];",
          "1111:         bool isCtorSuperCall = (callInfo.Flags & CallFlags_New) && newTarget != nullptr && !JavascriptOperators::IsUndefined(newTarget);",
          "1112:         Assert( isCtorSuperCall || !(callInfo.Flags & CallFlags_New) || args[0] == nullptr",
          "1113:             || JavascriptOperators::GetTypeId(args[0]) == TypeIds_HostDispatch);",
          "1115:         ScriptContext* scriptContext = function->GetScriptContext();",
          "1116:         JavascriptArray* pNew = nullptr;",
          "1118:         if (callInfo.Count < 2)",
          "1119:         {",
          "1121:             pNew = CreateArrayFromConstructorNoArg(function, scriptContext);",
          "1123:             return isCtorSuperCall ?",
          "1124:                 JavascriptOperators::OrdinaryCreateFromConstructor(RecyclableObject::FromVar(newTarget), pNew, nullptr, scriptContext) :",
          "1125:                 pNew;",
          "1126:         }",
          "1128:         if (callInfo.Count == 2)",
          "1129:         {",
          "1131:             Var firstArgument = args[1];",
          "1132:             int elementCount;",
          "1134:             if (TaggedInt::Is(firstArgument))",
          "1135:             {",
          "1136:                 elementCount = TaggedInt::ToInt32(firstArgument);",
          "1137:                 if (elementCount < 0)",
          "1138:                 {",
          "1139:                     JavascriptError::ThrowRangeError(scriptContext, JSERR_ArrayLengthConstructIncorrect);",
          "1140:                 }",
          "1142:                 pNew = CreateArrayFromConstructor(function, elementCount, scriptContext);",
          "1143:             }",
          "1144:             else if (JavascriptNumber::Is_NoTaggedIntCheck(firstArgument))",
          "1145:             {",
          "1147:                 double value = JavascriptNumber::GetValue(firstArgument);",
          "1148:                 uint32 uvalue = JavascriptConversion::ToUInt32(value);",
          "1149:                 if (value != uvalue)",
          "1150:                 {",
          "1151:                     JavascriptError::ThrowRangeError(scriptContext, JSERR_ArrayLengthConstructIncorrect);",
          "1152:                 }",
          "1154:                 pNew = CreateArrayFromConstructor(function, uvalue, scriptContext);",
          "1155:             }",
          "1156:             else",
          "1157:             {",
          "1164:                 pNew = CreateArrayFromConstructor(function, 1, scriptContext);",
          "1166:                 JavascriptOperators::SetItem(pNew, pNew, 0u, firstArgument, scriptContext, PropertyOperation_ThrowIfNotExtensible);",
          "1173:                 pNew->SetLength(1);",
          "1174:             }",
          "1175:         }",
          "1176:         else",
          "1177:         {",
          "1180:             pNew = CreateArrayFromConstructor(function, callInfo.Count - 1, scriptContext);",
          "1181:             pNew->JavascriptArray::FillFromArgs(callInfo.Count - 1, 0, args.Values);",
          "1182:         }",
          "1184: #ifdef VALIDATE_ARRAY",
          "1185:         pNew->ValidateArray();",
          "1186: #endif",
          "1187:         return isCtorSuperCall ?",
          "1188:             JavascriptOperators::OrdinaryCreateFromConstructor(RecyclableObject::FromVar(newTarget), pNew, nullptr, scriptContext) :",
          "1189:             pNew;",
          "1190:     }",
          "1192:     JavascriptArray* JavascriptArray::CreateArrayFromConstructor(RecyclableObject* constructor, uint32 length, ScriptContext* scriptContext)",
          "1193:     {",
          "1194:         JavascriptLibrary* library = constructor->GetLibrary();",
          "1200:         return library->CreateArray(length);",
          "1201:     }",
          "1203:     JavascriptArray* JavascriptArray::CreateArrayFromConstructorNoArg(RecyclableObject* constructor, ScriptContext* scriptContext)",
          "1204:     {",
          "1205:         JavascriptLibrary* library = constructor->GetLibrary();",
          "1206:         return library->CreateArray();",
          "1207:     }",
          "1209: #if ENABLE_PROFILE_INFO",
          "1210:     Var JavascriptArray::ProfiledNewInstanceNoArg(RecyclableObject *function, ScriptContext *scriptContext, ArrayCallSiteInfo *arrayInfo, RecyclerWeakReference<FunctionBody> *weakFuncRef)",
          "1211:     {",
          "1212:         Assert(JavascriptFunction::Is(function) &&",
          "1213:                JavascriptFunction::FromVar(function)->GetFunctionInfo() == &JavascriptArray::EntryInfo::NewInstance);",
          "1215:         if (arrayInfo->IsNativeIntArray())",
          "1216:         {",
          "1217:             JavascriptNativeIntArray *arr = scriptContext->GetLibrary()->CreateNativeIntArray();",
          "1218:             arr->SetArrayProfileInfo(weakFuncRef, arrayInfo);",
          "1219:             return arr;",
          "1220:         }",
          "1222:         if (arrayInfo->IsNativeFloatArray())",
          "1223:         {",
          "1224:             JavascriptNativeFloatArray *arr = scriptContext->GetLibrary()->CreateNativeFloatArray();",
          "1225:             arr->SetArrayProfileInfo(weakFuncRef, arrayInfo);",
          "1226:             return arr;",
          "1227:         }",
          "1229:         return scriptContext->GetLibrary()->CreateArray();",
          "1230:     }",
          "1231: #endif",
          "1233:     Var JavascriptNativeIntArray::NewInstance(RecyclableObject* function, CallInfo callInfo, ...)",
          "1234:     {",
          "1235:         ARGUMENTS(args, callInfo);",
          "1236:         return NewInstance(function, args);",
          "1237:     }",
          "1239:     Var JavascriptNativeIntArray::NewInstance(RecyclableObject* function, Arguments args)",
          "1240:     {",
          "1241:         Assert(!PHASE_OFF1(NativeArrayPhase));",
          "1243:         PROBE_STACK(function->GetScriptContext(), Js::Constants::MinStackDefault);",
          "1245:         const CallInfo &callInfo = args.Info;",
          "1246:         if (callInfo.Count < 2)",
          "1247:         {",
          "1249:             return function->GetLibrary()->CreateNativeIntArray();",
          "1250:         }",
          "1252:         JavascriptArray* pNew = nullptr;",
          "1253:         if (callInfo.Count == 2)",
          "1254:         {",
          "1256:             Var firstArgument = args[1];",
          "1257:             int elementCount;",
          "1258:             if (TaggedInt::Is(firstArgument))",
          "1259:             {",
          "1260:                 elementCount = TaggedInt::ToInt32(firstArgument);",
          "1261:                 if (elementCount < 0)",
          "1262:                 {",
          "1263:                     JavascriptError::ThrowRangeError(",
          "1264:                         function->GetScriptContext(), JSERR_ArrayLengthConstructIncorrect);",
          "1265:                 }",
          "1266:                 pNew = function->GetLibrary()->CreateNativeIntArray(elementCount);",
          "1267:             }",
          "1268:             else if (JavascriptNumber::Is_NoTaggedIntCheck(firstArgument))",
          "1269:             {",
          "1271:                 double value = JavascriptNumber::GetValue(firstArgument);",
          "1272:                 uint32 uvalue = JavascriptConversion::ToUInt32(value);",
          "1273:                 if (value != uvalue)",
          "1274:                 {",
          "1275:                     JavascriptError::ThrowRangeError(",
          "1276:                         function->GetScriptContext(), JSERR_ArrayLengthConstructIncorrect);",
          "1277:                 }",
          "1278:                 pNew = function->GetLibrary()->CreateNativeIntArray(uvalue);",
          "1279:             }",
          "1280:             else",
          "1281:             {",
          "1288:                 pNew = function->GetLibrary()->CreateArray(1);",
          "1289:                 pNew->DirectSetItemAt<Var>(0, firstArgument);",
          "1290:             }",
          "1291:         }",
          "1292:         else",
          "1293:         {",
          "1297:             JavascriptNativeIntArray *arr = function->GetLibrary()->CreateNativeIntArray(callInfo.Count - 1);",
          "1298:             pNew = arr->FillFromArgs(callInfo.Count - 1, 0, args.Values);",
          "1299:         }",
          "1301: #ifdef VALIDATE_ARRAY",
          "1302:         pNew->ValidateArray();",
          "1303: #endif",
          "1305:         return pNew;",
          "1306:     }",
          "1308:     Var JavascriptNativeFloatArray::NewInstance(RecyclableObject* function, CallInfo callInfo, ...)",
          "1309:     {",
          "1310:         ARGUMENTS(args, callInfo);",
          "1311:         return NewInstance(function, args);",
          "1312:     }",
          "1314:     Var JavascriptNativeFloatArray::NewInstance(RecyclableObject* function, Arguments args)",
          "1315:     {",
          "1316:         Assert(!PHASE_OFF1(NativeArrayPhase));",
          "1318:         PROBE_STACK(function->GetScriptContext(), Js::Constants::MinStackDefault);",
          "1320:         const CallInfo &callInfo = args.Info;",
          "1321:         if (callInfo.Count < 2)",
          "1322:         {",
          "1324:             return function->GetLibrary()->CreateNativeFloatArray();",
          "1325:         }",
          "1327:         JavascriptArray* pNew = nullptr;",
          "1328:         if (callInfo.Count == 2)",
          "1329:         {",
          "1331:             Var firstArgument = args[1];",
          "1332:             int elementCount;",
          "1333:             if (TaggedInt::Is(firstArgument))",
          "1334:             {",
          "1335:                 elementCount = TaggedInt::ToInt32(firstArgument);",
          "1336:                 if (elementCount < 0)",
          "1337:                 {",
          "1338:                     JavascriptError::ThrowRangeError(",
          "1339:                         function->GetScriptContext(), JSERR_ArrayLengthConstructIncorrect);",
          "1340:                 }",
          "1341:                 pNew = function->GetLibrary()->CreateNativeFloatArray(elementCount);",
          "1342:             }",
          "1343:             else if (JavascriptNumber::Is_NoTaggedIntCheck(firstArgument))",
          "1344:             {",
          "1346:                 double value = JavascriptNumber::GetValue(firstArgument);",
          "1347:                 uint32 uvalue = JavascriptConversion::ToUInt32(value);",
          "1348:                 if (value != uvalue)",
          "1349:                 {",
          "1350:                     JavascriptError::ThrowRangeError(",
          "1351:                         function->GetScriptContext(), JSERR_ArrayLengthConstructIncorrect);",
          "1352:                 }",
          "1353:                 pNew = function->GetLibrary()->CreateNativeFloatArray(uvalue);",
          "1354:             }",
          "1355:             else",
          "1356:             {",
          "1363:                 pNew = function->GetLibrary()->CreateArray(1);",
          "1364:                 pNew->DirectSetItemAt<Var>(0, firstArgument);",
          "1365:             }",
          "1366:         }",
          "1367:         else",
          "1368:         {",
          "1372:             JavascriptNativeFloatArray *arr = function->GetLibrary()->CreateNativeFloatArray(callInfo.Count - 1);",
          "1373:             pNew = arr->FillFromArgs(callInfo.Count - 1, 0, args.Values);",
          "1374:         }",
          "1376: #ifdef VALIDATE_ARRAY",
          "1377:         pNew->ValidateArray();",
          "1378: #endif",
          "1380:         return pNew;",
          "1381:     }",
          "1384: #if ENABLE_PROFILE_INFO",
          "1385:     JavascriptArray * JavascriptNativeIntArray::FillFromArgs(uint length, uint start, Var *args, ArrayCallSiteInfo *arrayInfo, bool dontCreateNewArray)",
          "1386: #else",
          "1387:     JavascriptArray * JavascriptNativeIntArray::FillFromArgs(uint length, uint start, Var *args, bool dontCreateNewArray)",
          "1388: #endif",
          "1389:     {",
          "1390:         uint i;",
          "1391:         for (i = start; i < length; i++)",
          "1392:         {",
          "1393:             Var item = args[i + 1];",
          "1395:             bool isTaggedInt = TaggedInt::Is(item);",
          "1396:             bool isTaggedIntMissingValue = false;",
          "1397: #ifdef _M_AMD64",
          "1398:             if (isTaggedInt)",
          "1399:             {",
          "1400:                 int32 iValue = TaggedInt::ToInt32(item);",
          "1401:                 isTaggedIntMissingValue = Js::SparseArraySegment<int32>::IsMissingItem(&iValue);",
          "1402:             }",
          "1403: #endif",
          "1404:             if (isTaggedInt && !isTaggedIntMissingValue)",
          "1405:             {",
          "1407:                 this->DirectSetItemAt(i, TaggedInt::ToInt32(item));",
          "1408:             }",
          "1409:             else if (!isTaggedIntMissingValue && JavascriptNumber::Is_NoTaggedIntCheck(item))",
          "1410:             {",
          "1411:                 double dvalue = JavascriptNumber::GetValue(item);",
          "1412:                 int32 ivalue;",
          "1413:                 if (JavascriptNumber::TryGetInt32Value(dvalue, &ivalue) && !Js::SparseArraySegment<int32>::IsMissingItem(&ivalue))",
          "1414:                 {",
          "1415:                     this->DirectSetItemAt(i, ivalue);",
          "1416:                 }",
          "1417:                 else",
          "1418:                 {",
          "1419: #if ENABLE_PROFILE_INFO",
          "1420:                     if (arrayInfo)",
          "1421:                     {",
          "1422:                         arrayInfo->SetIsNotNativeIntArray();",
          "1423:                     }",
          "1424: #endif",
          "1426:                     if (HasInlineHeadSegment(length) && i < this->head->length && !dontCreateNewArray)",
          "1427:                     {",
          "1430:                         JavascriptNativeFloatArray *fArr =",
          "1431:                             this->GetScriptContext()->GetLibrary()->CreateNativeFloatArrayLiteral(length);",
          "1432:                         return fArr->JavascriptNativeFloatArray::FillFromArgs(length, 0, args);",
          "1433:                     }",
          "1435:                     JavascriptNativeFloatArray *fArr = JavascriptNativeIntArray::ToNativeFloatArray(this);",
          "1436:                     fArr->DirectSetItemAt(i, dvalue);",
          "1437: #if ENABLE_PROFILE_INFO",
          "1438:                     return fArr->JavascriptNativeFloatArray::FillFromArgs(length, i + 1, args, arrayInfo, dontCreateNewArray);",
          "1439: #else",
          "1440:                     return fArr->JavascriptNativeFloatArray::FillFromArgs(length, i + 1, args, dontCreateNewArray);",
          "1441: #endif",
          "1442:                 }",
          "1443:             }",
          "1444:             else",
          "1445:             {",
          "1446: #if ENABLE_PROFILE_INFO",
          "1447:                 if (arrayInfo)",
          "1448:                 {",
          "1449:                     arrayInfo->SetIsNotNativeArray();",
          "1450:                 }",
          "1451: #endif",
          "1453:                 #pragma prefast(suppress:6237, \"The right hand side condition does not have any side effects.\")",
          "1454:                 if (sizeof(int32) < sizeof(Var) && HasInlineHeadSegment(length) && i < this->head->length && !dontCreateNewArray)",
          "1455:                 {",
          "1458:                     JavascriptArray *arr = this->GetScriptContext()->GetLibrary()->CreateArrayLiteral(length);",
          "1459:                     return arr->JavascriptArray::FillFromArgs(length, 0, args);",
          "1460:                 }",
          "1462:                 JavascriptArray *arr = JavascriptNativeIntArray::ToVarArray(this);",
          "1463: #if ENABLE_PROFILE_INFO",
          "1464:                 return arr->JavascriptArray::FillFromArgs(length, i, args, nullptr, dontCreateNewArray);",
          "1465: #else",
          "1466:                 return arr->JavascriptArray::FillFromArgs(length, i, args, dontCreateNewArray);",
          "1467: #endif",
          "1468:             }",
          "1469:         }",
          "1471:         return this;",
          "1472:     }",
          "1474: #if ENABLE_PROFILE_INFO",
          "1475:     JavascriptArray * JavascriptNativeFloatArray::FillFromArgs(uint length, uint start, Var *args, ArrayCallSiteInfo *arrayInfo, bool dontCreateNewArray)",
          "1476: #else",
          "1477:     JavascriptArray * JavascriptNativeFloatArray::FillFromArgs(uint length, uint start, Var *args, bool dontCreateNewArray)",
          "1478: #endif",
          "1479:     {",
          "1480:         uint i;",
          "1481:         for (i = start; i < length; i++)",
          "1482:         {",
          "1483:             Var item = args[i + 1];",
          "1484:             if (TaggedInt::Is(item))",
          "1485:             {",
          "1486:                 this->DirectSetItemAt(i, TaggedInt::ToDouble(item));",
          "1487:             }",
          "1488:             else if (JavascriptNumber::Is_NoTaggedIntCheck(item))",
          "1489:             {",
          "1490:                 this->DirectSetItemAt(i, JavascriptNumber::GetValue(item));",
          "1491:             }",
          "1492:             else",
          "1493:             {",
          "1494:                 JavascriptArray *arr = JavascriptNativeFloatArray::ToVarArray(this);",
          "1495: #if ENABLE_PROFILE_INFO",
          "1496:                 if (arrayInfo)",
          "1497:                 {",
          "1498:                     arrayInfo->SetIsNotNativeArray();",
          "1499:                 }",
          "1500:                 return arr->JavascriptArray::FillFromArgs(length, i, args, nullptr, dontCreateNewArray);",
          "1501: #else",
          "1502:                 return arr->JavascriptArray::FillFromArgs(length, i, args, dontCreateNewArray);",
          "1503: #endif",
          "1504:             }",
          "1505:         }",
          "1507:         return this;",
          "1508:     }",
          "1510: #if ENABLE_PROFILE_INFO",
          "1511:     JavascriptArray * JavascriptArray::FillFromArgs(uint length, uint start, Var *args, ArrayCallSiteInfo *arrayInfo, bool dontCreateNewArray)",
          "1512: #else",
          "1513:     JavascriptArray * JavascriptArray::FillFromArgs(uint length, uint start, Var *args, bool dontCreateNewArray)",
          "1514: #endif",
          "1515:     {",
          "1516:         uint32 i;",
          "1517:         for (i = start; i < length; i++)",
          "1518:         {",
          "1519:             Var item = args[i + 1];",
          "1520:             this->DirectSetItemAt(i, item);",
          "1521:         }",
          "1523:         return this;",
          "1524:     }",
          "1526:     DynamicType * JavascriptNativeIntArray::GetInitialType(ScriptContext * scriptContext)",
          "1527:     {",
          "1528:         return scriptContext->GetLibrary()->GetNativeIntArrayType();",
          "1529:     }",
          "1531: #if ENABLE_COPYONACCESS_ARRAY",
          "1532:     DynamicType * JavascriptCopyOnAccessNativeIntArray::GetInitialType(ScriptContext * scriptContext)",
          "1533:     {",
          "1534:         return scriptContext->GetLibrary()->GetCopyOnAccessNativeIntArrayType();",
          "1535:     }",
          "1536: #endif",
          "1538:     JavascriptNativeFloatArray *JavascriptNativeIntArray::ToNativeFloatArray(JavascriptNativeIntArray *intArray)",
          "1539:     {",
          "1540: #if ENABLE_PROFILE_INFO",
          "1541:         ArrayCallSiteInfo *arrayInfo = intArray->GetArrayCallSiteInfo();",
          "1542:         if (arrayInfo)",
          "1543:         {",
          "1544: #if DBG",
          "1545:             Js::JavascriptStackWalker walker(intArray->GetScriptContext());",
          "1546:             Js::JavascriptFunction* caller = NULL;",
          "1547:             bool foundScriptCaller = false;",
          "1548:             while(walker.GetCaller(&caller))",
          "1549:             {",
          "1550:                 if(caller != NULL && Js::ScriptFunction::Is(caller))",
          "1551:                 {",
          "1552:                     foundScriptCaller = true;",
          "1553:                     break;",
          "1554:                 }",
          "1555:             }",
          "1557:             if(foundScriptCaller)",
          "1558:             {",
          "1559:                 Assert(caller);",
          "1560:                 Assert(caller->GetFunctionBody());",
          "1561:                 if(PHASE_TRACE(Js::NativeArrayConversionPhase, caller->GetFunctionBody()))",
          "1562:                 {",
          "1563:                     Output::Print(_u(\"Conversion: Int array to Float array    ArrayCreationFunctionNumber:%2d    CallSiteNumber:%2d \\n\"), arrayInfo->functionNumber, arrayInfo->callSiteNumber);",
          "1564:                     Output::Flush();",
          "1565:                 }",
          "1566:             }",
          "1567:             else",
          "1568:             {",
          "1569:                 if(PHASE_TRACE1(Js::NativeArrayConversionPhase))",
          "1570:                 {",
          "1571:                     Output::Print(_u(\"Conversion: Int array to Float array across ScriptContexts\"));",
          "1572:                     Output::Flush();",
          "1573:                 }",
          "1574:             }",
          "1575: #else",
          "1576:             if(PHASE_TRACE1(Js::NativeArrayConversionPhase))",
          "1577:             {",
          "1578:                 Output::Print(_u(\"Conversion: Int array to Float array\"));",
          "1579:                 Output::Flush();",
          "1580:             }",
          "1581: #endif",
          "1583:             arrayInfo->SetIsNotNativeIntArray();",
          "1584:         }",
          "1585: #endif",
          "1589:         ScriptContext *scriptContext = intArray->GetScriptContext();",
          "1590:         Recycler *recycler = scriptContext->GetRecycler();",
          "1591:         SparseArraySegmentBase *seg, *nextSeg, *prevSeg = nullptr;",
          "1592:         for (seg = intArray->head; seg; seg = nextSeg)",
          "1593:         {",
          "1594:             nextSeg = seg->next;",
          "1595:             uint32 size = seg->size;",
          "1596:             if (size == 0)",
          "1597:             {",
          "1598:                 continue;",
          "1599:             }",
          "1601:             uint32 left = seg->left;",
          "1602:             uint32 length = seg->length;",
          "1603:             int i;",
          "1604:             int32 ival;",
          "1607:             seg->size >>= 1;",
          "1608:             if (seg == intArray->head || seg->length > (seg->size >>= 1))",
          "1609:             {",
          "1611:                 SparseArraySegment<double> *newSeg =",
          "1612:                     SparseArraySegment<double>::AllocateSegment(recycler, left, length, nextSeg);",
          "1613:                 Assert(newSeg != nullptr);",
          "1614:                 Assert((prevSeg == nullptr) == (seg == intArray->head));",
          "1615:                 newSeg->next = nextSeg;",
          "1616:                 intArray->LinkSegments((SparseArraySegment<double>*)prevSeg, newSeg);",
          "1617:                 if (intArray->GetLastUsedSegment() == seg)",
          "1618:                 {",
          "1619:                     intArray->SetLastUsedSegment(newSeg);",
          "1620:                 }",
          "1621:                 prevSeg = newSeg;",
          "1622:                 SegmentBTree * segmentMap = intArray->GetSegmentMap();",
          "1623:                 if (segmentMap)",
          "1624:                 {",
          "1625:                     segmentMap->SwapSegment(left, seg, newSeg);",
          "1626:                 }",
          "1629:                 for (i = 0; (uint)i < newSeg->length; i++)",
          "1630:                 {",
          "1631:                     ival = ((SparseArraySegment<int32>*)seg)->elements[i /*+ seg->length*/];",
          "1632:                     if (ival == JavascriptNativeIntArray::MissingItem)",
          "1633:                     {",
          "1634:                         continue;",
          "1635:                     }",
          "1636:                     newSeg->elements[i] = (double)ival;",
          "1637:                 }",
          "1638:             }",
          "1639:             else",
          "1640:             {",
          "1642:                 for (i = seg->length - 1; i >= 0; i--)",
          "1643:                 {",
          "1644:                     ival = ((SparseArraySegment<int32>*)seg)->elements[i];",
          "1645:                     if (ival == JavascriptNativeIntArray::MissingItem)",
          "1646:                     {",
          "1647:                         ((SparseArraySegment<double>*)seg)->elements[i] = (double)JavascriptNativeFloatArray::MissingItem;",
          "1648:                     }",
          "1649:                     else",
          "1650:                     {",
          "1651:                         ((SparseArraySegment<double>*)seg)->elements[i] = (double)ival;",
          "1652:                     }",
          "1653:                 }",
          "1654:                 prevSeg = seg;",
          "1655:             }",
          "1656:         }",
          "1658:         if (intArray->GetType() == scriptContext->GetLibrary()->GetNativeIntArrayType())",
          "1659:         {",
          "1660:             intArray->type = scriptContext->GetLibrary()->GetNativeFloatArrayType();",
          "1661:         }",
          "1662:         else",
          "1663:         {",
          "1664:             if (intArray->GetDynamicType()->GetIsLocked())",
          "1665:             {",
          "1666:                 DynamicTypeHandler *typeHandler = intArray->GetDynamicType()->GetTypeHandler();",
          "1667:                 if (typeHandler->IsPathTypeHandler())",
          "1668:                 {",
          "1673:                     static_cast<PathTypeHandlerBase*>(typeHandler)->ResetTypeHandler(intArray);",
          "1674:                 }",
          "1675:                 else",
          "1676:                 {",
          "1677:                     intArray->ChangeType();",
          "1678:                 }",
          "1679:             }",
          "1680:             intArray->GetType()->SetTypeId(TypeIds_NativeFloatArray);",
          "1681:         }",
          "1683:         if (CrossSite::IsCrossSiteObjectTyped(intArray))",
          "1684:         {",
          "1685:             Assert(VirtualTableInfo<CrossSiteObject<JavascriptNativeIntArray>>::HasVirtualTable(intArray));",
          "1686:             VirtualTableInfo<CrossSiteObject<JavascriptNativeFloatArray>>::SetVirtualTable(intArray);",
          "1687:         }",
          "1688:         else",
          "1689:         {",
          "1690:             Assert(VirtualTableInfo<JavascriptNativeIntArray>::HasVirtualTable(intArray));",
          "1691:             VirtualTableInfo<JavascriptNativeFloatArray>::SetVirtualTable(intArray);",
          "1692:         }",
          "1694:         return (JavascriptNativeFloatArray*)intArray;",
          "1695:     }",
          "1702:     template<>",
          "1703:     void JavascriptArray::ChangeArrayTypeToNativeArray<double>(JavascriptArray * varArray, ScriptContext * scriptContext)",
          "1704:     {",
          "1705:         AssertMsg(!JavascriptNativeArray::Is(varArray), \"Ensure that the incoming Array is a Var array\");",
          "1707:         if (varArray->GetType() == scriptContext->GetLibrary()->GetArrayType())",
          "1708:         {",
          "1709:             varArray->type = scriptContext->GetLibrary()->GetNativeFloatArrayType();",
          "1710:         }",
          "1711:         else",
          "1712:         {",
          "1713:             if (varArray->GetDynamicType()->GetIsLocked())",
          "1714:             {",
          "1715:                 DynamicTypeHandler *typeHandler = varArray->GetDynamicType()->GetTypeHandler();",
          "1716:                 if (typeHandler->IsPathTypeHandler())",
          "1717:                 {",
          "1722:                     static_cast<PathTypeHandlerBase*>(typeHandler)->ResetTypeHandler(varArray);",
          "1723:                 }",
          "1724:                 else",
          "1725:                 {",
          "1726:                     varArray->ChangeType();",
          "1727:                 }",
          "1728:             }",
          "1729:             varArray->GetType()->SetTypeId(TypeIds_NativeFloatArray);",
          "1730:         }",
          "1732:         if (CrossSite::IsCrossSiteObjectTyped(varArray))",
          "1733:         {",
          "1734:             Assert(VirtualTableInfo<CrossSiteObject<JavascriptArray>>::HasVirtualTable(varArray));",
          "1735:             VirtualTableInfo<CrossSiteObject<JavascriptNativeFloatArray>>::SetVirtualTable(varArray);",
          "1736:         }",
          "1737:         else",
          "1738:         {",
          "1739:             Assert(VirtualTableInfo<JavascriptArray>::HasVirtualTable(varArray));",
          "1740:             VirtualTableInfo<JavascriptNativeFloatArray>::SetVirtualTable(varArray);",
          "1741:         }",
          "1742:     }",
          "1749:     template<>",
          "1750:     void JavascriptArray::ChangeArrayTypeToNativeArray<int32>(JavascriptArray * varArray, ScriptContext * scriptContext)",
          "1751:     {",
          "1752:         AssertMsg(!JavascriptNativeArray::Is(varArray), \"Ensure that the incoming Array is a Var array\");",
          "1754:         if (varArray->GetType() == scriptContext->GetLibrary()->GetArrayType())",
          "1755:         {",
          "1756:             varArray->type = scriptContext->GetLibrary()->GetNativeIntArrayType();",
          "1757:         }",
          "1758:         else",
          "1759:         {",
          "1760:             if (varArray->GetDynamicType()->GetIsLocked())",
          "1761:             {",
          "1762:                 DynamicTypeHandler *typeHandler = varArray->GetDynamicType()->GetTypeHandler();",
          "1763:                 if (typeHandler->IsPathTypeHandler())",
          "1764:                 {",
          "1769:                     static_cast<PathTypeHandlerBase*>(typeHandler)->ResetTypeHandler(varArray);",
          "1770:                 }",
          "1771:                 else",
          "1772:                 {",
          "1773:                     varArray->ChangeType();",
          "1774:                 }",
          "1775:             }",
          "1776:             varArray->GetType()->SetTypeId(TypeIds_NativeIntArray);",
          "1777:         }",
          "1779:         if (CrossSite::IsCrossSiteObjectTyped(varArray))",
          "1780:         {",
          "1781:             Assert(VirtualTableInfo<CrossSiteObject<JavascriptArray>>::HasVirtualTable(varArray));",
          "1782:             VirtualTableInfo<CrossSiteObject<JavascriptNativeIntArray>>::SetVirtualTable(varArray);",
          "1783:         }",
          "1784:         else",
          "1785:         {",
          "1786:             Assert(VirtualTableInfo<JavascriptArray>::HasVirtualTable(varArray));",
          "1787:             VirtualTableInfo<JavascriptNativeIntArray>::SetVirtualTable(varArray);",
          "1788:         }",
          "1789:     }",
          "1791:     template<>",
          "1792:     int32 JavascriptArray::GetNativeValue<int32>(Js::Var ival, ScriptContext * scriptContext)",
          "1793:     {",
          "1794:         return JavascriptConversion::ToInt32(ival, scriptContext);",
          "1795:     }",
          "1797:     template <>",
          "1798:     double JavascriptArray::GetNativeValue<double>(Var ival, ScriptContext * scriptContext)",
          "1799:     {",
          "1800:         return JavascriptConversion::ToNumber(ival, scriptContext);",
          "1801:     }",
          "1809:     template<typename NativeArrayType, typename T>",
          "1810:     NativeArrayType *JavascriptArray::ConvertToNativeArrayInPlace(JavascriptArray *varArray)",
          "1811:     {",
          "1812:         AssertMsg(!JavascriptNativeArray::Is(varArray), \"Ensure that the incoming Array is a Var array\");",
          "1814:         ScriptContext *scriptContext = varArray->GetScriptContext();",
          "1815:         SparseArraySegmentBase *seg, *nextSeg, *prevSeg = nullptr;",
          "1816:         for (seg = varArray->head; seg; seg = nextSeg)",
          "1817:         {",
          "1818:             nextSeg = seg->next;",
          "1819:             uint32 size = seg->size;",
          "1820:             if (size == 0)",
          "1821:             {",
          "1822:                 continue;",
          "1823:             }",
          "1825:             int i;",
          "1826:             Var ival;",
          "1828:             uint32 growFactor = sizeof(Var) / sizeof(T);",
          "1829:             AssertMsg(growFactor == 1, \"We support only in place conversion of Var array to Native Array\");",
          "1832:             for (i = seg->length - 1; i >= 0; i--)",
          "1833:             {",
          "1834:                 ival = ((SparseArraySegment<Var>*)seg)->elements[i];",
          "1835:                 if (ival == JavascriptArray::MissingItem)",
          "1836:                 {",
          "1837:                     ((SparseArraySegment<T>*)seg)->elements[i] = NativeArrayType::MissingItem;",
          "1838:                 }",
          "1839:                 else",
          "1840:                 {",
          "1841:                     ((SparseArraySegment<T>*)seg)->elements[i] = GetNativeValue<T>(ival, scriptContext);",
          "1842:                 }",
          "1843:             }",
          "1844:             prevSeg = seg;",
          "1845:         }",
          "1848:         ChangeArrayTypeToNativeArray<T>(varArray, scriptContext);",
          "1850:         return (NativeArrayType*)varArray;",
          "1851:     }",
          "1853:     JavascriptArray *JavascriptNativeIntArray::ConvertToVarArray(JavascriptNativeIntArray *intArray)",
          "1854:     {",
          "1855: #if ENABLE_COPYONACCESS_ARRAY",
          "1856:         JavascriptLibrary::CheckAndConvertCopyOnAccessNativeIntArray<Var>(intArray);",
          "1857: #endif",
          "1858:         ScriptContext *scriptContext = intArray->GetScriptContext();",
          "1859:         Recycler *recycler = scriptContext->GetRecycler();",
          "1860:         SparseArraySegmentBase *seg, *nextSeg, *prevSeg = nullptr;",
          "1861:         for (seg = intArray->head; seg; seg = nextSeg)",
          "1862:         {",
          "1863:             nextSeg = seg->next;",
          "1864:             uint32 size = seg->size;",
          "1865:             if (size == 0)",
          "1866:             {",
          "1867:                 continue;",
          "1868:             }",
          "1870:             uint32 left = seg->left;",
          "1871:             uint32 length = seg->length;",
          "1872:             int i;",
          "1873:             int32 ival;",
          "1876:             uint32 growFactor = sizeof(Var) / sizeof(int32);",
          "1877:             if ((growFactor != 1 && (seg == intArray->head || seg->length > (seg->size /= growFactor))) ||",
          "1878:                 (seg->next == nullptr && SparseArraySegmentBase::IsLeafSegment(seg, recycler)))",
          "1879:             {",
          "1882:                 SparseArraySegment<Var> *newSeg =",
          "1883:                     SparseArraySegment<Var>::AllocateSegment(recycler, left, length, nextSeg);",
          "1885:                 AnalysisAssert(newSeg);",
          "1886:                 Assert((prevSeg == nullptr) == (seg == intArray->head));",
          "1887:                 newSeg->next = nextSeg;",
          "1888:                 intArray->LinkSegments((SparseArraySegment<Var>*)prevSeg, newSeg);",
          "1889:                 if (intArray->GetLastUsedSegment() == seg)",
          "1890:                 {",
          "1891:                     intArray->SetLastUsedSegment(newSeg);",
          "1892:                 }",
          "1893:                 prevSeg = newSeg;",
          "1895:                 SegmentBTree * segmentMap = intArray->GetSegmentMap();",
          "1896:                 if (segmentMap)",
          "1897:                 {",
          "1898:                     segmentMap->SwapSegment(left, seg, newSeg);",
          "1899:                 }",
          "1902:                 for (i = 0; (uint)i < newSeg->length; i++)",
          "1903:                 {",
          "1904:                     ival = ((SparseArraySegment<int32>*)seg)->elements[i];",
          "1905:                     if (ival == JavascriptNativeIntArray::MissingItem)",
          "1906:                     {",
          "1907:                         continue;",
          "1908:                     }",
          "1909:                     newSeg->elements[i] = JavascriptNumber::ToVar(ival, scriptContext);",
          "1910:                 }",
          "1911:             }",
          "1912:             else",
          "1913:             {",
          "1916:                 for (i = seg->length - 1; i >= 0; i--)",
          "1917:                 {",
          "1918:                     ival = ((SparseArraySegment<int32>*)seg)->elements[i];",
          "1919:                     if (ival == JavascriptNativeIntArray::MissingItem)",
          "1920:                     {",
          "1921:                         ((SparseArraySegment<Var>*)seg)->elements[i] = (Var)JavascriptArray::MissingItem;",
          "1922:                     }",
          "1923:                     else",
          "1924:                     {",
          "1925:                         ((SparseArraySegment<Var>*)seg)->elements[i] = JavascriptNumber::ToVar(ival, scriptContext);",
          "1926:                     }",
          "1927:                 }",
          "1928:                 prevSeg = seg;",
          "1929:             }",
          "1930:         }",
          "1932:         if (intArray->GetType() == scriptContext->GetLibrary()->GetNativeIntArrayType())",
          "1933:         {",
          "1934:             intArray->type = scriptContext->GetLibrary()->GetArrayType();",
          "1935:         }",
          "1936:         else",
          "1937:         {",
          "1938:             if (intArray->GetDynamicType()->GetIsLocked())",
          "1939:             {",
          "1940:                 DynamicTypeHandler *typeHandler = intArray->GetDynamicType()->GetTypeHandler();",
          "1941:                 if (typeHandler->IsPathTypeHandler())",
          "1942:                 {",
          "1947:                     static_cast<PathTypeHandlerBase*>(typeHandler)->ResetTypeHandler(intArray);",
          "1948:                 }",
          "1949:                 else",
          "1950:                 {",
          "1951:                     intArray->ChangeType();",
          "1952:                 }",
          "1953:             }",
          "1954:             intArray->GetType()->SetTypeId(TypeIds_Array);",
          "1955:         }",
          "1957:         if (CrossSite::IsCrossSiteObjectTyped(intArray))",
          "1958:         {",
          "1959:             Assert(VirtualTableInfo<CrossSiteObject<JavascriptNativeIntArray>>::HasVirtualTable(intArray));",
          "1960:             VirtualTableInfo<CrossSiteObject<JavascriptArray>>::SetVirtualTable(intArray);",
          "1961:         }",
          "1962:         else",
          "1963:         {",
          "1964:             Assert(VirtualTableInfo<JavascriptNativeIntArray>::HasVirtualTable(intArray));",
          "1965:             VirtualTableInfo<JavascriptArray>::SetVirtualTable(intArray);",
          "1966:         }",
          "1968:         return intArray;",
          "1969:     }",
          "1970:     JavascriptArray *JavascriptNativeIntArray::ToVarArray(JavascriptNativeIntArray *intArray)",
          "1971:     {",
          "1972: #if ENABLE_PROFILE_INFO",
          "1973:         ArrayCallSiteInfo *arrayInfo = intArray->GetArrayCallSiteInfo();",
          "1974:         if (arrayInfo)",
          "1975:         {",
          "1976: #if DBG",
          "1977:             Js::JavascriptStackWalker walker(intArray->GetScriptContext());",
          "1978:             Js::JavascriptFunction* caller = NULL;",
          "1979:             bool foundScriptCaller = false;",
          "1980:             while(walker.GetCaller(&caller))",
          "1981:             {",
          "1982:                 if(caller != NULL && Js::ScriptFunction::Is(caller))",
          "1983:                 {",
          "1984:                     foundScriptCaller = true;",
          "1985:                     break;",
          "1986:                 }",
          "1987:             }",
          "1989:             if(foundScriptCaller)",
          "1990:             {",
          "1991:                 Assert(caller);",
          "1992:                 Assert(caller->GetFunctionBody());",
          "1993:                 if(PHASE_TRACE(Js::NativeArrayConversionPhase, caller->GetFunctionBody()))",
          "1994:                 {",
          "1995:                     Output::Print(_u(\"Conversion: Int array to Var array    ArrayCreationFunctionNumber:%2d    CallSiteNumber:%2d \\n\"), arrayInfo->functionNumber, arrayInfo->callSiteNumber);",
          "1996:                     Output::Flush();",
          "1997:                 }",
          "1998:             }",
          "1999:             else",
          "2000:             {",
          "2001:                 if(PHASE_TRACE1(Js::NativeArrayConversionPhase))",
          "2002:                 {",
          "2003:                     Output::Print(_u(\"Conversion: Int array to Var array across ScriptContexts\"));",
          "2004:                     Output::Flush();",
          "2005:                 }",
          "2006:             }",
          "2007: #else",
          "2008:             if(PHASE_TRACE1(Js::NativeArrayConversionPhase))",
          "2009:             {",
          "2010:                 Output::Print(_u(\"Conversion: Int array to Var array\"));",
          "2011:                 Output::Flush();",
          "2012:             }",
          "2013: #endif",
          "2015:             arrayInfo->SetIsNotNativeArray();",
          "2016:         }",
          "2017: #endif",
          "2019:         intArray->ClearArrayCallSiteIndex();",
          "2021:         return ConvertToVarArray(intArray);",
          "2022:     }",
          "2024:     DynamicType * JavascriptNativeFloatArray::GetInitialType(ScriptContext * scriptContext)",
          "2025:     {",
          "2026:         return scriptContext->GetLibrary()->GetNativeFloatArrayType();",
          "2027:     }",
          "2034:     JavascriptArray *JavascriptNativeFloatArray::ConvertToVarArray(JavascriptNativeFloatArray *fArray)",
          "2035:     {",
          "2037:         Assert(sizeof(double) >= sizeof(Var));",
          "2039:         uint32 shrinkFactor = sizeof(double) / sizeof(Var);",
          "2040:         ScriptContext *scriptContext = fArray->GetScriptContext();",
          "2041:         Recycler *recycler = scriptContext->GetRecycler();",
          "2042:         SparseArraySegmentBase *seg, *nextSeg, *prevSeg = nullptr;",
          "2043:         for (seg = fArray->head; seg; seg = nextSeg)",
          "2044:         {",
          "2045:             nextSeg = seg->next;",
          "2046:             if (seg->size == 0)",
          "2047:             {",
          "2048:                 continue;",
          "2049:             }",
          "2050:             uint32 left = seg->left;",
          "2051:             uint32 length = seg->length;",
          "2052:             SparseArraySegment<Var> *newSeg;",
          "2053:             if (seg->next == nullptr && SparseArraySegmentBase::IsLeafSegment(seg, recycler))",
          "2054:             {",
          "2056:                 newSeg =",
          "2057:                     SparseArraySegment<Var>::AllocateSegment(recycler, left, length, nextSeg);",
          "2058:                 Assert((prevSeg == nullptr) == (seg == fArray->head));",
          "2059:                 newSeg->next = nextSeg;",
          "2060:                 fArray->LinkSegments((SparseArraySegment<Var>*)prevSeg, newSeg);",
          "2061:                 if (fArray->GetLastUsedSegment() == seg)",
          "2062:                 {",
          "2063:                     fArray->SetLastUsedSegment(newSeg);",
          "2064:                 }",
          "2065:                 prevSeg = newSeg;",
          "2067:                 SegmentBTree * segmentMap = fArray->GetSegmentMap();",
          "2068:                 if (segmentMap)",
          "2069:                 {",
          "2070:                     segmentMap->SwapSegment(left, seg, newSeg);",
          "2071:                 }",
          "2072:             }",
          "2073:             else",
          "2074:             {",
          "2075:                 newSeg = (SparseArraySegment<Var>*)seg;",
          "2076:                 prevSeg = seg;",
          "2077:                 if (shrinkFactor != 1)",
          "2078:                 {",
          "2079:                     uint32 newSize = seg->size * shrinkFactor;",
          "2080:                     uint32 limit;",
          "2081:                     if (seg->next)",
          "2082:                     {",
          "2083:                         limit = seg->next->left;",
          "2084:                     }",
          "2085:                     else",
          "2086:                     {",
          "2087:                         limit = JavascriptArray::MaxArrayLength;",
          "2088:                     }",
          "2089:                     seg->size = min(newSize, limit - seg->left);",
          "2090:                 }",
          "2091:             }",
          "2092:             uint32 i;",
          "2093:             for (i = 0; i < seg->length; i++)",
          "2094:             {",
          "2095:                 if (SparseArraySegment<double>::IsMissingItem(&((SparseArraySegment<double>*)seg)->elements[i]))",
          "2096:                 {",
          "2097:                     if (seg == newSeg)",
          "2098:                     {",
          "2099:                         newSeg->elements[i] = (Var)JavascriptArray::MissingItem;",
          "2100:                     }",
          "2101:                     Assert(newSeg->elements[i] == (Var)JavascriptArray::MissingItem);",
          "2102:                 }",
          "2103:                 else if (*(uint64*)&(((SparseArraySegment<double>*)seg)->elements[i]) == 0ull)",
          "2104:                 {",
          "2105:                     newSeg->elements[i] = TaggedInt::ToVarUnchecked(0);",
          "2106:                 }",
          "2107:                 else",
          "2108:                 {",
          "2109:                     int32 ival;",
          "2110:                     double dval = ((SparseArraySegment<double>*)seg)->elements[i];",
          "2111:                     if (JavascriptNumber::TryGetInt32Value(dval, &ival) && !TaggedInt::IsOverflow(ival))",
          "2112:                     {",
          "2113:                         newSeg->elements[i] = TaggedInt::ToVarUnchecked(ival);",
          "2114:                     }",
          "2115:                     else",
          "2116:                     {",
          "2117:                         newSeg->elements[i] = JavascriptNumber::ToVarWithCheck(dval, scriptContext);",
          "2118:                     }",
          "2119:                 }",
          "2120:             }",
          "2121:             if (seg == newSeg && shrinkFactor != 1)",
          "2122:             {",
          "2124:                 newSeg->FillSegmentBuffer(i, seg->size);",
          "2125:             }",
          "2126:         }",
          "2128:         if (fArray->GetType() == scriptContext->GetLibrary()->GetNativeFloatArrayType())",
          "2129:         {",
          "2130:             fArray->type = scriptContext->GetLibrary()->GetArrayType();",
          "2131:         }",
          "2132:         else",
          "2133:         {",
          "2134:             if (fArray->GetDynamicType()->GetIsLocked())",
          "2135:             {",
          "2136:                 DynamicTypeHandler *typeHandler = fArray->GetDynamicType()->GetTypeHandler();",
          "2137:                 if (typeHandler->IsPathTypeHandler())",
          "2138:                 {",
          "2143:                     static_cast<PathTypeHandlerBase*>(typeHandler)->ResetTypeHandler(fArray);",
          "2144:                 }",
          "2145:                 else",
          "2146:                 {",
          "2147:                     fArray->ChangeType();",
          "2148:                 }",
          "2149:             }",
          "2150:             fArray->GetType()->SetTypeId(TypeIds_Array);",
          "2151:         }",
          "2153:         if (CrossSite::IsCrossSiteObjectTyped(fArray))",
          "2154:         {",
          "2155:             Assert(VirtualTableInfo<CrossSiteObject<JavascriptNativeFloatArray>>::HasVirtualTable(fArray));",
          "2156:             VirtualTableInfo<CrossSiteObject<JavascriptArray>>::SetVirtualTable(fArray);",
          "2157:         }",
          "2158:         else",
          "2159:         {",
          "2160:             Assert(VirtualTableInfo<JavascriptNativeFloatArray>::HasVirtualTable(fArray));",
          "2161:             VirtualTableInfo<JavascriptArray>::SetVirtualTable(fArray);",
          "2162:         }",
          "2164:         return fArray;",
          "2165:     }",
          "2167:     JavascriptArray *JavascriptNativeFloatArray::ToVarArray(JavascriptNativeFloatArray *fArray)",
          "2168:     {",
          "2169: #if ENABLE_PROFILE_INFO",
          "2170:         ArrayCallSiteInfo *arrayInfo = fArray->GetArrayCallSiteInfo();",
          "2171:         if (arrayInfo)",
          "2172:         {",
          "2173: #if DBG",
          "2174:             Js::JavascriptStackWalker walker(fArray->GetScriptContext());",
          "2175:             Js::JavascriptFunction* caller = NULL;",
          "2176:             bool foundScriptCaller = false;",
          "2177:             while(walker.GetCaller(&caller))",
          "2178:             {",
          "2179:                 if(caller != NULL && Js::ScriptFunction::Is(caller))",
          "2180:                 {",
          "2181:                     foundScriptCaller = true;",
          "2182:                     break;",
          "2183:                 }",
          "2184:             }",
          "2186:             if(foundScriptCaller)",
          "2187:             {",
          "2188:                 Assert(caller);",
          "2189:                 Assert(caller->GetFunctionBody());",
          "2190:                 if(PHASE_TRACE(Js::NativeArrayConversionPhase, caller->GetFunctionBody()))",
          "2191:                 {",
          "2192:                     Output::Print(_u(\"Conversion: Float array to Var array    ArrayCreationFunctionNumber:%2d    CallSiteNumber:%2d \\n\"), arrayInfo->functionNumber, arrayInfo->callSiteNumber);",
          "2193:                     Output::Flush();",
          "2194:                 }",
          "2195:             }",
          "2196:             else",
          "2197:             {",
          "2198:                 if(PHASE_TRACE1(Js::NativeArrayConversionPhase))",
          "2199:                 {",
          "2200:                     Output::Print(_u(\"Conversion: Float array to Var array across ScriptContexts\"));",
          "2201:                     Output::Flush();",
          "2202:                 }",
          "2203:             }",
          "2204: #else",
          "2205:             if(PHASE_TRACE1(Js::NativeArrayConversionPhase))",
          "2206:             {",
          "2207:                 Output::Print(_u(\"Conversion: Float array to Var array\"));",
          "2208:                 Output::Flush();",
          "2209:             }",
          "2210: #endif",
          "2212:             if(fArray->GetScriptContext()->IsScriptContextInNonDebugMode())",
          "2213:             {",
          "2214:                 Assert(!arrayInfo->IsNativeIntArray());",
          "2215:             }",
          "2217:             arrayInfo->SetIsNotNativeArray();",
          "2218:         }",
          "2219: #endif",
          "2221:         fArray->ClearArrayCallSiteIndex();",
          "2223:         return ConvertToVarArray(fArray);",
          "2225:     }",
          "2234:     int64 JavascriptArray::GetIndexFromVar(Js::Var arg, int64 length, ScriptContext* scriptContext)",
          "2235:     {",
          "2236:         int64 index;",
          "2238:         if (TaggedInt::Is(arg))",
          "2239:         {",
          "2240:             int intValue = TaggedInt::ToInt32(arg);",
          "2242:             if (intValue < 0)",
          "2243:             {",
          "2244:                 index = max<int64>(0, length + intValue);",
          "2245:             }",
          "2246:             else",
          "2247:             {",
          "2248:                 index = intValue;",
          "2249:             }",
          "2251:             if (index > length)",
          "2252:             {",
          "2253:                 index = length;",
          "2254:             }",
          "2255:         }",
          "2256:         else",
          "2257:         {",
          "2258:             double doubleValue = JavascriptConversion::ToInteger(arg, scriptContext);",
          "2261:             if (doubleValue > length)",
          "2262:             {",
          "2263:                 return length;",
          "2264:             }",
          "2266:             index = NumberUtilities::TryToInt64(doubleValue);",
          "2268:             if (index < 0)",
          "2269:             {",
          "2270:                 index = max<int64>(0, index + length);",
          "2271:             }",
          "2272:         }",
          "2274:         return index;",
          "2275:     }",
          "2277:     TypeId JavascriptArray::OP_SetNativeIntElementC(JavascriptNativeIntArray *arr, uint32 index, Var value, ScriptContext *scriptContext)",
          "2278:     {",
          "2279:         int32 iValue;",
          "2280:         double dValue;",
          "2282:         TypeId typeId = arr->TrySetNativeIntArrayItem(value, &iValue, &dValue);",
          "2283:         if (typeId == TypeIds_NativeIntArray)",
          "2284:         {",
          "2285:             arr->SetArrayLiteralItem(index, iValue);",
          "2286:         }",
          "2287:         else if (typeId == TypeIds_NativeFloatArray)",
          "2288:         {",
          "2289:             arr->SetArrayLiteralItem(index, dValue);",
          "2290:         }",
          "2291:         else",
          "2292:         {",
          "2293:             arr->SetArrayLiteralItem(index, value);",
          "2294:         }",
          "2295:         return typeId;",
          "2296:     }",
          "2298:     TypeId JavascriptArray::OP_SetNativeFloatElementC(JavascriptNativeFloatArray *arr, uint32 index, Var value, ScriptContext *scriptContext)",
          "2299:     {",
          "2300:         double dValue;",
          "2301:         TypeId typeId = arr->TrySetNativeFloatArrayItem(value, &dValue);",
          "2302:         if (typeId == TypeIds_NativeFloatArray)",
          "2303:         {",
          "2304:             arr->SetArrayLiteralItem(index, dValue);",
          "2305:         }",
          "2306:         else",
          "2307:         {",
          "2308:             arr->SetArrayLiteralItem(index, value);",
          "2309:         }",
          "2310:         return typeId;",
          "2311:     }",
          "2313:     template<typename T>",
          "2314:     void JavascriptArray::SetArrayLiteralItem(uint32 index, T value)",
          "2315:     {",
          "2316:         SparseArraySegment<T> * segment = SparseArraySegment<T>::From(this->head);",
          "2318:         Assert(segment->left == 0);",
          "2319:         Assert(index < segment->length);",
          "2321:         segment->elements[index] = value;",
          "2322:     }",
          "2324:     void JavascriptNativeIntArray::SetIsPrototype()",
          "2325:     {",
          "2327:         ToVarArray(this);",
          "2328:         __super::SetIsPrototype();",
          "2329:     }",
          "2331:     void JavascriptNativeFloatArray::SetIsPrototype()",
          "2332:     {",
          "2334:         ToVarArray(this);",
          "2335:         __super::SetIsPrototype();",
          "2336:     }",
          "2338: #if ENABLE_PROFILE_INFO",
          "2339:     ArrayCallSiteInfo *JavascriptNativeArray::GetArrayCallSiteInfo()",
          "2340:     {",
          "2341:         RecyclerWeakReference<FunctionBody> *weakRef = this->weakRefToFuncBody;",
          "2342:         if (weakRef)",
          "2343:         {",
          "2344:             FunctionBody *functionBody = weakRef->Get();",
          "2345:             if (functionBody)",
          "2346:             {",
          "2347:                 if (functionBody->HasDynamicProfileInfo())",
          "2348:                 {",
          "2349:                     Js::ProfileId profileId = this->GetArrayCallSiteIndex();",
          "2350:                     if (profileId < functionBody->GetProfiledArrayCallSiteCount())",
          "2351:                     {",
          "2352:                         return functionBody->GetAnyDynamicProfileInfo()->GetArrayCallSiteInfo(functionBody, profileId);",
          "2353:                     }",
          "2354:                 }",
          "2355:             }",
          "2356:             else",
          "2357:             {",
          "2358:                 this->ClearArrayCallSiteIndex();",
          "2359:             }",
          "2360:         }",
          "2361:         return nullptr;",
          "2362:     }",
          "2364:     void JavascriptNativeArray::SetArrayProfileInfo(RecyclerWeakReference<FunctionBody> *weakRef, ArrayCallSiteInfo *arrayInfo)",
          "2365:     {",
          "2366:         Assert(weakRef);",
          "2367:         FunctionBody *functionBody = weakRef->Get();",
          "2368:         if (functionBody && functionBody->HasDynamicProfileInfo())",
          "2369:         {",
          "2370:             ArrayCallSiteInfo *baseInfo = functionBody->GetAnyDynamicProfileInfo()->GetArrayCallSiteInfo(functionBody, 0);",
          "2371:             Js::ProfileId index = (Js::ProfileId)(arrayInfo - baseInfo);",
          "2372:             Assert(index < functionBody->GetProfiledArrayCallSiteCount());",
          "2373:             SetArrayCallSite(index, weakRef);",
          "2374:         }",
          "2375:     }",
          "2377:     void JavascriptNativeArray::CopyArrayProfileInfo(Js::JavascriptNativeArray* baseArray)",
          "2378:     {",
          "2379:         if (baseArray->weakRefToFuncBody)",
          "2380:         {",
          "2381:             if (baseArray->weakRefToFuncBody->Get())",
          "2382:             {",
          "2383:                 SetArrayCallSite(baseArray->GetArrayCallSiteIndex(), baseArray->weakRefToFuncBody);",
          "2384:             }",
          "2385:             else",
          "2386:             {",
          "2387:                 baseArray->ClearArrayCallSiteIndex();",
          "2388:             }",
          "2389:         }",
          "2390:     }",
          "2391: #endif",
          "2393:     Var JavascriptNativeArray::FindMinOrMax(Js::ScriptContext * scriptContext, bool findMax)",
          "2394:     {",
          "2395:         if (JavascriptNativeIntArray::Is(this))",
          "2396:         {",
          "2397:             return this->FindMinOrMax<int32, false>(scriptContext, findMax);",
          "2398:         }",
          "2399:         else",
          "2400:         {",
          "2401:             return this->FindMinOrMax<double, true>(scriptContext, findMax);",
          "2402:         }",
          "2403:     }",
          "2405:     template <typename T, bool checkNaNAndNegZero>",
          "2406:     Var JavascriptNativeArray::FindMinOrMax(Js::ScriptContext * scriptContext, bool findMax)",
          "2407:     {",
          "2408:         AssertMsg(this->HasNoMissingValues(), \"Fastpath is only for arrays with one segment and no missing values\");",
          "2409:         uint len = this->GetLength();",
          "2411:         Js::SparseArraySegment<T>* headSegment = ((Js::SparseArraySegment<T>*)this->GetHead());",
          "2412:         uint headSegLen = headSegment->length;",
          "2413:         Assert(headSegLen == len);",
          "2415:         if (headSegment->next == nullptr)",
          "2416:         {",
          "2417:             T currentRes = headSegment->elements[0];",
          "2418:             for (uint i = 0; i < headSegLen; i++)",
          "2419:             {",
          "2420:                 T compare = headSegment->elements[i];",
          "2421:                 if (checkNaNAndNegZero && JavascriptNumber::IsNan(double(compare)))",
          "2422:                 {",
          "2423:                     return scriptContext->GetLibrary()->GetNaN();",
          "2424:                 }",
          "2425:                 if (findMax ? currentRes < compare : currentRes > compare ||",
          "2426:                     (checkNaNAndNegZero && compare == 0 && Js::JavascriptNumber::IsNegZero(double(currentRes))))",
          "2427:                 {",
          "2428:                     currentRes = compare;",
          "2429:                 }",
          "2430:             }",
          "2431:             return Js::JavascriptNumber::ToVarNoCheck(currentRes, scriptContext);",
          "2432:         }",
          "2433:         else",
          "2434:         {",
          "2435:             AssertMsg(false, \"FindMinOrMax currently supports native arrays with only one segment\");",
          "2436:             Throw::FatalInternalError();",
          "2437:         }",
          "2438:     }",
          "2440:     SparseArraySegmentBase * JavascriptArray::GetLastUsedSegment() const",
          "2441:     {",
          "2442:         return HasSegmentMap() ?",
          "2443:             PointerValue(segmentUnion.segmentBTreeRoot->lastUsedSegment) :",
          "2444:             PointerValue(segmentUnion.lastUsedSegment);",
          "2445:     }",
          "2447:     void JavascriptArray::SetHeadAndLastUsedSegment(SparseArraySegmentBase * segment)",
          "2448:     {",
          "2450:         Assert(!HasSegmentMap());",
          "2451:         this->head = this->segmentUnion.lastUsedSegment = segment;",
          "2452:     }",
          "2454:     void JavascriptArray::SetLastUsedSegment(SparseArraySegmentBase * segment)",
          "2455:     {",
          "2456:         if (HasSegmentMap())",
          "2457:         {",
          "2458:             this->segmentUnion.segmentBTreeRoot->lastUsedSegment = segment;",
          "2459:         }",
          "2460:         else",
          "2461:         {",
          "2462:             this->segmentUnion.lastUsedSegment = segment;",
          "2463:         }",
          "2464:     }",
          "2465:     bool JavascriptArray::HasSegmentMap() const",
          "2466:     {",
          "2467:         return !!(GetFlags() & DynamicObjectFlags::HasSegmentMap);",
          "2468:     }",
          "2470:     SegmentBTreeRoot * JavascriptArray::GetSegmentMap() const",
          "2471:     {",
          "2472:         return (HasSegmentMap() ? segmentUnion.segmentBTreeRoot : nullptr);",
          "2473:     }",
          "2475:     void JavascriptArray::SetSegmentMap(SegmentBTreeRoot * segmentMap)",
          "2476:     {",
          "2477:         Assert(!HasSegmentMap());",
          "2478:         SparseArraySegmentBase * lastUsedSeg = this->segmentUnion.lastUsedSegment;",
          "2479:         SetFlags(GetFlags() | DynamicObjectFlags::HasSegmentMap);",
          "2480:         segmentUnion.segmentBTreeRoot = segmentMap;",
          "2481:         segmentMap->lastUsedSegment = lastUsedSeg;",
          "2482:     }",
          "2484:     void JavascriptArray::ClearSegmentMap()",
          "2485:     {",
          "2486:         if (HasSegmentMap())",
          "2487:         {",
          "2488:             SetFlags(GetFlags() & ~DynamicObjectFlags::HasSegmentMap);",
          "2489:             SparseArraySegmentBase * lastUsedSeg = segmentUnion.segmentBTreeRoot->lastUsedSegment;",
          "2490:             segmentUnion.segmentBTreeRoot = nullptr;",
          "2491:             segmentUnion.lastUsedSegment = lastUsedSeg;",
          "2492:         }",
          "2493:     }",
          "2495:     SegmentBTreeRoot * JavascriptArray::BuildSegmentMap()",
          "2496:     {",
          "2497:         Recycler* recycler = GetRecycler();",
          "2498:         SegmentBTreeRoot* tmpSegmentMap = AllocatorNewStruct(Recycler, recycler, SegmentBTreeRoot);",
          "2499:         ForEachSegment([recycler, tmpSegmentMap](SparseArraySegmentBase * current)",
          "2500:         {",
          "2501:             tmpSegmentMap->Add(recycler, current);",
          "2502:             return false;",
          "2503:         });",
          "2506:         SetSegmentMap(tmpSegmentMap);",
          "2507:         return tmpSegmentMap;",
          "2508:     }",
          "2510:     void JavascriptArray::TryAddToSegmentMap(Recycler* recycler, SparseArraySegmentBase* seg)",
          "2511:     {",
          "2512:         SegmentBTreeRoot * savedSegmentMap = GetSegmentMap();",
          "2513:         if (savedSegmentMap)",
          "2514:         {",
          "2520:             ClearSegmentMap();",
          "2521:             savedSegmentMap->Add(recycler, seg);",
          "2522:             SetSegmentMap(savedSegmentMap);",
          "2523:         }",
          "2524:     }",
          "2526:     void JavascriptArray::InvalidateLastUsedSegment()",
          "2527:     {",
          "2528:         this->SetLastUsedSegment(this->head);",
          "2529:     }",
          "2531:     DescriptorFlags JavascriptArray::GetSetter(PropertyId propertyId, Var *setterValue, PropertyValueInfo* info, ScriptContext* requestContext)",
          "2532:     {",
          "2533:         DescriptorFlags flags;",
          "2534:         if (GetSetterBuiltIns(propertyId, info, &flags))",
          "2535:         {",
          "2536:             return flags;",
          "2537:         }",
          "2538:         return __super::GetSetter(propertyId, setterValue, info, requestContext);",
          "2539:     }",
          "2541:     DescriptorFlags JavascriptArray::GetSetter(JavascriptString* propertyNameString, Var *setterValue, PropertyValueInfo* info, ScriptContext* requestContext)",
          "2542:     {",
          "2543:         DescriptorFlags flags;",
          "2544:         PropertyRecord const* propertyRecord;",
          "2545:         this->GetScriptContext()->FindPropertyRecord(propertyNameString, &propertyRecord);",
          "2547:         if (propertyRecord != nullptr && GetSetterBuiltIns(propertyRecord->GetPropertyId(), info, &flags))",
          "2548:         {",
          "2549:             return flags;",
          "2550:         }",
          "2552:         return __super::GetSetter(propertyNameString, setterValue, info, requestContext);",
          "2553:     }",
          "2555:     bool JavascriptArray::GetSetterBuiltIns(PropertyId propertyId, PropertyValueInfo* info, DescriptorFlags* descriptorFlags)",
          "2556:     {",
          "2557:         if (propertyId == PropertyIds::length)",
          "2558:         {",
          "2559:             PropertyValueInfo::SetNoCache(info, this);",
          "2561:             return true;",
          "2562:         }",
          "2563:         return false;",
          "2564:     }",
          "2566:     SparseArraySegmentBase * JavascriptArray::GetBeginLookupSegment(uint32 index, const bool useSegmentMap) const",
          "2567:     {",
          "2568:         SparseArraySegmentBase *seg = nullptr;",
          "2569:         SparseArraySegmentBase * lastUsedSeg = this->GetLastUsedSegment();",
          "2570:         if (lastUsedSeg != nullptr && lastUsedSeg->left <= index)",
          "2571:         {",
          "2572:             seg = lastUsedSeg;",
          "2573:             if(index - lastUsedSeg->left < lastUsedSeg->size)",
          "2574:             {",
          "2575:                 return seg;",
          "2576:             }",
          "2577:         }",
          "2579:         SegmentBTreeRoot * segmentMap = GetSegmentMap();",
          "2580:         if(!useSegmentMap || !segmentMap)",
          "2581:         {",
          "2582:             return seg ? seg : PointerValue(this->head);",
          "2583:         }",
          "2585:         if(seg)",
          "2586:         {",
          "2589:             SparseArraySegmentBase *const nextSeg = seg->next;",
          "2590:             if(nextSeg)",
          "2591:             {",
          "2592:                 if(index < nextSeg->left)",
          "2593:                 {",
          "2594:                     return seg;",
          "2595:                 }",
          "2596:                 else if(index - nextSeg->left < nextSeg->size)",
          "2597:                 {",
          "2598:                     return nextSeg;",
          "2599:                 }",
          "2600:             }",
          "2601:         }",
          "2603:         SparseArraySegmentBase *matchOrNextSeg;",
          "2604:         segmentMap->Find(index, seg, matchOrNextSeg);",
          "2605:         return seg ? seg : matchOrNextSeg;",
          "2606:     }",
          "2608:     uint32 JavascriptArray::GetNextIndex(uint32 index) const",
          "2609:     {",
          "2610:         if (JavascriptNativeIntArray::Is((Var)this))",
          "2611:         {",
          "2612:             return this->GetNextIndexHelper<int32>(index);",
          "2613:         }",
          "2614:         else if (JavascriptNativeFloatArray::Is((Var)this))",
          "2615:         {",
          "2616:             return this->GetNextIndexHelper<double>(index);",
          "2617:         }",
          "2618:         return this->GetNextIndexHelper<Var>(index);",
          "2619:     }",
          "2621:     template<typename T>",
          "2622:     uint32 JavascriptArray::GetNextIndexHelper(uint32 index) const",
          "2623:     {",
          "2624:         AssertMsg(this->head, \"array head should never be null\");",
          "2625:         uint candidateIndex;",
          "2627:         if (index == JavascriptArray::InvalidIndex)",
          "2628:         {",
          "2629:             candidateIndex = head->left;",
          "2630:         }",
          "2631:         else",
          "2632:         {",
          "2633:             candidateIndex = index + 1;",
          "2634:         }",
          "2636:         SparseArraySegment<T>* current = (SparseArraySegment<T>*)this->GetBeginLookupSegment(candidateIndex);",
          "2638:         while (current != nullptr)",
          "2639:         {",
          "2640:             if ((current->left <= candidateIndex) && ((candidateIndex - current->left) < current->length))",
          "2641:             {",
          "2642:                 for (uint i = candidateIndex - current->left; i < current->length; i++)",
          "2643:                 {",
          "2644:                     if (!SparseArraySegment<T>::IsMissingItem(&current->elements[i]))",
          "2645:                     {",
          "2646:                         return i + current->left;",
          "2647:                     }",
          "2648:                 }",
          "2649:             }",
          "2650:             current = SparseArraySegment<T>::From(current->next);",
          "2651:             if (current != NULL)",
          "2652:             {",
          "2653:                 if (candidateIndex < current->left)",
          "2654:                 {",
          "2655:                     candidateIndex = current->left;",
          "2656:                 }",
          "2657:             }",
          "2658:         }",
          "2659:         return JavascriptArray::InvalidIndex;",
          "2660:     }",
          "2664:     void JavascriptArray::SetLength(uint32 newLength)",
          "2665:     {",
          "2666:         if (newLength == length)",
          "2667:             return;",
          "2669:         if (head == EmptySegment)",
          "2670:         {",
          "2672:         }",
          "2673:         else if (newLength == 0)",
          "2674:         {",
          "2675:             this->ClearElements(head, 0);",
          "2676:             head->length = 0;",
          "2677:             head->next = nullptr;",
          "2678:             SetHasNoMissingValues();",
          "2680:             ClearSegmentMap();",
          "2681:             this->InvalidateLastUsedSegment();",
          "2682:         }",
          "2683:         else if (newLength < length)",
          "2684:         {",
          "2696:             SparseArraySegmentBase* next = GetBeginLookupSegment(newLength - 1); // head, or next.left < newLength",
          "2697:             Field(SparseArraySegmentBase*)* prev = &head;",
          "2699:             while(next != nullptr)",
          "2700:             {",
          "2701:                 if (newLength <= next->left)",
          "2702:                 {",
          "2703:                     ClearSegmentMap(); // truncate segments, null out segmentMap",
          "2705:                     break;",
          "2706:                 }",
          "2707:                 else if (newLength <= (next->left + next->length))",
          "2708:                 {",
          "2709:                     if (next->next)",
          "2710:                     {",
          "2711:                         ClearSegmentMap(); // Will truncate segments, null out segmentMap",
          "2712:                     }",
          "2714:                     uint32 newSegmentLength = newLength - next->left;",
          "2715:                     this->ClearElements(next, newSegmentLength);",
          "2716:                     next->next = nullptr;",
          "2717:                     next->length = newSegmentLength;",
          "2718:                     break;",
          "2719:                 }",
          "2720:                 else",
          "2721:                 {",
          "2722:                     prev = &next->next;",
          "2723:                     next = next->next;",
          "2724:                 }",
          "2725:             }",
          "2726:             this->InvalidateLastUsedSegment();",
          "2727:         }",
          "2728:         this->length = newLength;",
          "2730: #ifdef VALIDATE_ARRAY",
          "2731:         ValidateArray();",
          "2732: #endif",
          "2733:     }",
          "2735:     BOOL JavascriptArray::SetLength(Var newLength)",
          "2736:     {",
          "2737:         ScriptContext *scriptContext;",
          "2738:         if(TaggedInt::Is(newLength))",
          "2739:         {",
          "2740:             int32 lenValue = TaggedInt::ToInt32(newLength);",
          "2741:             if (lenValue < 0)",
          "2742:             {",
          "2743:                 scriptContext = GetScriptContext();",
          "2744:                 if (scriptContext->GetThreadContext()->RecordImplicitException())",
          "2745:                 {",
          "2746:                     JavascriptError::ThrowRangeError(scriptContext, JSERR_ArrayLengthAssignIncorrect);",
          "2747:                 }",
          "2748:             }",
          "2749:             else",
          "2750:             {",
          "2751:                 this->SetLength(lenValue);",
          "2752:             }",
          "2753:             return TRUE;",
          "2754:         }",
          "2756:         scriptContext = GetScriptContext();",
          "2757:         uint32 uintValue = JavascriptConversion::ToUInt32(newLength, scriptContext);",
          "2758:         double dblValue = JavascriptConversion::ToNumber(newLength, scriptContext);",
          "2759:         if (dblValue == uintValue)",
          "2760:         {",
          "2761:             this->SetLength(uintValue);",
          "2762:         }",
          "2763:         else",
          "2764:         {",
          "2765:             ThreadContext* threadContext = scriptContext->GetThreadContext();",
          "2766:             ImplicitCallFlags flags = threadContext->GetImplicitCallFlags();",
          "2767:             if (flags != ImplicitCall_None && threadContext->IsDisableImplicitCall())",
          "2768:             {",
          "2771:                 return TRUE;",
          "2772:             }",
          "2774:             if (threadContext->RecordImplicitException())",
          "2775:             {",
          "2776:                 JavascriptError::ThrowRangeError(scriptContext, JSERR_ArrayLengthAssignIncorrect);",
          "2777:             }",
          "2778:         }",
          "2780:         return TRUE;",
          "2781:     }",
          "2783:     void JavascriptArray::ClearElements(SparseArraySegmentBase *seg, uint32 newSegmentLength)",
          "2784:     {",
          "2785:         SparseArraySegment<Var>::ClearElements(((SparseArraySegment<Var>*)seg)->elements + newSegmentLength, seg->length - newSegmentLength);",
          "2786:     }",
          "2788:     void JavascriptNativeIntArray::ClearElements(SparseArraySegmentBase *seg, uint32 newSegmentLength)",
          "2789:     {",
          "2790:         SparseArraySegment<int32>::ClearElements(((SparseArraySegment<int32>*)seg)->elements + newSegmentLength, seg->length - newSegmentLength);",
          "2791:     }",
          "2793:     void JavascriptNativeFloatArray::ClearElements(SparseArraySegmentBase *seg, uint32 newSegmentLength)",
          "2794:     {",
          "2795:         SparseArraySegment<double>::ClearElements(((SparseArraySegment<double>*)seg)->elements + newSegmentLength, seg->length - newSegmentLength);",
          "2796:     }",
          "2798:     Var JavascriptArray::DirectGetItem(uint32 index)",
          "2799:     {",
          "2800:         SparseArraySegment<Var> *seg = (SparseArraySegment<Var>*)this->GetLastUsedSegment();",
          "2801:         uint32 offset = index - seg->left;",
          "2802:         if (index >= seg->left && offset < seg->length)",
          "2803:         {",
          "2804:             if (!SparseArraySegment<Var>::IsMissingItem(&seg->elements[offset]))",
          "2805:             {",
          "2806:                 return seg->elements[offset];",
          "2807:             }",
          "2808:         }",
          "2809:         Var element;",
          "2810:         if (DirectGetItemAtFull(index, &element))",
          "2811:         {",
          "2812:             return element;",
          "2813:         }",
          "2814:         return GetType()->GetLibrary()->GetUndefined();",
          "2815:     }",
          "2817:     Var JavascriptNativeIntArray::DirectGetItem(uint32 index)",
          "2818:     {",
          "2819: #if ENABLE_COPYONACCESS_ARRAY",
          "2820:         JavascriptLibrary::CheckAndConvertCopyOnAccessNativeIntArray<Var>(this);",
          "2821: #endif",
          "2822:         SparseArraySegment<int32> *seg = (SparseArraySegment<int32>*)this->GetLastUsedSegment();",
          "2823:         uint32 offset = index - seg->left;",
          "2824:         if (index >= seg->left && offset < seg->length)",
          "2825:         {",
          "2826:             if (!SparseArraySegment<int32>::IsMissingItem(&seg->elements[offset]))",
          "2827:             {",
          "2828:                 return JavascriptNumber::ToVar(seg->elements[offset], GetScriptContext());",
          "2829:             }",
          "2830:         }",
          "2831:         Var element;",
          "2832:         if (DirectGetItemAtFull(index, &element))",
          "2833:         {",
          "2834:             return element;",
          "2835:         }",
          "2836:         return GetType()->GetLibrary()->GetUndefined();",
          "2837:     }",
          "2839:     DescriptorFlags JavascriptNativeIntArray::GetItemSetter(uint32 index, Var* setterValue, ScriptContext* requestContext)",
          "2840:     {",
          "2841: #if ENABLE_COPYONACCESS_ARRAY",
          "2842:         JavascriptLibrary::CheckAndConvertCopyOnAccessNativeIntArray<Var>(this);",
          "2843: #endif",
          "2844:         int32 value = 0;",
          "2845:         return this->DirectGetItemAt(index, &value) ? WritableData : None;",
          "2846:     }",
          "2849:     Var JavascriptNativeFloatArray::DirectGetItem(uint32 index)",
          "2850:     {",
          "2851:         SparseArraySegment<double> *seg = (SparseArraySegment<double>*)this->GetLastUsedSegment();",
          "2852:         uint32 offset = index - seg->left;",
          "2853:         if (index >= seg->left && offset < seg->length)",
          "2854:         {",
          "2855:             if (!SparseArraySegment<double>::IsMissingItem(&seg->elements[offset]))",
          "2856:             {",
          "2857:                 return JavascriptNumber::ToVarWithCheck(seg->elements[offset], GetScriptContext());",
          "2858:             }",
          "2859:         }",
          "2860:         Var element;",
          "2861:         if (DirectGetItemAtFull(index, &element))",
          "2862:         {",
          "2863:             return element;",
          "2864:         }",
          "2865:         return GetType()->GetLibrary()->GetUndefined();",
          "2866:     }",
          "2868:     Var JavascriptArray::DirectGetItem(JavascriptString *propName, ScriptContext* scriptContext)",
          "2869:     {",
          "2870:         PropertyRecord const * propertyRecord;",
          "2871:         scriptContext->GetOrAddPropertyRecord(propName->GetString(), propName->GetLength(), &propertyRecord);",
          "2872:         return JavascriptOperators::GetProperty(this, propertyRecord->GetPropertyId(), scriptContext, NULL);",
          "2873:     }",
          "2875:     BOOL JavascriptArray::DirectGetItemAtFull(uint32 index, Var* outVal)",
          "2876:     {",
          "2877:         if (this->DirectGetItemAt(index, outVal))",
          "2878:         {",
          "2879:             return TRUE;",
          "2880:         }",
          "2882:         ScriptContext* requestContext = type->GetScriptContext();",
          "2883:         return JavascriptOperators::GetItem(this, this->GetPrototype(), index, outVal, requestContext);",
          "2884:     }",
          "2889:     void JavascriptArray::LinkSegmentsCommon(SparseArraySegmentBase* prev, SparseArraySegmentBase* current)",
          "2890:     {",
          "2891:         if (prev)",
          "2892:         {",
          "2893:             prev->next = current;",
          "2894:         }",
          "2895:         else",
          "2896:         {",
          "2897:             Assert(current);",
          "2898:             head = current;",
          "2899:         }",
          "2900:     }",
          "2902:     template<typename T>",
          "2903:     BOOL JavascriptArray::DirectDeleteItemAt(uint32 itemIndex)",
          "2904:     {",
          "2905:         if (itemIndex >= length)",
          "2906:         {",
          "2907:             return true;",
          "2908:         }",
          "2909:         SparseArraySegment<T>* next = (SparseArraySegment<T>*)GetBeginLookupSegment(itemIndex);",
          "2910:         while(next != nullptr && next->left <= itemIndex)",
          "2911:         {",
          "2912:             uint32 limit = next->left + next->length;",
          "2913:             if (itemIndex < limit)",
          "2914:             {",
          "2915:                 next->SetElement(GetRecycler(), itemIndex, SparseArraySegment<T>::GetMissingItem());",
          "2916:                 if(itemIndex - next->left == next->length - 1)",
          "2917:                 {",
          "2918:                     --next->length;",
          "2919:                 }",
          "2920:                 else if(next == head)",
          "2921:                 {",
          "2922:                     SetHasNoMissingValues(false);",
          "2923:                 }",
          "2924:                 break;",
          "2925:             }",
          "2926:             next = SparseArraySegment<T>::From(next->next);",
          "2927:         }",
          "2928: #ifdef VALIDATE_ARRAY",
          "2929:         ValidateArray();",
          "2930: #endif",
          "2931:         return true;",
          "2932:     }",
          "2934:     template <> Var JavascriptArray::ConvertToIndex(BigIndex idxDest, ScriptContext* scriptContext)",
          "2935:     {",
          "2936:         return idxDest.ToNumber(scriptContext);",
          "2937:     }",
          "2939:     template <> uint32 JavascriptArray::ConvertToIndex(BigIndex idxDest, ScriptContext* scriptContext)",
          "2940:     {",
          "2942:         return idxDest.IsSmallIndex() ? idxDest.GetSmallIndex() : UINT_MAX;",
          "2943:     }",
          "2945:     template <> Var JavascriptArray::ConvertToIndex(uint32 idxDest, ScriptContext* scriptContext)",
          "2946:     {",
          "2947:         return  JavascriptNumber::ToVar(idxDest, scriptContext);",
          "2948:     }",
          "2950:     void JavascriptArray::ThrowErrorOnFailure(BOOL succeeded, ScriptContext* scriptContext, uint32 index)",
          "2951:     {",
          "2952:         if (!succeeded)",
          "2953:         {",
          "2954:             JavascriptError::ThrowTypeError(scriptContext, JSERR_CantRedefineProp, JavascriptConversion::ToString(JavascriptNumber::ToVar(index, scriptContext), scriptContext)->GetSz());",
          "2955:         }",
          "2956:     }",
          "2958:     void JavascriptArray::ThrowErrorOnFailure(BOOL succeeded, ScriptContext* scriptContext, BigIndex index)",
          "2959:     {",
          "2960:         if (!succeeded)",
          "2961:         {",
          "2962:             uint64 i = (uint64)(index.IsSmallIndex() ? index.GetSmallIndex() : index.GetBigIndex());",
          "2963:             JavascriptError::ThrowTypeError(scriptContext, JSERR_CantRedefineProp, JavascriptConversion::ToString(JavascriptNumber::ToVar(i, scriptContext), scriptContext)->GetSz());",
          "2964:         }",
          "2965:     }",
          "2967:     BOOL JavascriptArray::SetArrayLikeObjects(RecyclableObject* pDestObj, uint32 idxDest, Var aItem)",
          "2968:     {",
          "2969:         return pDestObj->SetItem(idxDest, aItem, Js::PropertyOperation_ThrowIfNotExtensible);",
          "2970:     }",
          "2972:     uint64 JavascriptArray::OP_GetLength(Var obj, ScriptContext *scriptContext)",
          "2973:     {",
          "2974:         if (scriptContext->GetConfig()->IsES6ToLengthEnabled())",
          "2975:         {",
          "2977:             return (uint64)JavascriptConversion::ToLength(JavascriptOperators::OP_GetLength(obj, scriptContext), scriptContext);",
          "2978:         }",
          "2979:         else",
          "2980:         {",
          "2981:             return (uint64)JavascriptConversion::ToUInt32(JavascriptOperators::OP_GetLength(obj, scriptContext), scriptContext);",
          "2982:         }",
          "2983:     }",
          "2985:     template<typename T>",
          "2986:     void JavascriptArray::TryGetArrayAndLength(Var arg,",
          "2987:         ScriptContext *scriptContext,",
          "2988:         PCWSTR methodName,",
          "2989:         __out JavascriptArray** array,",
          "2990:         __out RecyclableObject** obj,",
          "2991:         __out T * length)",
          "2992:     {",
          "2993:         Assert(array != nullptr);",
          "2994:         Assert(obj != nullptr);",
          "2995:         Assert(length != nullptr);",
          "2997:         if (JavascriptArray::Is(arg) && !JavascriptArray::FromVar(arg)->IsCrossSiteObject())",
          "2998:         {",
          "2999: #if ENABLE_COPYONACCESS_ARRAY",
          "3000:             JavascriptLibrary::CheckAndConvertCopyOnAccessNativeIntArray<Var>(arg);",
          "3001: #endif",
          "3005:         }",
          "3006:         else",
          "3007:         {",
          "3008:             if (!JavascriptConversion::ToObject(arg, scriptContext, obj))",
          "3009:             {",
          "3010:                 JavascriptError::ThrowTypeError(scriptContext, JSERR_This_NullOrUndefined, methodName);",
          "3011:             }",
          "3014:         }",
          "3015:     }",
          "3017:     BOOL JavascriptArray::SetArrayLikeObjects(RecyclableObject* pDestObj, BigIndex idxDest, Var aItem)",
          "3018:     {",
          "3019:         ScriptContext* scriptContext = pDestObj->GetScriptContext();",
          "3021:         if (idxDest.IsSmallIndex())",
          "3022:         {",
          "3023:             return pDestObj->SetItem(idxDest.GetSmallIndex(), aItem, Js::PropertyOperation_ThrowIfNotExtensible);",
          "3024:         }",
          "3025:         PropertyRecord const * propertyRecord;",
          "3026:         JavascriptOperators::GetPropertyIdForInt(idxDest.GetBigIndex(), scriptContext, &propertyRecord);",
          "3027:         return pDestObj->SetProperty(propertyRecord->GetPropertyId(), aItem, PropertyOperation_ThrowIfNotExtensible, nullptr);",
          "3028:     }",
          "3030:     template<typename T>",
          "3031:     void JavascriptArray::ConcatArgs(RecyclableObject* pDestObj, TypeId* remoteTypeIds,",
          "3032:         Js::Arguments& args, ScriptContext* scriptContext, uint start, BigIndex startIdxDest,",
          "3033:         BOOL FirstPromotedItemIsSpreadable, BigIndex FirstPromotedItemLength, bool spreadableCheckedAndTrue)",
          "3034:     {",
          "3036:         Throw::InternalError();",
          "3037:     }",
          "3041:     template<typename T>",
          "3042:     void JavascriptArray::ConcatArgs(RecyclableObject* pDestObj, TypeId* remoteTypeIds,",
          "3043:         Js::Arguments& args, ScriptContext* scriptContext, uint start, uint startIdxDest,",
          "3044:         BOOL firstPromotedItemIsSpreadable, BigIndex firstPromotedItemLength, bool spreadableCheckedAndTrue)",
          "3045:     {",
          "3046:         JS_REENTRANCY_LOCK(jsReentLock, scriptContext->GetThreadContext());",
          "3047:         JavascriptArray* pDestArray = nullptr;",
          "3049:         if (JavascriptArray::Is(pDestObj))",
          "3050:         {",
          "3051:             pDestArray = JavascriptArray::FromVar(pDestObj);",
          "3052:         }",
          "3054:         T idxDest = startIdxDest;",
          "3055:         for (uint idxArg = start; idxArg < args.Info.Count; idxArg++)",
          "3056:         {",
          "3057:             Var aItem = args[idxArg];",
          "3058:             bool spreadable = spreadableCheckedAndTrue;",
          "3059:             if (!spreadable && scriptContext->GetConfig()->IsES6IsConcatSpreadableEnabled())",
          "3060:             {",
          "3064:                 JS_REENTRANT(jsReentLock, spreadable = firstPromotedItemIsSpreadable || JavascriptOperators::IsConcatSpreadable(aItem));",
          "3066:                 if (!spreadable)",
          "3067:                 {",
          "3068:                     JS_REENTRANT(jsReentLock, JavascriptArray::SetConcatItem<T>(aItem, idxArg, pDestArray, pDestObj, idxDest, scriptContext));",
          "3069:                     ++idxDest;",
          "3070:                     continue;",
          "3071:                 }",
          "3072:             }",
          "3073:             else",
          "3074:             {",
          "3075:                 spreadableCheckedAndTrue = false; // if it was `true`, reset after the first use",
          "3076:             }",
          "3078:             if (pDestArray && JavascriptArray::IsDirectAccessArray(aItem) && JavascriptArray::IsDirectAccessArray(pDestArray)",
          "3079:                 && BigIndex(idxDest + JavascriptArray::FromVar(aItem)->length).IsSmallIndex()) // Fast path",
          "3080:             {",
          "3081:                 if (JavascriptNativeIntArray::Is(aItem))",
          "3082:                 {",
          "3083:                     JavascriptNativeIntArray *pItemArray = JavascriptNativeIntArray::FromVar(aItem);",
          "3084:                     JS_REENTRANT(jsReentLock, CopyNativeIntArrayElementsToVar(pDestArray, idxDest, pItemArray));",
          "3085:                     idxDest = idxDest + pItemArray->length;",
          "3086:                 }",
          "3087:                 else if (JavascriptNativeFloatArray::Is(aItem))",
          "3088:                 {",
          "3089:                     JavascriptNativeFloatArray *pItemArray = JavascriptNativeFloatArray::FromVar(aItem);",
          "3090:                     JS_REENTRANT(jsReentLock, CopyNativeFloatArrayElementsToVar(pDestArray, idxDest, pItemArray));",
          "3091:                     idxDest = idxDest + pItemArray->length;",
          "3092:                 }",
          "3093:                 else",
          "3094:                 {",
          "3095:                     JavascriptArray* pItemArray = JavascriptArray::FromVar(aItem);",
          "3096:                     JS_REENTRANT(jsReentLock, CopyArrayElements(pDestArray, idxDest, pItemArray));",
          "3097:                     idxDest = idxDest + pItemArray->length;",
          "3098:                 }",
          "3099:             }",
          "3100:             else",
          "3101:             {",
          "3103:                 if (DynamicObject::IsAnyArray(aItem) || remoteTypeIds[idxArg] == TypeIds_Array || spreadable)",
          "3104:                 {",
          "3106:                     BigIndex length;",
          "3107:                     if (firstPromotedItemIsSpreadable)",
          "3108:                     {",
          "3109:                         firstPromotedItemIsSpreadable = false;",
          "3110:                         length = firstPromotedItemLength;",
          "3111:                     }",
          "3112:                     else",
          "3113:                     {",
          "3114:                         JS_REENTRANT(jsReentLock, length = OP_GetLength(aItem, scriptContext));",
          "3115:                     }",
          "3117:                     if (PromoteToBigIndex(length,idxDest))",
          "3118:                     {",
          "3123:                         ConcatArgs<BigIndex>(pDestArray, remoteTypeIds, args, scriptContext, idxArg, idxDest, /*firstPromotedItemIsSpreadable*/true, length);",
          "3124:                         return;",
          "3125:                     }",
          "3127:                     if (length + idxDest > FiftyThirdPowerOfTwoMinusOne) // 2^53-1: from ECMA 22.1.3.1 Array.prototype.concat(...arguments)",
          "3128:                     {",
          "3129:                         JavascriptError::ThrowTypeError(scriptContext, JSERR_IllegalArraySizeAndLength);",
          "3130:                     }",
          "3132:                     RecyclableObject* itemObject = RecyclableObject::FromVar(aItem);",
          "3133:                     Var subItem;",
          "3134:                     uint32 lengthToUin32Max = length.IsSmallIndex() ? length.GetSmallIndex() : MaxArrayLength;",
          "3135:                     for (uint32 idxSubItem = 0u; idxSubItem < lengthToUin32Max; ++idxSubItem)",
          "3136:                     {",
          "3137:                         JS_REENTRANT(jsReentLock, BOOL hasItem = JavascriptOperators::HasItem(itemObject, idxSubItem));",
          "3138:                         if (hasItem)",
          "3139:                         {",
          "3140:                             JS_REENTRANT(jsReentLock, subItem = JavascriptOperators::GetItem(itemObject, idxSubItem, scriptContext));",
          "3142:                             if (pDestArray)",
          "3143:                             {",
          "3144:                                 pDestArray->DirectSetItemAt(idxDest, subItem);",
          "3145:                             }",
          "3146:                             else",
          "3147:                             {",
          "3148:                                 JS_REENTRANT(jsReentLock, ThrowErrorOnFailure(SetArrayLikeObjects(pDestObj, idxDest, subItem), scriptContext, idxDest));",
          "3149:                             }",
          "3150:                         }",
          "3151:                         ++idxDest;",
          "3152:                     }",
          "3154:                     for (BigIndex idxSubItem = MaxArrayLength; idxSubItem < length; ++idxSubItem)",
          "3155:                     {",
          "3156:                         PropertyRecord const * propertyRecord;",
          "3157:                         JavascriptOperators::GetPropertyIdForInt(idxSubItem.GetBigIndex(), scriptContext, &propertyRecord);",
          "3158:                         JS_REENTRANT(jsReentLock, BOOL hasProp = JavascriptOperators::HasProperty(itemObject, propertyRecord->GetPropertyId()));",
          "3159:                         if (hasProp)",
          "3160:                         {",
          "3161:                             JS_REENTRANT(jsReentLock, subItem = JavascriptOperators::GetProperty(itemObject, propertyRecord->GetPropertyId(), scriptContext));",
          "3162:                             if (pDestArray)",
          "3163:                             {",
          "3164:                                 pDestArray->DirectSetItemAt(idxDest, subItem);",
          "3165:                             }",
          "3166:                             else",
          "3167:                             {",
          "3168:                                 JS_REENTRANT(jsReentLock, ThrowErrorOnFailure(SetArrayLikeObjects(pDestObj, idxDest, subItem), scriptContext, idxSubItem));",
          "3169:                             }",
          "3170:                         }",
          "3171:                         ++idxDest;",
          "3172:                     }",
          "3173:                 }",
          "3174:                 else // concat 1 item",
          "3175:                 {",
          "3176:                     JS_REENTRANT(jsReentLock, JavascriptArray::SetConcatItem<T>(aItem, idxArg, pDestArray, pDestObj, idxDest, scriptContext));",
          "3177:                     ++idxDest;",
          "3178:                 }",
          "3179:             }",
          "3180:         }",
          "3181:         if (!pDestArray)",
          "3182:         {",
          "3183:             JS_REENTRANT(jsReentLock, pDestObj->SetProperty(PropertyIds::length, ConvertToIndex<T, Var>(idxDest, scriptContext), Js::PropertyOperation_None, nullptr));",
          "3184:        }",
          "3185:         else if (pDestArray->GetLength() != ConvertToIndex<T, uint32>(idxDest, scriptContext))",
          "3186:         {",
          "3187:             pDestArray->SetLength(ConvertToIndex<T, uint32>(idxDest, scriptContext));",
          "3188:         }",
          "3189:     }",
          "3191:     bool JavascriptArray::PromoteToBigIndex(BigIndex lhs, BigIndex rhs)",
          "3192:     {",
          "3193:         return false; // already a big index",
          "3194:     }",
          "3196:     bool JavascriptArray::PromoteToBigIndex(BigIndex lhs, uint32 rhs)",
          "3197:     {",
          "3198:         ::Math::RecordOverflowPolicy destLengthOverflow;",
          "3199:         if (lhs.IsSmallIndex())",
          "3200:         {",
          "3201:             UInt32Math::Add(lhs.GetSmallIndex(), rhs, destLengthOverflow);",
          "3202:             return destLengthOverflow.HasOverflowed();",
          "3203:         }",
          "3204:         return true;",
          "3205:     }",
          "3207:     JavascriptArray* JavascriptArray::ConcatIntArgs(JavascriptNativeIntArray* pDestArray, TypeId *remoteTypeIds, Js::Arguments& args, ScriptContext* scriptContext)",
          "3208:     {",
          "3209:         JS_REENTRANCY_LOCK(jsReentLock, scriptContext->GetThreadContext());",
          "3210:         uint idxDest = 0u;",
          "3211:         for (uint idxArg = 0; idxArg < args.Info.Count; idxArg++)",
          "3212:         {",
          "3213:             Var aItem = args[idxArg];",
          "3214:             bool spreadableCheckedAndTrue = false;",
          "3216:             if (scriptContext->GetConfig()->IsES6IsConcatSpreadableEnabled())",
          "3217:             {",
          "3218:                 JS_REENTRANT(jsReentLock, spreadableCheckedAndTrue = !scriptContext->GetConfig()->IsES6IsConcatSpreadableEnabled() || JavascriptOperators::IsConcatSpreadable(aItem));",
          "3219:                 if (!JavascriptNativeIntArray::Is(pDestArray))",
          "3220:                 {",
          "3221:                     ConcatArgs<uint>(pDestArray, remoteTypeIds, args, scriptContext, idxArg, idxDest, spreadableCheckedAndTrue);",
          "3222:                     return pDestArray;",
          "3223:                 }",
          "3225:                 if(!spreadableCheckedAndTrue)",
          "3226:                 {",
          "3227:                     JS_REENTRANT(jsReentLock, pDestArray->SetItem(idxDest, aItem, PropertyOperation_ThrowIfNotExtensible));",
          "3228:                     idxDest = idxDest + 1;",
          "3229:                     if (!JavascriptNativeIntArray::Is(pDestArray)) // SetItem could convert pDestArray to a var array if aItem is not an integer if so fall back",
          "3230:                     {",
          "3231:                         JS_REENTRANT(jsReentLock, ConcatArgs<uint>(pDestArray, remoteTypeIds, args, scriptContext, idxArg + 1, idxDest));",
          "3232:                         return pDestArray;",
          "3233:                     }",
          "3234:                     continue;",
          "3235:                 }",
          "3236:             }",
          "3238:             if (JavascriptNativeIntArray::Is(aItem)) // Fast path",
          "3239:             {",
          "3240:                 JavascriptNativeIntArray* pItemArray = JavascriptNativeIntArray::FromVar(aItem);",
          "3242:                 JS_REENTRANT(jsReentLock, bool converted = CopyNativeIntArrayElements(pDestArray, idxDest, pItemArray));",
          "3244:                 idxDest = idxDest + pItemArray->length;",
          "3245:                 if (converted)",
          "3246:                 {",
          "3249:                     JS_REENTRANT(jsReentLock, ConcatArgs<uint>(pDestArray, remoteTypeIds, args, scriptContext, idxArg + 1, idxDest));",
          "3250:                     return pDestArray;",
          "3251:                 }",
          "3252:             }",
          "3253:             else if (!JavascriptArray::IsAnyArray(aItem) && remoteTypeIds[idxArg] != TypeIds_Array)",
          "3254:             {",
          "3255:                 if (TaggedInt::Is(aItem))",
          "3256:                 {",
          "3257:                     pDestArray->DirectSetItemAt(idxDest, TaggedInt::ToInt32(aItem));",
          "3258:                 }",
          "3259:                 else",
          "3260:                 {",
          "3261: #if DBG",
          "3262:                     int32 int32Value;",
          "3263:                     Assert(",
          "3264:                         JavascriptNumber::TryGetInt32Value(JavascriptNumber::GetValue(aItem), &int32Value) &&",
          "3265:                         !SparseArraySegment<int32>::IsMissingItem(&int32Value));",
          "3266: #endif",
          "3267:                     pDestArray->DirectSetItemAt(idxDest, static_cast<int32>(JavascriptNumber::GetValue(aItem)));",
          "3268:                 }",
          "3269:                 ++idxDest;",
          "3270:             }",
          "3271:             else",
          "3272:             {",
          "3273:                 JavascriptArray *pVarDestArray = JavascriptNativeIntArray::ConvertToVarArray(pDestArray);",
          "3274:                 JS_REENTRANT(jsReentLock, ConcatArgs<uint>(pVarDestArray, remoteTypeIds, args, scriptContext, idxArg, idxDest, spreadableCheckedAndTrue));",
          "3275:                 return pVarDestArray;",
          "3276:             }",
          "3277:         }",
          "3278:         if (pDestArray->GetLength() != idxDest)",
          "3279:         {",
          "3280:             pDestArray->SetLength(idxDest);",
          "3281:         }",
          "3282:         return pDestArray;",
          "3283:     }",
          "3285:     JavascriptArray* JavascriptArray::ConcatFloatArgs(JavascriptNativeFloatArray* pDestArray, TypeId *remoteTypeIds, Js::Arguments& args, ScriptContext* scriptContext)",
          "3286:     {",
          "3287:         JS_REENTRANCY_LOCK(jsReentLock, scriptContext->GetThreadContext());",
          "3288:         uint idxDest = 0u;",
          "3289:         for (uint idxArg = 0; idxArg < args.Info.Count; idxArg++)",
          "3290:         {",
          "3291:             Var aItem = args[idxArg];",
          "3293:             bool spreadableCheckedAndTrue = false;",
          "3295:             if (scriptContext->GetConfig()->IsES6IsConcatSpreadableEnabled())",
          "3296:             {",
          "3297:                 JS_REENTRANT(jsReentLock, spreadableCheckedAndTrue = !scriptContext->GetConfig()->IsES6IsConcatSpreadableEnabled() || JavascriptOperators::IsConcatSpreadable(aItem));",
          "3298:                 if (!JavascriptNativeFloatArray::Is(pDestArray))",
          "3299:                 {",
          "3300:                     ConcatArgs<uint>(pDestArray, remoteTypeIds, args, scriptContext, idxArg, idxDest, spreadableCheckedAndTrue);",
          "3301:                     return pDestArray;",
          "3302:                 }",
          "3304:                 if (!spreadableCheckedAndTrue)",
          "3305:                 {",
          "3306:                     JS_REENTRANT(jsReentLock, pDestArray->SetItem(idxDest, aItem, PropertyOperation_ThrowIfNotExtensible));",
          "3308:                     idxDest = idxDest + 1;",
          "3309:                     if (!JavascriptNativeFloatArray::Is(pDestArray)) // SetItem could convert pDestArray to a var array if aItem is not an integer if so fall back",
          "3310:                     {",
          "3311:                         JS_REENTRANT(jsReentLock, ConcatArgs<uint>(pDestArray, remoteTypeIds, args, scriptContext, idxArg + 1, idxDest));",
          "3312:                         return pDestArray;",
          "3313:                     }",
          "3314:                     continue;",
          "3315:                 }",
          "3316:             }",
          "3318:             bool converted;",
          "3319:             if (JavascriptArray::IsAnyArray(aItem) || remoteTypeIds[idxArg] == TypeIds_Array)",
          "3320:             {",
          "3321:                 if (JavascriptNativeIntArray::Is(aItem)) // Fast path",
          "3322:                 {",
          "3323:                     JavascriptNativeIntArray *pIntArray = JavascriptNativeIntArray::FromVar(aItem);",
          "3325:                     JS_REENTRANT(jsReentLock, converted = CopyNativeIntArrayElementsToFloat(pDestArray, idxDest, pIntArray));",
          "3327:                     idxDest = idxDest + pIntArray->length;",
          "3328:                 }",
          "3329:                 else if (JavascriptNativeFloatArray::Is(aItem))",
          "3330:                 {",
          "3331:                     JavascriptNativeFloatArray* pItemArray = JavascriptNativeFloatArray::FromVar(aItem);",
          "3333:                     JS_REENTRANT(jsReentLock, converted = CopyNativeFloatArrayElements(pDestArray, idxDest, pItemArray));",
          "3335:                     idxDest = idxDest + pItemArray->length;",
          "3336:                 }",
          "3337:                 else",
          "3338:                 {",
          "3339:                     JavascriptArray *pVarDestArray = JavascriptNativeFloatArray::ConvertToVarArray(pDestArray);",
          "3341:                     JS_REENTRANT(jsReentLock, ConcatArgs<uint>(pVarDestArray, remoteTypeIds, args, scriptContext, idxArg, idxDest, spreadableCheckedAndTrue));",
          "3343:                     return pVarDestArray;",
          "3344:                 }",
          "3346:                 if (converted)",
          "3347:                 {",
          "3351:                     JS_REENTRANT(jsReentLock, ConcatArgs<uint>(pDestArray, remoteTypeIds, args, scriptContext, idxArg + 1, idxDest));",
          "3353:                     return pDestArray;",
          "3354:                 }",
          "3355:             }",
          "3356:             else",
          "3357:             {",
          "3358:                 if (TaggedInt::Is(aItem))",
          "3359:                 {",
          "3360:                     pDestArray->DirectSetItemAt(idxDest, (double)TaggedInt::ToInt32(aItem));",
          "3361:                 }",
          "3362:                 else",
          "3363:                 {",
          "3364:                     Assert(JavascriptNumber::Is(aItem));",
          "3365:                     pDestArray->DirectSetItemAt(idxDest, JavascriptNumber::GetValue(aItem));",
          "3366:                 }",
          "3367:                 ++idxDest;",
          "3368:             }",
          "3369:         }",
          "3370:         if (pDestArray->GetLength() != idxDest)",
          "3371:         {",
          "3372:             pDestArray->SetLength(idxDest);",
          "3373:         }",
          "3375:         return pDestArray;",
          "3376:     }",
          "3378:     bool JavascriptArray::BoxConcatItem(Var aItem, uint idxArg, ScriptContext *scriptContext)",
          "3379:     {",
          "3380:         return idxArg == 0 && !JavascriptOperators::IsObject(aItem);",
          "3381:     }",
          "3383:     Var JavascriptArray::EntryConcat(RecyclableObject* function, CallInfo callInfo, ...)",
          "3384:     {",
          "3385:         PROBE_STACK(function->GetScriptContext(), Js::Constants::MinStackDefault);",
          "3387:         ARGUMENTS(args, callInfo);",
          "3388:         ScriptContext* scriptContext = function->GetScriptContext();",
          "3389:         JS_REENTRANCY_LOCK(jsReentLock, scriptContext->GetThreadContext());",
          "3391:         Assert(!(callInfo.Flags & CallFlags_New));",
          "3393:         if (args.Info.Count == 0)",
          "3394:         {",
          "3395:             JavascriptError::ThrowTypeError(scriptContext, JSERR_This_NullOrUndefined, _u(\"Array.prototype.concat\"));",
          "3396:         }",
          "3403:         uint32 cDestLength = 0;",
          "3404:         JavascriptArray * pDestArray = NULL;",
          "3406:         PROBE_STACK(function->GetScriptContext(), Js::Constants::MinStackDefault + (args.Info.Count * sizeof(TypeId*)));",
          "3407:         TypeId* remoteTypeIds = (TypeId*)_alloca(args.Info.Count * sizeof(TypeId*));",
          "3409:         bool isInt = true;",
          "3410:         bool isFloat = true;",
          "3411:         ::Math::RecordOverflowPolicy destLengthOverflow;",
          "3412:         for (uint idxArg = 0; idxArg < args.Info.Count; idxArg++)",
          "3413:         {",
          "3414:             Var aItem = args[idxArg];",
          "3415: #if ENABLE_COPYONACCESS_ARRAY",
          "3416:             JavascriptLibrary::CheckAndConvertCopyOnAccessNativeIntArray<Var>(aItem);",
          "3417: #endif",
          "3418:             if (DynamicObject::IsAnyArray(aItem)) // Get JavascriptArray or ES5Array length",
          "3419:             {",
          "3420:                 JavascriptArray * pItemArray = JavascriptArray::FromAnyArray(aItem);",
          "3421:                 if (isFloat)",
          "3422:                 {",
          "3423:                     if (!JavascriptNativeIntArray::Is(pItemArray))",
          "3424:                     {",
          "3425:                         isInt = false;",
          "3426:                         if (!JavascriptNativeFloatArray::Is(pItemArray))",
          "3427:                         {",
          "3428:                             isFloat = false;",
          "3429:                         }",
          "3430:                     }",
          "3431:                 }",
          "3432:                 cDestLength = UInt32Math::Add(cDestLength, pItemArray->GetLength(), destLengthOverflow);",
          "3433:             }",
          "3434:             else // Get remote array or object length",
          "3435:             {",
          "3438:                 if (JavascriptOperators::IsArray(aItem))",
          "3439:                 {",
          "3442:                     isInt = false;",
          "3443:                     isFloat = false;",
          "3444:                     if (!JavascriptProxy::Is(aItem))",
          "3445:                     {",
          "3446:                         if (scriptContext->GetConfig()->IsES6ToLengthEnabled())",
          "3447:                         {",
          "3448:                             JS_REENTRANT(jsReentLock,",
          "3449:                                 int64 len = JavascriptConversion::ToLength(JavascriptOperators::OP_GetLength(aItem, scriptContext), scriptContext));",
          "3451:                             cDestLength = UInt32Math::Add(cDestLength, len < MaxArrayLength ? (uint32)len : MaxArrayLength, destLengthOverflow);",
          "3452:                         }",
          "3453:                         else",
          "3454:                         {",
          "3455:                             JS_REENTRANT(jsReentLock,",
          "3456:                                 uint len = JavascriptConversion::ToUInt32(JavascriptOperators::OP_GetLength(aItem, scriptContext), scriptContext));",
          "3457:                             cDestLength = UInt32Math::Add(cDestLength, len, destLengthOverflow);",
          "3458:                         }",
          "3459:                     }",
          "3460:                     remoteTypeIds[idxArg] = TypeIds_Array; // Mark remote array, no matter remote JavascriptArray or ES5Array.",
          "3461:                 }",
          "3462:                 else",
          "3463:                 {",
          "3464:                     if (isFloat)",
          "3465:                     {",
          "3466:                         if (BoxConcatItem(aItem, idxArg, scriptContext))",
          "3467:                         {",
          "3469:                             isInt = false;",
          "3470:                             isFloat = false;",
          "3471:                         }",
          "3472:                         else if (!TaggedInt::Is(aItem))",
          "3473:                         {",
          "3474:                             if (!JavascriptNumber::Is(aItem))",
          "3475:                             {",
          "3476:                                 isInt = false;",
          "3477:                                 isFloat = false;",
          "3478:                             }",
          "3479:                             else if (isInt)",
          "3480:                             {",
          "3481:                                 int32 int32Value;",
          "3482:                                 if(!JavascriptNumber::TryGetInt32Value(JavascriptNumber::GetValue(aItem), &int32Value) ||",
          "3483:                                     SparseArraySegment<int32>::IsMissingItem(&int32Value))",
          "3484:                                 {",
          "3485:                                     isInt = false;",
          "3486:                                 }",
          "3487:                             }",
          "3488:                         }",
          "3489:                         else if(isInt)",
          "3490:                         {",
          "3491:                             int32 int32Value = TaggedInt::ToInt32(aItem);",
          "3492:                             if(SparseArraySegment<int32>::IsMissingItem(&int32Value))",
          "3493:                             {",
          "3494:                                 isInt = false;",
          "3495:                             }",
          "3496:                         }",
          "3497:                     }",
          "3499:                     remoteTypeIds[idxArg] = TypeIds_Limit;",
          "3500:                     cDestLength = UInt32Math::Add(cDestLength, 1, destLengthOverflow);",
          "3501:                 }",
          "3502:             }",
          "3503:         }",
          "3504:         if (destLengthOverflow.HasOverflowed())",
          "3505:         {",
          "3506:             cDestLength = MaxArrayLength;",
          "3507:             isInt = false;",
          "3508:             isFloat = false;",
          "3509:         }",
          "3514:         RecyclableObject* pDestObj = nullptr;",
          "3515:         bool isArray = false;",
          "3517:         JS_REENTRANT(jsReentLock, pDestObj = ArraySpeciesCreate(args[0], 0, scriptContext));",
          "3519:         if (pDestObj)",
          "3520:         {",
          "3521: #if ENABLE_COPYONACCESS_ARRAY",
          "3522:             JavascriptLibrary::CheckAndConvertCopyOnAccessNativeIntArray<Var>(pDestObj);",
          "3523: #endif",
          "3527:             if (isInt)",
          "3528:             {",
          "3529:                 if (JavascriptNativeIntArray::Is(pDestObj))",
          "3530:                 {",
          "3531:                     isArray = true;",
          "3532:                 }",
          "3533:                 else",
          "3534:                 {",
          "3535:                     isInt = false;",
          "3536:                     isFloat = JavascriptNativeFloatArray::Is(pDestObj);",
          "3537:                     isArray = JavascriptArray::Is(pDestObj);",
          "3538:                 }",
          "3539:             }",
          "3540:             else if (isFloat)",
          "3541:             {",
          "3542:                 if (JavascriptNativeIntArray::Is(pDestObj))",
          "3543:                 {",
          "3544:                     JavascriptNativeIntArray::ToNativeFloatArray(JavascriptNativeIntArray::FromVar(pDestObj));",
          "3545:                     isArray = true;",
          "3546:                 }",
          "3547:                 else",
          "3548:                 {",
          "3549:                     isFloat = JavascriptNativeFloatArray::Is(pDestObj);",
          "3550:                     isArray = JavascriptArray::Is(pDestObj);",
          "3551:                 }",
          "3552:             }",
          "3553:             else",
          "3554:             {",
          "3555:                 if (JavascriptNativeIntArray::Is(pDestObj))",
          "3556:                 {",
          "3557:                     JavascriptNativeIntArray::ToVarArray(JavascriptNativeIntArray::FromVar(pDestObj));",
          "3558:                     isArray = true;",
          "3559:                 }",
          "3560:                 else if (JavascriptNativeFloatArray::Is(pDestObj))",
          "3561:                 {",
          "3562:                     JavascriptNativeFloatArray::ToVarArray(JavascriptNativeFloatArray::FromVar(pDestObj));",
          "3563:                     isArray = true;",
          "3564:                 }",
          "3565:                 else",
          "3566:                 {",
          "3567:                     isArray = JavascriptArray::Is(pDestObj);",
          "3568:                 }",
          "3569:             }",
          "3571:         }",
          "3573:         if (pDestObj == nullptr || isArray)",
          "3574:         {",
          "3575:             if (isInt)",
          "3576:             {",
          "3577:                 JavascriptNativeIntArray *pIntArray = isArray ? JavascriptNativeIntArray::FromVar(pDestObj) : scriptContext->GetLibrary()->CreateNativeIntArray(cDestLength);",
          "3578:                 pIntArray->EnsureHead<int32>();",
          "3580:                 JS_REENTRANT(jsReentLock, pDestArray = ConcatIntArgs(pIntArray, remoteTypeIds, args, scriptContext));",
          "3581:             }",
          "3582:             else if (isFloat)",
          "3583:             {",
          "3584:                 JavascriptNativeFloatArray *pFArray = isArray ? JavascriptNativeFloatArray::FromVar(pDestObj) : scriptContext->GetLibrary()->CreateNativeFloatArray(cDestLength);",
          "3585:                 pFArray->EnsureHead<double>();",
          "3587:                 JS_REENTRANT(jsReentLock, pDestArray = ConcatFloatArgs(pFArray, remoteTypeIds, args, scriptContext));",
          "3588:             }",
          "3589:             else",
          "3590:             {",
          "3592:                 pDestArray = isArray ?  JavascriptArray::FromVar(pDestObj) : scriptContext->GetLibrary()->CreateArray(cDestLength);",
          "3594:                 pDestArray->EnsureHead<Var>();",
          "3596:                 JS_REENTRANT(jsReentLock, ConcatArgsCallingHelper(pDestArray, remoteTypeIds, args, scriptContext, destLengthOverflow));",
          "3597:             }",
          "3603: #ifdef VALIDATE_ARRAY",
          "3604:             pDestArray->ValidateArray();",
          "3605: #endif",
          "3607:             return pDestArray;",
          "3608:         }",
          "3610:         Assert(pDestObj);",
          "3611:         JS_REENTRANT(jsReentLock, ConcatArgsCallingHelper(pDestObj, remoteTypeIds, args, scriptContext, destLengthOverflow));",
          "3613:         return pDestObj;",
          "3614:     }",
          "3616:     void JavascriptArray::ConcatArgsCallingHelper(RecyclableObject* pDestObj, TypeId* remoteTypeIds, Js::Arguments& args, ScriptContext* scriptContext, ::Math::RecordOverflowPolicy &destLengthOverflow)",
          "3617:     {",
          "3618:         if (destLengthOverflow.HasOverflowed())",
          "3619:         {",
          "3620:             ConcatArgs<BigIndex>(pDestObj, remoteTypeIds, args, scriptContext);",
          "3621:         }",
          "3622:         else",
          "3623:         {",
          "3625:             ConcatArgs<uint32>(pDestObj, remoteTypeIds, args, scriptContext);",
          "3626:         }",
          "3627:     }",
          "3629:     template<typename T>",
          "3631:     {",
          "3632:         if (BoxConcatItem(aItem, idxArg, scriptContext))",
          "3633:         {",
          "3635:             RecyclableObject* pObj = nullptr;",
          "3636:             if (FALSE == JavascriptConversion::ToObject(aItem, scriptContext, &pObj))",
          "3637:             {",
          "3638:                 JavascriptError::ThrowTypeError(scriptContext, JSERR_This_NullOrUndefined, _u(\"Array.prototype.concat\"));",
          "3639:             }",
          "3640:             if (pDestArray)",
          "3641:             {",
          "3642:                 pDestArray->DirectSetItemAt(idxDest, pObj);",
          "3643:             }",
          "3644:             else",
          "3645:             {",
          "3646:                 SetArrayLikeObjects(pDestObj, idxDest, pObj);",
          "3647:             }",
          "3648:         }",
          "3649:         else",
          "3650:         {",
          "3651:             if (pDestArray)",
          "3652:             {",
          "3653:                 pDestArray->DirectSetItemAt(idxDest, aItem);",
          "3654:             }",
          "3655:             else",
          "3656:             {",
          "3657:                 SetArrayLikeObjects(pDestObj, idxDest, aItem);",
          "3658:             }",
          "3659:         }",
          "3660:     }",
          "3662:     int64 JavascriptArray::GetFromLastIndex(Var arg, int64 length, ScriptContext *scriptContext)",
          "3663:     {",
          "3664:         int64 fromIndex;",
          "3666:         if (TaggedInt::Is(arg))",
          "3667:         {",
          "3668:             int intValue = TaggedInt::ToInt32(arg);",
          "3670:             if (intValue >= 0)",
          "3671:             {",
          "3672:                 fromIndex = min<int64>(intValue, length - 1);",
          "3673:             }",
          "3674:             else if ((uint32)-intValue > length)",
          "3675:             {",
          "3676:                 return length;",
          "3677:             }",
          "3678:             else",
          "3679:             {",
          "3680:                 fromIndex = intValue + length;",
          "3681:             }",
          "3682:         }",
          "3683:         else",
          "3684:         {",
          "3685:             double value = JavascriptConversion::ToInteger(arg, scriptContext);",
          "3687:             if (value >= 0)",
          "3688:             {",
          "3689:                 fromIndex = (int64)min(value, (double)(length - 1));",
          "3690:             }",
          "3691:             else if (value + length < 0)",
          "3692:             {",
          "3693:                 return length;",
          "3694:             }",
          "3695:             else",
          "3696:             {",
          "3697:                 fromIndex = (int64)(value + length);",
          "3698:             }",
          "3699:         }",
          "3701:         return fromIndex;",
          "3702:     }",
          "3710:     template <bool includesAlgorithm>",
          "3711:     Var JavascriptArray::IndexOfHelper(Arguments const & args, ScriptContext *scriptContext)",
          "3712:     {",
          "3713:         JS_REENTRANCY_LOCK(jsReentLock, scriptContext->GetThreadContext());",
          "3715:         RecyclableObject* obj = nullptr;",
          "3716:         JavascriptArray* pArr = nullptr;",
          "3717:         BigIndex length;",
          "3718:         Var trueValue = scriptContext->GetLibrary()->GetTrue();",
          "3719:         Var falseValue = scriptContext->GetLibrary()->GetFalse();",
          "3721:         JS_REENTRANT(jsReentLock, TryGetArrayAndLength(args[0], scriptContext, _u(\"Array.prototype.indexOf\"), &pArr, &obj, &length));",
          "3723:         Var search;",
          "3724:         uint32 fromIndex = 0;",
          "3725:         uint64 fromIndex64 = 0;",
          "3730:         if ((pArr || TypedArrayBase::Is(obj)) && (length.IsSmallIndex() || length.IsUint32Max()))",
          "3731:         {",
          "3732:             uint32 len = length.IsUint32Max() ? MaxArrayLength : length.GetSmallIndex();",
          "3733:             JS_REENTRANT(jsReentLock, BOOL gotParam = GetParamForIndexOf(len, args, search, fromIndex, scriptContext));",
          "3734:             if (!gotParam)",
          "3735:             {",
          "3736:                 return includesAlgorithm ? falseValue : TaggedInt::ToVarUnchecked(-1);",
          "3737:             }",
          "3738:         }",
          "3739:         else if (length.IsSmallIndex())",
          "3740:         {",
          "3741:             JS_REENTRANT(jsReentLock, BOOL gotParam = GetParamForIndexOf(length.GetSmallIndex(), args, search, fromIndex, scriptContext));",
          "3742:             if (!gotParam)",
          "3743:             {",
          "3744:                 return includesAlgorithm ? falseValue : TaggedInt::ToVarUnchecked(-1);",
          "3745:             }",
          "3746:         }",
          "3747:         else",
          "3748:         {",
          "3749:             JS_REENTRANT(jsReentLock, BOOL gotParam = GetParamForIndexOf(length.GetBigIndex(), args, search, fromIndex64, scriptContext));",
          "3750:             if (!gotParam)",
          "3751:             {",
          "3752:                 return includesAlgorithm ? falseValue : TaggedInt::ToVarUnchecked(-1);",
          "3753:             }",
          "3754:         }",
          "3757:         if (pArr && !JavascriptArray::Is(obj))",
          "3758:         {",
          "3759:             AssertOrFailFastMsg(ES5Array::Is(obj), \"The array should have been converted to an ES5Array\");",
          "3760:             pArr = nullptr;",
          "3761:         }",
          "3763:         if (pArr)",
          "3764:         {",
          "3765:             if (length.IsSmallIndex() || length.IsUint32Max())",
          "3766:             {",
          "3767:                 uint32 len = length.IsUint32Max() ? MaxArrayLength : length.GetSmallIndex();",
          "3768:                 int32 index = pArr->HeadSegmentIndexOfHelper(search, fromIndex, len, includesAlgorithm, scriptContext);",
          "3772:                 if (index != -1 || fromIndex == -1)",
          "3773:                 {",
          "3774:                     if (includesAlgorithm)",
          "3775:                     {",
          "3777:                         return (index == -1) ? falseValue : trueValue;",
          "3778:                     }",
          "3779:                     else",
          "3780:                     {",
          "3782:                         return JavascriptNumber::ToVar(index, scriptContext);",
          "3783:                     }",
          "3784:                 }",
          "3787:                 switch (pArr->GetTypeId())",
          "3788:                 {",
          "3789:                 case Js::TypeIds_Array:",
          "3790:                 JS_REENTRANT_UNLOCK(jsReentLock, return TemplatedIndexOfHelper<includesAlgorithm>(pArr, search, fromIndex, len, scriptContext));",
          "3791:                 case Js::TypeIds_NativeIntArray:",
          "3792:                 JS_REENTRANT_UNLOCK(jsReentLock, return TemplatedIndexOfHelper<includesAlgorithm>(JavascriptNativeIntArray::FromVar(pArr), search, fromIndex, len, scriptContext));",
          "3793:                 case Js::TypeIds_NativeFloatArray:",
          "3794:                 JS_REENTRANT_UNLOCK(jsReentLock, return TemplatedIndexOfHelper<includesAlgorithm>(JavascriptNativeFloatArray::FromVar(pArr), search, fromIndex, len, scriptContext));",
          "3795:                 default:",
          "3796:                     AssertMsg(FALSE, \"invalid array typeid\");",
          "3797:                 JS_REENTRANT_UNLOCK(jsReentLock, return TemplatedIndexOfHelper<includesAlgorithm>(pArr, search, fromIndex, len, scriptContext));",
          "3798:                 }",
          "3799:             }",
          "3800:         }",
          "3803:         if (TypedArrayBase::Is(obj))",
          "3804:         {",
          "3805:             if (length.IsSmallIndex() || length.IsUint32Max())",
          "3806:             {",
          "3807:                 JS_REENTRANT_UNLOCK(jsReentLock, return TemplatedIndexOfHelper<includesAlgorithm>(TypedArrayBase::FromVar(obj), search, fromIndex, length.GetSmallIndex(), scriptContext));",
          "3808:             }",
          "3809:         }",
          "3810:         if (length.IsSmallIndex())",
          "3811:         {",
          "3812:             JS_REENTRANT_UNLOCK(jsReentLock, return TemplatedIndexOfHelper<includesAlgorithm>(obj, search, fromIndex, length.GetSmallIndex(), scriptContext));",
          "3813:         }",
          "3814:         else",
          "3815:         {",
          "3816:             JS_REENTRANT_UNLOCK(jsReentLock, return TemplatedIndexOfHelper<includesAlgorithm>(obj, search, fromIndex64, length.GetBigIndex(), scriptContext));",
          "3817:         }",
          "3818:     }",
          "3821:     Var JavascriptArray::EntryIndexOf(RecyclableObject* function, CallInfo callInfo, ...)",
          "3822:     {",
          "3823:         PROBE_STACK(function->GetScriptContext(), Js::Constants::MinStackDefault);",
          "3825:         ARGUMENTS(args, callInfo);",
          "3826:         ScriptContext* scriptContext = function->GetScriptContext();",
          "3827:         JS_REENTRANCY_LOCK(jsReentLock, scriptContext->GetThreadContext());",
          "3829:         Assert(!(callInfo.Flags & CallFlags_New));",
          "3831:         CHAKRATEL_LANGSTATS_INC_BUILTINCOUNT(Array_Prototype_indexOf);",
          "3833:         JS_REENTRANT_UNLOCK(jsReentLock, Var returnValue =  IndexOfHelper<false>(args, scriptContext));",
          "3836:         Assert(returnValue != scriptContext->GetLibrary()->GetTrue() && returnValue != scriptContext->GetLibrary()->GetFalse());",
          "3838:         return returnValue;",
          "3839:     }",
          "3841:     Var JavascriptArray::EntryIncludes(RecyclableObject* function, CallInfo callInfo, ...)",
          "3842:     {",
          "3843:         PROBE_STACK(function->GetScriptContext(), Js::Constants::MinStackDefault);",
          "3845:         ARGUMENTS(args, callInfo);",
          "3846:         ScriptContext* scriptContext = function->GetScriptContext();",
          "3847:         JS_REENTRANCY_LOCK(jsReentLock, scriptContext->GetThreadContext());",
          "3849:         Assert(!(callInfo.Flags & CallFlags_New));",
          "3851:         CHAKRATEL_LANGSTATS_INC_BUILTINCOUNT(Array_Prototype_includes);",
          "3853:         JS_REENTRANT(jsReentLock, Var returnValue = IndexOfHelper<true>(args, scriptContext));",
          "3854:         Assert(returnValue == scriptContext->GetLibrary()->GetTrue() || returnValue == scriptContext->GetLibrary()->GetFalse());",
          "3856:         return returnValue;",
          "3857:     }",
          "3860:     template<typename T>",
          "3861:     BOOL JavascriptArray::GetParamForIndexOf(T length, Arguments const& args, Var& search, T& fromIndex, ScriptContext * scriptContext)",
          "3862:     {",
          "3863:         if (length == 0)",
          "3864:         {",
          "3865:             return false;",
          "3866:         }",
          "3868:         if (args.Info.Count > 2)",
          "3869:         {",
          "3870:             fromIndex = GetFromIndex(args[2], length, scriptContext);",
          "3871:             if (fromIndex >= length)",
          "3872:             {",
          "3873:                 return false;",
          "3874:             }",
          "3875:             search = args[1];",
          "3876:         }",
          "3877:         else",
          "3878:         {",
          "3879:             fromIndex = 0;",
          "3880:             search = args.Info.Count > 1 ? args[1] : scriptContext->GetLibrary()->GetUndefined();",
          "3881:         }",
          "3882:         return true;",
          "3883:     }",
          "3885:     template <>",
          "3886:     BOOL JavascriptArray::TemplatedGetItem(RecyclableObject * obj, uint32 index, Var * element, ScriptContext * scriptContext, bool checkHasItem)",
          "3887:     {",
          "3889:         Assert(!VirtualTableInfo<JavascriptArray>::HasVirtualTable(obj)",
          "3890:             && !VirtualTableInfo<JavascriptNativeIntArray>::HasVirtualTable(obj)",
          "3891:             && !VirtualTableInfo<JavascriptNativeFloatArray>::HasVirtualTable(obj));",
          "3892:         if (checkHasItem && !JavascriptOperators::HasItem(obj, index))",
          "3893:         {",
          "3894:             return FALSE;",
          "3895:         }",
          "3896:         return JavascriptOperators::GetItem(obj, index, element, scriptContext);",
          "3897:     }",
          "3899:     template <>",
          "3900:     BOOL JavascriptArray::TemplatedGetItem(RecyclableObject * obj, uint64 index, Var * element, ScriptContext * scriptContext, bool checkHasItem)",
          "3901:     {",
          "3903:         Assert(!VirtualTableInfo<JavascriptArray>::HasVirtualTable(obj)",
          "3904:             && !VirtualTableInfo<JavascriptNativeIntArray>::HasVirtualTable(obj)",
          "3905:             && !VirtualTableInfo<JavascriptNativeFloatArray>::HasVirtualTable(obj));",
          "3906:         PropertyRecord const * propertyRecord;",
          "3907:         JavascriptOperators::GetPropertyIdForInt(index, scriptContext, &propertyRecord);",
          "3909:         if (checkHasItem && !JavascriptOperators::HasProperty(obj, propertyRecord->GetPropertyId()))",
          "3910:         {",
          "3911:             return FALSE;",
          "3912:         }",
          "3915:         return *element != scriptContext->GetLibrary()->GetUndefined();",
          "3916:     }",
          "3918:     template <>",
          "3919:     BOOL JavascriptArray::TemplatedGetItem(JavascriptArray *pArr, uint32 index, Var * element, ScriptContext * scriptContext, bool checkHasItem)",
          "3920:     {",
          "3921:         Assert(VirtualTableInfo<JavascriptArray>::HasVirtualTable(pArr)",
          "3922:             || VirtualTableInfo<CrossSiteObject<JavascriptArray>>::HasVirtualTable(pArr));",
          "3923:         return pArr->JavascriptArray::DirectGetItemAtFull(index, element);",
          "3924:     }",
          "3925:     template <>",
          "3926:     BOOL JavascriptArray::TemplatedGetItem(JavascriptArray *pArr, uint64 index, Var * element, ScriptContext * scriptContext, bool checkHasItem)",
          "3927:     {",
          "3929:         Assert(false);",
          "3930:         Throw::InternalError();",
          "3931:     }",
          "3933:     template <>",
          "3934:     BOOL JavascriptArray::TemplatedGetItem(JavascriptNativeIntArray *pArr, uint32 index, Var * element, ScriptContext * scriptContext, bool checkHasItem)",
          "3935:     {",
          "3936:         Assert(VirtualTableInfo<JavascriptNativeIntArray>::HasVirtualTable(pArr)",
          "3937:             || VirtualTableInfo<CrossSiteObject<JavascriptNativeIntArray>>::HasVirtualTable(pArr));",
          "3938:         return pArr->JavascriptNativeIntArray::DirectGetItemAtFull(index, element);",
          "3939:     }",
          "3941:     template <>",
          "3942:     BOOL JavascriptArray::TemplatedGetItem(JavascriptNativeIntArray *pArr, uint64 index, Var * element, ScriptContext * scriptContext, bool checkHasItem)",
          "3943:     {",
          "3945:         Assert(false);",
          "3946:         Throw::InternalError();",
          "3947:     }",
          "3949:     template <>",
          "3950:     BOOL JavascriptArray::TemplatedGetItem(JavascriptNativeFloatArray *pArr, uint32 index, Var * element, ScriptContext * scriptContext, bool checkHasItem)",
          "3951:     {",
          "3952:         Assert(VirtualTableInfo<JavascriptNativeFloatArray>::HasVirtualTable(pArr)",
          "3953:             || VirtualTableInfo<CrossSiteObject<JavascriptNativeFloatArray>>::HasVirtualTable(pArr));",
          "3954:         return pArr->JavascriptNativeFloatArray::DirectGetItemAtFull(index, element);",
          "3955:     }",
          "3957:     template <>",
          "3958:     BOOL JavascriptArray::TemplatedGetItem(JavascriptNativeFloatArray *pArr, uint64 index, Var * element, ScriptContext * scriptContext, bool checkHasItem)",
          "3959:     {",
          "3961:         Assert(false);",
          "3962:         Throw::InternalError();",
          "3963:     }",
          "3965:     template <>",
          "3966:     BOOL JavascriptArray::TemplatedGetItem(TypedArrayBase * typedArrayBase, uint32 index, Var * element, ScriptContext * scriptContext, bool checkHasItem)",
          "3967:     {",
          "3972:         if (checkHasItem && !typedArrayBase->HasItem(index))",
          "3973:         {",
          "3974:             return false;",
          "3975:         }",
          "3978:         return true;",
          "3979:     }",
          "3981:     template <>",
          "3982:     BOOL JavascriptArray::TemplatedGetItem(TypedArrayBase * typedArrayBase, uint64 index, Var * element, ScriptContext * scriptContext, bool checkHasItem)",
          "3983:     {",
          "3985:         Assert(false);",
          "3986:         Throw::InternalError();",
          "3987:     }",
          "3989:     template <bool includesAlgorithm, typename T, typename P>",
          "3990:     Var JavascriptArray::TemplatedIndexOfHelper(T * pArr, Var search, P fromIndex, P toIndex, ScriptContext * scriptContext)",
          "3991:     {",
          "3992:         Var element = nullptr;",
          "3993:         bool isSearchTaggedInt = TaggedInt::Is(search);",
          "3994:         bool doUndefinedSearch = includesAlgorithm && JavascriptOperators::GetTypeId(search) == TypeIds_Undefined;",
          "3996:         Var trueValue = scriptContext->GetLibrary()->GetTrue();",
          "3997:         Var falseValue = scriptContext->GetLibrary()->GetFalse();",
          "4000:         for (P i = fromIndex; i < toIndex; i++)",
          "4001:         {",
          "4002:             if (!TryTemplatedGetItem(pArr, i, &element, scriptContext, !includesAlgorithm))",
          "4003:             {",
          "4004:                 if (doUndefinedSearch)",
          "4005:                 {",
          "4006:                     return trueValue;",
          "4007:                 }",
          "4008:                 continue;",
          "4009:             }",
          "4011:             if (isSearchTaggedInt && TaggedInt::Is(element))",
          "4012:             {",
          "4013:                 if (element == search)",
          "4014:                 {",
          "4015:                     return includesAlgorithm? trueValue : JavascriptNumber::ToVar(i, scriptContext);",
          "4016:                 }",
          "4017:                 continue;",
          "4018:             }",
          "4020:             if (includesAlgorithm)",
          "4021:             {",
          "4023:                 if (JavascriptConversion::SameValueZero(element, search))",
          "4024:                 {",
          "4025:                     return trueValue;",
          "4026:                 }",
          "4027:             }",
          "4028:             else",
          "4029:             {",
          "4031:                 if (JavascriptOperators::StrictEqual(element, search, scriptContext))",
          "4032:                 {",
          "4033:                     return JavascriptNumber::ToVar(i, scriptContext);",
          "4034:                 }",
          "4035:             }",
          "4036:         }",
          "4038:         return includesAlgorithm ? falseValue :  TaggedInt::ToVarUnchecked(-1);",
          "4039:     }",
          "4041:     int32 JavascriptArray::HeadSegmentIndexOfHelper(Var search, uint32 &fromIndex, uint32 toIndex, bool includesAlgorithm, ScriptContext * scriptContext)",
          "4042:     {",
          "4043:         Assert(Is(GetTypeId()) && !JavascriptNativeArray::Is(GetTypeId()));",
          "4045:         if (!HasNoMissingValues() || fromIndex >= GetHead()->length)",
          "4046:         {",
          "4047:             return -1;",
          "4048:         }",
          "4050:         bool isSearchTaggedInt = TaggedInt::Is(search);",
          "4054:         SparseArraySegment<Var>* head = static_cast<SparseArraySegment<Var>*>(GetHead());",
          "4055:         uint32 toIndexTrimmed = toIndex <= head->length ? toIndex : head->length;",
          "4056:         for (uint32 i = fromIndex; i < toIndexTrimmed; i++)",
          "4057:         {",
          "4058:             Var element = head->GetElement(i);",
          "4059:             if (isSearchTaggedInt && TaggedInt::Is(element))",
          "4060:             {",
          "4061:                 if (search == element)",
          "4062:                 {",
          "4063:                     return i;",
          "4064:                 }",
          "4065:             }",
          "4066:             else if (includesAlgorithm && JavascriptConversion::SameValueZero(element, search))",
          "4067:             {",
          "4069:                 return i;",
          "4070:             }",
          "4071:             else if (JavascriptOperators::StrictEqual(element, search, scriptContext))",
          "4072:             {",
          "4074:                 return i;",
          "4075:             }",
          "4076:         }",
          "4080:         fromIndex = toIndex > GetHead()->length ? GetHead()->length : -1;",
          "4081:         return -1;",
          "4082:     }",
          "4084:     template<typename T>",
          "4085:     bool AreAllBytesEqual(T value)",
          "4086:     {",
          "4087:         byte* bValue = (byte*)&value;",
          "4088:         byte firstByte = *bValue++;",
          "4089:         for (int i = 1; i < sizeof(T); ++i)",
          "4090:         {",
          "4091:             if (*bValue++ != firstByte)",
          "4092:             {",
          "4093:                 return false;",
          "4094:             }",
          "4095:         }",
          "4096:         return true;",
          "4097:     }",
          "4099:     template<>",
          "4100:     void JavascriptArray::CopyValueToSegmentBuferNoCheck(Field(double)* buffer, uint32 length, double value)",
          "4101:     {",
          "4102:         if (JavascriptNumber::IsZero(value) && !JavascriptNumber::IsNegZero(value))",
          "4103:         {",
          "4104:             memset(buffer, 0, sizeof(double) * length);",
          "4105:         }",
          "4106:         else",
          "4107:         {",
          "4108:             for (uint32 i = 0; i < length; i++)",
          "4109:             {",
          "4110:                 buffer[i] = value;",
          "4111:             }",
          "4112:         }",
          "4113:     }",
          "4115:     template<>",
          "4116:     void JavascriptArray::CopyValueToSegmentBuferNoCheck(Field(int32)* buffer, uint32 length, int32 value)",
          "4117:     {",
          "4118:         if (value == 0 || AreAllBytesEqual(value))",
          "4119:         {",
          "4120:             memset(buffer, *(byte*)&value, sizeof(int32)* length);",
          "4121:         }",
          "4122:         else",
          "4123:         {",
          "4124:             for (uint32 i = 0; i < length; i++)",
          "4125:             {",
          "4126:                 buffer[i] = value;",
          "4127:             }",
          "4128:         }",
          "4129:     }",
          "4131:     template<>",
          "4132:     void JavascriptArray::CopyValueToSegmentBuferNoCheck(Field(Js::Var)* buffer, uint32 length, Js::Var value)",
          "4133:     {",
          "4134:         for (uint32 i = 0; i < length; i++)",
          "4135:         {",
          "4136:             buffer[i] = value;",
          "4137:         }",
          "4138:     }",
          "4140:     int32 JavascriptNativeIntArray::HeadSegmentIndexOfHelper(Var search, uint32 &fromIndex, uint32 toIndex, bool includesAlgorithm,  ScriptContext * scriptContext)",
          "4141:     {",
          "4149:         if (!HasNoMissingValues() || fromIndex >= GetHead()->length)",
          "4150:         {",
          "4151:             return -1;",
          "4152:         }",
          "4154:         bool isSearchTaggedInt = TaggedInt::Is(search);",
          "4155:         if (!isSearchTaggedInt && !JavascriptNumber::Is_NoTaggedIntCheck(search))",
          "4156:         {",
          "4159:             fromIndex = toIndex > GetHead()->length ? GetHead()->length : -1;",
          "4160:             return -1;",
          "4161:         }",
          "4162:         int32 searchAsInt32;",
          "4163:         if (isSearchTaggedInt)",
          "4164:         {",
          "4165:             searchAsInt32 = TaggedInt::ToInt32(search);",
          "4166:         }",
          "4167:         else if (!JavascriptNumber::TryGetInt32Value<true>(JavascriptNumber::GetValue(search), &searchAsInt32))",
          "4168:         {",
          "4171:             fromIndex = toIndex > GetHead()->length ? GetHead()->length : -1;",
          "4172:             return -1;",
          "4173:         }",
          "4179:         SparseArraySegment<int32> * head = static_cast<SparseArraySegment<int32>*>(GetHead());",
          "4180:         uint32 toIndexTrimmed = toIndex <= head->length ? toIndex : head->length;",
          "4181:         for (uint32 i = fromIndex; i < toIndexTrimmed; i++)",
          "4182:         {",
          "4183:             int32 element = head->GetElement(i);",
          "4184:             if (searchAsInt32 == element)",
          "4185:             {",
          "4186:                 return i;",
          "4187:             }",
          "4188:         }",
          "4192:         fromIndex = toIndex > GetHead()->length ? GetHead()->length : -1;",
          "4193:         return -1;",
          "4194:     }",
          "4196:     int32 JavascriptNativeFloatArray::HeadSegmentIndexOfHelper(Var search, uint32 &fromIndex, uint32 toIndex, bool includesAlgorithm, ScriptContext * scriptContext)",
          "4197:     {",
          "4205:         if (!HasNoMissingValues() || fromIndex >= GetHead()->length)",
          "4206:         {",
          "4207:             return -1;",
          "4208:         }",
          "4210:         bool isSearchTaggedInt = TaggedInt::Is(search);",
          "4211:         if (!isSearchTaggedInt && !JavascriptNumber::Is_NoTaggedIntCheck(search))",
          "4212:         {",
          "4215:             fromIndex = toIndex > GetHead()->length ? GetHead()->length : -1;",
          "4216:             return -1;",
          "4217:         }",
          "4219:         double searchAsDouble = isSearchTaggedInt ? TaggedInt::ToDouble(search) : JavascriptNumber::GetValue(search);",
          "4226:         SparseArraySegment<double> * head = static_cast<SparseArraySegment<double>*>(GetHead());",
          "4227:         uint32 toIndexTrimmed = toIndex <= head->length ? toIndex : head->length;",
          "4229:         bool matchNaN = includesAlgorithm && JavascriptNumber::IsNan(searchAsDouble);",
          "4231:         for (uint32 i = fromIndex; i < toIndexTrimmed; i++)",
          "4232:         {",
          "4233:             double element = head->GetElement(i);",
          "4235:             if (element == searchAsDouble)",
          "4236:             {",
          "4237:                 return i;",
          "4238:             }",
          "4241:             if (matchNaN && JavascriptNumber::IsNan(element))",
          "4242:             {",
          "4243:                 return i;",
          "4244:             }",
          "4246:         }",
          "4248:         fromIndex = toIndex > GetHead()->length ? GetHead()->length : -1;",
          "4249:         return -1;",
          "4250:     }",
          "4252:     Var JavascriptArray::EntryJoin(RecyclableObject* function, CallInfo callInfo, ...)",
          "4253:     {",
          "4254:         PROBE_STACK(function->GetScriptContext(), Js::Constants::MinStackDefault);",
          "4256:         ARGUMENTS(args, callInfo);",
          "4257:         ScriptContext* scriptContext = function->GetScriptContext();",
          "4258:         JS_REENTRANCY_LOCK(jsReentLock, scriptContext->GetThreadContext());",
          "4260:         Assert(!(callInfo.Flags & CallFlags_New));",
          "4262:         if (args.Info.Count == 0)",
          "4263:         {",
          "4264:             JavascriptError::ThrowTypeError(scriptContext, JSERR_This_NullOrUndefined, _u(\"Array.prototype.join\"));",
          "4265:         }",
          "4267:         JavascriptString* separator;",
          "4268:         if (args.Info.Count >= 2)",
          "4269:         {",
          "4270:             TypeId typeId = JavascriptOperators::GetTypeId(args[1]);",
          "4272:             if (TypeIds_Undefined != typeId)",
          "4273:             {",
          "4274:                 JS_REENTRANT(jsReentLock, separator = JavascriptConversion::ToString(args[1], scriptContext));",
          "4275:             }",
          "4276:             else",
          "4277:             {",
          "4278:                 separator = scriptContext->GetLibrary()->GetCommaDisplayString();",
          "4279:             }",
          "4280:         }",
          "4281:         else",
          "4282:         {",
          "4283:             separator = scriptContext->GetLibrary()->GetCommaDisplayString();",
          "4284:         }",
          "4286:         JS_REENTRANT_UNLOCK(jsReentLock, return JoinHelper(args[0], separator, scriptContext));",
          "4287:     }",
          "4289:     JavascriptString* JavascriptArray::JoinToString(Var value, ScriptContext* scriptContext)",
          "4290:     {",
          "4291:         TypeId typeId = JavascriptOperators::GetTypeId(value);",
          "4292:         if (typeId == TypeIds_Null || typeId == TypeIds_Undefined)",
          "4293:         {",
          "4294:             return scriptContext->GetLibrary()->GetEmptyString();",
          "4295:         }",
          "4296:         else",
          "4297:         {",
          "4298:             return JavascriptConversion::ToString(value, scriptContext);",
          "4299:         }",
          "4300:     }",
          "4302:     JavascriptString* JavascriptArray::JoinHelper(Var thisArg, JavascriptString* separator, ScriptContext* scriptContext)",
          "4303:     {",
          "4304:         JS_REENTRANCY_LOCK(jsReentLock, scriptContext->GetThreadContext());",
          "4306:         bool isArray = JavascriptArray::Is(thisArg) && (scriptContext == JavascriptArray::FromVar(thisArg)->GetScriptContext());",
          "4307:         bool isProxy = JavascriptProxy::Is(thisArg) && (scriptContext == JavascriptProxy::FromVar(thisArg)->GetScriptContext());",
          "4308:         Var target = NULL;",
          "4309:         bool isTargetObjectPushed = false;",
          "4312:         if (isProxy)",
          "4313:         {",
          "4314:             JavascriptProxy* proxy = JavascriptProxy::FromVar(thisArg);",
          "4315:             Assert(proxy);",
          "4316:             target = proxy->GetTarget();",
          "4317:             if (target != nullptr)",
          "4318:             {",
          "4320:                 if (scriptContext->CheckObject(target))",
          "4321:                 {",
          "4322:                     return scriptContext->GetLibrary()->GetEmptyString();",
          "4323:                 }",
          "4324:                 else",
          "4325:                 {",
          "4326:                     scriptContext->PushObject(target);",
          "4327:                     isTargetObjectPushed = true;",
          "4328:                 }",
          "4329:             }",
          "4330:         }",
          "4332:         else if (scriptContext->CheckObject(thisArg))",
          "4333:         {",
          "4334:             return scriptContext->GetLibrary()->GetEmptyString();",
          "4335:         }",
          "4337:         if (!isTargetObjectPushed)",
          "4338:         {",
          "4339:             scriptContext->PushObject(thisArg);",
          "4340:         }",
          "4342:         JavascriptString* res = nullptr;",
          "4344:         TryFinally([&]()",
          "4345:         {",
          "4346:             if (isArray)",
          "4347:             {",
          "4348: #if ENABLE_COPYONACCESS_ARRAY",
          "4349:                 JavascriptLibrary::CheckAndConvertCopyOnAccessNativeIntArray(thisArg);",
          "4350: #endif",
          "4351:                 JavascriptArray * arr = JavascriptArray::FromVar(thisArg);",
          "4352:                 switch (arr->GetTypeId())",
          "4353:                 {",
          "4354:                 case Js::TypeIds_Array:",
          "4355:                     JS_REENTRANT(jsReentLock, res = JoinArrayHelper(arr, separator, scriptContext));",
          "4356:                     break;",
          "4357:                 case Js::TypeIds_NativeIntArray:",
          "4358:                     JS_REENTRANT(jsReentLock, res = JoinArrayHelper(JavascriptNativeIntArray::FromVar(arr), separator, scriptContext));",
          "4359:                     break;",
          "4360:                 case Js::TypeIds_NativeFloatArray:",
          "4361:                     JS_REENTRANT(jsReentLock, res = JoinArrayHelper(JavascriptNativeFloatArray::FromVar(arr), separator, scriptContext));",
          "4362:                     break;",
          "4363:                 }",
          "4365:             }",
          "4366:             else if (RecyclableObject::Is(thisArg))",
          "4367:             {",
          "4368:                 JS_REENTRANT(jsReentLock, res = JoinOtherHelper(RecyclableObject::FromVar(thisArg), separator, scriptContext));",
          "4369:             }",
          "4370:             else",
          "4371:             {",
          "4372:                 JS_REENTRANT(jsReentLock, res = JoinOtherHelper(scriptContext->GetLibrary()->CreateNumberObject(thisArg), separator, scriptContext));",
          "4373:             }",
          "4374:         },",
          "4375:         [&](bool/*hasException*/)",
          "4376:         {",
          "4377:             Var top = scriptContext->PopObject();",
          "4378:             if (isProxy)",
          "4379:             {",
          "4380:                 AssertMsg(top == target, \"Unmatched operation stack\");",
          "4381:             }",
          "4382:             else",
          "4383:             {",
          "4384:                 AssertMsg(top == thisArg, \"Unmatched operation stack\");",
          "4385:             }",
          "4386:         });",
          "4388:         if (res == nullptr)",
          "4389:         {",
          "4390:             res = scriptContext->GetLibrary()->GetEmptyString();",
          "4391:         }",
          "4393:         return res;",
          "4394:     }",
          "4396:     static const charcount_t Join_MaxEstimatedAppendCount = static_cast<charcount_t>((64 << 20) / sizeof(void *)); // 64 MB worth of pointers",
          "4398:     template <typename T>",
          "4399:     JavascriptString* JavascriptArray::JoinArrayHelper(T * arr, JavascriptString* separator, ScriptContext* scriptContext)",
          "4400:     {",
          "4401:         JS_REENTRANCY_LOCK(jsReentLock, scriptContext->GetThreadContext());",
          "4403:         Assert(VirtualTableInfo<T>::HasVirtualTable(arr) || VirtualTableInfo<CrossSiteObject<T>>::HasVirtualTable(arr));",
          "4404:         const uint32 arrLength = arr->length;",
          "4405:         switch(arrLength)",
          "4406:         {",
          "4407:             default:",
          "4408:             {",
          "4409: CaseDefault:",
          "4410:                 bool hasSeparator = (separator->GetLength() != 0);",
          "4411:                 const charcount_t estimatedAppendCount =",
          "4412:                     min(",
          "4413:                         Join_MaxEstimatedAppendCount,",
          "4414:                         static_cast<charcount_t>(arrLength + (hasSeparator ? arrLength - 1 : 0)));",
          "4415:                 CompoundString *const cs =",
          "4416:                     CompoundString::NewWithPointerCapacity(estimatedAppendCount, scriptContext->GetLibrary());",
          "4417:                 Var item;",
          "4418:                 BOOL gotItem;",
          "4419:                 JS_REENTRANT(jsReentLock, gotItem = TemplatedGetItem(arr, 0u, &item, scriptContext));",
          "4420:                 if (gotItem)",
          "4421:                 {",
          "4422:                     JS_REENTRANT(jsReentLock, cs->Append(JavascriptArray::JoinToString(item, scriptContext)));",
          "4423:                 }",
          "4425:                 for (uint32 i = 1; i < arrLength; i++)",
          "4426:                 {",
          "4427:                     if (hasSeparator)",
          "4428:                     {",
          "4429:                         cs->Append(separator);",
          "4430:                     }",
          "4432:                     JS_REENTRANT(jsReentLock, gotItem = TryTemplatedGetItem(arr, i, &item, scriptContext));",
          "4433:                     if (gotItem)",
          "4434:                     {",
          "4435:                         JS_REENTRANT(jsReentLock, cs->Append(JavascriptArray::JoinToString(item, scriptContext)));",
          "4436:                     }",
          "4437:                 }",
          "4438:                 return cs;",
          "4439:             }",
          "4441:             case 2:",
          "4442:             {",
          "4443:                 bool hasSeparator = (separator->GetLength() != 0);",
          "4444:                 BOOL gotItem;",
          "4445:                 if(hasSeparator)",
          "4446:                 {",
          "4447:                     goto CaseDefault;",
          "4448:                 }",
          "4450:                 JavascriptString *res = nullptr;",
          "4451:                 Var item;",
          "4453:                 JS_REENTRANT(jsReentLock, gotItem = TemplatedGetItem(arr, 0u, &item, scriptContext));",
          "4454:                 if (gotItem)",
          "4455:                 {",
          "4456:                     JS_REENTRANT(jsReentLock, res = JavascriptArray::JoinToString(item, scriptContext));",
          "4457:                 }",
          "4458:                 JS_REENTRANT(jsReentLock, gotItem = TryTemplatedGetItem(arr, 1u, &item, scriptContext));",
          "4459:                 if (gotItem)",
          "4460:                 {",
          "4461:                     JS_REENTRANT(jsReentLock, JavascriptString *const itemString = JavascriptArray::JoinToString(item, scriptContext));",
          "4462:                     return res ? ConcatString::New(res, itemString) : itemString;",
          "4463:                 }",
          "4465:                 if(res)",
          "4466:                 {",
          "4467:                     return res;",
          "4468:                 }",
          "4470:                 goto Case0;",
          "4471:             }",
          "4473:             case 1:",
          "4474:             {",
          "4475:                 Var item;",
          "4476:                 BOOL gotItem;",
          "4477:                 JS_REENTRANT(jsReentLock, gotItem = TemplatedGetItem(arr, 0u, &item, scriptContext));",
          "4478:                 if (gotItem)",
          "4479:                 {",
          "4480:                     JS_REENTRANT_UNLOCK(jsReentLock, return JavascriptArray::JoinToString(item, scriptContext));",
          "4481:                 }",
          "4483:             }",
          "4485:             case 0:",
          "4486: Case0:",
          "4487:                 return scriptContext->GetLibrary()->GetEmptyString();",
          "4488:         }",
          "4489:     }",
          "4491:     JavascriptString* JavascriptArray::JoinOtherHelper(RecyclableObject* object, JavascriptString* separator, ScriptContext* scriptContext)",
          "4492:     {",
          "4493:         JS_REENTRANCY_LOCK(jsReentLock, scriptContext->GetThreadContext());",
          "4498:         JS_REENTRANT(jsReentLock,",
          "4499:             int64 cSrcLength = (int64)OP_GetLength(object, scriptContext));",
          "4501:         switch (cSrcLength)",
          "4502:         {",
          "4503:             default:",
          "4504:             {",
          "4505: CaseDefault:",
          "4506:                 bool hasSeparator = (separator->GetLength() != 0);",
          "4507:                 BOOL gotItem;",
          "4508:                 const charcount_t estimatedAppendCount =",
          "4509:                     min(",
          "4510:                         Join_MaxEstimatedAppendCount,",
          "4511:                         static_cast<charcount_t>(cSrcLength + (hasSeparator ? cSrcLength - 1 : 0)));",
          "4512:                 CompoundString *const cs =",
          "4513:                     CompoundString::NewWithPointerCapacity(estimatedAppendCount, scriptContext->GetLibrary());",
          "4514:                 Var value;",
          "4515:                 JS_REENTRANT(jsReentLock, gotItem = JavascriptOperators::GetItem(object, 0u, &value, scriptContext));",
          "4516:                 if (gotItem)",
          "4517:                 {",
          "4518:                     JS_REENTRANT(jsReentLock, cs->Append(JavascriptArray::JoinToString(value, scriptContext)));",
          "4519:                 }",
          "4520:                 for (uint32 i = 1; i < cSrcLength; i++)",
          "4521:                 {",
          "4522:                     if (hasSeparator)",
          "4523:                     {",
          "4524:                         cs->Append(separator);",
          "4525:                     }",
          "4526:                     JS_REENTRANT(jsReentLock, gotItem = JavascriptOperators::GetItem(object, i, &value, scriptContext));",
          "4527:                     if (gotItem)",
          "4528:                     {",
          "4529:                         JS_REENTRANT(jsReentLock, cs->Append(JavascriptArray::JoinToString(value, scriptContext)));",
          "4530:                     }",
          "4531:                 }",
          "4532:                 return cs;",
          "4533:             }",
          "4535:             case 2:",
          "4536:             {",
          "4537:                 bool hasSeparator = (separator->GetLength() != 0);",
          "4538:                 BOOL gotItem;",
          "4539:                 if(hasSeparator)",
          "4540:                 {",
          "4541:                     goto CaseDefault;",
          "4542:                 }",
          "4544:                 JavascriptString *res = nullptr;",
          "4545:                 Var value;",
          "4546:                 JS_REENTRANT(jsReentLock, gotItem = JavascriptOperators::GetItem(object, 0u, &value, scriptContext));",
          "4547:                 if (gotItem)",
          "4548:                 {",
          "4549:                     JS_REENTRANT(jsReentLock, res = JavascriptArray::JoinToString(value, scriptContext));",
          "4550:                 }",
          "4551:                 JS_REENTRANT(jsReentLock, gotItem = JavascriptOperators::GetItem(object, 1u, &value, scriptContext));",
          "4552:                 if (gotItem)",
          "4553:                 {",
          "4554:                     JS_REENTRANT(jsReentLock, JavascriptString *const valueString = JavascriptArray::JoinToString(value, scriptContext));",
          "4555:                     return res ? ConcatString::New(res, valueString) : valueString;",
          "4556:                 }",
          "4557:                 if(res)",
          "4558:                 {",
          "4559:                     return res;",
          "4560:                 }",
          "4561:                 goto Case0;",
          "4562:             }",
          "4564:             case 1:",
          "4565:             {",
          "4566:                 Var value;",
          "4567:                 JS_REENTRANT(jsReentLock, BOOL gotItem = JavascriptOperators::GetItem(object, 0u, &value, scriptContext));",
          "4568:                 if (gotItem)",
          "4569:                 {",
          "4570:                     JS_REENTRANT_UNLOCK(jsReentLock, return JavascriptArray::JoinToString(value, scriptContext));",
          "4571:                 }",
          "4573:             }",
          "4575:             case 0:",
          "4576: Case0:",
          "4577:                 return scriptContext->GetLibrary()->GetEmptyString();",
          "4578:         }",
          "4579:     }",
          "4581:     Var JavascriptArray::EntryLastIndexOf(RecyclableObject* function, CallInfo callInfo, ...)",
          "4582:     {",
          "4583:         PROBE_STACK(function->GetScriptContext(), Js::Constants::MinStackDefault);",
          "4585:         ARGUMENTS(args, callInfo);",
          "4586:         ScriptContext* scriptContext = function->GetScriptContext();",
          "4587:         JS_REENTRANCY_LOCK(jsReentLock, scriptContext->GetThreadContext());",
          "4589:         CHAKRATEL_LANGSTATS_INC_BUILTINCOUNT(Array_Prototype_lastIndexOf);",
          "4591:         Assert(!(callInfo.Flags & CallFlags_New));",
          "4593:         int64 length;",
          "4594:         JavascriptArray * pArr = nullptr;",
          "4595:         RecyclableObject* obj = nullptr;",
          "4597:         JS_REENTRANT(jsReentLock, TryGetArrayAndLength(args[0], scriptContext, _u(\"Array.prototype.lastIndexOf\"), &pArr, &obj, &length));",
          "4599:         Var search;",
          "4600:         int64 fromIndex;",
          "4601:         JS_REENTRANT(jsReentLock,",
          "4602:             BOOL gotParam = GetParamForLastIndexOf(length, args, search, fromIndex, scriptContext));",
          "4603:         if (!gotParam)",
          "4604:         {",
          "4605:             return TaggedInt::ToVarUnchecked(-1);",
          "4606:         }",
          "4609:         if (pArr && !JavascriptArray::Is(obj))",
          "4610:         {",
          "4611:             AssertOrFailFastMsg(ES5Array::Is(obj), \"The array should have been converted to an ES5Array\");",
          "4612:             pArr = nullptr;",
          "4613:         }",
          "4615:         if (pArr)",
          "4616:         {",
          "4617:             switch (pArr->GetTypeId())",
          "4618:             {",
          "4619:             case Js::TypeIds_Array:",
          "4620:                 JS_REENTRANT_UNLOCK(jsReentLock, return LastIndexOfHelper(pArr, search, fromIndex, scriptContext));",
          "4621:             case Js::TypeIds_NativeIntArray:",
          "4622:                 JS_REENTRANT_UNLOCK(jsReentLock, return LastIndexOfHelper(JavascriptNativeIntArray::FromVar(pArr), search, fromIndex, scriptContext));",
          "4623:             case Js::TypeIds_NativeFloatArray:",
          "4624:                 JS_REENTRANT_UNLOCK(jsReentLock, return LastIndexOfHelper(JavascriptNativeFloatArray::FromVar(pArr), search, fromIndex, scriptContext));",
          "4625:             default:",
          "4626:                 AssertMsg(FALSE, \"invalid array typeid\");",
          "4627:                 JS_REENTRANT_UNLOCK(jsReentLock, return LastIndexOfHelper(pArr, search, fromIndex, scriptContext));",
          "4628:             }",
          "4629:         }",
          "4632:         if (TypedArrayBase::Is(obj))",
          "4633:         {",
          "4634:             JS_REENTRANT_UNLOCK(jsReentLock, return LastIndexOfHelper(TypedArrayBase::FromVar(obj), search, fromIndex, scriptContext));",
          "4635:         }",
          "4637:         JS_REENTRANT_UNLOCK(jsReentLock, return LastIndexOfHelper(obj, search, fromIndex, scriptContext));",
          "4638:     }",
          "4641:     BOOL JavascriptArray::GetParamForLastIndexOf(int64 length, Arguments const & args, Var& search, int64& fromIndex, ScriptContext * scriptContext)",
          "4642:     {",
          "4643:         if (length == 0)",
          "4644:         {",
          "4645:             return false;",
          "4646:         }",
          "4648:         if (args.Info.Count > 2)",
          "4649:         {",
          "4650:             fromIndex = GetFromLastIndex(args[2], length, scriptContext);",
          "4652:             if (fromIndex >= length)",
          "4653:             {",
          "4654:                 return false;",
          "4655:             }",
          "4656:             search = args[1];",
          "4657:         }",
          "4658:         else",
          "4659:         {",
          "4660:             search = args.Info.Count > 1 ? args[1] : scriptContext->GetLibrary()->GetUndefined();",
          "4661:             fromIndex = length - 1;",
          "4662:         }",
          "4663:         return true;",
          "4664:     }",
          "4666:     template <typename T>",
          "4667:     Var JavascriptArray::LastIndexOfHelper(T* pArr, Var search, int64 fromIndex, ScriptContext * scriptContext)",
          "4668:     {",
          "4669:         Var element = nullptr;",
          "4670:         bool isSearchTaggedInt = TaggedInt::Is(search);",
          "4673:         while (fromIndex >= MaxArrayLength)",
          "4674:         {",
          "4675:             Var index = JavascriptNumber::ToVar(fromIndex, scriptContext);",
          "4677:             if (JavascriptOperators::OP_HasItem(pArr, index, scriptContext))",
          "4678:             {",
          "4679:                 element = JavascriptOperators::OP_GetElementI(pArr, index, scriptContext);",
          "4681:                 if (isSearchTaggedInt && TaggedInt::Is(element))",
          "4682:                 {",
          "4683:                     if (element == search)",
          "4684:                     {",
          "4685:                         return index;",
          "4686:                     }",
          "4687:                     fromIndex--;",
          "4688:                     continue;",
          "4689:                 }",
          "4691:                 if (JavascriptOperators::StrictEqual(element, search, scriptContext))",
          "4692:                 {",
          "4693:                     return index;",
          "4694:                 }",
          "4695:             }",
          "4697:             fromIndex--;",
          "4698:         }",
          "4700:         Assert(fromIndex < MaxArrayLength);",
          "4703:         uint32 end = static_cast<uint32>(fromIndex);",
          "4705:         for (uint32 i = 0; i <= end; i++)",
          "4706:         {",
          "4707:             uint32 index = end - i;",
          "4709:             if (!TryTemplatedGetItem(pArr, index, &element, scriptContext))",
          "4710:             {",
          "4711:                 continue;",
          "4712:             }",
          "4714:             if (isSearchTaggedInt && TaggedInt::Is(element))",
          "4715:             {",
          "4716:                 if (element == search)",
          "4717:                 {",
          "4718:                     return JavascriptNumber::ToVar(index, scriptContext);",
          "4719:                 }",
          "4720:                 continue;",
          "4721:             }",
          "4723:             if (JavascriptOperators::StrictEqual(element, search, scriptContext))",
          "4724:             {",
          "4725:                 return JavascriptNumber::ToVar(index, scriptContext);",
          "4726:             }",
          "4727:         }",
          "4729:         return TaggedInt::ToVarUnchecked(-1);",
          "4730:     }",
          "4736:     void JavascriptNativeArray::PopWithNoDst(Var nativeArray)",
          "4737:     {",
          "4738:         Assert(JavascriptNativeArray::Is(nativeArray));",
          "4739:         JavascriptArray * arr = JavascriptArray::FromVar(nativeArray);",
          "4742:         Assert(arr->GetLength() != 0);",
          "4744:         uint32 index = arr->GetLength() - 1;",
          "4745:         arr->SetLength(index);",
          "4746:     }",
          "4756:     int32 JavascriptNativeIntArray::Pop(ScriptContext * scriptContext, Var object)",
          "4757:     {",
          "4758:         Assert(JavascriptNativeIntArray::Is(object));",
          "4759:         JavascriptNativeIntArray * arr = JavascriptNativeIntArray::FromVar(object);",
          "4761:         Assert(arr->GetLength() != 0);",
          "4763:         uint32 index = arr->length - 1;",
          "4765:         int32 element = Js::JavascriptOperators::OP_GetNativeIntElementI_UInt32(object, index, scriptContext);",
          "4768:         if(!SparseArraySegment<int32>::IsMissingItem(&element))",
          "4769:         {",
          "4770:             arr->SetLength(index);",
          "4771:         }",
          "4772:         return element;",
          "4773:     }",
          "4783:     double JavascriptNativeFloatArray::Pop(ScriptContext * scriptContext, Var object)",
          "4784:     {",
          "4785:         Assert(JavascriptNativeFloatArray::Is(object));",
          "4786:         JavascriptNativeFloatArray * arr = JavascriptNativeFloatArray::FromVar(object);",
          "4788:         Assert(arr->GetLength() != 0);",
          "4790:         uint32 index = arr->length - 1;",
          "4792:         double element = Js::JavascriptOperators::OP_GetNativeFloatElementI_UInt32(object, index, scriptContext);",
          "4795:         if(!SparseArraySegment<double>::IsMissingItem(&element))",
          "4796:         {",
          "4797:             arr->SetLength(index);",
          "4798:         }",
          "4799:         return element;",
          "4800:     }",
          "4807:     Var JavascriptArray::Pop(ScriptContext * scriptContext, Var object)",
          "4808:     {",
          "4809:         if (JavascriptArray::Is(object))",
          "4810:         {",
          "4811:             return EntryPopJavascriptArray(scriptContext, object);",
          "4812:         }",
          "4813:         else",
          "4814:         {",
          "4815:             return EntryPopNonJavascriptArray(scriptContext, object);",
          "4816:         }",
          "4817:     }",
          "4819:     Var JavascriptArray::EntryPopJavascriptArray(ScriptContext * scriptContext, Var object)",
          "4820:     {",
          "4821:         JS_REENTRANCY_LOCK(jsReentLock, scriptContext->GetThreadContext());",
          "4822:         JavascriptArray * arr = JavascriptArray::FromVar(object);",
          "4823:         uint32 length = arr->length;",
          "4825:         if (length == 0)",
          "4826:         {",
          "4828:             return scriptContext->GetLibrary()->GetUndefined();",
          "4829:         }",
          "4831:         uint32 index = length - 1;",
          "4832:         Var element;",
          "4833:         JS_REENTRANT(jsReentLock, BOOL gotItem = arr->DirectGetItemAtFull(index, &element));",
          "4835:         if (!gotItem)",
          "4836:         {",
          "4837:             element = scriptContext->GetLibrary()->GetUndefined();",
          "4838:         }",
          "4839:         else",
          "4840:         {",
          "4841:             element = CrossSite::MarshalVar(scriptContext, element);",
          "4842:         }",
          "4843:         arr->SetLength(index); // SetLength will clear element at index",
          "4845: #ifdef VALIDATE_ARRAY",
          "4846:         arr->ValidateArray();",
          "4847: #endif",
          "4848:         return element;",
          "4849:     }",
          "4851:     Var JavascriptArray::EntryPopNonJavascriptArray(ScriptContext * scriptContext, Var object)",
          "4852:     {",
          "4853:         JS_REENTRANCY_LOCK(jsReentLock, scriptContext->GetThreadContext());",
          "4854:         RecyclableObject* dynamicObject = nullptr;",
          "4855:         if (FALSE == JavascriptConversion::ToObject(object, scriptContext, &dynamicObject))",
          "4856:         {",
          "4857:             JavascriptError::ThrowTypeError(scriptContext, JSERR_This_NullOrUndefined, _u(\"Array.prototype.pop\"));",
          "4858:         }",
          "4859:         JS_REENTRANT(jsReentLock, BigIndex length = OP_GetLength(dynamicObject, scriptContext));",
          "4861:         ThrowTypeErrorOnFailureHelper h(scriptContext, _u(\"Array.prototype.pop\"));",
          "4862:         if (length == 0u)",
          "4863:         {",
          "4865:             JS_REENTRANT(jsReentLock,",
          "4866:                 h.ThrowTypeErrorOnFailure(JavascriptOperators::SetProperty(dynamicObject, dynamicObject, PropertyIds::length, TaggedInt::ToVarUnchecked(0), scriptContext, PropertyOperation_ThrowIfNotExtensible)));",
          "4867:             return scriptContext->GetLibrary()->GetUndefined();",
          "4868:         }",
          "4869:         BigIndex index = length;",
          "4870:         --index;",
          "4871:         Var element;",
          "4872:         if (index.IsSmallIndex())",
          "4873:         {",
          "4874:             JS_REENTRANT(jsReentLock, BOOL gotItem = JavascriptOperators::GetItem(dynamicObject, index.GetSmallIndex(), &element, scriptContext));",
          "4875:             if (!gotItem)",
          "4876:             {",
          "4877:                 element = scriptContext->GetLibrary()->GetUndefined();",
          "4878:             }",
          "4879:             JS_REENTRANT(jsReentLock,",
          "4880:                 h.ThrowTypeErrorOnFailure(JavascriptOperators::DeleteItem(dynamicObject, index.GetSmallIndex(), PropertyOperation_ThrowOnDeleteIfNotConfig)),",
          "4882:                 h.ThrowTypeErrorOnFailure(JavascriptOperators::SetProperty(dynamicObject, dynamicObject, PropertyIds::length, JavascriptNumber::ToVar(index.GetSmallIndex(), scriptContext), scriptContext, PropertyOperation_ThrowIfNotExtensible)));",
          "4883:         }",
          "4884:         else",
          "4885:         {",
          "4886:             JS_REENTRANT(jsReentLock, BOOL gotItem = JavascriptOperators::GetItem(dynamicObject, index.GetBigIndex(), &element, scriptContext));",
          "4887:             if (!gotItem)",
          "4888:             {",
          "4889:                 element = scriptContext->GetLibrary()->GetUndefined();",
          "4890:             }",
          "4891:             JS_REENTRANT(jsReentLock, h.ThrowTypeErrorOnFailure(JavascriptOperators::DeleteItem(dynamicObject, index.GetBigIndex(), PropertyOperation_ThrowOnDeleteIfNotConfig)),",
          "4893:                 h.ThrowTypeErrorOnFailure(JavascriptOperators::SetProperty(dynamicObject, dynamicObject, PropertyIds::length, JavascriptNumber::ToVar(index.GetBigIndex(), scriptContext), scriptContext, PropertyOperation_ThrowIfNotExtensible)));",
          "4894:         }",
          "4895:         return element;",
          "4896:     }",
          "4898:     Var JavascriptArray::EntryPop(RecyclableObject* function, CallInfo callInfo, ...)",
          "4899:     {",
          "4900:         PROBE_STACK(function->GetScriptContext(), Js::Constants::MinStackDefault);",
          "4902:         ARGUMENTS(args, callInfo);",
          "4903:         ScriptContext* scriptContext = function->GetScriptContext();",
          "4904:         JS_REENTRANCY_LOCK(jsReentLock, scriptContext->GetThreadContext());",
          "4906:         Assert(!(callInfo.Flags & CallFlags_New));",
          "4908:         if (args.Info.Count == 0)",
          "4909:         {",
          "4910:             JavascriptError::ThrowTypeError(scriptContext, JSERR_This_NullOrUndefined, _u(\"Array.prototype.pop\"));",
          "4911:         }",
          "4913:         if (JavascriptArray::Is(args[0]))",
          "4914:         {",
          "4915:             JS_REENTRANT_UNLOCK(jsReentLock, return EntryPopJavascriptArray(scriptContext, args.Values[0]));",
          "4916:         }",
          "4917:         else",
          "4918:         {",
          "4920:             JS_REENTRANT_UNLOCK(jsReentLock, return EntryPopNonJavascriptArray(scriptContext, args.Values[0]));",
          "4921:         }",
          "4922:     }",
          "4929:     Var JavascriptNativeIntArray::Push(ScriptContext * scriptContext, Var array, int value)",
          "4930:     {",
          "4933:         if (JavascriptNativeIntArray::IsNonCrossSite(array))",
          "4934:         {",
          "4935:             JavascriptNativeIntArray * nativeIntArray = JavascriptNativeIntArray::FromVar(array);",
          "4936:             Assert(!nativeIntArray->IsCrossSiteObject());",
          "4937:             uint32 n = nativeIntArray->length;",
          "4939:             if(n < JavascriptArray::MaxArrayLength)",
          "4940:             {",
          "4941:                 nativeIntArray->SetItem(n, value);",
          "4943:                 n++;",
          "4945:                 AssertMsg(n == nativeIntArray->length, \"Wrong update to the length of the native Int array\");",
          "4947:                 return JavascriptNumber::ToVar(n, scriptContext);",
          "4948:             }",
          "4949:         }",
          "4950:         return JavascriptArray::Push(scriptContext, array, JavascriptNumber::ToVar(value, scriptContext));",
          "4951:     }",
          "4958:     Var JavascriptNativeFloatArray::Push(ScriptContext * scriptContext, Var * array, double value)",
          "4959:     {",
          "4962:         if(JavascriptNativeFloatArray::IsNonCrossSite(array))",
          "4963:         {",
          "4964:             JavascriptNativeFloatArray * nativeFloatArray = JavascriptNativeFloatArray::FromVar(array);",
          "4965:             Assert(!nativeFloatArray->IsCrossSiteObject());",
          "4966:             uint32 n = nativeFloatArray->length;",
          "4968:             if(n < JavascriptArray::MaxArrayLength)",
          "4969:             {",
          "4970:                 nativeFloatArray->SetItem(n, value);",
          "4972:                 n++;",
          "4974:                 AssertMsg(n == nativeFloatArray->length, \"Wrong update to the length of the native Float array\");",
          "4975:                 return JavascriptNumber::ToVar(n, scriptContext);",
          "4976:             }",
          "4977:         }",
          "4979:         return JavascriptArray::Push(scriptContext, array, JavascriptNumber::ToVarNoCheck(value, scriptContext));",
          "4980:     }",
          "4986:     Var JavascriptArray::Push(ScriptContext * scriptContext, Var object, Var value)",
          "4987:     {",
          "4988:         Var args[2];",
          "4989:         args[0] = object;",
          "4990:         args[1] = value;",
          "4992:         if (JavascriptArray::Is(object))",
          "4993:         {",
          "4994:             return EntryPushJavascriptArray(scriptContext, args, 2);",
          "4995:         }",
          "4996:         else",
          "4997:         {",
          "4998:             return EntryPushNonJavascriptArray(scriptContext, args, 2);",
          "4999:         }",
          "5001:     }",
          "5007:     Var JavascriptArray::EntryPushNonJavascriptArray(ScriptContext * scriptContext, Var * args, uint argCount)",
          "5008:     {",
          "5009:         JS_REENTRANCY_LOCK(jsReentLock, scriptContext->GetThreadContext());",
          "5011:         RecyclableObject* obj = nullptr;",
          "5012:         if (FALSE == JavascriptConversion::ToObject(args[0], scriptContext, &obj))",
          "5013:         {",
          "5014:             JavascriptError::ThrowTypeError(scriptContext, JSERR_This_NullOrUndefined, _u(\"Array.prototype.push\"));",
          "5015:         }",
          "5017:         JS_REENTRANT_UNLOCK(jsReentLock, Var length = JavascriptOperators::OP_GetLength(obj, scriptContext));",
          "5018:         if(JavascriptOperators::GetTypeId(length) == TypeIds_Undefined && scriptContext->GetThreadContext()->IsDisableImplicitCall() &&",
          "5019:             scriptContext->GetThreadContext()->GetImplicitCallFlags() != Js::ImplicitCall_None)",
          "5020:         {",
          "5021:             return length;",
          "5022:         }",
          "5024:         ThrowTypeErrorOnFailureHelper h(scriptContext, _u(\"Array.prototype.push\"));",
          "5025:         BigIndex n;",
          "5026:         if (scriptContext->GetConfig()->IsES6ToLengthEnabled())",
          "5027:         {",
          "5028:             n = (uint64) JavascriptConversion::ToLength(length, scriptContext);",
          "5029:         }",
          "5030:         else",
          "5031:         {",
          "5032:             n = JavascriptConversion::ToUInt32(length, scriptContext);",
          "5033:         }",
          "5035:         uint index;",
          "5036:         for (index=1; index < argCount && n < JavascriptArray::MaxArrayLength; ++index, ++n)",
          "5037:         {",
          "5038:             JS_REENTRANT(jsReentLock,",
          "5039:                 BOOL setItem = JavascriptOperators::SetItem(obj, obj, n.GetSmallIndex(), args[index], scriptContext, PropertyOperation_ThrowIfNotExtensible));",
          "5040:             if (h.IsThrowTypeError(setItem))",
          "5041:             {",
          "5042:                 if (scriptContext->GetThreadContext()->RecordImplicitException())",
          "5043:                 {",
          "5044:                     h.ThrowTypeErrorOnFailure();",
          "5045:                 }",
          "5046:                 else",
          "5047:                 {",
          "5048:                     return nullptr;",
          "5049:                 }",
          "5050:             }",
          "5051:         }",
          "5054:         if (index < argCount)",
          "5055:         {",
          "5056:             BigIndex big = n;",
          "5058:             for (; index < argCount; ++index, ++big)",
          "5059:             {",
          "5060:                 JS_REENTRANT(jsReentLock, BOOL setItem = big.SetItem(obj, args[index], PropertyOperation_ThrowIfNotExtensible));",
          "5061:                 if (h.IsThrowTypeError(setItem))",
          "5062:                 {",
          "5063:                     if(scriptContext->GetThreadContext()->RecordImplicitException())",
          "5064:                     {",
          "5065:                         h.ThrowTypeErrorOnFailure();",
          "5066:                     }",
          "5067:                     else",
          "5068:                     {",
          "5069:                         return nullptr;",
          "5070:                     }",
          "5071:                 }",
          "5073:             }",
          "5076:             JS_REENTRANT(jsReentLock,",
          "5077:                 BOOL setLength = JavascriptOperators::SetProperty(obj, obj, PropertyIds::length, big.ToNumber(scriptContext), scriptContext, PropertyOperation_ThrowIfNotExtensible));",
          "5078:             if (h.IsThrowTypeError(setLength))",
          "5079:             {",
          "5080:                 if(scriptContext->GetThreadContext()->RecordImplicitException())",
          "5081:                 {",
          "5082:                     h.ThrowTypeErrorOnFailure();",
          "5083:                 }",
          "5084:                 else",
          "5085:                 {",
          "5086:                     return nullptr;",
          "5087:                 }",
          "5088:             }",
          "5090:             return big.ToNumber(scriptContext);",
          "5091:         }",
          "5092:         else",
          "5093:         {",
          "5095:             Var lengthAsNUmberVar = JavascriptNumber::ToVar(n.IsSmallIndex() ? n.GetSmallIndex() : n.GetBigIndex(), scriptContext);",
          "5096:             JS_REENTRANT(jsReentLock,",
          "5097:                 BOOL setLength = JavascriptOperators::SetProperty(obj, obj, PropertyIds::length, lengthAsNUmberVar, scriptContext, PropertyOperation_ThrowIfNotExtensible));",
          "5098:             if (h.IsThrowTypeError(setLength))",
          "5099:             {",
          "5100:                 if(scriptContext->GetThreadContext()->RecordImplicitException())",
          "5101:                 {",
          "5102:                     h.ThrowTypeErrorOnFailure();",
          "5103:                 }",
          "5104:                 else",
          "5105:                 {",
          "5106:                     return nullptr;",
          "5107:                 }",
          "5108:             }",
          "5110:             return lengthAsNUmberVar;",
          "5111:         }",
          "5112:     }",
          "5119:     Var JavascriptArray::EntryPushJavascriptArray(ScriptContext * scriptContext, Var * args, uint argCount)",
          "5120:     {",
          "5121:         JavascriptArray * arr = JavascriptArray::FromAnyArray(args[0]);",
          "5122:         uint n = arr->length;",
          "5123:         ThrowTypeErrorOnFailureHelper h(scriptContext, _u(\"Array.prototype.push\"));",
          "5126:         if (argCount == 2 && n < JavascriptArray::MaxArrayLength)",
          "5127:         {",
          "5129:             h.ThrowTypeErrorOnFailure(arr->SetItem(n, args[1], PropertyOperation_None));",
          "5130:             return JavascriptNumber::ToVar(n + 1, scriptContext);",
          "5131:         }",
          "5134:         if (JavascriptArray::MaxArrayLength - argCount + 1 > n && JavascriptArray::IsVarArray(arr) && scriptContext == arr->GetScriptContext())",
          "5135:         {",
          "5136:             uint index;",
          "5137:             for (index = 1; index < argCount; ++index, ++n)",
          "5138:             {",
          "5139:                 Assert(n != JavascriptArray::MaxArrayLength);",
          "5141:                 arr->JavascriptArray::DirectSetItemAt(n, args[index]);",
          "5142:             }",
          "5143:             return JavascriptNumber::ToVar(n, scriptContext);",
          "5144:         }",
          "5146:         return EntryPushJavascriptArrayNoFastPath(scriptContext, args, argCount);",
          "5147:     }",
          "5149:     Var JavascriptArray::EntryPushJavascriptArrayNoFastPath(ScriptContext * scriptContext, Var * args, uint argCount)",
          "5150:     {",
          "5151:         JS_REENTRANCY_LOCK(jsReentLock, scriptContext->GetThreadContext());",
          "5152:         JavascriptArray * arr = JavascriptArray::FromAnyArray(args[0]);",
          "5153:         uint n = arr->length;",
          "5154:         ThrowTypeErrorOnFailureHelper h(scriptContext, _u(\"Array.prototype.push\"));",
          "5157:         uint index;",
          "5158:         for (index = 1; index < argCount && n < JavascriptArray::MaxArrayLength; ++index, ++n)",
          "5159:         {",
          "5161:             h.ThrowTypeErrorOnFailure(arr->SetItem(n, args[index], PropertyOperation_None));",
          "5162:         }",
          "5165:         if (index < argCount)",
          "5166:         {",
          "5168:             arr = EnsureNonNativeArray(arr);",
          "5169:             Assert(n == JavascriptArray::MaxArrayLength);",
          "5170:             for (BigIndex big = n; index < argCount; ++index, ++big)",
          "5171:             {",
          "5172:                 JS_REENTRANT(jsReentLock, h.ThrowTypeErrorOnFailure(big.SetItem(arr, args[index])));",
          "5173:             }",
          "5175: #ifdef VALIDATE_ARRAY",
          "5176:             arr->ValidateArray();",
          "5177: #endif",
          "5179:             JavascriptError::ThrowRangeError(scriptContext, JSERR_ArrayLengthAssignIncorrect);",
          "5180:         }",
          "5182: #ifdef VALIDATE_ARRAY",
          "5183:         arr->ValidateArray();",
          "5184: #endif",
          "5185:         return JavascriptNumber::ToVar(n, scriptContext);",
          "5186:     }",
          "5192:     Var JavascriptArray::EntryPush(RecyclableObject* function, CallInfo callInfo, ...)",
          "5193:     {",
          "5194:         PROBE_STACK(function->GetScriptContext(), Js::Constants::MinStackDefault);",
          "5196:         ARGUMENTS(args, callInfo);",
          "5197:         ScriptContext* scriptContext = function->GetScriptContext();",
          "5198:         Assert(!(callInfo.Flags & CallFlags_New));",
          "5200:         if (args.Info.Count == 0)",
          "5201:         {",
          "5202:             JavascriptError::ThrowTypeError(scriptContext, JSERR_This_NullOrUndefined, _u(\"Array.prototype.push\"));",
          "5203:         }",
          "5205:         if (JavascriptArray::Is(args[0]))",
          "5206:         {",
          "5207:             return EntryPushJavascriptArray(scriptContext, args.Values, args.Info.Count);",
          "5208:         }",
          "5209:         else",
          "5210:         {",
          "5211:             return EntryPushNonJavascriptArray(scriptContext, args.Values, args.Info.Count);",
          "5212:         }",
          "5213:     }",
          "5216:     Var JavascriptArray::EntryReverse(RecyclableObject* function, CallInfo callInfo, ...)",
          "5217:     {",
          "5218:         PROBE_STACK(function->GetScriptContext(), Js::Constants::MinStackDefault);",
          "5220:         ARGUMENTS(args, callInfo);",
          "5221:         ScriptContext* scriptContext = function->GetScriptContext();",
          "5222:         JS_REENTRANCY_LOCK(jsReentLock, scriptContext->GetThreadContext());",
          "5224:         Assert(!(callInfo.Flags & CallFlags_New));",
          "5226:         if (args.Info.Count == 0)",
          "5227:         {",
          "5228:             JavascriptError::ThrowTypeError(scriptContext, JSERR_This_NullOrUndefined, _u(\"Array.prototype.reverse\"));",
          "5229:         }",
          "5231:         BigIndex length = 0u;",
          "5232:         JavascriptArray* pArr = nullptr;",
          "5233:         RecyclableObject* obj = nullptr;",
          "5235:         JS_REENTRANT(jsReentLock, TryGetArrayAndLength(args[0], scriptContext, _u(\"Array.prototype.reverse\"), &pArr, &obj, &length));",
          "5237:         if (length.IsSmallIndex())",
          "5238:         {",
          "5239:             JS_REENTRANT_UNLOCK(jsReentLock, return JavascriptArray::ReverseHelper(pArr, nullptr, obj, length.GetSmallIndex(), scriptContext));",
          "5240:         }",
          "5241:         Assert(pArr == nullptr || length.IsUint32Max()); // if pArr is not null lets make sure length is safe to cast, which will only happen if length is a uint32max",
          "5243:         JS_REENTRANT_UNLOCK(jsReentLock, return JavascriptArray::ReverseHelper(pArr, nullptr, obj, length.GetBigIndex(), scriptContext));",
          "5244:     }",
          "5247:     template <typename T>",
          "5248:     Var JavascriptArray::ReverseHelper(JavascriptArray* pArr, Js::TypedArrayBase* typedArrayBase, RecyclableObject* obj, T length, ScriptContext* scriptContext)",
          "5249:     {",
          "5250:         JS_REENTRANCY_LOCK(jsReentLock, scriptContext->GetThreadContext());",
          "5252:         T middle = length / 2;",
          "5253:         Var lowerValue = nullptr, upperValue = nullptr;",
          "5254:         T lowerExists, upperExists;",
          "5255:         const char16* methodName;",
          "5256:         bool isTypedArrayEntryPoint = typedArrayBase != nullptr;",
          "5258:         if (isTypedArrayEntryPoint)",
          "5259:         {",
          "5260:             methodName = _u(\"[TypedArray].prototype.reverse\");",
          "5261:         }",
          "5262:         else",
          "5263:         {",
          "5264:             methodName = _u(\"Array.prototype.reverse\");",
          "5265:         }",
          "5268:         if (!isTypedArrayEntryPoint && pArr == nullptr && TypedArrayBase::Is(obj))",
          "5269:         {",
          "5270:             typedArrayBase = TypedArrayBase::FromVar(obj);",
          "5271:         }",
          "5273:         ThrowTypeErrorOnFailureHelper h(scriptContext, methodName);",
          "5275:         if (pArr)",
          "5276:         {",
          "5277:             Recycler * recycler = scriptContext->GetRecycler();",
          "5279:             if (length <= 1)",
          "5280:             {",
          "5281:                 return pArr;",
          "5282:             }",
          "5284:             if (pArr->IsFillFromPrototypes())",
          "5285:             {",
          "5288:                 if (length % 2 == 0)",
          "5289:                 {",
          "5290:                     JS_REENTRANT(jsReentLock, pArr->FillFromPrototypes(0, (uint32)length));",
          "5291:                 }",
          "5292:                 else",
          "5293:                 {",
          "5294:                     middle = length / 2;",
          "5295:                     JS_REENTRANT(jsReentLock,",
          "5296:                         pArr->FillFromPrototypes(0, (uint32)middle),",
          "5297:                         pArr->FillFromPrototypes(1 + (uint32)middle, (uint32)length));",
          "5298:                 }",
          "5299:             }",
          "5301:             if (pArr->HasNoMissingValues() && pArr->head && pArr->head->next)",
          "5302:             {",
          "5304:                 pArr->SetHasNoMissingValues(false);",
          "5305:             }",
          "5310:             length = pArr->length;",
          "5312:             SparseArraySegmentBase* seg = pArr->head;",
          "5313:             SparseArraySegmentBase *prevSeg = nullptr;",
          "5314:             SparseArraySegmentBase *nextSeg = nullptr;",
          "5315:             SparseArraySegmentBase *pinPrevSeg = nullptr;",
          "5317:             bool isIntArray = false;",
          "5318:             bool isFloatArray = false;",
          "5320:             if (JavascriptNativeIntArray::Is(pArr))",
          "5321:             {",
          "5322:                 isIntArray = true;",
          "5323:             }",
          "5324:             else if (JavascriptNativeFloatArray::Is(pArr))",
          "5325:             {",
          "5326:                 isFloatArray = true;",
          "5327:             }",
          "5329:             while (seg)",
          "5330:             {",
          "5331:                 nextSeg = seg->next;",
          "5335:                 if (seg->length > 0)",
          "5336:                 {",
          "5337:                     if (isIntArray)",
          "5338:                     {",
          "5339:                         ((SparseArraySegment<int32>*)seg)->ReverseSegment(recycler);",
          "5340:                     }",
          "5341:                     else if (isFloatArray)",
          "5342:                     {",
          "5343:                         ((SparseArraySegment<double>*)seg)->ReverseSegment(recycler);",
          "5344:                     }",
          "5345:                     else",
          "5346:                     {",
          "5347:                         ((SparseArraySegment<Var>*)seg)->ReverseSegment(recycler);",
          "5348:                     }",
          "5350:                     seg->left = ((uint32)length) > (seg->left + seg->length) ? ((uint32)length) - (seg->left + seg->length) : 0;",
          "5352:                     seg->next = prevSeg;",
          "5355:                     seg->EnsureSizeInBound();",
          "5359:                     pinPrevSeg = prevSeg;",
          "5360:                     prevSeg = seg;",
          "5361:                 }",
          "5363:                 seg = nextSeg;",
          "5364:             }",
          "5366:             pArr->head = prevSeg;",
          "5369:             pArr->ClearSegmentMap();",
          "5371:             if (isIntArray)",
          "5372:             {",
          "5373:                 if (pArr->head && pArr->head->next && SparseArraySegmentBase::IsLeafSegment(pArr->head, recycler))",
          "5374:                 {",
          "5375:                     pArr->ReallocNonLeafSegment(SparseArraySegment<int32>::From(pArr->head), pArr->head->next);",
          "5376:                 }",
          "5377:                 pArr->EnsureHeadStartsFromZero<int32>(recycler);",
          "5378:             }",
          "5379:             else if (isFloatArray)",
          "5380:             {",
          "5381:                 if (pArr->head && pArr->head->next && SparseArraySegmentBase::IsLeafSegment(pArr->head, recycler))",
          "5382:                 {",
          "5383:                     pArr->ReallocNonLeafSegment(SparseArraySegment<double>::From(pArr->head), pArr->head->next);",
          "5384:                 }",
          "5385:                 pArr->EnsureHeadStartsFromZero<double>(recycler);",
          "5386:             }",
          "5387:             else",
          "5388:             {",
          "5389:                 pArr->EnsureHeadStartsFromZero<Var>(recycler);",
          "5390:             }",
          "5392:             pArr->InvalidateLastUsedSegment(); // lastUsedSegment might be 0-length and discarded above",
          "5394: #ifdef VALIDATE_ARRAY",
          "5395:             pArr->ValidateArray();",
          "5396: #endif",
          "5397:         }",
          "5398:         else if (typedArrayBase)",
          "5399:         {",
          "5400:             Assert(length <= JavascriptArray::MaxArrayLength);",
          "5401:             if (typedArrayBase->GetLength() == length)",
          "5402:             {",
          "5405:                 for (uint32 lower = 0; lower < (uint32)middle; lower++)",
          "5406:                 {",
          "5407:                     uint32 upper = (uint32)length - lower - 1;",
          "5409:                     lowerValue = typedArrayBase->DirectGetItem(lower);",
          "5410:                     upperValue = typedArrayBase->DirectGetItem(upper);",
          "5414:                     lowerExists = typedArrayBase->HasItem(lower);",
          "5415:                     upperExists = typedArrayBase->HasItem(upper);",
          "5417:                     JS_REENTRANT(jsReentLock,",
          "5418:                         h.ThrowTypeErrorOnFailure(typedArrayBase->DirectSetItem(lower, upperValue)),",
          "5419:                         h.ThrowTypeErrorOnFailure(typedArrayBase->DirectSetItem(upper, lowerValue)));",
          "5420:                 }",
          "5421:             }",
          "5422:             else",
          "5423:             {",
          "5424:                 Assert(middle <= UINT_MAX);",
          "5425:                 for (uint32 lower = 0; lower < (uint32)middle; lower++)",
          "5426:                 {",
          "5427:                     uint32 upper = (uint32)length - lower - 1;",
          "5429:                     lowerValue = typedArrayBase->DirectGetItem(lower);",
          "5430:                     upperValue = typedArrayBase->DirectGetItem(upper);",
          "5432:                     lowerExists = typedArrayBase->HasItem(lower);",
          "5433:                     upperExists = typedArrayBase->HasItem(upper);",
          "5435:                     if (lowerExists)",
          "5436:                     {",
          "5437:                         if (upperExists)",
          "5438:                         {",
          "5439:                             JS_REENTRANT(jsReentLock,",
          "5440:                                 h.ThrowTypeErrorOnFailure(typedArrayBase->DirectSetItem(lower, upperValue)),",
          "5441:                                 h.ThrowTypeErrorOnFailure(typedArrayBase->DirectSetItem(upper, lowerValue)));",
          "5442:                         }",
          "5443:                         else",
          "5444:                         {",
          "5446:                             h.ThrowTypeErrorOnFailure(typedArrayBase->DeleteItem(lower, PropertyOperation_ThrowOnDeleteIfNotConfig));",
          "5447:                             JS_REENTRANT(jsReentLock, h.ThrowTypeErrorOnFailure(typedArrayBase->DirectSetItem(upper, lowerValue)));",
          "5448:                         }",
          "5449:                     }",
          "5450:                     else",
          "5451:                     {",
          "5452:                         if (upperExists)",
          "5453:                         {",
          "5454:                             JS_REENTRANT(jsReentLock, h.ThrowTypeErrorOnFailure(typedArrayBase->DirectSetItem(lower, upperValue)));",
          "5456:                             h.ThrowTypeErrorOnFailure(typedArrayBase->DeleteItem(upper, PropertyOperation_ThrowOnDeleteIfNotConfig));",
          "5457:                         }",
          "5458:                     }",
          "5459:                 }",
          "5460:             }",
          "5461:         }",
          "5462:         else",
          "5463:         {",
          "5464:             for (T lower = 0; lower < middle; lower++)",
          "5465:             {",
          "5466:                 T upper = length - lower - 1;",
          "5468:                 JS_REENTRANT(jsReentLock,",
          "5469:                     lowerExists = JavascriptOperators::HasItem(obj, lower) && JavascriptOperators::GetItem(obj, lower, &lowerValue, scriptContext),",
          "5470:                     upperExists = JavascriptOperators::HasItem(obj, upper) && JavascriptOperators::GetItem(obj, upper, &upperValue, scriptContext));",
          "5472:                 if (lowerExists)",
          "5473:                 {",
          "5474:                     if (upperExists)",
          "5475:                     {",
          "5476:                         JS_REENTRANT(jsReentLock,",
          "5477:                             h.ThrowTypeErrorOnFailure(JavascriptOperators::SetItem(obj, obj, lower, upperValue, scriptContext, PropertyOperation_ThrowIfNotExtensible)),",
          "5478:                             h.ThrowTypeErrorOnFailure(JavascriptOperators::SetItem(obj, obj, upper, lowerValue, scriptContext, PropertyOperation_ThrowIfNotExtensible)));",
          "5479:                     }",
          "5480:                     else",
          "5481:                     {",
          "5482:                         JS_REENTRANT(jsReentLock,",
          "5483:                             h.ThrowTypeErrorOnFailure(JavascriptOperators::DeleteItem(obj, lower, PropertyOperation_ThrowOnDeleteIfNotConfig)),",
          "5484:                             h.ThrowTypeErrorOnFailure(JavascriptOperators::SetItem(obj, obj, upper, lowerValue, scriptContext, PropertyOperation_ThrowIfNotExtensible)));",
          "5485:                     }",
          "5486:                 }",
          "5487:                 else",
          "5488:                 {",
          "5489:                     if (upperExists)",
          "5490:                     {",
          "5491:                         JS_REENTRANT(jsReentLock,",
          "5492:                             h.ThrowTypeErrorOnFailure(JavascriptOperators::SetItem(obj, obj, lower, upperValue, scriptContext, PropertyOperation_ThrowIfNotExtensible)),",
          "5493:                             h.ThrowTypeErrorOnFailure(JavascriptOperators::DeleteItem(obj, upper, PropertyOperation_ThrowOnDeleteIfNotConfig)));",
          "5494:                     }",
          "5495:                 }",
          "5496:             }",
          "5497:         }",
          "5499:         return obj;",
          "5500:     }",
          "5502:     template<typename T>",
          "5503:     void JavascriptArray::ShiftHelper(JavascriptArray* pArr, ScriptContext * scriptContext)",
          "5504:     {",
          "5505:         Recycler * recycler = scriptContext->GetRecycler();",
          "5507:         SparseArraySegment<T>* next = SparseArraySegment<T>::From(pArr->head->next);",
          "5508:         while (next)",
          "5509:         {",
          "5510:             next->left--;",
          "5511:             next = SparseArraySegment<T>::From(next->next);",
          "5512:         }",
          "5515:         next = SparseArraySegment<T>::From(pArr->head->next);",
          "5516:         if (next && (pArr->head->size > next->left))",
          "5517:         {",
          "5518:             AssertMsg(pArr->head->left == 0, \"Array always points to a head starting at index 0\");",
          "5519:             AssertMsg(pArr->head->size == next->left + 1, \"Shift next->left overlaps current segment by more than 1 element\");",
          "5521:             SparseArraySegment<T> *head = SparseArraySegment<T>::From(pArr->head);",
          "5523:             if (next->length != 0)",
          "5524:             {",
          "5525:                 uint32 offset = head->size - 1;",
          "5529:                 if (next->next)",
          "5530:                 {",
          "5536:                     Assert(next->next->left >= head->size);",
          "5537:                     uint32 maxGrowSize = next->next->left - head->size;",
          "5538:                     if (maxGrowSize != 0)",
          "5539:                     {",
          "5540:                         head = head->GrowByMinMax(recycler, next->length - 1, maxGrowSize); //-1 is to account for unshift",
          "5541:                     }",
          "5542:                     else",
          "5543:                     {",
          "5545:                         Assert(next->length == 1);",
          "5546:                     }",
          "5547:                 }",
          "5548:                 else",
          "5549:                 {",
          "5550:                     head = head->GrowByMin(recycler, next->length - 1); //-1 is to account for unshift",
          "5551:                 }",
          "5552:                 MoveArray(head->elements + offset, next->elements, next->length);",
          "5553:                 head->length = offset + next->length;",
          "5554:                 pArr->head = head;",
          "5555:             }",
          "5556:             head->next = next->next;",
          "5557:             pArr->InvalidateLastUsedSegment();",
          "5558:         }",
          "5560: #ifdef VALIDATE_ARRAY",
          "5561:             pArr->ValidateArray();",
          "5562: #endif",
          "5563:     }",
          "5565:     Var JavascriptArray::EntryShift(RecyclableObject* function, CallInfo callInfo, ...)",
          "5566:     {",
          "5567:         PROBE_STACK(function->GetScriptContext(), Js::Constants::MinStackDefault);",
          "5569:         ARGUMENTS(args, callInfo);",
          "5570:         ScriptContext* scriptContext = function->GetScriptContext();",
          "5571:         JS_REENTRANCY_LOCK(jsReentLock, scriptContext->GetThreadContext());",
          "5573:         Assert(!(callInfo.Flags & CallFlags_New));",
          "5575:         Var res = scriptContext->GetLibrary()->GetUndefined();",
          "5577:         if (args.Info.Count == 0)",
          "5578:         {",
          "5579:             return res;",
          "5580:         }",
          "5581:         if (JavascriptArray::Is(args[0]))",
          "5582:         {",
          "5583:             JavascriptArray * pArr = JavascriptArray::FromVar(args[0]);",
          "5584: #if ENABLE_COPYONACCESS_ARRAY",
          "5585:             JavascriptLibrary::CheckAndConvertCopyOnAccessNativeIntArray<Var>(pArr);",
          "5586: #endif",
          "5588:             if (pArr->length == 0)",
          "5589:             {",
          "5590:                 return res;",
          "5591:             }",
          "5593:             if(pArr->IsFillFromPrototypes())",
          "5594:             {",
          "5595:                 JS_REENTRANT(jsReentLock, pArr->FillFromPrototypes(0, pArr->length)); // We need find all missing value from [[proto]] object",
          "5596:             }",
          "5598:             if(pArr->HasNoMissingValues() && pArr->head && pArr->head->next)",
          "5599:             {",
          "5601:                 pArr->SetHasNoMissingValues(false);",
          "5602:             }",
          "5604:             pArr->length--;",
          "5606:             pArr->ClearSegmentMap(); // Dump segmentMap on shift (before any allocation)",
          "5608:             Recycler * recycler = scriptContext->GetRecycler();",
          "5610:             bool isIntArray = false;",
          "5611:             bool isFloatArray = false;",
          "5613:             if(JavascriptNativeIntArray::Is(pArr))",
          "5614:             {",
          "5615:                 isIntArray = true;",
          "5616:             }",
          "5617:             else if(JavascriptNativeFloatArray::Is(pArr))",
          "5618:             {",
          "5619:                 isFloatArray = true;",
          "5620:             }",
          "5622:             if (pArr->head->length != 0)",
          "5623:             {",
          "5624:                 if(isIntArray)",
          "5625:                 {",
          "5626:                     int32 nativeResult = SparseArraySegment<int32>::From(pArr->head)->GetElement(0);",
          "5628:                     if(SparseArraySegment<int32>::IsMissingItem(&nativeResult))",
          "5629:                     {",
          "5630:                         res = scriptContext->GetLibrary()->GetUndefined();",
          "5631:                     }",
          "5632:                     else",
          "5633:                     {",
          "5634:                         res = Js::JavascriptNumber::ToVar(nativeResult, scriptContext);",
          "5635:                     }",
          "5636:                     SparseArraySegment<int32>::From(pArr->head)->RemoveElement(recycler, 0);",
          "5637:                 }",
          "5638:                 else if (isFloatArray)",
          "5639:                 {",
          "5640:                     double nativeResult = SparseArraySegment<double>::From(pArr->head)->GetElement(0);",
          "5642:                     if(SparseArraySegment<double>::IsMissingItem(&nativeResult))",
          "5643:                     {",
          "5644:                         res = scriptContext->GetLibrary()->GetUndefined();",
          "5645:                     }",
          "5646:                     else",
          "5647:                     {",
          "5648:                         res = Js::JavascriptNumber::ToVarNoCheck(nativeResult, scriptContext);",
          "5649:                     }",
          "5650:                     SparseArraySegment<double>::From(pArr->head)->RemoveElement(recycler, 0);",
          "5651:                 }",
          "5652:                 else",
          "5653:                 {",
          "5654:                     res = SparseArraySegment<Var>::From(pArr->head)->GetElement(0);",
          "5656:                     if(SparseArraySegment<Var>::IsMissingItem(&res))",
          "5657:                     {",
          "5658:                         res = scriptContext->GetLibrary()->GetUndefined();",
          "5659:                     }",
          "5660:                     else",
          "5661:                     {",
          "5662:                         res = CrossSite::MarshalVar(scriptContext, res);",
          "5663:                     }",
          "5664:                     SparseArraySegment<Var>::From(pArr->head)->RemoveElement(recycler, 0);",
          "5665:                 }",
          "5666:             }",
          "5668:             if(isIntArray)",
          "5669:             {",
          "5670:                 ShiftHelper<int32>(pArr, scriptContext);",
          "5671:             }",
          "5672:             else if (isFloatArray)",
          "5673:             {",
          "5674:                 ShiftHelper<double>(pArr, scriptContext);",
          "5675:             }",
          "5676:             else",
          "5677:             {",
          "5678:                 ShiftHelper<Var>(pArr, scriptContext);",
          "5679:             }",
          "5680:         }",
          "5681:         else",
          "5682:         {",
          "5683:             RecyclableObject* dynamicObject = nullptr;",
          "5684:             if (FALSE == JavascriptConversion::ToObject(args[0], scriptContext, &dynamicObject))",
          "5685:             {",
          "5686:                 JavascriptError::ThrowTypeError(scriptContext, JSERR_This_NullOrUndefined, _u(\"Array.prototype.shift\"));",
          "5687:             }",
          "5689:             ThrowTypeErrorOnFailureHelper h(scriptContext, _u(\"Array.prototype.shift\"));",
          "5691:             JS_REENTRANT(jsReentLock, BigIndex length = OP_GetLength(dynamicObject, scriptContext));",
          "5693:             if (length == 0u)",
          "5694:             {",
          "5696:                 JS_REENTRANT(jsReentLock,",
          "5697:                     h.ThrowTypeErrorOnFailure(JavascriptOperators::SetProperty(dynamicObject, dynamicObject, PropertyIds::length, TaggedInt::ToVarUnchecked(0), scriptContext, PropertyOperation_ThrowIfNotExtensible)));",
          "5698:                 return scriptContext->GetLibrary()->GetUndefined();",
          "5699:             }",
          "5701:             JS_REENTRANT(jsReentLock,",
          "5702:                 BOOL gotItem = JavascriptOperators::GetItem(dynamicObject, 0u, &res, scriptContext));",
          "5703:             if (!gotItem)",
          "5704:             {",
          "5705:                 res = scriptContext->GetLibrary()->GetUndefined();",
          "5706:             }",
          "5707:             --length;",
          "5708:             uint32 lengthToUin32Max = length.IsSmallIndex() ? length.GetSmallIndex() : MaxArrayLength;",
          "5709:             for (uint32 i = 0u; i < lengthToUin32Max; i++)",
          "5710:             {",
          "5711:                 JS_REENTRANT(jsReentLock, BOOL hasItem = JavascriptOperators::HasItem(dynamicObject, i + 1));",
          "5712:                 if (hasItem)",
          "5713:                 {",
          "5714:                     Var element = nullptr;",
          "5715:                     JS_REENTRANT(jsReentLock,",
          "5716:                         element = JavascriptOperators::GetItem(dynamicObject, i + 1, scriptContext),",
          "5717:                         h.ThrowTypeErrorOnFailure(JavascriptOperators::SetItem(dynamicObject, dynamicObject, i, element, scriptContext, PropertyOperation_ThrowIfNotExtensible, /*skipPrototypeCheck*/ true)));",
          "5718:                 }",
          "5719:                 else",
          "5720:                 {",
          "5721:                     JS_REENTRANT(jsReentLock, h.ThrowTypeErrorOnFailure(JavascriptOperators::DeleteItem(dynamicObject, i, PropertyOperation_ThrowOnDeleteIfNotConfig)));",
          "5722:                 }",
          "5723:             }",
          "5725:             for (uint64 i = MaxArrayLength; length > i; i++)",
          "5726:             {",
          "5727:                 JS_REENTRANT(jsReentLock, BOOL hasItem = JavascriptOperators::HasItem(dynamicObject, i + 1));",
          "5728:                 if (hasItem)",
          "5729:                 {",
          "5730:                     Var element = nullptr;",
          "5731:                     JS_REENTRANT(jsReentLock,",
          "5732:                         element = JavascriptOperators::GetItem(dynamicObject, i + 1, scriptContext),",
          "5733:                         h.ThrowTypeErrorOnFailure(JavascriptOperators::SetItem(dynamicObject, dynamicObject, i, element, scriptContext, PropertyOperation_ThrowIfNotExtensible)));",
          "5734:                 }",
          "5735:                 else",
          "5736:                 {",
          "5737:                     JS_REENTRANT(jsReentLock, h.ThrowTypeErrorOnFailure(JavascriptOperators::DeleteItem(dynamicObject, i, PropertyOperation_ThrowOnDeleteIfNotConfig)));",
          "5738:                 }",
          "5739:             }",
          "5741:             if (length.IsSmallIndex())",
          "5742:             {",
          "5743:                 JS_REENTRANT(jsReentLock,",
          "5744:                     h.ThrowTypeErrorOnFailure(JavascriptOperators::DeleteItem(dynamicObject, length.GetSmallIndex(), PropertyOperation_ThrowOnDeleteIfNotConfig)),",
          "5745:                     h.ThrowTypeErrorOnFailure(JavascriptOperators::SetProperty(dynamicObject, dynamicObject, PropertyIds::length, JavascriptNumber::ToVar(length.GetSmallIndex(), scriptContext), scriptContext, PropertyOperation_ThrowIfNotExtensible)));",
          "5746:             }",
          "5747:             else",
          "5748:             {",
          "5749:                 JS_REENTRANT(jsReentLock,",
          "5750:                     h.ThrowTypeErrorOnFailure(JavascriptOperators::DeleteItem(dynamicObject, length.GetBigIndex(), PropertyOperation_ThrowOnDeleteIfNotConfig)),",
          "5751:                     h.ThrowTypeErrorOnFailure(JavascriptOperators::SetProperty(dynamicObject, dynamicObject, PropertyIds::length, JavascriptNumber::ToVar(length.GetBigIndex(), scriptContext), scriptContext, PropertyOperation_ThrowIfNotExtensible)));",
          "5752:             }",
          "5753:         }",
          "5754:         return res;",
          "5755:     }",
          "5757:     Js::JavascriptArray* JavascriptArray::CreateNewArrayHelper(uint32 len, bool isIntArray, bool isFloatArray,  Js::JavascriptArray* baseArray, ScriptContext* scriptContext)",
          "5758:     {",
          "5759:         if (isIntArray)",
          "5760:         {",
          "5761:             Js::JavascriptNativeIntArray *pnewArr = scriptContext->GetLibrary()->CreateNativeIntArray(len);",
          "5762:             pnewArr->EnsureHead<int32>();",
          "5763: #if ENABLE_PROFILE_INFO",
          "5764:             pnewArr->CopyArrayProfileInfo(Js::JavascriptNativeIntArray::FromVar(baseArray));",
          "5765: #endif",
          "5767:             return pnewArr;",
          "5768:         }",
          "5769:         else if (isFloatArray)",
          "5770:         {",
          "5771:             Js::JavascriptNativeFloatArray *pnewArr  = scriptContext->GetLibrary()->CreateNativeFloatArray(len);",
          "5772:             pnewArr->EnsureHead<double>();",
          "5773: #if ENABLE_PROFILE_INFO",
          "5774:             pnewArr->CopyArrayProfileInfo(Js::JavascriptNativeFloatArray::FromVar(baseArray));",
          "5775: #endif",
          "5777:             return pnewArr;",
          "5778:         }",
          "5779:         else",
          "5780:         {",
          "5781:             JavascriptArray *pnewArr = pnewArr = scriptContext->GetLibrary()->CreateArray(len);",
          "5782:             pnewArr->EnsureHead<Var>();",
          "5783:             return pnewArr;",
          "5784:         }",
          "5785:    }",
          "5787:     template<typename T>",
          "5788:     void JavascriptArray::SliceHelper(JavascriptArray* pArr,  JavascriptArray* pnewArr, uint32 start, uint32 newLen)",
          "5789:     {",
          "5790:         JS_REENTRANCY_LOCK(jsReentLock, pArr->GetScriptContext()->GetThreadContext());",
          "5792:         SparseArraySegment<T>* headSeg = SparseArraySegment<T>::From(pArr->head);",
          "5793:         SparseArraySegment<T>* pnewHeadSeg = SparseArraySegment<T>::From(pnewArr->head);",
          "5796:         CopyArray(pnewHeadSeg->elements, newLen, headSeg->elements + start, newLen);",
          "5797:         pnewHeadSeg->length = newLen;",
          "5799:         Assert(pnewHeadSeg->length <= pnewHeadSeg->size);",
          "5801:         if (!pArr->HasNoMissingValues())",
          "5802:         {",
          "5803:             for (uint32 i = 0; i < newLen && (i + start) < pArr->length; i++)",
          "5804:             {",
          "5807:                 if (pArr->IsMissingItem(i + start))",
          "5808:                 {",
          "5809:                     Var element;",
          "5810:                     pnewArr->SetHasNoMissingValues(false);",
          "5811:                     JS_REENTRANT(jsReentLock, BOOL gotItem = pArr->DirectGetItemAtFull(i + start, &element));",
          "5812:                     if (gotItem)",
          "5813:                     {",
          "5814:                         JS_REENTRANT(jsReentLock, pnewArr->SetItem(i, element, PropertyOperation_None));",
          "5815:                     }",
          "5816:                 }",
          "5817:             }",
          "5818:         }",
          "5819: #ifdef DBG",
          "5820:         else",
          "5821:         {",
          "5822:             for (uint32 i = 0; i < newLen; i++)",
          "5823:             {",
          "5824:                 AssertMsg(!SparseArraySegment<T>::IsMissingItem(&headSeg->elements[i+start]), \"Array marked incorrectly as having missing value\");",
          "5825:             }",
          "5826:         }",
          "5827: #endif",
          "5828:     }",
          "5832:     void JavascriptArray::GetArrayTypeAndConvert(bool* isIntArray, bool* isFloatArray)",
          "5833:     {",
          "5834:         if (JavascriptNativeIntArray::Is(this))",
          "5835:         {",
          "5836: #if ENABLE_PROFILE_INFO",
          "5837:             JavascriptNativeIntArray* nativeIntArray = JavascriptNativeIntArray::FromVar(this);",
          "5838:             ArrayCallSiteInfo* info = nativeIntArray->GetArrayCallSiteInfo();",
          "5839:             if(!info || info->IsNativeIntArray())",
          "5840:             {",
          "5842:             }",
          "5843:             else if(info->IsNativeFloatArray())",
          "5844:             {",
          "5845:                 JavascriptNativeIntArray::ToNativeFloatArray(nativeIntArray);",
          "5847:             }",
          "5848:             else",
          "5849:             {",
          "5850:                 JavascriptNativeIntArray::ToVarArray(nativeIntArray);",
          "5851:             }",
          "5852: #else",
          "5854: #endif",
          "5855:         }",
          "5856:         else if (JavascriptNativeFloatArray::Is(this))",
          "5857:         {",
          "5858: #if ENABLE_PROFILE_INFO",
          "5859:             JavascriptNativeFloatArray* nativeFloatArray = JavascriptNativeFloatArray::FromVar(this);",
          "5860:             ArrayCallSiteInfo* info = nativeFloatArray->GetArrayCallSiteInfo();",
          "5862:             if(info && !info->IsNativeArray())",
          "5863:             {",
          "5864:                 JavascriptNativeFloatArray::ToVarArray(nativeFloatArray);",
          "5865:             }",
          "5866:             else",
          "5867:             {",
          "5869:             }",
          "5870: #else",
          "5872: #endif",
          "5873:         }",
          "5874:     }",
          "5876:     Var JavascriptArray::EntrySlice(RecyclableObject* function, CallInfo callInfo, ...)",
          "5877:     {",
          "5878:         PROBE_STACK(function->GetScriptContext(), Js::Constants::MinStackDefault);",
          "5880:         ARGUMENTS(args, callInfo);",
          "5881:         ScriptContext* scriptContext = function->GetScriptContext();",
          "5882:         JS_REENTRANCY_LOCK(jsReentLock, scriptContext->GetThreadContext());",
          "5884:         Assert(!(callInfo.Flags & CallFlags_New));",
          "5886:         Var res = scriptContext->GetLibrary()->GetUndefined();",
          "5888:         if (args.Info.Count == 0)",
          "5889:         {",
          "5890:             return res;",
          "5891:         }",
          "5893:         BigIndex length;",
          "5894:         JavascriptArray* pArr = nullptr;",
          "5895:         RecyclableObject* obj = nullptr;",
          "5897:         JS_REENTRANT(jsReentLock, TryGetArrayAndLength(args[0], scriptContext, _u(\"Array.prototype.slice\"), &pArr, &obj, &length));",
          "5899:         if (length.IsSmallIndex())",
          "5900:         {",
          "5901:             JS_REENTRANT_UNLOCK(jsReentLock, return JavascriptArray::SliceHelper(pArr, nullptr, obj, length.GetSmallIndex(), args, scriptContext));",
          "5902:         }",
          "5904:         Assert(pArr == nullptr || length.IsUint32Max());",
          "5905:         JS_REENTRANT_UNLOCK(jsReentLock, return JavascriptArray::SliceHelper(pArr, nullptr, obj, length.GetBigIndex(), args, scriptContext));",
          "5906:     }",
          "5909:     template <typename T>",
          "5910:     Var JavascriptArray::SliceHelper(JavascriptArray* pArr, Js::TypedArrayBase* typedArrayBase, RecyclableObject* obj, T length, Arguments& args, ScriptContext* scriptContext)",
          "5911:     {",
          "5912:         JS_REENTRANCY_LOCK(jsReentLock, scriptContext->GetThreadContext());",
          "5914:         JavascriptArray* newArr = nullptr;",
          "5915:         RecyclableObject* newObj = nullptr;",
          "5916:         bool isIntArray = false;",
          "5917:         bool isFloatArray = false;",
          "5918:         bool isTypedArrayEntryPoint = typedArrayBase != nullptr;",
          "5919:         bool isBuiltinArrayCtor = true;",
          "5920:         T startT = 0;",
          "5921:         T newLenT = length;",
          "5922:         T endT = length;",
          "5924: #if ENABLE_COPYONACCESS_ARRAY",
          "5925:         JavascriptLibrary::CheckAndConvertCopyOnAccessNativeIntArray<Var>(pArr);",
          "5926: #endif",
          "5927:         if (args.Info.Count > 1)",
          "5928:         {",
          "5929:             JS_REENTRANT(jsReentLock, startT = GetFromIndex(args[1], length, scriptContext));",
          "5931:             if (args.Info.Count > 2 && JavascriptOperators::GetTypeId(args[2]) != TypeIds_Undefined)",
          "5932:             {",
          "5933:                 JS_REENTRANT(jsReentLock, endT = GetFromIndex(args[2], length, scriptContext));",
          "5934:             }",
          "5936:             newLenT = endT > startT ? endT - startT : 0;",
          "5937:         }",
          "5940:         if (pArr && !JavascriptArray::Is(obj))",
          "5941:         {",
          "5942:             AssertOrFailFastMsg(ES5Array::Is(obj), \"The array should have been converted to an ES5Array\");",
          "5943:             pArr = nullptr;",
          "5944:         }",
          "5946:         if (TypedArrayBase::IsDetachedTypedArray(obj))",
          "5947:         {",
          "5948:             JavascriptError::ThrowTypeError(scriptContext, JSERR_DetachedTypedArray, _u(\"Array.prototype.slice\"));",
          "5949:         }",
          "5952:         if (!isTypedArrayEntryPoint && pArr == nullptr && TypedArrayBase::Is(obj))",
          "5953:         {",
          "5954:             typedArrayBase = TypedArrayBase::FromVar(obj);",
          "5955:         }",
          "5959:         if (isTypedArrayEntryPoint)",
          "5960:         {",
          "5961:             JS_REENTRANT(jsReentLock,",
          "5962:                 Var constructor = JavascriptOperators::SpeciesConstructor(typedArrayBase, TypedArrayBase::GetDefaultConstructor(args[0], scriptContext), scriptContext));",
          "5963:             isBuiltinArrayCtor = false;",
          "5965:             AssertAndFailFast(pArr == nullptr);",
          "5966:             Assert(JavascriptOperators::IsConstructor(constructor));",
          "5968:             Js::Var constructorArgs[] = { constructor, JavascriptNumber::ToVar(newLenT, scriptContext) };",
          "5969:             Js::CallInfo constructorCallInfo(Js::CallFlags_New, _countof(constructorArgs));",
          "5970:             JS_REENTRANT(jsReentLock, newObj = RecyclableObject::FromVar(TypedArrayBase::TypedArrayCreate(constructor, &Js::Arguments(constructorCallInfo, constructorArgs), (uint32)newLenT, scriptContext)));",
          "5971:         }",
          "5973:         else if (pArr != nullptr)",
          "5974:         {",
          "5975:             JS_REENTRANT(jsReentLock, newObj = ArraySpeciesCreate(pArr, newLenT, scriptContext, &isIntArray, &isFloatArray, &isBuiltinArrayCtor));",
          "5976:         }",
          "5979:         else",
          "5980:         {",
          "5981:             JS_REENTRANT(jsReentLock, newObj = ArraySpeciesCreate(obj, newLenT, scriptContext, nullptr, nullptr, &isBuiltinArrayCtor));",
          "5982:         }",
          "5986:         if (newObj == nullptr)",
          "5987:         {",
          "5988:             if (pArr)",
          "5989:             {",
          "5990:                 pArr->GetArrayTypeAndConvert(&isIntArray, &isFloatArray);",
          "5991:             }",
          "5993:             if (newLenT > JavascriptArray::MaxArrayLength)",
          "5994:             {",
          "5995:                 JavascriptError::ThrowRangeError(scriptContext, JSERR_ArrayLengthConstructIncorrect);",
          "5996:             }",
          "5998:             newArr = CreateNewArrayHelper(static_cast<uint32>(newLenT), isIntArray, isFloatArray, pArr, scriptContext);",
          "5999: #if ENABLE_COPYONACCESS_ARRAY",
          "6000:             JavascriptLibrary::CheckAndConvertCopyOnAccessNativeIntArray<Var>(newArr);",
          "6001: #endif",
          "6002:             newObj = newArr;",
          "6003:         }",
          "6004:         else",
          "6005:         {",
          "6007:             if (JavascriptArray::Is(newObj))",
          "6008:             {",
          "6009: #if ENABLE_COPYONACCESS_ARRAY",
          "6010:                 JavascriptLibrary::CheckAndConvertCopyOnAccessNativeIntArray<Var>(newObj);",
          "6011: #endif",
          "6012:                 newArr = JavascriptArray::FromVar(newObj);",
          "6013:             }",
          "6014:         }",
          "6016:         uint32 start  = (uint32) startT;",
          "6017:         uint32 newLen = (uint32) newLenT;",
          "6020:         Assert(newObj);",
          "6023:         if (newLen == 0)",
          "6024:         {",
          "6025:             return newObj;",
          "6026:         }",
          "6030:         if (pArr && !JavascriptArray::Is(obj))",
          "6031:         {",
          "6032:             AssertOrFailFastMsg(ES5Array::Is(obj), \"The array should have been converted to an ES5Array\");",
          "6033:             pArr = nullptr;",
          "6034:         }",
          "6036:         if (pArr)",
          "6037:         {",
          "6039:             if (newArr && isBuiltinArrayCtor)",
          "6040:             {",
          "6041:                 if (JavascriptArray::IsDirectAccessArray(newArr))",
          "6042:                 {",
          "6043:                     if (((start + newLen) <= pArr->head->length) && newLen <= newArr->head->size) //Fast Path",
          "6044:                     {",
          "6045:                         if (isIntArray)",
          "6046:                         {",
          "6047:                             JS_REENTRANT(jsReentLock, SliceHelper<int32>(pArr, newArr, start, newLen));",
          "6048:                         }",
          "6049:                         else if (isFloatArray)",
          "6050:                         {",
          "6051:                             JS_REENTRANT(jsReentLock, SliceHelper<double>(pArr, newArr, start, newLen));",
          "6052:                         }",
          "6053:                         else",
          "6054:                         {",
          "6055:                             JS_REENTRANT(jsReentLock, SliceHelper<Var>(pArr, newArr, start, newLen));",
          "6056:                         }",
          "6057:                     }",
          "6058:                     else",
          "6059:                     {",
          "6060:                         if (isIntArray)",
          "6061:                         {",
          "6062:                             JS_REENTRANT(jsReentLock, CopyNativeIntArrayElements(JavascriptNativeIntArray::FromVar(newArr), 0, JavascriptNativeIntArray::FromVar(pArr), start, start + newLen));",
          "6063:                         }",
          "6064:                         else if (isFloatArray)",
          "6065:                         {",
          "6066:                             JS_REENTRANT(jsReentLock, CopyNativeFloatArrayElements(JavascriptNativeFloatArray::FromVar(newArr), 0, JavascriptNativeFloatArray::FromVar(pArr), start, start + newLen));",
          "6067:                         }",
          "6068:                         else",
          "6069:                         {",
          "6070:                             JS_REENTRANT(jsReentLock, CopyArrayElements(newArr, 0u, pArr, start, start + newLen));",
          "6071:                         }",
          "6072:                     }",
          "6073:                 }",
          "6074:                 else",
          "6075:                 {",
          "6076:                     AssertMsg(CONFIG_FLAG(ForceES5Array), \"newArr can only be ES5Array when it is forced\");",
          "6077:                     Var element;",
          "6078:                     for (uint32 i = 0; i < newLen; i++)",
          "6079:                     {",
          "6080:                         JS_REENTRANT(jsReentLock, BOOL gotItem = pArr->DirectGetItemAtFull(i + start, &element));",
          "6081:                         if (!gotItem)",
          "6082:                         {",
          "6083:                             continue;",
          "6084:                         }",
          "6086:                         newArr->SetItem(i, element, PropertyOperation_None);",
          "6090:                         if (!JavascriptArray::Is(obj))",
          "6091:                         {",
          "6092:                             AssertOrFailFastMsg(ES5Array::Is(obj), \"The array should have been converted to an ES5Array\");",
          "6093:                             JS_REENTRANT_UNLOCK(jsReentLock, return JavascriptArray::SliceObjectHelper(obj, start, i + 1, newArr, newObj, newLen, scriptContext));",
          "6094:                         }",
          "6095:                     }",
          "6096:                 }",
          "6097:             }",
          "6098:             else",
          "6099:             {",
          "6101:                 Var element;",
          "6103:                 for (uint32 i = 0; i < newLen; i++)",
          "6104:                 {",
          "6105:                     JS_REENTRANT(jsReentLock, BOOL gotItem = pArr->DirectGetItemAtFull(i + start, &element));",
          "6106:                     if (!gotItem)",
          "6107:                     {",
          "6108:                         continue;",
          "6109:                     }",
          "6111:                     JS_REENTRANT(jsReentLock, ThrowErrorOnFailure(JavascriptArray::SetArrayLikeObjects(newObj, i, element), scriptContext, i));",
          "6115:                     if (!JavascriptArray::Is(obj))",
          "6116:                     {",
          "6117:                         AssertOrFailFastMsg(ES5Array::Is(obj), \"The array should have been converted to an ES5Array\");",
          "6118:                         JS_REENTRANT_UNLOCK(jsReentLock, return JavascriptArray::SliceObjectHelper(obj, start, i + 1, newArr, newObj, newLen, scriptContext));",
          "6119:                     }",
          "6120:                 }",
          "6121:             }",
          "6122:         }",
          "6123:         else if (typedArrayBase)",
          "6124:         {",
          "6125:             AssertAndFailFast(TypedArrayBase::Is(typedArrayBase));",
          "6128:             TypedArrayBase* newTypedArray = nullptr;",
          "6130:             if (TypedArrayBase::Is(newObj))",
          "6131:             {",
          "6132:                 newTypedArray = TypedArrayBase::FromVar(newObj);",
          "6133:             }",
          "6134:             else",
          "6135:             {",
          "6136:                 AssertAndFailFast(newArr != nullptr);",
          "6137:             }",
          "6139:             Var element;",
          "6141:             for (uint32 i = 0; i < newLen; i++)",
          "6142:             {",
          "6144:                 if (!isTypedArrayEntryPoint && !typedArrayBase->HasItem(i + start))",
          "6145:                 {",
          "6146:                     continue;",
          "6147:                 }",
          "6149:                 element = typedArrayBase->DirectGetItem(i + start);",
          "6152:                 if (newTypedArray)",
          "6153:                 {",
          "6154:                     JS_REENTRANT(jsReentLock, newTypedArray->DirectSetItem(i, element));",
          "6155:                 }",
          "6156:                 else",
          "6157:                 {",
          "6158:                     newArr->SetItem(i, element, PropertyOperation_None);",
          "6159:                 }",
          "6160:             }",
          "6161:         }",
          "6162:         else",
          "6163:         {",
          "6164:             JS_REENTRANT_UNLOCK(jsReentLock, return JavascriptArray::SliceObjectHelper(obj, start, 0u, newArr, newObj, newLen, scriptContext));;",
          "6165:         }",
          "6167:         if (!isTypedArrayEntryPoint)",
          "6168:         {",
          "6169:             JavascriptOperators::SetProperty(newObj, newObj, Js::PropertyIds::length, JavascriptNumber::ToVar(newLen, scriptContext), scriptContext, PropertyOperation_ThrowIfNotExtensible);",
          "6170:         }",
          "6172: #ifdef VALIDATE_ARRAY",
          "6173:         if (JavascriptArray::Is(newObj))",
          "6174:         {",
          "6175:             JavascriptArray::FromVar(newObj)->ValidateArray();",
          "6176:         }",
          "6177: #endif",
          "6179:         return newObj;",
          "6180:     }",
          "6182:     Var JavascriptArray::SliceObjectHelper(RecyclableObject* obj, uint32 sliceStart, uint32 start, JavascriptArray* newArr, RecyclableObject* newObj, uint32 newLen, ScriptContext* scriptContext)",
          "6183:     {",
          "6184:         JS_REENTRANCY_LOCK(jsReentLock, scriptContext->GetThreadContext());",
          "6186:         for (uint32 i = start; i < newLen; i++)",
          "6187:         {",
          "6188:             JS_REENTRANT(jsReentLock, BOOL hasItem = JavascriptOperators::HasItem(obj, i + sliceStart));",
          "6189:                 if (hasItem)",
          "6190:             {",
          "6191:                 JS_REENTRANT(jsReentLock, Var element = JavascriptOperators::GetItem(obj, i + sliceStart, scriptContext));",
          "6192:                 if (newArr != nullptr)",
          "6193:                 {",
          "6194:                     newArr->SetItem(i, element, PropertyOperation_None);",
          "6195:                 }",
          "6196:                 else",
          "6197:                 {",
          "6198:                         JS_REENTRANT(jsReentLock, ThrowErrorOnFailure(JavascriptArray::SetArrayLikeObjects(newObj, i, element), scriptContext, i));",
          "6199:                 }",
          "6200:             }",
          "6201:         }",
          "6203:             JS_REENTRANT(jsReentLock,",
          "6204:                 JavascriptOperators::SetProperty(newObj, newObj, Js::PropertyIds::length, JavascriptNumber::ToVar(newLen, scriptContext), scriptContext, PropertyOperation_ThrowIfNotExtensible));",
          "6206: #ifdef VALIDATE_ARRAY",
          "6207:         if (JavascriptArray::Is(newObj))",
          "6208:         {",
          "6209:             JavascriptArray::FromVar(newObj)->ValidateArray();",
          "6210:         }",
          "6211: #endif",
          "6213:         return newObj;",
          "6214:     }",
          "6216:     struct CompareVarsInfo",
          "6217:     {",
          "6218:         ScriptContext* scriptContext;",
          "6219:         RecyclableObject* compFn;",
          "6220:     };",
          "6222:     int __cdecl compareVars(void* cvInfoV, const void* aRef, const void* bRef)",
          "6223:     {",
          "6224:         CompareVarsInfo* cvInfo=(CompareVarsInfo*)cvInfoV;",
          "6225:         ScriptContext* requestContext=cvInfo->scriptContext;",
          "6226:         RecyclableObject* compFn=cvInfo->compFn;",
          "6228:         AssertMsg(*(Var*)aRef, \"No null expected in sort\");",
          "6229:         AssertMsg(*(Var*)bRef, \"No null expected in sort\");",
          "6231:         if (compFn != nullptr)",
          "6232:         {",
          "6233:             ScriptContext* scriptContext = compFn->GetScriptContext();",
          "6236:             CallFlags flags = CallFlags_Value;",
          "6237:             Var undefined = scriptContext->GetLibrary()->GetUndefined();",
          "6238:             Var retVal;",
          "6239:             if (requestContext != scriptContext)",
          "6240:             {",
          "6241:                 Var leftVar = CrossSite::MarshalVar(scriptContext, *(Var*)aRef);",
          "6242:                 Var rightVar = CrossSite::MarshalVar(scriptContext, *(Var*)bRef);",
          "6243:                 retVal = CALL_FUNCTION(scriptContext->GetThreadContext(), compFn, CallInfo(flags, 3), undefined, leftVar, rightVar);",
          "6244:             }",
          "6245:             else",
          "6246:             {",
          "6247:                 retVal = CALL_FUNCTION(scriptContext->GetThreadContext(), compFn, CallInfo(flags, 3), undefined, *(Var*)aRef, *(Var*)bRef);",
          "6248:             }",
          "6250:             if (TaggedInt::Is(retVal))",
          "6251:             {",
          "6252:                 return TaggedInt::ToInt32(retVal);",
          "6253:             }",
          "6254:             double dblResult;",
          "6255:             if (JavascriptNumber::Is_NoTaggedIntCheck(retVal))",
          "6256:             {",
          "6257:                 dblResult = JavascriptNumber::GetValue(retVal);",
          "6258:             }",
          "6259:             else",
          "6260:             {",
          "6261:                 dblResult = JavascriptConversion::ToNumber_Full(retVal, scriptContext);",
          "6262:             }",
          "6263:             if (dblResult < 0)",
          "6264:             {",
          "6265:                 return -1;",
          "6266:             }",
          "6267:             return (dblResult > 0) ? 1 : 0;",
          "6268:         }",
          "6269:         else",
          "6270:         {",
          "6271:             JavascriptString* pStr1 = JavascriptConversion::ToString(*(Var*)aRef, requestContext);",
          "6272:             JavascriptString* pStr2 = JavascriptConversion::ToString(*(Var*)bRef, requestContext);",
          "6274:             return JavascriptString::strcmp(pStr1, pStr2);",
          "6275:         }",
          "6276:     }",
          "6278:     static void hybridSort(__inout_ecount(length) Field(Var) *elements, uint32 length, CompareVarsInfo* compareInfo)",
          "6279:     {",
          "6282:         if (length > 512)",
          "6283:         {",
          "6284:             qsort_s(elements, length, compareVars, compareInfo);",
          "6285:             return;",
          "6286:         }",
          "6288:         for (int i = 1; i < (int)length; i++)",
          "6289:         {",
          "6290:             if (compareVars(compareInfo, elements + i, elements + i - 1) < 0) {",
          "6292:                 int first = 0;",
          "6293:                 int last = i - 1;",
          "6294:                 while (first <= last)",
          "6295:                 {",
          "6296:                     int middle = (first + last) / 2;",
          "6297:                     if (compareVars(compareInfo, elements + i, elements + middle) < 0)",
          "6298:                     {",
          "6299:                         last = middle - 1;",
          "6300:                     }",
          "6301:                     else",
          "6302:                     {",
          "6303:                         first = middle + 1;",
          "6304:                     }",
          "6305:                 }",
          "6308:                 Var value = elements[i];",
          "6309:                 MoveArray(elements + first + 1, elements + first, (i - first));",
          "6310:                 elements[first] = value;",
          "6311:             }",
          "6312:         }",
          "6313:     }",
          "6315:     void JavascriptArray::Sort(RecyclableObject* compFn)",
          "6316:     {",
          "6317:         JS_REENTRANCY_LOCK(jsReentLock, this->GetScriptContext()->GetThreadContext());",
          "6319:         if (length <= 1)",
          "6320:         {",
          "6321:             return;",
          "6322:         }",
          "6324:         this->EnsureHead<Var>();",
          "6325:         ScriptContext* scriptContext = this->GetScriptContext();",
          "6326:         Recycler* recycler = scriptContext->GetRecycler();",
          "6328:         CompareVarsInfo cvInfo;",
          "6329:         cvInfo.scriptContext = scriptContext;",
          "6330:         cvInfo.compFn = compFn;",
          "6332:         Assert(head != nullptr);",
          "6335:         ClearSegmentMap();",
          "6337:         uint32 countUndefined = 0;",
          "6338:         SparseArraySegment<Var>* startSeg = SparseArraySegment<Var>::From(head);",
          "6341:         uint32 saveLength = length;",
          "6343:         head = const_cast<SparseArraySegmentBase*>(EmptySegment);",
          "6344:         SetFlags(DynamicObjectFlags::None);",
          "6345:         this->InvalidateLastUsedSegment();",
          "6346:         length = 0;",
          "6348:         TryFinally([&]()",
          "6349:         {",
          "6351:             if (startSeg->next == nullptr) // Single segment fast path",
          "6352:             {",
          "6353:                 if (compFn != nullptr)",
          "6354:                 {",
          "6355:                     countUndefined = startSeg->RemoveUndefined(scriptContext);",
          "6357: #ifdef VALIDATE_ARRAY",
          "6358:                     ValidateSegment(startSeg);",
          "6359: #endif",
          "6360:                     JS_REENTRANT(jsReentLock, hybridSort(startSeg->elements, startSeg->length, &cvInfo));",
          "6361:                 }",
          "6362:                 else",
          "6363:                 {",
          "6364:                     JS_REENTRANT(jsReentLock, countUndefined = sort(startSeg->elements, &startSeg->length, scriptContext));",
          "6365:                 }",
          "6366:                 head = startSeg;",
          "6367:             }",
          "6368:             else",
          "6369:             {",
          "6370:                 SparseArraySegment<Var>* allElements = SparseArraySegment<Var>::AllocateSegment(recycler, 0, 0, nullptr);",
          "6371:                 SparseArraySegment<Var>* next = startSeg;",
          "6373:                 uint32 nextIndex = 0;",
          "6375:                 while (next)",
          "6376:                 {",
          "6377:                     countUndefined += next->RemoveUndefined(scriptContext);",
          "6378:                     if (next->length != 0)",
          "6379:                     {",
          "6380:                         allElements = SparseArraySegment<Var>::CopySegment(recycler, allElements, nextIndex, next, next->left, next->length);",
          "6381:                     }",
          "6382:                     next = SparseArraySegment<Var>::From(next->next);",
          "6383:                     nextIndex = allElements->length;",
          "6385: #ifdef VALIDATE_ARRAY",
          "6386:                     ValidateSegment(allElements);",
          "6387: #endif",
          "6388:                 }",
          "6390:                 if (compFn != nullptr)",
          "6391:                 {",
          "6392:                     JS_REENTRANT(jsReentLock, hybridSort(allElements->elements, allElements->length, &cvInfo));",
          "6393:                 }",
          "6394:                 else",
          "6395:                 {",
          "6396:                     JS_REENTRANT(jsReentLock, sort(allElements->elements, &allElements->length, scriptContext));",
          "6397:                 }",
          "6399:                 head = allElements;",
          "6400:                 head->next = nullptr;",
          "6401:             }",
          "6402:         },",
          "6403:         [&](bool hasException)",
          "6404:         {",
          "6405:             length = saveLength;",
          "6406:             ClearSegmentMap(); // Dump the segmentMap again in case user compare function rebuilds it",
          "6407:             if (hasException)",
          "6408:             {",
          "6409:                 head = startSeg;",
          "6410:                 this->InvalidateLastUsedSegment();",
          "6411:             }",
          "6412:         });",
          "6414: #if DEBUG",
          "6415:         {",
          "6416:             uint32 countNull = 0;",
          "6417:             uint32 index = head->length - 1;",
          "6418:             while (countNull < head->length)",
          "6419:             {",
          "6420:                 if (SparseArraySegment<Var>::From(head)->elements[index] != NULL)",
          "6421:                 {",
          "6422:                     break;",
          "6423:                 }",
          "6424:                 index--;",
          "6425:                 countNull++;",
          "6426:             }",
          "6427:             AssertMsg(countNull == 0, \"No null expected at the end\");",
          "6428:         }",
          "6429: #endif",
          "6431:         if (countUndefined != 0)",
          "6432:         {",
          "6434:             uint32 newLength = head->length + countUndefined;",
          "6435:             if (newLength > head->size)",
          "6436:             {",
          "6437:                 head = SparseArraySegment<Var>::From(head)->GrowByMin(recycler, newLength - head->size);",
          "6438:             }",
          "6440:             Var undefined = scriptContext->GetLibrary()->GetUndefined();",
          "6441:             for (uint32 i = head->length; i < newLength; i++)",
          "6442:             {",
          "6443:                 SparseArraySegment<Var>::From(head)->elements[i] = undefined;",
          "6444:             }",
          "6445:             head->length = newLength;",
          "6446:         }",
          "6447:         SetHasNoMissingValues();",
          "6448:         this->InvalidateLastUsedSegment();",
          "6450: #ifdef VALIDATE_ARRAY",
          "6451:         ValidateArray();",
          "6452: #endif",
          "6453:         return;",
          "6454:     }",
          "6456:     uint32 JavascriptArray::sort(__inout_ecount(*len) Field(Var) *orig, uint32 *len, ScriptContext *scriptContext)",
          "6457:     {",
          "6458:         uint32 count = 0, countUndefined = 0;",
          "6459:         Element *elements = RecyclerNewArrayZ(scriptContext->GetRecycler(), Element, *len);",
          "6460:         RecyclableObject *undefined = scriptContext->GetLibrary()->GetUndefined();",
          "6466:         for (uint32 i = 0; i < *len; ++i)",
          "6467:         {",
          "6468:             if (!SparseArraySegment<Var>::IsMissingItem(&orig[i]))",
          "6469:             {",
          "6470:                 if (!JavascriptOperators::IsUndefinedObject(orig[i], undefined))",
          "6471:                 {",
          "6472:                     elements[count].Value = orig[i];",
          "6473:                     elements[count].StringValue =  JavascriptConversion::ToString(orig[i], scriptContext);",
          "6475:                     count++;",
          "6476:                 }",
          "6477:                 else",
          "6478:                 {",
          "6479:                     countUndefined++;",
          "6480:                 }",
          "6481:             }",
          "6482:         }",
          "6484:         if (count > 0)",
          "6485:         {",
          "6486:             SortElements(elements, 0, count - 1);",
          "6488:             for (uint32 i = 0; i < count; ++i)",
          "6489:             {",
          "6490:                 orig[i] = elements[i].Value;",
          "6491:             }",
          "6492:         }",
          "6494:         for (uint32 i = count + countUndefined; i < *len; ++i)",
          "6495:         {",
          "6496:             orig[i] = SparseArraySegment<Var>::GetMissingItem();",
          "6497:         }",
          "6500:         return countUndefined;",
          "6501:     }",
          "6503:     int __cdecl JavascriptArray::CompareElements(void* context, const void* elem1, const void* elem2)",
          "6504:     {",
          "6505:         const Element* element1 = static_cast<const Element*>(elem1);",
          "6506:         const Element* element2 = static_cast<const Element*>(elem2);",
          "6508:         Assert(element1 != NULL);",
          "6509:         Assert(element2 != NULL);",
          "6511:         return JavascriptString::strcmp(element1->StringValue, element2->StringValue);",
          "6512:     }",
          "6514:     void JavascriptArray::SortElements(Element* elements, uint32 left, uint32 right)",
          "6515:     {",
          "6517:         qsort_s<Element, Field(Var)>(elements, right - left + 1, CompareElements, this);",
          "6518:     }",
          "6520:     Var JavascriptArray::EntrySort(RecyclableObject* function, CallInfo callInfo, ...)",
          "6521:     {",
          "6522:         PROBE_STACK(function->GetScriptContext(), Js::Constants::MinStackDefault);",
          "6524:         ARGUMENTS(args, callInfo);",
          "6525:         ScriptContext* scriptContext = function->GetScriptContext();",
          "6526:         JS_REENTRANCY_LOCK(jsReentLock, scriptContext->GetThreadContext());",
          "6527:         AUTO_TAG_NATIVE_LIBRARY_ENTRY(function, callInfo, _u(\"Array.prototype.sort\"));",
          "6529:         Assert(!(callInfo.Flags & CallFlags_New));",
          "6531:         AssertMsg(args.Info.Count >= 1, \"Should have at least one argument\");",
          "6533:         RecyclableObject* compFn = NULL;",
          "6534:         if (args.Info.Count > 1)",
          "6535:         {",
          "6536:             if (JavascriptConversion::IsCallable(args[1]))",
          "6537:             {",
          "6538:                 compFn = RecyclableObject::FromVar(args[1]);",
          "6539:             }",
          "6540:             else",
          "6541:             {",
          "6542:                 TypeId typeId = JavascriptOperators::GetTypeId(args[1]);",
          "6546:                 bool useDefaultComparer = typeId == TypeIds_Undefined;",
          "6547:                 if (!useDefaultComparer)",
          "6548:                 {",
          "6549:                     JavascriptError::ThrowTypeError(scriptContext, JSERR_FunctionArgument_NeedInternalObject, _u(\"Array.prototype.sort\"));",
          "6550:                 }",
          "6551:             }",
          "6552:         }",
          "6554:         if (JavascriptArray::Is(args[0]))",
          "6555:         {",
          "6556: #if ENABLE_COPYONACCESS_ARRAY",
          "6557:             JavascriptLibrary::CheckAndConvertCopyOnAccessNativeIntArray<Var>(args[0]);",
          "6558: #endif",
          "6560:             JavascriptArray *arr = JavascriptArray::FromVar(args[0]);",
          "6562:             if (arr->length <= 1)",
          "6563:             {",
          "6564:                 return args[0];",
          "6565:             }",
          "6567:             if(arr->IsFillFromPrototypes())",
          "6568:             {",
          "6569:                 JS_REENTRANT(jsReentLock, arr->FillFromPrototypes(0, arr->length)); // We need find all missing value from [[proto]] object",
          "6570:             }",
          "6577: #if defined(_M_X64_OR_ARM64)",
          "6578:             if(compFn && JavascriptNativeFloatArray::Is(arr))",
          "6579:             {",
          "6580:                 arr = JavascriptNativeFloatArray::ConvertToVarArray((JavascriptNativeFloatArray*)arr);",
          "6581:                 JS_REENTRANT(jsReentLock, arr->Sort(compFn));",
          "6582:                 arr = arr->ConvertToNativeArrayInPlace<JavascriptNativeFloatArray, double>(arr);",
          "6583:             }",
          "6584:             else",
          "6585:             {",
          "6586:                 EnsureNonNativeArray(arr);",
          "6587:                 JS_REENTRANT(jsReentLock, arr->Sort(compFn));",
          "6588:             }",
          "6589: #else",
          "6590:             if(compFn && JavascriptNativeIntArray::Is(arr))",
          "6591:             {",
          "6593:                 arr = JavascriptNativeIntArray::ConvertToVarArray((JavascriptNativeIntArray*)arr);",
          "6594:                 JS_REENTRANT(jsReentLock, arr->Sort(compFn));",
          "6595:                 arr = arr->ConvertToNativeArrayInPlace<JavascriptNativeIntArray, int32>(arr);",
          "6596:             }",
          "6597:             else",
          "6598:             {",
          "6599:                 EnsureNonNativeArray(arr);",
          "6600:                 JS_REENTRANT(jsReentLock, arr->Sort(compFn));",
          "6601:             }",
          "6602: #endif",
          "6604:         }",
          "6605:         else",
          "6606:         {",
          "6607:             RecyclableObject* pObj = nullptr;",
          "6608:             if (FALSE == JavascriptConversion::ToObject(args[0], scriptContext, &pObj))",
          "6609:             {",
          "6610:                 JavascriptError::ThrowTypeError(scriptContext, JSERR_This_NullOrUndefined, _u(\"Array.prototype.sort\"));",
          "6611:             }",
          "6612:             JS_REENTRANT(jsReentLock,",
          "6613:                 uint32 len = JavascriptConversion::ToUInt32(JavascriptOperators::OP_GetLength(pObj, scriptContext), scriptContext));",
          "6614:             JavascriptArray* sortArray = scriptContext->GetLibrary()->CreateArray(len);",
          "6615:             sortArray->EnsureHead<Var>();",
          "6616:             ThrowTypeErrorOnFailureHelper h(scriptContext, _u(\"Array.prototype.sort\"));",
          "6618:             BEGIN_TEMP_ALLOCATOR(tempAlloc, scriptContext, _u(\"Runtime\"))",
          "6619:             {",
          "6620:                 JsUtil::List<uint32, ArenaAllocator>* indexList = JsUtil::List<uint32, ArenaAllocator>::New(tempAlloc);",
          "6622:                 for (uint32 i = 0; i < len; i++)",
          "6623:                 {",
          "6624:                     Var item;",
          "6625:                     JS_REENTRANT(jsReentLock, BOOL gotItem = JavascriptOperators::GetItem(pObj, i, &item, scriptContext));",
          "6626:                     if (gotItem)",
          "6627:                     {",
          "6628:                         indexList->Add(i);",
          "6629:                         sortArray->DirectSetItemAt(i, item);",
          "6630:                     }",
          "6631:                 }",
          "6632:                 if (indexList->Count() > 0)",
          "6633:                 {",
          "6634:                     if (sortArray->length > 1)",
          "6635:                     {",
          "6636:                         sortArray->FillFromPrototypes(0, sortArray->length); // We need find all missing value from [[proto]] object",
          "6637:                     }",
          "6638:                     JS_REENTRANT(jsReentLock, sortArray->Sort(compFn));",
          "6640:                     uint32 removeIndex = sortArray->head->length;",
          "6641:                     for (uint32 i = 0; i < removeIndex; i++)",
          "6642:                     {",
          "6643:                         AssertMsg(!SparseArraySegment<Var>::IsMissingItem(&SparseArraySegment<Var>::From(sortArray->head)->elements[i]), \"No gaps expected in sorted array\");",
          "6644:                         JS_REENTRANT(jsReentLock, h.ThrowTypeErrorOnFailure(JavascriptOperators::SetItem(pObj, pObj, i, SparseArraySegment<Var>::From(sortArray->head)->elements[i], scriptContext)));",
          "6645:                     }",
          "6646:                     for (int i = 0; i < indexList->Count(); i++)",
          "6647:                     {",
          "6648:                         uint32 value = indexList->Item(i);",
          "6649:                         if (value >= removeIndex)",
          "6650:                         {",
          "6651:                             JS_REENTRANT(jsReentLock, h.ThrowTypeErrorOnFailure((JavascriptOperators::DeleteItem(pObj, value))));",
          "6652:                         }",
          "6653:                     }",
          "6654:                 }",
          "6656:             }",
          "6657:             END_TEMP_ALLOCATOR(tempAlloc, scriptContext);",
          "6658:         }",
          "6659:         return args[0];",
          "6660:     }",
          "6662:     Var JavascriptArray::EntrySplice(RecyclableObject* function, CallInfo callInfo, ...)",
          "6663:     {",
          "6664:         PROBE_STACK(function->GetScriptContext(), Js::Constants::MinStackDefault);",
          "6666:         ARGUMENTS(args, callInfo);",
          "6667:         ScriptContext* scriptContext = function->GetScriptContext();",
          "6668:         JS_REENTRANCY_LOCK(jsReentLock, scriptContext->GetThreadContext());",
          "6670:         Assert(!(callInfo.Flags & CallFlags_New));",
          "6672:         AssertMsg(args.Info.Count >= 1, \"Should have at least one argument\");",
          "6674:         JavascriptArray* pArr = 0;",
          "6675:         RecyclableObject* pObj = 0;",
          "6676:         uint64 start = 0u;",
          "6677:         uint64 deleteLen = 0u;",
          "6678:         uint64 length = 0u;",
          "6680:         JS_REENTRANT(jsReentLock, TryGetArrayAndLength(args[0], scriptContext, _u(\"Array.prototype.splice\"), &pArr, &pObj, &length));",
          "6682:         switch (args.Info.Count)",
          "6683:         {",
          "6684:         case 1:",
          "6685:             start = length;",
          "6686:             deleteLen = 0u;",
          "6687:             break;",
          "6689:         case 2:",
          "6690:             JS_REENTRANT(jsReentLock, start = GetFromIndex(args[1], length, scriptContext));",
          "6691:             deleteLen = length - start;",
          "6692:             break;",
          "6694:         default:",
          "6695:             JS_REENTRANT(jsReentLock, start = GetFromIndex(args[1], length, scriptContext),",
          "6696:                 deleteLen = GetFromIndex(args[2], (length - start), scriptContext, false));",
          "6697:             break;",
          "6698:         }",
          "6701:         if (pArr && !JavascriptArray::Is(pObj))",
          "6702:         {",
          "6703:             AssertOrFailFastMsg(ES5Array::Is(pObj), \"The array should have been converted to an ES5Array\");",
          "6704:             pArr = nullptr;",
          "6705:         }",
          "6707:         Var* insertArgs = args.Info.Count > 3 ? &args.Values[3] : nullptr;",
          "6708:         uint32 insertLen = args.Info.Count > 3 ? args.Info.Count - 3 : 0;",
          "6710:         if (pArr != nullptr)",
          "6711:         {",
          "6713:             _Analysis_assume_(length <= UINT_MAX);",
          "6714:             JS_REENTRANT_UNLOCK(jsReentLock,",
          "6715:                 return TryArraySplice(pArr, (uint32)start, (uint32)length, (uint32)deleteLen, insertArgs, insertLen, scriptContext));",
          "6716:         }",
          "6718:         uint64 newLen = (length - deleteLen) + insertLen;",
          "6719:         if (newLen > UINT_MAX || length > UINT_MAX || (length + insertLen) > UINT_MAX)",
          "6720:         {",
          "6721:             JS_REENTRANT_UNLOCK(jsReentLock,",
          "6722:                 return ObjectSpliceHelper<uint64>(pObj, length, start, deleteLen, (Var*)insertArgs, insertLen, scriptContext, nullptr));",
          "6723:         }",
          "6724:         else",
          "6725:         {",
          "6726:             JS_REENTRANT_UNLOCK(jsReentLock,",
          "6727:                 return ObjectSpliceHelper<uint32>(pObj, (uint32)length, (uint32)start, (uint32)deleteLen, (Var*)insertArgs, insertLen, scriptContext, nullptr));",
          "6728:         }",
          "6729:     }",
          "6731:     inline BOOL JavascriptArray::IsSingleSegmentArray() const",
          "6732:     {",
          "6733:         return nullptr == head->next;",
          "6734:     }",
          "6736:     template<typename T>",
          "6737:     void JavascriptArray::ArraySegmentSpliceHelper(JavascriptArray *pnewArr, SparseArraySegment<T> *seg, SparseArraySegment<T> **prev,",
          "6738:                                                     uint32 start, uint32 deleteLen, Var* insertArgs, uint32 insertLen, Recycler *recycler)",
          "6739:     {",
          "6741:         uint32 relativeStart    = start - seg->left;  // This will be different from start when head->left is non zero -",
          "6744:         uint32 headDeleteLen    = min(start + deleteLen , seg->left + seg->length) - start;   // actual number of elements to delete in",
          "6747:         uint32 newHeadLen       = seg->length - headDeleteLen + insertLen;     // new length of the head after splice",
          "6750:         if (headDeleteLen != 0)",
          "6751:         {",
          "6752:             pnewArr->InvalidateLastUsedSegment();",
          "6753:             pnewArr->head = SparseArraySegment<T>::CopySegment(recycler, SparseArraySegment<T>::From(pnewArr->head), 0, seg, start, headDeleteLen);",
          "6754:         }",
          "6756:         if (newHeadLen != 0)",
          "6757:         {",
          "6758:             if (seg->size < newHeadLen)",
          "6759:             {",
          "6760:                 if (seg->next)",
          "6761:                 {",
          "6763:                     seg = seg->GrowByMinMax(recycler, newHeadLen - seg->size, seg->next->left - deleteLen + insertLen - seg->left - seg->size);",
          "6764:                 }",
          "6765:                 else",
          "6766:                 {",
          "6767:                     seg = seg->GrowByMin(recycler, newHeadLen - seg->size);",
          "6768:                 }",
          "6769: #ifdef VALIDATE_ARRAY",
          "6770:                 ValidateSegment(seg);",
          "6771: #endif",
          "6772:             }",
          "6775:             if (headDeleteLen != insertLen)",
          "6776:             {",
          "6777:                 uint32 noElementsToMove = seg->length - (relativeStart + headDeleteLen);",
          "6778:                 MoveArray(seg->elements + relativeStart + insertLen,",
          "6779:                             seg->elements + relativeStart + headDeleteLen,",
          "6780:                             noElementsToMove);",
          "6781:                 if (newHeadLen < seg->length) // truncate if necessary",
          "6782:                 {",
          "6783:                     seg->Truncate(seg->left + newHeadLen); // set end elements to null so that when we introduce null elements we are safe",
          "6784:                 }",
          "6785:                 seg->length = newHeadLen;",
          "6786:             }",
          "6788:             if (insertLen > 0)",
          "6789:             {",
          "6790:                 Assert(!VirtualTableInfo<JavascriptNativeIntArray>::HasVirtualTable(pnewArr) &&",
          "6791:                    !VirtualTableInfo<JavascriptNativeFloatArray>::HasVirtualTable(pnewArr));",
          "6794:                 CopyArray(seg->elements + relativeStart, insertLen,",
          "6795:                           reinterpret_cast<const T*>(insertArgs), insertLen);",
          "6796:             }",
          "6798:         }",
          "6799:         else",
          "6800:         {",
          "6802:         }",
          "6803:     }",
          "6805:     template<typename T>",
          "6806:     void JavascriptArray::ArraySpliceHelper(JavascriptArray* pnewArr, JavascriptArray* pArr, uint32 start, uint32 deleteLen, Var* insertArgs, uint32 insertLen, ScriptContext *scriptContext)",
          "6807:     {",
          "6809:         Recycler *recycler  = scriptContext->GetRecycler();",
          "6811:         Field(SparseArraySegmentBase*)* prevSeg  = &pArr->head;        // holds the next pointer of previous",
          "6812:         Field(SparseArraySegmentBase*)* prevPrevSeg  = &pArr->head;    // this holds the previous pointer to prevSeg dirty trick.",
          "6813:         SparseArraySegmentBase* savePrev = nullptr;",
          "6815:         Assert(pArr->head); // We should never have a null head.",
          "6816:         pArr->EnsureHead<T>();",
          "6817:         SparseArraySegment<T>* startSeg = SparseArraySegment<T>::From(pArr->head);",
          "6819:         const uint32 limit = start + deleteLen;",
          "6820:         uint32 rightLimit;",
          "6821:         if (UInt32Math::Add(startSeg->left, startSeg->size, &rightLimit))",
          "6822:         {",
          "6823:             rightLimit = JavascriptArray::MaxArrayLength;",
          "6824:         }",
          "6827:         while (startSeg && (rightLimit <= start))",
          "6828:         {",
          "6829:             savePrev = startSeg;",
          "6830:             prevPrevSeg = prevSeg;",
          "6831:             prevSeg = &startSeg->next;",
          "6832:             startSeg = SparseArraySegment<T>::From(startSeg->next);",
          "6834:             if (startSeg)",
          "6835:             {",
          "6836:                 if (UInt32Math::Add(startSeg->left, startSeg->size, &rightLimit))",
          "6837:                 {",
          "6838:                     rightLimit = JavascriptArray::MaxArrayLength;",
          "6839:                 }",
          "6840:             }",
          "6841:         }",
          "6844:         SparseArraySegmentBase* inlineHeadSegment = nullptr;",
          "6845:         bool hasInlineSegment = false;",
          "6847:         if (JavascriptNativeArray::Is(pArr))",
          "6848:         {",
          "6849:             if (JavascriptNativeFloatArray::Is(pArr))",
          "6850:             {",
          "6851:                 inlineHeadSegment = DetermineInlineHeadSegmentPointer<JavascriptNativeFloatArray, 0, true>((JavascriptNativeFloatArray*)pArr);",
          "6852:             }",
          "6853:             else if (JavascriptNativeIntArray::Is(pArr))",
          "6854:             {",
          "6855:                 inlineHeadSegment = DetermineInlineHeadSegmentPointer<JavascriptNativeIntArray, 0, true>((JavascriptNativeIntArray*)pArr);",
          "6856:             }",
          "6857:             Assert(inlineHeadSegment);",
          "6858:             hasInlineSegment = (startSeg == (SparseArraySegment<T>*)inlineHeadSegment);",
          "6859:         }",
          "6860:         else",
          "6861:         {",
          "6867:             hasInlineSegment = HasInlineHeadSegment(pArr->head->length);",
          "6868:         }",
          "6870:         if (startSeg)",
          "6871:         {",
          "6873:             if (startSeg->left <= start && (startSeg->left + startSeg->length) >= limit)",
          "6874:             {",
          "6876:                 SparseArraySegmentBase *nextSeg = startSeg->next;",
          "6878:                 JavascriptArray::ArraySegmentSpliceHelper(pnewArr, (SparseArraySegment<T>*)startSeg, (SparseArraySegment<T>**)prevSeg, start, deleteLen, insertArgs, insertLen, recycler);",
          "6879:                 while (nextSeg)",
          "6880:                 {",
          "6882:                     nextSeg->left = nextSeg->left - deleteLen + insertLen;",
          "6883:                     if (nextSeg->next == nullptr)",
          "6884:                     {",
          "6885:                         nextSeg->EnsureSizeInBound();",
          "6886:                     }",
          "6887:                     nextSeg = nextSeg->next;",
          "6888:                 }",
          "6889:                 if (*prevSeg)",
          "6890:                 {",
          "6891:                     (*prevSeg)->EnsureSizeInBound();",
          "6892:                 }",
          "6893:                 return;",
          "6894:             }",
          "6895:             else",
          "6896:             {",
          "6897:                 SparseArraySegment<T>* newHeadSeg = nullptr; // pnewArr->head is null",
          "6898:                 Field(SparseArraySegmentBase*)* prevNewHeadSeg = &pnewArr->head;",
          "6907:                 if (startSeg->left < start)",
          "6908:                 {",
          "6909:                     if (start < startSeg->left + startSeg->length)",
          "6910:                     {",
          "6911:                         uint32 headDeleteLen = startSeg->left + startSeg->length - start;",
          "6913:                         if (startSeg->next)",
          "6914:                         {",
          "6916:                             newHeadSeg = SparseArraySegment<T>::template AllocateSegmentImpl<false>(recycler, 0, headDeleteLen, headDeleteLen, nullptr);",
          "6917:                         }",
          "6918:                         else",
          "6919:                         {",
          "6920:                             newHeadSeg = SparseArraySegment<T>::AllocateSegment(recycler, 0, headDeleteLen, headDeleteLen, nullptr);",
          "6921:                         }",
          "6922:                         newHeadSeg = SparseArraySegment<T>::CopySegment(recycler, newHeadSeg, 0, startSeg, start, headDeleteLen);",
          "6923:                         newHeadSeg->next = nullptr;",
          "6925:                         prevNewHeadSeg = &newHeadSeg->next;",
          "6926:                         startSeg->Truncate(start);",
          "6927:                     }",
          "6928:                     savePrev = startSeg;",
          "6929:                     prevPrevSeg = prevSeg;",
          "6930:                     prevSeg = &startSeg->next;",
          "6931:                     startSeg = SparseArraySegment<T>::From(startSeg->next);",
          "6932:                 }",
          "6935:                 else if (hasInlineSegment && nullptr != startSeg)",
          "6936:                 {",
          "6938:                     if (startSeg->left  <= start && start < startSeg->left + startSeg->length)",
          "6939:                     {",
          "6940:                         uint32 headDeleteLen = startSeg->left + startSeg->length - start;",
          "6941:                         if (startSeg->next)",
          "6942:                         {",
          "6944:                             newHeadSeg = SparseArraySegment<T>::template AllocateSegmentImpl<false>(recycler, 0, headDeleteLen, headDeleteLen, nullptr);",
          "6945:                         }",
          "6946:                         else",
          "6947:                         {",
          "6948:                             newHeadSeg = SparseArraySegment<T>::AllocateSegment(recycler, 0, headDeleteLen, headDeleteLen, nullptr);",
          "6949:                         }",
          "6950:                         newHeadSeg = SparseArraySegment<T>::CopySegment(recycler, newHeadSeg, 0, startSeg, start, headDeleteLen);",
          "6952:                         prevNewHeadSeg = &newHeadSeg->next;",
          "6956:                         startSeg = SparseArraySegment<T>::From(startSeg->next);",
          "6957:                     }",
          "6959:                     else if (startSeg->left == 0 && startSeg->length == 0)",
          "6960:                     {",
          "6961:                         Assert(startSeg->size != 0);",
          "6963:                         startSeg = SparseArraySegment<T>::From(startSeg->next);",
          "6964:                     }",
          "6965:                 }",
          "6967:                 SparseArraySegmentBase *temp = nullptr;",
          "6968:                 while (startSeg && (startSeg->left + startSeg->length) <= limit)",
          "6969:                 {",
          "6970:                     temp = startSeg->next;",
          "6973:                     startSeg->left = startSeg->left - start;",
          "6974:                     startSeg->next = nullptr;",
          "6976:                     prevNewHeadSeg = &startSeg->next;",
          "6980:                     startSeg = (SparseArraySegment<T>*)temp;",
          "6981:                 }",
          "6986:                 bool dummyHeadNodeInserted = false;",
          "6987:                 if (!savePrev && (!startSeg || startSeg->left != 0))",
          "6988:                 {",
          "6989:                     Assert(pArr->head == startSeg);",
          "6990:                     pArr->EnsureHeadStartsFromZero<T>(recycler);",
          "6991:                     Assert(pArr->head && pArr->head->next == startSeg);",
          "6993:                     savePrev = pArr->head;",
          "6994:                     prevPrevSeg = prevSeg;",
          "6995:                     prevSeg = &pArr->head->next;",
          "6996:                     dummyHeadNodeInserted = true;",
          "6997:                 }",
          "7000:                 if (startSeg && (startSeg->left < limit))",
          "7001:                 {",
          "7003:                     uint32 headDeleteLen = start + deleteLen - startSeg->left ;",
          "7005:                     newHeadSeg = SparseArraySegment<T>::AllocateSegment(recycler, startSeg->left -  start, headDeleteLen, (SparseArraySegmentBase *)nullptr);",
          "7006:                     newHeadSeg = SparseArraySegment<T>::CopySegment(recycler, newHeadSeg, startSeg->left -  start, startSeg, startSeg->left, headDeleteLen);",
          "7007:                     newHeadSeg->next = nullptr;",
          "7009:                     prevNewHeadSeg = &newHeadSeg->next;",
          "7012:                     MoveArray(startSeg->elements, startSeg->elements + headDeleteLen, startSeg->length - headDeleteLen);",
          "7013:                     startSeg->left = startSeg->left + headDeleteLen; // We are moving the left ahead to point to the right index",
          "7014:                     startSeg->length = startSeg->length - headDeleteLen;",
          "7015:                     startSeg->Truncate(startSeg->left + startSeg->length);",
          "7016:                     startSeg->EnsureSizeInBound(); // Just truncated, size might exceed next.left",
          "7017:                 }",
          "7019:                 if (startSeg && ((startSeg->left - deleteLen + insertLen) == 0) && dummyHeadNodeInserted)",
          "7020:                 {",
          "7021:                     Assert(start + insertLen == 0);",
          "7023:                     pArr->head = startSeg;",
          "7024:                     savePrev = nullptr;",
          "7025:                     prevSeg = &pArr->head;",
          "7026:                 }",
          "7028:                 while (startSeg)",
          "7029:                 {",
          "7030:                     startSeg->left = startSeg->left - deleteLen + insertLen ;",
          "7031:                     if (startSeg->next == nullptr)",
          "7032:                     {",
          "7033:                         startSeg->EnsureSizeInBound();",
          "7034:                     }",
          "7035:                     startSeg = SparseArraySegment<T>::From(startSeg->next);",
          "7036:                 }",
          "7037:             }",
          "7038:         }",
          "7041:         pnewArr->head->EnsureSizeInBound();",
          "7042:         if (savePrev)",
          "7043:         {",
          "7044:             savePrev->EnsureSizeInBound();",
          "7045:         }",
          "7048:         if (insertLen > 0)",
          "7049:         {",
          "7050:             Assert(!JavascriptNativeIntArray::Is(pArr) && !JavascriptNativeFloatArray::Is(pArr));",
          "7053:             SparseArraySegment<T> *segInsert = nullptr;",
          "7056:             Assert(!savePrev || savePrev->left <= start);",
          "7057:             if (savePrev && (start - savePrev->left < savePrev->size))",
          "7058:             {",
          "7059:                 segInsert = (SparseArraySegment<T>*)savePrev;",
          "7060:                 uint32 spaceLeft = segInsert->size - (start - segInsert->left);",
          "7061:                 if(spaceLeft < insertLen)",
          "7062:                 {",
          "7063:                     if (!segInsert->next)",
          "7064:                     {",
          "7065:                         segInsert = segInsert->GrowByMin(recycler, insertLen - spaceLeft);",
          "7066:                     }",
          "7067:                     else",
          "7068:                     {",
          "7069:                         segInsert = segInsert->GrowByMinMax(recycler, insertLen - spaceLeft, segInsert->next->left - segInsert->left - segInsert->size);",
          "7070:                     }",
          "7071:                 }",
          "7073:                 segInsert->length = start + insertLen - segInsert->left;",
          "7074:             }",
          "7075:             else",
          "7076:             {",
          "7077:                 segInsert = SparseArraySegment<T>::AllocateSegment(recycler, start, insertLen, *prevSeg);",
          "7078:                 segInsert->next = *prevSeg;",
          "7080:                 savePrev = segInsert;",
          "7081:             }",
          "7083:             uint32 relativeStart = start - segInsert->left;",
          "7085:             CopyArray(segInsert->elements + relativeStart, insertLen,",
          "7086:                       reinterpret_cast<const T*>(insertArgs), insertLen);",
          "7087:         }",
          "7088:     }",
          "7090:     Var JavascriptArray::TryArraySplice(JavascriptArray* pArr, uint32 start, uint32 len, uint32 deleteLen,",
          "7091:         Var* insertArgs, uint32 insertLen, ScriptContext *scriptContext)",
          "7092:     {",
          "7093:         JS_REENTRANCY_LOCK(jsReentLock, scriptContext->GetThreadContext());",
          "7095:         Assert(pArr != nullptr);",
          "7097:         RecyclableObject* newObj = nullptr;",
          "7098:         Recycler *recycler = scriptContext->GetRecycler();",
          "7100:         ::Math::RecordOverflowPolicy newLenOverflow;",
          "7101:         uint32 newLen = UInt32Math::Add(len - deleteLen, insertLen, newLenOverflow); // new length of the array after splice",
          "7105:         if (deleteLen == insertLen)",
          "7106:         {",
          "7107:             JS_REENTRANT(jsReentLock, pArr->FillFromPrototypes(start, start + deleteLen));",
          "7108:         }",
          "7109:         else if (len)",
          "7110:         {",
          "7111:             JS_REENTRANT(jsReentLock, pArr->FillFromPrototypes(start, len));",
          "7112:         }",
          "7118:         if (newLenOverflow.HasOverflowed())",
          "7119:         {",
          "7120:             pArr = EnsureNonNativeArray(pArr);",
          "7121:             BigIndex dstIndex = MaxArrayLength;",
          "7123:             uint32 maxInsertLen = MaxArrayLength - start;",
          "7124:             if (insertLen > maxInsertLen)",
          "7125:             {",
          "7127:                 for (uint32 i = maxInsertLen; i < insertLen; i++)",
          "7128:                 {",
          "7129:                     pArr->DirectSetItemAt(dstIndex, insertArgs[i]);",
          "7130:                     ++dstIndex;",
          "7131:                 }",
          "7133:                 insertLen = maxInsertLen; // update",
          "7136:                 if (start + deleteLen < len)",
          "7137:                 {",
          "7138:                     pArr->TruncateToProperties(dstIndex, start + deleteLen);",
          "7139:                 }",
          "7140:             }",
          "7141:             else",
          "7142:             {",
          "7144:                 pArr->TruncateToProperties(dstIndex, MaxArrayLength - insertLen + deleteLen);",
          "7145:             }",
          "7147:             len = pArr->length; // update",
          "7148:             newLen = len - deleteLen + insertLen;",
          "7149:             Assert(newLen == MaxArrayLength);",
          "7150:         }",
          "7152:         if (insertArgs)",
          "7153:         {",
          "7154:             pArr = EnsureNonNativeArray(pArr);",
          "7155:         }",
          "7157:         bool isIntArray = false;",
          "7158:         bool isFloatArray = false;",
          "7159:         bool isBuiltinArrayCtor = true;",
          "7160:         JavascriptArray *newArr = nullptr;",
          "7163:         pArr->ClearSegmentMap();",
          "7167:         JS_REENTRANT(jsReentLock, newObj = ArraySpeciesCreate(pArr, deleteLen, scriptContext, nullptr, nullptr, &isBuiltinArrayCtor));",
          "7168:         if (newObj != nullptr)",
          "7169:         {",
          "7170:             pArr = EnsureNonNativeArray(pArr);",
          "7172:             if (JavascriptArray::Is(newObj))",
          "7173:             {",
          "7174: #if ENABLE_COPYONACCESS_ARRAY",
          "7175:                 JavascriptLibrary::CheckAndConvertCopyOnAccessNativeIntArray<Var>(newObj);",
          "7176: #endif",
          "7177:                 newArr = JavascriptArray::FromVar(newObj);",
          "7178:             }",
          "7179:         }",
          "7180:         else",
          "7182:         {",
          "7183:             pArr->GetArrayTypeAndConvert(&isIntArray, &isFloatArray);",
          "7184:             newArr = CreateNewArrayHelper(deleteLen, isIntArray, isFloatArray, pArr, scriptContext);",
          "7185: #if ENABLE_COPYONACCESS_ARRAY",
          "7186:             JavascriptLibrary::CheckAndConvertCopyOnAccessNativeIntArray<Var>(newArr);",
          "7187: #endif",
          "7188:         }",
          "7191:         if (newArr && isBuiltinArrayCtor && len == pArr->length)",
          "7192:         {",
          "7196:             if (pArr->IsSingleSegmentArray() && pArr->head->HasIndex(start))",
          "7197:             {",
          "7198:                 if (isIntArray)",
          "7199:                 {",
          "7200:                     ArraySegmentSpliceHelper<int32>(newArr, SparseArraySegment<int32>::From(pArr->head), (SparseArraySegment<int32>**)&pArr->head, start, deleteLen, insertArgs, insertLen, recycler);",
          "7201:                 }",
          "7202:                 else if (isFloatArray)",
          "7203:                 {",
          "7204:                     ArraySegmentSpliceHelper<double>(newArr, SparseArraySegment<double>::From(pArr->head), (SparseArraySegment<double>**)&pArr->head, start, deleteLen, insertArgs, insertLen, recycler);",
          "7205:                 }",
          "7206:                 else",
          "7207:                 {",
          "7208:                     ArraySegmentSpliceHelper<Var>(newArr, SparseArraySegment<Var>::From(pArr->head), (SparseArraySegment<Var>**)&pArr->head, start, deleteLen, insertArgs, insertLen, recycler);",
          "7209:                 }",
          "7215:                 newArr->SetHasNoMissingValues(pArr->HasNoMissingValues());",
          "7216:             }",
          "7217:             else",
          "7218:             {",
          "7219:                 if (isIntArray)",
          "7220:                 {",
          "7221:                     ArraySpliceHelper<int32>(newArr, pArr, start, deleteLen, insertArgs, insertLen, scriptContext);",
          "7222:                 }",
          "7223:                 else if (isFloatArray)",
          "7224:                 {",
          "7225:                     ArraySpliceHelper<double>(newArr, pArr, start, deleteLen, insertArgs, insertLen, scriptContext);",
          "7226:                 }",
          "7227:                 else",
          "7228:                 {",
          "7229:                     ArraySpliceHelper<Var>(newArr, pArr, start, deleteLen, insertArgs, insertLen, scriptContext);",
          "7230:                 }",
          "7233:                 pArr->SetHasNoMissingValues(false);",
          "7234:                 newArr->SetHasNoMissingValues(false);",
          "7235:             }",
          "7237:             if (isIntArray)",
          "7238:             {",
          "7239:                 pArr->EnsureHeadStartsFromZero<int32>(recycler);",
          "7240:                 newArr->EnsureHeadStartsFromZero<int32>(recycler);",
          "7241:             }",
          "7242:             else if (isFloatArray)",
          "7243:             {",
          "7244:                 pArr->EnsureHeadStartsFromZero<double>(recycler);",
          "7245:                 newArr->EnsureHeadStartsFromZero<double>(recycler);",
          "7246:             }",
          "7247:             else",
          "7248:             {",
          "7249:                 pArr->EnsureHeadStartsFromZero<Var>(recycler);",
          "7250:                 newArr->EnsureHeadStartsFromZero<Var>(recycler);",
          "7251:             }",
          "7253:             pArr->InvalidateLastUsedSegment();",
          "7261:             if (pArr->length != len)",
          "7262:             {",
          "7263:                 pArr->SetLength(newLen);",
          "7264:             }",
          "7265:             else",
          "7266:             {",
          "7267:                 pArr->length = newLen;",
          "7268:             }",
          "7270:             if (newArr->length != deleteLen)",
          "7271:             {",
          "7272:                 newArr->SetLength(deleteLen);",
          "7273:             }",
          "7274:             else",
          "7275:             {",
          "7276:                 newArr->length = deleteLen;",
          "7277:             }",
          "7279:             newArr->InvalidateLastUsedSegment();",
          "7281: #ifdef VALIDATE_ARRAY",
          "7282:             newArr->ValidateArray();",
          "7283:             pArr->ValidateArray();",
          "7284: #endif",
          "7285:             if (newLenOverflow.HasOverflowed())",
          "7286:             {",
          "7288:                 JavascriptError::ThrowRangeError(scriptContext, JSERR_ArrayLengthAssignIncorrect);",
          "7289:             }",
          "7291:             return newArr;",
          "7292:         }",
          "7294:         if (newLenOverflow.HasOverflowed())",
          "7295:         {",
          "7296:             JS_REENTRANT_UNLOCK(jsReentLock, return ObjectSpliceHelper<uint64>(pArr, len, start, deleteLen, insertArgs, insertLen, scriptContext, newObj));",
          "7297:         }",
          "7298:         else // Use uint32 version if no overflow",
          "7299:         {",
          "7300:             JS_REENTRANT_UNLOCK(jsReentLock, return ObjectSpliceHelper<uint32>(pArr, len, start, deleteLen, insertArgs, insertLen, scriptContext, newObj));",
          "7301:         }",
          "7303:     }",
          "7305:     template<typename T>",
          "7306:     RecyclableObject* JavascriptArray::ObjectSpliceHelper(RecyclableObject* pObj, T len, T start,",
          "7307:         T deleteLen, Var* insertArgs, uint32 insertLen, ScriptContext *scriptContext, RecyclableObject* pNewObj)",
          "7308:     {",
          "7309:         JS_REENTRANCY_LOCK(jsReentLock, scriptContext->GetThreadContext());",
          "7310:         JavascriptArray *pnewArr = nullptr;",
          "7312:         if (pNewObj == nullptr)",
          "7313:         {",
          "7314:             JS_REENTRANT(jsReentLock, pNewObj = ArraySpeciesCreate(pObj, deleteLen, scriptContext));",
          "7315:             if (pNewObj == nullptr)",
          "7316:             {",
          "7317:                 if (deleteLen > UINT_MAX)",
          "7318:                 {",
          "7319:                     JavascriptError::ThrowRangeError(scriptContext, JSERR_ArrayLengthConstructIncorrect);",
          "7320:                 }",
          "7322:                 pnewArr = scriptContext->GetLibrary()->CreateArray(static_cast<uint32>(deleteLen));",
          "7323:                 pnewArr->EnsureHead<Var>();",
          "7325:                 pNewObj = pnewArr;",
          "7326:             }",
          "7327:         }",
          "7329:         if (JavascriptArray::Is(pNewObj))",
          "7330:         {",
          "7331: #if ENABLE_COPYONACCESS_ARRAY",
          "7332:             JavascriptLibrary::CheckAndConvertCopyOnAccessNativeIntArray<Var>(pNewObj);",
          "7333: #endif",
          "7334:             pnewArr = JavascriptArray::FromVar(pNewObj);",
          "7335:         }",
          "7338:         if (pnewArr != nullptr)",
          "7339:         {",
          "7340:             for (uint32 i = 0; i < deleteLen; i++)",
          "7341:             {",
          "7342:                 JS_REENTRANT(jsReentLock, BOOL hasItem = JavascriptOperators::HasItem(pObj, start + i));",
          "7343:                 if (hasItem)",
          "7344:                 {",
          "7345:                     JS_REENTRANT(jsReentLock, Var element = JavascriptOperators::GetItem(pObj, start + i, scriptContext));",
          "7346:                     pnewArr->SetItem(i, element, PropertyOperation_None);",
          "7347:                 }",
          "7348:             }",
          "7349:         }",
          "7350:         else",
          "7351:         {",
          "7352:             BigIndex k = 0u;",
          "7353:             for (T i = 0u; i < deleteLen; i++)",
          "7354:             {",
          "7355:                 JS_REENTRANT(jsReentLock, BOOL hasItem = JavascriptOperators::HasItem(pObj, start + i));",
          "7356:                 if (hasItem)",
          "7357:                 {",
          "7358:                     Var element = nullptr;",
          "7359:                     JS_REENTRANT(jsReentLock, element = JavascriptOperators::GetItem(pObj, start + i, scriptContext),",
          "7360:                         ThrowErrorOnFailure(JavascriptArray::SetArrayLikeObjects(pNewObj, k, element), scriptContext, k));",
          "7361:                 }",
          "7362:                 ++k;",
          "7363:             }",
          "7364:         }",
          "7366:         ThrowTypeErrorOnFailureHelper h(scriptContext, _u(\"Array.prototype.splice\"));",
          "7369:         if (insertLen > deleteLen) // Might overflow max array length",
          "7370:         {",
          "7372:             JS_REENTRANT(jsReentLock, Unshift<BigIndex, T>(pObj, start + insertLen, start + deleteLen, len, scriptContext));",
          "7373:         }",
          "7374:         else if (insertLen < deleteLen) // Won't overflow max array length",
          "7375:         {",
          "7376:             T j = 0;",
          "7377:             for (T i = start + deleteLen; i < len; i++)",
          "7378:             {",
          "7379:                 JS_REENTRANT(jsReentLock, BOOL hasItem = JavascriptOperators::HasItem(pObj, i));",
          "7380:                 if (hasItem)",
          "7381:                 {",
          "7382:                     Var element = nullptr;",
          "7383:                     JS_REENTRANT(jsReentLock, element = JavascriptOperators::GetItem(pObj, i, scriptContext),",
          "7384:                         h.ThrowTypeErrorOnFailure(JavascriptOperators::SetItem(pObj, pObj, start + insertLen + j, element, scriptContext, PropertyOperation_ThrowIfNotExtensible)));",
          "7385:                 }",
          "7386:                 else",
          "7387:                 {",
          "7388:                     JS_REENTRANT(jsReentLock,",
          "7389:                         h.ThrowTypeErrorOnFailure(JavascriptOperators::DeleteItem(pObj, start + insertLen + j, PropertyOperation_ThrowOnDeleteIfNotConfig)));",
          "7390:                 }",
          "7391:                 j++;",
          "7392:             }",
          "7395:             for (T i = len; i > len - deleteLen + insertLen; i--)",
          "7396:             {",
          "7397:                 JS_REENTRANT(jsReentLock, h.ThrowTypeErrorOnFailure(JavascriptOperators::DeleteItem(pObj, i - 1, PropertyOperation_ThrowOnDeleteIfNotConfig)));",
          "7398:             }",
          "7399:         }",
          "7401:         if (insertLen > 0)",
          "7402:         {",
          "7403:             T dstIndex = start; // insert index might overflow max array length",
          "7404:             for (uint32 i = 0; i < insertLen; i++)",
          "7405:             {",
          "7406:                 JS_REENTRANT(jsReentLock,",
          "7407:                     h.ThrowTypeErrorOnFailure(IndexTrace<BigIndex>::SetItem(pObj, dstIndex, insertArgs[i], PropertyOperation_ThrowIfNotExtensible)));",
          "7408:                 ++dstIndex;",
          "7409:             }",
          "7410:         }",
          "7413:         T newLen = T(len - deleteLen) + insertLen;",
          "7414:         JS_REENTRANT(jsReentLock,",
          "7415:             h.ThrowTypeErrorOnFailure(JavascriptOperators::SetProperty(pObj, pObj, PropertyIds::length, IndexTrace<BigIndex>::ToNumber(newLen, scriptContext), scriptContext, PropertyOperation_ThrowIfNotExtensible)),",
          "7416:             h.ThrowTypeErrorOnFailure(JavascriptOperators::SetProperty(pNewObj, pNewObj, PropertyIds::length, IndexTrace<BigIndex>::ToNumber(deleteLen, scriptContext), scriptContext, PropertyOperation_ThrowIfNotExtensible)));",
          "7417: #ifdef VALIDATE_ARRAY",
          "7418:         if (pnewArr)",
          "7419:         {",
          "7420:             pnewArr->ValidateArray();",
          "7421:         }",
          "7422: #endif",
          "7423:         return pNewObj;",
          "7424:     }",
          "7426:     Var JavascriptArray::EntryToLocaleString(RecyclableObject* function, CallInfo callInfo, ...)",
          "7427:     {",
          "7428:         PROBE_STACK(function->GetScriptContext(), Js::Constants::MinStackDefault);",
          "7430:         ARGUMENTS(args, callInfo);",
          "7431:         ScriptContext* scriptContext = function->GetScriptContext();",
          "7432:         JS_REENTRANCY_LOCK(jsReentLock, scriptContext->GetThreadContext());",
          "7434:         Assert(!(callInfo.Flags & CallFlags_New));",
          "7436:         if (args.Info.Count == 0)",
          "7437:         {",
          "7438:             JavascriptError::ThrowTypeError(scriptContext, JSERR_This_NeedObject, _u(\"Array.prototype.toLocaleString\"));",
          "7439:         }",
          "7441:         if (JavascriptArray::IsDirectAccessArray(args[0]))",
          "7442:         {",
          "7443:             JavascriptArray* arr = JavascriptArray::FromVar(args[0]);",
          "7444:             JS_REENTRANT_UNLOCK(jsReentLock, return ToLocaleString(arr, scriptContext));",
          "7445:         }",
          "7446:         else",
          "7447:         {",
          "7448:             if (TypedArrayBase::IsDetachedTypedArray(args[0]))",
          "7449:             {",
          "7450:                 JavascriptError::ThrowTypeError(scriptContext, JSERR_DetachedTypedArray, _u(\"Array.prototype.toLocalString\"));",
          "7451:             }",
          "7453:             RecyclableObject* obj = nullptr;",
          "7454:             if (FALSE == JavascriptConversion::ToObject(args[0], scriptContext, &obj))",
          "7455:             {",
          "7456:                 JavascriptError::ThrowTypeError(scriptContext, JSERR_This_NullOrUndefined, _u(\"Array.prototype.toLocaleString\"));",
          "7457:             }",
          "7458:             JS_REENTRANT_UNLOCK(jsReentLock, return ToLocaleString(obj, scriptContext));",
          "7459:         }",
          "7460:     }",
          "7465:     template<typename T, typename P>",
          "7466:     void JavascriptArray::Unshift(RecyclableObject* obj, const T& toIndex, P start, P end, ScriptContext* scriptContext)",
          "7467:     {",
          "7468:         JS_REENTRANCY_LOCK(jsReentLock, scriptContext->GetThreadContext());",
          "7470:         typedef IndexTrace<T> index_trace;",
          "7472:         ThrowTypeErrorOnFailureHelper h(scriptContext, _u(\"Array.prototype.unshift\"));",
          "7473:         if (start < end)",
          "7474:         {",
          "7475:             T newEnd = (end - start - 1);// newEnd - 1",
          "7476:             T dst = toIndex + newEnd;",
          "7477:             for (P i = end; i > start; --i)",
          "7478:             {",
          "7479:                 JS_REENTRANT(jsReentLock, BOOL hasItem = JavascriptOperators::HasItem(obj, i - 1));",
          "7480:                 if (hasItem)",
          "7481:                 {",
          "7482:                     Var element = nullptr;",
          "7483:                     JS_REENTRANT(jsReentLock, element = JavascriptOperators::GetItem(obj, i - 1, scriptContext),",
          "7484:                         h.ThrowTypeErrorOnFailure(index_trace::SetItem(obj, dst, element, PropertyOperation_ThrowIfNotExtensible)));",
          "7485:                 }",
          "7486:                 else",
          "7487:                 {",
          "7488:                     JS_REENTRANT(jsReentLock, h.ThrowTypeErrorOnFailure(index_trace::DeleteItem(obj, dst, PropertyOperation_ThrowOnDeleteIfNotConfig)));",
          "7489:                 }",
          "7491:                 --dst;",
          "7492:             }",
          "7493:         }",
          "7494:     }",
          "7496:     template<typename T>",
          "7497:     void JavascriptArray::GrowArrayHeadHelperForUnshift(JavascriptArray* pArr, uint32 unshiftElements, ScriptContext * scriptContext)",
          "7498:     {",
          "7499:         SparseArraySegmentBase* nextToHeadSeg = pArr->head->next;",
          "7500:         Recycler* recycler = scriptContext->GetRecycler();",
          "7502:         if (nextToHeadSeg == nullptr)",
          "7503:         {",
          "7504:             pArr->EnsureHead<T>();",
          "7505:             pArr->head = SparseArraySegment<T>::From(pArr->head)->GrowByMin(recycler, unshiftElements);",
          "7506:         }",
          "7507:         else",
          "7508:         {",
          "7509:             pArr->head = SparseArraySegment<T>::From(pArr->head)->GrowByMinMax(recycler, unshiftElements, ((nextToHeadSeg->left + unshiftElements) - pArr->head->left - pArr->head->size));",
          "7510:         }",
          "7512:     }",
          "7514:     template<typename T>",
          "7515:     void JavascriptArray::UnshiftHelper(JavascriptArray* pArr, uint32 unshiftElements, Js::Var * elements)",
          "7516:     {",
          "7517:         SparseArraySegment<T>* head = SparseArraySegment<T>::From(pArr->head);",
          "7519:         MoveArray(head->elements + unshiftElements, head->elements, pArr->head->length);",
          "7520:         uint32 oldHeadLength = head->length;",
          "7521:         head->length += unshiftElements;",
          "7524:         pArr->InvalidateLastUsedSegment();",
          "7526:         bool hasNoMissingValues = pArr->HasNoMissingValues();",
          "7529:         if(unshiftElements > oldHeadLength)",
          "7530:         {",
          "7531:             pArr->SetHasNoMissingValues(false);",
          "7532:         }",
          "7534: #if ENABLE_PROFILE_INFO",
          "7535:         pArr->FillFromArgs(unshiftElements, 0, elements, nullptr, true/*dontCreateNewArray*/);",
          "7536: #else",
          "7537:         pArr->FillFromArgs(unshiftElements, 0, elements, true/*dontCreateNewArray*/);",
          "7538: #endif",
          "7541:         pArr->SetHasNoMissingValues(hasNoMissingValues);",
          "7542:     }",
          "7544:     Var JavascriptArray::EntryUnshift(RecyclableObject* function, CallInfo callInfo, ...)",
          "7545:     {",
          "7546:         PROBE_STACK(function->GetScriptContext(), Js::Constants::MinStackDefault);",
          "7548:         ARGUMENTS(args, callInfo);",
          "7549:         ScriptContext* scriptContext = function->GetScriptContext();",
          "7550:         JS_REENTRANCY_LOCK(jsReentLock, scriptContext->GetThreadContext());",
          "7552:         Assert(!(callInfo.Flags & CallFlags_New));",
          "7554:         Var res = scriptContext->GetLibrary()->GetUndefined();",
          "7556:         if (args.Info.Count == 0)",
          "7557:         {",
          "7558:            return res;",
          "7559:         }",
          "7560:         if (JavascriptArray::Is(args[0]) && !JavascriptArray::FromVar(args[0])->IsCrossSiteObject())",
          "7561:         {",
          "7562: #if ENABLE_COPYONACCESS_ARRAY",
          "7563:             JavascriptLibrary::CheckAndConvertCopyOnAccessNativeIntArray<Var>(args[0]);",
          "7564: #endif",
          "7565:             JavascriptArray * pArr = JavascriptArray::FromVar(args[0]);",
          "7567:             uint32 unshiftElements = args.Info.Count - 1;",
          "7569:             if (unshiftElements > 0)",
          "7570:             {",
          "7571:                 if (pArr->IsFillFromPrototypes())",
          "7572:                 {",
          "7573:                     JS_REENTRANT(jsReentLock, pArr->FillFromPrototypes(0, pArr->length)); // We need find all missing value from [[proto]] object",
          "7574:                 }",
          "7577:                 bool newLenOverflowed = false;",
          "7578:                 uint32 maxLen = MaxArrayLength - unshiftElements;",
          "7579:                 if (pArr->length > maxLen)",
          "7580:                 {",
          "7581:                     newLenOverflowed = true;",
          "7583:                     EnsureNonNativeArray(pArr);",
          "7584:                     pArr->TruncateToProperties(MaxArrayLength, maxLen);",
          "7585:                     Assert(pArr->length + unshiftElements == MaxArrayLength);",
          "7586:                 }",
          "7588:                 pArr->ClearSegmentMap(); // Dump segmentMap on unshift (before any possible allocation and throw)",
          "7590:                 Assert(pArr->length <= MaxArrayLength - unshiftElements);",
          "7592:                 SparseArraySegmentBase* renumberSeg = pArr->head->next;",
          "7594:                 bool isIntArray = false;",
          "7595:                 bool isFloatArray = false;",
          "7597:                 if (JavascriptNativeIntArray::Is(pArr))",
          "7598:                 {",
          "7599:                     isIntArray = true;",
          "7600:                 }",
          "7601:                 else if (JavascriptNativeFloatArray::Is(pArr))",
          "7602:                 {",
          "7603:                     isFloatArray = true;",
          "7604:                 }",
          "7608:                 if (pArr->head->size < pArr->head->length + unshiftElements)",
          "7609:                 {",
          "7610:                     if (isIntArray)",
          "7611:                     {",
          "7612:                         GrowArrayHeadHelperForUnshift<int32>(pArr, unshiftElements, scriptContext);",
          "7613:                     }",
          "7614:                     else if (isFloatArray)",
          "7615:                     {",
          "7616:                         GrowArrayHeadHelperForUnshift<double>(pArr, unshiftElements, scriptContext);",
          "7617:                     }",
          "7618:                     else",
          "7619:                     {",
          "7620:                         GrowArrayHeadHelperForUnshift<Var>(pArr, unshiftElements, scriptContext);",
          "7621:                     }",
          "7622:                 }",
          "7624:                 while (renumberSeg)",
          "7625:                 {",
          "7626:                     renumberSeg->left += unshiftElements;",
          "7627:                     if (renumberSeg->next == nullptr)",
          "7628:                     {",
          "7630:                         renumberSeg->EnsureSizeInBound();",
          "7631:                     }",
          "7632:                     renumberSeg = renumberSeg->next;",
          "7633:                 }",
          "7635:                 if (isIntArray)",
          "7636:                 {",
          "7637:                     UnshiftHelper<int32>(pArr, unshiftElements, args.Values);",
          "7638:                 }",
          "7639:                 else if (isFloatArray)",
          "7640:                 {",
          "7641:                     UnshiftHelper<double>(pArr, unshiftElements, args.Values);",
          "7642:                 }",
          "7643:                 else",
          "7644:                 {",
          "7645:                     UnshiftHelper<Var>(pArr, unshiftElements, args.Values);",
          "7646:                 }",
          "7648:                 pArr->InvalidateLastUsedSegment();",
          "7649:                 pArr->length += unshiftElements;",
          "7651: #ifdef VALIDATE_ARRAY",
          "7652:                 pArr->ValidateArray();",
          "7653: #endif",
          "7655:                 if (newLenOverflowed) // ES5: throw if new \"length\" exceeds max array length",
          "7656:                 {",
          "7657:                     JavascriptError::ThrowRangeError(scriptContext, JSERR_ArrayLengthAssignIncorrect);",
          "7658:                 }",
          "7659:             }",
          "7660:             res = JavascriptNumber::ToVar(pArr->length, scriptContext);",
          "7661:         }",
          "7662:         else",
          "7663:         {",
          "7664:             RecyclableObject* dynamicObject = nullptr;",
          "7665:             if (FALSE == JavascriptConversion::ToObject(args[0], scriptContext, &dynamicObject))",
          "7666:             {",
          "7667:                 JavascriptError::ThrowTypeError(scriptContext, JSERR_This_NullOrUndefined, _u(\"Array.prototype.unshift\"));",
          "7668:             }",
          "7670:             JS_REENTRANT(jsReentLock, BigIndex length = OP_GetLength(dynamicObject, scriptContext));",
          "7671:             uint32 unshiftElements = args.Info.Count - 1;",
          "7672:             if (unshiftElements > 0)",
          "7673:             {",
          "7674:                 uint32 MaxSpaceUint32 = MaxArrayLength - unshiftElements;",
          "7677:                 BigIndex end = length > MaxSpaceUint32 ? MaxSpaceUint32 : length;",
          "7678:                 if (end < length)",
          "7679:                 {",
          "7682:                     if (length.IsSmallIndex())",
          "7683:                     {",
          "7684:                         JS_REENTRANT(jsReentLock, Unshift<BigIndex>(dynamicObject, MaxArrayLength, end.GetSmallIndex(), length.GetSmallIndex(), scriptContext));",
          "7685:                     }",
          "7686:                     else",
          "7687:                     {",
          "7688:                         JS_REENTRANT(jsReentLock, Unshift<BigIndex, uint64>(dynamicObject, MaxArrayLength, (uint64)end.GetSmallIndex(), length.GetBigIndex(), scriptContext));",
          "7689:                     }",
          "7690:                 }",
          "7694:                 JS_REENTRANT(jsReentLock, Unshift<uint32>(dynamicObject, unshiftElements, (uint32)0, end.GetSmallIndex(), scriptContext));",
          "7696:                 for (uint32 i = 0; i < unshiftElements; i++)",
          "7697:                 {",
          "7698:                     JS_REENTRANT(jsReentLock,",
          "7699:                         JavascriptOperators::SetItem(dynamicObject, dynamicObject, i, args[i + 1], scriptContext, PropertyOperation_ThrowIfNotExtensible, true));",
          "7700:                 }",
          "7701:             }",
          "7703:             ThrowTypeErrorOnFailureHelper h(scriptContext, _u(\"Array.prototype.unshift\"));",
          "7706:             BigIndex newLen = length + unshiftElements;",
          "7707:             res = JavascriptNumber::ToVar(newLen.IsSmallIndex() ? newLen.GetSmallIndex() : newLen.GetBigIndex(), scriptContext);",
          "7708:             JS_REENTRANT(jsReentLock,",
          "7709:                 BOOL setLength = JavascriptOperators::SetProperty(dynamicObject, dynamicObject, PropertyIds::length, res, scriptContext, PropertyOperation_ThrowIfNotExtensible));",
          "7710:             h.ThrowTypeErrorOnFailure(setLength);",
          "7711:         }",
          "7712:         return res;",
          "7714:     }",
          "7716:     Var JavascriptArray::EntryToString(RecyclableObject* function, CallInfo callInfo, ...)",
          "7717:     {",
          "7718:         PROBE_STACK(function->GetScriptContext(), Js::Constants::MinStackDefault);",
          "7720:         ARGUMENTS(args, callInfo);",
          "7721:         ScriptContext* scriptContext = function->GetScriptContext();",
          "7722:         JS_REENTRANCY_LOCK(jsReentLock, scriptContext->GetThreadContext());",
          "7724:         Assert(!(callInfo.Flags & CallFlags_New));",
          "7726:         if (args.Info.Count == 0)",
          "7727:         {",
          "7728:             JavascriptError::ThrowTypeError(scriptContext, JSERR_NeedObject);",
          "7729:         }",
          "7733:         RecyclableObject* obj = nullptr;",
          "7734:         if (FALSE == JavascriptConversion::ToObject(args[0], scriptContext, &obj))",
          "7735:         {",
          "7736:             JavascriptError::ThrowTypeError(scriptContext, JSERR_This_NullOrUndefined, _u(\"Array.prototype.toString\"));",
          "7737:         }",
          "7740:         JS_REENTRANT(jsReentLock, Var join = JavascriptOperators::GetProperty(obj, PropertyIds::join, scriptContext));",
          "7741:         if (JavascriptConversion::IsCallable(join))",
          "7742:         {",
          "7743:             RecyclableObject* func = RecyclableObject::FromVar(join);",
          "7746:             ThreadContext * threadContext = scriptContext->GetThreadContext();",
          "7747:             JS_REENTRANT(jsReentLock,",
          "7748:                 Var result = threadContext->ExecuteImplicitCall(func, ImplicitCall_ToPrimitive, [=]() -> Js::Var",
          "7749:             {",
          "7751:                 Assert(!ThreadContext::IsOnStack(obj));",
          "7754:                 CallFlags flags = CallFlags_Value;",
          "7755:                 return CALL_FUNCTION(threadContext, func, CallInfo(flags, 1), obj);",
          "7756:             }));",
          "7758:             if(!result)",
          "7759:             {",
          "7761:                 Assert(threadContext->IsDisableImplicitCall());",
          "7762:                 result = scriptContext->GetLibrary()->GetNull();",
          "7763:             }",
          "7765:             return result;",
          "7766:         }",
          "7767:         else",
          "7768:         {",
          "7770:             JS_REENTRANT_UNLOCK(jsReentLock,",
          "7771:                 return CALL_ENTRYPOINT(scriptContext->GetThreadContext(), JavascriptObject::EntryToString, function, CallInfo(1), obj));",
          "7772:         }",
          "7773:     }",
          "7775: #if DEBUG",
          "7776:     BOOL JavascriptArray::GetIndex(const char16* propName, uint32 *pIndex)",
          "7777:     {",
          "7778:         uint32 lu, luDig;",
          "7780:         int32 cch = (int32)wcslen(propName);",
          "7781:         char16* pch = const_cast<char16 *>(propName);",
          "7783:         lu = *pch - '0';",
          "7784:         if (lu > 9)",
          "7785:             return FALSE;",
          "7787:         if (0 == lu)",
          "7788:         {",
          "7790:             return 1 == cch;",
          "7791:         }",
          "7793:         while ((luDig = *++pch - '0') < 10)",
          "7794:         {",
          "7796:             if (lu > 0x19999999)",
          "7797:                 return FALSE;",
          "7798:             lu *= 10;",
          "7799:             if(lu > (ULONG_MAX - luDig))",
          "7800:                 return FALSE;",
          "7801:             lu += luDig;",
          "7802:         }",
          "7804:         if (pch - propName != cch)",
          "7805:             return FALSE;",
          "7807:         if (lu == JavascriptArray::InvalidIndex)",
          "7808:         {",
          "7811:             return FALSE;",
          "7812:         }",
          "7815:         return TRUE;",
          "7816:     }",
          "7817: #endif",
          "7819:     JavascriptString* JavascriptArray::GetLocaleSeparator(ScriptContext* scriptContext)",
          "7820:     {",
          "7821: #ifdef ENABLE_GLOBALIZATION",
          "7822:         LCID lcid = GetUserDefaultLCID();",
          "7823:         int count = 0;",
          "7824:         char16 szSeparator[6];",
          "7827:         count = GetLocaleInfoW(lcid, LOCALE_SLIST, szSeparator, 5);",
          "7828:         if( !count)",
          "7829:         {",
          "7830:             AssertMsg(FALSE, \"GetLocaleInfo failed\");",
          "7831:             return scriptContext->GetLibrary()->GetCommaSpaceDisplayString();",
          "7832:         }",
          "7833:         else",
          "7834:         {",
          "7836:             if( count < 2 || szSeparator[count-2] != ' ')",
          "7837:             {",
          "7838:                 szSeparator[count-1] = ' ';",
          "7839:                 szSeparator[count] = '\\0';",
          "7840:             }",
          "7842:             return JavascriptString::NewCopyBuffer(szSeparator, count, scriptContext);",
          "7843:         }",
          "7844: #else",
          "7846:         return scriptContext->GetLibrary()->GetCommaSpaceDisplayString();",
          "7847: #endif",
          "7848:     }",
          "7850:     template <typename T>",
          "7851:     JavascriptString* JavascriptArray::ToLocaleString(T* arr, ScriptContext* scriptContext)",
          "7852:     {",
          "7853:         JS_REENTRANCY_LOCK(jsReentLock, scriptContext->GetThreadContext());",
          "7855:         uint32 length = 0;",
          "7856:         if (TypedArrayBase::Is(arr))",
          "7857:         {",
          "7859:             length = TypedArrayBase::FromVar(arr)->GetLength();",
          "7860:         }",
          "7861:         else",
          "7862:         {",
          "7864:             JS_REENTRANT(jsReentLock, length = ItemTrace<T>::GetLength(arr, scriptContext));",
          "7865:         }",
          "7867:         if (length == 0 || scriptContext->CheckObject(arr))",
          "7868:         {",
          "7869:             return scriptContext->GetLibrary()->GetEmptyString();",
          "7870:         }",
          "7872:         JavascriptString* res = scriptContext->GetLibrary()->GetEmptyString();",
          "7873:         bool pushedObject = false;",
          "7875:         TryFinally([&]()",
          "7876:         {",
          "7877:             scriptContext->PushObject(arr);",
          "7878:             pushedObject = true;",
          "7880:             Var element;",
          "7881:             JS_REENTRANT(jsReentLock, BOOL gotItem = ItemTrace<T>::GetItem(arr, 0, &element, scriptContext));",
          "7882:             if (gotItem)",
          "7883:             {",
          "7884:                 JS_REENTRANT(jsReentLock, res = JavascriptArray::ToLocaleStringHelper(element, scriptContext));",
          "7885:             }",
          "7887:             if (length > 1)",
          "7888:             {",
          "7889:                 JavascriptString* separator = GetLocaleSeparator(scriptContext);",
          "7891:                 for (uint32 i = 1; i < length; i++)",
          "7892:                 {",
          "7893:                     res = JavascriptString::Concat(res, separator);",
          "7894:                     JS_REENTRANT(jsReentLock, gotItem = ItemTrace<T>::GetItem(arr, i, &element, scriptContext));",
          "7895:                     if (gotItem)",
          "7896:                     {",
          "7897:                         JS_REENTRANT(jsReentLock, res = JavascriptString::Concat(res, JavascriptArray::ToLocaleStringHelper(element, scriptContext)));",
          "7898:                     }",
          "7899:                 }",
          "7900:             }",
          "7901:         },",
          "7902:         [&](bool/*hasException*/)",
          "7903:         {",
          "7904:             if (pushedObject)",
          "7905:             {",
          "7906:                 Var top = scriptContext->PopObject();",
          "7907:                 AssertMsg(top == arr, \"Unmatched operation stack\");",
          "7908:             }",
          "7909:         });",
          "7911:         if (res == nullptr)",
          "7912:         {",
          "7913:             res = scriptContext->GetLibrary()->GetEmptyString();",
          "7914:         }",
          "7916:         return res;",
          "7917:     }",
          "7919:     Var JavascriptArray::EntryIsArray(RecyclableObject* function, CallInfo callInfo, ...)",
          "7920:     {",
          "7921:         PROBE_STACK(function->GetScriptContext(), Js::Constants::MinStackDefault);",
          "7923:         ARGUMENTS(args, callInfo);",
          "7924:         ScriptContext* scriptContext = function->GetScriptContext();",
          "7925:         JS_REENTRANCY_LOCK(jsReentLock, scriptContext->GetThreadContext());",
          "7927:         Assert(!(callInfo.Flags & CallFlags_New));",
          "7929:         CHAKRATEL_LANGSTATS_INC_BUILTINCOUNT(Array_Constructor_isArray);",
          "7931:         if (args.Info.Count < 2)",
          "7932:         {",
          "7933:             return scriptContext->GetLibrary()->GetFalse();",
          "7934:         }",
          "7936: #if ENABLE_COPYONACCESS_ARRAY",
          "7937:         JavascriptLibrary::CheckAndConvertCopyOnAccessNativeIntArray<Var>(args[1]);",
          "7938: #endif",
          "7939:         if (JavascriptOperators::IsArray(args[1]))",
          "7940:         {",
          "7941:             return scriptContext->GetLibrary()->GetTrue();",
          "7942:         }",
          "7943:         return scriptContext->GetLibrary()->GetFalse();",
          "7944:     }",
          "7951:     Var JavascriptArray::EntryFind(RecyclableObject* function, CallInfo callInfo, ...)",
          "7952:     {",
          "7953:         PROBE_STACK(function->GetScriptContext(), Js::Constants::MinStackDefault);",
          "7955:         ARGUMENTS(args, callInfo);",
          "7956:         ScriptContext* scriptContext = function->GetScriptContext();",
          "7957:         JS_REENTRANCY_LOCK(jsReentLock, scriptContext->GetThreadContext());",
          "7959:         Assert(!(callInfo.Flags & CallFlags_New));",
          "7961:         if (args.Info.Count == 0)",
          "7962:         {",
          "7963:             JavascriptError::ThrowTypeError(scriptContext, JSERR_This_NullOrUndefined, _u(\"Array.prototype.find\"));",
          "7964:         }",
          "7966:         int64 length;",
          "7967:         JavascriptArray * pArr = nullptr;",
          "7968:         RecyclableObject* obj = nullptr;",
          "7970:         JS_REENTRANT_UNLOCK(jsReentLock, TryGetArrayAndLength(args[0], scriptContext, _u(\"Array.prototype.find\"), &pArr, &obj, &length));",
          "7972:             return JavascriptArray::FindHelper<false>(pArr, nullptr, obj, length, args, scriptContext);",
          "7973:     }",
          "7975:     template <bool findIndex>",
          "7976:     Var JavascriptArray::FindHelper(JavascriptArray* pArr, Js::TypedArrayBase* typedArrayBase, RecyclableObject* obj, int64 length, Arguments& args, ScriptContext* scriptContext)",
          "7977:     {",
          "7978:         JS_REENTRANCY_LOCK(jsReentLock, scriptContext->GetThreadContext());",
          "7980:         if (args.Info.Count < 2 || !JavascriptConversion::IsCallable(args[1]))",
          "7981:         {",
          "7983:             if (typedArrayBase != nullptr)",
          "7984:             {",
          "7985:                 JavascriptError::ThrowTypeError(scriptContext, JSERR_FunctionArgument_NeedFunction, findIndex ? _u(\"[TypedArray].prototype.findIndex\") : _u(\"[TypedArray].prototype.find\"));",
          "7986:             }",
          "7987:             else",
          "7988:             {",
          "7989:                 JavascriptError::ThrowTypeError(scriptContext, JSERR_FunctionArgument_NeedFunction, findIndex ? _u(\"Array.prototype.findIndex\") : _u(\"Array.prototype.find\"));",
          "7990:             }",
          "7991:         }",
          "7993:         RecyclableObject* callBackFn = RecyclableObject::FromVar(args[1]);",
          "7994:         Var thisArg;",
          "7996:         if (args.Info.Count > 2)",
          "7997:         {",
          "7998:             thisArg = args[2];",
          "7999:         }",
          "8000:         else",
          "8001:         {",
          "8002:             thisArg = scriptContext->GetLibrary()->GetUndefined();",
          "8003:         }",
          "8006:         if (typedArrayBase == nullptr && pArr == nullptr && TypedArrayBase::Is(obj))",
          "8007:         {",
          "8008:             typedArrayBase = TypedArrayBase::FromVar(obj);",
          "8009:         }",
          "8012:         CallFlags flags = CallFlags_Value;",
          "8013:         Var element = nullptr;",
          "8014:         Var testResult = nullptr;",
          "8016:         if (pArr)",
          "8017:         {",
          "8018:             Var undefined = scriptContext->GetLibrary()->GetUndefined();",
          "8020:             Assert(length <= UINT_MAX);",
          "8021:             for (uint32 k = 0; k < (uint32)length; k++)",
          "8022:             {",
          "8023:                 element = undefined;",
          "8024:                 JS_REENTRANT(jsReentLock, pArr->DirectGetItemAtFull(k, &element));",
          "8026:                 Var index = JavascriptNumber::ToVar(k, scriptContext);",
          "8028:                 JS_REENTRANT(jsReentLock,",
          "8029:                     testResult = CALL_FUNCTION(scriptContext->GetThreadContext(), callBackFn, CallInfo(flags, 4), thisArg,",
          "8030:                         element,",
          "8031:                         index,",
          "8032:                         pArr));",
          "8034:                 if (JavascriptConversion::ToBoolean(testResult, scriptContext))",
          "8035:                 {",
          "8036:                     return findIndex ? index : element;",
          "8037:                 }",
          "8041:                 if (!JavascriptArray::Is(obj))",
          "8042:                 {",
          "8043:                     AssertOrFailFastMsg(ES5Array::Is(obj), \"The array should have been converted to an ES5Array\");",
          "8044:                     JS_REENTRANT_UNLOCK(jsReentLock, return JavascriptArray::FindObjectHelper<findIndex>(obj, length, k + 1, callBackFn, thisArg, scriptContext));",
          "8045:                 }",
          "8046:             }",
          "8047:         }",
          "8048:         else if (typedArrayBase)",
          "8049:         {",
          "8050:             Assert(length <= UINT_MAX);",
          "8051:             for (uint32 k = 0; k < (uint32)length; k++)",
          "8052:             {",
          "8055:                 element = typedArrayBase->DirectGetItem(k);",
          "8057:                 Var index = JavascriptNumber::ToVar(k, scriptContext);",
          "8059:                 JS_REENTRANT(jsReentLock,",
          "8060:                     testResult = CALL_FUNCTION(scriptContext->GetThreadContext(), callBackFn, CallInfo(flags, 4), thisArg,",
          "8061:                         element,",
          "8062:                         index,",
          "8063:                         typedArrayBase));",
          "8065:                 if (JavascriptConversion::ToBoolean(testResult, scriptContext))",
          "8066:                 {",
          "8067:                     return findIndex ? index : element;",
          "8068:                 }",
          "8069:             }",
          "8070:         }",
          "8071:         else",
          "8072:         {",
          "8073:             JS_REENTRANT_UNLOCK(jsReentLock, return JavascriptArray::FindObjectHelper<findIndex>(obj, length, 0u, callBackFn, thisArg, scriptContext));",
          "8074:         }",
          "8076:         return findIndex ? JavascriptNumber::ToVar(-1, scriptContext) : scriptContext->GetLibrary()->GetUndefined();",
          "8077:     }",
          "8079:     template <bool findIndex>",
          "8080:     Var JavascriptArray::FindObjectHelper(RecyclableObject* obj, int64 length, int64 start, RecyclableObject* callBackFn, Var thisArg, ScriptContext* scriptContext)",
          "8081:     {",
          "8082:         JS_REENTRANCY_LOCK(jsReentLock, scriptContext->GetThreadContext());",
          "8085:         CallFlags flags = CallFlags_Value;",
          "8086:         Var element = nullptr;",
          "8087:         Var testResult = nullptr;",
          "8089:         for (int64 k = start; k < length; k++)",
          "8090:         {",
          "8091:             JS_REENTRANT(jsReentLock, element = JavascriptOperators::GetItem(obj, (uint64)k, scriptContext));",
          "8092:             Var index = JavascriptNumber::ToVar(k, scriptContext);",
          "8094:                 JS_REENTRANT(jsReentLock,",
          "8095:                     testResult = CALL_FUNCTION(scriptContext->GetThreadContext(), callBackFn, CallInfo(flags, 4), thisArg,",
          "8096:                     element,",
          "8097:                     index,",
          "8098:                         obj));",
          "8100:             if (JavascriptConversion::ToBoolean(testResult, scriptContext))",
          "8101:             {",
          "8102:                 return findIndex ? index : element;",
          "8103:             }",
          "8104:         }",
          "8106:         return findIndex ? JavascriptNumber::ToVar(-1, scriptContext) : scriptContext->GetLibrary()->GetUndefined();",
          "8107:     }",
          "8114:     Var JavascriptArray::EntryFindIndex(RecyclableObject* function, CallInfo callInfo, ...)",
          "8115:     {",
          "8116:         PROBE_STACK(function->GetScriptContext(), Js::Constants::MinStackDefault);",
          "8118:         ARGUMENTS(args, callInfo);",
          "8119:         ScriptContext* scriptContext = function->GetScriptContext();",
          "8120:         JS_REENTRANCY_LOCK(jsReentLock, scriptContext->GetThreadContext());",
          "8122:         Assert(!(callInfo.Flags & CallFlags_New));",
          "8124:         if (args.Info.Count == 0)",
          "8125:         {",
          "8126:             JavascriptError::ThrowTypeError(scriptContext, JSERR_This_NullOrUndefined, _u(\"Array.prototype.findIndex\"));",
          "8127:         }",
          "8129:         int64 length;",
          "8130:         JavascriptArray * pArr = nullptr;",
          "8131:         RecyclableObject* obj = nullptr;",
          "8133:         JS_REENTRANT_UNLOCK(jsReentLock,",
          "8134:             TryGetArrayAndLength(args[0], scriptContext, _u(\"Array.prototype.findIndex\"), &pArr, &obj, &length));",
          "8135:             return JavascriptArray::FindHelper<true>(pArr, nullptr, obj, length, args, scriptContext);",
          "8136:     }",
          "8143:     Var JavascriptArray::EntryEntries(RecyclableObject* function, CallInfo callInfo, ...)",
          "8144:     {",
          "8145:         PROBE_STACK(function->GetScriptContext(), Js::Constants::MinStackDefault);",
          "8147:         ARGUMENTS(args, callInfo);",
          "8148:         ScriptContext* scriptContext = function->GetScriptContext();",
          "8149:         JS_REENTRANCY_LOCK(jsReentLock, scriptContext->GetThreadContext());",
          "8151:         Assert(!(callInfo.Flags & CallFlags_New));",
          "8153:         if (args.Info.Count == 0)",
          "8154:         {",
          "8155:             JavascriptError::ThrowTypeError(scriptContext, JSERR_This_NullOrUndefined, _u(\"Array.prototype.entries\"));",
          "8156:         }",
          "8158:         RecyclableObject* thisObj = nullptr;",
          "8159:         if (FALSE == JavascriptConversion::ToObject(args[0], scriptContext, &thisObj))",
          "8160:         {",
          "8161:             JavascriptError::ThrowTypeError(scriptContext, JSERR_This_NullOrUndefined, _u(\"Array.prototype.entries\"));",
          "8162:         }",
          "8164: #if ENABLE_COPYONACCESS_ARRAY",
          "8165:         JavascriptLibrary::CheckAndConvertCopyOnAccessNativeIntArray<Var>(thisObj);",
          "8166: #endif",
          "8167:         JS_REENTRANT_UNLOCK(jsReentLock,",
          "8168:             return scriptContext->GetLibrary()->CreateArrayIterator(thisObj, JavascriptArrayIteratorKind::KeyAndValue));",
          "8169:     }",
          "8175:     Var JavascriptArray::EntryKeys(RecyclableObject* function, CallInfo callInfo, ...)",
          "8176:     {",
          "8177:         PROBE_STACK(function->GetScriptContext(), Js::Constants::MinStackDefault);",
          "8179:         ARGUMENTS(args, callInfo);",
          "8180:         ScriptContext* scriptContext = function->GetScriptContext();",
          "8181:         JS_REENTRANCY_LOCK(jsReentLock, scriptContext->GetThreadContext());",
          "8183:         Assert(!(callInfo.Flags & CallFlags_New));",
          "8185:         if (args.Info.Count == 0)",
          "8186:         {",
          "8187:             JavascriptError::ThrowTypeError(scriptContext, JSERR_This_NullOrUndefined, _u(\"Array.prototype.keys\"));",
          "8188:         }",
          "8190:         RecyclableObject* thisObj = nullptr;",
          "8191:         if (FALSE == JavascriptConversion::ToObject(args[0], scriptContext, &thisObj))",
          "8192:         {",
          "8193:             JavascriptError::ThrowTypeError(scriptContext, JSERR_This_NullOrUndefined, _u(\"Array.prototype.keys\"));",
          "8194:         }",
          "8196: #if ENABLE_COPYONACCESS_ARRAY",
          "8197:         JavascriptLibrary::CheckAndConvertCopyOnAccessNativeIntArray<Var>(thisObj);",
          "8198: #endif",
          "8199:         JS_REENTRANT_UNLOCK(jsReentLock,",
          "8200:             return scriptContext->GetLibrary()->CreateArrayIterator(thisObj, JavascriptArrayIteratorKind::Key));",
          "8201:     }",
          "8207:     Var JavascriptArray::EntryValues(RecyclableObject* function, CallInfo callInfo, ...)",
          "8208:     {",
          "8209:         PROBE_STACK(function->GetScriptContext(), Js::Constants::MinStackDefault);",
          "8211:         ARGUMENTS(args, callInfo);",
          "8212:         ScriptContext* scriptContext = function->GetScriptContext();",
          "8213:         JS_REENTRANCY_LOCK(jsReentLock, scriptContext->GetThreadContext());",
          "8215:         Assert(!(callInfo.Flags & CallFlags_New));",
          "8217:         if (args.Info.Count == 0)",
          "8218:         {",
          "8219:             JavascriptError::ThrowTypeError(scriptContext, JSERR_This_NullOrUndefined, _u(\"Array.prototype.values\"));",
          "8220:         }",
          "8222:         RecyclableObject* thisObj = nullptr;",
          "8223:         if (FALSE == JavascriptConversion::ToObject(args[0], scriptContext, &thisObj))",
          "8224:         {",
          "8225:             JavascriptError::ThrowTypeError(scriptContext, JSERR_This_NullOrUndefined, _u(\"Array.prototype.values\"));",
          "8226:         }",
          "8228: #if ENABLE_COPYONACCESS_ARRAY",
          "8229:         JavascriptLibrary::CheckAndConvertCopyOnAccessNativeIntArray<Var>(thisObj);",
          "8230: #endif",
          "8231:         JS_REENTRANT_UNLOCK(jsReentLock,",
          "8232:             return scriptContext->GetLibrary()->CreateArrayIterator(thisObj, JavascriptArrayIteratorKind::Value));",
          "8233:     }",
          "8235:     Var JavascriptArray::EntryEvery(RecyclableObject* function, CallInfo callInfo, ...)",
          "8236:     {",
          "8237:         PROBE_STACK(function->GetScriptContext(), Js::Constants::MinStackDefault);",
          "8239:         ARGUMENTS(args, callInfo);",
          "8240:         ScriptContext* scriptContext = function->GetScriptContext();",
          "8241:         JS_REENTRANCY_LOCK(jsReentLock, scriptContext->GetThreadContext());",
          "8242:         AUTO_TAG_NATIVE_LIBRARY_ENTRY(function, callInfo, _u(\"Array.prototype.every\"));",
          "8244:         Assert(!(callInfo.Flags & CallFlags_New));",
          "8246:         CHAKRATEL_LANGSTATS_INC_BUILTINCOUNT(Array_Prototype_every);",
          "8248:         if (args.Info.Count == 0)",
          "8249:         {",
          "8250:             JavascriptError::ThrowTypeError(scriptContext, JSERR_This_NullOrUndefined, _u(\"Array.prototype.every\"));",
          "8251:         }",
          "8253:         BigIndex length;",
          "8254:         JavascriptArray* pArr = nullptr;",
          "8255:         RecyclableObject* obj = nullptr;",
          "8257:         JS_REENTRANT(jsReentLock, TryGetArrayAndLength(args[0], scriptContext, _u(\"Array.prototype.every\"), &pArr, &obj, &length));",
          "8259:         if (length.IsSmallIndex())",
          "8260:         {",
          "8261:             JS_REENTRANT_UNLOCK(jsReentLock, return JavascriptArray::EveryHelper(pArr, nullptr, obj, length.GetSmallIndex(), args, scriptContext));",
          "8262:         }",
          "8263:         Assert(pArr == nullptr || length.IsUint32Max()); // if pArr is not null lets make sure length is safe to cast, which will only happen if length is a uint32max",
          "8264:         JS_REENTRANT_UNLOCK(jsReentLock, return JavascriptArray::EveryHelper(pArr, nullptr, obj, length.GetBigIndex(), args, scriptContext));",
          "8265:     }",
          "8268:     template <typename T>",
          "8269:     Var JavascriptArray::EveryHelper(JavascriptArray* pArr, Js::TypedArrayBase* typedArrayBase, RecyclableObject* obj, T length, Arguments& args, ScriptContext* scriptContext)",
          "8270:     {",
          "8271:         JS_REENTRANCY_LOCK(jsReentLock, scriptContext->GetThreadContext());",
          "8273:         if (args.Info.Count < 2 || !JavascriptConversion::IsCallable(args[1]))",
          "8274:         {",
          "8276:             if (typedArrayBase != nullptr)",
          "8277:             {",
          "8278:                 JavascriptError::ThrowTypeError(scriptContext, JSERR_FunctionArgument_NeedFunction, _u(\"[TypedArray].prototype.every\"));",
          "8279:             }",
          "8280:             else",
          "8281:             {",
          "8282:                 JavascriptError::ThrowTypeError(scriptContext, JSERR_FunctionArgument_NeedFunction, _u(\"Array.prototype.every\"));",
          "8283:             }",
          "8284:         }",
          "8286:         RecyclableObject* callBackFn = RecyclableObject::FromVar(args[1]);",
          "8287:         Var thisArg = nullptr;",
          "8290:         if (args.Info.Count > 2)",
          "8291:         {",
          "8292:             thisArg = args[2];",
          "8293:         }",
          "8294:         else",
          "8295:         {",
          "8296:             thisArg = scriptContext->GetLibrary()->GetUndefined();",
          "8297:         }",
          "8300:         if (typedArrayBase == nullptr && pArr == nullptr && TypedArrayBase::Is(obj))",
          "8301:         {",
          "8302:             typedArrayBase = TypedArrayBase::FromVar(obj);",
          "8303:         }",
          "8305:         Var element = nullptr;",
          "8306:         Var testResult = nullptr;",
          "8308:         CallFlags flags = CallFlags_Value;",
          "8310:         if (pArr)",
          "8311:         {",
          "8312:             Assert(length <= UINT_MAX);",
          "8313:             for (uint32 k = 0; k < (uint32)length; k++)",
          "8314:             {",
          "8315:                 JS_REENTRANT(jsReentLock, BOOL gotItem = pArr->DirectGetItemAtFull(k, &element));",
          "8316:                 if (!gotItem)",
          "8317:                 {",
          "8318:                     continue;",
          "8319:                 }",
          "8321:                 JS_REENTRANT(jsReentLock,",
          "8322:                     testResult = CALL_FUNCTION(scriptContext->GetThreadContext(), callBackFn, CallInfo(flags, 4), thisArg,",
          "8323:                         element,",
          "8324:                         JavascriptNumber::ToVar(k, scriptContext),",
          "8325:                         pArr));",
          "8327:                 if (!JavascriptConversion::ToBoolean(testResult, scriptContext))",
          "8328:                 {",
          "8329:                     return scriptContext->GetLibrary()->GetFalse();",
          "8330:                 }",
          "8334:                 if (!JavascriptArray::Is(obj))",
          "8335:                 {",
          "8336:                     AssertOrFailFastMsg(ES5Array::Is(obj), \"The array should have been converted to an ES5Array\");",
          "8337:                     JS_REENTRANT_UNLOCK(jsReentLock, return JavascriptArray::EveryObjectHelper<T>(obj, length, k + 1, callBackFn, thisArg, scriptContext));",
          "8338:                 }",
          "8339:             }",
          "8340:         }",
          "8341:         else if (typedArrayBase)",
          "8342:         {",
          "8343:             AssertAndFailFast(TypedArrayBase::Is(typedArrayBase));",
          "8344:             uint32 end = (uint32)min(length, (T)typedArrayBase->GetLength());",
          "8346:             for (uint32 k = 0; k < end; k++)",
          "8347:             {",
          "8350:                 element = typedArrayBase->DirectGetItem(k);",
          "8352:                 JS_REENTRANT(jsReentLock,",
          "8353:                     testResult = CALL_FUNCTION(scriptContext->GetThreadContext(), callBackFn, CallInfo(flags, 4), thisArg,",
          "8354:                         element,",
          "8355:                         JavascriptNumber::ToVar(k, scriptContext),",
          "8356:                         typedArrayBase));",
          "8358:                 if (!JavascriptConversion::ToBoolean(testResult, scriptContext))",
          "8359:                 {",
          "8360:                     return scriptContext->GetLibrary()->GetFalse();",
          "8361:                 }",
          "8362:             }",
          "8363:         }",
          "8364:         else",
          "8365:         {",
          "8366:             JS_REENTRANT_UNLOCK(jsReentLock, return JavascriptArray::EveryObjectHelper<T>(obj, length, 0u, callBackFn, thisArg, scriptContext));",
          "8367:         }",
          "8369:         return scriptContext->GetLibrary()->GetTrue();",
          "8370:     }",
          "8372:     template <typename T>",
          "8373:     Var JavascriptArray::EveryObjectHelper(RecyclableObject* obj, T length, T start, RecyclableObject* callBackFn, Var thisArg, ScriptContext* scriptContext)",
          "8374:     {",
          "8375:         JS_REENTRANCY_LOCK(jsReentLock, scriptContext->GetThreadContext());",
          "8378:         CallFlags flags = CallFlags_Value;",
          "8379:         Var element = nullptr;",
          "8380:         Var testResult = nullptr;",
          "8382:         for (T k = start; k < length; k++)",
          "8383:         {",
          "8385:                 JS_REENTRANT(jsReentLock, BOOL hasItem = JavascriptOperators::HasItem(obj, k));",
          "8386:                 if (hasItem)",
          "8387:             {",
          "8388:                     JS_REENTRANT(jsReentLock,",
          "8389:                         element = JavascriptOperators::GetItem(obj, k, scriptContext),",
          "8390:                         testResult = CALL_FUNCTION(scriptContext->GetThreadContext(), callBackFn, CallInfo(flags, 4), thisArg,",
          "8391:                         element,",
          "8392:                         JavascriptNumber::ToVar(k, scriptContext),",
          "8393:                             obj));",
          "8395:                 if (!JavascriptConversion::ToBoolean(testResult, scriptContext))",
          "8396:                 {",
          "8397:                     return scriptContext->GetLibrary()->GetFalse();",
          "8398:                 }",
          "8399:             }",
          "8400:         }",
          "8402:         return scriptContext->GetLibrary()->GetTrue();",
          "8403:     }",
          "8406:     Var JavascriptArray::EntrySome(RecyclableObject* function, CallInfo callInfo, ...)",
          "8407:     {",
          "8408:         PROBE_STACK(function->GetScriptContext(), Js::Constants::MinStackDefault);",
          "8410:         ARGUMENTS(args, callInfo);",
          "8411:         ScriptContext* scriptContext = function->GetScriptContext();",
          "8412:         JS_REENTRANCY_LOCK(jsReentLock, scriptContext->GetThreadContext());",
          "8414:         AUTO_TAG_NATIVE_LIBRARY_ENTRY(function, callInfo, _u(\"Array.prototype.some\"));",
          "8416:         CHAKRATEL_LANGSTATS_INC_BUILTINCOUNT(Array_Prototype_some);",
          "8418:         Assert(!(callInfo.Flags & CallFlags_New));",
          "8420:         if (args.Info.Count == 0)",
          "8421:         {",
          "8422:             JavascriptError::ThrowTypeError(scriptContext, JSERR_This_NullOrUndefined, _u(\"Array.prototype.some\"));",
          "8423:         }",
          "8425:         BigIndex length;",
          "8426:         JavascriptArray* pArr = nullptr;",
          "8427:         RecyclableObject* obj = nullptr;",
          "8429:         JS_REENTRANT(jsReentLock, TryGetArrayAndLength(args[0], scriptContext, _u(\"Array.prototype.some\"), &pArr, &obj, &length));",
          "8431:         if (length.IsSmallIndex())",
          "8432:         {",
          "8433:             JS_REENTRANT_UNLOCK(jsReentLock, return JavascriptArray::SomeHelper(pArr, nullptr, obj, length.GetSmallIndex(), args, scriptContext));",
          "8434:         }",
          "8435:         Assert(pArr == nullptr || length.IsUint32Max()); // if pArr is not null lets make sure length is safe to cast, which will only happen if length is a uint32max",
          "8436:         JS_REENTRANT_UNLOCK(jsReentLock, return JavascriptArray::SomeHelper(pArr, nullptr, obj, length.GetBigIndex(), args, scriptContext));",
          "8437:     }",
          "8440:     template <typename T>",
          "8441:     Var JavascriptArray::SomeHelper(JavascriptArray* pArr, Js::TypedArrayBase* typedArrayBase, RecyclableObject* obj, T length, Arguments& args, ScriptContext* scriptContext)",
          "8442:     {",
          "8443:         JS_REENTRANCY_LOCK(jsReentLock, scriptContext->GetThreadContext());",
          "8445:         if (args.Info.Count < 2 || !JavascriptConversion::IsCallable(args[1]))",
          "8446:         {",
          "8448:             if (typedArrayBase != nullptr)",
          "8449:             {",
          "8450:                 JavascriptError::ThrowTypeError(scriptContext, JSERR_FunctionArgument_NeedFunction, _u(\"[TypedArray].prototype.some\"));",
          "8451:             }",
          "8452:             else",
          "8453:             {",
          "8454:                 JavascriptError::ThrowTypeError(scriptContext, JSERR_FunctionArgument_NeedFunction, _u(\"Array.prototype.some\"));",
          "8455:             }",
          "8456:         }",
          "8458:         RecyclableObject* callBackFn = RecyclableObject::FromVar(args[1]);",
          "8459:         Var thisArg = nullptr;",
          "8461:         if (args.Info.Count > 2)",
          "8462:         {",
          "8463:             thisArg = args[2];",
          "8464:         }",
          "8465:         else",
          "8466:         {",
          "8467:             thisArg = scriptContext->GetLibrary()->GetUndefined();",
          "8468:         }",
          "8471:         if (typedArrayBase == nullptr && pArr == nullptr && TypedArrayBase::Is(obj))",
          "8472:         {",
          "8473:             typedArrayBase = TypedArrayBase::FromVar(obj);",
          "8474:         }",
          "8477:         CallFlags flags = CallFlags_Value;",
          "8478:         Var element = nullptr;",
          "8479:         Var testResult = nullptr;",
          "8481:         if (pArr)",
          "8482:         {",
          "8483:             Assert(length <= UINT_MAX);",
          "8484:             for (uint32 k = 0; k < (uint32)length; k++)",
          "8485:             {",
          "8486:                 JS_REENTRANT(jsReentLock, BOOL gotItem = pArr->DirectGetItemAtFull(k, &element));",
          "8487:                 if (!gotItem)",
          "8488:                 {",
          "8489:                     continue;",
          "8490:                 }",
          "8492:                 JS_REENTRANT_UNLOCK(jsReentLock,",
          "8493:                     testResult = CALL_FUNCTION(scriptContext->GetThreadContext(), callBackFn, CallInfo(flags, 4), thisArg,",
          "8494:                         element,",
          "8495:                         JavascriptNumber::ToVar(k, scriptContext),",
          "8496:                         pArr));",
          "8498:                 if (JavascriptConversion::ToBoolean(testResult, scriptContext))",
          "8499:                 {",
          "8500:                     return scriptContext->GetLibrary()->GetTrue();",
          "8501:                 }",
          "8505:                 if (!JavascriptArray::Is(obj))",
          "8506:                 {",
          "8507:                     AssertOrFailFastMsg(ES5Array::Is(obj), \"The array should have been converted to an ES5Array\");",
          "8508:                     JS_REENTRANT_UNLOCK(jsReentLock, return JavascriptArray::SomeObjectHelper<T>(obj, length, k + 1, callBackFn, thisArg, scriptContext));",
          "8509:                 }",
          "8510:             }",
          "8511:         }",
          "8512:         else if (typedArrayBase)",
          "8513:         {",
          "8514:             AssertAndFailFast(TypedArrayBase::Is(typedArrayBase));",
          "8515:             uint32 end = (uint32)min(length, (T)typedArrayBase->GetLength());",
          "8517:             for (uint32 k = 0; k < end; k++)",
          "8518:             {",
          "8521:                 element = typedArrayBase->DirectGetItem(k);",
          "8523:                 JS_REENTRANT_UNLOCK(jsReentLock,",
          "8524:                     testResult = CALL_FUNCTION(scriptContext->GetThreadContext(), callBackFn, CallInfo(flags, 4), thisArg,",
          "8525:                         element,",
          "8526:                         JavascriptNumber::ToVar(k, scriptContext),",
          "8527:                         typedArrayBase));",
          "8529:                 if (JavascriptConversion::ToBoolean(testResult, scriptContext))",
          "8530:                 {",
          "8531:                     return scriptContext->GetLibrary()->GetTrue();",
          "8532:                 }",
          "8533:             }",
          "8534:         }",
          "8535:         else",
          "8536:         {",
          "8537:             JS_REENTRANT_UNLOCK(jsReentLock, return JavascriptArray::SomeObjectHelper<T>(obj, length, 0u, callBackFn, thisArg, scriptContext));",
          "8538:         }",
          "8540:         return scriptContext->GetLibrary()->GetFalse();",
          "8541:     }",
          "8543:     template <typename T>",
          "8544:     Var JavascriptArray::SomeObjectHelper(RecyclableObject* obj, T length, T start, RecyclableObject* callBackFn, Var thisArg, ScriptContext* scriptContext)",
          "8545:     {",
          "8546:         JS_REENTRANCY_LOCK(jsReentLock, scriptContext->GetThreadContext());",
          "8549:         CallFlags flags = CallFlags_Value;",
          "8550:         Var element = nullptr;",
          "8551:         Var testResult = nullptr;",
          "8553:         for (T k = start; k < length; k++)",
          "8554:         {",
          "8555:             JS_REENTRANT(jsReentLock, BOOL hasItem = JavascriptOperators::HasItem(obj, k));",
          "8556:             if (hasItem)",
          "8557:             {",
          "8558:                 JS_REENTRANT_UNLOCK(jsReentLock,",
          "8559:                     element = JavascriptOperators::GetItem(obj, k, scriptContext),",
          "8560:                     testResult = CALL_FUNCTION(scriptContext->GetThreadContext(), callBackFn, CallInfo(flags, 4), thisArg,",
          "8561:                         element,",
          "8562:                         JavascriptNumber::ToVar(k, scriptContext),",
          "8563:                         obj));",
          "8565:                 if (JavascriptConversion::ToBoolean(testResult, scriptContext))",
          "8566:                 {",
          "8567:                     return scriptContext->GetLibrary()->GetTrue();",
          "8568:                 }",
          "8569:             }",
          "8570:         }",
          "8572:         return scriptContext->GetLibrary()->GetFalse();",
          "8573:     }",
          "8575:     Var JavascriptArray::EntryForEach(RecyclableObject* function, CallInfo callInfo, ...)",
          "8576:     {",
          "8577:         PROBE_STACK(function->GetScriptContext(), Js::Constants::MinStackDefault);",
          "8579:         ARGUMENTS(args, callInfo);",
          "8580:         ScriptContext* scriptContext = function->GetScriptContext();",
          "8581:         JS_REENTRANCY_LOCK(jsReentLock, scriptContext->GetThreadContext());",
          "8583:         AUTO_TAG_NATIVE_LIBRARY_ENTRY(function, callInfo, _u(\"Array.prototype.forEach\"));",
          "8585:         CHAKRATEL_LANGSTATS_INC_BUILTINCOUNT(Array_Prototype_forEach)",
          "8587:         Assert(!(callInfo.Flags & CallFlags_New));",
          "8589:         if (args.Info.Count == 0)",
          "8590:         {",
          "8591:             JavascriptError::ThrowTypeError(scriptContext, JSERR_This_NullOrUndefined, _u(\"Array.prototype.forEach\"));",
          "8592:         }",
          "8594:         BigIndex length;",
          "8595:         JavascriptArray* pArr = nullptr;",
          "8596:         RecyclableObject* dynamicObject = nullptr;",
          "8597:         RecyclableObject* callBackFn = nullptr;",
          "8598:         Var thisArg = nullptr;",
          "8600:         JS_REENTRANT(jsReentLock, TryGetArrayAndLength(args[0], scriptContext, _u(\"Array.prototype.forEach\"), &pArr, &dynamicObject, &length));",
          "8602:         if (args.Info.Count < 2 || !JavascriptConversion::IsCallable(args[1]))",
          "8603:         {",
          "8604:             JavascriptError::ThrowTypeError(scriptContext, JSERR_FunctionArgument_NeedFunction, _u(\"Array.prototype.forEach\"));",
          "8605:         }",
          "8606:         callBackFn = RecyclableObject::FromVar(args[1]);",
          "8608:         if (args.Info.Count > 2)",
          "8609:         {",
          "8610:             thisArg = args[2];",
          "8611:         }",
          "8612:         else",
          "8613:         {",
          "8614:             thisArg = scriptContext->GetLibrary()->GetUndefined();",
          "8615:         }",
          "8618:         CallFlags flags = CallFlags_Value;",
          "8620:         auto fn32 = [dynamicObject, callBackFn, flags, thisArg,",
          "8621:             scriptContext](uint32 k, Var element)",
          "8622:         {",
          "8623:             CALL_FUNCTION(scriptContext->GetThreadContext(), callBackFn, CallInfo(flags, 4), thisArg,",
          "8624:                 element,",
          "8625:                 JavascriptNumber::ToVar(k, scriptContext),",
          "8626:                 dynamicObject);",
          "8627:         };",
          "8629:         auto fn64 = [dynamicObject, callBackFn, flags, thisArg,",
          "8630:             scriptContext](uint64 k, Var element)",
          "8631:         {",
          "8632:             CALL_FUNCTION(scriptContext->GetThreadContext(), callBackFn, CallInfo(flags, 4), thisArg,",
          "8633:                 element,",
          "8634:                 JavascriptNumber::ToVar(k, scriptContext),",
          "8635:                 dynamicObject);",
          "8636:         };",
          "8638:         if (pArr)",
          "8639:         {",
          "8640:             Assert(pArr == dynamicObject);",
          "8641:             JS_REENTRANT(jsReentLock, pArr->ForEachItemInRange<true>(0, length.IsUint32Max() ? MaxArrayLength : length.GetSmallIndex(), scriptContext, fn32));",
          "8642:         }",
          "8643:         else",
          "8644:         {",
          "8645:             if (length.IsSmallIndex())",
          "8646:             {",
          "8647:                 JS_REENTRANT(jsReentLock, TemplatedForEachItemInRange<true>(dynamicObject, 0u, length.GetSmallIndex(), scriptContext, fn32));",
          "8648:             }",
          "8649:             else",
          "8650:             {",
          "8651:                 JS_REENTRANT(jsReentLock, TemplatedForEachItemInRange<true>(dynamicObject, 0ui64, length.GetBigIndex(), scriptContext, fn64));",
          "8652:             }",
          "8653:         }",
          "8654:         return scriptContext->GetLibrary()->GetUndefined();",
          "8655:     }",
          "8657:     Var JavascriptArray::EntryCopyWithin(RecyclableObject* function, CallInfo callInfo, ...)",
          "8658:     {",
          "8659:         PROBE_STACK(function->GetScriptContext(), Js::Constants::MinStackDefault);",
          "8661:         ARGUMENTS(args, callInfo);",
          "8662:         ScriptContext* scriptContext = function->GetScriptContext();",
          "8663:         JS_REENTRANCY_LOCK(jsReentLock, scriptContext->GetThreadContext());",
          "8665:         Assert(!(callInfo.Flags & CallFlags_New));",
          "8667:         RecyclableObject* obj = nullptr;",
          "8668:         JavascriptArray* pArr = nullptr;",
          "8669:         int64 length;",
          "8671:         JS_REENTRANT_UNLOCK(jsReentLock, TryGetArrayAndLength(args[0], scriptContext, _u(\"Array.prototype.copyWithin\"), &pArr, &obj, &length));",
          "8672:             return JavascriptArray::CopyWithinHelper(pArr, nullptr, obj, length, args, scriptContext);",
          "8673:     }",
          "8676:     Var JavascriptArray::CopyWithinHelper(JavascriptArray* pArr, Js::TypedArrayBase* typedArrayBase, RecyclableObject* obj, int64 length, Arguments& args, ScriptContext* scriptContext)",
          "8677:     {",
          "8678:         JS_REENTRANCY_LOCK(jsReentLock, scriptContext->GetThreadContext());",
          "8680:         Assert(args.Info.Count > 0);",
          "8682:         JavascriptLibrary* library = scriptContext->GetLibrary();",
          "8683:         int64 fromVal = 0;",
          "8684:         int64 toVal = 0;",
          "8685:         int64 finalVal = length;",
          "8688:         if (typedArrayBase == nullptr && pArr == nullptr && TypedArrayBase::Is(obj))",
          "8689:         {",
          "8690:             typedArrayBase = TypedArrayBase::FromVar(obj);",
          "8691:         }",
          "8693:         if (args.Info.Count > 1)",
          "8694:         {",
          "8695:             JS_REENTRANT(jsReentLock, toVal = JavascriptArray::GetIndexFromVar(args[1], length, scriptContext));",
          "8697:             if (args.Info.Count > 2)",
          "8698:             {",
          "8699:                 JS_REENTRANT(jsReentLock, fromVal = JavascriptArray::GetIndexFromVar(args[2], length, scriptContext));",
          "8701:                 if (args.Info.Count > 3 && args[3] != library->GetUndefined())",
          "8702:                 {",
          "8703:                     JS_REENTRANT(jsReentLock, finalVal = JavascriptArray::GetIndexFromVar(args[3], length, scriptContext));",
          "8704:                 }",
          "8705:             }",
          "8706:         }",
          "8709:         if (finalVal <= fromVal || length <= toVal)",
          "8710:         {",
          "8711:             return obj;",
          "8712:         }",
          "8715:         Assert(finalVal > fromVal && length > toVal);",
          "8717:         int64 count = min(finalVal - fromVal, length - toVal);",
          "8720:         Assert(count > 0);",
          "8722:         int direction;",
          "8724:         if (fromVal < toVal && toVal < (fromVal + count))",
          "8725:         {",
          "8726:             direction = -1;",
          "8727:             fromVal += count - 1;",
          "8728:             toVal += count - 1;",
          "8729:         }",
          "8730:         else",
          "8731:         {",
          "8732:             direction = 1;",
          "8733:         }",
          "8736:         if (pArr && !JavascriptArray::Is(obj))",
          "8737:         {",
          "8738:             AssertOrFailFastMsg(ES5Array::Is(obj), \"The array should have been converted to an ES5Array\");",
          "8739:             pArr = nullptr;",
          "8740:         }",
          "8744:         if ((direction == -1 && (fromVal >= MaxArrayLength || toVal >= MaxArrayLength))",
          "8745:             || (((fromVal + count) > MaxArrayLength) || ((toVal + count) > MaxArrayLength)))",
          "8746:         {",
          "8747:             while (count > 0)",
          "8748:             {",
          "8749:                 Var index = JavascriptNumber::ToVar(fromVal, scriptContext);",
          "8751:                 JS_REENTRANT(jsReentLock, BOOL hasItem = JavascriptOperators::OP_HasItem(obj, index, scriptContext));",
          "8752:                 if (hasItem)",
          "8753:                 {",
          "8754:                     Var val = nullptr;",
          "8755:                     JS_REENTRANT(jsReentLock,",
          "8756:                         val = JavascriptOperators::OP_GetElementI(obj, index, scriptContext),",
          "8757:                         JavascriptOperators::OP_SetElementI(obj, JavascriptNumber::ToVar(toVal, scriptContext), val, scriptContext, PropertyOperation_ThrowIfNotExtensible));",
          "8758:                 }",
          "8759:                 else",
          "8760:                 {",
          "8761:                     JavascriptOperators::OP_DeleteElementI(obj, JavascriptNumber::ToVar(toVal, scriptContext), scriptContext, PropertyOperation_ThrowOnDeleteIfNotConfig);",
          "8762:                 }",
          "8764:                 fromVal += direction;",
          "8765:                 toVal += direction;",
          "8766:                 count--;",
          "8767:             }",
          "8768:         }",
          "8769:         else",
          "8770:         {",
          "8771:             Assert(fromVal < MaxArrayLength);",
          "8772:             Assert(toVal < MaxArrayLength);",
          "8773:             Assert(direction == -1 || (fromVal + count < MaxArrayLength && toVal + count < MaxArrayLength));",
          "8775:             uint32 fromIndex = static_cast<uint32>(fromVal);",
          "8776:             uint32 toIndex = static_cast<uint32>(toVal);",
          "8778:             while (count > 0)",
          "8779:             {",
          "8780:                 JS_REENTRANT(jsReentLock, BOOL hasItem = obj->HasItem(fromIndex));",
          "8781:                 if (hasItem)",
          "8782:                 {",
          "8783:                     if (typedArrayBase)",
          "8784:                     {",
          "8785:                         Var val = typedArrayBase->DirectGetItem(fromIndex);",
          "8787:                         JS_REENTRANT(jsReentLock, typedArrayBase->DirectSetItem(toIndex, val));",
          "8788:                     }",
          "8789:                     else if (pArr)",
          "8790:                     {",
          "8791:                         JS_REENTRANT(jsReentLock, Var val = pArr->DirectGetItem(fromIndex));",
          "8792:                         pArr->SetItem(toIndex, val, Js::PropertyOperation_ThrowIfNotExtensible);",
          "8794:                         if (!JavascriptArray::Is(obj))",
          "8795:                         {",
          "8796:                             AssertOrFailFastMsg(ES5Array::Is(obj), \"The array should have been converted to an ES5Array\");",
          "8797:                             pArr = nullptr;",
          "8798:                         }",
          "8799:                     }",
          "8800:                     else",
          "8801:                     {",
          "8802:                         Var val = nullptr;",
          "8803:                         JS_REENTRANT(jsReentLock,",
          "8804:                             val = JavascriptOperators::OP_GetElementI_UInt32(obj, fromIndex, scriptContext),",
          "8805:                             JavascriptOperators::OP_SetElementI_UInt32(obj, toIndex, val, scriptContext, PropertyOperation_ThrowIfNotExtensible));",
          "8806:                     }",
          "8807:                 }",
          "8808:                 else",
          "8809:                 {",
          "8810:                     obj->DeleteItem(toIndex, PropertyOperation_ThrowOnDeleteIfNotConfig);",
          "8811:                 }",
          "8813:                 fromIndex += direction;",
          "8814:                 toIndex += direction;",
          "8815:                 count--;",
          "8816:             }",
          "8817:         }",
          "8819:         return obj;",
          "8820:     }",
          "8822:     Var JavascriptArray::EntryFill(RecyclableObject* function, CallInfo callInfo, ...)",
          "8823:     {",
          "8824:         PROBE_STACK(function->GetScriptContext(), Js::Constants::MinStackDefault);",
          "8826:         ARGUMENTS(args, callInfo);",
          "8827:         ScriptContext* scriptContext = function->GetScriptContext();",
          "8828:         JS_REENTRANCY_LOCK(jsReentLock, scriptContext->GetThreadContext());",
          "8830:         Assert(!(callInfo.Flags & CallFlags_New));",
          "8832:         RecyclableObject* obj = nullptr;",
          "8833:         JavascriptArray* pArr = nullptr;",
          "8834:         int64 length;",
          "8836:         JS_REENTRANT_UNLOCK(jsReentLock,",
          "8837:             TryGetArrayAndLength(args[0], scriptContext, _u(\"Array.prototype.fill\"), &pArr, &obj, &length));",
          "8838:             return JavascriptArray::FillHelper(pArr, nullptr, obj, length, args, scriptContext);",
          "8839:     }",
          "8842:     Var JavascriptArray::FillHelper(JavascriptArray* pArr, Js::TypedArrayBase* typedArrayBase, RecyclableObject* obj, int64 length, Arguments& args, ScriptContext* scriptContext)",
          "8843:     {",
          "8844:         JS_REENTRANCY_LOCK(jsReentLock, scriptContext->GetThreadContext());",
          "8846:         Assert(args.Info.Count > 0);",
          "8848:         JavascriptLibrary* library = scriptContext->GetLibrary();",
          "8851:         if (typedArrayBase == nullptr && pArr == nullptr && TypedArrayBase::Is(obj))",
          "8852:         {",
          "8853:             typedArrayBase = TypedArrayBase::FromVar(obj);",
          "8854:         }",
          "8856:         Var fillValue;",
          "8858:         if (args.Info.Count > 1)",
          "8859:         {",
          "8860:             fillValue = args[1];",
          "8861:         }",
          "8862:         else",
          "8863:         {",
          "8864:             fillValue = library->GetUndefined();",
          "8865:         }",
          "8867:         int64 k = 0;",
          "8868:         int64 finalVal = length;",
          "8870:         if (args.Info.Count > 2)",
          "8871:         {",
          "8872:             JS_REENTRANT_UNLOCK(jsReentLock, k = JavascriptArray::GetIndexFromVar(args[2], length, scriptContext));",
          "8874:             if (args.Info.Count > 3 && !JavascriptOperators::IsUndefinedObject(args[3]))",
          "8875:             {",
          "8876:                 JS_REENTRANT_UNLOCK(jsReentLock, finalVal = JavascriptArray::GetIndexFromVar(args[3], length, scriptContext));",
          "8877:             }",
          "8881:             if (pArr && !JavascriptArray::Is(obj))",
          "8882:             {",
          "8883:                 AssertOrFailFastMsg(ES5Array::Is(obj), \"The array should have been converted to an ES5Array\");",
          "8884:                 pArr = nullptr;",
          "8885:             }",
          "8886:         }",
          "8888:         if (k < MaxArrayLength)",
          "8889:         {",
          "8890:             int64 end = min<int64>(finalVal, MaxArrayLength);",
          "8891:             uint32 u32k = static_cast<uint32>(k);",
          "8893:             while (u32k < end)",
          "8894:             {",
          "8895:                 if (typedArrayBase)",
          "8896:                 {",
          "8897:                     JS_REENTRANT(jsReentLock, typedArrayBase->DirectSetItem(u32k, fillValue));",
          "8898:                 }",
          "8899:                 else if (pArr)",
          "8900:                 {",
          "8901:                     pArr->SetItem(u32k, fillValue, PropertyOperation_ThrowIfNotExtensible);",
          "8902:                 }",
          "8903:                 else",
          "8904:                 {",
          "8905:                     JS_REENTRANT(jsReentLock,",
          "8906:                         JavascriptOperators::OP_SetElementI_UInt32(obj, u32k, fillValue, scriptContext, Js::PropertyOperation_ThrowIfNotExtensible));",
          "8907:                 }",
          "8909:                 u32k++;",
          "8910:             }",
          "8912:             BigIndex dstIndex = MaxArrayLength;",
          "8914:             for (int64 i = end; i < finalVal; ++i)",
          "8915:             {",
          "8916:                 if (pArr)",
          "8917:                 {",
          "8918:                     pArr->DirectSetItemAt(dstIndex, fillValue);",
          "8919:                     ++dstIndex;",
          "8920:                 }",
          "8921:                 else",
          "8922:                 {",
          "8923:                     JS_REENTRANT(jsReentLock,",
          "8924:                         JavascriptOperators::OP_SetElementI(obj, JavascriptNumber::ToVar(i, scriptContext), fillValue, scriptContext, Js::PropertyOperation_ThrowIfNotExtensible));",
          "8925:                 }",
          "8926:             }",
          "8927:         }",
          "8928:         else",
          "8929:         {",
          "8930:             BigIndex dstIndex = static_cast<uint64>(k);",
          "8932:             for (int64 i = k; i < finalVal; i++)",
          "8933:             {",
          "8934:                 if (pArr)",
          "8935:                 {",
          "8936:                     pArr->DirectSetItemAt(dstIndex, fillValue);",
          "8937:                     ++dstIndex;",
          "8938:                 }",
          "8939:                 else",
          "8940:                 {",
          "8941:                     JS_REENTRANT(jsReentLock,",
          "8942:                         JavascriptOperators::OP_SetElementI(obj, JavascriptNumber::ToVar(i, scriptContext), fillValue, scriptContext, Js::PropertyOperation_ThrowIfNotExtensible));",
          "8943:                 }",
          "8944:             }",
          "8945:         }",
          "8947:         return obj;",
          "8948:     }",
          "8951:     Var JavascriptArray::EntryMap(RecyclableObject* function, CallInfo callInfo, ...)",
          "8952:     {",
          "8953:         PROBE_STACK(function->GetScriptContext(), Js::Constants::MinStackDefault);",
          "8955:         ARGUMENTS(args, callInfo);",
          "8956:         ScriptContext* scriptContext = function->GetScriptContext();",
          "8957:         JS_REENTRANCY_LOCK(jsReentLock, scriptContext->GetThreadContext());",
          "8958:         AUTO_TAG_NATIVE_LIBRARY_ENTRY(function, callInfo, _u(\"Array.prototype.map\"));",
          "8960:         CHAKRATEL_LANGSTATS_INC_BUILTINCOUNT(Array_Prototype_map);",
          "8962:         Assert(!(callInfo.Flags & CallFlags_New));",
          "8964:         if (args.Info.Count == 0)",
          "8965:         {",
          "8966:             JavascriptError::ThrowTypeError(scriptContext, JSERR_This_NullOrUndefined, _u(\"Array.prototype.map\"));",
          "8967:         }",
          "8969:         BigIndex length;",
          "8970:         JavascriptArray* pArr = nullptr;",
          "8971:         RecyclableObject* obj = nullptr;",
          "8973:         JS_REENTRANT(jsReentLock, TryGetArrayAndLength(args[0], scriptContext, _u(\"Array.prototype.map\"), &pArr, &obj, &length));",
          "8975:         if (length.IsSmallIndex())",
          "8976:         {",
          "8977:             JS_REENTRANT_UNLOCK(jsReentLock, return JavascriptArray::MapHelper(pArr, nullptr, obj, length.GetSmallIndex(), args, scriptContext));",
          "8978:         }",
          "8979:         Assert(pArr == nullptr || length.IsUint32Max()); // if pArr is not null lets make sure length is safe to cast, which will only happen if length is a uint32max",
          "8980:         JS_REENTRANT_UNLOCK(jsReentLock, return JavascriptArray::MapHelper(pArr, nullptr, obj, length.GetBigIndex(), args, scriptContext));",
          "8981:     }",
          "8984:     template<typename T>",
          "8985:     Var JavascriptArray::MapHelper(JavascriptArray* pArr, Js::TypedArrayBase* typedArrayBase, RecyclableObject* obj, T length, Arguments& args, ScriptContext* scriptContext)",
          "8986:     {",
          "8987:         JS_REENTRANCY_LOCK(jsReentLock, scriptContext->GetThreadContext());",
          "8989:         RecyclableObject* newObj = nullptr;",
          "8990:         JavascriptArray* newArr = nullptr;",
          "8991:         bool isTypedArrayEntryPoint = typedArrayBase != nullptr;",
          "8992:         bool isBuiltinArrayCtor = true;",
          "8994:         if (args.Info.Count < 2 || !JavascriptConversion::IsCallable(args[1]))",
          "8995:         {",
          "8996:             if (isTypedArrayEntryPoint)",
          "8997:             {",
          "8998:                 JavascriptError::ThrowTypeError(scriptContext, JSERR_FunctionArgument_NeedFunction, _u(\"[TypedArray].prototype.map\"));",
          "8999:             }",
          "9000:             else",
          "9001:             {",
          "9002:                 JavascriptError::ThrowTypeError(scriptContext, JSERR_FunctionArgument_NeedFunction, _u(\"Array.prototype.map\"));",
          "9003:             }",
          "9004:         }",
          "9006:         RecyclableObject* callBackFn = RecyclableObject::FromVar(args[1]);",
          "9007:         Var thisArg;",
          "9009:         if (args.Info.Count > 2)",
          "9010:         {",
          "9011:             thisArg = args[2];",
          "9012:         }",
          "9013:         else",
          "9014:         {",
          "9015:             thisArg = scriptContext->GetLibrary()->GetUndefined();",
          "9016:         }",
          "9019:         if (!isTypedArrayEntryPoint && pArr == nullptr && TypedArrayBase::Is(obj))",
          "9020:         {",
          "9021:             typedArrayBase = TypedArrayBase::FromVar(obj);",
          "9022:         }",
          "9026:         if (isTypedArrayEntryPoint)",
          "9027:         {",
          "9028:             JS_REENTRANT(jsReentLock,",
          "9029:                 Var constructor = JavascriptOperators::SpeciesConstructor(",
          "9030:                     typedArrayBase, TypedArrayBase::GetDefaultConstructor(args[0], scriptContext), scriptContext));",
          "9032:             isBuiltinArrayCtor = false;",
          "9034:             Assert(JavascriptOperators::IsConstructor(constructor));",
          "9036:             Js::Var constructorArgs[] = { constructor, JavascriptNumber::ToVar(length, scriptContext) };",
          "9037:             Js::CallInfo constructorCallInfo(Js::CallFlags_New, _countof(constructorArgs));",
          "9038:             JS_REENTRANT(jsReentLock, newObj = RecyclableObject::FromVar(TypedArrayBase::TypedArrayCreate(constructor, &Js::Arguments(constructorCallInfo, constructorArgs), (uint32)length, scriptContext)));",
          "9039:         }",
          "9041:         else if (pArr == nullptr || scriptContext->GetConfig()->IsES6SpeciesEnabled())",
          "9042:         {",
          "9043:             JS_REENTRANT(jsReentLock, newObj = ArraySpeciesCreate(obj, length, scriptContext, nullptr, nullptr, &isBuiltinArrayCtor));",
          "9044:         }",
          "9046:         if (newObj == nullptr)",
          "9047:         {",
          "9048:             if (length > UINT_MAX)",
          "9049:             {",
          "9050:                 JavascriptError::ThrowRangeError(scriptContext, JSERR_ArrayLengthConstructIncorrect);",
          "9051:             }",
          "9052:             newArr = scriptContext->GetLibrary()->CreateArray(static_cast<uint32>(length));",
          "9053:             newArr->EnsureHead<Var>();",
          "9054:             newObj = newArr;",
          "9055:         }",
          "9056:         else",
          "9057:         {",
          "9059:             if (JavascriptArray::Is(newObj))",
          "9060:             {",
          "9061: #if ENABLE_COPYONACCESS_ARRAY",
          "9062:                 JavascriptLibrary::CheckAndConvertCopyOnAccessNativeIntArray<Var>(newObj);",
          "9063: #endif",
          "9064:                 newArr = JavascriptArray::FromVar(newObj);",
          "9065:             }",
          "9066:         }",
          "9068:         Var element = nullptr;",
          "9069:         Var mappedValue = nullptr;",
          "9071:         CallFlags callBackFnflags = CallFlags_Value;",
          "9072:         CallInfo callBackFnInfo = CallInfo(callBackFnflags, 4);",
          "9075:         Assert(newObj);",
          "9079:         if (pArr && !JavascriptArray::Is(obj))",
          "9080:         {",
          "9081:             AssertOrFailFastMsg(ES5Array::Is(obj), \"The array should have been converted to an ES5Array\");",
          "9082:             pArr = nullptr;",
          "9083:         }",
          "9085:         if (pArr != nullptr)",
          "9086:         {",
          "9088:             Assert(length <= UINT_MAX);",
          "9089:             for (uint32 k = 0; k < (uint32)length; k++)",
          "9090:             {",
          "9091:                 JS_REENTRANT(jsReentLock, BOOL gotItem = pArr->DirectGetItemAtFull(k, &element));",
          "9092:                 if (!gotItem)",
          "9093:                 {",
          "9094:                     continue;",
          "9095:                 }",
          "9097:                 JS_REENTRANT(jsReentLock,",
          "9098:                     mappedValue = CALL_FUNCTION(scriptContext->GetThreadContext(), callBackFn, callBackFnInfo, thisArg,",
          "9099:                         element,",
          "9100:                         JavascriptNumber::ToVar(k, scriptContext),",
          "9101:                         pArr));",
          "9104:                 if (newArr && isBuiltinArrayCtor)",
          "9105:                 {",
          "9106:                     newArr->DirectSetItemAt(k, mappedValue);",
          "9107:                 }",
          "9108:                 else",
          "9109:                 {",
          "9110:                     JS_REENTRANT(jsReentLock, ThrowErrorOnFailure(JavascriptArray::SetArrayLikeObjects(newObj, k, mappedValue), scriptContext, k));",
          "9111:                 }",
          "9115:                 if (!JavascriptArray::Is(obj))",
          "9116:                 {",
          "9117:                     AssertOrFailFastMsg(ES5Array::Is(obj), \"The array should have been converted to an ES5Array\");",
          "9118:                     JS_REENTRANT_UNLOCK(jsReentLock, return JavascriptArray::MapObjectHelper<T>(obj, length, k + 1, newObj, newArr, isBuiltinArrayCtor, callBackFn, thisArg, scriptContext));",
          "9119:                 }",
          "9120:             }",
          "9121:         }",
          "9122:         else if (typedArrayBase != nullptr)",
          "9123:         {",
          "9124:             AssertAndFailFast(TypedArrayBase::Is(typedArrayBase));",
          "9127:             TypedArrayBase* newTypedArray = nullptr;",
          "9129:             if (TypedArrayBase::Is(newObj))",
          "9130:             {",
          "9131:                 newTypedArray = TypedArrayBase::FromVar(newObj);",
          "9132:             }",
          "9133:             else",
          "9134:             {",
          "9135:                 AssertAndFailFast(newArr != nullptr);",
          "9136:             }",
          "9138:             Assert(length <= UINT_MAX);",
          "9139:             uint32 end = (uint32)min(length, (T)typedArrayBase->GetLength());",
          "9141:             for (uint32 k = 0; k < end; k++)",
          "9142:             {",
          "9145:                 element = typedArrayBase->DirectGetItem(k);",
          "9146:                 JS_REENTRANT(jsReentLock,",
          "9147:                     mappedValue = CALL_FUNCTION(scriptContext->GetThreadContext(), callBackFn, callBackFnInfo, thisArg,",
          "9148:                         element,",
          "9149:                         JavascriptNumber::ToVar(k, scriptContext),",
          "9150:                         obj));",
          "9153:                 if (newTypedArray)",
          "9154:                 {",
          "9155:                     JS_REENTRANT(jsReentLock, newTypedArray->DirectSetItem(k, mappedValue));",
          "9156:                 }",
          "9157:                 else",
          "9158:                 {",
          "9159:                     newArr->SetItem(k, mappedValue, PropertyOperation_None);",
          "9160:                 }",
          "9161:             }",
          "9162:         }",
          "9163:         else",
          "9164:         {",
          "9165:             JS_REENTRANT_UNLOCK(jsReentLock, return JavascriptArray::MapObjectHelper<T>(obj, length, 0u, newObj, newArr, isBuiltinArrayCtor, callBackFn, thisArg, scriptContext));",
          "9166:         }",
          "9168: #ifdef VALIDATE_ARRAY",
          "9169:         if (JavascriptArray::Is(newObj))",
          "9170:         {",
          "9171:             newArr->ValidateArray();",
          "9172:         }",
          "9173: #endif",
          "9175:         return newObj;",
          "9176:     }",
          "9178:     template<typename T>",
          "9179:     Var JavascriptArray::MapObjectHelper(RecyclableObject* obj, T length, T start, RecyclableObject* newObj, JavascriptArray* newArr,",
          "9180:         bool isBuiltinArrayCtor, RecyclableObject* callBackFn, Var thisArg, ScriptContext* scriptContext)",
          "9181:     {",
          "9182:         JS_REENTRANCY_LOCK(jsReentLock, scriptContext->GetThreadContext());",
          "9185:         CallFlags callBackFnflags = CallFlags_Value;",
          "9186:         CallInfo callBackFnInfo = CallInfo(callBackFnflags, 4);",
          "9187:         Var element = nullptr;",
          "9188:         Var mappedValue = nullptr;",
          "9190:         for (T k = start; k < length; k++)",
          "9191:         {",
          "9192:                 JS_REENTRANT(jsReentLock, BOOL hasItem = JavascriptOperators::HasItem(obj, k));",
          "9193:                 if (hasItem)",
          "9194:             {",
          "9195:                     JS_REENTRANT(jsReentLock,",
          "9196:                         element = JavascriptOperators::GetItem(obj, k, scriptContext),",
          "9197:                         mappedValue = CALL_FUNCTION(scriptContext->GetThreadContext(), callBackFn, callBackFnInfo, thisArg,",
          "9198:                         element,",
          "9199:                         JavascriptNumber::ToVar(k, scriptContext),",
          "9200:                             obj));",
          "9202:                 if (newArr && isBuiltinArrayCtor)",
          "9203:                 {",
          "9204:                     newArr->SetItem((uint32)k, mappedValue, PropertyOperation_None);",
          "9205:                 }",
          "9206:                 else",
          "9207:                 {",
          "9208:                     JS_REENTRANT(jsReentLock, ThrowErrorOnFailure(JavascriptArray::SetArrayLikeObjects(newObj, BigIndex(k), mappedValue), scriptContext, BigIndex(k)));",
          "9209:                 }",
          "9210:             }",
          "9211:         }",
          "9213: #ifdef VALIDATE_ARRAY",
          "9214:         if (JavascriptArray::Is(newObj))",
          "9215:         {",
          "9216:             newArr->ValidateArray();",
          "9217:         }",
          "9218: #endif",
          "9220:         return newObj;",
          "9221:     }",
          "9223:     Var JavascriptArray::EntryFilter(RecyclableObject* function, CallInfo callInfo, ...)",
          "9224:     {",
          "9225:         PROBE_STACK(function->GetScriptContext(), Js::Constants::MinStackDefault);",
          "9227:         ARGUMENTS(args, callInfo);",
          "9228:         ScriptContext* scriptContext = function->GetScriptContext();",
          "9229:         JS_REENTRANCY_LOCK(jsReentLock, scriptContext->GetThreadContext());",
          "9231:         AUTO_TAG_NATIVE_LIBRARY_ENTRY(function, callInfo, _u(\"Array.prototype.filter\"));",
          "9233:         CHAKRATEL_LANGSTATS_INC_BUILTINCOUNT(Array_Prototype_filter);",
          "9235:         Assert(!(callInfo.Flags & CallFlags_New));",
          "9236:         if (args.Info.Count == 0)",
          "9237:         {",
          "9238:             JavascriptError::ThrowTypeError(scriptContext, JSERR_This_NullOrUndefined, _u(\"Array.prototype.filter\"));",
          "9239:         }",
          "9241:         BigIndex length;",
          "9242:         JavascriptArray* pArr = nullptr;",
          "9243:         RecyclableObject* obj = nullptr;",
          "9245:         JS_REENTRANT(jsReentLock, TryGetArrayAndLength(args[0], scriptContext, _u(\"Array.prototype.filter\"), &pArr, &obj, &length));",
          "9247:         if (length.IsSmallIndex())",
          "9248:         {",
          "9249:             JS_REENTRANT_UNLOCK(jsReentLock, return JavascriptArray::FilterHelper(pArr, obj, length.GetSmallIndex(), args, scriptContext));",
          "9250:         }",
          "9252:         JS_REENTRANT_UNLOCK(jsReentLock, return JavascriptArray::FilterHelper(pArr, obj, length.GetBigIndex(), args, scriptContext));",
          "9253:     }",
          "9255:     template <typename T>",
          "9256:     Var JavascriptArray::FilterHelper(JavascriptArray* pArr, RecyclableObject* obj, T length, Arguments& args, ScriptContext* scriptContext)",
          "9257:     {",
          "9258:         JS_REENTRANCY_LOCK(jsReentLock, scriptContext->GetThreadContext());",
          "9260:         if (args.Info.Count < 2 || !JavascriptConversion::IsCallable(args[1]))",
          "9261:         {",
          "9262:             JavascriptError::ThrowTypeError(scriptContext, JSERR_FunctionArgument_NeedFunction, _u(\"Array.prototype.filter\"));",
          "9263:         }",
          "9265:         RecyclableObject* callBackFn = RecyclableObject::FromVar(args[1]);",
          "9266:         Var thisArg = nullptr;",
          "9268:         if (args.Info.Count > 2)",
          "9269:         {",
          "9270:             thisArg = args[2];",
          "9271:         }",
          "9272:         else",
          "9273:         {",
          "9274:             thisArg = scriptContext->GetLibrary()->GetUndefined();",
          "9275:         }",
          "9278:         bool isBuiltinArrayCtor = true;",
          "9279:         JS_REENTRANT(jsReentLock, RecyclableObject* newObj = ArraySpeciesCreate(obj, 0, scriptContext, nullptr, nullptr, &isBuiltinArrayCtor));",
          "9280:         JavascriptArray* newArr = nullptr;",
          "9282:         if (newObj == nullptr)",
          "9283:         {",
          "9284:             newArr = scriptContext->GetLibrary()->CreateArray(0);",
          "9285:             newArr->EnsureHead<Var>();",
          "9286:             newObj = newArr;",
          "9287:         }",
          "9288:         else",
          "9289:         {",
          "9291:             if (JavascriptArray::Is(newObj))",
          "9292:             {",
          "9293: #if ENABLE_COPYONACCESS_ARRAY",
          "9294:                 JavascriptLibrary::CheckAndConvertCopyOnAccessNativeIntArray<Var>(newObj);",
          "9295: #endif",
          "9296:                 newArr = JavascriptArray::FromVar(newObj);",
          "9297:             }",
          "9298:         }",
          "9302:         if (pArr && !JavascriptArray::Is(obj))",
          "9303:         {",
          "9304:             AssertOrFailFastMsg(ES5Array::Is(obj), \"The array should have been converted to an ES5Array\");",
          "9305:             pArr = nullptr;",
          "9306:         }",
          "9308:         Var element = nullptr;",
          "9309:         Var selected = nullptr;",
          "9311:         if (pArr)",
          "9312:         {",
          "9313:             Assert(length <= MaxArrayLength);",
          "9314:             uint32 i = 0;",
          "9316:             Assert(length <= UINT_MAX);",
          "9317:             for (uint32 k = 0; k < (uint32)length; k++)",
          "9318:             {",
          "9319:                 JS_REENTRANT(jsReentLock, BOOL gotItem = pArr->DirectGetItemAtFull(k, &element));",
          "9320:                 if (!gotItem)",
          "9321:                 {",
          "9322:                     continue;",
          "9323:                 }",
          "9325:                 JS_REENTRANT(jsReentLock,",
          "9326:                     selected = CALL_ENTRYPOINT(scriptContext->GetThreadContext(),",
          "9327:                         callBackFn->GetEntryPoint(), callBackFn, CallInfo(CallFlags_Value, 4),",
          "9328:                         thisArg,",
          "9329:                         element,",
          "9330:                         JavascriptNumber::ToVar(k, scriptContext),",
          "9331:                         pArr));",
          "9333:                 if (JavascriptConversion::ToBoolean(selected, scriptContext))",
          "9334:                 {",
          "9336:                     if (newArr && isBuiltinArrayCtor)",
          "9337:                     {",
          "9338:                         newArr->DirectSetItemAt(i, element);",
          "9339:                     }",
          "9340:                     else",
          "9341:                     {",
          "9342:                         JS_REENTRANT(jsReentLock, ThrowErrorOnFailure(JavascriptArray::SetArrayLikeObjects(newObj, i, element), scriptContext, i));",
          "9343:                     }",
          "9344:                     ++i;",
          "9345:                 }",
          "9349:                 if (!JavascriptArray::Is(obj))",
          "9350:                 {",
          "9351:                     AssertOrFailFastMsg(ES5Array::Is(obj), \"The array should have been converted to an ES5Array\");",
          "9352:                     JS_REENTRANT_UNLOCK(jsReentLock, return JavascriptArray::FilterObjectHelper<T>(obj, length, k + 1, newArr, newObj, i, callBackFn, thisArg, scriptContext));",
          "9353:                 }",
          "9354:             }",
          "9355:         }",
          "9356:         else",
          "9357:         {",
          "9358:             JS_REENTRANT_UNLOCK(jsReentLock, return JavascriptArray::FilterObjectHelper<T>(obj, length, 0u, newArr, newObj, 0u, callBackFn, thisArg, scriptContext));",
          "9359:         }",
          "9361: #ifdef VALIDATE_ARRAY",
          "9362:         if (newArr)",
          "9363:         {",
          "9364:             newArr->ValidateArray();",
          "9365:         }",
          "9366: #endif",
          "9368:         return newObj;",
          "9369:     }",
          "9371:     template <typename T>",
          "9372:     Var JavascriptArray::FilterObjectHelper(RecyclableObject* obj, T length, T start, JavascriptArray* newArr, RecyclableObject* newObj, T newStart,",
          "9373:         RecyclableObject* callBackFn, Var thisArg, ScriptContext* scriptContext)",
          "9374:     {",
          "9375:         JS_REENTRANCY_LOCK(jsReentLock, scriptContext->GetThreadContext());",
          "9377:         Var element = nullptr;",
          "9378:         Var selected = nullptr;",
          "9379:         BigIndex i = BigIndex(newStart);",
          "9381:         for (T k = start; k < length; k++)",
          "9382:         {",
          "9383:                 JS_REENTRANT(jsReentLock, BOOL hasItem = JavascriptOperators::HasItem(obj, k));",
          "9384:                 if (hasItem)",
          "9385:             {",
          "9386:                     JS_REENTRANT(jsReentLock,",
          "9387:                         element = JavascriptOperators::GetItem(obj, k, scriptContext),",
          "9388:                         selected = CALL_ENTRYPOINT(scriptContext->GetThreadContext(),",
          "9389:                             callBackFn->GetEntryPoint(), callBackFn, CallInfo(CallFlags_Value, 4),",
          "9390:                         thisArg,",
          "9391:                         element,",
          "9392:                         JavascriptNumber::ToVar(k, scriptContext),",
          "9393:                             obj));",
          "9395:                 if (JavascriptConversion::ToBoolean(selected, scriptContext))",
          "9396:                 {",
          "9397:                     if (newArr)",
          "9398:                     {",
          "9399:                         newArr->DirectSetItemAt(i, element);",
          "9400:                     }",
          "9401:                     else",
          "9402:                     {",
          "9403:                             JS_REENTRANT(jsReentLock, ThrowErrorOnFailure(JavascriptArray::SetArrayLikeObjects(newObj, i, element), scriptContext, i));",
          "9404:                     }",
          "9406:                     ++i;",
          "9407:                 }",
          "9408:             }",
          "9409:         }",
          "9411: #ifdef VALIDATE_ARRAY",
          "9412:         if (newArr)",
          "9413:         {",
          "9414:             newArr->ValidateArray();",
          "9415:         }",
          "9416: #endif",
          "9418:         return newObj;",
          "9419:     }",
          "9421:     Var JavascriptArray::EntryReduce(RecyclableObject* function, CallInfo callInfo, ...)",
          "9422:     {",
          "9423:         PROBE_STACK(function->GetScriptContext(), Js::Constants::MinStackDefault);",
          "9425:         ARGUMENTS(args, callInfo);",
          "9426:         ScriptContext* scriptContext = function->GetScriptContext();",
          "9427:         JS_REENTRANCY_LOCK(jsReentLock, scriptContext->GetThreadContext());",
          "9429:         AUTO_TAG_NATIVE_LIBRARY_ENTRY(function, callInfo, _u(\"Array.prototype.reduce\"));",
          "9431:         CHAKRATEL_LANGSTATS_INC_BUILTINCOUNT(Array_Prototype_reduce);",
          "9433:         Assert(!(callInfo.Flags & CallFlags_New));",
          "9435:         if (args.Info.Count == 0)",
          "9436:         {",
          "9437:             JavascriptError::ThrowTypeError(scriptContext, JSERR_This_NullOrUndefined, _u(\"Array.prototype.reduce\"));",
          "9438:         }",
          "9440:         BigIndex length;",
          "9441:         JavascriptArray * pArr = nullptr;",
          "9442:         RecyclableObject* obj = nullptr;",
          "9443:         JS_REENTRANT(jsReentLock, TryGetArrayAndLength(args[0], scriptContext, _u(\"Array.prototype.reduce\"), &pArr, &obj, &length));",
          "9445:         if (length.IsSmallIndex())",
          "9446:         {",
          "9447:             JS_REENTRANT_UNLOCK(jsReentLock, return JavascriptArray::ReduceHelper(pArr, nullptr, obj, length.GetSmallIndex(), args, scriptContext));",
          "9448:         }",
          "9450:         JS_REENTRANT_UNLOCK(jsReentLock, return JavascriptArray::ReduceHelper(pArr, nullptr, obj, length.GetBigIndex(), args, scriptContext));",
          "9451:     }",
          "9454:     template <typename T>",
          "9455:     Var JavascriptArray::ReduceHelper(JavascriptArray* pArr, Js::TypedArrayBase* typedArrayBase, RecyclableObject* obj, T length, Arguments& args, ScriptContext* scriptContext)",
          "9456:     {",
          "9457:         JS_REENTRANCY_LOCK(jsReentLock, scriptContext->GetThreadContext());",
          "9459:         if (args.Info.Count < 2 || !JavascriptConversion::IsCallable(args[1]))",
          "9460:         {",
          "9461:             if (typedArrayBase != nullptr)",
          "9462:             {",
          "9463:                 JavascriptError::ThrowTypeError(scriptContext, JSERR_FunctionArgument_NeedFunction, _u(\"[TypedArray].prototype.reduce\"));",
          "9464:             }",
          "9465:             else",
          "9466:             {",
          "9467:                 JavascriptError::ThrowTypeError(scriptContext, JSERR_FunctionArgument_NeedFunction, _u(\"Array.prototype.reduce\"));",
          "9468:             }",
          "9469:         }",
          "9472:         if (typedArrayBase == nullptr && pArr == nullptr && TypedArrayBase::Is(obj))",
          "9473:         {",
          "9474:             typedArrayBase = TypedArrayBase::FromVar(obj);",
          "9475:         }",
          "9477:         T k = 0;",
          "9478:         RecyclableObject* callBackFn = RecyclableObject::FromVar(args[1]);",
          "9479:         Var accumulator = nullptr;",
          "9480:         Var element = nullptr;",
          "9482:         if (args.Info.Count > 2)",
          "9483:         {",
          "9484:             accumulator = args[2];",
          "9485:         }",
          "9486:         else",
          "9487:         {",
          "9488:             if (length == 0)",
          "9489:             {",
          "9490:                 JavascriptError::ThrowTypeError(scriptContext, VBSERR_ActionNotSupported);",
          "9491:             }",
          "9493:             bool bPresent = false;",
          "9495:             if (pArr)",
          "9496:             {",
          "9497:                 for (; k < length && bPresent == false; k++)",
          "9498:                 {",
          "9499:                     JS_REENTRANT(jsReentLock, BOOL gotItem = pArr->DirectGetItemAtFull((uint32)k, &element));",
          "9500:                     if (!gotItem)",
          "9501:                     {",
          "9502:                         continue;",
          "9503:                     }",
          "9505:                     bPresent = true;",
          "9506:                     accumulator = element;",
          "9507:                 }",
          "9511:                 if (!JavascriptArray::Is(obj))",
          "9512:                 {",
          "9513:                     AssertOrFailFastMsg(ES5Array::Is(obj), \"The array should have been converted to an ES5Array\");",
          "9514:                     pArr = nullptr;",
          "9515:                 }",
          "9516:             }",
          "9517:             else if (typedArrayBase)",
          "9518:             {",
          "9519:                 AssertAndFailFast(TypedArrayBase::Is(typedArrayBase));",
          "9520:                 uint32 end = (uint32)min(length, (T)typedArrayBase->GetLength());",
          "9522:                 for (; k < end && bPresent == false; k++)",
          "9523:                 {",
          "9526:                     element = typedArrayBase->DirectGetItem((uint32)k);",
          "9528:                     bPresent = true;",
          "9529:                     accumulator = element;",
          "9530:                 }",
          "9531:             }",
          "9532:             else",
          "9533:             {",
          "9534:                 for (; k < length && bPresent == false; k++)",
          "9535:                 {",
          "9536:                     JS_REENTRANT(jsReentLock, BOOL hasItem = JavascriptOperators::HasItem(obj, k));",
          "9537:                     if (hasItem)",
          "9538:                     {",
          "9539:                         JS_REENTRANT(jsReentLock, accumulator = JavascriptOperators::GetItem(obj, k, scriptContext));",
          "9540:                         bPresent = true;",
          "9541:                     }",
          "9542:                 }",
          "9543:             }",
          "9545:             if (bPresent == false)",
          "9546:             {",
          "9547:                 JavascriptError::ThrowTypeError(scriptContext, VBSERR_ActionNotSupported);",
          "9548:             }",
          "9549:         }",
          "9551:         Assert(accumulator);",
          "9553:         Var undefinedValue = scriptContext->GetLibrary()->GetUndefined();",
          "9555:         CallFlags flags = CallFlags_Value;",
          "9557:         if (pArr)",
          "9558:         {",
          "9559:             for (; k < length; k++)",
          "9560:             {",
          "9561:                 JS_REENTRANT(jsReentLock, BOOL gotItem = pArr->DirectGetItemAtFull((uint32)k, &element));",
          "9562:                 if (!gotItem)",
          "9563:                 {",
          "9564:                     continue;",
          "9565:                 }",
          "9567:                 JS_REENTRANT(jsReentLock,",
          "9568:                     accumulator = CALL_FUNCTION(scriptContext->GetThreadContext(), callBackFn, CallInfo(flags, 5), undefinedValue,",
          "9569:                         accumulator,",
          "9570:                         element,",
          "9571:                         JavascriptNumber::ToVar(k, scriptContext),",
          "9572:                         pArr));",
          "9576:                 if (!JavascriptArray::Is(obj))",
          "9577:                 {",
          "9578:                     AssertOrFailFastMsg(ES5Array::Is(obj), \"The array should have been converted to an ES5Array\");",
          "9579:                     JS_REENTRANT_UNLOCK(jsReentLock, return JavascriptArray::ReduceObjectHelper<T>(obj, length, k + 1, callBackFn, accumulator, scriptContext));",
          "9580:                 }",
          "9581:             }",
          "9582:         }",
          "9583:         else if (typedArrayBase)",
          "9584:         {",
          "9585:             AssertAndFailFast(TypedArrayBase::Is(typedArrayBase));",
          "9586:             uint32 end = (uint32)min(length, (T)typedArrayBase->GetLength());",
          "9588:             for (; k < end; k++)",
          "9589:             {",
          "9592:                 element = typedArrayBase->DirectGetItem((uint32)k);",
          "9594:                 JS_REENTRANT(jsReentLock,",
          "9595:                     accumulator = CALL_FUNCTION(scriptContext->GetThreadContext(), callBackFn, CallInfo(flags, 5), undefinedValue,",
          "9596:                         accumulator,",
          "9597:                         element,",
          "9598:                         JavascriptNumber::ToVar(k, scriptContext),",
          "9599:                         typedArrayBase));",
          "9600:             }",
          "9601:         }",
          "9602:         else",
          "9603:         {",
          "9604:             JS_REENTRANT_UNLOCK(jsReentLock, return JavascriptArray::ReduceObjectHelper<T>(obj, length, k, callBackFn, accumulator, scriptContext));",
          "9605:         }",
          "9607:         return accumulator;",
          "9608:     }",
          "9610:     template <typename T>",
          "9611:     Var JavascriptArray::ReduceObjectHelper(RecyclableObject* obj, T length, T start, RecyclableObject* callBackFn, Var accumulator, ScriptContext* scriptContext)",
          "9612:     {",
          "9613:         JS_REENTRANCY_LOCK(jsReentLock, scriptContext->GetThreadContext());",
          "9616:         CallFlags flags = CallFlags_Value;",
          "9617:         Var element = nullptr;",
          "9619:         for (T k = start; k < length; k++)",
          "9620:         {",
          "9621:                 JS_REENTRANT(jsReentLock, BOOL hasItem = JavascriptOperators::HasItem(obj, k));",
          "9622:                 if (hasItem)",
          "9623:             {",
          "9624:                     JS_REENTRANT(jsReentLock,",
          "9625:                         element = JavascriptOperators::GetItem(obj, k, scriptContext),",
          "9626:                         accumulator = CALL_FUNCTION(scriptContext->GetThreadContext(), callBackFn, CallInfo(flags, 5), scriptContext->GetLibrary()->GetUndefined(),",
          "9627:                             accumulator,",
          "9628:                             element,",
          "9629:                             JavascriptNumber::ToVar(k, scriptContext),",
          "9630:                             obj));",
          "9631:             }",
          "9632:         }",
          "9634:         return accumulator;",
          "9635:     }",
          "9637:     Var JavascriptArray::EntryReduceRight(RecyclableObject* function, CallInfo callInfo, ...)",
          "9638:     {",
          "9639:         PROBE_STACK(function->GetScriptContext(), Js::Constants::MinStackDefault);",
          "9641:         ARGUMENTS(args, callInfo);",
          "9642:         ScriptContext* scriptContext = function->GetScriptContext();",
          "9643:         JS_REENTRANCY_LOCK(jsReentLock, scriptContext->GetThreadContext());",
          "9645:         AUTO_TAG_NATIVE_LIBRARY_ENTRY(function, callInfo, _u(\"Array.prototype.reduceRight\"));",
          "9647:         CHAKRATEL_LANGSTATS_INC_BUILTINCOUNT(Array_Prototype_reduceRight);",
          "9649:         Assert(!(callInfo.Flags & CallFlags_New));",
          "9651:         if (args.Info.Count == 0)",
          "9652:         {",
          "9653:             JavascriptError::ThrowTypeError(scriptContext, JSERR_This_NullOrUndefined, _u(\"Array.prototype.reduceRight\"));",
          "9654:         }",
          "9656:         BigIndex length;",
          "9657:         JavascriptArray * pArr = nullptr;",
          "9658:         RecyclableObject* obj = nullptr;",
          "9659:         JS_REENTRANT(jsReentLock, TryGetArrayAndLength(args[0], scriptContext, _u(\"Array.prototype.reduceRight\"), &pArr, &obj, &length));",
          "9661:         if (length.IsSmallIndex())",
          "9662:         {",
          "9663:             JS_REENTRANT_UNLOCK(jsReentLock, return JavascriptArray::ReduceRightHelper(pArr, nullptr, obj, length.GetSmallIndex(), args, scriptContext));",
          "9664:         }",
          "9666:         JS_REENTRANT_UNLOCK(jsReentLock, return JavascriptArray::ReduceRightHelper(pArr, nullptr, obj, length.GetBigIndex(), args, scriptContext));",
          "9667:     }",
          "9670:     template <typename T>",
          "9671:     Var JavascriptArray::ReduceRightHelper(JavascriptArray* pArr, Js::TypedArrayBase* typedArrayBase, RecyclableObject* obj, T length, Arguments& args, ScriptContext* scriptContext)",
          "9672:     {",
          "9673:         JS_REENTRANCY_LOCK(jsReentLock, scriptContext->GetThreadContext());",
          "9675:         if (args.Info.Count < 2 || !JavascriptConversion::IsCallable(args[1]))",
          "9676:         {",
          "9677:             if (typedArrayBase != nullptr)",
          "9678:             {",
          "9679:                 JavascriptError::ThrowTypeError(scriptContext, JSERR_FunctionArgument_NeedFunction, _u(\"[TypedArray].prototype.reduceRight\"));",
          "9680:             }",
          "9681:             else",
          "9682:             {",
          "9683:                 JavascriptError::ThrowTypeError(scriptContext, JSERR_FunctionArgument_NeedFunction, _u(\"Array.prototype.reduceRight\"));",
          "9684:             }",
          "9685:         }",
          "9688:         if (typedArrayBase == nullptr && pArr == nullptr && TypedArrayBase::Is(obj))",
          "9689:         {",
          "9690:             typedArrayBase = TypedArrayBase::FromVar(obj);",
          "9691:         }",
          "9693:         RecyclableObject* callBackFn = RecyclableObject::FromVar(args[1]);",
          "9694:         Var accumulator = nullptr;",
          "9695:         Var element = nullptr;",
          "9696:         T k = 0;",
          "9697:         T index = 0;",
          "9699:         if (args.Info.Count > 2)",
          "9700:         {",
          "9701:             accumulator = args[2];",
          "9702:         }",
          "9703:         else",
          "9704:         {",
          "9705:             if (length == 0)",
          "9706:             {",
          "9707:                 JavascriptError::ThrowTypeError(scriptContext, VBSERR_ActionNotSupported);",
          "9708:             }",
          "9710:             bool bPresent = false;",
          "9711:             if (pArr)",
          "9712:             {",
          "9713:                 for (; k < length && bPresent == false; k++)",
          "9714:                 {",
          "9715:                     index = length - k - 1;",
          "9716:                     JS_REENTRANT(jsReentLock, BOOL gotItem = pArr->DirectGetItemAtFull((uint32)index, &element));",
          "9717:                     if (!gotItem)",
          "9718:                     {",
          "9719:                         continue;",
          "9720:                     }",
          "9721:                     bPresent = true;",
          "9722:                     accumulator = element;",
          "9723:                 }",
          "9727:                 if (!JavascriptArray::Is(obj))",
          "9728:                 {",
          "9729:                     AssertOrFailFastMsg(ES5Array::Is(obj), \"The array should have been converted to an ES5Array\");",
          "9730:                     pArr = nullptr;",
          "9731:                 }",
          "9732:             }",
          "9733:             else if (typedArrayBase)",
          "9734:             {",
          "9735:                 AssertAndFailFast(TypedArrayBase::Is(typedArrayBase));",
          "9736:                 uint32 end = (uint32)min(length, (T)typedArrayBase->GetLength());",
          "9738:                 for (; k < end && bPresent == false; k++)",
          "9739:                 {",
          "9742:                     index = length - k - 1;",
          "9743:                     element = typedArrayBase->DirectGetItem((uint32)index);",
          "9744:                     bPresent = true;",
          "9745:                     accumulator = element;",
          "9746:                 }",
          "9747:             }",
          "9748:             else",
          "9749:             {",
          "9750:                 for (; k < length && bPresent == false; k++)",
          "9751:                 {",
          "9752:                     index = length - k - 1;",
          "9753:                     JS_REENTRANT(jsReentLock, BOOL hasItem = JavascriptOperators::HasItem(obj, index));",
          "9754:                     if (hasItem)",
          "9755:                     {",
          "9756:                         JS_REENTRANT(jsReentLock, accumulator = JavascriptOperators::GetItem(obj, index, scriptContext));",
          "9757:                         bPresent = true;",
          "9758:                     }",
          "9759:                 }",
          "9760:             }",
          "9761:             if (bPresent == false)",
          "9762:             {",
          "9763:                 JavascriptError::ThrowTypeError(scriptContext, VBSERR_ActionNotSupported);",
          "9764:             }",
          "9765:         }",
          "9768:         CallFlags flags = CallFlags_Value;",
          "9769:         Var undefinedValue = scriptContext->GetLibrary()->GetUndefined();",
          "9771:         if (pArr)",
          "9772:         {",
          "9773:             for (; k < length; k++)",
          "9774:             {",
          "9775:                 index = length - k - 1;",
          "9776:                 JS_REENTRANT(jsReentLock, BOOL gotItem = pArr->DirectGetItemAtFull((uint32)index, &element));",
          "9777:                 if (!gotItem)",
          "9778:                 {",
          "9779:                     continue;",
          "9780:                 }",
          "9782:                 JS_REENTRANT(jsReentLock,",
          "9783:                     accumulator = CALL_FUNCTION(scriptContext->GetThreadContext(), callBackFn, CallInfo(flags, 5), undefinedValue,",
          "9784:                         accumulator,",
          "9785:                         element,",
          "9786:                         JavascriptNumber::ToVar(index, scriptContext),",
          "9787:                         pArr));",
          "9791:                 if (!JavascriptArray::Is(obj))",
          "9792:                 {",
          "9793:                     AssertOrFailFastMsg(ES5Array::Is(obj), \"The array should have been converted to an ES5Array\");",
          "9794:                     JS_REENTRANT_UNLOCK(jsReentLock, return JavascriptArray::ReduceRightObjectHelper<T>(obj, length, k + 1, callBackFn, accumulator, scriptContext));",
          "9795:                 }",
          "9796:             }",
          "9797:         }",
          "9798:         else if (typedArrayBase)",
          "9799:         {",
          "9800:             AssertAndFailFast(TypedArrayBase::Is(typedArrayBase));",
          "9801:             uint32 end = (uint32)min(length, (T)typedArrayBase->GetLength());",
          "9803:             for (; k < end; k++)",
          "9804:             {",
          "9807:                 index = length - k - 1;",
          "9808:                 element = typedArrayBase->DirectGetItem((uint32)index);",
          "9810:                 JS_REENTRANT(jsReentLock,",
          "9811:                     accumulator = CALL_FUNCTION(scriptContext->GetThreadContext(), callBackFn, CallInfo(flags, 5), undefinedValue,",
          "9812:                         accumulator,",
          "9813:                         element,",
          "9814:                         JavascriptNumber::ToVar(index, scriptContext),",
          "9815:                         typedArrayBase));",
          "9816:             }",
          "9817:         }",
          "9818:         else",
          "9819:         {",
          "9820:             JS_REENTRANT_UNLOCK(jsReentLock, return JavascriptArray::ReduceRightObjectHelper<T>(obj, length, k, callBackFn, accumulator, scriptContext));",
          "9821:         }",
          "9823:         return accumulator;",
          "9824:     }",
          "9826:     template <typename T>",
          "9827:     Var JavascriptArray::ReduceRightObjectHelper(RecyclableObject* obj, T length, T start, RecyclableObject* callBackFn, Var accumulator, ScriptContext* scriptContext)",
          "9828:     {",
          "9829:         JS_REENTRANCY_LOCK(jsReentLock, scriptContext->GetThreadContext());",
          "9832:         CallFlags flags = CallFlags_Value;",
          "9833:         Var element = nullptr;",
          "9834:         T index = 0;",
          "9836:         for (T k = start; k < length; k++)",
          "9837:         {",
          "9838:             index = length - k - 1;",
          "9839:             JS_REENTRANT(jsReentLock, BOOL hasItem = JavascriptOperators::HasItem(obj, index));",
          "9840:             if (hasItem)",
          "9841:             {",
          "9842:                 JS_REENTRANT(jsReentLock,",
          "9843:                     element = JavascriptOperators::GetItem(obj, index, scriptContext),",
          "9844:                     accumulator = CALL_FUNCTION(scriptContext->GetThreadContext(),",
          "9845:                         callBackFn, CallInfo(flags, 5), scriptContext->GetLibrary()->GetUndefined(),",
          "9846:                         accumulator,",
          "9847:                         element,",
          "9848:                         JavascriptNumber::ToVar(index, scriptContext),",
          "9849:                         obj));",
          "9850:             }",
          "9851:         }",
          "9853:         return accumulator;",
          "9854:     }",
          "9856:     Var JavascriptArray::EntryFrom(RecyclableObject* function, CallInfo callInfo, ...)",
          "9857:     {",
          "9858:         PROBE_STACK(function->GetScriptContext(), Js::Constants::MinStackDefault);",
          "9860:         ARGUMENTS(args, callInfo);",
          "9861:         ScriptContext* scriptContext = function->GetScriptContext();",
          "9862:         JS_REENTRANCY_LOCK(jsReentLock, scriptContext->GetThreadContext());",
          "9864:         AUTO_TAG_NATIVE_LIBRARY_ENTRY(function, callInfo, _u(\"Array.from\"));",
          "9866:         Assert(!(callInfo.Flags & CallFlags_New));",
          "9868:         JavascriptLibrary* library = scriptContext->GetLibrary();",
          "9869:         RecyclableObject* constructor = nullptr;",
          "9871:         if (JavascriptOperators::IsConstructor(args[0]))",
          "9872:         {",
          "9873:             constructor = RecyclableObject::FromVar(args[0]);",
          "9874:         }",
          "9876:         RecyclableObject* items = nullptr;",
          "9878:         if (args.Info.Count < 2 || !JavascriptConversion::ToObject(args[1], scriptContext, &items))",
          "9879:         {",
          "9880:             JavascriptError::ThrowTypeError(scriptContext, JSERR_FunctionArgument_NeedObject, _u(\"Array.from\"));",
          "9881:         }",
          "9883:         JavascriptArray* itemsArr = nullptr;",
          "9885:         if (JavascriptArray::Is(items))",
          "9886:         {",
          "9887: #if ENABLE_COPYONACCESS_ARRAY",
          "9888:             JavascriptLibrary::CheckAndConvertCopyOnAccessNativeIntArray<Var>(items);",
          "9889: #endif",
          "9890:             itemsArr = JavascriptArray::FromVar(items);",
          "9891:         }",
          "9893:         bool mapping = false;",
          "9894:         JavascriptFunction* mapFn = nullptr;",
          "9895:         Var mapFnThisArg = nullptr;",
          "9897:         if (args.Info.Count >= 3 && !JavascriptOperators::IsUndefinedObject(args[2]))",
          "9898:         {",
          "9899:             if (!JavascriptFunction::Is(args[2]))",
          "9900:             {",
          "9901:                 JavascriptError::ThrowTypeError(scriptContext, JSERR_FunctionArgument_NeedFunction, _u(\"Array.from\"));",
          "9902:             }",
          "9904:             mapFn = JavascriptFunction::FromVar(args[2]);",
          "9906:             if (args.Info.Count >= 4)",
          "9907:             {",
          "9908:                 mapFnThisArg = args[3];",
          "9909:             }",
          "9910:             else",
          "9911:             {",
          "9912:                 mapFnThisArg = library->GetUndefined();",
          "9913:             }",
          "9915:             mapping = true;",
          "9916:         }",
          "9918:         RecyclableObject* newObj = nullptr;",
          "9919:         JavascriptArray* newArr = nullptr;",
          "9921:         JS_REENTRANT(jsReentLock, RecyclableObject* iterator = JavascriptOperators::GetIterator(items, scriptContext, true /* optional */));",
          "9923:         if (iterator != nullptr)",
          "9924:         {",
          "9925:             if (constructor)",
          "9926:             {",
          "9927:                 Js::Var constructorArgs[] = { constructor };",
          "9928:                 Js::CallInfo constructorCallInfo(Js::CallFlags_New, _countof(constructorArgs));",
          "9929:                 JS_REENTRANT(jsReentLock, newObj = RecyclableObject::FromVar(JavascriptOperators::NewScObject(constructor, Js::Arguments(constructorCallInfo, constructorArgs), scriptContext)));",
          "9931:                 if (JavascriptArray::Is(newObj))",
          "9932:                 {",
          "9933: #if ENABLE_COPYONACCESS_ARRAY",
          "9934:                     JavascriptLibrary::CheckAndConvertCopyOnAccessNativeIntArray<Var>(newObj);",
          "9935: #endif",
          "9936:                     newArr = JavascriptArray::FromVar(newObj);",
          "9937:                 }",
          "9938:             }",
          "9939:             else",
          "9940:             {",
          "9941:                 newArr = scriptContext->GetLibrary()->CreateArray(0);",
          "9942:                 newArr->EnsureHead<Var>();",
          "9943:                 newObj = newArr;",
          "9944:             }",
          "9946:             uint32 k = 0;",
          "9948:             JS_REENTRANT(jsReentLock, JavascriptOperators::DoIteratorStepAndValue(iterator, scriptContext, [&](Var nextValue) {",
          "9949:                 if (mapping)",
          "9950:                 {",
          "9951:                     Assert(mapFn != nullptr);",
          "9952:                     Assert(mapFnThisArg != nullptr);",
          "9954:                     Js::Var mapFnArgs[] = { mapFnThisArg, nextValue, JavascriptNumber::ToVar(k, scriptContext) };",
          "9955:                     Js::CallInfo mapFnCallInfo(Js::CallFlags_Value, _countof(mapFnArgs));",
          "9956:                     nextValue = mapFn->CallFunction(Js::Arguments(mapFnCallInfo, mapFnArgs));",
          "9957:                 }",
          "9959:                 if (newArr)",
          "9960:                 {",
          "9961:                     newArr->SetItem(k, nextValue, PropertyOperation_None);",
          "9962:                 }",
          "9963:                 else",
          "9964:                 {",
          "9965:                     ThrowErrorOnFailure(JavascriptArray::SetArrayLikeObjects(newObj, k, nextValue), scriptContext, k);",
          "9966:                 }",
          "9968:                 k++;",
          "9969:             }));",
          "9971:             JS_REENTRANT(jsReentLock, JavascriptOperators::SetProperty(newObj, newObj, Js::PropertyIds::length, JavascriptNumber::ToVar(k, scriptContext), scriptContext, PropertyOperation_ThrowIfNotExtensible));",
          "9972:         }",
          "9973:         else",
          "9974:         {",
          "9975:             JS_REENTRANT(jsReentLock, int64 len = (int64)OP_GetLength(items, scriptContext));",
          "9977:             if (constructor)",
          "9978:             {",
          "9979:                 Js::Var constructorArgs[] = { constructor, JavascriptNumber::ToVar(len, scriptContext) };",
          "9980:                 Js::CallInfo constructorCallInfo(Js::CallFlags_New, _countof(constructorArgs));",
          "9981:                 JS_REENTRANT(jsReentLock, newObj = RecyclableObject::FromVar(JavascriptOperators::NewScObject(constructor, Js::Arguments(constructorCallInfo, constructorArgs), scriptContext)));",
          "9983:                 if (JavascriptArray::Is(newObj))",
          "9984:                 {",
          "9985: #if ENABLE_COPYONACCESS_ARRAY",
          "9986:                     JavascriptLibrary::CheckAndConvertCopyOnAccessNativeIntArray<Var>(newObj);",
          "9987: #endif",
          "9988:                     newArr = JavascriptArray::FromVar(newObj);",
          "9989:                 }",
          "9990:             }",
          "9991:             else",
          "9992:             {",
          "9994:                 if (len > MaxArrayLength)",
          "9995:                 {",
          "9996:                     JavascriptError::ThrowRangeError(scriptContext, JSERR_ArrayLengthAssignIncorrect, _u(\"Array.from\"));",
          "9997:                 }",
          "10000:                 newArr = scriptContext->GetLibrary()->CreateArray(static_cast<uint32>(len));",
          "10001:                 newArr->EnsureHead<Var>();",
          "10002:                 newObj = newArr;",
          "10003:             }",
          "10005:             uint32 k = 0;",
          "10007:             for ( ; k < len; k++)",
          "10008:             {",
          "10009:                 Var kValue;",
          "10011:                 if (itemsArr)",
          "10012:                 {",
          "10013:                     JS_REENTRANT(jsReentLock, kValue = itemsArr->DirectGetItem(k));",
          "10014:                 }",
          "10015:                 else",
          "10016:                 {",
          "10017:                     JS_REENTRANT(jsReentLock, kValue = JavascriptOperators::OP_GetElementI_UInt32(items, k, scriptContext));",
          "10018:                 }",
          "10020:                 if (mapping)",
          "10021:                 {",
          "10022:                     Assert(mapFn != nullptr);",
          "10023:                     Assert(mapFnThisArg != nullptr);",
          "10025:                     Js::Var mapFnArgs[] = { mapFnThisArg, kValue, JavascriptNumber::ToVar(k, scriptContext) };",
          "10026:                     Js::CallInfo mapFnCallInfo(Js::CallFlags_Value, _countof(mapFnArgs));",
          "10027:                     JS_REENTRANT(jsReentLock, kValue = mapFn->CallFunction(Js::Arguments(mapFnCallInfo, mapFnArgs)));",
          "10028:                 }",
          "10030:                 if (newArr)",
          "10031:                 {",
          "10032:                     newArr->SetItem(k, kValue, PropertyOperation_None);",
          "10033:                 }",
          "10034:                 else",
          "10035:                 {",
          "10036:                     JS_REENTRANT(jsReentLock, ThrowErrorOnFailure(JavascriptArray::SetArrayLikeObjects(newObj, k, kValue), scriptContext, k));",
          "10037:                 }",
          "10038:             }",
          "10040:             JS_REENTRANT(jsReentLock, JavascriptOperators::SetProperty(newObj, newObj, Js::PropertyIds::length, JavascriptNumber::ToVar(len, scriptContext), scriptContext, PropertyOperation_ThrowIfNotExtensible));",
          "10041:         }",
          "10043:         return newObj;",
          "10044:     }",
          "10046:     Var JavascriptArray::EntryOf(RecyclableObject* function, CallInfo callInfo, ...)",
          "10047:     {",
          "10048:         PROBE_STACK(function->GetScriptContext(), Js::Constants::MinStackDefault);",
          "10050:         ARGUMENTS(args, callInfo);",
          "10051:         ScriptContext* scriptContext = function->GetScriptContext();",
          "10052:         JS_REENTRANCY_LOCK(jsReentLock, scriptContext->GetThreadContext());",
          "10054:         Assert(!(callInfo.Flags & CallFlags_New));",
          "10056:         if (args.Info.Count == 0)",
          "10057:         {",
          "10058:             JavascriptError::ThrowTypeError(scriptContext, JSERR_This_NullOrUndefined, _u(\"Array.of\"));",
          "10059:         }",
          "10061:         JS_REENTRANT_UNLOCK(jsReentLock, return JavascriptArray::OfHelper(false, args, scriptContext));",
          "10062:     }",
          "10064:     Var JavascriptArray::EntryGetterSymbolSpecies(RecyclableObject* function, CallInfo callInfo, ...)",
          "10065:     {",
          "10066:         ARGUMENTS(args, callInfo);",
          "10068:         Assert(args.Info.Count > 0);",
          "10070:         return args[0];",
          "10071:     }",
          "10074:     Var JavascriptArray::OfHelper(bool isTypedArrayEntryPoint, Arguments& args, ScriptContext* scriptContext)",
          "10075:     {",
          "10076:         JS_REENTRANCY_LOCK(jsReentLock, scriptContext->GetThreadContext());",
          "10078:         Assert(args.Info.Count > 0);",
          "10081:         uint32 len = args.Info.Count - 1;",
          "10082:         Var newObj = nullptr;",
          "10083:         JavascriptArray* newArr = nullptr;",
          "10084:         TypedArrayBase* newTypedArray = nullptr;",
          "10085:         bool isBuiltinArrayCtor = true;",
          "10087:         if (JavascriptOperators::IsConstructor(args[0]))",
          "10088:         {",
          "10089:             RecyclableObject* constructor = RecyclableObject::FromVar(args[0]);",
          "10090:             isBuiltinArrayCtor = (constructor == scriptContext->GetLibrary()->GetArrayConstructor());",
          "10092:             Js::Var constructorArgs[] = { constructor, JavascriptNumber::ToVar(len, scriptContext) };",
          "10093:             Js::CallInfo constructorCallInfo(Js::CallFlags_New, _countof(constructorArgs));",
          "10094:             if (isTypedArrayEntryPoint)",
          "10095:             {",
          "10096:                 JS_REENTRANT(jsReentLock, newObj = TypedArrayBase::TypedArrayCreate(constructor, &Js::Arguments(constructorCallInfo, constructorArgs), len, scriptContext));",
          "10097:             }",
          "10098:             else",
          "10099:             {",
          "10100:                 JS_REENTRANT(jsReentLock, newObj = JavascriptOperators::NewScObject(constructor, Js::Arguments(constructorCallInfo, constructorArgs), scriptContext));",
          "10101:             }",
          "10104:             if (JavascriptArray::Is(newObj))",
          "10105:             {",
          "10106: #if ENABLE_COPYONACCESS_ARRAY",
          "10107:                 JavascriptLibrary::CheckAndConvertCopyOnAccessNativeIntArray<Var>(newObj);",
          "10108: #endif",
          "10109:                 newArr = JavascriptArray::FromVar(newObj);",
          "10110:             }",
          "10111:             else if (TypedArrayBase::Is(newObj))",
          "10112:             {",
          "10113:                 newTypedArray = TypedArrayBase::FromVar(newObj);",
          "10114:             }",
          "10115:         }",
          "10116:         else",
          "10117:         {",
          "10119:             if (isTypedArrayEntryPoint)",
          "10120:             {",
          "10121:                 JavascriptError::ThrowTypeError(scriptContext, JSERR_This_NeedFunction, _u(\"[TypedArray].of\"));",
          "10122:             }",
          "10124:             newArr = scriptContext->GetLibrary()->CreateArray(len);",
          "10125:             newArr->EnsureHead<Var>();",
          "10126:             newObj = newArr;",
          "10127:         }",
          "10130:         Assert(newObj);",
          "10132:         if (isBuiltinArrayCtor)",
          "10133:         {",
          "10134:             for (uint32 k = 0; k < len; k++)",
          "10135:             {",
          "10136:                 Var kValue = args[k + 1];",
          "10138:                 newArr->DirectSetItemAt(k, kValue);",
          "10139:             }",
          "10140:         }",
          "10141:         else if (newTypedArray)",
          "10142:         {",
          "10143:             for (uint32 k = 0; k < len; k++)",
          "10144:             {",
          "10145:                 Var kValue = args[k + 1];",
          "10147:                 JS_REENTRANT(jsReentLock, newTypedArray->DirectSetItem(k, kValue));",
          "10148:             }",
          "10149:         }",
          "10150:         else",
          "10151:         {",
          "10152:             for (uint32 k = 0; k < len; k++)",
          "10153:             {",
          "10154:                 Var kValue = args[k + 1];",
          "10155:                 JS_REENTRANT(jsReentLock, ThrowErrorOnFailure(JavascriptArray::SetArrayLikeObjects(RecyclableObject::FromVar(newObj), k, kValue), scriptContext, k));",
          "10156:             }",
          "10157:         }",
          "10159:         if (!isTypedArrayEntryPoint)",
          "10160:         {",
          "10162:             JS_REENTRANT(jsReentLock, JavascriptOperators::OP_SetProperty(newObj, Js::PropertyIds::length, JavascriptNumber::ToVar(len, scriptContext), scriptContext, nullptr, PropertyOperation_ThrowIfNotExtensible));",
          "10163:         }",
          "10165:         return newObj;",
          "10166:     }",
          "10168:     JavascriptString* JavascriptArray::ToLocaleStringHelper(Var value, ScriptContext* scriptContext)",
          "10169:     {",
          "10170:         TypeId typeId = JavascriptOperators::GetTypeId(value);",
          "10171:         if (typeId == TypeIds_Null || typeId == TypeIds_Undefined)",
          "10172:         {",
          "10173:             return scriptContext->GetLibrary()->GetEmptyString();",
          "10174:         }",
          "10175:         else",
          "10176:         {",
          "10177:             return JavascriptConversion::ToLocaleString(value, scriptContext);",
          "10178:         }",
          "10179:     }",
          "10181:     inline BOOL JavascriptArray::IsFullArray() const",
          "10182:     {",
          "10183:         if (head && head->length == length)",
          "10184:         {",
          "10185:             AssertMsg(head->next == 0 && head->left == 0, \"Invalid Array\");",
          "10186:             return true;",
          "10187:         }",
          "10188:         return (0 == length);",
          "10189:     }",
          "10196:     bool JavascriptArray::IsFillFromPrototypes()",
          "10197:     {",
          "10198:         return !(this->head->next == nullptr && this->HasNoMissingValues() && this->length == this->head->length);",
          "10199:     }",
          "10203:     void JavascriptArray::FillFromPrototypes(uint32 startIndex, uint32 limitIndex)",
          "10204:     {",
          "10205:         if (startIndex >= limitIndex)",
          "10206:         {",
          "10207:             return;",
          "10208:         }",
          "10210:         RecyclableObject* prototype = this->GetPrototype();",
          "10213:         while (JavascriptOperators::GetTypeId(prototype) != TypeIds_Null)",
          "10214:         {",
          "10215:             ForEachOwnMissingArrayIndexOfObject(this, nullptr, prototype, startIndex, limitIndex,0, [this](uint32 index, Var value) {",
          "10216:                 this->SetItem(index, value, PropertyOperation_None);",
          "10217:             });",
          "10219:             prototype = prototype->GetPrototype();",
          "10220:         }",
          "10221: #ifdef VALIDATE_ARRAY",
          "10222:         ValidateArray();",
          "10223: #endif",
          "10224:     }",
          "10229:     template<typename T>",
          "10230:     void JavascriptArray::EnsureHeadStartsFromZero(Recycler * recycler)",
          "10231:     {",
          "10232:         if (head == nullptr || head->left != 0)",
          "10233:         {",
          "10236:             ClearSegmentMap();",
          "10243:             SparseArraySegment<T>* savedHead = SparseArraySegment<T>::From(this->head);",
          "10244:             SparseArraySegment<T>* savedLastUsedSegment = (SparseArraySegment<T>*)this->GetLastUsedSegment();",
          "10245:             SetHeadAndLastUsedSegment(const_cast<SparseArraySegmentBase*>(EmptySegment));",
          "10247:             SparseArraySegment<T> *newSeg = SparseArraySegment<T>::AllocateSegment(recycler, 0, 0, savedHead);",
          "10248:             newSeg->next = savedHead;",
          "10249:             this->head = newSeg;",
          "10250:             SetHasNoMissingValues();",
          "10251:             this->SetLastUsedSegment(savedLastUsedSegment);",
          "10252:         }",
          "10253:     }",
          "10255: #ifdef ENABLE_DEBUG_CONFIG_OPTIONS",
          "10256:     void JavascriptArray::CheckForceES5Array()",
          "10257:     {",
          "10258:         if (Configuration::Global.flags.ForceES5Array)",
          "10259:         {",
          "10262:             if (PHASE_OFF1(NativeArrayPhase))",
          "10263:             {",
          "10264:                 GetTypeHandler()->ConvertToTypeWithItemAttributes(this);",
          "10265:             }",
          "10266:         }",
          "10267:     }",
          "10268: #endif",
          "10270:     template <typename T, typename Fn>",
          "10271:     void JavascriptArray::ForEachOwnMissingArrayIndexOfObject(JavascriptArray *baseArray, JavascriptArray *destArray, RecyclableObject* obj, uint32 startIndex, uint32 limitIndex, T destIndex, Fn fn)",
          "10272:     {",
          "10273:         JS_REENTRANCY_LOCK(jsReentLock, baseArray->GetScriptContext()->GetThreadContext());",
          "10274:         Assert(DynamicObject::IsAnyArray(obj) || JavascriptOperators::IsObject(obj));",
          "10276:         Var oldValue;",
          "10277:         JavascriptArray* arr = nullptr;",
          "10278:         if (DynamicObject::IsAnyArray(obj))",
          "10279:         {",
          "10280:             arr = JavascriptArray::FromAnyArray(obj);",
          "10281:         }",
          "10282:         else if (DynamicType::Is(obj->GetTypeId()))",
          "10283:         {",
          "10284:             DynamicObject* dynobj = DynamicObject::FromVar(obj);",
          "10285:             ArrayObject* objectArray = dynobj->GetObjectArray();",
          "10286:             arr = (objectArray && JavascriptArray::IsAnyArray(objectArray)) ? JavascriptArray::FromAnyArray(objectArray) : nullptr;",
          "10287:         }",
          "10289:         if (arr != nullptr)",
          "10290:         {",
          "10291:             if (JavascriptArray::Is(arr))",
          "10292:             {",
          "10293:                 arr = EnsureNonNativeArray(arr);",
          "10294:                 ArrayElementEnumerator e(arr, startIndex, limitIndex);",
          "10296:                 while(e.MoveNext<Var>())",
          "10297:                 {",
          "10298:                     uint32 index = e.GetIndex();",
          "10299:                     if (!baseArray->DirectGetVarItemAt(index, &oldValue, baseArray->GetScriptContext()))",
          "10300:                     {",
          "10301:                         T n = destIndex + (index - startIndex);",
          "10302:                         if (destArray == nullptr || !destArray->DirectGetItemAt(n, &oldValue))",
          "10303:                         {",
          "10304:                             JS_REENTRANT(jsReentLock, fn(index, e.GetItem<Var>()));",
          "10305:                         }",
          "10306:                     }",
          "10307:                 }",
          "10308:             }",
          "10309:             else",
          "10310:             {",
          "10311:                 ScriptContext* scriptContext = obj->GetScriptContext();",
          "10313:                 Assert(ES5Array::Is(arr));",
          "10315:                 ES5Array* es5Array = ES5Array::FromVar(arr);",
          "10316:                 ES5ArrayIndexStaticEnumerator<true> e(es5Array);",
          "10318:                 while (e.MoveNext())",
          "10319:                 {",
          "10320:                     uint32 index = e.GetIndex();",
          "10321:                     if (index < startIndex) continue;",
          "10322:                     else if (index >= limitIndex) break;",
          "10324:                     if (!baseArray->DirectGetVarItemAt(index, &oldValue, baseArray->GetScriptContext()))",
          "10325:                     {",
          "10326:                         T n = destIndex + (index - startIndex);",
          "10327:                         if (destArray == nullptr || !destArray->DirectGetItemAt(n, &oldValue))",
          "10328:                         {",
          "10329:                             Var value = nullptr;",
          "10330:                             JS_REENTRANT(jsReentLock, BOOL gotItem = JavascriptOperators::GetOwnItem(obj, index, &value, scriptContext));",
          "10331:                             if (gotItem)",
          "10332:                             {",
          "10333:                                 JS_REENTRANT(jsReentLock, fn(index, value));",
          "10334:                             }",
          "10335:                         }",
          "10336:                     }",
          "10337:                 }",
          "10338:             }",
          "10339:         }",
          "10340:     }",
          "10345:     JavascriptArray::ArrayElementEnumerator::ArrayElementEnumerator(JavascriptArray* arr, uint32 start, uint32 end)",
          "10346:         : start(start), end(min(end, arr->length))",
          "10347:     {",
          "10348:         Init(arr);",
          "10349:     }",
          "10354:     void JavascriptArray::ArrayElementEnumerator::Init(JavascriptArray* arr)",
          "10355:     {",
          "10357:         seg = (arr ? arr->GetBeginLookupSegment(start) : nullptr);",
          "10358:         while (seg && (seg->left + seg->length <= start))",
          "10359:         {",
          "10360:             seg = seg->next;",
          "10361:         }",
          "10364:         if (seg)",
          "10365:         {",
          "10366:             if (seg->left >= end)",
          "10367:             {",
          "10368:                 seg = nullptr;",
          "10369:             }",
          "10370:             else",
          "10371:             {",
          "10373:                 index = max(seg->left, start) - seg->left - 1;",
          "10374:                 endIndex = min(end - seg->left, seg->length);",
          "10375:             }",
          "10376:         }",
          "10377:     }",
          "10382:     template<typename T>",
          "10383:     inline bool JavascriptArray::ArrayElementEnumerator::MoveNext()",
          "10384:     {",
          "10385:         while (seg)",
          "10386:         {",
          "10388:             while (++index < endIndex)",
          "10389:             {",
          "10390:                 if (!SparseArraySegment<T>::IsMissingItem(&((SparseArraySegment<T>*)seg)->elements[index]))",
          "10391:                 {",
          "10392:                     return true;",
          "10393:                 }",
          "10394:             }",
          "10397:             seg = seg->next;",
          "10398:             if (seg)",
          "10399:             {",
          "10400:                 if (seg->left >= end)",
          "10401:                 {",
          "10402:                     seg = nullptr;",
          "10403:                     break;",
          "10404:                 }",
          "10405:                 else",
          "10406:                 {",
          "10407:                     index = static_cast<uint32>(-1);",
          "10408:                     endIndex = min(end - seg->left, seg->length);",
          "10409:                 }",
          "10410:             }",
          "10411:         }",
          "10413:         return false;",
          "10414:     }",
          "10419:     uint32 JavascriptArray::ArrayElementEnumerator::GetIndex() const",
          "10420:     {",
          "10421:         Assert(seg && index < seg->length && index < endIndex);",
          "10422:         return seg->left + index;",
          "10423:     }",
          "10428:     template<typename T>",
          "10429:     T JavascriptArray::ArrayElementEnumerator::GetItem() const",
          "10430:     {",
          "10431:         Assert(seg && index < seg->length && index < endIndex &&",
          "10432:                !SparseArraySegment<T>::IsMissingItem(&((SparseArraySegment<T>*)seg)->elements[index]));",
          "10433:         return ((SparseArraySegment<T>*)seg)->elements[index];",
          "10434:     }",
          "10439:     JavascriptArray::BigIndex::BigIndex(uint32 initIndex)",
          "10440:         : index(initIndex), bigIndex(InvalidIndex)",
          "10441:     {",
          "10443:     }",
          "10448:     JavascriptArray::BigIndex::BigIndex(uint64 initIndex)",
          "10449:         : index(InvalidIndex), bigIndex(initIndex)",
          "10450:     {",
          "10451:         if (bigIndex < InvalidIndex) // if it's actually small index",
          "10452:         {",
          "10453:             index = static_cast<uint32>(bigIndex);",
          "10454:             bigIndex = InvalidIndex;",
          "10455:         }",
          "10456:     }",
          "10458:     bool JavascriptArray::BigIndex::IsUint32Max() const",
          "10459:     {",
          "10460:         return index == InvalidIndex && bigIndex == InvalidIndex;",
          "10461:     }",
          "10462:     bool JavascriptArray::BigIndex::IsSmallIndex() const",
          "10463:     {",
          "10464:         return index < InvalidIndex;",
          "10465:     }",
          "10467:     uint32 JavascriptArray::BigIndex::GetSmallIndex() const",
          "10468:     {",
          "10469:         Assert(IsSmallIndex());",
          "10470:         return index;",
          "10471:     }",
          "10473:     uint64 JavascriptArray::BigIndex::GetBigIndex() const",
          "10474:     {",
          "10475:         Assert(!IsSmallIndex());",
          "10476:         return bigIndex;",
          "10477:     }",
          "10481:     Var JavascriptArray::BigIndex::ToNumber(ScriptContext* scriptContext) const",
          "10482:     {",
          "10483:         if (IsSmallIndex())",
          "10484:         {",
          "10485:             return small_index::ToNumber(index, scriptContext);",
          "10486:         }",
          "10487:         else",
          "10488:         {",
          "10489:             return JavascriptNumber::ToVar(bigIndex, scriptContext);",
          "10490:         }",
          "10491:     }",
          "10496:     const JavascriptArray::BigIndex& JavascriptArray::BigIndex::operator++()",
          "10497:     {",
          "10498:         if (IsSmallIndex())",
          "10499:         {",
          "10500:             ++index;",
          "10502:         }",
          "10503:         else",
          "10504:         {",
          "10505:             bigIndex = bigIndex + 1;",
          "10506:         }",
          "10508:         return *this;",
          "10509:     }",
          "10514:     const JavascriptArray::BigIndex& JavascriptArray::BigIndex::operator--()",
          "10515:     {",
          "10516:         if (IsSmallIndex())",
          "10517:         {",
          "10518:             --index;",
          "10519:         }",
          "10520:         else",
          "10521:         {",
          "10522:             Assert(index == InvalidIndex && bigIndex >= InvalidIndex);",
          "10524:             --bigIndex;",
          "10525:             if (bigIndex < InvalidIndex)",
          "10526:             {",
          "10527:                 index = InvalidIndex - 1;",
          "10528:                 bigIndex = InvalidIndex;",
          "10529:             }",
          "10530:         }",
          "10532:         return *this;",
          "10533:     }",
          "10535:     JavascriptArray::BigIndex JavascriptArray::BigIndex::operator+(const BigIndex& delta) const",
          "10536:     {",
          "10537:         if (delta.IsSmallIndex())",
          "10538:         {",
          "10539:             return operator+(delta.GetSmallIndex());",
          "10540:         }",
          "10541:         if (IsSmallIndex())",
          "10542:         {",
          "10543:             return index + delta.GetBigIndex();",
          "10544:         }",
          "10546:         return bigIndex + delta.GetBigIndex();",
          "10547:     }",
          "10552:     JavascriptArray::BigIndex JavascriptArray::BigIndex::operator+(uint32 delta) const",
          "10553:     {",
          "10554:         if (IsSmallIndex())",
          "10555:         {",
          "10556:             uint32 newIndex;",
          "10557:             if (UInt32Math::Add(index, delta, &newIndex))",
          "10558:             {",
          "10559:                 return static_cast<uint64>(index) + static_cast<uint64>(delta);",
          "10560:             }",
          "10561:             else",
          "10562:             {",
          "10563:                 return newIndex; // ok if newIndex == InvalidIndex",
          "10564:             }",
          "10565:         }",
          "10566:         else",
          "10567:         {",
          "10568:             return bigIndex + static_cast<uint64>(delta);",
          "10569:         }",
          "10570:     }",
          "10572:     bool JavascriptArray::BigIndex::operator==(const BigIndex& rhs) const",
          "10573:     {",
          "10574:         if (rhs.IsSmallIndex() && this->IsSmallIndex())",
          "10575:         {",
          "10576:             return this->GetSmallIndex() == rhs.GetSmallIndex();",
          "10577:         }",
          "10578:         else if (rhs.IsSmallIndex() && !this->IsSmallIndex())",
          "10579:         {",
          "10581:             return this->GetBigIndex() == (uint64) rhs.GetSmallIndex();",
          "10582:         }",
          "10583:         else if (!rhs.IsSmallIndex() && this->IsSmallIndex())",
          "10584:         {",
          "10586:             return ((uint64)this->GetSmallIndex()) == rhs.GetBigIndex();",
          "10587:         }",
          "10588:         return this->GetBigIndex() == rhs.GetBigIndex();",
          "10589:     }",
          "10591:     bool JavascriptArray::BigIndex::operator> (const BigIndex& rhs) const",
          "10592:     {",
          "10593:         if (rhs.IsSmallIndex() && this->IsSmallIndex())",
          "10594:         {",
          "10595:             return this->GetSmallIndex() > rhs.GetSmallIndex();",
          "10596:         }",
          "10597:         else if (rhs.IsSmallIndex() && !this->IsSmallIndex())",
          "10598:         {",
          "10600:             return this->GetBigIndex() > (uint64)rhs.GetSmallIndex();",
          "10601:         }",
          "10602:         else if (!rhs.IsSmallIndex() && this->IsSmallIndex())",
          "10603:         {",
          "10605:             return ((uint64)this->GetSmallIndex()) > rhs.GetBigIndex();",
          "10606:         }",
          "10607:         return this->GetBigIndex() > rhs.GetBigIndex();",
          "10608:     }",
          "10610:     bool JavascriptArray::BigIndex::operator< (const BigIndex& rhs) const",
          "10611:     {",
          "10612:         if (rhs.IsSmallIndex() && this->IsSmallIndex())",
          "10613:         {",
          "10614:             return this->GetSmallIndex() < rhs.GetSmallIndex();",
          "10615:         }",
          "10616:         else if (rhs.IsSmallIndex() && !this->IsSmallIndex())",
          "10617:         {",
          "10619:             return this->GetBigIndex() < (uint64)rhs.GetSmallIndex();",
          "10620:         }",
          "10621:         else if (!rhs.IsSmallIndex() && this->IsSmallIndex())",
          "10622:         {",
          "10624:             return ((uint64)this->GetSmallIndex()) < rhs.GetBigIndex();",
          "10625:         }",
          "10626:         return this->GetBigIndex() < rhs.GetBigIndex();",
          "10627:     }",
          "10629:     bool JavascriptArray::BigIndex::operator<=(const BigIndex& rhs) const",
          "10630:     {",
          "10631:         if (rhs.IsSmallIndex() && this->IsSmallIndex())",
          "10632:         {",
          "10633:             return this->GetSmallIndex() <= rhs.GetSmallIndex();",
          "10634:         }",
          "10635:         else if (rhs.IsSmallIndex() && !this->IsSmallIndex())",
          "10636:         {",
          "10638:             return this->GetBigIndex() <= (uint64)rhs.GetSmallIndex();",
          "10639:         }",
          "10640:         else if (!rhs.IsSmallIndex() && !this->IsSmallIndex())",
          "10641:         {",
          "10643:             return ((uint64)this->GetSmallIndex()) <= rhs.GetBigIndex();",
          "10644:         }",
          "10645:         return this->GetBigIndex() <= rhs.GetBigIndex();",
          "10646:     }",
          "10648:     bool JavascriptArray::BigIndex::operator>=(const BigIndex& rhs) const",
          "10649:     {",
          "10650:         if (rhs.IsSmallIndex() && this->IsSmallIndex())",
          "10651:         {",
          "10652:             return this->GetSmallIndex() >= rhs.GetSmallIndex();",
          "10653:         }",
          "10654:         else if (rhs.IsSmallIndex() && !this->IsSmallIndex())",
          "10655:         {",
          "10657:             return this->GetBigIndex() >= (uint64)rhs.GetSmallIndex();",
          "10658:         }",
          "10659:         else if (!rhs.IsSmallIndex() && this->IsSmallIndex())",
          "10660:         {",
          "10662:             return ((uint64)this->GetSmallIndex()) >= rhs.GetBigIndex();",
          "10663:         }",
          "10664:         return this->GetBigIndex() >= rhs.GetBigIndex();",
          "10665:     }",
          "10667:     BOOL JavascriptArray::BigIndex::GetItem(JavascriptArray* arr, Var* outVal) const",
          "10668:     {",
          "10669:         if (IsSmallIndex())",
          "10670:         {",
          "10671:             return small_index::GetItem(arr, index, outVal);",
          "10672:         }",
          "10673:         else",
          "10674:         {",
          "10675:             ScriptContext* scriptContext = arr->GetScriptContext();",
          "10676:             PropertyRecord const * propertyRecord;",
          "10677:             JavascriptOperators::GetPropertyIdForInt(bigIndex, scriptContext, &propertyRecord);",
          "10678:             return arr->GetProperty(arr, propertyRecord->GetPropertyId(), outVal, NULL, scriptContext);",
          "10679:         }",
          "10680:     }",
          "10682:     BOOL JavascriptArray::BigIndex::SetItem(JavascriptArray* arr, Var newValue) const",
          "10683:     {",
          "10684:         if (IsSmallIndex())",
          "10685:         {",
          "10686:             return small_index::SetItem(arr, index, newValue);",
          "10687:         }",
          "10688:         else",
          "10689:         {",
          "10690:             ScriptContext* scriptContext = arr->GetScriptContext();",
          "10691:             PropertyRecord const * propertyRecord;",
          "10692:             JavascriptOperators::GetPropertyIdForInt(bigIndex, scriptContext, &propertyRecord);",
          "10693:             return arr->SetProperty(propertyRecord->GetPropertyId(), newValue, PropertyOperation_None, NULL);",
          "10694:         }",
          "10695:     }",
          "10697:     void JavascriptArray::BigIndex::SetItemIfNotExist(JavascriptArray* arr, Var newValue) const",
          "10698:     {",
          "10699:         if (IsSmallIndex())",
          "10700:         {",
          "10701:             small_index::SetItemIfNotExist(arr, index, newValue);",
          "10702:         }",
          "10703:         else",
          "10704:         {",
          "10705:             ScriptContext* scriptContext = arr->GetScriptContext();",
          "10706:             PropertyRecord const * propertyRecord;",
          "10707:             JavascriptOperators::GetPropertyIdForInt(bigIndex, scriptContext, &propertyRecord);",
          "10708:             Var oldValue;",
          "10709:             PropertyId propertyId = propertyRecord->GetPropertyId();",
          "10710:             if (!arr->GetProperty(arr, propertyId, &oldValue, NULL, scriptContext))",
          "10711:             {",
          "10712:                 arr->SetProperty(propertyId, newValue, PropertyOperation_None, NULL);",
          "10713:             }",
          "10714:         }",
          "10715:     }",
          "10717:     BOOL JavascriptArray::BigIndex::DeleteItem(JavascriptArray* arr) const",
          "10718:     {",
          "10719:         if (IsSmallIndex())",
          "10720:         {",
          "10721:             return small_index::DeleteItem(arr, index);",
          "10722:         }",
          "10723:         else",
          "10724:         {",
          "10725:             ScriptContext* scriptContext = arr->GetScriptContext();",
          "10726:             PropertyRecord const * propertyRecord;",
          "10727:             JavascriptOperators::GetPropertyIdForInt(bigIndex, scriptContext, &propertyRecord);",
          "10728:             return arr->DeleteProperty(propertyRecord->GetPropertyId(), PropertyOperation_None);",
          "10729:         }",
          "10730:     }",
          "10732:     BOOL JavascriptArray::BigIndex::SetItem(RecyclableObject* obj, Var newValue, PropertyOperationFlags flags) const",
          "10733:     {",
          "10734:         if (IsSmallIndex())",
          "10735:         {",
          "10736:             return small_index::SetItem(obj, index, newValue, flags);",
          "10737:         }",
          "10738:         else",
          "10739:         {",
          "10740:             ScriptContext* scriptContext = obj->GetScriptContext();",
          "10741:             PropertyRecord const * propertyRecord;",
          "10742:             JavascriptOperators::GetPropertyIdForInt(bigIndex, scriptContext, &propertyRecord);",
          "10743:             return JavascriptOperators::SetProperty(obj, obj, propertyRecord->GetPropertyId(), newValue, scriptContext, flags);",
          "10744:         }",
          "10745:     }",
          "10747:     BOOL JavascriptArray::BigIndex::DeleteItem(RecyclableObject* obj, PropertyOperationFlags flags) const",
          "10748:     {",
          "10749:         if (IsSmallIndex())",
          "10750:         {",
          "10751:             return small_index::DeleteItem(obj, index, flags);",
          "10752:         }",
          "10753:         else",
          "10754:         {",
          "10755:             PropertyRecord const * propertyRecord;",
          "10756:             JavascriptOperators::GetPropertyIdForInt(bigIndex, obj->GetScriptContext(), &propertyRecord);",
          "10757:             return JavascriptOperators::DeleteProperty(obj, propertyRecord->GetPropertyId(), flags);",
          "10758:         }",
          "10759:     }",
          "10764:     void JavascriptArray::TruncateToProperties(const BigIndex& dstIndex, uint32 start)",
          "10765:     {",
          "10766:         Assert(!dstIndex.IsSmallIndex());",
          "10767:         typedef IndexTrace<BigIndex> index_trace;",
          "10769:         BigIndex dst = dstIndex;",
          "10770:         uint32 i = start;",
          "10772:         ArrayElementEnumerator e(this, start);",
          "10773:         while(e.MoveNext<Var>())",
          "10774:         {",
          "10776:             while (i < e.GetIndex())",
          "10777:             {",
          "10778:                 index_trace::DeleteItem(this, dst);",
          "10779:                 ++i;",
          "10780:                 ++dst;",
          "10781:             }",
          "10784:             index_trace::SetItem(this, dst, e.GetItem<Var>());",
          "10785:             ++i;",
          "10786:             ++dst;",
          "10787:         }",
          "10790:         while (i < this->length)",
          "10791:         {",
          "10792:             index_trace::DeleteItem(this, dst);",
          "10793:             ++i;",
          "10794:             ++dst;",
          "10795:         }",
          "10798:         SetLength(start);",
          "10799:     }",
          "10804:     template<typename T>",
          "10805:     void JavascriptArray::InternalCopyArrayElements(JavascriptArray* dstArray, const T& dstIndex, JavascriptArray* srcArray, uint32 start, uint32 end)",
          "10806:     {",
          "10807:         Assert(start < end && end <= srcArray->length);",
          "10809:         uint32 count = 0;",
          "10812:         ArrayElementEnumerator e(srcArray, start, end);",
          "10813:         while(e.MoveNext<Var>())",
          "10814:         {",
          "10815:             T n = dstIndex + (e.GetIndex() - start);",
          "10816:             dstArray->DirectSetItemAt(n, e.GetItem<Var>());",
          "10817:             count++;",
          "10818:         }",
          "10821:         if (start + count != end)",
          "10822:         {",
          "10823:             InternalFillFromPrototype(dstArray, dstIndex, srcArray, start, end, count);",
          "10824:         }",
          "10825:     }",
          "10831:     void JavascriptArray::CopyArrayElements(JavascriptArray* dstArray, const BigIndex& dstIndex, JavascriptArray* srcArray, uint32 start, uint32 end)",
          "10832:     {",
          "10833:         end = min(end, srcArray->length);",
          "10834:         if (start < end)",
          "10835:         {",
          "10836:             uint32 len = end - start;",
          "10837:             if (dstIndex.IsSmallIndex() && (len < MaxArrayLength - dstIndex.GetSmallIndex()))",
          "10838:             {",
          "10840:                 InternalCopyArrayElements(dstArray, dstIndex.GetSmallIndex(), srcArray, start, end);",
          "10841:             }",
          "10842:             else",
          "10843:             {",
          "10844:                 InternalCopyArrayElements(dstArray, dstIndex, srcArray, start, end);",
          "10845:             }",
          "10846:         }",
          "10847:     }",
          "10852:     void JavascriptArray::CopyArrayElements(JavascriptArray* dstArray, uint32 dstIndex, JavascriptArray* srcArray, uint32 start, uint32 end)",
          "10853:     {",
          "10854:         end = min(end, srcArray->length);",
          "10855:         if (start < end)",
          "10856:         {",
          "10857:             Assert(end - start <= MaxArrayLength - dstIndex);",
          "10858:             InternalCopyArrayElements(dstArray, dstIndex, srcArray, start, end);",
          "10859:         }",
          "10860:     }",
          "10862:     template <typename T>",
          "10863:     void JavascriptArray::CopyAnyArrayElementsToVar(JavascriptArray* dstArray, T dstIndex, JavascriptArray* srcArray, uint32 start, uint32 end)",
          "10864:     {",
          "10865: #if ENABLE_COPYONACCESS_ARRAY",
          "10866:         JavascriptLibrary::CheckAndConvertCopyOnAccessNativeIntArray<Var>(srcArray);",
          "10867: #endif",
          "10868: #if ENABLE_COPYONACCESS_ARRAY",
          "10869:         JavascriptLibrary::CheckAndConvertCopyOnAccessNativeIntArray<Var>(dstArray);",
          "10870: #endif",
          "10871:         if (JavascriptNativeIntArray::Is(srcArray))",
          "10872:         {",
          "10873:             CopyNativeIntArrayElementsToVar(dstArray, dstIndex, JavascriptNativeIntArray::FromVar(srcArray), start, end);",
          "10874:         }",
          "10875:         else if (JavascriptNativeFloatArray::Is(srcArray))",
          "10876:         {",
          "10877:             CopyNativeFloatArrayElementsToVar(dstArray, dstIndex, JavascriptNativeFloatArray::FromVar(srcArray), start, end);",
          "10878:         }",
          "10879:         else",
          "10880:         {",
          "10881:             CopyArrayElements(dstArray, dstIndex, srcArray, start, end);",
          "10882:         }",
          "10883:     }",
          "10885:     void JavascriptArray::CopyNativeIntArrayElementsToVar(JavascriptArray* dstArray, const BigIndex& dstIndex, JavascriptNativeIntArray* srcArray, uint32 start, uint32 end)",
          "10886:     {",
          "10887:         end = min(end, srcArray->length);",
          "10888:         if (start < end)",
          "10889:         {",
          "10890:             uint32 len = end - start;",
          "10891:             if (dstIndex.IsSmallIndex() && (len < MaxArrayLength - dstIndex.GetSmallIndex()))",
          "10892:             {",
          "10894:                 InternalCopyNativeIntArrayElements(dstArray, dstIndex.GetSmallIndex(), srcArray, start, end);",
          "10895:             }",
          "10896:             else",
          "10897:             {",
          "10898:                 InternalCopyNativeIntArrayElements(dstArray, dstIndex, srcArray, start, end);",
          "10899:             }",
          "10900:         }",
          "10901:     }",
          "10906:     void JavascriptArray::CopyNativeIntArrayElementsToVar(JavascriptArray* dstArray, uint32 dstIndex, JavascriptNativeIntArray* srcArray, uint32 start, uint32 end)",
          "10907:     {",
          "10908:         end = min(end, srcArray->length);",
          "10909:         if (start < end)",
          "10910:         {",
          "10911:             Assert(end - start <= MaxArrayLength - dstIndex);",
          "10912:             InternalCopyNativeIntArrayElements(dstArray, dstIndex, srcArray, start, end);",
          "10913:         }",
          "10914:     }",
          "10916:     bool JavascriptArray::CopyNativeIntArrayElements(JavascriptNativeIntArray* dstArray, uint32 dstIndex, JavascriptNativeIntArray* srcArray, uint32 start, uint32 end)",
          "10917:     {",
          "10918:         end = min(end, srcArray->length);",
          "10919:         if (start >= end)",
          "10920:         {",
          "10921:             return false;",
          "10922:         }",
          "10924:         Assert(end - start <= MaxArrayLength - dstIndex);",
          "10925:         Assert(start < end && end <= srcArray->length);",
          "10927:         uint32 count = 0;",
          "10930:         ArrayElementEnumerator e(srcArray, start, end);",
          "10931:         while(e.MoveNext<int32>())",
          "10932:         {",
          "10933:             uint n = dstIndex + (e.GetIndex() - start);",
          "10934:             dstArray->DirectSetItemAt(n, e.GetItem<int32>());",
          "10935:             count++;",
          "10936:         }",
          "10939:         if (start + count != end)",
          "10940:         {",
          "10941:             JavascriptArray *varArray = JavascriptNativeIntArray::ToVarArray(dstArray);",
          "10942:             InternalFillFromPrototype(varArray, dstIndex, srcArray, start, end, count);",
          "10943:             return true;",
          "10944:         }",
          "10946:         return false;",
          "10947:     }",
          "10949:     bool JavascriptArray::CopyNativeIntArrayElementsToFloat(JavascriptNativeFloatArray* dstArray, uint32 dstIndex, JavascriptNativeIntArray* srcArray, uint32 start, uint32 end)",
          "10950:     {",
          "10951:         end = min(end, srcArray->length);",
          "10952:         if (start >= end)",
          "10953:         {",
          "10954:             return false;",
          "10955:         }",
          "10957:         Assert(end - start <= MaxArrayLength - dstIndex);",
          "10958:         Assert(start < end && end <= srcArray->length);",
          "10960:         uint32 count = 0;",
          "10963:         ArrayElementEnumerator e(srcArray, start, end);",
          "10964:         while(e.MoveNext<int32>())",
          "10965:         {",
          "10966:             uint n = dstIndex + (e.GetIndex() - start);",
          "10967:             dstArray->DirectSetItemAt(n, (double)e.GetItem<int32>());",
          "10968:             count++;",
          "10969:         }",
          "10972:         if (start + count != end)",
          "10973:         {",
          "10974:             JavascriptArray *varArray = JavascriptNativeFloatArray::ToVarArray(dstArray);",
          "10975:             InternalFillFromPrototype(varArray, dstIndex, srcArray, start, end, count);",
          "10976:             return true;",
          "10977:         }",
          "10979:         return false;",
          "10980:     }",
          "10982:     void JavascriptArray::CopyNativeFloatArrayElementsToVar(JavascriptArray* dstArray, const BigIndex& dstIndex, JavascriptNativeFloatArray* srcArray, uint32 start, uint32 end)",
          "10983:     {",
          "10984:         end = min(end, srcArray->length);",
          "10985:         if (start < end)",
          "10986:         {",
          "10987:             uint32 len = end - start;",
          "10988:             if (dstIndex.IsSmallIndex() && (len < MaxArrayLength - dstIndex.GetSmallIndex()))",
          "10989:             {",
          "10991:                 InternalCopyNativeFloatArrayElements(dstArray, dstIndex.GetSmallIndex(), srcArray, start, end);",
          "10992:             }",
          "10993:             else",
          "10994:             {",
          "10995:                 InternalCopyNativeFloatArrayElements(dstArray, dstIndex, srcArray, start, end);",
          "10996:             }",
          "10997:         }",
          "10998:     }",
          "11003:     void JavascriptArray::CopyNativeFloatArrayElementsToVar(JavascriptArray* dstArray, uint32 dstIndex, JavascriptNativeFloatArray* srcArray, uint32 start, uint32 end)",
          "11004:     {",
          "11005:         end = min(end, srcArray->length);",
          "11006:         if (start < end)",
          "11007:         {",
          "11008:             Assert(end - start <= MaxArrayLength - dstIndex);",
          "11009:             InternalCopyNativeFloatArrayElements(dstArray, dstIndex, srcArray, start, end);",
          "11010:         }",
          "11011:     }",
          "11013:     bool JavascriptArray::CopyNativeFloatArrayElements(JavascriptNativeFloatArray* dstArray, uint32 dstIndex, JavascriptNativeFloatArray* srcArray, uint32 start, uint32 end)",
          "11014:     {",
          "11015:         end = min(end, srcArray->length);",
          "11016:         if (start >= end)",
          "11017:         {",
          "11018:             return false;",
          "11019:         }",
          "11021:         Assert(end - start <= MaxArrayLength - dstIndex);",
          "11022:         Assert(start < end && end <= srcArray->length);",
          "11024:         uint32 count = 0;",
          "11027:         ArrayElementEnumerator e(srcArray, start, end);",
          "11028:         while(e.MoveNext<double>())",
          "11029:         {",
          "11030:             uint n = dstIndex + (e.GetIndex() - start);",
          "11031:             dstArray->DirectSetItemAt(n, e.GetItem<double>());",
          "11032:             count++;",
          "11033:         }",
          "11036:         if (start + count != end)",
          "11037:         {",
          "11038:             JavascriptArray *varArray = JavascriptNativeFloatArray::ToVarArray(dstArray);",
          "11039:             InternalFillFromPrototype(varArray, dstIndex, srcArray, start, end, count);",
          "11040:             return true;",
          "11041:         }",
          "11043:         return false;",
          "11044:     }",
          "11046:     JavascriptArray *JavascriptArray::EnsureNonNativeArray(JavascriptArray *arr)",
          "11047:     {",
          "11048: #if ENABLE_COPYONACCESS_ARRAY",
          "11049:         JavascriptLibrary::CheckAndConvertCopyOnAccessNativeIntArray<Var>(arr);",
          "11050: #endif",
          "11051:         if (JavascriptNativeIntArray::Is(arr))",
          "11052:         {",
          "11053:             arr = JavascriptNativeIntArray::ToVarArray((JavascriptNativeIntArray*)arr);",
          "11054:         }",
          "11055:         else if (JavascriptNativeFloatArray::Is(arr))",
          "11056:         {",
          "11057:             arr = JavascriptNativeFloatArray::ToVarArray((JavascriptNativeFloatArray*)arr);",
          "11058:         }",
          "11060:         return arr;",
          "11061:     }",
          "11063:     BOOL JavascriptNativeIntArray::DirectGetItemAtFull(uint32 index, Var* outVal)",
          "11064:     {",
          "11065:         ScriptContext* requestContext = type->GetScriptContext();",
          "11066:         if (JavascriptNativeIntArray::GetItem(this, index, outVal, requestContext))",
          "11067:         {",
          "11068:             return TRUE;",
          "11069:         }",
          "11071:         return JavascriptOperators::GetItem(this, this->GetPrototype(), index, outVal, requestContext);",
          "11072:     }",
          "11074:     BOOL JavascriptNativeFloatArray::DirectGetItemAtFull(uint32 index, Var* outVal)",
          "11075:     {",
          "11076:         ScriptContext* requestContext = type->GetScriptContext();",
          "11077:         if (JavascriptNativeFloatArray::GetItem(this, index, outVal, requestContext))",
          "11078:         {",
          "11079:             return TRUE;",
          "11080:         }",
          "11082:         return JavascriptOperators::GetItem(this, this->GetPrototype(), index, outVal, requestContext);",
          "11083:     }",
          "11085:     template<typename T>",
          "11086:     void JavascriptArray::InternalCopyNativeIntArrayElements(JavascriptArray* dstArray, const T& dstIndex, JavascriptNativeIntArray* srcArray, uint32 start, uint32 end)",
          "11087:     {",
          "11088:         Assert(start < end && end <= srcArray->length);",
          "11090:         uint32 count = 0;",
          "11093:         ScriptContext *scriptContext = dstArray->GetScriptContext();",
          "11095:         ArrayElementEnumerator e(srcArray, start, end);",
          "11096:         while(e.MoveNext<int32>())",
          "11097:         {",
          "11098:             T n = dstIndex + (e.GetIndex() - start);",
          "11099:             dstArray->DirectSetItemAt(n, JavascriptNumber::ToVar(e.GetItem<int32>(), scriptContext));",
          "11100:             count++;",
          "11101:         }",
          "11104:         if (start + count != end)",
          "11105:         {",
          "11106:             InternalFillFromPrototype(dstArray, dstIndex, srcArray, start, end, count);",
          "11107:         }",
          "11108:     }",
          "11110:     template<typename T>",
          "11111:     void JavascriptArray::InternalCopyNativeFloatArrayElements(JavascriptArray* dstArray, const T& dstIndex, JavascriptNativeFloatArray* srcArray, uint32 start, uint32 end)",
          "11112:     {",
          "11113:         Assert(start < end && end <= srcArray->length);",
          "11115:         uint32 count = 0;",
          "11118:         ScriptContext *scriptContext = dstArray->GetScriptContext();",
          "11119:         ArrayElementEnumerator e(srcArray, start, end);",
          "11120:         while(e.MoveNext<double>())",
          "11121:         {",
          "11122:             T n = dstIndex + (e.GetIndex() - start);",
          "11123:             dstArray->DirectSetItemAt(n, JavascriptNumber::ToVarWithCheck(e.GetItem<double>(), scriptContext));",
          "11124:             count++;",
          "11125:         }",
          "11128:         if (start + count != end)",
          "11129:         {",
          "11130:             InternalFillFromPrototype(dstArray, dstIndex, srcArray, start, end, count);",
          "11131:         }",
          "11132:     }",
          "11134:     Var JavascriptArray::SpreadArrayArgs(Var arrayToSpread, const Js::AuxArray<uint32> *spreadIndices, ScriptContext *scriptContext)",
          "11135:     {",
          "11136:         JS_REENTRANCY_LOCK(jsReentLock, scriptContext->GetThreadContext());",
          "11140: #if ENABLE_COPYONACCESS_ARRAY",
          "11141:         JavascriptLibrary::CheckAndConvertCopyOnAccessNativeIntArray<Var>(arrayToSpread);",
          "11142: #endif",
          "11143:         JavascriptArray *array = FromVar(arrayToSpread);",
          "11144:         uint32 arrayLength = array->GetLength();",
          "11145:         uint32 actualLength = arrayLength;",
          "11147:         for (unsigned i = 0; i < spreadIndices->count; ++i)",
          "11148:         {",
          "11149:             JS_REENTRANT(jsReentLock,",
          "11150:                 actualLength = UInt32Math::Add(actualLength - 1, GetSpreadArgLen(array->DirectGetItem(spreadIndices->elements[i]), scriptContext)));",
          "11151:         }",
          "11153:         JavascriptArray *result = FromVar(OP_NewScArrayWithMissingValues(actualLength, scriptContext));",
          "11156:         for (unsigned i = 0, spreadArrIndex = 0, resultIndex = 0; i < arrayLength && resultIndex < actualLength; ++i)",
          "11157:         {",
          "11158:             uint32 spreadIndex = spreadIndices->elements[spreadArrIndex]; // The index of the next element to be spread.",
          "11161:             auto needArraySlowCopy = [&](Var instance) {",
          "11162:                 if (JavascriptArray::Is(instance))",
          "11163:                 {",
          "11164:                     JavascriptArray *arr = JavascriptArray::FromVar(instance);",
          "11165:                     JS_REENTRANT_UNLOCK(jsReentLock, return arr->IsCrossSiteObject() || arr->IsFillFromPrototypes());",
          "11166:                 }",
          "11167:                 return false;",
          "11168:             };",
          "11171:             auto slowCopy = [&scriptContext, &needArraySlowCopy",
          "11172:                 ](JavascriptArray *dstArray, unsigned dstIndex, Var srcArray, uint32 start, uint32 end) {",
          "11173:                 Assert(needArraySlowCopy(srcArray) || ArgumentsObject::Is(srcArray) || TypedArrayBase::Is(srcArray) || JavascriptString::Is(srcArray));",
          "11174:                 JS_REENTRANCY_LOCK(jsReentLock, scriptContext->GetThreadContext());",
          "11176:                 RecyclableObject *propertyObject;",
          "11177:                 if (!JavascriptOperators::GetPropertyObject(srcArray, scriptContext, &propertyObject))",
          "11178:                 {",
          "11179:                     JavascriptError::ThrowTypeError(scriptContext, JSERR_InvalidSpreadArgument);",
          "11180:                 }",
          "11182:                 for (uint32 j = start; j < end; j++)",
          "11183:                 {",
          "11184:                     Var element;",
          "11185:                     JS_REENTRANT(jsReentLock, BOOL gotItem = JavascriptOperators::GetItem(srcArray, propertyObject, j, &element, scriptContext));",
          "11186:                     if (!gotItem)",
          "11187:                     {",
          "11189:                         element = scriptContext->GetLibrary()->GetUndefined();",
          "11190:                     }",
          "11191:                     dstArray->DirectSetItemAt(dstIndex++, element);",
          "11192:                 }",
          "11193:             };",
          "11195:             if (i < spreadIndex)",
          "11196:             {",
          "11199:                 if (needArraySlowCopy(array))",
          "11200:                 {",
          "11201:                     slowCopy(result, resultIndex, (Var)array, i, spreadIndex);",
          "11202:                 }",
          "11203:                 else",
          "11204:                 {",
          "11205:                     JS_REENTRANT(jsReentLock, CopyAnyArrayElementsToVar(result, resultIndex, array, i, spreadIndex));",
          "11206:                 }",
          "11207:                 resultIndex += spreadIndex - i;",
          "11208:                 i = spreadIndex - 1;",
          "11209:                 continue;",
          "11210:             }",
          "11211:             else if (i > spreadIndex)",
          "11212:             {",
          "11214:                 Assert(spreadArrIndex == spreadIndices->count - 1);",
          "11215:                 if (needArraySlowCopy(array))",
          "11216:                 {",
          "11217:                     slowCopy(result, resultIndex, array, i, arrayLength);",
          "11218:                 }",
          "11219:                 else",
          "11220:                 {",
          "11221:                     JS_REENTRANT(jsReentLock, CopyAnyArrayElementsToVar(result, resultIndex, array, i, arrayLength));",
          "11222:                 }",
          "11223:                 break;",
          "11224:             }",
          "11225:             else",
          "11226:             {",
          "11227:                 JS_REENTRANT(jsReentLock, Var instance = array->DirectGetItem(i));",
          "11229:                 if (SpreadArgument::Is(instance))",
          "11230:                 {",
          "11231:                     SpreadArgument* spreadArgument = SpreadArgument::FromVar(instance);",
          "11232:                     uint32 len = spreadArgument->GetArgumentSpreadCount();",
          "11233:                     const Var*  spreadItems = spreadArgument->GetArgumentSpread();",
          "11234:                     for (uint32 j = 0; j < len; j++)",
          "11235:                     {",
          "11236:                         result->DirectSetItemAt(resultIndex++, spreadItems[j]);",
          "11237:                     }",
          "11239:                 }",
          "11240:                 else",
          "11241:                 {",
          "11242:                     Assert(JavascriptOperators::IsUndefinedObject(instance));",
          "11243:                     result->DirectSetItemAt(resultIndex++, instance);",
          "11244:                 }",
          "11246:                 if (spreadArrIndex < spreadIndices->count - 1)",
          "11247:                 {",
          "11248:                     spreadArrIndex++;",
          "11249:                 }",
          "11250:             }",
          "11251:         }",
          "11252:         AssertMsg(arrayLength == array->GetLength(), \"Array's length should not have changed\");",
          "11253:         return result;",
          "11254:     }",
          "11256:     uint32 JavascriptArray::GetSpreadArgLen(Var spreadArg, ScriptContext *scriptContext)",
          "11257:     {",
          "11260:         spreadArg = CrossSite::MarshalVar(scriptContext, spreadArg);",
          "11261:         if (JavascriptArray::Is(spreadArg))",
          "11262:         {",
          "11263:             JavascriptArray *arr = JavascriptArray::FromVar(spreadArg);",
          "11264:             return arr->GetLength();",
          "11265:         }",
          "11267:         if (TypedArrayBase::Is(spreadArg))",
          "11268:         {",
          "11269:             TypedArrayBase *tarr = TypedArrayBase::FromVar(spreadArg);",
          "11270:             return tarr->GetLength();",
          "11271:         }",
          "11273:         if (SpreadArgument::Is(spreadArg))",
          "11274:         {",
          "11275:             SpreadArgument *spreadFunctionArgs = SpreadArgument::FromVar(spreadArg);",
          "11276:             return spreadFunctionArgs->GetArgumentSpreadCount();",
          "11277:         }",
          "11279:         AssertMsg(false, \"LdCustomSpreadIteratorList should have converted the arg to one of the above types\");",
          "11280:         Throw::FatalInternalError();",
          "11281:     }",
          "11283: #ifdef VALIDATE_ARRAY",
          "11284:     class ArraySegmentsVisitor",
          "11285:     {",
          "11286:     private:",
          "11287:         SparseArraySegmentBase* seg;",
          "11289:     public:",
          "11290:         ArraySegmentsVisitor(SparseArraySegmentBase* head)",
          "11291:             : seg(head)",
          "11292:         {",
          "11293:         }",
          "11295:         void operator()(SparseArraySegmentBase* s)",
          "11296:         {",
          "11297:             Assert(seg == s);",
          "11298:             if (seg)",
          "11299:             {",
          "11300:                 seg = seg->next;",
          "11301:             }",
          "11302:         }",
          "11303:     };",
          "11305:     void JavascriptArray::ValidateArrayCommon()",
          "11306:     {",
          "11307:         SparseArraySegmentBase * lastUsedSegment = this->GetLastUsedSegment();",
          "11308:         AssertMsg(this != nullptr && head && lastUsedSegment, \"Array should not be null\");",
          "11309:         AssertMsg(head->left == 0, \"Array always should have a segment starting at zero\");",
          "11312:         bool foundLastUsedSegment = false;",
          "11313:         SparseArraySegmentBase *seg = head;",
          "11314:         while(seg != nullptr)",
          "11315:         {",
          "11316:             if (seg == lastUsedSegment)",
          "11317:             {",
          "11318:                 foundLastUsedSegment = true;",
          "11319:             }",
          "11321:             AssertMsg(seg->length <= seg->size , \"Length greater than size not possible\");",
          "11323:             SparseArraySegmentBase* next = seg->next;",
          "11324:             if (next != nullptr)",
          "11325:             {",
          "11326:                 AssertMsg(seg->left < next->left, \"Segment is adjacent to or overlaps with next segment\");",
          "11327:                 AssertMsg(seg->size <= (next->left - seg->left), \"Segment is adjacent to or overlaps with next segment\");",
          "11328:                 AssertMsg(!SparseArraySegmentBase::IsLeafSegment(seg, this->GetScriptContext()->GetRecycler()), \"Leaf segment with a next pointer\");",
          "11329:             }",
          "11330:             else",
          "11331:             {",
          "11332:                 AssertMsg(seg->length <= MaxArrayLength - seg->left, \"Segment index range overflow\");",
          "11333:                 AssertMsg(seg->left + seg->length <= this->length, \"Segment index range exceeds array length\");",
          "11334:             }",
          "11336:             seg = next;",
          "11337:         }",
          "11338:         AssertMsg(foundLastUsedSegment || HasSegmentMap(), \"Corrupt lastUsedSegment in array header\");",
          "11341:         if (HasSegmentMap())",
          "11342:         {",
          "11343:             ArraySegmentsVisitor visitor(head);",
          "11344:             GetSegmentMap()->Walk(visitor);",
          "11345:         }",
          "11346:     }",
          "11348:     void JavascriptArray::ValidateArray()",
          "11349:     {",
          "11350:         if (!Js::Configuration::Global.flags.ArrayValidate)",
          "11351:         {",
          "11352:             return;",
          "11353:         }",
          "11354:         ValidateArrayCommon();",
          "11356:         JavascriptArray::ValidateVarSegment(SparseArraySegment<Var>::From(head));",
          "11357:     }",
          "11359:     void JavascriptNativeIntArray::ValidateArray()",
          "11360:     {",
          "11361:         if (!Js::Configuration::Global.flags.ArrayValidate)",
          "11362:         {",
          "11363: #if DBG",
          "11364:             SparseArraySegmentBase *seg = head;",
          "11365:             while (seg)",
          "11366:             {",
          "11367:                 if (seg->next != nullptr)",
          "11368:                 {",
          "11369:                     AssertMsg(!SparseArraySegmentBase::IsLeafSegment(seg, this->GetScriptContext()->GetRecycler()), \"Leaf segment with a next pointer\");",
          "11370:                 }",
          "11371:                 seg = seg->next;",
          "11372:             }",
          "11373: #endif",
          "11374:             return;",
          "11375:         }",
          "11376:         ValidateArrayCommon();",
          "11378:         JavascriptArray::ValidateSegment<int32>(SparseArraySegment<int32>::From(head));",
          "11379:     }",
          "11381:     void JavascriptNativeFloatArray::ValidateArray()",
          "11382:     {",
          "11383:         if (!Js::Configuration::Global.flags.ArrayValidate)",
          "11384:         {",
          "11385: #if DBG",
          "11386:             SparseArraySegmentBase *seg = head;",
          "11387:             while (seg)",
          "11388:             {",
          "11389:                 if (seg->next != nullptr)",
          "11390:                 {",
          "11391:                     AssertMsg(!SparseArraySegmentBase::IsLeafSegment(seg, this->GetScriptContext()->GetRecycler()), \"Leaf segment with a next pointer\");",
          "11392:                 }",
          "11393:                 seg = seg->next;",
          "11394:             }",
          "11395: #endif",
          "11396:             return;",
          "11397:         }",
          "11398:         ValidateArrayCommon();",
          "11400:         JavascriptArray::ValidateSegment<double>(SparseArraySegment<double>::From(head));",
          "11401:     }",
          "11404:     void JavascriptArray::ValidateVarSegment(SparseArraySegment<Var>* seg)",
          "11405:     {",
          "11406:         if (!Js::Configuration::Global.flags.ArrayValidate)",
          "11407:         {",
          "11408:             return;",
          "11409:         }",
          "11410:         int32 inspect;",
          "11411:         double inspectDouble;",
          "11412:         while (seg)",
          "11413:         {",
          "11414:             uint32 i = 0;",
          "11415:             for (i = 0; i < seg->length; i++)",
          "11416:             {",
          "11417:                 if (SparseArraySegment<Var>::IsMissingItem(&seg->elements[i]))",
          "11418:                 {",
          "11419:                     continue;",
          "11420:                 }",
          "11421:                 if (TaggedInt::Is(seg->elements[i]))",
          "11422:                 {",
          "11423:                     inspect = TaggedInt::ToInt32(seg->elements[i]);",
          "11425:                 }",
          "11426:                 else if (JavascriptNumber::Is_NoTaggedIntCheck(seg->elements[i]))",
          "11427:                 {",
          "11428:                     inspectDouble = JavascriptNumber::GetValue(seg->elements[i]);",
          "11429:                 }",
          "11430:                 else",
          "11431:                 {",
          "11432:                     AssertMsg(RecyclableObject::Is(seg->elements[i]), \"Invalid entry in segment\");",
          "11433:                 }",
          "11434:             }",
          "11435:             ValidateSegment(seg);",
          "11437:             seg = SparseArraySegment<Var>::From(seg->next);",
          "11438:         }",
          "11439:     }",
          "11441:     template<typename T>",
          "11442:     void JavascriptArray::ValidateSegment(SparseArraySegment<T>* seg)",
          "11443:     {",
          "11444:         if (!Js::Configuration::Global.flags.ArrayValidate)",
          "11445:         {",
          "11446:             return;",
          "11447:         }",
          "11449:         while (seg)",
          "11450:         {",
          "11451:             uint32 i = seg->length;",
          "11452:             while (i < seg->size)",
          "11453:             {",
          "11454:                 AssertMsg(SparseArraySegment<T>::IsMissingItem(&seg->elements[i]), \"Non missing value the end of the segment\");",
          "11455:                 i++;",
          "11456:             }",
          "11458:             seg = SparseArraySegment<T>::From(seg->next);",
          "11459:         }",
          "11460:     }",
          "11461: #endif",
          "11463:     template <typename T>",
          "11464:     void JavascriptArray::InitBoxedInlineHeadSegment(SparseArraySegment<T> * dst, SparseArraySegment<T> * src)",
          "11465:     {",
          "11467:         SetFlags(GetFlags() & ~DynamicObjectFlags::HasSegmentMap);",
          "11469:         SetHeadAndLastUsedSegment(dst);",
          "11471:         dst->left = src->left;",
          "11472:         dst->length = src->length;",
          "11473:         dst->size = src->size;",
          "11474:         dst->next = src->next;",
          "11476:         CopyArray(dst->elements, dst->size, src->elements, src->size);",
          "11477:     }",
          "11479:     JavascriptArray::JavascriptArray(JavascriptArray * instance, bool boxHead)",
          "11480:         : ArrayObject(instance)",
          "11481:     {",
          "11482:         if (boxHead)",
          "11483:         {",
          "11484:             InitBoxedInlineHeadSegment(DetermineInlineHeadSegmentPointer<JavascriptArray, 0, true>(this), SparseArraySegment<Var>::From(instance->head));",
          "11485:         }",
          "11486:         else",
          "11487:         {",
          "11489:             SetFlags(GetFlags() & ~DynamicObjectFlags::HasSegmentMap);",
          "11490:             head = instance->head;",
          "11491:             SetLastUsedSegment(instance->GetLastUsedSegment());",
          "11492:         }",
          "11493:     }",
          "11495:     template <typename T>",
          "11496:     T * JavascriptArray::BoxStackInstance(T * instance)",
          "11497:     {",
          "11498:         Assert(ThreadContext::IsOnStack(instance));",
          "11500:         T ** boxedInstanceRef = ((T **)instance) - 1;",
          "11501:         T * boxedInstance = *boxedInstanceRef;",
          "11502:         if (boxedInstance)",
          "11503:         {",
          "11504:             return boxedInstance;",
          "11505:         }",
          "11507:         const size_t inlineSlotsSize = instance->GetTypeHandler()->GetInlineSlotsSize();",
          "11508:         if (ThreadContext::IsOnStack(instance->head))",
          "11509:         {",
          "11510:             boxedInstance = RecyclerNewPlusZ(instance->GetRecycler(),",
          "11511:                 inlineSlotsSize + sizeof(Js::SparseArraySegmentBase) + instance->head->size * sizeof(typename T::TElement),",
          "11512:                 T, instance, true);",
          "11513:         }",
          "11514:         else if(inlineSlotsSize)",
          "11515:         {",
          "11516:             boxedInstance = RecyclerNewPlusZ(instance->GetRecycler(), inlineSlotsSize, T, instance, false);",
          "11517:         }",
          "11518:         else",
          "11519:         {",
          "11520:             boxedInstance = RecyclerNew(instance->GetRecycler(), T, instance, false);",
          "11521:         }",
          "11524:         return boxedInstance;",
          "11525:     }",
          "11527:     JavascriptArray *",
          "11528:     JavascriptArray::BoxStackInstance(JavascriptArray * instance)",
          "11529:     {",
          "11530:         return BoxStackInstance<JavascriptArray>(instance);",
          "11531:     }",
          "11533: #if ENABLE_TTD",
          "11534:     void JavascriptArray::MarkVisitKindSpecificPtrs(TTD::SnapshotExtractor* extractor)",
          "11535:     {",
          "11536:         TTDAssert(this->GetTypeId() == Js::TypeIds_Array || this->GetTypeId() == Js::TypeIds_ES5Array, \"Should only be used on basic arrays (or called as super from ES5Array.\");",
          "11538:         ScriptContext* ctx = this->GetScriptContext();",
          "11540:         uint32 index = Js::JavascriptArray::InvalidIndex;",
          "11541:         while(true)",
          "11542:         {",
          "11543:             index = this->GetNextIndex(index);",
          "11544:             if(index == Js::JavascriptArray::InvalidIndex) // End of array",
          "11545:             {",
          "11546:                 break;",
          "11547:             }",
          "11549:             Js::Var aval = nullptr;",
          "11550:             if(this->DirectGetVarItemAt(index, &aval, ctx))",
          "11551:             {",
          "11552:                 extractor->MarkVisitVar(aval);",
          "11553:             }",
          "11554:         }",
          "11555:     }",
          "11557:     void JavascriptArray::ProcessCorePaths()",
          "11558:     {",
          "11559:         TTDAssert(this->GetTypeId() == Js::TypeIds_Array, \"Should only be used on basic arrays.\");",
          "11561:         ScriptContext* ctx = this->GetScriptContext();",
          "11563:         uint32 index = Js::JavascriptArray::InvalidIndex;",
          "11564:         while(true)",
          "11565:         {",
          "11566:             index = this->GetNextIndex(index);",
          "11567:             if(index == Js::JavascriptArray::InvalidIndex) // End of array",
          "11568:             {",
          "11569:                 break;",
          "11570:             }",
          "11572:             Js::Var aval = nullptr;",
          "11573:             if(this->DirectGetVarItemAt(index, &aval, ctx))",
          "11574:             {",
          "11575:                 TTD::UtilSupport::TTAutoString pathExt;",
          "11576:                 ctx->TTDWellKnownInfo->BuildArrayIndexBuffer(index, pathExt);",
          "11578:                 ctx->TTDWellKnownInfo->EnqueueNewPathVarAsNeeded(this, aval, pathExt.GetStrValue());",
          "11579:             }",
          "11580:         }",
          "11581:     }",
          "11583:     TTD::NSSnapObjects::SnapObjectType JavascriptArray::GetSnapTag_TTD() const",
          "11584:     {",
          "11585:         return TTD::NSSnapObjects::SnapObjectType::SnapArrayObject;",
          "11586:     }",
          "11588:     void JavascriptArray::ExtractSnapObjectDataInto(TTD::NSSnapObjects::SnapObject* objData, TTD::SlabAllocator& alloc)",
          "11589:     {",
          "11590:         TTDAssert(this->GetTypeId() == Js::TypeIds_Array, \"Should only be used on basic Js arrays.\");",
          "11592:         TTD::NSSnapObjects::SnapArrayInfo<TTD::TTDVar>* sai = TTD::NSSnapObjects::ExtractArrayValues<TTD::TTDVar>(this, alloc);",
          "11593:         TTD::NSSnapObjects::StdExtractSetKindSpecificInfo<TTD::NSSnapObjects::SnapArrayInfo<TTD::TTDVar>*, TTD::NSSnapObjects::SnapObjectType::SnapArrayObject>(objData, sai);",
          "11594:     }",
          "11595: #endif",
          "11597:     JavascriptNativeArray::JavascriptNativeArray(JavascriptNativeArray * instance) :",
          "11598:         JavascriptArray(instance, false),",
          "11599:         weakRefToFuncBody(instance->weakRefToFuncBody)",
          "11600:     {",
          "11601:     }",
          "11603:     JavascriptNativeIntArray::JavascriptNativeIntArray(JavascriptNativeIntArray * instance, bool boxHead) :",
          "11604:         JavascriptNativeArray(instance)",
          "11605:     {",
          "11606:         if (boxHead)",
          "11607:         {",
          "11608:             InitBoxedInlineHeadSegment(DetermineInlineHeadSegmentPointer<JavascriptNativeIntArray, 0, true>(this), SparseArraySegment<int>::From(instance->head));",
          "11609:         }",
          "11610:         else",
          "11611:         {",
          "11613:             Assert(head == instance->head);",
          "11614:             Assert(segmentUnion.lastUsedSegment == instance->GetLastUsedSegment());",
          "11615:         }",
          "11616:     }",
          "11618:     JavascriptNativeIntArray *",
          "11619:     JavascriptNativeIntArray::BoxStackInstance(JavascriptNativeIntArray * instance)",
          "11620:     {",
          "11621:         return JavascriptArray::BoxStackInstance<JavascriptNativeIntArray>(instance);",
          "11622:     }",
          "11624: #if ENABLE_TTD",
          "11625:     TTD::NSSnapObjects::SnapObjectType JavascriptNativeIntArray::GetSnapTag_TTD() const",
          "11626:     {",
          "11627:         return TTD::NSSnapObjects::SnapObjectType::SnapNativeIntArrayObject;",
          "11628:     }",
          "11630:     void JavascriptNativeIntArray::ExtractSnapObjectDataInto(TTD::NSSnapObjects::SnapObject* objData, TTD::SlabAllocator& alloc)",
          "11631:     {",
          "11632:         TTD::NSSnapObjects::SnapArrayInfo<int32>* sai = TTD::NSSnapObjects::ExtractArrayValues<int32>(this, alloc);",
          "11633:         TTD::NSSnapObjects::StdExtractSetKindSpecificInfo<TTD::NSSnapObjects::SnapArrayInfo<int32>*, TTD::NSSnapObjects::SnapObjectType::SnapNativeIntArrayObject>(objData, sai);",
          "11634:     }",
          "11636: #if ENABLE_COPYONACCESS_ARRAY",
          "11637:     TTD::NSSnapObjects::SnapObjectType JavascriptCopyOnAccessNativeIntArray::GetSnapTag_TTD() const",
          "11638:     {",
          "11639:         return TTD::NSSnapObjects::SnapObjectType::Invalid;",
          "11640:     }",
          "11642:     void JavascriptCopyOnAccessNativeIntArray::ExtractSnapObjectDataInto(TTD::NSSnapObjects::SnapObject* objData, TTD::SlabAllocator& alloc)",
          "11643:     {",
          "11644:         TTDAssert(false, \"Not implemented yet!!!\");",
          "11645:     }",
          "11646: #endif",
          "11647: #endif",
          "11649:     JavascriptNativeFloatArray::JavascriptNativeFloatArray(JavascriptNativeFloatArray * instance, bool boxHead) :",
          "11650:         JavascriptNativeArray(instance)",
          "11651:     {",
          "11652:         if (boxHead)",
          "11653:         {",
          "11654:             InitBoxedInlineHeadSegment(DetermineInlineHeadSegmentPointer<JavascriptNativeFloatArray, 0, true>(this), SparseArraySegment<double>::From(instance->head));",
          "11655:         }",
          "11656:         else",
          "11657:         {",
          "11659:             Assert(head == instance->head);",
          "11660:             Assert(segmentUnion.lastUsedSegment == instance->GetLastUsedSegment());",
          "11661:         }",
          "11662:     }",
          "11664:     JavascriptNativeFloatArray *",
          "11665:     JavascriptNativeFloatArray::BoxStackInstance(JavascriptNativeFloatArray * instance)",
          "11666:     {",
          "11667:         return JavascriptArray::BoxStackInstance<JavascriptNativeFloatArray>(instance);",
          "11668:     }",
          "11670: #if ENABLE_TTD",
          "11671:     TTD::NSSnapObjects::SnapObjectType JavascriptNativeFloatArray::GetSnapTag_TTD() const",
          "11672:     {",
          "11673:         return TTD::NSSnapObjects::SnapObjectType::SnapNativeFloatArrayObject;",
          "11674:     }",
          "11676:     void JavascriptNativeFloatArray::ExtractSnapObjectDataInto(TTD::NSSnapObjects::SnapObject* objData, TTD::SlabAllocator& alloc)",
          "11677:     {",
          "11678:         TTDAssert(this->GetTypeId() == Js::TypeIds_NativeFloatArray, \"Should only be used on native float arrays.\");",
          "11680:         TTD::NSSnapObjects::SnapArrayInfo<double>* sai = TTD::NSSnapObjects::ExtractArrayValues<double>(this, alloc);",
          "11681:         TTD::NSSnapObjects::StdExtractSetKindSpecificInfo<TTD::NSSnapObjects::SnapArrayInfo<double>*, TTD::NSSnapObjects::SnapObjectType::SnapNativeFloatArrayObject>(objData, sai);",
          "11682:     }",
          "11683: #endif",
          "11685:     template<typename T>",
          "11686:     RecyclableObject*",
          "11687:     JavascriptArray::ArraySpeciesCreate(Var originalArray, T length, ScriptContext* scriptContext, bool *pIsIntArray, bool *pIsFloatArray, bool *pIsBuiltinArrayCtor)",
          "11688:     {",
          "11689:         if (originalArray == nullptr || !scriptContext->GetConfig()->IsES6SpeciesEnabled())",
          "11690:         {",
          "11691:             return nullptr;",
          "11692:         }",
          "11694:         if (JavascriptArray::Is(originalArray)",
          "11695:             && !DynamicObject::FromVar(originalArray)->GetDynamicType()->GetTypeHandler()->GetIsNotPathTypeHandlerOrHasUserDefinedCtor()",
          "11696:             && DynamicObject::FromVar(originalArray)->GetPrototype() == scriptContext->GetLibrary()->GetArrayPrototype()",
          "11697:             && !scriptContext->GetLibrary()->GetArrayObjectHasUserDefinedSpecies())",
          "11698:         {",
          "11699:             return nullptr;",
          "11700:         }",
          "11702:         Var constructor = scriptContext->GetLibrary()->GetUndefined();",
          "11704:         if (JavascriptOperators::IsArray(originalArray))",
          "11705:         {",
          "11706:             if (!JavascriptOperators::GetProperty(RecyclableObject::FromVar(originalArray), PropertyIds::constructor, &constructor, scriptContext))",
          "11707:             {",
          "11708:                 return nullptr;",
          "11709:             }",
          "11711:             if (JavascriptOperators::IsConstructor(constructor))",
          "11712:             {",
          "11713:                 ScriptContext* constructorScriptContext = RecyclableObject::FromVar(constructor)->GetScriptContext();",
          "11714:                 if (constructorScriptContext != scriptContext)",
          "11715:                 {",
          "11716:                     if (constructorScriptContext->GetLibrary()->GetArrayConstructor() == constructor)",
          "11717:                     {",
          "11718:                         constructor = scriptContext->GetLibrary()->GetUndefined();",
          "11719:                     }",
          "11720:                 }",
          "11721:             }",
          "11723:             if (JavascriptOperators::IsObject(constructor))",
          "11724:             {",
          "11725:                 if (!JavascriptOperators::GetProperty((RecyclableObject*)constructor, PropertyIds::_symbolSpecies, &constructor, scriptContext))",
          "11726:                 {",
          "11727:                     if (pIsBuiltinArrayCtor != nullptr)",
          "11728:                     {",
          "11730:                     }",
          "11731:                     return nullptr;",
          "11732:                 }",
          "11733:                 if (constructor == scriptContext->GetLibrary()->GetNull())",
          "11734:                 {",
          "11735:                     constructor = scriptContext->GetLibrary()->GetUndefined();",
          "11736:                 }",
          "11737:             }",
          "11738:         }",
          "11740:         if (constructor == scriptContext->GetLibrary()->GetUndefined() || constructor == scriptContext->GetLibrary()->GetArrayConstructor())",
          "11741:         {",
          "11742:             if (length > UINT_MAX)",
          "11743:             {",
          "11744:                 JavascriptError::ThrowRangeError(scriptContext, JSERR_ArrayLengthConstructIncorrect);",
          "11745:             }",
          "11747:             if (nullptr == pIsIntArray)",
          "11748:             {",
          "11749:                 return scriptContext->GetLibrary()->CreateArray(static_cast<uint32>(length));",
          "11750:             }",
          "11751:             else",
          "11752:             {",
          "11754:                 JavascriptArray* pArr = JavascriptArray::FromVar(originalArray);",
          "11755:                 pArr->GetArrayTypeAndConvert(pIsIntArray, pIsFloatArray);",
          "11756:                 return CreateNewArrayHelper(static_cast<uint32>(length), *pIsIntArray, *pIsFloatArray, pArr, scriptContext);",
          "11757:             }",
          "11758:         }",
          "11760:         if (!JavascriptOperators::IsConstructor(constructor))",
          "11761:         {",
          "11762:             JavascriptError::ThrowTypeError(scriptContext, JSERR_NotAConstructor, _u(\"constructor[Symbol.species]\"));",
          "11763:         }",
          "11765:         if (pIsBuiltinArrayCtor != nullptr)",
          "11766:         {",
          "11768:         }",
          "11770:         Js::Var constructorArgs[] = { constructor, JavascriptNumber::ToVar(length, scriptContext) };",
          "11771:         Js::CallInfo constructorCallInfo(Js::CallFlags_New, _countof(constructorArgs));",
          "11773:         return RecyclableObject::FromVar(JavascriptOperators::NewScObject(constructor, Js::Arguments(constructorCallInfo, constructorArgs), scriptContext));",
          "11774:     }",
          "11776:     PropertyId const JavascriptArray::specialPropertyIds[] =",
          "11777:     {",
          "11778:         PropertyIds::length",
          "11779:     };",
          "11781:     BOOL JavascriptArray::DeleteProperty(PropertyId propertyId, PropertyOperationFlags flags)",
          "11782:     {",
          "11783:         if (propertyId == PropertyIds::length)",
          "11784:         {",
          "11785:             return false;",
          "11786:         }",
          "11787:         return DynamicObject::DeleteProperty(propertyId, flags);",
          "11788:     }",
          "11790:     BOOL JavascriptArray::DeleteProperty(JavascriptString *propertyNameString, PropertyOperationFlags flags)",
          "11791:     {",
          "11792:         JsUtil::CharacterBuffer<WCHAR> propertyName(propertyNameString->GetString(), propertyNameString->GetLength());",
          "11793:         if (BuiltInPropertyRecords::length.Equals(propertyName))",
          "11794:         {",
          "11795:             return false;",
          "11796:         }",
          "11797:         return DynamicObject::DeleteProperty(propertyNameString, flags);",
          "11798:     }",
          "11800:     BOOL JavascriptArray::HasProperty(PropertyId propertyId)",
          "11801:     {",
          "11802:         if (propertyId == PropertyIds::length)",
          "11803:         {",
          "11804:             return true;",
          "11805:         }",
          "11807:         ScriptContext* scriptContext = GetScriptContext();",
          "11808:         uint32 index;",
          "11809:         if (scriptContext->IsNumericPropertyId(propertyId, &index))",
          "11810:         {",
          "11811:             return this->HasItem(index);",
          "11812:         }",
          "11814:         return DynamicObject::HasProperty(propertyId);",
          "11815:     }",
          "11817:     BOOL JavascriptArray::IsEnumerable(PropertyId propertyId)",
          "11818:     {",
          "11819:         if (propertyId == PropertyIds::length)",
          "11820:         {",
          "11821:             return false;",
          "11822:         }",
          "11823:         return DynamicObject::IsEnumerable(propertyId);",
          "11824:     }",
          "11826:     BOOL JavascriptArray::IsConfigurable(PropertyId propertyId)",
          "11827:     {",
          "11828:         if (propertyId == PropertyIds::length)",
          "11829:         {",
          "11830:             return false;",
          "11831:         }",
          "11832:         return DynamicObject::IsConfigurable(propertyId);",
          "11833:     }",
          "11839:     BOOL JavascriptArray::SetEnumerable(PropertyId propertyId, BOOL value)",
          "11840:     {",
          "11841:         if (propertyId == PropertyIds::length)",
          "11842:         {",
          "11843:             Assert(!value); // Can't change array length enumerable",
          "11844:             return true;",
          "11845:         }",
          "11847:         ScriptContext* scriptContext = this->GetScriptContext();",
          "11849:         uint32 index;",
          "11850:         if (scriptContext->IsNumericPropertyId(propertyId, &index))",
          "11851:         {",
          "11852:             return GetTypeHandler()->ConvertToTypeWithItemAttributes(this)",
          "11853:                 ->SetEnumerable(this, propertyId, value);",
          "11854:         }",
          "11856:         return __super::SetEnumerable(propertyId, value);",
          "11857:     }",
          "11863:     BOOL JavascriptArray::SetWritable(PropertyId propertyId, BOOL value)",
          "11864:     {",
          "11865:         ScriptContext* scriptContext = this->GetScriptContext();",
          "11866:         uint32 index;",
          "11868:         bool setLengthNonWritable = (propertyId == PropertyIds::length && !value);",
          "11869:         if (setLengthNonWritable || scriptContext->IsNumericPropertyId(propertyId, &index))",
          "11870:         {",
          "11871:             return GetTypeHandler()->ConvertToTypeWithItemAttributes(this)",
          "11872:                 ->SetWritable(this, propertyId, value);",
          "11873:         }",
          "11875:         return __super::SetWritable(propertyId, value);",
          "11876:     }",
          "11882:     BOOL JavascriptArray::SetConfigurable(PropertyId propertyId, BOOL value)",
          "11883:     {",
          "11884:         if (propertyId == PropertyIds::length)",
          "11885:         {",
          "11886:             Assert(!value); // Can't change array length configurable",
          "11887:             return true;",
          "11888:         }",
          "11890:         ScriptContext* scriptContext = this->GetScriptContext();",
          "11892:         uint32 index;",
          "11893:         if (scriptContext->IsNumericPropertyId(propertyId, &index))",
          "11894:         {",
          "11895:             return GetTypeHandler()->ConvertToTypeWithItemAttributes(this)",
          "11896:                 ->SetConfigurable(this, propertyId, value);",
          "11897:         }",
          "11899:         return __super::SetConfigurable(propertyId, value);",
          "11900:     }",
          "11906:     BOOL JavascriptArray::SetAttributes(PropertyId propertyId, PropertyAttributes attributes)",
          "11907:     {",
          "11908:         ScriptContext* scriptContext = this->GetScriptContext();",
          "11912:         Assert(propertyId != PropertyIds::length);",
          "11914:         uint32 index;",
          "11915:         if (scriptContext->IsNumericPropertyId(propertyId, &index))",
          "11916:         {",
          "11917:             return GetTypeHandler()->ConvertToTypeWithItemAttributes(this)",
          "11918:                 ->SetItemAttributes(this, index, attributes);",
          "11919:         }",
          "11921:         return __super::SetAttributes(propertyId, attributes);",
          "11922:     }",
          "11928:     BOOL JavascriptArray::SetAccessors(PropertyId propertyId, Var getter, Var setter, PropertyOperationFlags flags)",
          "11929:     {",
          "11930:         ScriptContext* scriptContext = this->GetScriptContext();",
          "11932:         uint32 index;",
          "11933:         if (scriptContext->IsNumericPropertyId(propertyId, &index))",
          "11934:         {",
          "11935:             return GetTypeHandler()->ConvertToTypeWithItemAttributes(this)",
          "11936:                 ->SetItemAccessors(this, index, getter, setter);",
          "11937:         }",
          "11939:         return __super::SetAccessors(propertyId, getter, setter, flags);",
          "11940:     }",
          "11946:     BOOL JavascriptArray::SetItemWithAttributes(uint32 index, Var value, PropertyAttributes attributes)",
          "11947:     {",
          "11948:         return GetTypeHandler()->ConvertToTypeWithItemAttributes(this)",
          "11949:             ->SetItemWithAttributes(this, index, value, attributes);",
          "11950:     }",
          "11956:     BOOL JavascriptArray::SetItemAttributes(uint32 index, PropertyAttributes attributes)",
          "11957:     {",
          "11958:         return GetTypeHandler()->ConvertToTypeWithItemAttributes(this)",
          "11959:             ->SetItemAttributes(this, index, attributes);",
          "11960:     }",
          "11966:     BOOL JavascriptArray::SetItemAccessors(uint32 index, Var getter, Var setter)",
          "11967:     {",
          "11968:         return GetTypeHandler()->ConvertToTypeWithItemAttributes(this)",
          "11969:             ->SetItemAccessors(this, index, getter, setter);",
          "11970:     }",
          "11973:     BOOL JavascriptArray::IsObjectArrayFrozen()",
          "11974:     {",
          "11976:         return false;",
          "11977:     }",
          "11979:     JavascriptEnumerator * JavascriptArray::GetIndexEnumerator(EnumeratorFlags flags, ScriptContext* requestContext)",
          "11980:     {",
          "11981:         if (!!(flags & EnumeratorFlags::SnapShotSemantics))",
          "11982:         {",
          "11983:             return RecyclerNew(GetRecycler(), JavascriptArrayIndexSnapshotEnumerator, this, flags, requestContext);",
          "11984:         }",
          "11985:         return RecyclerNew(GetRecycler(), JavascriptArrayIndexEnumerator, this, flags, requestContext);",
          "11986:     }",
          "11988:     BOOL JavascriptArray::GetNonIndexEnumerator(JavascriptStaticEnumerator * enumerator, ScriptContext* requestContext)",
          "11989:     {",
          "11990:         return enumerator->Initialize(nullptr, nullptr, this, EnumeratorFlags::SnapShotSemantics, requestContext, nullptr);",
          "11991:     }",
          "11993:     BOOL JavascriptArray::IsItemEnumerable(uint32 index)",
          "11994:     {",
          "11995:         return true;",
          "11996:     }",
          "12002:     BOOL JavascriptArray::PreventExtensions()",
          "12003:     {",
          "12004:         return GetTypeHandler()->ConvertToTypeWithItemAttributes(this)->PreventExtensions(this);",
          "12005:     }",
          "12011:     BOOL JavascriptArray::Seal()",
          "12012:     {",
          "12013:         return GetTypeHandler()->ConvertToTypeWithItemAttributes(this)->Seal(this);",
          "12014:     }",
          "12020:     BOOL JavascriptArray::Freeze()",
          "12021:     {",
          "12022:         return GetTypeHandler()->ConvertToTypeWithItemAttributes(this)->Freeze(this);",
          "12023:     }",
          "12025:     BOOL JavascriptArray::GetSpecialPropertyName(uint32 index, Var *propertyName, ScriptContext * requestContext)",
          "12026:     {",
          "12027:         if (index == 0)",
          "12028:         {",
          "12030:             return true;",
          "12031:         }",
          "12032:         return false;",
          "12033:     }",
          "12036:     uint JavascriptArray::GetSpecialPropertyCount() const",
          "12037:     {",
          "12038:         return _countof(specialPropertyIds);",
          "12039:     }",
          "12042:     PropertyId const * JavascriptArray::GetSpecialPropertyIds() const",
          "12043:     {",
          "12044:         return specialPropertyIds;",
          "12045:     }",
          "12047:     BOOL JavascriptArray::GetPropertyReference(Var originalInstance, PropertyId propertyId, Var* value, PropertyValueInfo* info, ScriptContext* requestContext)",
          "12048:     {",
          "12049:         return JavascriptArray::GetProperty(originalInstance, propertyId, value, info, requestContext);",
          "12050:     }",
          "12052:     BOOL JavascriptArray::GetProperty(Var originalInstance, PropertyId propertyId, Var* value, PropertyValueInfo* info, ScriptContext* requestContext)",
          "12053:     {",
          "12054:         if (GetPropertyBuiltIns(propertyId, value))",
          "12055:         {",
          "12056:             return true;",
          "12057:         }",
          "12059:         ScriptContext* scriptContext = GetScriptContext();",
          "12060:         uint32 index;",
          "12061:         if (scriptContext->IsNumericPropertyId(propertyId, &index))",
          "12062:         {",
          "12063:             return this->GetItem(this, index, value, scriptContext);",
          "12064:         }",
          "12066:         return DynamicObject::GetProperty(originalInstance, propertyId, value, info, requestContext);",
          "12067:     }",
          "12069:     BOOL JavascriptArray::GetProperty(Var originalInstance, JavascriptString* propertyNameString, Var* value, PropertyValueInfo* info, ScriptContext* requestContext)",
          "12070:     {",
          "12071:         AssertMsg(!PropertyRecord::IsPropertyNameNumeric(propertyNameString->GetString(), propertyNameString->GetLength()),",
          "12072:             \"Numeric property names should have been converted to uint or PropertyRecord*\");",
          "12074:         PropertyRecord const* propertyRecord;",
          "12075:         this->GetScriptContext()->FindPropertyRecord(propertyNameString, &propertyRecord);",
          "12077:         if (propertyRecord != nullptr && GetPropertyBuiltIns(propertyRecord->GetPropertyId(), value))",
          "12078:         {",
          "12079:             return true;",
          "12080:         }",
          "12082:         return DynamicObject::GetProperty(originalInstance, propertyNameString, value, info, requestContext);",
          "12083:     }",
          "12085:     BOOL JavascriptArray::GetPropertyBuiltIns(PropertyId propertyId, Var* value)",
          "12086:     {",
          "12090:         if (propertyId == PropertyIds::length)",
          "12091:         {",
          "12093:             return true;",
          "12094:         }",
          "12096:         return false;",
          "12097:     }",
          "12099:     BOOL JavascriptArray::HasItem(uint32 index)",
          "12100:     {",
          "12101:         Var value;",
          "12102:         return this->DirectGetItemAt<Var>(index, &value);",
          "12103:     }",
          "12105:     BOOL JavascriptArray::GetItem(Var originalInstance, uint32 index, Var* value, ScriptContext* requestContext)",
          "12106:     {",
          "12107:         return this->DirectGetItemAt<Var>(index, value);",
          "12108:     }",
          "12110:     BOOL JavascriptArray::GetItemReference(Var originalInstance, uint32 index, Var* value, ScriptContext* requestContext)",
          "12111:     {",
          "12112:         return this->DirectGetItemAt<Var>(index, value);",
          "12113:     }",
          "12115:     BOOL JavascriptArray::DirectGetVarItemAt(uint32 index, Var *value, ScriptContext *requestContext)",
          "12116:     {",
          "12117:         return this->DirectGetItemAt<Var>(index, value);",
          "12118:     }",
          "12120:     BOOL JavascriptNativeIntArray::HasItem(uint32 index)",
          "12121:     {",
          "12122: #if ENABLE_COPYONACCESS_ARRAY",
          "12123:         JavascriptLibrary::CheckAndConvertCopyOnAccessNativeIntArray<Var>(this);",
          "12124: #endif",
          "12125:         int32 value;",
          "12126:         return this->DirectGetItemAt<int32>(index, &value);",
          "12127:     }",
          "12129:     BOOL JavascriptNativeFloatArray::HasItem(uint32 index)",
          "12130:     {",
          "12131:         double dvalue;",
          "12132:         return this->DirectGetItemAt<double>(index, &dvalue);",
          "12133:     }",
          "12135:     BOOL JavascriptNativeIntArray::GetItem(Var originalInstance, uint32 index, Var* value, ScriptContext* requestContext)",
          "12136:     {",
          "12137: #if ENABLE_COPYONACCESS_ARRAY",
          "12138:         JavascriptLibrary::CheckAndConvertCopyOnAccessNativeIntArray<Var>(this);",
          "12139: #endif",
          "12140:         return JavascriptNativeIntArray::DirectGetVarItemAt(index, value, requestContext);",
          "12141:     }",
          "12143:     BOOL JavascriptNativeIntArray::DirectGetVarItemAt(uint32 index, Var *value, ScriptContext *requestContext)",
          "12144:     {",
          "12145:         int32 intvalue;",
          "12146:         if (!this->DirectGetItemAt<int32>(index, &intvalue))",
          "12147:         {",
          "12148:             return FALSE;",
          "12149:         }",
          "12151:         return TRUE;",
          "12152:     }",
          "12154:     BOOL JavascriptNativeIntArray::GetItemReference(Var originalInstance, uint32 index, Var* value, ScriptContext* requestContext)",
          "12155:     {",
          "12156:         return JavascriptNativeIntArray::GetItem(originalInstance, index, value, requestContext);",
          "12157:     }",
          "12159:     BOOL JavascriptNativeFloatArray::GetItem(Var originalInstance, uint32 index, Var* value, ScriptContext* requestContext)",
          "12160:     {",
          "12161:         return JavascriptNativeFloatArray::DirectGetVarItemAt(index, value, requestContext);",
          "12162:     }",
          "12164:     BOOL JavascriptNativeFloatArray::DirectGetVarItemAt(uint32 index, Var *value, ScriptContext *requestContext)",
          "12165:     {",
          "12166:         double dvalue;",
          "12167:         int32 ivalue;",
          "12168:         if (!this->DirectGetItemAt<double>(index, &dvalue))",
          "12169:         {",
          "12170:             return FALSE;",
          "12171:         }",
          "12172:         if (*(uint64*)&dvalue == 0ull)",
          "12173:         {",
          "12175:         }",
          "12176:         else if (JavascriptNumber::TryGetInt32Value(dvalue, &ivalue) && !TaggedInt::IsOverflow(ivalue))",
          "12177:         {",
          "12179:         }",
          "12180:         else",
          "12181:         {",
          "12183:         }",
          "12184:         return TRUE;",
          "12185:     }",
          "12187:     BOOL JavascriptNativeFloatArray::GetItemReference(Var originalInstance, uint32 index, Var* value, ScriptContext* requestContext)",
          "12188:     {",
          "12189:         return JavascriptNativeFloatArray::GetItem(originalInstance, index, value, requestContext);",
          "12190:     }",
          "12192:     BOOL JavascriptArray::SetProperty(PropertyId propertyId, Var value, PropertyOperationFlags flags, PropertyValueInfo* info)",
          "12193:     {",
          "12194: #if ENABLE_COPYONACCESS_ARRAY",
          "12195:         JavascriptLibrary::CheckAndConvertCopyOnAccessNativeIntArray<Var>(this);",
          "12196: #endif",
          "12197:         uint32 indexValue;",
          "12198:         if (propertyId == PropertyIds::length)",
          "12199:         {",
          "12200:             return this->SetLength(value);",
          "12201:         }",
          "12202:         else if (GetScriptContext()->IsNumericPropertyId(propertyId, &indexValue))",
          "12203:         {",
          "12205:             return SetItem(indexValue, value, flags);",
          "12206:         }",
          "12207:         else",
          "12208:         {",
          "12209:             return DynamicObject::SetProperty(propertyId, value, flags, info);",
          "12210:         }",
          "12211:     }",
          "12213:     BOOL JavascriptArray::SetProperty(JavascriptString* propertyNameString, Var value, PropertyOperationFlags flags, PropertyValueInfo* info)",
          "12214:     {",
          "12215:         AssertMsg(!PropertyRecord::IsPropertyNameNumeric(propertyNameString->GetString(), propertyNameString->GetLength()),",
          "12216:             \"Numeric property names should have been converted to uint or PropertyRecord*\");",
          "12218: #if ENABLE_COPYONACCESS_ARRAY",
          "12219:         JavascriptLibrary::CheckAndConvertCopyOnAccessNativeIntArray<Var>(this);",
          "12220: #endif",
          "12221:         PropertyRecord const* propertyRecord;",
          "12222:         this->GetScriptContext()->FindPropertyRecord(propertyNameString, &propertyRecord);",
          "12224:         if (propertyRecord != nullptr && propertyRecord->GetPropertyId() == PropertyIds::length)",
          "12225:         {",
          "12226:             return this->SetLength(value);",
          "12227:         }",
          "12229:         return DynamicObject::SetProperty(propertyNameString, value, flags, info);",
          "12230:     }",
          "12232:     BOOL JavascriptArray::SetPropertyWithAttributes(PropertyId propertyId, Var value, PropertyAttributes attributes, PropertyValueInfo* info, PropertyOperationFlags flags, SideEffects possibleSideEffects)",
          "12233:     {",
          "12234: #if ENABLE_COPYONACCESS_ARRAY",
          "12235:         JavascriptLibrary::CheckAndConvertCopyOnAccessNativeIntArray<Var>(this);",
          "12236: #endif",
          "12237:         ScriptContext* scriptContext = GetScriptContext();",
          "12239:         if (propertyId == PropertyIds::length)",
          "12240:         {",
          "12241:             Assert(attributes == PropertyWritable);",
          "12242:             Assert(IsWritable(propertyId) && !IsConfigurable(propertyId) && !IsEnumerable(propertyId));",
          "12243:             return this->SetLength(value);",
          "12244:         }",
          "12246:         uint32 index;",
          "12247:         if (scriptContext->IsNumericPropertyId(propertyId, &index))",
          "12248:         {",
          "12250:             return SetItemWithAttributes(index, value, attributes);",
          "12251:         }",
          "12253:         return __super::SetPropertyWithAttributes(propertyId, value, attributes, info, flags, possibleSideEffects);",
          "12254:     }",
          "12256:     BOOL JavascriptArray::SetItem(uint32 index, Var value, PropertyOperationFlags flags)",
          "12257:     {",
          "12258:         this->DirectSetItemAt(index, value);",
          "12259:         return true;",
          "12260:     }",
          "12262:     BOOL JavascriptNativeIntArray::SetItem(uint32 index, Var value, PropertyOperationFlags flags)",
          "12263:     {",
          "12264:         int32 iValue;",
          "12265:         double dValue;",
          "12266: #if ENABLE_COPYONACCESS_ARRAY",
          "12267:         JavascriptLibrary::CheckAndConvertCopyOnAccessNativeIntArray<Var>(this);",
          "12268: #endif",
          "12269:         TypeId typeId = this->TrySetNativeIntArrayItem(value, &iValue, &dValue);",
          "12270:         if (typeId == TypeIds_NativeIntArray)",
          "12271:         {",
          "12272:             this->SetItem(index, iValue);",
          "12273:         }",
          "12274:         else if (typeId == TypeIds_NativeFloatArray)",
          "12275:         {",
          "12276:             reinterpret_cast<JavascriptNativeFloatArray*>(this)->DirectSetItemAt<double>(index, dValue);",
          "12277:         }",
          "12278:         else",
          "12279:         {",
          "12280:             this->DirectSetItemAt<Var>(index, value);",
          "12281:         }",
          "12283:         return TRUE;",
          "12284:     }",
          "12286:     TypeId JavascriptNativeIntArray::TrySetNativeIntArrayItem(Var value, int32 *iValue, double *dValue)",
          "12287:     {",
          "12288:         if (TaggedInt::Is(value))",
          "12289:         {",
          "12290:             int32 i = TaggedInt::ToInt32(value);",
          "12291:             if (i != JavascriptNativeIntArray::MissingItem)",
          "12292:             {",
          "12294:                 return TypeIds_NativeIntArray;",
          "12295:             }",
          "12296:         }",
          "12297:         if (JavascriptNumber::Is_NoTaggedIntCheck(value))",
          "12298:         {",
          "12299:             bool isInt32;",
          "12300:             int32 i;",
          "12301:             double d = JavascriptNumber::GetValue(value);",
          "12302:             if (JavascriptNumber::TryGetInt32OrUInt32Value(d, &i, &isInt32))",
          "12303:             {",
          "12304:                 if (isInt32 && i != JavascriptNativeIntArray::MissingItem)",
          "12305:                 {",
          "12307:                     return TypeIds_NativeIntArray;",
          "12308:                 }",
          "12309:             }",
          "12310:             else",
          "12311:             {",
          "12313:                 JavascriptNativeIntArray::ToNativeFloatArray(this);",
          "12314:                 return TypeIds_NativeFloatArray;",
          "12315:             }",
          "12316:         }",
          "12318:         JavascriptNativeIntArray::ToVarArray(this);",
          "12319:         return TypeIds_Array;",
          "12320:     }",
          "12322:     BOOL JavascriptNativeIntArray::SetItem(uint32 index, int32 iValue)",
          "12323:     {",
          "12324:         if (iValue == JavascriptNativeIntArray::MissingItem)",
          "12325:         {",
          "12326:             JavascriptArray *varArr = JavascriptNativeIntArray::ToVarArray(this);",
          "12327:             varArr->DirectSetItemAt(index, JavascriptNumber::ToVar(iValue, GetScriptContext()));",
          "12328:             return TRUE;",
          "12329:         }",
          "12331:         this->DirectSetItemAt(index, iValue);",
          "12332:         return TRUE;",
          "12333:     }",
          "12335:     BOOL JavascriptNativeFloatArray::SetItem(uint32 index, Var value, PropertyOperationFlags flags)",
          "12336:     {",
          "12337:         double dValue;",
          "12338:         TypeId typeId = this->TrySetNativeFloatArrayItem(value, &dValue);",
          "12339:         if (typeId == TypeIds_NativeFloatArray)",
          "12340:         {",
          "12341:             this->SetItem(index, dValue);",
          "12342:         }",
          "12343:         else",
          "12344:         {",
          "12345:             this->DirectSetItemAt(index, value);",
          "12346:         }",
          "12347:         return TRUE;",
          "12348:     }",
          "12350:     TypeId JavascriptNativeFloatArray::TrySetNativeFloatArrayItem(Var value, double *dValue)",
          "12351:     {",
          "12352:         if (TaggedInt::Is(value))",
          "12353:         {",
          "12355:             return TypeIds_NativeFloatArray;",
          "12356:         }",
          "12357:         else if (JavascriptNumber::Is_NoTaggedIntCheck(value))",
          "12358:         {",
          "12360:             return TypeIds_NativeFloatArray;",
          "12361:         }",
          "12363:         JavascriptNativeFloatArray::ToVarArray(this);",
          "12364:         return TypeIds_Array;",
          "12365:     }",
          "12367:     BOOL JavascriptNativeFloatArray::SetItem(uint32 index, double dValue)",
          "12368:     {",
          "12369:         if (*(uint64*)&dValue == *(uint64*)&JavascriptNativeFloatArray::MissingItem)",
          "12370:         {",
          "12371:             JavascriptArray *varArr = JavascriptNativeFloatArray::ToVarArray(this);",
          "12372:             varArr->DirectSetItemAt(index, JavascriptNumber::ToVarNoCheck(dValue, GetScriptContext()));",
          "12373:             return TRUE;",
          "12374:         }",
          "12376:         this->DirectSetItemAt<double>(index, dValue);",
          "12377:         return TRUE;",
          "12378:     }",
          "12380:     BOOL JavascriptArray::DeleteItem(uint32 index, PropertyOperationFlags flags)",
          "12381:     {",
          "12382:         return this->DirectDeleteItemAt<Var>(index);",
          "12383:     }",
          "12385:     BOOL JavascriptNativeIntArray::DeleteItem(uint32 index, PropertyOperationFlags flags)",
          "12386:     {",
          "12387:         return this->DirectDeleteItemAt<int32>(index);",
          "12388:     }",
          "12390:     BOOL JavascriptNativeFloatArray::DeleteItem(uint32 index, PropertyOperationFlags flags)",
          "12391:     {",
          "12392:         return this->DirectDeleteItemAt<double>(index);",
          "12393:     }",
          "12395:     BOOL JavascriptArray::GetEnumerator(JavascriptStaticEnumerator * enumerator, EnumeratorFlags flags, ScriptContext* requestContext, ForInCache * forInCache)",
          "12396:     {",
          "12397:         return enumerator->Initialize(nullptr, this, this, flags, requestContext, forInCache);",
          "12398:     }",
          "12400:     BOOL JavascriptArray::GetDiagValueString(StringBuilder<ArenaAllocator>* stringBuilder, ScriptContext* requestContext)",
          "12401:     {",
          "12402:         stringBuilder->Append(_u('['));",
          "12404:         if (this->length < 10)",
          "12405:         {",
          "12406:             auto funcPtr = [&]()",
          "12407:             {",
          "12408:                 ENTER_PINNED_SCOPE(JavascriptString, valueStr);",
          "12409:                 valueStr = JavascriptArray::JoinHelper(this, GetLibrary()->GetCommaDisplayString(), requestContext);",
          "12410:                 stringBuilder->Append(valueStr->GetString(), valueStr->GetLength());",
          "12411:                 LEAVE_PINNED_SCOPE();",
          "12412:             };",
          "12414:             if (!requestContext->GetThreadContext()->IsScriptActive())",
          "12415:             {",
          "12416:                 BEGIN_JS_RUNTIME_CALL(requestContext);",
          "12417:                 {",
          "12418:                     funcPtr();",
          "12419:                 }",
          "12420:                 END_JS_RUNTIME_CALL(requestContext);",
          "12421:             }",
          "12422:             else",
          "12423:             {",
          "12424:                 funcPtr();",
          "12425:             }",
          "12426:         }",
          "12427:         else",
          "12428:         {",
          "12429:             stringBuilder->AppendCppLiteral(_u(\"...\"));",
          "12430:         }",
          "12432:         stringBuilder->Append(_u(']'));",
          "12434:         return TRUE;",
          "12435:     }",
          "12437:     BOOL JavascriptArray::GetDiagTypeString(StringBuilder<ArenaAllocator>* stringBuilder, ScriptContext* requestContext)",
          "12438:     {",
          "12439:         stringBuilder->AppendCppLiteral(_u(\"Object, (Array)\"));",
          "12440:         return TRUE;",
          "12441:     }",
          "12443:     bool JavascriptNativeArray::Is(Var aValue)",
          "12444:     {",
          "12445:         TypeId typeId = JavascriptOperators::GetTypeId(aValue);",
          "12446:         return JavascriptNativeArray::Is(typeId);",
          "12447:     }",
          "12449:     bool JavascriptNativeArray::Is(TypeId typeId)",
          "12450:     {",
          "12451:         return JavascriptNativeIntArray::Is(typeId) || JavascriptNativeFloatArray::Is(typeId);",
          "12452:     }",
          "12454:     JavascriptNativeArray* JavascriptNativeArray::FromVar(Var aValue)",
          "12455:     {",
          "12456:         AssertMsg(Is(aValue), \"Ensure var is actually a 'JavascriptNativeArray'\");",
          "12458:         return static_cast<JavascriptNativeArray *>(RecyclableObject::FromVar(aValue));",
          "12459:     }",
          "12461:     bool JavascriptNativeIntArray::Is(Var aValue)",
          "12462:     {",
          "12463:         TypeId typeId = JavascriptOperators::GetTypeId(aValue);",
          "12464:         return JavascriptNativeIntArray::Is(typeId);",
          "12465:     }",
          "12467: #if ENABLE_COPYONACCESS_ARRAY",
          "12468:     bool JavascriptCopyOnAccessNativeIntArray::Is(Var aValue)",
          "12469:     {",
          "12470:         TypeId typeId = JavascriptOperators::GetTypeId(aValue);",
          "12471:         return JavascriptCopyOnAccessNativeIntArray::Is(typeId);",
          "12472:     }",
          "12473: #endif",
          "12475:     bool JavascriptNativeIntArray::Is(TypeId typeId)",
          "12476:     {",
          "12477:         return typeId == TypeIds_NativeIntArray;",
          "12478:     }",
          "12480: #if ENABLE_COPYONACCESS_ARRAY",
          "12481:     bool JavascriptCopyOnAccessNativeIntArray::Is(TypeId typeId)",
          "12482:     {",
          "12483:         return typeId == TypeIds_CopyOnAccessNativeIntArray;",
          "12484:     }",
          "12485: #endif",
          "12487:     bool JavascriptNativeIntArray::IsNonCrossSite(Var aValue)",
          "12488:     {",
          "12489:         bool ret = !TaggedInt::Is(aValue) && VirtualTableInfo<JavascriptNativeIntArray>::HasVirtualTable(aValue);",
          "12490:         Assert(ret == (JavascriptNativeIntArray::Is(aValue) && !JavascriptNativeIntArray::FromVar(aValue)->IsCrossSiteObject()));",
          "12491:         return ret;",
          "12492:     }",
          "12494:     JavascriptNativeIntArray* JavascriptNativeIntArray::FromVar(Var aValue)",
          "12495:     {",
          "12496:         AssertMsg(Is(aValue), \"Ensure var is actually a 'JavascriptNativeIntArray'\");",
          "12498:         return static_cast<JavascriptNativeIntArray *>(RecyclableObject::FromVar(aValue));",
          "12499:     }",
          "12501: #if ENABLE_COPYONACCESS_ARRAY",
          "12502:     JavascriptCopyOnAccessNativeIntArray* JavascriptCopyOnAccessNativeIntArray::FromVar(Var aValue)",
          "12503:     {",
          "12504:         AssertMsg(Is(aValue), \"Ensure var is actually a 'JavascriptCopyOnAccessNativeIntArray'\");",
          "12506:         return static_cast<JavascriptCopyOnAccessNativeIntArray *>(RecyclableObject::FromVar(aValue));",
          "12507:     }",
          "12508: #endif",
          "12510:     bool JavascriptNativeFloatArray::Is(Var aValue)",
          "12511:     {",
          "12512:         TypeId typeId = JavascriptOperators::GetTypeId(aValue);",
          "12513:         return JavascriptNativeFloatArray::Is(typeId);",
          "12514:     }",
          "12516:     bool JavascriptNativeFloatArray::Is(TypeId typeId)",
          "12517:     {",
          "12518:         return typeId == TypeIds_NativeFloatArray;",
          "12519:     }",
          "12521:     bool JavascriptNativeFloatArray::IsNonCrossSite(Var aValue)",
          "12522:     {",
          "12523:         bool ret = !TaggedInt::Is(aValue) && VirtualTableInfo<JavascriptNativeFloatArray>::HasVirtualTable(aValue);",
          "12524:         Assert(ret == (JavascriptNativeFloatArray::Is(aValue) && !JavascriptNativeFloatArray::FromVar(aValue)->IsCrossSiteObject()));",
          "12525:         return ret;",
          "12526:     }",
          "12528:     JavascriptNativeFloatArray* JavascriptNativeFloatArray::FromVar(Var aValue)",
          "12529:     {",
          "12530:         AssertMsg(Is(aValue), \"Ensure var is actually a 'JavascriptNativeFloatArray'\");",
          "12532:         return static_cast<JavascriptNativeFloatArray *>(RecyclableObject::FromVar(aValue));",
          "12533:     }",
          "12535:     template int   Js::JavascriptArray::GetParamForIndexOf<unsigned int>(unsigned int, Js::Arguments const&, void*&, unsigned int&, Js::ScriptContext*);",
          "12536:     template bool  Js::JavascriptArray::ArrayElementEnumerator::MoveNext<void*>();",
          "12537:     template void  Js::JavascriptArray::SetArrayLiteralItem<void*>(unsigned int, void*);",
          "12538:     template void* Js::JavascriptArray::TemplatedIndexOfHelper<false, Js::TypedArrayBase, unsigned int>(Js::TypedArrayBase*, void*, unsigned int, unsigned int, Js::ScriptContext*);",
          "12539:     template void* Js::JavascriptArray::TemplatedIndexOfHelper<true, Js::TypedArrayBase, unsigned int>(Js::TypedArrayBase*, void*, unsigned int, unsigned int, Js::ScriptContext*);",
          "12540: } //namespace Js",
          "",
          "---------------"
        ],
        "lib/Runtime/Library/JavascriptLibrary.h||lib/Runtime/Library/JavascriptLibrary.h": [
          "File: lib/Runtime/Library/JavascriptLibrary.h -> lib/Runtime/Library/JavascriptLibrary.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "5: #pragma once",
          "7: #define InlineSlotCountIncrement (HeapConstants::ObjectGranularity / sizeof(Var))",
          "9: #define MaxPreInitializedObjectTypeInlineSlotCount 16",
          "10: #define MaxPreInitializedObjectHeaderInlinedTypeInlineSlotCount \\",
          "11:     (Js::DynamicTypeHandler::GetObjectHeaderInlinableSlotCapacity() + MaxPreInitializedObjectTypeInlineSlotCount)",
          "12: #define PreInitializedObjectTypeCount ((MaxPreInitializedObjectTypeInlineSlotCount / InlineSlotCountIncrement) + 1)",
          "13: CompileAssert(MaxPreInitializedObjectTypeInlineSlotCount <= USHRT_MAX);",
          "15: class ScriptSite;",
          "16: class ActiveScriptExternalLibrary;",
          "17: class ProjectionExternalLibrary;",
          "18: class EditAndContinue;",
          "19: class ChakraHostScriptContext;",
          "21: #ifdef ENABLE_PROJECTION",
          "22: namespace Projection",
          "23: {",
          "24:     class ProjectionContext;",
          "25:     class WinRTPromiseEngineInterfaceExtensionObject;",
          "26: }",
          "27: #endif",
          "29: namespace Js",
          "30: {",
          "31:     static const unsigned int EvalMRUSize = 15;",
          "32:     typedef JsUtil::BaseDictionary<DWORD_PTR, SourceContextInfo *, Recycler, PowerOf2SizePolicy> SourceContextInfoMap;",
          "33:     typedef JsUtil::BaseDictionary<uint, SourceContextInfo *, Recycler, PowerOf2SizePolicy> DynamicSourceContextInfoMap;",
          "35:     typedef JsUtil::BaseDictionary<EvalMapString, ScriptFunction*, RecyclerNonLeafAllocator, PrimeSizePolicy> SecondLevelEvalCache;",
          "36:     typedef TwoLevelHashRecord<FastEvalMapString, ScriptFunction*, SecondLevelEvalCache, EvalMapString> EvalMapRecord;",
          "37:     typedef JsUtil::Cache<FastEvalMapString, EvalMapRecord*, RecyclerNonLeafAllocator, PrimeSizePolicy, JsUtil::MRURetentionPolicy<FastEvalMapString, EvalMRUSize>, FastEvalMapStringComparer> EvalCacheTopLevelDictionary;",
          "38:     typedef JsUtil::Cache<EvalMapString, FunctionInfo*, RecyclerNonLeafAllocator, PrimeSizePolicy, JsUtil::MRURetentionPolicy<EvalMapString, EvalMRUSize>> NewFunctionCache;",
          "39:     typedef JsUtil::BaseDictionary<ParseableFunctionInfo*, ParseableFunctionInfo*, Recycler, PrimeSizePolicy, RecyclerPointerComparer> ParseableFunctionInfoMap;",
          "41:     typedef TwoLevelHashDictionary<FastEvalMapString, ScriptFunction*, EvalMapRecord, EvalCacheTopLevelDictionary, EvalMapString> EvalCacheDictionary;",
          "43:     typedef JsUtil::BaseDictionary<JavascriptMethod, JavascriptFunction*, Recycler, PowerOf2SizePolicy> BuiltInLibraryFunctionMap;",
          "46:     struct EnumeratedObjectCache",
          "47:     {",
          "48:         static const int kMaxCachedPropStrings = 16;",
          "49:         Field(DynamicObject*) object;",
          "50:         Field(DynamicType*) type;",
          "51:         Field(PropertyString*) propertyStrings[kMaxCachedPropStrings];",
          "52:         Field(int) validPropStrings;",
          "53:     };",
          "55:     struct Cache",
          "56:     {",
          "57:         Field(JavascriptString *) lastNumberToStringRadix10String;",
          "58:         Field(EnumeratedObjectCache) enumObjCache;",
          "59:         Field(JavascriptString *) lastUtcTimeFromStrString;",
          "60:         Field(EvalCacheDictionary*) evalCacheDictionary;",
          "61:         Field(EvalCacheDictionary*) indirectEvalCacheDictionary;",
          "62:         Field(NewFunctionCache*) newFunctionCache;",
          "63:         Field(RegexPatternMruMap *) dynamicRegexMap;",
          "64:         Field(SourceContextInfoMap*) sourceContextInfoMap;   // maps host provided context cookie to the URL of the script buffer passed.",
          "65:         Field(DynamicSourceContextInfoMap*) dynamicSourceContextInfoMap;",
          "66:         Field(SourceContextInfo*) noContextSourceContextInfo;",
          "67:         Field(SRCINFO*) noContextGlobalSourceInfo;",
          "68:         Field(Field(SRCINFO const *)*) moduleSrcInfo;",
          "69:         Field(BuiltInLibraryFunctionMap*) builtInLibraryFunctions;",
          "70: #if ENABLE_PROFILE_INFO",
          "71: #if DBG_DUMP || defined(DYNAMIC_PROFILE_STORAGE) || defined(RUNTIME_DATA_COLLECTION)",
          "72:         Field(DynamicProfileInfoList*) profileInfoList;",
          "73: #endif",
          "74: #endif",
          "75:     };",
          "77:     class MissingPropertyTypeHandler;",
          "78:     class SourceTextModuleRecord;",
          "79:     class ArrayBufferBase;",
          "80:     class SharedContents;",
          "81:     typedef RecyclerFastAllocator<JavascriptNumber, LeafBit> RecyclerJavascriptNumberAllocator;",
          "82:     typedef JsUtil::List<Var, Recycler> ListForListIterator;",
          "84:     class UndeclaredBlockVariable : public RecyclableObject",
          "85:     {",
          "86:         friend class JavascriptLibrary;",
          "87:         UndeclaredBlockVariable(Type* type) : RecyclableObject(type) { }",
          "88:     };",
          "90:     class SourceTextModuleRecord;",
          "91:     typedef JsUtil::List<SourceTextModuleRecord*> ModuleRecordList;",
          "93: #if ENABLE_COPYONACCESS_ARRAY",
          "94:     struct CacheForCopyOnAccessArraySegments",
          "95:     {",
          "96:         static const uint32 MAX_SIZE = 31;",
          "97:         Field(SparseArraySegment<int32> *) cache[MAX_SIZE];",
          "98:         Field(uint32) count;",
          "100:         uint32 AddSegment(SparseArraySegment<int32> *segment)",
          "101:         {",
          "102:             cache[count++] = segment;",
          "103:             return count;",
          "104:         }",
          "106:         SparseArraySegment<int32> *GetSegmentByIndex(byte index)",
          "107:         {",
          "108:             Assert(index <= MAX_SIZE);",
          "109:             return cache[index - 1];",
          "110:         }",
          "112:         bool IsNotOverHardLimit()",
          "113:         {",
          "114:             return count < MAX_SIZE;",
          "115:         }",
          "117:         bool IsNotFull()",
          "118:         {",
          "119:             return count < (uint32) CONFIG_FLAG(CopyOnAccessArraySegmentCacheSize);",
          "120:         }",
          "122:         bool IsValidIndex(uint32 index)",
          "123:         {",
          "124:             return count && index && index <= count;",
          "125:         }",
          "127: #if ENABLE_DEBUG_CONFIG_OPTIONS",
          "128:         uint32 GetCount()",
          "129:         {",
          "130:             return count;",
          "131:         }",
          "132: #endif",
          "133:     };",
          "134: #endif",
          "136:     template <typename T>",
          "137:     struct StringTemplateCallsiteObjectComparer",
          "138:     {",
          "139:         static bool Equals(T x, T y)",
          "140:         {",
          "141:             static_assert(false, \"Unexpected type T\");",
          "142:         }",
          "143:         static hash_t GetHashCode(T i)",
          "144:         {",
          "145:             static_assert(false, \"Unexpected type T\");",
          "146:         }",
          "147:     };",
          "149:     template <>",
          "150:     struct StringTemplateCallsiteObjectComparer<ParseNodePtr>",
          "151:     {",
          "152:         static bool Equals(ParseNodePtr x, RecyclerWeakReference<Js::RecyclableObject>* y);",
          "153:         static bool Equals(ParseNodePtr x, ParseNodePtr y);",
          "154:         static hash_t GetHashCode(ParseNodePtr i);",
          "155:     };",
          "157:     template <>",
          "158:     struct StringTemplateCallsiteObjectComparer<RecyclerWeakReference<Js::RecyclableObject>*>",
          "159:     {",
          "160:         static bool Equals(RecyclerWeakReference<Js::RecyclableObject>* x, RecyclerWeakReference<Js::RecyclableObject>* y);",
          "161:         static bool Equals(RecyclerWeakReference<Js::RecyclableObject>* x, ParseNodePtr y);",
          "162:         static hash_t GetHashCode(RecyclerWeakReference<Js::RecyclableObject>* o);",
          "163:     };",
          "165:     class JavascriptLibrary : public JavascriptLibraryBase",
          "166:     {",
          "167:         friend class EditAndContinue;",
          "168:         friend class ScriptSite;",
          "169:         friend class GlobalObject;",
          "170:         friend class ScriptContext;",
          "171:         friend class EngineInterfaceObject;",
          "172:         friend class ExternalLibraryBase;",
          "173:         friend class ActiveScriptExternalLibrary;",
          "174:         friend class IntlEngineInterfaceExtensionObject;",
          "175:         friend class ChakraHostScriptContext;",
          "176: #ifdef ENABLE_PROJECTION",
          "177:         friend class ProjectionExternalLibrary;",
          "178:         friend class Projection::WinRTPromiseEngineInterfaceExtensionObject;",
          "179:         friend class Projection::ProjectionContext;",
          "180: #endif",
          "181:         static const char16* domBuiltinPropertyNames[];",
          "183:     public:",
          "184: #if ENABLE_COPYONACCESS_ARRAY",
          "185:         Field(CacheForCopyOnAccessArraySegments *) cacheForCopyOnAccessArraySegments;",
          "186: #endif",
          "188:         static DWORD GetScriptContextOffset() { return offsetof(JavascriptLibrary, scriptContext); }",
          "189:         static DWORD GetUndeclBlockVarOffset() { return offsetof(JavascriptLibrary, undeclBlockVarSentinel); }",
          "190:         static DWORD GetEmptyStringOffset() { return offsetof(JavascriptLibrary, emptyString); }",
          "191:         static DWORD GetUndefinedValueOffset() { return offsetof(JavascriptLibrary, undefinedValue); }",
          "192:         static DWORD GetNullValueOffset() { return offsetof(JavascriptLibrary, nullValue); }",
          "193:         static DWORD GetBooleanTrueOffset() { return offsetof(JavascriptLibrary, booleanTrue); }",
          "194:         static DWORD GetBooleanFalseOffset() { return offsetof(JavascriptLibrary, booleanFalse); }",
          "195:         static DWORD GetNegativeZeroOffset() { return offsetof(JavascriptLibrary, negativeZero); }",
          "196:         static DWORD GetNumberTypeStaticOffset() { return offsetof(JavascriptLibrary, numberTypeStatic); }",
          "197:         static DWORD GetStringTypeStaticOffset() { return offsetof(JavascriptLibrary, stringTypeStatic); }",
          "198:         static DWORD GetObjectTypesOffset() { return offsetof(JavascriptLibrary, objectTypes); }",
          "199:         static DWORD GetObjectHeaderInlinedTypesOffset() { return offsetof(JavascriptLibrary, objectHeaderInlinedTypes); }",
          "200:         static DWORD GetRegexTypeOffset() { return offsetof(JavascriptLibrary, regexType); }",
          "201:         static DWORD GetArrayConstructorOffset() { return offsetof(JavascriptLibrary, arrayConstructor); }",
          "202:         static DWORD GetPositiveInfinityOffset() { return offsetof(JavascriptLibrary, positiveInfinite); }",
          "203:         static DWORD GetNaNOffset() { return offsetof(JavascriptLibrary, nan); }",
          "204:         static DWORD GetNativeIntArrayTypeOffset() { return offsetof(JavascriptLibrary, nativeIntArrayType); }",
          "205: #if ENABLE_COPYONACCESS_ARRAY",
          "206:         static DWORD GetCopyOnAccessNativeIntArrayTypeOffset() { return offsetof(JavascriptLibrary, copyOnAccessNativeIntArrayType); }",
          "207: #endif",
          "208:         static DWORD GetNativeFloatArrayTypeOffset() { return offsetof(JavascriptLibrary, nativeFloatArrayType); }",
          "209:         static DWORD GetVTableAddressesOffset() { return offsetof(JavascriptLibrary, vtableAddresses); }",
          "210:         static DWORD GetConstructorCacheDefaultInstanceOffset() { return offsetof(JavascriptLibrary, constructorCacheDefaultInstance); }",
          "211:         static DWORD GetAbsDoubleCstOffset() { return offsetof(JavascriptLibrary, absDoubleCst); }",
          "212:         static DWORD GetUintConvertConstOffset() { return offsetof(JavascriptLibrary, uintConvertConst); }",
          "213:         static DWORD GetBuiltinFunctionsOffset() { return offsetof(JavascriptLibrary, builtinFunctions); }",
          "214:         static DWORD GetCharStringCacheOffset() { return offsetof(JavascriptLibrary, charStringCache); }",
          "215:         static DWORD GetCharStringCacheAOffset() { return GetCharStringCacheOffset() + CharStringCache::GetCharStringCacheAOffset(); }",
          "216:         const  JavascriptLibraryBase* GetLibraryBase() const { return static_cast<const JavascriptLibraryBase*>(this); }",
          "217:         void SetGlobalObject(GlobalObject* globalObject) {this->globalObject = globalObject; }",
          "218:         static DWORD GetRandSeed0Offset() { return offsetof(JavascriptLibrary, randSeed0); }",
          "219:         static DWORD GetRandSeed1Offset() { return offsetof(JavascriptLibrary, randSeed1); }",
          "220:         static DWORD GetTypeDisplayStringsOffset() { return offsetof(JavascriptLibrary, typeDisplayStrings); }",
          "221:         typedef bool (CALLBACK *PromiseContinuationCallback)(Var task, void *callbackState);",
          "223:         Var GetUndeclBlockVar() const { return undeclBlockVarSentinel; }",
          "224:         bool IsUndeclBlockVar(Var var) const { return var == undeclBlockVarSentinel; }",
          "226:         static bool IsTypedArrayConstructor(Var constructor, ScriptContext* scriptContext);",
          "228:     private:",
          "229:         FieldNoBarrier(Recycler *) recycler;",
          "230:         Field(ExternalLibraryBase*) externalLibraryList;",
          "232:         Field(UndeclaredBlockVariable*) undeclBlockVarSentinel;",
          "234:         Field(DynamicType *) generatorConstructorPrototypeObjectType;",
          "235:         Field(DynamicType *) constructorPrototypeObjectType;",
          "236:         Field(DynamicType *) heapArgumentsType;",
          "237:         Field(DynamicType *) activationObjectType;",
          "238:         Field(DynamicType *) arrayType;",
          "239:         Field(DynamicType *) nativeIntArrayType;",
          "240: #if ENABLE_COPYONACCESS_ARRAY",
          "241:         Field(DynamicType *) copyOnAccessNativeIntArrayType;",
          "242: #endif",
          "243:         Field(DynamicType *) nativeFloatArrayType;",
          "244:         Field(DynamicType *) arrayBufferType;",
          "245:         Field(DynamicType *) sharedArrayBufferType;",
          "246:         Field(DynamicType *) dataViewType;",
          "247:         Field(DynamicType *) typedArrayType;",
          "248:         Field(DynamicType *) int8ArrayType;",
          "249:         Field(DynamicType *) uint8ArrayType;",
          "250:         Field(DynamicType *) uint8ClampedArrayType;",
          "251:         Field(DynamicType *) int16ArrayType;",
          "252:         Field(DynamicType *) uint16ArrayType;",
          "253:         Field(DynamicType *) int32ArrayType;",
          "254:         Field(DynamicType *) uint32ArrayType;",
          "255:         Field(DynamicType *) float32ArrayType;",
          "256:         Field(DynamicType *) float64ArrayType;",
          "257:         Field(DynamicType *) int64ArrayType;",
          "258:         Field(DynamicType *) uint64ArrayType;",
          "259:         Field(DynamicType *) boolArrayType;",
          "260:         Field(DynamicType *) charArrayType;",
          "261:         Field(StaticType *) booleanTypeStatic;",
          "262:         Field(DynamicType *) booleanTypeDynamic;",
          "263:         Field(DynamicType *) dateType;",
          "264:         Field(StaticType *) variantDateType;",
          "265:         Field(DynamicType *) symbolTypeDynamic;",
          "266:         Field(StaticType *) symbolTypeStatic;",
          "267:         Field(DynamicType *) iteratorResultType;",
          "268:         Field(DynamicType *) arrayIteratorType;",
          "269:         Field(DynamicType *) mapIteratorType;",
          "270:         Field(DynamicType *) setIteratorType;",
          "271:         Field(DynamicType *) stringIteratorType;",
          "272:         Field(DynamicType *) promiseType;",
          "273:         Field(DynamicType *) listIteratorType;",
          "275:         Field(JavascriptFunction*) builtinFunctions[BuiltinFunction::Count];",
          "277:         Field(INT_PTR) vtableAddresses[VTableValue::Count];",
          "278:         Field(JavascriptString*) typeDisplayStrings[TypeIds_Limit];",
          "279:         Field(ConstructorCache *) constructorCacheDefaultInstance;",
          "280:         __declspec(align(16)) Field(const BYTE *) absDoubleCst;",
          "281:         Field(double const *) uintConvertConst;",
          "284:         Field(DynamicTypeHandler *) anonymousFunctionTypeHandler;",
          "285:         Field(DynamicTypeHandler *) anonymousFunctionWithPrototypeTypeHandler;",
          "286:         Field(DynamicTypeHandler *) functionTypeHandler;",
          "287:         Field(DynamicTypeHandler *) functionWithPrototypeTypeHandler;",
          "288:         Field(DynamicType *) externalFunctionWithDeferredPrototypeType;",
          "289:         Field(DynamicType *) wrappedFunctionWithDeferredPrototypeType;",
          "290:         Field(DynamicType *) stdCallFunctionWithDeferredPrototypeType;",
          "291:         Field(DynamicType *) idMappedFunctionWithPrototypeType;",
          "292:         Field(DynamicType *) externalConstructorFunctionWithDeferredPrototypeType;",
          "293:         Field(DynamicType *) defaultExternalConstructorFunctionWithDeferredPrototypeType;",
          "294:         Field(DynamicType *) boundFunctionType;",
          "295:         Field(DynamicType *) regexConstructorType;",
          "296:         Field(DynamicType *) crossSiteDeferredPrototypeFunctionType;",
          "297:         Field(DynamicType *) crossSiteIdMappedFunctionWithPrototypeType;",
          "298:         Field(DynamicType *) crossSiteExternalConstructFunctionWithPrototypeType;",
          "300:         Field(StaticType  *) enumeratorType;",
          "301:         Field(DynamicType *) errorType;",
          "302:         Field(DynamicType *) evalErrorType;",
          "303:         Field(DynamicType *) rangeErrorType;",
          "304:         Field(DynamicType *) referenceErrorType;",
          "305:         Field(DynamicType *) syntaxErrorType;",
          "306:         Field(DynamicType *) typeErrorType;",
          "307:         Field(DynamicType *) uriErrorType;",
          "308:         Field(DynamicType *) webAssemblyCompileErrorType;",
          "309:         Field(DynamicType *) webAssemblyRuntimeErrorType;",
          "310:         Field(DynamicType *) webAssemblyLinkErrorType;",
          "311:         Field(StaticType  *) numberTypeStatic;",
          "312:         Field(StaticType  *) int64NumberTypeStatic;",
          "313:         Field(StaticType  *) uint64NumberTypeStatic;",
          "315:         Field(DynamicType *) webAssemblyModuleType;",
          "316:         Field(DynamicType *) webAssemblyInstanceType;",
          "317:         Field(DynamicType *) webAssemblyMemoryType;",
          "318:         Field(DynamicType *) webAssemblyTableType;",
          "321:         Field(DynamicType *) simdBool8x16TypeDynamic;",
          "322:         Field(DynamicType *) simdBool16x8TypeDynamic;",
          "323:         Field(DynamicType *) simdBool32x4TypeDynamic;",
          "324:         Field(DynamicType *) simdInt8x16TypeDynamic;",
          "325:         Field(DynamicType *) simdInt16x8TypeDynamic;",
          "326:         Field(DynamicType *) simdInt32x4TypeDynamic;",
          "327:         Field(DynamicType *) simdUint8x16TypeDynamic;",
          "328:         Field(DynamicType *) simdUint16x8TypeDynamic;",
          "329:         Field(DynamicType *) simdUint32x4TypeDynamic;",
          "330:         Field(DynamicType *) simdFloat32x4TypeDynamic;",
          "332:         Field(StaticType *) simdFloat32x4TypeStatic;",
          "333:         Field(StaticType *) simdInt32x4TypeStatic;",
          "334:         Field(StaticType *) simdInt8x16TypeStatic;",
          "335:         Field(StaticType *) simdFloat64x2TypeStatic;",
          "336:         Field(StaticType *) simdInt16x8TypeStatic;",
          "337:         Field(StaticType *) simdBool32x4TypeStatic;",
          "338:         Field(StaticType *) simdBool16x8TypeStatic;",
          "339:         Field(StaticType *) simdBool8x16TypeStatic;",
          "340:         Field(StaticType *) simdUint32x4TypeStatic;",
          "341:         Field(StaticType *) simdUint16x8TypeStatic;",
          "342:         Field(StaticType *) simdUint8x16TypeStatic;",
          "344:         Field(DynamicType *) numberTypeDynamic;",
          "345:         Field(DynamicType *) objectTypes[PreInitializedObjectTypeCount];",
          "346:         Field(DynamicType *) objectHeaderInlinedTypes[PreInitializedObjectTypeCount];",
          "347:         Field(DynamicType *) regexPrototypeType;",
          "348:         Field(DynamicType *) regexType;",
          "349:         Field(DynamicType *) regexResultType;",
          "350:         Field(StaticType  *) stringTypeStatic;",
          "351:         Field(DynamicType *) stringTypeDynamic;",
          "352:         Field(DynamicType *) mapType;",
          "353:         Field(DynamicType *) setType;",
          "354:         Field(DynamicType *) weakMapType;",
          "355:         Field(DynamicType *) weakSetType;",
          "356:         Field(DynamicType *) proxyType;",
          "357:         Field(StaticType  *) withType;",
          "358:         Field(DynamicType *) SpreadArgumentType;",
          "359:         Field(DynamicType *) moduleNamespaceType;",
          "360:         Field(PropertyDescriptor) defaultPropertyDescriptor;",
          "362:         Field(JavascriptString*) nullString;",
          "363:         Field(JavascriptString*) emptyString;",
          "364:         Field(JavascriptString*) quotesString;",
          "365:         Field(JavascriptString*) whackString;",
          "366:         Field(JavascriptString*) objectDisplayString;",
          "367:         Field(JavascriptString*) stringTypeDisplayString;",
          "368:         Field(JavascriptString*) errorDisplayString;",
          "369:         Field(JavascriptString*) functionPrefixString;",
          "370:         Field(JavascriptString*) generatorFunctionPrefixString;",
          "371:         Field(JavascriptString*) asyncFunctionPrefixString;",
          "372:         Field(JavascriptString*) functionDisplayString;",
          "373:         Field(JavascriptString*) xDomainFunctionDisplayString;",
          "374:         Field(JavascriptString*) undefinedDisplayString;",
          "375:         Field(JavascriptString*) nanDisplayString;",
          "376:         Field(JavascriptString*) nullDisplayString;",
          "377:         Field(JavascriptString*) unknownDisplayString;",
          "378:         Field(JavascriptString*) commaDisplayString;",
          "379:         Field(JavascriptString*) commaSpaceDisplayString;",
          "380:         Field(JavascriptString*) trueDisplayString;",
          "381:         Field(JavascriptString*) falseDisplayString;",
          "382:         Field(JavascriptString*) lengthDisplayString;",
          "383:         Field(JavascriptString*) invalidDateString;",
          "384:         Field(JavascriptString*) objectTypeDisplayString;",
          "385:         Field(JavascriptString*) functionTypeDisplayString;",
          "386:         Field(JavascriptString*) booleanTypeDisplayString;",
          "387:         Field(JavascriptString*) numberTypeDisplayString;",
          "388:         Field(JavascriptString*) moduleTypeDisplayString;",
          "389:         Field(JavascriptString*) variantDateTypeDisplayString;",
          "392:         Field(JavascriptString*) simdFloat32x4DisplayString;",
          "393:         Field(JavascriptString*) simdFloat64x2DisplayString;",
          "394:         Field(JavascriptString*) simdInt32x4DisplayString;",
          "395:         Field(JavascriptString*) simdInt16x8DisplayString;",
          "396:         Field(JavascriptString*) simdInt8x16DisplayString;",
          "397:         Field(JavascriptString*) simdBool32x4DisplayString;",
          "398:         Field(JavascriptString*) simdBool16x8DisplayString;",
          "399:         Field(JavascriptString*) simdBool8x16DisplayString;",
          "400:         Field(JavascriptString*) simdUint32x4DisplayString;",
          "401:         Field(JavascriptString*) simdUint16x8DisplayString;",
          "402:         Field(JavascriptString*) simdUint8x16DisplayString;",
          "406:         Field(JavascriptString*) symbolTypeDisplayString;",
          "407:         Field(JavascriptString*) debuggerDeadZoneBlockVariableString;",
          "409:         Field(DynamicObject*) missingPropertyHolder;",
          "411:         Field(StaticType*) throwErrorObjectType;",
          "413:         Field(PropertyStringCacheMap*) propertyStringMap;",
          "415:         Field(ConstructorCache*) builtInConstructorCache;",
          "417: #ifdef ENABLE_DEBUG_CONFIG_OPTIONS",
          "418:         Field(JavascriptFunction*) debugObjectFaultInjectionCookieGetterFunction;",
          "419:         Field(JavascriptFunction*) debugObjectFaultInjectionCookieSetterFunction;",
          "420: #endif",
          "422:         Field(JavascriptFunction*) evalFunctionObject;",
          "423:         Field(JavascriptFunction*) arrayPrototypeValuesFunction;",
          "424:         Field(JavascriptFunction*) parseIntFunctionObject;",
          "425:         Field(JavascriptFunction*) parseFloatFunctionObject;",
          "426:         Field(JavascriptFunction*) arrayPrototypeToStringFunction;",
          "427:         Field(JavascriptFunction*) arrayPrototypeToLocaleStringFunction;",
          "428:         Field(JavascriptFunction*) identityFunction;",
          "429:         Field(JavascriptFunction*) throwerFunction;",
          "430:         Field(JavascriptFunction*) generatorNextFunction;",
          "431:         Field(JavascriptFunction*) generatorThrowFunction;",
          "433:         Field(JavascriptFunction*) objectValueOfFunction;",
          "434:         Field(JavascriptFunction*) objectToStringFunction;",
          "436: #ifdef ENABLE_WASM",
          "437:         Field(DynamicObject*) webAssemblyObject;",
          "438: #endif",
          "441:         Field(JavascriptFunction*) simdFloat32x4ToStringFunction;",
          "442:         Field(JavascriptFunction*) simdFloat64x2ToStringFunction;",
          "443:         Field(JavascriptFunction*) simdInt32x4ToStringFunction;",
          "444:         Field(JavascriptFunction*) simdInt16x8ToStringFunction;",
          "445:         Field(JavascriptFunction*) simdInt8x16ToStringFunction;",
          "446:         Field(JavascriptFunction*) simdBool32x4ToStringFunction;",
          "447:         Field(JavascriptFunction*) simdBool16x8ToStringFunction;",
          "448:         Field(JavascriptFunction*) simdBool8x16ToStringFunction;",
          "449:         Field(JavascriptFunction*) simdUint32x4ToStringFunction;",
          "450:         Field(JavascriptFunction*) simdUint16x8ToStringFunction;",
          "451:         Field(JavascriptFunction*) simdUint8x16ToStringFunction;",
          "455:         Field(JavascriptSymbol*) symbolMatch;",
          "456:         Field(JavascriptSymbol*) symbolReplace;",
          "457:         Field(JavascriptSymbol*) symbolSearch;",
          "458:         Field(JavascriptSymbol*) symbolSplit;",
          "460:         Field(UnifiedRegex::RegexPattern *) emptyRegexPattern;",
          "461:         Field(JavascriptFunction*) regexExecFunction;",
          "462:         Field(JavascriptFunction*) regexFlagsGetterFunction;",
          "463:         Field(JavascriptFunction*) regexGlobalGetterFunction;",
          "464:         Field(JavascriptFunction*) regexStickyGetterFunction;",
          "465:         Field(JavascriptFunction*) regexUnicodeGetterFunction;",
          "467:         Field(RuntimeFunction*) sharedArrayBufferConstructor;",
          "468:         Field(DynamicObject*) sharedArrayBufferPrototype;",
          "469:         Field(DynamicObject*) atomicsObject;",
          "471:         Field(DynamicObject*) webAssemblyCompileErrorPrototype;",
          "472:         Field(RuntimeFunction*) webAssemblyCompileErrorConstructor;",
          "473:         Field(DynamicObject*) webAssemblyRuntimeErrorPrototype;",
          "474:         Field(RuntimeFunction*) webAssemblyRuntimeErrorConstructor;",
          "475:         Field(DynamicObject*) webAssemblyLinkErrorPrototype;",
          "476:         Field(RuntimeFunction*) webAssemblyLinkErrorConstructor;",
          "478:         Field(DynamicObject*) webAssemblyMemoryPrototype;",
          "479:         Field(RuntimeFunction*) webAssemblyMemoryConstructor;",
          "480:         Field(DynamicObject*) webAssemblyModulePrototype;",
          "481:         Field(RuntimeFunction*) webAssemblyModuleConstructor;",
          "482:         Field(DynamicObject*) webAssemblyInstancePrototype;",
          "483:         Field(RuntimeFunction*) webAssemblyInstanceConstructor;",
          "484:         Field(DynamicObject*) webAssemblyTablePrototype;",
          "485:         Field(RuntimeFunction*) webAssemblyTableConstructor;",
          "487:         Field(int) regexConstructorSlotIndex;",
          "488:         Field(int) regexExecSlotIndex;",
          "489:         Field(int) regexFlagsGetterSlotIndex;",
          "490:         Field(int) regexGlobalGetterSlotIndex;",
          "491:         Field(int) regexStickyGetterSlotIndex;",
          "492:         Field(int) regexUnicodeGetterSlotIndex;",
          "494:         mutable Field(CharStringCache) charStringCache;",
          "496:         FieldNoBarrier(PromiseContinuationCallback) nativeHostPromiseContinuationFunction;",
          "497:         Field(void *) nativeHostPromiseContinuationFunctionState;",
          "499:         typedef SList<Js::FunctionProxy*, Recycler> FunctionReferenceList;",
          "500:         typedef JsUtil::WeakReferenceDictionary<uintptr_t, DynamicType, DictionarySizePolicy<PowerOf2Policy, 1>> JsrtExternalTypesCache;",
          "502:         Field(void *) bindRefChunkBegin;",
          "503:         Field(Field(void*)*) bindRefChunkCurrent;",
          "504:         Field(Field(void*)*) bindRefChunkEnd;",
          "505:         Field(TypePath*) rootPath;         // this should be in library instead of ScriptContext::Cache",
          "506:         Field(Js::Cache) cache;",
          "507:         Field(FunctionReferenceList*) dynamicFunctionReference;",
          "508:         Field(uint) dynamicFunctionReferenceDepth;",
          "509:         Field(FinalizableObject*) jsrtContextObject;",
          "510:         Field(JsrtExternalTypesCache*) jsrtExternalTypesCache;",
          "511:         Field(FunctionBody*) fakeGlobalFuncForUndefer;",
          "513:         typedef JsUtil::BaseHashSet<RecyclerWeakReference<RecyclableObject>*, Recycler, PowerOf2SizePolicy, RecyclerWeakReference<RecyclableObject>*, StringTemplateCallsiteObjectComparer> StringTemplateCallsiteObjectList;",
          "518:         Field(StringTemplateCallsiteObjectList*) stringTemplateCallsiteObjectList;",
          "520:         Field(ModuleRecordList*) moduleRecordList;",
          "536:         Field(JsUtil::List<Type *> *) typesEnsuredToHaveOnlyWritableDataPropertiesInItAndPrototypeChain;",
          "538:         Field(uint64) randSeed0, randSeed1;",
          "539:         Field(bool) isPRNGSeeded;",
          "540:         Field(bool) inProfileMode;",
          "541:         Field(bool) inDispatchProfileMode;",
          "542:         Field(bool) arrayObjectHasUserDefinedSpecies;",
          "544:         JavascriptFunction * AddFunctionToLibraryObjectWithPrototype(DynamicObject * object, PropertyId propertyId, FunctionInfo * functionInfo, int length, DynamicObject * prototype = nullptr, DynamicType * functionType = nullptr);",
          "545:         JavascriptFunction * AddFunctionToLibraryObject(DynamicObject* object, PropertyId propertyId, FunctionInfo * functionInfo, int length, PropertyAttributes attributes = PropertyBuiltInMethodDefaults);",
          "547:         JavascriptFunction * AddFunctionToLibraryObjectWithName(DynamicObject* object, PropertyId propertyId, PropertyId nameId, FunctionInfo * functionInfo, int length);",
          "548:         RuntimeFunction* AddGetterToLibraryObject(DynamicObject* object, PropertyId propertyId, FunctionInfo* functionInfo);",
          "549:         void AddAccessorsToLibraryObject(DynamicObject* object, PropertyId propertyId, FunctionInfo * getterFunctionInfo, FunctionInfo * setterFunctionInfo);",
          "550:         void AddAccessorsToLibraryObject(DynamicObject* object, PropertyId propertyId, RecyclableObject * getterFunction, RecyclableObject * setterFunction);",
          "551:         void AddAccessorsToLibraryObjectWithName(DynamicObject* object, PropertyId propertyId, PropertyId nameId, FunctionInfo * getterFunctionInfo, FunctionInfo * setterFunction);",
          "552:         RuntimeFunction * CreateGetterFunction(PropertyId nameId, FunctionInfo* functionInfo);",
          "553:         RuntimeFunction * CreateSetterFunction(PropertyId nameId, FunctionInfo* functionInfo);",
          "555:         template <size_t N>",
          "556:         JavascriptFunction * AddFunctionToLibraryObjectWithPropertyName(DynamicObject* object, const char16(&propertyName)[N], FunctionInfo * functionInfo, int length);",
          "558:         static SimpleTypeHandler<1> SharedPrototypeTypeHandler;",
          "559:         static SimpleTypeHandler<1> SharedFunctionWithoutPrototypeTypeHandler;",
          "560:         static SimpleTypeHandler<1> SharedFunctionWithPrototypeTypeHandlerV11;",
          "561:         static SimpleTypeHandler<2> SharedFunctionWithPrototypeTypeHandler;",
          "562:         static SimpleTypeHandler<1> SharedFunctionWithLengthTypeHandler;",
          "563:         static SimpleTypeHandler<2> SharedFunctionWithLengthAndNameTypeHandler;",
          "564:         static SimpleTypeHandler<1> SharedIdMappedFunctionWithPrototypeTypeHandler;",
          "565:         static SimpleTypeHandler<2> SharedNamespaceSymbolTypeHandler;",
          "566:         static MissingPropertyTypeHandler MissingPropertyHolderTypeHandler;",
          "568:         static SimplePropertyDescriptor const SharedFunctionPropertyDescriptors[2];",
          "569:         static SimplePropertyDescriptor const HeapArgumentsPropertyDescriptors[3];",
          "570:         static SimplePropertyDescriptor const FunctionWithLengthAndPrototypeTypeDescriptors[2];",
          "571:         static SimplePropertyDescriptor const FunctionWithLengthAndNameTypeDescriptors[2];",
          "572:         static SimplePropertyDescriptor const ModuleNamespaceTypeDescriptors[2];",
          "574:     public:",
          "577:         static const ObjectInfoBits EnumFunctionClass = EnumClass_1_Bit;",
          "579:         static void InitializeProperties(ThreadContext * threadContext);",
          "581:         JavascriptLibrary(GlobalObject* globalObject) :",
          "582:             JavascriptLibraryBase(globalObject),",
          "583:             inProfileMode(false),",
          "584:             inDispatchProfileMode(false),",
          "585:             propertyStringMap(nullptr),",
          "586:             parseIntFunctionObject(nullptr),",
          "587:             evalFunctionObject(nullptr),",
          "588:             parseFloatFunctionObject(nullptr),",
          "589:             arrayPrototypeToLocaleStringFunction(nullptr),",
          "590:             arrayPrototypeToStringFunction(nullptr),",
          "591:             identityFunction(nullptr),",
          "592:             throwerFunction(nullptr),",
          "593:             jsrtContextObject(nullptr),",
          "594:             jsrtExternalTypesCache(nullptr),",
          "595:             fakeGlobalFuncForUndefer(nullptr),",
          "596:             externalLibraryList(nullptr),",
          "597: #if ENABLE_COPYONACCESS_ARRAY",
          "598:             cacheForCopyOnAccessArraySegments(nullptr),",
          "599: #endif",
          "600:             referencedPropertyRecords(nullptr),",
          "601:             stringTemplateCallsiteObjectList(nullptr),",
          "602:             moduleRecordList(nullptr),",
          "603:             rootPath(nullptr),",
          "604:             bindRefChunkBegin(nullptr),",
          "605:             bindRefChunkCurrent(nullptr),",
          "606:             bindRefChunkEnd(nullptr),",
          "607:             dynamicFunctionReference(nullptr)",
          "608:         {",
          "609:             this->globalObject = globalObject;",
          "610:         }",
          "612:         void Initialize(ScriptContext* scriptContext, GlobalObject * globalObject);",
          "613:         void Uninitialize();",
          "614:         GlobalObject* GetGlobalObject() const { return globalObject; }",
          "615:         ScriptContext* GetScriptContext() const { return scriptContext; }",
          "617:         Recycler * GetRecycler() const { return recycler; }",
          "618:         Var GetTrueOrFalse(BOOL value) { return value ? booleanTrue : booleanFalse; }",
          "619:         JavascriptSymbol* GetSymbolMatch() { return symbolMatch; }",
          "620:         JavascriptSymbol* GetSymbolReplace() { return symbolReplace; }",
          "621:         JavascriptSymbol* GetSymbolSearch() { return symbolSearch; }",
          "622:         JavascriptSymbol* GetSymbolSplit() { return symbolSplit; }",
          "623:         JavascriptSymbol* GetSymbolSpecies() { return symbolSpecies; }",
          "624:         JavascriptString* GetNullString() { return nullString; }",
          "625:         JavascriptString* GetEmptyString() const;",
          "626:         JavascriptString* GetWhackString() { return whackString; }",
          "627:         JavascriptString* GetUndefinedDisplayString() { return undefinedDisplayString; }",
          "628:         JavascriptString* GetNaNDisplayString() { return nanDisplayString; }",
          "629:         JavascriptString* GetQuotesString() { return quotesString; }",
          "630:         JavascriptString* GetNullDisplayString() { return nullDisplayString; }",
          "631:         JavascriptString* GetUnknownDisplayString() { return unknownDisplayString; }",
          "632:         JavascriptString* GetCommaDisplayString() { return commaDisplayString; }",
          "633:         JavascriptString* GetCommaSpaceDisplayString() { return commaSpaceDisplayString; }",
          "634:         JavascriptString* GetTrueDisplayString() { return trueDisplayString; }",
          "635:         JavascriptString* GetFalseDisplayString() { return falseDisplayString; }",
          "636:         JavascriptString* GetLengthDisplayString() { return lengthDisplayString; }",
          "637:         JavascriptString* GetObjectDisplayString() { return objectDisplayString; }",
          "638:         JavascriptString* GetStringTypeDisplayString() { return stringTypeDisplayString; }",
          "639:         JavascriptString* GetErrorDisplayString() const { return errorDisplayString; }",
          "640:         JavascriptString* GetFunctionPrefixString() { return functionPrefixString; }",
          "641:         JavascriptString* GetGeneratorFunctionPrefixString() { return generatorFunctionPrefixString; }",
          "642:         JavascriptString* GetAsyncFunctionPrefixString() { return asyncFunctionPrefixString; }",
          "643:         JavascriptString* GetFunctionDisplayString() { return functionDisplayString; }",
          "644:         JavascriptString* GetXDomainFunctionDisplayString() { return xDomainFunctionDisplayString; }",
          "645:         JavascriptString* GetInvalidDateString() { return invalidDateString; }",
          "646:         JavascriptString* GetObjectTypeDisplayString() const { return objectTypeDisplayString; }",
          "647:         JavascriptString* GetFunctionTypeDisplayString() const { return functionTypeDisplayString; }",
          "648:         JavascriptString* GetBooleanTypeDisplayString() const { return booleanTypeDisplayString; }",
          "649:         JavascriptString* GetNumberTypeDisplayString() const { return numberTypeDisplayString; }",
          "650:         JavascriptString* GetModuleTypeDisplayString() const { return moduleTypeDisplayString; }",
          "651:         JavascriptString* GetVariantDateTypeDisplayString() const { return variantDateTypeDisplayString; }",
          "654:         JavascriptString* GetSIMDFloat32x4DisplayString() const { return simdFloat32x4DisplayString; }",
          "655:         JavascriptString* GetSIMDFloat64x2DisplayString() const { return simdFloat64x2DisplayString; }",
          "656:         JavascriptString* GetSIMDInt32x4DisplayString()   const { return simdInt32x4DisplayString; }",
          "657:         JavascriptString* GetSIMDInt16x8DisplayString()   const { return simdInt16x8DisplayString; }",
          "658:         JavascriptString* GetSIMDInt8x16DisplayString()   const { return simdInt8x16DisplayString; }",
          "660:         JavascriptString* GetSIMDBool32x4DisplayString()   const { return simdBool32x4DisplayString; }",
          "661:         JavascriptString* GetSIMDBool16x8DisplayString()   const { return simdBool16x8DisplayString; }",
          "662:         JavascriptString* GetSIMDBool8x16DisplayString()   const { return simdBool8x16DisplayString; }",
          "664:         JavascriptString* GetSIMDUint32x4DisplayString()   const { return simdUint32x4DisplayString; }",
          "665:         JavascriptString* GetSIMDUint16x8DisplayString()   const { return simdUint16x8DisplayString; }",
          "666:         JavascriptString* GetSIMDUint8x16DisplayString()   const { return simdUint8x16DisplayString; }",
          "668:         JavascriptString* GetSymbolTypeDisplayString() const { return symbolTypeDisplayString; }",
          "669:         JavascriptString* GetDebuggerDeadZoneBlockVariableString() { Assert(debuggerDeadZoneBlockVariableString); return debuggerDeadZoneBlockVariableString; }",
          "670:         JavascriptRegExp* CreateEmptyRegExp();",
          "671:         JavascriptFunction* GetEvalFunctionObject() { return evalFunctionObject; }",
          "672:         JavascriptFunction* GetArrayPrototypeValuesFunction() { return EnsureArrayPrototypeValuesFunction(); }",
          "673:         JavascriptFunction* GetArrayIteratorPrototypeBuiltinNextFunction() { return arrayIteratorPrototypeBuiltinNextFunction; }",
          "674:         DynamicObject* GetReflectObject() const { return reflectObject; }",
          "675:         const PropertyDescriptor* GetDefaultPropertyDescriptor() const { return &defaultPropertyDescriptor; }",
          "676:         DynamicObject* GetMissingPropertyHolder() const { return missingPropertyHolder; }",
          "678:         JavascriptFunction* GetSharedArrayBufferConstructor() { return sharedArrayBufferConstructor; }",
          "679:         DynamicObject* GetAtomicsObject() { return atomicsObject; }",
          "681:         DynamicObject* GetWebAssemblyCompileErrorPrototype() const { return webAssemblyCompileErrorPrototype; }",
          "682:         DynamicObject* GetWebAssemblyCompileErrorConstructor() const { return webAssemblyCompileErrorConstructor; }",
          "683:         DynamicObject* GetWebAssemblyRuntimeErrorPrototype() const { return webAssemblyRuntimeErrorPrototype; }",
          "684:         DynamicObject* GetWebAssemblyRuntimeErrorConstructor() const { return webAssemblyRuntimeErrorConstructor; }",
          "685:         DynamicObject* GetWebAssemblyLinkErrorPrototype() const { return webAssemblyLinkErrorPrototype; }",
          "686:         DynamicObject* GetWebAssemblyLinkErrorConstructor() const { return webAssemblyLinkErrorConstructor; }",
          "688: #if ENABLE_TTD",
          "689:         Js::PropertyId ExtractPrimitveSymbolId_TTD(Var value);",
          "690:         Js::RecyclableObject* CreatePrimitveSymbol_TTD(Js::PropertyId pid);",
          "691:         Js::RecyclableObject* CreatePrimitveSymbol_TTD(Js::JavascriptString* str);",
          "693:         Js::RecyclableObject* CreateDefaultBoxedObject_TTD(Js::TypeId kind);",
          "694:         void SetBoxedObjectValue_TTD(Js::RecyclableObject* obj, Js::Var value);",
          "696:         Js::RecyclableObject* CreateDate_TTD(double value);",
          "697:         Js::RecyclableObject* CreateRegex_TTD(const char16* patternSource, uint32 patternLength, UnifiedRegex::RegexFlags flags, CharCount lastIndex, Js::Var lastVar);",
          "698:         Js::RecyclableObject* CreateError_TTD();",
          "700:         Js::RecyclableObject* CreateES5Array_TTD();",
          "701:         static void SetLengthWritableES5Array_TTD(Js::RecyclableObject* es5Array, bool isLengthWritable);",
          "703:         Js::RecyclableObject* CreateSet_TTD();",
          "704:         Js::RecyclableObject* CreateWeakSet_TTD();",
          "705:         static void AddSetElementInflate_TTD(Js::JavascriptSet* set, Var value);",
          "706:         static void AddWeakSetElementInflate_TTD(Js::JavascriptWeakSet* set, Var value);",
          "708:         Js::RecyclableObject* CreateMap_TTD();",
          "709:         Js::RecyclableObject* CreateWeakMap_TTD();",
          "710:         static void AddMapElementInflate_TTD(Js::JavascriptMap* map, Var key, Var value);",
          "711:         static void AddWeakMapElementInflate_TTD(Js::JavascriptWeakMap* map, Var key, Var value);",
          "713:         Js::RecyclableObject* CreateExternalFunction_TTD(Js::Var fname);",
          "714:         Js::RecyclableObject* CreateBoundFunction_TTD(RecyclableObject* function, Var bThis, uint32 ct, Var* args);",
          "716:         Js::RecyclableObject* CreateProxy_TTD(RecyclableObject* handler, RecyclableObject* target);",
          "717:         Js::RecyclableObject* CreateRevokeFunction_TTD(RecyclableObject* proxy);",
          "719:         Js::RecyclableObject* CreateHeapArguments_TTD(uint32 numOfArguments, uint32 formalCount, ActivationObject* frameObject, byte* deletedArray);",
          "720:         Js::RecyclableObject* CreateES5HeapArguments_TTD(uint32 numOfArguments, uint32 formalCount, ActivationObject* frameObject, byte* deletedArray);",
          "722:         Js::JavascriptPromiseCapability* CreatePromiseCapability_TTD(Var promise, Var resolve, Var reject);",
          "723:         Js::JavascriptPromiseReaction* CreatePromiseReaction_TTD(RecyclableObject* handler, JavascriptPromiseCapability* capabilities);",
          "725:         Js::RecyclableObject* CreatePromise_TTD(uint32 status, Var result, JsUtil::List<Js::JavascriptPromiseReaction*, HeapAllocator>& resolveReactions, JsUtil::List<Js::JavascriptPromiseReaction*, HeapAllocator>& rejectReactions);",
          "726:         JavascriptPromiseResolveOrRejectFunctionAlreadyResolvedWrapper* CreateAlreadyDefinedWrapper_TTD(bool alreadyDefined);",
          "727:         Js::RecyclableObject* CreatePromiseResolveOrRejectFunction_TTD(RecyclableObject* promise, bool isReject, JavascriptPromiseResolveOrRejectFunctionAlreadyResolvedWrapper* alreadyResolved);",
          "728:         Js::RecyclableObject* CreatePromiseReactionTaskFunction_TTD(JavascriptPromiseReaction* reaction, Var argument);",
          "730:         Js::JavascriptPromiseAllResolveElementFunctionRemainingElementsWrapper* CreateRemainingElementsWrapper_TTD(Js::ScriptContext* ctx, uint32 value);",
          "731:         Js::RecyclableObject* JavascriptLibrary::CreatePromiseAllResolveElementFunction_TTD(Js::JavascriptPromiseCapability* capabilities, uint32 index, Js::JavascriptPromiseAllResolveElementFunctionRemainingElementsWrapper* wrapper, Js::RecyclableObject* values, bool alreadyCalled);",
          "732: #endif",
          "734: #ifdef ENABLE_INTL_OBJECT",
          "735:         void ResetIntlObject();",
          "736:         void EnsureIntlObjectReady();",
          "737:         template <class Fn>",
          "738:         void InitializeIntlForPrototypes(Fn fn);",
          "739:         void InitializeIntlForStringPrototype();",
          "740:         void InitializeIntlForDatePrototype();",
          "741:         void InitializeIntlForNumberPrototype();",
          "742: #endif",
          "744: #ifdef ENABLE_DEBUG_CONFIG_OPTIONS",
          "745:         DynamicType * GetDebugDisposableObjectType() { return debugDisposableObjectType; }",
          "746:         DynamicType * GetDebugFuncExecutorInDisposeObjectType() { return debugFuncExecutorInDisposeObjectType; }",
          "747: #endif",
          "749:         DynamicType* GetErrorType(ErrorTypeEnum typeToCreate) const;",
          "750:         StaticType  * GetBooleanTypeStatic() const { return booleanTypeStatic; }",
          "751:         DynamicType * GetBooleanTypeDynamic() const { return booleanTypeDynamic; }",
          "752:         DynamicType * GetDateType() const { return dateType; }",
          "753:         DynamicType * GetBoundFunctionType() const { return boundFunctionType; }",
          "754:         DynamicType * GetRegExpConstructorType() const { return regexConstructorType; }",
          "755:         StaticType  * GetEnumeratorType() const { return enumeratorType; }",
          "756:         DynamicType * GetSpreadArgumentType() const { return SpreadArgumentType; }",
          "757:         StaticType  * GetWithType() const { return withType; }",
          "758:         DynamicType * GetErrorType() const { return errorType; }",
          "759:         DynamicType * GetEvalErrorType() const { return evalErrorType; }",
          "760:         DynamicType * GetRangeErrorType() const { return rangeErrorType; }",
          "761:         DynamicType * GetReferenceErrorType() const { return referenceErrorType; }",
          "762:         DynamicType * GetSyntaxErrorType() const { return syntaxErrorType; }",
          "763:         DynamicType * GetTypeErrorType() const { return typeErrorType; }",
          "764:         DynamicType * GetURIErrorType() const { return uriErrorType; }",
          "765:         DynamicType * GetWebAssemblyCompileErrorType() const { return webAssemblyCompileErrorType; }",
          "766:         DynamicType * GetWebAssemblyRuntimeErrorType() const { return webAssemblyRuntimeErrorType; }",
          "767:         DynamicType * GetWebAssemblyLinkErrorType() const { return webAssemblyLinkErrorType; }",
          "768:         StaticType  * GetNumberTypeStatic() const { return numberTypeStatic; }",
          "769:         StaticType  * GetInt64TypeStatic() const { return int64NumberTypeStatic; }",
          "770:         StaticType  * GetUInt64TypeStatic() const { return uint64NumberTypeStatic; }",
          "771:         DynamicType * GetNumberTypeDynamic() const { return numberTypeDynamic; }",
          "772:         DynamicType * GetPromiseType() const { return promiseType; }",
          "774:         DynamicType * GetWebAssemblyModuleType()  const { return webAssemblyModuleType; }",
          "775:         DynamicType * GetWebAssemblyInstanceType()  const { return webAssemblyInstanceType; }",
          "776:         DynamicType * GetWebAssemblyMemoryType() const { return webAssemblyMemoryType; }",
          "777:         DynamicType * GetWebAssemblyTableType() const { return webAssemblyTableType; }",
          "780:         DynamicType * GetSIMDBool8x16TypeDynamic()  const { return simdBool8x16TypeDynamic;  }",
          "781:         DynamicType * GetSIMDBool16x8TypeDynamic()  const { return simdBool16x8TypeDynamic;  }",
          "782:         DynamicType * GetSIMDBool32x4TypeDynamic()  const { return simdBool32x4TypeDynamic;  }",
          "783:         DynamicType * GetSIMDInt8x16TypeDynamic()   const { return simdInt8x16TypeDynamic;   }",
          "784:         DynamicType * GetSIMDInt16x8TypeDynamic()   const { return simdInt16x8TypeDynamic;   }",
          "785:         DynamicType * GetSIMDInt32x4TypeDynamic()   const { return simdInt32x4TypeDynamic;   }",
          "786:         DynamicType * GetSIMDUint8x16TypeDynamic()  const { return simdUint8x16TypeDynamic;  }",
          "787:         DynamicType * GetSIMDUint16x8TypeDynamic()  const { return simdUint16x8TypeDynamic;  }",
          "788:         DynamicType * GetSIMDUint32x4TypeDynamic()  const { return simdUint32x4TypeDynamic;  }",
          "789:         DynamicType * GetSIMDFloat32x4TypeDynamic() const { return simdFloat32x4TypeDynamic; }",
          "791:         StaticType* GetSIMDFloat32x4TypeStatic() const { return simdFloat32x4TypeStatic; }",
          "792:         StaticType* GetSIMDFloat64x2TypeStatic() const { return simdFloat64x2TypeStatic; }",
          "793:         StaticType* GetSIMDInt32x4TypeStatic()   const { return simdInt32x4TypeStatic; }",
          "794:         StaticType* GetSIMDInt16x8TypeStatic()   const { return simdInt16x8TypeStatic; }",
          "795:         StaticType* GetSIMDInt8x16TypeStatic()   const { return simdInt8x16TypeStatic; }",
          "796:         StaticType* GetSIMDBool32x4TypeStatic() const { return simdBool32x4TypeStatic; }",
          "797:         StaticType* GetSIMDBool16x8TypeStatic() const { return simdBool16x8TypeStatic; }",
          "798:         StaticType* GetSIMDBool8x16TypeStatic() const { return simdBool8x16TypeStatic; }",
          "799:         StaticType* GetSIMDUInt32x4TypeStatic()   const { return simdUint32x4TypeStatic; }",
          "800:         StaticType* GetSIMDUint16x8TypeStatic()   const { return simdUint16x8TypeStatic; }",
          "801:         StaticType* GetSIMDUint8x16TypeStatic()   const { return simdUint8x16TypeStatic; }",
          "803:         DynamicType * GetObjectLiteralType(uint16 requestedInlineSlotCapacity);",
          "804:         DynamicType * GetObjectHeaderInlinedLiteralType(uint16 requestedInlineSlotCapacity);",
          "805:         DynamicType * GetObjectType() const { return objectTypes[0]; }",
          "806:         DynamicType * GetObjectHeaderInlinedType() const { return objectHeaderInlinedTypes[0]; }",
          "807:         StaticType  * GetSymbolTypeStatic() const { return symbolTypeStatic; }",
          "808:         DynamicType * GetSymbolTypeDynamic() const { return symbolTypeDynamic; }",
          "809:         DynamicType * GetProxyType() const { return proxyType; }",
          "810:         DynamicType * GetHeapArgumentsObjectType() const { return heapArgumentsType; }",
          "811:         DynamicType * GetActivationObjectType() const { return activationObjectType; }",
          "812:         DynamicType * GetModuleNamespaceType() const { return moduleNamespaceType; }",
          "813:         DynamicType * GetArrayType() const { return arrayType; }",
          "814:         DynamicType * GetNativeIntArrayType() const { return nativeIntArrayType; }",
          "815: #if ENABLE_COPYONACCESS_ARRAY",
          "816:         DynamicType * GetCopyOnAccessNativeIntArrayType() const { return copyOnAccessNativeIntArrayType; }",
          "817: #endif",
          "818:         DynamicType * GetNativeFloatArrayType() const { return nativeFloatArrayType; }",
          "819:         DynamicType * GetRegexPrototypeType() const { return regexPrototypeType; }",
          "820:         DynamicType * GetRegexType() const { return regexType; }",
          "821:         DynamicType * GetRegexResultType() const { return regexResultType; }",
          "822:         DynamicType * GetArrayBufferType() const { return arrayBufferType; }",
          "823:         StaticType  * GetStringTypeStatic() const { AssertMsg(stringTypeStatic, \"Where's stringTypeStatic?\"); return stringTypeStatic; }",
          "824:         DynamicType * GetStringTypeDynamic() const { return stringTypeDynamic; }",
          "825:         StaticType  * GetVariantDateType() const { return variantDateType; }",
          "826:         void EnsureDebugObject(DynamicObject* newDebugObject);",
          "827:         DynamicObject* GetDebugObject() const { Assert(debugObject != nullptr); return debugObject; }",
          "828:         DynamicType * GetMapType() const { return mapType; }",
          "829:         DynamicType * GetSetType() const { return setType; }",
          "830:         DynamicType * GetWeakMapType() const { return weakMapType; }",
          "831:         DynamicType * GetWeakSetType() const { return weakSetType; }",
          "832:         DynamicType * GetArrayIteratorType() const { return arrayIteratorType; }",
          "833:         DynamicType * GetMapIteratorType() const { return mapIteratorType; }",
          "834:         DynamicType * GetSetIteratorType() const { return setIteratorType; }",
          "835:         DynamicType * GetStringIteratorType() const { return stringIteratorType; }",
          "836:         DynamicType * GetListIteratorType() const { return listIteratorType; }",
          "837:         JavascriptFunction* GetDefaultAccessorFunction() const { return defaultAccessorFunction; }",
          "838:         JavascriptFunction* GetStackTraceAccessorFunction() const { return stackTraceAccessorFunction; }",
          "839:         JavascriptFunction* GetThrowTypeErrorRestrictedPropertyAccessorFunction() const { return throwTypeErrorRestrictedPropertyAccessorFunction; }",
          "840:         JavascriptFunction* Get__proto__getterFunction() const { return __proto__getterFunction; }",
          "841:         JavascriptFunction* Get__proto__setterFunction() const { return __proto__setterFunction; }",
          "843:         JavascriptFunction* GetObjectValueOfFunction() const { return objectValueOfFunction; }",
          "844:         JavascriptFunction* GetObjectToStringFunction() const { return objectToStringFunction; }",
          "847:         JavascriptFunction* GetSIMDFloat32x4ToStringFunction() const { return simdFloat32x4ToStringFunction;  }",
          "848:         JavascriptFunction* GetSIMDFloat64x2ToStringFunction() const { return simdFloat64x2ToStringFunction; }",
          "849:         JavascriptFunction* GetSIMDInt32x4ToStringFunction()   const { return simdInt32x4ToStringFunction; }",
          "850:         JavascriptFunction* GetSIMDInt16x8ToStringFunction()   const { return simdInt16x8ToStringFunction; }",
          "851:         JavascriptFunction* GetSIMDInt8x16ToStringFunction()   const { return simdInt8x16ToStringFunction; }",
          "852:         JavascriptFunction* GetSIMDBool32x4ToStringFunction()   const { return simdBool32x4ToStringFunction; }",
          "853:         JavascriptFunction* GetSIMDBool16x8ToStringFunction()   const { return simdBool16x8ToStringFunction; }",
          "854:         JavascriptFunction* GetSIMDBool8x16ToStringFunction()   const { return simdBool8x16ToStringFunction; }",
          "855:         JavascriptFunction* GetSIMDUint32x4ToStringFunction()   const { return simdUint32x4ToStringFunction; }",
          "856:         JavascriptFunction* GetSIMDUint16x8ToStringFunction()   const { return simdUint16x8ToStringFunction; }",
          "857:         JavascriptFunction* GetSIMDUint8x16ToStringFunction()   const { return simdUint8x16ToStringFunction; }",
          "859:         JavascriptFunction* GetDebugObjectNonUserGetterFunction() const { return debugObjectNonUserGetterFunction; }",
          "860:         JavascriptFunction* GetDebugObjectNonUserSetterFunction() const { return debugObjectNonUserSetterFunction; }",
          "862:         UnifiedRegex::RegexPattern * GetEmptyRegexPattern() const { return emptyRegexPattern; }",
          "863:         JavascriptFunction* GetRegexExecFunction() const { return regexExecFunction; }",
          "864:         JavascriptFunction* GetRegexFlagsGetterFunction() const { return regexFlagsGetterFunction; }",
          "865:         JavascriptFunction* GetRegexGlobalGetterFunction() const { return regexGlobalGetterFunction; }",
          "866:         JavascriptFunction* GetRegexStickyGetterFunction() const { return regexStickyGetterFunction; }",
          "867:         JavascriptFunction* GetRegexUnicodeGetterFunction() const { return regexUnicodeGetterFunction; }",
          "869:         int GetRegexConstructorSlotIndex() const { return regexConstructorSlotIndex;  }",
          "870:         int GetRegexExecSlotIndex() const { return regexExecSlotIndex;  }",
          "871:         int GetRegexFlagsGetterSlotIndex() const { return regexFlagsGetterSlotIndex;  }",
          "872:         int GetRegexGlobalGetterSlotIndex() const { return regexGlobalGetterSlotIndex;  }",
          "873:         int GetRegexStickyGetterSlotIndex() const { return regexStickyGetterSlotIndex;  }",
          "874:         int GetRegexUnicodeGetterSlotIndex() const { return regexUnicodeGetterSlotIndex;  }",
          "876:         TypePath* GetRootPath() const { return rootPath; }",
          "877:         void BindReference(void * addr);",
          "878:         void CleanupForClose();",
          "879:         void BeginDynamicFunctionReferences();",
          "880:         void EndDynamicFunctionReferences();",
          "881:         void RegisterDynamicFunctionReference(FunctionProxy* func);",
          "883:         void SetDebugObjectNonUserAccessor(FunctionInfo *funcGetter, FunctionInfo *funcSetter);",
          "885:         JavascriptFunction* GetDebugObjectDebugModeGetterFunction() const { return debugObjectDebugModeGetterFunction; }",
          "886:         void SetDebugObjectDebugModeAccessor(FunctionInfo *funcGetter);",
          "888: #ifdef ENABLE_DEBUG_CONFIG_OPTIONS",
          "889:         JavascriptFunction* GetDebugObjectFaultInjectionCookieGetterFunction() const { return debugObjectFaultInjectionCookieGetterFunction; }",
          "890:         JavascriptFunction* GetDebugObjectFaultInjectionCookieSetterFunction() const { return debugObjectFaultInjectionCookieSetterFunction; }",
          "891:         void SetDebugObjectFaultInjectionCookieGetterAccessor(FunctionInfo *funcGetter, FunctionInfo *funcSetter);",
          "892: #endif",
          "894:         JavascriptFunction* GetArrayPrototypeToStringFunction() const { return arrayPrototypeToStringFunction; }",
          "895:         JavascriptFunction* GetArrayPrototypeToLocaleStringFunction() const { return arrayPrototypeToLocaleStringFunction; }",
          "896:         JavascriptFunction* GetIdentityFunction() const { return identityFunction; }",
          "897:         JavascriptFunction* GetThrowerFunction() const { return throwerFunction; }",
          "899:         void SetNativeHostPromiseContinuationFunction(PromiseContinuationCallback function, void *state);",
          "901:         void SetJsrtContext(FinalizableObject* jsrtContext);",
          "902:         FinalizableObject* GetJsrtContext();",
          "903:         void EnqueueTask(Var taskVar);",
          "905:         HeapArgumentsObject* CreateHeapArguments(Var frameObj, uint formalCount, bool isStrictMode = false);",
          "906:         JavascriptArray* CreateArray();",
          "907:         JavascriptArray* CreateArray(uint32 length);",
          "908:         JavascriptArray *CreateArrayOnStack(void *const stackAllocationPointer);",
          "909:         JavascriptNativeIntArray* CreateNativeIntArray();",
          "910:         JavascriptNativeIntArray* CreateNativeIntArray(uint32 length);",
          "911: #if ENABLE_COPYONACCESS_ARRAY",
          "912:         JavascriptCopyOnAccessNativeIntArray* CreateCopyOnAccessNativeIntArray();",
          "913:         JavascriptCopyOnAccessNativeIntArray* CreateCopyOnAccessNativeIntArray(uint32 length);",
          "914: #endif",
          "915:         JavascriptNativeFloatArray* CreateNativeFloatArray();",
          "916:         JavascriptNativeFloatArray* CreateNativeFloatArray(uint32 length);",
          "917:         JavascriptArray* CreateArray(uint32 length, uint32 size);",
          "918:         ArrayBuffer* CreateArrayBuffer(uint32 length);",
          "919:         ArrayBuffer* CreateArrayBuffer(byte* buffer, uint32 length);",
          "920:         ArrayBuffer* CreateWebAssemblyArrayBuffer(uint32 length);",
          "921:         ArrayBuffer* CreateWebAssemblyArrayBuffer(byte* buffer, uint32 length);",
          "922:         SharedArrayBuffer* CreateSharedArrayBuffer(uint32 length);",
          "923:         SharedArrayBuffer* CreateSharedArrayBuffer(SharedContents *contents);",
          "924:         ArrayBuffer* CreateProjectionArraybuffer(uint32 length);",
          "925:         ArrayBuffer* CreateProjectionArraybuffer(byte* buffer, uint32 length);",
          "926:         DataView* CreateDataView(ArrayBufferBase* arrayBuffer, uint32 offSet, uint32 mappedLength);",
          "928:         template <typename TypeName, bool clamped>",
          "929:         inline DynamicType* GetTypedArrayType(TypeName);",
          "931:         template<> inline DynamicType* GetTypedArrayType<int8,false>(int8) { return int8ArrayType; };",
          "932:         template<> inline DynamicType* GetTypedArrayType<uint8,false>(uint8) { return uint8ArrayType; };",
          "933:         template<> inline DynamicType* GetTypedArrayType<uint8,true>(uint8) { return uint8ClampedArrayType; };",
          "934:         template<> inline DynamicType* GetTypedArrayType<int16,false>(int16) { return int16ArrayType; };",
          "935:         template<> inline DynamicType* GetTypedArrayType<uint16,false>(uint16) { return uint16ArrayType; };",
          "936:         template<> inline DynamicType* GetTypedArrayType<int32,false>(int32) { return int32ArrayType; };",
          "937:         template<> inline DynamicType* GetTypedArrayType<uint32,false>(uint32) { return uint32ArrayType; };",
          "938:         template<> inline DynamicType* GetTypedArrayType<float,false>(float) { return float32ArrayType; };",
          "939:         template<> inline DynamicType* GetTypedArrayType<double,false>(double) { return float64ArrayType; };",
          "940:         template<> inline DynamicType* GetTypedArrayType<int64,false>(int64) { return int64ArrayType; };",
          "941:         template<> inline DynamicType* GetTypedArrayType<uint64,false>(uint64) { return uint64ArrayType; };",
          "942:         template<> inline DynamicType* GetTypedArrayType<bool,false>(bool) { return boolArrayType; };",
          "944:         DynamicType* GetCharArrayType() { return charArrayType; };",
          "950:         JavascriptArray*            CreateArrayLiteral(uint32 length);",
          "951:         JavascriptNativeIntArray*   CreateNativeIntArrayLiteral(uint32 length);",
          "953: #if ENABLE_PROFILE_INFO",
          "954:         JavascriptNativeIntArray*   CreateCopyOnAccessNativeIntArrayLiteral(ArrayCallSiteInfo *arrayInfo, FunctionBody *functionBody, const Js::AuxArray<int32> *ints);",
          "955: #endif",
          "957:         JavascriptNativeFloatArray* CreateNativeFloatArrayLiteral(uint32 length);",
          "959:         JavascriptBoolean* CreateBoolean(BOOL value);",
          "960:         JavascriptDate* CreateDate();",
          "961:         JavascriptDate* CreateDate(double value);",
          "962:         JavascriptDate* CreateDate(SYSTEMTIME* pst);",
          "963:         JavascriptMap* CreateMap();",
          "964:         JavascriptSet* CreateSet();",
          "965:         JavascriptWeakMap* CreateWeakMap();",
          "966:         JavascriptWeakSet* CreateWeakSet();",
          "967:         JavascriptError* CreateError();",
          "968:         JavascriptError* CreateError(DynamicType* errorType, BOOL isExternal = FALSE);",
          "969:         JavascriptError* CreateExternalError(ErrorTypeEnum errorTypeEnum);",
          "970:         JavascriptError* CreateEvalError();",
          "971:         JavascriptError* CreateRangeError();",
          "972:         JavascriptError* CreateReferenceError();",
          "973:         JavascriptError* CreateSyntaxError();",
          "974:         JavascriptError* CreateTypeError();",
          "975:         JavascriptError* CreateURIError();",
          "976:         JavascriptError* CreateStackOverflowError();",
          "977:         JavascriptError* CreateOutOfMemoryError();",
          "978:         JavascriptError* CreateWebAssemblyCompileError();",
          "979:         JavascriptError* CreateWebAssemblyRuntimeError();",
          "980:         JavascriptError* CreateWebAssemblyLinkError();",
          "981:         JavascriptSymbol* CreateSymbol(JavascriptString* description);",
          "982:         JavascriptSymbol* CreateSymbol(const char16* description, int descriptionLength);",
          "983:         JavascriptSymbol* CreateSymbol(const PropertyRecord* propertyRecord);",
          "984:         JavascriptPromise* CreatePromise();",
          "985:         JavascriptGenerator* CreateGenerator(Arguments& args, ScriptFunction* scriptFunction, RecyclableObject* prototype);",
          "986:         JavascriptFunction* CreateNonProfiledFunction(FunctionInfo * functionInfo);",
          "987:         template <class MethodType>",
          "988:         JavascriptExternalFunction* CreateIdMappedExternalFunction(MethodType entryPoint, DynamicType *pPrototypeType);",
          "989:         JavascriptExternalFunction* CreateExternalConstructor(Js::ExternalMethod entryPoint, PropertyId nameId, RecyclableObject * prototype);",
          "990:         JavascriptExternalFunction* CreateExternalConstructor(Js::ExternalMethod entryPoint, PropertyId nameId, InitializeMethod method, unsigned short deferredTypeSlots, bool hasAccessors);",
          "991:         DynamicType* GetCachedJsrtExternalType(uintptr_t finalizeCallback);",
          "992:         void CacheJsrtExternalType(uintptr_t finalizeCallback, DynamicType* dynamicType);",
          "993:         static DynamicTypeHandler * GetDeferredPrototypeGeneratorFunctionTypeHandler(ScriptContext* scriptContext);",
          "994:         static DynamicTypeHandler * GetDeferredPrototypeAsyncFunctionTypeHandler(ScriptContext* scriptContext);",
          "995:         DynamicType * CreateDeferredPrototypeGeneratorFunctionType(JavascriptMethod entrypoint, bool isAnonymousFunction, bool isShared = false);",
          "996:         DynamicType * CreateDeferredPrototypeAsyncFunctionType(JavascriptMethod entrypoint, bool isAnonymousFunction, bool isShared = false);",
          "998:         static DynamicTypeHandler * GetDeferredPrototypeFunctionTypeHandler(ScriptContext* scriptContext);",
          "999:         static DynamicTypeHandler * GetDeferredAnonymousPrototypeFunctionTypeHandler();",
          "1000:         static DynamicTypeHandler * GetDeferredAnonymousPrototypeGeneratorFunctionTypeHandler();",
          "1001:         static DynamicTypeHandler * GetDeferredAnonymousPrototypeAsyncFunctionTypeHandler();",
          "1003:         DynamicTypeHandler * GetDeferredFunctionTypeHandler();",
          "1004:         DynamicTypeHandler * ScriptFunctionTypeHandler(bool noPrototypeProperty, bool isAnonymousFunction);",
          "1005:         DynamicTypeHandler * GetDeferredAnonymousFunctionTypeHandler();",
          "1006:         template<bool isNameAvailable, bool isPrototypeAvailable = true>",
          "1007:         static DynamicTypeHandler * GetDeferredFunctionTypeHandlerBase();",
          "1008:         template<bool isNameAvailable, bool isPrototypeAvailable = true>",
          "1009:         static DynamicTypeHandler * GetDeferredGeneratorFunctionTypeHandlerBase();",
          "1010:         template<bool isNameAvailable>",
          "1011:         static DynamicTypeHandler * GetDeferredAsyncFunctionTypeHandlerBase();",
          "1013:         DynamicType * CreateDeferredPrototypeFunctionType(JavascriptMethod entrypoint);",
          "1014:         DynamicType * CreateDeferredPrototypeFunctionTypeNoProfileThunk(JavascriptMethod entrypoint, bool isShared = false);",
          "1015:         DynamicType * CreateFunctionType(JavascriptMethod entrypoint, RecyclableObject* prototype = nullptr);",
          "1016:         DynamicType * CreateFunctionWithLengthType(FunctionInfo * functionInfo);",
          "1017:         DynamicType * CreateFunctionWithLengthAndNameType(FunctionInfo * functionInfo);",
          "1018:         DynamicType * CreateFunctionWithLengthAndPrototypeType(FunctionInfo * functionInfo);",
          "1019:         DynamicType * CreateFunctionWithLengthType(DynamicObject * prototype, FunctionInfo * functionInfo);",
          "1020:         DynamicType * CreateFunctionWithLengthAndNameType(DynamicObject * prototype, FunctionInfo * functionInfo);",
          "1021:         DynamicType * CreateFunctionWithLengthAndPrototypeType(DynamicObject * prototype, FunctionInfo * functionInfo);",
          "1022:         ScriptFunction * CreateScriptFunction(FunctionProxy* proxy);",
          "1023:         AsmJsScriptFunction * CreateAsmJsScriptFunction(FunctionProxy* proxy);",
          "1024:         ScriptFunctionWithInlineCache * CreateScriptFunctionWithInlineCache(FunctionProxy* proxy);",
          "1025:         GeneratorVirtualScriptFunction * CreateGeneratorVirtualScriptFunction(FunctionProxy* proxy);",
          "1026:         DynamicType * CreateGeneratorType(RecyclableObject* prototype);",
          "1028: #if 0",
          "1029:         JavascriptNumber* CreateNumber(double value);",
          "1030: #endif",
          "1031:         JavascriptNumber* CreateNumber(double value, RecyclerJavascriptNumberAllocator * numberAllocator);",
          "1032:         JavascriptGeneratorFunction* CreateGeneratorFunction(JavascriptMethod entryPoint, GeneratorVirtualScriptFunction* scriptFunction);",
          "1033:         JavascriptAsyncFunction* CreateAsyncFunction(JavascriptMethod entryPoint, GeneratorVirtualScriptFunction* scriptFunction);",
          "1034:         JavascriptExternalFunction* CreateExternalFunction(ExternalMethod entryPointer, PropertyId nameId, Var signature, JavascriptTypeId prototypeTypeId, UINT64 flags);",
          "1035:         JavascriptExternalFunction* CreateExternalFunction(ExternalMethod entryPointer, Var nameId, Var signature, JavascriptTypeId prototypeTypeId, UINT64 flags);",
          "1036:         JavascriptExternalFunction* CreateStdCallExternalFunction(StdCallJavascriptMethod entryPointer, PropertyId nameId, void *callbackState);",
          "1037:         JavascriptExternalFunction* CreateStdCallExternalFunction(StdCallJavascriptMethod entryPointer, Var nameId, void *callbackState);",
          "1038:         JavascriptPromiseAsyncSpawnExecutorFunction* CreatePromiseAsyncSpawnExecutorFunction(JavascriptMethod entryPoint, JavascriptGenerator* generator, Var target);",
          "1039:         JavascriptPromiseAsyncSpawnStepArgumentExecutorFunction* CreatePromiseAsyncSpawnStepArgumentExecutorFunction(JavascriptMethod entryPoint, JavascriptGenerator* generator, Var argument, JavascriptFunction* resolve = NULL, JavascriptFunction* reject = NULL, bool isReject = false);",
          "1040:         JavascriptPromiseCapabilitiesExecutorFunction* CreatePromiseCapabilitiesExecutorFunction(JavascriptMethod entryPoint, JavascriptPromiseCapability* capability);",
          "1041:         JavascriptPromiseResolveOrRejectFunction* CreatePromiseResolveOrRejectFunction(JavascriptMethod entryPoint, JavascriptPromise* promise, bool isReject, JavascriptPromiseResolveOrRejectFunctionAlreadyResolvedWrapper* alreadyResolvedRecord);",
          "1042:         JavascriptPromiseReactionTaskFunction* CreatePromiseReactionTaskFunction(JavascriptMethod entryPoint, JavascriptPromiseReaction* reaction, Var argument);",
          "1043:         JavascriptPromiseResolveThenableTaskFunction* CreatePromiseResolveThenableTaskFunction(JavascriptMethod entryPoint, JavascriptPromise* promise, RecyclableObject* thenable, RecyclableObject* thenFunction);",
          "1044:         JavascriptPromiseAllResolveElementFunction* CreatePromiseAllResolveElementFunction(JavascriptMethod entryPoint, uint32 index, JavascriptArray* values, JavascriptPromiseCapability* capabilities, JavascriptPromiseAllResolveElementFunctionRemainingElementsWrapper* remainingElements);",
          "1045:         JavascriptExternalFunction* CreateWrappedExternalFunction(JavascriptExternalFunction* wrappedFunction);",
          "1047: #if ENABLE_NATIVE_CODEGEN",
          "1048: #if !FLOATVAR",
          "1049:         JavascriptNumber* CreateCodeGenNumber(CodeGenNumberAllocator *alloc, double value);",
          "1050: #endif",
          "1051: #endif",
          "1053:         DynamicObject* CreateGeneratorConstructorPrototypeObject();",
          "1054:         DynamicObject* CreateConstructorPrototypeObject(JavascriptFunction * constructor);",
          "1055:         DynamicObject* CreateObject(const bool allowObjectHeaderInlining = false, const PropertyIndex requestedInlineSlotCapacity = 0);",
          "1056:         DynamicObject* CreateObject(DynamicTypeHandler * typeHandler);",
          "1057:         DynamicObject* CreateActivationObject();",
          "1058:         DynamicObject* CreatePseudoActivationObject();",
          "1059:         DynamicObject* CreateBlockActivationObject();",
          "1060:         DynamicObject* CreateConsoleScopeActivationObject();",
          "1061:         DynamicType* CreateObjectType(RecyclableObject* prototype, Js::TypeId typeId, uint16 requestedInlineSlotCapacity);",
          "1062:         DynamicType* CreateObjectTypeNoCache(RecyclableObject* prototype, Js::TypeId typeId);",
          "1063:         DynamicType* CreateObjectType(RecyclableObject* prototype, uint16 requestedInlineSlotCapacity);",
          "1064:         DynamicObject* CreateObject(RecyclableObject* prototype, uint16 requestedInlineSlotCapacity = 0);",
          "1066:         typedef JavascriptString* LibStringType; // used by diagnostics template",
          "1067:         template< size_t N > JavascriptString* CreateStringFromCppLiteral(const char16 (&value)[N]) const;",
          "1068:         template<> JavascriptString* CreateStringFromCppLiteral(const char16 (&value)[1]) const; // Specialization for empty string",
          "1069:         template<> JavascriptString* CreateStringFromCppLiteral(const char16 (&value)[2]) const; // Specialization for single-char strings",
          "1070:         PropertyString* CreatePropertyString(const Js::PropertyRecord* propertyRecord);",
          "1071:         PropertyString* CreatePropertyString(const Js::PropertyRecord* propertyRecord, ArenaAllocator *arena);",
          "1073:         JavascriptVariantDate* CreateVariantDate(const double value);",
          "1075:         JavascriptBooleanObject* CreateBooleanObject(BOOL value);",
          "1076:         JavascriptBooleanObject* CreateBooleanObject();",
          "1077:         JavascriptNumberObject* CreateNumberObjectWithCheck(double value);",
          "1078:         JavascriptNumberObject* CreateNumberObject(Var number);",
          "1079:         JavascriptSIMDObject* CreateSIMDObject(Var simdValue, TypeId typeDescriptor);",
          "1080:         JavascriptStringObject* CreateStringObject(JavascriptString* value);",
          "1081:         JavascriptStringObject* CreateStringObject(const char16* value, charcount_t length);",
          "1082:         JavascriptSymbolObject* CreateSymbolObject(JavascriptSymbol* value);",
          "1083:         JavascriptArrayIterator* CreateArrayIterator(Var iterable, JavascriptArrayIteratorKind kind);",
          "1084:         JavascriptMapIterator* CreateMapIterator(JavascriptMap* map, JavascriptMapIteratorKind kind);",
          "1085:         JavascriptSetIterator* CreateSetIterator(JavascriptSet* set, JavascriptSetIteratorKind kind);",
          "1086:         JavascriptStringIterator* CreateStringIterator(JavascriptString* string);",
          "1087:         JavascriptListIterator* CreateListIterator(ListForListIterator* list);",
          "1089:         JavascriptRegExp* CreateRegExp(UnifiedRegex::RegexPattern* pattern);",
          "1091:         DynamicObject* CreateIteratorResultObject(Var value, Var done);",
          "1092:         DynamicObject* CreateIteratorResultObjectValueFalse(Var value);",
          "1093:         DynamicObject* CreateIteratorResultObjectUndefinedTrue();",
          "1095:         RecyclableObject* CreateThrowErrorObject(JavascriptError* error);",
          "1097:         JavascriptFunction* EnsurePromiseResolveFunction();",
          "1098:         JavascriptFunction* EnsurePromiseThenFunction();",
          "1099:         JavascriptFunction* EnsureGeneratorNextFunction();",
          "1100:         JavascriptFunction* EnsureGeneratorThrowFunction();",
          "1101:         JavascriptFunction* EnsureJSONStringifyFunction();",
          "1102:         JavascriptFunction* EnsureObjectFreezeFunction();",
          "1104:         void SetCrossSiteForSharedFunctionType(JavascriptFunction * function);",
          "1106:         bool IsPRNGSeeded() { return isPRNGSeeded; }",
          "1107:         uint64 GetRandSeed0() { return randSeed0; }",
          "1108:         uint64 GetRandSeed1() { return randSeed1; }",
          "1109:         void SetIsPRNGSeeded(bool val);",
          "1110:         void SetRandSeed0(uint64 rs) { randSeed0 = rs;}",
          "1111:         void SetRandSeed1(uint64 rs) { randSeed1 = rs; }",
          "1113:         void SetProfileMode(bool fSet);",
          "1114:         void SetDispatchProfile(bool fSet, JavascriptMethod dispatchInvoke);",
          "1115:         HRESULT ProfilerRegisterBuiltIns();",
          "1117: #if ENABLE_COPYONACCESS_ARRAY",
          "1118:         static bool IsCopyOnAccessArrayCallSite(JavascriptLibrary *lib, ArrayCallSiteInfo *arrayInfo, uint32 length);",
          "1119:         static bool IsCachedCopyOnAccessArrayCallSite(const JavascriptLibrary *lib, ArrayCallSiteInfo *arrayInfo);",
          "1120:         template <typename T>",
          "1121:         static void CheckAndConvertCopyOnAccessNativeIntArray(const T instance);",
          "1122: #endif",
          "1124:         void EnsureStringTemplateCallsiteObjectList();",
          "1125:         void AddStringTemplateCallsiteObject(RecyclableObject* callsite);",
          "1126:         RecyclableObject* TryGetStringTemplateCallsiteObject(ParseNodePtr pnode);",
          "1127:         RecyclableObject* TryGetStringTemplateCallsiteObject(RecyclableObject* callsite);",
          "1129:         static void CheckAndInvalidateIsConcatSpreadableCache(PropertyId propertyId, ScriptContext *scriptContext);",
          "1131: #if DBG_DUMP",
          "1132:         static const char16* GetStringTemplateCallsiteObjectKey(Var callsite);",
          "1133: #endif",
          "1135:         Field(JavascriptFunction*)* GetBuiltinFunctions();",
          "1136:         INT_PTR* GetVTableAddresses();",
          "1137:         static BuiltinFunction GetBuiltinFunctionForPropId(PropertyId id);",
          "1138:         static BuiltinFunction GetBuiltInForFuncInfo(intptr_t funcInfoAddr, ThreadContextInfo *context);",
          "1139: #if DBG",
          "1140:         static void CheckRegisteredBuiltIns(Field(JavascriptFunction*)* builtInFuncs, ScriptContext *scriptContext);",
          "1141: #endif",
          "1142:         static BOOL CanFloatPreferenceFunc(BuiltinFunction index);",
          "1143:         static BOOL IsFltFunc(BuiltinFunction index);",
          "1144:         static bool IsFloatFunctionCallsite(BuiltinFunction index, size_t argc);",
          "1145:         static bool IsFltBuiltInConst(PropertyId id);",
          "1146:         static size_t GetArgCForBuiltIn(BuiltinFunction index)",
          "1147:         {",
          "1148:             Assert(index < _countof(JavascriptLibrary::LibraryFunctionArgC));",
          "1149:             return JavascriptLibrary::LibraryFunctionArgC[index];",
          "1150:         }",
          "1151:         static BuiltInFlags GetFlagsForBuiltIn(BuiltinFunction index)",
          "1152:         {",
          "1153:             Assert(index < _countof(JavascriptLibrary::LibraryFunctionFlags));",
          "1154:             return (BuiltInFlags)JavascriptLibrary::LibraryFunctionFlags[index];",
          "1155:         }",
          "1156:         static BuiltinFunction GetBuiltInInlineCandidateId(Js::OpCode opCode);",
          "1157:         static BuiltInArgSpecializationType GetBuiltInArgType(BuiltInFlags flags, BuiltInArgShift argGroup);",
          "1158:         static bool IsTypeSpecRequired(BuiltInFlags flags)",
          "1159:         {",
          "1160:             return GetBuiltInArgType(flags, BuiltInArgShift::BIAS_Src1) || GetBuiltInArgType(flags, BuiltInArgShift::BIAS_Src2) || GetBuiltInArgType(flags, BuiltInArgShift::BIAS_Dst);",
          "1161:         }",
          "1162: #if ENABLE_DEBUG_CONFIG_OPTIONS",
          "1163:         static char16 const * GetNameForBuiltIn(BuiltinFunction index)",
          "1164:         {",
          "1165:             Assert(index < _countof(JavascriptLibrary::LibraryFunctionName));",
          "1166:             return JavascriptLibrary::LibraryFunctionName[index];",
          "1167:         }",
          "1168: #endif",
          "1170:         PropertyStringCacheMap* EnsurePropertyStringMap();",
          "1171:         PropertyStringCacheMap* GetPropertyStringMap() { return this->propertyStringMap; }",
          "1173:         void TypeAndPrototypesAreEnsuredToHaveOnlyWritableDataProperties(Type *const type);",
          "1174:         void NoPrototypeChainsAreEnsuredToHaveOnlyWritableDataProperties();",
          "1176:         static bool ArrayIteratorPrototypeHasUserDefinedNext(ScriptContext *scriptContext);",
          "1178:         CharStringCache& GetCharStringCache() { return charStringCache;  }",
          "1179:         static JavascriptLibrary * FromCharStringCache(CharStringCache * cache)",
          "1180:         {",
          "1181:             return (JavascriptLibrary *)((uintptr_t)cache - offsetof(JavascriptLibrary, charStringCache));",
          "1182:         }",
          "1184:         bool GetArrayObjectHasUserDefinedSpecies() const { return arrayObjectHasUserDefinedSpecies; }",
          "1185:         void SetArrayObjectHasUserDefinedSpecies(bool val) { arrayObjectHasUserDefinedSpecies = val; }",
          "1187:         FunctionBody* GetFakeGlobalFuncForUndefer()const { return this->fakeGlobalFuncForUndefer; }",
          "1188:         void SetFakeGlobalFuncForUndefer(FunctionBody* functionBody) { this->fakeGlobalFuncForUndefer = functionBody; }",
          "1190:         ModuleRecordList* EnsureModuleRecordList();",
          "1191:         SourceTextModuleRecord* GetModuleRecord(uint moduleId);",
          "1193:     private:",
          "1194: #ifdef ENABLE_DEBUG_CONFIG_OPTIONS",
          "1198:         Field(DynamicType *) debugDisposableObjectType;",
          "1199:         Field(DynamicType *) debugFuncExecutorInDisposeObjectType;",
          "1200: #endif",
          "1202:         void InitializePrototypes();",
          "1203:         void InitializeTypes();",
          "1204:         void InitializeGlobal(GlobalObject * globalObject);",
          "1205:         static void PrecalculateArrayAllocationBuckets();",
          "1207: #define STANDARD_INIT(name) \\",
          "1208:         static void __cdecl Initialize##name##Constructor(DynamicObject* arrayConstructor, DeferredTypeHandlerBase * typeHandler, DeferredInitializeMode mode); \\",
          "1209:         static void __cdecl Initialize##name##Prototype(DynamicObject* arrayPrototype, DeferredTypeHandlerBase * typeHandler, DeferredInitializeMode mode);",
          "1211:         STANDARD_INIT(Array);",
          "1212:         STANDARD_INIT(SharedArrayBuffer);",
          "1213:         STANDARD_INIT(ArrayBuffer);",
          "1214:         STANDARD_INIT(DataView);",
          "1215:         STANDARD_INIT(Error);",
          "1216:         STANDARD_INIT(EvalError);",
          "1217:         STANDARD_INIT(RangeError);",
          "1218:         STANDARD_INIT(ReferenceError);",
          "1219:         STANDARD_INIT(SyntaxError);",
          "1220:         STANDARD_INIT(TypeError);",
          "1221:         STANDARD_INIT(URIError);",
          "1222:         STANDARD_INIT(RuntimeError);",
          "1223:         STANDARD_INIT(TypedArray);",
          "1224:         STANDARD_INIT(Int8Array);",
          "1225:         STANDARD_INIT(Uint8Array);",
          "1226:         STANDARD_INIT(Uint8ClampedArray);",
          "1227:         STANDARD_INIT(Int16Array);",
          "1228:         STANDARD_INIT(Uint16Array);",
          "1229:         STANDARD_INIT(Int32Array);",
          "1230:         STANDARD_INIT(Uint32Array);",
          "1231:         STANDARD_INIT(Float32Array);",
          "1232:         STANDARD_INIT(Float64Array);",
          "1233:         STANDARD_INIT(Boolean);",
          "1234:         STANDARD_INIT(Symbol);",
          "1235:         STANDARD_INIT(Date);",
          "1236:         STANDARD_INIT(Proxy);",
          "1237:         STANDARD_INIT(Function);",
          "1238:         STANDARD_INIT(Number);",
          "1239:         STANDARD_INIT(Object);",
          "1240:         STANDARD_INIT(Regex);",
          "1241:         STANDARD_INIT(String);",
          "1242:         STANDARD_INIT(Map);",
          "1243:         STANDARD_INIT(Set);",
          "1244:         STANDARD_INIT(WeakMap);",
          "1245:         STANDARD_INIT(WeakSet);",
          "1246:         STANDARD_INIT(Promise);",
          "1247:         STANDARD_INIT(GeneratorFunction);",
          "1248:         STANDARD_INIT(AsyncFunction);",
          "1249:         STANDARD_INIT(WebAssemblyCompileError);",
          "1250:         STANDARD_INIT(WebAssemblyRuntimeError);",
          "1251:         STANDARD_INIT(WebAssemblyLinkError);",
          "1252:         STANDARD_INIT(WebAssemblyMemory);",
          "1253:         STANDARD_INIT(WebAssemblyModule);",
          "1254:         STANDARD_INIT(WebAssemblyInstance);",
          "1255:         STANDARD_INIT(WebAssemblyTable);",
          "1257: #undef STANDARD_INIT",
          "1259:         static void __cdecl InitializeAtomicsObject(DynamicObject* atomicsObject, DeferredTypeHandlerBase * typeHandler, DeferredInitializeMode mode);",
          "1261:         static void __cdecl InitializeInt64ArrayPrototype(DynamicObject* prototype, DeferredTypeHandlerBase * typeHandler, DeferredInitializeMode mode);",
          "1262:         static void __cdecl InitializeUint64ArrayPrototype(DynamicObject* prototype, DeferredTypeHandlerBase * typeHandler, DeferredInitializeMode mode);",
          "1263:         static void __cdecl InitializeBoolArrayPrototype(DynamicObject* prototype, DeferredTypeHandlerBase * typeHandler, DeferredInitializeMode mode);",
          "1264:         static void __cdecl InitializeCharArrayPrototype(DynamicObject* prototype, DeferredTypeHandlerBase * typeHandler, DeferredInitializeMode mode);",
          "1266:         void InitializeComplexThings();",
          "1267:         void InitializeStaticValues();",
          "1268:         static void __cdecl InitializeMathObject(DynamicObject* mathObject, DeferredTypeHandlerBase * typeHandler, DeferredInitializeMode mode);",
          "1269: #ifdef ENABLE_WASM",
          "1270:         static void __cdecl InitializeWebAssemblyObject(DynamicObject* WasmObject, DeferredTypeHandlerBase * typeHandler, DeferredInitializeMode mode);",
          "1271: #endif",
          "1273:         static void __cdecl InitializeSIMDObject(DynamicObject* simdObject, DeferredTypeHandlerBase * typeHandler, DeferredInitializeMode mode);",
          "1274:         static void __cdecl InitializeSIMDOpCodeMaps();",
          "1276:         template<typename SIMDTypeName>",
          "1277:         static void SIMDPrototypeInitHelper(DynamicObject* simdPrototype, JavascriptLibrary* library, JavascriptFunction* constructorFn, JavascriptString* strLiteral);",
          "1279:         static void __cdecl InitializeSIMDBool8x16Prototype(DynamicObject* simdPrototype, DeferredTypeHandlerBase * typeHandler, DeferredInitializeMode mode);",
          "1280:         static void __cdecl InitializeSIMDBool16x8Prototype(DynamicObject* simdPrototype, DeferredTypeHandlerBase * typeHandler, DeferredInitializeMode mode);",
          "1281:         static void __cdecl InitializeSIMDBool32x4Prototype(DynamicObject* simdPrototype, DeferredTypeHandlerBase * typeHandler, DeferredInitializeMode mode);",
          "1282:         static void __cdecl InitializeSIMDInt8x16Prototype(DynamicObject* simdPrototype, DeferredTypeHandlerBase * typeHandler, DeferredInitializeMode mode);",
          "1283:         static void __cdecl InitializeSIMDInt16x8Prototype(DynamicObject* simdPrototype, DeferredTypeHandlerBase * typeHandler, DeferredInitializeMode mode);",
          "1284:         static void __cdecl InitializeSIMDInt32x4Prototype(DynamicObject* simdPrototype, DeferredTypeHandlerBase * typeHandler, DeferredInitializeMode mode);",
          "1285:         static void __cdecl InitializeSIMDUint8x16Prototype(DynamicObject* simdPrototype, DeferredTypeHandlerBase * typeHandler, DeferredInitializeMode mode);",
          "1286:         static void __cdecl InitializeSIMDUint16x8Prototype(DynamicObject* simdPrototype, DeferredTypeHandlerBase * typeHandler, DeferredInitializeMode mode);",
          "1287:         static void __cdecl InitializeSIMDUint32x4Prototype(DynamicObject* simdPrototype, DeferredTypeHandlerBase * typeHandler, DeferredInitializeMode mode);",
          "1288:         static void __cdecl InitializeSIMDFloat32x4Prototype(DynamicObject* simdPrototype, DeferredTypeHandlerBase * typeHandler, DeferredInitializeMode mode);",
          "1289:         static void __cdecl InitializeSIMDFloat64x2Prototype(DynamicObject* simdPrototype, DeferredTypeHandlerBase * typeHandler, DeferredInitializeMode mode);",
          "1291:         static void __cdecl InitializeJSONObject(DynamicObject* JSONObject, DeferredTypeHandlerBase * typeHandler, DeferredInitializeMode mode);",
          "1292:         static void __cdecl InitializeEngineInterfaceObject(DynamicObject* engineInterface, DeferredTypeHandlerBase * typeHandler, DeferredInitializeMode mode);",
          "1293:         static void __cdecl InitializeReflectObject(DynamicObject* reflectObject, DeferredTypeHandlerBase * typeHandler, DeferredInitializeMode mode);",
          "1294: #ifdef ENABLE_INTL_OBJECT",
          "1295:         static void __cdecl InitializeIntlObject(DynamicObject* IntlEngineObject, DeferredTypeHandlerBase * typeHandler, DeferredInitializeMode mode);",
          "1296: #endif",
          "1297: #ifdef ENABLE_PROJECTION",
          "1298:         void InitializeWinRTPromiseConstructor();",
          "1299: #endif",
          "1301:         static void __cdecl InitializeIteratorPrototype(DynamicObject* iteratorPrototype, DeferredTypeHandlerBase * typeHandler, DeferredInitializeMode mode);",
          "1302:         static void __cdecl InitializeArrayIteratorPrototype(DynamicObject* arrayIteratorPrototype, DeferredTypeHandlerBase * typeHandler, DeferredInitializeMode mode);",
          "1303:         static void __cdecl InitializeMapIteratorPrototype(DynamicObject* mapIteratorPrototype, DeferredTypeHandlerBase * typeHandler, DeferredInitializeMode mode);",
          "1304:         static void __cdecl InitializeSetIteratorPrototype(DynamicObject* setIteratorPrototype, DeferredTypeHandlerBase * typeHandler, DeferredInitializeMode mode);",
          "1305:         static void __cdecl InitializeStringIteratorPrototype(DynamicObject* stringIteratorPrototype, DeferredTypeHandlerBase * typeHandler, DeferredInitializeMode mode);",
          "1307:         static void __cdecl InitializeGeneratorPrototype(DynamicObject* generatorPrototype, DeferredTypeHandlerBase * typeHandler, DeferredInitializeMode mode);",
          "1309:         static void __cdecl InitializeAsyncFunction(DynamicObject *function, DeferredTypeHandlerBase * typeHandler, DeferredInitializeMode mode);",
          "1311:         RuntimeFunction* CreateBuiltinConstructor(FunctionInfo * functionInfo, DynamicTypeHandler * typeHandler, DynamicObject* prototype = nullptr);",
          "1312:         RuntimeFunction* DefaultCreateFunction(FunctionInfo * functionInfo, int length, DynamicObject * prototype, DynamicType * functionType, PropertyId nameId);",
          "1313:         RuntimeFunction* DefaultCreateFunction(FunctionInfo * functionInfo, int length, DynamicObject * prototype, DynamicType * functionType, Var nameId);",
          "1314:         JavascriptFunction* AddFunction(DynamicObject* object, PropertyId propertyId, RuntimeFunction* function);",
          "1315:         void AddMember(DynamicObject* object, PropertyId propertyId, Var value);",
          "1316:         void AddMember(DynamicObject* object, PropertyId propertyId, Var value, PropertyAttributes attributes);",
          "1317:         JavascriptString* CreateEmptyString();",
          "1320:         static void __cdecl InitializeGeneratorFunction(DynamicObject* function, DeferredTypeHandlerBase * typeHandler, DeferredInitializeMode mode);",
          "1321:         template<bool addPrototype>",
          "1322:         static void __cdecl InitializeFunction(DynamicObject* function, DeferredTypeHandlerBase * typeHandler, DeferredInitializeMode mode);",
          "1324:         static size_t const LibraryFunctionArgC[BuiltinFunction::Count + 1];",
          "1325:         static int const LibraryFunctionFlags[BuiltinFunction::Count + 1];   // returns enum BuiltInFlags.",
          "1326: #if ENABLE_DEBUG_CONFIG_OPTIONS",
          "1327:         static char16 const * const LibraryFunctionName[BuiltinFunction::Count + 1];",
          "1328: #endif",
          "1330:         JavascriptFunction* EnsureArrayPrototypeValuesFunction();",
          "1333:     public:",
          "1334:         virtual void Finalize(bool isShutdown) override;",
          "1336: #if DBG",
          "1337:         void DumpLibraryByteCode();",
          "1338: #endif",
          "1339:     private:",
          "1340:         typedef JsUtil::BaseHashSet<Js::PropertyRecord const *, Recycler, PowerOf2SizePolicy> ReferencedPropertyRecordHashSet;",
          "1341:         Field(ReferencedPropertyRecordHashSet*) referencedPropertyRecords;",
          "1343:         ReferencedPropertyRecordHashSet * EnsureReferencedPropertyRecordList()",
          "1344:         {",
          "1345:             ReferencedPropertyRecordHashSet* pidList = this->referencedPropertyRecords;",
          "1346:             if (pidList == nullptr)",
          "1347:             {",
          "1348:                 pidList = RecyclerNew(this->recycler, ReferencedPropertyRecordHashSet, this->recycler, 173);",
          "1349:                 this->referencedPropertyRecords = pidList;",
          "1350:             }",
          "1351:             return pidList;",
          "1352:         }",
          "1354:         ReferencedPropertyRecordHashSet * GetReferencedPropertyRecordList() const",
          "1355:         {",
          "1356:             return this->referencedPropertyRecords;",
          "1357:         }",
          "1359:         HRESULT ProfilerRegisterObject();",
          "1360:         HRESULT ProfilerRegisterArray();",
          "1361:         HRESULT ProfilerRegisterBoolean();",
          "1362:         HRESULT ProfilerRegisterDate();",
          "1363:         HRESULT ProfilerRegisterFunction();",
          "1364:         HRESULT ProfilerRegisterMath();",
          "1365:         HRESULT ProfilerRegisterNumber();",
          "1366:         HRESULT ProfilerRegisterString();",
          "1367:         HRESULT ProfilerRegisterRegExp();",
          "1368:         HRESULT ProfilerRegisterJSON();",
          "1369:         HRESULT ProfilerRegisterMap();",
          "1370:         HRESULT ProfilerRegisterSet();",
          "1371:         HRESULT ProfilerRegisterWeakMap();",
          "1372:         HRESULT ProfilerRegisterWeakSet();",
          "1373:         HRESULT ProfilerRegisterSymbol();",
          "1374:         HRESULT ProfilerRegisterIterator();",
          "1375:         HRESULT ProfilerRegisterArrayIterator();",
          "1376:         HRESULT ProfilerRegisterMapIterator();",
          "1377:         HRESULT ProfilerRegisterSetIterator();",
          "1378:         HRESULT ProfilerRegisterStringIterator();",
          "1379:         HRESULT ProfilerRegisterTypedArray();",
          "1380:         HRESULT ProfilerRegisterPromise();",
          "1381:         HRESULT ProfilerRegisterProxy();",
          "1382:         HRESULT ProfilerRegisterReflect();",
          "1383:         HRESULT ProfilerRegisterGenerator();",
          "1384:         HRESULT ProfilerRegisterSIMD();",
          "1385:         HRESULT ProfilerRegisterAtomics();",
          "1387: #ifdef IR_VIEWER",
          "1388:         HRESULT ProfilerRegisterIRViewer();",
          "1390:     };",
          "1391: }",
          "",
          "[Added Lines]",
          "5: #pragma once",
          "7: #define InlineSlotCountIncrement (HeapConstants::ObjectGranularity / sizeof(Var))",
          "9: #define MaxPreInitializedObjectTypeInlineSlotCount 16",
          "10: #define MaxPreInitializedObjectHeaderInlinedTypeInlineSlotCount \\",
          "11:     (Js::DynamicTypeHandler::GetObjectHeaderInlinableSlotCapacity() + MaxPreInitializedObjectTypeInlineSlotCount)",
          "12: #define PreInitializedObjectTypeCount ((MaxPreInitializedObjectTypeInlineSlotCount / InlineSlotCountIncrement) + 1)",
          "13: CompileAssert(MaxPreInitializedObjectTypeInlineSlotCount <= USHRT_MAX);",
          "15: class ScriptSite;",
          "16: class ActiveScriptExternalLibrary;",
          "17: class ProjectionExternalLibrary;",
          "18: class EditAndContinue;",
          "19: class ChakraHostScriptContext;",
          "21: #ifdef ENABLE_PROJECTION",
          "22: namespace Projection",
          "23: {",
          "24:     class ProjectionContext;",
          "25:     class WinRTPromiseEngineInterfaceExtensionObject;",
          "26: }",
          "27: #endif",
          "29: namespace Js",
          "30: {",
          "31:     static const unsigned int EvalMRUSize = 15;",
          "32:     typedef JsUtil::BaseDictionary<DWORD_PTR, SourceContextInfo *, Recycler, PowerOf2SizePolicy> SourceContextInfoMap;",
          "33:     typedef JsUtil::BaseDictionary<uint, SourceContextInfo *, Recycler, PowerOf2SizePolicy> DynamicSourceContextInfoMap;",
          "35:     typedef JsUtil::BaseDictionary<EvalMapString, ScriptFunction*, RecyclerNonLeafAllocator, PrimeSizePolicy> SecondLevelEvalCache;",
          "36:     typedef TwoLevelHashRecord<FastEvalMapString, ScriptFunction*, SecondLevelEvalCache, EvalMapString> EvalMapRecord;",
          "37:     typedef JsUtil::Cache<FastEvalMapString, EvalMapRecord*, RecyclerNonLeafAllocator, PrimeSizePolicy, JsUtil::MRURetentionPolicy<FastEvalMapString, EvalMRUSize>, FastEvalMapStringComparer> EvalCacheTopLevelDictionary;",
          "38:     typedef JsUtil::Cache<EvalMapString, FunctionInfo*, RecyclerNonLeafAllocator, PrimeSizePolicy, JsUtil::MRURetentionPolicy<EvalMapString, EvalMRUSize>> NewFunctionCache;",
          "39:     typedef JsUtil::BaseDictionary<ParseableFunctionInfo*, ParseableFunctionInfo*, Recycler, PrimeSizePolicy, RecyclerPointerComparer> ParseableFunctionInfoMap;",
          "41:     typedef TwoLevelHashDictionary<FastEvalMapString, ScriptFunction*, EvalMapRecord, EvalCacheTopLevelDictionary, EvalMapString> EvalCacheDictionary;",
          "43:     typedef JsUtil::BaseDictionary<JavascriptMethod, JavascriptFunction*, Recycler, PowerOf2SizePolicy> BuiltInLibraryFunctionMap;",
          "46:     struct EnumeratedObjectCache",
          "47:     {",
          "48:         static const int kMaxCachedPropStrings = 16;",
          "49:         Field(DynamicObject*) object;",
          "50:         Field(DynamicType*) type;",
          "51:         Field(PropertyString*) propertyStrings[kMaxCachedPropStrings];",
          "52:         Field(int) validPropStrings;",
          "53:     };",
          "55:     struct Cache",
          "56:     {",
          "57:         Field(JavascriptString *) lastNumberToStringRadix10String;",
          "58:         Field(EnumeratedObjectCache) enumObjCache;",
          "59:         Field(JavascriptString *) lastUtcTimeFromStrString;",
          "60:         Field(EvalCacheDictionary*) evalCacheDictionary;",
          "61:         Field(EvalCacheDictionary*) indirectEvalCacheDictionary;",
          "62:         Field(NewFunctionCache*) newFunctionCache;",
          "63:         Field(RegexPatternMruMap *) dynamicRegexMap;",
          "64:         Field(SourceContextInfoMap*) sourceContextInfoMap;   // maps host provided context cookie to the URL of the script buffer passed.",
          "65:         Field(DynamicSourceContextInfoMap*) dynamicSourceContextInfoMap;",
          "66:         Field(SourceContextInfo*) noContextSourceContextInfo;",
          "67:         Field(SRCINFO*) noContextGlobalSourceInfo;",
          "68:         Field(Field(SRCINFO const *)*) moduleSrcInfo;",
          "69:         Field(BuiltInLibraryFunctionMap*) builtInLibraryFunctions;",
          "70: #if ENABLE_PROFILE_INFO",
          "71: #if DBG_DUMP || defined(DYNAMIC_PROFILE_STORAGE) || defined(RUNTIME_DATA_COLLECTION)",
          "72:         Field(DynamicProfileInfoList*) profileInfoList;",
          "73: #endif",
          "74: #endif",
          "75:     };",
          "77:     class MissingPropertyTypeHandler;",
          "78:     class SourceTextModuleRecord;",
          "79:     class ArrayBufferBase;",
          "80:     class SharedContents;",
          "81:     typedef RecyclerFastAllocator<JavascriptNumber, LeafBit> RecyclerJavascriptNumberAllocator;",
          "82:     typedef JsUtil::List<Var, Recycler> ListForListIterator;",
          "84:     class UndeclaredBlockVariable : public RecyclableObject",
          "85:     {",
          "86:         friend class JavascriptLibrary;",
          "87:         UndeclaredBlockVariable(Type* type) : RecyclableObject(type) { }",
          "88:     };",
          "90:     class SourceTextModuleRecord;",
          "91:     typedef JsUtil::List<SourceTextModuleRecord*> ModuleRecordList;",
          "93: #if ENABLE_COPYONACCESS_ARRAY",
          "94:     struct CacheForCopyOnAccessArraySegments",
          "95:     {",
          "96:         static const uint32 MAX_SIZE = 31;",
          "97:         Field(SparseArraySegment<int32> *) cache[MAX_SIZE];",
          "98:         Field(uint32) count;",
          "100:         uint32 AddSegment(SparseArraySegment<int32> *segment)",
          "101:         {",
          "102:             cache[count++] = segment;",
          "103:             return count;",
          "104:         }",
          "106:         SparseArraySegment<int32> *GetSegmentByIndex(byte index)",
          "107:         {",
          "108:             Assert(index <= MAX_SIZE);",
          "109:             return cache[index - 1];",
          "110:         }",
          "112:         bool IsNotOverHardLimit()",
          "113:         {",
          "114:             return count < MAX_SIZE;",
          "115:         }",
          "117:         bool IsNotFull()",
          "118:         {",
          "119:             return count < (uint32) CONFIG_FLAG(CopyOnAccessArraySegmentCacheSize);",
          "120:         }",
          "122:         bool IsValidIndex(uint32 index)",
          "123:         {",
          "124:             return count && index && index <= count;",
          "125:         }",
          "127: #if ENABLE_DEBUG_CONFIG_OPTIONS",
          "128:         uint32 GetCount()",
          "129:         {",
          "130:             return count;",
          "131:         }",
          "132: #endif",
          "133:     };",
          "134: #endif",
          "136:     template <typename T>",
          "137:     struct StringTemplateCallsiteObjectComparer",
          "138:     {",
          "139:         static bool Equals(T x, T y)",
          "140:         {",
          "141:             static_assert(false, \"Unexpected type T\");",
          "142:         }",
          "143:         static hash_t GetHashCode(T i)",
          "144:         {",
          "145:             static_assert(false, \"Unexpected type T\");",
          "146:         }",
          "147:     };",
          "149:     template <>",
          "150:     struct StringTemplateCallsiteObjectComparer<ParseNodePtr>",
          "151:     {",
          "152:         static bool Equals(ParseNodePtr x, RecyclerWeakReference<Js::RecyclableObject>* y);",
          "153:         static bool Equals(ParseNodePtr x, ParseNodePtr y);",
          "154:         static hash_t GetHashCode(ParseNodePtr i);",
          "155:     };",
          "157:     template <>",
          "158:     struct StringTemplateCallsiteObjectComparer<RecyclerWeakReference<Js::RecyclableObject>*>",
          "159:     {",
          "160:         static bool Equals(RecyclerWeakReference<Js::RecyclableObject>* x, RecyclerWeakReference<Js::RecyclableObject>* y);",
          "161:         static bool Equals(RecyclerWeakReference<Js::RecyclableObject>* x, ParseNodePtr y);",
          "162:         static hash_t GetHashCode(RecyclerWeakReference<Js::RecyclableObject>* o);",
          "163:     };",
          "165:     class JavascriptLibrary : public JavascriptLibraryBase",
          "166:     {",
          "167:         friend class EditAndContinue;",
          "168:         friend class ScriptSite;",
          "169:         friend class GlobalObject;",
          "170:         friend class ScriptContext;",
          "171:         friend class EngineInterfaceObject;",
          "172:         friend class ExternalLibraryBase;",
          "173:         friend class ActiveScriptExternalLibrary;",
          "174:         friend class IntlEngineInterfaceExtensionObject;",
          "175:         friend class ChakraHostScriptContext;",
          "176: #ifdef ENABLE_PROJECTION",
          "177:         friend class ProjectionExternalLibrary;",
          "178:         friend class Projection::WinRTPromiseEngineInterfaceExtensionObject;",
          "179:         friend class Projection::ProjectionContext;",
          "180: #endif",
          "181:         static const char16* domBuiltinPropertyNames[];",
          "183:     public:",
          "184: #if ENABLE_COPYONACCESS_ARRAY",
          "185:         Field(CacheForCopyOnAccessArraySegments *) cacheForCopyOnAccessArraySegments;",
          "186: #endif",
          "188:         static DWORD GetScriptContextOffset() { return offsetof(JavascriptLibrary, scriptContext); }",
          "189:         static DWORD GetUndeclBlockVarOffset() { return offsetof(JavascriptLibrary, undeclBlockVarSentinel); }",
          "190:         static DWORD GetEmptyStringOffset() { return offsetof(JavascriptLibrary, emptyString); }",
          "191:         static DWORD GetUndefinedValueOffset() { return offsetof(JavascriptLibrary, undefinedValue); }",
          "192:         static DWORD GetNullValueOffset() { return offsetof(JavascriptLibrary, nullValue); }",
          "193:         static DWORD GetBooleanTrueOffset() { return offsetof(JavascriptLibrary, booleanTrue); }",
          "194:         static DWORD GetBooleanFalseOffset() { return offsetof(JavascriptLibrary, booleanFalse); }",
          "195:         static DWORD GetNegativeZeroOffset() { return offsetof(JavascriptLibrary, negativeZero); }",
          "196:         static DWORD GetNumberTypeStaticOffset() { return offsetof(JavascriptLibrary, numberTypeStatic); }",
          "197:         static DWORD GetStringTypeStaticOffset() { return offsetof(JavascriptLibrary, stringTypeStatic); }",
          "198:         static DWORD GetObjectTypesOffset() { return offsetof(JavascriptLibrary, objectTypes); }",
          "199:         static DWORD GetObjectHeaderInlinedTypesOffset() { return offsetof(JavascriptLibrary, objectHeaderInlinedTypes); }",
          "200:         static DWORD GetRegexTypeOffset() { return offsetof(JavascriptLibrary, regexType); }",
          "201:         static DWORD GetArrayConstructorOffset() { return offsetof(JavascriptLibrary, arrayConstructor); }",
          "202:         static DWORD GetPositiveInfinityOffset() { return offsetof(JavascriptLibrary, positiveInfinite); }",
          "203:         static DWORD GetNaNOffset() { return offsetof(JavascriptLibrary, nan); }",
          "204:         static DWORD GetNativeIntArrayTypeOffset() { return offsetof(JavascriptLibrary, nativeIntArrayType); }",
          "205: #if ENABLE_COPYONACCESS_ARRAY",
          "206:         static DWORD GetCopyOnAccessNativeIntArrayTypeOffset() { return offsetof(JavascriptLibrary, copyOnAccessNativeIntArrayType); }",
          "207: #endif",
          "208:         static DWORD GetNativeFloatArrayTypeOffset() { return offsetof(JavascriptLibrary, nativeFloatArrayType); }",
          "209:         static DWORD GetVTableAddressesOffset() { return offsetof(JavascriptLibrary, vtableAddresses); }",
          "210:         static DWORD GetConstructorCacheDefaultInstanceOffset() { return offsetof(JavascriptLibrary, constructorCacheDefaultInstance); }",
          "211:         static DWORD GetAbsDoubleCstOffset() { return offsetof(JavascriptLibrary, absDoubleCst); }",
          "212:         static DWORD GetUintConvertConstOffset() { return offsetof(JavascriptLibrary, uintConvertConst); }",
          "213:         static DWORD GetBuiltinFunctionsOffset() { return offsetof(JavascriptLibrary, builtinFunctions); }",
          "214:         static DWORD GetCharStringCacheOffset() { return offsetof(JavascriptLibrary, charStringCache); }",
          "215:         static DWORD GetCharStringCacheAOffset() { return GetCharStringCacheOffset() + CharStringCache::GetCharStringCacheAOffset(); }",
          "216:         const  JavascriptLibraryBase* GetLibraryBase() const { return static_cast<const JavascriptLibraryBase*>(this); }",
          "217:         void SetGlobalObject(GlobalObject* globalObject) {this->globalObject = globalObject; }",
          "218:         static DWORD GetRandSeed0Offset() { return offsetof(JavascriptLibrary, randSeed0); }",
          "219:         static DWORD GetRandSeed1Offset() { return offsetof(JavascriptLibrary, randSeed1); }",
          "220:         static DWORD GetTypeDisplayStringsOffset() { return offsetof(JavascriptLibrary, typeDisplayStrings); }",
          "221:         typedef bool (CALLBACK *PromiseContinuationCallback)(Var task, void *callbackState);",
          "223:         Var GetUndeclBlockVar() const { return undeclBlockVarSentinel; }",
          "224:         bool IsUndeclBlockVar(Var var) const { return var == undeclBlockVarSentinel; }",
          "226:         static bool IsTypedArrayConstructor(Var constructor, ScriptContext* scriptContext);",
          "228:     private:",
          "229:         FieldNoBarrier(Recycler *) recycler;",
          "230:         Field(ExternalLibraryBase*) externalLibraryList;",
          "232:         Field(UndeclaredBlockVariable*) undeclBlockVarSentinel;",
          "234:         Field(DynamicType *) generatorConstructorPrototypeObjectType;",
          "235:         Field(DynamicType *) constructorPrototypeObjectType;",
          "236:         Field(DynamicType *) heapArgumentsType;",
          "237:         Field(DynamicType *) activationObjectType;",
          "238:         Field(DynamicType *) arrayType;",
          "239:         Field(DynamicType *) nativeIntArrayType;",
          "240: #if ENABLE_COPYONACCESS_ARRAY",
          "241:         Field(DynamicType *) copyOnAccessNativeIntArrayType;",
          "242: #endif",
          "243:         Field(DynamicType *) nativeFloatArrayType;",
          "244:         Field(DynamicType *) arrayBufferType;",
          "245:         Field(DynamicType *) sharedArrayBufferType;",
          "246:         Field(DynamicType *) dataViewType;",
          "247:         Field(DynamicType *) typedArrayType;",
          "248:         Field(DynamicType *) int8ArrayType;",
          "249:         Field(DynamicType *) uint8ArrayType;",
          "250:         Field(DynamicType *) uint8ClampedArrayType;",
          "251:         Field(DynamicType *) int16ArrayType;",
          "252:         Field(DynamicType *) uint16ArrayType;",
          "253:         Field(DynamicType *) int32ArrayType;",
          "254:         Field(DynamicType *) uint32ArrayType;",
          "255:         Field(DynamicType *) float32ArrayType;",
          "256:         Field(DynamicType *) float64ArrayType;",
          "257:         Field(DynamicType *) int64ArrayType;",
          "258:         Field(DynamicType *) uint64ArrayType;",
          "259:         Field(DynamicType *) boolArrayType;",
          "260:         Field(DynamicType *) charArrayType;",
          "261:         Field(StaticType *) booleanTypeStatic;",
          "262:         Field(DynamicType *) booleanTypeDynamic;",
          "263:         Field(DynamicType *) dateType;",
          "264:         Field(StaticType *) variantDateType;",
          "265:         Field(DynamicType *) symbolTypeDynamic;",
          "266:         Field(StaticType *) symbolTypeStatic;",
          "267:         Field(DynamicType *) iteratorResultType;",
          "268:         Field(DynamicType *) arrayIteratorType;",
          "269:         Field(DynamicType *) mapIteratorType;",
          "270:         Field(DynamicType *) setIteratorType;",
          "271:         Field(DynamicType *) stringIteratorType;",
          "272:         Field(DynamicType *) promiseType;",
          "273:         Field(DynamicType *) listIteratorType;",
          "275:         Field(JavascriptFunction*) builtinFunctions[BuiltinFunction::Count];",
          "277:         Field(INT_PTR) vtableAddresses[VTableValue::Count];",
          "278:         Field(JavascriptString*) typeDisplayStrings[TypeIds_Limit];",
          "279:         Field(ConstructorCache *) constructorCacheDefaultInstance;",
          "280:         __declspec(align(16)) Field(const BYTE *) absDoubleCst;",
          "281:         Field(double const *) uintConvertConst;",
          "284:         Field(DynamicTypeHandler *) anonymousFunctionTypeHandler;",
          "285:         Field(DynamicTypeHandler *) anonymousFunctionWithPrototypeTypeHandler;",
          "286:         Field(DynamicTypeHandler *) functionTypeHandler;",
          "287:         Field(DynamicTypeHandler *) functionWithPrototypeTypeHandler;",
          "288:         Field(DynamicType *) externalFunctionWithDeferredPrototypeType;",
          "289:         Field(DynamicType *) wrappedFunctionWithDeferredPrototypeType;",
          "290:         Field(DynamicType *) stdCallFunctionWithDeferredPrototypeType;",
          "291:         Field(DynamicType *) idMappedFunctionWithPrototypeType;",
          "292:         Field(DynamicType *) externalConstructorFunctionWithDeferredPrototypeType;",
          "293:         Field(DynamicType *) defaultExternalConstructorFunctionWithDeferredPrototypeType;",
          "294:         Field(DynamicType *) boundFunctionType;",
          "295:         Field(DynamicType *) regexConstructorType;",
          "296:         Field(DynamicType *) crossSiteDeferredPrototypeFunctionType;",
          "297:         Field(DynamicType *) crossSiteIdMappedFunctionWithPrototypeType;",
          "298:         Field(DynamicType *) crossSiteExternalConstructFunctionWithPrototypeType;",
          "300:         Field(StaticType  *) enumeratorType;",
          "301:         Field(DynamicType *) errorType;",
          "302:         Field(DynamicType *) evalErrorType;",
          "303:         Field(DynamicType *) rangeErrorType;",
          "304:         Field(DynamicType *) referenceErrorType;",
          "305:         Field(DynamicType *) syntaxErrorType;",
          "306:         Field(DynamicType *) typeErrorType;",
          "307:         Field(DynamicType *) uriErrorType;",
          "308:         Field(DynamicType *) webAssemblyCompileErrorType;",
          "309:         Field(DynamicType *) webAssemblyRuntimeErrorType;",
          "310:         Field(DynamicType *) webAssemblyLinkErrorType;",
          "311:         Field(StaticType  *) numberTypeStatic;",
          "312:         Field(StaticType  *) int64NumberTypeStatic;",
          "313:         Field(StaticType  *) uint64NumberTypeStatic;",
          "315:         Field(DynamicType *) webAssemblyModuleType;",
          "316:         Field(DynamicType *) webAssemblyInstanceType;",
          "317:         Field(DynamicType *) webAssemblyMemoryType;",
          "318:         Field(DynamicType *) webAssemblyTableType;",
          "321:         Field(DynamicType *) simdBool8x16TypeDynamic;",
          "322:         Field(DynamicType *) simdBool16x8TypeDynamic;",
          "323:         Field(DynamicType *) simdBool32x4TypeDynamic;",
          "324:         Field(DynamicType *) simdInt8x16TypeDynamic;",
          "325:         Field(DynamicType *) simdInt16x8TypeDynamic;",
          "326:         Field(DynamicType *) simdInt32x4TypeDynamic;",
          "327:         Field(DynamicType *) simdUint8x16TypeDynamic;",
          "328:         Field(DynamicType *) simdUint16x8TypeDynamic;",
          "329:         Field(DynamicType *) simdUint32x4TypeDynamic;",
          "330:         Field(DynamicType *) simdFloat32x4TypeDynamic;",
          "332:         Field(StaticType *) simdFloat32x4TypeStatic;",
          "333:         Field(StaticType *) simdInt32x4TypeStatic;",
          "334:         Field(StaticType *) simdInt8x16TypeStatic;",
          "335:         Field(StaticType *) simdFloat64x2TypeStatic;",
          "336:         Field(StaticType *) simdInt16x8TypeStatic;",
          "337:         Field(StaticType *) simdBool32x4TypeStatic;",
          "338:         Field(StaticType *) simdBool16x8TypeStatic;",
          "339:         Field(StaticType *) simdBool8x16TypeStatic;",
          "340:         Field(StaticType *) simdUint32x4TypeStatic;",
          "341:         Field(StaticType *) simdUint16x8TypeStatic;",
          "342:         Field(StaticType *) simdUint8x16TypeStatic;",
          "344:         Field(DynamicType *) numberTypeDynamic;",
          "345:         Field(DynamicType *) objectTypes[PreInitializedObjectTypeCount];",
          "346:         Field(DynamicType *) objectHeaderInlinedTypes[PreInitializedObjectTypeCount];",
          "347:         Field(DynamicType *) regexPrototypeType;",
          "348:         Field(DynamicType *) regexType;",
          "349:         Field(DynamicType *) regexResultType;",
          "350:         Field(StaticType  *) stringTypeStatic;",
          "351:         Field(DynamicType *) stringTypeDynamic;",
          "352:         Field(DynamicType *) mapType;",
          "353:         Field(DynamicType *) setType;",
          "354:         Field(DynamicType *) weakMapType;",
          "355:         Field(DynamicType *) weakSetType;",
          "356:         Field(DynamicType *) proxyType;",
          "357:         Field(StaticType  *) withType;",
          "358:         Field(DynamicType *) SpreadArgumentType;",
          "359:         Field(DynamicType *) moduleNamespaceType;",
          "360:         Field(PropertyDescriptor) defaultPropertyDescriptor;",
          "362:         Field(JavascriptString*) nullString;",
          "363:         Field(JavascriptString*) emptyString;",
          "364:         Field(JavascriptString*) quotesString;",
          "365:         Field(JavascriptString*) whackString;",
          "366:         Field(JavascriptString*) objectDisplayString;",
          "367:         Field(JavascriptString*) stringTypeDisplayString;",
          "368:         Field(JavascriptString*) errorDisplayString;",
          "369:         Field(JavascriptString*) functionPrefixString;",
          "370:         Field(JavascriptString*) generatorFunctionPrefixString;",
          "371:         Field(JavascriptString*) asyncFunctionPrefixString;",
          "372:         Field(JavascriptString*) functionDisplayString;",
          "373:         Field(JavascriptString*) xDomainFunctionDisplayString;",
          "374:         Field(JavascriptString*) undefinedDisplayString;",
          "375:         Field(JavascriptString*) nanDisplayString;",
          "376:         Field(JavascriptString*) nullDisplayString;",
          "377:         Field(JavascriptString*) unknownDisplayString;",
          "378:         Field(JavascriptString*) commaDisplayString;",
          "379:         Field(JavascriptString*) commaSpaceDisplayString;",
          "380:         Field(JavascriptString*) trueDisplayString;",
          "381:         Field(JavascriptString*) falseDisplayString;",
          "382:         Field(JavascriptString*) lengthDisplayString;",
          "383:         Field(JavascriptString*) invalidDateString;",
          "384:         Field(JavascriptString*) objectTypeDisplayString;",
          "385:         Field(JavascriptString*) functionTypeDisplayString;",
          "386:         Field(JavascriptString*) booleanTypeDisplayString;",
          "387:         Field(JavascriptString*) numberTypeDisplayString;",
          "388:         Field(JavascriptString*) moduleTypeDisplayString;",
          "389:         Field(JavascriptString*) variantDateTypeDisplayString;",
          "392:         Field(JavascriptString*) simdFloat32x4DisplayString;",
          "393:         Field(JavascriptString*) simdFloat64x2DisplayString;",
          "394:         Field(JavascriptString*) simdInt32x4DisplayString;",
          "395:         Field(JavascriptString*) simdInt16x8DisplayString;",
          "396:         Field(JavascriptString*) simdInt8x16DisplayString;",
          "397:         Field(JavascriptString*) simdBool32x4DisplayString;",
          "398:         Field(JavascriptString*) simdBool16x8DisplayString;",
          "399:         Field(JavascriptString*) simdBool8x16DisplayString;",
          "400:         Field(JavascriptString*) simdUint32x4DisplayString;",
          "401:         Field(JavascriptString*) simdUint16x8DisplayString;",
          "402:         Field(JavascriptString*) simdUint8x16DisplayString;",
          "406:         Field(JavascriptString*) symbolTypeDisplayString;",
          "407:         Field(JavascriptString*) debuggerDeadZoneBlockVariableString;",
          "409:         Field(DynamicObject*) missingPropertyHolder;",
          "411:         Field(StaticType*) throwErrorObjectType;",
          "413:         Field(PropertyStringCacheMap*) propertyStringMap;",
          "415:         Field(ConstructorCache*) builtInConstructorCache;",
          "417: #ifdef ENABLE_DEBUG_CONFIG_OPTIONS",
          "418:         Field(JavascriptFunction*) debugObjectFaultInjectionCookieGetterFunction;",
          "419:         Field(JavascriptFunction*) debugObjectFaultInjectionCookieSetterFunction;",
          "420: #endif",
          "422:         Field(JavascriptFunction*) evalFunctionObject;",
          "423:         Field(JavascriptFunction*) arrayPrototypeValuesFunction;",
          "424:         Field(JavascriptFunction*) parseIntFunctionObject;",
          "425:         Field(JavascriptFunction*) parseFloatFunctionObject;",
          "426:         Field(JavascriptFunction*) arrayPrototypeToStringFunction;",
          "427:         Field(JavascriptFunction*) arrayPrototypeToLocaleStringFunction;",
          "428:         Field(JavascriptFunction*) identityFunction;",
          "429:         Field(JavascriptFunction*) throwerFunction;",
          "430:         Field(JavascriptFunction*) generatorNextFunction;",
          "431:         Field(JavascriptFunction*) generatorThrowFunction;",
          "433:         Field(JavascriptFunction*) objectValueOfFunction;",
          "434:         Field(JavascriptFunction*) objectToStringFunction;",
          "436: #ifdef ENABLE_WASM",
          "437:         Field(DynamicObject*) webAssemblyObject;",
          "438: #endif",
          "441:         Field(JavascriptFunction*) simdFloat32x4ToStringFunction;",
          "442:         Field(JavascriptFunction*) simdFloat64x2ToStringFunction;",
          "443:         Field(JavascriptFunction*) simdInt32x4ToStringFunction;",
          "444:         Field(JavascriptFunction*) simdInt16x8ToStringFunction;",
          "445:         Field(JavascriptFunction*) simdInt8x16ToStringFunction;",
          "446:         Field(JavascriptFunction*) simdBool32x4ToStringFunction;",
          "447:         Field(JavascriptFunction*) simdBool16x8ToStringFunction;",
          "448:         Field(JavascriptFunction*) simdBool8x16ToStringFunction;",
          "449:         Field(JavascriptFunction*) simdUint32x4ToStringFunction;",
          "450:         Field(JavascriptFunction*) simdUint16x8ToStringFunction;",
          "451:         Field(JavascriptFunction*) simdUint8x16ToStringFunction;",
          "455:         Field(JavascriptSymbol*) symbolMatch;",
          "456:         Field(JavascriptSymbol*) symbolReplace;",
          "457:         Field(JavascriptSymbol*) symbolSearch;",
          "458:         Field(JavascriptSymbol*) symbolSplit;",
          "460:         Field(UnifiedRegex::RegexPattern *) emptyRegexPattern;",
          "461:         Field(JavascriptFunction*) regexExecFunction;",
          "462:         Field(JavascriptFunction*) regexFlagsGetterFunction;",
          "463:         Field(JavascriptFunction*) regexGlobalGetterFunction;",
          "464:         Field(JavascriptFunction*) regexStickyGetterFunction;",
          "465:         Field(JavascriptFunction*) regexUnicodeGetterFunction;",
          "467:         Field(RuntimeFunction*) sharedArrayBufferConstructor;",
          "468:         Field(DynamicObject*) sharedArrayBufferPrototype;",
          "469:         Field(DynamicObject*) atomicsObject;",
          "471:         Field(DynamicObject*) webAssemblyCompileErrorPrototype;",
          "472:         Field(RuntimeFunction*) webAssemblyCompileErrorConstructor;",
          "473:         Field(DynamicObject*) webAssemblyRuntimeErrorPrototype;",
          "474:         Field(RuntimeFunction*) webAssemblyRuntimeErrorConstructor;",
          "475:         Field(DynamicObject*) webAssemblyLinkErrorPrototype;",
          "476:         Field(RuntimeFunction*) webAssemblyLinkErrorConstructor;",
          "478:         Field(DynamicObject*) webAssemblyMemoryPrototype;",
          "479:         Field(RuntimeFunction*) webAssemblyMemoryConstructor;",
          "480:         Field(DynamicObject*) webAssemblyModulePrototype;",
          "481:         Field(RuntimeFunction*) webAssemblyModuleConstructor;",
          "482:         Field(DynamicObject*) webAssemblyInstancePrototype;",
          "483:         Field(RuntimeFunction*) webAssemblyInstanceConstructor;",
          "484:         Field(DynamicObject*) webAssemblyTablePrototype;",
          "485:         Field(RuntimeFunction*) webAssemblyTableConstructor;",
          "487:         Field(int) regexConstructorSlotIndex;",
          "488:         Field(int) regexExecSlotIndex;",
          "489:         Field(int) regexFlagsGetterSlotIndex;",
          "490:         Field(int) regexGlobalGetterSlotIndex;",
          "491:         Field(int) regexStickyGetterSlotIndex;",
          "492:         Field(int) regexUnicodeGetterSlotIndex;",
          "494:         mutable Field(CharStringCache) charStringCache;",
          "496:         FieldNoBarrier(PromiseContinuationCallback) nativeHostPromiseContinuationFunction;",
          "497:         Field(void *) nativeHostPromiseContinuationFunctionState;",
          "499:         typedef SList<Js::FunctionProxy*, Recycler> FunctionReferenceList;",
          "500:         typedef JsUtil::WeakReferenceDictionary<uintptr_t, DynamicType, DictionarySizePolicy<PowerOf2Policy, 1>> JsrtExternalTypesCache;",
          "502:         Field(void *) bindRefChunkBegin;",
          "503:         Field(Field(void*)*) bindRefChunkCurrent;",
          "504:         Field(Field(void*)*) bindRefChunkEnd;",
          "505:         Field(TypePath*) rootPath;         // this should be in library instead of ScriptContext::Cache",
          "506:         Field(Js::Cache) cache;",
          "507:         Field(FunctionReferenceList*) dynamicFunctionReference;",
          "508:         Field(uint) dynamicFunctionReferenceDepth;",
          "509:         Field(FinalizableObject*) jsrtContextObject;",
          "510:         Field(JsrtExternalTypesCache*) jsrtExternalTypesCache;",
          "511:         Field(FunctionBody*) fakeGlobalFuncForUndefer;",
          "513:         typedef JsUtil::BaseHashSet<RecyclerWeakReference<RecyclableObject>*, Recycler, PowerOf2SizePolicy, RecyclerWeakReference<RecyclableObject>*, StringTemplateCallsiteObjectComparer> StringTemplateCallsiteObjectList;",
          "518:         Field(StringTemplateCallsiteObjectList*) stringTemplateCallsiteObjectList;",
          "520:         Field(ModuleRecordList*) moduleRecordList;",
          "536:         Field(JsUtil::List<Type *> *) typesEnsuredToHaveOnlyWritableDataPropertiesInItAndPrototypeChain;",
          "538:         Field(uint64) randSeed0, randSeed1;",
          "539:         Field(bool) isPRNGSeeded;",
          "540:         Field(bool) inProfileMode;",
          "541:         Field(bool) inDispatchProfileMode;",
          "542:         Field(bool) arrayObjectHasUserDefinedSpecies;",
          "544:         JavascriptFunction * AddFunctionToLibraryObjectWithPrototype(DynamicObject * object, PropertyId propertyId, FunctionInfo * functionInfo, int length, DynamicObject * prototype = nullptr, DynamicType * functionType = nullptr);",
          "545:         JavascriptFunction * AddFunctionToLibraryObject(DynamicObject* object, PropertyId propertyId, FunctionInfo * functionInfo, int length, PropertyAttributes attributes = PropertyBuiltInMethodDefaults);",
          "547:         JavascriptFunction * AddFunctionToLibraryObjectWithName(DynamicObject* object, PropertyId propertyId, PropertyId nameId, FunctionInfo * functionInfo, int length);",
          "548:         RuntimeFunction* AddGetterToLibraryObject(DynamicObject* object, PropertyId propertyId, FunctionInfo* functionInfo);",
          "549:         void AddAccessorsToLibraryObject(DynamicObject* object, PropertyId propertyId, FunctionInfo * getterFunctionInfo, FunctionInfo * setterFunctionInfo);",
          "550:         void AddAccessorsToLibraryObject(DynamicObject* object, PropertyId propertyId, RecyclableObject * getterFunction, RecyclableObject * setterFunction);",
          "551:         void AddAccessorsToLibraryObjectWithName(DynamicObject* object, PropertyId propertyId, PropertyId nameId, FunctionInfo * getterFunctionInfo, FunctionInfo * setterFunction);",
          "552:         RuntimeFunction * CreateGetterFunction(PropertyId nameId, FunctionInfo* functionInfo);",
          "553:         RuntimeFunction * CreateSetterFunction(PropertyId nameId, FunctionInfo* functionInfo);",
          "555:         template <size_t N>",
          "556:         JavascriptFunction * AddFunctionToLibraryObjectWithPropertyName(DynamicObject* object, const char16(&propertyName)[N], FunctionInfo * functionInfo, int length);",
          "558:         static SimpleTypeHandler<1> SharedPrototypeTypeHandler;",
          "559:         static SimpleTypeHandler<1> SharedFunctionWithoutPrototypeTypeHandler;",
          "560:         static SimpleTypeHandler<1> SharedFunctionWithPrototypeTypeHandlerV11;",
          "561:         static SimpleTypeHandler<2> SharedFunctionWithPrototypeTypeHandler;",
          "562:         static SimpleTypeHandler<1> SharedFunctionWithLengthTypeHandler;",
          "563:         static SimpleTypeHandler<2> SharedFunctionWithLengthAndNameTypeHandler;",
          "564:         static SimpleTypeHandler<1> SharedIdMappedFunctionWithPrototypeTypeHandler;",
          "565:         static SimpleTypeHandler<2> SharedNamespaceSymbolTypeHandler;",
          "566:         static MissingPropertyTypeHandler MissingPropertyHolderTypeHandler;",
          "568:         static SimplePropertyDescriptor const SharedFunctionPropertyDescriptors[2];",
          "569:         static SimplePropertyDescriptor const HeapArgumentsPropertyDescriptors[3];",
          "570:         static SimplePropertyDescriptor const FunctionWithLengthAndPrototypeTypeDescriptors[2];",
          "571:         static SimplePropertyDescriptor const FunctionWithLengthAndNameTypeDescriptors[2];",
          "572:         static SimplePropertyDescriptor const ModuleNamespaceTypeDescriptors[2];",
          "574:     public:",
          "577:         static const ObjectInfoBits EnumFunctionClass = EnumClass_1_Bit;",
          "579:         static void InitializeProperties(ThreadContext * threadContext);",
          "581:         JavascriptLibrary(GlobalObject* globalObject) :",
          "582:             JavascriptLibraryBase(globalObject),",
          "583:             inProfileMode(false),",
          "584:             inDispatchProfileMode(false),",
          "585:             propertyStringMap(nullptr),",
          "586:             parseIntFunctionObject(nullptr),",
          "587:             evalFunctionObject(nullptr),",
          "588:             parseFloatFunctionObject(nullptr),",
          "589:             arrayPrototypeToLocaleStringFunction(nullptr),",
          "590:             arrayPrototypeToStringFunction(nullptr),",
          "591:             identityFunction(nullptr),",
          "592:             throwerFunction(nullptr),",
          "593:             jsrtContextObject(nullptr),",
          "594:             jsrtExternalTypesCache(nullptr),",
          "595:             fakeGlobalFuncForUndefer(nullptr),",
          "596:             externalLibraryList(nullptr),",
          "597: #if ENABLE_COPYONACCESS_ARRAY",
          "598:             cacheForCopyOnAccessArraySegments(nullptr),",
          "599: #endif",
          "600:             referencedPropertyRecords(nullptr),",
          "601:             stringTemplateCallsiteObjectList(nullptr),",
          "602:             moduleRecordList(nullptr),",
          "603:             rootPath(nullptr),",
          "604:             bindRefChunkBegin(nullptr),",
          "605:             bindRefChunkCurrent(nullptr),",
          "606:             bindRefChunkEnd(nullptr),",
          "607:             dynamicFunctionReference(nullptr)",
          "608:         {",
          "609:             this->globalObject = globalObject;",
          "610:         }",
          "612:         void Initialize(ScriptContext* scriptContext, GlobalObject * globalObject);",
          "613:         void Uninitialize();",
          "614:         GlobalObject* GetGlobalObject() const { return globalObject; }",
          "615:         ScriptContext* GetScriptContext() const { return scriptContext; }",
          "617:         Recycler * GetRecycler() const { return recycler; }",
          "618:         Var GetTrueOrFalse(BOOL value) { return value ? booleanTrue : booleanFalse; }",
          "619:         JavascriptSymbol* GetSymbolMatch() { return symbolMatch; }",
          "620:         JavascriptSymbol* GetSymbolReplace() { return symbolReplace; }",
          "621:         JavascriptSymbol* GetSymbolSearch() { return symbolSearch; }",
          "622:         JavascriptSymbol* GetSymbolSplit() { return symbolSplit; }",
          "623:         JavascriptSymbol* GetSymbolSpecies() { return symbolSpecies; }",
          "624:         JavascriptString* GetNullString() { return nullString; }",
          "625:         JavascriptString* GetEmptyString() const;",
          "626:         JavascriptString* GetWhackString() { return whackString; }",
          "627:         JavascriptString* GetUndefinedDisplayString() { return undefinedDisplayString; }",
          "628:         JavascriptString* GetNaNDisplayString() { return nanDisplayString; }",
          "629:         JavascriptString* GetQuotesString() { return quotesString; }",
          "630:         JavascriptString* GetNullDisplayString() { return nullDisplayString; }",
          "631:         JavascriptString* GetUnknownDisplayString() { return unknownDisplayString; }",
          "632:         JavascriptString* GetCommaDisplayString() { return commaDisplayString; }",
          "633:         JavascriptString* GetCommaSpaceDisplayString() { return commaSpaceDisplayString; }",
          "634:         JavascriptString* GetTrueDisplayString() { return trueDisplayString; }",
          "635:         JavascriptString* GetFalseDisplayString() { return falseDisplayString; }",
          "636:         JavascriptString* GetLengthDisplayString() { return lengthDisplayString; }",
          "637:         JavascriptString* GetObjectDisplayString() { return objectDisplayString; }",
          "638:         JavascriptString* GetStringTypeDisplayString() { return stringTypeDisplayString; }",
          "639:         JavascriptString* GetErrorDisplayString() const { return errorDisplayString; }",
          "640:         JavascriptString* GetFunctionPrefixString() { return functionPrefixString; }",
          "641:         JavascriptString* GetGeneratorFunctionPrefixString() { return generatorFunctionPrefixString; }",
          "642:         JavascriptString* GetAsyncFunctionPrefixString() { return asyncFunctionPrefixString; }",
          "643:         JavascriptString* GetFunctionDisplayString() { return functionDisplayString; }",
          "644:         JavascriptString* GetXDomainFunctionDisplayString() { return xDomainFunctionDisplayString; }",
          "645:         JavascriptString* GetInvalidDateString() { return invalidDateString; }",
          "646:         JavascriptString* GetObjectTypeDisplayString() const { return objectTypeDisplayString; }",
          "647:         JavascriptString* GetFunctionTypeDisplayString() const { return functionTypeDisplayString; }",
          "648:         JavascriptString* GetBooleanTypeDisplayString() const { return booleanTypeDisplayString; }",
          "649:         JavascriptString* GetNumberTypeDisplayString() const { return numberTypeDisplayString; }",
          "650:         JavascriptString* GetModuleTypeDisplayString() const { return moduleTypeDisplayString; }",
          "651:         JavascriptString* GetVariantDateTypeDisplayString() const { return variantDateTypeDisplayString; }",
          "654:         JavascriptString* GetSIMDFloat32x4DisplayString() const { return simdFloat32x4DisplayString; }",
          "655:         JavascriptString* GetSIMDFloat64x2DisplayString() const { return simdFloat64x2DisplayString; }",
          "656:         JavascriptString* GetSIMDInt32x4DisplayString()   const { return simdInt32x4DisplayString; }",
          "657:         JavascriptString* GetSIMDInt16x8DisplayString()   const { return simdInt16x8DisplayString; }",
          "658:         JavascriptString* GetSIMDInt8x16DisplayString()   const { return simdInt8x16DisplayString; }",
          "660:         JavascriptString* GetSIMDBool32x4DisplayString()   const { return simdBool32x4DisplayString; }",
          "661:         JavascriptString* GetSIMDBool16x8DisplayString()   const { return simdBool16x8DisplayString; }",
          "662:         JavascriptString* GetSIMDBool8x16DisplayString()   const { return simdBool8x16DisplayString; }",
          "664:         JavascriptString* GetSIMDUint32x4DisplayString()   const { return simdUint32x4DisplayString; }",
          "665:         JavascriptString* GetSIMDUint16x8DisplayString()   const { return simdUint16x8DisplayString; }",
          "666:         JavascriptString* GetSIMDUint8x16DisplayString()   const { return simdUint8x16DisplayString; }",
          "668:         JavascriptString* GetSymbolTypeDisplayString() const { return symbolTypeDisplayString; }",
          "669:         JavascriptString* GetDebuggerDeadZoneBlockVariableString() { Assert(debuggerDeadZoneBlockVariableString); return debuggerDeadZoneBlockVariableString; }",
          "670:         JavascriptRegExp* CreateEmptyRegExp();",
          "671:         JavascriptFunction* GetEvalFunctionObject() { return evalFunctionObject; }",
          "672:         JavascriptFunction* GetArrayPrototypeValuesFunction() { return EnsureArrayPrototypeValuesFunction(); }",
          "673:         JavascriptFunction* GetArrayIteratorPrototypeBuiltinNextFunction() { return arrayIteratorPrototypeBuiltinNextFunction; }",
          "674:         DynamicObject* GetReflectObject() const { return reflectObject; }",
          "675:         const PropertyDescriptor* GetDefaultPropertyDescriptor() const { return &defaultPropertyDescriptor; }",
          "676:         DynamicObject* GetMissingPropertyHolder() const { return missingPropertyHolder; }",
          "678:         JavascriptFunction* GetSharedArrayBufferConstructor() { return sharedArrayBufferConstructor; }",
          "679:         DynamicObject* GetAtomicsObject() { return atomicsObject; }",
          "681:         DynamicObject* GetWebAssemblyCompileErrorPrototype() const { return webAssemblyCompileErrorPrototype; }",
          "682:         DynamicObject* GetWebAssemblyCompileErrorConstructor() const { return webAssemblyCompileErrorConstructor; }",
          "683:         DynamicObject* GetWebAssemblyRuntimeErrorPrototype() const { return webAssemblyRuntimeErrorPrototype; }",
          "684:         DynamicObject* GetWebAssemblyRuntimeErrorConstructor() const { return webAssemblyRuntimeErrorConstructor; }",
          "685:         DynamicObject* GetWebAssemblyLinkErrorPrototype() const { return webAssemblyLinkErrorPrototype; }",
          "686:         DynamicObject* GetWebAssemblyLinkErrorConstructor() const { return webAssemblyLinkErrorConstructor; }",
          "688: #if ENABLE_TTD",
          "689:         Js::PropertyId ExtractPrimitveSymbolId_TTD(Var value);",
          "690:         Js::RecyclableObject* CreatePrimitveSymbol_TTD(Js::PropertyId pid);",
          "691:         Js::RecyclableObject* CreatePrimitveSymbol_TTD(Js::JavascriptString* str);",
          "693:         Js::RecyclableObject* CreateDefaultBoxedObject_TTD(Js::TypeId kind);",
          "694:         void SetBoxedObjectValue_TTD(Js::RecyclableObject* obj, Js::Var value);",
          "696:         Js::RecyclableObject* CreateDate_TTD(double value);",
          "697:         Js::RecyclableObject* CreateRegex_TTD(const char16* patternSource, uint32 patternLength, UnifiedRegex::RegexFlags flags, CharCount lastIndex, Js::Var lastVar);",
          "698:         Js::RecyclableObject* CreateError_TTD();",
          "700:         Js::RecyclableObject* CreateES5Array_TTD();",
          "701:         static void SetLengthWritableES5Array_TTD(Js::RecyclableObject* es5Array, bool isLengthWritable);",
          "703:         Js::RecyclableObject* CreateSet_TTD();",
          "704:         Js::RecyclableObject* CreateWeakSet_TTD();",
          "705:         static void AddSetElementInflate_TTD(Js::JavascriptSet* set, Var value);",
          "706:         static void AddWeakSetElementInflate_TTD(Js::JavascriptWeakSet* set, Var value);",
          "708:         Js::RecyclableObject* CreateMap_TTD();",
          "709:         Js::RecyclableObject* CreateWeakMap_TTD();",
          "710:         static void AddMapElementInflate_TTD(Js::JavascriptMap* map, Var key, Var value);",
          "711:         static void AddWeakMapElementInflate_TTD(Js::JavascriptWeakMap* map, Var key, Var value);",
          "713:         Js::RecyclableObject* CreateExternalFunction_TTD(Js::Var fname);",
          "714:         Js::RecyclableObject* CreateBoundFunction_TTD(RecyclableObject* function, Var bThis, uint32 ct, Var* args);",
          "716:         Js::RecyclableObject* CreateProxy_TTD(RecyclableObject* handler, RecyclableObject* target);",
          "717:         Js::RecyclableObject* CreateRevokeFunction_TTD(RecyclableObject* proxy);",
          "719:         Js::RecyclableObject* CreateHeapArguments_TTD(uint32 numOfArguments, uint32 formalCount, ActivationObject* frameObject, byte* deletedArray);",
          "720:         Js::RecyclableObject* CreateES5HeapArguments_TTD(uint32 numOfArguments, uint32 formalCount, ActivationObject* frameObject, byte* deletedArray);",
          "722:         Js::JavascriptPromiseCapability* CreatePromiseCapability_TTD(Var promise, Var resolve, Var reject);",
          "723:         Js::JavascriptPromiseReaction* CreatePromiseReaction_TTD(RecyclableObject* handler, JavascriptPromiseCapability* capabilities);",
          "725:         Js::RecyclableObject* CreatePromise_TTD(uint32 status, Var result, JsUtil::List<Js::JavascriptPromiseReaction*, HeapAllocator>& resolveReactions, JsUtil::List<Js::JavascriptPromiseReaction*, HeapAllocator>& rejectReactions);",
          "726:         JavascriptPromiseResolveOrRejectFunctionAlreadyResolvedWrapper* CreateAlreadyDefinedWrapper_TTD(bool alreadyDefined);",
          "727:         Js::RecyclableObject* CreatePromiseResolveOrRejectFunction_TTD(RecyclableObject* promise, bool isReject, JavascriptPromiseResolveOrRejectFunctionAlreadyResolvedWrapper* alreadyResolved);",
          "728:         Js::RecyclableObject* CreatePromiseReactionTaskFunction_TTD(JavascriptPromiseReaction* reaction, Var argument);",
          "730:         Js::JavascriptPromiseAllResolveElementFunctionRemainingElementsWrapper* CreateRemainingElementsWrapper_TTD(Js::ScriptContext* ctx, uint32 value);",
          "731:         Js::RecyclableObject* JavascriptLibrary::CreatePromiseAllResolveElementFunction_TTD(Js::JavascriptPromiseCapability* capabilities, uint32 index, Js::JavascriptPromiseAllResolveElementFunctionRemainingElementsWrapper* wrapper, Js::RecyclableObject* values, bool alreadyCalled);",
          "732: #endif",
          "734: #ifdef ENABLE_INTL_OBJECT",
          "735:         void ResetIntlObject();",
          "736:         void EnsureIntlObjectReady();",
          "737:         template <class Fn>",
          "738:         void InitializeIntlForPrototypes(Fn fn);",
          "739:         void InitializeIntlForStringPrototype();",
          "740:         void InitializeIntlForDatePrototype();",
          "741:         void InitializeIntlForNumberPrototype();",
          "742: #endif",
          "744: #ifdef ENABLE_DEBUG_CONFIG_OPTIONS",
          "745:         DynamicType * GetDebugDisposableObjectType() { return debugDisposableObjectType; }",
          "746:         DynamicType * GetDebugFuncExecutorInDisposeObjectType() { return debugFuncExecutorInDisposeObjectType; }",
          "747: #endif",
          "749:         DynamicType* GetErrorType(ErrorTypeEnum typeToCreate) const;",
          "750:         StaticType  * GetBooleanTypeStatic() const { return booleanTypeStatic; }",
          "751:         DynamicType * GetBooleanTypeDynamic() const { return booleanTypeDynamic; }",
          "752:         DynamicType * GetDateType() const { return dateType; }",
          "753:         DynamicType * GetBoundFunctionType() const { return boundFunctionType; }",
          "754:         DynamicType * GetRegExpConstructorType() const { return regexConstructorType; }",
          "755:         StaticType  * GetEnumeratorType() const { return enumeratorType; }",
          "756:         DynamicType * GetSpreadArgumentType() const { return SpreadArgumentType; }",
          "757:         StaticType  * GetWithType() const { return withType; }",
          "758:         DynamicType * GetErrorType() const { return errorType; }",
          "759:         DynamicType * GetEvalErrorType() const { return evalErrorType; }",
          "760:         DynamicType * GetRangeErrorType() const { return rangeErrorType; }",
          "761:         DynamicType * GetReferenceErrorType() const { return referenceErrorType; }",
          "762:         DynamicType * GetSyntaxErrorType() const { return syntaxErrorType; }",
          "763:         DynamicType * GetTypeErrorType() const { return typeErrorType; }",
          "764:         DynamicType * GetURIErrorType() const { return uriErrorType; }",
          "765:         DynamicType * GetWebAssemblyCompileErrorType() const { return webAssemblyCompileErrorType; }",
          "766:         DynamicType * GetWebAssemblyRuntimeErrorType() const { return webAssemblyRuntimeErrorType; }",
          "767:         DynamicType * GetWebAssemblyLinkErrorType() const { return webAssemblyLinkErrorType; }",
          "768:         StaticType  * GetNumberTypeStatic() const { return numberTypeStatic; }",
          "769:         StaticType  * GetInt64TypeStatic() const { return int64NumberTypeStatic; }",
          "770:         StaticType  * GetUInt64TypeStatic() const { return uint64NumberTypeStatic; }",
          "771:         DynamicType * GetNumberTypeDynamic() const { return numberTypeDynamic; }",
          "772:         DynamicType * GetPromiseType() const { return promiseType; }",
          "774:         DynamicType * GetWebAssemblyModuleType()  const { return webAssemblyModuleType; }",
          "775:         DynamicType * GetWebAssemblyInstanceType()  const { return webAssemblyInstanceType; }",
          "776:         DynamicType * GetWebAssemblyMemoryType() const { return webAssemblyMemoryType; }",
          "777:         DynamicType * GetWebAssemblyTableType() const { return webAssemblyTableType; }",
          "780:         DynamicType * GetSIMDBool8x16TypeDynamic()  const { return simdBool8x16TypeDynamic;  }",
          "781:         DynamicType * GetSIMDBool16x8TypeDynamic()  const { return simdBool16x8TypeDynamic;  }",
          "782:         DynamicType * GetSIMDBool32x4TypeDynamic()  const { return simdBool32x4TypeDynamic;  }",
          "783:         DynamicType * GetSIMDInt8x16TypeDynamic()   const { return simdInt8x16TypeDynamic;   }",
          "784:         DynamicType * GetSIMDInt16x8TypeDynamic()   const { return simdInt16x8TypeDynamic;   }",
          "785:         DynamicType * GetSIMDInt32x4TypeDynamic()   const { return simdInt32x4TypeDynamic;   }",
          "786:         DynamicType * GetSIMDUint8x16TypeDynamic()  const { return simdUint8x16TypeDynamic;  }",
          "787:         DynamicType * GetSIMDUint16x8TypeDynamic()  const { return simdUint16x8TypeDynamic;  }",
          "788:         DynamicType * GetSIMDUint32x4TypeDynamic()  const { return simdUint32x4TypeDynamic;  }",
          "789:         DynamicType * GetSIMDFloat32x4TypeDynamic() const { return simdFloat32x4TypeDynamic; }",
          "791:         StaticType* GetSIMDFloat32x4TypeStatic() const { return simdFloat32x4TypeStatic; }",
          "792:         StaticType* GetSIMDFloat64x2TypeStatic() const { return simdFloat64x2TypeStatic; }",
          "793:         StaticType* GetSIMDInt32x4TypeStatic()   const { return simdInt32x4TypeStatic; }",
          "794:         StaticType* GetSIMDInt16x8TypeStatic()   const { return simdInt16x8TypeStatic; }",
          "795:         StaticType* GetSIMDInt8x16TypeStatic()   const { return simdInt8x16TypeStatic; }",
          "796:         StaticType* GetSIMDBool32x4TypeStatic() const { return simdBool32x4TypeStatic; }",
          "797:         StaticType* GetSIMDBool16x8TypeStatic() const { return simdBool16x8TypeStatic; }",
          "798:         StaticType* GetSIMDBool8x16TypeStatic() const { return simdBool8x16TypeStatic; }",
          "799:         StaticType* GetSIMDUInt32x4TypeStatic()   const { return simdUint32x4TypeStatic; }",
          "800:         StaticType* GetSIMDUint16x8TypeStatic()   const { return simdUint16x8TypeStatic; }",
          "801:         StaticType* GetSIMDUint8x16TypeStatic()   const { return simdUint8x16TypeStatic; }",
          "803:         DynamicType * GetObjectLiteralType(uint16 requestedInlineSlotCapacity);",
          "804:         DynamicType * GetObjectHeaderInlinedLiteralType(uint16 requestedInlineSlotCapacity);",
          "805:         DynamicType * GetObjectType() const { return objectTypes[0]; }",
          "806:         DynamicType * GetObjectHeaderInlinedType() const { return objectHeaderInlinedTypes[0]; }",
          "807:         StaticType  * GetSymbolTypeStatic() const { return symbolTypeStatic; }",
          "808:         DynamicType * GetSymbolTypeDynamic() const { return symbolTypeDynamic; }",
          "809:         DynamicType * GetProxyType() const { return proxyType; }",
          "810:         DynamicType * GetHeapArgumentsObjectType() const { return heapArgumentsType; }",
          "811:         DynamicType * GetActivationObjectType() const { return activationObjectType; }",
          "812:         DynamicType * GetModuleNamespaceType() const { return moduleNamespaceType; }",
          "813:         DynamicType * GetArrayType() const { return arrayType; }",
          "814:         DynamicType * GetNativeIntArrayType() const { return nativeIntArrayType; }",
          "815: #if ENABLE_COPYONACCESS_ARRAY",
          "816:         DynamicType * GetCopyOnAccessNativeIntArrayType() const { return copyOnAccessNativeIntArrayType; }",
          "817: #endif",
          "818:         DynamicType * GetNativeFloatArrayType() const { return nativeFloatArrayType; }",
          "819:         DynamicType * GetRegexPrototypeType() const { return regexPrototypeType; }",
          "820:         DynamicType * GetRegexType() const { return regexType; }",
          "821:         DynamicType * GetRegexResultType() const { return regexResultType; }",
          "822:         DynamicType * GetArrayBufferType() const { return arrayBufferType; }",
          "823:         StaticType  * GetStringTypeStatic() const { AssertMsg(stringTypeStatic, \"Where's stringTypeStatic?\"); return stringTypeStatic; }",
          "824:         DynamicType * GetStringTypeDynamic() const { return stringTypeDynamic; }",
          "825:         StaticType  * GetVariantDateType() const { return variantDateType; }",
          "826:         void EnsureDebugObject(DynamicObject* newDebugObject);",
          "827:         DynamicObject* GetDebugObject() const { Assert(debugObject != nullptr); return debugObject; }",
          "828:         DynamicType * GetMapType() const { return mapType; }",
          "829:         DynamicType * GetSetType() const { return setType; }",
          "830:         DynamicType * GetWeakMapType() const { return weakMapType; }",
          "831:         DynamicType * GetWeakSetType() const { return weakSetType; }",
          "832:         DynamicType * GetArrayIteratorType() const { return arrayIteratorType; }",
          "833:         DynamicType * GetMapIteratorType() const { return mapIteratorType; }",
          "834:         DynamicType * GetSetIteratorType() const { return setIteratorType; }",
          "835:         DynamicType * GetStringIteratorType() const { return stringIteratorType; }",
          "836:         DynamicType * GetListIteratorType() const { return listIteratorType; }",
          "837:         JavascriptFunction* GetDefaultAccessorFunction() const { return defaultAccessorFunction; }",
          "838:         JavascriptFunction* GetStackTraceAccessorFunction() const { return stackTraceAccessorFunction; }",
          "839:         JavascriptFunction* GetThrowTypeErrorRestrictedPropertyAccessorFunction() const { return throwTypeErrorRestrictedPropertyAccessorFunction; }",
          "840:         JavascriptFunction* Get__proto__getterFunction() const { return __proto__getterFunction; }",
          "841:         JavascriptFunction* Get__proto__setterFunction() const { return __proto__setterFunction; }",
          "843:         JavascriptFunction* GetObjectValueOfFunction() const { return objectValueOfFunction; }",
          "844:         JavascriptFunction* GetObjectToStringFunction() const { return objectToStringFunction; }",
          "847:         JavascriptFunction* GetSIMDFloat32x4ToStringFunction() const { return simdFloat32x4ToStringFunction;  }",
          "848:         JavascriptFunction* GetSIMDFloat64x2ToStringFunction() const { return simdFloat64x2ToStringFunction; }",
          "849:         JavascriptFunction* GetSIMDInt32x4ToStringFunction()   const { return simdInt32x4ToStringFunction; }",
          "850:         JavascriptFunction* GetSIMDInt16x8ToStringFunction()   const { return simdInt16x8ToStringFunction; }",
          "851:         JavascriptFunction* GetSIMDInt8x16ToStringFunction()   const { return simdInt8x16ToStringFunction; }",
          "852:         JavascriptFunction* GetSIMDBool32x4ToStringFunction()   const { return simdBool32x4ToStringFunction; }",
          "853:         JavascriptFunction* GetSIMDBool16x8ToStringFunction()   const { return simdBool16x8ToStringFunction; }",
          "854:         JavascriptFunction* GetSIMDBool8x16ToStringFunction()   const { return simdBool8x16ToStringFunction; }",
          "855:         JavascriptFunction* GetSIMDUint32x4ToStringFunction()   const { return simdUint32x4ToStringFunction; }",
          "856:         JavascriptFunction* GetSIMDUint16x8ToStringFunction()   const { return simdUint16x8ToStringFunction; }",
          "857:         JavascriptFunction* GetSIMDUint8x16ToStringFunction()   const { return simdUint8x16ToStringFunction; }",
          "859:         JavascriptFunction* GetDebugObjectNonUserGetterFunction() const { return debugObjectNonUserGetterFunction; }",
          "860:         JavascriptFunction* GetDebugObjectNonUserSetterFunction() const { return debugObjectNonUserSetterFunction; }",
          "862:         UnifiedRegex::RegexPattern * GetEmptyRegexPattern() const { return emptyRegexPattern; }",
          "863:         JavascriptFunction* GetRegexExecFunction() const { return regexExecFunction; }",
          "864:         JavascriptFunction* GetRegexFlagsGetterFunction() const { return regexFlagsGetterFunction; }",
          "865:         JavascriptFunction* GetRegexGlobalGetterFunction() const { return regexGlobalGetterFunction; }",
          "866:         JavascriptFunction* GetRegexStickyGetterFunction() const { return regexStickyGetterFunction; }",
          "867:         JavascriptFunction* GetRegexUnicodeGetterFunction() const { return regexUnicodeGetterFunction; }",
          "869:         int GetRegexConstructorSlotIndex() const { return regexConstructorSlotIndex;  }",
          "870:         int GetRegexExecSlotIndex() const { return regexExecSlotIndex;  }",
          "871:         int GetRegexFlagsGetterSlotIndex() const { return regexFlagsGetterSlotIndex;  }",
          "872:         int GetRegexGlobalGetterSlotIndex() const { return regexGlobalGetterSlotIndex;  }",
          "873:         int GetRegexStickyGetterSlotIndex() const { return regexStickyGetterSlotIndex;  }",
          "874:         int GetRegexUnicodeGetterSlotIndex() const { return regexUnicodeGetterSlotIndex;  }",
          "876:         TypePath* GetRootPath() const { return rootPath; }",
          "877:         void BindReference(void * addr);",
          "878:         void CleanupForClose();",
          "879:         void BeginDynamicFunctionReferences();",
          "880:         void EndDynamicFunctionReferences();",
          "881:         void RegisterDynamicFunctionReference(FunctionProxy* func);",
          "883:         void SetDebugObjectNonUserAccessor(FunctionInfo *funcGetter, FunctionInfo *funcSetter);",
          "885:         JavascriptFunction* GetDebugObjectDebugModeGetterFunction() const { return debugObjectDebugModeGetterFunction; }",
          "886:         void SetDebugObjectDebugModeAccessor(FunctionInfo *funcGetter);",
          "888: #ifdef ENABLE_DEBUG_CONFIG_OPTIONS",
          "889:         JavascriptFunction* GetDebugObjectFaultInjectionCookieGetterFunction() const { return debugObjectFaultInjectionCookieGetterFunction; }",
          "890:         JavascriptFunction* GetDebugObjectFaultInjectionCookieSetterFunction() const { return debugObjectFaultInjectionCookieSetterFunction; }",
          "891:         void SetDebugObjectFaultInjectionCookieGetterAccessor(FunctionInfo *funcGetter, FunctionInfo *funcSetter);",
          "892: #endif",
          "894:         JavascriptFunction* GetArrayPrototypeToStringFunction() const { return arrayPrototypeToStringFunction; }",
          "895:         JavascriptFunction* GetArrayPrototypeToLocaleStringFunction() const { return arrayPrototypeToLocaleStringFunction; }",
          "896:         JavascriptFunction* GetIdentityFunction() const { return identityFunction; }",
          "897:         JavascriptFunction* GetThrowerFunction() const { return throwerFunction; }",
          "899:         void SetNativeHostPromiseContinuationFunction(PromiseContinuationCallback function, void *state);",
          "901:         void SetJsrtContext(FinalizableObject* jsrtContext);",
          "902:         FinalizableObject* GetJsrtContext();",
          "903:         void EnqueueTask(Var taskVar);",
          "905:         HeapArgumentsObject* CreateHeapArguments(Var frameObj, uint formalCount, bool isStrictMode = false);",
          "906:         JavascriptArray* CreateArray();",
          "907:         JavascriptArray* CreateArray(uint32 length);",
          "908:         JavascriptArray *CreateArrayOnStack(void *const stackAllocationPointer);",
          "909:         JavascriptNativeIntArray* CreateNativeIntArray();",
          "910:         JavascriptNativeIntArray* CreateNativeIntArray(uint32 length);",
          "911: #if ENABLE_COPYONACCESS_ARRAY",
          "912:         JavascriptCopyOnAccessNativeIntArray* CreateCopyOnAccessNativeIntArray();",
          "913:         JavascriptCopyOnAccessNativeIntArray* CreateCopyOnAccessNativeIntArray(uint32 length);",
          "914: #endif",
          "915:         JavascriptNativeFloatArray* CreateNativeFloatArray();",
          "916:         JavascriptNativeFloatArray* CreateNativeFloatArray(uint32 length);",
          "917:         JavascriptArray* CreateArray(uint32 length, uint32 size);",
          "918:         ArrayBuffer* CreateArrayBuffer(uint32 length);",
          "919:         ArrayBuffer* CreateArrayBuffer(byte* buffer, uint32 length);",
          "920:         ArrayBuffer* CreateWebAssemblyArrayBuffer(uint32 length);",
          "921:         ArrayBuffer* CreateWebAssemblyArrayBuffer(byte* buffer, uint32 length);",
          "922:         SharedArrayBuffer* CreateSharedArrayBuffer(uint32 length);",
          "923:         SharedArrayBuffer* CreateSharedArrayBuffer(SharedContents *contents);",
          "924:         ArrayBuffer* CreateProjectionArraybuffer(uint32 length);",
          "925:         ArrayBuffer* CreateProjectionArraybuffer(byte* buffer, uint32 length);",
          "926:         DataView* CreateDataView(ArrayBufferBase* arrayBuffer, uint32 offSet, uint32 mappedLength);",
          "928:         template <typename TypeName, bool clamped>",
          "929:         inline DynamicType* GetTypedArrayType(TypeName);",
          "931:         template<> inline DynamicType* GetTypedArrayType<int8,false>(int8) { return int8ArrayType; };",
          "932:         template<> inline DynamicType* GetTypedArrayType<uint8,false>(uint8) { return uint8ArrayType; };",
          "933:         template<> inline DynamicType* GetTypedArrayType<uint8,true>(uint8) { return uint8ClampedArrayType; };",
          "934:         template<> inline DynamicType* GetTypedArrayType<int16,false>(int16) { return int16ArrayType; };",
          "935:         template<> inline DynamicType* GetTypedArrayType<uint16,false>(uint16) { return uint16ArrayType; };",
          "936:         template<> inline DynamicType* GetTypedArrayType<int32,false>(int32) { return int32ArrayType; };",
          "937:         template<> inline DynamicType* GetTypedArrayType<uint32,false>(uint32) { return uint32ArrayType; };",
          "938:         template<> inline DynamicType* GetTypedArrayType<float,false>(float) { return float32ArrayType; };",
          "939:         template<> inline DynamicType* GetTypedArrayType<double,false>(double) { return float64ArrayType; };",
          "940:         template<> inline DynamicType* GetTypedArrayType<int64,false>(int64) { return int64ArrayType; };",
          "941:         template<> inline DynamicType* GetTypedArrayType<uint64,false>(uint64) { return uint64ArrayType; };",
          "942:         template<> inline DynamicType* GetTypedArrayType<bool,false>(bool) { return boolArrayType; };",
          "944:         DynamicType* GetCharArrayType() { return charArrayType; };",
          "950:         JavascriptArray*            CreateArrayLiteral(uint32 length);",
          "951:         JavascriptNativeIntArray*   CreateNativeIntArrayLiteral(uint32 length);",
          "953: #if ENABLE_PROFILE_INFO",
          "954:         JavascriptNativeIntArray*   CreateCopyOnAccessNativeIntArrayLiteral(ArrayCallSiteInfo *arrayInfo, FunctionBody *functionBody, const Js::AuxArray<int32> *ints);",
          "955: #endif",
          "957:         JavascriptNativeFloatArray* CreateNativeFloatArrayLiteral(uint32 length);",
          "959:         JavascriptBoolean* CreateBoolean(BOOL value);",
          "960:         JavascriptDate* CreateDate();",
          "961:         JavascriptDate* CreateDate(double value);",
          "962:         JavascriptDate* CreateDate(SYSTEMTIME* pst);",
          "963:         JavascriptMap* CreateMap();",
          "964:         JavascriptSet* CreateSet();",
          "965:         JavascriptWeakMap* CreateWeakMap();",
          "966:         JavascriptWeakSet* CreateWeakSet();",
          "967:         JavascriptError* CreateError();",
          "968:         JavascriptError* CreateError(DynamicType* errorType, BOOL isExternal = FALSE);",
          "969:         JavascriptError* CreateExternalError(ErrorTypeEnum errorTypeEnum);",
          "970:         JavascriptError* CreateEvalError();",
          "971:         JavascriptError* CreateRangeError();",
          "972:         JavascriptError* CreateReferenceError();",
          "973:         JavascriptError* CreateSyntaxError();",
          "974:         JavascriptError* CreateTypeError();",
          "975:         JavascriptError* CreateURIError();",
          "976:         JavascriptError* CreateStackOverflowError();",
          "977:         JavascriptError* CreateOutOfMemoryError();",
          "978:         JavascriptError* CreateWebAssemblyCompileError();",
          "979:         JavascriptError* CreateWebAssemblyRuntimeError();",
          "980:         JavascriptError* CreateWebAssemblyLinkError();",
          "981:         JavascriptSymbol* CreateSymbol(JavascriptString* description);",
          "982:         JavascriptSymbol* CreateSymbol(const char16* description, int descriptionLength);",
          "983:         JavascriptSymbol* CreateSymbol(const PropertyRecord* propertyRecord);",
          "984:         JavascriptPromise* CreatePromise();",
          "985:         JavascriptGenerator* CreateGenerator(Arguments& args, ScriptFunction* scriptFunction, RecyclableObject* prototype);",
          "986:         JavascriptFunction* CreateNonProfiledFunction(FunctionInfo * functionInfo);",
          "987:         template <class MethodType>",
          "988:         JavascriptExternalFunction* CreateIdMappedExternalFunction(MethodType entryPoint, DynamicType *pPrototypeType);",
          "989:         JavascriptExternalFunction* CreateExternalConstructor(Js::ExternalMethod entryPoint, PropertyId nameId, RecyclableObject * prototype);",
          "990:         JavascriptExternalFunction* CreateExternalConstructor(Js::ExternalMethod entryPoint, PropertyId nameId, InitializeMethod method, unsigned short deferredTypeSlots, bool hasAccessors);",
          "991:         DynamicType* GetCachedJsrtExternalType(uintptr_t finalizeCallback);",
          "992:         void CacheJsrtExternalType(uintptr_t finalizeCallback, DynamicType* dynamicType);",
          "993:         static DynamicTypeHandler * GetDeferredPrototypeGeneratorFunctionTypeHandler(ScriptContext* scriptContext);",
          "994:         static DynamicTypeHandler * GetDeferredPrototypeAsyncFunctionTypeHandler(ScriptContext* scriptContext);",
          "995:         DynamicType * CreateDeferredPrototypeGeneratorFunctionType(JavascriptMethod entrypoint, bool isAnonymousFunction, bool isShared = false);",
          "996:         DynamicType * CreateDeferredPrototypeAsyncFunctionType(JavascriptMethod entrypoint, bool isAnonymousFunction, bool isShared = false);",
          "998:         static DynamicTypeHandler * GetDeferredPrototypeFunctionTypeHandler(ScriptContext* scriptContext);",
          "999:         static DynamicTypeHandler * GetDeferredAnonymousPrototypeFunctionTypeHandler();",
          "1000:         static DynamicTypeHandler * GetDeferredAnonymousPrototypeGeneratorFunctionTypeHandler();",
          "1001:         static DynamicTypeHandler * GetDeferredAnonymousPrototypeAsyncFunctionTypeHandler();",
          "1003:         DynamicTypeHandler * GetDeferredFunctionTypeHandler();",
          "1004:         DynamicTypeHandler * ScriptFunctionTypeHandler(bool noPrototypeProperty, bool isAnonymousFunction);",
          "1005:         DynamicTypeHandler * GetDeferredAnonymousFunctionTypeHandler();",
          "1006:         template<bool isNameAvailable, bool isPrototypeAvailable = true>",
          "1007:         static DynamicTypeHandler * GetDeferredFunctionTypeHandlerBase();",
          "1008:         template<bool isNameAvailable, bool isPrototypeAvailable = true>",
          "1009:         static DynamicTypeHandler * GetDeferredGeneratorFunctionTypeHandlerBase();",
          "1010:         template<bool isNameAvailable>",
          "1011:         static DynamicTypeHandler * GetDeferredAsyncFunctionTypeHandlerBase();",
          "1013:         DynamicType * CreateDeferredPrototypeFunctionType(JavascriptMethod entrypoint);",
          "1014:         DynamicType * CreateDeferredPrototypeFunctionTypeNoProfileThunk(JavascriptMethod entrypoint, bool isShared = false);",
          "1015:         DynamicType * CreateFunctionType(JavascriptMethod entrypoint, RecyclableObject* prototype = nullptr);",
          "1016:         DynamicType * CreateFunctionWithLengthType(FunctionInfo * functionInfo);",
          "1017:         DynamicType * CreateFunctionWithLengthAndNameType(FunctionInfo * functionInfo);",
          "1018:         DynamicType * CreateFunctionWithLengthAndPrototypeType(FunctionInfo * functionInfo);",
          "1019:         DynamicType * CreateFunctionWithLengthType(DynamicObject * prototype, FunctionInfo * functionInfo);",
          "1020:         DynamicType * CreateFunctionWithLengthAndNameType(DynamicObject * prototype, FunctionInfo * functionInfo);",
          "1021:         DynamicType * CreateFunctionWithLengthAndPrototypeType(DynamicObject * prototype, FunctionInfo * functionInfo);",
          "1022:         ScriptFunction * CreateScriptFunction(FunctionProxy* proxy);",
          "1023:         AsmJsScriptFunction * CreateAsmJsScriptFunction(FunctionProxy* proxy);",
          "1024:         ScriptFunctionWithInlineCache * CreateScriptFunctionWithInlineCache(FunctionProxy* proxy);",
          "1025:         GeneratorVirtualScriptFunction * CreateGeneratorVirtualScriptFunction(FunctionProxy* proxy);",
          "1026:         DynamicType * CreateGeneratorType(RecyclableObject* prototype);",
          "1028: #if 0",
          "1029:         JavascriptNumber* CreateNumber(double value);",
          "1030: #endif",
          "1031:         JavascriptNumber* CreateNumber(double value, RecyclerJavascriptNumberAllocator * numberAllocator);",
          "1032:         JavascriptGeneratorFunction* CreateGeneratorFunction(JavascriptMethod entryPoint, GeneratorVirtualScriptFunction* scriptFunction);",
          "1033:         JavascriptAsyncFunction* CreateAsyncFunction(JavascriptMethod entryPoint, GeneratorVirtualScriptFunction* scriptFunction);",
          "1034:         JavascriptExternalFunction* CreateExternalFunction(ExternalMethod entryPointer, PropertyId nameId, Var signature, JavascriptTypeId prototypeTypeId, UINT64 flags);",
          "1035:         JavascriptExternalFunction* CreateExternalFunction(ExternalMethod entryPointer, Var nameId, Var signature, JavascriptTypeId prototypeTypeId, UINT64 flags);",
          "1036:         JavascriptExternalFunction* CreateStdCallExternalFunction(StdCallJavascriptMethod entryPointer, PropertyId nameId, void *callbackState);",
          "1037:         JavascriptExternalFunction* CreateStdCallExternalFunction(StdCallJavascriptMethod entryPointer, Var nameId, void *callbackState);",
          "1038:         JavascriptPromiseAsyncSpawnExecutorFunction* CreatePromiseAsyncSpawnExecutorFunction(JavascriptMethod entryPoint, JavascriptGenerator* generator, Var target);",
          "1039:         JavascriptPromiseAsyncSpawnStepArgumentExecutorFunction* CreatePromiseAsyncSpawnStepArgumentExecutorFunction(JavascriptMethod entryPoint, JavascriptGenerator* generator, Var argument, JavascriptFunction* resolve = NULL, JavascriptFunction* reject = NULL, bool isReject = false);",
          "1040:         JavascriptPromiseCapabilitiesExecutorFunction* CreatePromiseCapabilitiesExecutorFunction(JavascriptMethod entryPoint, JavascriptPromiseCapability* capability);",
          "1041:         JavascriptPromiseResolveOrRejectFunction* CreatePromiseResolveOrRejectFunction(JavascriptMethod entryPoint, JavascriptPromise* promise, bool isReject, JavascriptPromiseResolveOrRejectFunctionAlreadyResolvedWrapper* alreadyResolvedRecord);",
          "1042:         JavascriptPromiseReactionTaskFunction* CreatePromiseReactionTaskFunction(JavascriptMethod entryPoint, JavascriptPromiseReaction* reaction, Var argument);",
          "1043:         JavascriptPromiseResolveThenableTaskFunction* CreatePromiseResolveThenableTaskFunction(JavascriptMethod entryPoint, JavascriptPromise* promise, RecyclableObject* thenable, RecyclableObject* thenFunction);",
          "1044:         JavascriptPromiseAllResolveElementFunction* CreatePromiseAllResolveElementFunction(JavascriptMethod entryPoint, uint32 index, JavascriptArray* values, JavascriptPromiseCapability* capabilities, JavascriptPromiseAllResolveElementFunctionRemainingElementsWrapper* remainingElements);",
          "1045:         JavascriptExternalFunction* CreateWrappedExternalFunction(JavascriptExternalFunction* wrappedFunction);",
          "1047: #if ENABLE_NATIVE_CODEGEN",
          "1048: #if !FLOATVAR",
          "1049:         JavascriptNumber* CreateCodeGenNumber(CodeGenNumberAllocator *alloc, double value);",
          "1050: #endif",
          "1051: #endif",
          "1053:         DynamicObject* CreateGeneratorConstructorPrototypeObject();",
          "1054:         DynamicObject* CreateConstructorPrototypeObject(JavascriptFunction * constructor);",
          "1055:         DynamicObject* CreateObject(const bool allowObjectHeaderInlining = false, const PropertyIndex requestedInlineSlotCapacity = 0);",
          "1056:         DynamicObject* CreateObject(DynamicTypeHandler * typeHandler);",
          "1057:         DynamicObject* CreateActivationObject();",
          "1058:         DynamicObject* CreatePseudoActivationObject();",
          "1059:         DynamicObject* CreateBlockActivationObject();",
          "1060:         DynamicObject* CreateConsoleScopeActivationObject();",
          "1061:         DynamicType* CreateObjectType(RecyclableObject* prototype, Js::TypeId typeId, uint16 requestedInlineSlotCapacity);",
          "1062:         DynamicType* CreateObjectTypeNoCache(RecyclableObject* prototype, Js::TypeId typeId);",
          "1063:         DynamicType* CreateObjectType(RecyclableObject* prototype, uint16 requestedInlineSlotCapacity);",
          "1064:         DynamicObject* CreateObject(RecyclableObject* prototype, uint16 requestedInlineSlotCapacity = 0);",
          "1066:         typedef JavascriptString* LibStringType; // used by diagnostics template",
          "1067:         template< size_t N > JavascriptString* CreateStringFromCppLiteral(const char16 (&value)[N]) const;",
          "1068:         template<> JavascriptString* CreateStringFromCppLiteral(const char16 (&value)[1]) const; // Specialization for empty string",
          "1069:         template<> JavascriptString* CreateStringFromCppLiteral(const char16 (&value)[2]) const; // Specialization for single-char strings",
          "1070:         PropertyString* CreatePropertyString(const Js::PropertyRecord* propertyRecord);",
          "1071:         PropertyString* CreatePropertyString(const Js::PropertyRecord* propertyRecord, ArenaAllocator *arena);",
          "1073:         JavascriptVariantDate* CreateVariantDate(const double value);",
          "1075:         JavascriptBooleanObject* CreateBooleanObject(BOOL value);",
          "1076:         JavascriptBooleanObject* CreateBooleanObject();",
          "1077:         JavascriptNumberObject* CreateNumberObjectWithCheck(double value);",
          "1078:         JavascriptNumberObject* CreateNumberObject(Var number);",
          "1079:         JavascriptSIMDObject* CreateSIMDObject(Var simdValue, TypeId typeDescriptor);",
          "1080:         JavascriptStringObject* CreateStringObject(JavascriptString* value);",
          "1081:         JavascriptStringObject* CreateStringObject(const char16* value, charcount_t length);",
          "1082:         JavascriptSymbolObject* CreateSymbolObject(JavascriptSymbol* value);",
          "1083:         JavascriptArrayIterator* CreateArrayIterator(Var iterable, JavascriptArrayIteratorKind kind);",
          "1084:         JavascriptMapIterator* CreateMapIterator(JavascriptMap* map, JavascriptMapIteratorKind kind);",
          "1085:         JavascriptSetIterator* CreateSetIterator(JavascriptSet* set, JavascriptSetIteratorKind kind);",
          "1086:         JavascriptStringIterator* CreateStringIterator(JavascriptString* string);",
          "1087:         JavascriptListIterator* CreateListIterator(ListForListIterator* list);",
          "1089:         JavascriptRegExp* CreateRegExp(UnifiedRegex::RegexPattern* pattern);",
          "1091:         DynamicObject* CreateIteratorResultObject(Var value, Var done);",
          "1092:         DynamicObject* CreateIteratorResultObjectValueFalse(Var value);",
          "1093:         DynamicObject* CreateIteratorResultObjectUndefinedTrue();",
          "1095:         RecyclableObject* CreateThrowErrorObject(JavascriptError* error);",
          "1097:         JavascriptFunction* EnsurePromiseResolveFunction();",
          "1098:         JavascriptFunction* EnsurePromiseThenFunction();",
          "1099:         JavascriptFunction* EnsureGeneratorNextFunction();",
          "1100:         JavascriptFunction* EnsureGeneratorThrowFunction();",
          "1101:         JavascriptFunction* EnsureJSONStringifyFunction();",
          "1102:         JavascriptFunction* EnsureObjectFreezeFunction();",
          "1104:         void SetCrossSiteForSharedFunctionType(JavascriptFunction * function);",
          "1106:         bool IsPRNGSeeded() { return isPRNGSeeded; }",
          "1107:         uint64 GetRandSeed0() { return randSeed0; }",
          "1108:         uint64 GetRandSeed1() { return randSeed1; }",
          "1109:         void SetIsPRNGSeeded(bool val);",
          "1110:         void SetRandSeed0(uint64 rs) { randSeed0 = rs;}",
          "1111:         void SetRandSeed1(uint64 rs) { randSeed1 = rs; }",
          "1113:         void SetProfileMode(bool fSet);",
          "1114:         void SetDispatchProfile(bool fSet, JavascriptMethod dispatchInvoke);",
          "1115:         HRESULT ProfilerRegisterBuiltIns();",
          "1117: #if ENABLE_COPYONACCESS_ARRAY",
          "1118:         static bool IsCopyOnAccessArrayCallSite(JavascriptLibrary *lib, ArrayCallSiteInfo *arrayInfo, uint32 length);",
          "1119:         static bool IsCachedCopyOnAccessArrayCallSite(const JavascriptLibrary *lib, ArrayCallSiteInfo *arrayInfo);",
          "1120:         template <typename T>",
          "1121:         static void CheckAndConvertCopyOnAccessNativeIntArray(const T instance);",
          "1122: #endif",
          "1124:         void EnsureStringTemplateCallsiteObjectList();",
          "1125:         void AddStringTemplateCallsiteObject(RecyclableObject* callsite);",
          "1126:         RecyclableObject* TryGetStringTemplateCallsiteObject(ParseNodePtr pnode);",
          "1127:         RecyclableObject* TryGetStringTemplateCallsiteObject(RecyclableObject* callsite);",
          "1129:         static void CheckAndInvalidateIsConcatSpreadableCache(PropertyId propertyId, ScriptContext *scriptContext);",
          "1131: #if DBG_DUMP",
          "1132:         static const char16* GetStringTemplateCallsiteObjectKey(Var callsite);",
          "1133: #endif",
          "1135:         Field(JavascriptFunction*)* GetBuiltinFunctions();",
          "1136:         INT_PTR* GetVTableAddresses();",
          "1137:         static BuiltinFunction GetBuiltinFunctionForPropId(PropertyId id);",
          "1138:         static BuiltinFunction GetBuiltInForFuncInfo(intptr_t funcInfoAddr, ThreadContextInfo *context);",
          "1139: #if DBG",
          "1140:         static void CheckRegisteredBuiltIns(Field(JavascriptFunction*)* builtInFuncs, ScriptContext *scriptContext);",
          "1141: #endif",
          "1142:         static BOOL CanFloatPreferenceFunc(BuiltinFunction index);",
          "1143:         static BOOL IsFltFunc(BuiltinFunction index);",
          "1144:         static bool IsFloatFunctionCallsite(BuiltinFunction index, size_t argc);",
          "1145:         static bool IsFltBuiltInConst(PropertyId id);",
          "1146:         static size_t GetArgCForBuiltIn(BuiltinFunction index)",
          "1147:         {",
          "1148:             Assert(index < _countof(JavascriptLibrary::LibraryFunctionArgC));",
          "1149:             return JavascriptLibrary::LibraryFunctionArgC[index];",
          "1150:         }",
          "1151:         static BuiltInFlags GetFlagsForBuiltIn(BuiltinFunction index)",
          "1152:         {",
          "1153:             Assert(index < _countof(JavascriptLibrary::LibraryFunctionFlags));",
          "1154:             return (BuiltInFlags)JavascriptLibrary::LibraryFunctionFlags[index];",
          "1155:         }",
          "1156:         static BuiltinFunction GetBuiltInInlineCandidateId(Js::OpCode opCode);",
          "1157:         static BuiltInArgSpecializationType GetBuiltInArgType(BuiltInFlags flags, BuiltInArgShift argGroup);",
          "1158:         static bool IsTypeSpecRequired(BuiltInFlags flags)",
          "1159:         {",
          "1160:             return GetBuiltInArgType(flags, BuiltInArgShift::BIAS_Src1) || GetBuiltInArgType(flags, BuiltInArgShift::BIAS_Src2) || GetBuiltInArgType(flags, BuiltInArgShift::BIAS_Dst);",
          "1161:         }",
          "1162: #if ENABLE_DEBUG_CONFIG_OPTIONS",
          "1163:         static char16 const * GetNameForBuiltIn(BuiltinFunction index)",
          "1164:         {",
          "1165:             Assert(index < _countof(JavascriptLibrary::LibraryFunctionName));",
          "1166:             return JavascriptLibrary::LibraryFunctionName[index];",
          "1167:         }",
          "1168: #endif",
          "1170:         PropertyStringCacheMap* EnsurePropertyStringMap();",
          "1171:         PropertyStringCacheMap* GetPropertyStringMap() { return this->propertyStringMap; }",
          "1173:         void TypeAndPrototypesAreEnsuredToHaveOnlyWritableDataProperties(Type *const type);",
          "1174:         void NoPrototypeChainsAreEnsuredToHaveOnlyWritableDataProperties();",
          "1176:         static bool ArrayIteratorPrototypeHasUserDefinedNext(ScriptContext *scriptContext);",
          "1178:         CharStringCache& GetCharStringCache() { return charStringCache;  }",
          "1179:         static JavascriptLibrary * FromCharStringCache(CharStringCache * cache)",
          "1180:         {",
          "1181:             return (JavascriptLibrary *)((uintptr_t)cache - offsetof(JavascriptLibrary, charStringCache));",
          "1182:         }",
          "1184:         bool GetArrayObjectHasUserDefinedSpecies() const { return arrayObjectHasUserDefinedSpecies; }",
          "1185:         void SetArrayObjectHasUserDefinedSpecies(bool val) { arrayObjectHasUserDefinedSpecies = val; }",
          "1187:         FunctionBody* GetFakeGlobalFuncForUndefer()const { return this->fakeGlobalFuncForUndefer; }",
          "1188:         void SetFakeGlobalFuncForUndefer(FunctionBody* functionBody) { this->fakeGlobalFuncForUndefer = functionBody; }",
          "1190:         ModuleRecordList* EnsureModuleRecordList();",
          "1191:         SourceTextModuleRecord* GetModuleRecord(uint moduleId);",
          "1193:     private:",
          "1194: #ifdef ENABLE_DEBUG_CONFIG_OPTIONS",
          "1198:         Field(DynamicType *) debugDisposableObjectType;",
          "1199:         Field(DynamicType *) debugFuncExecutorInDisposeObjectType;",
          "1200: #endif",
          "1202:         void InitializePrototypes();",
          "1203:         void InitializeTypes();",
          "1204:         void InitializeGlobal(GlobalObject * globalObject);",
          "1205:         static void PrecalculateArrayAllocationBuckets();",
          "1207: #define STANDARD_INIT(name) \\",
          "1208:         static void __cdecl Initialize##name##Constructor(DynamicObject* arrayConstructor, DeferredTypeHandlerBase * typeHandler, DeferredInitializeMode mode); \\",
          "1209:         static void __cdecl Initialize##name##Prototype(DynamicObject* arrayPrototype, DeferredTypeHandlerBase * typeHandler, DeferredInitializeMode mode);",
          "1211:         STANDARD_INIT(Array);",
          "1212:         STANDARD_INIT(SharedArrayBuffer);",
          "1213:         STANDARD_INIT(ArrayBuffer);",
          "1214:         STANDARD_INIT(DataView);",
          "1215:         STANDARD_INIT(Error);",
          "1216:         STANDARD_INIT(EvalError);",
          "1217:         STANDARD_INIT(RangeError);",
          "1218:         STANDARD_INIT(ReferenceError);",
          "1219:         STANDARD_INIT(SyntaxError);",
          "1220:         STANDARD_INIT(TypeError);",
          "1221:         STANDARD_INIT(URIError);",
          "1222:         STANDARD_INIT(RuntimeError);",
          "1223:         STANDARD_INIT(TypedArray);",
          "1224:         STANDARD_INIT(Int8Array);",
          "1225:         STANDARD_INIT(Uint8Array);",
          "1226:         STANDARD_INIT(Uint8ClampedArray);",
          "1227:         STANDARD_INIT(Int16Array);",
          "1228:         STANDARD_INIT(Uint16Array);",
          "1229:         STANDARD_INIT(Int32Array);",
          "1230:         STANDARD_INIT(Uint32Array);",
          "1231:         STANDARD_INIT(Float32Array);",
          "1232:         STANDARD_INIT(Float64Array);",
          "1233:         STANDARD_INIT(Boolean);",
          "1234:         STANDARD_INIT(Symbol);",
          "1235:         STANDARD_INIT(Date);",
          "1236:         STANDARD_INIT(Proxy);",
          "1237:         STANDARD_INIT(Function);",
          "1238:         STANDARD_INIT(Number);",
          "1239:         STANDARD_INIT(Object);",
          "1240:         STANDARD_INIT(Regex);",
          "1241:         STANDARD_INIT(String);",
          "1242:         STANDARD_INIT(Map);",
          "1243:         STANDARD_INIT(Set);",
          "1244:         STANDARD_INIT(WeakMap);",
          "1245:         STANDARD_INIT(WeakSet);",
          "1246:         STANDARD_INIT(Promise);",
          "1247:         STANDARD_INIT(GeneratorFunction);",
          "1248:         STANDARD_INIT(AsyncFunction);",
          "1249:         STANDARD_INIT(WebAssemblyCompileError);",
          "1250:         STANDARD_INIT(WebAssemblyRuntimeError);",
          "1251:         STANDARD_INIT(WebAssemblyLinkError);",
          "1252:         STANDARD_INIT(WebAssemblyMemory);",
          "1253:         STANDARD_INIT(WebAssemblyModule);",
          "1254:         STANDARD_INIT(WebAssemblyInstance);",
          "1255:         STANDARD_INIT(WebAssemblyTable);",
          "1257: #undef STANDARD_INIT",
          "1259:         static void __cdecl InitializeAtomicsObject(DynamicObject* atomicsObject, DeferredTypeHandlerBase * typeHandler, DeferredInitializeMode mode);",
          "1261:         static void __cdecl InitializeInt64ArrayPrototype(DynamicObject* prototype, DeferredTypeHandlerBase * typeHandler, DeferredInitializeMode mode);",
          "1262:         static void __cdecl InitializeUint64ArrayPrototype(DynamicObject* prototype, DeferredTypeHandlerBase * typeHandler, DeferredInitializeMode mode);",
          "1263:         static void __cdecl InitializeBoolArrayPrototype(DynamicObject* prototype, DeferredTypeHandlerBase * typeHandler, DeferredInitializeMode mode);",
          "1264:         static void __cdecl InitializeCharArrayPrototype(DynamicObject* prototype, DeferredTypeHandlerBase * typeHandler, DeferredInitializeMode mode);",
          "1266:         void InitializeComplexThings();",
          "1267:         void InitializeStaticValues();",
          "1268:         static void __cdecl InitializeMathObject(DynamicObject* mathObject, DeferredTypeHandlerBase * typeHandler, DeferredInitializeMode mode);",
          "1269: #ifdef ENABLE_WASM",
          "1270:         static void __cdecl InitializeWebAssemblyObject(DynamicObject* WasmObject, DeferredTypeHandlerBase * typeHandler, DeferredInitializeMode mode);",
          "1271: #endif",
          "1273:         static void __cdecl InitializeSIMDObject(DynamicObject* simdObject, DeferredTypeHandlerBase * typeHandler, DeferredInitializeMode mode);",
          "1274:         static void __cdecl InitializeSIMDOpCodeMaps();",
          "1276:         template<typename SIMDTypeName>",
          "1277:         static void SIMDPrototypeInitHelper(DynamicObject* simdPrototype, JavascriptLibrary* library, JavascriptFunction* constructorFn, JavascriptString* strLiteral);",
          "1279:         static void __cdecl InitializeSIMDBool8x16Prototype(DynamicObject* simdPrototype, DeferredTypeHandlerBase * typeHandler, DeferredInitializeMode mode);",
          "1280:         static void __cdecl InitializeSIMDBool16x8Prototype(DynamicObject* simdPrototype, DeferredTypeHandlerBase * typeHandler, DeferredInitializeMode mode);",
          "1281:         static void __cdecl InitializeSIMDBool32x4Prototype(DynamicObject* simdPrototype, DeferredTypeHandlerBase * typeHandler, DeferredInitializeMode mode);",
          "1282:         static void __cdecl InitializeSIMDInt8x16Prototype(DynamicObject* simdPrototype, DeferredTypeHandlerBase * typeHandler, DeferredInitializeMode mode);",
          "1283:         static void __cdecl InitializeSIMDInt16x8Prototype(DynamicObject* simdPrototype, DeferredTypeHandlerBase * typeHandler, DeferredInitializeMode mode);",
          "1284:         static void __cdecl InitializeSIMDInt32x4Prototype(DynamicObject* simdPrototype, DeferredTypeHandlerBase * typeHandler, DeferredInitializeMode mode);",
          "1285:         static void __cdecl InitializeSIMDUint8x16Prototype(DynamicObject* simdPrototype, DeferredTypeHandlerBase * typeHandler, DeferredInitializeMode mode);",
          "1286:         static void __cdecl InitializeSIMDUint16x8Prototype(DynamicObject* simdPrototype, DeferredTypeHandlerBase * typeHandler, DeferredInitializeMode mode);",
          "1287:         static void __cdecl InitializeSIMDUint32x4Prototype(DynamicObject* simdPrototype, DeferredTypeHandlerBase * typeHandler, DeferredInitializeMode mode);",
          "1288:         static void __cdecl InitializeSIMDFloat32x4Prototype(DynamicObject* simdPrototype, DeferredTypeHandlerBase * typeHandler, DeferredInitializeMode mode);",
          "1289:         static void __cdecl InitializeSIMDFloat64x2Prototype(DynamicObject* simdPrototype, DeferredTypeHandlerBase * typeHandler, DeferredInitializeMode mode);",
          "1291:         static void __cdecl InitializeJSONObject(DynamicObject* JSONObject, DeferredTypeHandlerBase * typeHandler, DeferredInitializeMode mode);",
          "1292:         static void __cdecl InitializeEngineInterfaceObject(DynamicObject* engineInterface, DeferredTypeHandlerBase * typeHandler, DeferredInitializeMode mode);",
          "1293:         static void __cdecl InitializeReflectObject(DynamicObject* reflectObject, DeferredTypeHandlerBase * typeHandler, DeferredInitializeMode mode);",
          "1294: #ifdef ENABLE_INTL_OBJECT",
          "1295:         static void __cdecl InitializeIntlObject(DynamicObject* IntlEngineObject, DeferredTypeHandlerBase * typeHandler, DeferredInitializeMode mode);",
          "1296: #endif",
          "1297: #ifdef ENABLE_PROJECTION",
          "1298:         void InitializeWinRTPromiseConstructor();",
          "1299: #endif",
          "1301:         static void __cdecl InitializeIteratorPrototype(DynamicObject* iteratorPrototype, DeferredTypeHandlerBase * typeHandler, DeferredInitializeMode mode);",
          "1302:         static void __cdecl InitializeArrayIteratorPrototype(DynamicObject* arrayIteratorPrototype, DeferredTypeHandlerBase * typeHandler, DeferredInitializeMode mode);",
          "1303:         static void __cdecl InitializeMapIteratorPrototype(DynamicObject* mapIteratorPrototype, DeferredTypeHandlerBase * typeHandler, DeferredInitializeMode mode);",
          "1304:         static void __cdecl InitializeSetIteratorPrototype(DynamicObject* setIteratorPrototype, DeferredTypeHandlerBase * typeHandler, DeferredInitializeMode mode);",
          "1305:         static void __cdecl InitializeStringIteratorPrototype(DynamicObject* stringIteratorPrototype, DeferredTypeHandlerBase * typeHandler, DeferredInitializeMode mode);",
          "1307:         static void __cdecl InitializeGeneratorPrototype(DynamicObject* generatorPrototype, DeferredTypeHandlerBase * typeHandler, DeferredInitializeMode mode);",
          "1309:         static void __cdecl InitializeAsyncFunction(DynamicObject *function, DeferredTypeHandlerBase * typeHandler, DeferredInitializeMode mode);",
          "1311:         RuntimeFunction* CreateBuiltinConstructor(FunctionInfo * functionInfo, DynamicTypeHandler * typeHandler, DynamicObject* prototype = nullptr);",
          "1312:         RuntimeFunction* DefaultCreateFunction(FunctionInfo * functionInfo, int length, DynamicObject * prototype, DynamicType * functionType, PropertyId nameId);",
          "1313:         RuntimeFunction* DefaultCreateFunction(FunctionInfo * functionInfo, int length, DynamicObject * prototype, DynamicType * functionType, Var nameId);",
          "1314:         JavascriptFunction* AddFunction(DynamicObject* object, PropertyId propertyId, RuntimeFunction* function);",
          "1315:         void AddMember(DynamicObject* object, PropertyId propertyId, Var value);",
          "1316:         void AddMember(DynamicObject* object, PropertyId propertyId, Var value, PropertyAttributes attributes);",
          "1317:         JavascriptString* CreateEmptyString();",
          "1320:         static void __cdecl InitializeGeneratorFunction(DynamicObject* function, DeferredTypeHandlerBase * typeHandler, DeferredInitializeMode mode);",
          "1321:         template<bool addPrototype>",
          "1322:         static void __cdecl InitializeFunction(DynamicObject* function, DeferredTypeHandlerBase * typeHandler, DeferredInitializeMode mode);",
          "1324:         static size_t const LibraryFunctionArgC[BuiltinFunction::Count + 1];",
          "1325:         static int const LibraryFunctionFlags[BuiltinFunction::Count + 1];   // returns enum BuiltInFlags.",
          "1326: #if ENABLE_DEBUG_CONFIG_OPTIONS",
          "1327:         static char16 const * const LibraryFunctionName[BuiltinFunction::Count + 1];",
          "1328: #endif",
          "1330:         JavascriptFunction* EnsureArrayPrototypeValuesFunction();",
          "1333:     public:",
          "1334:         virtual void Finalize(bool isShutdown) override;",
          "1336: #if DBG",
          "1337:         void DumpLibraryByteCode();",
          "1338: #endif",
          "1339:     private:",
          "1340:         typedef JsUtil::BaseHashSet<Js::PropertyRecord const *, Recycler, PowerOf2SizePolicy> ReferencedPropertyRecordHashSet;",
          "1341:         Field(ReferencedPropertyRecordHashSet*) referencedPropertyRecords;",
          "1343:         ReferencedPropertyRecordHashSet * EnsureReferencedPropertyRecordList()",
          "1344:         {",
          "1345:             ReferencedPropertyRecordHashSet* pidList = this->referencedPropertyRecords;",
          "1346:             if (pidList == nullptr)",
          "1347:             {",
          "1348:                 pidList = RecyclerNew(this->recycler, ReferencedPropertyRecordHashSet, this->recycler, 173);",
          "1349:                 this->referencedPropertyRecords = pidList;",
          "1350:             }",
          "1351:             return pidList;",
          "1352:         }",
          "1354:         ReferencedPropertyRecordHashSet * GetReferencedPropertyRecordList() const",
          "1355:         {",
          "1356:             return this->referencedPropertyRecords;",
          "1357:         }",
          "1359:         HRESULT ProfilerRegisterObject();",
          "1360:         HRESULT ProfilerRegisterArray();",
          "1361:         HRESULT ProfilerRegisterBoolean();",
          "1362:         HRESULT ProfilerRegisterDate();",
          "1363:         HRESULT ProfilerRegisterFunction();",
          "1364:         HRESULT ProfilerRegisterMath();",
          "1365:         HRESULT ProfilerRegisterNumber();",
          "1366:         HRESULT ProfilerRegisterString();",
          "1367:         HRESULT ProfilerRegisterRegExp();",
          "1368:         HRESULT ProfilerRegisterJSON();",
          "1369:         HRESULT ProfilerRegisterMap();",
          "1370:         HRESULT ProfilerRegisterSet();",
          "1371:         HRESULT ProfilerRegisterWeakMap();",
          "1372:         HRESULT ProfilerRegisterWeakSet();",
          "1373:         HRESULT ProfilerRegisterSymbol();",
          "1374:         HRESULT ProfilerRegisterIterator();",
          "1375:         HRESULT ProfilerRegisterArrayIterator();",
          "1376:         HRESULT ProfilerRegisterMapIterator();",
          "1377:         HRESULT ProfilerRegisterSetIterator();",
          "1378:         HRESULT ProfilerRegisterStringIterator();",
          "1379:         HRESULT ProfilerRegisterTypedArray();",
          "1380:         HRESULT ProfilerRegisterPromise();",
          "1381:         HRESULT ProfilerRegisterProxy();",
          "1382:         HRESULT ProfilerRegisterReflect();",
          "1383:         HRESULT ProfilerRegisterGenerator();",
          "1384:         HRESULT ProfilerRegisterSIMD();",
          "1385:         HRESULT ProfilerRegisterAtomics();",
          "1387: #ifdef IR_VIEWER",
          "1388:         HRESULT ProfilerRegisterIRViewer();",
          "1390:     };",
          "1391: }",
          "",
          "---------------"
        ],
        "lib/Runtime/Library/JavascriptLibraryBase.h||lib/Runtime/Library/JavascriptLibraryBase.h": [
          "File: lib/Runtime/Library/JavascriptLibraryBase.h -> lib/Runtime/Library/JavascriptLibraryBase.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "9: #pragma once",
          "11: namespace Js",
          "12: {",
          "13:     class EngineInterfaceObject;",
          "15:     class JavascriptLibraryBase : public FinalizableObject",
          "16:     {",
          "17:         friend class JavascriptLibrary;",
          "18:         friend class ScriptSite;",
          "19:     public:",
          "20:         JavascriptLibraryBase(GlobalObject* globalObject):",
          "21:             globalObject(globalObject)",
          "22:         {",
          "23:         }",
          "24:         Var GetPI() { return pi; }",
          "25:         Var GetNaN() { return nan; }",
          "26:         Var GetNegativeInfinite() { return negativeInfinite; }",
          "27:         Var GetPositiveInfinite() { return positiveInfinite; }",
          "28:         Var GetMaxValue() { return maxValue; }",
          "29:         Var GetMinValue() { return minValue; }",
          "30:         Var GetNegativeZero() { return negativeZero; }",
          "31:         RecyclableObject* GetUndefined() { return undefinedValue; }",
          "32:         RecyclableObject* GetNull() { return nullValue; }",
          "33:         JavascriptBoolean* GetTrue() { return booleanTrue; }",
          "34:         JavascriptBoolean* GetFalse() { return booleanFalse; }",
          "36:         JavascriptSymbol* GetSymbolHasInstance() { return symbolHasInstance; }",
          "37:         JavascriptSymbol* GetSymbolIsConcatSpreadable() { return symbolIsConcatSpreadable; }",
          "38:         JavascriptSymbol* GetSymbolIterator() { return symbolIterator; }",
          "39:         JavascriptSymbol* GetSymbolToPrimitive() { return symbolToPrimitive; }",
          "40:         JavascriptSymbol* GetSymbolToStringTag() { return symbolToStringTag; }",
          "41:         JavascriptSymbol* GetSymbolUnscopables() { return symbolUnscopables; }",
          "43:         JavascriptFunction* GetObjectConstructor() { return objectConstructor; }",
          "44:         JavascriptFunction* GetArrayConstructor() { return arrayConstructor; }",
          "45:         JavascriptFunction* GetBooleanConstructor() { return booleanConstructor; }",
          "46:         JavascriptFunction* GetDateConstructor() { return dateConstructor; }",
          "47:         JavascriptFunction* GetFunctionConstructor() { return functionConstructor; }",
          "48:         JavascriptFunction* GetNumberConstructor() { return numberConstructor; }",
          "49:         JavascriptRegExpConstructor* GetRegExpConstructor() { return regexConstructor; }",
          "50:         JavascriptFunction* GetStringConstructor() { return stringConstructor; }",
          "51:         JavascriptFunction* GetArrayBufferConstructor() { return arrayBufferConstructor; }",
          "52:         JavascriptFunction* GetPixelArrayConstructor() { return pixelArrayConstructor; }",
          "53:         JavascriptFunction* GetTypedArrayConstructor() const { return typedArrayConstructor; }",
          "54:         JavascriptFunction* GetInt8ArrayConstructor() { return Int8ArrayConstructor; }",
          "55:         JavascriptFunction* GetUint8ArrayConstructor() { return Uint8ArrayConstructor; }",
          "56:         JavascriptFunction* GetUint8ClampedArrayConstructor() { return Uint8ClampedArrayConstructor; }",
          "57:         JavascriptFunction* GetInt16ArrayConstructor() { return Int16ArrayConstructor; }",
          "58:         JavascriptFunction* GetUint16ArrayConstructor() { return Uint16ArrayConstructor; }",
          "59:         JavascriptFunction* GetInt32ArrayConstructor() { return Int32ArrayConstructor; }",
          "60:         JavascriptFunction* GetUint32ArrayConstructor() { return Uint32ArrayConstructor; }",
          "61:         JavascriptFunction* GetFloat32ArrayConstructor() { return Float32ArrayConstructor; }",
          "62:         JavascriptFunction* GetFloat64ArrayConstructor() { return Float64ArrayConstructor; }",
          "63:         JavascriptFunction* GetMapConstructor() { return mapConstructor; }",
          "64:         JavascriptFunction* GetSetConstructor() { return setConstructor; }",
          "65:         JavascriptFunction* GetWeakMapConstructor() { return weakMapConstructor; }",
          "66:         JavascriptFunction* GetWeakSetConstructor() { return weakSetConstructor; }",
          "67:         JavascriptFunction* GetSymbolConstructor() { return symbolConstructor; }",
          "68:         JavascriptFunction* GetProxyConstructor() const { return proxyConstructor; }",
          "69:         JavascriptFunction* GetPromiseConstructor() const { return promiseConstructor; }",
          "70:         JavascriptFunction* GetGeneratorFunctionConstructor() const { return generatorFunctionConstructor; }",
          "71:         JavascriptFunction* GetAsyncFunctionConstructor() const { return asyncFunctionConstructor; }",
          "73:         JavascriptFunction* GetErrorConstructor() const { return errorConstructor; }",
          "74:         JavascriptFunction* GetEvalErrorConstructor() const { return evalErrorConstructor; }",
          "75:         JavascriptFunction* GetRangeErrorConstructor() const { return rangeErrorConstructor; }",
          "76:         JavascriptFunction* GetReferenceErrorConstructor() const { return referenceErrorConstructor; }",
          "77:         JavascriptFunction* GetSyntaxErrorConstructor() const { return syntaxErrorConstructor; }",
          "78:         JavascriptFunction* GetTypeErrorConstructor() const { return typeErrorConstructor; }",
          "79:         JavascriptFunction* GetURIErrorConstructor() const { return uriErrorConstructor; }",
          "80:         JavascriptFunction* GetPromiseResolve() const { return promiseResolveFunction; }",
          "81:         JavascriptFunction* GetPromiseThen() const { return promiseThenFunction; }",
          "82:         JavascriptFunction* GetJSONStringify() const { return jsonStringifyFunction; }",
          "83:         JavascriptFunction* GetObjectFreeze() const { return objectFreezeFunction; }",
          "85:         DynamicObject* GetMathObject() { return mathObject; }",
          "86:         DynamicObject* GetJSONObject() { return JSONObject; }",
          "87: #ifdef ENABLE_INTL_OBJECT",
          "88:         DynamicObject* GetINTLObject() { return IntlObject; }",
          "89: #endif",
          "90: #if defined(ENABLE_INTL_OBJECT) || defined(ENABLE_PROJECTION)",
          "91:         EngineInterfaceObject* GetEngineInterfaceObject() { return engineInterfaceObject; }",
          "92: #endif",
          "94:         DynamicObject* GetArrayPrototype() { return arrayPrototype; }",
          "95:         DynamicObject* GetBooleanPrototype() { return booleanPrototype; }",
          "96:         DynamicObject* GetDatePrototype() { return datePrototype; }",
          "97:         DynamicObject* GetFunctionPrototype() { return functionPrototype; }",
          "98:         DynamicObject* GetNumberPrototype() { return numberPrototype; }",
          "99:         DynamicObject* GetSIMDBool8x16Prototype()  { return simdBool8x16Prototype;  }",
          "100:         DynamicObject* GetSIMDBool16x8Prototype()  { return simdBool16x8Prototype;  }",
          "101:         DynamicObject* GetSIMDBool32x4Prototype()  { return simdBool32x4Prototype;  }",
          "102:         DynamicObject* GetSIMDInt8x16Prototype()   { return simdInt8x16Prototype;   }",
          "103:         DynamicObject* GetSIMDInt16x8Prototype()   { return simdInt16x8Prototype;   }",
          "104:         DynamicObject* GetSIMDInt32x4Prototype()   { return simdInt32x4Prototype;   }",
          "105:         DynamicObject* GetSIMDUint8x16Prototype()  { return simdUint8x16Prototype;  }",
          "106:         DynamicObject* GetSIMDUint16x8Prototype()  { return simdUint16x8Prototype;  }",
          "107:         DynamicObject* GetSIMDUint32x4Prototype()  { return simdUint32x4Prototype;  }",
          "108:         DynamicObject* GetSIMDFloat32x4Prototype() { return simdFloat32x4Prototype; }",
          "109:         DynamicObject* GetSIMDFloat64x2Prototype() { return simdFloat64x2Prototype; }",
          "110:         ObjectPrototypeObject* GetObjectPrototypeObject() { return objectPrototype; }",
          "111:         DynamicObject* GetObjectPrototype();",
          "112:         DynamicObject* GetRegExpPrototype() { return regexPrototype; }",
          "113:         DynamicObject* GetStringPrototype() { return stringPrototype; }",
          "114:         DynamicObject* GetMapPrototype() { return mapPrototype; }",
          "115:         DynamicObject* GetSetPrototype() { return setPrototype; }",
          "116:         DynamicObject* GetWeakMapPrototype() { return weakMapPrototype; }",
          "117:         DynamicObject* GetWeakSetPrototype() { return weakSetPrototype; }",
          "118:         DynamicObject* GetSymbolPrototype() { return symbolPrototype; }",
          "119:         DynamicObject* GetArrayIteratorPrototype() const { return arrayIteratorPrototype; }",
          "120:         DynamicObject* GetMapIteratorPrototype() const { return mapIteratorPrototype; }",
          "121:         DynamicObject* GetSetIteratorPrototype() const { return setIteratorPrototype; }",
          "122:         DynamicObject* GetStringIteratorPrototype() const { return stringIteratorPrototype; }",
          "123:         DynamicObject* GetPromisePrototype() const { return promisePrototype; }",
          "124:         DynamicObject* GetGeneratorFunctionPrototype() const { return generatorFunctionPrototype; }",
          "125:         DynamicObject* GetGeneratorPrototype() const { return generatorPrototype; }",
          "126:         DynamicObject* GetAsyncFunctionPrototype() const { return asyncFunctionPrototype; }",
          "128:         DynamicObject* GetErrorPrototype() const { return errorPrototype; }",
          "129:         DynamicObject* GetEvalErrorPrototype() const { return evalErrorPrototype; }",
          "130:         DynamicObject* GetRangeErrorPrototype() const { return rangeErrorPrototype; }",
          "131:         DynamicObject* GetReferenceErrorPrototype() const { return referenceErrorPrototype; }",
          "132:         DynamicObject* GetSyntaxErrorPrototype() const { return syntaxErrorPrototype; }",
          "133:         DynamicObject* GetTypeErrorPrototype() const { return typeErrorPrototype; }",
          "134:         DynamicObject* GetURIErrorPrototype() const { return uriErrorPrototype; }",
          "136:     protected:",
          "137:         Field(GlobalObject*) globalObject;",
          "138:         Field(RuntimeFunction*) mapConstructor;",
          "139:         Field(RuntimeFunction*) setConstructor;",
          "140:         Field(RuntimeFunction*) weakMapConstructor;",
          "141:         Field(RuntimeFunction*) weakSetConstructor;",
          "142:         Field(RuntimeFunction*) arrayConstructor;",
          "143:         Field(RuntimeFunction*) typedArrayConstructor;",
          "144:         Field(RuntimeFunction*) Int8ArrayConstructor;",
          "145:         Field(RuntimeFunction*) Uint8ArrayConstructor;",
          "146:         Field(RuntimeFunction*) Uint8ClampedArrayConstructor;",
          "147:         Field(RuntimeFunction*) Int16ArrayConstructor;",
          "148:         Field(RuntimeFunction*) Uint16ArrayConstructor;",
          "149:         Field(RuntimeFunction*) Int32ArrayConstructor;",
          "150:         Field(RuntimeFunction*) Uint32ArrayConstructor;",
          "151:         Field(RuntimeFunction*) Float32ArrayConstructor;",
          "152:         Field(RuntimeFunction*) Float64ArrayConstructor;",
          "153:         Field(RuntimeFunction*) arrayBufferConstructor;",
          "154:         Field(RuntimeFunction*) dataViewConstructor;",
          "155:         Field(RuntimeFunction*) booleanConstructor;",
          "156:         Field(RuntimeFunction*) dateConstructor;",
          "157:         Field(RuntimeFunction*) functionConstructor;",
          "158:         Field(RuntimeFunction*) numberConstructor;",
          "159:         Field(RuntimeFunction*) objectConstructor;",
          "160:         Field(RuntimeFunction*) symbolConstructor;",
          "161:         Field(JavascriptRegExpConstructor*) regexConstructor;",
          "162:         Field(RuntimeFunction*) stringConstructor;",
          "163:         Field(RuntimeFunction*) pixelArrayConstructor;",
          "165:         Field(RuntimeFunction*) errorConstructor;",
          "166:         Field(RuntimeFunction*) evalErrorConstructor;",
          "167:         Field(RuntimeFunction*) rangeErrorConstructor;",
          "168:         Field(RuntimeFunction*) referenceErrorConstructor;",
          "169:         Field(RuntimeFunction*) syntaxErrorConstructor;",
          "170:         Field(RuntimeFunction*) typeErrorConstructor;",
          "171:         Field(RuntimeFunction*) uriErrorConstructor;",
          "172:         Field(RuntimeFunction*) proxyConstructor;",
          "173:         Field(RuntimeFunction*) promiseConstructor;",
          "174:         Field(RuntimeFunction*) generatorFunctionConstructor;",
          "175:         Field(RuntimeFunction*) asyncFunctionConstructor;",
          "177:         Field(JavascriptFunction*) defaultAccessorFunction;",
          "178:         Field(JavascriptFunction*) stackTraceAccessorFunction;",
          "179:         Field(JavascriptFunction*) throwTypeErrorRestrictedPropertyAccessorFunction;",
          "180:         Field(JavascriptFunction*) debugObjectNonUserGetterFunction;",
          "181:         Field(JavascriptFunction*) debugObjectNonUserSetterFunction;",
          "182:         Field(JavascriptFunction*) debugObjectDebugModeGetterFunction;",
          "183:         Field(JavascriptFunction*) __proto__getterFunction;",
          "184:         Field(JavascriptFunction*) __proto__setterFunction;",
          "185:         Field(JavascriptFunction*) arrayIteratorPrototypeBuiltinNextFunction;",
          "186:         Field(JavascriptFunction*) promiseResolveFunction;",
          "187:         Field(JavascriptFunction*) promiseThenFunction;",
          "188:         Field(JavascriptFunction*) jsonStringifyFunction;",
          "189:         Field(JavascriptFunction*) objectFreezeFunction;",
          "190:         Field(DynamicObject*) mathObject;",
          "192:         Field(DynamicObject*) simdObject;",
          "194:         Field(DynamicObject*) debugObject;",
          "195:         Field(DynamicObject*) JSONObject;",
          "196: #ifdef ENABLE_INTL_OBJECT",
          "197:         Field(DynamicObject*) IntlObject;",
          "198: #endif",
          "199: #if defined(ENABLE_INTL_OBJECT) || defined(ENABLE_PROJECTION)",
          "200:         Field(EngineInterfaceObject*) engineInterfaceObject;",
          "201: #endif",
          "202:         Field(DynamicObject*) reflectObject;",
          "204:         Field(DynamicObject*) arrayPrototype;",
          "206:         Field(DynamicObject*) typedArrayPrototype;",
          "207:         Field(DynamicObject*) Int8ArrayPrototype;",
          "208:         Field(DynamicObject*) Uint8ArrayPrototype;",
          "209:         Field(DynamicObject*) Uint8ClampedArrayPrototype;",
          "210:         Field(DynamicObject*) Int16ArrayPrototype;",
          "211:         Field(DynamicObject*) Uint16ArrayPrototype;",
          "212:         Field(DynamicObject*) Int32ArrayPrototype;",
          "213:         Field(DynamicObject*) Uint32ArrayPrototype;",
          "214:         Field(DynamicObject*) Float32ArrayPrototype;",
          "215:         Field(DynamicObject*) Float64ArrayPrototype;",
          "216:         Field(DynamicObject*) Int64ArrayPrototype;",
          "217:         Field(DynamicObject*) Uint64ArrayPrototype;",
          "218:         Field(DynamicObject*) BoolArrayPrototype;",
          "219:         Field(DynamicObject*) CharArrayPrototype;",
          "220:         Field(DynamicObject*) arrayBufferPrototype;",
          "221:         Field(DynamicObject*) dataViewPrototype;",
          "222:         Field(DynamicObject*) pixelArrayPrototype;",
          "223:         Field(DynamicObject*) booleanPrototype;",
          "224:         Field(DynamicObject*) datePrototype;",
          "225:         Field(DynamicObject*) functionPrototype;",
          "226:         Field(DynamicObject*) numberPrototype;",
          "227:         Field(ObjectPrototypeObject*) objectPrototype;",
          "228:         Field(DynamicObject*) regexPrototype;",
          "229:         Field(DynamicObject*) stringPrototype;",
          "230:         Field(DynamicObject*) mapPrototype;",
          "231:         Field(DynamicObject*) setPrototype;",
          "232:         Field(DynamicObject*) weakMapPrototype;",
          "233:         Field(DynamicObject*) weakSetPrototype;",
          "234:         Field(DynamicObject*) symbolPrototype;",
          "235:         Field(DynamicObject*) iteratorPrototype;           // aka %IteratorPrototype%",
          "236:         Field(DynamicObject*) arrayIteratorPrototype;",
          "237:         Field(DynamicObject*) mapIteratorPrototype;",
          "238:         Field(DynamicObject*) setIteratorPrototype;",
          "239:         Field(DynamicObject*) stringIteratorPrototype;",
          "240:         Field(DynamicObject*) promisePrototype;",
          "241:         Field(DynamicObject*) generatorFunctionPrototype;  // aka %Generator%",
          "242:         Field(DynamicObject*) generatorPrototype;          // aka %GeneratorPrototype%",
          "243:         Field(DynamicObject*) asyncFunctionPrototype;      // aka %AsyncFunctionPrototype%",
          "245:         Field(DynamicObject*) errorPrototype;",
          "246:         Field(DynamicObject*) evalErrorPrototype;",
          "247:         Field(DynamicObject*) rangeErrorPrototype;",
          "248:         Field(DynamicObject*) referenceErrorPrototype;",
          "249:         Field(DynamicObject*) syntaxErrorPrototype;",
          "250:         Field(DynamicObject*) typeErrorPrototype;",
          "251:         Field(DynamicObject*) uriErrorPrototype;",
          "254:         Field(DynamicObject*) simdBool8x16Prototype;",
          "255:         Field(DynamicObject*) simdBool16x8Prototype;",
          "256:         Field(DynamicObject*) simdBool32x4Prototype;",
          "257:         Field(DynamicObject*) simdInt8x16Prototype;",
          "258:         Field(DynamicObject*) simdInt16x8Prototype;",
          "259:         Field(DynamicObject*) simdInt32x4Prototype;",
          "260:         Field(DynamicObject*) simdUint8x16Prototype;",
          "261:         Field(DynamicObject*) simdUint16x8Prototype;",
          "262:         Field(DynamicObject*) simdUint32x4Prototype;",
          "263:         Field(DynamicObject*) simdFloat32x4Prototype;",
          "264:         Field(DynamicObject*) simdFloat64x2Prototype;",
          "266:         Field(JavascriptBoolean*) booleanTrue;",
          "267:         Field(JavascriptBoolean*) booleanFalse;",
          "269:         Field(Var) nan;",
          "270:         Field(Var) negativeInfinite;",
          "271:         Field(Var) positiveInfinite;",
          "272:         Field(Var) pi;",
          "273:         Field(Var) minValue;",
          "274:         Field(Var) maxValue;",
          "275:         Field(Var) negativeZero;",
          "276:         Field(RecyclableObject*) undefinedValue;",
          "277:         Field(RecyclableObject*) nullValue;",
          "279:         Field(JavascriptSymbol*) symbolHasInstance;",
          "280:         Field(JavascriptSymbol*) symbolIsConcatSpreadable;",
          "281:         Field(JavascriptSymbol*) symbolIterator;",
          "282:         Field(JavascriptSymbol*) symbolSpecies;",
          "283:         Field(JavascriptSymbol*) symbolToPrimitive;",
          "284:         Field(JavascriptSymbol*) symbolToStringTag;",
          "285:         Field(JavascriptSymbol*) symbolUnscopables;",
          "287:     public:",
          "288:         Field(ScriptContext*) scriptContext;",
          "290:     private:",
          "291:         virtual void Dispose(bool isShutdown) override;",
          "292:         virtual void Finalize(bool isShutdown) override;",
          "293:         virtual void Mark(Recycler *recycler) override { AssertMsg(false, \"Mark called on object that isn't TrackableObject\"); }",
          "295:     };",
          "296: }",
          "",
          "[Added Lines]",
          "9: #pragma once",
          "11: namespace Js",
          "12: {",
          "13:     class EngineInterfaceObject;",
          "15:     class JavascriptLibraryBase : public FinalizableObject",
          "16:     {",
          "17:         friend class JavascriptLibrary;",
          "18:         friend class ScriptSite;",
          "19:     public:",
          "20:         JavascriptLibraryBase(GlobalObject* globalObject):",
          "21:             globalObject(globalObject)",
          "22:         {",
          "23:         }",
          "24:         Var GetPI() { return pi; }",
          "25:         Var GetNaN() { return nan; }",
          "26:         Var GetNegativeInfinite() { return negativeInfinite; }",
          "27:         Var GetPositiveInfinite() { return positiveInfinite; }",
          "28:         Var GetMaxValue() { return maxValue; }",
          "29:         Var GetMinValue() { return minValue; }",
          "30:         Var GetNegativeZero() { return negativeZero; }",
          "31:         RecyclableObject* GetUndefined() { return undefinedValue; }",
          "32:         RecyclableObject* GetNull() { return nullValue; }",
          "33:         JavascriptBoolean* GetTrue() { return booleanTrue; }",
          "34:         JavascriptBoolean* GetFalse() { return booleanFalse; }",
          "36:         JavascriptSymbol* GetSymbolHasInstance() { return symbolHasInstance; }",
          "37:         JavascriptSymbol* GetSymbolIsConcatSpreadable() { return symbolIsConcatSpreadable; }",
          "38:         JavascriptSymbol* GetSymbolIterator() { return symbolIterator; }",
          "39:         JavascriptSymbol* GetSymbolToPrimitive() { return symbolToPrimitive; }",
          "40:         JavascriptSymbol* GetSymbolToStringTag() { return symbolToStringTag; }",
          "41:         JavascriptSymbol* GetSymbolUnscopables() { return symbolUnscopables; }",
          "43:         JavascriptFunction* GetObjectConstructor() { return objectConstructor; }",
          "44:         JavascriptFunction* GetArrayConstructor() { return arrayConstructor; }",
          "45:         JavascriptFunction* GetBooleanConstructor() { return booleanConstructor; }",
          "46:         JavascriptFunction* GetDateConstructor() { return dateConstructor; }",
          "47:         JavascriptFunction* GetFunctionConstructor() { return functionConstructor; }",
          "48:         JavascriptFunction* GetNumberConstructor() { return numberConstructor; }",
          "49:         JavascriptRegExpConstructor* GetRegExpConstructor() { return regexConstructor; }",
          "50:         JavascriptFunction* GetStringConstructor() { return stringConstructor; }",
          "51:         JavascriptFunction* GetArrayBufferConstructor() { return arrayBufferConstructor; }",
          "52:         JavascriptFunction* GetPixelArrayConstructor() { return pixelArrayConstructor; }",
          "53:         JavascriptFunction* GetTypedArrayConstructor() const { return typedArrayConstructor; }",
          "54:         JavascriptFunction* GetInt8ArrayConstructor() { return Int8ArrayConstructor; }",
          "55:         JavascriptFunction* GetUint8ArrayConstructor() { return Uint8ArrayConstructor; }",
          "56:         JavascriptFunction* GetUint8ClampedArrayConstructor() { return Uint8ClampedArrayConstructor; }",
          "57:         JavascriptFunction* GetInt16ArrayConstructor() { return Int16ArrayConstructor; }",
          "58:         JavascriptFunction* GetUint16ArrayConstructor() { return Uint16ArrayConstructor; }",
          "59:         JavascriptFunction* GetInt32ArrayConstructor() { return Int32ArrayConstructor; }",
          "60:         JavascriptFunction* GetUint32ArrayConstructor() { return Uint32ArrayConstructor; }",
          "61:         JavascriptFunction* GetFloat32ArrayConstructor() { return Float32ArrayConstructor; }",
          "62:         JavascriptFunction* GetFloat64ArrayConstructor() { return Float64ArrayConstructor; }",
          "63:         JavascriptFunction* GetMapConstructor() { return mapConstructor; }",
          "64:         JavascriptFunction* GetSetConstructor() { return setConstructor; }",
          "65:         JavascriptFunction* GetWeakMapConstructor() { return weakMapConstructor; }",
          "66:         JavascriptFunction* GetWeakSetConstructor() { return weakSetConstructor; }",
          "67:         JavascriptFunction* GetSymbolConstructor() { return symbolConstructor; }",
          "68:         JavascriptFunction* GetProxyConstructor() const { return proxyConstructor; }",
          "69:         JavascriptFunction* GetPromiseConstructor() const { return promiseConstructor; }",
          "70:         JavascriptFunction* GetGeneratorFunctionConstructor() const { return generatorFunctionConstructor; }",
          "71:         JavascriptFunction* GetAsyncFunctionConstructor() const { return asyncFunctionConstructor; }",
          "73:         JavascriptFunction* GetErrorConstructor() const { return errorConstructor; }",
          "74:         JavascriptFunction* GetEvalErrorConstructor() const { return evalErrorConstructor; }",
          "75:         JavascriptFunction* GetRangeErrorConstructor() const { return rangeErrorConstructor; }",
          "76:         JavascriptFunction* GetReferenceErrorConstructor() const { return referenceErrorConstructor; }",
          "77:         JavascriptFunction* GetSyntaxErrorConstructor() const { return syntaxErrorConstructor; }",
          "78:         JavascriptFunction* GetTypeErrorConstructor() const { return typeErrorConstructor; }",
          "79:         JavascriptFunction* GetURIErrorConstructor() const { return uriErrorConstructor; }",
          "80:         JavascriptFunction* GetPromiseResolve() const { return promiseResolveFunction; }",
          "81:         JavascriptFunction* GetPromiseThen() const { return promiseThenFunction; }",
          "82:         JavascriptFunction* GetJSONStringify() const { return jsonStringifyFunction; }",
          "83:         JavascriptFunction* GetObjectFreeze() const { return objectFreezeFunction; }",
          "85:         DynamicObject* GetMathObject() { return mathObject; }",
          "86:         DynamicObject* GetJSONObject() { return JSONObject; }",
          "87: #ifdef ENABLE_INTL_OBJECT",
          "88:         DynamicObject* GetINTLObject() { return IntlObject; }",
          "89: #endif",
          "90: #if defined(ENABLE_INTL_OBJECT) || defined(ENABLE_PROJECTION)",
          "91:         EngineInterfaceObject* GetEngineInterfaceObject() { return engineInterfaceObject; }",
          "92: #endif",
          "94:         DynamicObject* GetArrayPrototype() { return arrayPrototype; }",
          "95:         DynamicObject* GetBooleanPrototype() { return booleanPrototype; }",
          "96:         DynamicObject* GetDatePrototype() { return datePrototype; }",
          "97:         DynamicObject* GetFunctionPrototype() { return functionPrototype; }",
          "98:         DynamicObject* GetNumberPrototype() { return numberPrototype; }",
          "99:         DynamicObject* GetSIMDBool8x16Prototype()  { return simdBool8x16Prototype;  }",
          "100:         DynamicObject* GetSIMDBool16x8Prototype()  { return simdBool16x8Prototype;  }",
          "101:         DynamicObject* GetSIMDBool32x4Prototype()  { return simdBool32x4Prototype;  }",
          "102:         DynamicObject* GetSIMDInt8x16Prototype()   { return simdInt8x16Prototype;   }",
          "103:         DynamicObject* GetSIMDInt16x8Prototype()   { return simdInt16x8Prototype;   }",
          "104:         DynamicObject* GetSIMDInt32x4Prototype()   { return simdInt32x4Prototype;   }",
          "105:         DynamicObject* GetSIMDUint8x16Prototype()  { return simdUint8x16Prototype;  }",
          "106:         DynamicObject* GetSIMDUint16x8Prototype()  { return simdUint16x8Prototype;  }",
          "107:         DynamicObject* GetSIMDUint32x4Prototype()  { return simdUint32x4Prototype;  }",
          "108:         DynamicObject* GetSIMDFloat32x4Prototype() { return simdFloat32x4Prototype; }",
          "109:         DynamicObject* GetSIMDFloat64x2Prototype() { return simdFloat64x2Prototype; }",
          "110:         ObjectPrototypeObject* GetObjectPrototypeObject() { return objectPrototype; }",
          "111:         DynamicObject* GetObjectPrototype();",
          "112:         DynamicObject* GetRegExpPrototype() { return regexPrototype; }",
          "113:         DynamicObject* GetStringPrototype() { return stringPrototype; }",
          "114:         DynamicObject* GetMapPrototype() { return mapPrototype; }",
          "115:         DynamicObject* GetSetPrototype() { return setPrototype; }",
          "116:         DynamicObject* GetWeakMapPrototype() { return weakMapPrototype; }",
          "117:         DynamicObject* GetWeakSetPrototype() { return weakSetPrototype; }",
          "118:         DynamicObject* GetSymbolPrototype() { return symbolPrototype; }",
          "119:         DynamicObject* GetArrayIteratorPrototype() const { return arrayIteratorPrototype; }",
          "120:         DynamicObject* GetMapIteratorPrototype() const { return mapIteratorPrototype; }",
          "121:         DynamicObject* GetSetIteratorPrototype() const { return setIteratorPrototype; }",
          "122:         DynamicObject* GetStringIteratorPrototype() const { return stringIteratorPrototype; }",
          "123:         DynamicObject* GetPromisePrototype() const { return promisePrototype; }",
          "124:         DynamicObject* GetGeneratorFunctionPrototype() const { return generatorFunctionPrototype; }",
          "125:         DynamicObject* GetGeneratorPrototype() const { return generatorPrototype; }",
          "126:         DynamicObject* GetAsyncFunctionPrototype() const { return asyncFunctionPrototype; }",
          "128:         DynamicObject* GetErrorPrototype() const { return errorPrototype; }",
          "129:         DynamicObject* GetEvalErrorPrototype() const { return evalErrorPrototype; }",
          "130:         DynamicObject* GetRangeErrorPrototype() const { return rangeErrorPrototype; }",
          "131:         DynamicObject* GetReferenceErrorPrototype() const { return referenceErrorPrototype; }",
          "132:         DynamicObject* GetSyntaxErrorPrototype() const { return syntaxErrorPrototype; }",
          "133:         DynamicObject* GetTypeErrorPrototype() const { return typeErrorPrototype; }",
          "134:         DynamicObject* GetURIErrorPrototype() const { return uriErrorPrototype; }",
          "136:     protected:",
          "137:         Field(GlobalObject*) globalObject;",
          "138:         Field(RuntimeFunction*) mapConstructor;",
          "139:         Field(RuntimeFunction*) setConstructor;",
          "140:         Field(RuntimeFunction*) weakMapConstructor;",
          "141:         Field(RuntimeFunction*) weakSetConstructor;",
          "142:         Field(RuntimeFunction*) arrayConstructor;",
          "143:         Field(RuntimeFunction*) typedArrayConstructor;",
          "144:         Field(RuntimeFunction*) Int8ArrayConstructor;",
          "145:         Field(RuntimeFunction*) Uint8ArrayConstructor;",
          "146:         Field(RuntimeFunction*) Uint8ClampedArrayConstructor;",
          "147:         Field(RuntimeFunction*) Int16ArrayConstructor;",
          "148:         Field(RuntimeFunction*) Uint16ArrayConstructor;",
          "149:         Field(RuntimeFunction*) Int32ArrayConstructor;",
          "150:         Field(RuntimeFunction*) Uint32ArrayConstructor;",
          "151:         Field(RuntimeFunction*) Float32ArrayConstructor;",
          "152:         Field(RuntimeFunction*) Float64ArrayConstructor;",
          "153:         Field(RuntimeFunction*) arrayBufferConstructor;",
          "154:         Field(RuntimeFunction*) dataViewConstructor;",
          "155:         Field(RuntimeFunction*) booleanConstructor;",
          "156:         Field(RuntimeFunction*) dateConstructor;",
          "157:         Field(RuntimeFunction*) functionConstructor;",
          "158:         Field(RuntimeFunction*) numberConstructor;",
          "159:         Field(RuntimeFunction*) objectConstructor;",
          "160:         Field(RuntimeFunction*) symbolConstructor;",
          "161:         Field(JavascriptRegExpConstructor*) regexConstructor;",
          "162:         Field(RuntimeFunction*) stringConstructor;",
          "163:         Field(RuntimeFunction*) pixelArrayConstructor;",
          "165:         Field(RuntimeFunction*) errorConstructor;",
          "166:         Field(RuntimeFunction*) evalErrorConstructor;",
          "167:         Field(RuntimeFunction*) rangeErrorConstructor;",
          "168:         Field(RuntimeFunction*) referenceErrorConstructor;",
          "169:         Field(RuntimeFunction*) syntaxErrorConstructor;",
          "170:         Field(RuntimeFunction*) typeErrorConstructor;",
          "171:         Field(RuntimeFunction*) uriErrorConstructor;",
          "172:         Field(RuntimeFunction*) proxyConstructor;",
          "173:         Field(RuntimeFunction*) promiseConstructor;",
          "174:         Field(RuntimeFunction*) generatorFunctionConstructor;",
          "175:         Field(RuntimeFunction*) asyncFunctionConstructor;",
          "177:         Field(JavascriptFunction*) defaultAccessorFunction;",
          "178:         Field(JavascriptFunction*) stackTraceAccessorFunction;",
          "179:         Field(JavascriptFunction*) throwTypeErrorRestrictedPropertyAccessorFunction;",
          "180:         Field(JavascriptFunction*) debugObjectNonUserGetterFunction;",
          "181:         Field(JavascriptFunction*) debugObjectNonUserSetterFunction;",
          "182:         Field(JavascriptFunction*) debugObjectDebugModeGetterFunction;",
          "183:         Field(JavascriptFunction*) __proto__getterFunction;",
          "184:         Field(JavascriptFunction*) __proto__setterFunction;",
          "185:         Field(JavascriptFunction*) arrayIteratorPrototypeBuiltinNextFunction;",
          "186:         Field(JavascriptFunction*) promiseResolveFunction;",
          "187:         Field(JavascriptFunction*) promiseThenFunction;",
          "188:         Field(JavascriptFunction*) jsonStringifyFunction;",
          "189:         Field(JavascriptFunction*) objectFreezeFunction;",
          "190:         Field(DynamicObject*) mathObject;",
          "192:         Field(DynamicObject*) simdObject;",
          "194:         Field(DynamicObject*) debugObject;",
          "195:         Field(DynamicObject*) JSONObject;",
          "196: #ifdef ENABLE_INTL_OBJECT",
          "197:         Field(DynamicObject*) IntlObject;",
          "198: #endif",
          "199: #if defined(ENABLE_INTL_OBJECT) || defined(ENABLE_PROJECTION)",
          "200:         Field(EngineInterfaceObject*) engineInterfaceObject;",
          "201: #endif",
          "202:         Field(DynamicObject*) reflectObject;",
          "204:         Field(DynamicObject*) arrayPrototype;",
          "206:         Field(DynamicObject*) typedArrayPrototype;",
          "207:         Field(DynamicObject*) Int8ArrayPrototype;",
          "208:         Field(DynamicObject*) Uint8ArrayPrototype;",
          "209:         Field(DynamicObject*) Uint8ClampedArrayPrototype;",
          "210:         Field(DynamicObject*) Int16ArrayPrototype;",
          "211:         Field(DynamicObject*) Uint16ArrayPrototype;",
          "212:         Field(DynamicObject*) Int32ArrayPrototype;",
          "213:         Field(DynamicObject*) Uint32ArrayPrototype;",
          "214:         Field(DynamicObject*) Float32ArrayPrototype;",
          "215:         Field(DynamicObject*) Float64ArrayPrototype;",
          "216:         Field(DynamicObject*) Int64ArrayPrototype;",
          "217:         Field(DynamicObject*) Uint64ArrayPrototype;",
          "218:         Field(DynamicObject*) BoolArrayPrototype;",
          "219:         Field(DynamicObject*) CharArrayPrototype;",
          "220:         Field(DynamicObject*) arrayBufferPrototype;",
          "221:         Field(DynamicObject*) dataViewPrototype;",
          "222:         Field(DynamicObject*) pixelArrayPrototype;",
          "223:         Field(DynamicObject*) booleanPrototype;",
          "224:         Field(DynamicObject*) datePrototype;",
          "225:         Field(DynamicObject*) functionPrototype;",
          "226:         Field(DynamicObject*) numberPrototype;",
          "227:         Field(ObjectPrototypeObject*) objectPrototype;",
          "228:         Field(DynamicObject*) regexPrototype;",
          "229:         Field(DynamicObject*) stringPrototype;",
          "230:         Field(DynamicObject*) mapPrototype;",
          "231:         Field(DynamicObject*) setPrototype;",
          "232:         Field(DynamicObject*) weakMapPrototype;",
          "233:         Field(DynamicObject*) weakSetPrototype;",
          "234:         Field(DynamicObject*) symbolPrototype;",
          "235:         Field(DynamicObject*) iteratorPrototype;           // aka %IteratorPrototype%",
          "236:         Field(DynamicObject*) arrayIteratorPrototype;",
          "237:         Field(DynamicObject*) mapIteratorPrototype;",
          "238:         Field(DynamicObject*) setIteratorPrototype;",
          "239:         Field(DynamicObject*) stringIteratorPrototype;",
          "240:         Field(DynamicObject*) promisePrototype;",
          "241:         Field(DynamicObject*) generatorFunctionPrototype;  // aka %Generator%",
          "242:         Field(DynamicObject*) generatorPrototype;          // aka %GeneratorPrototype%",
          "243:         Field(DynamicObject*) asyncFunctionPrototype;      // aka %AsyncFunctionPrototype%",
          "245:         Field(DynamicObject*) errorPrototype;",
          "246:         Field(DynamicObject*) evalErrorPrototype;",
          "247:         Field(DynamicObject*) rangeErrorPrototype;",
          "248:         Field(DynamicObject*) referenceErrorPrototype;",
          "249:         Field(DynamicObject*) syntaxErrorPrototype;",
          "250:         Field(DynamicObject*) typeErrorPrototype;",
          "251:         Field(DynamicObject*) uriErrorPrototype;",
          "254:         Field(DynamicObject*) simdBool8x16Prototype;",
          "255:         Field(DynamicObject*) simdBool16x8Prototype;",
          "256:         Field(DynamicObject*) simdBool32x4Prototype;",
          "257:         Field(DynamicObject*) simdInt8x16Prototype;",
          "258:         Field(DynamicObject*) simdInt16x8Prototype;",
          "259:         Field(DynamicObject*) simdInt32x4Prototype;",
          "260:         Field(DynamicObject*) simdUint8x16Prototype;",
          "261:         Field(DynamicObject*) simdUint16x8Prototype;",
          "262:         Field(DynamicObject*) simdUint32x4Prototype;",
          "263:         Field(DynamicObject*) simdFloat32x4Prototype;",
          "264:         Field(DynamicObject*) simdFloat64x2Prototype;",
          "266:         Field(JavascriptBoolean*) booleanTrue;",
          "267:         Field(JavascriptBoolean*) booleanFalse;",
          "269:         Field(Var) nan;",
          "270:         Field(Var) negativeInfinite;",
          "271:         Field(Var) positiveInfinite;",
          "272:         Field(Var) pi;",
          "273:         Field(Var) minValue;",
          "274:         Field(Var) maxValue;",
          "275:         Field(Var) negativeZero;",
          "276:         Field(RecyclableObject*) undefinedValue;",
          "277:         Field(RecyclableObject*) nullValue;",
          "279:         Field(JavascriptSymbol*) symbolHasInstance;",
          "280:         Field(JavascriptSymbol*) symbolIsConcatSpreadable;",
          "281:         Field(JavascriptSymbol*) symbolIterator;",
          "282:         Field(JavascriptSymbol*) symbolSpecies;",
          "283:         Field(JavascriptSymbol*) symbolToPrimitive;",
          "284:         Field(JavascriptSymbol*) symbolToStringTag;",
          "285:         Field(JavascriptSymbol*) symbolUnscopables;",
          "287:     public:",
          "288:         Field(ScriptContext*) scriptContext;",
          "290:     private:",
          "291:         virtual void Dispose(bool isShutdown) override;",
          "292:         virtual void Finalize(bool isShutdown) override;",
          "293:         virtual void Mark(Recycler *recycler) override { AssertMsg(false, \"Mark called on object that isn't TrackableObject\"); }",
          "295:     };",
          "296: }",
          "",
          "---------------"
        ],
        "lib/Runtime/Types/SpreadArgument.h||lib/Runtime/Types/SpreadArgument.h": [
          "File: lib/Runtime/Types/SpreadArgument.h -> lib/Runtime/Types/SpreadArgument.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "5: #pragma once",
          "6: namespace Js",
          "7: {",
          "9:     class SpreadArgument : public DynamicObject",
          "10:     {",
          "11:     private:",
          "12:         typedef JsUtil::List<Var, Recycler> VarList;",
          "13:         Field(VarList*) iteratorIndices;",
          "15:         void AssertAndFailFast() { AssertMsg(false, \"This function should not be invoked\"); Js::Throw::InternalError();}",
          "16:     protected:",
          "17:         DEFINE_VTABLE_CTOR(SpreadArgument, DynamicObject);",
          "18:         DEFINE_MARSHAL_OBJECT_TO_SCRIPT_CONTEXT(SpreadArgument);",
          "20:     public:",
          "21:         static bool Is(Var aValue);",
          "22:         static SpreadArgument* FromVar(Var value);",
          "23:         SpreadArgument(Var iterator, bool useDirectCall, DynamicType * type);",
          "24:         const Var* GetArgumentSpread() const { return iteratorIndices ? iteratorIndices->GetBuffer() : nullptr; }",
          "25:         uint GetArgumentSpreadCount()  const { return iteratorIndices ? iteratorIndices->Count() : 0; }",
          "28:         virtual BOOL HasProperty(PropertyId propertyId) override { AssertAndFailFast();  return FALSE; };",
          "29:         virtual BOOL HasOwnProperty(PropertyId propertyId) override { AssertAndFailFast(); return FALSE; };",
          "30:         virtual BOOL SetProperty(PropertyId propertyId, Var value, PropertyOperationFlags flags, PropertyValueInfo* info) override { AssertAndFailFast(); return FALSE; };",
          "31:         virtual BOOL GetProperty(Var originalInstance, PropertyId propertyId, Var* value, PropertyValueInfo* info, ScriptContext* requestContext) override { AssertAndFailFast(); return FALSE; };",
          "32:         virtual BOOL DeleteProperty(PropertyId propertyId, PropertyOperationFlags flags) override{ AssertAndFailFast(); return FALSE;};",
          "33:         virtual BOOL DeleteProperty(JavascriptString * propertyNameString, PropertyOperationFlags flags) override { AssertAndFailFast(); return FALSE; };",
          "34:         virtual BOOL GetPropertyReference(Var originalInstance, PropertyId propertyId, Var* value, PropertyValueInfo* info, ScriptContext* requestContext) override { AssertAndFailFast(); return None; };",
          "35:         virtual BOOL SetProperty(JavascriptString* propertyNameString, Var value, PropertyOperationFlags flags, PropertyValueInfo* info) override { AssertAndFailFast(); return FALSE; };",
          "36:         virtual BOOL GetProperty(Var originalInstance, JavascriptString* propertyNameString, Var* value, PropertyValueInfo* info, ScriptContext* requestContext) override { AssertAndFailFast(); return FALSE; };",
          "37:         virtual DescriptorFlags GetSetter(PropertyId propertyId, Var *setterValue, PropertyValueInfo* info, ScriptContext* requestContext) override { AssertAndFailFast(); return None; };",
          "38:         virtual DescriptorFlags GetSetter(JavascriptString* propertyNameString, Var *setterValue, PropertyValueInfo* info, ScriptContext* requestContext) override { AssertAndFailFast(); return None; };",
          "39:         virtual int GetPropertyCount() override { AssertAndFailFast(); return 0; };",
          "40:         virtual PropertyId GetPropertyId(PropertyIndex index) override { AssertAndFailFast();  return Constants::NoProperty; };",
          "41:         virtual PropertyId GetPropertyId(BigPropertyIndex index) override { AssertAndFailFast(); return Constants::NoProperty;; };",
          "42:         virtual BOOL SetInternalProperty(PropertyId internalPropertyId, Var value, PropertyOperationFlags flags, PropertyValueInfo* info) override { AssertAndFailFast(); return FALSE; };",
          "43:         virtual BOOL InitProperty(PropertyId propertyId, Var value, PropertyOperationFlags flags = PropertyOperation_None, PropertyValueInfo* info = NULL) override { AssertAndFailFast(); return FALSE; };",
          "44:         virtual BOOL SetPropertyWithAttributes(PropertyId propertyId, Var value, PropertyAttributes attributes, PropertyValueInfo* info, PropertyOperationFlags flags = PropertyOperation_None, SideEffects possibleSideEffects = SideEffects_Any) override { AssertAndFailFast(); return FALSE; };",
          "45:         virtual BOOL IsFixedProperty(PropertyId propertyId) override { AssertAndFailFast(); return FALSE; };",
          "46:         virtual BOOL HasItem(uint32 index) override { AssertAndFailFast(); return FALSE; };",
          "47:         virtual BOOL HasOwnItem(uint32 index) override { AssertAndFailFast(); return FALSE; };",
          "48:         virtual BOOL GetItem(Var originalInstance, uint32 index, Var* value, ScriptContext * requestContext) override { AssertAndFailFast(); return FALSE; };",
          "49:         virtual BOOL GetItemReference(Var originalInstance, uint32 index, Var* value, ScriptContext * requestContext) override { AssertAndFailFast(); return FALSE; };",
          "50:         virtual DescriptorFlags GetItemSetter(uint32 index, Var* setterValue, ScriptContext* requestContext) override { AssertAndFailFast(); return None; };",
          "51:         virtual BOOL SetItem(uint32 index, Var value, PropertyOperationFlags flags) override { AssertAndFailFast(); return FALSE; };",
          "52:         virtual BOOL DeleteItem(uint32 index, PropertyOperationFlags flags) override { AssertAndFailFast(); return FALSE; };",
          "53:         virtual BOOL ToPrimitive(JavascriptHint hint, Var* result, ScriptContext * requestContext) override { AssertAndFailFast(); return FALSE; };",
          "54:         virtual BOOL GetEnumerator(JavascriptStaticEnumerator * enumerator, EnumeratorFlags flags, ScriptContext* requestContext, ForInCache * forInCache = nullptr) override { AssertAndFailFast(); return FALSE; };",
          "55:         virtual BOOL SetAccessors(PropertyId propertyId, Var getter, Var setter, PropertyOperationFlags flags = PropertyOperation_None) override { AssertAndFailFast(); return FALSE; };",
          "56:         virtual BOOL GetAccessors(PropertyId propertyId, Var *getter, Var *setter, ScriptContext * requestContext) override { AssertAndFailFast(); return FALSE; };",
          "57:         virtual BOOL IsWritable(PropertyId propertyId) override { AssertAndFailFast(); return FALSE; };",
          "58:         virtual BOOL IsConfigurable(PropertyId propertyId) override { AssertAndFailFast(); return FALSE; };",
          "59:         virtual BOOL IsEnumerable(PropertyId propertyId) override { AssertAndFailFast(); return FALSE; };",
          "60:         virtual BOOL SetEnumerable(PropertyId propertyId, BOOL value) override { AssertAndFailFast(); return FALSE; };",
          "61:         virtual BOOL SetWritable(PropertyId propertyId, BOOL value) override { AssertAndFailFast(); return FALSE; };",
          "62:         virtual BOOL SetConfigurable(PropertyId propertyId, BOOL value) override { AssertAndFailFast(); return FALSE; };",
          "63:         virtual BOOL SetAttributes(PropertyId propertyId, PropertyAttributes attributes) override { AssertAndFailFast(); return FALSE; };",
          "64:         virtual BOOL IsExtensible() override { AssertAndFailFast(); return FALSE; };",
          "65:         virtual BOOL PreventExtensions() override { AssertAndFailFast(); return FALSE; };",
          "66:         virtual BOOL Seal() override { AssertAndFailFast(); return FALSE; };",
          "67:         virtual BOOL Freeze() override { AssertAndFailFast(); return FALSE; };",
          "68:         virtual BOOL IsSealed() override { AssertAndFailFast(); return FALSE; };",
          "69:         virtual BOOL IsFrozen() override { AssertAndFailFast(); return FALSE; };",
          "70:         virtual BOOL GetDiagValueString(StringBuilder<ArenaAllocator>* stringBuilder, ScriptContext* requestContext) override { AssertAndFailFast(); return FALSE; };",
          "71:         virtual Var GetTypeOfString(ScriptContext * requestContext) override { AssertAndFailFast(); return RecyclableObject::GetTypeOfString(requestContext); };",
          "72:     };",
          "73: }",
          "",
          "[Added Lines]",
          "5: #pragma once",
          "6: namespace Js",
          "7: {",
          "9:     class SpreadArgument : public DynamicObject",
          "10:     {",
          "11:     private:",
          "12:         typedef JsUtil::List<Var, Recycler> VarList;",
          "13:         Field(VarList*) iteratorIndices;",
          "15:         void AssertAndFailFast() { AssertMsg(false, \"This function should not be invoked\"); Js::Throw::InternalError();}",
          "16:     protected:",
          "17:         DEFINE_VTABLE_CTOR(SpreadArgument, DynamicObject);",
          "18:         DEFINE_MARSHAL_OBJECT_TO_SCRIPT_CONTEXT(SpreadArgument);",
          "20:     public:",
          "21:         static bool Is(Var aValue);",
          "22:         static SpreadArgument* FromVar(Var value);",
          "23:         SpreadArgument(Var iterator, bool useDirectCall, DynamicType * type);",
          "24:         const Var* GetArgumentSpread() const { return iteratorIndices ? iteratorIndices->GetBuffer() : nullptr; }",
          "25:         uint GetArgumentSpreadCount()  const { return iteratorIndices ? iteratorIndices->Count() : 0; }",
          "28:         virtual BOOL HasProperty(PropertyId propertyId) override { AssertAndFailFast();  return FALSE; };",
          "29:         virtual BOOL HasOwnProperty(PropertyId propertyId) override { AssertAndFailFast(); return FALSE; };",
          "30:         virtual BOOL SetProperty(PropertyId propertyId, Var value, PropertyOperationFlags flags, PropertyValueInfo* info) override { AssertAndFailFast(); return FALSE; };",
          "31:         virtual BOOL GetProperty(Var originalInstance, PropertyId propertyId, Var* value, PropertyValueInfo* info, ScriptContext* requestContext) override { AssertAndFailFast(); return FALSE; };",
          "32:         virtual BOOL DeleteProperty(PropertyId propertyId, PropertyOperationFlags flags) override{ AssertAndFailFast(); return FALSE;};",
          "33:         virtual BOOL DeleteProperty(JavascriptString * propertyNameString, PropertyOperationFlags flags) override { AssertAndFailFast(); return FALSE; };",
          "34:         virtual BOOL GetPropertyReference(Var originalInstance, PropertyId propertyId, Var* value, PropertyValueInfo* info, ScriptContext* requestContext) override { AssertAndFailFast(); return None; };",
          "35:         virtual BOOL SetProperty(JavascriptString* propertyNameString, Var value, PropertyOperationFlags flags, PropertyValueInfo* info) override { AssertAndFailFast(); return FALSE; };",
          "36:         virtual BOOL GetProperty(Var originalInstance, JavascriptString* propertyNameString, Var* value, PropertyValueInfo* info, ScriptContext* requestContext) override { AssertAndFailFast(); return FALSE; };",
          "37:         virtual DescriptorFlags GetSetter(PropertyId propertyId, Var *setterValue, PropertyValueInfo* info, ScriptContext* requestContext) override { AssertAndFailFast(); return None; };",
          "38:         virtual DescriptorFlags GetSetter(JavascriptString* propertyNameString, Var *setterValue, PropertyValueInfo* info, ScriptContext* requestContext) override { AssertAndFailFast(); return None; };",
          "39:         virtual int GetPropertyCount() override { AssertAndFailFast(); return 0; };",
          "40:         virtual PropertyId GetPropertyId(PropertyIndex index) override { AssertAndFailFast();  return Constants::NoProperty; };",
          "41:         virtual PropertyId GetPropertyId(BigPropertyIndex index) override { AssertAndFailFast(); return Constants::NoProperty;; };",
          "42:         virtual BOOL SetInternalProperty(PropertyId internalPropertyId, Var value, PropertyOperationFlags flags, PropertyValueInfo* info) override { AssertAndFailFast(); return FALSE; };",
          "43:         virtual BOOL InitProperty(PropertyId propertyId, Var value, PropertyOperationFlags flags = PropertyOperation_None, PropertyValueInfo* info = NULL) override { AssertAndFailFast(); return FALSE; };",
          "44:         virtual BOOL SetPropertyWithAttributes(PropertyId propertyId, Var value, PropertyAttributes attributes, PropertyValueInfo* info, PropertyOperationFlags flags = PropertyOperation_None, SideEffects possibleSideEffects = SideEffects_Any) override { AssertAndFailFast(); return FALSE; };",
          "45:         virtual BOOL IsFixedProperty(PropertyId propertyId) override { AssertAndFailFast(); return FALSE; };",
          "46:         virtual BOOL HasItem(uint32 index) override { AssertAndFailFast(); return FALSE; };",
          "47:         virtual BOOL HasOwnItem(uint32 index) override { AssertAndFailFast(); return FALSE; };",
          "48:         virtual BOOL GetItem(Var originalInstance, uint32 index, Var* value, ScriptContext * requestContext) override { AssertAndFailFast(); return FALSE; };",
          "49:         virtual BOOL GetItemReference(Var originalInstance, uint32 index, Var* value, ScriptContext * requestContext) override { AssertAndFailFast(); return FALSE; };",
          "50:         virtual DescriptorFlags GetItemSetter(uint32 index, Var* setterValue, ScriptContext* requestContext) override { AssertAndFailFast(); return None; };",
          "51:         virtual BOOL SetItem(uint32 index, Var value, PropertyOperationFlags flags) override { AssertAndFailFast(); return FALSE; };",
          "52:         virtual BOOL DeleteItem(uint32 index, PropertyOperationFlags flags) override { AssertAndFailFast(); return FALSE; };",
          "53:         virtual BOOL ToPrimitive(JavascriptHint hint, Var* result, ScriptContext * requestContext) override { AssertAndFailFast(); return FALSE; };",
          "54:         virtual BOOL GetEnumerator(JavascriptStaticEnumerator * enumerator, EnumeratorFlags flags, ScriptContext* requestContext, ForInCache * forInCache = nullptr) override { AssertAndFailFast(); return FALSE; };",
          "55:         virtual BOOL SetAccessors(PropertyId propertyId, Var getter, Var setter, PropertyOperationFlags flags = PropertyOperation_None) override { AssertAndFailFast(); return FALSE; };",
          "56:         virtual BOOL GetAccessors(PropertyId propertyId, Var *getter, Var *setter, ScriptContext * requestContext) override { AssertAndFailFast(); return FALSE; };",
          "57:         virtual BOOL IsWritable(PropertyId propertyId) override { AssertAndFailFast(); return FALSE; };",
          "58:         virtual BOOL IsConfigurable(PropertyId propertyId) override { AssertAndFailFast(); return FALSE; };",
          "59:         virtual BOOL IsEnumerable(PropertyId propertyId) override { AssertAndFailFast(); return FALSE; };",
          "60:         virtual BOOL SetEnumerable(PropertyId propertyId, BOOL value) override { AssertAndFailFast(); return FALSE; };",
          "61:         virtual BOOL SetWritable(PropertyId propertyId, BOOL value) override { AssertAndFailFast(); return FALSE; };",
          "62:         virtual BOOL SetConfigurable(PropertyId propertyId, BOOL value) override { AssertAndFailFast(); return FALSE; };",
          "63:         virtual BOOL SetAttributes(PropertyId propertyId, PropertyAttributes attributes) override { AssertAndFailFast(); return FALSE; };",
          "64:         virtual BOOL IsExtensible() override { AssertAndFailFast(); return FALSE; };",
          "65:         virtual BOOL PreventExtensions() override { AssertAndFailFast(); return FALSE; };",
          "66:         virtual BOOL Seal() override { AssertAndFailFast(); return FALSE; };",
          "67:         virtual BOOL Freeze() override { AssertAndFailFast(); return FALSE; };",
          "68:         virtual BOOL IsSealed() override { AssertAndFailFast(); return FALSE; };",
          "69:         virtual BOOL IsFrozen() override { AssertAndFailFast(); return FALSE; };",
          "70:         virtual BOOL GetDiagValueString(StringBuilder<ArenaAllocator>* stringBuilder, ScriptContext* requestContext) override { AssertAndFailFast(); return FALSE; };",
          "71:         virtual Var GetTypeOfString(ScriptContext * requestContext) override { AssertAndFailFast(); return RecyclableObject::GetTypeOfString(requestContext); };",
          "72:     };",
          "73: }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "a430ded7ed0025b0c8c2bb7ba72dc62ae0c2c0db",
      "candidate_info": {
        "commit_hash": "a430ded7ed0025b0c8c2bb7ba72dc62ae0c2c0db",
        "repo": "Microsoft/ChakraCore",
        "commit_url": "https://github.com/Microsoft/ChakraCore/commit/a430ded7ed0025b0c8c2bb7ba72dc62ae0c2c0db",
        "files": [
          "lib/Runtime/Library/JavascriptArray.cpp",
          "test/Array/CopyOnAccessArray_bugs.baseline",
          "test/Array/CopyOnAccessArray_bugs.js"
        ],
        "message": "[1.4>master] [MERGE #2357 @MikeHolman] add more CopyOnAccessNativeIntArray conversions\n\nMerge pull request #2357 from MikeHolman:copyonaccess",
        "before_after_code_files": [
          "lib/Runtime/Library/JavascriptArray.cpp||lib/Runtime/Library/JavascriptArray.cpp",
          "test/Array/CopyOnAccessArray_bugs.baseline||test/Array/CopyOnAccessArray_bugs.baseline",
          "test/Array/CopyOnAccessArray_bugs.js||test/Array/CopyOnAccessArray_bugs.js"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "lib/Runtime/Library/JavascriptArray.cpp||lib/Runtime/Library/JavascriptArray.cpp"
          ],
          "candidate": [
            "lib/Runtime/Library/JavascriptArray.cpp||lib/Runtime/Library/JavascriptArray.cpp"
          ]
        }
      },
      "candidate_diff": {
        "lib/Runtime/Library/JavascriptArray.cpp||lib/Runtime/Library/JavascriptArray.cpp": [
          "File: lib/Runtime/Library/JavascriptArray.cpp -> lib/Runtime/Library/JavascriptArray.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "12109:     BOOL JavascriptArray::SetProperty(PropertyId propertyId, Var value, PropertyOperationFlags flags, PropertyValueInfo* info)",
          "12110:     {",
          "12111:         uint32 indexValue;",
          "12112:         if (propertyId == PropertyIds::length)",
          "12113:         {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "12111: #if ENABLE_COPYONACCESS_ARRAY",
          "12112:         JavascriptLibrary::CheckAndConvertCopyOnAccessNativeIntArray<Var>(this);",
          "12113: #endif",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "12129:         AssertMsg(!PropertyRecord::IsPropertyNameNumeric(propertyNameString->GetString(), propertyNameString->GetLength()),",
          "12130:             \"Numeric property names should have been converted to uint or PropertyRecord*\");",
          "12132:         PropertyRecord const* propertyRecord;",
          "12133:         this->GetScriptContext()->FindPropertyRecord(propertyNameString, &propertyRecord);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "12135: #if ENABLE_COPYONACCESS_ARRAY",
          "12136:         JavascriptLibrary::CheckAndConvertCopyOnAccessNativeIntArray<Var>(this);",
          "12137: #endif",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "12143:     BOOL JavascriptArray::SetPropertyWithAttributes(PropertyId propertyId, Var value, PropertyAttributes attributes, PropertyValueInfo* info, PropertyOperationFlags flags, SideEffects possibleSideEffects)",
          "12144:     {",
          "12145:         ScriptContext* scriptContext = GetScriptContext();",
          "12147:         if (propertyId == PropertyIds::length)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "12151: #if ENABLE_COPYONACCESS_ARRAY",
          "12152:         JavascriptLibrary::CheckAndConvertCopyOnAccessNativeIntArray<Var>(this);",
          "12153: #endif",
          "",
          "---------------"
        ],
        "test/Array/CopyOnAccessArray_bugs.baseline||test/Array/CopyOnAccessArray_bugs.baseline": [
          "File: test/Array/CopyOnAccessArray_bugs.baseline -> test/Array/CopyOnAccessArray_bugs.baseline",
          "--- Hunk 1 ---",
          "[Context before]",
          "28: PASSED",
          "30: PASSED",
          "",
          "[Removed Lines]",
          "31: Summary of tests: total executed: 11; passed: 11; failed: 0",
          "",
          "[Added Lines]",
          "32: PASSED",
          "34: PASSED",
          "35: Summary of tests: total executed: 13; passed: 13; failed: 0",
          "",
          "---------------"
        ],
        "test/Array/CopyOnAccessArray_bugs.js||test/Array/CopyOnAccessArray_bugs.js": [
          "File: test/Array/CopyOnAccessArray_bugs.js -> test/Array/CopyOnAccessArray_bugs.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "119:             assert.areEqual('1,0,0,0,0', q.toString(), 'Setting array element through Proxy');",
          "120:         }",
          "121:     },",
          "122: ];",
          "123: testRunner.runTests(tests, { verbose: WScript.Arguments[0] != \"summary\" });",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "122:     {",
          "123:         name: \"Reflect.defineProperty\",",
          "124:         body: function ()",
          "125:         {",
          "126:             var b = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16]",
          "127:             Reflect.defineProperty(b, \"length\", {value: 0});",
          "128:             assert.areEqual(b.length, 0, \"Setting length property to 0\");",
          "129:         }",
          "130:     },",
          "131:     {",
          "132:         name: \"Array.of\",",
          "133:         body: function ()",
          "134:         {",
          "135:             var target = [1,2,3,4,5];",
          "136:             function constructor()",
          "137:             {",
          "138:                 return target;",
          "139:             }",
          "140:             var a = Array.of.call(constructor);",
          "141:             assert.areEqual(a, [], \"Array.of.call with custom constructor\");",
          "142:         }",
          "143:     }",
          "",
          "---------------"
        ]
      }
    }
  ]
}
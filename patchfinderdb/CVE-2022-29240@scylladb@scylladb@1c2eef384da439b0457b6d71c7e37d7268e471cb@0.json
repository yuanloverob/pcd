{
  "cve_id": "CVE-2022-29240",
  "cve_desc": "Scylla is a real-time big data database that is API-compatible with Apache Cassandra and Amazon DynamoDB. When decompressing CQL frame received from user, Scylla assumes that user-provided uncompressed length is correct. If user provides fake length, that is greater than the real one, part of decompression buffer won't be overwritten, and will be left uninitialized. This can be exploited in several ways, depending on the privileges of the user. 1. The main exploit is that an attacker with access to CQL port, but no user account, can bypass authentication, but only if there are other legitimate clients making connections to the cluster, and they use LZ4. 2. Attacker that already has a user account on the cluster can read parts of uninitialized memory, which can contain things like passwords of other users or fragments of other queries / results, which leads to authorization bypass and sensitive information disclosure. The bug has been patched in the following versions: Scylla Enterprise: 2020.1.14, 2021.1.12, 2022.1.0. Scylla Open Source: 4.6.7, 5.0.3. Users unable to upgrade should make sure none of their drivers connect to cluster using LZ4 compression, and that Scylla CQL port is behind firewall. Additionally make sure no untrusted client can connect to Scylla, by setting up authentication and applying workarounds from previous point (firewall, no lz4 compression).",
  "repo": "scylladb/scylladb",
  "patch_hash": "1c2eef384da439b0457b6d71c7e37d7268e471cb",
  "patch_info": {
    "commit_hash": "1c2eef384da439b0457b6d71c7e37d7268e471cb",
    "repo": "scylladb/scylladb",
    "commit_url": "https://github.com/scylladb/scylladb/commit/1c2eef384da439b0457b6d71c7e37d7268e471cb",
    "files": [
      "transport/server.cc"
    ],
    "message": "transport/server.cc: Return correct size of decompressed lz4 buffer\n\nAn incorrect size is returned from the function, which could lead to\ncrashes or undefined behavior. Fix by erroring out in these cases.\n\nFixes #11476",
    "before_after_code_files": [
      "transport/server.cc||transport/server.cc"
    ]
  },
  "patch_diff": {
    "transport/server.cc||transport/server.cc": [
      "File: transport/server.cc -> transport/server.cc",
      "--- Hunk 1 ---",
      "[Context before]",
      "727:                     if (ret < 0) {",
      "728:                         throw std::runtime_error(\"CQL frame LZ4 uncompression failure\");",
      "729:                     }",
      "731:                 });",
      "732:                 on_compression_buffer_use();",
      "733:                 return uncomp;",
      "",
      "[Removed Lines]",
      "730:                     return out.size();",
      "",
      "[Added Lines]",
      "730:                     if (ret != out.size()) {",
      "731:                         throw std::runtime_error(\"Malformed CQL frame - provided uncompressed size different than real uncompressed size\");",
      "732:                     }",
      "733:                     return static_cast<size_t>(ret);",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "9a8e73f0c3e4664af86045e2889868c876062067",
      "candidate_info": {
        "commit_hash": "9a8e73f0c3e4664af86045e2889868c876062067",
        "repo": "scylladb/scylladb",
        "commit_url": "https://github.com/scylladb/scylladb/commit/9a8e73f0c3e4664af86045e2889868c876062067",
        "files": [
          "transport/server.cc"
        ],
        "message": "transport/server.cc: Return correct size of decompressed lz4 buffer\n\nAn incorrect size is returned from the function, which could lead to\ncrashes or undefined behavior. Fix by erroring out in these cases.\n\nFixes #11476\n\n(cherry picked from commit 1c2eef384da439b0457b6d71c7e37d7268e471cb)",
        "before_after_code_files": [
          "transport/server.cc||transport/server.cc"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_cherry_pick": 1,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "transport/server.cc||transport/server.cc"
          ],
          "candidate": [
            "transport/server.cc||transport/server.cc"
          ]
        }
      },
      "candidate_diff": {
        "transport/server.cc||transport/server.cc": [
          "File: transport/server.cc -> transport/server.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "728:                     if (ret < 0) {",
          "729:                         throw std::runtime_error(\"CQL frame LZ4 uncompression failure\");",
          "730:                     }",
          "732:                 });",
          "733:                 on_compression_buffer_use();",
          "734:                 return uncomp;",
          "",
          "[Removed Lines]",
          "731:                     return out.size();",
          "",
          "[Added Lines]",
          "731:                     if (ret != out.size()) {",
          "732:                         throw std::runtime_error(\"Malformed CQL frame - provided uncompressed size different than real uncompressed size\");",
          "733:                     }",
          "734:                     return static_cast<size_t>(ret);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "c48e9b47ddf40a2991df00422c3e54a935605e6a",
      "candidate_info": {
        "commit_hash": "c48e9b47ddf40a2991df00422c3e54a935605e6a",
        "repo": "scylladb/scylladb",
        "commit_url": "https://github.com/scylladb/scylladb/commit/c48e9b47ddf40a2991df00422c3e54a935605e6a",
        "files": [
          "transport/server.cc"
        ],
        "message": "transport/server.cc: Return correct size of decompressed lz4 buffer\n\nAn incorrect size is returned from the function, which could lead to\ncrashes or undefined behavior. Fix by erroring out in these cases.\n\nFixes #11476\n\n(cherry picked from commit 1c2eef384da439b0457b6d71c7e37d7268e471cb)",
        "before_after_code_files": [
          "transport/server.cc||transport/server.cc"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_cherry_pick": 1,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "transport/server.cc||transport/server.cc"
          ],
          "candidate": [
            "transport/server.cc||transport/server.cc"
          ]
        }
      },
      "candidate_diff": {
        "transport/server.cc||transport/server.cc": [
          "File: transport/server.cc -> transport/server.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "727:                     if (ret < 0) {",
          "728:                         throw std::runtime_error(\"CQL frame LZ4 uncompression failure\");",
          "729:                     }",
          "731:                 });",
          "732:                 on_compression_buffer_use();",
          "733:                 return uncomp;",
          "",
          "[Removed Lines]",
          "730:                     return out.size();",
          "",
          "[Added Lines]",
          "730:                     if (ret != out.size()) {",
          "731:                         throw std::runtime_error(\"Malformed CQL frame - provided uncompressed size different than real uncompressed size\");",
          "732:                     }",
          "733:                     return static_cast<size_t>(ret);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "32aa1e5287f23055a22d722e09088bab2a057d38",
      "candidate_info": {
        "commit_hash": "32aa1e5287f23055a22d722e09088bab2a057d38",
        "repo": "scylladb/scylladb",
        "commit_url": "https://github.com/scylladb/scylladb/commit/32aa1e5287f23055a22d722e09088bab2a057d38",
        "files": [
          "transport/server.cc"
        ],
        "message": "transport/server.cc: Return correct size of decompressed lz4 buffer\n\nAn incorrect size is returned from the function, which could lead to\ncrashes or undefined behavior. Fix by erroring out in these cases.\n\nFixes #11476\n\n(cherry picked from commit 1c2eef384da439b0457b6d71c7e37d7268e471cb)",
        "before_after_code_files": [
          "transport/server.cc||transport/server.cc"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_cherry_pick": 1,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "transport/server.cc||transport/server.cc"
          ],
          "candidate": [
            "transport/server.cc||transport/server.cc"
          ]
        }
      },
      "candidate_diff": {
        "transport/server.cc||transport/server.cc": [
          "File: transport/server.cc -> transport/server.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "717:                     if (ret < 0) {",
          "718:                         throw std::runtime_error(\"CQL frame LZ4 uncompression failure\");",
          "719:                     }",
          "721:                 });",
          "722:                 on_compression_buffer_use();",
          "723:                 return uncomp;",
          "",
          "[Removed Lines]",
          "720:                     return out.size();",
          "",
          "[Added Lines]",
          "720:                     if (ret != out.size()) {",
          "721:                         throw std::runtime_error(\"Malformed CQL frame - provided uncompressed size different than real uncompressed size\");",
          "722:                     }",
          "723:                     return static_cast<size_t>(ret);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "5dedf8528829354988bcb7e2617a5e9d60b50e61",
      "candidate_info": {
        "commit_hash": "5dedf8528829354988bcb7e2617a5e9d60b50e61",
        "repo": "scylladb/scylladb",
        "commit_url": "https://github.com/scylladb/scylladb/commit/5dedf8528829354988bcb7e2617a5e9d60b50e61",
        "files": [
          "transport/server.cc"
        ],
        "message": "transport: prevent signed and unsigned comparison\n\nThis can lead to undefined behavior. Cast to unsigned, after\nwe've verified the value is indeed positive.",
        "before_after_code_files": [
          "transport/server.cc||transport/server.cc"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "transport/server.cc||transport/server.cc"
          ],
          "candidate": [
            "transport/server.cc||transport/server.cc"
          ]
        }
      },
      "candidate_diff": {
        "transport/server.cc||transport/server.cc": [
          "File: transport/server.cc -> transport/server.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "727:                     if (ret < 0) {",
          "728:                         throw std::runtime_error(\"CQL frame LZ4 uncompression failure\");",
          "729:                     }",
          "731:                         throw std::runtime_error(\"Malformed CQL frame - provided uncompressed size different than real uncompressed size\");",
          "732:                     }",
          "733:                     return static_cast<size_t>(ret);",
          "",
          "[Removed Lines]",
          "730:                     if (ret != out.size()) {",
          "",
          "[Added Lines]",
          "730:                     if (size_t(ret) != out.size()) {  // ret is known to be positive here",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "bf26a8c4673f9367fac1a592dc09d968a39d4d80",
      "candidate_info": {
        "commit_hash": "bf26a8c4673f9367fac1a592dc09d968a39d4d80",
        "repo": "scylladb/scylladb",
        "commit_url": "https://github.com/scylladb/scylladb/commit/bf26a8c4673f9367fac1a592dc09d968a39d4d80",
        "files": [
          "test/boost/reusable_buffer_test.cc",
          "transport/request.hh",
          "transport/response.hh",
          "transport/server.cc",
          "utils/fragmented_temporary_buffer.hh",
          "utils/reusable_buffer.hh"
        ],
        "message": "utils: redesign reusable_buffer\n\nLarge contiguous buffers put large pressure on the allocator\nand are a common source of reactor stalls. Therefore, Scylla avoids\ntheir use, replacing it with fragmented buffers whenever possible.\nHowever, the use of large contiguous buffers is impossible to avoid\nwhen dealing with some external libraries (i.e. some compression\nlibraries, like LZ4).\n\nFortunately, calls to external libraries are synchronous, so we can\nminimize the allocator impact by reusing a single buffer between calls.\n\nAn implementation of such a reusable buffer has two conflicting goals:\nto allocate as rarely as possible, and to waste as little memory as\npossible. The bigger the buffer, the more likely that it will be able\nto handle future requests without reallocation, but also the memory\nmemory it ties up.\n\nIf request sizes are repetitive, the near-optimal solution is to\nsimply resize the buffer up to match the biggest seen request,\nand never resize down.\n\nHowever, if we anticipate pathologically large requests, which are\ncaused by an application/configuration bug and are never repeated\nagain after they are fixed, we might want to resize down after such\npathological requests stop, so that the memory they took isn't tied\nup forever.\n\nThe current implementation of reusable buffers handles this by\nresizing down to 0 every 100'000 requests.\n\nThis patch attempts to solve a few shortcomings of the current\nimplementation.\n1. Resizing to 0 is too aggressive. During regular operation, we will\nsurely need to resize it back to the previous size again. If something\nis allocated in the hole left by the old buffer, this might cause\na stall. We prefer to resize down only after pathological requests.\n2. When resizing, the current implementation allocates the new buffer\nbefore freeing the old one. This increases allocator pressure for no\nreason.\n3. When resizing up, the buffer is resized to exactly the requested\nsize. That is, if the current size is 1MiB, following requests\nof 1MiB+1B and 1MiB+2B will both cause a resize.\nIt's preferable to limit the set of possible sizes so that every\nreset doesn't tend to cause multiple resizes of almost the same size.\nThe natural set of sizes is powers of 2, because that's what the\nunderlying buddy allocator uses. No waste is caused by rounding up\nthe allocation to a power of 2.\n4. The interval of 100'000 uses is both too low and too arbitrary.\nThis is up for discussion, but I think that it's preferable to base\nthe dynamics of the buffer on time, rather than the number of uses.\nIt's more predictable to humans.\n\nThe implementation proposed in this patch addresses these as follows:\n1. Instead of resizing down to 0, we resize to the biggest size\n   seen in the last period.\n   As long as at least one maximal (up to a power of 2) \"normal\" request\n   appears each period, the buffer will never have to be resized.\n2. The capacity of the buffer is always rounded up to the nearest\n   power of 2.\n3. The resize down period is no longer measured in number of requests\n   but in real time.\n\nAdditionally, since a shared buffer in asynchronous code is quite a\nfootgun, some rudimentary refcounting is added to assert that only\none reference to the buffer exists at a time, and that the buffer isn't\ndownsized while a reference to it exists.\n\nFixes #13437",
        "before_after_code_files": [
          "test/boost/reusable_buffer_test.cc||test/boost/reusable_buffer_test.cc",
          "transport/request.hh||transport/request.hh",
          "transport/response.hh||transport/response.hh",
          "transport/server.cc||transport/server.cc",
          "utils/fragmented_temporary_buffer.hh||utils/fragmented_temporary_buffer.hh",
          "utils/reusable_buffer.hh||utils/reusable_buffer.hh"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "transport/server.cc||transport/server.cc"
          ],
          "candidate": [
            "transport/server.cc||transport/server.cc"
          ]
        }
      },
      "candidate_diff": {
        "test/boost/reusable_buffer_test.cc||test/boost/reusable_buffer_test.cc": [
          "File: test/boost/reusable_buffer_test.cc -> test/boost/reusable_buffer_test.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "14: #include <boost/range/algorithm/copy.hpp>",
          "23:         testlog.info(\"Testing buffer size {}\", n);",
          "24:         auto original = tests::random::get_bytes(n);",
          "26:         bytes_ostream bo;",
          "27:         bo.write(original);",
          "40:         }",
          "47:     };",
          "49:     for (auto j = 0; j < 2; j++) {",
          "57:         for (auto i = 0; i < 25; i++) {",
          "59:         }",
          "60:     }",
          "67:         testlog.info(\"Testing maximum buffer size {}, actual: {} \", maximum, actual);",
          "69:         bytes original;",
          "",
          "[Removed Lines]",
          "9: #define BOOST_TEST_MODULE reusable_buffer",
          "10: #include <boost/test/unit_test.hpp>",
          "12: #include \"utils/reusable_buffer.hh\"",
          "16: #include \"test/lib/random_utils.hh\"",
          "17: #include \"test/lib/log.hh\"",
          "19: BOOST_AUTO_TEST_CASE(test_get_linearized_view) {",
          "20:     utils::reusable_buffer buffer;",
          "22:     auto test = [&buffer] (size_t n) {",
          "29:         auto view = buffer.get_linearized_view(bo);",
          "30:         BOOST_REQUIRE_EQUAL(view.size(), n);",
          "31:         BOOST_REQUIRE(view == original);",
          "32:         BOOST_REQUIRE(bo.linearize() == original);",
          "34:         std::vector<temporary_buffer<char>> tbufs;",
          "35:         bytes_view left = original;",
          "36:         while (!left.empty()) {",
          "37:             auto this_size = std::min<size_t>(left.size(), fragmented_temporary_buffer::default_fragment_size);",
          "38:             tbufs.emplace_back(reinterpret_cast<const char*>(left.data()), this_size);",
          "39:             left.remove_prefix(this_size);",
          "42:         auto fbuf = fragmented_temporary_buffer(std::move(tbufs), original.size());",
          "43:         view = buffer.get_linearized_view(fragmented_temporary_buffer::view(fbuf));",
          "44:         BOOST_REQUIRE_EQUAL(view.size(), n);",
          "45:         BOOST_REQUIRE(view == original);",
          "46:         BOOST_REQUIRE(linearized(fragmented_temporary_buffer::view(fbuf)) == original);",
          "50:         buffer.clear();",
          "52:         test(0);",
          "53:         test(1'000'000);",
          "54:         test(1'000);",
          "55:         test(100'000);",
          "58:             test(tests::random::get_int(512 * 1024));",
          "61: }",
          "63: BOOST_AUTO_TEST_CASE(test_make_buffer) {",
          "64:     utils::reusable_buffer buffer;",
          "66:     auto test = [&buffer] (size_t maximum, size_t actual) {",
          "",
          "[Added Lines]",
          "9: #include \"test/lib/random_utils.hh\"",
          "10: #include \"test/lib/log.hh\"",
          "14: #include \"utils/reusable_buffer.hh\"",
          "15: #include <seastar/core/manual_clock.hh>",
          "16: #include <seastar/testing/test_case.hh>",
          "17: #include <seastar/util/later.hh>",
          "18: #include <seastar/core/coroutine.hh>",
          "19: #include <bit>",
          "21: using namespace seastar;",
          "23: SEASTAR_TEST_CASE(test_get_linearized_view) {",
          "24:     auto test = [] (size_t n, utils::reusable_buffer<manual_clock>& buffer) {",
          "31:         {",
          "32:             auto bufguard = utils::reusable_buffer_guard(buffer);",
          "33:             auto view = bufguard.get_linearized_view(bo);",
          "34:             BOOST_REQUIRE_EQUAL(view.size(), n);",
          "35:             BOOST_REQUIRE(view == original);",
          "36:             BOOST_REQUIRE(bo.linearize() == original);",
          "39:         {",
          "40:             std::vector<temporary_buffer<char>> tbufs;",
          "41:             bytes_view left = original;",
          "42:             while (!left.empty()) {",
          "43:                 auto this_size = std::min<size_t>(left.size(), fragmented_temporary_buffer::default_fragment_size);",
          "44:                 tbufs.emplace_back(reinterpret_cast<const char*>(left.data()), this_size);",
          "45:                 left.remove_prefix(this_size);",
          "46:             }",
          "48:             auto bufguard = utils::reusable_buffer_guard(buffer);",
          "49:             auto fbuf = fragmented_temporary_buffer(std::move(tbufs), original.size());",
          "50:             auto view = bufguard.get_linearized_view(fragmented_temporary_buffer::view(fbuf));",
          "51:             BOOST_REQUIRE_EQUAL(view.size(), n);",
          "52:             BOOST_REQUIRE(view == original);",
          "53:             BOOST_REQUIRE(linearized(fragmented_temporary_buffer::view(fbuf)) == original);",
          "54:         }",
          "58:         utils::reusable_buffer<manual_clock> buffer(std::chrono::milliseconds(1));",
          "60:         test(0, buffer);",
          "61:         test(1'000'000, buffer);",
          "62:         test(1'000, buffer);",
          "63:         test(100'000, buffer);",
          "66:             test(tests::random::get_int(512 * 1024), buffer);",
          "70:     return make_ready_future<>();",
          "71: }",
          "73: SEASTAR_TEST_CASE(test_make_buffer) {",
          "74:     auto test = [] (size_t maximum, size_t actual, utils::reusable_buffer<manual_clock>& buffer) {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "75:             return actual;",
          "76:         };",
          "88:     };",
          "90:     for (auto j = 0; j < 2; j++) {",
          "98:         for (auto i = 0; i < 25; i++) {",
          "99:             auto a = tests::random::get_int(512 * 1024);",
          "100:             auto b = tests::random::get_int(512 * 1024);",
          "102:         }",
          "103:     }",
          "104: }",
          "",
          "[Removed Lines]",
          "78:         auto bo = buffer.make_buffer(maximum, make_buffer_fn);",
          "80:         BOOST_REQUIRE_EQUAL(bo.size(), actual);",
          "81:         BOOST_REQUIRE(bo.linearize() == original);",
          "83:         auto fbuf = buffer.make_fragmented_temporary_buffer(maximum, fragmented_temporary_buffer::default_fragment_size, make_buffer_fn);",
          "84:         auto view = fragmented_temporary_buffer::view(fbuf);",
          "86:         BOOST_REQUIRE_EQUAL(view.size_bytes(), actual);",
          "87:         BOOST_REQUIRE(linearized(view) == original);",
          "91:         buffer.clear();",
          "93:         test(0, 0);",
          "94:         test(100'000, 0);",
          "95:         test(200'000, 200'000);",
          "96:         test(400'000, 100'000);",
          "101:             test(std::max(a, b), std::min(a, b));",
          "",
          "[Added Lines]",
          "86:         {",
          "87:             auto bufguard = utils::reusable_buffer_guard(buffer);",
          "88:             auto bo = bufguard.make_bytes_ostream(maximum, make_buffer_fn);",
          "90:             BOOST_REQUIRE_EQUAL(bo.size(), actual);",
          "91:             BOOST_REQUIRE(bo.linearize() == original);",
          "92:         }",
          "94:         {",
          "95:             auto bufguard = utils::reusable_buffer_guard(buffer);",
          "96:             auto fbuf = bufguard.make_fragmented_temporary_buffer(maximum, make_buffer_fn);",
          "97:             auto view = fragmented_temporary_buffer::view(fbuf);",
          "99:             BOOST_REQUIRE_EQUAL(view.size_bytes(), actual);",
          "100:             BOOST_REQUIRE(linearized(view) == original);",
          "101:         }",
          "105:         utils::reusable_buffer<manual_clock> buffer(std::chrono::milliseconds(1));",
          "107:         test(0, 0, buffer);",
          "108:         test(100'000, 0, buffer);",
          "109:         test(200'000, 200'000, buffer);",
          "110:         test(400'000, 100'000, buffer);",
          "115:             test(std::max(a, b), std::min(a, b), buffer);",
          "119:     return make_ready_future<>();",
          "120: }",
          "122: SEASTAR_TEST_CASE(test_decay) {",
          "123:     using namespace std::chrono_literals;",
          "124:     utils::reusable_buffer<manual_clock> buffer(1s);",
          "125:     auto get_buffer = [&buffer] (size_t size) {",
          "126:         auto bufguard = utils::reusable_buffer_guard(buffer);",
          "127:         bufguard.get_temporary_buffer(size);",
          "128:     };",
          "129:     auto advance_clock = [] (manual_clock::duration d) {",
          "130:         manual_clock::advance(d);",
          "131:         return yield();",
          "132:     };",
          "133:     BOOST_REQUIRE(buffer.reallocs() == 0);",
          "134:     get_buffer(1'000'000);",
          "135:     get_buffer(1'000'001);",
          "136:     get_buffer(1'000'000);",
          "137:     get_buffer(1'000);",
          "138:     BOOST_REQUIRE_EQUAL(buffer.reallocs(), 1);",
          "143:     BOOST_REQUIRE_EQUAL(buffer.size(), std::bit_ceil(size_t(1'000'001)));",
          "144:     co_await advance_clock(1500ms);",
          "145:     get_buffer(1'000);",
          "146:     BOOST_REQUIRE_EQUAL(buffer.reallocs(), 1);",
          "147:     co_await advance_clock(1000ms);",
          "148:     BOOST_REQUIRE_EQUAL(buffer.reallocs(), 2);",
          "149:     BOOST_REQUIRE_EQUAL(buffer.size(), std::bit_ceil(size_t(1'000)));",
          "150:     co_await advance_clock(1000ms);",
          "151:     BOOST_REQUIRE_EQUAL(buffer.reallocs(), 3);",
          "152:     BOOST_REQUIRE_EQUAL(buffer.size(), 0);",
          "",
          "---------------"
        ],
        "transport/request.hh||transport/request.hh": [
          "File: transport/request.hh -> transport/request.hh",
          "--- Hunk 1 ---",
          "[Context before]",
          "11: #include \"server.hh\"",
          "12: #include \"utils/utf8.hh\"",
          "14: #include \"utils/fragmented_temporary_buffer.hh\"",
          "16: namespace cql_transport {",
          "",
          "[Removed Lines]",
          "13: #include \"utils/reusable_buffer.hh\"",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "transport/response.hh||transport/response.hh": [
          "File: transport/response.hh -> transport/response.hh",
          "--- Hunk 1 ---",
          "[Context before]",
          "9: #pragma once",
          "11: #include \"server.hh\"",
          "14: namespace cql_transport {",
          "",
          "[Removed Lines]",
          "12: #include \"utils/reusable_buffer.hh\"",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "transport/server.cc||transport/server.cc": [
          "File: transport/server.cc -> transport/server.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "62: #include \"transport/cql_protocol_extension.hh\"",
          "63: #include \"utils/bit_cast.hh\"",
          "64: #include \"db/config.hh\"",
          "66: template<typename T = void>",
          "67: using coordinator_result = exceptions::coordinator_result<T>;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "65: #include \"utils/reusable_buffer.hh\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "790:     });",
          "791: }",
          "808: }",
          "810: }",
          "812: future<fragmented_temporary_buffer> cql_server::connection::read_and_decompress_frame(size_t length, uint8_t flags)",
          "813: {",
          "815:     if (flags & cql_frame_flags::compression) {",
          "816:         if (_compression == cql_compression::lz4) {",
          "817:             if (length < 4) {",
          "818:                 throw std::runtime_error(fmt::format(\"CQL frame truncated: expected to have at least 4 bytes, got {}\", length));",
          "819:             }",
          "820:             return _buffer_reader.read_exactly(_read_buf, length).then([] (fragmented_temporary_buffer buf) {",
          "823:                 if (uncomp_len < 0) {",
          "824:                     throw std::runtime_error(\"CQL frame uncompressed length is negative: \" + std::to_string(uncomp_len));",
          "825:                 }",
          "831:                     if (ret < 0) {",
          "832:                         throw std::runtime_error(\"CQL frame LZ4 uncompression failure\");",
          "833:                     }",
          "835:                         throw std::runtime_error(\"Malformed CQL frame - provided uncompressed size different than real uncompressed size\");",
          "836:                     }",
          "837:                     return static_cast<size_t>(ret);",
          "838:                 });",
          "841:             });",
          "842:         } else if (_compression == cql_compression::snappy) {",
          "843:             return _buffer_reader.read_exactly(_read_buf, length).then([] (fragmented_temporary_buffer buf) {",
          "844:                 auto in = input_buffer.get_linearized_view(fragmented_temporary_buffer::view(buf));",
          "845:                 size_t uncomp_len;",
          "846:                 if (snappy_uncompressed_length(reinterpret_cast<const char*>(in.data()), in.size(), &uncomp_len) != SNAPPY_OK) {",
          "847:                     throw std::runtime_error(\"CQL frame Snappy uncompressed size is unknown\");",
          "848:                 }",
          "850:                     size_t output_len = out.size();",
          "851:                     if (snappy_uncompress(reinterpret_cast<const char*>(in.data()), in.size(), reinterpret_cast<char*>(out.data()), &output_len) != SNAPPY_OK) {",
          "852:                         throw std::runtime_error(\"CQL frame Snappy uncompression failure\");",
          "853:                     }",
          "854:                     return output_len;",
          "855:                 });",
          "858:             });",
          "859:         } else {",
          "860:             throw exceptions::protocol_exception(format(\"Unknown compression algorithm\"));",
          "",
          "[Removed Lines]",
          "793: namespace compression_buffers {",
          "797: static constexpr size_t clear_buffers_trigger = 100'000;",
          "798: static thread_local size_t buffer_use_count = 0;",
          "799: static thread_local utils::reusable_buffer input_buffer;",
          "800: static thread_local utils::reusable_buffer output_buffer;",
          "802: void on_compression_buffer_use() {",
          "803:     if (++buffer_use_count == clear_buffers_trigger) {",
          "804:         input_buffer.clear();",
          "805:         output_buffer.clear();",
          "806:         buffer_use_count = 0;",
          "807:     }",
          "814:     using namespace compression_buffers;",
          "821:                 auto linearization_buffer = bytes_ostream();",
          "822:                 int32_t uncomp_len = request_reader(buf.get_istream(), linearization_buffer).read_int();",
          "826:                 buf.remove_prefix(4);",
          "827:                 auto in = input_buffer.get_linearized_view(fragmented_temporary_buffer::view(buf));",
          "828:                 auto uncomp = output_buffer.make_fragmented_temporary_buffer(uncomp_len, fragmented_temporary_buffer::default_fragment_size, [&] (bytes_mutable_view out) {",
          "829:                     auto ret = LZ4_decompress_safe(reinterpret_cast<const char*>(in.data()), reinterpret_cast<char*>(out.data()),",
          "830:                                                    in.size(), out.size());",
          "834:                     if (size_t(ret) != out.size()) {  // ret is known to be positive here",
          "839:                 on_compression_buffer_use();",
          "840:                 return uncomp;",
          "849:                 auto uncomp = output_buffer.make_fragmented_temporary_buffer(uncomp_len, fragmented_temporary_buffer::default_fragment_size, [&] (bytes_mutable_view out) {",
          "856:                 on_compression_buffer_use();",
          "857:                 return uncomp;",
          "",
          "[Added Lines]",
          "798: static utils::reusable_buffer_guard input_buffer_guard() {",
          "799:     using namespace std::chrono_literals;",
          "800:     static thread_local utils::reusable_buffer<lowres_clock> buf(600s);",
          "801:     return buf;",
          "803: static utils::reusable_buffer_guard output_buffer_guard() {",
          "804:     using namespace std::chrono_literals;",
          "805:     static thread_local utils::reusable_buffer<lowres_clock> buf(600s);",
          "806:     return buf;",
          "817:                 auto input_buffer = input_buffer_guard();",
          "818:                 auto output_buffer = output_buffer_guard();",
          "819:                 auto v = fragmented_temporary_buffer::view(buf);",
          "820:                 int32_t uncomp_len = read_simple<int32_t>(v);",
          "824:                 auto in = input_buffer.get_linearized_view(v);",
          "825:                 return output_buffer.make_fragmented_temporary_buffer(uncomp_len, [&in] (bytes_mutable_view out) {",
          "826:                     auto ret = LZ4_decompress_safe(reinterpret_cast<const char*>(in.data()), reinterpret_cast<char*>(out.data()), in.size(), out.size());",
          "830:                     if (static_cast<size_t>(ret) != out.size()) {  // ret is known to be positive here",
          "838:                 auto input_buffer = input_buffer_guard();",
          "839:                 auto output_buffer = output_buffer_guard();",
          "845:                 return output_buffer.make_fragmented_temporary_buffer(uncomp_len, [&in] (bytes_mutable_view out) {",
          "850:                     if (output_len != out.size()) {",
          "851:                         throw std::runtime_error(\"Malformed CQL frame - provided uncompressed size different than real uncompressed size\");",
          "852:                     }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1598: void cql_server::response::compress_lz4()",
          "1599: {",
          "1613:         if (ret == 0) {",
          "1614:             throw std::runtime_error(\"CQL frame LZ4 compression failure\");",
          "1615:         }",
          "1617:     });",
          "1619: }",
          "1621: void cql_server::response::compress_snappy()",
          "1622: {",
          "1632:             throw std::runtime_error(\"CQL frame Snappy compression failure\");",
          "1633:         }",
          "1635:     });",
          "1637: }",
          "1639: void cql_server::response::serialize(const event::schema_change& event, uint8_t version)",
          "",
          "[Removed Lines]",
          "1600:     using namespace compression_buffers;",
          "1601:     auto view = input_buffer.get_linearized_view(_body);",
          "1602:     const char* input = reinterpret_cast<const char*>(view.data());",
          "1603:     size_t input_len = view.size();",
          "1605:     size_t output_len = LZ4_COMPRESSBOUND(input_len) + 4;",
          "1606:     _body = output_buffer.make_buffer(output_len, [&] (bytes_mutable_view output_view) {",
          "1607:         char* output = reinterpret_cast<char*>(output_view.data());",
          "1608:         output[0] = (input_len >> 24) & 0xFF;",
          "1609:         output[1] = (input_len >> 16) & 0xFF;",
          "1610:         output[2] = (input_len >> 8) & 0xFF;",
          "1611:         output[3] = input_len & 0xFF;",
          "1612:         auto ret = LZ4_compress_default(input, output + 4, input_len, LZ4_compressBound(input_len));",
          "1616:         return ret + 4;",
          "1618:     on_compression_buffer_use();",
          "1623:     using namespace compression_buffers;",
          "1624:     auto view = input_buffer.get_linearized_view(_body);",
          "1625:     const char* input = reinterpret_cast<const char*>(view.data());",
          "1626:     size_t input_len = view.size();",
          "1628:     size_t output_len = snappy_max_compressed_length(input_len);",
          "1629:     _body = output_buffer.make_buffer(output_len, [&] (bytes_mutable_view output_view) {",
          "1630:         char* output = reinterpret_cast<char*>(output_view.data());",
          "1631:         if (snappy_compress(input, input_len, output, &output_len) != SNAPPY_OK) {",
          "1634:         return output_len;",
          "1636:     on_compression_buffer_use();",
          "",
          "[Added Lines]",
          "1597:     auto input_buffer = input_buffer_guard();",
          "1598:     auto output_buffer = output_buffer_guard();",
          "1600:     auto in = input_buffer.get_linearized_view(_body);",
          "1601:     size_t output_len = LZ4_COMPRESSBOUND(in.size()) + 4;",
          "1602:     _body = output_buffer.make_bytes_ostream(output_len, [&in] (bytes_mutable_view out) {",
          "1603:         out.data()[0] = (in.size() >> 24) & 0xFF;",
          "1604:         out.data()[1] = (in.size() >> 16) & 0xFF;",
          "1605:         out.data()[2] = (in.size() >> 8) & 0xFF;",
          "1606:         out.data()[3] = in.size() & 0xFF;",
          "1607:         auto ret = LZ4_compress_default(reinterpret_cast<const char*>(in.data()), reinterpret_cast<char*>(out.data() + 4), in.size(), out.size() - 4);",
          "1611:         return static_cast<size_t>(ret) + 4;",
          "1617:     auto input_buffer = input_buffer_guard();",
          "1618:     auto output_buffer = output_buffer_guard();",
          "1620:     auto in = input_buffer.get_linearized_view(_body);",
          "1621:     size_t output_len = snappy_max_compressed_length(in.size());",
          "1622:     _body = output_buffer.make_bytes_ostream(output_len, [&in] (bytes_mutable_view out) {",
          "1623:         size_t actual_len = out.size();",
          "1624:         if (snappy_compress(reinterpret_cast<const char*>(in.data()), in.size(), reinterpret_cast<char*>(out.data()), &actual_len) != SNAPPY_OK) {",
          "1627:         return actual_len;",
          "",
          "---------------"
        ],
        "utils/fragmented_temporary_buffer.hh||utils/fragmented_temporary_buffer.hh": [
          "File: utils/fragmented_temporary_buffer.hh -> utils/fragmented_temporary_buffer.hh",
          "--- Hunk 1 ---",
          "[Context before]",
          "38:         : _fragments(std::move(fragments)), _size_bytes(size_bytes)",
          "39:     { }",
          "41:     explicit operator view() const noexcept;",
          "43:     istream get_istream() const noexcept;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "41:     fragmented_temporary_buffer(const char* str, size_t size)",
          "42:     {",
          "44:         size_t pos = 0;",
          "45:         for (auto& frag : _fragments) {",
          "46:             std::memcpy(frag.get_write(), str + pos, frag.size());",
          "47:             pos += frag.size();",
          "48:         }",
          "49:     }",
          "",
          "---------------"
        ],
        "utils/reusable_buffer.hh||utils/reusable_buffer.hh": [
          "File: utils/reusable_buffer.hh -> utils/reusable_buffer.hh",
          "--- Hunk 1 ---",
          "[Context before]",
          "9: #pragma once",
          "11: #include <seastar/core/memory.hh>",
          "64:         }",
          "66:     }",
          "78:         }",
          "82:             dst = std::copy(fragment.begin(), fragment.end(), dst);",
          "83:         }",
          "85:     }",
          "93:         }",
          "98:             dst = std::copy(fragment.begin(), fragment.end(), dst);",
          "101:     }",
          "110:     template<typename Function>",
          "115:         bytes_ostream output;",
          "127:             output.remove_suffix(output.size() - actual_length);",
          "128:         }",
          "129:         return output;",
          "130:     }",
          "132:     template<typename Function>",
          "155:         } else {",
          "157:         }",
          "159:     }",
          "165:     }",
          "166: };",
          "",
          "[Removed Lines]",
          "13: #include \"bytes.hh\"",
          "14: #include \"bytes_ostream.hh\"",
          "15: #include \"utils/fragmented_temporary_buffer.hh\"",
          "17: #include <boost/range/algorithm/for_each.hpp>",
          "19: namespace utils {",
          "48: class reusable_buffer { // extract to utils",
          "50:     std::unique_ptr<int8_t[]> _buffer;",
          "51:     size_t _size = 0;",
          "52: private:",
          "53:     bytes_mutable_view reserve(size_t n) {",
          "54:         if (_size < n) {",
          "58:             seastar::memory::scoped_large_allocation_warning_disable g;",
          "62:             _buffer.reset(new int8_t[n]);",
          "63:             _size = n;",
          "65:         return bytes_mutable_view(_buffer.get(), n);",
          "67: public:",
          "75:     bytes_view get_linearized_view(const bytes_ostream& data) {",
          "76:         if (data.is_linearized()) {",
          "77:             return data.view();",
          "79:         auto mutable_view = reserve(data.size());",
          "80:         auto dst = mutable_view.begin();",
          "81:         for (bytes_view fragment : data) {",
          "84:         return bytes_view(mutable_view);",
          "88:     bytes_view get_linearized_view(const fragmented_temporary_buffer::view& data) {",
          "89:         if (data.empty()) {",
          "90:             return { };",
          "91:         } else if (std::next(data.begin()) == data.end()) {",
          "92:             return *data.begin();",
          "94:         auto mutable_view = reserve(data.size_bytes());",
          "95:         auto dst = mutable_view.begin();",
          "96:         using boost::range::for_each;",
          "97:         for_each(data, [&] (bytes_view fragment) {",
          "99:         });",
          "100:         return bytes_view(mutable_view);",
          "111:     requires requires(Function fn, bytes_mutable_view view) {",
          "112:         { fn(view) } -> std::convertible_to<size_t>;",
          "113:     }",
          "114:     bytes_ostream make_buffer(size_t maximum_length, Function&& fn) {",
          "116:         bytes_mutable_view view = [&] {",
          "117:             if (maximum_length && maximum_length <= bytes_ostream::max_chunk_size()) {",
          "118:                 auto ptr = output.write_place_holder(maximum_length);",
          "119:                 return bytes_mutable_view(ptr, maximum_length);",
          "120:             }",
          "121:             return reserve(maximum_length);",
          "122:         }();",
          "123:         size_t actual_length = fn(view);",
          "124:         if (output.empty()) {",
          "125:             output.write(bytes_view(view.data(), actual_length));",
          "126:         } else {",
          "133:     requires requires(Function fn, bytes_mutable_view view) {",
          "134:         { fn(view) } -> std::same_as<size_t>;",
          "135:     }",
          "136:     fragmented_temporary_buffer make_fragmented_temporary_buffer(size_t maximum_length, size_t maximum_fragment_size, Function&& fn) {",
          "137:         std::vector<temporary_buffer<char>> fragments;",
          "138:         bytes_mutable_view view = [&] {",
          "139:             if (maximum_length <= maximum_fragment_size) {",
          "140:                 fragments.emplace_back(maximum_length);",
          "141:                 return bytes_mutable_view(reinterpret_cast<bytes::pointer>(fragments.back().get_write()), maximum_length);",
          "142:             }",
          "143:             return reserve(maximum_length);",
          "144:         }();",
          "145:         size_t actual_length = fn(view);",
          "146:         if (fragments.empty()) {",
          "147:             auto left = actual_length;",
          "148:             auto src = reinterpret_cast<const bytes::value_type*>(_buffer.get());",
          "149:             while (left) {",
          "150:                 auto this_length = std::min(left, maximum_fragment_size);",
          "151:                 fragments.emplace_back(reinterpret_cast<const char*>(src), this_length);",
          "152:                 src += this_length;",
          "153:                 left -= this_length;",
          "154:             }",
          "156:             fragments.back().trim(actual_length);",
          "158:         return fragmented_temporary_buffer(std::move(fragments), actual_length);",
          "162:     void clear() noexcept {",
          "163:         _buffer.reset();",
          "164:         _size = 0;",
          "168: }",
          "",
          "[Added Lines]",
          "11: #include \"utils/fragmented_temporary_buffer.hh\"",
          "12: #include <seastar/core/timer.hh>",
          "14: #include <chrono>",
          "15: #include <bit>",
          "17: namespace utils {",
          "23: class reusable_buffer_impl {",
          "24: protected:",
          "25:     friend class reusable_buffer_guard;",
          "30:     size_t _high_watermark = 0;",
          "31:     std::unique_ptr<bytes::value_type[]> _buf; // The underlying contiguous buffer.",
          "32:     size_t _buf_size = 0;",
          "33:     size_t _refcount = 0;                // Used purely for anti-misuse checks.",
          "34:     size_t _reallocs = 0;                // Number of size changes.",
          "35: public:",
          "36:     size_t size() const noexcept { return _buf_size; }",
          "37:     size_t reallocs() const noexcept { return _reallocs; }",
          "38: protected:",
          "40:     reusable_buffer_impl(const reusable_buffer_impl&) = delete;",
          "41:     reusable_buffer_impl& operator=(const reusable_buffer_impl&) = delete;",
          "43:     reusable_buffer_impl() = default;",
          "45:     ~reusable_buffer_impl() {",
          "46:         assert(_refcount == 0);",
          "47:     }",
          "49:     void resize(size_t new_size) & {",
          "53:         seastar::memory::scoped_large_allocation_warning_disable g;",
          "59:         _buf = nullptr;",
          "60:         _buf_size = 0;",
          "61:         _reallocs += 1;",
          "62:         _buf.reset(new bytes::value_type[new_size]);",
          "63:         _buf_size = new_size;",
          "64:     }",
          "69:     bytes_mutable_view get_temporary_buffer(size_t size) & {",
          "70:         _high_watermark = std::max(_high_watermark, std::bit_ceil(size));",
          "71:         if (_high_watermark > _buf_size) {",
          "72:             resize(_high_watermark);",
          "74:         return {_buf.get(), size};",
          "85:     bytes_view get_linearized_view(fragmented_temporary_buffer::view ftb) & {",
          "86:         if (ftb.current_fragment().size() == ftb.size_bytes()) {",
          "87:             return {ftb.current_fragment().data(), ftb.size_bytes()};",
          "89:         const auto out = get_temporary_buffer(ftb.size_bytes()).data();",
          "90:         auto dst = out;",
          "91:         for (bytes_view fragment : fragmented_temporary_buffer::view(ftb)) {",
          "94:         return {out, ftb.size_bytes()};",
          "101:     bytes_view get_linearized_view(bytes_ostream& bo) & {",
          "102:         if (bo.is_linearized()) {",
          "103:             return bo.view();",
          "105:         const auto out = get_temporary_buffer(bo.size()).data();",
          "106:         auto dst = out;",
          "107:         for (bytes_view fragment : bo) {",
          "109:         }",
          "110:         return {out, bo.size()};",
          "124:     requires std::is_invocable_r_v<size_t, Function, bytes_mutable_view>",
          "125:     bytes_ostream make_bytes_ostream(size_t maximum_length, Function&& fn) & {",
          "127:         if (maximum_length && maximum_length <= bytes_ostream::max_chunk_size()) {",
          "128:             auto ptr = output.write_place_holder(maximum_length);",
          "129:             size_t actual_length = fn(bytes_mutable_view(ptr, maximum_length));",
          "131:         } else {",
          "132:             auto view = get_temporary_buffer(maximum_length);",
          "133:             size_t actual_length = fn(view);",
          "134:             output.write(bytes_view(view.data(), actual_length));",
          "150:     requires std::is_invocable_r_v<size_t, Function, bytes_mutable_view>",
          "151:     fragmented_temporary_buffer make_fragmented_temporary_buffer(size_t maximum_length, Function&& fn) & {",
          "152:         if (maximum_length <= fragmented_temporary_buffer::default_fragment_size) {",
          "153:             seastar::temporary_buffer<char> buf(maximum_length);",
          "154:             auto view = bytes_mutable_view(reinterpret_cast<bytes::value_type*>(buf.get_write()), buf.size());",
          "155:             size_t actual_length = fn(view);",
          "156:             buf.trim(actual_length);",
          "157:             std::vector<seastar::temporary_buffer<char>> chunks;",
          "158:             chunks.push_back(std::move(buf));",
          "159:             return fragmented_temporary_buffer(std::move(chunks), actual_length);",
          "161:             auto view = get_temporary_buffer(maximum_length);",
          "162:             size_t actual_length = fn(view);",
          "163:             return fragmented_temporary_buffer(reinterpret_cast<const char*>(view.data()), actual_length);",
          "164:         }",
          "165:     }",
          "166: };",
          "209: template <typename Clock>",
          "210: class reusable_buffer : public reusable_buffer_impl {",
          "211: public:",
          "212:     using period_type = typename Clock::duration;",
          "213: private:",
          "214:     seastar::timer<Clock> _decay_timer;",
          "215:     period_type _decay_period;",
          "217:     void decay() & {",
          "218:         assert(_refcount == 0);",
          "219:         if (_high_watermark <= _buf_size / 16) {",
          "229:             resize(_high_watermark);",
          "231:         _high_watermark = 0;",
          "232:     }",
          "233: public:",
          "234:     reusable_buffer(period_type period)",
          "235:         : _decay_period(period)",
          "236:     {",
          "237:         _decay_timer.set_callback([this] {decay();});",
          "238:         _decay_timer.arm_periodic(_decay_period);",
          "239:     }",
          "240: };",
          "256: class reusable_buffer_guard {",
          "257: private:",
          "258:     reusable_buffer_impl& _buf;",
          "259:     bool used = false;",
          "260: private:",
          "261:     void mark_used() {",
          "262:         assert(!used);",
          "263:         used = true;",
          "265: public:",
          "266:     reusable_buffer_guard(const reusable_buffer_guard&) = delete;",
          "267:     reusable_buffer_guard& operator=(const reusable_buffer_guard&) = delete;",
          "269:     reusable_buffer_guard(reusable_buffer_impl& _buf)",
          "270:         : _buf(_buf)",
          "271:     {",
          "272:         assert(_buf._refcount == 0);",
          "273:         _buf._refcount += 1;",
          "274:     }",
          "276:     ~reusable_buffer_guard() {",
          "277:         _buf._refcount -= 1;",
          "278:     }",
          "282:     bytes_mutable_view get_temporary_buffer(size_t size) & {",
          "283:         mark_used();",
          "284:         return _buf.get_temporary_buffer(size);",
          "285:     }",
          "289:     bytes_view get_linearized_view(fragmented_temporary_buffer::view ftb) & {",
          "290:         mark_used();",
          "291:         return _buf.get_linearized_view(std::move(ftb));",
          "292:     }",
          "296:     bytes_view get_linearized_view(bytes_ostream& bo) & {",
          "297:         mark_used();",
          "298:         return _buf.get_linearized_view(bo);",
          "299:     }",
          "303:     template<typename Function>",
          "304:     requires std::is_invocable_r_v<size_t, Function, bytes_mutable_view>",
          "305:     bytes_ostream make_bytes_ostream(size_t maximum_length, Function&& fn) & {",
          "306:         mark_used();",
          "307:         return _buf.make_bytes_ostream(maximum_length, std::forward<Function>(fn));",
          "308:     }",
          "312:     template<typename Function>",
          "313:     requires std::is_invocable_r_v<size_t, Function, bytes_mutable_view>",
          "314:     fragmented_temporary_buffer make_fragmented_temporary_buffer(size_t maximum_length, Function&& fn) & {",
          "315:         mark_used();",
          "316:         return _buf.make_fragmented_temporary_buffer(maximum_length, std::forward<Function>(fn));",
          "320: } // namespace utils",
          "",
          "---------------"
        ]
      }
    }
  ]
}
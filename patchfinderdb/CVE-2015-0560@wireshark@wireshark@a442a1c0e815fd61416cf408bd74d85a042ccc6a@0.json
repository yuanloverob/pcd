{
  "cve_id": "CVE-2015-0560",
  "cve_desc": "The dissect_wccp2r1_address_table_info function in epan/dissectors/packet-wccp.c in the WCCP dissector in Wireshark 1.10.x before 1.10.12 and 1.12.x before 1.12.3 does not initialize certain data structures, which allows remote attackers to cause a denial of service (application crash) via a crafted packet.",
  "repo": "wireshark/wireshark",
  "patch_hash": "a442a1c0e815fd61416cf408bd74d85a042ccc6a",
  "patch_info": {
    "commit_hash": "a442a1c0e815fd61416cf408bd74d85a042ccc6a",
    "repo": "wireshark/wireshark",
    "commit_url": "https://github.com/wireshark/wireshark/commit/a442a1c0e815fd61416cf408bd74d85a042ccc6a",
    "files": [
      "epan/dissectors/packet-wccp.c"
    ],
    "message": "WCCP: initialize address table to 0\n\nIt prevents an uninitialized access later on if an exception is triggered before filling the table\n\nBug: 10806\nChange-Id: I8f75fb18cd8d033013c34093f9d6c8762f23452b\nReviewed-on: https://code.wireshark.org/review/6056\nReviewed-by: Pascal Quantin <pascal.quantin@gmail.com>",
    "before_after_code_files": [
      "epan/dissectors/packet-wccp.c||epan/dissectors/packet-wccp.c"
    ]
  },
  "patch_diff": {
    "epan/dissectors/packet-wccp.c||epan/dissectors/packet-wccp.c": [
      "File: epan/dissectors/packet-wccp.c -> epan/dissectors/packet-wccp.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "1891:   case 1:",
      "1892:     if (wccp_wccp_address_table.table_ipv4 == NULL)",
      "1893:       wccp_wccp_address_table.table_ipv4 = (guint32 *)",
      "1895:     if (address_length != 4) {",
      "1896:       expert_add_info_format(pinfo, tf, &ei_wccp_length_bad,",
      "1897:                              \"The Address length must be 4, but I found  %d for IPv4 addresses. Correcting this.\",",
      "",
      "[Removed Lines]",
      "1894:         wmem_alloc(pinfo->pool, wccp_wccp_address_table.table_length * 4);",
      "",
      "[Added Lines]",
      "1894:         wmem_alloc0(pinfo->pool, wccp_wccp_address_table.table_length * 4);",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "1902:   case 2:",
      "1903:     if (wccp_wccp_address_table.table_ipv6 == NULL)",
      "1904:       wccp_wccp_address_table.table_ipv6 = (struct e_in6_addr *)",
      "1906:     if (address_length != 16) {",
      "1907:       expert_add_info_format(pinfo, tf, &ei_wccp_length_bad,",
      "1908:                              \"The Address length must be 16, but I found %d for IPv6 addresses.  Correcting this\",",
      "",
      "[Removed Lines]",
      "1905:         wmem_alloc(pinfo->pool, wccp_wccp_address_table.table_length * sizeof(struct e_in6_addr));",
      "",
      "[Added Lines]",
      "1905:         wmem_alloc0(pinfo->pool, wccp_wccp_address_table.table_length * sizeof(struct e_in6_addr));",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "adce5fa31f01e7894465b42de98b9a7ee69c152a",
      "candidate_info": {
        "commit_hash": "adce5fa31f01e7894465b42de98b9a7ee69c152a",
        "repo": "wireshark/wireshark",
        "commit_url": "https://github.com/wireshark/wireshark/commit/adce5fa31f01e7894465b42de98b9a7ee69c152a",
        "files": [
          "epan/dissectors/packet-wccp.c"
        ],
        "message": "WCCP: initialize address table to 0\n\nIt prevents an uninitialized access later on if an exception is triggered before filling the table\n\nBug: 10806\nChange-Id: I8f75fb18cd8d033013c34093f9d6c8762f23452b\nReviewed-on: https://code.wireshark.org/review/6056\nReviewed-by: Pascal Quantin <pascal.quantin@gmail.com>\n(cherry picked from commit a442a1c0e815fd61416cf408bd74d85a042ccc6a)\nConflicts:\n\tepan/dissectors/packet-wccp.c\nReviewed-on: https://code.wireshark.org/review/6058",
        "before_after_code_files": [
          "epan/dissectors/packet-wccp.c||epan/dissectors/packet-wccp.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_cherry_pick": 1,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "epan/dissectors/packet-wccp.c||epan/dissectors/packet-wccp.c"
          ],
          "candidate": [
            "epan/dissectors/packet-wccp.c||epan/dissectors/packet-wccp.c"
          ]
        }
      },
      "candidate_diff": {
        "epan/dissectors/packet-wccp.c||epan/dissectors/packet-wccp.c": [
          "File: epan/dissectors/packet-wccp.c -> epan/dissectors/packet-wccp.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1916:   case 1:",
          "1917:     if (wccp_wccp_address_table.table_ipv4 == NULL)",
          "1918:       wccp_wccp_address_table.table_ipv4 = (guint32 *)",
          "1920:     if ((address_length != 4) && (pinfo && info_tree)) {",
          "1921:       expert_add_info_format(pinfo, tf, &ei_wccp_length_bad,",
          "1922:                              \"The Address length must be 4, but I found  %d for IPv4 addresses. Correcting this.\",",
          "",
          "[Removed Lines]",
          "1919:         wmem_alloc(pinfo->pool, wccp_wccp_address_table.table_length * 4);",
          "",
          "[Added Lines]",
          "1919:         wmem_alloc0(pinfo->pool, wccp_wccp_address_table.table_length * 4);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1927:   case 2:",
          "1928:     if (wccp_wccp_address_table.table_ipv6 == NULL)",
          "1929:       wccp_wccp_address_table.table_ipv6 = (struct e_in6_addr *)",
          "1931:     if ((address_length != 16) && (pinfo && info_tree)) {",
          "1932:       expert_add_info_format(pinfo, tf, &ei_wccp_length_bad,",
          "1933:                              \"The Address length must be 16, but I found %d for IPv6 addresses.  Correcting this\",",
          "",
          "[Removed Lines]",
          "1930:         wmem_alloc(pinfo->pool, wccp_wccp_address_table.table_length * sizeof(struct e_in6_addr));",
          "",
          "[Added Lines]",
          "1930:         wmem_alloc0(pinfo->pool, wccp_wccp_address_table.table_length * sizeof(struct e_in6_addr));",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "7f8e46c6f41194c55909e052664e6f40040fe6ff",
      "candidate_info": {
        "commit_hash": "7f8e46c6f41194c55909e052664e6f40040fe6ff",
        "repo": "wireshark/wireshark",
        "commit_url": "https://github.com/wireshark/wireshark/commit/7f8e46c6f41194c55909e052664e6f40040fe6ff",
        "files": [
          "epan/dissectors/packet-wccp.c"
        ],
        "message": "WCCP: initialize address table to 0\n\nIt prevents an uninitialized access later on if an exception is triggered before filling the table\n\nBug: 10806\nChange-Id: I8f75fb18cd8d033013c34093f9d6c8762f23452b\nReviewed-on: https://code.wireshark.org/review/6056\nReviewed-by: Pascal Quantin <pascal.quantin@gmail.com>\n(cherry picked from commit a442a1c0e815fd61416cf408bd74d85a042ccc6a)\nConflicts:\n\tepan/dissectors/packet-wccp.c\nReviewed-on: https://code.wireshark.org/review/6058\n(cherry picked from commit adce5fa31f01e7894465b42de98b9a7ee69c152a)\nReviewed-on: https://code.wireshark.org/review/6464\nReviewed-by: Michael Mann <mmann78@netscape.net>",
        "before_after_code_files": [
          "epan/dissectors/packet-wccp.c||epan/dissectors/packet-wccp.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_cherry_pick": 1,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "epan/dissectors/packet-wccp.c||epan/dissectors/packet-wccp.c"
          ],
          "candidate": [
            "epan/dissectors/packet-wccp.c||epan/dissectors/packet-wccp.c"
          ]
        }
      },
      "candidate_diff": {
        "epan/dissectors/packet-wccp.c||epan/dissectors/packet-wccp.c": [
          "File: epan/dissectors/packet-wccp.c -> epan/dissectors/packet-wccp.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1916:   case 1:",
          "1917:     if (wccp_wccp_address_table.table_ipv4 == NULL)",
          "1918:       wccp_wccp_address_table.table_ipv4 = (guint32 *)",
          "1920:     if ((address_length != 4) && (pinfo && info_tree)) {",
          "1921:       expert_add_info_format(pinfo, tf, &ei_wccp_length_bad,",
          "1922:                              \"The Address length must be 4, but I found  %d for IPv4 addresses. Correcting this.\",",
          "",
          "[Removed Lines]",
          "1919:         wmem_alloc(pinfo->pool, wccp_wccp_address_table.table_length * 4);",
          "",
          "[Added Lines]",
          "1919:         wmem_alloc0(pinfo->pool, wccp_wccp_address_table.table_length * 4);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1927:   case 2:",
          "1928:     if (wccp_wccp_address_table.table_ipv6 == NULL)",
          "1929:       wccp_wccp_address_table.table_ipv6 = (struct e_in6_addr *)",
          "1931:     if ((address_length != 16) && (pinfo && info_tree)) {",
          "1932:       expert_add_info_format(pinfo, tf, &ei_wccp_length_bad,",
          "1933:                              \"The Address length must be 16, but I found %d for IPv6 addresses.  Correcting this\",",
          "",
          "[Removed Lines]",
          "1930:         wmem_alloc(pinfo->pool, wccp_wccp_address_table.table_length * sizeof(struct e_in6_addr));",
          "",
          "[Added Lines]",
          "1930:         wmem_alloc0(pinfo->pool, wccp_wccp_address_table.table_length * sizeof(struct e_in6_addr));",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "524ed1df6e6126cd63ba419ccb82c83636d77ee4",
      "candidate_info": {
        "commit_hash": "524ed1df6e6126cd63ba419ccb82c83636d77ee4",
        "repo": "wireshark/wireshark",
        "commit_url": "https://github.com/wireshark/wireshark/commit/524ed1df6e6126cd63ba419ccb82c83636d77ee4",
        "files": [
          "epan/dissectors/packet-wccp.c"
        ],
        "message": "WCCP: Fix up storing and decoding of IP addresses.\n\nTry to decode as many IP addresses as we can, even if they don't fit in the\ntable we store them in.\n\nOnly add IP addresses in the table once.  We could theoretically reallocate\nthe table but the original code seems to assume the addresses should (in\nnon-fuzzed captures) only show up once per PDU.  This part of the change fixes\nthe fuzz failure.\n\nBug: 11153\nChange-Id: I56b9854ac1342080c9f32699a3f97750fa335696\nReviewed-on: https://code.wireshark.org/review/8748\nPetri-Dish: Jeff Morriss <jeff.morriss.ws@gmail.com>\nTested-by: Petri Dish Buildbot <buildbot-no-reply@wireshark.org>\nReviewed-by: Anders Broman <a.broman58@gmail.com>",
        "before_after_code_files": [
          "epan/dissectors/packet-wccp.c||epan/dissectors/packet-wccp.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "epan/dissectors/packet-wccp.c||epan/dissectors/packet-wccp.c"
          ],
          "candidate": [
            "epan/dissectors/packet-wccp.c||epan/dissectors/packet-wccp.c"
          ]
        }
      },
      "candidate_diff": {
        "epan/dissectors/packet-wccp.c||epan/dissectors/packet-wccp.c": [
          "File: epan/dissectors/packet-wccp.c -> epan/dissectors/packet-wccp.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1836:    once to get the tables, once to display them",
          "1838: static gint",
          "1841: {",
          "1842:   guint16 address_length;",
          "1843:   guint32 i;",
          "1849:   if (length < 2*4)",
          "1850:     return length - 2*4;",
          "1857:   EAT_AND_CHECK(2,2);",
          "1860:   proto_tree_add_item(info_tree, hf_address_table_address_length, tvb, offset, 2, ENC_BIG_ENDIAN);",
          "1861:   EAT_AND_CHECK(2,2);",
          "1864:   tf = proto_tree_add_item(info_tree, hf_address_table_length, tvb, offset, 4, ENC_BIG_ENDIAN);",
          "1865:   element_tree = proto_item_add_subtree(tf, ett_table_element);",
          "1867:   EAT(4);",
          "1920:     case 1:",
          "1922:       addr  =  tvb_ip_to_str(tvb, offset);",
          "1925:       break;",
          "1926:     case 2:",
          "1930:         tvb_get_ipv6(tvb, offset, &(wccp_wccp_address_table.table_ipv6[i]));",
          "1931:       break;",
          "1932:     default:",
          "1934:     };",
          "1936:     if (element_tree) {",
          "1940:     }",
          "1941:     EAT(address_length);",
          "1942:   }",
          "1943:   return length;",
          "1944: }",
          "",
          "[Removed Lines]",
          "1839: dissect_wccp2r1_address_table_info(tvbuff_t *tvb, int offset,",
          "1840:                                    int length, packet_info *pinfo, proto_tree *info_tree)",
          "1844:   proto_tree *element_tree=NULL;",
          "1845:   proto_item *tf=NULL;",
          "1847:   wccp_wccp_address_table.in_use = TRUE;",
          "1853:   wccp_wccp_address_table.family = tvb_get_ntohs(tvb,offset);",
          "1855:   proto_tree_add_item(info_tree, hf_address_table_family, tvb,",
          "1856:                         offset, 2, ENC_BIG_ENDIAN);",
          "1859:   address_length = tvb_get_ntohs(tvb,offset);",
          "1863:   wccp_wccp_address_table.table_length =  tvb_get_ntohl(tvb,offset);",
          "1870:   switch (wccp_wccp_address_table.family) {",
          "1871:   case 1:",
          "1872:     if (wccp_wccp_address_table.table_ipv4 == NULL)",
          "1873:       wccp_wccp_address_table.table_ipv4 = (guint32 *)",
          "1874:         wmem_alloc0(pinfo->pool, wccp_wccp_address_table.table_length * 4);",
          "1875:     if (address_length != 4) {",
          "1876:       expert_add_info_format(pinfo, tf, &ei_wccp_length_bad,",
          "1877:                              \"The Address length must be 4, but I found  %d for IPv4 addresses. Correcting this.\",",
          "1878:                              address_length);",
          "1879:       address_length = 4;",
          "1880:     }",
          "1881:     break;",
          "1882:   case 2:",
          "1883:     if (wccp_wccp_address_table.table_ipv6 == NULL)",
          "1884:       wccp_wccp_address_table.table_ipv6 = (struct e_in6_addr *)",
          "1885:         wmem_alloc0(pinfo->pool, wccp_wccp_address_table.table_length * sizeof(struct e_in6_addr));",
          "1886:     if (address_length != 16) {",
          "1887:       expert_add_info_format(pinfo, tf, &ei_wccp_length_bad,",
          "1888:                              \"The Address length must be 16, but I found %d for IPv6 addresses.  Correcting this\",",
          "1889:                              address_length);",
          "1890:       address_length=16;",
          "1891:     }",
          "1892:     break;",
          "1893:   default:",
          "1894:     expert_add_info_format(pinfo, tf, &ei_wccp_address_table_family_unknown,",
          "1895:                     \"Unknown address family: %d\", wccp_wccp_address_table.family);",
          "1896:   };",
          "1900:   for(i=0; i<wccp_wccp_address_table.table_length; i++) {",
          "1901:     const gchar* addr;",
          "1904:     if (length < address_length) {",
          "1905:       expert_add_info_format(pinfo, tf, &ei_wccp_length_bad, \"Ran out of space to decode\");",
          "1908:       wccp_wccp_address_table.in_use = FALSE;",
          "1909:       wccp_wccp_address_table.family = -1;",
          "1910:       wccp_wccp_address_table.version = -1;",
          "1911:       wccp_wccp_address_table.table_length = 0;",
          "1912:       wccp_wccp_address_table.table_ipv4 = (guint32 *) NULL;",
          "1913:       wccp_wccp_address_table.table_ipv6 = (struct e_in6_addr *)NULL;",
          "1916:       return length - address_length;",
          "1917:     }",
          "1919:     switch (wccp_wccp_address_table.family) {",
          "1923:       if (wccp_wccp_address_table.table_ipv4 != NULL)",
          "1924:         wccp_wccp_address_table.table_ipv4[i] = tvb_get_ntohl(tvb,offset);",
          "1928:       addr = tvb_ip6_to_str(tvb,offset);",
          "1929:       if (wccp_wccp_address_table.table_ipv6 != NULL)",
          "1933:       addr = wmem_strdup_printf(wmem_packet_scope(), \"unknown family\");",
          "1937:       proto_tree_add_string_format_value(element_tree, hf_address_table_element, tvb,",
          "1938:                                          offset, address_length, addr,",
          "1939:                                          \"%d: %s\", i+1, addr);",
          "",
          "[Added Lines]",
          "1839: dissect_wccp2r1_address_table_info(tvbuff_t *tvb, int offset, int length,",
          "1840:                                    packet_info *pinfo, proto_tree *info_tree)",
          "1844:   gint16 family;",
          "1845:   guint16 table_length;",
          "1846:   proto_tree *element_tree;",
          "1847:   proto_item *tf;",
          "1852:   family = tvb_get_ntohs(tvb, offset);",
          "1853:   proto_tree_add_item(info_tree, hf_address_table_family, tvb, offset, 2, ENC_BIG_ENDIAN);",
          "1856:   address_length = tvb_get_ntohs(tvb, offset);",
          "1860:   table_length =  tvb_get_ntohl(tvb, offset);",
          "1865:   if (wccp_wccp_address_table.in_use == FALSE) {",
          "1866:     wccp_wccp_address_table.in_use = TRUE;",
          "1867:     wccp_wccp_address_table.family = family;",
          "1868:     wccp_wccp_address_table.table_length =  table_length;",
          "1871:     switch (wccp_wccp_address_table.family) {",
          "1872:     case 1:",
          "1873:       if (wccp_wccp_address_table.table_ipv4 == NULL)",
          "1874:         wccp_wccp_address_table.table_ipv4 = (guint32 *)",
          "1875:           wmem_alloc0(pinfo->pool, wccp_wccp_address_table.table_length * 4);",
          "1876:       if (address_length != 4) {",
          "1877:         expert_add_info_format(pinfo, tf, &ei_wccp_length_bad,",
          "1878:                                \"The Address length must be 4, but I found %d for IPv4 addresses. Correcting this.\",",
          "1879:                                address_length);",
          "1880:         address_length = 4;",
          "1881:       }",
          "1882:       break;",
          "1883:     case 2:",
          "1884:       if (wccp_wccp_address_table.table_ipv6 == NULL)",
          "1885:         wccp_wccp_address_table.table_ipv6 = (struct e_in6_addr *)",
          "1886:           wmem_alloc0(pinfo->pool, wccp_wccp_address_table.table_length * sizeof(struct e_in6_addr));",
          "1887:       if (address_length != 16) {",
          "1888:         expert_add_info_format(pinfo, tf, &ei_wccp_length_bad,",
          "1889:                                \"The Address length must be 16, but I found %d for IPv6 addresses. Correcting this.\",",
          "1890:                                address_length);",
          "1891:         address_length = 16;",
          "1892:       }",
          "1893:       break;",
          "1894:     default:",
          "1895:       expert_add_info_format(pinfo, tf, &ei_wccp_address_table_family_unknown,",
          "1896:                       \"Unknown address family: %d\", wccp_wccp_address_table.family);",
          "1897:     };",
          "1898:   }",
          "1902:   for(i=0; i<table_length; i++) {",
          "1903:     const gchar *addr;",
          "1905:     switch (family) {",
          "1909:       if ((wccp_wccp_address_table.table_ipv4 != NULL) && ((address_length * i) < wccp_wccp_address_table.table_length))",
          "1910:         wccp_wccp_address_table.table_ipv4[i] = tvb_get_ntohl(tvb, offset);",
          "1914:       addr = tvb_ip6_to_str(tvb, offset);",
          "1915:       if ((wccp_wccp_address_table.table_ipv6 != NULL) && ((address_length * i) < wccp_wccp_address_table.table_length))",
          "1919:       addr = wmem_strdup_printf(wmem_packet_scope(), \"unknown family %d\", wccp_wccp_address_table.family);",
          "1923:       proto_item *pi;",
          "1925:       pi = proto_tree_add_string_format_value(element_tree, hf_address_table_element, tvb,",
          "1926:                                               offset, address_length, addr,",
          "1927:                                               \"%d: %s\", i+1, addr);",
          "1928:       if ((address_length * i) > wccp_wccp_address_table.table_length)",
          "1929:         expert_add_info_format(pinfo, pi, &ei_wccp_length_bad, \"Ran out of space to store address\");",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "e843c6797db98bfceab382d5d7e76727e1014f5e",
      "candidate_info": {
        "commit_hash": "e843c6797db98bfceab382d5d7e76727e1014f5e",
        "repo": "wireshark/wireshark",
        "commit_url": "https://github.com/wireshark/wireshark/commit/e843c6797db98bfceab382d5d7e76727e1014f5e",
        "files": [
          "epan/dissectors/packet-wccp.c"
        ],
        "message": "wccp: use pinfo-scope memory for addresses\n\nThey may be accessed during the print phase, at which point packet-scope memory\nhas already been freed.\n\nBug: 10720\nChange-Id: Ia2b160fd9de4ccaa3a4b8d9cb70fb9b32d4e08a0\nReviewed-on: https://code.wireshark.org/review/5496\nReviewed-by: Evan Huus <eapache@gmail.com>",
        "before_after_code_files": [
          "epan/dissectors/packet-wccp.c||epan/dissectors/packet-wccp.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "epan/dissectors/packet-wccp.c||epan/dissectors/packet-wccp.c"
          ],
          "candidate": [
            "epan/dissectors/packet-wccp.c||epan/dissectors/packet-wccp.c"
          ]
        }
      },
      "candidate_diff": {
        "epan/dissectors/packet-wccp.c||epan/dissectors/packet-wccp.c": [
          "File: epan/dissectors/packet-wccp.c -> epan/dissectors/packet-wccp.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "508: static void",
          "509: find_wccp_address_table(tvbuff_t *tvb, int offset,",
          "511: {",
          "512:   guint16 type;",
          "513:   guint16 item_length;",
          "",
          "[Removed Lines]",
          "510:                         packet_info *pinfo _U_, proto_tree *wccp_tree _U_)",
          "",
          "[Added Lines]",
          "510:                         packet_info *pinfo, proto_tree *wccp_tree _U_)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "550:     if (type == WCCP2r1_ADDRESS_TABLE)",
          "551:       {",
          "554:         return;",
          "555:       }",
          "",
          "[Removed Lines]",
          "552:         dissect_wccp2r1_address_table_info(tvb, offset+4, item_length, NULL, NULL);",
          "",
          "[Added Lines]",
          "552:         dissect_wccp2r1_address_table_info(tvb, offset+4, item_length, pinfo, NULL);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1900:   case 1:",
          "1901:     if (wccp_wccp_address_table.table_ipv4 == NULL)",
          "1902:       wccp_wccp_address_table.table_ipv4 = (guint32 *)",
          "1904:     if ((address_length != 4) && (pinfo && info_tree)) {",
          "1905:       expert_add_info_format(pinfo, tf, &ei_wccp_length_bad,",
          "1906:                              \"The Address length must be 4, but I found  %d for IPv4 addresses. Correcting this.\",",
          "",
          "[Removed Lines]",
          "1903:         wmem_alloc(wmem_packet_scope(), wccp_wccp_address_table.table_length * 4);",
          "",
          "[Added Lines]",
          "1903:         wmem_alloc(pinfo->pool, wccp_wccp_address_table.table_length * 4);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1911:   case 2:",
          "1912:     if (wccp_wccp_address_table.table_ipv6 == NULL)",
          "1913:       wccp_wccp_address_table.table_ipv6 = (struct e_in6_addr *)",
          "1915:     if ((address_length != 16) && (pinfo && info_tree)) {",
          "1916:       expert_add_info_format(pinfo, tf, &ei_wccp_length_bad,",
          "1917:                              \"The Address length must be 16, but I found %d for IPv6 addresses.  Correcting this\",",
          "",
          "[Removed Lines]",
          "1914:         wmem_alloc(wmem_packet_scope(), wccp_wccp_address_table.table_length * sizeof(struct e_in6_addr));",
          "",
          "[Added Lines]",
          "1914:         wmem_alloc(pinfo->pool, wccp_wccp_address_table.table_length * sizeof(struct e_in6_addr));",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "b1eaf29d4056f05d1bd6a7f3d692553ec069a228",
      "candidate_info": {
        "commit_hash": "b1eaf29d4056f05d1bd6a7f3d692553ec069a228",
        "repo": "wireshark/wireshark",
        "commit_url": "https://github.com/wireshark/wireshark/commit/b1eaf29d4056f05d1bd6a7f3d692553ec069a228",
        "files": [
          "epan/dissectors/packet-wccp.c"
        ],
        "message": "WCCP - Only populate address table once and presume first address table type is the one that should populate it.\n\nPing-Bug: 11358\nChange-Id: Ieed093b4aa263026772450f95dd5fa18280f9b76\nReviewed-on: https://code.wireshark.org/review/9648\nReviewed-by: Michael Mann <mmann78@netscape.net>",
        "before_after_code_files": [
          "epan/dissectors/packet-wccp.c||epan/dissectors/packet-wccp.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "epan/dissectors/packet-wccp.c||epan/dissectors/packet-wccp.c"
          ],
          "candidate": [
            "epan/dissectors/packet-wccp.c||epan/dissectors/packet-wccp.c"
          ]
        }
      },
      "candidate_diff": {
        "epan/dissectors/packet-wccp.c||epan/dissectors/packet-wccp.c": [
          "File: epan/dissectors/packet-wccp.c -> epan/dissectors/packet-wccp.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1854:   EAT(4);",
          "1856:   if (wccp_wccp_address_table.in_use == FALSE) {",
          "1858:     wccp_wccp_address_table.family = family;",
          "1859:     wccp_wccp_address_table.table_length =  table_length;",
          "",
          "[Removed Lines]",
          "1857:     wccp_wccp_address_table.in_use = TRUE;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1897:     case 1:",
          "1899:       addr  =  tvb_ip_to_str(tvb, offset);",
          "1901:         wccp_wccp_address_table.table_ipv4[i] = tvb_get_ntohl(tvb, offset);",
          "1902:       break;",
          "1903:     case 2:",
          "1905:       addr = tvb_ip6_to_str(tvb, offset);",
          "1907:         tvb_get_ipv6(tvb, offset, &(wccp_wccp_address_table.table_ipv6[i]));",
          "1908:       break;",
          "1909:     default:",
          "",
          "[Removed Lines]",
          "1900:       if ((wccp_wccp_address_table.table_ipv4 != NULL) && ((address_length * i) < wccp_wccp_address_table.table_length))",
          "1906:       if ((wccp_wccp_address_table.table_ipv6 != NULL) && ((address_length * i) < wccp_wccp_address_table.table_length))",
          "",
          "[Added Lines]",
          "1899:       if ((wccp_wccp_address_table.in_use == FALSE) &&",
          "1900:           (wccp_wccp_address_table.table_ipv4 != NULL) &&",
          "1901:           ((address_length * i) < wccp_wccp_address_table.table_length))",
          "1907:       if ((wccp_wccp_address_table.in_use == FALSE) &&",
          "1908:           (wccp_wccp_address_table.table_ipv6 != NULL) &&",
          "1909:           (i < wccp_wccp_address_table.table_length))",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1916:       pi = proto_tree_add_string_format_value(element_tree, hf_address_table_element, tvb,",
          "1917:                                               offset, address_length, addr,",
          "1918:                                               \"%d: %s\", i+1, addr);",
          "1920:         expert_add_info_format(pinfo, pi, &ei_wccp_length_bad, \"Ran out of space to store address\");",
          "1921:     }",
          "1922:     EAT(address_length);",
          "1923:   }",
          "1925:   return length;",
          "1926: }",
          "",
          "[Removed Lines]",
          "1919:       if ((address_length * i) > wccp_wccp_address_table.table_length)",
          "",
          "[Added Lines]",
          "1922:       if (i > wccp_wccp_address_table.table_length)",
          "1928:   wccp_wccp_address_table.in_use = TRUE;",
          "",
          "---------------"
        ]
      }
    }
  ]
}
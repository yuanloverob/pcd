{
  "cve_id": "CVE-2021-20223",
  "cve_desc": "",
  "repo": "sqlite/sqlite",
  "patch_hash": "d1d43efa4fb0f2098c0e2c5bf2e807c58d5ec05b",
  "patch_info": {
    "commit_hash": "d1d43efa4fb0f2098c0e2c5bf2e807c58d5ec05b",
    "repo": "sqlite/sqlite",
    "commit_url": "https://github.com/sqlite/sqlite/commit/d1d43efa4fb0f2098c0e2c5bf2e807c58d5ec05b",
    "files": [
      "ext/fts5/fts5_unicode2.c",
      "ext/fts5/test/fts5tok1.test",
      "manifest",
      "manifest.uuid"
    ],
    "message": "Prevent fts5 tokenizer unicode61 from considering '\\0' to be a token characters, even if other characters of class \"Cc\" are.\n\nFossilOrigin-Name: b7b7bde9b7a03665e3691c6d51118965f216d2dfb1617f138b9f9e60e418ed2f",
    "before_after_code_files": [
      "ext/fts5/fts5_unicode2.c||ext/fts5/fts5_unicode2.c",
      "ext/fts5/test/fts5tok1.test||ext/fts5/test/fts5tok1.test",
      "manifest.uuid||manifest.uuid"
    ]
  },
  "patch_diff": {
    "ext/fts5/fts5_unicode2.c||ext/fts5/fts5_unicode2.c": [
      "File: ext/fts5/fts5_unicode2.c -> ext/fts5/fts5_unicode2.c"
    ],
    "ext/fts5/test/fts5tok1.test||ext/fts5/test/fts5tok1.test": [
      "File: ext/fts5/test/fts5tok1.test -> ext/fts5/test/fts5tok1.test",
      "--- Hunk 1 ---",
      "[Context before]",
      "111:   SELECT * FROM t4;",
      "112: } {1 {SQL logic error}}",
      "115: finish_test",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "114: #-------------------------------------------------------------------------",
      "115: # Embedded 0x00 characters.",
      "116: #",
      "117: reset_db",
      "118: do_execsql_test 3.1.0 {",
      "119:   CREATE VIRTUAL TABLE t1 USING fts5(z);",
      "120:   CREATE VIRTUAL TABLE tt USING fts5vocab(t1, 'instance');",
      "121:   INSERT INTO t1 VALUES('abc' || char(0) || 'def');",
      "122:   SELECT * FROM tt;",
      "123: } { abc 1 z 0 def 1 z 1 }",
      "124: do_execsql_test 3.1.1 {",
      "125:   SELECT hex(z) FROM t1;",
      "126: } {61626300646566}",
      "127: do_execsql_test 3.1.2 {",
      "128:   INSERT INTO t1(t1) VALUES('integrity-check');",
      "129: } {}",
      "131: do_execsql_test 3.2.0 {",
      "132:   CREATE VIRTUAL TABLE t2 USING fts5(z,",
      "133:       tokenize=\"unicode61 categories 'L* N* Co Cc'\"",
      "134:   );",
      "135:   CREATE VIRTUAL TABLE tu USING fts5vocab(t2, 'instance');",
      "137:   INSERT INTO t2 VALUES('abc' || char(0) || 'def');",
      "138:   SELECT * FROM tu;",
      "139: } { abc 1 z 0 def 1 z 1 }",
      "141: do_execsql_test 3.2.1 {",
      "142:   SELECT hex(z) FROM t1;",
      "143: } {61626300646566}",
      "145: do_execsql_test 3.2.2 {",
      "146:   INSERT INTO t1(t1) VALUES('integrity-check');",
      "147: } {}",
      "",
      "---------------"
    ],
    "manifest.uuid||manifest.uuid": [
      "File: manifest.uuid -> manifest.uuid",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "1: 0e7e113d9f2c929c1f8a85e2cfad8e2e60f0e8770212b5e5320fb2a2c42911f8",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "ac45b7402d6956ba755fdefc871fe9bff8c690ee",
      "candidate_info": {
        "commit_hash": "ac45b7402d6956ba755fdefc871fe9bff8c690ee",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/ac45b7402d6956ba755fdefc871fe9bff8c690ee",
        "files": [
          "manifest",
          "manifest.uuid",
          "src/alter.c",
          "src/attach.c",
          "src/build.c",
          "src/delete.c",
          "src/parse.y",
          "src/resolve.c",
          "src/select.c",
          "src/sqliteInt.h",
          "src/trigger.c",
          "src/update.c",
          "test/altertab3.test",
          "test/fts4upfrom.test",
          "test/pg_common.tcl",
          "test/triggerupfrom.test",
          "test/upfrom1.tcl",
          "test/upfrom1.test",
          "test/upfrom2.test",
          "test/upfrom3.test",
          "test/upfromfault.test"
        ],
        "message": "Support a FROM clause in UPDATE statements, as postgres does.\n\nFossilOrigin-Name: 7d7d5ecbd70cc39ab7a641ae26af0d3b69d5cb02e626b620102a6e19e7d8a577",
        "before_after_code_files": [
          "manifest.uuid||manifest.uuid",
          "src/alter.c||src/alter.c",
          "src/attach.c||src/attach.c",
          "src/build.c||src/build.c",
          "src/delete.c||src/delete.c",
          "src/parse.y||src/parse.y",
          "src/resolve.c||src/resolve.c",
          "src/select.c||src/select.c",
          "src/sqliteInt.h||src/sqliteInt.h",
          "src/trigger.c||src/trigger.c",
          "src/update.c||src/update.c",
          "test/altertab3.test||test/altertab3.test",
          "test/fts4upfrom.test||test/fts4upfrom.test",
          "test/pg_common.tcl||test/pg_common.tcl",
          "test/triggerupfrom.test||test/triggerupfrom.test",
          "test/upfrom1.tcl||test/upfrom1.tcl",
          "test/upfrom1.test||test/upfrom1.test",
          "test/upfrom2.test||test/upfrom2.test",
          "test/upfrom3.test||test/upfrom3.test",
          "test/upfromfault.test||test/upfromfault.test"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: 73d62f82f94347c60e026bc9cb859fec2d8b5f0c756df0c4941f11817234bff8",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/alter.c||src/alter.c": [
          "File: src/alter.c -> src/alter.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1191:       if( pParse->nErr ) rc = pParse->rc;",
          "1192:     }",
          "1193:     if( rc==SQLITE_OK && pStep->zTarget ){",
          "1205:           rc = sqlite3ResolveExprNames(&sNC, pStep->pWhere);",
          "1206:         }",
          "1207:         if( rc==SQLITE_OK ){",
          "",
          "[Removed Lines]",
          "1194:       Table *pTarget = sqlite3LocateTable(pParse, 0, pStep->zTarget, zDb);",
          "1195:       if( pTarget==0 ){",
          "1196:         rc = SQLITE_ERROR;",
          "1197:       }else if( SQLITE_OK==(rc = sqlite3ViewGetColumnNames(pParse, pTarget)) ){",
          "1198:         SrcList sSrc;",
          "1199:         memset(&sSrc, 0, sizeof(sSrc));",
          "1200:         sSrc.nSrc = 1;",
          "1201:         sSrc.a[0].zName = pStep->zTarget;",
          "1202:         sSrc.a[0].pTab = pTarget;",
          "1203:         sNC.pSrcList = &sSrc;",
          "1204:         if( pStep->pWhere ){",
          "",
          "[Added Lines]",
          "1194:       SrcList *pSrc = sqlite3TriggerStepSrc(pParse, pStep);",
          "1195:       if( pSrc ){",
          "1196:         int i;",
          "1197:         for(i=0; i<pSrc->nSrc; i++){",
          "1198:           struct SrcList_item *p = &pSrc->a[i];",
          "1199:           p->pTab = sqlite3LocateTableItem(pParse, 0, p);",
          "1200:           p->iCursor = pParse->nTab++;",
          "1201:           if( p->pTab==0 ){",
          "1202:             rc = SQLITE_ERROR;",
          "1203:           }else{",
          "1204:             p->pTab->nTabRef++;",
          "1205:             rc = sqlite3ViewGetColumnNames(pParse, p->pTab);",
          "1206:           }",
          "1207:         }",
          "1208:         sNC.pSrcList = pSrc;",
          "1209:         if( rc==SQLITE_OK && pStep->pWhere ){",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1211:         if( pStep->pUpsert ){",
          "1212:           Upsert *pUpsert = pStep->pUpsert;",
          "1213:           assert( rc==SQLITE_OK );",
          "1215:           sNC.uNC.pUpsert = pUpsert;",
          "1216:           sNC.ncFlags = NC_UUpsert;",
          "1217:           rc = sqlite3ResolveExprListNames(&sNC, pUpsert->pUpsertTarget);",
          "",
          "[Removed Lines]",
          "1214:           pUpsert->pUpsertSrc = &sSrc;",
          "",
          "[Added Lines]",
          "1219:           pUpsert->pUpsertSrc = pSrc;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1228:           sNC.ncFlags = 0;",
          "1229:         }",
          "1230:         sNC.pSrcList = 0;",
          "1231:       }",
          "1232:     }",
          "1233:   }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1236:         sqlite3SrcListDelete(db, pSrc);",
          "1237:       }else{",
          "1238:         rc = SQLITE_NOMEM;",
          "",
          "---------------"
        ],
        "src/attach.c||src/attach.c": [
          "File: src/attach.c -> src/attach.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "599:     if( sqlite3FixExprList(pFix, pStep->pExprList) ){",
          "600:       return 1;",
          "601:     }",
          "602: #ifndef SQLITE_OMIT_UPSERT",
          "603:     if( pStep->pUpsert ){",
          "604:       Upsert *pUp = pStep->pUpsert;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "602:     if( pStep->pFrom && sqlite3FixSrcList(pFix, pStep->pFrom) ){",
          "603:       return 1;",
          "604:     }",
          "",
          "---------------"
        ],
        "src/build.c||src/build.c": [
          "File: src/build.c -> src/build.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "4569:   }",
          "4570: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4577: SrcList *sqlite3SrcListAppendList(Parse *pParse, SrcList *p1, SrcList *p2){",
          "4578:   assert( p1 && p1->nSrc==1 );",
          "4579:   if( p2 ){",
          "4580:     SrcList *pNew = sqlite3SrcListEnlarge(pParse, p1, p2->nSrc, 1);",
          "4581:     if( pNew==0 ){",
          "4582:       sqlite3SrcListDelete(pParse->db, p2);",
          "4583:     }else{",
          "4584:       p1 = pNew;",
          "4585:       memcpy(&p1->a[1], p2->a, p2->nSrc*sizeof(struct SrcList_item));",
          "4586:       sqlite3_free(p2);",
          "4587:     }",
          "4588:   }",
          "4589:   return p1;",
          "4590: }",
          "",
          "---------------"
        ],
        "src/delete.c||src/delete.c": [
          "File: src/delete.c -> src/delete.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "31: Table *sqlite3SrcListLookup(Parse *pParse, SrcList *pSrc){",
          "32:   struct SrcList_item *pItem = pSrc->a;",
          "33:   Table *pTab;",
          "35:   pTab = sqlite3LocateTableItem(pParse, 0, pItem);",
          "36:   sqlite3DeleteTable(pParse->db, pItem->pTab);",
          "37:   pItem->pTab = pTab;",
          "",
          "[Removed Lines]",
          "34:   assert( pItem && pSrc->nSrc==1 );",
          "",
          "[Added Lines]",
          "34:   assert( pItem && pSrc->nSrc>=1 );",
          "",
          "---------------"
        ],
        "src/parse.y||src/parse.y": [
          "File: src/parse.y -> src/parse.y",
          "--- Hunk 1 ---",
          "[Context before]",
          "662: from(A) ::= FROM seltablist(X). {",
          "663:   A = X;",
          "664:   sqlite3SrcListShiftJoinType(A);",
          "",
          "[Removed Lines]",
          "661: from(A) ::= .                {A = sqlite3DbMallocZero(pParse->db, sizeof(*A));}",
          "",
          "[Added Lines]",
          "661: from(A) ::= .                {A = 0;}",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "892: %if SQLITE_ENABLE_UPDATE_DELETE_LIMIT || SQLITE_UDL_CAPABLE_PARSER",
          "894:         where_opt(W) orderby_opt(O) limit_opt(L).  {",
          "895:   sqlite3SrcListIndexedBy(pParse, X, &I);",
          "896:   sqlite3ExprListCheckLength(pParse,Y,\"set list\");",
          "897: #ifndef SQLITE_ENABLE_UPDATE_DELETE_LIMIT",
          "898:   if( O || L ){",
          "",
          "[Removed Lines]",
          "893: cmd ::= with UPDATE orconf(R) xfullname(X) indexed_opt(I) SET setlist(Y)",
          "",
          "[Added Lines]",
          "893: cmd ::= with UPDATE orconf(R) xfullname(X) indexed_opt(I) SET setlist(Y) from(F)",
          "896:   X = sqlite3SrcListAppendList(pParse, X, F);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "904:   sqlite3Update(pParse,X,Y,W,R,O,L,0);",
          "905: }",
          "906: %else",
          "908:         where_opt(W). {",
          "909:   sqlite3SrcListIndexedBy(pParse, X, &I);",
          "910:   sqlite3ExprListCheckLength(pParse,Y,\"set list\");",
          "911:   sqlite3Update(pParse,X,Y,W,R,0,0,0);",
          "912: }",
          "913: %endif",
          "",
          "[Removed Lines]",
          "907: cmd ::= with UPDATE orconf(R) xfullname(X) indexed_opt(I) SET setlist(Y)",
          "",
          "[Added Lines]",
          "908: cmd ::= with UPDATE orconf(R) xfullname(X) indexed_opt(I) SET setlist(Y) from(F)",
          "912:   X = sqlite3SrcListAppendList(pParse, X, F);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1515: %destructor trigger_cmd {sqlite3DeleteTriggerStep(pParse->db, $$);}",
          "1517: trigger_cmd(A) ::=",
          "1522: trigger_cmd(A) ::= scanpt(B) insert_cmd(R) INTO",
          "",
          "[Removed Lines]",
          "1518:    UPDATE(B) orconf(R) trnm(X) tridxby SET setlist(Y) where_opt(Z) scanpt(E).",
          "1519:    {A = sqlite3TriggerUpdateStep(pParse, &X, Y, Z, R, B.z, E);}",
          "",
          "[Added Lines]",
          "1520:    UPDATE(B) orconf(R) trnm(X) tridxby SET setlist(Y) from(F) where_opt(Z) scanpt(E).",
          "1521:    {A = sqlite3TriggerUpdateStep(pParse, &X, F, Y, Z, R, B.z, E);}",
          "",
          "---------------"
        ],
        "src/resolve.c||src/resolve.c": [
          "File: src/resolve.c -> src/resolve.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "756: #endif",
          "757:   switch( pExpr->op ){",
          "764:     case TK_ROW: {",
          "765:       SrcList *pSrcList = pNC->pSrcList;",
          "766:       struct SrcList_item *pItem;",
          "768:       pItem = pSrcList->a;",
          "770:       pExpr->op = TK_COLUMN;",
          "771:       pExpr->y.pTab = pItem->pTab;",
          "772:       pExpr->iTable = pItem->iCursor;",
          "774:       pExpr->affExpr = SQLITE_AFF_INTEGER;",
          "775:       break;",
          "776:     }",
          "",
          "[Removed Lines]",
          "759: #if defined(SQLITE_ENABLE_UPDATE_DELETE_LIMIT) && !defined(SQLITE_OMIT_SUBQUERY)",
          "767:       assert( pSrcList && pSrcList->nSrc==1 );",
          "769:       assert( HasRowid(pItem->pTab) && pItem->pTab->pSelect==0 );",
          "773:       pExpr->iColumn = -1;",
          "777: #endif /* defined(SQLITE_ENABLE_UPDATE_DELETE_LIMIT)",
          "",
          "[Added Lines]",
          "767:       assert( pSrcList && pSrcList->nSrc>=1 );",
          "772:       pExpr->iColumn--;",
          "",
          "---------------"
        ],
        "src/select.c||src/select.c": [
          "File: src/select.c -> src/select.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "103: void sqlite3SelectDestInit(SelectDest *pDest, int eDest, int iParm){",
          "104:   pDest->eDest = (u8)eDest;",
          "105:   pDest->iSDParm = iParm;",
          "106:   pDest->zAffSdst = 0;",
          "107:   pDest->iSdst = 0;",
          "108:   pDest->nSdst = 0;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "106:   pDest->iSDParm2 = 0;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "975:       testcase( eDest==SRT_Coroutine );",
          "976:       testcase( eDest==SRT_Output );",
          "977:       assert( eDest==SRT_Set || eDest==SRT_Mem",
          "979:     }",
          "980:     sRowLoadInfo.regResult = regResult;",
          "981:     sRowLoadInfo.ecelFlags = ecelFlags;",
          "",
          "[Removed Lines]",
          "978:            || eDest==SRT_Coroutine || eDest==SRT_Output );",
          "",
          "[Added Lines]",
          "979:            || eDest==SRT_Coroutine || eDest==SRT_Output",
          "980:            || eDest==SRT_Upfrom );",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1124:       break;",
          "1125:     }",
          "1127: #ifndef SQLITE_OMIT_SUBQUERY",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1129:     case SRT_Upfrom: {",
          "1130:       if( pSort ){",
          "1131:         pushOntoSorter(",
          "1132:             pParse, pSort, p, regResult, regOrig, nResultCol, nPrefixReg);",
          "1133:       }else{",
          "1134:         int i2 = pDest->iSDParm2;",
          "1135:         int r1 = sqlite3GetTempReg(pParse);",
          "1136:         sqlite3VdbeAddOp3(v, OP_MakeRecord,regResult+(i2<0),nResultCol-(i2<0),r1);",
          "1137:         if( i2<0 ){",
          "1138:           sqlite3VdbeAddOp3(v, OP_Insert, iParm, r1, regResult);",
          "1139:         }else{",
          "1140:           sqlite3VdbeAddOp4Int(v, OP_IdxInsert, iParm, r1, regResult, i2);",
          "1141:         }",
          "1142:       }",
          "1143:       break;",
          "1144:     }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1555:       break;",
          "1556:     }",
          "1557: #endif",
          "1558:     default: {",
          "1559:       assert( eDest==SRT_Output || eDest==SRT_Coroutine );",
          "1560:       testcase( eDest==SRT_Output );",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1578:     case SRT_Upfrom: {",
          "1579:       int i2 = pDest->iSDParm2;",
          "1580:       int r1 = sqlite3GetTempReg(pParse);",
          "1581:       sqlite3VdbeAddOp3(v, OP_MakeRecord,regRow+(i2<0),nColumn-(i2<0),r1);",
          "1582:       if( i2<0 ){",
          "1583:         sqlite3VdbeAddOp3(v, OP_Insert, iParm, r1, regRow);",
          "1584:       }else{",
          "1585:         sqlite3VdbeAddOp4Int(v, OP_IdxInsert, iParm, r1, regRow, i2);",
          "1586:       }",
          "1587:       break;",
          "1588:     }",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "4969:   for(i=0, pFrom=pTabList->a; i<pTabList->nSrc; i++, pFrom++){",
          "4970:     Table *pTab;",
          "4971:     assert( pFrom->fg.isRecursive==0 || pFrom->pTab!=0 );",
          "4974: #ifndef SQLITE_OMIT_CTE",
          "4975:     if( withExpand(pWalker, pFrom) ) return WRC_Abort;",
          "4976:     if( pFrom->pTab ) {} else",
          "",
          "[Removed Lines]",
          "4972:     if( pFrom->fg.isRecursive ) continue;",
          "4973:     assert( pFrom->pTab==0 );",
          "",
          "[Added Lines]",
          "5003:     if( pFrom->pTab ) continue;",
          "5004:     assert( pFrom->fg.isRecursive==0 );",
          "",
          "---------------"
        ],
        "src/sqliteInt.h||src/sqliteInt.h": [
          "File: src/sqliteInt.h -> src/sqliteInt.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "4230: IdList *sqlite3IdListAppend(Parse*, IdList*, Token*);",
          "4231: int sqlite3IdListIndex(IdList*,const char*);",
          "4232: SrcList *sqlite3SrcListEnlarge(Parse*, SrcList*, int, int);",
          "4233: SrcList *sqlite3SrcListAppend(Parse*, SrcList*, Token*, Token*);",
          "4234: SrcList *sqlite3SrcListAppendFromTerm(Parse*, SrcList*, Token*, Token*,",
          "4235:                                       Token*, Select*, Expr*, IdList*);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4244: SrcList *sqlite3SrcListAppendList(Parse *pParse, SrcList *p1, SrcList *p2);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "4399:   TriggerStep *sqlite3TriggerInsertStep(Parse*,Token*, IdList*,",
          "4400:                                         Select*,u8,Upsert*,",
          "4401:                                         const char*,const char*);",
          "4404:   TriggerStep *sqlite3TriggerDeleteStep(Parse*,Token*, Expr*,",
          "4405:                                         const char*,const char*);",
          "4406:   void sqlite3DeleteTrigger(sqlite3*, Trigger*);",
          "4407:   void sqlite3UnlinkAndDeleteTrigger(sqlite3*,int,const char*);",
          "4408:   u32 sqlite3TriggerColmask(Parse*,Trigger*,ExprList*,int,int,Table*,int);",
          "4409: # define sqlite3ParseToplevel(p) ((p)->pToplevel ? (p)->pToplevel : (p))",
          "4410: # define sqlite3IsToplevel(p) ((p)->pToplevel==0)",
          "4411: #else",
          "",
          "[Removed Lines]",
          "4402:   TriggerStep *sqlite3TriggerUpdateStep(Parse*,Token*,ExprList*, Expr*, u8,",
          "4403:                                         const char*,const char*);",
          "",
          "[Added Lines]",
          "4414:   TriggerStep *sqlite3TriggerUpdateStep(Parse*,Token*,SrcList*,ExprList*,",
          "4415:                                         Expr*, u8, const char*,const char*);",
          "4421:   SrcList *sqlite3TriggerStepSrc(Parse*, TriggerStep*);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "4419: # define sqlite3ParseToplevel(p) p",
          "4420: # define sqlite3IsToplevel(p) 1",
          "4421: # define sqlite3TriggerColmask(A,B,C,D,E,F,G) 0",
          "4422: #endif",
          "4424: int sqlite3JoinType(Parse*, Token*, Token*, Token*);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4435: # define sqlite3TriggerStepSrc(A,B) 0",
          "",
          "---------------"
        ],
        "src/trigger.c||src/trigger.c": [
          "File: src/trigger.c -> src/trigger.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "26:     sqlite3SelectDelete(db, pTmp->pSelect);",
          "27:     sqlite3IdListDelete(db, pTmp->pIdList);",
          "28:     sqlite3UpsertDelete(db, pTmp->pUpsert);",
          "29:     sqlite3DbFree(db, pTmp->zSpan);",
          "31:     sqlite3DbFree(db, pTmp);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "29:     sqlite3SrcListDelete(db, pTmp->pFrom);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "486: TriggerStep *sqlite3TriggerUpdateStep(",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "490:   SrcList *pFrom,",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "500:     if( IN_RENAME_OBJECT ){",
          "501:       pTriggerStep->pExprList = pEList;",
          "502:       pTriggerStep->pWhere = pWhere;",
          "503:       pEList = 0;",
          "504:       pWhere = 0;",
          "505:     }else{",
          "506:       pTriggerStep->pExprList = sqlite3ExprListDup(db, pEList, EXPRDUP_REDUCE);",
          "507:       pTriggerStep->pWhere = sqlite3ExprDup(db, pWhere, EXPRDUP_REDUCE);",
          "508:     }",
          "509:     pTriggerStep->orconf = orconf;",
          "510:   }",
          "511:   sqlite3ExprListDelete(db, pEList);",
          "512:   sqlite3ExprDelete(db, pWhere);",
          "513:   return pTriggerStep;",
          "514: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "505:       pTriggerStep->pFrom = pFrom;",
          "508:       pFrom = 0;",
          "512:       pTriggerStep->pFrom = sqlite3SrcListDup(db, pFrom, EXPRDUP_REDUCE);",
          "515:   }else{",
          "516:     sqlite3SrcListDelete(db, pFrom);",
          "520:   sqlite3SrcListDelete(db, pFrom);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "742: ){",
          "743:   sqlite3 *db = pParse->db;",
          "747:   pSrc = sqlite3SrcListAppend(pParse, 0, 0, 0);",
          "748:   if( pSrc ){",
          "757:     }",
          "758:   }",
          "759:   return pSrc;",
          "760: }",
          "",
          "[Removed Lines]",
          "739: static SrcList *targetSrcList(",
          "749:     assert( pSrc->nSrc>0 );",
          "750:     pSrc->a[pSrc->nSrc-1].zName = sqlite3DbStrDup(db, pStep->zTarget);",
          "751:     iDb = sqlite3SchemaToIndex(db, pStep->pTrig->pSchema);",
          "752:     if( iDb==0 || iDb>=2 ){",
          "753:       const char *zDb;",
          "754:       assert( iDb<db->nDb );",
          "755:       zDb = db->aDb[iDb].zDbSName;",
          "756:       pSrc->a[pSrc->nSrc-1].zDatabase =  sqlite3DbStrDup(db, zDb);",
          "",
          "[Added Lines]",
          "747: SrcList *sqlite3TriggerStepSrc(",
          "753:   char *zName = sqlite3DbStrDup(db, pStep->zTarget);",
          "755:   assert( pSrc==0 || pSrc->nSrc==1 );",
          "756:   assert( zName || pSrc==0 );",
          "758:     Schema *pSchema = pStep->pTrig->pSchema;",
          "759:     pSrc->a[0].zName = zName;",
          "760:     if( pSchema!=db->aDb[1].pSchema ){",
          "761:       pSrc->a[0].pSchema = pSchema;",
          "763:     if( pStep->pFrom ){",
          "764:       SrcList *pDup = sqlite3SrcListDup(db, pStep->pFrom, 0);",
          "765:       pSrc = sqlite3SrcListAppendList(pParse, pSrc, pDup);",
          "766:     }",
          "767:   }else{",
          "768:     sqlite3DbFree(db, zName);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "803:     switch( pStep->op ){",
          "804:       case TK_UPDATE: {",
          "805:         sqlite3Update(pParse,",
          "807:           sqlite3ExprListDup(db, pStep->pExprList, 0),",
          "808:           sqlite3ExprDup(db, pStep->pWhere, 0),",
          "809:           pParse->eOrconf, 0, 0, 0",
          "",
          "[Removed Lines]",
          "806:           targetSrcList(pParse, pStep),",
          "",
          "[Added Lines]",
          "817:           sqlite3TriggerStepSrc(pParse, pStep),",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "812:       }",
          "813:       case TK_INSERT: {",
          "814:         sqlite3Insert(pParse,",
          "816:           sqlite3SelectDup(db, pStep->pSelect, 0),",
          "817:           sqlite3IdListDup(db, pStep->pIdList),",
          "818:           pParse->eOrconf,",
          "",
          "[Removed Lines]",
          "815:           targetSrcList(pParse, pStep),",
          "",
          "[Added Lines]",
          "826:           sqlite3TriggerStepSrc(pParse, pStep),",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "822:       }",
          "823:       case TK_DELETE: {",
          "824:         sqlite3DeleteFrom(pParse,",
          "826:           sqlite3ExprDup(db, pStep->pWhere, 0), 0, 0",
          "827:         );",
          "828:         break;",
          "",
          "[Removed Lines]",
          "825:           targetSrcList(pParse, pStep),",
          "",
          "[Added Lines]",
          "836:           sqlite3TriggerStepSrc(pParse, pStep),",
          "",
          "---------------"
        ],
        "src/update.c||src/update.c": [
          "File: src/update.c -> src/update.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "130:                                             aXRef, chngRowid);",
          "131: }",
          "140: void sqlite3Update(",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "139: static Expr *exprRowColumn(Parse *pParse, int iCol){",
          "140:   Expr *pRet = sqlite3PExpr(pParse, TK_ROW, 0, 0);",
          "141:   if( pRet ) pRet->iColumn = iCol+1;",
          "142:   return pRet;",
          "143: }",
          "183: static void updateFromSelect(",
          "190:   ExprList *pOrderBy,",
          "191:   Expr *pLimit",
          "192: ){",
          "193:   int i;",
          "194:   SelectDest dest;",
          "195:   Select *pSelect = 0;",
          "196:   ExprList *pList = 0;",
          "197:   ExprList *pGrp = 0;",
          "198:   sqlite3 *db = pParse->db;",
          "199:   Table *pTab = pTabList->a[0].pTab;",
          "200:   SrcList *pSrc;",
          "201:   Expr *pWhere2;",
          "202:   Expr *pLimit2;",
          "203:   ExprList *pOrderBy2;",
          "204:   int eDest;",
          "206:   if( pOrderBy && pLimit==0 ) {",
          "207:     sqlite3ErrorMsg(pParse, \"ORDER BY without LIMIT on UPDATE\");",
          "208:     return;",
          "209:   }",
          "211:   pSrc = sqlite3SrcListDup(db, pTabList, 0);",
          "212:   pWhere2 = sqlite3ExprDup(db, pWhere, 0);",
          "213:   pLimit2 = sqlite3ExprDup(db, pLimit, 0);",
          "214:   pOrderBy2 = sqlite3ExprListDup(db, pOrderBy, 0);",
          "216:   assert( pTabList->nSrc>1 );",
          "217:   if( pSrc ){",
          "218:     pSrc->a[0].iCursor = -1;",
          "219:     pSrc->a[0].pTab->nTabRef--;",
          "220:     pSrc->a[0].pTab = 0;",
          "221:   }",
          "222:   if( pPk ){",
          "223:     for(i=0; i<pPk->nKeyCol; i++){",
          "224:       Expr *pNew = exprRowColumn(pParse, pPk->aiColumn[i]);",
          "225:       if( pLimit ){",
          "226:         pGrp = sqlite3ExprListAppend(pParse, pGrp, sqlite3ExprDup(db, pNew, 0));",
          "227:       }",
          "228:       pList = sqlite3ExprListAppend(pParse, pList, pNew);",
          "229:     }",
          "230:     eDest = SRT_Upfrom;",
          "231:   }else if( pTab->pSelect ){",
          "232:     for(i=0; i<pTab->nCol; i++){",
          "233:       pList = sqlite3ExprListAppend(pParse, pList, exprRowColumn(pParse, i));",
          "234:     }",
          "235:     eDest = SRT_Table;",
          "236:   }else{",
          "237:     eDest = IsVirtual(pTab) ? SRT_Table : SRT_Upfrom;",
          "238:     pList = sqlite3ExprListAppend(pParse, 0, sqlite3PExpr(pParse,TK_ROW,0,0));",
          "239:     if( pLimit ){",
          "240:       pGrp = sqlite3ExprListAppend(pParse, 0, sqlite3PExpr(pParse,TK_ROW,0,0));",
          "241:     }",
          "242:   }",
          "243:   assert( pChanges || db->mallocFailed );",
          "244:   if( pChanges ){",
          "245:     for(i=0; i<pChanges->nExpr; i++){",
          "246:       pList = sqlite3ExprListAppend(pParse, pList,",
          "247:           sqlite3ExprDup(db, pChanges->a[i].pExpr, 0)",
          "248:       );",
          "249:     }",
          "250:   }",
          "251:   pSelect = sqlite3SelectNew(pParse, pList,",
          "252:       pSrc, pWhere2, pGrp, 0, pOrderBy2, SF_IncludeHidden, pLimit2",
          "253:   );",
          "254:   sqlite3SelectDestInit(&dest, eDest, iEph);",
          "255:   dest.iSDParm2 = (pPk ? pPk->nKeyCol : -1);",
          "256:   sqlite3Select(pParse, pSelect, &dest);",
          "257:   sqlite3SelectDelete(db, pSelect);",
          "258: }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "207:   if( pParse->nErr || db->mallocFailed ){",
          "208:     goto update_cleanup;",
          "209:   }",
          "",
          "[Removed Lines]",
          "210:   assert( pTabList->nSrc==1 );",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "232: # define isView 0",
          "233: #endif",
          "235: #ifdef SQLITE_ENABLE_UPDATE_DELETE_LIMIT",
          "237:     pWhere = sqlite3LimitWhere(",
          "238:         pParse, pTabList, pWhere, pOrderBy, pLimit, \"UPDATE\"",
          "239:     );",
          "",
          "[Removed Lines]",
          "236:   if( !isView ){",
          "",
          "[Added Lines]",
          "369:   nChangeFrom = (pTabList->nSrc>1) ? pChanges->nExpr : 0;",
          "370:   assert( nChangeFrom==0 || pUpsert==0 );",
          "373:   if( !isView && nChangeFrom==0 ){",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "303:   chngRowid = chngPk = 0;",
          "304:   for(i=0; i<pChanges->nExpr; i++){",
          "306:       goto update_cleanup;",
          "307:     }",
          "308:     for(j=0; j<pTab->nCol; j++){",
          "",
          "[Removed Lines]",
          "305:     if( sqlite3ResolveExprNames(&sNC, pChanges->a[i].pExpr) ){",
          "",
          "[Added Lines]",
          "444:     if( nChangeFrom==0 && sqlite3ResolveExprNames(&sNC, pChanges->a[i].pExpr) ){",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "310:         if( j==pTab->iPKey ){",
          "311:           chngRowid = 1;",
          "312:           pRowidExpr = pChanges->a[i].pExpr;",
          "313:         }else if( pPk && (pTab->aCol[j].colFlags & COLFLAG_PRIMKEY)!=0 ){",
          "314:           chngPk = 1;",
          "315:         }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "452:           iRowidExpr = i;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "332:         j = -1;",
          "333:         chngRowid = 1;",
          "334:         pRowidExpr = pChanges->a[i].pExpr;",
          "335:       }else{",
          "336:         sqlite3ErrorMsg(pParse, \"no such column: %s\", pChanges->a[i].zEName);",
          "337:         pParse->checkSchema = 1;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "475:         iRowidExpr = i;",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "463: #if !defined(SQLITE_OMIT_VIEW) && !defined(SQLITE_OMIT_TRIGGER)",
          "465:     sqlite3MaterializeView(pParse, pTab,",
          "466:         pWhere, pOrderBy, pLimit, iDataCur",
          "467:     );",
          "",
          "[Removed Lines]",
          "464:   if( isView ){",
          "",
          "[Added Lines]",
          "605:   if( nChangeFrom==0 && isView ){",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "477:     goto update_cleanup;",
          "478:   }",
          "",
          "[Removed Lines]",
          "476:   if( sqlite3ResolveExprNames(&sNC, pWhere) ){",
          "",
          "[Added Lines]",
          "617:   if( nChangeFrom==0 && sqlite3ResolveExprNames(&sNC, pWhere) ){",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "500:     sqlite3VdbeAddOp2(v, OP_Integer, 0, regRowCount);",
          "501:   }",
          "504:     sqlite3VdbeAddOp3(v, OP_Null, 0, regRowSet, regOldRowid);",
          "505:   }else{",
          "508:     iPk = pParse->nMem+1;",
          "509:     pParse->nMem += nPk;",
          "510:     regKey = ++pParse->nMem;",
          "511:     if( pUpsert==0 ){",
          "512:       iEph = pParse->nTab++;",
          "516:     }",
          "517:   }",
          "529:   }else{",
          "562:         }",
          "564:       }",
          "565:     }",
          "593:     }else{",
          "597:     }",
          "598:   }",
          "600:   if( pUpsert==0 ){",
          "602:       sqlite3WhereEnd(pWInfo);",
          "603:     }",
          "",
          "[Removed Lines]",
          "503:   if( HasRowid(pTab) ){",
          "506:     assert( pPk!=0 );",
          "507:     nPk = pPk->nKeyCol;",
          "513:         sqlite3VdbeAddOp3(v, OP_Null, 0, iPk, iPk+nPk-1);",
          "514:       addrOpen = sqlite3VdbeAddOp2(v, OP_OpenEphemeral, iEph, nPk);",
          "515:       sqlite3VdbeSetP4KeyInfo(pParse, pPk);",
          "519:   if( pUpsert ){",
          "525:     pWInfo = 0;",
          "526:     eOnePass = ONEPASS_SINGLE;",
          "527:     sqlite3ExprIfFalse(pParse, pWhere, labelBreak, SQLITE_JUMPIFNULL);",
          "528:     bFinishSeek = 0;",
          "537:     flags = WHERE_ONEPASS_DESIRED|WHERE_SEEK_UNIQ_TABLE;",
          "538:     if( !pParse->nested && !pTrigger && !hasFK && !chngKey && !bReplace ){",
          "539:       flags |= WHERE_ONEPASS_MULTIROW;",
          "540:     }",
          "541:     pWInfo = sqlite3WhereBegin(pParse, pTabList, pWhere, 0, 0, flags, iIdxCur);",
          "542:     if( pWInfo==0 ) goto update_cleanup;",
          "554:     eOnePass = sqlite3WhereOkOnePass(pWInfo, aiCurOnePass);",
          "555:     bFinishSeek = sqlite3WhereUsesDeferredSeek(pWInfo);",
          "556:     if( eOnePass!=ONEPASS_SINGLE ){",
          "557:       sqlite3MultiWrite(pParse);",
          "558:       if( eOnePass==ONEPASS_MULTI ){",
          "559:         int iCur = aiCurOnePass[1];",
          "560:         if( iCur>=0 && iCur!=iDataCur && aToOpen[iCur-iBaseCur] ){",
          "561:           eOnePass = ONEPASS_OFF;",
          "563:         assert( iCur!=iDataCur || !HasRowid(pTab) );",
          "566:   }",
          "568:   if( HasRowid(pTab) ){",
          "572:     sqlite3VdbeAddOp2(v, OP_Rowid, iDataCur, regOldRowid);",
          "573:     if( eOnePass==ONEPASS_OFF ){",
          "575:       aRegIdx[nAllIdx] = ++pParse->nMem;",
          "576:       sqlite3VdbeAddOp2(v, OP_RowSetAdd, regRowSet, regOldRowid);",
          "577:     }",
          "578:   }else{",
          "584:     for(i=0; i<nPk; i++){",
          "585:       assert( pPk->aiColumn[i]>=0 );",
          "586:       sqlite3ExprCodeGetColumnOfTable(v, pTab, iDataCur,",
          "587:                                       pPk->aiColumn[i], iPk+i);",
          "588:     }",
          "589:     if( eOnePass ){",
          "590:       if( addrOpen ) sqlite3VdbeChangeToNoop(v, addrOpen);",
          "591:       nKey = nPk;",
          "592:       regKey = iPk;",
          "594:       sqlite3VdbeAddOp4(v, OP_MakeRecord, iPk, nPk, regKey,",
          "595:                         sqlite3IndexAffinityStr(db, pPk), nPk);",
          "596:       sqlite3VdbeAddOp4Int(v, OP_IdxInsert, iEph, regKey, iPk, nPk);",
          "601:     if( eOnePass!=ONEPASS_MULTI ){",
          "",
          "[Added Lines]",
          "644:   if( nChangeFrom==0 && HasRowid(pTab) ){",
          "647:     assert( pPk!=0 || HasRowid(pTab) );",
          "648:     nPk = pPk ? pPk->nKeyCol : 0;",
          "651:     pParse->nMem += nChangeFrom;",
          "654:       int nEphCol = nPk + nChangeFrom + (isView ? pTab->nCol : 0);",
          "656:       if( pPk ) sqlite3VdbeAddOp3(v, OP_Null, 0, iPk, iPk+nPk-1);",
          "657:       addrOpen = sqlite3VdbeAddOp2(v, OP_OpenEphemeral, iEph, nEphCol);",
          "658:       if( pPk ){",
          "659:         KeyInfo *pKeyInfo = sqlite3KeyInfoOfIndex(pParse, pPk);",
          "660:         if( pKeyInfo ){",
          "661:           pKeyInfo->nAllField = nEphCol;",
          "662:           sqlite3VdbeAppendP4(v, pKeyInfo, P4_KEYINFO);",
          "663:         }",
          "664:       }",
          "665:       if( nChangeFrom ){",
          "666:         updateFromSelect(",
          "667:             pParse, iEph, pPk, pChanges, pTabList, pWhere, pOrderBy, pLimit",
          "668:         );",
          "669: #ifndef SQLITE_OMIT_SUBQUERY",
          "670:         if( isView ) iDataCur = iEph;",
          "671: #endif",
          "672:       }",
          "676:   if( nChangeFrom ){",
          "677:     sqlite3MultiWrite(pParse);",
          "678:     eOnePass = ONEPASS_OFF;",
          "679:     nKey = nPk;",
          "680:     regKey = iPk;",
          "682:     if( pUpsert ){",
          "688:       pWInfo = 0;",
          "689:       eOnePass = ONEPASS_SINGLE;",
          "690:       sqlite3ExprIfFalse(pParse, pWhere, labelBreak, SQLITE_JUMPIFNULL);",
          "691:       bFinishSeek = 0;",
          "692:     }else{",
          "700:       flags = WHERE_ONEPASS_DESIRED|WHERE_SEEK_UNIQ_TABLE;",
          "701:       if( !pParse->nested && !pTrigger && !hasFK && !chngKey && !bReplace ){",
          "702:         flags |= WHERE_ONEPASS_MULTIROW;",
          "703:       }",
          "704:       pWInfo = sqlite3WhereBegin(pParse, pTabList, pWhere, 0, 0, flags,iIdxCur);",
          "705:       if( pWInfo==0 ) goto update_cleanup;",
          "717:       eOnePass = sqlite3WhereOkOnePass(pWInfo, aiCurOnePass);",
          "718:       bFinishSeek = sqlite3WhereUsesDeferredSeek(pWInfo);",
          "719:       if( eOnePass!=ONEPASS_SINGLE ){",
          "720:         sqlite3MultiWrite(pParse);",
          "721:         if( eOnePass==ONEPASS_MULTI ){",
          "722:           int iCur = aiCurOnePass[1];",
          "723:           if( iCur>=0 && iCur!=iDataCur && aToOpen[iCur-iBaseCur] ){",
          "724:             eOnePass = ONEPASS_OFF;",
          "725:           }",
          "726:           assert( iCur!=iDataCur || !HasRowid(pTab) );",
          "731:     if( HasRowid(pTab) ){",
          "735:       sqlite3VdbeAddOp2(v, OP_Rowid, iDataCur, regOldRowid);",
          "736:       if( eOnePass==ONEPASS_OFF ){",
          "738:         aRegIdx[nAllIdx] = ++pParse->nMem;",
          "739:         sqlite3VdbeAddOp2(v, OP_RowSetAdd, regRowSet, regOldRowid);",
          "740:       }",
          "747:       for(i=0; i<nPk; i++){",
          "748:         assert( pPk->aiColumn[i]>=0 );",
          "749:         sqlite3ExprCodeGetColumnOfTable(v, pTab, iDataCur,",
          "750:                                         pPk->aiColumn[i], iPk+i);",
          "751:       }",
          "752:       if( eOnePass ){",
          "753:         if( addrOpen ) sqlite3VdbeChangeToNoop(v, addrOpen);",
          "754:         nKey = nPk;",
          "755:         regKey = iPk;",
          "756:       }else{",
          "757:         sqlite3VdbeAddOp4(v, OP_MakeRecord, iPk, nPk, regKey,",
          "758:                           sqlite3IndexAffinityStr(db, pPk), nPk);",
          "759:         sqlite3VdbeAddOp4Int(v, OP_IdxInsert, iEph, regKey, iPk, nPk);",
          "760:       }",
          "765:     if( nChangeFrom==0 && eOnePass!=ONEPASS_MULTI ){",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "634:       sqlite3VdbeAddOp2(v, OP_IsNull, pPk ? regKey : regOldRowid, labelBreak);",
          "635:       VdbeCoverageIf(v, pPk==0);",
          "636:       VdbeCoverageIf(v, pPk!=0);",
          "638:       labelContinue = sqlite3VdbeMakeLabel(pParse);",
          "639:       sqlite3VdbeAddOp2(v, OP_Rewind, iEph, labelBreak); VdbeCoverage(v);",
          "643:     }else{",
          "644:       labelContinue = sqlite3VdbeAddOp3(v, OP_RowSetRead, regRowSet,labelBreak,",
          "645:                                regOldRowid);",
          "",
          "[Removed Lines]",
          "637:     }else if( pPk ){",
          "640:       addrTop = sqlite3VdbeAddOp2(v, OP_RowData, iEph, regKey);",
          "641:       sqlite3VdbeAddOp4Int(v, OP_NotFound, iDataCur, labelContinue, regKey, 0);",
          "642:       VdbeCoverage(v);",
          "",
          "[Added Lines]",
          "801:     }else if( pPk || nChangeFrom ){",
          "804:       addrTop = sqlite3VdbeCurrentAddr(v);",
          "805:       if( nChangeFrom ){",
          "806:         if( !isView ){",
          "807:           if( pPk ){",
          "808:             for(i=0; i<nPk; i++){",
          "809:               sqlite3VdbeAddOp3(v, OP_Column, iEph, i, iPk+i);",
          "810:             }",
          "811:             sqlite3VdbeAddOp4Int(",
          "812:                 v, OP_NotFound, iDataCur, labelContinue, iPk, nPk",
          "813:             );",
          "814:           }else{",
          "815:             sqlite3VdbeAddOp2(v, OP_Rowid, iEph, regOldRowid);",
          "816:             sqlite3VdbeAddOp3(",
          "817:                 v, OP_NotExists, iDataCur, labelContinue, regOldRowid",
          "818:             );",
          "819:           }",
          "820:         }",
          "821:         VdbeCoverage(v);",
          "822:       }else{",
          "823:         sqlite3VdbeAddOp2(v, OP_RowData, iEph, regKey);",
          "824:         sqlite3VdbeAddOp4Int(v, OP_NotFound, iDataCur, labelContinue, regKey,0);",
          "825:         VdbeCoverage(v);",
          "826:       }",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "656:   assert( chngKey || pTrigger || hasFK || regOldRowid==regNewRowid );",
          "657:   if( chngRowid ){",
          "659:     sqlite3VdbeAddOp1(v, OP_MustBeInt, regNewRowid); VdbeCoverage(v);",
          "660:   }",
          "",
          "[Removed Lines]",
          "658:     sqlite3ExprCode(pParse, pRowidExpr, regNewRowid);",
          "",
          "[Added Lines]",
          "842:     assert( iRowidExpr>=0 );",
          "843:     if( nChangeFrom==0 ){",
          "844:       sqlite3ExprCode(pParse, pRowidExpr, regNewRowid);",
          "845:     }else{",
          "846:       sqlite3VdbeAddOp3(v, OP_Column, iEph, iRowidExpr, regNewRowid);",
          "847:     }",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "708:     }else{",
          "709:       j = aXRef[i];",
          "710:       if( j>=0 ){",
          "712:       }else if( 0==(tmask&TRIGGER_BEFORE) || i>31 || (newmask & MASKBIT32(i)) ){",
          "",
          "[Removed Lines]",
          "711:         sqlite3ExprCode(pParse, pChanges->a[j].pExpr, k);",
          "",
          "[Added Lines]",
          "900:         if( nChangeFrom ){",
          "901:           assert( eOnePass==ONEPASS_OFF );",
          "902:           int nOff = (isView ? pTab->nCol : nPk);",
          "903:           sqlite3VdbeAddOp3(v, OP_Column, iEph, nOff+j, k);",
          "904:         }else{",
          "905:           sqlite3ExprCode(pParse, pChanges->a[j].pExpr, k);",
          "906:         }",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "740:     sqlite3CodeRowTrigger(pParse, pTrigger, TK_UPDATE, pChanges,",
          "741:         TRIGGER_BEFORE, pTab, regOldRowid, onError, labelContinue);",
          "771:       }",
          "773: #ifndef SQLITE_OMIT_GENERATED_COLUMNS",
          "779: #endif",
          "780:   }",
          "782:   if( !isView ){",
          "",
          "[Removed Lines]",
          "749:     if( pPk ){",
          "750:       sqlite3VdbeAddOp4Int(v, OP_NotFound, iDataCur, labelContinue,regKey,nKey);",
          "751:       VdbeCoverage(v);",
          "752:     }else{",
          "753:       sqlite3VdbeAddOp3(v, OP_NotExists, iDataCur, labelContinue, regOldRowid);",
          "754:       VdbeCoverage(v);",
          "755:     }",
          "766:     for(i=0, k=regNew; i<pTab->nCol; i++, k++){",
          "767:       if( pTab->aCol[i].colFlags & COLFLAG_GENERATED ){",
          "768:         if( pTab->aCol[i].colFlags & COLFLAG_VIRTUAL ) k--;",
          "769:       }else if( aXRef[i]<0 && i!=pTab->iPKey ){",
          "770:         sqlite3ExprCodeGetColumnOfTable(v, pTab, iDataCur, i, k);",
          "772:     }",
          "774:     if( pTab->tabFlags & TF_HasGenerated ){",
          "775:       testcase( pTab->tabFlags & TF_HasVirtual );",
          "776:       testcase( pTab->tabFlags & TF_HasStored );",
          "777:       sqlite3ComputeGeneratedColumns(pParse, regNew, pTab);",
          "778:     }",
          "",
          "[Added Lines]",
          "938:     if( !isView ){",
          "945:       if( pPk ){",
          "946:         sqlite3VdbeAddOp4Int(v, OP_NotFound,iDataCur,labelContinue,regKey,nKey);",
          "947:         VdbeCoverage(v);",
          "948:       }else{",
          "949:         sqlite3VdbeAddOp3(v, OP_NotExists, iDataCur, labelContinue,regOldRowid);",
          "950:         VdbeCoverage(v);",
          "951:       }",
          "962:       for(i=0, k=regNew; i<pTab->nCol; i++, k++){",
          "963:         if( pTab->aCol[i].colFlags & COLFLAG_GENERATED ){",
          "964:           if( pTab->aCol[i].colFlags & COLFLAG_VIRTUAL ) k--;",
          "965:         }else if( aXRef[i]<0 && i!=pTab->iPKey ){",
          "966:           sqlite3ExprCodeGetColumnOfTable(v, pTab, iDataCur, i, k);",
          "967:         }",
          "970:       if( pTab->tabFlags & TF_HasGenerated ){",
          "971:         testcase( pTab->tabFlags & TF_HasVirtual );",
          "972:         testcase( pTab->tabFlags & TF_HasStored );",
          "973:         sqlite3ComputeGeneratedColumns(pParse, regNew, pTab);",
          "974:       }",
          "976:     }",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "879:   }else if( eOnePass==ONEPASS_MULTI ){",
          "880:     sqlite3VdbeResolveLabel(v, labelContinue);",
          "881:     sqlite3WhereEnd(pWInfo);",
          "883:     sqlite3VdbeResolveLabel(v, labelContinue);",
          "884:     sqlite3VdbeAddOp2(v, OP_Next, iEph, addrTop); VdbeCoverage(v);",
          "885:   }else{",
          "",
          "[Removed Lines]",
          "882:   }else if( pPk ){",
          "",
          "[Added Lines]",
          "1079:   }else if( pPk || nChangeFrom ){",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "982:   addr= sqlite3VdbeAddOp2(v, OP_OpenEphemeral, ephemTab, nArg);",
          "983:   regArg = pParse->nMem + 1;",
          "984:   pParse->nMem += nArg;",
          "1004:     if( pRowid ){",
          "1006:     }else{",
          "1008:     }",
          "1009:   }else{",
          "1035: #if defined(SQLITE_DEBUG) && !defined(SQLITE_ENABLE_NULL_TRIM)",
          "1039: #endif",
          "1042:   }",
          "1045:   if( eOnePass==ONEPASS_OFF ){",
          "1050:     addr = sqlite3VdbeAddOp1(v, OP_Rewind, ephemTab); VdbeCoverage(v);",
          "",
          "[Removed Lines]",
          "985:   regRec = ++pParse->nMem;",
          "986:   regRowid = ++pParse->nMem;",
          "989:   pWInfo = sqlite3WhereBegin(pParse, pSrc, pWhere, 0,0,WHERE_ONEPASS_DESIRED,0);",
          "990:   if( pWInfo==0 ) return;",
          "993:   for(i=0; i<pTab->nCol; i++){",
          "994:     assert( (pTab->aCol[i].colFlags & COLFLAG_GENERATED)==0 );",
          "995:     if( aXRef[i]>=0 ){",
          "996:       sqlite3ExprCode(pParse, pChanges->a[aXRef[i]].pExpr, regArg+2+i);",
          "997:     }else{",
          "998:       sqlite3VdbeAddOp3(v, OP_VColumn, iCsr, i, regArg+2+i);",
          "1000:     }",
          "1001:   }",
          "1002:   if( HasRowid(pTab) ){",
          "1003:     sqlite3VdbeAddOp2(v, OP_Rowid, iCsr, regArg);",
          "1005:       sqlite3ExprCode(pParse, pRowid, regArg+1);",
          "1007:       sqlite3VdbeAddOp2(v, OP_Rowid, iCsr, regArg+1);",
          "1012:     pPk = sqlite3PrimaryKeyIndex(pTab);",
          "1013:     assert( pPk!=0 );",
          "1014:     assert( pPk->nKeyCol==1 );",
          "1015:     iPk = pPk->aiColumn[0];",
          "1016:     sqlite3VdbeAddOp3(v, OP_VColumn, iCsr, iPk, regArg);",
          "1017:     sqlite3VdbeAddOp2(v, OP_SCopy, regArg+2+iPk, regArg+1);",
          "1018:   }",
          "1020:   eOnePass = sqlite3WhereOkOnePass(pWInfo, aDummy);",
          "1023:   assert( eOnePass==ONEPASS_OFF || eOnePass==ONEPASS_SINGLE );",
          "1025:   if( eOnePass ){",
          "1028:     sqlite3VdbeChangeToNoop(v, addr);",
          "1029:     sqlite3VdbeAddOp1(v, OP_Close, iCsr);",
          "1030:   }else{",
          "1033:     sqlite3MultiWrite(pParse);",
          "1034:     sqlite3VdbeAddOp3(v, OP_MakeRecord, regArg, nArg, regRec);",
          "1038:     sqlite3VdbeChangeP5(v, OPFLAG_NOCHNG_MAGIC);",
          "1040:     sqlite3VdbeAddOp2(v, OP_NewRowid, ephemTab, regRowid);",
          "1041:     sqlite3VdbeAddOp3(v, OP_Insert, ephemTab, regRec, regRowid);",
          "1047:     sqlite3WhereEnd(pWInfo);",
          "",
          "[Added Lines]",
          "1182:   if( pSrc->nSrc>1 ){",
          "1183:     Expr *pRow;",
          "1184:     ExprList *pList;",
          "1186:       pRow = sqlite3ExprDup(db, pRowid, 0);",
          "1188:       pRow = sqlite3PExpr(pParse, TK_ROW, 0, 0);",
          "1190:     pList = sqlite3ExprListAppend(pParse, 0, pRow);",
          "1192:     for(i=0; i<pTab->nCol; i++){",
          "1193:       if( aXRef[i]>=0 ){",
          "1194:         pList = sqlite3ExprListAppend(pParse, pList,",
          "1195:           sqlite3ExprDup(db, pChanges->a[aXRef[i]].pExpr, 0)",
          "1196:         );",
          "1197:       }else{",
          "1198:         pList = sqlite3ExprListAppend(pParse, pList, exprRowColumn(pParse, i));",
          "1199:       }",
          "1200:     }",
          "1202:     updateFromSelect(pParse, ephemTab, 0, pList, pSrc, pWhere, 0, 0);",
          "1203:     sqlite3ExprListDelete(db, pList);",
          "1204:     eOnePass = ONEPASS_OFF;",
          "1206:     regRec = ++pParse->nMem;",
          "1207:     regRowid = ++pParse->nMem;",
          "1210:     pWInfo = sqlite3WhereBegin(pParse, pSrc,pWhere,0,0,WHERE_ONEPASS_DESIRED,0);",
          "1211:     if( pWInfo==0 ) return;",
          "1214:     for(i=0; i<pTab->nCol; i++){",
          "1215:       assert( (pTab->aCol[i].colFlags & COLFLAG_GENERATED)==0 );",
          "1216:       if( aXRef[i]>=0 ){",
          "1217:         sqlite3ExprCode(pParse, pChanges->a[aXRef[i]].pExpr, regArg+2+i);",
          "1218:       }else{",
          "1219:         sqlite3VdbeAddOp3(v, OP_VColumn, iCsr, i, regArg+2+i);",
          "1221:       }",
          "1222:     }",
          "1223:     if( HasRowid(pTab) ){",
          "1224:       sqlite3VdbeAddOp2(v, OP_Rowid, iCsr, regArg);",
          "1225:       if( pRowid ){",
          "1226:         sqlite3ExprCode(pParse, pRowid, regArg+1);",
          "1227:       }else{",
          "1228:         sqlite3VdbeAddOp2(v, OP_Rowid, iCsr, regArg+1);",
          "1229:       }",
          "1230:     }else{",
          "1233:       pPk = sqlite3PrimaryKeyIndex(pTab);",
          "1234:       assert( pPk!=0 );",
          "1235:       assert( pPk->nKeyCol==1 );",
          "1236:       iPk = pPk->aiColumn[0];",
          "1237:       sqlite3VdbeAddOp3(v, OP_VColumn, iCsr, iPk, regArg);",
          "1238:       sqlite3VdbeAddOp2(v, OP_SCopy, regArg+2+iPk, regArg+1);",
          "1239:     }",
          "1241:     eOnePass = sqlite3WhereOkOnePass(pWInfo, aDummy);",
          "1244:     assert( eOnePass==ONEPASS_OFF || eOnePass==ONEPASS_SINGLE );",
          "1246:     if( eOnePass ){",
          "1249:       sqlite3VdbeChangeToNoop(v, addr);",
          "1250:       sqlite3VdbeAddOp1(v, OP_Close, iCsr);",
          "1251:     }else{",
          "1254:       sqlite3MultiWrite(pParse);",
          "1255:       sqlite3VdbeAddOp3(v, OP_MakeRecord, regArg, nArg, regRec);",
          "1259:       sqlite3VdbeChangeP5(v, OPFLAG_NOCHNG_MAGIC);",
          "1261:       sqlite3VdbeAddOp2(v, OP_NewRowid, ephemTab, regRowid);",
          "1262:       sqlite3VdbeAddOp3(v, OP_Insert, ephemTab, regRec, regRowid);",
          "1263:     }",
          "1269:     if( pSrc->nSrc==1 ){",
          "1270:       sqlite3WhereEnd(pWInfo);",
          "1271:     }",
          "",
          "---------------"
        ],
        "test/altertab3.test||test/altertab3.test": [
          "File: test/altertab3.test -> test/altertab3.test",
          "--- Hunk 1 ---",
          "[Context before]",
          "586:     DELETE FROM v2;",
          "587:   END}}",
          "589: finish_test",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "589: #------------------------------------------------------------------------",
          "590: #",
          "591: reset_db",
          "592: do_execsql_test 25.1 {",
          "593:   CREATE TABLE t1(a, b, c);",
          "594:   CREATE TABLE t2(a, b, c);",
          "595:   CREATE TRIGGER ttt AFTER INSERT ON t1 BEGIN",
          "596:     UPDATE t1 SET a=t2.a FROM t2 WHERE t1.a=t2.a;",
          "597:   END;",
          "598: }",
          "599: #do_execsql_test 25.2 {",
          "600: #  ALTER TABLE t2 RENAME COLUMN a TO aaa;",
          "601: #}",
          "",
          "---------------"
        ],
        "test/fts4upfrom.test||test/fts4upfrom.test": [
          "File: test/fts4upfrom.test -> test/fts4upfrom.test",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: # 2020 February 24",
          "2: #",
          "3: # The author disclaims copyright to this source code.  In place of",
          "4: # a legal notice, here is a blessing:",
          "5: #",
          "6: #    May you do good and not evil.",
          "7: #    May you find forgiveness for yourself and forgive others.",
          "8: #    May you share freely, never taking more than you give.",
          "9: #",
          "10: #*************************************************************************",
          "11: # This file implements regression tests for SQLite library.  The",
          "12: # focus of this script is testing UPDATE statements with FROM clauses",
          "13: # against FTS4 tables.",
          "14: #",
          "15: #",
          "17: set testdir [file dirname $argv0]",
          "18: source $testdir/tester.tcl",
          "19: set testprefix fts4upfrom",
          "21: # If SQLITE_ENABLE_FTS3 is defined, omit this file.",
          "22: ifcapable !fts3 {",
          "23:   finish_test",
          "24:   return",
          "25: }",
          "27: foreach {tn create_table} {",
          "28:   0 { CREATE VIRTUAL TABLE ft USING fts5(a, b, c) }",
          "29:   1 { CREATE VIRTUAL TABLE ft USING fts3(a, b, c) }",
          "30:   2 { CREATE TABLE ft(a, b, c) }",
          "31:   3 {",
          "32:     CREATE TABLE real(a, b, c);",
          "33:     CREATE INDEX i1 ON real(a);",
          "34:     CREATE VIEW ft AS SELECT rowid, a, b, c FROM real;",
          "35:     CREATE TRIGGER tr1 INSTEAD OF INSERT ON ft BEGIN",
          "36:       INSERT INTO real(rowid, a, b, c) VALUES(new.rowid, new.a, new.b, new.c);",
          "37:     END;",
          "38:     CREATE TRIGGER tr2 INSTEAD OF UPDATE ON ft BEGIN",
          "39:       UPDATE real SET rowid=new.rowid, a=new.a, b=new.b, c=new.c",
          "40:       WHERE rowid=old.rowid;",
          "41:     END;",
          "42:   }",
          "43: } {",
          "44:   if {$tn==0} { ifcapable !fts5 { continue } }",
          "45:   catchsql { DROP VIEW IF EXISTS changes }",
          "46:   catchsql { DROP TABLE IF EXISTS ft }",
          "47:   catchsql { DROP VIEW IF EXISTS ft }",
          "48:   execsql $create_table",
          "50:   do_execsql_test 1.$tn.0 {",
          "51:     INSERT INTO ft(a, b, c) VALUES('a', NULL, 'apple');",
          "52:     INSERT INTO ft(a, b, c) VALUES('b', NULL, 'banana');",
          "53:     INSERT INTO ft(a, b, c) VALUES('c', NULL, 'cherry');",
          "54:     INSERT INTO ft(a, b, c) VALUES('d', NULL, 'damson plum');",
          "55:   }",
          "57:   do_execsql_test 1.$tn.1 {",
          "58:     SELECT a, b, c FROM ft ORDER BY rowid;",
          "59:   } {",
          "60:     a {} apple",
          "61:     b {} banana",
          "62:     c {} cherry",
          "63:     d {} {damson plum}",
          "64:   }",
          "66:   do_execsql_test 1.$tn.2 {",
          "67:     UPDATE ft SET b=o.c FROM ft AS o WHERE (ft.a == char(unicode(o.a)+1))",
          "68:   }",
          "70:   do_execsql_test 1.$tn.3 {",
          "71:     SELECT a, b, c FROM ft ORDER BY rowid;",
          "72:   } {",
          "73:     a {} apple",
          "74:     b apple banana",
          "75:     c banana cherry",
          "76:     d cherry {damson plum}",
          "77:   }",
          "79:   do_catchsql_test 1.$tn.4 {",
          "80:     UPDATE ft SET c=v FROM changes WHERE a=k;",
          "81:   } {1 {no such table: changes}}",
          "83:   do_execsql_test 1.$tn.5 {",
          "84:     create view changes(k, v) AS",
          "85:       VALUES( 'd', 'dewberry' ) UNION ALL",
          "86:       VALUES( 'c', 'clementine' ) UNION ALL",
          "87:       VALUES( 'b', 'blueberry' ) UNION ALL",
          "88:       VALUES( 'a', 'apricot' )",
          "89:     ;",
          "90:   }",
          "92:   do_execsql_test 1.$tn.6 {",
          "93:     UPDATE ft SET c=v FROM changes WHERE a=k;",
          "94:   }",
          "96:   do_execsql_test 1.$tn.7 {",
          "97:     SELECT rowid, a, b, c FROM ft ORDER BY rowid;",
          "98:   } {",
          "99:     1 a {} apricot",
          "100:     2 b apple blueberry",
          "101:     3 c banana clementine",
          "102:     4 d cherry dewberry",
          "103:   }",
          "105:   do_execsql_test 1.$tn.8 \"",
          "106:     WITH x1(o, n) AS (",
          "107:         VALUES(1, 11) UNION ALL",
          "108:         VALUES(2, 12) UNION ALL",
          "109:         VALUES(3, 13) UNION ALL",
          "110:         VALUES(4, 14)",
          "111:     )",
          "112:     SELECT ft.rowid, a, b, c, o, n FROM ft, x1 WHERE ft.rowid = o;",
          "113:   \" {",
          "114:     1 a {} apricot 1 11",
          "115:     2 b apple blueberry 2 12",
          "116:     3 c banana clementine 3 13",
          "117:     4 d cherry dewberry 4 14",
          "118:   }",
          "120:   set ROWID rowid",
          "121:   if {$tn==1} { set ROWID docid }",
          "122:   do_execsql_test 1.$tn.9 \"",
          "123:     WITH x1(o, n) AS (",
          "124:         VALUES(1, 11) UNION ALL",
          "125:         VALUES(2, 12) UNION ALL",
          "126:         VALUES(3, 13) UNION ALL",
          "127:         VALUES(4, 14)",
          "128:     )",
          "129:     UPDATE ft SET $ROWID = n FROM x1 WHERE ft.rowid = o;",
          "130:     SELECT rowid, a, b, c FROM ft ORDER BY rowid;",
          "131:   \" {",
          "132:     11 a {} apricot",
          "133:     12 b apple blueberry",
          "134:     13 c banana clementine",
          "135:     14 d cherry dewberry",
          "136:   }",
          "137: }",
          "139: finish_test",
          "",
          "---------------"
        ],
        "test/pg_common.tcl||test/pg_common.tcl": [
          "File: test/pg_common.tcl -> test/pg_common.tcl",
          "--- Hunk 1 ---",
          "[Context before]",
          "19: proc execsql {sql} {",
          "21:   set lSql [list]",
          "22:   set frag \"\"",
          "23:   while {[string length $sql]>0} {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "21:   set sql [string map {{WITHOUT ROWID} {}} $sql]",
          "",
          "---------------"
        ],
        "test/triggerupfrom.test||test/triggerupfrom.test": [
          "File: test/triggerupfrom.test -> test/triggerupfrom.test",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: # 2020 July 14",
          "2: #",
          "3: # The author disclaims copyright to this source code.  In place of",
          "4: # a legal notice, here is a blessing:",
          "5: #",
          "6: #    May you do good and not evil.",
          "7: #    May you find forgiveness for yourself and forgive others.",
          "8: #    May you share freely, never taking more than you give.",
          "9: #",
          "10: #***********************************************************************",
          "11: #",
          "13: set testdir [file dirname $argv0]",
          "14: source $testdir/tester.tcl",
          "15: set testprefix triggerupfrom",
          "17: do_execsql_test 1.0 {",
          "18:   CREATE TABLE map(k, v);",
          "19:   INSERT INTO map VALUES(1, 'one'), (2, 'two'), (3, 'three'), (4, 'four');",
          "21:   CREATE TABLE t1(a INTEGER PRIMARY KEY, b, c);",
          "23:   CREATE TRIGGER tr AFTER INSERT ON t1 BEGIN",
          "24:     UPDATE t1 SET c = v FROM map WHERE k=new.a AND a=new.a;",
          "25:   END;",
          "26: }",
          "28: do_execsql_test 1.1 {",
          "29:   INSERT INTO t1(a) VALUES(1);",
          "30: }",
          "32: do_execsql_test 1.2 {",
          "33:   SELECT a, c FROM t1 ORDER BY a;",
          "34: } {1 one}",
          "36: do_execsql_test 1.3 {",
          "37:   INSERT INTO t1(a) VALUES(2), (3), (4), (5);",
          "38:   SELECT a, c FROM t1 ORDER BY a;",
          "39: } {1 one 2 two 3 three 4 four 5 {}}",
          "41: forcedelete test.db2",
          "42: do_execsql_test 2.0 {",
          "43:   ATTACH 'test.db2' AS aux;",
          "44:   CREATE TABLE aux.t3(x, y);",
          "45:   INSERT INTO aux.t3 VALUES('x', 'y');",
          "46: }",
          "48: do_catchsql_test 2.1 {",
          "49:   CREATE TRIGGER tr2 AFTER INSERT ON t1 BEGIN",
          "50:     UPDATE t1 SET b = y FROM aux.t3 WHERE k=new.a;",
          "51:   END;",
          "52: } {1 {trigger tr2 cannot reference objects in database aux}}",
          "54: do_execsql_test 2.2 {",
          "55:   CREATE TEMP TRIGGER tr2 AFTER INSERT ON t1 BEGIN",
          "56:     UPDATE t1 SET b = y FROM aux.t3 WHERE a=new.a;",
          "57:   END;",
          "58:   INSERT INTO t1(a) VALUES(10), (20);",
          "59:   SELECT * FROM t1;",
          "60: } {",
          "61:   1 {} one",
          "62:   2 {} two",
          "63:   3 {} three",
          "64:   4 {} four",
          "65:   5 {} {}",
          "66:   10 y {}",
          "67:   20 y {}",
          "68: }",
          "70: do_execsql_test 2.3 {",
          "71:   CREATE TABLE link(f, t);",
          "72:   INSERT INTO link VALUES(5, 2), (20, 10), (2, 1);",
          "73:   CREATE TRIGGER tr3 BEFORE DELETE ON t1 BEGIN",
          "74:     UPDATE t1 SET b=coalesce(old.b,old.c) FROM main.link WHERE a=t AND old.a=f;",
          "75:   END;",
          "76:   DELETE FROM t1 WHERE a=2;",
          "77:   SELECT * FROM t1;",
          "78: } {",
          "79:   1 two one",
          "80:   3 {} three",
          "81:   4 {} four",
          "82:   5 {} {}",
          "83:   10 y {}",
          "84:   20 y {}",
          "85: }",
          "87: db close",
          "88: sqlite3 db \"\"",
          "89: do_catchsql_test 2.4 {",
          "90:   ATTACH 'test.db' AS yyy;",
          "91:   SELECT * FROM t1;",
          "92: } {1 {malformed database schema (tr3) - trigger tr3 cannot reference objects in database main}}",
          "94: #-------------------------------------------------------------------------",
          "95: reset_db",
          "96: forcedelete test.db2",
          "97: do_execsql_test 3.0 {",
          "98:   CREATE TABLE mmm(x, y);",
          "99:   INSERT INTO mmm VALUES(1, 'one');",
          "100:   INSERT INTO mmm VALUES(2, 'two');",
          "101:   INSERT INTO mmm VALUES(3, 'three');",
          "103:   ATTACH 'test.db2' AS aux;",
          "104:   CREATE TABLE aux.t1(a, b);",
          "105:   CREATE TABLE aux.mmm(x, y);",
          "106:   INSERT INTO aux.mmm VALUES(1, 'ONE');",
          "107:   INSERT INTO aux.mmm VALUES(2, 'TWO');",
          "108:   INSERT INTO aux.mmm VALUES(3, 'THREE');",
          "110:   CREATE TRIGGER aux.ttt AFTER INSERT ON t1 BEGIN",
          "111:     UPDATE t1 SET b=y FROM mmm WHERE x=new.a AND a=new.a;",
          "112:   END;",
          "114:   INSERT INTO t1(a) VALUES (2);",
          "115:   SELECT * FROM t1;",
          "116: } {2 TWO}",
          "118: #-------------------------------------------------------------------------",
          "119: # Test that INSTEAD OF UPDATE triggers on views work with UPDATE...FROM",
          "120: # statements. Including, if the library is built with ENABLE_HIDDEN_COLUMNS,",
          "121: # that they work correctly on views with hidden columns.",
          "122: #",
          "123: reset_db",
          "124: do_execsql_test 4.0 {",
          "125:   CREATE TABLE t1(k, a, b);",
          "126:   INSERT INTO t1 VALUES('a', 1, 'one');",
          "127:   INSERT INTO t1 VALUES('b', 2, 'two');",
          "128:   INSERT INTO t1 VALUES('c', 3, 'three');",
          "129:   INSERT INTO t1 VALUES('d', 4, 'four');",
          "131:   CREATE TABLE log(x);",
          "132:   CREATE VIEW v1 AS SELECT k, a, b AS __hidden__b FROM t1;",
          "133:   CREATE TRIGGER tr1 INSTEAD OF UPDATE ON v1 BEGIN",
          "134:     INSERT INTO log VALUES(",
          "135:       '('||old.a||','||old.__hidden__b||')->('||new.a||','||new.__hidden__b||')'",
          "136:     );",
          "137:   END;",
          "138: }",
          "140: ifcapable hiddencolumns {",
          "141:   do_execsql_test 4.1-hc-enabled {",
          "142:     SELECT * FROM v1",
          "143:   } {a 1 b 2 c 3 d 4}",
          "144: } else {",
          "145:   do_execsql_test 4.1-hc-disabled {",
          "146:     SELECT * FROM v1",
          "147:   } {a 1 one b 2 two c 3 three d 4 four}",
          "148: }",
          "150: do_execsql_test 4.2 {",
          "151:   UPDATE v1 SET a='xyz' WHERE k IN ('a', 'c');",
          "152:   SELECT * FROM log;",
          "153:   DELETE FROM log;",
          "154: } {",
          "155:   (1,one)->(xyz,one)",
          "156:   (3,three)->(xyz,three)",
          "157: }",
          "159: do_execsql_test 4.3 {",
          "160:   CREATE TABLE map(k, v);",
          "161:   INSERT INTO map VALUES('b', 'twelve');",
          "162:   INSERT INTO map VALUES('d', 'fourteen');",
          "163:   UPDATE v1 SET a=map.v FROM map WHERE v1.k=map.k;",
          "164:   SELECT * FROM log;",
          "165:   DELETE FROM log;",
          "166: } {",
          "167:   (2,two)->(twelve,two)",
          "168:   (4,four)->(fourteen,four)",
          "169: }",
          "173: finish_test",
          "",
          "---------------"
        ],
        "test/upfrom1.tcl||test/upfrom1.tcl": [
          "File: test/upfrom1.tcl -> test/upfrom1.tcl",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: # 2020 April 22",
          "2: #",
          "3: # The author disclaims copyright to this source code.  In place of",
          "4: # a legal notice, here is a blessing:",
          "5: #",
          "6: #    May you do good and not evil.",
          "7: #    May you find forgiveness for yourself and forgive others.",
          "8: #    May you share freely, never taking more than you give.",
          "9: #",
          "10: #***********************************************************************",
          "11: #",
          "13: source [file join [file dirname $argv0] pg_common.tcl]",
          "15: #=========================================================================",
          "17: start_test upfrom1 \"2020 April 22\"",
          "19: foreach {tn wo} {",
          "20:   1 \"WITHOUT ROWID\"",
          "21:   2 \"\"",
          "22: } {",
          "23: eval [string map [list %TN% $tn %WITHOUT_ROWID% $wo] {",
          "24: execsql_test 1.%TN%.0 {",
          "25:   DROP TABLE IF EXISTS t2;",
          "26:   CREATE TABLE t2(a INTEGER PRIMARY KEY, b INTEGER, c INTEGER) %WITHOUT_ROWID%;",
          "27:   INSERT INTO t2 VALUES(1, 2, 3);",
          "28:   INSERT INTO t2 VALUES(4, 5, 6);",
          "29:   INSERT INTO t2 VALUES(7, 8, 9);",
          "31:   DROP TABLE IF EXISTS chng;",
          "32:   CREATE TABLE chng(a INTEGER, b INTEGER, c INTEGER);",
          "33:   INSERT INTO chng VALUES(1, 100, 1000);",
          "34:   INSERT INTO chng VALUES(7, 700, 7000);",
          "35: }",
          "37: execsql_test 1.%TN%.1 {",
          "38:   SELECT * FROM t2;",
          "39: }",
          "41: execsql_test 1.%TN%.2 {",
          "42:   UPDATE t2 SET b = chng.b, c = chng.c FROM chng WHERE chng.a = t2.a;",
          "43:   SELECT * FROM t2 ORDER BY a;",
          "44: }",
          "46: execsql_test 1.%TN%.3 {",
          "47:   DELETE FROM t2;",
          "48:   INSERT INTO t2 VALUES(1, 2, 3);",
          "49:   INSERT INTO t2 VALUES(4, 5, 6);",
          "50:   INSERT INTO t2 VALUES(7, 8, 9);",
          "51: }",
          "53: execsql_test 1.%TN%.4 {",
          "54:   UPDATE t2 SET (b, c) = (SELECT b, c FROM chng WHERE a=t2.a)",
          "55:     WHERE a IN (SELECT a FROM chng);",
          "56:   SELECT * FROM t2 ORDER BY a;",
          "57: }",
          "59: execsql_test 1.%TN%.5 {",
          "60:   DROP TABLE IF EXISTS t3;",
          "61:   CREATE TABLE t3(a INTEGER PRIMARY KEY, b INTEGER, c TEXT) %WITHOUT_ROWID%;",
          "62:   INSERT INTO t3 VALUES(1, 1, 'one');",
          "63:   INSERT INTO t3 VALUES(2, 2, 'two');",
          "64:   INSERT INTO t3 VALUES(3, 3, 'three');",
          "66:   DROP TABLE IF EXISTS t4;",
          "67:   CREATE TABLE t4(x TEXT);",
          "68:   INSERT INTO t4 VALUES('five');",
          "70:   SELECT * FROM t3 ORDER BY a;",
          "71: }",
          "73: execsql_test 1.%TN%.6 {",
          "74:   UPDATE t3 SET c=x FROM t4;",
          "75:   SELECT * FROM t3 ORDER BY a;",
          "76: }",
          "77: }]}",
          "79: execsql_test 2.1 {",
          "80:   DROP TABLE IF EXISTS t5;",
          "81:   DROP TABLE IF EXISTS m1;",
          "82:   DROP TABLE IF EXISTS m2;",
          "83:   CREATE TABLE t5(a INTEGER PRIMARY KEY, b TEXT, c TEXT);",
          "84:   CREATE TABLE m1(x INTEGER PRIMARY KEY, y TEXT);",
          "85:   CREATE TABLE m2(u INTEGER PRIMARY KEY, v TEXT);",
          "87:   INSERT INTO t5 VALUES(1, 'one', 'ONE');",
          "88:   INSERT INTO t5 VALUES(2, 'two', 'TWO');",
          "89:   INSERT INTO t5 VALUES(3, 'three', 'THREE');",
          "90:   INSERT INTO t5 VALUES(4, 'four', 'FOUR');",
          "92:   INSERT INTO m1 VALUES(1, 'i');",
          "93:   INSERT INTO m1 VALUES(2, 'ii');",
          "94:   INSERT INTO m1 VALUES(3, 'iii');",
          "96:   INSERT INTO m2 VALUES(1, 'I');",
          "97:   INSERT INTO m2 VALUES(3, 'II');",
          "98:   INSERT INTO m2 VALUES(4, 'III');",
          "99: }",
          "101: execsql_test 2.2 {",
          "102:   UPDATE t5 SET b=y, c=v FROM m1 LEFT JOIN m2 ON (x=u) WHERE x=a;",
          "103:   SELECT * FROM t5 ORDER BY a;",
          "104: }",
          "107: finish_test",
          "",
          "---------------"
        ],
        "test/upfrom1.test||test/upfrom1.test": [
          "File: test/upfrom1.test -> test/upfrom1.test",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: # 2020 April 22",
          "2: #",
          "3: # The author disclaims copyright to this source code.  In place of",
          "4: # a legal notice, here is a blessing:",
          "5: #",
          "6: #    May you do good and not evil.",
          "7: #    May you find forgiveness for yourself and forgive others.",
          "8: #    May you share freely, never taking more than you give.",
          "9: #",
          "10: #***********************************************************************",
          "11: # This file implements regression tests for SQLite library.",
          "12: #",
          "14: ####################################################",
          "15: # DO NOT EDIT! THIS FILE IS AUTOMATICALLY GENERATED!",
          "16: ####################################################",
          "18: set testdir [file dirname $argv0]",
          "19: source $testdir/tester.tcl",
          "20: set testprefix upfrom1",
          "22: do_execsql_test 1.1.0 {",
          "23:   DROP TABLE IF EXISTS t2;",
          "24:   CREATE TABLE t2(a INTEGER PRIMARY KEY, b INTEGER, c INTEGER) WITHOUT ROWID;",
          "25:   INSERT INTO t2 VALUES(1, 2, 3);",
          "26:   INSERT INTO t2 VALUES(4, 5, 6);",
          "27:   INSERT INTO t2 VALUES(7, 8, 9);",
          "29:   DROP TABLE IF EXISTS chng;",
          "30:   CREATE TABLE chng(a INTEGER, b INTEGER, c INTEGER);",
          "31:   INSERT INTO chng VALUES(1, 100, 1000);",
          "32:   INSERT INTO chng VALUES(7, 700, 7000);",
          "33: } {}",
          "35: do_execsql_test 1.1.1 {",
          "36:   SELECT * FROM t2;",
          "37: } {1 2 3   4 5 6   7 8 9}",
          "39: do_execsql_test 1.1.2 {",
          "40:   UPDATE t2 SET b = chng.b, c = chng.c FROM chng WHERE chng.a = t2.a;",
          "41:   SELECT * FROM t2 ORDER BY a;",
          "42: } {1 100 1000   4 5 6   7 700 7000}",
          "44: do_execsql_test 1.1.3 {",
          "45:   DELETE FROM t2;",
          "46:   INSERT INTO t2 VALUES(1, 2, 3);",
          "47:   INSERT INTO t2 VALUES(4, 5, 6);",
          "48:   INSERT INTO t2 VALUES(7, 8, 9);",
          "49: } {}",
          "51: do_execsql_test 1.1.4 {",
          "52:   UPDATE t2 SET (b, c) = (SELECT b, c FROM chng WHERE a=t2.a)",
          "53:     WHERE a IN (SELECT a FROM chng);",
          "54:   SELECT * FROM t2 ORDER BY a;",
          "55: } {1 100 1000   4 5 6   7 700 7000}",
          "57: do_execsql_test 1.1.5 {",
          "58:   DROP TABLE IF EXISTS t3;",
          "59:   CREATE TABLE t3(a INTEGER PRIMARY KEY, b INTEGER, c TEXT) WITHOUT ROWID;",
          "60:   INSERT INTO t3 VALUES(1, 1, 'one');",
          "61:   INSERT INTO t3 VALUES(2, 2, 'two');",
          "62:   INSERT INTO t3 VALUES(3, 3, 'three');",
          "64:   DROP TABLE IF EXISTS t4;",
          "65:   CREATE TABLE t4(x TEXT);",
          "66:   INSERT INTO t4 VALUES('five');",
          "68:   SELECT * FROM t3 ORDER BY a;",
          "69: } {1 1 one   2 2 two   3 3 three}",
          "71: do_execsql_test 1.1.6 {",
          "72:   UPDATE t3 SET c=x FROM t4;",
          "73:   SELECT * FROM t3 ORDER BY a;",
          "74: } {1 1 five   2 2 five   3 3 five}",
          "76: do_execsql_test 1.2.0 {",
          "77:   DROP TABLE IF EXISTS t2;",
          "78:   CREATE TABLE t2(a INTEGER PRIMARY KEY, b INTEGER, c INTEGER) ;",
          "79:   INSERT INTO t2 VALUES(1, 2, 3);",
          "80:   INSERT INTO t2 VALUES(4, 5, 6);",
          "81:   INSERT INTO t2 VALUES(7, 8, 9);",
          "83:   DROP TABLE IF EXISTS chng;",
          "84:   CREATE TABLE chng(a INTEGER, b INTEGER, c INTEGER);",
          "85:   INSERT INTO chng VALUES(1, 100, 1000);",
          "86:   INSERT INTO chng VALUES(7, 700, 7000);",
          "87: } {}",
          "89: do_execsql_test 1.2.1 {",
          "90:   SELECT * FROM t2;",
          "91: } {1 2 3   4 5 6   7 8 9}",
          "93: do_execsql_test 1.2.2 {",
          "94:   UPDATE t2 SET b = chng.b, c = chng.c FROM chng WHERE chng.a = t2.a;",
          "95:   SELECT * FROM t2 ORDER BY a;",
          "96: } {1 100 1000   4 5 6   7 700 7000}",
          "98: do_execsql_test 1.2.3 {",
          "99:   DELETE FROM t2;",
          "100:   INSERT INTO t2 VALUES(1, 2, 3);",
          "101:   INSERT INTO t2 VALUES(4, 5, 6);",
          "102:   INSERT INTO t2 VALUES(7, 8, 9);",
          "103: } {}",
          "105: do_execsql_test 1.2.4 {",
          "106:   UPDATE t2 SET (b, c) = (SELECT b, c FROM chng WHERE a=t2.a)",
          "107:     WHERE a IN (SELECT a FROM chng);",
          "108:   SELECT * FROM t2 ORDER BY a;",
          "109: } {1 100 1000   4 5 6   7 700 7000}",
          "111: do_execsql_test 1.2.5 {",
          "112:   DROP TABLE IF EXISTS t3;",
          "113:   CREATE TABLE t3(a INTEGER PRIMARY KEY, b INTEGER, c TEXT) ;",
          "114:   INSERT INTO t3 VALUES(1, 1, 'one');",
          "115:   INSERT INTO t3 VALUES(2, 2, 'two');",
          "116:   INSERT INTO t3 VALUES(3, 3, 'three');",
          "118:   DROP TABLE IF EXISTS t4;",
          "119:   CREATE TABLE t4(x TEXT);",
          "120:   INSERT INTO t4 VALUES('five');",
          "122:   SELECT * FROM t3 ORDER BY a;",
          "123: } {1 1 one   2 2 two   3 3 three}",
          "125: do_execsql_test 1.2.6 {",
          "126:   UPDATE t3 SET c=x FROM t4;",
          "127:   SELECT * FROM t3 ORDER BY a;",
          "128: } {1 1 five   2 2 five   3 3 five}",
          "130: do_execsql_test 2.1 {",
          "131:   DROP TABLE IF EXISTS t5;",
          "132:   DROP TABLE IF EXISTS m1;",
          "133:   DROP TABLE IF EXISTS m2;",
          "134:   CREATE TABLE t5(a INTEGER PRIMARY KEY, b TEXT, c TEXT);",
          "135:   CREATE TABLE m1(x INTEGER PRIMARY KEY, y TEXT);",
          "136:   CREATE TABLE m2(u INTEGER PRIMARY KEY, v TEXT);",
          "138:   INSERT INTO t5 VALUES(1, 'one', 'ONE');",
          "139:   INSERT INTO t5 VALUES(2, 'two', 'TWO');",
          "140:   INSERT INTO t5 VALUES(3, 'three', 'THREE');",
          "141:   INSERT INTO t5 VALUES(4, 'four', 'FOUR');",
          "143:   INSERT INTO m1 VALUES(1, 'i');",
          "144:   INSERT INTO m1 VALUES(2, 'ii');",
          "145:   INSERT INTO m1 VALUES(3, 'iii');",
          "147:   INSERT INTO m2 VALUES(1, 'I');",
          "148:   INSERT INTO m2 VALUES(3, 'II');",
          "149:   INSERT INTO m2 VALUES(4, 'III');",
          "150: } {}",
          "152: do_execsql_test 2.2 {",
          "153:   UPDATE t5 SET b=y, c=v FROM m1 LEFT JOIN m2 ON (x=u) WHERE x=a;",
          "154:   SELECT * FROM t5 ORDER BY a;",
          "155: } {1 i I   2 ii {}   3 iii II   4 four FOUR}",
          "157: finish_test",
          "",
          "---------------"
        ],
        "test/upfrom2.test||test/upfrom2.test": [
          "File: test/upfrom2.test -> test/upfrom2.test",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: # 2020 April 29",
          "2: #",
          "3: # The author disclaims copyright to this source code.  In place of",
          "4: # a legal notice, here is a blessing:",
          "5: #",
          "6: #    May you do good and not evil.",
          "7: #    May you find forgiveness for yourself and forgive others.",
          "8: #    May you share freely, never taking more than you give.",
          "9: #",
          "10: #***********************************************************************",
          "11: #",
          "13: set testdir [file dirname $argv0]",
          "14: source $testdir/tester.tcl",
          "15: set testprefix upfrom2",
          "17: # Test cases:",
          "18: #",
          "19: #   1.*: Test that triggers are fired correctly for UPDATE FROM statements,",
          "20: #        and only once for each row. Except for INSTEAD OF triggers on",
          "21: #        views - these are fired once for each row returned by the join,",
          "22: #        including duplicates.",
          "23: #",
          "24: #   2.*: Test adding ORDER BY and LIMIT clauses with UPDATE FROM statements.",
          "25: #",
          "27: foreach {tn wo} {",
          "28:   1 \"\"",
          "29:   2 \"WITHOUT ROWID\"",
          "30: } {",
          "31:   reset_db",
          "33:   eval [string map [list %WO% $wo %TN% $tn] {",
          "34:   do_execsql_test 1.%TN%.0 {",
          "35:     CREATE TABLE log(t TEXT);",
          "36:     CREATE TABLE t1(x PRIMARY KEY, y, z UNIQUE) %WO%;",
          "37:     CREATE INDEX t1y ON t1(y);",
          "39:     INSERT INTO t1 VALUES(1, 'i',   'one');",
          "40:     INSERT INTO t1 VALUES(2, 'ii',  'two');",
          "41:     INSERT INTO t1 VALUES(3, 'iii', 'three');",
          "42:     INSERT INTO t1 VALUES(4, 'iv',  'four');",
          "44:     CREATE TRIGGER tr1 BEFORE UPDATE ON t1 BEGIN",
          "45:       INSERT INTO log VALUES(old.z || '->' || new.z);",
          "46:     END;",
          "47:     CREATE TRIGGER tr2 AFTER UPDATE ON t1 BEGIN",
          "48:       INSERT INTO log VALUES(old.y || '->' || new.y);",
          "49:     END;",
          "50:   }",
          "52:   do_execsql_test 1.%TN%.1 {",
          "53:     WITH data(k, v) AS (",
          "54:       VALUES(3, 'thirty'), (1, 'ten')",
          "55:     )",
          "56:     UPDATE t1 SET z=v FROM data WHERE x=k;",
          "58:     SELECT * FROM t1;",
          "59:     SELECT * FROM log;",
          "60:   } {",
          "61:     1 i ten   2 ii two   3 iii thirty   4 iv four",
          "62:     one->ten        i->i",
          "63:     three->thirty   iii->iii",
          "64:   }",
          "66:   do_execsql_test 1.%TN%.2 {",
          "67:     CREATE TABLE t2(a, b);",
          "68:     CREATE TABLE t3(k, v);",
          "70:     INSERT INTO t3 VALUES(5,   'v');",
          "71:     INSERT INTO t3 VALUES(12, 'xii');",
          "73:     INSERT INTO t2 VALUES(2, 12);",
          "74:     INSERT INTO t2 VALUES(3, 5);",
          "76:     DELETE FROM log;",
          "77:     UPDATE t1 SET y=v FROM t2, t3 WHERE t1.x=t2.a AND t3.k=t2.b;",
          "79:     SELECT * FROM t1;",
          "80:     SELECT * FROM log;",
          "81:   } {",
          "82:     1 i ten   2 xii two   3 v thirty   4 iv four",
          "83:     two->two         ii->xii",
          "84:     thirty->thirty   iii->v",
          "85:   }",
          "87:   do_execsql_test 1.%TN%.3 {",
          "88:     DELETE FROM log;",
          "89:     WITH data(k, v) AS (",
          "90:       VALUES(1, 'seven'), (1, 'eight'), (2, 'eleven'), (2, 'twelve')",
          "91:     )",
          "92:     UPDATE t1 SET z=v FROM data WHERE x=k;",
          "94:     SELECT * FROM t1;",
          "95:     SELECT * FROM log;",
          "96:   } {",
          "97:     1 i eight   2 xii twelve   3 v thirty   4 iv four",
          "98:     ten->eight        i->i",
          "99:     two->twelve       xii->xii",
          "100:   }",
          "102:   do_test 1.%TN%.4 { db changes } {2}",
          "104:   do_execsql_test 1.%TN%.5 {",
          "105:     CREATE VIEW v1 AS SELECT * FROM t1;",
          "106:     CREATE TRIGGER v1tr INSTEAD OF UPDATE ON v1 BEGIN",
          "107:       UPDATE t1 SET y=new.y, z=new.z WHERE x=new.x;",
          "108:     END;",
          "110:     DELETE FROM log;",
          "111:     WITH data(k, v) AS (",
          "112:       VALUES(3, 'thirteen'), (3, 'fourteen'), (4, 'fifteen'), (4, 'sixteen')",
          "113:     )",
          "114:     UPDATE v1 SET z=v FROM data WHERE x=k;",
          "115:   }",
          "117:   do_execsql_test 1.%TN%.6 {",
          "118:     SELECT * FROM v1;",
          "119:     SELECT * FROM log;",
          "120:   } {",
          "121:     1 i eight   2 xii twelve   3 v fourteen   4 iv sixteen",
          "122:     thirty->thirteen  v->v",
          "123:     thirteen->fourteen  v->v",
          "124:     four->fifteen  iv->iv",
          "125:     fifteen->sixteen  iv->iv",
          "126:   }",
          "128:   #--------------------------------------------------------------",
          "130:   do_execsql_test 1.%TN%.7 {",
          "131:     CREATE TABLE o1(w, x, y, z UNIQUE, PRIMARY KEY(w, x)) %WO%;",
          "132:     CREATE INDEX o1y ON t1(y);",
          "134:     INSERT INTO o1 VALUES(0, 0, 'i', 'one');",
          "135:     INSERT INTO o1 VALUES(0, 1, 'ii', 'two');",
          "136:     INSERT INTO o1 VALUES(1, 0, 'iii', 'three');",
          "137:     INSERT INTO o1 VALUES(1, 1, 'iv', 'four');",
          "139:     CREATE TRIGGER tro1 BEFORE UPDATE ON o1 BEGIN",
          "140:       INSERT INTO log VALUES(old.z || '->' || new.z);",
          "141:     END;",
          "142:     CREATE TRIGGER tro2 AFTER UPDATE ON o1 BEGIN",
          "143:       INSERT INTO log VALUES(old.y || '->' || new.y);",
          "144:     END;",
          "145:   }",
          "147:   do_execsql_test 1.%TN%.8 {",
          "148:     DELETE FROM log;",
          "149:     WITH data(k, v) AS (",
          "150:       VALUES(3, 'thirty'), (1, 'ten')",
          "151:     )",
          "152:     UPDATE o1 SET z=v FROM data WHERE (1+x+w*2)=k;",
          "154:     SELECT * FROM o1;",
          "155:     SELECT * FROM log;",
          "156:   } {",
          "157:     0 0 i ten   0 1 ii two   1 0 iii thirty   1 1 iv four",
          "158:     one->ten        i->i",
          "159:     three->thirty   iii->iii",
          "160:   }",
          "162:   do_execsql_test 1.%TN%.9 {",
          "163:     DELETE FROM log;",
          "164:     UPDATE o1 SET y=v FROM t2, t3 WHERE (1+o1.w*2+o1.x)=t2.a AND t3.k=t2.b;",
          "166:     SELECT * FROM o1;",
          "167:     SELECT * FROM log;",
          "168:   } {",
          "169:     0 0 i ten   0 1 xii two   1 0 v thirty   1 1 iv four",
          "170:     two->two         ii->xii",
          "171:     thirty->thirty   iii->v",
          "172:   }",
          "174:   do_execsql_test 1.%TN%.10 {",
          "175:     DELETE FROM log;",
          "176:     WITH data(k, v) AS (",
          "177:       VALUES(1, 'seven'), (1, 'eight'), (2, 'eleven'), (2, 'twelve')",
          "178:     )",
          "179:     UPDATE o1 SET z=v FROM data WHERE (1+w*2+x)=k;",
          "181:     SELECT * FROM o1;",
          "182:     SELECT * FROM log;",
          "183:   } {",
          "184:     0 0 i eight   0 1 xii twelve   1 0 v thirty   1 1 iv four",
          "185:     ten->eight        i->i",
          "186:     two->twelve       xii->xii",
          "187:   }",
          "189:   do_test 1.%TN%.11 { db changes } {2}",
          "191:   do_execsql_test 1.%TN%.12 {",
          "192:     CREATE VIEW w1 AS SELECT * FROM o1;",
          "193:     CREATE TRIGGER w1tr INSTEAD OF UPDATE ON w1 BEGIN",
          "194:       UPDATE o1 SET y=new.y, z=new.z WHERE w=new.w AND x=new.x;",
          "195:     END;",
          "197:     DELETE FROM log;",
          "198:     WITH data(k, v) AS (",
          "199:       VALUES(3, 'thirteen'), (3, 'fourteen'), (4, 'fifteen'), (4, 'sixteen')",
          "200:     )",
          "201:     UPDATE w1 SET z=v FROM data WHERE (1+w*2+x)=k;",
          "202:   }",
          "204:   do_execsql_test 1.%TN%.13 {",
          "205:     SELECT * FROM w1;",
          "206:     SELECT * FROM log;",
          "207:   } {",
          "208:     0 0 i eight   0 1 xii twelve   1 0 v fourteen   1 1 iv sixteen",
          "209:     thirty->thirteen  v->v",
          "210:     thirteen->fourteen  v->v",
          "211:     four->fifteen  iv->iv",
          "212:     fifteen->sixteen  iv->iv",
          "213:   }",
          "215: }]",
          "216: }",
          "218: ifcapable update_delete_limit {",
          "219: foreach {tn wo} {",
          "220:   1 \"\"",
          "221:   2 \"WITHOUT ROWID\"",
          "222: } {",
          "223:   reset_db",
          "225: eval [string map [list %WO% $wo %TN% $tn] {",
          "226:   do_execsql_test 2.%TN%.1 {",
          "227:     CREATE TABLE x1(a INTEGER PRIMARY KEY, b) %WO%;",
          "228:     INSERT INTO x1 VALUES",
          "229:         (1, 'one'), (2, 'two'), (3, 'three'), (4, 'four'),",
          "230:         (5, 'five'), (6, 'six'), (7, 'seven'), (8, 'eight');",
          "231:   }",
          "233:   do_execsql_test 2.%TN%.2 {",
          "234:     CREATE TABLE data1(x, y);",
          "235:     INSERT INTO data1 VALUES",
          "236:     (1, 'eleven'), (1, 'twenty-one'), (2, 'twelve'), (2, 'twenty-two'),",
          "237:     (3, 'thirteen'), (3, 'twenty-three'), (4, 'fourteen'), (4, 'twenty-four');",
          "238:   }",
          "240:   do_execsql_test 2.%TN%.3 {",
          "241:     UPDATE x1 SET b=y FROM data1 WHERE a=x ORDER BY a LIMIT 3;",
          "242:     SELECT * FROM x1;",
          "243:   } {",
          "244:     1 eleven 2 twelve 3 thirteen 4 four 5 five 6 six 7 seven 8 eight",
          "245:   }",
          "247:   do_execsql_test 2.%TN%.4 {",
          "248:     UPDATE x1 SET b=b||y FROM data1 WHERE a=x ORDER BY b LIMIT 3;",
          "249:     SELECT * FROM x1;",
          "250:   } {",
          "251:     1 eleveneleven 2 twelve 3 thirteenthirteen 4 fourfourteen",
          "252:     5 five 6 six 7 seven 8 eight",
          "253:   }",
          "255:   do_catchsql_test 2.%TN%.5 {",
          "256:     UPDATE x1 SET b=b||b ORDER BY b;",
          "257:   } {1 {ORDER BY without LIMIT on UPDATE}}",
          "258:   do_catchsql_test 2.%TN%.6 {",
          "259:     UPDATE x1 SET b=b||y FROM data1 WHERE a=x ORDER BY b;",
          "260:   } {1 {ORDER BY without LIMIT on UPDATE}}",
          "262:   #-----------------------------------------------------------------------",
          "264:   do_execsql_test 2.%TN%.6 {",
          "265:     DROP TABLE x1;",
          "266:     CREATE TABLE x1(u, v, b, PRIMARY KEY(u, v)) %WO%;",
          "267:     INSERT INTO x1 VALUES",
          "268:         (0, 1, 'one'), (1, 0, 'two'), (1, 1, 'three'), (2, 0, 'four'),",
          "269:         (2, 1, 'five'), (3, 0, 'six'), (3, 1, 'seven'), (4, 0, 'eight');",
          "270:   }",
          "272:   do_execsql_test 2.%TN%.7 {",
          "273:     UPDATE x1 SET b=y FROM data1 WHERE (u*2+v)=x ORDER BY u, v LIMIT 3;",
          "274:     SELECT * FROM x1;",
          "275:   } {",
          "276:     0 1 eleven 1 0 twelve 1 1 thirteen 2 0 four",
          "277:     2 1 five 3 0 six 3 1 seven 4 0 eight",
          "278:   }",
          "280:   do_execsql_test 2.%TN%.8 {",
          "281:     UPDATE x1 SET b=b||y FROM data1 WHERE (u*2+v)=x ORDER BY b LIMIT 3;",
          "282:     SELECT * FROM x1;",
          "283:   } {",
          "284:     0 1 eleveneleven 1 0 twelve 1 1 thirteenthirteen 2 0 fourfourteen",
          "285:     2 1 five  3 0 six 3 1 seven 4 0 eight",
          "286:   }",
          "289: }]",
          "290: }}",
          "292: reset_db",
          "293: do_execsql_test 3.0 {",
          "294:   CREATE TABLE data(x, y, z);",
          "295:   CREATE VIEW t1 AS SELECT * FROM data;",
          "296:   CREATE TRIGGER t1_insert INSTEAD OF INSERT ON t1 BEGIN",
          "297:     INSERT INTO data VALUES(new.x, new.y, new.z);",
          "298:   END;",
          "299:   CREATE TRIGGER t1_update INSTEAD OF UPDATE ON t1 BEGIN",
          "300:     INSERT INTO log VALUES(old.z || '->' || new.z);",
          "301:   END;",
          "303:   CREATE TABLE log(t TEXT);",
          "305:   INSERT INTO t1 VALUES(1, 'i',   'one');",
          "306:   INSERT INTO t1 VALUES(2, 'ii',  'two');",
          "307:   INSERT INTO t1 VALUES(3, 'iii', 'three');",
          "308:   INSERT INTO t1 VALUES(4, 'iv',  'four');",
          "309: }",
          "311: do_execsql_test 3.1 {",
          "312:   WITH input(k, v) AS (",
          "313:       VALUES(3, 'thirty'), (1, 'ten')",
          "314:   )",
          "315:   UPDATE t1 SET z=v FROM input WHERE x=k;",
          "316: }",
          "318: foreach {tn sql} {",
          "319:   2 {",
          "320:     CREATE TABLE x1(a INT PRIMARY KEY, b, c) WITHOUT ROWID;",
          "321:   }",
          "322:   1 {",
          "323:     CREATE TABLE x1(a INTEGER PRIMARY KEY, b, c);",
          "324:   }",
          "325:   3 {",
          "326:     CREATE TABLE x1(a INT PRIMARY KEY, b, c);",
          "327:   }",
          "328: } {",
          "330:   reset_db",
          "331:   execsql $sql",
          "333:   do_execsql_test 4.$tn.0 {",
          "334:     INSERT INTO x1 VALUES(1, 1, 1);",
          "335:     INSERT INTO x1 VALUES(2, 2, 2);",
          "336:     INSERT INTO x1 VALUES(3, 3, 3);",
          "337:     INSERT INTO x1 VALUES(4, 4, 4);",
          "338:     INSERT INTO x1 VALUES(5, 5, 5);",
          "339:     CREATE TABLE map(o, t);",
          "340:     INSERT INTO map VALUES(3, 30), (4, 40), (1, 10);",
          "341:   }",
          "343:   do_execsql_test 4.$tn.1 {",
          "344:     UPDATE x1 SET a=t FROM map WHERE a=o;",
          "345:     SELECT * FROM x1 ORDER BY a;",
          "346:   } {2 2 2   5 5 5   10 1 1  30 3 3  40 4 4}",
          "347: }",
          "349: finish_test",
          "",
          "---------------"
        ],
        "test/upfrom3.test||test/upfrom3.test": [
          "File: test/upfrom3.test -> test/upfrom3.test",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: # 2020 July 14",
          "2: #",
          "3: # The author disclaims copyright to this source code.  In place of",
          "4: # a legal notice, here is a blessing:",
          "5: #",
          "6: #    May you do good and not evil.",
          "7: #    May you find forgiveness for yourself and forgive others.",
          "8: #    May you share freely, never taking more than you give.",
          "9: #",
          "10: #***********************************************************************",
          "11: #",
          "13: set testdir [file dirname $argv0]",
          "14: source $testdir/tester.tcl",
          "15: set testprefix upfrom3",
          "17: # Test plan:",
          "18: #",
          "19: #   1.*: Test UPDATE ... FROM statements that modify IPK fields. And that",
          "20: #        modify \"INTEGER PRIMARY KEY\" fields on WITHOUT ROWID tables.",
          "21: #",
          "22: #   2.*: Test UPDATE ... FROM statements that modify PK fields of WITHOUT",
          "23: #        ROWID tables.",
          "24: #",
          "25: #   3.*: Test that UPDATE ... FROM statements are not confused if there",
          "26: #        are multiple tables of the same name in attached databases.",
          "27: #",
          "28: #   4.*: Tests for UPDATE ... FROM statements and foreign keys.",
          "29: #",
          "31: foreach {tn wo} {",
          "32:   1 \"\"",
          "33:   2 \"WITHOUT ROWID\"",
          "34: } {",
          "35:   reset_db",
          "36:   eval [string map [list %WO% $wo %TN% $tn] {",
          "38:   do_execsql_test 1.%TN%.0 {",
          "39:     CREATE TABLE log(t TEXT);",
          "40:     CREATE TABLE t1(x INTEGER PRIMARY KEY, y, z UNIQUE) %WO%;",
          "41:     CREATE INDEX t1y ON t1(y);",
          "43:     INSERT INTO t1 VALUES(1, 'i',   'one');",
          "44:     INSERT INTO t1 VALUES(2, 'ii',  'two');",
          "45:     INSERT INTO t1 VALUES(3, 'iii', 'three');",
          "46:     INSERT INTO t1 VALUES(4, 'iv',  'four');",
          "47:   }",
          "49:   do_execsql_test 1.%TN%.1 {",
          "50:     CREATE TABLE x1(o, n);",
          "51:     INSERT INTO x1 VALUES(1, 11);",
          "52:     INSERT INTO x1 VALUES(2, 12);",
          "53:     INSERT INTO x1 VALUES(3, 13);",
          "54:     INSERT INTO x1 VALUES(4, 14);",
          "55:     UPDATE t1 SET x=n FROM x1 WHERE x=o;",
          "56:     SELECT x, y, z FROM t1 ORDER BY 1;",
          "57:   } {",
          "58:     11 i one",
          "59:     12 ii two",
          "60:     13 iii three",
          "61:     14 iv four",
          "62:   }",
          "64:   do_test 1.%TN%.2 { db changes } 4",
          "66:   do_execsql_test 1.%TN%.3 {",
          "67:     INSERT INTO x1 VALUES(11, 21);",
          "68:     INSERT INTO x1 VALUES(12, 22);",
          "69:     INSERT INTO x1 VALUES(13, 23);",
          "70:     INSERT INTO x1 VALUES(14, 24);",
          "72:     INSERT INTO x1 VALUES(21, 31);",
          "73:     INSERT INTO x1 VALUES(22, 32);",
          "74:     INSERT INTO x1 VALUES(23, 33);",
          "75:     INSERT INTO x1 VALUES(24, 34);",
          "76:     UPDATE t1 SET x=n FROM x1 WHERE x=o;",
          "77:     SELECT x, y, z FROM t1 ORDER BY 1;",
          "78:   } {",
          "79:     21 i one",
          "80:     22 ii two",
          "81:     23 iii three",
          "82:     24 iv four",
          "83:   }",
          "85:   do_execsql_test 1.%TN%.4 {",
          "86:     UPDATE t1 SET x=n FROM x1 WHERE x=o;",
          "87:     SELECT x, y, z FROM t1 ORDER BY 1;",
          "88:   } {",
          "89:     31 i one",
          "90:     32 ii two",
          "91:     33 iii three",
          "92:     34 iv four",
          "93:   }",
          "95:   do_execsql_test 1.%TN%.5 {",
          "96:     INSERT INTO x1 VALUES(31, 32);",
          "97:     INSERT INTO x1 VALUES(33, 34);",
          "98:     UPDATE OR REPLACE t1 SET x=n FROM x1 WHERE x=o;",
          "99:     SELECT x, y, z FROM t1 ORDER BY 1;",
          "100:   } {",
          "101:     32 i one",
          "102:     34 iii three",
          "103:   }",
          "105:   do_execsql_test 1.%TN%.6 {",
          "106:     INSERT INTO t1 VALUES(33, 'ii', 'two');",
          "107:     INSERT INTO t1 VALUES(35, 'iv', 'four');",
          "108:   }",
          "110:   do_execsql_test 1.%TN%.7 {",
          "111:     CREATE TABLE x2(o, n, zz);",
          "112:     INSERT INTO x2 VALUES(32, 41, 'four');",
          "113:     INSERT INTO x2 VALUES(33, 42, 'three');",
          "114:     UPDATE OR IGNORE t1 SET x=n, z=zz FROM x2 WHERE x=o;",
          "115:     SELECT x, y, z FROM t1 ORDER BY 1;",
          "116:   } {",
          "117:     32 i one",
          "118:     33 ii two",
          "119:     34 iii three",
          "120:     35 iv four",
          "121:   }",
          "123:   do_execsql_test 1.%TN%.8 {",
          "124:     UPDATE OR REPLACE t1 SET x=n, z=zz FROM x2 WHERE x=o;",
          "125:     SELECT x, y, z FROM t1 ORDER BY 1;",
          "126:   } {",
          "127:     41 i four",
          "128:     42 ii three",
          "129:   }",
          "131:   }]",
          "132: }",
          "134: do_execsql_test 2.1.1 {",
          "135:   CREATE TABLE u1(a, b, c, PRIMARY KEY(b, c)) WITHOUT ROWID;",
          "136:   INSERT INTO u1 VALUES(0, 0, 0);",
          "137:   INSERT INTO u1 VALUES(1, 0, 1);",
          "138:   INSERT INTO u1 VALUES(2, 1, 0);",
          "139:   INSERT INTO u1 VALUES(3, 1, 1);",
          "140: }",
          "142: do_execsql_test 2.1.2 {",
          "143:   CREATE TABLE map(f, t);",
          "144:   INSERT INTO map VALUES(0, 10);",
          "145:   INSERT INTO map VALUES(1, 11);",
          "146:   UPDATE u1 SET c=t FROM map WHERE c=f;",
          "147:   SELECT * FROM u1 ORDER BY a;",
          "148: } {",
          "149:   0 0 10",
          "150:   1 0 11",
          "151:   2 1 10",
          "152:   3 1 11",
          "153: }",
          "155: do_execsql_test 2.1.3 {",
          "156:   UPDATE u1 SET b=t FROM map WHERE b=f;",
          "157:   SELECT * FROM u1 ORDER BY a;",
          "158: } {",
          "159:   0 10 10",
          "160:   1 10 11",
          "161:   2 11 10",
          "162:   3 11 11",
          "163: }",
          "165: do_execsql_test 2.1.4 {",
          "166:   CREATE TABLE map2(o1, o2, n1, n2);",
          "167:   INSERT INTO map2 VALUES",
          "168:     (10, 10, 50, 50), (10, 11, 50, 60),",
          "169:     (11, 10, 60, 50), (11, 11, 60, 60);",
          "170:   UPDATE u1 SET b=n1, c=n2 FROM map2 WHERE b=o1 AND c=o2;",
          "171:   SELECT * FROM u1 ORDER BY a;",
          "172: } {",
          "173:   0 50 50",
          "174:   1 50 60",
          "175:   2 60 50",
          "176:   3 60 60",
          "177: }",
          "179: #-------------------------------------------------------------------------",
          "180: foreach {tn wo} {",
          "181:   1 \"\"",
          "182:   2 \"WITHOUT ROWID\"",
          "183: } {",
          "184:   reset_db",
          "185:   forcedelete test.db2",
          "186:   eval [string map [list %WO% $wo %TN% $tn] {",
          "187:     do_execsql_test 3.$tn.1 {",
          "188:       CREATE TABLE g1(a, b, c, PRIMARY KEY(a, b)) %WO%;",
          "189:       INSERT INTO g1 VALUES(1, 1, 1);",
          "191:       ATTACH 'test.db2' AS aux;",
          "192:       CREATE TABLE aux.g1(a, b, c, PRIMARY KEY(a, b)) %WO%;",
          "193:       INSERT INTO aux.g1 VALUES(10, 1, 10);",
          "194:       INSERT INTO aux.g1 VALUES(20, 2, 20);",
          "195:       INSERT INTO aux.g1 VALUES(30, 3, 30);",
          "196:     }",
          "198:     do_execsql_test 3.$tn.2 {",
          "199:       UPDATE aux.g1 SET c=101 FROM main.g1;",
          "200:     }",
          "201:     do_execsql_test 3.$tn.3 {",
          "202:       SELECT * FROM aux.g1;",
          "203:     } {10 1 101  20 2 101  30 3 101}",
          "205:     do_execsql_test 3.$tn.4 {",
          "206:       UPDATE g1 SET c=101 FROM g1;",
          "207:     }",
          "208:     do_execsql_test 3.$tn.5 {",
          "209:       SELECT * FROM g1;",
          "210:     } {1 1 101}",
          "211:   }]",
          "212: }",
          "214: #-------------------------------------------------------------------------",
          "215: reset_db",
          "216: foreach {tn wo} {",
          "217:   1 \"\"",
          "218:   2 \"WITHOUT ROWID\"",
          "219: } {",
          "220:   reset_db",
          "221:   forcedelete test.db2",
          "222:   eval [string map [list %WO% $wo %TN% $tn] {",
          "224:     do_execsql_test 4.$tn.1 {",
          "225:       CREATE TABLE p1(a INTEGER PRIMARY KEY, b) %WO%;",
          "226:       CREATE TABLE c1(x PRIMARY KEY, y REFERENCES p1 ON UPDATE CASCADE) %WO%;",
          "227:       PRAGMA foreign_keys = 1;",
          "229:       INSERT INTO p1 VALUES(1, 'one');",
          "230:       INSERT INTO p1 VALUES(11, 'eleven');",
          "231:       INSERT INTO p1 VALUES(111, 'eleventyone');",
          "233:       INSERT INTO c1 VALUES('a', 1);",
          "234:       INSERT INTO c1 VALUES('b', 11);",
          "235:       INSERT INTO c1 VALUES('c', 111);",
          "236:     }",
          "238:     do_execsql_test 4.$tn.2 {",
          "239:       CREATE TABLE map(f, t);",
          "240:       INSERT INTO map VALUES('a', 111);",
          "241:       INSERT INTO map VALUES('c', 112);",
          "242:     }",
          "244:     do_catchsql_test 4.$tn.3 {",
          "245:       UPDATE c1 SET y=t FROM map WHERE x=f;",
          "246:     } {1 {FOREIGN KEY constraint failed}}",
          "248:     do_execsql_test 4.$tn.4 {",
          "249:       INSERT INTO map VALUES('eleven', 12);",
          "250:       INSERT INTO map VALUES('eleventyone', 112);",
          "251:       UPDATE p1 SET a=t FROM map WHERE b=f;",
          "252:     }",
          "254:     do_execsql_test 4.$tn.5 {",
          "255:       SELECT * FROM c1",
          "256:     } {a 1  b 12  c 112}",
          "258:   }]",
          "259: }",
          "261: finish_test",
          "",
          "---------------"
        ],
        "test/upfromfault.test||test/upfromfault.test": [
          "File: test/upfromfault.test -> test/upfromfault.test",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: # 2020 April 29",
          "2: #",
          "3: # The author disclaims copyright to this source code.  In place of",
          "4: # a legal notice, here is a blessing:",
          "5: #",
          "6: #    May you do good and not evil.",
          "7: #    May you find forgiveness for yourself and forgive others.",
          "8: #    May you share freely, never taking more than you give.",
          "9: #",
          "10: #***********************************************************************",
          "11: #",
          "13: set testdir [file dirname $argv0]",
          "14: source $testdir/tester.tcl",
          "15: set testprefix upfromfault",
          "17: foreach {tn sql} {",
          "18:   1 {",
          "19:     CREATE TABLE t1(x PRIMARY KEY, y, z UNIQUE);",
          "20:     CREATE INDEX t1y ON t1(y);",
          "21:   }",
          "22:   2 {",
          "23:     CREATE TABLE t1(x PRIMARY KEY, y, z UNIQUE) WITHOUT ROWID;",
          "24:     CREATE INDEX t1y ON t1(y);",
          "25:   }",
          "26:   3 {",
          "27:     CREATE TABLE t1(x, y, z UNIQUE, PRIMARY KEY(x,y)) WITHOUT ROWID;",
          "28:   }",
          "29:   4 {",
          "30:     CREATE VIRTUAL TABLE t1 USING fts5(x, y, z);",
          "31:   }",
          "32:   5 {",
          "33:     CREATE TABLE real(x, y, z);",
          "34:     CREATE VIEW t1 AS SELECT * FROM real;",
          "35:     CREATE TRIGGER t1_insert INSTEAD OF INSERT ON t1 BEGIN",
          "36:       INSERT INTO real VALUES(new.x, new.y, new.z);",
          "37:     END;",
          "38:     CREATE TRIGGER t1_update INSTEAD OF UPDATE ON t1 BEGIN",
          "39:       INSERT INTO log VALUES(old.z || '->' || new.z);",
          "40:       UPDATE real SET y=new.y, z=new.z WHERE x=old.x;",
          "41:     END;",
          "42:   }",
          "43: } {",
          "44: if {$tn<5} continue",
          "45:   reset_db",
          "47:   ifcapable !fts5 { if {$tn==4} continue }",
          "49:   execsql $sql",
          "50:   do_execsql_test 1.$tn.0 {",
          "51:     CREATE TABLE log(t TEXT);",
          "53:     INSERT INTO t1 VALUES(1, 'i',   'one');",
          "54:     INSERT INTO t1 VALUES(2, 'ii',  'two');",
          "55:     INSERT INTO t1 VALUES(3, 'iii', 'three');",
          "56:     INSERT INTO t1 VALUES(4, 'iv',  'four');",
          "57:   }",
          "58:   if {$tn!=4 && $tn!=5} {",
          "59:     do_execsql_test 1.$tn.0b {",
          "60:       CREATE TRIGGER tr1 BEFORE UPDATE ON t1 BEGIN",
          "61:         INSERT INTO log VALUES(old.z || '->' || new.z);",
          "62:       END;",
          "63:       CREATE TRIGGER tr2 AFTER UPDATE ON t1 BEGIN",
          "64:         INSERT INTO log VALUES(old.y || '->' || new.y);",
          "65:       END;",
          "66:     }",
          "67:   }",
          "69:   faultsim_save_and_close",
          "71:   do_faultsim_test 1.$tn -prep {",
          "72:     faultsim_restore_and_reopen",
          "73:     execsql { SELECT * FROM t1 }",
          "74:   } -body {",
          "75:     execsql {",
          "76:       WITH data(k, v) AS (",
          "77:           VALUES(3, 'thirty'), (1, 'ten')",
          "78:       )",
          "79:       UPDATE t1 SET z=v FROM data WHERE x=k;",
          "80:     }",
          "81:   } -test {",
          "82:     faultsim_test_result {0 {}} {1 {vtable constructor failed: t1}}",
          "83:     if {$testrc==0} {",
          "84:       set res [execsql { SELECT * FROM t1 }]",
          "85:       if {$res!=\"1 i ten 2 ii two 3 iii thirty 4 iv four\"} {",
          "86:         error \"unexpected result: $res\"",
          "87:       }",
          "88:     }",
          "89:   }",
          "90: }",
          "93: finish_test",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "2e51dc6c9ba75d1fdf6d9953f710cf49bc2a04d1",
      "candidate_info": {
        "commit_hash": "2e51dc6c9ba75d1fdf6d9953f710cf49bc2a04d1",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/2e51dc6c9ba75d1fdf6d9953f710cf49bc2a04d1",
        "files": [
          "manifest",
          "manifest.uuid",
          "src/build.c",
          "src/expr.c",
          "src/insert.c",
          "src/parse.y",
          "src/sqliteInt.h",
          "src/treeview.c",
          "test/default.test",
          "test/select3.test"
        ],
        "message": "Merge updates from trunk.\n\nFossilOrigin-Name: e05f743f619a6b60d0782ee85c73f6866696962954d7cb3eceb03af79c6a6189",
        "before_after_code_files": [
          "manifest.uuid||manifest.uuid",
          "src/build.c||src/build.c",
          "src/expr.c||src/expr.c",
          "src/insert.c||src/insert.c",
          "src/parse.y||src/parse.y",
          "src/sqliteInt.h||src/sqliteInt.h",
          "src/treeview.c||src/treeview.c",
          "test/default.test||test/default.test",
          "test/select3.test||test/select3.test"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: 29d1cc5c3619a88229f18c3c8131228f8a2d151ac3d9203f0c7fc538a996ecec",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/build.c||src/build.c": [
          "File: src/build.c -> src/build.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "2157: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2160: #ifdef SQLITE_DEBUG",
          "2167: static int markImmutableExprStep(Walker *pWalker, Expr *pExpr){",
          "2168:   ExprSetVVAProperty(pExpr, EP_Immutable);",
          "2169:   return WRC_Continue;",
          "2170: }",
          "2171: static void markExprListImmutable(ExprList *pList){",
          "2172:   if( pList ){",
          "2173:     Walker w;",
          "2174:     memset(&w, 0, sizeof(w));",
          "2175:     w.xExprCallback = markImmutableExprStep;",
          "2176:     w.xSelectCallback = sqlite3SelectWalkNoop;",
          "2177:     w.xSelectCallback2 = 0;",
          "2178:     sqlite3WalkExprList(&w, pList);",
          "2179:   }",
          "2180: }",
          "2181: #else",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2250:       sqlite3ExprListDelete(db, p->pCheck);",
          "2251:       p->pCheck = 0;",
          "2252:     }",
          "2253:   }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2278:     }else{",
          "2279:       markExprListImmutable(p->pCheck);",
          "",
          "---------------"
        ],
        "src/expr.c||src/expr.c": [
          "File: src/expr.c -> src/expr.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "46:   int op;",
          "47:   while( ExprHasProperty(pExpr, EP_Skip) ){",
          "48:     assert( pExpr->op==TK_COLLATE );",
          "",
          "[Removed Lines]",
          "45: char sqlite3ExprAffinity(Expr *pExpr){",
          "",
          "[Added Lines]",
          "45: char sqlite3ExprAffinity(const Expr *pExpr){",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "156:   sqlite3 *db = pParse->db;",
          "157:   CollSeq *pColl = 0;",
          "159:   while( p ){",
          "160:     int op = p->op;",
          "161:     if( op==TK_REGISTER ) op = p->op2;",
          "",
          "[Removed Lines]",
          "155: CollSeq *sqlite3ExprCollSeq(Parse *pParse, Expr *pExpr){",
          "158:   Expr *p = pExpr;",
          "",
          "[Added Lines]",
          "155: CollSeq *sqlite3ExprCollSeq(Parse *pParse, const Expr *pExpr){",
          "158:   const Expr *p = pExpr;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "228:   CollSeq *p = sqlite3ExprCollSeq(pParse, pExpr);",
          "229:   if( p==0 ) p = pParse->db->pDfltColl;",
          "230:   assert( p!=0 );",
          "",
          "[Removed Lines]",
          "227: CollSeq *sqlite3ExprNNCollSeq(Parse *pParse, Expr *pExpr){",
          "",
          "[Added Lines]",
          "227: CollSeq *sqlite3ExprNNCollSeq(Parse *pParse, const Expr *pExpr){",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "238:   CollSeq *pColl1 = sqlite3ExprNNCollSeq(pParse, pE1);",
          "239:   CollSeq *pColl2 = sqlite3ExprNNCollSeq(pParse, pE2);",
          "240:   return sqlite3StrICmp(pColl1->zName, pColl2->zName)==0;",
          "",
          "[Removed Lines]",
          "237: int sqlite3ExprCollSeqMatch(Parse *pParse, Expr *pE1, Expr *pE2){",
          "",
          "[Added Lines]",
          "237: int sqlite3ExprCollSeqMatch(Parse *pParse, const Expr *pE1, const Expr *pE2){",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "249:   char aff1 = sqlite3ExprAffinity(pExpr);",
          "250:   if( aff1>SQLITE_AFF_NONE && aff2>SQLITE_AFF_NONE ){",
          "",
          "[Removed Lines]",
          "248: char sqlite3CompareAffinity(Expr *pExpr, char aff2){",
          "",
          "[Added Lines]",
          "248: char sqlite3CompareAffinity(const Expr *pExpr, char aff2){",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "271:   char aff;",
          "272:   assert( pExpr->op==TK_EQ || pExpr->op==TK_IN || pExpr->op==TK_LT ||",
          "273:           pExpr->op==TK_GT || pExpr->op==TK_GE || pExpr->op==TK_LE ||",
          "",
          "[Removed Lines]",
          "270: static char comparisonAffinity(Expr *pExpr){",
          "",
          "[Added Lines]",
          "270: static char comparisonAffinity(const Expr *pExpr){",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "294:   char aff = comparisonAffinity(pExpr);",
          "295:   if( aff<SQLITE_AFF_TEXT ){",
          "296:     return 1;",
          "",
          "[Removed Lines]",
          "293: int sqlite3IndexAffinityOk(Expr *pExpr, char idx_affinity){",
          "",
          "[Added Lines]",
          "293: int sqlite3IndexAffinityOk(const Expr *pExpr, char idx_affinity){",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "309:   u8 aff = (char)sqlite3ExprAffinity(pExpr2);",
          "310:   aff = (u8)sqlite3CompareAffinity(pExpr1, aff) | (u8)jumpIfNull;",
          "311:   return aff;",
          "",
          "[Removed Lines]",
          "308: static u8 binaryCompareP5(Expr *pExpr1, Expr *pExpr2, int jumpIfNull){",
          "",
          "[Added Lines]",
          "308: static u8 binaryCompareP5(",
          "312: ){",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "326: CollSeq *sqlite3BinaryCompareCollSeq(",
          "327:   Parse *pParse,",
          "330: ){",
          "331:   CollSeq *pColl;",
          "332:   assert( pLeft );",
          "",
          "[Removed Lines]",
          "328:   Expr *pLeft,",
          "329:   Expr *pRight",
          "",
          "[Added Lines]",
          "332:   const Expr *pLeft,",
          "333:   const Expr *pRight",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "355:   if( ExprHasProperty(p, EP_Commuted) ){",
          "356:     return sqlite3BinaryCompareCollSeq(pParse, p->pRight, p->pLeft);",
          "357:   }else{",
          "",
          "[Removed Lines]",
          "354: CollSeq *sqlite3ExprCompareCollSeq(Parse *pParse, Expr *p){",
          "",
          "[Added Lines]",
          "358: CollSeq *sqlite3ExprCompareCollSeq(Parse *pParse, const Expr *p){",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "594:   int addrDone = sqlite3VdbeMakeLabel(pParse);",
          "595:   int isCommuted = ExprHasProperty(pExpr,EP_Commuted);",
          "597:   if( pParse->nErr ) return;",
          "598:   if( nLeft!=sqlite3ExprVectorSize(pRight) ){",
          "599:     sqlite3ErrorMsg(pParse, \"row value misused\");",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "601:   assert( !ExprHasVVAProperty(pExpr,EP_Immutable) );",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "1206:     assert( !ExprHasProperty(p, EP_TokenOnly|EP_Reduced) );",
          "1207:     assert( !ExprHasProperty(p, EP_FromJoin) );",
          "1208:     assert( !ExprHasProperty(p, EP_MemToken) );",
          "1210:     if( p->pLeft || p->x.pList ){",
          "1211:       nSize = EXPR_REDUCEDSIZE | EP_Reduced;",
          "1212:     }else{",
          "",
          "[Removed Lines]",
          "1209:     assert( !ExprHasProperty(p, EP_NoReduce) );",
          "",
          "[Added Lines]",
          "1214:     assert( !ExprHasVVAProperty(p, EP_NoReduce) );",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "1311:     pNew->flags &= ~(EP_Reduced|EP_TokenOnly|EP_Static|EP_MemToken);",
          "1312:     pNew->flags |= nStructSize & (EP_Reduced|EP_TokenOnly);",
          "1313:     pNew->flags |= staticFlag;",
          "1316:     if( nToken ){",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1319:     ExprClearVVAProperties(pNew);",
          "1320:     if( dupFlags ){",
          "1321:       ExprSetVVAProperty(pNew, EP_Immutable);",
          "1322:     }",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "2852:     ExprSetProperty(pExpr, EP_Subrtn);",
          "2853:     pExpr->y.sub.regReturn = ++pParse->nMem;",
          "2854:     pExpr->y.sub.iAddr =",
          "2855:       sqlite3VdbeAddOp2(v, OP_Integer, 0, pExpr->y.sub.regReturn) + 1;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2862:     assert( !ExprHasProperty(pExpr, EP_TokenOnly|EP_Reduced) );",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "3173:   pLeft = pExpr->pLeft;",
          "3174:   if( sqlite3ExprCheckIN(pParse, pExpr) ) return;",
          "3175:   zAff = exprINAffinity(pParse, pExpr);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3183:   assert( !ExprHasVVAProperty(pExpr,EP_Immutable) );",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "3496:   }else{",
          "3497:     iAddr = 0;",
          "3498:   }",
          "3500:   if( pCol->affinity>=SQLITE_AFF_TEXT ){",
          "3501:     sqlite3VdbeAddOp4(v, OP_Affinity, regOut, 1, 0, &pCol->affinity, 1);",
          "3502:   }",
          "",
          "[Removed Lines]",
          "3499:   sqlite3ExprCode(pParse, pCol->pDflt, regOut);",
          "",
          "[Added Lines]",
          "3510:   sqlite3ExprCodeCopy(pParse, pCol->pDflt, regOut);",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "3780:   if( pExpr==0 ){",
          "3781:     op = TK_NULL;",
          "3782:   }else{",
          "3783:     op = pExpr->op;",
          "3784:   }",
          "3785:   switch( op ){",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3794:     assert( !ExprHasVVAProperty(pExpr,EP_Immutable) );",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "3790:         assert( pCol->iMem>0 );",
          "3791:         return pCol->iMem;",
          "3792:       }else if( pAggInfo->useSortingIdx ){",
          "3793:         sqlite3VdbeAddOp3(v, OP_Column, pAggInfo->sortingIdxPTab,",
          "3794:                               pCol->iSorterColumn, target);",
          "3795:         return target;",
          "3796:       }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3805:         Table *pTab = pCol->pTab;",
          "3808:         if( ALWAYS(pTab) && pCol->iColumn>=0 ){",
          "3809:           sqlite3ColumnDefault(v, pTab, pCol->iColumn, target);",
          "3810:         }",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "4034:         tempX.op = TK_INTEGER;",
          "4035:         tempX.flags = EP_IntValue|EP_TokenOnly;",
          "4036:         tempX.u.iValue = 0;",
          "4037:         r1 = sqlite3ExprCodeTemp(pParse, &tempX, &regFree1);",
          "4038:         r2 = sqlite3ExprCodeTemp(pParse, pExpr->pLeft, &regFree2);",
          "4039:         sqlite3VdbeAddOp3(v, OP_Subtract, r2, r1, target);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4053:         ExprClearVVAProperties(&tempX);",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "4110:         return sqlite3ExprCodeAtInit(pParse, pExpr, -1);",
          "4111:       }",
          "4112:       assert( !ExprHasProperty(pExpr, EP_xIsSelect) );",
          "4118:       nFarg = pFarg ? pFarg->nExpr : 0;",
          "4119:       assert( !ExprHasProperty(pExpr, EP_IntValue) );",
          "4120:       zId = pExpr->u.zToken;",
          "",
          "[Removed Lines]",
          "4113:       if( ExprHasProperty(pExpr, EP_TokenOnly) ){",
          "4114:         pFarg = 0;",
          "4115:       }else{",
          "4116:         pFarg = pExpr->x.pList;",
          "4117:       }",
          "",
          "[Added Lines]",
          "4130:       assert( !ExprHasProperty(pExpr, EP_TokenOnly) );",
          "4131:       pFarg = pExpr->x.pList;",
          "",
          "---------------",
          "--- Hunk 21 ---",
          "[Context before]",
          "4568: void sqlite3ExprCode(Parse *pParse, Expr *pExpr, int target){",
          "4569:   int inReg;",
          "4571:   assert( target>0 && target<=pParse->nMem );",
          "4572:   inReg = sqlite3ExprCodeTarget(pParse, pExpr, target);",
          "4573:   assert( pParse->pVdbe!=0 || pParse->db->mallocFailed );",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4585:   assert( pExpr==0 || !ExprHasVVAProperty(pExpr,EP_Immutable) );",
          "",
          "---------------",
          "--- Hunk 22 ---",
          "[Context before]",
          "4604:   if( pParse->okConstFactor && sqlite3ExprIsConstantNotJoin(pExpr) ){",
          "4605:     sqlite3ExprCodeAtInit(pParse, pExpr, target);",
          "4606:   }else{",
          "4608:   }",
          "4609: }",
          "",
          "[Removed Lines]",
          "4607:     sqlite3ExprCode(pParse, pExpr, target);",
          "",
          "[Added Lines]",
          "4622:     sqlite3ExprCodeCopy(pParse, pExpr, target);",
          "",
          "---------------",
          "--- Hunk 23 ---",
          "[Context before]",
          "4785:   assert( jumpIfNull==SQLITE_JUMPIFNULL || jumpIfNull==0 );",
          "4788:   op = pExpr->op;",
          "4789:   switch( op ){",
          "4790:     case TK_AND:",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4803:   assert( !ExprHasVVAProperty(pExpr, EP_Immutable) );",
          "",
          "---------------",
          "--- Hunk 24 ---",
          "[Context before]",
          "4926:   assert( jumpIfNull==SQLITE_JUMPIFNULL || jumpIfNull==0 );",
          "4928:   if( pExpr==0 )    return;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4945:   assert( !ExprHasVVAProperty(pExpr,EP_Immutable) );",
          "",
          "---------------",
          "--- Hunk 25 ---",
          "[Context before]",
          "5209:   }",
          "5210:   if( (pA->flags & (EP_Distinct|EP_Commuted))",
          "5211:      != (pB->flags & (EP_Distinct|EP_Commuted)) ) return 2;",
          "5213:     if( combinedFlags & EP_xIsSelect ) return 2;",
          "5214:     if( (combinedFlags & EP_FixedCol)==0",
          "5215:      && sqlite3ExprCompare(pParse, pA->pLeft, pB->pLeft, iTab) ) return 2;",
          "",
          "[Removed Lines]",
          "5212:   if( (combinedFlags & EP_TokenOnly)==0 ){",
          "",
          "[Added Lines]",
          "5229:   if( ALWAYS((combinedFlags & EP_TokenOnly)==0) ){",
          "",
          "---------------",
          "--- Hunk 26 ---",
          "[Context before]",
          "5217:     if( sqlite3ExprListCompare(pA->x.pList, pB->x.pList, iTab) ) return 2;",
          "5218:     if( pA->op!=TK_STRING",
          "5219:      && pA->op!=TK_TRUEFALSE",
          "5221:     ){",
          "5222:       if( pA->iColumn!=pB->iColumn ) return 2;",
          "5223:       if( pA->op2!=pB->op2 ){",
          "",
          "[Removed Lines]",
          "5220:      && (combinedFlags & EP_Reduced)==0",
          "",
          "[Added Lines]",
          "5237:      && ALWAYS((combinedFlags & EP_Reduced)==0)",
          "",
          "---------------"
        ],
        "src/insert.c||src/insert.c": [
          "File: src/insert.c -> src/insert.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1606:             VdbeCoverage(v);",
          "1607:             assert( (pCol->colFlags & COLFLAG_GENERATED)==0 );",
          "1608:             nSeenReplace++;",
          "1610:             sqlite3VdbeJumpHere(v, addr1);",
          "1611:             break;",
          "1612:           }",
          "",
          "[Removed Lines]",
          "1609:             sqlite3ExprCode(pParse, pCol->pDflt, iReg);",
          "",
          "[Added Lines]",
          "1609:             sqlite3ExprCodeCopy(pParse, pCol->pDflt, iReg);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1661:     onError = overrideError!=OE_Default ? overrideError : OE_Abort;",
          "1662:     for(i=0; i<pCheck->nExpr; i++){",
          "1663:       int allOk;",
          "1664:       Expr *pExpr = pCheck->a[i].pExpr;",
          "1665:       if( aiChng",
          "1666:        && !sqlite3ExprReferencesUpdatedColumn(pExpr, aiChng, pkChng)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1664:       Expr *pCopy;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1675:       }",
          "1676:       allOk = sqlite3VdbeMakeLabel(pParse);",
          "1677:       sqlite3VdbeVerifyAbortable(v, onError);",
          "1679:       if( onError==OE_Ignore ){",
          "1680:         sqlite3VdbeGoto(v, ignoreDest);",
          "1681:       }else{",
          "",
          "[Removed Lines]",
          "1678:       sqlite3ExprIfTrue(pParse, pExpr, allOk, SQLITE_JUMPIFNULL);",
          "",
          "[Added Lines]",
          "1679:       pCopy = sqlite3ExprDup(db, pExpr, 0);",
          "1680:       if( !db->mallocFailed ){",
          "1681:         sqlite3ExprIfTrue(pParse, pCopy, allOk, SQLITE_JUMPIFNULL);",
          "1682:       }",
          "1683:       sqlite3ExprDelete(db, pCopy);",
          "",
          "---------------"
        ],
        "src/parse.y||src/parse.y": [
          "File: src/parse.y -> src/parse.y",
          "--- Hunk 1 ---",
          "[Context before]",
          "965:       p->op = (u8)op;",
          "966:       p->affExpr = 0;",
          "967:       p->flags = EP_Leaf;",
          "968:       p->iAgg = -1;",
          "969:       p->pLeft = p->pRight = 0;",
          "970:       p->x.pList = 0;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "968:       ExprClearVVAProperties(p);",
          "",
          "---------------"
        ],
        "src/sqliteInt.h||src/sqliteInt.h": [
          "File: src/sqliteInt.h -> src/sqliteInt.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "2598:   union {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2597: #ifdef SQLITE_DEBUG",
          "2599: #endif",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2700: #define ExprAlwaysTrue(E)   (((E)->flags&(EP_FromJoin|EP_IsTrue))==EP_IsTrue)",
          "2701: #define ExprAlwaysFalse(E)  (((E)->flags&(EP_FromJoin|EP_IsFalse))==EP_IsFalse)",
          "2707: #ifdef SQLITE_DEBUG",
          "2709: #else",
          "2710: # define ExprSetVVAProperty(E,P)",
          "2711: #endif",
          "",
          "[Removed Lines]",
          "2708: # define ExprSetVVAProperty(E,P)  (E)->flags|=(P)",
          "",
          "[Added Lines]",
          "2718: # define ExprSetVVAProperty(E,P)   (E)->vvaFlags|=(P)",
          "2719: # define ExprHasVVAProperty(E,P)   (((E)->vvaFlags&(P))!=0)",
          "2720: # define ExprClearVVAProperties(E) (E)->vvaFlags = 0",
          "2723: # define ExprHasVVAProperty(E,P)   0",
          "2724: # define ExprClearVVAProperties(E)",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "4440: const char *sqlite3IndexAffinityStr(sqlite3*, Index*);",
          "4441: void sqlite3TableAffinity(Vdbe*, Table*, int);",
          "4444: char sqlite3TableColumnAffinity(Table*,int);",
          "4446: int sqlite3Atoi64(const char*, i64*, int, u8);",
          "4447: int sqlite3DecOrHexToI64(const char*, i64*);",
          "4448: void sqlite3ErrorWithMsg(sqlite3*, int, const char*,...);",
          "",
          "[Removed Lines]",
          "4442: char sqlite3CompareAffinity(Expr *pExpr, char aff2);",
          "4443: int sqlite3IndexAffinityOk(Expr *pExpr, char idx_affinity);",
          "4445: char sqlite3ExprAffinity(Expr *pExpr);",
          "",
          "[Added Lines]",
          "4456: char sqlite3CompareAffinity(const Expr *pExpr, char aff2);",
          "4457: int sqlite3IndexAffinityOk(const Expr *pExpr, char idx_affinity);",
          "4459: char sqlite3ExprAffinity(const Expr *pExpr);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "4466: int sqlite3IsBinary(const CollSeq*);",
          "4467: CollSeq *sqlite3LocateCollSeq(Parse *pParse, const char*zName);",
          "4468: void sqlite3SetTextEncoding(sqlite3 *db, u8);",
          "4472: Expr *sqlite3ExprAddCollateToken(Parse *pParse, Expr*, const Token*, int);",
          "4473: Expr *sqlite3ExprAddCollateString(Parse*,Expr*,const char*);",
          "4474: Expr *sqlite3ExprSkipCollate(Expr*);",
          "",
          "[Removed Lines]",
          "4469: CollSeq *sqlite3ExprCollSeq(Parse *pParse, Expr *pExpr);",
          "4470: CollSeq *sqlite3ExprNNCollSeq(Parse *pParse, Expr *pExpr);",
          "4471: int sqlite3ExprCollSeqMatch(Parse*,Expr*,Expr*);",
          "",
          "[Added Lines]",
          "4483: CollSeq *sqlite3ExprCollSeq(Parse *pParse, const Expr *pExpr);",
          "4484: CollSeq *sqlite3ExprNNCollSeq(Parse *pParse, const Expr *pExpr);",
          "4485: int sqlite3ExprCollSeqMatch(Parse*,const Expr*,const Expr*);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "4699: #endif",
          "4700: int sqlite3Reprepare(Vdbe*);",
          "4701: void sqlite3ExprListCheckLength(Parse*, ExprList*, const char*);",
          "4704: int sqlite3TempInMemory(const sqlite3*);",
          "4705: const char *sqlite3JournalModename(int);",
          "4706: #ifndef SQLITE_OMIT_WAL",
          "",
          "[Removed Lines]",
          "4702: CollSeq *sqlite3ExprCompareCollSeq(Parse*,Expr*);",
          "4703: CollSeq *sqlite3BinaryCompareCollSeq(Parse *, Expr *, Expr *);",
          "",
          "[Added Lines]",
          "4716: CollSeq *sqlite3ExprCompareCollSeq(Parse*,const Expr*);",
          "4717: CollSeq *sqlite3BinaryCompareCollSeq(Parse *, const Expr*, const Expr*);",
          "",
          "---------------"
        ],
        "src/treeview.c||src/treeview.c": [
          "File: src/treeview.c -> src/treeview.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "398: void sqlite3TreeViewExpr(TreeView *pView, const Expr *pExpr, u8 moreToFollow){",
          "402:   pView = sqlite3TreeViewPush(pView, moreToFollow);",
          "403:   if( pExpr==0 ){",
          "404:     sqlite3TreeViewLine(pView, \"nil\");",
          "405:     sqlite3TreeViewPop(pView);",
          "406:     return;",
          "407:   }",
          "409:     StrAccum x;",
          "410:     sqlite3StrAccumInit(&x, 0, zFlgs, sizeof(zFlgs), 0);",
          "411:     sqlite3_str_appendf(&x, \" fg.af=%x.%c\",",
          "",
          "[Removed Lines]",
          "401:   char zFlgs[60];",
          "408:   if( pExpr->flags || pExpr->affExpr ){",
          "",
          "[Added Lines]",
          "401:   char zFlgs[200];",
          "408:   if( pExpr->flags || pExpr->affExpr || pExpr->vvaFlags ){",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "416:     if( ExprHasProperty(pExpr, EP_FromDDL) ){",
          "417:       sqlite3_str_appendf(&x, \" DDL\");",
          "418:     }",
          "419:     sqlite3StrAccumFinish(&x);",
          "420:   }else{",
          "421:     zFlgs[0] = 0;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "419:     if( ExprHasVVAProperty(pExpr, EP_Immutable) ){",
          "420:       sqlite3_str_appendf(&x, \" IMMUTABLE\");",
          "421:     }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "522:     case TK_RSHIFT:  zBinOp = \"RSHIFT\"; break;",
          "523:     case TK_CONCAT:  zBinOp = \"CONCAT\"; break;",
          "524:     case TK_DOT:     zBinOp = \"DOT\";    break;",
          "526:     case TK_UMINUS:  zUniOp = \"UMINUS\"; break;",
          "527:     case TK_UPLUS:   zUniOp = \"UPLUS\";  break;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "528:     case TK_LIMIT:   zBinOp = \"LIMIT\";  break;",
          "",
          "---------------"
        ],
        "test/default.test||test/default.test": [
          "File: test/default.test -> test/default.test",
          "--- Hunk 1 ---",
          "[Context before]",
          "128:   CREATE TABLE t2(a TEXT, b TEXT DEFAULT(98+coalesce(5,:xyz)));",
          "129: } {1 {default value of column [b] is not constant}}",
          "131: finish_test",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "131: # 2020-03-09 out-of-bounds memory access discovered by \"Eternal Sakura\"",
          "132: # and reported to chromium.",
          "133: #",
          "134: reset_db",
          "135: do_catchsql_test default-5.1 {",
          "136:   CREATE TABLE t1 (a,b DEFAULT(random() NOTNULL IN (RAISE(IGNORE),2,3)));",
          "137:   INSERT INTO t1(a) VALUES(1);",
          "138: } {1 {RAISE() may only be used within a trigger-program}}",
          "",
          "---------------"
        ],
        "test/select3.test||test/select3.test": [
          "File: test/select3.test -> test/select3.test",
          "--- Hunk 1 ---",
          "[Context before]",
          "306:   } {{} 1.0 ok}",
          "307: }",
          "309: finish_test",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "309: # 2020-03-10 ticket e0c2ad1aa8a9c691",
          "310: reset_db",
          "311: do_execsql_test select3-9.100 {",
          "312:   CREATE TABLE t0(c0 REAL, c1 REAL GENERATED ALWAYS AS (c0));",
          "313:   INSERT INTO t0(c0) VALUES (1);",
          "314:   SELECT * FROM t0 GROUP BY c0;",
          "315: } {1.0 1.0}",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "4549a3b8cb6d776dc7023580ded18a8158dccc9e",
      "candidate_info": {
        "commit_hash": "4549a3b8cb6d776dc7023580ded18a8158dccc9e",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/4549a3b8cb6d776dc7023580ded18a8158dccc9e",
        "files": [
          "manifest",
          "manifest.uuid",
          "test/fuzzdata8.db"
        ],
        "message": "Improve a testcase in test/fuzzdata8.db to make it more resilient.\n\nFossilOrigin-Name: 139aefe60097e06b43df35652e6b2183b7a4b03341d1bde23deada3fa3358fee",
        "before_after_code_files": [
          "manifest.uuid||manifest.uuid"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: 61f873b14c2c835f3d10b018b357cb8b1f041e97e05709d7ab5a8055e5e05349",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "1a3220ace68c3889c875120120497d4c7b78e714",
      "candidate_info": {
        "commit_hash": "1a3220ace68c3889c875120120497d4c7b78e714",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/1a3220ace68c3889c875120120497d4c7b78e714",
        "files": [
          "manifest",
          "manifest.uuid"
        ],
        "message": "Version 3.31.0\n\nFossilOrigin-Name: f6affdd41608946fcfcea914ece149038a8b25a62bbe719ed2561c649b86d824",
        "before_after_code_files": [
          "manifest.uuid||manifest.uuid"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: 4daf94d83319231e42243625c804d5db2d14f10fa5ea1a1f358c3603c47b955b",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "e26d428a5900bb0cbfbb4e3857ff6343e7664cfe",
      "candidate_info": {
        "commit_hash": "e26d428a5900bb0cbfbb4e3857ff6343e7664cfe",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/e26d428a5900bb0cbfbb4e3857ff6343e7664cfe",
        "files": [
          "manifest",
          "manifest.uuid",
          "src/select.c",
          "src/sqliteInt.h",
          "src/treeview.c"
        ],
        "message": "Improved tree-view debugging output for aggregate functions.\n\nFossilOrigin-Name: b5711b4eead10ef4b0b61f2e2c54768d215a4105f6d47d2ea78991b6e53a6831",
        "before_after_code_files": [
          "manifest.uuid||manifest.uuid",
          "src/select.c||src/select.c",
          "src/sqliteInt.h||src/sqliteInt.h",
          "src/treeview.c||src/treeview.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: d48af4d2cfff3d5f4ccc3db5d658e8b503255b577e6e62b5c2b4a4437875b895",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/select.c||src/select.c": [
          "File: src/select.c -> src/select.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "6362:     }",
          "6363:     pAggInfo->pNext = pParse->pAggList;",
          "6364:     pParse->pAggList = pAggInfo;",
          "6365:     memset(&sNC, 0, sizeof(sNC));",
          "6366:     sNC.pParse = pParse;",
          "6367:     sNC.pSrcList = pTabList;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "6365:     pAggInfo->selId = p->selId;",
          "",
          "---------------"
        ],
        "src/sqliteInt.h||src/sqliteInt.h": [
          "File: src/sqliteInt.h -> src/sqliteInt.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "2524:   } *aFunc;",
          "2530: };",
          "",
          "[Removed Lines]",
          "2526: #ifdef SQLITE_DEBUG",
          "2528: #endif",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/treeview.c||src/treeview.c": [
          "File: src/treeview.c -> src/treeview.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "582: #endif",
          "583:       }",
          "584:       if( pExpr->op==TK_AGG_FUNCTION ){",
          "586:                              pExpr->op2, pExpr->u.zToken, zFlgs,",
          "587:                              pExpr->iAgg, pExpr->pAggInfo);",
          "588:       }else if( pExpr->op2!=0 ){",
          "589:         const char *zOp2;",
          "",
          "[Removed Lines]",
          "585:         sqlite3TreeViewLine(pView, \"AGG_FUNCTION%d %Q%s iAgg=%d agg=%p\",",
          "",
          "[Added Lines]",
          "585:         sqlite3TreeViewLine(pView, \"AGG_FUNCTION%d %Q%s agg=%d[%d]/%p\",",
          "587:                              pExpr->pAggInfo ? pExpr->pAggInfo->selId : 0,",
          "",
          "---------------"
        ]
      }
    }
  ]
}
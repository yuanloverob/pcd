{
  "cve_id": "CVE-2015-8955",
  "cve_desc": "arch/arm64/kernel/perf_event.c in the Linux kernel before 4.1 on arm64 platforms allows local users to gain privileges or cause a denial of service (invalid pointer dereference) via vectors involving events that are mishandled during a span of multiple HW PMUs.",
  "repo": "torvalds/linux",
  "patch_hash": "8fff105e13041e49b82f92eef034f363a6b1c071",
  "patch_info": {
    "commit_hash": "8fff105e13041e49b82f92eef034f363a6b1c071",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/8fff105e13041e49b82f92eef034f363a6b1c071",
    "files": [
      "arch/arm64/kernel/perf_event.c"
    ],
    "message": "arm64: perf: reject groups spanning multiple HW PMUs\n\nThe perf core implicitly rejects events spanning multiple HW PMUs, as in\nthese cases the event->ctx will differ. However this validation is\nperformed after pmu::event_init() is called in perf_init_event(), and\nthus pmu::event_init() may be called with a group leader from a\ndifferent HW PMU.\n\nThe ARM64 PMU driver does not take this fact into account, and when\nvalidating groups assumes that it can call to_arm_pmu(event->pmu) for\nany HW event. When the event in question is from another HW PMU this is\nwrong, and results in dereferencing garbage.\n\nThis patch updates the ARM64 PMU driver to first test for and reject\nevents from other PMUs, moving the to_arm_pmu and related logic after\nthis test. Fixes a crash triggered by perf_fuzzer on Linux-4.0-rc2, with\na CCI PMU present:\n\nBad mode in Synchronous Abort handler detected, code 0x86000006 -- IABT (current EL)\nCPU: 0 PID: 1371 Comm: perf_fuzzer Not tainted 3.19.0+ #249\nHardware name: V2F-1XV7 Cortex-A53x2 SMM (DT)\ntask: ffffffc07c73a280 ti: ffffffc07b0a0000 task.ti: ffffffc07b0a0000\nPC is at 0x0\nLR is at validate_event+0x90/0xa8\npc : [<0000000000000000>] lr : [<ffffffc000090228>] pstate: 00000145\nsp : ffffffc07b0a3ba0\n\n[<          (null)>]           (null)\n[<ffffffc0000907d8>] armpmu_event_init+0x174/0x3cc\n[<ffffffc00015d870>] perf_try_init_event+0x34/0x70\n[<ffffffc000164094>] perf_init_event+0xe0/0x10c\n[<ffffffc000164348>] perf_event_alloc+0x288/0x358\n[<ffffffc000164c5c>] SyS_perf_event_open+0x464/0x98c\nCode: bad PC value\n\nAlso cleans up the code to use the arm_pmu only when we know\nthat we are dealing with an arm pmu event.\n\nCc: Will Deacon <will.deacon@arm.com>\nAcked-by: Mark Rutland <mark.rutland@arm.com>\nAcked-by: Peter Ziljstra (Intel) <peterz@infradead.org>\nSigned-off-by: Suzuki K. Poulose <suzuki.poulose@arm.com>\nSigned-off-by: Will Deacon <will.deacon@arm.com>",
    "before_after_code_files": [
      "arch/arm64/kernel/perf_event.c||arch/arm64/kernel/perf_event.c"
    ]
  },
  "patch_diff": {
    "arch/arm64/kernel/perf_event.c||arch/arm64/kernel/perf_event.c": [
      "File: arch/arm64/kernel/perf_event.c -> arch/arm64/kernel/perf_event.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "322: }",
      "324: static int",
      "327: {",
      "329:  struct hw_perf_event fake_event = event->hw;",
      "330:  struct pmu *leader_pmu = event->group_leader->pmu;",
      "332:  if (is_software_event(event))",
      "333:   return 1;",
      "335:  if (event->pmu != leader_pmu || event->state < PERF_EVENT_STATE_OFF)",
      "336:   return 1;",
      "338:  if (event->state == PERF_EVENT_STATE_OFF && !event->attr.enable_on_exec)",
      "339:   return 1;",
      "341:  return armpmu->get_event_idx(hw_events, &fake_event) >= 0;",
      "342: }",
      "",
      "[Removed Lines]",
      "325: validate_event(struct pmu_hw_events *hw_events,",
      "326:         struct perf_event *event)",
      "328:  struct arm_pmu *armpmu = to_arm_pmu(event->pmu);",
      "",
      "[Added Lines]",
      "325: validate_event(struct pmu *pmu, struct pmu_hw_events *hw_events,",
      "326:     struct perf_event *event)",
      "328:  struct arm_pmu *armpmu;",
      "340:  if (event->pmu != pmu)",
      "341:   return 0;",
      "349:  armpmu = to_arm_pmu(event->pmu);",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "355:  memset(fake_used_mask, 0, sizeof(fake_used_mask));",
      "356:  fake_pmu.used_mask = fake_used_mask;",
      "359:   return -EINVAL;",
      "361:  list_for_each_entry(sibling, &leader->sibling_list, group_entry) {",
      "363:    return -EINVAL;",
      "364:  }",
      "367:   return -EINVAL;",
      "369:  return 0;",
      "",
      "[Removed Lines]",
      "358:  if (!validate_event(&fake_pmu, leader))",
      "362:   if (!validate_event(&fake_pmu, sibling))",
      "366:  if (!validate_event(&fake_pmu, event))",
      "",
      "[Added Lines]",
      "367:  if (!validate_event(event->pmu, &fake_pmu, leader))",
      "371:   if (!validate_event(event->pmu, &fake_pmu, sibling))",
      "375:  if (!validate_event(event->pmu, &fake_pmu, event))",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "6475b2d846176e3272351266869481a21ff47866",
      "candidate_info": {
        "commit_hash": "6475b2d846176e3272351266869481a21ff47866",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/6475b2d846176e3272351266869481a21ff47866",
        "files": [
          "arch/arm64/Kconfig",
          "arch/arm64/include/asm/pmu.h",
          "arch/arm64/kernel/perf_event.c",
          "drivers/perf/Kconfig"
        ],
        "message": "arm64: perf: move to shared arm_pmu framework\n\nNow that the arm_pmu framework has been factored out to drivers/perf we\ncan make use of it for arm64, gaining support for heterogeneous PMUs\nand unifying the two codebases before they diverge further.\n\nThe as yet unused PMU name for PMUv3 is changed to armv8_pmuv3, matching\nthe style previously applied to the 32-bit PMUs.\n\nSigned-off-by: Mark Rutland <mark.rutland@arm.com>\nAcked-by: Will Deacon <will.deacon@arm.com>\nSigned-off-by: Catalin Marinas <catalin.marinas@arm.com>",
        "before_after_code_files": [
          "arch/arm64/include/asm/pmu.h||arch/arm64/include/asm/pmu.h",
          "arch/arm64/kernel/perf_event.c||arch/arm64/kernel/perf_event.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "arch/arm64/kernel/perf_event.c||arch/arm64/kernel/perf_event.c"
          ],
          "candidate": [
            "arch/arm64/kernel/perf_event.c||arch/arm64/kernel/perf_event.c"
          ]
        }
      },
      "candidate_diff": {
        "arch/arm64/include/asm/pmu.h||arch/arm64/include/asm/pmu.h": [
          "File: arch/arm64/include/asm/pmu.h -> arch/arm64/include/asm/pmu.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "arch/arm64/kernel/perf_event.c||arch/arm64/kernel/perf_event.c": [
          "File: arch/arm64/kernel/perf_event.c -> arch/arm64/kernel/perf_event.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "37: #include <asm/irq_regs.h>",
          "",
          "[Removed Lines]",
          "21: #define pr_fmt(fmt) \"hw perfevents: \" fmt",
          "23: #include <linux/bitmap.h>",
          "24: #include <linux/interrupt.h>",
          "25: #include <linux/irq.h>",
          "26: #include <linux/kernel.h>",
          "27: #include <linux/export.h>",
          "28: #include <linux/of_device.h>",
          "29: #include <linux/perf_event.h>",
          "30: #include <linux/platform_device.h>",
          "31: #include <linux/slab.h>",
          "32: #include <linux/spinlock.h>",
          "33: #include <linux/uaccess.h>",
          "35: #include <asm/cputype.h>",
          "36: #include <asm/irq.h>",
          "38: #include <asm/pmu.h>",
          "44: #define ARMPMU_MAX_HWEVENTS  32",
          "46: static DEFINE_PER_CPU(struct perf_event * [ARMPMU_MAX_HWEVENTS], hw_events);",
          "47: static DEFINE_PER_CPU(unsigned long [BITS_TO_LONGS(ARMPMU_MAX_HWEVENTS)], used_mask);",
          "48: static DEFINE_PER_CPU(struct pmu_hw_events, cpu_hw_events);",
          "50: #define to_arm_pmu(p) (container_of(p, struct arm_pmu, pmu))",
          "53: static struct arm_pmu *cpu_pmu;",
          "55: int",
          "56: armpmu_get_max_events(void)",
          "57: {",
          "58:  int max_events = 0;",
          "60:  if (cpu_pmu != NULL)",
          "61:   max_events = cpu_pmu->num_events;",
          "63:  return max_events;",
          "64: }",
          "65: EXPORT_SYMBOL_GPL(armpmu_get_max_events);",
          "67: int perf_num_counters(void)",
          "68: {",
          "69:  return armpmu_get_max_events();",
          "70: }",
          "71: EXPORT_SYMBOL_GPL(perf_num_counters);",
          "73: #define HW_OP_UNSUPPORTED  0xFFFF",
          "75: #define C(_x) \\",
          "76:  PERF_COUNT_HW_CACHE_##_x",
          "78: #define CACHE_OP_UNSUPPORTED  0xFFFF",
          "80: #define PERF_MAP_ALL_UNSUPPORTED     \\",
          "81:  [0 ... PERF_COUNT_HW_MAX - 1] = HW_OP_UNSUPPORTED",
          "83: #define PERF_CACHE_MAP_ALL_UNSUPPORTED     \\",
          "84: [0 ... C(MAX) - 1] = {       \\",
          "85:  [0 ... C(OP_MAX) - 1] = {     \\",
          "86:   [0 ... C(RESULT_MAX) - 1] = CACHE_OP_UNSUPPORTED, \\",
          "87:  },        \\",
          "88: }",
          "90: static int",
          "91: armpmu_map_cache_event(const unsigned (*cache_map)",
          "92:           [PERF_COUNT_HW_CACHE_MAX]",
          "93:           [PERF_COUNT_HW_CACHE_OP_MAX]",
          "94:           [PERF_COUNT_HW_CACHE_RESULT_MAX],",
          "95:          u64 config)",
          "96: {",
          "97:  unsigned int cache_type, cache_op, cache_result, ret;",
          "99:  cache_type = (config >>  0) & 0xff;",
          "100:  if (cache_type >= PERF_COUNT_HW_CACHE_MAX)",
          "101:   return -EINVAL;",
          "103:  cache_op = (config >>  8) & 0xff;",
          "104:  if (cache_op >= PERF_COUNT_HW_CACHE_OP_MAX)",
          "105:   return -EINVAL;",
          "107:  cache_result = (config >> 16) & 0xff;",
          "108:  if (cache_result >= PERF_COUNT_HW_CACHE_RESULT_MAX)",
          "109:   return -EINVAL;",
          "111:  ret = (int)(*cache_map)[cache_type][cache_op][cache_result];",
          "113:  if (ret == CACHE_OP_UNSUPPORTED)",
          "114:   return -ENOENT;",
          "116:  return ret;",
          "117: }",
          "119: static int",
          "120: armpmu_map_event(const unsigned (*event_map)[PERF_COUNT_HW_MAX], u64 config)",
          "121: {",
          "122:  int mapping;",
          "124:  if (config >= PERF_COUNT_HW_MAX)",
          "125:   return -EINVAL;",
          "127:  mapping = (*event_map)[config];",
          "128:  return mapping == HW_OP_UNSUPPORTED ? -ENOENT : mapping;",
          "129: }",
          "131: static int",
          "132: armpmu_map_raw_event(u32 raw_event_mask, u64 config)",
          "133: {",
          "134:  return (int)(config & raw_event_mask);",
          "135: }",
          "137: static int map_cpu_event(struct perf_event *event,",
          "138:     const unsigned (*event_map)[PERF_COUNT_HW_MAX],",
          "139:     const unsigned (*cache_map)",
          "140:      [PERF_COUNT_HW_CACHE_MAX]",
          "141:      [PERF_COUNT_HW_CACHE_OP_MAX]",
          "142:      [PERF_COUNT_HW_CACHE_RESULT_MAX],",
          "143:     u32 raw_event_mask)",
          "144: {",
          "145:  u64 config = event->attr.config;",
          "147:  switch (event->attr.type) {",
          "148:  case PERF_TYPE_HARDWARE:",
          "149:   return armpmu_map_event(event_map, config);",
          "150:  case PERF_TYPE_HW_CACHE:",
          "151:   return armpmu_map_cache_event(cache_map, config);",
          "152:  case PERF_TYPE_RAW:",
          "153:   return armpmu_map_raw_event(raw_event_mask, config);",
          "154:  }",
          "156:  return -ENOENT;",
          "157: }",
          "159: int",
          "160: armpmu_event_set_period(struct perf_event *event,",
          "161:    struct hw_perf_event *hwc,",
          "162:    int idx)",
          "163: {",
          "164:  struct arm_pmu *armpmu = to_arm_pmu(event->pmu);",
          "165:  s64 left = local64_read(&hwc->period_left);",
          "166:  s64 period = hwc->sample_period;",
          "167:  int ret = 0;",
          "169:  if (unlikely(left <= -period)) {",
          "170:   left = period;",
          "171:   local64_set(&hwc->period_left, left);",
          "172:   hwc->last_period = period;",
          "173:   ret = 1;",
          "174:  }",
          "176:  if (unlikely(left <= 0)) {",
          "177:   left += period;",
          "178:   local64_set(&hwc->period_left, left);",
          "179:   hwc->last_period = period;",
          "180:   ret = 1;",
          "181:  }",
          "189:  if (left > (armpmu->max_period >> 1))",
          "190:   left = armpmu->max_period >> 1;",
          "192:  local64_set(&hwc->prev_count, (u64)-left);",
          "194:  armpmu->write_counter(idx, (u64)(-left) & 0xffffffff);",
          "196:  perf_event_update_userpage(event);",
          "198:  return ret;",
          "199: }",
          "201: u64",
          "202: armpmu_event_update(struct perf_event *event,",
          "203:       struct hw_perf_event *hwc,",
          "204:       int idx)",
          "205: {",
          "206:  struct arm_pmu *armpmu = to_arm_pmu(event->pmu);",
          "207:  u64 delta, prev_raw_count, new_raw_count;",
          "209: again:",
          "210:  prev_raw_count = local64_read(&hwc->prev_count);",
          "211:  new_raw_count = armpmu->read_counter(idx);",
          "213:  if (local64_cmpxchg(&hwc->prev_count, prev_raw_count,",
          "214:         new_raw_count) != prev_raw_count)",
          "215:   goto again;",
          "217:  delta = (new_raw_count - prev_raw_count) & armpmu->max_period;",
          "219:  local64_add(delta, &event->count);",
          "220:  local64_sub(delta, &hwc->period_left);",
          "222:  return new_raw_count;",
          "223: }",
          "225: static void",
          "226: armpmu_read(struct perf_event *event)",
          "227: {",
          "228:  struct hw_perf_event *hwc = &event->hw;",
          "231:  if (hwc->idx < 0)",
          "232:   return;",
          "234:  armpmu_event_update(event, hwc, hwc->idx);",
          "235: }",
          "237: static void",
          "238: armpmu_stop(struct perf_event *event, int flags)",
          "239: {",
          "240:  struct arm_pmu *armpmu = to_arm_pmu(event->pmu);",
          "241:  struct hw_perf_event *hwc = &event->hw;",
          "247:  if (!(hwc->state & PERF_HES_STOPPED)) {",
          "248:   armpmu->disable(hwc, hwc->idx);",
          "250:   armpmu_event_update(event, hwc, hwc->idx);",
          "251:   hwc->state |= PERF_HES_STOPPED | PERF_HES_UPTODATE;",
          "252:  }",
          "253: }",
          "255: static void",
          "256: armpmu_start(struct perf_event *event, int flags)",
          "257: {",
          "258:  struct arm_pmu *armpmu = to_arm_pmu(event->pmu);",
          "259:  struct hw_perf_event *hwc = &event->hw;",
          "265:  if (flags & PERF_EF_RELOAD)",
          "266:   WARN_ON_ONCE(!(hwc->state & PERF_HES_UPTODATE));",
          "268:  hwc->state = 0;",
          "276:  armpmu_event_set_period(event, hwc, hwc->idx);",
          "277:  armpmu->enable(hwc, hwc->idx);",
          "278: }",
          "280: static void",
          "281: armpmu_del(struct perf_event *event, int flags)",
          "282: {",
          "283:  struct arm_pmu *armpmu = to_arm_pmu(event->pmu);",
          "284:  struct pmu_hw_events *hw_events = armpmu->get_hw_events();",
          "285:  struct hw_perf_event *hwc = &event->hw;",
          "286:  int idx = hwc->idx;",
          "288:  WARN_ON(idx < 0);",
          "290:  armpmu_stop(event, PERF_EF_UPDATE);",
          "291:  hw_events->events[idx] = NULL;",
          "292:  clear_bit(idx, hw_events->used_mask);",
          "294:  perf_event_update_userpage(event);",
          "295: }",
          "297: static int",
          "298: armpmu_add(struct perf_event *event, int flags)",
          "299: {",
          "300:  struct arm_pmu *armpmu = to_arm_pmu(event->pmu);",
          "301:  struct pmu_hw_events *hw_events = armpmu->get_hw_events();",
          "302:  struct hw_perf_event *hwc = &event->hw;",
          "303:  int idx;",
          "304:  int err = 0;",
          "306:  perf_pmu_disable(event->pmu);",
          "309:  idx = armpmu->get_event_idx(hw_events, hwc);",
          "310:  if (idx < 0) {",
          "311:   err = idx;",
          "312:   goto out;",
          "313:  }",
          "319:  event->hw.idx = idx;",
          "320:  armpmu->disable(hwc, idx);",
          "321:  hw_events->events[idx] = event;",
          "323:  hwc->state = PERF_HES_STOPPED | PERF_HES_UPTODATE;",
          "324:  if (flags & PERF_EF_START)",
          "325:   armpmu_start(event, PERF_EF_RELOAD);",
          "328:  perf_event_update_userpage(event);",
          "330: out:",
          "331:  perf_pmu_enable(event->pmu);",
          "332:  return err;",
          "333: }",
          "335: static int",
          "336: validate_event(struct pmu *pmu, struct pmu_hw_events *hw_events,",
          "337:     struct perf_event *event)",
          "338: {",
          "339:  struct arm_pmu *armpmu;",
          "340:  struct hw_perf_event fake_event = event->hw;",
          "341:  struct pmu *leader_pmu = event->group_leader->pmu;",
          "343:  if (is_software_event(event))",
          "344:   return 1;",
          "351:  if (event->pmu != pmu)",
          "352:   return 0;",
          "354:  if (event->pmu != leader_pmu || event->state < PERF_EVENT_STATE_OFF)",
          "355:   return 1;",
          "357:  if (event->state == PERF_EVENT_STATE_OFF && !event->attr.enable_on_exec)",
          "358:   return 1;",
          "360:  armpmu = to_arm_pmu(event->pmu);",
          "361:  return armpmu->get_event_idx(hw_events, &fake_event) >= 0;",
          "362: }",
          "364: static int",
          "365: validate_group(struct perf_event *event)",
          "366: {",
          "367:  struct perf_event *sibling, *leader = event->group_leader;",
          "368:  struct pmu_hw_events fake_pmu;",
          "369:  DECLARE_BITMAP(fake_used_mask, ARMPMU_MAX_HWEVENTS);",
          "375:  memset(fake_used_mask, 0, sizeof(fake_used_mask));",
          "376:  fake_pmu.used_mask = fake_used_mask;",
          "378:  if (!validate_event(event->pmu, &fake_pmu, leader))",
          "379:   return -EINVAL;",
          "381:  list_for_each_entry(sibling, &leader->sibling_list, group_entry) {",
          "382:   if (!validate_event(event->pmu, &fake_pmu, sibling))",
          "383:    return -EINVAL;",
          "384:  }",
          "386:  if (!validate_event(event->pmu, &fake_pmu, event))",
          "387:   return -EINVAL;",
          "389:  return 0;",
          "390: }",
          "392: static void",
          "393: armpmu_disable_percpu_irq(void *data)",
          "394: {",
          "395:  unsigned int irq = *(unsigned int *)data;",
          "396:  disable_percpu_irq(irq);",
          "397: }",
          "399: static void",
          "400: armpmu_release_hardware(struct arm_pmu *armpmu)",
          "401: {",
          "402:  int irq;",
          "403:  unsigned int i, irqs;",
          "404:  struct platform_device *pmu_device = armpmu->plat_device;",
          "406:  irqs = min(pmu_device->num_resources, num_possible_cpus());",
          "407:  if (!irqs)",
          "408:   return;",
          "410:  irq = platform_get_irq(pmu_device, 0);",
          "411:  if (irq <= 0)",
          "412:   return;",
          "414:  if (irq_is_percpu(irq)) {",
          "415:   on_each_cpu(armpmu_disable_percpu_irq, &irq, 1);",
          "416:   free_percpu_irq(irq, &cpu_hw_events);",
          "417:  } else {",
          "418:   for (i = 0; i < irqs; ++i) {",
          "419:    int cpu = i;",
          "421:    if (armpmu->irq_affinity)",
          "422:     cpu = armpmu->irq_affinity[i];",
          "424:    if (!cpumask_test_and_clear_cpu(cpu, &armpmu->active_irqs))",
          "425:     continue;",
          "426:    irq = platform_get_irq(pmu_device, i);",
          "427:    if (irq > 0)",
          "428:     free_irq(irq, armpmu);",
          "429:   }",
          "430:  }",
          "431: }",
          "433: static void",
          "434: armpmu_enable_percpu_irq(void *data)",
          "435: {",
          "436:  unsigned int irq = *(unsigned int *)data;",
          "437:  enable_percpu_irq(irq, IRQ_TYPE_NONE);",
          "438: }",
          "440: static int",
          "441: armpmu_reserve_hardware(struct arm_pmu *armpmu)",
          "442: {",
          "443:  int err, irq;",
          "444:  unsigned int i, irqs;",
          "445:  struct platform_device *pmu_device = armpmu->plat_device;",
          "447:  if (!pmu_device)",
          "448:   return -ENODEV;",
          "450:  irqs = min(pmu_device->num_resources, num_possible_cpus());",
          "451:  if (!irqs) {",
          "452:   pr_err(\"no irqs for PMUs defined\\n\");",
          "453:   return -ENODEV;",
          "454:  }",
          "456:  irq = platform_get_irq(pmu_device, 0);",
          "457:  if (irq <= 0) {",
          "458:   pr_err(\"failed to get valid irq for PMU device\\n\");",
          "459:   return -ENODEV;",
          "460:  }",
          "462:  if (irq_is_percpu(irq)) {",
          "463:   err = request_percpu_irq(irq, armpmu->handle_irq,",
          "464:     \"arm-pmu\", &cpu_hw_events);",
          "466:   if (err) {",
          "467:    pr_err(\"unable to request percpu IRQ%d for ARM PMU counters\\n\",",
          "468:      irq);",
          "469:    armpmu_release_hardware(armpmu);",
          "470:    return err;",
          "471:   }",
          "473:   on_each_cpu(armpmu_enable_percpu_irq, &irq, 1);",
          "474:  } else {",
          "475:   for (i = 0; i < irqs; ++i) {",
          "476:    int cpu = i;",
          "478:    err = 0;",
          "479:    irq = platform_get_irq(pmu_device, i);",
          "480:    if (irq <= 0)",
          "481:     continue;",
          "483:    if (armpmu->irq_affinity)",
          "484:     cpu = armpmu->irq_affinity[i];",
          "491:    if (irq_set_affinity(irq, cpumask_of(cpu)) && irqs > 1) {",
          "492:     pr_warning(\"unable to set irq affinity (irq=%d, cpu=%u)\\n\",",
          "493:       irq, cpu);",
          "494:     continue;",
          "495:    }",
          "497:    err = request_irq(irq, armpmu->handle_irq,",
          "498:      IRQF_NOBALANCING | IRQF_NO_THREAD,",
          "499:      \"arm-pmu\", armpmu);",
          "500:    if (err) {",
          "501:     pr_err(\"unable to request IRQ%d for ARM PMU counters\\n\",",
          "502:       irq);",
          "503:     armpmu_release_hardware(armpmu);",
          "504:     return err;",
          "505:    }",
          "507:    cpumask_set_cpu(cpu, &armpmu->active_irqs);",
          "508:   }",
          "509:  }",
          "511:  return 0;",
          "512: }",
          "514: static void",
          "515: hw_perf_event_destroy(struct perf_event *event)",
          "516: {",
          "517:  struct arm_pmu *armpmu = to_arm_pmu(event->pmu);",
          "518:  atomic_t *active_events  = &armpmu->active_events;",
          "519:  struct mutex *pmu_reserve_mutex = &armpmu->reserve_mutex;",
          "521:  if (atomic_dec_and_mutex_lock(active_events, pmu_reserve_mutex)) {",
          "522:   armpmu_release_hardware(armpmu);",
          "523:   mutex_unlock(pmu_reserve_mutex);",
          "524:  }",
          "525: }",
          "527: static int",
          "528: event_requires_mode_exclusion(struct perf_event_attr *attr)",
          "529: {",
          "530:  return attr->exclude_idle || attr->exclude_user ||",
          "531:         attr->exclude_kernel || attr->exclude_hv;",
          "532: }",
          "534: static int",
          "535: __hw_perf_event_init(struct perf_event *event)",
          "536: {",
          "537:  struct arm_pmu *armpmu = to_arm_pmu(event->pmu);",
          "538:  struct hw_perf_event *hwc = &event->hw;",
          "539:  int mapping, err;",
          "541:  mapping = armpmu->map_event(event);",
          "543:  if (mapping < 0) {",
          "544:   pr_debug(\"event %x:%llx not supported\\n\", event->attr.type,",
          "545:     event->attr.config);",
          "546:   return mapping;",
          "547:  }",
          "555:  hwc->idx  = -1;",
          "556:  hwc->config_base = 0;",
          "557:  hwc->config  = 0;",
          "558:  hwc->event_base  = 0;",
          "563:  if ((!armpmu->set_event_filter ||",
          "564:       armpmu->set_event_filter(hwc, &event->attr)) &&",
          "565:       event_requires_mode_exclusion(&event->attr)) {",
          "566:   pr_debug(\"ARM performance counters do not support mode exclusion\\n\");",
          "567:   return -EPERM;",
          "568:  }",
          "573:  hwc->config_base     |= (unsigned long)mapping;",
          "575:  if (!hwc->sample_period) {",
          "582:   hwc->sample_period  = armpmu->max_period >> 1;",
          "583:   hwc->last_period    = hwc->sample_period;",
          "584:   local64_set(&hwc->period_left, hwc->sample_period);",
          "585:  }",
          "587:  err = 0;",
          "588:  if (event->group_leader != event) {",
          "589:   err = validate_group(event);",
          "590:   if (err)",
          "591:    return -EINVAL;",
          "592:  }",
          "594:  return err;",
          "595: }",
          "597: static int armpmu_event_init(struct perf_event *event)",
          "598: {",
          "599:  struct arm_pmu *armpmu = to_arm_pmu(event->pmu);",
          "600:  int err = 0;",
          "601:  atomic_t *active_events = &armpmu->active_events;",
          "603:  if (armpmu->map_event(event) == -ENOENT)",
          "604:   return -ENOENT;",
          "606:  event->destroy = hw_perf_event_destroy;",
          "608:  if (!atomic_inc_not_zero(active_events)) {",
          "609:   mutex_lock(&armpmu->reserve_mutex);",
          "610:   if (atomic_read(active_events) == 0)",
          "611:    err = armpmu_reserve_hardware(armpmu);",
          "613:   if (!err)",
          "614:    atomic_inc(active_events);",
          "615:   mutex_unlock(&armpmu->reserve_mutex);",
          "616:  }",
          "618:  if (err)",
          "619:   return err;",
          "621:  err = __hw_perf_event_init(event);",
          "622:  if (err)",
          "623:   hw_perf_event_destroy(event);",
          "625:  return err;",
          "626: }",
          "628: static void armpmu_enable(struct pmu *pmu)",
          "629: {",
          "630:  struct arm_pmu *armpmu = to_arm_pmu(pmu);",
          "631:  struct pmu_hw_events *hw_events = armpmu->get_hw_events();",
          "632:  int enabled = bitmap_weight(hw_events->used_mask, armpmu->num_events);",
          "634:  if (enabled)",
          "635:   armpmu->start();",
          "636: }",
          "638: static void armpmu_disable(struct pmu *pmu)",
          "639: {",
          "640:  struct arm_pmu *armpmu = to_arm_pmu(pmu);",
          "641:  armpmu->stop();",
          "642: }",
          "644: static void __init armpmu_init(struct arm_pmu *armpmu)",
          "645: {",
          "646:  atomic_set(&armpmu->active_events, 0);",
          "647:  mutex_init(&armpmu->reserve_mutex);",
          "649:  armpmu->pmu = (struct pmu) {",
          "650:   .pmu_enable = armpmu_enable,",
          "651:   .pmu_disable = armpmu_disable,",
          "652:   .event_init = armpmu_event_init,",
          "653:   .add  = armpmu_add,",
          "654:   .del  = armpmu_del,",
          "655:   .start  = armpmu_start,",
          "656:   .stop  = armpmu_stop,",
          "657:   .read  = armpmu_read,",
          "658:  };",
          "659: }",
          "661: int __init armpmu_register(struct arm_pmu *armpmu, char *name, int type)",
          "662: {",
          "663:  armpmu_init(armpmu);",
          "664:  return perf_pmu_register(&armpmu->pmu, name, type);",
          "665: }",
          "",
          "[Added Lines]",
          "24: #include <linux/of.h>",
          "25: #include <linux/perf/arm_pmu.h>",
          "26: #include <linux/platform_device.h>",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "740: #define ARMV8_IDX_CYCLE_COUNTER 0",
          "741: #define ARMV8_IDX_COUNTER0 1",
          "744: #define ARMV8_MAX_COUNTERS 32",
          "745: #define ARMV8_COUNTER_MASK (ARMV8_MAX_COUNTERS - 1)",
          "",
          "[Removed Lines]",
          "742: #define ARMV8_IDX_COUNTER_LAST (ARMV8_IDX_CYCLE_COUNTER + cpu_pmu->num_events - 1)",
          "",
          "[Added Lines]",
          "103: #define ARMV8_IDX_COUNTER_LAST(cpu_pmu) \\",
          "104:  (ARMV8_IDX_CYCLE_COUNTER + cpu_pmu->num_events - 1)",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "805:  return pmovsr & ARMV8_OVERFLOWED_MASK;",
          "806: }",
          "809: {",
          "811: }",
          "813: static inline int armv8pmu_counter_has_overflowed(u32 pmnc, int idx)",
          "814: {",
          "827: }",
          "829: static inline int armv8pmu_select_counter(int idx)",
          "830: {",
          "840:  asm volatile(\"msr pmselr_el0, %0\" :: \"r\" (counter));",
          "841:  isb();",
          "843:  return idx;",
          "844: }",
          "847: {",
          "848:  u32 value = 0;",
          "851:   pr_err(\"CPU%u reading wrong counter %d\\n\",",
          "852:    smp_processor_id(), idx);",
          "853:  else if (idx == ARMV8_IDX_CYCLE_COUNTER)",
          "",
          "[Removed Lines]",
          "808: static inline int armv8pmu_counter_valid(int idx)",
          "810:  return idx >= ARMV8_IDX_CYCLE_COUNTER && idx <= ARMV8_IDX_COUNTER_LAST;",
          "815:  int ret = 0;",
          "816:  u32 counter;",
          "818:  if (!armv8pmu_counter_valid(idx)) {",
          "819:   pr_err(\"CPU%u checking wrong counter %d overflow status\\n\",",
          "820:    smp_processor_id(), idx);",
          "821:  } else {",
          "822:   counter = ARMV8_IDX_TO_COUNTER(idx);",
          "823:   ret = pmnc & BIT(counter);",
          "824:  }",
          "826:  return ret;",
          "831:  u32 counter;",
          "833:  if (!armv8pmu_counter_valid(idx)) {",
          "834:   pr_err(\"CPU%u selecting wrong PMNC counter %d\\n\",",
          "835:    smp_processor_id(), idx);",
          "836:   return -EINVAL;",
          "837:  }",
          "839:  counter = ARMV8_IDX_TO_COUNTER(idx);",
          "846: static inline u32 armv8pmu_read_counter(int idx)",
          "850:  if (!armv8pmu_counter_valid(idx))",
          "",
          "[Added Lines]",
          "170: static inline int armv8pmu_counter_valid(struct arm_pmu *cpu_pmu, int idx)",
          "172:  return idx >= ARMV8_IDX_CYCLE_COUNTER &&",
          "173:   idx <= ARMV8_IDX_COUNTER_LAST(cpu_pmu);",
          "178:  return pmnc & BIT(ARMV8_IDX_TO_COUNTER(idx));",
          "183:  u32 counter = ARMV8_IDX_TO_COUNTER(idx);",
          "190: static inline u32 armv8pmu_read_counter(struct perf_event *event)",
          "192:  struct arm_pmu *cpu_pmu = to_arm_pmu(event->pmu);",
          "193:  struct hw_perf_event *hwc = &event->hw;",
          "194:  int idx = hwc->idx;",
          "197:  if (!armv8pmu_counter_valid(cpu_pmu, idx))",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "858:  return value;",
          "859: }",
          "862: {",
          "864:   pr_err(\"CPU%u writing wrong counter %d\\n\",",
          "865:    smp_processor_id(), idx);",
          "866:  else if (idx == ARMV8_IDX_CYCLE_COUNTER)",
          "",
          "[Removed Lines]",
          "861: static inline void armv8pmu_write_counter(int idx, u32 value)",
          "863:  if (!armv8pmu_counter_valid(idx))",
          "",
          "[Added Lines]",
          "208: static inline void armv8pmu_write_counter(struct perf_event *event, u32 value)",
          "210:  struct arm_pmu *cpu_pmu = to_arm_pmu(event->pmu);",
          "211:  struct hw_perf_event *hwc = &event->hw;",
          "212:  int idx = hwc->idx;",
          "214:  if (!armv8pmu_counter_valid(cpu_pmu, idx))",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "880: static inline int armv8pmu_enable_counter(int idx)",
          "881: {",
          "891:  asm volatile(\"msr pmcntenset_el0, %0\" :: \"r\" (BIT(counter)));",
          "892:  return idx;",
          "893: }",
          "895: static inline int armv8pmu_disable_counter(int idx)",
          "896: {",
          "906:  asm volatile(\"msr pmcntenclr_el0, %0\" :: \"r\" (BIT(counter)));",
          "907:  return idx;",
          "908: }",
          "910: static inline int armv8pmu_enable_intens(int idx)",
          "911: {",
          "921:  asm volatile(\"msr pmintenset_el1, %0\" :: \"r\" (BIT(counter)));",
          "922:  return idx;",
          "923: }",
          "925: static inline int armv8pmu_disable_intens(int idx)",
          "926: {",
          "936:  asm volatile(\"msr pmintenclr_el1, %0\" :: \"r\" (BIT(counter)));",
          "937:  isb();",
          "939:  asm volatile(\"msr pmovsclr_el0, %0\" :: \"r\" (BIT(counter)));",
          "940:  isb();",
          "941:  return idx;",
          "942: }",
          "",
          "[Removed Lines]",
          "882:  u32 counter;",
          "884:  if (!armv8pmu_counter_valid(idx)) {",
          "885:   pr_err(\"CPU%u enabling wrong PMNC counter %d\\n\",",
          "886:    smp_processor_id(), idx);",
          "887:   return -EINVAL;",
          "888:  }",
          "890:  counter = ARMV8_IDX_TO_COUNTER(idx);",
          "897:  u32 counter;",
          "899:  if (!armv8pmu_counter_valid(idx)) {",
          "900:   pr_err(\"CPU%u disabling wrong PMNC counter %d\\n\",",
          "901:    smp_processor_id(), idx);",
          "902:   return -EINVAL;",
          "903:  }",
          "905:  counter = ARMV8_IDX_TO_COUNTER(idx);",
          "912:  u32 counter;",
          "914:  if (!armv8pmu_counter_valid(idx)) {",
          "915:   pr_err(\"CPU%u enabling wrong PMNC counter IRQ enable %d\\n\",",
          "916:    smp_processor_id(), idx);",
          "917:   return -EINVAL;",
          "918:  }",
          "920:  counter = ARMV8_IDX_TO_COUNTER(idx);",
          "927:  u32 counter;",
          "929:  if (!armv8pmu_counter_valid(idx)) {",
          "930:   pr_err(\"CPU%u disabling wrong PMNC counter IRQ enable %d\\n\",",
          "931:    smp_processor_id(), idx);",
          "932:   return -EINVAL;",
          "933:  }",
          "935:  counter = ARMV8_IDX_TO_COUNTER(idx);",
          "",
          "[Added Lines]",
          "233:  u32 counter = ARMV8_IDX_TO_COUNTER(idx);",
          "240:  u32 counter = ARMV8_IDX_TO_COUNTER(idx);",
          "247:  u32 counter = ARMV8_IDX_TO_COUNTER(idx);",
          "254:  u32 counter = ARMV8_IDX_TO_COUNTER(idx);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "955:  return value;",
          "956: }",
          "959: {",
          "960:  unsigned long flags;",
          "",
          "[Removed Lines]",
          "958: static void armv8pmu_enable_event(struct hw_perf_event *hwc, int idx)",
          "961:  struct pmu_hw_events *events = cpu_pmu->get_hw_events();",
          "",
          "[Added Lines]",
          "278: static void armv8pmu_enable_event(struct perf_event *event)",
          "281:  struct hw_perf_event *hwc = &event->hw;",
          "282:  struct arm_pmu *cpu_pmu = to_arm_pmu(event->pmu);",
          "283:  struct pmu_hw_events *events = this_cpu_ptr(cpu_pmu->hw_events);",
          "284:  int idx = hwc->idx;",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "989:  raw_spin_unlock_irqrestore(&events->pmu_lock, flags);",
          "990: }",
          "993: {",
          "994:  unsigned long flags;",
          "",
          "[Removed Lines]",
          "992: static void armv8pmu_disable_event(struct hw_perf_event *hwc, int idx)",
          "995:  struct pmu_hw_events *events = cpu_pmu->get_hw_events();",
          "",
          "[Added Lines]",
          "315: static void armv8pmu_disable_event(struct perf_event *event)",
          "318:  struct hw_perf_event *hwc = &event->hw;",
          "319:  struct arm_pmu *cpu_pmu = to_arm_pmu(event->pmu);",
          "320:  struct pmu_hw_events *events = this_cpu_ptr(cpu_pmu->hw_events);",
          "321:  int idx = hwc->idx;",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "1016: {",
          "1017:  u32 pmovsr;",
          "1018:  struct perf_sample_data data;",
          "1020:  struct pt_regs *regs;",
          "1021:  int idx;",
          "",
          "[Removed Lines]",
          "1019:  struct pmu_hw_events *cpuc;",
          "",
          "[Added Lines]",
          "345:  struct arm_pmu *cpu_pmu = (struct arm_pmu *)dev;",
          "346:  struct pmu_hw_events *cpuc = this_cpu_ptr(cpu_pmu->hw_events);",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "1037:  regs = get_irq_regs();",
          "1040:  for (idx = 0; idx < cpu_pmu->num_events; ++idx) {",
          "1041:   struct perf_event *event = cpuc->events[idx];",
          "1042:   struct hw_perf_event *hwc;",
          "",
          "[Removed Lines]",
          "1039:  cpuc = this_cpu_ptr(&cpu_hw_events);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "1053:    continue;",
          "1055:   hwc = &event->hw;",
          "1057:   perf_sample_data_init(&data, 0, hwc->last_period);",
          "1059:    continue;",
          "1061:   if (perf_event_overflow(event, &data, regs))",
          "1063:  }",
          "",
          "[Removed Lines]",
          "1056:   armpmu_event_update(event, hwc, idx);",
          "1058:   if (!armpmu_event_set_period(event, hwc, idx))",
          "1062:    cpu_pmu->disable(hwc, idx);",
          "",
          "[Added Lines]",
          "382:   armpmu_event_update(event);",
          "384:   if (!armpmu_event_set_period(event))",
          "388:    cpu_pmu->disable(event);",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "1074:  return IRQ_HANDLED;",
          "1075: }",
          "1078: {",
          "1079:  unsigned long flags;",
          "1082:  raw_spin_lock_irqsave(&events->pmu_lock, flags);",
          "",
          "[Removed Lines]",
          "1077: static void armv8pmu_start(void)",
          "1080:  struct pmu_hw_events *events = cpu_pmu->get_hw_events();",
          "",
          "[Added Lines]",
          "403: static void armv8pmu_start(struct arm_pmu *cpu_pmu)",
          "406:  struct pmu_hw_events *events = this_cpu_ptr(cpu_pmu->hw_events);",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "1085:  raw_spin_unlock_irqrestore(&events->pmu_lock, flags);",
          "1086: }",
          "1089: {",
          "1090:  unsigned long flags;",
          "1093:  raw_spin_lock_irqsave(&events->pmu_lock, flags);",
          "",
          "[Removed Lines]",
          "1088: static void armv8pmu_stop(void)",
          "1091:  struct pmu_hw_events *events = cpu_pmu->get_hw_events();",
          "",
          "[Added Lines]",
          "414: static void armv8pmu_stop(struct arm_pmu *cpu_pmu)",
          "417:  struct pmu_hw_events *events = this_cpu_ptr(cpu_pmu->hw_events);",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "1097: }",
          "1099: static int armv8pmu_get_event_idx(struct pmu_hw_events *cpuc,",
          "1101: {",
          "1102:  int idx;",
          "1106:  if (evtype == ARMV8_PMUV3_PERFCTR_CLOCK_CYCLES) {",
          "",
          "[Removed Lines]",
          "1100:       struct hw_perf_event *event)",
          "1103:  unsigned long evtype = event->config_base & ARMV8_EVTYPE_EVENT;",
          "",
          "[Added Lines]",
          "426:       struct perf_event *event)",
          "429:  struct arm_pmu *cpu_pmu = to_arm_pmu(event->pmu);",
          "430:  struct hw_perf_event *hwc = &event->hw;",
          "431:  unsigned long evtype = hwc->config_base & ARMV8_EVTYPE_EVENT;",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "1152: static void armv8pmu_reset(void *info)",
          "1153: {",
          "1154:  u32 idx, nb_cnt = cpu_pmu->num_events;",
          "1161:  armv8pmu_pmcr_write(ARMV8_PMCR_P | ARMV8_PMCR_C);",
          "",
          "[Removed Lines]",
          "1157:  for (idx = ARMV8_IDX_CYCLE_COUNTER; idx < nb_cnt; ++idx)",
          "1158:   armv8pmu_disable_event(NULL, idx);",
          "",
          "[Added Lines]",
          "482:  struct arm_pmu *cpu_pmu = (struct arm_pmu *)info;",
          "486:  for (idx = ARMV8_IDX_CYCLE_COUNTER; idx < nb_cnt; ++idx) {",
          "487:   armv8pmu_disable_counter(idx);",
          "488:   armv8pmu_disable_intens(idx);",
          "489:  }",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "1167: static int armv8_pmuv3_map_event(struct perf_event *event)",
          "1168: {",
          "1170:     &armv8_pmuv3_perf_cache_map,",
          "1171:     ARMV8_EVTYPE_EVENT);",
          "1172: }",
          "1188: {",
          "1196: }",
          "1199: {",
          "1205: }",
          "1213: {",
          "1217: }",
          "1225:  {},",
          "1226: };",
          "1229: {",
          "1279: }",
          "1282:  .driver  = {",
          "1285:  },",
          "1287: };",
          "1290: {",
          "1292: }",
          "",
          "[Removed Lines]",
          "1169:  return map_cpu_event(event, &armv8_pmuv3_perf_map,",
          "1174: static struct arm_pmu armv8pmu = {",
          "1175:  .handle_irq  = armv8pmu_handle_irq,",
          "1176:  .enable   = armv8pmu_enable_event,",
          "1177:  .disable  = armv8pmu_disable_event,",
          "1178:  .read_counter  = armv8pmu_read_counter,",
          "1179:  .write_counter  = armv8pmu_write_counter,",
          "1180:  .get_event_idx  = armv8pmu_get_event_idx,",
          "1181:  .start   = armv8pmu_start,",
          "1182:  .stop   = armv8pmu_stop,",
          "1183:  .reset   = armv8pmu_reset,",
          "1184:  .max_period  = (1LLU << 32) - 1,",
          "1185: };",
          "1187: static u32 __init armv8pmu_read_num_pmnc_events(void)",
          "1189:  u32 nb_cnt;",
          "1192:  nb_cnt = (armv8pmu_pmcr_read() >> ARMV8_PMCR_N_SHIFT) & ARMV8_PMCR_N_MASK;",
          "1195:  return nb_cnt + 1;",
          "1198: static struct arm_pmu *__init armv8_pmuv3_pmu_init(void)",
          "1200:  armv8pmu.name   = \"arm/armv8-pmuv3\";",
          "1201:  armv8pmu.map_event  = armv8_pmuv3_map_event;",
          "1202:  armv8pmu.num_events  = armv8pmu_read_num_pmnc_events();",
          "1203:  armv8pmu.set_event_filter = armv8pmu_set_event_filter;",
          "1204:  return &armv8pmu;",
          "1211: static int __init",
          "1212: cpu_pmu_reset(void)",
          "1214:  if (cpu_pmu && cpu_pmu->reset)",
          "1215:   return on_each_cpu(cpu_pmu->reset, NULL, 1);",
          "1216:  return 0;",
          "1218: arch_initcall(cpu_pmu_reset);",
          "1223: static const struct of_device_id armpmu_of_device_ids[] = {",
          "1224:  {.compatible = \"arm,armv8-pmuv3\"},",
          "1228: static int armpmu_device_probe(struct platform_device *pdev)",
          "1230:  int i, irq, *irqs;",
          "1232:  if (!cpu_pmu)",
          "1233:   return -ENODEV;",
          "1236:  irq = platform_get_irq(pdev, 0);",
          "1237:  if (irq >= 0 && irq_is_percpu(irq))",
          "1238:   goto out;",
          "1240:  irqs = kcalloc(pdev->num_resources, sizeof(*irqs), GFP_KERNEL);",
          "1241:  if (!irqs)",
          "1242:   return -ENOMEM;",
          "1244:  for (i = 0; i < pdev->num_resources; ++i) {",
          "1245:   struct device_node *dn;",
          "1246:   int cpu;",
          "1248:   dn = of_parse_phandle(pdev->dev.of_node, \"interrupt-affinity\",",
          "1249:           i);",
          "1250:   if (!dn) {",
          "1251:    pr_warn(\"Failed to parse %s/interrupt-affinity[%d]\\n\",",
          "1252:     of_node_full_name(pdev->dev.of_node), i);",
          "1253:    break;",
          "1254:   }",
          "1256:   for_each_possible_cpu(cpu)",
          "1257:    if (dn == of_cpu_device_node_get(cpu))",
          "1258:     break;",
          "1260:   if (cpu >= nr_cpu_ids) {",
          "1261:    pr_warn(\"Failed to find logical CPU for %s\\n\",",
          "1262:     dn->name);",
          "1263:    of_node_put(dn);",
          "1264:    break;",
          "1265:   }",
          "1266:   of_node_put(dn);",
          "1268:   irqs[i] = cpu;",
          "1269:  }",
          "1271:  if (i == pdev->num_resources)",
          "1272:   cpu_pmu->irq_affinity = irqs;",
          "1273:  else",
          "1274:   kfree(irqs);",
          "1276: out:",
          "1277:  cpu_pmu->plat_device = pdev;",
          "1278:  return 0;",
          "1281: static struct platform_driver armpmu_driver = {",
          "1283:   .name = \"arm-pmu\",",
          "1284:   .of_match_table = armpmu_of_device_ids,",
          "1286:  .probe  = armpmu_device_probe,",
          "1289: static int __init register_pmu_driver(void)",
          "1291:  return platform_driver_register(&armpmu_driver);",
          "1293: device_initcall(register_pmu_driver);",
          "1295: static struct pmu_hw_events *armpmu_get_cpu_events(void)",
          "1296: {",
          "1297:  return this_cpu_ptr(&cpu_hw_events);",
          "1298: }",
          "1300: static void __init cpu_pmu_init(struct arm_pmu *armpmu)",
          "1301: {",
          "1302:  int cpu;",
          "1303:  for_each_possible_cpu(cpu) {",
          "1304:   struct pmu_hw_events *events = &per_cpu(cpu_hw_events, cpu);",
          "1305:   events->events = per_cpu(hw_events, cpu);",
          "1306:   events->used_mask = per_cpu(used_mask, cpu);",
          "1307:   raw_spin_lock_init(&events->pmu_lock);",
          "1308:  }",
          "1309:  armpmu->get_hw_events = armpmu_get_cpu_events;",
          "1310: }",
          "1312: static int __init init_hw_perf_events(void)",
          "1313: {",
          "1314:  u64 dfr = read_cpuid(ID_AA64DFR0_EL1);",
          "1316:  switch ((dfr >> 8) & 0xf) {",
          "1318:   cpu_pmu = armv8_pmuv3_pmu_init();",
          "1319:   break;",
          "1320:  }",
          "1322:  if (cpu_pmu) {",
          "1323:   pr_info(\"enabled with %s PMU driver, %d counters available\\n\",",
          "1324:    cpu_pmu->name, cpu_pmu->num_events);",
          "1325:   cpu_pmu_init(cpu_pmu);",
          "1326:   armpmu_register(cpu_pmu, \"cpu\", PERF_TYPE_RAW);",
          "1327:  } else {",
          "1328:   pr_info(\"no hardware support available\\n\");",
          "1329:  }",
          "1331:  return 0;",
          "1332: }",
          "1333: early_initcall(init_hw_perf_events);",
          "",
          "[Added Lines]",
          "500:  return armpmu_map_event(event, &armv8_pmuv3_perf_map,",
          "505: static void armv8pmu_read_num_pmnc_events(void *info)",
          "507:  int *nb_cnt = info;",
          "516: static int armv8pmu_probe_num_events(struct arm_pmu *arm_pmu)",
          "518:  return smp_call_function_any(&arm_pmu->supported_cpus,",
          "519:         armv8pmu_read_num_pmnc_events,",
          "520:         &arm_pmu->num_events, 1);",
          "523: static int armv8_pmuv3_init(struct arm_pmu *cpu_pmu)",
          "525:  cpu_pmu->handle_irq  = armv8pmu_handle_irq,",
          "526:  cpu_pmu->enable   = armv8pmu_enable_event,",
          "527:  cpu_pmu->disable  = armv8pmu_disable_event,",
          "528:  cpu_pmu->read_counter  = armv8pmu_read_counter,",
          "529:  cpu_pmu->write_counter  = armv8pmu_write_counter,",
          "530:  cpu_pmu->get_event_idx  = armv8pmu_get_event_idx,",
          "531:  cpu_pmu->start   = armv8pmu_start,",
          "532:  cpu_pmu->stop   = armv8pmu_stop,",
          "533:  cpu_pmu->reset   = armv8pmu_reset,",
          "534:  cpu_pmu->max_period  = (1LLU << 32) - 1,",
          "535:  cpu_pmu->name   = \"armv8_pmuv3\";",
          "536:  cpu_pmu->map_event  = armv8_pmuv3_map_event;",
          "537:  cpu_pmu->set_event_filter = armv8pmu_set_event_filter;",
          "538:  return armv8pmu_probe_num_events(cpu_pmu);",
          "541: static const struct of_device_id armv8_pmu_of_device_ids[] = {",
          "542:  {.compatible = \"arm,armv8-pmuv3\", .data = armv8_pmuv3_init},",
          "546: static int armv8_pmu_device_probe(struct platform_device *pdev)",
          "548:  return arm_pmu_device_probe(pdev, armv8_pmu_of_device_ids, NULL);",
          "551: static struct platform_driver armv8_pmu_driver = {",
          "553:   .name = \"armv8-pmu\",",
          "554:   .of_match_table = armv8_pmu_of_device_ids,",
          "556:  .probe  = armv8_pmu_device_probe,",
          "559: static int __init register_armv8_pmu_driver(void)",
          "561:  return platform_driver_register(&armv8_pmu_driver);",
          "563: device_initcall(register_armv8_pmu_driver);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "2d23ed04de933625bc777cc474d2cd9a2a3fa860",
      "candidate_info": {
        "commit_hash": "2d23ed04de933625bc777cc474d2cd9a2a3fa860",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/2d23ed04de933625bc777cc474d2cd9a2a3fa860",
        "files": [
          "arch/arm64/kernel/perf_event.c"
        ],
        "message": "arm64: perf: Remove unnecessary printk\n\nARM64 pmu prints an error message in event_init() when\nno hardware PMU is available. This is pretty annoying as\nit keeps printing the message for every single trial, flooding\nthe kernel logs, unnecessarily. The return code is sufficient for\nthe user to figure out the reason.\n\nSigned-off-by: Suzuki K. Poulose <suzuki.poulose@arm.com>\nSigned-off-by: Will Deacon <will.deacon@arm.com>",
        "before_after_code_files": [
          "arch/arm64/kernel/perf_event.c||arch/arm64/kernel/perf_event.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "arch/arm64/kernel/perf_event.c||arch/arm64/kernel/perf_event.c"
          ],
          "candidate": [
            "arch/arm64/kernel/perf_event.c||arch/arm64/kernel/perf_event.c"
          ]
        }
      },
      "candidate_diff": {
        "arch/arm64/kernel/perf_event.c||arch/arm64/kernel/perf_event.c": [
          "File: arch/arm64/kernel/perf_event.c -> arch/arm64/kernel/perf_event.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "435:  unsigned int i, irqs;",
          "436:  struct platform_device *pmu_device = armpmu->plat_device;",
          "440:   return -ENODEV;",
          "443:  irqs = min(pmu_device->num_resources, num_possible_cpus());",
          "444:  if (!irqs) {",
          "",
          "[Removed Lines]",
          "438:  if (!pmu_device) {",
          "439:   pr_err(\"no PMU device registered\\n\");",
          "441:  }",
          "",
          "[Added Lines]",
          "438:  if (!pmu_device)",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "96045ed486b09b2dc21c3d09edb13f22dff875bf",
      "candidate_info": {
        "commit_hash": "96045ed486b09b2dc21c3d09edb13f22dff875bf",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/96045ed486b09b2dc21c3d09edb13f22dff875bf",
        "files": [
          "arch/arm64/kernel/perf_event.c"
        ],
        "message": "arm64: Mark PMU interrupt IRQF_NO_THREAD\n\nMark the PMU interrupts as non-threadable, as is the case with\narch/arm: d9c3365 ARM: 7813/1: Mark pmu interupt IRQF_NO_THREAD\n\nAcked-by: Will Deacon <will.deacon@arm.com>\nSuggested-by: Sebastian Andrzej Siewior <bigeasy@linutronix.de>\nSigned-off-by: Anders Roxell <anders.roxell@linaro.org>\nSigned-off-by: Catalin Marinas <catalin.marinas@arm.com>",
        "before_after_code_files": [
          "arch/arm64/kernel/perf_event.c||arch/arm64/kernel/perf_event.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "arch/arm64/kernel/perf_event.c||arch/arm64/kernel/perf_event.c"
          ],
          "candidate": [
            "arch/arm64/kernel/perf_event.c||arch/arm64/kernel/perf_event.c"
          ]
        }
      },
      "candidate_diff": {
        "arch/arm64/kernel/perf_event.c||arch/arm64/kernel/perf_event.c": [
          "File: arch/arm64/kernel/perf_event.c -> arch/arm64/kernel/perf_event.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "488:    }",
          "490:    err = request_irq(irq, armpmu->handle_irq,",
          "492:      \"arm-pmu\", armpmu);",
          "493:    if (err) {",
          "494:     pr_err(\"unable to request IRQ%d for ARM PMU counters\\n\",",
          "",
          "[Removed Lines]",
          "491:      IRQF_NOBALANCING,",
          "",
          "[Added Lines]",
          "491:      IRQF_NOBALANCING | IRQF_NO_THREAD,",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "d5efd9cc9cf2e422d064c912c7d5d985f52c1b2c",
      "candidate_info": {
        "commit_hash": "d5efd9cc9cf2e422d064c912c7d5d985f52c1b2c",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/d5efd9cc9cf2e422d064c912c7d5d985f52c1b2c",
        "files": [
          "arch/arm64/include/asm/pmu.h",
          "arch/arm64/kernel/perf_event.c"
        ],
        "message": "arm64: pmu: add support for interrupt-affinity property\n\nHistorically, the PMU devicetree bindings have expected SPIs to be\nlisted in order of *logical* CPU number. This is problematic for\nbootloaders, especially when the boot CPU (logical ID 0) isn't listed\nfirst in the devicetree.\n\nThis patch adds a new optional property, interrupt-affinity, to the\nPMU node which allows the interrupt affinity to be described using\na list of phandled to CPU nodes, with each entry in the list\ncorresponding to the SPI at the same index in the interrupts property.\n\nCc: Mark Rutland <mark.rutland@arm.com>\nSigned-off-by: Will Deacon <will.deacon@arm.com>",
        "before_after_code_files": [
          "arch/arm64/include/asm/pmu.h||arch/arm64/include/asm/pmu.h",
          "arch/arm64/kernel/perf_event.c||arch/arm64/kernel/perf_event.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "arch/arm64/kernel/perf_event.c||arch/arm64/kernel/perf_event.c"
          ],
          "candidate": [
            "arch/arm64/kernel/perf_event.c||arch/arm64/kernel/perf_event.c"
          ]
        }
      },
      "candidate_diff": {
        "arch/arm64/include/asm/pmu.h||arch/arm64/include/asm/pmu.h": [
          "File: arch/arm64/include/asm/pmu.h -> arch/arm64/include/asm/pmu.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "44: struct arm_pmu {",
          "45:  struct pmu  pmu;",
          "46:  cpumask_t  active_irqs;",
          "47:  const char  *name;",
          "48:  irqreturn_t  (*handle_irq)(int irq_num, void *dev);",
          "49:  void   (*enable)(struct hw_perf_event *evt, int idx);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "47:  int   *irq_affinity;",
          "",
          "---------------"
        ],
        "arch/arm64/kernel/perf_event.c||arch/arm64/kernel/perf_event.c": [
          "File: arch/arm64/kernel/perf_event.c -> arch/arm64/kernel/perf_event.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "25: #include <linux/irq.h>",
          "26: #include <linux/kernel.h>",
          "27: #include <linux/export.h>",
          "28: #include <linux/perf_event.h>",
          "29: #include <linux/platform_device.h>",
          "30: #include <linux/spinlock.h>",
          "31: #include <linux/uaccess.h>",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "28: #include <linux/of.h>",
          "31: #include <linux/slab.h>",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "405:   free_percpu_irq(irq, &cpu_hw_events);",
          "406:  } else {",
          "407:   for (i = 0; i < irqs; ++i) {",
          "409:     continue;",
          "410:    irq = platform_get_irq(pmu_device, i);",
          "411:    if (irq > 0)",
          "",
          "[Removed Lines]",
          "408:    if (!cpumask_test_and_clear_cpu(i, &armpmu->active_irqs))",
          "",
          "[Added Lines]",
          "410:    int cpu = i;",
          "412:    if (armpmu->irq_affinity)",
          "413:     cpu = armpmu->irq_affinity[i];",
          "415:    if (!cpumask_test_and_clear_cpu(cpu, &armpmu->active_irqs))",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "459:   on_each_cpu(armpmu_enable_percpu_irq, &irq, 1);",
          "460:  } else {",
          "461:   for (i = 0; i < irqs; ++i) {",
          "462:    err = 0;",
          "463:    irq = platform_get_irq(pmu_device, i);",
          "464:    if (irq <= 0)",
          "465:     continue;",
          "473:     pr_warning(\"unable to set irq affinity (irq=%d, cpu=%u)\\n\",",
          "475:     continue;",
          "476:    }",
          "",
          "[Removed Lines]",
          "472:    if (irq_set_affinity(irq, cpumask_of(i)) && irqs > 1) {",
          "474:       irq, i);",
          "",
          "[Added Lines]",
          "469:    int cpu = i;",
          "476:    if (armpmu->irq_affinity)",
          "477:     cpu = armpmu->irq_affinity[i];",
          "484:    if (irq_set_affinity(irq, cpumask_of(cpu)) && irqs > 1) {",
          "486:       irq, cpu);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "485:     return err;",
          "486:    }",
          "489:   }",
          "490:  }",
          "",
          "[Removed Lines]",
          "488:    cpumask_set_cpu(i, &armpmu->active_irqs);",
          "",
          "[Added Lines]",
          "500:    cpumask_set_cpu(cpu, &armpmu->active_irqs);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1299: static int armpmu_device_probe(struct platform_device *pdev)",
          "1300: {",
          "1301:  if (!cpu_pmu)",
          "1302:   return -ENODEV;",
          "1304:  cpu_pmu->plat_device = pdev;",
          "1305:  return 0;",
          "1306: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1313:  int i, *irqs;",
          "1318:  irqs = kcalloc(pdev->num_resources, sizeof(*irqs), GFP_KERNEL);",
          "1319:  if (!irqs)",
          "1320:   return -ENOMEM;",
          "1322:  for (i = 0; i < pdev->num_resources; ++i) {",
          "1323:   struct device_node *dn;",
          "1324:   int cpu;",
          "1326:   dn = of_parse_phandle(pdev->dev.of_node, \"interrupt-affinity\",",
          "1327:           i);",
          "1328:   if (!dn) {",
          "1329:    pr_warn(\"Failed to parse %s/interrupt-affinity[%d]\\n\",",
          "1330:     of_node_full_name(dn), i);",
          "1331:    break;",
          "1332:   }",
          "1334:   for_each_possible_cpu(cpu)",
          "1335:    if (arch_find_n_match_cpu_physical_id(dn, cpu, NULL))",
          "1336:     break;",
          "1338:   of_node_put(dn);",
          "1339:   if (cpu >= nr_cpu_ids) {",
          "1340:    pr_warn(\"Failed to find logical CPU for %s\\n\",",
          "1341:     dn->name);",
          "1342:    break;",
          "1343:   }",
          "1345:   irqs[i] = cpu;",
          "1346:  }",
          "1348:  if (i == pdev->num_resources)",
          "1349:   cpu_pmu->irq_affinity = irqs;",
          "1350:  else",
          "1351:   kfree(irqs);",
          "",
          "---------------"
        ]
      }
    }
  ]
}
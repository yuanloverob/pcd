{
  "cve_id": "CVE-2015-3815",
  "cve_desc": "The detect_version function in wiretap/logcat.c in the Android Logcat file parser in Wireshark 1.12.x before 1.12.5 does not check the length of the payload, which allows remote attackers to cause a denial of service (out-of-bounds read and application crash) via a packet with a crafted payload, as demonstrated by a length of zero, a different vulnerability than CVE-2015-3906.",
  "repo": "wireshark/wireshark",
  "patch_hash": "b3b1f7c3aa2233a147294bad833b748d38fba84d",
  "patch_info": {
    "commit_hash": "b3b1f7c3aa2233a147294bad833b748d38fba84d",
    "repo": "wireshark/wireshark",
    "commit_url": "https://github.com/wireshark/wireshark/commit/b3b1f7c3aa2233a147294bad833b748d38fba84d",
    "files": [
      "wiretap/logcat.c"
    ],
    "message": "logcat: improve (crash) robustness, improve names\n\nThe logcat version detector would crash with ASAN enabled because it did\nnot validate the payload length and hence a payload length of 0 would\ntrigger out-of-bounds access. (This happened on non-logcat data.)\n\nThis patch tries to get rid of all magic numbers by using a structure,\nimproves the version detector to validate the payload length and\nprevents crashes due to missing nul-terminators in the input. Older\nAndroid kernels would create entries with __pad with random contents, so\nthat cannot be used to determine version for v1. Instead, use heuristics\non the priority, tag and maybe the msg field.\n\nFurthermore, Android is mostly (if not, always?) Little-Endian, so add\nconversions where necessary (just in case WS supports BE arches).\n\n\"microseconds\" has been renamed to \"milliseconds\" because that is what\nthey are, actually. A duplicate logcat_log loop has been refactored\nsuch that one loop is sufficient, instead of separate buffers for each\nlog part, a single one is now used. get_priority does not really need\na pointer, just make it accept a character.\n\nThe output has been validated against v1 and v2 logcat binary formats\nwith __pad (hdr_size) equal to 0, and on attachment 9906.\n\nChange-Id: I46c8813e76fe705b293ffdee85b4c1bfff7d8362\nReviewed-on: https://code.wireshark.org/review/2803\nReviewed-by: Michal Labedzki <michal.labedzki@tieto.com>\nTested-by: Michal Labedzki <michal.labedzki@tieto.com>",
    "before_after_code_files": [
      "wiretap/logcat.c||wiretap/logcat.c"
    ]
  },
  "patch_diff": {
    "wiretap/logcat.c||wiretap/logcat.c": [
      "File: wiretap/logcat.c -> wiretap/logcat.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "43:     enum dump_type_t type;",
      "44: };",
      "47:     static gchar priorities[] = \"??VDIWEFS\";",
      "50:         return '?';",
      "53: }",
      "55: static gchar *logcat_log(const struct dumper_t *dumper, guint32 seconds,",
      "57:         const gchar *log)",
      "58: {",
      "59:     gchar  time_buffer[15];",
      "",
      "[Removed Lines]",
      "46: static gchar get_priority(const guint8 *priority) {",
      "49:     if (*priority >= (guint8) sizeof(priorities))",
      "52:     return priorities[(int) *priority];",
      "56:         gint microseconds, gint pid, gint tid, gchar priority, const gchar *tag,",
      "",
      "[Added Lines]",
      "51: #define LOGGER_ENTRY_MAX_PAYLOAD 4076",
      "53: struct logger_entry {",
      "61: };",
      "63: struct logger_entry_v2 {",
      "70:     union {",
      "74:     };",
      "76: };",
      "79: static gchar get_priority(const guint8 priority) {",
      "82:     if (priority >= (guint8) sizeof(priorities))",
      "85:     return priorities[priority];",
      "89:         gint milliseconds, gint pid, gint tid, gchar priority, const gchar *tag,",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "80:             strftime(time_buffer, sizeof(time_buffer), \"%m-%d %H:%M:%S\",",
      "81:                     gmtime(&datetime));",
      "82:             return g_strdup_printf(\"%s.%03i %c/%-8s(%5i): %s\\n\",",
      "84:         case DUMP_THREADTIME:",
      "85:             strftime(time_buffer, sizeof(time_buffer), \"%m-%d %H:%M:%S\",",
      "86:                     gmtime(&datetime));",
      "87:             return g_strdup_printf(\"%s.%03i %5i %5i %c %-8s: %s\\n\",",
      "89:         case DUMP_LONG:",
      "90:             strftime(time_buffer, sizeof(time_buffer), \"%m-%d %H:%M:%S\",",
      "91:                     gmtime(&datetime));",
      "92:             return g_strdup_printf(\"[ %s.%03i %5i:0x%02x %c/%s ]\\n%s\\n\\n\",",
      "94:         default:",
      "95:             return NULL;",
      "96:     }",
      "",
      "[Removed Lines]",
      "83:                     time_buffer, microseconds, priority, tag, pid, log);",
      "88:                     time_buffer, microseconds, pid, tid, priority, tag, log);",
      "93:                     time_buffer, microseconds, pid, tid, priority, tag, log);",
      "",
      "[Added Lines]",
      "116:                     time_buffer, milliseconds, priority, tag, pid, log);",
      "121:                     time_buffer, milliseconds, pid, tid, priority, tag, log);",
      "126:                     time_buffer, milliseconds, pid, tid, priority, tag, log);",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "100: static gint detect_version(wtap *wth, int *err, gchar **err_info)",
      "101: {",
      "113:     bytes_read = file_read(&tmp, 2, wth->fh);",
      "114:     if (bytes_read != 2) {",
      "",
      "[Removed Lines]",
      "102:     gint     bytes_read;",
      "103:     guint16  payload_length;",
      "104:     guint16  try_header_size;",
      "105:     guint8  *buffer;",
      "106:     gint64   file_offset;",
      "107:     guint32  log_length;",
      "108:     guint32  tag_length;",
      "109:     guint16  tmp;",
      "111:     file_offset = file_tell(wth->fh);",
      "",
      "[Added Lines]",
      "135:     gint                     bytes_read;",
      "136:     guint16                  payload_length;",
      "137:     guint16                  hdr_size;",
      "138:     guint16                  read_sofar;",
      "139:     guint16                  entry_len;",
      "140:     gint                     version;",
      "141:     struct logger_entry     *log_entry;",
      "142:     struct logger_entry_v2  *log_entry_v2;",
      "143:     guint8                  *buffer;",
      "144:     guint16                  tmp;",
      "145:     guint8                  *msg_payload, *msg_part, *msg_end;",
      "146:     guint16                  msg_len;",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "127:         return -1;",
      "128:     }",
      "136:             if (*err == 0 && bytes_read != 0)",
      "140:         }",
      "159:         g_free(buffer);",
      "161:     }",
      "163:     g_free(buffer);",
      "165: }",
      "167: static gboolean logcat_read_packet(struct logcat_phdr *logcat, FILE_T fh,",
      "",
      "[Removed Lines]",
      "129:     try_header_size = pletoh16(&tmp);",
      "131:     buffer = (guint8 *) g_malloc(5 * 4 + payload_length);",
      "132:     bytes_read = file_read(buffer, 5 * 4 + payload_length, wth->fh);",
      "133:     if (bytes_read != 5 * 4 + payload_length) {",
      "134:         if (bytes_read != 4 * 4 + payload_length) {",
      "138:             g_free(buffer);",
      "139:             return -1;",
      "141:     }",
      "143:     if (try_header_size == 24) {",
      "144:         tag_length = (guint32)strlen(buffer + 5 * 4 + 1) + 1;",
      "145:         log_length = (guint32)strlen(buffer + 5 * 4 + 1 + tag_length) + 1;",
      "146:         if (payload_length == 1 + tag_length + log_length) {",
      "147:             g_free(buffer);",
      "148:             return 2;",
      "149:         }",
      "150:     }",
      "152:     tag_length = (guint32)strlen(buffer + 4 * 4 + 1) + 1;",
      "153:     log_length = (guint32)strlen(buffer + 4 * 4 + 1 + tag_length) + 1;",
      "154:     if (payload_length == 1 + tag_length + log_length) {",
      "155:         if (file_seek(wth->fh, file_offset + 4 * 4 + 1 + tag_length + log_length, SEEK_SET, err) == -1) {",
      "156:             g_free(buffer);",
      "157:             return -1;",
      "158:         }",
      "160:         return 1;",
      "164:     return 0;",
      "",
      "[Added Lines]",
      "166:     hdr_size = pletoh16(&tmp);",
      "167:     read_sofar = 4;",
      "170:     if (payload_length < 3)",
      "171:         return -1;",
      "173:     if (payload_length > LOGGER_ENTRY_MAX_PAYLOAD)",
      "174:         return -1;",
      "177:     buffer = (guint8 *) g_malloc(sizeof(*log_entry_v2) + payload_length);",
      "178:     log_entry_v2 = (struct logger_entry_v2 *) buffer;",
      "179:     log_entry = (struct logger_entry *) buffer;",
      "183:     for (version = 1; version <= 2; ++version) {",
      "184:         if (version == 1) {",
      "185:             msg_payload = log_entry->msg;",
      "186:             entry_len = sizeof(*log_entry) + payload_length;",
      "187:         } else if (version == 2) {",
      "189:             msg_payload = log_entry_v2->msg;",
      "190:             entry_len = sizeof(*log_entry_v2) + payload_length;",
      "191:             if (hdr_size != sizeof(*log_entry_v2))",
      "192:                 continue;",
      "193:         }",
      "195:         bytes_read = file_read(buffer + read_sofar, entry_len - read_sofar,",
      "196:                 wth->fh);",
      "197:         if (bytes_read != entry_len - read_sofar) {",
      "202:             version = -1;",
      "203:             break;",
      "205:         read_sofar += bytes_read;",
      "208:         if (get_priority(msg_payload[0]) == '?')",
      "209:             continue;",
      "212:         msg_part = (guint8 *) memchr(msg_payload, '\\0', payload_length - 1);",
      "213:         if (msg_part == NULL)",
      "214:             continue;",
      "217:         ++msg_part;",
      "218:         msg_len = payload_length - (msg_part - msg_payload);",
      "219:         msg_end = (guint8 *) memchr(msg_part, '\\0', msg_len);",
      "221:         if (msg_end && (msg_payload + payload_length - 1 != msg_end))",
      "222:             continue;",
      "225:         return version;",
      "229:     return -1;",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "172:     guint16              payload_length;",
      "173:     guint                tmp[2];",
      "174:     guint8              *pd;",
      "176:     bytes_read = file_read(&tmp, 2, fh);",
      "177:     if (bytes_read != 2) {",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "240:     struct logger_entry *log_entry;",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "183:     payload_length = pletoh16(tmp);",
      "185:     if (logcat->version == 1) {",
      "187:     } else if (logcat->version == 2) {",
      "189:     } else {",
      "190:         return FALSE;",
      "191:     }",
      "193:     buffer_assure_space(buf, packet_size);",
      "194:     pd = buffer_start_ptr(buf);",
      "197:     memcpy(pd, tmp, 2);",
      "",
      "[Removed Lines]",
      "186:         packet_size = 5 * 4 + payload_length;",
      "188:         packet_size = 6 * 4 + payload_length;",
      "",
      "[Added Lines]",
      "252:         packet_size = sizeof(struct logger_entry) + payload_length;",
      "254:         packet_size = sizeof(struct logger_entry_v2) + payload_length;",
      "261:     log_entry = (struct logger_entry *) pd;",
      "",
      "---------------",
      "--- Hunk 7 ---",
      "[Context before]",
      "208:     phdr->rec_type = REC_TYPE_PACKET;",
      "209:     phdr->presence_flags = WTAP_HAS_TS;",
      "212:     phdr->caplen = packet_size;",
      "213:     phdr->len = packet_size;",
      "",
      "[Removed Lines]",
      "210:     phdr->ts.secs = (time_t) pletoh32(pd + 12);",
      "211:     phdr->ts.nsecs = (int) pletoh32(pd + 16);",
      "",
      "[Added Lines]",
      "277:     phdr->ts.secs = (time_t) GINT32_FROM_LE(log_entry->sec);",
      "278:     phdr->ts.nsecs = GINT32_FROM_LE(log_entry->nsec);",
      "",
      "---------------",
      "--- Hunk 8 ---",
      "[Context before]",
      "340:     gchar                          *buf;",
      "341:     gint                            length;",
      "342:     gchar                           priority;",
      "343:     const gchar                    *tag;",
      "347:     gchar                          *log_part;",
      "352:     const union wtap_pseudo_header *pseudo_header = &phdr->pseudo_header;",
      "353:     const struct dumper_t          *dumper        = (const struct dumper_t *) wdh->priv;",
      "",
      "[Removed Lines]",
      "344:     const gint                     *pid;",
      "345:     const gint                     *tid;",
      "346:     const gchar                    *log;",
      "348:     const gchar                    *str_begin;",
      "349:     const gchar                    *str_end;",
      "350:     const guint32                  *datetime;",
      "351:     const guint32                  *nanoseconds;",
      "",
      "[Added Lines]",
      "410:     const struct logger_entry      *log_entry = (struct logger_entry *) pd;",
      "411:     const struct logger_entry_v2   *log_entry_v2 = (struct logger_entry_v2 *) pd;",
      "412:     gint                            payload_length;",
      "414:     gint32                          pid;",
      "415:     gint32                          tid;",
      "416:     gint32                          seconds;",
      "417:     gint32                          milliseconds;",
      "418:     const gchar                    *msg_begin;",
      "419:     gint                            msg_pre_skip;",
      "420:     gchar                          *log;",
      "422:     gchar                          *log_next;",
      "",
      "---------------",
      "--- Hunk 9 ---",
      "[Context before]",
      "358:         return FALSE;",
      "359:     }",
      "361:     if (pseudo_header->logcat.version == 1) {",
      "369:     } else if (pseudo_header->logcat.version == 2) {",
      "377:     } else {",
      "379:         return FALSE;",
      "380:     }",
      "401:         }",
      "413:                 priority, tag, log_part);",
      "414:         if (!buf) {",
      "416:             return FALSE;",
      "417:         }",
      "419:         length = (guint32)strlen(buf);",
      "421:         if (!wtap_dump_file_write(wdh, buf, length, err)) {",
      "423:             return FALSE;",
      "424:         }",
      "426:         wdh->bytes_dumped += length;",
      "430:     return TRUE;",
      "431: }",
      "",
      "[Removed Lines]",
      "362:         pid = (const gint *) (pd + 4);",
      "363:         tid = (const gint *) (pd + 2 * 4);",
      "364:         datetime = (const guint32 *) (pd + 3 * 4);",
      "365:         nanoseconds = (const guint32 *) (pd + 4 * 4);",
      "366:         priority = get_priority((const guint8 *) (pd + 5 * 4));",
      "367:         tag = (const gchar *) (pd + 5 * 4 + 1);",
      "368:         log = tag + strlen(tag) + 1;",
      "370:         pid = (const gint *) (pd + 4);",
      "371:         tid = (const gint *) (pd + 2 * 4);",
      "372:         datetime = (const guint32 *) (pd + 3 * 4);",
      "373:         nanoseconds = (const guint32 *) (pd + 4 * 4);",
      "374:         priority = get_priority((const guint8 *) (pd + 6 * 4));",
      "375:         tag = (const char *) (pd + 6 * 4 + 1);",
      "376:         log = tag + strlen(tag) + 1;",
      "382:     str_begin = str_end = log;",
      "383:     while (dumper->type != DUMP_LONG && (str_end = strchr(str_begin, '\\n'))) {",
      "384:         log_part = (gchar *) g_malloc(str_end - str_begin + 1);",
      "385:         g_strlcpy(log_part, str_begin, str_end - str_begin + 1);",
      "387:         str_begin = str_end + 1;",
      "389:         buf = logcat_log(dumper, *datetime, *nanoseconds / 1000000, *pid, *tid,",
      "390:                 priority, tag, log_part);",
      "391:         if (!buf) {",
      "392:             g_free(log_part);",
      "393:             return FALSE;",
      "394:         }",
      "395:         g_free(log_part);",
      "396:         length = (guint32)strlen(buf);",
      "398:         if (!wtap_dump_file_write(wdh, buf, length, err)) {",
      "399:             g_free(buf);",
      "400:             return FALSE;",
      "403:         wdh->bytes_dumped += length;",
      "405:         g_free(buf);",
      "406:     }",
      "408:     if (*str_begin != '\\0') {",
      "409:         log_part = (gchar *) g_malloc(strlen(str_begin) + 1);",
      "410:         g_strlcpy(log_part, str_begin, strlen(str_begin) + 1);",
      "412:         buf = logcat_log(dumper, *datetime, *nanoseconds / 1000000, *pid, *tid,",
      "415:             g_free(log_part);",
      "418:         g_free(log_part);",
      "422:             g_free(buf);",
      "427:         g_free(buf);",
      "428:     }",
      "",
      "[Added Lines]",
      "432:     payload_length = GINT32_FROM_LE(log_entry->len);",
      "433:     pid = GINT32_FROM_LE(log_entry->pid);",
      "434:     tid = GINT32_FROM_LE(log_entry->tid);",
      "435:     seconds = GINT32_FROM_LE(log_entry->sec);",
      "436:     milliseconds = GINT32_FROM_LE(log_entry->nsec) / 1000000;",
      "440:         priority = get_priority(log_entry->msg[0]);",
      "441:         tag = log_entry->msg + 1;",
      "442:         msg_pre_skip = 1 + strlen(tag) + 1;",
      "443:         msg_begin = log_entry->msg + msg_pre_skip;",
      "445:         priority = get_priority(log_entry_v2->msg[0]);",
      "446:         tag = log_entry_v2->msg + 1;",
      "447:         msg_pre_skip = 1 + strlen(tag) + 1;",
      "448:         msg_begin = log_entry_v2->msg + msg_pre_skip;",
      "455:     log = g_strndup(msg_begin, payload_length - msg_pre_skip);",
      "459:     log_next = log;",
      "460:     do {",
      "461:         log_part = log_next;",
      "462:         if (dumper->type == DUMP_LONG) {",
      "464:             log_next = NULL;",
      "465:         } else {",
      "467:             log_next = strchr(log_part, '\\n');",
      "468:             if (log_next != NULL) {",
      "470:                 ++log_next;",
      "472:                 if (*log_next == '\\0') {",
      "473:                     log_next = NULL;",
      "474:                 }",
      "475:             }",
      "478:         buf = logcat_log(dumper, seconds, milliseconds, pid, tid,",
      "481:             g_free(log);",
      "487:             g_free(log);",
      "492:     } while (log_next != NULL);",
      "494:     g_free(log);",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "e2038e03007faaa29f9ed1cb3619e84bd6e03247",
      "candidate_info": {
        "commit_hash": "e2038e03007faaa29f9ed1cb3619e84bd6e03247",
        "repo": "wireshark/wireshark",
        "commit_url": "https://github.com/wireshark/wireshark/commit/e2038e03007faaa29f9ed1cb3619e84bd6e03247",
        "files": [
          "wiretap/logcat.c"
        ],
        "message": "Add strlen casts.\n\nChange-Id: Icaf80f060c476dd7259c04c4cce4123025ef1dab\nReviewed-on: https://code.wireshark.org/review/3012\nReviewed-by: Gerald Combs <gerald@wireshark.org>",
        "before_after_code_files": [
          "wiretap/logcat.c||wiretap/logcat.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "wiretap/logcat.c||wiretap/logcat.c"
          ],
          "candidate": [
            "wiretap/logcat.c||wiretap/logcat.c"
          ]
        }
      },
      "candidate_diff": {
        "wiretap/logcat.c||wiretap/logcat.c": [
          "File: wiretap/logcat.c -> wiretap/logcat.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "439:     if (pseudo_header->logcat.version == 1) {",
          "440:         priority = get_priority(log_entry->msg[0]);",
          "441:         tag = log_entry->msg + 1;",
          "443:         msg_begin = log_entry->msg + msg_pre_skip;",
          "444:     } else if (pseudo_header->logcat.version == 2) {",
          "445:         priority = get_priority(log_entry_v2->msg[0]);",
          "446:         tag = log_entry_v2->msg + 1;",
          "448:         msg_begin = log_entry_v2->msg + msg_pre_skip;",
          "449:     } else {",
          "",
          "[Removed Lines]",
          "442:         msg_pre_skip = 1 + strlen(tag) + 1;",
          "447:         msg_pre_skip = 1 + strlen(tag) + 1;",
          "",
          "[Added Lines]",
          "442:         msg_pre_skip = 1 + (gint) strlen(tag) + 1;",
          "447:         msg_pre_skip = 1 + (gint) strlen(tag) + 1;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "a68e3a410c210e798aa9c96c03ef5cc075f19ca9",
      "candidate_info": {
        "commit_hash": "a68e3a410c210e798aa9c96c03ef5cc075f19ca9",
        "repo": "wireshark/wireshark",
        "commit_url": "https://github.com/wireshark/wireshark/commit/a68e3a410c210e798aa9c96c03ef5cc075f19ca9",
        "files": [
          "epan/dissectors/packet-logcat.c",
          "wiretap/CMakeLists.txt",
          "wiretap/Makefile.common",
          "wiretap/file_access.c",
          "wiretap/logcat.c",
          "wiretap/logcat.h",
          "wiretap/wtap.h"
        ],
        "message": "Wiretap: Add support for Android Logcat\n\nNow Androit Logcat (Logger) binary logs are supported.\nTry \"adb logcat -Bf /sdcard/log.logcat; adb pull /sdcard/log.logcat\".\nAlso there is possibility to save logs to text format like by \"adb\".\n\nChange-Id: If7bfc53d3fbd549a0978d1dbf96f3fff671fd601\nReviewed-on: https://code.wireshark.org/review/235\nReviewed-by: Anders Broman <a.broman58@gmail.com>",
        "before_after_code_files": [
          "epan/dissectors/packet-logcat.c||epan/dissectors/packet-logcat.c",
          "wiretap/Makefile.common||wiretap/Makefile.common",
          "wiretap/file_access.c||wiretap/file_access.c",
          "wiretap/logcat.c||wiretap/logcat.c",
          "wiretap/logcat.h||wiretap/logcat.h",
          "wiretap/wtap.h||wiretap/wtap.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "wiretap/logcat.c||wiretap/logcat.c"
          ],
          "candidate": [
            "wiretap/logcat.c||wiretap/logcat.c"
          ]
        }
      },
      "candidate_diff": {
        "epan/dissectors/packet-logcat.c||epan/dissectors/packet-logcat.c": [
          "File: epan/dissectors/packet-logcat.c -> epan/dissectors/packet-logcat.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "28: #include <epan/expert.h>",
          "29: #include <epan/exported_pdu.h>",
          "30: #include <epan/tap.h>",
          "32: static int proto_logcat = -1;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "31: #include <wiretap/wtap.h>",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "282: void",
          "283: proto_reg_handoff_logcat(void)",
          "284: {",
          "285:     dissector_add_handle(\"tcp.port\", logcat_handle);",
          "287:     exported_pdu_tap = find_tap_id(EXPORT_PDU_TAP_NAME_LOGCAT);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "286:     dissector_add_uint(\"wtap_encap\", WTAP_ENCAP_LOGCAT, logcat_handle);",
          "",
          "---------------"
        ],
        "wiretap/Makefile.common||wiretap/Makefile.common": [
          "File: wiretap/Makefile.common -> wiretap/Makefile.common",
          "--- Hunk 1 ---",
          "[Context before]",
          "56:  mime_file.c  \\",
          "57:  k12.c   \\",
          "58:  lanalyzer.c  \\",
          "59:  libpcap.c  \\",
          "60:  merge.c   \\",
          "61:  mpeg.c   \\",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "59:  logcat.c  \\",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "114:  k12.h   \\",
          "115:  lanalyzer.h  \\",
          "116:  libpcap.h  \\",
          "117:  merge.h   \\",
          "118:  mpeg.h   \\",
          "120:  mp2t.h   \\",
          "121:  netmon.h  \\",
          "122:  netscreen.h  \\",
          "",
          "[Removed Lines]",
          "119:  mpeg.h   \\",
          "",
          "[Added Lines]",
          "118:  logcat.h  \\",
          "",
          "---------------"
        ],
        "wiretap/file_access.c||wiretap/file_access.c": [
          "File: wiretap/file_access.c -> wiretap/file_access.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "64: #include \"5views.h\"",
          "65: #include \"erf.h\"",
          "66: #include \"hcidump.h\"",
          "67: #include \"network_instruments.h\"",
          "68: #include \"k12.h\"",
          "69: #include \"ber.h\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "67: #include \"logcat.h\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "360:     { \"Hcidump\",                     OPEN_INFO_HEURISTIC, hcidump_open,             NULL,       NULL },",
          "361:     { \"Commview\",                    OPEN_INFO_HEURISTIC, commview_open,            \"ncf\",      NULL },",
          "362:     { \"Nstrace\",                     OPEN_INFO_HEURISTIC, nstrace_open,             \"txt\",      NULL },",
          "364:     { \"Ascend\",                      OPEN_INFO_HEURISTIC, ascend_open,              \"txt\",      NULL },",
          "365:     { \"Toshiba\",                     OPEN_INFO_HEURISTIC, toshiba_open,             \"txt\",      NULL },",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "364:     { \"Logcat \",                     OPEN_INFO_HEURISTIC, logcat_open,              \"logcat\",   NULL },",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1421:  { \"NetScaler Trace (Version 3.0)\", \"nstrace30\", \"cap\", NULL,",
          "1422:    TRUE, FALSE, 0,",
          "1425: };",
          "",
          "[Removed Lines]",
          "1423:    nstrace_30_dump_can_write_encap, nstrace_dump_open, NULL }",
          "",
          "[Added Lines]",
          "1425:    nstrace_30_dump_can_write_encap, nstrace_dump_open, NULL },",
          "1428:  { \"Android Logcat Binary format\",          \"logcat\",         \"logcat\", NULL,",
          "1429:    FALSE, FALSE, 0,",
          "1430:    logcat_dump_can_write_encap, logcat_binary_dump_open, NULL },",
          "1431:  { \"Android Logcat Brief text format\",      \"logcat-brief\",      NULL, NULL,",
          "1432:    FALSE, FALSE, 0,",
          "1433:    logcat_dump_can_write_encap, logcat_text_brief_dump_open, NULL },",
          "1434:  { \"Android Logcat Process text format\",    \"logcat-process\",    NULL, NULL,",
          "1435:    FALSE, FALSE, 0,",
          "1436:    logcat_dump_can_write_encap, logcat_text_process_dump_open, NULL },",
          "1437:  { \"Android Logcat Tag text format\",        \"logcat-tag\",        NULL, NULL,",
          "1438:    FALSE, FALSE, 0,",
          "1439:    logcat_dump_can_write_encap, logcat_text_tag_dump_open, NULL },",
          "1440:  { \"Android Logcat Time text format\",       \"logcat-time\",       NULL, NULL,",
          "1441:    FALSE, FALSE, 0,",
          "1442:    logcat_dump_can_write_encap, logcat_text_time_dump_open, NULL },",
          "1443:  { \"Android Logcat Thread text format\",     \"logcat-thread\",     NULL, NULL,",
          "1444:    FALSE, FALSE, 0,",
          "1445:    logcat_dump_can_write_encap, logcat_text_thread_dump_open, NULL },",
          "1446:  { \"Android Logcat Threadtime text format\", \"logcat-threadtime\", NULL, NULL,",
          "1447:    FALSE, FALSE, 0,",
          "1448:    logcat_dump_can_write_encap, logcat_text_threadtime_dump_open, NULL },",
          "1449:  { \"Android Logcat Long text format\",       \"logcat-long\",       NULL, NULL,",
          "1450:    FALSE, FALSE, 0,",
          "1451:    logcat_dump_can_write_encap, logcat_text_long_dump_open, NULL }",
          "",
          "---------------"
        ],
        "wiretap/logcat.c||wiretap/logcat.c": [
          "File: wiretap/logcat.c -> wiretap/logcat.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "20: #include \"config.h\"",
          "22: #include <string.h>",
          "23: #include <time.h>",
          "25: #include \"wtap-int.h\"",
          "26: #include \"file_wrappers.h\"",
          "27: #include \"buffer.h\"",
          "29: #include \"logcat.h\"",
          "31: enum dump_type_t {",
          "32:     DUMP_BINARY,",
          "33:     DUMP_BRIEF,",
          "34:     DUMP_PROCESS,",
          "35:     DUMP_TAG,",
          "36:     DUMP_TIME,",
          "37:     DUMP_THREAD,",
          "38:     DUMP_THREADTIME,",
          "39:     DUMP_LONG",
          "40: };",
          "42: struct dumper_t {",
          "43:     enum dump_type_t type;",
          "44: };",
          "46: static gchar get_priority(const guint8 *priority) {",
          "47:     static gchar priorities[] = \"??VDIWEFS\";",
          "49:     if (*priority >= (guint8) sizeof(priorities))",
          "50:         return '?';",
          "52:     return priorities[(int) *priority];",
          "53: }",
          "55: static gchar *logcat_log(const struct dumper_t *dumper, guint32 seconds,",
          "56:         gint microseconds, gint pid, gint tid, gchar priority, const gchar *tag,",
          "57:         const gchar *log)",
          "58: {",
          "59:     gchar  time_buffer[15];",
          "60:     time_t datetime;",
          "62:     datetime = (time_t) seconds;",
          "64:     switch (dumper->type) {",
          "65:         case DUMP_BRIEF:",
          "66:             return g_strdup_printf(\"%c/%s(%5i): %s\\n\",",
          "67:                     priority, tag, pid, log);",
          "68:         case DUMP_PROCESS:",
          "69:             return g_strdup_printf(\"%c(%5i) %s  (%s)\\n\",",
          "70:                     priority, pid, log, tag);",
          "71:         case DUMP_TAG:",
          "72:             return g_strdup_printf(\"%c/%s: %s\\n\",",
          "73:                    priority, tag, log);",
          "74:         case DUMP_THREAD:",
          "75:             return g_strdup_printf(\"%c(%5i:%5i) %s\\n\",",
          "76:                     priority, pid, tid, log);",
          "77:         case DUMP_TIME:",
          "78:             strftime(time_buffer, sizeof(time_buffer), \"%m-%d %H:%M:%S\",",
          "79:                     gmtime(&datetime));",
          "80:             return g_strdup_printf(\"%s.%03i %c/%s(%5i): %s\\n\",",
          "81:                     time_buffer, microseconds, priority, tag, pid, log);",
          "82:         case DUMP_THREADTIME:",
          "83:             strftime(time_buffer, sizeof(time_buffer), \"%m-%d %H:%M:%S\",",
          "84:                     gmtime(&datetime));",
          "85:             return g_strdup_printf(\"%s.%03i %5i:%5i %c %s: %s\\n\",",
          "86:                     time_buffer, microseconds, pid, tid, priority, tag, log);",
          "87:         case DUMP_LONG:",
          "88:             strftime(time_buffer, sizeof(time_buffer), \"%m-%d %H:%M:%S\",",
          "89:                     gmtime(&datetime));",
          "90:             return g_strdup_printf(\"[ %s.%03i %5i:%5i %c/%s ]\\n%s\\n\\n\",",
          "91:                     time_buffer, microseconds, pid, tid, priority, tag, log);",
          "92:         default:",
          "93:             return NULL;",
          "94:     }",
          "96: }",
          "98: static gint detect_version(wtap *wth, int *err, gchar **err_info)",
          "99: {",
          "100:     gint     bytes_read;",
          "101:     guint16  payload_length;",
          "102:     guint16  try_header_size;",
          "103:     guint8  *buffer;",
          "104:     gint64   file_offset;",
          "105:     guint32  log_length;",
          "106:     guint32  tag_length;",
          "107:     guint16  tmp;",
          "109:     file_offset = file_tell(wth->fh);",
          "111:     bytes_read = file_read(&tmp, 2, wth->fh);",
          "112:     if (bytes_read != 2) {",
          "114:         if (*err == 0 && bytes_read != 0)",
          "116:         return -1;",
          "117:     }",
          "118:     payload_length = pletoh16(&tmp);",
          "120:     bytes_read = file_read(&tmp, 2, wth->fh);",
          "121:     if (bytes_read != 2) {",
          "123:         if (*err == 0 && bytes_read != 0)",
          "125:         return -1;",
          "126:     }",
          "127:     try_header_size = pletoh16(&tmp);",
          "129:     buffer = (guint8 *) g_malloc(5 * 4 + payload_length);",
          "130:     bytes_read = file_read(buffer, 5 * 4 + payload_length, wth->fh);",
          "131:     if (bytes_read != 5 * 4 + payload_length) {",
          "132:         if (bytes_read != 4 * 4 + payload_length) {",
          "134:             if (*err == 0 && bytes_read != 0)",
          "136:             g_free(buffer);",
          "137:             return -1;",
          "138:         }",
          "139:     }",
          "141:     if (try_header_size == 24) {",
          "142:         tag_length = strlen(buffer + 5 * 4 + 1) + 1;",
          "143:         log_length = strlen(buffer + 5 * 4 + 1 + tag_length) + 1;",
          "144:         if (payload_length == 1 + tag_length + log_length) {",
          "145:             g_free(buffer);",
          "146:             return 2;",
          "147:         }",
          "148:     }",
          "150:     tag_length = strlen(buffer + 4 * 4 + 1) + 1;",
          "151:     log_length = strlen(buffer + 4 * 4 + 1 + tag_length) + 1;",
          "152:     if (payload_length == 1 + tag_length + log_length) {",
          "153:         if (file_seek(wth->fh, file_offset + 4 * 4 + 1 + tag_length + log_length, SEEK_SET, err) == -1) {",
          "154:             g_free(buffer);",
          "155:             return -1;",
          "156:         }",
          "157:         g_free(buffer);",
          "158:         return 1;",
          "159:     }",
          "161:     g_free(buffer);",
          "162:     return 0;",
          "163: }",
          "165: static gboolean logcat_read(wtap *wth, int *err, gchar **err_info,",
          "166:     gint64 *data_offset)",
          "167: {",
          "168:     gint                 bytes_read;",
          "169:     gint                 packet_size;",
          "170:     guint16              payload_length;",
          "171:     guint16              tmp;",
          "172:     guint8              *buf;",
          "173:     struct logcat_phdr  *logcat;",
          "177:     bytes_read = file_read(&tmp, 2, wth->fh);",
          "178:     if (bytes_read != 2) {",
          "180:         if (*err == 0 && bytes_read != 0)",
          "182:         return FALSE;",
          "183:     }",
          "184:     payload_length = pletoh16(&tmp);",
          "186:     if (file_seek(wth->fh, *data_offset, SEEK_SET, err) == -1)",
          "187:         return FALSE;",
          "189:     logcat = (struct logcat_phdr *) wth->priv;",
          "191:     if (logcat->version == 1) {",
          "192:         packet_size = 5 * 4 + payload_length;",
          "193:     } else if (logcat->version == 2) {",
          "194:         packet_size = 6 * 4 + payload_length;",
          "195:     } else {",
          "196:         return FALSE;",
          "197:     }",
          "199:     buffer_assure_space(wth->frame_buffer, packet_size);",
          "200:     buf = buffer_start_ptr(wth->frame_buffer);",
          "202:     bytes_read = file_read(buf, packet_size, wth->fh);",
          "203:     if (bytes_read != packet_size) {",
          "205:         if (*err == 0)",
          "207:         return FALSE;",
          "208:     }",
          "210:     wth->phdr.presence_flags = WTAP_HAS_TS | WTAP_HAS_CAP_LEN;",
          "211:     wth->phdr.ts.secs = (time_t) pletoh32(buf + 12);",
          "212:     wth->phdr.ts.nsecs = (int) pletoh32(buf + 16);",
          "213:     wth->phdr.caplen = packet_size;",
          "214:     wth->phdr.len = packet_size;",
          "216:     wth->phdr.pseudo_header.logcat.version = logcat->version;",
          "218:     return TRUE;",
          "219: }",
          "221: static gboolean logcat_seek_read(wtap *wth, gint64 seek_off,",
          "222:     struct wtap_pkthdr *phdr, Buffer *buf,",
          "223:     int *err, gchar **err_info)",
          "224: {",
          "225:     gint                 bytes_read;",
          "226:     gint                 packet_size;",
          "227:     guint16              payload_length;",
          "228:     guint                tmp[4];",
          "229:     struct logcat_phdr  *logcat;",
          "231:     if (file_seek(wth->random_fh, seek_off, SEEK_SET, err) == -1)",
          "232:         return FALSE;",
          "234:     bytes_read = file_read(&tmp, 2, wth->random_fh);",
          "235:     if (bytes_read != 2) {",
          "237:         if (*err == 0 && bytes_read != 0)",
          "239:         return FALSE;",
          "240:     }",
          "241:     payload_length = pletoh16(tmp);",
          "243:     logcat = (struct logcat_phdr *) wth->priv;",
          "245:     if (logcat->version == 1) {",
          "246:         packet_size = 5 * 4 + payload_length;",
          "247:     } else if (logcat->version == 2) {",
          "248:         packet_size = 6 * 4 + payload_length;",
          "249:     } else {",
          "250:         return FALSE;",
          "251:     }",
          "253:     if (file_seek(wth->random_fh, seek_off + 12, SEEK_SET, err) == -1)",
          "254:         return FALSE;",
          "256:     bytes_read = file_read(&tmp, 4, wth->random_fh);",
          "257:     if (bytes_read != 4) {",
          "259:         if (*err == 0 && bytes_read != 0)",
          "261:         return FALSE;",
          "262:     }",
          "264:     phdr->ts.secs = (time_t) pletoh32(tmp);",
          "266:     bytes_read = file_read(tmp, 4, wth->random_fh);",
          "267:     if (bytes_read != 4) {",
          "269:         if (*err == 0 && bytes_read != 0)",
          "271:         return FALSE;",
          "272:     }",
          "274:     phdr->ts.nsecs = (int) pletoh32(tmp);",
          "276:     phdr->presence_flags = WTAP_HAS_TS | WTAP_HAS_CAP_LEN;",
          "277:     phdr->caplen = packet_size;",
          "278:     phdr->len = packet_size;",
          "280:     phdr->pseudo_header.logcat.version = logcat->version;",
          "282:     if (file_seek(wth->random_fh, seek_off, SEEK_SET, err) == -1)",
          "283:         return FALSE;",
          "285:     return wtap_read_packet_bytes(wth->random_fh, buf, packet_size, err, err_info);",
          "286: }",
          "288: int logcat_open(wtap *wth, int *err, gchar **err_info _U_)",
          "289: {",
          "290:     int                 local_err;",
          "291:     gchar              *local_err_info;",
          "292:     gint                version;",
          "293:     gint                tmp_version;",
          "294:     struct logcat_phdr *logcat;",
          "297:     version = detect_version(wth, &local_err, &local_err_info);",
          "298:     if (version <= 0)",
          "299:         return 0;",
          "301:     tmp_version = detect_version(wth, &local_err, &local_err_info);",
          "302:     if (tmp_version < 0 && !file_eof(wth->fh)) {",
          "303:         return 0;",
          "304:     } else if (tmp_version > 0) {",
          "305:         if (tmp_version != version)",
          "306:             return 0;",
          "308:         tmp_version = detect_version(wth, &local_err, &local_err_info);",
          "309:         if (tmp_version != version && !file_eof(wth->fh))",
          "310:             return 0;",
          "311:     }",
          "313:     if (file_seek(wth->fh, 0, SEEK_SET, err) == -1)",
          "314:         return -1;",
          "316:     logcat = (struct logcat_phdr *) g_malloc(sizeof(struct logcat_phdr));",
          "317:     logcat->version = version;",
          "319:     wth->priv = logcat;",
          "321:     wth->file_type_subtype = WTAP_FILE_TYPE_SUBTYPE_LOGCAT;",
          "322:     wth->file_encap = WTAP_ENCAP_LOGCAT;",
          "323:     wth->snapshot_length = 0;",
          "325:     wth->subtype_read = logcat_read;",
          "326:     wth->subtype_seek_read = logcat_seek_read;",
          "327:     wth->tsprecision = WTAP_FILE_TSPREC_USEC;",
          "329:     return 1;",
          "330: }",
          "332: int logcat_dump_can_write_encap(int encap)",
          "333: {",
          "334:     if (encap == WTAP_ENCAP_PER_PACKET)",
          "335:         return WTAP_ERR_ENCAP_PER_PACKET_UNSUPPORTED;",
          "337:     if (encap != WTAP_ENCAP_LOGCAT)",
          "338:         return WTAP_ERR_UNSUPPORTED_ENCAP;",
          "340:     return 0;",
          "341: }",
          "343: static gboolean logcat_binary_dump(wtap_dumper *wdh,",
          "344:     const struct wtap_pkthdr *phdr,",
          "345:     const guint8 *pd, int *err)",
          "346: {",
          "347:     if (!wtap_dump_file_write(wdh, pd, phdr->caplen, err))",
          "348:         return FALSE;",
          "350:     wdh->bytes_dumped += phdr->caplen;",
          "352:     return TRUE;",
          "353: }",
          "355: gboolean logcat_binary_dump_open(wtap_dumper *wdh, int *err)",
          "356: {",
          "357:     wdh->subtype_write = logcat_binary_dump;",
          "358:     wdh->subtype_close = NULL;",
          "360:     switch (wdh->file_type_subtype) {",
          "361:         case WTAP_FILE_TYPE_SUBTYPE_LOGCAT:",
          "362:             wdh->tsprecision = WTAP_FILE_TSPREC_USEC;",
          "363:             break;",
          "365:         default:",
          "367:             return FALSE;",
          "368:     }",
          "370:     return TRUE;",
          "371: }",
          "373: static gboolean logcat_dump_text(wtap_dumper *wdh,",
          "374:     const struct wtap_pkthdr *phdr,",
          "375:     const guint8 *pd, int *err)",
          "376: {",
          "377:     gchar                          *buf;",
          "378:     gint                            length;",
          "379:     gchar                           priority;",
          "380:     const gchar                    *tag;",
          "381:     const gint                     *pid;",
          "382:     const gint                     *tid;",
          "383:     const gchar                    *log;",
          "384:     gchar                          *log_part;",
          "385:     const gchar                    *str_begin;",
          "386:     const gchar                    *str_end;",
          "387:     const guint32                  *datetime;",
          "388:     const guint32                  *nanoseconds;",
          "389:     const union wtap_pseudo_header *pseudo_header = &phdr->pseudo_header;",
          "390:     const struct dumper_t          *dumper        = (const struct dumper_t *) wdh->priv;",
          "392:     if (pseudo_header->logcat.version == 1) {",
          "393:         pid = (const gint *) (pd + 4);",
          "394:         tid = (const gint *) (pd + 2 * 4);",
          "395:         datetime = (const guint32 *) (pd + 3 * 4);",
          "396:         nanoseconds = (const guint32 *) (pd + 4 * 4);",
          "397:         priority = get_priority((const guint8 *) (pd + 5 * 4));",
          "398:         tag = (const gchar *) (pd + 5 * 4 + 1);",
          "399:         log = tag + strlen(tag) + 1;",
          "400:     } else if (pseudo_header->logcat.version == 2) {",
          "401:         pid = (const gint *) (pd + 4);",
          "402:         tid = (const gint *) (pd + 2 * 4);",
          "403:         datetime = (const guint32 *) (pd + 3 * 4);",
          "404:         nanoseconds = (const guint32 *) (pd + 4 * 4);",
          "405:         priority = get_priority((const guint8 *) (pd + 6 * 4));",
          "406:         tag = (const char *) (pd + 6 * 4 + 1);",
          "407:         log = tag + strlen(tag) + 1;",
          "408:     } else {",
          "410:         return FALSE;",
          "411:     }",
          "413:     str_begin = str_end = log;",
          "414:     while (dumper->type != DUMP_LONG && (str_end = strchr(str_begin, '\\n'))) {",
          "415:         log_part = (gchar *) g_malloc(str_end - str_begin + 1);",
          "416:         strncpy(log_part, str_begin, str_end - str_begin);",
          "417:         log_part[str_end - str_begin] = '\\0';",
          "418:         str_begin = str_end + 1;",
          "420:         buf = logcat_log(dumper, *datetime, *nanoseconds / 1000000, *pid, *tid,",
          "421:                 priority, tag, log_part);",
          "422:         if (!buf) {",
          "423:             g_free(log_part);",
          "424:             return FALSE;",
          "425:         }",
          "426:         g_free(log_part);",
          "427:         length = strlen(buf);",
          "429:         if (!wtap_dump_file_write(wdh, buf, length, err)) {",
          "430:             g_free(buf);",
          "431:             return FALSE;",
          "432:         }",
          "434:         wdh->bytes_dumped += length;",
          "436:         g_free(buf);",
          "437:     }",
          "439:     if (*str_begin != '\\0') {",
          "440:         log_part = (gchar *) g_malloc(strlen(str_begin) + 1);",
          "441:         strncpy(log_part, str_begin, strlen(str_begin));",
          "442:         log_part[strlen(str_begin)] = '\\0';",
          "444:         buf = logcat_log(dumper, *datetime, *nanoseconds / 1000000, *pid, *tid,",
          "445:                 priority, tag, log_part);",
          "446:         if (!buf) {",
          "447:             g_free(log_part);",
          "448:             return FALSE;",
          "449:         }",
          "450:         g_free(log_part);",
          "451:         length = strlen(buf);",
          "453:         if (!wtap_dump_file_write(wdh, buf, length, err)) {",
          "454:             g_free(buf);",
          "455:             return FALSE;",
          "456:         }",
          "458:         wdh->bytes_dumped += length;",
          "459:         g_free(buf);",
          "460:     }",
          "462:     return TRUE;",
          "463: }",
          "465: gboolean logcat_text_brief_dump_open(wtap_dumper *wdh, int *err _U_)",
          "466: {",
          "467:     struct dumper_t *dumper;",
          "469:     dumper = (struct dumper_t *) g_malloc(sizeof(struct dumper_t));",
          "470:     dumper->type = DUMP_BRIEF;",
          "472:     wdh->priv = dumper;",
          "473:     wdh->subtype_write = logcat_dump_text;",
          "474:     wdh->subtype_close = NULL;",
          "476:     return TRUE;",
          "477: }",
          "479: gboolean logcat_text_process_dump_open(wtap_dumper *wdh, int *err _U_)",
          "480: {",
          "481:     struct dumper_t *dumper;",
          "483:     dumper = (struct dumper_t *) g_malloc(sizeof(struct dumper_t));",
          "484:     dumper->type = DUMP_PROCESS;",
          "486:     wdh->priv = dumper;",
          "487:     wdh->subtype_write = logcat_dump_text;",
          "488:     wdh->subtype_close = NULL;",
          "490:     return TRUE;",
          "491: }",
          "493: gboolean logcat_text_tag_dump_open(wtap_dumper *wdh, int *err _U_)",
          "494: {",
          "495:     struct dumper_t *dumper;",
          "497:     dumper = (struct dumper_t *) g_malloc(sizeof(struct dumper_t));",
          "498:     dumper->type = DUMP_TAG;",
          "500:     wdh->priv = dumper;",
          "501:     wdh->subtype_write = logcat_dump_text;",
          "502:     wdh->subtype_close = NULL;",
          "504:     return TRUE;",
          "505: }",
          "507: gboolean logcat_text_time_dump_open(wtap_dumper *wdh, int *err _U_)",
          "508: {",
          "509:     struct dumper_t *dumper;",
          "511:     dumper = (struct dumper_t *) g_malloc(sizeof(struct dumper_t));",
          "512:     dumper->type = DUMP_TIME;",
          "514:     wdh->priv = dumper;",
          "515:     wdh->subtype_write = logcat_dump_text;",
          "516:     wdh->subtype_close = NULL;",
          "518:     return TRUE;",
          "519: }",
          "521: gboolean logcat_text_thread_dump_open(wtap_dumper *wdh, int *err _U_)",
          "522: {",
          "523:     struct dumper_t *dumper;",
          "525:     dumper = (struct dumper_t *) g_malloc(sizeof(struct dumper_t));",
          "526:     dumper->type = DUMP_THREAD;",
          "528:     wdh->priv = dumper;",
          "529:     wdh->subtype_write = logcat_dump_text;",
          "530:     wdh->subtype_close = NULL;",
          "532:     return TRUE;",
          "533: }",
          "535: gboolean logcat_text_threadtime_dump_open(wtap_dumper *wdh, int *err _U_)",
          "536: {",
          "537:     struct dumper_t *dumper;",
          "539:     dumper = (struct dumper_t *) g_malloc(sizeof(struct dumper_t));",
          "540:     dumper->type = DUMP_THREADTIME;",
          "542:     wdh->priv = dumper;",
          "543:     wdh->subtype_write = logcat_dump_text;",
          "544:     wdh->subtype_close = NULL;",
          "546:     return TRUE;",
          "547: }",
          "549: gboolean logcat_text_long_dump_open(wtap_dumper *wdh, int *err _U_)",
          "550: {",
          "551:     struct dumper_t *dumper;",
          "553:     dumper = (struct dumper_t *) g_malloc(sizeof(struct dumper_t));",
          "554:     dumper->type = DUMP_LONG;",
          "556:     wdh->priv = dumper;",
          "557:     wdh->subtype_write = logcat_dump_text;",
          "558:     wdh->subtype_close = NULL;",
          "560:     return TRUE;",
          "561: }",
          "",
          "---------------"
        ],
        "wiretap/logcat.h||wiretap/logcat.h": [
          "File: wiretap/logcat.h -> wiretap/logcat.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "21: #ifndef __LOGCAT_H__",
          "22: #define __LOGCAT_H__",
          "24: #include <glib.h>",
          "26: #include \"wtap.h\"",
          "28: int      logcat_open(wtap *wth, int *err, gchar **err_info);",
          "30: gboolean logcat_binary_dump_open(wtap_dumper *wdh, int *err);",
          "31: gboolean logcat_text_brief_dump_open(wtap_dumper *wdh, int *err);",
          "32: gboolean logcat_text_process_dump_open(wtap_dumper *wdh, int *err);",
          "33: gboolean logcat_text_tag_dump_open(wtap_dumper *wdh, int *err);",
          "34: gboolean logcat_text_time_dump_open(wtap_dumper *wdh, int *err);",
          "35: gboolean logcat_text_thread_dump_open(wtap_dumper *wdh, int *err);",
          "36: gboolean logcat_text_threadtime_dump_open(wtap_dumper *wdh, int *err);",
          "37: gboolean logcat_text_long_dump_open(wtap_dumper *wdh, int *err);",
          "39: int      logcat_dump_can_write_encap(int encap);",
          "41: #endif",
          "",
          "---------------"
        ],
        "wiretap/wtap.h||wiretap/wtap.h": [
          "File: wiretap/wtap.h -> wiretap/wtap.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "254: #define WTAP_ENCAP_BLUETOOTH_BREDR_BB           161",
          "255: #define WTAP_ENCAP_BLUETOOTH_LE_LL_WITH_PHDR    162",
          "256: #define WTAP_ENCAP_NSTRACE_3_0                  163",
          "259: #define WTAP_NUM_ENCAP_TYPES                    wtap_get_num_encap_types()",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "257: #define WTAP_ENCAP_LOGCAT                       164",
          "258: #define WTAP_ENCAP_LOGCAT_BRIEF                 165",
          "259: #define WTAP_ENCAP_LOGCAT_PROCESS               166",
          "260: #define WTAP_ENCAP_LOGCAT_TAG                   167",
          "261: #define WTAP_ENCAP_LOGCAT_THREAD                168",
          "262: #define WTAP_ENCAP_LOGCAT_TIME                  169",
          "263: #define WTAP_ENCAP_LOGCAT_THREADTIME            170",
          "264: #define WTAP_ENCAP_LOGCAT_LONG                  171",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "330: #define WTAP_FILE_TYPE_SUBTYPE_CAMINS                        64",
          "331: #define WTAP_FILE_TYPE_SUBTYPE_STANAG_4607                   65",
          "332: #define WTAP_FILE_TYPE_SUBTYPE_NETSCALER_3_0                 66",
          "334: #define WTAP_NUM_FILE_TYPES_SUBTYPES  wtap_get_num_file_types_subtypes()",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "341: #define WTAP_FILE_TYPE_SUBTYPE_LOGCAT                        67",
          "342: #define WTAP_FILE_TYPE_SUBTYPE_LOGCAT_BRIEF                  68",
          "343: #define WTAP_FILE_TYPE_SUBTYPE_LOGCAT_PROCESS                69",
          "344: #define WTAP_FILE_TYPE_SUBTYPE_LOGCAT_TAG                    70",
          "345: #define WTAP_FILE_TYPE_SUBTYPE_LOGCAT_THREAD                 71",
          "346: #define WTAP_FILE_TYPE_SUBTYPE_LOGCAT_TIME                   72",
          "347: #define WTAP_FILE_TYPE_SUBTYPE_LOGCAT_THREADTIME             73",
          "348: #define WTAP_FILE_TYPE_SUBTYPE_LOGCAT_LONG                   74",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "865: #define GSM_UM_CHANNEL_AGCH     7",
          "866: #define GSM_UM_CHANNEL_PCH      8",
          "868: union wtap_pseudo_header {",
          "869:     struct eth_phdr     eth;",
          "870:     struct x25_phdr     x25;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "885: struct logcat_phdr {",
          "886:     gint version;",
          "887: };",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "890:     struct nstr_phdr    nstr;",
          "891:     struct nokia_phdr   nokia;",
          "892:     struct llcp_phdr    llcp;",
          "893: };",
          "895: struct wtap_pkthdr {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "914:     struct logcat_phdr  logcat;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "4a3d0b868473260c24aa66f5e3fa737b54a9fd02",
      "candidate_info": {
        "commit_hash": "4a3d0b868473260c24aa66f5e3fa737b54a9fd02",
        "repo": "wireshark/wireshark",
        "commit_url": "https://github.com/wireshark/wireshark/commit/4a3d0b868473260c24aa66f5e3fa737b54a9fd02",
        "files": [
          "wiretap/logcat.c"
        ],
        "message": "Logcat: Fix dump formats\n\nSome dump formats are not exactly what should be done,\nso fix them and try to little improve them (mostly by space padding %-8s)\n\nChange-Id: I8ee38479c848abc0a2eaff30ce733e4b60930ac4\nReviewed-on: https://code.wireshark.org/review/2550\nReviewed-by: Michal Labedzki <michal.labedzki@tieto.com>",
        "before_after_code_files": [
          "wiretap/logcat.c||wiretap/logcat.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "wiretap/logcat.c||wiretap/logcat.c"
          ],
          "candidate": [
            "wiretap/logcat.c||wiretap/logcat.c"
          ]
        }
      },
      "candidate_diff": {
        "wiretap/logcat.c||wiretap/logcat.c": [
          "File: wiretap/logcat.c -> wiretap/logcat.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "64:     switch (dumper->type) {",
          "65:         case DUMP_BRIEF:",
          "67:                     priority, tag, pid, log);",
          "68:         case DUMP_PROCESS:",
          "69:             return g_strdup_printf(\"%c(%5i) %s  (%s)\\n\",",
          "71:         case DUMP_TAG:",
          "73:                    priority, tag, log);",
          "74:         case DUMP_THREAD:",
          "76:                     priority, pid, tid, log);",
          "77:         case DUMP_TIME:",
          "78:             strftime(time_buffer, sizeof(time_buffer), \"%m-%d %H:%M:%S\",",
          "79:                     gmtime(&datetime));",
          "81:                     time_buffer, microseconds, priority, tag, pid, log);",
          "82:         case DUMP_THREADTIME:",
          "83:             strftime(time_buffer, sizeof(time_buffer), \"%m-%d %H:%M:%S\",",
          "84:                     gmtime(&datetime));",
          "86:                     time_buffer, microseconds, pid, tid, priority, tag, log);",
          "87:         case DUMP_LONG:",
          "88:             strftime(time_buffer, sizeof(time_buffer), \"%m-%d %H:%M:%S\",",
          "89:                     gmtime(&datetime));",
          "91:                     time_buffer, microseconds, pid, tid, priority, tag, log);",
          "92:         default:",
          "93:             return NULL;",
          "",
          "[Removed Lines]",
          "66:             return g_strdup_printf(\"%c/%s(%5i): %s\\n\",",
          "70:                     priority, pid, log, tag);",
          "72:             return g_strdup_printf(\"%c/%s: %s\\n\",",
          "75:             return g_strdup_printf(\"%c(%5i:%5i) %s\\n\",",
          "80:             return g_strdup_printf(\"%s.%03i %c/%s(%5i): %s\\n\",",
          "85:             return g_strdup_printf(\"%s.%03i %5i:%5i %c %s: %s\\n\",",
          "90:             return g_strdup_printf(\"[ %s.%03i %5i:%5i %c/%s ]\\n%s\\n\\n\",",
          "",
          "[Added Lines]",
          "66:             return g_strdup_printf(\"%c/%-8s(%5i): %s\\n\",",
          "72:                     priority, pid, log, \"\");",
          "74:             return g_strdup_printf(\"%c/%-8s: %s\\n\",",
          "77:             return g_strdup_printf(\"%c(%5i:0x%02x) %s\\n\",",
          "82:             return g_strdup_printf(\"%s.%03i %c/%-8s(%5i): %s\\n\",",
          "87:             return g_strdup_printf(\"%s.%03i %5i %5i %c %-8s: %s\\n\",",
          "92:             return g_strdup_printf(\"[ %s.%03i %5i:0x%02x %c/%s ]\\n%s\\n\\n\",",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "380:     str_begin = str_end = log;",
          "381:     while (dumper->type != DUMP_LONG && (str_end = strchr(str_begin, '\\n'))) {",
          "382:         log_part = (gchar *) g_malloc(str_end - str_begin + 1);",
          "385:         str_begin = str_end + 1;",
          "387:         buf = logcat_log(dumper, *datetime, *nanoseconds / 1000000, *pid, *tid,",
          "",
          "[Removed Lines]",
          "383:         g_strlcpy(log_part, str_begin, str_end - str_begin);",
          "384:         log_part[str_end - str_begin] = '\\0';",
          "",
          "[Added Lines]",
          "385:         g_strlcpy(log_part, str_begin, str_end - str_begin + 1);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "406:     if (*str_begin != '\\0') {",
          "407:         log_part = (gchar *) g_malloc(strlen(str_begin) + 1);",
          "411:         buf = logcat_log(dumper, *datetime, *nanoseconds / 1000000, *pid, *tid,",
          "412:                 priority, tag, log_part);",
          "",
          "[Removed Lines]",
          "408:         g_strlcpy(log_part, str_begin, strlen(str_begin));",
          "409:         log_part[strlen(str_begin)] = '\\0';",
          "",
          "[Added Lines]",
          "410:         g_strlcpy(log_part, str_begin, strlen(str_begin) + 1);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "ffd48cefa6c468d4cdadd5e562f0d3c63eb4a2d6",
      "candidate_info": {
        "commit_hash": "ffd48cefa6c468d4cdadd5e562f0d3c63eb4a2d6",
        "repo": "wireshark/wireshark",
        "commit_url": "https://github.com/wireshark/wireshark/commit/ffd48cefa6c468d4cdadd5e562f0d3c63eb4a2d6",
        "files": [
          "wiretap/ascend_scanner.l",
          "wiretap/commview.c",
          "wiretap/cosine.c",
          "wiretap/dbs-etherwatch.c",
          "wiretap/erf.c",
          "wiretap/i4b_trace.h",
          "wiretap/k12.c",
          "wiretap/logcat.c",
          "wiretap/netscaler.c",
          "wiretap/netscreen.h",
          "wiretap/nettl.c",
          "wiretap/netxray.c",
          "wiretap/pcap-common.c",
          "wiretap/pcapng.c",
          "wiretap/pppdump.c",
          "wiretap/toshiba.c",
          "wiretap/vms.c",
          "wiretap/wtap.c"
        ],
        "message": "Whitespace cleanups.\n\nChange-Id: I92f983b2e04defab30eb31c14c484b9f0f582413\nReviewed-on: https://code.wireshark.org/review/4513\nReviewed-by: Guy Harris <guy@alum.mit.edu>",
        "before_after_code_files": [
          "wiretap/ascend_scanner.l||wiretap/ascend_scanner.l",
          "wiretap/commview.c||wiretap/commview.c",
          "wiretap/cosine.c||wiretap/cosine.c",
          "wiretap/dbs-etherwatch.c||wiretap/dbs-etherwatch.c",
          "wiretap/erf.c||wiretap/erf.c",
          "wiretap/i4b_trace.h||wiretap/i4b_trace.h",
          "wiretap/k12.c||wiretap/k12.c",
          "wiretap/logcat.c||wiretap/logcat.c",
          "wiretap/netscaler.c||wiretap/netscaler.c",
          "wiretap/netscreen.h||wiretap/netscreen.h",
          "wiretap/nettl.c||wiretap/nettl.c",
          "wiretap/netxray.c||wiretap/netxray.c",
          "wiretap/pcap-common.c||wiretap/pcap-common.c",
          "wiretap/pcapng.c||wiretap/pcapng.c",
          "wiretap/pppdump.c||wiretap/pppdump.c",
          "wiretap/toshiba.c||wiretap/toshiba.c",
          "wiretap/vms.c||wiretap/vms.c",
          "wiretap/wtap.c||wiretap/wtap.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "wiretap/logcat.c||wiretap/logcat.c"
          ],
          "candidate": [
            "wiretap/logcat.c||wiretap/logcat.c"
          ]
        }
      },
      "candidate_diff": {
        "wiretap/ascend_scanner.l||wiretap/ascend_scanner.l": [
          "File: wiretap/ascend_scanner.l -> wiretap/ascend_scanner.l"
        ],
        "wiretap/commview.c||wiretap/commview.c": [
          "File: wiretap/commview.c -> wiretap/commview.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "48:  guint8  version;",
          "49:  guint16  year;",
          "50:  guint8  month;",
          "52:  guint8  hours;",
          "53:  guint8  minutes;",
          "54:  guint8  seconds;",
          "",
          "[Removed Lines]",
          "51:  guint8   day;",
          "",
          "[Added Lines]",
          "51:  guint8  day;",
          "",
          "---------------"
        ],
        "wiretap/cosine.c||wiretap/cosine.c": [
          "File: wiretap/cosine.c -> wiretap/cosine.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "158: #define COSINE_REC_MAGIC_STR2 COSINE_HDR_MAGIC_STR2",
          "160: #define COSINE_HEADER_LINES_TO_CHECK 200",
          "163: #define COSINE_MAX_PACKET_LEN 65536",
          "",
          "[Removed Lines]",
          "161: #define COSINE_LINE_LENGTH         240",
          "",
          "[Added Lines]",
          "161: #define COSINE_LINE_LENGTH  240",
          "",
          "---------------"
        ],
        "wiretap/dbs-etherwatch.c||wiretap/dbs-etherwatch.c": [
          "File: wiretap/dbs-etherwatch.c -> wiretap/dbs-etherwatch.c"
        ],
        "wiretap/erf.c||wiretap/erf.c": [
          "File: wiretap/erf.c -> wiretap/erf.c"
        ],
        "wiretap/i4b_trace.h||wiretap/i4b_trace.h": [
          "File: wiretap/i4b_trace.h -> wiretap/i4b_trace.h"
        ],
        "wiretap/k12.c||wiretap/k12.c": [
          "File: wiretap/k12.c -> wiretap/k12.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "522:     while (left > buffer_len) {",
          "524:         if (is_random) {",
          "525:             file_data->rand_read_buff = buffer;",
          "526:             file_data->rand_read_buff_len = buffer_len;",
          "",
          "[Removed Lines]",
          "523:      buffer = (guint8*)g_realloc(buffer,buffer_len*=2);",
          "",
          "[Added Lines]",
          "523:         buffer = (guint8*)g_realloc(buffer,buffer_len*=2);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1012:                ascii_strdown_inplace() call below) to be null-terminated;",
          "1013:                is that guaranteed (even with a corrupt file)?",
          "1017:             if (rec_len < K12_SRCDESC_EXTRATYPE + extra_len + name_len + stack_len) {",
          "",
          "[Removed Lines]",
          "1014:         Obviously not, as a corrupt file could contain anything",
          "1015:         here; the Tektronix document says the strings \"must end",
          "",
          "[Added Lines]",
          "1014:                Obviously not, as a corrupt file could contain anything",
          "1015:                here; the Tektronix document says the strings \"must end",
          "",
          "---------------"
        ],
        "wiretap/logcat.c||wiretap/logcat.c": [
          "File: wiretap/logcat.c -> wiretap/logcat.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "66:     if (!wtap_read_bytes_or_eof(fh, &tmp, 2, err, err_info)) {",
          "73:         if (*err == WTAP_ERR_SHORT_READ) {",
          "",
          "[Removed Lines]",
          "67:      if (*err == 0) {",
          "71:          return -2;",
          "72:      }",
          "",
          "[Added Lines]",
          "67:         if (*err == 0) {",
          "71:             return -2;",
          "72:         }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "119:                 continue;",
          "120:         }",
          "123:             g_free(buffer);",
          "124:             if (*err == WTAP_ERR_SHORT_READ) {",
          "",
          "[Removed Lines]",
          "122:  if (!wtap_read_bytes(fh, buffer + read_sofar, entry_len - read_sofar, err, err_info)) {",
          "",
          "[Added Lines]",
          "122:         if (!wtap_read_bytes(fh, buffer + read_sofar, entry_len - read_sofar, err, err_info)) {",
          "",
          "---------------"
        ],
        "wiretap/netscaler.c||wiretap/netscaler.c": [
          "File: wiretap/netscaler.c -> wiretap/netscaler.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1353:     if (!wtap_read_bytes(wth->random_fh, (void *)&hdr, sizeof hdr,",
          "1355:         return FALSE;",
          "",
          "[Removed Lines]",
          "1354:                               err, err_info))",
          "",
          "[Added Lines]",
          "1354:                          err, err_info))",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1366:     pd = ws_buffer_start_ptr(buf);",
          "1367:     memcpy(pd, (void *)&hdr, sizeof hdr);",
          "1368:     if (record_length > sizeof hdr) {",
          "1372:             return FALSE;",
          "1373:     }",
          "",
          "[Removed Lines]",
          "1369:      bytes_to_read = (unsigned int)(record_length - sizeof hdr);",
          "1370:      if (!wtap_read_bytes(wth->random_fh, pd + sizeof hdr, bytes_to_read,",
          "1371:                                err, err_info))",
          "",
          "[Added Lines]",
          "1369:         bytes_to_read = (unsigned int)(record_length - sizeof hdr);",
          "1370:         if (!wtap_read_bytes(wth->random_fh, pd + sizeof hdr, bytes_to_read,",
          "1371:                              err, err_info))",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1441:     if (hdr.phd_RecordSizeLow & NSPR_V20RECORDSIZE_2BYTES) {",
          "1442:         if (!wtap_read_bytes(wth->random_fh, (void *)&hdr.phd_RecordSizeHigh, 1,",
          "1444:             return FALSE;",
          "1445:         hdrlen = 3;",
          "1446:     }",
          "",
          "[Removed Lines]",
          "1443:                                   err, err_info))",
          "",
          "[Added Lines]",
          "1443:                              err, err_info))",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1457:     pd = ws_buffer_start_ptr(buf);",
          "1458:     memcpy(pd, (void *)&hdr, hdrlen);",
          "1459:     if (record_length > hdrlen) {",
          "1463:             return FALSE;",
          "1464:     }",
          "",
          "[Removed Lines]",
          "1460:      bytes_to_read = (unsigned int)(record_length - hdrlen);",
          "1461:      if (!wtap_read_bytes(wth->random_fh, pd + hdrlen, bytes_to_read,",
          "1462:                            err, err_info))",
          "",
          "[Added Lines]",
          "1460:         bytes_to_read = (unsigned int)(record_length - hdrlen);",
          "1461:         if (!wtap_read_bytes(wth->random_fh, pd + hdrlen, bytes_to_read,",
          "1462:                              err, err_info))",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1542:     if (hdr.phd_RecordSizeLow & NSPR_V20RECORDSIZE_2BYTES) {",
          "1545:             return FALSE;",
          "1546:         hdrlen = 3;",
          "1547:     }",
          "",
          "[Removed Lines]",
          "1543:      if (!wtap_read_bytes(wth->random_fh, (void *)&hdr.phd_RecordSizeHigh, 1,",
          "1544:                                err, err_info))",
          "",
          "[Added Lines]",
          "1543:         if (!wtap_read_bytes(wth->random_fh, (void *)&hdr.phd_RecordSizeHigh, 1,",
          "1544:                              err, err_info))",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1560:     if (record_length > hdrlen) {",
          "1561:         bytes_to_read = (unsigned int)(record_length - hdrlen);",
          "1562:         if (!wtap_read_bytes(wth->random_fh, pd + hdrlen, bytes_to_read,",
          "1564:             return FALSE;",
          "1565:     }",
          "",
          "[Removed Lines]",
          "1563:                                   err, err_info))",
          "",
          "[Added Lines]",
          "1563:                              err, err_info))",
          "",
          "---------------"
        ],
        "wiretap/netscreen.h||wiretap/netscreen.h": [
          "File: wiretap/netscreen.h -> wiretap/netscreen.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "37: #define NETSCREEN_REC_MAGIC_STR1 NETSCREEN_HDR_MAGIC_STR1",
          "38: #define NETSCREEN_REC_MAGIC_STR2 NETSCREEN_HDR_MAGIC_STR2",
          "41: #define NETSCREEN_HEADER_LINES_TO_CHECK 32",
          "42: #define NETSCREEN_MAX_INFOLINES  8",
          "43: #define NETSCREEN_SPACES_ON_INFO_LINE 14",
          "",
          "[Removed Lines]",
          "40: #define NETSCREEN_LINE_LENGTH         128",
          "",
          "[Added Lines]",
          "40: #define NETSCREEN_LINE_LENGTH  128",
          "",
          "---------------"
        ],
        "wiretap/nettl.c||wiretap/nettl.c": [
          "File: wiretap/nettl.c -> wiretap/nettl.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "239:         case NETTL_SUBSYS_EISA_FDDI :",
          "240:         case NETTL_SUBSYS_PCI_FDDI :",
          "241:         case NETTL_SUBSYS_HSC_FDDI :",
          "244:         case NETTL_SUBSYS_TOKEN :",
          "245:         case NETTL_SUBSYS_PCI_TR :",
          "248:         case NETTL_SUBSYS_NS_LS_IP :",
          "249:         case NETTL_SUBSYS_NS_LS_LOOPBACK :",
          "250:         case NETTL_SUBSYS_NS_LS_TCP :",
          "251:         case NETTL_SUBSYS_NS_LS_UDP :",
          "252:         case NETTL_SUBSYS_NS_LS_IPV6 :",
          "255:         case NETTL_SUBSYS_NS_LS_ICMP :",
          "258:         case NETTL_SUBSYS_NS_LS_ICMPV6 :",
          "261:         case NETTL_SUBSYS_NS_LS_TELNET :",
          "267:     }",
          "269:     if (file_seek(wth->fh, FILE_HDR_SIZE, SEEK_SET, err) == -1) {",
          "271:     }",
          "272:     wth->file_tsprec = WTAP_TSPREC_USEC;",
          "",
          "[Removed Lines]",
          "242:   wth->file_encap = WTAP_ENCAP_NETTL_FDDI;",
          "243:   break;",
          "246:   wth->file_encap = WTAP_ENCAP_NETTL_TOKEN_RING;",
          "247:   break;",
          "253:   wth->file_encap = WTAP_ENCAP_NETTL_RAW_IP;",
          "254:   break;",
          "256:   wth->file_encap = WTAP_ENCAP_NETTL_RAW_ICMP;",
          "257:   break;",
          "259:   wth->file_encap = WTAP_ENCAP_NETTL_RAW_ICMPV6;",
          "260:   break;",
          "262:   wth->file_encap = WTAP_ENCAP_NETTL_RAW_TELNET;",
          "263:   break;",
          "264:  default:",
          "266:   wth->file_encap = WTAP_ENCAP_NETTL_ETHERNET;",
          "270:  return -1;",
          "",
          "[Added Lines]",
          "242:                 wth->file_encap = WTAP_ENCAP_NETTL_FDDI;",
          "243:                 break;",
          "246:                 wth->file_encap = WTAP_ENCAP_NETTL_TOKEN_RING;",
          "247:                 break;",
          "253:                 wth->file_encap = WTAP_ENCAP_NETTL_RAW_IP;",
          "254:                 break;",
          "256:                 wth->file_encap = WTAP_ENCAP_NETTL_RAW_ICMP;",
          "257:                 break;",
          "259:                 wth->file_encap = WTAP_ENCAP_NETTL_RAW_ICMPV6;",
          "260:                 break;",
          "262:                 wth->file_encap = WTAP_ENCAP_NETTL_RAW_TELNET;",
          "263:                 break;",
          "264:         default:",
          "266:                 wth->file_encap = WTAP_ENCAP_NETTL_ETHERNET;",
          "270:         return -1;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "283:     if (!nettl_read_rec(wth, wth->fh, &wth->phdr, wth->frame_buffer,",
          "284:         err, err_info)) {",
          "287:     }",
          "",
          "[Removed Lines]",
          "286:  return FALSE;",
          "",
          "[Added Lines]",
          "286:         return FALSE;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "297:     if (wth->file_encap == WTAP_ENCAP_UNKNOWN)",
          "299:     else {",
          "302:     }",
          "304:     return TRUE;",
          "",
          "[Removed Lines]",
          "298:  wth->file_encap = wth->phdr.pkt_encap;",
          "300:  if (wth->file_encap != wth->phdr.pkt_encap)",
          "301:      wth->file_encap = WTAP_ENCAP_PER_PACKET;",
          "",
          "[Added Lines]",
          "298:         wth->file_encap = wth->phdr.pkt_encap;",
          "300:         if (wth->file_encap != wth->phdr.pkt_encap)",
          "301:             wth->file_encap = WTAP_ENCAP_PER_PACKET;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "307: static gboolean",
          "308: nettl_seek_read(wtap *wth, gint64 seek_off, struct wtap_pkthdr *phdr,",
          "310: {",
          "311:     if (file_seek(wth->random_fh, seek_off, SEEK_SET, err) == -1)",
          "315:     if (!nettl_read_rec(wth, wth->random_fh, phdr, buf, err, err_info)) {",
          "322:     }",
          "323:     return TRUE;",
          "324: }",
          "326: static gboolean",
          "327: nettl_read_rec(wtap *wth, FILE_T fh, struct wtap_pkthdr *phdr, Buffer *buf,",
          "329: {",
          "330:     union wtap_pseudo_header *pseudo_header = &phdr->pseudo_header;",
          "331:     nettl_t *nettl = (nettl_t *)wth->priv;",
          "",
          "[Removed Lines]",
          "309:   Buffer *buf, int *err, gchar **err_info)",
          "312:  return FALSE;",
          "317:  if (*err == 0) {",
          "320:  }",
          "321:  return FALSE;",
          "328:   int *err, gchar **err_info)",
          "",
          "[Added Lines]",
          "309:                 Buffer *buf, int *err, gchar **err_info)",
          "312:         return FALSE;",
          "317:         if (*err == 0) {",
          "320:         }",
          "321:         return FALSE;",
          "328:                 int *err, gchar **err_info)",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "344:     errno = WTAP_ERR_CANT_READ;",
          "345:     if (!wtap_read_bytes_or_eof(fh, &rec_hdr.hdr_len, sizeof rec_hdr.hdr_len,",
          "346:                           err, err_info))",
          "348:     hdr_len = g_ntohs(rec_hdr.hdr_len);",
          "349:     if (hdr_len < NETTL_REC_HDR_LEN) {",
          "354:     }",
          "355:     if (!wtap_read_bytes(fh, &rec_hdr.subsys, NETTL_REC_HDR_LEN - 2,",
          "356:                               err, err_info))",
          "358:     subsys = g_ntohs(rec_hdr.subsys);",
          "359:     hdr_len -= NETTL_REC_HDR_LEN;",
          "360:     if (file_seek(fh, hdr_len, SEEK_CUR, err) == -1)",
          "363:     if ( (pntoh32(&rec_hdr.kind) & NETTL_HDR_PDU_MASK) == 0 ) {",
          "",
          "[Removed Lines]",
          "347:  return FALSE;",
          "352:      hdr_len);",
          "353:  return FALSE;",
          "357:  return FALSE;",
          "361:  return FALSE;",
          "",
          "[Added Lines]",
          "347:         return FALSE;",
          "352:             hdr_len);",
          "353:         return FALSE;",
          "357:         return FALSE;",
          "361:         return FALSE;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "367:         caplen = pntoh32(&rec_hdr.caplen);",
          "368:         padlen = 0;",
          "369:     } else switch (subsys) {",
          "391:         case NETTL_SUBSYS_PCI_FDDI :",
          "392:         case NETTL_SUBSYS_HSC_FDDI :",
          "393:         case NETTL_SUBSYS_TOKEN :",
          "394:         case NETTL_SUBSYS_PCI_TR :",
          "436:                 if (pntoh32(&rec_hdr.kind) == NETTL_HDR_PDUIN) {",
          "438:                        there are an extra 3 bytes after the DSAP and SSAP",
          "",
          "[Removed Lines]",
          "370:  case NETTL_SUBSYS_LAN100 :",
          "371:  case NETTL_SUBSYS_EISA100BT :",
          "372:  case NETTL_SUBSYS_BASE100 :",
          "373:  case NETTL_SUBSYS_GSC100BT :",
          "374:  case NETTL_SUBSYS_PCI100BT :",
          "375:  case NETTL_SUBSYS_SPP100BT :",
          "376:  case NETTL_SUBSYS_100VG :",
          "377:  case NETTL_SUBSYS_GELAN :",
          "378:  case NETTL_SUBSYS_BTLAN :",
          "379:  case NETTL_SUBSYS_INTL100 :",
          "380:  case NETTL_SUBSYS_IGELAN :",
          "381:  case NETTL_SUBSYS_IETHER :",
          "382:  case NETTL_SUBSYS_IXGBE :",
          "383:  case NETTL_SUBSYS_HSSN :",
          "384:  case NETTL_SUBSYS_IGSSN :",
          "385:  case NETTL_SUBSYS_ICXGBE :",
          "386:  case NETTL_SUBSYS_IEXGBE :",
          "387:  case NETTL_SUBSYS_IOCXGBE :",
          "388:  case NETTL_SUBSYS_IQXGBE :",
          "389:  case NETTL_SUBSYS_HPPB_FDDI :",
          "390:  case NETTL_SUBSYS_EISA_FDDI :",
          "395:  case NETTL_SUBSYS_NS_LS_IP :",
          "396:  case NETTL_SUBSYS_NS_LS_LOOPBACK :",
          "397:  case NETTL_SUBSYS_NS_LS_TCP :",
          "398:  case NETTL_SUBSYS_NS_LS_UDP :",
          "399:  case NETTL_SUBSYS_HP_APAPORT :",
          "400:  case NETTL_SUBSYS_HP_APALACP :",
          "401:  case NETTL_SUBSYS_NS_LS_IPV6 :",
          "402:  case NETTL_SUBSYS_NS_LS_ICMPV6 :",
          "403:  case NETTL_SUBSYS_NS_LS_ICMP :",
          "404:  case NETTL_SUBSYS_NS_LS_TELNET :",
          "405:  case NETTL_SUBSYS_NS_LS_SCTP :",
          "406:      if( (subsys == NETTL_SUBSYS_NS_LS_IP)",
          "407:       || (subsys == NETTL_SUBSYS_NS_LS_LOOPBACK)",
          "408:       || (subsys == NETTL_SUBSYS_NS_LS_UDP)",
          "409:       || (subsys == NETTL_SUBSYS_NS_LS_TCP)",
          "410:       || (subsys == NETTL_SUBSYS_NS_LS_SCTP)",
          "411:       || (subsys == NETTL_SUBSYS_NS_LS_IPV6)) {",
          "412:   phdr->pkt_encap = WTAP_ENCAP_NETTL_RAW_IP;",
          "413:      } else if (subsys == NETTL_SUBSYS_NS_LS_ICMP) {",
          "414:   phdr->pkt_encap = WTAP_ENCAP_NETTL_RAW_ICMP;",
          "415:      } else if (subsys == NETTL_SUBSYS_NS_LS_ICMPV6) {",
          "416:   phdr->pkt_encap = WTAP_ENCAP_NETTL_RAW_ICMPV6;",
          "417:      } else if (subsys == NETTL_SUBSYS_NS_LS_TELNET) {",
          "418:   phdr->pkt_encap = WTAP_ENCAP_NETTL_RAW_TELNET;",
          "419:      } else if( (subsys == NETTL_SUBSYS_HPPB_FDDI)",
          "420:       || (subsys == NETTL_SUBSYS_EISA_FDDI)",
          "421:       || (subsys == NETTL_SUBSYS_PCI_FDDI)",
          "422:       || (subsys == NETTL_SUBSYS_HSC_FDDI) ) {",
          "423:   phdr->pkt_encap = WTAP_ENCAP_NETTL_FDDI;",
          "424:      } else if( (subsys == NETTL_SUBSYS_PCI_TR)",
          "425:       || (subsys == NETTL_SUBSYS_TOKEN) ) {",
          "426:   phdr->pkt_encap = WTAP_ENCAP_NETTL_TOKEN_RING;",
          "427:      } else {",
          "428:   phdr->pkt_encap = WTAP_ENCAP_NETTL_ETHERNET;",
          "429:      }",
          "431:      length = pntoh32(&rec_hdr.length);",
          "432:      caplen = pntoh32(&rec_hdr.caplen);",
          "435:      if (subsys == NETTL_SUBSYS_HPPB_FDDI) {",
          "",
          "[Added Lines]",
          "370:         case NETTL_SUBSYS_LAN100 :",
          "371:         case NETTL_SUBSYS_EISA100BT :",
          "372:         case NETTL_SUBSYS_BASE100 :",
          "373:         case NETTL_SUBSYS_GSC100BT :",
          "374:         case NETTL_SUBSYS_PCI100BT :",
          "375:         case NETTL_SUBSYS_SPP100BT :",
          "376:         case NETTL_SUBSYS_100VG :",
          "377:         case NETTL_SUBSYS_GELAN :",
          "378:         case NETTL_SUBSYS_BTLAN :",
          "379:         case NETTL_SUBSYS_INTL100 :",
          "380:         case NETTL_SUBSYS_IGELAN :",
          "381:         case NETTL_SUBSYS_IETHER :",
          "382:         case NETTL_SUBSYS_IXGBE :",
          "383:         case NETTL_SUBSYS_HSSN :",
          "384:         case NETTL_SUBSYS_IGSSN :",
          "385:         case NETTL_SUBSYS_ICXGBE :",
          "386:         case NETTL_SUBSYS_IEXGBE :",
          "387:         case NETTL_SUBSYS_IOCXGBE :",
          "388:         case NETTL_SUBSYS_IQXGBE :",
          "389:         case NETTL_SUBSYS_HPPB_FDDI :",
          "390:         case NETTL_SUBSYS_EISA_FDDI :",
          "395:         case NETTL_SUBSYS_NS_LS_IP :",
          "396:         case NETTL_SUBSYS_NS_LS_LOOPBACK :",
          "397:         case NETTL_SUBSYS_NS_LS_TCP :",
          "398:         case NETTL_SUBSYS_NS_LS_UDP :",
          "399:         case NETTL_SUBSYS_HP_APAPORT :",
          "400:         case NETTL_SUBSYS_HP_APALACP :",
          "401:         case NETTL_SUBSYS_NS_LS_IPV6 :",
          "402:         case NETTL_SUBSYS_NS_LS_ICMPV6 :",
          "403:         case NETTL_SUBSYS_NS_LS_ICMP :",
          "404:         case NETTL_SUBSYS_NS_LS_TELNET :",
          "405:         case NETTL_SUBSYS_NS_LS_SCTP :",
          "406:             if( (subsys == NETTL_SUBSYS_NS_LS_IP)",
          "407:              || (subsys == NETTL_SUBSYS_NS_LS_LOOPBACK)",
          "408:              || (subsys == NETTL_SUBSYS_NS_LS_UDP)",
          "409:              || (subsys == NETTL_SUBSYS_NS_LS_TCP)",
          "410:              || (subsys == NETTL_SUBSYS_NS_LS_SCTP)",
          "411:              || (subsys == NETTL_SUBSYS_NS_LS_IPV6)) {",
          "412:                 phdr->pkt_encap = WTAP_ENCAP_NETTL_RAW_IP;",
          "413:             } else if (subsys == NETTL_SUBSYS_NS_LS_ICMP) {",
          "414:                 phdr->pkt_encap = WTAP_ENCAP_NETTL_RAW_ICMP;",
          "415:             } else if (subsys == NETTL_SUBSYS_NS_LS_ICMPV6) {",
          "416:                 phdr->pkt_encap = WTAP_ENCAP_NETTL_RAW_ICMPV6;",
          "417:             } else if (subsys == NETTL_SUBSYS_NS_LS_TELNET) {",
          "418:                 phdr->pkt_encap = WTAP_ENCAP_NETTL_RAW_TELNET;",
          "419:             } else if( (subsys == NETTL_SUBSYS_HPPB_FDDI)",
          "420:                     || (subsys == NETTL_SUBSYS_EISA_FDDI)",
          "421:                     || (subsys == NETTL_SUBSYS_PCI_FDDI)",
          "422:                     || (subsys == NETTL_SUBSYS_HSC_FDDI) ) {",
          "423:                 phdr->pkt_encap = WTAP_ENCAP_NETTL_FDDI;",
          "424:             } else if( (subsys == NETTL_SUBSYS_PCI_TR)",
          "425:                     || (subsys == NETTL_SUBSYS_TOKEN) ) {",
          "426:                 phdr->pkt_encap = WTAP_ENCAP_NETTL_TOKEN_RING;",
          "427:             } else {",
          "428:                 phdr->pkt_encap = WTAP_ENCAP_NETTL_ETHERNET;",
          "429:             }",
          "431:             length = pntoh32(&rec_hdr.length);",
          "432:             caplen = pntoh32(&rec_hdr.caplen);",
          "435:             if (subsys == NETTL_SUBSYS_HPPB_FDDI) {",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "441:                     fddihack=TRUE;",
          "442:                     padlen = 0;",
          "443:                 } else {",
          "457:                 if (file_seek(fh, 3, SEEK_CUR, err) == -1)",
          "458:                     return FALSE;",
          "459:                 padlen = 3;",
          "462:                 if (file_seek(fh, 26, SEEK_CUR, err) == -1)",
          "463:                     return FALSE;",
          "464:                 padlen = 26;",
          "",
          "[Removed Lines]",
          "445:              if (!wtap_read_bytes(fh, dummyc, 9, err, err_info))",
          "446:    return FALSE;",
          "448:       padlen = (int)dummyc[8];",
          "449:       if (file_seek(fh, padlen, SEEK_CUR, err) == -1)",
          "450:    return FALSE;",
          "451:       padlen += 9;",
          "452:   }",
          "453:      } else if ( (subsys == NETTL_SUBSYS_PCI_FDDI)",
          "454:               || (subsys == NETTL_SUBSYS_EISA_FDDI)",
          "455:               || (subsys == NETTL_SUBSYS_HSC_FDDI) ) {",
          "460:      } else if (subsys == NETTL_SUBSYS_NS_LS_LOOPBACK) {",
          "",
          "[Added Lines]",
          "445:                     if (!wtap_read_bytes(fh, dummyc, 9, err, err_info))",
          "446:                         return FALSE;",
          "448:                     padlen = (int)dummyc[8];",
          "449:                     if (file_seek(fh, padlen, SEEK_CUR, err) == -1)",
          "450:                         return FALSE;",
          "451:                     padlen += 9;",
          "452:                 }",
          "453:             } else if ( (subsys == NETTL_SUBSYS_PCI_FDDI)",
          "454:                      || (subsys == NETTL_SUBSYS_EISA_FDDI)",
          "455:                      || (subsys == NETTL_SUBSYS_HSC_FDDI) ) {",
          "460:             } else if (subsys == NETTL_SUBSYS_NS_LS_LOOPBACK) {",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "476:                 if (file_seek(fh, 8, SEEK_CUR, err) == -1)",
          "477:                     return FALSE;",
          "478:                 padlen = 8;",
          "502:             if (nettl->is_hpux_11) {",
          "503:                 if (file_seek(fh, 2, SEEK_CUR, err) == -1) return FALSE;",
          "504:             }",
          "541:             length = pntoh32(&rec_hdr.length);",
          "542:             caplen = pntoh32(&rec_hdr.caplen);",
          "543:             padlen = 0;",
          "",
          "[Removed Lines]",
          "479:      } else {",
          "480:       padlen = 0;",
          "481:      }",
          "482:      break;",
          "484:  case NETTL_SUBSYS_NS_LS_DRIVER :",
          "488:      phdr->pkt_encap = WTAP_ENCAP_NETTL_ETHERNET;",
          "489:      if (!wtap_read_bytes(fh, &drv_eth_hdr, NS_LS_DRV_ETH_HDR_LEN,",
          "490:                                err, err_info))",
          "491:   return FALSE;",
          "493:      length = pntoh16(&drv_eth_hdr.length);",
          "494:      caplen = pntoh16(&drv_eth_hdr.caplen);",
          "505:      padlen = 0;",
          "506:      break;",
          "508:  case NETTL_SUBSYS_SX25L2:",
          "509:  case NETTL_SUBSYS_SX25L3:",
          "528:      phdr->pkt_encap = WTAP_ENCAP_NETTL_X25;",
          "529:      length = pntoh32(&rec_hdr.length);",
          "530:      caplen = pntoh32(&rec_hdr.caplen);",
          "532:      if (file_seek(fh, padlen, SEEK_CUR, err) == -1)",
          "533:   return FALSE;",
          "534:      break;",
          "536:  default:",
          "539:      wth->file_encap = WTAP_ENCAP_PER_PACKET;",
          "540:      phdr->pkt_encap = WTAP_ENCAP_NETTL_ETHERNET;",
          "",
          "[Added Lines]",
          "479:             } else {",
          "480:                 padlen = 0;",
          "481:             }",
          "482:             break;",
          "484:         case NETTL_SUBSYS_NS_LS_DRIVER :",
          "488:             phdr->pkt_encap = WTAP_ENCAP_NETTL_ETHERNET;",
          "489:             if (!wtap_read_bytes(fh, &drv_eth_hdr, NS_LS_DRV_ETH_HDR_LEN,",
          "490:                                       err, err_info))",
          "491:                 return FALSE;",
          "493:             length = pntoh16(&drv_eth_hdr.length);",
          "494:             caplen = pntoh16(&drv_eth_hdr.caplen);",
          "505:             padlen = 0;",
          "506:             break;",
          "508:         case NETTL_SUBSYS_SX25L2:",
          "509:         case NETTL_SUBSYS_SX25L3:",
          "528:             phdr->pkt_encap = WTAP_ENCAP_NETTL_X25;",
          "529:             length = pntoh32(&rec_hdr.length);",
          "530:             caplen = pntoh32(&rec_hdr.caplen);",
          "532:             if (file_seek(fh, padlen, SEEK_CUR, err) == -1)",
          "533:                 return FALSE;",
          "534:             break;",
          "536:         default:",
          "539:             wth->file_encap = WTAP_ENCAP_PER_PACKET;",
          "540:             phdr->pkt_encap = WTAP_ENCAP_NETTL_ETHERNET;",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "545:     }",
          "547:     if (length < padlen) {",
          "552:     }",
          "553:     phdr->rec_type = REC_TYPE_PACKET;",
          "554:     phdr->presence_flags = WTAP_HAS_TS|WTAP_HAS_CAP_LEN;",
          "555:     phdr->len = length - padlen;",
          "556:     if (caplen < padlen) {",
          "561:     }",
          "562:     datalen = caplen - padlen;",
          "563:     phdr->caplen = datalen;",
          "",
          "[Removed Lines]",
          "550:      length, padlen);",
          "551:  return FALSE;",
          "559:      caplen, padlen);",
          "560:  return FALSE;",
          "",
          "[Added Lines]",
          "550:             length, padlen);",
          "551:         return FALSE;",
          "559:             caplen, padlen);",
          "560:         return FALSE;",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "571:     pseudo_header->nettl.uid      = pntoh16(&rec_hdr.uid);",
          "573:     if (phdr->caplen > WTAP_MAX_PACKET_SIZE) {",
          "582:     }",
          "",
          "[Removed Lines]",
          "580:      phdr->caplen, WTAP_MAX_PACKET_SIZE);",
          "581:  return FALSE;",
          "",
          "[Added Lines]",
          "580:             phdr->caplen, WTAP_MAX_PACKET_SIZE);",
          "581:         return FALSE;",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "609:             datalen -= bytes_to_read;",
          "610:             if (datalen == 0) {",
          "614:         }",
          "615:         if (!wtap_read_bytes(fh, pd + 15, datalen, err, err_info))",
          "616:             return FALSE;",
          "617:     } else {",
          "620:     }",
          "622:     return TRUE;",
          "",
          "[Removed Lines]",
          "612:   return TRUE;",
          "613:      }",
          "618:      if (!wtap_read_bytes(fh, pd, datalen, err, err_info))",
          "619:          return FALSE;",
          "",
          "[Added Lines]",
          "612:                 return TRUE;",
          "613:             }",
          "618:         if (!wtap_read_bytes(fh, pd, datalen, err, err_info))",
          "619:             return FALSE;",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "630: int nettl_dump_can_write_encap(int encap)",
          "631: {",
          "654: }",
          "",
          "[Removed Lines]",
          "633:  switch (encap) {",
          "634:   case WTAP_ENCAP_ETHERNET:",
          "635:   case WTAP_ENCAP_FDDI_BITSWAPPED:",
          "636:   case WTAP_ENCAP_TOKEN_RING:",
          "637:   case WTAP_ENCAP_NETTL_ETHERNET:",
          "638:   case WTAP_ENCAP_NETTL_FDDI:",
          "639:   case WTAP_ENCAP_NETTL_TOKEN_RING:",
          "640:   case WTAP_ENCAP_NETTL_RAW_IP:",
          "641:   case WTAP_ENCAP_NETTL_RAW_ICMP:",
          "642:   case WTAP_ENCAP_NETTL_RAW_ICMPV6:",
          "643:   case WTAP_ENCAP_NETTL_RAW_TELNET:",
          "645:   case WTAP_ENCAP_NETTL_X25:",
          "647:   case WTAP_ENCAP_PER_PACKET:",
          "648:   case WTAP_ENCAP_UNKNOWN:",
          "649:   case WTAP_ENCAP_NETTL_UNKNOWN:",
          "650:    return 0;",
          "651:   default:",
          "652:    return WTAP_ERR_UNSUPPORTED_ENCAP;",
          "653:  }",
          "",
          "[Added Lines]",
          "633:         switch (encap) {",
          "634:                 case WTAP_ENCAP_ETHERNET:",
          "635:                 case WTAP_ENCAP_FDDI_BITSWAPPED:",
          "636:                 case WTAP_ENCAP_TOKEN_RING:",
          "637:                 case WTAP_ENCAP_NETTL_ETHERNET:",
          "638:                 case WTAP_ENCAP_NETTL_FDDI:",
          "639:                 case WTAP_ENCAP_NETTL_TOKEN_RING:",
          "640:                 case WTAP_ENCAP_NETTL_RAW_IP:",
          "641:                 case WTAP_ENCAP_NETTL_RAW_ICMP:",
          "642:                 case WTAP_ENCAP_NETTL_RAW_ICMPV6:",
          "643:                 case WTAP_ENCAP_NETTL_RAW_TELNET:",
          "645:                 case WTAP_ENCAP_NETTL_X25:",
          "647:                 case WTAP_ENCAP_PER_PACKET:",
          "648:                 case WTAP_ENCAP_UNKNOWN:",
          "649:                 case WTAP_ENCAP_NETTL_UNKNOWN:",
          "650:                         return 0;",
          "651:                 default:",
          "652:                         return WTAP_ERR_UNSUPPORTED_ENCAP;",
          "653:         }",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "659: gboolean nettl_dump_open(wtap_dumper *wdh, int *err)",
          "660: {",
          "682: }",
          "686: static gboolean nettl_dump(wtap_dumper *wdh,",
          "689: {",
          "757: #if 0",
          "767: #endif",
          "805:         wdh->bytes_dumped += phdr->caplen;",
          "808: }",
          "",
          "[Removed Lines]",
          "661:  struct nettl_file_hdr file_hdr;",
          "664:  wdh->subtype_write = nettl_dump;",
          "665:  wdh->subtype_close = NULL;",
          "668:  memset(&file_hdr,0,sizeof(file_hdr));",
          "669:  memcpy(file_hdr.magic,nettl_magic_hpux10,sizeof(file_hdr.magic));",
          "670:  g_strlcpy(file_hdr.file_name,\"/tmp/wireshark.TRC000\",NETTL_FILENAME_SIZE);",
          "671:  g_strlcpy(file_hdr.tz,\"UTC\",20);",
          "672:  g_strlcpy(file_hdr.host_name,\"\",9);",
          "673:  g_strlcpy(file_hdr.os_vers,\"B.11.11\",9);",
          "674:  file_hdr.os_v=0x55;",
          "675:  g_strlcpy(file_hdr.model,\"9000/800\",11);",
          "676:  file_hdr.unknown=g_htons(0x406);",
          "677:  if (!wtap_dump_file_write(wdh, &file_hdr, sizeof file_hdr, err))",
          "678:   return FALSE;",
          "679:  wdh->bytes_dumped += sizeof(file_hdr);",
          "681:  return TRUE;",
          "687:  const struct wtap_pkthdr *phdr,",
          "688:  const guint8 *pd, int *err)",
          "690:  const union wtap_pseudo_header *pseudo_header = &phdr->pseudo_header;",
          "691:  struct nettlrec_hdr rec_hdr;",
          "692:  guint8 dummyc[24];",
          "695:  if (phdr->rec_type != REC_TYPE_PACKET) {",
          "697:   return FALSE;",
          "698:  }",
          "701:  if (phdr->caplen > WTAP_MAX_PACKET_SIZE) {",
          "703:   return FALSE;",
          "704:  }",
          "706:  memset(&rec_hdr,0,sizeof(rec_hdr));",
          "708:  rec_hdr.hdr_len = g_htons(sizeof(rec_hdr) + 4);",
          "709:  rec_hdr.kind = g_htonl(NETTL_HDR_PDUIN);",
          "710:  rec_hdr.sec = g_htonl(phdr->ts.secs);",
          "711:  rec_hdr.usec = g_htonl(phdr->ts.nsecs/1000);",
          "712:  rec_hdr.caplen = g_htonl(phdr->caplen);",
          "713:  rec_hdr.length = g_htonl(phdr->len);",
          "714:  rec_hdr.devid = -1;",
          "715:  rec_hdr.pid = -1;",
          "716:  rec_hdr.uid = -1;",
          "718:  switch (phdr->pkt_encap) {",
          "720:   case WTAP_ENCAP_NETTL_FDDI:",
          "722:    rec_hdr.caplen = g_htonl(phdr->caplen + 3);",
          "723:    rec_hdr.length = g_htonl(phdr->len + 3);",
          "725:   case WTAP_ENCAP_NETTL_ETHERNET:",
          "726:   case WTAP_ENCAP_NETTL_TOKEN_RING:",
          "727:   case WTAP_ENCAP_NETTL_RAW_IP:",
          "728:   case WTAP_ENCAP_NETTL_RAW_ICMP:",
          "729:   case WTAP_ENCAP_NETTL_RAW_ICMPV6:",
          "730:   case WTAP_ENCAP_NETTL_RAW_TELNET:",
          "731:   case WTAP_ENCAP_NETTL_UNKNOWN:",
          "732:    rec_hdr.subsys = g_htons(pseudo_header->nettl.subsys);",
          "733:    rec_hdr.devid = g_htonl(pseudo_header->nettl.devid);",
          "734:    rec_hdr.kind = g_htonl(pseudo_header->nettl.kind);",
          "735:    rec_hdr.pid = g_htonl(pseudo_header->nettl.pid);",
          "736:    rec_hdr.uid = g_htons(pseudo_header->nettl.uid);",
          "737:    break;",
          "739:   case WTAP_ENCAP_RAW_IP:",
          "740:    rec_hdr.subsys = g_htons(NETTL_SUBSYS_NS_LS_IP);",
          "741:    break;",
          "743:   case WTAP_ENCAP_ETHERNET:",
          "744:    rec_hdr.subsys = g_htons(NETTL_SUBSYS_BTLAN);",
          "745:    break;",
          "747:   case WTAP_ENCAP_FDDI_BITSWAPPED:",
          "748:    rec_hdr.subsys = g_htons(NETTL_SUBSYS_PCI_FDDI);",
          "750:    rec_hdr.caplen = g_htonl(phdr->caplen + 3);",
          "751:    rec_hdr.length = g_htonl(phdr->len + 3);",
          "752:    break;",
          "754:   case WTAP_ENCAP_TOKEN_RING:",
          "755:    rec_hdr.subsys = g_htons(NETTL_SUBSYS_PCI_TR);",
          "756:    break;",
          "758:   case WTAP_ENCAP_NETTL_X25:",
          "759:    rec_hdr.caplen = g_htonl(phdr->caplen + 24);",
          "760:    rec_hdr.length = g_htonl(phdr->len + 24);",
          "761:    rec_hdr.subsys = g_htons(pseudo_header->nettl.subsys);",
          "762:    rec_hdr.devid = g_htonl(pseudo_header->nettl.devid);",
          "763:    rec_hdr.kind = g_htonl(pseudo_header->nettl.kind);",
          "764:    rec_hdr.pid = g_htonl(pseudo_header->nettl.pid);",
          "765:    rec_hdr.uid = g_htons(pseudo_header->nettl.uid);",
          "766:    break;",
          "768:   default:",
          "771:    return FALSE;",
          "772:  }",
          "774:  if (!wtap_dump_file_write(wdh, &rec_hdr, sizeof(rec_hdr), err))",
          "775:   return FALSE;",
          "776:  wdh->bytes_dumped += sizeof(rec_hdr);",
          "781:  memset(dummyc, 0, sizeof dummyc);",
          "782:  if (!wtap_dump_file_write(wdh, dummyc, 4, err))",
          "783:   return FALSE;",
          "784:  wdh->bytes_dumped += 4;",
          "786:  if ((phdr->pkt_encap == WTAP_ENCAP_FDDI_BITSWAPPED) ||",
          "787:      (phdr->pkt_encap == WTAP_ENCAP_NETTL_FDDI)) {",
          "789:   if (!wtap_dump_file_write(wdh, dummyc, 3, err))",
          "790:    return FALSE;",
          "791:          wdh->bytes_dumped += 3;",
          "792:  }",
          "794:  } else if (phdr->pkt_encap == WTAP_ENCAP_NETTL_X25) {",
          "795:   if (!wtap_dump_file_write(wdh, dummyc, 24, err))",
          "796:    return FALSE;",
          "797:   wdh->bytes_dumped += 24;",
          "798:  }",
          "803:  if (!wtap_dump_file_write(wdh, pd, phdr->caplen, err))",
          "804:   return FALSE;",
          "807:  return TRUE;",
          "",
          "[Added Lines]",
          "661:         struct nettl_file_hdr file_hdr;",
          "664:         wdh->subtype_write = nettl_dump;",
          "665:         wdh->subtype_close = NULL;",
          "668:         memset(&file_hdr,0,sizeof(file_hdr));",
          "669:         memcpy(file_hdr.magic,nettl_magic_hpux10,sizeof(file_hdr.magic));",
          "670:         g_strlcpy(file_hdr.file_name,\"/tmp/wireshark.TRC000\",NETTL_FILENAME_SIZE);",
          "671:         g_strlcpy(file_hdr.tz,\"UTC\",20);",
          "672:         g_strlcpy(file_hdr.host_name,\"\",9);",
          "673:         g_strlcpy(file_hdr.os_vers,\"B.11.11\",9);",
          "674:         file_hdr.os_v=0x55;",
          "675:         g_strlcpy(file_hdr.model,\"9000/800\",11);",
          "676:         file_hdr.unknown=g_htons(0x406);",
          "677:         if (!wtap_dump_file_write(wdh, &file_hdr, sizeof file_hdr, err))",
          "678:                 return FALSE;",
          "679:         wdh->bytes_dumped += sizeof(file_hdr);",
          "681:         return TRUE;",
          "687:         const struct wtap_pkthdr *phdr,",
          "688:         const guint8 *pd, int *err)",
          "690:         const union wtap_pseudo_header *pseudo_header = &phdr->pseudo_header;",
          "691:         struct nettlrec_hdr rec_hdr;",
          "692:         guint8 dummyc[24];",
          "695:         if (phdr->rec_type != REC_TYPE_PACKET) {",
          "697:                 return FALSE;",
          "698:         }",
          "701:         if (phdr->caplen > WTAP_MAX_PACKET_SIZE) {",
          "703:                 return FALSE;",
          "704:         }",
          "706:         memset(&rec_hdr,0,sizeof(rec_hdr));",
          "708:         rec_hdr.hdr_len = g_htons(sizeof(rec_hdr) + 4);",
          "709:         rec_hdr.kind = g_htonl(NETTL_HDR_PDUIN);",
          "710:         rec_hdr.sec = g_htonl(phdr->ts.secs);",
          "711:         rec_hdr.usec = g_htonl(phdr->ts.nsecs/1000);",
          "712:         rec_hdr.caplen = g_htonl(phdr->caplen);",
          "713:         rec_hdr.length = g_htonl(phdr->len);",
          "714:         rec_hdr.devid = -1;",
          "715:         rec_hdr.pid = -1;",
          "716:         rec_hdr.uid = -1;",
          "718:         switch (phdr->pkt_encap) {",
          "720:                 case WTAP_ENCAP_NETTL_FDDI:",
          "722:                         rec_hdr.caplen = g_htonl(phdr->caplen + 3);",
          "723:                         rec_hdr.length = g_htonl(phdr->len + 3);",
          "725:                 case WTAP_ENCAP_NETTL_ETHERNET:",
          "726:                 case WTAP_ENCAP_NETTL_TOKEN_RING:",
          "727:                 case WTAP_ENCAP_NETTL_RAW_IP:",
          "728:                 case WTAP_ENCAP_NETTL_RAW_ICMP:",
          "729:                 case WTAP_ENCAP_NETTL_RAW_ICMPV6:",
          "730:                 case WTAP_ENCAP_NETTL_RAW_TELNET:",
          "731:                 case WTAP_ENCAP_NETTL_UNKNOWN:",
          "732:                         rec_hdr.subsys = g_htons(pseudo_header->nettl.subsys);",
          "733:                         rec_hdr.devid = g_htonl(pseudo_header->nettl.devid);",
          "734:                         rec_hdr.kind = g_htonl(pseudo_header->nettl.kind);",
          "735:                         rec_hdr.pid = g_htonl(pseudo_header->nettl.pid);",
          "736:                         rec_hdr.uid = g_htons(pseudo_header->nettl.uid);",
          "737:                         break;",
          "739:                 case WTAP_ENCAP_RAW_IP:",
          "740:                         rec_hdr.subsys = g_htons(NETTL_SUBSYS_NS_LS_IP);",
          "741:                         break;",
          "743:                 case WTAP_ENCAP_ETHERNET:",
          "744:                         rec_hdr.subsys = g_htons(NETTL_SUBSYS_BTLAN);",
          "745:                         break;",
          "747:                 case WTAP_ENCAP_FDDI_BITSWAPPED:",
          "748:                         rec_hdr.subsys = g_htons(NETTL_SUBSYS_PCI_FDDI);",
          "750:                         rec_hdr.caplen = g_htonl(phdr->caplen + 3);",
          "751:                         rec_hdr.length = g_htonl(phdr->len + 3);",
          "752:                         break;",
          "754:                 case WTAP_ENCAP_TOKEN_RING:",
          "755:                         rec_hdr.subsys = g_htons(NETTL_SUBSYS_PCI_TR);",
          "756:                         break;",
          "758:                 case WTAP_ENCAP_NETTL_X25:",
          "759:                         rec_hdr.caplen = g_htonl(phdr->caplen + 24);",
          "760:                         rec_hdr.length = g_htonl(phdr->len + 24);",
          "761:                         rec_hdr.subsys = g_htons(pseudo_header->nettl.subsys);",
          "762:                         rec_hdr.devid = g_htonl(pseudo_header->nettl.devid);",
          "763:                         rec_hdr.kind = g_htonl(pseudo_header->nettl.kind);",
          "764:                         rec_hdr.pid = g_htonl(pseudo_header->nettl.pid);",
          "765:                         rec_hdr.uid = g_htons(pseudo_header->nettl.uid);",
          "766:                         break;",
          "768:                 default:",
          "771:                         return FALSE;",
          "772:         }",
          "774:         if (!wtap_dump_file_write(wdh, &rec_hdr, sizeof(rec_hdr), err))",
          "775:                 return FALSE;",
          "776:         wdh->bytes_dumped += sizeof(rec_hdr);",
          "781:         memset(dummyc, 0, sizeof dummyc);",
          "782:         if (!wtap_dump_file_write(wdh, dummyc, 4, err))",
          "783:                 return FALSE;",
          "784:         wdh->bytes_dumped += 4;",
          "786:         if ((phdr->pkt_encap == WTAP_ENCAP_FDDI_BITSWAPPED) ||",
          "787:             (phdr->pkt_encap == WTAP_ENCAP_NETTL_FDDI)) {",
          "789:                 if (!wtap_dump_file_write(wdh, dummyc, 3, err))",
          "790:                         return FALSE;",
          "791:                 wdh->bytes_dumped += 3;",
          "792:         }",
          "794:         } else if (phdr->pkt_encap == WTAP_ENCAP_NETTL_X25) {",
          "795:                 if (!wtap_dump_file_write(wdh, dummyc, 24, err))",
          "796:                         return FALSE;",
          "797:                 wdh->bytes_dumped += 24;",
          "798:         }",
          "803:         if (!wtap_dump_file_write(wdh, pd, phdr->caplen, err))",
          "804:                 return FALSE;",
          "807:         return TRUE;",
          "",
          "---------------"
        ],
        "wiretap/netxray.c||wiretap/netxray.c": [
          "File: wiretap/netxray.c -> wiretap/netxray.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1202:         if (netxray->fcs_valid) {",
          "",
          "[Added Lines]",
          "1202:     if (netxray->fcs_valid) {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1243:         if (netxray->fcs_valid) {",
          "",
          "[Added Lines]",
          "1243:     if (netxray->fcs_valid) {",
          "",
          "---------------"
        ],
        "wiretap/pcap-common.c||wiretap/pcap-common.c": [
          "File: wiretap/pcap-common.c -> wiretap/pcap-common.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "329:  { 183,  WTAP_ENCAP_JUNIPER_VP },",
          "335:  { 188,  WTAP_ENCAP_IEEE802_16_MAC_CPS },",
          "341:  { 192,  WTAP_ENCAP_PPI },",
          "",
          "[Removed Lines]",
          "331:  { 186,   WTAP_ENCAP_USB },",
          "333:  { 187,   WTAP_ENCAP_BLUETOOTH_H4 },",
          "337:  { 189,   WTAP_ENCAP_USB_LINUX },",
          "339:  { 190,   WTAP_ENCAP_CAN20B },",
          "",
          "[Added Lines]",
          "331:  { 186,  WTAP_ENCAP_USB },",
          "333:  { 187,  WTAP_ENCAP_BLUETOOTH_H4 },",
          "337:  { 189,  WTAP_ENCAP_USB_LINUX },",
          "339:  { 190,  WTAP_ENCAP_CAN20B },",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "349:  { 199,  WTAP_ENCAP_IPMB },",
          "353:  { 202,  WTAP_ENCAP_AX25_KISS },",
          "357:  { 204,  WTAP_ENCAP_PPP_WITH_PHDR },",
          "359:  { 209,  WTAP_ENCAP_I2C },",
          "371:  { 215,  WTAP_ENCAP_IEEE802_15_4_NONASK_PHY },",
          "375:  { 224,  WTAP_ENCAP_FIBRE_CHANNEL_FC2 },",
          "",
          "[Removed Lines]",
          "351:  { 201,   WTAP_ENCAP_BLUETOOTH_H4_WITH_PHDR },",
          "355:  { 203,   WTAP_ENCAP_LAPD },",
          "361:  { 210,   WTAP_ENCAP_FLEXRAY },",
          "363:  { 211,   WTAP_ENCAP_MOST },",
          "365:  { 212,   WTAP_ENCAP_LIN },",
          "367:  { 213,   WTAP_ENCAP_X2E_SERIAL },",
          "369:  { 214,   WTAP_ENCAP_X2E_XORAYA },",
          "373:  { 220,   WTAP_ENCAP_USB_LINUX_MMAPPED },",
          "",
          "[Added Lines]",
          "351:  { 201,  WTAP_ENCAP_BLUETOOTH_H4_WITH_PHDR },",
          "355:  { 203,  WTAP_ENCAP_LAPD },",
          "361:  { 210,  WTAP_ENCAP_FLEXRAY },",
          "363:  { 211,  WTAP_ENCAP_MOST },",
          "365:  { 212,  WTAP_ENCAP_LIN },",
          "367:  { 213,  WTAP_ENCAP_X2E_SERIAL },",
          "369:  { 214,  WTAP_ENCAP_X2E_XORAYA },",
          "373:  { 220,  WTAP_ENCAP_USB_LINUX_MMAPPED },",
          "",
          "---------------"
        ],
        "wiretap/pcapng.c||wiretap/pcapng.c": [
          "File: wiretap/pcapng.c -> wiretap/pcapng.c"
        ],
        "wiretap/pppdump.c||wiretap/pppdump.c": [
          "File: wiretap/pppdump.c -> wiretap/pppdump.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "355:  if (!collate(state, wth->fh, err, err_info, buf, &num_bytes, &direction,",
          "356:      pid, 0)) {",
          "358:    g_free(pid);",
          "359:   return FALSE;",
          "360:  }",
          "",
          "[Removed Lines]",
          "357:       if (pid != NULL)",
          "",
          "[Added Lines]",
          "357:   if (pid != NULL)",
          "",
          "---------------"
        ],
        "wiretap/toshiba.c||wiretap/toshiba.c": [
          "File: wiretap/toshiba.c -> wiretap/toshiba.c"
        ],
        "wiretap/vms.c||wiretap/vms.c": [
          "File: wiretap/vms.c -> wiretap/vms.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "360:      num_items_scanned = sscanf(p,",
          "363:            &tm.tm_year, &tm.tm_hour,",
          "364:            &tm.tm_min, &tm.tm_sec, &csec);",
          "366:      if (num_items_scanned != 8) {",
          "367:        num_items_scanned = sscanf(p,",
          "372:      }",
          "375:      if (num_items_scanned != 8) {",
          "378:   return FALSE;",
          "379:      }",
          "380:  }",
          "393:      break;",
          "395:     } while (! isdumpline(line));",
          "397:     p = strstr(months, mon);",
          "398:     if (p)",
          "400:     tm.tm_year -= 1900;",
          "401:     tm.tm_isdst = -1;",
          "",
          "[Removed Lines]",
          "361:              \"packet %9d at %2d-%3s-%4d %2d:%2d:%2d.%9d\",",
          "362:              &pktnum, &tm.tm_mday, mon,",
          "368:                \"packet seq # = %9d at %2d-%3s-%4d %2d:%2d:%2d.%9d\",",
          "369:                &pktnum, &tm.tm_mday, mon,",
          "370:              &tm.tm_year, &tm.tm_hour,",
          "371:              &tm.tm_min, &tm.tm_sec, &csec);",
          "381:         if ( (! pkt_len) && (p = strstr(line, \"Length\"))) {",
          "382:             p += sizeof(\"Length \");",
          "383:             while (*p && ! isdigit((guchar)*p))",
          "384:                 p++;",
          "386:             if ( !*p ) {",
          "389:                 return FALSE;",
          "390:             }",
          "392:             pkt_len = atoi(p);",
          "394:         }",
          "399:         tm.tm_mon = (int) (p - months) / 3;",
          "",
          "[Added Lines]",
          "361:            \"packet %9d at %2d-%3s-%4d %2d:%2d:%2d.%9d\",",
          "362:            &pktnum, &tm.tm_mday, mon,",
          "368:       \"packet seq # = %9d at %2d-%3s-%4d %2d:%2d:%2d.%9d\",",
          "369:       &pktnum, &tm.tm_mday, mon,",
          "370:       &tm.tm_year, &tm.tm_hour,",
          "371:       &tm.tm_min, &tm.tm_sec, &csec);",
          "381:  if ( (! pkt_len) && (p = strstr(line, \"Length\"))) {",
          "382:      p += sizeof(\"Length \");",
          "383:      while (*p && ! isdigit((guchar)*p))",
          "384:   p++;",
          "386:      if ( !*p ) {",
          "389:   return FALSE;",
          "390:      }",
          "392:      pkt_len = atoi(p);",
          "394:  }",
          "399:  tm.tm_mon = (int) (p - months) / 3;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "415:     for (i = 0; i < pkt_len; i += 16) {",
          "423:  line[VMS_LINE_LENGTH] = '\\0';",
          "428:       if (*err == 0) {",
          "430:       }",
          "431:       return FALSE;",
          "432:   }",
          "433:   line[VMS_LINE_LENGTH] = '\\0';",
          "434:      }",
          "437:  }",
          "438:  if (!parse_single_hex_dump_line(line, pd, i,",
          "439:      offset, pkt_len - i)) {",
          "444:     }",
          "",
          "[Removed Lines]",
          "416:         if (file_gets(line, VMS_LINE_LENGTH, fh) == NULL) {",
          "418:             if (*err == 0) {",
          "420:             }",
          "421:             return FALSE;",
          "422:         }",
          "424:         if (i == 0) {",
          "426:          if (file_gets(line, VMS_LINE_LENGTH, fh) == NULL) {",
          "435:             while (line[offset] && !isxdigit((guchar)line[offset]))",
          "436:                 offset++;",
          "442:             return FALSE;",
          "443:         }",
          "",
          "[Added Lines]",
          "416:  if (file_gets(line, VMS_LINE_LENGTH, fh) == NULL) {",
          "418:      if (*err == 0) {",
          "420:      }",
          "421:      return FALSE;",
          "422:  }",
          "424:  if (i == 0) {",
          "426:   if (file_gets(line, VMS_LINE_LENGTH, fh) == NULL) {",
          "435:      while (line[offset] && !isxdigit((guchar)line[offset]))",
          "436:   offset++;",
          "442:      return FALSE;",
          "443:  }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "451:     if (!file_gets(line, VMS_LINE_LENGTH, fh)) {",
          "459:     }",
          "460:     return TRUE;",
          "461: }",
          "",
          "[Removed Lines]",
          "453:         if (*err == 0) {",
          "456:             return TRUE;",
          "457:         }",
          "458:         return FALSE;",
          "",
          "[Added Lines]",
          "453:  if (*err == 0) {",
          "456:      return TRUE;",
          "457:  }",
          "458:  return FALSE;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "495:     if (value != byte_offset) {",
          "497:     }",
          "499:     if (remaining > 16)",
          "",
          "[Removed Lines]",
          "496:         return FALSE;",
          "",
          "[Added Lines]",
          "496:  return FALSE;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "506:     for (i = 0; i < remaining; i++) {",
          "511:     }",
          "513:     return TRUE;",
          "",
          "[Removed Lines]",
          "507:         lbuf[0] = rec[offsets[i] + in_off];",
          "508:         lbuf[1] = rec[offsets[i] + 1 + in_off];",
          "510:         buf[byte_offset + i] = (guint8) strtoul(lbuf, NULL, 16);",
          "",
          "[Added Lines]",
          "507:  lbuf[0] = rec[offsets[i] + in_off];",
          "508:  lbuf[1] = rec[offsets[i] + 1 + in_off];",
          "510:  buf[byte_offset + i] = (guint8) strtoul(lbuf, NULL, 16);",
          "",
          "---------------"
        ],
        "wiretap/wtap.c||wiretap/wtap.c": [
          "File: wiretap/wtap.c -> wiretap/wtap.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "646:  { \"BACnet MS/TP with Directional Info\", \"bacnet-ms-tp-with-direction\" },",
          "652:  { \"IEEE 802.11 plus AiroPeek radio header\", \"ieee-802-11-airopeek\" },",
          "",
          "[Removed Lines]",
          "649:   { \"IxVeriWave header and stats block\", \"ixveriwave\" },",
          "",
          "[Added Lines]",
          "649:  { \"IxVeriWave header and stats block\", \"ixveriwave\" },",
          "",
          "---------------"
        ]
      }
    }
  ]
}
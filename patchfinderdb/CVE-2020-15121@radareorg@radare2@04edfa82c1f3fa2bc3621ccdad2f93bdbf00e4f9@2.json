{
  "cve_id": "CVE-2020-15121",
  "cve_desc": "In radare2 before version 4.5.0, malformed PDB file names in the PDB server path cause shell injection. To trigger the problem it's required to open the executable in radare2 and run idpd to trigger the download. The shell code will execute, and will create a file called pwned in the current directory.",
  "repo": "radareorg/radare2",
  "patch_hash": "04edfa82c1f3fa2bc3621ccdad2f93bdbf00e4f9",
  "patch_info": {
    "commit_hash": "04edfa82c1f3fa2bc3621ccdad2f93bdbf00e4f9",
    "repo": "radareorg/radare2",
    "commit_url": "https://github.com/radareorg/radare2/commit/04edfa82c1f3fa2bc3621ccdad2f93bdbf00e4f9",
    "files": [
      "libr/bin/pdb/pdb_downloader.c",
      "libr/config.mk.tail",
      "libr/include/r_socket.h",
      "libr/include/r_types.h",
      "libr/include/r_util/r_str.h",
      "libr/socket/socket.c",
      "libr/socket/socket_http.c",
      "libr/util/str.c",
      "libr/util/sys.c",
      "meson.build",
      "shlr/sdb/src/disk.c",
      "test/db/formats/pdb",
      "test/unit/test_str.c"
    ],
    "message": "Fix command injection on PDB download (#16966)\n\n* Fix r_sys_mkdirp with absolute path on Windows\n* Fix build with --with-openssl\n* Use RBuffer in r_socket_http_answer()\n* r_socket_http_answer: Fix read for big responses\n* Implement r_str_escape_sh()\n* Cleanup r_socket_connect() on Windows\n* Fix socket being created without a protocol\n* Fix socket connect with SSL ##socket\n* Use select() in r_socket_ready()\n* Fix read failing if received only protocol answer\n* Fix double-free\n* r_socket_http_get: Fail if req. SSL with no support\n* Follow redirects in r_socket_http_answer()\n* Fix r_socket_http_get result length with R2_CURL=1\n* Also follow redirects\n* Avoid using curl for downloading PDBs\n* Use r_socket_http_get() on UNIXs\n* Use WinINet API on Windows for r_socket_http_get()\n* Fix command injection\n* Fix r_sys_cmd_str_full output for binary data\n* Validate GUID on PDB download\n* Pass depth to socket_http_get_recursive()\n* Remove 'r_' and '__' from static function names\n* Fix is_valid_guid\n* Fix for comments",
    "before_after_code_files": [
      "libr/bin/pdb/pdb_downloader.c||libr/bin/pdb/pdb_downloader.c",
      "libr/config.mk.tail||libr/config.mk.tail",
      "libr/include/r_socket.h||libr/include/r_socket.h",
      "libr/include/r_types.h||libr/include/r_types.h",
      "libr/include/r_util/r_str.h||libr/include/r_util/r_str.h",
      "libr/socket/socket.c||libr/socket/socket.c",
      "libr/socket/socket_http.c||libr/socket/socket_http.c",
      "libr/util/str.c||libr/util/str.c",
      "libr/util/sys.c||libr/util/sys.c",
      "meson.build||meson.build",
      "shlr/sdb/src/disk.c||shlr/sdb/src/disk.c",
      "test/unit/test_str.c||test/unit/test_str.c"
    ]
  },
  "patch_diff": {
    "libr/bin/pdb/pdb_downloader.c||libr/bin/pdb/pdb_downloader.c": [
      "File: libr/bin/pdb/pdb_downloader.c -> libr/bin/pdb/pdb_downloader.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "18:  return true;",
      "19: }",
      "24:   return false;",
      "25:  }",
      "26:  return true;",
      "27: }",
      "29: static int download(struct SPDBDownloader *pd) {",
      "30:  SPDBDownloaderOpt *opt = pd->opt;",
      "44:  int res = 0;",
      "45:  int cmd_ret;",
      "46:  if (!opt->dbg_file || !*opt->dbg_file) {",
      "48:   return 0;",
      "49:  }",
      "76:  if (r_file_exists (abspath_to_file)) {",
      "77:   eprintf (\"File already downloaded.\\n\");",
      "87:   return 1;",
      "88:  }",
      "90:  if (checkExtract () || opt->extract == 0) {",
      "100: #if __WINDOWS__",
      "110: #else",
      "113:   char *abspath_to_dir = r_file_dirname (abspath_to_archive);",
      "119: #endif",
      "127:    if (res && ((cmd_ret = r_sys_cmd (extractor_cmd)) != 0)) {",
      "128:     eprintf (\"cab extractor exited with error %d\\n\", cmd_ret);",
      "129:     res = 0;",
      "130:    }",
      "131:    r_file_rm (abspath_to_archive);",
      "132:   }",
      "134:  }",
      "135:  if (res == 0) {",
      "136:   eprintf (\"Falling back to uncompressed pdb\\n\");",
      "148:   eprintf (\"Attempting to download uncompressed pdb in %s\\n\", abspath_to_file);",
      "165:  return res;",
      "166: }",
      "",
      "[Removed Lines]",
      "21: static bool checkCurl() {",
      "22:  const char nul[] = R_SYS_DEVNULL;",
      "23:  if (r_sys_cmdf (\"curl --version > %s\", nul) != 0) {",
      "31:  char *curl_cmd = NULL;",
      "32:  char *extractor_cmd = NULL;",
      "33:  char *abspath_to_archive = NULL;",
      "34:  char *abspath_to_file = NULL;",
      "35:  char *archive_name = NULL;",
      "36:  size_t archive_name_len = 0;",
      "37:  char *symbol_store_path = NULL;",
      "38:  char *dbg_file = NULL;",
      "39:  char *guid = NULL;",
      "40:  char *archive_name_escaped  = NULL;",
      "41:  char *user_agent = NULL;",
      "42:  char *symbol_server = NULL;",
      "50:  if (!checkCurl ()) {",
      "51:   return 0;",
      "52:  }",
      "54:  archive_name_len = strlen (opt->dbg_file);",
      "55:  archive_name = malloc (archive_name_len + 1);",
      "56:  if (!archive_name) {",
      "57:   return 0;",
      "58:  }",
      "59:  memcpy (archive_name, opt->dbg_file, archive_name_len + 1);",
      "60:  archive_name[archive_name_len - 1] = '_';",
      "61:  symbol_store_path = r_str_escape (opt->symbol_store_path);",
      "62:  dbg_file = r_str_escape (opt->dbg_file);",
      "63:  guid = r_str_escape (opt->guid);",
      "64:  archive_name_escaped = r_str_escape (archive_name);",
      "65:  user_agent = r_str_escape (opt->user_agent);",
      "66:  symbol_server = r_str_escape (opt->symbol_server);",
      "68:  abspath_to_archive = r_str_newf (\"%s%s%s%s%s%s%s\",",
      "69:        symbol_store_path, R_SYS_DIR,",
      "70:        dbg_file, R_SYS_DIR,",
      "71:        guid, R_SYS_DIR,",
      "72:        archive_name_escaped);",
      "74:  abspath_to_file = strdup (abspath_to_archive);",
      "75:  abspath_to_file[strlen (abspath_to_file) - 1] = 'b';",
      "78:   R_FREE (user_agent);",
      "79:   R_FREE (abspath_to_archive);",
      "80:   R_FREE (archive_name_escaped);",
      "81:   R_FREE (symbol_store_path);",
      "82:   R_FREE (dbg_file);",
      "83:   R_FREE (guid);",
      "84:   R_FREE (archive_name);",
      "85:   R_FREE (abspath_to_file);",
      "86:   R_FREE (symbol_server);",
      "91:   res = 1;",
      "93:   curl_cmd = r_str_newf (\"curl -sfLA \\\"%s\\\" \\\"%s/%s/%s/%s\\\" --create-dirs -o \\\"%s\\\"\",",
      "94:                          user_agent,",
      "95:                          symbol_server,",
      "96:           dbg_file,",
      "97:           guid,",
      "98:                          archive_name_escaped,",
      "99:                          abspath_to_archive);",
      "101:   const char *cabextractor = \"expand\";",
      "102:   const char *format = \"%s %s %s\";",
      "108:   extractor_cmd = r_str_newf (format, cabextractor,",
      "109:    abspath_to_archive, abspath_to_file);",
      "111:   const char *cabextractor = \"cabextract\";",
      "112:   const char *format = \"%s -d \\\"%s\\\" \\\"%s\\\"\";",
      "117:   extractor_cmd = r_str_newf (format, cabextractor, abspath_to_dir, abspath_to_archive);",
      "118:   R_FREE (abspath_to_dir);",
      "120:   eprintf (\"Attempting to download compressed pdb in %s\\n\", abspath_to_archive);",
      "121:   if ((cmd_ret = r_sys_cmd (curl_cmd) != 0)) {",
      "122:    eprintf(\"curl exited with error %d\\n\", cmd_ret);",
      "123:    res = 0;",
      "124:   }",
      "125:   eprintf (\"Attempting to decompress pdb\\n\");",
      "126:   if (opt->extract > 0) {",
      "133:   R_FREE (curl_cmd);",
      "137:   res = 1;",
      "139:   archive_name_escaped[strlen (archive_name_escaped) - 1] = 'b';",
      "141:   curl_cmd = r_str_newf (\"curl -sfLA \\\"%s\\\" \\\"%s/%s/%s/%s\\\" --create-dirs -o \\\"%s\\\"\",",
      "142:                          opt->user_agent,",
      "143:                          opt->symbol_server,",
      "144:                          opt->dbg_file,",
      "145:                          opt->guid,",
      "146:                          archive_name_escaped,",
      "147:                          abspath_to_file);",
      "149:   if ((cmd_ret = r_sys_cmd (curl_cmd) != 0)) {",
      "150:    eprintf(\"curl exited with error %d\\n\", cmd_ret);",
      "151:    res = 0;",
      "152:   }",
      "153:   R_FREE (curl_cmd);",
      "154:  }",
      "155:  R_FREE (abspath_to_archive);",
      "156:  R_FREE (abspath_to_file);",
      "157:  R_FREE (archive_name);",
      "158:  R_FREE (extractor_cmd);",
      "159:  R_FREE (symbol_store_path);",
      "160:  R_FREE (dbg_file);",
      "161:  R_FREE (guid);",
      "162:  R_FREE (archive_name_escaped);",
      "163:  R_FREE (user_agent);",
      "164:  R_FREE (symbol_server);",
      "",
      "[Added Lines]",
      "21: static bool download_and_write(SPDBDownloaderOpt *opt, const char *file) {",
      "22:  char *dir = r_str_newf (\"%s%s%s%s%s\",",
      "23:   opt->symbol_store_path, R_SYS_DIR,",
      "24:   opt->dbg_file, R_SYS_DIR,",
      "25:   opt->guid);",
      "26:  if (!r_sys_mkdirp (dir)) {",
      "27:   free (dir);",
      "30:  char *url = r_str_newf (\"%s/%s/%s/%s\", opt->symbol_server, opt->dbg_file, opt->guid, file);",
      "31:  int len;",
      "32:  char *file_buf = r_socket_http_get (url, NULL, &len);",
      "33:  free (url);",
      "34:  if (!len || R_STR_ISEMPTY (file_buf)) {",
      "35:   free (dir);",
      "36:   free (file_buf);",
      "37:   return false;",
      "38:  }",
      "39:  char *path = r_str_newf (\"%s%s%s\", dir, R_SYS_DIR, opt->dbg_file);",
      "40:  FILE *f = fopen (path, \"wb\");",
      "41:  if (f) {",
      "42:   fwrite (file_buf, sizeof (char), (size_t)len, f);",
      "43:   fclose (f);",
      "44:  }",
      "45:  free (dir);",
      "46:  free (path);",
      "47:  free (file_buf);",
      "61:  char *abspath_to_file = r_str_newf (\"%s%s%s%s%s%s%s\",",
      "62:   opt->symbol_store_path, R_SYS_DIR,",
      "63:   opt->dbg_file, R_SYS_DIR,",
      "64:   opt->guid, R_SYS_DIR,",
      "65:   opt->dbg_file);",
      "69:   free (abspath_to_file);",
      "74:   char *extractor_cmd = NULL;",
      "75:   char *archive_name = strdup (opt->dbg_file);",
      "76:   archive_name[strlen (archive_name) - 1] = '_';",
      "77:   char *abspath_to_archive = r_str_newf (\"%s%s%s%s%s%s%s\",",
      "78:    opt->symbol_store_path, R_SYS_DIR,",
      "79:    opt->dbg_file, R_SYS_DIR,",
      "80:    opt->guid, R_SYS_DIR,",
      "81:    archive_name);",
      "83:   eprintf (\"Attempting to download compressed pdb in %s\\n\", abspath_to_archive);",
      "84:   char *abs_arch_esc = r_str_escape_sh (abspath_to_archive);",
      "86:   char *abs_file_esc = r_str_escape_sh (abspath_to_file);",
      "90:   extractor_cmd = r_str_newf (\"expand \\\"%s\\\" \\\"%s\\\"\", abs_arch_esc, abs_file_esc);",
      "91:   free (abs_file_esc);",
      "94:   char *abs_dir_esc = r_str_escape_sh (abspath_to_dir);",
      "98:   extractor_cmd = r_str_newf (\"cabextract -d \\\"%s\\\" \\\"%s\\\"\", abs_arch_esc, abs_dir_esc);",
      "99:   free (abs_dir_esc);",
      "100:   free (abspath_to_dir);",
      "102:   free (abs_arch_esc);",
      "103:   res = download_and_write (opt, archive_name);",
      "105:   if (opt->extract > 0 && res) {",
      "106:    eprintf (\"Attempting to decompress pdb\\n\");",
      "113:   free (archive_name);",
      "114:   free (abspath_to_archive);",
      "119:   res = download_and_write (opt, opt->dbg_file);",
      "120:  }",
      "121:  free (abspath_to_file);",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "191:  pd->download = 0;",
      "192: }",
      "194: int r_bin_pdb_download(RCore *core, int isradjson, int *actions_done, SPDBOptions *options) {",
      "195:  int ret;",
      "196:  SPDBDownloaderOpt opt;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "151: static bool is_valid_guid(const char *guid) {",
      "152:  if (!guid) {",
      "153:   return false;",
      "154:  }",
      "155:  size_t i;",
      "156:  for (i = 0; guid[i]; i++) {",
      "157:   if (!isxdigit (guid[i])) {",
      "158:    return false;",
      "159:   }",
      "160:  }",
      "161:  return i >= 33; // len of GUID and age",
      "162: }",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "202:   return 1;",
      "203:  }",
      "205:  if (!options || !options->symbol_server || !options->user_agent) {",
      "206:   eprintf (\"Can't retrieve pdb configurations\\n\");",
      "207:   return 1;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "175:  if (!is_valid_guid (info->guid)) {",
      "176:   eprintf (\"Invalid GUID for file\\n\");",
      "177:   return 1;",
      "178:  }",
      "",
      "---------------"
    ],
    "libr/config.mk.tail||libr/config.mk.tail": [
      "File: libr/config.mk.tail -> libr/config.mk.tail",
      "--- Hunk 1 ---",
      "[Context before]",
      "52: BN_LIBS=-lgmp",
      "53: endif",
      "55: #both of these need ssl includes",
      "56: ifneq (,$(filter r_socket r_util,$(BINDEPS)))",
      "57: ifeq (${HAVE_LIB_SSL},1)",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "55: # open-ssl",
      "56: ifeq (${HAVE_LIB_SSL},1)",
      "57: BN_LIBS=${SSL_LDFLAGS}",
      "58: endif",
      "",
      "---------------"
    ],
    "libr/include/r_socket.h||libr/include/r_socket.h": [
      "File: libr/include/r_socket.h -> libr/include/r_socket.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "1: #ifndef R2_SOCKET_H",
      "2: #define R2_SOCKET_H",
      "9: #include \"r_types.h\"",
      "10: #include \"r_bind.h\"",
      "11: #include \"r_list.h\"",
      "",
      "[Removed Lines]",
      "5: #if defined(__WINDOWS__)",
      "6: #include <ws2tcpip.h>",
      "7: #endif",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ],
    "libr/include/r_types.h||libr/include/r_types.h": [
      "File: libr/include/r_types.h -> libr/include/r_types.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "152:   #ifdef _MSC_VER",
      "154:   #include <winsock2.h>",
      "155:   #ifndef WIN32_LEAN_AND_MEAN",
      "156:   #define WIN32_LEAN_AND_MEAN",
      "157:   #endif",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "155:   #include <ws2tcpip.h>",
      "",
      "---------------"
    ],
    "libr/include/r_util/r_str.h||libr/include/r_util/r_str.h": [
      "File: libr/include/r_util/r_str.h -> libr/include/r_util/r_str.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "148: R_API char *r_str_path_escape(const char *path);",
      "149: R_API int r_str_unescape(char *buf);",
      "150: R_API char *r_str_escape(const char *buf);",
      "151: R_API char *r_str_escape_dot(const char *buf);",
      "152: R_API char *r_str_escape_latin1(const char *buf, bool show_asciidot, bool esc_bslash, bool colors);",
      "153: R_API char *r_str_escape_utf8(const char *buf, bool show_asciidot, bool esc_bslash);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "151: R_API char *r_str_escape_sh(const char *buf);",
      "",
      "---------------"
    ],
    "libr/socket/socket.c||libr/socket/socket.c": [
      "File: libr/socket/socket.c -> libr/socket/socket.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "260: R_API bool r_socket_connect(RSocket *s, const char *host, const char *port, int proto, unsigned int timeout) {",
      "261:  r_return_val_if_fail (s, false);",
      "262: #if __WINDOWS__",
      "263:  struct sockaddr_in sa;",
      "265:  WSADATA wsadata;",
      "270:  if (WSAStartup (MAKEWORD (1, 1), &wsadata) == SOCKET_ERROR) {",
      "271:   eprintf (\"Error creating socket.\");",
      "272:   return false;",
      "273:  }",
      "292: #endif",
      "326:  int ret;",
      "328:  struct addrinfo *res, *rp;",
      "329:  if (!proto) {",
      "330:   proto = R_SOCKET_PROTO_TCP;",
      "331:  }",
      "332:  r_sys_signal (SIGPIPE, SIG_IGN);",
      "333:  if (proto == R_SOCKET_PROTO_UNIX) {",
      "334:   if (!__connect_unix (s, host)) {",
      "335:    return false;",
      "336:   }",
      "337:  } else {",
      "339:   hints.ai_protocol = proto;",
      "",
      "[Removed Lines]",
      "264:  struct hostent *he;",
      "266:  TIMEVAL Timeout;",
      "267:  Timeout.tv_sec = timeout;",
      "268:  Timeout.tv_usec = 0;",
      "274:  s->fd = socket (AF_INET, SOCK_STREAM, 0);",
      "275:  if (s->fd == R_INVALID_SOCKET) {",
      "276:   return false;",
      "277:  }",
      "279:  unsigned long iMode = 1;",
      "280:  int iResult = ioctlsocket (s->fd, FIONBIO, &iMode);",
      "281:  if (iResult != NO_ERROR) {",
      "282:   eprintf (\"ioctlsocket error: %d\\n\", iResult);",
      "283:  }",
      "284:  memset (&sa, 0, sizeof (sa));",
      "285:  sa.sin_family = AF_INET;",
      "286:  he = (struct hostent *)gethostbyname (host);",
      "287:  if (he == (struct hostent*)0) {",
      "288: #ifdef _MSC_VER",
      "289:   closesocket (s->fd);",
      "290: #else",
      "291:   close (s->fd);",
      "293:   return false;",
      "294:  }",
      "295:  sa.sin_addr = *((struct in_addr *)he->h_addr);",
      "296:  s->port = r_socket_port_by_name (port);",
      "297:  s->proto = proto;",
      "298:  sa.sin_port = htons (s->port);",
      "299:  if (!connect (s->fd, (const struct sockaddr*)&sa, sizeof (struct sockaddr))) {",
      "300: #ifdef _MSC_VER",
      "301:   closesocket (s->fd);",
      "302: #else",
      "303:   close (s->fd);",
      "304: #endif",
      "305:   return false;",
      "306:  }",
      "307:  iMode = 0;",
      "308:  iResult = ioctlsocket (s->fd, FIONBIO, &iMode);",
      "309:  if (iResult != NO_ERROR) {",
      "310:   eprintf (\"ioctlsocket error: %d\\n\", iResult);",
      "311:  }",
      "312:  if (timeout > 0) {",
      "313:   r_socket_block_time (s, 1, timeout, 0);",
      "314:  }",
      "315:  fd_set Write, Err;",
      "316:  FD_ZERO (&Write);",
      "317:  FD_ZERO (&Err);",
      "318:  FD_SET (s->fd, &Write);",
      "319:  FD_SET (s->fd, &Err);",
      "320:  select (0, NULL, &Write, &Err, &Timeout);",
      "321:  if (FD_ISSET (s->fd, &Write)) {",
      "322:   return true;",
      "323:  }",
      "324:  return false;",
      "325: #elif __UNIX__",
      "327:  struct addrinfo hints = {0};",
      "",
      "[Added Lines]",
      "263: #define gai_strerror gai_strerrorA",
      "273:  struct addrinfo hints = { 0 };",
      "278: #if __UNIX__",
      "280: #endif",
      "282: #if __UNIX__",
      "286: #endif",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "367:     return true;",
      "368:    }",
      "369:    if (errno == EINPROGRESS) {",
      "373:     fd_set wfds;",
      "377:     if ((ret = select (s->fd + 1, NULL, &wfds, NULL, &tv)) != -1) {",
      "378:      if (r_socket_is_connected (s)) {",
      "379:       freeaddrinfo (res);",
      "381:      }",
      "382:     } else {",
      "383:      perror (\"connect\");",
      "",
      "[Removed Lines]",
      "370:     struct timeval tv;",
      "371:     tv.tv_sec = timeout;",
      "372:     tv.tv_usec = 0;",
      "374:     FD_ZERO(&wfds);",
      "375:     FD_SET(s->fd, &wfds);",
      "380:       return true;",
      "",
      "[Added Lines]",
      "320:     struct timeval tv = {timeout, 0};",
      "322:     FD_ZERO (&wfds);",
      "323:     FD_SET (s->fd, &wfds);",
      "328:       goto success;",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "391:    return false;",
      "392:   }",
      "393:  }",
      "395: #if HAVE_LIB_SSL",
      "396:  if (s->is_ssl) {",
      "397:   s->ctx = SSL_CTX_new (SSLv23_client_method ());",
      "398:   if (!s->ctx) {",
      "400:    return false;",
      "401:   }",
      "402:   s->sfd = SSL_new (s->ctx);",
      "403:   SSL_set_fd (s->sfd, s->fd);",
      "406:    return false;",
      "407:   }",
      "408:  }",
      "",
      "[Removed Lines]",
      "394: #endif",
      "399:    r_socket_free (s);",
      "404:   if (SSL_connect (s->sfd) != 1) {",
      "405:    r_socket_free (s);",
      "",
      "[Added Lines]",
      "342: success:",
      "347:    r_socket_close (s);",
      "352:   int ret = SSL_connect (s->sfd);",
      "353:   if (ret != 1) {",
      "354:    int error = SSL_get_error (s->sfd, ret);",
      "355:    int tries = 10;",
      "356:    while (tries && ret && (error == SSL_ERROR_WANT_READ || error == SSL_ERROR_WANT_WRITE)) {",
      "357:     struct timeval tv = {1, 0};",
      "358:     fd_set rfds, wfds;",
      "359:     FD_ZERO (&rfds);",
      "360:     FD_ZERO (&wfds);",
      "361:     if (error == SSL_ERROR_WANT_READ) {",
      "362:      FD_SET (s->fd, &rfds);",
      "363:     } else {",
      "364:      FD_SET (s->fd, &wfds);",
      "365:     }",
      "366:     if ((ret = select (s->fd + 1, &rfds, &wfds, NULL, &tv)) < 1) {",
      "367:      r_socket_close (s);",
      "368:      return false;",
      "369:     }",
      "370:     ret = SSL_connect (s->sfd);",
      "371:     if (ret == 1) {",
      "372:      return true;",
      "373:     }",
      "374:     error = SSL_get_error (s->sfd, ret);",
      "375:     tries--;",
      "376:    }",
      "377:    r_socket_close (s);",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "622:  FD_ZERO (&except_fds);",
      "623:  FD_SET (s->fd, &except_fds);",
      "629:  int r = select (s->fd + 1, &read_fds, NULL, &except_fds, &t);",
      "630:  if(r < 0) {",
      "",
      "[Removed Lines]",
      "625:  struct timeval t;",
      "626:  t.tv_sec = timeout;",
      "627:  t.tv_usec = 0;",
      "",
      "[Added Lines]",
      "597:  struct timeval t = {timeout, 0};",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "659:  ioctlsocket (s->fd, FIONBIO, (u_long FAR*)&block);",
      "660: #endif",
      "661:  if (sec > 0 || usec > 0) {",
      "665:   if (setsockopt (s->fd, SOL_SOCKET, SO_RCVTIMEO, (char *)&tv, sizeof (tv)) < 0) {",
      "666:    return false;",
      "667:   }",
      "",
      "[Removed Lines]",
      "662:   struct timeval tv = {0};",
      "663:   tv.tv_sec = sec;",
      "664:   tv.tv_usec = usec;",
      "",
      "[Added Lines]",
      "632:   struct timeval tv = {sec, usec};",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "678:  return true;",
      "679: }",
      "684: R_API int r_socket_ready(RSocket *s, int secs, int usecs) {",
      "694:  fd_set rfds;",
      "696:  if (s->fd == R_INVALID_SOCKET) {",
      "697:   return -1;",
      "698:  }",
      "699:  FD_ZERO (&rfds);",
      "700:  FD_SET (s->fd, &rfds);",
      "703:  return select (s->fd + 1, &rfds, NULL, NULL, &tv);",
      "707: }",
      "709: R_API char *r_socket_to_string(RSocket *s) {",
      "",
      "[Removed Lines]",
      "685: #if __UNIX__",
      "687:  int msecs = (usecs / 1000);",
      "688:  struct pollfd fds[1];",
      "689:  fds[0].fd = s->fd;",
      "690:  fds[0].events = POLLIN | POLLPRI;",
      "691:  fds[0].revents = POLLNVAL | POLLHUP | POLLERR;",
      "692:  return poll ((struct pollfd *)&fds, 1, msecs);",
      "693: #elif __WINDOWS__",
      "695:  struct timeval tv;",
      "701:  tv.tv_sec = secs;",
      "702:  tv.tv_usec = usecs;",
      "704: #else",
      "706: #endif",
      "",
      "[Added Lines]",
      "653:  struct timeval tv = {secs, usecs};",
      "",
      "---------------",
      "--- Hunk 7 ---",
      "[Context before]",
      "794:   return SSL_read (s->sfd, buf, len);",
      "795:  }",
      "796: #endif",
      "808:  int r = recv (s->fd, buf, len, 0);",
      "809:  D { eprintf (\"READ \"); int i; for (i = 0; i<len; i++) { eprintf (\"%02x \", buf[i]); } eprintf (\"\\n\"); }",
      "810:  return r;",
      "812: }",
      "814: R_API int r_socket_read_block(RSocket *s, ut8 *buf, int len) {",
      "",
      "[Removed Lines]",
      "797: #if __WINDOWS__",
      "798: rep:",
      "799:  {",
      "800:  int ret = recv (s->fd, (void *)buf, len, 0);",
      "801:  if (ret == -1) {",
      "802:   goto rep;",
      "803:  }",
      "804:  return ret;",
      "805:  }",
      "806: #else",
      "811: #endif",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 8 ---",
      "[Context before]",
      "816:  for (ret = 0; ret < len; ) {",
      "817:   int r = r_socket_read (s, buf + ret, len - ret);",
      "818:   if (r == -1) {",
      "819:    return -1;",
      "820:   }",
      "821:   if (r < 1) {",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "761: #if HAVE_LIB_SSL",
      "762:    if (SSL_get_error (s->sfd, r) == SSL_ERROR_WANT_READ) {",
      "763:     if (r_socket_ready (s, 1, 0) == 1) {",
      "764:      continue;",
      "765:     }",
      "766:    }",
      "767: #endif",
      "",
      "---------------"
    ],
    "libr/socket/socket_http.c||libr/socket/socket_http.c": [
      "File: libr/socket/socket_http.c -> libr/socket/socket_http.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "3: #include <r_socket.h>",
      "4: #include <r_util.h>",
      "11:   return 0;",
      "12:  }",
      "19:    break;",
      "20:   }",
      "21:  }",
      "22:  return i;",
      "23: }",
      "26:  r_return_val_if_fail (s, NULL);",
      "27:  const char *p;",
      "31:   return NULL;",
      "32:  }",
      "33:  char *res = NULL;",
      "35:  if ((dn = (char*)r_str_casestr (buf, \"\\n\\n\"))) {",
      "36:   delta += 2;",
      "37:  } else if ((dn = (char*)r_str_casestr (buf, \"\\r\\n\\r\\n\"))) {",
      "38:   delta += 4;",
      "39:  } else {",
      "41:  }",
      "43:  olen -= delta;",
      "46:  p = r_str_casestr (buf, \"Content-Length: \");",
      "47:  if (p) {",
      "",
      "[Removed Lines]",
      "6: static int __socket_slurp (RSocket *s, ut8 *buf, int bufsz) {",
      "7:  int i;",
      "8:  int chsz = 1;",
      "10:  if (r_socket_read_block (s, (ut8 *) buf, 1) != 1) {",
      "13:  for (i = 1; i < bufsz; i += chsz) {",
      "14:   buf[i] =0;",
      "15:   r_socket_block_time (s, 1, 0, 1000);",
      "16:   int olen = r_socket_read_block (s, (ut8 *) buf + i , chsz);",
      "17:   if (olen != chsz) {",
      "18:    buf[i] = 0;",
      "25: static char *r_socket_http_answer (RSocket *s, int *code, int *rlen) {",
      "28:  int ret, len = 0, bufsz = 32768, delta = 0;",
      "29:  char *dn, *buf = calloc (1, bufsz + 32); // XXX: use r_buffer here",
      "30:  if (!buf) {",
      "34:  int olen = __socket_slurp (s, (ut8*)buf, bufsz);",
      "40:   goto fail;",
      "",
      "[Added Lines]",
      "6: #if __WINDOWS__",
      "7: #include <WinInet.h>",
      "8: #endif",
      "10: #define SOCKET_HTTP_MAX_HEADER_LENGTH 0x2000",
      "11: #define SOCKET_HTTP_MAX_REDIRECTS 5",
      "13: static size_t socket_slurp(RSocket *s, RBuffer *buf) {",
      "14:  size_t i;",
      "15:  if (r_socket_ready (s, 1, 0) != 1) {",
      "18:  r_socket_block_time (s, 1, 0, 1000);",
      "19:  for (i = 0; i < SOCKET_HTTP_MAX_HEADER_LENGTH; i += 1) {",
      "20:   ut8 c;",
      "21:   int olen = r_socket_read_block (s, &c, 1);",
      "22:   if (olen != 1) {",
      "23:    r_buf_append_bytes (buf, (ut8 *)\"\", 1);",
      "26:   r_buf_append_bytes (buf, &c, 1);",
      "31: static char *socket_http_get_recursive(const char *url, int *code, int *rlen, ut32 redirections);",
      "33: static char *socket_http_answer(RSocket *s, int *code, int *rlen, ut32 redirections) {",
      "36:  int ret, len = 0, delta = 0;",
      "37:  char *dn;",
      "38:  RBuffer *b = r_buf_new ();",
      "39:  if (!b) {",
      "43:  size_t olen = socket_slurp (s, b);",
      "44:  char *buf = malloc (olen + 1);",
      "45:  if (!buf) {",
      "46:   goto exit;",
      "47:  }",
      "48:  r_buf_read_at (b, 0, (ut8 *)buf, olen);",
      "49:  buf[olen] = 0;",
      "55:   goto exit;",
      "62:  p = r_str_casestr (buf, \"Location:\");",
      "63:  if (p) {",
      "64:   if (!redirections) {",
      "65:    eprintf (\"Too many redirects\\n\");",
      "66:    goto exit;",
      "67:   }",
      "68:   p += strlen (\"Location:\");",
      "69:   char *end_url = strchr (p, '\\n');",
      "70:   if (end_url) {",
      "71:    int url_len = end_url - p;",
      "72:    char *url = r_str_ndup (p, url_len);",
      "73:    r_str_trim (url);",
      "74:    res = socket_http_get_recursive (url, code, rlen, --redirections);",
      "75:    free (url);",
      "76:    len = *rlen;",
      "77:   }",
      "78:   goto exit;",
      "79:  }",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "52:  if (len > 0) {",
      "53:   if (len > olen) {",
      "54:    res = malloc (len + 2);",
      "55:    memcpy (res, dn + delta, olen);",
      "56:    do {",
      "57:     ret = r_socket_read_block (s, (ut8*) res + olen, len - olen);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "91:    if (!res) {",
      "92:     goto exit;",
      "93:    }",
      "94:    olen -= dn - buf;",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "71:  } else {",
      "72:   res = NULL;",
      "73:  }",
      "75:  free (buf);",
      "77:  r_socket_close (s);",
      "78:  if (rlen) {",
      "",
      "[Removed Lines]",
      "74: fail:",
      "",
      "[Added Lines]",
      "114: exit:",
      "116:  r_buf_free (b);",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "81:  return res;",
      "82: }",
      "85:  char *curl_env = r_sys_getenv (\"R2_CURL\");",
      "90:   if (res) {",
      "91:    if (code) {",
      "93:    }",
      "94:    if (rlen) {",
      "96:    }",
      "97:   }",
      "99:   return res;",
      "100:  }",
      "101:  free (curl_env);",
      "102:  RSocket *s;",
      "103:  int ssl = r_str_startswith (url, \"https://\");",
      "104:  char *response, *host, *path, *port = \"80\";",
      "105:  char *uri = strdup (url);",
      "106:  if (!uri) {",
      "107:   return NULL;",
      "108:  }",
      "116:  host = strstr (uri, \"://\");",
      "117:  if (!host) {",
      "118:   free (uri);",
      "",
      "[Removed Lines]",
      "84: R_API char *r_socket_http_get(const char *url, int *code, int *rlen) {",
      "86:  if (curl_env && *curl_env) {",
      "87:   char *encoded_url = r_str_escape (url);",
      "88:   char *res = r_sys_cmd_strf (\"curl '%s'\", encoded_url);",
      "89:   free (encoded_url);",
      "98:   free (curl_env);",
      "110:  if (code) {",
      "112:  }",
      "113:  if (rlen) {",
      "115:  }",
      "",
      "[Added Lines]",
      "124: #if __WINDOWS__",
      "125: static char *http_get_w32(const char *url, int *code, int *rlen) {",
      "126:  HINTERNET hInternet = InternetOpenA (\"radare2 \"R2_VERSION, INTERNET_OPEN_TYPE_DIRECT, NULL, NULL, 0);",
      "127:  if (!hInternet) {",
      "128:   r_sys_perror (\"InternetOpenA\");",
      "129:   return NULL;",
      "130:  }",
      "131:  HINTERNET hOpenUrl = InternetOpenUrlA (hInternet, url, NULL, 0, 0, 0);",
      "132:  if (!hOpenUrl) {",
      "133:   r_sys_perror (\"InternetOpenUrlA\");",
      "134:   InternetCloseHandle (hInternet);",
      "135:   return NULL;",
      "136:  }",
      "138:  char *ret = NULL;",
      "139:  size_t read_sz = 0x100000;",
      "140:  DWORD r = 0, w = 0;",
      "141:  bool res = true;",
      "142:  do {",
      "143:   w += r;",
      "144:   if (!res && GetLastError () == ERROR_INSUFFICIENT_BUFFER) {",
      "145:    read_sz *= 2;",
      "146:   }",
      "147:   char *tmp = realloc (ret, read_sz + w);",
      "148:   if (!tmp) {",
      "149:    R_FREE (ret);",
      "150:    goto exit;",
      "151:   }",
      "152:   ret = tmp;",
      "153:  } while (!(res = InternetReadFile (hOpenUrl, ret + w, read_sz, &r)) || r);",
      "155:  if (w) {",
      "156:   char *tmp = realloc (ret, (size_t)w + 1);",
      "157:   if (tmp) {",
      "158:    ret = tmp;",
      "159:    ret[w] = 0;",
      "160:   } else {",
      "161:    R_FREE (ret);",
      "162:   }",
      "163:  } else {",
      "164:   R_FREE (ret);",
      "165:  }",
      "167: exit:",
      "168:  if (rlen) {",
      "170:  }",
      "171:  if (code && w) {",
      "173:  }",
      "174:  InternetCloseHandle (hInternet);",
      "175:  InternetCloseHandle (hOpenUrl);",
      "176:  return ret;",
      "177: }",
      "178: #endif",
      "180: static char *socket_http_get_recursive(const char *url, int *code, int *rlen, ut32 redirections) {",
      "181:  if (code) {",
      "183:  }",
      "184:  if (rlen) {",
      "186:  }",
      "188:  if (!R_STR_ISEMPTY (curl_env) && atoi (curl_env)) {",
      "189:   int len;",
      "190:   char *escaped_url = r_str_escape_sh (url);",
      "191:   char *command = r_str_newf (\"curl -sfL -o - \\\"%s\\\"\", escaped_url);",
      "192:   char *res = r_sys_cmd_str (command, NULL, &len);",
      "193:   free (escaped_url);",
      "194:   free (command);",
      "195:   free (curl_env);",
      "196:   if (!res) {",
      "197:    return NULL;",
      "198:   }",
      "210: #if __WINDOWS__",
      "211:  return http_get_w32 (url, code, rlen);",
      "212: #else",
      "215: #if !HAVE_LIB_SSL",
      "216:  if (ssl) {",
      "217:   eprintf (\"Tried to get '%s', but SSL support is disabled, set R2_CURL=1 to use curl\\n\", url);",
      "218:   return NULL;",
      "219:  }",
      "220: #endif",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "147:     \"Accept: */*\\r\\n\"",
      "148:     \"Host: %s:%s\\r\\n\"",
      "149:     \"\\r\\n\", path, host, port);",
      "151:  } else {",
      "152:   eprintf (\"Cannot connect to %s:%s\\n\", host, port);",
      "153:   response = NULL;",
      "",
      "[Removed Lines]",
      "150:   response = r_socket_http_answer (s, code, rlen);",
      "",
      "[Added Lines]",
      "260:   response = socket_http_answer (s, code, rlen, redirections);",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "155:  free (uri);",
      "156:  r_socket_free (s);",
      "157:  return response;",
      "158: }",
      "161:  RSocket *s;",
      "162:  bool ssl = r_str_startswith (url, \"https://\");",
      "163:  char *uri = strdup (url);",
      "",
      "[Removed Lines]",
      "160: R_API char *r_socket_http_post (const char *url, const char *data, int *code, int *rlen) {",
      "",
      "[Added Lines]",
      "268: #endif",
      "269: }",
      "271: R_API char *r_socket_http_get(const char *url, int *code, int *rlen) {",
      "272:  return socket_http_get_recursive (url, code, rlen, SOCKET_HTTP_MAX_REDIRECTS);",
      "275: R_API char *r_socket_http_post(const char *url, const char *data, int *code, int *rlen) {",
      "",
      "---------------",
      "--- Hunk 7 ---",
      "[Context before]",
      "206:    \"\\r\\n\", path, host, (int)strlen (data));",
      "207:  free (uri);",
      "208:  r_socket_write (s, (void *)data, strlen (data));",
      "210: }",
      "212: #if TEST",
      "",
      "[Removed Lines]",
      "209:  return r_socket_http_answer (s, code, rlen);",
      "",
      "[Added Lines]",
      "324:  return socket_http_answer (s, code, rlen, 0);",
      "",
      "---------------"
    ],
    "libr/util/str.c||libr/util/str.c": [
      "File: libr/util/str.c -> libr/util/str.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "1351:  return r_str_escape_ (buf, false, true, true, false, true);",
      "1352: }",
      "1354: R_API char *r_str_escape_dot(const char *buf) {",
      "1355:  return r_str_escape_ (buf, true, true, true, false, true);",
      "1356: }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1355: R_API char *r_str_escape_sh(const char *buf) {",
      "1356:  r_return_val_if_fail (buf, NULL);",
      "1357:  char *new_buf = malloc (1 + strlen (buf) * 2);",
      "1358:  if (!new_buf) {",
      "1359:   return NULL;",
      "1360:  }",
      "1361:  const char *p = buf;",
      "1362:  char *q = new_buf;",
      "1363:  while (*p) {",
      "1364:   switch (*p) {",
      "1365: #if __UNIX__",
      "1366:   case '$':",
      "1367:   case '`':",
      "1368: #endif",
      "1369:   case '\\\\':",
      "1370:   case '\"':",
      "1373:   default:",
      "1375:    break;",
      "1376:   }",
      "1377:  }",
      "1379:  return new_buf;",
      "1380: }",
      "",
      "---------------"
    ],
    "libr/util/sys.c||libr/util/sys.c": [
      "File: libr/util/sys.c -> libr/util/sys.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "660:   }",
      "662:   r_sys_signal (SIGPIPE, SIG_IGN);",
      "663:   for (;;) {",
      "664:    fd_set rfds, wfds;",
      "665:    int nfd;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "663:   size_t err_len = 0, out_len = 0;",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "680:     break;",
      "681:    }",
      "682:    if (output && FD_ISSET (sh_out[0], &rfds)) {",
      "684:      break;",
      "685:     }",
      "689:     }",
      "691:    } else if (FD_ISSET (sh_err[0], &rfds) && sterr) {",
      "693:      break;",
      "694:     }",
      "697:    } else if (FD_ISSET (sh_in[1], &wfds) && inputptr && *inputptr) {",
      "698:     int inputptr_len = strlen (inputptr);",
      "699:     bytes = write (sh_in[1], inputptr, inputptr_len);",
      "",
      "[Removed Lines]",
      "683:     if (!(bytes = read (sh_out[0], buffer, sizeof (buffer)-1))) {",
      "686:     buffer[sizeof (buffer) - 1] = '\\0';",
      "687:     if (len) {",
      "690:     outputptr = r_str_append (outputptr, buffer);",
      "692:     if (!read (sh_err[0], buffer, sizeof (buffer)-1)) {",
      "695:     buffer[sizeof (buffer) - 1] = '\\0';",
      "",
      "[Added Lines]",
      "684:     if ((bytes = read (sh_out[0], buffer, sizeof (buffer))) < 1) {",
      "687:     char *tmp = realloc (outputptr, out_len + bytes + 1);",
      "688:     if (!tmp) {",
      "689:      R_FREE (outputptr);",
      "690:      break;",
      "692:     outputptr = tmp;",
      "693:     memcpy (outputptr + out_len, buffer, bytes);",
      "694:     out_len += bytes;",
      "696:     if ((bytes = read (sh_err[0], buffer, sizeof (buffer))) < 1) {",
      "697:      break;",
      "698:     }",
      "699:     char *tmp = realloc (*sterr, err_len + bytes + 1);",
      "700:     if (!tmp) {",
      "701:      R_FREE (*sterr);",
      "705:     memcpy (*sterr + err_len, buffer, bytes);",
      "706:     err_len += bytes;",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "727:    ret = false;",
      "728:   }",
      "730:   if (output) {",
      "732:   } else {",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "740:   if (len) {",
      "742:   }",
      "743:   if (*sterr) {",
      "744:    (*sterr)[err_len] = 0;",
      "745:   }",
      "746:   if (outputptr) {",
      "747:    outputptr[out_len] = 0;",
      "748:   }",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "829:  {",
      "830:   char *p = strstr (ptr, \":\\\\\");",
      "831:   if (p) {",
      "833:   }",
      "834:  }",
      "835: #endif",
      "",
      "[Removed Lines]",
      "832:    ptr = p + 2;",
      "",
      "[Added Lines]",
      "851:    ptr = p + 3;",
      "",
      "---------------"
    ],
    "meson.build||meson.build": [
      "File: meson.build -> meson.build",
      "--- Hunk 1 ---",
      "[Context before]",
      "112: platform_deps = []",
      "113: platform_inc = ['.', 'libr/include']",
      "114: if host_machine.system() == 'windows'",
      "116: endif",
      "117: platform_inc = include_directories(platform_inc)",
      "",
      "[Removed Lines]",
      "115:   platform_deps = [cc.find_library('ws2_32'), cc.find_library('psapi')]",
      "",
      "[Added Lines]",
      "115:   platform_deps = [cc.find_library('ws2_32'), cc.find_library('wininet'), cc.find_library('psapi')]",
      "",
      "---------------"
    ],
    "shlr/sdb/src/disk.c||shlr/sdb/src/disk.c": [
      "File: shlr/sdb/src/disk.c -> shlr/sdb/src/disk.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "64: #if __SDB_WINDOWS__",
      "65:  char *p = strstr (ptr, \":\\\\\");",
      "66:  if (p) {",
      "68:  }",
      "69: #endif",
      "70:  while ((ptr = strchr (ptr, slash))) {",
      "",
      "[Removed Lines]",
      "67:   ptr = p + 2;",
      "",
      "[Added Lines]",
      "67:   ptr = p + 3;",
      "",
      "---------------"
    ],
    "test/unit/test_str.c||test/unit/test_str.c": [
      "File: test/unit/test_str.c -> test/unit/test_str.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "336:  mu_end;",
      "337: }",
      "339: bool test_r_str_unescape(void) {",
      "340:  char buf[] = \"Hello\\\\x31World\\\\n\";",
      "341:  r_str_unescape (buf);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "339: bool test_r_str_escape_sh(void) {",
      "340:  char *escaped = r_str_escape_sh (\"Hello, \\\"World\\\"\");",
      "341:  mu_assert_streq (escaped, \"Hello, \\\\\\\"World\\\\\\\"\", \"escaped \\\"double quotes\\\"\");",
      "342:  free (escaped);",
      "343:  escaped = r_str_escape_sh (\"Hello, \\\\World\\\\\");",
      "344:  mu_assert_streq (escaped, \"Hello, \\\\\\\\World\\\\\\\\\", \"escaped backspace\");",
      "345:  free (escaped);",
      "346: #if __UNIX__",
      "347:  escaped = r_str_escape_sh (\"Hello, $(World)\");",
      "348:  mu_assert_streq (escaped, \"Hello, \\\\$(World)\", \"escaped $(command)\");",
      "349:  free (escaped);",
      "350:  escaped = r_str_escape_sh (\"Hello, `World`\");",
      "351:  mu_assert_streq (escaped, \"Hello, \\\\`World\\\\`\", \"escaped `command`\");",
      "352:  free (escaped);",
      "353: #endif",
      "354:  mu_end;",
      "355: }",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "477:  mu_run_test (test_r_str_utf8_charsize);",
      "478:  mu_run_test (test_r_str_utf8_charsize_prev);",
      "479:  mu_run_test (test_r_str_sanitize_sdb_key);",
      "480:  mu_run_test (test_r_str_unescape);",
      "481:  mu_run_test (test_r_str_constpool);",
      "482:  mu_run_test (test_r_str_format_msvc_argv);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "498:  mu_run_test (test_r_str_escape_sh);",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "9677804b8e4f187656279a109d937c583ca0fb0a",
      "candidate_info": {
        "commit_hash": "9677804b8e4f187656279a109d937c583ca0fb0a",
        "repo": "radareorg/radare2",
        "commit_url": "https://github.com/radareorg/radare2/commit/9677804b8e4f187656279a109d937c583ca0fb0a",
        "files": [
          "doc/debug-internals.md",
          "libr/debug/debug.c",
          "libr/debug/meson.build",
          "libr/debug/p/debug_gdb.c",
          "libr/debug/p/debug_native.c",
          "libr/debug/p/debug_qnx.c",
          "libr/debug/p/debug_windbg.c",
          "libr/debug/p/native/maps/windows_maps.c",
          "libr/debug/p/native/w32.c",
          "libr/debug/p/native/windows/windows_debug.c",
          "libr/debug/p/native/windows/windows_debug.h",
          "libr/include/r_debug.h",
          "libr/io/p/io_debug.c",
          "libr/io/p/io_w32dbg.c",
          "libr/util/sys.c",
          "meson.build"
        ],
        "message": "Windows native debugger refactoring ##debug ##windows\n\n* Windows native debugger refactoring\n\nMassive win32 native debugging code refactoring\nand corresponding fixes.\n\n* Fix hang after killing process",
        "before_after_code_files": [
          "libr/debug/debug.c||libr/debug/debug.c",
          "libr/debug/meson.build||libr/debug/meson.build",
          "libr/debug/p/debug_gdb.c||libr/debug/p/debug_gdb.c",
          "libr/debug/p/debug_native.c||libr/debug/p/debug_native.c",
          "libr/debug/p/debug_qnx.c||libr/debug/p/debug_qnx.c",
          "libr/debug/p/debug_windbg.c||libr/debug/p/debug_windbg.c",
          "libr/debug/p/native/maps/windows_maps.c||libr/debug/p/native/maps/windows_maps.c",
          "libr/debug/p/native/w32.c||libr/debug/p/native/w32.c",
          "libr/debug/p/native/windows/windows_debug.c||libr/debug/p/native/windows/windows_debug.c",
          "libr/debug/p/native/windows/windows_debug.h||libr/debug/p/native/windows/windows_debug.h",
          "libr/include/r_debug.h||libr/include/r_debug.h",
          "libr/io/p/io_debug.c||libr/io/p/io_debug.c",
          "libr/io/p/io_w32dbg.c||libr/io/p/io_w32dbg.c",
          "libr/util/sys.c||libr/util/sys.c",
          "meson.build||meson.build"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "libr/util/sys.c||libr/util/sys.c",
            "meson.build||meson.build"
          ],
          "candidate": [
            "libr/util/sys.c||libr/util/sys.c",
            "meson.build||meson.build"
          ]
        }
      },
      "candidate_diff": {
        "libr/debug/debug.c||libr/debug/debug.c": [
          "File: libr/debug/debug.c -> libr/debug/debug.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "5: #include <signal.h>",
          "7: #if __WINDOWS__",
          "9: #endif",
          "11: R_LIB_VERSION(r_debug);",
          "",
          "[Removed Lines]",
          "8: void w32_break_process(void *);",
          "",
          "[Added Lines]",
          "8: void w32_break_process_wrapper(void *);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "587:   return false;",
          "588:  }",
          "591:   return false;",
          "592:  }",
          "",
          "[Removed Lines]",
          "590:  if (dbg->h && dbg->h->select && !dbg->h->select (pid, tid)) {",
          "",
          "[Added Lines]",
          "590:  if (dbg->h && dbg->h->select && !dbg->h->select (dbg, pid, tid)) {",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1101:   return false;",
          "1102:  }",
          "1103: #if __WINDOWS__",
          "1105: #endif",
          "1106: repeat:",
          "1107:  if (r_debug_is_dead (dbg)) {",
          "",
          "[Removed Lines]",
          "1104:  r_cons_break_push (w32_break_process, dbg);",
          "",
          "[Added Lines]",
          "1104:  r_cons_break_push (w32_break_process_wrapper, dbg);",
          "",
          "---------------"
        ],
        "libr/debug/meson.build||libr/debug/meson.build": [
          "File: libr/debug/meson.build -> libr/debug/meson.build",
          "--- Hunk 1 ---",
          "[Context before]",
          "63: if host_machine.system() == 'windows'",
          "64:  r_debug_sources += [",
          "66:  ]",
          "67: endif",
          "69: if host_machine.system() != 'windows'",
          "73: endif",
          "75: if host_machine.system() == 'darwin'",
          "",
          "[Removed Lines]",
          "65:   'p/native/maps/windows_maps.c'",
          "70:  r_debug_sources += [",
          "71:   'p/native/procfs.c'",
          "72:  ]",
          "",
          "[Added Lines]",
          "65:   'p/native/maps/windows_maps.c',",
          "66:   'p/native/windows/windows_debug.c',",
          "71:   r_debug_sources += [",
          "72:     'p/native/procfs.c'",
          "73:   ]",
          "",
          "---------------"
        ],
        "libr/debug/p/debug_gdb.c||libr/debug/p/debug_gdb.c": [
          "File: libr/debug/p/debug_gdb.c -> libr/debug/p/debug_gdb.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1045:  return true;",
          "1046: }",
          "1049:  if (!desc  || !*origriogdb ) {",
          "1050:   desc = NULL; //TODO hacky fix, please improve. I would suggest using a **desc instead of a *desc, so it is automatically updated",
          "1051:   return false;",
          "",
          "[Removed Lines]",
          "1048: static int r_debug_gdb_select(int pid, int tid) {",
          "",
          "[Added Lines]",
          "1048: static int r_debug_gdb_select(RDebug *dbg, int pid, int tid) {",
          "",
          "---------------"
        ],
        "libr/debug/p/debug_native.c||libr/debug/p/debug_native.c": [
          "File: libr/debug/p/debug_native.c -> libr/debug/p/debug_native.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "31: #endif",
          "33: #if __WINDOWS__",
          "35: #define R_DEBUG_REG_T CONTEXT",
          "37: #ifdef NTSTATUS",
          "38: #undef NTSTATUS",
          "39: #endif",
          "",
          "[Removed Lines]",
          "34: #include <windows.h>",
          "36: #include \"native/w32.c\"",
          "",
          "[Added Lines]",
          "35: #include \"native/windows/windows_debug.h\"",
          "37: R_API RList *r_w32_dbg_modules(RDebug *); //ugly!",
          "38: R_API RList *r_w32_dbg_maps(RDebug *);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "127: #include \"native/reg.c\" // x86 specific",
          "145: #endif",
          "146: static int r_debug_native_step (RDebug *dbg) {",
          "150:  return xnu_step (dbg);",
          "151: #elif __BSD__",
          "152:  int ret = ptrace (PT_STEP, dbg->pid, (caddr_t)1, 0);",
          "153:  if (ret != 0) {",
          "",
          "[Removed Lines]",
          "129: #endif",
          "130: #if __WINDOWS__",
          "131: static int windows_step (RDebug *dbg) {",
          "133: #if _MSC_VER",
          "134:  CONTEXT regs;",
          "135: #else",
          "136:  CONTEXT regs __attribute__ ((aligned (16)));",
          "137: #endif",
          "138:  r_debug_native_reg_read (dbg, R_REG_TYPE_GPR, (ut8 *)&regs, sizeof (regs));",
          "139:  regs.EFlags |= 0x100;",
          "140:  r_debug_native_reg_write (dbg, R_REG_TYPE_GPR, (ut8 *)&regs, sizeof (regs));",
          "141:  r_debug_native_continue (dbg, dbg->pid, dbg->tid, dbg->reason.signum);",
          "142:  (void)r_debug_handle_signals (dbg);",
          "143:  return true;",
          "144: }",
          "147: #if __WINDOWS__",
          "148:  return windows_step (dbg);",
          "149: #elif __APPLE__",
          "",
          "[Added Lines]",
          "134: #if __APPLE__",
          "136: #elif __WINDOWS__",
          "137:  return w32_step (dbg);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "166:  if (!dbg || pid == dbg->pid)",
          "167:   return dbg->tid;",
          "168: #endif",
          "184:  return xnu_attach (dbg, pid);",
          "185: #elif __KFBSD__",
          "186:  if (ptrace (PT_ATTACH, pid, 0, 0) != -1) {",
          "187:   perror (\"ptrace (PT_ATTACH)\");",
          "",
          "[Removed Lines]",
          "169: #if __linux__ || __ANDROID__",
          "170:  return linux_attach (dbg, pid);",
          "171: #elif __WINDOWS__",
          "172:  int ret;",
          "173:  HANDLE process = w32_OpenProcess (PROCESS_ALL_ACCESS, FALSE, pid);",
          "174:  if (process != (HANDLE)NULL && DebugActiveProcess (pid)) {",
          "175:   ret = w32_first_thread (pid);",
          "176:  } else {",
          "177:   ret = -1;",
          "178:  }",
          "180:  ret = w32_first_thread (pid);",
          "181:  CloseHandle (process);",
          "182:  return ret;",
          "183: #elif __APPLE__",
          "",
          "[Added Lines]",
          "156: #if __APPLE__",
          "158: #elif __WINDOWS__",
          "159:  return w32_attach (dbg, pid);",
          "160: #elif __linux__ || __ANDROID__",
          "161:  return linux_attach (dbg, pid);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "198: }",
          "200: static int r_debug_native_detach (RDebug *dbg, int pid) {",
          "204:  return xnu_detach (dbg, pid);",
          "205: #elif __BSD__",
          "206:  return ptrace (PT_DETACH, pid, NULL, 0);",
          "207: #else",
          "",
          "[Removed Lines]",
          "201: #if __WINDOWS__",
          "202:  return w32_DebugActiveProcessStop (pid)? 0 : -1;",
          "203: #elif __APPLE__",
          "",
          "[Added Lines]",
          "178: #if __APPLE__",
          "180: #elif __WINDOWS__",
          "181:  return w32_detach (dbg, pid);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "209: #endif",
          "210: }",
          "212: static int r_debug_native_continue_syscall (RDebug *dbg, int pid, int num) {",
          "214: #if __linux__",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "189: #if __WINDOWS__",
          "190: static int r_debug_native_select (RDebug *dbg, int pid, int tid) {",
          "191:  return w32_select (dbg, pid, tid);",
          "192: }",
          "193: #endif",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "237: static int r_debug_native_continue(RDebug *dbg, int pid, int tid, int sig) {",
          "246:  }",
          "247:  return tid;",
          "250:  if (!ret) {",
          "251:   return -1;",
          "252:  }",
          "",
          "[Removed Lines]",
          "238: #if __WINDOWS__",
          "240:  DWORD continue_status = (sig == DBG_EXCEPTION_NOT_HANDLED)",
          "241:   ? DBG_EXCEPTION_NOT_HANDLED : DBG_CONTINUE;",
          "242:  if (ContinueDebugEvent (pid, tid, continue_status) == 0) {",
          "243:   r_sys_perror (\"r_debug_native_continue/ContinueDebugEvent\");",
          "244:   eprintf (\"debug_contp: error\\n\");",
          "245:   return false;",
          "248: #elif __APPLE__",
          "249:  bool ret = xnu_continue (dbg, pid, tid, sig);",
          "",
          "[Added Lines]",
          "221: #if __APPLE__",
          "222:  bool ret = xnu_continue (dbg, pid, tid, sig);",
          "223:  if (!ret) {",
          "224:   return -1;",
          "227: #elif __WINDOWS__",
          "228:  bool ret = w32_continue (dbg, pid, tid, sig);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "291: static RDebugInfo* r_debug_native_info (RDebug *dbg, const char *arg) {",
          "292: #if __APPLE__",
          "293:  return xnu_info (dbg, arg);",
          "294: #elif __linux__",
          "295:  return linux_info (dbg, arg);",
          "296: #elif __KFBSD__",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "273: #elif __WINDOWS__",
          "274:  return w32_info (dbg, arg);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "373:  kvm_close (kd);",
          "375:  return rdi;",
          "378: #else",
          "379:  return NULL;",
          "380: #endif",
          "",
          "[Removed Lines]",
          "376: #elif __WINDOWS__",
          "377:  return w32_info (dbg, arg);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "474:   RDebugInfo *r = r_debug_native_info (dbg, \"\");",
          "475:   if (r && r->thread) {",
          "476:    PTHREAD_ITEM item = r->thread;",
          "478:    r_cons_printf (\"(%d) Finished thread %d Exit code %d\\n\", (ut32)item->pid, (ut32)item->tid, (ut32)item->dwExitCode);",
          "479:    r_cons_flush ();",
          "481:    r_debug_info_free (r);",
          "482:   }",
          "483:  }",
          "484: #else",
          "485:  if (pid == -1) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "459:  } else if (reason == R_DEBUG_REASON_DEAD) {",
          "460:   RDebugInfo *r = r_debug_native_info (dbg, \"\");",
          "461:   if (r && r->thread) {",
          "462:    PTHREAD_ITEM item = r->thread;",
          "463:    r_cons_printf (\"(%d) Finished process with exit code %d\\n\", dbg->main_pid, item->dwExitCode);",
          "464:    r_cons_flush ();",
          "465:    r_debug_info_free (r);",
          "466:   }",
          "467:   dbg->pid = -1;",
          "468:   dbg->tid = -1;",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "673:  if (!list) {",
          "674:   return NULL;",
          "675:  }",
          "679:  if (pid) {",
          "680:   RDebugPid *p = xnu_get_pid (pid);",
          "681:   if (p) {",
          "",
          "[Removed Lines]",
          "676: #if __WINDOWS__",
          "677:  return w32_pids (pid, list);",
          "678: #elif __APPLE__",
          "",
          "[Added Lines]",
          "662: #if __APPLE__",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "690:    }",
          "691:   }",
          "692:  }",
          "693: #elif __linux__",
          "694:  list->free = (RListFree)&r_debug_pid_free;",
          "695:  DIR *dh;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "677: #elif __WINDOWS__",
          "678:  return w32_pid_list (dbg, pid, list);",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "840:   eprintf (\"No list?\\n\");",
          "841:   return NULL;",
          "842:  }",
          "846:  return xnu_thread_list (dbg, pid, list);",
          "847: #elif __linux__",
          "848:  return linux_thread_list (pid, list);",
          "849: #else",
          "",
          "[Removed Lines]",
          "843: #if __WINDOWS__",
          "844:  return w32_thread_list (pid, list);",
          "845: #elif __APPLE__",
          "",
          "[Added Lines]",
          "829: #if __APPLE__",
          "831: #elif __WINDOWS__",
          "832:  return w32_thread_list (dbg, pid, list);",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "921:  if (size < 1) {",
          "922:   return false;",
          "923:  }",
          "927:  return xnu_reg_read (dbg, type, buf, size);",
          "928: #elif __linux__",
          "929:  return linux_reg_read (dbg, type, buf, size);",
          "930: #elif __sun || __NetBSD__ || __KFBSD__ || __OpenBSD__ || __DragonFly__",
          "",
          "[Removed Lines]",
          "924: #if __WINDOWS__",
          "925:  return w32_reg_read (dbg, type, buf, size);",
          "926: #elif __APPLE__",
          "",
          "[Added Lines]",
          "910: #if __APPLE__",
          "912: #elif __WINDOWS__",
          "913:  return w32_reg_read (dbg, type, buf, size);",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "940:  if (type == R_REG_TYPE_DRX) {",
          "941: #if __i386__ || __x86_64__",
          "945: #elif __linux__",
          "946:   return linux_reg_write (dbg, type, buf, size);",
          "949: #else",
          "954:   return false;",
          "955: #endif",
          "956: #else // i386/x86-64",
          "957:   return false;",
          "958: #endif",
          "959:  } else if (type == R_REG_TYPE_GPR) {",
          "962: #elif __linux__",
          "963:   return linux_reg_write (dbg, type, buf, size);",
          "964: #elif __sun || __NetBSD__ || __KFBSD__ || __OpenBSD__ || __DragonFly__",
          "",
          "[Removed Lines]",
          "942: #if __KFBSD__",
          "943:   return (0 == ptrace (PT_SETDBREGS, dbg->pid,",
          "944:    (caddr_t)buf, sizeof (struct dbreg)));",
          "947: #elif __APPLE__",
          "948:   return xnu_reg_write (dbg, type, buf, size);",
          "951: #if __WINDOWS__",
          "952:   return w32_reg_write (dbg, type, buf, size);",
          "953: #endif",
          "960: #if __WINDOWS__",
          "961:   return w32_reg_write(dbg, type, buf, size);",
          "",
          "[Added Lines]",
          "928: #if __APPLE__",
          "929:   return xnu_reg_write (dbg, type, buf, size);",
          "930: #elif __WINDOWS__",
          "931:   return w32_reg_write (dbg, type, buf, size);",
          "934: #elif __KFBSD__",
          "935:   return (0 == ptrace (PT_SETDBREGS, dbg->pid,",
          "936:    (caddr_t)buf, sizeof (struct dbreg)));",
          "945: #if __APPLE__",
          "946:   return xnu_reg_write (dbg, type, buf, size);",
          "947: #elif __WINDOWS__",
          "948:   return w32_reg_write (dbg, type, buf, size);",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "967:   if (sizeof (R_DEBUG_REG_T) < size)",
          "968:    size = sizeof (R_DEBUG_REG_T);",
          "969:   return (ret != 0) ? false: true;",
          "972: #else",
          "973: #warning r_debug_native_reg_write not implemented",
          "974: #endif",
          "",
          "[Removed Lines]",
          "970: #elif __APPLE__",
          "971:   return xnu_reg_write (dbg, type, buf, size);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "1172: err_linux_map_dealloc:",
          "1173:  return ret;",
          "1174: }",
          "1198: #endif",
          "1200: static RDebugMap* r_debug_native_map_alloc (RDebug *dbg, ut64 addr, int size) {",
          "1202: #if __APPLE__",
          "1204:  return xnu_map_alloc (dbg, addr, size);",
          "1206: #elif __WINDOWS__",
          "1223: #elif __linux__",
          "1224:  return linux_map_alloc (dbg, addr, size);",
          "1225: #else",
          "",
          "[Removed Lines]",
          "1175: #elif __WINDOWS__",
          "1176: static int io_perms_to_prot(int io_perms) {",
          "1177:  int prot_perms;",
          "1179:  if ((io_perms & R_PERM_RWX) == R_PERM_RWX) {",
          "1180:   prot_perms = PAGE_EXECUTE_READWRITE;",
          "1181:  } else if ((io_perms & (R_PERM_W | R_PERM_X)) == (R_PERM_W | R_PERM_X)) {",
          "1182:   prot_perms = PAGE_EXECUTE_READWRITE;",
          "1183:  } else if ((io_perms & (R_PERM_R | R_PERM_X)) == (R_PERM_R | R_PERM_X)) {",
          "1184:   prot_perms = PAGE_EXECUTE_READ;",
          "1185:  } else if ((io_perms & R_PERM_RW) == R_PERM_RW) {",
          "1186:   prot_perms = PAGE_READWRITE;",
          "1187:  } else if (io_perms & R_PERM_W) {",
          "1188:   prot_perms = PAGE_READWRITE;",
          "1189:  } else if (io_perms & R_PERM_X) {",
          "1190:   prot_perms = PAGE_EXECUTE;",
          "1191:  } else if (io_perms & R_PERM_R) {",
          "1192:   prot_perms = PAGE_READONLY;",
          "1193:  } else {",
          "1194:   prot_perms = PAGE_NOACCESS;",
          "1195:  }",
          "1196:  return prot_perms;",
          "1197: }",
          "1207:  RDebugMap *map = NULL;",
          "1208:  LPVOID base = NULL;",
          "1209:  HANDLE process = w32_OpenProcess (PROCESS_ALL_ACCESS, FALSE, dbg->pid);",
          "1210:  if (process == INVALID_HANDLE_VALUE) {",
          "1211:   return map;",
          "1212:  }",
          "1213:  base = VirtualAllocEx (process, (LPVOID)(size_t)addr,",
          "1214:       (SIZE_T)size, MEM_COMMIT, PAGE_READWRITE);",
          "1215:  CloseHandle (process);",
          "1216:  if (!base) {",
          "1217:   eprintf (\"Failed to allocate memory\\n\");",
          "1218:   return map;",
          "1219:  }",
          "1220:  r_debug_map_sync (dbg);",
          "1221:  map = r_debug_map_get (dbg, (ut64)(size_t)base);",
          "1222:  return map;",
          "",
          "[Added Lines]",
          "1166:  return w32_map_alloc (dbg, addr, size);",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "1231: static int r_debug_native_map_dealloc (RDebug *dbg, ut64 addr, int size) {",
          "1232: #if __APPLE__",
          "1234:  return xnu_map_dealloc (dbg, addr, size);",
          "1236: #elif __WINDOWS__",
          "1249: #elif __linux__",
          "1251: #else",
          "1253:  return false;",
          "",
          "[Removed Lines]",
          "1237:  HANDLE process = w32_OpenProcess (PROCESS_ALL_ACCESS, FALSE, dbg->tid);",
          "1238:  if (process == INVALID_HANDLE_VALUE) {",
          "1239:   return false;",
          "1240:  }",
          "1241:  int ret = true;",
          "1242:  if (!VirtualFreeEx (process, (LPVOID)(size_t)addr,",
          "1243:      (SIZE_T)size, MEM_DECOMMIT)) {",
          "1244:   eprintf (\"Failed to free memory\\n\");",
          "1245:   ret = false;",
          "1246:  }",
          "1247:  CloseHandle (process);",
          "1248:  return ret;",
          "1250:  return linux_map_dealloc(dbg, addr, size);",
          "",
          "[Added Lines]",
          "1179:  return w32_map_dealloc (dbg, addr, size);",
          "1181:  return linux_map_dealloc (dbg, addr, size);",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "1410:  }",
          "1411:  fclose (fd);",
          "1412: #endif // __sun",
          "1414:  return list;",
          "1415: }",
          "",
          "[Removed Lines]",
          "1413: #endif // __WINDOWS",
          "",
          "[Added Lines]",
          "1344: #endif // __APPLE__",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "1425:  if (list && !r_list_empty (list)) {",
          "1426:   return list;",
          "1427:  }",
          "1430:  list = r_w32_dbg_modules (dbg);",
          "1431:  if (list && !r_list_empty (list)) {",
          "1432:   return list;",
          "",
          "[Removed Lines]",
          "1428: #endif",
          "1429: #if __WINDOWS__",
          "",
          "[Added Lines]",
          "1359: #elif  __WINDOWS__",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "1470:   pid = dbg->pid;",
          "1471:  }",
          "1472: #if __WINDOWS__",
          "1477: #else",
          "1478: #if 0",
          "1479:  if (thread) {",
          "",
          "[Removed Lines]",
          "1473:  if (sig==0)",
          "1474:   ret = true;",
          "1475:  else",
          "1476:   ret = w32_terminate_process (dbg, pid);",
          "",
          "[Added Lines]",
          "1403:  ret = w32_kill (dbg, pid, tid, sig);",
          "",
          "---------------",
          "--- Hunk 21 ---",
          "[Context before]",
          "1505: static int r_debug_native_init (RDebug *dbg) {",
          "1506:  dbg->h->desc = r_debug_desc_plugin_native;",
          "1507: #if __WINDOWS__",
          "1509: #else",
          "1510:  return true;",
          "1511: #endif",
          "",
          "[Removed Lines]",
          "1508:  return w32_dbg_init ();",
          "",
          "[Added Lines]",
          "1435:  return w32_init (dbg);",
          "",
          "---------------",
          "--- Hunk 22 ---",
          "[Context before]",
          "1784: }",
          "1785: #endif",
          "1867: static RList *r_debug_desc_native_list (int pid) {",
          "1869: #if __APPLE__",
          "1870:  return xnu_desc_list (pid);",
          "1871: #elif __WINDOWS__",
          "1873: #elif __KFBSD__",
          "1874:  RList *ret = NULL;",
          "1875:  int perm, type, mib[4];",
          "",
          "[Removed Lines]",
          "1787: #if __WINDOWS__",
          "1788: static RList *win_desc_list (int pid) {",
          "1789:  RDebugDesc *desc;",
          "1790:  RList *ret = r_list_new();",
          "1791:  int i;",
          "1792:  HANDLE processHandle;",
          "1793:  PSYSTEM_HANDLE_INFORMATION handleInfo;",
          "1794:  NTSTATUS status;",
          "1795:  ULONG handleInfoSize = 0x10000;",
          "1796:  LPVOID buff;",
          "1797:  if (!(processHandle = w32_OpenProcess (0x0040, FALSE, pid))) {",
          "1798:   eprintf (\"win_desc_list: Error opening process.\\n\");",
          "1799:   return NULL;",
          "1800:  }",
          "1801:  handleInfo = (PSYSTEM_HANDLE_INFORMATION)malloc(handleInfoSize);",
          "1802:  #define STATUS_INFO_LENGTH_MISMATCH 0xc0000004",
          "1803:  #define SystemHandleInformation 16",
          "1804:  while ((status = w32_NtQuerySystemInformation(SystemHandleInformation,handleInfo,handleInfoSize,NULL)) == STATUS_INFO_LENGTH_MISMATCH)",
          "1805:   handleInfo = (PSYSTEM_HANDLE_INFORMATION)realloc(handleInfo, handleInfoSize *= 2);",
          "1806:  if (status) {",
          "1807:   eprintf(\"win_desc_list: NtQuerySystemInformation failed!\\n\");",
          "1808:   return NULL;",
          "1809:  }",
          "1810:  for (i = 0; i < handleInfo->HandleCount; i++) {",
          "1811:   SYSTEM_HANDLE handle = handleInfo->Handles[i];",
          "1812:   HANDLE dupHandle = NULL;",
          "1813:   POBJECT_TYPE_INFORMATION objectTypeInfo;",
          "1814:   PVOID objectNameInfo;",
          "1815:   UNICODE_STRING objectName;",
          "1816:   ULONG returnLength;",
          "1817:   if (handle.ProcessId != pid)",
          "1818:    continue;",
          "1819:   if (handle.ObjectTypeNumber != 0x1c)",
          "1820:    continue;",
          "1821:   if (w32_NtDuplicateObject (processHandle, &handle.Handle, GetCurrentProcess(), &dupHandle, 0, 0, 0))",
          "1822:    continue;",
          "1823:   objectTypeInfo = (POBJECT_TYPE_INFORMATION)malloc(0x1000);",
          "1824:   if (w32_NtQueryObject(dupHandle,2,objectTypeInfo,0x1000,NULL)) {",
          "1825:    CloseHandle(dupHandle);",
          "1826:    continue;",
          "1827:   }",
          "1828:   objectNameInfo = malloc(0x1000);",
          "1829:   if (w32_NtQueryObject(dupHandle,1,objectNameInfo,0x1000,&returnLength)) {",
          "1830:    objectNameInfo = realloc(objectNameInfo, returnLength);",
          "1831:    if (w32_NtQueryObject(dupHandle, 1, objectNameInfo, returnLength, NULL)) {",
          "1832:     free(objectTypeInfo);",
          "1833:     free(objectNameInfo);",
          "1834:     CloseHandle(dupHandle);",
          "1835:     continue;",
          "1836:    }",
          "1837:   }",
          "1838:   objectName = *(PUNICODE_STRING)objectNameInfo;",
          "1839:   if (objectName.Length) {",
          "1841:    buff=malloc((objectName.Length/2)+1);",
          "1842:    wcstombs(buff,objectName.Buffer,objectName.Length/2);",
          "1843:    desc = r_debug_desc_new (handle.Handle,",
          "1844:      buff, 0, '?', 0);",
          "1845:    if (!desc) break;",
          "1846:    r_list_append (ret, desc);",
          "1847:    free(buff);",
          "1848:   } else {",
          "1849:    buff=malloc((objectTypeInfo->Name.Length / 2)+1);",
          "1850:    wcstombs(buff,objectTypeInfo->Name.Buffer,objectTypeInfo->Name.Length);",
          "1851:    desc = r_debug_desc_new (handle.Handle,",
          "1852:      buff, 0, '?', 0);",
          "1853:    if (!desc) break;",
          "1854:    r_list_append (ret, desc);",
          "1855:    free(buff);",
          "1856:   }",
          "1857:   free(objectTypeInfo);",
          "1858:   free(objectNameInfo);",
          "1859:   CloseHandle(dupHandle);",
          "1860:  }",
          "1861:  free(handleInfo);",
          "1862:  CloseHandle(processHandle);",
          "1863:  return ret;",
          "1864: }",
          "1865: #endif",
          "1872:  return win_desc_list(pid);",
          "",
          "[Added Lines]",
          "1718:  return w32_desc_list (pid);",
          "",
          "---------------",
          "--- Hunk 23 ---",
          "[Context before]",
          "1976: static int r_debug_native_map_protect (RDebug *dbg, ut64 addr, int size, int perms) {",
          "1977: #if __WINDOWS__",
          "1988: #elif __APPLE__",
          "1989:  return xnu_map_protect (dbg, addr, size, perms);",
          "1990: #elif __linux__",
          "",
          "[Removed Lines]",
          "1978:  DWORD old;",
          "1979:  BOOL ret = FALSE;",
          "1980:  HANDLE h_proc = w32_OpenProcess (PROCESS_ALL_ACCESS, FALSE, dbg->pid);",
          "1982:  if (h_proc) {",
          "1983:   ret = VirtualProtectEx (h_proc, (LPVOID)(size_t)addr,",
          "1984:    size, io_perms_to_prot (perms), &old);",
          "1985:   CloseHandle (h_proc);",
          "1986:  }",
          "1987:  return ret;",
          "",
          "[Added Lines]",
          "1824:  return w32_map_protect (dbg, addr, size, perms);",
          "",
          "---------------",
          "--- Hunk 24 ---",
          "[Context before]",
          "2111:  .contsc = &r_debug_native_continue_syscall,",
          "2112:  .attach = &r_debug_native_attach,",
          "2113:  .detach = &r_debug_native_detach,",
          "2114:  .pids = &r_debug_native_pids,",
          "2115:  .tids = &r_debug_native_tids,",
          "2116:  .threads = &r_debug_native_threads,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1952: #if __WINDOWS__",
          "1953:  .select = &r_debug_native_select,",
          "1954: #endif",
          "",
          "---------------"
        ],
        "libr/debug/p/debug_qnx.c||libr/debug/p/debug_qnx.c": [
          "File: libr/debug/p/debug_qnx.c -> libr/debug/p/debug_qnx.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "37:  r_list_append (list, __r_debug_pid_new (name, pid, 's', 0));",
          "38: }",
          "41:  return qnxr_select (desc, pid, tid);",
          "42: }",
          "",
          "[Removed Lines]",
          "40: static int r_debug_qnx_select (int pid, int tid) {",
          "",
          "[Added Lines]",
          "40: static int r_debug_qnx_select (RDebug *dbg, int pid, int tid) {",
          "",
          "---------------"
        ],
        "libr/debug/p/debug_windbg.c||libr/debug/p/debug_windbg.c": [
          "File: libr/debug/p/debug_windbg.c -> libr/debug/p/debug_windbg.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "199:  return ret;",
          "200: }",
          "203:  ut32 old = windbg_get_target (wctx);",
          "204:  int ret = windbg_set_target (wctx, pid);",
          "205:  if (!ret) {",
          "",
          "[Removed Lines]",
          "202: static int r_debug_windbg_select(int pid, int tid) {",
          "",
          "[Added Lines]",
          "202: static int r_debug_windbg_select(RDebug *dbg, int pid, int tid) {",
          "",
          "---------------"
        ],
        "libr/debug/p/native/maps/windows_maps.c||libr/debug/p/native/maps/windows_maps.c": [
          "File: libr/debug/p/native/maps/windows_maps.c -> libr/debug/p/native/maps/windows_maps.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1: #include \"windows_maps.h\"",
          "4: typedef struct {",
          "5:  RDebugMap *map;",
          "",
          "[Removed Lines]",
          "2: #include \"../w32.h\"",
          "",
          "[Added Lines]",
          "2: #include \"../windows/windows_debug.h\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "26: }",
          "28: static RDebugMap *add_map(RList *list, const char *name, ut64 addr, ut64 len, MEMORY_BASIC_INFORMATION *mbi) {",
          "30:  int perm;",
          "31:  char *map_type = get_map_type (mbi);",
          "34:  switch (mbi->Protect) {",
          "35:  case PAGE_EXECUTE:",
          "",
          "[Removed Lines]",
          "29:  RDebugMap *mr;",
          "32:  char *map_name;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "56:  default:",
          "57:   perm = 0;",
          "58:  }",
          "60:  if (!map_name) {",
          "63:  }",
          "66:  if (mr) {",
          "67:   r_list_append (list, mr);",
          "68:  }",
          "71:  return mr;",
          "72: }",
          "",
          "[Removed Lines]",
          "59:  map_name = r_str_newf (\"%-8s %s\", map_type, name);",
          "61:   perror (\"r_str_newf\");",
          "62:   goto err_add_map;",
          "64:  mr = r_debug_map_new (map_name, addr,",
          "65:   addr + len, perm, mbi->Type == MEM_PRIVATE);",
          "69: err_add_map:",
          "70:  free (map_name);",
          "",
          "[Added Lines]",
          "57:  char *map_name = r_str_newf (\"%-8s %s\", map_type, name);",
          "59:   return NULL;",
          "61:  RDebugMap *mr = r_debug_map_new (map_name, addr, addr + len, perm, mbi->Type == MEM_PRIVATE);",
          "62:  free (map_name);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "76: }",
          "78: R_API RList *r_w32_dbg_modules(RDebug *dbg) {",
          "81:  RList *list = r_list_newf (free);",
          "82:  DWORD flags = TH32CS_SNAPMODULE | TH32CS_SNAPMODULE32;",
          "83:  HANDLE h_mod_snap = w32_CreateToolhelp32Snapshot (flags, dbg->pid);",
          "86:   r_sys_perror (\"r_w32_dbg_modules/CreateToolhelp32Snapshot\");",
          "87:   goto err_w32_dbg_modules;",
          "88:  }",
          "91:   goto err_w32_dbg_modules;",
          "92:  }",
          "93:  do {",
          "99:   free (mod_name);",
          "104:    }",
          "105:   }",
          "107: err_w32_dbg_modules:",
          "108:  if (h_mod_snap) {",
          "109:   CloseHandle (h_mod_snap);",
          "",
          "[Removed Lines]",
          "79:  MODULEENTRY32 me32;",
          "80:  RDebugMap *mr;",
          "85:  if (!h_mod_snap) {",
          "89:  me32.dwSize = sizeof (MODULEENTRY32);",
          "90:  if (!Module32First (h_mod_snap, &me32)) {",
          "94:   char *mod_name;",
          "95:   ut64 baddr = (ut64)(size_t)me32.modBaseAddr;",
          "97:   mod_name = r_sys_conv_win_to_utf8 (me32.szModule);",
          "98:   mr = r_debug_map_new (mod_name, baddr, baddr + me32.modBaseSize, 0, 0);",
          "100:   if (mr) {",
          "101:    mr->file = r_sys_conv_win_to_utf8 (me32.szExePath);",
          "102:    if (mr->file) {",
          "103:     r_list_append (list, mr);",
          "106:  } while (Module32Next (h_mod_snap, &me32));",
          "",
          "[Added Lines]",
          "74:  if (dbg->main_pid == -1) {",
          "75:   return NULL;",
          "76:  }",
          "77:  MODULEENTRY32 me;",
          "82:  if (h_mod_snap == INVALID_HANDLE_VALUE) {",
          "86:  me.dwSize = sizeof (MODULEENTRY32);",
          "87:  if (!Module32First (h_mod_snap, &me)) {",
          "88:   r_sys_perror (\"r_w32_dbg_modules/Module32First\");",
          "92:   ut64 baddr = (ut64)(size_t)me.modBaseAddr;",
          "93:   char *mod_name = r_sys_conv_win_to_utf8 (me.szModule);",
          "94:   RDebugMap *dbgmap = r_debug_map_new (mod_name, baddr, baddr + me.modBaseSize, 0, 0);",
          "96:   if (dbgmap) {",
          "97:    dbgmap->file = r_sys_conv_win_to_utf8 (me.szExePath);",
          "98:    if (dbgmap->file) {",
          "99:     r_list_append (list, dbgmap);",
          "102:  } while (Module32Next (h_mod_snap, &me));",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "111:  return list;",
          "112: }",
          "114: static int set_mod_inf(HANDLE h_proc, RDebugMap *map, RWinModInfo *mod) {",
          "115:  IMAGE_DOS_HEADER *dos_hdr;",
          "116:  IMAGE_NT_HEADERS *nt_hdrs;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "110: static bool is_pe_hdr(unsigned char *pe_hdr) {",
          "111:  IMAGE_DOS_HEADER *dos_header = (IMAGE_DOS_HEADER *)pe_hdr;",
          "112:  IMAGE_NT_HEADERS *nt_headers;",
          "114:  if (dos_header->e_magic == IMAGE_DOS_SIGNATURE) {",
          "115:   nt_headers = (IMAGE_NT_HEADERS *)((char *)dos_header",
          "116:     + dos_header->e_lfanew);",
          "118:   if (nt_headers->Signature == IMAGE_NT_SIGNATURE)",
          "119:    return true;",
          "120:  }",
          "121:  return false;",
          "122: }",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "126:  ReadProcessMemory (h_proc, (LPCVOID)(size_t)map->addr, (LPVOID)pe_hdr, sizeof (pe_hdr), &len);",
          "127:  if (len == (SIZE_T)sizeof (pe_hdr) && is_pe_hdr (pe_hdr)) {",
          "128:   dos_hdr = (IMAGE_DOS_HEADER *)pe_hdr;",
          "132:   nt_hdrs = (IMAGE_NT_HEADERS *)((char *)dos_hdr + dos_hdr->e_lfanew);",
          "137:    nt_hdrs32 = (IMAGE_NT_HEADERS32 *)((char *)dos_hdr + dos_hdr->e_lfanew);",
          "138:    mod->sect_count = nt_hdrs32->FileHeader.NumberOfSections;",
          "139:    sect_hdr = (IMAGE_SECTION_HEADER *)((char *)nt_hdrs32 + sizeof (IMAGE_NT_HEADERS32));",
          "",
          "[Removed Lines]",
          "129:   if (!dos_hdr) {",
          "130:    goto err_set_mod_info;",
          "131:   }",
          "133:   if (!nt_hdrs) {",
          "134:    goto err_set_mod_info;",
          "135:   }",
          "136:   if (nt_hdrs->FileHeader.Machine == 0x014c) { // check for x32 pefile",
          "",
          "[Added Lines]",
          "140:   if (nt_hdrs->FileHeader.Machine == IMAGE_FILE_MACHINE_I386) { // check for x32 pefile",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "141:    mod->sect_count = nt_hdrs->FileHeader.NumberOfSections;",
          "142:    sect_hdr = (IMAGE_SECTION_HEADER *)((char *)nt_hdrs + sizeof (IMAGE_NT_HEADERS));",
          "143:   }",
          "148:   }",
          "151:  }",
          "153:  if (mod_inf_fill == -1) {",
          "154:   R_FREE (mod->sect_hdr);",
          "155:  }",
          "",
          "[Removed Lines]",
          "144:   mod->sect_hdr = (IMAGE_SECTION_HEADER *)malloc (sizeof (IMAGE_SECTION_HEADER) * mod->sect_count);",
          "145:   if (!mod->sect_hdr) {",
          "146:    perror (\"malloc set_mod_inf()\");",
          "147:    goto err_set_mod_info;",
          "149:   memcpy (mod->sect_hdr, sect_hdr, sizeof (IMAGE_SECTION_HEADER) * mod->sect_count);",
          "150:   mod_inf_fill = 0;",
          "152: err_set_mod_info:",
          "",
          "[Added Lines]",
          "148:   if ((char *)sect_hdr + (sizeof (IMAGE_SECTION_HEADER) * mod->sect_count) < ((char *)pe_hdr + sizeof (pe_hdr))) {",
          "149:    mod->sect_hdr = (IMAGE_SECTION_HEADER *)malloc (sizeof (IMAGE_SECTION_HEADER) * mod->sect_count);",
          "150:    if (mod->sect_hdr) {",
          "151:     memcpy (mod->sect_hdr, sect_hdr, sizeof (IMAGE_SECTION_HEADER) * mod->sect_count);",
          "152:     mod_inf_fill = 0;",
          "153:    } else {",
          "154:     perror (\"malloc set_mod_inf()\");",
          "155:    }",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "196:     char *map_name = r_str_newf (\"%s | %s\", mod->map->name, sect_hdr->Name);",
          "197:     if (!map_name) {",
          "198:      perror (\"r_str_newf\");",
          "200:     }",
          "201:     if (sect_found == 1) {",
          "202:      add_map (map_list, map_name, sect_addr, sect_len, mbi);",
          "",
          "[Removed Lines]",
          "199:      goto err_proc_mem_img;",
          "",
          "[Added Lines]",
          "204:      return;",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "217:    add_map_reg (map_list, mod->map->name, mbi);",
          "218:   }",
          "219:  }",
          "222: }",
          "224: static void proc_mem_map(HANDLE h_proc, RList *map_list, MEMORY_BASIC_INFORMATION *mbi) {",
          "225:  TCHAR f_name[MAX_PATH + 1];",
          "228:  if (len > 0) {",
          "229:   char *f_name_ = r_sys_conv_win_to_utf8 (f_name);",
          "230:   add_map_reg (map_list, f_name_, mbi);",
          "",
          "[Removed Lines]",
          "220: err_proc_mem_img:",
          "221:  ;",
          "227:  DWORD len = w32_GetMappedFileName (h_proc, mbi->BaseAddress, f_name, MAX_PATH);",
          "",
          "[Added Lines]",
          "230:  DWORD len = GetMappedFileName (h_proc, mbi->BaseAddress, f_name, MAX_PATH);",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "235: }",
          "237: R_API RList *r_w32_dbg_maps(RDebug *dbg) {",
          "238:  SYSTEM_INFO si = {0};",
          "239:  LPVOID cur_addr;",
          "240:  MEMORY_BASIC_INFORMATION mbi;",
          "242:  RWinModInfo mod_inf = {0};",
          "243:  RList *map_list = r_list_new(), *mod_list = NULL;",
          "245:  GetSystemInfo (&si);",
          "251:  cur_addr = si.lpMinimumApplicationAddress;",
          "253:  mod_list = r_w32_dbg_modules (dbg);",
          "255:  while (cur_addr < si.lpMaximumApplicationAddress &&",
          "257:   if (mbi.State != MEM_FREE) {",
          "258:    switch (mbi.Type) {",
          "259:    case MEM_IMAGE:",
          "261:     break;",
          "262:    case MEM_MAPPED:",
          "264:     break;",
          "265:    default:",
          "266:     add_map_reg (map_list, \"\", &mbi);",
          "",
          "[Removed Lines]",
          "241:  HANDLE h_proc;",
          "246:  h_proc = w32_OpenProcess (PROCESS_QUERY_INFORMATION | PROCESS_VM_READ, FALSE, dbg->pid);",
          "247:  if (!h_proc) {",
          "248:   r_sys_perror (\"r_w32_dbg_maps/w32_OpenProcess\");",
          "249:   goto err_w32_dbg_maps;",
          "250:  }",
          "256:   VirtualQueryEx (h_proc, cur_addr, &mbi, sizeof (mbi)) != 0) {",
          "260:     proc_mem_img (h_proc, map_list, mod_list, &mod_inf, &si, &mbi);",
          "263:     proc_mem_map (h_proc, map_list, &mbi);",
          "",
          "[Added Lines]",
          "241:  if (dbg->pid == -1) {",
          "242:   return NULL;",
          "243:  }",
          "249:  RIOW32Dbg *rio = dbg->user;",
          "257:   VirtualQueryEx (rio->pi.hProcess, cur_addr, &mbi, sizeof (mbi)) != 0) {",
          "261:     proc_mem_img (rio->pi.hProcess, map_list, mod_list, &mod_inf, &si, &mbi);",
          "264:     proc_mem_map (rio->pi.hProcess, map_list, &mbi);",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "268:   }",
          "269:   cur_addr = (LPVOID)(size_t)((ut64)(size_t)mbi.BaseAddress + mbi.RegionSize);",
          "270:  }",
          "272:  free (mod_inf.sect_hdr);",
          "273:  r_list_free (mod_list);",
          "274:  return map_list;",
          "",
          "[Removed Lines]",
          "271: err_w32_dbg_maps:",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "libr/debug/p/native/w32.c||libr/debug/p/native/w32.c": [
          "File: libr/debug/p/native/w32.c -> libr/debug/p/native/w32.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "211:  case EXCEPTION_INT_DIVIDE_BY_ZERO:",
          "212:  case EXCEPTION_STACK_OVERFLOW:",
          "213:   eprintf (\"(%d) Fatal exception (%s) in thread %d\\n\",",
          "215:    get_w32_excep_name(code),",
          "216:    (int)de->dwThreadId);",
          "217:   break;",
          "",
          "[Removed Lines]",
          "214:    (int)de->dwProcessId,",
          "",
          "[Added Lines]",
          "214:    (int)de->dwProcessId,",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "278:    }",
          "279:   }",
          "280:   cur_drive++;",
          "282: err_get_file_name_from_handle:",
          "283:  if (map) {",
          "284:   UnmapViewOfFile (map);",
          "",
          "[Removed Lines]",
          "281:  }",
          "",
          "[Added Lines]",
          "281:  }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "291:   free (filename);",
          "292:   return filename_;",
          "295:  return NULL;",
          "296: }",
          "297: LPVOID lstLib = 0;",
          "",
          "[Removed Lines]",
          "294:  }",
          "",
          "[Added Lines]",
          "294:  }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "531:  IMAGE_DOS_HEADER *dos_header = (IMAGE_DOS_HEADER *)pe_hdr;",
          "532:  IMAGE_NT_HEADERS *nt_headers;",
          "535:   nt_headers = (IMAGE_NT_HEADERS *)((char *)dos_header",
          "536:     + dos_header->e_lfanew);",
          "538:    return true;",
          "539:  }",
          "540:  return false;",
          "",
          "[Removed Lines]",
          "534:  if (dos_header->e_magic==IMAGE_DOS_SIGNATURE) {",
          "537:   if (nt_headers->Signature==IMAGE_NT_SIGNATURE)",
          "",
          "[Added Lines]",
          "534:  if (dos_header->e_magic == IMAGE_DOS_SIGNATURE) {",
          "538:   if (nt_headers->Signature == IMAGE_NT_SIGNATURE)",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "556:         te32.dwSize = sizeof(THREADENTRY32);",
          "562:         th = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, pid);",
          "563:         if(th == INVALID_HANDLE_VALUE || !Thread32First (th, &te32))",
          "564:                 goto err_load_th;",
          "565:         do {",
          "571: #if 0",
          "580: #endif",
          "588:         } while (Thread32Next (th, &te32));",
          "589: err_load_th:",
          "590:         if(th != INVALID_HANDLE_VALUE)",
          "592:  return list;",
          "593: }",
          "",
          "[Removed Lines]",
          "558:  if (!w32_OpenThread) {",
          "559:   eprintf(\"w32_thread_list: no w32_OpenThread?\\n\");",
          "560:   return list;",
          "561:  }",
          "567:                 if (te32.th32OwnerProcessID == pid) {",
          "572:  75 typedef struct tagTHREADENTRY32 {",
          "573:  76         DWORD dwSize;",
          "574:  77         DWORD cntUsage;",
          "575:  78         DWORD th32ThreadID;",
          "576:  79         DWORD th32OwnerProcessID;",
          "577:  80         LONG tpBasePri;",
          "578:  81         LONG tpDeltaPri;",
          "579:  82         DWORD dwFlags;",
          "581:    thid = w32_OpenThread (THREAD_ALL_ACCESS, 0, te32.th32ThreadID);",
          "582:    if (!thid) {",
          "583:     r_sys_perror (\"w32_thread_list/OpenThread\");",
          "584:                                 goto err_load_th;",
          "585:    }",
          "586:    r_list_append (list, r_debug_pid_new (\"???\", te32.th32ThreadID, 0, 's', 0));",
          "587:                 }",
          "591:                 CloseHandle (th);",
          "",
          "[Added Lines]",
          "559:   if (!w32_OpenThread) {",
          "560:    eprintf(\"w32_thread_list: no w32_OpenThread?\\n\");",
          "561:    return list;",
          "562:   }",
          "568:             if (te32.th32OwnerProcessID == pid) {",
          "572:      75 typedef struct tagTHREADENTRY32 {",
          "573:      76         DWORD dwSize;",
          "574:      77         DWORD cntUsage;",
          "575:      78         DWORD th32ThreadID;",
          "576:      79         DWORD th32OwnerProcessID;",
          "577:      80         LONG tpBasePri;",
          "578:      81         LONG tpDeltaPri;",
          "579:      82         DWORD dwFlags;",
          "580:      83 };",
          "582:     thid = w32_OpenThread (THREAD_ALL_ACCESS, 0, te32.th32ThreadID);",
          "583:     if (!thid) {",
          "584:      r_sys_perror (\"w32_thread_list/OpenThread\");",
          "585:      goto err_load_th;",
          "586:     }",
          "587:     r_list_append (list, r_debug_pid_new (\"???\", te32.th32ThreadID, 0, 's', 0));",
          "588:             }",
          "592:             CloseHandle (th);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "957:   goto err_w32_info_user;",
          "958:  }",
          "959:  if (*usr_dom) {",
          "961:  } else {",
          "962:   rdi->usr = r_sys_conv_win_to_utf8 (usr);",
          "963:  }",
          "",
          "[Removed Lines]",
          "960:   rdi->usr = r_str_newf (W32_TCHAR_FSTR\"\\\\\"W32_TCHAR_FSTR, usr_dom, usr);",
          "",
          "[Added Lines]",
          "961:   rdi->usr = r_str_newf (W32_TCHAR_FSTR\"\\\\\"W32_TCHAR_FSTR, usr_dom, usr);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "1021:  w32_info_user (dbg, rdi);",
          "1022:  w32_info_exe (dbg, rdi);",
          "1023:  return rdi;",
          "",
          "[Removed Lines]",
          "1024: }",
          "",
          "[Added Lines]",
          "1027: #include \"maps/windows.c\"",
          "",
          "---------------"
        ],
        "libr/debug/p/native/windows/windows_debug.c||libr/debug/p/native/windows/windows_debug.c": [
          "File: libr/debug/p/native/windows/windows_debug.c -> libr/debug/p/native/windows/windows_debug.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2: #include <string.h>",
          "3: #include \"windows_debug.h\"",
          "5: const DWORD wait_time = 1000;",
          "7: #define w32_PROCESS_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED | SYNCHRONIZE | 0xFFF)",
          "8: #define w32_THREAD_ALL_ACCESS w32_PROCESS_ALL_ACCESS",
          "9: bool setup_debug_privileges(bool b) {",
          "10:  HANDLE tok;",
          "11:  if (!OpenProcessToken (GetCurrentProcess (), TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &tok)) {",
          "12:   return false;",
          "13:  }",
          "14:  bool ret = false;",
          "15:  LUID luid;",
          "16:  if (LookupPrivilegeValue (NULL, SE_DEBUG_NAME, &luid)) {",
          "17:   TOKEN_PRIVILEGES tp;",
          "18:   tp.PrivilegeCount = 1;",
          "19:   tp.Privileges[0].Luid = luid;",
          "20:   tp.Privileges[0].Attributes = b ? SE_PRIVILEGE_ENABLED : 0;",
          "21:   if (AdjustTokenPrivileges (tok, FALSE, &tp, 0, NULL, NULL)) {",
          "23:    ret = GetLastError () == ERROR_SUCCESS;",
          "24:   }",
          "25:  }",
          "26:  CloseHandle (tok);",
          "27:  return ret;",
          "28: }",
          "30: int w32_init(RDebug *dbg) {",
          "31:  if (!dbg->user) {",
          "32:   RIOW32Dbg *rio = R_NEW0 (RIOW32Dbg);",
          "33:   if (rio) {",
          "34:    rio->pi.dwProcessId = dbg->pid;",
          "35:    rio->pi.dwThreadId = dbg->tid;",
          "36:   }",
          "37:   dbg->user = rio;",
          "38:  }",
          "41:  setup_debug_privileges (true);",
          "43:  HMODULE lib = GetModuleHandle (TEXT (\"kernel32\")); //Always loaded",
          "44:  if (!lib) {",
          "45:   return false;",
          "46:  }",
          "48:  w32_DebugActiveProcessStop = (BOOL (WINAPI *) (DWORD))",
          "49:   GetProcAddress (lib, \"DebugActiveProcessStop\");",
          "51:  w32_OpenThread = (HANDLE (WINAPI *) (DWORD, BOOL, DWORD))",
          "52:   GetProcAddress (lib, \"OpenThread\");",
          "54:  w32_OpenProcess = (HANDLE (WINAPI *) (DWORD, BOOL, DWORD))",
          "55:   GetProcAddress (lib, \"OpenProcess\");",
          "57:  w32_DebugBreakProcess = (BOOL (WINAPI *) (HANDLE))",
          "58:   GetProcAddress (lib, \"DebugBreakProcess\");",
          "60:  w32_CreateToolhelp32Snapshot = (HANDLE (WINAPI *) (DWORD, DWORD))",
          "61:   GetProcAddress (lib, \"CreateToolhelp32Snapshot\");",
          "64:  w32_GetThreadId = (DWORD (WINAPI *) (HANDLE))",
          "65:   GetProcAddress (lib, \"GetThreadId\");",
          "68:  w32_GetProcessId = (DWORD (WINAPI *) (HANDLE))",
          "69:   GetProcAddress (lib, \"GetProcessId\");",
          "71:  w32_QueryFullProcessImageName = (BOOL (WINAPI *) (HANDLE, DWORD, LPTSTR, PDWORD))",
          "72:   GetProcAddress (lib, W32_TCALL (\"QueryFullProcessImageName\"));",
          "75:  w32_GetEnabledXStateFeatures = (ut64 (WINAPI *) ())",
          "76:   GetProcAddress (lib, \"GetEnabledXStateFeatures\");",
          "78:  w32_InitializeContext = (BOOL (WINAPI *) (PVOID, DWORD, PCONTEXT *, PDWORD))",
          "79:   GetProcAddress (lib, \"InitializeContext\");",
          "81:  w32_GetXStateFeaturesMask = (BOOL (WINAPI *) (PCONTEXT Context, PDWORD64))",
          "82:   GetProcAddress (lib, \"GetXStateFeaturesMask\");",
          "84:  w32_LocateXStateFeature = (PVOID (WINAPI *) (PCONTEXT Context, DWORD, PDWORD))",
          "85:   GetProcAddress (lib, \"LocateXStateFeature\");",
          "87:  w32_SetXStateFeaturesMask = (BOOL (WINAPI *) (PCONTEXT Context, DWORD64))",
          "88:   GetProcAddress (lib, \"SetXStateFeaturesMask\");",
          "90:  lib = LoadLibrary (TEXT (\"psapi.dll\"));",
          "91:  if (!lib) {",
          "92:   eprintf (\"Cannot load psapi.dll. Aborting\\n\");",
          "93:   return false;",
          "94:  }",
          "95:  w32_GetMappedFileName = (DWORD (WINAPI *) (HANDLE, LPVOID, LPTSTR, DWORD))",
          "96:   GetProcAddress (lib, W32_TCALL (\"GetMappedFileName\"));",
          "98:  w32_GetModuleBaseName = (DWORD (WINAPI *) (HANDLE, HMODULE, LPTSTR, DWORD))",
          "99:   GetProcAddress (lib, W32_TCALL (\"GetModuleBaseName\"));",
          "101:  w32_GetModuleInformation = (BOOL (WINAPI *) (HANDLE, HMODULE, LPMODULEINFO, DWORD))",
          "102:   GetProcAddress (lib, \"GetModuleInformation\");",
          "104:  w32_GetModuleFileNameEx = (DWORD (WINAPI *) (HANDLE, HMODULE, LPTSTR, DWORD))",
          "105:   GetProcAddress (lib, W32_TCALL (\"GetModuleFileNameEx\"));",
          "107:  lib = LoadLibrary (TEXT (\"ntdll.dll\"));",
          "108:  if (!lib) {",
          "109:   eprintf (\"Cannot load ntdll.dll. Aborting\\n\");",
          "110:   return false;",
          "111:  }",
          "112:  w32_NtQuerySystemInformation = (NTSTATUS (WINAPI *) (ULONG, PVOID, ULONG, PULONG))",
          "113:   GetProcAddress (lib, \"NtQuerySystemInformation\");",
          "115:  w32_NtDuplicateObject = (NTSTATUS (WINAPI *) (HANDLE, HANDLE, HANDLE, PHANDLE, ACCESS_MASK, ULONG, ULONG))",
          "116:   GetProcAddress (lib, \"NtDuplicateObject\");",
          "118:  w32_NtQueryObject = (NTSTATUS (WINAPI *) (HANDLE, ULONG, PVOID, ULONG, PULONG))",
          "119:   GetProcAddress (lib, \"NtQueryObject\");",
          "121:  w32_NtQueryInformationThread = (NTSTATUS (WINAPI *) (HANDLE, ULONG, PVOID, ULONG, PULONG))",
          "122:   GetProcAddress (lib, \"NtQueryInformationThread\");",
          "124:  if (!w32_DebugActiveProcessStop || !w32_OpenThread || !w32_DebugBreakProcess ||",
          "125:   !w32_GetModuleBaseName || !w32_GetModuleInformation) {",
          "127:   eprintf (\"debug_init_calls:\\n\"",
          "128:     \"DebugActiveProcessStop: 0x%p\\n\"",
          "129:     \"OpenThread: 0x%p\\n\"",
          "130:     \"DebugBreakProcess: 0x%p\\n\"",
          "131:     \"GetThreadId: 0x%p\\n\",",
          "132:    w32_DebugActiveProcessStop, w32_OpenThread, w32_DebugBreakProcess, w32_GetThreadId);",
          "133:   return false;",
          "134:  }",
          "137:  return true;",
          "138: }",
          "140: static PTHREAD_ITEM __r_debug_thread_add(RDebug *dbg, DWORD pid, DWORD tid, HANDLE hThread, LPVOID lpThreadLocalBase, LPVOID lpStartAddress, BOOL bFinished) {",
          "141:  r_return_val_if_fail (dbg, NULL);",
          "142:  PVOID startAddress = 0;",
          "143:  if (!dbg->threads) {",
          "144:   dbg->threads = r_list_newf (free);",
          "145:  }",
          "146:  if (!lpStartAddress) {",
          "147:   w32_NtQueryInformationThread (hThread, 9, &lpStartAddress, sizeof (LPVOID), NULL);",
          "148:  }",
          "149:  RListIter *it;",
          "150:  THREAD_ITEM th = {",
          "151:    pid,",
          "152:    tid,",
          "153:    bFinished,",
          "154:    false,",
          "155:    hThread,",
          "156:    lpThreadLocalBase,",
          "157:    lpStartAddress",
          "158:  };",
          "159:  PTHREAD_ITEM pthread;",
          "160:  r_list_foreach (dbg->threads, it, pthread) {",
          "161:   if (pthread->tid == tid) {",
          "163:    return NULL;",
          "164:   }",
          "165:  }",
          "166:  pthread = R_NEW0 (THREAD_ITEM);",
          "167:  if (!pthread) {",
          "168:   R_LOG_ERROR (\"__r_debug_thread_add: Memory allocation failed.\\n\");",
          "169:   return NULL;",
          "170:  }",
          "172:  r_list_append (dbg->threads, pthread);",
          "173:  return pthread;",
          "174: }",
          "176: static int __suspend_thread(HANDLE th, int bits) {",
          "177:  int ret;",
          "179:   if ((ret = SuspendThread (th)) == -1) {",
          "180:    r_sys_perror (\"__suspend_thread/SuspendThread\");",
          "181:   }",
          "183:   if ((ret = Wow64SuspendThread (th)) == -1) {",
          "184:    r_sys_perror (\"__suspend_thread/Wow64SuspendThread\");",
          "185:   }",
          "187:  return ret;",
          "188: }",
          "190: static int __resume_thread(HANDLE th, int bits) {",
          "191:  int ret;",
          "193:   if ((ret = ResumeThread (th)) == -1) {",
          "194:    r_sys_perror (\"__resume_thread/ResumeThread\");",
          "195:   }",
          "197:   if ((ret = ResumeThread (th)) == -1) {",
          "198:    r_sys_perror (\"__resume_thread/Wow64ResumeThread\");",
          "199:   }",
          "201:  return ret;",
          "202: }",
          "204: static inline void __continue_thread(HANDLE th, int bits) {",
          "205:  int ret;",
          "206:  do {",
          "207:   ret = __resume_thread (th, bits);",
          "208:  } while (ret > 0);",
          "209: }",
          "211: static int __w32_findthread_cmp(int *tid, PTHREAD_ITEM th) {",
          "212:  return (int)!(*tid == th->tid);",
          "213: }",
          "215: static bool __is_thread_alive(RDebug *dbg, int tid) {",
          "216:  RListIter *it = r_list_find (dbg->threads, &tid, (RListComparator)__w32_findthread_cmp);",
          "217:  if (!it) {",
          "218:   return false;",
          "219:  }",
          "220:  PTHREAD_ITEM th = it->data;",
          "221:  if (!th->bFinished) {",
          "222:   if (SuspendThread (th->hThread) != -1) {",
          "223:    ResumeThread (th->hThread);",
          "224:    return true;",
          "225:   }",
          "226:  }",
          "227:  th->bFinished = true;",
          "228:  return false;",
          "229: }",
          "231: static bool __is_proc_alive(HANDLE ph) {",
          "232:  if (ph) {",
          "233:   DWORD code;",
          "234:   if (!GetExitCodeProcess (ph, &code)) {",
          "235:    GetExitCodeThread (ph, &code);",
          "236:   }",
          "237:   return code == STILL_ACTIVE;",
          "238:  }",
          "239:  return false;",
          "240: }",
          "242: static int __set_thread_context(HANDLE th, const ut8 *buf, int size, int bits) {",
          "243:  bool ret;",
          "244:  CONTEXT ctx = {0};",
          "245:  size = R_MIN (size, sizeof (ctx));",
          "246:  memcpy (&ctx, buf, size);",
          "247:  if(!(ret = SetThreadContext (th, &ctx))) {",
          "248:   r_sys_perror (\"__set_thread_context/SetThreadContext\");",
          "249:  }",
          "250:  return ret;",
          "251: }",
          "253: static int __get_thread_context(HANDLE th, ut8 *buf, int size, int bits) {",
          "254:  int ret = 0;",
          "255:  CONTEXT ctx = {0};",
          "257:  ctx.ContextFlags = CONTEXT_ALL;",
          "258:  if (GetThreadContext (th, &ctx)) {",
          "259:   if (size > sizeof (ctx)) {",
          "260:    size = sizeof (ctx);",
          "261:   }",
          "262:   memcpy (buf, &ctx, size);",
          "263:   ret = size;",
          "264:  } else {",
          "265:   if (__is_proc_alive (th)) {",
          "266:    r_sys_perror (\"__get_thread_context/GetThreadContext\");",
          "267:   }",
          "268:  }",
          "269:  return ret;",
          "270: }",
          "272: static int __get_avx(HANDLE th, ut128 xmm[16], ut128 ymm[16]) {",
          "273:  int nregs = 0, index = 0;",
          "274:  DWORD ctxsize = 0;",
          "275:  DWORD featurelen = 0;",
          "276:  ut64 featuremask = 0;",
          "277:  ut128 *newxmm = NULL;",
          "278:  ut128 *newymm = NULL;",
          "279:  void *buffer = NULL;",
          "280:  PCONTEXT ctx;",
          "281:  if (!w32_GetEnabledXStateFeatures) {",
          "282:   return 0;",
          "283:  }",
          "285:  featuremask = w32_GetEnabledXStateFeatures ();",
          "286:  if ((featuremask & XSTATE_MASK_AVX) == 0) {",
          "287:   return 0;",
          "288:  }",
          "289:  if ((w32_InitializeContext (NULL, CONTEXT_ALL | CONTEXT_XSTATE, NULL, &ctxsize)) || (GetLastError () != ERROR_INSUFFICIENT_BUFFER)) {",
          "290:   return 0;",
          "291:  }",
          "292:  buffer = malloc (ctxsize);",
          "293:  if (!buffer) {",
          "294:   return 0;",
          "295:  }",
          "296:  if (!w32_InitializeContext (buffer, CONTEXT_ALL | CONTEXT_XSTATE, &ctx, &ctxsize)) {",
          "297:   goto err_get_avx;",
          "298:  }",
          "299:  if (!w32_SetXStateFeaturesMask (ctx, XSTATE_MASK_AVX)) {",
          "300:   goto err_get_avx;",
          "301:  }",
          "303:  if (!GetThreadContext (th, ctx)) {",
          "304:   goto err_get_avx;",
          "305:  }",
          "306:  if (w32_GetXStateFeaturesMask (ctx, &featuremask)) {",
          "307:   goto err_get_avx;",
          "308:  }",
          "309:  newxmm = (ut128 *)w32_LocateXStateFeature (ctx, XSTATE_LEGACY_SSE, &featurelen);",
          "310:   nregs = featurelen / sizeof(*newxmm);",
          "311:  for (index = 0; index < nregs; index++) {",
          "312:   ymm[index].High = 0;",
          "313:   xmm[index].High = 0;",
          "314:   ymm[index].Low = 0;",
          "315:   xmm[index].Low = 0;",
          "316:  }",
          "317:  if (newxmm != NULL) {",
          "318:   for (index = 0; index < nregs; index++) {",
          "319:    xmm[index].High = newxmm[index].High;",
          "320:    xmm[index].Low = newxmm[index].Low;",
          "321:   }",
          "322:  }",
          "323:  if ((featuremask & XSTATE_MASK_AVX) != 0) {",
          "325:   newymm = (ut128 *)w32_LocateXStateFeature (ctx, XSTATE_AVX, NULL);",
          "326:   if (!newymm) {",
          "327:    goto err_get_avx;",
          "328:   }",
          "329:   for (index = 0; index < nregs; index++) {",
          "330:    ymm[index].High = newymm[index].High;",
          "331:    ymm[index].Low = newymm[index].Low;",
          "332:   }",
          "333:  }",
          "334: err_get_avx:",
          "335:  free (buffer);",
          "336:  return nregs;",
          "337: }",
          "339: static void __printwincontext(HANDLE th, CONTEXT *ctx) {",
          "340:  ut128 xmm[16];",
          "341:  ut128 ymm[16];",
          "342:  ut80 st[8];",
          "343:  ut64 mm[8];",
          "344:  ut16 top = 0;",
          "345:  int x, nxmm = 0, nymm = 0;",
          "346: #if _WIN64",
          "347:  eprintf (\"ControlWord   = %08x StatusWord   = %08x\\n\", ctx->FltSave.ControlWord, ctx->FltSave.StatusWord);",
          "348:  eprintf (\"MxCsr         = %08x TagWord      = %08x\\n\", ctx->MxCsr, ctx->FltSave.TagWord);",
          "349:  eprintf (\"ErrorOffset   = %08x DataOffset   = %08x\\n\", ctx->FltSave.ErrorOffset, ctx->FltSave.DataOffset);",
          "350:  eprintf (\"ErrorSelector = %08x DataSelector = %08x\\n\", ctx->FltSave.ErrorSelector, ctx->FltSave.DataSelector);",
          "351:  for (x = 0; x < 8; x++) {",
          "352:   st[x].Low = ctx->FltSave.FloatRegisters[x].Low;",
          "353:   st[x].High = (ut16)ctx->FltSave.FloatRegisters[x].High;",
          "354:  }",
          "355:  top = (ctx->FltSave.StatusWord & 0x3fff) >> 11;",
          "356:  for (x = 0; x < 8; x++) {",
          "357:   mm[top] = ctx->FltSave.FloatRegisters[x].Low;",
          "358:   top++;",
          "359:   if (top > 7) {",
          "360:    top = 0;",
          "361:   }",
          "362:  }",
          "363:  for (x = 0; x < 16; x++) {",
          "364:   xmm[x].High = ctx->FltSave.XmmRegisters[x].High;",
          "365:   xmm[x].Low = ctx->FltSave.XmmRegisters[x].Low;",
          "366:  }",
          "367:  nxmm = 16;",
          "368: #else",
          "369:  eprintf (\"ControlWord   = %08x StatusWord   = %08x\\n\", (ut32)ctx->FloatSave.ControlWord, (ut32)ctx->FloatSave.StatusWord);",
          "370:  eprintf (\"MxCsr         = %08x TagWord      = %08x\\n\", *(ut32 *)&ctx->ExtendedRegisters[24], (ut32)ctx->FloatSave.TagWord);",
          "371:  eprintf (\"ErrorOffset   = %08x DataOffset   = %08x\\n\", (ut32)ctx->FloatSave.ErrorOffset, (ut32)ctx->FloatSave.DataOffset);",
          "372:  eprintf (\"ErrorSelector = %08x DataSelector = %08x\\n\", (ut32)ctx->FloatSave.ErrorSelector, (ut32)ctx->FloatSave.DataSelector);",
          "373:  for (x = 0; x < 8; x++) {",
          "374:   st[x].High = (ut16) *((ut16 *)(&ctx->FloatSave.RegisterArea[x * 10] + 8));",
          "375:   st[x].Low = (ut64) *((ut64 *)&ctx->FloatSave.RegisterArea[x * 10]);",
          "376:  }",
          "377:  top = (ctx->FloatSave.StatusWord & 0x3fff) >> 11;",
          "378:  for (x = 0; x < 8; x++) {",
          "379:   mm[top] = *((ut64 *)&ctx->FloatSave.RegisterArea[x * 10]);",
          "380:   top++;",
          "381:   if (top>7) {",
          "382:    top = 0;",
          "383:   }",
          "384:  }",
          "385:  for (x = 0; x < 8; x++) {",
          "386:   xmm[x] = *((ut128 *)&ctx->ExtendedRegisters[(10 + x) * 16]);",
          "387:  }",
          "388:  nxmm = 8;",
          "389: #endif",
          "391:  for (x = 0; x < 8; x++) {",
          "397:   eprintf (\"ST%i %04x %016\"PFMT64x\" (%f)\\n\", x, st[x].High, st[x].Low, (double)(*((long double *)&st[x])));",
          "398:  }",
          "399:  for (x = 0; x < 8; x++) {",
          "400:   eprintf (\"MM%i %016\"PFMT64x\"\\n\", x, mm[x]);",
          "401:  }",
          "402:  for (x = 0; x < nxmm; x++) {",
          "403:   eprintf (\"XMM%i %016\"PFMT64x\" %016\"PFMT64x\"\\n\", x, xmm[x].High, xmm[x].Low);",
          "404:  }",
          "406:  nymm = __get_avx (th, xmm, ymm);",
          "407:  if (nymm) {",
          "408:   for (x = 0; x < nymm; x++) {",
          "409:    eprintf (\"Ymm%d: %016\"PFMT64x\" %016\"PFMT64x\" %016\"PFMT64x\" %016\"PFMT64x\"\\n\", x, ymm[x].High, ymm[x].Low, xmm[x].High, xmm[x].Low );",
          "410:   }",
          "411:  }",
          "412: }",
          "414: int w32_reg_read(RDebug *dbg, int type, ut8 *buf, int size) {",
          "415:  bool showfpu = false;",
          "416:  if (type < -1) {",
          "417:   showfpu = true; // hack for debugging",
          "418:   type = -type;",
          "419:  }",
          "420:  RIOW32Dbg *rio = dbg->user;",
          "422:  bool alive = __is_thread_alive (dbg, dbg->tid);",
          "423:  HANDLE th = rio->pi.hThread;",
          "424:  if (!th || th == INVALID_HANDLE_VALUE) {",
          "425:   if (alive) {",
          "426:    DWORD flags = THREAD_SUSPEND_RESUME | THREAD_GET_CONTEXT;",
          "427:    if (dbg->bits == R_SYS_BITS_64) {",
          "428:      flags |= THREAD_QUERY_INFORMATION;",
          "429:    }",
          "430:    th = w32_OpenThread (flags, FALSE, dbg->tid);",
          "431:    if (!th) {",
          "432:     r_sys_perror (\"w32_reg_read/OpenThread\");",
          "433:     return 0;",
          "434:    }",
          "435:   } else {",
          "436:    return 0;",
          "437:   }",
          "438:  }",
          "440:  if (alive && __suspend_thread (th, dbg->bits) == -1) {",
          "441:   CloseHandle (th);",
          "442:   return 0;",
          "443:  }",
          "444:  size = __get_thread_context (th, buf, size, dbg->bits);",
          "445:  if (showfpu) {",
          "446:   __printwincontext (th, (CONTEXT *)buf);",
          "447:  }",
          "449:  if (alive && __resume_thread (th, dbg->bits) == -1) {",
          "450:   size = 0;",
          "451:  }",
          "452:  if (th != rio->pi.hThread) {",
          "453:   CloseHandle (th);",
          "454:  }",
          "455:  return size;",
          "456: }",
          "458: int w32_reg_write(RDebug *dbg, int type, const ut8 *buf, int size) {",
          "459:  DWORD flags = THREAD_SUSPEND_RESUME | THREAD_SET_CONTEXT;",
          "460:  if (dbg->bits == R_SYS_BITS_64) {",
          "461:   flags |= THREAD_QUERY_INFORMATION;",
          "462:  }",
          "463:  HANDLE th = w32_OpenThread (flags, FALSE, dbg->tid);",
          "464:  if (!th) {",
          "465:   r_sys_perror (\"w32_reg_write/OpenThread\");",
          "466:   return false;",
          "467:  }",
          "468:  bool alive = __is_thread_alive (dbg, dbg->tid);",
          "470:  if (alive && __suspend_thread (th, dbg->bits) == -1) {",
          "471:   CloseHandle (th);",
          "472:   return false;",
          "473:  }",
          "474:  bool ret = __set_thread_context (th, buf, size, dbg->bits);",
          "476:  if (alive && __resume_thread (th, dbg->bits) == -1) {",
          "477:   ret = false;",
          "478:  }",
          "479:  CloseHandle (th);",
          "480:  return ret;",
          "481: }",
          "483: int w32_attach(RDebug *dbg, int pid) {",
          "484:  RIOW32Dbg *rio = dbg->user;",
          "485:  if (rio->pi.hProcess) {",
          "486:   return rio->pi.dwThreadId;",
          "487:  }",
          "488:  HANDLE ph = w32_OpenProcess (w32_PROCESS_ALL_ACCESS, FALSE, pid);",
          "489:  if (!ph) {",
          "490:   return -1;",
          "491:  }",
          "492:  if (!DebugActiveProcess (pid)) {",
          "493:   CloseHandle (ph);",
          "494:   return -1;",
          "495:  }",
          "496:  RList *threads = r_list_new ();",
          "497:  if (!threads) {",
          "498:   CloseHandle (ph);",
          "499:   return -1;",
          "500:  }",
          "501:  threads = w32_thread_list (dbg, pid, threads);",
          "502:  if (threads->length == 0) {",
          "503:   r_list_free (threads);",
          "504:   CloseHandle (ph);",
          "505:   return -1;",
          "506:  }",
          "507:  int tid = ((RDebugPid *)threads->head->data)->pid;",
          "508:  r_list_free (threads);",
          "509:  rio->pi.hProcess = ph;",
          "511:  return tid;",
          "512: }",
          "514: int w32_detach(RDebug *dbg, int pid) {",
          "515:  if (pid == -1 || dbg->pid != pid) {",
          "516:   return false;",
          "517:  }",
          "518:  RIOW32Dbg *rio = dbg->user;",
          "519:  bool ret = false;",
          "520:  if (rio->pi.hProcess) {",
          "521:   ret = w32_DebugActiveProcessStop (pid);",
          "522:  }",
          "523:  if (rio->pi.hProcess) {",
          "524:   CloseHandle (rio->pi.hProcess);",
          "525:   rio->pi.hProcess = NULL;",
          "526:  }",
          "527:  return ret;",
          "528: }",
          "530: static char *__get_file_name_from_handle(HANDLE handle_file) {",
          "531:  HANDLE handle_file_map = NULL;",
          "532:  LPTSTR filename = NULL;",
          "533:  DWORD file_size_high = 0;",
          "534:  LPVOID map = NULL;",
          "535:  DWORD file_size_low = GetFileSize (handle_file, &file_size_high);",
          "537:  if (file_size_low == 0 && file_size_high == 0) {",
          "538:   return NULL;",
          "539:  }",
          "540:  handle_file_map = CreateFileMapping (handle_file, NULL, PAGE_READONLY, 0, 1, NULL);",
          "541:  if (!handle_file_map) {",
          "542:   goto err_get_file_name_from_handle;",
          "543:  }",
          "544:  filename = malloc ((MAX_PATH + 1) * sizeof (TCHAR));",
          "545:  if (!filename) {",
          "546:   goto err_get_file_name_from_handle;",
          "547:  }",
          "549:  map = MapViewOfFile (handle_file_map, FILE_MAP_READ, 0, 0, 1);",
          "550:  if (!map || !GetMappedFileName (GetCurrentProcess (), map, filename, MAX_PATH)) {",
          "551:   goto err_get_file_name_from_handle;",
          "552:  }",
          "553:  TCHAR temp_buffer[512];",
          "555:  if (!GetLogicalDriveStrings (_countof (temp_buffer) - 1, temp_buffer)) {",
          "556:   goto err_get_file_name_from_handle;",
          "557:  }",
          "558:  TCHAR name[MAX_PATH];",
          "559:  TCHAR drive[3] = TEXT (\" :\");",
          "560:  LPTSTR cur_drive = temp_buffer;",
          "561:  while (*cur_drive) {",
          "564:   if (QueryDosDevice (drive, name, MAX_PATH)) {",
          "565:    size_t name_length = _tcslen (name);",
          "567:    if (name_length < MAX_PATH) {",
          "568:     if (_tcsnicmp (filename, name, name_length) == 0",
          "569:      && *(filename + name_length) == TEXT ('\\\\')) {",
          "570:      TCHAR temp_filename[MAX_PATH];",
          "571:      _sntprintf_s (temp_filename, MAX_PATH, _TRUNCATE, TEXT (\"%s%s\"),",
          "572:       drive, filename + name_length);",
          "573:      _tcsncpy (filename, temp_filename,",
          "574:       _tcslen (temp_filename) + 1);",
          "575:      filename[MAX_PATH] = (TCHAR)'\\0';",
          "576:      break;",
          "577:     }",
          "578:    }",
          "579:   }",
          "580:   cur_drive++;",
          "581:  }",
          "582: err_get_file_name_from_handle:",
          "583:  if (map) {",
          "584:   UnmapViewOfFile (map);",
          "585:  }",
          "586:  if (handle_file_map) {",
          "587:   CloseHandle (handle_file_map);",
          "588:  }",
          "589:  if (filename) {",
          "590:   char *ret = r_sys_conv_win_to_utf8 (filename);",
          "591:   free (filename);",
          "592:   return ret;",
          "593:  }",
          "594:  return NULL;",
          "595: }",
          "597: static char *__resolve_path(HANDLE ph, HANDLE mh) {",
          "599:  const DWORD maxlength = MAX_PATH;",
          "600:  TCHAR filename[MAX_PATH];",
          "601:  DWORD length = GetModuleFileNameEx (ph, mh, filename, maxlength);",
          "602:  if (length > 0) {",
          "603:   return r_sys_conv_win_to_utf8 (filename);",
          "604:  }",
          "605:  char *name = __get_file_name_from_handle (mh);",
          "606:  if (name) {",
          "607:   return name;",
          "608:  }",
          "610:  length = GetProcessImageFileName (mh, filename, maxlength);",
          "611:  if (length == 0) {",
          "612:   return NULL;",
          "613:  }",
          "615:  TCHAR *tmp = _tcschr (filename + 1, '\\\\');",
          "616:  if (!tmp) {",
          "617:   return NULL;",
          "618:  }",
          "619:  tmp = _tcschr (tmp + 1, '\\\\');",
          "620:  if (!tmp) {",
          "621:   return NULL;",
          "622:  }",
          "623:  length = tmp - filename;",
          "624:  TCHAR device[MAX_PATH];",
          "625:  char *ret = NULL;",
          "626:  for (TCHAR drv[] = TEXT(\"A:\"); drv[0] <= TEXT ('Z'); drv[0]++) {",
          "627:   if (QueryDosDevice (drv, device, maxlength) > 0) {",
          "628:    if (!_tcsncmp (filename, device, length)) {",
          "629:     TCHAR path[MAX_PATH];",
          "630:     _sntprintf (path, maxlength, TEXT (\"%s%s\"), drv, tmp);",
          "631:     ret = r_sys_conv_win_to_utf8 (path);",
          "632:     break;",
          "633:    }",
          "634:   }",
          "635:  }",
          "636:  return ret;",
          "637: }",
          "639: LPVOID lstLib = 0;",
          "640: PLIB_ITEM lstLibPtr = 0;",
          "641: static void *__r_debug_findlib(void *BaseOfDll) {",
          "642:  PLIB_ITEM libPtr = NULL;",
          "643:  if (lstLib) {",
          "644:   libPtr = (PLIB_ITEM)lstLib;",
          "645:   while (libPtr->hFile != NULL) {",
          "646:    if (libPtr->hFile != INVALID_HANDLE_VALUE)",
          "647:     if (libPtr->BaseOfDll == BaseOfDll)",
          "648:      return ((void*)libPtr);",
          "649:    libPtr = (PLIB_ITEM)((ULONG_PTR)libPtr + sizeof (LIB_ITEM));",
          "650:   }",
          "651:  }",
          "652:  return NULL;",
          "653: }",
          "655: #define PLIB_MAX 512",
          "657: static void __r_debug_lstLibAdd(DWORD pid, LPVOID lpBaseOfDll, HANDLE hFile, char *dllname) {",
          "658:  if (lstLib == 0) {",
          "659:   lstLib = VirtualAlloc (0, PLIB_MAX * sizeof (LIB_ITEM), MEM_COMMIT, PAGE_READWRITE);",
          "660:  }",
          "661:  lstLibPtr = (PLIB_ITEM)lstLib;",
          "662:  if (!lstLibPtr) {",
          "663:   R_LOG_ERROR (\"Failed to allocate memory\");",
          "664:   return;",
          "665:  }",
          "666:  for (int x = 0; x < PLIB_MAX; x++) {",
          "667:   if (lstLibPtr->hFile == hFile) {",
          "668:    return;",
          "669:   }",
          "670:   if (!lstLibPtr->hFile) {",
          "671:    lstLibPtr->pid = pid;",
          "672:    lstLibPtr->hFile = hFile; //DBGEvent->u.LoadDll.hFile;",
          "673:    lstLibPtr->BaseOfDll = lpBaseOfDll;//DBGEvent->u.LoadDll.lpBaseOfDll;",
          "674:    strncpy (lstLibPtr->Path, dllname, MAX_PATH - 1);",
          "675:    int i = strlen (dllname);",
          "676:    int n = i;",
          "677:    while (dllname[i] != '\\\\' && i >= 0) {",
          "678:     i--;",
          "679:    }",
          "680:    strncpy (lstLibPtr->Name, dllname + i + 1, (size_t)n - i);",
          "681:    return;",
          "682:   }",
          "683:   lstLibPtr++;",
          "684:  }",
          "685:  eprintf (\"__r_debug_lstLibAdd: Cannot find slot\\n\");",
          "686: }",
          "688: static bool breaked = false;",
          "690: int w32_select(RDebug* dbg, int pid, int tid) {",
          "691:  RIOW32Dbg *rio = dbg->user;",
          "692:  if (!dbg->threads) {",
          "693:   dbg->threads = r_list_newf (free);",
          "694:  }",
          "696:  RListIter *it = r_list_find (dbg->threads, &tid, (RListComparator)__w32_findthread_cmp);",
          "697:  PTHREAD_ITEM th = it ? it->data : NULL;",
          "699:  if (tid && dbg->threads && !th) {",
          "700:   th = __r_debug_thread_add (dbg, pid, tid, w32_OpenThread (w32_THREAD_ALL_ACCESS, FALSE, tid), 0, 0, FALSE);",
          "701:  }",
          "703:  int selected = 0;",
          "704:  if (th && __is_thread_alive (dbg, th->tid)) {",
          "705:   rio->pi.hThread = th->hThread;",
          "706:   __continue_thread (th->hThread, dbg->bits);",
          "707:   th->bSuspended = false;",
          "708:   selected = tid;",
          "709:  } else if (tid) {",
          "711:   r_list_foreach (dbg->threads, it, th) {",
          "712:    if (th->bFinished) {",
          "713:     continue;",
          "714:    }",
          "715:    __continue_thread (th->hThread, dbg->bits);",
          "716:    rio->pi.hThread = th->hThread;",
          "717:    th->bSuspended = false;",
          "718:    selected = th->tid;",
          "719:    break;",
          "720:   }",
          "721:  }",
          "724:  r_list_foreach (dbg->threads, it, th) {",
          "725:   if (!th->bFinished && !th->bSuspended && th->tid != selected) {",
          "726:    __suspend_thread (th->hThread, dbg->bits);",
          "727:    th->bSuspended = true;",
          "728:   }",
          "729:  }",
          "731:  return selected;",
          "732: }",
          "734: int w32_kill(RDebug *dbg, int pid, int tid, int sig) {",
          "735:  RIOW32Dbg *rio = dbg->user;",
          "737:  if (sig == 0) {",
          "738:   if (!__is_proc_alive (rio->pi.hProcess)) {",
          "739:    r_list_purge (dbg->threads);",
          "740:    return false;",
          "741:   }",
          "742:   return true;",
          "743:  }",
          "745:  DebugActiveProcessStop (pid);",
          "747:  bool ret = false;",
          "748:  if (TerminateProcess (rio->pi.hProcess, 1)) {",
          "749:   if (WaitForSingleObject (rio->pi.hProcess, wait_time) != WAIT_OBJECT_0) {",
          "750:    r_sys_perror (\"w32_kill/WaitForSingleObject\");",
          "751:   } else {",
          "752:    ret = true;",
          "753:   }",
          "754:  }",
          "755:  r_list_purge (dbg->threads);",
          "756:  CloseHandle (rio->pi.hProcess);",
          "757:  rio->pi.hProcess = NULL;",
          "758:  return ret;",
          "759: }",
          "761: void w32_break_process_wrapper(void *d) {",
          "762:  w32_break_process (d);",
          "763: }",
          "765: void w32_break_process(RDebug *dbg) {",
          "766:  RIOW32Dbg *rio = dbg->user;",
          "767:  w32_select (dbg, rio->pi.dwProcessId, 0); // Suspend all threads",
          "768:  breaked = true;",
          "769: #if 0",
          "770:  if (!w32_DebugBreakProcess (rio->pi.hProcess)) {",
          "771:   r_sys_perror (\"w32_break_process/DebugBreakProcess\");",
          "772:  }",
          "773: #endif",
          "774: }",
          "776: static const char *__get_w32_excep_name(DWORD code) {",
          "777:  switch (code) {",
          "779:  case EXCEPTION_ACCESS_VIOLATION:",
          "780:   return \"access violation\";",
          "781:  case EXCEPTION_ARRAY_BOUNDS_EXCEEDED:",
          "782:   return \"array bounds exceeded\";",
          "783:  case EXCEPTION_ILLEGAL_INSTRUCTION:",
          "784:   return \"illegal instruction\";",
          "785:  case EXCEPTION_INT_DIVIDE_BY_ZERO:",
          "786:   return \"divide by zero\";",
          "787:  case EXCEPTION_STACK_OVERFLOW:",
          "788:   return \"stack overflow\";",
          "789:  default:",
          "790:   return \"unknown\";",
          "791:  }",
          "792: }",
          "794: static int __debug_exception_event(DEBUG_EVENT *de) {",
          "795:  unsigned long code = de->u.Exception.ExceptionRecord.ExceptionCode;",
          "796:  switch (code) {",
          "798:  case EXCEPTION_ACCESS_VIOLATION:",
          "799:  case EXCEPTION_ARRAY_BOUNDS_EXCEEDED:",
          "800:  case EXCEPTION_ILLEGAL_INSTRUCTION:",
          "801:  case EXCEPTION_INT_DIVIDE_BY_ZERO:",
          "802:  case EXCEPTION_STACK_OVERFLOW:",
          "803:   eprintf (\"(%d) Fatal exception (%s) in thread %d\\n\",",
          "804:    (int)de->dwProcessId,",
          "805:    __get_w32_excep_name(code),",
          "806:    (int)de->dwThreadId);",
          "807:   break;",
          "809:  case 0x406D1388:",
          "810:   eprintf (\"(%d) MS_VC_EXCEPTION (%x) in thread %d\\n\",",
          "811:    (int)de->dwProcessId, (int)code, (int)de->dwThreadId);",
          "812:   return 1;",
          "813:  default:",
          "814:   eprintf (\"(%d) Unknown exception %x in thread %d\\n\",",
          "815:    (int)de->dwProcessId, (int)code, (int)de->dwThreadId);",
          "816:   break;",
          "817:  }",
          "818:  return 0;",
          "819: }",
          "821: #if 0",
          "822: static char *__r_debug_get_dll() {",
          "823:  return lstLibPtr->Path;",
          "824: }",
          "825: #endif",
          "827: static PLIB_ITEM __r_debug_get_lib_item() {",
          "828:  return lstLibPtr;",
          "829: }",
          "831: int w32_dbg_wait(RDebug *dbg, int pid) {",
          "832:  RIOW32Dbg* rio = dbg->user;",
          "833:  DEBUG_EVENT de;",
          "834:  int tid, next_event = 0;",
          "835:  char *dllname = NULL;",
          "836:  int ret = R_DEBUG_REASON_UNKNOWN;",
          "837:  static int exited_already = 0;",
          "839:  do {",
          "841:   if (exited_already == pid) {",
          "842:    return R_DEBUG_REASON_DEAD;",
          "843:   }",
          "844:   memset (&de, 0, sizeof (DEBUG_EVENT));",
          "846:   do {",
          "847:    if (!WaitForDebugEvent (&de, wait_time)) {",
          "848:     if (GetLastError () != ERROR_SEM_TIMEOUT) {",
          "849:      r_sys_perror (\"w32_dbg_wait/WaitForDebugEvent\");",
          "850:      return -1;",
          "851:     }",
          "852:     if (!__is_thread_alive (dbg, dbg->tid)) {",
          "853:      if (!w32_select (dbg, dbg->pid, dbg->tid)) {",
          "854:       return R_DEBUG_REASON_DEAD;",
          "855:      }",
          "856:     }",
          "857:    } else {",
          "858:     break;",
          "859:    }",
          "860:   } while (!breaked);",
          "862:   if (breaked) {",
          "863:    return R_DEBUG_REASON_NONE;",
          "864:   }",
          "866:   tid = de.dwThreadId;",
          "867:   pid = de.dwProcessId;",
          "868:   dbg->tid = rio->pi.dwThreadId = tid;",
          "869:   dbg->pid = rio->pi.dwProcessId = pid;",
          "872:   switch (de.dwDebugEventCode) {",
          "873:   case CREATE_PROCESS_DEBUG_EVENT:",
          "874:    next_event = 0;",
          "875:    __r_debug_thread_add (dbg, pid, tid, de.u.CreateProcessInfo.hThread, de.u.CreateProcessInfo.lpThreadLocalBase, de.u.CreateProcessInfo.lpStartAddress, FALSE);",
          "876:    rio->pi.hProcess = de.u.CreateProcessInfo.hProcess;",
          "877:    rio->pi.hThread = de.u.CreateProcessInfo.hThread;",
          "878:    rio->pi.dwProcessId = pid;",
          "879:    ret = R_DEBUG_REASON_NEW_PID;",
          "880:    break;",
          "881:   case CREATE_THREAD_DEBUG_EVENT:",
          "882:    __r_debug_thread_add (dbg, pid, tid, de.u.CreateThread.hThread, de.u.CreateThread.lpThreadLocalBase, de.u.CreateThread.lpStartAddress, FALSE);",
          "883:    ret = R_DEBUG_REASON_NEW_TID;",
          "884:    next_event = 0;",
          "885:    break;",
          "886:   case EXIT_PROCESS_DEBUG_EVENT:",
          "887:   case EXIT_THREAD_DEBUG_EVENT:",
          "888:   {",
          "889:    RListIter *it = r_list_find (dbg->threads, &tid, (RListComparator)__w32_findthread_cmp);",
          "890:    if (it) {",
          "891:     PTHREAD_ITEM th = it->data;",
          "892:     th->bFinished = TRUE;",
          "893:     th->hThread = INVALID_HANDLE_VALUE;",
          "894:     th->dwExitCode = de.u.ExitThread.dwExitCode;",
          "895:    } else {",
          "896:     __r_debug_thread_add (dbg, pid, tid, INVALID_HANDLE_VALUE, de.u.CreateThread.lpThreadLocalBase, de.u.CreateThread.lpStartAddress, TRUE);",
          "897:    }",
          "898:    next_event = 0;",
          "899:    if (de.dwDebugEventCode == EXIT_PROCESS_DEBUG_EVENT) {",
          "900:     exited_already = pid;",
          "901:     ContinueDebugEvent (pid, tid, DBG_CONTINUE);",
          "902:     ret = pid == dbg->main_pid ? R_DEBUG_REASON_DEAD : R_DEBUG_REASON_EXIT_PID;",
          "903:    } else {",
          "904:     ret = R_DEBUG_REASON_EXIT_TID;",
          "905:    }",
          "906:    break;",
          "907:   }",
          "908:   case LOAD_DLL_DEBUG_EVENT:",
          "909:    dllname = __resolve_path (((RIOW32Dbg *)dbg->user)->pi.hProcess, de.u.LoadDll.hFile); //__get_file_name_from_handle",
          "910:    if (dllname) {",
          "911:     __r_debug_lstLibAdd (pid,de.u.LoadDll.lpBaseOfDll, de.u.LoadDll.hFile, dllname);",
          "912:     free (dllname);",
          "913:    }",
          "914:    next_event = 0;",
          "915:    ret = R_DEBUG_REASON_NEW_LIB;",
          "916:    break;",
          "917:   case UNLOAD_DLL_DEBUG_EVENT:",
          "918:    lstLibPtr = (PLIB_ITEM)__r_debug_findlib (de.u.UnloadDll.lpBaseOfDll);",
          "919:    if (lstLibPtr != NULL) {",
          "920:     lstLibPtr->hFile = INVALID_HANDLE_VALUE;",
          "921:    } else {",
          "922:     __r_debug_lstLibAdd (pid, de.u.UnloadDll.lpBaseOfDll, INVALID_HANDLE_VALUE, \"not cached\");",
          "923:     if (dllname)",
          "924:      free (dllname);",
          "925:    }",
          "926:    next_event = 0;",
          "927:    ret = R_DEBUG_REASON_EXIT_LIB;",
          "928:    break;",
          "929:   case OUTPUT_DEBUG_STRING_EVENT:",
          "930:   {",
          "931:    char *str = calloc (de.u.DebugString.nDebugStringLength, sizeof (TCHAR));",
          "932:    ReadProcessMemory (rio->pi.hProcess, de.u.DebugString.lpDebugStringData, str, de.u.DebugString.nDebugStringLength, NULL);",
          "933:    char *tmp = de.u.DebugString.fUnicode",
          "934:      ? r_utf16_to_utf8 ((wchar_t *)str)",
          "935:      : r_acp_to_utf8 (str);",
          "936:    if (tmp) {",
          "937:      free (str);",
          "938:      str = tmp;",
          "939:    }",
          "940:    eprintf (\"(%d) Debug string: %s\\n\", pid, str);",
          "941:    free (str);",
          "942:    w32_continue (dbg, pid, tid, DBG_EXCEPTION_NOT_HANDLED);",
          "943:    next_event = 1;",
          "944:    break;",
          "945:   }",
          "946:   case RIP_EVENT:",
          "947:    eprintf (\"(%d) RIP event\\n\", pid);",
          "948:    w32_continue (dbg, pid, tid, -1);",
          "949:    next_event = 1;",
          "951:    break;",
          "952:   case EXCEPTION_DEBUG_EVENT:",
          "953:    switch (de.u.Exception.ExceptionRecord.ExceptionCode) {",
          "954:    case DBG_CONTROL_C:",
          "955:     eprintf (\"Received CTRL+C event, continuing\\n\");",
          "956:     w32_continue (dbg, pid, tid, DBG_EXCEPTION_NOT_HANDLED);",
          "957:     next_event = 1;",
          "958:     break;",
          "959: #if _WIN64",
          "961: #endif",
          "962:    case EXCEPTION_BREAKPOINT:",
          "963:     ret = R_DEBUG_REASON_BREAKPOINT;",
          "964:     next_event = 0;",
          "965:     break;",
          "966: #if _WIN64",
          "968: #endif",
          "969:    case EXCEPTION_SINGLE_STEP:",
          "970:     ret = R_DEBUG_REASON_STEP;",
          "971:     next_event = 0;",
          "972:     break;",
          "973:    default:",
          "974:     if (!__debug_exception_event (&de)) {",
          "975:      ret = R_DEBUG_REASON_TRAP;",
          "976:      next_event = 0;",
          "977:     } else {",
          "978:      next_event = 1;",
          "979:      w32_continue (dbg, pid, tid, -1);",
          "980:     }",
          "981:    }",
          "982:    dbg->reason.signum = de.u.Exception.ExceptionRecord.ExceptionCode;",
          "983:    break;",
          "984:   default:",
          "985:    eprintf (\"(%d) unknown event: %d\\n\", pid, de.dwDebugEventCode);",
          "986:    return -1;",
          "987:   }",
          "988:  } while (next_event);",
          "990:  RListIter *it = r_list_find (dbg->threads, &tid, (RListComparator)__w32_findthread_cmp);",
          "991:  if (it) {",
          "992:   PTHREAD_ITEM th = it->data;",
          "993:   rio->pi.hThread = th->hThread;",
          "994:  } else {",
          "995:   __r_debug_thread_add (dbg, pid, tid, w32_OpenThread (w32_THREAD_ALL_ACCESS, FALSE, tid), 0, 0, __is_thread_alive (dbg, tid));",
          "996:  }",
          "998:  return ret;",
          "999: }",
          "1001: int w32_step(RDebug *dbg) {",
          "1003:  CONTEXT ctx;",
          "1004:  if (!w32_reg_read (dbg, R_REG_TYPE_GPR, (ut8 *)&ctx, sizeof (ctx))) {",
          "1005:   return false;",
          "1006:  }",
          "1007:  ctx.EFlags |= 0x100;",
          "1008:  if (!w32_reg_write (dbg, R_REG_TYPE_GPR, (ut8 *)&ctx, sizeof (ctx))) {",
          "1009:   return false;",
          "1010:  }",
          "1011:  return w32_continue (dbg, dbg->pid, dbg->tid, dbg->reason.signum);",
          "1013: }",
          "1015: int w32_continue(RDebug *dbg, int pid, int tid, int sig) {",
          "1017:  RIOW32Dbg *rio = dbg->user;",
          "1018:  DWORD continue_status = (sig == DBG_EXCEPTION_NOT_HANDLED)",
          "1019:   ? DBG_EXCEPTION_NOT_HANDLED : DBG_EXCEPTION_HANDLED;",
          "1020:  dbg->tid = w32_select (dbg, pid, tid);",
          "1021:  if (breaked) {",
          "1022:   breaked = false;",
          "1023:   return tid;",
          "1024:  }",
          "1025:  if (!ContinueDebugEvent (rio->pi.dwProcessId, rio->pi.dwThreadId, continue_status)) {",
          "1026:   r_sys_perror (\"w32_continue/ContinueDebugEvent\");",
          "1027:   return false;",
          "1028:  }",
          "1029:  return tid;",
          "1030: }",
          "1032: RDebugMap *w32_map_alloc(RDebug *dbg, ut64 addr, int size) {",
          "1033:  RIOW32Dbg *rio = dbg->user;",
          "1034:  LPVOID base = VirtualAllocEx (rio->pi.hProcess, (LPVOID)addr, (SIZE_T)size, MEM_COMMIT, PAGE_READWRITE);",
          "1035:  if (!base) {",
          "1036:   r_sys_perror (\"w32_map_alloc/VirtualAllocEx\");",
          "1037:   return NULL;",
          "1038:  }",
          "1039:  r_debug_map_sync (dbg);",
          "1040:  return r_debug_map_get (dbg, (ut64)base);",
          "1041: }",
          "1043: int w32_map_dealloc(RDebug *dbg, ut64 addr, int size) {",
          "1044:  RIOW32Dbg *rio = dbg->user;",
          "1045:  if (!VirtualFreeEx (rio->pi.hProcess, (LPVOID)addr, 0, MEM_RELEASE)) {",
          "1046:   r_sys_perror (\"w32_map_dealloc/VirtualFreeEx\");",
          "1047:   return false;",
          "1048:  }",
          "1049:  return true;",
          "1050: }",
          "1052: static int __io_perms_to_prot(int io_perms) {",
          "1053:  int prot_perms;",
          "1055:  if ((io_perms & R_PERM_RWX) == R_PERM_RWX) {",
          "1056:   prot_perms = PAGE_EXECUTE_READWRITE;",
          "1057:  } else if ((io_perms & (R_PERM_W | R_PERM_X)) == (R_PERM_W | R_PERM_X)) {",
          "1058:   prot_perms = PAGE_EXECUTE_READWRITE;",
          "1059:  } else if ((io_perms & (R_PERM_R | R_PERM_X)) == (R_PERM_R | R_PERM_X)) {",
          "1060:   prot_perms = PAGE_EXECUTE_READ;",
          "1061:  } else if ((io_perms & R_PERM_RW) == R_PERM_RW) {",
          "1062:   prot_perms = PAGE_READWRITE;",
          "1063:  } else if (io_perms & R_PERM_W) {",
          "1064:   prot_perms = PAGE_READWRITE;",
          "1065:  } else if (io_perms & R_PERM_X) {",
          "1066:   prot_perms = PAGE_EXECUTE;",
          "1067:  } else if (io_perms & R_PERM_R) {",
          "1068:   prot_perms = PAGE_READONLY;",
          "1069:  } else {",
          "1070:   prot_perms = PAGE_NOACCESS;",
          "1071:  }",
          "1072:  return prot_perms;",
          "1073: }",
          "1075: int w32_map_protect(RDebug *dbg, ut64 addr, int size, int perms) {",
          "1076:  DWORD old;",
          "1077:  RIOW32Dbg *rio = dbg->user;",
          "1078:  return VirtualProtectEx (rio->pi.hProcess, (LPVOID)(size_t)addr,",
          "1079:   size, __io_perms_to_prot (perms), &old);",
          "1080: }",
          "1082: RList *w32_thread_list(RDebug *dbg, int pid, RList *list) {",
          "1084:  HANDLE th = w32_CreateToolhelp32Snapshot (TH32CS_SNAPTHREAD, 0);",
          "1085:  if (th == INVALID_HANDLE_VALUE) {",
          "1086:   r_sys_perror (\"w32_thread_list/CreateToolhelp32Snapshot\");",
          "1087:   return list;",
          "1088:  }",
          "1089:  THREADENTRY32 te;",
          "1090:  te.dwSize = sizeof (te);",
          "1091:  HANDLE ph = w32_OpenProcess (PROCESS_QUERY_INFORMATION | PROCESS_VM_READ, FALSE, pid);",
          "1092:  if (Thread32First (th, &te)) {",
          "1094:   char *path = NULL;",
          "1095:   int uid = -1;",
          "1096:   if (!te.th32ThreadID) {",
          "1097:    path = __resolve_path (ph, NULL);",
          "1098:    DWORD sid;",
          "1099:    if (ProcessIdToSessionId (pid, &sid)) {",
          "1100:     uid = sid;",
          "1101:    }",
          "1102:   }",
          "1103:   if (!path) {",
          "1105:    path = \"???\";",
          "1106:   }",
          "1107:   do {",
          "1108:    if (te.th32OwnerProcessID == pid) {",
          "1109:     ut64 pc = 0;",
          "1110:     if (dbg->pid == pid) {",
          "1111:      CONTEXT ctx = {0};",
          "1112:      w32_reg_read (dbg, R_REG_TYPE_GPR, (ut8 *)&ctx, sizeof (ctx));",
          "1113:      pc = ctx.Rip;",
          "1114:     }",
          "1115:     r_list_append (list, r_debug_pid_new (path, te.th32ThreadID, uid, 's', pc));",
          "1116:    }",
          "1117:   } while (Thread32Next (th, &te));",
          "1118:   free (path);",
          "1119:  } else {",
          "1120:   r_sys_perror (\"w32_thread_list/Thread32First\");",
          "1121:  }",
          "1122:  CloseHandle (th);",
          "1123:  return list;",
          "1124: }",
          "1126: static void __w32_info_user(RDebug *dbg, RDebugInfo *rdi) {",
          "1127:  HANDLE h_tok = NULL;",
          "1128:  DWORD tok_len = 0;",
          "1129:  PTOKEN_USER tok_usr = NULL;",
          "1130:  LPTSTR usr = NULL, usr_dom = NULL;",
          "1131:  DWORD usr_len = 512;",
          "1132:  DWORD usr_dom_len = 512;",
          "1133:  SID_NAME_USE snu = {0};",
          "1134:  RIOW32Dbg *rio = dbg->user;",
          "1136:  if (!OpenProcessToken (rio->pi.hProcess, TOKEN_QUERY, &h_tok)) {",
          "1137:   r_sys_perror (\"__w32_info_user/OpenProcessToken\");",
          "1138:   goto err___w32_info_user;",
          "1139:  }",
          "1140:  if (!GetTokenInformation (h_tok, TokenUser, (LPVOID)&tok_usr, 0, &tok_len) && GetLastError () != ERROR_INSUFFICIENT_BUFFER) {",
          "1141:   r_sys_perror (\"__w32_info_user/GetTokenInformation\");",
          "1142:   goto err___w32_info_user;",
          "1143:  }",
          "1144:  tok_usr = (PTOKEN_USER)malloc (tok_len);",
          "1145:  if (!tok_usr) {",
          "1146:   perror (\"__w32_info_user/malloc tok_usr\");",
          "1147:   goto err___w32_info_user;",
          "1148:  }",
          "1149:  if (!GetTokenInformation (h_tok, TokenUser, (LPVOID)tok_usr, tok_len, &tok_len)) {",
          "1150:   r_sys_perror (\"__w32_info_user/GetTokenInformation\");",
          "1151:   goto err___w32_info_user;",
          "1152:  }",
          "1153:  usr = (LPTSTR)malloc (usr_len * sizeof (TCHAR));",
          "1154:  if (!usr) {",
          "1155:   perror (\"__w32_info_user/malloc usr\");",
          "1156:   goto err___w32_info_user;",
          "1157:  }",
          "1159:  usr_dom = (LPTSTR)malloc (usr_dom_len * sizeof (TCHAR));",
          "1160:  if (!usr_dom) {",
          "1161:   perror (\"__w32_info_user/malloc usr_dom\");",
          "1162:   goto err___w32_info_user;",
          "1163:  }",
          "1165:  if (!LookupAccountSid (NULL, tok_usr->User.Sid, usr, &usr_len, usr_dom, &usr_dom_len, &snu)) {",
          "1166:   r_sys_perror (\"__w32_info_user/LookupAccountSid\");",
          "1167:   goto err___w32_info_user;",
          "1168:  }",
          "1169:  if (*usr_dom) {",
          "1170:   rdi->usr = r_str_newf (W32_TCHAR_FSTR\"\\\\\"W32_TCHAR_FSTR, usr_dom, usr);",
          "1171:  } else {",
          "1172:   rdi->usr = r_sys_conv_win_to_utf8 (usr);",
          "1173:  }",
          "1174: err___w32_info_user:",
          "1175:  if (h_tok) {",
          "1176:   CloseHandle (h_tok);",
          "1177:  }",
          "1178:  free (usr);",
          "1179:  free (usr_dom);",
          "1180:  free (tok_usr);",
          "1181: }",
          "1183: static void __w32_info_exe(RDebug *dbg, RDebugInfo *rdi) {",
          "1184:  RIOW32Dbg *rio = dbg->user;",
          "1185:  rdi->exe = __resolve_path (rio->pi.hProcess, NULL);",
          "1186: }",
          "1188: RDebugInfo *w32_info(RDebug *dbg, const char *arg) {",
          "1189:  RDebugInfo *rdi = R_NEW0 (RDebugInfo);",
          "1190:  if (!rdi) {",
          "1191:   return NULL;",
          "1192:  }",
          "1193:  RListIter *th;",
          "1194:  rdi->status = R_DBG_PROC_SLEEP; // TODO: Fix this",
          "1195:  rdi->pid = dbg->pid;",
          "1196:  rdi->tid = dbg->tid;",
          "1197:  rdi->lib = (void *) __r_debug_get_lib_item ();",
          "1198:  rdi->thread = (th = r_list_find (dbg->threads, &dbg->tid, (RListComparator)__w32_findthread_cmp)) ? th->data : NULL;",
          "1199:  rdi->uid = -1;",
          "1200:  rdi->gid = -1;",
          "1201:  rdi->cwd = NULL;",
          "1202:  rdi->exe = NULL;",
          "1203:  rdi->cmdline = NULL;",
          "1204:  rdi->libname = NULL;",
          "1205:  __w32_info_user (dbg, rdi);",
          "1206:  __w32_info_exe (dbg, rdi);",
          "1207:  return rdi;",
          "1208: }",
          "1210: static RDebugPid *__build_debug_pid(int pid, HANDLE ph, const TCHAR* name) {",
          "1211:  char *path = NULL;",
          "1212:  int uid = -1;",
          "1213:  if (!ph) {",
          "1214:   ph = w32_OpenProcess (PROCESS_QUERY_INFORMATION | PROCESS_VM_READ, FALSE, pid);",
          "1215:   if (ph) {",
          "1216:    path = __resolve_path (ph, NULL);",
          "1217:    DWORD sid;",
          "1218:    if (ProcessIdToSessionId (pid, &sid)) {",
          "1219:     uid = sid;",
          "1220:    }",
          "1221:    CloseHandle (ph);",
          "1222:   } else {",
          "1223:    return NULL;",
          "1224:   }",
          "1225:  } else {",
          "1226:   path = __resolve_path (ph, NULL);",
          "1227:   DWORD sid;",
          "1228:   if (ProcessIdToSessionId (pid, &sid)) {",
          "1229:    uid = sid;",
          "1230:   }",
          "1231:  }",
          "1232:  if (!path) {",
          "1233:   path = r_sys_conv_win_to_utf8 (name);",
          "1234:  }",
          "1236:  RDebugPid *ret = r_debug_pid_new (path, pid, uid, 's', 0);",
          "1237:  free (path);",
          "1238:  return ret;",
          "1239: }",
          "1241: RList *w32_pid_list(RDebug *dbg, int pid, RList *list) {",
          "1242:  HANDLE sh = w32_CreateToolhelp32Snapshot (TH32CS_SNAPPROCESS, pid);",
          "1243:  if (sh == INVALID_HANDLE_VALUE) {",
          "1244:   r_sys_perror (\"w32_pid_list/CreateToolhelp32Snapshot\");",
          "1245:   return list;",
          "1246:  }",
          "1247:  PROCESSENTRY32 pe;",
          "1248:  pe.dwSize = sizeof (pe);",
          "1249:  if (Process32First (sh, &pe)) {",
          "1250:   RIOW32Dbg *rio = dbg->user;",
          "1251:   bool all = pid == 0, b = false;",
          "1252:   do {",
          "1253:    if (all || pe.th32ProcessID == pid || (b = pe.th32ParentProcessID == pid)) {",
          "1255:     RDebugPid *dbg_pid = __build_debug_pid (pe.th32ProcessID, b ? rio->pi.hProcess : NULL, pe.szExeFile);",
          "1256:     if (dbg_pid) {",
          "1257:      r_list_append (list, dbg_pid);",
          "1258:     }",
          "1259: #if 0",
          "1260:     else {",
          "1261:      eprintf (\"w32_pid_list: failed to process pid %d\\n\", pe.th32ProcessID);",
          "1262:     }",
          "1263: #endif",
          "1264:    }",
          "1265:   } while (Process32Next (sh, &pe));",
          "1266:  } else {",
          "1267:   r_sys_perror (\"w32_pid_list/Process32First\");",
          "1268:  }",
          "1269:  CloseHandle (sh);",
          "1270:  return list;",
          "1271: }",
          "1273: RList *w32_desc_list(int pid) {",
          "1274:  RDebugDesc *desc;",
          "1275:  RList *ret = r_list_newf (free);",
          "1276:  int i;",
          "1277:  HANDLE ph;",
          "1278:  PSYSTEM_HANDLE_INFORMATION handleInfo;",
          "1279:  NTSTATUS status;",
          "1280:  ULONG handleInfoSize = 0x10000;",
          "1281:  LPVOID buff;",
          "1282:  if (!ret) {",
          "1283:   perror (\"win_desc_list/r_list_new\");",
          "1284:   return NULL;",
          "1285:  }",
          "1286:  if (!(ph = w32_OpenProcess (PROCESS_DUP_HANDLE, FALSE, pid))) {",
          "1287:   r_sys_perror (\"win_desc_list/OpenProcess\");",
          "1288:   r_list_free (ret);",
          "1289:   return NULL;",
          "1290:  }",
          "1291:  handleInfo = (PSYSTEM_HANDLE_INFORMATION)malloc (handleInfoSize);",
          "1292:  #define STATUS_INFO_LENGTH_MISMATCH 0xc0000004",
          "1293:  #define SystemHandleInformation 16",
          "1294:  while ((status = w32_NtQuerySystemInformation (SystemHandleInformation, handleInfo, handleInfoSize, NULL)) == STATUS_INFO_LENGTH_MISMATCH) {",
          "1295:   handleInfoSize *= 2;",
          "1296:   void *tmp = realloc (handleInfo, (size_t)handleInfoSize);",
          "1297:   if (tmp) {",
          "1298:    handleInfo = (PSYSTEM_HANDLE_INFORMATION)tmp;",
          "1299:   }",
          "1300:  }",
          "1301:  if (status) {",
          "1302:   r_sys_perror (\"win_desc_list/NtQuerySystemInformation\");",
          "1303:   CloseHandle (ph);",
          "1304:   r_list_free (ret);",
          "1305:   return NULL;",
          "1306:  }",
          "1307:  for (i = 0; i < handleInfo->HandleCount; i++) {",
          "1308:   SYSTEM_HANDLE handle = handleInfo->Handles[i];",
          "1309:   HANDLE dupHandle = NULL;",
          "1310:   POBJECT_TYPE_INFORMATION objectTypeInfo;",
          "1311:   PVOID objectNameInfo;",
          "1312:   UNICODE_STRING objectName;",
          "1313:   ULONG returnLength;",
          "1314:   if (handle.ProcessId != pid) {",
          "1315:    continue;",
          "1316:   }",
          "1317:   if (handle.ObjectTypeNumber != 0x1c) {",
          "1318:    continue;",
          "1319:   }",
          "1320:   if (w32_NtDuplicateObject (ph, &handle.Handle, GetCurrentProcess (), &dupHandle, 0, 0, 0)) {",
          "1321:    continue;",
          "1322:   }",
          "1323:   objectTypeInfo = (POBJECT_TYPE_INFORMATION)malloc (0x1000);",
          "1324:   if (w32_NtQueryObject (dupHandle, 2, objectTypeInfo, 0x1000, NULL)) {",
          "1325:    CloseHandle (dupHandle);",
          "1326:    continue;",
          "1327:   }",
          "1328:   objectNameInfo = malloc (0x1000);",
          "1329:   if (!objectNameInfo) {",
          "1330:    break;",
          "1331:   }",
          "1332:   if (w32_NtQueryObject (dupHandle, 1, objectNameInfo, 0x1000, &returnLength)) {",
          "1333:    void *tmp = realloc (objectNameInfo, returnLength);",
          "1334:    if (tmp) {",
          "1335:     objectNameInfo = tmp;",
          "1336:    }",
          "1337:    if (w32_NtQueryObject (dupHandle, 1, objectNameInfo, returnLength, NULL)) {",
          "1338:     free (objectTypeInfo);",
          "1339:     free (objectNameInfo);",
          "1340:     CloseHandle (dupHandle);",
          "1341:     continue;",
          "1342:    }",
          "1343:   }",
          "1344:   objectName = *(PUNICODE_STRING)objectNameInfo;",
          "1345:   if (objectName.Length) {",
          "1347:    buff = malloc ((size_t)(objectName.Length / 2) + 1);",
          "1348:    wcstombs (buff, objectName.Buffer, objectName.Length / 2);",
          "1349:    desc = r_debug_desc_new (handle.Handle, buff, 0, '?', 0);",
          "1350:    if (!desc) {",
          "1351:     free (buff);",
          "1352:     break;",
          "1353:    }",
          "1354:    r_list_append (ret, desc);",
          "1355:    free (buff);",
          "1356:   } else {",
          "1357:    buff = malloc ((size_t)(objectTypeInfo->Name.Length / 2) + 1);",
          "1358:    wcstombs (buff, objectTypeInfo->Name.Buffer, objectTypeInfo->Name.Length);",
          "1359:    desc = r_debug_desc_new (handle.Handle, buff, 0, '?', 0);",
          "1360:    if (!desc) {",
          "1361:     free (buff);",
          "1362:     break;",
          "1363:    }",
          "1364:    r_list_append (ret, desc);",
          "1365:    free (buff);",
          "1366:   }",
          "1367:   free (objectTypeInfo);",
          "1368:   free (objectNameInfo);",
          "1369:   CloseHandle (dupHandle);",
          "1370:  }",
          "1371:  free (handleInfo);",
          "1372:  CloseHandle (ph);",
          "1373:  return ret;",
          "1374: }",
          "",
          "---------------"
        ],
        "libr/debug/p/native/windows/windows_debug.h||libr/debug/p/native/windows/windows_debug.h": [
          "File: libr/debug/p/native/windows/windows_debug.h -> libr/debug/p/native/windows/windows_debug.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: #ifndef WINDOWS_DEBUG_H",
          "2: #define WINDOWS_DEBUG_H",
          "4:  |   |   |",
          "5:  |___|___|",
          "6:  |   |   |",
          "7:  |___|___|",
          "10: #include <r_types.h>",
          "11: #include <r_debug.h>",
          "12: #include <psapi.h>",
          "14: #include <windows.h>",
          "15: #include <tlhelp32.h> // CreateToolhelp32Snapshot",
          "16: #include <psapi.h> // GetModuleFileNameEx, GetProcessImageFileName",
          "17: #include <tchar.h>",
          "19: #ifndef XSTATE_GSSE",
          "20: #define XSTATE_GSSE 2",
          "21: #endif",
          "23: #ifndef XSTATE_LEGACY_SSE",
          "24: #define XSTATE_LEGACY_SSE 1",
          "25: #endif",
          "27: #if !defined(XSTATE_MASK_GSSE)",
          "28: #define XSTATE_MASK_GSSE (1LLU << (XSTATE_GSSE))",
          "29: #endif",
          "31: #undef CONTEXT_XSTATE",
          "32: #if defined(_M_X64)",
          "33: #define CONTEXT_XSTATE (0x00100040)",
          "34: #else",
          "35: #define CONTEXT_XSTATE (0x00010040)",
          "36: #endif",
          "37: #define XSTATE_AVX (XSTATE_GSSE)",
          "38: #define XSTATE_MASK_AVX (XSTATE_MASK_GSSE)",
          "39: #ifndef CONTEXT_ALL",
          "40: #define CONTEXT_ALL 1048607",
          "41: #endif",
          "43: typedef struct _SYSTEM_HANDLE {",
          "44:  ULONG ProcessId;",
          "45:  BYTE ObjectTypeNumber;",
          "46:  BYTE Flags;",
          "47:  USHORT Handle;",
          "48:  PVOID Object;",
          "49:  ACCESS_MASK GrantedAccess;",
          "50: } SYSTEM_HANDLE, *PSYSTEM_HANDLE;",
          "52: typedef struct _SYSTEM_HANDLE_INFORMATION {",
          "53:  ULONG HandleCount;",
          "54:  SYSTEM_HANDLE Handles[1];",
          "55: } SYSTEM_HANDLE_INFORMATION, *PSYSTEM_HANDLE_INFORMATION;",
          "57: typedef enum _POOL_TYPE {",
          "58:  NonPagedPool,",
          "59:  PagedPool,",
          "60:  NonPagedPoolMustSucceed,",
          "61:  DontUseThisType,",
          "62:  NonPagedPoolCacheAligned,",
          "63:  PagedPoolCacheAligned,",
          "64:  NonPagedPoolCacheAlignedMustS",
          "65: } POOL_TYPE,",
          "68: typedef struct _UNICODE_STRING {",
          "69:  USHORT Length;",
          "70:  USHORT MaximumLength;",
          "71:  PWSTR Buffer;",
          "72: } UNICODE_STRING, *PUNICODE_STRING;",
          "74: typedef struct _OBJECT_TYPE_INFORMATION {",
          "75:  UNICODE_STRING Name;",
          "76:  ULONG TotalNumberOfObjects;",
          "77:  ULONG TotalNumberOfHandles;",
          "78:  ULONG TotalPagedPoolUsage;",
          "79:  ULONG TotalNonPagedPoolUsage;",
          "80:  ULONG TotalNamePoolUsage;",
          "81:  ULONG TotalHandleTableUsage;",
          "82:  ULONG HighWaterNumberOfObjects;",
          "83:  ULONG HighWaterNumberOfHandles;",
          "84:  ULONG HighWaterPagedPoolUsage;",
          "85:  ULONG HighWaterNonPagedPoolUsage;",
          "86:  ULONG HighWaterNamePoolUsage;",
          "87:  ULONG HighWaterHandleTableUsage;",
          "88:  ULONG InvalidAttributes;",
          "89:  GENERIC_MAPPING GenericMapping;",
          "90:  ULONG ValidAccess;",
          "91:  BOOLEAN SecurityRequired;",
          "92:  BOOLEAN MaintainHandleCount;",
          "93:  USHORT MaintainTypeList;",
          "94:  POOL_TYPE PoolType;",
          "95:  ULONG PagedPoolUsage;",
          "96:  ULONG NonPagedPoolUsage;",
          "97: } OBJECT_TYPE_INFORMATION, *POBJECT_TYPE_INFORMATION;",
          "99: typedef struct {",
          "100:  ut64 winbase;",
          "101:  PROCESS_INFORMATION pi;",
          "102: } RIOW32Dbg;",
          "105: typedef struct {",
          "106:  int pid;",
          "107:  int tid;",
          "108:  bool bFinished;",
          "109:  bool bSuspended;",
          "110:  HANDLE hThread;",
          "111:  LPVOID lpThreadLocalBase;",
          "112:  LPVOID lpStartAddress;",
          "113:  PVOID lpThreadEntryPoint;",
          "114:  DWORD dwExitCode;",
          "115: } THREAD_ITEM, *PTHREAD_ITEM;",
          "117: typedef struct{",
          "118:  int pid;",
          "119:  HANDLE hFile;",
          "120:  void* BaseOfDll;",
          "121:  char Path[MAX_PATH];",
          "122:  char Name[MAX_PATH];",
          "123: } LIB_ITEM, *PLIB_ITEM;",
          "125: DWORD (WINAPI *w32_GetModuleBaseName)(HANDLE, HMODULE, LPTSTR, DWORD);",
          "126: BOOL (WINAPI *w32_GetModuleInformation)(HANDLE, HMODULE, LPMODULEINFO, DWORD);",
          "127: BOOL (WINAPI *w32_DebugActiveProcessStop)(DWORD);",
          "128: HANDLE (WINAPI *w32_OpenThread)(DWORD, BOOL, DWORD);",
          "129: BOOL (WINAPI *w32_DebugBreakProcess)(HANDLE);",
          "130: DWORD (WINAPI *w32_GetThreadId)(HANDLE); // Vista",
          "131: DWORD (WINAPI *w32_GetProcessId)(HANDLE); // XP",
          "132: HANDLE (WINAPI *w32_OpenProcess)(DWORD, BOOL, DWORD);",
          "133: BOOL (WINAPI *w32_QueryFullProcessImageName)(HANDLE, DWORD, LPTSTR, PDWORD);",
          "134: DWORD (WINAPI *w32_GetMappedFileName)(HANDLE, LPVOID, LPTSTR, DWORD);",
          "135: NTSTATUS (WINAPI *w32_NtQuerySystemInformation)(ULONG, PVOID, ULONG, PULONG);",
          "136: NTSTATUS (WINAPI *w32_NtQueryInformationThread)(HANDLE, ULONG, PVOID, ULONG, PULONG);",
          "137: NTSTATUS (WINAPI *w32_NtDuplicateObject)(HANDLE, HANDLE, HANDLE, PHANDLE, ACCESS_MASK, ULONG, ULONG);",
          "138: NTSTATUS (WINAPI *w32_NtQueryObject)(HANDLE, ULONG, PVOID, ULONG, PULONG);",
          "140: ut64 (WINAPI *w32_GetEnabledXStateFeatures)();",
          "141: BOOL (WINAPI *w32_InitializeContext)(PVOID, DWORD, PCONTEXT*, PDWORD);",
          "142: BOOL (WINAPI *w32_GetXStateFeaturesMask)(PCONTEXT Context, PDWORD64);",
          "143: PVOID (WINAPI *w32_LocateXStateFeature)(PCONTEXT Context, DWORD, PDWORD);",
          "144: BOOL (WINAPI *w32_SetXStateFeaturesMask)(PCONTEXT Context, DWORD64);",
          "145: DWORD (WINAPI *w32_GetModuleFileNameEx)(HANDLE, HMODULE, LPTSTR, DWORD);",
          "146: HANDLE (WINAPI *w32_CreateToolhelp32Snapshot)(DWORD, DWORD);",
          "149: int w32_init(RDebug *dbg);",
          "151: int w32_reg_read(RDebug *dbg, int type, ut8 *buf, int size);",
          "152: int w32_reg_write(RDebug *dbg, int type, const ut8 *buf, int size);",
          "154: int w32_attach(RDebug *dbg, int pid);",
          "155: int w32_detach(RDebug *dbg, int pid);",
          "156: int w32_select(RDebug *dbg, int pid, int tid);",
          "157: int w32_kill(RDebug *dbg, int pid, int tid, int sig);",
          "158: void w32_break_process(RDebug *dbg);",
          "159: int w32_dbg_wait(RDebug *dbg, int pid);",
          "161: int w32_step(RDebug *dbg);",
          "162: int w32_continue(RDebug *dbg, int pid, int tid, int sig);",
          "163: RDebugMap *w32_map_alloc(RDebug *dbg, ut64 addr, int size);",
          "164: int w32_map_dealloc(RDebug *dbg, ut64 addr, int size);",
          "165: int w32_map_protect(RDebug *dbg, ut64 addr, int size, int perms);",
          "167: RList *w32_thread_list(RDebug *dbg, int pid, RList *list);",
          "168: RDebugInfo *w32_info(RDebug *dbg, const char *arg);",
          "170: RList *w32_pid_list(RDebug *dbg, int pid, RList *list);",
          "172: RList *w32_desc_list(int pid);",
          "173: #endif",
          "",
          "---------------"
        ],
        "libr/include/r_debug.h||libr/include/r_debug.h": [
          "File: libr/include/r_debug.h -> libr/include/r_debug.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "368:  int (*startv)(int argc, char **argv);",
          "369:  int (*attach)(RDebug *dbg, int pid);",
          "370:  int (*detach)(RDebug *dbg, int pid);",
          "372:  RList *(*threads)(RDebug *dbg, int pid);",
          "373:  RList *(*pids)(RDebug *dbg, int pid);",
          "374:  RList *(*tids)(RDebug *dbg, int pid);",
          "",
          "[Removed Lines]",
          "371:  int (*select)(int pid, int tid);",
          "",
          "[Added Lines]",
          "371:  int (*select)(RDebug *dbg, int pid, int tid);",
          "",
          "---------------"
        ],
        "libr/io/p/io_debug.c||libr/io/p/io_debug.c": [
          "File: libr/io/p/io_debug.c -> libr/io/p/io_debug.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "44: #include <mach-o/nlist.h>",
          "45: #endif",
          "59: typedef struct {",
          "60:  HANDLE hnd;",
          "61:  ut64 winbase;",
          "62: } RIOW32;",
          "64: typedef struct {",
          "67:  ut64 winbase;",
          "68:  PROCESS_INFORMATION pi;",
          "69: } RIOW32Dbg;",
          "",
          "[Removed Lines]",
          "53: #if __WINDOWS__",
          "54: #include <windows.h>",
          "55: #include <tlhelp32.h>",
          "56: #include <winbase.h>",
          "57: #include <psapi.h>",
          "65:  int pid;",
          "66:  int tid;",
          "",
          "[Added Lines]",
          "47: #if __WINDOWS__",
          "48: #include <windows.h>",
          "49: #include <tlhelp32.h>",
          "50: #include <winbase.h>",
          "51: #include <psapi.h>",
          "52: #endif",
          "60: #if __WINDOWS__",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "592:    if ((ret = _plugin->open (io, uri, rw, mode))) {",
          "593:     RIOW32Dbg *w32 = (RIOW32Dbg *)ret->data;",
          "594:     w32->winbase = winbase;",
          "596:    }",
          "597: #elif __APPLE__",
          "598:    sprintf (uri, \"smach://%d\", pid);  //s is for spawn",
          "",
          "[Removed Lines]",
          "595:     w32->tid = wintid;",
          "",
          "[Added Lines]",
          "595:     w32->pi.dwThreadId = wintid;",
          "",
          "---------------"
        ],
        "libr/io/p/io_w32dbg.c||libr/io/p/io_w32dbg.c": [
          "File: libr/io/p/io_w32dbg.c -> libr/io/p/io_w32dbg.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "13: #include <tlhelp32.h>",
          "15: typedef struct {",
          "18:  ut64 winbase;",
          "19:  PROCESS_INFORMATION pi;",
          "20: } RIOW32Dbg;",
          "23: #undef R_IO_NFDS",
          "24: #define R_IO_NFDS 2",
          "",
          "[Removed Lines]",
          "16:  int pid;",
          "17:  int tid;",
          "21: #define RIOW32DBG_PID(x) (((RIOW32Dbg*)x->data)->pid)",
          "",
          "[Added Lines]",
          "19: #define RIOW32DBG_PID(x) (((RIOW32Dbg*)x->data)->pi.dwProcessId)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "94:  return pid;",
          "95: }",
          "98:  DEBUG_EVENT de;",
          "99:  int ret = -1;",
          "102:  if (!h_proc) {",
          "103:   r_sys_perror (\"__open_proc/OpenProcess\");",
          "",
          "[Removed Lines]",
          "97: static int __open_proc (RIOW32Dbg *dbg, bool attach) {",
          "100:  HANDLE h_proc = OpenProcess (PROCESS_ALL_ACCESS, FALSE, dbg->pid);",
          "",
          "[Added Lines]",
          "95: static int __open_proc(RIOW32Dbg *dbg, bool attach) {",
          "98:  HANDLE h_proc = OpenProcess (PROCESS_ALL_ACCESS, FALSE, dbg->pi.dwProcessId);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "105:  }",
          "106:  if (attach) {",
          "109:    r_sys_perror (\"__open_proc/DebugActiveProcess\");",
          "110:    goto att_exit;",
          "111:   }",
          "",
          "[Removed Lines]",
          "108:   if (!DebugActiveProcess(dbg->pid)) {",
          "",
          "[Added Lines]",
          "106:   if (!DebugActiveProcess(dbg->pi.dwProcessId)) {",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "121:   dbg->winbase = (ut64)de.u.CreateProcessInfo.lpBaseOfImage;",
          "122:  }",
          "123:  dbg->pi.hProcess = h_proc;",
          "126: att_exit:",
          "127:  if (ret == -1 && h_proc) {",
          "128:   CloseHandle (h_proc);",
          "",
          "[Removed Lines]",
          "124:  dbg->tid = __w32_first_thread (dbg->pid);",
          "125:  ret = dbg->pid;",
          "",
          "[Added Lines]",
          "122:  dbg->pi.dwProcessId = dbg->pi.dwProcessId;",
          "123:  ret = dbg->pi.dwProcessId;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "137:   if (!dbg) {",
          "138:    return NULL;",
          "139:   }",
          "141:   if (__open_proc (dbg, !strncmp (file, \"attach://\", 9)) == -1) {",
          "142:    free (dbg);",
          "143:    return NULL;",
          "144:   }",
          "145:   ret = r_io_desc_new (io, &r_io_plugin_w32dbg,",
          "146:     file, rw | R_PERM_X, mode, dbg);",
          "148:   return ret;",
          "149:  }",
          "150:  return NULL;",
          "",
          "[Removed Lines]",
          "140:   dbg->pid = atoi (file + 9);",
          "147:   ret->name = r_sys_pid_to_path (dbg->pid);",
          "",
          "[Added Lines]",
          "138:   dbg->pi.dwProcessId = atoi (file + 9);",
          "143:   dbg->pi.dwThreadId = __w32_first_thread (dbg->pi.dwProcessId);",
          "144:   dbg->pi.hThread = OpenThread (THREAD_ALL_ACCESS, FALSE, dbg->pi.dwThreadId);",
          "147:   ret->name = r_sys_pid_to_path (dbg->pi.dwProcessId);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "166: }",
          "168: static int __close(RIODesc *fd) {",
          "171: }",
          "173: static char *__system(RIO *io, RIODesc *fd, const char *cmd) {",
          "",
          "[Removed Lines]",
          "170:  return true;",
          "",
          "[Added Lines]",
          "169:  RIOW32Dbg *iop = fd->data;",
          "170:  DebugActiveProcessStop (iop->pi.dwProcessId);",
          "171:  return false;",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "177:  if (!strncmp (cmd, \"pid\", 3)) {",
          "178:   if (cmd[3] == ' ') {",
          "179:    int pid = atoi (cmd + 3);",
          "181:     iop->pi.hProcess = OpenProcess (PROCESS_ALL_ACCESS, false, pid);",
          "182:     if (iop->pi.hProcess) {",
          "184:     } else {",
          "185:      eprintf (\"Cannot attach to %d\\n\", pid);",
          "186:     }",
          "187:    }",
          "189:   }",
          "191:  } else {",
          "192:   eprintf (\"Try: '=!pid'\\n\");",
          "193:  }",
          "194:  return NULL;",
          "195: }",
          "198:  RIOW32Dbg *iow = (RIOW32Dbg *)(fd ? fd->data : NULL);",
          "199:  if (!iow) {",
          "200:   return -1;",
          "201:  }",
          "203: }",
          "206:  RIOW32Dbg *iow = (RIOW32Dbg *)(fd ? fd->data : NULL);",
          "208: }",
          "211:  RIOW32Dbg *iow = (RIOW32Dbg *)(fd ? fd->data : NULL);",
          "212:  if (base && iow) {",
          "",
          "[Removed Lines]",
          "180:    if (pid > 0 && pid != iop->pid) {",
          "183:      iop->pid = iop->tid = pid;",
          "190:   return r_str_newf (\"%d\", iop->pid);",
          "197: static int __getpid (RIODesc *fd) {",
          "202:  return iow->pid;",
          "205: static int __gettid (RIODesc *fd) {",
          "207:  return iow? iow->tid: -1;",
          "210: static bool __getbase (RIODesc *fd, ut64 *base) {",
          "",
          "[Added Lines]",
          "181:    if (pid > 0 && pid != iop->pi.dwProcessId) {",
          "184:      iop->pi.dwProcessId = iop->pi.dwThreadId = pid;",
          "191:   return r_str_newf (\"%d\", iop->pi.dwProcessId);",
          "198: static int __getpid(RIODesc *fd) {",
          "203:  return iow->pi.dwProcessId;",
          "206: static int __gettid(RIODesc *fd) {",
          "208:  return iow? iow->pi.dwThreadId: -1;",
          "211: static bool __getbase(RIODesc *fd, ut64 *base) {",
          "",
          "---------------"
        ],
        "libr/util/sys.c||libr/util/sys.c": [
          "File: libr/util/sys.c -> libr/util/sys.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "74: #endif",
          "76: R_LIB_VERSION(r_util);",
          "82: static const struct {const char* name; ut64 bit;} arch_bit_array[] = {",
          "83:     {\"x86\", R_SYS_ARCH_X86},",
          "",
          "[Removed Lines]",
          "77: #ifdef _MSC_VER",
          "79: #pragma comment(lib, \"psapi.lib\")",
          "80: #endif",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "meson.build||meson.build": [
          "File: meson.build -> meson.build",
          "--- Hunk 1 ---",
          "[Context before]",
          "103: platform_deps = []",
          "104: platform_inc = ['.', 'libr/include']",
          "105: if host_machine.system() == 'windows'",
          "107: endif",
          "108: platform_inc = include_directories(platform_inc)",
          "",
          "[Removed Lines]",
          "106:   platform_deps = [cc.find_library('ws2_32')]",
          "",
          "[Added Lines]",
          "106:   platform_deps = [cc.find_library('ws2_32'), cc.find_library('psapi')]",
          "",
          "---------------"
        ]
      }
    }
  ]
}
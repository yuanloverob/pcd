{
  "cve_id": "CVE-2017-12168",
  "cve_desc": "The access_pmu_evcntr function in arch/arm64/kvm/sys_regs.c in the Linux kernel before 4.8.11 allows privileged KVM guest OS users to cause a denial of service (assertion failure and host OS crash) by accessing the Performance Monitors Cycle Count Register (PMCCNTR).",
  "repo": "torvalds/linux",
  "patch_hash": "9e3f7a29694049edd728e2400ab57ad7553e5aa9",
  "patch_info": {
    "commit_hash": "9e3f7a29694049edd728e2400ab57ad7553e5aa9",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/9e3f7a29694049edd728e2400ab57ad7553e5aa9",
    "files": [
      "arch/arm64/kvm/sys_regs.c"
    ],
    "message": "arm64: KVM: pmu: Fix AArch32 cycle counter access\n\nWe're missing the handling code for the cycle counter accessed\nfrom a 32bit guest, leading to unexpected results.\n\nCc: stable@vger.kernel.org # 4.6+\nSigned-off-by: Wei Huang <wei@redhat.com>\nSigned-off-by: Marc Zyngier <marc.zyngier@arm.com>",
    "before_after_code_files": [
      "arch/arm64/kvm/sys_regs.c||arch/arm64/kvm/sys_regs.c"
    ]
  },
  "patch_diff": {
    "arch/arm64/kvm/sys_regs.c||arch/arm64/kvm/sys_regs.c": [
      "File: arch/arm64/kvm/sys_regs.c -> arch/arm64/kvm/sys_regs.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "598:    idx = ARMV8_PMU_CYCLE_IDX;",
      "599:   } else {",
      "601:   }",
      "602:  } else if (r->CRn == 14 && (r->CRm & 12) == 8) {",
      "604:   if (pmu_access_event_counter_el0_disabled(vcpu))",
      "",
      "[Removed Lines]",
      "600:    BUG();",
      "",
      "[Added Lines]",
      "600:    return false;",
      "602:  } else if (r->CRn == 0 && r->CRm == 9) {",
      "604:   if (pmu_access_event_counter_el0_disabled(vcpu))",
      "605:    return false;",
      "607:   idx = ARMV8_PMU_CYCLE_IDX;",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "607:   idx = ((r->CRm & 3) << 3) | (r->Op2 & 7);",
      "608:  } else {",
      "610:  }",
      "612:  if (!pmu_counter_idx_valid(vcpu, idx))",
      "",
      "[Removed Lines]",
      "609:   BUG();",
      "",
      "[Added Lines]",
      "615:   return false;",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "051ff581ce70e822729e9474941f3c206cbf7436",
      "candidate_info": {
        "commit_hash": "051ff581ce70e822729e9474941f3c206cbf7436",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/051ff581ce70e822729e9474941f3c206cbf7436",
        "files": [
          "arch/arm64/include/asm/kvm_host.h",
          "arch/arm64/kvm/Makefile",
          "arch/arm64/kvm/sys_regs.c",
          "include/kvm/arm_pmu.h",
          "virt/kvm/arm/pmu.c"
        ],
        "message": "arm64: KVM: Add access handler for event counter register\n\nThese kind of registers include PMEVCNTRn, PMCCNTR and PMXEVCNTR which\nis mapped to PMEVCNTRn.\n\nThe access handler translates all aarch32 register offsets to aarch64\nones and uses vcpu_sys_reg() to access their values to avoid taking care\nof big endian.\n\nWhen reading these registers, return the sum of register value and the\nvalue perf event counts.\n\nSigned-off-by: Shannon Zhao <shannon.zhao@linaro.org>\nReviewed-by: Andrew Jones <drjones@redhat.com>\nSigned-off-by: Marc Zyngier <marc.zyngier@arm.com>",
        "before_after_code_files": [
          "arch/arm64/include/asm/kvm_host.h||arch/arm64/include/asm/kvm_host.h",
          "arch/arm64/kvm/sys_regs.c||arch/arm64/kvm/sys_regs.c",
          "include/kvm/arm_pmu.h||include/kvm/arm_pmu.h",
          "virt/kvm/arm/pmu.c||virt/kvm/arm/pmu.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "arch/arm64/kvm/sys_regs.c||arch/arm64/kvm/sys_regs.c"
          ],
          "candidate": [
            "arch/arm64/kvm/sys_regs.c||arch/arm64/kvm/sys_regs.c"
          ]
        }
      },
      "candidate_diff": {
        "arch/arm64/include/asm/kvm_host.h||arch/arm64/include/asm/kvm_host.h": [
          "File: arch/arm64/include/asm/kvm_host.h -> arch/arm64/include/asm/kvm_host.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "124:  PMEVCNTR30_EL0 = PMEVCNTR0_EL0 + 30,",
          "",
          "---------------"
        ],
        "arch/arm64/kvm/sys_regs.c||arch/arm64/kvm/sys_regs.c": [
          "File: arch/arm64/kvm/sys_regs.c -> arch/arm64/kvm/sys_regs.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "513:  return true;",
          "514: }",
          "517: #define DBG_BCR_BVR_WCR_WVR_EL1(n)     \\",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "516: static bool pmu_counter_idx_valid(struct kvm_vcpu *vcpu, u64 idx)",
          "517: {",
          "518:  u64 pmcr, val;",
          "520:  pmcr = vcpu_sys_reg(vcpu, PMCR_EL0);",
          "521:  val = (pmcr >> ARMV8_PMU_PMCR_N_SHIFT) & ARMV8_PMU_PMCR_N_MASK;",
          "522:  if (idx >= val && idx != ARMV8_PMU_CYCLE_IDX)",
          "523:   return false;",
          "525:  return true;",
          "526: }",
          "528: static bool access_pmu_evcntr(struct kvm_vcpu *vcpu,",
          "529:          struct sys_reg_params *p,",
          "530:          const struct sys_reg_desc *r)",
          "531: {",
          "532:  u64 idx;",
          "534:  if (!kvm_arm_pmu_v3_ready(vcpu))",
          "535:   return trap_raz_wi(vcpu, p, r);",
          "537:  if (r->CRn == 9 && r->CRm == 13) {",
          "538:   if (r->Op2 == 2) {",
          "540:    idx = vcpu_sys_reg(vcpu, PMSELR_EL0)",
          "541:          & ARMV8_PMU_COUNTER_MASK;",
          "542:   } else if (r->Op2 == 0) {",
          "544:    idx = ARMV8_PMU_CYCLE_IDX;",
          "545:   } else {",
          "546:    BUG();",
          "547:   }",
          "548:  } else if (r->CRn == 14 && (r->CRm & 12) == 8) {",
          "550:   idx = ((r->CRm & 3) << 3) | (r->Op2 & 7);",
          "551:  } else {",
          "552:   BUG();",
          "553:  }",
          "555:  if (!pmu_counter_idx_valid(vcpu, idx))",
          "556:   return false;",
          "558:  if (p->is_write)",
          "559:   kvm_pmu_set_counter_value(vcpu, idx, p->regval);",
          "560:  else",
          "561:   p->regval = kvm_pmu_get_counter_value(vcpu, idx);",
          "563:  return true;",
          "564: }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "528:  { Op0(0b10), Op1(0b000), CRn(0b0000), CRm((n)), Op2(0b111), \\",
          "529:    trap_wcr, reset_wcr, n, 0,  get_wcr, set_wcr }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "582: #define PMU_PMEVCNTR_EL0(n)      \\",
          "584:  { Op0(0b11), Op1(0b011), CRn(0b1110),    \\",
          "585:    CRm((0b1000 | (((n) >> 3) & 0x3))), Op2(((n) & 0x7)),  \\",
          "586:    access_pmu_evcntr, reset_unknown, (PMEVCNTR0_EL0 + n), }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "721:    access_pmceid },",
          "723:  { Op0(0b11), Op1(0b011), CRn(0b1001), CRm(0b1101), Op2(0b000),",
          "726:  { Op0(0b11), Op1(0b011), CRn(0b1001), CRm(0b1101), Op2(0b001),",
          "727:    trap_raz_wi },",
          "729:  { Op0(0b11), Op1(0b011), CRn(0b1001), CRm(0b1101), Op2(0b010),",
          "732:  { Op0(0b11), Op1(0b011), CRn(0b1001), CRm(0b1110), Op2(0b000),",
          "733:    trap_raz_wi },",
          "",
          "[Removed Lines]",
          "724:    trap_raz_wi },",
          "730:    trap_raz_wi },",
          "",
          "[Added Lines]",
          "781:    access_pmu_evcntr, reset_unknown, PMCCNTR_EL0 },",
          "787:    access_pmu_evcntr },",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "742:  { Op0(0b11), Op1(0b011), CRn(0b1101), CRm(0b0000), Op2(0b011),",
          "743:    NULL, reset_unknown, TPIDRRO_EL0 },",
          "746:  { Op0(0b11), Op1(0b100), CRn(0b0011), CRm(0b0000), Op2(0b000),",
          "747:    NULL, reset_unknown, DACR32_EL2 },",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "803:  PMU_PMEVCNTR_EL0(0),",
          "804:  PMU_PMEVCNTR_EL0(1),",
          "805:  PMU_PMEVCNTR_EL0(2),",
          "806:  PMU_PMEVCNTR_EL0(3),",
          "807:  PMU_PMEVCNTR_EL0(4),",
          "808:  PMU_PMEVCNTR_EL0(5),",
          "809:  PMU_PMEVCNTR_EL0(6),",
          "810:  PMU_PMEVCNTR_EL0(7),",
          "811:  PMU_PMEVCNTR_EL0(8),",
          "812:  PMU_PMEVCNTR_EL0(9),",
          "813:  PMU_PMEVCNTR_EL0(10),",
          "814:  PMU_PMEVCNTR_EL0(11),",
          "815:  PMU_PMEVCNTR_EL0(12),",
          "816:  PMU_PMEVCNTR_EL0(13),",
          "817:  PMU_PMEVCNTR_EL0(14),",
          "818:  PMU_PMEVCNTR_EL0(15),",
          "819:  PMU_PMEVCNTR_EL0(16),",
          "820:  PMU_PMEVCNTR_EL0(17),",
          "821:  PMU_PMEVCNTR_EL0(18),",
          "822:  PMU_PMEVCNTR_EL0(19),",
          "823:  PMU_PMEVCNTR_EL0(20),",
          "824:  PMU_PMEVCNTR_EL0(21),",
          "825:  PMU_PMEVCNTR_EL0(22),",
          "826:  PMU_PMEVCNTR_EL0(23),",
          "827:  PMU_PMEVCNTR_EL0(24),",
          "828:  PMU_PMEVCNTR_EL0(25),",
          "829:  PMU_PMEVCNTR_EL0(26),",
          "830:  PMU_PMEVCNTR_EL0(27),",
          "831:  PMU_PMEVCNTR_EL0(28),",
          "832:  PMU_PMEVCNTR_EL0(29),",
          "833:  PMU_PMEVCNTR_EL0(30),",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "931:  { Op1( 0), CRm( 2), .access = trap_raz_wi },",
          "932: };",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1025: #define PMU_PMEVCNTR(n)       \\",
          "1027:  { Op1(0), CRn(0b1110),      \\",
          "1028:    CRm((0b1000 | (((n) >> 3) & 0x3))), Op2(((n) & 0x7)),  \\",
          "1029:    access_pmu_evcntr }",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "966:  { Op1( 0), CRn( 9), CRm(12), Op2( 5), access_pmselr },",
          "967:  { Op1( 0), CRn( 9), CRm(12), Op2( 6), access_pmceid },",
          "968:  { Op1( 0), CRn( 9), CRm(12), Op2( 7), access_pmceid },",
          "970:  { Op1( 0), CRn( 9), CRm(13), Op2( 1), trap_raz_wi },",
          "972:  { Op1( 0), CRn( 9), CRm(14), Op2( 0), trap_raz_wi },",
          "973:  { Op1( 0), CRn( 9), CRm(14), Op2( 1), trap_raz_wi },",
          "974:  { Op1( 0), CRn( 9), CRm(14), Op2( 2), trap_raz_wi },",
          "",
          "[Removed Lines]",
          "969:  { Op1( 0), CRn( 9), CRm(13), Op2( 0), trap_raz_wi },",
          "971:  { Op1( 0), CRn( 9), CRm(13), Op2( 2), trap_raz_wi },",
          "",
          "[Added Lines]",
          "1066:  { Op1( 0), CRn( 9), CRm(13), Op2( 0), access_pmu_evcntr },",
          "1068:  { Op1( 0), CRn( 9), CRm(13), Op2( 2), access_pmu_evcntr },",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "982:  { Op1( 0), CRn(12), CRm(12), Op2( 5), trap_raz_wi },",
          "984:  { Op1( 0), CRn(13), CRm( 0), Op2( 1), access_vm_reg, NULL, c13_CID },",
          "985: };",
          "987: static const struct sys_reg_desc cp15_64_regs[] = {",
          "988:  { Op1( 0), CRn( 0), CRm( 2), Op2( 0), access_vm_reg, NULL, c2_TTBR0 },",
          "989:  { Op1( 0), CRn( 0), CRm(12), Op2( 0), access_gic_sgi },",
          "990:  { Op1( 1), CRn( 0), CRm( 2), Op2( 0), access_vm_reg, NULL, c2_TTBR1 },",
          "991: };",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1084:  PMU_PMEVCNTR(0),",
          "1085:  PMU_PMEVCNTR(1),",
          "1086:  PMU_PMEVCNTR(2),",
          "1087:  PMU_PMEVCNTR(3),",
          "1088:  PMU_PMEVCNTR(4),",
          "1089:  PMU_PMEVCNTR(5),",
          "1090:  PMU_PMEVCNTR(6),",
          "1091:  PMU_PMEVCNTR(7),",
          "1092:  PMU_PMEVCNTR(8),",
          "1093:  PMU_PMEVCNTR(9),",
          "1094:  PMU_PMEVCNTR(10),",
          "1095:  PMU_PMEVCNTR(11),",
          "1096:  PMU_PMEVCNTR(12),",
          "1097:  PMU_PMEVCNTR(13),",
          "1098:  PMU_PMEVCNTR(14),",
          "1099:  PMU_PMEVCNTR(15),",
          "1100:  PMU_PMEVCNTR(16),",
          "1101:  PMU_PMEVCNTR(17),",
          "1102:  PMU_PMEVCNTR(18),",
          "1103:  PMU_PMEVCNTR(19),",
          "1104:  PMU_PMEVCNTR(20),",
          "1105:  PMU_PMEVCNTR(21),",
          "1106:  PMU_PMEVCNTR(22),",
          "1107:  PMU_PMEVCNTR(23),",
          "1108:  PMU_PMEVCNTR(24),",
          "1109:  PMU_PMEVCNTR(25),",
          "1110:  PMU_PMEVCNTR(26),",
          "1111:  PMU_PMEVCNTR(27),",
          "1112:  PMU_PMEVCNTR(28),",
          "1113:  PMU_PMEVCNTR(29),",
          "1114:  PMU_PMEVCNTR(30),",
          "1119:  { Op1( 0), CRn( 0), CRm( 9), Op2( 0), access_pmu_evcntr },",
          "",
          "---------------"
        ],
        "include/kvm/arm_pmu.h||include/kvm/arm_pmu.h": [
          "File: include/kvm/arm_pmu.h -> include/kvm/arm_pmu.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "23: #include <linux/perf_event.h>",
          "24: #include <asm/perf_event.h>",
          "26: struct kvm_pmc {",
          "28:  struct perf_event *perf_event;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "26: #define ARMV8_PMU_CYCLE_IDX  (ARMV8_PMU_MAX_COUNTERS - 1)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "36: };",
          "38: #define kvm_arm_pmu_v3_ready(v)  ((v)->arch.pmu.ready)",
          "39: #else",
          "40: struct kvm_pmu {",
          "41: };",
          "43: #define kvm_arm_pmu_v3_ready(v)  (false)",
          "44: #endif",
          "46: #endif",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "41: u64 kvm_pmu_get_counter_value(struct kvm_vcpu *vcpu, u64 select_idx);",
          "42: void kvm_pmu_set_counter_value(struct kvm_vcpu *vcpu, u64 select_idx, u64 val);",
          "48: static inline u64 kvm_pmu_get_counter_value(struct kvm_vcpu *vcpu,",
          "49:          u64 select_idx)",
          "50: {",
          "51:  return 0;",
          "52: }",
          "53: static inline void kvm_pmu_set_counter_value(struct kvm_vcpu *vcpu,",
          "54:           u64 select_idx, u64 val) {}",
          "",
          "---------------"
        ],
        "virt/kvm/arm/pmu.c||virt/kvm/arm/pmu.c": [
          "File: virt/kvm/arm/pmu.c -> virt/kvm/arm/pmu.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "18: #include <linux/cpu.h>",
          "19: #include <linux/kvm.h>",
          "20: #include <linux/kvm_host.h>",
          "21: #include <linux/perf_event.h>",
          "22: #include <asm/kvm_emulate.h>",
          "23: #include <kvm/arm_pmu.h>",
          "30: u64 kvm_pmu_get_counter_value(struct kvm_vcpu *vcpu, u64 select_idx)",
          "31: {",
          "32:  u64 counter, reg, enabled, running;",
          "33:  struct kvm_pmu *pmu = &vcpu->arch.pmu;",
          "34:  struct kvm_pmc *pmc = &pmu->pmc[select_idx];",
          "36:  reg = (select_idx == ARMV8_PMU_CYCLE_IDX)",
          "37:        ? PMCCNTR_EL0 : PMEVCNTR0_EL0 + select_idx;",
          "38:  counter = vcpu_sys_reg(vcpu, reg);",
          "43:  if (pmc->perf_event)",
          "44:   counter += perf_event_read_value(pmc->perf_event, &enabled,",
          "45:        &running);",
          "47:  return counter & pmc->bitmask;",
          "48: }",
          "56: void kvm_pmu_set_counter_value(struct kvm_vcpu *vcpu, u64 select_idx, u64 val)",
          "57: {",
          "58:  u64 reg;",
          "60:  reg = (select_idx == ARMV8_PMU_CYCLE_IDX)",
          "61:        ? PMCCNTR_EL0 : PMEVCNTR0_EL0 + select_idx;",
          "62:  vcpu_sys_reg(vcpu, reg) += (s64)val - kvm_pmu_get_counter_value(vcpu, select_idx);",
          "63: }",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2013-4125",
  "cve_desc": "The fib6_add_rt2node function in net/ipv6/ip6_fib.c in the IPv6 stack in the Linux kernel through 3.10.1 does not properly handle Router Advertisement (RA) messages in certain circumstances involving three routes that initially qualified for membership in an ECMP route set until a change occurred for one of the first two routes, which allows remote attackers to cause a denial of service (system crash) via a crafted sequence of messages.",
  "repo": "torvalds/linux",
  "patch_hash": "307f2fb95e9b96b3577916e73d92e104f8f26494",
  "patch_info": {
    "commit_hash": "307f2fb95e9b96b3577916e73d92e104f8f26494",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/307f2fb95e9b96b3577916e73d92e104f8f26494",
    "files": [
      "net/ipv6/ip6_fib.c"
    ],
    "message": "ipv6: only static routes qualify for equal cost multipathing\n\nStatic routes in this case are non-expiring routes which did not get\nconfigured by autoconf or by icmpv6 redirects.\n\nTo make sure we actually get an ecmp route while searching for the first\none in this fib6_node's leafs, also make sure it matches the ecmp route\nassumptions.\n\nv2:\na) Removed RTF_EXPIRE check in dst.from chain. The check of RTF_ADDRCONF\n   already ensures that this route, even if added again without\n   RTF_EXPIRES (in case of a RA announcement with infinite timeout),\n   does not cause the rt6i_nsiblings logic to go wrong if a later RA\n   updates the expiration time later.\n\nv3:\na) Allow RTF_EXPIRES routes to enter the ecmp route set. We have to do so,\n   because an pmtu event could update the RTF_EXPIRES flag and we would\n   not count this route, if another route joins this set. We now filter\n   only for RTF_GATEWAY|RTF_ADDRCONF|RTF_DYNAMIC, which are flags that\n   don't get changed after rt6_info construction.\n\nCc: Nicolas Dichtel <nicolas.dichtel@6wind.com>\nSigned-off-by: Hannes Frederic Sowa <hannes@stressinduktion.org>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
    "before_after_code_files": [
      "net/ipv6/ip6_fib.c||net/ipv6/ip6_fib.c"
    ]
  },
  "patch_diff": {
    "net/ipv6/ip6_fib.c||net/ipv6/ip6_fib.c": [
      "File: net/ipv6/ip6_fib.c -> net/ipv6/ip6_fib.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "632:  return ln;",
      "633: }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "635: static inline bool rt6_qualify_for_ecmp(struct rt6_info *rt)",
      "636: {",
      "637:  return (rt->rt6i_flags & (RTF_GATEWAY|RTF_ADDRCONF|RTF_DYNAMIC)) ==",
      "638:         RTF_GATEWAY;",
      "639: }",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "646:  int add = (!info->nlh ||",
      "647:      (info->nlh->nlmsg_flags & NLM_F_CREATE));",
      "648:  int found = 0;",
      "650:  ins = &fn->leaf;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "655:  bool rt_can_ecmp = rt6_qualify_for_ecmp(rt);",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "697:     rt->rt6i_nsiblings++;",
      "698:   }",
      "",
      "[Removed Lines]",
      "694:    if (rt->rt6i_flags & RTF_GATEWAY &&",
      "695:        !(rt->rt6i_flags & RTF_EXPIRES) &&",
      "696:        !(iter->rt6i_flags & RTF_EXPIRES))",
      "",
      "[Added Lines]",
      "701:    if (rt_can_ecmp &&",
      "702:        rt6_qualify_for_ecmp(iter))",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "716:   sibling = fn->leaf;",
      "717:   while (sibling) {",
      "719:     list_add_tail(&rt->rt6i_siblings,",
      "720:            &sibling->rt6i_siblings);",
      "721:     break;",
      "",
      "[Removed Lines]",
      "718:    if (sibling->rt6i_metric == rt->rt6i_metric) {",
      "",
      "[Added Lines]",
      "724:    if (sibling->rt6i_metric == rt->rt6i_metric &&",
      "725:        rt6_qualify_for_ecmp(sibling)) {",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "51ebd3181572af8d5076808dab2682d800f6da5d",
      "candidate_info": {
        "commit_hash": "51ebd3181572af8d5076808dab2682d800f6da5d",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/51ebd3181572af8d5076808dab2682d800f6da5d",
        "files": [
          "include/net/ip6_fib.h",
          "net/ipv6/ip6_fib.c",
          "net/ipv6/route.c"
        ],
        "message": "ipv6: add support of equal cost multipath (ECMP)\n\nEach nexthop is added like a single route in the routing table. All routes\nthat have the same metric/weight and destination but not the same gateway\nare considering as ECMP routes. They are linked together, through a list called\nrt6i_siblings.\n\nECMP routes can be added in one shot, with RTA_MULTIPATH attribute or one after\nthe other (in both case, the flag NLM_F_EXCL should not be set).\n\nThe patch is based on a previous work from\nLuc Saillard <luc.saillard@6wind.com>.\n\nSigned-off-by: Nicolas Dichtel <nicolas.dichtel@6wind.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "before_after_code_files": [
          "include/net/ip6_fib.h||include/net/ip6_fib.h",
          "net/ipv6/ip6_fib.c||net/ipv6/ip6_fib.c",
          "net/ipv6/route.c||net/ipv6/route.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "net/ipv6/ip6_fib.c||net/ipv6/ip6_fib.c"
          ],
          "candidate": [
            "net/ipv6/ip6_fib.c||net/ipv6/ip6_fib.c"
          ]
        }
      },
      "candidate_diff": {
        "include/net/ip6_fib.h||include/net/ip6_fib.h": [
          "File: include/net/ip6_fib.h -> include/net/ip6_fib.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "47:  unsigned long fc_expires;",
          "48:  struct nlattr *fc_mx;",
          "49:  int  fc_mx_len;",
          "51:  struct nl_info fc_nlinfo;",
          "52: };",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "50:  int  fc_mp_len;",
          "51:  struct nlattr *fc_mp;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "100:  struct in6_addr   rt6i_gateway;",
          "102:  atomic_t   rt6i_ref;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "109:  struct list_head  rt6i_siblings;",
          "110:  unsigned int   rt6i_nsiblings;",
          "",
          "---------------"
        ],
        "net/ipv6/ip6_fib.c||net/ipv6/ip6_fib.c": [
          "File: net/ipv6/ip6_fib.c -> net/ipv6/ip6_fib.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "672:        iter->rt6i_idev == rt->rt6i_idev &&",
          "673:        ipv6_addr_equal(&iter->rt6i_gateway,",
          "674:          &rt->rt6i_gateway)) {",
          "675:     if (!(iter->rt6i_flags & RTF_EXPIRES))",
          "676:      return -EEXIST;",
          "677:     if (!(rt->rt6i_flags & RTF_EXPIRES))",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "675:     if (rt->rt6i_nsiblings)",
          "676:      rt->rt6i_nsiblings = 0;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "680:      rt6_set_expires(iter, rt->dst.expires);",
          "681:     return -EEXIST;",
          "682:    }",
          "683:   }",
          "685:   if (iter->rt6i_metric > rt->rt6i_metric)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "696:    if (rt->rt6i_flags & RTF_GATEWAY &&",
          "697:        !(rt->rt6i_flags & RTF_EXPIRES) &&",
          "698:        !(iter->rt6i_flags & RTF_EXPIRES))",
          "699:     rt->rt6i_nsiblings++;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "692:  if (ins == &fn->leaf)",
          "693:   fn->rr_ptr = NULL;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "713:  if (rt->rt6i_nsiblings) {",
          "714:   unsigned int rt6i_nsiblings;",
          "715:   struct rt6_info *sibling, *temp_sibling;",
          "718:   sibling = fn->leaf;",
          "719:   while (sibling) {",
          "720:    if (sibling->rt6i_metric == rt->rt6i_metric) {",
          "721:     list_add_tail(&rt->rt6i_siblings,",
          "722:            &sibling->rt6i_siblings);",
          "723:     break;",
          "724:    }",
          "725:    sibling = sibling->dst.rt6_next;",
          "726:   }",
          "731:   rt6i_nsiblings = 0;",
          "732:   list_for_each_entry_safe(sibling, temp_sibling,",
          "733:       &rt->rt6i_siblings, rt6i_siblings) {",
          "734:    sibling->rt6i_nsiblings++;",
          "735:    BUG_ON(sibling->rt6i_nsiblings != rt->rt6i_nsiblings);",
          "736:    rt6i_nsiblings++;",
          "737:   }",
          "738:   BUG_ON(rt6i_nsiblings != rt->rt6i_nsiblings);",
          "739:  }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1193:  if (fn->rr_ptr == rt)",
          "1194:   fn->rr_ptr = NULL;",
          "1197:  read_lock(&fib6_walker_lock);",
          "1198:  FOR_WALKERS(w) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1243:  if (rt->rt6i_nsiblings) {",
          "1244:   struct rt6_info *sibling, *next_sibling;",
          "1246:   list_for_each_entry_safe(sibling, next_sibling,",
          "1247:       &rt->rt6i_siblings, rt6i_siblings)",
          "1248:    sibling->rt6i_nsiblings--;",
          "1249:   rt->rt6i_nsiblings = 0;",
          "1250:   list_del_init(&rt->rt6i_siblings);",
          "1251:  }",
          "",
          "---------------"
        ],
        "net/ipv6/route.c||net/ipv6/route.c": [
          "File: net/ipv6/route.c -> net/ipv6/route.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "57: #include <net/xfrm.h>",
          "58: #include <net/netevent.h>",
          "59: #include <net/netlink.h>",
          "61: #include <asm/uaccess.h>",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "60: #include <net/nexthop.h>",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "289:   memset(dst + 1, 0, sizeof(*rt) - sizeof(*dst));",
          "290:   rt6_init_peer(rt, table ? &table->tb6_peers : net->ipv6.peers);",
          "291:   rt->rt6i_genid = rt_genid(net);",
          "292:  }",
          "293:  return rt;",
          "294: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "293:   INIT_LIST_HEAD(&rt->rt6i_siblings);",
          "294:   rt->rt6i_nsiblings = 0;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "385:   (IPV6_ADDR_MULTICAST | IPV6_ADDR_LINKLOCAL | IPV6_ADDR_LOOPBACK);",
          "386: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "395: static int rt6_info_hash_nhsfn(unsigned int candidate_count,",
          "396:           const struct flowi6 *fl6)",
          "397: {",
          "398:  unsigned int val = fl6->flowi6_proto;",
          "400:  val ^= fl6->daddr.s6_addr32[0];",
          "401:  val ^= fl6->daddr.s6_addr32[1];",
          "402:  val ^= fl6->daddr.s6_addr32[2];",
          "403:  val ^= fl6->daddr.s6_addr32[3];",
          "405:  val ^= fl6->saddr.s6_addr32[0];",
          "406:  val ^= fl6->saddr.s6_addr32[1];",
          "407:  val ^= fl6->saddr.s6_addr32[2];",
          "408:  val ^= fl6->saddr.s6_addr32[3];",
          "411:  switch (fl6->flowi6_proto) {",
          "412:  case IPPROTO_UDP:",
          "413:  case IPPROTO_TCP:",
          "414:  case IPPROTO_SCTP:",
          "415:   val ^= fl6->fl6_sport;",
          "416:   val ^= fl6->fl6_dport;",
          "417:   break;",
          "419:  case IPPROTO_ICMPV6:",
          "420:   val ^= fl6->fl6_icmp_type;",
          "421:   val ^= fl6->fl6_icmp_code;",
          "422:   break;",
          "423:  }",
          "425:  val ^= fl6->flowlabel;",
          "428:  val = val ^ (val >> 7) ^ (val >> 12);",
          "429:  return val % candidate_count;",
          "430: }",
          "432: static struct rt6_info *rt6_multipath_select(struct rt6_info *match,",
          "433:           struct flowi6 *fl6)",
          "434: {",
          "435:  struct rt6_info *sibling, *next_sibling;",
          "436:  int route_choosen;",
          "438:  route_choosen = rt6_info_hash_nhsfn(match->rt6i_nsiblings + 1, fl6);",
          "442:  if (route_choosen)",
          "443:   list_for_each_entry_safe(sibling, next_sibling,",
          "444:     &match->rt6i_siblings, rt6i_siblings) {",
          "445:    route_choosen--;",
          "446:    if (route_choosen == 0) {",
          "447:     match = sibling;",
          "448:     break;",
          "449:    }",
          "450:   }",
          "451:  return match;",
          "452: }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "702: restart:",
          "703:  rt = fn->leaf;",
          "704:  rt = rt6_device_match(net, rt, &fl6->saddr, fl6->flowi6_oif, flags);",
          "705:  BACKTRACK(net, &fl6->saddr);",
          "706: out:",
          "707:  dst_use(&rt->dst, jiffies);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "771:  if (rt->rt6i_nsiblings && fl6->flowi6_oif == 0)",
          "772:   rt = rt6_multipath_select(rt, fl6);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "864: restart:",
          "865:  rt = rt6_select(fn, oif, strict | reachable);",
          "867:  BACKTRACK(net, &fl6->saddr);",
          "868:  if (rt == net->ipv6.ip6_null_entry ||",
          "869:      rt->rt6i_flags & RTF_CACHE)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "934:  if (rt->rt6i_nsiblings && oif == 0)",
          "935:   rt = rt6_multipath_select(rt, fl6);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "2249:  [RTA_IIF]  = { .type = NLA_U32 },",
          "2250:  [RTA_PRIORITY]          = { .type = NLA_U32 },",
          "2251:  [RTA_METRICS]           = { .type = NLA_NESTED },",
          "2252: };",
          "2254: static int rtm_to_fib6_config(struct sk_buff *skb, struct nlmsghdr *nlh,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2321:  [RTA_MULTIPATH]  = { .len = sizeof(struct rtnexthop) },",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "2326:  if (tb[RTA_TABLE])",
          "2327:   cfg->fc_table = nla_get_u32(tb[RTA_TABLE]);",
          "2329:  err = 0;",
          "2330: errout:",
          "2331:  return err;",
          "2332: }",
          "2334: static int inet6_rtm_delroute(struct sk_buff *skb, struct nlmsghdr* nlh, void *arg)",
          "2335: {",
          "2336:  struct fib6_config cfg;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2399:  if (tb[RTA_MULTIPATH]) {",
          "2400:   cfg->fc_mp = nla_data(tb[RTA_MULTIPATH]);",
          "2401:   cfg->fc_mp_len = nla_len(tb[RTA_MULTIPATH]);",
          "2402:  }",
          "2409: static int ip6_route_multipath(struct fib6_config *cfg, int add)",
          "2410: {",
          "2411:  struct fib6_config r_cfg;",
          "2412:  struct rtnexthop *rtnh;",
          "2413:  int remaining;",
          "2414:  int attrlen;",
          "2415:  int err = 0, last_err = 0;",
          "2417: beginning:",
          "2418:  rtnh = (struct rtnexthop *)cfg->fc_mp;",
          "2419:  remaining = cfg->fc_mp_len;",
          "2422:  while (rtnh_ok(rtnh, remaining)) {",
          "2423:   memcpy(&r_cfg, cfg, sizeof(*cfg));",
          "2424:   if (rtnh->rtnh_ifindex)",
          "2425:    r_cfg.fc_ifindex = rtnh->rtnh_ifindex;",
          "2427:   attrlen = rtnh_attrlen(rtnh);",
          "2428:   if (attrlen > 0) {",
          "2429:    struct nlattr *nla, *attrs = rtnh_attrs(rtnh);",
          "2431:    nla = nla_find(attrs, attrlen, RTA_GATEWAY);",
          "2432:    if (nla) {",
          "2433:     nla_memcpy(&r_cfg.fc_gateway, nla, 16);",
          "2434:     r_cfg.fc_flags |= RTF_GATEWAY;",
          "2435:    }",
          "2436:   }",
          "2437:   err = add ? ip6_route_add(&r_cfg) : ip6_route_del(&r_cfg);",
          "2438:   if (err) {",
          "2439:    last_err = err;",
          "2444:    if (add) {",
          "2448:     add = 0;",
          "2449:     goto beginning;",
          "2450:    }",
          "2451:   }",
          "2452:   rtnh = rtnh_next(rtnh, &remaining);",
          "2453:  }",
          "2455:  return last_err;",
          "2456: }",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "2340:  if (err < 0)",
          "2341:   return err;",
          "2344: }",
          "2346: static int inet6_rtm_newroute(struct sk_buff *skb, struct nlmsghdr* nlh, void *arg)",
          "",
          "[Removed Lines]",
          "2343:  return ip6_route_del(&cfg);",
          "",
          "[Added Lines]",
          "2467:  if (cfg.fc_mp)",
          "2468:   return ip6_route_multipath(&cfg, 0);",
          "2469:  else",
          "2470:   return ip6_route_del(&cfg);",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "2352:  if (err < 0)",
          "2353:   return err;",
          "2356: }",
          "2358: static inline size_t rt6_nlmsg_size(void)",
          "",
          "[Removed Lines]",
          "2355:  return ip6_route_add(&cfg);",
          "",
          "[Added Lines]",
          "2482:  if (cfg.fc_mp)",
          "2483:   return ip6_route_multipath(&cfg, 1);",
          "2484:  else",
          "2485:   return ip6_route_add(&cfg);",
          "",
          "---------------"
        ]
      }
    }
  ]
}
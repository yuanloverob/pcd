{
  "cve_id": "CVE-2012-3364",
  "cve_desc": "Multiple stack-based buffer overflows in the Near Field Communication Controller Interface (NCI) in the Linux kernel before 3.4.5 allow remote attackers to cause a denial of service (crash) and possibly execute arbitrary code via incoming frames with crafted length fields.",
  "repo": "torvalds/linux",
  "patch_hash": "67de956ff5dc1d4f321e16cfbd63f5be3b691b43",
  "patch_info": {
    "commit_hash": "67de956ff5dc1d4f321e16cfbd63f5be3b691b43",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/67de956ff5dc1d4f321e16cfbd63f5be3b691b43",
    "files": [
      "net/nfc/nci/ntf.c"
    ],
    "message": "NFC: Prevent multiple buffer overflows in NCI\n\nFix multiple remotely-exploitable stack-based buffer overflows due to\nthe NCI code pulling length fields directly from incoming frames and\ncopying too much data into statically-sized arrays.\n\nSigned-off-by: Dan Rosenberg <dan.j.rosenberg@gmail.com>\nCc: stable@kernel.org\nCc: security@kernel.org\nCc: Lauro Ramos Venancio <lauro.venancio@openbossa.org>\nCc: Aloisio Almeida Jr <aloisio.almeida@openbossa.org>\nCc: Samuel Ortiz <sameo@linux.intel.com>\nCc: David S. Miller <davem@davemloft.net>\nAcked-by: Ilan Elias <ilane@ti.com>\nSigned-off-by: Samuel Ortiz <sameo@linux.intel.com>",
    "before_after_code_files": [
      "net/nfc/nci/ntf.c||net/nfc/nci/ntf.c"
    ]
  },
  "patch_diff": {
    "net/nfc/nci/ntf.c||net/nfc/nci/ntf.c": [
      "File: net/nfc/nci/ntf.c -> net/nfc/nci/ntf.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "106:  nfca_poll->sens_res = __le16_to_cpu(*((__u16 *)data));",
      "107:  data += 2;",
      "111:  pr_debug(\"sens_res 0x%x, nfcid1_len %d\\n\",",
      "112:    nfca_poll->sens_res, nfca_poll->nfcid1_len);",
      "",
      "[Removed Lines]",
      "109:  nfca_poll->nfcid1_len = *data++;",
      "",
      "[Added Lines]",
      "109:  nfca_poll->nfcid1_len = min_t(__u8, *data++, NFC_NFCID1_MAXSIZE);",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "130:    struct rf_tech_specific_params_nfcb_poll *nfcb_poll,",
      "131:            __u8 *data)",
      "132: {",
      "135:  pr_debug(\"sensb_res_len %d\\n\", nfcb_poll->sensb_res_len);",
      "",
      "[Removed Lines]",
      "133:  nfcb_poll->sensb_res_len = *data++;",
      "",
      "[Added Lines]",
      "133:  nfcb_poll->sensb_res_len = min_t(__u8, *data++, NFC_SENSB_RES_MAXSIZE);",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "145:            __u8 *data)",
      "146: {",
      "147:  nfcf_poll->bit_rate = *data++;",
      "150:  pr_debug(\"bit_rate %d, sensf_res_len %d\\n\",",
      "151:    nfcf_poll->bit_rate, nfcf_poll->sensf_res_len);",
      "",
      "[Removed Lines]",
      "148:  nfcf_poll->sensf_res_len = *data++;",
      "",
      "[Added Lines]",
      "148:  nfcf_poll->sensf_res_len = min_t(__u8, *data++, NFC_SENSF_RES_MAXSIZE);",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "331:  switch (ntf->activation_rf_tech_and_mode) {",
      "332:  case NCI_NFC_A_PASSIVE_POLL_MODE:",
      "333:   nfca_poll = &ntf->activation_params.nfca_poll_iso_dep;",
      "335:   pr_debug(\"rats_res_len %d\\n\", nfca_poll->rats_res_len);",
      "336:   if (nfca_poll->rats_res_len > 0) {",
      "337:    memcpy(nfca_poll->rats_res,",
      "",
      "[Removed Lines]",
      "334:   nfca_poll->rats_res_len = *data++;",
      "",
      "[Added Lines]",
      "334:   nfca_poll->rats_res_len = min_t(__u8, *data++, 20);",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "342:  case NCI_NFC_B_PASSIVE_POLL_MODE:",
      "343:   nfcb_poll = &ntf->activation_params.nfcb_poll_iso_dep;",
      "345:   pr_debug(\"attrib_res_len %d\\n\", nfcb_poll->attrib_res_len);",
      "346:   if (nfcb_poll->attrib_res_len > 0) {",
      "347:    memcpy(nfcb_poll->attrib_res,",
      "",
      "[Removed Lines]",
      "344:   nfcb_poll->attrib_res_len = *data++;",
      "",
      "[Added Lines]",
      "344:   nfcb_poll->attrib_res_len = min_t(__u8, *data++, 50);",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "e8c0dacd9836dc2dcb28d236c9cc3cfaa9965a20",
      "candidate_info": {
        "commit_hash": "e8c0dacd9836dc2dcb28d236c9cc3cfaa9965a20",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/e8c0dacd9836dc2dcb28d236c9cc3cfaa9965a20",
        "files": [
          "include/net/nfc/nci.h",
          "include/net/nfc/nci_core.h",
          "net/nfc/nci/core.c",
          "net/nfc/nci/data.c",
          "net/nfc/nci/lib.c",
          "net/nfc/nci/ntf.c",
          "net/nfc/nci/rsp.c"
        ],
        "message": "NFC: Update names and structs to NCI spec 1.0 d18\n\nAddition, deletion and modification of NCI constants.\nChanges in NCI commands, responses and notifications structures.\n\nSigned-off-by: Ilan Elias <ilane@ti.com>\nAcked-by: Lauro Ramos Venancio <lauro.venancio@openbossa.org>\nSigned-off-by: John W. Linville <linville@tuxdriver.com>",
        "before_after_code_files": [
          "include/net/nfc/nci.h||include/net/nfc/nci.h",
          "include/net/nfc/nci_core.h||include/net/nfc/nci_core.h",
          "net/nfc/nci/core.c||net/nfc/nci/core.c",
          "net/nfc/nci/data.c||net/nfc/nci/data.c",
          "net/nfc/nci/lib.c||net/nfc/nci/lib.c",
          "net/nfc/nci/ntf.c||net/nfc/nci/ntf.c",
          "net/nfc/nci/rsp.c||net/nfc/nci/rsp.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "net/nfc/nci/ntf.c||net/nfc/nci/ntf.c"
          ],
          "candidate": [
            "net/nfc/nci/ntf.c||net/nfc/nci/ntf.c"
          ]
        }
      },
      "candidate_diff": {
        "include/net/nfc/nci.h||include/net/nfc/nci.h": [
          "File: include/net/nfc/nci.h -> include/net/nfc/nci.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "37: #define NCI_STATUS_OK      0x00",
          "38: #define NCI_STATUS_REJECTED     0x01",
          "50: #define NCI_STATUS_DISCOVERY_ALREADY_STARTED   0xa0",
          "51: #define NCI_STATUS_DISCOVERY_TARGET_ACTIVATION_FAILED  0xa1",
          "53: #define NCI_STATUS_RF_TRANSMISSION_ERROR   0xb0",
          "54: #define NCI_STATUS_RF_PROTOCOL_ERROR    0xb1",
          "55: #define NCI_STATUS_RF_TIMEOUT_ERROR    0xb2",
          "58: #define NCI_STATUS_MAX_ACTIVE_NFCEE_INTERFACES_REACHED  0xc0",
          "59: #define NCI_STATUS_NFCEE_INTERFACE_ACTIVATION_FAILED  0xc1",
          "",
          "[Removed Lines]",
          "39: #define NCI_STATUS_MESSAGE_CORRUPTED    0x02",
          "40: #define NCI_STATUS_BUFFER_FULL     0x03",
          "41: #define NCI_STATUS_FAILED     0x04",
          "42: #define NCI_STATUS_NOT_INITIALIZED    0x05",
          "43: #define NCI_STATUS_SYNTAX_ERROR     0x06",
          "44: #define NCI_STATUS_SEMANTIC_ERROR    0x07",
          "45: #define NCI_STATUS_UNKNOWN_GID     0x08",
          "46: #define NCI_STATUS_UNKNOWN_OID     0x09",
          "47: #define NCI_STATUS_INVALID_PARAM    0x0a",
          "48: #define NCI_STATUS_MESSAGE_SIZE_EXCEEDED   0x0b",
          "56: #define NCI_STATUS_RF_LINK_LOSS_ERROR    0xb3",
          "",
          "[Added Lines]",
          "39: #define NCI_STATUS_RF_FRAME_CORRUPTED    0x02",
          "40: #define NCI_STATUS_FAILED     0x03",
          "41: #define NCI_STATUS_NOT_INITIALIZED    0x04",
          "42: #define NCI_STATUS_SYNTAX_ERROR     0x05",
          "43: #define NCI_STATUS_SEMANTIC_ERROR    0x06",
          "44: #define NCI_STATUS_UNKNOWN_GID     0x07",
          "45: #define NCI_STATUS_UNKNOWN_OID     0x08",
          "46: #define NCI_STATUS_INVALID_PARAM    0x09",
          "47: #define NCI_STATUS_MESSAGE_SIZE_EXCEEDED   0x0a",
          "51: #define NCI_STATUS_DISCOVERY_TEAR_DOWN    0xa2",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "73: #define NCI_NFC_A_ACTIVE_LISTEN_MODE    0x83",
          "74: #define NCI_NFC_F_ACTIVE_LISTEN_MODE    0x85",
          "77: #define NCI_RF_PROTOCOL_UNKNOWN     0x00",
          "78: #define NCI_RF_PROTOCOL_T1T     0x01",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "76: #define NCI_NFC_RF_TECHNOLOGY_A     0x00",
          "77: #define NCI_NFC_RF_TECHNOLOGY_B     0x01",
          "78: #define NCI_NFC_RF_TECHNOLOGY_F     0x02",
          "79: #define NCI_NFC_RF_TECHNOLOGY_15693    0x03",
          "82: #define NCI_NFC_BIT_RATE_106     0x00",
          "83: #define NCI_NFC_BIT_RATE_212     0x01",
          "84: #define NCI_NFC_BIT_RATE_424     0x02",
          "85: #define NCI_NFC_BIT_RATE_848     0x03",
          "86: #define NCI_NFC_BIT_RATE_1696     0x04",
          "87: #define NCI_NFC_BIT_RATE_3392     0x05",
          "88: #define NCI_NFC_BIT_RATE_6784     0x06",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "82: #define NCI_RF_PROTOCOL_NFC_DEP     0x05",
          "86: #define NCI_RF_INTERFACE_FRAME     0x01",
          "87: #define NCI_RF_INTERFACE_ISO_DEP    0x02",
          "88: #define NCI_RF_INTERFACE_NFC_DEP    0x03",
          "91: #define NCI_DISC_MAP_MODE_POLL     0x01",
          "92: #define NCI_DISC_MAP_MODE_LISTEN    0x02",
          "",
          "[Removed Lines]",
          "85: #define NCI_RF_INTERFACE_RFU     0x00",
          "",
          "[Added Lines]",
          "99: #define NCI_RF_INTERFACE_NFCEE_DIRECT    0x00",
          "105: #define NCI_RESET_TYPE_KEEP_CONFIG    0x00",
          "106: #define NCI_RESET_TYPE_RESET_CONFIG    0x01",
          "109: #define NCI_STATIC_RF_CONN_ID     0x00",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "98: #define NCI_DISCOVERY_TYPE_POLL_F_PASSIVE   0x02",
          "99: #define NCI_DISCOVERY_TYPE_POLL_A_ACTIVE   0x03",
          "100: #define NCI_DISCOVERY_TYPE_POLL_F_ACTIVE   0x05",
          "103: #define NCI_DISCOVERY_TYPE_WAKEUP_A_ACTIVE   0x09",
          "104: #define NCI_DISCOVERY_TYPE_LISTEN_A_PASSIVE   0x80",
          "105: #define NCI_DISCOVERY_TYPE_LISTEN_B_PASSIVE   0x81",
          "",
          "[Removed Lines]",
          "101: #define NCI_DISCOVERY_TYPE_WAKEUP_A_PASSIVE   0x06",
          "102: #define NCI_DISCOVERY_TYPE_WAKEUP_B_PASSIVE   0x07",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "111: #define NCI_DEACTIVATE_TYPE_IDLE_MODE    0x00",
          "112: #define NCI_DEACTIVATE_TYPE_SLEEP_MODE    0x01",
          "113: #define NCI_DEACTIVATE_TYPE_SLEEP_AF_MODE   0x02",
          "118: #define NCI_MT_DATA_PKT      0x00",
          "",
          "[Removed Lines]",
          "114: #define NCI_DEACTIVATE_TYPE_RF_LINK_LOSS   0x03",
          "115: #define NCI_DEACTIVATE_TYPE_DISCOVERY_ERROR   0x04",
          "",
          "[Added Lines]",
          "133: #define NCI_DEACTIVATE_TYPE_DISCOVERY    0x03",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "171: #define NCI_OP_CORE_RESET_CMD  nci_opcode_pack(NCI_GID_CORE, 0x00)",
          "173: #define NCI_OP_CORE_INIT_CMD  nci_opcode_pack(NCI_GID_CORE, 0x01)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "190: struct nci_core_reset_cmd {",
          "191:  __u8 reset_type;",
          "192: } __packed;",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "218: struct nci_core_reset_rsp {",
          "219:  __u8 status;",
          "220:  __u8 nci_ver;",
          "221: } __packed;",
          "223: #define NCI_OP_CORE_INIT_RSP  nci_opcode_pack(NCI_GID_CORE, 0x01)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "242:  __u8 config_status;",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "232: struct nci_core_init_rsp_2 {",
          "233:  __u8 max_logical_connections;",
          "234:  __le16 max_routing_table_size;",
          "239: } __packed;",
          "241: #define NCI_OP_CORE_SET_CONFIG_RSP nci_opcode_pack(NCI_GID_CORE, 0x02)",
          "",
          "[Removed Lines]",
          "235:  __u8 max_control_packet_payload_length;",
          "236:  __le16 rf_sending_buffer_size;",
          "237:  __le16 rf_receiving_buffer_size;",
          "238:  __le16 manufacturer_id;",
          "",
          "[Added Lines]",
          "257:  __u8 max_ctrl_pkt_payload_len;",
          "258:  __le16 max_size_for_large_params;",
          "259:  __u8 max_data_pkt_payload_size;",
          "260:  __u8 initial_num_credits;",
          "261:  __u8 manufact_id;",
          "262:  __le32 manufact_specific_info;",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "275:  __u8 rf_field_status;",
          "276: } __packed;",
          "279: struct rf_tech_specific_params_nfca_poll {",
          "280:  __u16 sens_res;",
          "",
          "[Removed Lines]",
          "278: #define NCI_OP_RF_ACTIVATE_NTF  nci_opcode_pack(NCI_GID_RF_MGMT, 0x05)",
          "",
          "[Added Lines]",
          "302: #define NCI_OP_RF_INTF_ACTIVATED_NTF nci_opcode_pack(NCI_GID_RF_MGMT, 0x05)",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "289:  __u8 rats_res[20];",
          "290: };",
          "294:  __u8 rf_protocol;",
          "296:  __u8 rf_tech_specific_params_len;",
          "298:  union {",
          "299:   struct rf_tech_specific_params_nfca_poll nfca_poll;",
          "300:  } rf_tech_specific_params;",
          "303:  __u8 activation_params_len;",
          "305:  union {",
          "",
          "[Removed Lines]",
          "292: struct nci_rf_activate_ntf {",
          "293:  __u8 target_handle;",
          "295:  __u8 rf_tech_and_mode;",
          "302:  __u8 rf_interface_type;",
          "",
          "[Added Lines]",
          "316: struct nci_rf_intf_activated_ntf {",
          "317:  __u8 rf_discovery_id;",
          "318:  __u8 rf_interface_type;",
          "320:  __u8 activation_rf_tech_and_mode;",
          "327:  __u8 data_exch_rf_tech_and_mode;",
          "328:  __u8 data_exch_tx_bit_rate;",
          "329:  __u8 data_exch_rx_bit_rate;",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "309: } __packed;",
          "311: #define NCI_OP_RF_DEACTIVATE_NTF nci_opcode_pack(NCI_GID_RF_MGMT, 0x06)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "339: struct nci_rf_deactivate_ntf {",
          "340:  __u8 type;",
          "341:  __u8 reason;",
          "342: } __packed;",
          "",
          "---------------"
        ],
        "include/net/nfc/nci_core.h||include/net/nfc/nci_core.h": [
          "File: include/net/nfc/nci_core.h -> include/net/nfc/nci_core.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "109:     [NCI_MAX_SUPPORTED_RF_INTERFACES];",
          "110:  __u8   max_logical_connections;",
          "111:  __u16   max_routing_table_size;",
          "118:  __u8   max_pkt_payload_size;",
          "120:  __u8   conn_id;",
          "",
          "[Removed Lines]",
          "112:  __u8   max_control_packet_payload_length;",
          "113:  __u16   rf_sending_buffer_size;",
          "114:  __u16   rf_receiving_buffer_size;",
          "115:  __u16   manufacturer_id;",
          "119:  __u8   initial_num_credits;",
          "",
          "[Added Lines]",
          "112:  __u8   max_ctrl_pkt_payload_len;",
          "113:  __u16   max_size_for_large_params;",
          "114:  __u8   max_data_pkt_payload_size;",
          "115:  __u8   initial_num_credits;",
          "116:  __u8   manufact_id;",
          "117:  __u32   manufact_specific_info;",
          "",
          "---------------"
        ],
        "net/nfc/nci/core.c||net/nfc/nci/core.c": [
          "File: net/nfc/nci/core.c -> net/nfc/nci/core.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "126: static void nci_reset_req(struct nci_dev *ndev, unsigned long opt)",
          "127: {",
          "129: }",
          "131: static void nci_init_req(struct nci_dev *ndev, unsigned long opt)",
          "",
          "[Removed Lines]",
          "128:  nci_send_cmd(ndev, NCI_OP_CORE_RESET_CMD, 0, NULL);",
          "",
          "[Added Lines]",
          "128:  struct nci_core_reset_cmd cmd;",
          "130:  cmd.reset_type = NCI_RESET_TYPE_RESET_CONFIG;",
          "131:  nci_send_cmd(ndev, NCI_OP_CORE_RESET_CMD, 1, &cmd);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "469:  ndev->data_exchange_cb = cb;",
          "470:  ndev->data_exchange_cb_context = cb_context;",
          "473:  if (rc)",
          "474:   clear_bit(NCI_DATA_EXCHANGE, &ndev->flags);",
          "",
          "[Removed Lines]",
          "472:  rc = nci_send_data(ndev, ndev->conn_id, skb);",
          "",
          "[Added Lines]",
          "475:  rc = nci_send_data(ndev, NCI_STATIC_RF_CONN_ID, skb);",
          "",
          "---------------"
        ],
        "net/nfc/nci/data.c||net/nfc/nci/data.c": [
          "File: net/nfc/nci/data.c -> net/nfc/nci/data.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "95:  __skb_queue_head_init(&frags_q);",
          "97:  while (total_len) {",
          "100:   skb_frag = nci_skb_alloc(ndev,",
          "101:      (NCI_DATA_HDR_SIZE + frag_len),",
          "",
          "[Removed Lines]",
          "98:   frag_len = min_t(int, total_len, ndev->max_pkt_payload_size);",
          "",
          "[Added Lines]",
          "98:   frag_len =",
          "99:    min_t(int, total_len, ndev->max_data_pkt_payload_size);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "151:  nfc_dbg(\"entry, conn_id 0x%x, plen %d\", conn_id, skb->len);",
          "156:   nci_push_data_hdr(ndev, conn_id, skb, NCI_PBF_LAST);",
          "",
          "[Removed Lines]",
          "154:  if (skb->len <= ndev->max_pkt_payload_size) {",
          "",
          "[Added Lines]",
          "155:  if (skb->len <= ndev->max_data_pkt_payload_size) {",
          "",
          "---------------"
        ],
        "net/nfc/nci/lib.c||net/nfc/nci/lib.c": [
          "File: net/nfc/nci/lib.c -> net/nfc/nci/lib.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "42:  case NCI_STATUS_REJECTED:",
          "43:   return -EBUSY;",
          "46:   return -EBADMSG;",
          "51:  case NCI_STATUS_NOT_INITIALIZED:",
          "52:   return -EHOSTDOWN;",
          "",
          "[Removed Lines]",
          "45:  case NCI_STATUS_MESSAGE_CORRUPTED:",
          "48:  case NCI_STATUS_BUFFER_FULL:",
          "49:   return -ENOBUFS;",
          "",
          "[Added Lines]",
          "45:  case NCI_STATUS_RF_FRAME_CORRUPTED:",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "80:  case NCI_STATUS_NFCEE_TIMEOUT_ERROR:",
          "81:   return -ETIMEDOUT;",
          "86:  case NCI_STATUS_MAX_ACTIVE_NFCEE_INTERFACES_REACHED:",
          "87:   return -EDQUOT;",
          "",
          "[Removed Lines]",
          "83:  case NCI_STATUS_RF_LINK_LOSS_ERROR:",
          "84:   return -ENOLINK;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "net/nfc/nci/ntf.c||net/nfc/nci/ntf.c": [
          "File: net/nfc/nci/ntf.c -> net/nfc/nci/ntf.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "54:    ntf->conn_entries[i].conn_id,",
          "55:    ntf->conn_entries[i].credits);",
          "59:    atomic_add(ntf->conn_entries[i].credits,",
          "60:     &ndev->credits_cnt);",
          "",
          "[Removed Lines]",
          "57:   if (ntf->conn_entries[i].conn_id == ndev->conn_id) {",
          "",
          "[Added Lines]",
          "57:   if (ntf->conn_entries[i].conn_id == NCI_STATIC_RF_CONN_ID) {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "74:  nfc_dbg(\"entry, rf_field_status %d\", ntf->rf_field_status);",
          "75: }",
          "79: {",
          "80:  struct rf_tech_specific_params_nfca_poll *nfca_poll;",
          "83:  nfca_poll = &ntf->rf_tech_specific_params.nfca_poll;",
          "86:  nfca_poll->sens_res = __le16_to_cpu(*((__u16 *)data));",
          "87:  data += 2;",
          "",
          "[Removed Lines]",
          "77: static int nci_rf_activate_nfca_passive_poll(struct nci_dev *ndev,",
          "78:    struct nci_rf_activate_ntf *ntf, __u8 *data)",
          "81:  struct activation_params_nfca_poll_iso_dep *nfca_poll_iso_dep;",
          "84:  nfca_poll_iso_dep = &ntf->activation_params.nfca_poll_iso_dep;",
          "",
          "[Added Lines]",
          "77: static __u8 *nci_extract_rf_params_nfca_passive_poll(struct nci_dev *ndev,",
          "78:    struct nci_rf_intf_activated_ntf *ntf, __u8 *data)",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "100:  if (nfca_poll->sel_res_len != 0)",
          "101:   nfca_poll->sel_res = *data++;",
          "107:   nfca_poll->sel_res_len,",
          "117:     data,",
          "119:   }",
          "120:   break;",
          "126:  default:",
          "129:   return -EPROTO;",
          "130:  }",
          "",
          "[Removed Lines]",
          "103:  ntf->rf_interface_type = *data++;",
          "104:  ntf->activation_params_len = *data++;",
          "106:  nfc_dbg(\"sel_res_len %d, sel_res 0x%x, rf_interface_type %d, activation_params_len %d\",",
          "108:   nfca_poll->sel_res,",
          "109:   ntf->rf_interface_type,",
          "110:   ntf->activation_params_len);",
          "112:  switch (ntf->rf_interface_type) {",
          "113:  case NCI_RF_INTERFACE_ISO_DEP:",
          "114:   nfca_poll_iso_dep->rats_res_len = *data++;",
          "115:   if (nfca_poll_iso_dep->rats_res_len > 0) {",
          "116:    memcpy(nfca_poll_iso_dep->rats_res,",
          "118:     nfca_poll_iso_dep->rats_res_len);",
          "122:  case NCI_RF_INTERFACE_FRAME:",
          "124:   break;",
          "127:   nfc_err(\"unsupported rf_interface_type 0x%x\",",
          "128:    ntf->rf_interface_type);",
          "",
          "[Added Lines]",
          "101:  nfc_dbg(\"sel_res_len %d, sel_res 0x%x\",",
          "103:   nfca_poll->sel_res);",
          "105:  return data;",
          "106: }",
          "108: static int nci_extract_activation_params_iso_dep(struct nci_dev *ndev,",
          "109:    struct nci_rf_intf_activated_ntf *ntf, __u8 *data)",
          "110: {",
          "111:  struct activation_params_nfca_poll_iso_dep *nfca_poll;",
          "113:  switch (ntf->activation_rf_tech_and_mode) {",
          "114:  case NCI_NFC_A_PASSIVE_POLL_MODE:",
          "115:   nfca_poll = &ntf->activation_params.nfca_poll_iso_dep;",
          "116:   nfca_poll->rats_res_len = *data++;",
          "117:   if (nfca_poll->rats_res_len > 0) {",
          "118:    memcpy(nfca_poll->rats_res,",
          "120:     nfca_poll->rats_res_len);",
          "125:   nfc_err(\"unsupported activation_rf_tech_and_mode 0x%x\",",
          "126:    ntf->activation_rf_tech_and_mode);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "133: }",
          "135: static void nci_target_found(struct nci_dev *ndev,",
          "137: {",
          "138:  struct nfc_target nfc_tgt;",
          "",
          "[Removed Lines]",
          "136:     struct nci_rf_activate_ntf *ntf)",
          "",
          "[Added Lines]",
          "134:     struct nci_rf_intf_activated_ntf *ntf)",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "141:   nfc_tgt.supported_protocols = NFC_PROTO_MIFARE_MASK;",
          "143:   nfc_tgt.supported_protocols = NFC_PROTO_ISO14443_MASK;",
          "145:  nfc_tgt.sens_res = ntf->rf_tech_specific_params.nfca_poll.sens_res;",
          "146:  nfc_tgt.sel_res = ntf->rf_tech_specific_params.nfca_poll.sel_res;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "142:  else",
          "143:   nfc_tgt.supported_protocols = 0;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "158:  nfc_targets_found(ndev->nfc_dev, &nfc_tgt, 1);",
          "159: }",
          "163: {",
          "165:  __u8 *data = skb->data;",
          "168:  clear_bit(NCI_DISCOVERY, &ndev->flags);",
          "169:  set_bit(NCI_POLL_ACTIVE, &ndev->flags);",
          "172:  ntf.rf_protocol = *data++;",
          "174:  ntf.rf_tech_specific_params_len = *data++;",
          "180:   ntf.rf_tech_specific_params_len);",
          "192:  }",
          "195:   nci_target_found(ndev, &ntf);",
          "196: }",
          "198: static void nci_rf_deactivate_ntf_packet(struct nci_dev *ndev,",
          "199:      struct sk_buff *skb)",
          "200: {",
          "205:  clear_bit(NCI_POLL_ACTIVE, &ndev->flags);",
          "206:  ndev->target_active_prot = 0;",
          "",
          "[Removed Lines]",
          "161: static void nci_rf_activate_ntf_packet(struct nci_dev *ndev,",
          "162:      struct sk_buff *skb)",
          "164:  struct nci_rf_activate_ntf ntf;",
          "166:  int rc = -1;",
          "171:  ntf.target_handle = *data++;",
          "173:  ntf.rf_tech_and_mode = *data++;",
          "176:  nfc_dbg(\"target_handle %d, rf_protocol 0x%x, rf_tech_and_mode 0x%x, rf_tech_specific_params_len %d\",",
          "177:   ntf.target_handle,",
          "178:   ntf.rf_protocol,",
          "179:   ntf.rf_tech_and_mode,",
          "182:  switch (ntf.rf_tech_and_mode) {",
          "183:  case NCI_NFC_A_PASSIVE_POLL_MODE:",
          "184:   rc = nci_rf_activate_nfca_passive_poll(ndev, &ntf,",
          "185:    data);",
          "186:   break;",
          "188:  default:",
          "189:   nfc_err(\"unsupported rf_tech_and_mode 0x%x\",",
          "190:    ntf.rf_tech_and_mode);",
          "191:   return;",
          "194:  if (!rc)",
          "201:  __u8 type = skb->data[0];",
          "203:  nfc_dbg(\"entry, type 0x%x\", type);",
          "",
          "[Added Lines]",
          "161: static void nci_rf_intf_activated_ntf_packet(struct nci_dev *ndev,",
          "162:       struct sk_buff *skb)",
          "164:  struct nci_rf_intf_activated_ntf ntf;",
          "166:  int err = 0;",
          "171:  ntf.rf_discovery_id = *data++;",
          "172:  ntf.rf_interface_type = *data++;",
          "174:  ntf.activation_rf_tech_and_mode = *data++;",
          "177:  nfc_dbg(\"rf_discovery_id %d\", ntf.rf_discovery_id);",
          "178:  nfc_dbg(\"rf_interface_type 0x%x\", ntf.rf_interface_type);",
          "179:  nfc_dbg(\"rf_protocol 0x%x\", ntf.rf_protocol);",
          "180:  nfc_dbg(\"activation_rf_tech_and_mode 0x%x\",",
          "181:   ntf.activation_rf_tech_and_mode);",
          "182:  nfc_dbg(\"rf_tech_specific_params_len %d\",",
          "185:  if (ntf.rf_tech_specific_params_len > 0) {",
          "186:   switch (ntf.activation_rf_tech_and_mode) {",
          "187:   case NCI_NFC_A_PASSIVE_POLL_MODE:",
          "188:    data = nci_extract_rf_params_nfca_passive_poll(ndev,",
          "189:     &ntf, data);",
          "190:    break;",
          "192:   default:",
          "193:    nfc_err(\"unsupported activation_rf_tech_and_mode 0x%x\",",
          "194:     ntf.activation_rf_tech_and_mode);",
          "195:    return;",
          "196:   }",
          "197:  }",
          "199:  ntf.data_exch_rf_tech_and_mode = *data++;",
          "200:  ntf.data_exch_tx_bit_rate = *data++;",
          "201:  ntf.data_exch_rx_bit_rate = *data++;",
          "202:  ntf.activation_params_len = *data++;",
          "204:  nfc_dbg(\"data_exch_rf_tech_and_mode 0x%x\",",
          "205:   ntf.data_exch_rf_tech_and_mode);",
          "206:  nfc_dbg(\"data_exch_tx_bit_rate 0x%x\",",
          "207:   ntf.data_exch_tx_bit_rate);",
          "208:  nfc_dbg(\"data_exch_rx_bit_rate 0x%x\",",
          "209:   ntf.data_exch_rx_bit_rate);",
          "210:  nfc_dbg(\"activation_params_len %d\",",
          "211:   ntf.activation_params_len);",
          "213:  if (ntf.activation_params_len > 0) {",
          "214:   switch (ntf.rf_interface_type) {",
          "215:   case NCI_RF_INTERFACE_ISO_DEP:",
          "216:    err = nci_extract_activation_params_iso_dep(ndev,",
          "217:     &ntf, data);",
          "218:    break;",
          "220:   case NCI_RF_INTERFACE_FRAME:",
          "222:    break;",
          "224:   default:",
          "225:    nfc_err(\"unsupported rf_interface_type 0x%x\",",
          "226:     ntf.rf_interface_type);",
          "227:    return;",
          "228:   }",
          "231:  if (!err)",
          "238:  struct nci_rf_deactivate_ntf *ntf = (void *) skb->data;",
          "240:  nfc_dbg(\"entry, type 0x%x, reason 0x%x\", ntf->type, ntf->reason);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "241:   nci_rf_field_info_ntf_packet(ndev, skb);",
          "242:   break;",
          "246:   break;",
          "248:  case NCI_OP_RF_DEACTIVATE_NTF:",
          "",
          "[Removed Lines]",
          "244:  case NCI_OP_RF_ACTIVATE_NTF:",
          "245:   nci_rf_activate_ntf_packet(ndev, skb);",
          "",
          "[Added Lines]",
          "281:  case NCI_OP_RF_INTF_ACTIVATED_NTF:",
          "282:   nci_rf_intf_activated_ntf_packet(ndev, skb);",
          "",
          "---------------"
        ],
        "net/nfc/nci/rsp.c||net/nfc/nci/rsp.c": [
          "File: net/nfc/nci/rsp.c -> net/nfc/nci/rsp.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "43:  nfc_dbg(\"entry, status 0x%x\", rsp->status);",
          "46:   ndev->nci_ver = rsp->nci_ver;",
          "50:  nci_req_complete(ndev, rsp->status);",
          "51: }",
          "",
          "[Removed Lines]",
          "45:  if (rsp->status == NCI_STATUS_OK)",
          "48:  nfc_dbg(\"nci_ver 0x%x\", ndev->nci_ver);",
          "",
          "[Added Lines]",
          "45:  if (rsp->status == NCI_STATUS_OK) {",
          "47:   nfc_dbg(\"nci_ver 0x%x, config_status 0x%x\",",
          "48:    rsp->nci_ver, rsp->config_status);",
          "49:  }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "58:  nfc_dbg(\"entry, status 0x%x\", rsp_1->status);",
          "60:  if (rsp_1->status != NCI_STATUS_OK)",
          "63:  ndev->nfcc_features = __le32_to_cpu(rsp_1->nfcc_features);",
          "64:  ndev->num_supported_rf_interfaces = rsp_1->num_supported_rf_interfaces;",
          "66:  if (ndev->num_supported_rf_interfaces >",
          "68:   ndev->num_supported_rf_interfaces =",
          "69:    NCI_MAX_SUPPORTED_RF_INTERFACES;",
          "70:  }",
          "",
          "[Removed Lines]",
          "61:   return;",
          "67:   NCI_MAX_SUPPORTED_RF_INTERFACES) {",
          "",
          "[Added Lines]",
          "62:   goto exit;",
          "68:    NCI_MAX_SUPPORTED_RF_INTERFACES) {",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "73:   rsp_1->supported_rf_interfaces,",
          "74:   ndev->num_supported_rf_interfaces);",
          "78:  ndev->max_logical_connections =",
          "79:   rsp_2->max_logical_connections;",
          "80:  ndev->max_routing_table_size =",
          "81:   __le16_to_cpu(rsp_2->max_routing_table_size);",
          "91:  nfc_dbg(\"nfcc_features 0x%x\",",
          "92:   ndev->nfcc_features);",
          "",
          "[Removed Lines]",
          "76:  rsp_2 = (void *) (skb->data + 6 + ndev->num_supported_rf_interfaces);",
          "82:  ndev->max_control_packet_payload_length =",
          "83:   rsp_2->max_control_packet_payload_length;",
          "84:  ndev->rf_sending_buffer_size =",
          "85:   __le16_to_cpu(rsp_2->rf_sending_buffer_size);",
          "86:  ndev->rf_receiving_buffer_size =",
          "87:   __le16_to_cpu(rsp_2->rf_receiving_buffer_size);",
          "88:  ndev->manufacturer_id =",
          "89:   __le16_to_cpu(rsp_2->manufacturer_id);",
          "",
          "[Added Lines]",
          "77:  rsp_2 = (void *) (skb->data + 6 + rsp_1->num_supported_rf_interfaces);",
          "83:  ndev->max_ctrl_pkt_payload_len =",
          "84:   rsp_2->max_ctrl_pkt_payload_len;",
          "85:  ndev->max_size_for_large_params =",
          "86:   __le16_to_cpu(rsp_2->max_size_for_large_params);",
          "87:  ndev->max_data_pkt_payload_size =",
          "88:   rsp_2->max_data_pkt_payload_size;",
          "89:  ndev->initial_num_credits =",
          "90:   rsp_2->initial_num_credits;",
          "91:  ndev->manufact_id =",
          "92:   rsp_2->manufact_id;",
          "93:  ndev->manufact_specific_info =",
          "94:   __le32_to_cpu(rsp_2->manufact_specific_info);",
          "96:  atomic_set(&ndev->credits_cnt, ndev->initial_num_credits);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "104:   ndev->max_logical_connections);",
          "105:  nfc_dbg(\"max_routing_table_size %d\",",
          "106:   ndev->max_routing_table_size);",
          "116:  nci_req_complete(ndev, rsp_1->status);",
          "117: }",
          "",
          "[Removed Lines]",
          "107:  nfc_dbg(\"max_control_packet_payload_length %d\",",
          "108:   ndev->max_control_packet_payload_length);",
          "109:  nfc_dbg(\"rf_sending_buffer_size %d\",",
          "110:   ndev->rf_sending_buffer_size);",
          "111:  nfc_dbg(\"rf_receiving_buffer_size %d\",",
          "112:   ndev->rf_receiving_buffer_size);",
          "113:  nfc_dbg(\"manufacturer_id 0x%x\",",
          "114:   ndev->manufacturer_id);",
          "",
          "[Added Lines]",
          "114:  nfc_dbg(\"max_ctrl_pkt_payload_len %d\",",
          "115:   ndev->max_ctrl_pkt_payload_len);",
          "116:  nfc_dbg(\"max_size_for_large_params %d\",",
          "117:   ndev->max_size_for_large_params);",
          "118:  nfc_dbg(\"max_data_pkt_payload_size %d\",",
          "119:   ndev->max_data_pkt_payload_size);",
          "120:  nfc_dbg(\"initial_num_credits %d\",",
          "121:   ndev->initial_num_credits);",
          "122:  nfc_dbg(\"manufact_id 0x%x\",",
          "123:   ndev->manufact_id);",
          "124:  nfc_dbg(\"manufact_specific_info 0x%x\",",
          "125:   ndev->manufact_specific_info);",
          "127: exit:",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "6a2968aaf50c7a22fced77a5e24aa636281efca8",
      "candidate_info": {
        "commit_hash": "6a2968aaf50c7a22fced77a5e24aa636281efca8",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/6a2968aaf50c7a22fced77a5e24aa636281efca8",
        "files": [
          "include/net/nfc/nci.h",
          "include/net/nfc/nci_core.h",
          "net/nfc/Kconfig",
          "net/nfc/Makefile",
          "net/nfc/nci/Kconfig",
          "net/nfc/nci/Makefile",
          "net/nfc/nci/core.c",
          "net/nfc/nci/data.c",
          "net/nfc/nci/lib.c",
          "net/nfc/nci/ntf.c",
          "net/nfc/nci/rsp.c"
        ],
        "message": "NFC: basic NCI protocol implementation\n\nThe NFC Controller Interface (NCI) is a standard\ncommunication protocol between an NFC Controller (NFCC)\nand a Device Host (DH), defined by the NFC Forum.\n\nSigned-off-by: Ilan Elias <ilane@ti.com>\nSigned-off-by: John W. Linville <linville@tuxdriver.com>",
        "before_after_code_files": [
          "include/net/nfc/nci.h||include/net/nfc/nci.h",
          "include/net/nfc/nci_core.h||include/net/nfc/nci_core.h",
          "net/nfc/nci/core.c||net/nfc/nci/core.c",
          "net/nfc/nci/data.c||net/nfc/nci/data.c",
          "net/nfc/nci/lib.c||net/nfc/nci/lib.c",
          "net/nfc/nci/ntf.c||net/nfc/nci/ntf.c",
          "net/nfc/nci/rsp.c||net/nfc/nci/rsp.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "net/nfc/nci/ntf.c||net/nfc/nci/ntf.c"
          ],
          "candidate": [
            "net/nfc/nci/ntf.c||net/nfc/nci/ntf.c"
          ]
        }
      },
      "candidate_diff": {
        "include/net/nfc/nci.h||include/net/nfc/nci.h": [
          "File: include/net/nfc/nci.h -> include/net/nfc/nci.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "28: #ifndef __NCI_H",
          "29: #define __NCI_H",
          "32: #define NCI_MAX_NUM_MAPPING_CONFIGS    10",
          "33: #define NCI_MAX_NUM_RF_CONFIGS     10",
          "34: #define NCI_MAX_NUM_CONN     10",
          "37: #define NCI_STATUS_OK      0x00",
          "38: #define NCI_STATUS_REJECTED     0x01",
          "39: #define NCI_STATUS_MESSAGE_CORRUPTED    0x02",
          "40: #define NCI_STATUS_BUFFER_FULL     0x03",
          "41: #define NCI_STATUS_FAILED     0x04",
          "42: #define NCI_STATUS_NOT_INITIALIZED    0x05",
          "43: #define NCI_STATUS_SYNTAX_ERROR     0x06",
          "44: #define NCI_STATUS_SEMANTIC_ERROR    0x07",
          "45: #define NCI_STATUS_UNKNOWN_GID     0x08",
          "46: #define NCI_STATUS_UNKNOWN_OID     0x09",
          "47: #define NCI_STATUS_INVALID_PARAM    0x0a",
          "48: #define NCI_STATUS_MESSAGE_SIZE_EXCEEDED   0x0b",
          "50: #define NCI_STATUS_DISCOVERY_ALREADY_STARTED   0xa0",
          "51: #define NCI_STATUS_DISCOVERY_TARGET_ACTIVATION_FAILED  0xa1",
          "53: #define NCI_STATUS_RF_TRANSMISSION_ERROR   0xb0",
          "54: #define NCI_STATUS_RF_PROTOCOL_ERROR    0xb1",
          "55: #define NCI_STATUS_RF_TIMEOUT_ERROR    0xb2",
          "56: #define NCI_STATUS_RF_LINK_LOSS_ERROR    0xb3",
          "58: #define NCI_STATUS_MAX_ACTIVE_NFCEE_INTERFACES_REACHED  0xc0",
          "59: #define NCI_STATUS_NFCEE_INTERFACE_ACTIVATION_FAILED  0xc1",
          "60: #define NCI_STATUS_NFCEE_TRANSMISSION_ERROR   0xc2",
          "61: #define NCI_STATUS_NFCEE_PROTOCOL_ERROR    0xc3",
          "62: #define NCI_STATUS_NFCEE_TIMEOUT_ERROR    0xc4",
          "65: #define NCI_NFC_A_PASSIVE_POLL_MODE    0x00",
          "66: #define NCI_NFC_B_PASSIVE_POLL_MODE    0x01",
          "67: #define NCI_NFC_F_PASSIVE_POLL_MODE    0x02",
          "68: #define NCI_NFC_A_ACTIVE_POLL_MODE    0x03",
          "69: #define NCI_NFC_F_ACTIVE_POLL_MODE    0x05",
          "70: #define NCI_NFC_A_PASSIVE_LISTEN_MODE    0x80",
          "71: #define NCI_NFC_B_PASSIVE_LISTEN_MODE    0x81",
          "72: #define NCI_NFC_F_PASSIVE_LISTEN_MODE    0x82",
          "73: #define NCI_NFC_A_ACTIVE_LISTEN_MODE    0x83",
          "74: #define NCI_NFC_F_ACTIVE_LISTEN_MODE    0x85",
          "77: #define NCI_RF_PROTOCOL_UNKNOWN     0x00",
          "78: #define NCI_RF_PROTOCOL_T1T     0x01",
          "79: #define NCI_RF_PROTOCOL_T2T     0x02",
          "80: #define NCI_RF_PROTOCOL_T3T     0x03",
          "81: #define NCI_RF_PROTOCOL_ISO_DEP     0x04",
          "82: #define NCI_RF_PROTOCOL_NFC_DEP     0x05",
          "85: #define NCI_RF_INTERFACE_RFU     0x00",
          "86: #define NCI_RF_INTERFACE_FRAME     0x01",
          "87: #define NCI_RF_INTERFACE_ISO_DEP    0x02",
          "88: #define NCI_RF_INTERFACE_NFC_DEP    0x03",
          "91: #define NCI_DISC_MAP_MODE_POLL     0x01",
          "92: #define NCI_DISC_MAP_MODE_LISTEN    0x02",
          "93: #define NCI_DISC_MAP_MODE_BOTH     0x03",
          "96: #define NCI_DISCOVERY_TYPE_POLL_A_PASSIVE   0x00",
          "97: #define NCI_DISCOVERY_TYPE_POLL_B_PASSIVE   0x01",
          "98: #define NCI_DISCOVERY_TYPE_POLL_F_PASSIVE   0x02",
          "99: #define NCI_DISCOVERY_TYPE_POLL_A_ACTIVE   0x03",
          "100: #define NCI_DISCOVERY_TYPE_POLL_F_ACTIVE   0x05",
          "101: #define NCI_DISCOVERY_TYPE_WAKEUP_A_PASSIVE   0x06",
          "102: #define NCI_DISCOVERY_TYPE_WAKEUP_B_PASSIVE   0x07",
          "103: #define NCI_DISCOVERY_TYPE_WAKEUP_A_ACTIVE   0x09",
          "104: #define NCI_DISCOVERY_TYPE_LISTEN_A_PASSIVE   0x80",
          "105: #define NCI_DISCOVERY_TYPE_LISTEN_B_PASSIVE   0x81",
          "106: #define NCI_DISCOVERY_TYPE_LISTEN_F_PASSIVE   0x82",
          "107: #define NCI_DISCOVERY_TYPE_LISTEN_A_ACTIVE   0x83",
          "108: #define NCI_DISCOVERY_TYPE_LISTEN_F_ACTIVE   0x85",
          "111: #define NCI_DEACTIVATE_TYPE_IDLE_MODE    0x00",
          "112: #define NCI_DEACTIVATE_TYPE_SLEEP_MODE    0x01",
          "113: #define NCI_DEACTIVATE_TYPE_SLEEP_AF_MODE   0x02",
          "114: #define NCI_DEACTIVATE_TYPE_RF_LINK_LOSS   0x03",
          "115: #define NCI_DEACTIVATE_TYPE_DISCOVERY_ERROR   0x04",
          "118: #define NCI_MT_DATA_PKT      0x00",
          "119: #define NCI_MT_CMD_PKT      0x01",
          "120: #define NCI_MT_RSP_PKT      0x02",
          "121: #define NCI_MT_NTF_PKT      0x03",
          "123: #define nci_mt(hdr)   (((hdr)[0]>>5)&0x07)",
          "124: #define nci_mt_set(hdr, mt)  ((hdr)[0] |= (__u8)(((mt)&0x07)<<5))",
          "127: #define NCI_PBF_LAST      0x00",
          "128: #define NCI_PBF_CONT      0x01",
          "130: #define nci_pbf(hdr)   (__u8)(((hdr)[0]>>4)&0x01)",
          "131: #define nci_pbf_set(hdr, pbf)  ((hdr)[0] |= (__u8)(((pbf)&0x01)<<4))",
          "134: #define nci_opcode_pack(gid, oid) (__u16)((((__u16)((gid)&0x0f))<<8)|\\",
          "135:      ((__u16)((oid)&0x3f)))",
          "136: #define nci_opcode(hdr)   nci_opcode_pack(hdr[0], hdr[1])",
          "137: #define nci_opcode_gid(op)  (__u8)(((op)&0x0f00)>>8)",
          "138: #define nci_opcode_oid(op)  (__u8)((op)&0x003f)",
          "141: #define nci_plen(hdr)   (__u8)((hdr)[2])",
          "144: #define nci_conn_id(hdr)  (__u8)(((hdr)[0])&0x0f)",
          "147: #define NCI_GID_CORE      0x0",
          "148: #define NCI_GID_RF_MGMT      0x1",
          "149: #define NCI_GID_NFCEE_MGMT     0x2",
          "150: #define NCI_GID_PROPRIETARY     0xf",
          "153: #define NCI_CTRL_HDR_SIZE     3",
          "154: #define NCI_DATA_HDR_SIZE     3",
          "156: struct nci_ctrl_hdr {",
          "158:  __u8 oid;",
          "159:  __u8 plen;",
          "160: } __packed;",
          "162: struct nci_data_hdr {",
          "164:  __u8 rfu;",
          "165:  __u8 plen;",
          "166: } __packed;",
          "171: #define NCI_OP_CORE_RESET_CMD  nci_opcode_pack(NCI_GID_CORE, 0x00)",
          "173: #define NCI_OP_CORE_INIT_CMD  nci_opcode_pack(NCI_GID_CORE, 0x01)",
          "175: #define NCI_OP_CORE_SET_CONFIG_CMD nci_opcode_pack(NCI_GID_CORE, 0x02)",
          "177: #define NCI_OP_CORE_CONN_CREATE_CMD nci_opcode_pack(NCI_GID_CORE, 0x04)",
          "178: struct nci_core_conn_create_cmd {",
          "179:  __u8 target_handle;",
          "180:  __u8 num_target_specific_params;",
          "181: } __packed;",
          "183: #define NCI_OP_CORE_CONN_CLOSE_CMD nci_opcode_pack(NCI_GID_CORE, 0x06)",
          "185: #define NCI_OP_RF_DISCOVER_MAP_CMD nci_opcode_pack(NCI_GID_RF_MGMT, 0x00)",
          "186: struct disc_map_config {",
          "187:  __u8 rf_protocol;",
          "188:  __u8 mode;",
          "189:  __u8 rf_interface_type;",
          "190: } __packed;",
          "192: struct nci_rf_disc_map_cmd {",
          "193:  __u8    num_mapping_configs;",
          "194:  struct disc_map_config  mapping_configs",
          "195:      [NCI_MAX_NUM_MAPPING_CONFIGS];",
          "196: } __packed;",
          "198: #define NCI_OP_RF_DISCOVER_CMD  nci_opcode_pack(NCI_GID_RF_MGMT, 0x03)",
          "199: struct disc_config {",
          "200:  __u8 type;",
          "201:  __u8 frequency;",
          "202: } __packed;",
          "204: struct nci_rf_disc_cmd {",
          "205:  __u8    num_disc_configs;",
          "206:  struct disc_config  disc_configs[NCI_MAX_NUM_RF_CONFIGS];",
          "207: } __packed;",
          "209: #define NCI_OP_RF_DEACTIVATE_CMD nci_opcode_pack(NCI_GID_RF_MGMT, 0x06)",
          "210: struct nci_rf_deactivate_cmd {",
          "211:  __u8 type;",
          "212: } __packed;",
          "217: #define NCI_OP_CORE_RESET_RSP  nci_opcode_pack(NCI_GID_CORE, 0x00)",
          "218: struct nci_core_reset_rsp {",
          "219:  __u8 status;",
          "220:  __u8 nci_ver;",
          "221: } __packed;",
          "223: #define NCI_OP_CORE_INIT_RSP  nci_opcode_pack(NCI_GID_CORE, 0x01)",
          "224: struct nci_core_init_rsp_1 {",
          "225:  __u8 status;",
          "226:  __le32 nfcc_features;",
          "227:  __u8 num_supported_rf_interfaces;",
          "230: } __packed;",
          "232: struct nci_core_init_rsp_2 {",
          "233:  __u8 max_logical_connections;",
          "234:  __le16 max_routing_table_size;",
          "235:  __u8 max_control_packet_payload_length;",
          "236:  __le16 rf_sending_buffer_size;",
          "237:  __le16 rf_receiving_buffer_size;",
          "238:  __le16 manufacturer_id;",
          "239: } __packed;",
          "241: #define NCI_OP_CORE_SET_CONFIG_RSP nci_opcode_pack(NCI_GID_CORE, 0x02)",
          "243: #define NCI_OP_CORE_CONN_CREATE_RSP nci_opcode_pack(NCI_GID_CORE, 0x04)",
          "244: struct nci_core_conn_create_rsp {",
          "245:  __u8 status;",
          "246:  __u8 max_pkt_payload_size;",
          "247:  __u8 initial_num_credits;",
          "248:  __u8 conn_id;",
          "249: } __packed;",
          "251: #define NCI_OP_CORE_CONN_CLOSE_RSP nci_opcode_pack(NCI_GID_CORE, 0x06)",
          "253: #define NCI_OP_RF_DISCOVER_MAP_RSP nci_opcode_pack(NCI_GID_RF_MGMT, 0x00)",
          "255: #define NCI_OP_RF_DISCOVER_RSP  nci_opcode_pack(NCI_GID_RF_MGMT, 0x03)",
          "257: #define NCI_OP_RF_DEACTIVATE_RSP nci_opcode_pack(NCI_GID_RF_MGMT, 0x06)",
          "262: #define NCI_OP_CORE_CONN_CREDITS_NTF nci_opcode_pack(NCI_GID_CORE, 0x07)",
          "263: struct conn_credit_entry {",
          "264:  __u8 conn_id;",
          "265:  __u8 credits;",
          "266: } __packed;",
          "268: struct nci_core_conn_credit_ntf {",
          "269:  __u8    num_entries;",
          "270:  struct conn_credit_entry conn_entries[NCI_MAX_NUM_CONN];",
          "271: } __packed;",
          "273: #define NCI_OP_RF_FIELD_INFO_NTF nci_opcode_pack(NCI_GID_CORE, 0x08)",
          "274: struct nci_rf_field_info_ntf {",
          "275:  __u8 rf_field_status;",
          "276: } __packed;",
          "278: #define NCI_OP_RF_ACTIVATE_NTF  nci_opcode_pack(NCI_GID_RF_MGMT, 0x05)",
          "279: struct rf_tech_specific_params_nfca_poll {",
          "280:  __u16 sens_res;",
          "282:  __u8 nfcid1[10];",
          "284:  __u8 sel_res;",
          "285: } __packed;",
          "287: struct activation_params_nfca_poll_iso_dep {",
          "288:  __u8 rats_res_len;",
          "289:  __u8 rats_res[20];",
          "290: };",
          "292: struct nci_rf_activate_ntf {",
          "293:  __u8 target_handle;",
          "294:  __u8 rf_protocol;",
          "295:  __u8 rf_tech_and_mode;",
          "296:  __u8 rf_tech_specific_params_len;",
          "298:  union {",
          "299:   struct rf_tech_specific_params_nfca_poll nfca_poll;",
          "300:  } rf_tech_specific_params;",
          "302:  __u8 rf_interface_type;",
          "303:  __u8 activation_params_len;",
          "305:  union {",
          "306:   struct activation_params_nfca_poll_iso_dep nfca_poll_iso_dep;",
          "307:  } activation_params;",
          "309: } __packed;",
          "311: #define NCI_OP_RF_DEACTIVATE_NTF nci_opcode_pack(NCI_GID_RF_MGMT, 0x06)",
          "",
          "---------------"
        ],
        "include/net/nfc/nci_core.h||include/net/nfc/nci_core.h": [
          "File: include/net/nfc/nci_core.h -> include/net/nfc/nci_core.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "28: #ifndef __NCI_CORE_H",
          "29: #define __NCI_CORE_H",
          "31: #include <linux/interrupt.h>",
          "32: #include <linux/skbuff.h>",
          "34: #include <net/nfc/nfc.h>",
          "35: #include <net/nfc/nci.h>",
          "38: enum {",
          "39:  NCI_INIT,",
          "40:  NCI_UP,",
          "41:  NCI_DISCOVERY,",
          "42:  NCI_POLL_ACTIVE,",
          "43: };",
          "46: #define NCI_RESET_TIMEOUT   5000",
          "47: #define NCI_INIT_TIMEOUT   5000",
          "48: #define NCI_RF_DISC_TIMEOUT   5000",
          "49: #define NCI_RF_DEACTIVATE_TIMEOUT  5000",
          "50: #define NCI_CMD_TIMEOUT    5000",
          "52: struct nci_dev;",
          "54: struct nci_ops {",
          "55:  int (*open)(struct nci_dev *ndev);",
          "56:  int (*close)(struct nci_dev *ndev);",
          "57:  int (*send)(struct sk_buff *skb);",
          "58: };",
          "60: #define NCI_MAX_SUPPORTED_RF_INTERFACES  4",
          "63: struct nci_dev {",
          "64:  struct nfc_dev  *nfc_dev;",
          "65:  struct nci_ops  *ops;",
          "67:  int   tx_headroom;",
          "68:  int   tx_tailroom;",
          "70:  unsigned long  flags;",
          "72:  atomic_t  cmd_cnt;",
          "73:  atomic_t  credits_cnt;",
          "75:  struct timer_list cmd_timer;",
          "77:  struct workqueue_struct *cmd_wq;",
          "78:  struct work_struct cmd_work;",
          "80:  struct workqueue_struct *rx_wq;",
          "81:  struct work_struct rx_work;",
          "83:  struct workqueue_struct *tx_wq;",
          "84:  struct work_struct tx_work;",
          "86:  struct sk_buff_head cmd_q;",
          "87:  struct sk_buff_head rx_q;",
          "88:  struct sk_buff_head tx_q;",
          "90:  struct mutex  req_lock;",
          "91:  struct completion req_completion;",
          "92:  __u32   req_status;",
          "93:  __u32   req_result;",
          "95:  void   *driver_data;",
          "97:  __u32   poll_prots;",
          "98:  __u32   target_available_prots;",
          "99:  __u32   target_active_prot;",
          "102:  __u8   nci_ver;",
          "105:  __u32   nfcc_features;",
          "106:  __u8   num_supported_rf_interfaces;",
          "107:  __u8   supported_rf_interfaces",
          "108:     [NCI_MAX_SUPPORTED_RF_INTERFACES];",
          "109:  __u8   max_logical_connections;",
          "110:  __u16   max_routing_table_size;",
          "111:  __u8   max_control_packet_payload_length;",
          "112:  __u16   rf_sending_buffer_size;",
          "113:  __u16   rf_receiving_buffer_size;",
          "114:  __u16   manufacturer_id;",
          "117:  __u8   max_pkt_payload_size;",
          "118:  __u8   initial_num_credits;",
          "119:  __u8   conn_id;",
          "122:  data_exchange_cb_t data_exchange_cb;",
          "123:  void   *data_exchange_cb_context;",
          "124:  struct sk_buff  *rx_data_reassembly;",
          "125: };",
          "128: struct nci_dev *nci_allocate_device(struct nci_ops *ops,",
          "129:     __u32 supported_protocols,",
          "130:     int tx_headroom,",
          "131:     int tx_tailroom);",
          "132: void nci_free_device(struct nci_dev *ndev);",
          "133: int nci_register_device(struct nci_dev *ndev);",
          "134: void nci_unregister_device(struct nci_dev *ndev);",
          "135: int nci_recv_frame(struct sk_buff *skb);",
          "137: static inline struct sk_buff *nci_skb_alloc(struct nci_dev *ndev,",
          "138:       unsigned int len,",
          "139:       gfp_t how)",
          "140: {",
          "141:  struct sk_buff *skb;",
          "143:  skb = alloc_skb(len + ndev->tx_headroom + ndev->tx_tailroom, how);",
          "144:  if (skb)",
          "145:   skb_reserve(skb, ndev->tx_headroom);",
          "147:  return skb;",
          "148: }",
          "150: static inline void nci_set_parent_dev(struct nci_dev *ndev, struct device *dev)",
          "151: {",
          "152:  nfc_set_parent_dev(ndev->nfc_dev, dev);",
          "153: }",
          "155: static inline void nci_set_drvdata(struct nci_dev *ndev, void *data)",
          "156: {",
          "157:  ndev->driver_data = data;",
          "158: }",
          "160: static inline void *nci_get_drvdata(struct nci_dev *ndev)",
          "161: {",
          "162:  return ndev->driver_data;",
          "163: }",
          "165: void nci_rsp_packet(struct nci_dev *ndev, struct sk_buff *skb);",
          "166: void nci_ntf_packet(struct nci_dev *ndev, struct sk_buff *skb);",
          "167: void nci_rx_data_packet(struct nci_dev *ndev, struct sk_buff *skb);",
          "168: int nci_send_cmd(struct nci_dev *ndev, __u16 opcode, __u8 plen, void *payload);",
          "169: int nci_send_data(struct nci_dev *ndev, __u8 conn_id, struct sk_buff *skb);",
          "170: void nci_data_exchange_complete(struct nci_dev *ndev, struct sk_buff *skb,",
          "171:     int err);",
          "174: #define NCI_REQ_DONE  0",
          "175: #define NCI_REQ_PEND  1",
          "176: #define NCI_REQ_CANCELED 2",
          "178: void nci_req_complete(struct nci_dev *ndev, int result);",
          "181: int nci_to_errno(__u8 code);",
          "",
          "---------------"
        ],
        "net/nfc/nci/core.c||net/nfc/nci/core.c": [
          "File: net/nfc/nci/core.c -> net/nfc/nci/core.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "28: #include <linux/types.h>",
          "29: #include <linux/workqueue.h>",
          "30: #include <linux/completion.h>",
          "31: #include <linux/sched.h>",
          "32: #include <linux/bitops.h>",
          "33: #include <linux/skbuff.h>",
          "35: #include \"../nfc.h\"",
          "36: #include <net/nfc/nci.h>",
          "37: #include <net/nfc/nci_core.h>",
          "38: #include <linux/nfc.h>",
          "40: static void nci_cmd_work(struct work_struct *work);",
          "41: static void nci_rx_work(struct work_struct *work);",
          "42: static void nci_tx_work(struct work_struct *work);",
          "46: void nci_req_complete(struct nci_dev *ndev, int result)",
          "47: {",
          "48:  if (ndev->req_status == NCI_REQ_PEND) {",
          "49:   ndev->req_result = result;",
          "50:   ndev->req_status = NCI_REQ_DONE;",
          "51:   complete(&ndev->req_completion);",
          "52:  }",
          "53: }",
          "55: static void nci_req_cancel(struct nci_dev *ndev, int err)",
          "56: {",
          "57:  if (ndev->req_status == NCI_REQ_PEND) {",
          "58:   ndev->req_result = err;",
          "59:   ndev->req_status = NCI_REQ_CANCELED;",
          "60:   complete(&ndev->req_completion);",
          "61:  }",
          "62: }",
          "65: static int __nci_request(struct nci_dev *ndev,",
          "66:  void (*req)(struct nci_dev *ndev, unsigned long opt),",
          "67:  unsigned long opt,",
          "68:  __u32 timeout)",
          "69: {",
          "70:  int rc = 0;",
          "71:  unsigned long completion_rc;",
          "73:  ndev->req_status = NCI_REQ_PEND;",
          "75:  init_completion(&ndev->req_completion);",
          "76:  req(ndev, opt);",
          "77:  completion_rc = wait_for_completion_interruptible_timeout(",
          "78:        &ndev->req_completion,",
          "79:        timeout);",
          "81:  nfc_dbg(\"wait_for_completion return %ld\", completion_rc);",
          "83:  if (completion_rc > 0) {",
          "84:   switch (ndev->req_status) {",
          "85:   case NCI_REQ_DONE:",
          "86:    rc = nci_to_errno(ndev->req_result);",
          "87:    break;",
          "89:   case NCI_REQ_CANCELED:",
          "90:    rc = -ndev->req_result;",
          "91:    break;",
          "93:   default:",
          "94:    rc = -ETIMEDOUT;",
          "95:    break;",
          "96:   }",
          "97:  } else {",
          "98:   nfc_err(\"wait_for_completion_interruptible_timeout failed %ld\",",
          "99:    completion_rc);",
          "101:   rc = ((completion_rc == 0) ? (-ETIMEDOUT) : (completion_rc));",
          "102:  }",
          "104:  ndev->req_status = ndev->req_result = 0;",
          "106:  return rc;",
          "107: }",
          "109: static inline int nci_request(struct nci_dev *ndev,",
          "110:   void (*req)(struct nci_dev *ndev, unsigned long opt),",
          "111:   unsigned long opt, __u32 timeout)",
          "112: {",
          "113:  int rc;",
          "115:  if (!test_bit(NCI_UP, &ndev->flags))",
          "116:   return -ENETDOWN;",
          "119:  mutex_lock(&ndev->req_lock);",
          "120:  rc = __nci_request(ndev, req, opt, timeout);",
          "121:  mutex_unlock(&ndev->req_lock);",
          "123:  return rc;",
          "124: }",
          "126: static void nci_reset_req(struct nci_dev *ndev, unsigned long opt)",
          "127: {",
          "128:  nci_send_cmd(ndev, NCI_OP_CORE_RESET_CMD, 0, NULL);",
          "129: }",
          "131: static void nci_init_req(struct nci_dev *ndev, unsigned long opt)",
          "132: {",
          "133:  nci_send_cmd(ndev, NCI_OP_CORE_INIT_CMD, 0, NULL);",
          "134: }",
          "136: static void nci_init_complete_req(struct nci_dev *ndev, unsigned long opt)",
          "137: {",
          "138:  struct nci_rf_disc_map_cmd cmd;",
          "139:  struct nci_core_conn_create_cmd conn_cmd;",
          "140:  int i;",
          "143:  conn_cmd.target_handle = 0;",
          "144:  conn_cmd.num_target_specific_params = 0;",
          "145:  nci_send_cmd(ndev, NCI_OP_CORE_CONN_CREATE_CMD, 2, &conn_cmd);",
          "148:  cmd.num_mapping_configs = 0;",
          "151:  for (i = 0; i < ndev->num_supported_rf_interfaces; i++) {",
          "152:   if (ndev->supported_rf_interfaces[i] ==",
          "153:    NCI_RF_INTERFACE_ISO_DEP) {",
          "154:    cmd.mapping_configs[cmd.num_mapping_configs]",
          "155:    .rf_protocol = NCI_RF_PROTOCOL_ISO_DEP;",
          "156:    cmd.mapping_configs[cmd.num_mapping_configs]",
          "157:    .mode = NCI_DISC_MAP_MODE_BOTH;",
          "158:    cmd.mapping_configs[cmd.num_mapping_configs]",
          "159:    .rf_interface_type = NCI_RF_INTERFACE_ISO_DEP;",
          "160:    cmd.num_mapping_configs++;",
          "161:   } else if (ndev->supported_rf_interfaces[i] ==",
          "162:    NCI_RF_INTERFACE_NFC_DEP) {",
          "163:    cmd.mapping_configs[cmd.num_mapping_configs]",
          "164:    .rf_protocol = NCI_RF_PROTOCOL_NFC_DEP;",
          "165:    cmd.mapping_configs[cmd.num_mapping_configs]",
          "166:    .mode = NCI_DISC_MAP_MODE_BOTH;",
          "167:    cmd.mapping_configs[cmd.num_mapping_configs]",
          "168:    .rf_interface_type = NCI_RF_INTERFACE_NFC_DEP;",
          "169:    cmd.num_mapping_configs++;",
          "170:   }",
          "172:   if (cmd.num_mapping_configs == NCI_MAX_NUM_MAPPING_CONFIGS)",
          "173:    break;",
          "174:  }",
          "176:  nci_send_cmd(ndev, NCI_OP_RF_DISCOVER_MAP_CMD,",
          "177:   (1 + (cmd.num_mapping_configs*sizeof(struct disc_map_config))),",
          "178:   &cmd);",
          "179: }",
          "181: static void nci_rf_discover_req(struct nci_dev *ndev, unsigned long opt)",
          "182: {",
          "183:  struct nci_rf_disc_cmd cmd;",
          "184:  __u32 protocols = opt;",
          "186:  cmd.num_disc_configs = 0;",
          "188:  if ((cmd.num_disc_configs < NCI_MAX_NUM_RF_CONFIGS) &&",
          "189:   (protocols & NFC_PROTO_JEWEL_MASK",
          "190:   || protocols & NFC_PROTO_MIFARE_MASK",
          "191:   || protocols & NFC_PROTO_ISO14443_MASK",
          "192:   || protocols & NFC_PROTO_NFC_DEP_MASK)) {",
          "193:   cmd.disc_configs[cmd.num_disc_configs].type =",
          "194:   NCI_DISCOVERY_TYPE_POLL_A_PASSIVE;",
          "195:   cmd.disc_configs[cmd.num_disc_configs].frequency = 1;",
          "196:   cmd.num_disc_configs++;",
          "197:  }",
          "199:  if ((cmd.num_disc_configs < NCI_MAX_NUM_RF_CONFIGS) &&",
          "200:   (protocols & NFC_PROTO_ISO14443_MASK)) {",
          "201:   cmd.disc_configs[cmd.num_disc_configs].type =",
          "202:   NCI_DISCOVERY_TYPE_POLL_B_PASSIVE;",
          "203:   cmd.disc_configs[cmd.num_disc_configs].frequency = 1;",
          "204:   cmd.num_disc_configs++;",
          "205:  }",
          "207:  if ((cmd.num_disc_configs < NCI_MAX_NUM_RF_CONFIGS) &&",
          "208:   (protocols & NFC_PROTO_FELICA_MASK",
          "209:   || protocols & NFC_PROTO_NFC_DEP_MASK)) {",
          "210:   cmd.disc_configs[cmd.num_disc_configs].type =",
          "211:   NCI_DISCOVERY_TYPE_POLL_F_PASSIVE;",
          "212:   cmd.disc_configs[cmd.num_disc_configs].frequency = 1;",
          "213:   cmd.num_disc_configs++;",
          "214:  }",
          "216:  nci_send_cmd(ndev, NCI_OP_RF_DISCOVER_CMD,",
          "217:   (1 + (cmd.num_disc_configs*sizeof(struct disc_config))),",
          "218:   &cmd);",
          "219: }",
          "221: static void nci_rf_deactivate_req(struct nci_dev *ndev, unsigned long opt)",
          "222: {",
          "223:  struct nci_rf_deactivate_cmd cmd;",
          "225:  cmd.type = NCI_DEACTIVATE_TYPE_IDLE_MODE;",
          "227:  nci_send_cmd(ndev, NCI_OP_RF_DEACTIVATE_CMD,",
          "228:    sizeof(struct nci_rf_deactivate_cmd),",
          "229:    &cmd);",
          "230: }",
          "232: static int nci_open_device(struct nci_dev *ndev)",
          "233: {",
          "234:  int rc = 0;",
          "236:  mutex_lock(&ndev->req_lock);",
          "238:  if (test_bit(NCI_UP, &ndev->flags)) {",
          "239:   rc = -EALREADY;",
          "240:   goto done;",
          "241:  }",
          "243:  if (ndev->ops->open(ndev)) {",
          "244:   rc = -EIO;",
          "245:   goto done;",
          "246:  }",
          "248:  atomic_set(&ndev->cmd_cnt, 1);",
          "250:  set_bit(NCI_INIT, &ndev->flags);",
          "252:  rc = __nci_request(ndev, nci_reset_req, 0,",
          "253:     msecs_to_jiffies(NCI_RESET_TIMEOUT));",
          "255:  if (!rc) {",
          "256:   rc = __nci_request(ndev, nci_init_req, 0,",
          "257:     msecs_to_jiffies(NCI_INIT_TIMEOUT));",
          "258:  }",
          "260:  if (!rc) {",
          "261:   rc = __nci_request(ndev, nci_init_complete_req, 0,",
          "262:     msecs_to_jiffies(NCI_INIT_TIMEOUT));",
          "263:  }",
          "265:  clear_bit(NCI_INIT, &ndev->flags);",
          "267:  if (!rc) {",
          "268:   set_bit(NCI_UP, &ndev->flags);",
          "269:  } else {",
          "271:   skb_queue_purge(&ndev->cmd_q);",
          "272:   skb_queue_purge(&ndev->rx_q);",
          "273:   skb_queue_purge(&ndev->tx_q);",
          "275:   ndev->ops->close(ndev);",
          "276:   ndev->flags = 0;",
          "277:  }",
          "279: done:",
          "280:  mutex_unlock(&ndev->req_lock);",
          "281:  return rc;",
          "282: }",
          "284: static int nci_close_device(struct nci_dev *ndev)",
          "285: {",
          "286:  nci_req_cancel(ndev, ENODEV);",
          "287:  mutex_lock(&ndev->req_lock);",
          "289:  if (!test_and_clear_bit(NCI_UP, &ndev->flags)) {",
          "290:   del_timer_sync(&ndev->cmd_timer);",
          "291:   mutex_unlock(&ndev->req_lock);",
          "292:   return 0;",
          "293:  }",
          "296:  skb_queue_purge(&ndev->rx_q);",
          "297:  skb_queue_purge(&ndev->tx_q);",
          "300:  flush_workqueue(ndev->rx_wq);",
          "301:  flush_workqueue(ndev->tx_wq);",
          "304:  skb_queue_purge(&ndev->cmd_q);",
          "305:  atomic_set(&ndev->cmd_cnt, 1);",
          "307:  set_bit(NCI_INIT, &ndev->flags);",
          "308:  __nci_request(ndev, nci_reset_req, 0,",
          "309:     msecs_to_jiffies(NCI_RESET_TIMEOUT));",
          "310:  clear_bit(NCI_INIT, &ndev->flags);",
          "313:  flush_workqueue(ndev->cmd_wq);",
          "317:  ndev->ops->close(ndev);",
          "320:  ndev->flags = 0;",
          "322:  mutex_unlock(&ndev->req_lock);",
          "324:  return 0;",
          "325: }",
          "328: static void nci_cmd_timer(unsigned long arg)",
          "329: {",
          "330:  struct nci_dev *ndev = (void *) arg;",
          "332:  nfc_dbg(\"entry\");",
          "334:  atomic_set(&ndev->cmd_cnt, 1);",
          "335:  queue_work(ndev->cmd_wq, &ndev->cmd_work);",
          "336: }",
          "338: static int nci_dev_up(struct nfc_dev *nfc_dev)",
          "339: {",
          "340:  struct nci_dev *ndev = nfc_get_drvdata(nfc_dev);",
          "342:  nfc_dbg(\"entry\");",
          "344:  return nci_open_device(ndev);",
          "345: }",
          "347: static int nci_dev_down(struct nfc_dev *nfc_dev)",
          "348: {",
          "349:  struct nci_dev *ndev = nfc_get_drvdata(nfc_dev);",
          "351:  nfc_dbg(\"entry\");",
          "353:  return nci_close_device(ndev);",
          "354: }",
          "356: static int nci_start_poll(struct nfc_dev *nfc_dev, __u32 protocols)",
          "357: {",
          "358:  struct nci_dev *ndev = nfc_get_drvdata(nfc_dev);",
          "359:  int rc;",
          "361:  nfc_dbg(\"entry\");",
          "363:  if (test_bit(NCI_DISCOVERY, &ndev->flags)) {",
          "364:   nfc_err(\"unable to start poll, since poll is already active\");",
          "365:   return -EBUSY;",
          "366:  }",
          "368:  if (test_bit(NCI_POLL_ACTIVE, &ndev->flags)) {",
          "369:   nfc_dbg(\"target already active, first deactivate...\");",
          "371:   rc = nci_request(ndev, nci_rf_deactivate_req, 0,",
          "372:    msecs_to_jiffies(NCI_RF_DEACTIVATE_TIMEOUT));",
          "373:   if (rc)",
          "374:    return -EBUSY;",
          "375:  }",
          "377:  rc = nci_request(ndev, nci_rf_discover_req, protocols,",
          "378:   msecs_to_jiffies(NCI_RF_DISC_TIMEOUT));",
          "380:  if (!rc)",
          "381:   ndev->poll_prots = protocols;",
          "383:  return rc;",
          "384: }",
          "386: static void nci_stop_poll(struct nfc_dev *nfc_dev)",
          "387: {",
          "388:  struct nci_dev *ndev = nfc_get_drvdata(nfc_dev);",
          "390:  nfc_dbg(\"entry\");",
          "392:  if (!test_bit(NCI_DISCOVERY, &ndev->flags)) {",
          "393:   nfc_err(\"unable to stop poll, since poll is not active\");",
          "394:   return;",
          "395:  }",
          "397:  nci_request(ndev, nci_rf_deactivate_req, 0,",
          "398:   msecs_to_jiffies(NCI_RF_DEACTIVATE_TIMEOUT));",
          "399: }",
          "401: static int nci_activate_target(struct nfc_dev *nfc_dev, __u32 target_idx,",
          "402:     __u32 protocol)",
          "403: {",
          "404:  struct nci_dev *ndev = nfc_get_drvdata(nfc_dev);",
          "406:  nfc_dbg(\"entry, target_idx %d, protocol 0x%x\", target_idx, protocol);",
          "408:  if (!test_bit(NCI_POLL_ACTIVE, &ndev->flags)) {",
          "409:   nfc_err(\"there is no available target to activate\");",
          "410:   return -EINVAL;",
          "411:  }",
          "413:  if (ndev->target_active_prot) {",
          "414:   nfc_err(\"there is already an active target\");",
          "415:   return -EBUSY;",
          "416:  }",
          "418:  if (!(ndev->target_available_prots & (1 << protocol))) {",
          "419:   nfc_err(\"target does not support the requested protocol 0x%x\",",
          "420:    protocol);",
          "421:   return -EINVAL;",
          "422:  }",
          "424:  ndev->target_active_prot = protocol;",
          "425:  ndev->target_available_prots = 0;",
          "427:  return 0;",
          "428: }",
          "430: static void nci_deactivate_target(struct nfc_dev *nfc_dev, __u32 target_idx)",
          "431: {",
          "432:  struct nci_dev *ndev = nfc_get_drvdata(nfc_dev);",
          "434:  nfc_dbg(\"entry, target_idx %d\", target_idx);",
          "436:  if (!ndev->target_active_prot) {",
          "437:   nfc_err(\"unable to deactivate target, no active target\");",
          "438:   return;",
          "439:  }",
          "441:  ndev->target_active_prot = 0;",
          "443:  if (test_bit(NCI_POLL_ACTIVE, &ndev->flags)) {",
          "444:   nci_request(ndev, nci_rf_deactivate_req, 0,",
          "445:    msecs_to_jiffies(NCI_RF_DEACTIVATE_TIMEOUT));",
          "446:  }",
          "447: }",
          "449: static int nci_data_exchange(struct nfc_dev *nfc_dev, __u32 target_idx,",
          "450:       struct sk_buff *skb,",
          "451:       data_exchange_cb_t cb,",
          "452:       void *cb_context)",
          "453: {",
          "454:  struct nci_dev *ndev = nfc_get_drvdata(nfc_dev);",
          "456:  nfc_dbg(\"entry, target_idx %d, len %d\", target_idx, skb->len);",
          "458:  if (!ndev->target_active_prot) {",
          "459:   nfc_err(\"unable to exchange data, no active target\");",
          "460:   return -EINVAL;",
          "461:  }",
          "464:  ndev->data_exchange_cb = cb;",
          "465:  ndev->data_exchange_cb_context = cb_context;",
          "467:  return nci_send_data(ndev, ndev->conn_id, skb);",
          "468: }",
          "470: static struct nfc_ops nci_nfc_ops = {",
          "471:  .dev_up = nci_dev_up,",
          "472:  .dev_down = nci_dev_down,",
          "473:  .start_poll = nci_start_poll,",
          "474:  .stop_poll = nci_stop_poll,",
          "475:  .activate_target = nci_activate_target,",
          "476:  .deactivate_target = nci_deactivate_target,",
          "477:  .data_exchange = nci_data_exchange,",
          "478: };",
          "488: struct nci_dev *nci_allocate_device(struct nci_ops *ops,",
          "489:      __u32 supported_protocols,",
          "490:      int tx_headroom,",
          "491:      int tx_tailroom)",
          "492: {",
          "493:  struct nci_dev *ndev = NULL;",
          "495:  nfc_dbg(\"entry, supported_protocols 0x%x\", supported_protocols);",
          "497:  if (!ops->open || !ops->close || !ops->send)",
          "498:   goto exit;",
          "500:  if (!supported_protocols)",
          "501:   goto exit;",
          "503:  ndev = kzalloc(sizeof(struct nci_dev), GFP_KERNEL);",
          "504:  if (!ndev)",
          "505:   goto exit;",
          "507:  ndev->ops = ops;",
          "508:  ndev->tx_headroom = tx_headroom;",
          "509:  ndev->tx_tailroom = tx_tailroom;",
          "511:  ndev->nfc_dev = nfc_allocate_device(&nci_nfc_ops,",
          "512:       supported_protocols,",
          "513:       tx_headroom + NCI_DATA_HDR_SIZE,",
          "514:       tx_tailroom);",
          "515:  if (!ndev->nfc_dev)",
          "516:   goto free_exit;",
          "518:  nfc_set_drvdata(ndev->nfc_dev, ndev);",
          "520:  goto exit;",
          "522: free_exit:",
          "523:  kfree(ndev);",
          "525: exit:",
          "526:  return ndev;",
          "527: }",
          "528: EXPORT_SYMBOL(nci_allocate_device);",
          "535: void nci_free_device(struct nci_dev *ndev)",
          "536: {",
          "537:  nfc_dbg(\"entry\");",
          "539:  nfc_free_device(ndev->nfc_dev);",
          "540:  kfree(ndev);",
          "541: }",
          "542: EXPORT_SYMBOL(nci_free_device);",
          "549: int nci_register_device(struct nci_dev *ndev)",
          "550: {",
          "551:  int rc;",
          "552:  struct device *dev = &ndev->nfc_dev->dev;",
          "553:  char name[32];",
          "555:  nfc_dbg(\"entry\");",
          "557:  rc = nfc_register_device(ndev->nfc_dev);",
          "558:  if (rc)",
          "559:   goto exit;",
          "561:  ndev->flags = 0;",
          "563:  INIT_WORK(&ndev->cmd_work, nci_cmd_work);",
          "564:  snprintf(name, sizeof(name), \"%s_nci_cmd_wq\", dev_name(dev));",
          "565:  ndev->cmd_wq = create_singlethread_workqueue(name);",
          "566:  if (!ndev->cmd_wq) {",
          "567:   rc = -ENOMEM;",
          "568:   goto unreg_exit;",
          "569:  }",
          "571:  INIT_WORK(&ndev->rx_work, nci_rx_work);",
          "572:  snprintf(name, sizeof(name), \"%s_nci_rx_wq\", dev_name(dev));",
          "573:  ndev->rx_wq = create_singlethread_workqueue(name);",
          "574:  if (!ndev->rx_wq) {",
          "575:   rc = -ENOMEM;",
          "576:   goto destroy_cmd_wq_exit;",
          "577:  }",
          "579:  INIT_WORK(&ndev->tx_work, nci_tx_work);",
          "580:  snprintf(name, sizeof(name), \"%s_nci_tx_wq\", dev_name(dev));",
          "581:  ndev->tx_wq = create_singlethread_workqueue(name);",
          "582:  if (!ndev->tx_wq) {",
          "583:   rc = -ENOMEM;",
          "584:   goto destroy_rx_wq_exit;",
          "585:  }",
          "587:  skb_queue_head_init(&ndev->cmd_q);",
          "588:  skb_queue_head_init(&ndev->rx_q);",
          "589:  skb_queue_head_init(&ndev->tx_q);",
          "591:  setup_timer(&ndev->cmd_timer, nci_cmd_timer,",
          "592:    (unsigned long) ndev);",
          "594:  mutex_init(&ndev->req_lock);",
          "596:  goto exit;",
          "598: destroy_rx_wq_exit:",
          "599:  destroy_workqueue(ndev->rx_wq);",
          "601: destroy_cmd_wq_exit:",
          "602:  destroy_workqueue(ndev->cmd_wq);",
          "604: unreg_exit:",
          "605:  nfc_unregister_device(ndev->nfc_dev);",
          "607: exit:",
          "608:  return rc;",
          "609: }",
          "610: EXPORT_SYMBOL(nci_register_device);",
          "617: void nci_unregister_device(struct nci_dev *ndev)",
          "618: {",
          "619:  nfc_dbg(\"entry\");",
          "621:  nci_close_device(ndev);",
          "623:  destroy_workqueue(ndev->cmd_wq);",
          "624:  destroy_workqueue(ndev->rx_wq);",
          "625:  destroy_workqueue(ndev->tx_wq);",
          "627:  nfc_unregister_device(ndev->nfc_dev);",
          "628: }",
          "629: EXPORT_SYMBOL(nci_unregister_device);",
          "636: int nci_recv_frame(struct sk_buff *skb)",
          "637: {",
          "638:  struct nci_dev *ndev = (struct nci_dev *) skb->dev;",
          "640:  nfc_dbg(\"entry, len %d\", skb->len);",
          "642:  if (!ndev || (!test_bit(NCI_UP, &ndev->flags)",
          "643:   && !test_bit(NCI_INIT, &ndev->flags))) {",
          "644:   kfree_skb(skb);",
          "645:   return -ENXIO;",
          "646:  }",
          "649:  skb_queue_tail(&ndev->rx_q, skb);",
          "650:  queue_work(ndev->rx_wq, &ndev->rx_work);",
          "652:  return 0;",
          "653: }",
          "654: EXPORT_SYMBOL(nci_recv_frame);",
          "656: static int nci_send_frame(struct sk_buff *skb)",
          "657: {",
          "658:  struct nci_dev *ndev = (struct nci_dev *) skb->dev;",
          "660:  nfc_dbg(\"entry, len %d\", skb->len);",
          "662:  if (!ndev) {",
          "663:   kfree_skb(skb);",
          "664:   return -ENODEV;",
          "665:  }",
          "668:  skb_orphan(skb);",
          "670:  return ndev->ops->send(skb);",
          "671: }",
          "674: int nci_send_cmd(struct nci_dev *ndev, __u16 opcode, __u8 plen, void *payload)",
          "675: {",
          "676:  struct nci_ctrl_hdr *hdr;",
          "677:  struct sk_buff *skb;",
          "679:  nfc_dbg(\"entry, opcode 0x%x, plen %d\", opcode, plen);",
          "681:  skb = nci_skb_alloc(ndev, (NCI_CTRL_HDR_SIZE + plen), GFP_KERNEL);",
          "682:  if (!skb) {",
          "683:   nfc_err(\"no memory for command\");",
          "684:   return -ENOMEM;",
          "685:  }",
          "687:  hdr = (struct nci_ctrl_hdr *) skb_put(skb, NCI_CTRL_HDR_SIZE);",
          "688:  hdr->gid = nci_opcode_gid(opcode);",
          "689:  hdr->oid = nci_opcode_oid(opcode);",
          "690:  hdr->plen = plen;",
          "692:  nci_mt_set((__u8 *)hdr, NCI_MT_CMD_PKT);",
          "693:  nci_pbf_set((__u8 *)hdr, NCI_PBF_LAST);",
          "695:  if (plen)",
          "696:   memcpy(skb_put(skb, plen), payload, plen);",
          "698:  skb->dev = (void *) ndev;",
          "700:  skb_queue_tail(&ndev->cmd_q, skb);",
          "701:  queue_work(ndev->cmd_wq, &ndev->cmd_work);",
          "703:  return 0;",
          "704: }",
          "708: static void nci_tx_work(struct work_struct *work)",
          "709: {",
          "710:  struct nci_dev *ndev = container_of(work, struct nci_dev, tx_work);",
          "711:  struct sk_buff *skb;",
          "713:  nfc_dbg(\"entry, credits_cnt %d\", atomic_read(&ndev->credits_cnt));",
          "716:  while (atomic_read(&ndev->credits_cnt)) {",
          "717:   skb = skb_dequeue(&ndev->tx_q);",
          "718:   if (!skb)",
          "719:    return;",
          "721:   atomic_dec(&ndev->credits_cnt);",
          "723:   nfc_dbg(\"NCI TX: MT=data, PBF=%d, conn_id=%d, plen=%d\",",
          "724:     nci_pbf(skb->data),",
          "725:     nci_conn_id(skb->data),",
          "726:     nci_plen(skb->data));",
          "728:   nci_send_frame(skb);",
          "729:  }",
          "730: }",
          "734: static void nci_rx_work(struct work_struct *work)",
          "735: {",
          "736:  struct nci_dev *ndev = container_of(work, struct nci_dev, rx_work);",
          "737:  struct sk_buff *skb;",
          "739:  while ((skb = skb_dequeue(&ndev->rx_q))) {",
          "741:   switch (nci_mt(skb->data)) {",
          "742:   case NCI_MT_RSP_PKT:",
          "743:    nci_rsp_packet(ndev, skb);",
          "744:    break;",
          "746:   case NCI_MT_NTF_PKT:",
          "747:    nci_ntf_packet(ndev, skb);",
          "748:    break;",
          "750:   case NCI_MT_DATA_PKT:",
          "751:    nci_rx_data_packet(ndev, skb);",
          "752:    break;",
          "754:   default:",
          "755:    nfc_err(\"unknown MT 0x%x\", nci_mt(skb->data));",
          "756:    kfree_skb(skb);",
          "757:    break;",
          "758:   }",
          "759:  }",
          "760: }",
          "764: static void nci_cmd_work(struct work_struct *work)",
          "765: {",
          "766:  struct nci_dev *ndev = container_of(work, struct nci_dev, cmd_work);",
          "767:  struct sk_buff *skb;",
          "769:  nfc_dbg(\"entry, cmd_cnt %d\", atomic_read(&ndev->cmd_cnt));",
          "772:  if (atomic_read(&ndev->cmd_cnt)) {",
          "773:   skb = skb_dequeue(&ndev->cmd_q);",
          "774:   if (!skb)",
          "775:    return;",
          "777:   atomic_dec(&ndev->cmd_cnt);",
          "779:   nfc_dbg(\"NCI TX: MT=cmd, PBF=%d, GID=0x%x, OID=0x%x, plen=%d\",",
          "780:     nci_pbf(skb->data),",
          "781:     nci_opcode_gid(nci_opcode(skb->data)),",
          "782:     nci_opcode_oid(nci_opcode(skb->data)),",
          "783:     nci_plen(skb->data));",
          "785:   nci_send_frame(skb);",
          "787:   mod_timer(&ndev->cmd_timer,",
          "788:    jiffies + msecs_to_jiffies(NCI_CMD_TIMEOUT));",
          "789:  }",
          "790: }",
          "",
          "---------------"
        ],
        "net/nfc/nci/data.c||net/nfc/nci/data.c": [
          "File: net/nfc/nci/data.c -> net/nfc/nci/data.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "24: #include <linux/types.h>",
          "25: #include <linux/interrupt.h>",
          "26: #include <linux/wait.h>",
          "27: #include <linux/bitops.h>",
          "28: #include <linux/skbuff.h>",
          "30: #include \"../nfc.h\"",
          "31: #include <net/nfc/nci.h>",
          "32: #include <net/nfc/nci_core.h>",
          "33: #include <linux/nfc.h>",
          "36: void nci_data_exchange_complete(struct nci_dev *ndev,",
          "37:     struct sk_buff *skb,",
          "38:     int err)",
          "39: {",
          "40:  data_exchange_cb_t cb = ndev->data_exchange_cb;",
          "41:  void *cb_context = ndev->data_exchange_cb_context;",
          "43:  nfc_dbg(\"entry, len %d, err %d\", ((skb) ? (skb->len) : (0)), err);",
          "45:  if (cb) {",
          "46:   ndev->data_exchange_cb = NULL;",
          "47:   ndev->data_exchange_cb_context = 0;",
          "50:   cb(cb_context, skb, err);",
          "51:  } else if (skb) {",
          "52:   nfc_err(\"no rx callback, dropping rx data...\");",
          "55:   kfree_skb(skb);",
          "56:  }",
          "57: }",
          "61: static inline void nci_push_data_hdr(struct nci_dev *ndev,",
          "62:      __u8 conn_id,",
          "63:      struct sk_buff *skb,",
          "64:      __u8 pbf)",
          "65: {",
          "66:  struct nci_data_hdr *hdr;",
          "67:  int plen = skb->len;",
          "69:  hdr = (struct nci_data_hdr *) skb_push(skb, NCI_DATA_HDR_SIZE);",
          "70:  hdr->conn_id = conn_id;",
          "71:  hdr->rfu = 0;",
          "72:  hdr->plen = plen;",
          "74:  nci_mt_set((__u8 *)hdr, NCI_MT_DATA_PKT);",
          "75:  nci_pbf_set((__u8 *)hdr, pbf);",
          "77:  skb->dev = (void *) ndev;",
          "78: }",
          "80: static int nci_queue_tx_data_frags(struct nci_dev *ndev,",
          "81:      __u8 conn_id,",
          "82:      struct sk_buff *skb) {",
          "83:  int total_len = skb->len;",
          "84:  unsigned char *data = skb->data;",
          "85:  unsigned long flags;",
          "86:  struct sk_buff_head frags_q;",
          "87:  struct sk_buff *skb_frag;",
          "88:  int frag_len;",
          "89:  int rc = 0;",
          "91:  nfc_dbg(\"entry, conn_id 0x%x, total_len %d\", conn_id, total_len);",
          "93:  __skb_queue_head_init(&frags_q);",
          "95:  while (total_len) {",
          "96:   frag_len = min_t(int, total_len, ndev->max_pkt_payload_size);",
          "98:   skb_frag = nci_skb_alloc(ndev,",
          "99:      (NCI_DATA_HDR_SIZE + frag_len),",
          "100:      GFP_KERNEL);",
          "101:   if (skb_frag == NULL) {",
          "102:    rc = -ENOMEM;",
          "103:    goto free_exit;",
          "104:   }",
          "105:   skb_reserve(skb_frag, NCI_DATA_HDR_SIZE);",
          "108:   memcpy(skb_put(skb_frag, frag_len), data, frag_len);",
          "111:   nci_push_data_hdr(ndev, conn_id, skb_frag,",
          "112:   ((total_len == frag_len) ? (NCI_PBF_LAST) : (NCI_PBF_CONT)));",
          "114:   __skb_queue_tail(&frags_q, skb_frag);",
          "116:   data += frag_len;",
          "117:   total_len -= frag_len;",
          "119:   nfc_dbg(\"frag_len %d, remaining total_len %d\",",
          "120:    frag_len, total_len);",
          "121:  }",
          "124:  spin_lock_irqsave(&ndev->tx_q.lock, flags);",
          "126:  while ((skb_frag = __skb_dequeue(&frags_q)) != NULL)",
          "127:   __skb_queue_tail(&ndev->tx_q, skb_frag);",
          "129:  spin_unlock_irqrestore(&ndev->tx_q.lock, flags);",
          "132:  kfree_skb(skb);",
          "134:  goto exit;",
          "136: free_exit:",
          "137:  while ((skb_frag = __skb_dequeue(&frags_q)) != NULL)",
          "138:   kfree_skb(skb_frag);",
          "140: exit:",
          "141:  return rc;",
          "142: }",
          "145: int nci_send_data(struct nci_dev *ndev, __u8 conn_id, struct sk_buff *skb)",
          "146: {",
          "147:  int rc = 0;",
          "149:  nfc_dbg(\"entry, conn_id 0x%x, plen %d\", conn_id, skb->len);",
          "152:  if (skb->len <= ndev->max_pkt_payload_size) {",
          "154:   nci_push_data_hdr(ndev, conn_id, skb, NCI_PBF_LAST);",
          "156:   skb_queue_tail(&ndev->tx_q, skb);",
          "157:  } else {",
          "159:   rc = nci_queue_tx_data_frags(ndev, conn_id, skb);",
          "160:   if (rc) {",
          "161:    nfc_err(\"failed to fragment tx data packet\");",
          "162:    goto free_exit;",
          "163:   }",
          "164:  }",
          "166:  queue_work(ndev->tx_wq, &ndev->tx_work);",
          "168:  goto exit;",
          "170: free_exit:",
          "171:  kfree_skb(skb);",
          "173: exit:",
          "174:  return rc;",
          "175: }",
          "179: static void nci_add_rx_data_frag(struct nci_dev *ndev,",
          "180:     struct sk_buff *skb,",
          "181:     __u8 pbf)",
          "182: {",
          "183:  int reassembly_len;",
          "184:  int err = 0;",
          "186:  if (ndev->rx_data_reassembly) {",
          "187:   reassembly_len = ndev->rx_data_reassembly->len;",
          "190:   if (skb_cow_head(skb, reassembly_len)) {",
          "191:    nfc_err(\"error adding room for accumulated rx data\");",
          "193:    kfree_skb(skb);",
          "194:    skb = 0;",
          "196:    kfree_skb(ndev->rx_data_reassembly);",
          "197:    ndev->rx_data_reassembly = 0;",
          "199:    err = -ENOMEM;",
          "200:    goto exit;",
          "201:   }",
          "204:   memcpy(skb_push(skb, reassembly_len),",
          "205:     ndev->rx_data_reassembly->data,",
          "206:     reassembly_len);",
          "209:   kfree_skb(ndev->rx_data_reassembly);",
          "210:   ndev->rx_data_reassembly = 0;",
          "211:  }",
          "213:  if (pbf == NCI_PBF_CONT) {",
          "215:   ndev->rx_data_reassembly = skb;",
          "216:   return;",
          "217:  }",
          "219: exit:",
          "220:  nci_data_exchange_complete(ndev, skb, err);",
          "221: }",
          "224: void nci_rx_data_packet(struct nci_dev *ndev, struct sk_buff *skb)",
          "225: {",
          "226:  __u8 pbf = nci_pbf(skb->data);",
          "228:  nfc_dbg(\"entry, len %d\", skb->len);",
          "230:  nfc_dbg(\"NCI RX: MT=data, PBF=%d, conn_id=%d, plen=%d\",",
          "231:    nci_pbf(skb->data),",
          "232:    nci_conn_id(skb->data),",
          "233:    nci_plen(skb->data));",
          "236:  skb_pull(skb, NCI_DATA_HDR_SIZE);",
          "238:  if (ndev->target_active_prot == NFC_PROTO_MIFARE) {",
          "240:   nfc_dbg(\"NFC_PROTO_MIFARE => remove the status byte\");",
          "241:   skb_trim(skb, (skb->len - 1));",
          "242:  }",
          "244:  nci_add_rx_data_frag(ndev, skb, pbf);",
          "245: }",
          "",
          "---------------"
        ],
        "net/nfc/nci/lib.c||net/nfc/nci/lib.c": [
          "File: net/nfc/nci/lib.c -> net/nfc/nci/lib.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "28: #include <linux/module.h>",
          "29: #include <linux/kernel.h>",
          "30: #include <linux/types.h>",
          "31: #include <linux/errno.h>",
          "33: #include <net/nfc/nci.h>",
          "36: int nci_to_errno(__u8 code)",
          "37: {",
          "38:  switch (code) {",
          "39:  case NCI_STATUS_OK:",
          "40:   return 0;",
          "42:  case NCI_STATUS_REJECTED:",
          "43:   return -EBUSY;",
          "45:  case NCI_STATUS_MESSAGE_CORRUPTED:",
          "46:   return -EBADMSG;",
          "48:  case NCI_STATUS_BUFFER_FULL:",
          "49:   return -ENOBUFS;",
          "51:  case NCI_STATUS_NOT_INITIALIZED:",
          "52:   return -EHOSTDOWN;",
          "54:  case NCI_STATUS_SYNTAX_ERROR:",
          "55:  case NCI_STATUS_SEMANTIC_ERROR:",
          "56:  case NCI_STATUS_INVALID_PARAM:",
          "57:  case NCI_STATUS_RF_PROTOCOL_ERROR:",
          "58:  case NCI_STATUS_NFCEE_PROTOCOL_ERROR:",
          "59:   return -EPROTO;",
          "61:  case NCI_STATUS_UNKNOWN_GID:",
          "62:  case NCI_STATUS_UNKNOWN_OID:",
          "63:   return -EBADRQC;",
          "65:  case NCI_STATUS_MESSAGE_SIZE_EXCEEDED:",
          "66:   return -EMSGSIZE;",
          "68:  case NCI_STATUS_DISCOVERY_ALREADY_STARTED:",
          "69:   return -EALREADY;",
          "71:  case NCI_STATUS_DISCOVERY_TARGET_ACTIVATION_FAILED:",
          "72:  case NCI_STATUS_NFCEE_INTERFACE_ACTIVATION_FAILED:",
          "73:   return -ECONNREFUSED;",
          "75:  case NCI_STATUS_RF_TRANSMISSION_ERROR:",
          "76:  case NCI_STATUS_NFCEE_TRANSMISSION_ERROR:",
          "77:   return -ECOMM;",
          "79:  case NCI_STATUS_RF_TIMEOUT_ERROR:",
          "80:  case NCI_STATUS_NFCEE_TIMEOUT_ERROR:",
          "81:   return -ETIMEDOUT;",
          "83:  case NCI_STATUS_RF_LINK_LOSS_ERROR:",
          "84:   return -ENOLINK;",
          "86:  case NCI_STATUS_MAX_ACTIVE_NFCEE_INTERFACES_REACHED:",
          "87:   return -EDQUOT;",
          "89:  case NCI_STATUS_FAILED:",
          "90:  default:",
          "91:   return -ENOSYS;",
          "92:  }",
          "93: }",
          "94: EXPORT_SYMBOL(nci_to_errno);",
          "",
          "---------------"
        ],
        "net/nfc/nci/ntf.c||net/nfc/nci/ntf.c": [
          "File: net/nfc/nci/ntf.c -> net/nfc/nci/ntf.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "28: #include <linux/types.h>",
          "29: #include <linux/interrupt.h>",
          "30: #include <linux/bitops.h>",
          "31: #include <linux/skbuff.h>",
          "33: #include \"../nfc.h\"",
          "34: #include <net/nfc/nci.h>",
          "35: #include <net/nfc/nci_core.h>",
          "36: #include <linux/nfc.h>",
          "40: static void nci_core_conn_credits_ntf_packet(struct nci_dev *ndev,",
          "41:       struct sk_buff *skb)",
          "42: {",
          "43:  struct nci_core_conn_credit_ntf *ntf = (void *) skb->data;",
          "44:  int i;",
          "46:  nfc_dbg(\"entry, num_entries %d\", ntf->num_entries);",
          "48:  if (ntf->num_entries > NCI_MAX_NUM_CONN)",
          "49:   ntf->num_entries = NCI_MAX_NUM_CONN;",
          "52:  for (i = 0; i < ntf->num_entries; i++) {",
          "53:   nfc_dbg(\"entry[%d]: conn_id %d, credits %d\", i,",
          "54:    ntf->conn_entries[i].conn_id,",
          "55:    ntf->conn_entries[i].credits);",
          "57:   if (ntf->conn_entries[i].conn_id == ndev->conn_id) {",
          "59:    atomic_add(ntf->conn_entries[i].credits,",
          "60:     &ndev->credits_cnt);",
          "61:   }",
          "62:  }",
          "65:  if (!skb_queue_empty(&ndev->tx_q))",
          "66:   queue_work(ndev->tx_wq, &ndev->tx_work);",
          "67: }",
          "69: static void nci_rf_field_info_ntf_packet(struct nci_dev *ndev,",
          "70:      struct sk_buff *skb)",
          "71: {",
          "72:  struct nci_rf_field_info_ntf *ntf = (void *) skb->data;",
          "74:  nfc_dbg(\"entry, rf_field_status %d\", ntf->rf_field_status);",
          "75: }",
          "77: static int nci_rf_activate_nfca_passive_poll(struct nci_dev *ndev,",
          "78:    struct nci_rf_activate_ntf *ntf, __u8 *data)",
          "79: {",
          "80:  struct rf_tech_specific_params_nfca_poll *nfca_poll;",
          "81:  struct activation_params_nfca_poll_iso_dep *nfca_poll_iso_dep;",
          "83:  nfca_poll = &ntf->rf_tech_specific_params.nfca_poll;",
          "84:  nfca_poll_iso_dep = &ntf->activation_params.nfca_poll_iso_dep;",
          "86:  nfca_poll->sens_res = __le16_to_cpu(*((__u16 *)data));",
          "87:  data += 2;",
          "89:  nfca_poll->nfcid1_len = *data++;",
          "91:  nfc_dbg(\"sens_res 0x%x, nfcid1_len %d\",",
          "92:   nfca_poll->sens_res,",
          "93:   nfca_poll->nfcid1_len);",
          "95:  memcpy(nfca_poll->nfcid1, data, nfca_poll->nfcid1_len);",
          "96:  data += nfca_poll->nfcid1_len;",
          "98:  nfca_poll->sel_res_len = *data++;",
          "100:  if (nfca_poll->sel_res_len != 0)",
          "101:   nfca_poll->sel_res = *data++;",
          "103:  ntf->rf_interface_type = *data++;",
          "104:  ntf->activation_params_len = *data++;",
          "106:  nfc_dbg(\"sel_res_len %d, sel_res 0x%x, rf_interface_type %d, activation_params_len %d\",",
          "107:   nfca_poll->sel_res_len,",
          "108:   nfca_poll->sel_res,",
          "109:   ntf->rf_interface_type,",
          "110:   ntf->activation_params_len);",
          "112:  switch (ntf->rf_interface_type) {",
          "113:  case NCI_RF_INTERFACE_ISO_DEP:",
          "114:   nfca_poll_iso_dep->rats_res_len = *data++;",
          "115:   if (nfca_poll_iso_dep->rats_res_len > 0) {",
          "116:    memcpy(nfca_poll_iso_dep->rats_res,",
          "117:     data,",
          "118:     nfca_poll_iso_dep->rats_res_len);",
          "119:   }",
          "120:   break;",
          "122:  case NCI_RF_INTERFACE_FRAME:",
          "124:   break;",
          "126:  default:",
          "127:   nfc_err(\"unsupported rf_interface_type 0x%x\",",
          "128:    ntf->rf_interface_type);",
          "129:   return -EPROTO;",
          "130:  }",
          "132:  return 0;",
          "133: }",
          "135: static void nci_target_found(struct nci_dev *ndev,",
          "136:     struct nci_rf_activate_ntf *ntf)",
          "137: {",
          "138:  struct nfc_target nfc_tgt;",
          "141:   nfc_tgt.supported_protocols = NFC_PROTO_MIFARE_MASK;",
          "143:   nfc_tgt.supported_protocols = NFC_PROTO_ISO14443_MASK;",
          "145:  nfc_tgt.sens_res = ntf->rf_tech_specific_params.nfca_poll.sens_res;",
          "146:  nfc_tgt.sel_res = ntf->rf_tech_specific_params.nfca_poll.sel_res;",
          "148:  if (!(nfc_tgt.supported_protocols & ndev->poll_prots)) {",
          "149:   nfc_dbg(\"the target found does not have the desired protocol\");",
          "150:   return;",
          "151:  }",
          "153:  nfc_dbg(\"new target found,  supported_protocols 0x%x\",",
          "154:   nfc_tgt.supported_protocols);",
          "156:  ndev->target_available_prots = nfc_tgt.supported_protocols;",
          "158:  nfc_targets_found(ndev->nfc_dev, &nfc_tgt, 1);",
          "159: }",
          "161: static void nci_rf_activate_ntf_packet(struct nci_dev *ndev,",
          "162:      struct sk_buff *skb)",
          "163: {",
          "164:  struct nci_rf_activate_ntf ntf;",
          "165:  __u8 *data = skb->data;",
          "166:  int rc = -1;",
          "168:  clear_bit(NCI_DISCOVERY, &ndev->flags);",
          "169:  set_bit(NCI_POLL_ACTIVE, &ndev->flags);",
          "171:  ntf.target_handle = *data++;",
          "172:  ntf.rf_protocol = *data++;",
          "173:  ntf.rf_tech_and_mode = *data++;",
          "174:  ntf.rf_tech_specific_params_len = *data++;",
          "176:  nfc_dbg(\"target_handle %d, rf_protocol 0x%x, rf_tech_and_mode 0x%x, rf_tech_specific_params_len %d\",",
          "177:   ntf.target_handle,",
          "178:   ntf.rf_protocol,",
          "179:   ntf.rf_tech_and_mode,",
          "180:   ntf.rf_tech_specific_params_len);",
          "182:  switch (ntf.rf_tech_and_mode) {",
          "183:  case NCI_NFC_A_PASSIVE_POLL_MODE:",
          "184:   rc = nci_rf_activate_nfca_passive_poll(ndev, &ntf,",
          "185:    data);",
          "186:   break;",
          "188:  default:",
          "189:   nfc_err(\"unsupported rf_tech_and_mode 0x%x\",",
          "190:    ntf.rf_tech_and_mode);",
          "191:   return;",
          "192:  }",
          "194:  if (!rc)",
          "195:   nci_target_found(ndev, &ntf);",
          "196: }",
          "198: static void nci_rf_deactivate_ntf_packet(struct nci_dev *ndev,",
          "199:      struct sk_buff *skb)",
          "200: {",
          "201:  __u8 type = skb->data[0];",
          "203:  nfc_dbg(\"entry, type 0x%x\", type);",
          "205:  clear_bit(NCI_POLL_ACTIVE, &ndev->flags);",
          "206:  ndev->target_active_prot = 0;",
          "209:  skb_queue_purge(&ndev->tx_q);",
          "212:  if (ndev->rx_data_reassembly) {",
          "213:   kfree_skb(ndev->rx_data_reassembly);",
          "214:   ndev->rx_data_reassembly = 0;",
          "215:  }",
          "218:  if (ndev->data_exchange_cb)",
          "219:   nci_data_exchange_complete(ndev, NULL, -EIO);",
          "220: }",
          "222: void nci_ntf_packet(struct nci_dev *ndev, struct sk_buff *skb)",
          "223: {",
          "224:  __u16 ntf_opcode = nci_opcode(skb->data);",
          "226:  nfc_dbg(\"NCI RX: MT=ntf, PBF=%d, GID=0x%x, OID=0x%x, plen=%d\",",
          "227:    nci_pbf(skb->data),",
          "228:    nci_opcode_gid(ntf_opcode),",
          "229:    nci_opcode_oid(ntf_opcode),",
          "230:    nci_plen(skb->data));",
          "233:  skb_pull(skb, NCI_CTRL_HDR_SIZE);",
          "235:  switch (ntf_opcode) {",
          "236:  case NCI_OP_CORE_CONN_CREDITS_NTF:",
          "237:   nci_core_conn_credits_ntf_packet(ndev, skb);",
          "238:   break;",
          "240:  case NCI_OP_RF_FIELD_INFO_NTF:",
          "241:   nci_rf_field_info_ntf_packet(ndev, skb);",
          "242:   break;",
          "244:  case NCI_OP_RF_ACTIVATE_NTF:",
          "245:   nci_rf_activate_ntf_packet(ndev, skb);",
          "246:   break;",
          "248:  case NCI_OP_RF_DEACTIVATE_NTF:",
          "249:   nci_rf_deactivate_ntf_packet(ndev, skb);",
          "250:   break;",
          "252:  default:",
          "253:   nfc_err(\"unknown ntf opcode 0x%x\", ntf_opcode);",
          "254:   break;",
          "255:  }",
          "257:  kfree_skb(skb);",
          "258: }",
          "",
          "---------------"
        ],
        "net/nfc/nci/rsp.c||net/nfc/nci/rsp.c": [
          "File: net/nfc/nci/rsp.c -> net/nfc/nci/rsp.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "28: #include <linux/types.h>",
          "29: #include <linux/interrupt.h>",
          "30: #include <linux/bitops.h>",
          "31: #include <linux/skbuff.h>",
          "33: #include \"../nfc.h\"",
          "34: #include <net/nfc/nci.h>",
          "35: #include <net/nfc/nci_core.h>",
          "39: static void nci_core_reset_rsp_packet(struct nci_dev *ndev, struct sk_buff *skb)",
          "40: {",
          "41:  struct nci_core_reset_rsp *rsp = (void *) skb->data;",
          "43:  nfc_dbg(\"entry, status 0x%x\", rsp->status);",
          "45:  if (rsp->status == NCI_STATUS_OK)",
          "46:   ndev->nci_ver = rsp->nci_ver;",
          "48:  nfc_dbg(\"nci_ver 0x%x\", ndev->nci_ver);",
          "50:  nci_req_complete(ndev, rsp->status);",
          "51: }",
          "53: static void nci_core_init_rsp_packet(struct nci_dev *ndev, struct sk_buff *skb)",
          "54: {",
          "55:  struct nci_core_init_rsp_1 *rsp_1 = (void *) skb->data;",
          "56:  struct nci_core_init_rsp_2 *rsp_2;",
          "58:  nfc_dbg(\"entry, status 0x%x\", rsp_1->status);",
          "60:  if (rsp_1->status != NCI_STATUS_OK)",
          "61:   return;",
          "63:  ndev->nfcc_features = __le32_to_cpu(rsp_1->nfcc_features);",
          "64:  ndev->num_supported_rf_interfaces = rsp_1->num_supported_rf_interfaces;",
          "66:  if (ndev->num_supported_rf_interfaces >",
          "67:   NCI_MAX_SUPPORTED_RF_INTERFACES) {",
          "68:   ndev->num_supported_rf_interfaces =",
          "69:    NCI_MAX_SUPPORTED_RF_INTERFACES;",
          "70:  }",
          "72:  memcpy(ndev->supported_rf_interfaces,",
          "73:   rsp_1->supported_rf_interfaces,",
          "74:   ndev->num_supported_rf_interfaces);",
          "76:  rsp_2 = (void *) (skb->data + 6 + ndev->num_supported_rf_interfaces);",
          "78:  ndev->max_logical_connections =",
          "79:   rsp_2->max_logical_connections;",
          "80:  ndev->max_routing_table_size =",
          "81:   __le16_to_cpu(rsp_2->max_routing_table_size);",
          "82:  ndev->max_control_packet_payload_length =",
          "83:   rsp_2->max_control_packet_payload_length;",
          "84:  ndev->rf_sending_buffer_size =",
          "85:   __le16_to_cpu(rsp_2->rf_sending_buffer_size);",
          "86:  ndev->rf_receiving_buffer_size =",
          "87:   __le16_to_cpu(rsp_2->rf_receiving_buffer_size);",
          "88:  ndev->manufacturer_id =",
          "89:   __le16_to_cpu(rsp_2->manufacturer_id);",
          "91:  nfc_dbg(\"nfcc_features 0x%x\",",
          "92:   ndev->nfcc_features);",
          "93:  nfc_dbg(\"num_supported_rf_interfaces %d\",",
          "94:   ndev->num_supported_rf_interfaces);",
          "95:  nfc_dbg(\"supported_rf_interfaces[0] 0x%x\",",
          "96:   ndev->supported_rf_interfaces[0]);",
          "97:  nfc_dbg(\"supported_rf_interfaces[1] 0x%x\",",
          "98:   ndev->supported_rf_interfaces[1]);",
          "99:  nfc_dbg(\"supported_rf_interfaces[2] 0x%x\",",
          "100:   ndev->supported_rf_interfaces[2]);",
          "101:  nfc_dbg(\"supported_rf_interfaces[3] 0x%x\",",
          "102:   ndev->supported_rf_interfaces[3]);",
          "103:  nfc_dbg(\"max_logical_connections %d\",",
          "104:   ndev->max_logical_connections);",
          "105:  nfc_dbg(\"max_routing_table_size %d\",",
          "106:   ndev->max_routing_table_size);",
          "107:  nfc_dbg(\"max_control_packet_payload_length %d\",",
          "108:   ndev->max_control_packet_payload_length);",
          "109:  nfc_dbg(\"rf_sending_buffer_size %d\",",
          "110:   ndev->rf_sending_buffer_size);",
          "111:  nfc_dbg(\"rf_receiving_buffer_size %d\",",
          "112:   ndev->rf_receiving_buffer_size);",
          "113:  nfc_dbg(\"manufacturer_id 0x%x\",",
          "114:   ndev->manufacturer_id);",
          "116:  nci_req_complete(ndev, rsp_1->status);",
          "117: }",
          "119: static void nci_core_conn_create_rsp_packet(struct nci_dev *ndev,",
          "120:       struct sk_buff *skb)",
          "121: {",
          "122:  struct nci_core_conn_create_rsp *rsp = (void *) skb->data;",
          "124:  nfc_dbg(\"entry, status 0x%x\", rsp->status);",
          "126:  if (rsp->status != NCI_STATUS_OK)",
          "127:   return;",
          "129:  ndev->max_pkt_payload_size = rsp->max_pkt_payload_size;",
          "130:  ndev->initial_num_credits = rsp->initial_num_credits;",
          "131:  ndev->conn_id = rsp->conn_id;",
          "133:  atomic_set(&ndev->credits_cnt, ndev->initial_num_credits);",
          "135:  nfc_dbg(\"max_pkt_payload_size %d\", ndev->max_pkt_payload_size);",
          "136:  nfc_dbg(\"initial_num_credits %d\", ndev->initial_num_credits);",
          "137:  nfc_dbg(\"conn_id %d\", ndev->conn_id);",
          "138: }",
          "140: static void nci_rf_disc_map_rsp_packet(struct nci_dev *ndev,",
          "141:      struct sk_buff *skb)",
          "142: {",
          "143:  __u8 status = skb->data[0];",
          "145:  nfc_dbg(\"entry, status 0x%x\", status);",
          "147:  nci_req_complete(ndev, status);",
          "148: }",
          "150: static void nci_rf_disc_rsp_packet(struct nci_dev *ndev, struct sk_buff *skb)",
          "151: {",
          "152:  __u8 status = skb->data[0];",
          "154:  nfc_dbg(\"entry, status 0x%x\", status);",
          "156:  if (status == NCI_STATUS_OK)",
          "157:   set_bit(NCI_DISCOVERY, &ndev->flags);",
          "159:  nci_req_complete(ndev, status);",
          "160: }",
          "162: static void nci_rf_deactivate_rsp_packet(struct nci_dev *ndev,",
          "163:      struct sk_buff *skb)",
          "164: {",
          "165:  __u8 status = skb->data[0];",
          "167:  nfc_dbg(\"entry, status 0x%x\", status);",
          "169:  clear_bit(NCI_DISCOVERY, &ndev->flags);",
          "171:  nci_req_complete(ndev, status);",
          "172: }",
          "174: void nci_rsp_packet(struct nci_dev *ndev, struct sk_buff *skb)",
          "175: {",
          "176:  __u16 rsp_opcode = nci_opcode(skb->data);",
          "179:  del_timer(&ndev->cmd_timer);",
          "181:  nfc_dbg(\"NCI RX: MT=rsp, PBF=%d, GID=0x%x, OID=0x%x, plen=%d\",",
          "182:    nci_pbf(skb->data),",
          "183:    nci_opcode_gid(rsp_opcode),",
          "184:    nci_opcode_oid(rsp_opcode),",
          "185:    nci_plen(skb->data));",
          "188:  skb_pull(skb, NCI_CTRL_HDR_SIZE);",
          "190:  switch (rsp_opcode) {",
          "191:  case NCI_OP_CORE_RESET_RSP:",
          "192:   nci_core_reset_rsp_packet(ndev, skb);",
          "193:   break;",
          "195:  case NCI_OP_CORE_INIT_RSP:",
          "196:   nci_core_init_rsp_packet(ndev, skb);",
          "197:   break;",
          "199:  case NCI_OP_CORE_CONN_CREATE_RSP:",
          "200:   nci_core_conn_create_rsp_packet(ndev, skb);",
          "201:   break;",
          "203:  case NCI_OP_RF_DISCOVER_MAP_RSP:",
          "204:   nci_rf_disc_map_rsp_packet(ndev, skb);",
          "205:   break;",
          "207:  case NCI_OP_RF_DISCOVER_RSP:",
          "208:   nci_rf_disc_rsp_packet(ndev, skb);",
          "209:   break;",
          "211:  case NCI_OP_RF_DEACTIVATE_RSP:",
          "212:   nci_rf_deactivate_rsp_packet(ndev, skb);",
          "213:   break;",
          "215:  default:",
          "216:   nfc_err(\"unknown rsp opcode 0x%x\", rsp_opcode);",
          "217:   break;",
          "218:  }",
          "220:  kfree_skb(skb);",
          "223:  atomic_set(&ndev->cmd_cnt, 1);",
          "224:  if (!skb_queue_empty(&ndev->cmd_q))",
          "225:   queue_work(ndev->cmd_wq, &ndev->cmd_work);",
          "226: }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "d5a2ca60e41fec4ede7b82d3608278523cffe77b",
      "candidate_info": {
        "commit_hash": "d5a2ca60e41fec4ede7b82d3608278523cffe77b",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/d5a2ca60e41fec4ede7b82d3608278523cffe77b",
        "files": [
          "include/linux/nfc.h",
          "include/net/nfc/nci.h",
          "include/net/nfc/nfc.h",
          "net/nfc/nci/ntf.c",
          "net/nfc/netlink.c"
        ],
        "message": "NFC: Export new attributes sensb_res and sensf_res\n\nExport new attributes sensb_res for tech B and sensf_res\nfor tech F in the target info (returned as a response to\nNFC_CMD_GET_TARGET).\nThe max size of the attributes nfcid1, sensb_res and sensf_res\nis exported to user space though include/linux/nfc.\n\nSigned-off-by: Ilan Elias <ilane@ti.com>\nAcked-by: Samuel Ortiz <sameo@linux.intel.com>\nSigned-off-by: John W. Linville <linville@tuxdriver.com>",
        "before_after_code_files": [
          "include/linux/nfc.h||include/linux/nfc.h",
          "include/net/nfc/nci.h||include/net/nfc/nci.h",
          "include/net/nfc/nfc.h||include/net/nfc/nfc.h",
          "net/nfc/nci/ntf.c||net/nfc/nci/ntf.c",
          "net/nfc/netlink.c||net/nfc/netlink.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "net/nfc/nci/ntf.c||net/nfc/nci/ntf.c"
          ],
          "candidate": [
            "net/nfc/nci/ntf.c||net/nfc/nci/ntf.c"
          ]
        }
      },
      "candidate_diff": {
        "include/linux/nfc.h||include/linux/nfc.h": [
          "File: include/linux/nfc.h -> include/linux/nfc.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "101:  NFC_ATTR_TARGET_SENS_RES,",
          "102:  NFC_ATTR_TARGET_SEL_RES,",
          "103:  NFC_ATTR_TARGET_NFCID1,",
          "104:  NFC_ATTR_COMM_MODE,",
          "105:  NFC_ATTR_RF_MODE,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "106:  NFC_ATTR_TARGET_SENSB_RES,",
          "107:  NFC_ATTR_TARGET_SENSF_RES,",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "109: #define NFC_ATTR_MAX (__NFC_ATTR_AFTER_LAST - 1)",
          "111: #define NFC_DEVICE_NAME_MAXSIZE 8",
          "114: #define NFC_PROTO_JEWEL  1",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "116: #define NFC_NFCID1_MAXSIZE 10",
          "117: #define NFC_SENSB_RES_MAXSIZE 12",
          "118: #define NFC_SENSF_RES_MAXSIZE 18",
          "",
          "---------------"
        ],
        "include/net/nfc/nci.h||include/net/nfc/nci.h": [
          "File: include/net/nfc/nci.h -> include/net/nfc/nci.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "275:  __u8 sel_res;",
          "276: } __packed;",
          "278: struct activation_params_nfca_poll_iso_dep {",
          "279:  __u8 rats_res_len;",
          "280:  __u8 rats_res[20];",
          "281: };",
          "283: struct nci_rf_intf_activated_ntf {",
          "284:  __u8 rf_discovery_id;",
          "285:  __u8 rf_interface;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "278: struct rf_tech_specific_params_nfcb_poll {",
          "279:  __u8 sensb_res_len;",
          "281: } __packed;",
          "283: struct rf_tech_specific_params_nfcf_poll {",
          "284:  __u8 bit_rate;",
          "285:  __u8 sensf_res_len;",
          "287: } __packed;",
          "294: struct activation_params_nfcb_poll_iso_dep {",
          "295:  __u8 attrib_res_len;",
          "296:  __u8 attrib_res[50];",
          "297: };",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "292:  union {",
          "293:   struct rf_tech_specific_params_nfca_poll nfca_poll;",
          "294:  } rf_tech_specific_params;",
          "296:  __u8 data_exch_rf_tech_and_mode;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "310:   struct rf_tech_specific_params_nfcb_poll nfcb_poll;",
          "311:   struct rf_tech_specific_params_nfcf_poll nfcf_poll;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "301:  union {",
          "302:   struct activation_params_nfca_poll_iso_dep nfca_poll_iso_dep;",
          "303:  } activation_params;",
          "305: } __packed;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "321:   struct activation_params_nfcb_poll_iso_dep nfcb_poll_iso_dep;",
          "",
          "---------------"
        ],
        "include/net/nfc/nfc.h||include/net/nfc/nfc.h": [
          "File: include/net/nfc/nfc.h -> include/net/nfc/nfc.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "24: #ifndef __NET_NFC_H",
          "25: #define __NET_NFC_H",
          "27: #include <linux/device.h>",
          "28: #include <linux/skbuff.h>",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "27: #include <linux/nfc.h>",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "66: #define NFC_TARGET_IDX_ANY -1",
          "67: #define NFC_MAX_GT_LEN 48",
          "70: struct nfc_target {",
          "71:  u32 idx;",
          "",
          "[Removed Lines]",
          "68: #define NFC_MAX_NFCID1_LEN 10",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "73:  u16 sens_res;",
          "74:  u8 sel_res;",
          "75:  u8 nfcid1_len;",
          "77: };",
          "79: struct nfc_genl_data {",
          "",
          "[Removed Lines]",
          "76:  u8 nfcid1[NFC_MAX_NFCID1_LEN];",
          "",
          "[Added Lines]",
          "76:  u8 nfcid1[NFC_NFCID1_MAXSIZE];",
          "77:  u8 sensb_res_len;",
          "78:  u8 sensb_res[NFC_SENSB_RES_MAXSIZE];",
          "79:  u8 sensf_res_len;",
          "80:  u8 sensf_res[NFC_SENSF_RES_MAXSIZE];",
          "",
          "---------------"
        ],
        "net/nfc/nci/ntf.c||net/nfc/nci/ntf.c": [
          "File: net/nfc/nci/ntf.c -> net/nfc/nci/ntf.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "115:  return data;",
          "116: }",
          "118: static int nci_extract_activation_params_iso_dep(struct nci_dev *ndev,",
          "119:    struct nci_rf_intf_activated_ntf *ntf, __u8 *data)",
          "120: {",
          "121:  struct activation_params_nfca_poll_iso_dep *nfca_poll;",
          "123:  switch (ntf->activation_rf_tech_and_mode) {",
          "124:  case NCI_NFC_A_PASSIVE_POLL_MODE:",
          "125:   nfca_poll = &ntf->activation_params.nfca_poll_iso_dep;",
          "126:   nfca_poll->rats_res_len = *data++;",
          "127:   if (nfca_poll->rats_res_len > 0) {",
          "128:    memcpy(nfca_poll->rats_res,",
          "129:     data,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "118: static __u8 *nci_extract_rf_params_nfcb_passive_poll(struct nci_dev *ndev,",
          "119:    struct nci_rf_intf_activated_ntf *ntf, __u8 *data)",
          "120: {",
          "121:  struct rf_tech_specific_params_nfcb_poll *nfcb_poll;",
          "123:  nfcb_poll = &ntf->rf_tech_specific_params.nfcb_poll;",
          "125:  nfcb_poll->sensb_res_len = *data++;",
          "127:  pr_debug(\"sensb_res_len %d\\n\", nfcb_poll->sensb_res_len);",
          "129:  memcpy(nfcb_poll->sensb_res, data, nfcb_poll->sensb_res_len);",
          "130:  data += nfcb_poll->sensb_res_len;",
          "132:  return data;",
          "133: }",
          "135: static __u8 *nci_extract_rf_params_nfcf_passive_poll(struct nci_dev *ndev,",
          "136:    struct nci_rf_intf_activated_ntf *ntf, __u8 *data)",
          "137: {",
          "138:  struct rf_tech_specific_params_nfcf_poll *nfcf_poll;",
          "140:  nfcf_poll = &ntf->rf_tech_specific_params.nfcf_poll;",
          "142:  nfcf_poll->bit_rate = *data++;",
          "143:  nfcf_poll->sensf_res_len = *data++;",
          "145:  pr_debug(\"bit_rate %d, sensf_res_len %d\\n\",",
          "146:   nfcf_poll->bit_rate, nfcf_poll->sensf_res_len);",
          "148:  memcpy(nfcf_poll->sensf_res, data, nfcf_poll->sensf_res_len);",
          "149:  data += nfcf_poll->sensf_res_len;",
          "151:  return data;",
          "152: }",
          "158:  struct activation_params_nfcb_poll_iso_dep *nfcb_poll;",
          "164:   pr_debug(\"rats_res_len %d\\n\", nfca_poll->rats_res_len);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "131:   }",
          "132:   break;",
          "134:  default:",
          "135:   pr_err(\"unsupported activation_rf_tech_and_mode 0x%x\\n\",",
          "136:          ntf->activation_rf_tech_and_mode);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "172:  case NCI_NFC_B_PASSIVE_POLL_MODE:",
          "173:   nfcb_poll = &ntf->activation_params.nfcb_poll_iso_dep;",
          "174:   nfcb_poll->attrib_res_len = *data++;",
          "175:   pr_debug(\"attrib_res_len %d\\n\",",
          "176:    nfcb_poll->attrib_res_len);",
          "177:   if (nfcb_poll->attrib_res_len > 0) {",
          "178:    memcpy(nfcb_poll->attrib_res,",
          "179:     data,",
          "180:     nfcb_poll->attrib_res_len);",
          "181:   }",
          "182:   break;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "145: {",
          "146:  struct nfc_target nfc_tgt;",
          "149:   nfc_tgt.supported_protocols = NFC_PROTO_MIFARE_MASK;",
          "151:   nfc_tgt.supported_protocols = NFC_PROTO_ISO14443_MASK;",
          "164:  if (!(nfc_tgt.supported_protocols & ndev->poll_prots)) {",
          "165:   pr_debug(\"the target found does not have the desired protocol\\n\");",
          "",
          "[Removed Lines]",
          "152:  else",
          "153:   nfc_tgt.supported_protocols = 0;",
          "155:  nfc_tgt.sens_res = ntf->rf_tech_specific_params.nfca_poll.sens_res;",
          "156:  nfc_tgt.sel_res = ntf->rf_tech_specific_params.nfca_poll.sel_res;",
          "157:  nfc_tgt.nfcid1_len = ntf->rf_tech_specific_params.nfca_poll.nfcid1_len;",
          "158:  if (nfc_tgt.nfcid1_len > 0) {",
          "159:   memcpy(nfc_tgt.nfcid1,",
          "160:    ntf->rf_tech_specific_params.nfca_poll.nfcid1,",
          "161:    nfc_tgt.nfcid1_len);",
          "162:  }",
          "",
          "[Added Lines]",
          "198:  memset(&nfc_tgt, 0, sizeof(nfc_tgt));",
          "200:  if (ntf->rf_protocol == NCI_RF_PROTOCOL_T2T)",
          "202:  else if (ntf->rf_protocol == NCI_RF_PROTOCOL_ISO_DEP)",
          "204:  else if (ntf->rf_protocol == NCI_RF_PROTOCOL_T3T)",
          "205:   nfc_tgt.supported_protocols = NFC_PROTO_FELICA_MASK;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "169:  pr_debug(\"new target found,  supported_protocols 0x%x\\n\",",
          "170:    nfc_tgt.supported_protocols);",
          "172:  ndev->target_available_prots = nfc_tgt.supported_protocols;",
          "173:  ndev->max_data_pkt_payload_size = ntf->max_data_pkt_payload_size;",
          "174:  ndev->initial_num_credits = ntf->initial_num_credits;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "215:  if (ntf->activation_rf_tech_and_mode == NCI_NFC_A_PASSIVE_POLL_MODE) {",
          "216:   nfc_tgt.sens_res =",
          "217:    ntf->rf_tech_specific_params.nfca_poll.sens_res;",
          "218:   nfc_tgt.sel_res =",
          "219:    ntf->rf_tech_specific_params.nfca_poll.sel_res;",
          "220:   nfc_tgt.nfcid1_len =",
          "221:    ntf->rf_tech_specific_params.nfca_poll.nfcid1_len;",
          "222:   if (nfc_tgt.nfcid1_len > 0) {",
          "223:    memcpy(nfc_tgt.nfcid1,",
          "224:     ntf->rf_tech_specific_params.nfca_poll.nfcid1,",
          "225:     nfc_tgt.nfcid1_len);",
          "226:   }",
          "227:  } else if (ntf->activation_rf_tech_and_mode ==",
          "228:       NCI_NFC_B_PASSIVE_POLL_MODE) {",
          "229:   nfc_tgt.sensb_res_len =",
          "230:    ntf->rf_tech_specific_params.nfcb_poll.sensb_res_len;",
          "231:   if (nfc_tgt.sensb_res_len > 0) {",
          "232:    memcpy(nfc_tgt.sensb_res,",
          "233:           ntf->rf_tech_specific_params.nfcb_poll.sensb_res,",
          "234:           nfc_tgt.sensb_res_len);",
          "235:   }",
          "236:  } else if (ntf->activation_rf_tech_and_mode ==",
          "237:       NCI_NFC_F_PASSIVE_POLL_MODE) {",
          "238:   nfc_tgt.sensf_res_len =",
          "239:    ntf->rf_tech_specific_params.nfcf_poll.sensf_res_len;",
          "240:   if (nfc_tgt.sensf_res_len > 0) {",
          "241:    memcpy(nfc_tgt.sensf_res,",
          "242:           ntf->rf_tech_specific_params.nfcf_poll.sensf_res,",
          "243:           nfc_tgt.sensf_res_len);",
          "244:   }",
          "245:  }",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "215:     &ntf, data);",
          "216:    break;",
          "218:   default:",
          "219:    pr_err(\"unsupported activation_rf_tech_and_mode 0x%x\\n\",",
          "220:           ntf.activation_rf_tech_and_mode);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "293:   case NCI_NFC_B_PASSIVE_POLL_MODE:",
          "294:    data = nci_extract_rf_params_nfcb_passive_poll(ndev,",
          "295:     &ntf, data);",
          "296:    break;",
          "298:   case NCI_NFC_F_PASSIVE_POLL_MODE:",
          "299:    data = nci_extract_rf_params_nfcf_passive_poll(ndev,",
          "300:     &ntf, data);",
          "301:    break;",
          "",
          "---------------"
        ],
        "net/nfc/netlink.c||net/nfc/netlink.c": [
          "File: net/nfc/netlink.c -> net/nfc/netlink.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "70:  if (target->nfcid1_len > 0)",
          "71:   NLA_PUT(msg, NFC_ATTR_TARGET_NFCID1, target->nfcid1_len,",
          "72:     target->nfcid1);",
          "74:  return genlmsg_end(msg, hdr);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "73:  if (target->sensb_res_len > 0)",
          "74:   NLA_PUT(msg, NFC_ATTR_TARGET_SENSB_RES, target->sensb_res_len,",
          "75:     target->sensb_res);",
          "76:  if (target->sensf_res_len > 0)",
          "77:   NLA_PUT(msg, NFC_ATTR_TARGET_SENSF_RES, target->sensf_res_len,",
          "78:     target->sensf_res);",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2013-7348",
  "cve_desc": "Double free vulnerability in the ioctx_alloc function in fs/aio.c in the Linux kernel before 3.12.4 allows local users to cause a denial of service (system crash) or possibly have unspecified other impact via vectors involving an error condition in the aio_setup_ring function.",
  "repo": "torvalds/linux",
  "patch_hash": "d558023207e008a4476a3b7bb8706b2a2bf5d84f",
  "patch_info": {
    "commit_hash": "d558023207e008a4476a3b7bb8706b2a2bf5d84f",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/d558023207e008a4476a3b7bb8706b2a2bf5d84f",
    "files": [
      "fs/aio.c"
    ],
    "message": "aio: prevent double free in ioctx_alloc\n\nioctx_alloc() calls aio_setup_ring() to allocate a ring. If aio_setup_ring()\nfails to do so it would call aio_free_ring() before returning, but\nioctx_alloc() would call aio_free_ring() again causing a double free of\nthe ring.\n\nThis is easily reproducible from userspace.\n\nSigned-off-by: Sasha Levin <sasha.levin@oracle.com>\nSigned-off-by: Benjamin LaHaise <bcrl@kvack.org>",
    "before_after_code_files": [
      "fs/aio.c||fs/aio.c"
    ]
  },
  "patch_diff": {
    "fs/aio.c||fs/aio.c": [
      "File: fs/aio.c -> fs/aio.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "610: err_cleanup:",
      "611:  aio_nr_sub(ctx->max_reqs);",
      "612: err:",
      "614:  free_percpu(ctx->cpu);",
      "615:  free_percpu(ctx->reqs.pcpu_count);",
      "616:  free_percpu(ctx->users.pcpu_count);",
      "",
      "[Removed Lines]",
      "613:  aio_free_ring(ctx);",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "e1bdd5f27a5b14e24a658d5511bebceb67679d83",
      "candidate_info": {
        "commit_hash": "e1bdd5f27a5b14e24a658d5511bebceb67679d83",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/e1bdd5f27a5b14e24a658d5511bebceb67679d83",
        "files": [
          "fs/aio.c"
        ],
        "message": "aio: percpu reqs_available\n\nSee the previous patch (\"aio: reqs_active -> reqs_available\") for why we\nwant to do this - this basically implements a per cpu allocator for\nreqs_available that doesn't actually allocate anything.\n\nNote that we need to increase the size of the ringbuffer we allocate,\nsince a single thread won't necessarily be able to use all the\nreqs_available slots - some (up to about half) might be on other per cpu\nlists, unavailable for the current thread.\n\nWe size the ringbuffer based on the nr_events userspace passed to\nio_setup(), so this is a slight behaviour change - but nr_events wasn't\nbeing used as a hard limit before, it was being rounded up to the next\npage before so this doesn't change the actual semantics.\n\nSigned-off-by: Kent Overstreet <koverstreet@google.com>\nCc: Zach Brown <zab@redhat.com>\nCc: Felipe Balbi <balbi@ti.com>\nCc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>\nCc: Mark Fasheh <mfasheh@suse.com>\nCc: Joel Becker <jlbec@evilplan.org>\nCc: Rusty Russell <rusty@rustcorp.com.au>\nCc: Jens Axboe <axboe@kernel.dk>\nCc: Asai Thambi S P <asamymuthupa@micron.com>\nCc: Selvan Mani <smani@micron.com>\nCc: Sam Bradshaw <sbradshaw@micron.com>\nCc: Jeff Moyer <jmoyer@redhat.com>\nCc: Al Viro <viro@zeniv.linux.org.uk>\nCc: Benjamin LaHaise <bcrl@kvack.org>\nReviewed-by: \"Theodore Ts'o\" <tytso@mit.edu>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Benjamin LaHaise <bcrl@kvack.org>",
        "before_after_code_files": [
          "fs/aio.c||fs/aio.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "fs/aio.c||fs/aio.c"
          ],
          "candidate": [
            "fs/aio.c||fs/aio.c"
          ]
        }
      },
      "candidate_diff": {
        "fs/aio.c||fs/aio.c": [
          "File: fs/aio.c -> fs/aio.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "26: #include <linux/mm.h>",
          "27: #include <linux/mman.h>",
          "28: #include <linux/mmu_context.h>",
          "29: #include <linux/slab.h>",
          "30: #include <linux/timer.h>",
          "31: #include <linux/aio.h>",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "29: #include <linux/percpu.h>",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "65: #define AIO_RING_PAGES 8",
          "67: struct kioctx {",
          "68:  atomic_t  users;",
          "69:  atomic_t  dead;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "68: struct kioctx_cpu {",
          "69:  unsigned  reqs_available;",
          "70: };",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "72:  unsigned long  user_id;",
          "73:  struct hlist_node list;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "80:  struct __percpu kioctx_cpu *cpu;",
          "86:  unsigned  req_batch;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "379: static void free_ioctx_rcu(struct rcu_head *head)",
          "380: {",
          "381:  struct kioctx *ctx = container_of(head, struct kioctx, rcu_head);",
          "382:  kmem_cache_free(kioctx_cachep, ctx);",
          "383: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "397:  free_percpu(ctx->cpu);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "392:  struct aio_ring *ring;",
          "393:  struct io_event res;",
          "394:  struct kiocb *req;",
          "397:  spin_lock_irq(&ctx->ctx_lock);",
          "",
          "[Removed Lines]",
          "395:  unsigned head, avail;",
          "",
          "[Added Lines]",
          "411:  unsigned cpu, head, avail;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "407:  spin_unlock_irq(&ctx->ctx_lock);",
          "409:  ring = kmap_atomic(ctx->ring_pages[0]);",
          "410:  head = ring->head;",
          "411:  kunmap_atomic(ring);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "425:  for_each_possible_cpu(cpu) {",
          "426:   struct kioctx_cpu *kcpu = per_cpu_ptr(ctx->cpu, cpu);",
          "428:   atomic_add(kcpu->reqs_available, &ctx->reqs_available);",
          "429:   kcpu->reqs_available = 0;",
          "430:  }",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "454:  struct kioctx *ctx;",
          "455:  int err = -ENOMEM;",
          "458:  if ((nr_events > (0x10000000U / sizeof(struct io_event))) ||",
          "459:      (nr_events > (0x10000000U / sizeof(struct kiocb)))) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "489:  nr_events = max(nr_events, num_possible_cpus() * 4);",
          "490:  nr_events *= 2;",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "480:  INIT_LIST_HEAD(&ctx->active_reqs);",
          "483:   goto out_freectx;",
          "485:  atomic_set(&ctx->reqs_available, ctx->nr_events - 1);",
          "488:  spin_lock(&aio_nr_lock);",
          "",
          "[Removed Lines]",
          "482:  if (aio_setup_ring(ctx) < 0)",
          "",
          "[Added Lines]",
          "517:  ctx->cpu = alloc_percpu(struct kioctx_cpu);",
          "518:  if (!ctx->cpu)",
          "521:  if (aio_setup_ring(ctx) < 0)",
          "522:   goto out_freepcpu;",
          "525:  ctx->req_batch = (ctx->nr_events - 1) / (num_possible_cpus() * 4);",
          "526:  BUG_ON(!ctx->req_batch);",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "506: out_cleanup:",
          "507:  err = -EAGAIN;",
          "508:  aio_free_ring(ctx);",
          "509: out_freectx:",
          "510:  if (ctx->aio_ring_file)",
          "511:   fput(ctx->aio_ring_file);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "550: out_freepcpu:",
          "551:  free_percpu(ctx->cpu);",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "610:  }",
          "611: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "656: static void put_reqs_available(struct kioctx *ctx, unsigned nr)",
          "657: {",
          "658:  struct kioctx_cpu *kcpu;",
          "660:  preempt_disable();",
          "661:  kcpu = this_cpu_ptr(ctx->cpu);",
          "663:  kcpu->reqs_available += nr;",
          "664:  while (kcpu->reqs_available >= ctx->req_batch * 2) {",
          "665:   kcpu->reqs_available -= ctx->req_batch;",
          "666:   atomic_add(ctx->req_batch, &ctx->reqs_available);",
          "667:  }",
          "669:  preempt_enable();",
          "670: }",
          "672: static bool get_reqs_available(struct kioctx *ctx)",
          "673: {",
          "674:  struct kioctx_cpu *kcpu;",
          "675:  bool ret = false;",
          "677:  preempt_disable();",
          "678:  kcpu = this_cpu_ptr(ctx->cpu);",
          "680:  if (!kcpu->reqs_available) {",
          "681:   int old, avail = atomic_read(&ctx->reqs_available);",
          "683:   do {",
          "684:    if (avail < ctx->req_batch)",
          "685:     goto out;",
          "687:    old = avail;",
          "688:    avail = atomic_cmpxchg(&ctx->reqs_available,",
          "689:             avail, avail - ctx->req_batch);",
          "690:   } while (avail != old);",
          "692:   kcpu->reqs_available += ctx->req_batch;",
          "693:  }",
          "695:  ret = true;",
          "696:  kcpu->reqs_available--;",
          "697: out:",
          "698:  preempt_enable();",
          "699:  return ret;",
          "700: }",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "624: {",
          "625:  struct kiocb *req;",
          "628:   return NULL;",
          "630:  req = kmem_cache_alloc(kiocb_cachep, GFP_KERNEL|__GFP_ZERO);",
          "",
          "[Removed Lines]",
          "627:  if (atomic_dec_if_positive(&ctx->reqs_available) <= 0)",
          "",
          "[Added Lines]",
          "716:  if (!get_reqs_available(ctx))",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "634:  atomic_set(&req->ki_users, 2);",
          "635:  req->ki_ctx = ctx;",
          "637:  return req;",
          "638: out_put:",
          "640:  return NULL;",
          "641: }",
          "",
          "[Removed Lines]",
          "639:  atomic_inc(&ctx->reqs_available);",
          "",
          "[Added Lines]",
          "727:  put_reqs_available(ctx, 1);",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "864:  pr_debug(\"%li  h%u t%u\\n\", ret, head, ctx->tail);",
          "867: out:",
          "868:  mutex_unlock(&ctx->ring_lock);",
          "",
          "[Removed Lines]",
          "866:  atomic_add(ret, &ctx->reqs_available);",
          "",
          "[Added Lines]",
          "958:  put_reqs_available(ctx, ret);",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "1248:  return 0;",
          "1249: out_put_req:",
          "1253:  return ret;",
          "",
          "[Removed Lines]",
          "1250:  atomic_inc(&ctx->reqs_available);",
          "",
          "[Added Lines]",
          "1342:  put_reqs_available(ctx, 1);",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2016-4303",
  "cve_desc": "The parse_string function in cjson.c in the cJSON library mishandles UTF8/16 strings, which allows remote attackers to cause a denial of service (crash) or execute arbitrary code via a non-hex character in a JSON string, which triggers a heap-based buffer overflow.",
  "repo": "esnet/iperf",
  "patch_hash": "91f2fa59e8ed80dfbf400add0164ee0e508e412a",
  "patch_info": {
    "commit_hash": "91f2fa59e8ed80dfbf400add0164ee0e508e412a",
    "repo": "esnet/iperf",
    "commit_url": "https://github.com/esnet/iperf/commit/91f2fa59e8ed80dfbf400add0164ee0e508e412a",
    "files": [
      "configure.ac",
      "src/cjson.c",
      "src/cjson.h",
      "src/iperf_api.c",
      "src/iperf_util.c"
    ],
    "message": "Fix a buffer overflow / heap corruption issue that could occur if a malformed JSON string was passed on the control channel.  This issue, present in the cJSON library, was already fixed upstream, so was addressed here in iperf3 by importing a newer version of cJSON (plus local ESnet modifications).\n\nDiscovered and reported by Dave McDaniel, Cisco Talos.\n\nBased on a patch by @dopheide-esnet, with input from @DaveGamble.\n\nCross-references:  TALOS-CAN-0164, ESNET-SECADV-2016-0001,\nCVE-2016-4303\n\n(cherry picked from commit ed94082be27d971a5e1b08b666e2c217cf470a40)\nSigned-off-by: Bruce A. Mah <bmah@es.net>",
    "before_after_code_files": [
      "configure.ac||configure.ac",
      "src/cjson.c||src/cjson.c",
      "src/cjson.h||src/cjson.h",
      "src/iperf_api.c||src/iperf_api.c",
      "src/iperf_util.c||src/iperf_util.c"
    ]
  },
  "patch_diff": {
    "configure.ac||configure.ac": [
      "File: configure.ac -> configure.ac",
      "--- Hunk 1 ---",
      "[Context before]",
      "62: # Check for systems which need -lsocket and -lnsl",
      "63: #AX_LIB_SOCKET_NSL",
      "65: # Solaris puts nanosleep in -lrt",
      "66: AC_SEARCH_LIBS(nanosleep, [rt], [], [",
      "67: echo \"nanosleep() required for timing operations.\"",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "65: # Check for the math library (needed by cjson on some platforms)",
      "66: AC_SEARCH_LIBS(floor, [m], [], [",
      "67: echo \"floor()\"",
      "68: exit 1",
      "69: ])",
      "",
      "---------------"
    ],
    "src/cjson.c||src/cjson.c": [
      "File: src/cjson.c -> src/cjson.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "40: #ifndef LLONG_MIN",
      "41: #define LLONG_MIN (-LLONG_MAX - 1LL)",
      "42: #endif",
      "54: {",
      "62:  return tolower(*(const unsigned char *)s1) - tolower(*(const unsigned char *)s2);",
      "63: }",
      "70: {",
      "83: {",
      "92: }",
      "97: {",
      "101:  return node;",
      "102: }",
      "107: {",
      "108:  cJSON *next;",
      "120:  }",
      "121: }",
      "125: {",
      "136:  }",
      "205: }",
      "210: {",
      "211:  char *str;",
      "224:  }",
      "225:  return str;",
      "226: }",
      "230: static const unsigned char firstByteMark[7] = { 0x00, 0x00, 0xC0, 0xE0, 0xF0, 0xF8, 0xFC };",
      "233: {",
      "260:    ptr++;",
      "287:      }",
      "303:      }",
      "305:      break;",
      "307:    }",
      "309:   }",
      "310:  }",
      "316:  return ptr;",
      "317: }",
      "322: {",
      "337:  }",
      "363:    }",
      "364:   }",
      "365:  }",
      "368:  return out;",
      "369: }",
      "398: {",
      "408:  return c;",
      "409: }",
      "418: {",
      "420: }",
      "425: {",
      "453: }",
      "471:  }",
      "472:  return out;",
      "473: }",
      "478: {",
      "479:  cJSON *child;",
      "498:   cJSON *new_item;",
      "506:  }",
      "513: }",
      "518: {",
      "519:  char **entries;",
      "560:  }",
      "574:   }",
      "576:  }",
      "580:  return out;",
      "581: }",
      "586: {",
      "587:  cJSON *child;",
      "615:   cJSON *new_item;",
      "632:  }",
      "639: }",
      "644: {",
      "695:   }",
      "699:  }",
      "725:  }",
      "734:  return out;",
      "735: }",
      "1033: }",
      "",
      "[Removed Lines]",
      "45: static const char *ep;",
      "47: const char *cJSON_GetErrorPtr( void )",
      "48: {",
      "49:  return ep;",
      "50: }",
      "53: static int cJSON_strcasecmp( const char *s1, const char *s2 )",
      "55:  if ( ! s1 )",
      "56:   return ( s1 == s2 ) ? 0 : 1;",
      "57:  if ( ! s2 )",
      "58:   return 1;",
      "59:  for ( ; tolower(*s1) == tolower(*s2); ++s1, ++s2)",
      "60:   if( *s1 == 0 )",
      "61:    return 0;",
      "66: static void *(*cJSON_malloc)( size_t ) = malloc;",
      "67: static void (*cJSON_free)( void * ) = free;",
      "69: void cJSON_InitHooks(cJSON_Hooks* hooks)",
      "71:  if ( ! hooks ) {",
      "73:   cJSON_malloc = malloc;",
      "74:   cJSON_free = free;",
      "75:   return;",
      "76:  }",
      "77:  cJSON_malloc = (hooks->malloc_fn) ? hooks->malloc_fn : malloc;",
      "78:  cJSON_free = (hooks->free_fn) ? hooks->free_fn : free;",
      "79: }",
      "82: static char* cJSON_strdup( const char* str )",
      "84:  size_t len;",
      "85:  char* copy;",
      "87:  len = strlen( str ) + 1;",
      "88:  if ( ! ( copy = (char*) cJSON_malloc( len ) ) )",
      "89:   return 0;",
      "90:  memcpy( copy, str, len );",
      "91:  return copy;",
      "96: static cJSON *cJSON_New_Item( void )",
      "98:  cJSON* node = (cJSON*) cJSON_malloc( sizeof(cJSON) );",
      "99:  if ( node )",
      "100:   memset( node, 0, sizeof(cJSON) );",
      "106: void cJSON_Delete( cJSON *c )",
      "110:  while ( c ) {",
      "111:   next = c->next;",
      "112:   if ( ! ( c->type & cJSON_IsReference ) && c->child )",
      "113:    cJSON_Delete( c->child );",
      "114:   if ( ! ( c->type & cJSON_IsReference ) && c->valuestring )",
      "115:    cJSON_free( c->valuestring );",
      "116:   if ( c->string )",
      "117:    cJSON_free( c->string );",
      "118:   cJSON_free( c );",
      "119:   c = next;",
      "124: static double ipow( double n, int exp )",
      "126:  double r;",
      "128:  if ( exp < 0 )",
      "129:   return 1.0 / ipow( n, -exp );",
      "130:  r = 1;",
      "131:  while ( exp > 0 ) {",
      "132:   if ( exp & 1 )",
      "133:    r *= n;",
      "134:   exp >>= 1;",
      "135:   n *= n;",
      "137:  return r;",
      "138: }",
      "142: static const char *parse_number( cJSON *item, const char *num )",
      "143: {",
      "144:  int64_t i = 0;",
      "145:  double f = 0;",
      "146:  int isint = 1;",
      "147:  int sign = 1, scale = 0, subscale = 0, signsubscale = 1;",
      "150:  if ( *num == '-' ) {",
      "152:   sign = -1;",
      "153:   ++num;",
      "154:  }",
      "155:  if ( *num == '0' )",
      "157:   ++num;",
      "158:  if ( *num >= '1' && *num<='9' ) {",
      "160:   do {",
      "161:    i = ( i * 10 ) + ( *num - '0' );",
      "162:    f = ( f * 10.0 ) + ( *num - '0' );",
      "163:    ++num;",
      "164:   } while ( *num >= '0' && *num <= '9' );",
      "165:  }",
      "166:  if ( *num == '.' && num[1] >= '0' && num[1] <= '9' ) {",
      "168:   isint = 0;",
      "169:   ++num;",
      "170:   do {",
      "171:    f = ( f * 10.0 ) + ( *num++ - '0' );",
      "172:    scale--;",
      "173:   } while ( *num >= '0' && *num <= '9' );",
      "174:  }",
      "175:  if ( *num == 'e' || *num == 'E' ) {",
      "177:   isint = 0;",
      "178:   ++num;",
      "179:   if ( *num == '+' )",
      "180:    ++num;",
      "181:   else if ( *num == '-' ) {",
      "183:    signsubscale = -1;",
      "184:    ++num;",
      "185:   }",
      "186:   while ( *num >= '0' && *num <= '9' )",
      "187:    subscale = ( subscale * 10 ) + ( *num++ - '0' );",
      "188:  }",
      "191:  if ( isint ) {",
      "193:   i = sign * i;",
      "194:   item->valueint = i;",
      "195:   item->valuefloat = i;",
      "196:  } else {",
      "198:   f = sign * f * ipow( 10.0, scale + subscale * signsubscale );",
      "199:   item->valueint = f;",
      "200:   item->valuefloat = f;",
      "201:  }",
      "203:  item->type = cJSON_Number;",
      "204:  return num;",
      "209: static char *print_number( cJSON *item )",
      "212:  double f, f2;",
      "213:  int64_t i;",
      "215:  str = (char*) cJSON_malloc( 64 );",
      "216:  if ( str ) {",
      "217:   f = item->valuefloat;",
      "218:   i = f;",
      "219:   f2 = i;",
      "220:   if ( f2 == f && item->valueint >= LLONG_MIN && item->valueint <= LLONG_MAX )",
      "221:    sprintf( str, \"%lld\", (long long) item->valueint );",
      "222:   else",
      "223:    sprintf( str, \"%g\", item->valuefloat );",
      "232: static const char *parse_string( cJSON *item, const char *str )",
      "234:  const char *ptr = str + 1;",
      "235:  char *ptr2;",
      "236:  char *out;",
      "237:  int len = 0;",
      "238:  unsigned uc, uc2;",
      "240:  if ( *str != '\\\"' ) {",
      "242:   ep = str;",
      "243:   return 0;",
      "244:  }",
      "247:  while ( *ptr != '\\\"' && *ptr && ++len )",
      "248:   if ( *ptr++ == '\\\\' )",
      "249:    ptr++;",
      "251:  if ( ! ( out = (char*) cJSON_malloc( len + 1 ) ) )",
      "252:   return 0;",
      "254:  ptr = str + 1;",
      "255:  ptr2 = out;",
      "256:  while ( *ptr != '\\\"' && *ptr ) {",
      "257:   if ( *ptr != '\\\\' )",
      "259:   else {",
      "261:    switch ( *ptr ) {",
      "262:     case 'b': *ptr2++ ='\\b'; break;",
      "263:     case 'f': *ptr2++ ='\\f'; break;",
      "264:     case 'n': *ptr2++ ='\\n'; break;",
      "265:     case 'r': *ptr2++ ='\\r'; break;",
      "266:     case 't': *ptr2++ ='\\t'; break;",
      "267:     case 'u':",
      "270:      sscanf( ptr + 1,\"%4x\", &uc );",
      "271:      ptr += 4;",
      "273:      if ( ( uc >= 0xDC00 && uc <= 0xDFFF ) || uc == 0 )",
      "274:       break;",
      "277:      if ( uc >= 0xD800 && uc <= 0xDBFF ) {",
      "278:       if ( ptr[1] != '\\\\' || ptr[2] != 'u' )",
      "280:        break;",
      "281:       sscanf( ptr + 3, \"%4x\", &uc2 );",
      "282:       ptr += 6;",
      "283:       if ( uc2 < 0xDC00 || uc2 > 0xDFFF )",
      "285:        break;",
      "286:       uc = 0x10000 | ( ( uc & 0x3FF ) << 10 ) | ( uc2 & 0x3FF );",
      "289:      len = 4;",
      "290:      if ( uc < 0x80 )",
      "291:       len = 1;",
      "292:      else if ( uc < 0x800 )",
      "293:       len = 2;",
      "294:      else if ( uc < 0x10000 )",
      "295:       len = 3;",
      "296:      ptr2 += len;",
      "298:      switch ( len ) {",
      "299:       case 4: *--ptr2 = ( ( uc | 0x80) & 0xBF ); uc >>= 6;",
      "300:       case 3: *--ptr2 = ( ( uc | 0x80) & 0xBF ); uc >>= 6;",
      "301:       case 2: *--ptr2 = ( ( uc | 0x80) & 0xBF ); uc >>= 6;",
      "302:       case 1: *--ptr2 = ( uc | firstByteMark[len] );",
      "304:      ptr2 += len;",
      "306:     default:  *ptr2++ = *ptr; break;",
      "308:    ++ptr;",
      "312:  if ( *ptr == '\\\"' )",
      "313:   ++ptr;",
      "314:  item->valuestring = out;",
      "315:  item->type = cJSON_String;",
      "321: static char *print_string_ptr( const char *str )",
      "323:  const char *ptr;",
      "324:  char *ptr2, *out;",
      "325:  int len = 0;",
      "326:  unsigned char token;",
      "328:  if ( ! str )",
      "329:   return cJSON_strdup( \"\" );",
      "330:  ptr = str;",
      "331:  while ( ( token = *ptr ) && ++len ) {",
      "332:   if ( strchr( \"\\\"\\\\\\b\\f\\n\\r\\t\", token ) )",
      "333:    ++len;",
      "334:   else if ( token < 32 )",
      "335:    len += 5;",
      "336:   ++ptr;",
      "339:  if ( ! ( out = (char*) cJSON_malloc( len + 3 ) ) )",
      "340:   return 0;",
      "342:  ptr2 = out;",
      "343:  ptr = str;",
      "345:  while ( *ptr ) {",
      "346:   if ( (unsigned char) *ptr > 31 && *ptr != '\\\"' && *ptr != '\\\\' )",
      "348:   else {",
      "350:    switch ( token = *ptr++ ) {",
      "351:     case '\\\\': *ptr2++ = '\\\\'; break;",
      "352:     case '\\\"': *ptr2++ = '\\\"'; break;",
      "353:     case '\\b': *ptr2++ = 'b'; break;",
      "354:     case '\\f': *ptr2++ = 'f'; break;",
      "355:     case '\\n': *ptr2++ = 'n'; break;",
      "356:     case '\\r': *ptr2++ = 'r'; break;",
      "357:     case '\\t': *ptr2++ = 't'; break;",
      "358:     default:",
      "360:     sprintf( ptr2, \"u%04x\", token );",
      "361:     ptr2 += 5;",
      "362:     break;",
      "373: static char *print_string( cJSON *item )",
      "374: {",
      "375:  return print_string_ptr( item->valuestring );",
      "376: }",
      "380: static const char *parse_value( cJSON *item, const char *value );",
      "381: static char *print_value( cJSON *item, int depth, int fmt );",
      "382: static const char *parse_array( cJSON *item, const char *value );",
      "383: static char *print_array( cJSON *item, int depth, int fmt );",
      "384: static const char *parse_object( cJSON *item, const char *value );",
      "385: static char *print_object( cJSON *item, int depth, int fmt );",
      "388: static const char *skip( const char *in )",
      "389: {",
      "390:  while ( in && *in && (unsigned char) *in <= 32 )",
      "391:   in++;",
      "392:  return in;",
      "393: }",
      "397: cJSON *cJSON_Parse( const char *value )",
      "399:  cJSON *c;",
      "400:  ep = 0;",
      "401:  if ( ! ( c = cJSON_New_Item() ) )",
      "404:  if ( ! parse_value( c, skip( value ) ) ) {",
      "405:   cJSON_Delete( c );",
      "406:   return 0;",
      "407:  }",
      "413: char *cJSON_Print( cJSON *item )",
      "414: {",
      "415:  return print_value( item, 0, 1 );",
      "416: }",
      "417: char *cJSON_PrintUnformatted( cJSON *item )",
      "419:  return print_value( item, 0, 0 );",
      "424: static const char *parse_value( cJSON *item, const char *value )",
      "426:  if ( ! value )",
      "428:  if ( ! strncmp( value, \"null\", 4 ) ) {",
      "429:   item->type = cJSON_NULL;",
      "430:   return value + 4;",
      "431:  }",
      "432:  if ( ! strncmp( value, \"false\", 5 ) ) {",
      "433:   item->type = cJSON_False;",
      "434:   return value + 5;",
      "435:  }",
      "436:  if ( ! strncmp( value, \"true\", 4 ) ) {",
      "437:   item->type = cJSON_True;",
      "438:   item->valueint = 1;",
      "439:   return value + 4;",
      "440:  }",
      "441:  if ( *value == '\\\"' )",
      "442:   return parse_string( item, value );",
      "443:  if ( *value == '-' || ( *value >= '0' && *value <= '9' ) )",
      "444:   return parse_number( item, value );",
      "445:  if ( *value == '[' )",
      "446:   return parse_array( item, value );",
      "447:  if ( *value == '{' )",
      "448:   return parse_object( item, value );",
      "451:  ep = value;",
      "452:  return 0;",
      "457: static char *print_value( cJSON *item, int depth, int fmt )",
      "458: {",
      "459:  char *out = 0;",
      "461:  if ( ! item )",
      "462:   return 0;",
      "463:  switch ( ( item->type ) & 255 ) {",
      "464:   case cJSON_NULL:   out = cJSON_strdup( \"null\" ); break;",
      "465:   case cJSON_False:  out = cJSON_strdup( \"false\" ); break;",
      "466:   case cJSON_True:   out = cJSON_strdup( \"true\" ); break;",
      "467:   case cJSON_Number: out = print_number( item ); break;",
      "468:   case cJSON_String: out = print_string( item ); break;",
      "469:   case cJSON_Array:  out = print_array( item, depth, fmt ); break;",
      "470:   case cJSON_Object: out = print_object( item, depth, fmt ); break;",
      "477: static const char *parse_array( cJSON *item, const char *value )",
      "481:  if ( *value != '[' ) {",
      "483:   ep = value;",
      "484:   return 0;",
      "485:  }",
      "487:  item->type = cJSON_Array;",
      "488:  value = skip( value + 1 );",
      "489:  if ( *value == ']' )",
      "492:  if ( ! ( item->child = child = cJSON_New_Item() ) )",
      "494:  if ( ! ( value = skip( parse_value( child, skip( value ) ) ) ) )",
      "495:   return 0;",
      "497:  while ( *value == ',' ) {",
      "499:   if ( ! ( new_item = cJSON_New_Item() ) )",
      "501:   child->next = new_item;",
      "502:   new_item->prev = child;",
      "503:   child = new_item;",
      "504:   if ( ! ( value = skip( parse_value( child, skip( value+1 ) ) ) ) )",
      "508:  if ( *value == ']' )",
      "511:  ep = value;",
      "512:  return 0;",
      "517: static char *print_array( cJSON *item, int depth, int fmt )",
      "520:  char *out = 0, *ptr, *ret;",
      "521:  int len = 5;",
      "522:  cJSON *child = item->child;",
      "523:  int numentries = 0, i = 0, fail = 0;",
      "526:  while ( child ) {",
      "527:   ++numentries;",
      "528:   child = child->next;",
      "529:  }",
      "531:  if ( ! ( entries = (char**) cJSON_malloc( numentries * sizeof(char*) ) ) )",
      "532:   return 0;",
      "533:  memset( entries, 0, numentries * sizeof(char*) );",
      "535:  child = item->child;",
      "536:  while ( child && ! fail ) {",
      "537:   ret = print_value( child, depth + 1, fmt );",
      "538:   entries[i++] = ret;",
      "539:   if ( ret )",
      "540:    len += strlen( ret ) + 2 + ( fmt ? 1 : 0 );",
      "541:   else",
      "542:    fail = 1;",
      "543:   child = child -> next;",
      "544:  }",
      "547:  if ( ! fail ) {",
      "548:   out = (char*) cJSON_malloc( len );",
      "549:   if ( ! out )",
      "550:    fail = 1;",
      "551:  }",
      "554:  if ( fail ) {",
      "555:   for ( i = 0; i < numentries; ++i )",
      "556:    if ( entries[i] )",
      "557:     cJSON_free( entries[i] );",
      "558:   cJSON_free( entries );",
      "559:   return 0;",
      "564:  ptr = out + 1;",
      "566:  for ( i = 0; i < numentries; ++i ) {",
      "567:   strcpy( ptr, entries[i] );",
      "568:   ptr += strlen( entries[i] );",
      "569:   if ( i != numentries - 1 ) {",
      "571:    if ( fmt )",
      "575:   cJSON_free( entries[i] );",
      "577:  cJSON_free( entries );",
      "585: static const char *parse_object( cJSON *item, const char *value )",
      "589:  if ( *value != '{' ) {",
      "591:   ep = value;",
      "592:   return 0;",
      "593:  }",
      "595:  item->type = cJSON_Object;",
      "596:  value =skip( value + 1 );",
      "597:  if ( *value == '}' )",
      "600:  if ( ! ( item->child = child = cJSON_New_Item() ) )",
      "601:   return 0;",
      "602:  if ( ! ( value = skip( parse_string( child, skip( value ) ) ) ) )",
      "603:   return 0;",
      "604:  child->string = child->valuestring;",
      "605:  child->valuestring = 0;",
      "606:  if ( *value != ':' ) {",
      "608:   ep = value;",
      "609:   return 0;",
      "610:  }",
      "611:  if ( ! ( value = skip( parse_value( child, skip( value + 1 ) ) ) ) )",
      "612:   return 0;",
      "614:  while ( *value == ',' ) {",
      "616:   if ( ! ( new_item = cJSON_New_Item() ) )",
      "618:   child->next = new_item;",
      "619:   new_item->prev = child;",
      "620:   child = new_item;",
      "621:   if ( ! ( value = skip( parse_string( child, skip( value + 1 ) ) ) ) )",
      "622:    return 0;",
      "623:   child->string = child->valuestring;",
      "624:   child->valuestring = 0;",
      "625:   if ( *value != ':' ) {",
      "627:    ep = value;",
      "628:    return 0;",
      "629:   }",
      "630:   if ( ! ( value = skip( parse_value( child, skip( value + 1 ) ) ) ) )",
      "631:    return 0;",
      "634:  if ( *value == '}' )",
      "637:  ep = value;",
      "638:  return 0;",
      "643: static char *print_object( cJSON *item, int depth, int fmt )",
      "645:  char **entries = 0, **names = 0;",
      "646:  char *out = 0, *ptr, *ret, *str;",
      "647:  int len = 7, i = 0, j;",
      "648:  cJSON *child = item->child;",
      "649:  int numentries = 0, fail = 0;",
      "652:  while ( child ) {",
      "653:   ++numentries;",
      "654:   child = child->next;",
      "655:  }",
      "657:  if ( ! ( entries = (char**) cJSON_malloc( numentries * sizeof(char*) ) ) )",
      "658:   return 0;",
      "659:  if ( ! ( names = (char**) cJSON_malloc( numentries * sizeof(char*) ) ) ) {",
      "660:   cJSON_free( entries );",
      "661:   return 0;",
      "662:  }",
      "663:  memset( entries, 0, sizeof(char*) * numentries );",
      "664:  memset( names, 0, sizeof(char*) * numentries );",
      "667:  child = item->child;",
      "668:  ++depth;",
      "669:  if ( fmt )",
      "670:   len += depth;",
      "671:  while ( child ) {",
      "672:   names[i] = str = print_string_ptr( child->string );",
      "673:   entries[i++] = ret = print_value( child, depth, fmt );",
      "674:   if ( str && ret )",
      "675:    len += strlen( ret ) + strlen( str ) + 2 + ( fmt ? 2 + depth : 0 );",
      "676:   else",
      "677:    fail = 1;",
      "678:   child = child->next;",
      "679:  }",
      "682:  if ( ! fail ) {",
      "683:   out = (char*) cJSON_malloc( len );",
      "684:   if ( ! out )",
      "685:    fail = 1;",
      "686:  }",
      "689:  if ( fail ) {",
      "690:   for ( i = 0; i < numentries; ++i ) {",
      "691:    if ( names[i] )",
      "692:     cJSON_free( names[i] );",
      "693:    if ( entries[i] )",
      "694:     cJSON_free( entries[i] );",
      "696:   cJSON_free( names );",
      "697:   cJSON_free( entries );",
      "698:   return 0;",
      "703:  ptr = out + 1;",
      "704:  if ( fmt )",
      "707:  for ( i = 0; i < numentries; ++i ) {",
      "708:   if ( fmt )",
      "709:    for ( j = 0; j < depth; ++j )",
      "711:   strcpy( ptr, names[i] );",
      "712:   ptr += strlen( names[i] );",
      "714:   if ( fmt )",
      "716:   strcpy( ptr, entries[i] );",
      "717:   ptr += strlen( entries[i] );",
      "718:   if ( i != numentries - 1 )",
      "720:   if ( fmt )",
      "723:   cJSON_free( names[i] );",
      "724:   cJSON_free( entries[i] );",
      "727:  cJSON_free( names );",
      "728:  cJSON_free( entries );",
      "729:  if ( fmt )",
      "730:   for ( i = 0; i < depth - 1; ++i )",
      "738: int cJSON_GetArraySize( cJSON *array )",
      "739: {",
      "740:  cJSON *c = array->child;",
      "741:  int i = 0;",
      "742:  while ( c ) {",
      "743:   ++i;",
      "744:   c = c->next;",
      "745:  }",
      "746:  return i;",
      "747: }",
      "750: cJSON *cJSON_GetArrayItem( cJSON *array, int item )",
      "751: {",
      "752:  cJSON *c = array->child;",
      "753:  while ( c && item > 0 ) {",
      "754:   --item;",
      "755:   c = c->next;",
      "756:  }",
      "757:  return c;",
      "758: }",
      "761: cJSON *cJSON_GetObjectItem( cJSON *object, const char *string )",
      "762: {",
      "763:  cJSON *c = object->child;",
      "764:  while ( c && cJSON_strcasecmp( c->string, string ) )",
      "765:   c = c->next;",
      "766:  return c;",
      "767: }",
      "771: static void suffix_object( cJSON *prev, cJSON *item )",
      "772: {",
      "773:  prev->next = item;",
      "774:  item->prev = prev;",
      "775: }",
      "779: static cJSON *create_reference( cJSON *item )",
      "780: {",
      "781:  cJSON *ref;",
      "782:  if ( ! ( ref = cJSON_New_Item() ) )",
      "783:   return 0;",
      "784:  memcpy( ref, item, sizeof(cJSON) );",
      "785:  ref->string = 0;",
      "786:  ref->type |= cJSON_IsReference;",
      "787:  ref->next = ref->prev = 0;",
      "788:  return ref;",
      "789: }",
      "793: void cJSON_AddItemToArray( cJSON *array, cJSON *item )",
      "794: {",
      "795:  cJSON *c = array->child;",
      "796:  if ( ! item )",
      "797:   return;",
      "798:  if ( ! c ) {",
      "799:   array->child = item;",
      "800:  } else {",
      "801:   while ( c && c->next )",
      "802:    c = c->next;",
      "803:   suffix_object( c, item );",
      "804:  }",
      "805: }",
      "807: void cJSON_AddItemToObject( cJSON *object, const char *string, cJSON *item )",
      "808: {",
      "809:  if ( ! item )",
      "810:   return;",
      "811:  if ( item->string )",
      "812:   cJSON_free( item->string );",
      "813:  item->string = cJSON_strdup( string );",
      "814:  cJSON_AddItemToArray( object, item );",
      "815: }",
      "817: void cJSON_AddItemReferenceToArray( cJSON *array, cJSON *item )",
      "818: {",
      "819:  cJSON_AddItemToArray( array, create_reference( item ) );",
      "820: }",
      "822: void cJSON_AddItemReferenceToObject( cJSON *object, const char *string, cJSON *item )",
      "823: {",
      "824:  cJSON_AddItemToObject( object, string, create_reference( item ) );",
      "825: }",
      "827: cJSON *cJSON_DetachItemFromArray( cJSON *array, int which )",
      "828: {",
      "829:  cJSON *c = array->child;",
      "830:  while ( c && which > 0 ) {",
      "831:   c = c->next;",
      "832:   --which;",
      "833:  }",
      "834:  if ( ! c )",
      "835:   return 0;",
      "836:  if ( c->prev )",
      "837:   c->prev->next = c->next;",
      "838:  if ( c->next ) c->next->prev = c->prev;",
      "839:  if ( c == array->child )",
      "840:   array->child = c->next;",
      "841:  c->prev = c->next = 0;",
      "842:  return c;",
      "843: }",
      "845: void cJSON_DeleteItemFromArray( cJSON *array, int which )",
      "846: {",
      "847:  cJSON_Delete( cJSON_DetachItemFromArray( array, which ) );",
      "848: }",
      "850: cJSON *cJSON_DetachItemFromObject( cJSON *object, const char *string )",
      "851: {",
      "852:  int i = 0;",
      "853:  cJSON *c = object->child;",
      "854:  while ( c && cJSON_strcasecmp( c->string, string ) ) {",
      "855:   ++i;",
      "856:   c = c->next;",
      "857:  }",
      "858:  if ( c )",
      "859:   return cJSON_DetachItemFromArray( object, i );",
      "860:  return 0;",
      "861: }",
      "863: void cJSON_DeleteItemFromObject( cJSON *object, const char *string )",
      "864: {",
      "865:  cJSON_Delete( cJSON_DetachItemFromObject( object, string ) );",
      "866: }",
      "869: void cJSON_ReplaceItemInArray( cJSON *array, int which, cJSON *newitem )",
      "870: {",
      "871:  cJSON *c = array->child;",
      "872:  while ( c && which > 0 ) {",
      "873:   c = c->next;",
      "874:   --which;",
      "875:  }",
      "876:  if ( ! c )",
      "877:   return;",
      "878:  newitem->next = c->next;",
      "879:  newitem->prev = c->prev;",
      "880:  if ( newitem->next )",
      "881:   newitem->next->prev = newitem;",
      "882:  if ( c == array->child )",
      "883:   array->child = newitem;",
      "884:  else",
      "885:   newitem->prev->next = newitem;",
      "886:  c->next = c->prev = 0;",
      "887:  cJSON_Delete( c );",
      "888: }",
      "890: void cJSON_ReplaceItemInObject( cJSON *object, const char *string, cJSON *newitem )",
      "891: {",
      "892:  int i = 0;",
      "893:  cJSON *c = object->child;",
      "894:  while ( c && cJSON_strcasecmp( c->string, string ) ) {",
      "895:   ++i;",
      "896:   c = c->next;",
      "897:  }",
      "898:  if ( c ) {",
      "899:   newitem->string = cJSON_strdup( string );",
      "900:   cJSON_ReplaceItemInArray( object, i, newitem );",
      "901:  }",
      "902: }",
      "907: cJSON *cJSON_CreateNull( void )",
      "908: {",
      "909:  cJSON *item = cJSON_New_Item();",
      "910:  if ( item )",
      "911:   item->type = cJSON_NULL;",
      "912:  return item;",
      "913: }",
      "915: cJSON *cJSON_CreateTrue( void )",
      "916: {",
      "917:  cJSON *item = cJSON_New_Item();",
      "918:  if ( item )",
      "919:   item->type = cJSON_True;",
      "920:  return item;",
      "921: }",
      "923: cJSON *cJSON_CreateFalse( void )",
      "924: {",
      "925:  cJSON *item = cJSON_New_Item();",
      "926:  if ( item )",
      "927:   item->type = cJSON_False;",
      "928:  return item;",
      "929: }",
      "931: cJSON *cJSON_CreateBool( int b )",
      "932: {",
      "933:  cJSON *item = cJSON_New_Item();",
      "934:  if ( item )",
      "935:   item->type = b ? cJSON_True : cJSON_False;",
      "936:  return item;",
      "937: }",
      "939: cJSON *cJSON_CreateInt( int64_t num )",
      "940: {",
      "941:  cJSON *item = cJSON_New_Item();",
      "942:  if ( item ) {",
      "943:   item->type = cJSON_Number;",
      "944:   item->valuefloat = num;",
      "945:   item->valueint = num;",
      "946:  }",
      "947:  return item;",
      "948: }",
      "950: cJSON *cJSON_CreateFloat( double num )",
      "951: {",
      "952:  cJSON *item = cJSON_New_Item();",
      "953:  if ( item ) {",
      "954:   item->type = cJSON_Number;",
      "955:   item->valuefloat = num;",
      "956:   item->valueint = num;",
      "957:  }",
      "958:  return item;",
      "959: }",
      "961: cJSON *cJSON_CreateString( const char *string )",
      "962: {",
      "963:  cJSON *item = cJSON_New_Item();",
      "964:  if ( item ) {",
      "965:   item->type = cJSON_String;",
      "966:   item->valuestring = cJSON_strdup( string );",
      "967:  }",
      "968:  return item;",
      "969: }",
      "971: cJSON *cJSON_CreateArray( void )",
      "972: {",
      "973:  cJSON *item = cJSON_New_Item();",
      "974:  if ( item )",
      "975:   item->type = cJSON_Array;",
      "976:  return item;",
      "977: }",
      "979: cJSON *cJSON_CreateObject( void )",
      "980: {",
      "981:  cJSON *item = cJSON_New_Item();",
      "982:  if ( item )",
      "983:   item->type = cJSON_Object;",
      "984:  return item;",
      "985: }",
      "990: cJSON *cJSON_CreateIntArray( int64_t *numbers, int count )",
      "991: {",
      "992:  int i;",
      "993:  cJSON *n = 0, *p = 0, *a = cJSON_CreateArray();",
      "994:  for ( i = 0; a && i < count; ++i ) {",
      "995:   n = cJSON_CreateInt( numbers[i] );",
      "996:   if ( ! i )",
      "997:    a->child = n;",
      "998:   else",
      "999:    suffix_object( p, n );",
      "1000:   p = n;",
      "1001:  }",
      "1002:  return a;",
      "1003: }",
      "1005: cJSON *cJSON_CreateFloatArray( double *numbers, int count )",
      "1006: {",
      "1007:  int i;",
      "1008:  cJSON *n = 0, *p = 0, *a = cJSON_CreateArray();",
      "1009:  for ( i = 0; a && i < count; ++i ) {",
      "1010:   n = cJSON_CreateFloat( numbers[i] );",
      "1011:   if ( ! i )",
      "1012:    a->child = n;",
      "1013:   else",
      "1014:    suffix_object( p, n );",
      "1015:   p = n;",
      "1016:  }",
      "1017:  return a;",
      "1018: }",
      "1020: cJSON *cJSON_CreateStringArray( const char **strings, int count )",
      "1021: {",
      "1022:  int i;",
      "1023:  cJSON *n = 0, *p = 0, *a = cJSON_CreateArray();",
      "1024:  for ( i = 0; a && i < count; ++i ) {",
      "1025:   n = cJSON_CreateString( strings[i] );",
      "1026:   if ( ! i )",
      "1027:    a->child = n;",
      "1028:   else",
      "1029:    suffix_object( p, n );",
      "1030:   p = n;",
      "1031:  }",
      "1032:  return a;",
      "",
      "[Added Lines]",
      "43: static const char *global_ep;",
      "45: const char *cJSON_GetErrorPtr(void) {return global_ep;}",
      "47: static int cJSON_strcasecmp(const char *s1,const char *s2)",
      "49:  if (!s1) return (s1==s2)?0:1;if (!s2) return 1;",
      "50:  for(; tolower(*s1) == tolower(*s2); ++s1, ++s2) if(*s1 == 0) return 0;",
      "54: static void *(*cJSON_malloc)(size_t sz) = malloc;",
      "55: static void (*cJSON_free)(void *ptr) = free;",
      "57: static char* cJSON_strdup(const char* str)",
      "59:       size_t len;",
      "60:       char* copy;",
      "62:       len = strlen(str) + 1;",
      "63:       if (!(copy = (char*)cJSON_malloc(len))) return 0;",
      "64:       memcpy(copy,str,len);",
      "65:       return copy;",
      "66: }",
      "68: void cJSON_InitHooks(cJSON_Hooks* hooks)",
      "71:         cJSON_malloc = malloc;",
      "72:         cJSON_free = free;",
      "73:         return;",
      "74:     }",
      "76:  cJSON_malloc = (hooks->malloc_fn)?hooks->malloc_fn:malloc;",
      "77:  cJSON_free  = (hooks->free_fn)?hooks->free_fn:free;",
      "81: static cJSON *cJSON_New_Item(void)",
      "83:  cJSON* node = (cJSON*)cJSON_malloc(sizeof(cJSON));",
      "84:  if (node) memset(node,0,sizeof(cJSON));",
      "89: void cJSON_Delete(cJSON *c)",
      "92:  while (c)",
      "93:  {",
      "94:   next=c->next;",
      "95:   if (!(c->type&cJSON_IsReference) && c->child) cJSON_Delete(c->child);",
      "96:   if (!(c->type&cJSON_IsReference) && c->valuestring) cJSON_free(c->valuestring);",
      "97:   if (!(c->type&cJSON_StringIsConst) && c->string) cJSON_free(c->string);",
      "98:   cJSON_free(c);",
      "99:   c=next;",
      "104: static const char *parse_number(cJSON *item,const char *num)",
      "106:  double n=0,sign=1,scale=0;int subscale=0,signsubscale=1;",
      "119:  item->valuedouble=n;",
      "120:  item->valueint=(int64_t)n;",
      "121:  item->type=cJSON_Number;",
      "122:  return num;",
      "123: }",
      "125: static int pow2gt (int x) { --x; x|=x>>1; x|=x>>2; x|=x>>4; x|=x>>8; x|=x>>16; return x+1; }",
      "127: typedef struct {char *buffer; int length; int offset; } printbuffer;",
      "129: static char* ensure(printbuffer *p,int needed)",
      "130: {",
      "131:  char *newbuffer;int newsize;",
      "132:  if (!p || !p->buffer) return 0;",
      "133:  needed+=p->offset;",
      "134:  if (needed<=p->length) return p->buffer+p->offset;",
      "136:  newsize=pow2gt(needed);",
      "137:  newbuffer=(char*)cJSON_malloc(newsize);",
      "138:  if (!newbuffer) {cJSON_free(p->buffer);p->length=0,p->buffer=0;return 0;}",
      "139:  if (newbuffer) memcpy(newbuffer,p->buffer,p->length);",
      "140:  cJSON_free(p->buffer);",
      "141:  p->length=newsize;",
      "142:  p->buffer=newbuffer;",
      "143:  return newbuffer+p->offset;",
      "146: static int update(printbuffer *p)",
      "149:  if (!p || !p->buffer) return 0;",
      "150:  str=p->buffer+p->offset;",
      "151:  return p->offset+strlen(str);",
      "152: }",
      "155: static char *print_number(cJSON *item,printbuffer *p)",
      "156: {",
      "157:  char *str=0;",
      "158:  double d=item->valuedouble;",
      "159:  if (d==0)",
      "160:  {",
      "161:   if (p) str=ensure(p,2);",
      "163:   if (str) strcpy(str,\"0\");",
      "164:  }",
      "165:  else if (fabs(((double)item->valueint)-d)<=DBL_EPSILON && d<=LLONG_MAX && d>=LLONG_MIN)",
      "166:  {",
      "167:   if (p) str=ensure(p,64);",
      "168:   else str=(char*)cJSON_malloc(64);",
      "169:   if (str) sprintf(str,\"%lld\",(long long) item->valueint);",
      "170:  }",
      "171:  else",
      "172:  {",
      "173:   if (p) str=ensure(p,64);",
      "175:   if (str)",
      "176:   {",
      "177:    if (fpclassify(d) != FP_ZERO && !isnormal(d))    sprintf(str,\"null\");",
      "178:    else if (fabs(floor(d)-d)<=DBL_EPSILON && fabs(d)<1.0e60) sprintf(str,\"%.0f\",d);",
      "179:    else if (fabs(d)<1.0e-6 || fabs(d)>1.0e9)     sprintf(str,\"%e\",d);",
      "180:    else              sprintf(str,\"%f\",d);",
      "181:   }",
      "186: static unsigned parse_hex4(const char *str)",
      "187: {",
      "188:  unsigned h=0;",
      "189:  if (*str>='0' && *str<='9') h+=(*str)-'0'; else if (*str>='A' && *str<='F') h+=10+(*str)-'A'; else if (*str>='a' && *str<='f') h+=10+(*str)-'a'; else return 0;",
      "190:  h=h<<4;str++;",
      "191:  if (*str>='0' && *str<='9') h+=(*str)-'0'; else if (*str>='A' && *str<='F') h+=10+(*str)-'A'; else if (*str>='a' && *str<='f') h+=10+(*str)-'a'; else return 0;",
      "192:  h=h<<4;str++;",
      "193:  if (*str>='0' && *str<='9') h+=(*str)-'0'; else if (*str>='A' && *str<='F') h+=10+(*str)-'A'; else if (*str>='a' && *str<='f') h+=10+(*str)-'a'; else return 0;",
      "194:  h=h<<4;str++;",
      "195:  if (*str>='0' && *str<='9') h+=(*str)-'0'; else if (*str>='A' && *str<='F') h+=10+(*str)-'A'; else if (*str>='a' && *str<='f') h+=10+(*str)-'a'; else return 0;",
      "196:  return h;",
      "197: }",
      "201: static const char *parse_string(cJSON *item,const char *str,const char **ep)",
      "203:  const char *ptr=str+1,*end_ptr=str+1;char *ptr2;char *out;int len=0;unsigned uc,uc2;",
      "209:  if (!out) return 0;",
      "211:  item->type=cJSON_String;",
      "213:  ptr=str+1;ptr2=out;",
      "214:  while (ptr < end_ptr)",
      "215:  {",
      "216:   if (*ptr!='\\\\') *ptr2++=*ptr++;",
      "217:   else",
      "218:   {",
      "220:    switch (*ptr)",
      "221:    {",
      "222:     case 'b': *ptr2++='\\b'; break;",
      "223:     case 'f': *ptr2++='\\f'; break;",
      "224:     case 'n': *ptr2++='\\n'; break;",
      "225:     case 'r': *ptr2++='\\r'; break;",
      "226:     case 't': *ptr2++='\\t'; break;",
      "234:      {",
      "237:       uc2=parse_hex4(ptr+3);ptr+=6;",
      "239:       uc=0x10000 + (((uc&0x3FF)<<10) | (uc2&0x3FF));",
      "242:      len=4;if (uc<0x80) len=1;else if (uc<0x800) len=2;else if (uc<0x10000) len=3; ptr2+=len;",
      "244:      switch (len) {",
      "245:       case 4: *--ptr2 =((uc | 0x80) & 0xBF); uc >>= 6;",
      "246:       case 3: *--ptr2 =((uc | 0x80) & 0xBF); uc >>= 6;",
      "247:       case 2: *--ptr2 =((uc | 0x80) & 0xBF); uc >>= 6;",
      "248:       case 1: *--ptr2 =(uc | firstByteMark[len]);",
      "250:      ptr2+=len;",
      "252:     default:  *ptr2++=*ptr; break;",
      "254:    ptr++;",
      "258:  if (*ptr=='\\\"') ptr++;",
      "263: static char *print_string_ptr(const char *str,printbuffer *p)",
      "265:  const char *ptr;char *ptr2,*out;int len=0,flag=0;unsigned char token;",
      "267:  if (!str)",
      "268:  {",
      "269:   if (p) out=ensure(p,3);",
      "270:   else out=(char*)cJSON_malloc(3);",
      "271:   if (!out) return 0;",
      "272:   strcpy(out,\"\\\"\\\"\");",
      "273:   return out;",
      "274:  }",
      "276:  for (ptr=str;*ptr;ptr++) flag|=((*ptr>0 && *ptr<32)||(*ptr=='\\\"')||(*ptr=='\\\\'))?1:0;",
      "277:  if (!flag)",
      "278:  {",
      "279:   len=ptr-str;",
      "280:   if (p) out=ensure(p,len+3);",
      "281:   else  out=(char*)cJSON_malloc(len+3);",
      "282:   if (!out) return 0;",
      "283:   ptr2=out;*ptr2++='\\\"';",
      "284:   strcpy(ptr2,str);",
      "285:   ptr2[len]='\\\"';",
      "286:   ptr2[len+1]=0;",
      "287:   return out;",
      "290:  ptr=str;while ((token=*ptr) && ++len) {if (strchr(\"\\\"\\\\\\b\\f\\n\\r\\t\",token)) len++; else if (token<32) len+=5;ptr++;}",
      "292:  if (p) out=ensure(p,len+3);",
      "293:  else out=(char*)cJSON_malloc(len+3);",
      "294:  if (!out) return 0;",
      "296:  ptr2=out;ptr=str;",
      "298:  while (*ptr)",
      "299:  {",
      "300:   if ((unsigned char)*ptr>31 && *ptr!='\\\"' && *ptr!='\\\\') *ptr2++=*ptr++;",
      "301:   else",
      "302:   {",
      "304:    switch (token=*ptr++)",
      "305:    {",
      "306:     case '\\\\': *ptr2++='\\\\'; break;",
      "307:     case '\\\"': *ptr2++='\\\"'; break;",
      "308:     case '\\b': *ptr2++='b'; break;",
      "309:     case '\\f': *ptr2++='f'; break;",
      "310:     case '\\n': *ptr2++='n'; break;",
      "311:     case '\\r': *ptr2++='r'; break;",
      "312:     case '\\t': *ptr2++='t'; break;",
      "321: static char *print_string(cJSON *item,printbuffer *p) {return print_string_ptr(item->valuestring,p);}",
      "324: static const char *parse_value(cJSON *item,const char *value,const char **ep);",
      "325: static char *print_value(cJSON *item,int depth,int fmt,printbuffer *p);",
      "326: static const char *parse_array(cJSON *item,const char *value,const char **ep);",
      "327: static char *print_array(cJSON *item,int depth,int fmt,printbuffer *p);",
      "328: static const char *parse_object(cJSON *item,const char *value,const char **ep);",
      "329: static char *print_object(cJSON *item,int depth,int fmt,printbuffer *p);",
      "332: static const char *skip(const char *in) {while (in && *in && (unsigned char)*in<=32) in++; return in;}",
      "335: cJSON *cJSON_ParseWithOpts(const char *value,const char **return_parse_end,int require_null_terminated)",
      "337:  const char *end=0,**ep=return_parse_end?return_parse_end:&global_ep;",
      "338:  cJSON *c=cJSON_New_Item();",
      "342:  end=parse_value(c,skip(value),ep);",
      "346:  if (require_null_terminated) {end=skip(end);if (*end) {cJSON_Delete(c);*ep=end;return 0;}}",
      "347:  if (return_parse_end) *return_parse_end=end;",
      "351: cJSON *cJSON_Parse(const char *value) {return cJSON_ParseWithOpts(value,0,0);}",
      "354: char *cJSON_Print(cJSON *item)    {return print_value(item,0,1,0);}",
      "355: char *cJSON_PrintUnformatted(cJSON *item) {return print_value(item,0,0,0);}",
      "357: char *cJSON_PrintBuffered(cJSON *item,int prebuffer,int fmt)",
      "359:  printbuffer p;",
      "360:  p.buffer=(char*)cJSON_malloc(prebuffer);",
      "361:  p.length=prebuffer;",
      "362:  p.offset=0;",
      "363:  return print_value(item,0,fmt,&p);",
      "368: static const char *parse_value(cJSON *item,const char *value,const char **ep)",
      "371:  if (!strncmp(value,\"null\",4)) { item->type=cJSON_NULL;  return value+4; }",
      "372:  if (!strncmp(value,\"false\",5)) { item->type=cJSON_False; return value+5; }",
      "373:  if (!strncmp(value,\"true\",4)) { item->type=cJSON_True; item->valueint=1; return value+4; }",
      "374:  if (*value=='\\\"')    { return parse_string(item,value,ep); }",
      "375:  if (*value=='-' || (*value>='0' && *value<='9')) { return parse_number(item,value); }",
      "376:  if (*value=='[')    { return parse_array(item,value,ep); }",
      "377:  if (*value=='{')    { return parse_object(item,value,ep); }",
      "383: static char *print_value(cJSON *item,int depth,int fmt,printbuffer *p)",
      "384: {",
      "385:  char *out=0;",
      "386:  if (!item) return 0;",
      "387:  if (p)",
      "388:  {",
      "389:   switch ((item->type)&255)",
      "390:   {",
      "391:    case cJSON_NULL: {out=ensure(p,5); if (out) strcpy(out,\"null\"); break;}",
      "392:    case cJSON_False: {out=ensure(p,6); if (out) strcpy(out,\"false\"); break;}",
      "393:    case cJSON_True: {out=ensure(p,5); if (out) strcpy(out,\"true\"); break;}",
      "394:    case cJSON_Number: out=print_number(item,p);break;",
      "395:    case cJSON_String: out=print_string(item,p);break;",
      "396:    case cJSON_Array: out=print_array(item,depth,fmt,p);break;",
      "397:    case cJSON_Object: out=print_object(item,depth,fmt,p);break;",
      "398:   }",
      "399:  }",
      "400:  else",
      "401:  {",
      "402:   switch ((item->type)&255)",
      "403:   {",
      "404:    case cJSON_NULL: out=cJSON_strdup(\"null\"); break;",
      "405:    case cJSON_False: out=cJSON_strdup(\"false\");break;",
      "406:    case cJSON_True: out=cJSON_strdup(\"true\"); break;",
      "407:    case cJSON_Number: out=print_number(item,0);break;",
      "408:    case cJSON_String: out=print_string(item,0);break;",
      "409:    case cJSON_Array: out=print_array(item,depth,fmt,0);break;",
      "410:    case cJSON_Object: out=print_object(item,depth,fmt,0);break;",
      "411:   }",
      "417: static const char *parse_array(cJSON *item,const char *value,const char **ep)",
      "422:  item->type=cJSON_Array;",
      "423:  value=skip(value+1);",
      "426:  item->child=child=cJSON_New_Item();",
      "429:  if (!value) return 0;",
      "431:  while (*value==',')",
      "432:  {",
      "435:   child->next=new_item;new_item->prev=child;child=new_item;",
      "436:   value=skip(parse_value(child,skip(value+1),ep));",
      "445: static char *print_array(cJSON *item,int depth,int fmt,printbuffer *p)",
      "448:  char *out=0,*ptr,*ret;int len=5;",
      "449:  cJSON *child=item->child;",
      "450:  int numentries=0,i=0,fail=0;",
      "451:  size_t tmplen=0;",
      "454:  while (child) numentries++,child=child->next;",
      "456:  if (!numentries)",
      "457:  {",
      "458:   if (p) out=ensure(p,3);",
      "459:   else out=(char*)cJSON_malloc(3);",
      "460:   if (out) strcpy(out,\"[]\");",
      "461:   return out;",
      "462:  }",
      "464:  if (p)",
      "465:  {",
      "467:   i=p->offset;",
      "468:   ptr=ensure(p,1);if (!ptr) return 0; *ptr='['; p->offset++;",
      "469:   child=item->child;",
      "470:   while (child && !fail)",
      "471:   {",
      "472:    print_value(child,depth+1,fmt,p);",
      "473:    p->offset=update(p);",
      "474:    if (child->next) {len=fmt?2:1;ptr=ensure(p,len+1);if (!ptr) return 0;*ptr++=',';if(fmt)*ptr++=' ';*ptr=0;p->offset+=len;}",
      "475:    child=child->next;",
      "476:   }",
      "477:   ptr=ensure(p,2);if (!ptr) return 0; *ptr++=']';*ptr=0;",
      "478:   out=(p->buffer)+i;",
      "480:  else",
      "481:  {",
      "483:   entries=(char**)cJSON_malloc(numentries*sizeof(char*));",
      "484:   if (!entries) return 0;",
      "485:   memset(entries,0,numentries*sizeof(char*));",
      "487:   child=item->child;",
      "488:   while (child && !fail)",
      "489:   {",
      "490:    ret=print_value(child,depth+1,fmt,0);",
      "491:    entries[i++]=ret;",
      "492:    if (ret) len+=strlen(ret)+2+(fmt?1:0); else fail=1;",
      "493:    child=child->next;",
      "497:   if (!fail) out=(char*)cJSON_malloc(len);",
      "499:   if (!out) fail=1;",
      "502:   if (fail)",
      "503:   {",
      "504:    for (i=0;i<numentries;i++) if (entries[i]) cJSON_free(entries[i]);",
      "505:    cJSON_free(entries);",
      "506:    return 0;",
      "507:   }",
      "511:   ptr=out+1;*ptr=0;",
      "512:   for (i=0;i<numentries;i++)",
      "513:   {",
      "514:    tmplen=strlen(entries[i]);memcpy(ptr,entries[i],tmplen);ptr+=tmplen;",
      "515:    if (i!=numentries-1) {*ptr++=',';if(fmt)*ptr++=' ';*ptr=0;}",
      "516:    cJSON_free(entries[i]);",
      "517:   }",
      "518:   cJSON_free(entries);",
      "525: static const char *parse_object(cJSON *item,const char *value,const char **ep)",
      "530:  item->type=cJSON_Object;",
      "531:  value=skip(value+1);",
      "534:  item->child=child=cJSON_New_Item();",
      "535:  if (!item->child) return 0;",
      "536:  value=skip(parse_string(child,skip(value),ep));",
      "537:  if (!value) return 0;",
      "538:  child->string=child->valuestring;child->valuestring=0;",
      "541:  if (!value) return 0;",
      "543:  while (*value==',')",
      "544:  {",
      "547:   child->next=new_item;new_item->prev=child;child=new_item;",
      "548:   value=skip(parse_string(child,skip(value+1),ep));",
      "549:   if (!value) return 0;",
      "550:   child->string=child->valuestring;child->valuestring=0;",
      "553:   if (!value) return 0;",
      "561: static char *print_object(cJSON *item,int depth,int fmt,printbuffer *p)",
      "563:  char **entries=0,**names=0;",
      "564:  char *out=0,*ptr,*ret,*str;int len=7,i=0,j;",
      "565:  cJSON *child=item->child;",
      "566:  int numentries=0,fail=0;",
      "567:  size_t tmplen=0;",
      "569:  while (child) numentries++,child=child->next;",
      "571:  if (!numentries)",
      "572:  {",
      "573:   if (p) out=ensure(p,fmt?depth+4:3);",
      "574:   else out=(char*)cJSON_malloc(fmt?depth+4:3);",
      "575:   if (!out) return 0;",
      "576:   ptr=out;*ptr++='{';",
      "577:   if (fmt) {*ptr++='\\n';for (i=0;i<depth;i++) *ptr++='\\t';}",
      "579:   return out;",
      "580:  }",
      "581:  if (p)",
      "582:  {",
      "584:   i=p->offset;",
      "585:   len=fmt?2:1; ptr=ensure(p,len+1); if (!ptr) return 0;",
      "587:   child=item->child;depth++;",
      "588:   while (child)",
      "589:   {",
      "590:    if (fmt)",
      "591:    {",
      "592:     ptr=ensure(p,depth); if (!ptr) return 0;",
      "593:     for (j=0;j<depth;j++) *ptr++='\\t';",
      "594:     p->offset+=depth;",
      "595:    }",
      "596:    print_string_ptr(child->string,p);",
      "597:    p->offset=update(p);",
      "599:    len=fmt?2:1;",
      "600:    ptr=ensure(p,len); if (!ptr) return 0;",
      "602:    p->offset+=len;",
      "604:    print_value(child,depth,fmt,p);",
      "605:    p->offset=update(p);",
      "607:    len=(fmt?1:0)+(child->next?1:0);",
      "608:    ptr=ensure(p,len+1); if (!ptr) return 0;",
      "609:    if (child->next) *ptr++=',';",
      "610:    if (fmt) *ptr++='\\n';*ptr=0;",
      "611:    p->offset+=len;",
      "612:    child=child->next;",
      "614:   ptr=ensure(p,fmt?(depth+1):2);  if (!ptr) return 0;",
      "615:   if (fmt) for (i=0;i<depth-1;i++) *ptr++='\\t';",
      "617:   out=(p->buffer)+i;",
      "619:  else",
      "620:  {",
      "622:   entries=(char**)cJSON_malloc(numentries*sizeof(char*));",
      "623:   if (!entries) return 0;",
      "624:   names=(char**)cJSON_malloc(numentries*sizeof(char*));",
      "625:   if (!names) {cJSON_free(entries);return 0;}",
      "626:   memset(entries,0,sizeof(char*)*numentries);",
      "627:   memset(names,0,sizeof(char*)*numentries);",
      "630:   child=item->child;depth++;if (fmt) len+=depth;",
      "631:   while (child && !fail)",
      "632:   {",
      "633:    names[i]=str=print_string_ptr(child->string,0);",
      "634:    entries[i++]=ret=print_value(child,depth,fmt,0);",
      "635:    if (str && ret) len+=strlen(ret)+strlen(str)+2+(fmt?2+depth:0); else fail=1;",
      "636:    child=child->next;",
      "637:   }",
      "640:   if (!fail) out=(char*)cJSON_malloc(len);",
      "641:   if (!out) fail=1;",
      "644:   if (fail)",
      "645:   {",
      "646:    for (i=0;i<numentries;i++) {if (names[i]) cJSON_free(names[i]);if (entries[i]) cJSON_free(entries[i]);}",
      "647:    cJSON_free(names);cJSON_free(entries);",
      "648:    return 0;",
      "649:   }",
      "653:   for (i=0;i<numentries;i++)",
      "654:   {",
      "655:    if (fmt) for (j=0;j<depth;j++) *ptr++='\\t';",
      "656:    tmplen=strlen(names[i]);memcpy(ptr,names[i],tmplen);ptr+=tmplen;",
      "658:    strcpy(ptr,entries[i]);ptr+=strlen(entries[i]);",
      "659:    if (i!=numentries-1) *ptr++=',';",
      "660:    if (fmt) *ptr++='\\n';*ptr=0;",
      "661:    cJSON_free(names[i]);cJSON_free(entries[i]);",
      "662:   }",
      "664:   cJSON_free(names);cJSON_free(entries);",
      "665:   if (fmt) for (i=0;i<depth-1;i++) *ptr++='\\t';",
      "672: int    cJSON_GetArraySize(cJSON *array)       {cJSON *c=array->child;int i=0;while(c)i++,c=c->next;return i;}",
      "673: cJSON *cJSON_GetArrayItem(cJSON *array,int item)    {cJSON *c=array?array->child:0;while (c && item>0) item--,c=c->next; return c;}",
      "674: cJSON *cJSON_GetObjectItem(cJSON *object,const char *string) {cJSON *c=object?object->child:0;while (c && cJSON_strcasecmp(c->string,string)) c=c->next; return c;}",
      "675: int cJSON_HasObjectItem(cJSON *object,const char *string)  {return cJSON_GetObjectItem(object,string)?1:0;}",
      "678: static void suffix_object(cJSON *prev,cJSON *item) {prev->next=item;item->prev=prev;}",
      "680: static cJSON *create_reference(cJSON *item) {cJSON *ref=cJSON_New_Item();if (!ref) return 0;memcpy(ref,item,sizeof(cJSON));ref->string=0;ref->type|=cJSON_IsReference;ref->next=ref->prev=0;return ref;}",
      "683: void   cJSON_AddItemToArray(cJSON *array, cJSON *item)      {cJSON *c=array->child;if (!item) return; if (!c) {array->child=item;} else {while (c && c->next) c=c->next; suffix_object(c,item);}}",
      "684: void   cJSON_AddItemToObject(cJSON *object,const char *string,cJSON *item) {if (!item) return; if (item->string) cJSON_free(item->string);item->string=cJSON_strdup(string);cJSON_AddItemToArray(object,item);}",
      "685: void   cJSON_AddItemToObjectCS(cJSON *object,const char *string,cJSON *item) {if (!item) return; if (!(item->type&cJSON_StringIsConst) && item->string) cJSON_free(item->string);item->string=(char*)string;item->type|=cJSON_StringIsConst;cJSON_AddItemToArray(object,item);}",
      "686: void cJSON_AddItemReferenceToArray(cJSON *array, cJSON *item)      {cJSON_AddItemToArray(array,create_reference(item));}",
      "687: void cJSON_AddItemReferenceToObject(cJSON *object,const char *string,cJSON *item) {cJSON_AddItemToObject(object,string,create_reference(item));}",
      "689: cJSON *cJSON_DetachItemFromArray(cJSON *array,int which)   {cJSON *c=array->child;while (c && which>0) c=c->next,which--;if (!c) return 0;",
      "690:  if (c->prev) c->prev->next=c->next;if (c->next) c->next->prev=c->prev;if (c==array->child) array->child=c->next;c->prev=c->next=0;return c;}",
      "691: void   cJSON_DeleteItemFromArray(cJSON *array,int which)   {cJSON_Delete(cJSON_DetachItemFromArray(array,which));}",
      "692: cJSON *cJSON_DetachItemFromObject(cJSON *object,const char *string) {int i=0;cJSON *c=object->child;while (c && cJSON_strcasecmp(c->string,string)) i++,c=c->next;if (c) return cJSON_DetachItemFromArray(object,i);return 0;}",
      "693: void   cJSON_DeleteItemFromObject(cJSON *object,const char *string) {cJSON_Delete(cJSON_DetachItemFromObject(object,string));}",
      "696: void   cJSON_InsertItemInArray(cJSON *array,int which,cJSON *newitem)  {cJSON *c=array->child;while (c && which>0) c=c->next,which--;if (!c) {cJSON_AddItemToArray(array,newitem);return;}",
      "697:  newitem->next=c;newitem->prev=c->prev;c->prev=newitem;if (c==array->child) array->child=newitem; else newitem->prev->next=newitem;}",
      "698: void   cJSON_ReplaceItemInArray(cJSON *array,int which,cJSON *newitem)  {cJSON *c=array->child;while (c && which>0) c=c->next,which--;if (!c) return;",
      "699:  newitem->next=c->next;newitem->prev=c->prev;if (newitem->next) newitem->next->prev=newitem;",
      "700:  if (c==array->child) array->child=newitem; else newitem->prev->next=newitem;c->next=c->prev=0;cJSON_Delete(c);}",
      "701: void   cJSON_ReplaceItemInObject(cJSON *object,const char *string,cJSON *newitem){int i=0;cJSON *c=object->child;while(c && cJSON_strcasecmp(c->string,string))i++,c=c->next;if(c){newitem->string=cJSON_strdup(string);cJSON_ReplaceItemInArray(object,i,newitem);}}",
      "704: cJSON *cJSON_CreateNull(void)     {cJSON *item=cJSON_New_Item();if(item)item->type=cJSON_NULL;return item;}",
      "705: cJSON *cJSON_CreateTrue(void)     {cJSON *item=cJSON_New_Item();if(item)item->type=cJSON_True;return item;}",
      "706: cJSON *cJSON_CreateFalse(void)     {cJSON *item=cJSON_New_Item();if(item)item->type=cJSON_False;return item;}",
      "707: cJSON *cJSON_CreateBool(int b)     {cJSON *item=cJSON_New_Item();if(item)item->type=b?cJSON_True:cJSON_False;return item;}",
      "708: cJSON *cJSON_CreateNumber(double num)   {cJSON *item=cJSON_New_Item();if(item){item->type=cJSON_Number;item->valuedouble=num;item->valueint=(int64_t)num;}return item;}",
      "709: cJSON *cJSON_CreateString(const char *string) {cJSON *item=cJSON_New_Item();if(item){item->type=cJSON_String;item->valuestring=cJSON_strdup(string);if(!item->valuestring){cJSON_Delete(item);return 0;}}return item;}",
      "710: cJSON *cJSON_CreateArray(void)     {cJSON *item=cJSON_New_Item();if(item)item->type=cJSON_Array;return item;}",
      "711: cJSON *cJSON_CreateObject(void)     {cJSON *item=cJSON_New_Item();if(item)item->type=cJSON_Object;return item;}",
      "714: cJSON *cJSON_CreateIntArray(const int *numbers,int count)  {int i;cJSON *n=0,*p=0,*a=cJSON_CreateArray();for(i=0;a && i<count;i++){n=cJSON_CreateNumber(numbers[i]);if(!n){cJSON_Delete(a);return 0;}if(!i)a->child=n;else suffix_object(p,n);p=n;}return a;}",
      "715: cJSON *cJSON_CreateFloatArray(const float *numbers,int count) {int i;cJSON *n=0,*p=0,*a=cJSON_CreateArray();for(i=0;a && i<count;i++){n=cJSON_CreateNumber(numbers[i]);if(!n){cJSON_Delete(a);return 0;}if(!i)a->child=n;else suffix_object(p,n);p=n;}return a;}",
      "716: cJSON *cJSON_CreateDoubleArray(const double *numbers,int count) {int i;cJSON *n=0,*p=0,*a=cJSON_CreateArray();for(i=0;a && i<count;i++){n=cJSON_CreateNumber(numbers[i]);if(!n){cJSON_Delete(a);return 0;}if(!i)a->child=n;else suffix_object(p,n);p=n;}return a;}",
      "717: cJSON *cJSON_CreateStringArray(const char **strings,int count) {int i;cJSON *n=0,*p=0,*a=cJSON_CreateArray();for(i=0;a && i<count;i++){n=cJSON_CreateString(strings[i]);if(!n){cJSON_Delete(a);return 0;}if(!i)a->child=n;else suffix_object(p,n);p=n;}return a;}",
      "720: cJSON *cJSON_Duplicate(cJSON *item,int recurse)",
      "721: {",
      "722:  cJSON *newitem,*cptr,*nptr=0,*newchild;",
      "724:  if (!item) return 0;",
      "726:  newitem=cJSON_New_Item();",
      "727:  if (!newitem) return 0;",
      "729:  newitem->type=item->type&(~cJSON_IsReference),newitem->valueint=item->valueint,newitem->valuedouble=item->valuedouble;",
      "730:  if (item->valuestring) {newitem->valuestring=cJSON_strdup(item->valuestring); if (!newitem->valuestring) {cJSON_Delete(newitem);return 0;}}",
      "731:  if (item->string)  {newitem->string=cJSON_strdup(item->string);   if (!newitem->string)  {cJSON_Delete(newitem);return 0;}}",
      "733:  if (!recurse) return newitem;",
      "735:  cptr=item->child;",
      "736:  while (cptr)",
      "737:  {",
      "739:   if (!newchild) {cJSON_Delete(newitem);return 0;}",
      "742:   cptr=cptr->next;",
      "743:  }",
      "744:  return newitem;",
      "745: }",
      "747: void cJSON_Minify(char *json)",
      "748: {",
      "749:  char *into=json;",
      "750:  while (*json)",
      "751:  {",
      "752:   if (*json==' ') json++;",
      "754:   else if (*json=='\\r') json++;",
      "755:   else if (*json=='\\n') json++;",
      "760:  }",
      "",
      "---------------"
    ],
    "src/cjson.h||src/cjson.h": [
      "File: src/cjson.h -> src/cjson.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "29: #endif",
      "40: #define cJSON_IsReference 256",
      "43: typedef struct cJSON {",
      "54: } cJSON;",
      "56: typedef struct cJSON_Hooks {",
      "59: } cJSON_Hooks;",
      "124: #ifdef __cplusplus",
      "125: }",
      "",
      "[Removed Lines]",
      "32: #define cJSON_False 0",
      "33: #define cJSON_True 1",
      "34: #define cJSON_NULL 2",
      "35: #define cJSON_Number 3",
      "36: #define cJSON_String 4",
      "37: #define cJSON_Array 5",
      "38: #define cJSON_Object 6",
      "57:       void *(*malloc_fn)(size_t sz );",
      "58:       void (*free_fn)( void *ptr );",
      "62: extern void cJSON_InitHooks( cJSON_Hooks* hooks );",
      "66: extern cJSON *cJSON_Parse( const char *value );",
      "68: extern char *cJSON_Print( cJSON *item );",
      "70: extern char *cJSON_PrintUnformatted( cJSON *item );",
      "72: extern void cJSON_Delete( cJSON *c );",
      "75: extern int cJSON_GetArraySize( cJSON *array );",
      "77: extern cJSON *cJSON_GetArrayItem( cJSON *array, int item );",
      "79: extern cJSON *cJSON_GetObjectItem( cJSON *object, const char *string );",
      "82: extern const char *cJSON_GetErrorPtr( void );",
      "85: extern cJSON *cJSON_CreateNull( void );",
      "86: extern cJSON *cJSON_CreateTrue( void );",
      "87: extern cJSON *cJSON_CreateFalse( void );",
      "88: extern cJSON *cJSON_CreateBool( int b );",
      "89: extern cJSON *cJSON_CreateInt( int64_t num );",
      "90: extern cJSON *cJSON_CreateFloat( double num );",
      "91: extern cJSON *cJSON_CreateString( const char *string );",
      "92: extern cJSON *cJSON_CreateArray( void );",
      "93: extern cJSON *cJSON_CreateObject( void );",
      "96: extern cJSON *cJSON_CreateIntArray( int64_t *numbers, int count );",
      "97: extern cJSON *cJSON_CreateFloatArray( double *numbers, int count );",
      "98: extern cJSON *cJSON_CreateStringArray( const char **strings, int count );",
      "101: extern void cJSON_AddItemToArray( cJSON *array, cJSON *item );",
      "102: extern void cJSON_AddItemToObject( cJSON *object, const char *string, cJSON *item );",
      "104: extern void cJSON_AddItemReferenceToArray( cJSON *array, cJSON *item );",
      "105: extern void cJSON_AddItemReferenceToObject( cJSON *object, const char *string, cJSON *item );",
      "108: extern cJSON *cJSON_DetachItemFromArray( cJSON *array, int which );",
      "109: extern void cJSON_DeleteItemFromArray( cJSON *array, int which );",
      "110: extern cJSON *cJSON_DetachItemFromObject( cJSON *object, const char *string );",
      "111: extern void cJSON_DeleteItemFromObject( cJSON *object, const char *string );",
      "114: extern void cJSON_ReplaceItemInArray( cJSON *array, int which, cJSON *newitem );",
      "115: extern void cJSON_ReplaceItemInObject( cJSON *object, const char *string, cJSON *newitem );",
      "117: #define cJSON_AddNullToObject( object, name )  cJSON_AddItemToObject( object, name, cJSON_CreateNull() )",
      "118: #define cJSON_AddTrueToObject( object, name )  cJSON_AddItemToObject( object, name, cJSON_CreateTrue() )",
      "119: #define cJSON_AddFalseToObject( object, name )  cJSON_AddItemToObject( object, name, cJSON_CreateFalse() )",
      "120: #define cJSON_AddIntToObject( object, name, n )  cJSON_AddItemToObject( object, name, cJSON_CreateInt( n ) )",
      "121: #define cJSON_AddFloatToObject( object, name, n ) cJSON_AddItemToObject( object, name, cJSON_CreateFloat( n ) )",
      "122: #define cJSON_AddStringToObject( object, name, s ) cJSON_AddItemToObject( object, name, cJSON_CreateString( s ) )",
      "",
      "[Added Lines]",
      "32: #define cJSON_False  (1 << 0)",
      "33: #define cJSON_True   (1 << 1)",
      "34: #define cJSON_NULL   (1 << 2)",
      "35: #define cJSON_Number (1 << 3)",
      "36: #define cJSON_String (1 << 4)",
      "37: #define cJSON_Array  (1 << 5)",
      "38: #define cJSON_Object (1 << 6)",
      "41: #define cJSON_StringIsConst 512",
      "58:       void *(*malloc_fn)(size_t sz);",
      "59:       void (*free_fn)(void *ptr);",
      "63: extern void cJSON_InitHooks(cJSON_Hooks* hooks);",
      "67: extern cJSON *cJSON_Parse(const char *value);",
      "69: extern char  *cJSON_Print(cJSON *item);",
      "71: extern char  *cJSON_PrintUnformatted(cJSON *item);",
      "73: extern char *cJSON_PrintBuffered(cJSON *item,int prebuffer,int fmt);",
      "75: extern void   cJSON_Delete(cJSON *c);",
      "78: extern int   cJSON_GetArraySize(cJSON *array);",
      "80: extern cJSON *cJSON_GetArrayItem(cJSON *array,int item);",
      "82: extern cJSON *cJSON_GetObjectItem(cJSON *object,const char *string);",
      "83: extern int cJSON_HasObjectItem(cJSON *object,const char *string);",
      "85: extern const char *cJSON_GetErrorPtr(void);",
      "88: extern cJSON *cJSON_CreateNull(void);",
      "89: extern cJSON *cJSON_CreateTrue(void);",
      "90: extern cJSON *cJSON_CreateFalse(void);",
      "91: extern cJSON *cJSON_CreateBool(int b);",
      "92: extern cJSON *cJSON_CreateNumber(double num);",
      "93: extern cJSON *cJSON_CreateString(const char *string);",
      "94: extern cJSON *cJSON_CreateArray(void);",
      "95: extern cJSON *cJSON_CreateObject(void);",
      "98: extern cJSON *cJSON_CreateIntArray(const int *numbers,int count);",
      "99: extern cJSON *cJSON_CreateFloatArray(const float *numbers,int count);",
      "100: extern cJSON *cJSON_CreateDoubleArray(const double *numbers,int count);",
      "101: extern cJSON *cJSON_CreateStringArray(const char **strings,int count);",
      "104: extern void cJSON_AddItemToArray(cJSON *array, cJSON *item);",
      "105: extern void cJSON_AddItemToObject(cJSON *object,const char *string,cJSON *item);",
      "108: extern void cJSON_AddItemReferenceToArray(cJSON *array, cJSON *item);",
      "109: extern void cJSON_AddItemReferenceToObject(cJSON *object,const char *string,cJSON *item);",
      "112: extern cJSON *cJSON_DetachItemFromArray(cJSON *array,int which);",
      "113: extern void   cJSON_DeleteItemFromArray(cJSON *array,int which);",
      "114: extern cJSON *cJSON_DetachItemFromObject(cJSON *object,const char *string);",
      "115: extern void   cJSON_DeleteItemFromObject(cJSON *object,const char *string);",
      "119: extern void cJSON_ReplaceItemInArray(cJSON *array,int which,cJSON *newitem);",
      "120: extern void cJSON_ReplaceItemInObject(cJSON *object,const char *string,cJSON *newitem);",
      "123: extern cJSON *cJSON_Duplicate(cJSON *item,int recurse);",
      "125: need to be released. With recurse!=0, it will duplicate any children connected to the item.",
      "130: extern cJSON *cJSON_ParseWithOpts(const char *value,const char **return_parse_end,int require_null_terminated);",
      "132: extern void cJSON_Minify(char *json);",
      "135: #define cJSON_AddNullToObject(object,name)  cJSON_AddItemToObject(object, name, cJSON_CreateNull())",
      "136: #define cJSON_AddTrueToObject(object,name)  cJSON_AddItemToObject(object, name, cJSON_CreateTrue())",
      "137: #define cJSON_AddFalseToObject(object,name)  cJSON_AddItemToObject(object, name, cJSON_CreateFalse())",
      "138: #define cJSON_AddBoolToObject(object,name,b) cJSON_AddItemToObject(object, name, cJSON_CreateBool(b))",
      "139: #define cJSON_AddNumberToObject(object,name,n) cJSON_AddItemToObject(object, name, cJSON_CreateNumber(n))",
      "140: #define cJSON_AddStringToObject(object,name,s) cJSON_AddItemToObject(object, name, cJSON_CreateString(s))",
      "143: #define cJSON_SetIntValue(object,val)   ((object)?(object)->valueint=(object)->valuedouble=(val):(val))",
      "144: #define cJSON_SetNumberValue(object,val)  ((object)?(object)->valueint=(object)->valuedouble=(val):(val))",
      "147: #define cJSON_ArrayForEach(pos, head)   for(pos = (head)->child; pos != NULL; pos = pos->next)",
      "",
      "---------------"
    ],
    "src/iperf_api.c||src/iperf_api.c": [
      "File: src/iperf_api.c -> src/iperf_api.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "523:  cJSON_AddStringToObject(test->json_start, \"cookie\", test->cookie);",
      "524:         if (test->protocol->id == SOCK_STREAM) {",
      "525:      if (test->settings->mss)",
      "527:      else {",
      "528:   len = sizeof(opt);",
      "529:   getsockopt(test->ctrl_sck, IPPROTO_TCP, TCP_MAXSEG, &opt, &len);",
      "531:      }",
      "532:  }",
      "533:     } else if (test->verbose) {",
      "",
      "[Removed Lines]",
      "526:   cJSON_AddIntToObject(test->json_start, \"tcp_mss\", test->settings->mss);",
      "530:   cJSON_AddIntToObject(test->json_start, \"tcp_mss_default\", opt);",
      "",
      "[Added Lines]",
      "526:   cJSON_AddNumberToObject(test->json_start, \"tcp_mss\", test->settings->mss);",
      "530:   cJSON_AddNumberToObject(test->json_start, \"tcp_mss_default\", opt);",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "1135:      cJSON_AddTrueToObject(j, \"tcp\");",
      "1136:  else if (test->protocol->id == Pudp)",
      "1137:      cJSON_AddTrueToObject(j, \"udp\");",
      "1139:  if (test->server_affinity != -1)",
      "1141:  if (test->duration)",
      "1143:  if (test->settings->bytes)",
      "1145:  if (test->settings->blocks)",
      "1147:  if (test->settings->mss)",
      "1149:  if (test->no_delay)",
      "1150:      cJSON_AddTrueToObject(j, \"nodelay\");",
      "1152:  if (test->reverse)",
      "1153:      cJSON_AddTrueToObject(j, \"reverse\");",
      "1154:  if (test->settings->socket_bufsize)",
      "1156:  if (test->settings->blksize)",
      "1158:  if (test->settings->rate)",
      "1160:  if (test->settings->burst)",
      "1162:  if (test->settings->tos)",
      "1164:  if (test->settings->flowlabel)",
      "1166:  if (test->title)",
      "1167:      cJSON_AddStringToObject(j, \"title\", test->title);",
      "1168:  if (test->congestion)",
      "1169:      cJSON_AddStringToObject(j, \"congestion\", test->congestion);",
      "1170:  if (test->get_server_output)",
      "1171:      cJSON_AddIntToObject(j, \"get_server_output\", iperf_get_test_get_server_output(test));",
      "1173:  if (test->debug) {",
      "1174:      printf(\"send_parameters:\\n%s\\n\", cJSON_Print(j));",
      "",
      "[Removed Lines]",
      "1138:  cJSON_AddIntToObject(j, \"omit\", test->omit);",
      "1140:      cJSON_AddIntToObject(j, \"server_affinity\", test->server_affinity);",
      "1142:      cJSON_AddIntToObject(j, \"time\", test->duration);",
      "1144:      cJSON_AddIntToObject(j, \"num\", test->settings->bytes);",
      "1146:      cJSON_AddIntToObject(j, \"blockcount\", test->settings->blocks);",
      "1148:      cJSON_AddIntToObject(j, \"MSS\", test->settings->mss);",
      "1151:  cJSON_AddIntToObject(j, \"parallel\", test->num_streams);",
      "1155:      cJSON_AddIntToObject(j, \"window\", test->settings->socket_bufsize);",
      "1157:      cJSON_AddIntToObject(j, \"len\", test->settings->blksize);",
      "1159:      cJSON_AddIntToObject(j, \"bandwidth\", test->settings->rate);",
      "1161:      cJSON_AddIntToObject(j, \"burst\", test->settings->burst);",
      "1163:      cJSON_AddIntToObject(j, \"TOS\", test->settings->tos);",
      "1165:      cJSON_AddIntToObject(j, \"flowlabel\", test->settings->flowlabel);",
      "",
      "[Added Lines]",
      "1138:  cJSON_AddNumberToObject(j, \"omit\", test->omit);",
      "1140:      cJSON_AddNumberToObject(j, \"server_affinity\", test->server_affinity);",
      "1142:      cJSON_AddNumberToObject(j, \"time\", test->duration);",
      "1144:      cJSON_AddNumberToObject(j, \"num\", test->settings->bytes);",
      "1146:      cJSON_AddNumberToObject(j, \"blockcount\", test->settings->blocks);",
      "1148:      cJSON_AddNumberToObject(j, \"MSS\", test->settings->mss);",
      "1151:  cJSON_AddNumberToObject(j, \"parallel\", test->num_streams);",
      "1155:      cJSON_AddNumberToObject(j, \"window\", test->settings->socket_bufsize);",
      "1157:      cJSON_AddNumberToObject(j, \"len\", test->settings->blksize);",
      "1159:      cJSON_AddNumberToObject(j, \"bandwidth\", test->settings->rate);",
      "1161:      cJSON_AddNumberToObject(j, \"burst\", test->settings->burst);",
      "1163:      cJSON_AddNumberToObject(j, \"TOS\", test->settings->tos);",
      "1165:      cJSON_AddNumberToObject(j, \"flowlabel\", test->settings->flowlabel);",
      "1171: <<<<<<< HEAD",
      "1173: =======",
      "1174:      cJSON_AddNumberToObject(j, \"get_server_output\", iperf_get_test_get_server_output(test));",
      "1175:  if (test->udp_counters_64bit)",
      "1176:      cJSON_AddNumberToObject(j, \"udp_counters_64bit\", iperf_get_test_udp_counters_64bit(test));",
      "1177:  if (test->no_fq_socket_pacing)",
      "1178:      cJSON_AddNumberToObject(j, \"no_fq_socket_pacing\", iperf_get_no_fq_socket_pacing(test));",
      "1180:  cJSON_AddStringToObject(j, \"client_version\", IPERF_VERSION);",
      "1181: >>>>>>> ed94082... Fix a buffer overflow / heap corruption issue that could occur if a",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "1267:  i_errno = IEPACKAGERESULTS;",
      "1268:  r = -1;",
      "1269:     } else {",
      "1273:  if ( ! test->sender )",
      "1274:      sender_has_retransmits = -1;",
      "1275:  else",
      "1276:      sender_has_retransmits = test->sender_has_retransmits;",
      "1280:  if (test->role == 's' && test->get_server_output) {",
      "",
      "[Removed Lines]",
      "1270:  cJSON_AddFloatToObject(j, \"cpu_util_total\", test->cpu_util[0]);",
      "1271:  cJSON_AddFloatToObject(j, \"cpu_util_user\", test->cpu_util[1]);",
      "1272:  cJSON_AddFloatToObject(j, \"cpu_util_system\", test->cpu_util[2]);",
      "1277:  cJSON_AddIntToObject(j, \"sender_has_retransmits\", sender_has_retransmits);",
      "",
      "[Added Lines]",
      "1280:  cJSON_AddNumberToObject(j, \"cpu_util_total\", test->cpu_util[0]);",
      "1281:  cJSON_AddNumberToObject(j, \"cpu_util_user\", test->cpu_util[1]);",
      "1282:  cJSON_AddNumberToObject(j, \"cpu_util_system\", test->cpu_util[2]);",
      "1287:  cJSON_AddNumberToObject(j, \"sender_has_retransmits\", sender_has_retransmits);",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "1318:       cJSON_AddItemToArray(j_streams, j_stream);",
      "1319:       bytes_transferred = test->sender ? sp->result->bytes_sent : sp->result->bytes_received;",
      "1320:       retransmits = (test->sender && test->sender_has_retransmits) ? sp->result->stream_retrans : -1;",
      "1327:   }",
      "1328:      }",
      "1329:      if (r == 0 && test->debug) {",
      "",
      "[Removed Lines]",
      "1321:       cJSON_AddIntToObject(j_stream, \"id\", sp->id);",
      "1322:       cJSON_AddIntToObject(j_stream, \"bytes\", bytes_transferred);",
      "1323:       cJSON_AddIntToObject(j_stream, \"retransmits\", retransmits);",
      "1324:       cJSON_AddFloatToObject(j_stream, \"jitter\", sp->jitter);",
      "1325:       cJSON_AddIntToObject(j_stream, \"errors\", sp->cnt_error);",
      "1326:       cJSON_AddIntToObject(j_stream, \"packets\", sp->packet_count);",
      "",
      "[Added Lines]",
      "1331:       cJSON_AddNumberToObject(j_stream, \"id\", sp->id);",
      "1332:       cJSON_AddNumberToObject(j_stream, \"bytes\", bytes_transferred);",
      "1333:       cJSON_AddNumberToObject(j_stream, \"retransmits\", retransmits);",
      "1334:       cJSON_AddNumberToObject(j_stream, \"jitter\", sp->jitter);",
      "1335:       cJSON_AddNumberToObject(j_stream, \"errors\", sp->cnt_error);",
      "1336:       cJSON_AddNumberToObject(j_stream, \"packets\", sp->packet_count);",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "1384:   printf(\"get_results\\n%s\\n\", cJSON_Print(j));",
      "1385:      }",
      "1390:      result_has_retransmits = j_sender_has_retransmits->valueint;",
      "1391:      if (! test->sender)",
      "1392:   test->sender_has_retransmits = result_has_retransmits;",
      "",
      "[Removed Lines]",
      "1387:      test->remote_cpu_util[0] = j_cpu_util_total->valuefloat;",
      "1388:      test->remote_cpu_util[1] = j_cpu_util_user->valuefloat;",
      "1389:      test->remote_cpu_util[2] = j_cpu_util_system->valuefloat;",
      "",
      "[Added Lines]",
      "1397:      test->remote_cpu_util[0] = j_cpu_util_total->valuedouble;",
      "1398:      test->remote_cpu_util[1] = j_cpu_util_user->valuedouble;",
      "1399:      test->remote_cpu_util[2] = j_cpu_util_system->valuedouble;",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "1415:        sid = j_id->valueint;",
      "1416:        bytes_transferred = j_bytes->valueint;",
      "1417:        retransmits = j_retransmits->valueint;",
      "1419:        cerror = j_errors->valueint;",
      "1420:        pcount = j_packets->valueint;",
      "1421:        SLIST_FOREACH(sp, &test->streams, streams)",
      "",
      "[Removed Lines]",
      "1418:        jitter = j_jitter->valuefloat;",
      "",
      "[Added Lines]",
      "1428:        jitter = j_jitter->valuedouble;",
      "",
      "---------------"
    ],
    "src/iperf_util.c||src/iperf_util.c": [
      "File: src/iperf_util.c -> src/iperf_util.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "272:   j = cJSON_CreateBool(va_arg(argp, int));",
      "273:   break;",
      "274:   case 'd':",
      "276:   break;",
      "277:   case 'f':",
      "279:   break;",
      "280:   case 's':",
      "281:   j = cJSON_CreateString(va_arg(argp, char *));",
      "",
      "[Removed Lines]",
      "275:   j = cJSON_CreateInt(va_arg(argp, int64_t));",
      "278:   j = cJSON_CreateFloat(va_arg(argp, double));",
      "",
      "[Added Lines]",
      "275:   j = cJSON_CreateNumber(va_arg(argp, int64_t));",
      "278:   j = cJSON_CreateNumber(va_arg(argp, double));",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "f01a9ca8f7e878e438a53687dabe30b7f7222912",
      "candidate_info": {
        "commit_hash": "f01a9ca8f7e878e438a53687dabe30b7f7222912",
        "repo": "esnet/iperf",
        "commit_url": "https://github.com/esnet/iperf/commit/f01a9ca8f7e878e438a53687dabe30b7f7222912",
        "files": [
          "configure.ac",
          "src/cjson.c",
          "src/cjson.h",
          "src/iperf_api.c",
          "src/iperf_util.c"
        ],
        "message": "Fix a buffer overflow / heap corruption issue that could occur if a malformed JSON string was passed on the control channel.  This issue, present in the cJSON library, was already fixed upstream, so was addressed here in iperf3 by importing a newer version of cJSON (plus local ESnet modifications).\n\nDiscovered and reported by Dave McDaniel, Cisco Talos.\n\nBased on a patch by @dopheide-esnet, with input from @DaveGamble.\n\nCross-references:  TALOS-CAN-0164, ESNET-SECADV-2016-0001,\nCVE-2016-4303\n\n(cherry picked from commit ed94082be27d971a5e1b08b666e2c217cf470a40)\nSigned-off-by: Bruce A. Mah <bmah@es.net>",
        "before_after_code_files": [
          "configure.ac||configure.ac",
          "src/cjson.c||src/cjson.c",
          "src/cjson.h||src/cjson.h",
          "src/iperf_api.c||src/iperf_api.c",
          "src/iperf_util.c||src/iperf_util.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "diff_branch_cherry_pick": 1,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "configure.ac||configure.ac",
            "src/cjson.c||src/cjson.c",
            "src/cjson.h||src/cjson.h",
            "src/iperf_api.c||src/iperf_api.c",
            "src/iperf_util.c||src/iperf_util.c"
          ],
          "candidate": [
            "configure.ac||configure.ac",
            "src/cjson.c||src/cjson.c",
            "src/cjson.h||src/cjson.h",
            "src/iperf_api.c||src/iperf_api.c",
            "src/iperf_util.c||src/iperf_util.c"
          ]
        }
      },
      "candidate_diff": {
        "configure.ac||configure.ac": [
          "File: configure.ac -> configure.ac",
          "--- Hunk 1 ---",
          "[Context before]",
          "57: # Check for systems which need -lsocket and -lnsl",
          "58: #AX_LIB_SOCKET_NSL",
          "60: # Solaris puts nanosleep in -lrt",
          "61: AC_SEARCH_LIBS(nanosleep, [rt], [], [",
          "62: echo \"nanosleep() required for timing operations.\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "60: # Check for the math library (needed by cjson on some platforms)",
          "61: AC_SEARCH_LIBS(floor, [m], [], [",
          "62: echo \"floor()\"",
          "63: exit 1",
          "64: ])",
          "",
          "---------------"
        ],
        "src/cjson.c||src/cjson.c": [
          "File: src/cjson.c -> src/cjson.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "42: #ifndef LLONG_MIN",
          "43: #define LLONG_MIN (-LLONG_MAX - 1LL)",
          "44: #endif",
          "50: {",
          "52: }",
          "56: {",
          "81: }",
          "85: {",
          "94: }",
          "99: {",
          "103:  return node;",
          "104: }",
          "109: {",
          "110:  cJSON *next;",
          "122:  }",
          "123: }",
          "127: {",
          "138:  }",
          "140: }",
          "207: }",
          "212: {",
          "213:  char *str;",
          "226:  }",
          "227:  return str;",
          "228: }",
          "232: static const unsigned char firstByteMark[7] = { 0x00, 0x00, 0xC0, 0xE0, 0xF0, 0xF8, 0xFC };",
          "235: {",
          "262:    ptr++;",
          "289:      }",
          "305:      }",
          "307:      break;",
          "309:    }",
          "311:   }",
          "312:  }",
          "318:  return ptr;",
          "319: }",
          "324: {",
          "339:  }",
          "365:    }",
          "366:   }",
          "367:  }",
          "370:  return out;",
          "371: }",
          "400: {",
          "410:  return c;",
          "411: }",
          "420: {",
          "422: }",
          "427: {",
          "455: }",
          "473:  }",
          "474:  return out;",
          "475: }",
          "480: {",
          "481:  cJSON *child;",
          "500:   cJSON *new_item;",
          "508:  }",
          "515: }",
          "520: {",
          "521:  char **entries;",
          "562:  }",
          "576:   }",
          "578:  }",
          "582:  return out;",
          "583: }",
          "588: {",
          "589:  cJSON *child;",
          "617:   cJSON *new_item;",
          "634:  }",
          "641: }",
          "646: {",
          "697:   }",
          "701:  }",
          "727:  }",
          "736:  return out;",
          "737: }",
          "1035: }",
          "",
          "[Removed Lines]",
          "47: static const char *ep;",
          "49: const char *cJSON_GetErrorPtr( void )",
          "51:  return ep;",
          "55: static int cJSON_strcasecmp( const char *s1, const char *s2 )",
          "57:  if ( ! s1 )",
          "58:   return ( s1 == s2 ) ? 0 : 1;",
          "59:  if ( ! s2 )",
          "60:   return 1;",
          "61:  for ( ; tolower((u_char)*s1) == tolower((u_char)*s2); ++s1, ++s2)",
          "62:   if( *s1 == 0 )",
          "63:    return 0;",
          "64:  return tolower((u_char)*s1) - tolower((u_char)*s2);",
          "65: }",
          "68: static void *(*cJSON_malloc)( size_t ) = malloc;",
          "69: static void (*cJSON_free)( void * ) = free;",
          "71: void cJSON_InitHooks(cJSON_Hooks* hooks)",
          "72: {",
          "73:  if ( ! hooks ) {",
          "75:   cJSON_malloc = malloc;",
          "76:   cJSON_free = free;",
          "77:   return;",
          "78:  }",
          "79:  cJSON_malloc = (hooks->malloc_fn) ? hooks->malloc_fn : malloc;",
          "80:  cJSON_free = (hooks->free_fn) ? hooks->free_fn : free;",
          "84: static char* cJSON_strdup( const char* str )",
          "86:  size_t len;",
          "87:  char* copy;",
          "89:  len = strlen( str ) + 1;",
          "90:  if ( ! ( copy = (char*) cJSON_malloc( len ) ) )",
          "91:   return 0;",
          "92:  memcpy( copy, str, len );",
          "93:  return copy;",
          "98: static cJSON *cJSON_New_Item( void )",
          "100:  cJSON* node = (cJSON*) cJSON_malloc( sizeof(cJSON) );",
          "101:  if ( node )",
          "102:   memset( node, 0, sizeof(cJSON) );",
          "108: void cJSON_Delete( cJSON *c )",
          "112:  while ( c ) {",
          "113:   next = c->next;",
          "114:   if ( ! ( c->type & cJSON_IsReference ) && c->child )",
          "115:    cJSON_Delete( c->child );",
          "116:   if ( ! ( c->type & cJSON_IsReference ) && c->valuestring )",
          "117:    cJSON_free( c->valuestring );",
          "118:   if ( c->string )",
          "119:    cJSON_free( c->string );",
          "120:   cJSON_free( c );",
          "121:   c = next;",
          "126: static double ipow( double n, int exp )",
          "128:  double r;",
          "130:  if ( exp < 0 )",
          "131:   return 1.0 / ipow( n, -exp );",
          "132:  r = 1;",
          "133:  while ( exp > 0 ) {",
          "134:   if ( exp & 1 )",
          "135:    r *= n;",
          "136:   exp >>= 1;",
          "137:   n *= n;",
          "139:  return r;",
          "144: static const char *parse_number( cJSON *item, const char *num )",
          "145: {",
          "146:  int64_t i = 0;",
          "147:  double f = 0;",
          "148:  int isint = 1;",
          "149:  int sign = 1, scale = 0, subscale = 0, signsubscale = 1;",
          "152:  if ( *num == '-' ) {",
          "154:   sign = -1;",
          "155:   ++num;",
          "156:  }",
          "157:  if ( *num == '0' )",
          "159:   ++num;",
          "160:  if ( *num >= '1' && *num<='9' ) {",
          "162:   do {",
          "163:    i = ( i * 10 ) + ( *num - '0' );",
          "164:    f = ( f * 10.0 ) + ( *num - '0' );",
          "165:    ++num;",
          "166:   } while ( *num >= '0' && *num <= '9' );",
          "167:  }",
          "168:  if ( *num == '.' && num[1] >= '0' && num[1] <= '9' ) {",
          "170:   isint = 0;",
          "171:   ++num;",
          "172:   do {",
          "173:    f = ( f * 10.0 ) + ( *num++ - '0' );",
          "174:    scale--;",
          "175:   } while ( *num >= '0' && *num <= '9' );",
          "176:  }",
          "177:  if ( *num == 'e' || *num == 'E' ) {",
          "179:   isint = 0;",
          "180:   ++num;",
          "181:   if ( *num == '+' )",
          "182:    ++num;",
          "183:   else if ( *num == '-' ) {",
          "185:    signsubscale = -1;",
          "186:    ++num;",
          "187:   }",
          "188:   while ( *num >= '0' && *num <= '9' )",
          "189:    subscale = ( subscale * 10 ) + ( *num++ - '0' );",
          "190:  }",
          "193:  if ( isint ) {",
          "195:   i = sign * i;",
          "196:   item->valueint = i;",
          "197:   item->valuefloat = i;",
          "198:  } else {",
          "200:   f = sign * f * ipow( 10.0, scale + subscale * signsubscale );",
          "201:   item->valueint = f;",
          "202:   item->valuefloat = f;",
          "203:  }",
          "205:  item->type = cJSON_Number;",
          "206:  return num;",
          "211: static char *print_number( cJSON *item )",
          "214:  double f, f2;",
          "215:  int64_t i;",
          "217:  str = (char*) cJSON_malloc( 64 );",
          "218:  if ( str ) {",
          "219:   f = item->valuefloat;",
          "220:   i = f;",
          "221:   f2 = i;",
          "222:   if ( f2 == f && item->valueint >= LLONG_MIN && item->valueint <= LLONG_MAX )",
          "223:    sprintf( str, \"%lld\", (long long) item->valueint );",
          "224:   else",
          "225:    sprintf( str, \"%g\", item->valuefloat );",
          "234: static const char *parse_string( cJSON *item, const char *str )",
          "236:  const char *ptr = str + 1;",
          "237:  char *ptr2;",
          "238:  char *out;",
          "239:  int len = 0;",
          "240:  unsigned uc, uc2;",
          "242:  if ( *str != '\\\"' ) {",
          "244:   ep = str;",
          "245:   return 0;",
          "246:  }",
          "249:  while ( *ptr != '\\\"' && *ptr && ++len )",
          "250:   if ( *ptr++ == '\\\\' )",
          "251:    ptr++;",
          "253:  if ( ! ( out = (char*) cJSON_malloc( len + 1 ) ) )",
          "254:   return 0;",
          "256:  ptr = str + 1;",
          "257:  ptr2 = out;",
          "258:  while ( *ptr != '\\\"' && *ptr ) {",
          "259:   if ( *ptr != '\\\\' )",
          "261:   else {",
          "263:    switch ( *ptr ) {",
          "264:     case 'b': *ptr2++ ='\\b'; break;",
          "265:     case 'f': *ptr2++ ='\\f'; break;",
          "266:     case 'n': *ptr2++ ='\\n'; break;",
          "267:     case 'r': *ptr2++ ='\\r'; break;",
          "268:     case 't': *ptr2++ ='\\t'; break;",
          "269:     case 'u':",
          "272:      sscanf( ptr + 1,\"%4x\", &uc );",
          "273:      ptr += 4;",
          "275:      if ( ( uc >= 0xDC00 && uc <= 0xDFFF ) || uc == 0 )",
          "276:       break;",
          "279:      if ( uc >= 0xD800 && uc <= 0xDBFF ) {",
          "280:       if ( ptr[1] != '\\\\' || ptr[2] != 'u' )",
          "282:        break;",
          "283:       sscanf( ptr + 3, \"%4x\", &uc2 );",
          "284:       ptr += 6;",
          "285:       if ( uc2 < 0xDC00 || uc2 > 0xDFFF )",
          "287:        break;",
          "288:       uc = 0x10000 | ( ( uc & 0x3FF ) << 10 ) | ( uc2 & 0x3FF );",
          "291:      len = 4;",
          "292:      if ( uc < 0x80 )",
          "293:       len = 1;",
          "294:      else if ( uc < 0x800 )",
          "295:       len = 2;",
          "296:      else if ( uc < 0x10000 )",
          "297:       len = 3;",
          "298:      ptr2 += len;",
          "300:      switch ( len ) {",
          "301:       case 4: *--ptr2 = ( ( uc | 0x80) & 0xBF ); uc >>= 6;",
          "302:       case 3: *--ptr2 = ( ( uc | 0x80) & 0xBF ); uc >>= 6;",
          "303:       case 2: *--ptr2 = ( ( uc | 0x80) & 0xBF ); uc >>= 6;",
          "304:       case 1: *--ptr2 = ( uc | firstByteMark[len] );",
          "306:      ptr2 += len;",
          "308:     default:  *ptr2++ = *ptr; break;",
          "310:    ++ptr;",
          "314:  if ( *ptr == '\\\"' )",
          "315:   ++ptr;",
          "316:  item->valuestring = out;",
          "317:  item->type = cJSON_String;",
          "323: static char *print_string_ptr( const char *str )",
          "325:  const char *ptr;",
          "326:  char *ptr2, *out;",
          "327:  int len = 0;",
          "328:  unsigned char token;",
          "330:  if ( ! str )",
          "331:   return cJSON_strdup( \"\" );",
          "332:  ptr = str;",
          "333:  while ( ( token = *ptr ) && ++len ) {",
          "334:   if ( strchr( \"\\\"\\\\\\b\\f\\n\\r\\t\", token ) )",
          "335:    ++len;",
          "336:   else if ( token < 32 )",
          "337:    len += 5;",
          "338:   ++ptr;",
          "341:  if ( ! ( out = (char*) cJSON_malloc( len + 3 ) ) )",
          "342:   return 0;",
          "344:  ptr2 = out;",
          "345:  ptr = str;",
          "347:  while ( *ptr ) {",
          "348:   if ( (unsigned char) *ptr > 31 && *ptr != '\\\"' && *ptr != '\\\\' )",
          "350:   else {",
          "352:    switch ( token = *ptr++ ) {",
          "353:     case '\\\\': *ptr2++ = '\\\\'; break;",
          "354:     case '\\\"': *ptr2++ = '\\\"'; break;",
          "355:     case '\\b': *ptr2++ = 'b'; break;",
          "356:     case '\\f': *ptr2++ = 'f'; break;",
          "357:     case '\\n': *ptr2++ = 'n'; break;",
          "358:     case '\\r': *ptr2++ = 'r'; break;",
          "359:     case '\\t': *ptr2++ = 't'; break;",
          "360:     default:",
          "362:     sprintf( ptr2, \"u%04x\", token );",
          "363:     ptr2 += 5;",
          "364:     break;",
          "375: static char *print_string( cJSON *item )",
          "376: {",
          "377:  return print_string_ptr( item->valuestring );",
          "378: }",
          "382: static const char *parse_value( cJSON *item, const char *value );",
          "383: static char *print_value( cJSON *item, int depth, int fmt );",
          "384: static const char *parse_array( cJSON *item, const char *value );",
          "385: static char *print_array( cJSON *item, int depth, int fmt );",
          "386: static const char *parse_object( cJSON *item, const char *value );",
          "387: static char *print_object( cJSON *item, int depth, int fmt );",
          "390: static const char *skip( const char *in )",
          "391: {",
          "392:  while ( in && *in && (unsigned char) *in <= 32 )",
          "393:   in++;",
          "394:  return in;",
          "395: }",
          "399: cJSON *cJSON_Parse( const char *value )",
          "401:  cJSON *c;",
          "402:  ep = 0;",
          "403:  if ( ! ( c = cJSON_New_Item() ) )",
          "406:  if ( ! parse_value( c, skip( value ) ) ) {",
          "407:   cJSON_Delete( c );",
          "408:   return 0;",
          "409:  }",
          "415: char *cJSON_Print( cJSON *item )",
          "416: {",
          "417:  return print_value( item, 0, 1 );",
          "418: }",
          "419: char *cJSON_PrintUnformatted( cJSON *item )",
          "421:  return print_value( item, 0, 0 );",
          "426: static const char *parse_value( cJSON *item, const char *value )",
          "428:  if ( ! value )",
          "430:  if ( ! strncmp( value, \"null\", 4 ) ) {",
          "431:   item->type = cJSON_NULL;",
          "432:   return value + 4;",
          "433:  }",
          "434:  if ( ! strncmp( value, \"false\", 5 ) ) {",
          "435:   item->type = cJSON_False;",
          "436:   return value + 5;",
          "437:  }",
          "438:  if ( ! strncmp( value, \"true\", 4 ) ) {",
          "439:   item->type = cJSON_True;",
          "440:   item->valueint = 1;",
          "441:   return value + 4;",
          "442:  }",
          "443:  if ( *value == '\\\"' )",
          "444:   return parse_string( item, value );",
          "445:  if ( *value == '-' || ( *value >= '0' && *value <= '9' ) )",
          "446:   return parse_number( item, value );",
          "447:  if ( *value == '[' )",
          "448:   return parse_array( item, value );",
          "449:  if ( *value == '{' )",
          "450:   return parse_object( item, value );",
          "453:  ep = value;",
          "454:  return 0;",
          "459: static char *print_value( cJSON *item, int depth, int fmt )",
          "460: {",
          "461:  char *out = 0;",
          "463:  if ( ! item )",
          "464:   return 0;",
          "465:  switch ( ( item->type ) & 255 ) {",
          "466:   case cJSON_NULL:   out = cJSON_strdup( \"null\" ); break;",
          "467:   case cJSON_False:  out = cJSON_strdup( \"false\" ); break;",
          "468:   case cJSON_True:   out = cJSON_strdup( \"true\" ); break;",
          "469:   case cJSON_Number: out = print_number( item ); break;",
          "470:   case cJSON_String: out = print_string( item ); break;",
          "471:   case cJSON_Array:  out = print_array( item, depth, fmt ); break;",
          "472:   case cJSON_Object: out = print_object( item, depth, fmt ); break;",
          "479: static const char *parse_array( cJSON *item, const char *value )",
          "483:  if ( *value != '[' ) {",
          "485:   ep = value;",
          "486:   return 0;",
          "487:  }",
          "489:  item->type = cJSON_Array;",
          "490:  value = skip( value + 1 );",
          "491:  if ( *value == ']' )",
          "494:  if ( ! ( item->child = child = cJSON_New_Item() ) )",
          "496:  if ( ! ( value = skip( parse_value( child, skip( value ) ) ) ) )",
          "497:   return 0;",
          "499:  while ( *value == ',' ) {",
          "501:   if ( ! ( new_item = cJSON_New_Item() ) )",
          "503:   child->next = new_item;",
          "504:   new_item->prev = child;",
          "505:   child = new_item;",
          "506:   if ( ! ( value = skip( parse_value( child, skip( value+1 ) ) ) ) )",
          "510:  if ( *value == ']' )",
          "513:  ep = value;",
          "514:  return 0;",
          "519: static char *print_array( cJSON *item, int depth, int fmt )",
          "522:  char *out = 0, *ptr, *ret;",
          "523:  int len = 5;",
          "524:  cJSON *child = item->child;",
          "525:  int numentries = 0, i = 0, fail = 0;",
          "528:  while ( child ) {",
          "529:   ++numentries;",
          "530:   child = child->next;",
          "531:  }",
          "533:  if ( ! ( entries = (char**) cJSON_malloc( numentries * sizeof(char*) ) ) )",
          "534:   return 0;",
          "535:  memset( entries, 0, numentries * sizeof(char*) );",
          "537:  child = item->child;",
          "538:  while ( child && ! fail ) {",
          "539:   ret = print_value( child, depth + 1, fmt );",
          "540:   entries[i++] = ret;",
          "541:   if ( ret )",
          "542:    len += strlen( ret ) + 2 + ( fmt ? 1 : 0 );",
          "543:   else",
          "544:    fail = 1;",
          "545:   child = child -> next;",
          "546:  }",
          "549:  if ( ! fail ) {",
          "550:   out = (char*) cJSON_malloc( len );",
          "551:   if ( ! out )",
          "552:    fail = 1;",
          "553:  }",
          "556:  if ( fail ) {",
          "557:   for ( i = 0; i < numentries; ++i )",
          "558:    if ( entries[i] )",
          "559:     cJSON_free( entries[i] );",
          "560:   cJSON_free( entries );",
          "561:   return 0;",
          "566:  ptr = out + 1;",
          "568:  for ( i = 0; i < numentries; ++i ) {",
          "569:   strcpy( ptr, entries[i] );",
          "570:   ptr += strlen( entries[i] );",
          "571:   if ( i != numentries - 1 ) {",
          "573:    if ( fmt )",
          "577:   cJSON_free( entries[i] );",
          "579:  cJSON_free( entries );",
          "587: static const char *parse_object( cJSON *item, const char *value )",
          "591:  if ( *value != '{' ) {",
          "593:   ep = value;",
          "594:   return 0;",
          "595:  }",
          "597:  item->type = cJSON_Object;",
          "598:  value =skip( value + 1 );",
          "599:  if ( *value == '}' )",
          "602:  if ( ! ( item->child = child = cJSON_New_Item() ) )",
          "603:   return 0;",
          "604:  if ( ! ( value = skip( parse_string( child, skip( value ) ) ) ) )",
          "605:   return 0;",
          "606:  child->string = child->valuestring;",
          "607:  child->valuestring = 0;",
          "608:  if ( *value != ':' ) {",
          "610:   ep = value;",
          "611:   return 0;",
          "612:  }",
          "613:  if ( ! ( value = skip( parse_value( child, skip( value + 1 ) ) ) ) )",
          "614:   return 0;",
          "616:  while ( *value == ',' ) {",
          "618:   if ( ! ( new_item = cJSON_New_Item() ) )",
          "620:   child->next = new_item;",
          "621:   new_item->prev = child;",
          "622:   child = new_item;",
          "623:   if ( ! ( value = skip( parse_string( child, skip( value + 1 ) ) ) ) )",
          "624:    return 0;",
          "625:   child->string = child->valuestring;",
          "626:   child->valuestring = 0;",
          "627:   if ( *value != ':' ) {",
          "629:    ep = value;",
          "630:    return 0;",
          "631:   }",
          "632:   if ( ! ( value = skip( parse_value( child, skip( value + 1 ) ) ) ) )",
          "633:    return 0;",
          "636:  if ( *value == '}' )",
          "639:  ep = value;",
          "640:  return 0;",
          "645: static char *print_object( cJSON *item, int depth, int fmt )",
          "647:  char **entries = 0, **names = 0;",
          "648:  char *out = 0, *ptr, *ret, *str;",
          "649:  int len = 7, i = 0, j;",
          "650:  cJSON *child = item->child;",
          "651:  int numentries = 0, fail = 0;",
          "654:  while ( child ) {",
          "655:   ++numentries;",
          "656:   child = child->next;",
          "657:  }",
          "659:  if ( ! ( entries = (char**) cJSON_malloc( numentries * sizeof(char*) ) ) )",
          "660:   return 0;",
          "661:  if ( ! ( names = (char**) cJSON_malloc( numentries * sizeof(char*) ) ) ) {",
          "662:   cJSON_free( entries );",
          "663:   return 0;",
          "664:  }",
          "665:  memset( entries, 0, sizeof(char*) * numentries );",
          "666:  memset( names, 0, sizeof(char*) * numentries );",
          "669:  child = item->child;",
          "670:  ++depth;",
          "671:  if ( fmt )",
          "672:   len += depth;",
          "673:  while ( child ) {",
          "674:   names[i] = str = print_string_ptr( child->string );",
          "675:   entries[i++] = ret = print_value( child, depth, fmt );",
          "676:   if ( str && ret )",
          "677:    len += strlen( ret ) + strlen( str ) + 2 + ( fmt ? 2 + depth : 0 );",
          "678:   else",
          "679:    fail = 1;",
          "680:   child = child->next;",
          "681:  }",
          "684:  if ( ! fail ) {",
          "685:   out = (char*) cJSON_malloc( len );",
          "686:   if ( ! out )",
          "687:    fail = 1;",
          "688:  }",
          "691:  if ( fail ) {",
          "692:   for ( i = 0; i < numentries; ++i ) {",
          "693:    if ( names[i] )",
          "694:     cJSON_free( names[i] );",
          "695:    if ( entries[i] )",
          "696:     cJSON_free( entries[i] );",
          "698:   cJSON_free( names );",
          "699:   cJSON_free( entries );",
          "700:   return 0;",
          "705:  ptr = out + 1;",
          "706:  if ( fmt )",
          "709:  for ( i = 0; i < numentries; ++i ) {",
          "710:   if ( fmt )",
          "711:    for ( j = 0; j < depth; ++j )",
          "713:   strcpy( ptr, names[i] );",
          "714:   ptr += strlen( names[i] );",
          "716:   if ( fmt )",
          "718:   strcpy( ptr, entries[i] );",
          "719:   ptr += strlen( entries[i] );",
          "720:   if ( i != numentries - 1 )",
          "722:   if ( fmt )",
          "725:   cJSON_free( names[i] );",
          "726:   cJSON_free( entries[i] );",
          "729:  cJSON_free( names );",
          "730:  cJSON_free( entries );",
          "731:  if ( fmt )",
          "732:   for ( i = 0; i < depth - 1; ++i )",
          "740: int cJSON_GetArraySize( cJSON *array )",
          "741: {",
          "742:  cJSON *c = array->child;",
          "743:  int i = 0;",
          "744:  while ( c ) {",
          "745:   ++i;",
          "746:   c = c->next;",
          "747:  }",
          "748:  return i;",
          "749: }",
          "752: cJSON *cJSON_GetArrayItem( cJSON *array, int item )",
          "753: {",
          "754:  cJSON *c = array->child;",
          "755:  while ( c && item > 0 ) {",
          "756:   --item;",
          "757:   c = c->next;",
          "758:  }",
          "759:  return c;",
          "760: }",
          "763: cJSON *cJSON_GetObjectItem( cJSON *object, const char *string )",
          "764: {",
          "765:  cJSON *c = object->child;",
          "766:  while ( c && cJSON_strcasecmp( c->string, string ) )",
          "767:   c = c->next;",
          "768:  return c;",
          "769: }",
          "773: static void suffix_object( cJSON *prev, cJSON *item )",
          "774: {",
          "775:  prev->next = item;",
          "776:  item->prev = prev;",
          "777: }",
          "781: static cJSON *create_reference( cJSON *item )",
          "782: {",
          "783:  cJSON *ref;",
          "784:  if ( ! ( ref = cJSON_New_Item() ) )",
          "785:   return 0;",
          "786:  memcpy( ref, item, sizeof(cJSON) );",
          "787:  ref->string = 0;",
          "788:  ref->type |= cJSON_IsReference;",
          "789:  ref->next = ref->prev = 0;",
          "790:  return ref;",
          "791: }",
          "795: void cJSON_AddItemToArray( cJSON *array, cJSON *item )",
          "796: {",
          "797:  cJSON *c = array->child;",
          "798:  if ( ! item )",
          "799:   return;",
          "800:  if ( ! c ) {",
          "801:   array->child = item;",
          "802:  } else {",
          "803:   while ( c && c->next )",
          "804:    c = c->next;",
          "805:   suffix_object( c, item );",
          "806:  }",
          "807: }",
          "809: void cJSON_AddItemToObject( cJSON *object, const char *string, cJSON *item )",
          "810: {",
          "811:  if ( ! item )",
          "812:   return;",
          "813:  if ( item->string )",
          "814:   cJSON_free( item->string );",
          "815:  item->string = cJSON_strdup( string );",
          "816:  cJSON_AddItemToArray( object, item );",
          "817: }",
          "819: void cJSON_AddItemReferenceToArray( cJSON *array, cJSON *item )",
          "820: {",
          "821:  cJSON_AddItemToArray( array, create_reference( item ) );",
          "822: }",
          "824: void cJSON_AddItemReferenceToObject( cJSON *object, const char *string, cJSON *item )",
          "825: {",
          "826:  cJSON_AddItemToObject( object, string, create_reference( item ) );",
          "827: }",
          "829: cJSON *cJSON_DetachItemFromArray( cJSON *array, int which )",
          "830: {",
          "831:  cJSON *c = array->child;",
          "832:  while ( c && which > 0 ) {",
          "833:   c = c->next;",
          "834:   --which;",
          "835:  }",
          "836:  if ( ! c )",
          "837:   return 0;",
          "838:  if ( c->prev )",
          "839:   c->prev->next = c->next;",
          "840:  if ( c->next ) c->next->prev = c->prev;",
          "841:  if ( c == array->child )",
          "842:   array->child = c->next;",
          "843:  c->prev = c->next = 0;",
          "844:  return c;",
          "845: }",
          "847: void cJSON_DeleteItemFromArray( cJSON *array, int which )",
          "848: {",
          "849:  cJSON_Delete( cJSON_DetachItemFromArray( array, which ) );",
          "850: }",
          "852: cJSON *cJSON_DetachItemFromObject( cJSON *object, const char *string )",
          "853: {",
          "854:  int i = 0;",
          "855:  cJSON *c = object->child;",
          "856:  while ( c && cJSON_strcasecmp( c->string, string ) ) {",
          "857:   ++i;",
          "858:   c = c->next;",
          "859:  }",
          "860:  if ( c )",
          "861:   return cJSON_DetachItemFromArray( object, i );",
          "862:  return 0;",
          "863: }",
          "865: void cJSON_DeleteItemFromObject( cJSON *object, const char *string )",
          "866: {",
          "867:  cJSON_Delete( cJSON_DetachItemFromObject( object, string ) );",
          "868: }",
          "871: void cJSON_ReplaceItemInArray( cJSON *array, int which, cJSON *newitem )",
          "872: {",
          "873:  cJSON *c = array->child;",
          "874:  while ( c && which > 0 ) {",
          "875:   c = c->next;",
          "876:   --which;",
          "877:  }",
          "878:  if ( ! c )",
          "879:   return;",
          "880:  newitem->next = c->next;",
          "881:  newitem->prev = c->prev;",
          "882:  if ( newitem->next )",
          "883:   newitem->next->prev = newitem;",
          "884:  if ( c == array->child )",
          "885:   array->child = newitem;",
          "886:  else",
          "887:   newitem->prev->next = newitem;",
          "888:  c->next = c->prev = 0;",
          "889:  cJSON_Delete( c );",
          "890: }",
          "892: void cJSON_ReplaceItemInObject( cJSON *object, const char *string, cJSON *newitem )",
          "893: {",
          "894:  int i = 0;",
          "895:  cJSON *c = object->child;",
          "896:  while ( c && cJSON_strcasecmp( c->string, string ) ) {",
          "897:   ++i;",
          "898:   c = c->next;",
          "899:  }",
          "900:  if ( c ) {",
          "901:   newitem->string = cJSON_strdup( string );",
          "902:   cJSON_ReplaceItemInArray( object, i, newitem );",
          "903:  }",
          "904: }",
          "909: cJSON *cJSON_CreateNull( void )",
          "910: {",
          "911:  cJSON *item = cJSON_New_Item();",
          "912:  if ( item )",
          "913:   item->type = cJSON_NULL;",
          "914:  return item;",
          "915: }",
          "917: cJSON *cJSON_CreateTrue( void )",
          "918: {",
          "919:  cJSON *item = cJSON_New_Item();",
          "920:  if ( item )",
          "921:   item->type = cJSON_True;",
          "922:  return item;",
          "923: }",
          "925: cJSON *cJSON_CreateFalse( void )",
          "926: {",
          "927:  cJSON *item = cJSON_New_Item();",
          "928:  if ( item )",
          "929:   item->type = cJSON_False;",
          "930:  return item;",
          "931: }",
          "933: cJSON *cJSON_CreateBool( int b )",
          "934: {",
          "935:  cJSON *item = cJSON_New_Item();",
          "936:  if ( item )",
          "937:   item->type = b ? cJSON_True : cJSON_False;",
          "938:  return item;",
          "939: }",
          "941: cJSON *cJSON_CreateInt( int64_t num )",
          "942: {",
          "943:  cJSON *item = cJSON_New_Item();",
          "944:  if ( item ) {",
          "945:   item->type = cJSON_Number;",
          "946:   item->valuefloat = num;",
          "947:   item->valueint = num;",
          "948:  }",
          "949:  return item;",
          "950: }",
          "952: cJSON *cJSON_CreateFloat( double num )",
          "953: {",
          "954:  cJSON *item = cJSON_New_Item();",
          "955:  if ( item ) {",
          "956:   item->type = cJSON_Number;",
          "957:   item->valuefloat = num;",
          "958:   item->valueint = num;",
          "959:  }",
          "960:  return item;",
          "961: }",
          "963: cJSON *cJSON_CreateString( const char *string )",
          "964: {",
          "965:  cJSON *item = cJSON_New_Item();",
          "966:  if ( item ) {",
          "967:   item->type = cJSON_String;",
          "968:   item->valuestring = cJSON_strdup( string );",
          "969:  }",
          "970:  return item;",
          "971: }",
          "973: cJSON *cJSON_CreateArray( void )",
          "974: {",
          "975:  cJSON *item = cJSON_New_Item();",
          "976:  if ( item )",
          "977:   item->type = cJSON_Array;",
          "978:  return item;",
          "979: }",
          "981: cJSON *cJSON_CreateObject( void )",
          "982: {",
          "983:  cJSON *item = cJSON_New_Item();",
          "984:  if ( item )",
          "985:   item->type = cJSON_Object;",
          "986:  return item;",
          "987: }",
          "992: cJSON *cJSON_CreateIntArray( int64_t *numbers, int count )",
          "993: {",
          "994:  int i;",
          "995:  cJSON *n = 0, *p = 0, *a = cJSON_CreateArray();",
          "996:  for ( i = 0; a && i < count; ++i ) {",
          "997:   n = cJSON_CreateInt( numbers[i] );",
          "998:   if ( ! i )",
          "999:    a->child = n;",
          "1000:   else",
          "1001:    suffix_object( p, n );",
          "1002:   p = n;",
          "1003:  }",
          "1004:  return a;",
          "1005: }",
          "1007: cJSON *cJSON_CreateFloatArray( double *numbers, int count )",
          "1008: {",
          "1009:  int i;",
          "1010:  cJSON *n = 0, *p = 0, *a = cJSON_CreateArray();",
          "1011:  for ( i = 0; a && i < count; ++i ) {",
          "1012:   n = cJSON_CreateFloat( numbers[i] );",
          "1013:   if ( ! i )",
          "1014:    a->child = n;",
          "1015:   else",
          "1016:    suffix_object( p, n );",
          "1017:   p = n;",
          "1018:  }",
          "1019:  return a;",
          "1020: }",
          "1022: cJSON *cJSON_CreateStringArray( const char **strings, int count )",
          "1023: {",
          "1024:  int i;",
          "1025:  cJSON *n = 0, *p = 0, *a = cJSON_CreateArray();",
          "1026:  for ( i = 0; a && i < count; ++i ) {",
          "1027:   n = cJSON_CreateString( strings[i] );",
          "1028:   if ( ! i )",
          "1029:    a->child = n;",
          "1030:   else",
          "1031:    suffix_object( p, n );",
          "1032:   p = n;",
          "1033:  }",
          "1034:  return a;",
          "",
          "[Added Lines]",
          "45: static const char *global_ep;",
          "47: const char *cJSON_GetErrorPtr(void) {return global_ep;}",
          "49: static int cJSON_strcasecmp(const char *s1,const char *s2)",
          "51:  if (!s1) return (s1==s2)?0:1;if (!s2) return 1;",
          "52:  for(; tolower(*s1) == tolower(*s2); ++s1, ++s2) if(*s1 == 0) return 0;",
          "53:  return tolower(*(const unsigned char *)s1) - tolower(*(const unsigned char *)s2);",
          "56: static void *(*cJSON_malloc)(size_t sz) = malloc;",
          "57: static void (*cJSON_free)(void *ptr) = free;",
          "59: static char* cJSON_strdup(const char* str)",
          "61:       size_t len;",
          "62:       char* copy;",
          "64:       len = strlen(str) + 1;",
          "65:       if (!(copy = (char*)cJSON_malloc(len))) return 0;",
          "66:       memcpy(copy,str,len);",
          "67:       return copy;",
          "70: void cJSON_InitHooks(cJSON_Hooks* hooks)",
          "73:         cJSON_malloc = malloc;",
          "74:         cJSON_free = free;",
          "75:         return;",
          "76:     }",
          "78:  cJSON_malloc = (hooks->malloc_fn)?hooks->malloc_fn:malloc;",
          "79:  cJSON_free  = (hooks->free_fn)?hooks->free_fn:free;",
          "83: static cJSON *cJSON_New_Item(void)",
          "85:  cJSON* node = (cJSON*)cJSON_malloc(sizeof(cJSON));",
          "86:  if (node) memset(node,0,sizeof(cJSON));",
          "91: void cJSON_Delete(cJSON *c)",
          "94:  while (c)",
          "95:  {",
          "96:   next=c->next;",
          "97:   if (!(c->type&cJSON_IsReference) && c->child) cJSON_Delete(c->child);",
          "98:   if (!(c->type&cJSON_IsReference) && c->valuestring) cJSON_free(c->valuestring);",
          "99:   if (!(c->type&cJSON_StringIsConst) && c->string) cJSON_free(c->string);",
          "100:   cJSON_free(c);",
          "101:   c=next;",
          "106: static const char *parse_number(cJSON *item,const char *num)",
          "108:  double n=0,sign=1,scale=0;int subscale=0,signsubscale=1;",
          "121:  item->valuedouble=n;",
          "122:  item->valueint=(int64_t)n;",
          "123:  item->type=cJSON_Number;",
          "124:  return num;",
          "127: static int pow2gt (int x) { --x; x|=x>>1; x|=x>>2; x|=x>>4; x|=x>>8; x|=x>>16; return x+1; }",
          "129: typedef struct {char *buffer; int length; int offset; } printbuffer;",
          "131: static char* ensure(printbuffer *p,int needed)",
          "132: {",
          "133:  char *newbuffer;int newsize;",
          "134:  if (!p || !p->buffer) return 0;",
          "135:  needed+=p->offset;",
          "136:  if (needed<=p->length) return p->buffer+p->offset;",
          "138:  newsize=pow2gt(needed);",
          "139:  newbuffer=(char*)cJSON_malloc(newsize);",
          "140:  if (!newbuffer) {cJSON_free(p->buffer);p->length=0,p->buffer=0;return 0;}",
          "141:  if (newbuffer) memcpy(newbuffer,p->buffer,p->length);",
          "142:  cJSON_free(p->buffer);",
          "143:  p->length=newsize;",
          "144:  p->buffer=newbuffer;",
          "145:  return newbuffer+p->offset;",
          "148: static int update(printbuffer *p)",
          "151:  if (!p || !p->buffer) return 0;",
          "152:  str=p->buffer+p->offset;",
          "153:  return p->offset+strlen(str);",
          "154: }",
          "157: static char *print_number(cJSON *item,printbuffer *p)",
          "158: {",
          "159:  char *str=0;",
          "160:  double d=item->valuedouble;",
          "161:  if (d==0)",
          "162:  {",
          "163:   if (p) str=ensure(p,2);",
          "165:   if (str) strcpy(str,\"0\");",
          "166:  }",
          "167:  else if (fabs(((double)item->valueint)-d)<=DBL_EPSILON && d<=LLONG_MAX && d>=LLONG_MIN)",
          "168:  {",
          "169:   if (p) str=ensure(p,64);",
          "170:   else str=(char*)cJSON_malloc(64);",
          "171:   if (str) sprintf(str,\"%lld\",(long long) item->valueint);",
          "172:  }",
          "173:  else",
          "174:  {",
          "175:   if (p) str=ensure(p,64);",
          "177:   if (str)",
          "178:   {",
          "179:    if (fpclassify(d) != FP_ZERO && !isnormal(d))    sprintf(str,\"null\");",
          "180:    else if (fabs(floor(d)-d)<=DBL_EPSILON && fabs(d)<1.0e60) sprintf(str,\"%.0f\",d);",
          "181:    else if (fabs(d)<1.0e-6 || fabs(d)>1.0e9)     sprintf(str,\"%e\",d);",
          "182:    else              sprintf(str,\"%f\",d);",
          "183:   }",
          "188: static unsigned parse_hex4(const char *str)",
          "189: {",
          "190:  unsigned h=0;",
          "191:  if (*str>='0' && *str<='9') h+=(*str)-'0'; else if (*str>='A' && *str<='F') h+=10+(*str)-'A'; else if (*str>='a' && *str<='f') h+=10+(*str)-'a'; else return 0;",
          "192:  h=h<<4;str++;",
          "193:  if (*str>='0' && *str<='9') h+=(*str)-'0'; else if (*str>='A' && *str<='F') h+=10+(*str)-'A'; else if (*str>='a' && *str<='f') h+=10+(*str)-'a'; else return 0;",
          "194:  h=h<<4;str++;",
          "195:  if (*str>='0' && *str<='9') h+=(*str)-'0'; else if (*str>='A' && *str<='F') h+=10+(*str)-'A'; else if (*str>='a' && *str<='f') h+=10+(*str)-'a'; else return 0;",
          "196:  h=h<<4;str++;",
          "197:  if (*str>='0' && *str<='9') h+=(*str)-'0'; else if (*str>='A' && *str<='F') h+=10+(*str)-'A'; else if (*str>='a' && *str<='f') h+=10+(*str)-'a'; else return 0;",
          "198:  return h;",
          "199: }",
          "203: static const char *parse_string(cJSON *item,const char *str,const char **ep)",
          "205:  const char *ptr=str+1,*end_ptr=str+1;char *ptr2;char *out;int len=0;unsigned uc,uc2;",
          "211:  if (!out) return 0;",
          "213:  item->type=cJSON_String;",
          "215:  ptr=str+1;ptr2=out;",
          "216:  while (ptr < end_ptr)",
          "217:  {",
          "218:   if (*ptr!='\\\\') *ptr2++=*ptr++;",
          "219:   else",
          "220:   {",
          "222:    switch (*ptr)",
          "223:    {",
          "224:     case 'b': *ptr2++='\\b'; break;",
          "225:     case 'f': *ptr2++='\\f'; break;",
          "226:     case 'n': *ptr2++='\\n'; break;",
          "227:     case 'r': *ptr2++='\\r'; break;",
          "228:     case 't': *ptr2++='\\t'; break;",
          "236:      {",
          "239:       uc2=parse_hex4(ptr+3);ptr+=6;",
          "241:       uc=0x10000 + (((uc&0x3FF)<<10) | (uc2&0x3FF));",
          "244:      len=4;if (uc<0x80) len=1;else if (uc<0x800) len=2;else if (uc<0x10000) len=3; ptr2+=len;",
          "246:      switch (len) {",
          "247:       case 4: *--ptr2 =((uc | 0x80) & 0xBF); uc >>= 6;",
          "248:       case 3: *--ptr2 =((uc | 0x80) & 0xBF); uc >>= 6;",
          "249:       case 2: *--ptr2 =((uc | 0x80) & 0xBF); uc >>= 6;",
          "250:       case 1: *--ptr2 =(uc | firstByteMark[len]);",
          "252:      ptr2+=len;",
          "254:     default:  *ptr2++=*ptr; break;",
          "256:    ptr++;",
          "260:  if (*ptr=='\\\"') ptr++;",
          "265: static char *print_string_ptr(const char *str,printbuffer *p)",
          "267:  const char *ptr;char *ptr2,*out;int len=0,flag=0;unsigned char token;",
          "269:  if (!str)",
          "270:  {",
          "271:   if (p) out=ensure(p,3);",
          "272:   else out=(char*)cJSON_malloc(3);",
          "273:   if (!out) return 0;",
          "274:   strcpy(out,\"\\\"\\\"\");",
          "275:   return out;",
          "276:  }",
          "278:  for (ptr=str;*ptr;ptr++) flag|=((*ptr>0 && *ptr<32)||(*ptr=='\\\"')||(*ptr=='\\\\'))?1:0;",
          "279:  if (!flag)",
          "280:  {",
          "281:   len=ptr-str;",
          "282:   if (p) out=ensure(p,len+3);",
          "283:   else  out=(char*)cJSON_malloc(len+3);",
          "284:   if (!out) return 0;",
          "285:   ptr2=out;*ptr2++='\\\"';",
          "286:   strcpy(ptr2,str);",
          "287:   ptr2[len]='\\\"';",
          "288:   ptr2[len+1]=0;",
          "289:   return out;",
          "292:  ptr=str;while ((token=*ptr) && ++len) {if (strchr(\"\\\"\\\\\\b\\f\\n\\r\\t\",token)) len++; else if (token<32) len+=5;ptr++;}",
          "294:  if (p) out=ensure(p,len+3);",
          "295:  else out=(char*)cJSON_malloc(len+3);",
          "296:  if (!out) return 0;",
          "298:  ptr2=out;ptr=str;",
          "300:  while (*ptr)",
          "301:  {",
          "302:   if ((unsigned char)*ptr>31 && *ptr!='\\\"' && *ptr!='\\\\') *ptr2++=*ptr++;",
          "303:   else",
          "304:   {",
          "306:    switch (token=*ptr++)",
          "307:    {",
          "308:     case '\\\\': *ptr2++='\\\\'; break;",
          "309:     case '\\\"': *ptr2++='\\\"'; break;",
          "310:     case '\\b': *ptr2++='b'; break;",
          "311:     case '\\f': *ptr2++='f'; break;",
          "312:     case '\\n': *ptr2++='n'; break;",
          "313:     case '\\r': *ptr2++='r'; break;",
          "314:     case '\\t': *ptr2++='t'; break;",
          "323: static char *print_string(cJSON *item,printbuffer *p) {return print_string_ptr(item->valuestring,p);}",
          "326: static const char *parse_value(cJSON *item,const char *value,const char **ep);",
          "327: static char *print_value(cJSON *item,int depth,int fmt,printbuffer *p);",
          "328: static const char *parse_array(cJSON *item,const char *value,const char **ep);",
          "329: static char *print_array(cJSON *item,int depth,int fmt,printbuffer *p);",
          "330: static const char *parse_object(cJSON *item,const char *value,const char **ep);",
          "331: static char *print_object(cJSON *item,int depth,int fmt,printbuffer *p);",
          "334: static const char *skip(const char *in) {while (in && *in && (unsigned char)*in<=32) in++; return in;}",
          "337: cJSON *cJSON_ParseWithOpts(const char *value,const char **return_parse_end,int require_null_terminated)",
          "339:  const char *end=0,**ep=return_parse_end?return_parse_end:&global_ep;",
          "340:  cJSON *c=cJSON_New_Item();",
          "344:  end=parse_value(c,skip(value),ep);",
          "348:  if (require_null_terminated) {end=skip(end);if (*end) {cJSON_Delete(c);*ep=end;return 0;}}",
          "349:  if (return_parse_end) *return_parse_end=end;",
          "353: cJSON *cJSON_Parse(const char *value) {return cJSON_ParseWithOpts(value,0,0);}",
          "356: char *cJSON_Print(cJSON *item)    {return print_value(item,0,1,0);}",
          "357: char *cJSON_PrintUnformatted(cJSON *item) {return print_value(item,0,0,0);}",
          "359: char *cJSON_PrintBuffered(cJSON *item,int prebuffer,int fmt)",
          "361:  printbuffer p;",
          "362:  p.buffer=(char*)cJSON_malloc(prebuffer);",
          "363:  p.length=prebuffer;",
          "364:  p.offset=0;",
          "365:  return print_value(item,0,fmt,&p);",
          "370: static const char *parse_value(cJSON *item,const char *value,const char **ep)",
          "373:  if (!strncmp(value,\"null\",4)) { item->type=cJSON_NULL;  return value+4; }",
          "374:  if (!strncmp(value,\"false\",5)) { item->type=cJSON_False; return value+5; }",
          "375:  if (!strncmp(value,\"true\",4)) { item->type=cJSON_True; item->valueint=1; return value+4; }",
          "376:  if (*value=='\\\"')    { return parse_string(item,value,ep); }",
          "377:  if (*value=='-' || (*value>='0' && *value<='9')) { return parse_number(item,value); }",
          "378:  if (*value=='[')    { return parse_array(item,value,ep); }",
          "379:  if (*value=='{')    { return parse_object(item,value,ep); }",
          "385: static char *print_value(cJSON *item,int depth,int fmt,printbuffer *p)",
          "386: {",
          "387:  char *out=0;",
          "388:  if (!item) return 0;",
          "389:  if (p)",
          "390:  {",
          "391:   switch ((item->type)&255)",
          "392:   {",
          "393:    case cJSON_NULL: {out=ensure(p,5); if (out) strcpy(out,\"null\"); break;}",
          "394:    case cJSON_False: {out=ensure(p,6); if (out) strcpy(out,\"false\"); break;}",
          "395:    case cJSON_True: {out=ensure(p,5); if (out) strcpy(out,\"true\"); break;}",
          "396:    case cJSON_Number: out=print_number(item,p);break;",
          "397:    case cJSON_String: out=print_string(item,p);break;",
          "398:    case cJSON_Array: out=print_array(item,depth,fmt,p);break;",
          "399:    case cJSON_Object: out=print_object(item,depth,fmt,p);break;",
          "400:   }",
          "401:  }",
          "402:  else",
          "403:  {",
          "404:   switch ((item->type)&255)",
          "405:   {",
          "406:    case cJSON_NULL: out=cJSON_strdup(\"null\"); break;",
          "407:    case cJSON_False: out=cJSON_strdup(\"false\");break;",
          "408:    case cJSON_True: out=cJSON_strdup(\"true\"); break;",
          "409:    case cJSON_Number: out=print_number(item,0);break;",
          "410:    case cJSON_String: out=print_string(item,0);break;",
          "411:    case cJSON_Array: out=print_array(item,depth,fmt,0);break;",
          "412:    case cJSON_Object: out=print_object(item,depth,fmt,0);break;",
          "413:   }",
          "419: static const char *parse_array(cJSON *item,const char *value,const char **ep)",
          "424:  item->type=cJSON_Array;",
          "425:  value=skip(value+1);",
          "428:  item->child=child=cJSON_New_Item();",
          "431:  if (!value) return 0;",
          "433:  while (*value==',')",
          "434:  {",
          "437:   child->next=new_item;new_item->prev=child;child=new_item;",
          "438:   value=skip(parse_value(child,skip(value+1),ep));",
          "447: static char *print_array(cJSON *item,int depth,int fmt,printbuffer *p)",
          "450:  char *out=0,*ptr,*ret;int len=5;",
          "451:  cJSON *child=item->child;",
          "452:  int numentries=0,i=0,fail=0;",
          "453:  size_t tmplen=0;",
          "456:  while (child) numentries++,child=child->next;",
          "458:  if (!numentries)",
          "459:  {",
          "460:   if (p) out=ensure(p,3);",
          "461:   else out=(char*)cJSON_malloc(3);",
          "462:   if (out) strcpy(out,\"[]\");",
          "463:   return out;",
          "464:  }",
          "466:  if (p)",
          "467:  {",
          "469:   i=p->offset;",
          "470:   ptr=ensure(p,1);if (!ptr) return 0; *ptr='['; p->offset++;",
          "471:   child=item->child;",
          "472:   while (child && !fail)",
          "473:   {",
          "474:    print_value(child,depth+1,fmt,p);",
          "475:    p->offset=update(p);",
          "476:    if (child->next) {len=fmt?2:1;ptr=ensure(p,len+1);if (!ptr) return 0;*ptr++=',';if(fmt)*ptr++=' ';*ptr=0;p->offset+=len;}",
          "477:    child=child->next;",
          "478:   }",
          "479:   ptr=ensure(p,2);if (!ptr) return 0; *ptr++=']';*ptr=0;",
          "480:   out=(p->buffer)+i;",
          "482:  else",
          "483:  {",
          "485:   entries=(char**)cJSON_malloc(numentries*sizeof(char*));",
          "486:   if (!entries) return 0;",
          "487:   memset(entries,0,numentries*sizeof(char*));",
          "489:   child=item->child;",
          "490:   while (child && !fail)",
          "491:   {",
          "492:    ret=print_value(child,depth+1,fmt,0);",
          "493:    entries[i++]=ret;",
          "494:    if (ret) len+=strlen(ret)+2+(fmt?1:0); else fail=1;",
          "495:    child=child->next;",
          "496:   }",
          "499:   if (!fail) out=(char*)cJSON_malloc(len);",
          "501:   if (!out) fail=1;",
          "504:   if (fail)",
          "505:   {",
          "506:    for (i=0;i<numentries;i++) if (entries[i]) cJSON_free(entries[i]);",
          "507:    cJSON_free(entries);",
          "508:    return 0;",
          "509:   }",
          "513:   ptr=out+1;*ptr=0;",
          "514:   for (i=0;i<numentries;i++)",
          "515:   {",
          "516:    tmplen=strlen(entries[i]);memcpy(ptr,entries[i],tmplen);ptr+=tmplen;",
          "517:    if (i!=numentries-1) {*ptr++=',';if(fmt)*ptr++=' ';*ptr=0;}",
          "518:    cJSON_free(entries[i]);",
          "520:   cJSON_free(entries);",
          "527: static const char *parse_object(cJSON *item,const char *value,const char **ep)",
          "532:  item->type=cJSON_Object;",
          "533:  value=skip(value+1);",
          "536:  item->child=child=cJSON_New_Item();",
          "537:  if (!item->child) return 0;",
          "538:  value=skip(parse_string(child,skip(value),ep));",
          "539:  if (!value) return 0;",
          "540:  child->string=child->valuestring;child->valuestring=0;",
          "543:  if (!value) return 0;",
          "545:  while (*value==',')",
          "546:  {",
          "549:   child->next=new_item;new_item->prev=child;child=new_item;",
          "550:   value=skip(parse_string(child,skip(value+1),ep));",
          "551:   if (!value) return 0;",
          "552:   child->string=child->valuestring;child->valuestring=0;",
          "555:   if (!value) return 0;",
          "563: static char *print_object(cJSON *item,int depth,int fmt,printbuffer *p)",
          "565:  char **entries=0,**names=0;",
          "566:  char *out=0,*ptr,*ret,*str;int len=7,i=0,j;",
          "567:  cJSON *child=item->child;",
          "568:  int numentries=0,fail=0;",
          "569:  size_t tmplen=0;",
          "571:  while (child) numentries++,child=child->next;",
          "573:  if (!numentries)",
          "574:  {",
          "575:   if (p) out=ensure(p,fmt?depth+4:3);",
          "576:   else out=(char*)cJSON_malloc(fmt?depth+4:3);",
          "577:   if (!out) return 0;",
          "578:   ptr=out;*ptr++='{';",
          "579:   if (fmt) {*ptr++='\\n';for (i=0;i<depth;i++) *ptr++='\\t';}",
          "581:   return out;",
          "582:  }",
          "583:  if (p)",
          "584:  {",
          "586:   i=p->offset;",
          "587:   len=fmt?2:1; ptr=ensure(p,len+1); if (!ptr) return 0;",
          "589:   child=item->child;depth++;",
          "590:   while (child)",
          "591:   {",
          "592:    if (fmt)",
          "593:    {",
          "594:     ptr=ensure(p,depth); if (!ptr) return 0;",
          "595:     for (j=0;j<depth;j++) *ptr++='\\t';",
          "596:     p->offset+=depth;",
          "597:    }",
          "598:    print_string_ptr(child->string,p);",
          "599:    p->offset=update(p);",
          "601:    len=fmt?2:1;",
          "602:    ptr=ensure(p,len); if (!ptr) return 0;",
          "604:    p->offset+=len;",
          "606:    print_value(child,depth,fmt,p);",
          "607:    p->offset=update(p);",
          "609:    len=(fmt?1:0)+(child->next?1:0);",
          "610:    ptr=ensure(p,len+1); if (!ptr) return 0;",
          "611:    if (child->next) *ptr++=',';",
          "612:    if (fmt) *ptr++='\\n';*ptr=0;",
          "613:    p->offset+=len;",
          "614:    child=child->next;",
          "616:   ptr=ensure(p,fmt?(depth+1):2);  if (!ptr) return 0;",
          "617:   if (fmt) for (i=0;i<depth-1;i++) *ptr++='\\t';",
          "619:   out=(p->buffer)+i;",
          "621:  else",
          "622:  {",
          "624:   entries=(char**)cJSON_malloc(numentries*sizeof(char*));",
          "625:   if (!entries) return 0;",
          "626:   names=(char**)cJSON_malloc(numentries*sizeof(char*));",
          "627:   if (!names) {cJSON_free(entries);return 0;}",
          "628:   memset(entries,0,sizeof(char*)*numentries);",
          "629:   memset(names,0,sizeof(char*)*numentries);",
          "632:   child=item->child;depth++;if (fmt) len+=depth;",
          "633:   while (child && !fail)",
          "634:   {",
          "635:    names[i]=str=print_string_ptr(child->string,0);",
          "636:    entries[i++]=ret=print_value(child,depth,fmt,0);",
          "637:    if (str && ret) len+=strlen(ret)+strlen(str)+2+(fmt?2+depth:0); else fail=1;",
          "638:    child=child->next;",
          "639:   }",
          "642:   if (!fail) out=(char*)cJSON_malloc(len);",
          "643:   if (!out) fail=1;",
          "646:   if (fail)",
          "647:   {",
          "648:    for (i=0;i<numentries;i++) {if (names[i]) cJSON_free(names[i]);if (entries[i]) cJSON_free(entries[i]);}",
          "649:    cJSON_free(names);cJSON_free(entries);",
          "650:    return 0;",
          "651:   }",
          "655:   for (i=0;i<numentries;i++)",
          "656:   {",
          "657:    if (fmt) for (j=0;j<depth;j++) *ptr++='\\t';",
          "658:    tmplen=strlen(names[i]);memcpy(ptr,names[i],tmplen);ptr+=tmplen;",
          "660:    strcpy(ptr,entries[i]);ptr+=strlen(entries[i]);",
          "661:    if (i!=numentries-1) *ptr++=',';",
          "662:    if (fmt) *ptr++='\\n';*ptr=0;",
          "663:    cJSON_free(names[i]);cJSON_free(entries[i]);",
          "664:   }",
          "666:   cJSON_free(names);cJSON_free(entries);",
          "667:   if (fmt) for (i=0;i<depth-1;i++) *ptr++='\\t';",
          "674: int    cJSON_GetArraySize(cJSON *array)       {cJSON *c=array->child;int i=0;while(c)i++,c=c->next;return i;}",
          "675: cJSON *cJSON_GetArrayItem(cJSON *array,int item)    {cJSON *c=array?array->child:0;while (c && item>0) item--,c=c->next; return c;}",
          "676: cJSON *cJSON_GetObjectItem(cJSON *object,const char *string) {cJSON *c=object?object->child:0;while (c && cJSON_strcasecmp(c->string,string)) c=c->next; return c;}",
          "677: int cJSON_HasObjectItem(cJSON *object,const char *string)  {return cJSON_GetObjectItem(object,string)?1:0;}",
          "680: static void suffix_object(cJSON *prev,cJSON *item) {prev->next=item;item->prev=prev;}",
          "682: static cJSON *create_reference(cJSON *item) {cJSON *ref=cJSON_New_Item();if (!ref) return 0;memcpy(ref,item,sizeof(cJSON));ref->string=0;ref->type|=cJSON_IsReference;ref->next=ref->prev=0;return ref;}",
          "685: void   cJSON_AddItemToArray(cJSON *array, cJSON *item)      {cJSON *c=array->child;if (!item) return; if (!c) {array->child=item;} else {while (c && c->next) c=c->next; suffix_object(c,item);}}",
          "686: void   cJSON_AddItemToObject(cJSON *object,const char *string,cJSON *item) {if (!item) return; if (item->string) cJSON_free(item->string);item->string=cJSON_strdup(string);cJSON_AddItemToArray(object,item);}",
          "687: void   cJSON_AddItemToObjectCS(cJSON *object,const char *string,cJSON *item) {if (!item) return; if (!(item->type&cJSON_StringIsConst) && item->string) cJSON_free(item->string);item->string=(char*)string;item->type|=cJSON_StringIsConst;cJSON_AddItemToArray(object,item);}",
          "688: void cJSON_AddItemReferenceToArray(cJSON *array, cJSON *item)      {cJSON_AddItemToArray(array,create_reference(item));}",
          "689: void cJSON_AddItemReferenceToObject(cJSON *object,const char *string,cJSON *item) {cJSON_AddItemToObject(object,string,create_reference(item));}",
          "691: cJSON *cJSON_DetachItemFromArray(cJSON *array,int which)   {cJSON *c=array->child;while (c && which>0) c=c->next,which--;if (!c) return 0;",
          "692:  if (c->prev) c->prev->next=c->next;if (c->next) c->next->prev=c->prev;if (c==array->child) array->child=c->next;c->prev=c->next=0;return c;}",
          "693: void   cJSON_DeleteItemFromArray(cJSON *array,int which)   {cJSON_Delete(cJSON_DetachItemFromArray(array,which));}",
          "694: cJSON *cJSON_DetachItemFromObject(cJSON *object,const char *string) {int i=0;cJSON *c=object->child;while (c && cJSON_strcasecmp(c->string,string)) i++,c=c->next;if (c) return cJSON_DetachItemFromArray(object,i);return 0;}",
          "695: void   cJSON_DeleteItemFromObject(cJSON *object,const char *string) {cJSON_Delete(cJSON_DetachItemFromObject(object,string));}",
          "698: void   cJSON_InsertItemInArray(cJSON *array,int which,cJSON *newitem)  {cJSON *c=array->child;while (c && which>0) c=c->next,which--;if (!c) {cJSON_AddItemToArray(array,newitem);return;}",
          "699:  newitem->next=c;newitem->prev=c->prev;c->prev=newitem;if (c==array->child) array->child=newitem; else newitem->prev->next=newitem;}",
          "700: void   cJSON_ReplaceItemInArray(cJSON *array,int which,cJSON *newitem)  {cJSON *c=array->child;while (c && which>0) c=c->next,which--;if (!c) return;",
          "701:  newitem->next=c->next;newitem->prev=c->prev;if (newitem->next) newitem->next->prev=newitem;",
          "702:  if (c==array->child) array->child=newitem; else newitem->prev->next=newitem;c->next=c->prev=0;cJSON_Delete(c);}",
          "703: void   cJSON_ReplaceItemInObject(cJSON *object,const char *string,cJSON *newitem){int i=0;cJSON *c=object->child;while(c && cJSON_strcasecmp(c->string,string))i++,c=c->next;if(c){newitem->string=cJSON_strdup(string);cJSON_ReplaceItemInArray(object,i,newitem);}}",
          "706: cJSON *cJSON_CreateNull(void)     {cJSON *item=cJSON_New_Item();if(item)item->type=cJSON_NULL;return item;}",
          "707: cJSON *cJSON_CreateTrue(void)     {cJSON *item=cJSON_New_Item();if(item)item->type=cJSON_True;return item;}",
          "708: cJSON *cJSON_CreateFalse(void)     {cJSON *item=cJSON_New_Item();if(item)item->type=cJSON_False;return item;}",
          "709: cJSON *cJSON_CreateBool(int b)     {cJSON *item=cJSON_New_Item();if(item)item->type=b?cJSON_True:cJSON_False;return item;}",
          "710: cJSON *cJSON_CreateNumber(double num)   {cJSON *item=cJSON_New_Item();if(item){item->type=cJSON_Number;item->valuedouble=num;item->valueint=(int64_t)num;}return item;}",
          "711: cJSON *cJSON_CreateString(const char *string) {cJSON *item=cJSON_New_Item();if(item){item->type=cJSON_String;item->valuestring=cJSON_strdup(string);if(!item->valuestring){cJSON_Delete(item);return 0;}}return item;}",
          "712: cJSON *cJSON_CreateArray(void)     {cJSON *item=cJSON_New_Item();if(item)item->type=cJSON_Array;return item;}",
          "713: cJSON *cJSON_CreateObject(void)     {cJSON *item=cJSON_New_Item();if(item)item->type=cJSON_Object;return item;}",
          "716: cJSON *cJSON_CreateIntArray(const int *numbers,int count)  {int i;cJSON *n=0,*p=0,*a=cJSON_CreateArray();for(i=0;a && i<count;i++){n=cJSON_CreateNumber(numbers[i]);if(!n){cJSON_Delete(a);return 0;}if(!i)a->child=n;else suffix_object(p,n);p=n;}return a;}",
          "717: cJSON *cJSON_CreateFloatArray(const float *numbers,int count) {int i;cJSON *n=0,*p=0,*a=cJSON_CreateArray();for(i=0;a && i<count;i++){n=cJSON_CreateNumber(numbers[i]);if(!n){cJSON_Delete(a);return 0;}if(!i)a->child=n;else suffix_object(p,n);p=n;}return a;}",
          "718: cJSON *cJSON_CreateDoubleArray(const double *numbers,int count) {int i;cJSON *n=0,*p=0,*a=cJSON_CreateArray();for(i=0;a && i<count;i++){n=cJSON_CreateNumber(numbers[i]);if(!n){cJSON_Delete(a);return 0;}if(!i)a->child=n;else suffix_object(p,n);p=n;}return a;}",
          "719: cJSON *cJSON_CreateStringArray(const char **strings,int count) {int i;cJSON *n=0,*p=0,*a=cJSON_CreateArray();for(i=0;a && i<count;i++){n=cJSON_CreateString(strings[i]);if(!n){cJSON_Delete(a);return 0;}if(!i)a->child=n;else suffix_object(p,n);p=n;}return a;}",
          "722: cJSON *cJSON_Duplicate(cJSON *item,int recurse)",
          "723: {",
          "724:  cJSON *newitem,*cptr,*nptr=0,*newchild;",
          "726:  if (!item) return 0;",
          "728:  newitem=cJSON_New_Item();",
          "729:  if (!newitem) return 0;",
          "731:  newitem->type=item->type&(~cJSON_IsReference),newitem->valueint=item->valueint,newitem->valuedouble=item->valuedouble;",
          "732:  if (item->valuestring) {newitem->valuestring=cJSON_strdup(item->valuestring); if (!newitem->valuestring) {cJSON_Delete(newitem);return 0;}}",
          "733:  if (item->string)  {newitem->string=cJSON_strdup(item->string);   if (!newitem->string)  {cJSON_Delete(newitem);return 0;}}",
          "735:  if (!recurse) return newitem;",
          "737:  cptr=item->child;",
          "738:  while (cptr)",
          "739:  {",
          "741:   if (!newchild) {cJSON_Delete(newitem);return 0;}",
          "744:   cptr=cptr->next;",
          "745:  }",
          "746:  return newitem;",
          "747: }",
          "749: void cJSON_Minify(char *json)",
          "750: {",
          "751:  char *into=json;",
          "752:  while (*json)",
          "753:  {",
          "754:   if (*json==' ') json++;",
          "756:   else if (*json=='\\r') json++;",
          "757:   else if (*json=='\\n') json++;",
          "762:  }",
          "",
          "---------------"
        ],
        "src/cjson.h||src/cjson.h": [
          "File: src/cjson.h -> src/cjson.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "29: #endif",
          "40: #define cJSON_IsReference 256",
          "43: typedef struct cJSON {",
          "54: } cJSON;",
          "56: typedef struct cJSON_Hooks {",
          "59: } cJSON_Hooks;",
          "124: #ifdef __cplusplus",
          "125: }",
          "",
          "[Removed Lines]",
          "32: #define cJSON_False 0",
          "33: #define cJSON_True 1",
          "34: #define cJSON_NULL 2",
          "35: #define cJSON_Number 3",
          "36: #define cJSON_String 4",
          "37: #define cJSON_Array 5",
          "38: #define cJSON_Object 6",
          "57:       void *(*malloc_fn)(size_t sz );",
          "58:       void (*free_fn)( void *ptr );",
          "62: extern void cJSON_InitHooks( cJSON_Hooks* hooks );",
          "66: extern cJSON *cJSON_Parse( const char *value );",
          "68: extern char *cJSON_Print( cJSON *item );",
          "70: extern char *cJSON_PrintUnformatted( cJSON *item );",
          "72: extern void cJSON_Delete( cJSON *c );",
          "75: extern int cJSON_GetArraySize( cJSON *array );",
          "77: extern cJSON *cJSON_GetArrayItem( cJSON *array, int item );",
          "79: extern cJSON *cJSON_GetObjectItem( cJSON *object, const char *string );",
          "82: extern const char *cJSON_GetErrorPtr( void );",
          "85: extern cJSON *cJSON_CreateNull( void );",
          "86: extern cJSON *cJSON_CreateTrue( void );",
          "87: extern cJSON *cJSON_CreateFalse( void );",
          "88: extern cJSON *cJSON_CreateBool( int b );",
          "89: extern cJSON *cJSON_CreateInt( int64_t num );",
          "90: extern cJSON *cJSON_CreateFloat( double num );",
          "91: extern cJSON *cJSON_CreateString( const char *string );",
          "92: extern cJSON *cJSON_CreateArray( void );",
          "93: extern cJSON *cJSON_CreateObject( void );",
          "96: extern cJSON *cJSON_CreateIntArray( int64_t *numbers, int count );",
          "97: extern cJSON *cJSON_CreateFloatArray( double *numbers, int count );",
          "98: extern cJSON *cJSON_CreateStringArray( const char **strings, int count );",
          "101: extern void cJSON_AddItemToArray( cJSON *array, cJSON *item );",
          "102: extern void cJSON_AddItemToObject( cJSON *object, const char *string, cJSON *item );",
          "104: extern void cJSON_AddItemReferenceToArray( cJSON *array, cJSON *item );",
          "105: extern void cJSON_AddItemReferenceToObject( cJSON *object, const char *string, cJSON *item );",
          "108: extern cJSON *cJSON_DetachItemFromArray( cJSON *array, int which );",
          "109: extern void cJSON_DeleteItemFromArray( cJSON *array, int which );",
          "110: extern cJSON *cJSON_DetachItemFromObject( cJSON *object, const char *string );",
          "111: extern void cJSON_DeleteItemFromObject( cJSON *object, const char *string );",
          "114: extern void cJSON_ReplaceItemInArray( cJSON *array, int which, cJSON *newitem );",
          "115: extern void cJSON_ReplaceItemInObject( cJSON *object, const char *string, cJSON *newitem );",
          "117: #define cJSON_AddNullToObject( object, name )  cJSON_AddItemToObject( object, name, cJSON_CreateNull() )",
          "118: #define cJSON_AddTrueToObject( object, name )  cJSON_AddItemToObject( object, name, cJSON_CreateTrue() )",
          "119: #define cJSON_AddFalseToObject( object, name )  cJSON_AddItemToObject( object, name, cJSON_CreateFalse() )",
          "120: #define cJSON_AddIntToObject( object, name, n )  cJSON_AddItemToObject( object, name, cJSON_CreateInt( n ) )",
          "121: #define cJSON_AddFloatToObject( object, name, n ) cJSON_AddItemToObject( object, name, cJSON_CreateFloat( n ) )",
          "122: #define cJSON_AddStringToObject( object, name, s ) cJSON_AddItemToObject( object, name, cJSON_CreateString( s ) )",
          "",
          "[Added Lines]",
          "32: #define cJSON_False  (1 << 0)",
          "33: #define cJSON_True   (1 << 1)",
          "34: #define cJSON_NULL   (1 << 2)",
          "35: #define cJSON_Number (1 << 3)",
          "36: #define cJSON_String (1 << 4)",
          "37: #define cJSON_Array  (1 << 5)",
          "38: #define cJSON_Object (1 << 6)",
          "41: #define cJSON_StringIsConst 512",
          "58:       void *(*malloc_fn)(size_t sz);",
          "59:       void (*free_fn)(void *ptr);",
          "63: extern void cJSON_InitHooks(cJSON_Hooks* hooks);",
          "67: extern cJSON *cJSON_Parse(const char *value);",
          "69: extern char  *cJSON_Print(cJSON *item);",
          "71: extern char  *cJSON_PrintUnformatted(cJSON *item);",
          "73: extern char *cJSON_PrintBuffered(cJSON *item,int prebuffer,int fmt);",
          "75: extern void   cJSON_Delete(cJSON *c);",
          "78: extern int   cJSON_GetArraySize(cJSON *array);",
          "80: extern cJSON *cJSON_GetArrayItem(cJSON *array,int item);",
          "82: extern cJSON *cJSON_GetObjectItem(cJSON *object,const char *string);",
          "83: extern int cJSON_HasObjectItem(cJSON *object,const char *string);",
          "85: extern const char *cJSON_GetErrorPtr(void);",
          "88: extern cJSON *cJSON_CreateNull(void);",
          "89: extern cJSON *cJSON_CreateTrue(void);",
          "90: extern cJSON *cJSON_CreateFalse(void);",
          "91: extern cJSON *cJSON_CreateBool(int b);",
          "92: extern cJSON *cJSON_CreateNumber(double num);",
          "93: extern cJSON *cJSON_CreateString(const char *string);",
          "94: extern cJSON *cJSON_CreateArray(void);",
          "95: extern cJSON *cJSON_CreateObject(void);",
          "98: extern cJSON *cJSON_CreateIntArray(const int *numbers,int count);",
          "99: extern cJSON *cJSON_CreateFloatArray(const float *numbers,int count);",
          "100: extern cJSON *cJSON_CreateDoubleArray(const double *numbers,int count);",
          "101: extern cJSON *cJSON_CreateStringArray(const char **strings,int count);",
          "104: extern void cJSON_AddItemToArray(cJSON *array, cJSON *item);",
          "105: extern void cJSON_AddItemToObject(cJSON *object,const char *string,cJSON *item);",
          "108: extern void cJSON_AddItemReferenceToArray(cJSON *array, cJSON *item);",
          "109: extern void cJSON_AddItemReferenceToObject(cJSON *object,const char *string,cJSON *item);",
          "112: extern cJSON *cJSON_DetachItemFromArray(cJSON *array,int which);",
          "113: extern void   cJSON_DeleteItemFromArray(cJSON *array,int which);",
          "114: extern cJSON *cJSON_DetachItemFromObject(cJSON *object,const char *string);",
          "115: extern void   cJSON_DeleteItemFromObject(cJSON *object,const char *string);",
          "119: extern void cJSON_ReplaceItemInArray(cJSON *array,int which,cJSON *newitem);",
          "120: extern void cJSON_ReplaceItemInObject(cJSON *object,const char *string,cJSON *newitem);",
          "123: extern cJSON *cJSON_Duplicate(cJSON *item,int recurse);",
          "125: need to be released. With recurse!=0, it will duplicate any children connected to the item.",
          "130: extern cJSON *cJSON_ParseWithOpts(const char *value,const char **return_parse_end,int require_null_terminated);",
          "132: extern void cJSON_Minify(char *json);",
          "135: #define cJSON_AddNullToObject(object,name)  cJSON_AddItemToObject(object, name, cJSON_CreateNull())",
          "136: #define cJSON_AddTrueToObject(object,name)  cJSON_AddItemToObject(object, name, cJSON_CreateTrue())",
          "137: #define cJSON_AddFalseToObject(object,name)  cJSON_AddItemToObject(object, name, cJSON_CreateFalse())",
          "138: #define cJSON_AddBoolToObject(object,name,b) cJSON_AddItemToObject(object, name, cJSON_CreateBool(b))",
          "139: #define cJSON_AddNumberToObject(object,name,n) cJSON_AddItemToObject(object, name, cJSON_CreateNumber(n))",
          "140: #define cJSON_AddStringToObject(object,name,s) cJSON_AddItemToObject(object, name, cJSON_CreateString(s))",
          "143: #define cJSON_SetIntValue(object,val)   ((object)?(object)->valueint=(object)->valuedouble=(val):(val))",
          "144: #define cJSON_SetNumberValue(object,val)  ((object)?(object)->valueint=(object)->valuedouble=(val):(val))",
          "147: #define cJSON_ArrayForEach(pos, head)   for(pos = (head)->child; pos != NULL; pos = pos->next)",
          "",
          "---------------"
        ],
        "src/iperf_api.c||src/iperf_api.c": [
          "File: src/iperf_api.c -> src/iperf_api.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "583:  cJSON_AddStringToObject(test->json_start, \"cookie\", test->cookie);",
          "584:         if (test->protocol->id == SOCK_STREAM) {",
          "585:      if (test->settings->mss)",
          "587:      else {",
          "588:   len = sizeof(opt);",
          "589:   getsockopt(test->ctrl_sck, IPPROTO_TCP, TCP_MAXSEG, &opt, &len);",
          "591:      }",
          "592:  }",
          "593:     } else if (test->verbose) {",
          "",
          "[Removed Lines]",
          "586:   cJSON_AddIntToObject(test->json_start, \"tcp_mss\", test->settings->mss);",
          "590:   cJSON_AddIntToObject(test->json_start, \"tcp_mss_default\", opt);",
          "",
          "[Added Lines]",
          "586:   cJSON_AddNumberToObject(test->json_start, \"tcp_mss\", test->settings->mss);",
          "590:   cJSON_AddNumberToObject(test->json_start, \"tcp_mss_default\", opt);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1298:      cJSON_AddTrueToObject(j, \"udp\");",
          "1299:         else if (test->protocol->id == Psctp)",
          "1300:             cJSON_AddTrueToObject(j, \"sctp\");",
          "1302:  if (test->server_affinity != -1)",
          "1304:  if (test->duration)",
          "1306:  if (test->settings->bytes)",
          "1308:  if (test->settings->blocks)",
          "1310:  if (test->settings->mss)",
          "1312:  if (test->no_delay)",
          "1313:      cJSON_AddTrueToObject(j, \"nodelay\");",
          "1315:  if (test->reverse)",
          "1316:      cJSON_AddTrueToObject(j, \"reverse\");",
          "1317:  if (test->settings->socket_bufsize)",
          "1319:  if (test->settings->blksize)",
          "1321:  if (test->settings->rate)",
          "1323:  if (test->settings->burst)",
          "1325:  if (test->settings->tos)",
          "1327:  if (test->settings->flowlabel)",
          "1329:  if (test->title)",
          "1330:      cJSON_AddStringToObject(j, \"title\", test->title);",
          "1331:  if (test->congestion)",
          "1332:      cJSON_AddStringToObject(j, \"congestion\", test->congestion);",
          "1333:  if (test->get_server_output)",
          "1335:  if (test->udp_counters_64bit)",
          "1337:  if (test->no_fq_socket_pacing)",
          "1340:  cJSON_AddStringToObject(j, \"client_version\", IPERF_VERSION);",
          "",
          "[Removed Lines]",
          "1301:  cJSON_AddIntToObject(j, \"omit\", test->omit);",
          "1303:      cJSON_AddIntToObject(j, \"server_affinity\", test->server_affinity);",
          "1305:      cJSON_AddIntToObject(j, \"time\", test->duration);",
          "1307:      cJSON_AddIntToObject(j, \"num\", test->settings->bytes);",
          "1309:      cJSON_AddIntToObject(j, \"blockcount\", test->settings->blocks);",
          "1311:      cJSON_AddIntToObject(j, \"MSS\", test->settings->mss);",
          "1314:  cJSON_AddIntToObject(j, \"parallel\", test->num_streams);",
          "1318:      cJSON_AddIntToObject(j, \"window\", test->settings->socket_bufsize);",
          "1320:      cJSON_AddIntToObject(j, \"len\", test->settings->blksize);",
          "1322:      cJSON_AddIntToObject(j, \"bandwidth\", test->settings->rate);",
          "1324:      cJSON_AddIntToObject(j, \"burst\", test->settings->burst);",
          "1326:      cJSON_AddIntToObject(j, \"TOS\", test->settings->tos);",
          "1328:      cJSON_AddIntToObject(j, \"flowlabel\", test->settings->flowlabel);",
          "1334:      cJSON_AddIntToObject(j, \"get_server_output\", iperf_get_test_get_server_output(test));",
          "1336:      cJSON_AddIntToObject(j, \"udp_counters_64bit\", iperf_get_test_udp_counters_64bit(test));",
          "1338:      cJSON_AddIntToObject(j, \"no_fq_socket_pacing\", iperf_get_no_fq_socket_pacing(test));",
          "",
          "[Added Lines]",
          "1301:  cJSON_AddNumberToObject(j, \"omit\", test->omit);",
          "1303:      cJSON_AddNumberToObject(j, \"server_affinity\", test->server_affinity);",
          "1305:      cJSON_AddNumberToObject(j, \"time\", test->duration);",
          "1307:      cJSON_AddNumberToObject(j, \"num\", test->settings->bytes);",
          "1309:      cJSON_AddNumberToObject(j, \"blockcount\", test->settings->blocks);",
          "1311:      cJSON_AddNumberToObject(j, \"MSS\", test->settings->mss);",
          "1314:  cJSON_AddNumberToObject(j, \"parallel\", test->num_streams);",
          "1318:      cJSON_AddNumberToObject(j, \"window\", test->settings->socket_bufsize);",
          "1320:      cJSON_AddNumberToObject(j, \"len\", test->settings->blksize);",
          "1322:      cJSON_AddNumberToObject(j, \"bandwidth\", test->settings->rate);",
          "1324:      cJSON_AddNumberToObject(j, \"burst\", test->settings->burst);",
          "1326:      cJSON_AddNumberToObject(j, \"TOS\", test->settings->tos);",
          "1328:      cJSON_AddNumberToObject(j, \"flowlabel\", test->settings->flowlabel);",
          "1334:      cJSON_AddNumberToObject(j, \"get_server_output\", iperf_get_test_get_server_output(test));",
          "1336:      cJSON_AddNumberToObject(j, \"udp_counters_64bit\", iperf_get_test_udp_counters_64bit(test));",
          "1338:      cJSON_AddNumberToObject(j, \"no_fq_socket_pacing\", iperf_get_no_fq_socket_pacing(test));",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1443:  i_errno = IEPACKAGERESULTS;",
          "1444:  r = -1;",
          "1445:     } else {",
          "1449:  if ( ! test->sender )",
          "1450:      sender_has_retransmits = -1;",
          "1451:  else",
          "1452:      sender_has_retransmits = test->sender_has_retransmits;",
          "1456:  if (test->role == 's' && test->get_server_output) {",
          "",
          "[Removed Lines]",
          "1446:  cJSON_AddFloatToObject(j, \"cpu_util_total\", test->cpu_util[0]);",
          "1447:  cJSON_AddFloatToObject(j, \"cpu_util_user\", test->cpu_util[1]);",
          "1448:  cJSON_AddFloatToObject(j, \"cpu_util_system\", test->cpu_util[2]);",
          "1453:  cJSON_AddIntToObject(j, \"sender_has_retransmits\", sender_has_retransmits);",
          "",
          "[Added Lines]",
          "1446:  cJSON_AddNumberToObject(j, \"cpu_util_total\", test->cpu_util[0]);",
          "1447:  cJSON_AddNumberToObject(j, \"cpu_util_user\", test->cpu_util[1]);",
          "1448:  cJSON_AddNumberToObject(j, \"cpu_util_system\", test->cpu_util[2]);",
          "1453:  cJSON_AddNumberToObject(j, \"sender_has_retransmits\", sender_has_retransmits);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1494:       cJSON_AddItemToArray(j_streams, j_stream);",
          "1495:       bytes_transferred = test->sender ? (sp->result->bytes_sent - sp->result->bytes_sent_omit) : sp->result->bytes_received;",
          "1496:       retransmits = (test->sender && test->sender_has_retransmits) ? sp->result->stream_retrans : -1;",
          "1503:   }",
          "1504:      }",
          "1505:      if (r == 0 && test->debug) {",
          "",
          "[Removed Lines]",
          "1497:       cJSON_AddIntToObject(j_stream, \"id\", sp->id);",
          "1498:       cJSON_AddIntToObject(j_stream, \"bytes\", bytes_transferred);",
          "1499:       cJSON_AddIntToObject(j_stream, \"retransmits\", retransmits);",
          "1500:       cJSON_AddFloatToObject(j_stream, \"jitter\", sp->jitter);",
          "1501:       cJSON_AddIntToObject(j_stream, \"errors\", sp->cnt_error);",
          "1502:       cJSON_AddIntToObject(j_stream, \"packets\", sp->packet_count);",
          "",
          "[Added Lines]",
          "1497:       cJSON_AddNumberToObject(j_stream, \"id\", sp->id);",
          "1498:       cJSON_AddNumberToObject(j_stream, \"bytes\", bytes_transferred);",
          "1499:       cJSON_AddNumberToObject(j_stream, \"retransmits\", retransmits);",
          "1500:       cJSON_AddNumberToObject(j_stream, \"jitter\", sp->jitter);",
          "1501:       cJSON_AddNumberToObject(j_stream, \"errors\", sp->cnt_error);",
          "1502:       cJSON_AddNumberToObject(j_stream, \"packets\", sp->packet_count);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1560:   printf(\"get_results\\n%s\\n\", cJSON_Print(j));",
          "1561:      }",
          "1566:      result_has_retransmits = j_sender_has_retransmits->valueint;",
          "1567:      if (! test->sender)",
          "1568:   test->sender_has_retransmits = result_has_retransmits;",
          "",
          "[Removed Lines]",
          "1563:      test->remote_cpu_util[0] = j_cpu_util_total->valuefloat;",
          "1564:      test->remote_cpu_util[1] = j_cpu_util_user->valuefloat;",
          "1565:      test->remote_cpu_util[2] = j_cpu_util_system->valuefloat;",
          "",
          "[Added Lines]",
          "1563:      test->remote_cpu_util[0] = j_cpu_util_total->valuedouble;",
          "1564:      test->remote_cpu_util[1] = j_cpu_util_user->valuedouble;",
          "1565:      test->remote_cpu_util[2] = j_cpu_util_system->valuedouble;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1591:        sid = j_id->valueint;",
          "1592:        bytes_transferred = j_bytes->valueint;",
          "1593:        retransmits = j_retransmits->valueint;",
          "1595:        cerror = j_errors->valueint;",
          "1596:        pcount = j_packets->valueint;",
          "1597:        SLIST_FOREACH(sp, &test->streams, streams)",
          "",
          "[Removed Lines]",
          "1594:        jitter = j_jitter->valuefloat;",
          "",
          "[Added Lines]",
          "1594:        jitter = j_jitter->valuedouble;",
          "",
          "---------------"
        ],
        "src/iperf_util.c||src/iperf_util.c": [
          "File: src/iperf_util.c -> src/iperf_util.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "350:   j = cJSON_CreateBool(va_arg(argp, int));",
          "351:   break;",
          "352:   case 'd':",
          "354:   break;",
          "355:   case 'f':",
          "357:   break;",
          "358:   case 's':",
          "359:   j = cJSON_CreateString(va_arg(argp, char *));",
          "",
          "[Removed Lines]",
          "353:   j = cJSON_CreateInt(va_arg(argp, int64_t));",
          "356:   j = cJSON_CreateFloat(va_arg(argp, double));",
          "",
          "[Added Lines]",
          "353:   j = cJSON_CreateNumber(va_arg(argp, int64_t));",
          "356:   j = cJSON_CreateNumber(va_arg(argp, double));",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "ed94082be27d971a5e1b08b666e2c217cf470a40",
      "candidate_info": {
        "commit_hash": "ed94082be27d971a5e1b08b666e2c217cf470a40",
        "repo": "esnet/iperf",
        "commit_url": "https://github.com/esnet/iperf/commit/ed94082be27d971a5e1b08b666e2c217cf470a40",
        "files": [
          "configure.ac",
          "src/cjson.c",
          "src/cjson.h",
          "src/iperf_api.c",
          "src/iperf_util.c"
        ],
        "message": "Fix a buffer overflow / heap corruption issue that could occur if a malformed JSON string was passed on the control channel.  This issue, present in the cJSON library, was already fixed upstream, so was addressed here in iperf3 by importing a newer version of cJSON (plus local ESnet modifications).\n\nDiscovered and reported by Dave McDaniel, Cisco Talos.\n\nBased on a patch by @dopheide-esnet, with input from @DaveGamble.\n\nCross-references:  TALOS-CAN-0164, ESNET-SECADV-2016-0001,\nCVE-2016-4303",
        "before_after_code_files": [
          "configure.ac||configure.ac",
          "src/cjson.c||src/cjson.c",
          "src/cjson.h||src/cjson.h",
          "src/iperf_api.c||src/iperf_api.c",
          "src/iperf_util.c||src/iperf_util.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "diff_branch_cherry_pick": 1,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "configure.ac||configure.ac",
            "src/cjson.c||src/cjson.c",
            "src/cjson.h||src/cjson.h",
            "src/iperf_api.c||src/iperf_api.c",
            "src/iperf_util.c||src/iperf_util.c"
          ],
          "candidate": [
            "configure.ac||configure.ac",
            "src/cjson.c||src/cjson.c",
            "src/cjson.h||src/cjson.h",
            "src/iperf_api.c||src/iperf_api.c",
            "src/iperf_util.c||src/iperf_util.c"
          ]
        }
      },
      "candidate_diff": {
        "configure.ac||configure.ac": [
          "File: configure.ac -> configure.ac",
          "--- Hunk 1 ---",
          "[Context before]",
          "57: # Check for systems which need -lsocket and -lnsl",
          "58: #AX_LIB_SOCKET_NSL",
          "60: # Solaris puts nanosleep in -lrt",
          "61: AC_SEARCH_LIBS(nanosleep, [rt], [], [",
          "62: echo \"nanosleep() required for timing operations.\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "60: # Check for the math library (needed by cjson on some platforms)",
          "61: AC_SEARCH_LIBS(floor, [m], [], [",
          "62: echo \"floor()\"",
          "63: exit 1",
          "64: ])",
          "",
          "---------------"
        ],
        "src/cjson.c||src/cjson.c": [
          "File: src/cjson.c -> src/cjson.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "42: #ifndef LLONG_MIN",
          "43: #define LLONG_MIN (-LLONG_MAX - 1LL)",
          "44: #endif",
          "50: {",
          "52: }",
          "56: {",
          "81: }",
          "85: {",
          "94: }",
          "99: {",
          "103:  return node;",
          "104: }",
          "109: {",
          "110:  cJSON *next;",
          "122:  }",
          "123: }",
          "127: {",
          "138:  }",
          "140: }",
          "207: }",
          "212: {",
          "213:  char *str;",
          "226:  }",
          "227:  return str;",
          "228: }",
          "232: static const unsigned char firstByteMark[7] = { 0x00, 0x00, 0xC0, 0xE0, 0xF0, 0xF8, 0xFC };",
          "235: {",
          "262:    ptr++;",
          "289:      }",
          "305:      }",
          "307:      break;",
          "309:    }",
          "311:   }",
          "312:  }",
          "318:  return ptr;",
          "319: }",
          "324: {",
          "339:  }",
          "365:    }",
          "366:   }",
          "367:  }",
          "370:  return out;",
          "371: }",
          "400: {",
          "410:  return c;",
          "411: }",
          "420: {",
          "422: }",
          "427: {",
          "455: }",
          "473:  }",
          "474:  return out;",
          "475: }",
          "480: {",
          "481:  cJSON *child;",
          "500:   cJSON *new_item;",
          "508:  }",
          "515: }",
          "520: {",
          "521:  char **entries;",
          "562:  }",
          "576:   }",
          "578:  }",
          "582:  return out;",
          "583: }",
          "588: {",
          "589:  cJSON *child;",
          "617:   cJSON *new_item;",
          "634:  }",
          "641: }",
          "646: {",
          "697:   }",
          "701:  }",
          "727:  }",
          "736:  return out;",
          "737: }",
          "1035: }",
          "",
          "[Removed Lines]",
          "47: static const char *ep;",
          "49: const char *cJSON_GetErrorPtr( void )",
          "51:  return ep;",
          "55: static int cJSON_strcasecmp( const char *s1, const char *s2 )",
          "57:  if ( ! s1 )",
          "58:   return ( s1 == s2 ) ? 0 : 1;",
          "59:  if ( ! s2 )",
          "60:   return 1;",
          "61:  for ( ; tolower((u_char)*s1) == tolower((u_char)*s2); ++s1, ++s2)",
          "62:   if( *s1 == 0 )",
          "63:    return 0;",
          "64:  return tolower((u_char)*s1) - tolower((u_char)*s2);",
          "65: }",
          "68: static void *(*cJSON_malloc)( size_t ) = malloc;",
          "69: static void (*cJSON_free)( void * ) = free;",
          "71: void cJSON_InitHooks(cJSON_Hooks* hooks)",
          "72: {",
          "73:  if ( ! hooks ) {",
          "75:   cJSON_malloc = malloc;",
          "76:   cJSON_free = free;",
          "77:   return;",
          "78:  }",
          "79:  cJSON_malloc = (hooks->malloc_fn) ? hooks->malloc_fn : malloc;",
          "80:  cJSON_free = (hooks->free_fn) ? hooks->free_fn : free;",
          "84: static char* cJSON_strdup( const char* str )",
          "86:  size_t len;",
          "87:  char* copy;",
          "89:  len = strlen( str ) + 1;",
          "90:  if ( ! ( copy = (char*) cJSON_malloc( len ) ) )",
          "91:   return 0;",
          "92:  memcpy( copy, str, len );",
          "93:  return copy;",
          "98: static cJSON *cJSON_New_Item( void )",
          "100:  cJSON* node = (cJSON*) cJSON_malloc( sizeof(cJSON) );",
          "101:  if ( node )",
          "102:   memset( node, 0, sizeof(cJSON) );",
          "108: void cJSON_Delete( cJSON *c )",
          "112:  while ( c ) {",
          "113:   next = c->next;",
          "114:   if ( ! ( c->type & cJSON_IsReference ) && c->child )",
          "115:    cJSON_Delete( c->child );",
          "116:   if ( ! ( c->type & cJSON_IsReference ) && c->valuestring )",
          "117:    cJSON_free( c->valuestring );",
          "118:   if ( c->string )",
          "119:    cJSON_free( c->string );",
          "120:   cJSON_free( c );",
          "121:   c = next;",
          "126: static double ipow( double n, int exp )",
          "128:  double r;",
          "130:  if ( exp < 0 )",
          "131:   return 1.0 / ipow( n, -exp );",
          "132:  r = 1;",
          "133:  while ( exp > 0 ) {",
          "134:   if ( exp & 1 )",
          "135:    r *= n;",
          "136:   exp >>= 1;",
          "137:   n *= n;",
          "139:  return r;",
          "144: static const char *parse_number( cJSON *item, const char *num )",
          "145: {",
          "146:  int64_t i = 0;",
          "147:  double f = 0;",
          "148:  int isint = 1;",
          "149:  int sign = 1, scale = 0, subscale = 0, signsubscale = 1;",
          "152:  if ( *num == '-' ) {",
          "154:   sign = -1;",
          "155:   ++num;",
          "156:  }",
          "157:  if ( *num == '0' )",
          "159:   ++num;",
          "160:  if ( *num >= '1' && *num<='9' ) {",
          "162:   do {",
          "163:    i = ( i * 10 ) + ( *num - '0' );",
          "164:    f = ( f * 10.0 ) + ( *num - '0' );",
          "165:    ++num;",
          "166:   } while ( *num >= '0' && *num <= '9' );",
          "167:  }",
          "168:  if ( *num == '.' && num[1] >= '0' && num[1] <= '9' ) {",
          "170:   isint = 0;",
          "171:   ++num;",
          "172:   do {",
          "173:    f = ( f * 10.0 ) + ( *num++ - '0' );",
          "174:    scale--;",
          "175:   } while ( *num >= '0' && *num <= '9' );",
          "176:  }",
          "177:  if ( *num == 'e' || *num == 'E' ) {",
          "179:   isint = 0;",
          "180:   ++num;",
          "181:   if ( *num == '+' )",
          "182:    ++num;",
          "183:   else if ( *num == '-' ) {",
          "185:    signsubscale = -1;",
          "186:    ++num;",
          "187:   }",
          "188:   while ( *num >= '0' && *num <= '9' )",
          "189:    subscale = ( subscale * 10 ) + ( *num++ - '0' );",
          "190:  }",
          "193:  if ( isint ) {",
          "195:   i = sign * i;",
          "196:   item->valueint = i;",
          "197:   item->valuefloat = i;",
          "198:  } else {",
          "200:   f = sign * f * ipow( 10.0, scale + subscale * signsubscale );",
          "201:   item->valueint = f;",
          "202:   item->valuefloat = f;",
          "203:  }",
          "205:  item->type = cJSON_Number;",
          "206:  return num;",
          "211: static char *print_number( cJSON *item )",
          "214:  double f, f2;",
          "215:  int64_t i;",
          "217:  str = (char*) cJSON_malloc( 64 );",
          "218:  if ( str ) {",
          "219:   f = item->valuefloat;",
          "220:   i = f;",
          "221:   f2 = i;",
          "222:   if ( f2 == f && item->valueint >= LLONG_MIN && item->valueint <= LLONG_MAX )",
          "223:    sprintf( str, \"%lld\", (long long) item->valueint );",
          "224:   else",
          "225:    sprintf( str, \"%g\", item->valuefloat );",
          "234: static const char *parse_string( cJSON *item, const char *str )",
          "236:  const char *ptr = str + 1;",
          "237:  char *ptr2;",
          "238:  char *out;",
          "239:  int len = 0;",
          "240:  unsigned uc, uc2;",
          "242:  if ( *str != '\\\"' ) {",
          "244:   ep = str;",
          "245:   return 0;",
          "246:  }",
          "249:  while ( *ptr != '\\\"' && *ptr && ++len )",
          "250:   if ( *ptr++ == '\\\\' )",
          "251:    ptr++;",
          "253:  if ( ! ( out = (char*) cJSON_malloc( len + 1 ) ) )",
          "254:   return 0;",
          "256:  ptr = str + 1;",
          "257:  ptr2 = out;",
          "258:  while ( *ptr != '\\\"' && *ptr ) {",
          "259:   if ( *ptr != '\\\\' )",
          "261:   else {",
          "263:    switch ( *ptr ) {",
          "264:     case 'b': *ptr2++ ='\\b'; break;",
          "265:     case 'f': *ptr2++ ='\\f'; break;",
          "266:     case 'n': *ptr2++ ='\\n'; break;",
          "267:     case 'r': *ptr2++ ='\\r'; break;",
          "268:     case 't': *ptr2++ ='\\t'; break;",
          "269:     case 'u':",
          "272:      sscanf( ptr + 1,\"%4x\", &uc );",
          "273:      ptr += 4;",
          "275:      if ( ( uc >= 0xDC00 && uc <= 0xDFFF ) || uc == 0 )",
          "276:       break;",
          "279:      if ( uc >= 0xD800 && uc <= 0xDBFF ) {",
          "280:       if ( ptr[1] != '\\\\' || ptr[2] != 'u' )",
          "282:        break;",
          "283:       sscanf( ptr + 3, \"%4x\", &uc2 );",
          "284:       ptr += 6;",
          "285:       if ( uc2 < 0xDC00 || uc2 > 0xDFFF )",
          "287:        break;",
          "288:       uc = 0x10000 | ( ( uc & 0x3FF ) << 10 ) | ( uc2 & 0x3FF );",
          "291:      len = 4;",
          "292:      if ( uc < 0x80 )",
          "293:       len = 1;",
          "294:      else if ( uc < 0x800 )",
          "295:       len = 2;",
          "296:      else if ( uc < 0x10000 )",
          "297:       len = 3;",
          "298:      ptr2 += len;",
          "300:      switch ( len ) {",
          "301:       case 4: *--ptr2 = ( ( uc | 0x80) & 0xBF ); uc >>= 6;",
          "302:       case 3: *--ptr2 = ( ( uc | 0x80) & 0xBF ); uc >>= 6;",
          "303:       case 2: *--ptr2 = ( ( uc | 0x80) & 0xBF ); uc >>= 6;",
          "304:       case 1: *--ptr2 = ( uc | firstByteMark[len] );",
          "306:      ptr2 += len;",
          "308:     default:  *ptr2++ = *ptr; break;",
          "310:    ++ptr;",
          "314:  if ( *ptr == '\\\"' )",
          "315:   ++ptr;",
          "316:  item->valuestring = out;",
          "317:  item->type = cJSON_String;",
          "323: static char *print_string_ptr( const char *str )",
          "325:  const char *ptr;",
          "326:  char *ptr2, *out;",
          "327:  int len = 0;",
          "328:  unsigned char token;",
          "330:  if ( ! str )",
          "331:   return cJSON_strdup( \"\" );",
          "332:  ptr = str;",
          "333:  while ( ( token = *ptr ) && ++len ) {",
          "334:   if ( strchr( \"\\\"\\\\\\b\\f\\n\\r\\t\", token ) )",
          "335:    ++len;",
          "336:   else if ( token < 32 )",
          "337:    len += 5;",
          "338:   ++ptr;",
          "341:  if ( ! ( out = (char*) cJSON_malloc( len + 3 ) ) )",
          "342:   return 0;",
          "344:  ptr2 = out;",
          "345:  ptr = str;",
          "347:  while ( *ptr ) {",
          "348:   if ( (unsigned char) *ptr > 31 && *ptr != '\\\"' && *ptr != '\\\\' )",
          "350:   else {",
          "352:    switch ( token = *ptr++ ) {",
          "353:     case '\\\\': *ptr2++ = '\\\\'; break;",
          "354:     case '\\\"': *ptr2++ = '\\\"'; break;",
          "355:     case '\\b': *ptr2++ = 'b'; break;",
          "356:     case '\\f': *ptr2++ = 'f'; break;",
          "357:     case '\\n': *ptr2++ = 'n'; break;",
          "358:     case '\\r': *ptr2++ = 'r'; break;",
          "359:     case '\\t': *ptr2++ = 't'; break;",
          "360:     default:",
          "362:     sprintf( ptr2, \"u%04x\", token );",
          "363:     ptr2 += 5;",
          "364:     break;",
          "375: static char *print_string( cJSON *item )",
          "376: {",
          "377:  return print_string_ptr( item->valuestring );",
          "378: }",
          "382: static const char *parse_value( cJSON *item, const char *value );",
          "383: static char *print_value( cJSON *item, int depth, int fmt );",
          "384: static const char *parse_array( cJSON *item, const char *value );",
          "385: static char *print_array( cJSON *item, int depth, int fmt );",
          "386: static const char *parse_object( cJSON *item, const char *value );",
          "387: static char *print_object( cJSON *item, int depth, int fmt );",
          "390: static const char *skip( const char *in )",
          "391: {",
          "392:  while ( in && *in && (unsigned char) *in <= 32 )",
          "393:   in++;",
          "394:  return in;",
          "395: }",
          "399: cJSON *cJSON_Parse( const char *value )",
          "401:  cJSON *c;",
          "402:  ep = 0;",
          "403:  if ( ! ( c = cJSON_New_Item() ) )",
          "406:  if ( ! parse_value( c, skip( value ) ) ) {",
          "407:   cJSON_Delete( c );",
          "408:   return 0;",
          "409:  }",
          "415: char *cJSON_Print( cJSON *item )",
          "416: {",
          "417:  return print_value( item, 0, 1 );",
          "418: }",
          "419: char *cJSON_PrintUnformatted( cJSON *item )",
          "421:  return print_value( item, 0, 0 );",
          "426: static const char *parse_value( cJSON *item, const char *value )",
          "428:  if ( ! value )",
          "430:  if ( ! strncmp( value, \"null\", 4 ) ) {",
          "431:   item->type = cJSON_NULL;",
          "432:   return value + 4;",
          "433:  }",
          "434:  if ( ! strncmp( value, \"false\", 5 ) ) {",
          "435:   item->type = cJSON_False;",
          "436:   return value + 5;",
          "437:  }",
          "438:  if ( ! strncmp( value, \"true\", 4 ) ) {",
          "439:   item->type = cJSON_True;",
          "440:   item->valueint = 1;",
          "441:   return value + 4;",
          "442:  }",
          "443:  if ( *value == '\\\"' )",
          "444:   return parse_string( item, value );",
          "445:  if ( *value == '-' || ( *value >= '0' && *value <= '9' ) )",
          "446:   return parse_number( item, value );",
          "447:  if ( *value == '[' )",
          "448:   return parse_array( item, value );",
          "449:  if ( *value == '{' )",
          "450:   return parse_object( item, value );",
          "453:  ep = value;",
          "454:  return 0;",
          "459: static char *print_value( cJSON *item, int depth, int fmt )",
          "460: {",
          "461:  char *out = 0;",
          "463:  if ( ! item )",
          "464:   return 0;",
          "465:  switch ( ( item->type ) & 255 ) {",
          "466:   case cJSON_NULL:   out = cJSON_strdup( \"null\" ); break;",
          "467:   case cJSON_False:  out = cJSON_strdup( \"false\" ); break;",
          "468:   case cJSON_True:   out = cJSON_strdup( \"true\" ); break;",
          "469:   case cJSON_Number: out = print_number( item ); break;",
          "470:   case cJSON_String: out = print_string( item ); break;",
          "471:   case cJSON_Array:  out = print_array( item, depth, fmt ); break;",
          "472:   case cJSON_Object: out = print_object( item, depth, fmt ); break;",
          "479: static const char *parse_array( cJSON *item, const char *value )",
          "483:  if ( *value != '[' ) {",
          "485:   ep = value;",
          "486:   return 0;",
          "487:  }",
          "489:  item->type = cJSON_Array;",
          "490:  value = skip( value + 1 );",
          "491:  if ( *value == ']' )",
          "494:  if ( ! ( item->child = child = cJSON_New_Item() ) )",
          "496:  if ( ! ( value = skip( parse_value( child, skip( value ) ) ) ) )",
          "497:   return 0;",
          "499:  while ( *value == ',' ) {",
          "501:   if ( ! ( new_item = cJSON_New_Item() ) )",
          "503:   child->next = new_item;",
          "504:   new_item->prev = child;",
          "505:   child = new_item;",
          "506:   if ( ! ( value = skip( parse_value( child, skip( value+1 ) ) ) ) )",
          "510:  if ( *value == ']' )",
          "513:  ep = value;",
          "514:  return 0;",
          "519: static char *print_array( cJSON *item, int depth, int fmt )",
          "522:  char *out = 0, *ptr, *ret;",
          "523:  int len = 5;",
          "524:  cJSON *child = item->child;",
          "525:  int numentries = 0, i = 0, fail = 0;",
          "528:  while ( child ) {",
          "529:   ++numentries;",
          "530:   child = child->next;",
          "531:  }",
          "533:  if ( ! ( entries = (char**) cJSON_malloc( numentries * sizeof(char*) ) ) )",
          "534:   return 0;",
          "535:  memset( entries, 0, numentries * sizeof(char*) );",
          "537:  child = item->child;",
          "538:  while ( child && ! fail ) {",
          "539:   ret = print_value( child, depth + 1, fmt );",
          "540:   entries[i++] = ret;",
          "541:   if ( ret )",
          "542:    len += strlen( ret ) + 2 + ( fmt ? 1 : 0 );",
          "543:   else",
          "544:    fail = 1;",
          "545:   child = child -> next;",
          "546:  }",
          "549:  if ( ! fail ) {",
          "550:   out = (char*) cJSON_malloc( len );",
          "551:   if ( ! out )",
          "552:    fail = 1;",
          "553:  }",
          "556:  if ( fail ) {",
          "557:   for ( i = 0; i < numentries; ++i )",
          "558:    if ( entries[i] )",
          "559:     cJSON_free( entries[i] );",
          "560:   cJSON_free( entries );",
          "561:   return 0;",
          "566:  ptr = out + 1;",
          "568:  for ( i = 0; i < numentries; ++i ) {",
          "569:   strcpy( ptr, entries[i] );",
          "570:   ptr += strlen( entries[i] );",
          "571:   if ( i != numentries - 1 ) {",
          "573:    if ( fmt )",
          "577:   cJSON_free( entries[i] );",
          "579:  cJSON_free( entries );",
          "587: static const char *parse_object( cJSON *item, const char *value )",
          "591:  if ( *value != '{' ) {",
          "593:   ep = value;",
          "594:   return 0;",
          "595:  }",
          "597:  item->type = cJSON_Object;",
          "598:  value =skip( value + 1 );",
          "599:  if ( *value == '}' )",
          "602:  if ( ! ( item->child = child = cJSON_New_Item() ) )",
          "603:   return 0;",
          "604:  if ( ! ( value = skip( parse_string( child, skip( value ) ) ) ) )",
          "605:   return 0;",
          "606:  child->string = child->valuestring;",
          "607:  child->valuestring = 0;",
          "608:  if ( *value != ':' ) {",
          "610:   ep = value;",
          "611:   return 0;",
          "612:  }",
          "613:  if ( ! ( value = skip( parse_value( child, skip( value + 1 ) ) ) ) )",
          "614:   return 0;",
          "616:  while ( *value == ',' ) {",
          "618:   if ( ! ( new_item = cJSON_New_Item() ) )",
          "620:   child->next = new_item;",
          "621:   new_item->prev = child;",
          "622:   child = new_item;",
          "623:   if ( ! ( value = skip( parse_string( child, skip( value + 1 ) ) ) ) )",
          "624:    return 0;",
          "625:   child->string = child->valuestring;",
          "626:   child->valuestring = 0;",
          "627:   if ( *value != ':' ) {",
          "629:    ep = value;",
          "630:    return 0;",
          "631:   }",
          "632:   if ( ! ( value = skip( parse_value( child, skip( value + 1 ) ) ) ) )",
          "633:    return 0;",
          "636:  if ( *value == '}' )",
          "639:  ep = value;",
          "640:  return 0;",
          "645: static char *print_object( cJSON *item, int depth, int fmt )",
          "647:  char **entries = 0, **names = 0;",
          "648:  char *out = 0, *ptr, *ret, *str;",
          "649:  int len = 7, i = 0, j;",
          "650:  cJSON *child = item->child;",
          "651:  int numentries = 0, fail = 0;",
          "654:  while ( child ) {",
          "655:   ++numentries;",
          "656:   child = child->next;",
          "657:  }",
          "659:  if ( ! ( entries = (char**) cJSON_malloc( numentries * sizeof(char*) ) ) )",
          "660:   return 0;",
          "661:  if ( ! ( names = (char**) cJSON_malloc( numentries * sizeof(char*) ) ) ) {",
          "662:   cJSON_free( entries );",
          "663:   return 0;",
          "664:  }",
          "665:  memset( entries, 0, sizeof(char*) * numentries );",
          "666:  memset( names, 0, sizeof(char*) * numentries );",
          "669:  child = item->child;",
          "670:  ++depth;",
          "671:  if ( fmt )",
          "672:   len += depth;",
          "673:  while ( child ) {",
          "674:   names[i] = str = print_string_ptr( child->string );",
          "675:   entries[i++] = ret = print_value( child, depth, fmt );",
          "676:   if ( str && ret )",
          "677:    len += strlen( ret ) + strlen( str ) + 2 + ( fmt ? 2 + depth : 0 );",
          "678:   else",
          "679:    fail = 1;",
          "680:   child = child->next;",
          "681:  }",
          "684:  if ( ! fail ) {",
          "685:   out = (char*) cJSON_malloc( len );",
          "686:   if ( ! out )",
          "687:    fail = 1;",
          "688:  }",
          "691:  if ( fail ) {",
          "692:   for ( i = 0; i < numentries; ++i ) {",
          "693:    if ( names[i] )",
          "694:     cJSON_free( names[i] );",
          "695:    if ( entries[i] )",
          "696:     cJSON_free( entries[i] );",
          "698:   cJSON_free( names );",
          "699:   cJSON_free( entries );",
          "700:   return 0;",
          "705:  ptr = out + 1;",
          "706:  if ( fmt )",
          "709:  for ( i = 0; i < numentries; ++i ) {",
          "710:   if ( fmt )",
          "711:    for ( j = 0; j < depth; ++j )",
          "713:   strcpy( ptr, names[i] );",
          "714:   ptr += strlen( names[i] );",
          "716:   if ( fmt )",
          "718:   strcpy( ptr, entries[i] );",
          "719:   ptr += strlen( entries[i] );",
          "720:   if ( i != numentries - 1 )",
          "722:   if ( fmt )",
          "725:   cJSON_free( names[i] );",
          "726:   cJSON_free( entries[i] );",
          "729:  cJSON_free( names );",
          "730:  cJSON_free( entries );",
          "731:  if ( fmt )",
          "732:   for ( i = 0; i < depth - 1; ++i )",
          "740: int cJSON_GetArraySize( cJSON *array )",
          "741: {",
          "742:  cJSON *c = array->child;",
          "743:  int i = 0;",
          "744:  while ( c ) {",
          "745:   ++i;",
          "746:   c = c->next;",
          "747:  }",
          "748:  return i;",
          "749: }",
          "752: cJSON *cJSON_GetArrayItem( cJSON *array, int item )",
          "753: {",
          "754:  cJSON *c = array->child;",
          "755:  while ( c && item > 0 ) {",
          "756:   --item;",
          "757:   c = c->next;",
          "758:  }",
          "759:  return c;",
          "760: }",
          "763: cJSON *cJSON_GetObjectItem( cJSON *object, const char *string )",
          "764: {",
          "765:  cJSON *c = object->child;",
          "766:  while ( c && cJSON_strcasecmp( c->string, string ) )",
          "767:   c = c->next;",
          "768:  return c;",
          "769: }",
          "773: static void suffix_object( cJSON *prev, cJSON *item )",
          "774: {",
          "775:  prev->next = item;",
          "776:  item->prev = prev;",
          "777: }",
          "781: static cJSON *create_reference( cJSON *item )",
          "782: {",
          "783:  cJSON *ref;",
          "784:  if ( ! ( ref = cJSON_New_Item() ) )",
          "785:   return 0;",
          "786:  memcpy( ref, item, sizeof(cJSON) );",
          "787:  ref->string = 0;",
          "788:  ref->type |= cJSON_IsReference;",
          "789:  ref->next = ref->prev = 0;",
          "790:  return ref;",
          "791: }",
          "795: void cJSON_AddItemToArray( cJSON *array, cJSON *item )",
          "796: {",
          "797:  cJSON *c = array->child;",
          "798:  if ( ! item )",
          "799:   return;",
          "800:  if ( ! c ) {",
          "801:   array->child = item;",
          "802:  } else {",
          "803:   while ( c && c->next )",
          "804:    c = c->next;",
          "805:   suffix_object( c, item );",
          "806:  }",
          "807: }",
          "809: void cJSON_AddItemToObject( cJSON *object, const char *string, cJSON *item )",
          "810: {",
          "811:  if ( ! item )",
          "812:   return;",
          "813:  if ( item->string )",
          "814:   cJSON_free( item->string );",
          "815:  item->string = cJSON_strdup( string );",
          "816:  cJSON_AddItemToArray( object, item );",
          "817: }",
          "819: void cJSON_AddItemReferenceToArray( cJSON *array, cJSON *item )",
          "820: {",
          "821:  cJSON_AddItemToArray( array, create_reference( item ) );",
          "822: }",
          "824: void cJSON_AddItemReferenceToObject( cJSON *object, const char *string, cJSON *item )",
          "825: {",
          "826:  cJSON_AddItemToObject( object, string, create_reference( item ) );",
          "827: }",
          "829: cJSON *cJSON_DetachItemFromArray( cJSON *array, int which )",
          "830: {",
          "831:  cJSON *c = array->child;",
          "832:  while ( c && which > 0 ) {",
          "833:   c = c->next;",
          "834:   --which;",
          "835:  }",
          "836:  if ( ! c )",
          "837:   return 0;",
          "838:  if ( c->prev )",
          "839:   c->prev->next = c->next;",
          "840:  if ( c->next ) c->next->prev = c->prev;",
          "841:  if ( c == array->child )",
          "842:   array->child = c->next;",
          "843:  c->prev = c->next = 0;",
          "844:  return c;",
          "845: }",
          "847: void cJSON_DeleteItemFromArray( cJSON *array, int which )",
          "848: {",
          "849:  cJSON_Delete( cJSON_DetachItemFromArray( array, which ) );",
          "850: }",
          "852: cJSON *cJSON_DetachItemFromObject( cJSON *object, const char *string )",
          "853: {",
          "854:  int i = 0;",
          "855:  cJSON *c = object->child;",
          "856:  while ( c && cJSON_strcasecmp( c->string, string ) ) {",
          "857:   ++i;",
          "858:   c = c->next;",
          "859:  }",
          "860:  if ( c )",
          "861:   return cJSON_DetachItemFromArray( object, i );",
          "862:  return 0;",
          "863: }",
          "865: void cJSON_DeleteItemFromObject( cJSON *object, const char *string )",
          "866: {",
          "867:  cJSON_Delete( cJSON_DetachItemFromObject( object, string ) );",
          "868: }",
          "871: void cJSON_ReplaceItemInArray( cJSON *array, int which, cJSON *newitem )",
          "872: {",
          "873:  cJSON *c = array->child;",
          "874:  while ( c && which > 0 ) {",
          "875:   c = c->next;",
          "876:   --which;",
          "877:  }",
          "878:  if ( ! c )",
          "879:   return;",
          "880:  newitem->next = c->next;",
          "881:  newitem->prev = c->prev;",
          "882:  if ( newitem->next )",
          "883:   newitem->next->prev = newitem;",
          "884:  if ( c == array->child )",
          "885:   array->child = newitem;",
          "886:  else",
          "887:   newitem->prev->next = newitem;",
          "888:  c->next = c->prev = 0;",
          "889:  cJSON_Delete( c );",
          "890: }",
          "892: void cJSON_ReplaceItemInObject( cJSON *object, const char *string, cJSON *newitem )",
          "893: {",
          "894:  int i = 0;",
          "895:  cJSON *c = object->child;",
          "896:  while ( c && cJSON_strcasecmp( c->string, string ) ) {",
          "897:   ++i;",
          "898:   c = c->next;",
          "899:  }",
          "900:  if ( c ) {",
          "901:   newitem->string = cJSON_strdup( string );",
          "902:   cJSON_ReplaceItemInArray( object, i, newitem );",
          "903:  }",
          "904: }",
          "909: cJSON *cJSON_CreateNull( void )",
          "910: {",
          "911:  cJSON *item = cJSON_New_Item();",
          "912:  if ( item )",
          "913:   item->type = cJSON_NULL;",
          "914:  return item;",
          "915: }",
          "917: cJSON *cJSON_CreateTrue( void )",
          "918: {",
          "919:  cJSON *item = cJSON_New_Item();",
          "920:  if ( item )",
          "921:   item->type = cJSON_True;",
          "922:  return item;",
          "923: }",
          "925: cJSON *cJSON_CreateFalse( void )",
          "926: {",
          "927:  cJSON *item = cJSON_New_Item();",
          "928:  if ( item )",
          "929:   item->type = cJSON_False;",
          "930:  return item;",
          "931: }",
          "933: cJSON *cJSON_CreateBool( int b )",
          "934: {",
          "935:  cJSON *item = cJSON_New_Item();",
          "936:  if ( item )",
          "937:   item->type = b ? cJSON_True : cJSON_False;",
          "938:  return item;",
          "939: }",
          "941: cJSON *cJSON_CreateInt( int64_t num )",
          "942: {",
          "943:  cJSON *item = cJSON_New_Item();",
          "944:  if ( item ) {",
          "945:   item->type = cJSON_Number;",
          "946:   item->valuefloat = num;",
          "947:   item->valueint = num;",
          "948:  }",
          "949:  return item;",
          "950: }",
          "952: cJSON *cJSON_CreateFloat( double num )",
          "953: {",
          "954:  cJSON *item = cJSON_New_Item();",
          "955:  if ( item ) {",
          "956:   item->type = cJSON_Number;",
          "957:   item->valuefloat = num;",
          "958:   item->valueint = num;",
          "959:  }",
          "960:  return item;",
          "961: }",
          "963: cJSON *cJSON_CreateString( const char *string )",
          "964: {",
          "965:  cJSON *item = cJSON_New_Item();",
          "966:  if ( item ) {",
          "967:   item->type = cJSON_String;",
          "968:   item->valuestring = cJSON_strdup( string );",
          "969:  }",
          "970:  return item;",
          "971: }",
          "973: cJSON *cJSON_CreateArray( void )",
          "974: {",
          "975:  cJSON *item = cJSON_New_Item();",
          "976:  if ( item )",
          "977:   item->type = cJSON_Array;",
          "978:  return item;",
          "979: }",
          "981: cJSON *cJSON_CreateObject( void )",
          "982: {",
          "983:  cJSON *item = cJSON_New_Item();",
          "984:  if ( item )",
          "985:   item->type = cJSON_Object;",
          "986:  return item;",
          "987: }",
          "992: cJSON *cJSON_CreateIntArray( int64_t *numbers, int count )",
          "993: {",
          "994:  int i;",
          "995:  cJSON *n = 0, *p = 0, *a = cJSON_CreateArray();",
          "996:  for ( i = 0; a && i < count; ++i ) {",
          "997:   n = cJSON_CreateInt( numbers[i] );",
          "998:   if ( ! i )",
          "999:    a->child = n;",
          "1000:   else",
          "1001:    suffix_object( p, n );",
          "1002:   p = n;",
          "1003:  }",
          "1004:  return a;",
          "1005: }",
          "1007: cJSON *cJSON_CreateFloatArray( double *numbers, int count )",
          "1008: {",
          "1009:  int i;",
          "1010:  cJSON *n = 0, *p = 0, *a = cJSON_CreateArray();",
          "1011:  for ( i = 0; a && i < count; ++i ) {",
          "1012:   n = cJSON_CreateFloat( numbers[i] );",
          "1013:   if ( ! i )",
          "1014:    a->child = n;",
          "1015:   else",
          "1016:    suffix_object( p, n );",
          "1017:   p = n;",
          "1018:  }",
          "1019:  return a;",
          "1020: }",
          "1022: cJSON *cJSON_CreateStringArray( const char **strings, int count )",
          "1023: {",
          "1024:  int i;",
          "1025:  cJSON *n = 0, *p = 0, *a = cJSON_CreateArray();",
          "1026:  for ( i = 0; a && i < count; ++i ) {",
          "1027:   n = cJSON_CreateString( strings[i] );",
          "1028:   if ( ! i )",
          "1029:    a->child = n;",
          "1030:   else",
          "1031:    suffix_object( p, n );",
          "1032:   p = n;",
          "1033:  }",
          "1034:  return a;",
          "",
          "[Added Lines]",
          "45: static const char *global_ep;",
          "47: const char *cJSON_GetErrorPtr(void) {return global_ep;}",
          "49: static int cJSON_strcasecmp(const char *s1,const char *s2)",
          "51:  if (!s1) return (s1==s2)?0:1;if (!s2) return 1;",
          "52:  for(; tolower(*s1) == tolower(*s2); ++s1, ++s2) if(*s1 == 0) return 0;",
          "53:  return tolower(*(const unsigned char *)s1) - tolower(*(const unsigned char *)s2);",
          "56: static void *(*cJSON_malloc)(size_t sz) = malloc;",
          "57: static void (*cJSON_free)(void *ptr) = free;",
          "59: static char* cJSON_strdup(const char* str)",
          "61:       size_t len;",
          "62:       char* copy;",
          "64:       len = strlen(str) + 1;",
          "65:       if (!(copy = (char*)cJSON_malloc(len))) return 0;",
          "66:       memcpy(copy,str,len);",
          "67:       return copy;",
          "70: void cJSON_InitHooks(cJSON_Hooks* hooks)",
          "73:         cJSON_malloc = malloc;",
          "74:         cJSON_free = free;",
          "75:         return;",
          "76:     }",
          "78:  cJSON_malloc = (hooks->malloc_fn)?hooks->malloc_fn:malloc;",
          "79:  cJSON_free  = (hooks->free_fn)?hooks->free_fn:free;",
          "83: static cJSON *cJSON_New_Item(void)",
          "85:  cJSON* node = (cJSON*)cJSON_malloc(sizeof(cJSON));",
          "86:  if (node) memset(node,0,sizeof(cJSON));",
          "91: void cJSON_Delete(cJSON *c)",
          "94:  while (c)",
          "95:  {",
          "96:   next=c->next;",
          "97:   if (!(c->type&cJSON_IsReference) && c->child) cJSON_Delete(c->child);",
          "98:   if (!(c->type&cJSON_IsReference) && c->valuestring) cJSON_free(c->valuestring);",
          "99:   if (!(c->type&cJSON_StringIsConst) && c->string) cJSON_free(c->string);",
          "100:   cJSON_free(c);",
          "101:   c=next;",
          "106: static const char *parse_number(cJSON *item,const char *num)",
          "108:  double n=0,sign=1,scale=0;int subscale=0,signsubscale=1;",
          "121:  item->valuedouble=n;",
          "122:  item->valueint=(int64_t)n;",
          "123:  item->type=cJSON_Number;",
          "124:  return num;",
          "127: static int pow2gt (int x) { --x; x|=x>>1; x|=x>>2; x|=x>>4; x|=x>>8; x|=x>>16; return x+1; }",
          "129: typedef struct {char *buffer; int length; int offset; } printbuffer;",
          "131: static char* ensure(printbuffer *p,int needed)",
          "132: {",
          "133:  char *newbuffer;int newsize;",
          "134:  if (!p || !p->buffer) return 0;",
          "135:  needed+=p->offset;",
          "136:  if (needed<=p->length) return p->buffer+p->offset;",
          "138:  newsize=pow2gt(needed);",
          "139:  newbuffer=(char*)cJSON_malloc(newsize);",
          "140:  if (!newbuffer) {cJSON_free(p->buffer);p->length=0,p->buffer=0;return 0;}",
          "141:  if (newbuffer) memcpy(newbuffer,p->buffer,p->length);",
          "142:  cJSON_free(p->buffer);",
          "143:  p->length=newsize;",
          "144:  p->buffer=newbuffer;",
          "145:  return newbuffer+p->offset;",
          "148: static int update(printbuffer *p)",
          "151:  if (!p || !p->buffer) return 0;",
          "152:  str=p->buffer+p->offset;",
          "153:  return p->offset+strlen(str);",
          "154: }",
          "157: static char *print_number(cJSON *item,printbuffer *p)",
          "158: {",
          "159:  char *str=0;",
          "160:  double d=item->valuedouble;",
          "161:  if (d==0)",
          "162:  {",
          "163:   if (p) str=ensure(p,2);",
          "165:   if (str) strcpy(str,\"0\");",
          "166:  }",
          "167:  else if (fabs(((double)item->valueint)-d)<=DBL_EPSILON && d<=LLONG_MAX && d>=LLONG_MIN)",
          "168:  {",
          "169:   if (p) str=ensure(p,64);",
          "170:   else str=(char*)cJSON_malloc(64);",
          "171:   if (str) sprintf(str,\"%lld\",(long long) item->valueint);",
          "172:  }",
          "173:  else",
          "174:  {",
          "175:   if (p) str=ensure(p,64);",
          "177:   if (str)",
          "178:   {",
          "179:    if (fpclassify(d) != FP_ZERO && !isnormal(d))    sprintf(str,\"null\");",
          "180:    else if (fabs(floor(d)-d)<=DBL_EPSILON && fabs(d)<1.0e60) sprintf(str,\"%.0f\",d);",
          "181:    else if (fabs(d)<1.0e-6 || fabs(d)>1.0e9)     sprintf(str,\"%e\",d);",
          "182:    else              sprintf(str,\"%f\",d);",
          "183:   }",
          "188: static unsigned parse_hex4(const char *str)",
          "189: {",
          "190:  unsigned h=0;",
          "191:  if (*str>='0' && *str<='9') h+=(*str)-'0'; else if (*str>='A' && *str<='F') h+=10+(*str)-'A'; else if (*str>='a' && *str<='f') h+=10+(*str)-'a'; else return 0;",
          "192:  h=h<<4;str++;",
          "193:  if (*str>='0' && *str<='9') h+=(*str)-'0'; else if (*str>='A' && *str<='F') h+=10+(*str)-'A'; else if (*str>='a' && *str<='f') h+=10+(*str)-'a'; else return 0;",
          "194:  h=h<<4;str++;",
          "195:  if (*str>='0' && *str<='9') h+=(*str)-'0'; else if (*str>='A' && *str<='F') h+=10+(*str)-'A'; else if (*str>='a' && *str<='f') h+=10+(*str)-'a'; else return 0;",
          "196:  h=h<<4;str++;",
          "197:  if (*str>='0' && *str<='9') h+=(*str)-'0'; else if (*str>='A' && *str<='F') h+=10+(*str)-'A'; else if (*str>='a' && *str<='f') h+=10+(*str)-'a'; else return 0;",
          "198:  return h;",
          "199: }",
          "203: static const char *parse_string(cJSON *item,const char *str,const char **ep)",
          "205:  const char *ptr=str+1,*end_ptr=str+1;char *ptr2;char *out;int len=0;unsigned uc,uc2;",
          "211:  if (!out) return 0;",
          "213:  item->type=cJSON_String;",
          "215:  ptr=str+1;ptr2=out;",
          "216:  while (ptr < end_ptr)",
          "217:  {",
          "218:   if (*ptr!='\\\\') *ptr2++=*ptr++;",
          "219:   else",
          "220:   {",
          "222:    switch (*ptr)",
          "223:    {",
          "224:     case 'b': *ptr2++='\\b'; break;",
          "225:     case 'f': *ptr2++='\\f'; break;",
          "226:     case 'n': *ptr2++='\\n'; break;",
          "227:     case 'r': *ptr2++='\\r'; break;",
          "228:     case 't': *ptr2++='\\t'; break;",
          "236:      {",
          "239:       uc2=parse_hex4(ptr+3);ptr+=6;",
          "241:       uc=0x10000 + (((uc&0x3FF)<<10) | (uc2&0x3FF));",
          "244:      len=4;if (uc<0x80) len=1;else if (uc<0x800) len=2;else if (uc<0x10000) len=3; ptr2+=len;",
          "246:      switch (len) {",
          "247:       case 4: *--ptr2 =((uc | 0x80) & 0xBF); uc >>= 6;",
          "248:       case 3: *--ptr2 =((uc | 0x80) & 0xBF); uc >>= 6;",
          "249:       case 2: *--ptr2 =((uc | 0x80) & 0xBF); uc >>= 6;",
          "250:       case 1: *--ptr2 =(uc | firstByteMark[len]);",
          "252:      ptr2+=len;",
          "254:     default:  *ptr2++=*ptr; break;",
          "256:    ptr++;",
          "260:  if (*ptr=='\\\"') ptr++;",
          "265: static char *print_string_ptr(const char *str,printbuffer *p)",
          "267:  const char *ptr;char *ptr2,*out;int len=0,flag=0;unsigned char token;",
          "269:  if (!str)",
          "270:  {",
          "271:   if (p) out=ensure(p,3);",
          "272:   else out=(char*)cJSON_malloc(3);",
          "273:   if (!out) return 0;",
          "274:   strcpy(out,\"\\\"\\\"\");",
          "275:   return out;",
          "276:  }",
          "278:  for (ptr=str;*ptr;ptr++) flag|=((*ptr>0 && *ptr<32)||(*ptr=='\\\"')||(*ptr=='\\\\'))?1:0;",
          "279:  if (!flag)",
          "280:  {",
          "281:   len=ptr-str;",
          "282:   if (p) out=ensure(p,len+3);",
          "283:   else  out=(char*)cJSON_malloc(len+3);",
          "284:   if (!out) return 0;",
          "285:   ptr2=out;*ptr2++='\\\"';",
          "286:   strcpy(ptr2,str);",
          "287:   ptr2[len]='\\\"';",
          "288:   ptr2[len+1]=0;",
          "289:   return out;",
          "292:  ptr=str;while ((token=*ptr) && ++len) {if (strchr(\"\\\"\\\\\\b\\f\\n\\r\\t\",token)) len++; else if (token<32) len+=5;ptr++;}",
          "294:  if (p) out=ensure(p,len+3);",
          "295:  else out=(char*)cJSON_malloc(len+3);",
          "296:  if (!out) return 0;",
          "298:  ptr2=out;ptr=str;",
          "300:  while (*ptr)",
          "301:  {",
          "302:   if ((unsigned char)*ptr>31 && *ptr!='\\\"' && *ptr!='\\\\') *ptr2++=*ptr++;",
          "303:   else",
          "304:   {",
          "306:    switch (token=*ptr++)",
          "307:    {",
          "308:     case '\\\\': *ptr2++='\\\\'; break;",
          "309:     case '\\\"': *ptr2++='\\\"'; break;",
          "310:     case '\\b': *ptr2++='b'; break;",
          "311:     case '\\f': *ptr2++='f'; break;",
          "312:     case '\\n': *ptr2++='n'; break;",
          "313:     case '\\r': *ptr2++='r'; break;",
          "314:     case '\\t': *ptr2++='t'; break;",
          "323: static char *print_string(cJSON *item,printbuffer *p) {return print_string_ptr(item->valuestring,p);}",
          "326: static const char *parse_value(cJSON *item,const char *value,const char **ep);",
          "327: static char *print_value(cJSON *item,int depth,int fmt,printbuffer *p);",
          "328: static const char *parse_array(cJSON *item,const char *value,const char **ep);",
          "329: static char *print_array(cJSON *item,int depth,int fmt,printbuffer *p);",
          "330: static const char *parse_object(cJSON *item,const char *value,const char **ep);",
          "331: static char *print_object(cJSON *item,int depth,int fmt,printbuffer *p);",
          "334: static const char *skip(const char *in) {while (in && *in && (unsigned char)*in<=32) in++; return in;}",
          "337: cJSON *cJSON_ParseWithOpts(const char *value,const char **return_parse_end,int require_null_terminated)",
          "339:  const char *end=0,**ep=return_parse_end?return_parse_end:&global_ep;",
          "340:  cJSON *c=cJSON_New_Item();",
          "344:  end=parse_value(c,skip(value),ep);",
          "348:  if (require_null_terminated) {end=skip(end);if (*end) {cJSON_Delete(c);*ep=end;return 0;}}",
          "349:  if (return_parse_end) *return_parse_end=end;",
          "353: cJSON *cJSON_Parse(const char *value) {return cJSON_ParseWithOpts(value,0,0);}",
          "356: char *cJSON_Print(cJSON *item)    {return print_value(item,0,1,0);}",
          "357: char *cJSON_PrintUnformatted(cJSON *item) {return print_value(item,0,0,0);}",
          "359: char *cJSON_PrintBuffered(cJSON *item,int prebuffer,int fmt)",
          "361:  printbuffer p;",
          "362:  p.buffer=(char*)cJSON_malloc(prebuffer);",
          "363:  p.length=prebuffer;",
          "364:  p.offset=0;",
          "365:  return print_value(item,0,fmt,&p);",
          "370: static const char *parse_value(cJSON *item,const char *value,const char **ep)",
          "373:  if (!strncmp(value,\"null\",4)) { item->type=cJSON_NULL;  return value+4; }",
          "374:  if (!strncmp(value,\"false\",5)) { item->type=cJSON_False; return value+5; }",
          "375:  if (!strncmp(value,\"true\",4)) { item->type=cJSON_True; item->valueint=1; return value+4; }",
          "376:  if (*value=='\\\"')    { return parse_string(item,value,ep); }",
          "377:  if (*value=='-' || (*value>='0' && *value<='9')) { return parse_number(item,value); }",
          "378:  if (*value=='[')    { return parse_array(item,value,ep); }",
          "379:  if (*value=='{')    { return parse_object(item,value,ep); }",
          "385: static char *print_value(cJSON *item,int depth,int fmt,printbuffer *p)",
          "386: {",
          "387:  char *out=0;",
          "388:  if (!item) return 0;",
          "389:  if (p)",
          "390:  {",
          "391:   switch ((item->type)&255)",
          "392:   {",
          "393:    case cJSON_NULL: {out=ensure(p,5); if (out) strcpy(out,\"null\"); break;}",
          "394:    case cJSON_False: {out=ensure(p,6); if (out) strcpy(out,\"false\"); break;}",
          "395:    case cJSON_True: {out=ensure(p,5); if (out) strcpy(out,\"true\"); break;}",
          "396:    case cJSON_Number: out=print_number(item,p);break;",
          "397:    case cJSON_String: out=print_string(item,p);break;",
          "398:    case cJSON_Array: out=print_array(item,depth,fmt,p);break;",
          "399:    case cJSON_Object: out=print_object(item,depth,fmt,p);break;",
          "400:   }",
          "401:  }",
          "402:  else",
          "403:  {",
          "404:   switch ((item->type)&255)",
          "405:   {",
          "406:    case cJSON_NULL: out=cJSON_strdup(\"null\"); break;",
          "407:    case cJSON_False: out=cJSON_strdup(\"false\");break;",
          "408:    case cJSON_True: out=cJSON_strdup(\"true\"); break;",
          "409:    case cJSON_Number: out=print_number(item,0);break;",
          "410:    case cJSON_String: out=print_string(item,0);break;",
          "411:    case cJSON_Array: out=print_array(item,depth,fmt,0);break;",
          "412:    case cJSON_Object: out=print_object(item,depth,fmt,0);break;",
          "413:   }",
          "419: static const char *parse_array(cJSON *item,const char *value,const char **ep)",
          "424:  item->type=cJSON_Array;",
          "425:  value=skip(value+1);",
          "428:  item->child=child=cJSON_New_Item();",
          "431:  if (!value) return 0;",
          "433:  while (*value==',')",
          "434:  {",
          "437:   child->next=new_item;new_item->prev=child;child=new_item;",
          "438:   value=skip(parse_value(child,skip(value+1),ep));",
          "447: static char *print_array(cJSON *item,int depth,int fmt,printbuffer *p)",
          "450:  char *out=0,*ptr,*ret;int len=5;",
          "451:  cJSON *child=item->child;",
          "452:  int numentries=0,i=0,fail=0;",
          "453:  size_t tmplen=0;",
          "456:  while (child) numentries++,child=child->next;",
          "458:  if (!numentries)",
          "459:  {",
          "460:   if (p) out=ensure(p,3);",
          "461:   else out=(char*)cJSON_malloc(3);",
          "462:   if (out) strcpy(out,\"[]\");",
          "463:   return out;",
          "464:  }",
          "466:  if (p)",
          "467:  {",
          "469:   i=p->offset;",
          "470:   ptr=ensure(p,1);if (!ptr) return 0; *ptr='['; p->offset++;",
          "471:   child=item->child;",
          "472:   while (child && !fail)",
          "473:   {",
          "474:    print_value(child,depth+1,fmt,p);",
          "475:    p->offset=update(p);",
          "476:    if (child->next) {len=fmt?2:1;ptr=ensure(p,len+1);if (!ptr) return 0;*ptr++=',';if(fmt)*ptr++=' ';*ptr=0;p->offset+=len;}",
          "477:    child=child->next;",
          "478:   }",
          "479:   ptr=ensure(p,2);if (!ptr) return 0; *ptr++=']';*ptr=0;",
          "480:   out=(p->buffer)+i;",
          "482:  else",
          "483:  {",
          "485:   entries=(char**)cJSON_malloc(numentries*sizeof(char*));",
          "486:   if (!entries) return 0;",
          "487:   memset(entries,0,numentries*sizeof(char*));",
          "489:   child=item->child;",
          "490:   while (child && !fail)",
          "491:   {",
          "492:    ret=print_value(child,depth+1,fmt,0);",
          "493:    entries[i++]=ret;",
          "494:    if (ret) len+=strlen(ret)+2+(fmt?1:0); else fail=1;",
          "495:    child=child->next;",
          "496:   }",
          "499:   if (!fail) out=(char*)cJSON_malloc(len);",
          "501:   if (!out) fail=1;",
          "504:   if (fail)",
          "505:   {",
          "506:    for (i=0;i<numentries;i++) if (entries[i]) cJSON_free(entries[i]);",
          "507:    cJSON_free(entries);",
          "508:    return 0;",
          "509:   }",
          "513:   ptr=out+1;*ptr=0;",
          "514:   for (i=0;i<numentries;i++)",
          "515:   {",
          "516:    tmplen=strlen(entries[i]);memcpy(ptr,entries[i],tmplen);ptr+=tmplen;",
          "517:    if (i!=numentries-1) {*ptr++=',';if(fmt)*ptr++=' ';*ptr=0;}",
          "518:    cJSON_free(entries[i]);",
          "520:   cJSON_free(entries);",
          "527: static const char *parse_object(cJSON *item,const char *value,const char **ep)",
          "532:  item->type=cJSON_Object;",
          "533:  value=skip(value+1);",
          "536:  item->child=child=cJSON_New_Item();",
          "537:  if (!item->child) return 0;",
          "538:  value=skip(parse_string(child,skip(value),ep));",
          "539:  if (!value) return 0;",
          "540:  child->string=child->valuestring;child->valuestring=0;",
          "543:  if (!value) return 0;",
          "545:  while (*value==',')",
          "546:  {",
          "549:   child->next=new_item;new_item->prev=child;child=new_item;",
          "550:   value=skip(parse_string(child,skip(value+1),ep));",
          "551:   if (!value) return 0;",
          "552:   child->string=child->valuestring;child->valuestring=0;",
          "555:   if (!value) return 0;",
          "563: static char *print_object(cJSON *item,int depth,int fmt,printbuffer *p)",
          "565:  char **entries=0,**names=0;",
          "566:  char *out=0,*ptr,*ret,*str;int len=7,i=0,j;",
          "567:  cJSON *child=item->child;",
          "568:  int numentries=0,fail=0;",
          "569:  size_t tmplen=0;",
          "571:  while (child) numentries++,child=child->next;",
          "573:  if (!numentries)",
          "574:  {",
          "575:   if (p) out=ensure(p,fmt?depth+4:3);",
          "576:   else out=(char*)cJSON_malloc(fmt?depth+4:3);",
          "577:   if (!out) return 0;",
          "578:   ptr=out;*ptr++='{';",
          "579:   if (fmt) {*ptr++='\\n';for (i=0;i<depth;i++) *ptr++='\\t';}",
          "581:   return out;",
          "582:  }",
          "583:  if (p)",
          "584:  {",
          "586:   i=p->offset;",
          "587:   len=fmt?2:1; ptr=ensure(p,len+1); if (!ptr) return 0;",
          "589:   child=item->child;depth++;",
          "590:   while (child)",
          "591:   {",
          "592:    if (fmt)",
          "593:    {",
          "594:     ptr=ensure(p,depth); if (!ptr) return 0;",
          "595:     for (j=0;j<depth;j++) *ptr++='\\t';",
          "596:     p->offset+=depth;",
          "597:    }",
          "598:    print_string_ptr(child->string,p);",
          "599:    p->offset=update(p);",
          "601:    len=fmt?2:1;",
          "602:    ptr=ensure(p,len); if (!ptr) return 0;",
          "604:    p->offset+=len;",
          "606:    print_value(child,depth,fmt,p);",
          "607:    p->offset=update(p);",
          "609:    len=(fmt?1:0)+(child->next?1:0);",
          "610:    ptr=ensure(p,len+1); if (!ptr) return 0;",
          "611:    if (child->next) *ptr++=',';",
          "612:    if (fmt) *ptr++='\\n';*ptr=0;",
          "613:    p->offset+=len;",
          "614:    child=child->next;",
          "616:   ptr=ensure(p,fmt?(depth+1):2);  if (!ptr) return 0;",
          "617:   if (fmt) for (i=0;i<depth-1;i++) *ptr++='\\t';",
          "619:   out=(p->buffer)+i;",
          "621:  else",
          "622:  {",
          "624:   entries=(char**)cJSON_malloc(numentries*sizeof(char*));",
          "625:   if (!entries) return 0;",
          "626:   names=(char**)cJSON_malloc(numentries*sizeof(char*));",
          "627:   if (!names) {cJSON_free(entries);return 0;}",
          "628:   memset(entries,0,sizeof(char*)*numentries);",
          "629:   memset(names,0,sizeof(char*)*numentries);",
          "632:   child=item->child;depth++;if (fmt) len+=depth;",
          "633:   while (child && !fail)",
          "634:   {",
          "635:    names[i]=str=print_string_ptr(child->string,0);",
          "636:    entries[i++]=ret=print_value(child,depth,fmt,0);",
          "637:    if (str && ret) len+=strlen(ret)+strlen(str)+2+(fmt?2+depth:0); else fail=1;",
          "638:    child=child->next;",
          "639:   }",
          "642:   if (!fail) out=(char*)cJSON_malloc(len);",
          "643:   if (!out) fail=1;",
          "646:   if (fail)",
          "647:   {",
          "648:    for (i=0;i<numentries;i++) {if (names[i]) cJSON_free(names[i]);if (entries[i]) cJSON_free(entries[i]);}",
          "649:    cJSON_free(names);cJSON_free(entries);",
          "650:    return 0;",
          "651:   }",
          "655:   for (i=0;i<numentries;i++)",
          "656:   {",
          "657:    if (fmt) for (j=0;j<depth;j++) *ptr++='\\t';",
          "658:    tmplen=strlen(names[i]);memcpy(ptr,names[i],tmplen);ptr+=tmplen;",
          "660:    strcpy(ptr,entries[i]);ptr+=strlen(entries[i]);",
          "661:    if (i!=numentries-1) *ptr++=',';",
          "662:    if (fmt) *ptr++='\\n';*ptr=0;",
          "663:    cJSON_free(names[i]);cJSON_free(entries[i]);",
          "664:   }",
          "666:   cJSON_free(names);cJSON_free(entries);",
          "667:   if (fmt) for (i=0;i<depth-1;i++) *ptr++='\\t';",
          "674: int    cJSON_GetArraySize(cJSON *array)       {cJSON *c=array->child;int i=0;while(c)i++,c=c->next;return i;}",
          "675: cJSON *cJSON_GetArrayItem(cJSON *array,int item)    {cJSON *c=array?array->child:0;while (c && item>0) item--,c=c->next; return c;}",
          "676: cJSON *cJSON_GetObjectItem(cJSON *object,const char *string) {cJSON *c=object?object->child:0;while (c && cJSON_strcasecmp(c->string,string)) c=c->next; return c;}",
          "677: int cJSON_HasObjectItem(cJSON *object,const char *string)  {return cJSON_GetObjectItem(object,string)?1:0;}",
          "680: static void suffix_object(cJSON *prev,cJSON *item) {prev->next=item;item->prev=prev;}",
          "682: static cJSON *create_reference(cJSON *item) {cJSON *ref=cJSON_New_Item();if (!ref) return 0;memcpy(ref,item,sizeof(cJSON));ref->string=0;ref->type|=cJSON_IsReference;ref->next=ref->prev=0;return ref;}",
          "685: void   cJSON_AddItemToArray(cJSON *array, cJSON *item)      {cJSON *c=array->child;if (!item) return; if (!c) {array->child=item;} else {while (c && c->next) c=c->next; suffix_object(c,item);}}",
          "686: void   cJSON_AddItemToObject(cJSON *object,const char *string,cJSON *item) {if (!item) return; if (item->string) cJSON_free(item->string);item->string=cJSON_strdup(string);cJSON_AddItemToArray(object,item);}",
          "687: void   cJSON_AddItemToObjectCS(cJSON *object,const char *string,cJSON *item) {if (!item) return; if (!(item->type&cJSON_StringIsConst) && item->string) cJSON_free(item->string);item->string=(char*)string;item->type|=cJSON_StringIsConst;cJSON_AddItemToArray(object,item);}",
          "688: void cJSON_AddItemReferenceToArray(cJSON *array, cJSON *item)      {cJSON_AddItemToArray(array,create_reference(item));}",
          "689: void cJSON_AddItemReferenceToObject(cJSON *object,const char *string,cJSON *item) {cJSON_AddItemToObject(object,string,create_reference(item));}",
          "691: cJSON *cJSON_DetachItemFromArray(cJSON *array,int which)   {cJSON *c=array->child;while (c && which>0) c=c->next,which--;if (!c) return 0;",
          "692:  if (c->prev) c->prev->next=c->next;if (c->next) c->next->prev=c->prev;if (c==array->child) array->child=c->next;c->prev=c->next=0;return c;}",
          "693: void   cJSON_DeleteItemFromArray(cJSON *array,int which)   {cJSON_Delete(cJSON_DetachItemFromArray(array,which));}",
          "694: cJSON *cJSON_DetachItemFromObject(cJSON *object,const char *string) {int i=0;cJSON *c=object->child;while (c && cJSON_strcasecmp(c->string,string)) i++,c=c->next;if (c) return cJSON_DetachItemFromArray(object,i);return 0;}",
          "695: void   cJSON_DeleteItemFromObject(cJSON *object,const char *string) {cJSON_Delete(cJSON_DetachItemFromObject(object,string));}",
          "698: void   cJSON_InsertItemInArray(cJSON *array,int which,cJSON *newitem)  {cJSON *c=array->child;while (c && which>0) c=c->next,which--;if (!c) {cJSON_AddItemToArray(array,newitem);return;}",
          "699:  newitem->next=c;newitem->prev=c->prev;c->prev=newitem;if (c==array->child) array->child=newitem; else newitem->prev->next=newitem;}",
          "700: void   cJSON_ReplaceItemInArray(cJSON *array,int which,cJSON *newitem)  {cJSON *c=array->child;while (c && which>0) c=c->next,which--;if (!c) return;",
          "701:  newitem->next=c->next;newitem->prev=c->prev;if (newitem->next) newitem->next->prev=newitem;",
          "702:  if (c==array->child) array->child=newitem; else newitem->prev->next=newitem;c->next=c->prev=0;cJSON_Delete(c);}",
          "703: void   cJSON_ReplaceItemInObject(cJSON *object,const char *string,cJSON *newitem){int i=0;cJSON *c=object->child;while(c && cJSON_strcasecmp(c->string,string))i++,c=c->next;if(c){newitem->string=cJSON_strdup(string);cJSON_ReplaceItemInArray(object,i,newitem);}}",
          "706: cJSON *cJSON_CreateNull(void)     {cJSON *item=cJSON_New_Item();if(item)item->type=cJSON_NULL;return item;}",
          "707: cJSON *cJSON_CreateTrue(void)     {cJSON *item=cJSON_New_Item();if(item)item->type=cJSON_True;return item;}",
          "708: cJSON *cJSON_CreateFalse(void)     {cJSON *item=cJSON_New_Item();if(item)item->type=cJSON_False;return item;}",
          "709: cJSON *cJSON_CreateBool(int b)     {cJSON *item=cJSON_New_Item();if(item)item->type=b?cJSON_True:cJSON_False;return item;}",
          "710: cJSON *cJSON_CreateNumber(double num)   {cJSON *item=cJSON_New_Item();if(item){item->type=cJSON_Number;item->valuedouble=num;item->valueint=(int64_t)num;}return item;}",
          "711: cJSON *cJSON_CreateString(const char *string) {cJSON *item=cJSON_New_Item();if(item){item->type=cJSON_String;item->valuestring=cJSON_strdup(string);if(!item->valuestring){cJSON_Delete(item);return 0;}}return item;}",
          "712: cJSON *cJSON_CreateArray(void)     {cJSON *item=cJSON_New_Item();if(item)item->type=cJSON_Array;return item;}",
          "713: cJSON *cJSON_CreateObject(void)     {cJSON *item=cJSON_New_Item();if(item)item->type=cJSON_Object;return item;}",
          "716: cJSON *cJSON_CreateIntArray(const int *numbers,int count)  {int i;cJSON *n=0,*p=0,*a=cJSON_CreateArray();for(i=0;a && i<count;i++){n=cJSON_CreateNumber(numbers[i]);if(!n){cJSON_Delete(a);return 0;}if(!i)a->child=n;else suffix_object(p,n);p=n;}return a;}",
          "717: cJSON *cJSON_CreateFloatArray(const float *numbers,int count) {int i;cJSON *n=0,*p=0,*a=cJSON_CreateArray();for(i=0;a && i<count;i++){n=cJSON_CreateNumber(numbers[i]);if(!n){cJSON_Delete(a);return 0;}if(!i)a->child=n;else suffix_object(p,n);p=n;}return a;}",
          "718: cJSON *cJSON_CreateDoubleArray(const double *numbers,int count) {int i;cJSON *n=0,*p=0,*a=cJSON_CreateArray();for(i=0;a && i<count;i++){n=cJSON_CreateNumber(numbers[i]);if(!n){cJSON_Delete(a);return 0;}if(!i)a->child=n;else suffix_object(p,n);p=n;}return a;}",
          "719: cJSON *cJSON_CreateStringArray(const char **strings,int count) {int i;cJSON *n=0,*p=0,*a=cJSON_CreateArray();for(i=0;a && i<count;i++){n=cJSON_CreateString(strings[i]);if(!n){cJSON_Delete(a);return 0;}if(!i)a->child=n;else suffix_object(p,n);p=n;}return a;}",
          "722: cJSON *cJSON_Duplicate(cJSON *item,int recurse)",
          "723: {",
          "724:  cJSON *newitem,*cptr,*nptr=0,*newchild;",
          "726:  if (!item) return 0;",
          "728:  newitem=cJSON_New_Item();",
          "729:  if (!newitem) return 0;",
          "731:  newitem->type=item->type&(~cJSON_IsReference),newitem->valueint=item->valueint,newitem->valuedouble=item->valuedouble;",
          "732:  if (item->valuestring) {newitem->valuestring=cJSON_strdup(item->valuestring); if (!newitem->valuestring) {cJSON_Delete(newitem);return 0;}}",
          "733:  if (item->string)  {newitem->string=cJSON_strdup(item->string);   if (!newitem->string)  {cJSON_Delete(newitem);return 0;}}",
          "735:  if (!recurse) return newitem;",
          "737:  cptr=item->child;",
          "738:  while (cptr)",
          "739:  {",
          "741:   if (!newchild) {cJSON_Delete(newitem);return 0;}",
          "744:   cptr=cptr->next;",
          "745:  }",
          "746:  return newitem;",
          "747: }",
          "749: void cJSON_Minify(char *json)",
          "750: {",
          "751:  char *into=json;",
          "752:  while (*json)",
          "753:  {",
          "754:   if (*json==' ') json++;",
          "756:   else if (*json=='\\r') json++;",
          "757:   else if (*json=='\\n') json++;",
          "762:  }",
          "",
          "---------------"
        ],
        "src/cjson.h||src/cjson.h": [
          "File: src/cjson.h -> src/cjson.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "29: #endif",
          "40: #define cJSON_IsReference 256",
          "43: typedef struct cJSON {",
          "54: } cJSON;",
          "56: typedef struct cJSON_Hooks {",
          "59: } cJSON_Hooks;",
          "124: #ifdef __cplusplus",
          "125: }",
          "",
          "[Removed Lines]",
          "32: #define cJSON_False 0",
          "33: #define cJSON_True 1",
          "34: #define cJSON_NULL 2",
          "35: #define cJSON_Number 3",
          "36: #define cJSON_String 4",
          "37: #define cJSON_Array 5",
          "38: #define cJSON_Object 6",
          "57:       void *(*malloc_fn)(size_t sz );",
          "58:       void (*free_fn)( void *ptr );",
          "62: extern void cJSON_InitHooks( cJSON_Hooks* hooks );",
          "66: extern cJSON *cJSON_Parse( const char *value );",
          "68: extern char *cJSON_Print( cJSON *item );",
          "70: extern char *cJSON_PrintUnformatted( cJSON *item );",
          "72: extern void cJSON_Delete( cJSON *c );",
          "75: extern int cJSON_GetArraySize( cJSON *array );",
          "77: extern cJSON *cJSON_GetArrayItem( cJSON *array, int item );",
          "79: extern cJSON *cJSON_GetObjectItem( cJSON *object, const char *string );",
          "82: extern const char *cJSON_GetErrorPtr( void );",
          "85: extern cJSON *cJSON_CreateNull( void );",
          "86: extern cJSON *cJSON_CreateTrue( void );",
          "87: extern cJSON *cJSON_CreateFalse( void );",
          "88: extern cJSON *cJSON_CreateBool( int b );",
          "89: extern cJSON *cJSON_CreateInt( int64_t num );",
          "90: extern cJSON *cJSON_CreateFloat( double num );",
          "91: extern cJSON *cJSON_CreateString( const char *string );",
          "92: extern cJSON *cJSON_CreateArray( void );",
          "93: extern cJSON *cJSON_CreateObject( void );",
          "96: extern cJSON *cJSON_CreateIntArray( int64_t *numbers, int count );",
          "97: extern cJSON *cJSON_CreateFloatArray( double *numbers, int count );",
          "98: extern cJSON *cJSON_CreateStringArray( const char **strings, int count );",
          "101: extern void cJSON_AddItemToArray( cJSON *array, cJSON *item );",
          "102: extern void cJSON_AddItemToObject( cJSON *object, const char *string, cJSON *item );",
          "104: extern void cJSON_AddItemReferenceToArray( cJSON *array, cJSON *item );",
          "105: extern void cJSON_AddItemReferenceToObject( cJSON *object, const char *string, cJSON *item );",
          "108: extern cJSON *cJSON_DetachItemFromArray( cJSON *array, int which );",
          "109: extern void cJSON_DeleteItemFromArray( cJSON *array, int which );",
          "110: extern cJSON *cJSON_DetachItemFromObject( cJSON *object, const char *string );",
          "111: extern void cJSON_DeleteItemFromObject( cJSON *object, const char *string );",
          "114: extern void cJSON_ReplaceItemInArray( cJSON *array, int which, cJSON *newitem );",
          "115: extern void cJSON_ReplaceItemInObject( cJSON *object, const char *string, cJSON *newitem );",
          "117: #define cJSON_AddNullToObject( object, name )  cJSON_AddItemToObject( object, name, cJSON_CreateNull() )",
          "118: #define cJSON_AddTrueToObject( object, name )  cJSON_AddItemToObject( object, name, cJSON_CreateTrue() )",
          "119: #define cJSON_AddFalseToObject( object, name )  cJSON_AddItemToObject( object, name, cJSON_CreateFalse() )",
          "120: #define cJSON_AddIntToObject( object, name, n )  cJSON_AddItemToObject( object, name, cJSON_CreateInt( n ) )",
          "121: #define cJSON_AddFloatToObject( object, name, n ) cJSON_AddItemToObject( object, name, cJSON_CreateFloat( n ) )",
          "122: #define cJSON_AddStringToObject( object, name, s ) cJSON_AddItemToObject( object, name, cJSON_CreateString( s ) )",
          "",
          "[Added Lines]",
          "32: #define cJSON_False  (1 << 0)",
          "33: #define cJSON_True   (1 << 1)",
          "34: #define cJSON_NULL   (1 << 2)",
          "35: #define cJSON_Number (1 << 3)",
          "36: #define cJSON_String (1 << 4)",
          "37: #define cJSON_Array  (1 << 5)",
          "38: #define cJSON_Object (1 << 6)",
          "41: #define cJSON_StringIsConst 512",
          "58:       void *(*malloc_fn)(size_t sz);",
          "59:       void (*free_fn)(void *ptr);",
          "63: extern void cJSON_InitHooks(cJSON_Hooks* hooks);",
          "67: extern cJSON *cJSON_Parse(const char *value);",
          "69: extern char  *cJSON_Print(cJSON *item);",
          "71: extern char  *cJSON_PrintUnformatted(cJSON *item);",
          "73: extern char *cJSON_PrintBuffered(cJSON *item,int prebuffer,int fmt);",
          "75: extern void   cJSON_Delete(cJSON *c);",
          "78: extern int   cJSON_GetArraySize(cJSON *array);",
          "80: extern cJSON *cJSON_GetArrayItem(cJSON *array,int item);",
          "82: extern cJSON *cJSON_GetObjectItem(cJSON *object,const char *string);",
          "83: extern int cJSON_HasObjectItem(cJSON *object,const char *string);",
          "85: extern const char *cJSON_GetErrorPtr(void);",
          "88: extern cJSON *cJSON_CreateNull(void);",
          "89: extern cJSON *cJSON_CreateTrue(void);",
          "90: extern cJSON *cJSON_CreateFalse(void);",
          "91: extern cJSON *cJSON_CreateBool(int b);",
          "92: extern cJSON *cJSON_CreateNumber(double num);",
          "93: extern cJSON *cJSON_CreateString(const char *string);",
          "94: extern cJSON *cJSON_CreateArray(void);",
          "95: extern cJSON *cJSON_CreateObject(void);",
          "98: extern cJSON *cJSON_CreateIntArray(const int *numbers,int count);",
          "99: extern cJSON *cJSON_CreateFloatArray(const float *numbers,int count);",
          "100: extern cJSON *cJSON_CreateDoubleArray(const double *numbers,int count);",
          "101: extern cJSON *cJSON_CreateStringArray(const char **strings,int count);",
          "104: extern void cJSON_AddItemToArray(cJSON *array, cJSON *item);",
          "105: extern void cJSON_AddItemToObject(cJSON *object,const char *string,cJSON *item);",
          "108: extern void cJSON_AddItemReferenceToArray(cJSON *array, cJSON *item);",
          "109: extern void cJSON_AddItemReferenceToObject(cJSON *object,const char *string,cJSON *item);",
          "112: extern cJSON *cJSON_DetachItemFromArray(cJSON *array,int which);",
          "113: extern void   cJSON_DeleteItemFromArray(cJSON *array,int which);",
          "114: extern cJSON *cJSON_DetachItemFromObject(cJSON *object,const char *string);",
          "115: extern void   cJSON_DeleteItemFromObject(cJSON *object,const char *string);",
          "119: extern void cJSON_ReplaceItemInArray(cJSON *array,int which,cJSON *newitem);",
          "120: extern void cJSON_ReplaceItemInObject(cJSON *object,const char *string,cJSON *newitem);",
          "123: extern cJSON *cJSON_Duplicate(cJSON *item,int recurse);",
          "125: need to be released. With recurse!=0, it will duplicate any children connected to the item.",
          "130: extern cJSON *cJSON_ParseWithOpts(const char *value,const char **return_parse_end,int require_null_terminated);",
          "132: extern void cJSON_Minify(char *json);",
          "135: #define cJSON_AddNullToObject(object,name)  cJSON_AddItemToObject(object, name, cJSON_CreateNull())",
          "136: #define cJSON_AddTrueToObject(object,name)  cJSON_AddItemToObject(object, name, cJSON_CreateTrue())",
          "137: #define cJSON_AddFalseToObject(object,name)  cJSON_AddItemToObject(object, name, cJSON_CreateFalse())",
          "138: #define cJSON_AddBoolToObject(object,name,b) cJSON_AddItemToObject(object, name, cJSON_CreateBool(b))",
          "139: #define cJSON_AddNumberToObject(object,name,n) cJSON_AddItemToObject(object, name, cJSON_CreateNumber(n))",
          "140: #define cJSON_AddStringToObject(object,name,s) cJSON_AddItemToObject(object, name, cJSON_CreateString(s))",
          "143: #define cJSON_SetIntValue(object,val)   ((object)?(object)->valueint=(object)->valuedouble=(val):(val))",
          "144: #define cJSON_SetNumberValue(object,val)  ((object)?(object)->valueint=(object)->valuedouble=(val):(val))",
          "147: #define cJSON_ArrayForEach(pos, head)   for(pos = (head)->child; pos != NULL; pos = pos->next)",
          "",
          "---------------"
        ],
        "src/iperf_api.c||src/iperf_api.c": [
          "File: src/iperf_api.c -> src/iperf_api.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "583:  cJSON_AddStringToObject(test->json_start, \"cookie\", test->cookie);",
          "584:         if (test->protocol->id == SOCK_STREAM) {",
          "585:      if (test->settings->mss)",
          "587:      else {",
          "588:   len = sizeof(opt);",
          "589:   getsockopt(test->ctrl_sck, IPPROTO_TCP, TCP_MAXSEG, &opt, &len);",
          "591:      }",
          "592:  }",
          "593:     } else if (test->verbose) {",
          "",
          "[Removed Lines]",
          "586:   cJSON_AddIntToObject(test->json_start, \"tcp_mss\", test->settings->mss);",
          "590:   cJSON_AddIntToObject(test->json_start, \"tcp_mss_default\", opt);",
          "",
          "[Added Lines]",
          "586:   cJSON_AddNumberToObject(test->json_start, \"tcp_mss\", test->settings->mss);",
          "590:   cJSON_AddNumberToObject(test->json_start, \"tcp_mss_default\", opt);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1302:      cJSON_AddTrueToObject(j, \"udp\");",
          "1303:         else if (test->protocol->id == Psctp)",
          "1304:             cJSON_AddTrueToObject(j, \"sctp\");",
          "1306:  if (test->server_affinity != -1)",
          "1308:  if (test->duration)",
          "1310:  if (test->settings->bytes)",
          "1312:  if (test->settings->blocks)",
          "1314:  if (test->settings->mss)",
          "1316:  if (test->no_delay)",
          "1317:      cJSON_AddTrueToObject(j, \"nodelay\");",
          "1319:  if (test->reverse)",
          "1320:      cJSON_AddTrueToObject(j, \"reverse\");",
          "1321:  if (test->settings->socket_bufsize)",
          "1323:  if (test->settings->blksize)",
          "1325:  if (test->settings->rate)",
          "1327:  if (test->settings->burst)",
          "1329:  if (test->settings->tos)",
          "1331:  if (test->settings->flowlabel)",
          "1333:  if (test->title)",
          "1334:      cJSON_AddStringToObject(j, \"title\", test->title);",
          "1335:  if (test->congestion)",
          "1336:      cJSON_AddStringToObject(j, \"congestion\", test->congestion);",
          "1337:  if (test->get_server_output)",
          "1339:  if (test->udp_counters_64bit)",
          "1341:  if (test->no_fq_socket_pacing)",
          "1344:  cJSON_AddStringToObject(j, \"client_version\", IPERF_VERSION);",
          "",
          "[Removed Lines]",
          "1305:  cJSON_AddIntToObject(j, \"omit\", test->omit);",
          "1307:      cJSON_AddIntToObject(j, \"server_affinity\", test->server_affinity);",
          "1309:      cJSON_AddIntToObject(j, \"time\", test->duration);",
          "1311:      cJSON_AddIntToObject(j, \"num\", test->settings->bytes);",
          "1313:      cJSON_AddIntToObject(j, \"blockcount\", test->settings->blocks);",
          "1315:      cJSON_AddIntToObject(j, \"MSS\", test->settings->mss);",
          "1318:  cJSON_AddIntToObject(j, \"parallel\", test->num_streams);",
          "1322:      cJSON_AddIntToObject(j, \"window\", test->settings->socket_bufsize);",
          "1324:      cJSON_AddIntToObject(j, \"len\", test->settings->blksize);",
          "1326:      cJSON_AddIntToObject(j, \"bandwidth\", test->settings->rate);",
          "1328:      cJSON_AddIntToObject(j, \"burst\", test->settings->burst);",
          "1330:      cJSON_AddIntToObject(j, \"TOS\", test->settings->tos);",
          "1332:      cJSON_AddIntToObject(j, \"flowlabel\", test->settings->flowlabel);",
          "1338:      cJSON_AddIntToObject(j, \"get_server_output\", iperf_get_test_get_server_output(test));",
          "1340:      cJSON_AddIntToObject(j, \"udp_counters_64bit\", iperf_get_test_udp_counters_64bit(test));",
          "1342:      cJSON_AddIntToObject(j, \"no_fq_socket_pacing\", iperf_get_no_fq_socket_pacing(test));",
          "",
          "[Added Lines]",
          "1305:  cJSON_AddNumberToObject(j, \"omit\", test->omit);",
          "1307:      cJSON_AddNumberToObject(j, \"server_affinity\", test->server_affinity);",
          "1309:      cJSON_AddNumberToObject(j, \"time\", test->duration);",
          "1311:      cJSON_AddNumberToObject(j, \"num\", test->settings->bytes);",
          "1313:      cJSON_AddNumberToObject(j, \"blockcount\", test->settings->blocks);",
          "1315:      cJSON_AddNumberToObject(j, \"MSS\", test->settings->mss);",
          "1318:  cJSON_AddNumberToObject(j, \"parallel\", test->num_streams);",
          "1322:      cJSON_AddNumberToObject(j, \"window\", test->settings->socket_bufsize);",
          "1324:      cJSON_AddNumberToObject(j, \"len\", test->settings->blksize);",
          "1326:      cJSON_AddNumberToObject(j, \"bandwidth\", test->settings->rate);",
          "1328:      cJSON_AddNumberToObject(j, \"burst\", test->settings->burst);",
          "1330:      cJSON_AddNumberToObject(j, \"TOS\", test->settings->tos);",
          "1332:      cJSON_AddNumberToObject(j, \"flowlabel\", test->settings->flowlabel);",
          "1338:      cJSON_AddNumberToObject(j, \"get_server_output\", iperf_get_test_get_server_output(test));",
          "1340:      cJSON_AddNumberToObject(j, \"udp_counters_64bit\", iperf_get_test_udp_counters_64bit(test));",
          "1342:      cJSON_AddNumberToObject(j, \"no_fq_socket_pacing\", iperf_get_no_fq_socket_pacing(test));",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1447:  i_errno = IEPACKAGERESULTS;",
          "1448:  r = -1;",
          "1449:     } else {",
          "1453:  if ( ! test->sender )",
          "1454:      sender_has_retransmits = -1;",
          "1455:  else",
          "1456:      sender_has_retransmits = test->sender_has_retransmits;",
          "1460:  if (test->role == 's' && test->get_server_output) {",
          "",
          "[Removed Lines]",
          "1450:  cJSON_AddFloatToObject(j, \"cpu_util_total\", test->cpu_util[0]);",
          "1451:  cJSON_AddFloatToObject(j, \"cpu_util_user\", test->cpu_util[1]);",
          "1452:  cJSON_AddFloatToObject(j, \"cpu_util_system\", test->cpu_util[2]);",
          "1457:  cJSON_AddIntToObject(j, \"sender_has_retransmits\", sender_has_retransmits);",
          "",
          "[Added Lines]",
          "1450:  cJSON_AddNumberToObject(j, \"cpu_util_total\", test->cpu_util[0]);",
          "1451:  cJSON_AddNumberToObject(j, \"cpu_util_user\", test->cpu_util[1]);",
          "1452:  cJSON_AddNumberToObject(j, \"cpu_util_system\", test->cpu_util[2]);",
          "1457:  cJSON_AddNumberToObject(j, \"sender_has_retransmits\", sender_has_retransmits);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1498:       cJSON_AddItemToArray(j_streams, j_stream);",
          "1499:       bytes_transferred = test->sender ? (sp->result->bytes_sent - sp->result->bytes_sent_omit) : sp->result->bytes_received;",
          "1500:       retransmits = (test->sender && test->sender_has_retransmits) ? sp->result->stream_retrans : -1;",
          "1507:   }",
          "1508:      }",
          "1509:      if (r == 0 && test->debug) {",
          "",
          "[Removed Lines]",
          "1501:       cJSON_AddIntToObject(j_stream, \"id\", sp->id);",
          "1502:       cJSON_AddIntToObject(j_stream, \"bytes\", bytes_transferred);",
          "1503:       cJSON_AddIntToObject(j_stream, \"retransmits\", retransmits);",
          "1504:       cJSON_AddFloatToObject(j_stream, \"jitter\", sp->jitter);",
          "1505:       cJSON_AddIntToObject(j_stream, \"errors\", sp->cnt_error);",
          "1506:       cJSON_AddIntToObject(j_stream, \"packets\", sp->packet_count);",
          "",
          "[Added Lines]",
          "1501:       cJSON_AddNumberToObject(j_stream, \"id\", sp->id);",
          "1502:       cJSON_AddNumberToObject(j_stream, \"bytes\", bytes_transferred);",
          "1503:       cJSON_AddNumberToObject(j_stream, \"retransmits\", retransmits);",
          "1504:       cJSON_AddNumberToObject(j_stream, \"jitter\", sp->jitter);",
          "1505:       cJSON_AddNumberToObject(j_stream, \"errors\", sp->cnt_error);",
          "1506:       cJSON_AddNumberToObject(j_stream, \"packets\", sp->packet_count);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1564:   printf(\"get_results\\n%s\\n\", cJSON_Print(j));",
          "1565:      }",
          "1570:      result_has_retransmits = j_sender_has_retransmits->valueint;",
          "1571:      if (! test->sender)",
          "1572:   test->sender_has_retransmits = result_has_retransmits;",
          "",
          "[Removed Lines]",
          "1567:      test->remote_cpu_util[0] = j_cpu_util_total->valuefloat;",
          "1568:      test->remote_cpu_util[1] = j_cpu_util_user->valuefloat;",
          "1569:      test->remote_cpu_util[2] = j_cpu_util_system->valuefloat;",
          "",
          "[Added Lines]",
          "1567:      test->remote_cpu_util[0] = j_cpu_util_total->valuedouble;",
          "1568:      test->remote_cpu_util[1] = j_cpu_util_user->valuedouble;",
          "1569:      test->remote_cpu_util[2] = j_cpu_util_system->valuedouble;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1595:        sid = j_id->valueint;",
          "1596:        bytes_transferred = j_bytes->valueint;",
          "1597:        retransmits = j_retransmits->valueint;",
          "1599:        cerror = j_errors->valueint;",
          "1600:        pcount = j_packets->valueint;",
          "1601:        SLIST_FOREACH(sp, &test->streams, streams)",
          "",
          "[Removed Lines]",
          "1598:        jitter = j_jitter->valuefloat;",
          "",
          "[Added Lines]",
          "1598:        jitter = j_jitter->valuedouble;",
          "",
          "---------------"
        ],
        "src/iperf_util.c||src/iperf_util.c": [
          "File: src/iperf_util.c -> src/iperf_util.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "350:   j = cJSON_CreateBool(va_arg(argp, int));",
          "351:   break;",
          "352:   case 'd':",
          "354:   break;",
          "355:   case 'f':",
          "357:   break;",
          "358:   case 's':",
          "359:   j = cJSON_CreateString(va_arg(argp, char *));",
          "",
          "[Removed Lines]",
          "353:   j = cJSON_CreateInt(va_arg(argp, int64_t));",
          "356:   j = cJSON_CreateFloat(va_arg(argp, double));",
          "",
          "[Added Lines]",
          "353:   j = cJSON_CreateNumber(va_arg(argp, int64_t));",
          "356:   j = cJSON_CreateNumber(va_arg(argp, double));",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "c35b6324c484c3f16e8ffbb263dae90783dd178f",
      "candidate_info": {
        "commit_hash": "c35b6324c484c3f16e8ffbb263dae90783dd178f",
        "repo": "esnet/iperf",
        "commit_url": "https://github.com/esnet/iperf/commit/c35b6324c484c3f16e8ffbb263dae90783dd178f",
        "files": [
          "src/cjson.c"
        ],
        "message": "Fix a buffer overflow in upstream cJSON.\n\nThis is DaveGamble/cJSON#30, and fixes issue #466.\n\nSigned-off-by: Bruce A. Mah <bmah@es.net>",
        "before_after_code_files": [
          "src/cjson.c||src/cjson.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/cjson.c||src/cjson.c"
          ],
          "candidate": [
            "src/cjson.c||src/cjson.c"
          ]
        }
      },
      "candidate_diff": {
        "src/cjson.c||src/cjson.c": [
          "File: src/cjson.c -> src/cjson.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "202: {",
          "203:  const char *ptr=str+1,*end_ptr=str+1;char *ptr2;char *out;int len=0;unsigned uc,uc2;",
          "209:  if (!out) return 0;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "206:  while (*end_ptr!='\\\"' && *end_ptr && ++len)",
          "207:  {",
          "208:      if (*end_ptr++ == '\\\\')",
          "209:      {",
          "210:   if (*end_ptr == '\\0')",
          "211:   {",
          "213:       return 0;",
          "214:   }",
          "216:      }",
          "217:  }",
          "",
          "---------------"
        ]
      }
    }
  ]
}
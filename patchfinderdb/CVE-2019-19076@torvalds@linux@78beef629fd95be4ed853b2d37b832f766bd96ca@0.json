{
  "cve_id": "CVE-2019-19076",
  "cve_desc": "A memory leak in the nfp_abm_u32_knode_replace() function in drivers/net/ethernet/netronome/nfp/abm/cls.c in the Linux kernel before 5.3.6 allows attackers to cause a denial of service (memory consumption), aka CID-78beef629fd9. NOTE: This has been argued as not a valid vulnerability. The upstream commit 78beef629fd9 was reverted",
  "repo": "torvalds/linux",
  "patch_hash": "78beef629fd95be4ed853b2d37b832f766bd96ca",
  "patch_info": {
    "commit_hash": "78beef629fd95be4ed853b2d37b832f766bd96ca",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/78beef629fd95be4ed853b2d37b832f766bd96ca",
    "files": [
      "drivers/net/ethernet/netronome/nfp/abm/cls.c"
    ],
    "message": "nfp: abm: fix memory leak in nfp_abm_u32_knode_replace\n\nIn nfp_abm_u32_knode_replace if the allocation for match fails it should\ngo to the error handling instead of returning. Updated other gotos to\nhave correct errno returned, too.\n\nSigned-off-by: Navid Emamdoost <navid.emamdoost@gmail.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
    "before_after_code_files": [
      "drivers/net/ethernet/netronome/nfp/abm/cls.c||drivers/net/ethernet/netronome/nfp/abm/cls.c"
    ]
  },
  "patch_diff": {
    "drivers/net/ethernet/netronome/nfp/abm/cls.c||drivers/net/ethernet/netronome/nfp/abm/cls.c": [
      "File: drivers/net/ethernet/netronome/nfp/abm/cls.c -> drivers/net/ethernet/netronome/nfp/abm/cls.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "176:  u8 mask, val;",
      "177:  int err;",
      "180:   goto err_delete;",
      "182:  tos_off = proto == htons(ETH_P_IP) ? 16 : 20;",
      "",
      "[Removed Lines]",
      "179:  if (!nfp_abm_u32_check_knode(alink->abm, knode, proto, extack))",
      "",
      "[Added Lines]",
      "179:  if (!nfp_abm_u32_check_knode(alink->abm, knode, proto, extack)) {",
      "180:   err = -EOPNOTSUPP;",
      "182:  }",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "198:   if ((iter->val & cmask) == (val & cmask) &&",
      "199:       iter->band != knode->res->classid) {",
      "200:    NL_SET_ERR_MSG_MOD(extack, \"conflict with already offloaded filter\");",
      "201:    goto err_delete;",
      "202:   }",
      "203:  }",
      "205:  if (!match) {",
      "206:   match = kzalloc(sizeof(*match), GFP_KERNEL);",
      "209:   list_add(&match->list, &alink->dscp_map);",
      "210:  }",
      "211:  match->handle = knode->handle;",
      "",
      "[Removed Lines]",
      "207:   if (!match)",
      "208:    return -ENOMEM;",
      "",
      "[Added Lines]",
      "203:    err = -EOPNOTSUPP;",
      "210:   if (!match) {",
      "211:    err = -ENOMEM;",
      "212:    goto err_delete;",
      "213:   }",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "222: err_delete:",
      "223:  nfp_abm_u32_knode_delete(alink, knode);",
      "225: }",
      "227: static int nfp_abm_setup_tc_block_cb(enum tc_setup_type type,",
      "",
      "[Removed Lines]",
      "224:  return -EOPNOTSUPP;",
      "",
      "[Added Lines]",
      "230:  return err;",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "174ab544e3bc0b0c944b8e642618203dd0c2ecdf",
      "candidate_info": {
        "commit_hash": "174ab544e3bc0b0c944b8e642618203dd0c2ecdf",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/174ab544e3bc0b0c944b8e642618203dd0c2ecdf",
        "files": [
          "drivers/net/ethernet/netronome/nfp/Makefile",
          "drivers/net/ethernet/netronome/nfp/abm/cls.c",
          "drivers/net/ethernet/netronome/nfp/abm/ctrl.c",
          "drivers/net/ethernet/netronome/nfp/abm/main.c",
          "drivers/net/ethernet/netronome/nfp/abm/main.h",
          "drivers/net/ethernet/netronome/nfp/abm/qdisc.c"
        ],
        "message": "nfp: abm: add cls_u32 offload for simple band classification\n\nUse offload of very simple u32 filters to direct packets to GRED\nbands based on the DSCP marking.  No u32 hashing is supported,\njust plain simple filters matching on ToS or Priority with\nappropriate mask device can support.\n\nSigned-off-by: Jakub Kicinski <jakub.kicinski@netronome.com>\nReviewed-by: John Hurley <john.hurley@netronome.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "before_after_code_files": [
          "drivers/net/ethernet/netronome/nfp/abm/cls.c||drivers/net/ethernet/netronome/nfp/abm/cls.c",
          "drivers/net/ethernet/netronome/nfp/abm/ctrl.c||drivers/net/ethernet/netronome/nfp/abm/ctrl.c",
          "drivers/net/ethernet/netronome/nfp/abm/main.c||drivers/net/ethernet/netronome/nfp/abm/main.c",
          "drivers/net/ethernet/netronome/nfp/abm/main.h||drivers/net/ethernet/netronome/nfp/abm/main.h",
          "drivers/net/ethernet/netronome/nfp/abm/qdisc.c||drivers/net/ethernet/netronome/nfp/abm/qdisc.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "drivers/net/ethernet/netronome/nfp/abm/cls.c||drivers/net/ethernet/netronome/nfp/abm/cls.c"
          ],
          "candidate": [
            "drivers/net/ethernet/netronome/nfp/abm/cls.c||drivers/net/ethernet/netronome/nfp/abm/cls.c"
          ]
        }
      },
      "candidate_diff": {
        "drivers/net/ethernet/netronome/nfp/abm/cls.c||drivers/net/ethernet/netronome/nfp/abm/cls.c": [
          "File: drivers/net/ethernet/netronome/nfp/abm/cls.c -> drivers/net/ethernet/netronome/nfp/abm/cls.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4: #include <linux/bitfield.h>",
          "5: #include <net/pkt_cls.h>",
          "7: #include \"../nfpcore/nfp_cpp.h\"",
          "8: #include \"../nfp_app.h\"",
          "9: #include \"../nfp_net_repr.h\"",
          "10: #include \"main.h\"",
          "12: struct nfp_abm_u32_match {",
          "13:  u32 handle;",
          "14:  u32 band;",
          "15:  u8 mask;",
          "16:  u8 val;",
          "17:  struct list_head list;",
          "18: };",
          "20: static bool",
          "21: nfp_abm_u32_check_knode(struct nfp_abm *abm, struct tc_cls_u32_knode *knode,",
          "22:    __be16 proto, struct netlink_ext_ack *extack)",
          "23: {",
          "24:  struct tc_u32_key *k;",
          "25:  unsigned int tos_off;",
          "27:  if (knode->exts && tcf_exts_has_actions(knode->exts)) {",
          "28:   NL_SET_ERR_MSG_MOD(extack, \"action offload not supported\");",
          "29:   return false;",
          "30:  }",
          "31:  if (knode->link_handle) {",
          "32:   NL_SET_ERR_MSG_MOD(extack, \"linking not supported\");",
          "33:   return false;",
          "34:  }",
          "35:  if (knode->sel->flags != TC_U32_TERMINAL) {",
          "36:   NL_SET_ERR_MSG_MOD(extack,",
          "37:        \"flags must be equal to TC_U32_TERMINAL\");",
          "38:   return false;",
          "39:  }",
          "40:  if (knode->sel->off || knode->sel->offshift || knode->sel->offmask ||",
          "41:      knode->sel->offoff || knode->fshift) {",
          "42:   NL_SET_ERR_MSG_MOD(extack, \"variable offseting not supported\");",
          "43:   return false;",
          "44:  }",
          "45:  if (knode->sel->hoff || knode->sel->hmask) {",
          "46:   NL_SET_ERR_MSG_MOD(extack, \"hashing not supported\");",
          "47:   return false;",
          "48:  }",
          "49:  if (knode->val || knode->mask) {",
          "50:   NL_SET_ERR_MSG_MOD(extack, \"matching on mark not supported\");",
          "51:   return false;",
          "52:  }",
          "53:  if (knode->res && knode->res->class) {",
          "54:   NL_SET_ERR_MSG_MOD(extack, \"setting non-0 class not supported\");",
          "55:   return false;",
          "56:  }",
          "57:  if (knode->res && knode->res->classid >= abm->num_bands) {",
          "58:   NL_SET_ERR_MSG_MOD(extack,",
          "59:        \"classid higher than number of bands\");",
          "60:   return false;",
          "61:  }",
          "62:  if (knode->sel->nkeys != 1) {",
          "63:   NL_SET_ERR_MSG_MOD(extack, \"exactly one key required\");",
          "64:   return false;",
          "65:  }",
          "67:  switch (proto) {",
          "68:  case htons(ETH_P_IP):",
          "69:   tos_off = 16;",
          "70:   break;",
          "71:  case htons(ETH_P_IPV6):",
          "72:   tos_off = 20;",
          "73:   break;",
          "74:  default:",
          "75:   NL_SET_ERR_MSG_MOD(extack, \"only IP and IPv6 supported as filter protocol\");",
          "76:   return false;",
          "77:  }",
          "79:  k = &knode->sel->keys[0];",
          "80:  if (k->offmask) {",
          "81:   NL_SET_ERR_MSG_MOD(extack, \"offset mask - variable offseting not supported\");",
          "82:   return false;",
          "83:  }",
          "84:  if (k->off) {",
          "85:   NL_SET_ERR_MSG_MOD(extack, \"only DSCP fields can be matched\");",
          "86:   return false;",
          "87:  }",
          "88:  if (k->val & ~k->mask) {",
          "89:   NL_SET_ERR_MSG_MOD(extack, \"mask does not cover the key\");",
          "90:   return false;",
          "91:  }",
          "92:  if (be32_to_cpu(k->mask) >> tos_off & ~abm->dscp_mask) {",
          "93:   NL_SET_ERR_MSG_MOD(extack, \"only high DSCP class selector bits can be used\");",
          "94:   nfp_err(abm->app->cpp,",
          "95:    \"u32 offload: requested mask %x FW can support only %x\\n\",",
          "96:    be32_to_cpu(k->mask) >> tos_off, abm->dscp_mask);",
          "97:   return false;",
          "98:  }",
          "100:  return true;",
          "101: }",
          "107: static unsigned int",
          "108: nfp_abm_find_band_for_prio(struct nfp_abm_link *alink, unsigned int prio)",
          "109: {",
          "110:  struct nfp_abm_u32_match *iter;",
          "112:  list_for_each_entry(iter, &alink->dscp_map, list)",
          "113:   if ((prio & iter->mask) == iter->val)",
          "114:    return iter->band;",
          "116:  return alink->def_band;",
          "117: }",
          "119: static int nfp_abm_update_band_map(struct nfp_abm_link *alink)",
          "120: {",
          "121:  unsigned int i, bits_per_prio, prios_per_word, base_shift;",
          "122:  struct nfp_abm *abm = alink->abm;",
          "123:  u32 field_mask;",
          "125:  alink->has_prio = !list_empty(&alink->dscp_map);",
          "127:  bits_per_prio = roundup_pow_of_two(order_base_2(abm->num_bands));",
          "128:  field_mask = (1 << bits_per_prio) - 1;",
          "129:  prios_per_word = sizeof(u32) * BITS_PER_BYTE / bits_per_prio;",
          "132:  base_shift = 8 - order_base_2(abm->num_prios);",
          "134:  for (i = 0; i < abm->num_prios; i++) {",
          "135:   unsigned int offset;",
          "136:   u32 *word;",
          "137:   u8 band;",
          "139:   word = &alink->prio_map[i / prios_per_word];",
          "140:   offset = (i % prios_per_word) * bits_per_prio;",
          "142:   band = nfp_abm_find_band_for_prio(alink, i << base_shift);",
          "146:  }",
          "149:  nfp_abm_qdisc_offload_update(alink);",
          "151:  return nfp_abm_ctrl_prio_map_update(alink, alink->prio_map);",
          "152: }",
          "154: static void",
          "155: nfp_abm_u32_knode_delete(struct nfp_abm_link *alink,",
          "156:     struct tc_cls_u32_knode *knode)",
          "157: {",
          "158:  struct nfp_abm_u32_match *iter;",
          "160:  list_for_each_entry(iter, &alink->dscp_map, list)",
          "161:   if (iter->handle == knode->handle) {",
          "162:    list_del(&iter->list);",
          "163:    kfree(iter);",
          "164:    nfp_abm_update_band_map(alink);",
          "165:    return;",
          "166:   }",
          "167: }",
          "169: static int",
          "170: nfp_abm_u32_knode_replace(struct nfp_abm_link *alink,",
          "171:      struct tc_cls_u32_knode *knode,",
          "172:      __be16 proto, struct netlink_ext_ack *extack)",
          "173: {",
          "174:  struct nfp_abm_u32_match *match = NULL, *iter;",
          "175:  unsigned int tos_off;",
          "176:  u8 mask, val;",
          "177:  int err;",
          "179:  if (!nfp_abm_u32_check_knode(alink->abm, knode, proto, extack))",
          "180:   goto err_delete;",
          "182:  tos_off = proto == htons(ETH_P_IP) ? 16 : 20;",
          "185:  val = be32_to_cpu(knode->sel->keys[0].val) >> tos_off & 0xff;",
          "186:  mask = be32_to_cpu(knode->sel->keys[0].mask) >> tos_off & 0xff;",
          "189:  list_for_each_entry(iter, &alink->dscp_map, list) {",
          "190:   u32 cmask;",
          "192:   if (iter->handle == knode->handle) {",
          "193:    match = iter;",
          "194:    continue;",
          "195:   }",
          "197:   cmask = iter->mask & mask;",
          "198:   if ((iter->val & cmask) == (val & cmask) &&",
          "199:       iter->band != knode->res->classid) {",
          "200:    NL_SET_ERR_MSG_MOD(extack, \"conflict with already offloaded filter\");",
          "201:    goto err_delete;",
          "202:   }",
          "203:  }",
          "205:  if (!match) {",
          "206:   match = kzalloc(sizeof(*match), GFP_KERNEL);",
          "207:   if (!match)",
          "208:    return -ENOMEM;",
          "209:   list_add(&match->list, &alink->dscp_map);",
          "210:  }",
          "211:  match->handle = knode->handle;",
          "212:  match->band = knode->res->classid;",
          "213:  match->mask = mask;",
          "214:  match->val = val;",
          "216:  err = nfp_abm_update_band_map(alink);",
          "217:  if (err)",
          "218:   goto err_delete;",
          "220:  return 0;",
          "222: err_delete:",
          "223:  nfp_abm_u32_knode_delete(alink, knode);",
          "224:  return -EOPNOTSUPP;",
          "225: }",
          "227: static int nfp_abm_setup_tc_block_cb(enum tc_setup_type type,",
          "228:          void *type_data, void *cb_priv)",
          "229: {",
          "230:  struct tc_cls_u32_offload *cls_u32 = type_data;",
          "231:  struct nfp_repr *repr = cb_priv;",
          "232:  struct nfp_abm_link *alink;",
          "234:  alink = repr->app_priv;",
          "236:  if (type != TC_SETUP_CLSU32) {",
          "237:   NL_SET_ERR_MSG_MOD(cls_u32->common.extack,",
          "238:        \"only offload of u32 classifier supported\");",
          "239:   return -EOPNOTSUPP;",
          "240:  }",
          "241:  if (!tc_cls_can_offload_and_chain0(repr->netdev, &cls_u32->common))",
          "242:   return -EOPNOTSUPP;",
          "244:  if (cls_u32->common.protocol != htons(ETH_P_IP) &&",
          "245:      cls_u32->common.protocol != htons(ETH_P_IPV6)) {",
          "246:   NL_SET_ERR_MSG_MOD(cls_u32->common.extack,",
          "247:        \"only IP and IPv6 supported as filter protocol\");",
          "248:   return -EOPNOTSUPP;",
          "249:  }",
          "251:  switch (cls_u32->command) {",
          "252:  case TC_CLSU32_NEW_KNODE:",
          "253:  case TC_CLSU32_REPLACE_KNODE:",
          "254:   return nfp_abm_u32_knode_replace(alink, &cls_u32->knode,",
          "255:        cls_u32->common.protocol,",
          "256:        cls_u32->common.extack);",
          "257:  case TC_CLSU32_DELETE_KNODE:",
          "258:   nfp_abm_u32_knode_delete(alink, &cls_u32->knode);",
          "259:   return 0;",
          "260:  default:",
          "261:   return -EOPNOTSUPP;",
          "262:  }",
          "263: }",
          "265: int nfp_abm_setup_cls_block(struct net_device *netdev, struct nfp_repr *repr,",
          "266:        struct tc_block_offload *f)",
          "267: {",
          "268:  if (f->binder_type != TCF_BLOCK_BINDER_TYPE_CLSACT_EGRESS)",
          "269:   return -EOPNOTSUPP;",
          "271:  switch (f->command) {",
          "272:  case TC_BLOCK_BIND:",
          "273:   return tcf_block_cb_register(f->block,",
          "274:           nfp_abm_setup_tc_block_cb,",
          "275:           repr, repr, f->extack);",
          "276:  case TC_BLOCK_UNBIND:",
          "277:   tcf_block_cb_unregister(f->block, nfp_abm_setup_tc_block_cb,",
          "278:      repr);",
          "279:   return 0;",
          "280:  default:",
          "281:   return -EOPNOTSUPP;",
          "282:  }",
          "283: }",
          "",
          "---------------"
        ],
        "drivers/net/ethernet/netronome/nfp/abm/ctrl.c||drivers/net/ethernet/netronome/nfp/abm/ctrl.c": [
          "File: drivers/net/ethernet/netronome/nfp/abm/ctrl.c -> drivers/net/ethernet/netronome/nfp/abm/ctrl.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "335:  abm->num_prios = res;",
          "337:  abm->prio_map_len = nfp_abm_ctrl_prio_map_size(abm);",
          "340:  if (!is_power_of_2(abm->num_bands) || !is_power_of_2(abm->num_prios) ||",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "338:  abm->dscp_mask = GENMASK(7, 8 - order_base_2(abm->num_prios));",
          "",
          "---------------"
        ],
        "drivers/net/ethernet/netronome/nfp/abm/main.c||drivers/net/ethernet/netronome/nfp/abm/main.c": [
          "File: drivers/net/ethernet/netronome/nfp/abm/main.c -> drivers/net/ethernet/netronome/nfp/abm/main.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "46:   return nfp_abm_setup_tc_red(netdev, repr->app_priv, type_data);",
          "47:  case TC_SETUP_QDISC_GRED:",
          "48:   return nfp_abm_setup_tc_gred(netdev, repr->app_priv, type_data);",
          "49:  default:",
          "50:   return -EOPNOTSUPP;",
          "51:  }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "49:  case TC_SETUP_BLOCK:",
          "50:   return nfp_abm_setup_cls_block(netdev, repr, type_data);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "315:  alink->id = id;",
          "316:  alink->total_queues = alink->vnic->max_rx_rings;",
          "318:  err = nfp_abm_ctrl_read_params(alink);",
          "319:  if (err)",
          "320:   goto err_free_alink;",
          "325:  err = nfp_eth_set_configured(app->cpp, eth_port->index, true);",
          "326:  if (err < 0)",
          "329:  netif_keep_dst(nn->dp.netdev);",
          "",
          "[Removed Lines]",
          "327:   goto err_free_alink;",
          "",
          "[Added Lines]",
          "320:  INIT_LIST_HEAD(&alink->dscp_map);",
          "326:  alink->prio_map = kzalloc(abm->prio_map_len, GFP_KERNEL);",
          "327:  if (!alink->prio_map)",
          "328:   goto err_free_alink;",
          "335:   goto err_free_priomap;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "334:  return 0;",
          "336: err_free_alink:",
          "337:  kfree(alink);",
          "338:  return err;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "344: err_free_priomap:",
          "345:  kfree(alink->prio_map);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "345:  nfp_abm_kill_reprs(alink->abm, alink);",
          "346:  WARN(!radix_tree_empty(&alink->qdiscs), \"left over qdiscs\\n\");",
          "347:  kfree(alink);",
          "348: }",
          "350: static u64 *",
          "351: nfp_abm_port_get_stats(struct nfp_app *app, struct nfp_port *port, u64 *data)",
          "352: {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "357:  kfree(alink->prio_map);",
          "361: static int nfp_abm_vnic_init(struct nfp_app *app, struct nfp_net *nn)",
          "362: {",
          "363:  struct nfp_abm_link *alink = nn->app_priv;",
          "365:  if (nfp_abm_has_prio(alink->abm))",
          "366:   return nfp_abm_ctrl_prio_map_update(alink, alink->prio_map);",
          "367:  return 0;",
          "368: }",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "492:  .vnic_alloc = nfp_abm_vnic_alloc,",
          "493:  .vnic_free = nfp_abm_vnic_free,",
          "495:  .port_get_stats  = nfp_abm_port_get_stats,",
          "496:  .port_get_stats_count = nfp_abm_port_get_stats_count,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "514:  .vnic_init = nfp_abm_vnic_init,",
          "",
          "---------------"
        ],
        "drivers/net/ethernet/netronome/nfp/abm/main.h||drivers/net/ethernet/netronome/nfp/abm/main.h": [
          "File: drivers/net/ethernet/netronome/nfp/abm/main.h -> drivers/net/ethernet/netronome/nfp/abm/main.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "5: #define __NFP_ABM_H__ 1",
          "7: #include <linux/bits.h>",
          "8: #include <linux/radix-tree.h>",
          "9: #include <net/devlink.h>",
          "10: #include <net/pkt_cls.h>",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "8: #include <linux/list.h>",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "53:  u32 *thresholds;",
          "54:  unsigned long *threshold_undef;",
          "55:  size_t num_thresholds;",
          "56:  unsigned int prio_map_len;",
          "58:  enum devlink_eswitch_mode eswitch_mode;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "61:  u8 dscp_mask;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "185:  u64 last_stats_update;",
          "187:  u8 def_band;",
          "189:  struct nfp_qdisc *root_qdisc;",
          "190:  struct radix_tree_root qdiscs;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "196:  u32 *prio_map;",
          "197:  bool has_prio;",
          "200:  struct list_head dscp_map;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "204:    struct tc_mq_qopt_offload *opt);",
          "205: int nfp_abm_setup_tc_gred(struct net_device *netdev, struct nfp_abm_link *alink,",
          "206:      struct tc_gred_qopt_offload *opt);",
          "208: int nfp_abm_ctrl_read_params(struct nfp_abm_link *alink);",
          "209: int nfp_abm_ctrl_find_addrs(struct nfp_abm *abm);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "220: int nfp_abm_setup_cls_block(struct net_device *netdev, struct nfp_repr *repr,",
          "221:        struct tc_block_offload *opt);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "220: u64 nfp_abm_ctrl_stat_sto(struct nfp_abm_link *alink, unsigned int i);",
          "221: int nfp_abm_ctrl_qm_enable(struct nfp_abm *abm);",
          "222: int nfp_abm_ctrl_qm_disable(struct nfp_abm *abm);",
          "223: int nfp_abm_ctrl_prio_map_update(struct nfp_abm_link *alink, u32 *packed);",
          "224: #endif",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "238: void nfp_abm_prio_map_update(struct nfp_abm *abm);",
          "",
          "---------------"
        ],
        "drivers/net/ethernet/netronome/nfp/abm/qdisc.c||drivers/net/ethernet/netronome/nfp/abm/qdisc.c": [
          "File: drivers/net/ethernet/netronome/nfp/abm/qdisc.c -> drivers/net/ethernet/netronome/nfp/abm/qdisc.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "197:  good_red = qdisc->type == NFP_QDISC_RED &&",
          "198:      qdisc->params_ok &&",
          "199:      qdisc->use_cnt == 1 &&",
          "200:      !qdisc->children[0];",
          "201:  good_gred = qdisc->type == NFP_QDISC_GRED &&",
          "202:       qdisc->params_ok &&",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "200:      !alink->has_prio &&",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "1d1997db870f4058676439ef7014390ba9e24eb2",
      "candidate_info": {
        "commit_hash": "1d1997db870f4058676439ef7014390ba9e24eb2",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/1d1997db870f4058676439ef7014390ba9e24eb2",
        "files": [
          "drivers/net/ethernet/netronome/nfp/abm/cls.c"
        ],
        "message": "Revert \"nfp: abm: fix memory leak in nfp_abm_u32_knode_replace\"\n\nThis reverts commit 78beef629fd9 (\"nfp: abm: fix memory leak in\nnfp_abm_u32_knode_replace\").\n\nThe quoted commit does not fix anything and resulted in a bogus\nCVE-2019-19076.\n\nIf match is NULL then it is known there is no matching entry in\nlist, hence, calling nfp_abm_u32_knode_delete() is pointless.\n\nSigned-off-by: Jakub Kicinski <jakub.kicinski@netronome.com>\nReviewed-by: John Hurley <john.hurley@netronome.com>",
        "before_after_code_files": [
          "drivers/net/ethernet/netronome/nfp/abm/cls.c||drivers/net/ethernet/netronome/nfp/abm/cls.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "drivers/net/ethernet/netronome/nfp/abm/cls.c||drivers/net/ethernet/netronome/nfp/abm/cls.c"
          ],
          "candidate": [
            "drivers/net/ethernet/netronome/nfp/abm/cls.c||drivers/net/ethernet/netronome/nfp/abm/cls.c"
          ]
        }
      },
      "candidate_diff": {
        "drivers/net/ethernet/netronome/nfp/abm/cls.c||drivers/net/ethernet/netronome/nfp/abm/cls.c": [
          "File: drivers/net/ethernet/netronome/nfp/abm/cls.c -> drivers/net/ethernet/netronome/nfp/abm/cls.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "176:  u8 mask, val;",
          "177:  int err;",
          "181:   goto err_delete;",
          "184:  tos_off = proto == htons(ETH_P_IP) ? 16 : 20;",
          "",
          "[Removed Lines]",
          "179:  if (!nfp_abm_u32_check_knode(alink->abm, knode, proto, extack)) {",
          "180:   err = -EOPNOTSUPP;",
          "182:  }",
          "",
          "[Added Lines]",
          "179:  if (!nfp_abm_u32_check_knode(alink->abm, knode, proto, extack))",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "200:   if ((iter->val & cmask) == (val & cmask) &&",
          "201:       iter->band != knode->res->classid) {",
          "202:    NL_SET_ERR_MSG_MOD(extack, \"conflict with already offloaded filter\");",
          "204:    goto err_delete;",
          "205:   }",
          "206:  }",
          "208:  if (!match) {",
          "209:   match = kzalloc(sizeof(*match), GFP_KERNEL);",
          "215:   list_add(&match->list, &alink->dscp_map);",
          "216:  }",
          "217:  match->handle = knode->handle;",
          "",
          "[Removed Lines]",
          "203:    err = -EOPNOTSUPP;",
          "210:   if (!match) {",
          "211:    err = -ENOMEM;",
          "212:    goto err_delete;",
          "213:   }",
          "",
          "[Added Lines]",
          "207:   if (!match)",
          "208:    return -ENOMEM;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "228: err_delete:",
          "229:  nfp_abm_u32_knode_delete(alink, knode);",
          "231: }",
          "233: static int nfp_abm_setup_tc_block_cb(enum tc_setup_type type,",
          "",
          "[Removed Lines]",
          "230:  return err;",
          "",
          "[Added Lines]",
          "224:  return -EOPNOTSUPP;",
          "",
          "---------------"
        ]
      }
    }
  ]
}
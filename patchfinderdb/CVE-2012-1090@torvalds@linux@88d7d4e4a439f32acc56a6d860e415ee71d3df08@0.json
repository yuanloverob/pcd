{
  "cve_id": "CVE-2012-1090",
  "cve_desc": "The cifs_lookup function in fs/cifs/dir.c in the Linux kernel before 3.2.10 allows local users to cause a denial of service (OOPS) via attempted access to a special file, as demonstrated by a FIFO.",
  "repo": "torvalds/linux",
  "patch_hash": "88d7d4e4a439f32acc56a6d860e415ee71d3df08",
  "patch_info": {
    "commit_hash": "88d7d4e4a439f32acc56a6d860e415ee71d3df08",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/88d7d4e4a439f32acc56a6d860e415ee71d3df08",
    "files": [
      "fs/cifs/dir.c"
    ],
    "message": "cifs: fix dentry refcount leak when opening a FIFO on lookup\n\ncommit 5bccda0ebc7c0331b81ac47d39e4b920b198b2cd upstream.\n\nThe cifs code will attempt to open files on lookup under certain\ncircumstances. What happens though if we find that the file we opened\nwas actually a FIFO or other special file?\n\nCurrently, the open filehandle just ends up being leaked leading to\na dentry refcount mismatch and oops on umount. Fix this by having the\ncode close the filehandle on the server if it turns out not to be a\nregular file. While we're at it, change this spaghetti if statement\ninto a switch too.\n\nReported-by: CAI Qian <caiqian@redhat.com>\nTested-by: CAI Qian <caiqian@redhat.com>\nReviewed-by: Shirish Pargaonkar <shirishpargaonkar@gmail.com>\nSigned-off-by: Jeff Layton <jlayton@redhat.com>\nSigned-off-by: Steve French <smfrench@gmail.com>\nSigned-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>",
    "before_after_code_files": [
      "fs/cifs/dir.c||fs/cifs/dir.c"
    ]
  },
  "patch_diff": {
    "fs/cifs/dir.c||fs/cifs/dir.c": [
      "File: fs/cifs/dir.c -> fs/cifs/dir.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "588:     posix_open = true;",
      "590:     pTcon->broken_posix_open = true;",
      "591:   }",
      "592:   if (!posix_open)",
      "593:    rc = cifs_get_inode_info_unix(&newInode, full_path,",
      "",
      "[Removed Lines]",
      "587:    if ((rc == 0) || (rc == -ENOENT))",
      "589:    else if ((rc == -EINVAL) || (rc != -EOPNOTSUPP))",
      "",
      "[Added Lines]",
      "587:    switch (rc) {",
      "588:    case 0:",
      "596:     if (newInode && !S_ISREG(newInode->i_mode)) {",
      "597:      CIFSSMBClose(xid, pTcon, fileHandle);",
      "598:      break;",
      "599:     }",
      "600:    case -ENOENT:",
      "602:    case -EOPNOTSUPP:",
      "603:     break;",
      "604:    default:",
      "606:    }",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "5bccda0ebc7c0331b81ac47d39e4b920b198b2cd",
      "candidate_info": {
        "commit_hash": "5bccda0ebc7c0331b81ac47d39e4b920b198b2cd",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/5bccda0ebc7c0331b81ac47d39e4b920b198b2cd",
        "files": [
          "fs/cifs/dir.c"
        ],
        "message": "cifs: fix dentry refcount leak when opening a FIFO on lookup\n\nThe cifs code will attempt to open files on lookup under certain\ncircumstances. What happens though if we find that the file we opened\nwas actually a FIFO or other special file?\n\nCurrently, the open filehandle just ends up being leaked leading to\na dentry refcount mismatch and oops on umount. Fix this by having the\ncode close the filehandle on the server if it turns out not to be a\nregular file. While we're at it, change this spaghetti if statement\ninto a switch too.\n\nCc: stable@vger.kernel.org\nReported-by: CAI Qian <caiqian@redhat.com>\nTested-by: CAI Qian <caiqian@redhat.com>\nReviewed-by: Shirish Pargaonkar <shirishpargaonkar@gmail.com>\nSigned-off-by: Jeff Layton <jlayton@redhat.com>\nSigned-off-by: Steve French <smfrench@gmail.com>",
        "before_after_code_files": [
          "fs/cifs/dir.c||fs/cifs/dir.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "fs/cifs/dir.c||fs/cifs/dir.c"
          ],
          "candidate": [
            "fs/cifs/dir.c||fs/cifs/dir.c"
          ]
        }
      },
      "candidate_diff": {
        "fs/cifs/dir.c||fs/cifs/dir.c": [
          "File: fs/cifs/dir.c -> fs/cifs/dir.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "588:     posix_open = true;",
          "590:     pTcon->broken_posix_open = true;",
          "591:   }",
          "592:   if (!posix_open)",
          "593:    rc = cifs_get_inode_info_unix(&newInode, full_path,",
          "",
          "[Removed Lines]",
          "587:    if ((rc == 0) || (rc == -ENOENT))",
          "589:    else if ((rc == -EINVAL) || (rc != -EOPNOTSUPP))",
          "",
          "[Added Lines]",
          "587:    switch (rc) {",
          "588:    case 0:",
          "596:     if (newInode && !S_ISREG(newInode->i_mode)) {",
          "597:      CIFSSMBClose(xid, pTcon, fileHandle);",
          "598:      break;",
          "599:     }",
          "600:    case -ENOENT:",
          "602:    case -EOPNOTSUPP:",
          "603:     break;",
          "604:    default:",
          "606:    }",
          "",
          "---------------"
        ]
      }
    }
  ]
}
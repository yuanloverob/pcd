{
  "cve_id": "CVE-2012-1179",
  "cve_desc": "The Linux kernel before 3.3.1, when KVM is used, allows guest OS users to cause a denial of service (host OS crash) by leveraging administrative access to the guest OS, related to the pmd_none_or_clear_bad function and page faults for huge pages.",
  "repo": "torvalds/linux",
  "patch_hash": "4a1d704194a441bf83c636004a479e01360ec850",
  "patch_info": {
    "commit_hash": "4a1d704194a441bf83c636004a479e01360ec850",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/4a1d704194a441bf83c636004a479e01360ec850",
    "files": [
      "arch/x86/kernel/vm86_32.c",
      "fs/proc/task_mmu.c",
      "include/asm-generic/pgtable.h",
      "mm/memcontrol.c",
      "mm/memory.c",
      "mm/mempolicy.c",
      "mm/mincore.c",
      "mm/pagewalk.c",
      "mm/swapfile.c"
    ],
    "message": "mm: thp: fix pmd_bad() triggering in code paths holding mmap_sem read mode\n\ncommit 1a5a9906d4e8d1976b701f889d8f35d54b928f25 upstream.\n\nIn some cases it may happen that pmd_none_or_clear_bad() is called with\nthe mmap_sem hold in read mode.  In those cases the huge page faults can\nallocate hugepmds under pmd_none_or_clear_bad() and that can trigger a\nfalse positive from pmd_bad() that will not like to see a pmd\nmaterializing as trans huge.\n\nIt's not khugepaged causing the problem, khugepaged holds the mmap_sem\nin write mode (and all those sites must hold the mmap_sem in read mode\nto prevent pagetables to go away from under them, during code review it\nseems vm86 mode on 32bit kernels requires that too unless it's\nrestricted to 1 thread per process or UP builds).  The race is only with\nthe huge pagefaults that can convert a pmd_none() into a\npmd_trans_huge().\n\nEffectively all these pmd_none_or_clear_bad() sites running with\nmmap_sem in read mode are somewhat speculative with the page faults, and\nthe result is always undefined when they run simultaneously.  This is\nprobably why it wasn't common to run into this.  For example if the\nmadvise(MADV_DONTNEED) runs zap_page_range() shortly before the page\nfault, the hugepage will not be zapped, if the page fault runs first it\nwill be zapped.\n\nAltering pmd_bad() not to error out if it finds hugepmds won't be enough\nto fix this, because zap_pmd_range would then proceed to call\nzap_pte_range (which would be incorrect if the pmd become a\npmd_trans_huge()).\n\nThe simplest way to fix this is to read the pmd in the local stack\n(regardless of what we read, no need of actual CPU barriers, only\ncompiler barrier needed), and be sure it is not changing under the code\nthat computes its value.  Even if the real pmd is changing under the\nvalue we hold on the stack, we don't care.  If we actually end up in\nzap_pte_range it means the pmd was not none already and it was not huge,\nand it can't become huge from under us (khugepaged locking explained\nabove).\n\nAll we need is to enforce that there is no way anymore that in a code\npath like below, pmd_trans_huge can be false, but pmd_none_or_clear_bad\ncan run into a hugepmd.  The overhead of a barrier() is just a compiler\ntweak and should not be measurable (I only added it for THP builds).  I\ndon't exclude different compiler versions may have prevented the race\ntoo by caching the value of *pmd on the stack (that hasn't been\nverified, but it wouldn't be impossible considering\npmd_none_or_clear_bad, pmd_bad, pmd_trans_huge, pmd_none are all inlines\nand there's no external function called in between pmd_trans_huge and\npmd_none_or_clear_bad).\n\n\t\tif (pmd_trans_huge(*pmd)) {\n\t\t\tif (next-addr != HPAGE_PMD_SIZE) {\n\t\t\t\tVM_BUG_ON(!rwsem_is_locked(&tlb->mm->mmap_sem));\n\t\t\t\tsplit_huge_page_pmd(vma->vm_mm, pmd);\n\t\t\t} else if (zap_huge_pmd(tlb, vma, pmd, addr))\n\t\t\t\tcontinue;\n\t\t\t/* fall through */\n\t\t}\n\t\tif (pmd_none_or_clear_bad(pmd))\n\nBecause this race condition could be exercised without special\nprivileges this was reported in CVE-2012-1179.\n\nThe race was identified and fully explained by Ulrich who debugged it.\nI'm quoting his accurate explanation below, for reference.\n\n====== start quote =======\n      mapcount 0 page_mapcount 1\n      kernel BUG at mm/huge_memory.c:1384!\n\n    At some point prior to the panic, a \"bad pmd ...\" message similar to the\n    following is logged on the console:\n\n      mm/memory.c:145: bad pmd ffff8800376e1f98(80000000314000e7).\n\n    The \"bad pmd ...\" message is logged by pmd_clear_bad() before it clears\n    the page's PMD table entry.\n\n        143 void pmd_clear_bad(pmd_t *pmd)\n        144 {\n    ->  145         pmd_ERROR(*pmd);\n        146         pmd_clear(pmd);\n        147 }\n\n    After the PMD table entry has been cleared, there is an inconsistency\n    between the actual number of PMD table entries that are mapping the page\n    and the page's map count (_mapcount field in struct page). When the page\n    is subsequently reclaimed, __split_huge_page() detects this inconsistency.\n\n       1381         if (mapcount != page_mapcount(page))\n       1382                 printk(KERN_ERR \"mapcount %d page_mapcount %d\\n\",\n       1383                        mapcount, page_mapcount(page));\n    -> 1384         BUG_ON(mapcount != page_mapcount(page));\n\n    The root cause of the problem is a race of two threads in a multithreaded\n    process. Thread B incurs a page fault on a virtual address that has never\n    been accessed (PMD entry is zero) while Thread A is executing an madvise()\n    system call on a virtual address within the same 2 MB (huge page) range.\n\n               virtual address space\n              .---------------------.\n              |                     |\n              |                     |\n            .-|---------------------|\n            | |                     |\n            | |                     |<-- B(fault)\n            | |                     |\n      2 MB  | |/////////////////////|-.\n      huge <  |/////////////////////|  > A(range)\n      page  | |/////////////////////|-'\n            | |                     |\n            | |                     |\n            '-|---------------------|\n              |                     |\n              |                     |\n              '---------------------'\n\n    - Thread A is executing an madvise(..., MADV_DONTNEED) system call\n      on the virtual address range \"A(range)\" shown in the picture.\n\n    sys_madvise\n      // Acquire the semaphore in shared mode.\n      down_read(&current->mm->mmap_sem)\n      ...\n      madvise_vma\n        switch (behavior)\n        case MADV_DONTNEED:\n             madvise_dontneed\n               zap_page_range\n                 unmap_vmas\n                   unmap_page_range\n                     zap_pud_range\n                       zap_pmd_range\n                         //\n                         // Assume that this huge page has never been accessed.\n                         // I.e. content of the PMD entry is zero (not mapped).\n                         //\n                         if (pmd_trans_huge(*pmd)) {\n                             // We don't get here due to the above assumption.\n                         }\n                         //\n                         // Assume that Thread B incurred a page fault and\n             .---------> // sneaks in here as shown below.\n             |           //\n             |           if (pmd_none_or_clear_bad(pmd))\n             |               {\n             |                 if (unlikely(pmd_bad(*pmd)))\n             |                     pmd_clear_bad\n             |                     {\n             |                       pmd_ERROR\n             |                         // Log \"bad pmd ...\" message here.\n             |                       pmd_clear\n             |                         // Clear the page's PMD entry.\n             |                         // Thread B incremented the map count\n             |                         // in page_add_new_anon_rmap(), but\n             |                         // now the page is no longer mapped\n             |                         // by a PMD entry (-> inconsistency).\n             |                     }\n             |               }\n             |\n             v\n    - Thread B is handling a page fault on virtual address \"B(fault)\" shown\n      in the picture.\n\n    ...\n    do_page_fault\n      __do_page_fault\n        // Acquire the semaphore in shared mode.\n        down_read_trylock(&mm->mmap_sem)\n        ...\n        handle_mm_fault\n          if (pmd_none(*pmd) && transparent_hugepage_enabled(vma))\n              // We get here due to the above assumption (PMD entry is zero).\n              do_huge_pmd_anonymous_page\n                alloc_hugepage_vma\n                  // Allocate a new transparent huge page here.\n                ...\n                __do_huge_pmd_anonymous_page\n                  ...\n                  spin_lock(&mm->page_table_lock)\n                  ...\n                  page_add_new_anon_rmap\n                    // Here we increment the page's map count (starts at -1).\n                    atomic_set(&page->_mapcount, 0)\n                  set_pmd_at\n                    // Here we set the page's PMD entry which will be cleared\n                    // when Thread A calls pmd_clear_bad().\n                  ...\n                  spin_unlock(&mm->page_table_lock)\n\n    The mmap_sem does not prevent the race because both threads are acquiring\n    it in shared mode (down_read).  Thread B holds the page_table_lock while\n    the page's map count and PMD table entry are updated.  However, Thread A\n    does not synchronize on that lock.\n\n====== end quote =======\n\n[akpm@linux-foundation.org: checkpatch fixes]\nReported-by: Ulrich Obergfell <uobergfe@redhat.com>\nSigned-off-by: Andrea Arcangeli <aarcange@redhat.com>\nAcked-by: Johannes Weiner <hannes@cmpxchg.org>\nCc: Mel Gorman <mgorman@suse.de>\nCc: Hugh Dickins <hughd@google.com>\nCc: Dave Jones <davej@redhat.com>\nAcked-by: Larry Woodman <lwoodman@redhat.com>\nAcked-by: Rik van Riel <riel@redhat.com>\nCc: Mark Salter <msalter@redhat.com>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>\nSigned-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>",
    "before_after_code_files": [
      "arch/x86/kernel/vm86_32.c||arch/x86/kernel/vm86_32.c",
      "fs/proc/task_mmu.c||fs/proc/task_mmu.c",
      "include/asm-generic/pgtable.h||include/asm-generic/pgtable.h",
      "mm/memcontrol.c||mm/memcontrol.c",
      "mm/memory.c||mm/memory.c",
      "mm/mempolicy.c||mm/mempolicy.c",
      "mm/mincore.c||mm/mincore.c",
      "mm/pagewalk.c||mm/pagewalk.c",
      "mm/swapfile.c||mm/swapfile.c"
    ]
  },
  "patch_diff": {
    "arch/x86/kernel/vm86_32.c||arch/x86/kernel/vm86_32.c": [
      "File: arch/x86/kernel/vm86_32.c -> arch/x86/kernel/vm86_32.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "172:  spinlock_t *ptl;",
      "173:  int i;",
      "175:  pgd = pgd_offset(mm, 0xA0000);",
      "176:  if (pgd_none_or_clear_bad(pgd))",
      "177:   goto out;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "175:  down_write(&mm->mmap_sem);",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "190:  }",
      "191:  pte_unmap_unlock(pte, ptl);",
      "192: out:",
      "193:  flush_tlb();",
      "194: }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "194:  up_write(&mm->mmap_sem);",
      "",
      "---------------"
    ],
    "fs/proc/task_mmu.c||fs/proc/task_mmu.c": [
      "File: fs/proc/task_mmu.c -> fs/proc/task_mmu.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "409:  } else {",
      "410:   spin_unlock(&walk->mm->page_table_lock);",
      "411:  }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "413:  if (pmd_trans_unstable(pmd))",
      "414:   return 0;",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "507:  struct page *page;",
      "509:  split_huge_page_pmd(walk->mm, pmd);",
      "511:  pte = pte_offset_map_lock(vma->vm_mm, pmd, addr, &ptl);",
      "512:  for (; addr != end; pte++, addr += PAGE_SIZE) {",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "513:  if (pmd_trans_unstable(pmd))",
      "514:   return 0;",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "670:  int err = 0;",
      "672:  split_huge_page_pmd(walk->mm, pmd);",
      "675:  vma = find_vma(walk->mm, addr);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "678:  if (pmd_trans_unstable(pmd))",
      "679:   return 0;",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "961:   spin_unlock(&walk->mm->page_table_lock);",
      "962:  }",
      "964:  orig_pte = pte = pte_offset_map_lock(walk->mm, pmd, addr, &ptl);",
      "965:  do {",
      "966:   struct page *page = can_gather_numa_stats(*pte, md->vma, addr);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "971:  if (pmd_trans_unstable(pmd))",
      "972:   return 0;",
      "",
      "---------------"
    ],
    "include/asm-generic/pgtable.h||include/asm-generic/pgtable.h": [
      "File: include/asm-generic/pgtable.h -> include/asm-generic/pgtable.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "425:     unsigned long size);",
      "426: #endif",
      "428: #ifndef CONFIG_TRANSPARENT_HUGEPAGE",
      "429: static inline int pmd_trans_huge(pmd_t pmd)",
      "430: {",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "428: #ifdef CONFIG_MMU",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "441:  return 0;",
      "442: }",
      "444: #endif",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "462: static inline int pmd_none_or_trans_huge_or_clear_bad(pmd_t *pmd)",
      "463: {",
      "465:  pmd_t pmdval = *pmd;",
      "470: #ifdef CONFIG_TRANSPARENT_HUGEPAGE",
      "471:  barrier();",
      "472: #endif",
      "473:  if (pmd_none(pmdval))",
      "474:   return 1;",
      "475:  if (unlikely(pmd_bad(pmdval))) {",
      "476:   if (!pmd_trans_huge(pmdval))",
      "477:    pmd_clear_bad(pmd);",
      "478:   return 1;",
      "479:  }",
      "480:  return 0;",
      "481: }",
      "496: static inline int pmd_trans_unstable(pmd_t *pmd)",
      "497: {",
      "498: #ifdef CONFIG_TRANSPARENT_HUGEPAGE",
      "499:  return pmd_none_or_trans_huge_or_clear_bad(pmd);",
      "500: #else",
      "501:  return 0;",
      "503: }",
      "",
      "---------------"
    ],
    "mm/memcontrol.c||mm/memcontrol.c": [
      "File: mm/memcontrol.c -> mm/memcontrol.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "5234:  spinlock_t *ptl;",
      "5236:  split_huge_page_pmd(walk->mm, pmd);",
      "5238:  pte = pte_offset_map_lock(vma->vm_mm, pmd, addr, &ptl);",
      "5239:  for (; addr != end; pte++, addr += PAGE_SIZE)",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "5237:  if (pmd_trans_unstable(pmd))",
      "5238:   return 0;",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "5396:  spinlock_t *ptl;",
      "5398:  split_huge_page_pmd(walk->mm, pmd);",
      "5399: retry:",
      "5400:  pte = pte_offset_map_lock(vma->vm_mm, pmd, addr, &ptl);",
      "5401:  for (; addr != end; addr += PAGE_SIZE) {",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "5401:  if (pmd_trans_unstable(pmd))",
      "5402:   return 0;",
      "",
      "---------------"
    ],
    "mm/memory.c||mm/memory.c": [
      "File: mm/memory.c -> mm/memory.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "1247:  do {",
      "1248:   next = pmd_addr_end(addr, end);",
      "1249:   if (pmd_trans_huge(*pmd)) {",
      "1251:     VM_BUG_ON(!rwsem_is_locked(&tlb->mm->mmap_sem));",
      "1252:     split_huge_page_pmd(vma->vm_mm, pmd);",
      "1253:    } else if (zap_huge_pmd(tlb, vma, pmd, addr))",
      "1256:   }",
      "1259:   next = zap_pte_range(tlb, vma, pmd, addr, next, details);",
      "1260:   cond_resched();",
      "1261:  } while (pmd++, addr = next, addr != end);",
      "",
      "[Removed Lines]",
      "1250:    if (next-addr != HPAGE_PMD_SIZE) {",
      "1254:     continue;",
      "1257:   if (pmd_none_or_clear_bad(pmd))",
      "1258:    continue;",
      "",
      "[Added Lines]",
      "1250:    if (next - addr != HPAGE_PMD_SIZE) {",
      "1254:     goto next;",
      "1264:   if (pmd_none_or_trans_huge_or_clear_bad(pmd))",
      "1265:    goto next;",
      "1267: next:",
      "",
      "---------------"
    ],
    "mm/mempolicy.c||mm/mempolicy.c": [
      "File: mm/mempolicy.c -> mm/mempolicy.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "512:  do {",
      "513:   next = pmd_addr_end(addr, end);",
      "514:   split_huge_page_pmd(vma->vm_mm, pmd);",
      "516:    continue;",
      "517:   if (check_pte_range(vma, pmd, addr, next, nodes,",
      "518:         flags, private))",
      "",
      "[Removed Lines]",
      "515:   if (pmd_none_or_clear_bad(pmd))",
      "",
      "[Added Lines]",
      "515:   if (pmd_none_or_trans_huge_or_clear_bad(pmd))",
      "",
      "---------------"
    ],
    "mm/mincore.c||mm/mincore.c": [
      "File: mm/mincore.c -> mm/mincore.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "164:    }",
      "166:   }",
      "168:    mincore_unmapped_range(vma, addr, next, vec);",
      "169:   else",
      "170:    mincore_pte_range(vma, pmd, addr, next, vec);",
      "",
      "[Removed Lines]",
      "167:   if (pmd_none_or_clear_bad(pmd))",
      "",
      "[Added Lines]",
      "167:   if (pmd_none_or_trans_huge_or_clear_bad(pmd))",
      "",
      "---------------"
    ],
    "mm/pagewalk.c||mm/pagewalk.c": [
      "File: mm/pagewalk.c -> mm/pagewalk.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "59:    continue;",
      "61:   split_huge_page_pmd(walk->mm, pmd);",
      "63:    goto again;",
      "64:   err = walk_pte_range(pmd, addr, next, walk);",
      "65:   if (err)",
      "",
      "[Removed Lines]",
      "62:   if (pmd_none_or_clear_bad(pmd))",
      "",
      "[Added Lines]",
      "62:   if (pmd_none_or_trans_huge_or_clear_bad(pmd))",
      "",
      "---------------"
    ],
    "mm/swapfile.c||mm/swapfile.c": [
      "File: mm/swapfile.c -> mm/swapfile.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "932:  pmd = pmd_offset(pud, addr);",
      "933:  do {",
      "934:   next = pmd_addr_end(addr, end);",
      "938:    continue;",
      "939:   ret = unuse_pte_range(vma, pmd, addr, next, entry, page);",
      "940:   if (ret)",
      "",
      "[Removed Lines]",
      "935:   if (unlikely(pmd_trans_huge(*pmd)))",
      "936:    continue;",
      "937:   if (pmd_none_or_clear_bad(pmd))",
      "",
      "[Added Lines]",
      "935:   if (pmd_none_or_trans_huge_or_clear_bad(pmd))",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "1a5a9906d4e8d1976b701f889d8f35d54b928f25",
      "candidate_info": {
        "commit_hash": "1a5a9906d4e8d1976b701f889d8f35d54b928f25",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/1a5a9906d4e8d1976b701f889d8f35d54b928f25",
        "files": [
          "arch/x86/kernel/vm86_32.c",
          "fs/proc/task_mmu.c",
          "include/asm-generic/pgtable.h",
          "mm/memcontrol.c",
          "mm/memory.c",
          "mm/mempolicy.c",
          "mm/mincore.c",
          "mm/pagewalk.c",
          "mm/swapfile.c"
        ],
        "message": "mm: thp: fix pmd_bad() triggering in code paths holding mmap_sem read mode\n\nIn some cases it may happen that pmd_none_or_clear_bad() is called with\nthe mmap_sem hold in read mode.  In those cases the huge page faults can\nallocate hugepmds under pmd_none_or_clear_bad() and that can trigger a\nfalse positive from pmd_bad() that will not like to see a pmd\nmaterializing as trans huge.\n\nIt's not khugepaged causing the problem, khugepaged holds the mmap_sem\nin write mode (and all those sites must hold the mmap_sem in read mode\nto prevent pagetables to go away from under them, during code review it\nseems vm86 mode on 32bit kernels requires that too unless it's\nrestricted to 1 thread per process or UP builds).  The race is only with\nthe huge pagefaults that can convert a pmd_none() into a\npmd_trans_huge().\n\nEffectively all these pmd_none_or_clear_bad() sites running with\nmmap_sem in read mode are somewhat speculative with the page faults, and\nthe result is always undefined when they run simultaneously.  This is\nprobably why it wasn't common to run into this.  For example if the\nmadvise(MADV_DONTNEED) runs zap_page_range() shortly before the page\nfault, the hugepage will not be zapped, if the page fault runs first it\nwill be zapped.\n\nAltering pmd_bad() not to error out if it finds hugepmds won't be enough\nto fix this, because zap_pmd_range would then proceed to call\nzap_pte_range (which would be incorrect if the pmd become a\npmd_trans_huge()).\n\nThe simplest way to fix this is to read the pmd in the local stack\n(regardless of what we read, no need of actual CPU barriers, only\ncompiler barrier needed), and be sure it is not changing under the code\nthat computes its value.  Even if the real pmd is changing under the\nvalue we hold on the stack, we don't care.  If we actually end up in\nzap_pte_range it means the pmd was not none already and it was not huge,\nand it can't become huge from under us (khugepaged locking explained\nabove).\n\nAll we need is to enforce that there is no way anymore that in a code\npath like below, pmd_trans_huge can be false, but pmd_none_or_clear_bad\ncan run into a hugepmd.  The overhead of a barrier() is just a compiler\ntweak and should not be measurable (I only added it for THP builds).  I\ndon't exclude different compiler versions may have prevented the race\ntoo by caching the value of *pmd on the stack (that hasn't been\nverified, but it wouldn't be impossible considering\npmd_none_or_clear_bad, pmd_bad, pmd_trans_huge, pmd_none are all inlines\nand there's no external function called in between pmd_trans_huge and\npmd_none_or_clear_bad).\n\n\t\tif (pmd_trans_huge(*pmd)) {\n\t\t\tif (next-addr != HPAGE_PMD_SIZE) {\n\t\t\t\tVM_BUG_ON(!rwsem_is_locked(&tlb->mm->mmap_sem));\n\t\t\t\tsplit_huge_page_pmd(vma->vm_mm, pmd);\n\t\t\t} else if (zap_huge_pmd(tlb, vma, pmd, addr))\n\t\t\t\tcontinue;\n\t\t\t/* fall through */\n\t\t}\n\t\tif (pmd_none_or_clear_bad(pmd))\n\nBecause this race condition could be exercised without special\nprivileges this was reported in CVE-2012-1179.\n\nThe race was identified and fully explained by Ulrich who debugged it.\nI'm quoting his accurate explanation below, for reference.\n\n====== start quote =======\n      mapcount 0 page_mapcount 1\n      kernel BUG at mm/huge_memory.c:1384!\n\n    At some point prior to the panic, a \"bad pmd ...\" message similar to the\n    following is logged on the console:\n\n      mm/memory.c:145: bad pmd ffff8800376e1f98(80000000314000e7).\n\n    The \"bad pmd ...\" message is logged by pmd_clear_bad() before it clears\n    the page's PMD table entry.\n\n        143 void pmd_clear_bad(pmd_t *pmd)\n        144 {\n    ->  145         pmd_ERROR(*pmd);\n        146         pmd_clear(pmd);\n        147 }\n\n    After the PMD table entry has been cleared, there is an inconsistency\n    between the actual number of PMD table entries that are mapping the page\n    and the page's map count (_mapcount field in struct page). When the page\n    is subsequently reclaimed, __split_huge_page() detects this inconsistency.\n\n       1381         if (mapcount != page_mapcount(page))\n       1382                 printk(KERN_ERR \"mapcount %d page_mapcount %d\\n\",\n       1383                        mapcount, page_mapcount(page));\n    -> 1384         BUG_ON(mapcount != page_mapcount(page));\n\n    The root cause of the problem is a race of two threads in a multithreaded\n    process. Thread B incurs a page fault on a virtual address that has never\n    been accessed (PMD entry is zero) while Thread A is executing an madvise()\n    system call on a virtual address within the same 2 MB (huge page) range.\n\n               virtual address space\n              .---------------------.\n              |                     |\n              |                     |\n            .-|---------------------|\n            | |                     |\n            | |                     |<-- B(fault)\n            | |                     |\n      2 MB  | |/////////////////////|-.\n      huge <  |/////////////////////|  > A(range)\n      page  | |/////////////////////|-'\n            | |                     |\n            | |                     |\n            '-|---------------------|\n              |                     |\n              |                     |\n              '---------------------'\n\n    - Thread A is executing an madvise(..., MADV_DONTNEED) system call\n      on the virtual address range \"A(range)\" shown in the picture.\n\n    sys_madvise\n      // Acquire the semaphore in shared mode.\n      down_read(&current->mm->mmap_sem)\n      ...\n      madvise_vma\n        switch (behavior)\n        case MADV_DONTNEED:\n             madvise_dontneed\n               zap_page_range\n                 unmap_vmas\n                   unmap_page_range\n                     zap_pud_range\n                       zap_pmd_range\n                         //\n                         // Assume that this huge page has never been accessed.\n                         // I.e. content of the PMD entry is zero (not mapped).\n                         //\n                         if (pmd_trans_huge(*pmd)) {\n                             // We don't get here due to the above assumption.\n                         }\n                         //\n                         // Assume that Thread B incurred a page fault and\n             .---------> // sneaks in here as shown below.\n             |           //\n             |           if (pmd_none_or_clear_bad(pmd))\n             |               {\n             |                 if (unlikely(pmd_bad(*pmd)))\n             |                     pmd_clear_bad\n             |                     {\n             |                       pmd_ERROR\n             |                         // Log \"bad pmd ...\" message here.\n             |                       pmd_clear\n             |                         // Clear the page's PMD entry.\n             |                         // Thread B incremented the map count\n             |                         // in page_add_new_anon_rmap(), but\n             |                         // now the page is no longer mapped\n             |                         // by a PMD entry (-> inconsistency).\n             |                     }\n             |               }\n             |\n             v\n    - Thread B is handling a page fault on virtual address \"B(fault)\" shown\n      in the picture.\n\n    ...\n    do_page_fault\n      __do_page_fault\n        // Acquire the semaphore in shared mode.\n        down_read_trylock(&mm->mmap_sem)\n        ...\n        handle_mm_fault\n          if (pmd_none(*pmd) && transparent_hugepage_enabled(vma))\n              // We get here due to the above assumption (PMD entry is zero).\n              do_huge_pmd_anonymous_page\n                alloc_hugepage_vma\n                  // Allocate a new transparent huge page here.\n                ...\n                __do_huge_pmd_anonymous_page\n                  ...\n                  spin_lock(&mm->page_table_lock)\n                  ...\n                  page_add_new_anon_rmap\n                    // Here we increment the page's map count (starts at -1).\n                    atomic_set(&page->_mapcount, 0)\n                  set_pmd_at\n                    // Here we set the page's PMD entry which will be cleared\n                    // when Thread A calls pmd_clear_bad().\n                  ...\n                  spin_unlock(&mm->page_table_lock)\n\n    The mmap_sem does not prevent the race because both threads are acquiring\n    it in shared mode (down_read).  Thread B holds the page_table_lock while\n    the page's map count and PMD table entry are updated.  However, Thread A\n    does not synchronize on that lock.\n\n====== end quote =======\n\n[akpm@linux-foundation.org: checkpatch fixes]\nReported-by: Ulrich Obergfell <uobergfe@redhat.com>\nSigned-off-by: Andrea Arcangeli <aarcange@redhat.com>\nAcked-by: Johannes Weiner <hannes@cmpxchg.org>\nCc: Mel Gorman <mgorman@suse.de>\nCc: Hugh Dickins <hughd@google.com>\nCc: Dave Jones <davej@redhat.com>\nAcked-by: Larry Woodman <lwoodman@redhat.com>\nAcked-by: Rik van Riel <riel@redhat.com>\nCc: <stable@vger.kernel.org>\t\t[2.6.38+]\nCc: Mark Salter <msalter@redhat.com>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
        "before_after_code_files": [
          "arch/x86/kernel/vm86_32.c||arch/x86/kernel/vm86_32.c",
          "fs/proc/task_mmu.c||fs/proc/task_mmu.c",
          "include/asm-generic/pgtable.h||include/asm-generic/pgtable.h",
          "mm/memcontrol.c||mm/memcontrol.c",
          "mm/memory.c||mm/memory.c",
          "mm/mempolicy.c||mm/mempolicy.c",
          "mm/mincore.c||mm/mincore.c",
          "mm/pagewalk.c||mm/pagewalk.c",
          "mm/swapfile.c||mm/swapfile.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "arch/x86/kernel/vm86_32.c||arch/x86/kernel/vm86_32.c",
            "fs/proc/task_mmu.c||fs/proc/task_mmu.c",
            "include/asm-generic/pgtable.h||include/asm-generic/pgtable.h",
            "mm/memcontrol.c||mm/memcontrol.c",
            "mm/memory.c||mm/memory.c",
            "mm/mempolicy.c||mm/mempolicy.c",
            "mm/mincore.c||mm/mincore.c",
            "mm/pagewalk.c||mm/pagewalk.c",
            "mm/swapfile.c||mm/swapfile.c"
          ],
          "candidate": [
            "arch/x86/kernel/vm86_32.c||arch/x86/kernel/vm86_32.c",
            "fs/proc/task_mmu.c||fs/proc/task_mmu.c",
            "include/asm-generic/pgtable.h||include/asm-generic/pgtable.h",
            "mm/memcontrol.c||mm/memcontrol.c",
            "mm/memory.c||mm/memory.c",
            "mm/mempolicy.c||mm/mempolicy.c",
            "mm/mincore.c||mm/mincore.c",
            "mm/pagewalk.c||mm/pagewalk.c",
            "mm/swapfile.c||mm/swapfile.c"
          ]
        }
      },
      "candidate_diff": {
        "arch/x86/kernel/vm86_32.c||arch/x86/kernel/vm86_32.c": [
          "File: arch/x86/kernel/vm86_32.c -> arch/x86/kernel/vm86_32.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "172:  spinlock_t *ptl;",
          "173:  int i;",
          "175:  pgd = pgd_offset(mm, 0xA0000);",
          "176:  if (pgd_none_or_clear_bad(pgd))",
          "177:   goto out;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "175:  down_write(&mm->mmap_sem);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "190:  }",
          "191:  pte_unmap_unlock(pte, ptl);",
          "192: out:",
          "193:  flush_tlb();",
          "194: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "194:  up_write(&mm->mmap_sem);",
          "",
          "---------------"
        ],
        "fs/proc/task_mmu.c||fs/proc/task_mmu.c": [
          "File: fs/proc/task_mmu.c -> fs/proc/task_mmu.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "409:  } else {",
          "410:   spin_unlock(&walk->mm->page_table_lock);",
          "411:  }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "413:  if (pmd_trans_unstable(pmd))",
          "414:   return 0;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "507:  struct page *page;",
          "509:  split_huge_page_pmd(walk->mm, pmd);",
          "511:  pte = pte_offset_map_lock(vma->vm_mm, pmd, addr, &ptl);",
          "512:  for (; addr != end; pte++, addr += PAGE_SIZE) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "513:  if (pmd_trans_unstable(pmd))",
          "514:   return 0;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "670:  int err = 0;",
          "672:  split_huge_page_pmd(walk->mm, pmd);",
          "675:  vma = find_vma(walk->mm, addr);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "678:  if (pmd_trans_unstable(pmd))",
          "679:   return 0;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "961:   spin_unlock(&walk->mm->page_table_lock);",
          "962:  }",
          "964:  orig_pte = pte = pte_offset_map_lock(walk->mm, pmd, addr, &ptl);",
          "965:  do {",
          "966:   struct page *page = can_gather_numa_stats(*pte, md->vma, addr);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "971:  if (pmd_trans_unstable(pmd))",
          "972:   return 0;",
          "",
          "---------------"
        ],
        "include/asm-generic/pgtable.h||include/asm-generic/pgtable.h": [
          "File: include/asm-generic/pgtable.h -> include/asm-generic/pgtable.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "425:     unsigned long size);",
          "426: #endif",
          "428: #ifndef CONFIG_TRANSPARENT_HUGEPAGE",
          "429: static inline int pmd_trans_huge(pmd_t pmd)",
          "430: {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "428: #ifdef CONFIG_MMU",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "441:  return 0;",
          "442: }",
          "444: #endif",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "462: static inline int pmd_none_or_trans_huge_or_clear_bad(pmd_t *pmd)",
          "463: {",
          "465:  pmd_t pmdval = *pmd;",
          "470: #ifdef CONFIG_TRANSPARENT_HUGEPAGE",
          "471:  barrier();",
          "472: #endif",
          "473:  if (pmd_none(pmdval))",
          "474:   return 1;",
          "475:  if (unlikely(pmd_bad(pmdval))) {",
          "476:   if (!pmd_trans_huge(pmdval))",
          "477:    pmd_clear_bad(pmd);",
          "478:   return 1;",
          "479:  }",
          "480:  return 0;",
          "481: }",
          "496: static inline int pmd_trans_unstable(pmd_t *pmd)",
          "497: {",
          "498: #ifdef CONFIG_TRANSPARENT_HUGEPAGE",
          "499:  return pmd_none_or_trans_huge_or_clear_bad(pmd);",
          "500: #else",
          "501:  return 0;",
          "503: }",
          "",
          "---------------"
        ],
        "mm/memcontrol.c||mm/memcontrol.c": [
          "File: mm/memcontrol.c -> mm/memcontrol.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "5230:  spinlock_t *ptl;",
          "5232:  split_huge_page_pmd(walk->mm, pmd);",
          "5234:  pte = pte_offset_map_lock(vma->vm_mm, pmd, addr, &ptl);",
          "5235:  for (; addr != end; pte++, addr += PAGE_SIZE)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "5233:  if (pmd_trans_unstable(pmd))",
          "5234:   return 0;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "5390:  spinlock_t *ptl;",
          "5392:  split_huge_page_pmd(walk->mm, pmd);",
          "5393: retry:",
          "5394:  pte = pte_offset_map_lock(vma->vm_mm, pmd, addr, &ptl);",
          "5395:  for (; addr != end; addr += PAGE_SIZE) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "5395:  if (pmd_trans_unstable(pmd))",
          "5396:   return 0;",
          "",
          "---------------"
        ],
        "mm/memory.c||mm/memory.c": [
          "File: mm/memory.c -> mm/memory.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1247:  do {",
          "1248:   next = pmd_addr_end(addr, end);",
          "1249:   if (pmd_trans_huge(*pmd)) {",
          "1251:     VM_BUG_ON(!rwsem_is_locked(&tlb->mm->mmap_sem));",
          "1252:     split_huge_page_pmd(vma->vm_mm, pmd);",
          "1253:    } else if (zap_huge_pmd(tlb, vma, pmd, addr))",
          "1256:   }",
          "1259:   next = zap_pte_range(tlb, vma, pmd, addr, next, details);",
          "1260:   cond_resched();",
          "1261:  } while (pmd++, addr = next, addr != end);",
          "",
          "[Removed Lines]",
          "1250:    if (next-addr != HPAGE_PMD_SIZE) {",
          "1254:     continue;",
          "1257:   if (pmd_none_or_clear_bad(pmd))",
          "1258:    continue;",
          "",
          "[Added Lines]",
          "1250:    if (next - addr != HPAGE_PMD_SIZE) {",
          "1254:     goto next;",
          "1264:   if (pmd_none_or_trans_huge_or_clear_bad(pmd))",
          "1265:    goto next;",
          "1267: next:",
          "",
          "---------------"
        ],
        "mm/mempolicy.c||mm/mempolicy.c": [
          "File: mm/mempolicy.c -> mm/mempolicy.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "512:  do {",
          "513:   next = pmd_addr_end(addr, end);",
          "514:   split_huge_page_pmd(vma->vm_mm, pmd);",
          "516:    continue;",
          "517:   if (check_pte_range(vma, pmd, addr, next, nodes,",
          "518:         flags, private))",
          "",
          "[Removed Lines]",
          "515:   if (pmd_none_or_clear_bad(pmd))",
          "",
          "[Added Lines]",
          "515:   if (pmd_none_or_trans_huge_or_clear_bad(pmd))",
          "",
          "---------------"
        ],
        "mm/mincore.c||mm/mincore.c": [
          "File: mm/mincore.c -> mm/mincore.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "164:    }",
          "166:   }",
          "168:    mincore_unmapped_range(vma, addr, next, vec);",
          "169:   else",
          "170:    mincore_pte_range(vma, pmd, addr, next, vec);",
          "",
          "[Removed Lines]",
          "167:   if (pmd_none_or_clear_bad(pmd))",
          "",
          "[Added Lines]",
          "167:   if (pmd_none_or_trans_huge_or_clear_bad(pmd))",
          "",
          "---------------"
        ],
        "mm/pagewalk.c||mm/pagewalk.c": [
          "File: mm/pagewalk.c -> mm/pagewalk.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "59:    continue;",
          "61:   split_huge_page_pmd(walk->mm, pmd);",
          "63:    goto again;",
          "64:   err = walk_pte_range(pmd, addr, next, walk);",
          "65:   if (err)",
          "",
          "[Removed Lines]",
          "62:   if (pmd_none_or_clear_bad(pmd))",
          "",
          "[Added Lines]",
          "62:   if (pmd_none_or_trans_huge_or_clear_bad(pmd))",
          "",
          "---------------"
        ],
        "mm/swapfile.c||mm/swapfile.c": [
          "File: mm/swapfile.c -> mm/swapfile.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "932:  pmd = pmd_offset(pud, addr);",
          "933:  do {",
          "934:   next = pmd_addr_end(addr, end);",
          "938:    continue;",
          "939:   ret = unuse_pte_range(vma, pmd, addr, next, entry, page);",
          "940:   if (ret)",
          "",
          "[Removed Lines]",
          "935:   if (unlikely(pmd_trans_huge(*pmd)))",
          "936:    continue;",
          "937:   if (pmd_none_or_clear_bad(pmd))",
          "",
          "[Added Lines]",
          "935:   if (pmd_none_or_trans_huge_or_clear_bad(pmd))",
          "",
          "---------------"
        ]
      }
    }
  ]
}
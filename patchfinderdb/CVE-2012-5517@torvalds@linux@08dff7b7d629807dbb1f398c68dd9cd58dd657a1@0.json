{
  "cve_id": "CVE-2012-5517",
  "cve_desc": "The online_pages function in mm/memory_hotplug.c in the Linux kernel before 3.6 allows local users to cause a denial of service (NULL pointer dereference and system crash) or possibly have unspecified other impact in opportunistic circumstances by using memory that was hot-added by an administrator.",
  "repo": "torvalds/linux",
  "patch_hash": "08dff7b7d629807dbb1f398c68dd9cd58dd657a1",
  "patch_info": {
    "commit_hash": "08dff7b7d629807dbb1f398c68dd9cd58dd657a1",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/08dff7b7d629807dbb1f398c68dd9cd58dd657a1",
    "files": [
      "mm/memory_hotplug.c"
    ],
    "message": "mm/hotplug: correctly add new zone to all other nodes' zone lists\n\nWhen online_pages() is called to add new memory to an empty zone, it\nrebuilds all zone lists by calling build_all_zonelists().  But there's a\nbug which prevents the new zone to be added to other nodes' zone lists.\n\nonline_pages() {\n\tbuild_all_zonelists()\n\t.....\n\tnode_set_state(zone_to_nid(zone), N_HIGH_MEMORY)\n}\n\nHere the node of the zone is put into N_HIGH_MEMORY state after calling\nbuild_all_zonelists(), but build_all_zonelists() only adds zones from\nnodes in N_HIGH_MEMORY state to the fallback zone lists.\nbuild_all_zonelists()\n\n    ->__build_all_zonelists()\n\t->build_zonelists()\n\t    ->find_next_best_node()\n\t\t->for_each_node_state(n, N_HIGH_MEMORY)\n\nSo memory in the new zone will never be used by other nodes, and it may\ncause strange behavor when system is under memory pressure.  So put node\ninto N_HIGH_MEMORY state before calling build_all_zonelists().\n\nSigned-off-by: Jianguo Wu <wujianguo@huawei.com>\nSigned-off-by: Jiang Liu <liuj97@gmail.com>\nCc: Mel Gorman <mgorman@suse.de>\nCc: Michal Hocko <mhocko@suse.cz>\nCc: Minchan Kim <minchan@kernel.org>\nCc: Rusty Russell <rusty@rustcorp.com.au>\nCc: Yinghai Lu <yinghai@kernel.org>\nCc: Tony Luck <tony.luck@intel.com>\nCc: KAMEZAWA Hiroyuki <kamezawa.hiroyu@jp.fujitsu.com>\nCc: KOSAKI Motohiro <kosaki.motohiro@jp.fujitsu.com>\nCc: David Rientjes <rientjes@google.com>\nCc: Keping Chen <chenkeping@huawei.com>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
    "before_after_code_files": [
      "mm/memory_hotplug.c||mm/memory_hotplug.c"
    ]
  },
  "patch_diff": {
    "mm/memory_hotplug.c||mm/memory_hotplug.c": [
      "File: mm/memory_hotplug.c -> mm/memory_hotplug.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "513:  zone->present_pages += onlined_pages;",
      "514:  zone->zone_pgdat->node_present_pages += onlined_pages;",
      "520:  mutex_unlock(&zonelists_mutex);",
      "522:  init_per_zone_wmark_min();",
      "525:   kswapd_run(zone_to_nid(zone));",
      "529:  vm_total_pages = nr_free_pagecache_pages();",
      "",
      "[Removed Lines]",
      "515:  if (need_zonelists_rebuild)",
      "516:   build_all_zonelists(NULL, zone);",
      "517:  else",
      "518:   zone_pcp_update(zone);",
      "524:  if (onlined_pages) {",
      "526:   node_set_state(zone_to_nid(zone), N_HIGH_MEMORY);",
      "527:  }",
      "",
      "[Added Lines]",
      "515:  if (onlined_pages) {",
      "516:   node_set_state(zone_to_nid(zone), N_HIGH_MEMORY);",
      "517:   if (need_zonelists_rebuild)",
      "518:    build_all_zonelists(NULL, zone);",
      "519:   else",
      "520:    zone_pcp_update(zone);",
      "521:  }",
      "527:  if (onlined_pages)",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "6dcd73d7011ba9046f9b98e7f7c9d958f5810e6b",
      "candidate_info": {
        "commit_hash": "6dcd73d7011ba9046f9b98e7f7c9d958f5810e6b",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/6dcd73d7011ba9046f9b98e7f7c9d958f5810e6b",
        "files": [
          "mm/memory_hotplug.c",
          "mm/page_alloc.c"
        ],
        "message": "memory-hotplug: allocate zone's pcp before onlining pages\n\nWe use __free_page() to put a page to buddy system when onlining pages.\n__free_page() will store NR_FREE_PAGES in zone's pcp.vm_stat_diff, so we\nshould allocate zone's pcp before onlining pages, otherwise we will lose\nsome free pages.\n\n[mhocko@suse.cz: make zone_pcp_reset independent of MEMORY_HOTREMOVE]\nSigned-off-by: Wen Congyang <wency@cn.fujitsu.com>\nCc: David Rientjes <rientjes@google.com>\nCc: Jiang Liu <liuj97@gmail.com>\nCc: Len Brown <len.brown@intel.com>\nCc: Benjamin Herrenschmidt <benh@kernel.crashing.org>\nCc: Paul Mackerras <paulus@samba.org>\nCc: Christoph Lameter <cl@linux.com>\nCc: Minchan Kim <minchan.kim@gmail.com>\nCc: KOSAKI Motohiro <kosaki.motohiro@jp.fujitsu.com>\nCc: Yasuaki Ishimatsu <isimatu.yasuaki@jp.fujitsu.com>\nCc: Dave Hansen <dave@linux.vnet.ibm.com>\nCc: Mel Gorman <mel@csn.ul.ie>\nSigned-off-by: Michal Hocko <mhocko@suse.cz>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
        "before_after_code_files": [
          "mm/memory_hotplug.c||mm/memory_hotplug.c",
          "mm/page_alloc.c||mm/page_alloc.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "mm/memory_hotplug.c||mm/memory_hotplug.c"
          ],
          "candidate": [
            "mm/memory_hotplug.c||mm/memory_hotplug.c"
          ]
        }
      },
      "candidate_diff": {
        "mm/memory_hotplug.c||mm/memory_hotplug.c": [
          "File: mm/memory_hotplug.c -> mm/memory_hotplug.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "500:  mutex_lock(&zonelists_mutex);",
          "502:   need_zonelists_rebuild = 1;",
          "504:  ret = walk_system_ram_range(pfn, nr_pages, &onlined_pages,",
          "505:   online_pages_range);",
          "506:  if (ret) {",
          "507:   mutex_unlock(&zonelists_mutex);",
          "508:   printk(KERN_DEBUG \"online_pages [mem %#010llx-%#010llx] failed\\n\",",
          "509:          (unsigned long long) pfn << PAGE_SHIFT,",
          "",
          "[Removed Lines]",
          "501:  if (!populated_zone(zone))",
          "",
          "[Added Lines]",
          "501:  if (!populated_zone(zone)) {",
          "503:   build_all_zonelists(NULL, zone);",
          "504:  }",
          "509:   if (need_zonelists_rebuild)",
          "510:    zone_pcp_reset(zone);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "519:  if (onlined_pages) {",
          "520:   node_set_state(zone_to_nid(zone), N_HIGH_MEMORY);",
          "521:   if (need_zonelists_rebuild)",
          "523:   else",
          "524:    zone_pcp_update(zone);",
          "525:  }",
          "",
          "[Removed Lines]",
          "522:    build_all_zonelists(NULL, zone);",
          "",
          "[Added Lines]",
          "526:    build_all_zonelists(NULL, NULL);",
          "",
          "---------------"
        ],
        "mm/page_alloc.c||mm/page_alloc.c": [
          "File: mm/page_alloc.c -> mm/page_alloc.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "5983: }",
          "5984: #endif",
          "5987: void zone_pcp_reset(struct zone *zone)",
          "5988: {",
          "5989:  unsigned long flags;",
          "",
          "[Removed Lines]",
          "5986: #ifdef CONFIG_MEMORY_HOTREMOVE",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "6003:  local_irq_restore(flags);",
          "6004: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "6005: #ifdef CONFIG_MEMORY_HOTREMOVE",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "9adb62a5df9c0fbef7b4665919329f73a34651ed",
      "candidate_info": {
        "commit_hash": "9adb62a5df9c0fbef7b4665919329f73a34651ed",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/9adb62a5df9c0fbef7b4665919329f73a34651ed",
        "files": [
          "include/linux/mmzone.h",
          "init/main.c",
          "kernel/cpu.c",
          "mm/memory_hotplug.c",
          "mm/page_alloc.c"
        ],
        "message": "mm/hotplug: correctly setup fallback zonelists when creating new pgdat\n\nWhen hotadd_new_pgdat() is called to create new pgdat for a new node, a\nfallback zonelist should be created for the new node.  There's code to try\nto achieve that in hotadd_new_pgdat() as below:\n\n\t/*\n\t * The node we allocated has no zone fallback lists. For avoiding\n\t * to access not-initialized zonelist, build here.\n\t */\n\tmutex_lock(&zonelists_mutex);\n\tbuild_all_zonelists(pgdat, NULL);\n\tmutex_unlock(&zonelists_mutex);\n\nBut it doesn't work as expected.  When hotadd_new_pgdat() is called, the\nnew node is still in offline state because node_set_online(nid) hasn't\nbeen called yet.  And build_all_zonelists() only builds zonelists for\nonline nodes as:\n\n        for_each_online_node(nid) {\n                pg_data_t *pgdat = NODE_DATA(nid);\n\n                build_zonelists(pgdat);\n                build_zonelist_cache(pgdat);\n        }\n\nThough we hope to create zonelist for the new pgdat, but it doesn't.  So\nadd a new parameter \"pgdat\" the build_all_zonelists() to build pgdat for\nthe new pgdat too.\n\nSigned-off-by: Jiang Liu <liuj97@gmail.com>\nSigned-off-by: Xishi Qiu <qiuxishi@huawei.com>\nCc: Mel Gorman <mgorman@suse.de>\nCc: Michal Hocko <mhocko@suse.cz>\nCc: Minchan Kim <minchan@kernel.org>\nCc: Rusty Russell <rusty@rustcorp.com.au>\nCc: Yinghai Lu <yinghai@kernel.org>\nCc: Tony Luck <tony.luck@intel.com>\nCc: KAMEZAWA Hiroyuki <kamezawa.hiroyu@jp.fujitsu.com>\nCc: KOSAKI Motohiro <kosaki.motohiro@jp.fujitsu.com>\nCc: David Rientjes <rientjes@google.com>\nCc: Keping Chen <chenkeping@huawei.com>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
        "before_after_code_files": [
          "include/linux/mmzone.h||include/linux/mmzone.h",
          "init/main.c||init/main.c",
          "kernel/cpu.c||kernel/cpu.c",
          "mm/memory_hotplug.c||mm/memory_hotplug.c",
          "mm/page_alloc.c||mm/page_alloc.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "mm/memory_hotplug.c||mm/memory_hotplug.c"
          ],
          "candidate": [
            "mm/memory_hotplug.c||mm/memory_hotplug.c"
          ]
        }
      },
      "candidate_diff": {
        "include/linux/mmzone.h||include/linux/mmzone.h": [
          "File: include/linux/mmzone.h -> include/linux/mmzone.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "721: #include <linux/memory_hotplug.h>",
          "723: extern struct mutex zonelists_mutex;",
          "725: void wakeup_kswapd(struct zone *zone, int order, enum zone_type classzone_idx);",
          "726: bool zone_watermark_ok(struct zone *z, int order, unsigned long mark,",
          "727:   int classzone_idx, int alloc_flags);",
          "",
          "[Removed Lines]",
          "724: void build_all_zonelists(void *data);",
          "",
          "[Added Lines]",
          "724: void build_all_zonelists(pg_data_t *pgdat, struct zone *zone);",
          "",
          "---------------"
        ],
        "init/main.c||init/main.c": [
          "File: init/main.c -> init/main.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "506:  setup_per_cpu_areas();",
          "510:  page_alloc_init();",
          "512:  printk(KERN_NOTICE \"Kernel command line: %s\\n\", boot_command_line);",
          "",
          "[Removed Lines]",
          "509:  build_all_zonelists(NULL);",
          "",
          "[Added Lines]",
          "509:  build_all_zonelists(NULL, NULL);",
          "",
          "---------------"
        ],
        "kernel/cpu.c||kernel/cpu.c": [
          "File: kernel/cpu.c -> kernel/cpu.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "417:  if (pgdat->node_zonelists->_zonerefs->zone == NULL) {",
          "418:   mutex_lock(&zonelists_mutex);",
          "420:   mutex_unlock(&zonelists_mutex);",
          "421:  }",
          "422: #endif",
          "",
          "[Removed Lines]",
          "419:   build_all_zonelists(NULL);",
          "",
          "[Added Lines]",
          "419:   build_all_zonelists(NULL, NULL);",
          "",
          "---------------"
        ],
        "mm/memory_hotplug.c||mm/memory_hotplug.c": [
          "File: mm/memory_hotplug.c -> mm/memory_hotplug.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "513:  zone->present_pages += onlined_pages;",
          "514:  zone->zone_pgdat->node_present_pages += onlined_pages;",
          "515:  if (need_zonelists_rebuild)",
          "517:  else",
          "518:   zone_pcp_update(zone);",
          "",
          "[Removed Lines]",
          "516:   build_all_zonelists(zone);",
          "",
          "[Added Lines]",
          "516:   build_all_zonelists(NULL, zone);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "564:  mutex_lock(&zonelists_mutex);",
          "566:  mutex_unlock(&zonelists_mutex);",
          "568:  return pgdat;",
          "",
          "[Removed Lines]",
          "565:  build_all_zonelists(NULL);",
          "",
          "[Added Lines]",
          "565:  build_all_zonelists(pgdat, NULL);",
          "",
          "---------------"
        ],
        "mm/page_alloc.c||mm/page_alloc.c": [
          "File: mm/page_alloc.c -> mm/page_alloc.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "3032:    user_zonelist_order = oldval;",
          "3033:   } else if (oldval != user_zonelist_order) {",
          "3034:    mutex_lock(&zonelists_mutex);",
          "3036:    mutex_unlock(&zonelists_mutex);",
          "3037:   }",
          "3038:  }",
          "",
          "[Removed Lines]",
          "3035:    build_all_zonelists(NULL);",
          "",
          "[Added Lines]",
          "3035:    build_all_zonelists(NULL, NULL);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "3415: {",
          "3416:  int nid;",
          "3417:  int cpu;",
          "3419: #ifdef CONFIG_NUMA",
          "3420:  memset(node_load, 0, sizeof(node_load));",
          "3421: #endif",
          "3422:  for_each_online_node(nid) {",
          "3423:   pg_data_t *pgdat = NODE_DATA(nid);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3418:  pg_data_t *self = data;",
          "3424:  if (self && !node_online(self->node_id)) {",
          "3425:   build_zonelists(self);",
          "3426:   build_zonelist_cache(self);",
          "3427:  }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "3467: {",
          "3468:  set_zonelist_order();",
          "",
          "[Removed Lines]",
          "3466: void __ref build_all_zonelists(void *data)",
          "",
          "[Added Lines]",
          "3473: void __ref build_all_zonelists(pg_data_t *pgdat, struct zone *zone)",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "3477: #ifdef CONFIG_MEMORY_HOTPLUG",
          "3480: #endif",
          "3483:  }",
          "3484:  vm_total_pages = nr_free_pagecache_pages();",
          "",
          "[Removed Lines]",
          "3478:   if (data)",
          "3479:    setup_zone_pageset((struct zone *)data);",
          "3481:   stop_machine(__build_all_zonelists, NULL, NULL);",
          "",
          "[Added Lines]",
          "3485:   if (zone)",
          "3486:    setup_zone_pageset(zone);",
          "3488:   stop_machine(__build_all_zonelists, pgdat, NULL);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "d9713679dbd2a6ecb840cd5b65a3ec555c1ec3d4",
      "candidate_info": {
        "commit_hash": "d9713679dbd2a6ecb840cd5b65a3ec555c1ec3d4",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/d9713679dbd2a6ecb840cd5b65a3ec555c1ec3d4",
        "files": [
          "Documentation/memory-hotplug.txt",
          "include/linux/memory.h",
          "mm/memory_hotplug.c"
        ],
        "message": "memory_hotplug: fix possible incorrect node_states[N_NORMAL_MEMORY]\n\nCurrently memory_hotplug only manages the node_states[N_HIGH_MEMORY], it\nforgets to manage node_states[N_NORMAL_MEMORY].  This may cause\nnode_states[N_NORMAL_MEMORY] to become incorrect.\n\nExample, if a node is empty before online, and we online a memory which is\nin ZONE_NORMAL.  And after online, node_states[N_HIGH_MEMORY] is correct,\nbut node_states[N_NORMAL_MEMORY] is incorrect, the online code doesn't set\nthe new online node to node_states[N_NORMAL_MEMORY].\n\nThe same thing will happen when offlining (the offline code doesn't clear\nthe node from node_states[N_NORMAL_MEMORY] when needed).  Some memory\nmanagment code depends node_states[N_NORMAL_MEMORY], so we have to fix up\nthe node_states[N_NORMAL_MEMORY].\n\nWe add node_states_check_changes_online() and\nnode_states_check_changes_offline() to detect whether\nnode_states[N_HIGH_MEMORY] and node_states[N_NORMAL_MEMORY] are changed\nwhile hotpluging.\n\nAlso add @status_change_nid_normal to struct memory_notify, thus the\nmemory hotplug callbacks know whether the node_states[N_NORMAL_MEMORY] are\nchanged.  (We can add a @flags and reuse @status_change_nid instead of\nintroducing @status_change_nid_normal, but it will add much more\ncomplexity in memory hotplug callback in every subsystem.  So introducing\n@status_change_nid_normal is better and it doesn't change the sematics of\n@status_change_nid)\n\nSigned-off-by: Lai Jiangshan <laijs@cn.fujitsu.com>\nCc: David Rientjes <rientjes@google.com>\nCc: Minchan Kim <minchan.kim@gmail.com>\nCc: KOSAKI Motohiro <kosaki.motohiro@jp.fujitsu.com>\nCc: Yasuaki Ishimatsu <isimatu.yasuaki@jp.fujitsu.com>\nCc: Rob Landley <rob@landley.net>\nCc: Jiang Liu <jiang.liu@huawei.com>\nCc: Kay Sievers <kay.sievers@vrfy.org>\nCc: Greg Kroah-Hartman <gregkh@suse.de>\nCc: Mel Gorman <mgorman@suse.de>\nCc: Wen Congyang <wency@cn.fujitsu.com>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
        "before_after_code_files": [
          "include/linux/memory.h||include/linux/memory.h",
          "mm/memory_hotplug.c||mm/memory_hotplug.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "mm/memory_hotplug.c||mm/memory_hotplug.c"
          ],
          "candidate": [
            "mm/memory_hotplug.c||mm/memory_hotplug.c"
          ]
        }
      },
      "candidate_diff": {
        "include/linux/memory.h||include/linux/memory.h": [
          "File: include/linux/memory.h -> include/linux/memory.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "53: struct memory_notify {",
          "54:  unsigned long start_pfn;",
          "55:  unsigned long nr_pages;",
          "56:  int status_change_nid;",
          "57: };",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "56:  int status_change_nid_normal;",
          "",
          "---------------"
        ],
        "mm/memory_hotplug.c||mm/memory_hotplug.c": [
          "File: mm/memory_hotplug.c -> mm/memory_hotplug.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "460:  return 0;",
          "461: }",
          "464: int __ref online_pages(unsigned long pfn, unsigned long nr_pages)",
          "465: {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "464: static void node_states_check_changes_online(unsigned long nr_pages,",
          "465:  struct zone *zone, struct memory_notify *arg)",
          "466: {",
          "467:  int nid = zone_to_nid(zone);",
          "468:  enum zone_type zone_last = ZONE_NORMAL;",
          "477:  if (N_HIGH_MEMORY == N_NORMAL_MEMORY)",
          "478:   zone_last = ZONE_MOVABLE;",
          "486:  if (zone_idx(zone) <= zone_last && !node_state(nid, N_NORMAL_MEMORY))",
          "487:   arg->status_change_nid_normal = nid;",
          "488:  else",
          "489:   arg->status_change_nid_normal = -1;",
          "496:  if (!node_state(nid, N_HIGH_MEMORY))",
          "497:   arg->status_change_nid = nid;",
          "498:  else",
          "499:   arg->status_change_nid = -1;",
          "500: }",
          "502: static void node_states_set_node(int node, struct memory_notify *arg)",
          "503: {",
          "504:  if (arg->status_change_nid_normal >= 0)",
          "505:   node_set_state(node, N_NORMAL_MEMORY);",
          "507:  node_set_state(node, N_HIGH_MEMORY);",
          "508: }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "471:  struct memory_notify arg;",
          "473:  lock_memory_hotplug();",
          "474:  arg.start_pfn = pfn;",
          "475:  arg.nr_pages = nr_pages;",
          "478:  nid = page_to_nid(pfn_to_page(pfn));",
          "482:  ret = memory_notify(MEM_GOING_ONLINE, &arg);",
          "483:  ret = notifier_to_errno(ret);",
          "",
          "[Removed Lines]",
          "476:  arg.status_change_nid = -1;",
          "479:  if (node_present_pages(nid) == 0)",
          "480:   arg.status_change_nid = nid;",
          "",
          "[Added Lines]",
          "526:  zone = page_zone(pfn_to_page(pfn));",
          "530:  node_states_check_changes_online(nr_pages, zone, &arg);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "486:   unlock_memory_hotplug();",
          "487:   return ret;",
          "488:  }",
          "",
          "[Removed Lines]",
          "494:  zone = page_zone(pfn_to_page(pfn));",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "521:  zone->present_pages += onlined_pages;",
          "522:  zone->zone_pgdat->node_present_pages += onlined_pages;",
          "523:  if (onlined_pages) {",
          "525:   if (need_zonelists_rebuild)",
          "526:    build_all_zonelists(NULL, NULL);",
          "527:   else",
          "",
          "[Removed Lines]",
          "524:   node_set_state(zone_to_nid(zone), N_HIGH_MEMORY);",
          "",
          "[Added Lines]",
          "570:   node_states_set_node(zone_to_nid(zone), &arg);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "871:  return offlined;",
          "872: }",
          "874: static int __ref __offline_pages(unsigned long start_pfn,",
          "875:     unsigned long end_pfn, unsigned long timeout)",
          "876: {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "921: static void node_states_check_changes_offline(unsigned long nr_pages,",
          "922:   struct zone *zone, struct memory_notify *arg)",
          "923: {",
          "924:  struct pglist_data *pgdat = zone->zone_pgdat;",
          "925:  unsigned long present_pages = 0;",
          "926:  enum zone_type zt, zone_last = ZONE_NORMAL;",
          "935:  if (N_HIGH_MEMORY == N_NORMAL_MEMORY)",
          "936:   zone_last = ZONE_MOVABLE;",
          "945:  for (zt = 0; zt <= zone_last; zt++)",
          "946:   present_pages += pgdat->node_zones[zt].present_pages;",
          "947:  if (zone_idx(zone) <= zone_last && nr_pages >= present_pages)",
          "948:   arg->status_change_nid_normal = zone_to_nid(zone);",
          "949:  else",
          "950:   arg->status_change_nid_normal = -1;",
          "955:  zone_last = ZONE_MOVABLE;",
          "963:  for (; zt <= zone_last; zt++)",
          "964:   present_pages += pgdat->node_zones[zt].present_pages;",
          "965:  if (nr_pages >= present_pages)",
          "966:   arg->status_change_nid = zone_to_nid(zone);",
          "967:  else",
          "968:   arg->status_change_nid = -1;",
          "969: }",
          "971: static void node_states_clear_node(int node, struct memory_notify *arg)",
          "972: {",
          "973:  if (arg->status_change_nid_normal >= 0)",
          "974:   node_clear_state(node, N_NORMAL_MEMORY);",
          "976:  if ((N_HIGH_MEMORY != N_NORMAL_MEMORY) &&",
          "977:      (arg->status_change_nid >= 0))",
          "978:   node_clear_state(node, N_HIGH_MEMORY);",
          "979: }",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "906:  arg.start_pfn = start_pfn;",
          "907:  arg.nr_pages = nr_pages;",
          "912:  ret = memory_notify(MEM_GOING_OFFLINE, &arg);",
          "913:  ret = notifier_to_errno(ret);",
          "",
          "[Removed Lines]",
          "908:  arg.status_change_nid = -1;",
          "909:  if (nr_pages >= node_present_pages(node))",
          "910:   arg.status_change_nid = node;",
          "",
          "[Added Lines]",
          "1015:  node_states_check_changes_offline(nr_pages, zone, &arg);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "980:  } else",
          "981:   zone_pcp_update(zone);",
          "985:   kswapd_stop(node);",
          "988:  vm_total_pages = nr_free_pagecache_pages();",
          "989:  writeback_set_ratelimit();",
          "",
          "[Removed Lines]",
          "983:  if (!node_present_pages(node)) {",
          "984:   node_clear_state(node, N_HIGH_MEMORY);",
          "986:  }",
          "",
          "[Added Lines]",
          "1088:  node_states_clear_node(node, &arg);",
          "1089:  if (arg.status_change_nid >= 0)",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2015-8324",
  "cve_desc": "The ext4 implementation in the Linux kernel before 2.6.34 does not properly track the initialization of certain data structures, which allows physically proximate attackers to cause a denial of service (NULL pointer dereference and panic) via a crafted USB device, related to the ext4_fill_super function.",
  "repo": "torvalds/linux",
  "patch_hash": "744692dc059845b2a3022119871846e74d4f6e11",
  "patch_info": {
    "commit_hash": "744692dc059845b2a3022119871846e74d4f6e11",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/744692dc059845b2a3022119871846e74d4f6e11",
    "files": [
      "fs/ext4/ext4.h",
      "fs/ext4/ext4_jbd2.h",
      "fs/ext4/extents.c",
      "fs/ext4/inode.c",
      "fs/ext4/super.c"
    ],
    "message": "ext4: use ext4_get_block_write in buffer write\n\nAllocate uninitialized extent before ext4 buffer write and\nconvert the extent to initialized after io completes.\nThe purpose is to make sure an extent can only be marked\ninitialized after it has been written with new data so\nwe can safely drop the i_mutex lock in ext4 DIO read without\nexposing stale data. This helps to improve multi-thread DIO\nread performance on high-speed disks.\n\nSkip the nobh and data=journal mount cases to make things simple for now.\n\nSigned-off-by: Jiaying Zhang <jiayingz@google.com>\nSigned-off-by: \"Theodore Ts'o\" <tytso@mit.edu>",
    "before_after_code_files": [
      "fs/ext4/ext4.h||fs/ext4/ext4.h",
      "fs/ext4/ext4_jbd2.h||fs/ext4/ext4_jbd2.h",
      "fs/ext4/extents.c||fs/ext4/extents.c",
      "fs/ext4/inode.c||fs/ext4/inode.c",
      "fs/ext4/super.c||fs/ext4/super.c"
    ]
  },
  "patch_diff": {
    "fs/ext4/ext4.h||fs/ext4/ext4.h": [
      "File: fs/ext4/ext4.h -> fs/ext4/ext4.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "361:       EXT4_GET_BLOCKS_CREATE_UNINIT_EXT)",
      "363: #define EXT4_GET_BLOCKS_IO_CONVERT_EXT  (EXT4_GET_BLOCKS_CONVERT|\\",
      "",
      "[Removed Lines]",
      "364:       EXT4_GET_BLOCKS_IO_CREATE_EXT)",
      "",
      "[Added Lines]",
      "364:       EXT4_GET_BLOCKS_CREATE_UNINIT_EXT)",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "704:  struct list_head i_completed_io_list;",
      "706:  ext4_io_end_t *cur_aio_dio;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "705:  spinlock_t i_completed_io_lock;",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "1781:         __u64 len, __u64 *moved_len);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1787: enum ext4_state_bits {",
      "1789:    = BH_JBDPrivateStart,",
      "1790: };",
      "1792: BUFFER_FNS(Uninit, uninit)",
      "1793: TAS_BUFFER_FNS(Uninit, uninit)",
      "",
      "---------------"
    ],
    "fs/ext4/ext4_jbd2.h||fs/ext4/ext4_jbd2.h": [
      "File: fs/ext4/ext4_jbd2.h -> fs/ext4/ext4_jbd2.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "304:  return 0;",
      "305: }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "316: static inline int ext4_should_dioread_nolock(struct inode *inode)",
      "317: {",
      "318:  if (!test_opt(inode->i_sb, DIOREAD_NOLOCK))",
      "319:   return 0;",
      "320:  if (test_opt(inode->i_sb, NOBH))",
      "321:   return 0;",
      "322:  if (!S_ISREG(inode->i_mode))",
      "323:   return 0;",
      "324:  if (!(EXT4_I(inode)->i_flags & EXT4_EXTENTS_FL))",
      "325:   return 0;",
      "326:  if (ext4_should_journal_data(inode))",
      "327:   return 0;",
      "328:  return 1;",
      "329: }",
      "",
      "---------------"
    ],
    "fs/ext4/extents.c||fs/ext4/extents.c": [
      "File: fs/ext4/extents.c -> fs/ext4/extents.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "1619:  BUG_ON(path[depth].p_hdr == NULL);",
      "1623:   && ext4_can_extents_be_merged(inode, ex, newext)) {",
      "1624:   ext_debug(\"append [%d]%d block to %d:[%d]%d (from %llu)\\n\",",
      "1625:     ext4_ext_is_uninitialized(newext),",
      "",
      "[Removed Lines]",
      "1622:  if (ex && (flag != EXT4_GET_BLOCKS_PRE_IO)",
      "",
      "[Added Lines]",
      "1622:  if (ex && !(flag & EXT4_GET_BLOCKS_PRE_IO)",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "1741: merge:",
      "1744:   ext4_ext_try_to_merge(inode, path, nearex);",
      "",
      "[Removed Lines]",
      "1743:  if (flag != EXT4_GET_BLOCKS_PRE_IO)",
      "",
      "[Added Lines]",
      "1743:  if (!(flag & EXT4_GET_BLOCKS_PRE_IO))",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "3065:  ext4_ext_show_leaf(inode, path);",
      "3069:   ret = ext4_split_unwritten_extents(handle,",
      "3070:       inode, path, iblock,",
      "3071:       max_blocks, flags);",
      "",
      "[Removed Lines]",
      "3068:  if (flags == EXT4_GET_BLOCKS_PRE_IO) {",
      "",
      "[Added Lines]",
      "3068:  if ((flags & EXT4_GET_BLOCKS_PRE_IO)) {",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "3078:    io->flag = EXT4_IO_UNWRITTEN;",
      "3079:   else",
      "3080:    ext4_set_inode_state(inode, EXT4_STATE_DIO_UNWRITTEN);",
      "3081:   goto out;",
      "3082:  }",
      "3085:   ret = ext4_convert_unwritten_extents_endio(handle, inode,",
      "3086:        path);",
      "3087:   if (ret >= 0)",
      "",
      "[Removed Lines]",
      "3084:  if (flags == EXT4_GET_BLOCKS_CONVERT) {",
      "",
      "[Added Lines]",
      "3081:   if (ext4_should_dioread_nolock(inode))",
      "3082:    set_buffer_uninit(bh_result);",
      "3086:  if ((flags & EXT4_GET_BLOCKS_CONVERT)) {",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "3351:  if (flags & EXT4_GET_BLOCKS_UNINIT_EXT){",
      "3352:   ext4_ext_mark_uninitialized(&newex);",
      "3363:    if (io)",
      "3364:     io->flag = EXT4_IO_UNWRITTEN;",
      "3365:    else",
      "3366:     ext4_set_inode_state(inode,",
      "3367:            EXT4_STATE_DIO_UNWRITTEN);",
      "3368:   }",
      "3369:  }",
      "3371:  if (unlikely(EXT4_I(inode)->i_flags & EXT4_EOFBLOCKS_FL)) {",
      "",
      "[Removed Lines]",
      "3362:   if (flags == EXT4_GET_BLOCKS_PRE_IO) {",
      "",
      "[Added Lines]",
      "3362:   if ((flags & EXT4_GET_BLOCKS_PRE_IO)) {",
      "3369:   if (ext4_should_dioread_nolock(inode))",
      "3370:    set_buffer_uninit(bh_result);",
      "",
      "---------------"
    ],
    "fs/ext4/inode.c||fs/ext4/inode.c": [
      "File: fs/ext4/inode.c -> fs/ext4/inode.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "38: #include <linux/uio.h>",
      "39: #include <linux/bio.h>",
      "40: #include <linux/workqueue.h>",
      "42: #include \"ext4_jbd2.h\"",
      "43: #include \"xattr.h\"",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "41: #include <linux/kernel.h>",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "1534:  ext4_truncate(inode);",
      "1535: }",
      "1537: static int ext4_write_begin(struct file *file, struct address_space *mapping,",
      "1538:        loff_t pos, unsigned len, unsigned flags,",
      "1539:        struct page **pagep, void **fsdata)",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1538: static int ext4_get_block_write(struct inode *inode, sector_t iblock,",
      "1539:      struct buffer_head *bh_result, int create);",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "1575:  }",
      "1581:  if (!ret && ext4_should_journal_data(inode)) {",
      "1582:   ret = walk_page_buffers(handle, page_buffers(page),",
      "",
      "[Removed Lines]",
      "1578:  ret = block_write_begin(file, mapping, pos, len, flags, pagep, fsdata,",
      "1579:     ext4_get_block);",
      "",
      "[Added Lines]",
      "1581:  if (ext4_should_dioread_nolock(inode))",
      "1582:   ret = block_write_begin(file, mapping, pos, len, flags, pagep,",
      "1583:     fsdata, ext4_get_block_write);",
      "1584:  else",
      "1585:   ret = block_write_begin(file, mapping, pos, len, flags, pagep,",
      "1586:     fsdata, ext4_get_block);",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "2092:     } else if (buffer_mapped(bh))",
      "2093:      BUG_ON(bh->b_blocknr != pblock);",
      "2095:     cur_logical++;",
      "2096:     pblock++;",
      "2097:    } while ((bh = bh->b_this_page) != head);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "2102:     if (buffer_uninit(exbh))",
      "2103:      set_buffer_uninit(bh);",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "2222:  new.b_state = 0;",
      "2223:  get_blocks_flags = EXT4_GET_BLOCKS_CREATE;",
      "2224:  if (mpd->b_state & (1 << BH_Delay))",
      "2225:   get_blocks_flags |= EXT4_GET_BLOCKS_DELALLOC_RESERVE;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "2233:  if (ext4_should_dioread_nolock(mpd->inode))",
      "2234:   get_blocks_flags |= EXT4_GET_BLOCKS_IO_CREATE_EXT;",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "2636:  return ret;",
      "2637: }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "2650: static int ext4_set_bh_endio(struct buffer_head *bh, struct inode *inode);",
      "2651: static void ext4_end_io_buffer_write(struct buffer_head *bh, int uptodate);",
      "",
      "---------------",
      "--- Hunk 7 ---",
      "[Context before]",
      "2683:  int ret = 0;",
      "2684:  loff_t size;",
      "2685:  unsigned int len;",
      "2687:  struct inode *inode = page->mapping->host;",
      "2689:  trace_ext4_writepage(inode, page);",
      "",
      "[Removed Lines]",
      "2686:  struct buffer_head *page_bufs;",
      "",
      "[Added Lines]",
      "2700:  struct buffer_head *page_bufs = NULL;",
      "",
      "---------------",
      "--- Hunk 8 ---",
      "[Context before]",
      "2760:  if (test_opt(inode->i_sb, NOBH) && ext4_should_writeback_data(inode))",
      "2761:   ret = nobh_writepage(page, noalloc_get_block_write, wbc);",
      "2763:   ret = block_write_full_page(page, noalloc_get_block_write,",
      "2764:          wbc);",
      "",
      "[Removed Lines]",
      "2762:  else",
      "",
      "[Added Lines]",
      "2776:  else if (page_bufs && buffer_uninit(page_bufs)) {",
      "2777:   ext4_set_bh_endio(page_bufs, inode);",
      "2778:   ret = block_write_full_page_endio(page, noalloc_get_block_write,",
      "2779:          wbc, ext4_end_io_buffer_write);",
      "2780:  } else",
      "",
      "---------------",
      "--- Hunk 9 ---",
      "[Context before]",
      "3347:  return mpage_readpages(mapping, pages, nr_pages, ext4_get_block);",
      "3348: }",
      "3350: static void ext4_invalidatepage(struct page *page, unsigned long offset)",
      "3351: {",
      "3352:  journal_t *journal = EXT4_JOURNAL(page->mapping->host);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "3368: static void ext4_free_io_end(ext4_io_end_t *io)",
      "3369: {",
      "3370:  BUG_ON(!io);",
      "3371:  if (io->page)",
      "3372:   put_page(io->page);",
      "3373:  iput(io->inode);",
      "3374:  kfree(io);",
      "3375: }",
      "3377: static void ext4_invalidatepage_free_endio(struct page *page, unsigned long offset)",
      "3378: {",
      "3379:  struct buffer_head *head, *bh;",
      "3380:  unsigned int curr_off = 0;",
      "3382:  if (!page_has_buffers(page))",
      "3383:   return;",
      "3384:  head = bh = page_buffers(page);",
      "3385:  do {",
      "3386:   if (offset <= curr_off && test_clear_buffer_uninit(bh)",
      "3387:      && bh->b_private) {",
      "3388:    ext4_free_io_end(bh->b_private);",
      "3389:    bh->b_private = NULL;",
      "3390:    bh->b_end_io = NULL;",
      "3391:   }",
      "3392:   curr_off = curr_off + bh->b_size;",
      "3393:   bh = bh->b_this_page;",
      "3394:  } while (bh != head);",
      "3395: }",
      "3404:  if (ext4_should_dioread_nolock(page->mapping->host))",
      "3405:   ext4_invalidatepage_free_endio(page, offset);",
      "",
      "---------------",
      "--- Hunk 10 ---",
      "[Context before]",
      "3471: static int ext4_get_block_write(struct inode *inode, sector_t iblock,",
      "3472:      struct buffer_head *bh_result, int create)",
      "3473: {",
      "3475:  int ret = 0;",
      "3476:  unsigned max_blocks = bh_result->b_size >> inode->i_blkbits;",
      "3477:  int dio_credits;",
      "3479:  ext4_debug(\"ext4_get_block_write: inode %lu, create flag %d\\n\",",
      "3480:      inode->i_ino, create);",
      "",
      "[Removed Lines]",
      "3474:  handle_t *handle = NULL;",
      "",
      "[Added Lines]",
      "3526:  handle_t *handle = ext4_journal_current_handle();",
      "3530:  int started = 0;",
      "",
      "---------------",
      "--- Hunk 11 ---",
      "[Context before]",
      "3486:  create = EXT4_GET_BLOCKS_IO_CREATE_EXT;",
      "3495:  }",
      "3496:  ret = ext4_get_blocks(handle, inode, iblock, max_blocks, bh_result,",
      "3497:          create);",
      "3498:  if (ret > 0) {",
      "3499:   bh_result->b_size = (ret << inode->i_blkbits);",
      "3500:   ret = 0;",
      "3501:  }",
      "3503: out:",
      "3504:  return ret;",
      "3505: }",
      "3514: static void dump_completed_IO(struct inode * inode)",
      "3515: {",
      "3516: #ifdef EXT4_DEBUG",
      "3517:  struct list_head *cur, *before, *after;",
      "3518:  ext4_io_end_t *io, *io0, *io1;",
      "3520:  if (list_empty(&EXT4_I(inode)->i_completed_io_list)){",
      "3521:   ext4_debug(\"inode %lu completed_io list is empty\\n\", inode->i_ino);",
      "",
      "[Removed Lines]",
      "3488:  if (max_blocks > DIO_MAX_BLOCKS)",
      "3489:   max_blocks = DIO_MAX_BLOCKS;",
      "3490:  dio_credits = ext4_chunk_trans_blocks(inode, max_blocks);",
      "3491:  handle = ext4_journal_start(inode, dio_credits);",
      "3492:  if (IS_ERR(handle)) {",
      "3493:   ret = PTR_ERR(handle);",
      "3494:   goto out;",
      "3502:  ext4_journal_stop(handle);",
      "3507: static void ext4_free_io_end(ext4_io_end_t *io)",
      "3508: {",
      "3509:  BUG_ON(!io);",
      "3510:  iput(io->inode);",
      "3511:  kfree(io);",
      "3512: }",
      "",
      "[Added Lines]",
      "3541:  if (!handle) {",
      "3542:   if (max_blocks > DIO_MAX_BLOCKS)",
      "3543:    max_blocks = DIO_MAX_BLOCKS;",
      "3544:   dio_credits = ext4_chunk_trans_blocks(inode, max_blocks);",
      "3545:   handle = ext4_journal_start(inode, dio_credits);",
      "3546:   if (IS_ERR(handle)) {",
      "3547:    ret = PTR_ERR(handle);",
      "3548:    goto out;",
      "3549:   }",
      "3550:   started = 1;",
      "3559:  if (started)",
      "3560:   ext4_journal_stop(handle);",
      "3570:  unsigned long flags;",
      "",
      "---------------",
      "--- Hunk 12 ---",
      "[Context before]",
      "3523:  }",
      "3525:  ext4_debug(\"Dump inode %lu completed_io list \\n\", inode->i_ino);",
      "3526:  list_for_each_entry(io, &EXT4_I(inode)->i_completed_io_list, list){",
      "3527:   cur = &io->list;",
      "3528:   before = cur->prev;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "3578:  spin_lock_irqsave(&EXT4_I(inode)->i_completed_io_lock, flags);",
      "",
      "---------------",
      "--- Hunk 13 ---",
      "[Context before]",
      "3533:   ext4_debug(\"io 0x%p from inode %lu,prev 0x%p,next 0x%p\\n\",",
      "3534:        io, inode->i_ino, io0, io1);",
      "3535:  }",
      "3536: #endif",
      "3537: }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "3589:  spin_unlock_irqrestore(&EXT4_I(inode)->i_completed_io_lock, flags);",
      "",
      "---------------",
      "--- Hunk 14 ---",
      "[Context before]",
      "3556:  if (io->flag != EXT4_IO_UNWRITTEN)",
      "3557:   return ret;",
      "3562:  if (ret < 0) {",
      "3563:   printk(KERN_EMERG \"%s: failed to convert unwritten\"",
      "3564:    \"extents to written extents, error is %d\"",
      "",
      "[Removed Lines]",
      "3559:  if (offset + size <= i_size_read(inode))",
      "3560:   ret = ext4_convert_unwritten_extents(inode, offset, size);",
      "",
      "[Added Lines]",
      "3613:  ret = ext4_convert_unwritten_extents(inode, offset, size);",
      "",
      "---------------",
      "--- Hunk 15 ---",
      "[Context before]",
      "3578: static void ext4_end_io_work(struct work_struct *work)",
      "3579: {",
      "3584:  mutex_lock(&inode->i_mutex);",
      "3585:  ret = ext4_end_io_nolock(io);",
      "3590:  }",
      "3591:  mutex_unlock(&inode->i_mutex);",
      "3592: }",
      "",
      "[Removed Lines]",
      "3580:  ext4_io_end_t *io  = container_of(work, ext4_io_end_t, work);",
      "3581:  struct inode *inode = io->inode;",
      "3582:  int ret = 0;",
      "3586:  if (ret >= 0) {",
      "3587:   if (!list_empty(&io->list))",
      "3588:    list_del_init(&io->list);",
      "3589:   ext4_free_io_end(io);",
      "",
      "[Added Lines]",
      "3632:  ext4_io_end_t  *io = container_of(work, ext4_io_end_t, work);",
      "3633:  struct inode  *inode = io->inode;",
      "3634:  struct ext4_inode_info *ei = EXT4_I(inode);",
      "3635:  unsigned long  flags;",
      "3636:  int   ret;",
      "3640:  if (ret < 0) {",
      "3641:   mutex_unlock(&inode->i_mutex);",
      "3642:   return;",
      "3645:  spin_lock_irqsave(&ei->i_completed_io_lock, flags);",
      "3646:  if (!list_empty(&io->list))",
      "3647:   list_del_init(&io->list);",
      "3648:  spin_unlock_irqrestore(&ei->i_completed_io_lock, flags);",
      "3650:  ext4_free_io_end(io);",
      "",
      "---------------",
      "--- Hunk 16 ---",
      "[Context before]",
      "3607: int flush_completed_IO(struct inode *inode)",
      "3608: {",
      "3609:  ext4_io_end_t *io;",
      "3610:  int ret = 0;",
      "3611:  int ret2 = 0;",
      "3614:   return ret;",
      "3616:  dump_completed_IO(inode);",
      "3619:     ext4_io_end_t, list);",
      "",
      "[Removed Lines]",
      "3613:  if (list_empty(&EXT4_I(inode)->i_completed_io_list))",
      "3617:  while (!list_empty(&EXT4_I(inode)->i_completed_io_list)){",
      "3618:   io = list_entry(EXT4_I(inode)->i_completed_io_list.next,",
      "",
      "[Added Lines]",
      "3669:  struct ext4_inode_info *ei = EXT4_I(inode);",
      "3670:  unsigned long flags;",
      "3674:  if (list_empty(&ei->i_completed_io_list))",
      "3678:  spin_lock_irqsave(&ei->i_completed_io_lock, flags);",
      "3679:  while (!list_empty(&ei->i_completed_io_list)){",
      "3680:   io = list_entry(ei->i_completed_io_list.next,",
      "",
      "---------------",
      "--- Hunk 17 ---",
      "[Context before]",
      "3634:   ret = ext4_end_io_nolock(io);",
      "3635:   if (ret < 0)",
      "3636:    ret2 = ret;",
      "3637:   else",
      "3638:    list_del_init(&io->list);",
      "3639:  }",
      "3640:  return (ret2 < 0) ? ret2 : 0;",
      "3641: }",
      "3644: {",
      "3645:  ext4_io_end_t *io = NULL;",
      "3649:  if (io) {",
      "3650:   igrab(inode);",
      "",
      "[Removed Lines]",
      "3643: static ext4_io_end_t *ext4_init_io_end (struct inode *inode)",
      "3647:  io = kmalloc(sizeof(*io), GFP_NOFS);",
      "",
      "[Added Lines]",
      "3696:   spin_unlock_irqrestore(&ei->i_completed_io_lock, flags);",
      "3698:   spin_lock_irqsave(&ei->i_completed_io_lock, flags);",
      "3704:  spin_unlock_irqrestore(&ei->i_completed_io_lock, flags);",
      "3708: static ext4_io_end_t *ext4_init_io_end (struct inode *inode, gfp_t flags)",
      "3712:  io = kmalloc(sizeof(*io), flags);",
      "",
      "---------------",
      "--- Hunk 18 ---",
      "[Context before]",
      "3652:   io->flag = 0;",
      "3653:   io->offset = 0;",
      "3654:   io->size = 0;",
      "3656:   INIT_WORK(&io->work, ext4_end_io_work);",
      "3657:   INIT_LIST_HEAD(&io->list);",
      "3658:  }",
      "",
      "[Removed Lines]",
      "3655:   io->error = 0;",
      "",
      "[Added Lines]",
      "3720:   io->page = NULL;",
      "",
      "---------------",
      "--- Hunk 19 ---",
      "[Context before]",
      "3665: {",
      "3666:         ext4_io_end_t *io_end = iocb->private;",
      "3667:  struct workqueue_struct *wq;",
      "3670:  if (!io_end || !size)",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "3733:  unsigned long flags;",
      "3734:  struct ext4_inode_info *ei;",
      "",
      "---------------",
      "--- Hunk 20 ---",
      "[Context before]",
      "3685:  io_end->offset = offset;",
      "3686:  io_end->size = size;",
      "3687:  wq = EXT4_SB(io_end->inode->i_sb)->dio_unwritten_wq;",
      "3690:  queue_work(wq, &io_end->work);",
      "3695:  iocb->private = NULL;",
      "3696: }",
      "",
      "[Removed Lines]",
      "3693:  list_add_tail(&io_end->list,",
      "3694:    &EXT4_I(io_end->inode)->i_completed_io_list);",
      "",
      "[Added Lines]",
      "3754:  io_end->flag = EXT4_IO_UNWRITTEN;",
      "3761:  ei = EXT4_I(io_end->inode);",
      "3762:  spin_lock_irqsave(&ei->i_completed_io_lock, flags);",
      "3763:  list_add_tail(&io_end->list, &ei->i_completed_io_list);",
      "3764:  spin_unlock_irqrestore(&ei->i_completed_io_lock, flags);",
      "3768: static void ext4_end_io_buffer_write(struct buffer_head *bh, int uptodate)",
      "3769: {",
      "3770:  ext4_io_end_t *io_end = bh->b_private;",
      "3771:  struct workqueue_struct *wq;",
      "3772:  struct inode *inode;",
      "3773:  unsigned long flags;",
      "3775:  if (!test_clear_buffer_uninit(bh) || !io_end)",
      "3776:   goto out;",
      "3778:  if (!(io_end->inode->i_sb->s_flags & MS_ACTIVE)) {",
      "3779:   printk(\"sb umounted, discard end_io request for inode %lu\\n\",",
      "3780:    io_end->inode->i_ino);",
      "3781:   ext4_free_io_end(io_end);",
      "3782:   goto out;",
      "3783:  }",
      "3785:  io_end->flag = EXT4_IO_UNWRITTEN;",
      "3786:  inode = io_end->inode;",
      "3789:  spin_lock_irqsave(&EXT4_I(inode)->i_completed_io_lock, flags);",
      "3790:  list_add_tail(&io_end->list, &EXT4_I(inode)->i_completed_io_list);",
      "3791:  spin_unlock_irqrestore(&EXT4_I(inode)->i_completed_io_lock, flags);",
      "3793:  wq = EXT4_SB(inode->i_sb)->dio_unwritten_wq;",
      "3795:  queue_work(wq, &io_end->work);",
      "3796: out:",
      "3797:  bh->b_private = NULL;",
      "3798:  bh->b_end_io = NULL;",
      "3799:  clear_buffer_uninit(bh);",
      "3800:  end_buffer_async_write(bh, uptodate);",
      "3801: }",
      "3803: static int ext4_set_bh_endio(struct buffer_head *bh, struct inode *inode)",
      "3804: {",
      "3805:  ext4_io_end_t *io_end;",
      "3806:  struct page *page = bh->b_page;",
      "3807:  loff_t offset = (sector_t)page->index << PAGE_CACHE_SHIFT;",
      "3808:  size_t size = bh->b_size;",
      "3810: retry:",
      "3811:  io_end = ext4_init_io_end(inode, GFP_ATOMIC);",
      "3812:  if (!io_end) {",
      "3813:   if (printk_ratelimit())",
      "3814:    printk(KERN_WARNING \"%s: allocation fail\\n\", __func__);",
      "3815:   schedule();",
      "3816:   goto retry;",
      "3817:  }",
      "3818:  io_end->offset = offset;",
      "3819:  io_end->size = size;",
      "3825:  io_end->page = page;",
      "3826:  get_page(io_end->page);",
      "3828:  bh->b_private = io_end;",
      "3829:  bh->b_end_io = ext4_end_io_buffer_write;",
      "3830:  return 0;",
      "3831: }",
      "",
      "---------------",
      "--- Hunk 21 ---",
      "[Context before]",
      "3748:   iocb->private = NULL;",
      "3749:   EXT4_I(inode)->cur_aio_dio = NULL;",
      "3750:   if (!is_sync_kiocb(iocb)) {",
      "3752:    if (!iocb->private)",
      "3753:     return -ENOMEM;",
      "",
      "[Removed Lines]",
      "3751:    iocb->private = ext4_init_io_end(inode);",
      "",
      "[Added Lines]",
      "3886:    iocb->private = ext4_init_io_end(inode, GFP_NOFS);",
      "",
      "---------------"
    ],
    "fs/ext4/super.c||fs/ext4/super.c": [
      "File: fs/ext4/super.c -> fs/ext4/super.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "709:  ei->i_reserved_quota = 0;",
      "710: #endif",
      "711:  INIT_LIST_HEAD(&ei->i_completed_io_list);",
      "712:  ei->cur_aio_dio = NULL;",
      "713:  ei->i_sync_tid = 0;",
      "714:  ei->i_datasync_tid = 0;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "712:  spin_lock_init(&ei->i_completed_io_lock);",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "926:  if (test_opt(sb, NOLOAD))",
      "927:   seq_puts(seq, \",norecovery\");",
      "929:  ext4_show_quota_options(seq, sb);",
      "931:  return 0;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "930:  if (test_opt(sb, DIOREAD_NOLOCK))",
      "931:   seq_puts(seq, \",dioread_nolock\");",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "1109:  Opt_stripe, Opt_delalloc, Opt_nodelalloc,",
      "1110:  Opt_block_validity, Opt_noblock_validity,",
      "1111:  Opt_inode_readahead_blks, Opt_journal_ioprio,",
      "1112:  Opt_discard, Opt_nodiscard,",
      "1113: };",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1116:  Opt_dioread_nolock, Opt_dioread_lock,",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "1176:  {Opt_auto_da_alloc, \"auto_da_alloc=%u\"},",
      "1177:  {Opt_auto_da_alloc, \"auto_da_alloc\"},",
      "1178:  {Opt_noauto_da_alloc, \"noauto_da_alloc\"},",
      "1179:  {Opt_discard, \"discard\"},",
      "1180:  {Opt_nodiscard, \"nodiscard\"},",
      "1181:  {Opt_err, NULL},",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1184:  {Opt_dioread_nolock, \"dioread_nolock\"},",
      "1185:  {Opt_dioread_lock, \"dioread_lock\"},",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "1640:   case Opt_nodiscard:",
      "1641:    clear_opt(sbi->s_mount_opt, DISCARD);",
      "1642:    break;",
      "1643:   default:",
      "1644:    ext4_msg(sb, KERN_ERR,",
      "1645:           \"Unrecognized mount option \\\"%s\\\" \"",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1650:   case Opt_dioread_nolock:",
      "1651:    set_opt(sbi->s_mount_opt, DIOREAD_NOLOCK);",
      "1652:    break;",
      "1653:   case Opt_dioread_lock:",
      "1654:    clear_opt(sbi->s_mount_opt, DIOREAD_NOLOCK);",
      "1655:    break;",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "2795:        EXT4_HAS_INCOMPAT_FEATURE(sb, EXT4_FEATURE_INCOMPAT_RECOVER)) {",
      "2796:   ext4_msg(sb, KERN_ERR, \"required journal recovery \"",
      "2797:          \"suppressed and not mounted read-only\");",
      "2799:  } else {",
      "2800:   clear_opt(sbi->s_mount_opt, DATA_FLAGS);",
      "2801:   set_opt(sbi->s_mount_opt, WRITEBACK_DATA);",
      "",
      "[Removed Lines]",
      "2798:   goto failed_mount4;",
      "",
      "[Added Lines]",
      "2811:   goto failed_mount_wq;",
      "",
      "---------------",
      "--- Hunk 7 ---",
      "[Context before]",
      "2808:      !jbd2_journal_set_features(EXT4_SB(sb)->s_journal, 0, 0,",
      "2809:            JBD2_FEATURE_INCOMPAT_64BIT)) {",
      "2810:   ext4_msg(sb, KERN_ERR, \"Failed to set 64-bit journal feature\");",
      "2812:  }",
      "2814:  if (test_opt(sb, JOURNAL_ASYNC_COMMIT)) {",
      "",
      "[Removed Lines]",
      "2811:   goto failed_mount4;",
      "",
      "[Added Lines]",
      "2824:   goto failed_mount_wq;",
      "",
      "---------------",
      "--- Hunk 8 ---",
      "[Context before]",
      "2847:       (sbi->s_journal, 0, 0, JBD2_FEATURE_INCOMPAT_REVOKE)) {",
      "2848:    ext4_msg(sb, KERN_ERR, \"Journal does not support \"",
      "2849:           \"requested data journaling mode\");",
      "2851:   }",
      "2852:  default:",
      "2853:   break;",
      "",
      "[Removed Lines]",
      "2850:    goto failed_mount4;",
      "",
      "[Added Lines]",
      "2863:    goto failed_mount_wq;",
      "",
      "---------------",
      "--- Hunk 9 ---",
      "[Context before]",
      "2855:  set_task_ioprio(sbi->s_journal->j_task, journal_ioprio);",
      "2857: no_journal:",
      "2859:  if (test_opt(sb, NOBH)) {",
      "2860:   if (!(test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_WRITEBACK_DATA)) {",
      "2861:    ext4_msg(sb, KERN_WARNING, \"Ignoring nobh option - \"",
      "2862:     \"its supported only with writeback mode\");",
      "2863:    clear_opt(sbi->s_mount_opt, NOBH);",
      "2864:   }",
      "2865:  }",
      "2866:  EXT4_SB(sb)->dio_unwritten_wq = create_workqueue(\"ext4-dio-unwritten\");",
      "2867:  if (!EXT4_SB(sb)->dio_unwritten_wq) {",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "2877:   if (test_opt(sb, DIOREAD_NOLOCK)) {",
      "2878:    ext4_msg(sb, KERN_WARNING, \"dioread_nolock option is \"",
      "2879:     \"not supported with nobh mode\");",
      "2880:    goto failed_mount_wq;",
      "2881:   }",
      "",
      "---------------",
      "--- Hunk 10 ---",
      "[Context before]",
      "2926:     \"requested data journaling mode\");",
      "2927:   clear_opt(sbi->s_mount_opt, DELALLOC);",
      "2928:  }",
      "2930:  err = ext4_setup_system_zone(sb);",
      "2931:  if (err) {",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "2946:  if (test_opt(sb, DIOREAD_NOLOCK)) {",
      "2947:   if (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_JOURNAL_DATA) {",
      "2948:    ext4_msg(sb, KERN_WARNING, \"Ignoring dioread_nolock \"",
      "2949:     \"option - requested data journaling mode\");",
      "2950:    clear_opt(sbi->s_mount_opt, DIOREAD_NOLOCK);",
      "2951:   }",
      "2952:   if (sb->s_blocksize < PAGE_SIZE) {",
      "2953:    ext4_msg(sb, KERN_WARNING, \"Ignoring dioread_nolock \"",
      "2954:     \"option - block size is too small\");",
      "2955:    clear_opt(sbi->s_mount_opt, DIOREAD_NOLOCK);",
      "2956:   }",
      "2957:  }",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "206f7ab4f49a2021fcb8687f25395be77711ddee",
      "candidate_info": {
        "commit_hash": "206f7ab4f49a2021fcb8687f25395be77711ddee",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/206f7ab4f49a2021fcb8687f25395be77711ddee",
        "files": [
          "fs/ext4/ext4.h",
          "fs/ext4/ext4_jbd2.h",
          "fs/ext4/inode.c",
          "fs/ext4/super.c"
        ],
        "message": "ext4: remove vestiges of nobh support\n\nThe nobh option was only supported for writeback mode, but given that all\nwrite paths actually create buffer heads it effectively was a no-op already.\n\nSigned-off-by: Christoph Hellwig <hch@lst.de>\nSigned-off-by: \"Theodore Ts'o\" <tytso@mit.edu>",
        "before_after_code_files": [
          "fs/ext4/ext4.h||fs/ext4/ext4.h",
          "fs/ext4/ext4_jbd2.h||fs/ext4/ext4_jbd2.h",
          "fs/ext4/inode.c||fs/ext4/inode.c",
          "fs/ext4/super.c||fs/ext4/super.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "fs/ext4/ext4.h||fs/ext4/ext4.h",
            "fs/ext4/ext4_jbd2.h||fs/ext4/ext4_jbd2.h",
            "fs/ext4/inode.c||fs/ext4/inode.c",
            "fs/ext4/super.c||fs/ext4/super.c"
          ],
          "candidate": [
            "fs/ext4/ext4.h||fs/ext4/ext4.h",
            "fs/ext4/ext4_jbd2.h||fs/ext4/ext4_jbd2.h",
            "fs/ext4/inode.c||fs/ext4/inode.c",
            "fs/ext4/super.c||fs/ext4/super.c"
          ]
        }
      },
      "candidate_diff": {
        "fs/ext4/ext4.h||fs/ext4/ext4.h": [
          "File: fs/ext4/ext4.h -> fs/ext4/ext4.h"
        ],
        "fs/ext4/ext4_jbd2.h||fs/ext4/ext4_jbd2.h": [
          "File: fs/ext4/ext4_jbd2.h -> fs/ext4/ext4_jbd2.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "321: static inline int ext4_should_dioread_nolock(struct inode *inode)",
          "322: {",
          "323:  if (!test_opt(inode->i_sb, DIOREAD_NOLOCK))",
          "324:   return 0;",
          "327:  if (!S_ISREG(inode->i_mode))",
          "328:   return 0;",
          "329:  if (!(ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS)))",
          "",
          "[Removed Lines]",
          "325:  if (test_opt(inode->i_sb, NOBH))",
          "326:   return 0;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "fs/ext4/inode.c||fs/ext4/inode.c": [
          "File: fs/ext4/inode.c -> fs/ext4/inode.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "2749:   return __ext4_journalled_writepage(page, len);",
          "2750:  }",
          "2755:   ext4_set_bh_endio(page_bufs, inode);",
          "2756:   ret = block_write_full_page_endio(page, noalloc_get_block_write,",
          "2757:          wbc, ext4_end_io_buffer_write);",
          "",
          "[Removed Lines]",
          "2752:  if (test_opt(inode->i_sb, NOBH) && ext4_should_writeback_data(inode))",
          "2753:   ret = nobh_writepage(page, noalloc_get_block_write, wbc);",
          "2754:  else if (page_bufs && buffer_uninit(page_bufs)) {",
          "",
          "[Added Lines]",
          "2750:  if (page_bufs && buffer_uninit(page_bufs)) {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "4125:  length = blocksize - (offset & (blocksize - 1));",
          "4126:  iblock = index << (PAGE_CACHE_SHIFT - inode->i_sb->s_blocksize_bits);",
          "4139:  if (!page_has_buffers(page))",
          "4140:   create_empty_buffers(page, blocksize, 0);",
          "",
          "[Removed Lines]",
          "4132:  if (!page_has_buffers(page) && test_opt(inode->i_sb, NOBH) &&",
          "4133:       ext4_should_writeback_data(inode) && PageUptodate(page)) {",
          "4134:   zero_user(page, offset, length);",
          "4135:   set_page_dirty(page);",
          "4136:   goto unlock;",
          "4137:  }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "fs/ext4/super.c||fs/ext4/super.c": [
          "File: fs/ext4/super.c -> fs/ext4/super.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "946:   seq_puts(seq, \",journal_async_commit\");",
          "947:  else if (test_opt(sb, JOURNAL_CHECKSUM))",
          "948:   seq_puts(seq, \",journal_checksum\");",
          "951:  if (test_opt(sb, I_VERSION))",
          "952:   seq_puts(seq, \",i_version\");",
          "953:  if (!test_opt(sb, DELALLOC))",
          "",
          "[Removed Lines]",
          "949:  if (test_opt(sb, NOBH))",
          "950:   seq_puts(seq, \",nobh\");",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1625:    break;",
          "1626:   case Opt_nobh:",
          "1628:    break;",
          "1629:   case Opt_bh:",
          "1631:    break;",
          "1632:   case Opt_i_version:",
          "1633:    set_opt(sbi->s_mount_opt, I_VERSION);",
          "",
          "[Removed Lines]",
          "1627:    set_opt(sbi->s_mount_opt, NOBH);",
          "1630:    clear_opt(sbi->s_mount_opt, NOBH);",
          "",
          "[Added Lines]",
          "1625:    ext4_msg(sb, KERN_WARNING,",
          "1626:      \"Ignoring deprecated nobh option\");",
          "1629:    ext4_msg(sb, KERN_WARNING,",
          "1630:      \"Ignoring deprecated bh option\");",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "2912:   ext4_msg(sb, KERN_ERR, \"insufficient memory\");",
          "2913:   goto failed_mount_wq;",
          "2914:  }",
          "2927:  EXT4_SB(sb)->dio_unwritten_wq = create_workqueue(\"ext4-dio-unwritten\");",
          "2928:  if (!EXT4_SB(sb)->dio_unwritten_wq) {",
          "2929:   printk(KERN_ERR \"EXT4-fs: failed to create DIO workqueue\\n\");",
          "",
          "[Removed Lines]",
          "2915:  if (test_opt(sb, NOBH)) {",
          "2916:   if (!(test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_WRITEBACK_DATA)) {",
          "2917:    ext4_msg(sb, KERN_WARNING, \"Ignoring nobh option - \"",
          "2918:     \"its supported only with writeback mode\");",
          "2919:    clear_opt(sbi->s_mount_opt, NOBH);",
          "2920:   }",
          "2921:   if (test_opt(sb, DIOREAD_NOLOCK)) {",
          "2922:    ext4_msg(sb, KERN_WARNING, \"dioread_nolock option is \"",
          "2923:     \"not supported with nobh mode\");",
          "2924:    goto failed_mount_wq;",
          "2925:   }",
          "2926:  }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "c7064ef13b2181a489836349f9baf87df0dab28f",
      "candidate_info": {
        "commit_hash": "c7064ef13b2181a489836349f9baf87df0dab28f",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/c7064ef13b2181a489836349f9baf87df0dab28f",
        "files": [
          "fs/ext4/ext4.h",
          "fs/ext4/extents.c",
          "fs/ext4/fsync.c",
          "fs/ext4/inode.c",
          "fs/ext4/super.c"
        ],
        "message": "ext4: mechanical rename some of the direct I/O get_block's identifiers\n\nThis commit renames some of the direct I/O's block allocation flags,\nvariables, and functions introduced in Mingming's \"Direct IO for holes\nand fallocate\" patches so that they can be used by ext4's buffered\nwrite path as well.  Also changed the related function comments\naccordingly to cover both direct write and buffered write cases.\n\nSigned-off-by: Jiaying Zhang <jiayingz@google.com>\nSigned-off-by: \"Theodore Ts'o\" <tytso@mit.edu>",
        "before_after_code_files": [
          "fs/ext4/ext4.h||fs/ext4/ext4.h",
          "fs/ext4/extents.c||fs/ext4/extents.c",
          "fs/ext4/fsync.c||fs/ext4/fsync.c",
          "fs/ext4/inode.c||fs/ext4/inode.c",
          "fs/ext4/super.c||fs/ext4/super.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "fs/ext4/ext4.h||fs/ext4/ext4.h",
            "fs/ext4/extents.c||fs/ext4/extents.c",
            "fs/ext4/inode.c||fs/ext4/inode.c",
            "fs/ext4/super.c||fs/ext4/super.c"
          ],
          "candidate": [
            "fs/ext4/ext4.h||fs/ext4/ext4.h",
            "fs/ext4/extents.c||fs/ext4/extents.c",
            "fs/ext4/inode.c||fs/ext4/inode.c",
            "fs/ext4/super.c||fs/ext4/super.c"
          ]
        }
      },
      "candidate_diff": {
        "fs/ext4/ext4.h||fs/ext4/ext4.h": [
          "File: fs/ext4/ext4.h -> fs/ext4/ext4.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "133:  int pages_written;",
          "134:  int retval;",
          "135: };",
          "137: typedef struct ext4_io_end {",
          "",
          "[Removed Lines]",
          "136: #define DIO_AIO_UNWRITTEN 0x1",
          "",
          "[Added Lines]",
          "136: #define EXT4_IO_UNWRITTEN 0x1",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "356:  unitialized extents if not allocated, split the uninitialized",
          "359: #define EXT4_GET_BLOCKS_CONVERT   0x0010",
          "361:       EXT4_GET_BLOCKS_CREATE_UNINIT_EXT)",
          "",
          "[Removed Lines]",
          "358: #define EXT4_GET_BLOCKS_DIO   0x0008",
          "360: #define EXT4_GET_BLOCKS_DIO_CREATE_EXT  (EXT4_GET_BLOCKS_DIO|\\",
          "363: #define EXT4_GET_BLOCKS_DIO_CONVERT_EXT  (EXT4_GET_BLOCKS_CONVERT|\\",
          "364:       EXT4_GET_BLOCKS_DIO_CREATE_EXT)",
          "",
          "[Added Lines]",
          "358: #define EXT4_GET_BLOCKS_PRE_IO   0x0008",
          "360: #define EXT4_GET_BLOCKS_IO_CREATE_EXT  (EXT4_GET_BLOCKS_PRE_IO|\\",
          "363: #define EXT4_GET_BLOCKS_IO_CONVERT_EXT  (EXT4_GET_BLOCKS_CONVERT|\\",
          "364:       EXT4_GET_BLOCKS_IO_CREATE_EXT)",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "700:  qsize_t i_reserved_quota;",
          "701: #endif",
          "706:  ext4_io_end_t *cur_aio_dio;",
          "",
          "[Removed Lines]",
          "704:  struct list_head i_aio_dio_complete_list;",
          "",
          "[Added Lines]",
          "704:  struct list_head i_completed_io_list;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1461:   struct address_space *mapping, loff_t from);",
          "1462: extern int ext4_page_mkwrite(struct vm_area_struct *vma, struct vm_fault *vmf);",
          "1463: extern qsize_t *ext4_get_reserved_space(struct inode *inode);",
          "1465: extern void ext4_da_update_reserve_space(struct inode *inode,",
          "1466:      int used, int quota_claim);",
          "",
          "[Removed Lines]",
          "1464: extern int flush_aio_dio_completed_IO(struct inode *inode);",
          "",
          "[Added Lines]",
          "1464: extern int flush_completed_IO(struct inode *inode);",
          "",
          "---------------"
        ],
        "fs/ext4/extents.c||fs/ext4/extents.c": [
          "File: fs/ext4/extents.c -> fs/ext4/extents.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1619:  BUG_ON(path[depth].p_hdr == NULL);",
          "1623:   && ext4_can_extents_be_merged(inode, ex, newext)) {",
          "1624:   ext_debug(\"append [%d]%d block to %d:[%d]%d (from %llu)\\n\",",
          "1625:     ext4_ext_is_uninitialized(newext),",
          "",
          "[Removed Lines]",
          "1622:  if (ex && (flag != EXT4_GET_BLOCKS_DIO_CREATE_EXT)",
          "",
          "[Added Lines]",
          "1622:  if (ex && (flag != EXT4_GET_BLOCKS_PRE_IO)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1741: merge:",
          "1744:   ext4_ext_try_to_merge(inode, path, nearex);",
          "",
          "[Removed Lines]",
          "1743:  if (flag != EXT4_GET_BLOCKS_DIO_CREATE_EXT)",
          "",
          "[Added Lines]",
          "1743:  if (flag != EXT4_GET_BLOCKS_PRE_IO)",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "2984:  ext4_ext_dirty(handle, inode, path + depth);",
          "2985:  return err;",
          "2986: }",
          "2988:            struct inode *inode,",
          "2989:            struct ext4_ext_path *path)",
          "2990: {",
          "",
          "[Removed Lines]",
          "2987: static int ext4_convert_unwritten_extents_dio(handle_t *handle,",
          "",
          "[Added Lines]",
          "2987: static int ext4_convert_unwritten_extents_endio(handle_t *handle,",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "3064:     flags, allocated);",
          "3065:  ext4_ext_show_leaf(inode, path);",
          "3069:   ret = ext4_split_unwritten_extents(handle,",
          "3070:       inode, path, iblock,",
          "3071:       max_blocks, flags);",
          "",
          "[Removed Lines]",
          "3068:  if (flags == EXT4_GET_BLOCKS_DIO_CREATE_EXT) {",
          "",
          "[Added Lines]",
          "3068:  if (flags == EXT4_GET_BLOCKS_PRE_IO) {",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "3077:   if (io)",
          "3079:   else",
          "3080:    ext4_set_inode_state(inode, EXT4_STATE_DIO_UNWRITTEN);",
          "3081:   goto out;",
          "3082:  }",
          "3086:        path);",
          "3087:   if (ret >= 0)",
          "3088:    ext4_update_inode_fsync_trans(handle, inode, 1);",
          "",
          "[Removed Lines]",
          "3078:    io->flag = DIO_AIO_UNWRITTEN;",
          "3084:  if (flags == EXT4_GET_BLOCKS_DIO_CONVERT_EXT) {",
          "3085:   ret = ext4_convert_unwritten_extents_dio(handle, inode,",
          "",
          "[Added Lines]",
          "3078:    io->flag = EXT4_IO_UNWRITTEN;",
          "3084:  if (flags == EXT4_GET_BLOCKS_CONVERT) {",
          "3085:   ret = ext4_convert_unwritten_extents_endio(handle, inode,",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "3363:    if (io)",
          "3365:    else",
          "3366:     ext4_set_inode_state(inode,",
          "3367:            EXT4_STATE_DIO_UNWRITTEN);",
          "",
          "[Removed Lines]",
          "3362:   if (flags == EXT4_GET_BLOCKS_DIO_CREATE_EXT) {",
          "3364:     io->flag = DIO_AIO_UNWRITTEN;",
          "",
          "[Added Lines]",
          "3362:   if (flags == EXT4_GET_BLOCKS_PRE_IO) {",
          "3364:     io->flag = EXT4_IO_UNWRITTEN;",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "3656:   map_bh.b_state = 0;",
          "3657:   ret = ext4_get_blocks(handle, inode, block,",
          "3658:           max_blocks, &map_bh,",
          "3660:   if (ret <= 0) {",
          "3661:    WARN_ON(ret <= 0);",
          "3662:    printk(KERN_ERR \"%s: ext4_ext_get_blocks \"",
          "",
          "[Removed Lines]",
          "3659:           EXT4_GET_BLOCKS_DIO_CONVERT_EXT);",
          "",
          "[Added Lines]",
          "3659:           EXT4_GET_BLOCKS_IO_CONVERT_EXT);",
          "",
          "---------------"
        ],
        "fs/ext4/fsync.c||fs/ext4/fsync.c": [
          "File: fs/ext4/fsync.c -> fs/ext4/fsync.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "63:  if (inode->i_sb->s_flags & MS_RDONLY)",
          "64:   return 0;",
          "67:  if (ret < 0)",
          "68:   return ret;",
          "",
          "[Removed Lines]",
          "66:  ret = flush_aio_dio_completed_IO(inode);",
          "",
          "[Added Lines]",
          "66:  ret = flush_completed_IO(inode);",
          "",
          "---------------"
        ],
        "fs/ext4/inode.c||fs/ext4/inode.c": [
          "File: fs/ext4/inode.c -> fs/ext4/inode.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "3468:  return ret;",
          "3469: }",
          "3472:      struct buffer_head *bh_result, int create)",
          "3473: {",
          "3474:  handle_t *handle = NULL;",
          "",
          "[Removed Lines]",
          "3471: static int ext4_get_block_dio_write(struct inode *inode, sector_t iblock,",
          "",
          "[Added Lines]",
          "3471: static int ext4_get_block_write(struct inode *inode, sector_t iblock,",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "3476:  unsigned max_blocks = bh_result->b_size >> inode->i_blkbits;",
          "3477:  int dio_credits;",
          "3480:      inode->i_ino, create);",
          "3502:  if (max_blocks > DIO_MAX_BLOCKS)",
          "3503:   max_blocks = DIO_MAX_BLOCKS;",
          "",
          "[Removed Lines]",
          "3479:  ext4_debug(\"ext4_get_block_dio_write: inode %lu, create flag %d\\n\",",
          "3500:  create = EXT4_GET_BLOCKS_DIO_CREATE_EXT;",
          "",
          "[Added Lines]",
          "3479:  ext4_debug(\"ext4_get_block_write: inode %lu, create flag %d\\n\",",
          "3486:  create = EXT4_GET_BLOCKS_IO_CREATE_EXT;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "3524:  iput(io->inode);",
          "3525:  kfree(io);",
          "3526: }",
          "3528: {",
          "3529: #ifdef EXT4_DEBUG",
          "3530:  struct list_head *cur, *before, *after;",
          "3531:  ext4_io_end_t *io, *io0, *io1;",
          "3535:   return;",
          "3536:  }",
          "3540:   cur = &io->list;",
          "3541:   before = cur->prev;",
          "3542:   io0 = container_of(before, ext4_io_end_t, list);",
          "",
          "[Removed Lines]",
          "3527: static void dump_aio_dio_list(struct inode * inode)",
          "3533:  if (list_empty(&EXT4_I(inode)->i_aio_dio_complete_list)){",
          "3534:   ext4_debug(\"inode %lu aio dio list is empty\\n\", inode->i_ino);",
          "3538:  ext4_debug(\"Dump inode %lu aio_dio_completed_IO list \\n\", inode->i_ino);",
          "3539:  list_for_each_entry(io, &EXT4_I(inode)->i_aio_dio_complete_list, list){",
          "",
          "[Added Lines]",
          "3514: static void dump_completed_IO(struct inode * inode)",
          "3520:  if (list_empty(&EXT4_I(inode)->i_completed_io_list)){",
          "3521:   ext4_debug(\"inode %lu completed_io list is empty\\n\", inode->i_ino);",
          "3525:  ext4_debug(\"Dump inode %lu completed_io list \\n\", inode->i_ino);",
          "3526:  list_for_each_entry(io, &EXT4_I(inode)->i_completed_io_list, list){",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "3556: {",
          "3557:  struct inode *inode = io->inode;",
          "3558:  loff_t offset = io->offset;",
          "3559:  ssize_t size = io->size;",
          "3560:  int ret = 0;",
          "3563:      \"list->prev 0x%p\\n\",",
          "3564:             io, inode->i_ino, io->list.next, io->list.prev);",
          "3566:  if (list_empty(&io->list))",
          "3567:   return ret;",
          "3570:   return ret;",
          "3572:  if (offset + size <= i_size_read(inode))",
          "",
          "[Removed Lines]",
          "3555: static int ext4_end_aio_dio_nolock(ext4_io_end_t *io)",
          "3562:  ext4_debug(\"end_aio_dio_onlock: io 0x%p from inode %lu,list->next 0x%p,\"",
          "3569:  if (io->flag != DIO_AIO_UNWRITTEN)",
          "",
          "[Added Lines]",
          "3542: static int ext4_end_io_nolock(ext4_io_end_t *io)",
          "3549:  ext4_debug(\"ext4_end_io_nolock: io 0x%p from inode %lu,list->next 0x%p,\"",
          "3556:  if (io->flag != EXT4_IO_UNWRITTEN)",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "3584:  io->flag = 0;",
          "3585:  return ret;",
          "3586: }",
          "3591: {",
          "3592:  ext4_io_end_t *io  = container_of(work, ext4_io_end_t, work);",
          "3593:  struct inode *inode = io->inode;",
          "3594:  int ret = 0;",
          "3596:  mutex_lock(&inode->i_mutex);",
          "3598:  if (ret >= 0) {",
          "3599:   if (!list_empty(&io->list))",
          "3600:    list_del_init(&io->list);",
          "",
          "[Removed Lines]",
          "3590: static void ext4_end_aio_dio_work(struct work_struct *work)",
          "3597:  ret = ext4_end_aio_dio_nolock(io);",
          "",
          "[Added Lines]",
          "3578: static void ext4_end_io_work(struct work_struct *work)",
          "3585:  ret = ext4_end_io_nolock(io);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "3602:  }",
          "3603:  mutex_unlock(&inode->i_mutex);",
          "3604: }",
          "3617: {",
          "3618:  ext4_io_end_t *io;",
          "3619:  int ret = 0;",
          "3620:  int ret2 = 0;",
          "3623:   return ret;",
          "3628:     ext4_io_end_t, list);",
          "",
          "[Removed Lines]",
          "3616: int flush_aio_dio_completed_IO(struct inode *inode)",
          "3622:  if (list_empty(&EXT4_I(inode)->i_aio_dio_complete_list))",
          "3625:  dump_aio_dio_list(inode);",
          "3626:  while (!list_empty(&EXT4_I(inode)->i_aio_dio_complete_list)){",
          "3627:   io = list_entry(EXT4_I(inode)->i_aio_dio_complete_list.next,",
          "",
          "[Added Lines]",
          "3607: int flush_completed_IO(struct inode *inode)",
          "3613:  if (list_empty(&EXT4_I(inode)->i_completed_io_list))",
          "3616:  dump_completed_IO(inode);",
          "3617:  while (!list_empty(&EXT4_I(inode)->i_completed_io_list)){",
          "3618:   io = list_entry(EXT4_I(inode)->i_completed_io_list.next,",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "3644:   if (ret < 0)",
          "3645:    ret2 = ret;",
          "3646:   else",
          "",
          "[Removed Lines]",
          "3643:   ret = ext4_end_aio_dio_nolock(io);",
          "",
          "[Added Lines]",
          "3634:   ret = ext4_end_io_nolock(io);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "3662:   io->offset = 0;",
          "3663:   io->size = 0;",
          "3664:   io->error = 0;",
          "3666:   INIT_LIST_HEAD(&io->list);",
          "3667:  }",
          "",
          "[Removed Lines]",
          "3665:   INIT_WORK(&io->work, ext4_end_aio_dio_work);",
          "",
          "[Added Lines]",
          "3656:   INIT_WORK(&io->work, ext4_end_io_work);",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "3685:     size);",
          "3689:   ext4_free_io_end(io_end);",
          "3690:   iocb->private = NULL;",
          "3691:   return;",
          "",
          "[Removed Lines]",
          "3688:  if (io_end->flag != DIO_AIO_UNWRITTEN){",
          "",
          "[Added Lines]",
          "3679:  if (io_end->flag != EXT4_IO_UNWRITTEN){",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "3702:  list_add_tail(&io_end->list,",
          "3704:  iocb->private = NULL;",
          "3705: }",
          "",
          "[Removed Lines]",
          "3703:    &EXT4_I(io_end->inode)->i_aio_dio_complete_list);",
          "",
          "[Added Lines]",
          "3694:    &EXT4_I(io_end->inode)->i_completed_io_list);",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "3772:   ret = blockdev_direct_IO(rw, iocb, inode,",
          "3773:       inode->i_sb->s_bdev, iov,",
          "3774:       offset, nr_segs,",
          "3776:       ext4_end_io_dio);",
          "3777:   if (iocb->private)",
          "3778:    EXT4_I(inode)->cur_aio_dio = NULL;",
          "",
          "[Removed Lines]",
          "3775:       ext4_get_block_dio_write,",
          "",
          "[Added Lines]",
          "3767:       ext4_get_block_write,",
          "",
          "---------------"
        ],
        "fs/ext4/super.c||fs/ext4/super.c": [
          "File: fs/ext4/super.c -> fs/ext4/super.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "708: #ifdef CONFIG_QUOTA",
          "709:  ei->i_reserved_quota = 0;",
          "710: #endif",
          "712:  ei->cur_aio_dio = NULL;",
          "713:  ei->i_sync_tid = 0;",
          "714:  ei->i_datasync_tid = 0;",
          "",
          "[Removed Lines]",
          "711:  INIT_LIST_HEAD(&ei->i_aio_dio_complete_list);",
          "",
          "[Added Lines]",
          "711:  INIT_LIST_HEAD(&ei->i_completed_io_list);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "5f5249507e4b5c4fc0f9c93f33d133d8c95f47e1",
      "candidate_info": {
        "commit_hash": "5f5249507e4b5c4fc0f9c93f33d133d8c95f47e1",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/5f5249507e4b5c4fc0f9c93f33d133d8c95f47e1",
        "files": [
          "fs/ext4/ext4.h",
          "fs/ext4/extents.c",
          "fs/ext4/inode.c"
        ],
        "message": "ext4: skip conversion of uninit extents after direct IO if there isn't any\n\nAt the end of direct I/O operation, ext4_ext_direct_IO() always called\next4_convert_unwritten_extents(), regardless of whether there were any\nunwritten extents involved in the I/O or not.\n\nThis commit adds a state flag so that ext4_ext_direct_IO() only calls\next4_convert_unwritten_extents() when necessary.\n\nSigned-off-by: Mingming Cao <cmm@us.ibm.com>\nSigned-off-by: \"Theodore Ts'o\" <tytso@mit.edu>",
        "before_after_code_files": [
          "fs/ext4/ext4.h||fs/ext4/ext4.h",
          "fs/ext4/extents.c||fs/ext4/extents.c",
          "fs/ext4/inode.c||fs/ext4/inode.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "fs/ext4/ext4.h||fs/ext4/ext4.h",
            "fs/ext4/extents.c||fs/ext4/extents.c",
            "fs/ext4/inode.c||fs/ext4/inode.c"
          ],
          "candidate": [
            "fs/ext4/ext4.h||fs/ext4/ext4.h",
            "fs/ext4/extents.c||fs/ext4/extents.c",
            "fs/ext4/inode.c||fs/ext4/inode.c"
          ]
        }
      },
      "candidate_diff": {
        "fs/ext4/ext4.h||fs/ext4/ext4.h": [
          "File: fs/ext4/ext4.h -> fs/ext4/ext4.h"
        ],
        "fs/ext4/extents.c||fs/ext4/extents.c": [
          "File: fs/ext4/extents.c -> fs/ext4/extents.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "3048:   ret = ext4_split_unwritten_extents(handle,",
          "3049:       inode, path, iblock,",
          "3050:       max_blocks, flags);",
          "3052:   if (io)",
          "3053:    io->flag = DIO_AIO_UNWRITTEN;",
          "3054:   goto out;",
          "3055:  }",
          "3057:  if (flags == EXT4_GET_BLOCKS_DIO_CONVERT_EXT) {",
          "3058:   ret = ext4_convert_unwritten_extents_dio(handle, inode,",
          "3059:        path);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3058:   else",
          "3059:    EXT4_I(inode)->i_state |= EXT4_STATE_DIO_UNWRITTEN;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "3302:  }",
          "3303:  err = ext4_ext_insert_extent(handle, inode, path, &newex, flags);",
          "3304:  if (err) {",
          "",
          "[Removed Lines]",
          "3300:   if (io && flags == EXT4_GET_BLOCKS_DIO_CREATE_EXT)",
          "3301:    io->flag = DIO_AIO_UNWRITTEN;",
          "",
          "[Added Lines]",
          "3307:   if (flags == EXT4_GET_BLOCKS_DIO_CREATE_EXT) {",
          "3308:    if (io)",
          "3309:     io->flag = DIO_AIO_UNWRITTEN;",
          "3310:    else",
          "3311:     EXT4_I(inode)->i_state |=",
          "3312:      EXT4_STATE_DIO_UNWRITTEN;;",
          "3313:   }",
          "",
          "---------------"
        ],
        "fs/ext4/inode.c||fs/ext4/inode.c": [
          "File: fs/ext4/inode.c -> fs/ext4/inode.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "3772:   if (ret != -EIOCBQUEUED && ret <= 0 && iocb->private) {",
          "3773:    ext4_free_io_end(iocb->private);",
          "3774:    iocb->private = NULL;",
          "3776:    int err;",
          "",
          "[Removed Lines]",
          "3775:   } else if (ret > 0) {",
          "",
          "[Added Lines]",
          "3775:   } else if (ret > 0 && (EXT4_I(inode)->i_state &",
          "3776:            EXT4_STATE_DIO_UNWRITTEN)) {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "3782:             offset, ret);",
          "3783:    if (err < 0)",
          "3784:     ret = err;",
          "3785:   }",
          "3786:   return ret;",
          "3787:  }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3786:    EXT4_I(inode)->i_state &= ~EXT4_STATE_DIO_UNWRITTEN;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "6db26ffc917b609402619e03df5af8d1cd371ce7",
      "candidate_info": {
        "commit_hash": "6db26ffc917b609402619e03df5af8d1cd371ce7",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/6db26ffc917b609402619e03df5af8d1cd371ce7",
        "files": [
          "fs/ext4/inode.c"
        ],
        "message": "fs/ext4/inode.c: use pr_warn_ratelimited()\n\npr_warning_ratelimited() doesn't exist.\n\nAlso include printk.h, which defines these things.\n\nCc: Theodore Ts'o <tytso@mit.edu>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
        "before_after_code_files": [
          "fs/ext4/inode.c||fs/ext4/inode.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "fs/ext4/inode.c||fs/ext4/inode.c"
          ],
          "candidate": [
            "fs/ext4/inode.c||fs/ext4/inode.c"
          ]
        }
      },
      "candidate_diff": {
        "fs/ext4/inode.c||fs/ext4/inode.c": [
          "File: fs/ext4/inode.c -> fs/ext4/inode.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "39: #include <linux/bio.h>",
          "40: #include <linux/workqueue.h>",
          "41: #include <linux/kernel.h>",
          "42: #include <linux/slab.h>",
          "43: #include <linux/ratelimit.h>",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "42: #include <linux/printk.h>",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "3737: retry:",
          "3738:  io_end = ext4_init_io_end(inode, GFP_ATOMIC);",
          "3739:  if (!io_end) {",
          "3741:   schedule();",
          "3742:   goto retry;",
          "3743:  }",
          "",
          "[Removed Lines]",
          "3740:   pr_warning_ratelimited(\"%s: allocation fail\\n\", __func__);",
          "",
          "[Added Lines]",
          "3741:   pr_warn_ratelimited(\"%s: allocation fail\\n\", __func__);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "4c0425ff68b1b87b802ffeda7b6a46ff7da7241c",
      "candidate_info": {
        "commit_hash": "4c0425ff68b1b87b802ffeda7b6a46ff7da7241c",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/4c0425ff68b1b87b802ffeda7b6a46ff7da7241c",
        "files": [
          "fs/ext4/ext4.h",
          "fs/ext4/inode.c",
          "fs/ext4/super.c"
        ],
        "message": "ext4: Use end_io callback to avoid direct I/O fallback to buffered I/O\n\nCurrently the DIO VFS code passes create = 0 when writing to the\nmiddle of file.  It does this to avoid block allocation for holes, so\nas not to expose stale data out when there is a parallel buffered read\n(which does not hold the i_mutex lock).  Direct I/O writes into holes\nfalls back to buffered IO for this reason.\n\nSince preallocated extents are treated as holes when doing a\nget_block() look up (buffer is not mapped), direct IO over fallocate\nalso falls back to buffered IO.  Thus ext4 actually silently falls\nback to buffered IO in above two cases, which is undesirable.\n\nTo fix this, this patch creates unitialized extents when a direct I/O\nwrite into holes in sparse files, and registering an end_io callback which\nconverts the uninitialized extent to an initialized extent after the\nI/O is completed.\n\nSinged-Off-By: Mingming Cao <cmm@us.ibm.com>\nSigned-off-by: \"Theodore Ts'o\" <tytso@mit.edu>",
        "before_after_code_files": [
          "fs/ext4/ext4.h||fs/ext4/ext4.h",
          "fs/ext4/inode.c||fs/ext4/inode.c",
          "fs/ext4/super.c||fs/ext4/super.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "fs/ext4/ext4.h||fs/ext4/ext4.h",
            "fs/ext4/inode.c||fs/ext4/inode.c",
            "fs/ext4/super.c||fs/ext4/super.c"
          ],
          "candidate": [
            "fs/ext4/ext4.h||fs/ext4/ext4.h",
            "fs/ext4/inode.c||fs/ext4/inode.c",
            "fs/ext4/super.c||fs/ext4/super.c"
          ]
        }
      },
      "candidate_diff": {
        "fs/ext4/ext4.h||fs/ext4/ext4.h": [
          "File: fs/ext4/ext4.h -> fs/ext4/ext4.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "1000:  unsigned int s_log_groups_per_flex;",
          "1001:  struct flex_groups *s_flex_groups;",
          "1002: };",
          "1004: static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1004:  struct workqueue_struct *dio_unwritten_wq;",
          "",
          "---------------"
        ],
        "fs/ext4/inode.c||fs/ext4/inode.c": [
          "File: fs/ext4/inode.c -> fs/ext4/inode.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "37: #include <linux/namei.h>",
          "38: #include <linux/uio.h>",
          "39: #include <linux/bio.h>",
          "41: #include \"ext4_jbd2.h\"",
          "42: #include \"xattr.h\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "40: #include <linux/workqueue.h>",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "3368:          const struct iovec *iov, loff_t offset,",
          "3369:          unsigned long nr_segs)",
          "3370: {",
          "",
          "[Removed Lines]",
          "3367: static ssize_t ext4_direct_IO(int rw, struct kiocb *iocb,",
          "",
          "[Added Lines]",
          "3370: static ssize_t ext4_ind_direct_IO(int rw, struct kiocb *iocb,",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "3438:  return ret;",
          "3439: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3446: static int ext4_get_block_dio_write(struct inode *inode, sector_t iblock,",
          "3447:      struct buffer_head *bh_result, int create)",
          "3448: {",
          "3449:  handle_t *handle = NULL;",
          "3450:  int ret = 0;",
          "3451:  unsigned max_blocks = bh_result->b_size >> inode->i_blkbits;",
          "3452:  int dio_credits;",
          "3473:  create = EXT4_GET_BLOCKS_DIO_CREATE_EXT;",
          "3475:  if (max_blocks > DIO_MAX_BLOCKS)",
          "3476:   max_blocks = DIO_MAX_BLOCKS;",
          "3477:  dio_credits = ext4_chunk_trans_blocks(inode, max_blocks);",
          "3478:  handle = ext4_journal_start(inode, dio_credits);",
          "3479:  if (IS_ERR(handle)) {",
          "3480:   ret = PTR_ERR(handle);",
          "3481:   goto out;",
          "3482:  }",
          "3483:  ret = ext4_get_blocks(handle, inode, iblock, max_blocks, bh_result,",
          "3484:          create);",
          "3485:  if (ret > 0) {",
          "3486:   bh_result->b_size = (ret << inode->i_blkbits);",
          "3487:   ret = 0;",
          "3488:  }",
          "3489:  ext4_journal_stop(handle);",
          "3490: out:",
          "3491:  return ret;",
          "3492: }",
          "3494: #define  DIO_AIO  0x1",
          "3496: static void ext4_free_io_end(ext4_io_end_t *io)",
          "3497: {",
          "3498:  kfree(io);",
          "3499: }",
          "3506: static void ext4_end_dio_unwritten(struct work_struct *work)",
          "3507: {",
          "3508:  ext4_io_end_t *io = container_of(work, ext4_io_end_t, work);",
          "3509:  struct inode *inode = io->inode;",
          "3510:  loff_t offset = io->offset;",
          "3511:  size_t size = io->size;",
          "3512:  int ret = 0;",
          "3513:  int aio = io->flag & DIO_AIO;",
          "3515:  if (aio)",
          "3516:   mutex_lock(&inode->i_mutex);",
          "3517:  if (offset + size <= i_size_read(inode))",
          "3518:   ret = ext4_convert_unwritten_extents(inode, offset, size);",
          "3520:  if (ret < 0)",
          "3521:   printk(KERN_EMERG \"%s: failed to convert unwritten\"",
          "3522:    \"extents to written extents, error is %d\\n\",",
          "3523:                        __func__, ret);",
          "3525:  ext4_free_io_end(io);",
          "3526:  if (aio)",
          "3527:   mutex_unlock(&inode->i_mutex);",
          "3528: }",
          "3530: static ext4_io_end_t *ext4_init_io_end (struct inode *inode, unsigned int flag)",
          "3531: {",
          "3532:  ext4_io_end_t *io = NULL;",
          "3534:  io = kmalloc(sizeof(*io), GFP_NOFS);",
          "3536:  if (io) {",
          "3537:   io->inode = inode;",
          "3538:   io->flag = flag;",
          "3539:   io->offset = 0;",
          "3540:   io->size = 0;",
          "3541:   io->error = 0;",
          "3542:   INIT_WORK(&io->work, ext4_end_dio_unwritten);",
          "3543:  }",
          "3545:  return io;",
          "3546: }",
          "3548: static void ext4_end_io_dio(struct kiocb *iocb, loff_t offset,",
          "3549:        ssize_t size, void *private)",
          "3550: {",
          "3551:         ext4_io_end_t *io_end = iocb->private;",
          "3552:  struct workqueue_struct *wq;",
          "3555:  if (!io_end || !size || !iocb->private)",
          "3556:   return;",
          "3557:  io_end->offset = offset;",
          "3558:  io_end->size = size;",
          "3559:  wq = EXT4_SB(io_end->inode->i_sb)->dio_unwritten_wq;",
          "3562:  queue_work(wq, &io_end->work);",
          "3564:         if (is_sync_kiocb(iocb))",
          "3565:   flush_workqueue(wq);",
          "3567:  iocb->private = NULL;",
          "3568: }",
          "3586: static ssize_t ext4_ext_direct_IO(int rw, struct kiocb *iocb,",
          "3587:          const struct iovec *iov, loff_t offset,",
          "3588:          unsigned long nr_segs)",
          "3589: {",
          "3590:  struct file *file = iocb->ki_filp;",
          "3591:  struct inode *inode = file->f_mapping->host;",
          "3592:  ssize_t ret;",
          "3593:  size_t count = iov_length(iov, nr_segs);",
          "3595:  loff_t final_size = offset + count;",
          "3596:  if (rw == WRITE && final_size <= inode->i_size) {",
          "3610:   iocb->private = ext4_init_io_end(inode, !is_sync_kiocb(iocb));",
          "3611:   if (!iocb->private)",
          "3612:    return -ENOMEM;",
          "3613:   ret = blockdev_direct_IO(rw, iocb, inode,",
          "3614:       inode->i_sb->s_bdev, iov,",
          "3615:       offset, nr_segs,",
          "3616:       ext4_get_block_dio_write,",
          "3617:       ext4_end_io_dio);",
          "3618:   return ret;",
          "3619:  }",
          "3620:  return ext4_ind_direct_IO(rw, iocb, iov, offset, nr_segs);",
          "3621: }",
          "3623: static ssize_t ext4_direct_IO(int rw, struct kiocb *iocb,",
          "3624:          const struct iovec *iov, loff_t offset,",
          "3625:          unsigned long nr_segs)",
          "3626: {",
          "3627:  struct file *file = iocb->ki_filp;",
          "3628:  struct inode *inode = file->f_mapping->host;",
          "3630:  if (EXT4_I(inode)->i_flags & EXT4_EXTENTS_FL)",
          "3631:   return ext4_ext_direct_IO(rw, iocb, iov, offset, nr_segs);",
          "3633:  return ext4_ind_direct_IO(rw, iocb, iov, offset, nr_segs);",
          "3634: }",
          "",
          "---------------"
        ],
        "fs/ext4/super.c||fs/ext4/super.c": [
          "File: fs/ext4/super.c -> fs/ext4/super.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "580:  struct ext4_super_block *es = sbi->s_es;",
          "581:  int i, err;",
          "583:  lock_super(sb);",
          "584:  lock_kernel();",
          "585:  if (sb->s_dirt)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "583:  flush_workqueue(sbi->dio_unwritten_wq);",
          "584:  destroy_workqueue(sbi->dio_unwritten_wq);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2801:    clear_opt(sbi->s_mount_opt, NOBH);",
          "2802:   }",
          "2803:  }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2807:  EXT4_SB(sb)->dio_unwritten_wq = create_workqueue(\"ext4-dio-unwritten\");",
          "2808:  if (!EXT4_SB(sb)->dio_unwritten_wq) {",
          "2809:   printk(KERN_ERR \"EXT4-fs: failed to create DIO workqueue\\n\");",
          "2810:   goto failed_mount_wq;",
          "2811:  }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "2914: failed_mount4:",
          "2915:  ext4_msg(sb, KERN_ERR, \"mount failed\");",
          "2916:  ext4_release_system_zone(sb);",
          "2917:  if (sbi->s_journal) {",
          "2918:   jbd2_journal_destroy(sbi->s_journal);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2925:  destroy_workqueue(EXT4_SB(sb)->dio_unwritten_wq);",
          "2926: failed_mount_wq:",
          "",
          "---------------"
        ]
      }
    }
  ]
}
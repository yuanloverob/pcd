{
  "cve_id": "CVE-2022-23574",
  "cve_desc": "Tensorflow is an Open Source Machine Learning Framework. There is a typo in TensorFlow's `SpecializeType` which results in heap OOB read/write. Due to a typo, `arg` is initialized to the `i`th mutable argument in a loop where the loop index is `j`. Hence it is possible to assign to `arg` from outside the vector of arguments. Since this is a mutable proto value, it allows both read and write to outside of bounds data. The fix will be included in TensorFlow 2.8.0. We will also cherrypick this commit on TensorFlow 2.7.1, and TensorFlow 2.6.3, as these are also affected and still in supported range.",
  "repo": "tensorflow/tensorflow",
  "patch_hash": "0657c83d08845cc434175934c642299de2c0f042",
  "patch_info": {
    "commit_hash": "0657c83d08845cc434175934c642299de2c0f042",
    "repo": "tensorflow/tensorflow",
    "commit_url": "https://github.com/tensorflow/tensorflow/commit/0657c83d08845cc434175934c642299de2c0f042",
    "files": [
      "tensorflow/core/framework/full_type_util.cc"
    ],
    "message": "Fix heap OOB read/write due to incorrect indexing.\n\nPiperOrigin-RevId: 408578046\nChange-Id: Ifc9ffea49e5890f55fcb2c27568611052c3ddcfa",
    "before_after_code_files": [
      "tensorflow/core/framework/full_type_util.cc||tensorflow/core/framework/full_type_util.cc"
    ]
  },
  "patch_diff": {
    "tensorflow/core/framework/full_type_util.cc||tensorflow/core/framework/full_type_util.cc": [
      "File: tensorflow/core/framework/full_type_util.cc -> tensorflow/core/framework/full_type_util.cc",
      "--- Hunk 1 ---",
      "[Context before]",
      "102:     for (int j = 0; j < t->args_size(); j++) {",
      "104:       if (arg->type_id() == TFT_VAR) {",
      "105:         const auto* attr = attrs.Find(arg->s());",
      "106:         if (attr == nullptr) {",
      "",
      "[Removed Lines]",
      "103:       auto* arg = t->mutable_args(i);",
      "",
      "[Added Lines]",
      "103:       auto* arg = t->mutable_args(j);",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "7c3f96bf324cebe443a7eb814ce771c66c073998",
      "candidate_info": {
        "commit_hash": "7c3f96bf324cebe443a7eb814ce771c66c073998",
        "repo": "tensorflow/tensorflow",
        "commit_url": "https://github.com/tensorflow/tensorflow/commit/7c3f96bf324cebe443a7eb814ce771c66c073998",
        "files": [
          "tensorflow/c/python_api.cc",
          "tensorflow/core/framework/BUILD",
          "tensorflow/core/framework/full_type.proto",
          "tensorflow/core/framework/full_type_util.cc",
          "tensorflow/core/framework/full_type_util.h",
          "tensorflow/core/framework/shape_inference.cc",
          "tensorflow/core/framework/shape_inference.h",
          "tensorflow/core/framework/types.proto",
          "tensorflow/core/graph/node_builder.cc",
          "tensorflow/core/ops/dataset_ops.cc",
          "tensorflow/core/ops/list_ops.cc",
          "tensorflow/python/framework/cpp_shape_inference.proto",
          "tensorflow/python/kernel_tests/list_ops_test.py",
          "tensorflow/python/kernel_tests/resource_variable_ops_test.py",
          "tensorflow/python/ops/list_ops.py",
          "tensorflow/python/ops/parallel_for/pfor.py"
        ],
        "message": "Upgrade SpecializedType to FullType. Move the type constructor execution to shape inference, making type information available to the shape inference functions.\n\nPiperOrigin-RevId: 380190719\nChange-Id: Ib7fa05d005f5839fb1a1ae5699fe67ec17b10f70",
        "before_after_code_files": [
          "tensorflow/c/python_api.cc||tensorflow/c/python_api.cc",
          "tensorflow/core/framework/full_type.proto||tensorflow/core/framework/full_type.proto",
          "tensorflow/core/framework/full_type_util.cc||tensorflow/core/framework/full_type_util.cc",
          "tensorflow/core/framework/full_type_util.h||tensorflow/core/framework/full_type_util.h",
          "tensorflow/core/framework/shape_inference.cc||tensorflow/core/framework/shape_inference.cc",
          "tensorflow/core/framework/shape_inference.h||tensorflow/core/framework/shape_inference.h",
          "tensorflow/core/framework/types.proto||tensorflow/core/framework/types.proto",
          "tensorflow/core/graph/node_builder.cc||tensorflow/core/graph/node_builder.cc",
          "tensorflow/core/ops/dataset_ops.cc||tensorflow/core/ops/dataset_ops.cc",
          "tensorflow/core/ops/list_ops.cc||tensorflow/core/ops/list_ops.cc",
          "tensorflow/python/framework/cpp_shape_inference.proto||tensorflow/python/framework/cpp_shape_inference.proto",
          "tensorflow/python/kernel_tests/list_ops_test.py||tensorflow/python/kernel_tests/list_ops_test.py",
          "tensorflow/python/kernel_tests/resource_variable_ops_test.py||tensorflow/python/kernel_tests/resource_variable_ops_test.py",
          "tensorflow/python/ops/list_ops.py||tensorflow/python/ops/list_ops.py",
          "tensorflow/python/ops/parallel_for/pfor.py||tensorflow/python/ops/parallel_for/pfor.py"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "tensorflow/core/framework/full_type_util.cc||tensorflow/core/framework/full_type_util.cc"
          ],
          "candidate": [
            "tensorflow/core/framework/full_type_util.cc||tensorflow/core/framework/full_type_util.cc"
          ]
        }
      },
      "candidate_diff": {
        "tensorflow/c/python_api.cc||tensorflow/c/python_api.cc": [
          "File: tensorflow/c/python_api.cc -> tensorflow/c/python_api.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "100:       auto* out_shape_and_type = handle_data.add_shape_and_type();",
          "101:       ic->ShapeHandleToProto(p.shape, out_shape_and_type->mutable_shape());",
          "102:       out_shape_and_type->set_dtype(p.dtype);",
          "104:     }",
          "105:   }",
          "106:   string result;",
          "",
          "[Removed Lines]",
          "103:       out_shape_and_type->set_specialized_type(p.specialized_type);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "129:         ic->MakeShapeFromShapeProto(shape_and_type_proto.shape(), &shape);",
          "130:     if (TF_GetCode(status) != TF_OK) return;",
          "131:     shapes_and_types.emplace_back(shape, shape_and_type_proto.dtype(),",
          "133:   }",
          "134:   ic->set_output_handle_shapes_and_types(output.index, shapes_and_types);",
          "135: }",
          "",
          "[Removed Lines]",
          "132:                                   shape_and_type_proto.specialized_type());",
          "",
          "[Added Lines]",
          "132:                                   shape_and_type_proto.type());",
          "",
          "---------------"
        ],
        "tensorflow/core/framework/full_type.proto||tensorflow/core/framework/full_type.proto": [
          "File: tensorflow/core/framework/full_type.proto -> tensorflow/core/framework/full_type.proto",
          "--- Hunk 1 ---",
          "[Context before]",
          "111:   TFT_ARRAY = 1001;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "123:   TFT_OPTIONAL = 1002;",
          "",
          "---------------"
        ],
        "tensorflow/core/framework/full_type_util.cc||tensorflow/core/framework/full_type_util.cc": [
          "File: tensorflow/core/framework/full_type_util.cc -> tensorflow/core/framework/full_type_util.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "16: #include \"tensorflow/core/framework/full_type_util.h\"",
          "18: namespace tensorflow {",
          "20: namespace full_type {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "18: #include \"tensorflow/core/framework/attr_value.pb.h\"",
          "19: #include \"tensorflow/core/framework/full_type.pb.h\"",
          "20: #include \"tensorflow/core/framework/node_def.pb.h\"",
          "21: #include \"tensorflow/core/framework/node_def_util.h\"",
          "22: #include \"tensorflow/core/framework/op_def.pb.h\"",
          "23: #include \"tensorflow/core/framework/types.h\"",
          "24: #include \"tensorflow/core/platform/statusor.h\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "61:   };",
          "62: }",
          "64: }  // namespace full_type",
          "66: }  // namespace tensorflow",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "72: StatusOr<FullTypeDef> SpecializeType(const AttrSlice& attrs,",
          "73:                                      const OpDef& op_def) {",
          "74:   FullTypeDef ft;",
          "75:   ft.set_type_id(TFT_PRODUCT);",
          "77:   for (int i = 0; i < op_def.output_arg_size(); i++) {",
          "78:     auto* t = ft.add_args();",
          "92:     for (int j = 0; j < t->args_size(); j++) {",
          "93:       auto* arg = t->mutable_args(i);",
          "94:       if (arg->type_id() == TFT_VAR) {",
          "95:         const auto* attr = attrs.Find(arg->s());",
          "96:         DCHECK(attr != nullptr);",
          "97:         if (attr->value_case() == AttrValue::kList) {",
          "98:           const auto& attr_list = attr->list();",
          "99:           arg->set_type_id(TFT_PRODUCT);",
          "100:           for (int i = 0; i < attr_list.type_size(); i++) {",
          "101:             map_dtype_to_tensor(attr_list.type(i), arg->add_args());",
          "102:           }",
          "104:         } else if (attr->value_case() == AttrValue::kType) {",
          "105:           map_dtype_to_tensor(attr->type(), arg);",
          "107:         } else {",
          "108:           return Status(error::UNIMPLEMENTED,",
          "109:                         absl::StrCat(\"unknown attribute type\",",
          "110:                                      attrs.DebugString(), \" key=\", arg->s()));",
          "111:         }",
          "113:         arg->clear_s();",
          "114:       }",
          "115:     }",
          "116:   }",
          "118:   return ft;",
          "119: }",
          "",
          "---------------"
        ],
        "tensorflow/core/framework/full_type_util.h||tensorflow/core/framework/full_type_util.h": [
          "File: tensorflow/core/framework/full_type_util.h -> tensorflow/core/framework/full_type_util.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "17: #define CORE_FRAMEWORK_FULL_TYPE_UTIL_H_",
          "19: #include <functional>",
          "21: #include \"tensorflow/core/framework/full_type.pb.h\"",
          "22: #include \"tensorflow/core/framework/op_def_builder.h\"",
          "24: namespace tensorflow {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "20: #include <string>",
          "23: #include \"tensorflow/core/framework/node_def.pb.h\"",
          "24: #include \"tensorflow/core/framework/node_def_util.h\"",
          "25: #include \"tensorflow/core/framework/op_def.pb.h\"",
          "27: #include \"tensorflow/core/platform/statusor.h\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "45: OpTypeConstructor UnaryTensorContainer(FullTypeId t, FullTypeId dtype);",
          "47: }  // namespace full_type",
          "49: }  // namespace tensorflow",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "56: StatusOr<FullTypeDef> SpecializeType(const AttrSlice& attrs,",
          "57:                                      const OpDef& op_def);",
          "",
          "---------------"
        ],
        "tensorflow/core/framework/shape_inference.cc||tensorflow/core/framework/shape_inference.cc": [
          "File: tensorflow/core/framework/shape_inference.cc -> tensorflow/core/framework/shape_inference.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "15: #include \"tensorflow/core/framework/shape_inference.h\"",
          "17: #include \"tensorflow/core/framework/bounds_check.h\"",
          "18: #include \"tensorflow/core/framework/node_def.pb.h\"",
          "19: #include \"tensorflow/core/framework/partial_tensor_shape.h\"",
          "20: #include \"tensorflow/core/framework/tensor_shape.pb.h\"",
          "21: #include \"tensorflow/core/lib/core/errors.h\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "18: #include \"tensorflow/core/framework/full_type_util.h\"",
          "20: #include \"tensorflow/core/framework/op_def.pb.h\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "166: void InferenceContext::PreInputInit(",
          "167:     const OpDef& op_def, const std::vector<const Tensor*>& input_tensors,",
          "168:     const std::vector<ShapeHandle>& input_tensors_as_shapes) {",
          "169:   input_tensors_ = input_tensors;",
          "170:   input_tensors_as_shapes_ = input_tensors_as_shapes;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "172:   const auto ret = full_type::SpecializeType(attrs_, op_def);",
          "173:   DCHECK(ret.status().ok()) << \"while instantiating types: \" << ret.status();",
          "174:   ret_types_ = ret.ValueOrDie();",
          "",
          "---------------"
        ],
        "tensorflow/core/framework/shape_inference.h||tensorflow/core/framework/shape_inference.h": [
          "File: tensorflow/core/framework/shape_inference.h -> tensorflow/core/framework/shape_inference.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "18: #include <vector>",
          "20: #include \"absl/memory/memory.h\"",
          "21: #include \"tensorflow/core/framework/node_def_util.h\"",
          "22: #include \"tensorflow/core/framework/tensor.h\"",
          "23: #include \"tensorflow/core/lib/core/errors.h\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "21: #include \"tensorflow/core/framework/full_type.pb.h\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "133: struct ShapeAndType {",
          "134:   ShapeAndType() {}",
          "135:   ShapeAndType(ShapeHandle s, DataType t) : shape(s), dtype(t) {}",
          "139:   ShapeHandle shape;",
          "140:   DataType dtype = DT_INVALID;",
          "144: };",
          "",
          "[Removed Lines]",
          "136:   ShapeAndType(ShapeHandle s, DataType t, SpecializedType specialized_t)",
          "137:       : shape(s), dtype(t), specialized_type(specialized_t) {}",
          "143:   SpecializedType specialized_type = ST_INVALID;",
          "",
          "[Added Lines]",
          "140:   ShapeAndType(ShapeHandle s, DataType t, FullTypeDef type_)",
          "141:       : shape(s), dtype(t), type(type_) {}",
          "145:   FullTypeDef type;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "325:   const AttrSlice& attrs() const { return attrs_; }",
          "329:   DimensionHandle Dim(ShapeHandle s, int64 idx) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "329:   const FullTypeDef& ret_types() const { return ret_types_; }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "754:   std::vector<std::unique_ptr<std::vector<ShapeAndType>>>",
          "755:       output_handle_shapes_and_types_;",
          "757:   const int graph_def_version_;",
          "758:   AttrSlice attrs_;",
          "759:   NameRangeMap input_name_map_;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "764:   FullTypeDef ret_types_;",
          "",
          "---------------"
        ],
        "tensorflow/core/framework/types.proto||tensorflow/core/framework/types.proto": [
          "File: tensorflow/core/framework/types.proto -> tensorflow/core/framework/types.proto",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "84: enum SpecializedType {",
          "86:   ST_INVALID = 0;",
          "88:   ST_TENSOR_LIST = 1;",
          "90:   ST_OPTIONAL = 2;",
          "91: }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "tensorflow/core/graph/node_builder.cc||tensorflow/core/graph/node_builder.cc": [
          "File: tensorflow/core/graph/node_builder.cc -> tensorflow/core/graph/node_builder.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "18: #include <unordered_map>",
          "19: #include <vector>",
          "21: #include \"tensorflow/core/framework/node_def_util.h\"",
          "22: #include \"tensorflow/core/framework/types.pb.h\"",
          "23: #include \"tensorflow/core/framework/versions.pb.h\"",
          "24: #include \"tensorflow/core/lib/core/errors.h\"",
          "25: #include \"tensorflow/core/protobuf/error_codes.pb.h\"",
          "27: namespace tensorflow {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "21: #include \"tensorflow/core/framework/full_type.pb.h\"",
          "22: #include \"tensorflow/core/framework/full_type_util.h\"",
          "27: #include \"tensorflow/core/platform/statusor.h\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "119: namespace {",
          "125:   const auto* op_registry = graph->op_registry();",
          "126:   const tensorflow::OpRegistrationData* op_reg_data;",
          "128:   if (op_reg_data->type_ctor == nullptr) {",
          "130:   }",
          "175: }",
          "177: }  // namespace",
          "",
          "[Removed Lines]",
          "121: Status run_type_constructor(Graph* graph, NodeDef* node_def, FullTypeDef* ft) {",
          "127:   TF_RETURN_IF_ERROR(op_registry->LookUp(node_def->op(), &op_reg_data));",
          "129:     return Status::OK();",
          "132:   ft->set_type_id(TFT_PRODUCT);",
          "134:   for (int i = 0; i < op_reg_data->op_def.output_arg_size(); i++) {",
          "135:     auto* t = ft->add_args();",
          "137:     t->CopyFrom(op_reg_data->op_def.output_arg(i).experimental_full_type());",
          "149:     for (int j = 0; j < t->args_size(); j++) {",
          "150:       auto* arg = t->mutable_args(i);",
          "151:       if (arg->type_id() == TFT_VAR) {",
          "152:         const auto& attr_val = node_def->attr().at(arg->s());",
          "153:         if (attr_val.value_case() == AttrValue::kList) {",
          "154:           const auto& attr_list = attr_val.list();",
          "155:           arg->set_type_id(TFT_PRODUCT);",
          "156:           for (int i = 0; i < attr_list.type_size(); i++) {",
          "157:             map_dtype_to_tensor(attr_list.type(i), arg->add_args());",
          "158:           }",
          "160:         } else if (attr_val.value_case() == AttrValue::kType) {",
          "161:           map_dtype_to_tensor(attr_val.type(), arg);",
          "163:         } else {",
          "164:           return Status(error::UNIMPLEMENTED,",
          "165:                         absl::StrCat(\"unknown attribute type\",",
          "166:                                      node_def->DebugString().c_str()));",
          "167:         }",
          "169:         arg->clear_s();",
          "170:       }",
          "171:     }",
          "172:   }",
          "174:   return Status::OK();",
          "",
          "[Added Lines]",
          "124: StatusOr<FullTypeDef> run_type_constructor(Graph* graph,",
          "125:                                            const NodeDef& node_def) {",
          "129:   TF_RETURN_IF_ERROR(op_registry->LookUp(node_def.op(), &op_reg_data));",
          "132:     return FullTypeDef();",
          "136:   return full_type::SpecializeType(AttrSlice(node_def), op_reg_data->op_def);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "189:   TF_RETURN_IF_ERROR(",
          "190:       CheckOpDeprecation(def_builder_.op_def(), graph->versions().producer()));",
          "196:   Node* node = graph->AddNode(std::move(node_def), &status);",
          "199:   if (ft.type_id() != TFT_UNSET) {",
          "200:     graph->SetNodeType(node->name(), ft);",
          "201:   }",
          "",
          "[Removed Lines]",
          "192:   FullTypeDef ft;",
          "193:   Status status = run_type_constructor(graph, &node_def, &ft);",
          "194:   if (!status.ok()) return status;",
          "197:   if (!status.ok()) return status;",
          "",
          "[Added Lines]",
          "154:   const auto ret = run_type_constructor(graph, node_def);",
          "155:   TF_RETURN_IF_ERROR(ret.status());",
          "157:   Status status;",
          "159:   TF_RETURN_IF_ERROR(status);",
          "161:   FullTypeDef ft = ret.ValueOrDie();",
          "",
          "---------------"
        ],
        "tensorflow/core/ops/dataset_ops.cc||tensorflow/core/ops/dataset_ops.cc": [
          "File: tensorflow/core/ops/dataset_ops.cc -> tensorflow/core/ops/dataset_ops.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "13: limitations under the License.",
          "15: #include \"tensorflow/core/framework/common_shape_fns.h\"",
          "16: #include \"tensorflow/core/framework/op.h\"",
          "17: #include \"tensorflow/core/framework/op_def_builder.h\"",
          "18: #include \"tensorflow/core/framework/shape_inference.h\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "16: #include \"tensorflow/core/framework/full_type.pb.h\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "867:     .Input(\"components: Toutput_types\")",
          "868:     .Output(\"optional: variant\")",
          "869:     .Attr(\"Toutput_types: list(type) >= 1\")",
          "870:     .SetShapeFn([](shape_inference::InferenceContext* c) {",
          "871:       std::vector<DataType> dtypes;",
          "872:       TF_RETURN_IF_ERROR(c->GetAttr(\"Toutput_types\", &dtypes));",
          "873:       c->set_output(0, c->Scalar());",
          "874:       std::vector<shape_inference::ShapeAndType> shapes_and_types;",
          "875:       shapes_and_types.reserve(c->num_inputs());",
          "876:       for (int i = 0; i < c->num_inputs(); ++i) {",
          "878:       }",
          "879:       c->set_output_handle_shapes_and_types(0, shapes_and_types);",
          "880:       return Status::OK();",
          "",
          "[Removed Lines]",
          "877:         shapes_and_types.emplace_back(c->input(i), dtypes[i], ST_OPTIONAL);",
          "",
          "[Added Lines]",
          "871:     .SetTypeConstructor(full_type::Unary(TFT_OPTIONAL, \"Toutput_types\"))",
          "878:       const FullTypeDef& ret_types = c->ret_types();",
          "892:         shapes_and_types.emplace_back(c->input(i), dtypes[i],",
          "893:                                       ret_types.args(0));",
          "",
          "---------------"
        ],
        "tensorflow/core/ops/list_ops.cc||tensorflow/core/ops/list_ops.cc": [
          "File: tensorflow/core/ops/list_ops.cc -> tensorflow/core/ops/list_ops.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "16: #include \"tensorflow/core/framework/common_shape_fns.h\"",
          "17: #include \"tensorflow/core/framework/op.h\"",
          "18: #include \"tensorflow/core/framework/shape_inference.h\"",
          "19: #include \"tensorflow/core/framework/types.pb.h\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "17: #include \"tensorflow/core/framework/full_type.pb.h\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "68:       shape_inference::ShapeHandle element_shape;",
          "69:       TF_RETURN_IF_ERROR(c->MakeShapeFromShapeTensorTreatScalarAsUnknownShape(",
          "70:           0, &element_shape));",
          "71:       c->set_output_handle_shapes_and_types(",
          "72:           0, std::vector<shape_inference::ShapeAndType>{",
          "74:       return Status::OK();",
          "75:     });",
          "",
          "[Removed Lines]",
          "73:                  {element_shape, element_dtype, ST_TENSOR_LIST}});",
          "",
          "[Added Lines]",
          "72:       const FullTypeDef& ret_types = c->ret_types();",
          "75:                  {element_shape, element_dtype, ret_types.args(0)}});",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "106:             c->Merge(element_shape, list_shape_type.shape, &ignored));",
          "107:         element_shape = list_shape_type.shape;",
          "108:       }",
          "109:       c->set_output_handle_shapes_and_types(",
          "110:           0, std::vector<shape_inference::ShapeAndType>{",
          "112:       return Status::OK();",
          "113:     });",
          "",
          "[Removed Lines]",
          "111:                  {element_shape, element_dtype, ST_TENSOR_LIST}});",
          "",
          "[Added Lines]",
          "111:       const FullTypeDef& ret_types = c->ret_types();",
          "114:                  {element_shape, element_dtype, ret_types.args(0)}});",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "155:             c->Merge(element_shape, list_shape_type.shape, &ignored));",
          "156:         element_shape = list_shape_type.shape;",
          "157:       }",
          "158:       c->set_output_handle_shapes_and_types(",
          "159:           0, std::vector<shape_inference::ShapeAndType>{",
          "161:       return Status::OK();",
          "162:     });",
          "",
          "[Removed Lines]",
          "160:                  {element_shape, element_dtype, ST_TENSOR_LIST}});",
          "",
          "[Added Lines]",
          "161:       const FullTypeDef& ret_types = c->ret_types();",
          "164:                  {element_shape, element_dtype, ret_types.args(0)}});",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "184:       if (IsValidTensorListHandleData(handle_data)) {",
          "185:         const shape_inference::ShapeAndType& list_shape_type =",
          "186:             (*handle_data)[0];",
          "187:         if (list_shape_type.dtype != element_dtype) {",
          "188:           return errors::InvalidArgument(",
          "189:               \"Trying to read from list with wrong element dtype. List has \"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "191:         if (list_shape_type.type.type_id() != TFT_ARRAY) {",
          "192:           return errors::InvalidArgument(\"Input agument must be a list.\");",
          "193:         }",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "348:       TF_RETURN_IF_ERROR(c->Merge(element_shape_from_tensor_shape,",
          "349:                                   element_shape,",
          "350:                                   &element_shape_from_tensor_shape));",
          "351:       c->set_output_handle_shapes_and_types(",
          "352:           0, std::vector<shape_inference::ShapeAndType>{",
          "354:       return Status::OK();",
          "355:     });",
          "",
          "[Removed Lines]",
          "353:                  {element_shape, element_dtype, ST_TENSOR_LIST}});",
          "",
          "[Added Lines]",
          "358:       const FullTypeDef& ret_types = c->ret_types();",
          "361:                  {element_shape, element_dtype, ret_types.args(0)}});",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "374:           1, &element_shape));",
          "375:       TF_RETURN_IF_ERROR(c->Merge(tensor_shape_except_first_dim, element_shape,",
          "376:                                   &tensor_shape_except_first_dim));",
          "377:       c->set_output_handle_shapes_and_types(",
          "378:           0, std::vector<shape_inference::ShapeAndType>{",
          "380:       return Status::OK();",
          "381:     });",
          "",
          "[Removed Lines]",
          "379:                  {element_shape, element_dtype, ST_TENSOR_LIST}});",
          "",
          "[Added Lines]",
          "385:       const FullTypeDef& ret_types = c->ret_types();",
          "388:                  {element_shape, element_dtype, ret_types.args(0)}});",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "415:           0, &element_shape));",
          "416:       DataType element_dtype;",
          "417:       TF_RETURN_IF_ERROR(c->GetAttr(\"element_dtype\", &element_dtype));",
          "418:       c->set_output_handle_shapes_and_types(",
          "419:           0, std::vector<shape_inference::ShapeAndType>{",
          "421:       return Status::OK();",
          "422:     });",
          "",
          "[Removed Lines]",
          "420:                  {element_shape, element_dtype, ST_TENSOR_LIST}});",
          "",
          "[Added Lines]",
          "427:       const FullTypeDef& ret_types = c->ret_types();",
          "430:                  {element_shape, element_dtype, ret_types.args(0)}});",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "489:             c->Merge(item_shape, list_shape_type.shape, &item_shape));",
          "490:         c->set_output_handle_shapes_and_types(0, *handle_data);",
          "491:       } else {",
          "492:         c->set_output_handle_shapes_and_types(",
          "494:       }",
          "495:       return Status::OK();",
          "496:     });",
          "",
          "[Removed Lines]",
          "493:             0, {{c->UnknownShape(), element_dtype, ST_TENSOR_LIST}});",
          "",
          "[Added Lines]",
          "502:         const FullTypeDef& ret_types = c->ret_types();",
          "504:             0, std::vector<shape_inference::ShapeAndType>{",
          "505:                    {c->UnknownShape(), element_dtype, ret_types.args(0)}});",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "542:       shape_inference::ShapeHandle element_shape;",
          "543:       TF_RETURN_IF_ERROR(c->MakeShapeFromShapeTensorTreatScalarAsUnknownShape(",
          "544:           2, &element_shape));",
          "545:       c->set_output_handle_shapes_and_types(",
          "547:       c->set_output(0, c->Scalar());",
          "548:       return Status::OK();",
          "549:     });",
          "",
          "[Removed Lines]",
          "546:           0, {{element_shape, element_dtype, ST_TENSOR_LIST}});",
          "",
          "[Added Lines]",
          "557:       const FullTypeDef& ret_types = c->ret_types();",
          "559:           0, std::vector<shape_inference::ShapeAndType>{",
          "560:                  {element_shape, element_dtype, ret_types.args(0)}});",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "563:       shape_inference::ShapeHandle element_shape;",
          "564:       TF_RETURN_IF_ERROR(c->MakeShapeFromShapeTensorTreatScalarAsUnknownShape(",
          "565:           2, &element_shape));",
          "566:       c->set_output_handle_shapes_and_types(",
          "568:       c->set_output(0, c->Scalar());",
          "569:       return Status::OK();",
          "570:     });",
          "",
          "[Removed Lines]",
          "567:           0, {{element_shape, element_dtype, ST_TENSOR_LIST}});",
          "",
          "[Added Lines]",
          "580:       const FullTypeDef& ret_types = c->ret_types();",
          "582:           0, std::vector<shape_inference::ShapeAndType>{",
          "583:                  {element_shape, element_dtype, ret_types.args(0)}});",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "592:         TF_RETURN_IF_ERROR(VerifyHandleData(c, *handle_data, element_dtype));",
          "593:         element_shape = GetElementShapeFromHandleData(*handle_data);",
          "594:       }",
          "595:       c->set_output_handle_shapes_and_types(",
          "597:       c->set_output(0, c->Scalar());",
          "598:       return Status::OK();",
          "599:     });",
          "",
          "[Removed Lines]",
          "596:           0, {{element_shape, element_dtype, ST_TENSOR_LIST}});",
          "",
          "[Added Lines]",
          "611:       const FullTypeDef& ret_types = c->ret_types();",
          "613:           0, std::vector<shape_inference::ShapeAndType>{",
          "614:                  {element_shape, element_dtype, ret_types.args(0)}});",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "618:       bool handle_data_a_nonempty = handle_data_a && !handle_data_a->empty();",
          "619:       bool handle_data_b_nonempty = handle_data_b && !handle_data_b->empty();",
          "620:       if (!(handle_data_a_nonempty || handle_data_b_nonempty)) {",
          "621:         c->set_output_handle_shapes_and_types(",
          "623:         return Status::OK();",
          "624:       }",
          "625:       shape_inference::ShapeAndType list_shape_type_a =",
          "",
          "[Removed Lines]",
          "622:             0, {{c->UnknownShape(), element_dtype, ST_TENSOR_LIST}});",
          "",
          "[Added Lines]",
          "639:         const FullTypeDef& ret_types = c->ret_types();",
          "641:             0, {{c->UnknownShape(), element_dtype, ret_types.args(0)}});",
          "",
          "---------------"
        ],
        "tensorflow/python/framework/cpp_shape_inference.proto||tensorflow/python/framework/cpp_shape_inference.proto": [
          "File: tensorflow/python/framework/cpp_shape_inference.proto -> tensorflow/python/framework/cpp_shape_inference.proto",
          "--- Hunk 1 ---",
          "[Context before]",
          "1: syntax = \"proto3\";",
          "3: package tensorflow;",
          "8: import \"tensorflow/core/framework/tensor_shape.proto\";",
          "10: message CppShapeInferenceResult {",
          "11:   message HandleShapeAndType {",
          "12:     TensorShapeProto shape = 1;",
          "13:     DataType dtype = 2;",
          "18:   }",
          "19:   message HandleData {",
          "20:     bool is_set = 1;",
          "",
          "[Removed Lines]",
          "4: option cc_enable_arenas = true;",
          "5: option go_package = \"github.com/tensorflow/tensorflow/tensorflow/go/python/framework/cpp_shape_inference_go_proto\";",
          "7: import \"tensorflow/core/framework/types.proto\";",
          "17:     SpecializedType specialized_type = 3;",
          "",
          "[Added Lines]",
          "5: import \"tensorflow/core/framework/full_type.proto\";",
          "7: import \"tensorflow/core/framework/types.proto\";",
          "9: option cc_enable_arenas = true;",
          "10: option go_package = \"github.com/tensorflow/tensorflow/tensorflow/go/python/framework/cpp_shape_inference_go_proto\";",
          "14:     reserved 3;",
          "18:     FullTypeDef type = 4;",
          "",
          "---------------"
        ],
        "tensorflow/python/kernel_tests/list_ops_test.py||tensorflow/python/kernel_tests/list_ops_test.py": [
          "File: tensorflow/python/kernel_tests/list_ops_test.py -> tensorflow/python/kernel_tests/list_ops_test.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "22: from absl.testing import parameterized",
          "23: import numpy as np  # pylint: disable=unused-import",
          "26: from tensorflow.python.client import session",
          "27: from tensorflow.python.eager import backprop",
          "28: from tensorflow.python.eager import context",
          "",
          "[Removed Lines]",
          "25: from tensorflow.core.framework import types_pb2",
          "",
          "[Added Lines]",
          "25: from tensorflow.core.framework import full_type_pb2",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1627:       l = list_ops.tensor_list_from_tensor(t, element_shape=[])",
          "1628:       handle_data = resource_variable_ops.get_eager_safe_handle_data(l)",
          "1629:       self.assertTrue(handle_data.is_set)",
          "1632:       return l",
          "1634:     tensor_list = func()",
          "1635:     handle_data = resource_variable_ops.get_eager_safe_handle_data(tensor_list)",
          "1636:     self.assertTrue(handle_data.is_set)",
          "1637:     self.assertEqual(dtypes.float32, handle_data.shape_and_type[0].dtype)",
          "1640:     element = list_ops.tensor_list_get_item(",
          "1641:         tensor_list, 0, element_dtype=dtypes.float32)",
          "1642:     self.assertAllEqual(element.shape.as_list(), [])",
          "",
          "[Removed Lines]",
          "1630:       self.assertEqual(types_pb2.ST_TENSOR_LIST,",
          "1631:                        handle_data.shape_and_type[0].specialized_type)",
          "1638:     self.assertEqual(types_pb2.ST_TENSOR_LIST,",
          "1639:                      handle_data.shape_and_type[0].specialized_type)",
          "",
          "[Added Lines]",
          "1630:       self.assertEqual(handle_data.shape_and_type[0].type.type_id,",
          "1631:                        full_type_pb2.TFT_ARRAY)",
          "1638:     self.assertEqual(handle_data.shape_and_type[0].type.type_id,",
          "1639:                      full_type_pb2.TFT_ARRAY)",
          "",
          "---------------"
        ],
        "tensorflow/python/kernel_tests/resource_variable_ops_test.py||tensorflow/python/kernel_tests/resource_variable_ops_test.py": [
          "File: tensorflow/python/kernel_tests/resource_variable_ops_test.py -> tensorflow/python/kernel_tests/resource_variable_ops_test.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "26: from absl.testing import parameterized",
          "27: import numpy as np",
          "29: from tensorflow.core.framework import tensor_pb2",
          "30: from tensorflow.python.eager import backprop",
          "31: from tensorflow.python.eager import context",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "29: from tensorflow.core.framework import full_type_pb2",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1371:     # NOTE(ebrevdo): shape_and_type lacks append() in some versions of protobuf.",
          "1372:     variant_shape_and_type_data.shape_and_type.extend([",
          "1373:         cpp_shape_inference_pb2.CppShapeInferenceResult.HandleShapeAndType(",
          "1375:     return variant_shape_and_type_data",
          "1377:   @def_function.function",
          "",
          "[Removed Lines]",
          "1374:             shape=stored_shape, dtype=stored_dtype)])",
          "",
          "[Added Lines]",
          "1375:             shape=stored_shape,",
          "1376:             dtype=stored_dtype,",
          "1377:             type=full_type_pb2.FullTypeDef())",
          "1378:     ])",
          "",
          "---------------"
        ],
        "tensorflow/python/ops/list_ops.py||tensorflow/python/ops/list_ops.py": [
          "File: tensorflow/python/ops/list_ops.py -> tensorflow/python/ops/list_ops.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "22: import numpy as np",
          "25: from tensorflow.python.framework import cpp_shape_inference_pb2",
          "26: from tensorflow.python.framework import dtypes",
          "27: from tensorflow.python.framework import ops",
          "",
          "[Removed Lines]",
          "24: from tensorflow.core.framework import types_pb2",
          "",
          "[Added Lines]",
          "24: from tensorflow.core.framework import full_type_pb2",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "73:       element_shape = tensor_shape.TensorShape(element_shape)",
          "74:     handle_data = cpp_shape_inference_pb2.CppShapeInferenceResult.HandleData()",
          "75:     handle_data.is_set = True",
          "76:     handle_data.shape_and_type.append(",
          "77:         cpp_shape_inference_pb2.CppShapeInferenceResult.HandleShapeAndType(",
          "78:             shape=element_shape.as_proto(),",
          "79:             dtype=element_dtype.as_datatype_enum,",
          "81:     list_handle._handle_data = handle_data  # pylint: disable=protected-access",
          "",
          "[Removed Lines]",
          "80:             specialized_type=types_pb2.ST_TENSOR_LIST))",
          "",
          "[Added Lines]",
          "76:     # TODO(b/191472076): This duplicates type inference. Clean up.",
          "81:             type=full_type_pb2.FullTypeDef(type_id=full_type_pb2.TFT_ARRAY)))",
          "",
          "---------------"
        ],
        "tensorflow/python/ops/parallel_for/pfor.py||tensorflow/python/ops/parallel_for/pfor.py": [
          "File: tensorflow/python/ops/parallel_for/pfor.py -> tensorflow/python/ops/parallel_for/pfor.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "28: import six",
          "30: from tensorflow.compiler.tf2xla.python import xla",
          "32: from tensorflow.python.eager import context",
          "33: from tensorflow.python.eager import def_function",
          "34: from tensorflow.python.eager import execute",
          "",
          "[Removed Lines]",
          "31: from tensorflow.core.framework import types_pb2",
          "",
          "[Added Lines]",
          "31: from tensorflow.core.framework import full_type_pb2",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "106:     # TODO(b/169968286): Identify all variant tensors (e.g. maps) and we can",
          "107:     # make this an error instead of assuming TensorLists have handle data.",
          "108:     return None  # Presumed not a TensorList/Optional",
          "113: def _parse_variant_shapes_and_types(t):",
          "",
          "[Removed Lines]",
          "109:   return (shapes_and_types[0].specialized_type == types_pb2.ST_TENSOR_LIST or",
          "110:           shapes_and_types[0].specialized_type == types_pb2.ST_OPTIONAL)",
          "",
          "[Added Lines]",
          "109:   type_id = shapes_and_types[0].type.type_id",
          "110:   return type_id in (full_type_pb2.TFT_ARRAY, full_type_pb2.TFT_OPTIONAL)",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "115:   shapes_and_types = _variant_handle_data(t)",
          "116:   if shapes_and_types is None or not shapes_and_types:",
          "117:     raise ValueError(\"Required handle data not set for {!r}\".format(t))",
          "119:     return shapes_and_types",
          "120:   else:",
          "122:       return shapes_and_types",
          "123:     else:",
          "124:       raise ValueError(",
          "",
          "[Removed Lines]",
          "118:   if shapes_and_types[0].specialized_type == types_pb2.ST_TENSOR_LIST:",
          "121:     if shapes_and_types[0].specialized_type != types_pb2.ST_INVALID:",
          "",
          "[Added Lines]",
          "118:   if shapes_and_types[0].type.type_id == full_type_pb2.TFT_ARRAY:",
          "121:     if shapes_and_types[0].type.type_id == full_type_pb2.TFT_UNSET:",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "135:   # of the variant.",
          "136:   if t.dtype == dtypes.variant:",
          "137:     shapes_and_types = _parse_variant_shapes_and_types(t)",
          "139:       if len(shapes_and_types) != 1:",
          "140:         raise ValueError(",
          "141:             \"Expected handle data of length 1, got {!r} of length {}\"",
          "",
          "[Removed Lines]",
          "138:     if shapes_and_types[0].specialized_type == types_pb2.ST_TENSOR_LIST:",
          "",
          "[Added Lines]",
          "138:     if shapes_and_types[0].type.type_id == full_type_pb2.TFT_ARRAY:",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "146:     else:",
          "147:       raise ValueError(",
          "148:           (\"Attempted to stack an unhandled variant-dtype tensor of \"",
          "150:   ones = array_ops.ones_like(array_ops.shape(t))",
          "151:   ones = array_ops.reshape(ones, [-1])",
          "152:   length = array_ops.reshape(length, [-1])",
          "",
          "[Removed Lines]",
          "149:            \"type {!r} ({!r})\").format(shapes_and_types[0].specialized_type, t))",
          "",
          "[Added Lines]",
          "149:            \"type {!r} ({!r})\").format(shapes_and_types[0].type, t))",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "9a86e5fa6cbbd8d2bd32b0080c7d0cae1c6225aa",
      "candidate_info": {
        "commit_hash": "9a86e5fa6cbbd8d2bd32b0080c7d0cae1c6225aa",
        "repo": "tensorflow/tensorflow",
        "commit_url": "https://github.com/tensorflow/tensorflow/commit/9a86e5fa6cbbd8d2bd32b0080c7d0cae1c6225aa",
        "files": [
          "tensorflow/core/framework/BUILD",
          "tensorflow/core/framework/full_type_util.cc",
          "tensorflow/core/framework/full_type_util.h",
          "tensorflow/core/framework/full_type_util_test.cc",
          "tensorflow/core/framework/shape_inference.cc",
          "tensorflow/core/framework/types.cc",
          "tensorflow/core/framework/types.h",
          "tensorflow/core/graph/graph.cc",
          "tensorflow/core/graph/node_builder_test.cc"
        ],
        "message": "Refactor SpecializeType to add support for the template expansion in TFT_FOR_EACH and more consistent substitution of variables from node attributes.\n\nPiperOrigin-RevId: 416033602\nChange-Id: Ie7e19fafe5f2fb5f3ba37f6c320e872ad94e3405",
        "before_after_code_files": [
          "tensorflow/core/framework/full_type_util.cc||tensorflow/core/framework/full_type_util.cc",
          "tensorflow/core/framework/full_type_util.h||tensorflow/core/framework/full_type_util.h",
          "tensorflow/core/framework/full_type_util_test.cc||tensorflow/core/framework/full_type_util_test.cc",
          "tensorflow/core/framework/shape_inference.cc||tensorflow/core/framework/shape_inference.cc",
          "tensorflow/core/framework/types.cc||tensorflow/core/framework/types.cc",
          "tensorflow/core/framework/types.h||tensorflow/core/framework/types.h",
          "tensorflow/core/graph/graph.cc||tensorflow/core/graph/graph.cc",
          "tensorflow/core/graph/node_builder_test.cc||tensorflow/core/graph/node_builder_test.cc"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "tensorflow/core/framework/full_type_util.cc||tensorflow/core/framework/full_type_util.cc"
          ],
          "candidate": [
            "tensorflow/core/framework/full_type_util.cc||tensorflow/core/framework/full_type_util.cc"
          ]
        }
      },
      "candidate_diff": {
        "tensorflow/core/framework/full_type_util.cc||tensorflow/core/framework/full_type_util.cc": [
          "File: tensorflow/core/framework/full_type_util.cc -> tensorflow/core/framework/full_type_util.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "18: #include <algorithm>",
          "19: #include <string>",
          "21: #include \"tensorflow/core/framework/attr_value.pb.h\"",
          "22: #include \"tensorflow/core/framework/full_type.pb.h\"",
          "23: #include \"tensorflow/core/framework/node_def.pb.h\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "21: #include \"absl/container/flat_hash_map.h\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "124:   };",
          "125: }",
          "174:     }",
          "175:   }",
          "178: }",
          "180: const FullTypeDef& GetArgDefaultUnset(const FullTypeDef& t, int i) {",
          "",
          "[Removed Lines]",
          "127: StatusOr<FullTypeDef> SpecializeType(const AttrSlice& attrs,",
          "128:                                      const OpDef& op_def) {",
          "129:   FullTypeDef ft;",
          "130:   ft.set_type_id(TFT_PRODUCT);",
          "132:   for (int i = 0; i < op_def.output_arg_size(); i++) {",
          "133:     auto* t = ft.add_args();",
          "147:     for (int j = 0; j < t->args_size(); j++) {",
          "148:       auto* arg = t->mutable_args(j);",
          "149:       if (arg->type_id() == TFT_VAR) {",
          "150:         const auto* attr = attrs.Find(arg->s());",
          "151:         if (attr == nullptr) {",
          "152:           return Status(",
          "153:               error::INVALID_ARGUMENT,",
          "154:               absl::StrCat(\"Could not find an attribute for key \", arg->s()));",
          "155:         }",
          "156:         if (attr->value_case() == AttrValue::kList) {",
          "157:           const auto& attr_list = attr->list();",
          "158:           arg->set_type_id(TFT_PRODUCT);",
          "159:           for (int i = 0; i < attr_list.type_size(); i++) {",
          "160:             map_dtype_to_tensor(attr_list.type(i), arg->add_args());",
          "161:           }",
          "163:         } else if (attr->value_case() == AttrValue::kType) {",
          "164:           map_dtype_to_tensor(attr->type(), arg);",
          "166:         } else {",
          "167:           return Status(error::UNIMPLEMENTED,",
          "168:                         absl::StrCat(\"unknown attribute type\",",
          "169:                                      attrs.DebugString(), \" key=\", arg->s()));",
          "170:         }",
          "172:         arg->clear_s();",
          "173:       }",
          "177:   return ft;",
          "",
          "[Added Lines]",
          "128: namespace {",
          "130: inline bool ReduceVariantTensor(FullTypeDef& t) {",
          "133:   if (t.type_id() == TFT_TENSOR && t.args_size() &&",
          "134:       t.args(0).type_id() == TFT_LEGACY_VARIANT) {",
          "135:     t.Clear();",
          "136:     return true;",
          "137:   }",
          "138:   return false;",
          "139: }",
          "141: typedef absl::flat_hash_map<StringPiece, const AttrValue*> AttrMap;",
          "143: inline Status SubstituteFromAttrs(AttrMap& attrs, FullTypeDef& t);",
          "145: Status SubstituteVar(AttrMap& attrs, FullTypeDef& t) {",
          "146:   DCHECK_EQ(t.args_size(), 0);",
          "148:   StringPiece var_name = t.s();",
          "149:   if (!attrs.contains(var_name)) {",
          "150:     return Status(",
          "151:         error::INVALID_ARGUMENT,",
          "152:         absl::StrCat(\"could not find an attribute for key '\", var_name, \"'\"));",
          "153:   }",
          "154:   const AttrValue* attr = attrs.at(var_name);",
          "156:   const auto attr_type = attr->value_case();",
          "157:   if (attr_type == AttrValue::kType) {",
          "158:     map_dtype_to_tensor(attr->type(), t);",
          "159:   } else if (attr_type == AttrValue::kList) {",
          "160:     const auto& attr_list = attr->list();",
          "161:     if (attr_list.type_size() != 1) {",
          "162:       return Status(error::UNIMPLEMENTED,",
          "163:                     absl::StrCat(\"lists or other than one type element\\n\",",
          "164:                                  attr_list.DebugString(), \"\\nkey=\", var_name));",
          "165:     }",
          "166:     map_dtype_to_tensor(attr_list.type(0), t);",
          "167:   } else {",
          "168:     return Status(error::UNIMPLEMENTED,",
          "169:                   absl::StrCat(\"unsupported attribute type \",",
          "170:                                attr->DebugString(), \" for name \", var_name));",
          "171:   }",
          "172:   t.clear_s();",
          "173:   return Status::OK();",
          "174: }",
          "176: Status SubstituteForEach(AttrMap& attrs, FullTypeDef& t) {",
          "177:   DCHECK_EQ(t.args_size(), 3);",
          "179:   const auto& cont = t.args(0);",
          "180:   const auto& tmpl = t.args(1);",
          "181:   const auto& t_var = t.args(2);",
          "183:   StringPiece var_name = t_var.s();",
          "184:   if (!attrs.contains(var_name)) {",
          "185:     return Status(",
          "186:         error::INVALID_ARGUMENT,",
          "187:         absl::StrCat(\"could not find an attribute for key '\", var_name, \"'\"));",
          "188:   }",
          "189:   const AttrValue* attr = attrs.at(var_name);",
          "191:   FullTypeDef result;",
          "192:   result.set_type_id(cont.type_id());",
          "194:   const auto attr_type = attr->value_case();",
          "195:   if (attr_type == AttrValue::kType) {",
          "196:     FullTypeDef* target = result.add_args();",
          "198:     TF_RETURN_WITH_CONTEXT_IF_ERROR(",
          "199:         SubstituteFromAttrs(attrs, *target), \"while substituting '\", var_name,",
          "200:         \"' from\\n\", attr->DebugString(), \"\\ninto \", target->DebugString());",
          "202:   } else if (attr_type == AttrValue::kList) {",
          "203:     const auto& attr_list = attr->list();",
          "204:     int tsize = attr_list.type_size();",
          "205:     if (tsize == 0) {",
          "206:       return Status(error::UNIMPLEMENTED,",
          "207:                     absl::StrCat(\"unsupported list attribute type\\n\",",
          "208:                                  attr_list.DebugString(), \"\\nkey=\", var_name));",
          "210:     AttrValue replacement;",
          "211:     attrs[var_name] = &replacement;",
          "212:     for (int i = 0; i < tsize; i++) {",
          "213:       replacement.set_type(attr_list.type(i));",
          "214:       FullTypeDef* target = result.add_args();",
          "216:       TF_RETURN_WITH_CONTEXT_IF_ERROR(SubstituteFromAttrs(attrs, *target),",
          "217:                                       \"while substituting '\", var_name,",
          "218:                                       \"' from\\n\", attr->DebugString(), \"\\n[\", i,",
          "219:                                       \"] into\\n\", target->DebugString());",
          "220:     }",
          "223:     attrs[var_name] = attr;",
          "225:   } else {",
          "226:     return Status(error::UNIMPLEMENTED,",
          "227:                   absl::StrCat(\"unsupported attribute type\\n\",",
          "228:                                attr->DebugString(), \"\\nfor name \", var_name));",
          "229:   }",
          "230:   t = result;",
          "231:   return Status::OK();",
          "232: }",
          "234: Status SubstituteGeneric(AttrMap& attrs, FullTypeDef& t) {",
          "235:   int nargs = t.args_size();",
          "236:   for (int j = 0; j < nargs; j++) {",
          "237:     TF_RETURN_WITH_CONTEXT_IF_ERROR(",
          "238:         SubstituteFromAttrs(attrs, *(t.mutable_args(j))),",
          "239:         \"while substituting arg \", j, \": \", t.args(j).DebugString());",
          "240:   }",
          "241:   return Status::OK();",
          "242: }",
          "244: inline Status SubstituteFromAttrs(AttrMap& attrs, FullTypeDef& t) {",
          "255:   switch (t.type_id()) {",
          "256:     case TFT_VAR:",
          "257:       return SubstituteVar(attrs, t);",
          "259:     case TFT_FOR_EACH:",
          "260:       return SubstituteForEach(attrs, t);",
          "262:     default:",
          "263:       return SubstituteGeneric(attrs, t);",
          "264:   }",
          "265:   return Status::OK();",
          "266: }",
          "268: }  // namespace",
          "270: Status SpecializeType(const AttrSlice& attrs, const OpDef& op_def,",
          "271:                       FullTypeDef& target) {",
          "272:   target.set_type_id(TFT_PRODUCT);",
          "274:   AttrMap map;",
          "275:   for (const auto& attr : attrs) {",
          "276:     map.emplace(attr.first, &attr.second);",
          "277:   }",
          "279:   int nargs = op_def.output_arg_size();",
          "280:   for (int i = 0; i < nargs; i++) {",
          "281:     auto& t = *(target.add_args());",
          "282:     t = op_def.output_arg(i).experimental_full_type();",
          "283:     TF_RETURN_WITH_CONTEXT_IF_ERROR(",
          "284:         SubstituteFromAttrs(map, t), \"while expanding vars of\\n\",",
          "285:         t.DebugString(), \"\\nfrom\\n\", attrs.SummarizeNode());",
          "286:     ReduceVariantTensor(t);",
          "289:   return Status::OK();",
          "",
          "---------------"
        ],
        "tensorflow/core/framework/full_type_util.h||tensorflow/core/framework/full_type_util.h": [
          "File: tensorflow/core/framework/full_type_util.h -> tensorflow/core/framework/full_type_util.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "73: const FullTypeDef& GetArgDefaultUnset(const FullTypeDef& t, int i);",
          "74: const FullTypeDef& GetArgDefaultAny(const FullTypeDef& t, int i);",
          "",
          "[Removed Lines]",
          "70: StatusOr<FullTypeDef> SpecializeType(const AttrSlice& attrs,",
          "71:                                      const OpDef& op_def);",
          "",
          "[Added Lines]",
          "70: Status SpecializeType(const AttrSlice& attrs, const OpDef& op_def,",
          "71:                       FullTypeDef& target);",
          "",
          "---------------"
        ],
        "tensorflow/core/framework/full_type_util_test.cc||tensorflow/core/framework/full_type_util_test.cc": [
          "File: tensorflow/core/framework/full_type_util_test.cc -> tensorflow/core/framework/full_type_util_test.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "134:   EXPECT_EQ(t.args(0).args(2).s(), \"T\");",
          "135: }",
          "137: TEST(GetArgDefaults, DefaultUnsetFromNoArgs) {",
          "138:   FullTypeDef t;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "137: TEST(SpecializeType, Fixed) {",
          "138:   OpDef op;",
          "139:   FullTypeDef* t = op.add_output_arg()->mutable_experimental_full_type();",
          "140:   t->set_type_id(TFT_ARRAY);",
          "141:   t->add_args()->set_type_id(TFT_TENSOR);",
          "142:   t->mutable_args(0)->add_args()->set_type_id(TFT_INT32);",
          "143:   t->add_args()->set_type_id(TFT_DATASET);",
          "144:   t->mutable_args(1)->add_args()->set_type_id(TFT_FLOAT);",
          "146:   AttrSlice empty;",
          "148:   FullTypeDef ft;",
          "149:   TF_ASSERT_OK(SpecializeType(empty, op, ft));",
          "151:   EXPECT_EQ(ft.type_id(), TFT_PRODUCT);",
          "152:   EXPECT_EQ(ft.args_size(), 1);",
          "154:   const FullTypeDef& t_actual = ft.args(0);",
          "155:   EXPECT_EQ(t_actual.type_id(), TFT_ARRAY);",
          "156:   EXPECT_EQ(t_actual.args_size(), 2);",
          "157:   EXPECT_EQ(t_actual.args(0).type_id(), TFT_TENSOR);",
          "158:   EXPECT_EQ(t_actual.args(0).args_size(), 1);",
          "159:   EXPECT_EQ(t_actual.args(0).args(0).type_id(), TFT_INT32);",
          "160:   EXPECT_EQ(t_actual.args(0).args(0).args_size(), 0);",
          "161:   EXPECT_EQ(t_actual.args(1).type_id(), TFT_DATASET);",
          "162:   EXPECT_EQ(t_actual.args(1).args_size(), 1);",
          "163:   EXPECT_EQ(t_actual.args(1).args(0).type_id(), TFT_FLOAT);",
          "164:   EXPECT_EQ(t_actual.args(1).args(0).args_size(), 0);",
          "165: }",
          "167: TEST(SpecializeType, VarExpandsFromSingleAttribute) {",
          "168:   OpDef op;",
          "169:   FullTypeDef* t = op.add_output_arg()->mutable_experimental_full_type();",
          "170:   t->set_type_id(TFT_ARRAY);",
          "171:   t->add_args()->set_type_id(TFT_TENSOR);",
          "172:   t->mutable_args(0)->add_args()->set_type_id(TFT_VAR);",
          "173:   t->mutable_args(0)->mutable_args(0)->set_s(\"T\");",
          "175:   AttrValue attr;",
          "176:   attr.set_type(DT_INT32);",
          "177:   NodeDef ndef;",
          "178:   (*ndef.mutable_attr())[\"T\"] = attr;",
          "180:   AttrSlice attrs(ndef);",
          "182:   FullTypeDef ft;",
          "183:   TF_ASSERT_OK(SpecializeType(attrs, op, ft));",
          "185:   EXPECT_EQ(ft.type_id(), TFT_PRODUCT);",
          "186:   EXPECT_EQ(ft.args_size(), 1);",
          "188:   const FullTypeDef& t_actual = ft.args(0);",
          "189:   EXPECT_EQ(t_actual.type_id(), TFT_ARRAY);",
          "190:   EXPECT_EQ(t_actual.args_size(), 1);",
          "191:   EXPECT_EQ(t_actual.args(0).type_id(), TFT_TENSOR);",
          "192:   EXPECT_EQ(t_actual.args(0).args_size(), 1);",
          "193:   EXPECT_EQ(t_actual.args(0).args(0).type_id(), TFT_INT32);",
          "194:   EXPECT_EQ(t_actual.args(0).args(0).args_size(), 0);",
          "195: }",
          "197: TEST(SpecializeType, VarExpandsFromSingleElementTypeListAttribute) {",
          "198:   OpDef op;",
          "199:   FullTypeDef* t = op.add_output_arg()->mutable_experimental_full_type();",
          "200:   t->set_type_id(TFT_ARRAY);",
          "201:   t->add_args()->set_type_id(TFT_TENSOR);",
          "202:   t->mutable_args(0)->add_args()->set_type_id(TFT_VAR);",
          "203:   t->mutable_args(0)->mutable_args(0)->set_s(\"T\");",
          "205:   AttrValue attr;",
          "206:   attr.mutable_list()->add_type(DT_INT32);",
          "207:   NodeDef ndef;",
          "208:   (*ndef.mutable_attr())[\"T\"] = attr;",
          "210:   AttrSlice attrs(ndef);",
          "212:   FullTypeDef ft;",
          "213:   TF_ASSERT_OK(SpecializeType(attrs, op, ft));",
          "215:   EXPECT_EQ(ft.type_id(), TFT_PRODUCT);",
          "216:   EXPECT_EQ(ft.args_size(), 1);",
          "218:   const FullTypeDef& t_actual = ft.args(0);",
          "219:   EXPECT_EQ(t_actual.type_id(), TFT_ARRAY);",
          "220:   EXPECT_EQ(t_actual.args_size(), 1);",
          "221:   EXPECT_EQ(t_actual.args(0).type_id(), TFT_TENSOR);",
          "222:   EXPECT_EQ(t_actual.args(0).args_size(), 1);",
          "223:   EXPECT_EQ(t_actual.args(0).args(0).type_id(), TFT_INT32);",
          "224:   EXPECT_EQ(t_actual.args(0).args(0).args_size(), 0);",
          "225: }",
          "227: TEST(SpecializeType, VarRejectsMultipleElementTypeListAttribute) {",
          "228:   OpDef op;",
          "229:   FullTypeDef* t = op.add_output_arg()->mutable_experimental_full_type();",
          "230:   t->set_type_id(TFT_ARRAY);",
          "231:   t->add_args()->set_type_id(TFT_TENSOR);",
          "232:   t->mutable_args(0)->add_args()->set_type_id(TFT_VAR);",
          "233:   t->mutable_args(0)->mutable_args(0)->set_s(\"T\");",
          "235:   AttrValue attr;",
          "236:   attr.mutable_list()->add_type(DT_INT32);",
          "237:   attr.mutable_list()->add_type(DT_FLOAT);",
          "238:   NodeDef ndef;",
          "239:   (*ndef.mutable_attr())[\"T\"] = attr;",
          "241:   AttrSlice attrs(ndef);",
          "243:   FullTypeDef ft;",
          "244:   EXPECT_FALSE(SpecializeType(attrs, op, ft).ok());",
          "245: }",
          "247: TEST(SpecializeType, VarRejectsEmptyTypeListAttribute) {",
          "248:   OpDef op;",
          "249:   FullTypeDef* t = op.add_output_arg()->mutable_experimental_full_type();",
          "250:   t->set_type_id(TFT_ARRAY);",
          "251:   t->add_args()->set_type_id(TFT_TENSOR);",
          "252:   t->mutable_args(0)->add_args()->set_type_id(TFT_VAR);",
          "253:   t->mutable_args(0)->mutable_args(0)->set_s(\"T\");",
          "255:   AttrValue attr;",
          "256:   attr.mutable_list();",
          "257:   NodeDef ndef;",
          "258:   (*ndef.mutable_attr())[\"T\"] = attr;",
          "260:   AttrSlice attrs(ndef);",
          "262:   FullTypeDef ft;",
          "263:   EXPECT_FALSE(SpecializeType(attrs, op, ft).ok());",
          "264: }",
          "266: TEST(SpecializeType, ForEachExpandsFromSingleAttribute) {",
          "267:   OpDef op;",
          "268:   FullTypeDef* t = op.add_output_arg()->mutable_experimental_full_type();",
          "269:   t->set_type_id(TFT_FOR_EACH);",
          "270:   t->add_args()->set_type_id(TFT_PRODUCT);",
          "271:   t->add_args()->set_type_id(TFT_TENSOR);",
          "272:   t->mutable_args(1)->add_args()->set_type_id(TFT_VAR);",
          "273:   t->mutable_args(1)->mutable_args(0)->set_s(\"T\");",
          "274:   t->add_args()->set_type_id(TFT_VAR);",
          "275:   t->mutable_args(2)->set_s(\"T\");",
          "277:   AttrValue attr;",
          "278:   attr.set_type(DT_INT32);",
          "279:   NodeDef ndef;",
          "280:   (*ndef.mutable_attr())[\"T\"] = attr;",
          "282:   AttrSlice attrs(ndef);",
          "284:   FullTypeDef ft;",
          "285:   TF_ASSERT_OK(SpecializeType(attrs, op, ft));",
          "287:   EXPECT_EQ(ft.type_id(), TFT_PRODUCT);",
          "288:   EXPECT_EQ(ft.args_size(), 1);",
          "290:   const FullTypeDef& t_actual = ft.args(0);",
          "291:   EXPECT_EQ(t_actual.type_id(), TFT_PRODUCT);",
          "292:   EXPECT_EQ(t_actual.args_size(), 1);",
          "293:   EXPECT_EQ(t_actual.args(0).type_id(), TFT_TENSOR);",
          "294:   EXPECT_EQ(t_actual.args(0).args_size(), 1);",
          "295:   EXPECT_EQ(t_actual.args(0).args(0).type_id(), TFT_INT32);",
          "296:   EXPECT_EQ(t_actual.args(0).args(0).args_size(), 0);",
          "297: }",
          "299: TEST(SpecializeType, ForEachExpandsFromListAttribute) {",
          "300:   OpDef op;",
          "301:   FullTypeDef* t = op.add_output_arg()->mutable_experimental_full_type();",
          "302:   t->set_type_id(TFT_FOR_EACH);",
          "303:   t->add_args()->set_type_id(TFT_PRODUCT);",
          "304:   t->add_args()->set_type_id(TFT_TENSOR);",
          "305:   t->mutable_args(1)->add_args()->set_type_id(TFT_VAR);",
          "306:   t->mutable_args(1)->mutable_args(0)->set_s(\"T\");",
          "307:   t->add_args()->set_type_id(TFT_VAR);",
          "308:   t->mutable_args(2)->set_s(\"T\");",
          "310:   AttrValue attr;",
          "311:   attr.mutable_list()->add_type(DT_INT32);",
          "312:   attr.mutable_list()->add_type(DT_FLOAT);",
          "313:   NodeDef ndef;",
          "314:   (*ndef.mutable_attr())[\"T\"] = attr;",
          "316:   AttrSlice attrs(ndef);",
          "318:   FullTypeDef ft;",
          "319:   TF_ASSERT_OK(SpecializeType(attrs, op, ft));",
          "321:   EXPECT_EQ(ft.type_id(), TFT_PRODUCT);",
          "322:   EXPECT_EQ(ft.args_size(), 1);",
          "324:   const FullTypeDef& t_actual = ft.args(0);",
          "325:   EXPECT_EQ(t_actual.type_id(), TFT_PRODUCT);",
          "326:   EXPECT_EQ(t_actual.args_size(), 2);",
          "327:   EXPECT_EQ(t_actual.args(0).type_id(), TFT_TENSOR);",
          "328:   EXPECT_EQ(t_actual.args(0).args_size(), 1);",
          "329:   EXPECT_EQ(t_actual.args(0).args(0).type_id(), TFT_INT32);",
          "330:   EXPECT_EQ(t_actual.args(0).args(0).args_size(), 0);",
          "331:   EXPECT_EQ(t_actual.args(1).type_id(), TFT_TENSOR);",
          "332:   EXPECT_EQ(t_actual.args(1).args_size(), 1);",
          "333:   EXPECT_EQ(t_actual.args(1).args(0).type_id(), TFT_FLOAT);",
          "334:   EXPECT_EQ(t_actual.args(1).args(0).args_size(), 0);",
          "335: }",
          "337: TEST(SpecializeType, ForEachDistributesNestedVar) {",
          "338:   OpDef op;",
          "339:   FullTypeDef* t = op.add_output_arg()->mutable_experimental_full_type();",
          "340:   t->set_type_id(TFT_FOR_EACH);",
          "341:   t->add_args()->set_type_id(TFT_PRODUCT);",
          "342:   t->add_args()->set_type_id(TFT_TENSOR);",
          "343:   t->mutable_args(1)->add_args()->set_type_id(TFT_VAR);",
          "344:   t->mutable_args(1)->mutable_args(0)->set_s(\"ForEachTarget\");",
          "345:   t->mutable_args(1)->add_args()->set_type_id(TFT_VAR);",
          "346:   t->mutable_args(1)->mutable_args(1)->set_s(\"GlobalVar\");",
          "347:   t->add_args()->set_type_id(TFT_VAR);",
          "348:   t->mutable_args(2)->set_s(\"ForEachTarget\");",
          "350:   NodeDef ndef;",
          "351:   AttrValue attr;",
          "353:   attr.mutable_list()->add_type(DT_INT32);",
          "354:   attr.mutable_list()->add_type(DT_INT64);",
          "355:   (*ndef.mutable_attr())[\"ForEachTarget\"] = attr;",
          "357:   attr.set_type(DT_FLOAT);",
          "358:   (*ndef.mutable_attr())[\"GlobalVar\"] = attr;",
          "360:   AttrSlice attrs(ndef);",
          "362:   FullTypeDef ft;",
          "363:   TF_ASSERT_OK(SpecializeType(attrs, op, ft));",
          "365:   EXPECT_EQ(ft.type_id(), TFT_PRODUCT);",
          "366:   EXPECT_EQ(ft.args_size(), 1);",
          "368:   const FullTypeDef& t_actual = ft.args(0);",
          "369:   EXPECT_EQ(t_actual.type_id(), TFT_PRODUCT);",
          "370:   EXPECT_EQ(t_actual.args_size(), 2);",
          "371:   EXPECT_EQ(t_actual.args(0).type_id(), TFT_TENSOR);",
          "372:   EXPECT_EQ(t_actual.args(0).args_size(), 2);",
          "373:   EXPECT_EQ(t_actual.args(0).args(0).type_id(), TFT_INT32);",
          "374:   EXPECT_EQ(t_actual.args(0).args(0).args_size(), 0);",
          "375:   EXPECT_EQ(t_actual.args(0).args(1).type_id(), TFT_FLOAT);",
          "376:   EXPECT_EQ(t_actual.args(0).args(1).args_size(), 0);",
          "377:   EXPECT_EQ(t_actual.args(1).type_id(), TFT_TENSOR);",
          "378:   EXPECT_EQ(t_actual.args(1).args_size(), 2);",
          "379:   EXPECT_EQ(t_actual.args(1).args(0).type_id(), TFT_INT64);",
          "380:   EXPECT_EQ(t_actual.args(1).args(0).args_size(), 0);",
          "381:   EXPECT_EQ(t_actual.args(1).args(1).type_id(), TFT_FLOAT);",
          "382:   EXPECT_EQ(t_actual.args(1).args(1).args_size(), 0);",
          "383: }",
          "385: TEST(SpecializeType, ForEachDistributesNestedForEach) {",
          "386:   OpDef op;",
          "387:   FullTypeDef* t = op.add_output_arg()->mutable_experimental_full_type();",
          "388:   t->set_type_id(TFT_FOR_EACH);",
          "389:   t->add_args()->set_type_id(TFT_PRODUCT);",
          "391:   FullTypeDef* inner = t->add_args();",
          "392:   inner->set_type_id(TFT_FOR_EACH);",
          "393:   inner->add_args()->set_type_id(TFT_PRODUCT);",
          "394:   inner->add_args()->set_type_id(TFT_ARRAY);",
          "395:   inner->mutable_args(1)->add_args()->set_type_id(TFT_VAR);",
          "396:   inner->mutable_args(1)->mutable_args(0)->set_s(\"InnerForEach\");",
          "397:   inner->mutable_args(1)->add_args()->set_type_id(TFT_VAR);",
          "398:   inner->mutable_args(1)->mutable_args(1)->set_s(\"OuterForEach\");",
          "399:   inner->add_args()->set_type_id(TFT_VAR);",
          "400:   inner->mutable_args(2)->set_s(\"InnerForEach\");",
          "402:   t->add_args()->set_type_id(TFT_VAR);",
          "403:   t->mutable_args(2)->set_s(\"OuterForEach\");",
          "405:   NodeDef ndef;",
          "406:   AttrValue attr;",
          "408:   attr.mutable_list()->add_type(DT_INT32);",
          "409:   attr.mutable_list()->add_type(DT_INT64);",
          "410:   (*ndef.mutable_attr())[\"OuterForEach\"] = attr;",
          "412:   attr.set_type(DT_FLOAT);",
          "413:   (*ndef.mutable_attr())[\"InnerForEach\"] = attr;",
          "415:   AttrSlice attrs(ndef);",
          "417:   FullTypeDef ft;",
          "418:   TF_ASSERT_OK(SpecializeType(attrs, op, ft));",
          "420:   EXPECT_EQ(ft.type_id(), TFT_PRODUCT);",
          "421:   EXPECT_EQ(ft.args_size(), 1);",
          "423:   const FullTypeDef& t_actual = ft.args(0);",
          "424:   EXPECT_EQ(t_actual.type_id(), TFT_PRODUCT);",
          "425:   EXPECT_EQ(t_actual.args_size(), 2);",
          "426:   EXPECT_EQ(t_actual.args(0).type_id(), TFT_PRODUCT);",
          "427:   EXPECT_EQ(t_actual.args(0).args_size(), 1);",
          "428:   EXPECT_EQ(t_actual.args(0).args(0).type_id(), TFT_ARRAY);",
          "429:   EXPECT_EQ(t_actual.args(0).args(0).args_size(), 2);",
          "430:   EXPECT_EQ(t_actual.args(0).args(0).args(0).type_id(), TFT_FLOAT);",
          "431:   EXPECT_EQ(t_actual.args(0).args(0).args(0).args_size(), 0);",
          "432:   EXPECT_EQ(t_actual.args(0).args(0).args(1).type_id(), TFT_INT32);",
          "433:   EXPECT_EQ(t_actual.args(0).args(0).args(1).args_size(), 0);",
          "434:   EXPECT_EQ(t_actual.args(1).type_id(), TFT_PRODUCT);",
          "435:   EXPECT_EQ(t_actual.args(1).args_size(), 1);",
          "436:   EXPECT_EQ(t_actual.args(1).args(0).type_id(), TFT_ARRAY);",
          "437:   EXPECT_EQ(t_actual.args(1).args(0).args_size(), 2);",
          "438:   EXPECT_EQ(t_actual.args(1).args(0).args(0).type_id(), TFT_FLOAT);",
          "439:   EXPECT_EQ(t_actual.args(1).args(0).args(0).args_size(), 0);",
          "440:   EXPECT_EQ(t_actual.args(1).args(0).args(1).type_id(), TFT_INT64);",
          "441:   EXPECT_EQ(t_actual.args(1).args(0).args(1).args_size(), 0);",
          "442: }",
          "444: TEST(SpecializeType, ForEachOverridesTargetOfNestedForEach) {",
          "445:   OpDef op;",
          "446:   FullTypeDef* t = op.add_output_arg()->mutable_experimental_full_type();",
          "447:   t->set_type_id(TFT_FOR_EACH);",
          "448:   t->add_args()->set_type_id(TFT_PRODUCT);",
          "450:   FullTypeDef* inner = t->add_args();",
          "451:   inner->set_type_id(TFT_FOR_EACH);",
          "452:   inner->add_args()->set_type_id(TFT_PRODUCT);",
          "453:   inner->add_args()->set_type_id(TFT_ARRAY);",
          "454:   inner->mutable_args(1)->add_args()->set_type_id(TFT_VAR);",
          "455:   inner->mutable_args(1)->mutable_args(0)->set_s(\"T\");",
          "456:   inner->add_args()->set_type_id(TFT_VAR);",
          "457:   inner->mutable_args(2)->set_s(\"T\");",
          "459:   t->add_args()->set_type_id(TFT_VAR);",
          "460:   t->mutable_args(2)->set_s(\"T\");",
          "462:   NodeDef ndef;",
          "463:   AttrValue attr;",
          "465:   attr.mutable_list()->add_type(DT_FLOAT);",
          "466:   attr.mutable_list()->add_type(DT_DOUBLE);",
          "467:   (*ndef.mutable_attr())[\"T\"] = attr;",
          "469:   AttrSlice attrs(ndef);",
          "471:   FullTypeDef ft;",
          "472:   TF_ASSERT_OK(SpecializeType(attrs, op, ft));",
          "474:   EXPECT_EQ(ft.type_id(), TFT_PRODUCT);",
          "475:   EXPECT_EQ(ft.args_size(), 1);",
          "477:   const FullTypeDef& t_actual = ft.args(0);",
          "478:   EXPECT_EQ(t_actual.type_id(), TFT_PRODUCT);",
          "479:   EXPECT_EQ(t_actual.args_size(), 2);",
          "480:   EXPECT_EQ(t_actual.args(0).type_id(), TFT_PRODUCT);",
          "481:   EXPECT_EQ(t_actual.args(0).args_size(), 1);",
          "482:   EXPECT_EQ(t_actual.args(0).args(0).type_id(), TFT_ARRAY);",
          "483:   EXPECT_EQ(t_actual.args(0).args(0).args_size(), 1);",
          "484:   EXPECT_EQ(t_actual.args(0).args(0).args(0).type_id(), TFT_FLOAT);",
          "485:   EXPECT_EQ(t_actual.args(0).args(0).args(0).args_size(), 0);",
          "486:   EXPECT_EQ(t_actual.args(1).type_id(), TFT_PRODUCT);",
          "487:   EXPECT_EQ(t_actual.args(1).args_size(), 1);",
          "488:   EXPECT_EQ(t_actual.args(1).args(0).type_id(), TFT_ARRAY);",
          "489:   EXPECT_EQ(t_actual.args(1).args(0).args_size(), 1);",
          "490:   EXPECT_EQ(t_actual.args(1).args(0).args(0).type_id(), TFT_DOUBLE);",
          "491:   EXPECT_EQ(t_actual.args(1).args(0).args(0).args_size(), 0);",
          "492: }",
          "",
          "---------------"
        ],
        "tensorflow/core/framework/shape_inference.cc||tensorflow/core/framework/shape_inference.cc": [
          "File: tensorflow/core/framework/shape_inference.cc -> tensorflow/core/framework/shape_inference.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "171:     const OpDef& op_def, const std::vector<const Tensor*>& input_tensors,",
          "172:     const std::vector<ShapeHandle>& input_tensors_as_shapes) {",
          "177:     return;",
          "178:   }",
          "181:   input_tensors_ = input_tensors;",
          "182:   input_tensors_as_shapes_ = input_tensors_as_shapes;",
          "",
          "[Removed Lines]",
          "174:   const auto ret = full_type::SpecializeType(attrs_, op_def);",
          "175:   if (!ret.status().ok()) {",
          "176:     construction_status_ = ret.status();",
          "179:   ret_types_ = ret.ValueOrDie();",
          "",
          "[Added Lines]",
          "174:   Status s = full_type::SpecializeType(attrs_, op_def, ret_types_);",
          "175:   if (!s.ok()) {",
          "176:     construction_status_ = s;",
          "",
          "---------------"
        ],
        "tensorflow/core/framework/types.cc||tensorflow/core/framework/types.cc": [
          "File: tensorflow/core/framework/types.cc -> tensorflow/core/framework/types.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "46:     {DT_HALF, TFT_HALF},",
          "47:     {DT_UINT32, TFT_UINT32},",
          "48:     {DT_UINT64, TFT_UINT64},",
          "49: });",
          "55:   const auto& mapped = DT_TO_FT->find(dtype);",
          "57:   if (mapped != DT_TO_FT->end()) {",
          "61:   }",
          "62: }",
          "",
          "[Removed Lines]",
          "51: void map_dtype_to_tensor(const DataType& dtype, FullTypeDef* t) {",
          "52:   t->set_type_id(TFT_TENSOR);",
          "56:   auto* arg = t->add_args();",
          "58:     arg->set_type_id(mapped->second);",
          "59:   } else {",
          "60:     arg->set_type_id(TFT_ANY);",
          "",
          "[Added Lines]",
          "49:     {DT_VARIANT, TFT_LEGACY_VARIANT},",
          "52: void map_dtype_to_tensor(const DataType& dtype, FullTypeDef& t) {",
          "53:   t.Clear();",
          "61:     t.set_type_id(mapped->second);",
          "",
          "---------------"
        ],
        "tensorflow/core/framework/types.h||tensorflow/core/framework/types.h": [
          "File: tensorflow/core/framework/types.h -> tensorflow/core/framework/types.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "562:   }",
          "563: };",
          "568: }  // namespace tensorflow",
          "",
          "[Removed Lines]",
          "566: void map_dtype_to_tensor(const DataType& dtype, FullTypeDef* t);",
          "",
          "[Added Lines]",
          "566: void map_dtype_to_tensor(const DataType& dtype, FullTypeDef& t);",
          "",
          "---------------"
        ],
        "tensorflow/core/graph/graph.cc||tensorflow/core/graph/graph.cc": [
          "File: tensorflow/core/graph/graph.cc -> tensorflow/core/graph/graph.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "573:   if (op_reg_data->type_ctor != nullptr) {",
          "574:     VLOG(3) << \"AddNode: found type constructor for \" << node_def.name();",
          "580:       VLOG(3) << \"AddNode: type inference failed for \" << node_def.name()",
          "582:       return nullptr;",
          "583:     }",
          "588:   } else {",
          "589:     VLOG(3) << \"AddNode: no type constructor for \" << node_def.name();",
          "590:   }",
          "",
          "[Removed Lines]",
          "575:     const auto ctor_type =",
          "576:         full_type::SpecializeType(AttrSlice(node_def), op_reg_data->op_def);",
          "577:     if (!ctor_type.ok()) {",
          "579:                                         ctor_type.status().ToString());",
          "581:               << \": \" << status->ToString();",
          "584:     const FullTypeDef ctor_typedef = ctor_type.ValueOrDie();",
          "585:     if (ctor_typedef.type_id() != TFT_UNSET) {",
          "587:     }",
          "",
          "[Added Lines]",
          "575:     Status s =",
          "576:         full_type::SpecializeType(AttrSlice(node_def), op_reg_data->op_def,",
          "578:     if (!s.ok()) {",
          "581:               << \": \" << s;",
          "",
          "---------------"
        ],
        "tensorflow/core/graph/node_builder_test.cc||tensorflow/core/graph/node_builder_test.cc": [
          "File: tensorflow/core/graph/node_builder_test.cc -> tensorflow/core/graph/node_builder_test.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "97:   ASSERT_EQ(ft.args_size(), 1);",
          "98:   auto ot = ft.args(0);",
          "99:   ASSERT_EQ(ot.type_id(), TFT_ARRAY);",
          "103: }",
          "105: REGISTER_OP(\"TypeInferenceOpTensorOutput\")",
          "",
          "[Removed Lines]",
          "100:   ASSERT_EQ(ot.args(0).type_id(), TFT_TENSOR);",
          "101:   ASSERT_EQ(ot.args(0).args(0).type_id(), TFT_FLOAT);",
          "102:   ASSERT_EQ(ot.args(0).args(0).args().size(), 0);",
          "",
          "[Added Lines]",
          "100:   ASSERT_EQ(ot.args(0).type_id(), TFT_FLOAT);",
          "101:   ASSERT_EQ(ot.args(0).args().size(), 0);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "189: TEST(NodeBuilderTest, TypeConstructorListType) {",
          "190:   Graph graph(OpRegistry::Global());",
          "191:   Node* node;",
          "193:                    .Attr(\"out_types\", {DT_FLOAT, DT_INT32})",
          "205: }",
          "207: }  // namespace",
          "",
          "[Removed Lines]",
          "192:   TF_EXPECT_OK(NodeBuilder(\"op\", \"FullTypeOpListType\")",
          "194:                    .Finalize(&graph, &node));",
          "195:   ASSERT_TRUE(node->def().has_experimental_type());",
          "196:   const FullTypeDef& ft = node->def().experimental_type();",
          "197:   ASSERT_EQ(ft.type_id(), TFT_PRODUCT);",
          "198:   ASSERT_EQ(ft.args_size(), 1);",
          "199:   auto ot = ft.args(0);",
          "200:   ASSERT_EQ(ot.type_id(), TFT_ARRAY);",
          "201:   ASSERT_EQ(ot.args(0).type_id(), TFT_PRODUCT);",
          "202:   ASSERT_EQ(ot.args(0).args(0).type_id(), TFT_TENSOR);",
          "203:   ASSERT_EQ(ot.args(0).args(0).args(0).type_id(), TFT_FLOAT);",
          "204:   ASSERT_EQ(ot.args(0).args(0).args(0).args().size(), 0);",
          "",
          "[Added Lines]",
          "191:   ASSERT_FALSE(NodeBuilder(\"op\", \"FullTypeOpListType\")",
          "193:                    .Finalize(&graph, &node)",
          "194:                    .ok());",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "acde01943417fbaf6dac1fdee806eb9e33e746b0",
      "candidate_info": {
        "commit_hash": "acde01943417fbaf6dac1fdee806eb9e33e746b0",
        "repo": "tensorflow/tensorflow",
        "commit_url": "https://github.com/tensorflow/tensorflow/commit/acde01943417fbaf6dac1fdee806eb9e33e746b0",
        "files": [
          "tensorflow/core/framework/full_type_util.cc",
          "tensorflow/core/framework/full_type_util_test.cc"
        ],
        "message": "Strengthen input verification for SpecializeType by replacing DCHECK with explicit test/status return.\n\nPiperOrigin-RevId: 453436708",
        "before_after_code_files": [
          "tensorflow/core/framework/full_type_util.cc||tensorflow/core/framework/full_type_util.cc",
          "tensorflow/core/framework/full_type_util_test.cc||tensorflow/core/framework/full_type_util_test.cc"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "tensorflow/core/framework/full_type_util.cc||tensorflow/core/framework/full_type_util.cc"
          ],
          "candidate": [
            "tensorflow/core/framework/full_type_util.cc||tensorflow/core/framework/full_type_util.cc"
          ]
        }
      },
      "candidate_diff": {
        "tensorflow/core/framework/full_type_util.cc||tensorflow/core/framework/full_type_util.cc": [
          "File: tensorflow/core/framework/full_type_util.cc -> tensorflow/core/framework/full_type_util.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "164: }",
          "166: Status SubstituteForEach(AttrMap& attrs, FullTypeDef& t) {",
          "169:   const auto& cont = t.args(0);",
          "170:   const auto& tmpl = t.args(1);",
          "",
          "[Removed Lines]",
          "167:   DCHECK_EQ(t.args_size(), 3);",
          "",
          "[Added Lines]",
          "167:   if (t.args_size() != 3) {",
          "168:     return Status(error::INVALID_ARGUMENT,",
          "169:                   absl::StrCat(\"illegal FOR_EACH type, expected 3 args, got \",",
          "170:                                t.args_size()));",
          "171:   }",
          "",
          "---------------"
        ],
        "tensorflow/core/framework/full_type_util_test.cc||tensorflow/core/framework/full_type_util_test.cc": [
          "File: tensorflow/core/framework/full_type_util_test.cc -> tensorflow/core/framework/full_type_util_test.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "510:   EXPECT_EQ(t_actual.args(1).args(0).args(0).args_size(), 0);",
          "511: }",
          "513: TEST(SpecializeType, RemovesLegacyVariant) {",
          "514:   OpDef op;",
          "515:   FullTypeDef* t = op.add_output_arg()->mutable_experimental_full_type();",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "513: TEST(SpecializeType, ForEachRejectsMalformedInput) {",
          "514:   OpDef op;",
          "515:   FullTypeDef* t = op.add_output_arg()->mutable_experimental_full_type();",
          "516:   t->set_type_id(TFT_FOR_EACH);",
          "517:   t->add_args()->set_type_id(TFT_PRODUCT);",
          "519:   NodeDef ndef;",
          "520:   AttrSlice attrs(ndef);",
          "522:   FullTypeDef ft;",
          "523:   EXPECT_FALSE(SpecializeType(attrs, op, ft).ok());",
          "524: }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "6104f0d4091c260ce9352f9155f7e9b725eab012",
      "candidate_info": {
        "commit_hash": "6104f0d4091c260ce9352f9155f7e9b725eab012",
        "repo": "tensorflow/tensorflow",
        "commit_url": "https://github.com/tensorflow/tensorflow/commit/6104f0d4091c260ce9352f9155f7e9b725eab012",
        "files": [
          "tensorflow/core/framework/full_type_util.cc",
          "tensorflow/core/framework/full_type_util_test.cc"
        ],
        "message": "Strengthen input verification for SpecializeType by replacing DCHECK with explicit test/status return.\n\nPiperOrigin-RevId: 453436708",
        "before_after_code_files": [
          "tensorflow/core/framework/full_type_util.cc||tensorflow/core/framework/full_type_util.cc",
          "tensorflow/core/framework/full_type_util_test.cc||tensorflow/core/framework/full_type_util_test.cc"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "tensorflow/core/framework/full_type_util.cc||tensorflow/core/framework/full_type_util.cc"
          ],
          "candidate": [
            "tensorflow/core/framework/full_type_util.cc||tensorflow/core/framework/full_type_util.cc"
          ]
        }
      },
      "candidate_diff": {
        "tensorflow/core/framework/full_type_util.cc||tensorflow/core/framework/full_type_util.cc": [
          "File: tensorflow/core/framework/full_type_util.cc -> tensorflow/core/framework/full_type_util.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "175: }",
          "177: Status SubstituteForEach(AttrMap& attrs, FullTypeDef& t) {",
          "180:   const auto& cont = t.args(0);",
          "181:   const auto& tmpl = t.args(1);",
          "",
          "[Removed Lines]",
          "178:   DCHECK_EQ(t.args_size(), 3);",
          "",
          "[Added Lines]",
          "178:   if (t.args_size() != 3) {",
          "179:     return Status(error::INVALID_ARGUMENT,",
          "180:                   absl::StrCat(\"illegal FOR_EACH type, expected 3 args, got \",",
          "181:                                t.args_size()));",
          "182:   }",
          "",
          "---------------"
        ],
        "tensorflow/core/framework/full_type_util_test.cc||tensorflow/core/framework/full_type_util_test.cc": [
          "File: tensorflow/core/framework/full_type_util_test.cc -> tensorflow/core/framework/full_type_util_test.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "510:   EXPECT_EQ(t_actual.args(1).args(0).args(0).args_size(), 0);",
          "511: }",
          "513: TEST(SpecializeType, RemovesLegacyVariant) {",
          "514:   OpDef op;",
          "515:   FullTypeDef* t = op.add_output_arg()->mutable_experimental_full_type();",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "513: TEST(SpecializeType, ForEachRejectsMalformedInput) {",
          "514:   OpDef op;",
          "515:   FullTypeDef* t = op.add_output_arg()->mutable_experimental_full_type();",
          "516:   t->set_type_id(TFT_FOR_EACH);",
          "517:   t->add_args()->set_type_id(TFT_PRODUCT);",
          "519:   NodeDef ndef;",
          "520:   AttrSlice attrs(ndef);",
          "522:   FullTypeDef ft;",
          "523:   EXPECT_FALSE(SpecializeType(attrs, op, ft).ok());",
          "524: }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "634b80a6ee614cee787befd371f31269911b0d19",
      "candidate_info": {
        "commit_hash": "634b80a6ee614cee787befd371f31269911b0d19",
        "repo": "tensorflow/tensorflow",
        "commit_url": "https://github.com/tensorflow/tensorflow/commit/634b80a6ee614cee787befd371f31269911b0d19",
        "files": [
          "tensorflow/core/framework/full_type_util.cc",
          "tensorflow/core/framework/full_type_util_test.cc"
        ],
        "message": "Strengthen input verification for SpecializeType by replacing DCHECK with explicit test/status return.\n\nPiperOrigin-RevId: 453436708",
        "before_after_code_files": [
          "tensorflow/core/framework/full_type_util.cc||tensorflow/core/framework/full_type_util.cc",
          "tensorflow/core/framework/full_type_util_test.cc||tensorflow/core/framework/full_type_util_test.cc"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "tensorflow/core/framework/full_type_util.cc||tensorflow/core/framework/full_type_util.cc"
          ],
          "candidate": [
            "tensorflow/core/framework/full_type_util.cc||tensorflow/core/framework/full_type_util.cc"
          ]
        }
      },
      "candidate_diff": {
        "tensorflow/core/framework/full_type_util.cc||tensorflow/core/framework/full_type_util.cc": [
          "File: tensorflow/core/framework/full_type_util.cc -> tensorflow/core/framework/full_type_util.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "174: }",
          "176: Status SubstituteForEach(AttrMap& attrs, FullTypeDef& t) {",
          "179:   const auto& cont = t.args(0);",
          "180:   const auto& tmpl = t.args(1);",
          "",
          "[Removed Lines]",
          "177:   DCHECK_EQ(t.args_size(), 3);",
          "",
          "[Added Lines]",
          "177:   if (t.args_size() != 3) {",
          "178:     return Status(error::INVALID_ARGUMENT,",
          "179:                   absl::StrCat(\"illegal FOR_EACH type, expected 3 args, got \",",
          "180:                                t.args_size()));",
          "181:   }",
          "",
          "---------------"
        ],
        "tensorflow/core/framework/full_type_util_test.cc||tensorflow/core/framework/full_type_util_test.cc": [
          "File: tensorflow/core/framework/full_type_util_test.cc -> tensorflow/core/framework/full_type_util_test.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "491:   EXPECT_EQ(t_actual.args(1).args(0).args(0).args_size(), 0);",
          "492: }",
          "494: TEST(GetArgDefaults, DefaultUnsetFromNoArgs) {",
          "495:   FullTypeDef t;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "494: TEST(SpecializeType, ForEachRejectsMalformedInput) {",
          "495:   OpDef op;",
          "496:   FullTypeDef* t = op.add_output_arg()->mutable_experimental_full_type();",
          "497:   t->set_type_id(TFT_FOR_EACH);",
          "498:   t->add_args()->set_type_id(TFT_PRODUCT);",
          "500:   NodeDef ndef;",
          "501:   AttrSlice attrs(ndef);",
          "503:   FullTypeDef ft;",
          "504:   EXPECT_FALSE(SpecializeType(attrs, op, ft).ok());",
          "505: }",
          "507: TEST(SpecializeType, RemovesLegacyVariant) {",
          "508:   OpDef op;",
          "509:   FullTypeDef* t = op.add_output_arg()->mutable_experimental_full_type();",
          "510:   t->set_type_id(TFT_ARRAY);",
          "511:   t->add_args()->set_type_id(TFT_TENSOR);",
          "512:   t->mutable_args(0)->add_args()->set_type_id(TFT_LEGACY_VARIANT);",
          "513:   t->add_args()->set_type_id(TFT_TENSOR);",
          "514:   t->mutable_args(1)->add_args()->set_type_id(TFT_FLOAT);",
          "516:   AttrSlice empty;",
          "518:   FullTypeDef ft;",
          "519:   TF_ASSERT_OK(SpecializeType(empty, op, ft));",
          "521:   EXPECT_EQ(ft.type_id(), TFT_PRODUCT);",
          "522:   EXPECT_EQ(ft.args_size(), 1);",
          "524:   const FullTypeDef& t_actual = ft.args(0);",
          "525:   EXPECT_EQ(t_actual.type_id(), TFT_ARRAY);",
          "526:   EXPECT_EQ(t_actual.args_size(), 0);",
          "527: }",
          "529: TEST(SpecializeType, RemovesLegacyVariantAfterExpansion) {",
          "530:   OpDef op;",
          "531:   FullTypeDef* t = op.add_output_arg()->mutable_experimental_full_type();",
          "532:   t->set_type_id(TFT_ARRAY);",
          "533:   t->add_args()->set_type_id(TFT_TENSOR);",
          "534:   t->mutable_args(0)->add_args()->set_type_id(TFT_VAR);",
          "535:   t->mutable_args(0)->mutable_args(0)->set_s(\"T\");",
          "537:   AttrValue attr;",
          "538:   attr.set_type(DT_VARIANT);",
          "539:   NodeDef ndef;",
          "540:   (*ndef.mutable_attr())[\"T\"] = attr;",
          "542:   AttrSlice attrs(ndef);",
          "544:   FullTypeDef ft;",
          "545:   TF_ASSERT_OK(SpecializeType(attrs, op, ft));",
          "547:   EXPECT_EQ(ft.type_id(), TFT_PRODUCT);",
          "548:   EXPECT_EQ(ft.args_size(), 1);",
          "550:   const FullTypeDef& t_actual = ft.args(0);",
          "551:   EXPECT_EQ(t_actual.type_id(), TFT_ARRAY);",
          "552:   EXPECT_EQ(t_actual.args_size(), 0);",
          "553: }",
          "",
          "---------------"
        ]
      }
    }
  ]
}
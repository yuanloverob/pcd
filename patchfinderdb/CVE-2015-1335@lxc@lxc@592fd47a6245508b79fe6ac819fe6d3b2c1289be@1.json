{
  "cve_id": "CVE-2015-1335",
  "cve_desc": "lxc-start in lxc before 1.0.8 and 1.1.x before 1.1.4 allows local container administrators to escape AppArmor confinement via a symlink attack on a (1) mount target or (2) bind mount source.",
  "repo": "lxc/lxc",
  "patch_hash": "592fd47a6245508b79fe6ac819fe6d3b2c1289be",
  "patch_info": {
    "commit_hash": "592fd47a6245508b79fe6ac819fe6d3b2c1289be",
    "repo": "lxc/lxc",
    "commit_url": "https://github.com/lxc/lxc/commit/592fd47a6245508b79fe6ac819fe6d3b2c1289be",
    "files": [
      "doc/lxc.container.conf.sgml.in",
      "src/lxc/cgfs.c",
      "src/lxc/cgmanager.c",
      "src/lxc/conf.c",
      "src/lxc/utils.c",
      "src/lxc/utils.h",
      "src/tests/Makefile.am",
      "src/tests/lxc-test-symlink"
    ],
    "message": "CVE-2015-1335: Protect container mounts against symlinks\n\nWhen a container starts up, lxc sets up the container's inital fstree\nby doing a bunch of mounting, guided by the container configuration\nfile.  The container config is owned by the admin or user on the host,\nso we do not try to guard against bad entries.  However, since the\nmount target is in the container, it's possible that the container admin\ncould divert the mount with symbolic links.  This could bypass proper\ncontainer startup (i.e. confinement of a root-owned container by the\nrestrictive apparmor policy, by diverting the required write to\n/proc/self/attr/current), or bypass the (path-based) apparmor policy\nby diverting, say, /proc to /mnt in the container.\n\nTo prevent this,\n\n1. do not allow mounts to paths containing symbolic links\n\n2. do not allow bind mounts from relative paths containing symbolic\nlinks.\n\nDetails:\n\nDefine safe_mount which ensures that the container has not inserted any\nsymbolic links into any mount targets for mounts to be done during\ncontainer setup.\n\nThe host's mount path may contain symbolic links.  As it is under the\ncontrol of the administrator, that's ok.  So safe_mount begins the check\nfor symbolic links after the rootfs->mount, by opening that directory.\n\nIt opens each directory along the path using openat() relative to the\nparent directory using O_NOFOLLOW.  When the target is reached, it\nmounts onto /proc/self/fd/<targetfd>.\n\nUse safe_mount() in mount_entry(), when mounting container proc,\nand when needed.  In particular, safe_mount() need not be used in\nany case where:\n\n1. the mount is done in the container's namespace\n2. the mount is for the container's rootfs\n3. the mount is relative to a tmpfs or proc/sysfs which we have\n   just safe_mount()ed ourselves\n\nSince we were using proc/net as a temporary placeholder for /proc/sys/net\nduring container startup, and proc/net is a symbolic link, use proc/tty\ninstead.\n\nUpdate the lxc.container.conf manpage with details about the new\nrestrictions.\n\nFinally, add a testcase to test some symbolic link possibilities.\n\nReported-by: Roman Fiedler\nSigned-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>\nAcked-by: St\u00e9phane Graber <stgraber@ubuntu.com>",
    "before_after_code_files": [
      "src/lxc/cgfs.c||src/lxc/cgfs.c",
      "src/lxc/cgmanager.c||src/lxc/cgmanager.c",
      "src/lxc/conf.c||src/lxc/conf.c",
      "src/lxc/utils.c||src/lxc/utils.c",
      "src/lxc/utils.h||src/lxc/utils.h",
      "src/tests/Makefile.am||src/tests/Makefile.am"
    ]
  },
  "patch_diff": {
    "src/lxc/cgfs.c||src/lxc/cgfs.c": [
      "File: src/lxc/cgfs.c -> src/lxc/cgfs.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "1363:  if (!path)",
      "1364:   return false;",
      "1365:  snprintf(path, bufsz, \"%s/sys/fs/cgroup\", root);",
      "1367:  if (r < 0) {",
      "1368:   SYSERROR(\"could not mount tmpfs to /sys/fs/cgroup in the container\");",
      "1369:   return false;",
      "",
      "[Removed Lines]",
      "1366:  r = mount(\"cgroup_root\", path, \"tmpfs\", MS_NOSUID|MS_NODEV|MS_NOEXEC|MS_RELATIME, \"size=10240k,mode=755\");",
      "",
      "[Added Lines]",
      "1366:  r = safe_mount(\"cgroup_root\", path, \"tmpfs\",",
      "1367:    MS_NOSUID|MS_NODEV|MS_NOEXEC|MS_RELATIME,",
      "1368:    \"size=10240k,mode=755\",",
      "1369:    root);",
      "",
      "---------------"
    ],
    "src/lxc/cgmanager.c||src/lxc/cgmanager.c": [
      "File: src/lxc/cgmanager.c -> src/lxc/cgmanager.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "1477:  }",
      "1481:   SYSERROR(\"Failed to mount tmpfs at %s\", cgpath);",
      "1482:   return false;",
      "1483:  }",
      "",
      "[Removed Lines]",
      "1480:  if (mount(\"cgroup\", cgpath, \"tmpfs\", 0, \"size=10000,mode=755\")) {",
      "",
      "[Added Lines]",
      "1480:  if (safe_mount(\"cgroup\", cgpath, \"tmpfs\", 0, \"size=10000,mode=755\", root)) {",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "1488:   return false;",
      "1489:  }",
      "1492:   SYSERROR(\"Failed to bind mount %s to %s\", dirname, cgpath);",
      "1493:   return false;",
      "1494:  }",
      "",
      "[Removed Lines]",
      "1491:  if (mount(dirname, cgpath, \"none\", MS_BIND, 0)) {",
      "",
      "[Added Lines]",
      "1491:  if (safe_mount(dirname, cgpath, \"none\", MS_BIND, 0, root)) {",
      "",
      "---------------"
    ],
    "src/lxc/conf.c||src/lxc/conf.c": [
      "File: src/lxc/conf.c -> src/lxc/conf.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "771:   { LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, \"proc\",                                              \"%r/proc\",                      \"proc\",     MS_NODEV|MS_NOEXEC|MS_NOSUID,   NULL },",
      "773:   { LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, \"%r/proc/sys\",                                       \"%r/proc/sys\",                  NULL,       MS_BIND,                        NULL },",
      "774:   { LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, NULL,                                                \"%r/proc/sys\",                  NULL,       MS_REMOUNT|MS_BIND|MS_RDONLY,   NULL },",
      "776:   { LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, \"%r/proc/sysrq-trigger\",                             \"%r/proc/sysrq-trigger\",        NULL,       MS_BIND,                        NULL },",
      "777:   { LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, NULL,                                                \"%r/proc/sysrq-trigger\",        NULL,       MS_REMOUNT|MS_BIND|MS_RDONLY,   NULL },",
      "778:   { LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_RW,    \"proc\",                                              \"%r/proc\",                      \"proc\",     MS_NODEV|MS_NOEXEC|MS_NOSUID,   NULL },",
      "",
      "[Removed Lines]",
      "772:   { LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, \"%r/proc/sys/net\",                                   \"%r/proc/net\",                  NULL,       MS_BIND,                        NULL },",
      "775:   { LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, \"%r/proc/net\",                                       \"%r/proc/sys/net\",              NULL,       MS_MOVE,                        NULL },",
      "",
      "[Added Lines]",
      "773:   { LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, \"%r/proc/sys/net\",                                   \"%r/proc/tty\",                  NULL,       MS_BIND,                        NULL },",
      "776:   { LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, \"%r/proc/tty\",                                       \"%r/proc/sys/net\",              NULL,       MS_MOVE,                        NULL },",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "815:    }",
      "816:    mflags = add_required_remount_flags(source, destination,",
      "817:      default_mounts[i].flags);",
      "819:    saved_errno = errno;",
      "820:    if (r < 0 && errno == ENOENT) {",
      "821:     INFO(\"Mount source or target for %s on %s doesn't exist. Skipping.\", source, destination);",
      "",
      "[Removed Lines]",
      "818:    r = mount(source, destination, default_mounts[i].fstype, mflags, default_mounts[i].options);",
      "",
      "[Added Lines]",
      "819:    r = safe_mount(source, destination, default_mounts[i].fstype, mflags, default_mounts[i].options, conf->rootfs.path ? conf->rootfs.mount : NULL);",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "1167:   return 0;",
      "1168:  }",
      "1171:   SYSERROR(\"Failed mounting tmpfs onto %s\\n\", path);",
      "1172:   return false;",
      "1173:  }",
      "",
      "[Removed Lines]",
      "1170:  if (mount(\"none\", path, \"tmpfs\", 0, \"size=100000,mode=755\")) {",
      "",
      "[Added Lines]",
      "1171:  if (safe_mount(\"none\", path, \"tmpfs\", 0, \"size=100000,mode=755\",",
      "1172:     rootfs->path ? rootfs->mount : NULL)) {",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "1252:     return -1;",
      "1253:    }",
      "1254:    fclose(pathfile);",
      "1256:     SYSERROR(\"Failed bind mounting device %s from host into container\",",
      "1257:      d->name);",
      "1258:     return -1;",
      "",
      "[Removed Lines]",
      "1255:    if (mount(hostpath, path, 0, MS_BIND, NULL) != 0) {",
      "",
      "[Added Lines]",
      "1257:    if (safe_mount(hostpath, path, 0, MS_BIND, NULL,",
      "1258:       rootfs->path ? rootfs->mount : NULL) != 0) {",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "1505:   return -1;",
      "1506:  }",
      "1509:   ERROR(\"failed to mount '%s' on '%s'\", console->name, path);",
      "1510:   return -1;",
      "1511:  }",
      "",
      "[Removed Lines]",
      "1508:  if (mount(console->name, path, \"none\", MS_BIND, 0)) {",
      "",
      "[Added Lines]",
      "1511:  if (safe_mount(console->name, path, \"none\", MS_BIND, 0, rootfs->mount)) {",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "1560:   return 0;",
      "1561:  }",
      "1564:   ERROR(\"failed to mount '%s' on '%s'\", console->name, lxcpath);",
      "1565:   return -1;",
      "1566:  }",
      "",
      "[Removed Lines]",
      "1563:  if (mount(console->name, lxcpath, \"none\", MS_BIND, 0)) {",
      "",
      "[Added Lines]",
      "1566:  if (safe_mount(console->name, lxcpath, \"none\", MS_BIND, 0, rootfs->mount)) {",
      "",
      "---------------",
      "--- Hunk 7 ---",
      "[Context before]",
      "1711: static int mount_entry(const char *fsname, const char *target,",
      "1712:          const char *fstype, unsigned long mountflags,",
      "1714: {",
      "1715: #ifdef HAVE_STATVFS",
      "1716:  struct statvfs sb;",
      "1717: #endif",
      "1720:   if (optional) {",
      "1721:    INFO(\"failed to mount '%s' on '%s' (optional): %s\", fsname,",
      "1722:         target, strerror(errno));",
      "",
      "[Removed Lines]",
      "1713:          const char *data, int optional)",
      "1719:  if (mount(fsname, target, fstype, mountflags & ~MS_REMOUNT, data)) {",
      "",
      "[Added Lines]",
      "1716:          const char *data, int optional, const char *rootfs)",
      "1722:  if (safe_mount(fsname, target, fstype, mountflags & ~MS_REMOUNT, data, rootfs)) {",
      "",
      "---------------",
      "--- Hunk 8 ---",
      "[Context before]",
      "1763: #endif",
      "1765:   if (mount(fsname, target, fstype,",
      "1767:    if (optional) {",
      "1768:     INFO(\"failed to mount '%s' on '%s' (optional): %s\",",
      "1769:       fsname, target, strerror(errno));",
      "",
      "[Removed Lines]",
      "1766:      mountflags | MS_REMOUNT, data)) {",
      "",
      "[Added Lines]",
      "1769:      mountflags | MS_REMOUNT, data) < 0) {",
      "",
      "---------------",
      "--- Hunk 9 ---",
      "[Context before]",
      "1843: }",
      "1845: static inline int mount_entry_on_generic(struct mntent *mntent,",
      "1847: {",
      "1848:  unsigned long mntflags;",
      "1849:  char *mntdata;",
      "",
      "[Removed Lines]",
      "1846:                  const char* path)",
      "",
      "[Added Lines]",
      "1849:                  const char* path, const char *rootfs)",
      "",
      "---------------",
      "--- Hunk 10 ---",
      "[Context before]",
      "1863:  }",
      "1865:  ret = mount_entry(mntent->mnt_fsname, path, mntent->mnt_type,",
      "1868:  free(mntdata);",
      "",
      "[Removed Lines]",
      "1866:      mntflags, mntdata, optional);",
      "",
      "[Added Lines]",
      "1869:      mntflags, mntdata, optional, rootfs);",
      "",
      "---------------",
      "--- Hunk 11 ---",
      "[Context before]",
      "1873: static inline int mount_entry_on_systemfs(struct mntent *mntent)",
      "1874: {",
      "1876: }",
      "1878: static int mount_entry_on_absolute_rootfs(struct mntent *mntent,",
      "",
      "[Removed Lines]",
      "1875:   return mount_entry_on_generic(mntent, mntent->mnt_dir);",
      "",
      "[Added Lines]",
      "1878:   return mount_entry_on_generic(mntent, mntent->mnt_dir, NULL);",
      "",
      "---------------",
      "--- Hunk 12 ---",
      "[Context before]",
      "1919:   return -1;",
      "1920:  }",
      "1923: }",
      "1925: static int mount_entry_on_relative_rootfs(struct mntent *mntent,",
      "",
      "[Removed Lines]",
      "1922:  return mount_entry_on_generic(mntent, path);",
      "",
      "[Added Lines]",
      "1925:  return mount_entry_on_generic(mntent, path, rootfs->mount);",
      "",
      "---------------",
      "--- Hunk 13 ---",
      "[Context before]",
      "1935:   return -1;",
      "1936:  }",
      "1939: }",
      "1941: static int mount_file_entries(const struct lxc_rootfs *rootfs, FILE *file,",
      "",
      "[Removed Lines]",
      "1938:  return mount_entry_on_generic(mntent, path);",
      "",
      "[Added Lines]",
      "1941:  return mount_entry_on_generic(mntent, path, rootfs);",
      "",
      "---------------",
      "--- Hunk 14 ---",
      "[Context before]",
      "3602:   fclose(pathfile);",
      "3603:  }",
      "3606:  if (ret < 0)",
      "3607:   SYSERROR(\"Failed to bind lxc.init.static into container\");",
      "3608:  INFO(\"lxc.init.static bound into container at %s\", path);",
      "",
      "[Removed Lines]",
      "3605:  ret = mount(path, destpath, \"none\", MS_BIND, NULL);",
      "",
      "[Added Lines]",
      "3608:  ret = safe_mount(path, destpath, \"none\", MS_BIND, NULL, conf->rootfs.mount);",
      "",
      "---------------"
    ],
    "src/lxc/utils.c||src/lxc/utils.c": [
      "File: src/lxc/utils.c -> src/lxc/utils.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "1404:  return ret;",
      "1405: }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1414: static char *get_nextpath(char *path, int *offsetp, int fulllen)",
      "1415: {",
      "1416:  int offset = *offsetp;",
      "1418:  if (offset >= fulllen)",
      "1419:   return NULL;",
      "1421:  while (path[offset] != '\\0' && offset < fulllen)",
      "1422:   offset++;",
      "1423:  while (path[offset] == '\\0' && offset < fulllen)",
      "1424:   offset++;",
      "1427:  return (offset < fulllen) ? &path[offset] : NULL;",
      "1428: }",
      "1434: static bool is_subdir(const char *subdir, const char *dir, size_t len)",
      "1435: {",
      "1436:  size_t subdirlen = strlen(subdir);",
      "1438:  if (subdirlen < len)",
      "1439:   return false;",
      "1440:  if (strncmp(subdir, dir, len) != 0)",
      "1441:   return false;",
      "1442:  if (dir[len-1] == '/')",
      "1443:   return true;",
      "1444:  if (subdir[len] == '/' || subdirlen == len)",
      "1445:   return true;",
      "1446:  return false;",
      "1447: }",
      "1453: static int check_symlink(int fd)",
      "1454: {",
      "1455:  struct stat sb;",
      "1456:  int ret = fstat(fd, &sb);",
      "1457:  if (ret < 0)",
      "1458:   return -ENOENT;",
      "1459:  if (S_ISLNK(sb.st_mode))",
      "1460:   return -ELOOP;",
      "1461:  return 0;",
      "1462: }",
      "1470: static int open_if_safe(int dirfd, const char *nextpath)",
      "1471: {",
      "1472:  int newfd = openat(dirfd, nextpath, O_RDONLY | O_NOFOLLOW);",
      "1473:  if (newfd >= 0) // was not a symlink, all good",
      "1474:   return newfd;",
      "1476:  if (errno == ELOOP)",
      "1477:   return newfd;",
      "1479:  if (errno == EPERM || errno == EACCES) {",
      "1482:   newfd = openat(dirfd, nextpath, O_PATH | O_NOFOLLOW);",
      "1483:   if (newfd >= 0) {",
      "1488:    int ret = check_symlink(newfd);",
      "1489:    if (ret < 0) {",
      "1490:     close(newfd);",
      "1491:     newfd = ret;",
      "1492:    }",
      "1493:   }",
      "1494:  }",
      "1496:  return newfd;",
      "1497: }",
      "1512: static int open_without_symlink(const char *target, const char *prefix_skip)",
      "1513: {",
      "1514:  int curlen = 0, dirfd, fulllen, i;",
      "1515:  char *dup = NULL;",
      "1517:  fulllen = strlen(target);",
      "1520:  if (prefix_skip) {",
      "1521:   curlen = strlen(prefix_skip);",
      "1522:   if (!is_subdir(target, prefix_skip, curlen)) {",
      "1523:    ERROR(\"WHOA there - target '%s' didn't start with prefix '%s'\",",
      "1524:     target, prefix_skip);",
      "1525:    return -EINVAL;",
      "1526:   }",
      "1532:   if (curlen)",
      "1533:    curlen--;",
      "1534:  } else {",
      "1535:   prefix_skip = \"/\";",
      "1536:   curlen = 0;",
      "1537:  }",
      "1540:  if ((dup = strdup(target)) == NULL) {",
      "1541:   SYSERROR(\"Out of memory checking for symbolic link\");",
      "1542:   return -ENOMEM;",
      "1543:  }",
      "1544:  for (i = 0; i < fulllen; i++) {",
      "1545:   if (dup[i] == '/')",
      "1546:    dup[i] = '\\0';",
      "1547:  }",
      "1549:  dirfd = open(prefix_skip, O_RDONLY);",
      "1550:  if (dirfd < 0)",
      "1551:   goto out;",
      "1552:  while (1) {",
      "1553:   int newfd, saved_errno;",
      "1554:   char *nextpath;",
      "1556:   if ((nextpath = get_nextpath(dup, &curlen, fulllen)) == NULL)",
      "1557:    goto out;",
      "1558:   newfd = open_if_safe(dirfd, nextpath);",
      "1559:   saved_errno = errno;",
      "1560:   close(dirfd);",
      "1561:   dirfd = newfd;",
      "1562:   if (newfd < 0) {",
      "1563:    errno = saved_errno;",
      "1564:    if (errno == ELOOP)",
      "1565:     SYSERROR(\"%s in %s was a symbolic link!\", nextpath, target);",
      "1566:    else",
      "1567:     SYSERROR(\"Error examining %s in %s\", nextpath, target);",
      "1568:    goto out;",
      "1569:   }",
      "1570:  }",
      "1572: out:",
      "1573:  free(dup);",
      "1574:  return dirfd;",
      "1575: }",
      "1585: int safe_mount(const char *src, const char *dest, const char *fstype,",
      "1586:   unsigned long flags, const void *data, const char *rootfs)",
      "1587: {",
      "1588:  int srcfd = -1, destfd, ret, saved_errno;",
      "1589:  char srcbuf[50], destbuf[50]; // only needs enough for /proc/self/fd/<fd>",
      "1590:  const char *mntsrc = src;",
      "1592:  if (!rootfs)",
      "1593:   rootfs = \"\";",
      "1596:  if (flags & MS_BIND && src && src[0] != '/') {",
      "1597:   INFO(\"this is a relative bind mount\");",
      "1598:   srcfd = open_without_symlink(src, NULL);",
      "1599:   if (srcfd < 0)",
      "1600:    return srcfd;",
      "1601:   ret = snprintf(srcbuf, 50, \"/proc/self/fd/%d\", srcfd);",
      "1602:   if (ret < 0 || ret > 50) {",
      "1603:    close(srcfd);",
      "1604:    ERROR(\"Out of memory\");",
      "1605:    return -EINVAL;",
      "1606:   }",
      "1607:   mntsrc = srcbuf;",
      "1608:  }",
      "1610:  destfd = open_without_symlink(dest, rootfs);",
      "1611:  if (destfd < 0) {",
      "1612:   if (srcfd != -1)",
      "1613:    close(srcfd);",
      "1614:   return destfd;",
      "1615:  }",
      "1617:  ret = snprintf(destbuf, 50, \"/proc/self/fd/%d\", destfd);",
      "1618:  if (ret < 0 || ret > 50) {",
      "1619:   if (srcfd != -1)",
      "1620:    close(srcfd);",
      "1621:   close(destfd);",
      "1622:   ERROR(\"Out of memory\");",
      "1623:   return -EINVAL;",
      "1624:  }",
      "1626:  ret = mount(mntsrc, destbuf, fstype, flags, data);",
      "1627:  saved_errno = errno;",
      "1628:  if (srcfd != -1)",
      "1629:   close(srcfd);",
      "1630:  close(destfd);",
      "1631:  if (ret < 0) {",
      "1632:   errno = saved_errno;",
      "1633:   SYSERROR(\"Failed to mount %s onto %s\", src, dest);",
      "1634:   return ret;",
      "1635:  }",
      "1637:  return 0;",
      "1638: }",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "1446:  return 0;",
      "1448: domount:",
      "1450:   return -1;",
      "1451:  INFO(\"Mounted /proc in container for security transition\");",
      "1452:  return 1;",
      "",
      "[Removed Lines]",
      "1449:  if (mount(\"proc\", path, \"proc\", 0, NULL))",
      "",
      "[Added Lines]",
      "1682:  if (safe_mount(\"proc\", path, \"proc\", 0, NULL, rootfs) < 0)",
      "",
      "---------------"
    ],
    "src/lxc/utils.h||src/lxc/utils.h": [
      "File: src/lxc/utils.h -> src/lxc/utils.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "279: int is_dir(const char *path);",
      "280: char *get_template_path(const char *t);",
      "281: int setproctitle(char *title);",
      "282: int mount_proc_if_needed(const char *rootfs);",
      "283: int null_stdfds(void);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "282: int safe_mount(const char *src, const char *dest, const char *fstype,",
      "283:   unsigned long flags, const void *data, const char *rootfs);",
      "",
      "---------------"
    ],
    "src/tests/Makefile.am||src/tests/Makefile.am": [
      "File: src/tests/Makefile.am -> src/tests/Makefile.am",
      "--- Hunk 1 ---",
      "[Context before]",
      "55:  lxc-test-apparmor-mount \\",
      "56:  lxc-test-checkpoint-restore \\",
      "57:  lxc-test-snapdeps \\",
      "58:  lxc-test-ubuntu \\",
      "59:  lxc-test-unpriv \\",
      "60:  lxc-test-usernic",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "58:  lxc-test-symlink \\",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "82:  lxc-test-cloneconfig \\",
      "83:  lxc-test-createconfig \\",
      "84:  lxc-test-snapdeps \\",
      "85:  lxc-test-ubuntu \\",
      "86:  lxc-test-unpriv \\",
      "87:  may_control.c \\",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "86:  lxc-test-symlink \\",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "1ec0e8e3fd766ff77c6128f384772f407f9b75da",
      "candidate_info": {
        "commit_hash": "1ec0e8e3fd766ff77c6128f384772f407f9b75da",
        "repo": "lxc/lxc",
        "commit_url": "https://github.com/lxc/lxc/commit/1ec0e8e3fd766ff77c6128f384772f407f9b75da",
        "files": [
          "src/lxc/bdev/lxcoverlay.c",
          "src/lxc/conf.c"
        ],
        "message": "Fix NULL-ptr derefs for container without rootfs\n\nSince we allow containers to be created without a rootfs most checks in conf.c\nare not sane anymore. Instead of just checking if rootfs->path != NULL we need\nto check whether rootfs != NULL.\n\nMinor fixes:\n- Have mount_autodev() always return -1 on failure: mount_autodev() returns 0\n  on success and -1 on failure. But when the return value of safe_mount() was\n  checked in mount_autodev() we returned false (instead of -1) which caused\n  mount_autodev() to return 0 (success) instead of the correct -1 (failure).\n\nSigned-off-by: Christian Brauner <christian.brauner@mailbox.org>",
        "before_after_code_files": [
          "src/lxc/bdev/lxcoverlay.c||src/lxc/bdev/lxcoverlay.c",
          "src/lxc/conf.c||src/lxc/conf.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/lxc/conf.c||src/lxc/conf.c"
          ],
          "candidate": [
            "src/lxc/conf.c||src/lxc/conf.c"
          ]
        }
      },
      "candidate_diff": {
        "src/lxc/bdev/lxcoverlay.c||src/lxc/bdev/lxcoverlay.c": [
          "File: src/lxc/bdev/lxcoverlay.c -> src/lxc/bdev/lxcoverlay.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "489:  size_t len = 0;",
          "490:  size_t rootfslen = 0;",
          "493:   goto err;",
          "495:  opts = lxc_string_split(mntent->mnt_opts, ',');",
          "",
          "[Removed Lines]",
          "492:  if (!rootfs->path || !lxc_name || !lxc_path)",
          "",
          "[Added Lines]",
          "492:  if (!rootfs || !rootfs->path || !lxc_name || !lxc_path)",
          "",
          "---------------"
        ],
        "src/lxc/conf.c||src/lxc/conf.c": [
          "File: src/lxc/conf.c -> src/lxc/conf.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "858:  int ret,i;",
          "859:  struct stat s;",
          "862:  for (i = 0; i < sizeof(dev_symlinks) / sizeof(dev_symlinks[0]); i++) {",
          "863:   const struct dev_symlinks *d = &dev_symlinks[i];",
          "865:   if (ret < 0 || ret >= MAXPATHLEN)",
          "866:    return -1;",
          "",
          "[Removed Lines]",
          "864:   ret = snprintf(path, sizeof(path), \"%s/dev/%s\", rootfs->path ? rootfs->mount : \"\", d->name);",
          "",
          "[Added Lines]",
          "862:  char *rootfs_path = NULL;",
          "863:  if (rootfs && rootfs->path)",
          "864:   rootfs_path = rootfs->mount;",
          "869:   ret = snprintf(path, sizeof(path), \"%s/dev/%s\", rootfs_path ? rootfs_path : \"\", d->name);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1064:  size_t clen;",
          "1065:  char *path;",
          "1067:  INFO(\"Mounting container /dev\");",
          "1071:  path = alloca(clen);",
          "1074:  if (ret < 0 || ret >= clen)",
          "1075:   return -1;",
          "",
          "[Removed Lines]",
          "1070:  clen = (rootfs->path ? strlen(rootfs->mount) : 0) + 9;",
          "1073:  ret = snprintf(path, clen, \"%s/dev\", rootfs->path ? rootfs->mount : \"\");",
          "",
          "[Added Lines]",
          "1073:  char *rootfs_path = NULL;",
          "1074:  if (rootfs && rootfs->path)",
          "1075:   rootfs_path = rootfs->mount;",
          "1080:  clen = (rootfs_path ? strlen(rootfs_path) : 0) + 9;",
          "1083:  ret = snprintf(path, clen, \"%s/dev\", rootfs_path ? rootfs_path : \"\");",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1080:   return 0;",
          "1081:  }",
          "1085:   SYSERROR(\"Failed mounting tmpfs onto %s\\n\", path);",
          "1087:  }",
          "1089:  INFO(\"Mounted tmpfs onto %s\",  path);",
          "1092:  if (ret < 0 || ret >= clen)",
          "1093:   return -1;",
          "",
          "[Removed Lines]",
          "1083:  if (safe_mount(\"none\", path, \"tmpfs\", 0, \"size=500000,mode=755\",",
          "1084:     rootfs->path ? rootfs->mount : NULL)) {",
          "1086:   return false;",
          "1091:  ret = snprintf(path, clen, \"%s/dev/pts\", rootfs->path ? rootfs->mount : \"\");",
          "",
          "[Added Lines]",
          "1093:  ret = safe_mount(\"none\", path, \"tmpfs\", 0, \"size=500000,mode=755\",",
          "1094:    rootfs_path);",
          "1095:  if (ret != 0) {",
          "1097:   return -1;",
          "1102:  ret = snprintf(path, clen, \"%s/dev/pts\", rootfs_path ? rootfs_path : \"\");",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1132:  int i;",
          "1133:  mode_t cmask;",
          "1135:  INFO(\"Creating initial consoles under container /dev\");",
          "1138:  if (ret < 0 || ret >= MAXPATHLEN) {",
          "1139:   ERROR(\"Error calculating container /dev location\");",
          "1140:   return -1;",
          "",
          "[Removed Lines]",
          "1137:  ret = snprintf(path, MAXPATHLEN, \"%s/dev\", rootfs->path ? rootfs->mount : \"\");",
          "",
          "[Added Lines]",
          "1147:  char *rootfs_path = NULL;",
          "1148:  if (rootfs && rootfs->path)",
          "1149:   rootfs_path = rootfs->mount;",
          "1153:  ret = snprintf(path, MAXPATHLEN, \"%s/dev\", rootfs_path ? rootfs_path : \"\");",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1147:  cmask = umask(S_IXUSR | S_IXGRP | S_IXOTH);",
          "1148:  for (i = 0; i < sizeof(lxc_devs) / sizeof(lxc_devs[0]); i++) {",
          "1149:   const struct lxc_devs *d = &lxc_devs[i];",
          "1151:   if (ret < 0 || ret >= MAXPATHLEN)",
          "1152:    return -1;",
          "1153:   ret = mknod(path, d->mode, makedev(d->maj, d->min));",
          "",
          "[Removed Lines]",
          "1150:   ret = snprintf(path, MAXPATHLEN, \"%s/dev/%s\", rootfs->path ? rootfs->mount : \"\", d->name);",
          "",
          "[Added Lines]",
          "1166:   ret = snprintf(path, MAXPATHLEN, \"%s/dev/%s\", rootfs_path ? rootfs_path : \"\", d->name);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1167:    }",
          "1168:    fclose(pathfile);",
          "1169:    if (safe_mount(hostpath, path, 0, MS_BIND, NULL,",
          "1171:     SYSERROR(\"Failed bind mounting device %s from host into container\",",
          "1172:      d->name);",
          "1173:     return -1;",
          "",
          "[Removed Lines]",
          "1170:       rootfs->path ? rootfs->mount : NULL) != 0) {",
          "",
          "[Added Lines]",
          "1186:       rootfs_path ? rootfs_path : NULL) != 0) {",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "1743:  size_t len = 0;",
          "1744:  size_t rootfslen = 0;",
          "1747:   goto err;",
          "1749:  opts = lxc_string_split(mntent->mnt_opts, ',');",
          "",
          "[Removed Lines]",
          "1746:  if (!rootfs->path || !lxc_name || !lxc_path)",
          "",
          "[Added Lines]",
          "1762:  if (!rootfs || !rootfs->path || !lxc_name || !lxc_path)",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "1849:   return -1;",
          "1850:  }",
          "1852:  ret = mount_entry(mntent->mnt_fsname, path, mntent->mnt_type, mntflags,",
          "1856:  free(mntdata);",
          "1857:  return ret;",
          "",
          "[Removed Lines]",
          "1853:      mntdata, optional,",
          "1854:      rootfs->path ? rootfs->mount : NULL);",
          "",
          "[Added Lines]",
          "1869:  char *rootfs_path = NULL;",
          "1870:  if (rootfs && rootfs->path)",
          "1871:   rootfs_path = rootfs->mount;",
          "1874:    mntdata, optional, rootfs_path);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "87da4ec3371b975df8387360524c76cb4d4b6a4a",
      "candidate_info": {
        "commit_hash": "87da4ec3371b975df8387360524c76cb4d4b6a4a",
        "repo": "lxc/lxc",
        "commit_url": "https://github.com/lxc/lxc/commit/87da4ec3371b975df8387360524c76cb4d4b6a4a",
        "files": [
          "src/lxc/conf.c",
          "src/lxc/start.c"
        ],
        "message": "autodev: switch strategies (v3)\n\nDo not keep container devs under /dev/.lxc.  Instead, always\nkeep them in a small tmpfs mounted at $(mounted_root)/dev.\n\nThe tmpfs is mounted in the container monitor's namespace.  This\nmeans that at every reboot it will get re-created.  It seems to\nme this better replicates what happens on a real host.\n\nIf we want devices persisting across reboots, then perhaps we can\nimplement a $lxcpath/$name/keepdev directory containing devices to\nbind into the container at each startup.\n\nChangelog (v2): don't bother with the $lxcpath/$name/rootfs.dev\n\tdirectory, just mount the tmpfs straight into the container.\n\nChangelog (v3): Don't create /dev if it doesn't exist\n\nSigned-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>\nAcked-by: St\u00e9phane Graber <stgraber@ubuntu.com>",
        "before_after_code_files": [
          "src/lxc/conf.c||src/lxc/conf.c",
          "src/lxc/start.c||src/lxc/start.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/lxc/conf.c||src/lxc/conf.c"
          ],
          "candidate": [
            "src/lxc/conf.c||src/lxc/conf.c"
          ]
        }
      },
      "candidate_diff": {
        "src/lxc/conf.c||src/lxc/conf.c": [
          "File: src/lxc/conf.c -> src/lxc/conf.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "95: lxc_log_define(lxc_conf, lxc);",
          "102: #if HAVE_SYS_CAPABILITY_H",
          "103: #ifndef CAP_SETFCAP",
          "",
          "[Removed Lines]",
          "97: #define MAXHWLEN    18",
          "98: #define MAXINDEXLEN 20",
          "99: #define MAXMTULEN   16",
          "100: #define MAXLINELEN  128",
          "",
          "[Added Lines]",
          "97: #define LINELEN 4096",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "295: static struct caps_opt caps_opt[] = {};",
          "296: #endif",
          "301: static int run_buffer(char *buffer)",
          "302: {",
          "303:  struct lxc_popen_FILE *f;",
          "",
          "[Removed Lines]",
          "298: const char *dev_base_path = \"/dev/.lxc\";",
          "299: const char *dev_user_path = \"/dev/.lxc/user\";",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1092: }",
          "1277: static int mount_autodev(const char *name, char *root, const char *lxcpath)",
          "1278: {",
          "1279:  int ret;",
          "1285:  INFO(\"Mounting /dev under %s\", root);",
          "1293:   return -1;",
          "1323:  }",
          "1327:  }",
          "1330:   return -1;",
          "1336:   ret = mkdir(path, S_IRWXU | S_IRGRP | S_IXGRP | S_IROTH | S_IXOTH);",
          "1337:   if (ret) {",
          "1338:    SYSERROR(\"Failed to create /dev/pts in container\");",
          "",
          "[Removed Lines]",
          "1107: #define LINELEN 4096",
          "1108: #define MAX_FSTYPE_LEN 128",
          "1109: static int mount_check_fs( const char *dir, char *fstype )",
          "1110: {",
          "1111:  char buf[LINELEN], *p;",
          "1112:  struct stat s;",
          "1113:  FILE *f;",
          "1114:  int found_fs = 0;",
          "1115:  char *p2;",
          "1117:  DEBUG(\"entering mount_check_fs for %s\", dir);",
          "1119:  if ( 0 != access(dir, F_OK) || 0 != stat(dir, &s) || 0 == S_ISDIR(s.st_mode) ) {",
          "1120:   return 0;",
          "1121:  }",
          "1123:  f = fopen(\"/proc/self/mounts\", \"r\");",
          "1124:  if (!f)",
          "1125:   return 0;",
          "1126:  while (fgets(buf, LINELEN, f)) {",
          "1127:   p = index(buf, ' ');",
          "1128:   if( !p )",
          "1129:    continue;",
          "1131:   p2 = p + 1;",
          "1133:   p = index(p2, ' ');",
          "1134:   if( !p )",
          "1135:    continue;",
          "1139:   if( strcmp( p2, dir ) ) {",
          "1140:    continue;",
          "1141:   }",
          "1143:   p2 = p + 1;",
          "1144:   p = index( p2, ' ');",
          "1145:   if( !p )",
          "1146:    continue;",
          "1149:   ++found_fs;",
          "1151:   if( fstype ) {",
          "1152:    strncpy( fstype, p2, MAX_FSTYPE_LEN - 1 );",
          "1153:    fstype [ MAX_FSTYPE_LEN - 1 ] = '\\0';",
          "1154:   }",
          "1155:  }",
          "1157:  fclose(f);",
          "1159:  DEBUG(\"mount_check_fs returning %d last %s\", found_fs, fstype);",
          "1161:  return found_fs;",
          "1162: }",
          "1173: static char *mk_devtmpfs(const char *name, char *path, const char *lxcpath)",
          "1174: {",
          "1175:  int ret;",
          "1176:  struct stat s;",
          "1177:  char tmp_path[MAXPATHLEN];",
          "1178:  char fstype[MAX_FSTYPE_LEN];",
          "1179:  uint64_t hash;",
          "1181:  if ( 0 != access(dev_base_path, F_OK) || 0 != stat(dev_base_path, &s) || 0 == S_ISDIR(s.st_mode) ) {",
          "1183:   ret = mkdir(dev_base_path, S_IRWXU | S_IRGRP | S_IXGRP | S_IROTH | S_IXOTH);",
          "1184:   if ( ret ) {",
          "1185:    SYSERROR( \"Unable to create /dev/.lxc for autodev\" );",
          "1186:    return NULL;",
          "1187:   }",
          "1188:  }",
          "1201:  if( ! mount_check_fs( \"/dev\", fstype )",
          "1202:   || strcmp( \"devtmpfs\", fstype ) ) {",
          "1205:   if ( ! mount_check_fs( \"/dev/.lxc\", NULL ) ) {",
          "1212:    ERROR(\"/dev/.lxc is not setup - taking fallback\" );",
          "1213:    return NULL;",
          "1214:   }",
          "1215:  }",
          "1217:  if ( 0 != access(dev_user_path, F_OK) || 0 != stat(dev_user_path, &s) || 0 == S_ISDIR(s.st_mode) ) {",
          "1223:   ret = mkdir(dev_user_path, S_IRWXU | S_IRWXG | S_IRWXO | S_ISVTX);",
          "1224:   if ( ret ) {",
          "1226:    ERROR(\"Unable to create /dev/.lxc/user\");",
          "1227:   }",
          "1229:   chmod(dev_user_path, S_IRWXU | S_IRWXG | S_IRWXO | S_ISVTX);",
          "1230:  }",
          "1238:  ret = snprintf(tmp_path, MAXPATHLEN, \"%s/%s\", lxcpath, name);",
          "1239:  if (ret < 0 || ret >= MAXPATHLEN)",
          "1240:   return NULL;",
          "1242:  hash = fnv_64a_buf(tmp_path, ret, FNV1A_64_INIT);",
          "1244:  ret = snprintf(tmp_path, MAXPATHLEN, \"%s/%s.%016\" PRIx64, dev_base_path, name, hash);",
          "1245:  if (ret < 0 || ret >= MAXPATHLEN)",
          "1246:   return NULL;",
          "1248:  if ( 0 != access(tmp_path, F_OK) || 0 != stat(tmp_path, &s) || 0 == S_ISDIR(s.st_mode) ) {",
          "1249:   ret = mkdir(tmp_path, S_IRWXU | S_IRGRP | S_IXGRP | S_IROTH | S_IXOTH);",
          "1250:   if ( ret ) {",
          "1253:    INFO(\"Setup in /dev/.lxc failed.  Trying /dev/.lxc/user.\" );",
          "1255:    ret = snprintf(tmp_path, MAXPATHLEN, \"%s/%s.%016\" PRIx64, dev_user_path, name, hash);",
          "1256:    if (ret < 0 || ret >= MAXPATHLEN)",
          "1257:     return NULL;",
          "1259:    if ( 0 != access(tmp_path, F_OK) || 0 != stat(tmp_path, &s) || 0 == S_ISDIR(s.st_mode) ) {",
          "1260:     ret = mkdir(tmp_path, S_IRWXU | S_IRGRP | S_IXGRP | S_IROTH | S_IXOTH);",
          "1261:     if ( ret ) {",
          "1262:      ERROR(\"Container /dev setup in host /dev failed - taking fallback\" );",
          "1263:      return NULL;",
          "1264:     }",
          "1265:    }",
          "1266:   }",
          "1267:  }",
          "1269:  strcpy( path, tmp_path );",
          "1270:  return path;",
          "1271: }",
          "1280:  struct stat s;",
          "1281:  char path[MAXPATHLEN];",
          "1282:  char host_path[MAXPATHLEN];",
          "1283:  char devtmpfs_path[MAXPATHLEN];",
          "1287:  ret = snprintf(host_path, MAXPATHLEN, \"%s/%s/rootfs.dev\", lxcpath, name);",
          "1288:  if (ret < 0 || ret > MAXPATHLEN)",
          "1289:   return -1;",
          "1291:  ret = snprintf(path, MAXPATHLEN, \"%s/dev\", root);",
          "1292:  if (ret < 0 || ret > MAXPATHLEN)",
          "1295:  if (mk_devtmpfs( name, devtmpfs_path, lxcpath ) ) {",
          "1304:   unlink( host_path );",
          "1305:   rmdir( host_path );",
          "1306:   ret = symlink(devtmpfs_path, host_path);",
          "1308:   if ( ret < 0 ) {",
          "1309:    SYSERROR(\"WARNING: Failed to create symlink '%s'->'%s'\", host_path, devtmpfs_path);",
          "1310:   }",
          "1311:   DEBUG(\"Bind mounting %s to %s\", devtmpfs_path , path );",
          "1312:   ret = mount(devtmpfs_path, path, NULL, MS_BIND, 0 );",
          "1313:  } else {",
          "1315:   if ( ! mount_check_fs( host_path, NULL ) ) {",
          "1316:    DEBUG(\"Mounting tmpfs to %s\", host_path );",
          "1317:    ret = mount(\"none\", path, \"tmpfs\", 0, \"size=100000,mode=755\");",
          "1318:   } else {",
          "1320:    DEBUG(\"Bind mounting %s to %s\", host_path, path );",
          "1321:    ret = mount(host_path , path, NULL, MS_BIND, 0 );",
          "1322:   }",
          "1324:  if (ret) {",
          "1325:   SYSERROR(\"Failed to mount /dev at %s\", root);",
          "1326:   return -1;",
          "1328:  ret = snprintf(path, MAXPATHLEN, \"%s/dev/pts\", root);",
          "1329:  if (ret < 0 || ret >= MAXPATHLEN)",
          "1335:  if ( 0 != access(path, F_OK) || 0 != stat(path, &s) || 0 == S_ISDIR(s.st_mode) ) {",
          "",
          "[Added Lines]",
          "1095:  size_t clen;",
          "1096:  char *path;",
          "1101:  clen = strlen(root) + 9;",
          "1102:  path = alloca(clen);",
          "1104:  ret = snprintf(path, clen, \"%s/dev\", root);",
          "1105:  if (ret < 0 || ret >= clen)",
          "1108:  if (!dir_exists(path)) {",
          "1109:   WARN(\"No /dev on container rootfs.\");",
          "1110:   WARN(\"Proceeding without autodev setup\");",
          "1111:   return 0;",
          "1114:  if (mount(\"none\", path, \"tmpfs\", 0, \"size=100000,mode=755\")) {",
          "1115:   SYSERROR(\"Failed mounting tmpfs onto %s\\n\", path);",
          "1116:   return false;",
          "1119:  INFO(\"Mounted tmpfs onto %s\",  path);",
          "1121:  ret = snprintf(path, clen, \"%s/dev/pts\", root);",
          "1122:  if (ret < 0 || ret >= clen)",
          "1129:  if (!dir_exists(path)) {",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1395:  return 0;",
          "1396: }",
          "1456: static int setup_rootfs(struct lxc_conf *conf)",
          "1457: {",
          "1458:  const struct lxc_rootfs *rootfs = &conf->rootfs;",
          "",
          "[Removed Lines]",
          "1402: int lxc_delete_autodev(struct lxc_handler *handler)",
          "1403: {",
          "1404:  int ret;",
          "1405:  struct stat s;",
          "1406:  struct lxc_conf *lxc_conf = handler->conf;",
          "1407:  const char *name = handler->name;",
          "1408:  const char *lxcpath = handler->lxcpath;",
          "1409:  char tmp_path[MAXPATHLEN];",
          "1410:  uint64_t hash;",
          "1412:  if ( lxc_conf->autodev <= 0 )",
          "1413:   return 0;",
          "1416:  if ( lxc_conf->reboot == 1 )",
          "1417:   return 0;",
          "1424:  ret = snprintf(tmp_path, MAXPATHLEN, \"%s/%s\", lxcpath, name);",
          "1425:  if (ret < 0 || ret >= MAXPATHLEN)",
          "1426:   return -1;",
          "1428:  hash = fnv_64a_buf(tmp_path, ret, FNV1A_64_INIT);",
          "1431:  ret = snprintf(tmp_path, MAXPATHLEN, \"%s/%s.%016\" PRIx64, dev_base_path, name, hash);",
          "1432:  if (ret < 0 || ret >= MAXPATHLEN)",
          "1433:   return -1;",
          "1435:  if ( 0 != access(tmp_path, F_OK) || 0 != stat(tmp_path, &s) || 0 == S_ISDIR(s.st_mode) ) {",
          "1437:   ret = snprintf(tmp_path, MAXPATHLEN, \"%s/%s.%016\" PRIx64, dev_user_path, name, hash);",
          "1438:   if (ret < 0 || ret >= MAXPATHLEN)",
          "1439:    return -1;",
          "1441:   if ( 0 != access(tmp_path, F_OK) || 0 != stat(tmp_path, &s) || 0 == S_ISDIR(s.st_mode) ) {",
          "1442:    WARN(\"Failed to locate autodev /dev/.lxc and /dev/.lxc/user.\" );",
          "1443:    return -1;",
          "1444:   }",
          "1445:  }",
          "1448:  INFO(\"Cleaning %s\", tmp_path );",
          "1449:  if ( 0 != lxc_rmdir_onedev(tmp_path, NULL) ) {",
          "1450:   ERROR(\"Failed to cleanup autodev\" );",
          "1451:  }",
          "1453:  return 0;",
          "1454: }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/lxc/start.c||src/lxc/start.c": [
          "File: src/lxc/start.c -> src/lxc/start.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "490:  lxc_console_delete(&handler->conf->console);",
          "491:  lxc_delete_tty(&handler->conf->tty_info);",
          "493:  close(handler->conf->maincmd_fd);",
          "494:  handler->conf->maincmd_fd = -1;",
          "495:  free(handler->name);",
          "",
          "[Removed Lines]",
          "492:  lxc_delete_autodev(handler);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "ea986a874775a0800194822aed9359e73297970d",
      "candidate_info": {
        "commit_hash": "ea986a874775a0800194822aed9359e73297970d",
        "repo": "lxc/lxc",
        "commit_url": "https://github.com/lxc/lxc/commit/ea986a874775a0800194822aed9359e73297970d",
        "files": [
          "src/lxc/conf.c"
        ],
        "message": "Add flag in mount_entry to skip NODEV in case of a persistent dev entry\n\nSigned-off-by: Rodrigo Vaz <rodrigo@heroku.com>",
        "before_after_code_files": [
          "src/lxc/conf.c||src/lxc/conf.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/lxc/conf.c||src/lxc/conf.c"
          ],
          "candidate": [
            "src/lxc/conf.c||src/lxc/conf.c"
          ]
        }
      },
      "candidate_diff": {
        "src/lxc/conf.c||src/lxc/conf.c": [
          "File: src/lxc/conf.c -> src/lxc/conf.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1635: static int mount_entry(const char *fsname, const char *target,",
          "1636:          const char *fstype, unsigned long mountflags,",
          "1638: {",
          "1639: #ifdef HAVE_STATVFS",
          "1640:  struct statvfs sb;",
          "",
          "[Removed Lines]",
          "1637:          const char *data, int optional, const char *rootfs)",
          "",
          "[Added Lines]",
          "1637:          const char *data, int optional, int dev, const char *rootfs)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1663:    unsigned long required_flags = rqd_flags;",
          "1664:    if (sb.f_flag & MS_NOSUID)",
          "1665:     required_flags |= MS_NOSUID;",
          "1667:     required_flags |= MS_NODEV;",
          "1668:    if (sb.f_flag & MS_RDONLY)",
          "1669:     required_flags |= MS_RDONLY;",
          "",
          "[Removed Lines]",
          "1666:    if (sb.f_flag & MS_NODEV)",
          "",
          "[Added Lines]",
          "1666:    if (sb.f_flag & MS_NODEV && !dev)",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1785:  char *mntdata;",
          "1786:  int ret;",
          "1787:  bool optional = hasmntopt(mntent, \"optional\") != NULL;",
          "1789:  char *rootfs_path = NULL;",
          "1790:  if (rootfs && rootfs->path)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1788:  bool dev = hasmntopt(mntent, \"dev\") != NULL;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1803:  }",
          "1805:  ret = mount_entry(mntent->mnt_fsname, path, mntent->mnt_type, mntflags,",
          "1808:  free(mntdata);",
          "1809:  return ret;",
          "",
          "[Removed Lines]",
          "1806:      mntdata, optional, rootfs_path);",
          "",
          "[Added Lines]",
          "1807:      mntdata, optional, dev, rootfs_path);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "4d5b72a186dcf3700b4e5af44d044edf1036980c",
      "candidate_info": {
        "commit_hash": "4d5b72a186dcf3700b4e5af44d044edf1036980c",
        "repo": "lxc/lxc",
        "commit_url": "https://github.com/lxc/lxc/commit/4d5b72a186dcf3700b4e5af44d044edf1036980c",
        "files": [
          "src/lxc/conf.c"
        ],
        "message": "Factorize handle of create=dir and create=file\n\nSigned-off-by: Nicolas Cornu <ncornu@aldebaran.com>",
        "before_after_code_files": [
          "src/lxc/conf.c||src/lxc/conf.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/lxc/conf.c||src/lxc/conf.c"
          ],
          "candidate": [
            "src/lxc/conf.c||src/lxc/conf.c"
          ]
        }
      },
      "candidate_diff": {
        "src/lxc/conf.c||src/lxc/conf.c": [
          "File: src/lxc/conf.c -> src/lxc/conf.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1804:  }",
          "1805: }",
          "1808: {",
          "1811:  int ret;",
          "1812:  FILE *pathfile = NULL;",
          "1816:  if (hasmntopt(mntent, \"create=dir\")) {",
          "1819:    ret = -1;",
          "1820:   }",
          "1821:  }",
          "1825:   pathdirname = dirname(pathdirname);",
          "1826:   if (mkdir_p(pathdirname, 0755) < 0) {",
          "1827:    WARN(\"Failed to create target directory\");",
          "1828:   }",
          "1830:   if (!pathfile) {",
          "1832:    ret = -1;",
          "1833:   }",
          "1834:   else",
          "1835:    fclose(pathfile);",
          "1836:  }",
          "1838:  cull_mntent_opt(mntent);",
          "",
          "[Removed Lines]",
          "1807: static inline int mount_entry_on_systemfs(struct mntent *mntent)",
          "1809:  unsigned long mntflags;",
          "1810:  char *mntdata;",
          "1813:  char* pathdirname = NULL;",
          "1814:  bool optional = hasmntopt(mntent, \"optional\") != NULL;",
          "1817:   if (mkdir_p(mntent->mnt_dir, 0755) < 0) {",
          "1818:    WARN(\"Failed to create mount target '%s'\", mntent->mnt_dir);",
          "1823:  if (hasmntopt(mntent, \"create=file\") && access(mntent->mnt_dir, F_OK)) {",
          "1824:   pathdirname = strdup(mntent->mnt_dir);",
          "1829:   pathfile = fopen(mntent->mnt_dir, \"wb\");",
          "1831:    WARN(\"Failed to create mount target '%s'\", mntent->mnt_dir);",
          "",
          "[Added Lines]",
          "1807: static int mount_entry_create_dir_file(const struct mntent *mntent,",
          "1808:            const char* path)",
          "1810:  char *pathdirname = NULL;",
          "1815:   if (mkdir_p(path, 0755) < 0) {",
          "1816:    WARN(\"Failed to create mount target '%s'\", path);",
          "1821:  if (hasmntopt(mntent, \"create=file\") && access(path, F_OK)) {",
          "1822:   pathdirname = strdup(path);",
          "1827:   pathfile = fopen(path, \"wb\");",
          "1829:    WARN(\"Failed to create mount target '%s'\", path);",
          "1835:  free(pathdirname);",
          "1836:  return ret;",
          "1837: }",
          "1839: static inline int mount_entry_on_systemfs(struct mntent *mntent)",
          "1840: {",
          "1841:  unsigned long mntflags;",
          "1842:  char *mntdata;",
          "1843:  int ret;",
          "1844:  bool optional = hasmntopt(mntent, \"optional\") != NULL;",
          "1846:  ret = mount_entry_create_dir_file(mntent, mntent->mnt_dir);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1845:  ret = mount_entry(mntent->mnt_fsname, mntent->mnt_dir,",
          "1846:      mntent->mnt_type, mntflags, mntdata, optional);",
          "1849:  free(mntdata);",
          "1851:  return ret;",
          "",
          "[Removed Lines]",
          "1848:  free(pathdirname);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1861:  char *mntdata;",
          "1862:  int r, ret = 0, offset;",
          "1863:  const char *lxcpath;",
          "1866:  bool optional = hasmntopt(mntent, \"optional\") != NULL;",
          "1868:  lxcpath = lxc_global_config_value(\"lxc.lxcpath\");",
          "",
          "[Removed Lines]",
          "1864:  FILE *pathfile = NULL;",
          "1865:  char *pathdirname = NULL;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1901:   goto out;",
          "1902:  }",
          "1925:  cull_mntent_opt(mntent);",
          "1927:  if (parse_mntopts(mntent->mnt_opts, &mntflags, &mntdata) < 0) {",
          "",
          "[Removed Lines]",
          "1904:  if (hasmntopt(mntent, \"create=dir\")) {",
          "1905:   if (mkdir_p(path, 0755) < 0) {",
          "1906:    WARN(\"Failed to create mount target '%s'\", path);",
          "1907:    ret = -1;",
          "1908:   }",
          "1909:  }",
          "1911:  if (hasmntopt(mntent, \"create=file\") && access(path, F_OK)) {",
          "1912:   pathdirname = strdup(path);",
          "1913:   pathdirname = dirname(pathdirname);",
          "1914:   if (mkdir_p(pathdirname, 0755) < 0) {",
          "1915:    WARN(\"Failed to create target directory\");",
          "1916:   }",
          "1917:   pathfile = fopen(path, \"wb\");",
          "1918:   if (!pathfile) {",
          "1919:    WARN(\"Failed to create mount target '%s'\", path);",
          "1920:    ret = -1;",
          "1921:   }",
          "1922:   else",
          "1923:    fclose(pathfile);",
          "1924:  }",
          "",
          "[Added Lines]",
          "1911:  ret = mount_entry_create_dir_file(mntent, path);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1935:  free(mntdata);",
          "1937: out:",
          "1939:  return ret;",
          "1940: }",
          "",
          "[Removed Lines]",
          "1938:  free(pathdirname);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1946:  unsigned long mntflags;",
          "1947:  char *mntdata;",
          "1948:  int ret;",
          "1951:  bool optional = hasmntopt(mntent, \"optional\") != NULL;",
          "",
          "[Removed Lines]",
          "1949:  FILE *pathfile = NULL;",
          "1950:  char *pathdirname = NULL;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "1957:   return -1;",
          "1958:  }",
          "1981:  cull_mntent_opt(mntent);",
          "1983:  if (parse_mntopts(mntent->mnt_opts, &mntflags, &mntdata) < 0) {",
          "",
          "[Removed Lines]",
          "1960:  if (hasmntopt(mntent, \"create=dir\")) {",
          "1961:   if (mkdir_p(path, 0755) < 0) {",
          "1962:    WARN(\"Failed to create mount target '%s'\", path);",
          "1963:    ret = -1;",
          "1964:   }",
          "1965:  }",
          "1967:  if (hasmntopt(mntent, \"create=file\") && access(path, F_OK)) {",
          "1968:   pathdirname = strdup(path);",
          "1969:   pathdirname = dirname(pathdirname);",
          "1970:   if (mkdir_p(pathdirname, 0755) < 0) {",
          "1971:    WARN(\"Failed to create target directory\");",
          "1972:   }",
          "1973:   pathfile = fopen(path, \"wb\");",
          "1974:   if (!pathfile) {",
          "1975:    WARN(\"Failed to create mount target '%s'\", path);",
          "1976:    ret = -1;",
          "1977:   }",
          "1978:   else",
          "1979:    fclose(pathfile);",
          "1980:  }",
          "",
          "[Added Lines]",
          "1945:  ret = mount_entry_create_dir_file(mntent, path);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "1988:  ret = mount_entry(mntent->mnt_fsname, path, mntent->mnt_type,",
          "1989:      mntflags, mntdata, optional);",
          "1992:  free(mntdata);",
          "1994:  return ret;",
          "",
          "[Removed Lines]",
          "1991:  free(pathdirname);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "ec50007fc2c90016a725b0a0ef329c039ad98265",
      "candidate_info": {
        "commit_hash": "ec50007fc2c90016a725b0a0ef329c039ad98265",
        "repo": "lxc/lxc",
        "commit_url": "https://github.com/lxc/lxc/commit/ec50007fc2c90016a725b0a0ef329c039ad98265",
        "files": [
          "src/lxc/bdev/lxcoverlay.c",
          "src/lxc/conf.c"
        ],
        "message": "Fix mount_entry_on_generic()\n\nIn mount_entry_on_generic() we dereferenced a NULL pointer whenever a container\nwithout a rootfs was created. (Since mount_entry_on_systemfs() passes them with\nNULL.) We have mount_entry_on_generic() check whether rootfs != NULL.\n\nWe also check whether rootfs != NULL in the functions ovl_mkdir() and\nmount_entry_create_aufs_dirs() and bail immediately. Rationale: For overlay and\naufs lxc.mount.entry entries users give us absolute paths to e.g. workdir and\nupperdir which we create for them. We currently use rootfs->path and the\nlxcpath for the container to check that users give us a sane path to create\nthose directories under and refuse if they do not. If we want to allow overlay\nmounts for containers without a rootfs they can easily be reworked.\n\nSigned-off-by: Christian Brauner <christian.brauner@mailbox.org>",
        "before_after_code_files": [
          "src/lxc/bdev/lxcoverlay.c||src/lxc/bdev/lxcoverlay.c",
          "src/lxc/conf.c||src/lxc/conf.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/lxc/conf.c||src/lxc/conf.c"
          ],
          "candidate": [
            "src/lxc/conf.c||src/lxc/conf.c"
          ]
        }
      },
      "candidate_diff": {
        "src/lxc/bdev/lxcoverlay.c||src/lxc/bdev/lxcoverlay.c": [
          "File: src/lxc/bdev/lxcoverlay.c -> src/lxc/bdev/lxcoverlay.c"
        ],
        "src/lxc/conf.c||src/lxc/conf.c": [
          "File: src/lxc/conf.c -> src/lxc/conf.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "858:  int ret,i;",
          "859:  struct stat s;",
          "867:  for (i = 0; i < sizeof(dev_symlinks) / sizeof(dev_symlinks[0]); i++) {",
          "868:   const struct dev_symlinks *d = &dev_symlinks[i];",
          "870:   if (ret < 0 || ret >= MAXPATHLEN)",
          "871:    return -1;",
          "",
          "[Removed Lines]",
          "862:  char *rootfs_path = NULL;",
          "863:  if (rootfs && rootfs->path)",
          "864:   rootfs_path = rootfs->mount;",
          "869:   ret = snprintf(path, sizeof(path), \"%s/dev/%s\", rootfs_path ? rootfs_path : \"\", d->name);",
          "",
          "[Added Lines]",
          "864:   ret = snprintf(path, sizeof(path), \"%s/dev/%s\", rootfs->path ? rootfs->mount : \"\", d->name);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1069:  size_t clen;",
          "1070:  char *path;",
          "1077:  INFO(\"Mounting container /dev\");",
          "1081:  path = alloca(clen);",
          "1084:  if (ret < 0 || ret >= clen)",
          "1085:   return -1;",
          "",
          "[Removed Lines]",
          "1073:  char *rootfs_path = NULL;",
          "1074:  if (rootfs && rootfs->path)",
          "1075:   rootfs_path = rootfs->mount;",
          "1080:  clen = (rootfs_path ? strlen(rootfs_path) : 0) + 9;",
          "1083:  ret = snprintf(path, clen, \"%s/dev\", rootfs_path ? rootfs_path : \"\");",
          "",
          "[Added Lines]",
          "1070:  clen = (rootfs->path ? strlen(rootfs->mount) : 0) + 9;",
          "1073:  ret = snprintf(path, clen, \"%s/dev\", rootfs->path ? rootfs->mount : \"\");",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1091:  }",
          "1093:  ret = safe_mount(\"none\", path, \"tmpfs\", 0, \"size=500000,mode=755\",",
          "1095:  if (ret != 0) {",
          "1096:   SYSERROR(\"Failed mounting tmpfs onto %s\\n\", path);",
          "1097:   return -1;",
          "",
          "[Removed Lines]",
          "1094:    rootfs_path);",
          "",
          "[Added Lines]",
          "1084:    rootfs->path ? rootfs->mount : NULL);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1100:  INFO(\"Mounted tmpfs onto %s\",  path);",
          "1103:  if (ret < 0 || ret >= clen)",
          "1104:   return -1;",
          "",
          "[Removed Lines]",
          "1102:  ret = snprintf(path, clen, \"%s/dev/pts\", rootfs_path ? rootfs_path : \"\");",
          "",
          "[Added Lines]",
          "1092:  ret = snprintf(path, clen, \"%s/dev/pts\", rootfs->path ? rootfs->mount : \"\");",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1143:  int i;",
          "1144:  mode_t cmask;",
          "1151:  INFO(\"Creating initial consoles under container /dev\");",
          "1154:  if (ret < 0 || ret >= MAXPATHLEN) {",
          "1155:   ERROR(\"Error calculating container /dev location\");",
          "1156:   return -1;",
          "",
          "[Removed Lines]",
          "1147:  char *rootfs_path = NULL;",
          "1148:  if (rootfs && rootfs->path)",
          "1149:   rootfs_path = rootfs->mount;",
          "1153:  ret = snprintf(path, MAXPATHLEN, \"%s/dev\", rootfs_path ? rootfs_path : \"\");",
          "",
          "[Added Lines]",
          "1138:  ret = snprintf(path, MAXPATHLEN, \"%s/dev\", rootfs->path ? rootfs->mount : \"\");",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1163:  cmask = umask(S_IXUSR | S_IXGRP | S_IXOTH);",
          "1164:  for (i = 0; i < sizeof(lxc_devs) / sizeof(lxc_devs[0]); i++) {",
          "1165:   const struct lxc_devs *d = &lxc_devs[i];",
          "1167:   if (ret < 0 || ret >= MAXPATHLEN)",
          "1168:    return -1;",
          "1169:   ret = mknod(path, d->mode, makedev(d->maj, d->min));",
          "",
          "[Removed Lines]",
          "1166:   ret = snprintf(path, MAXPATHLEN, \"%s/dev/%s\", rootfs_path ? rootfs_path : \"\", d->name);",
          "",
          "[Added Lines]",
          "1151:   ret = snprintf(path, MAXPATHLEN, \"%s/dev/%s\", rootfs->path ? rootfs->mount : \"\", d->name);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "1183:    }",
          "1184:    fclose(pathfile);",
          "1185:    if (safe_mount(hostpath, path, 0, MS_BIND, NULL,",
          "1187:     SYSERROR(\"Failed bind mounting device %s from host into container\",",
          "1188:      d->name);",
          "1189:     return -1;",
          "",
          "[Removed Lines]",
          "1186:       rootfs_path ? rootfs_path : NULL) != 0) {",
          "",
          "[Added Lines]",
          "1171:       rootfs->path ? rootfs->mount : NULL) != 0) {",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "1853:  int ret;",
          "1854:  bool optional = hasmntopt(mntent, \"optional\") != NULL;",
          "1856:  ret = mount_entry_create_dir_file(mntent, path, rootfs, lxc_name, lxc_path);",
          "1858:  if (ret < 0)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1845:  char *rootfs_path = NULL;",
          "1846:  if (rootfs && rootfs->path)",
          "1847:   rootfs_path = rootfs->mount;",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "1865:   return -1;",
          "1866:  }",
          "1873:  ret = mount_entry(mntent->mnt_fsname, path, mntent->mnt_type, mntflags,",
          "1876:  free(mntdata);",
          "1877:  return ret;",
          "",
          "[Removed Lines]",
          "1869:  char *rootfs_path = NULL;",
          "1870:  if (rootfs && rootfs->path)",
          "1871:   rootfs_path = rootfs->mount;",
          "1874:    mntdata, optional, rootfs_path);",
          "",
          "[Added Lines]",
          "1862:      mntdata, optional, rootfs_path);",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "1880: static inline int mount_entry_on_systemfs(struct mntent *mntent)",
          "1881: {",
          "1883: }",
          "1885: static int mount_entry_on_absolute_rootfs(struct mntent *mntent,",
          "",
          "[Removed Lines]",
          "1882:   return mount_entry_on_generic(mntent, mntent->mnt_dir, NULL, NULL, NULL);",
          "",
          "[Added Lines]",
          "1870:  return mount_entry_on_generic(mntent, mntent->mnt_dir, NULL, NULL, NULL);",
          "",
          "---------------"
        ]
      }
    }
  ]
}
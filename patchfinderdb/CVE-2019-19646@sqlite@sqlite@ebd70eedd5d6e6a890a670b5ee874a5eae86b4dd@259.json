{
  "cve_id": "CVE-2019-19646",
  "cve_desc": "pragma.c in SQLite through 3.30.1 mishandles NOT NULL in an integrity_check PRAGMA command in certain cases of generated columns.",
  "repo": "sqlite/sqlite",
  "patch_hash": "ebd70eedd5d6e6a890a670b5ee874a5eae86b4dd",
  "patch_info": {
    "commit_hash": "ebd70eedd5d6e6a890a670b5ee874a5eae86b4dd",
    "repo": "sqlite/sqlite",
    "commit_url": "https://github.com/sqlite/sqlite/commit/ebd70eedd5d6e6a890a670b5ee874a5eae86b4dd",
    "files": [
      "manifest",
      "manifest.uuid",
      "src/pragma.c",
      "test/gencol1.test"
    ],
    "message": "Fix the NOT NULL verification logic in PRAGMA integrity_check so that it works for generated columns whose value is the result of a comparison operator. Ticket [bd8c280671ba44a7]\n\nFossilOrigin-Name: f3b39c71b88cb6721f443de56cdce4c08252453a5e340b00a2bd88dc10c42400",
    "before_after_code_files": [
      "manifest.uuid||manifest.uuid",
      "src/pragma.c||src/pragma.c",
      "test/gencol1.test||test/gencol1.test"
    ]
  },
  "patch_diff": {
    "manifest.uuid||manifest.uuid": [
      "File: manifest.uuid -> manifest.uuid",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "1: e3398c5ffb060b2b26334b8598e2c63953741e2d6f5124dbd6bdfc8e94742539",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ],
    "src/pragma.c||src/pragma.c": [
      "File: src/pragma.c -> src/pragma.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "1596:           if( j==pTab->iPKey ) continue;",
      "1597:           if( pTab->aCol[j].notNull==0 ) continue;",
      "1598:           sqlite3ExprCodeGetColumnOfTable(v, pTab, iDataCur, j, 3);",
      "1600:           jmp2 = sqlite3VdbeAddOp1(v, OP_NotNull, 3); VdbeCoverage(v);",
      "1601:           zErr = sqlite3MPrintf(db, \"NULL value in %s.%s\", pTab->zName,",
      "1602:                               pTab->aCol[j].zName);",
      "",
      "[Removed Lines]",
      "1599:           sqlite3VdbeChangeP5(v, OPFLAG_TYPEOFARG);",
      "",
      "[Added Lines]",
      "1599:           if( sqlite3VdbeGetOp(v,-1)->opcode==OP_Column ){",
      "1600:             sqlite3VdbeChangeP5(v, OPFLAG_TYPEOFARG);",
      "1601:           }",
      "",
      "---------------"
    ],
    "test/gencol1.test||test/gencol1.test": [
      "File: test/gencol1.test -> test/gencol1.test",
      "--- Hunk 1 ---",
      "[Context before]",
      "328:   INSERT OR REPLACE INTO t0(c0, c1) VALUES (2, 1), (1, 0)",
      "329: } {1 {FOREIGN KEY constraint failed}}",
      "331: finish_test",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "331: # 2019-12-09 ticket bd8c280671ba44a7",
      "332: # With generated columns, the sqlite3ExprGetColumnOfTable() routine might",
      "333: # generate a code sequence that does not end with OP_Column.  So check to",
      "334: # make sure that the last instruction generated is an OP_column prior to",
      "335: # applying the OPFLAG_TYPEOFARG optimization to NOT NULL checks in the",
      "336: # PRAGMA integrity_check code.",
      "337: #",
      "338: sqlite3 db :memory:",
      "339: do_execsql_test gencol1-12.10 {",
      "340:   CREATE TABLE t0 (c0, c1 NOT NULL AS (c0==0));",
      "341:   INSERT INTO t0(c0) VALUES (0);",
      "342:   PRAGMA integrity_check;",
      "343: } {ok}",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "012b15e2d7dfc7cc443a00e2d977c17d90160745",
      "candidate_info": {
        "commit_hash": "012b15e2d7dfc7cc443a00e2d977c17d90160745",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/012b15e2d7dfc7cc443a00e2d977c17d90160745",
        "files": [
          "manifest",
          "manifest.uuid",
          "src/dbstat.c",
          "test/stat.test"
        ],
        "message": "Get the aggregate=TRUE feature working on the DBSTAT virtual  table.\n\nFossilOrigin-Name: 16fef3db063830884de46d53a289f637a7204fe84fcdee7ea81dbb8bca578952",
        "before_after_code_files": [
          "manifest.uuid||manifest.uuid",
          "src/dbstat.c||src/dbstat.c",
          "test/stat.test||test/stat.test"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: 9b5722f0fe666b99677e5f333dd8413aefb9ace7a461d74f6558f0ac53768719",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/dbstat.c||src/dbstat.c": [
          "File: src/dbstat.c -> src/dbstat.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "76: typedef struct StatTable StatTable;",
          "",
          "[Removed Lines]",
          "59: #define VTAB_SCHEMA                                                          \\",
          "60:   \"CREATE TABLE xx( \"                                                        \\",
          "61:   \"  name       TEXT,\"          /*  0 Name of table or index */              \\",
          "62:   \"  path       TEXT,\"          /*  1 Path to page from root */              \\",
          "63:   \"  pageno     INTEGER,\"       /*  2 Page number */                         \\",
          "64:   \"  pagetype   TEXT,\"          /*  3 'internal', 'leaf' or 'overflow' */    \\",
          "65:   \"  ncell      INTEGER,\"       /*  4 Cells on page (0 for overflow) */      \\",
          "66:   \"  payload    INTEGER,\"       /*  5 Bytes of payload on this page */       \\",
          "67:   \"  unused     INTEGER,\"       /*  6 Bytes of unused space on this page */  \\",
          "68:   \"  mx_payload INTEGER,\"       /*  7 Largest payload size of all cells */   \\",
          "69:   \"  pgoffset   INTEGER,\"       /*  8 Offset of page in file */              \\",
          "70:   \"  pgsize     INTEGER,\"       /*  9 Size of the page */                    \\",
          "71:   \"  schema     TEXT HIDDEN,\"   /* 10 Database schema being analyzed */      \\",
          "72:   \"  aggregate  BOOLEAN HIDDEN\" /* 11 aggregate info for each table */       \\",
          "73:   \");\"",
          "",
          "[Added Lines]",
          "59: static const char zDbstatSchema[] =",
          "60:   \"CREATE TABLE x(\"",
          "73:   \")\"",
          "74: ;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "165:   }else{",
          "166:     iDb = 0;",
          "167:   }",
          "169:   if( rc==SQLITE_OK ){",
          "170:     pTab = (StatTable *)sqlite3_malloc64(sizeof(StatTable));",
          "171:     if( pTab==0 ) rc = SQLITE_NOMEM_BKPT;",
          "",
          "[Removed Lines]",
          "168:   rc = sqlite3_declare_vtab(db, VTAB_SCHEMA);",
          "",
          "[Added Lines]",
          "170:   rc = sqlite3_declare_vtab(db, zDbstatSchema);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "323:   pCsr->isEof = 0;",
          "324: }",
          "329: static int statClose(sqlite3_vtab_cursor *pCursor){",
          "330:   StatCursor *pCsr = (StatCursor *)pCursor;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "329: static void statResetCounts(StatCursor *pCsr){",
          "330:   pCsr->nCell = 0;",
          "331:   pCsr->nMxPayload = 0;",
          "332:   pCsr->nUnused = 0;",
          "333:   pCsr->nPayload = 0;",
          "334:   pCsr->szPage = 0;",
          "335:   pCsr->nPage = 0;",
          "336: }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "481:   sqlite3_file *fd;",
          "482:   sqlite3_int64 x[2];",
          "491:   fd = sqlite3PagerFile(pPager);",
          "492:   x[0] = pCsr->iPageno;",
          "493:   if( sqlite3OsFileControl(fd, 230440, &x)==SQLITE_OK ){",
          "494:     pCsr->iOffset = x[0];",
          "496:   }",
          "497: }",
          "502: static int statNext(sqlite3_vtab_cursor *pCursor){",
          "503:   int rc;",
          "",
          "[Removed Lines]",
          "485:   pCsr->szPage = sqlite3BtreeGetPageSize(pBt);",
          "486:   pCsr->iOffset = (i64)pCsr->szPage * (pCsr->iPageno - 1);",
          "495:     pCsr->szPage = (int)x[1];",
          "",
          "[Added Lines]",
          "506:     pCsr->szPage += x[1];",
          "507:   }else{",
          "509:     pCsr->szPage += sqlite3BtreeGetPageSize(pBt);",
          "510:     pCsr->iOffset = (i64)pCsr->szPage * (pCsr->iPageno - 1);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "514: statNextRestart:",
          "515:   if( pCsr->aPage[0].pPg==0 ){",
          "516:     rc = sqlite3_step(pCsr->pStmt);",
          "517:     if( rc==SQLITE_ROW ){",
          "518:       int nPage;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "534:     statResetCounts(pCsr);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "525:       rc = sqlite3PagerGet(pPager, iRoot, &pCsr->aPage[0].pPg, 0);",
          "526:       pCsr->aPage[0].iPgno = iRoot;",
          "527:       pCsr->aPage[0].iCell = 0;",
          "529:       pCsr->iPage = 0;",
          "531:     }else{",
          "532:       pCsr->isEof = 1;",
          "533:       return sqlite3_reset(pCsr->pStmt);",
          "534:     }",
          "535:   }else{",
          "538:     StatPage *p = &pCsr->aPage[pCsr->iPage];",
          "540:     while( p->iCell<p->nCell ){",
          "541:       StatCell *pCell = &p->aCell[p->iCell];",
          "544:         sqlite3BtreeEnter(pBt);",
          "545:         nUsable = sqlite3BtreeGetPageSize(pBt) -",
          "546:                         sqlite3BtreeGetReserveNoMutex(pBt);",
          "547:         sqlite3BtreeLeave(pBt);",
          "556:         if( pCell->iOvfl<pCell->nOvfl-1 ){",
          "559:         }else{",
          "562:         }",
          "563:         pCell->iOvfl++;",
          "566:       }",
          "567:       if( p->iRightChildPg ) break;",
          "568:       p->iCell++;",
          "",
          "[Removed Lines]",
          "528:       pCsr->aPage[0].zPath = z = sqlite3_mprintf(\"/\");",
          "530:       if( z==0 ) rc = SQLITE_NOMEM_BKPT;",
          "542:       if( pCell->iOvfl<pCell->nOvfl ){",
          "543:         int nUsable;",
          "548:         pCsr->zName = (char *)sqlite3_column_text(pCsr->pStmt, 0);",
          "549:         pCsr->iPageno = pCell->aOvfl[pCell->iOvfl];",
          "550:         pCsr->zPagetype = \"overflow\";",
          "551:         pCsr->nCell = 0;",
          "552:         pCsr->nMxPayload = 0;",
          "553:         pCsr->zPath = z = sqlite3_mprintf(",
          "554:             \"%s%.3x+%.6x\", p->zPath, p->iCell, pCell->iOvfl",
          "555:         );",
          "557:           pCsr->nUnused = 0;",
          "558:           pCsr->nPayload = nUsable - 4;",
          "560:           pCsr->nPayload = pCell->nLastOvfl;",
          "561:           pCsr->nUnused = nUsable - 4 - pCsr->nPayload;",
          "564:         statSizeAndOffset(pCsr);",
          "565:         return z==0 ? SQLITE_NOMEM_BKPT : SQLITE_OK;",
          "",
          "[Added Lines]",
          "547:       if( !pCsr->isAgg ){",
          "548:         pCsr->aPage[0].zPath = z = sqlite3_mprintf(\"/\");",
          "549:         if( z==0 ) rc = SQLITE_NOMEM_BKPT;",
          "550:       }",
          "552:       pCsr->nPage = 1;",
          "560:     if( !pCsr->isAgg ) statResetCounts(pCsr);",
          "563:       while( pCell->iOvfl<pCell->nOvfl ){",
          "564:         int nUsable, iOvfl;",
          "569:         pCsr->nPage++;",
          "570:         statSizeAndOffset(pCsr);",
          "572:           pCsr->nPayload += nUsable - 4;",
          "574:           pCsr->nPayload += pCell->nLastOvfl;",
          "575:           pCsr->nUnused += nUsable - 4 - pCell->nLastOvfl;",
          "577:         iOvfl = pCell->iOvfl;",
          "579:         if( !pCsr->isAgg ){",
          "580:           pCsr->zName = (char *)sqlite3_column_text(pCsr->pStmt, 0);",
          "581:           pCsr->iPageno = pCell->aOvfl[iOvfl];",
          "582:           pCsr->zPagetype = \"overflow\";",
          "583:           pCsr->zPath = z = sqlite3_mprintf(",
          "584:               \"%s%.3x+%.6x\", p->zPath, p->iCell, iOvfl",
          "585:           );",
          "586:           return z==0 ? SQLITE_NOMEM_BKPT : SQLITE_OK;",
          "587:         }",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "571:     if( !p->iRightChildPg || p->iCell>p->nCell ){",
          "572:       statClearPage(p);",
          "576:     }",
          "577:     pCsr->iPage++;",
          "",
          "[Removed Lines]",
          "573:       if( pCsr->iPage==0 ) return statNext(pCursor);",
          "574:       pCsr->iPage--;",
          "",
          "[Added Lines]",
          "595:       if( pCsr->iPage>0 ){",
          "596:         pCsr->iPage--;",
          "597:       }else if( pCsr->isAgg ){",
          "600:         return SQLITE_OK;",
          "601:       }",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "587:       p[1].iPgno = p->aCell[p->iCell].iChildPg;",
          "588:     }",
          "589:     rc = sqlite3PagerGet(pPager, p[1].iPgno, &p[1].pPg, 0);",
          "590:     p[1].iCell = 0;",
          "592:     p->iCell++;",
          "594:   }",
          "",
          "[Removed Lines]",
          "591:     p[1].zPath = z = sqlite3_mprintf(\"%s%.3x/\", p->zPath, p->iCell);",
          "593:     if( z==0 ) rc = SQLITE_NOMEM_BKPT;",
          "",
          "[Added Lines]",
          "617:     pCsr->nPage++;",
          "619:     if( !pCsr->isAgg ){",
          "620:       p[1].zPath = z = sqlite3_mprintf(\"%s%.3x/\", p->zPath, p->iCell);",
          "621:       if( z==0 ) rc = SQLITE_NOMEM_BKPT;",
          "622:     }",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "620:           pCsr->zPagetype = \"corrupted\";",
          "621:           break;",
          "622:       }",
          "628:       nPayload = 0;",
          "629:       for(i=0; i<p->nCell; i++){",
          "630:         nPayload += p->aCell[i].nLocal;",
          "631:       }",
          "633:     }",
          "634:   }",
          "",
          "[Removed Lines]",
          "623:       pCsr->nCell = p->nCell;",
          "624:       pCsr->nUnused = p->nUnused;",
          "625:       pCsr->nMxPayload = p->nMxPayload;",
          "626:       pCsr->zPath = z = sqlite3_mprintf(\"%s\", p->zPath);",
          "627:       if( z==0 ) rc = SQLITE_NOMEM_BKPT;",
          "632:       pCsr->nPayload = nPayload;",
          "",
          "[Added Lines]",
          "653:       pCsr->nCell += p->nCell;",
          "654:       pCsr->nUnused += p->nUnused;",
          "655:       if( p->nMxPayload>pCsr->nMxPayload ) pCsr->nMxPayload = p->nMxPayload;",
          "656:       if( !pCsr->isAgg ){",
          "657:         pCsr->zPath = z = sqlite3_mprintf(\"%s\", p->zPath);",
          "658:         if( z==0 ) rc = SQLITE_NOMEM_BKPT;",
          "659:       }",
          "664:       pCsr->nPayload += nPayload;",
          "669:       if( pCsr->isAgg ) goto statNextRestart;",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "722:       sqlite3_result_text(ctx, pCsr->zName, -1, SQLITE_TRANSIENT);",
          "723:       break;",
          "726:       break;",
          "729:       break;",
          "732:       break;",
          "734:       sqlite3_result_int(ctx, pCsr->nCell);",
          "",
          "[Removed Lines]",
          "725:       sqlite3_result_text(ctx, pCsr->zPath, -1, SQLITE_TRANSIENT);",
          "728:       sqlite3_result_int64(ctx, pCsr->iPageno);",
          "731:       sqlite3_result_text(ctx, pCsr->zPagetype, -1, SQLITE_STATIC);",
          "",
          "[Added Lines]",
          "762:       if( !pCsr->isAgg ){",
          "763:         sqlite3_result_text(ctx, pCsr->zPath, -1, SQLITE_TRANSIENT);",
          "764:       }",
          "767:       if( pCsr->isAgg ){",
          "768:         sqlite3_result_int64(ctx, pCsr->nPage);",
          "769:       }else{",
          "770:         sqlite3_result_int64(ctx, pCsr->iPageno);",
          "771:       }",
          "774:       if( !pCsr->isAgg ){",
          "775:         sqlite3_result_text(ctx, pCsr->zPagetype, -1, SQLITE_STATIC);",
          "776:       }",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "743:       sqlite3_result_int(ctx, pCsr->nMxPayload);",
          "744:       break;",
          "747:       break;",
          "749:       sqlite3_result_int(ctx, pCsr->szPage);",
          "",
          "[Removed Lines]",
          "746:       sqlite3_result_int64(ctx, pCsr->iOffset);",
          "",
          "[Added Lines]",
          "791:       if( !pCsr->isAgg ){",
          "792:         sqlite3_result_int64(ctx, pCsr->iOffset);",
          "793:       }",
          "",
          "---------------"
        ],
        "test/stat.test||test/stat.test": [
          "File: test/stat.test -> test/stat.test",
          "--- Hunk 1 ---",
          "[Context before]",
          "134:   t3 /00f/ 23 leaf 2 738 268 370                         \\",
          "135: ]",
          "137: # With every index entry overflowing, make sure no pages are missed",
          "138: # (other than the locking page which is 64 in this test build.)",
          "139: #",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "137: do_execsql_test stat-2.1agg {",
          "138:   SELECT * FROM dbstat WHERE aggregate=TRUE ORDER BY name;",
          "139: } [list \\",
          "140:   sqlite_autoindex_t3_1 {}  5 {} 32  3898 1065 132 {}  5120 \\",
          "141:   sqlite_master         {}  1 {}  2    84  824  49 {}  1024 \\",
          "142:   t3                    {} 17 {} 47 11188 5815 370 {} 17408 \\",
          "143: ]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "171:   t4 /000+000006 18 overflow 0 1020 0 0      \\",
          "172: ]",
          "174: do_execsql_test stat-4.1 {",
          "175:   CREATE TABLE t5(x);",
          "176:   CREATE INDEX i5 ON t5(x);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "182: do_execsql_test stat-3.2 {",
          "183:   SELECT *, '|' FROM dbstat WHERE aggregate=TRUE ORDER BY name;",
          "184: } [list \\",
          "185:   i4            {} 9 {} 1 7782 1386 7782 {} 9216 | \\",
          "186:   sqlite_master {} 1 {} 2   74  834   40 {} 1024 | \\",
          "187:   t4            {} 8 {} 1 7780  367 7780 {} 8192 | \\",
          "188: ]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "201:   t1 /001+000000 4 overflow 0 1020 0 0    \\",
          "202: ]",
          "204: do_catchsql_test stat-6.1 {",
          "205:   CREATE VIRTUAL TABLE temp.s2 USING dbstat(mainx);",
          "206: } {1 {no such database: mainx}}",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "221: do_execsql_test stat-5.20 {",
          "222:   SELECT name, quote(path), pageno, quote(pagetype), ncell, payload,",
          "223:          unused, mx_payload, '|' FROM dbstat('main',1);",
          "224: } {sqlite_master NULL 1 NULL 1 34 878 34 | tx NULL 1 NULL 0 0 1016 0 |}",
          "225: do_execsql_test stat-5.21 {",
          "226:   SELECT name, quote(path), pageno, quote(pagetype), ncell, payload,",
          "227:          unused, mx_payload, '|' FROM dbstat('aux1',1);",
          "228: } {sqlite_master NULL 1 NULL 1 34 878 34 | t1 NULL 3 NULL 2 3033 5 1517 |}",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "ed26483346dc9b6925330e45786bf589735ddbf0",
      "candidate_info": {
        "commit_hash": "ed26483346dc9b6925330e45786bf589735ddbf0",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/ed26483346dc9b6925330e45786bf589735ddbf0",
        "files": [
          "manifest",
          "manifest.uuid",
          "src/test_fs.c"
        ],
        "message": "We learn that readdir_r() is deprecated in favor of plain old readdir(), which is now suppose to be threadsafe using thread-local storage.  So remove the use of readdir_r() from the test code.  (SQLite itself never calls readdir() or readdir_r()).\n\nFossilOrigin-Name: 7a0a26ed380dd0bdda50b0204b30b53bbbbc70f278eba02f91541ac6c691aef2",
        "before_after_code_files": [
          "manifest.uuid||manifest.uuid",
          "src/test_fs.c||src/test_fs.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: b99f8512c06b9d47e48b028781265512ce8b812ae4e6af0a7139a093cf9a8f74",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/test_fs.c||src/test_fs.c": [
          "File: src/test_fs.c -> src/test_fs.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "238:   if( pCsr->pDir ){",
          "239:     struct DIRENT *pRes = 0;",
          "241:     pRes = readdir(pCsr->pDir);",
          "242:     if( pRes!=0 ){",
          "243:       memcpy(&pCsr->entry, pRes, sizeof(struct DIRENT));",
          "244:     }",
          "248:     if( pRes==0 ){",
          "249:       closedir(pCsr->pDir);",
          "250:       pCsr->pDir = 0;",
          "",
          "[Removed Lines]",
          "240: #if defined(__MINGW_H)",
          "245: #else",
          "246:     readdir_r(pCsr->pDir, &pCsr->entry, &pRes);",
          "247: #endif",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "03c5c213289baed1f809d3e58dee1e2abfb72f2b",
      "candidate_info": {
        "commit_hash": "03c5c213289baed1f809d3e58dee1e2abfb72f2b",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/03c5c213289baed1f809d3e58dee1e2abfb72f2b",
        "files": [
          "manifest",
          "manifest.uuid",
          "src/expr.c"
        ],
        "message": "OSSFuzz found a case where an assert() inside sqlite3ExprCompare() can be true.  Test case added to TH3.\n\nFossilOrigin-Name: 23b62fb160d86dc9d9073bcc714601f5b7695f96abd893eafecf4b2e565b87f2",
        "before_after_code_files": [
          "manifest.uuid||manifest.uuid",
          "src/expr.c||src/expr.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: d1db8d5894450b24bb0335983503d9bbf6cc48a0ae4b83291283fb2d32b6b25b",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/expr.c||src/expr.c": [
          "File: src/expr.c -> src/expr.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "4784:      && sqlite3ExprCompare(pParse, pA->pLeft, pB->pLeft, iTab) ) return 2;",
          "4785:     if( sqlite3ExprCompare(pParse, pA->pRight, pB->pRight, iTab) ) return 2;",
          "4786:     if( sqlite3ExprListCompare(pA->x.pList, pB->x.pList, iTab) ) return 2;",
          "4789:       if( pA->iColumn!=pB->iColumn ) return 2;",
          "4790:       if( pA->iTable!=pB->iTable",
          "4791:        && (pA->iTable!=iTab || NEVER(pB->iTable>=0)) ) return 2;",
          "",
          "[Removed Lines]",
          "4787:     assert( (combinedFlags & EP_Reduced)==0 );",
          "4788:     if( pA->op!=TK_STRING && pA->op!=TK_TRUEFALSE ){",
          "",
          "[Added Lines]",
          "4787:     if( pA->op!=TK_STRING",
          "4788:      && pA->op!=TK_TRUEFALSE",
          "4789:      && (combinedFlags & EP_Reduced)==0",
          "4790:     ){",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "4509ffa3621d1e44a3d4ba5fbf90dd9a629a9053",
      "candidate_info": {
        "commit_hash": "4509ffa3621d1e44a3d4ba5fbf90dd9a629a9053",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/4509ffa3621d1e44a3d4ba5fbf90dd9a629a9053",
        "files": [
          "manifest",
          "manifest.uuid",
          "src/sqliteInt.h"
        ],
        "message": "Always use the stdlib.h intptr_t type for pointer-integer conversions, when it is available.\n\nFossilOrigin-Name: c0d932449db3deed42a99bd948aab61e56b2d8441d7de5243688695ff04e8177",
        "before_after_code_files": [
          "manifest.uuid||manifest.uuid",
          "src/sqliteInt.h||src/sqliteInt.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: 59c9e73f86b89ee17b0bce47bcb93f5b5ace5b7985678287195002afb9d40cd8",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/sqliteInt.h||src/sqliteInt.h": [
          "File: src/sqliteInt.h -> src/sqliteInt.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "216: # define SQLITE_INT_TO_PTR(X)  ((void*)(__PTRDIFF_TYPE__)(X))",
          "217: # define SQLITE_PTR_TO_INT(X)  ((int)(__PTRDIFF_TYPE__)(X))",
          "219: # define SQLITE_INT_TO_PTR(X)  ((void*)&((char*)0)[X])",
          "220: # define SQLITE_PTR_TO_INT(X)  ((int)(((char*)X)-(char*)0))",
          "225: # define SQLITE_INT_TO_PTR(X)  ((void*)(X))",
          "226: # define SQLITE_PTR_TO_INT(X)  ((int)(X))",
          "",
          "[Removed Lines]",
          "222: # define SQLITE_INT_TO_PTR(X)  ((void*)(intptr_t)(X))",
          "223: # define SQLITE_PTR_TO_INT(X)  ((int)(intptr_t)(X))",
          "",
          "[Added Lines]",
          "216: # define SQLITE_INT_TO_PTR(X)  ((void*)(intptr_t)(X))",
          "217: # define SQLITE_PTR_TO_INT(X)  ((int)(intptr_t)(X))",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "c589acbc501fa0f04e1f818b2fce94131fd05542",
      "candidate_info": {
        "commit_hash": "c589acbc501fa0f04e1f818b2fce94131fd05542",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/c589acbc501fa0f04e1f818b2fce94131fd05542",
        "files": [
          "manifest",
          "manifest.uuid",
          "src/vtab.c",
          "test/fts4rename.test"
        ],
        "message": "Fix a problem allowing a Table object to be deleted from within a call to the xDestroy method of the associated virtual table, causing a use-after-free error.\n\nFossilOrigin-Name: 1dbbb0101e8213b92b9a4c78c0fd2f9d0240a8ea3b40dff1033d1b8d71fb04ef",
        "before_after_code_files": [
          "manifest.uuid||manifest.uuid",
          "src/vtab.c||src/vtab.c",
          "test/fts4rename.test||test/fts4rename.test"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: b6d7d42b7426622a26b67809cd1f21285fea120aa1897377b9946840463b41f1",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/vtab.c||src/vtab.c": [
          "File: src/vtab.c -> src/vtab.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "841:     p = vtabDisconnectAll(db, pTab);",
          "842:     xDestroy = p->pMod->pModule->xDestroy;",
          "844:     rc = xDestroy(p->pVtab);",
          "846:     if( rc==SQLITE_OK ){",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "844:     pTab->nTabRef++;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "849:       pTab->pVTable = 0;",
          "850:       sqlite3VtabUnlock(p);",
          "851:     }",
          "852:   }",
          "854:   return rc;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "853:     sqlite3DeleteTable(db, pTab);",
          "",
          "---------------"
        ],
        "test/fts4rename.test||test/fts4rename.test": [
          "File: test/fts4rename.test -> test/fts4rename.test",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: # 2019 April 30",
          "2: #",
          "3: # The author disclaims copyright to this source code.  In place of",
          "4: # a legal notice, here is a blessing:",
          "5: #",
          "6: #    May you do good and not evil.",
          "7: #    May you find forgiveness for yourself and forgive others.",
          "8: #    May you share freely, never taking more than you give.",
          "9: #",
          "10: #*************************************************************************",
          "11: #",
          "13: set testdir [file dirname $argv0]",
          "14: source $testdir/tester.tcl",
          "15: source $testdir/fts3_common.tcl",
          "16: set ::testprefix fts4rename",
          "18: # If SQLITE_ENABLE_FTS3 is defined, omit this file.",
          "19: ifcapable !fts3 {",
          "20:   finish_test",
          "21:   return",
          "22: }",
          "24: do_execsql_test 1.0 {",
          "25:   CREATE VIRTUAL TABLE temp.t1 USING fts3(a);",
          "26:   BEGIN;",
          "27:   CREATE TABLE t2(x);",
          "28: } {}",
          "30: do_catchsql_test 1.1 {",
          "31:   ALTER TABLE t1_content RENAME c0a TO docid;",
          "32: } {1 {duplicate column name: docid}}",
          "34: do_catchsql_test 1.2 {",
          "35:   UPDATE t1 SET Col0 = 1 ;",
          "36: } {1 {no such column: Col0}}",
          "38: do_catchsql_test 1.3 {",
          "39:   ROLLBACK;",
          "40:   DROP TABLE t1;",
          "41: } {0 {}}",
          "43: finish_test",
          "",
          "---------------"
        ]
      }
    }
  ]
}
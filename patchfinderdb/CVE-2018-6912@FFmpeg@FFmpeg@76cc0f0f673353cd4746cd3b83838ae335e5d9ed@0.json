{
  "cve_id": "CVE-2018-6912",
  "cve_desc": "The decode_plane function in libavcodec/utvideodec.c in FFmpeg through 3.4.2 allows remote attackers to cause a denial of service (out of array read) via a crafted AVI file.",
  "repo": "FFmpeg/FFmpeg",
  "patch_hash": "76cc0f0f673353cd4746cd3b83838ae335e5d9ed",
  "patch_info": {
    "commit_hash": "76cc0f0f673353cd4746cd3b83838ae335e5d9ed",
    "repo": "FFmpeg/FFmpeg",
    "commit_url": "https://github.com/FFmpeg/FFmpeg/commit/76cc0f0f673353cd4746cd3b83838ae335e5d9ed",
    "files": [
      "libavcodec/utvideodec.c"
    ],
    "message": "avcodec/utvideodec: Add several out of array read related checks\n\nFixes: OV_decode_plane.avi\n\nFound-by: GwanYeong Kim <gy741.kim@gmail.com>\nSigned-off-by: Michael Niedermayer <michael@niedermayer.cc>",
    "before_after_code_files": [
      "libavcodec/utvideodec.c||libavcodec/utvideodec.c"
    ]
  },
  "patch_diff": {
    "libavcodec/utvideodec.c||libavcodec/utvideodec.c": [
      "File: libavcodec/utvideodec.c -> libavcodec/utvideodec.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "268:             send   = (height * (slice + 1) / c->slices) & cmask;",
      "269:             dest   = dst + sstart * stride;",
      "271:             for (p = dest; p < dst + send * stride; p += 8) {",
      "272:                 int bits = get_bits_le(&cbit, 3);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "271:             if (3 * ((dst + send * stride - dest + 7)/8) > get_bits_left(&cbit))",
      "272:                 return AVERROR_INVALIDDATA;",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "277:                     uint32_t sub = 0x80 >> (8 - (bits + 1)), add;",
      "278:                     int k;",
      "280:                     for (k = 0; k < 8; k++) {",
      "282:                         p[k] = get_bits_le(&pbit, bits + 1);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "283:                     if ((bits + 1) * 8 > get_bits_left(&pbit))",
      "284:                         return AVERROR_INVALIDDATA;",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "639:             for (j = 0; j < c->slices; j++) {",
      "640:                 c->packed_stream[i][j] = packed_stream;",
      "641:                 c->packed_stream_size[i][j] = bytestream2_get_le32(&pb);",
      "644:                     return AVERROR_INVALIDDATA;",
      "645:                 packed_stream += c->packed_stream_size[i][j];",
      "646:             }",
      "647:         }",
      "",
      "[Removed Lines]",
      "642:                 left -= c->packed_stream_size[i][j];",
      "643:                 if (left < 0)",
      "",
      "[Added Lines]",
      "648:                 if (c->packed_stream_size[i][j] > left)",
      "650:                 left -= c->packed_stream_size[i][j];",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "652:             for (j = 0; j < c->slices; j++) {",
      "653:                 c->control_stream[i][j] = control_stream;",
      "654:                 c->control_stream_size[i][j] = bytestream2_get_le32(&pb);",
      "657:                     return AVERROR_INVALIDDATA;",
      "658:                 control_stream += c->control_stream_size[i][j];",
      "659:             }",
      "660:         }",
      "",
      "[Removed Lines]",
      "655:                 left -= c->control_stream_size[i][j];",
      "656:                 if (left < 0)",
      "",
      "[Added Lines]",
      "661:                 if (c->control_stream_size[i][j] > left)",
      "663:                 left -= c->control_stream_size[i][j];",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "92b32664cdc064523c60ddba5ed139855e08470c",
      "candidate_info": {
        "commit_hash": "92b32664cdc064523c60ddba5ed139855e08470c",
        "repo": "FFmpeg/FFmpeg",
        "commit_url": "https://github.com/FFmpeg/FFmpeg/commit/92b32664cdc064523c60ddba5ed139855e08470c",
        "files": [
          "libavcodec/utvideo.h",
          "libavcodec/utvideodec.c",
          "libavformat/riff.c"
        ],
        "message": "avcodec/utvideodec: add support for UMH2, UMY2, UMH4, UMY4, UMRA, UMRG\n\nThese are new modes which are supposed to be more SIMD friendly.\n\nSigned-off-by: Paul B Mahol <onemda@gmail.com>",
        "before_after_code_files": [
          "libavcodec/utvideo.h||libavcodec/utvideo.h",
          "libavcodec/utvideodec.c||libavcodec/utvideodec.c",
          "libavformat/riff.c||libavformat/riff.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "libavcodec/utvideodec.c||libavcodec/utvideodec.c"
          ],
          "candidate": [
            "libavcodec/utvideodec.c||libavcodec/utvideodec.c"
          ]
        }
      },
      "candidate_diff": {
        "libavcodec/utvideo.h||libavcodec/utvideo.h": [
          "File: libavcodec/utvideo.h -> libavcodec/utvideo.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "72:     LLVidDSPContext llviddsp;",
          "73:     LLVidEncDSPContext llvidencdsp;",
          "76:     int      planes;",
          "77:     int      slices;",
          "78:     int      compression;",
          "79:     int      interlaced;",
          "80:     int      frame_pred;",
          "81:     int      pro;",
          "83:     ptrdiff_t slice_stride;",
          "84:     uint8_t *slice_bits, *slice_buffer[4];",
          "85:     int      slice_bits_size;",
          "86: } UtvideoContext;",
          "88: typedef struct HuffEntry {",
          "",
          "[Removed Lines]",
          "75:     uint32_t frame_info_size, flags, frame_info;",
          "",
          "[Added Lines]",
          "75:     uint32_t frame_info_size, flags, frame_info, offset;",
          "82:     int      pack;",
          "88:     const uint8_t *packed_stream[4][256];",
          "89:     size_t packed_stream_size[4][256];",
          "90:     const uint8_t *control_stream[4][256];",
          "91:     size_t control_stream_size[4][256];",
          "",
          "---------------"
        ],
        "libavcodec/utvideodec.c||libavcodec/utvideodec.c": [
          "File: libavcodec/utvideodec.c -> libavcodec/utvideodec.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "247:     int sstart, send;",
          "248:     VLC vlc;",
          "249:     GetBitContext gb;",
          "251:     const int cmask = compute_cmask(plane_no, c->interlaced, c->avctx->pix_fmt);",
          "253:     if (build_huff(src, &vlc, &fsym)) {",
          "254:         av_log(c->avctx, AV_LOG_ERROR, \"Cannot build Huffman codes\\n\");",
          "255:         return AVERROR_INVALIDDATA;",
          "",
          "[Removed Lines]",
          "250:     int prev, fsym;",
          "",
          "[Added Lines]",
          "250:     int ret, prev, fsym;",
          "253:     if (c->pack) {",
          "254:         send = 0;",
          "255:         for (slice = 0; slice < c->slices; slice++) {",
          "256:             GetBitContext cbit, pbit;",
          "257:             uint8_t *dest, *p;",
          "259:             ret = init_get_bits8(&cbit, c->control_stream[plane_no][slice], c->control_stream_size[plane_no][slice]);",
          "260:             if (ret < 0)",
          "261:                 return ret;",
          "263:             ret = init_get_bits8(&pbit, c->packed_stream[plane_no][slice], c->packed_stream_size[plane_no][slice]);",
          "264:             if (ret < 0)",
          "265:                 return ret;",
          "267:             sstart = send;",
          "268:             send   = (height * (slice + 1) / c->slices) & cmask;",
          "269:             dest   = dst + sstart * stride;",
          "271:             for (p = dest; p < dst + send * stride; p += 8) {",
          "272:                 int bits = get_bits_le(&cbit, 3);",
          "274:                 if (bits == 0) {",
          "276:                 } else {",
          "277:                     uint32_t sub = 0x80 >> (8 - (bits + 1)), add;",
          "278:                     int k;",
          "280:                     for (k = 0; k < 8; k++) {",
          "282:                         p[k] = get_bits_le(&pbit, bits + 1);",
          "283:                         add = (~p[k] & sub) << (8 - bits);",
          "284:                         p[k] -= sub;",
          "285:                         p[k] += add;",
          "286:                     }",
          "287:                 }",
          "288:             }",
          "289:         }",
          "291:         return 0;",
          "292:     }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "568:     bytestream2_init(&gb, buf, buf_size);",
          "570:         if (bytestream2_get_bytes_left(&gb) < c->frame_info_size) {",
          "571:             av_log(avctx, AV_LOG_ERROR, \"Not enough data for frame information\\n\");",
          "572:             return AVERROR_INVALIDDATA;",
          "",
          "[Removed Lines]",
          "569:     if (c->pro) {",
          "",
          "[Added Lines]",
          "611:     if (c->pack) {",
          "612:         const uint8_t *packed_stream;",
          "613:         const uint8_t *control_stream;",
          "614:         GetByteContext pb;",
          "615:         uint32_t nb_cbs;",
          "616:         int left;",
          "618:         c->frame_info = PRED_GRADIENT << 8;",
          "620:         if (bytestream2_get_byte(&gb) != 1)",
          "621:             return AVERROR_INVALIDDATA;",
          "622:         bytestream2_skip(&gb, 3);",
          "623:         c->offset = bytestream2_get_le32(&gb);",
          "625:         if (buf_size <= c->offset + 8LL)",
          "626:             return AVERROR_INVALIDDATA;",
          "628:         bytestream2_init(&pb, buf + 8 + c->offset, buf_size - 8 - c->offset);",
          "630:         nb_cbs = bytestream2_get_le32(&pb);",
          "631:         if (nb_cbs > c->offset)",
          "632:             return AVERROR_INVALIDDATA;",
          "634:         packed_stream = buf + 8;",
          "635:         control_stream = packed_stream + (c->offset - nb_cbs);",
          "636:         left = control_stream - packed_stream;",
          "638:         for (i = 0; i < c->planes; i++) {",
          "639:             for (j = 0; j < c->slices; j++) {",
          "640:                 c->packed_stream[i][j] = packed_stream;",
          "641:                 c->packed_stream_size[i][j] = bytestream2_get_le32(&pb);",
          "642:                 left -= c->packed_stream_size[i][j];",
          "643:                 if (left < 0)",
          "644:                     return AVERROR_INVALIDDATA;",
          "645:                 packed_stream += c->packed_stream_size[i][j];",
          "646:             }",
          "647:         }",
          "649:         left = buf + buf_size - control_stream;",
          "651:         for (i = 0; i < c->planes; i++) {",
          "652:             for (j = 0; j < c->slices; j++) {",
          "653:                 c->control_stream[i][j] = control_stream;",
          "654:                 c->control_stream_size[i][j] = bytestream2_get_le32(&pb);",
          "655:                 left -= c->control_stream_size[i][j];",
          "656:                 if (left < 0)",
          "657:                     return AVERROR_INVALIDDATA;",
          "658:                 control_stream += c->control_stream_size[i][j];",
          "659:             }",
          "660:         }",
          "661:     } else if (c->pro) {",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "636:     max_slice_size += 4*avctx->width;",
          "644:     }",
          "646:     switch (c->avctx->pix_fmt) {",
          "",
          "[Removed Lines]",
          "638:     av_fast_malloc(&c->slice_bits, &c->slice_bits_size,",
          "639:                    max_slice_size + AV_INPUT_BUFFER_PADDING_SIZE);",
          "641:     if (!c->slice_bits) {",
          "642:         av_log(avctx, AV_LOG_ERROR, \"Cannot allocate temporary buffer\\n\");",
          "643:         return AVERROR(ENOMEM);",
          "",
          "[Added Lines]",
          "730:     if (!c->pack) {",
          "731:         av_fast_malloc(&c->slice_bits, &c->slice_bits_size,",
          "732:                        max_slice_size + AV_INPUT_BUFFER_PADDING_SIZE);",
          "734:         if (!c->slice_bits) {",
          "735:             av_log(avctx, AV_LOG_ERROR, \"Cannot allocate temporary buffer\\n\");",
          "736:             return AVERROR(ENOMEM);",
          "737:         }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "819:     ff_bswapdsp_init(&c->bdsp);",
          "820:     ff_llviddsp_init(&c->llviddsp);",
          "853:     c->slice_bits_size = 0;",
          "855:     switch (avctx->codec_tag) {",
          "",
          "[Removed Lines]",
          "822:     if (avctx->extradata_size >= 16) {",
          "823:         av_log(avctx, AV_LOG_DEBUG, \"Encoder version %d.%d.%d.%d\\n\",",
          "824:                avctx->extradata[3], avctx->extradata[2],",
          "825:                avctx->extradata[1], avctx->extradata[0]);",
          "826:         av_log(avctx, AV_LOG_DEBUG, \"Original format %\"PRIX32\"\\n\",",
          "827:                AV_RB32(avctx->extradata + 4));",
          "828:         c->frame_info_size = AV_RL32(avctx->extradata + 8);",
          "829:         c->flags           = AV_RL32(avctx->extradata + 12);",
          "831:         if (c->frame_info_size != 4)",
          "832:             avpriv_request_sample(avctx, \"Frame info not 4 bytes\");",
          "833:         av_log(avctx, AV_LOG_DEBUG, \"Encoding parameters %08\"PRIX32\"\\n\", c->flags);",
          "834:         c->slices      = (c->flags >> 24) + 1;",
          "835:         c->compression = c->flags & 1;",
          "836:         c->interlaced  = c->flags & 0x800;",
          "837:     } else if (avctx->extradata_size == 8) {",
          "838:         av_log(avctx, AV_LOG_DEBUG, \"Encoder version %d.%d.%d.%d\\n\",",
          "839:                avctx->extradata[3], avctx->extradata[2],",
          "840:                avctx->extradata[1], avctx->extradata[0]);",
          "841:         av_log(avctx, AV_LOG_DEBUG, \"Original format %\"PRIX32\"\\n\",",
          "842:                AV_RB32(avctx->extradata + 4));",
          "843:         c->interlaced  = 0;",
          "844:         c->pro         = 1;",
          "845:         c->frame_info_size = 4;",
          "846:     } else {",
          "847:         av_log(avctx, AV_LOG_ERROR,",
          "848:                \"Insufficient extradata size %d, should be at least 16\\n\",",
          "849:                avctx->extradata_size);",
          "850:         return AVERROR_INVALIDDATA;",
          "851:     }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "903:         avctx->pix_fmt = AV_PIX_FMT_YUV444P;",
          "904:         avctx->colorspace = AVCOL_SPC_BT709;",
          "905:         break;",
          "906:     default:",
          "907:         av_log(avctx, AV_LOG_ERROR, \"Unknown Ut Video FOURCC provided (%08X)\\n\",",
          "908:                avctx->codec_tag);",
          "909:         return AVERROR_INVALIDDATA;",
          "910:     }",
          "912:     return 0;",
          "913: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "969:     case MKTAG('U', 'M', 'Y', '2'):",
          "970:         c->planes      = 3;",
          "971:         c->pack        = 1;",
          "972:         avctx->pix_fmt = AV_PIX_FMT_YUV422P;",
          "973:         avctx->colorspace = AVCOL_SPC_BT470BG;",
          "974:         break;",
          "975:     case MKTAG('U', 'M', 'H', '2'):",
          "976:         c->planes      = 3;",
          "977:         c->pack        = 1;",
          "978:         avctx->pix_fmt = AV_PIX_FMT_YUV422P;",
          "979:         avctx->colorspace = AVCOL_SPC_BT709;",
          "980:         break;",
          "981:     case MKTAG('U', 'M', 'Y', '4'):",
          "982:         c->planes      = 3;",
          "983:         c->pack        = 1;",
          "984:         avctx->pix_fmt = AV_PIX_FMT_YUV444P;",
          "985:         avctx->colorspace = AVCOL_SPC_BT470BG;",
          "986:         break;",
          "987:     case MKTAG('U', 'M', 'H', '4'):",
          "988:         c->planes      = 3;",
          "989:         c->pack        = 1;",
          "990:         avctx->pix_fmt = AV_PIX_FMT_YUV444P;",
          "991:         avctx->colorspace = AVCOL_SPC_BT709;",
          "992:         break;",
          "993:     case MKTAG('U', 'M', 'R', 'G'):",
          "994:         c->planes      = 3;",
          "995:         c->pack        = 1;",
          "996:         avctx->pix_fmt = AV_PIX_FMT_GBRP;",
          "997:         break;",
          "998:     case MKTAG('U', 'M', 'R', 'A'):",
          "999:         c->planes      = 4;",
          "1000:         c->pack        = 1;",
          "1001:         avctx->pix_fmt = AV_PIX_FMT_GBRAP;",
          "1002:         break;",
          "1009:     if (c->pack && avctx->extradata_size >= 16) {",
          "1010:         av_log(avctx, AV_LOG_DEBUG, \"Encoder version %d.%d.%d.%d\\n\",",
          "1011:                avctx->extradata[3], avctx->extradata[2],",
          "1012:                avctx->extradata[1], avctx->extradata[0]);",
          "1013:         av_log(avctx, AV_LOG_DEBUG, \"Original format %\"PRIX32\"\\n\",",
          "1014:                AV_RB32(avctx->extradata + 4));",
          "1015:         c->compression = avctx->extradata[8];",
          "1016:         if (c->compression != 2)",
          "1017:             avpriv_request_sample(avctx, \"Unknown compression type\");",
          "1018:         c->slices      = avctx->extradata[9] + 1;",
          "1019:     } else if (avctx->extradata_size >= 16) {",
          "1020:         av_log(avctx, AV_LOG_DEBUG, \"Encoder version %d.%d.%d.%d\\n\",",
          "1021:                avctx->extradata[3], avctx->extradata[2],",
          "1022:                avctx->extradata[1], avctx->extradata[0]);",
          "1023:         av_log(avctx, AV_LOG_DEBUG, \"Original format %\"PRIX32\"\\n\",",
          "1024:                AV_RB32(avctx->extradata + 4));",
          "1025:         c->frame_info_size = AV_RL32(avctx->extradata + 8);",
          "1026:         c->flags           = AV_RL32(avctx->extradata + 12);",
          "1028:         if (c->frame_info_size != 4)",
          "1029:             avpriv_request_sample(avctx, \"Frame info not 4 bytes\");",
          "1030:         av_log(avctx, AV_LOG_DEBUG, \"Encoding parameters %08\"PRIX32\"\\n\", c->flags);",
          "1031:         c->slices      = (c->flags >> 24) + 1;",
          "1032:         c->compression = c->flags & 1;",
          "1033:         c->interlaced  = c->flags & 0x800;",
          "1034:     } else if (avctx->extradata_size == 8) {",
          "1035:         av_log(avctx, AV_LOG_DEBUG, \"Encoder version %d.%d.%d.%d\\n\",",
          "1036:                avctx->extradata[3], avctx->extradata[2],",
          "1037:                avctx->extradata[1], avctx->extradata[0]);",
          "1038:         av_log(avctx, AV_LOG_DEBUG, \"Original format %\"PRIX32\"\\n\",",
          "1039:                AV_RB32(avctx->extradata + 4));",
          "1040:         c->interlaced  = 0;",
          "1041:         c->pro         = 1;",
          "1042:         c->frame_info_size = 4;",
          "1043:     } else {",
          "1044:         av_log(avctx, AV_LOG_ERROR,",
          "1045:                \"Insufficient extradata size %d, should be at least 16\\n\",",
          "1046:                avctx->extradata_size);",
          "1047:         return AVERROR_INVALIDDATA;",
          "1048:     }",
          "",
          "---------------"
        ],
        "libavformat/riff.c||libavformat/riff.c": [
          "File: libavformat/riff.c -> libavformat/riff.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "404:     { AV_CODEC_ID_UTVIDEO,      MKTAG('U', 'Q', 'Y', '2') },",
          "405:     { AV_CODEC_ID_UTVIDEO,      MKTAG('U', 'Q', 'R', 'A') },",
          "406:     { AV_CODEC_ID_UTVIDEO,      MKTAG('U', 'Q', 'R', 'G') },",
          "407:     { AV_CODEC_ID_VBLE,         MKTAG('V', 'B', 'L', 'E') },",
          "408:     { AV_CODEC_ID_ESCAPE130,    MKTAG('E', '1', '3', '0') },",
          "409:     { AV_CODEC_ID_DXTORY,       MKTAG('x', 't', 'o', 'r') },",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "407:     { AV_CODEC_ID_UTVIDEO,      MKTAG('U', 'M', 'Y', '2') },",
          "408:     { AV_CODEC_ID_UTVIDEO,      MKTAG('U', 'M', 'H', '2') },",
          "409:     { AV_CODEC_ID_UTVIDEO,      MKTAG('U', 'M', 'Y', '4') },",
          "410:     { AV_CODEC_ID_UTVIDEO,      MKTAG('U', 'M', 'H', '4') },",
          "411:     { AV_CODEC_ID_UTVIDEO,      MKTAG('U', 'M', 'R', 'A') },",
          "412:     { AV_CODEC_ID_UTVIDEO,      MKTAG('U', 'M', 'R', 'G') },",
          "",
          "---------------"
        ]
      }
    }
  ]
}
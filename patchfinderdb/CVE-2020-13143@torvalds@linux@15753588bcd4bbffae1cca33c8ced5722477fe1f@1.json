{
  "cve_id": "CVE-2020-13143",
  "cve_desc": "gadget_dev_desc_UDC_store in drivers/usb/gadget/configfs.c in the Linux kernel 3.16 through 5.6.13 relies on kstrdup without considering the possibility of an internal '\\0' value, which allows attackers to trigger an out-of-bounds read, aka CID-15753588bcd4.",
  "repo": "torvalds/linux",
  "patch_hash": "15753588bcd4bbffae1cca33c8ced5722477fe1f",
  "patch_info": {
    "commit_hash": "15753588bcd4bbffae1cca33c8ced5722477fe1f",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/15753588bcd4bbffae1cca33c8ced5722477fe1f",
    "files": [
      "drivers/usb/gadget/configfs.c"
    ],
    "message": "USB: gadget: fix illegal array access in binding with UDC\n\nFuzzUSB (a variant of syzkaller) found an illegal array access\nusing an incorrect index while binding a gadget with UDC.\n\nReference: https://www.spinics.net/lists/linux-usb/msg194331.html\n\nThis bug occurs when a size variable used for a buffer\nis misused to access its strcpy-ed buffer.\nGiven a buffer along with its size variable (taken from user input),\nfrom which, a new buffer is created using kstrdup().\nDue to the original buffer containing 0 value in the middle,\nthe size of the kstrdup-ed buffer becomes smaller than that of the original.\nSo accessing the kstrdup-ed buffer with the same size variable\ntriggers memory access violation.\n\nThe fix makes sure no zero value in the buffer,\nby comparing the strlen() of the orignal buffer with the size variable,\nso that the access to the kstrdup-ed buffer is safe.\n\nBUG: KASAN: slab-out-of-bounds in gadget_dev_desc_UDC_store+0x1ba/0x200\ndrivers/usb/gadget/configfs.c:266\nRead of size 1 at addr ffff88806a55dd7e by task syz-executor.0/17208\n\nCPU: 2 PID: 17208 Comm: syz-executor.0 Not tainted 5.6.8 #1\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS Bochs 01/01/2011\nCall Trace:\n __dump_stack lib/dump_stack.c:77 [inline]\n dump_stack+0xce/0x128 lib/dump_stack.c:118\n print_address_description.constprop.4+0x21/0x3c0 mm/kasan/report.c:374\n __kasan_report+0x131/0x1b0 mm/kasan/report.c:506\n kasan_report+0x12/0x20 mm/kasan/common.c:641\n __asan_report_load1_noabort+0x14/0x20 mm/kasan/generic_report.c:132\n gadget_dev_desc_UDC_store+0x1ba/0x200 drivers/usb/gadget/configfs.c:266\n flush_write_buffer fs/configfs/file.c:251 [inline]\n configfs_write_file+0x2f1/0x4c0 fs/configfs/file.c:283\n __vfs_write+0x85/0x110 fs/read_write.c:494\n vfs_write+0x1cd/0x510 fs/read_write.c:558\n ksys_write+0x18a/0x220 fs/read_write.c:611\n __do_sys_write fs/read_write.c:623 [inline]\n __se_sys_write fs/read_write.c:620 [inline]\n __x64_sys_write+0x73/0xb0 fs/read_write.c:620\n do_syscall_64+0x9e/0x510 arch/x86/entry/common.c:294\n entry_SYSCALL_64_after_hwframe+0x49/0xbe\n\nSigned-off-by: Kyungtae Kim <kt0755@gmail.com>\nReported-and-tested-by: Kyungtae Kim <kt0755@gmail.com>\nCc: Felipe Balbi <balbi@kernel.org>\nCc: stable <stable@vger.kernel.org>\nLink: https://lore.kernel.org/r/20200510054326.GA19198@pizza01\nSigned-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>",
    "before_after_code_files": [
      "drivers/usb/gadget/configfs.c||drivers/usb/gadget/configfs.c"
    ]
  },
  "patch_diff": {
    "drivers/usb/gadget/configfs.c||drivers/usb/gadget/configfs.c": [
      "File: drivers/usb/gadget/configfs.c -> drivers/usb/gadget/configfs.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "260:  char *name;",
      "261:  int ret;",
      "263:  name = kstrdup(page, GFP_KERNEL);",
      "264:  if (!name)",
      "265:   return -ENOMEM;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "263:  if (strlen(page) < len)",
      "264:   return -EOVERFLOW;",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "220995622da5317714b5fe659165735f7b44b87e",
      "candidate_info": {
        "commit_hash": "220995622da5317714b5fe659165735f7b44b87e",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/220995622da5317714b5fe659165735f7b44b87e",
        "files": [
          "drivers/tty/serial/kgdboc.c",
          "include/linux/kgdb.h",
          "kernel/debug/debug_core.c"
        ],
        "message": "kgdboc: Add kgdboc_earlycon to support early kgdb using boot consoles\n\nWe want to enable kgdb to debug the early parts of the kernel.\nUnfortunately kgdb normally is a client of the tty API in the kernel\nand serial drivers don't register to the tty layer until fairly late\nin the boot process.\n\nSerial drivers do, however, commonly register a boot console.  Let's\nenable the kgdboc driver to work with boot consoles to provide early\ndebugging.\n\nThis change co-opts the existing read() function pointer that's part\nof \"struct console\".  It's assumed that if a boot console (with the\nflag CON_BOOT) has implemented read() that both the read() and write()\nfunction are polling functions.  That means they work without\ninterrupts and read() will return immediately (with 0 bytes read) if\nthere's nothing to read.  This should be a safe assumption since it\nappears that no current boot consoles implement read() right now and\nthere seems no reason to do so unless they wanted to support\n\"kgdboc_earlycon\".\n\nThe normal/expected way to make all this work is to use\n\"kgdboc_earlycon\" and \"kgdboc\" together.  You should point them both\nto the same physical serial connection.  At boot time, as the system\ntransitions from the boot console to the normal console (and registers\na tty), kgdb will switch over.\n\nOne awkward part of all this, though, is that there can be a window\nwhere the boot console goes away and we can't quite transtion over to\nthe main kgdboc that uses the tty layer.  There are two main problems:\n\n1. The act of registering the tty doesn't cause any call into kgdboc\n   so there is a window of time when the tty is there but kgdboc's\n   init code hasn't been called so we can't transition to it.\n\n2. On some serial drivers the normal console inits (and replaces the\n   boot console) quite early in the system.  Presumably these drivers\n   were coded up before earlycon worked as well as it does today and\n   probably they don't need to do this anymore, but it causes us\n   problems nontheless.\n\nProblem #1 is not too big of a deal somewhat due to the luck of probe\nordering.  kgdboc is last in the tty/serial/Makefile so its probe gets\nright after all other tty devices.  It's not fun to rely on this, but\nit does work for the most part.\n\nProblem #2 is a big deal, but only for some serial drivers.  Other\nserial drivers end up registering the console (which gets rid of the\nboot console) and tty at nearly the same time.\n\nThe way we'll deal with the window when the system has stopped using\nthe boot console and the time when we're setup using the tty is to\nkeep using the boot console.  This may sound surprising, but it has\nbeen found to work well in practice.  If it doesn't work, it shouldn't\nbe too hard for a given serial driver to make it keep working.\nSpecifically, it's expected that the read()/write() function provided\nin the boot console should be the same (or nearly the same) as the\nnormal kgdb polling functions.  That means continuing to use them\nshould work just fine.  To make things even more likely to work work\nwe'll also trap the recently added exit() function in the boot console\nwe're using and delay any calls to it until we're all done with the\nboot console.\n\nNOTE: there could be ways to use all this in weird / unexpected ways.\nIf you do something like this, it's a bit of a buyer beware situation.\nSpecifically:\n- If you specify only \"kgdboc_earlycon\" but not \"kgdboc\" then\n  (depending on your serial driver) things will probably work OK, but\n  you'll get a warning printed the first time you use kgdb after the\n  boot console is gone.  You'd only be able to do this, of course, if\n  the serial driver you're running atop provided an early boot console.\n- If your \"kgdboc_earlycon\" and \"kgdboc\" devices are not the same\n  device things should work OK, but it'll be your job to switch over\n  which device you're monitoring (including figuring out how to switch\n  over gdb in-flight if you're using it).\n\nWhen trying to enable \"kgdboc_earlycon\" it should be noted that the\nnames that are registered through the boot console layer and the tty\nlayer are not the same for the same port.  For example when debugging\non one board I'd need to pass \"kgdboc_earlycon=qcom_geni\nkgdboc=ttyMSM0\" to enable things properly.  Since digging up the boot\nconsole name is a pain and there will rarely be more than one boot\nconsole enabled, you can provide the \"kgdboc_earlycon\" parameter\nwithout specifying the name of the boot console.  In this case we'll\njust pick the first boot that implements read() that we find.\n\nThis new \"kgdboc_earlycon\" parameter should be contrasted to the\nexisting \"ekgdboc\" parameter.  While both provide a way to debug very\nearly, the usage and mechanisms are quite different.  Specifically\n\"kgdboc_earlycon\" is meant to be used in tandem with \"kgdboc\" and\nthere is a transition from one to the other.  The \"ekgdboc\" parameter,\non the other hand, replaces the \"kgdboc\" parameter.  It runs the same\nlogic as the \"kgdboc\" parameter but just relies on your TTY driver\nbeing present super early.  The only known usage of the old \"ekgdboc\"\nparameter is documented as \"ekgdboc=kbd earlyprintk=vga\".  It should\nbe noted that \"kbd\" has special treatment allowing it to init early as\na tty device.\n\nSigned-off-by: Douglas Anderson <dianders@chromium.org>\nReviewed-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>\nTested-by: Sumit Garg <sumit.garg@linaro.org>\nLink: https://lore.kernel.org/r/20200507130644.v4.8.I8fba5961bf452ab92350654aa61957f23ecf0100@changeid\nSigned-off-by: Daniel Thompson <daniel.thompson@linaro.org>",
        "before_after_code_files": [
          "drivers/tty/serial/kgdboc.c||drivers/tty/serial/kgdboc.c",
          "include/linux/kgdb.h||include/linux/kgdb.h",
          "kernel/debug/debug_core.c||kernel/debug/debug_core.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "drivers/tty/serial/kgdboc.c||drivers/tty/serial/kgdboc.c": [
          "File: drivers/tty/serial/kgdboc.c -> drivers/tty/serial/kgdboc.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "21: #include <linux/input.h>",
          "22: #include <linux/module.h>",
          "23: #include <linux/platform_device.h>",
          "25: #define MAX_CONFIG_LEN  40",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "24: #include <linux/serial_core.h>",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "43: static struct platform_device *kgdboc_pdev;",
          "45: #ifdef CONFIG_KDB_KEYBOARD",
          "46: static int kgdboc_reset_connect(struct input_handler *handler,",
          "47:     struct input_dev *dev,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "46: static struct kgdb_io  kgdboc_earlycon_io_ops;",
          "47: static struct console  *earlycon;",
          "48: static int                      (*earlycon_orig_exit)(struct console *con);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "138: static void cleanup_kgdboc(void)",
          "139: {",
          "140:  if (configured != 1)",
          "141:   return;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "145:  if (earlycon)",
          "146:   kgdb_unregister_io_module(&kgdboc_earlycon_io_ops);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "410: early_param(\"ekgdboc\", kgdboc_early_init);",
          "412: module_init(init_kgdboc);",
          "413: module_exit(exit_kgdboc);",
          "414: module_param_call(kgdboc, param_set_kgdboc_var, param_get_string, &kps, 0644);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "420: static int kgdboc_earlycon_get_char(void)",
          "421: {",
          "422:  char c;",
          "424:  if (!earlycon->read(earlycon, &c, 1))",
          "425:   return NO_POLL_CHAR;",
          "427:  return c;",
          "428: }",
          "430: static void kgdboc_earlycon_put_char(u8 chr)",
          "431: {",
          "432:  earlycon->write(earlycon, &chr, 1);",
          "433: }",
          "435: static void kgdboc_earlycon_pre_exp_handler(void)",
          "436: {",
          "437:  struct console *con;",
          "438:  static bool already_warned;",
          "440:  if (already_warned)",
          "441:   return;",
          "451:  for_each_console(con)",
          "452:   if (con == earlycon)",
          "453:    return;",
          "455:  already_warned = true;",
          "456:  pr_warn(\"kgdboc_earlycon is still using bootconsole\\n\");",
          "457: }",
          "459: static int kgdboc_earlycon_deferred_exit(struct console *con)",
          "460: {",
          "468:  con->exit = earlycon_orig_exit;",
          "470:  return 0;",
          "471: }",
          "473: static void kgdboc_earlycon_deinit(void)",
          "474: {",
          "475:  if (!earlycon)",
          "476:   return;",
          "478:  if (earlycon->exit == kgdboc_earlycon_deferred_exit)",
          "484:   earlycon->exit = earlycon_orig_exit;",
          "485:  else if (earlycon->exit)",
          "491:   earlycon->exit(earlycon);",
          "493:  earlycon = NULL;",
          "494: }",
          "496: static struct kgdb_io kgdboc_earlycon_io_ops = {",
          "497:  .name   = \"kgdboc_earlycon\",",
          "498:  .read_char  = kgdboc_earlycon_get_char,",
          "499:  .write_char  = kgdboc_earlycon_put_char,",
          "500:  .pre_exception  = kgdboc_earlycon_pre_exp_handler,",
          "501:  .deinit   = kgdboc_earlycon_deinit,",
          "502:  .is_console  = true,",
          "503: };",
          "505: static int __init kgdboc_earlycon_init(char *opt)",
          "506: {",
          "507:  struct console *con;",
          "509:  kdb_init(KDB_INIT_EARLY);",
          "515:  console_lock();",
          "516:  for_each_console(con) {",
          "517:   if (con->write && con->read &&",
          "518:       (con->flags & (CON_BOOT | CON_ENABLED)) &&",
          "519:       (!opt || !opt[0] || strcmp(con->name, opt) == 0))",
          "520:    break;",
          "521:  }",
          "523:  if (!con) {",
          "524:   pr_info(\"Couldn't find kgdb earlycon\\n\");",
          "525:   goto unlock;",
          "526:  }",
          "528:  earlycon = con;",
          "529:  pr_info(\"Going to register kgdb with earlycon '%s'\\n\", con->name);",
          "530:  if (kgdb_register_io_module(&kgdboc_earlycon_io_ops) != 0) {",
          "531:   earlycon = NULL;",
          "532:   pr_info(\"Failed to register kgdb with earlycon\\n\");",
          "533:  } else {",
          "535:   earlycon_orig_exit = con->exit;",
          "536:   con->exit = kgdboc_earlycon_deferred_exit;",
          "537:  }",
          "539: unlock:",
          "540:  console_unlock();",
          "543:  return 0;",
          "544: }",
          "546: early_param(\"kgdboc_earlycon\", kgdboc_earlycon_init);",
          "",
          "---------------"
        ],
        "include/linux/kgdb.h||include/linux/kgdb.h": [
          "File: include/linux/kgdb.h -> include/linux/kgdb.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "282:  void   (*write_char) (u8);",
          "283:  void   (*flush) (void);",
          "284:  int   (*init) (void);",
          "285:  void   (*pre_exception) (void);",
          "286:  void   (*post_exception) (void);",
          "287:  int   is_console;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "288:  void   (*deinit) (void);",
          "",
          "---------------"
        ],
        "kernel/debug/debug_core.c||kernel/debug/debug_core.c": [
          "File: kernel/debug/debug_core.c -> kernel/debug/debug_core.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1074: int kgdb_register_io_module(struct kgdb_io *new_dbg_io_ops)",
          "1075: {",
          "1076:  int err;",
          "1078:  spin_lock(&kgdb_registration_lock);",
          "1085:  }",
          "1087:  if (new_dbg_io_ops->init) {",
          "",
          "[Removed Lines]",
          "1080:  if (dbg_io_ops) {",
          "1081:   spin_unlock(&kgdb_registration_lock);",
          "1083:   pr_err(\"Another I/O driver is already registered with KGDB\\n\");",
          "1084:   return -EBUSY;",
          "",
          "[Added Lines]",
          "1076:  struct kgdb_io *old_dbg_io_ops;",
          "1081:  old_dbg_io_ops = dbg_io_ops;",
          "1082:  if (old_dbg_io_ops) {",
          "1083:   if (!old_dbg_io_ops->deinit) {",
          "1084:    spin_unlock(&kgdb_registration_lock);",
          "1086:    pr_err(\"KGDB I/O driver %s can't replace %s.\\n\",",
          "1087:     new_dbg_io_ops->name, old_dbg_io_ops->name);",
          "1088:    return -EBUSY;",
          "1089:   }",
          "1090:   pr_info(\"Replacing I/O driver %s with %s\\n\",",
          "1091:    old_dbg_io_ops->name, new_dbg_io_ops->name);",
          "1092:   old_dbg_io_ops->deinit();",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1097:  spin_unlock(&kgdb_registration_lock);",
          "1099:  pr_info(\"Registered I/O driver %s\\n\", new_dbg_io_ops->name);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1107:  if (old_dbg_io_ops)",
          "1108:   return 0;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1133:  spin_unlock(&kgdb_registration_lock);",
          "1135:  pr_info(\"Unregistered I/O driver %s, debugger disabled\\n\",",
          "1136:   old_dbg_io_ops->name);",
          "1137: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1146:  if (old_dbg_io_ops->deinit)",
          "1147:   old_dbg_io_ops->deinit();",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "720bc316690bd27dea9d71510b50f0cd698ffc32",
      "candidate_info": {
        "commit_hash": "720bc316690bd27dea9d71510b50f0cd698ffc32",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/720bc316690bd27dea9d71510b50f0cd698ffc32",
        "files": [
          "drivers/block/ps3disk.c"
        ],
        "message": "ps3disk: use the default segment boundary\n\nSince commit dcebd755926b (\"block: use bio_for_each_bvec() to compute\nmulti-page bvec count\"), the kernel will bug_on on the PS3 because\nbio_split() is called with sectors == 0:\n\n  kernel BUG at block/bio.c:1853!\n  Oops: Exception in kernel mode, sig: 5 [#1]\n  BE PAGE_SIZE=4K MMU=Hash PREEMPT SMP NR_CPUS=8 NUMA PS3\n  Modules linked in: firewire_sbp2 rtc_ps3(+) soundcore ps3_gelic(+) \\\n  ps3rom(+) firewire_core ps3vram(+) usb_common crc_itu_t\n  CPU: 0 PID: 97 Comm: blkid Not tainted 5.3.0-rc4 #1\n  NIP:  c00000000027d0d0 LR: c00000000027d0b0 CTR: 0000000000000000\n  REGS: c00000000135ae90 TRAP: 0700   Not tainted  (5.3.0-rc4)\n  MSR:  8000000000028032 <SF,EE,IR,DR,RI>  CR: 44008240  XER: 20000000\n  IRQMASK: 0\n  GPR00: c000000000289368 c00000000135b120 c00000000084a500 c000000004ff8300\n  GPR04: 0000000000000c00 c000000004c905e0 c000000004c905e0 000000000000ffff\n  GPR08: 0000000000000000 0000000000000001 0000000000000000 000000000000ffff\n  GPR12: 0000000000000000 c0000000008ef000 000000000000003e 0000000000080001\n  GPR16: 0000000000000100 000000000000ffff 0000000000000000 0000000000000004\n  GPR20: c00000000062fd7e 0000000000000001 000000000000ffff 0000000000000080\n  GPR24: c000000000781788 c00000000135b350 0000000000000080 c000000004c905e0\n  GPR28: c00000000135b348 c000000004ff8300 0000000000000000 c000000004c90000\n  NIP [c00000000027d0d0] .bio_split+0x28/0xac\n  LR [c00000000027d0b0] .bio_split+0x8/0xac\n  Call Trace:\n  [c00000000135b120] [c00000000027d130] .bio_split+0x88/0xac (unreliable)\n  [c00000000135b1b0] [c000000000289368] .__blk_queue_split+0x11c/0x53c\n  [c00000000135b2d0] [c00000000028f614] .blk_mq_make_request+0x80/0x7d4\n  [c00000000135b3d0] [c000000000283a8c] .generic_make_request+0x118/0x294\n  [c00000000135b4b0] [c000000000283d34] .submit_bio+0x12c/0x174\n  [c00000000135b580] [c000000000205a44] .mpage_bio_submit+0x3c/0x4c\n  [c00000000135b600] [c000000000206184] .mpage_readpages+0xa4/0x184\n  [c00000000135b750] [c0000000001ff8fc] .blkdev_readpages+0x24/0x38\n  [c00000000135b7c0] [c0000000001589f0] .read_pages+0x6c/0x1a8\n  [c00000000135b8b0] [c000000000158c74] .__do_page_cache_readahead+0x118/0x184\n  [c00000000135b9b0] [c0000000001591a8] .force_page_cache_readahead+0xe4/0xe8\n  [c00000000135ba50] [c00000000014fc24] .generic_file_read_iter+0x1d8/0x830\n  [c00000000135bb50] [c0000000001ffadc] .blkdev_read_iter+0x40/0x5c\n  [c00000000135bbc0] [c0000000001b9e00] .new_sync_read+0x144/0x1a0\n  [c00000000135bcd0] [c0000000001bc454] .vfs_read+0xa0/0x124\n  [c00000000135bd70] [c0000000001bc7a4] .ksys_read+0x70/0xd8\n  [c00000000135be20] [c00000000000a524] system_call+0x5c/0x70\n  Instruction dump:\n  7fe3fb78 482e30dc 7c0802a6 482e3085 7c9e2378 f821ff71 7ca42b78 7d3e00d0\n  7c7d1b78 79290fe0 7cc53378 69290001 <0b090000> 81230028 7bca0020 7929ba62\n  [ end trace 313fec760f30aa1f ]---\n\nThe problem originates from setting the segment boundary of the\nrequest queue to -1UL. This makes get_max_segment_size() return zero\nwhen offset is zero, whatever the max segment size. The test with\nBLK_SEG_BOUNDARY_MASK fails and 'mask - (mask & offset) + 1' overflows\nto zero in the return statement.\n\nNot setting the segment boundary and using the default\nvalue (BLK_SEG_BOUNDARY_MASK) fixes the problem.\n\nSigned-off-by: Emmanuel Nicolet <emmanuel.nicolet@gmail.com>\nSigned-off-by: Geoff Levand <geoff@infradead.org>\nSigned-off-by: Michael Ellerman <mpe@ellerman.id.au>\nLink: https://lore.kernel.org/r/060a416c43138f45105c0540eff1a45539f7e2fc.1589049250.git.geoff@infradead.org",
        "before_after_code_files": [
          "drivers/block/ps3disk.c||drivers/block/ps3disk.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "drivers/block/ps3disk.c||drivers/block/ps3disk.c": [
          "File: drivers/block/ps3disk.c -> drivers/block/ps3disk.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "454:  queue->queuedata = dev;",
          "456:  blk_queue_max_hw_sectors(queue, dev->bounce_size >> 9);",
          "458:  blk_queue_dma_alignment(queue, dev->blk_size-1);",
          "459:  blk_queue_logical_block_size(queue, dev->blk_size);",
          "",
          "[Removed Lines]",
          "457:  blk_queue_segment_boundary(queue, -1UL);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "58c1721787be8a6ff28b4e5b6ce395915476871e",
      "candidate_info": {
        "commit_hash": "58c1721787be8a6ff28b4e5b6ce395915476871e",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/58c1721787be8a6ff28b4e5b6ce395915476871e",
        "files": [
          "drivers/gpu/drm/drm_dp_mst_topology.c"
        ],
        "message": "drm/dp_mst: Fix timeout handling of MST down messages\n\nThis fixes the following use-after-free problem in case an MST down\nmessage times out, while waiting for the response for it:\n\n[  449.022841] [drm:drm_dp_mst_wait_tx_reply.isra.26] timedout msg send 0000000080ba7fa2 2 0\n[  449.022898] ------------[ cut here ]------------\n[  449.022903] list_add corruption. prev->next should be next (ffff88847dae32c0), but was 6b6b6b6b6b6b6b6b. (prev=ffff88847db1c140).\n[  449.022931] WARNING: CPU: 2 PID: 22 at lib/list_debug.c:28 __list_add_valid+0x4d/0x70\n[  449.022935] Modules linked in: asix usbnet mii snd_hda_codec_hdmi mei_hdcp i915 x86_pkg_temp_thermal coretemp crct10dif_pclmul crc32_pclmul ghash_clmulni_intel snd_hda_intel snd_intel_dspcfg snd_hda_codec snd_hwdep e1000e snd_hda_core ptp snd_pcm pps_core mei_me mei intel_lpss_pci prime_numbers\n[  449.022966] CPU: 2 PID: 22 Comm: kworker/2:0 Not tainted 5.7.0-rc3-CI-Patchwork_17536+ #1\n[  449.022970] Hardware name: Intel Corporation Tiger Lake Client Platform/TigerLake U DDR4 SODIMM RVP, BIOS TGLSFWI1.R00.2457.A16.1912270059 12/27/2019\n[  449.022976] Workqueue: events_long drm_dp_mst_link_probe_work\n[  449.022982] RIP: 0010:__list_add_valid+0x4d/0x70\n[  449.022987] Code: c3 48 89 d1 48 c7 c7 f0 e7 32 82 48 89 c2 e8 3a 49 b7 ff 0f 0b 31 c0 c3 48 89 c1 4c 89 c6 48 c7 c7 40 e8 32 82 e8 23 49 b7 ff <0f> 0b 31 c0 c3 48 89 f2 4c 89 c1 48 89 fe 48 c7 c7 90 e8 32 82 e8\n[  449.022991] RSP: 0018:ffffc900001abcb0 EFLAGS: 00010286\n[  449.022995] RAX: 0000000000000000 RBX: ffff88847dae2d58 RCX: 0000000000000001\n[  449.022999] RDX: 0000000080000001 RSI: ffff88849d914978 RDI: 00000000ffffffff\n[  449.023002] RBP: ffff88847dae32c0 R08: ffff88849d914978 R09: 0000000000000000\n[  449.023006] R10: ffffc900001abcb8 R11: 0000000000000000 R12: ffff888490d98400\n[  449.023009] R13: ffff88847dae3230 R14: ffff88847db1c140 R15: ffff888490d98540\n[  449.023013] FS:  0000000000000000(0000) GS:ffff88849ff00000(0000) knlGS:0000000000000000\n[  449.023017] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n[  449.023021] CR2: 00007fb96fafdc63 CR3: 0000000005610004 CR4: 0000000000760ee0\n[  449.023025] PKRU: 55555554\n[  449.023028] Call Trace:\n[  449.023034]  drm_dp_queue_down_tx+0x59/0x110\n[  449.023041]  ? rcu_read_lock_sched_held+0x4d/0x80\n[  449.023050]  ? kmem_cache_alloc_trace+0x2a6/0x2d0\n[  449.023060]  drm_dp_send_link_address+0x74/0x870\n[  449.023065]  ? __slab_free+0x3e1/0x5c0\n[  449.023071]  ? lockdep_hardirqs_on+0xe0/0x1c0\n[  449.023078]  ? lockdep_hardirqs_on+0xe0/0x1c0\n[  449.023097]  drm_dp_check_and_send_link_address+0x9a/0xc0\n[  449.023106]  drm_dp_mst_link_probe_work+0x9e/0x160\n[  449.023117]  process_one_work+0x268/0x600\n[  449.023124]  ? __schedule+0x307/0x8d0\n[  449.023139]  worker_thread+0x37/0x380\n[  449.023149]  ? process_one_work+0x600/0x600\n[  449.023153]  kthread+0x140/0x160\n[  449.023159]  ? kthread_park+0x80/0x80\n[  449.023169]  ret_from_fork+0x24/0x50\n\nFixes: d308a881a591 (\"drm/dp_mst: Kill the second sideband tx slot, save the world\")\nCc: Lyude Paul <lyude@redhat.com>\nCc: Sean Paul <sean@poorly.run>\nCc: Wayne Lin <Wayne.Lin@amd.com>\nCc: <stable@vger.kernel.org> # v3.17+\nSigned-off-by: Imre Deak <imre.deak@intel.com>\nReviewed-by: Ville Syrj\u00e4l\u00e4 <ville.syrjala@linux.intel.com>\nLink: https://patchwork.freedesktop.org/patch/msgid/20200513103155.12336-1-imre.deak@intel.com",
        "before_after_code_files": [
          "drivers/gpu/drm/drm_dp_mst_topology.c||drivers/gpu/drm/drm_dp_mst_topology.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "drivers/gpu/drm/drm_dp_mst_topology.c||drivers/gpu/drm/drm_dp_mst_topology.c": [
          "File: drivers/gpu/drm/drm_dp_mst_topology.c -> drivers/gpu/drm/drm_dp_mst_topology.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1199:   if (txmsg->state == DRM_DP_SIDEBAND_TX_QUEUED ||",
          "1201:    list_del(&txmsg->next);",
          "1202:  }",
          "1203: out:",
          "",
          "[Removed Lines]",
          "1200:       txmsg->state == DRM_DP_SIDEBAND_TX_START_SEND)",
          "",
          "[Added Lines]",
          "1200:       txmsg->state == DRM_DP_SIDEBAND_TX_START_SEND ||",
          "1201:       txmsg->state == DRM_DP_SIDEBAND_TX_SENT)",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "21e0958ec9684e76e32f822c5e611a7d7ea0a5ba",
      "candidate_info": {
        "commit_hash": "21e0958ec9684e76e32f822c5e611a7d7ea0a5ba",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/21e0958ec9684e76e32f822c5e611a7d7ea0a5ba",
        "files": [
          "drivers/md/md.c"
        ],
        "message": "md: add checkings before flush md_misc_wq\n\nColy reported possible circular locking dependencyi with LOCKDEP enabled,\nquote the below info from the detailed report [1].\n\n[ 1607.673903] Chain exists of:\n[ 1607.673903]   kn->count#256 --> (wq_completion)md_misc -->\n(work_completion)(&rdev->del_work)\n[ 1607.673903]\n[ 1607.827946]  Possible unsafe locking scenario:\n[ 1607.827946]\n[ 1607.898780]        CPU0                    CPU1\n[ 1607.952980]        ----                    ----\n[ 1608.007173]   lock((work_completion)(&rdev->del_work));\n[ 1608.069690]                                lock((wq_completion)md_misc);\n[ 1608.149887]                                lock((work_completion)(&rdev->del_work));\n[ 1608.242563]   lock(kn->count#256);\n[ 1608.283238]\n[ 1608.283238]  *** DEADLOCK ***\n[ 1608.283238]\n[ 1608.354078] 2 locks held by kworker/5:0/843:\n[ 1608.405152]  #0: ffff8889eecc9948 ((wq_completion)md_misc){+.+.}, at:\nprocess_one_work+0x42b/0xb30\n[ 1608.512399]  #1: ffff888a1d3b7e10\n((work_completion)(&rdev->del_work)){+.+.}, at: process_one_work+0x42b/0xb30\n[ 1608.632130]\n\nSince works (rdev->del_work and mddev->del_work) are queued in md_misc_wq,\nthen lockdep_map lock is held if either of them are running, then both of\nthem try to hold kernfs lock by call kobject_del. Then if new_dev_store\nor array_state_store are triggered by write to the related sysfs node, so\nthe write operation gets kernfs lock, but need the lockdep_map because all\nof them would trigger flush_workqueue(md_misc_wq) finally, then the same\nlockdep_map lock is needed.\n\nTo suppress the lockdep warnning, we should flush the workqueue in case the\nrelated work is pending. And several works are attached to md_misc_wq, so\nwe need to check which work should be checked:\n\n1. for __md_stop_writes, the purpose of call flush workqueue is ensure sync\nthread is started if it was starting, so check mddev->del_work is pending\nor not since md_start_sync is attached to mddev->del_work.\n\n2. __md_stop flushes md_misc_wq to ensure event_work is done, check the\nevent_work is enough. Assume raid_{ctr,dtr} -> md_stop -> __md_stop doesn't\nneed the kernfs lock.\n\n3. both new_dev_store (holds kernfs lock) and ADD_NEW_DISK ioctl (holds the\nbdev->bd_mutex) call flush_workqueue to ensure md_delayed_delete has\ncompleted, this case will be handled in next patch.\n\n4. md_open flushes workqueue to ensure the previous md is disappeared, but\nit holds bdev->bd_mutex then try to flush workqueue, so it is better to\ncheck mddev->del_work as well to avoid potential lock issue, this will be\ndone in another patch.\n\n[1]: https://marc.info/?l=linux-raid&m=158518958031584&w=2\n\nCc: Coly Li <colyli@suse.de>\nReported-by: Coly Li <colyli@suse.de>\nSigned-off-by: Guoqing Jiang <guoqing.jiang@cloud.ionos.com>\nSigned-off-by: Song Liu <songliubraving@fb.com>",
        "before_after_code_files": [
          "drivers/md/md.c||drivers/md/md.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "drivers/md/md.c||drivers/md/md.c": [
          "File: drivers/md/md.c -> drivers/md/md.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "6147: static void __md_stop_writes(struct mddev *mddev)",
          "6148: {",
          "6149:  set_bit(MD_RECOVERY_FROZEN, &mddev->recovery);",
          "6151:  if (mddev->sync_thread) {",
          "6152:   set_bit(MD_RECOVERY_INTR, &mddev->recovery);",
          "6153:   md_reap_sync_thread(mddev);",
          "",
          "[Removed Lines]",
          "6150:  flush_workqueue(md_misc_wq);",
          "",
          "[Added Lines]",
          "6150:  if (work_pending(&mddev->del_work))",
          "6151:   flush_workqueue(md_misc_wq);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "6200:  md_bitmap_destroy(mddev);",
          "6201:  mddev_detach(mddev);",
          "6204:  spin_lock(&mddev->lock);",
          "6205:  mddev->pers = NULL;",
          "6206:  spin_unlock(&mddev->lock);",
          "",
          "[Removed Lines]",
          "6203:  flush_workqueue(md_misc_wq);",
          "",
          "[Added Lines]",
          "6204:  if (mddev->event_work.func)",
          "6205:   flush_workqueue(md_misc_wq);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "625236ba3832ae947cb3ebb7acc1f30788b274ef",
      "candidate_info": {
        "commit_hash": "625236ba3832ae947cb3ebb7acc1f30788b274ef",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/625236ba3832ae947cb3ebb7acc1f30788b274ef",
        "files": [
          "include/linux/lsm_hook_defs.h"
        ],
        "message": "security: Fix the default value of secid_to_secctx hook\n\nsecurity_secid_to_secctx is called by the bpf_lsm hook and a successful\nreturn value (i.e 0) implies that the parameter will be consumed by the\nLSM framework. The current behaviour return success when the pointer\nisn't initialized when CONFIG_BPF_LSM is enabled, with the default\nreturn from kernel/bpf/bpf_lsm.c.\n\nThis is the internal error:\n\n[ 1229.341488][ T2659] usercopy: Kernel memory exposure attempt detected from null address (offset 0, size 280)!\n[ 1229.374977][ T2659] ------------[ cut here ]------------\n[ 1229.376813][ T2659] kernel BUG at mm/usercopy.c:99!\n[ 1229.378398][ T2659] Internal error: Oops - BUG: 0 [#1] PREEMPT SMP\n[ 1229.380348][ T2659] Modules linked in:\n[ 1229.381654][ T2659] CPU: 0 PID: 2659 Comm: systemd-journal Tainted: G    B   W         5.7.0-rc5-next-20200511-00019-g864e0c6319b8-dirty #13\n[ 1229.385429][ T2659] Hardware name: linux,dummy-virt (DT)\n[ 1229.387143][ T2659] pstate: 80400005 (Nzcv daif +PAN -UAO BTYPE=--)\n[ 1229.389165][ T2659] pc : usercopy_abort+0xc8/0xcc\n[ 1229.390705][ T2659] lr : usercopy_abort+0xc8/0xcc\n[ 1229.392225][ T2659] sp : ffff000064247450\n[ 1229.393533][ T2659] x29: ffff000064247460 x28: 0000000000000000\n[ 1229.395449][ T2659] x27: 0000000000000118 x26: 0000000000000000\n[ 1229.397384][ T2659] x25: ffffa000127049e0 x24: ffffa000127049e0\n[ 1229.399306][ T2659] x23: ffffa000127048e0 x22: ffffa000127048a0\n[ 1229.401241][ T2659] x21: ffffa00012704b80 x20: ffffa000127049e0\n[ 1229.403163][ T2659] x19: ffffa00012704820 x18: 0000000000000000\n[ 1229.405094][ T2659] x17: 0000000000000000 x16: 0000000000000000\n[ 1229.407008][ T2659] x15: 0000000000000000 x14: 003d090000000000\n[ 1229.408942][ T2659] x13: ffff80000d5b25b2 x12: 1fffe0000d5b25b1\n[ 1229.410859][ T2659] x11: 1fffe0000d5b25b1 x10: ffff80000d5b25b1\n[ 1229.412791][ T2659] x9 : ffffa0001034bee0 x8 : ffff00006ad92d8f\n[ 1229.414707][ T2659] x7 : 0000000000000000 x6 : ffffa00015eacb20\n[ 1229.416642][ T2659] x5 : ffff0000693c8040 x4 : 0000000000000000\n[ 1229.418558][ T2659] x3 : ffffa0001034befc x2 : d57a7483a01c6300\n[ 1229.420610][ T2659] x1 : 0000000000000000 x0 : 0000000000000059\n[ 1229.422526][ T2659] Call trace:\n[ 1229.423631][ T2659]  usercopy_abort+0xc8/0xcc\n[ 1229.425091][ T2659]  __check_object_size+0xdc/0x7d4\n[ 1229.426729][ T2659]  put_cmsg+0xa30/0xa90\n[ 1229.428132][ T2659]  unix_dgram_recvmsg+0x80c/0x930\n[ 1229.429731][ T2659]  sock_recvmsg+0x9c/0xc0\n[ 1229.431123][ T2659]  ____sys_recvmsg+0x1cc/0x5f8\n[ 1229.432663][ T2659]  ___sys_recvmsg+0x100/0x160\n[ 1229.434151][ T2659]  __sys_recvmsg+0x110/0x1a8\n[ 1229.435623][ T2659]  __arm64_sys_recvmsg+0x58/0x70\n[ 1229.437218][ T2659]  el0_svc_common.constprop.1+0x29c/0x340\n[ 1229.438994][ T2659]  do_el0_svc+0xe8/0x108\n[ 1229.440587][ T2659]  el0_svc+0x74/0x88\n[ 1229.441917][ T2659]  el0_sync_handler+0xe4/0x8b4\n[ 1229.443464][ T2659]  el0_sync+0x17c/0x180\n[ 1229.444920][ T2659] Code: aa1703e2 aa1603e1 910a8260 97ecc860 (d4210000)\n[ 1229.447070][ T2659] ---[ end trace 400497d91baeaf51 ]---\n[ 1229.448791][ T2659] Kernel panic - not syncing: Fatal exception\n[ 1229.450692][ T2659] Kernel Offset: disabled\n[ 1229.452061][ T2659] CPU features: 0x240002,20002004\n[ 1229.453647][ T2659] Memory Limit: none\n[ 1229.455015][ T2659] ---[ end Kernel panic - not syncing: Fatal exception ]---\n\nRework the so the default return value is -EOPNOTSUPP.\n\nThere are likely other callbacks such as security_inode_getsecctx() that\nmay have the same problem, and that someone that understand the code\nbetter needs to audit them.\n\nThank you Arnd for helping me figure out what went wrong.\n\nFixes: 98e828a0650f (\"security: Refactor declaration of LSM hooks\")\nSigned-off-by: Anders Roxell <anders.roxell@linaro.org>\nSigned-off-by: Alexei Starovoitov <ast@kernel.org>\nAcked-by: James Morris <jamorris@linux.microsoft.com>\nCc: Arnd Bergmann <arnd@arndb.de>\nLink: https://lore.kernel.org/bpf/20200512174607.9630-1-anders.roxell@linaro.org",
        "before_after_code_files": [
          "include/linux/lsm_hook_defs.h||include/linux/lsm_hook_defs.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "include/linux/lsm_hook_defs.h||include/linux/lsm_hook_defs.h": [
          "File: include/linux/lsm_hook_defs.h -> include/linux/lsm_hook_defs.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "243:   char **value)",
          "244: LSM_HOOK(int, -EINVAL, setprocattr, const char *name, void *value, size_t size)",
          "245: LSM_HOOK(int, 0, ismaclabel, const char *name)",
          "247:   u32 *seclen)",
          "248: LSM_HOOK(int, 0, secctx_to_secid, const char *secdata, u32 seclen, u32 *secid)",
          "249: LSM_HOOK(void, LSM_RET_VOID, release_secctx, char *secdata, u32 seclen)",
          "",
          "[Removed Lines]",
          "246: LSM_HOOK(int, 0, secid_to_secctx, u32 secid, char **secdata,",
          "",
          "[Added Lines]",
          "246: LSM_HOOK(int, -EOPNOTSUPP, secid_to_secctx, u32 secid, char **secdata,",
          "",
          "---------------"
        ]
      }
    }
  ]
}
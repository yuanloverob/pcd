{
  "cve_id": "CVE-2011-4131",
  "cve_desc": "The NFSv4 implementation in the Linux kernel before 3.2.2 does not properly handle bitmap sizes in GETACL replies, which allows remote NFS servers to cause a denial of service (OOPS) by sending an excessive number of bitmap words.",
  "repo": "torvalds/linux",
  "patch_hash": "bf118a342f10dafe44b14451a1392c3254629a1f",
  "patch_info": {
    "commit_hash": "bf118a342f10dafe44b14451a1392c3254629a1f",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/bf118a342f10dafe44b14451a1392c3254629a1f",
    "files": [
      "fs/nfs/nfs4proc.c",
      "fs/nfs/nfs4xdr.c",
      "include/linux/nfs_xdr.h",
      "include/linux/sunrpc/xdr.h",
      "net/sunrpc/xdr.c"
    ],
    "message": "NFSv4: include bitmap in nfsv4 get acl data\n\nThe NFSv4 bitmap size is unbounded: a server can return an arbitrary\nsized bitmap in an FATTR4_WORD0_ACL request.  Replace using the\nnfs4_fattr_bitmap_maxsz as a guess to the maximum bitmask returned by a server\nwith the inclusion of the bitmap (xdr length plus bitmasks) and the acl data\nxdr length to the (cached) acl page data.\n\nThis is a general solution to commit e5012d1f \"NFSv4.1: update\nnfs4_fattr_bitmap_maxsz\" and fixes hitting a BUG_ON in xdr_shrink_bufhead\nwhen getting ACLs.\n\nFix a bug in decode_getacl that returned -EINVAL on ACLs > page when getxattr\nwas called with a NULL buffer, preventing ACL > PAGE_SIZE from being retrieved.\n\nCc: stable@kernel.org\nSigned-off-by: Andy Adamson <andros@netapp.com>\nSigned-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>",
    "before_after_code_files": [
      "fs/nfs/nfs4proc.c||fs/nfs/nfs4proc.c",
      "fs/nfs/nfs4xdr.c||fs/nfs/nfs4xdr.c",
      "include/linux/nfs_xdr.h||include/linux/nfs_xdr.h",
      "include/linux/sunrpc/xdr.h||include/linux/sunrpc/xdr.h",
      "net/sunrpc/xdr.c||net/sunrpc/xdr.c"
    ]
  },
  "patch_diff": {
    "fs/nfs/nfs4proc.c||fs/nfs/nfs4proc.c": [
      "File: fs/nfs/nfs4proc.c -> fs/nfs/nfs4proc.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "3427: #define NFS4ACL_MAXPAGES (XATTR_SIZE_MAX >> PAGE_CACHE_SHIFT)",
      "3442: static int buf_to_pages_noslab(const void *buf, size_t buflen,",
      "3443:   struct page **pages, unsigned int *pgbase)",
      "3444: {",
      "",
      "[Removed Lines]",
      "3429: static void buf_to_pages(const void *buf, size_t buflen,",
      "3430:   struct page **pages, unsigned int *pgbase)",
      "3431: {",
      "3432:  const void *p = buf;",
      "3435:  p -= *pgbase;",
      "3436:  while (p < buf + buflen) {",
      "3438:   p += PAGE_CACHE_SIZE;",
      "3439:  }",
      "3440: }",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "3535:  nfs4_set_cached_acl(inode, acl);",
      "3536: }",
      "3538: static ssize_t __nfs4_get_acl_uncached(struct inode *inode, void *buf, size_t buflen)",
      "3539: {",
      "3541:  struct nfs_getaclargs args = {",
      "3542:   .fh = NFS_FH(inode),",
      "3543:   .acl_pages = pages,",
      "",
      "[Removed Lines]",
      "3540:  struct page *pages[NFS4ACL_MAXPAGES];",
      "",
      "[Added Lines]",
      "3537:  struct page *pages[NFS4ACL_MAXPAGES] = {NULL, };",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "3552:   .rpc_argp = &args,",
      "3553:   .rpc_resp = &res,",
      "3554:  };",
      "3571:  }",
      "3573:  if (ret)",
      "3574:   goto out_free;",
      "3577:  else",
      "3579:  if (buf) {",
      "3580:   ret = -ERANGE;",
      "3582:    goto out_free;",
      "3585:  }",
      "3587: out_free:",
      "3590:  return ret;",
      "3591: }",
      "",
      "[Removed Lines]",
      "3555:  struct page *localpage = NULL;",
      "3556:  int ret;",
      "3558:  if (buflen < PAGE_SIZE) {",
      "3561:   localpage = alloc_page(GFP_KERNEL);",
      "3562:   resp_buf = page_address(localpage);",
      "3563:   if (localpage == NULL)",
      "3564:    return -ENOMEM;",
      "3565:   args.acl_pages[0] = localpage;",
      "3566:   args.acl_pgbase = 0;",
      "3567:   args.acl_len = PAGE_SIZE;",
      "3568:  } else {",
      "3569:   resp_buf = buf;",
      "3570:   buf_to_pages(buf, buflen, args.acl_pages, &args.acl_pgbase);",
      "3572:  ret = nfs4_call_sync(NFS_SERVER(inode)->client, NFS_SERVER(inode), &msg, &args.seq_args, &res.seq_res, 0);",
      "3575:  if (res.acl_len > args.acl_len)",
      "3576:   nfs4_write_cached_acl(inode, NULL, res.acl_len);",
      "3578:   nfs4_write_cached_acl(inode, resp_buf, res.acl_len);",
      "3581:   if (res.acl_len > buflen)",
      "3583:   if (localpage)",
      "3584:    memcpy(buf, resp_buf, res.acl_len);",
      "3586:  ret = res.acl_len;",
      "3588:  if (localpage)",
      "3589:   __free_page(localpage);",
      "",
      "[Added Lines]",
      "3552:  int ret = -ENOMEM, npages, i, acl_len = 0;",
      "3554:  npages = (buflen + PAGE_SIZE - 1) >> PAGE_SHIFT;",
      "3557:  if (npages == 0)",
      "3558:   npages = 1;",
      "3560:  for (i = 0; i < npages; i++) {",
      "3561:   pages[i] = alloc_page(GFP_KERNEL);",
      "3562:   if (!pages[i])",
      "3563:    goto out_free;",
      "3564:  }",
      "3565:  if (npages > 1) {",
      "3567:   args.acl_scratch = alloc_page(GFP_KERNEL);",
      "3568:   if (!args.acl_scratch)",
      "3569:    goto out_free;",
      "3571:  args.acl_len = npages * PAGE_SIZE;",
      "3572:  args.acl_pgbase = 0;",
      "3575:  if (buf == NULL)",
      "3576:   res.acl_flags |= NFS4_ACL_LEN_REQUEST;",
      "3577:  resp_buf = page_address(pages[0]);",
      "3579:  dprintk(\"%s  buf %p buflen %ld npages %d args.acl_len %ld\\n\",",
      "3580:   __func__, buf, buflen, npages, args.acl_len);",
      "3581:  ret = nfs4_call_sync(NFS_SERVER(inode)->client, NFS_SERVER(inode),",
      "3582:         &msg, &args.seq_args, &res.seq_res, 0);",
      "3586:  acl_len = res.acl_len - res.acl_data_offset;",
      "3587:  if (acl_len > args.acl_len)",
      "3588:   nfs4_write_cached_acl(inode, NULL, acl_len);",
      "3590:   nfs4_write_cached_acl(inode, resp_buf + res.acl_data_offset,",
      "3591:           acl_len);",
      "3594:   if (acl_len > buflen)",
      "3596:   _copy_from_pages(buf, pages, res.acl_data_offset,",
      "3597:     res.acl_len);",
      "3599:  ret = acl_len;",
      "3601:  for (i = 0; i < npages; i++)",
      "3602:   if (pages[i])",
      "3603:    __free_page(pages[i]);",
      "3604:  if (args.acl_scratch)",
      "3605:   __free_page(args.acl_scratch);",
      "",
      "---------------"
    ],
    "fs/nfs/nfs4xdr.c||fs/nfs/nfs4xdr.c": [
      "File: fs/nfs/nfs4xdr.c -> fs/nfs/nfs4xdr.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "2517:  encode_compound_hdr(xdr, req, &hdr);",
      "2518:  encode_sequence(xdr, &args->seq_args, &hdr);",
      "2519:  encode_putfh(xdr, args->fh, &hdr);",
      "2521:  encode_getattr_two(xdr, FATTR4_WORD0_ACL, 0, &hdr);",
      "2523:  xdr_inline_pages(&req->rq_rcv_buf, replen << 2,",
      "2524:   args->acl_pages, args->acl_pgbase, args->acl_len);",
      "2525:  encode_nops(&hdr);",
      "2526: }",
      "",
      "[Removed Lines]",
      "2520:  replen = hdr.replen + op_decode_hdr_maxsz + nfs4_fattr_bitmap_maxsz + 1;",
      "",
      "[Added Lines]",
      "2520:  replen = hdr.replen + op_decode_hdr_maxsz + 1;",
      "2525:  xdr_set_scratch_buffer(xdr, page_address(args->acl_scratch), PAGE_SIZE);",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "4957: }",
      "4959: static int decode_getacl(struct xdr_stream *xdr, struct rpc_rqst *req,",
      "4961: {",
      "4963:  uint32_t attrlen,",
      "4964:    bitmap[3] = {0};",
      "4965:  struct kvec *iov = req->rq_rcv_buf.head;",
      "4966:  int status;",
      "4969:  if ((status = decode_op_hdr(xdr, OP_GETATTR)) != 0)",
      "4970:   goto out;",
      "4971:  if ((status = decode_attr_bitmap(xdr, bitmap)) != 0)",
      "4972:   goto out;",
      "4973:  if ((status = decode_attr_length(xdr, &attrlen, &savep)) != 0)",
      "",
      "[Removed Lines]",
      "4960:   size_t *acl_len)",
      "4962:  __be32 *savep;",
      "",
      "[Added Lines]",
      "4962:     struct nfs_getaclres *res)",
      "4964:  __be32 *savep, *bm_p;",
      "4970:  res->acl_len = 0;",
      "4973:  bm_p = xdr->p;",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "4979:   size_t hdrlen;",
      "4980:   u32 recvd;",
      "4984:   hdrlen = (u8 *)xdr->p - (u8 *)iov->iov_base;",
      "4985:   recvd = req->rq_rcv_buf.len - hdrlen;",
      "4986:   if (attrlen > recvd) {",
      "4989:      attrlen, recvd);",
      "4990:    return -EINVAL;",
      "4991:   }",
      "4992:   xdr_read_pages(xdr, attrlen);",
      "4994:  } else",
      "4995:   status = -EOPNOTSUPP;",
      "",
      "[Removed Lines]",
      "4987:    dprintk(\"NFS: server cheating in getattr\"",
      "4988:      \" acl reply: attrlen %u > recvd %u\\n\",",
      "",
      "[Added Lines]",
      "4988:   xdr->p = bm_p;",
      "4989:   res->acl_data_offset = be32_to_cpup(bm_p) + 2;",
      "4990:   res->acl_data_offset <<= 2;",
      "4995:   attrlen += res->acl_data_offset;",
      "4998:    if (res->acl_flags & NFS4_ACL_LEN_REQUEST) {",
      "5000:     res->acl_len = attrlen;",
      "5001:     goto out;",
      "5002:    }",
      "5003:    dprintk(\"NFS: acl reply: attrlen %u > recvd %u\\n\",",
      "5008:   res->acl_len = attrlen;",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "6028:  status = decode_putfh(xdr);",
      "6029:  if (status)",
      "6030:   goto out;",
      "6033: out:",
      "6034:  return status;",
      "",
      "[Removed Lines]",
      "6031:  status = decode_getacl(xdr, rqstp, &res->acl_len);",
      "",
      "[Added Lines]",
      "6046:  status = decode_getacl(xdr, rqstp, res);",
      "",
      "---------------"
    ],
    "include/linux/nfs_xdr.h||include/linux/nfs_xdr.h": [
      "File: include/linux/nfs_xdr.h -> include/linux/nfs_xdr.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "602:  size_t    acl_len;",
      "603:  unsigned int   acl_pgbase;",
      "604:  struct page **   acl_pages;",
      "605:  struct nfs4_sequence_args  seq_args;",
      "606: };",
      "608: struct nfs_getaclres {",
      "609:  size_t    acl_len;",
      "610:  struct nfs4_sequence_res seq_res;",
      "611: };",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "605:  struct page *   acl_scratch;",
      "613:  size_t    acl_data_offset;",
      "614:  int    acl_flags;",
      "",
      "---------------"
    ],
    "include/linux/sunrpc/xdr.h||include/linux/sunrpc/xdr.h": [
      "File: include/linux/sunrpc/xdr.h -> include/linux/sunrpc/xdr.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "191:         struct xdr_array2_desc *desc);",
      "192: extern int xdr_encode_array2(struct xdr_buf *buf, unsigned int base,",
      "193:         struct xdr_array2_desc *desc);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "194: extern void _copy_from_pages(char *p, struct page **pages, size_t pgbase,",
      "195:         size_t len);",
      "",
      "---------------"
    ],
    "net/sunrpc/xdr.c||net/sunrpc/xdr.c": [
      "File: net/sunrpc/xdr.c -> net/sunrpc/xdr.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "300: _copy_from_pages(char *p, struct page **pages, size_t pgbase, size_t len)",
      "301: {",
      "302:  struct page **pgfrom;",
      "",
      "[Removed Lines]",
      "299: static void",
      "",
      "[Added Lines]",
      "299: void",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "325:  } while ((len -= copy) != 0);",
      "326: }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "327: EXPORT_SYMBOL_GPL(_copy_from_pages);",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "cff298c721099c9ac4cea7196a37097ba2847946",
      "candidate_info": {
        "commit_hash": "cff298c721099c9ac4cea7196a37097ba2847946",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/cff298c721099c9ac4cea7196a37097ba2847946",
        "files": [
          "fs/nfs/nfs4xdr.c"
        ],
        "message": "NFSv4: Don't use private xdr_stream fields in decode_getacl\n\nInstead of using the private field xdr->p from struct xdr_stream,\nuse the public xdr_stream_pos().\n\nSigned-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>",
        "before_after_code_files": [
          "fs/nfs/nfs4xdr.c||fs/nfs/nfs4xdr.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "fs/nfs/nfs4xdr.c||fs/nfs/nfs4xdr.c"
          ],
          "candidate": [
            "fs/nfs/nfs4xdr.c||fs/nfs/nfs4xdr.c"
          ]
        }
      },
      "candidate_diff": {
        "fs/nfs/nfs4xdr.c||fs/nfs/nfs4xdr.c": [
          "File: fs/nfs/nfs4xdr.c -> fs/nfs/nfs4xdr.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "5045:     struct nfs_getaclres *res)",
          "5046: {",
          "5047:  unsigned int savep;",
          "5049:  uint32_t attrlen,",
          "5050:    bitmap[3] = {0};",
          "5051:  int status;",
          "5053:  res->acl_len = 0;",
          "5054:  if ((status = decode_op_hdr(xdr, OP_GETATTR)) != 0)",
          "",
          "[Removed Lines]",
          "5048:  __be32 *bm_p;",
          "",
          "[Added Lines]",
          "5051:  unsigned int pg_offset;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "5057:  xdr_enter_page(xdr, xdr->buf->page_len);",
          "5061:  if ((status = decode_attr_bitmap(xdr, bitmap)) != 0)",
          "5062:   goto out;",
          "",
          "[Removed Lines]",
          "5059:  bm_p = xdr->p;",
          "",
          "[Added Lines]",
          "5060:  pg_offset = xdr->buf->head[0].iov_len;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "5077:   res->acl_len = attrlen;",
          "5079:    if (res->acl_flags & NFS4_ACL_LEN_REQUEST) {",
          "5081:     goto out;",
          "5082:    }",
          "5083:    dprintk(\"NFS: acl reply: attrlen %u > page_len %u\\n\",",
          "5085:    return -EINVAL;",
          "5086:   }",
          "5087:  } else",
          "",
          "[Removed Lines]",
          "5073:   res->acl_data_offset = (xdr->p - bm_p) << 2;",
          "5078:   if (attrlen + res->acl_data_offset > xdr->buf->page_len) {",
          "5084:      attrlen, xdr->buf->page_len);",
          "",
          "[Added Lines]",
          "5074:   res->acl_data_offset = xdr_stream_pos(xdr) - pg_offset;",
          "5079:   if (attrlen > (xdr->nwords << 2)) {",
          "5085:      attrlen, xdr->nwords << 2);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "7d3e91a89b7adbc2831334def9e494dd9892f9af",
      "candidate_info": {
        "commit_hash": "7d3e91a89b7adbc2831334def9e494dd9892f9af",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/7d3e91a89b7adbc2831334def9e494dd9892f9af",
        "files": [
          "fs/nfs/nfs4proc.c"
        ],
        "message": "NFSv4: Check for buffer length in __nfs4_get_acl_uncached\n\nCommit 1f1ea6c \"NFSv4: Fix buffer overflow checking in\n__nfs4_get_acl_uncached\" accidently dropped the checking for too small\nresult buffer length.\n\nIf someone uses getxattr on \"system.nfs4_acl\" on an NFSv4 mount\nsupporting ACLs, the ACL has not been cached and the buffer suplied is\ntoo short, we still copy the complete ACL, resulting in kernel and user\nspace memory corruption.\n\nSigned-off-by: Sven Wegener <sven.wegener@stealer.net>\nCc: stable@kernel.org\nSigned-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>",
        "before_after_code_files": [
          "fs/nfs/nfs4proc.c||fs/nfs/nfs4proc.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "fs/nfs/nfs4proc.c||fs/nfs/nfs4proc.c"
          ],
          "candidate": [
            "fs/nfs/nfs4proc.c||fs/nfs/nfs4proc.c"
          ]
        }
      },
      "candidate_diff": {
        "fs/nfs/nfs4proc.c||fs/nfs/nfs4proc.c": [
          "File: fs/nfs/nfs4proc.c -> fs/nfs/nfs4proc.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "3937:   goto out_free;",
          "3938:  }",
          "3939:  nfs4_write_cached_acl(inode, pages, res.acl_data_offset, res.acl_len);",
          "3941:   _copy_from_pages(buf, pages, res.acl_data_offset, res.acl_len);",
          "3942: out_ok:",
          "3943:  ret = res.acl_len;",
          "3944: out_free:",
          "",
          "[Removed Lines]",
          "3940:  if (buf)",
          "",
          "[Added Lines]",
          "3940:  if (buf) {",
          "3941:   if (res.acl_len > buflen) {",
          "3942:    ret = -ERANGE;",
          "3943:    goto out_free;",
          "3944:   }",
          "3946:  }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "21f498c2f73bd6150d82931f09965826dca0b5f2",
      "candidate_info": {
        "commit_hash": "21f498c2f73bd6150d82931f09965826dca0b5f2",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/21f498c2f73bd6150d82931f09965826dca0b5f2",
        "files": [
          "fs/nfs/nfs4proc.c"
        ],
        "message": "NFSv4: Fix range checking in __nfs4_get_acl_uncached and __nfs4_proc_set_acl\n\nEnsure that the user supplied buffer size doesn't cause us to overflow\nthe 'pages' array.\n\nAlso fix up some confusion between the use of PAGE_SIZE and\nPAGE_CACHE_SIZE when calculating buffer sizes. We're not using\nthe page cache for anything here.\n\nSigned-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>",
        "before_after_code_files": [
          "fs/nfs/nfs4proc.c||fs/nfs/nfs4proc.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "fs/nfs/nfs4proc.c||fs/nfs/nfs4proc.c"
          ],
          "candidate": [
            "fs/nfs/nfs4proc.c||fs/nfs/nfs4proc.c"
          ]
        }
      },
      "candidate_diff": {
        "fs/nfs/nfs4proc.c||fs/nfs/nfs4proc.c": [
          "File: fs/nfs/nfs4proc.c -> fs/nfs/nfs4proc.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "3653:   && (server->acl_bitmask & ACL4_SUPPORT_DENY_ACL);",
          "3654: }",
          "3662: static int buf_to_pages_noslab(const void *buf, size_t buflen,",
          "3663:   struct page **pages, unsigned int *pgbase)",
          "",
          "[Removed Lines]",
          "3660: #define NFS4ACL_MAXPAGES (XATTR_SIZE_MAX >> PAGE_CACHE_SHIFT)",
          "",
          "[Added Lines]",
          "3660: #define NFS4ACL_MAXPAGES DIV_ROUND_UP(XATTR_SIZE_MAX, PAGE_SIZE)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "3668:  spages = pages;",
          "3670:  do {",
          "3672:   newpage = alloc_page(GFP_KERNEL);",
          "3674:   if (newpage == NULL)",
          "",
          "[Removed Lines]",
          "3671:   len = min_t(size_t, PAGE_CACHE_SIZE, buflen);",
          "",
          "[Added Lines]",
          "3671:   len = min_t(size_t, PAGE_SIZE, buflen);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "3782:   .rpc_argp = &args,",
          "3783:   .rpc_resp = &res,",
          "3784:  };",
          "3786:  size_t acl_len = 0;",
          "3791:  if (npages == 0)",
          "3792:   npages = 1;",
          "3797:  for (i = 0; i < npages; i++) {",
          "3798:   pages[i] = alloc_page(GFP_KERNEL);",
          "",
          "[Removed Lines]",
          "3785:  int ret = -ENOMEM, npages, i;",
          "3788:  npages = (buflen + PAGE_SIZE - 1) >> PAGE_SHIFT;",
          "3795:  npages++;",
          "",
          "[Added Lines]",
          "3785:  unsigned int npages = DIV_ROUND_UP(buflen, PAGE_SIZE);",
          "3786:  int ret = -ENOMEM, i;",
          "3793:  if (npages > ARRAY_SIZE(pages))",
          "3794:   return -ERANGE;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "3891:   .rpc_argp = &arg,",
          "3892:   .rpc_resp = &res,",
          "3893:  };",
          "3894:  int ret, i;",
          "3896:  if (!nfs4_server_supports_acls(server))",
          "3897:   return -EOPNOTSUPP;",
          "3898:  i = buf_to_pages_noslab(buf, buflen, arg.acl_pages, &arg.acl_pgbase);",
          "3899:  if (i < 0)",
          "3900:   return i;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3893:  unsigned int npages = DIV_ROUND_UP(buflen, PAGE_SIZE);",
          "3898:  if (npages > ARRAY_SIZE(pages))",
          "3899:   return -ERANGE;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "56d08fef2369d5ca9ad2e1fc697f5379fd8af751",
      "candidate_info": {
        "commit_hash": "56d08fef2369d5ca9ad2e1fc697f5379fd8af751",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/56d08fef2369d5ca9ad2e1fc697f5379fd8af751",
        "files": [
          "fs/nfs/nfs4proc.c"
        ],
        "message": "NFS: nfs_getaclargs.acl_len is a size_t\n\nSquelch compiler warnings:\n\nfs/nfs/nfs4proc.c: In function \u2018__nfs4_get_acl_uncached\u2019:\nfs/nfs/nfs4proc.c:3811:14: warning: comparison between signed and\n\tunsigned integer expressions [-Wsign-compare]\nfs/nfs/nfs4proc.c:3818:15: warning: comparison between signed and\n\tunsigned integer expressions [-Wsign-compare]\n\nIntroduced by commit bf118a34 \"NFSv4: include bitmap in nfsv4 get\nacl data\", Dec 7, 2011.\n\nSigned-off-by: Chuck Lever <chuck.lever@oracle.com>\nSigned-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>",
        "before_after_code_files": [
          "fs/nfs/nfs4proc.c||fs/nfs/nfs4proc.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "fs/nfs/nfs4proc.c||fs/nfs/nfs4proc.c"
          ],
          "candidate": [
            "fs/nfs/nfs4proc.c||fs/nfs/nfs4proc.c"
          ]
        }
      },
      "candidate_diff": {
        "fs/nfs/nfs4proc.c||fs/nfs/nfs4proc.c": [
          "File: fs/nfs/nfs4proc.c -> fs/nfs/nfs4proc.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "3775:   .rpc_argp = &args,",
          "3776:   .rpc_resp = &res,",
          "3777:  };",
          "3780:  npages = (buflen + PAGE_SIZE - 1) >> PAGE_SHIFT;",
          "",
          "[Removed Lines]",
          "3778:  int ret = -ENOMEM, npages, i, acl_len = 0;",
          "",
          "[Added Lines]",
          "3778:  int ret = -ENOMEM, npages, i;",
          "3779:  size_t acl_len = 0;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "e9e3d724e2145f5039b423c290ce2b2c3d8f94bc",
      "candidate_info": {
        "commit_hash": "e9e3d724e2145f5039b423c290ce2b2c3d8f94bc",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/e9e3d724e2145f5039b423c290ce2b2c3d8f94bc",
        "files": [
          "fs/nfs/nfs4proc.c"
        ],
        "message": "nfs4: Ensure that ACL pages sent over NFS were not allocated from the slab (v3)\n\nThe \"bad_page()\" page allocator sanity check was reported recently (call\nchain as follows):\n\n  bad_page+0x69/0x91\n  free_hot_cold_page+0x81/0x144\n  skb_release_data+0x5f/0x98\n  __kfree_skb+0x11/0x1a\n  tcp_ack+0x6a3/0x1868\n  tcp_rcv_established+0x7a6/0x8b9\n  tcp_v4_do_rcv+0x2a/0x2fa\n  tcp_v4_rcv+0x9a2/0x9f6\n  do_timer+0x2df/0x52c\n  ip_local_deliver+0x19d/0x263\n  ip_rcv+0x539/0x57c\n  netif_receive_skb+0x470/0x49f\n  :virtio_net:virtnet_poll+0x46b/0x5c5\n  net_rx_action+0xac/0x1b3\n  __do_softirq+0x89/0x133\n  call_softirq+0x1c/0x28\n  do_softirq+0x2c/0x7d\n  do_IRQ+0xec/0xf5\n  default_idle+0x0/0x50\n  ret_from_intr+0x0/0xa\n  default_idle+0x29/0x50\n  cpu_idle+0x95/0xb8\n  start_kernel+0x220/0x225\n  _sinittext+0x22f/0x236\n\nIt occurs because an skb with a fraglist was freed from the tcp\nretransmit queue when it was acked, but a page on that fraglist had\nPG_Slab set (indicating it was allocated from the Slab allocator (which\nmeans the free path above can't safely free it via put_page.\n\nWe tracked this back to an nfsv4 setacl operation, in which the nfs code\nattempted to fill convert the passed in buffer to an array of pages in\n__nfs4_proc_set_acl, which gets used by the skb->frags list in\nxs_sendpages.  __nfs4_proc_set_acl just converts each page in the buffer\nto a page struct via virt_to_page, but the vfs allocates the buffer via\nkmalloc, meaning the PG_slab bit is set.  We can't create a buffer with\nkmalloc and free it later in the tcp ack path with put_page, so we need\nto either:\n\n1) ensure that when we create the list of pages, no page struct has\n   PG_Slab set\n\n or\n\n2) not use a page list to send this data\n\nGiven that these buffers can be multiple pages and arbitrarily sized, I\nthink (1) is the right way to go.  I've written the below patch to\nallocate a page from the buddy allocator directly and copy the data over\nto it.  This ensures that we have a put_page free-able page for every\nentry that winds up on an skb frag list, so it can be safely freed when\nthe frame is acked.  We do a put page on each entry after the\nrpc_call_sync call so as to drop our own reference count to the page,\nleaving only the ref count taken by tcp_sendpages.  This way the data\nwill be properly freed when the ack comes in\n\nSuccessfully tested by myself to solve the above oops.\n\nNote, as this is the result of a setacl operation that exceeded a page\nof data, I think this amounts to a local DOS triggerable by an\nuprivlidged user, so I'm CCing security on this as well.\n\nSigned-off-by: Neil Horman <nhorman@tuxdriver.com>\nCC: Trond Myklebust <Trond.Myklebust@netapp.com>\nCC: security@kernel.org\nCC: Jeff Layton <jlayton@redhat.com>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
        "before_after_code_files": [
          "fs/nfs/nfs4proc.c||fs/nfs/nfs4proc.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "fs/nfs/nfs4proc.c||fs/nfs/nfs4proc.c"
          ],
          "candidate": [
            "fs/nfs/nfs4proc.c||fs/nfs/nfs4proc.c"
          ]
        }
      },
      "candidate_diff": {
        "fs/nfs/nfs4proc.c||fs/nfs/nfs4proc.c": [
          "File: fs/nfs/nfs4proc.c -> fs/nfs/nfs4proc.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "51: #include <linux/sunrpc/bc_xprt.h>",
          "52: #include <linux/xattr.h>",
          "53: #include <linux/utsname.h>",
          "55: #include \"nfs4_fs.h\"",
          "56: #include \"delegation.h\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "54: #include <linux/mm.h>",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "3252:  }",
          "3253: }",
          "3255: struct nfs4_cached_acl {",
          "3256:  int cached;",
          "3257:  size_t len;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3256: static int buf_to_pages_noslab(const void *buf, size_t buflen,",
          "3257:   struct page **pages, unsigned int *pgbase)",
          "3258: {",
          "3259:  struct page *newpage, **spages;",
          "3260:  int rc = 0;",
          "3261:  size_t len;",
          "3262:  spages = pages;",
          "3264:  do {",
          "3265:   len = min(PAGE_CACHE_SIZE, buflen);",
          "3266:   newpage = alloc_page(GFP_KERNEL);",
          "3268:   if (newpage == NULL)",
          "3269:    goto unwind;",
          "3270:   memcpy(page_address(newpage), buf, len);",
          "3271:                 buf += len;",
          "3272:                 buflen -= len;",
          "3274:   rc++;",
          "3275:  } while (buflen != 0);",
          "3277:  return rc;",
          "3279: unwind:",
          "3280:  for(; rc > 0; rc--)",
          "3281:   __free_page(spages[rc-1]);",
          "3282:  return -ENOMEM;",
          "3283: }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "3420:   .rpc_argp = &arg,",
          "3421:   .rpc_resp = &res,",
          "3422:  };",
          "3425:  if (!nfs4_server_supports_acls(server))",
          "3426:   return -EOPNOTSUPP;",
          "3427:  nfs_inode_return_delegation(inode);",
          "3429:  ret = nfs4_call_sync(server, &msg, &arg, &res, 1);",
          "",
          "[Removed Lines]",
          "3423:  int ret;",
          "3428:  buf_to_pages(buf, buflen, arg.acl_pages, &arg.acl_pgbase);",
          "",
          "[Added Lines]",
          "3453:  int ret, i;",
          "3457:  i = buf_to_pages_noslab(buf, buflen, arg.acl_pages, &arg.acl_pgbase);",
          "3458:  if (i < 0)",
          "3459:   return i;",
          "3467:  for (; i > 0; i--)",
          "3468:   put_page(pages[i-1]);",
          "",
          "---------------"
        ]
      }
    }
  ]
}
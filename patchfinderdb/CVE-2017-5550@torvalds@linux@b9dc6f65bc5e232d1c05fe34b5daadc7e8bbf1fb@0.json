{
  "cve_id": "CVE-2017-5550",
  "cve_desc": "Off-by-one error in the pipe_advance function in lib/iov_iter.c in the Linux kernel before 4.9.5 allows local users to obtain sensitive information from uninitialized heap-memory locations in opportunistic circumstances by reading from a pipe after an incorrect buffer-release decision.",
  "repo": "torvalds/linux",
  "patch_hash": "b9dc6f65bc5e232d1c05fe34b5daadc7e8bbf1fb",
  "patch_info": {
    "commit_hash": "b9dc6f65bc5e232d1c05fe34b5daadc7e8bbf1fb",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/b9dc6f65bc5e232d1c05fe34b5daadc7e8bbf1fb",
    "files": [
      "lib/iov_iter.c"
    ],
    "message": "fix a fencepost error in pipe_advance()\n\nThe logics in pipe_advance() used to release all buffers past the new\nposition failed in cases when the number of buffers to release was equal\nto pipe->buffers.  If that happened, none of them had been released,\nleaving pipe full.  Worse, it was trivial to trigger and we end up with\npipe full of uninitialized pages.  IOW, it's an infoleak.\n\nCc: stable@vger.kernel.org # v4.9\nReported-by: \"Alan J. Wylie\" <alan@wylie.me.uk>\nTested-by: \"Alan J. Wylie\" <alan@wylie.me.uk>\nSigned-off-by: Al Viro <viro@zeniv.linux.org.uk>",
    "before_after_code_files": [
      "lib/iov_iter.c||liiov_iter.c"
    ]
  },
  "patch_diff": {
    "lib/iov_iter.c||liiov_iter.c": [
      "File: lib/iov_iter.c -> liiov_iter.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "730: }",
      "731: EXPORT_SYMBOL(iov_iter_copy_from_user_atomic);",
      "733: static void pipe_advance(struct iov_iter *i, size_t size)",
      "734: {",
      "735:  struct pipe_inode_info *pipe = i->pipe;",
      "740:  if (unlikely(i->count < size))",
      "741:   size = i->count;",
      "744:  if (size) {",
      "747:   while (1) {",
      "748:    buf = &pipe->bufs[idx];",
      "750:     break;",
      "752:    idx = next_idx(idx, pipe);",
      "753:   }",
      "755:   i->idx = idx;",
      "768:  }",
      "770: }",
      "772: void iov_iter_advance(struct iov_iter *i, size_t size)",
      "",
      "[Removed Lines]",
      "736:  struct pipe_buffer *buf;",
      "737:  int idx = i->idx;",
      "738:  size_t off = i->iov_offset, orig_sz;",
      "742:  orig_sz = size;",
      "746:    size += off - pipe->bufs[idx].offset;",
      "749:    if (size <= buf->len)",
      "751:    size -= buf->len;",
      "754:   buf->len = size;",
      "756:   off = i->iov_offset = buf->offset + size;",
      "757:  }",
      "758:  if (off)",
      "759:   idx = next_idx(idx, pipe);",
      "760:  if (pipe->nrbufs) {",
      "761:   int unused = (pipe->curbuf + pipe->nrbufs) & (pipe->buffers - 1);",
      "763:   while (idx != unused) {",
      "764:    pipe_buf_release(pipe, &pipe->bufs[idx]);",
      "765:    idx = next_idx(idx, pipe);",
      "766:    pipe->nrbufs--;",
      "767:   }",
      "769:  i->count -= orig_sz;",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "826:    size_t count)",
      "827: {",
      "828:  BUG_ON(direction != ITER_PIPE);",
      "829:  i->type = direction;",
      "830:  i->pipe = pipe;",
      "831:  i->idx = (pipe->curbuf + pipe->nrbufs) & (pipe->buffers - 1);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "241699cd72a8489c9446ae3910ddd243e9b9061b",
      "candidate_info": {
        "commit_hash": "241699cd72a8489c9446ae3910ddd243e9b9061b",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/241699cd72a8489c9446ae3910ddd243e9b9061b",
        "files": [
          "fs/splice.c",
          "include/linux/splice.h",
          "include/linux/uio.h",
          "lib/iov_iter.c"
        ],
        "message": "new iov_iter flavour: pipe-backed\n\niov_iter variant for passing data into pipe.  copy_to_iter()\ncopies data into page(s) it has allocated and stuffs them into\nthe pipe; copy_page_to_iter() stuffs there a reference to the\npage given to it.  Both will try to coalesce if possible.\niov_iter_zero() is similar to copy_to_iter(); iov_iter_get_pages()\nand friends will do as copy_to_iter() would have and return the\npages where the data would've been copied.  iov_iter_advance()\nwill truncate everything past the spot it has advanced to.\n\nNew primitive: iov_iter_pipe(), used for initializing those.\npipe should be locked all along.\n\nRunning out of space acts as fault would for iovec-backed ones;\nin other words, giving it to ->read_iter() may result in short\nread if the pipe overflows, or -EFAULT if it happens with nothing\ncopied there.\n\nIn other words, ->read_iter() on those acts pretty much like\n->splice_read().  Moreover, all generic_file_splice_read() users,\nas well as many other ->splice_read() instances can be switched\nto that scheme - that'll happen in the next commit.\n\nSigned-off-by: Al Viro <viro@zeniv.linux.org.uk>",
        "before_after_code_files": [
          "fs/splice.c||fs/splice.c",
          "include/linux/splice.h||include/linux/splice.h",
          "include/linux/uio.h||include/linux/uio.h",
          "lib/iov_iter.c||lib/iov_iter.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "lib/iov_iter.c||liiov_iter.c"
          ],
          "candidate": [
            "lib/iov_iter.c||lib/iov_iter.c"
          ]
        }
      },
      "candidate_diff": {
        "fs/splice.c||fs/splice.c": [
          "File: fs/splice.c -> fs/splice.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "524: }",
          "525: EXPORT_SYMBOL(generic_file_splice_read);",
          "528:  .can_merge = 0,",
          "529:  .confirm = generic_pipe_buf_confirm,",
          "530:  .release = generic_pipe_buf_release,",
          "",
          "[Removed Lines]",
          "527: static const struct pipe_buf_operations default_pipe_buf_ops = {",
          "",
          "[Added Lines]",
          "527: const struct pipe_buf_operations default_pipe_buf_ops = {",
          "",
          "---------------"
        ],
        "include/linux/splice.h||include/linux/splice.h": [
          "File: include/linux/splice.h -> include/linux/splice.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "85: extern void spd_release_page(struct splice_pipe_desc *, unsigned int);",
          "87: extern const struct pipe_buf_operations page_cache_pipe_buf_ops;",
          "88: #endif",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "88: extern const struct pipe_buf_operations default_pipe_buf_ops;",
          "",
          "---------------"
        ],
        "include/linux/uio.h||include/linux/uio.h": [
          "File: include/linux/uio.h -> include/linux/uio.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "13: #include <uapi/linux/uio.h>",
          "15: struct page;",
          "17: struct kvec {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "16: struct pipe_inode_info;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "23:  ITER_IOVEC = 0,",
          "24:  ITER_KVEC = 2,",
          "25:  ITER_BVEC = 4,",
          "26: };",
          "28: struct iov_iter {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "27:  ITER_PIPE = 8,",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "33:   const struct iovec *iov;",
          "34:   const struct kvec *kvec;",
          "35:   const struct bio_vec *bvec;",
          "36:  };",
          "38: };",
          "",
          "[Removed Lines]",
          "37:  unsigned long nr_segs;",
          "",
          "[Added Lines]",
          "38:   struct pipe_inode_info *pipe;",
          "39:  };",
          "40:  union {",
          "41:   unsigned long nr_segs;",
          "42:   int idx;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "64: }",
          "66: #define iov_for_each(iov, iter, start)    \\",
          "68:  for (iter = (start);     \\",
          "69:       (iter).count &&     \\",
          "70:       ((iov = iov_iter_iovec(&(iter))), 1);  \\",
          "",
          "[Removed Lines]",
          "67:  if (!((start).type & ITER_BVEC))   \\",
          "",
          "[Added Lines]",
          "73:  if (!((start).type & (ITER_BVEC | ITER_PIPE)))  \\",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "94:    unsigned long nr_segs, size_t count);",
          "95: void iov_iter_bvec(struct iov_iter *i, int direction, const struct bio_vec *bvec,",
          "96:    unsigned long nr_segs, size_t count);",
          "97: ssize_t iov_iter_get_pages(struct iov_iter *i, struct page **pages,",
          "98:    size_t maxsize, unsigned maxpages, size_t *start);",
          "99: ssize_t iov_iter_get_pages_alloc(struct iov_iter *i, struct page ***pages,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "103: void iov_iter_pipe(struct iov_iter *i, int direction, struct pipe_inode_info *pipe,",
          "104:    size_t count);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "110: static inline bool iter_is_iovec(struct iov_iter *i)",
          "111: {",
          "113: }",
          "",
          "[Removed Lines]",
          "112:  return !(i->type & (ITER_BVEC | ITER_KVEC));",
          "",
          "[Added Lines]",
          "120:  return !(i->type & (ITER_BVEC | ITER_KVEC | ITER_PIPE));",
          "",
          "---------------"
        ],
        "lib/iov_iter.c||lib/iov_iter.c": [
          "File: lib/iov_iter.c -> lib/iov_iter.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "3: #include <linux/pagemap.h>",
          "4: #include <linux/slab.h>",
          "5: #include <linux/vmalloc.h>",
          "6: #include <net/checksum.h>",
          "8: #define iterate_iovec(i, n, __v, __p, skip, STEP) { \\",
          "9:  size_t left;     \\",
          "10:  size_t wanted = n;    \\",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "6: #include <linux/splice.h>",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "290:  return wanted - bytes;",
          "291: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "296: #ifdef PIPE_PARANOIA",
          "297: static bool sanity(const struct iov_iter *i)",
          "298: {",
          "299:  struct pipe_inode_info *pipe = i->pipe;",
          "300:  int idx = i->idx;",
          "301:  int next = pipe->curbuf + pipe->nrbufs;",
          "302:  if (i->iov_offset) {",
          "303:   struct pipe_buffer *p;",
          "304:   if (unlikely(!pipe->nrbufs))",
          "305:    goto Bad; // pipe must be non-empty",
          "306:   if (unlikely(idx != ((next - 1) & (pipe->buffers - 1))))",
          "307:    goto Bad; // must be at the last buffer...",
          "309:   p = &pipe->bufs[idx];",
          "310:   if (unlikely(p->offset + p->len != i->iov_offset))",
          "311:    goto Bad; // ... at the end of segment",
          "312:  } else {",
          "313:   if (idx != (next & (pipe->buffers - 1)))",
          "314:    goto Bad; // must be right after the last buffer",
          "315:  }",
          "316:  return true;",
          "317: Bad:",
          "318:  printk(KERN_ERR \"idx = %d, offset = %zd\\n\", i->idx, i->iov_offset);",
          "319:  printk(KERN_ERR \"curbuf = %d, nrbufs = %d, buffers = %d\\n\",",
          "320:    pipe->curbuf, pipe->nrbufs, pipe->buffers);",
          "321:  for (idx = 0; idx < pipe->buffers; idx++)",
          "322:   printk(KERN_ERR \"[%p %p %d %d]\\n\",",
          "323:    pipe->bufs[idx].ops,",
          "324:    pipe->bufs[idx].page,",
          "325:    pipe->bufs[idx].offset,",
          "326:    pipe->bufs[idx].len);",
          "327:  WARN_ON(1);",
          "328:  return false;",
          "329: }",
          "330: #else",
          "331: #define sanity(i) true",
          "332: #endif",
          "334: static inline int next_idx(int idx, struct pipe_inode_info *pipe)",
          "335: {",
          "336:  return (idx + 1) & (pipe->buffers - 1);",
          "337: }",
          "339: static size_t copy_page_to_iter_pipe(struct page *page, size_t offset, size_t bytes,",
          "340:     struct iov_iter *i)",
          "341: {",
          "342:  struct pipe_inode_info *pipe = i->pipe;",
          "343:  struct pipe_buffer *buf;",
          "344:  size_t off;",
          "345:  int idx;",
          "347:  if (unlikely(bytes > i->count))",
          "348:   bytes = i->count;",
          "350:  if (unlikely(!bytes))",
          "351:   return 0;",
          "353:  if (!sanity(i))",
          "354:   return 0;",
          "356:  off = i->iov_offset;",
          "357:  idx = i->idx;",
          "358:  buf = &pipe->bufs[idx];",
          "359:  if (off) {",
          "360:   if (offset == off && buf->page == page) {",
          "362:    buf->len += bytes;",
          "363:    i->iov_offset += bytes;",
          "364:    goto out;",
          "365:   }",
          "366:   idx = next_idx(idx, pipe);",
          "367:   buf = &pipe->bufs[idx];",
          "368:  }",
          "369:  if (idx == pipe->curbuf && pipe->nrbufs)",
          "370:   return 0;",
          "371:  pipe->nrbufs++;",
          "372:  buf->ops = &page_cache_pipe_buf_ops;",
          "373:  get_page(buf->page = page);",
          "374:  buf->offset = offset;",
          "375:  buf->len = bytes;",
          "376:  i->iov_offset = offset + bytes;",
          "377:  i->idx = idx;",
          "378: out:",
          "379:  i->count -= bytes;",
          "380:  return bytes;",
          "381: }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "356:  kunmap_atomic(addr);",
          "357: }",
          "359: size_t copy_to_iter(const void *addr, size_t bytes, struct iov_iter *i)",
          "360: {",
          "361:  const char *from = addr;",
          "362:  iterate_and_advance(i, bytes, v,",
          "363:   __copy_to_user(v.iov_base, (from += v.iov_len) - v.iov_len,",
          "364:           v.iov_len),",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "449: static inline bool allocated(struct pipe_buffer *buf)",
          "450: {",
          "451:  return buf->ops == &default_pipe_buf_ops;",
          "452: }",
          "454: static inline void data_start(const struct iov_iter *i, int *idxp, size_t *offp)",
          "455: {",
          "456:  size_t off = i->iov_offset;",
          "457:  int idx = i->idx;",
          "458:  if (off && (!allocated(&i->pipe->bufs[idx]) || off == PAGE_SIZE)) {",
          "459:   idx = next_idx(idx, i->pipe);",
          "460:   off = 0;",
          "461:  }",
          "464: }",
          "466: static size_t push_pipe(struct iov_iter *i, size_t size,",
          "467:    int *idxp, size_t *offp)",
          "468: {",
          "469:  struct pipe_inode_info *pipe = i->pipe;",
          "470:  size_t off;",
          "471:  int idx;",
          "472:  ssize_t left;",
          "474:  if (unlikely(size > i->count))",
          "475:   size = i->count;",
          "476:  if (unlikely(!size))",
          "477:   return 0;",
          "479:  left = size;",
          "480:  data_start(i, &idx, &off);",
          "483:  if (off) {",
          "484:   left -= PAGE_SIZE - off;",
          "485:   if (left <= 0) {",
          "486:    pipe->bufs[idx].len += size;",
          "487:    return size;",
          "488:   }",
          "489:   pipe->bufs[idx].len = PAGE_SIZE;",
          "490:   idx = next_idx(idx, pipe);",
          "491:  }",
          "492:  while (idx != pipe->curbuf || !pipe->nrbufs) {",
          "493:   struct page *page = alloc_page(GFP_USER);",
          "494:   if (!page)",
          "495:    break;",
          "496:   pipe->nrbufs++;",
          "497:   pipe->bufs[idx].ops = &default_pipe_buf_ops;",
          "498:   pipe->bufs[idx].page = page;",
          "499:   pipe->bufs[idx].offset = 0;",
          "500:   if (left <= PAGE_SIZE) {",
          "501:    pipe->bufs[idx].len = left;",
          "502:    return size;",
          "503:   }",
          "504:   pipe->bufs[idx].len = PAGE_SIZE;",
          "505:   left -= PAGE_SIZE;",
          "506:   idx = next_idx(idx, pipe);",
          "507:  }",
          "508:  return size - left;",
          "509: }",
          "511: static size_t copy_pipe_to_iter(const void *addr, size_t bytes,",
          "512:     struct iov_iter *i)",
          "513: {",
          "514:  struct pipe_inode_info *pipe = i->pipe;",
          "515:  size_t n, off;",
          "516:  int idx;",
          "518:  if (!sanity(i))",
          "519:   return 0;",
          "521:  bytes = n = push_pipe(i, bytes, &idx, &off);",
          "522:  if (unlikely(!n))",
          "523:   return 0;",
          "524:  for ( ; n; idx = next_idx(idx, pipe), off = 0) {",
          "525:   size_t chunk = min_t(size_t, n, PAGE_SIZE - off);",
          "526:   memcpy_to_page(pipe->bufs[idx].page, off, addr, chunk);",
          "527:   i->idx = idx;",
          "528:   i->iov_offset = off + chunk;",
          "529:   n -= chunk;",
          "530:   addr += chunk;",
          "531:  }",
          "532:  i->count -= bytes;",
          "533:  return bytes;",
          "534: }",
          "539:  if (unlikely(i->type & ITER_PIPE))",
          "540:   return copy_pipe_to_iter(addr, bytes, i);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "374: size_t copy_from_iter(void *addr, size_t bytes, struct iov_iter *i)",
          "375: {",
          "376:  char *to = addr;",
          "377:  iterate_and_advance(i, bytes, v,",
          "378:   __copy_from_user((to += v.iov_len) - v.iov_len, v.iov_base,",
          "379:      v.iov_len),",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "556:  if (unlikely(i->type & ITER_PIPE)) {",
          "557:   WARN_ON(1);",
          "558:   return 0;",
          "559:  }",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "389: size_t copy_from_iter_nocache(void *addr, size_t bytes, struct iov_iter *i)",
          "390: {",
          "391:  char *to = addr;",
          "392:  iterate_and_advance(i, bytes, v,",
          "393:   __copy_from_user_nocache((to += v.iov_len) - v.iov_len,",
          "394:       v.iov_base, v.iov_len),",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "575:  if (unlikely(i->type & ITER_PIPE)) {",
          "576:   WARN_ON(1);",
          "577:   return 0;",
          "578:  }",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "409:   size_t wanted = copy_to_iter(kaddr + offset, bytes, i);",
          "410:   kunmap_atomic(kaddr);",
          "411:   return wanted;",
          "413:   return copy_page_to_iter_iovec(page, offset, bytes, i);",
          "414: }",
          "415: EXPORT_SYMBOL(copy_page_to_iter);",
          "417: size_t copy_page_from_iter(struct page *page, size_t offset, size_t bytes,",
          "418:     struct iov_iter *i)",
          "419: {",
          "420:  if (i->type & (ITER_BVEC|ITER_KVEC)) {",
          "421:   void *kaddr = kmap_atomic(page);",
          "422:   size_t wanted = copy_from_iter(kaddr + offset, bytes, i);",
          "",
          "[Removed Lines]",
          "412:  } else",
          "",
          "[Added Lines]",
          "599:  } else if (likely(!(i->type & ITER_PIPE)))",
          "601:  else",
          "602:   return copy_page_to_iter_pipe(page, offset, bytes, i);",
          "609:  if (unlikely(i->type & ITER_PIPE)) {",
          "610:   WARN_ON(1);",
          "611:   return 0;",
          "612:  }",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "427: }",
          "428: EXPORT_SYMBOL(copy_page_from_iter);",
          "430: size_t iov_iter_zero(size_t bytes, struct iov_iter *i)",
          "431: {",
          "432:  iterate_and_advance(i, bytes, v,",
          "433:   __clear_user(v.iov_base, v.iov_len),",
          "434:   memzero_page(v.bv_page, v.bv_offset, v.bv_len),",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "623: static size_t pipe_zero(size_t bytes, struct iov_iter *i)",
          "624: {",
          "625:  struct pipe_inode_info *pipe = i->pipe;",
          "626:  size_t n, off;",
          "627:  int idx;",
          "629:  if (!sanity(i))",
          "630:   return 0;",
          "632:  bytes = n = push_pipe(i, bytes, &idx, &off);",
          "633:  if (unlikely(!n))",
          "634:   return 0;",
          "636:  for ( ; n; idx = next_idx(idx, pipe), off = 0) {",
          "637:   size_t chunk = min_t(size_t, n, PAGE_SIZE - off);",
          "638:   memzero_page(pipe->bufs[idx].page, off, chunk);",
          "639:   i->idx = idx;",
          "640:   i->iov_offset = off + chunk;",
          "641:   n -= chunk;",
          "642:  }",
          "643:  i->count -= bytes;",
          "644:  return bytes;",
          "645: }",
          "649:  if (unlikely(i->type & ITER_PIPE))",
          "650:   return pipe_zero(bytes, i);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "443:   struct iov_iter *i, unsigned long offset, size_t bytes)",
          "444: {",
          "445:  char *kaddr = kmap_atomic(page), *p = kaddr + offset;",
          "446:  iterate_all_kinds(i, bytes, v,",
          "447:   __copy_from_user_inatomic((p += v.iov_len) - v.iov_len,",
          "448:        v.iov_base, v.iov_len),",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "665:  if (unlikely(i->type & ITER_PIPE)) {",
          "666:   kunmap_atomic(kaddr);",
          "667:   WARN_ON(1);",
          "668:   return 0;",
          "669:  }",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "455: }",
          "456: EXPORT_SYMBOL(iov_iter_copy_from_user_atomic);",
          "458: void iov_iter_advance(struct iov_iter *i, size_t size)",
          "459: {",
          "460:  iterate_and_advance(i, size, v, 0, 0, 0)",
          "461: }",
          "462: EXPORT_SYMBOL(iov_iter_advance);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "682: static void pipe_advance(struct iov_iter *i, size_t size)",
          "683: {",
          "684:  struct pipe_inode_info *pipe = i->pipe;",
          "685:  struct pipe_buffer *buf;",
          "686:  int idx = i->idx;",
          "687:  size_t off = i->iov_offset;",
          "689:  if (unlikely(i->count < size))",
          "690:   size = i->count;",
          "692:  if (size) {",
          "694:    size += off - pipe->bufs[idx].offset;",
          "695:   while (1) {",
          "696:    buf = &pipe->bufs[idx];",
          "697:    if (size <= buf->len)",
          "698:     break;",
          "699:    size -= buf->len;",
          "700:    idx = next_idx(idx, pipe);",
          "701:   }",
          "702:   buf->len = size;",
          "703:   i->idx = idx;",
          "704:   off = i->iov_offset = buf->offset + size;",
          "705:  }",
          "706:  if (off)",
          "707:   idx = next_idx(idx, pipe);",
          "708:  if (pipe->nrbufs) {",
          "709:   int unused = (pipe->curbuf + pipe->nrbufs) & (pipe->buffers - 1);",
          "711:   while (idx != unused) {",
          "712:    buf = &pipe->bufs[idx];",
          "713:    buf->ops->release(pipe, buf);",
          "714:    buf->ops = NULL;",
          "715:    idx = next_idx(idx, pipe);",
          "716:    pipe->nrbufs--;",
          "717:   }",
          "718:  }",
          "719: }",
          "723:  if (unlikely(i->type & ITER_PIPE)) {",
          "724:   pipe_advance(i, size);",
          "725:   return;",
          "726:  }",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "467: size_t iov_iter_single_seg_count(const struct iov_iter *i)",
          "468: {",
          "469:  if (i->nr_segs == 1)",
          "470:   return i->count;",
          "471:  else if (i->type & ITER_BVEC)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "736:  if (unlikely(i->type & ITER_PIPE))",
          "737:   return i->count; // it is a silly place, anyway",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "501: }",
          "502: EXPORT_SYMBOL(iov_iter_bvec);",
          "504: unsigned long iov_iter_alignment(const struct iov_iter *i)",
          "505: {",
          "506:  unsigned long res = 0;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "773: void iov_iter_pipe(struct iov_iter *i, int direction,",
          "774:    struct pipe_inode_info *pipe,",
          "775:    size_t count)",
          "776: {",
          "777:  BUG_ON(direction != ITER_PIPE);",
          "778:  i->type = direction;",
          "779:  i->pipe = pipe;",
          "780:  i->idx = (pipe->curbuf + pipe->nrbufs) & (pipe->buffers - 1);",
          "781:  i->iov_offset = 0;",
          "782:  i->count = count;",
          "783: }",
          "784: EXPORT_SYMBOL(iov_iter_pipe);",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "509:  if (!size)",
          "510:   return 0;",
          "512:  iterate_all_kinds(i, size, v,",
          "513:   (res |= (unsigned long)v.iov_base | v.iov_len, 0),",
          "514:   res |= v.bv_offset | v.bv_len,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "794:  if (unlikely(i->type & ITER_PIPE)) {",
          "795:   if (i->iov_offset && allocated(&i->pipe->bufs[i->idx]))",
          "796:    return size | i->iov_offset;",
          "797:   return size;",
          "798:  }",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "525:  if (!size)",
          "526:   return 0;",
          "528:  iterate_all_kinds(i, size, v,",
          "529:   (res |= (!res ? 0 : (unsigned long)v.iov_base) |",
          "530:    (size != v.iov_len ? size : 0), 0),",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "815:  if (unlikely(i->type & ITER_PIPE)) {",
          "816:   WARN_ON(1);",
          "817:   return ~0U;",
          "818:  }",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "537: }",
          "538: EXPORT_SYMBOL(iov_iter_gap_alignment);",
          "540: ssize_t iov_iter_get_pages(struct iov_iter *i,",
          "541:      struct page **pages, size_t maxsize, unsigned maxpages,",
          "542:      size_t *start)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "832: static inline size_t __pipe_get_pages(struct iov_iter *i,",
          "833:     size_t maxsize,",
          "834:     struct page **pages,",
          "835:     int idx,",
          "836:     size_t *start)",
          "837: {",
          "838:  struct pipe_inode_info *pipe = i->pipe;",
          "839:  size_t n = push_pipe(i, maxsize, &idx, start);",
          "840:  if (!n)",
          "841:   return -EFAULT;",
          "843:  maxsize = n;",
          "844:  n += *start;",
          "845:  while (n >= PAGE_SIZE) {",
          "846:   get_page(*pages++ = pipe->bufs[idx].page);",
          "847:   idx = next_idx(idx, pipe);",
          "848:   n -= PAGE_SIZE;",
          "849:  }",
          "851:  return maxsize;",
          "852: }",
          "854: static ssize_t pipe_get_pages(struct iov_iter *i,",
          "855:      struct page **pages, size_t maxsize, unsigned maxpages,",
          "856:      size_t *start)",
          "857: {",
          "858:  unsigned npages;",
          "859:  size_t capacity;",
          "860:  int idx;",
          "862:  if (!sanity(i))",
          "863:   return -EFAULT;",
          "865:  data_start(i, &idx, start);",
          "867:  npages = ((i->pipe->curbuf - idx - 1) & (i->pipe->buffers - 1)) + 1;",
          "868:  capacity = min(npages,maxpages) * PAGE_SIZE - *start;",
          "870:  return __pipe_get_pages(i, min(maxsize, capacity), pages, idx, start);",
          "871: }",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "547:  if (!maxsize)",
          "548:   return 0;",
          "550:  iterate_all_kinds(i, maxsize, v, ({",
          "551:   unsigned long addr = (unsigned long)v.iov_base;",
          "552:   size_t len = v.iov_len + (*start = addr & (PAGE_SIZE - 1));",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "883:  if (unlikely(i->type & ITER_PIPE))",
          "884:   return pipe_get_pages(i, pages, maxsize, maxpages, start);",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "582:  return p;",
          "583: }",
          "585: ssize_t iov_iter_get_pages_alloc(struct iov_iter *i,",
          "586:      struct page ***pages, size_t maxsize,",
          "587:      size_t *start)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "920: static ssize_t pipe_get_pages_alloc(struct iov_iter *i,",
          "921:      struct page ***pages, size_t maxsize,",
          "922:      size_t *start)",
          "923: {",
          "924:  struct page **p;",
          "925:  size_t n;",
          "926:  int idx;",
          "927:  int npages;",
          "929:  if (!sanity(i))",
          "930:   return -EFAULT;",
          "932:  data_start(i, &idx, start);",
          "934:  npages = ((i->pipe->curbuf - idx - 1) & (i->pipe->buffers - 1)) + 1;",
          "935:  n = npages * PAGE_SIZE - *start;",
          "936:  if (maxsize > n)",
          "937:   maxsize = n;",
          "938:  else",
          "939:   npages = DIV_ROUND_UP(maxsize + *start, PAGE_SIZE);",
          "940:  p = get_pages_array(npages);",
          "941:  if (!p)",
          "942:   return -ENOMEM;",
          "943:  n = __pipe_get_pages(i, maxsize, p, idx, start);",
          "944:  if (n > 0)",
          "946:  else",
          "947:   kvfree(p);",
          "948:  return n;",
          "949: }",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "594:  if (!maxsize)",
          "595:   return 0;",
          "597:  iterate_all_kinds(i, maxsize, v, ({",
          "598:   unsigned long addr = (unsigned long)v.iov_base;",
          "599:   size_t len = v.iov_len + (*start = addr & (PAGE_SIZE - 1));",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "963:  if (unlikely(i->type & ITER_PIPE))",
          "964:   return pipe_get_pages_alloc(i, pages, maxsize, start);",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "635:  __wsum sum, next;",
          "636:  size_t off = 0;",
          "637:  sum = *csum;",
          "638:  iterate_and_advance(i, bytes, v, ({",
          "639:   int err = 0;",
          "640:   next = csum_and_copy_from_user(v.iov_base,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1006:  if (unlikely(i->type & ITER_PIPE)) {",
          "1007:   WARN_ON(1);",
          "1008:   return 0;",
          "1009:  }",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "673:  __wsum sum, next;",
          "674:  size_t off = 0;",
          "675:  sum = *csum;",
          "676:  iterate_and_advance(i, bytes, v, ({",
          "677:   int err = 0;",
          "678:   next = csum_and_copy_to_user((from += v.iov_len) - v.iov_len,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1048:  if (unlikely(i->type & ITER_PIPE)) {",
          "1050:   return 0;",
          "1051:  }",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "712:  if (!size)",
          "713:   return 0;",
          "716:   unsigned long p = (unsigned long)v.iov_base;",
          "717:   npages += DIV_ROUND_UP(p + v.iov_len, PAGE_SIZE)",
          "718:    - p / PAGE_SIZE;",
          "",
          "[Removed Lines]",
          "715:  iterate_all_kinds(i, size, v, ({",
          "",
          "[Added Lines]",
          "1091:  if (unlikely(i->type & ITER_PIPE)) {",
          "1092:   struct pipe_inode_info *pipe = i->pipe;",
          "1093:   size_t off;",
          "1094:   int idx;",
          "1096:   if (!sanity(i))",
          "1097:    return 0;",
          "1099:   data_start(i, &idx, &off);",
          "1101:   npages = ((pipe->curbuf - idx - 1) & (pipe->buffers - 1)) + 1;",
          "1102:   if (npages >= maxpages)",
          "1103:    return maxpages;",
          "1104:  } else iterate_all_kinds(i, size, v, ({",
          "",
          "---------------",
          "--- Hunk 21 ---",
          "[Context before]",
          "737: const void *dup_iter(struct iov_iter *new, struct iov_iter *old, gfp_t flags)",
          "738: {",
          "740:  if (new->type & ITER_BVEC)",
          "741:   return new->bvec = kmemdup(new->bvec,",
          "742:         new->nr_segs * sizeof(struct bio_vec),",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1129:  if (unlikely(new->type & ITER_PIPE)) {",
          "1130:   WARN_ON(1);",
          "1131:   return NULL;",
          "1132:  }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "680bb946a1ae04fe0ff369a4965f76b48c07dc54",
      "candidate_info": {
        "commit_hash": "680bb946a1ae04fe0ff369a4965f76b48c07dc54",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/680bb946a1ae04fe0ff369a4965f76b48c07dc54",
        "files": [
          "lib/iov_iter.c"
        ],
        "message": "fix iov_iter_advance() for ITER_PIPE\n\niov_iter_advance() needs to decrement iter->count by the number of\nbytes we'd moved beyond.  Normal flavours do that, but ITER_PIPE\ndoesn't and ITER_PIPE generic_file_read_iter() for O_DIRECT files\nends up with a bogus fallback to page cache read, resulting in incorrect\nvalues for file offset and bytes read.\n\nSigned-off-by: Abhi Das <adas@redhat.com>\nSigned-off-by: Al Viro <viro@zeniv.linux.org.uk>",
        "before_after_code_files": [
          "lib/iov_iter.c||lib/iov_iter.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "lib/iov_iter.c||liiov_iter.c"
          ],
          "candidate": [
            "lib/iov_iter.c||lib/iov_iter.c"
          ]
        }
      },
      "candidate_diff": {
        "lib/iov_iter.c||lib/iov_iter.c": [
          "File: lib/iov_iter.c -> lib/iov_iter.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "683:  struct pipe_inode_info *pipe = i->pipe;",
          "684:  struct pipe_buffer *buf;",
          "685:  int idx = i->idx;",
          "688:  if (unlikely(i->count < size))",
          "689:   size = i->count;",
          "691:  if (size) {",
          "",
          "[Removed Lines]",
          "686:  size_t off = i->iov_offset;",
          "",
          "[Added Lines]",
          "686:  size_t off = i->iov_offset, orig_sz;",
          "690:  orig_sz = size;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "713:    pipe->nrbufs--;",
          "714:   }",
          "715:  }",
          "716: }",
          "718: void iov_iter_advance(struct iov_iter *i, size_t size)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "717:  i->count -= orig_sz;",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2015-0559",
  "cve_desc": "Multiple use-after-free vulnerabilities in epan/dissectors/packet-wccp.c in the WCCP dissector in Wireshark 1.10.x before 1.10.12 and 1.12.x before 1.12.3 allow remote attackers to cause a denial of service (application crash) via a crafted packet, related to the use of packet-scope memory instead of pinfo-scope memory.",
  "repo": "wireshark/wireshark",
  "patch_hash": "e843c6797db98bfceab382d5d7e76727e1014f5e",
  "patch_info": {
    "commit_hash": "e843c6797db98bfceab382d5d7e76727e1014f5e",
    "repo": "wireshark/wireshark",
    "commit_url": "https://github.com/wireshark/wireshark/commit/e843c6797db98bfceab382d5d7e76727e1014f5e",
    "files": [
      "epan/dissectors/packet-wccp.c"
    ],
    "message": "wccp: use pinfo-scope memory for addresses\n\nThey may be accessed during the print phase, at which point packet-scope memory\nhas already been freed.\n\nBug: 10720\nChange-Id: Ia2b160fd9de4ccaa3a4b8d9cb70fb9b32d4e08a0\nReviewed-on: https://code.wireshark.org/review/5496\nReviewed-by: Evan Huus <eapache@gmail.com>",
    "before_after_code_files": [
      "epan/dissectors/packet-wccp.c||epan/dissectors/packet-wccp.c"
    ]
  },
  "patch_diff": {
    "epan/dissectors/packet-wccp.c||epan/dissectors/packet-wccp.c": [
      "File: epan/dissectors/packet-wccp.c -> epan/dissectors/packet-wccp.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "508: static void",
      "509: find_wccp_address_table(tvbuff_t *tvb, int offset,",
      "511: {",
      "512:   guint16 type;",
      "513:   guint16 item_length;",
      "",
      "[Removed Lines]",
      "510:                         packet_info *pinfo _U_, proto_tree *wccp_tree _U_)",
      "",
      "[Added Lines]",
      "510:                         packet_info *pinfo, proto_tree *wccp_tree _U_)",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "550:     if (type == WCCP2r1_ADDRESS_TABLE)",
      "551:       {",
      "554:         return;",
      "555:       }",
      "",
      "[Removed Lines]",
      "552:         dissect_wccp2r1_address_table_info(tvb, offset+4, item_length, NULL, NULL);",
      "",
      "[Added Lines]",
      "552:         dissect_wccp2r1_address_table_info(tvb, offset+4, item_length, pinfo, NULL);",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "1900:   case 1:",
      "1901:     if (wccp_wccp_address_table.table_ipv4 == NULL)",
      "1902:       wccp_wccp_address_table.table_ipv4 = (guint32 *)",
      "1904:     if ((address_length != 4) && (pinfo && info_tree)) {",
      "1905:       expert_add_info_format(pinfo, tf, &ei_wccp_length_bad,",
      "1906:                              \"The Address length must be 4, but I found  %d for IPv4 addresses. Correcting this.\",",
      "",
      "[Removed Lines]",
      "1903:         wmem_alloc(wmem_packet_scope(), wccp_wccp_address_table.table_length * 4);",
      "",
      "[Added Lines]",
      "1903:         wmem_alloc(pinfo->pool, wccp_wccp_address_table.table_length * 4);",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "1911:   case 2:",
      "1912:     if (wccp_wccp_address_table.table_ipv6 == NULL)",
      "1913:       wccp_wccp_address_table.table_ipv6 = (struct e_in6_addr *)",
      "1915:     if ((address_length != 16) && (pinfo && info_tree)) {",
      "1916:       expert_add_info_format(pinfo, tf, &ei_wccp_length_bad,",
      "1917:                              \"The Address length must be 16, but I found %d for IPv6 addresses.  Correcting this\",",
      "",
      "[Removed Lines]",
      "1914:         wmem_alloc(wmem_packet_scope(), wccp_wccp_address_table.table_length * sizeof(struct e_in6_addr));",
      "",
      "[Added Lines]",
      "1914:         wmem_alloc(pinfo->pool, wccp_wccp_address_table.table_length * sizeof(struct e_in6_addr));",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "dea8d025f19481a31e70b810458a009981c13078",
      "candidate_info": {
        "commit_hash": "dea8d025f19481a31e70b810458a009981c13078",
        "repo": "wireshark/wireshark",
        "commit_url": "https://github.com/wireshark/wireshark/commit/dea8d025f19481a31e70b810458a009981c13078",
        "files": [
          "epan/dissectors/packet-wccp.c"
        ],
        "message": "wccp: use pinfo-scope memory for addresses\n\nThey may be accessed during the print phase, at which point packet-scope memory\nhas already been freed.\n\nBug: 10720\nChange-Id: Ia2b160fd9de4ccaa3a4b8d9cb70fb9b32d4e08a0\nReviewed-on: https://code.wireshark.org/review/5496\nReviewed-by: Evan Huus <eapache@gmail.com>\n(cherry picked from commit e843c6797db98bfceab382d5d7e76727e1014f5e)\nConflicts:\n\tepan/dissectors/packet-wccp.c\nReviewed-on: https://code.wireshark.org/review/6057\nReviewed-by: Pascal Quantin <pascal.quantin@gmail.com>",
        "before_after_code_files": [
          "epan/dissectors/packet-wccp.c||epan/dissectors/packet-wccp.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_cherry_pick": 1,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "epan/dissectors/packet-wccp.c||epan/dissectors/packet-wccp.c"
          ],
          "candidate": [
            "epan/dissectors/packet-wccp.c||epan/dissectors/packet-wccp.c"
          ]
        }
      },
      "candidate_diff": {
        "epan/dissectors/packet-wccp.c||epan/dissectors/packet-wccp.c": [
          "File: epan/dissectors/packet-wccp.c -> epan/dissectors/packet-wccp.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "507: static void",
          "508: find_wccp_address_table(tvbuff_t *tvb, int offset, guint16 length,",
          "510: {",
          "511:   guint16 type;",
          "512:   guint16 item_length;",
          "",
          "[Removed Lines]",
          "509:                         packet_info *pinfo _U_, proto_tree *wccp_tree _U_)",
          "",
          "[Added Lines]",
          "509:                         packet_info *pinfo, proto_tree *wccp_tree _U_)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "529:     if (type == WCCP2r1_ADDRESS_TABLE)",
          "530:       {",
          "533:         return;",
          "534:       }",
          "",
          "[Removed Lines]",
          "531:         dissect_wccp2r1_address_table_info(tvb, offset+4, item_length, NULL, NULL);",
          "",
          "[Added Lines]",
          "531:         dissect_wccp2r1_address_table_info(tvb, offset+4, item_length, pinfo, NULL);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1916:   case 1:",
          "1917:     if (wccp_wccp_address_table.table_ipv4 == NULL)",
          "1918:       wccp_wccp_address_table.table_ipv4 = (guint32 *)",
          "1920:     if ((address_length != 4) && (pinfo && info_tree)) {",
          "1921:       expert_add_info_format(pinfo, tf, &ei_wccp_length_bad,",
          "1922:                              \"The Address length must be 4, but I found  %d for IPv4 addresses. Correcting this.\",",
          "",
          "[Removed Lines]",
          "1919:         wmem_alloc(wmem_packet_scope(), wccp_wccp_address_table.table_length * 4);",
          "",
          "[Added Lines]",
          "1919:         wmem_alloc(pinfo->pool, wccp_wccp_address_table.table_length * 4);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1927:   case 2:",
          "1928:     if (wccp_wccp_address_table.table_ipv6 == NULL)",
          "1929:       wccp_wccp_address_table.table_ipv6 = (struct e_in6_addr *)",
          "1931:     if ((address_length != 16) && (pinfo && info_tree)) {",
          "1932:       expert_add_info_format(pinfo, tf, &ei_wccp_length_bad,",
          "1933:                              \"The Address length must be 16, but I found %d for IPv6 addresses.  Correcting this\",",
          "",
          "[Removed Lines]",
          "1930:         wmem_alloc(wmem_packet_scope(), wccp_wccp_address_table.table_length * sizeof(struct e_in6_addr));",
          "",
          "[Added Lines]",
          "1930:         wmem_alloc(pinfo->pool, wccp_wccp_address_table.table_length * sizeof(struct e_in6_addr));",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "6812cfb6d64c34293500782e8573ead43233d7b9",
      "candidate_info": {
        "commit_hash": "6812cfb6d64c34293500782e8573ead43233d7b9",
        "repo": "wireshark/wireshark",
        "commit_url": "https://github.com/wireshark/wireshark/commit/6812cfb6d64c34293500782e8573ead43233d7b9",
        "files": [
          "epan/dissectors/packet-wccp.c"
        ],
        "message": "wccp: use pinfo-scope memory for addresses\n\nThey may be accessed during the print phase, at which point packet-scope memory\nhas already been freed.\n\nBug: 10720\nChange-Id: Ia2b160fd9de4ccaa3a4b8d9cb70fb9b32d4e08a0\nReviewed-on: https://code.wireshark.org/review/5496\nReviewed-by: Evan Huus <eapache@gmail.com>\n(cherry picked from commit e843c6797db98bfceab382d5d7e76727e1014f5e)\nConflicts:\n\tepan/dissectors/packet-wccp.c\nReviewed-on: https://code.wireshark.org/review/6057\nReviewed-by: Pascal Quantin <pascal.quantin@gmail.com>\n(cherry picked from commit dea8d025f19481a31e70b810458a009981c13078)\nReviewed-on: https://code.wireshark.org/review/6425\nReviewed-by: Michael Mann <mmann78@netscape.net>",
        "before_after_code_files": [
          "epan/dissectors/packet-wccp.c||epan/dissectors/packet-wccp.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_cherry_pick": 1,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "epan/dissectors/packet-wccp.c||epan/dissectors/packet-wccp.c"
          ],
          "candidate": [
            "epan/dissectors/packet-wccp.c||epan/dissectors/packet-wccp.c"
          ]
        }
      },
      "candidate_diff": {
        "epan/dissectors/packet-wccp.c||epan/dissectors/packet-wccp.c": [
          "File: epan/dissectors/packet-wccp.c -> epan/dissectors/packet-wccp.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "507: static void",
          "508: find_wccp_address_table(tvbuff_t *tvb, int offset, guint16 length,",
          "510: {",
          "511:   guint16 type;",
          "512:   guint16 item_length;",
          "",
          "[Removed Lines]",
          "509:                         packet_info *pinfo _U_, proto_tree *wccp_tree _U_)",
          "",
          "[Added Lines]",
          "509:                         packet_info *pinfo, proto_tree *wccp_tree _U_)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "529:     if (type == WCCP2r1_ADDRESS_TABLE)",
          "530:       {",
          "533:         return;",
          "534:       }",
          "",
          "[Removed Lines]",
          "531:         dissect_wccp2r1_address_table_info(tvb, offset+4, item_length, NULL, NULL);",
          "",
          "[Added Lines]",
          "531:         dissect_wccp2r1_address_table_info(tvb, offset+4, item_length, pinfo, NULL);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1916:   case 1:",
          "1917:     if (wccp_wccp_address_table.table_ipv4 == NULL)",
          "1918:       wccp_wccp_address_table.table_ipv4 = (guint32 *)",
          "1920:     if ((address_length != 4) && (pinfo && info_tree)) {",
          "1921:       expert_add_info_format(pinfo, tf, &ei_wccp_length_bad,",
          "1922:                              \"The Address length must be 4, but I found  %d for IPv4 addresses. Correcting this.\",",
          "",
          "[Removed Lines]",
          "1919:         wmem_alloc(wmem_packet_scope(), wccp_wccp_address_table.table_length * 4);",
          "",
          "[Added Lines]",
          "1919:         wmem_alloc(pinfo->pool, wccp_wccp_address_table.table_length * 4);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1927:   case 2:",
          "1928:     if (wccp_wccp_address_table.table_ipv6 == NULL)",
          "1929:       wccp_wccp_address_table.table_ipv6 = (struct e_in6_addr *)",
          "1931:     if ((address_length != 16) && (pinfo && info_tree)) {",
          "1932:       expert_add_info_format(pinfo, tf, &ei_wccp_length_bad,",
          "1933:                              \"The Address length must be 16, but I found %d for IPv6 addresses.  Correcting this\",",
          "",
          "[Removed Lines]",
          "1930:         wmem_alloc(wmem_packet_scope(), wccp_wccp_address_table.table_length * sizeof(struct e_in6_addr));",
          "",
          "[Added Lines]",
          "1930:         wmem_alloc(pinfo->pool, wccp_wccp_address_table.table_length * sizeof(struct e_in6_addr));",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "524ed1df6e6126cd63ba419ccb82c83636d77ee4",
      "candidate_info": {
        "commit_hash": "524ed1df6e6126cd63ba419ccb82c83636d77ee4",
        "repo": "wireshark/wireshark",
        "commit_url": "https://github.com/wireshark/wireshark/commit/524ed1df6e6126cd63ba419ccb82c83636d77ee4",
        "files": [
          "epan/dissectors/packet-wccp.c"
        ],
        "message": "WCCP: Fix up storing and decoding of IP addresses.\n\nTry to decode as many IP addresses as we can, even if they don't fit in the\ntable we store them in.\n\nOnly add IP addresses in the table once.  We could theoretically reallocate\nthe table but the original code seems to assume the addresses should (in\nnon-fuzzed captures) only show up once per PDU.  This part of the change fixes\nthe fuzz failure.\n\nBug: 11153\nChange-Id: I56b9854ac1342080c9f32699a3f97750fa335696\nReviewed-on: https://code.wireshark.org/review/8748\nPetri-Dish: Jeff Morriss <jeff.morriss.ws@gmail.com>\nTested-by: Petri Dish Buildbot <buildbot-no-reply@wireshark.org>\nReviewed-by: Anders Broman <a.broman58@gmail.com>",
        "before_after_code_files": [
          "epan/dissectors/packet-wccp.c||epan/dissectors/packet-wccp.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "epan/dissectors/packet-wccp.c||epan/dissectors/packet-wccp.c"
          ],
          "candidate": [
            "epan/dissectors/packet-wccp.c||epan/dissectors/packet-wccp.c"
          ]
        }
      },
      "candidate_diff": {
        "epan/dissectors/packet-wccp.c||epan/dissectors/packet-wccp.c": [
          "File: epan/dissectors/packet-wccp.c -> epan/dissectors/packet-wccp.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1836:    once to get the tables, once to display them",
          "1838: static gint",
          "1841: {",
          "1842:   guint16 address_length;",
          "1843:   guint32 i;",
          "1849:   if (length < 2*4)",
          "1850:     return length - 2*4;",
          "1857:   EAT_AND_CHECK(2,2);",
          "1860:   proto_tree_add_item(info_tree, hf_address_table_address_length, tvb, offset, 2, ENC_BIG_ENDIAN);",
          "1861:   EAT_AND_CHECK(2,2);",
          "1864:   tf = proto_tree_add_item(info_tree, hf_address_table_length, tvb, offset, 4, ENC_BIG_ENDIAN);",
          "1865:   element_tree = proto_item_add_subtree(tf, ett_table_element);",
          "1867:   EAT(4);",
          "1920:     case 1:",
          "1922:       addr  =  tvb_ip_to_str(tvb, offset);",
          "1925:       break;",
          "1926:     case 2:",
          "1930:         tvb_get_ipv6(tvb, offset, &(wccp_wccp_address_table.table_ipv6[i]));",
          "1931:       break;",
          "1932:     default:",
          "1934:     };",
          "1936:     if (element_tree) {",
          "1940:     }",
          "1941:     EAT(address_length);",
          "1942:   }",
          "1943:   return length;",
          "1944: }",
          "",
          "[Removed Lines]",
          "1839: dissect_wccp2r1_address_table_info(tvbuff_t *tvb, int offset,",
          "1840:                                    int length, packet_info *pinfo, proto_tree *info_tree)",
          "1844:   proto_tree *element_tree=NULL;",
          "1845:   proto_item *tf=NULL;",
          "1847:   wccp_wccp_address_table.in_use = TRUE;",
          "1853:   wccp_wccp_address_table.family = tvb_get_ntohs(tvb,offset);",
          "1855:   proto_tree_add_item(info_tree, hf_address_table_family, tvb,",
          "1856:                         offset, 2, ENC_BIG_ENDIAN);",
          "1859:   address_length = tvb_get_ntohs(tvb,offset);",
          "1863:   wccp_wccp_address_table.table_length =  tvb_get_ntohl(tvb,offset);",
          "1870:   switch (wccp_wccp_address_table.family) {",
          "1871:   case 1:",
          "1872:     if (wccp_wccp_address_table.table_ipv4 == NULL)",
          "1873:       wccp_wccp_address_table.table_ipv4 = (guint32 *)",
          "1874:         wmem_alloc0(pinfo->pool, wccp_wccp_address_table.table_length * 4);",
          "1875:     if (address_length != 4) {",
          "1876:       expert_add_info_format(pinfo, tf, &ei_wccp_length_bad,",
          "1877:                              \"The Address length must be 4, but I found  %d for IPv4 addresses. Correcting this.\",",
          "1878:                              address_length);",
          "1879:       address_length = 4;",
          "1880:     }",
          "1881:     break;",
          "1882:   case 2:",
          "1883:     if (wccp_wccp_address_table.table_ipv6 == NULL)",
          "1884:       wccp_wccp_address_table.table_ipv6 = (struct e_in6_addr *)",
          "1885:         wmem_alloc0(pinfo->pool, wccp_wccp_address_table.table_length * sizeof(struct e_in6_addr));",
          "1886:     if (address_length != 16) {",
          "1887:       expert_add_info_format(pinfo, tf, &ei_wccp_length_bad,",
          "1888:                              \"The Address length must be 16, but I found %d for IPv6 addresses.  Correcting this\",",
          "1889:                              address_length);",
          "1890:       address_length=16;",
          "1891:     }",
          "1892:     break;",
          "1893:   default:",
          "1894:     expert_add_info_format(pinfo, tf, &ei_wccp_address_table_family_unknown,",
          "1895:                     \"Unknown address family: %d\", wccp_wccp_address_table.family);",
          "1896:   };",
          "1900:   for(i=0; i<wccp_wccp_address_table.table_length; i++) {",
          "1901:     const gchar* addr;",
          "1904:     if (length < address_length) {",
          "1905:       expert_add_info_format(pinfo, tf, &ei_wccp_length_bad, \"Ran out of space to decode\");",
          "1908:       wccp_wccp_address_table.in_use = FALSE;",
          "1909:       wccp_wccp_address_table.family = -1;",
          "1910:       wccp_wccp_address_table.version = -1;",
          "1911:       wccp_wccp_address_table.table_length = 0;",
          "1912:       wccp_wccp_address_table.table_ipv4 = (guint32 *) NULL;",
          "1913:       wccp_wccp_address_table.table_ipv6 = (struct e_in6_addr *)NULL;",
          "1916:       return length - address_length;",
          "1917:     }",
          "1919:     switch (wccp_wccp_address_table.family) {",
          "1923:       if (wccp_wccp_address_table.table_ipv4 != NULL)",
          "1924:         wccp_wccp_address_table.table_ipv4[i] = tvb_get_ntohl(tvb,offset);",
          "1928:       addr = tvb_ip6_to_str(tvb,offset);",
          "1929:       if (wccp_wccp_address_table.table_ipv6 != NULL)",
          "1933:       addr = wmem_strdup_printf(wmem_packet_scope(), \"unknown family\");",
          "1937:       proto_tree_add_string_format_value(element_tree, hf_address_table_element, tvb,",
          "1938:                                          offset, address_length, addr,",
          "1939:                                          \"%d: %s\", i+1, addr);",
          "",
          "[Added Lines]",
          "1839: dissect_wccp2r1_address_table_info(tvbuff_t *tvb, int offset, int length,",
          "1840:                                    packet_info *pinfo, proto_tree *info_tree)",
          "1844:   gint16 family;",
          "1845:   guint16 table_length;",
          "1846:   proto_tree *element_tree;",
          "1847:   proto_item *tf;",
          "1852:   family = tvb_get_ntohs(tvb, offset);",
          "1853:   proto_tree_add_item(info_tree, hf_address_table_family, tvb, offset, 2, ENC_BIG_ENDIAN);",
          "1856:   address_length = tvb_get_ntohs(tvb, offset);",
          "1860:   table_length =  tvb_get_ntohl(tvb, offset);",
          "1865:   if (wccp_wccp_address_table.in_use == FALSE) {",
          "1866:     wccp_wccp_address_table.in_use = TRUE;",
          "1867:     wccp_wccp_address_table.family = family;",
          "1868:     wccp_wccp_address_table.table_length =  table_length;",
          "1871:     switch (wccp_wccp_address_table.family) {",
          "1872:     case 1:",
          "1873:       if (wccp_wccp_address_table.table_ipv4 == NULL)",
          "1874:         wccp_wccp_address_table.table_ipv4 = (guint32 *)",
          "1875:           wmem_alloc0(pinfo->pool, wccp_wccp_address_table.table_length * 4);",
          "1876:       if (address_length != 4) {",
          "1877:         expert_add_info_format(pinfo, tf, &ei_wccp_length_bad,",
          "1878:                                \"The Address length must be 4, but I found %d for IPv4 addresses. Correcting this.\",",
          "1879:                                address_length);",
          "1880:         address_length = 4;",
          "1881:       }",
          "1882:       break;",
          "1883:     case 2:",
          "1884:       if (wccp_wccp_address_table.table_ipv6 == NULL)",
          "1885:         wccp_wccp_address_table.table_ipv6 = (struct e_in6_addr *)",
          "1886:           wmem_alloc0(pinfo->pool, wccp_wccp_address_table.table_length * sizeof(struct e_in6_addr));",
          "1887:       if (address_length != 16) {",
          "1888:         expert_add_info_format(pinfo, tf, &ei_wccp_length_bad,",
          "1889:                                \"The Address length must be 16, but I found %d for IPv6 addresses. Correcting this.\",",
          "1890:                                address_length);",
          "1891:         address_length = 16;",
          "1892:       }",
          "1893:       break;",
          "1894:     default:",
          "1895:       expert_add_info_format(pinfo, tf, &ei_wccp_address_table_family_unknown,",
          "1896:                       \"Unknown address family: %d\", wccp_wccp_address_table.family);",
          "1897:     };",
          "1898:   }",
          "1902:   for(i=0; i<table_length; i++) {",
          "1903:     const gchar *addr;",
          "1905:     switch (family) {",
          "1909:       if ((wccp_wccp_address_table.table_ipv4 != NULL) && ((address_length * i) < wccp_wccp_address_table.table_length))",
          "1910:         wccp_wccp_address_table.table_ipv4[i] = tvb_get_ntohl(tvb, offset);",
          "1914:       addr = tvb_ip6_to_str(tvb, offset);",
          "1915:       if ((wccp_wccp_address_table.table_ipv6 != NULL) && ((address_length * i) < wccp_wccp_address_table.table_length))",
          "1919:       addr = wmem_strdup_printf(wmem_packet_scope(), \"unknown family %d\", wccp_wccp_address_table.family);",
          "1923:       proto_item *pi;",
          "1925:       pi = proto_tree_add_string_format_value(element_tree, hf_address_table_element, tvb,",
          "1926:                                               offset, address_length, addr,",
          "1927:                                               \"%d: %s\", i+1, addr);",
          "1928:       if ((address_length * i) > wccp_wccp_address_table.table_length)",
          "1929:         expert_add_info_format(pinfo, pi, &ei_wccp_length_bad, \"Ran out of space to store address\");",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "a442a1c0e815fd61416cf408bd74d85a042ccc6a",
      "candidate_info": {
        "commit_hash": "a442a1c0e815fd61416cf408bd74d85a042ccc6a",
        "repo": "wireshark/wireshark",
        "commit_url": "https://github.com/wireshark/wireshark/commit/a442a1c0e815fd61416cf408bd74d85a042ccc6a",
        "files": [
          "epan/dissectors/packet-wccp.c"
        ],
        "message": "WCCP: initialize address table to 0\n\nIt prevents an uninitialized access later on if an exception is triggered before filling the table\n\nBug: 10806\nChange-Id: I8f75fb18cd8d033013c34093f9d6c8762f23452b\nReviewed-on: https://code.wireshark.org/review/6056\nReviewed-by: Pascal Quantin <pascal.quantin@gmail.com>",
        "before_after_code_files": [
          "epan/dissectors/packet-wccp.c||epan/dissectors/packet-wccp.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "epan/dissectors/packet-wccp.c||epan/dissectors/packet-wccp.c"
          ],
          "candidate": [
            "epan/dissectors/packet-wccp.c||epan/dissectors/packet-wccp.c"
          ]
        }
      },
      "candidate_diff": {
        "epan/dissectors/packet-wccp.c||epan/dissectors/packet-wccp.c": [
          "File: epan/dissectors/packet-wccp.c -> epan/dissectors/packet-wccp.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1891:   case 1:",
          "1892:     if (wccp_wccp_address_table.table_ipv4 == NULL)",
          "1893:       wccp_wccp_address_table.table_ipv4 = (guint32 *)",
          "1895:     if (address_length != 4) {",
          "1896:       expert_add_info_format(pinfo, tf, &ei_wccp_length_bad,",
          "1897:                              \"The Address length must be 4, but I found  %d for IPv4 addresses. Correcting this.\",",
          "",
          "[Removed Lines]",
          "1894:         wmem_alloc(pinfo->pool, wccp_wccp_address_table.table_length * 4);",
          "",
          "[Added Lines]",
          "1894:         wmem_alloc0(pinfo->pool, wccp_wccp_address_table.table_length * 4);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1902:   case 2:",
          "1903:     if (wccp_wccp_address_table.table_ipv6 == NULL)",
          "1904:       wccp_wccp_address_table.table_ipv6 = (struct e_in6_addr *)",
          "1906:     if (address_length != 16) {",
          "1907:       expert_add_info_format(pinfo, tf, &ei_wccp_length_bad,",
          "1908:                              \"The Address length must be 16, but I found %d for IPv6 addresses.  Correcting this\",",
          "",
          "[Removed Lines]",
          "1905:         wmem_alloc(pinfo->pool, wccp_wccp_address_table.table_length * sizeof(struct e_in6_addr));",
          "",
          "[Added Lines]",
          "1905:         wmem_alloc0(pinfo->pool, wccp_wccp_address_table.table_length * sizeof(struct e_in6_addr));",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "a159cedd5bc3a39c29f9a9952b5f202cb6565f0b",
      "candidate_info": {
        "commit_hash": "a159cedd5bc3a39c29f9a9952b5f202cb6565f0b",
        "repo": "wireshark/wireshark",
        "commit_url": "https://github.com/wireshark/wireshark/commit/a159cedd5bc3a39c29f9a9952b5f202cb6565f0b",
        "files": [
          "epan/dissectors/packet-wccp.c"
        ],
        "message": "WCCP: Remove uneeded check (pinfo & info_tree)\n\nRemove also some false positive Dereference of null pointer\n\nChange-Id: I09687993531827c6e4f5178f3414ddd9a2702038\nReviewed-on: https://code.wireshark.org/review/5506\nPetri-Dish: Alexis La Goutte <alexis.lagoutte@gmail.com>\nReviewed-by: Evan Huus <eapache@gmail.com>\nTested-by: Petri Dish Buildbot <buildbot-no-reply@wireshark.org>\nReviewed-by: Alexis La Goutte <alexis.lagoutte@gmail.com>",
        "before_after_code_files": [
          "epan/dissectors/packet-wccp.c||epan/dissectors/packet-wccp.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "epan/dissectors/packet-wccp.c||epan/dissectors/packet-wccp.c"
          ],
          "candidate": [
            "epan/dissectors/packet-wccp.c||epan/dissectors/packet-wccp.c"
          ]
        }
      },
      "candidate_diff": {
        "epan/dissectors/packet-wccp.c||epan/dissectors/packet-wccp.c": [
          "File: epan/dissectors/packet-wccp.c -> epan/dissectors/packet-wccp.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1871:   wccp_wccp_address_table.in_use = TRUE;",
          "1876:   if (length < 2*4)",
          "1877:     return length - 2*4;",
          "1880:   wccp_wccp_address_table.family = tvb_get_ntohs(tvb,offset);",
          "1883:                         offset, 2, ENC_BIG_ENDIAN);",
          "1884:   EAT_AND_CHECK(2,2);",
          "1886:   address_length = tvb_get_ntohs(tvb,offset);",
          "1889:   EAT_AND_CHECK(2,2);",
          "1891:   wccp_wccp_address_table.table_length =  tvb_get_ntohl(tvb,offset);",
          "1896:   EAT(4);",
          "",
          "[Removed Lines]",
          "1873:   if (info_tree)",
          "1874:     tf = proto_tree_get_parent(info_tree);",
          "1881:   if (pinfo && info_tree)",
          "1882:     proto_tree_add_item(info_tree, hf_address_table_family, tvb,",
          "1887:   if (info_tree)",
          "1888:     proto_tree_add_item(info_tree, hf_address_table_address_length, tvb, offset, 2, ENC_BIG_ENDIAN);",
          "1892:   if (pinfo && info_tree) {",
          "1893:     tf = proto_tree_add_item(info_tree, hf_address_table_length, tvb, offset, 4, ENC_BIG_ENDIAN);",
          "1894:     element_tree = proto_item_add_subtree(tf, ett_table_element);",
          "1895:   }",
          "",
          "[Added Lines]",
          "1879:   proto_tree_add_item(info_tree, hf_address_table_family, tvb,",
          "1884:   proto_tree_add_item(info_tree, hf_address_table_address_length, tvb, offset, 2, ENC_BIG_ENDIAN);",
          "1888:   tf = proto_tree_add_item(info_tree, hf_address_table_length, tvb, offset, 4, ENC_BIG_ENDIAN);",
          "1889:   element_tree = proto_item_add_subtree(tf, ett_table_element);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1901:     if (wccp_wccp_address_table.table_ipv4 == NULL)",
          "1902:       wccp_wccp_address_table.table_ipv4 = (guint32 *)",
          "1903:         wmem_alloc(pinfo->pool, wccp_wccp_address_table.table_length * 4);",
          "1905:       expert_add_info_format(pinfo, tf, &ei_wccp_length_bad,",
          "1906:                              \"The Address length must be 4, but I found  %d for IPv4 addresses. Correcting this.\",",
          "1907:                              address_length);",
          "",
          "[Removed Lines]",
          "1904:     if ((address_length != 4) && (pinfo && info_tree)) {",
          "",
          "[Added Lines]",
          "1899:     if (address_length != 4) {",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1912:     if (wccp_wccp_address_table.table_ipv6 == NULL)",
          "1913:       wccp_wccp_address_table.table_ipv6 = (struct e_in6_addr *)",
          "1914:         wmem_alloc(pinfo->pool, wccp_wccp_address_table.table_length * sizeof(struct e_in6_addr));",
          "1916:       expert_add_info_format(pinfo, tf, &ei_wccp_length_bad,",
          "1917:                              \"The Address length must be 16, but I found %d for IPv6 addresses.  Correcting this\",",
          "1918:                              address_length);",
          "",
          "[Removed Lines]",
          "1915:     if ((address_length != 16) && (pinfo && info_tree)) {",
          "",
          "[Added Lines]",
          "1910:     if (address_length != 16) {",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1920:     }",
          "1921:     break;",
          "1922:   default:",
          "1925:                     \"Unknown address family: %d\", wccp_wccp_address_table.family);",
          "1927:   };",
          "",
          "[Removed Lines]",
          "1923:     if (pinfo && info_tree) {",
          "1924:       expert_add_info_format(pinfo, tf, &ei_wccp_address_table_family_unknown,",
          "1926:     }",
          "",
          "[Added Lines]",
          "1918:     expert_add_info_format(pinfo, tf, &ei_wccp_address_table_family_unknown,",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1935:     if (length < address_length) {",
          "1940:       wccp_wccp_address_table.in_use = FALSE;",
          "",
          "[Removed Lines]",
          "1936:       if (pinfo && tf)",
          "1937:         expert_add_info_format(pinfo, tf, &ei_wccp_length_bad, \"Ran out of space to decode\");",
          "",
          "[Added Lines]",
          "1929:       expert_add_info_format(pinfo, tf, &ei_wccp_length_bad, \"Ran out of space to decode\");",
          "",
          "---------------"
        ]
      }
    }
  ]
}
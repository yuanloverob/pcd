{
  "cve_id": "CVE-2015-3906",
  "cve_desc": "The logcat_dump_text function in wiretap/logcat.c in the Android Logcat file parser in Wireshark 1.12.x before 1.12.5 does not properly handle a lack of \\0 termination, which allows remote attackers to cause a denial of service (out-of-bounds read and application crash) via a crafted message in a packet, a different vulnerability than CVE-2015-3815.",
  "repo": "wireshark/wireshark",
  "patch_hash": "b3b1f7c3aa2233a147294bad833b748d38fba84d",
  "patch_info": {
    "commit_hash": "b3b1f7c3aa2233a147294bad833b748d38fba84d",
    "repo": "wireshark/wireshark",
    "commit_url": "https://github.com/wireshark/wireshark/commit/b3b1f7c3aa2233a147294bad833b748d38fba84d",
    "files": [
      "wiretap/logcat.c"
    ],
    "message": "logcat: improve (crash) robustness, improve names\n\nThe logcat version detector would crash with ASAN enabled because it did\nnot validate the payload length and hence a payload length of 0 would\ntrigger out-of-bounds access. (This happened on non-logcat data.)\n\nThis patch tries to get rid of all magic numbers by using a structure,\nimproves the version detector to validate the payload length and\nprevents crashes due to missing nul-terminators in the input. Older\nAndroid kernels would create entries with __pad with random contents, so\nthat cannot be used to determine version for v1. Instead, use heuristics\non the priority, tag and maybe the msg field.\n\nFurthermore, Android is mostly (if not, always?) Little-Endian, so add\nconversions where necessary (just in case WS supports BE arches).\n\n\"microseconds\" has been renamed to \"milliseconds\" because that is what\nthey are, actually. A duplicate logcat_log loop has been refactored\nsuch that one loop is sufficient, instead of separate buffers for each\nlog part, a single one is now used. get_priority does not really need\na pointer, just make it accept a character.\n\nThe output has been validated against v1 and v2 logcat binary formats\nwith __pad (hdr_size) equal to 0, and on attachment 9906.\n\nChange-Id: I46c8813e76fe705b293ffdee85b4c1bfff7d8362\nReviewed-on: https://code.wireshark.org/review/2803\nReviewed-by: Michal Labedzki <michal.labedzki@tieto.com>\nTested-by: Michal Labedzki <michal.labedzki@tieto.com>",
    "before_after_code_files": [
      "wiretap/logcat.c||wiretap/logcat.c"
    ]
  },
  "patch_diff": {
    "wiretap/logcat.c||wiretap/logcat.c": [
      "File: wiretap/logcat.c -> wiretap/logcat.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "43:     enum dump_type_t type;",
      "44: };",
      "47:     static gchar priorities[] = \"??VDIWEFS\";",
      "50:         return '?';",
      "53: }",
      "55: static gchar *logcat_log(const struct dumper_t *dumper, guint32 seconds,",
      "57:         const gchar *log)",
      "58: {",
      "59:     gchar  time_buffer[15];",
      "",
      "[Removed Lines]",
      "46: static gchar get_priority(const guint8 *priority) {",
      "49:     if (*priority >= (guint8) sizeof(priorities))",
      "52:     return priorities[(int) *priority];",
      "56:         gint microseconds, gint pid, gint tid, gchar priority, const gchar *tag,",
      "",
      "[Added Lines]",
      "51: #define LOGGER_ENTRY_MAX_PAYLOAD 4076",
      "53: struct logger_entry {",
      "61: };",
      "63: struct logger_entry_v2 {",
      "70:     union {",
      "74:     };",
      "76: };",
      "79: static gchar get_priority(const guint8 priority) {",
      "82:     if (priority >= (guint8) sizeof(priorities))",
      "85:     return priorities[priority];",
      "89:         gint milliseconds, gint pid, gint tid, gchar priority, const gchar *tag,",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "80:             strftime(time_buffer, sizeof(time_buffer), \"%m-%d %H:%M:%S\",",
      "81:                     gmtime(&datetime));",
      "82:             return g_strdup_printf(\"%s.%03i %c/%-8s(%5i): %s\\n\",",
      "84:         case DUMP_THREADTIME:",
      "85:             strftime(time_buffer, sizeof(time_buffer), \"%m-%d %H:%M:%S\",",
      "86:                     gmtime(&datetime));",
      "87:             return g_strdup_printf(\"%s.%03i %5i %5i %c %-8s: %s\\n\",",
      "89:         case DUMP_LONG:",
      "90:             strftime(time_buffer, sizeof(time_buffer), \"%m-%d %H:%M:%S\",",
      "91:                     gmtime(&datetime));",
      "92:             return g_strdup_printf(\"[ %s.%03i %5i:0x%02x %c/%s ]\\n%s\\n\\n\",",
      "94:         default:",
      "95:             return NULL;",
      "96:     }",
      "",
      "[Removed Lines]",
      "83:                     time_buffer, microseconds, priority, tag, pid, log);",
      "88:                     time_buffer, microseconds, pid, tid, priority, tag, log);",
      "93:                     time_buffer, microseconds, pid, tid, priority, tag, log);",
      "",
      "[Added Lines]",
      "116:                     time_buffer, milliseconds, priority, tag, pid, log);",
      "121:                     time_buffer, milliseconds, pid, tid, priority, tag, log);",
      "126:                     time_buffer, milliseconds, pid, tid, priority, tag, log);",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "100: static gint detect_version(wtap *wth, int *err, gchar **err_info)",
      "101: {",
      "113:     bytes_read = file_read(&tmp, 2, wth->fh);",
      "114:     if (bytes_read != 2) {",
      "",
      "[Removed Lines]",
      "102:     gint     bytes_read;",
      "103:     guint16  payload_length;",
      "104:     guint16  try_header_size;",
      "105:     guint8  *buffer;",
      "106:     gint64   file_offset;",
      "107:     guint32  log_length;",
      "108:     guint32  tag_length;",
      "109:     guint16  tmp;",
      "111:     file_offset = file_tell(wth->fh);",
      "",
      "[Added Lines]",
      "135:     gint                     bytes_read;",
      "136:     guint16                  payload_length;",
      "137:     guint16                  hdr_size;",
      "138:     guint16                  read_sofar;",
      "139:     guint16                  entry_len;",
      "140:     gint                     version;",
      "141:     struct logger_entry     *log_entry;",
      "142:     struct logger_entry_v2  *log_entry_v2;",
      "143:     guint8                  *buffer;",
      "144:     guint16                  tmp;",
      "145:     guint8                  *msg_payload, *msg_part, *msg_end;",
      "146:     guint16                  msg_len;",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "127:         return -1;",
      "128:     }",
      "136:             if (*err == 0 && bytes_read != 0)",
      "140:         }",
      "159:         g_free(buffer);",
      "161:     }",
      "163:     g_free(buffer);",
      "165: }",
      "167: static gboolean logcat_read_packet(struct logcat_phdr *logcat, FILE_T fh,",
      "",
      "[Removed Lines]",
      "129:     try_header_size = pletoh16(&tmp);",
      "131:     buffer = (guint8 *) g_malloc(5 * 4 + payload_length);",
      "132:     bytes_read = file_read(buffer, 5 * 4 + payload_length, wth->fh);",
      "133:     if (bytes_read != 5 * 4 + payload_length) {",
      "134:         if (bytes_read != 4 * 4 + payload_length) {",
      "138:             g_free(buffer);",
      "139:             return -1;",
      "141:     }",
      "143:     if (try_header_size == 24) {",
      "144:         tag_length = (guint32)strlen(buffer + 5 * 4 + 1) + 1;",
      "145:         log_length = (guint32)strlen(buffer + 5 * 4 + 1 + tag_length) + 1;",
      "146:         if (payload_length == 1 + tag_length + log_length) {",
      "147:             g_free(buffer);",
      "148:             return 2;",
      "149:         }",
      "150:     }",
      "152:     tag_length = (guint32)strlen(buffer + 4 * 4 + 1) + 1;",
      "153:     log_length = (guint32)strlen(buffer + 4 * 4 + 1 + tag_length) + 1;",
      "154:     if (payload_length == 1 + tag_length + log_length) {",
      "155:         if (file_seek(wth->fh, file_offset + 4 * 4 + 1 + tag_length + log_length, SEEK_SET, err) == -1) {",
      "156:             g_free(buffer);",
      "157:             return -1;",
      "158:         }",
      "160:         return 1;",
      "164:     return 0;",
      "",
      "[Added Lines]",
      "166:     hdr_size = pletoh16(&tmp);",
      "167:     read_sofar = 4;",
      "170:     if (payload_length < 3)",
      "171:         return -1;",
      "173:     if (payload_length > LOGGER_ENTRY_MAX_PAYLOAD)",
      "174:         return -1;",
      "177:     buffer = (guint8 *) g_malloc(sizeof(*log_entry_v2) + payload_length);",
      "178:     log_entry_v2 = (struct logger_entry_v2 *) buffer;",
      "179:     log_entry = (struct logger_entry *) buffer;",
      "183:     for (version = 1; version <= 2; ++version) {",
      "184:         if (version == 1) {",
      "185:             msg_payload = log_entry->msg;",
      "186:             entry_len = sizeof(*log_entry) + payload_length;",
      "187:         } else if (version == 2) {",
      "189:             msg_payload = log_entry_v2->msg;",
      "190:             entry_len = sizeof(*log_entry_v2) + payload_length;",
      "191:             if (hdr_size != sizeof(*log_entry_v2))",
      "192:                 continue;",
      "193:         }",
      "195:         bytes_read = file_read(buffer + read_sofar, entry_len - read_sofar,",
      "196:                 wth->fh);",
      "197:         if (bytes_read != entry_len - read_sofar) {",
      "202:             version = -1;",
      "203:             break;",
      "205:         read_sofar += bytes_read;",
      "208:         if (get_priority(msg_payload[0]) == '?')",
      "209:             continue;",
      "212:         msg_part = (guint8 *) memchr(msg_payload, '\\0', payload_length - 1);",
      "213:         if (msg_part == NULL)",
      "214:             continue;",
      "217:         ++msg_part;",
      "218:         msg_len = payload_length - (msg_part - msg_payload);",
      "219:         msg_end = (guint8 *) memchr(msg_part, '\\0', msg_len);",
      "221:         if (msg_end && (msg_payload + payload_length - 1 != msg_end))",
      "222:             continue;",
      "225:         return version;",
      "229:     return -1;",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "172:     guint16              payload_length;",
      "173:     guint                tmp[2];",
      "174:     guint8              *pd;",
      "176:     bytes_read = file_read(&tmp, 2, fh);",
      "177:     if (bytes_read != 2) {",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "240:     struct logger_entry *log_entry;",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "183:     payload_length = pletoh16(tmp);",
      "185:     if (logcat->version == 1) {",
      "187:     } else if (logcat->version == 2) {",
      "189:     } else {",
      "190:         return FALSE;",
      "191:     }",
      "193:     buffer_assure_space(buf, packet_size);",
      "194:     pd = buffer_start_ptr(buf);",
      "197:     memcpy(pd, tmp, 2);",
      "",
      "[Removed Lines]",
      "186:         packet_size = 5 * 4 + payload_length;",
      "188:         packet_size = 6 * 4 + payload_length;",
      "",
      "[Added Lines]",
      "252:         packet_size = sizeof(struct logger_entry) + payload_length;",
      "254:         packet_size = sizeof(struct logger_entry_v2) + payload_length;",
      "261:     log_entry = (struct logger_entry *) pd;",
      "",
      "---------------",
      "--- Hunk 7 ---",
      "[Context before]",
      "208:     phdr->rec_type = REC_TYPE_PACKET;",
      "209:     phdr->presence_flags = WTAP_HAS_TS;",
      "212:     phdr->caplen = packet_size;",
      "213:     phdr->len = packet_size;",
      "",
      "[Removed Lines]",
      "210:     phdr->ts.secs = (time_t) pletoh32(pd + 12);",
      "211:     phdr->ts.nsecs = (int) pletoh32(pd + 16);",
      "",
      "[Added Lines]",
      "277:     phdr->ts.secs = (time_t) GINT32_FROM_LE(log_entry->sec);",
      "278:     phdr->ts.nsecs = GINT32_FROM_LE(log_entry->nsec);",
      "",
      "---------------",
      "--- Hunk 8 ---",
      "[Context before]",
      "340:     gchar                          *buf;",
      "341:     gint                            length;",
      "342:     gchar                           priority;",
      "343:     const gchar                    *tag;",
      "347:     gchar                          *log_part;",
      "352:     const union wtap_pseudo_header *pseudo_header = &phdr->pseudo_header;",
      "353:     const struct dumper_t          *dumper        = (const struct dumper_t *) wdh->priv;",
      "",
      "[Removed Lines]",
      "344:     const gint                     *pid;",
      "345:     const gint                     *tid;",
      "346:     const gchar                    *log;",
      "348:     const gchar                    *str_begin;",
      "349:     const gchar                    *str_end;",
      "350:     const guint32                  *datetime;",
      "351:     const guint32                  *nanoseconds;",
      "",
      "[Added Lines]",
      "410:     const struct logger_entry      *log_entry = (struct logger_entry *) pd;",
      "411:     const struct logger_entry_v2   *log_entry_v2 = (struct logger_entry_v2 *) pd;",
      "412:     gint                            payload_length;",
      "414:     gint32                          pid;",
      "415:     gint32                          tid;",
      "416:     gint32                          seconds;",
      "417:     gint32                          milliseconds;",
      "418:     const gchar                    *msg_begin;",
      "419:     gint                            msg_pre_skip;",
      "420:     gchar                          *log;",
      "422:     gchar                          *log_next;",
      "",
      "---------------",
      "--- Hunk 9 ---",
      "[Context before]",
      "358:         return FALSE;",
      "359:     }",
      "361:     if (pseudo_header->logcat.version == 1) {",
      "369:     } else if (pseudo_header->logcat.version == 2) {",
      "377:     } else {",
      "379:         return FALSE;",
      "380:     }",
      "401:         }",
      "413:                 priority, tag, log_part);",
      "414:         if (!buf) {",
      "416:             return FALSE;",
      "417:         }",
      "419:         length = (guint32)strlen(buf);",
      "421:         if (!wtap_dump_file_write(wdh, buf, length, err)) {",
      "423:             return FALSE;",
      "424:         }",
      "426:         wdh->bytes_dumped += length;",
      "430:     return TRUE;",
      "431: }",
      "",
      "[Removed Lines]",
      "362:         pid = (const gint *) (pd + 4);",
      "363:         tid = (const gint *) (pd + 2 * 4);",
      "364:         datetime = (const guint32 *) (pd + 3 * 4);",
      "365:         nanoseconds = (const guint32 *) (pd + 4 * 4);",
      "366:         priority = get_priority((const guint8 *) (pd + 5 * 4));",
      "367:         tag = (const gchar *) (pd + 5 * 4 + 1);",
      "368:         log = tag + strlen(tag) + 1;",
      "370:         pid = (const gint *) (pd + 4);",
      "371:         tid = (const gint *) (pd + 2 * 4);",
      "372:         datetime = (const guint32 *) (pd + 3 * 4);",
      "373:         nanoseconds = (const guint32 *) (pd + 4 * 4);",
      "374:         priority = get_priority((const guint8 *) (pd + 6 * 4));",
      "375:         tag = (const char *) (pd + 6 * 4 + 1);",
      "376:         log = tag + strlen(tag) + 1;",
      "382:     str_begin = str_end = log;",
      "383:     while (dumper->type != DUMP_LONG && (str_end = strchr(str_begin, '\\n'))) {",
      "384:         log_part = (gchar *) g_malloc(str_end - str_begin + 1);",
      "385:         g_strlcpy(log_part, str_begin, str_end - str_begin + 1);",
      "387:         str_begin = str_end + 1;",
      "389:         buf = logcat_log(dumper, *datetime, *nanoseconds / 1000000, *pid, *tid,",
      "390:                 priority, tag, log_part);",
      "391:         if (!buf) {",
      "392:             g_free(log_part);",
      "393:             return FALSE;",
      "394:         }",
      "395:         g_free(log_part);",
      "396:         length = (guint32)strlen(buf);",
      "398:         if (!wtap_dump_file_write(wdh, buf, length, err)) {",
      "399:             g_free(buf);",
      "400:             return FALSE;",
      "403:         wdh->bytes_dumped += length;",
      "405:         g_free(buf);",
      "406:     }",
      "408:     if (*str_begin != '\\0') {",
      "409:         log_part = (gchar *) g_malloc(strlen(str_begin) + 1);",
      "410:         g_strlcpy(log_part, str_begin, strlen(str_begin) + 1);",
      "412:         buf = logcat_log(dumper, *datetime, *nanoseconds / 1000000, *pid, *tid,",
      "415:             g_free(log_part);",
      "418:         g_free(log_part);",
      "422:             g_free(buf);",
      "427:         g_free(buf);",
      "428:     }",
      "",
      "[Added Lines]",
      "432:     payload_length = GINT32_FROM_LE(log_entry->len);",
      "433:     pid = GINT32_FROM_LE(log_entry->pid);",
      "434:     tid = GINT32_FROM_LE(log_entry->tid);",
      "435:     seconds = GINT32_FROM_LE(log_entry->sec);",
      "436:     milliseconds = GINT32_FROM_LE(log_entry->nsec) / 1000000;",
      "440:         priority = get_priority(log_entry->msg[0]);",
      "441:         tag = log_entry->msg + 1;",
      "442:         msg_pre_skip = 1 + strlen(tag) + 1;",
      "443:         msg_begin = log_entry->msg + msg_pre_skip;",
      "445:         priority = get_priority(log_entry_v2->msg[0]);",
      "446:         tag = log_entry_v2->msg + 1;",
      "447:         msg_pre_skip = 1 + strlen(tag) + 1;",
      "448:         msg_begin = log_entry_v2->msg + msg_pre_skip;",
      "455:     log = g_strndup(msg_begin, payload_length - msg_pre_skip);",
      "459:     log_next = log;",
      "460:     do {",
      "461:         log_part = log_next;",
      "462:         if (dumper->type == DUMP_LONG) {",
      "464:             log_next = NULL;",
      "465:         } else {",
      "467:             log_next = strchr(log_part, '\\n');",
      "468:             if (log_next != NULL) {",
      "470:                 ++log_next;",
      "472:                 if (*log_next == '\\0') {",
      "473:                     log_next = NULL;",
      "474:                 }",
      "475:             }",
      "478:         buf = logcat_log(dumper, seconds, milliseconds, pid, tid,",
      "481:             g_free(log);",
      "487:             g_free(log);",
      "492:     } while (log_next != NULL);",
      "494:     g_free(log);",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "22c2210cc254cc6251c3831cd2b58f1ffe6a0cf8",
      "candidate_info": {
        "commit_hash": "22c2210cc254cc6251c3831cd2b58f1ffe6a0cf8",
        "repo": "wireshark/wireshark",
        "commit_url": "https://github.com/wireshark/wireshark/commit/22c2210cc254cc6251c3831cd2b58f1ffe6a0cf8",
        "files": [
          "wiretap/logcat.c"
        ],
        "message": "logcat: improve (crash) robustness, improve names\n\nThe logcat version detector would crash with ASAN enabled because it did\nnot validate the payload length and hence a payload length of 0 would\ntrigger out-of-bounds access. (This happened on non-logcat data.)\n\nThis patch tries to get rid of all magic numbers by using a structure,\nimproves the version detector to validate the payload length and\nprevents crashes due to missing nul-terminators in the input. Older\nAndroid kernels would create entries with __pad with random contents, so\nthat cannot be used to determine version for v1. Instead, use heuristics\non the priority, tag and maybe the msg field.\n\nFurthermore, Android is mostly (if not, always?) Little-Endian, so add\nconversions where necessary (just in case WS supports BE arches).\n\n\"microseconds\" has been renamed to \"milliseconds\" because that is what\nthey are, actually. A duplicate logcat_log loop has been refactored\nsuch that one loop is sufficient, instead of separate buffers for each\nlog part, a single one is now used. get_priority does not really need\na pointer, just make it accept a character.\n\nThe output has been validated against v1 and v2 logcat binary formats\nwith __pad (hdr_size) equal to 0, and on attachment 9906.\n\nReviewed-on: https://code.wireshark.org/review/2803\nReviewed-by: Michal Labedzki <michal.labedzki@tieto.com>\nTested-by: Michal Labedzki <michal.labedzki@tieto.com>\n(cherry picked from commit b3b1f7c3aa2233a147294bad833b748d38fba84d)\n\nConflicts:\n\twiretap/logcat.c\n\nChange-Id: I33bb20b5f9a5e03a231121a784bfffdfba0aba98\nReviewed-on: https://code.wireshark.org/review/8346\nReviewed-by: Gerald Combs <gerald@wireshark.org>\n(cherry picked from commit afeff4f5d0c51d2394f7c0f00ae1c57ad8cd1ded)\nReviewed-on: https://code.wireshark.org/review/8641\nReviewed-by: Balint Reczey <balint@balintreczey.hu>",
        "before_after_code_files": [
          "wiretap/logcat.c||wiretap/logcat.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_cherry_pick": 1,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "wiretap/logcat.c||wiretap/logcat.c"
          ],
          "candidate": [
            "wiretap/logcat.c||wiretap/logcat.c"
          ]
        }
      },
      "candidate_diff": {
        "wiretap/logcat.c||wiretap/logcat.c": [
          "File: wiretap/logcat.c -> wiretap/logcat.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "43:     enum dump_type_t type;",
          "44: };",
          "47:     static gchar priorities[] = \"??VDIWEFS\";",
          "50:         return '?';",
          "53: }",
          "55: static gchar *logcat_log(const struct dumper_t *dumper, guint32 seconds,",
          "57:         const gchar *log)",
          "58: {",
          "59:     gchar  time_buffer[15];",
          "",
          "[Removed Lines]",
          "46: static gchar get_priority(const guint8 *priority) {",
          "49:     if (*priority >= (guint8) sizeof(priorities))",
          "52:     return priorities[(int) *priority];",
          "56:         gint microseconds, gint pid, gint tid, gchar priority, const gchar *tag,",
          "",
          "[Added Lines]",
          "51: #define LOGGER_ENTRY_MAX_PAYLOAD 4076",
          "53: struct logger_entry {",
          "61: };",
          "63: struct logger_entry_v2 {",
          "70:     union {",
          "74:     };",
          "76: };",
          "79: static gchar get_priority(const guint8 priority) {",
          "82:     if (priority >= (guint8) sizeof(priorities))",
          "85:     return priorities[priority];",
          "89:         gint milliseconds, gint pid, gint tid, gchar priority, const gchar *tag,",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "80:             strftime(time_buffer, sizeof(time_buffer), \"%m-%d %H:%M:%S\",",
          "81:                     gmtime(&datetime));",
          "82:             return g_strdup_printf(\"%s.%03i %c/%-8s(%5i): %s\\n\",",
          "84:         case DUMP_THREADTIME:",
          "85:             strftime(time_buffer, sizeof(time_buffer), \"%m-%d %H:%M:%S\",",
          "86:                     gmtime(&datetime));",
          "87:             return g_strdup_printf(\"%s.%03i %5i %5i %c %-8s: %s\\n\",",
          "89:         case DUMP_LONG:",
          "90:             strftime(time_buffer, sizeof(time_buffer), \"%m-%d %H:%M:%S\",",
          "91:                     gmtime(&datetime));",
          "92:             return g_strdup_printf(\"[ %s.%03i %5i:0x%02x %c/%s ]\\n%s\\n\\n\",",
          "94:         default:",
          "95:             return NULL;",
          "96:     }",
          "",
          "[Removed Lines]",
          "83:                     time_buffer, microseconds, priority, tag, pid, log);",
          "88:                     time_buffer, microseconds, pid, tid, priority, tag, log);",
          "93:                     time_buffer, microseconds, pid, tid, priority, tag, log);",
          "",
          "[Added Lines]",
          "116:                     time_buffer, milliseconds, priority, tag, pid, log);",
          "121:                     time_buffer, milliseconds, pid, tid, priority, tag, log);",
          "126:                     time_buffer, milliseconds, pid, tid, priority, tag, log);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "100: static gint detect_version(wtap *wth, int *err, gchar **err_info)",
          "101: {",
          "113:     bytes_read = file_read(&tmp, 2, wth->fh);",
          "114:     if (bytes_read != 2) {",
          "",
          "[Removed Lines]",
          "102:     gint     bytes_read;",
          "103:     guint16  payload_length;",
          "104:     guint16  try_header_size;",
          "105:     guint8  *buffer;",
          "106:     gint64   file_offset;",
          "107:     guint32  log_length;",
          "108:     guint32  tag_length;",
          "109:     guint16  tmp;",
          "111:     file_offset = file_tell(wth->fh);",
          "",
          "[Added Lines]",
          "135:     gint                     bytes_read;",
          "136:     guint16                  payload_length;",
          "137:     guint16                  hdr_size;",
          "138:     guint16                  read_sofar;",
          "139:     guint16                  entry_len;",
          "140:     gint                     version;",
          "141:     struct logger_entry     *log_entry;",
          "142:     struct logger_entry_v2  *log_entry_v2;",
          "143:     guint8                  *buffer;",
          "144:     guint16                  tmp;",
          "145:     guint8                  *msg_payload, *msg_part, *msg_end;",
          "146:     guint16                  msg_len;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "127:         return -1;",
          "128:     }",
          "136:             if (*err == 0 && bytes_read != 0)",
          "140:         }",
          "159:         g_free(buffer);",
          "161:     }",
          "163:     g_free(buffer);",
          "165: }",
          "167: static gboolean logcat_read_packet(struct logcat_phdr *logcat, FILE_T fh,",
          "",
          "[Removed Lines]",
          "129:     try_header_size = pletoh16(&tmp);",
          "131:     buffer = (guint8 *) g_malloc(5 * 4 + payload_length);",
          "132:     bytes_read = file_read(buffer, 5 * 4 + payload_length, wth->fh);",
          "133:     if (bytes_read != 5 * 4 + payload_length) {",
          "134:         if (bytes_read != 4 * 4 + payload_length) {",
          "138:             g_free(buffer);",
          "139:             return -1;",
          "141:     }",
          "143:     if (try_header_size == 24) {",
          "144:         tag_length = (guint32)strlen(buffer + 5 * 4 + 1) + 1;",
          "145:         log_length = (guint32)strlen(buffer + 5 * 4 + 1 + tag_length) + 1;",
          "146:         if (payload_length == 1 + tag_length + log_length) {",
          "147:             g_free(buffer);",
          "148:             return 2;",
          "149:         }",
          "150:     }",
          "152:     tag_length = (guint32)strlen(buffer + 4 * 4 + 1) + 1;",
          "153:     log_length = (guint32)strlen(buffer + 4 * 4 + 1 + tag_length) + 1;",
          "154:     if (payload_length == 1 + tag_length + log_length) {",
          "155:         if (file_seek(wth->fh, file_offset + 4 * 4 + 1 + tag_length + log_length, SEEK_SET, err) == -1) {",
          "156:             g_free(buffer);",
          "157:             return -1;",
          "158:         }",
          "160:         return 1;",
          "164:     return 0;",
          "",
          "[Added Lines]",
          "166:     hdr_size = pletoh16(&tmp);",
          "167:     read_sofar = 4;",
          "170:     if (payload_length < 3)",
          "171:         return -1;",
          "173:     if (payload_length > LOGGER_ENTRY_MAX_PAYLOAD)",
          "174:         return -1;",
          "177:     buffer = (guint8 *) g_malloc(sizeof(*log_entry_v2) + payload_length);",
          "178:     log_entry_v2 = (struct logger_entry_v2 *) buffer;",
          "179:     log_entry = (struct logger_entry *) buffer;",
          "183:     for (version = 1; version <= 2; ++version) {",
          "184:         if (version == 1) {",
          "185:             msg_payload = log_entry->msg;",
          "186:             entry_len = sizeof(*log_entry) + payload_length;",
          "187:         } else if (version == 2) {",
          "189:             msg_payload = log_entry_v2->msg;",
          "190:             entry_len = sizeof(*log_entry_v2) + payload_length;",
          "191:             if (hdr_size != sizeof(*log_entry_v2))",
          "192:                 continue;",
          "193:         }",
          "195:         bytes_read = file_read(buffer + read_sofar, entry_len - read_sofar,",
          "196:                 wth->fh);",
          "197:         if (bytes_read != entry_len - read_sofar) {",
          "202:             version = -1;",
          "203:             break;",
          "205:         read_sofar += bytes_read;",
          "208:         if (get_priority(msg_payload[0]) == '?')",
          "209:             continue;",
          "212:         msg_part = (guint8 *) memchr(msg_payload, '\\0', payload_length - 1);",
          "213:         if (msg_part == NULL)",
          "214:             continue;",
          "217:         ++msg_part;",
          "218:         msg_len = payload_length - (msg_part - msg_payload);",
          "219:         msg_end = (guint8 *) memchr(msg_part, '\\0', msg_len);",
          "221:         if (msg_end && (msg_payload + payload_length - 1 != msg_end))",
          "222:             continue;",
          "225:         return version;",
          "229:     return -1;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "172:     guint16              payload_length;",
          "173:     guint                tmp[2];",
          "174:     guint8              *pd;",
          "176:     bytes_read = file_read(&tmp, 2, fh);",
          "177:     if (bytes_read != 2) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "240:     struct logger_entry *log_entry;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "183:     payload_length = pletoh16(tmp);",
          "185:     if (logcat->version == 1) {",
          "187:     } else if (logcat->version == 2) {",
          "189:     } else {",
          "190:         return FALSE;",
          "191:     }",
          "193:     buffer_assure_space(buf, packet_size);",
          "194:     pd = buffer_start_ptr(buf);",
          "197:     memcpy(pd, tmp, 2);",
          "",
          "[Removed Lines]",
          "186:         packet_size = 5 * 4 + payload_length;",
          "188:         packet_size = 6 * 4 + payload_length;",
          "",
          "[Added Lines]",
          "252:         packet_size = sizeof(struct logger_entry) + payload_length;",
          "254:         packet_size = sizeof(struct logger_entry_v2) + payload_length;",
          "261:     log_entry = (struct logger_entry *) pd;",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "208:     phdr->rec_type = REC_TYPE_PACKET;",
          "209:     phdr->presence_flags = WTAP_HAS_TS;",
          "212:     phdr->caplen = packet_size;",
          "213:     phdr->len = packet_size;",
          "",
          "[Removed Lines]",
          "210:     phdr->ts.secs = (time_t) pletoh32(pd + 12);",
          "211:     phdr->ts.nsecs = (int) pletoh32(pd + 16);",
          "",
          "[Added Lines]",
          "277:     phdr->ts.secs = (time_t) GINT32_FROM_LE(log_entry->sec);",
          "278:     phdr->ts.nsecs = GINT32_FROM_LE(log_entry->nsec);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "340:     gchar                          *buf;",
          "341:     gint                            length;",
          "342:     gchar                           priority;",
          "343:     const gchar                    *tag;",
          "347:     gchar                          *log_part;",
          "352:     const union wtap_pseudo_header *pseudo_header = &phdr->pseudo_header;",
          "353:     const struct dumper_t          *dumper        = (const struct dumper_t *) wdh->priv;",
          "",
          "[Removed Lines]",
          "344:     const gint                     *pid;",
          "345:     const gint                     *tid;",
          "346:     const gchar                    *log;",
          "348:     const gchar                    *str_begin;",
          "349:     const gchar                    *str_end;",
          "350:     const guint32                  *datetime;",
          "351:     const guint32                  *nanoseconds;",
          "",
          "[Added Lines]",
          "410:     const struct logger_entry      *log_entry = (struct logger_entry *) pd;",
          "411:     const struct logger_entry_v2   *log_entry_v2 = (struct logger_entry_v2 *) pd;",
          "412:     gint                            payload_length;",
          "414:     gint32                          pid;",
          "415:     gint32                          tid;",
          "416:     gint32                          seconds;",
          "417:     gint32                          milliseconds;",
          "418:     const gchar                    *msg_begin;",
          "419:     gint                            msg_pre_skip;",
          "420:     gchar                          *log;",
          "422:     gchar                          *log_next;",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "358:         return FALSE;",
          "359:     }",
          "361:     if (pseudo_header->logcat.version == 1) {",
          "369:     } else if (pseudo_header->logcat.version == 2) {",
          "377:     } else {",
          "379:         return FALSE;",
          "380:     }",
          "401:         }",
          "414:                 priority, tag, log_part);",
          "415:         if (!buf) {",
          "417:             return FALSE;",
          "418:         }",
          "420:         length = (guint32)strlen(buf);",
          "422:         if (!wtap_dump_file_write(wdh, buf, length, err)) {",
          "424:             return FALSE;",
          "425:         }",
          "427:         wdh->bytes_dumped += length;",
          "431:     return TRUE;",
          "432: }",
          "",
          "[Removed Lines]",
          "362:         pid = (const gint *) (pd + 4);",
          "363:         tid = (const gint *) (pd + 2 * 4);",
          "364:         datetime = (const guint32 *) (pd + 3 * 4);",
          "365:         nanoseconds = (const guint32 *) (pd + 4 * 4);",
          "366:         priority = get_priority((const guint8 *) (pd + 5 * 4));",
          "367:         tag = (const gchar *) (pd + 5 * 4 + 1);",
          "368:         log = tag + strlen(tag) + 1;",
          "370:         pid = (const gint *) (pd + 4);",
          "371:         tid = (const gint *) (pd + 2 * 4);",
          "372:         datetime = (const guint32 *) (pd + 3 * 4);",
          "373:         nanoseconds = (const guint32 *) (pd + 4 * 4);",
          "374:         priority = get_priority((const guint8 *) (pd + 6 * 4));",
          "375:         tag = (const char *) (pd + 6 * 4 + 1);",
          "376:         log = tag + strlen(tag) + 1;",
          "382:     str_begin = str_end = log;",
          "383:     while (dumper->type != DUMP_LONG && (str_end = strchr(str_begin, '\\n'))) {",
          "384:         log_part = (gchar *) g_malloc(str_end - str_begin + 1);",
          "385:         g_strlcpy(log_part, str_begin, str_end - str_begin + 1);",
          "387:         str_begin = str_end + 1;",
          "389:         buf = logcat_log(dumper, *datetime, *nanoseconds / 1000000, *pid, *tid,",
          "390:                 priority, tag, log_part);",
          "391:         if (!buf) {",
          "392:             g_free(log_part);",
          "393:             return FALSE;",
          "394:         }",
          "395:         g_free(log_part);",
          "396:         length = (guint32)strlen(buf);",
          "398:         if (!wtap_dump_file_write(wdh, buf, length, err)) {",
          "399:             g_free(buf);",
          "400:             return FALSE;",
          "403:         wdh->bytes_dumped += length;",
          "405:         g_free(buf);",
          "406:     }",
          "408:     if (*str_begin != '\\0') {",
          "409:         log_part = (gchar *) g_malloc(strlen(str_begin) + 1);",
          "410:         g_strlcpy(log_part, str_begin, strlen(str_begin) + 1);",
          "413:         buf = logcat_log(dumper, *datetime, *nanoseconds / 1000000, *pid, *tid,",
          "416:             g_free(log_part);",
          "419:         g_free(log_part);",
          "423:             g_free(buf);",
          "428:         g_free(buf);",
          "429:     }",
          "",
          "[Added Lines]",
          "432:     payload_length = GINT32_FROM_LE(log_entry->len);",
          "433:     pid = GINT32_FROM_LE(log_entry->pid);",
          "434:     tid = GINT32_FROM_LE(log_entry->tid);",
          "435:     seconds = GINT32_FROM_LE(log_entry->sec);",
          "436:     milliseconds = GINT32_FROM_LE(log_entry->nsec) / 1000000;",
          "440:         priority = get_priority(log_entry->msg[0]);",
          "441:         tag = log_entry->msg + 1;",
          "442:         msg_pre_skip = 1 + strlen(tag) + 1;",
          "443:         msg_begin = log_entry->msg + msg_pre_skip;",
          "445:         priority = get_priority(log_entry_v2->msg[0]);",
          "446:         tag = log_entry_v2->msg + 1;",
          "447:         msg_pre_skip = 1 + strlen(tag) + 1;",
          "448:         msg_begin = log_entry_v2->msg + msg_pre_skip;",
          "455:     log = g_strndup(msg_begin, payload_length - msg_pre_skip);",
          "459:     log_next = log;",
          "460:     do {",
          "461:         log_part = log_next;",
          "462:         if (dumper->type == DUMP_LONG) {",
          "464:             log_next = NULL;",
          "465:         } else {",
          "467:             log_next = strchr(log_part, '\\n');",
          "468:             if (log_next != NULL) {",
          "470:                 ++log_next;",
          "472:                 if (*log_next == '\\0') {",
          "473:                     log_next = NULL;",
          "474:                 }",
          "475:             }",
          "478:         buf = logcat_log(dumper, seconds, milliseconds, pid, tid,",
          "481:             g_free(log);",
          "487:             g_free(log);",
          "492:     } while (log_next != NULL);",
          "494:     g_free(log);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "afeff4f5d0c51d2394f7c0f00ae1c57ad8cd1ded",
      "candidate_info": {
        "commit_hash": "afeff4f5d0c51d2394f7c0f00ae1c57ad8cd1ded",
        "repo": "wireshark/wireshark",
        "commit_url": "https://github.com/wireshark/wireshark/commit/afeff4f5d0c51d2394f7c0f00ae1c57ad8cd1ded",
        "files": [
          "wiretap/logcat.c"
        ],
        "message": "logcat: improve (crash) robustness, improve names\n\nThe logcat version detector would crash with ASAN enabled because it did\nnot validate the payload length and hence a payload length of 0 would\ntrigger out-of-bounds access. (This happened on non-logcat data.)\n\nThis patch tries to get rid of all magic numbers by using a structure,\nimproves the version detector to validate the payload length and\nprevents crashes due to missing nul-terminators in the input. Older\nAndroid kernels would create entries with __pad with random contents, so\nthat cannot be used to determine version for v1. Instead, use heuristics\non the priority, tag and maybe the msg field.\n\nFurthermore, Android is mostly (if not, always?) Little-Endian, so add\nconversions where necessary (just in case WS supports BE arches).\n\n\"microseconds\" has been renamed to \"milliseconds\" because that is what\nthey are, actually. A duplicate logcat_log loop has been refactored\nsuch that one loop is sufficient, instead of separate buffers for each\nlog part, a single one is now used. get_priority does not really need\na pointer, just make it accept a character.\n\nThe output has been validated against v1 and v2 logcat binary formats\nwith __pad (hdr_size) equal to 0, and on attachment 9906.\n\nReviewed-on: https://code.wireshark.org/review/2803\nReviewed-by: Michal Labedzki <michal.labedzki@tieto.com>\nTested-by: Michal Labedzki <michal.labedzki@tieto.com>\n(cherry picked from commit b3b1f7c3aa2233a147294bad833b748d38fba84d)\n\nConflicts:\n\twiretap/logcat.c\n\nChange-Id: I33bb20b5f9a5e03a231121a784bfffdfba0aba98\nReviewed-on: https://code.wireshark.org/review/8346\nReviewed-by: Gerald Combs <gerald@wireshark.org>",
        "before_after_code_files": [
          "wiretap/logcat.c||wiretap/logcat.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_cherry_pick": 1,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "wiretap/logcat.c||wiretap/logcat.c"
          ],
          "candidate": [
            "wiretap/logcat.c||wiretap/logcat.c"
          ]
        }
      },
      "candidate_diff": {
        "wiretap/logcat.c||wiretap/logcat.c": [
          "File: wiretap/logcat.c -> wiretap/logcat.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "43:     enum dump_type_t type;",
          "44: };",
          "47:     static gchar priorities[] = \"??VDIWEFS\";",
          "50:         return '?';",
          "53: }",
          "55: static gchar *logcat_log(const struct dumper_t *dumper, guint32 seconds,",
          "57:         const gchar *log)",
          "58: {",
          "59:     gchar  time_buffer[15];",
          "",
          "[Removed Lines]",
          "46: static gchar get_priority(const guint8 *priority) {",
          "49:     if (*priority >= (guint8) sizeof(priorities))",
          "52:     return priorities[(int) *priority];",
          "56:         gint microseconds, gint pid, gint tid, gchar priority, const gchar *tag,",
          "",
          "[Added Lines]",
          "51: #define LOGGER_ENTRY_MAX_PAYLOAD 4076",
          "53: struct logger_entry {",
          "61: };",
          "63: struct logger_entry_v2 {",
          "70:     union {",
          "74:     };",
          "76: };",
          "79: static gchar get_priority(const guint8 priority) {",
          "82:     if (priority >= (guint8) sizeof(priorities))",
          "85:     return priorities[priority];",
          "89:         gint milliseconds, gint pid, gint tid, gchar priority, const gchar *tag,",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "80:             strftime(time_buffer, sizeof(time_buffer), \"%m-%d %H:%M:%S\",",
          "81:                     gmtime(&datetime));",
          "82:             return g_strdup_printf(\"%s.%03i %c/%-8s(%5i): %s\\n\",",
          "84:         case DUMP_THREADTIME:",
          "85:             strftime(time_buffer, sizeof(time_buffer), \"%m-%d %H:%M:%S\",",
          "86:                     gmtime(&datetime));",
          "87:             return g_strdup_printf(\"%s.%03i %5i %5i %c %-8s: %s\\n\",",
          "89:         case DUMP_LONG:",
          "90:             strftime(time_buffer, sizeof(time_buffer), \"%m-%d %H:%M:%S\",",
          "91:                     gmtime(&datetime));",
          "92:             return g_strdup_printf(\"[ %s.%03i %5i:0x%02x %c/%s ]\\n%s\\n\\n\",",
          "94:         default:",
          "95:             return NULL;",
          "96:     }",
          "",
          "[Removed Lines]",
          "83:                     time_buffer, microseconds, priority, tag, pid, log);",
          "88:                     time_buffer, microseconds, pid, tid, priority, tag, log);",
          "93:                     time_buffer, microseconds, pid, tid, priority, tag, log);",
          "",
          "[Added Lines]",
          "116:                     time_buffer, milliseconds, priority, tag, pid, log);",
          "121:                     time_buffer, milliseconds, pid, tid, priority, tag, log);",
          "126:                     time_buffer, milliseconds, pid, tid, priority, tag, log);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "100: static gint detect_version(wtap *wth, int *err, gchar **err_info)",
          "101: {",
          "113:     bytes_read = file_read(&tmp, 2, wth->fh);",
          "114:     if (bytes_read != 2) {",
          "",
          "[Removed Lines]",
          "102:     gint     bytes_read;",
          "103:     guint16  payload_length;",
          "104:     guint16  try_header_size;",
          "105:     guint8  *buffer;",
          "106:     gint64   file_offset;",
          "107:     guint32  log_length;",
          "108:     guint32  tag_length;",
          "109:     guint16  tmp;",
          "111:     file_offset = file_tell(wth->fh);",
          "",
          "[Added Lines]",
          "135:     gint                     bytes_read;",
          "136:     guint16                  payload_length;",
          "137:     guint16                  hdr_size;",
          "138:     guint16                  read_sofar;",
          "139:     guint16                  entry_len;",
          "140:     gint                     version;",
          "141:     struct logger_entry     *log_entry;",
          "142:     struct logger_entry_v2  *log_entry_v2;",
          "143:     guint8                  *buffer;",
          "144:     guint16                  tmp;",
          "145:     guint8                  *msg_payload, *msg_part, *msg_end;",
          "146:     guint16                  msg_len;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "127:         return -1;",
          "128:     }",
          "136:             if (*err == 0 && bytes_read != 0)",
          "140:         }",
          "159:         g_free(buffer);",
          "161:     }",
          "163:     g_free(buffer);",
          "165: }",
          "167: static gboolean logcat_read_packet(struct logcat_phdr *logcat, FILE_T fh,",
          "",
          "[Removed Lines]",
          "129:     try_header_size = pletoh16(&tmp);",
          "131:     buffer = (guint8 *) g_malloc(5 * 4 + payload_length);",
          "132:     bytes_read = file_read(buffer, 5 * 4 + payload_length, wth->fh);",
          "133:     if (bytes_read != 5 * 4 + payload_length) {",
          "134:         if (bytes_read != 4 * 4 + payload_length) {",
          "138:             g_free(buffer);",
          "139:             return -1;",
          "141:     }",
          "143:     if (try_header_size == 24) {",
          "144:         tag_length = (guint32)strlen(buffer + 5 * 4 + 1) + 1;",
          "145:         log_length = (guint32)strlen(buffer + 5 * 4 + 1 + tag_length) + 1;",
          "146:         if (payload_length == 1 + tag_length + log_length) {",
          "147:             g_free(buffer);",
          "148:             return 2;",
          "149:         }",
          "150:     }",
          "152:     tag_length = (guint32)strlen(buffer + 4 * 4 + 1) + 1;",
          "153:     log_length = (guint32)strlen(buffer + 4 * 4 + 1 + tag_length) + 1;",
          "154:     if (payload_length == 1 + tag_length + log_length) {",
          "155:         if (file_seek(wth->fh, file_offset + 4 * 4 + 1 + tag_length + log_length, SEEK_SET, err) == -1) {",
          "156:             g_free(buffer);",
          "157:             return -1;",
          "158:         }",
          "160:         return 1;",
          "164:     return 0;",
          "",
          "[Added Lines]",
          "166:     hdr_size = pletoh16(&tmp);",
          "167:     read_sofar = 4;",
          "170:     if (payload_length < 3)",
          "171:         return -1;",
          "173:     if (payload_length > LOGGER_ENTRY_MAX_PAYLOAD)",
          "174:         return -1;",
          "177:     buffer = (guint8 *) g_malloc(sizeof(*log_entry_v2) + payload_length);",
          "178:     log_entry_v2 = (struct logger_entry_v2 *) buffer;",
          "179:     log_entry = (struct logger_entry *) buffer;",
          "183:     for (version = 1; version <= 2; ++version) {",
          "184:         if (version == 1) {",
          "185:             msg_payload = log_entry->msg;",
          "186:             entry_len = sizeof(*log_entry) + payload_length;",
          "187:         } else if (version == 2) {",
          "189:             msg_payload = log_entry_v2->msg;",
          "190:             entry_len = sizeof(*log_entry_v2) + payload_length;",
          "191:             if (hdr_size != sizeof(*log_entry_v2))",
          "192:                 continue;",
          "193:         }",
          "195:         bytes_read = file_read(buffer + read_sofar, entry_len - read_sofar,",
          "196:                 wth->fh);",
          "197:         if (bytes_read != entry_len - read_sofar) {",
          "202:             version = -1;",
          "203:             break;",
          "205:         read_sofar += bytes_read;",
          "208:         if (get_priority(msg_payload[0]) == '?')",
          "209:             continue;",
          "212:         msg_part = (guint8 *) memchr(msg_payload, '\\0', payload_length - 1);",
          "213:         if (msg_part == NULL)",
          "214:             continue;",
          "217:         ++msg_part;",
          "218:         msg_len = payload_length - (msg_part - msg_payload);",
          "219:         msg_end = (guint8 *) memchr(msg_part, '\\0', msg_len);",
          "221:         if (msg_end && (msg_payload + payload_length - 1 != msg_end))",
          "222:             continue;",
          "225:         return version;",
          "229:     return -1;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "172:     guint16              payload_length;",
          "173:     guint                tmp[2];",
          "174:     guint8              *pd;",
          "176:     bytes_read = file_read(&tmp, 2, fh);",
          "177:     if (bytes_read != 2) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "240:     struct logger_entry *log_entry;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "183:     payload_length = pletoh16(tmp);",
          "185:     if (logcat->version == 1) {",
          "187:     } else if (logcat->version == 2) {",
          "189:     } else {",
          "190:         return FALSE;",
          "191:     }",
          "193:     buffer_assure_space(buf, packet_size);",
          "194:     pd = buffer_start_ptr(buf);",
          "197:     memcpy(pd, tmp, 2);",
          "",
          "[Removed Lines]",
          "186:         packet_size = 5 * 4 + payload_length;",
          "188:         packet_size = 6 * 4 + payload_length;",
          "",
          "[Added Lines]",
          "252:         packet_size = sizeof(struct logger_entry) + payload_length;",
          "254:         packet_size = sizeof(struct logger_entry_v2) + payload_length;",
          "261:     log_entry = (struct logger_entry *) pd;",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "208:     phdr->rec_type = REC_TYPE_PACKET;",
          "209:     phdr->presence_flags = WTAP_HAS_TS;",
          "212:     phdr->caplen = packet_size;",
          "213:     phdr->len = packet_size;",
          "",
          "[Removed Lines]",
          "210:     phdr->ts.secs = (time_t) pletoh32(pd + 12);",
          "211:     phdr->ts.nsecs = (int) pletoh32(pd + 16);",
          "",
          "[Added Lines]",
          "277:     phdr->ts.secs = (time_t) GINT32_FROM_LE(log_entry->sec);",
          "278:     phdr->ts.nsecs = GINT32_FROM_LE(log_entry->nsec);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "340:     gchar                          *buf;",
          "341:     gint                            length;",
          "342:     gchar                           priority;",
          "343:     const gchar                    *tag;",
          "347:     gchar                          *log_part;",
          "352:     const union wtap_pseudo_header *pseudo_header = &phdr->pseudo_header;",
          "353:     const struct dumper_t          *dumper        = (const struct dumper_t *) wdh->priv;",
          "",
          "[Removed Lines]",
          "344:     const gint                     *pid;",
          "345:     const gint                     *tid;",
          "346:     const gchar                    *log;",
          "348:     const gchar                    *str_begin;",
          "349:     const gchar                    *str_end;",
          "350:     const guint32                  *datetime;",
          "351:     const guint32                  *nanoseconds;",
          "",
          "[Added Lines]",
          "410:     const struct logger_entry      *log_entry = (struct logger_entry *) pd;",
          "411:     const struct logger_entry_v2   *log_entry_v2 = (struct logger_entry_v2 *) pd;",
          "412:     gint                            payload_length;",
          "414:     gint32                          pid;",
          "415:     gint32                          tid;",
          "416:     gint32                          seconds;",
          "417:     gint32                          milliseconds;",
          "418:     const gchar                    *msg_begin;",
          "419:     gint                            msg_pre_skip;",
          "420:     gchar                          *log;",
          "422:     gchar                          *log_next;",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "358:         return FALSE;",
          "359:     }",
          "361:     if (pseudo_header->logcat.version == 1) {",
          "369:     } else if (pseudo_header->logcat.version == 2) {",
          "377:     } else {",
          "379:         return FALSE;",
          "380:     }",
          "401:         }",
          "414:                 priority, tag, log_part);",
          "415:         if (!buf) {",
          "417:             return FALSE;",
          "418:         }",
          "420:         length = (guint32)strlen(buf);",
          "422:         if (!wtap_dump_file_write(wdh, buf, length, err)) {",
          "424:             return FALSE;",
          "425:         }",
          "427:         wdh->bytes_dumped += length;",
          "431:     return TRUE;",
          "432: }",
          "",
          "[Removed Lines]",
          "362:         pid = (const gint *) (pd + 4);",
          "363:         tid = (const gint *) (pd + 2 * 4);",
          "364:         datetime = (const guint32 *) (pd + 3 * 4);",
          "365:         nanoseconds = (const guint32 *) (pd + 4 * 4);",
          "366:         priority = get_priority((const guint8 *) (pd + 5 * 4));",
          "367:         tag = (const gchar *) (pd + 5 * 4 + 1);",
          "368:         log = tag + strlen(tag) + 1;",
          "370:         pid = (const gint *) (pd + 4);",
          "371:         tid = (const gint *) (pd + 2 * 4);",
          "372:         datetime = (const guint32 *) (pd + 3 * 4);",
          "373:         nanoseconds = (const guint32 *) (pd + 4 * 4);",
          "374:         priority = get_priority((const guint8 *) (pd + 6 * 4));",
          "375:         tag = (const char *) (pd + 6 * 4 + 1);",
          "376:         log = tag + strlen(tag) + 1;",
          "382:     str_begin = str_end = log;",
          "383:     while (dumper->type != DUMP_LONG && (str_end = strchr(str_begin, '\\n'))) {",
          "384:         log_part = (gchar *) g_malloc(str_end - str_begin + 1);",
          "385:         g_strlcpy(log_part, str_begin, str_end - str_begin + 1);",
          "387:         str_begin = str_end + 1;",
          "389:         buf = logcat_log(dumper, *datetime, *nanoseconds / 1000000, *pid, *tid,",
          "390:                 priority, tag, log_part);",
          "391:         if (!buf) {",
          "392:             g_free(log_part);",
          "393:             return FALSE;",
          "394:         }",
          "395:         g_free(log_part);",
          "396:         length = (guint32)strlen(buf);",
          "398:         if (!wtap_dump_file_write(wdh, buf, length, err)) {",
          "399:             g_free(buf);",
          "400:             return FALSE;",
          "403:         wdh->bytes_dumped += length;",
          "405:         g_free(buf);",
          "406:     }",
          "408:     if (*str_begin != '\\0') {",
          "409:         log_part = (gchar *) g_malloc(strlen(str_begin) + 1);",
          "410:         g_strlcpy(log_part, str_begin, strlen(str_begin) + 1);",
          "413:         buf = logcat_log(dumper, *datetime, *nanoseconds / 1000000, *pid, *tid,",
          "416:             g_free(log_part);",
          "419:         g_free(log_part);",
          "423:             g_free(buf);",
          "428:         g_free(buf);",
          "429:     }",
          "",
          "[Added Lines]",
          "432:     payload_length = GINT32_FROM_LE(log_entry->len);",
          "433:     pid = GINT32_FROM_LE(log_entry->pid);",
          "434:     tid = GINT32_FROM_LE(log_entry->tid);",
          "435:     seconds = GINT32_FROM_LE(log_entry->sec);",
          "436:     milliseconds = GINT32_FROM_LE(log_entry->nsec) / 1000000;",
          "440:         priority = get_priority(log_entry->msg[0]);",
          "441:         tag = log_entry->msg + 1;",
          "442:         msg_pre_skip = 1 + strlen(tag) + 1;",
          "443:         msg_begin = log_entry->msg + msg_pre_skip;",
          "445:         priority = get_priority(log_entry_v2->msg[0]);",
          "446:         tag = log_entry_v2->msg + 1;",
          "447:         msg_pre_skip = 1 + strlen(tag) + 1;",
          "448:         msg_begin = log_entry_v2->msg + msg_pre_skip;",
          "455:     log = g_strndup(msg_begin, payload_length - msg_pre_skip);",
          "459:     log_next = log;",
          "460:     do {",
          "461:         log_part = log_next;",
          "462:         if (dumper->type == DUMP_LONG) {",
          "464:             log_next = NULL;",
          "465:         } else {",
          "467:             log_next = strchr(log_part, '\\n');",
          "468:             if (log_next != NULL) {",
          "470:                 ++log_next;",
          "472:                 if (*log_next == '\\0') {",
          "473:                     log_next = NULL;",
          "474:                 }",
          "475:             }",
          "478:         buf = logcat_log(dumper, seconds, milliseconds, pid, tid,",
          "481:             g_free(log);",
          "487:             g_free(log);",
          "492:     } while (log_next != NULL);",
          "494:     g_free(log);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "56a09d24dcdcaddae1cb67a18bbc2fd588c427ed",
      "candidate_info": {
        "commit_hash": "56a09d24dcdcaddae1cb67a18bbc2fd588c427ed",
        "repo": "wireshark/wireshark",
        "commit_url": "https://github.com/wireshark/wireshark/commit/56a09d24dcdcaddae1cb67a18bbc2fd588c427ed",
        "files": [
          "epan/dissectors/packet-btavdtp.c",
          "epan/dissectors/packet-btbnep.c",
          "epan/dissectors/packet-bthci_cmd.c",
          "epan/dissectors/packet-btsdp.c",
          "epan/dissectors/packet-logcat-text.c",
          "epan/dissectors/packet-usb-audio.c",
          "epan/dissectors/packet-usb-com.c",
          "epan/dissectors/packet-usb.c",
          "wiretap/file_access.c",
          "wiretap/file_wrappers.c",
          "wiretap/logcat.c",
          "wiretap/logcat.h",
          "wiretap/logcat_text.c",
          "wiretap/merge.c"
        ],
        "message": "Try to fix some buildbot warnings\n\nMost interesting are:\n warning: cannot optimize loop, the loop counter may overflow [-Wunsafe-loop-optimizations]\n warning: ISO C forbids zero-size array [-Wpedantic]\n warning: ISO C90 doesn't support unnamed structs/unions [-Wpedantic]\n warning: cast discards '__attribute__((const))' qualifier from pointer target type [-Wcast-qual\n warning: initializer element is not computable at load time [enabled by default]\n\nChange-Id: I5573c6bdca856a304877d9bef643f8c0fa93cdaf\nReviewed-on: https://code.wireshark.org/review/3174\nPetri-Dish: Michal Labedzki <michal.labedzki@tieto.com>\nTested-by: Petri Dish Buildbot <buildbot-no-reply@wireshark.org>\nReviewed-by: Michal Labedzki <michal.labedzki@tieto.com>",
        "before_after_code_files": [
          "epan/dissectors/packet-btavdtp.c||epan/dissectors/packet-btavdtp.c",
          "epan/dissectors/packet-btbnep.c||epan/dissectors/packet-btbnep.c",
          "epan/dissectors/packet-bthci_cmd.c||epan/dissectors/packet-bthci_cmd.c",
          "epan/dissectors/packet-btsdp.c||epan/dissectors/packet-btsdp.c",
          "epan/dissectors/packet-logcat-text.c||epan/dissectors/packet-logcat-text.c",
          "epan/dissectors/packet-usb-audio.c||epan/dissectors/packet-usb-audio.c",
          "epan/dissectors/packet-usb-com.c||epan/dissectors/packet-usb-com.c",
          "epan/dissectors/packet-usb.c||epan/dissectors/packet-usb.c",
          "wiretap/file_access.c||wiretap/file_access.c",
          "wiretap/file_wrappers.c||wiretap/file_wrappers.c",
          "wiretap/logcat.c||wiretap/logcat.c",
          "wiretap/logcat.h||wiretap/logcat.h",
          "wiretap/logcat_text.c||wiretap/logcat_text.c",
          "wiretap/merge.c||wiretap/merge.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "wiretap/logcat.c||wiretap/logcat.c"
          ],
          "candidate": [
            "wiretap/logcat.c||wiretap/logcat.c"
          ]
        }
      },
      "candidate_diff": {
        "epan/dissectors/packet-btavdtp.c||epan/dissectors/packet-btavdtp.c": [
          "File: epan/dissectors/packet-btavdtp.c -> epan/dissectors/packet-btavdtp.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1276:             col_add_fstr(pinfo->cinfo, COL_INFO, \"Unknown direction %d \",",
          "1277:                 direction);",
          "1278:             goto LABEL_data;",
          "1280:     }",
          "1282:     l2cap_data = (btl2cap_data_t *) data;",
          "",
          "[Removed Lines]",
          "1279:             break;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "epan/dissectors/packet-btbnep.c||epan/dissectors/packet-btbnep.c": [
          "File: epan/dissectors/packet-btbnep.c -> epan/dissectors/packet-btbnep.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "154:     guint16      uuid_dst;",
          "155:     guint16      uuid_src;",
          "156:     guint16      response_message;",
          "158:     guint        i_item;",
          "160:     proto_tree_add_item(tree, hf_btbnep_control_type, tvb, offset, 1, ENC_BIG_ENDIAN);",
          "",
          "[Removed Lines]",
          "157:     guint        list_length;",
          "",
          "[Added Lines]",
          "157:     guint16      list_length;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "203:             list_length = tvb_get_ntohs(tvb, offset);",
          "204:             offset += 2;",
          "207:                 proto_tree_add_item(tree, hf_btbnep_network_type_start, tvb, offset, 2, ENC_BIG_ENDIAN);",
          "208:                 offset += 2;",
          "",
          "[Removed Lines]",
          "206:             for (i_item = 0; i_item < list_length; i_item += 4) {",
          "",
          "[Added Lines]",
          "206:             for (i_item = 0; i_item + 4 > i_item && i_item < list_length; i_item += 4) {",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "223:             list_length = tvb_get_ntohs(tvb, offset);",
          "224:             offset += 2;",
          "227:                 proto_tree_add_item(tree, hf_btbnep_multicast_address_start, tvb, offset, 6, ENC_NA);",
          "228:                 offset += 6;",
          "",
          "[Removed Lines]",
          "226:             for (i_item = 0; i_item < list_length; i_item += 12) {",
          "",
          "[Added Lines]",
          "226:             for (i_item = 0; i_item + 12 > i_item && i_item < list_length; i_item += 12) {",
          "",
          "---------------"
        ],
        "epan/dissectors/packet-bthci_cmd.c||epan/dissectors/packet-bthci_cmd.c": [
          "File: epan/dissectors/packet-bthci_cmd.c -> epan/dissectors/packet-bthci_cmd.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "4988:     guint8       length;",
          "4989:     guint8       type;",
          "4990:     guint8       data_size;",
          "4992:     guint        i_uuid;",
          "4994:     data_size = tvb_length(tvb);",
          "",
          "[Removed Lines]",
          "4991:     gint         end_offset;",
          "",
          "[Added Lines]",
          "4991:     gint64       end_offset;",
          "",
          "---------------"
        ],
        "epan/dissectors/packet-btsdp.c||epan/dissectors/packet-btsdp.c": [
          "File: epan/dissectors/packet-btsdp.c -> epan/dissectors/packet-btsdp.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1237:     tid_request_t     *tid_request;",
          "1238:     continuation_state_data_t *continuation_state_data;",
          "1239:     wmem_tree_key_t    key[12];",
          "1240:     guint32            k_interface_id;",
          "1241:     guint32            k_adapter_id;",
          "1242:     guint32            k_chandle;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1240:     wmem_tree_t       *subtree;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1244:     guint32            k_tid;",
          "1245:     guint32            k_pdu_type;",
          "1246:     guint32            k_frame_number;",
          "1248:     guint32            interface_id;",
          "1249:     guint32            adapter_id;",
          "1250:     guint32            chandle;",
          "1251:     guint32            psm;",
          "1252:     guint32            frame_number;",
          "1255:     if (new_tvb) *new_tvb = NULL;",
          "",
          "[Removed Lines]",
          "1247:     guint8             *k_continuation_state;",
          "1253:     guint32           *continuation_state_array;",
          "",
          "[Added Lines]",
          "1248:     guint32           *k_continuation_state_array;",
          "1249:     guint8            *continuation_state;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1330:                     if (tid_request->continuation_state_length > 0) {",
          "1342:                         k_interface_id       = interface_id;",
          "1343:                         k_adapter_id         = adapter_id;",
          "",
          "[Removed Lines]",
          "1333:                         k_continuation_state = (guint8 *) wmem_alloc0(wmem_packet_scope(), 20);",
          "1334:                         k_continuation_state[0] = tid_request->continuation_state_length;",
          "1335:                         memcpy(&k_continuation_state[1], tid_request->continuation_state, tid_request->continuation_state_length);",
          "1336:                         continuation_state_array = (guint32 *) k_continuation_state;",
          "1338:                         k_continuation_state = (guint8 *) wmem_alloc0(wmem_packet_scope(), 20);",
          "1339:                         k_continuation_state[0] = tid_request->continuation_state_length;",
          "1340:                         memcpy(&k_continuation_state[1], tid_request->continuation_state, tid_request->continuation_state_length);",
          "",
          "[Added Lines]",
          "1334:                         k_continuation_state_array =  (guint32 *) wmem_alloc0(wmem_packet_scope(), 20);",
          "1335:                         continuation_state = (guint8 *) k_continuation_state_array;",
          "1336:                         continuation_state[0] = tid_request->continuation_state_length;",
          "1337:                         memcpy(&continuation_state[1], tid_request->continuation_state, tid_request->continuation_state_length);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1357:                         key[4].length = 1;",
          "1358:                         key[4].key    = &k_pdu_type;",
          "1359:                         key[5].length = 1;",
          "1361:                         key[6].length = 1;",
          "1363:                         key[7].length = 1;",
          "1365:                         key[8].length = 1;",
          "1367:                         key[9].length = 1;",
          "1369:                         key[10].length = 1;",
          "1370:                         key[10].key    = &k_frame_number;",
          "1371:                         key[11].length = 0;",
          "",
          "[Removed Lines]",
          "1360:                         key[5].key    = (guint32 *) &k_continuation_state[0];",
          "1362:                         key[6].key    = (guint32 *) &k_continuation_state[4];",
          "1364:                         key[7].key    = (guint32 *) &k_continuation_state[8];",
          "1366:                         key[8].key    = (guint32 *) &k_continuation_state[12];",
          "1368:                         key[9].key    = (guint32 *) &k_continuation_state[16];",
          "",
          "[Added Lines]",
          "1357:                         key[5].key    = &k_continuation_state_array[0];",
          "1359:                         key[6].key    = &k_continuation_state_array[1];",
          "1361:                         key[7].key    = &k_continuation_state_array[2];",
          "1363:                         key[8].key    = &k_continuation_state_array[3];",
          "1365:                         key[9].key    = &k_continuation_state_array[4];",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1377:                                 continuation_state_data->chandle == chandle &&",
          "1378:                                 continuation_state_data->psm == psm &&",
          "1379:                                 continuation_state_data->pdu_type == tid_request->pdu_type &&",
          "1385:                             tid_request->data = (guint8 *) wmem_alloc(wmem_file_scope(), continuation_state_data->data_length + attribute_list_byte_count);",
          "1386:                             tid_request->data_length = continuation_state_data->data_length + attribute_list_byte_count;",
          "1387:                             memcpy(tid_request->data, continuation_state_data->data, continuation_state_data->data_length);",
          "",
          "[Removed Lines]",
          "1380:                                 continuation_state_data->continuation_state[0] == continuation_state_array[0] &&",
          "1381:                                 continuation_state_data->continuation_state[1] == continuation_state_array[1] &&",
          "1382:                                 continuation_state_data->continuation_state[2] == continuation_state_array[2] &&",
          "1383:                                 continuation_state_data->continuation_state[3] == continuation_state_array[3] &&",
          "1384:                                 continuation_state_data->continuation_state[4] == continuation_state_array[4]) {",
          "",
          "[Added Lines]",
          "1377:                                 continuation_state_data->continuation_state[0] == k_continuation_state_array[0] &&",
          "1378:                                 continuation_state_data->continuation_state[1] == k_continuation_state_array[1] &&",
          "1379:                                 continuation_state_data->continuation_state[2] == k_continuation_state_array[2] &&",
          "1380:                                 continuation_state_data->continuation_state[3] == k_continuation_state_array[3] &&",
          "1381:                                 continuation_state_data->continuation_state[4] == k_continuation_state_array[4]) {",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1443:             }",
          "1444:         }",
          "1445:     } else {",
          "1447:         guint8       continuation_state_length;",
          "1448:         guint8      *packet_scope_string;",
          "1450:         continuation_state_length = tvb_get_guint8(tvb, offset);",
          "1451:         offset++;",
          "1454:         packet_scope_string = tvb_bytes_to_ep_str(tvb, offset, continuation_state_length);",
          "1457:         if (!pinfo->fd->flags.visited) {",
          "1458:             if (is_request) {",
          "",
          "[Removed Lines]",
          "1446:         guint8      *continuation_state;",
          "1453:         continuation_state = (guint8 *) wmem_alloc(wmem_file_scope(), continuation_state_length);",
          "1455:         memcpy(continuation_state, packet_scope_string, continuation_state_length);",
          "",
          "[Added Lines]",
          "1443:         guint8      *continuation_state_buffer;",
          "1450:         continuation_state_buffer = (guint8 *) wmem_alloc(wmem_file_scope(), continuation_state_length);",
          "1452:         memcpy(continuation_state_buffer, packet_scope_string, continuation_state_length);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "1480:                 tid_request->pdu_type = pdu_type;",
          "1483:                 tid_request->continuation_state_length = continuation_state_length;",
          "1485:                 wmem_tree_insert32_array(tid_requests, key, tid_request);",
          "",
          "[Removed Lines]",
          "1482:                 tid_request->continuation_state        = continuation_state;",
          "",
          "[Added Lines]",
          "1479:                 tid_request->continuation_state        = continuation_state_buffer;",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "1495:                     if (tid_request->continuation_state_length > 0) {",
          "1507:                         k_interface_id       = interface_id;",
          "1508:                         k_adapter_id         = adapter_id;",
          "1509:                         k_chandle            = chandle;",
          "1510:                         k_psm                = psm;",
          "1511:                         k_pdu_type           = tid_request->pdu_type;",
          "1514:                         key[0].length = 1;",
          "1515:                         key[0].key    = &k_interface_id;",
          "",
          "[Removed Lines]",
          "1498:                         k_continuation_state = (guint8 *) wmem_alloc0(wmem_packet_scope(), 20);",
          "1499:                         k_continuation_state[0] = tid_request->continuation_state_length;",
          "1500:                         memcpy(&k_continuation_state[1], tid_request->continuation_state, tid_request->continuation_state_length);",
          "1501:                         continuation_state_array = (guint32 *) k_continuation_state;",
          "1503:                         k_continuation_state = (guint8 *) wmem_alloc0(wmem_packet_scope(), 20);",
          "1504:                         k_continuation_state[0] = tid_request->continuation_state_length;",
          "1505:                         memcpy(&k_continuation_state[1], tid_request->continuation_state, tid_request->continuation_state_length);",
          "1512:                         k_frame_number       = frame_number;",
          "",
          "[Added Lines]",
          "1494:                         k_continuation_state_array =  (guint32 *) wmem_alloc0(wmem_packet_scope(), 20);",
          "1495:                         continuation_state = (guint8 *) k_continuation_state_array;",
          "1496:                         continuation_state[0] = tid_request->continuation_state_length;",
          "1497:                         memcpy(&continuation_state[1], tid_request->continuation_state, tid_request->continuation_state_length);",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "1522:                         key[4].length = 1;",
          "1523:                         key[4].key    = &k_pdu_type;",
          "1524:                         key[5].length = 1;",
          "1526:                         key[6].length = 1;",
          "1528:                         key[7].length = 1;",
          "1530:                         key[8].length = 1;",
          "1532:                         key[9].length = 1;",
          "1550:                             tid_request->data = (guint8 *) wmem_alloc(wmem_file_scope(), continuation_state_data->data_length + attribute_list_byte_count);",
          "1551:                             tid_request->data_length = continuation_state_data->data_length + attribute_list_byte_count;",
          "1552:                             memcpy(tid_request->data, continuation_state_data->data, continuation_state_data->data_length);",
          "",
          "[Removed Lines]",
          "1525:                         key[5].key    = (guint32 *) &k_continuation_state[0];",
          "1527:                         key[6].key    = (guint32 *) &k_continuation_state[4];",
          "1529:                         key[7].key    = (guint32 *) &k_continuation_state[8];",
          "1531:                         key[8].key    = (guint32 *) &k_continuation_state[12];",
          "1533:                         key[9].key    = (guint32 *) &k_continuation_state[16];",
          "1534:                         key[10].length = 1;",
          "1535:                         key[10].key    = &k_frame_number;",
          "1536:                         key[11].length = 0;",
          "1537:                         key[11].key    = NULL;",
          "1539:                         continuation_state_data = (continuation_state_data_t *) wmem_tree_lookup32_array_le(continuation_states, key);",
          "1540:                         if (continuation_state_data && continuation_state_data->interface_id == interface_id &&",
          "1541:                                 continuation_state_data->adapter_id == adapter_id &&",
          "1542:                                 continuation_state_data->chandle == chandle &&",
          "1543:                                 continuation_state_data->psm == psm &&",
          "1544:                                 continuation_state_data->pdu_type == tid_request->pdu_type &&",
          "1545:                                 continuation_state_data->continuation_state[0] == continuation_state_array[0] &&",
          "1546:                                 continuation_state_data->continuation_state[1] == continuation_state_array[1] &&",
          "1547:                                 continuation_state_data->continuation_state[2] == continuation_state_array[2] &&",
          "1548:                                 continuation_state_data->continuation_state[3] == continuation_state_array[3] &&",
          "1549:                                 continuation_state_data->continuation_state[4] == continuation_state_array[4]) {",
          "",
          "[Added Lines]",
          "1516:                         key[5].key    = &k_continuation_state_array[0];",
          "1518:                         key[6].key    = &k_continuation_state_array[1];",
          "1520:                         key[7].key    = &k_continuation_state_array[2];",
          "1522:                         key[8].key    = &k_continuation_state_array[3];",
          "1524:                         key[9].key     = &k_continuation_state_array[4];",
          "1525:                         key[10].length = 0;",
          "1526:                         key[10].key    = NULL;",
          "1528:                         subtree = (wmem_tree_t *) wmem_tree_lookup32_array(continuation_states, key);",
          "1529:                         continuation_state_data = (subtree) ? (continuation_state_data_t *) wmem_tree_lookup32_le(subtree, frame_number) : NULL;",
          "1530:                         if (continuation_state_data) {",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "1563:                     if (record_handle) *record_handle = tid_request->record_handle;",
          "1575:                     k_interface_id       = interface_id;",
          "1576:                     k_adapter_id         = adapter_id;",
          "",
          "[Removed Lines]",
          "1566:                     k_continuation_state = (guint8 *) wmem_alloc0(wmem_packet_scope(), 20);",
          "1567:                     k_continuation_state[0] = continuation_state_length;",
          "1568:                     memcpy(&k_continuation_state[1], continuation_state, continuation_state_length);",
          "1569:                     continuation_state_array = (guint32 *) k_continuation_state;",
          "1571:                     k_continuation_state = (guint8 *) wmem_alloc0(wmem_packet_scope(), 20);",
          "1572:                     k_continuation_state[0] = continuation_state_length;",
          "1573:                     memcpy(&k_continuation_state[1], continuation_state, continuation_state_length);",
          "",
          "[Added Lines]",
          "1547:                     k_continuation_state_array =  (guint32 *) wmem_alloc0(wmem_packet_scope(), 20);",
          "1548:                     continuation_state = (guint8 *) k_continuation_state_array;",
          "1549:                     continuation_state[0] = continuation_state_length;",
          "1550:                     memcpy(&continuation_state[1], continuation_state_buffer, continuation_state_length);",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "1590:                     key[4].length = 1;",
          "1591:                     key[4].key    = &k_pdu_type;",
          "1592:                     key[5].length = 1;",
          "1594:                     key[6].length = 1;",
          "1596:                     key[7].length = 1;",
          "1598:                     key[8].length = 1;",
          "1600:                     key[9].length = 1;",
          "1602:                     key[10].length = 1;",
          "1603:                     key[10].key    = &k_frame_number;",
          "1604:                     key[11].length = 0;",
          "",
          "[Removed Lines]",
          "1593:                     key[5].key    = (guint32 *) &k_continuation_state[0];",
          "1595:                     key[6].key    = (guint32 *) &k_continuation_state[4];",
          "1597:                     key[7].key    = (guint32 *) &k_continuation_state[8];",
          "1599:                     key[8].key    = (guint32 *) &k_continuation_state[12];",
          "1601:                     key[9].key    = (guint32 *) &k_continuation_state[16];",
          "",
          "[Added Lines]",
          "1570:                     key[5].key    = &k_continuation_state_array[0];",
          "1572:                     key[6].key    = &k_continuation_state_array[1];",
          "1574:                     key[7].key    = &k_continuation_state_array[2];",
          "1576:                     key[8].key    = &k_continuation_state_array[3];",
          "1578:                     key[9].key    = &k_continuation_state_array[4];",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "1610:                     continuation_state_data->chandle = chandle;",
          "1611:                     continuation_state_data->psm = psm;",
          "1612:                     continuation_state_data->pdu_type = pdu_type;",
          "1618:                     continuation_state_data->data = tid_request->data;",
          "1619:                     continuation_state_data->data_length = tid_request->data_length;",
          "",
          "[Removed Lines]",
          "1613:                     continuation_state_data->continuation_state[0] = continuation_state_array[0];",
          "1614:                     continuation_state_data->continuation_state[1] = continuation_state_array[1];",
          "1615:                     continuation_state_data->continuation_state[2] = continuation_state_array[2];",
          "1616:                     continuation_state_data->continuation_state[3] = continuation_state_array[3];",
          "1617:                     continuation_state_data->continuation_state[4] = continuation_state_array[4];",
          "",
          "[Added Lines]",
          "1590:                     continuation_state_data->continuation_state[0] = k_continuation_state_array[0];",
          "1591:                     continuation_state_data->continuation_state[1] = k_continuation_state_array[1];",
          "1592:                     continuation_state_data->continuation_state[2] = k_continuation_state_array[2];",
          "1593:                     continuation_state_data->continuation_state[3] = k_continuation_state_array[3];",
          "1594:                     continuation_state_data->continuation_state[4] = k_continuation_state_array[4];",
          "",
          "---------------"
        ],
        "epan/dissectors/packet-logcat-text.c||epan/dissectors/packet-logcat-text.c": [
          "File: epan/dissectors/packet-logcat-text.c -> epan/dissectors/packet-logcat-text.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "79:         proto_tree *maintree, gint start_offset, packet_info *pinfo);",
          "81: typedef struct {",
          "83:     const tGETTER *getters;",
          "84:     guint no_of_getters;",
          "85: } dissect_info_t;",
          "",
          "[Removed Lines]",
          "82:     GRegex *regex;",
          "",
          "[Added Lines]",
          "82:     GRegex **regex;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "207:     if (!g_regex_match(special_regex, frame, G_REGEX_MATCH_NOTEMPTY, NULL)) {",
          "210:         if (NULL == tokens) return 0;",
          "211:         if (g_strv_length(tokens) != dinfo->no_of_getters + 2) {",
          "212:             proto_tree_add_expert(maintree, pinfo, &ei_malformed_token, tvb, offset, -1);",
          "",
          "[Removed Lines]",
          "209:         tokens = g_regex_split(dinfo->regex, frame, G_REGEX_MATCH_NOTEMPTY);",
          "",
          "[Added Lines]",
          "209:         tokens = g_regex_split(*dinfo->regex, frame, G_REGEX_MATCH_NOTEMPTY);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "229: static int dissect_logcat_text_brief(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,",
          "230:         void *data _U_) {",
          "231:     static const tGETTER getters[] = { get_priority, get_tag, get_pid, get_log };",
          "234:     return dissect_logcat_text(tvb, tree, pinfo, &dinfo);",
          "235: }",
          "",
          "[Removed Lines]",
          "232:     dissect_info_t dinfo = { brief_regex, getters, array_length(getters) };",
          "",
          "[Added Lines]",
          "232:     dissect_info_t dinfo = { &brief_regex, getters, array_length(getters) };",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "237: static int dissect_logcat_text_tag(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,",
          "238:         void *data _U_) {",
          "239:     static const tGETTER getters[] = { get_priority, get_tag, get_log };",
          "242:     return dissect_logcat_text(tvb, tree, pinfo, &dinfo);",
          "243: }",
          "",
          "[Removed Lines]",
          "240:     dissect_info_t dinfo = { tag_regex, getters, array_length(getters) };",
          "",
          "[Added Lines]",
          "240:     dissect_info_t dinfo = { &tag_regex, getters, array_length(getters) };",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "245: static int dissect_logcat_text_process(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,",
          "246:         void *data _U_) {",
          "247:     static const tGETTER getters[] = { get_priority, get_pid, get_log };",
          "250:     SET_ADDRESS(&pinfo->dst, AT_STRINGZ, 0, \"\");",
          "251:     SET_ADDRESS(&pinfo->src, AT_STRINGZ, 0, \"\");",
          "",
          "[Removed Lines]",
          "248:     dissect_info_t dinfo = { process_regex, getters, array_length(getters) };",
          "",
          "[Added Lines]",
          "248:     dissect_info_t dinfo = { &process_regex, getters, array_length(getters) };",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "256: static int dissect_logcat_text_time(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,",
          "257:         void *data _U_) {",
          "258:     static const tGETTER getters[] = { get_time, get_priority, get_tag, get_pid, get_log };",
          "261:     return dissect_logcat_text(tvb, tree, pinfo, &dinfo);",
          "262: }",
          "",
          "[Removed Lines]",
          "259:     dissect_info_t dinfo = { time_regex, getters, array_length(getters) };",
          "",
          "[Added Lines]",
          "259:     dissect_info_t dinfo = { &time_regex, getters, array_length(getters) };",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "264: static int dissect_logcat_text_thread(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,",
          "265:         void *data _U_) {",
          "266:     static const tGETTER getters[] = { get_priority, get_pid, get_tid, get_log };",
          "269:     SET_ADDRESS(&pinfo->dst, AT_STRINGZ, 0, \"\");",
          "270:     SET_ADDRESS(&pinfo->src, AT_STRINGZ, 0, \"\");",
          "",
          "[Removed Lines]",
          "267:     dissect_info_t dinfo = { thread_regex, getters, array_length(getters) };",
          "",
          "[Added Lines]",
          "267:     dissect_info_t dinfo = { &thread_regex, getters, array_length(getters) };",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "275: static int dissect_logcat_text_threadtime(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,",
          "276:         void *data _U_) {",
          "277:     static const tGETTER getters[] = { get_time, get_pid, get_tid, get_priority, get_tag, get_log };",
          "280:     return dissect_logcat_text(tvb, tree, pinfo, &dinfo);",
          "281: }",
          "",
          "[Removed Lines]",
          "278:     dissect_info_t dinfo = { threadtime_regex, getters, array_length(getters) };",
          "",
          "[Added Lines]",
          "278:     dissect_info_t dinfo = { &threadtime_regex, getters, array_length(getters) };",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "283: static int dissect_logcat_text_long(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,",
          "284:         void *data _U_) {",
          "285:     static const tGETTER getters[] = { get_time, get_pid, get_tid, get_priority, get_tag, get_log };",
          "288:     return dissect_logcat_text(tvb, tree, pinfo, &dinfo);",
          "289: }",
          "",
          "[Removed Lines]",
          "286:     dissect_info_t dinfo = { long_regex, getters, array_length(getters) };",
          "",
          "[Added Lines]",
          "286:     dissect_info_t dinfo = { &long_regex, getters, array_length(getters) };",
          "",
          "---------------"
        ],
        "epan/dissectors/packet-usb-audio.c||epan/dissectors/packet-usb-audio.c": [
          "File: epan/dissectors/packet-usb-audio.c -> epan/dissectors/packet-usb-audio.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "490: {",
          "491:     usb_conv_info_t *usb_conv_info;",
          "492:     proto_tree      *tree   = NULL;",
          "494:     guint            length = tvb_length(tvb);",
          "",
          "[Removed Lines]",
          "493:     guint            offset;",
          "",
          "[Added Lines]",
          "493:     gint             offset;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "515:             offset = 0;",
          "516:             col_set_str(pinfo->cinfo, COL_INFO, \"USB-MIDI Event Packets\");",
          "519:             {",
          "520:                 dissect_usb_midi_event(tvb, pinfo, tree, parent_tree, offset);",
          "521:                 offset += 4;",
          "",
          "[Removed Lines]",
          "518:             while (offset < length)",
          "",
          "[Added Lines]",
          "518:             while (offset > 0 && (guint) offset < length)",
          "",
          "---------------"
        ],
        "epan/dissectors/packet-usb-com.c||epan/dissectors/packet-usb-com.c": [
          "File: epan/dissectors/packet-usb-com.c -> epan/dissectors/packet-usb-com.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "558:                 return call_dissector_only(mbim_bulk_handle, tvb, pinfo, tree, NULL);",
          "560:             default:",
          "561:                 break;",
          "562:         }",
          "",
          "[Removed Lines]",
          "559:                 break;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "epan/dissectors/packet-usb.c||epan/dissectors/packet-usb.c": [
          "File: epan/dissectors/packet-usb.c -> epan/dissectors/packet-usb.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1105:    clear_usb_conv_tmp_data() clears these components, it should be called",
          "1108: {",
          "",
          "[Removed Lines]",
          "1107: void clear_usb_conv_tmp_data(usb_conv_info_t *usb_conv_info)",
          "",
          "[Added Lines]",
          "1107: static void clear_usb_conv_tmp_data(usb_conv_info_t *usb_conv_info)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1598:     if (!usb_trans_info->u.get_descriptor.index) {",
          "1602:             proto_tree_add_item(tree, hf_usb_wLANGID, tvb, offset, 2, ENC_LITTLE_ENDIAN);",
          "1603:             offset+=2;",
          "",
          "[Removed Lines]",
          "1600:         while(len>(offset-old_offset)) {",
          "",
          "[Added Lines]",
          "1600:         while (offset >= old_offset && len > (offset - old_offset)) {",
          "",
          "---------------"
        ],
        "wiretap/file_access.c||wiretap/file_access.c": [
          "File: wiretap/file_access.c -> wiretap/file_access.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1517:  init_file_types_subtypes();",
          "1519:  if (!fi || !fi->name || !fi->short_name || subtype > wtap_num_file_types_subtypes) {",
          "",
          "[Removed Lines]",
          "1513: int",
          "1514: wtap_register_file_type_subtypes(const struct file_type_subtype_info* fi, const int subtype)",
          "1515: {",
          "1516:  struct file_type_subtype_info* finfo = NULL;",
          "",
          "[Added Lines]",
          "1513: int wtap_register_file_type_subtypes(const struct file_type_subtype_info* fi, const int subtype) {",
          "1514:  struct file_type_subtype_info* finfo;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1568:  if (subtype < 0 || subtype >= wtap_num_file_types_subtypes) {",
          "1569:   g_error(\"invalid file type to de-register\");",
          "",
          "[Removed Lines]",
          "1563: void",
          "1564: wtap_deregister_file_type_subtype(const int subtype)",
          "1565: {",
          "1566:  struct file_type_subtype_info* finfo = NULL;",
          "",
          "[Added Lines]",
          "1561: void wtap_deregister_file_type_subtype(const int subtype) {",
          "1562:  struct file_type_subtype_info* finfo;",
          "",
          "---------------"
        ],
        "wiretap/file_wrappers.c||wiretap/file_wrappers.c": [
          "File: wiretap/file_wrappers.c -> wiretap/file_wrappers.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1643:         strm->avail_in = len;",
          "1644:         strm->next_in = (Bytef *)buf;",
          "1645:         state->pos += len;",
          "1646:         if (gz_comp(state, Z_NO_FLUSH) == -1)",
          "1647:             return 0;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1644: #if ZLIB_CONST",
          "1645:         strm->next_in = (z_const Bytef *)buf;",
          "1646: #else",
          "1648: #endif",
          "",
          "---------------"
        ],
        "wiretap/logcat.c||wiretap/logcat.c": [
          "File: wiretap/logcat.c -> wiretap/logcat.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "50:     struct logger_entry_v2  *log_entry_v2;",
          "51:     guint8                  *buffer;",
          "52:     guint16                  tmp;",
          "54:     guint16                  msg_len;",
          "",
          "[Removed Lines]",
          "53:     guint8                  *msg_payload, *msg_part, *msg_end;",
          "",
          "[Added Lines]",
          "53:     guint8                  *msg_payload;",
          "54:     guint8                  *msg_part;",
          "55:     guint8                  *msg_end;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "91:     for (version = 1; version <= 2; ++version) {",
          "92:         if (version == 1) {",
          "94:             entry_len = sizeof(*log_entry) + payload_length;",
          "95:         } else if (version == 2) {",
          "98:             entry_len = sizeof(*log_entry_v2) + payload_length;",
          "99:             if (hdr_size != sizeof(*log_entry_v2))",
          "100:                 continue;",
          "",
          "[Removed Lines]",
          "93:             msg_payload = log_entry->msg;",
          "97:             msg_payload = log_entry_v2->msg;",
          "",
          "[Added Lines]",
          "95:             msg_payload = (guint8 *) (log_entry + 1);",
          "99:             msg_payload = (guint8 *) (log_entry_v2 + 1);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "137: }",
          "139: gint logcat_exported_pdu_length(const guint8 *pd) {",
          "146:     while(GINT16_FROM_BE(*tag)) {",
          "148:         length += 2 + 2 + GINT16_FROM_BE(*tag_length);",
          "150:         pd += 2 + 2 + GINT16_FROM_BE(*tag_length);",
          "152:     }",
          "154:     length += 2 + 2;",
          "",
          "[Removed Lines]",
          "140:     guint16 *tag;",
          "141:     guint16 *tag_length;",
          "142:     gint     length = 0;",
          "144:     tag = (guint16 *) pd;",
          "147:         tag_length = (guint16 *) (pd + 2);",
          "151:         tag = (guint16 *) pd;",
          "",
          "[Added Lines]",
          "142:     const guint16  *tag;",
          "143:     const guint16  *tag_length;",
          "144:     gint            length = 0;",
          "146:     tag = (const guint16 *) pd;",
          "149:         tag_length = (const guint16 *) (pd + 2);",
          "153:         tag = (const guint16 *) pd;",
          "",
          "---------------"
        ],
        "wiretap/logcat.h||wiretap/logcat.h": [
          "File: wiretap/logcat.h -> wiretap/logcat.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "58: };",
          "60: int      logcat_open(wtap *wth, int *err, gchar **err_info);",
          "",
          "[Removed Lines]",
          "56:     };",
          "",
          "[Added Lines]",
          "56:     } id;",
          "",
          "---------------"
        ],
        "wiretap/logcat_text.c||wiretap/logcat_text.c": [
          "File: wiretap/logcat_text.c -> wiretap/logcat_text.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "57: static gint buffered_detect_version(const guint8 *pd)",
          "58: {",
          "61:     gint                     version;",
          "63:     guint8                  *msg_part;",
          "64:     guint8                  *msg_end;",
          "65:     guint16                  msg_len;",
          "71:     if (log_entry->len < 3)",
          "",
          "[Removed Lines]",
          "59:     struct logger_entry     *log_entry;",
          "60:     struct logger_entry_v2  *log_entry_v2;",
          "62:     guint8                  *msg_payload = NULL;",
          "67:     log_entry_v2 = (struct logger_entry_v2 *) pd;",
          "68:     log_entry = (struct logger_entry *) pd;",
          "",
          "[Added Lines]",
          "59:     const struct logger_entry     *log_entry;",
          "60:     const struct logger_entry_v2  *log_entry_v2;",
          "62:     const guint8            *msg_payload = NULL;",
          "67:     log_entry_v2 = (const struct logger_entry_v2 *) pd;",
          "68:     log_entry = (const struct logger_entry *) pd;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "80:     for (version = 1; version <= 2; ++version) {",
          "81:         if (version == 1) {",
          "83:         } else if (version == 2) {",
          "86:             if (log_entry_v2->hdr_size != sizeof(*log_entry_v2))",
          "87:                 continue;",
          "88:         }",
          "",
          "[Removed Lines]",
          "82:             msg_payload = log_entry->msg;",
          "85:             msg_payload = log_entry_v2->msg;",
          "",
          "[Added Lines]",
          "82:             msg_payload = (const guint8 *) (log_entry + 1);",
          "85:             msg_payload = (const guint8 *) (log_entry_v2 + 1);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "427:     gint32                          tid;",
          "428:     gint32                          seconds;",
          "429:     gint32                          milliseconds;",
          "430:     const gchar                    *msg_begin;",
          "431:     gint                            msg_pre_skip;",
          "432:     gchar                          *log;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "430:     const guint8                   *msg_payload = NULL;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "458:             logcat_version = pseudo_header->logcat.version;",
          "459:         }",
          "464:         payload_length = GINT32_FROM_LE(log_entry->len);",
          "465:         pid = GINT32_FROM_LE(log_entry->pid);",
          "",
          "[Removed Lines]",
          "461:         log_entry = (struct logger_entry *) pd;",
          "462:         log_entry_v2 = (struct logger_entry_v2 *) pd;",
          "",
          "[Added Lines]",
          "462:         log_entry = (const struct logger_entry *) pd;",
          "463:         log_entry_v2 = (const struct logger_entry_v2 *) pd;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "471:         if (logcat_version == 1) {",
          "474:             msg_pre_skip = 1 + (gint) strlen(tag) + 1;",
          "476:         } else if (logcat_version == 2) {",
          "479:             msg_pre_skip = 1 + (gint) strlen(tag) + 1;",
          "481:         } else {",
          "483:             return FALSE;",
          "",
          "[Removed Lines]",
          "472:             priority = get_priority(log_entry->msg[0]);",
          "473:             tag = log_entry->msg + 1;",
          "475:             msg_begin = log_entry->msg + msg_pre_skip;",
          "477:             priority = get_priority(log_entry_v2->msg[0]);",
          "478:             tag = log_entry_v2->msg + 1;",
          "480:             msg_begin = log_entry_v2->msg + msg_pre_skip;",
          "",
          "[Added Lines]",
          "473:             msg_payload = (const guint8 *) (log_entry + 1);",
          "475:             priority = get_priority(msg_payload[0]);",
          "476:             tag = msg_payload + 1;",
          "478:             msg_begin = msg_payload + msg_pre_skip;",
          "480:             msg_payload = (const guint8 *) (log_entry_v2 + 1);",
          "482:             priority = get_priority(msg_payload[0]);",
          "483:             tag = msg_payload + 1;",
          "485:             msg_begin = msg_payload + msg_pre_skip;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "533:     case WTAP_ENCAP_LOGCAT_THREADTIME:",
          "534:     case WTAP_ENCAP_LOGCAT_LONG:",
          "535:         if (dumper->type == wdh->encap) {",
          "537:                 return FALSE;",
          "538:             }",
          "539:         } else {",
          "",
          "[Removed Lines]",
          "536:             if (!wtap_dump_file_write(wdh, (gchar*) pd, phdr->caplen, err)) {",
          "",
          "[Added Lines]",
          "541:             if (!wtap_dump_file_write(wdh, (const gchar*) pd, phdr->caplen, err)) {",
          "",
          "---------------"
        ],
        "wiretap/merge.c||wiretap/merge.c": [
          "File: wiretap/merge.c -> wiretap/merge.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "50:                     merge_in_file_t **in_files, int *err, gchar **err_info,",
          "51:                     int *err_fileno)",
          "52: {",
          "54:   size_t files_size = in_file_count * sizeof(merge_in_file_t);",
          "55:   merge_in_file_t *files;",
          "56:   gint64 size;",
          "",
          "[Removed Lines]",
          "53:   int i, j;",
          "",
          "[Added Lines]",
          "53:   gint i;",
          "54:   gint j;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "73:     }",
          "74:     size = wtap_file_size(files[i].wth, err);",
          "75:     if (size == -1) {",
          "77:         wtap_close(files[j].wth);",
          "79:       return FALSE;",
          "",
          "[Removed Lines]",
          "76:       for (j = 0; j <= i; j++)",
          "",
          "[Added Lines]",
          "77:       for (j = 0; j + 1 > j && j <= i; j++)",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "1275d05913e7ad40208fd34746748ff9ac3324b3",
      "candidate_info": {
        "commit_hash": "1275d05913e7ad40208fd34746748ff9ac3324b3",
        "repo": "wireshark/wireshark",
        "commit_url": "https://github.com/wireshark/wireshark/commit/1275d05913e7ad40208fd34746748ff9ac3324b3",
        "files": [
          "wiretap/logcat.c",
          "wiretap/logcat_text.c"
        ],
        "message": "Reduce compilator warnings\n\nwarning: cast from 'const guint8 *' (aka 'const unsigned char *') to\n\t'const guint16 *' (aka 'const unsigned short *') increases required\n\talignment from 1 to 2 [-Wcast-align]\nwarning: cast from 'const guint8 *' (aka 'const unsigned char *') to\n\t'const struct logger_entry *' increases required alignment\n\tfrom 1 to 4 [-Wcast-align]\n\nChange-Id: I1ef8bfedb31c3f633166405689d8d788d45365db\nReviewed-on: https://code.wireshark.org/review/4236\nPetri-Dish: Michal Labedzki <michal.labedzki@tieto.com>\nTested-by: Petri Dish Buildbot <buildbot-no-reply@wireshark.org>\nTested-by: Michal Labedzki <michal.labedzki@tieto.com>\nReviewed-by: Michal Labedzki <michal.labedzki@tieto.com>",
        "before_after_code_files": [
          "wiretap/logcat.c||wiretap/logcat.c",
          "wiretap/logcat_text.c||wiretap/logcat_text.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "wiretap/logcat.c||wiretap/logcat.c"
          ],
          "candidate": [
            "wiretap/logcat.c||wiretap/logcat.c"
          ]
        }
      },
      "candidate_diff": {
        "wiretap/logcat.c||wiretap/logcat.c": [
          "File: wiretap/logcat.c -> wiretap/logcat.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "87:     buffer = (guint8 *) g_malloc(sizeof(*log_entry_v2) + payload_length);",
          "",
          "[Removed Lines]",
          "88:     log_entry_v2 = (struct logger_entry_v2 *) buffer;",
          "89:     log_entry = (struct logger_entry *) buffer;",
          "",
          "[Added Lines]",
          "88:     log_entry_v2 = (struct logger_entry_v2 *)(void *) buffer;",
          "89:     log_entry = (struct logger_entry *)(void *) buffer;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "143:     const guint16  *tag_length;",
          "144:     gint            length = 0;",
          "148:     while(GINT16_FROM_BE(*tag)) {",
          "150:         length += 2 + 2 + GINT16_FROM_BE(*tag_length);",
          "152:         pd += 2 + 2 + GINT16_FROM_BE(*tag_length);",
          "154:     }",
          "156:     length += 2 + 2;",
          "",
          "[Removed Lines]",
          "146:     tag = (const guint16 *) pd;",
          "149:         tag_length = (const guint16 *) (pd + 2);",
          "153:         tag = (const guint16 *) pd;",
          "",
          "[Added Lines]",
          "146:     tag = (const guint16 *)(const void *) pd;",
          "149:         tag_length = (const guint16 *)(const void *) (pd + 2);",
          "153:         tag = (const guint16 *)(const void *) pd;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "188:     ws_buffer_assure_space(buf, packet_size);",
          "189:     pd = ws_buffer_start_ptr(buf);",
          "193:     memcpy(pd, tmp, 2);",
          "",
          "[Removed Lines]",
          "190:     log_entry = (struct logger_entry *) pd;",
          "",
          "[Added Lines]",
          "190:     log_entry = (struct logger_entry *)(void *) pd;",
          "",
          "---------------"
        ],
        "wiretap/logcat_text.c||wiretap/logcat_text.c": [
          "File: wiretap/logcat_text.c -> wiretap/logcat_text.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "64:     guint8                  *msg_end;",
          "65:     guint16                  msg_len;",
          "71:     if (log_entry->len < 3)",
          "",
          "[Removed Lines]",
          "67:     log_entry_v2 = (const struct logger_entry_v2 *) pd;",
          "68:     log_entry = (const struct logger_entry *) pd;",
          "",
          "[Added Lines]",
          "67:     log_entry    = (const struct logger_entry *)(const void *) pd;",
          "68:     log_entry_v2 = (const struct logger_entry_v2 *)(const void *) pd;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "459:             logcat_version = pseudo_header->logcat.version;",
          "460:         }",
          "465:         payload_length = GINT32_FROM_LE(log_entry->len);",
          "466:         pid = GINT32_FROM_LE(log_entry->pid);",
          "",
          "[Removed Lines]",
          "462:         log_entry = (const struct logger_entry *) pd;",
          "463:         log_entry_v2 = (const struct logger_entry_v2 *) pd;",
          "",
          "[Added Lines]",
          "462:         log_entry    = (const struct logger_entry *)(const void *) pd;",
          "463:         log_entry_v2 = (const struct logger_entry_v2 *)(const void *) pd;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "4a3d0b868473260c24aa66f5e3fa737b54a9fd02",
      "candidate_info": {
        "commit_hash": "4a3d0b868473260c24aa66f5e3fa737b54a9fd02",
        "repo": "wireshark/wireshark",
        "commit_url": "https://github.com/wireshark/wireshark/commit/4a3d0b868473260c24aa66f5e3fa737b54a9fd02",
        "files": [
          "wiretap/logcat.c"
        ],
        "message": "Logcat: Fix dump formats\n\nSome dump formats are not exactly what should be done,\nso fix them and try to little improve them (mostly by space padding %-8s)\n\nChange-Id: I8ee38479c848abc0a2eaff30ce733e4b60930ac4\nReviewed-on: https://code.wireshark.org/review/2550\nReviewed-by: Michal Labedzki <michal.labedzki@tieto.com>",
        "before_after_code_files": [
          "wiretap/logcat.c||wiretap/logcat.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "wiretap/logcat.c||wiretap/logcat.c"
          ],
          "candidate": [
            "wiretap/logcat.c||wiretap/logcat.c"
          ]
        }
      },
      "candidate_diff": {
        "wiretap/logcat.c||wiretap/logcat.c": [
          "File: wiretap/logcat.c -> wiretap/logcat.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "64:     switch (dumper->type) {",
          "65:         case DUMP_BRIEF:",
          "67:                     priority, tag, pid, log);",
          "68:         case DUMP_PROCESS:",
          "69:             return g_strdup_printf(\"%c(%5i) %s  (%s)\\n\",",
          "71:         case DUMP_TAG:",
          "73:                    priority, tag, log);",
          "74:         case DUMP_THREAD:",
          "76:                     priority, pid, tid, log);",
          "77:         case DUMP_TIME:",
          "78:             strftime(time_buffer, sizeof(time_buffer), \"%m-%d %H:%M:%S\",",
          "79:                     gmtime(&datetime));",
          "81:                     time_buffer, microseconds, priority, tag, pid, log);",
          "82:         case DUMP_THREADTIME:",
          "83:             strftime(time_buffer, sizeof(time_buffer), \"%m-%d %H:%M:%S\",",
          "84:                     gmtime(&datetime));",
          "86:                     time_buffer, microseconds, pid, tid, priority, tag, log);",
          "87:         case DUMP_LONG:",
          "88:             strftime(time_buffer, sizeof(time_buffer), \"%m-%d %H:%M:%S\",",
          "89:                     gmtime(&datetime));",
          "91:                     time_buffer, microseconds, pid, tid, priority, tag, log);",
          "92:         default:",
          "93:             return NULL;",
          "",
          "[Removed Lines]",
          "66:             return g_strdup_printf(\"%c/%s(%5i): %s\\n\",",
          "70:                     priority, pid, log, tag);",
          "72:             return g_strdup_printf(\"%c/%s: %s\\n\",",
          "75:             return g_strdup_printf(\"%c(%5i:%5i) %s\\n\",",
          "80:             return g_strdup_printf(\"%s.%03i %c/%s(%5i): %s\\n\",",
          "85:             return g_strdup_printf(\"%s.%03i %5i:%5i %c %s: %s\\n\",",
          "90:             return g_strdup_printf(\"[ %s.%03i %5i:%5i %c/%s ]\\n%s\\n\\n\",",
          "",
          "[Added Lines]",
          "66:             return g_strdup_printf(\"%c/%-8s(%5i): %s\\n\",",
          "72:                     priority, pid, log, \"\");",
          "74:             return g_strdup_printf(\"%c/%-8s: %s\\n\",",
          "77:             return g_strdup_printf(\"%c(%5i:0x%02x) %s\\n\",",
          "82:             return g_strdup_printf(\"%s.%03i %c/%-8s(%5i): %s\\n\",",
          "87:             return g_strdup_printf(\"%s.%03i %5i %5i %c %-8s: %s\\n\",",
          "92:             return g_strdup_printf(\"[ %s.%03i %5i:0x%02x %c/%s ]\\n%s\\n\\n\",",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "380:     str_begin = str_end = log;",
          "381:     while (dumper->type != DUMP_LONG && (str_end = strchr(str_begin, '\\n'))) {",
          "382:         log_part = (gchar *) g_malloc(str_end - str_begin + 1);",
          "385:         str_begin = str_end + 1;",
          "387:         buf = logcat_log(dumper, *datetime, *nanoseconds / 1000000, *pid, *tid,",
          "",
          "[Removed Lines]",
          "383:         g_strlcpy(log_part, str_begin, str_end - str_begin);",
          "384:         log_part[str_end - str_begin] = '\\0';",
          "",
          "[Added Lines]",
          "385:         g_strlcpy(log_part, str_begin, str_end - str_begin + 1);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "406:     if (*str_begin != '\\0') {",
          "407:         log_part = (gchar *) g_malloc(strlen(str_begin) + 1);",
          "411:         buf = logcat_log(dumper, *datetime, *nanoseconds / 1000000, *pid, *tid,",
          "412:                 priority, tag, log_part);",
          "",
          "[Removed Lines]",
          "408:         g_strlcpy(log_part, str_begin, strlen(str_begin));",
          "409:         log_part[strlen(str_begin)] = '\\0';",
          "",
          "[Added Lines]",
          "410:         g_strlcpy(log_part, str_begin, strlen(str_begin) + 1);",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2022-0156",
  "cve_desc": "vim is vulnerable to Use After Free",
  "repo": "vim/vim",
  "patch_hash": "9f1a39a5d1cd7989ada2d1cb32f97d84360e050f",
  "patch_info": {
    "commit_hash": "9f1a39a5d1cd7989ada2d1cb32f97d84360e050f",
    "repo": "vim/vim",
    "commit_url": "https://github.com/vim/vim/commit/9f1a39a5d1cd7989ada2d1cb32f97d84360e050f",
    "files": [
      "src/alloc.c",
      "src/message.c",
      "src/proto/alloc.pro",
      "src/proto/userfunc.pro",
      "src/testdir/test_vim9_func.vim",
      "src/usercmd.c",
      "src/userfunc.c",
      "src/version.c",
      "src/vim9compile.c",
      "src/viminfo.c"
    ],
    "message": "patch 8.2.4040: keeping track of allocated lines is too complicated\n\nProblem:    Keeping track of allocated lines in user functions is too\n            complicated.\nSolution:   Instead of freeing individual lines keep them all until the end.",
    "before_after_code_files": [
      "src/alloc.c||src/alloc.c",
      "src/message.c||src/message.c",
      "src/proto/alloc.pro||src/proto/alloc.pro",
      "src/proto/userfunc.pro||src/proto/userfunc.pro",
      "src/testdir/test_vim9_func.vim||src/testdir/test_vim9_func.vim",
      "src/usercmd.c||src/usercmd.c",
      "src/userfunc.c||src/userfunc.c",
      "src/version.c||src/version.c",
      "src/vim9compile.c||src/vim9compile.c",
      "src/viminfo.c||src/viminfo.c"
    ]
  },
  "patch_diff": {
    "src/alloc.c||src/alloc.c": [
      "File: src/alloc.c -> src/alloc.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "702: }",
      "704:     void",
      "706: {",
      "707:     ga_init(gap);",
      "708:     gap->ga_itemsize = itemsize;",
      "",
      "[Removed Lines]",
      "705: ga_init2(garray_T *gap, int itemsize, int growsize)",
      "",
      "[Added Lines]",
      "705: ga_init2(garray_T *gap, size_t itemsize, int growsize)",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "791:     int",
      "793: {",
      "794:     char_u *cp = vim_strsave(p);",
      "",
      "[Removed Lines]",
      "792: ga_add_string(garray_T *gap, char_u *p)",
      "",
      "[Added Lines]",
      "792: ga_copy_string(garray_T *gap, char_u *p)",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "805:     return OK;",
      "806: }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "812:     int",
      "813: ga_add_string(garray_T *gap, char_u *p)",
      "814: {",
      "815:     if (ga_grow(gap, 1) == FAIL)",
      "816:  return FAIL;",
      "817:     ((char_u **)(gap->ga_data))[gap->ga_len++] = p;",
      "818:     return OK;",
      "819: }",
      "",
      "---------------"
    ],
    "src/message.c||src/message.c": [
      "File: src/message.c -> src/message.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "587:     if (STRCMP(\"RESET\", error) == 0)",
      "588:  ga_clear_strings(&ignore_error_list);",
      "589:     else",
      "591: }",
      "593:     static int",
      "",
      "[Removed Lines]",
      "590:  ga_add_string(&ignore_error_list, error);",
      "",
      "[Added Lines]",
      "590:  ga_copy_string(&ignore_error_list, error);",
      "",
      "---------------"
    ],
    "src/proto/alloc.pro||src/proto/alloc.pro": [
      "File: src/proto/alloc.pro -> src/proto/alloc.pro",
      "--- Hunk 1 ---",
      "[Context before]",
      "17: void ga_clear_strings(garray_T *gap);",
      "18: int ga_copy_strings(garray_T *from, garray_T *to);",
      "19: void ga_init(garray_T *gap);",
      "21: int ga_grow(garray_T *gap, int n);",
      "22: int ga_grow_inner(garray_T *gap, int n);",
      "23: char_u *ga_concat_strings(garray_T *gap, char *sep);",
      "24: int ga_add_string(garray_T *gap, char_u *p);",
      "25: void ga_concat(garray_T *gap, char_u *s);",
      "26: void ga_concat_len(garray_T *gap, char_u *s, size_t len);",
      "",
      "[Removed Lines]",
      "20: void ga_init2(garray_T *gap, int itemsize, int growsize);",
      "",
      "[Added Lines]",
      "20: void ga_init2(garray_T *gap, size_t itemsize, int growsize);",
      "24: int ga_copy_string(garray_T *gap, char_u *p);",
      "",
      "---------------"
    ],
    "src/proto/userfunc.pro||src/proto/userfunc.pro": [
      "File: src/proto/userfunc.pro -> src/proto/userfunc.pro",
      "--- Hunk 1 ---",
      "[Context before]",
      "38: char_u *get_scriptlocal_funcname(char_u *funcname);",
      "39: char_u *save_function_name(char_u **name, int *is_global, int skip, int flags, funcdict_T *fudi);",
      "40: void list_functions(regmatch_T *regmatch);",
      "42: void ex_function(exarg_T *eap);",
      "43: void ex_defcompile(exarg_T *eap);",
      "44: int eval_fname_script(char_u *p);",
      "",
      "[Removed Lines]",
      "41: ufunc_T *define_function(exarg_T *eap, char_u *name_arg, char_u **line_to_free);",
      "",
      "[Added Lines]",
      "41: ufunc_T *define_function(exarg_T *eap, char_u *name_arg, garray_T *lines_to_free);",
      "",
      "---------------"
    ],
    "src/testdir/test_vim9_func.vim||src/testdir/test_vim9_func.vim": [
      "File: src/testdir/test_vim9_func.vim -> src/testdir/test_vim9_func.vim",
      "--- Hunk 1 ---",
      "[Context before]",
      "1757:   CheckScriptFailure(lines, 'E1173: Text found after endfunction: BBBB')",
      "1758: enddef",
      "1760: def Test_return_type_wrong()",
      "1761:   CheckScriptFailure([",
      "1762:         'def Func(): number',",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1760: def Test_error_in_function_args()",
      "1761:   var lines =<< trim END",
      "1762:       def FirstFunction()",
      "1763:         def SecondFunction(J  =",
      "1764:         # Nois",
      "1765:         # one",
      "1767:          enddef|BBBB",
      "1768:       enddef",
      "1769:       # Compile all functions",
      "1770:       defcompile",
      "1771:   END",
      "1772:   CheckScriptFailure(lines, 'E488:')",
      "1773: enddef",
      "",
      "---------------"
    ],
    "src/usercmd.c||src/usercmd.c": [
      "File: src/usercmd.c -> src/usercmd.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "1021:  char_u     *line = NULL;",
      "1023:  ga_init2(&ga, sizeof(char_u *), 10);",
      "1025:      return retp;",
      "",
      "[Removed Lines]",
      "1024:  if (ga_add_string(&ga, p) == FAIL)",
      "",
      "[Added Lines]",
      "1024:  if (ga_copy_string(&ga, p) == FAIL)",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "1038:       emsg(_(e_missing_rcurly));",
      "1039:       break;",
      "1040:   }",
      "1042:       break;",
      "1043:   if (*skipwhite(line) == '}')",
      "1044:       break;",
      "",
      "[Removed Lines]",
      "1041:   if (ga_add_string(&ga, line) == FAIL)",
      "",
      "[Added Lines]",
      "1041:   if (ga_copy_string(&ga, line) == FAIL)",
      "",
      "---------------"
    ],
    "src/userfunc.c||src/userfunc.c": [
      "File: src/userfunc.c -> src/userfunc.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "172:     static char_u *",
      "173: get_function_line(",
      "174:  exarg_T  *eap,",
      "176:  int  indent,",
      "177:  getline_opt_T getline_options)",
      "178: {",
      "",
      "[Removed Lines]",
      "175:  char_u  **line_to_free,",
      "",
      "[Added Lines]",
      "175:  garray_T *lines_to_free,",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "184:  theline = eap->getline(':', eap->cookie, indent, getline_options);",
      "185:     if (theline != NULL)",
      "186:     {",
      "191:     }",
      "193:     return theline;",
      "",
      "[Removed Lines]",
      "187:  if (*eap->cmdlinep == *line_to_free)",
      "189:  vim_free(*line_to_free);",
      "",
      "[Added Lines]",
      "187:  if (lines_to_free->ga_len > 0",
      "188:   && *eap->cmdlinep == ((char_u **)lines_to_free->ga_data)",
      "189:          [lines_to_free->ga_len - 1])",
      "191:  ga_add_string(lines_to_free, theline);",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "210:     garray_T *default_args,",
      "211:     int  skip,",
      "212:     exarg_T *eap,",
      "214: {",
      "215:     int  mustend = FALSE;",
      "216:     char_u *arg;",
      "",
      "[Removed Lines]",
      "213:     char_u **line_to_free)",
      "",
      "[Added Lines]",
      "214:     garray_T *lines_to_free)",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "241:     && (*p == NUL || (VIM_ISWHITE(*whitep) && *p == '#')))",
      "242:  {",
      "245:          GETLINE_CONCAT_CONT);",
      "247:      if (theline == NULL)",
      "",
      "[Removed Lines]",
      "244:      char_u *theline = get_function_line(eap, line_to_free, 0,",
      "",
      "[Added Lines]",
      "245:      char_u *theline = get_function_line(eap, lines_to_free, 0,",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "677:  exarg_T     *eap,",
      "678:  garray_T    *newlines,",
      "679:  char_u     *line_arg_in,",
      "681: {",
      "682:     linenr_T sourcing_lnum_top = SOURCING_LNUM;",
      "683:     linenr_T sourcing_lnum_off;",
      "",
      "[Removed Lines]",
      "680:  char_u     **line_to_free)",
      "",
      "[Added Lines]",
      "681:  garray_T    *lines_to_free)",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "744:  }",
      "745:  else",
      "746:  {",
      "748:              getline_options);",
      "749:  }",
      "750:  if (KeyTyped)",
      "",
      "[Removed Lines]",
      "747:      theline = get_function_line(eap, line_to_free, indent,",
      "",
      "[Added Lines]",
      "748:      theline = get_function_line(eap, lines_to_free, indent,",
      "",
      "---------------",
      "--- Hunk 7 ---",
      "[Context before]",
      "854:       {",
      "858:    eap->nextcmd = nextcmd;",
      "861:    {",
      "862:        vim_free(*eap->cmdlinep);",
      "865:    }",
      "866:       }",
      "867:       break;",
      "",
      "[Removed Lines]",
      "859:    if (*line_to_free != NULL",
      "860:          && *eap->cmdlinep != *line_to_free)",
      "",
      "[Added Lines]",
      "861:    if (lines_to_free->ga_len > 0",
      "862:     && *eap->cmdlinep !=",
      "863:          ((char_u **)lines_to_free->ga_data)",
      "864:          [lines_to_free->ga_len - 1])",
      "870:          [lines_to_free->ga_len - 1];",
      "871:        --lines_to_free->ga_len;",
      "",
      "---------------",
      "--- Hunk 8 ---",
      "[Context before]",
      "1118:     garray_T newlines;",
      "1119:     char_u *cmdline = NULL;",
      "1120:     int  ret = FAIL;",
      "1122:     partial_T *pt;",
      "1123:     char_u *name;",
      "1124:     int  lnum_save = -1;",
      "",
      "[Removed Lines]",
      "1121:     char_u *line_to_free = NULL;",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 9 ---",
      "[Context before]",
      "1144:     }",
      "1146:     ga_init2(&newlines, (int)sizeof(char_u *), 10);",
      "1151:  goto erret;",
      "1155:     evalarg->eval_break_count += newlines.ga_len;",
      "",
      "[Removed Lines]",
      "1147:     if (get_function_body(&eap, &newlines, NULL, &line_to_free) == FAIL)",
      "1148:     {",
      "1149:  if (cmdline != line_to_free)",
      "1150:      vim_free(cmdline);",
      "1152:     }",
      "",
      "[Added Lines]",
      "1153:     if (get_function_body(&eap, &newlines, NULL,",
      "1154:           &evalarg->eval_tofree_ga) == FAIL)",
      "",
      "---------------",
      "--- Hunk 10 ---",
      "[Context before]",
      "1208:  {",
      "1209:      ((char_u **)(tfgap->ga_data))[tfgap->ga_len++] = cmdline;",
      "1210:      evalarg->eval_using_cmdline = TRUE;",
      "1213:  }",
      "1214:     }",
      "1215:     else",
      "",
      "[Removed Lines]",
      "1211:      if (cmdline == line_to_free)",
      "1212:   line_to_free = NULL;",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 11 ---",
      "[Context before]",
      "1278: erret:",
      "1279:     if (lnum_save >= 0)",
      "1280:  SOURCING_LNUM = lnum_save;",
      "1282:     ga_clear_strings(&newlines);",
      "1283:     if (newargs != NULL)",
      "1284:  ga_clear_strings(newargs);",
      "",
      "[Removed Lines]",
      "1281:     vim_free(line_to_free);",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 12 ---",
      "[Context before]",
      "3962:     ufunc_T *",
      "3964: {",
      "3965:     int  j;",
      "3966:     int  c;",
      "",
      "[Removed Lines]",
      "3963: define_function(exarg_T *eap, char_u *name_arg, char_u **line_to_free)",
      "",
      "[Added Lines]",
      "3964: define_function(exarg_T *eap, char_u *name_arg, garray_T *lines_to_free)",
      "",
      "---------------",
      "--- Hunk 13 ---",
      "[Context before]",
      "4229:     if (get_function_args(&p, ')', &newargs,",
      "4230:    eap->cmdidx == CMD_def ? &argtypes : NULL, FALSE,",
      "4231:     NULL, &varargs, &default_args, eap->skip,",
      "4233:  goto errret_2;",
      "4234:     whitep = p;",
      "",
      "[Removed Lines]",
      "4232:     eap, line_to_free) == FAIL)",
      "",
      "[Added Lines]",
      "4233:     eap, lines_to_free) == FAIL)",
      "",
      "---------------",
      "--- Hunk 14 ---",
      "[Context before]",
      "4343:      || eap->skip)",
      "4344:  goto erret;",
      "",
      "[Removed Lines]",
      "4342:     if (get_function_body(eap, &newlines, line_arg, line_to_free) == FAIL",
      "",
      "[Added Lines]",
      "4343:     if (get_function_body(eap, &newlines, line_arg, lines_to_free) == FAIL",
      "",
      "---------------",
      "--- Hunk 15 ---",
      "[Context before]",
      "4645:     void",
      "4646: ex_function(exarg_T *eap)",
      "4647: {",
      "4652: }",
      "",
      "[Removed Lines]",
      "4648:     char_u *line_to_free = NULL;",
      "4650:     (void)define_function(eap, NULL, &line_to_free);",
      "4651:     vim_free(line_to_free);",
      "",
      "[Added Lines]",
      "4649:     garray_T lines_to_free;",
      "4651:     ga_init2(&lines_to_free, sizeof(char_u *), 50);",
      "4652:     (void)define_function(eap, NULL, &lines_to_free);",
      "4653:     ga_clear_strings(&lines_to_free);",
      "",
      "---------------"
    ],
    "src/version.c||src/version.c": [
      "File: src/version.c -> src/version.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "751: static int included_patches[] =",
      "754:     4039,",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "754:     4040,",
      "",
      "---------------"
    ],
    "src/vim9compile.c||src/vim9compile.c": [
      "File: src/vim9compile.c -> src/vim9compile.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "812:     static char_u *",
      "814: {",
      "815:     int  is_global = *eap->arg == 'g' && eap->arg[1] == ':';",
      "816:     char_u *name_start = eap->arg;",
      "",
      "[Removed Lines]",
      "813: compile_nested_function(exarg_T *eap, cctx_T *cctx, char_u **line_to_free)",
      "",
      "[Added Lines]",
      "813: compile_nested_function(exarg_T *eap, cctx_T *cctx, garray_T *lines_to_free)",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "876:  goto theend;",
      "877:     }",
      "880:     if (ufunc == NULL)",
      "881:     {",
      "882:  r = eap->skip ? OK : FAIL;",
      "",
      "[Removed Lines]",
      "879:     ufunc = define_function(eap, lambda_name, line_to_free);",
      "",
      "[Added Lines]",
      "879:     ufunc = define_function(eap, lambda_name, lines_to_free);",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "2496:  cctx_T  *outer_cctx)",
      "2497: {",
      "2498:     char_u *line = NULL;",
      "2500:     char_u *p;",
      "2501:     char *errormsg = NULL; // error message",
      "2502:     cctx_T cctx;",
      "",
      "[Removed Lines]",
      "2499:     char_u *line_to_free = NULL;",
      "",
      "[Added Lines]",
      "2499:     garray_T lines_to_free;",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "2514: #endif",
      "2515:     int  debug_lnum = -1;",
      "2519:     if (ufunc->uf_dfunc_idx > 0)",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "2518:     ga_init2(&lines_to_free, sizeof(char_u *), 50);",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "2681:      if (line != NULL)",
      "2682:      {",
      "2683:   line = vim_strsave(line);",
      "2686:      }",
      "2687:  }",
      "",
      "[Removed Lines]",
      "2684:   vim_free(line_to_free);",
      "2685:   line_to_free = line;",
      "",
      "[Added Lines]",
      "2687:   if (ga_add_string(&lines_to_free, line) == FAIL)",
      "2688:       goto erret;",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "2926:      case CMD_def:",
      "2927:      case CMD_function:",
      "2928:       ea.arg = p;",
      "2930:       break;",
      "2932:      case CMD_return:",
      "",
      "[Removed Lines]",
      "2929:       line = compile_nested_function(&ea, &cctx, &line_to_free);",
      "",
      "[Added Lines]",
      "2932:       line = compile_nested_function(&ea, &cctx, &lines_to_free);",
      "",
      "---------------",
      "--- Hunk 7 ---",
      "[Context before]",
      "3236:     if (do_estack_push)",
      "3237:  estack_pop();",
      "3240:     free_imported(&cctx);",
      "3241:     free_locals(&cctx);",
      "3242:     ga_clear(&cctx.ctx_type_stack);",
      "",
      "[Removed Lines]",
      "3239:     vim_free(line_to_free);",
      "",
      "[Added Lines]",
      "3242:     ga_clear_strings(&lines_to_free);",
      "",
      "---------------"
    ],
    "src/viminfo.c||src/viminfo.c": [
      "File: src/viminfo.c -> src/viminfo.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "2730:     {",
      "2732:  if (writing)",
      "2734:     }",
      "2735:     else",
      "2736:     {",
      "",
      "[Removed Lines]",
      "2733:      ga_add_string(&virp->vir_barlines, virp->vir_line);",
      "",
      "[Added Lines]",
      "2733:      ga_copy_string(&virp->vir_barlines, virp->vir_line);",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "2769:      default:",
      "2771:   if (writing)",
      "2773:  }",
      "2774:  for (i = 0; i < values.ga_len; ++i)",
      "2775:  {",
      "",
      "[Removed Lines]",
      "2772:       ga_add_string(&virp->vir_barlines, virp->vir_line);",
      "",
      "[Added Lines]",
      "2772:       ga_copy_string(&virp->vir_barlines, virp->vir_line);",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "d87c21a918d8d611750f22d68fc638bf7a79b1d5",
      "candidate_info": {
        "commit_hash": "d87c21a918d8d611750f22d68fc638bf7a79b1d5",
        "repo": "vim/vim",
        "commit_url": "https://github.com/vim/vim/commit/d87c21a918d8d611750f22d68fc638bf7a79b1d5",
        "files": [
          "src/userfunc.c",
          "src/version.c"
        ],
        "message": "patch 8.2.2865: skipping over function body fails\n\nProblem:    Skipping over function body fails.\nSolution:   Do not define the function when skipping.",
        "before_after_code_files": [
          "src/userfunc.c||src/userfunc.c",
          "src/version.c||src/version.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/userfunc.c||src/userfunc.c",
            "src/version.c||src/version.c"
          ],
          "candidate": [
            "src/userfunc.c||src/userfunc.c",
            "src/version.c||src/version.c"
          ]
        }
      },
      "candidate_diff": {
        "src/userfunc.c||src/userfunc.c": [
          "File: src/userfunc.c -> src/userfunc.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "4015:     sourcing_lnum_top = SOURCING_LNUM;",
          "4018:  goto erret;",
          "",
          "[Removed Lines]",
          "4017:     if (get_function_body(eap, &newlines, line_arg, &line_to_free) == FAIL)",
          "",
          "[Added Lines]",
          "4019:     if (get_function_body(eap, &newlines, line_arg, &line_to_free) == FAIL",
          "4020:      || eap->skip)",
          "",
          "---------------"
        ],
        "src/version.c||src/version.c": [
          "File: src/version.c -> src/version.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "751: static int included_patches[] =",
          "754:     2864,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "754:     2865,",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "057e84afe5bd37fe272bf7cfafca629ef9da1bd3",
      "candidate_info": {
        "commit_hash": "057e84afe5bd37fe272bf7cfafca629ef9da1bd3",
        "repo": "vim/vim",
        "commit_url": "https://github.com/vim/vim/commit/057e84afe5bd37fe272bf7cfafca629ef9da1bd3",
        "files": [
          "src/errors.h",
          "src/proto/vim9compile.pro",
          "src/testdir/test_vim9_expr.vim",
          "src/testdir/test_vim9_func.vim",
          "src/testdir/test_vim9_script.vim",
          "src/userfunc.c",
          "src/version.c",
          "src/vim9compile.c",
          "src/vim9script.c"
        ],
        "message": "patch 8.2.2558: no error if a lambda argument shadows a variable\n\nProblem:    No error if a lambda argument shadows a variable.\nSolution:   Check that the argument name shadows a local, argument or script\n            variable. (closes #7898)",
        "before_after_code_files": [
          "src/errors.h||src/errors.h",
          "src/proto/vim9compile.pro||src/proto/vim9compile.pro",
          "src/testdir/test_vim9_expr.vim||src/testdir/test_vim9_expr.vim",
          "src/testdir/test_vim9_func.vim||src/testdir/test_vim9_func.vim",
          "src/testdir/test_vim9_script.vim||src/testdir/test_vim9_script.vim",
          "src/userfunc.c||src/userfunc.c",
          "src/version.c||src/version.c",
          "src/vim9compile.c||src/vim9compile.c",
          "src/vim9script.c||src/vim9script.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/testdir/test_vim9_func.vim||src/testdir/test_vim9_func.vim",
            "src/userfunc.c||src/userfunc.c",
            "src/version.c||src/version.c",
            "src/vim9compile.c||src/vim9compile.c"
          ],
          "candidate": [
            "src/testdir/test_vim9_func.vim||src/testdir/test_vim9_func.vim",
            "src/userfunc.c||src/userfunc.c",
            "src/version.c||src/version.c",
            "src/vim9compile.c||src/vim9compile.c"
          ]
        }
      },
      "candidate_diff": {
        "src/errors.h||src/errors.h": [
          "File: src/errors.h -> src/errors.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "147:  INIT(= N_(\"E1052: Cannot declare an option: %s\"));",
          "148: EXTERN char e_could_not_import_str[]",
          "149:  INIT(= N_(\"E1053: Could not import \\\"%s\\\"\"));",
          "151:  INIT(= N_(\"E1054: Variable already declared in the script: %s\"));",
          "152: EXTERN char e_missing_name_after_dots[]",
          "153:  INIT(= N_(\"E1055: Missing name after ...\"));",
          "",
          "[Removed Lines]",
          "150: EXTERN char e_variable_already_declared_in_script[]",
          "",
          "[Added Lines]",
          "150: EXTERN char e_variable_already_declared_in_script_str[]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "369:  INIT(= N_(\"E1165: Cannot use a range with an assignment: %s\"));",
          "370: EXTERN char e_cannot_use_range_with_dictionary[]",
          "371:  INIT(= N_(\"E1166: Cannot use a range with a dictionary\"));",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "372: EXTERN char e_argument_name_shadows_existing_variable_str[]",
          "373:  INIT(= N_(\"E1167: Argument name shadows existing variable: %s\"));",
          "374: EXTERN char e_argument_already_declared_in_script_str[]",
          "375:  INIT(= N_(\"E1168: Argument already declared in the script: %s\"));",
          "",
          "---------------"
        ],
        "src/proto/vim9compile.pro||src/proto/vim9compile.pro": [
          "File: src/proto/vim9compile.pro -> src/proto/vim9compile.pro",
          "--- Hunk 1 ---",
          "[Context before]",
          "2: int script_var_exists(char_u *name, size_t len, int vim9script, cctx_T *cctx);",
          "4: int check_compare_types(exprtype_T type, typval_T *tv1, typval_T *tv2);",
          "5: int use_typecheck(type_T *actual, type_T *expected);",
          "6: int need_type(type_T *actual, type_T *expected, int offset, int arg_idx, cctx_T *cctx, int silent, int actual_is_const);",
          "",
          "[Removed Lines]",
          "3: int check_defined(char_u *p, size_t len, cctx_T *cctx);",
          "",
          "[Added Lines]",
          "3: int check_defined(char_u *p, size_t len, cctx_T *cctx, int is_arg);",
          "",
          "---------------"
        ],
        "src/testdir/test_vim9_expr.vim||src/testdir/test_vim9_expr.vim": [
          "File: src/testdir/test_vim9_expr.vim -> src/testdir/test_vim9_expr.vim",
          "--- Hunk 1 ---",
          "[Context before]",
          "2844:   # lambda method call",
          "2845:   l = [2, 5]",
          "2847:   assert_equal([2, 5, 8], l)",
          "2849:   # dict member",
          "",
          "[Removed Lines]",
          "2846:   l->((l) => add(l, 8))()",
          "",
          "[Added Lines]",
          "2846:   l->((ll) => add(ll, 8))()",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "3034: enddef",
          "3036: func Test_expr7_trailing_fails()",
          "3039: endfunc",
          "3041: func Test_expr_fails()",
          "",
          "[Removed Lines]",
          "3037:   call CheckDefFailure(['var l = [2]', 'l->((l) => add(l, 8))'], 'E107:', 2)",
          "3038:   call CheckDefFailure(['var l = [2]', 'l->((l) => add(l, 8)) ()'], 'E274:', 2)",
          "",
          "[Added Lines]",
          "3037:   call CheckDefFailure(['var l = [2]', 'l->((ll) => add(ll, 8))'], 'E107:', 2)",
          "3038:   call CheckDefFailure(['var l = [2]', 'l->((ll) => add(ll, 8)) ()'], 'E274:', 2)",
          "",
          "---------------"
        ],
        "src/testdir/test_vim9_func.vim||src/testdir/test_vim9_func.vim": [
          "File: src/testdir/test_vim9_func.vim -> src/testdir/test_vim9_func.vim",
          "--- Hunk 1 ---",
          "[Context before]",
          "596:       echo nr",
          "597:     enddef",
          "598:   END",
          "601:   lines =<< trim END",
          "602:     vim9script",
          "",
          "[Removed Lines]",
          "599:   CheckScriptFailure(lines, 'E1054:')",
          "",
          "[Added Lines]",
          "599:   CheckScriptFailure(lines, 'E1168:')",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "699:     Ref = (x, y, z) => 0",
          "700:   END",
          "701:   CheckDefAndScriptFailure(lines, 'E1012:')",
          "702: enddef",
          "704: def Test_lambda_return_type()",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "703:   lines =<< trim END",
          "704:       var one = 1",
          "705:       var l = [1, 2, 3]",
          "706:       echo map(l, (one) => one)",
          "707:   END",
          "708:   CheckDefFailure(lines, 'E1167:')",
          "709:   CheckScriptFailure(['vim9script'] + lines, 'E1168:')",
          "711:   lines =<< trim END",
          "712:       def ShadowLocal()",
          "713:         var one = 1",
          "714:         var l = [1, 2, 3]",
          "715:         echo map(l, (one) => one)",
          "716:       enddef",
          "717:   END",
          "718:   CheckDefFailure(lines, 'E1167:')",
          "720:   lines =<< trim END",
          "721:       def Shadowarg(one: number)",
          "722:         var l = [1, 2, 3]",
          "723:         echo map(l, (one) => one)",
          "724:       enddef",
          "725:   END",
          "726:   CheckDefFailure(lines, 'E1167:')",
          "",
          "---------------"
        ],
        "src/testdir/test_vim9_script.vim||src/testdir/test_vim9_script.vim": [
          "File: src/testdir/test_vim9_script.vim -> src/testdir/test_vim9_script.vim",
          "--- Hunk 1 ---",
          "[Context before]",
          "1119:     import exported from './Xexport.vim'",
          "1120:   END",
          "1121:   writefile(import_already_defined, 'Ximport.vim')",
          "1124:   # try to import something that is already defined",
          "1125:   import_already_defined =<< trim END",
          "",
          "[Removed Lines]",
          "1122:   assert_fails('source Ximport.vim', 'E1073:', '', 3, 'Ximport.vim')",
          "",
          "[Added Lines]",
          "1122:   assert_fails('source Ximport.vim', 'E1054:', '', 3, 'Ximport.vim')",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1128:     import * as exported from './Xexport.vim'",
          "1129:   END",
          "1130:   writefile(import_already_defined, 'Ximport.vim')",
          "1133:   # try to import something that is already defined",
          "1134:   import_already_defined =<< trim END",
          "",
          "[Removed Lines]",
          "1131:   assert_fails('source Ximport.vim', 'E1073:', '', 3, 'Ximport.vim')",
          "",
          "[Added Lines]",
          "1131:   assert_fails('source Ximport.vim', 'E1054:', '', 3, 'Ximport.vim')",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1137:     import {exported} from './Xexport.vim'",
          "1138:   END",
          "1139:   writefile(import_already_defined, 'Ximport.vim')",
          "1142:   # try changing an imported const",
          "1143:   var import_assign_to_const =<< trim END",
          "",
          "[Removed Lines]",
          "1140:   assert_fails('source Ximport.vim', 'E1073:', '', 3, 'Ximport.vim')",
          "",
          "[Added Lines]",
          "1140:   assert_fails('source Ximport.vim', 'E1054:', '', 3, 'Ximport.vim')",
          "",
          "---------------"
        ],
        "src/userfunc.c||src/userfunc.c": [
          "File: src/userfunc.c -> src/userfunc.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "64:  garray_T    *newargs,",
          "65:  garray_T    *argtypes,",
          "66:  int     types_optional,",
          "67:  int     skip)",
          "68: {",
          "69:     char_u *p = arg;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "68:  evalarg_T   *evalarg,",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "81:  return arg;",
          "82:     }",
          "89:  return arg;",
          "92:     if (newargs != NULL && ga_grow(newargs, 1) == FAIL)",
          "93:  return arg;",
          "",
          "[Removed Lines]",
          "85:     if (!skip && argtypes != NULL && script_var_exists(arg, p - arg,",
          "86:            FALSE, NULL) == OK)",
          "87:     {",
          "88:  semsg(_(e_variable_already_declared_in_script), arg);",
          "90:     }",
          "",
          "[Added Lines]",
          "88:     if (!skip && argtypes != NULL && check_defined(arg, p - arg,",
          "89:       evalarg == NULL ? NULL : evalarg->eval_cctx, TRUE) == FAIL)",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "173:     garray_T *newargs,",
          "174:     garray_T *argtypes, // NULL unless using :def",
          "175:     int  types_optional, // types optional if \"argtypes\" is not NULL",
          "176:     int  *varargs,",
          "177:     garray_T *default_args,",
          "178:     int  skip,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "176:     evalarg_T *evalarg, // context or NULL",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "248:   arg = p;",
          "249:   p = one_function_arg(p, newargs, argtypes, types_optional,",
          "251:   if (p == arg)",
          "252:       break;",
          "253:   if (*skipwhite(p) == '=')",
          "",
          "[Removed Lines]",
          "250:           skip);",
          "",
          "[Added Lines]",
          "251:         evalarg, skip);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "260:  else",
          "261:  {",
          "262:      arg = p;",
          "264:      if (p == arg)",
          "265:   break;",
          "",
          "[Removed Lines]",
          "263:      p = one_function_arg(p, newargs, argtypes, types_optional, skip);",
          "",
          "[Added Lines]",
          "264:      p = one_function_arg(p, newargs, argtypes, types_optional,",
          "265:         evalarg, skip);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "577:     s = *arg + 1;",
          "578:     ret = get_function_args(&s, equal_arrow ? ')' : '-', NULL,",
          "580:        NULL, NULL, TRUE, NULL, NULL);",
          "581:     if (ret == FAIL || skip_arrow(s, equal_arrow, &ret_type, NULL) == NULL)",
          "582:     {",
          "",
          "[Removed Lines]",
          "579:      types_optional ? &argtypes : NULL, types_optional,",
          "",
          "[Added Lines]",
          "581:      types_optional ? &argtypes : NULL, types_optional, evalarg,",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "592:  pnewargs = NULL;",
          "594:     ret = get_function_args(arg, equal_arrow ? ')' : '-', pnewargs,",
          "596:          &varargs, NULL, FALSE, NULL, NULL);",
          "597:     if (ret == FAIL",
          "598:     || (s = skip_arrow(*arg, equal_arrow, &ret_type,",
          "",
          "[Removed Lines]",
          "595:      types_optional ? &argtypes : NULL, types_optional,",
          "",
          "[Added Lines]",
          "597:      types_optional ? &argtypes : NULL, types_optional, evalarg,",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "684:  fp->uf_refcount = 1;",
          "685:  set_ufunc_name(fp, name);",
          "687:  fp->uf_args = newargs;",
          "688:  ga_init(&fp->uf_def_args);",
          "689:  if (types_optional)",
          "",
          "[Removed Lines]",
          "686:  hash_add(&func_hashtab, UF2HIKEY(fp));",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "726:  pt->pt_refcount = 1;",
          "727:  rettv->vval.v_partial = pt;",
          "728:  rettv->v_type = VAR_PARTIAL;",
          "729:     }",
          "731:     eval_lavars_used = old_eval_lavars;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "731:  hash_add(&func_hashtab, UF2HIKEY(fp));",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "3278:     ++p;",
          "3279:     if (get_function_args(&p, ')', &newargs,",
          "3280:    eap->cmdidx == CMD_def ? &argtypes : NULL, FALSE,",
          "3282:     eap, &line_to_free) == FAIL)",
          "3283:  goto errret_2;",
          "3284:     whitep = p;",
          "",
          "[Removed Lines]",
          "3281:     &varargs, &default_args, eap->skip,",
          "",
          "[Added Lines]",
          "3284:     NULL, &varargs, &default_args, eap->skip,",
          "",
          "---------------"
        ],
        "src/version.c||src/version.c": [
          "File: src/version.c -> src/version.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "751: static int included_patches[] =",
          "754:     2557,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "754:     2558,",
          "",
          "---------------"
        ],
        "src/vim9compile.c||src/vim9compile.c": [
          "File: src/vim9compile.c -> src/vim9compile.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "379:     static int",
          "380: variable_exists(char_u *name, size_t len, cctx_T *cctx)",
          "381: {",
          "384:      || script_var_exists(name, len, FALSE, cctx) == OK",
          "385:      || find_imported(name, len, cctx) != NULL;",
          "386: }",
          "",
          "[Removed Lines]",
          "382:     return lookup_local(name, len, NULL, cctx) == OK",
          "383:      || arg_exists(name, len, NULL, NULL, NULL, cctx) == OK",
          "",
          "[Added Lines]",
          "382:     return (cctx != NULL",
          "383:   && (lookup_local(name, len, NULL, cctx) == OK",
          "384:       || arg_exists(name, len, NULL, NULL, NULL, cctx) == OK))",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "394:     int",
          "396: {",
          "397:     int  c = p[len];",
          "398:     ufunc_T *ufunc = NULL;",
          "400:     p[len] = NUL;",
          "403:   && (lookup_local(p, len, NULL, cctx) == OK",
          "404:       || arg_exists(p, len, NULL, NULL, NULL, cctx) == OK))",
          "405:      || find_imported(p, len, cctx) != NULL",
          "",
          "[Removed Lines]",
          "395: check_defined(char_u *p, size_t len, cctx_T *cctx)",
          "401:     if (script_var_exists(p, len, FALSE, cctx) == OK",
          "402:      || (cctx != NULL",
          "",
          "[Added Lines]",
          "397: check_defined(char_u *p, size_t len, cctx_T *cctx, int is_arg)",
          "402:     if (script_var_exists(p, len, FALSE, cctx) == OK)",
          "403:     {",
          "404:  if (is_arg)",
          "405:      semsg(_(e_argument_already_declared_in_script_str), p);",
          "406:  else",
          "407:      semsg(_(e_variable_already_declared_in_script_str), p);",
          "408:  return FAIL;",
          "409:     }",
          "412:     if ((cctx != NULL",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "409:  if (ufunc == NULL || !func_is_global(ufunc)",
          "410:   || (p[0] == 'g' && p[1] == ':'))",
          "411:  {",
          "412:      p[len] = c;",
          "414:      return FAIL;",
          "415:  }",
          "416:     }",
          "",
          "[Removed Lines]",
          "413:      semsg(_(e_name_already_defined_str), p);",
          "",
          "[Added Lines]",
          "422:      if (is_arg)",
          "423:   semsg(_(e_argument_name_shadows_existing_variable_str), p);",
          "424:      else",
          "425:   semsg(_(e_name_already_defined_str), p);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "5120:  semsg(_(e_namespace_not_supported_str), name_start);",
          "5121:  return NULL;",
          "5122:     }",
          "5124:  return NULL;",
          "5126:     eap->arg = name_end;",
          "",
          "[Removed Lines]",
          "5123:     if (check_defined(name_start, name_end - name_start, cctx) == FAIL)",
          "",
          "[Added Lines]",
          "5136:     if (check_defined(name_start, name_end - name_start, cctx, FALSE) == FAIL)",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "5686:        semsg(_(e_cannot_declare_script_variable_in_function),",
          "5687:         lhs->lhs_name);",
          "5688:    else",
          "5690:         lhs->lhs_name);",
          "5691:    return FAIL;",
          "5692:       }",
          "",
          "[Removed Lines]",
          "5689:        semsg(_(e_variable_already_declared_in_script),",
          "",
          "[Added Lines]",
          "5702:        semsg(_(e_variable_already_declared_in_script_str),",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "5723:    }",
          "5724:       }",
          "5725:   }",
          "5727:                == FAIL)",
          "5728:       return FAIL;",
          "5729:      }",
          "",
          "[Removed Lines]",
          "5726:   else if (check_defined(var_start, lhs->lhs_varlen, cctx)",
          "",
          "[Added Lines]",
          "5739:   else if (check_defined(var_start, lhs->lhs_varlen, cctx, FALSE)",
          "",
          "---------------"
        ],
        "src/vim9script.c||src/vim9script.c": [
          "File: src/vim9script.c -> src/vim9script.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "370:      if (eval_isnamec1(*arg))",
          "371:   while (eval_isnamec(*arg))",
          "372:       ++arg;",
          "374:   goto erret;",
          "375:      as_name = vim_strnsave(p, arg - p);",
          "376:      arg = skipwhite_and_linebreak(arg, evalarg);",
          "",
          "[Removed Lines]",
          "373:      if (check_defined(p, arg - p, cctx) == FAIL)",
          "",
          "[Added Lines]",
          "373:      if (check_defined(p, arg - p, cctx, FALSE) == FAIL)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "555:      }",
          "556:      else",
          "557:      {",
          "559:       goto erret;",
          "561:   imported = new_imported(gap != NULL ? gap",
          "",
          "[Removed Lines]",
          "558:   if (check_defined(name, len, cctx) == FAIL)",
          "",
          "[Added Lines]",
          "558:   if (check_defined(name, len, cctx, FALSE) == FAIL)",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "567:   {",
          "568:       imported->imp_name = name;",
          "569:       ((char_u **)names.ga_data)[i] = NULL;",
          "571:   else",
          "572:   {",
          "",
          "[Removed Lines]",
          "570:   }",
          "",
          "[Added Lines]",
          "570:   }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "7a6eaa06f98cef61d2131c25b4b47b8262cb8f59",
      "candidate_info": {
        "commit_hash": "7a6eaa06f98cef61d2131c25b4b47b8262cb8f59",
        "repo": "vim/vim",
        "commit_url": "https://github.com/vim/vim/commit/7a6eaa06f98cef61d2131c25b4b47b8262cb8f59",
        "files": [
          "src/errors.h",
          "src/misc2.c",
          "src/proto/vim9compile.pro",
          "src/testdir/test_vim9_expr.vim",
          "src/userfunc.c",
          "src/version.c",
          "src/vim9compile.c"
        ],
        "message": "patch 8.2.2635: Vim9: cannot define an inline function\n\nProblem:    Vim9: cannot define an inline function.\nSolution:   Make an inline function mostly work.",
        "before_after_code_files": [
          "src/errors.h||src/errors.h",
          "src/misc2.c||src/misc2.c",
          "src/proto/vim9compile.pro||src/proto/vim9compile.pro",
          "src/testdir/test_vim9_expr.vim||src/testdir/test_vim9_expr.vim",
          "src/userfunc.c||src/userfunc.c",
          "src/version.c||src/version.c",
          "src/vim9compile.c||src/vim9compile.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/userfunc.c||src/userfunc.c",
            "src/version.c||src/version.c",
            "src/vim9compile.c||src/vim9compile.c"
          ],
          "candidate": [
            "src/userfunc.c||src/userfunc.c",
            "src/version.c||src/version.c",
            "src/vim9compile.c||src/vim9compile.c"
          ]
        }
      },
      "candidate_diff": {
        "src/errors.h||src/errors.h": [
          "File: src/errors.h -> src/errors.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "377:  INIT(= N_(\"E1169: 'import * as {name}' not supported here\"));",
          "378: EXTERN char e_cannot_use_hash_curly_to_start_comment[]",
          "379:  INIT(= N_(\"E1170: Cannot use #{ to start a comment\"));",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "380: EXTERN char e_missing_end_block[]",
          "381:  INIT(= N_(\"E1171: Missing } after inline function\"));",
          "382: EXTERN char e_cannot_use_default_values_in_lambda[]",
          "383:  INIT(= N_(\"E1172: Cannot use default values in a lambda\"));",
          "",
          "---------------"
        ],
        "src/misc2.c||src/misc2.c": [
          "File: src/misc2.c -> src/misc2.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "2026: {",
          "2027:     int  i;",
          "2031:     ga_clear(gap);",
          "2032: }",
          "",
          "[Removed Lines]",
          "2029:     for (i = 0; i < gap->ga_len; ++i)",
          "2030:  vim_free(((char_u **)(gap->ga_data))[i]);",
          "",
          "[Added Lines]",
          "2029:     if (gap->ga_data != NULL)",
          "2030:  for (i = 0; i < gap->ga_len; ++i)",
          "2031:      vim_free(((char_u **)(gap->ga_data))[i]);",
          "",
          "---------------"
        ],
        "src/proto/vim9compile.pro||src/proto/vim9compile.pro": [
          "File: src/proto/vim9compile.pro -> src/proto/vim9compile.pro",
          "--- Hunk 1 ---",
          "[Context before]",
          "14: char_u *to_name_const_end(char_u *arg);",
          "15: exprtype_T get_compare_type(char_u *p, int *len, int *type_is);",
          "16: void error_white_both(char_u *op, int len);",
          "17: int assignment_len(char_u *p, int *heredoc);",
          "18: void vim9_declare_error(char_u *name);",
          "19: int check_vim9_unlet(char_u *name);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "17: void fill_exarg_from_cctx(exarg_T *eap, cctx_T *cctx);",
          "",
          "---------------"
        ],
        "src/testdir/test_vim9_expr.vim||src/testdir/test_vim9_expr.vim": [
          "File: src/testdir/test_vim9_expr.vim -> src/testdir/test_vim9_expr.vim",
          "--- Hunk 1 ---",
          "[Context before]",
          "1946:   CheckScriptSuccess(lines)",
          "1947: enddef",
          "1949: def NewLambdaWithComments(): func",
          "1950:   return (x) =>",
          "1951:             # some comment",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1949: def Test_expr7_lambda_block()",
          "1950:   var lines =<< trim END",
          "1951:       var Func = (s: string): string => {",
          "1952:                       return 'hello ' .. s",
          "1953:                     }",
          "1954:       assert_equal('hello there', Func('there'))",
          "1956:       var ll = range(3)",
          "1957:       var dll = mapnew(ll, (k, v): string => {",
          "1958:           if v % 2",
          "1959:             return 'yes'",
          "1960:           endif",
          "1961:           return 'no'",
          "1962:         })",
          "1963:       assert_equal(['no', 'yes', 'no'], dll)",
          "1964:   END",
          "1965:   CheckDefAndScriptSuccess(lines)",
          "1966: enddef",
          "",
          "---------------"
        ],
        "src/userfunc.c||src/userfunc.c": [
          "File: src/userfunc.c -> src/userfunc.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "397:     return OK;",
          "398: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "400:     static int",
          "401: parse_return_type(ufunc_T *fp, char_u *ret_type)",
          "402: {",
          "403:     if (ret_type == NULL)",
          "404:  fp->uf_ret_type = &t_void;",
          "405:     else",
          "406:     {",
          "407:  char_u *p = ret_type;",
          "409:  fp->uf_ret_type = parse_type(&p, &fp->uf_type_list, TRUE);",
          "410:  if (fp->uf_ret_type == NULL)",
          "411:  {",
          "412:      fp->uf_ret_type = &t_void;",
          "413:      return FAIL;",
          "414:  }",
          "415:     }",
          "416:     return OK;",
          "417: }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "516:   return NULL;",
          "517:      }",
          "518:  }",
          "524:     }",
          "529:     {",
          "534:     }",
          "536: }",
          "",
          "[Removed Lines]",
          "519:  bef = s;",
          "520:  s = skipwhite(s);",
          "521:  if (*s != '=')",
          "522:      return NULL;",
          "523:  ++s;",
          "525:     if (*s != '>')",
          "526:  return NULL;",
          "527:     if (white_error != NULL && ((!VIM_ISWHITE(*bef) && *bef != '{')",
          "528:   || !IS_WHITE_OR_NUL(s[1])))",
          "531:  semsg(_(e_white_space_required_before_and_after_str_at_str),",
          "532:             equal_arrow ? \"=>\" : \"->\", bef);",
          "533:  return NULL;",
          "535:     return skipwhite(s + 1);",
          "",
          "[Added Lines]",
          "538:  bef = s;",
          "539:  s = skipwhite(s);",
          "540:  if (*s != '=')",
          "541:      return NULL;",
          "542:  ++s;",
          "543:     }",
          "544:     if (*s != '>')",
          "545:  return NULL;",
          "546:     if (white_error != NULL && ((!VIM_ISWHITE(*bef) && *bef != '{')",
          "547:   || !IS_WHITE_OR_NUL(s[1])))",
          "548:     {",
          "550:  semsg(_(e_white_space_required_before_and_after_str_at_str),",
          "551:             equal_arrow ? \"=>\" : \"->\", bef);",
          "552:  return NULL;",
          "553:     }",
          "554:     return skipwhite(s + 1);",
          "555: }",
          "563:     static int",
          "564: is_function_cmd(char_u **cmd)",
          "565: {",
          "566:     char_u *p = *cmd;",
          "568:     if (checkforcmd(&p, \"function\", 2))",
          "569:     {",
          "570:  if (*p == '(')",
          "571:      return FALSE;",
          "573:  return TRUE;",
          "574:     }",
          "575:     return FALSE;",
          "576: }",
          "583:     static int",
          "584: get_function_body(",
          "585:  exarg_T     *eap,",
          "586:  garray_T    *newlines,",
          "587:  char_u     *line_arg_in,",
          "588:  char_u     **line_to_free)",
          "589: {",
          "590:     linenr_T sourcing_lnum_top = SOURCING_LNUM;",
          "591:     linenr_T sourcing_lnum_off;",
          "592:     int  saved_wait_return = need_wait_return;",
          "593:     char_u *line_arg = line_arg_in;",
          "594:     int  vim9_function = eap->cmdidx == CMD_def",
          "595:          || eap->cmdidx == CMD_block;",
          "596: #define MAX_FUNC_NESTING 50",
          "597:     char nesting_def[MAX_FUNC_NESTING];",
          "598:     int  nesting = 0;",
          "599:     getline_opt_T getline_options;",
          "600:     int  indent = 2;",
          "601:     char_u *skip_until = NULL;",
          "602:     int  ret = FAIL;",
          "603:     int  is_heredoc = FALSE;",
          "604:     char_u *heredoc_trimmed = NULL;",
          "608:     sourcing_lnum_off = get_sourced_lnum(eap->getline, eap->cookie);",
          "609:     if (SOURCING_LNUM < sourcing_lnum_off)",
          "610:     {",
          "611:  sourcing_lnum_off -= SOURCING_LNUM;",
          "612:  if (ga_grow(newlines, sourcing_lnum_off) == FAIL)",
          "613:      goto theend;",
          "614:  while (sourcing_lnum_off-- > 0)",
          "615:      ((char_u **)(newlines->ga_data))[newlines->ga_len++] = NULL;",
          "616:     }",
          "618:     nesting_def[nesting] = vim9_function;",
          "619:     getline_options = vim9_function",
          "620:     ? GETLINE_CONCAT_CONTBAR : GETLINE_CONCAT_CONT;",
          "621:     for (;;)",
          "622:     {",
          "623:  char_u *theline;",
          "624:  char_u *p;",
          "625:  char_u *arg;",
          "627:  if (KeyTyped)",
          "628:  {",
          "629:      msg_scroll = TRUE;",
          "630:      saved_wait_return = FALSE;",
          "631:  }",
          "632:  need_wait_return = FALSE;",
          "634:  if (line_arg != NULL)",
          "635:  {",
          "637:      theline = line_arg;",
          "638:      p = vim_strchr(theline, '\\n');",
          "639:      if (p == NULL)",
          "640:   line_arg += STRLEN(line_arg);",
          "641:      else",
          "642:      {",
          "644:   line_arg = p + 1;",
          "645:      }",
          "646:  }",
          "647:  else",
          "648:  {",
          "649:      vim_free(*line_to_free);",
          "650:      if (eap->getline == NULL)",
          "651:   theline = getcmdline(':', 0L, indent, getline_options);",
          "652:      else",
          "653:   theline = eap->getline(':', eap->cookie, indent,",
          "654:              getline_options);",
          "656:  }",
          "657:  if (KeyTyped)",
          "658:      lines_left = Rows - 1;",
          "659:  if (theline == NULL)",
          "660:  {",
          "662:      SOURCING_LNUM = sourcing_lnum_top;",
          "663:      if (skip_until != NULL)",
          "664:   semsg(_(e_missing_heredoc_end_marker_str), skip_until);",
          "665:      else if (eap->cmdidx == CMD_def)",
          "666:   emsg(_(e_missing_enddef));",
          "667:      else if (eap->cmdidx == CMD_block)",
          "668:   emsg(_(e_missing_end_block));",
          "669:      else",
          "670:   emsg(_(\"E126: Missing :endfunction\"));",
          "671:      goto theend;",
          "672:  }",
          "675:  sourcing_lnum_off = get_sourced_lnum(eap->getline, eap->cookie);",
          "676:  if (SOURCING_LNUM < sourcing_lnum_off)",
          "677:      sourcing_lnum_off -= SOURCING_LNUM;",
          "678:  else",
          "679:      sourcing_lnum_off = 0;",
          "681:  if (skip_until != NULL)",
          "682:  {",
          "687:      if (heredoc_trimmed == NULL",
          "688:       || (is_heredoc && skipwhite(theline) == theline)",
          "689:       || STRNCMP(theline, heredoc_trimmed,",
          "690:        STRLEN(heredoc_trimmed)) == 0)",
          "691:      {",
          "692:   if (heredoc_trimmed == NULL)",
          "693:       p = theline;",
          "694:   else if (is_heredoc)",
          "695:       p = skipwhite(theline) == theline",
          "696:      ? theline : theline + STRLEN(heredoc_trimmed);",
          "697:   else",
          "698:       p = theline + STRLEN(heredoc_trimmed);",
          "699:   if (STRCMP(p, skip_until) == 0)",
          "700:   {",
          "701:       VIM_CLEAR(skip_until);",
          "702:       VIM_CLEAR(heredoc_trimmed);",
          "703:       getline_options = vim9_function",
          "704:     ? GETLINE_CONCAT_CONTBAR : GETLINE_CONCAT_CONT;",
          "705:       is_heredoc = FALSE;",
          "706:   }",
          "707:      }",
          "708:  }",
          "709:  else",
          "710:  {",
          "711:      int c;",
          "714:      for (p = theline; VIM_ISWHITE(*p) || *p == ':'; ++p)",
          "715:   ;",
          "719:      if ((nesting == 0 && eap->cmdidx == CMD_block)",
          "720:       ? *p == '}'",
          "721:       : (checkforcmd(&p, nesting_def[nesting]",
          "722:       ? \"enddef\" : \"endfunction\", 4)",
          "723:    && *p != ':'))",
          "724:      {",
          "725:   if (nesting-- == 0)",
          "726:   {",
          "727:       char_u *nextcmd = NULL;",
          "729:       if (*p == '|' || *p == '}')",
          "730:    nextcmd = p + 1;",
          "731:       else if (line_arg != NULL && *skipwhite(line_arg) != NUL)",
          "732:    nextcmd = line_arg;",
          "733:       else if (*p != NUL && *p != (vim9_function ? '#' : '\"')",
          "734:      && p_verbose > 0",
          "735:      && eap->cmdidx != CMD_block)",
          "736:    give_warning2(eap->cmdidx == CMD_def",
          "737:        ? (char_u *)_(\"W1001: Text found after :enddef: %s\")",
          "738:        : (char_u *)_(\"W22: Text found after :endfunction: %s\"),",
          "739:         p, TRUE);",
          "740:       if (nextcmd != NULL)",
          "741:       {",
          "745:    eap->nextcmd = nextcmd;",
          "746:    if (*line_to_free != NULL)",
          "747:    {",
          "748:        vim_free(*eap->cmdlinep);",
          "751:    }",
          "752:       }",
          "753:       break;",
          "754:   }",
          "755:      }",
          "762:      else if (nesting_def[nesting])",
          "763:      {",
          "764:   if (checkforcmd(&p, \"endfunction\", 4) && *p != ':')",
          "765:       emsg(_(e_mismatched_endfunction));",
          "766:      }",
          "767:      else if (eap->cmdidx == CMD_def && checkforcmd(&p, \"enddef\", 4))",
          "768:   emsg(_(e_mismatched_enddef));",
          "772:      if (indent > 2 && (*p == '}' || STRNCMP(p, \"end\", 3) == 0))",
          "773:   indent -= 2;",
          "774:      else if (STRNCMP(p, \"if\", 2) == 0",
          "775:       || STRNCMP(p, \"wh\", 2) == 0",
          "776:       || STRNCMP(p, \"for\", 3) == 0",
          "777:       || STRNCMP(p, \"try\", 3) == 0)",
          "778:   indent += 2;",
          "783:      c = *p;",
          "784:      if (is_function_cmd(&p)",
          "785:       || (eap->cmdidx == CMD_def && checkforcmd(&p, \"def\", 3)))",
          "786:      {",
          "787:   if (*p == '!')",
          "788:       p = skipwhite(p + 1);",
          "789:   p += eval_fname_script(p);",
          "790:   vim_free(trans_function_name(&p, NULL, TRUE, 0, NULL,",
          "791:           NULL, NULL));",
          "792:   if (*skipwhite(p) == '(')",
          "793:   {",
          "794:       if (nesting == MAX_FUNC_NESTING - 1)",
          "795:    emsg(_(e_function_nesting_too_deep));",
          "796:       else",
          "797:       {",
          "798:    ++nesting;",
          "799:    nesting_def[nesting] = (c == 'd');",
          "800:    indent += 2;",
          "801:       }",
          "802:   }",
          "803:      }",
          "806:      p = skip_range(p, FALSE, NULL);",
          "807:      if (!vim9_function",
          "808:   && ((p[0] == 'a' && (!ASCII_ISALPHA(p[1]) || p[1] == 'p'))",
          "809:       || (p[0] == 'c'",
          "810:    && (!ASCII_ISALPHA(p[1]) || (p[1] == 'h'",
          "811:     && (!ASCII_ISALPHA(p[2]) || (p[2] == 'a'",
          "812:      && (STRNCMP(&p[3], \"nge\", 3) != 0",
          "813:          || !ASCII_ISALPHA(p[6])))))))",
          "814:       || (p[0] == 'i'",
          "815:    && (!ASCII_ISALPHA(p[1]) || (p[1] == 'n'",
          "816:     && (!ASCII_ISALPHA(p[2])",
          "817:         || (p[2] == 's'",
          "818:      && (!ASCII_ISALPHA(p[3])",
          "819:       || p[3] == 'e'))))))))",
          "820:   skip_until = vim_strsave((char_u *)\".\");",
          "823:      arg = skipwhite(skiptowhite(p));",
          "824:      if (arg[0] == '<' && arg[1] =='<'",
          "825:       && ((p[0] == 'p' && p[1] == 'y'",
          "826:         && (!ASCII_ISALNUM(p[2]) || p[2] == 't'",
          "827:      || ((p[2] == '3' || p[2] == 'x')",
          "828:          && !ASCII_ISALPHA(p[3]))))",
          "829:    || (p[0] == 'p' && p[1] == 'e'",
          "830:         && (!ASCII_ISALPHA(p[2]) || p[2] == 'r'))",
          "831:    || (p[0] == 't' && p[1] == 'c'",
          "832:         && (!ASCII_ISALPHA(p[2]) || p[2] == 'l'))",
          "833:    || (p[0] == 'l' && p[1] == 'u' && p[2] == 'a'",
          "834:         && !ASCII_ISALPHA(p[3]))",
          "835:    || (p[0] == 'r' && p[1] == 'u' && p[2] == 'b'",
          "836:         && (!ASCII_ISALPHA(p[3]) || p[3] == 'y'))",
          "837:    || (p[0] == 'm' && p[1] == 'z'",
          "838:         && (!ASCII_ISALPHA(p[2]) || p[2] == 's'))",
          "839:    ))",
          "840:      {",
          "842:   p = skipwhite(arg + 2);",
          "843:   if (STRNCMP(p, \"trim\", 4) == 0)",
          "844:   {",
          "846:       p = skipwhite(p + 4);",
          "847:       heredoc_trimmed = vim_strnsave(theline,",
          "848:        skipwhite(theline) - theline);",
          "849:   }",
          "850:   if (*p == NUL)",
          "851:       skip_until = vim_strsave((char_u *)\".\");",
          "852:   else",
          "853:       skip_until = vim_strnsave(p, skiptowhite(p) - p);",
          "854:   getline_options = GETLINE_NONE;",
          "855:   is_heredoc = TRUE;",
          "856:      }",
          "862:      arg = skipwhite(skiptowhite(p));",
          "863:      if (*arg == '[')",
          "864:   arg = vim_strchr(arg, ']');",
          "865:      if (arg != NULL)",
          "866:      {",
          "867:   int found = (eap->cmdidx == CMD_def && arg[0] == '='",
          "868:           && arg[1] == '<' && arg[2] =='<');",
          "870:   if (!found)",
          "872:       arg = skipwhite(skiptowhite(arg));",
          "873:   if (found || (arg[0] == '=' && arg[1] == '<' && arg[2] =='<'",
          "874:    && (checkforcmd(&p, \"let\", 2)",
          "875:        || checkforcmd(&p, \"var\", 3)",
          "876:        || checkforcmd(&p, \"final\", 5)",
          "877:        || checkforcmd(&p, \"const\", 5))))",
          "878:   {",
          "879:       p = skipwhite(arg + 3);",
          "880:       if (STRNCMP(p, \"trim\", 4) == 0)",
          "881:       {",
          "883:    p = skipwhite(p + 4);",
          "884:    heredoc_trimmed = vim_strnsave(theline,",
          "885:        skipwhite(theline) - theline);",
          "886:       }",
          "887:       skip_until = vim_strnsave(p, skiptowhite(p) - p);",
          "888:       getline_options = GETLINE_NONE;",
          "889:       is_heredoc = TRUE;",
          "890:   }",
          "891:      }",
          "892:  }",
          "895:  if (ga_grow(newlines, 1 + sourcing_lnum_off) == FAIL)",
          "896:      goto theend;",
          "901:  p = vim_strsave(theline);",
          "902:  if (p == NULL)",
          "903:      goto theend;",
          "904:  ((char_u **)(newlines->ga_data))[newlines->ga_len++] = p;",
          "908:  while (sourcing_lnum_off-- > 0)",
          "909:      ((char_u **)(newlines->ga_data))[newlines->ga_len++] = NULL;",
          "912:  if (line_arg != NULL && *line_arg == NUL)",
          "913:      line_arg = NULL;",
          "914:     }",
          "918:     if (!eap->skip && !did_emsg)",
          "919:  ret = OK;",
          "921: theend:",
          "922:     vim_free(skip_until);",
          "923:     vim_free(heredoc_trimmed);",
          "924:     need_wait_return |= saved_wait_return;",
          "925:     return ret;",
          "926: }",
          "933:     static int",
          "934: lambda_function_body(",
          "935:  char_u     **arg,",
          "936:  typval_T    *rettv,",
          "937:  evalarg_T   *evalarg,",
          "938:  garray_T    *newargs,",
          "939:  garray_T    *argtypes,",
          "940:  int     varargs,",
          "941:  garray_T    *default_args,",
          "942:  char_u     *ret_type)",
          "943: {",
          "944:     int  evaluate = evalarg != NULL",
          "945:           && (evalarg->eval_flags & EVAL_EVALUATE);",
          "946:     ufunc_T *ufunc;",
          "947:     exarg_T eap;",
          "948:     garray_T newlines;",
          "949:     char_u *cmdline = NULL;",
          "950:     int  ret = FAIL;",
          "951:     char_u *line_to_free = NULL;",
          "952:     partial_T *pt;",
          "953:     char_u *name;",
          "954:     int  lnum_save = -1;",
          "955:     linenr_T sourcing_lnum_top = SOURCING_LNUM;",
          "957:     CLEAR_FIELD(eap);",
          "958:     eap.cmdidx = CMD_block;",
          "959:     eap.forceit = FALSE;",
          "960:     eap.arg = *arg + 1;",
          "961:     eap.cmdlinep = &cmdline;",
          "962:     eap.skip = !evaluate;",
          "963:     if (evalarg->eval_cctx != NULL)",
          "964:  fill_exarg_from_cctx(&eap, evalarg->eval_cctx);",
          "965:     else",
          "966:     {",
          "967:  eap.getline = evalarg->eval_getline;",
          "968:  eap.cookie = evalarg->eval_cookie;",
          "969:     }",
          "971:     ga_init2(&newlines, (int)sizeof(char_u *), 10);",
          "972:     if (get_function_body(&eap, &newlines, NULL, &line_to_free) == FAIL)",
          "973:  goto erret;",
          "974:     if (cmdline != NULL)",
          "975:     {",
          "978:  if (evalarg->eval_cctx == NULL)",
          "979:  {",
          "981:      vim_free(evalarg->eval_tofree_lambda);",
          "982:      evalarg->eval_tofree_lambda = cmdline;",
          "983:  }",
          "985:     else",
          "988:     name = get_lambda_name();",
          "989:     ufunc = alloc_clear(offsetof(ufunc_T, uf_name) + STRLEN(name) + 1);",
          "990:     if (ufunc == NULL)",
          "991:  goto erret;",
          "992:     set_ufunc_name(ufunc, name);",
          "993:     if (hash_add(&func_hashtab, UF2HIKEY(ufunc)) == FAIL)",
          "995:  vim_free(ufunc);",
          "996:  goto erret;",
          "998:     ufunc->uf_refcount = 1;",
          "999:     ufunc->uf_args = *newargs;",
          "1000:     newargs->ga_data = NULL;",
          "1001:     ufunc->uf_def_args = *default_args;",
          "1002:     default_args->ga_data = NULL;",
          "1003:     ufunc->uf_func_type = &t_func_any;",
          "1006:     lnum_save = SOURCING_LNUM;",
          "1007:     SOURCING_LNUM = sourcing_lnum_top;",
          "1010:     if (parse_argument_types(ufunc, argtypes, varargs) == FAIL)",
          "1011:     {",
          "1012:  SOURCING_LNUM = lnum_save;",
          "1013:  goto erret;",
          "1014:     }",
          "1017:     if (parse_return_type(ufunc, ret_type) == FAIL)",
          "1018:  goto erret;",
          "1020:     pt = ALLOC_CLEAR_ONE(partial_T);",
          "1021:     if (pt == NULL)",
          "1022:  goto erret;",
          "1023:     pt->pt_func = ufunc;",
          "1024:     pt->pt_refcount = 1;",
          "1026:     ufunc->uf_lines = newlines;",
          "1027:     newlines.ga_data = NULL;",
          "1028:     if (sandbox)",
          "1029:  ufunc->uf_flags |= FC_SANDBOX;",
          "1030:     if (!ASCII_ISUPPER(*ufunc->uf_name))",
          "1031:  ufunc->uf_flags |= FC_VIM9;",
          "1032:     ufunc->uf_script_ctx = current_sctx;",
          "1033:     ufunc->uf_script_ctx_version = current_sctx.sc_version;",
          "1034:     ufunc->uf_script_ctx.sc_lnum += sourcing_lnum_top;",
          "1035:     set_function_type(ufunc);",
          "1037:     rettv->vval.v_partial = pt;",
          "1038:     rettv->v_type = VAR_PARTIAL;",
          "1039:     ret = OK;",
          "1041: erret:",
          "1042:     if (lnum_save >= 0)",
          "1043:  SOURCING_LNUM = lnum_save;",
          "1044:     vim_free(line_to_free);",
          "1045:     ga_clear_strings(&newlines);",
          "1046:     ga_clear_strings(newargs);",
          "1047:     ga_clear_strings(default_args);",
          "1048:     return ret;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "554:     garray_T newlines;",
          "555:     garray_T *pnewargs;",
          "556:     garray_T argtypes;",
          "557:     ufunc_T *fp = NULL;",
          "558:     partial_T   *pt = NULL;",
          "559:     int  varargs;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1070:     garray_T default_args;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "597:     ret = get_function_args(arg, equal_arrow ? ')' : '-', pnewargs,",
          "598:      types_optional ? &argtypes : NULL, types_optional, evalarg,",
          "600:     if (ret == FAIL",
          "601:     || (s = skip_arrow(*arg, equal_arrow, &ret_type,",
          "602:   equal_arrow || in_vim9script() ? &white_error : NULL)) == NULL)",
          "",
          "[Removed Lines]",
          "599:          &varargs, NULL, FALSE, NULL, NULL);",
          "",
          "[Added Lines]",
          "1113:          &varargs, &default_args,",
          "1114:          FALSE, NULL, NULL);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "625:     if (equal_arrow && **arg == '{')",
          "626:     {",
          "630:  goto errret;",
          "631:     }",
          "",
          "[Removed Lines]",
          "629:  emsg(\"Lambda function body not supported yet\");",
          "",
          "[Added Lines]",
          "1142:  if (lambda_function_body(arg, rettv, evalarg, pnewargs,",
          "1143:       types_optional ? &argtypes : NULL, varargs,",
          "1144:       &default_args, ret_type) == FAIL)",
          "1145:      goto errret;",
          "1146:  goto theend;",
          "1147:     }",
          "1148:     if (default_args.ga_len > 0)",
          "1149:     {",
          "1150:  emsg(_(e_cannot_use_default_values_in_lambda));",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "732:  hash_add(&func_hashtab, UF2HIKEY(fp));",
          "733:     }",
          "735:     eval_lavars_used = old_eval_lavars;",
          "736:     if (evalarg != NULL && evalarg->eval_tofree == NULL)",
          "737:  evalarg->eval_tofree = tofree1;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1256: theend:",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "745: errret:",
          "746:     ga_clear_strings(&newargs);",
          "747:     ga_clear_strings(&newlines);",
          "748:     if (types_optional)",
          "749:  ga_clear_strings(&argtypes);",
          "750:     vim_free(fp);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1270:     ga_clear_strings(&default_args);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "2459:     {",
          "2461:  if (check_argument_types(funcexe->check_type, argvars, argcount,",
          "2463:      error = FCERR_OTHER;",
          "2464:     }",
          "",
          "[Removed Lines]",
          "2462:          name) == FAIL)",
          "",
          "[Added Lines]",
          "2985:          (name != NULL) ? name : funcname) == FAIL)",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "3005:     }",
          "3006: }",
          "",
          "[Removed Lines]",
          "3014:     static int",
          "3015: is_function_cmd(char_u **cmd)",
          "3016: {",
          "3017:     char_u *p = *cmd;",
          "3019:     if (checkforcmd(&p, \"function\", 2))",
          "3020:     {",
          "3021:  if (*p == '(')",
          "3022:      return FALSE;",
          "3024:  return TRUE;",
          "3025:     }",
          "3026:     return FALSE;",
          "3027: }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "3035:     ufunc_T *",
          "3036: define_function(exarg_T *eap, char_u *name_arg)",
          "3037: {",
          "3039:     char_u *line_to_free = NULL;",
          "3040:     int  j;",
          "3041:     int  c;",
          "3042:     int  saved_did_emsg;",
          "3044:     char_u *name = name_arg;",
          "3045:     int  is_global = FALSE;",
          "3046:     char_u *p;",
          "",
          "[Removed Lines]",
          "3038:     char_u *theline;",
          "3043:     int  saved_wait_return = need_wait_return;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "3056:     char_u *ret_type = NULL;",
          "3057:     ufunc_T *fp = NULL;",
          "3058:     int  overwrite = FALSE;",
          "3063:     dictitem_T *v;",
          "3064:     funcdict_T fudi;",
          "3065:     static int func_nr = 0;     // number for nameless function",
          "3066:     int  paren;",
          "3067:     hashitem_T *hi;",
          "3070:     linenr_T sourcing_lnum_top;",
          "3074:     int  vim9script = in_vim9script();",
          "3075:     imported_T *import = NULL;",
          "",
          "[Removed Lines]",
          "3059:     int  indent;",
          "3060:     int  nesting;",
          "3061: #define MAX_FUNC_NESTING 50",
          "3062:     char nesting_def[MAX_FUNC_NESTING];",
          "3068:     getline_opt_T getline_options;",
          "3069:     linenr_T sourcing_lnum_off;",
          "3071:     int  is_heredoc = FALSE;",
          "3072:     char_u *skip_until = NULL;",
          "3073:     char_u *heredoc_trimmed = NULL;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "3263:  goto ret_free;",
          "3264:     }",
          "3268:     if (!eap->skip && name_arg == NULL)",
          "3269:     {",
          "",
          "[Removed Lines]",
          "3266:     ga_init2(&newlines, (int)sizeof(char_u *), 3);",
          "",
          "[Added Lines]",
          "3757:     ga_init2(&newlines, (int)sizeof(char_u *), 10);",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "3305:     if (eap->cmdidx == CMD_def)",
          "3306:     {",
          "3499:      }",
          "3500:  }",
          "3502:  {",
          "3512:      {",
          "3541:      }",
          "3549:      {",
          "3552:      }",
          "3572:      {",
          "3589:      }",
          "3626:      {",
          "3630:   {",
          "3635:   }",
          "3642:      }",
          "3678:  }",
          "3689:      goto erret;",
          "3700:     }",
          "3705:  goto erret;",
          "",
          "[Removed Lines]",
          "3308:  if (*p == ':')",
          "3309:  {",
          "3310:      ret_type = skipwhite(p + 1);",
          "3311:      p = skip_type(ret_type, FALSE);",
          "3312:      if (p > ret_type)",
          "3313:      {",
          "3314:   ret_type = vim_strnsave(ret_type, p - ret_type);",
          "3315:   whitep = p;",
          "3316:   p = skipwhite(p);",
          "3317:      }",
          "3318:      else",
          "3319:      {",
          "3320:   semsg(_(e_expected_type_str), ret_type);",
          "3321:   ret_type = NULL;",
          "3322:      }",
          "3323:  }",
          "3324:  p = skipwhite(p);",
          "3325:     }",
          "3326:     else",
          "3328:  for (;;)",
          "3329:  {",
          "3330:      whitep = p;",
          "3331:      p = skipwhite(p);",
          "3332:      if (STRNCMP(p, \"range\", 5) == 0)",
          "3333:      {",
          "3334:   flags |= FC_RANGE;",
          "3335:   p += 5;",
          "3336:      }",
          "3337:      else if (STRNCMP(p, \"dict\", 4) == 0)",
          "3338:      {",
          "3339:   flags |= FC_DICT;",
          "3340:   p += 4;",
          "3341:      }",
          "3342:      else if (STRNCMP(p, \"abort\", 5) == 0)",
          "3343:      {",
          "3344:   flags |= FC_ABORT;",
          "3345:   p += 5;",
          "3346:      }",
          "3347:      else if (STRNCMP(p, \"closure\", 7) == 0)",
          "3348:      {",
          "3349:   flags |= FC_CLOSURE;",
          "3350:   p += 7;",
          "3351:   if (current_funccal == NULL)",
          "3352:   {",
          "3353:       emsg_funcname(N_(\"E932: Closure function should not be at top level: %s\"),",
          "3354:        name == NULL ? (char_u *)\"\" : name);",
          "3355:       goto erret;",
          "3356:   }",
          "3357:      }",
          "3358:      else",
          "3359:   break;",
          "3360:  }",
          "3364:     if (*p == '\\n')",
          "3365:  line_arg = p + 1;",
          "3366:     else if (*p != NUL",
          "3367:      && !(*p == '\"' && (!vim9script || eap->cmdidx == CMD_function)",
          "3368:            && eap->cmdidx != CMD_def)",
          "3369:      && !(VIM_ISWHITE(*whitep) && *p == '#'",
          "3370:          && (vim9script || eap->cmdidx == CMD_def))",
          "3371:      && !eap->skip",
          "3372:      && !did_emsg)",
          "3373:  semsg(_(e_trailing_arg), p);",
          "3379:     if (KeyTyped)",
          "3380:     {",
          "3384:  if (!eap->skip && !eap->forceit)",
          "3385:  {",
          "3386:      if (fudi.fd_dict != NULL && fudi.fd_newkey == NULL)",
          "3387:   emsg(_(e_funcdict));",
          "3388:      else if (name != NULL && find_func(name, is_global, NULL) != NULL)",
          "3389:   emsg_funcname(e_funcexts, name);",
          "3390:  }",
          "3392:  if (!eap->skip && did_emsg)",
          "3393:      goto erret;",
          "3395:  msg_putchar('\\n');     // don't overwrite the function name",
          "3396:  cmdline_row = msg_row;",
          "3397:     }",
          "3400:     sourcing_lnum_top = SOURCING_LNUM;",
          "3404:     sourcing_lnum_off = get_sourced_lnum(eap->getline, eap->cookie);",
          "3405:     if (SOURCING_LNUM < sourcing_lnum_off)",
          "3406:     {",
          "3407:  sourcing_lnum_off -= SOURCING_LNUM;",
          "3408:  if (ga_grow(&newlines, sourcing_lnum_off) == FAIL)",
          "3409:      goto erret;",
          "3410:  while (sourcing_lnum_off-- > 0)",
          "3411:      ((char_u **)(newlines.ga_data))[newlines.ga_len++] = NULL;",
          "3412:     }",
          "3414:     indent = 2;",
          "3415:     nesting = 0;",
          "3416:     nesting_def[nesting] = (eap->cmdidx == CMD_def);",
          "3417:     getline_options = eap->cmdidx == CMD_def",
          "3418:     ? GETLINE_CONCAT_CONTBAR : GETLINE_CONCAT_CONT;",
          "3419:     for (;;)",
          "3420:     {",
          "3421:  if (KeyTyped)",
          "3422:  {",
          "3423:      msg_scroll = TRUE;",
          "3424:      saved_wait_return = FALSE;",
          "3425:  }",
          "3426:  need_wait_return = FALSE;",
          "3428:  if (line_arg != NULL)",
          "3429:  {",
          "3431:      theline = line_arg;",
          "3432:      p = vim_strchr(theline, '\\n');",
          "3433:      if (p == NULL)",
          "3434:   line_arg += STRLEN(line_arg);",
          "3435:      else",
          "3436:      {",
          "3438:   line_arg = p + 1;",
          "3439:      }",
          "3440:  }",
          "3441:  else",
          "3442:  {",
          "3443:      vim_free(line_to_free);",
          "3444:      if (eap->getline == NULL)",
          "3445:   theline = getcmdline(':', 0L, indent, getline_options);",
          "3446:      else",
          "3447:   theline = eap->getline(':', eap->cookie, indent,",
          "3448:              getline_options);",
          "3449:      line_to_free = theline;",
          "3450:  }",
          "3451:  if (KeyTyped)",
          "3452:      lines_left = Rows - 1;",
          "3453:  if (theline == NULL)",
          "3454:  {",
          "3456:      SOURCING_LNUM = sourcing_lnum_top;",
          "3457:      if (skip_until != NULL)",
          "3458:   semsg(_(e_missing_heredoc_end_marker_str), skip_until);",
          "3459:      else if (eap->cmdidx == CMD_def)",
          "3460:   emsg(_(e_missing_enddef));",
          "3461:      else",
          "3462:   emsg(_(\"E126: Missing :endfunction\"));",
          "3463:      goto erret;",
          "3464:  }",
          "3467:  sourcing_lnum_off = get_sourced_lnum(eap->getline, eap->cookie);",
          "3468:  if (SOURCING_LNUM < sourcing_lnum_off)",
          "3469:      sourcing_lnum_off -= SOURCING_LNUM;",
          "3470:  else",
          "3471:      sourcing_lnum_off = 0;",
          "3473:  if (skip_until != NULL)",
          "3474:  {",
          "3479:      if (heredoc_trimmed == NULL",
          "3480:       || (is_heredoc && skipwhite(theline) == theline)",
          "3481:       || STRNCMP(theline, heredoc_trimmed,",
          "3482:        STRLEN(heredoc_trimmed)) == 0)",
          "3483:      {",
          "3484:   if (heredoc_trimmed == NULL)",
          "3485:       p = theline;",
          "3486:   else if (is_heredoc)",
          "3487:       p = skipwhite(theline) == theline",
          "3488:      ? theline : theline + STRLEN(heredoc_trimmed);",
          "3489:   else",
          "3490:       p = theline + STRLEN(heredoc_trimmed);",
          "3491:   if (STRCMP(p, skip_until) == 0)",
          "3492:   {",
          "3493:       VIM_CLEAR(skip_until);",
          "3494:       VIM_CLEAR(heredoc_trimmed);",
          "3495:       getline_options = eap->cmdidx == CMD_def",
          "3496:     ? GETLINE_CONCAT_CONTBAR : GETLINE_CONCAT_CONT;",
          "3497:       is_heredoc = FALSE;",
          "3498:   }",
          "3501:  else",
          "3504:      for (p = theline; VIM_ISWHITE(*p) || *p == ':'; ++p)",
          "3505:   ;",
          "3509:      if (checkforcmd(&p, nesting_def[nesting]",
          "3510:       ? \"enddef\" : \"endfunction\", 4)",
          "3511:       && *p != ':')",
          "3513:   if (nesting-- == 0)",
          "3514:   {",
          "3515:       char_u *nextcmd = NULL;",
          "3517:       if (*p == '|')",
          "3518:    nextcmd = p + 1;",
          "3519:       else if (line_arg != NULL && *skipwhite(line_arg) != NUL)",
          "3520:    nextcmd = line_arg;",
          "3521:       else if (*p != NUL && *p != '\"' && p_verbose > 0)",
          "3522:    give_warning2(eap->cmdidx == CMD_def",
          "3523:        ? (char_u *)_(\"W1001: Text found after :enddef: %s\")",
          "3524:        : (char_u *)_(\"W22: Text found after :endfunction: %s\"),",
          "3525:         p, TRUE);",
          "3526:       if (nextcmd != NULL)",
          "3527:       {",
          "3531:    eap->nextcmd = nextcmd;",
          "3532:    if (line_to_free != NULL)",
          "3533:    {",
          "3534:        vim_free(*eap->cmdlinep);",
          "3536:        line_to_free = NULL;",
          "3537:    }",
          "3538:       }",
          "3539:       break;",
          "3540:   }",
          "3548:      else if (nesting_def[nesting])",
          "3550:   if (checkforcmd(&p, \"endfunction\", 4) && *p != ':')",
          "3551:       emsg(_(e_mismatched_endfunction));",
          "3553:      else if (eap->cmdidx == CMD_def && checkforcmd(&p, \"enddef\", 4))",
          "3554:   emsg(_(e_mismatched_enddef));",
          "3558:      if (indent > 2 && (*p == '}' || STRNCMP(p, \"end\", 3) == 0))",
          "3559:   indent -= 2;",
          "3560:      else if (STRNCMP(p, \"if\", 2) == 0",
          "3561:       || STRNCMP(p, \"wh\", 2) == 0",
          "3562:       || STRNCMP(p, \"for\", 3) == 0",
          "3563:       || STRNCMP(p, \"try\", 3) == 0)",
          "3564:   indent += 2;",
          "3569:      c = *p;",
          "3570:      if (is_function_cmd(&p)",
          "3571:       || (eap->cmdidx == CMD_def && checkforcmd(&p, \"def\", 3)))",
          "3573:   if (*p == '!')",
          "3574:       p = skipwhite(p + 1);",
          "3575:   p += eval_fname_script(p);",
          "3576:   vim_free(trans_function_name(&p, NULL, TRUE, 0, NULL,",
          "3577:           NULL, NULL));",
          "3578:   if (*skipwhite(p) == '(')",
          "3579:   {",
          "3580:       if (nesting == MAX_FUNC_NESTING - 1)",
          "3581:    emsg(_(e_function_nesting_too_deep));",
          "3582:       else",
          "3583:       {",
          "3584:    ++nesting;",
          "3585:    nesting_def[nesting] = (c == 'd');",
          "3586:    indent += 2;",
          "3587:       }",
          "3588:   }",
          "3592:      p = skip_range(p, FALSE, NULL);",
          "3593:      if (eap->cmdidx != CMD_def",
          "3594:   && ((p[0] == 'a' && (!ASCII_ISALPHA(p[1]) || p[1] == 'p'))",
          "3595:       || (p[0] == 'c'",
          "3596:    && (!ASCII_ISALPHA(p[1]) || (p[1] == 'h'",
          "3597:     && (!ASCII_ISALPHA(p[2]) || (p[2] == 'a'",
          "3598:      && (STRNCMP(&p[3], \"nge\", 3) != 0",
          "3599:          || !ASCII_ISALPHA(p[6])))))))",
          "3600:       || (p[0] == 'i'",
          "3601:    && (!ASCII_ISALPHA(p[1]) || (p[1] == 'n'",
          "3602:     && (!ASCII_ISALPHA(p[2])",
          "3603:         || (p[2] == 's'",
          "3604:      && (!ASCII_ISALPHA(p[3])",
          "3605:       || p[3] == 'e'))))))))",
          "3606:   skip_until = vim_strsave((char_u *)\".\");",
          "3609:      arg = skipwhite(skiptowhite(p));",
          "3610:      if (arg[0] == '<' && arg[1] =='<'",
          "3611:       && ((p[0] == 'p' && p[1] == 'y'",
          "3612:         && (!ASCII_ISALNUM(p[2]) || p[2] == 't'",
          "3613:      || ((p[2] == '3' || p[2] == 'x')",
          "3614:          && !ASCII_ISALPHA(p[3]))))",
          "3615:    || (p[0] == 'p' && p[1] == 'e'",
          "3616:         && (!ASCII_ISALPHA(p[2]) || p[2] == 'r'))",
          "3617:    || (p[0] == 't' && p[1] == 'c'",
          "3618:         && (!ASCII_ISALPHA(p[2]) || p[2] == 'l'))",
          "3619:    || (p[0] == 'l' && p[1] == 'u' && p[2] == 'a'",
          "3620:         && !ASCII_ISALPHA(p[3]))",
          "3621:    || (p[0] == 'r' && p[1] == 'u' && p[2] == 'b'",
          "3622:         && (!ASCII_ISALPHA(p[3]) || p[3] == 'y'))",
          "3623:    || (p[0] == 'm' && p[1] == 'z'",
          "3624:         && (!ASCII_ISALPHA(p[2]) || p[2] == 's'))",
          "3625:    ))",
          "3628:   p = skipwhite(arg + 2);",
          "3629:   if (STRNCMP(p, \"trim\", 4) == 0)",
          "3632:       p = skipwhite(p + 4);",
          "3633:       heredoc_trimmed = vim_strnsave(theline,",
          "3634:        skipwhite(theline) - theline);",
          "3636:   if (*p == NUL)",
          "3637:       skip_until = vim_strsave((char_u *)\".\");",
          "3638:   else",
          "3639:       skip_until = vim_strnsave(p, skiptowhite(p) - p);",
          "3640:   getline_options = GETLINE_NONE;",
          "3641:   is_heredoc = TRUE;",
          "3648:      arg = skipwhite(skiptowhite(p));",
          "3649:      if (*arg == '[')",
          "3650:   arg = vim_strchr(arg, ']');",
          "3651:      if (arg != NULL)",
          "3652:      {",
          "3653:   int found = (eap->cmdidx == CMD_def && arg[0] == '='",
          "3654:           && arg[1] == '<' && arg[2] =='<');",
          "3656:   if (!found)",
          "3658:       arg = skipwhite(skiptowhite(arg));",
          "3659:   if (found || (arg[0] == '=' && arg[1] == '<' && arg[2] =='<'",
          "3660:    && (checkforcmd(&p, \"let\", 2)",
          "3661:        || checkforcmd(&p, \"var\", 3)",
          "3662:        || checkforcmd(&p, \"final\", 5)",
          "3663:        || checkforcmd(&p, \"const\", 5))))",
          "3664:   {",
          "3665:       p = skipwhite(arg + 3);",
          "3666:       if (STRNCMP(p, \"trim\", 4) == 0)",
          "3667:       {",
          "3669:    p = skipwhite(p + 4);",
          "3670:    heredoc_trimmed = vim_strnsave(theline,",
          "3671:        skipwhite(theline) - theline);",
          "3672:       }",
          "3673:       skip_until = vim_strnsave(p, skiptowhite(p) - p);",
          "3674:       getline_options = GETLINE_NONE;",
          "3675:       is_heredoc = TRUE;",
          "3676:   }",
          "3677:      }",
          "3681:  if (ga_grow(&newlines, 1 + sourcing_lnum_off) == FAIL)",
          "3682:      goto erret;",
          "3687:  p = vim_strsave(theline);",
          "3688:  if (p == NULL)",
          "3690:  ((char_u **)(newlines.ga_data))[newlines.ga_len++] = p;",
          "3694:  while (sourcing_lnum_off-- > 0)",
          "3695:      ((char_u **)(newlines.ga_data))[newlines.ga_len++] = NULL;",
          "3698:  if (line_arg != NULL && *line_arg == NUL)",
          "3699:      line_arg = NULL;",
          "3704:     if (eap->skip || did_emsg)",
          "",
          "[Added Lines]",
          "3799:  if (*p == ':')",
          "3800:  {",
          "3801:      ret_type = skipwhite(p + 1);",
          "3802:      p = skip_type(ret_type, FALSE);",
          "3803:      if (p > ret_type)",
          "3804:      {",
          "3805:   ret_type = vim_strnsave(ret_type, p - ret_type);",
          "3806:   whitep = p;",
          "3807:   p = skipwhite(p);",
          "3808:      }",
          "3809:      else",
          "3810:      {",
          "3811:   semsg(_(e_expected_type_str), ret_type);",
          "3812:   ret_type = NULL;",
          "3815:  p = skipwhite(p);",
          "3816:     }",
          "3817:     else",
          "3819:  for (;;)",
          "3821:      whitep = p;",
          "3822:      p = skipwhite(p);",
          "3823:      if (STRNCMP(p, \"range\", 5) == 0)",
          "3825:   flags |= FC_RANGE;",
          "3826:   p += 5;",
          "3828:      else if (STRNCMP(p, \"dict\", 4) == 0)",
          "3830:   flags |= FC_DICT;",
          "3831:   p += 4;",
          "3833:      else if (STRNCMP(p, \"abort\", 5) == 0)",
          "3835:   flags |= FC_ABORT;",
          "3836:   p += 5;",
          "3838:      else if (STRNCMP(p, \"closure\", 7) == 0)",
          "3840:   flags |= FC_CLOSURE;",
          "3841:   p += 7;",
          "3842:   if (current_funccal == NULL)",
          "3844:       emsg_funcname(N_(\"E932: Closure function should not be at top level: %s\"),",
          "3845:        name == NULL ? (char_u *)\"\" : name);",
          "3846:       goto erret;",
          "3849:      else",
          "3850:   break;",
          "3851:  }",
          "3855:     if (*p == '\\n')",
          "3856:  line_arg = p + 1;",
          "3857:     else if (*p != NUL",
          "3858:      && !(*p == '\"' && (!vim9script || eap->cmdidx == CMD_function)",
          "3859:            && eap->cmdidx != CMD_def)",
          "3860:      && !(VIM_ISWHITE(*whitep) && *p == '#'",
          "3861:          && (vim9script || eap->cmdidx == CMD_def))",
          "3862:      && !eap->skip",
          "3863:      && !did_emsg)",
          "3864:  semsg(_(e_trailing_arg), p);",
          "3870:     if (KeyTyped)",
          "3871:     {",
          "3875:  if (!eap->skip && !eap->forceit)",
          "3876:  {",
          "3877:      if (fudi.fd_dict != NULL && fudi.fd_newkey == NULL)",
          "3878:   emsg(_(e_funcdict));",
          "3879:      else if (name != NULL && find_func(name, is_global, NULL) != NULL)",
          "3880:   emsg_funcname(e_funcexts, name);",
          "3883:  if (!eap->skip && did_emsg)",
          "3886:  msg_putchar('\\n');     // don't overwrite the function name",
          "3887:  cmdline_row = msg_row;",
          "3891:     sourcing_lnum_top = SOURCING_LNUM;",
          "3893:     if (get_function_body(eap, &newlines, line_arg, &line_to_free) == FAIL)",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "3933:  varargs = FALSE;",
          "3939:  {",
          "3948:  }",
          "3949:  SOURCING_LNUM = lnum_save;",
          "3950:     }",
          "",
          "[Removed Lines]",
          "3936:  if (ret_type == NULL)",
          "3937:      fp->uf_ret_type = &t_void;",
          "3938:  else",
          "3940:      p = ret_type;",
          "3941:      fp->uf_ret_type = parse_type(&p, &fp->uf_type_list, TRUE);",
          "3942:      if (fp->uf_ret_type == NULL)",
          "3943:      {",
          "3944:   fp->uf_ret_type = &t_void;",
          "3945:   SOURCING_LNUM = lnum_save;",
          "3946:   goto erret;",
          "3947:      }",
          "",
          "[Added Lines]",
          "4125:  if (parse_return_type(fp, ret_type) == FAIL)",
          "4127:      SOURCING_LNUM = lnum_save;",
          "4128:      goto erret;",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "4004:  VIM_CLEAR(fp->uf_arg_types);",
          "4005: ret_free:",
          "4006:     ga_clear_strings(&argtypes);",
          "4009:     vim_free(line_to_free);",
          "4010:     vim_free(fudi.fd_newkey);",
          "4011:     if (name != name_arg)",
          "4012:  vim_free(name);",
          "4013:     vim_free(ret_type);",
          "4014:     did_emsg |= saved_did_emsg;",
          "4017:     return fp;",
          "4018: }",
          "",
          "[Removed Lines]",
          "4007:     vim_free(skip_until);",
          "4008:     vim_free(heredoc_trimmed);",
          "4015:     need_wait_return |= saved_wait_return;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/version.c||src/version.c": [
          "File: src/version.c -> src/version.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "751: static int included_patches[] =",
          "754:     2634,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "754:     2635,",
          "",
          "---------------"
        ],
        "src/vim9compile.c||src/vim9compile.c": [
          "File: src/vim9compile.c -> src/vim9compile.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "5126:     }",
          "5127: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "5129:     void",
          "5130: fill_exarg_from_cctx(exarg_T *eap, cctx_T *cctx)",
          "5131: {",
          "5132:     eap->getline = exarg_getline;",
          "5133:     eap->cookie = cctx;",
          "5134: }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "5176:  return NULL;",
          "5178:     eap->arg = name_end;",
          "5182:     eap->forceit = FALSE;",
          "5183:     lambda_name = vim_strsave(get_lambda_name());",
          "5184:     if (lambda_name == NULL)",
          "",
          "[Removed Lines]",
          "5179:     eap->getline = exarg_getline;",
          "5180:     eap->cookie = cctx;",
          "5181:     eap->skip = cctx->ctx_skip == SKIP_YES;",
          "",
          "[Added Lines]",
          "5186:     fill_exarg_from_cctx(eap, cctx);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "7473a84cf935f64ddd4ea7fe7eee0f9c51c50b60",
      "candidate_info": {
        "commit_hash": "7473a84cf935f64ddd4ea7fe7eee0f9c51c50b60",
        "repo": "vim/vim",
        "commit_url": "https://github.com/vim/vim/commit/7473a84cf935f64ddd4ea7fe7eee0f9c51c50b60",
        "files": [
          "src/errors.h",
          "src/testdir/test_vim9_func.vim",
          "src/userfunc.c",
          "src/version.c",
          "src/vim9compile.c"
        ],
        "message": "patch 8.2.3924: Vim9: no error if something follows :enddef\n\nProblem:    Vim9: no error if something follows :enddef in a nested function.\nSolution:   Give an error.  Move common code to a function.",
        "before_after_code_files": [
          "src/errors.h||src/errors.h",
          "src/testdir/test_vim9_func.vim||src/testdir/test_vim9_func.vim",
          "src/userfunc.c||src/userfunc.c",
          "src/version.c||src/version.c",
          "src/vim9compile.c||src/vim9compile.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/testdir/test_vim9_func.vim||src/testdir/test_vim9_func.vim",
            "src/userfunc.c||src/userfunc.c",
            "src/version.c||src/version.c",
            "src/vim9compile.c||src/vim9compile.c"
          ],
          "candidate": [
            "src/testdir/test_vim9_func.vim||src/testdir/test_vim9_func.vim",
            "src/userfunc.c||src/userfunc.c",
            "src/version.c||src/version.c",
            "src/vim9compile.c||src/vim9compile.c"
          ]
        }
      },
      "candidate_diff": {
        "src/errors.h||src/errors.h": [
          "File: src/errors.h -> src/errors.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "717:  INIT(= N_(\"E1171: Missing } after inline function\"));",
          "718: EXTERN char e_cannot_use_default_values_in_lambda[]",
          "719:  INIT(= N_(\"E1172: Cannot use default values in a lambda\"));",
          "722: EXTERN char e_string_required_for_argument_nr[]",
          "723:  INIT(= N_(\"E1174: String required for argument %d\"));",
          "724: EXTERN char e_non_empty_string_required_for_argument_nr[]",
          "",
          "[Removed Lines]",
          "720: EXTERN char e_text_found_after_enddef_str[]",
          "721:  INIT(= N_(\"E1173: Text found after enddef: %s\"));",
          "",
          "[Added Lines]",
          "720: EXTERN char e_text_found_after_str_str[]",
          "721:  INIT(= N_(\"E1173: Text found after %s: %s\"));",
          "",
          "---------------"
        ],
        "src/testdir/test_vim9_func.vim||src/testdir/test_vim9_func.vim": [
          "File: src/testdir/test_vim9_func.vim -> src/testdir/test_vim9_func.vim",
          "--- Hunk 1 ---",
          "[Context before]",
          "1686:       # Compile all functions",
          "1687:       defcompile",
          "1688:   END",
          "1690: enddef",
          "1692: def Test_nested_function_with_args_split()",
          "",
          "[Removed Lines]",
          "1689:   CheckScriptFailure(lines, 'E476: Invalid command: AAAAA')",
          "",
          "[Added Lines]",
          "1689:   CheckScriptFailure(lines, 'E1173: Text found after enddef: BBBB')",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1703:       # Compile all functions",
          "1704:       defcompile",
          "1705:   END",
          "1708: enddef",
          "1710: def Test_return_type_wrong()",
          "",
          "[Removed Lines]",
          "1706:   # FIXME: this should fail on the BBBB",
          "1707:   CheckScriptSuccess(lines)",
          "",
          "[Added Lines]",
          "1706:   CheckScriptFailure(lines, 'E1173: Text found after enddef: BBBB')",
          "1708:   lines =<< trim END",
          "1709:       vim9script",
          "1710:       def FirstFunction()",
          "1711:         func SecondFunction()",
          "1712:         endfunc|BBBB",
          "1713:       enddef",
          "1714:       defcompile",
          "1715:   END",
          "1716:   CheckScriptFailure(lines, 'E1173: Text found after endfunction: BBBB')",
          "",
          "---------------"
        ],
        "src/userfunc.c||src/userfunc.c": [
          "File: src/userfunc.c -> src/userfunc.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "165:     return p;",
          "166: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "173:     static char_u *",
          "174: get_function_line(",
          "175:  exarg_T  *eap,",
          "176:  char_u  **line_to_free,",
          "177:  getline_opt_T getline_options,",
          "178:  int  indent)",
          "179: {",
          "180:     char_u *theline;",
          "182:     if (eap->getline == NULL)",
          "183:  theline = getcmdline(':', 0L, indent, getline_options);",
          "184:     else",
          "185:  theline = eap->getline(':', eap->cookie, indent, getline_options);",
          "186:     if (theline != NULL)",
          "187:     {",
          "188:  if (*eap->cmdlinep == *line_to_free)",
          "190:  vim_free(*line_to_free);",
          "192:     }",
          "194:     return theline;",
          "195: }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "212:  while (eap != NULL && eap->getline != NULL",
          "213:     && (*p == NUL || (VIM_ISWHITE(*whitep) && *p == '#')))",
          "214:  {",
          "219:      if (theline == NULL)",
          "220:   break;",
          "225:      whitep = (char_u *)\" \";",
          "226:      p = skipwhite(theline);",
          "227:  }",
          "",
          "[Removed Lines]",
          "215:      char_u *theline;",
          "218:      theline = eap->getline(':', eap->cookie, 0, TRUE);",
          "221:      vim_free(*line_to_free);",
          "222:      if (*eap->cmdlinep == *line_to_free)",
          "",
          "[Added Lines]",
          "245:      char_u *theline = get_function_line(eap, line_to_free, 0, TRUE);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "720:  }",
          "721:  else",
          "722:  {",
          "727:              getline_options);",
          "732:  }",
          "733:  if (KeyTyped)",
          "734:      lines_left = Rows - 1;",
          "",
          "[Removed Lines]",
          "723:      if (eap->getline == NULL)",
          "724:   theline = getcmdline(':', 0L, indent, getline_options);",
          "725:      else",
          "726:   theline = eap->getline(':', eap->cookie, indent,",
          "728:      if (*eap->cmdlinep == *line_to_free)",
          "730:      vim_free(*line_to_free);",
          "",
          "[Added Lines]",
          "747:      theline = get_function_line(eap, line_to_free, indent,",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "827:    SOURCING_LNUM = sourcing_lnum_top",
          "828:        + newlines->ga_len + 1;",
          "829:    if (eap->cmdidx == CMD_def)",
          "831:    else",
          "832:        give_warning2((char_u *)",
          "833:        _(\"W22: Text found after :endfunction: %s\"),",
          "",
          "[Removed Lines]",
          "830:        semsg(_(e_text_found_after_enddef_str), p);",
          "",
          "[Added Lines]",
          "847:        semsg(_(e_text_found_after_str_str), \"enddef\", p);",
          "",
          "---------------"
        ],
        "src/version.c||src/version.c": [
          "File: src/version.c -> src/version.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "750: static int included_patches[] =",
          "753:     3923,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "753:     3924,",
          "",
          "---------------"
        ],
        "src/vim9compile.c||src/vim9compile.c": [
          "File: src/vim9compile.c -> src/vim9compile.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "879:     }",
          "881:     ufunc = define_function(eap, lambda_name, line_to_free);",
          "883:     if (ufunc == NULL)",
          "884:     {",
          "885:  r = eap->skip ? OK : FAIL;",
          "886:  goto theend;",
          "887:     }",
          "890:     if (!is_global && cctx->ctx_ufunc->uf_block_depth > 0)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "887:     if (eap->nextcmd != NULL)",
          "888:     {",
          "889:  semsg(_(e_text_found_after_str_str),",
          "890:        eap->cmdidx == CMD_def ? \"enddef\" : \"endfunction\", eap->nextcmd);",
          "891:  r = FAIL;",
          "892:  goto theend;",
          "893:     }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "074f84c01fbe70554feb6a71c0d9cacf2ef77ca5",
      "candidate_info": {
        "commit_hash": "074f84c01fbe70554feb6a71c0d9cacf2ef77ca5",
        "repo": "vim/vim",
        "commit_url": "https://github.com/vim/vim/commit/074f84c01fbe70554feb6a71c0d9cacf2ef77ca5",
        "files": [
          "src/testdir/test_vim9_func.vim",
          "src/userfunc.c",
          "src/version.c"
        ],
        "message": "patch 8.2.2864: Vim9: crash when using inline function\n\nProblem:    Vim9: crash when using inline function.\nSolution:   Check for NULL pointer. Make using inline function work inside\n            lambda. (closes #8217)",
        "before_after_code_files": [
          "src/testdir/test_vim9_func.vim||src/testdir/test_vim9_func.vim",
          "src/userfunc.c||src/userfunc.c",
          "src/version.c||src/version.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/testdir/test_vim9_func.vim||src/testdir/test_vim9_func.vim",
            "src/userfunc.c||src/userfunc.c",
            "src/version.c||src/version.c"
          ],
          "candidate": [
            "src/testdir/test_vim9_func.vim||src/testdir/test_vim9_func.vim",
            "src/userfunc.c||src/userfunc.c",
            "src/version.c||src/version.c"
          ]
        }
      },
      "candidate_diff": {
        "src/testdir/test_vim9_func.vim||src/testdir/test_vim9_func.vim": [
          "File: src/testdir/test_vim9_func.vim -> src/testdir/test_vim9_func.vim",
          "--- Hunk 1 ---",
          "[Context before]",
          "2102:   CheckScriptSuccess(lines)",
          "2103: enddef",
          "2105: def Shadowed(): list<number>",
          "2106:   var FuncList: list<func: number> = [() => 42]",
          "2107:   return FuncList->mapnew((_, Shadowed) => Shadowed())",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2105: def Test_nested_inline_lambda()",
          "2106:   # TODO: use the \"text\" argument",
          "2107:   var lines =<< trim END",
          "2108:       vim9script",
          "2109:       def F(text: string): func(string): func(string): string",
          "2110:         return (arg: string): func(string): string => ((sep: string): string => {",
          "2111:             return sep .. arg",
          "2112:           })",
          "2113:       enddef",
          "2114:       assert_equal('--there', F('unused')('there')('--'))",
          "2115:   END",
          "2116:   CheckScriptSuccess(lines)",
          "2117: enddef",
          "",
          "---------------"
        ],
        "src/userfunc.c||src/userfunc.c": [
          "File: src/userfunc.c -> src/userfunc.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "945:      line_arg = NULL;",
          "946:     }",
          "951:  ret = OK;",
          "953: theend:",
          "",
          "[Removed Lines]",
          "950:     if (!eap->skip && !did_emsg)",
          "",
          "[Added Lines]",
          "950:     if (!did_emsg)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "974:  char_u     *ret_type)",
          "975: {",
          "976:     int  evaluate = (evalarg->eval_flags & EVAL_EVALUATE);",
          "977:     ufunc_T *ufunc = NULL;",
          "978:     exarg_T eap;",
          "979:     garray_T newlines;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "978:     garray_T *gap = &evalarg->eval_ga;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1010:  vim_free(cmdline);",
          "1011:  goto erret;",
          "1012:     }",
          "1013:     if (cmdline != NULL)",
          "1014:     {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1017:     evalarg->eval_break_count += newlines.ga_len;",
          "1018:     if (gap->ga_itemsize > 0)",
          "1019:     {",
          "1020:  int idx;",
          "1021:  char_u *last;",
          "1022:  size_t  plen;",
          "1023:  char_u  *pnl;",
          "1025:  for (idx = 0; idx < newlines.ga_len; ++idx)",
          "1026:  {",
          "1027:      char_u  *p = skipwhite(((char_u **)newlines.ga_data)[idx]);",
          "1029:      if (ga_grow(gap, 1) == FAIL)",
          "1030:   goto erret;",
          "1036:      if (*p == NUL || vim9_comment_start(p))",
          "1037:   p = (char_u *)\"\";",
          "1038:      plen = STRLEN(p);",
          "1039:      pnl = vim_strnsave((char_u *)\"\\n\", plen + 1);",
          "1040:      if (pnl != NULL)",
          "1041:   mch_memmove(pnl + 1, p, plen + 1);",
          "1042:      ((char_u **)gap->ga_data)[gap->ga_len] = pnl;",
          "1043:      ++gap->ga_len;",
          "1044:  }",
          "1045:  if (ga_grow(gap, 1) == FAIL)",
          "1046:      goto erret;",
          "1047:  if (cmdline != NULL)",
          "1049:      last = cmdline;",
          "1050:  else",
          "1052:      last = (char_u *)\"}\";",
          "1053:  plen = STRLEN(last);",
          "1054:  pnl = vim_strnsave((char_u *)\"\\n\", plen + 1);",
          "1055:  if (pnl != NULL)",
          "1056:      mch_memmove(pnl + 1, last, plen + 1);",
          "1057:  ((char_u **)gap->ga_data)[gap->ga_len] = pnl;",
          "1058:  ++gap->ga_len;",
          "1059:     }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1022:     else",
          "1025:     name = get_lambda_name();",
          "1026:     ufunc = alloc_clear(offsetof(ufunc_T, uf_name) + STRLEN(name) + 1);",
          "1027:     if (ufunc == NULL)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1073:     if (!evaluate)",
          "1074:     {",
          "1075:  ret = OK;",
          "1076:  goto erret;",
          "1077:     }",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1078:  SOURCING_LNUM = lnum_save;",
          "1079:     vim_free(line_to_free);",
          "1080:     ga_clear_strings(&newlines);",
          "1082:     ga_clear_strings(default_args);",
          "1083:     if (ufunc != NULL)",
          "1084:     {",
          "",
          "[Removed Lines]",
          "1081:     ga_clear_strings(newargs);",
          "",
          "[Added Lines]",
          "1135:     if (newargs != NULL)",
          "1136:  ga_clear_strings(newargs);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1222:  int     len;",
          "1223:  int     flags = 0;",
          "1224:  char_u     *p;",
          "1225:  char_u     *name = get_lambda_name();",
          "1227:  fp = alloc_clear(offsetof(ufunc_T, uf_name) + STRLEN(name) + 1);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1280:  char_u     *line_end;",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "1236:  if (ga_grow(&newlines, 1) == FAIL)",
          "1237:      goto errret;",
          "1241:  p = alloc(len);",
          "1242:  if (p == NULL)",
          "1243:      goto errret;",
          "1244:  ((char_u **)(newlines.ga_data))[newlines.ga_len++] = p;",
          "1245:  STRCPY(p, \"return \");",
          "1247:  if (strstr((char *)p + 7, \"a:\") == NULL)",
          "1249:      flags |= FC_NOARGS;",
          "",
          "[Removed Lines]",
          "1240:  len = 7 + (int)(end - start) + 1;",
          "1246:  vim_strncpy(p + 7, start, end - start);",
          "",
          "[Added Lines]",
          "1296:  line_end = vim_strchr(start, '\\n');",
          "1297:  if (line_end == NULL)",
          "1298:      line_end = end;",
          "1301:  len = 7 + (int)(line_end - start) + 1;",
          "1307:  vim_strncpy(p + 7, start, line_end - start);",
          "1309:  if (line_end != end)",
          "1310:  {",
          "1313:      while (*line_end == '\\n')",
          "1314:      {",
          "1315:   if (ga_grow(&newlines, 1) == FAIL)",
          "1316:       goto errret;",
          "1317:   start = line_end + 1;",
          "1318:   line_end = vim_strchr(start, '\\n');",
          "1319:   if (line_end == NULL)",
          "1320:       line_end = end;",
          "1321:   ((char_u **)(newlines.ga_data))[newlines.ga_len++] =",
          "1322:       vim_strnsave(start, line_end - start);",
          "1323:      }",
          "1324:  }",
          "",
          "---------------"
        ],
        "src/version.c||src/version.c": [
          "File: src/version.c -> src/version.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "751: static int included_patches[] =",
          "754:     2863,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "754:     2864,",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2021-29530",
  "cve_desc": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can trigger a null pointer dereference by providing an invalid `permutation` to `tf.raw_ops.SparseMatrixSparseCholesky`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/080f1d9e257589f78b3ffb75debf584168aa6062/tensorflow/core/kernels/sparse/sparse_cholesky_op.cc#L85-L86) fails to properly validate the input arguments. Although `ValidateInputs` is called and there are checks in the body of this function, the code proceeds to the next line in `ValidateInputs` since `OP_REQUIRES`(https://github.com/tensorflow/tensorflow/blob/080f1d9e257589f78b3ffb75debf584168aa6062/tensorflow/core/framework/op_requires.h#L41-L48) is a macro that only exits the current function. Thus, the first validation condition that fails in `ValidateInputs` will cause an early return from that function. However, the caller will continue execution from the next line. The fix is to either explicitly check `context->status()` or to convert `ValidateInputs` to return a `Status`. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
  "repo": "tensorflow/tensorflow",
  "patch_hash": "e6a7c7cc18c3aaad1ae0872cb0a959f5c923d2bd",
  "patch_info": {
    "commit_hash": "e6a7c7cc18c3aaad1ae0872cb0a959f5c923d2bd",
    "repo": "tensorflow/tensorflow",
    "commit_url": "https://github.com/tensorflow/tensorflow/commit/e6a7c7cc18c3aaad1ae0872cb0a959f5c923d2bd",
    "files": [
      "tensorflow/core/kernels/sparse/sparse_cholesky_op.cc"
    ],
    "message": "Remove `OP_REQUIRES` call from helper function.\n\nSince `OP_REQUIRES` macro expands to a `return;` (among other), calling it in a helper function only ends the helper function's execution earlier, but the kernel will still run from start to end. Thus, all the expected validations are actually broken/useless as the code ploughs through the next crash anyway.\n\nPiperOrigin-RevId: 369524386\nChange-Id: I54f6cf9328445675ccc392e661b04336b229c9da",
    "before_after_code_files": [
      "tensorflow/core/kernels/sparse/sparse_cholesky_op.cc||tensorflow/core/kernels/sparse/sparse_cholesky_op.cc"
    ]
  },
  "patch_diff": {
    "tensorflow/core/kernels/sparse/sparse_cholesky_op.cc||tensorflow/core/kernels/sparse/sparse_cholesky_op.cc": [
      "File: tensorflow/core/kernels/sparse/sparse_cholesky_op.cc -> tensorflow/core/kernels/sparse/sparse_cholesky_op.cc",
      "--- Hunk 1 ---",
      "[Context before]",
      "17: #include <numeric>",
      "18: #include <vector>",
      "20: #define EIGEN_USE_THREADS",
      "22: #include \"third_party/eigen3/Eigen/Core\"",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "20: #include \"tensorflow/core/framework/op_requires.h\"",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "83:     int64 num_rows;",
      "84:     int batch_size;",
      "89:     Tensor batch_ptr(cpu_allocator(), DT_INT32, TensorShape({batch_size + 1}));",
      "",
      "[Removed Lines]",
      "85:     ValidateInputs(ctx, *input_matrix, input_permutation_indices, &batch_size,",
      "86:                    &num_rows);",
      "",
      "[Added Lines]",
      "87:     OP_REQUIRES_OK(ctx, ValidateInputs(*input_matrix, input_permutation_indices,",
      "88:                                        &batch_size, &num_rows));",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "226:   }",
      "228:  private:",
      "239:     const Tensor& dense_shape = sparse_matrix.dense_shape();",
      "240:     const int rank = dense_shape.dim_size(0);",
      "244:     const int row_dim = (rank == 2) ? 0 : 1;",
      "245:     auto dense_shape_vec = dense_shape.vec<int64>();",
      "247:     const int64 num_cols = dense_shape_vec(row_dim + 1);",
      "251:     const TensorShape& perm_shape = permutation_indices.shape();",
      "265:     if (*batch_size > 1) {",
      "271:     }",
      "272:   }",
      "273: };",
      "",
      "[Removed Lines]",
      "229:   void ValidateInputs(OpKernelContext* ctx,",
      "230:                       const CSRSparseMatrix& sparse_matrix,",
      "231:                       const Tensor& permutation_indices, int* batch_size,",
      "232:                       int64* num_rows) {",
      "233:     OP_REQUIRES(ctx, sparse_matrix.dtype() == DataTypeToEnum<T>::value,",
      "234:                 errors::InvalidArgument(",
      "235:                     \"Asked for a CSRSparseMatrix of type \",",
      "236:                     DataTypeString(DataTypeToEnum<T>::value),",
      "237:                     \" but saw dtype: \", DataTypeString(sparse_matrix.dtype())));",
      "241:     OP_REQUIRES(ctx, rank == 2 || rank == 3,",
      "242:                 errors::InvalidArgument(\"sparse matrix must have rank 2 or 3; \",",
      "243:                                         \"but dense_shape has size \", rank));",
      "248:     OP_REQUIRES(ctx, *num_rows == num_cols,",
      "249:                 errors::InvalidArgument(\"sparse matrix must be square; got: \",",
      "252:     OP_REQUIRES(",
      "253:         ctx, perm_shape.dims() + 1 == rank,",
      "254:         errors::InvalidArgument(",
      "255:             \"sparse matrix must have the same rank as permutation; got: \", rank,",
      "256:             \" != \", perm_shape.dims(), \" + 1.\"));",
      "257:     OP_REQUIRES(",
      "258:         ctx, perm_shape.dim_size(rank - 2) == *num_rows,",
      "259:         errors::InvalidArgument(",
      "260:             \"permutation must have the same number of elements in each batch \"",
      "261:             \"as the number of rows in sparse matrix; got: \",",
      "262:             perm_shape.dim_size(rank - 2), \" != \", *num_rows));",
      "266:       OP_REQUIRES(",
      "267:           ctx, perm_shape.dim_size(0) == *batch_size,",
      "268:           errors::InvalidArgument(\"permutation must have the same batch size \"",
      "269:                                   \"as sparse matrix; got: \",",
      "270:                                   perm_shape.dim_size(0), \" != \", *batch_size));",
      "",
      "[Added Lines]",
      "231:   Status ValidateInputs(const CSRSparseMatrix& sparse_matrix,",
      "232:                         const Tensor& permutation_indices, int* batch_size,",
      "233:                         int64* num_rows) {",
      "234:     if (sparse_matrix.dtype() != DataTypeToEnum<T>::value)",
      "235:       return errors::InvalidArgument(",
      "236:           \"Asked for a CSRSparseMatrix of type \",",
      "237:           DataTypeString(DataTypeToEnum<T>::value),",
      "238:           \" but saw dtype: \", DataTypeString(sparse_matrix.dtype()));",
      "242:     if (rank < 2 || rank > 3)",
      "243:       return errors::InvalidArgument(\"sparse matrix must have rank 2 or 3; \",",
      "244:                                      \"but dense_shape has size \", rank);",
      "249:     if (*num_rows != num_cols)",
      "250:       return errors::InvalidArgument(",
      "251:           \"sparse matrix must be square; got: \", *num_rows, \" != \", num_cols);",
      "253:     if (perm_shape.dims() + 1 != rank)",
      "254:       return errors::InvalidArgument(",
      "255:           \"sparse matrix must have the same rank as permutation; got: \", rank,",
      "256:           \" != \", perm_shape.dims(), \" + 1.\");",
      "257:     if (perm_shape.dim_size(rank - 2) != *num_rows)",
      "258:       return errors::InvalidArgument(",
      "259:           \"permutation must have the same number of elements in each batch \"",
      "260:           \"as the number of rows in sparse matrix; got: \",",
      "261:           perm_shape.dim_size(rank - 2), \" != \", *num_rows);",
      "265:       if (perm_shape.dim_size(0) != *batch_size)",
      "266:         return errors::InvalidArgument(",
      "267:             \"permutation must have the same batch size \"",
      "268:             \"as sparse matrix; got: \",",
      "269:             perm_shape.dim_size(0), \" != \", *batch_size);",
      "272:     return Status::OK();",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "54f3e395ba891f6535e71440fba722568db17d98",
      "candidate_info": {
        "commit_hash": "54f3e395ba891f6535e71440fba722568db17d98",
        "repo": "tensorflow/tensorflow",
        "commit_url": "https://github.com/tensorflow/tensorflow/commit/54f3e395ba891f6535e71440fba722568db17d98",
        "files": [
          "tensorflow/core/kernels/sparse/sparse_cholesky_op.cc"
        ],
        "message": "Remove `OP_REQUIRES` call from helper function.\n\nSince `OP_REQUIRES` macro expands to a `return;` (among other), calling it in a helper function only ends the helper function's execution earlier, but the kernel will still run from start to end. Thus, all the expected validations are actually broken/useless as the code ploughs through the next crash anyway.\n\nPiperOrigin-RevId: 369524386\nChange-Id: I54f6cf9328445675ccc392e661b04336b229c9da",
        "before_after_code_files": [
          "tensorflow/core/kernels/sparse/sparse_cholesky_op.cc||tensorflow/core/kernels/sparse/sparse_cholesky_op.cc"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "tensorflow/core/kernels/sparse/sparse_cholesky_op.cc||tensorflow/core/kernels/sparse/sparse_cholesky_op.cc"
          ],
          "candidate": [
            "tensorflow/core/kernels/sparse/sparse_cholesky_op.cc||tensorflow/core/kernels/sparse/sparse_cholesky_op.cc"
          ]
        }
      },
      "candidate_diff": {
        "tensorflow/core/kernels/sparse/sparse_cholesky_op.cc||tensorflow/core/kernels/sparse/sparse_cholesky_op.cc": [
          "File: tensorflow/core/kernels/sparse/sparse_cholesky_op.cc -> tensorflow/core/kernels/sparse/sparse_cholesky_op.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "17: #include <numeric>",
          "18: #include <vector>",
          "20: #define EIGEN_USE_THREADS",
          "22: #include \"third_party/eigen3/Eigen/Core\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "20: #include \"tensorflow/core/framework/op_requires.h\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "83:     int64 num_rows;",
          "84:     int batch_size;",
          "89:     Tensor batch_ptr(cpu_allocator(), DT_INT32, TensorShape({batch_size + 1}));",
          "",
          "[Removed Lines]",
          "85:     ValidateInputs(ctx, *input_matrix, input_permutation_indices, &batch_size,",
          "86:                    &num_rows);",
          "",
          "[Added Lines]",
          "87:     OP_REQUIRES_OK(ctx, ValidateInputs(*input_matrix, input_permutation_indices,",
          "88:                                        &batch_size, &num_rows));",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "226:   }",
          "228:  private:",
          "239:     const Tensor& dense_shape = sparse_matrix.dense_shape();",
          "240:     const int rank = dense_shape.dim_size(0);",
          "244:     const int row_dim = (rank == 2) ? 0 : 1;",
          "245:     auto dense_shape_vec = dense_shape.vec<int64>();",
          "247:     const int64 num_cols = dense_shape_vec(row_dim + 1);",
          "251:     const TensorShape& perm_shape = permutation_indices.shape();",
          "265:     if (*batch_size > 1) {",
          "271:     }",
          "272:   }",
          "273: };",
          "",
          "[Removed Lines]",
          "229:   void ValidateInputs(OpKernelContext* ctx,",
          "230:                       const CSRSparseMatrix& sparse_matrix,",
          "231:                       const Tensor& permutation_indices, int* batch_size,",
          "232:                       int64* num_rows) {",
          "233:     OP_REQUIRES(ctx, sparse_matrix.dtype() == DataTypeToEnum<T>::value,",
          "234:                 errors::InvalidArgument(",
          "235:                     \"Asked for a CSRSparseMatrix of type \",",
          "236:                     DataTypeString(DataTypeToEnum<T>::value),",
          "237:                     \" but saw dtype: \", DataTypeString(sparse_matrix.dtype())));",
          "241:     OP_REQUIRES(ctx, rank == 2 || rank == 3,",
          "242:                 errors::InvalidArgument(\"sparse matrix must have rank 2 or 3; \",",
          "243:                                         \"but dense_shape has size \", rank));",
          "248:     OP_REQUIRES(ctx, *num_rows == num_cols,",
          "249:                 errors::InvalidArgument(\"sparse matrix must be square; got: \",",
          "252:     OP_REQUIRES(",
          "253:         ctx, perm_shape.dims() + 1 == rank,",
          "254:         errors::InvalidArgument(",
          "255:             \"sparse matrix must have the same rank as permutation; got: \", rank,",
          "256:             \" != \", perm_shape.dims(), \" + 1.\"));",
          "257:     OP_REQUIRES(",
          "258:         ctx, perm_shape.dim_size(rank - 2) == *num_rows,",
          "259:         errors::InvalidArgument(",
          "260:             \"permutation must have the same number of elements in each batch \"",
          "261:             \"as the number of rows in sparse matrix; got: \",",
          "262:             perm_shape.dim_size(rank - 2), \" != \", *num_rows));",
          "266:       OP_REQUIRES(",
          "267:           ctx, perm_shape.dim_size(0) == *batch_size,",
          "268:           errors::InvalidArgument(\"permutation must have the same batch size \"",
          "269:                                   \"as sparse matrix; got: \",",
          "270:                                   perm_shape.dim_size(0), \" != \", *batch_size));",
          "",
          "[Added Lines]",
          "231:   Status ValidateInputs(const CSRSparseMatrix& sparse_matrix,",
          "232:                         const Tensor& permutation_indices, int* batch_size,",
          "233:                         int64* num_rows) {",
          "234:     if (sparse_matrix.dtype() != DataTypeToEnum<T>::value)",
          "235:       return errors::InvalidArgument(",
          "236:           \"Asked for a CSRSparseMatrix of type \",",
          "237:           DataTypeString(DataTypeToEnum<T>::value),",
          "238:           \" but saw dtype: \", DataTypeString(sparse_matrix.dtype()));",
          "242:     if (rank < 2 || rank > 3)",
          "243:       return errors::InvalidArgument(\"sparse matrix must have rank 2 or 3; \",",
          "244:                                      \"but dense_shape has size \", rank);",
          "249:     if (*num_rows != num_cols)",
          "250:       return errors::InvalidArgument(",
          "251:           \"sparse matrix must be square; got: \", *num_rows, \" != \", num_cols);",
          "253:     if (perm_shape.dims() + 1 != rank)",
          "254:       return errors::InvalidArgument(",
          "255:           \"sparse matrix must have the same rank as permutation; got: \", rank,",
          "256:           \" != \", perm_shape.dims(), \" + 1.\");",
          "257:     if (perm_shape.dim_size(rank - 2) != *num_rows)",
          "258:       return errors::InvalidArgument(",
          "259:           \"permutation must have the same number of elements in each batch \"",
          "260:           \"as the number of rows in sparse matrix; got: \",",
          "261:           perm_shape.dim_size(rank - 2), \" != \", *num_rows);",
          "265:       if (perm_shape.dim_size(0) != *batch_size)",
          "266:         return errors::InvalidArgument(",
          "267:             \"permutation must have the same batch size \"",
          "268:             \"as sparse matrix; got: \",",
          "269:             perm_shape.dim_size(0), \" != \", *batch_size);",
          "272:     return Status::OK();",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "0b36c628ec83d6d16230ffebcb287a9ab4a4b896",
      "candidate_info": {
        "commit_hash": "0b36c628ec83d6d16230ffebcb287a9ab4a4b896",
        "repo": "tensorflow/tensorflow",
        "commit_url": "https://github.com/tensorflow/tensorflow/commit/0b36c628ec83d6d16230ffebcb287a9ab4a4b896",
        "files": [
          "tensorflow/core/kernels/sparse/sparse_cholesky_op.cc"
        ],
        "message": "Remove `OP_REQUIRES` call from helper function.\n\nSince `OP_REQUIRES` macro expands to a `return;` (among other), calling it in a helper function only ends the helper function's execution earlier, but the kernel will still run from start to end. Thus, all the expected validations are actually broken/useless as the code ploughs through the next crash anyway.\n\nPiperOrigin-RevId: 369524386\nChange-Id: I54f6cf9328445675ccc392e661b04336b229c9da",
        "before_after_code_files": [
          "tensorflow/core/kernels/sparse/sparse_cholesky_op.cc||tensorflow/core/kernels/sparse/sparse_cholesky_op.cc"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "tensorflow/core/kernels/sparse/sparse_cholesky_op.cc||tensorflow/core/kernels/sparse/sparse_cholesky_op.cc"
          ],
          "candidate": [
            "tensorflow/core/kernels/sparse/sparse_cholesky_op.cc||tensorflow/core/kernels/sparse/sparse_cholesky_op.cc"
          ]
        }
      },
      "candidate_diff": {
        "tensorflow/core/kernels/sparse/sparse_cholesky_op.cc||tensorflow/core/kernels/sparse/sparse_cholesky_op.cc": [
          "File: tensorflow/core/kernels/sparse/sparse_cholesky_op.cc -> tensorflow/core/kernels/sparse/sparse_cholesky_op.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "17: #include <numeric>",
          "18: #include <vector>",
          "20: #define EIGEN_USE_THREADS",
          "22: #include \"third_party/eigen3/Eigen/Core\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "20: #include \"tensorflow/core/framework/op_requires.h\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "83:     int64 num_rows;",
          "84:     int batch_size;",
          "89:     Tensor batch_ptr(cpu_allocator(), DT_INT32, TensorShape({batch_size + 1}));",
          "",
          "[Removed Lines]",
          "85:     ValidateInputs(ctx, *input_matrix, input_permutation_indices, &batch_size,",
          "86:                    &num_rows);",
          "",
          "[Added Lines]",
          "87:     OP_REQUIRES_OK(ctx, ValidateInputs(*input_matrix, input_permutation_indices,",
          "88:                                        &batch_size, &num_rows));",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "226:   }",
          "228:  private:",
          "239:     const Tensor& dense_shape = sparse_matrix.dense_shape();",
          "240:     const int rank = dense_shape.dim_size(0);",
          "244:     const int row_dim = (rank == 2) ? 0 : 1;",
          "245:     auto dense_shape_vec = dense_shape.vec<int64>();",
          "247:     const int64 num_cols = dense_shape_vec(row_dim + 1);",
          "251:     const TensorShape& perm_shape = permutation_indices.shape();",
          "265:     if (*batch_size > 1) {",
          "271:     }",
          "272:   }",
          "273: };",
          "",
          "[Removed Lines]",
          "229:   void ValidateInputs(OpKernelContext* ctx,",
          "230:                       const CSRSparseMatrix& sparse_matrix,",
          "231:                       const Tensor& permutation_indices, int* batch_size,",
          "232:                       int64* num_rows) {",
          "233:     OP_REQUIRES(ctx, sparse_matrix.dtype() == DataTypeToEnum<T>::value,",
          "234:                 errors::InvalidArgument(",
          "235:                     \"Asked for a CSRSparseMatrix of type \",",
          "236:                     DataTypeString(DataTypeToEnum<T>::value),",
          "237:                     \" but saw dtype: \", DataTypeString(sparse_matrix.dtype())));",
          "241:     OP_REQUIRES(ctx, rank == 2 || rank == 3,",
          "242:                 errors::InvalidArgument(\"sparse matrix must have rank 2 or 3; \",",
          "243:                                         \"but dense_shape has size \", rank));",
          "248:     OP_REQUIRES(ctx, *num_rows == num_cols,",
          "249:                 errors::InvalidArgument(\"sparse matrix must be square; got: \",",
          "252:     OP_REQUIRES(",
          "253:         ctx, perm_shape.dims() + 1 == rank,",
          "254:         errors::InvalidArgument(",
          "255:             \"sparse matrix must have the same rank as permutation; got: \", rank,",
          "256:             \" != \", perm_shape.dims(), \" + 1.\"));",
          "257:     OP_REQUIRES(",
          "258:         ctx, perm_shape.dim_size(rank - 2) == *num_rows,",
          "259:         errors::InvalidArgument(",
          "260:             \"permutation must have the same number of elements in each batch \"",
          "261:             \"as the number of rows in sparse matrix; got: \",",
          "262:             perm_shape.dim_size(rank - 2), \" != \", *num_rows));",
          "266:       OP_REQUIRES(",
          "267:           ctx, perm_shape.dim_size(0) == *batch_size,",
          "268:           errors::InvalidArgument(\"permutation must have the same batch size \"",
          "269:                                   \"as sparse matrix; got: \",",
          "270:                                   perm_shape.dim_size(0), \" != \", *batch_size));",
          "",
          "[Added Lines]",
          "231:   Status ValidateInputs(const CSRSparseMatrix& sparse_matrix,",
          "232:                         const Tensor& permutation_indices, int* batch_size,",
          "233:                         int64* num_rows) {",
          "234:     if (sparse_matrix.dtype() != DataTypeToEnum<T>::value)",
          "235:       return errors::InvalidArgument(",
          "236:           \"Asked for a CSRSparseMatrix of type \",",
          "237:           DataTypeString(DataTypeToEnum<T>::value),",
          "238:           \" but saw dtype: \", DataTypeString(sparse_matrix.dtype()));",
          "242:     if (rank < 2 || rank > 3)",
          "243:       return errors::InvalidArgument(\"sparse matrix must have rank 2 or 3; \",",
          "244:                                      \"but dense_shape has size \", rank);",
          "249:     if (*num_rows != num_cols)",
          "250:       return errors::InvalidArgument(",
          "251:           \"sparse matrix must be square; got: \", *num_rows, \" != \", num_cols);",
          "253:     if (perm_shape.dims() + 1 != rank)",
          "254:       return errors::InvalidArgument(",
          "255:           \"sparse matrix must have the same rank as permutation; got: \", rank,",
          "256:           \" != \", perm_shape.dims(), \" + 1.\");",
          "257:     if (perm_shape.dim_size(rank - 2) != *num_rows)",
          "258:       return errors::InvalidArgument(",
          "259:           \"permutation must have the same number of elements in each batch \"",
          "260:           \"as the number of rows in sparse matrix; got: \",",
          "261:           perm_shape.dim_size(rank - 2), \" != \", *num_rows);",
          "265:       if (perm_shape.dim_size(0) != *batch_size)",
          "266:         return errors::InvalidArgument(",
          "267:             \"permutation must have the same batch size \"",
          "268:             \"as sparse matrix; got: \",",
          "269:             perm_shape.dim_size(0), \" != \", *batch_size);",
          "272:     return Status::OK();",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "93d2356b460c658e6eaf7c84e9d4a679cd05c266",
      "candidate_info": {
        "commit_hash": "93d2356b460c658e6eaf7c84e9d4a679cd05c266",
        "repo": "tensorflow/tensorflow",
        "commit_url": "https://github.com/tensorflow/tensorflow/commit/93d2356b460c658e6eaf7c84e9d4a679cd05c266",
        "files": [
          "tensorflow/core/kernels/sparse/sparse_cholesky_op.cc"
        ],
        "message": "Remove `OP_REQUIRES` call from helper function.\n\nSince `OP_REQUIRES` macro expands to a `return;` (among other), calling it in a helper function only ends the helper function's execution earlier, but the kernel will still run from start to end. Thus, all the expected validations are actually broken/useless as the code ploughs through the next crash anyway.\n\nPiperOrigin-RevId: 369524386\nChange-Id: I54f6cf9328445675ccc392e661b04336b229c9da",
        "before_after_code_files": [
          "tensorflow/core/kernels/sparse/sparse_cholesky_op.cc||tensorflow/core/kernels/sparse/sparse_cholesky_op.cc"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "tensorflow/core/kernels/sparse/sparse_cholesky_op.cc||tensorflow/core/kernels/sparse/sparse_cholesky_op.cc"
          ],
          "candidate": [
            "tensorflow/core/kernels/sparse/sparse_cholesky_op.cc||tensorflow/core/kernels/sparse/sparse_cholesky_op.cc"
          ]
        }
      },
      "candidate_diff": {
        "tensorflow/core/kernels/sparse/sparse_cholesky_op.cc||tensorflow/core/kernels/sparse/sparse_cholesky_op.cc": [
          "File: tensorflow/core/kernels/sparse/sparse_cholesky_op.cc -> tensorflow/core/kernels/sparse/sparse_cholesky_op.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "17: #include <numeric>",
          "18: #include <vector>",
          "20: #define EIGEN_USE_THREADS",
          "22: #include \"third_party/eigen3/Eigen/Core\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "20: #include \"tensorflow/core/framework/op_requires.h\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "83:     int64 num_rows;",
          "84:     int batch_size;",
          "89:     Tensor batch_ptr(cpu_allocator(), DT_INT32, TensorShape({batch_size + 1}));",
          "",
          "[Removed Lines]",
          "85:     ValidateInputs(ctx, *input_matrix, input_permutation_indices, &batch_size,",
          "86:                    &num_rows);",
          "",
          "[Added Lines]",
          "87:     OP_REQUIRES_OK(ctx, ValidateInputs(*input_matrix, input_permutation_indices,",
          "88:                                        &batch_size, &num_rows));",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "226:   }",
          "228:  private:",
          "239:     const Tensor& dense_shape = sparse_matrix.dense_shape();",
          "240:     const int rank = dense_shape.dim_size(0);",
          "244:     const int row_dim = (rank == 2) ? 0 : 1;",
          "245:     auto dense_shape_vec = dense_shape.vec<int64>();",
          "247:     const int64 num_cols = dense_shape_vec(row_dim + 1);",
          "251:     const TensorShape& perm_shape = permutation_indices.shape();",
          "265:     if (*batch_size > 1) {",
          "271:     }",
          "272:   }",
          "273: };",
          "",
          "[Removed Lines]",
          "229:   void ValidateInputs(OpKernelContext* ctx,",
          "230:                       const CSRSparseMatrix& sparse_matrix,",
          "231:                       const Tensor& permutation_indices, int* batch_size,",
          "232:                       int64* num_rows) {",
          "233:     OP_REQUIRES(ctx, sparse_matrix.dtype() == DataTypeToEnum<T>::value,",
          "234:                 errors::InvalidArgument(",
          "235:                     \"Asked for a CSRSparseMatrix of type \",",
          "236:                     DataTypeString(DataTypeToEnum<T>::value),",
          "237:                     \" but saw dtype: \", DataTypeString(sparse_matrix.dtype())));",
          "241:     OP_REQUIRES(ctx, rank == 2 || rank == 3,",
          "242:                 errors::InvalidArgument(\"sparse matrix must have rank 2 or 3; \",",
          "243:                                         \"but dense_shape has size \", rank));",
          "248:     OP_REQUIRES(ctx, *num_rows == num_cols,",
          "249:                 errors::InvalidArgument(\"sparse matrix must be square; got: \",",
          "252:     OP_REQUIRES(",
          "253:         ctx, perm_shape.dims() + 1 == rank,",
          "254:         errors::InvalidArgument(",
          "255:             \"sparse matrix must have the same rank as permutation; got: \", rank,",
          "256:             \" != \", perm_shape.dims(), \" + 1.\"));",
          "257:     OP_REQUIRES(",
          "258:         ctx, perm_shape.dim_size(rank - 2) == *num_rows,",
          "259:         errors::InvalidArgument(",
          "260:             \"permutation must have the same number of elements in each batch \"",
          "261:             \"as the number of rows in sparse matrix; got: \",",
          "262:             perm_shape.dim_size(rank - 2), \" != \", *num_rows));",
          "266:       OP_REQUIRES(",
          "267:           ctx, perm_shape.dim_size(0) == *batch_size,",
          "268:           errors::InvalidArgument(\"permutation must have the same batch size \"",
          "269:                                   \"as sparse matrix; got: \",",
          "270:                                   perm_shape.dim_size(0), \" != \", *batch_size));",
          "",
          "[Added Lines]",
          "231:   Status ValidateInputs(const CSRSparseMatrix& sparse_matrix,",
          "232:                         const Tensor& permutation_indices, int* batch_size,",
          "233:                         int64* num_rows) {",
          "234:     if (sparse_matrix.dtype() != DataTypeToEnum<T>::value)",
          "235:       return errors::InvalidArgument(",
          "236:           \"Asked for a CSRSparseMatrix of type \",",
          "237:           DataTypeString(DataTypeToEnum<T>::value),",
          "238:           \" but saw dtype: \", DataTypeString(sparse_matrix.dtype()));",
          "242:     if (rank < 2 || rank > 3)",
          "243:       return errors::InvalidArgument(\"sparse matrix must have rank 2 or 3; \",",
          "244:                                      \"but dense_shape has size \", rank);",
          "249:     if (*num_rows != num_cols)",
          "250:       return errors::InvalidArgument(",
          "251:           \"sparse matrix must be square; got: \", *num_rows, \" != \", num_cols);",
          "253:     if (perm_shape.dims() + 1 != rank)",
          "254:       return errors::InvalidArgument(",
          "255:           \"sparse matrix must have the same rank as permutation; got: \", rank,",
          "256:           \" != \", perm_shape.dims(), \" + 1.\");",
          "257:     if (perm_shape.dim_size(rank - 2) != *num_rows)",
          "258:       return errors::InvalidArgument(",
          "259:           \"permutation must have the same number of elements in each batch \"",
          "260:           \"as the number of rows in sparse matrix; got: \",",
          "261:           perm_shape.dim_size(rank - 2), \" != \", *num_rows);",
          "265:       if (perm_shape.dim_size(0) != *batch_size)",
          "266:         return errors::InvalidArgument(",
          "267:             \"permutation must have the same batch size \"",
          "268:             \"as sparse matrix; got: \",",
          "269:             perm_shape.dim_size(0), \" != \", *batch_size);",
          "272:     return Status::OK();",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "6c5a32c95ec2299186cab279cf745737c1c139b6",
      "candidate_info": {
        "commit_hash": "6c5a32c95ec2299186cab279cf745737c1c139b6",
        "repo": "tensorflow/tensorflow",
        "commit_url": "https://github.com/tensorflow/tensorflow/commit/6c5a32c95ec2299186cab279cf745737c1c139b6",
        "files": [
          "tensorflow/core/kernels/sparse/sparse_cholesky_op.cc"
        ],
        "message": "Remove `OP_REQUIRES` call from helper function.\n\nSince `OP_REQUIRES` macro expands to a `return;` (among other), calling it in a helper function only ends the helper function's execution earlier, but the kernel will still run from start to end. Thus, all the expected validations are actually broken/useless as the code ploughs through the next crash anyway.\n\nPiperOrigin-RevId: 369524386\nChange-Id: I54f6cf9328445675ccc392e661b04336b229c9da",
        "before_after_code_files": [
          "tensorflow/core/kernels/sparse/sparse_cholesky_op.cc||tensorflow/core/kernels/sparse/sparse_cholesky_op.cc"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "tensorflow/core/kernels/sparse/sparse_cholesky_op.cc||tensorflow/core/kernels/sparse/sparse_cholesky_op.cc"
          ],
          "candidate": [
            "tensorflow/core/kernels/sparse/sparse_cholesky_op.cc||tensorflow/core/kernels/sparse/sparse_cholesky_op.cc"
          ]
        }
      },
      "candidate_diff": {
        "tensorflow/core/kernels/sparse/sparse_cholesky_op.cc||tensorflow/core/kernels/sparse/sparse_cholesky_op.cc": [
          "File: tensorflow/core/kernels/sparse/sparse_cholesky_op.cc -> tensorflow/core/kernels/sparse/sparse_cholesky_op.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "17: #include <numeric>",
          "18: #include <vector>",
          "20: #define EIGEN_USE_THREADS",
          "22: #include \"third_party/eigen3/Eigen/Core\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "20: #include \"tensorflow/core/framework/op_requires.h\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "83:     int64 num_rows;",
          "84:     int batch_size;",
          "89:     Tensor batch_ptr(cpu_allocator(), DT_INT32, TensorShape({batch_size + 1}));",
          "",
          "[Removed Lines]",
          "85:     ValidateInputs(ctx, *input_matrix, input_permutation_indices, &batch_size,",
          "86:                    &num_rows);",
          "",
          "[Added Lines]",
          "87:     OP_REQUIRES_OK(ctx, ValidateInputs(*input_matrix, input_permutation_indices,",
          "88:                                        &batch_size, &num_rows));",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "226:   }",
          "228:  private:",
          "239:     const Tensor& dense_shape = sparse_matrix.dense_shape();",
          "240:     const int rank = dense_shape.dim_size(0);",
          "244:     const int row_dim = (rank == 2) ? 0 : 1;",
          "245:     auto dense_shape_vec = dense_shape.vec<int64>();",
          "247:     const int64 num_cols = dense_shape_vec(row_dim + 1);",
          "251:     const TensorShape& perm_shape = permutation_indices.shape();",
          "265:     if (*batch_size > 1) {",
          "271:     }",
          "272:   }",
          "273: };",
          "",
          "[Removed Lines]",
          "229:   void ValidateInputs(OpKernelContext* ctx,",
          "230:                       const CSRSparseMatrix& sparse_matrix,",
          "231:                       const Tensor& permutation_indices, int* batch_size,",
          "232:                       int64* num_rows) {",
          "233:     OP_REQUIRES(ctx, sparse_matrix.dtype() == DataTypeToEnum<T>::value,",
          "234:                 errors::InvalidArgument(",
          "235:                     \"Asked for a CSRSparseMatrix of type \",",
          "236:                     DataTypeString(DataTypeToEnum<T>::value),",
          "237:                     \" but saw dtype: \", DataTypeString(sparse_matrix.dtype())));",
          "241:     OP_REQUIRES(ctx, rank == 2 || rank == 3,",
          "242:                 errors::InvalidArgument(\"sparse matrix must have rank 2 or 3; \",",
          "243:                                         \"but dense_shape has size \", rank));",
          "248:     OP_REQUIRES(ctx, *num_rows == num_cols,",
          "249:                 errors::InvalidArgument(\"sparse matrix must be square; got: \",",
          "252:     OP_REQUIRES(",
          "253:         ctx, perm_shape.dims() + 1 == rank,",
          "254:         errors::InvalidArgument(",
          "255:             \"sparse matrix must have the same rank as permutation; got: \", rank,",
          "256:             \" != \", perm_shape.dims(), \" + 1.\"));",
          "257:     OP_REQUIRES(",
          "258:         ctx, perm_shape.dim_size(rank - 2) == *num_rows,",
          "259:         errors::InvalidArgument(",
          "260:             \"permutation must have the same number of elements in each batch \"",
          "261:             \"as the number of rows in sparse matrix; got: \",",
          "262:             perm_shape.dim_size(rank - 2), \" != \", *num_rows));",
          "266:       OP_REQUIRES(",
          "267:           ctx, perm_shape.dim_size(0) == *batch_size,",
          "268:           errors::InvalidArgument(\"permutation must have the same batch size \"",
          "269:                                   \"as sparse matrix; got: \",",
          "270:                                   perm_shape.dim_size(0), \" != \", *batch_size));",
          "",
          "[Added Lines]",
          "231:   Status ValidateInputs(const CSRSparseMatrix& sparse_matrix,",
          "232:                         const Tensor& permutation_indices, int* batch_size,",
          "233:                         int64* num_rows) {",
          "234:     if (sparse_matrix.dtype() != DataTypeToEnum<T>::value)",
          "235:       return errors::InvalidArgument(",
          "236:           \"Asked for a CSRSparseMatrix of type \",",
          "237:           DataTypeString(DataTypeToEnum<T>::value),",
          "238:           \" but saw dtype: \", DataTypeString(sparse_matrix.dtype()));",
          "242:     if (rank < 2 || rank > 3)",
          "243:       return errors::InvalidArgument(\"sparse matrix must have rank 2 or 3; \",",
          "244:                                      \"but dense_shape has size \", rank);",
          "249:     if (*num_rows != num_cols)",
          "250:       return errors::InvalidArgument(",
          "251:           \"sparse matrix must be square; got: \", *num_rows, \" != \", num_cols);",
          "253:     if (perm_shape.dims() + 1 != rank)",
          "254:       return errors::InvalidArgument(",
          "255:           \"sparse matrix must have the same rank as permutation; got: \", rank,",
          "256:           \" != \", perm_shape.dims(), \" + 1.\");",
          "257:     if (perm_shape.dim_size(rank - 2) != *num_rows)",
          "258:       return errors::InvalidArgument(",
          "259:           \"permutation must have the same number of elements in each batch \"",
          "260:           \"as the number of rows in sparse matrix; got: \",",
          "261:           perm_shape.dim_size(rank - 2), \" != \", *num_rows);",
          "265:       if (perm_shape.dim_size(0) != *batch_size)",
          "266:         return errors::InvalidArgument(",
          "267:             \"permutation must have the same batch size \"",
          "268:             \"as sparse matrix; got: \",",
          "269:             perm_shape.dim_size(0), \" != \", *batch_size);",
          "272:     return Status::OK();",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "1dcf51e75885d0048100414e5ef8016176c0b17a",
      "candidate_info": {
        "commit_hash": "1dcf51e75885d0048100414e5ef8016176c0b17a",
        "repo": "tensorflow/tensorflow",
        "commit_url": "https://github.com/tensorflow/tensorflow/commit/1dcf51e75885d0048100414e5ef8016176c0b17a",
        "files": [
          "tensorflow/core/kernels/sparse/sparse_cholesky_op.cc"
        ],
        "message": "Remove `OP_REQUIRES` call from helper function.\n\nSince `OP_REQUIRES` macro expands to a `return;` (among other), calling it in a helper function only ends the helper function's execution earlier, but the kernel will still run from start to end. Thus, all the expected validations are actually broken/useless as the code ploughs through the next crash anyway.\n\nPiperOrigin-RevId: 369524386\nChange-Id: I54f6cf9328445675ccc392e661b04336b229c9da",
        "before_after_code_files": [
          "tensorflow/core/kernels/sparse/sparse_cholesky_op.cc||tensorflow/core/kernels/sparse/sparse_cholesky_op.cc"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "tensorflow/core/kernels/sparse/sparse_cholesky_op.cc||tensorflow/core/kernels/sparse/sparse_cholesky_op.cc"
          ],
          "candidate": [
            "tensorflow/core/kernels/sparse/sparse_cholesky_op.cc||tensorflow/core/kernels/sparse/sparse_cholesky_op.cc"
          ]
        }
      },
      "candidate_diff": {
        "tensorflow/core/kernels/sparse/sparse_cholesky_op.cc||tensorflow/core/kernels/sparse/sparse_cholesky_op.cc": [
          "File: tensorflow/core/kernels/sparse/sparse_cholesky_op.cc -> tensorflow/core/kernels/sparse/sparse_cholesky_op.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "17: #include <numeric>",
          "18: #include <vector>",
          "20: #define EIGEN_USE_THREADS",
          "22: #include \"third_party/eigen3/Eigen/Core\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "20: #include \"tensorflow/core/framework/op_requires.h\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "83:     int64 num_rows;",
          "84:     int batch_size;",
          "89:     Tensor batch_ptr(cpu_allocator(), DT_INT32, TensorShape({batch_size + 1}));",
          "",
          "[Removed Lines]",
          "85:     ValidateInputs(ctx, *input_matrix, input_permutation_indices, &batch_size,",
          "86:                    &num_rows);",
          "",
          "[Added Lines]",
          "87:     OP_REQUIRES_OK(ctx, ValidateInputs(*input_matrix, input_permutation_indices,",
          "88:                                        &batch_size, &num_rows));",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "226:   }",
          "228:  private:",
          "239:     const Tensor& dense_shape = sparse_matrix.dense_shape();",
          "240:     const int rank = dense_shape.dim_size(0);",
          "244:     const int row_dim = (rank == 2) ? 0 : 1;",
          "245:     auto dense_shape_vec = dense_shape.vec<int64>();",
          "247:     const int64 num_cols = dense_shape_vec(row_dim + 1);",
          "251:     const TensorShape& perm_shape = permutation_indices.shape();",
          "265:     if (*batch_size > 1) {",
          "271:     }",
          "272:   }",
          "273: };",
          "",
          "[Removed Lines]",
          "229:   void ValidateInputs(OpKernelContext* ctx,",
          "230:                       const CSRSparseMatrix& sparse_matrix,",
          "231:                       const Tensor& permutation_indices, int* batch_size,",
          "232:                       int64* num_rows) {",
          "233:     OP_REQUIRES(ctx, sparse_matrix.dtype() == DataTypeToEnum<T>::value,",
          "234:                 errors::InvalidArgument(",
          "235:                     \"Asked for a CSRSparseMatrix of type \",",
          "236:                     DataTypeString(DataTypeToEnum<T>::value),",
          "237:                     \" but saw dtype: \", DataTypeString(sparse_matrix.dtype())));",
          "241:     OP_REQUIRES(ctx, rank == 2 || rank == 3,",
          "242:                 errors::InvalidArgument(\"sparse matrix must have rank 2 or 3; \",",
          "243:                                         \"but dense_shape has size \", rank));",
          "248:     OP_REQUIRES(ctx, *num_rows == num_cols,",
          "249:                 errors::InvalidArgument(\"sparse matrix must be square; got: \",",
          "252:     OP_REQUIRES(",
          "253:         ctx, perm_shape.dims() + 1 == rank,",
          "254:         errors::InvalidArgument(",
          "255:             \"sparse matrix must have the same rank as permutation; got: \", rank,",
          "256:             \" != \", perm_shape.dims(), \" + 1.\"));",
          "257:     OP_REQUIRES(",
          "258:         ctx, perm_shape.dim_size(rank - 2) == *num_rows,",
          "259:         errors::InvalidArgument(",
          "260:             \"permutation must have the same number of elements in each batch \"",
          "261:             \"as the number of rows in sparse matrix; got: \",",
          "262:             perm_shape.dim_size(rank - 2), \" != \", *num_rows));",
          "266:       OP_REQUIRES(",
          "267:           ctx, perm_shape.dim_size(0) == *batch_size,",
          "268:           errors::InvalidArgument(\"permutation must have the same batch size \"",
          "269:                                   \"as sparse matrix; got: \",",
          "270:                                   perm_shape.dim_size(0), \" != \", *batch_size));",
          "",
          "[Added Lines]",
          "231:   Status ValidateInputs(const CSRSparseMatrix& sparse_matrix,",
          "232:                         const Tensor& permutation_indices, int* batch_size,",
          "233:                         int64* num_rows) {",
          "234:     if (sparse_matrix.dtype() != DataTypeToEnum<T>::value)",
          "235:       return errors::InvalidArgument(",
          "236:           \"Asked for a CSRSparseMatrix of type \",",
          "237:           DataTypeString(DataTypeToEnum<T>::value),",
          "238:           \" but saw dtype: \", DataTypeString(sparse_matrix.dtype()));",
          "242:     if (rank < 2 || rank > 3)",
          "243:       return errors::InvalidArgument(\"sparse matrix must have rank 2 or 3; \",",
          "244:                                      \"but dense_shape has size \", rank);",
          "249:     if (*num_rows != num_cols)",
          "250:       return errors::InvalidArgument(",
          "251:           \"sparse matrix must be square; got: \", *num_rows, \" != \", num_cols);",
          "253:     if (perm_shape.dims() + 1 != rank)",
          "254:       return errors::InvalidArgument(",
          "255:           \"sparse matrix must have the same rank as permutation; got: \", rank,",
          "256:           \" != \", perm_shape.dims(), \" + 1.\");",
          "257:     if (perm_shape.dim_size(rank - 2) != *num_rows)",
          "258:       return errors::InvalidArgument(",
          "259:           \"permutation must have the same number of elements in each batch \"",
          "260:           \"as the number of rows in sparse matrix; got: \",",
          "261:           perm_shape.dim_size(rank - 2), \" != \", *num_rows);",
          "265:       if (perm_shape.dim_size(0) != *batch_size)",
          "266:         return errors::InvalidArgument(",
          "267:             \"permutation must have the same batch size \"",
          "268:             \"as sparse matrix; got: \",",
          "269:             perm_shape.dim_size(0), \" != \", *batch_size);",
          "272:     return Status::OK();",
          "",
          "---------------"
        ]
      }
    }
  ]
}
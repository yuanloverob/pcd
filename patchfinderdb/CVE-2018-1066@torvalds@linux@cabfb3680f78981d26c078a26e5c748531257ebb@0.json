{
  "cve_id": "CVE-2018-1066",
  "cve_desc": "The Linux kernel before version 4.11 is vulnerable to a NULL pointer dereference in fs/cifs/cifsencrypt.c:setup_ntlmv2_rsp() that allows an attacker controlling a CIFS server to kernel panic a client that has this server mounted, because an empty TargetInfo field in an NTLMSSP setup negotiation response is mishandled during session recovery.",
  "repo": "torvalds/linux",
  "patch_hash": "cabfb3680f78981d26c078a26e5c748531257ebb",
  "patch_info": {
    "commit_hash": "cabfb3680f78981d26c078a26e5c748531257ebb",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/cabfb3680f78981d26c078a26e5c748531257ebb",
    "files": [
      "fs/cifs/sess.c",
      "fs/cifs/smb2pdu.c"
    ],
    "message": "CIFS: Enable encryption during session setup phase\n\nIn order to allow encryption on SMB connection we need to exchange\na session key and generate encryption and decryption keys.\n\nSigned-off-by: Pavel Shilovsky <pshilov@microsoft.com>",
    "before_after_code_files": [
      "fs/cifs/sess.c||fs/cifs/sess.c",
      "fs/cifs/smb2pdu.c||fs/cifs/smb2pdu.c"
    ]
  },
  "patch_diff": {
    "fs/cifs/sess.c||fs/cifs/sess.c": [
      "File: fs/cifs/sess.c -> fs/cifs/sess.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "345:  flags = NTLMSSP_NEGOTIATE_56 | NTLMSSP_REQUEST_TARGET |",
      "346:   NTLMSSP_NEGOTIATE_128 | NTLMSSP_NEGOTIATE_UNICODE |",
      "349:   flags |= NTLMSSP_NEGOTIATE_SIGN;",
      "355:  sec_blob->NegotiateFlags = cpu_to_le32(flags);",
      "",
      "[Removed Lines]",
      "347:   NTLMSSP_NEGOTIATE_NTLM | NTLMSSP_NEGOTIATE_EXTENDED_SEC;",
      "348:  if (ses->server->sign) {",
      "350:   if (!ses->server->session_estab ||",
      "351:     ses->ntlmssp->sesskey_per_smbsess)",
      "352:    flags |= NTLMSSP_NEGOTIATE_KEY_XCH;",
      "353:  }",
      "",
      "[Added Lines]",
      "347:   NTLMSSP_NEGOTIATE_NTLM | NTLMSSP_NEGOTIATE_EXTENDED_SEC |",
      "348:   NTLMSSP_NEGOTIATE_SEAL;",
      "349:  if (ses->server->sign)",
      "351:  if (!ses->server->session_estab || ses->ntlmssp->sesskey_per_smbsess)",
      "352:   flags |= NTLMSSP_NEGOTIATE_KEY_XCH;",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "407:  flags = NTLMSSP_NEGOTIATE_56 |",
      "408:   NTLMSSP_REQUEST_TARGET | NTLMSSP_NEGOTIATE_TARGET_INFO |",
      "409:   NTLMSSP_NEGOTIATE_128 | NTLMSSP_NEGOTIATE_UNICODE |",
      "412:   flags |= NTLMSSP_NEGOTIATE_SIGN;",
      "418:  tmp = *pbuffer + sizeof(AUTHENTICATE_MESSAGE);",
      "419:  sec_blob->NegotiateFlags = cpu_to_le32(flags);",
      "",
      "[Removed Lines]",
      "410:   NTLMSSP_NEGOTIATE_NTLM | NTLMSSP_NEGOTIATE_EXTENDED_SEC;",
      "411:  if (ses->server->sign) {",
      "413:   if (!ses->server->session_estab ||",
      "414:     ses->ntlmssp->sesskey_per_smbsess)",
      "415:    flags |= NTLMSSP_NEGOTIATE_KEY_XCH;",
      "416:  }",
      "",
      "[Added Lines]",
      "409:   NTLMSSP_NEGOTIATE_NTLM | NTLMSSP_NEGOTIATE_EXTENDED_SEC |",
      "410:   NTLMSSP_NEGOTIATE_SEAL;",
      "411:  if (ses->server->sign)",
      "413:  if (!ses->server->session_estab || ses->ntlmssp->sesskey_per_smbsess)",
      "414:   flags |= NTLMSSP_NEGOTIATE_KEY_XCH;",
      "",
      "---------------"
    ],
    "fs/cifs/smb2pdu.c||fs/cifs/smb2pdu.c": [
      "File: fs/cifs/smb2pdu.c -> fs/cifs/smb2pdu.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "756:  struct cifs_ses *ses = sess_data->ses;",
      "758:  mutex_lock(&ses->server->srv_mutex);",
      "760:   rc = ses->server->ops->generate_signingkey(ses);",
      "763:   if (rc) {",
      "764:    cifs_dbg(FYI,",
      "765:     \"SMB3 session key generation failed\\n\");",
      "766:    mutex_unlock(&ses->server->srv_mutex);",
      "768:   }",
      "769:  }",
      "770:  if (!ses->server->session_estab) {",
      "",
      "[Removed Lines]",
      "759:  if (ses->server->sign && ses->server->ops->generate_signingkey) {",
      "761:   kfree(ses->auth_key.response);",
      "762:   ses->auth_key.response = NULL;",
      "767:    goto keygen_exit;",
      "",
      "[Added Lines]",
      "759:  if (ses->server->ops->generate_signingkey) {",
      "765:    return rc;",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "778:  ses->status = CifsGood;",
      "779:  ses->need_reconnect = false;",
      "780:  spin_unlock(&GlobalMid_Lock);",
      "787:  return rc;",
      "788: }",
      "",
      "[Removed Lines]",
      "782: keygen_exit:",
      "783:  if (!ses->server->sign) {",
      "784:   kfree(ses->auth_key.response);",
      "785:   ses->auth_key.response = NULL;",
      "786:  }",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "3baf1a7b921500596b77487d5a34a27d656fc032",
      "candidate_info": {
        "commit_hash": "3baf1a7b921500596b77487d5a34a27d656fc032",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/3baf1a7b921500596b77487d5a34a27d656fc032",
        "files": [
          "fs/cifs/smb2pdu.c"
        ],
        "message": "SMB2: Separate Kerberos authentication from SMB2_sess_setup\n\nAdd helper functions and split Kerberos authentication off\nSMB2_sess_setup.\n\nSigned-off-by: Sachin Prabhu <sprabhu@redhat.com>\nSigned-off-by: Steve French <smfrench@gmail.com>\nReviewed-by: Pavel Shilovsky <pshilov@microsoft.com>",
        "before_after_code_files": [
          "fs/cifs/smb2pdu.c||fs/cifs/smb2pdu.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "fs/cifs/smb2pdu.c||fs/cifs/smb2pdu.c"
          ],
          "candidate": [
            "fs/cifs/smb2pdu.c||fs/cifs/smb2pdu.c"
          ]
        }
      },
      "candidate_diff": {
        "fs/cifs/smb2pdu.c||fs/cifs/smb2pdu.c": [
          "File: fs/cifs/smb2pdu.c -> fs/cifs/smb2pdu.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "593:  return -EIO;",
          "594: }",
          "596: int",
          "597: SMB2_sess_setup(const unsigned int xid, struct cifs_ses *ses,",
          "598:   const struct nls_table *nls_cp)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "596: struct SMB2_sess_data {",
          "597:  unsigned int xid;",
          "598:  struct cifs_ses *ses;",
          "599:  struct nls_table *nls_cp;",
          "600:  void (*func)(struct SMB2_sess_data *);",
          "601:  int result;",
          "602:  u64 previous_session;",
          "611:  int buf0_type;",
          "612:  struct kvec iov[2];",
          "613: };",
          "615: static int",
          "616: SMB2_sess_alloc_buffer(struct SMB2_sess_data *sess_data)",
          "617: {",
          "618:  int rc;",
          "619:  struct cifs_ses *ses = sess_data->ses;",
          "620:  struct smb2_sess_setup_req *req;",
          "621:  struct TCP_Server_Info *server = ses->server;",
          "623:  rc = small_smb2_init(SMB2_SESSION_SETUP, NULL, (void **) &req);",
          "624:  if (rc)",
          "625:   return rc;",
          "630:  req->PreviousSessionId = sess_data->previous_session;",
          "634:  req->hdr.CreditRequest = cpu_to_le16(3);",
          "637:  if (server->sign)",
          "638:   req->SecurityMode = SMB2_NEGOTIATE_SIGNING_REQUIRED;",
          "640:   req->SecurityMode = SMB2_NEGOTIATE_SIGNING_ENABLED;",
          "641:  else",
          "642:   req->SecurityMode = 0;",
          "644:  req->Capabilities = 0;",
          "647:  sess_data->iov[0].iov_base = (char *)req;",
          "649:  sess_data->iov[0].iov_len = get_rfc1002_length(req) + 4 - 1;",
          "654:  sess_data->buf0_type = CIFS_SMALL_BUFFER;",
          "656:  return 0;",
          "657: }",
          "659: static void",
          "660: SMB2_sess_free_buffer(struct SMB2_sess_data *sess_data)",
          "661: {",
          "662:  free_rsp_buf(sess_data->buf0_type, sess_data->iov[0].iov_base);",
          "663:  sess_data->buf0_type = CIFS_NO_BUFFER;",
          "664: }",
          "666: static int",
          "667: SMB2_sess_sendreceive(struct SMB2_sess_data *sess_data)",
          "668: {",
          "669:  int rc;",
          "670:  struct smb2_sess_setup_req *req = sess_data->iov[0].iov_base;",
          "673:  req->SecurityBufferOffset =",
          "674:   cpu_to_le16(sizeof(struct smb2_sess_setup_req) -",
          "675:    1 /* pad */ - 4 /* rfc1001 len */);",
          "676:  req->SecurityBufferLength = cpu_to_le16(sess_data->iov[1].iov_len);",
          "678:  inc_rfc1001_len(req, sess_data->iov[1].iov_len - 1 /* pad */);",
          "682:  rc = SendReceive2(sess_data->xid, sess_data->ses,",
          "683:     sess_data->iov, 2,",
          "684:     &sess_data->buf0_type,",
          "685:     CIFS_LOG_ERROR | CIFS_NEG_OP);",
          "687:  return rc;",
          "688: }",
          "690: static int",
          "691: SMB2_sess_establish_session(struct SMB2_sess_data *sess_data)",
          "692: {",
          "693:  int rc = 0;",
          "694:  struct cifs_ses *ses = sess_data->ses;",
          "696:  mutex_lock(&ses->server->srv_mutex);",
          "697:  if (ses->server->sign && ses->server->ops->generate_signingkey) {",
          "698:   rc = ses->server->ops->generate_signingkey(ses);",
          "699:   kfree(ses->auth_key.response);",
          "700:   ses->auth_key.response = NULL;",
          "701:   if (rc) {",
          "702:    cifs_dbg(FYI,",
          "703:     \"SMB3 session key generation failed\\n\");",
          "704:    mutex_unlock(&ses->server->srv_mutex);",
          "705:    goto keygen_exit;",
          "706:   }",
          "707:  }",
          "708:  if (!ses->server->session_estab) {",
          "709:   ses->server->sequence_number = 0x2;",
          "710:   ses->server->session_estab = true;",
          "711:  }",
          "712:  mutex_unlock(&ses->server->srv_mutex);",
          "714:  cifs_dbg(FYI, \"SMB2/3 session established successfully\\n\");",
          "715:  spin_lock(&GlobalMid_Lock);",
          "716:  ses->status = CifsGood;",
          "717:  ses->need_reconnect = false;",
          "718:  spin_unlock(&GlobalMid_Lock);",
          "720: keygen_exit:",
          "721:  if (!ses->server->sign) {",
          "722:   kfree(ses->auth_key.response);",
          "723:   ses->auth_key.response = NULL;",
          "724:  }",
          "725:  return rc;",
          "726: }",
          "728: #ifdef CONFIG_CIFS_UPCALL",
          "729: static void",
          "730: SMB2_auth_kerberos(struct SMB2_sess_data *sess_data)",
          "731: {",
          "732:  int rc;",
          "733:  struct cifs_ses *ses = sess_data->ses;",
          "734:  struct cifs_spnego_msg *msg;",
          "735:  struct key *spnego_key = NULL;",
          "736:  struct smb2_sess_setup_rsp *rsp = NULL;",
          "738:  rc = SMB2_sess_alloc_buffer(sess_data);",
          "739:  if (rc)",
          "740:   goto out;",
          "742:  spnego_key = cifs_get_spnego_key(ses);",
          "743:  if (IS_ERR(spnego_key)) {",
          "744:   rc = PTR_ERR(spnego_key);",
          "745:   spnego_key = NULL;",
          "746:   goto out;",
          "747:  }",
          "749:  msg = spnego_key->payload.data[0];",
          "754:  if (msg->version != CIFS_SPNEGO_UPCALL_VERSION) {",
          "755:   cifs_dbg(VFS,",
          "756:      \"bad cifs.upcall version. Expected %d got %d\",",
          "757:      CIFS_SPNEGO_UPCALL_VERSION, msg->version);",
          "758:   rc = -EKEYREJECTED;",
          "759:   goto out_put_spnego_key;",
          "760:  }",
          "762:  ses->auth_key.response = kmemdup(msg->data, msg->sesskey_len,",
          "763:       GFP_KERNEL);",
          "764:  if (!ses->auth_key.response) {",
          "765:   cifs_dbg(VFS,",
          "766:    \"Kerberos can't allocate (%u bytes) memory\",",
          "767:    msg->sesskey_len);",
          "768:   rc = -ENOMEM;",
          "769:   goto out_put_spnego_key;",
          "770:  }",
          "771:  ses->auth_key.len = msg->sesskey_len;",
          "773:  sess_data->iov[1].iov_base = msg->data + msg->sesskey_len;",
          "774:  sess_data->iov[1].iov_len = msg->secblob_len;",
          "776:  rc = SMB2_sess_sendreceive(sess_data);",
          "777:  if (rc)",
          "778:   goto out_put_spnego_key;",
          "780:  rsp = (struct smb2_sess_setup_rsp *)sess_data->iov[0].iov_base;",
          "781:  ses->Suid = rsp->hdr.SessionId;",
          "783:  ses->session_flags = le16_to_cpu(rsp->SessionFlags);",
          "784:  if (ses->session_flags & SMB2_SESSION_FLAG_ENCRYPT_DATA)",
          "785:   cifs_dbg(VFS, \"SMB3 encryption not supported yet\\n\");",
          "787:  rc = SMB2_sess_establish_session(sess_data);",
          "788: out_put_spnego_key:",
          "789:  key_invalidate(spnego_key);",
          "790:  key_put(spnego_key);",
          "791: out:",
          "792:  sess_data->result = rc;",
          "793:  sess_data->func = NULL;",
          "794:  SMB2_sess_free_buffer(sess_data);",
          "795: }",
          "796: #else",
          "797: static void",
          "798: SMB2_auth_kerberos(struct SMB2_sess_data *sess_data)",
          "799: {",
          "800:  cifs_dbg(VFS, \"Kerberos negotiated but upcall support disabled!\\n\");",
          "801:  sess_data->result = -EOPNOTSUPP;",
          "802:  sess_data->func = NULL;",
          "803: }",
          "804: #endif",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "606:  struct TCP_Server_Info *server = ses->server;",
          "607:  u16 blob_length = 0;",
          "609:  char *security_blob = NULL;",
          "610:  unsigned char *ntlmssp_blob = NULL;",
          "612:  u64 previous_session = ses->Suid;",
          "614:  cifs_dbg(FYI, \"Session Setup\\n\");",
          "",
          "[Removed Lines]",
          "608:  struct key *spnego_key = NULL;",
          "",
          "[Added Lines]",
          "822:  struct SMB2_sess_data *sess_data;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "618:   return -EIO;",
          "619:  }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "831:  sess_data = kzalloc(sizeof(struct SMB2_sess_data), GFP_KERNEL);",
          "832:  if (!sess_data)",
          "833:   return -ENOMEM;",
          "834:  sess_data->xid = xid;",
          "835:  sess_data->ses = ses;",
          "836:  sess_data->buf0_type = CIFS_NO_BUFFER;",
          "837:  sess_data->nls_cp = (struct nls_table *) nls_cp;",
          "838:  sess_data->previous_session = ses->Suid;",
          "840:  if (ses->sectype == Kerberos) {",
          "841:   SMB2_auth_kerberos(sess_data);",
          "842:   goto out;",
          "843:  }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "671:  iov[0].iov_len = get_rfc1002_length(req) + 4 - 1;",
          "714:   ntlmssp_blob = kmalloc(sizeof(struct _NEGOTIATE_MESSAGE),",
          "715:            GFP_KERNEL);",
          "716:   if (ntlmssp_blob == NULL) {",
          "",
          "[Removed Lines]",
          "673:  if (ses->sectype == Kerberos) {",
          "674: #ifdef CONFIG_CIFS_UPCALL",
          "675:   struct cifs_spnego_msg *msg;",
          "677:   spnego_key = cifs_get_spnego_key(ses);",
          "678:   if (IS_ERR(spnego_key)) {",
          "679:    rc = PTR_ERR(spnego_key);",
          "680:    spnego_key = NULL;",
          "681:    goto ssetup_exit;",
          "682:   }",
          "684:   msg = spnego_key->payload.data[0];",
          "689:   if (msg->version != CIFS_SPNEGO_UPCALL_VERSION) {",
          "690:    cifs_dbg(VFS,",
          "691:       \"bad cifs.upcall version. Expected %d got %d\",",
          "692:       CIFS_SPNEGO_UPCALL_VERSION, msg->version);",
          "693:    rc = -EKEYREJECTED;",
          "694:    goto ssetup_exit;",
          "695:   }",
          "696:   ses->auth_key.response = kmemdup(msg->data, msg->sesskey_len,",
          "697:        GFP_KERNEL);",
          "698:   if (!ses->auth_key.response) {",
          "699:    cifs_dbg(VFS,",
          "700:     \"Kerberos can't allocate (%u bytes) memory\",",
          "701:     msg->sesskey_len);",
          "702:    rc = -ENOMEM;",
          "703:    goto ssetup_exit;",
          "704:   }",
          "705:   ses->auth_key.len = msg->sesskey_len;",
          "706:   blob_length = msg->secblob_len;",
          "707:   iov[1].iov_base = msg->data + msg->sesskey_len;",
          "708:   iov[1].iov_len = blob_length;",
          "709: #else",
          "710:   rc = -EOPNOTSUPP;",
          "711:   goto ssetup_exit;",
          "",
          "[Added Lines]",
          "897:  if (phase == NtLmNegotiate) {",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "853:   kfree(ses->auth_key.response);",
          "854:   ses->auth_key.response = NULL;",
          "855:  }",
          "860:  kfree(ses->ntlmssp);",
          "862:  return rc;",
          "863: }",
          "",
          "[Removed Lines]",
          "856:  if (spnego_key) {",
          "857:   key_invalidate(spnego_key);",
          "858:   key_put(spnego_key);",
          "859:  }",
          "",
          "[Added Lines]",
          "1042:  return rc;",
          "1043: out:",
          "1044:  rc = sess_data->result;",
          "1045:  kfree(sess_data);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "b8da344b74c822e966c6d19d6b2321efe82c5d97",
      "candidate_info": {
        "commit_hash": "b8da344b74c822e966c6d19d6b2321efe82c5d97",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/b8da344b74c822e966c6d19d6b2321efe82c5d97",
        "files": [
          "fs/cifs/ntlmssp.h",
          "fs/cifs/sess.c",
          "fs/cifs/smb2pdu.c"
        ],
        "message": "cifs: dynamic allocation of ntlmssp blob\n\nIn sess_auth_rawntlmssp_authenticate(), the ntlmssp blob is allocated\nstatically and its size is an \"empirical\" 5*sizeof(struct\n_AUTHENTICATE_MESSAGE) (320B on x86_64). I don't know where this value\ncomes from or if it was ever appropriate, but it is currently\ninsufficient: the user and domain name in UTF16 could take 1kB by\nthemselves. Because of that, build_ntlmssp_auth_blob() might corrupt\nmemory (out-of-bounds write). The size of ntlmssp_blob in\nSMB2_sess_setup() is too small too (sizeof(struct _NEGOTIATE_MESSAGE)\n+ 500).\n\nThis patch allocates the blob dynamically in\nbuild_ntlmssp_auth_blob().\n\nSigned-off-by: Jerome Marchand <jmarchan@redhat.com>\nSigned-off-by: Steve French <smfrench@gmail.com>\nCC: Stable <stable@vger.kernel.org>",
        "before_after_code_files": [
          "fs/cifs/ntlmssp.h||fs/cifs/ntlmssp.h",
          "fs/cifs/sess.c||fs/cifs/sess.c",
          "fs/cifs/smb2pdu.c||fs/cifs/smb2pdu.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "fs/cifs/sess.c||fs/cifs/sess.c",
            "fs/cifs/smb2pdu.c||fs/cifs/smb2pdu.c"
          ],
          "candidate": [
            "fs/cifs/sess.c||fs/cifs/sess.c",
            "fs/cifs/smb2pdu.c||fs/cifs/smb2pdu.c"
          ]
        }
      },
      "candidate_diff": {
        "fs/cifs/ntlmssp.h||fs/cifs/ntlmssp.h": [
          "File: fs/cifs/ntlmssp.h -> fs/cifs/ntlmssp.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "134: int decode_ntlmssp_challenge(char *bcc_ptr, int blob_len, struct cifs_ses *ses);",
          "135: void build_ntlmssp_negotiate_blob(unsigned char *pbuffer, struct cifs_ses *ses);",
          "137:    struct cifs_ses *ses,",
          "138:    const struct nls_table *nls_cp);",
          "",
          "[Removed Lines]",
          "136: int build_ntlmssp_auth_blob(unsigned char *pbuffer, u16 *buflen,",
          "",
          "[Added Lines]",
          "136: int build_ntlmssp_auth_blob(unsigned char **pbuffer, u16 *buflen,",
          "",
          "---------------"
        ],
        "fs/cifs/sess.c||fs/cifs/sess.c": [
          "File: fs/cifs/sess.c -> fs/cifs/sess.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "364:  sec_blob->DomainName.MaximumLength = 0;",
          "365: }",
          "371:      u16 *buflen,",
          "372:        struct cifs_ses *ses,",
          "373:        const struct nls_table *nls_cp)",
          "374: {",
          "375:  int rc;",
          "377:  __u32 flags;",
          "378:  unsigned char *tmp;",
          "380:  memcpy(sec_blob->Signature, NTLMSSP_SIGNATURE, 8);",
          "381:  sec_blob->MessageType = NtLmAuthenticate;",
          "",
          "[Removed Lines]",
          "368:    maximum possible size is fixed and small, making this approach cleaner.",
          "370: int build_ntlmssp_auth_blob(unsigned char *pbuffer,",
          "376:  AUTHENTICATE_MESSAGE *sec_blob = (AUTHENTICATE_MESSAGE *)pbuffer;",
          "",
          "[Added Lines]",
          "367: static int size_of_ntlmssp_blob(struct cifs_ses *ses)",
          "368: {",
          "369:  int sz = sizeof(AUTHENTICATE_MESSAGE) + ses->auth_key.len",
          "370:   - CIFS_SESS_KEY_SIZE + CIFS_CPHTXT_SIZE + 2;",
          "372:  if (ses->domainName)",
          "373:   sz += 2 * strnlen(ses->domainName, CIFS_MAX_DOMAINNAME_LEN);",
          "374:  else",
          "375:   sz += 2;",
          "377:  if (ses->user_name)",
          "378:   sz += 2 * strnlen(ses->user_name, CIFS_MAX_USERNAME_LEN);",
          "379:  else",
          "380:   sz += 2;",
          "382:  return sz;",
          "383: }",
          "385: int build_ntlmssp_auth_blob(unsigned char **pbuffer,",
          "391:  AUTHENTICATE_MESSAGE *sec_blob;",
          "395:  rc = setup_ntlmv2_rsp(ses, nls_cp);",
          "396:  if (rc) {",
          "397:   cifs_dbg(VFS, \"Error %d during NTLMSSP authentication\\n\", rc);",
          "399:   goto setup_ntlmv2_ret;",
          "400:  }",
          "402:  sec_blob = (AUTHENTICATE_MESSAGE *)*pbuffer;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "391:    flags |= NTLMSSP_NEGOTIATE_KEY_XCH;",
          "392:  }",
          "395:  sec_blob->NegotiateFlags = cpu_to_le32(flags);",
          "397:  sec_blob->LmChallengeResponse.BufferOffset =",
          "",
          "[Removed Lines]",
          "394:  tmp = pbuffer + sizeof(AUTHENTICATE_MESSAGE);",
          "",
          "[Added Lines]",
          "418:  tmp = *pbuffer + sizeof(AUTHENTICATE_MESSAGE);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "399:  sec_blob->LmChallengeResponse.Length = 0;",
          "400:  sec_blob->LmChallengeResponse.MaximumLength = 0;",
          "403:  if (ses->user_name != NULL) {",
          "409:   memcpy(tmp, ses->auth_key.response + CIFS_SESS_KEY_SIZE,",
          "410:     ses->auth_key.len - CIFS_SESS_KEY_SIZE);",
          "411:   tmp += ses->auth_key.len - CIFS_SESS_KEY_SIZE;",
          "",
          "[Removed Lines]",
          "402:  sec_blob->NtChallengeResponse.BufferOffset = cpu_to_le32(tmp - pbuffer);",
          "404:   rc = setup_ntlmv2_rsp(ses, nls_cp);",
          "405:   if (rc) {",
          "406:    cifs_dbg(VFS, \"Error %d during NTLMSSP authentication\\n\", rc);",
          "407:    goto setup_ntlmv2_ret;",
          "408:   }",
          "",
          "[Added Lines]",
          "426:  sec_blob->NtChallengeResponse.BufferOffset =",
          "427:     cpu_to_le32(tmp - *pbuffer);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "423:  }",
          "425:  if (ses->domainName == NULL) {",
          "427:   sec_blob->DomainName.Length = 0;",
          "428:   sec_blob->DomainName.MaximumLength = 0;",
          "429:   tmp += 2;",
          "",
          "[Removed Lines]",
          "426:   sec_blob->DomainName.BufferOffset = cpu_to_le32(tmp - pbuffer);",
          "",
          "[Added Lines]",
          "446:   sec_blob->DomainName.BufferOffset = cpu_to_le32(tmp - *pbuffer);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "432:   len = cifs_strtoUTF16((__le16 *)tmp, ses->domainName,",
          "433:           CIFS_MAX_DOMAINNAME_LEN, nls_cp);",
          "436:   sec_blob->DomainName.Length = cpu_to_le16(len);",
          "437:   sec_blob->DomainName.MaximumLength = cpu_to_le16(len);",
          "438:   tmp += len;",
          "439:  }",
          "441:  if (ses->user_name == NULL) {",
          "443:   sec_blob->UserName.Length = 0;",
          "444:   sec_blob->UserName.MaximumLength = 0;",
          "445:   tmp += 2;",
          "",
          "[Removed Lines]",
          "435:   sec_blob->DomainName.BufferOffset = cpu_to_le32(tmp - pbuffer);",
          "442:   sec_blob->UserName.BufferOffset = cpu_to_le32(tmp - pbuffer);",
          "",
          "[Added Lines]",
          "455:   sec_blob->DomainName.BufferOffset = cpu_to_le32(tmp - *pbuffer);",
          "462:   sec_blob->UserName.BufferOffset = cpu_to_le32(tmp - *pbuffer);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "448:   len = cifs_strtoUTF16((__le16 *)tmp, ses->user_name,",
          "449:           CIFS_MAX_USERNAME_LEN, nls_cp);",
          "452:   sec_blob->UserName.Length = cpu_to_le16(len);",
          "453:   sec_blob->UserName.MaximumLength = cpu_to_le16(len);",
          "454:   tmp += len;",
          "455:  }",
          "458:  sec_blob->WorkstationName.Length = 0;",
          "459:  sec_blob->WorkstationName.MaximumLength = 0;",
          "460:  tmp += 2;",
          "",
          "[Removed Lines]",
          "451:   sec_blob->UserName.BufferOffset = cpu_to_le32(tmp - pbuffer);",
          "457:  sec_blob->WorkstationName.BufferOffset = cpu_to_le32(tmp - pbuffer);",
          "",
          "[Added Lines]",
          "471:   sec_blob->UserName.BufferOffset = cpu_to_le32(tmp - *pbuffer);",
          "477:  sec_blob->WorkstationName.BufferOffset = cpu_to_le32(tmp - *pbuffer);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "463:   (ses->ntlmssp->server_flags & NTLMSSP_NEGOTIATE_EXTENDED_SEC))",
          "464:    && !calc_seckey(ses)) {",
          "465:   memcpy(tmp, ses->ntlmssp->ciphertext, CIFS_CPHTXT_SIZE);",
          "467:   sec_blob->SessionKey.Length = cpu_to_le16(CIFS_CPHTXT_SIZE);",
          "468:   sec_blob->SessionKey.MaximumLength =",
          "469:     cpu_to_le16(CIFS_CPHTXT_SIZE);",
          "470:   tmp += CIFS_CPHTXT_SIZE;",
          "471:  } else {",
          "473:   sec_blob->SessionKey.Length = 0;",
          "474:   sec_blob->SessionKey.MaximumLength = 0;",
          "475:  }",
          "477: setup_ntlmv2_ret:",
          "479:  return rc;",
          "480: }",
          "",
          "[Removed Lines]",
          "466:   sec_blob->SessionKey.BufferOffset = cpu_to_le32(tmp - pbuffer);",
          "472:   sec_blob->SessionKey.BufferOffset = cpu_to_le32(tmp - pbuffer);",
          "",
          "[Added Lines]",
          "486:   sec_blob->SessionKey.BufferOffset = cpu_to_le32(tmp - *pbuffer);",
          "492:   sec_blob->SessionKey.BufferOffset = cpu_to_le32(tmp - *pbuffer);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "1266:  struct cifs_ses *ses = sess_data->ses;",
          "1267:  __u16 bytes_remaining;",
          "1268:  char *bcc_ptr;",
          "1270:  u16 blob_len;",
          "1272:  cifs_dbg(FYI, \"rawntlmssp session setup authenticate phase\\n\");",
          "",
          "[Removed Lines]",
          "1269:  char *ntlmsspblob = NULL;",
          "",
          "[Added Lines]",
          "1289:  unsigned char *ntlmsspblob = NULL;",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "1280:  pSMB = (SESSION_SETUP_ANDX *)sess_data->iov[0].iov_base;",
          "1281:  smb_buf = (struct smb_hdr *)pSMB;",
          "1295:      &blob_len, ses, sess_data->nls_cp);",
          "1296:  if (rc)",
          "1297:   goto out_free_ntlmsspblob;",
          "",
          "[Removed Lines]",
          "1287:  ntlmsspblob = kzalloc(5*sizeof(struct _AUTHENTICATE_MESSAGE),",
          "1288:     GFP_KERNEL);",
          "1289:  if (!ntlmsspblob) {",
          "1290:   rc = -ENOMEM;",
          "1291:   goto out;",
          "1292:  }",
          "1294:  rc = build_ntlmssp_auth_blob(ntlmsspblob,",
          "",
          "[Added Lines]",
          "1302:  rc = build_ntlmssp_auth_blob(&ntlmsspblob,",
          "",
          "---------------"
        ],
        "fs/cifs/smb2pdu.c||fs/cifs/smb2pdu.c": [
          "File: fs/cifs/smb2pdu.c -> fs/cifs/smb2pdu.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "588:  u16 blob_length = 0;",
          "589:  struct key *spnego_key = NULL;",
          "590:  char *security_blob = NULL;",
          "594:  cifs_dbg(FYI, \"Session Setup\\n\");",
          "",
          "[Removed Lines]",
          "591:  char *ntlmssp_blob = NULL;",
          "",
          "[Added Lines]",
          "591:  unsigned char *ntlmssp_blob = NULL;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "713:   iov[1].iov_len = blob_length;",
          "714:  } else if (phase == NtLmAuthenticate) {",
          "715:   req->hdr.SessionId = ses->Suid;",
          "723:           nls_cp);",
          "724:   if (rc) {",
          "725:    cifs_dbg(FYI, \"build_ntlmssp_auth_blob failed %d\\n\",",
          "",
          "[Removed Lines]",
          "716:   ntlmssp_blob = kzalloc(sizeof(struct _NEGOTIATE_MESSAGE) + 500,",
          "717:            GFP_KERNEL);",
          "718:   if (ntlmssp_blob == NULL) {",
          "719:    rc = -ENOMEM;",
          "720:    goto ssetup_exit;",
          "721:   }",
          "722:   rc = build_ntlmssp_auth_blob(ntlmssp_blob, &blob_length, ses,",
          "",
          "[Added Lines]",
          "716:   rc = build_ntlmssp_auth_blob(&ntlmssp_blob, &blob_length, ses,",
          "",
          "---------------"
        ]
      }
    }
  ]
}
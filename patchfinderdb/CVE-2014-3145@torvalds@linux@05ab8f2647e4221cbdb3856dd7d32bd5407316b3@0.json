{
  "cve_id": "CVE-2014-3145",
  "cve_desc": "The BPF_S_ANC_NLATTR_NEST extension implementation in the sk_run_filter function in net/core/filter.c in the Linux kernel through 3.14.3 uses the reverse order in a certain subtraction, which allows local users to cause a denial of service (over-read and system crash) via crafted BPF instructions.  NOTE: the affected code was moved to the __skb_get_nlattr_nest function before the vulnerability was announced.",
  "repo": "torvalds/linux",
  "patch_hash": "05ab8f2647e4221cbdb3856dd7d32bd5407316b3",
  "patch_info": {
    "commit_hash": "05ab8f2647e4221cbdb3856dd7d32bd5407316b3",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/05ab8f2647e4221cbdb3856dd7d32bd5407316b3",
    "files": [
      "net/core/filter.c"
    ],
    "message": "filter: prevent nla extensions to peek beyond the end of the message\n\nThe BPF_S_ANC_NLATTR and BPF_S_ANC_NLATTR_NEST extensions fail to check\nfor a minimal message length before testing the supplied offset to be\nwithin the bounds of the message. This allows the subtraction of the nla\nheader to underflow and therefore -- as the data type is unsigned --\nallowing far to big offset and length values for the search of the\nnetlink attribute.\n\nThe remainder calculation for the BPF_S_ANC_NLATTR_NEST extension is\nalso wrong. It has the minuend and subtrahend mixed up, therefore\ncalculates a huge length value, allowing to overrun the end of the\nmessage while looking for the netlink attribute.\n\nThe following three BPF snippets will trigger the bugs when attached to\na UNIX datagram socket and parsing a message with length 1, 2 or 3.\n\n ,-[ PoC for missing size check in BPF_S_ANC_NLATTR ]--\n | ld\t#0x87654321\n | ldx\t#42\n | ld\t#nla\n | ret\ta\n `---\n\n ,-[ PoC for the same bug in BPF_S_ANC_NLATTR_NEST ]--\n | ld\t#0x87654321\n | ldx\t#42\n | ld\t#nlan\n | ret\ta\n `---\n\n ,-[ PoC for wrong remainder calculation in BPF_S_ANC_NLATTR_NEST ]--\n | ; (needs a fake netlink header at offset 0)\n | ld\t#0\n | ldx\t#42\n | ld\t#nlan\n | ret\ta\n `---\n\nFix the first issue by ensuring the message length fulfills the minimal\nsize constrains of a nla header. Fix the second bug by getting the math\nfor the remainder calculation right.\n\nFixes: 4738c1db15 (\"[SKFILTER]: Add SKF_ADF_NLATTR instruction\")\nFixes: d214c7537b (\"filter: add SKF_AD_NLATTR_NEST to look for nested..\")\nCc: Patrick McHardy <kaber@trash.net>\nCc: Pablo Neira Ayuso <pablo@netfilter.org>\nSigned-off-by: Mathias Krause <minipli@googlemail.com>\nAcked-by: Daniel Borkmann <dborkman@redhat.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
    "before_after_code_files": [
      "net/core/filter.c||net/core/filter.c"
    ]
  },
  "patch_diff": {
    "net/core/filter.c||net/core/filter.c": [
      "File: net/core/filter.c -> net/core/filter.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "600:  if (skb_is_nonlinear(skb))",
      "601:   return 0;",
      "603:  if (A > skb->len - sizeof(struct nlattr))",
      "604:   return 0;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "603:  if (skb->len < sizeof(struct nlattr))",
      "604:   return 0;",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "618:  if (skb_is_nonlinear(skb))",
      "619:   return 0;",
      "621:  if (A > skb->len - sizeof(struct nlattr))",
      "622:   return 0;",
      "624:  nla = (struct nlattr *) &skb->data[A];",
      "626:   return 0;",
      "628:  nla = nla_find_nested(nla, X);",
      "",
      "[Removed Lines]",
      "625:  if (nla->nla_len > A - skb->len)",
      "",
      "[Added Lines]",
      "624:  if (skb->len < sizeof(struct nlattr))",
      "625:   return 0;",
      "631:  if (nla->nla_len > skb->len - A)",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "ed55b6ac077fe7f9c6490ff55172c4b563562d7c",
      "candidate_info": {
        "commit_hash": "ed55b6ac077fe7f9c6490ff55172c4b563562d7c",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/ed55b6ac077fe7f9c6490ff55172c4b563562d7c",
        "files": [
          "fs/btrfs/extent-tree.c"
        ],
        "message": "btrfs: fix lockdep warning with reclaim lock inversion\n\nWhen encountering memory pressure, testers have run into the following\nlockdep warning. It was caused by __link_block_group calling kobject_add\nwith the groups_sem held. kobject_add calls kvasprintf with GFP_KERNEL,\nwhich gets us into reclaim context. The kobject doesn't actually need\nto be added under the lock -- it just needs to ensure that it's only\nadded for the first block group to be linked.\n\n=========================================================\n[ INFO: possible irq lock inversion dependency detected ]\n3.14.0-rc8-default #1 Not tainted\n---------------------------------------------------------\nkswapd0/169 just changed the state of lock:\n (&delayed_node->mutex){+.+.-.}, at: [<ffffffffa018baea>] __btrfs_release_delayed_node+0x3a/0x200 [btrfs]\nbut this lock took another, RECLAIM_FS-unsafe lock in the past:\n (&found->groups_sem){+++++.}\n\nand interrupts could create inverse lock ordering between them.\n\nother info that might help us debug this:\n Possible interrupt unsafe locking scenario:\n       CPU0                    CPU1\n       ----                    ----\n  lock(&found->groups_sem);\n                               local_irq_disable();\n                               lock(&delayed_node->mutex);\n                               lock(&found->groups_sem);\n  <Interrupt>\n    lock(&delayed_node->mutex);\n\n *** DEADLOCK ***\n2 locks held by kswapd0/169:\n #0:  (shrinker_rwsem){++++..}, at: [<ffffffff81159e8a>] shrink_slab+0x3a/0x160\n #1:  (&type->s_umount_key#27){++++..}, at: [<ffffffff811bac6f>] grab_super_passive+0x3f/0x90\n\nSigned-off-by: Jeff Mahoney <jeffm@suse.com>\nSigned-off-by: Chris Mason <clm@fb.com>",
        "before_after_code_files": [
          "fs/btrfs/extent-tree.c||fs/btrfs/extent-tree.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "fs/btrfs/extent-tree.c||fs/btrfs/extent-tree.c": [
          "File: fs/btrfs/extent-tree.c -> fs/btrfs/extent-tree.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "8337:           struct btrfs_block_group_cache *cache)",
          "8338: {",
          "8339:  int index = get_block_group_index(cache);",
          "8341:  down_write(&space_info->groups_sem);",
          "8343:   struct kobject *kobj = &space_info->block_group_kobjs[index];",
          "8344:   int ret;",
          "",
          "[Removed Lines]",
          "8342:  if (list_empty(&space_info->block_groups[index])) {",
          "",
          "[Added Lines]",
          "8340:  bool first = false;",
          "8343:  if (list_empty(&space_info->block_groups[index]))",
          "8344:   first = true;",
          "8345:  list_add_tail(&cache->list, &space_info->block_groups[index]);",
          "8346:  up_write(&space_info->groups_sem);",
          "8348:  if (first) {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "8351:    kobject_put(&space_info->kobj);",
          "8352:   }",
          "8353:  }",
          "8356: }",
          "8358: static struct btrfs_block_group_cache *",
          "",
          "[Removed Lines]",
          "8354:  list_add_tail(&cache->list, &space_info->block_groups[index]);",
          "8355:  up_write(&space_info->groups_sem);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "b10ebd34cccae1b431caf1be54919aede2be7cbe",
      "candidate_info": {
        "commit_hash": "b10ebd34cccae1b431caf1be54919aede2be7cbe",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/b10ebd34cccae1b431caf1be54919aede2be7cbe",
        "files": [
          "drivers/md/dm-thin.c"
        ],
        "message": "dm thin: fix rcu_read_lock being held in code that can sleep\n\nCommit c140e1c4e23 (\"dm thin: use per thin device deferred bio lists\")\nintroduced the use of an rculist for all active thin devices.  The use\nof rcu_read_lock() in process_deferred_bios() can result in a BUG if a\ndm_bio_prison_cell must be allocated as a side-effect of bio_detain():\n\n BUG: sleeping function called from invalid context at mm/mempool.c:203\n in_atomic(): 1, irqs_disabled(): 0, pid: 6, name: kworker/u8:0\n 3 locks held by kworker/u8:0/6:\n   #0:  (\"dm-\" \"thin\"){.+.+..}, at: [<ffffffff8106be42>] process_one_work+0x192/0x550\n   #1:  ((&pool->worker)){+.+...}, at: [<ffffffff8106be42>] process_one_work+0x192/0x550\n   #2:  (rcu_read_lock){.+.+..}, at: [<ffffffff816360b5>] do_worker+0x5/0x4d0\n\nWe can't process deferred bios with the rcu lock held, since\ndm_bio_prison_cell allocation may block if the bio-prison's cell mempool\nis exhausted.\n\nTo fix:\n\n- Introduce a refcount and completion field to each thin_c\n\n- Add thin_get/put methods for adjusting the refcount.  If the refcount\n  hits zero then the completion is triggered.\n\n- Initialise refcount to 1 when creating thin_c\n\n- When iterating the active_thins list we thin_get() whilst the rcu\n  lock is held.\n\n- After the rcu lock is dropped we process the deferred bios for that\n  thin.\n\n- When destroying a thin_c we thin_put() and then wait for the\n  completion -- to avoid a race between the worker thread iterating\n  from that thin_c and destroying the thin_c.\n\nSigned-off-by: Joe Thornber <ejt@redhat.com>\nSigned-off-by: Mike Snitzer <snitzer@redhat.com>",
        "before_after_code_files": [
          "drivers/md/dm-thin.c||drivers/md/dm-thin.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "drivers/md/dm-thin.c||drivers/md/dm-thin.c": [
          "File: drivers/md/dm-thin.c -> drivers/md/dm-thin.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "232:  struct bio_list deferred_bio_list;",
          "233:  struct bio_list retry_on_resume_list;",
          "235: };",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "240:  atomic_t refcount;",
          "241:  struct completion can_destroy;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1486:  blk_finish_plug(&plug);",
          "1487: }",
          "1489: static void process_deferred_bios(struct pool *pool)",
          "1490: {",
          "1491:  unsigned long flags;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1496: static void thin_get(struct thin_c *tc);",
          "1497: static void thin_put(struct thin_c *tc);",
          "1504: static struct thin_c *get_first_thin(struct pool *pool)",
          "1505: {",
          "1506:  struct thin_c *tc = NULL;",
          "1508:  rcu_read_lock();",
          "1509:  if (!list_empty(&pool->active_thins)) {",
          "1510:   tc = list_entry_rcu(pool->active_thins.next, struct thin_c, list);",
          "1511:   thin_get(tc);",
          "1512:  }",
          "1513:  rcu_read_unlock();",
          "1515:  return tc;",
          "1516: }",
          "1518: static struct thin_c *get_next_thin(struct pool *pool, struct thin_c *tc)",
          "1519: {",
          "1520:  struct thin_c *old_tc = tc;",
          "1522:  rcu_read_lock();",
          "1523:  list_for_each_entry_continue_rcu(tc, &pool->active_thins, list) {",
          "1524:   thin_get(tc);",
          "1525:   thin_put(old_tc);",
          "1526:   rcu_read_unlock();",
          "1527:   return tc;",
          "1528:  }",
          "1529:  thin_put(old_tc);",
          "1530:  rcu_read_unlock();",
          "1532:  return NULL;",
          "1533: }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1493:  struct bio_list bios;",
          "1494:  struct thin_c *tc;",
          "1498:   process_thin_deferred_bios(tc);",
          "",
          "[Removed Lines]",
          "1496:  rcu_read_lock();",
          "1497:  list_for_each_entry_rcu(tc, &pool->active_thins, list)",
          "1499:  rcu_read_unlock();",
          "",
          "[Added Lines]",
          "1542:  tc = get_first_thin(pool);",
          "1543:  while (tc) {",
          "1545:   tc = get_next_thin(pool, tc);",
          "1546:  }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "3064: static void thin_dtr(struct dm_target *ti)",
          "3065: {",
          "3066:  struct thin_c *tc = ti->private;",
          "3067:  unsigned long flags;",
          "3069:  spin_lock_irqsave(&tc->pool->lock, flags);",
          "3070:  list_del_rcu(&tc->list);",
          "3071:  spin_unlock_irqrestore(&tc->pool->lock, flags);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3111: static void thin_get(struct thin_c *tc)",
          "3112: {",
          "3113:  atomic_inc(&tc->refcount);",
          "3114: }",
          "3116: static void thin_put(struct thin_c *tc)",
          "3117: {",
          "3118:  if (atomic_dec_and_test(&tc->refcount))",
          "3119:   complete(&tc->can_destroy);",
          "3120: }",
          "3127:  thin_put(tc);",
          "3128:  wait_for_completion(&tc->can_destroy);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "3193:  mutex_unlock(&dm_thin_pool_table.mutex);",
          "3195:  spin_lock_irqsave(&tc->pool->lock, flags);",
          "3196:  list_add_tail_rcu(&tc->list, &tc->pool->active_thins);",
          "3197:  spin_unlock_irqrestore(&tc->pool->lock, flags);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3256:  atomic_set(&tc->refcount, 1);",
          "3257:  init_completion(&tc->can_destroy);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "b34aa86f12e8848ba453215602c8c50fa63c4cb3",
      "candidate_info": {
        "commit_hash": "b34aa86f12e8848ba453215602c8c50fa63c4cb3",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/b34aa86f12e8848ba453215602c8c50fa63c4cb3",
        "files": [
          "drivers/staging/comedi/comedi_buf.c",
          "drivers/staging/comedi/comedi_fops.c",
          "drivers/staging/comedi/comedi_internal.h"
        ],
        "message": "staging: comedi: fix circular locking dependency in comedi_mmap()\n\nMmapping a comedi data buffer with lockdep checking enabled produced the\nfollowing kernel debug messages:\n\n======================================================\n[ INFO: possible circular locking dependency detected ]\n3.5.0-rc3-ija1+ #9 Tainted: G         C\n-------------------------------------------------------\ncomedi_test/4160 is trying to acquire lock:\n (&dev->mutex#2){+.+.+.}, at: [<ffffffffa00313f4>] comedi_mmap+0x57/0x1d9 [comedi]\n\nbut task is already holding lock:\n (&mm->mmap_sem){++++++}, at: [<ffffffff810c96fe>] vm_mmap_pgoff+0x41/0x76\n\nwhich lock already depends on the new lock.\n\nthe existing dependency chain (in reverse order) is:\n\n-> #1 (&mm->mmap_sem){++++++}:\n       [<ffffffff8106d0e8>] lock_acquire+0x97/0x105\n       [<ffffffff810ce3bc>] might_fault+0x6d/0x90\n       [<ffffffffa0031ffb>] do_devinfo_ioctl.isra.7+0x11e/0x14c [comedi]\n       [<ffffffffa003227f>] comedi_unlocked_ioctl+0x256/0xe48 [comedi]\n       [<ffffffff810f7fcd>] vfs_ioctl+0x18/0x34\n       [<ffffffff810f87fd>] do_vfs_ioctl+0x382/0x43c\n       [<ffffffff810f88f9>] sys_ioctl+0x42/0x65\n       [<ffffffff81415c62>] system_call_fastpath+0x16/0x1b\n\n-> #0 (&dev->mutex#2){+.+.+.}:\n       [<ffffffff8106c528>] __lock_acquire+0x101d/0x1591\n       [<ffffffff8106d0e8>] lock_acquire+0x97/0x105\n       [<ffffffff8140c894>] mutex_lock_nested+0x46/0x2a4\n       [<ffffffffa00313f4>] comedi_mmap+0x57/0x1d9 [comedi]\n       [<ffffffff810d5816>] mmap_region+0x281/0x492\n       [<ffffffff810d5c92>] do_mmap_pgoff+0x26b/0x2a7\n       [<ffffffff810c971a>] vm_mmap_pgoff+0x5d/0x76\n       [<ffffffff810d493f>] sys_mmap_pgoff+0xc7/0x10d\n       [<ffffffff81004d36>] sys_mmap+0x16/0x20\n       [<ffffffff81415c62>] system_call_fastpath+0x16/0x1b\n\nother info that might help us debug this:\n\n Possible unsafe locking scenario:\n\n       CPU0                    CPU1\n       ----                    ----\n  lock(&mm->mmap_sem);\n                               lock(&dev->mutex#2);\n                               lock(&mm->mmap_sem);\n  lock(&dev->mutex#2);\n\n *** DEADLOCK ***\n\nTo avoid the circular dependency, just try to get the lock in\n`comedi_mmap()` instead of blocking.  Since the comedi device's main mutex\nis heavily used, do a down-read of its `attach_lock` rwsemaphore\ninstead.  Trying to down-read `attach_lock` should only fail if\nsome task has down-write locked it, and that is only done while the\ncomedi device is being attached to or detached from a low-level hardware\ndevice.\n\nUnfortunately, acquiring the `attach_lock` doesn't prevent another\ntask replacing the comedi data buffer we are trying to mmap.  The\ndetails of the buffer are held in a `struct comedi_buf_map` and pointed\nto by `s->async->buf_map` where `s` is the comedi subdevice whose buffer\nwe are trying to map.  The `struct comedi_buf_map` is already reference\ncounted with a `struct kref`, so we can stop it being freed prematurely.\n\nModify `comedi_mmap()` to call new function\n`comedi_buf_map_from_subdev_get()` to read the subdevice's current\nbuffer map pointer and increment its reference instead of accessing\n`async->buf_map` directly.  Call `comedi_buf_map_put()` to decrement the\nreference once the buffer map structure has been dealt with.  (Note that\n`comedi_buf_map_put()` does nothing if passed a NULL pointer.)\n\n`comedi_buf_map_from_subdev_get()` checks the subdevice's buffer map\npointer has been set and the buffer map has been initialized enough for\n`comedi_mmap()` to deal with it (specifically, check the `n_pages`\nmember has been set to a non-zero value).  If all is well, the buffer\nmap's reference is incremented and a pointer to it is returned.  The\ncomedi subdevice's spin-lock is used to protect the checks.  Also use\nthe spin-lock in `__comedi_buf_alloc()` and `__comedi_buf_free()` to\nprotect changes to the subdevice's buffer map structure pointer and the\nbuffer map structure's `n_pages` member.  (This checking of `n_pages` is\na bit clunky and I [Ian Abbott] plan to deal with it in the future.)\n\nSigned-off-by: Ian Abbott <abbotti@mev.co.uk>\nCc: <stable@vger.kernel.org> # 3.14.x, 3.15.x\nSigned-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>",
        "before_after_code_files": [
          "drivers/staging/comedi/comedi_buf.c||drivers/staging/comedi/comedi_buf.c",
          "drivers/staging/comedi/comedi_fops.c||drivers/staging/comedi/comedi_fops.c",
          "drivers/staging/comedi/comedi_internal.h||drivers/staging/comedi/comedi_internal.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "drivers/staging/comedi/comedi_buf.c||drivers/staging/comedi/comedi_buf.c": [
          "File: drivers/staging/comedi/comedi_buf.c -> drivers/staging/comedi/comedi_buf.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "61:          struct comedi_subdevice *s)",
          "62: {",
          "63:  struct comedi_async *async = s->async;",
          "65:  if (async->prealloc_buf) {",
          "66:   vunmap(async->prealloc_buf);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "64:  struct comedi_buf_map *bm;",
          "65:  unsigned long flags;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "68:   async->prealloc_bufsz = 0;",
          "69:  }",
          "72:  async->buf_map = NULL;",
          "73: }",
          "75: static void __comedi_buf_alloc(struct comedi_device *dev,",
          "",
          "[Removed Lines]",
          "71:  comedi_buf_map_put(async->buf_map);",
          "",
          "[Added Lines]",
          "73:  spin_lock_irqsave(&s->spin_lock, flags);",
          "74:  bm = async->buf_map;",
          "76:  spin_unlock_irqrestore(&s->spin_lock, flags);",
          "77:  comedi_buf_map_put(bm);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "80:  struct page **pages = NULL;",
          "81:  struct comedi_buf_map *bm;",
          "82:  struct comedi_buf_page *buf;",
          "83:  unsigned i;",
          "85:  if (!IS_ENABLED(CONFIG_HAS_DMA) && s->async_dma_dir != DMA_NONE) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "88:  unsigned long flags;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "92:  if (!bm)",
          "93:   return;",
          "96:  kref_init(&bm->refcount);",
          "97:  bm->dma_dir = s->async_dma_dir;",
          "98:  if (bm->dma_dir != DMA_NONE)",
          "",
          "[Removed Lines]",
          "95:  async->buf_map = bm;",
          "",
          "[Added Lines]",
          "102:  spin_lock_irqsave(&s->spin_lock, flags);",
          "103:  async->buf_map = bm;",
          "104:  spin_unlock_irqrestore(&s->spin_lock, flags);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "128:   pages[i] = virt_to_page(buf->virt_addr);",
          "129:  }",
          "130:  bm->n_pages = i;",
          "133:  if (i == n_pages)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "138:  spin_lock_irqsave(&s->spin_lock, flags);",
          "140:  spin_unlock_irqrestore(&s->spin_lock, flags);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "150:  return 1;",
          "151: }",
          "153: bool comedi_buf_is_mmapped(struct comedi_async *async)",
          "154: {",
          "155:  struct comedi_buf_map *bm = async->buf_map;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "164: struct comedi_buf_map *",
          "165: comedi_buf_map_from_subdev_get(struct comedi_subdevice *s)",
          "166: {",
          "167:  struct comedi_async *async = s->async;",
          "168:  struct comedi_buf_map *bm = NULL;",
          "169:  unsigned long flags;",
          "171:  if (!async)",
          "172:   return NULL;",
          "174:  spin_lock_irqsave(&s->spin_lock, flags);",
          "175:  bm = async->buf_map;",
          "177:  if (bm && bm->n_pages)",
          "178:   comedi_buf_map_get(bm);",
          "179:  else",
          "180:   bm = NULL;",
          "181:  spin_unlock_irqrestore(&s->spin_lock, flags);",
          "183:  return bm;",
          "184: }",
          "",
          "---------------"
        ],
        "drivers/staging/comedi/comedi_fops.c||drivers/staging/comedi/comedi_fops.c": [
          "File: drivers/staging/comedi/comedi_fops.c -> drivers/staging/comedi/comedi_fops.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1926:  struct comedi_device *dev = file->private_data;",
          "1927:  struct comedi_subdevice *s;",
          "1928:  struct comedi_async *async;",
          "1930:  unsigned long start = vma->vm_start;",
          "1931:  unsigned long size;",
          "1932:  int n_pages;",
          "1933:  int i;",
          "1934:  int retval;",
          "1938:  if (!dev->attached) {",
          "1939:   dev_dbg(dev->class_dev, \"no driver attached\\n\");",
          "",
          "[Removed Lines]",
          "1929:  struct comedi_buf_map *bm;",
          "1936:  mutex_lock(&dev->mutex);",
          "",
          "[Added Lines]",
          "1929:  struct comedi_buf_map *bm = NULL;",
          "1942:  if (!down_read_trylock(&dev->attach_lock))",
          "1943:   return -EAGAIN;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1973:  }",
          "1975:  n_pages = size >> PAGE_SHIFT;",
          "1977:  if (!bm || n_pages > bm->n_pages) {",
          "1978:   retval = -EINVAL;",
          "1979:   goto done;",
          "",
          "[Removed Lines]",
          "1976:  bm = async->buf_map;",
          "",
          "[Added Lines]",
          "1985:  bm = comedi_buf_map_from_subdev_get(s);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1998:  retval = 0;",
          "1999: done:",
          "2001:  return retval;",
          "2002: }",
          "",
          "[Removed Lines]",
          "2000:  mutex_unlock(&dev->mutex);",
          "",
          "[Added Lines]",
          "2009:  up_read(&dev->attach_lock);",
          "",
          "---------------"
        ],
        "drivers/staging/comedi/comedi_internal.h||drivers/staging/comedi/comedi_internal.h": [
          "File: drivers/staging/comedi/comedi_internal.h -> drivers/staging/comedi/comedi_internal.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "19: bool comedi_buf_is_mmapped(struct comedi_async *async);",
          "20: void comedi_buf_map_get(struct comedi_buf_map *bm);",
          "21: int comedi_buf_map_put(struct comedi_buf_map *bm);",
          "22: unsigned int comedi_buf_write_n_allocated(struct comedi_async *async);",
          "23: void comedi_device_cancel_all(struct comedi_device *dev);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "22: struct comedi_buf_map *comedi_buf_map_from_subdev_get(",
          "23:   struct comedi_subdevice *s);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "eb4a5346e777784f1b5ae9fd0c29b96344bdc3ae",
      "candidate_info": {
        "commit_hash": "eb4a5346e777784f1b5ae9fd0c29b96344bdc3ae",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/eb4a5346e777784f1b5ae9fd0c29b96344bdc3ae",
        "files": [
          "drivers/char/hw_random/bcm2835-rng.c"
        ],
        "message": "hwrng: bcm2835 - fix oops when rng h/w is accessed during registration\n\nCommit \"d9e7972 hwrng: add randomness to system from rng sources\"\nexposed a bug in the bcm2835-rng driver resulting in boot failure\non Raspberry Pi due to the following oops:\n\n[   28.261523] BUG: soft lockup - CPU#0 stuck for 23s! [swapper:1]\n[   28.271058]\n[   28.275958] CPU: 0 PID: 1 Comm: swapper Not tainted 3.14.0+ #11\n[   28.285374] task: db480000 ti: db484000 task.ti: db484000\n[   28.294279] PC is at bcm2835_rng_read+0x28/0x48\n[   28.302276] LR is at hwrng_register+0x1a8/0x238\n.\n.\n.\n\nThe RNG h/w is not completely initialized and enabled before\nhwrng_register() is called and so the bcm2835_rng_read() fails.\nFix this by making the warmup/enable writes before registering\nthe RNG source with the hwrng core.\n\nSigned-off-by: Matt Porter <mporter@linaro.org>\nSigned-off-by: Herbert Xu <herbert@gondor.apana.org.au>",
        "before_after_code_files": [
          "drivers/char/hw_random/bcm2835-rng.c||drivers/char/hw_random/bcm2835-rng.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "drivers/char/hw_random/bcm2835-rng.c||drivers/char/hw_random/bcm2835-rng.c": [
          "File: drivers/char/hw_random/bcm2835-rng.c -> drivers/char/hw_random/bcm2835-rng.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "61:  }",
          "62:  bcm2835_rng_ops.priv = (unsigned long)rng_base;",
          "65:  err = hwrng_register(&bcm2835_rng_ops);",
          "66:  if (err) {",
          "67:   dev_err(dev, \"hwrng registration failed\\n\");",
          "68:   iounmap(rng_base);",
          "70:   dev_info(dev, \"hwrng registered\\n\");",
          "76:  return err;",
          "77: }",
          "",
          "[Removed Lines]",
          "69:  } else {",
          "73:   __raw_writel(RNG_WARMUP_COUNT, rng_base + RNG_STATUS);",
          "74:   __raw_writel(RNG_RBGEN, rng_base + RNG_CTRL);",
          "75:  }",
          "",
          "[Added Lines]",
          "65:  __raw_writel(RNG_WARMUP_COUNT, rng_base + RNG_STATUS);",
          "66:  __raw_writel(RNG_RBGEN, rng_base + RNG_CTRL);",
          "73:  } else",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "007649375f6af242d5b1df2c15996949714303ba",
      "candidate_info": {
        "commit_hash": "007649375f6af242d5b1df2c15996949714303ba",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/007649375f6af242d5b1df2c15996949714303ba",
        "files": [
          "fs/ext4/super.c"
        ],
        "message": "ext4: initialize multi-block allocator before checking block descriptors\n\nWith EXT4FS_DEBUG ext4_count_free_clusters() will call\next4_read_block_bitmap() without s_group_info initialized, so we need to\ninitialize multi-block allocator before.\n\nAnd dependencies that must be solved, to allow this:\n- multi-block allocator needs in group descriptors\n- need to install s_op before initializing multi-block allocator,\n  because in ext4_mb_init_backend() new inode is created.\n- initialize number of group desc blocks (s_gdb_count) otherwise\n  number of clusters returned by ext4_free_clusters_after_init() is not correct.\n  (see ext4_bg_num_gdb_nometa())\n\nHere is the stack backtrace:\n\n(gdb) bt\n #0  ext4_get_group_info (group=0, sb=0xffff880079a10000) at ext4.h:2430\n #1  ext4_validate_block_bitmap (sb=sb@entry=0xffff880079a10000,\n     desc=desc@entry=0xffff880056510000, block_group=block_group@entry=0,\n     bh=bh@entry=0xffff88007bf2b2d8) at balloc.c:358\n #2  0xffffffff81232202 in ext4_wait_block_bitmap (sb=sb@entry=0xffff880079a10000,\n     block_group=block_group@entry=0,\n     bh=bh@entry=0xffff88007bf2b2d8) at balloc.c:476\n #3  0xffffffff81232eaf in ext4_read_block_bitmap (sb=sb@entry=0xffff880079a10000,\n     block_group=block_group@entry=0) at balloc.c:489\n #4  0xffffffff81232fc0 in ext4_count_free_clusters (sb=sb@entry=0xffff880079a10000) at balloc.c:665\n #5  0xffffffff81259ffa in ext4_check_descriptors (first_not_zeroed=<synthetic pointer>,\n     sb=0xffff880079a10000) at super.c:2143\n #6  ext4_fill_super (sb=sb@entry=0xffff880079a10000, data=<optimized out>,\n     data@entry=0x0 <irq_stack_union>, silent=silent@entry=0) at super.c:3851\n     ...\n\nSigned-off-by: Azat Khuzhin <a3at.mail@gmail.com>\nSigned-off-by: \"Theodore Ts'o\" <tytso@mit.edu>",
        "before_after_code_files": [
          "fs/ext4/super.c||fs/ext4/super.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "fs/ext4/super.c||fs/ext4/super.c": [
          "File: fs/ext4/super.c -> fs/ext4/super.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "3869:    goto failed_mount2;",
          "3870:   }",
          "3871:  }",
          "3872:  if (!ext4_check_descriptors(sb, &first_not_zeroed)) {",
          "3873:   ext4_msg(sb, KERN_ERR, \"group descriptors corrupted!\");",
          "3875:  }",
          "3876:  if (EXT4_HAS_INCOMPAT_FEATURE(sb, EXT4_FEATURE_INCOMPAT_FLEX_BG))",
          "3877:   if (!ext4_fill_flex_info(sb)) {",
          "3878:    ext4_msg(sb, KERN_ERR,",
          "3879:           \"unable to initialize \"",
          "3880:           \"flex_bg meta info!\");",
          "3882:   }",
          "3885:  get_random_bytes(&sbi->s_next_generation, sizeof(u32));",
          "3886:  spin_lock_init(&sbi->s_next_gen_lock);",
          "",
          "[Removed Lines]",
          "3874:   goto failed_mount2;",
          "3881:    goto failed_mount2;",
          "3884:  sbi->s_gdb_count = db_count;",
          "",
          "[Added Lines]",
          "3877:  sbi->s_gdb_count = db_count;",
          "3878:  if (!test_opt(sb, NOLOAD) &&",
          "3879:      EXT4_HAS_COMPAT_FEATURE(sb, EXT4_FEATURE_COMPAT_HAS_JOURNAL))",
          "3880:   sb->s_op = &ext4_sops;",
          "3881:  else",
          "3882:   sb->s_op = &ext4_nojournal_sops;",
          "3884:  ext4_ext_init(sb);",
          "3885:  err = ext4_mb_init(sb);",
          "3886:  if (err) {",
          "3887:   ext4_msg(sb, KERN_ERR, \"failed to initialize mballoc (%d)\",",
          "3888:     err);",
          "3889:   goto failed_mount2;",
          "3890:  }",
          "3894:   goto failed_mount2a;",
          "3901:    goto failed_mount2a;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "3916:  sbi->s_stripe = ext4_get_stripe_size(sbi);",
          "3917:  sbi->s_extent_max_zeroout_kb = 32;",
          "3927:  sb->s_export_op = &ext4_export_ops;",
          "3928:  sb->s_xattr = ext4_xattr_handlers;",
          "3929: #ifdef CONFIG_QUOTA",
          "",
          "[Removed Lines]",
          "3922:  if (!test_opt(sb, NOLOAD) &&",
          "3923:      EXT4_HAS_COMPAT_FEATURE(sb, EXT4_FEATURE_COMPAT_HAS_JOURNAL))",
          "3924:   sb->s_op = &ext4_sops;",
          "3925:  else",
          "3926:   sb->s_op = &ext4_nojournal_sops;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "4113:  if (err) {",
          "4114:   ext4_msg(sb, KERN_ERR, \"failed to reserve %llu clusters for \"",
          "4115:     \"reserved pool\", ext4_calculate_resv_clusters(sb));",
          "4117:  }",
          "4119:  err = ext4_setup_system_zone(sb);",
          "4120:  if (err) {",
          "4121:   ext4_msg(sb, KERN_ERR, \"failed to initialize system \"",
          "4122:     \"zone (%d)\", err);",
          "4131:   goto failed_mount5;",
          "4132:  }",
          "",
          "[Removed Lines]",
          "4116:   goto failed_mount4a;",
          "4123:   goto failed_mount4a;",
          "4124:  }",
          "4126:  ext4_ext_init(sb);",
          "4127:  err = ext4_mb_init(sb);",
          "4128:  if (err) {",
          "4129:   ext4_msg(sb, KERN_ERR, \"failed to initialize mballoc (%d)\",",
          "4130:     err);",
          "",
          "[Added Lines]",
          "4127:   goto failed_mount5;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "4204: failed_mount7:",
          "4205:  ext4_unregister_li_request(sb);",
          "4206: failed_mount6:",
          "4210:  ext4_release_system_zone(sb);",
          "4212:  dput(sb->s_root);",
          "4213:  sb->s_root = NULL;",
          "4214: failed_mount4:",
          "",
          "[Removed Lines]",
          "4207:  ext4_mb_release(sb);",
          "4208: failed_mount5:",
          "4209:  ext4_ext_release(sb);",
          "4211: failed_mount4a:",
          "",
          "[Added Lines]",
          "4211: failed_mount5:",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "4232:  percpu_counter_destroy(&sbi->s_extent_cache_cnt);",
          "4233:  if (sbi->s_mmp_tsk)",
          "4234:   kthread_stop(sbi->s_mmp_tsk);",
          "4235: failed_mount2:",
          "4236:  for (i = 0; i < db_count; i++)",
          "4237:   brelse(sbi->s_group_desc[i]);",
          "4238:  ext4_kvfree(sbi->s_group_desc);",
          "4239: failed_mount:",
          "4240:  if (sbi->s_chksum_driver)",
          "4241:   crypto_free_shash(sbi->s_chksum_driver);",
          "4242:  if (sbi->s_proc) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4235: failed_mount2a:",
          "4236:  ext4_mb_release(sb);",
          "4242:  ext4_ext_release(sb);",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2014-9050",
  "cve_desc": "Heap-based buffer overflow in the cli_scanpe function in libclamav/pe.c in ClamAV before 0.98.5 allows remote attackers to cause a denial of service (crash) via a crafted y0da Crypter PE file.",
  "repo": "vrtadmin/clamav-devel",
  "patch_hash": "fc3794a54d2affe5770c1f876484a871c783e91e",
  "patch_info": {
    "commit_hash": "fc3794a54d2affe5770c1f876484a871c783e91e",
    "repo": "vrtadmin/clamav-devel",
    "commit_url": "https://github.com/vrtadmin/clamav-devel/commit/fc3794a54d2affe5770c1f876484a871c783e91e",
    "files": [
      "libclamav/pe.c"
    ],
    "message": "Merge fix from security/bb11155 branch",
    "before_after_code_files": [
      "libclamav/pe.c||libclamav/pe.c"
    ]
  },
  "patch_diff": {
    "libclamav/pe.c||libclamav/pe.c": [
      "File: libclamav/pe.c -> libclamav/pe.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "737:  char sname[9], epbuff[4096], *tempfile;",
      "738:  uint32_t epsize;",
      "739:  ssize_t bytes, at;",
      "741:  unsigned int ssize = 0, dsize = 0, dll = 0, pe_plus = 0, corrupted_cur;",
      "742:  int (*upxfn)(const char *, uint32_t, char *, uint32_t *, uint32_t, uint32_t, uint32_t) = NULL;",
      "743:  const char *src = NULL;",
      "744:  char *dest = NULL;",
      "745:  int ndesc, ret = CL_CLEAN, upack = 0, native=0;",
      "746:  size_t fsize;",
      "748:  struct cli_exe_section *exe_sections;",
      "749:  char timestr[32];",
      "750:  struct pe_image_data_dir *dirs;",
      "",
      "[Removed Lines]",
      "740:  unsigned int i, found, upx_success = 0, min = 0, max = 0, err, overlays = 0;",
      "747:  uint32_t valign, falign, hdr_size, j;",
      "",
      "[Added Lines]",
      "740:  unsigned int i, j, found, upx_success = 0, min = 0, max = 0, err, overlays = 0, rescan = 1;",
      "747:  uint32_t valign, falign, hdr_size;",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "1238:     cli_jsonint(pe_json, \"NumberOfSections\", nsections);",
      "1239: #endif",
      "1241:     for(i = 0; i < nsections; i++) {",
      "1254: #if HAVE_JSON",
      "1255:         add_section_info(ctx, &exe_sections[i]);",
      "",
      "[Removed Lines]",
      "1242:  strncpy(sname, (char *) section_hdr[i].Name, 8);",
      "1243:  sname[8] = 0;",
      "1244:  exe_sections[i].rva = PEALIGN(EC32(section_hdr[i].VirtualAddress), valign);",
      "1245:  exe_sections[i].vsz = PESALIGN(EC32(section_hdr[i].VirtualSize), valign);",
      "1246:  exe_sections[i].raw = PEALIGN(EC32(section_hdr[i].PointerToRawData), falign);",
      "1247:  exe_sections[i].rsz = PESALIGN(EC32(section_hdr[i].SizeOfRawData), falign);",
      "1248:  exe_sections[i].chr = EC32(section_hdr[i].Characteristics);",
      "1250:  exe_sections[i].uvsz = EC32(section_hdr[i].VirtualSize);",
      "1251:  exe_sections[i].uraw = EC32(section_hdr[i].PointerToRawData);",
      "1252:  exe_sections[i].ursz = EC32(section_hdr[i].SizeOfRawData);",
      "",
      "[Added Lines]",
      "1241:     while (rescan==1) {",
      "1242:         rescan=0;",
      "1243:         for (i=0; i < nsections; i++) {",
      "1244:             exe_sections[i].rva = PEALIGN(EC32(section_hdr[i].VirtualAddress), valign);",
      "1245:             exe_sections[i].vsz = PESALIGN(EC32(section_hdr[i].VirtualSize), valign);",
      "1246:             exe_sections[i].raw = PEALIGN(EC32(section_hdr[i].PointerToRawData), falign);",
      "1247:             exe_sections[i].rsz = PESALIGN(EC32(section_hdr[i].SizeOfRawData), falign);",
      "1248:             exe_sections[i].chr = EC32(section_hdr[i].Characteristics);",
      "1250:             exe_sections[i].uvsz = EC32(section_hdr[i].VirtualSize);",
      "1251:             exe_sections[i].uraw = EC32(section_hdr[i].PointerToRawData);",
      "1252:             exe_sections[i].ursz = EC32(section_hdr[i].SizeOfRawData);",
      "1255:                 if (!CLI_ISCONTAINED(0, fsize, exe_sections[i].uraw, exe_sections[i].ursz)",
      "1256:                     || exe_sections[i].raw >= fsize) {",
      "1257:                     cli_dbgmsg(\"Broken PE file - Section %d starts or exists beyond the end of file (Offset@ %lu, Total filesize %lu)\\n\", i, (unsigned long)exe_sections[i].raw, (unsigned long)fsize);",
      "1258:                     if (nsections == 1) {",
      "1259:                         free(section_hdr);",
      "1260:                         free(exe_sections);",
      "1262:                         if(DETECT_BROKEN_PE) {",
      "1263:                             cli_append_virus(ctx, \"Heuristics.Broken.Executable\");",
      "1264:                             return CL_VIRUS;",
      "1265:                         }",
      "1268:                     }",
      "1270:                     for (j=i; j < nsections-1; j++)",
      "1271:                         memcpy(&exe_sections[j], &exe_sections[j+1], sizeof(struct cli_exe_section));",
      "1273:                     for (j=i; j < nsections-1; j++)",
      "1274:                         memcpy(&section_hdr[j], &section_hdr[j+1], sizeof(struct pe_image_section_hdr));",
      "1276:                     nsections--;",
      "1277:                     rescan=1;",
      "1278:                     break;",
      "1279:                 }",
      "1280:             }",
      "1281:         }",
      "1282:     }",
      "1285:         strncpy(sname, (char *) section_hdr[i].Name, 8);",
      "1286:         sname[8] = 0;",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "1304:  }",
      "1319:      if(SCAN_ALGO && (DCONF & PE_CONF_POLIPOS) && !*sname && exe_sections[i].vsz > 40000 && exe_sections[i].vsz < 70000 && exe_sections[i].chr == 0xe0000060) polipos = i;",
      "",
      "[Removed Lines]",
      "1308:        cli_dbgmsg(\"Broken PE file - Section %d starts beyond the end of file (Offset@ %lu, Total filesize %lu)\\n\", i, (unsigned long)exe_sections[i].raw, (unsigned long)fsize);",
      "1309:        cli_dbgmsg(\"------------------------------------\\n\");",
      "1310:   free(section_hdr);",
      "1311:   free(exe_sections);",
      "1312:   if(DETECT_BROKEN_PE) {",
      "1313:       cli_append_virus(ctx, \"Heuristics.Broken.Executable\");",
      "1314:       return CL_VIRUS;",
      "1315:   }",
      "1317:      }",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "f98a68afe8406b205e12e10b97d37d86efb36c51",
      "candidate_info": {
        "commit_hash": "f98a68afe8406b205e12e10b97d37d86efb36c51",
        "repo": "vrtadmin/clamav-devel",
        "commit_url": "https://github.com/vrtadmin/clamav-devel/commit/f98a68afe8406b205e12e10b97d37d86efb36c51",
        "files": [
          "libclamav/pe.c"
        ],
        "message": "Retab cli_scanpe()",
        "before_after_code_files": [
          "libclamav/pe.c||libclamav/pe.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "libclamav/pe.c||libclamav/pe.c"
          ],
          "candidate": [
            "libclamav/pe.c||libclamav/pe.c"
          ]
        }
      },
      "candidate_diff": {
        "libclamav/pe.c||libclamav/pe.c": [
          "File: libclamav/pe.c -> libclamav/pe.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "723: int cli_scanpe(cli_ctx *ctx)",
          "724: {",
          "754: #ifdef HAVE__INTERNAL__SHA_COLLECT",
          "756: #endif",
          "757:     const char *archtype=NULL, *subsystem=NULL;",
          "759: #if HAVE_JSON",
          "763: #endif",
          "765:     if(!ctx) {",
          "768:     }",
          "770: #if HAVE_JSON",
          "",
          "[Removed Lines]",
          "726:  uint16_t nsections;",
          "729:  uint8_t polipos = 0;",
          "730:  time_t timestamp;",
          "731:  struct pe_image_file_hdr file_hdr;",
          "732:  union {",
          "733:      struct pe_image_optional_hdr64 opt64;",
          "734:      struct pe_image_optional_hdr32 opt32;",
          "735:  } pe_opt;",
          "736:  struct pe_image_section_hdr *section_hdr;",
          "737:  char sname[9], epbuff[4096], *tempfile;",
          "738:  uint32_t epsize;",
          "739:  ssize_t bytes, at;",
          "740:  unsigned int i, j, found, upx_success = 0, min = 0, max = 0, err, overlays = 0, rescan = 1;",
          "741:  unsigned int ssize = 0, dsize = 0, dll = 0, pe_plus = 0, corrupted_cur;",
          "742:  int (*upxfn)(const char *, uint32_t, char *, uint32_t *, uint32_t, uint32_t, uint32_t) = NULL;",
          "743:  const char *src = NULL;",
          "744:  char *dest = NULL;",
          "745:  int ndesc, ret = CL_CLEAN, upack = 0, native=0;",
          "746:  size_t fsize;",
          "747:  uint32_t valign, falign, hdr_size;",
          "748:  struct cli_exe_section *exe_sections;",
          "749:  char timestr[32];",
          "750:  struct pe_image_data_dir *dirs;",
          "751:  struct cli_bc_ctx *bc_ctx;",
          "752:  fmap_t *map;",
          "753:  struct cli_pe_hook_data pedata;",
          "755:  int sha_collect = ctx->sha_collect;",
          "758:  uint32_t viruses_found = 0;",
          "760:         int toval = 0;",
          "761:         struct json_object *pe_json=NULL;",
          "762:         char jsonbuf[128];",
          "766:  cli_errmsg(\"cli_scanpe: ctx == NULL\\n\");",
          "767:  return CL_ENULLARG;",
          "",
          "[Added Lines]",
          "726:     uint16_t nsections;",
          "729:     uint8_t polipos = 0;",
          "730:     time_t timestamp;",
          "731:     struct pe_image_file_hdr file_hdr;",
          "732:     union {",
          "733:         struct pe_image_optional_hdr64 opt64;",
          "734:         struct pe_image_optional_hdr32 opt32;",
          "735:     } pe_opt;",
          "736:     struct pe_image_section_hdr *section_hdr;",
          "737:     char sname[9], epbuff[4096], *tempfile;",
          "738:     uint32_t epsize;",
          "739:     ssize_t bytes, at;",
          "740:     unsigned int i, j, found, upx_success = 0, min = 0, max = 0, err, overlays = 0, rescan = 1;",
          "741:     unsigned int ssize = 0, dsize = 0, dll = 0, pe_plus = 0, corrupted_cur;",
          "742:     int (*upxfn)(const char *, uint32_t, char *, uint32_t *, uint32_t, uint32_t, uint32_t) = NULL;",
          "743:     const char *src = NULL;",
          "744:     char *dest = NULL;",
          "745:     int ndesc, ret = CL_CLEAN, upack = 0, native=0;",
          "746:     size_t fsize;",
          "747:     uint32_t valign, falign, hdr_size;",
          "748:     struct cli_exe_section *exe_sections;",
          "749:     char timestr[32];",
          "750:     struct pe_image_data_dir *dirs;",
          "751:     struct cli_bc_ctx *bc_ctx;",
          "752:     fmap_t *map;",
          "753:     struct cli_pe_hook_data pedata;",
          "755:     int sha_collect = ctx->sha_collect;",
          "758:     uint32_t viruses_found = 0;",
          "760:     int toval = 0;",
          "761:     struct json_object *pe_json=NULL;",
          "762:     char jsonbuf[128];",
          "766:         cli_errmsg(\"cli_scanpe: ctx == NULL\\n\");",
          "767:         return CL_ENULLARG;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "778: #endif",
          "779:     map = *ctx->fmap;",
          "780:     if(fmap_readn(map, &e_magic, 0, sizeof(e_magic)) != sizeof(e_magic)) {",
          "783:     }",
          "785:     if(EC16(e_magic) != PE_IMAGE_DOS_SIGNATURE && EC16(e_magic) != PE_IMAGE_DOS_SIGNATURE_OLD) {",
          "788:     }",
          "790:     if(fmap_readn(map, &e_lfanew, 58 + sizeof(e_magic), sizeof(e_lfanew)) != sizeof(e_lfanew)) {",
          "798:     }",
          "800:     e_lfanew = EC32(e_lfanew);",
          "801:     cli_dbgmsg(\"e_lfanew == %d\\n\", e_lfanew);",
          "802:     if(!e_lfanew) {",
          "805:     }",
          "807:     if(fmap_readn(map, &file_hdr, e_lfanew, sizeof(struct pe_image_file_hdr)) != sizeof(struct pe_image_file_hdr)) {",
          "811:     }",
          "813:     if(EC32(file_hdr.Magic) != PE_IMAGE_NT_SIGNATURE) {",
          "816:     }",
          "818:     if(EC16(file_hdr.Characteristics) & 0x2000) {",
          "",
          "[Removed Lines]",
          "781:  cli_dbgmsg(\"Can't read DOS signature\\n\");",
          "782:  return CL_CLEAN;",
          "786:  cli_dbgmsg(\"Invalid DOS signature\\n\");",
          "787:  return CL_CLEAN;",
          "791:  cli_dbgmsg(\"Can't read new header address\\n\");",
          "793:  if(DETECT_BROKEN_PE) {",
          "794:      cli_append_virus(ctx,\"Heuristics.Broken.Executable\");",
          "795:      return CL_VIRUS;",
          "796:  }",
          "797:  return CL_CLEAN;",
          "803:  cli_dbgmsg(\"Not a PE file\\n\");",
          "804:  return CL_CLEAN;",
          "809:  cli_dbgmsg(\"Can't read file header\\n\");",
          "810:  return CL_CLEAN;",
          "814:  cli_dbgmsg(\"Invalid PE signature (probably NE file)\\n\");",
          "815:  return CL_CLEAN;",
          "",
          "[Added Lines]",
          "781:         cli_dbgmsg(\"Can't read DOS signature\\n\");",
          "782:         return CL_CLEAN;",
          "786:         cli_dbgmsg(\"Invalid DOS signature\\n\");",
          "787:         return CL_CLEAN;",
          "791:         cli_dbgmsg(\"Can't read new header address\\n\");",
          "793:         if(DETECT_BROKEN_PE) {",
          "794:             cli_append_virus(ctx,\"Heuristics.Broken.Executable\");",
          "795:             return CL_VIRUS;",
          "796:         }",
          "798:         return CL_CLEAN;",
          "804:         cli_dbgmsg(\"Not a PE file\\n\");",
          "805:         return CL_CLEAN;",
          "810:         cli_dbgmsg(\"Can't read file header\\n\");",
          "811:         return CL_CLEAN;",
          "815:         cli_dbgmsg(\"Invalid PE signature (probably NE file)\\n\");",
          "816:         return CL_CLEAN;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "820:         if ((pe_json))",
          "821:             cli_jsonstr(pe_json, \"Type\", \"DLL\");",
          "822: #endif",
          "825:     } else if(EC16(file_hdr.Characteristics) & 0x01) {",
          "826: #if HAVE_JSON",
          "827:         if ((pe_json))",
          "828:             cli_jsonstr(pe_json, \"Type\", \"EXE\");",
          "829: #endif",
          "831:     }",
          "833:     switch(EC16(file_hdr.Machine)) {",
          "835:         archtype = \"Unknown\";",
          "838:         archtype = \"80386\";",
          "841:         archtype = \"80486\";",
          "844:         archtype = \"80586\";",
          "847:         archtype = \"R30000 (big-endian)\";",
          "850:         archtype = \"R3000\";",
          "853:         archtype = \"R4000\";",
          "856:         archtype = \"R10000\";",
          "859:         archtype = \"DEC Alpha AXP\";",
          "862:         archtype = \"DEC Alpha AXP 64bit\";",
          "865:         archtype = \"PowerPC\";",
          "868:         archtype = \"IA64\";",
          "871:         archtype = \"M68k\";",
          "874:         archtype = \"MIPS16\";",
          "877:         archtype = \"MIPS+FPU\";",
          "880:         archtype = \"MIPS16+FPU\";",
          "883:         archtype = \"Hitachi SH3\";",
          "886:         archtype = \"Hitachi SH3-DSP\";",
          "889:         archtype = \"Hitachi SH3-E\";",
          "892:         archtype = \"Hitachi SH4\";",
          "895:         archtype = \"Hitachi SH5\";",
          "898:         archtype = \"ARM\";",
          "901:         archtype = \"THUMB\";",
          "904:         archtype = \"AM33\";",
          "907:         archtype = \"Infineon TriCore\";",
          "910:         archtype = \"CEF\";",
          "913:         archtype = \"EFI Byte Code\";",
          "916:         archtype = \"M32R\";",
          "919:         archtype = \"CEEE\";",
          "922:         archtype = \"AMD64\";",
          "925:         archtype = \"Unknown\";",
          "926:     }",
          "",
          "[Removed Lines]",
          "823:  cli_dbgmsg(\"File type: DLL\\n\");",
          "824:  dll = 1;",
          "830:  cli_dbgmsg(\"File type: Executable\\n\");",
          "834:  case 0x0:",
          "836:      break;",
          "837:  case 0x14c:",
          "839:      break;",
          "840:  case 0x14d:",
          "842:      break;",
          "843:  case 0x14e:",
          "845:      break;",
          "846:  case 0x160:",
          "848:      break;",
          "849:  case 0x162:",
          "851:      break;",
          "852:  case 0x166:",
          "854:      break;",
          "855:  case 0x168:",
          "857:      break;",
          "858:  case 0x184:",
          "860:      break;",
          "861:  case 0x284:",
          "863:      break;",
          "864:  case 0x1f0:",
          "866:      break;",
          "867:  case 0x200:",
          "869:      break;",
          "870:  case 0x268:",
          "872:      break;",
          "873:  case 0x266:",
          "875:      break;",
          "876:  case 0x366:",
          "878:      break;",
          "879:  case 0x466:",
          "881:      break;",
          "882:  case 0x1a2:",
          "884:      break;",
          "885:  case 0x1a3:",
          "887:      break;",
          "888:  case 0x1a4:",
          "890:      break;",
          "891:  case 0x1a6:",
          "893:      break;",
          "894:  case 0x1a8:",
          "896:      break;",
          "897:  case 0x1c0:",
          "899:      break;",
          "900:  case 0x1c2:",
          "902:      break;",
          "903:  case 0x1d3:",
          "905:      break;",
          "906:  case 0x520:",
          "908:      break;",
          "909:  case 0xcef:",
          "911:      break;",
          "912:  case 0xebc:",
          "914:      break;",
          "915:  case 0x9041:",
          "917:      break;",
          "918:  case 0xc0ee:",
          "920:      break;",
          "921:  case 0x8664:",
          "923:      break;",
          "924:  default:",
          "",
          "[Added Lines]",
          "824:         cli_dbgmsg(\"File type: DLL\\n\");",
          "825:         dll = 1;",
          "831:         cli_dbgmsg(\"File type: Executable\\n\");",
          "835:     case 0x0:",
          "837:         break;",
          "838:     case 0x14c:",
          "840:         break;",
          "841:     case 0x14d:",
          "843:         break;",
          "844:     case 0x14e:",
          "846:         break;",
          "847:     case 0x160:",
          "849:         break;",
          "850:     case 0x162:",
          "852:         break;",
          "853:     case 0x166:",
          "855:         break;",
          "856:     case 0x168:",
          "858:         break;",
          "859:     case 0x184:",
          "861:         break;",
          "862:     case 0x284:",
          "864:         break;",
          "865:     case 0x1f0:",
          "867:         break;",
          "868:     case 0x200:",
          "870:         break;",
          "871:     case 0x268:",
          "873:         break;",
          "874:     case 0x266:",
          "876:         break;",
          "877:     case 0x366:",
          "879:         break;",
          "880:     case 0x466:",
          "882:         break;",
          "883:     case 0x1a2:",
          "885:         break;",
          "886:     case 0x1a3:",
          "888:         break;",
          "889:     case 0x1a4:",
          "891:         break;",
          "892:     case 0x1a6:",
          "894:         break;",
          "895:     case 0x1a8:",
          "897:         break;",
          "898:     case 0x1c0:",
          "900:         break;",
          "901:     case 0x1c2:",
          "903:         break;",
          "904:     case 0x1d3:",
          "906:         break;",
          "907:     case 0x520:",
          "909:         break;",
          "910:     case 0xcef:",
          "912:         break;",
          "913:     case 0xebc:",
          "915:         break;",
          "916:     case 0x9041:",
          "918:         break;",
          "919:     case 0xc0ee:",
          "921:         break;",
          "922:     case 0x8664:",
          "924:         break;",
          "925:     default:",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "937: #if HAVE_JSON",
          "938:         pe_add_heuristic_property(ctx, \"BadNumberOfSections\");",
          "939: #endif",
          "951:     }",
          "952:     cli_dbgmsg(\"NumberOfSections: %d\\n\", nsections);",
          "954:     timestamp = (time_t) EC32(file_hdr.TimeDateStamp);",
          "",
          "[Removed Lines]",
          "940:  if(DETECT_BROKEN_PE) {",
          "941:      cli_append_virus(ctx,\"Heuristics.Broken.Executable\");",
          "942:      return CL_VIRUS;",
          "943:  }",
          "944:  if(!ctx->corrupted_input) {",
          "945:      if(nsections)",
          "946:   cli_warnmsg(\"PE file contains %d sections\\n\", nsections);",
          "947:      else",
          "948:   cli_warnmsg(\"PE file contains no sections\\n\");",
          "949:  }",
          "950:  return CL_CLEAN;",
          "",
          "[Added Lines]",
          "941:         if(DETECT_BROKEN_PE) {",
          "942:             cli_append_virus(ctx,\"Heuristics.Broken.Executable\");",
          "943:             return CL_VIRUS;",
          "944:         }",
          "946:         if(!ctx->corrupted_input) {",
          "947:             if(nsections)",
          "948:             cli_warnmsg(\"PE file contains %d sections\\n\", nsections);",
          "949:             else",
          "950:             cli_warnmsg(\"PE file contains no sections\\n\");",
          "951:         }",
          "953:         return CL_CLEAN;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "969:         pe_add_heuristic_property(ctx, \"BadOptionalHeaderSize\");",
          "970: #endif",
          "971:         cli_dbgmsg(\"SizeOfOptionalHeader too small\\n\");",
          "977:     }",
          "979:     at = e_lfanew + sizeof(struct pe_image_file_hdr);",
          "980:     if(fmap_readn(map, &optional_hdr32, at, sizeof(struct pe_image_optional_hdr32)) != sizeof(struct pe_image_optional_hdr32)) {",
          "981:         cli_dbgmsg(\"Can't read optional file header\\n\");",
          "987:     }",
          "988:     at += sizeof(struct pe_image_optional_hdr32);",
          "",
          "[Removed Lines]",
          "972:  if(DETECT_BROKEN_PE) {",
          "973:      cli_append_virus(ctx,\"Heuristics.Broken.Executable\");",
          "974:      return CL_VIRUS;",
          "975:  }",
          "976:  return CL_CLEAN;",
          "982:  if(DETECT_BROKEN_PE) {",
          "983:      cli_append_virus(ctx,\"Heuristics.Broken.Executable\");",
          "984:      return CL_VIRUS;",
          "985:  }",
          "986:  return CL_CLEAN;",
          "",
          "[Added Lines]",
          "976:         if(DETECT_BROKEN_PE) {",
          "977:             cli_append_virus(ctx,\"Heuristics.Broken.Executable\");",
          "978:             return CL_VIRUS;",
          "979:         }",
          "981:         return CL_CLEAN;",
          "987:         if(DETECT_BROKEN_PE) {",
          "988:             cli_append_virus(ctx,\"Heuristics.Broken.Executable\");",
          "989:             return CL_VIRUS;",
          "990:         }",
          "992:         return CL_CLEAN;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "993:         pe_add_heuristic_property(ctx, \"BadOptionalHeaderSizePE32Plus\");",
          "994: #endif",
          "995:         if(EC16(file_hdr.SizeOfOptionalHeader)!=sizeof(struct pe_image_optional_hdr64)) {",
          "1005:     }",
          "1035: #if HAVE_JSON",
          "1059: #endif",
          "1091: #if HAVE_JSON",
          "1115: #endif",
          "1116:     }",
          "",
          "[Removed Lines]",
          "997:      cli_dbgmsg(\"Incorrect SizeOfOptionalHeader for PE32+\\n\");",
          "998:      if(DETECT_BROKEN_PE) {",
          "999:   cli_append_virus(ctx,\"Heuristics.Broken.Executable\");",
          "1000:   return CL_VIRUS;",
          "1001:      }",
          "1002:      return CL_CLEAN;",
          "1003:  }",
          "1004:  pe_plus = 1;",
          "1008:  if (EC16(file_hdr.SizeOfOptionalHeader)!=sizeof(struct pe_image_optional_hdr32)) {",
          "1010:      at += EC16(file_hdr.SizeOfOptionalHeader)-sizeof(struct pe_image_optional_hdr32);",
          "1011:  }",
          "1013:  if(DCONF & PE_CONF_UPACK)",
          "1014:      upack = (EC16(file_hdr.SizeOfOptionalHeader)==0x148);",
          "1016:  vep = EC32(optional_hdr32.AddressOfEntryPoint);",
          "1017:  hdr_size = EC32(optional_hdr32.SizeOfHeaders);",
          "1018:  cli_dbgmsg(\"File format: PE\\n\");",
          "1020:  cli_dbgmsg(\"MajorLinkerVersion: %d\\n\", optional_hdr32.MajorLinkerVersion);",
          "1021:  cli_dbgmsg(\"MinorLinkerVersion: %d\\n\", optional_hdr32.MinorLinkerVersion);",
          "1022:  cli_dbgmsg(\"SizeOfCode: 0x%x\\n\", EC32(optional_hdr32.SizeOfCode));",
          "1023:  cli_dbgmsg(\"SizeOfInitializedData: 0x%x\\n\", EC32(optional_hdr32.SizeOfInitializedData));",
          "1024:  cli_dbgmsg(\"SizeOfUninitializedData: 0x%x\\n\", EC32(optional_hdr32.SizeOfUninitializedData));",
          "1025:  cli_dbgmsg(\"AddressOfEntryPoint: 0x%x\\n\", vep);",
          "1026:  cli_dbgmsg(\"BaseOfCode: 0x%x\\n\", EC32(optional_hdr32.BaseOfCode));",
          "1027:  cli_dbgmsg(\"SectionAlignment: 0x%x\\n\", EC32(optional_hdr32.SectionAlignment));",
          "1028:  cli_dbgmsg(\"FileAlignment: 0x%x\\n\", EC32(optional_hdr32.FileAlignment));",
          "1029:  cli_dbgmsg(\"MajorSubsystemVersion: %d\\n\", EC16(optional_hdr32.MajorSubsystemVersion));",
          "1030:  cli_dbgmsg(\"MinorSubsystemVersion: %d\\n\", EC16(optional_hdr32.MinorSubsystemVersion));",
          "1031:  cli_dbgmsg(\"SizeOfImage: 0x%x\\n\", EC32(optional_hdr32.SizeOfImage));",
          "1032:  cli_dbgmsg(\"SizeOfHeaders: 0x%x\\n\", hdr_size);",
          "1033:  cli_dbgmsg(\"NumberOfRvaAndSizes: %d\\n\", EC32(optional_hdr32.NumberOfRvaAndSizes));",
          "1034:  dirs = optional_hdr32.DataDirectory;",
          "1036:     cli_jsonint(pe_json, \"MajorLinkerVersion\", optional_hdr32.MajorLinkerVersion);",
          "1037:     cli_jsonint(pe_json, \"MinorLinkerVersion\", optional_hdr32.MinorLinkerVersion);",
          "1038:     cli_jsonint(pe_json, \"SizeOfCode\", EC32(optional_hdr32.SizeOfCode));",
          "1039:     cli_jsonint(pe_json, \"SizeOfInitializedData\", EC32(optional_hdr32.SizeOfInitializedData));",
          "1040:     cli_jsonint(pe_json, \"SizeOfUninitializedData\", EC32(optional_hdr32.SizeOfUninitializedData));",
          "1041:     cli_jsonint(pe_json, \"NumberOfRvaAndSizes\", EC32(optional_hdr32.NumberOfRvaAndSizes));",
          "1042:     cli_jsonint(pe_json, \"MajorSubsystemVersion\", EC16(optional_hdr32.MajorSubsystemVersion));",
          "1043:     cli_jsonint(pe_json, \"MinorSubsystemVersion\", EC16(optional_hdr32.MinorSubsystemVersion));",
          "1045:     snprintf(jsonbuf, sizeof(jsonbuf), \"0x%x\", EC32(optional_hdr32.BaseOfCode));",
          "1046:     cli_jsonstr(pe_json, \"BaseOfCode\", jsonbuf);",
          "1048:     snprintf(jsonbuf, sizeof(jsonbuf), \"0x%x\", EC32(optional_hdr32.SectionAlignment));",
          "1049:     cli_jsonstr(pe_json, \"SectionAlignment\", jsonbuf);",
          "1051:     snprintf(jsonbuf, sizeof(jsonbuf), \"0x%x\", EC32(optional_hdr32.FileAlignment));",
          "1052:     cli_jsonstr(pe_json, \"FileAlignment\", jsonbuf);",
          "1054:     snprintf(jsonbuf, sizeof(jsonbuf), \"0x%x\", EC32(optional_hdr32.SizeOfImage));",
          "1055:     cli_jsonstr(pe_json, \"SizeOfImage\", jsonbuf);",
          "1057:     snprintf(jsonbuf, sizeof(jsonbuf), \"0x%x\", hdr_size);",
          "1058:     cli_jsonstr(pe_json, \"SizeOfHeaders\", jsonbuf);",
          "1063:         if(fmap_readn(map, &optional_hdr32 + 1, at, sizeof(struct pe_image_optional_hdr64) - sizeof(struct pe_image_optional_hdr32)) != sizeof(struct pe_image_optional_hdr64) - sizeof(struct pe_image_optional_hdr32)) {",
          "1064:      cli_dbgmsg(\"Can't read optional file header\\n\");",
          "1065:      if(DETECT_BROKEN_PE) {",
          "1066:   cli_append_virus(ctx,\"Heuristics.Broken.Executable\");",
          "1067:   return CL_VIRUS;",
          "1068:      }",
          "1069:      return CL_CLEAN;",
          "1070:  }",
          "1071:  at += sizeof(struct pe_image_optional_hdr64) - sizeof(struct pe_image_optional_hdr32);",
          "1072:  vep = EC32(optional_hdr64.AddressOfEntryPoint);",
          "1073:  hdr_size = EC32(optional_hdr64.SizeOfHeaders);",
          "1074:  cli_dbgmsg(\"File format: PE32+\\n\");",
          "1076:  cli_dbgmsg(\"MajorLinkerVersion: %d\\n\", optional_hdr64.MajorLinkerVersion);",
          "1077:  cli_dbgmsg(\"MinorLinkerVersion: %d\\n\", optional_hdr64.MinorLinkerVersion);",
          "1078:  cli_dbgmsg(\"SizeOfCode: 0x%x\\n\", EC32(optional_hdr64.SizeOfCode));",
          "1079:  cli_dbgmsg(\"SizeOfInitializedData: 0x%x\\n\", EC32(optional_hdr64.SizeOfInitializedData));",
          "1080:  cli_dbgmsg(\"SizeOfUninitializedData: 0x%x\\n\", EC32(optional_hdr64.SizeOfUninitializedData));",
          "1081:  cli_dbgmsg(\"AddressOfEntryPoint: 0x%x\\n\", vep);",
          "1082:  cli_dbgmsg(\"BaseOfCode: 0x%x\\n\", EC32(optional_hdr64.BaseOfCode));",
          "1083:  cli_dbgmsg(\"SectionAlignment: 0x%x\\n\", EC32(optional_hdr64.SectionAlignment));",
          "1084:  cli_dbgmsg(\"FileAlignment: 0x%x\\n\", EC32(optional_hdr64.FileAlignment));",
          "1085:  cli_dbgmsg(\"MajorSubsystemVersion: %d\\n\", EC16(optional_hdr64.MajorSubsystemVersion));",
          "1086:  cli_dbgmsg(\"MinorSubsystemVersion: %d\\n\", EC16(optional_hdr64.MinorSubsystemVersion));",
          "1087:  cli_dbgmsg(\"SizeOfImage: 0x%x\\n\", EC32(optional_hdr64.SizeOfImage));",
          "1088:  cli_dbgmsg(\"SizeOfHeaders: 0x%x\\n\", hdr_size);",
          "1089:  cli_dbgmsg(\"NumberOfRvaAndSizes: %d\\n\", EC32(optional_hdr64.NumberOfRvaAndSizes));",
          "1090:  dirs = optional_hdr64.DataDirectory;",
          "1092:     cli_jsonint(pe_json, \"MajorLinkerVersion\", optional_hdr64.MajorLinkerVersion);",
          "1093:     cli_jsonint(pe_json, \"MinorLinkerVersion\", optional_hdr64.MinorLinkerVersion);",
          "1094:     cli_jsonint(pe_json, \"SizeOfCode\", EC32(optional_hdr64.SizeOfCode));",
          "1095:     cli_jsonint(pe_json, \"SizeOfInitializedData\", EC32(optional_hdr64.SizeOfInitializedData));",
          "1096:     cli_jsonint(pe_json, \"SizeOfUninitializedData\", EC32(optional_hdr64.SizeOfUninitializedData));",
          "1097:     cli_jsonint(pe_json, \"NumberOfRvaAndSizes\", EC32(optional_hdr64.NumberOfRvaAndSizes));",
          "1098:     cli_jsonint(pe_json, \"MajorSubsystemVersion\", EC16(optional_hdr64.MajorSubsystemVersion));",
          "1099:     cli_jsonint(pe_json, \"MinorSubsystemVersion\", EC16(optional_hdr64.MinorSubsystemVersion));",
          "1101:     snprintf(jsonbuf, sizeof(jsonbuf), \"0x%x\", EC32(optional_hdr64.BaseOfCode));",
          "1102:     cli_jsonstr(pe_json, \"BaseOfCode\", jsonbuf);",
          "1104:     snprintf(jsonbuf, sizeof(jsonbuf), \"0x%x\", EC32(optional_hdr64.SectionAlignment));",
          "1105:     cli_jsonstr(pe_json, \"SectionAlignment\", jsonbuf);",
          "1107:     snprintf(jsonbuf, sizeof(jsonbuf), \"0x%x\", EC32(optional_hdr64.FileAlignment));",
          "1108:     cli_jsonstr(pe_json, \"FileAlignment\", jsonbuf);",
          "1110:     snprintf(jsonbuf, sizeof(jsonbuf), \"0x%x\", EC32(optional_hdr64.SizeOfImage));",
          "1111:     cli_jsonstr(pe_json, \"SizeOfImage\", jsonbuf);",
          "1113:     snprintf(jsonbuf, sizeof(jsonbuf), \"0x%x\", hdr_size);",
          "1114:     cli_jsonstr(pe_json, \"SizeOfHeaders\", jsonbuf);",
          "",
          "[Added Lines]",
          "1003:             cli_dbgmsg(\"Incorrect SizeOfOptionalHeader for PE32+\\n\");",
          "1005:             if(DETECT_BROKEN_PE) {",
          "1006:                 cli_append_virus(ctx,\"Heuristics.Broken.Executable\");",
          "1007:                 return CL_VIRUS;",
          "1008:             }",
          "1010:             return CL_CLEAN;",
          "1011:         }",
          "1012:         pe_plus = 1;",
          "1016:         if (EC16(file_hdr.SizeOfOptionalHeader)!=sizeof(struct pe_image_optional_hdr32)) {",
          "1018:             at += EC16(file_hdr.SizeOfOptionalHeader)-sizeof(struct pe_image_optional_hdr32);",
          "1019:         }",
          "1021:         if(DCONF & PE_CONF_UPACK)",
          "1022:             upack = (EC16(file_hdr.SizeOfOptionalHeader)==0x148);",
          "1024:         vep = EC32(optional_hdr32.AddressOfEntryPoint);",
          "1025:         hdr_size = EC32(optional_hdr32.SizeOfHeaders);",
          "1026:         cli_dbgmsg(\"File format: PE\\n\");",
          "1028:         cli_dbgmsg(\"MajorLinkerVersion: %d\\n\", optional_hdr32.MajorLinkerVersion);",
          "1029:         cli_dbgmsg(\"MinorLinkerVersion: %d\\n\", optional_hdr32.MinorLinkerVersion);",
          "1030:         cli_dbgmsg(\"SizeOfCode: 0x%x\\n\", EC32(optional_hdr32.SizeOfCode));",
          "1031:         cli_dbgmsg(\"SizeOfInitializedData: 0x%x\\n\", EC32(optional_hdr32.SizeOfInitializedData));",
          "1032:         cli_dbgmsg(\"SizeOfUninitializedData: 0x%x\\n\", EC32(optional_hdr32.SizeOfUninitializedData));",
          "1033:         cli_dbgmsg(\"AddressOfEntryPoint: 0x%x\\n\", vep);",
          "1034:         cli_dbgmsg(\"BaseOfCode: 0x%x\\n\", EC32(optional_hdr32.BaseOfCode));",
          "1035:         cli_dbgmsg(\"SectionAlignment: 0x%x\\n\", EC32(optional_hdr32.SectionAlignment));",
          "1036:         cli_dbgmsg(\"FileAlignment: 0x%x\\n\", EC32(optional_hdr32.FileAlignment));",
          "1037:         cli_dbgmsg(\"MajorSubsystemVersion: %d\\n\", EC16(optional_hdr32.MajorSubsystemVersion));",
          "1038:         cli_dbgmsg(\"MinorSubsystemVersion: %d\\n\", EC16(optional_hdr32.MinorSubsystemVersion));",
          "1039:         cli_dbgmsg(\"SizeOfImage: 0x%x\\n\", EC32(optional_hdr32.SizeOfImage));",
          "1040:         cli_dbgmsg(\"SizeOfHeaders: 0x%x\\n\", hdr_size);",
          "1041:         cli_dbgmsg(\"NumberOfRvaAndSizes: %d\\n\", EC32(optional_hdr32.NumberOfRvaAndSizes));",
          "1042:         dirs = optional_hdr32.DataDirectory;",
          "1044:         cli_jsonint(pe_json, \"MajorLinkerVersion\", optional_hdr32.MajorLinkerVersion);",
          "1045:         cli_jsonint(pe_json, \"MinorLinkerVersion\", optional_hdr32.MinorLinkerVersion);",
          "1046:         cli_jsonint(pe_json, \"SizeOfCode\", EC32(optional_hdr32.SizeOfCode));",
          "1047:         cli_jsonint(pe_json, \"SizeOfInitializedData\", EC32(optional_hdr32.SizeOfInitializedData));",
          "1048:         cli_jsonint(pe_json, \"SizeOfUninitializedData\", EC32(optional_hdr32.SizeOfUninitializedData));",
          "1049:         cli_jsonint(pe_json, \"NumberOfRvaAndSizes\", EC32(optional_hdr32.NumberOfRvaAndSizes));",
          "1050:         cli_jsonint(pe_json, \"MajorSubsystemVersion\", EC16(optional_hdr32.MajorSubsystemVersion));",
          "1051:         cli_jsonint(pe_json, \"MinorSubsystemVersion\", EC16(optional_hdr32.MinorSubsystemVersion));",
          "1053:         snprintf(jsonbuf, sizeof(jsonbuf), \"0x%x\", EC32(optional_hdr32.BaseOfCode));",
          "1054:         cli_jsonstr(pe_json, \"BaseOfCode\", jsonbuf);",
          "1056:         snprintf(jsonbuf, sizeof(jsonbuf), \"0x%x\", EC32(optional_hdr32.SectionAlignment));",
          "1057:         cli_jsonstr(pe_json, \"SectionAlignment\", jsonbuf);",
          "1059:         snprintf(jsonbuf, sizeof(jsonbuf), \"0x%x\", EC32(optional_hdr32.FileAlignment));",
          "1060:         cli_jsonstr(pe_json, \"FileAlignment\", jsonbuf);",
          "1062:         snprintf(jsonbuf, sizeof(jsonbuf), \"0x%x\", EC32(optional_hdr32.SizeOfImage));",
          "1063:         cli_jsonstr(pe_json, \"SizeOfImage\", jsonbuf);",
          "1065:         snprintf(jsonbuf, sizeof(jsonbuf), \"0x%x\", hdr_size);",
          "1066:         cli_jsonstr(pe_json, \"SizeOfHeaders\", jsonbuf);",
          "1071:             if(fmap_readn(map, &optional_hdr32 + 1, at, sizeof(struct pe_image_optional_hdr64) - sizeof(struct pe_image_optional_hdr32)) != sizeof(struct pe_image_optional_hdr64) - sizeof(struct pe_image_optional_hdr32)) {",
          "1072:             cli_dbgmsg(\"Can't read optional file header\\n\");",
          "1073:             if(DETECT_BROKEN_PE) {",
          "1074:                 cli_append_virus(ctx,\"Heuristics.Broken.Executable\");",
          "1075:                 return CL_VIRUS;",
          "1076:             }",
          "1078:             return CL_CLEAN;",
          "1079:         }",
          "1081:         at += sizeof(struct pe_image_optional_hdr64) - sizeof(struct pe_image_optional_hdr32);",
          "1082:         vep = EC32(optional_hdr64.AddressOfEntryPoint);",
          "1083:         hdr_size = EC32(optional_hdr64.SizeOfHeaders);",
          "1084:         cli_dbgmsg(\"File format: PE32+\\n\");",
          "1086:         cli_dbgmsg(\"MajorLinkerVersion: %d\\n\", optional_hdr64.MajorLinkerVersion);",
          "1087:         cli_dbgmsg(\"MinorLinkerVersion: %d\\n\", optional_hdr64.MinorLinkerVersion);",
          "1088:         cli_dbgmsg(\"SizeOfCode: 0x%x\\n\", EC32(optional_hdr64.SizeOfCode));",
          "1089:         cli_dbgmsg(\"SizeOfInitializedData: 0x%x\\n\", EC32(optional_hdr64.SizeOfInitializedData));",
          "1090:         cli_dbgmsg(\"SizeOfUninitializedData: 0x%x\\n\", EC32(optional_hdr64.SizeOfUninitializedData));",
          "1091:         cli_dbgmsg(\"AddressOfEntryPoint: 0x%x\\n\", vep);",
          "1092:         cli_dbgmsg(\"BaseOfCode: 0x%x\\n\", EC32(optional_hdr64.BaseOfCode));",
          "1093:         cli_dbgmsg(\"SectionAlignment: 0x%x\\n\", EC32(optional_hdr64.SectionAlignment));",
          "1094:         cli_dbgmsg(\"FileAlignment: 0x%x\\n\", EC32(optional_hdr64.FileAlignment));",
          "1095:         cli_dbgmsg(\"MajorSubsystemVersion: %d\\n\", EC16(optional_hdr64.MajorSubsystemVersion));",
          "1096:         cli_dbgmsg(\"MinorSubsystemVersion: %d\\n\", EC16(optional_hdr64.MinorSubsystemVersion));",
          "1097:         cli_dbgmsg(\"SizeOfImage: 0x%x\\n\", EC32(optional_hdr64.SizeOfImage));",
          "1098:         cli_dbgmsg(\"SizeOfHeaders: 0x%x\\n\", hdr_size);",
          "1099:         cli_dbgmsg(\"NumberOfRvaAndSizes: %d\\n\", EC32(optional_hdr64.NumberOfRvaAndSizes));",
          "1100:         dirs = optional_hdr64.DataDirectory;",
          "1102:         cli_jsonint(pe_json, \"MajorLinkerVersion\", optional_hdr64.MajorLinkerVersion);",
          "1103:         cli_jsonint(pe_json, \"MinorLinkerVersion\", optional_hdr64.MinorLinkerVersion);",
          "1104:         cli_jsonint(pe_json, \"SizeOfCode\", EC32(optional_hdr64.SizeOfCode));",
          "1105:         cli_jsonint(pe_json, \"SizeOfInitializedData\", EC32(optional_hdr64.SizeOfInitializedData));",
          "1106:         cli_jsonint(pe_json, \"SizeOfUninitializedData\", EC32(optional_hdr64.SizeOfUninitializedData));",
          "1107:         cli_jsonint(pe_json, \"NumberOfRvaAndSizes\", EC32(optional_hdr64.NumberOfRvaAndSizes));",
          "1108:         cli_jsonint(pe_json, \"MajorSubsystemVersion\", EC16(optional_hdr64.MajorSubsystemVersion));",
          "1109:         cli_jsonint(pe_json, \"MinorSubsystemVersion\", EC16(optional_hdr64.MinorSubsystemVersion));",
          "1111:         snprintf(jsonbuf, sizeof(jsonbuf), \"0x%x\", EC32(optional_hdr64.BaseOfCode));",
          "1112:         cli_jsonstr(pe_json, \"BaseOfCode\", jsonbuf);",
          "1114:         snprintf(jsonbuf, sizeof(jsonbuf), \"0x%x\", EC32(optional_hdr64.SectionAlignment));",
          "1115:         cli_jsonstr(pe_json, \"SectionAlignment\", jsonbuf);",
          "1117:         snprintf(jsonbuf, sizeof(jsonbuf), \"0x%x\", EC32(optional_hdr64.FileAlignment));",
          "1118:         cli_jsonstr(pe_json, \"FileAlignment\", jsonbuf);",
          "1120:         snprintf(jsonbuf, sizeof(jsonbuf), \"0x%x\", EC32(optional_hdr64.SizeOfImage));",
          "1121:         cli_jsonstr(pe_json, \"SizeOfImage\", jsonbuf);",
          "1123:         snprintf(jsonbuf, sizeof(jsonbuf), \"0x%x\", hdr_size);",
          "1124:         cli_jsonstr(pe_json, \"SizeOfHeaders\", jsonbuf);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "1126:     switch(pe_plus ? EC16(optional_hdr64.Subsystem) : EC16(optional_hdr32.Subsystem)) {",
          "1128:         subsystem = \"Unknown\";",
          "1131:         subsystem = \"Native (svc)\";",
          "1135:         subsystem = \"Win32 GUI\";",
          "1138:         subsystem = \"Win32 console\";",
          "1141:         subsystem = \"OS/2 console\";",
          "1144:         subsystem = \"POSIX console\";",
          "1147:         subsystem = \"Native Win9x driver\";",
          "1150:         subsystem = \"WinCE GUI\";",
          "1153:         subsystem = \"EFI application\";",
          "1156:         subsystem = \"EFI driver\";",
          "1159:         subsystem = \"EFI runtime driver\";",
          "1162:         subsystem = \"EFI ROM image\";",
          "1165:         subsystem = \"Xbox\";",
          "1168:         subsystem = \"Boot application\";",
          "1171:         subsystem = \"Unknown\";",
          "1172:     }",
          "",
          "[Removed Lines]",
          "1127:  case 0:",
          "1129:      break;",
          "1130:  case 1:",
          "1132:      native = 1;",
          "1133:      break;",
          "1134:  case 2:",
          "1136:      break;",
          "1137:  case 3:",
          "1139:      break;",
          "1140:  case 5:",
          "1142:      break;",
          "1143:  case 7:",
          "1145:      break;",
          "1146:  case 8:",
          "1148:      break;",
          "1149:  case 9:",
          "1151:      break;",
          "1152:  case 10:",
          "1154:      break;",
          "1155:  case 11:",
          "1157:      break;",
          "1158:  case 12:",
          "1160:      break;",
          "1161:  case 13:",
          "1163:      break;",
          "1164:  case 14:",
          "1166:      break;",
          "1167:  case 16:",
          "1169:      break;",
          "1170:  default:",
          "",
          "[Added Lines]",
          "1137:     case 0:",
          "1139:         break;",
          "1140:     case 1:",
          "1142:         native = 1;",
          "1143:         break;",
          "1144:     case 2:",
          "1146:         break;",
          "1147:     case 3:",
          "1149:         break;",
          "1150:     case 5:",
          "1152:         break;",
          "1153:     case 7:",
          "1155:         break;",
          "1156:     case 8:",
          "1158:         break;",
          "1159:     case 9:",
          "1161:         break;",
          "1162:     case 10:",
          "1164:         break;",
          "1165:     case 11:",
          "1167:         break;",
          "1168:     case 12:",
          "1170:         break;",
          "1171:     case 13:",
          "1173:         break;",
          "1174:     case 14:",
          "1176:         break;",
          "1177:     case 16:",
          "1179:         break;",
          "1180:     default:",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "1182:     if (DETECT_BROKEN_PE && !native && (!(pe_plus?EC32(optional_hdr64.SectionAlignment):EC32(optional_hdr32.SectionAlignment)) || (pe_plus?EC32(optional_hdr64.SectionAlignment):EC32(optional_hdr32.SectionAlignment))%0x1000)) {",
          "1183:         cli_dbgmsg(\"Bad virtual alignemnt\\n\");",
          "1186:     }",
          "1188:     if (DETECT_BROKEN_PE && !native && (!(pe_plus?EC32(optional_hdr64.FileAlignment):EC32(optional_hdr32.FileAlignment)) || (pe_plus?EC32(optional_hdr64.FileAlignment):EC32(optional_hdr32.FileAlignment))%0x200)) {",
          "1189:         cli_dbgmsg(\"Bad file alignemnt\\n\");",
          "1192:     }",
          "1194:     fsize = map->len;",
          "",
          "[Removed Lines]",
          "1184:  cli_append_virus(ctx,\"Heuristics.Broken.Executable\");",
          "1185:  return CL_VIRUS;",
          "1190:  cli_append_virus(ctx, \"Heuristics.Broken.Executable\");",
          "1191:  return CL_VIRUS;",
          "",
          "[Added Lines]",
          "1194:         cli_append_virus(ctx,\"Heuristics.Broken.Executable\");",
          "1195:         return CL_VIRUS;",
          "1200:         cli_append_virus(ctx, \"Heuristics.Broken.Executable\");",
          "1201:         return CL_VIRUS;",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "1196:     section_hdr = (struct pe_image_section_hdr *) cli_calloc(nsections, sizeof(struct pe_image_section_hdr));",
          "1198:     if(!section_hdr) {",
          "1201:     }",
          "1203:     exe_sections = (struct cli_exe_section *) cli_calloc(nsections, sizeof(struct cli_exe_section));",
          "1205:     if(!exe_sections) {",
          "1209:     }",
          "1211:     valign = (pe_plus)?EC32(optional_hdr64.SectionAlignment):EC32(optional_hdr32.SectionAlignment);",
          "",
          "[Removed Lines]",
          "1199:  cli_dbgmsg(\"Can't allocate memory for section headers\\n\");",
          "1200:  return CL_EMEM;",
          "1206:  cli_dbgmsg(\"Can't allocate memory for section headers\\n\");",
          "1207:  free(section_hdr);",
          "1208:  return CL_EMEM;",
          "",
          "[Added Lines]",
          "1209:         cli_dbgmsg(\"Can't allocate memory for section headers\\n\");",
          "1210:         return CL_EMEM;",
          "1216:         cli_dbgmsg(\"Can't allocate memory for section headers\\n\");",
          "1217:         free(section_hdr);",
          "1218:         return CL_EMEM;",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "1214:     if(fmap_readn(map, section_hdr, at, sizeof(struct pe_image_section_hdr)*nsections) != (int)(nsections*sizeof(struct pe_image_section_hdr))) {",
          "1215:         cli_dbgmsg(\"Can't read section header\\n\");",
          "1224:     }",
          "1225:     at += sizeof(struct pe_image_section_hdr)*nsections;",
          "1227:     for(i = 0; falign!=0x200 && i<nsections; i++) {",
          "1233:     }",
          "",
          "[Removed Lines]",
          "1216:  cli_dbgmsg(\"Possibly broken PE file\\n\");",
          "1217:  free(section_hdr);",
          "1218:  free(exe_sections);",
          "1219:  if(DETECT_BROKEN_PE) {",
          "1220:      cli_append_virus(ctx,\"Heuristics.Broken.Executable\");",
          "1221:      return CL_VIRUS;",
          "1222:  }",
          "1223:  return CL_CLEAN;",
          "1229:  if (falign && section_hdr[i].SizeOfRawData && EC32(section_hdr[i].PointerToRawData)%falign && !(EC32(section_hdr[i].PointerToRawData)%0x200)) {",
          "1230:      cli_dbgmsg(\"Found misaligned section, using 0x200\\n\");",
          "1231:      falign = 0x200;",
          "1232:  }",
          "",
          "[Added Lines]",
          "1226:         cli_dbgmsg(\"Possibly broken PE file\\n\");",
          "1228:         free(section_hdr);",
          "1229:         free(exe_sections);",
          "1231:         if(DETECT_BROKEN_PE) {",
          "1232:             cli_append_virus(ctx,\"Heuristics.Broken.Executable\");",
          "1233:             return CL_VIRUS;",
          "1234:         }",
          "1236:         return CL_CLEAN;",
          "1243:         if (falign && section_hdr[i].SizeOfRawData && EC32(section_hdr[i].PointerToRawData)%falign && !(EC32(section_hdr[i].PointerToRawData)%0x200)) {",
          "1244:             cli_dbgmsg(\"Found misaligned section, using 0x200\\n\");",
          "1245:             falign = 0x200;",
          "1246:         }",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "1281:         }",
          "1282:     }",
          "1285:         strncpy(sname, (char *) section_hdr[i].Name, 8);",
          "1286:         sname[8] = 0;",
          "",
          "[Removed Lines]",
          "1284:     for(i = 0; i < nsections; i++) {",
          "",
          "[Added Lines]",
          "1298:         for(i = 0; i < nsections; i++) {",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "1295:         }",
          "1296: #endif",
          "1395:     }",
          "1397:     free(section_hdr);",
          "1399:     if(!(ep = cli_rawaddr(vep, exe_sections, nsections, &err, fsize, hdr_size)) && err) {",
          "1407:     }",
          "1409: #if HAVE_JSON",
          "",
          "[Removed Lines]",
          "1298:  if (!exe_sections[i].vsz && exe_sections[i].rsz)",
          "1299:      exe_sections[i].vsz=PESALIGN(exe_sections[i].ursz, valign);",
          "1301:  if (exe_sections[i].rsz && fsize>exe_sections[i].raw && !CLI_ISCONTAINED(0, (uint32_t) fsize, exe_sections[i].raw, exe_sections[i].rsz))",
          "1302:      exe_sections[i].rsz = fsize - exe_sections[i].raw;",
          "1304:  cli_dbgmsg(\"Section %d\\n\", i);",
          "1305:  cli_dbgmsg(\"Section name: %s\\n\", sname);",
          "1306:  cli_dbgmsg(\"Section data (from headers - in memory)\\n\");",
          "1307:  cli_dbgmsg(\"VirtualSize: 0x%x 0x%x\\n\", exe_sections[i].uvsz, exe_sections[i].vsz);",
          "1308:  cli_dbgmsg(\"VirtualAddress: 0x%x 0x%x\\n\", exe_sections[i].urva, exe_sections[i].rva);",
          "1309:  cli_dbgmsg(\"SizeOfRawData: 0x%x 0x%x\\n\", exe_sections[i].ursz, exe_sections[i].rsz);",
          "1310:  cli_dbgmsg(\"PointerToRawData: 0x%x 0x%x\\n\", exe_sections[i].uraw, exe_sections[i].raw);",
          "1312:  if(exe_sections[i].chr & 0x20) {",
          "1313:      cli_dbgmsg(\"Section contains executable code\\n\");",
          "1315:      if(exe_sections[i].vsz < exe_sections[i].rsz) {",
          "1316:   cli_dbgmsg(\"Section contains free space\\n\");",
          "1318:   cli_dbgmsg(\"Dumping %d bytes\\n\", section_hdr.SizeOfRawData - section_hdr.VirtualSize);",
          "1319:   ddump(desc, section_hdr.PointerToRawData + section_hdr.VirtualSize, section_hdr.SizeOfRawData - section_hdr.VirtualSize, cli_gentemp(NULL));",
          "1322:      }",
          "1323:  }",
          "1325:  if(exe_sections[i].chr & 0x20000000)",
          "1326:      cli_dbgmsg(\"Section's memory is executable\\n\");",
          "1328:  if(exe_sections[i].chr & 0x80000000)",
          "1329:      cli_dbgmsg(\"Section's memory is writeable\\n\");",
          "1332:      cli_dbgmsg(\"VirtualAddress is misaligned\\n\");",
          "1333:      cli_dbgmsg(\"------------------------------------\\n\");",
          "1334:      cli_append_virus(ctx, \"Heuristics.Broken.Executable\");",
          "1335:      free(section_hdr);",
          "1336:      free(exe_sections);",
          "1337:      return CL_VIRUS;",
          "1338:  }",
          "1341:      if(SCAN_ALGO && (DCONF & PE_CONF_POLIPOS) && !*sname && exe_sections[i].vsz > 40000 && exe_sections[i].vsz < 70000 && exe_sections[i].chr == 0xe0000060) polipos = i;",
          "1344:      if((DCONF & PE_CONF_MD5SECT) && ctx->engine->hm_mdb) {",
          "1345:          ret = scan_pe_mdb(ctx, &exe_sections[i]);",
          "1346:          if (ret != CL_CLEAN) {",
          "1347:              if (ret != CL_VIRUS)",
          "1348:                  cli_errmsg(\"scan_pe: scan_pe_mdb failed: %s!\\n\", cl_strerror(ret));",
          "1349:       cli_dbgmsg(\"------------------------------------\\n\");",
          "1350:              free(section_hdr);",
          "1351:              free(exe_sections);",
          "1352:              return ret;",
          "1353:          }",
          "1354:      }",
          "1355:  }",
          "1356:  cli_dbgmsg(\"------------------------------------\\n\");",
          "1358:  if (exe_sections[i].urva>>31 || exe_sections[i].uvsz>>31 || (exe_sections[i].rsz && exe_sections[i].uraw>>31) || exe_sections[i].ursz>>31) {",
          "1359:      cli_dbgmsg(\"Found PE values with sign bit set\\n\");",
          "1360:      free(section_hdr);",
          "1361:      free(exe_sections);",
          "1362:      if(DETECT_BROKEN_PE) {",
          "1363:   cli_append_virus(ctx, \"Heuristics.Broken.Executable\");",
          "1364:   return CL_VIRUS;",
          "1365:      }",
          "1366:      return CL_CLEAN;",
          "1367:  }",
          "1369:  if(!i) {",
          "1371:          cli_dbgmsg(\"First section is in the wrong place\\n\");",
          "1372:   cli_append_virus(ctx, \"Heuristics.Broken.Executable\");",
          "1373:   free(section_hdr);",
          "1374:   free(exe_sections);",
          "1375:   return CL_VIRUS;",
          "1376:      }",
          "1377:      min = exe_sections[i].rva;",
          "1378:      max = exe_sections[i].rva + exe_sections[i].rsz;",
          "1379:  } else {",
          "1381:          cli_dbgmsg(\"Virtually misplaced section (wrong order, overlapping, non contiguous)\\n\");",
          "1382:   cli_append_virus(ctx, \"Heuristics.Broken.Executable\");",
          "1383:   free(section_hdr);",
          "1384:   free(exe_sections);",
          "1385:   return CL_VIRUS;",
          "1386:      }",
          "1387:      if(exe_sections[i].rva < min)",
          "1388:          min = exe_sections[i].rva;",
          "1390:      if(exe_sections[i].rva + exe_sections[i].rsz > max) {",
          "1391:          max = exe_sections[i].rva + exe_sections[i].rsz;",
          "1392:   overlays = exe_sections[i].raw + exe_sections[i].rsz;",
          "1393:      }",
          "1394:  }",
          "1400:  cli_dbgmsg(\"EntryPoint out of file\\n\");",
          "1401:  free(exe_sections);",
          "1402:  if(DETECT_BROKEN_PE) {",
          "1403:      cli_append_virus(ctx,\"Heuristics.Broken.Executable\");",
          "1404:      return CL_VIRUS;",
          "1405:  }",
          "1406:  return CL_CLEAN;",
          "",
          "[Added Lines]",
          "1312:         if (!exe_sections[i].vsz && exe_sections[i].rsz)",
          "1313:             exe_sections[i].vsz=PESALIGN(exe_sections[i].ursz, valign);",
          "1315:         if (exe_sections[i].rsz && fsize>exe_sections[i].raw && !CLI_ISCONTAINED(0, (uint32_t) fsize, exe_sections[i].raw, exe_sections[i].rsz))",
          "1316:             exe_sections[i].rsz = fsize - exe_sections[i].raw;",
          "1318:         cli_dbgmsg(\"Section %d\\n\", i);",
          "1319:         cli_dbgmsg(\"Section name: %s\\n\", sname);",
          "1320:         cli_dbgmsg(\"Section data (from headers - in memory)\\n\");",
          "1321:         cli_dbgmsg(\"VirtualSize: 0x%x 0x%x\\n\", exe_sections[i].uvsz, exe_sections[i].vsz);",
          "1322:         cli_dbgmsg(\"VirtualAddress: 0x%x 0x%x\\n\", exe_sections[i].urva, exe_sections[i].rva);",
          "1323:         cli_dbgmsg(\"SizeOfRawData: 0x%x 0x%x\\n\", exe_sections[i].ursz, exe_sections[i].rsz);",
          "1324:         cli_dbgmsg(\"PointerToRawData: 0x%x 0x%x\\n\", exe_sections[i].uraw, exe_sections[i].raw);",
          "1326:         if(exe_sections[i].chr & 0x20) {",
          "1327:             cli_dbgmsg(\"Section contains executable code\\n\");",
          "1329:             if(exe_sections[i].vsz < exe_sections[i].rsz) {",
          "1330:                 cli_dbgmsg(\"Section contains free space\\n\");",
          "1332:                 cli_dbgmsg(\"Dumping %d bytes\\n\", section_hdr.SizeOfRawData - section_hdr.VirtualSize);",
          "1333:                 ddump(desc, section_hdr.PointerToRawData + section_hdr.VirtualSize, section_hdr.SizeOfRawData - section_hdr.VirtualSize, cli_gentemp(NULL));",
          "1335:             }",
          "1336:         }",
          "1338:         if(exe_sections[i].chr & 0x20000000)",
          "1339:             cli_dbgmsg(\"Section's memory is executable\\n\");",
          "1341:         if(exe_sections[i].chr & 0x80000000)",
          "1342:             cli_dbgmsg(\"Section's memory is writeable\\n\");",
          "1345:             cli_dbgmsg(\"VirtualAddress is misaligned\\n\");",
          "1346:             cli_dbgmsg(\"------------------------------------\\n\");",
          "1347:             cli_append_virus(ctx, \"Heuristics.Broken.Executable\");",
          "1348:             free(section_hdr);",
          "1349:             free(exe_sections);",
          "1350:             return CL_VIRUS;",
          "1351:         }",
          "1354:             if(SCAN_ALGO && (DCONF & PE_CONF_POLIPOS) && !*sname && exe_sections[i].vsz > 40000 && exe_sections[i].vsz < 70000 && exe_sections[i].chr == 0xe0000060) polipos = i;",
          "1357:             if((DCONF & PE_CONF_MD5SECT) && ctx->engine->hm_mdb) {",
          "1358:                 ret = scan_pe_mdb(ctx, &exe_sections[i]);",
          "1359:                 if (ret != CL_CLEAN) {",
          "1360:                     if (ret != CL_VIRUS)",
          "1361:                         cli_errmsg(\"scan_pe: scan_pe_mdb failed: %s!\\n\", cl_strerror(ret));",
          "1363:                     cli_dbgmsg(\"------------------------------------\\n\");",
          "1364:                     free(section_hdr);",
          "1365:                     free(exe_sections);",
          "1366:                     return ret;",
          "1367:                 }",
          "1368:             }",
          "1369:         }",
          "1370:         cli_dbgmsg(\"------------------------------------\\n\");",
          "1372:         if (exe_sections[i].urva>>31 || exe_sections[i].uvsz>>31 || (exe_sections[i].rsz && exe_sections[i].uraw>>31) || exe_sections[i].ursz>>31) {",
          "1373:             cli_dbgmsg(\"Found PE values with sign bit set\\n\");",
          "1375:             free(section_hdr);",
          "1376:             free(exe_sections);",
          "1377:             if(DETECT_BROKEN_PE) {",
          "1378:                 cli_append_virus(ctx, \"Heuristics.Broken.Executable\");",
          "1379:                 return CL_VIRUS;",
          "1380:             }",
          "1382:             return CL_CLEAN;",
          "1383:         }",
          "1385:         if(!i) {",
          "1387:                 cli_dbgmsg(\"First section is in the wrong place\\n\");",
          "1388:                 cli_append_virus(ctx, \"Heuristics.Broken.Executable\");",
          "1389:                 free(section_hdr);",
          "1390:                 free(exe_sections);",
          "1391:                 return CL_VIRUS;",
          "1392:             }",
          "1394:             min = exe_sections[i].rva;",
          "1395:             max = exe_sections[i].rva + exe_sections[i].rsz;",
          "1396:         } else {",
          "1398:                 cli_dbgmsg(\"Virtually misplaced section (wrong order, overlapping, non contiguous)\\n\");",
          "1399:                 cli_append_virus(ctx, \"Heuristics.Broken.Executable\");",
          "1400:                 free(section_hdr);",
          "1401:                 free(exe_sections);",
          "1402:                 return CL_VIRUS;",
          "1403:             }",
          "1405:             if(exe_sections[i].rva < min)",
          "1406:                 min = exe_sections[i].rva;",
          "1408:             if(exe_sections[i].rva + exe_sections[i].rsz > max) {",
          "1409:                 max = exe_sections[i].rva + exe_sections[i].rsz;",
          "1410:                 overlays = exe_sections[i].raw + exe_sections[i].rsz;",
          "1411:             }",
          "1412:         }",
          "1418:         cli_dbgmsg(\"EntryPoint out of file\\n\");",
          "1419:         free(exe_sections);",
          "1420:         if(DETECT_BROKEN_PE) {",
          "1421:             cli_append_virus(ctx,\"Heuristics.Broken.Executable\");",
          "1422:             return CL_VIRUS;",
          "1423:         }",
          "1425:         return CL_CLEAN;",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "1417:     cli_dbgmsg(\"EntryPoint offset: 0x%x (%d)\\n\", ep, ep);",
          "1422:     }",
          "1424:     epsize = fmap_readn(map, epbuff, ep, 4096);",
          "",
          "[Removed Lines]",
          "1420:  free(exe_sections);",
          "1421:  return CL_CLEAN;",
          "",
          "[Added Lines]",
          "1439:         free(exe_sections);",
          "1440:         return CL_CLEAN;",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "1440:     if(overlays) {",
          "1449:     }",
          "1451:     pedata.nsections = nsections;",
          "",
          "[Removed Lines]",
          "1441:  int overlays_sz = fsize - overlays;",
          "1442:  if(overlays_sz > 0) {",
          "1443:      ret = cli_scanishield(ctx, overlays, overlays_sz);",
          "1444:      if(ret != CL_CLEAN) {",
          "1445:   free(exe_sections);",
          "1446:   return ret;",
          "1447:      }",
          "1448:  }",
          "",
          "[Added Lines]",
          "1460:         int overlays_sz = fsize - overlays;",
          "1461:         if(overlays_sz > 0) {",
          "1462:             ret = cli_scanishield(ctx, overlays, overlays_sz);",
          "1463:             if(ret != CL_CLEAN) {",
          "1464:                 free(exe_sections);",
          "1465:                 return ret;",
          "1466:             }",
          "1467:         }",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "1464:     bc_ctx = cli_bytecode_context_alloc();",
          "1465:     if (!bc_ctx) {",
          "1469:     }",
          "1470:     cli_bytecode_context_setpe(bc_ctx, &pedata, exe_sections);",
          "1471:     cli_bytecode_context_setctx(bc_ctx, ctx);",
          "1472:     ret = cli_bytecode_runhook(ctx, ctx->engine, bc_ctx, BC_PE_ALL, map);",
          "",
          "[Removed Lines]",
          "1466:  cli_errmsg(\"cli_scanpe: can't allocate memory for bc_ctx\\n\");",
          "1467:  free(exe_sections);",
          "1468:  return CL_EMEM;",
          "",
          "[Added Lines]",
          "1485:         cli_errmsg(\"cli_scanpe: can't allocate memory for bc_ctx\\n\");",
          "1486:         free(exe_sections);",
          "1487:         return CL_EMEM;",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "1487:     if(SCAN_ALGO && (DCONF & PE_CONF_PARITE) && !dll && epsize == 4096 && ep == exe_sections[nsections - 1].raw) {",
          "1488:         const char *pt = cli_memstr(epbuff, 4040, \"\\x47\\x65\\x74\\x50\\x72\\x6f\\x63\\x41\\x64\\x64\\x72\\x65\\x73\\x73\\x00\", 15);",
          "1500:     }",
          "1503:     if(SCAN_ALGO && (DCONF & PE_CONF_KRIZ) && epsize >= 200 && CLI_ISCONTAINED(exe_sections[nsections - 1].raw, exe_sections[nsections - 1].rsz, ep, 0x0fd2) && epbuff[1]=='\\x9c' && epbuff[2]=='\\x60') {",
          "1589:     }",
          "1592:     if(SCAN_ALGO && (DCONF & PE_CONF_MAGISTR) && !dll && (nsections>1) && (exe_sections[nsections - 1].chr & 0x80000000)) {",
          "1593:         uint32_t rsize, vsize, dam = 0;",
          "1632:     }",
          "1635:     while(polipos && !dll && nsections > 2 && nsections < 13 && e_lfanew <= 0x800 && (EC16(optional_hdr32.Subsystem) == 2 || EC16(optional_hdr32.Subsystem) == 3) && EC16(file_hdr.Machine) == 0x14c && optional_hdr32.SizeOfStackReserve >= 0x80000) {",
          "",
          "[Removed Lines]",
          "1489:  if(pt) {",
          "1490:      pt += 15;",
          "1491:      if((((uint32_t)cli_readint32(pt) ^ (uint32_t)cli_readint32(pt + 4)) == 0x505a4f) && (((uint32_t)cli_readint32(pt + 8) ^ (uint32_t)cli_readint32(pt + 12)) == 0xffffb) && (((uint32_t)cli_readint32(pt + 16) ^ (uint32_t)cli_readint32(pt + 20)) == 0xb8)) {",
          "1492:          cli_append_virus(ctx,\"Heuristics.W32.Parite.B\");",
          "1493:   if (!SCAN_ALL) {",
          "1494:       free(exe_sections);",
          "1495:       return CL_VIRUS;",
          "1496:   }",
          "1497:   viruses_found++;",
          "1498:      }",
          "1499:  }",
          "1504:  enum {KZSTRASH,KZSCDELTA,KZSPDELTA,KZSGETSIZE,KZSXORPRFX,KZSXOR,KZSDDELTA,KZSLOOP,KZSTOP};",
          "1505:  uint8_t kzs[] = {KZSTRASH,KZSCDELTA,KZSPDELTA,KZSGETSIZE,KZSTRASH,KZSXORPRFX,KZSXOR,KZSTRASH,KZSDDELTA,KZSTRASH,KZSLOOP,KZSTOP};",
          "1506:  uint8_t *kzstate = kzs;",
          "1507:  uint8_t *kzcode = (uint8_t *)epbuff + 3;",
          "1508:  uint8_t kzdptr=0xff, kzdsize=0xff;",
          "1509:  int kzlen = 197, kzinitlen=0xffff, kzxorlen=-1;",
          "1510:  cli_dbgmsg(\"in kriz\\n\");",
          "1512:  while(*kzstate!=KZSTOP) {",
          "1513:      uint8_t op;",
          "1514:      if(kzlen<=6) break;",
          "1515:      op = *kzcode++;",
          "1516:      kzlen--;",
          "1517:      switch (*kzstate) {",
          "1518:      case KZSTRASH: case KZSGETSIZE: {",
          "1519:   int opsz=0;",
          "1520:   switch(op) {",
          "1521:   case 0x81:",
          "1522:       kzcode+=5;",
          "1523:       kzlen-=5;",
          "1524:       break;",
          "1525:   case 0xb8: case 0xb9: case 0xba: case 0xbb: case 0xbd: case 0xbe: case 0xbf:",
          "1526:       if(*kzstate==KZSGETSIZE && cli_readint32(kzcode)==0x0fd2) {",
          "1527:    kzinitlen = kzlen-5;",
          "1528:    kzdsize=op-0xb8;",
          "1529:    kzstate++;",
          "1531:    cli_dbgmsg(\"kriz: using #%d as size counter\\n\", kzdsize);",
          "1532:       }",
          "1533:       opsz=4;",
          "1534:   case 0x48: case 0x49: case 0x4a: case 0x4b: case 0x4d: case 0x4e: case 0x4f:",
          "1535:       op&=7;",
          "1536:       if(op!=kzdptr && op!=kzdsize) {",
          "1537:    kzcode+=opsz;",
          "1538:    kzlen-=opsz;",
          "1539:    break;",
          "1540:       }",
          "1541:   default:",
          "1542:       kzcode--;",
          "1543:       kzlen++;",
          "1544:       kzstate++;",
          "1545:   }",
          "1546:   break;",
          "1547:      }",
          "1548:      case KZSCDELTA:",
          "1549:   if(op==0xe8 && (uint32_t)cli_readint32(kzcode) < 0xff) {",
          "1550:       kzlen-=*kzcode+4;",
          "1551:       kzcode+=*kzcode+4;",
          "1552:       kzstate++;",
          "1553:   } else *kzstate=KZSTOP;",
          "1554:   break;",
          "1555:      case KZSPDELTA:",
          "1556:   if((op&0xf8)==0x58 && (kzdptr=op-0x58)!=4) {",
          "1557:       kzstate++;",
          "1558:       cli_dbgmsg(\"kriz: using #%d as pointer\\n\", kzdptr);",
          "1559:   } else *kzstate=KZSTOP;",
          "1560:   break;",
          "1561:      case KZSXORPRFX:",
          "1562:   kzstate++;",
          "1563:   if(op==0x3e) break;",
          "1564:      case KZSXOR:",
          "1565:   if (op==0x80 && *kzcode==kzdptr+0xb0) {",
          "1566:       kzxorlen=kzlen;",
          "1567:       kzcode+=+6;",
          "1568:       kzlen-=+6;",
          "1569:       kzstate++;",
          "1570:   } else *kzstate=KZSTOP;",
          "1571:   break;",
          "1572:      case KZSDDELTA:",
          "1573:   if (op==kzdptr+0x48) kzstate++;",
          "1574:   else *kzstate=KZSTOP;",
          "1575:   break;",
          "1576:      case KZSLOOP:",
          "1577:   if (op==kzdsize+0x48 && *kzcode==0x75 && kzlen-(int8_t)kzcode[1]-3<=kzinitlen && kzlen-(int8_t)kzcode[1]>=kzxorlen) {",
          "1578:       cli_append_virus(ctx,\"Heuristics.W32.Kriz\");",
          "1579:       if (!SCAN_ALL) {",
          "1580:           free(exe_sections);",
          "1581:    return CL_VIRUS;",
          "1582:       }",
          "1583:       viruses_found++;",
          "1584:   }",
          "1585:   cli_dbgmsg(\"kriz: loop out of bounds, corrupted sample?\\n\");",
          "1586:   kzstate++;",
          "1587:      }",
          "1588:  }",
          "1595:  vsize = exe_sections[nsections - 1].uvsz;",
          "1596:  rsize = exe_sections[nsections - 1].rsz;",
          "1597:  if(rsize < exe_sections[nsections - 1].ursz) {",
          "1598:      rsize = exe_sections[nsections - 1].ursz;",
          "1599:      dam = 1;",
          "1600:  }",
          "1602:  if(vsize >= 0x612c && rsize >= 0x612c && ((vsize & 0xff) == 0xec)) {",
          "1603:   int bw = rsize < 0x7000 ? rsize : 0x7000;",
          "1604:   const char *tbuff;",
          "1606:      if((tbuff = fmap_need_off_once(map, exe_sections[nsections - 1].raw + rsize - bw, 4096))) {",
          "1607:   if(cli_memstr(tbuff, 4091, \"\\xe8\\x2c\\x61\\x00\\x00\", 5)) {",
          "1608:       cli_append_virus(ctx, dam ? \"Heuristics.W32.Magistr.A.dam\" : \"Heuristics.W32.Magistr.A\");",
          "1609:       if (!SCAN_ALL) {",
          "1610:           free(exe_sections);",
          "1611:    return CL_VIRUS;",
          "1612:       }",
          "1613:       viruses_found++;",
          "1614:   }",
          "1615:      }",
          "1617:  } else if(rsize >= 0x7000 && vsize >= 0x7000 && ((vsize & 0xff) == 0xed)) {",
          "1618:   int bw = rsize < 0x8000 ? rsize : 0x8000;",
          "1619:   const char *tbuff;",
          "1621:      if((tbuff = fmap_need_off_once(map, exe_sections[nsections - 1].raw + rsize - bw, 4096))) {",
          "1622:   if(cli_memstr(tbuff, 4091, \"\\xe8\\x04\\x72\\x00\\x00\", 5)) {",
          "1623:       cli_append_virus(ctx,dam ? \"Heuristics.W32.Magistr.B.dam\" : \"Heuristics.W32.Magistr.B\");",
          "1624:       if (!SCAN_ALL) {",
          "1625:           free(exe_sections);",
          "1626:    return CL_VIRUS;",
          "1627:       }",
          "1628:       viruses_found++;",
          "1629:   }",
          "1630:      }",
          "1631:  }",
          "1636:  uint32_t jump, jold, *jumps = NULL;",
          "1637:  const uint8_t *code;",
          "1638:  unsigned int xsjs = 0;",
          "1640:  if(exe_sections[0].rsz > CLI_MAX_ALLOCATION) break;",
          "1642:  if(!exe_sections[0].rsz) break;",
          "1643:  if(!(code=fmap_need_off_once(map, exe_sections[0].raw, exe_sections[0].rsz))) break;",
          "1644:  for(i=0; i<exe_sections[0].rsz - 5; i++) {",
          "1645:      if((uint8_t)(code[i]-0xe8) > 1) continue;",
          "1646:      jump = cli_rawaddr(exe_sections[0].rva+i+5+cli_readint32(&code[i+1]), exe_sections, nsections, &err, fsize, hdr_size);",
          "1647:      if(err || !CLI_ISCONTAINED(exe_sections[polipos].raw, exe_sections[polipos].rsz, jump, 9)) continue;",
          "1648:      if(xsjs % 128 == 0) {",
          "1649:   if(xsjs == 1280) break;",
          "1650:   if(!(jumps=(uint32_t *)cli_realloc2(jumps, (xsjs+128)*sizeof(uint32_t)))) {",
          "1651:       free(exe_sections);",
          "1652:       return CL_EMEM;",
          "1653:   }",
          "1654:      }",
          "1655:      j=0;",
          "1656:      for(; j<xsjs; j++) {",
          "1657:   if(jumps[j]<jump) continue;",
          "1658:   if(jumps[j]==jump) {",
          "1659:       xsjs--;",
          "1660:       break;",
          "1661:   }",
          "1662:   jold=jumps[j];",
          "1663:   jumps[j]=jump;",
          "1664:   jump=jold;",
          "1665:      }",
          "1666:      jumps[j]=jump;",
          "1667:      xsjs++;",
          "1668:  }",
          "1669:  if(!xsjs) break;",
          "1670:  cli_dbgmsg(\"Polipos: Checking %d xsect jump(s)\\n\", xsjs);",
          "1671:  for(i=0;i<xsjs;i++) {",
          "1672:      if(!(code = fmap_need_off_once(map, jumps[i], 9))) continue;",
          "1673:      if((jump=cli_readint32(code))==0x60ec8b55 || (code[4]==0x0ec && ((jump==0x83ec8b55 && code[6]==0x60) || (jump==0x81ec8b55 && !code[7] && !code[8])))) {",
          "1674:   cli_append_virus(ctx,\"Heuristics.W32.Polipos.A\");",
          "1675:   if (!SCAN_ALL) {",
          "1676:       free(jumps);",
          "1677:       free(exe_sections);",
          "1678:       return CL_VIRUS;",
          "1679:   }",
          "1680:   viruses_found++;",
          "1681:      }",
          "1682:  }",
          "1683:  free(jumps);",
          "1684:  break;",
          "1685:     }",
          "1688:     if (SCAN_ALGO && (DCONF & PE_CONF_SWIZZOR) && nsections > 1 && fsize > 64*1024 && fsize < 4*1024*1024) {",
          "1689:      if(dirs[2].Size) {",
          "1690:       struct swizz_stats *stats = cli_calloc(1, sizeof(*stats));",
          "1691:       unsigned int m = 1000;",
          "1692:       ret = CL_CLEAN;",
          "1694:       if (!stats)",
          "1695:        ret = CL_EMEM;",
          "1696:       else {",
          "1697:        cli_parseres_special(EC32(dirs[2].VirtualAddress), EC32(dirs[2].VirtualAddress), map, exe_sections, nsections, fsize, hdr_size, 0, 0, &m, stats);",
          "1698:        if ((ret = cli_detect_swizz(stats)) == CL_VIRUS) {",
          "1699:     cli_append_virus(ctx,\"Heuristics.Trojan.Swizzor.Gen\");",
          "1700:        }",
          "1701:        free(stats);",
          "1702:       }",
          "1703:       if (ret != CL_CLEAN) {",
          "1704:    if (!(ret == CL_VIRUS && SCAN_ALL)) {",
          "1705:        free(exe_sections);",
          "1706:        return ret;",
          "1707:    }",
          "1708:    viruses_found++;",
          "1709:       }",
          "1710:      }",
          "1711:     }",
          "",
          "[Added Lines]",
          "1509:         if(pt) {",
          "1510:             pt += 15;",
          "1511:             if((((uint32_t)cli_readint32(pt) ^ (uint32_t)cli_readint32(pt + 4)) == 0x505a4f) && (((uint32_t)cli_readint32(pt + 8) ^ (uint32_t)cli_readint32(pt + 12)) == 0xffffb) && (((uint32_t)cli_readint32(pt + 16) ^ (uint32_t)cli_readint32(pt + 20)) == 0xb8)) {",
          "1512:                 cli_append_virus(ctx,\"Heuristics.W32.Parite.B\");",
          "1513:                 if (!SCAN_ALL) {",
          "1514:                     free(exe_sections);",
          "1515:                     return CL_VIRUS;",
          "1516:                 }",
          "1518:                 viruses_found++;",
          "1519:             }",
          "1520:         }",
          "1525:         enum {KZSTRASH,KZSCDELTA,KZSPDELTA,KZSGETSIZE,KZSXORPRFX,KZSXOR,KZSDDELTA,KZSLOOP,KZSTOP};",
          "1526:         uint8_t kzs[] = {KZSTRASH,KZSCDELTA,KZSPDELTA,KZSGETSIZE,KZSTRASH,KZSXORPRFX,KZSXOR,KZSTRASH,KZSDDELTA,KZSTRASH,KZSLOOP,KZSTOP};",
          "1527:         uint8_t *kzstate = kzs;",
          "1528:         uint8_t *kzcode = (uint8_t *)epbuff + 3;",
          "1529:         uint8_t kzdptr=0xff, kzdsize=0xff;",
          "1530:         int kzlen = 197, kzinitlen=0xffff, kzxorlen=-1;",
          "1531:         cli_dbgmsg(\"in kriz\\n\");",
          "1533:         while(*kzstate!=KZSTOP) {",
          "1534:             uint8_t op;",
          "1535:             if(kzlen<=6)",
          "1536:                 break;",
          "1538:             op = *kzcode++;",
          "1539:             kzlen--;",
          "1541:             switch (*kzstate) {",
          "1542:             case KZSTRASH:",
          "1543:             case KZSGETSIZE: {",
          "1544:                 int opsz=0;",
          "1545:                 switch(op) {",
          "1546:                 case 0x81:",
          "1547:                     kzcode+=5;",
          "1548:                     kzlen-=5;",
          "1549:                     break;",
          "1550:                 case 0xb8:",
          "1551:                 case 0xb9:",
          "1552:                 case 0xba:",
          "1553:                 case 0xbb:",
          "1554:                 case 0xbd:",
          "1555:                 case 0xbe:",
          "1556:                 case 0xbf:",
          "1557:                     if(*kzstate==KZSGETSIZE && cli_readint32(kzcode)==0x0fd2) {",
          "1558:                         kzinitlen = kzlen-5;",
          "1559:                         kzdsize=op-0xb8;",
          "1560:                         kzstate++;",
          "1563:                         cli_dbgmsg(\"kriz: using #%d as size counter\\n\", kzdsize);",
          "1564:                     }",
          "1565:                     opsz=4;",
          "1566:                 case 0x48:",
          "1567:                 case 0x49:",
          "1568:                 case 0x4a:",
          "1569:                 case 0x4b:",
          "1570:                 case 0x4d:",
          "1571:                 case 0x4e:",
          "1572:                 case 0x4f:",
          "1573:                     op&=7;",
          "1574:                     if(op!=kzdptr && op!=kzdsize) {",
          "1575:                         kzcode+=opsz;",
          "1576:                         kzlen-=opsz;",
          "1577:                         break;",
          "1578:                     }",
          "1579:                 default:",
          "1580:                     kzcode--;",
          "1581:                     kzlen++;",
          "1582:                     kzstate++;",
          "1583:                 }",
          "1585:                 break;",
          "1586:             }",
          "1587:             case KZSCDELTA:",
          "1588:                 if(op==0xe8 && (uint32_t)cli_readint32(kzcode) < 0xff) {",
          "1589:                     kzlen-=*kzcode+4;",
          "1590:                     kzcode+=*kzcode+4;",
          "1591:                     kzstate++;",
          "1592:                 } else {",
          "1594:                 }",
          "1596:                 break;",
          "1597:             case KZSPDELTA:",
          "1598:                 if((op&0xf8)==0x58 && (kzdptr=op-0x58)!=4) {",
          "1599:                     kzstate++;",
          "1600:                     cli_dbgmsg(\"kriz: using #%d as pointer\\n\", kzdptr);",
          "1601:                 } else {",
          "1603:                 }",
          "1605:                 break;",
          "1606:             case KZSXORPRFX:",
          "1607:                 kzstate++;",
          "1608:                 if(op==0x3e)",
          "1609:                     break;",
          "1610:             case KZSXOR:",
          "1611:                 if (op==0x80 && *kzcode==kzdptr+0xb0) {",
          "1612:                     kzxorlen=kzlen;",
          "1613:                     kzcode+=+6;",
          "1614:                     kzlen-=+6;",
          "1615:                     kzstate++;",
          "1616:                 } else {",
          "1618:                 }",
          "1620:                 break;",
          "1621:             case KZSDDELTA:",
          "1622:                 if (op==kzdptr+0x48)",
          "1623:                     kzstate++;",
          "1624:                 else",
          "1627:                 break;",
          "1628:             case KZSLOOP:",
          "1629:                 if (op==kzdsize+0x48 && *kzcode==0x75 && kzlen-(int8_t)kzcode[1]-3<=kzinitlen && kzlen-(int8_t)kzcode[1]>=kzxorlen) {",
          "1630:                     cli_append_virus(ctx,\"Heuristics.W32.Kriz\");",
          "1631:                     if (!SCAN_ALL) {",
          "1632:                         free(exe_sections);",
          "1633:                         return CL_VIRUS;",
          "1634:                     }",
          "1636:                     viruses_found++;",
          "1637:                 }",
          "1639:                 cli_dbgmsg(\"kriz: loop out of bounds, corrupted sample?\\n\");",
          "1640:                 kzstate++;",
          "1641:             }",
          "1642:         }",
          "1649:         vsize = exe_sections[nsections - 1].uvsz;",
          "1650:         rsize = exe_sections[nsections - 1].rsz;",
          "1651:         if(rsize < exe_sections[nsections - 1].ursz) {",
          "1652:             rsize = exe_sections[nsections - 1].ursz;",
          "1653:             dam = 1;",
          "1654:         }",
          "1656:         if(vsize >= 0x612c && rsize >= 0x612c && ((vsize & 0xff) == 0xec)) {",
          "1657:             int bw = rsize < 0x7000 ? rsize : 0x7000;",
          "1658:             const char *tbuff;",
          "1660:             if((tbuff = fmap_need_off_once(map, exe_sections[nsections - 1].raw + rsize - bw, 4096))) {",
          "1661:                 if(cli_memstr(tbuff, 4091, \"\\xe8\\x2c\\x61\\x00\\x00\", 5)) {",
          "1662:                     cli_append_virus(ctx, dam ? \"Heuristics.W32.Magistr.A.dam\" : \"Heuristics.W32.Magistr.A\");",
          "1663:                     if (!SCAN_ALL) {",
          "1664:                         free(exe_sections);",
          "1665:                         return CL_VIRUS;",
          "1666:                     }",
          "1668:                     viruses_found++;",
          "1669:                 }",
          "1670:             }",
          "1671:         } else if(rsize >= 0x7000 && vsize >= 0x7000 && ((vsize & 0xff) == 0xed)) {",
          "1672:             int bw = rsize < 0x8000 ? rsize : 0x8000;",
          "1673:             const char *tbuff;",
          "1675:             if((tbuff = fmap_need_off_once(map, exe_sections[nsections - 1].raw + rsize - bw, 4096))) {",
          "1676:                 if(cli_memstr(tbuff, 4091, \"\\xe8\\x04\\x72\\x00\\x00\", 5)) {",
          "1677:                     cli_append_virus(ctx,dam ? \"Heuristics.W32.Magistr.B.dam\" : \"Heuristics.W32.Magistr.B\");",
          "1678:                     if (!SCAN_ALL) {",
          "1679:                         free(exe_sections);",
          "1680:                         return CL_VIRUS;",
          "1681:                     }",
          "1683:                     viruses_found++;",
          "1684:                 }",
          "1685:             }",
          "1686:         }",
          "1691:         uint32_t jump, jold, *jumps = NULL;",
          "1692:         const uint8_t *code;",
          "1693:         unsigned int xsjs = 0;",
          "1695:         if(exe_sections[0].rsz > CLI_MAX_ALLOCATION)",
          "1696:             break;",
          "1697:         if(!exe_sections[0].rsz)",
          "1698:             break;",
          "1699:         if(!(code=fmap_need_off_once(map, exe_sections[0].raw, exe_sections[0].rsz)))",
          "1700:             break;",
          "1702:         for(i=0; i<exe_sections[0].rsz - 5; i++) {",
          "1703:             if((uint8_t)(code[i]-0xe8) > 1)",
          "1704:                 continue;",
          "1706:             jump = cli_rawaddr(exe_sections[0].rva+i+5+cli_readint32(&code[i+1]), exe_sections, nsections, &err, fsize, hdr_size);",
          "1707:             if(err || !CLI_ISCONTAINED(exe_sections[polipos].raw, exe_sections[polipos].rsz, jump, 9))",
          "1708:                 continue;",
          "1710:             if(xsjs % 128 == 0) {",
          "1711:                 if(xsjs == 1280)",
          "1712:                     break;",
          "1714:                 if(!(jumps=(uint32_t *)cli_realloc2(jumps, (xsjs+128)*sizeof(uint32_t)))) {",
          "1715:                     free(exe_sections);",
          "1716:                     return CL_EMEM;",
          "1717:                 }",
          "1718:             }",
          "1720:             j=0;",
          "1721:             for(; j<xsjs; j++) {",
          "1722:                 if(jumps[j]<jump)",
          "1723:                     continue;",
          "1724:                 if(jumps[j]==jump) {",
          "1725:                     xsjs--;",
          "1726:                     break;",
          "1727:                 }",
          "1729:                 jold=jumps[j];",
          "1730:                 jumps[j]=jump;",
          "1731:                 jump=jold;",
          "1732:             }",
          "1734:             jumps[j]=jump;",
          "1735:             xsjs++;",
          "1736:         }",
          "1738:         if(!xsjs)",
          "1739:             break;",
          "1741:         cli_dbgmsg(\"Polipos: Checking %d xsect jump(s)\\n\", xsjs);",
          "1742:         for(i=0;i<xsjs;i++) {",
          "1743:             if(!(code = fmap_need_off_once(map, jumps[i], 9)))",
          "1744:                 continue;",
          "1746:             if((jump=cli_readint32(code))==0x60ec8b55 || (code[4]==0x0ec && ((jump==0x83ec8b55 && code[6]==0x60) || (jump==0x81ec8b55 && !code[7] && !code[8])))) {",
          "1747:                 cli_append_virus(ctx,\"Heuristics.W32.Polipos.A\");",
          "1748:                 if (!SCAN_ALL) {",
          "1749:                     free(jumps);",
          "1750:                     free(exe_sections);",
          "1751:                     return CL_VIRUS;",
          "1752:                 }",
          "1754:                 viruses_found++;",
          "1755:             }",
          "1756:         }",
          "1758:         free(jumps);",
          "1759:         break;",
          "1760:     }",
          "1763:     if (SCAN_ALGO && (DCONF & PE_CONF_SWIZZOR) && nsections > 1 && fsize > 64*1024 && fsize < 4*1024*1024) {",
          "1764:         if(dirs[2].Size) {",
          "1765:             struct swizz_stats *stats = cli_calloc(1, sizeof(*stats));",
          "1766:             unsigned int m = 1000;",
          "1767:             ret = CL_CLEAN;",
          "1769:             if (!stats) {",
          "1770:                 ret = CL_EMEM;",
          "1771:             } else {",
          "1772:                 cli_parseres_special(EC32(dirs[2].VirtualAddress), EC32(dirs[2].VirtualAddress), map, exe_sections, nsections, fsize, hdr_size, 0, 0, &m, stats);",
          "1773:                 if ((ret = cli_detect_swizz(stats)) == CL_VIRUS)",
          "1774:                     cli_append_virus(ctx,\"Heuristics.Trojan.Swizzor.Gen\");",
          "1776:                 free(stats);",
          "1777:             }",
          "1778:             if (ret != CL_CLEAN) {",
          "1779:                 if (!(ret == CL_VIRUS && SCAN_ALL)) {",
          "1780:                     free(exe_sections);",
          "1781:                     return ret;",
          "1782:                 }",
          "1784:                 viruses_found++;",
          "1785:             }",
          "1786:         }",
          "1787:     }",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "1722:     found = 0;",
          "1723:     if(DCONF & (PE_CONF_UPX | PE_CONF_FSG | PE_CONF_MEW)) {",
          "1728: #if HAVE_JSON",
          "1730: #endif",
          "1734:     }",
          "1737:     if (found && (DCONF & PE_CONF_MEW) && epsize>=16 && epbuff[0]=='\\xe9') {",
          "1803: #if HAVE_JSON",
          "1805: #endif",
          "1811:     }",
          "1813:     if(epsize<168) {",
          "1816:     }",
          "1818:     if (found || upack) {",
          "1913: #if HAVE_JSON",
          "1915: #endif",
          "1924:     while(found  && (DCONF & PE_CONF_FSG) && epbuff[0] == '\\x87' && epbuff[1] == '\\x25') {",
          "2000: #if HAVE_JSON",
          "2002: #endif",
          "2007:     }",
          "2010:     while(found && (DCONF & PE_CONF_FSG) && epbuff[0] == '\\xbe' && cli_readint32(epbuff + 1) - EC32(optional_hdr32.ImageBase) < min) {",
          "2107: #if HAVE_JSON",
          "2109: #endif",
          "2114:     }",
          "2117:     while(found && (DCONF & PE_CONF_FSG) && epbuff[0] == '\\xbb' && cli_readint32(epbuff + 1) - EC32(optional_hdr32.ImageBase) < min && epbuff[5] == '\\xbf' && epbuff[10] == '\\xbe' && vep >= exe_sections[i + 1].rva && vep - exe_sections[i + 1].rva > exe_sections[i + 1].rva - 0xe0 ) {",
          "2213: #if HAVE_JSON",
          "2215: #endif",
          "2220:     }",
          "2223:     if(found && (DCONF & PE_CONF_UPX)) {",
          "2342:     }",
          "2344:     if(upx_success) {",
          "2348: #if HAVE_JSON",
          "2350: #endif",
          "2363:         close(ndesc);",
          "2364:         CLI_TMPUNLK();",
          "2365:         free(tempfile);",
          "2388:     }",
          "2393:     if(epsize<200) {",
          "2396:     }",
          "2398:     found = 2;",
          "2400:     if(epbuff[0] != '\\xb8' || (uint32_t) cli_readint32(epbuff + 1) != exe_sections[nsections - 1].rva + EC32(optional_hdr32.ImageBase)) {",
          "2405:     }",
          "2407:     if(found && (DCONF & PE_CONF_PETITE)) {",
          "2433: #if HAVE_JSON",
          "2435: #endif",
          "2440:     }",
          "",
          "[Removed Lines]",
          "1724:  for(i = 0; i < (unsigned int) nsections - 1; i++) {",
          "1725:      if(!exe_sections[i].rsz && exe_sections[i].vsz && exe_sections[i + 1].rsz && exe_sections[i + 1].vsz) {",
          "1726:   found = 1;",
          "1727:   cli_dbgmsg(\"UPX/FSG/MEW: empty section found - assuming compression\\n\");",
          "1729:         cli_jsonbool(pe_json, \"HasEmptySection\", 1);",
          "1731:   break;",
          "1732:      }",
          "1733:  }",
          "1738:  uint32_t fileoffset;",
          "1739:  const char *tbuff;",
          "1741:  fileoffset = (vep + cli_readint32(epbuff + 1) + 5);",
          "1742:  while (fileoffset == 0x154 || fileoffset == 0x158) {",
          "1743:      char *src;",
          "1744:      uint32_t offdiff, uselzma;",
          "1746:      cli_dbgmsg (\"MEW: found MEW characteristics %08X + %08X + 5 = %08X\\n\",",
          "1747:    cli_readint32(epbuff + 1), vep, cli_readint32(epbuff + 1) + vep + 5);",
          "1749:      if(!(tbuff = fmap_need_off_once(map, fileoffset, 0xb0)))",
          "1750:   break;",
          "1751:      if (fileoffset == 0x154) cli_dbgmsg(\"MEW: Win9x compatibility was set!\\n\");",
          "1752:      else cli_dbgmsg(\"MEW: Win9x compatibility was NOT set!\\n\");",
          "1754:      if((offdiff = cli_readint32(tbuff+1) - EC32(optional_hdr32.ImageBase)) <= exe_sections[i + 1].rva || offdiff >= exe_sections[i + 1].rva + exe_sections[i + 1].raw - 4) {",
          "1755:          cli_dbgmsg(\"MEW: ESI is not in proper section\\n\");",
          "1756:   break;",
          "1757:      }",
          "1758:      offdiff -= exe_sections[i + 1].rva;",
          "1760:      if(!exe_sections[i + 1].rsz) {",
          "1761:   cli_dbgmsg(\"MEW: mew section is empty\\n\");",
          "1762:   break;",
          "1763:      }",
          "1764:      ssize = exe_sections[i + 1].vsz;",
          "1765:      dsize = exe_sections[i].vsz;",
          "1767:      cli_dbgmsg(\"MEW: ssize %08x dsize %08x offdiff: %08x\\n\", ssize, dsize, offdiff);",
          "1769:      CLI_UNPSIZELIMITS(\"MEW\", MAX(ssize, dsize));",
          "1770:      CLI_UNPSIZELIMITS(\"MEW\", MAX(ssize + dsize, exe_sections[i + 1].rsz));",
          "1772:      if (exe_sections[i + 1].rsz < offdiff + 12 || exe_sections[i + 1].rsz > ssize) {",
          "1773:          cli_dbgmsg(\"MEW: Size mismatch: %08x\\n\", exe_sections[i + 1].rsz);",
          "1774:   break;",
          "1775:      }",
          "1778:      if (!(src = cli_calloc (ssize + dsize, sizeof(char)))) {",
          "1779:          free(exe_sections);",
          "1780:   return CL_EMEM;",
          "1781:      }",
          "1783:      if((bytes = fmap_readn(map, src + dsize, exe_sections[i + 1].raw, exe_sections[i + 1].rsz)) != exe_sections[i + 1].rsz) {",
          "1784:   cli_dbgmsg(\"MEW: Can't read %d bytes [read: %lu]\\n\", exe_sections[i + 1].rsz, (unsigned long)bytes);",
          "1785:   free(exe_sections);",
          "1786:   free(src);",
          "1787:   return CL_EREAD;",
          "1788:      }",
          "1789:      cli_dbgmsg(\"MEW: %u (%08x) bytes read\\n\", (unsigned int)bytes, (unsigned int)bytes);",
          "1792:      if (tbuff[0x7b] == '\\xe8') {",
          "1793:          if (!CLI_ISCONTAINED(exe_sections[1].rva, exe_sections[1].vsz, cli_readint32(tbuff + 0x7c) + fileoffset + 0x80, 4)) {",
          "1794:       cli_dbgmsg(\"MEW: lzma proc out of bounds!\\n\");",
          "1795:       free(src);",
          "1797:   }",
          "1798:   uselzma = cli_readint32(tbuff + 0x7c) - (exe_sections[0].rva - fileoffset - 0x80);",
          "1799:      } else {",
          "1800:          uselzma = 0;",
          "1801:      }",
          "1804:         cli_jsonstr(pe_json, \"Packer\", \"MEW\");",
          "1807:      CLI_UNPTEMP(\"MEW\",(src,exe_sections,0));",
          "1808:      CLI_UNPRESULTS(\"MEW\",(unmew11(src, offdiff, ssize, dsize, EC32(optional_hdr32.ImageBase), exe_sections[0].rva, uselzma, ndesc)),1,(src,0));",
          "1809:      break;",
          "1810:  }",
          "1814:  free(exe_sections);",
          "1815:  return CL_CLEAN;",
          "1842:      ((",
          "1845:       )",
          "1846:      ||",
          "1850:       )",
          "1851:     ))",
          "1852:     ||",
          "1856:       )",
          "1857:      ||",
          "1860:       cli_readint32(epbuff + 1) - EC32(optional_hdr32.ImageBase) > 0 &&",
          "1862:       )",
          "1863:     ))",
          "1864:     ) {",
          "1865:      uint32_t vma, off;",
          "1866:      int a,b,c;",
          "1868:      cli_dbgmsg(\"Upack characteristics found.\\n\");",
          "1869:      a = exe_sections[0].vsz;",
          "1870:      b = exe_sections[1].vsz;",
          "1871:      if (upack) {",
          "1872:          cli_dbgmsg(\"Upack: var set\\n\");",
          "1873:   c = exe_sections[2].vsz;",
          "1874:   ssize = exe_sections[0].ursz + exe_sections[0].uraw;",
          "1875:   off = exe_sections[0].rva;",
          "1876:   vma = EC32(optional_hdr32.ImageBase) + exe_sections[0].rva;",
          "1877:      } else {",
          "1878:          cli_dbgmsg(\"Upack: var NOT set\\n\");",
          "1879:   c = exe_sections[1].rva;",
          "1880:   ssize = exe_sections[1].uraw;",
          "1881:   off = 0;",
          "1882:   vma = exe_sections[1].rva - exe_sections[1].uraw;",
          "1883:      }",
          "1885:      dsize = a+b+c;",
          "1887:      CLI_UNPSIZELIMITS(\"Upack\", MAX(MAX(dsize, ssize), exe_sections[1].ursz));",
          "1889:      if (!CLI_ISCONTAINED(0, dsize, exe_sections[1].rva - off, exe_sections[1].ursz) || (upack && !CLI_ISCONTAINED(0, dsize, exe_sections[2].rva - exe_sections[0].rva, ssize)) || ssize > dsize) {",
          "1890:          cli_dbgmsg(\"Upack: probably malformed pe-header, skipping to next unpacker\\n\");",
          "1891:   break;",
          "1892:      }",
          "1894:      if((dest = (char *) cli_calloc(dsize, sizeof(char))) == NULL) {",
          "1895:          free(exe_sections);",
          "1896:   return CL_EMEM;",
          "1897:      }",
          "1899:      if((unsigned int)fmap_readn(map, dest, 0, ssize) != ssize) {",
          "1900:          cli_dbgmsg(\"Upack: Can't read raw data of section 0\\n\");",
          "1901:   free(dest);",
          "1902:   break;",
          "1903:      }",
          "1905:      if(upack) memmove(dest + exe_sections[2].rva - exe_sections[0].rva, dest, ssize);",
          "1907:      if((unsigned int)fmap_readn(map, dest + exe_sections[1].rva - off, exe_sections[1].uraw, exe_sections[1].ursz) != exe_sections[1].ursz) {",
          "1908:   cli_dbgmsg(\"Upack: Can't read raw data of section 1\\n\");",
          "1909:   free(dest);",
          "1910:   break;",
          "1911:      }",
          "1914:         cli_jsonstr(pe_json, \"Packer\", \"Upack\");",
          "1917:      CLI_UNPTEMP(\"Upack\",(dest,exe_sections,0));",
          "1918:      CLI_UNPRESULTS(\"Upack\",(unupack(upack, dest, dsize, epbuff, vma, ep, EC32(optional_hdr32.ImageBase), exe_sections[0].rva, ndesc)),1,(dest,0));",
          "1919:      break;",
          "1920:  }",
          "1921:     }",
          "1925:  const char *dst;",
          "1929:  uint32_t newesi, newedi, newebx, newedx;",
          "1931:  ssize = exe_sections[i + 1].rsz;",
          "1932:  dsize = exe_sections[i].vsz;",
          "1934:  CLI_UNPSIZELIMITS(\"FSG\", MAX(dsize, ssize));",
          "1936:  if(ssize <= 0x19 || dsize <= ssize) {",
          "1937:      cli_dbgmsg(\"FSG: Size mismatch (ssize: %d, dsize: %d)\\n\", ssize, dsize);",
          "1938:      free(exe_sections);",
          "1939:      return CL_CLEAN;",
          "1940:  }",
          "1942:  newedx = cli_readint32(epbuff + 2) - EC32(optional_hdr32.ImageBase);",
          "1943:  if(!CLI_ISCONTAINED(exe_sections[i + 1].rva, exe_sections[i + 1].rsz, newedx, 4)) {",
          "1944:      cli_dbgmsg(\"FSG: xchg out of bounds (%x), giving up\\n\", newedx);",
          "1945:      break;",
          "1946:  }",
          "1948:  if(!exe_sections[i + 1].rsz || !(src = fmap_need_off_once(map, exe_sections[i + 1].raw, ssize))) {",
          "1949:      cli_dbgmsg(\"Can't read raw data of section %d\\n\", i + 1);",
          "1950:      free(exe_sections);",
          "1951:      return CL_ESEEK;",
          "1952:  }",
          "1954:  dst = src + newedx - exe_sections[i + 1].rva;",
          "1955:  if(newedx < exe_sections[i + 1].rva || !CLI_ISCONTAINED(src, ssize, dst, 4)) {",
          "1956:      cli_dbgmsg(\"FSG: New ESP out of bounds\\n\");",
          "1957:      break;",
          "1958:  }",
          "1960:  newedx = cli_readint32(dst) - EC32(optional_hdr32.ImageBase);",
          "1961:  if(!CLI_ISCONTAINED(exe_sections[i + 1].rva, exe_sections[i + 1].rsz, newedx, 4)) {",
          "1962:      cli_dbgmsg(\"FSG: New ESP (%x) is wrong\\n\", newedx);",
          "1963:      break;",
          "1964:  }",
          "1966:  dst = src + newedx - exe_sections[i + 1].rva;",
          "1967:  if(!CLI_ISCONTAINED(src, ssize, dst, 32)) {",
          "1968:      cli_dbgmsg(\"FSG: New stack out of bounds\\n\");",
          "1969:      break;",
          "1970:  }",
          "1972:  newedi = cli_readint32(dst) - EC32(optional_hdr32.ImageBase);",
          "1973:  newesi = cli_readint32(dst + 4) - EC32(optional_hdr32.ImageBase);",
          "1974:  newebx = cli_readint32(dst + 16) - EC32(optional_hdr32.ImageBase);",
          "1975:  newedx = cli_readint32(dst + 20);",
          "1977:  if(newedi != exe_sections[i].rva) {",
          "1978:      cli_dbgmsg(\"FSG: Bad destination buffer (edi is %x should be %x)\\n\", newedi, exe_sections[i].rva);",
          "1979:      break;",
          "1980:  }",
          "1982:  if(newesi < exe_sections[i + 1].rva || newesi - exe_sections[i + 1].rva >= exe_sections[i + 1].rsz) {",
          "1983:      cli_dbgmsg(\"FSG: Source buffer out of section bounds\\n\");",
          "1984:      break;",
          "1985:  }",
          "1987:  if(!CLI_ISCONTAINED(exe_sections[i + 1].rva, exe_sections[i + 1].rsz, newebx, 16)) {",
          "1988:      cli_dbgmsg(\"FSG: Array of functions out of bounds\\n\");",
          "1989:      break;",
          "1990:  }",
          "1992:  newedx=cli_readint32(newebx + 12 - exe_sections[i + 1].rva + src) - EC32(optional_hdr32.ImageBase);",
          "1993:  cli_dbgmsg(\"FSG: found old EP @%x\\n\",newedx);",
          "1995:  if((dest = (char *) cli_calloc(dsize, sizeof(char))) == NULL) {",
          "1996:      free(exe_sections);",
          "1997:      return CL_EMEM;",
          "1998:  }",
          "2001:     cli_jsonstr(pe_json, \"Packer\", \"FSG\");",
          "2004:  CLI_UNPTEMP(\"FSG\",(dest,exe_sections,0));",
          "2005:  CLI_UNPRESULTSFSG2(\"FSG\",(unfsg_200(newesi - exe_sections[i + 1].rva + src, dest, ssize + exe_sections[i + 1].rva - newesi, dsize, newedi, EC32(optional_hdr32.ImageBase), newedx, ndesc)),1,(dest,0));",
          "2006:  break;",
          "2014:  int sectcnt = 0;",
          "2015:  const char *support;",
          "2016:  uint32_t newesi, newedi, oldep, gp, t;",
          "2017:  struct cli_exe_section *sections;",
          "2019:  ssize = exe_sections[i + 1].rsz;",
          "2020:  dsize = exe_sections[i].vsz;",
          "2022:  CLI_UNPSIZELIMITS(\"FSG\", MAX(dsize, ssize));",
          "2024:  if(ssize <= 0x19 || dsize <= ssize) {",
          "2025:      cli_dbgmsg(\"FSG: Size mismatch (ssize: %d, dsize: %d)\\n\", ssize, dsize);",
          "2026:      free(exe_sections);",
          "2027:      return CL_CLEAN;",
          "2028:  }",
          "2030:  if(!(t = cli_rawaddr(cli_readint32(epbuff + 1) - EC32(optional_hdr32.ImageBase), NULL, 0 , &err, fsize, hdr_size)) && err ) {",
          "2031:      cli_dbgmsg(\"FSG: Support data out of padding area\\n\");",
          "2032:      break;",
          "2033:  }",
          "2035:  gp = exe_sections[i + 1].raw - t;",
          "2037:  CLI_UNPSIZELIMITS(\"FSG\", gp);",
          "2039:  if(!(support = fmap_need_off_once(map, t, gp))) {",
          "2040:      cli_dbgmsg(\"Can't read %d bytes from padding area\\n\", gp);",
          "2041:      free(exe_sections);",
          "2042:      return CL_EREAD;",
          "2043:  }",
          "2049:  if(newesi < exe_sections[i + 1].rva || newesi - exe_sections[i + 1].rva >= exe_sections[i + 1].rsz) {",
          "2050:      cli_dbgmsg(\"FSG: Source buffer out of section bounds\\n\");",
          "2051:      break;",
          "2052:  }",
          "2054:  if(newedi != exe_sections[i].rva) {",
          "2055:      cli_dbgmsg(\"FSG: Bad destination (is %x should be %x)\\n\", newedi, exe_sections[i].rva);",
          "2056:      break;",
          "2057:  }",
          "2060:  for(t = 12; t < gp - 4; t += 4) {",
          "2061:      uint32_t rva = cli_readint32(support+t);",
          "2063:      if(!rva)",
          "2064:   break;",
          "2066:      rva -= EC32(optional_hdr32.ImageBase)+1;",
          "2067:      sectcnt++;",
          "2069:      if(rva % 0x1000) cli_dbgmsg(\"FSG: Original section %d is misaligned\\n\", sectcnt);",
          "2071:      if(rva < exe_sections[i].rva || rva - exe_sections[i].rva >= exe_sections[i].vsz) {",
          "2072:   cli_dbgmsg(\"FSG: Original section %d is out of bounds\\n\", sectcnt);",
          "2073:   break;",
          "2074:      }",
          "2075:  }",
          "2077:  if(t >= gp - 4 || cli_readint32(support + t)) {",
          "2078:      break;",
          "2079:  }",
          "2081:  if((sections = (struct cli_exe_section *) cli_malloc((sectcnt + 1) * sizeof(struct cli_exe_section))) == NULL) {",
          "2082:         cli_errmsg(\"FSG: Unable to allocate memory for sections %lu\\n\", (sectcnt + 1) * sizeof(struct cli_exe_section));",
          "2083:      free(exe_sections);",
          "2084:      return CL_EMEM;",
          "2085:  }",
          "2087:  sections[0].rva = newedi;",
          "2088:  for(t = 1; t <= (uint32_t)sectcnt; t++)",
          "2089:      sections[t].rva = cli_readint32(support + 8 + t * 4) - 1 - EC32(optional_hdr32.ImageBase);",
          "2091:  if(!exe_sections[i + 1].rsz || !(src = fmap_need_off_once(map, exe_sections[i + 1].raw, ssize))) {",
          "2092:      cli_dbgmsg(\"Can't read raw data of section %d\\n\", i);",
          "2093:      free(exe_sections);",
          "2094:      free(sections);",
          "2095:      return CL_EREAD;",
          "2096:  }",
          "2098:  if((dest = (char *) cli_calloc(dsize, sizeof(char))) == NULL) {",
          "2099:      free(exe_sections);",
          "2100:      free(sections);",
          "2101:      return CL_EMEM;",
          "2102:  }",
          "2104:  oldep = vep + 161 + 6 + cli_readint32(epbuff+163);",
          "2105:  cli_dbgmsg(\"FSG: found old EP @%x\\n\", oldep);",
          "2108:     cli_jsonstr(pe_json, \"Packer\", \"FSG\");",
          "2111:  CLI_UNPTEMP(\"FSG\",(dest,sections,exe_sections,0));",
          "2112:  CLI_UNPRESULTSFSG1(\"FSG\",(unfsg_133(src + newesi - exe_sections[i + 1].rva, dest, ssize + exe_sections[i + 1].rva - newesi, dsize, sections, sectcnt, EC32(optional_hdr32.ImageBase), oldep, ndesc)),1,(dest,sections,0));",
          "2121:  int sectcnt = 0;",
          "2122:  uint32_t gp, t = cli_rawaddr(cli_readint32(epbuff+1) - EC32(optional_hdr32.ImageBase), NULL, 0 , &err, fsize, hdr_size);",
          "2123:  const char *support;",
          "2124:  uint32_t newesi = cli_readint32(epbuff+11) - EC32(optional_hdr32.ImageBase);",
          "2125:  uint32_t newedi = cli_readint32(epbuff+6) - EC32(optional_hdr32.ImageBase);",
          "2126:  uint32_t oldep = vep - exe_sections[i + 1].rva;",
          "2127:  struct cli_exe_section *sections;",
          "2129:  ssize = exe_sections[i + 1].rsz;",
          "2130:  dsize = exe_sections[i].vsz;",
          "2132:  if(err) {",
          "2133:      cli_dbgmsg(\"FSG: Support data out of padding area\\n\");",
          "2134:      break;",
          "2135:  }",
          "2137:  if(newesi < exe_sections[i + 1].rva || newesi - exe_sections[i + 1].rva >= exe_sections[i + 1].raw) {",
          "2138:      cli_dbgmsg(\"FSG: Source buffer out of section bounds\\n\");",
          "2139:      break;",
          "2140:  }",
          "2142:  if(newedi != exe_sections[i].rva) {",
          "2143:      cli_dbgmsg(\"FSG: Bad destination (is %x should be %x)\\n\", newedi, exe_sections[i].rva);",
          "2144:      break;",
          "2145:  }",
          "2147:  CLI_UNPSIZELIMITS(\"FSG\", MAX(dsize, ssize));",
          "2149:  if(ssize <= 0x19 || dsize <= ssize) {",
          "2150:      cli_dbgmsg(\"FSG: Size mismatch (ssize: %d, dsize: %d)\\n\", ssize, dsize);",
          "2151:      free(exe_sections);",
          "2152:      return CL_CLEAN;",
          "2153:  }",
          "2155:  gp = exe_sections[i + 1].raw - t;",
          "2157:  CLI_UNPSIZELIMITS(\"FSG\", gp)",
          "2159:  if(!(support = fmap_need_off_once(map, t, gp))) {",
          "2160:      cli_dbgmsg(\"Can't read %d bytes from padding area\\n\", gp);",
          "2161:      free(exe_sections);",
          "2162:      return CL_EREAD;",
          "2163:  }",
          "2166:  for(t = 0; t < gp - 2; t += 2) {",
          "2167:      uint32_t rva = support[t]|(support[t+1]<<8);",
          "2169:      if (rva == 2 || rva == 1)",
          "2170:   break;",
          "2172:      rva = ((rva-2)<<12) - EC32(optional_hdr32.ImageBase);",
          "2173:      sectcnt++;",
          "2175:      if(rva < exe_sections[i].rva || rva - exe_sections[i].rva >= exe_sections[i].vsz) {",
          "2176:   cli_dbgmsg(\"FSG: Original section %d is out of bounds\\n\", sectcnt);",
          "2177:   break;",
          "2178:      }",
          "2179:  }",
          "2181:  if(t >= gp-10 || cli_readint32(support + t + 6) != 2) {",
          "2182:      break;",
          "2183:  }",
          "2185:  if((sections = (struct cli_exe_section *) cli_malloc((sectcnt + 1) * sizeof(struct cli_exe_section))) == NULL) {",
          "2186:         cli_errmsg(\"FSG: Unable to allocate memory for sections %lu\\n\", (sectcnt + 1) * sizeof(struct cli_exe_section));",
          "2187:      free(exe_sections);",
          "2188:      return CL_EMEM;",
          "2189:  }",
          "2191:  sections[0].rva = newedi;",
          "2192:  for(t = 0; t <= (uint32_t)sectcnt - 1; t++) {",
          "2193:      sections[t+1].rva = (((support[t*2]|(support[t*2+1]<<8))-2)<<12)-EC32(optional_hdr32.ImageBase);",
          "2194:  }",
          "2196:  if(!exe_sections[i + 1].rsz || !(src = fmap_need_off_once(map, exe_sections[i + 1].raw, ssize))) {",
          "2197:      cli_dbgmsg(\"FSG: Can't read raw data of section %d\\n\", i);",
          "2198:      free(exe_sections);",
          "2199:      free(sections);",
          "2200:      return CL_EREAD;",
          "2201:  }",
          "2203:  if((dest = (char *) cli_calloc(dsize, sizeof(char))) == NULL) {",
          "2204:      free(exe_sections);",
          "2205:      free(sections);",
          "2206:      return CL_EMEM;",
          "2207:  }",
          "2209:  gp = 0xda + 6*(epbuff[16]=='\\xe8');",
          "2210:  oldep = vep + gp + 6 + cli_readint32(src+gp+2+oldep);",
          "2211:  cli_dbgmsg(\"FSG: found old EP @%x\\n\", oldep);",
          "2214:     cli_jsonstr(pe_json, \"Packer\", \"FSG\");",
          "2217:  CLI_UNPTEMP(\"FSG\",(dest,sections,exe_sections,0));",
          "2218:  CLI_UNPRESULTSFSG1(\"FSG\",(unfsg_133(src + newesi - exe_sections[i + 1].rva, dest, ssize + exe_sections[i + 1].rva - newesi, dsize, sections, sectcnt, EC32(optional_hdr32.ImageBase), oldep, ndesc)),1,(dest,sections,0));",
          "2228:  ssize = exe_sections[i + 1].rsz;",
          "2229:  dsize = exe_sections[i].vsz + exe_sections[i + 1].vsz;",
          "2233:  CLI_UNPSIZELIMITS(\"UPX\", MAX(dsize, ssize));",
          "2235:  if(ssize <= 0x19 || dsize <= ssize || dsize > CLI_MAX_ALLOCATION ) {",
          "2236:      cli_dbgmsg(\"UPX: Size mismatch or dsize too big (ssize: %d, dsize: %d)\\n\", ssize, dsize);",
          "2237:      free(exe_sections);",
          "2238:      return CL_CLEAN;",
          "2239:  }",
          "2241:  if(!exe_sections[i + 1].rsz || !(src = fmap_need_off_once(map, exe_sections[i + 1].raw, ssize))) {",
          "2242:      cli_dbgmsg(\"UPX: Can't read raw data of section %d\\n\", i+1);",
          "2243:      free(exe_sections);",
          "2244:      return CL_EREAD;",
          "2245:  }",
          "2247:  if((dest = (char *) cli_calloc(dsize + 8192, sizeof(char))) == NULL) {",
          "2248:      free(exe_sections);",
          "2249:      return CL_EMEM;",
          "2250:  }",
          "2253:  if(cli_memstr(UPX_NRV2B, 24, epbuff + 0x69, 13) || cli_memstr(UPX_NRV2B, 24, epbuff + 0x69 + 8, 13)) {",
          "2254:      cli_dbgmsg(\"UPX: Looks like a NRV2B decompression routine\\n\");",
          "2255:      upxfn = upx_inflate2b;",
          "2256:  } else if(cli_memstr(UPX_NRV2D, 24, epbuff + 0x69, 13) || cli_memstr(UPX_NRV2D, 24, epbuff + 0x69 + 8, 13)) {",
          "2257:      cli_dbgmsg(\"UPX: Looks like a NRV2D decompression routine\\n\");",
          "2258:      upxfn = upx_inflate2d;",
          "2259:  } else if(cli_memstr(UPX_NRV2E, 24, epbuff + 0x69, 13) || cli_memstr(UPX_NRV2E, 24, epbuff + 0x69 + 8, 13)) {",
          "2260:      cli_dbgmsg(\"UPX: Looks like a NRV2E decompression routine\\n\");",
          "2261:      upxfn = upx_inflate2e;",
          "2262:  }",
          "2264:  if(upxfn) {",
          "2265:      int skew = cli_readint32(epbuff + 2) - EC32(optional_hdr32.ImageBase) - exe_sections[i + 1].rva;",
          "2268:   skew = 0;",
          "2269:      } else if ((unsigned int)skew > ssize) {",
          "2271:   skew = 0;",
          "2272:      } else {",
          "2273:   cli_dbgmsg(\"UPX: UPX1 seems skewed by %d bytes\\n\", skew);",
          "2274:      }",
          "2277:      if(upxfn(src + skew, ssize - skew, dest, &dsize, exe_sections[i].rva, exe_sections[i + 1].rva, vep-skew) >= 0) {",
          "2278:   upx_success = 1;",
          "2279:      }",
          "2281:      else if(skew && (upxfn(src, ssize, dest, &dsize, exe_sections[i].rva, exe_sections[i + 1].rva, vep) >= 0)) {",
          "2282:   upx_success = 1;",
          "2283:      }",
          "2285:      if(upx_success)",
          "2286:   cli_dbgmsg(\"UPX: Successfully decompressed\\n\");",
          "2287:      else",
          "2288:   cli_dbgmsg(\"UPX: Preferred decompressor failed\\n\");",
          "2289:  }",
          "2291:  if(!upx_success && upxfn != upx_inflate2b) {",
          "2292:      if(upx_inflate2b(src, ssize, dest, &dsize, exe_sections[i].rva, exe_sections[i + 1].rva, vep) == -1 && upx_inflate2b(src + 0x15, ssize - 0x15, dest, &dsize, exe_sections[i].rva, exe_sections[i + 1].rva, vep - 0x15) == -1) {",
          "2294:   cli_dbgmsg(\"UPX: NRV2B decompressor failed\\n\");",
          "2295:      } else {",
          "2296:   upx_success = 1;",
          "2297:   cli_dbgmsg(\"UPX: Successfully decompressed with NRV2B\\n\");",
          "2298:      }",
          "2299:  }",
          "2301:  if(!upx_success && upxfn != upx_inflate2d) {",
          "2302:      if(upx_inflate2d(src, ssize, dest, &dsize, exe_sections[i].rva, exe_sections[i + 1].rva, vep) == -1 && upx_inflate2d(src + 0x15, ssize - 0x15, dest, &dsize, exe_sections[i].rva, exe_sections[i + 1].rva, vep - 0x15) == -1) {",
          "2304:   cli_dbgmsg(\"UPX: NRV2D decompressor failed\\n\");",
          "2305:      } else {",
          "2306:   upx_success = 1;",
          "2307:   cli_dbgmsg(\"UPX: Successfully decompressed with NRV2D\\n\");",
          "2308:      }",
          "2309:  }",
          "2311:  if(!upx_success && upxfn != upx_inflate2e) {",
          "2312:      if(upx_inflate2e(src, ssize, dest, &dsize, exe_sections[i].rva, exe_sections[i + 1].rva, vep) == -1 && upx_inflate2e(src + 0x15, ssize - 0x15, dest, &dsize, exe_sections[i].rva, exe_sections[i + 1].rva, vep - 0x15) == -1) {",
          "2313:   cli_dbgmsg(\"UPX: NRV2E decompressor failed\\n\");",
          "2314:      } else {",
          "2315:   upx_success = 1;",
          "2316:   cli_dbgmsg(\"UPX: Successfully decompressed with NRV2E\\n\");",
          "2317:      }",
          "2318:  }",
          "2320:  if(cli_memstr(UPX_LZMA2, 20, epbuff + 0x2f, 20)) {",
          "2321:      uint32_t strictdsize=cli_readint32(epbuff+0x21), skew = 0;",
          "2322:      if(ssize > 0x15 && epbuff[0] == '\\x60' && epbuff[1] == '\\xbe') {",
          "2323:   skew = cli_readint32(epbuff+2) - exe_sections[i + 1].rva - optional_hdr32.ImageBase;",
          "2324:   if(skew!=0x15) skew = 0;",
          "2325:      }",
          "2326:      if(strictdsize<=dsize)",
          "2327:   upx_success = upx_inflatelzma(src+skew, ssize-skew, dest, &strictdsize, exe_sections[i].rva, exe_sections[i + 1].rva, vep) >=0;",
          "2328:  } else if (cli_memstr(UPX_LZMA1, 20, epbuff + 0x39, 20)) {",
          "2329:      uint32_t strictdsize=cli_readint32(epbuff+0x2b), skew = 0;",
          "2330:      if(ssize > 0x15 && epbuff[0] == '\\x60' && epbuff[1] == '\\xbe') {",
          "2331:   skew = cli_readint32(epbuff+2) - exe_sections[i + 1].rva - optional_hdr32.ImageBase;",
          "2332:   if(skew!=0x15) skew = 0;",
          "2333:      }",
          "2334:      if(strictdsize<=dsize)",
          "2335:   upx_success = upx_inflatelzma(src+skew, ssize-skew, dest, &strictdsize, exe_sections[i].rva, exe_sections[i + 1].rva, vep) >=0;",
          "2336:  }",
          "2338:  if(!upx_success) {",
          "2339:      cli_dbgmsg(\"UPX: All decompressors failed\\n\");",
          "2340:      free(dest);",
          "2341:  }",
          "2345:  free(exe_sections);",
          "2347:  CLI_UNPTEMP(\"UPX/FSG\",(dest,0));",
          "2349:     cli_jsonstr(pe_json, \"Packer\", \"UPX\");",
          "2352:  if((unsigned int) write(ndesc, dest, dsize) != dsize) {",
          "2353:      cli_dbgmsg(\"UPX/FSG: Can't write %d bytes\\n\", dsize);",
          "2354:      free(tempfile);",
          "2355:      free(dest);",
          "2356:      close(ndesc);",
          "2357:      return CL_EWRITE;",
          "2358:  }",
          "2360:  free(dest);",
          "2361:  if (lseek(ndesc, 0, SEEK_SET) == -1) {",
          "2362:         cli_dbgmsg(\"UPX/FSG: lseek() failed\\n\");",
          "2366:         SHA_RESET;",
          "2367:         return CL_ESEEK;",
          "2368:     }",
          "2370:  if(ctx->engine->keeptmp)",
          "2371:      cli_dbgmsg(\"UPX/FSG: Decompressed data saved in %s\\n\", tempfile);",
          "2373:  cli_dbgmsg(\"***** Scanning decompressed file *****\\n\");",
          "2374:  SHA_OFF;",
          "2375:  if((ret = cli_magic_scandesc(ndesc, ctx)) == CL_VIRUS) {",
          "2376:      close(ndesc);",
          "2377:      CLI_TMPUNLK();",
          "2378:      free(tempfile);",
          "2379:      SHA_RESET;",
          "2380:      return CL_VIRUS;",
          "2381:  }",
          "2383:  SHA_RESET;",
          "2384:  close(ndesc);",
          "2385:  CLI_TMPUNLK();",
          "2386:  free(tempfile);",
          "2387:  return ret;",
          "2394:  free(exe_sections);",
          "2395:  return CL_CLEAN;",
          "2401:  if(nsections < 2 || epbuff[0] != '\\xb8' || (uint32_t) cli_readint32(epbuff + 1) != exe_sections[nsections - 2].rva + EC32(optional_hdr32.ImageBase))",
          "2402:      found = 0;",
          "2403:  else",
          "2404:      found = 1;",
          "2408:  cli_dbgmsg(\"Petite: v2.%d compression detected\\n\", found);",
          "2410:  if(cli_readint32(epbuff + 0x80) == 0x163c988d) {",
          "2411:      cli_dbgmsg(\"Petite: level zero compression is not supported yet\\n\");",
          "2412:  } else {",
          "2413:      dsize = max - min;",
          "2415:      CLI_UNPSIZELIMITS(\"Petite\", dsize);",
          "2417:      if((dest = (char *) cli_calloc(dsize, sizeof(char))) == NULL) {",
          "2418:   cli_dbgmsg(\"Petite: Can't allocate %d bytes\\n\", dsize);",
          "2419:   free(exe_sections);",
          "2420:   return CL_EMEM;",
          "2421:      }",
          "2423:      for(i = 0 ; i < nsections; i++) {",
          "2424:   if(exe_sections[i].raw) {",
          "2425:       if(!exe_sections[i].rsz || (unsigned int)fmap_readn(map, dest + exe_sections[i].rva - min, exe_sections[i].raw, exe_sections[i].ursz) != exe_sections[i].ursz) {",
          "2426:    free(exe_sections);",
          "2427:    free(dest);",
          "2428:    return CL_CLEAN;",
          "2429:       }",
          "2430:   }",
          "2431:      }",
          "2434:         cli_jsonstr(pe_json, \"Packer\", \"Petite\");",
          "2437:      CLI_UNPTEMP(\"Petite\",(dest,exe_sections,0));",
          "2438:      CLI_UNPRESULTS(\"Petite\",(petite_inflate2x_1to9(dest, min, max - min, exe_sections, nsections - (found == 1 ? 1 : 0), EC32(optional_hdr32.ImageBase),vep, ndesc, found, EC32(optional_hdr32.DataDirectory[2].VirtualAddress),EC32(optional_hdr32.DataDirectory[2].Size))),0,(dest,0));",
          "2439:  }",
          "",
          "[Added Lines]",
          "1800:         for(i = 0; i < (unsigned int) nsections - 1; i++) {",
          "1801:             if(!exe_sections[i].rsz && exe_sections[i].vsz && exe_sections[i + 1].rsz && exe_sections[i + 1].vsz) {",
          "1802:                 found = 1;",
          "1803:                 cli_dbgmsg(\"UPX/FSG/MEW: empty section found - assuming compression\\n\");",
          "1805:                 cli_jsonbool(pe_json, \"HasEmptySection\", 1);",
          "1807:                 break;",
          "1808:             }",
          "1809:         }",
          "1814:         uint32_t fileoffset;",
          "1815:         const char *tbuff;",
          "1817:         fileoffset = (vep + cli_readint32(epbuff + 1) + 5);",
          "1818:         while (fileoffset == 0x154 || fileoffset == 0x158) {",
          "1819:             char *src;",
          "1820:             uint32_t offdiff, uselzma;",
          "1822:             cli_dbgmsg (\"MEW: found MEW characteristics %08X + %08X + 5 = %08X\\n\",",
          "1823:                 cli_readint32(epbuff + 1), vep, cli_readint32(epbuff + 1) + vep + 5);",
          "1825:             if(!(tbuff = fmap_need_off_once(map, fileoffset, 0xb0)))",
          "1826:                 break;",
          "1828:             if (fileoffset == 0x154)",
          "1829:                 cli_dbgmsg(\"MEW: Win9x compatibility was set!\\n\");",
          "1830:             else",
          "1831:                 cli_dbgmsg(\"MEW: Win9x compatibility was NOT set!\\n\");",
          "1833:             if((offdiff = cli_readint32(tbuff+1) - EC32(optional_hdr32.ImageBase)) <= exe_sections[i + 1].rva || offdiff >= exe_sections[i + 1].rva + exe_sections[i + 1].raw - 4) {",
          "1834:                 cli_dbgmsg(\"MEW: ESI is not in proper section\\n\");",
          "1835:                 break;",
          "1836:             }",
          "1838:             offdiff -= exe_sections[i + 1].rva;",
          "1840:             if(!exe_sections[i + 1].rsz) {",
          "1841:                 cli_dbgmsg(\"MEW: mew section is empty\\n\");",
          "1842:                 break;",
          "1843:             }",
          "1845:             ssize = exe_sections[i + 1].vsz;",
          "1846:             dsize = exe_sections[i].vsz;",
          "1848:             cli_dbgmsg(\"MEW: ssize %08x dsize %08x offdiff: %08x\\n\", ssize, dsize, offdiff);",
          "1850:             CLI_UNPSIZELIMITS(\"MEW\", MAX(ssize, dsize));",
          "1851:             CLI_UNPSIZELIMITS(\"MEW\", MAX(ssize + dsize, exe_sections[i + 1].rsz));",
          "1853:             if (exe_sections[i + 1].rsz < offdiff + 12 || exe_sections[i + 1].rsz > ssize) {",
          "1854:                 cli_dbgmsg(\"MEW: Size mismatch: %08x\\n\", exe_sections[i + 1].rsz);",
          "1855:                 break;",
          "1856:             }",
          "1859:             if (!(src = cli_calloc (ssize + dsize, sizeof(char)))) {",
          "1860:                 free(exe_sections);",
          "1861:                 return CL_EMEM;",
          "1862:             }",
          "1864:             if((bytes = fmap_readn(map, src + dsize, exe_sections[i + 1].raw, exe_sections[i + 1].rsz)) != exe_sections[i + 1].rsz) {",
          "1865:                 cli_dbgmsg(\"MEW: Can't read %d bytes [read: %lu]\\n\", exe_sections[i + 1].rsz, (unsigned long)bytes);",
          "1866:                 free(exe_sections);",
          "1867:                 free(src);",
          "1868:                 return CL_EREAD;",
          "1869:             }",
          "1871:             cli_dbgmsg(\"MEW: %u (%08x) bytes read\\n\", (unsigned int)bytes, (unsigned int)bytes);",
          "1874:             if (tbuff[0x7b] == '\\xe8') {",
          "1875:                 if (!CLI_ISCONTAINED(exe_sections[1].rva, exe_sections[1].vsz, cli_readint32(tbuff + 0x7c) + fileoffset + 0x80, 4)) {",
          "1876:                     cli_dbgmsg(\"MEW: lzma proc out of bounds!\\n\");",
          "1877:                     free(src);",
          "1879:                 }",
          "1881:                 uselzma = cli_readint32(tbuff + 0x7c) - (exe_sections[0].rva - fileoffset - 0x80);",
          "1882:             } else {",
          "1883:                 uselzma = 0;",
          "1884:             }",
          "1887:             cli_jsonstr(pe_json, \"Packer\", \"MEW\");",
          "1890:             CLI_UNPTEMP(\"MEW\",(src,exe_sections,0));",
          "1891:             CLI_UNPRESULTS(\"MEW\",(unmew11(src, offdiff, ssize, dsize, EC32(optional_hdr32.ImageBase), exe_sections[0].rva, uselzma, ndesc)),1,(src,0));",
          "1892:             break;",
          "1893:         }",
          "1897:         free(exe_sections);",
          "1898:         return CL_CLEAN;",
          "1925:             ((",
          "1928:              )",
          "1929:             ||",
          "1933:              )",
          "1934:            ))",
          "1935:            ||",
          "1939:              )",
          "1940:             ||",
          "1943:              cli_readint32(epbuff + 1) - EC32(optional_hdr32.ImageBase) > 0 &&",
          "1945:              )",
          "1946:            ))",
          "1947:            ) {",
          "1948:             uint32_t vma, off;",
          "1949:             int a,b,c;",
          "1951:             cli_dbgmsg(\"Upack characteristics found.\\n\");",
          "1952:             a = exe_sections[0].vsz;",
          "1953:             b = exe_sections[1].vsz;",
          "1954:             if (upack) {",
          "1955:                 cli_dbgmsg(\"Upack: var set\\n\");",
          "1957:                 c = exe_sections[2].vsz;",
          "1958:                 ssize = exe_sections[0].ursz + exe_sections[0].uraw;",
          "1959:                 off = exe_sections[0].rva;",
          "1960:                 vma = EC32(optional_hdr32.ImageBase) + exe_sections[0].rva;",
          "1961:             } else {",
          "1962:                 cli_dbgmsg(\"Upack: var NOT set\\n\");",
          "1963:                 c = exe_sections[1].rva;",
          "1964:                 ssize = exe_sections[1].uraw;",
          "1965:                 off = 0;",
          "1966:                 vma = exe_sections[1].rva - exe_sections[1].uraw;",
          "1967:             }",
          "1969:             dsize = a+b+c;",
          "1971:             CLI_UNPSIZELIMITS(\"Upack\", MAX(MAX(dsize, ssize), exe_sections[1].ursz));",
          "1973:             if (!CLI_ISCONTAINED(0, dsize, exe_sections[1].rva - off, exe_sections[1].ursz) || (upack && !CLI_ISCONTAINED(0, dsize, exe_sections[2].rva - exe_sections[0].rva, ssize)) || ssize > dsize) {",
          "1974:                 cli_dbgmsg(\"Upack: probably malformed pe-header, skipping to next unpacker\\n\");",
          "1975:                 break;",
          "1976:             }",
          "1978:             if((dest = (char *) cli_calloc(dsize, sizeof(char))) == NULL) {",
          "1979:                 free(exe_sections);",
          "1980:                 return CL_EMEM;",
          "1981:             }",
          "1983:             if((unsigned int)fmap_readn(map, dest, 0, ssize) != ssize) {",
          "1984:                 cli_dbgmsg(\"Upack: Can't read raw data of section 0\\n\");",
          "1985:                 free(dest);",
          "1986:                 break;",
          "1987:             }",
          "1989:             if(upack)",
          "1990:                 memmove(dest + exe_sections[2].rva - exe_sections[0].rva, dest, ssize);",
          "1992:             if((unsigned int)fmap_readn(map, dest + exe_sections[1].rva - off, exe_sections[1].uraw, exe_sections[1].ursz) != exe_sections[1].ursz) {",
          "1993:                 cli_dbgmsg(\"Upack: Can't read raw data of section 1\\n\");",
          "1994:                 free(dest);",
          "1995:                 break;",
          "1996:             }",
          "1999:             cli_jsonstr(pe_json, \"Packer\", \"Upack\");",
          "2002:             CLI_UNPTEMP(\"Upack\",(dest,exe_sections,0));",
          "2003:             CLI_UNPRESULTS(\"Upack\",(unupack(upack, dest, dsize, epbuff, vma, ep, EC32(optional_hdr32.ImageBase), exe_sections[0].rva, ndesc)),1,(dest,0));",
          "2005:             break;",
          "2006:         }",
          "2007:     }",
          "2010:         const char *dst;",
          "2011:         uint32_t newesi, newedi, newebx, newedx;",
          "2015:         ssize = exe_sections[i + 1].rsz;",
          "2016:         dsize = exe_sections[i].vsz;",
          "2018:         CLI_UNPSIZELIMITS(\"FSG\", MAX(dsize, ssize));",
          "2020:         if(ssize <= 0x19 || dsize <= ssize) {",
          "2021:             cli_dbgmsg(\"FSG: Size mismatch (ssize: %d, dsize: %d)\\n\", ssize, dsize);",
          "2022:             free(exe_sections);",
          "2023:             return CL_CLEAN;",
          "2024:         }",
          "2026:         newedx = cli_readint32(epbuff + 2) - EC32(optional_hdr32.ImageBase);",
          "2027:         if(!CLI_ISCONTAINED(exe_sections[i + 1].rva, exe_sections[i + 1].rsz, newedx, 4)) {",
          "2028:             cli_dbgmsg(\"FSG: xchg out of bounds (%x), giving up\\n\", newedx);",
          "2029:             break;",
          "2030:         }",
          "2032:         if(!exe_sections[i + 1].rsz || !(src = fmap_need_off_once(map, exe_sections[i + 1].raw, ssize))) {",
          "2033:             cli_dbgmsg(\"Can't read raw data of section %d\\n\", i + 1);",
          "2034:             free(exe_sections);",
          "2035:             return CL_ESEEK;",
          "2036:         }",
          "2038:         dst = src + newedx - exe_sections[i + 1].rva;",
          "2039:         if(newedx < exe_sections[i + 1].rva || !CLI_ISCONTAINED(src, ssize, dst, 4)) {",
          "2040:             cli_dbgmsg(\"FSG: New ESP out of bounds\\n\");",
          "2041:             break;",
          "2042:         }",
          "2044:         newedx = cli_readint32(dst) - EC32(optional_hdr32.ImageBase);",
          "2045:         if(!CLI_ISCONTAINED(exe_sections[i + 1].rva, exe_sections[i + 1].rsz, newedx, 4)) {",
          "2046:             cli_dbgmsg(\"FSG: New ESP (%x) is wrong\\n\", newedx);",
          "2047:             break;",
          "2048:         }",
          "2050:         dst = src + newedx - exe_sections[i + 1].rva;",
          "2051:         if(!CLI_ISCONTAINED(src, ssize, dst, 32)) {",
          "2052:             cli_dbgmsg(\"FSG: New stack out of bounds\\n\");",
          "2053:             break;",
          "2054:         }",
          "2056:         newedi = cli_readint32(dst) - EC32(optional_hdr32.ImageBase);",
          "2057:         newesi = cli_readint32(dst + 4) - EC32(optional_hdr32.ImageBase);",
          "2058:         newebx = cli_readint32(dst + 16) - EC32(optional_hdr32.ImageBase);",
          "2059:         newedx = cli_readint32(dst + 20);",
          "2061:         if(newedi != exe_sections[i].rva) {",
          "2062:             cli_dbgmsg(\"FSG: Bad destination buffer (edi is %x should be %x)\\n\", newedi, exe_sections[i].rva);",
          "2063:             break;",
          "2064:         }",
          "2066:         if(newesi < exe_sections[i + 1].rva || newesi - exe_sections[i + 1].rva >= exe_sections[i + 1].rsz) {",
          "2067:             cli_dbgmsg(\"FSG: Source buffer out of section bounds\\n\");",
          "2068:             break;",
          "2069:         }",
          "2071:         if(!CLI_ISCONTAINED(exe_sections[i + 1].rva, exe_sections[i + 1].rsz, newebx, 16)) {",
          "2072:             cli_dbgmsg(\"FSG: Array of functions out of bounds\\n\");",
          "2073:             break;",
          "2074:         }",
          "2076:         newedx=cli_readint32(newebx + 12 - exe_sections[i + 1].rva + src) - EC32(optional_hdr32.ImageBase);",
          "2077:         cli_dbgmsg(\"FSG: found old EP @%x\\n\",newedx);",
          "2079:         if((dest = (char *) cli_calloc(dsize, sizeof(char))) == NULL) {",
          "2080:             free(exe_sections);",
          "2081:             return CL_EMEM;",
          "2082:         }",
          "2085:         cli_jsonstr(pe_json, \"Packer\", \"FSG\");",
          "2088:         CLI_UNPTEMP(\"FSG\",(dest,exe_sections,0));",
          "2089:         CLI_UNPRESULTSFSG2(\"FSG\",(unfsg_200(newesi - exe_sections[i + 1].rva + src, dest, ssize + exe_sections[i + 1].rva - newesi, dsize, newedi, EC32(optional_hdr32.ImageBase), newedx, ndesc)),1,(dest,0));",
          "2090:         break;",
          "2095:         int sectcnt = 0;",
          "2096:         const char *support;",
          "2097:         uint32_t newesi, newedi, oldep, gp, t;",
          "2098:         struct cli_exe_section *sections;",
          "2102:         ssize = exe_sections[i + 1].rsz;",
          "2103:         dsize = exe_sections[i].vsz;",
          "2105:         CLI_UNPSIZELIMITS(\"FSG\", MAX(dsize, ssize));",
          "2107:         if(ssize <= 0x19 || dsize <= ssize) {",
          "2108:             cli_dbgmsg(\"FSG: Size mismatch (ssize: %d, dsize: %d)\\n\", ssize, dsize);",
          "2109:             free(exe_sections);",
          "2110:             return CL_CLEAN;",
          "2111:         }",
          "2113:         if(!(t = cli_rawaddr(cli_readint32(epbuff + 1) - EC32(optional_hdr32.ImageBase), NULL, 0 , &err, fsize, hdr_size)) && err ) {",
          "2114:             cli_dbgmsg(\"FSG: Support data out of padding area\\n\");",
          "2115:             break;",
          "2116:         }",
          "2118:         gp = exe_sections[i + 1].raw - t;",
          "2120:         CLI_UNPSIZELIMITS(\"FSG\", gp);",
          "2122:         if(!(support = fmap_need_off_once(map, t, gp))) {",
          "2123:             cli_dbgmsg(\"Can't read %d bytes from padding area\\n\", gp);",
          "2124:             free(exe_sections);",
          "2125:             return CL_EREAD;",
          "2126:         }",
          "2132:         if(newesi < exe_sections[i + 1].rva || newesi - exe_sections[i + 1].rva >= exe_sections[i + 1].rsz) {",
          "2133:             cli_dbgmsg(\"FSG: Source buffer out of section bounds\\n\");",
          "2134:             break;",
          "2135:         }",
          "2137:         if(newedi != exe_sections[i].rva) {",
          "2138:             cli_dbgmsg(\"FSG: Bad destination (is %x should be %x)\\n\", newedi, exe_sections[i].rva);",
          "2139:             break;",
          "2140:         }",
          "2143:         for(t = 12; t < gp - 4; t += 4) {",
          "2144:             uint32_t rva = cli_readint32(support+t);",
          "2146:             if(!rva)",
          "2147:                 break;",
          "2149:             rva -= EC32(optional_hdr32.ImageBase)+1;",
          "2150:             sectcnt++;",
          "2152:             if(rva % 0x1000)",
          "2153:                 cli_dbgmsg(\"FSG: Original section %d is misaligned\\n\", sectcnt);",
          "2155:             if(rva < exe_sections[i].rva || rva - exe_sections[i].rva >= exe_sections[i].vsz) {",
          "2156:                 cli_dbgmsg(\"FSG: Original section %d is out of bounds\\n\", sectcnt);",
          "2157:                 break;",
          "2158:             }",
          "2159:         }",
          "2161:         if(t >= gp - 4 || cli_readint32(support + t)) {",
          "2162:             break;",
          "2163:         }",
          "2165:         if((sections = (struct cli_exe_section *) cli_malloc((sectcnt + 1) * sizeof(struct cli_exe_section))) == NULL) {",
          "2166:             cli_errmsg(\"FSG: Unable to allocate memory for sections %lu\\n\", (sectcnt + 1) * sizeof(struct cli_exe_section));",
          "2167:             free(exe_sections);",
          "2168:             return CL_EMEM;",
          "2169:         }",
          "2171:         sections[0].rva = newedi;",
          "2172:         for(t = 1; t <= (uint32_t)sectcnt; t++)",
          "2173:             sections[t].rva = cli_readint32(support + 8 + t * 4) - 1 - EC32(optional_hdr32.ImageBase);",
          "2175:         if(!exe_sections[i + 1].rsz || !(src = fmap_need_off_once(map, exe_sections[i + 1].raw, ssize))) {",
          "2176:             cli_dbgmsg(\"Can't read raw data of section %d\\n\", i);",
          "2177:             free(exe_sections);",
          "2178:             free(sections);",
          "2179:             return CL_EREAD;",
          "2180:         }",
          "2182:         if((dest = (char *) cli_calloc(dsize, sizeof(char))) == NULL) {",
          "2183:             free(exe_sections);",
          "2184:             free(sections);",
          "2185:             return CL_EMEM;",
          "2186:         }",
          "2188:         oldep = vep + 161 + 6 + cli_readint32(epbuff+163);",
          "2189:         cli_dbgmsg(\"FSG: found old EP @%x\\n\", oldep);",
          "2192:         cli_jsonstr(pe_json, \"Packer\", \"FSG\");",
          "2195:         CLI_UNPTEMP(\"FSG\",(dest,sections,exe_sections,0));",
          "2196:         CLI_UNPRESULTSFSG1(\"FSG\",(unfsg_133(src + newesi - exe_sections[i + 1].rva, dest, ssize + exe_sections[i + 1].rva - newesi, dsize, sections, sectcnt, EC32(optional_hdr32.ImageBase), oldep, ndesc)),1,(dest,sections,0));",
          "2201:         int sectcnt = 0;",
          "2202:         uint32_t gp, t = cli_rawaddr(cli_readint32(epbuff+1) - EC32(optional_hdr32.ImageBase), NULL, 0 , &err, fsize, hdr_size);",
          "2203:         const char *support;",
          "2204:         uint32_t newesi = cli_readint32(epbuff+11) - EC32(optional_hdr32.ImageBase);",
          "2205:         uint32_t newedi = cli_readint32(epbuff+6) - EC32(optional_hdr32.ImageBase);",
          "2206:         uint32_t oldep = vep - exe_sections[i + 1].rva;",
          "2207:         struct cli_exe_section *sections;",
          "2211:         ssize = exe_sections[i + 1].rsz;",
          "2212:         dsize = exe_sections[i].vsz;",
          "2214:         if(err) {",
          "2215:             cli_dbgmsg(\"FSG: Support data out of padding area\\n\");",
          "2216:             break;",
          "2217:         }",
          "2219:         if(newesi < exe_sections[i + 1].rva || newesi - exe_sections[i + 1].rva >= exe_sections[i + 1].raw) {",
          "2220:             cli_dbgmsg(\"FSG: Source buffer out of section bounds\\n\");",
          "2221:             break;",
          "2222:         }",
          "2224:         if(newedi != exe_sections[i].rva) {",
          "2225:             cli_dbgmsg(\"FSG: Bad destination (is %x should be %x)\\n\", newedi, exe_sections[i].rva);",
          "2226:             break;",
          "2227:         }",
          "2229:         CLI_UNPSIZELIMITS(\"FSG\", MAX(dsize, ssize));",
          "2231:         if(ssize <= 0x19 || dsize <= ssize) {",
          "2232:             cli_dbgmsg(\"FSG: Size mismatch (ssize: %d, dsize: %d)\\n\", ssize, dsize);",
          "2233:             free(exe_sections);",
          "2234:             return CL_CLEAN;",
          "2235:         }",
          "2237:         gp = exe_sections[i + 1].raw - t;",
          "2239:         CLI_UNPSIZELIMITS(\"FSG\", gp)",
          "2241:         if(!(support = fmap_need_off_once(map, t, gp))) {",
          "2242:             cli_dbgmsg(\"Can't read %d bytes from padding area\\n\", gp);",
          "2243:             free(exe_sections);",
          "2244:             return CL_EREAD;",
          "2245:         }",
          "2248:         for(t = 0; t < gp - 2; t += 2) {",
          "2249:             uint32_t rva = support[t]|(support[t+1]<<8);",
          "2251:             if (rva == 2 || rva == 1)",
          "2252:                 break;",
          "2254:             rva = ((rva-2)<<12) - EC32(optional_hdr32.ImageBase);",
          "2255:             sectcnt++;",
          "2257:             if(rva < exe_sections[i].rva || rva - exe_sections[i].rva >= exe_sections[i].vsz) {",
          "2258:                 cli_dbgmsg(\"FSG: Original section %d is out of bounds\\n\", sectcnt);",
          "2259:                 break;",
          "2260:             }",
          "2261:         }",
          "2263:         if(t >= gp-10 || cli_readint32(support + t + 6) != 2)",
          "2264:             break;",
          "2266:         if((sections = (struct cli_exe_section *) cli_malloc((sectcnt + 1) * sizeof(struct cli_exe_section))) == NULL) {",
          "2267:             cli_errmsg(\"FSG: Unable to allocate memory for sections %lu\\n\", (sectcnt + 1) * sizeof(struct cli_exe_section));",
          "2268:             free(exe_sections);",
          "2269:             return CL_EMEM;",
          "2270:         }",
          "2272:         sections[0].rva = newedi;",
          "2273:         for(t = 0; t <= (uint32_t)sectcnt - 1; t++)",
          "2274:             sections[t+1].rva = (((support[t*2]|(support[t*2+1]<<8))-2)<<12)-EC32(optional_hdr32.ImageBase);",
          "2276:         if(!exe_sections[i + 1].rsz || !(src = fmap_need_off_once(map, exe_sections[i + 1].raw, ssize))) {",
          "2277:             cli_dbgmsg(\"FSG: Can't read raw data of section %d\\n\", i);",
          "2278:             free(exe_sections);",
          "2279:             free(sections);",
          "2280:             return CL_EREAD;",
          "2281:         }",
          "2283:         if((dest = (char *) cli_calloc(dsize, sizeof(char))) == NULL) {",
          "2284:             free(exe_sections);",
          "2285:             free(sections);",
          "2286:             return CL_EMEM;",
          "2287:         }",
          "2289:         gp = 0xda + 6*(epbuff[16]=='\\xe8');",
          "2290:         oldep = vep + gp + 6 + cli_readint32(src+gp+2+oldep);",
          "2291:         cli_dbgmsg(\"FSG: found old EP @%x\\n\", oldep);",
          "2294:         cli_jsonstr(pe_json, \"Packer\", \"FSG\");",
          "2297:         CLI_UNPTEMP(\"FSG\",(dest,sections,exe_sections,0));",
          "2298:         CLI_UNPRESULTSFSG1(\"FSG\",(unfsg_133(src + newesi - exe_sections[i + 1].rva, dest, ssize + exe_sections[i + 1].rva - newesi, dsize, sections, sectcnt, EC32(optional_hdr32.ImageBase), oldep, ndesc)),1,(dest,sections,0));",
          "2305:         ssize = exe_sections[i + 1].rsz;",
          "2306:         dsize = exe_sections[i].vsz + exe_sections[i + 1].vsz;",
          "2315:         CLI_UNPSIZELIMITS(\"UPX\", MAX(dsize, ssize));",
          "2317:         if(ssize <= 0x19 || dsize <= ssize || dsize > CLI_MAX_ALLOCATION ) {",
          "2318:             cli_dbgmsg(\"UPX: Size mismatch or dsize too big (ssize: %d, dsize: %d)\\n\", ssize, dsize);",
          "2319:             free(exe_sections);",
          "2320:             return CL_CLEAN;",
          "2321:         }",
          "2323:         if(!exe_sections[i + 1].rsz || !(src = fmap_need_off_once(map, exe_sections[i + 1].raw, ssize))) {",
          "2324:             cli_dbgmsg(\"UPX: Can't read raw data of section %d\\n\", i+1);",
          "2325:             free(exe_sections);",
          "2326:             return CL_EREAD;",
          "2327:         }",
          "2329:         if((dest = (char *) cli_calloc(dsize + 8192, sizeof(char))) == NULL) {",
          "2330:             free(exe_sections);",
          "2331:             return CL_EMEM;",
          "2332:         }",
          "2335:         if(cli_memstr(UPX_NRV2B, 24, epbuff + 0x69, 13) || cli_memstr(UPX_NRV2B, 24, epbuff + 0x69 + 8, 13)) {",
          "2336:             cli_dbgmsg(\"UPX: Looks like a NRV2B decompression routine\\n\");",
          "2337:             upxfn = upx_inflate2b;",
          "2338:         } else if(cli_memstr(UPX_NRV2D, 24, epbuff + 0x69, 13) || cli_memstr(UPX_NRV2D, 24, epbuff + 0x69 + 8, 13)) {",
          "2339:             cli_dbgmsg(\"UPX: Looks like a NRV2D decompression routine\\n\");",
          "2340:             upxfn = upx_inflate2d;",
          "2341:         } else if(cli_memstr(UPX_NRV2E, 24, epbuff + 0x69, 13) || cli_memstr(UPX_NRV2E, 24, epbuff + 0x69 + 8, 13)) {",
          "2342:             cli_dbgmsg(\"UPX: Looks like a NRV2E decompression routine\\n\");",
          "2343:             upxfn = upx_inflate2e;",
          "2344:         }",
          "2346:         if(upxfn) {",
          "2347:             int skew = cli_readint32(epbuff + 2) - EC32(optional_hdr32.ImageBase) - exe_sections[i + 1].rva;",
          "2349:             if(epbuff[1] != '\\xbe' || skew <= 0 || skew > 0xfff) {",
          "2351:                 skew = 0;",
          "2352:             } else if ((unsigned int)skew > ssize) {",
          "2354:                 skew = 0;",
          "2355:             } else {",
          "2356:                 cli_dbgmsg(\"UPX: UPX1 seems skewed by %d bytes\\n\", skew);",
          "2357:             }",
          "2360:             if(upxfn(src + skew, ssize - skew, dest, &dsize, exe_sections[i].rva, exe_sections[i + 1].rva, vep-skew) >= 0) {",
          "2361:                 upx_success = 1;",
          "2362:             }",
          "2364:             else if(skew && (upxfn(src, ssize, dest, &dsize, exe_sections[i].rva, exe_sections[i + 1].rva, vep) >= 0)) {",
          "2365:                 upx_success = 1;",
          "2366:             }",
          "2368:             if(upx_success)",
          "2369:                 cli_dbgmsg(\"UPX: Successfully decompressed\\n\");",
          "2370:             else",
          "2371:                 cli_dbgmsg(\"UPX: Preferred decompressor failed\\n\");",
          "2372:         }",
          "2374:         if(!upx_success && upxfn != upx_inflate2b) {",
          "2375:             if(upx_inflate2b(src, ssize, dest, &dsize, exe_sections[i].rva, exe_sections[i + 1].rva, vep) == -1 && upx_inflate2b(src + 0x15, ssize - 0x15, dest, &dsize, exe_sections[i].rva, exe_sections[i + 1].rva, vep - 0x15) == -1) {",
          "2377:                 cli_dbgmsg(\"UPX: NRV2B decompressor failed\\n\");",
          "2378:             } else {",
          "2379:                 upx_success = 1;",
          "2380:                 cli_dbgmsg(\"UPX: Successfully decompressed with NRV2B\\n\");",
          "2381:             }",
          "2382:         }",
          "2384:         if(!upx_success && upxfn != upx_inflate2d) {",
          "2385:             if(upx_inflate2d(src, ssize, dest, &dsize, exe_sections[i].rva, exe_sections[i + 1].rva, vep) == -1 && upx_inflate2d(src + 0x15, ssize - 0x15, dest, &dsize, exe_sections[i].rva, exe_sections[i + 1].rva, vep - 0x15) == -1) {",
          "2387:                 cli_dbgmsg(\"UPX: NRV2D decompressor failed\\n\");",
          "2388:             } else {",
          "2389:                 upx_success = 1;",
          "2390:                 cli_dbgmsg(\"UPX: Successfully decompressed with NRV2D\\n\");",
          "2391:             }",
          "2392:         }",
          "2394:         if(!upx_success && upxfn != upx_inflate2e) {",
          "2395:             if(upx_inflate2e(src, ssize, dest, &dsize, exe_sections[i].rva, exe_sections[i + 1].rva, vep) == -1 && upx_inflate2e(src + 0x15, ssize - 0x15, dest, &dsize, exe_sections[i].rva, exe_sections[i + 1].rva, vep - 0x15) == -1) {",
          "2396:                 cli_dbgmsg(\"UPX: NRV2E decompressor failed\\n\");",
          "2397:             } else {",
          "2398:                 upx_success = 1;",
          "2399:                 cli_dbgmsg(\"UPX: Successfully decompressed with NRV2E\\n\");",
          "2400:             }",
          "2401:         }",
          "2403:         if(cli_memstr(UPX_LZMA2, 20, epbuff + 0x2f, 20)) {",
          "2404:             uint32_t strictdsize=cli_readint32(epbuff+0x21), skew = 0;",
          "2405:             if(ssize > 0x15 && epbuff[0] == '\\x60' && epbuff[1] == '\\xbe') {",
          "2406:                 skew = cli_readint32(epbuff+2) - exe_sections[i + 1].rva - optional_hdr32.ImageBase;",
          "2407:                 if(skew!=0x15)",
          "2408:                     skew = 0;",
          "2409:             }",
          "2411:             if(strictdsize<=dsize)",
          "2412:                 upx_success = upx_inflatelzma(src+skew, ssize-skew, dest, &strictdsize, exe_sections[i].rva, exe_sections[i + 1].rva, vep) >=0;",
          "2413:         } else if (cli_memstr(UPX_LZMA1, 20, epbuff + 0x39, 20)) {",
          "2414:             uint32_t strictdsize=cli_readint32(epbuff+0x2b), skew = 0;",
          "2415:             if(ssize > 0x15 && epbuff[0] == '\\x60' && epbuff[1] == '\\xbe') {",
          "2416:                 skew = cli_readint32(epbuff+2) - exe_sections[i + 1].rva - optional_hdr32.ImageBase;",
          "2417:                 if(skew!=0x15)",
          "2418:                     skew = 0;",
          "2419:             }",
          "2421:             if(strictdsize<=dsize)",
          "2422:                 upx_success = upx_inflatelzma(src+skew, ssize-skew, dest, &strictdsize, exe_sections[i].rva, exe_sections[i + 1].rva, vep) >=0;",
          "2423:         }",
          "2425:         if(!upx_success) {",
          "2426:             cli_dbgmsg(\"UPX: All decompressors failed\\n\");",
          "2427:             free(dest);",
          "2428:         }",
          "2432:         free(exe_sections);",
          "2434:         CLI_UNPTEMP(\"UPX/FSG\",(dest,0));",
          "2436:         cli_jsonstr(pe_json, \"Packer\", \"UPX\");",
          "2439:         if((unsigned int) write(ndesc, dest, dsize) != dsize) {",
          "2440:             cli_dbgmsg(\"UPX/FSG: Can't write %d bytes\\n\", dsize);",
          "2441:             free(tempfile);",
          "2442:             free(dest);",
          "2443:             close(ndesc);",
          "2444:             return CL_EWRITE;",
          "2445:         }",
          "2447:         free(dest);",
          "2448:         if (lseek(ndesc, 0, SEEK_SET) == -1) {",
          "2449:             cli_dbgmsg(\"UPX/FSG: lseek() failed\\n\");",
          "2450:             close(ndesc);",
          "2451:             CLI_TMPUNLK();",
          "2452:             free(tempfile);",
          "2453:             SHA_RESET;",
          "2454:             return CL_ESEEK;",
          "2455:         }",
          "2457:         if(ctx->engine->keeptmp)",
          "2458:             cli_dbgmsg(\"UPX/FSG: Decompressed data saved in %s\\n\", tempfile);",
          "2460:         cli_dbgmsg(\"***** Scanning decompressed file *****\\n\");",
          "2461:         SHA_OFF;",
          "2462:         if((ret = cli_magic_scandesc(ndesc, ctx)) == CL_VIRUS) {",
          "2463:             close(ndesc);",
          "2464:             CLI_TMPUNLK();",
          "2465:             free(tempfile);",
          "2466:             SHA_RESET;",
          "2467:             return CL_VIRUS;",
          "2468:         }",
          "2470:         SHA_RESET;",
          "2474:         return ret;",
          "2481:         free(exe_sections);",
          "2482:         return CL_CLEAN;",
          "2488:         if(nsections < 2 || epbuff[0] != '\\xb8' || (uint32_t) cli_readint32(epbuff + 1) != exe_sections[nsections - 2].rva + EC32(optional_hdr32.ImageBase))",
          "2489:             found = 0;",
          "2490:         else",
          "2491:             found = 1;",
          "2495:         cli_dbgmsg(\"Petite: v2.%d compression detected\\n\", found);",
          "2497:         if(cli_readint32(epbuff + 0x80) == 0x163c988d) {",
          "2498:             cli_dbgmsg(\"Petite: level zero compression is not supported yet\\n\");",
          "2499:         } else {",
          "2500:             dsize = max - min;",
          "2502:             CLI_UNPSIZELIMITS(\"Petite\", dsize);",
          "2504:             if((dest = (char *) cli_calloc(dsize, sizeof(char))) == NULL) {",
          "2505:                 cli_dbgmsg(\"Petite: Can't allocate %d bytes\\n\", dsize);",
          "2506:                 free(exe_sections);",
          "2507:                 return CL_EMEM;",
          "2508:             }",
          "2510:             for(i = 0 ; i < nsections; i++) {",
          "2511:                 if(exe_sections[i].raw) {",
          "2512:                     if(!exe_sections[i].rsz || (unsigned int)fmap_readn(map, dest + exe_sections[i].rva - min, exe_sections[i].raw, exe_sections[i].ursz) != exe_sections[i].ursz) {",
          "2513:                         free(exe_sections);",
          "2514:                         free(dest);",
          "2515:                         return CL_CLEAN;",
          "2516:                     }",
          "2517:                 }",
          "2518:             }",
          "2521:             cli_jsonstr(pe_json, \"Packer\", \"Petite\");",
          "2524:             CLI_UNPTEMP(\"Petite\",(dest,exe_sections,0));",
          "2525:             CLI_UNPRESULTS(\"Petite\",(petite_inflate2x_1to9(dest, min, max - min, exe_sections, nsections - (found == 1 ? 1 : 0), EC32(optional_hdr32.ImageBase),vep, ndesc, found, EC32(optional_hdr32.DataDirectory[2].VirtualAddress),EC32(optional_hdr32.DataDirectory[2].Size))),0,(dest,0));",
          "2526:         }",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "2446:        vep < exe_sections[nsections - 1].rva + exe_sections[nsections - 1].rsz - 0x3217 - 4 &&",
          "2447:        memcmp(epbuff+4, \"\\xe8\\x00\\x00\\x00\\x00\\x8b\\x1c\\x24\\x83\\xc3\", 10) == 0)  {",
          "2466: #if HAVE_JSON",
          "2468: #endif",
          "2472:     }",
          "",
          "[Removed Lines]",
          "2449:  char *spinned;",
          "2451:  CLI_UNPSIZELIMITS(\"PEspin\", fsize);",
          "2453:  if((spinned = (char *) cli_malloc(fsize)) == NULL) {",
          "2454:         cli_errmsg(\"PESping: Unable to allocate memory for spinned %lu\\n\", (unsigned long)fsize);",
          "2455:      free(exe_sections);",
          "2456:      return CL_EMEM;",
          "2457:  }",
          "2459:  if((size_t) fmap_readn(map, spinned, 0, fsize) != fsize) {",
          "2460:      cli_dbgmsg(\"PESpin: Can't read %lu bytes\\n\", (unsigned long)fsize);",
          "2461:      free(spinned);",
          "2462:      free(exe_sections);",
          "2463:      return CL_EREAD;",
          "2464:  }",
          "2467:     cli_jsonstr(pe_json, \"Packer\", \"PEspin\");",
          "2470:  CLI_UNPTEMP(\"PESpin\",(spinned,exe_sections,0));",
          "2471:  CLI_UNPRESULTS_(\"PEspin\",SPINCASE(),(unspin(spinned, fsize, exe_sections, nsections - 1, vep, ndesc, ctx)),0,(spinned,0));",
          "",
          "[Added Lines]",
          "2536:         char *spinned;",
          "2538:         CLI_UNPSIZELIMITS(\"PEspin\", fsize);",
          "2540:         if((spinned = (char *) cli_malloc(fsize)) == NULL) {",
          "2541:             cli_errmsg(\"PESping: Unable to allocate memory for spinned %lu\\n\", (unsigned long)fsize);",
          "2542:             free(exe_sections);",
          "2543:             return CL_EMEM;",
          "2544:         }",
          "2546:         if((size_t) fmap_readn(map, spinned, 0, fsize) != fsize) {",
          "2547:             cli_dbgmsg(\"PESpin: Can't read %lu bytes\\n\", (unsigned long)fsize);",
          "2548:             free(spinned);",
          "2549:             free(exe_sections);",
          "2550:             return CL_EREAD;",
          "2551:         }",
          "2554:         cli_jsonstr(pe_json, \"Packer\", \"PEspin\");",
          "2557:         CLI_UNPTEMP(\"PESpin\",(spinned,exe_sections,0));",
          "2558:         CLI_UNPRESULTS_(\"PEspin\",SPINCASE(),(unspin(spinned, fsize, exe_sections, nsections - 1, vep, ndesc, ctx)),0,(spinned,0));",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "2476:     if((DCONF & PE_CONF_YC) && nsections > 1 &&",
          "2477:        (EC32(optional_hdr32.AddressOfEntryPoint) == exe_sections[nsections - 1].rva + 0x60)) {",
          "2534: #if HAVE_JSON",
          "2536: #endif",
          "2542:     }",
          "",
          "[Removed Lines]",
          "2479:  uint32_t ecx = 0;",
          "2480:  int16_t offset;",
          "2483:  if (!memcmp(epbuff, \"\\x55\\x8B\\xEC\\x53\\x56\\x57\\x60\\xE8\\x00\\x00\\x00\\x00\\x5D\\x81\\xED\", 15) &&",
          "2484:      !memcmp(epbuff+0x26, \"\\x8D\\x3A\\x8B\\xF7\\x33\\xC0\\xEB\\x04\\x90\\xEB\\x01\\xC2\\xAC\", 13) &&",
          "2485:      ((uint8_t)epbuff[0x13] == 0xB9) &&",
          "2486:      ((uint16_t)(cli_readint16(epbuff+0x18)) == 0xE981) &&",
          "2487:      !memcmp(epbuff+0x1e,\"\\x8B\\xD5\\x81\\xC2\", 4)) {",
          "2489:      offset = 0;",
          "2490:      if (0x6c - cli_readint32(epbuff+0xf) + cli_readint32(epbuff+0x22) == 0xC6)",
          "2491:   ecx = cli_readint32(epbuff+0x14) - cli_readint32(epbuff+0x1a);",
          "2492:  }",
          "2495:  if (!ecx && !memcmp(epbuff, \"\\x55\\x8B\\xEC\\x83\\xEC\\x40\\x53\\x56\\x57\", 9) &&",
          "2496:      !memcmp(epbuff+0x17, \"\\xe8\\x00\\x00\\x00\\x00\\x5d\\x81\\xed\", 8) &&",
          "2497:      ((uint8_t)epbuff[0x23] == 0xB9)) {",
          "2499:      offset = 0x10;",
          "2500:      if (0x6c - cli_readint32(epbuff+0x1f) + cli_readint32(epbuff+0x32) == 0xC6)",
          "2501:   ecx = cli_readint32(epbuff+0x24) - cli_readint32(epbuff+0x2a);",
          "2502:  }",
          "2505:  if (!ecx && !memcmp(epbuff, \"\\x60\\xe8\\x00\\x00\\x00\\x00\\x5d\\x81\\xed\",9) &&",
          "2506:      ((uint8_t)epbuff[0xd] == 0xb9) &&",
          "2507:      ((uint16_t)cli_readint16(epbuff + 0x12)== 0xbd8d) &&",
          "2508:      !memcmp(epbuff+0x18, \"\\x8b\\xf7\\xac\", 3)) {",
          "2510:      offset = -0x18;",
          "2511:      if (0x66 - cli_readint32(epbuff+0x9) + cli_readint32(epbuff+0x14) == 0xae)",
          "2512:   ecx = cli_readint32(epbuff+0xe);",
          "2513:  }",
          "2515:  if (ecx > 0x800 && ecx < 0x2000 &&",
          "2516:      !memcmp(epbuff+0x63+offset, \"\\xaa\\xe2\\xcc\", 3) &&",
          "2517:      (fsize >= exe_sections[nsections-1].raw + 0xC6 + ecx + offset)) {",
          "2519:      char *spinned;",
          "2521:      if((spinned = (char *) cli_malloc(fsize)) == NULL) {",
          "2522:             cli_errmsg(\"yC: Unable to allocate memory for spinned %lu\\n\", (unsigned long)fsize);",
          "2523:        free(exe_sections);",
          "2524:        return CL_EMEM;",
          "2525:      }",
          "2527:      if((size_t) fmap_readn(map, spinned, 0, fsize) != fsize) {",
          "2528:        cli_dbgmsg(\"yC: Can't read %lu bytes\\n\", (unsigned long)fsize);",
          "2529:        free(spinned);",
          "2530:        free(exe_sections);",
          "2531:        return CL_EREAD;",
          "2532:      }",
          "2535:         cli_jsonstr(pe_json, \"Packer\", \"yC\");",
          "2538:      cli_dbgmsg(\"%d,%d,%d,%d\\n\", nsections-1, e_lfanew, ecx, offset);",
          "2539:      CLI_UNPTEMP(\"yC\",(spinned,exe_sections,0));",
          "2540:      CLI_UNPRESULTS(\"yC\",(yc_decrypt(spinned, fsize, exe_sections, nsections-1, e_lfanew, ndesc, ecx, offset)),0,(spinned,0));",
          "2541:  }",
          "",
          "[Added Lines]",
          "2566:         uint32_t ecx = 0;",
          "2567:         int16_t offset;",
          "2570:         if (!memcmp(epbuff, \"\\x55\\x8B\\xEC\\x53\\x56\\x57\\x60\\xE8\\x00\\x00\\x00\\x00\\x5D\\x81\\xED\", 15) &&",
          "2571:             !memcmp(epbuff+0x26, \"\\x8D\\x3A\\x8B\\xF7\\x33\\xC0\\xEB\\x04\\x90\\xEB\\x01\\xC2\\xAC\", 13) &&",
          "2572:             ((uint8_t)epbuff[0x13] == 0xB9) &&",
          "2573:             ((uint16_t)(cli_readint16(epbuff+0x18)) == 0xE981) &&",
          "2574:             !memcmp(epbuff+0x1e,\"\\x8B\\xD5\\x81\\xC2\", 4)) {",
          "2576:             offset = 0;",
          "2577:             if (0x6c - cli_readint32(epbuff+0xf) + cli_readint32(epbuff+0x22) == 0xC6)",
          "2578:             ecx = cli_readint32(epbuff+0x14) - cli_readint32(epbuff+0x1a);",
          "2579:         }",
          "2582:         if (!ecx && !memcmp(epbuff, \"\\x55\\x8B\\xEC\\x83\\xEC\\x40\\x53\\x56\\x57\", 9) &&",
          "2583:             !memcmp(epbuff+0x17, \"\\xe8\\x00\\x00\\x00\\x00\\x5d\\x81\\xed\", 8) &&",
          "2584:             ((uint8_t)epbuff[0x23] == 0xB9)) {",
          "2586:             offset = 0x10;",
          "2587:             if (0x6c - cli_readint32(epbuff+0x1f) + cli_readint32(epbuff+0x32) == 0xC6)",
          "2588:             ecx = cli_readint32(epbuff+0x24) - cli_readint32(epbuff+0x2a);",
          "2589:         }",
          "2592:         if (!ecx && !memcmp(epbuff, \"\\x60\\xe8\\x00\\x00\\x00\\x00\\x5d\\x81\\xed\",9) &&",
          "2593:             ((uint8_t)epbuff[0xd] == 0xb9) &&",
          "2594:             ((uint16_t)cli_readint16(epbuff + 0x12)== 0xbd8d) &&",
          "2595:             !memcmp(epbuff+0x18, \"\\x8b\\xf7\\xac\", 3)) {",
          "2597:             offset = -0x18;",
          "2598:             if (0x66 - cli_readint32(epbuff+0x9) + cli_readint32(epbuff+0x14) == 0xae)",
          "2599:             ecx = cli_readint32(epbuff+0xe);",
          "2600:         }",
          "2602:         if (ecx > 0x800 && ecx < 0x2000 &&",
          "2603:             !memcmp(epbuff+0x63+offset, \"\\xaa\\xe2\\xcc\", 3) &&",
          "2604:             (fsize >= exe_sections[nsections-1].raw + 0xC6 + ecx + offset)) {",
          "2606:             char *spinned;",
          "2608:             if((spinned = (char *) cli_malloc(fsize)) == NULL) {",
          "2609:                 cli_errmsg(\"yC: Unable to allocate memory for spinned %lu\\n\", (unsigned long)fsize);",
          "2610:                 free(exe_sections);",
          "2611:                 return CL_EMEM;",
          "2612:             }",
          "2614:             if((size_t) fmap_readn(map, spinned, 0, fsize) != fsize) {",
          "2615:                 cli_dbgmsg(\"yC: Can't read %lu bytes\\n\", (unsigned long)fsize);",
          "2616:                 free(spinned);",
          "2617:                 free(exe_sections);",
          "2618:                 return CL_EREAD;",
          "2619:             }",
          "2622:             cli_jsonstr(pe_json, \"Packer\", \"yC\");",
          "2625:             cli_dbgmsg(\"%d,%d,%d,%d\\n\", nsections-1, e_lfanew, ecx, offset);",
          "2626:             CLI_UNPTEMP(\"yC\",(spinned,exe_sections,0));",
          "2627:             CLI_UNPRESULTS(\"yC\",(yc_decrypt(spinned, fsize, exe_sections, nsections-1, e_lfanew, ndesc, ecx, offset)),0,(spinned,0));",
          "2628:         }",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "2547:        vep == exe_sections[nsections - 1].rva &&",
          "2548:        memcmp(epbuff, \"\\x53\\x55\\x8b\\xe8\\x33\\xdb\\xeb\", 7) == 0 &&",
          "2549:        memcmp(epbuff+0x68, \"\\xe8\\x00\\x00\\x00\\x00\\x58\\x2d\\x6d\\x00\\x00\\x00\\x50\\x60\\x33\\xc9\\x50\\x58\\x50\\x50\", 19) == 0)  {",
          "2551:         uint8_t *packer;",
          "2566:         if(!(src=(char *)cli_calloc(ssize, sizeof(char)))) {",
          "2576:         for(i = 0 ; i < (unsigned int)nsections-1; i++) {",
          "2580:         }",
          "2581:         if(i+1!=nsections) {",
          "2582:             cli_dbgmsg(\"WWpack: Probably hacked/damaged file.\\n\");",
          "2583:             free(src);",
          "2584:             break;",
          "2585:         }",
          "2599: #if HAVE_JSON",
          "2601: #endif",
          "2606:     }",
          "2610:     while((DCONF & PE_CONF_ASPACK) && ep+58+0x70e < fsize && !memcmp(epbuff,\"\\x60\\xe8\\x03\\x00\\x00\\x00\\xe9\\xeb\",8)) {",
          "2622:         if(!(src=(char *)cli_calloc(ssize, sizeof(char)))) {",
          "2626:         for(i = 0 ; i < (unsigned int)nsections; i++) {",
          "2630:         }",
          "2631:         if(i!=nsections) {",
          "2632:             cli_dbgmsg(\"Aspack: Probably hacked/damaged Aspack file.\\n\");",
          "2633:             free(src);",
          "",
          "[Removed Lines]",
          "2550:  uint32_t head = exe_sections[nsections - 1].raw;",
          "2552:  char *src;",
          "2554:  ssize = 0;",
          "2555:  for(i=0 ; ; i++) {",
          "2556:      if(exe_sections[i].raw<head)",
          "2557:          head=exe_sections[i].raw;",
          "2558:      if(i+1==nsections) break;",
          "2559:      if(ssize<exe_sections[i].rva+exe_sections[i].vsz)",
          "2560:   ssize=exe_sections[i].rva+exe_sections[i].vsz;",
          "2561:  }",
          "2562:  if(!head || !ssize || head>ssize) break;",
          "2564:  CLI_UNPSIZELIMITS(\"WWPack\", ssize);",
          "2567:      free(exe_sections);",
          "2568:      return CL_EMEM;",
          "2569:  }",
          "2570:  if((size_t) fmap_readn(map, src, 0, head) != head) {",
          "2571:      cli_dbgmsg(\"WWPack: Can't read %d bytes from headers\\n\", head);",
          "2572:      free(src);",
          "2573:      free(exe_sections);",
          "2574:      return CL_EREAD;",
          "2575:  }",
          "2577:      if(!exe_sections[i].rsz) continue;",
          "2578:             if(!CLI_ISCONTAINED(src, ssize, src+exe_sections[i].rva, exe_sections[i].rsz)) break;",
          "2579:             if((unsigned int)fmap_readn(map, src+exe_sections[i].rva, exe_sections[i].raw, exe_sections[i].rsz)!=exe_sections[i].rsz) break;",
          "2586:  if((packer = (uint8_t *) cli_calloc(exe_sections[nsections - 1].rsz, sizeof(char))) == NULL) {",
          "2587:      free(src);",
          "2588:      free(exe_sections);",
          "2589:      return CL_EMEM;",
          "2590:  }",
          "2591:  if(!exe_sections[nsections - 1].rsz || (size_t) fmap_readn(map, packer, exe_sections[nsections - 1].raw, exe_sections[nsections - 1].rsz) != exe_sections[nsections - 1].rsz) {",
          "2592:      cli_dbgmsg(\"WWPack: Can't read %d bytes from wwpack sect\\n\", exe_sections[nsections - 1].rsz);",
          "2593:      free(src);",
          "2594:      free(packer);",
          "2595:      free(exe_sections);",
          "2596:      return CL_EREAD;",
          "2597:  }",
          "2600:     cli_jsonstr(pe_json, \"Packer\", \"WWPack\");",
          "2603:  CLI_UNPTEMP(\"WWPack\",(src,packer,exe_sections,0));",
          "2604:  CLI_UNPRESULTS(\"WWPack\",(wwunpack((uint8_t *)src, ssize, packer, exe_sections, nsections-1, e_lfanew, ndesc)),0,(src,packer,0));",
          "2605:  break;",
          "2611:  char *src;",
          "2613:         if(epsize<0x3bf || memcmp(epbuff+0x3b9, \"\\x68\\x00\\x00\\x00\\x00\\xc3\",6)) break;",
          "2614:  ssize = 0;",
          "2615:  for(i=0 ; i< nsections ; i++)",
          "2616:      if(ssize<exe_sections[i].rva+exe_sections[i].vsz)",
          "2617:   ssize=exe_sections[i].rva+exe_sections[i].vsz;",
          "2618:  if(!ssize) break;",
          "2620:  CLI_UNPSIZELIMITS(\"Aspack\", ssize);",
          "2623:      free(exe_sections);",
          "2624:      return CL_EMEM;",
          "2625:  }",
          "2627:      if(!exe_sections[i].rsz) continue;",
          "2628:             if(!CLI_ISCONTAINED(src, ssize, src+exe_sections[i].rva, exe_sections[i].rsz)) break;",
          "2629:             if((unsigned int)fmap_readn(map, src+exe_sections[i].rva, exe_sections[i].raw, exe_sections[i].rsz)!=exe_sections[i].rsz) break;",
          "",
          "[Added Lines]",
          "2637:         uint32_t head = exe_sections[nsections - 1].raw;",
          "2639:         char *src;",
          "2641:         ssize = 0;",
          "2642:         for(i=0 ; ; i++) {",
          "2643:             if(exe_sections[i].raw<head)",
          "2644:                 head=exe_sections[i].raw;",
          "2646:             if(i+1==nsections)",
          "2647:                 break;",
          "2649:             if(ssize<exe_sections[i].rva+exe_sections[i].vsz)",
          "2650:                 ssize=exe_sections[i].rva+exe_sections[i].vsz;",
          "2651:         }",
          "2653:         if(!head || !ssize || head>ssize)",
          "2654:             break;",
          "2656:         CLI_UNPSIZELIMITS(\"WWPack\", ssize);",
          "2659:             free(exe_sections);",
          "2660:             return CL_EMEM;",
          "2661:         }",
          "2663:         if((size_t) fmap_readn(map, src, 0, head) != head) {",
          "2664:             cli_dbgmsg(\"WWPack: Can't read %d bytes from headers\\n\", head);",
          "2665:             free(src);",
          "2666:             free(exe_sections);",
          "2667:             return CL_EREAD;",
          "2668:         }",
          "2671:             if(!exe_sections[i].rsz)",
          "2672:                 continue;",
          "2674:             if(!CLI_ISCONTAINED(src, ssize, src+exe_sections[i].rva, exe_sections[i].rsz))",
          "2675:                 break;",
          "2677:             if((unsigned int)fmap_readn(map, src+exe_sections[i].rva, exe_sections[i].raw, exe_sections[i].rsz)!=exe_sections[i].rsz)",
          "2678:                 break;",
          "2687:         if((packer = (uint8_t *) cli_calloc(exe_sections[nsections - 1].rsz, sizeof(char))) == NULL) {",
          "2688:             free(src);",
          "2689:             free(exe_sections);",
          "2690:             return CL_EMEM;",
          "2691:         }",
          "2693:         if(!exe_sections[nsections - 1].rsz || (size_t) fmap_readn(map, packer, exe_sections[nsections - 1].raw, exe_sections[nsections - 1].rsz) != exe_sections[nsections - 1].rsz) {",
          "2694:             cli_dbgmsg(\"WWPack: Can't read %d bytes from wwpack sect\\n\", exe_sections[nsections - 1].rsz);",
          "2695:             free(src);",
          "2696:             free(packer);",
          "2697:             free(exe_sections);",
          "2698:             return CL_EREAD;",
          "2699:         }",
          "2702:         cli_jsonstr(pe_json, \"Packer\", \"WWPack\");",
          "2705:         CLI_UNPTEMP(\"WWPack\",(src,packer,exe_sections,0));",
          "2706:         CLI_UNPRESULTS(\"WWPack\",(wwunpack((uint8_t *)src, ssize, packer, exe_sections, nsections-1, e_lfanew, ndesc)),0,(src,packer,0));",
          "2707:         break;",
          "2713:         char *src;",
          "2715:         if(epsize<0x3bf || memcmp(epbuff+0x3b9, \"\\x68\\x00\\x00\\x00\\x00\\xc3\",6))",
          "2716:             break;",
          "2717:         ssize = 0;",
          "2718:         for(i=0 ; i< nsections ; i++)",
          "2719:             if(ssize<exe_sections[i].rva+exe_sections[i].vsz)",
          "2720:                 ssize=exe_sections[i].rva+exe_sections[i].vsz;",
          "2722:         if(!ssize)",
          "2723:             break;",
          "2725:         CLI_UNPSIZELIMITS(\"Aspack\", ssize);",
          "2728:             free(exe_sections);",
          "2729:             return CL_EMEM;",
          "2730:         }",
          "2732:             if(!exe_sections[i].rsz)",
          "2733:                 continue;",
          "2735:             if(!CLI_ISCONTAINED(src, ssize, src+exe_sections[i].rva, exe_sections[i].rsz))",
          "2736:                 break;",
          "2738:             if((unsigned int)fmap_readn(map, src+exe_sections[i].rva, exe_sections[i].raw, exe_sections[i].rsz)!=exe_sections[i].rsz)",
          "2739:                 break;",
          "",
          "---------------",
          "--- Hunk 21 ---",
          "[Context before]",
          "2638:         cli_jsonstr(pe_json, \"Packer\", \"Aspack\");",
          "2639: #endif",
          "2644:     }",
          "2648:     while (DCONF & PE_CONF_NSPACK) {",
          "2707: #if HAVE_JSON",
          "2709: #endif",
          "2714:     }",
          "2722:     ctx->corrupted_input = corrupted_cur;",
          "2725:     bc_ctx = cli_bytecode_context_alloc();",
          "2726:     if (!bc_ctx) {",
          "2729:     }",
          "2730:     cli_bytecode_context_setpe(bc_ctx, &pedata, exe_sections);",
          "2731:     cli_bytecode_context_setctx(bc_ctx, ctx);",
          "2732:     ret = cli_bytecode_runhook(ctx, ctx->engine, bc_ctx, BC_PE_UNPACKER, map);",
          "2733:     switch (ret) {",
          "2747:     }",
          "2749:     free(exe_sections);",
          "2750: #if HAVE_JSON",
          "2752:         return CL_ETIMEOUT;",
          "2754: #endif",
          "2755:     if (SCAN_ALL && viruses_found)",
          "2757:     return CL_CLEAN;",
          "2758: }",
          "",
          "[Removed Lines]",
          "2641:  CLI_UNPTEMP(\"Aspack\",(src,exe_sections,0));",
          "2642:  CLI_UNPRESULTS(\"Aspack\",(unaspack212((uint8_t *)src, ssize, exe_sections, nsections, vep-1, EC32(optional_hdr32.ImageBase), ndesc)),1,(src,0));",
          "2643:  break;",
          "2649:  uint32_t eprva = vep;",
          "2650:  uint32_t start_of_stuff, rep = ep;",
          "2651:  unsigned int nowinldr;",
          "2652:  const char *nbuff;",
          "2654:  src=epbuff;",
          "2656:      eprva = cli_readint32(epbuff+1)+vep+5;",
          "2657:      if (!(rep = cli_rawaddr(eprva, exe_sections, nsections, &err, fsize, hdr_size)) && err) break;",
          "2658:      if (!(nbuff = fmap_need_off_once(map, rep, 24))) break;",
          "2659:      src = nbuff;",
          "2660:  }",
          "2662:  if (memcmp(src, \"\\x9c\\x60\\xe8\\x00\\x00\\x00\\x00\\x5d\\xb8\\x07\\x00\\x00\\x00\", 13)) break;",
          "2664:  nowinldr = 0x54-cli_readint32(src+17);",
          "2665:  cli_dbgmsg(\"NsPack: Found *start_of_stuff @delta-%x\\n\", nowinldr);",
          "2667:  if(!(nbuff = fmap_need_off_once(map, rep-nowinldr, 4))) break;",
          "2668:  start_of_stuff=rep+cli_readint32(nbuff);",
          "2669:  if(!(nbuff = fmap_need_off_once(map, start_of_stuff, 20))) break;",
          "2670:  src = nbuff;",
          "2671:  if (!cli_readint32(nbuff)) {",
          "2673:      src+=4;",
          "2674:  }",
          "2676:  ssize = cli_readint32(src+5)|0xff;",
          "2677:  dsize = cli_readint32(src+9);",
          "2679:  CLI_UNPSIZELIMITS(\"NsPack\", MAX(ssize,dsize));",
          "2681:  if (!ssize || !dsize || dsize != exe_sections[0].vsz) break;",
          "2682:  if (!(dest=cli_malloc(dsize))) {",
          "2683:         cli_errmsg(\"NsPack: Unable to allocate memory for dest %u\\n\", dsize);",
          "2684:         break;",
          "2685:     }",
          "2688:  if(!(src = fmap_need_off(map, start_of_stuff, ssize))) {",
          "2689:      free(dest);",
          "2690:      break;",
          "2691:  }",
          "2694:  eprva+=0x27a;",
          "2695:  if (!(rep = cli_rawaddr(eprva, exe_sections, nsections, &err, fsize, hdr_size)) && err) {",
          "2696:    free(dest);",
          "2697:    break;",
          "2698:  }",
          "2699:  if(!(nbuff = fmap_need_off_once(map, rep, 5))) {",
          "2700:    free(dest);",
          "2701:    break;",
          "2702:  }",
          "2703:  fmap_unneed_off(map, start_of_stuff, ssize);",
          "2704:  eprva=eprva+5+cli_readint32(nbuff+1);",
          "2705:  cli_dbgmsg(\"NsPack: OEP = %08x\\n\", eprva);",
          "2708:     cli_jsonstr(pe_json, \"Packer\", \"NsPack\");",
          "2711:  CLI_UNPTEMP(\"NsPack\",(dest,exe_sections,0));",
          "2712:  CLI_UNPRESULTS(\"NsPack\",(unspack(src, dest, ctx, exe_sections[0].rva, EC32(optional_hdr32.ImageBase), eprva, ndesc)),0,(dest,0));",
          "2713:  break;",
          "2727:  cli_errmsg(\"cli_scanpe: can't allocate memory for bc_ctx\\n\");",
          "2728:  return CL_EMEM;",
          "2734:  case CL_VIRUS:",
          "2735:      free(exe_sections);",
          "2736:      cli_bytecode_context_destroy(bc_ctx);",
          "2737:      return CL_VIRUS;",
          "2738:  case CL_SUCCESS:",
          "2739:      ndesc = cli_bytecode_context_getresult_file(bc_ctx, &tempfile);",
          "2740:      cli_bytecode_context_destroy(bc_ctx);",
          "2741:      if (ndesc != -1 && tempfile) {",
          "2742:   CLI_UNPRESULTS(\"bytecode PE hook\", 1, 1, (0));",
          "2743:      }",
          "2744:      break;",
          "2745:  default:",
          "2746:      cli_bytecode_context_destroy(bc_ctx);",
          "2751:     if (cli_json_timeout_cycle_check(ctx, &toval) != CL_SUCCESS) {",
          "2753:     }",
          "2756:  return CL_VIRUS;",
          "",
          "[Added Lines]",
          "2752:         CLI_UNPTEMP(\"Aspack\",(src,exe_sections,0));",
          "2753:         CLI_UNPRESULTS(\"Aspack\",(unaspack212((uint8_t *)src, ssize, exe_sections, nsections, vep-1, EC32(optional_hdr32.ImageBase), ndesc)),1,(src,0));",
          "2754:         break;",
          "2760:         uint32_t eprva = vep;",
          "2761:         uint32_t start_of_stuff, rep = ep;",
          "2762:         unsigned int nowinldr;",
          "2763:         const char *nbuff;",
          "2765:         src=epbuff;",
          "2767:             eprva = cli_readint32(epbuff+1)+vep+5;",
          "2768:             if (!(rep = cli_rawaddr(eprva, exe_sections, nsections, &err, fsize, hdr_size)) && err)",
          "2769:                 break;",
          "2771:             if (!(nbuff = fmap_need_off_once(map, rep, 24)))",
          "2772:                 break;",
          "2774:             src = nbuff;",
          "2775:         }",
          "2777:         if (memcmp(src, \"\\x9c\\x60\\xe8\\x00\\x00\\x00\\x00\\x5d\\xb8\\x07\\x00\\x00\\x00\", 13))",
          "2778:             break;",
          "2780:         nowinldr = 0x54-cli_readint32(src+17);",
          "2781:         cli_dbgmsg(\"NsPack: Found *start_of_stuff @delta-%x\\n\", nowinldr);",
          "2783:         if(!(nbuff = fmap_need_off_once(map, rep-nowinldr, 4)))",
          "2784:             break;",
          "2786:         start_of_stuff=rep+cli_readint32(nbuff);",
          "2787:         if(!(nbuff = fmap_need_off_once(map, start_of_stuff, 20)))",
          "2788:             break;",
          "2790:         src = nbuff;",
          "2791:         if (!cli_readint32(nbuff)) {",
          "2793:             src+=4;",
          "2794:         }",
          "2796:         ssize = cli_readint32(src+5)|0xff;",
          "2797:         dsize = cli_readint32(src+9);",
          "2799:         CLI_UNPSIZELIMITS(\"NsPack\", MAX(ssize,dsize));",
          "2801:         if (!ssize || !dsize || dsize != exe_sections[0].vsz)",
          "2802:             break;",
          "2804:         if (!(dest=cli_malloc(dsize))) {",
          "2805:             cli_errmsg(\"NsPack: Unable to allocate memory for dest %u\\n\", dsize);",
          "2806:             break;",
          "2807:         }",
          "2810:         if(!(src = fmap_need_off(map, start_of_stuff, ssize))) {",
          "2811:             free(dest);",
          "2812:             break;",
          "2813:         }",
          "2816:         eprva+=0x27a;",
          "2817:         if (!(rep = cli_rawaddr(eprva, exe_sections, nsections, &err, fsize, hdr_size)) && err) {",
          "2818:           free(dest);",
          "2819:           break;",
          "2820:         }",
          "2822:         if(!(nbuff = fmap_need_off_once(map, rep, 5))) {",
          "2823:           free(dest);",
          "2824:           break;",
          "2825:         }",
          "2827:         fmap_unneed_off(map, start_of_stuff, ssize);",
          "2828:         eprva=eprva+5+cli_readint32(nbuff+1);",
          "2829:         cli_dbgmsg(\"NsPack: OEP = %08x\\n\", eprva);",
          "2832:         cli_jsonstr(pe_json, \"Packer\", \"NsPack\");",
          "2835:         CLI_UNPTEMP(\"NsPack\",(dest,exe_sections,0));",
          "2836:         CLI_UNPRESULTS(\"NsPack\",(unspack(src, dest, ctx, exe_sections[0].rva, EC32(optional_hdr32.ImageBase), eprva, ndesc)),0,(dest,0));",
          "2837:         break;",
          "2848:         cli_errmsg(\"cli_scanpe: can't allocate memory for bc_ctx\\n\");",
          "2849:         return CL_EMEM;",
          "2857:     case CL_VIRUS:",
          "2858:         free(exe_sections);",
          "2859:         cli_bytecode_context_destroy(bc_ctx);",
          "2860:         return CL_VIRUS;",
          "2861:     case CL_SUCCESS:",
          "2862:         ndesc = cli_bytecode_context_getresult_file(bc_ctx, &tempfile);",
          "2863:         cli_bytecode_context_destroy(bc_ctx);",
          "2864:         if (ndesc != -1 && tempfile) {",
          "2865:             CLI_UNPRESULTS(\"bytecode PE hook\", 1, 1, (0));",
          "2866:         }",
          "2868:         break;",
          "2869:     default:",
          "2870:         cli_bytecode_context_destroy(bc_ctx);",
          "2876:     if (cli_json_timeout_cycle_check(ctx, &toval) != CL_SUCCESS)",
          "2881:         return CL_VIRUS;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "182c2d69031e27380c23a662b68617c51e291625",
      "candidate_info": {
        "commit_hash": "182c2d69031e27380c23a662b68617c51e291625",
        "repo": "vrtadmin/clamav-devel",
        "commit_url": "https://github.com/vrtadmin/clamav-devel/commit/182c2d69031e27380c23a662b68617c51e291625",
        "files": [
          "libclamav/pe.c"
        ],
        "message": "Adjust the logic surrounding adjusting the PE section sizes",
        "before_after_code_files": [
          "libclamav/pe.c||libclamav/pe.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "libclamav/pe.c||libclamav/pe.c"
          ],
          "candidate": [
            "libclamav/pe.c||libclamav/pe.c"
          ]
        }
      },
      "candidate_diff": {
        "libclamav/pe.c||libclamav/pe.c": [
          "File: libclamav/pe.c -> libclamav/pe.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1212:             exe_sections[i].ursz = EC32(section_hdr[i].SizeOfRawData);",
          "1217:                     cli_dbgmsg(\"Broken PE file - Section %d starts or exists beyond the end of file (Offset@ %lu, Total filesize %lu)\\n\", i, (unsigned long)exe_sections[i].raw, (unsigned long)fsize);",
          "1218:                     if (nsections == 1) {",
          "1219:                         free(section_hdr);",
          "",
          "[Removed Lines]",
          "1215:                 if (!CLI_ISCONTAINED(0, fsize, exe_sections[i].uraw, exe_sections[i].ursz)",
          "1216:                     || exe_sections[i].raw >= fsize) {",
          "",
          "[Added Lines]",
          "1215:                 if (exe_sections[i].raw >= fsize || exe_sections[i].uraw > fsize) {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1237:                     rescan=1;",
          "1238:                     break;",
          "1239:                 }",
          "1240:             }",
          "1241:         }",
          "1242:     }",
          "1245:         strncpy(sname, (char *) section_hdr[i].Name, 8);",
          "1246:         sname[8] = 0;",
          "",
          "[Removed Lines]",
          "1244:         for(i = 0; i < nsections; i++) {",
          "",
          "[Added Lines]",
          "1240:                 if (!CLI_ISCONTAINED(0, (uint32_t) fsize, exe_sections[i].raw, exe_sections[i].rsz))",
          "1241:                     exe_sections[i].rsz = fsize - exe_sections[i].raw;",
          "1243:                 if (!CLI_ISCONTAINED(0, fsize, exe_sections[i].uraw, exe_sections[i].ursz))",
          "1244:                     exe_sections[i].ursz = fsize - exe_sections[i].uraw;",
          "1249:     for(i = 0; i < nsections; i++) {",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1258:         if (!exe_sections[i].vsz && exe_sections[i].rsz)",
          "1259:             exe_sections[i].vsz=PESALIGN(exe_sections[i].ursz, valign);",
          "1264:         cli_dbgmsg(\"Section %d\\n\", i);",
          "1265:         cli_dbgmsg(\"Section name: %s\\n\", sname);",
          "1266:         cli_dbgmsg(\"Section data (from headers - in memory)\\n\");",
          "",
          "[Removed Lines]",
          "1261:         if (exe_sections[i].rsz && fsize>exe_sections[i].raw && !CLI_ISCONTAINED(0, (uint32_t) fsize, exe_sections[i].raw, exe_sections[i].rsz))",
          "1262:             exe_sections[i].rsz = fsize - exe_sections[i].raw;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "be37d606d26cc05950b48d39ce5a85ddc4351897",
      "candidate_info": {
        "commit_hash": "be37d606d26cc05950b48d39ce5a85ddc4351897",
        "repo": "vrtadmin/clamav-devel",
        "commit_url": "https://github.com/vrtadmin/clamav-devel/commit/be37d606d26cc05950b48d39ce5a85ddc4351897",
        "files": [
          "libclamav/pe.c"
        ],
        "message": "Merge fix from security/bb11155 branch",
        "before_after_code_files": [
          "libclamav/pe.c||libclamav/pe.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "libclamav/pe.c||libclamav/pe.c"
          ],
          "candidate": [
            "libclamav/pe.c||libclamav/pe.c"
          ]
        }
      },
      "candidate_diff": {
        "libclamav/pe.c||libclamav/pe.c": [
          "File: libclamav/pe.c -> libclamav/pe.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "737:  char sname[9], epbuff[4096], *tempfile;",
          "738:  uint32_t epsize;",
          "739:  ssize_t bytes, at;",
          "741:  unsigned int ssize = 0, dsize = 0, dll = 0, pe_plus = 0, corrupted_cur;",
          "742:  int (*upxfn)(const char *, uint32_t, char *, uint32_t *, uint32_t, uint32_t, uint32_t) = NULL;",
          "743:  const char *src = NULL;",
          "744:  char *dest = NULL;",
          "745:  int ndesc, ret = CL_CLEAN, upack = 0, native=0;",
          "746:  size_t fsize;",
          "748:  struct cli_exe_section *exe_sections;",
          "749:  char timestr[32];",
          "750:  struct pe_image_data_dir *dirs;",
          "",
          "[Removed Lines]",
          "740:  unsigned int i, found, upx_success = 0, min = 0, max = 0, err, overlays = 0;",
          "747:  uint32_t valign, falign, hdr_size, j;",
          "",
          "[Added Lines]",
          "740:  unsigned int i, j, found, upx_success = 0, min = 0, max = 0, err, overlays = 0, rescan = 1;",
          "747:  uint32_t valign, falign, hdr_size;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1238:     cli_jsonint(pe_json, \"NumberOfSections\", nsections);",
          "1239: #endif",
          "1241:     for(i = 0; i < nsections; i++) {",
          "1254: #if HAVE_JSON",
          "1255:         add_section_info(ctx, &exe_sections[i]);",
          "",
          "[Removed Lines]",
          "1242:  strncpy(sname, (char *) section_hdr[i].Name, 8);",
          "1243:  sname[8] = 0;",
          "1244:  exe_sections[i].rva = PEALIGN(EC32(section_hdr[i].VirtualAddress), valign);",
          "1245:  exe_sections[i].vsz = PESALIGN(EC32(section_hdr[i].VirtualSize), valign);",
          "1246:  exe_sections[i].raw = PEALIGN(EC32(section_hdr[i].PointerToRawData), falign);",
          "1247:  exe_sections[i].rsz = PESALIGN(EC32(section_hdr[i].SizeOfRawData), falign);",
          "1248:  exe_sections[i].chr = EC32(section_hdr[i].Characteristics);",
          "1250:  exe_sections[i].uvsz = EC32(section_hdr[i].VirtualSize);",
          "1251:  exe_sections[i].uraw = EC32(section_hdr[i].PointerToRawData);",
          "1252:  exe_sections[i].ursz = EC32(section_hdr[i].SizeOfRawData);",
          "",
          "[Added Lines]",
          "1241:     while (rescan==1) {",
          "1242:         rescan=0;",
          "1243:         for (i=0; i < nsections; i++) {",
          "1244:             exe_sections[i].rva = PEALIGN(EC32(section_hdr[i].VirtualAddress), valign);",
          "1245:             exe_sections[i].vsz = PESALIGN(EC32(section_hdr[i].VirtualSize), valign);",
          "1246:             exe_sections[i].raw = PEALIGN(EC32(section_hdr[i].PointerToRawData), falign);",
          "1247:             exe_sections[i].rsz = PESALIGN(EC32(section_hdr[i].SizeOfRawData), falign);",
          "1248:             exe_sections[i].chr = EC32(section_hdr[i].Characteristics);",
          "1250:             exe_sections[i].uvsz = EC32(section_hdr[i].VirtualSize);",
          "1251:             exe_sections[i].uraw = EC32(section_hdr[i].PointerToRawData);",
          "1252:             exe_sections[i].ursz = EC32(section_hdr[i].SizeOfRawData);",
          "1255:                 if (!CLI_ISCONTAINED(0, fsize, exe_sections[i].uraw, exe_sections[i].ursz)",
          "1256:                     || exe_sections[i].raw >= fsize) {",
          "1257:                     cli_dbgmsg(\"Broken PE file - Section %d starts or exists beyond the end of file (Offset@ %lu, Total filesize %lu)\\n\", i, (unsigned long)exe_sections[i].raw, (unsigned long)fsize);",
          "1258:                     if (nsections == 1) {",
          "1259:                         free(section_hdr);",
          "1260:                         free(exe_sections);",
          "1262:                         if(DETECT_BROKEN_PE) {",
          "1263:                             cli_append_virus(ctx, \"Heuristics.Broken.Executable\");",
          "1264:                             return CL_VIRUS;",
          "1265:                         }",
          "1268:                     }",
          "1270:                     for (j=i; j < nsections-1; j++)",
          "1271:                         memcpy(&exe_sections[j], &exe_sections[j+1], sizeof(struct cli_exe_section));",
          "1273:                     for (j=i; j < nsections-1; j++)",
          "1274:                         memcpy(&section_hdr[j], &section_hdr[j+1], sizeof(struct pe_image_section_hdr));",
          "1276:                     nsections--;",
          "1277:                     rescan=1;",
          "1278:                     break;",
          "1279:                 }",
          "1280:             }",
          "1281:         }",
          "1282:     }",
          "1285:         strncpy(sname, (char *) section_hdr[i].Name, 8);",
          "1286:         sname[8] = 0;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1304:  }",
          "1319:      if(SCAN_ALGO && (DCONF & PE_CONF_POLIPOS) && !*sname && exe_sections[i].vsz > 40000 && exe_sections[i].vsz < 70000 && exe_sections[i].chr == 0xe0000060) polipos = i;",
          "",
          "[Removed Lines]",
          "1308:        cli_dbgmsg(\"Broken PE file - Section %d starts beyond the end of file (Offset@ %lu, Total filesize %lu)\\n\", i, (unsigned long)exe_sections[i].raw, (unsigned long)fsize);",
          "1309:        cli_dbgmsg(\"------------------------------------\\n\");",
          "1310:   free(section_hdr);",
          "1311:   free(exe_sections);",
          "1312:   if(DETECT_BROKEN_PE) {",
          "1313:       cli_append_virus(ctx, \"Heuristics.Broken.Executable\");",
          "1314:       return CL_VIRUS;",
          "1315:   }",
          "1317:      }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "31e820115753cf8a1fc87e9cf16389fb74373546",
      "candidate_info": {
        "commit_hash": "31e820115753cf8a1fc87e9cf16389fb74373546",
        "repo": "vrtadmin/clamav-devel",
        "commit_url": "https://github.com/vrtadmin/clamav-devel/commit/31e820115753cf8a1fc87e9cf16389fb74373546",
        "files": [
          "libclamav/pe.c"
        ],
        "message": "Merge fix from security/bb11155 branch",
        "before_after_code_files": [
          "libclamav/pe.c||libclamav/pe.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "libclamav/pe.c||libclamav/pe.c"
          ],
          "candidate": [
            "libclamav/pe.c||libclamav/pe.c"
          ]
        }
      },
      "candidate_diff": {
        "libclamav/pe.c||libclamav/pe.c": [
          "File: libclamav/pe.c -> libclamav/pe.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "737:  char sname[9], epbuff[4096], *tempfile;",
          "738:  uint32_t epsize;",
          "739:  ssize_t bytes, at;",
          "741:  unsigned int ssize = 0, dsize = 0, dll = 0, pe_plus = 0, corrupted_cur;",
          "742:  int (*upxfn)(const char *, uint32_t, char *, uint32_t *, uint32_t, uint32_t, uint32_t) = NULL;",
          "743:  const char *src = NULL;",
          "744:  char *dest = NULL;",
          "745:  int ndesc, ret = CL_CLEAN, upack = 0, native=0;",
          "746:  size_t fsize;",
          "748:  struct cli_exe_section *exe_sections;",
          "749:  char timestr[32];",
          "750:  struct pe_image_data_dir *dirs;",
          "",
          "[Removed Lines]",
          "740:  unsigned int i, found, upx_success = 0, min = 0, max = 0, err, overlays = 0;",
          "747:  uint32_t valign, falign, hdr_size, j;",
          "",
          "[Added Lines]",
          "740:  unsigned int i, j, found, upx_success = 0, min = 0, max = 0, err, overlays = 0, rescan = 1;",
          "747:  uint32_t valign, falign, hdr_size;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1238:     cli_jsonint(pe_json, \"NumberOfSections\", nsections);",
          "1239: #endif",
          "1241:     for(i = 0; i < nsections; i++) {",
          "1254: #if HAVE_JSON",
          "1255:         add_section_info(ctx, &exe_sections[i]);",
          "",
          "[Removed Lines]",
          "1242:  strncpy(sname, (char *) section_hdr[i].Name, 8);",
          "1243:  sname[8] = 0;",
          "1244:  exe_sections[i].rva = PEALIGN(EC32(section_hdr[i].VirtualAddress), valign);",
          "1245:  exe_sections[i].vsz = PESALIGN(EC32(section_hdr[i].VirtualSize), valign);",
          "1246:  exe_sections[i].raw = PEALIGN(EC32(section_hdr[i].PointerToRawData), falign);",
          "1247:  exe_sections[i].rsz = PESALIGN(EC32(section_hdr[i].SizeOfRawData), falign);",
          "1248:  exe_sections[i].chr = EC32(section_hdr[i].Characteristics);",
          "1250:  exe_sections[i].uvsz = EC32(section_hdr[i].VirtualSize);",
          "1251:  exe_sections[i].uraw = EC32(section_hdr[i].PointerToRawData);",
          "1252:  exe_sections[i].ursz = EC32(section_hdr[i].SizeOfRawData);",
          "",
          "[Added Lines]",
          "1241:     while (rescan==1) {",
          "1242:         rescan=0;",
          "1243:         for (i=0; i < nsections; i++) {",
          "1244:             exe_sections[i].rva = PEALIGN(EC32(section_hdr[i].VirtualAddress), valign);",
          "1245:             exe_sections[i].vsz = PESALIGN(EC32(section_hdr[i].VirtualSize), valign);",
          "1246:             exe_sections[i].raw = PEALIGN(EC32(section_hdr[i].PointerToRawData), falign);",
          "1247:             exe_sections[i].rsz = PESALIGN(EC32(section_hdr[i].SizeOfRawData), falign);",
          "1248:             exe_sections[i].chr = EC32(section_hdr[i].Characteristics);",
          "1250:             exe_sections[i].uvsz = EC32(section_hdr[i].VirtualSize);",
          "1251:             exe_sections[i].uraw = EC32(section_hdr[i].PointerToRawData);",
          "1252:             exe_sections[i].ursz = EC32(section_hdr[i].SizeOfRawData);",
          "1255:                 if (!CLI_ISCONTAINED(0, fsize, exe_sections[i].uraw, exe_sections[i].ursz)",
          "1256:                     || exe_sections[i].raw >= fsize) {",
          "1257:                     cli_dbgmsg(\"Broken PE file - Section %d starts or exists beyond the end of file (Offset@ %lu, Total filesize %lu)\\n\", i, (unsigned long)exe_sections[i].raw, (unsigned long)fsize);",
          "1258:                     if (nsections == 1) {",
          "1259:                         free(section_hdr);",
          "1260:                         free(exe_sections);",
          "1262:                         if(DETECT_BROKEN_PE) {",
          "1263:                             cli_append_virus(ctx, \"Heuristics.Broken.Executable\");",
          "1264:                             return CL_VIRUS;",
          "1265:                         }",
          "1268:                     }",
          "1270:                     for (j=i; j < nsections-1; j++)",
          "1271:                         memcpy(&exe_sections[j], &exe_sections[j+1], sizeof(struct cli_exe_section));",
          "1273:                     for (j=i; j < nsections-1; j++)",
          "1274:                         memcpy(&section_hdr[j], &section_hdr[j+1], sizeof(struct pe_image_section_hdr));",
          "1276:                     nsections--;",
          "1277:                     rescan=1;",
          "1278:                     break;",
          "1279:                 }",
          "1280:             }",
          "1281:         }",
          "1282:     }",
          "1285:         strncpy(sname, (char *) section_hdr[i].Name, 8);",
          "1286:         sname[8] = 0;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1304:  }",
          "1319:      if(SCAN_ALGO && (DCONF & PE_CONF_POLIPOS) && !*sname && exe_sections[i].vsz > 40000 && exe_sections[i].vsz < 70000 && exe_sections[i].chr == 0xe0000060) polipos = i;",
          "",
          "[Removed Lines]",
          "1308:        cli_dbgmsg(\"Broken PE file - Section %d starts beyond the end of file (Offset@ %lu, Total filesize %lu)\\n\", i, (unsigned long)exe_sections[i].raw, (unsigned long)fsize);",
          "1309:        cli_dbgmsg(\"------------------------------------\\n\");",
          "1310:   free(section_hdr);",
          "1311:   free(exe_sections);",
          "1312:   if(DETECT_BROKEN_PE) {",
          "1313:       cli_append_virus(ctx, \"Heuristics.Broken.Executable\");",
          "1314:       return CL_VIRUS;",
          "1315:   }",
          "1317:      }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2013-1943",
  "cve_desc": "The KVM subsystem in the Linux kernel before 3.0 does not check whether kernel addresses are specified during allocation of memory slots for use in a guest's physical address space, which allows local users to gain privileges or obtain sensitive information from kernel memory via a crafted application, related to arch/x86/kvm/paging_tmpl.h and virt/kvm/kvm_main.c.",
  "repo": "torvalds/linux",
  "patch_hash": "fa3d315a4ce2c0891cdde262562e710d95fba19e",
  "patch_info": {
    "commit_hash": "fa3d315a4ce2c0891cdde262562e710d95fba19e",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/fa3d315a4ce2c0891cdde262562e710d95fba19e",
    "files": [
      "arch/x86/kvm/paging_tmpl.h",
      "virt/kvm/kvm_main.c"
    ],
    "message": "KVM: Validate userspace_addr of memslot when registered\n\nThis way, we can avoid checking the user space address many times when\nwe read the guest memory.\n\nAlthough we can do the same for write if we check which slots are\nwritable, we do not care write now: reading the guest memory happens\nmore often than writing.\n\n[avi: change VERIFY_READ to VERIFY_WRITE]\n\nSigned-off-by: Takuya Yoshikawa <yoshikawa.takuya@oss.ntt.co.jp>\nSigned-off-by: Avi Kivity <avi@redhat.com>",
    "before_after_code_files": [
      "arch/x86/kvm/paging_tmpl.h||arch/x86/kvm/paging_tmpl.h",
      "virt/kvm/kvm_main.c||virt/kvm/kvm_main.c"
    ]
  },
  "patch_diff": {
    "arch/x86/kvm/paging_tmpl.h||arch/x86/kvm/paging_tmpl.h": [
      "File: arch/x86/kvm/paging_tmpl.h -> arch/x86/kvm/paging_tmpl.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "185:   }",
      "187:   ptep_user = (pt_element_t __user *)((void *)host_addr + offset);",
      "189:    present = false;",
      "190:    break;",
      "191:   }",
      "",
      "[Removed Lines]",
      "188:   if (unlikely(copy_from_user(&pte, ptep_user, sizeof(pte)))) {",
      "",
      "[Added Lines]",
      "188:   if (unlikely(__copy_from_user(&pte, ptep_user, sizeof(pte)))) {",
      "",
      "---------------"
    ],
    "virt/kvm/kvm_main.c||virt/kvm/kvm_main.c": [
      "File: virt/kvm/kvm_main.c -> virt/kvm/kvm_main.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "648:   goto out;",
      "649:  if (mem->guest_phys_addr & (PAGE_SIZE - 1))",
      "650:   goto out;",
      "652:   goto out;",
      "653:  if (mem->slot >= KVM_MEMORY_SLOTS + KVM_PRIVATE_MEM_SLOTS)",
      "654:   goto out;",
      "",
      "[Removed Lines]",
      "651:  if (user_alloc && (mem->userspace_addr & (PAGE_SIZE - 1)))",
      "",
      "[Added Lines]",
      "652:  if (user_alloc &&",
      "653:      ((mem->userspace_addr & (PAGE_SIZE - 1)) ||",
      "654:       !access_ok(VERIFY_WRITE, mem->userspace_addr, mem->memory_size)))",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "1283:  addr = gfn_to_hva(kvm, gfn);",
      "1284:  if (kvm_is_error_hva(addr))",
      "1285:   return -EFAULT;",
      "1287:  if (r)",
      "1288:   return -EFAULT;",
      "1289:  return 0;",
      "",
      "[Removed Lines]",
      "1286:  r = copy_from_user(data, (void __user *)addr + offset, len);",
      "",
      "[Added Lines]",
      "1289:  r = __copy_from_user(data, (void __user *)addr + offset, len);",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "9e3bb6b6f6a0c535eb053fbf0005a8e79e053374",
      "candidate_info": {
        "commit_hash": "9e3bb6b6f6a0c535eb053fbf0005a8e79e053374",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/9e3bb6b6f6a0c535eb053fbf0005a8e79e053374",
        "files": [
          "virt/kvm/kvm_main.c"
        ],
        "message": "KVM: add missing void __user * cast to access_ok() call\n\nfa3d315a \"KVM: Validate userspace_addr of memslot when registered\" introduced\nthis new warning onn s390:\n\nkvm_main.c: In function '__kvm_set_memory_region':\nkvm_main.c:654:7: warning: passing argument 1 of '__access_ok' makes pointer from integer without a cast\narch/s390/include/asm/uaccess.h:53:19: note: expected 'const void *' but argument is of type '__u64'\n\nAdd the missing cast to get rid of it again...\n\nCc: Takuya Yoshikawa <yoshikawa.takuya@oss.ntt.co.jp>\nSigned-off-by: Heiko Carstens <heiko.carstens@de.ibm.com>\nSigned-off-by: Avi Kivity <avi@redhat.com>",
        "before_after_code_files": [
          "virt/kvm/kvm_main.c||virt/kvm/kvm_main.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "virt/kvm/kvm_main.c||virt/kvm/kvm_main.c"
          ],
          "candidate": [
            "virt/kvm/kvm_main.c||virt/kvm/kvm_main.c"
          ]
        }
      },
      "candidate_diff": {
        "virt/kvm/kvm_main.c||virt/kvm/kvm_main.c": [
          "File: virt/kvm/kvm_main.c -> virt/kvm/kvm_main.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "652:  if (user_alloc &&",
          "653:      ((mem->userspace_addr & (PAGE_SIZE - 1)) ||",
          "655:   goto out;",
          "656:  if (mem->slot >= KVM_MEMORY_SLOTS + KVM_PRIVATE_MEM_SLOTS)",
          "657:   goto out;",
          "",
          "[Removed Lines]",
          "654:       !access_ok(VERIFY_WRITE, mem->userspace_addr, mem->memory_size)))",
          "",
          "[Added Lines]",
          "654:       !access_ok(VERIFY_WRITE,",
          "655:    (void __user *)(unsigned long)mem->userspace_addr,",
          "656:    mem->memory_size)))",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "781e0743af3c5ba356d55bc60df59f2dded1e938",
      "candidate_info": {
        "commit_hash": "781e0743af3c5ba356d55bc60df59f2dded1e938",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/781e0743af3c5ba356d55bc60df59f2dded1e938",
        "files": [
          "arch/x86/kvm/paging_tmpl.h"
        ],
        "message": "KVM: MMU: Add unlikely() annotations to walk_addr_generic()\n\nwalk_addr_generic() is a hot path and is also hard for the cpu to predict -\nsome of the parameters (fetch_fault in particular) vary wildly from\ninvocation to invocation.\n\nAdd unlikely() annotations where appropriate; all walk failures are\nconsidered unlikely, as are cases where we have to mark the accessed or\ndirty bit, as they are slow paths both in kvm and on real processors.\n\nSigned-off-by: Avi Kivity <avi@redhat.com>",
        "before_after_code_files": [
          "arch/x86/kvm/paging_tmpl.h||arch/x86/kvm/paging_tmpl.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "arch/x86/kvm/paging_tmpl.h||arch/x86/kvm/paging_tmpl.h"
          ],
          "candidate": [
            "arch/x86/kvm/paging_tmpl.h||arch/x86/kvm/paging_tmpl.h"
          ]
        }
      },
      "candidate_diff": {
        "arch/x86/kvm/paging_tmpl.h||arch/x86/kvm/paging_tmpl.h": [
          "File: arch/x86/kvm/paging_tmpl.h -> arch/x86/kvm/paging_tmpl.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "173:   real_gfn = mmu->translate_gpa(vcpu, gfn_to_gpa(table_gfn),",
          "174:            PFERR_USER_MASK|PFERR_WRITE_MASK);",
          "176:    present = false;",
          "177:    break;",
          "178:   }",
          "179:   real_gfn = gpa_to_gfn(real_gfn);",
          "181:   host_addr = gfn_to_hva(vcpu->kvm, real_gfn);",
          "183:    present = false;",
          "184:    break;",
          "185:   }",
          "187:   ptep_user = (pt_element_t __user *)((void *)host_addr + offset);",
          "189:    present = false;",
          "190:    break;",
          "191:   }",
          "193:   trace_kvm_mmu_paging_element(pte, walker->level);",
          "196:    present = false;",
          "197:    break;",
          "198:   }",
          "201:    rsvd_fault = true;",
          "202:    break;",
          "203:   }",
          "210:    eperm = true;",
          "212: #if PTTYPE == 64",
          "214:    eperm = true;",
          "215: #endif",
          "218:    int ret;",
          "219:    trace_kvm_mmu_set_accessed_bit(table_gfn, index,",
          "220:              sizeof(pte));",
          "",
          "[Removed Lines]",
          "175:   if (real_gfn == UNMAPPED_GVA) {",
          "182:   if (kvm_is_error_hva(host_addr)) {",
          "188:   if (get_user(pte, ptep_user)) {",
          "195:   if (!is_present_gpte(pte)) {",
          "200:   if (is_rsvd_bits_set(&vcpu->arch.mmu, pte, walker->level)) {",
          "205:   if (write_fault && !is_writable_pte(pte))",
          "206:    if (user_fault || is_write_protection(vcpu))",
          "207:     eperm = true;",
          "209:   if (user_fault && !(pte & PT_USER_MASK))",
          "213:   if (fetch_fault && (pte & PT64_NX_MASK))",
          "217:   if (!eperm && !rsvd_fault && !(pte & PT_ACCESSED_MASK)) {",
          "",
          "[Added Lines]",
          "175:   if (unlikely(real_gfn == UNMAPPED_GVA)) {",
          "182:   if (unlikely(kvm_is_error_hva(host_addr))) {",
          "188:   if (unlikely(get_user(pte, ptep_user))) {",
          "195:   if (unlikely(!is_present_gpte(pte))) {",
          "200:   if (unlikely(is_rsvd_bits_set(&vcpu->arch.mmu, pte,",
          "201:            walker->level))) {",
          "206:   if (unlikely(write_fault && !is_writable_pte(pte)",
          "207:         && (user_fault || is_write_protection(vcpu))))",
          "208:    eperm = true;",
          "210:   if (unlikely(user_fault && !(pte & PT_USER_MASK)))",
          "214:   if (unlikely(fetch_fault && (pte & PT64_NX_MASK)))",
          "218:   if (!eperm && !rsvd_fault",
          "219:       && unlikely(!(pte & PT_ACCESSED_MASK))) {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "270:   --walker->level;",
          "271:  }",
          "274:   goto error;",
          "277:   int ret;",
          "279:   trace_kvm_mmu_set_dirty_bit(table_gfn, index, sizeof(pte));",
          "",
          "[Removed Lines]",
          "273:  if (!present || eperm || rsvd_fault)",
          "276:  if (write_fault && !is_dirty_gpte(pte)) {",
          "",
          "[Added Lines]",
          "275:  if (unlikely(!present || eperm || rsvd_fault))",
          "278:  if (write_fault && unlikely(!is_dirty_gpte(pte))) {",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "6e2ca7d1802bf8ed9908435e34daa116662e7790",
      "candidate_info": {
        "commit_hash": "6e2ca7d1802bf8ed9908435e34daa116662e7790",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/6e2ca7d1802bf8ed9908435e34daa116662e7790",
        "files": [
          "arch/x86/kvm/paging_tmpl.h"
        ],
        "message": "KVM: MMU: Optimize guest page table walk\n\nThis patch optimizes the guest page table walk by using get_user()\ninstead of copy_from_user().\n\nWith this patch applied, paging64_walk_addr_generic() has become\nabout 0.5us to 1.0us faster on my Phenom II machine with NPT on.\n\nSigned-off-by: Takuya Yoshikawa <yoshikawa.takuya@oss.ntt.co.jp>\nSigned-off-by: Avi Kivity <avi@redhat.com>",
        "before_after_code_files": [
          "arch/x86/kvm/paging_tmpl.h||arch/x86/kvm/paging_tmpl.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "arch/x86/kvm/paging_tmpl.h||arch/x86/kvm/paging_tmpl.h"
          ],
          "candidate": [
            "arch/x86/kvm/paging_tmpl.h||arch/x86/kvm/paging_tmpl.h"
          ]
        }
      },
      "candidate_diff": {
        "arch/x86/kvm/paging_tmpl.h||arch/x86/kvm/paging_tmpl.h": [
          "File: arch/x86/kvm/paging_tmpl.h -> arch/x86/kvm/paging_tmpl.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "123:         gva_t addr, u32 access)",
          "124: {",
          "125:  pt_element_t pte;",
          "126:  gfn_t table_gfn;",
          "127:  unsigned index, pt_access, uninitialized_var(pte_access);",
          "128:  gpa_t pte_gpa;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "126:  pt_element_t __user *ptep_user;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "158:  pt_access = ACC_ALL;",
          "160:  for (;;) {",
          "161:   index = PT_INDEX(addr, walker->level);",
          "163:   table_gfn = gpte_to_gfn(pte);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "162:   gfn_t real_gfn;",
          "163:   unsigned long host_addr;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "166:   walker->table_gfn[walker->level - 1] = table_gfn;",
          "167:   walker->pte_gpa[walker->level - 1] = pte_gpa;",
          "172:    present = false;",
          "173:    break;",
          "174:   }",
          "",
          "[Removed Lines]",
          "169:   if (kvm_read_guest_page_mmu(vcpu, mmu, table_gfn, &pte,",
          "170:          offset, sizeof(pte),",
          "171:          PFERR_USER_MASK|PFERR_WRITE_MASK)) {",
          "",
          "[Added Lines]",
          "173:   real_gfn = mmu->translate_gpa(vcpu, gfn_to_gpa(table_gfn),",
          "174:            PFERR_USER_MASK|PFERR_WRITE_MASK);",
          "175:   if (real_gfn == UNMAPPED_GVA) {",
          "176:    present = false;",
          "177:    break;",
          "178:   }",
          "179:   real_gfn = gpa_to_gfn(real_gfn);",
          "181:   host_addr = gfn_to_hva(vcpu->kvm, real_gfn);",
          "182:   if (kvm_is_error_hva(host_addr)) {",
          "183:    present = false;",
          "184:    break;",
          "185:   }",
          "187:   ptep_user = (pt_element_t __user *)((void *)host_addr + offset);",
          "188:   if (get_user(pte, ptep_user)) {",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2020-15121",
  "cve_desc": "In radare2 before version 4.5.0, malformed PDB file names in the PDB server path cause shell injection. To trigger the problem it's required to open the executable in radare2 and run idpd to trigger the download. The shell code will execute, and will create a file called pwned in the current directory.",
  "repo": "radareorg/radare2",
  "patch_hash": "04edfa82c1f3fa2bc3621ccdad2f93bdbf00e4f9",
  "patch_info": {
    "commit_hash": "04edfa82c1f3fa2bc3621ccdad2f93bdbf00e4f9",
    "repo": "radareorg/radare2",
    "commit_url": "https://github.com/radareorg/radare2/commit/04edfa82c1f3fa2bc3621ccdad2f93bdbf00e4f9",
    "files": [
      "libr/bin/pdb/pdb_downloader.c",
      "libr/config.mk.tail",
      "libr/include/r_socket.h",
      "libr/include/r_types.h",
      "libr/include/r_util/r_str.h",
      "libr/socket/socket.c",
      "libr/socket/socket_http.c",
      "libr/util/str.c",
      "libr/util/sys.c",
      "meson.build",
      "shlr/sdb/src/disk.c",
      "test/db/formats/pdb",
      "test/unit/test_str.c"
    ],
    "message": "Fix command injection on PDB download (#16966)\n\n* Fix r_sys_mkdirp with absolute path on Windows\n* Fix build with --with-openssl\n* Use RBuffer in r_socket_http_answer()\n* r_socket_http_answer: Fix read for big responses\n* Implement r_str_escape_sh()\n* Cleanup r_socket_connect() on Windows\n* Fix socket being created without a protocol\n* Fix socket connect with SSL ##socket\n* Use select() in r_socket_ready()\n* Fix read failing if received only protocol answer\n* Fix double-free\n* r_socket_http_get: Fail if req. SSL with no support\n* Follow redirects in r_socket_http_answer()\n* Fix r_socket_http_get result length with R2_CURL=1\n* Also follow redirects\n* Avoid using curl for downloading PDBs\n* Use r_socket_http_get() on UNIXs\n* Use WinINet API on Windows for r_socket_http_get()\n* Fix command injection\n* Fix r_sys_cmd_str_full output for binary data\n* Validate GUID on PDB download\n* Pass depth to socket_http_get_recursive()\n* Remove 'r_' and '__' from static function names\n* Fix is_valid_guid\n* Fix for comments",
    "before_after_code_files": [
      "libr/bin/pdb/pdb_downloader.c||libr/bin/pdb/pdb_downloader.c",
      "libr/config.mk.tail||libr/config.mk.tail",
      "libr/include/r_socket.h||libr/include/r_socket.h",
      "libr/include/r_types.h||libr/include/r_types.h",
      "libr/include/r_util/r_str.h||libr/include/r_util/r_str.h",
      "libr/socket/socket.c||libr/socket/socket.c",
      "libr/socket/socket_http.c||libr/socket/socket_http.c",
      "libr/util/str.c||libr/util/str.c",
      "libr/util/sys.c||libr/util/sys.c",
      "meson.build||meson.build",
      "shlr/sdb/src/disk.c||shlr/sdb/src/disk.c",
      "test/unit/test_str.c||test/unit/test_str.c"
    ]
  },
  "patch_diff": {
    "libr/bin/pdb/pdb_downloader.c||libr/bin/pdb/pdb_downloader.c": [
      "File: libr/bin/pdb/pdb_downloader.c -> libr/bin/pdb/pdb_downloader.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "18:  return true;",
      "19: }",
      "24:   return false;",
      "25:  }",
      "26:  return true;",
      "27: }",
      "29: static int download(struct SPDBDownloader *pd) {",
      "30:  SPDBDownloaderOpt *opt = pd->opt;",
      "44:  int res = 0;",
      "45:  int cmd_ret;",
      "46:  if (!opt->dbg_file || !*opt->dbg_file) {",
      "48:   return 0;",
      "49:  }",
      "76:  if (r_file_exists (abspath_to_file)) {",
      "77:   eprintf (\"File already downloaded.\\n\");",
      "87:   return 1;",
      "88:  }",
      "90:  if (checkExtract () || opt->extract == 0) {",
      "100: #if __WINDOWS__",
      "110: #else",
      "113:   char *abspath_to_dir = r_file_dirname (abspath_to_archive);",
      "119: #endif",
      "127:    if (res && ((cmd_ret = r_sys_cmd (extractor_cmd)) != 0)) {",
      "128:     eprintf (\"cab extractor exited with error %d\\n\", cmd_ret);",
      "129:     res = 0;",
      "130:    }",
      "131:    r_file_rm (abspath_to_archive);",
      "132:   }",
      "134:  }",
      "135:  if (res == 0) {",
      "136:   eprintf (\"Falling back to uncompressed pdb\\n\");",
      "148:   eprintf (\"Attempting to download uncompressed pdb in %s\\n\", abspath_to_file);",
      "165:  return res;",
      "166: }",
      "",
      "[Removed Lines]",
      "21: static bool checkCurl() {",
      "22:  const char nul[] = R_SYS_DEVNULL;",
      "23:  if (r_sys_cmdf (\"curl --version > %s\", nul) != 0) {",
      "31:  char *curl_cmd = NULL;",
      "32:  char *extractor_cmd = NULL;",
      "33:  char *abspath_to_archive = NULL;",
      "34:  char *abspath_to_file = NULL;",
      "35:  char *archive_name = NULL;",
      "36:  size_t archive_name_len = 0;",
      "37:  char *symbol_store_path = NULL;",
      "38:  char *dbg_file = NULL;",
      "39:  char *guid = NULL;",
      "40:  char *archive_name_escaped  = NULL;",
      "41:  char *user_agent = NULL;",
      "42:  char *symbol_server = NULL;",
      "50:  if (!checkCurl ()) {",
      "51:   return 0;",
      "52:  }",
      "54:  archive_name_len = strlen (opt->dbg_file);",
      "55:  archive_name = malloc (archive_name_len + 1);",
      "56:  if (!archive_name) {",
      "57:   return 0;",
      "58:  }",
      "59:  memcpy (archive_name, opt->dbg_file, archive_name_len + 1);",
      "60:  archive_name[archive_name_len - 1] = '_';",
      "61:  symbol_store_path = r_str_escape (opt->symbol_store_path);",
      "62:  dbg_file = r_str_escape (opt->dbg_file);",
      "63:  guid = r_str_escape (opt->guid);",
      "64:  archive_name_escaped = r_str_escape (archive_name);",
      "65:  user_agent = r_str_escape (opt->user_agent);",
      "66:  symbol_server = r_str_escape (opt->symbol_server);",
      "68:  abspath_to_archive = r_str_newf (\"%s%s%s%s%s%s%s\",",
      "69:        symbol_store_path, R_SYS_DIR,",
      "70:        dbg_file, R_SYS_DIR,",
      "71:        guid, R_SYS_DIR,",
      "72:        archive_name_escaped);",
      "74:  abspath_to_file = strdup (abspath_to_archive);",
      "75:  abspath_to_file[strlen (abspath_to_file) - 1] = 'b';",
      "78:   R_FREE (user_agent);",
      "79:   R_FREE (abspath_to_archive);",
      "80:   R_FREE (archive_name_escaped);",
      "81:   R_FREE (symbol_store_path);",
      "82:   R_FREE (dbg_file);",
      "83:   R_FREE (guid);",
      "84:   R_FREE (archive_name);",
      "85:   R_FREE (abspath_to_file);",
      "86:   R_FREE (symbol_server);",
      "91:   res = 1;",
      "93:   curl_cmd = r_str_newf (\"curl -sfLA \\\"%s\\\" \\\"%s/%s/%s/%s\\\" --create-dirs -o \\\"%s\\\"\",",
      "94:                          user_agent,",
      "95:                          symbol_server,",
      "96:           dbg_file,",
      "97:           guid,",
      "98:                          archive_name_escaped,",
      "99:                          abspath_to_archive);",
      "101:   const char *cabextractor = \"expand\";",
      "102:   const char *format = \"%s %s %s\";",
      "108:   extractor_cmd = r_str_newf (format, cabextractor,",
      "109:    abspath_to_archive, abspath_to_file);",
      "111:   const char *cabextractor = \"cabextract\";",
      "112:   const char *format = \"%s -d \\\"%s\\\" \\\"%s\\\"\";",
      "117:   extractor_cmd = r_str_newf (format, cabextractor, abspath_to_dir, abspath_to_archive);",
      "118:   R_FREE (abspath_to_dir);",
      "120:   eprintf (\"Attempting to download compressed pdb in %s\\n\", abspath_to_archive);",
      "121:   if ((cmd_ret = r_sys_cmd (curl_cmd) != 0)) {",
      "122:    eprintf(\"curl exited with error %d\\n\", cmd_ret);",
      "123:    res = 0;",
      "124:   }",
      "125:   eprintf (\"Attempting to decompress pdb\\n\");",
      "126:   if (opt->extract > 0) {",
      "133:   R_FREE (curl_cmd);",
      "137:   res = 1;",
      "139:   archive_name_escaped[strlen (archive_name_escaped) - 1] = 'b';",
      "141:   curl_cmd = r_str_newf (\"curl -sfLA \\\"%s\\\" \\\"%s/%s/%s/%s\\\" --create-dirs -o \\\"%s\\\"\",",
      "142:                          opt->user_agent,",
      "143:                          opt->symbol_server,",
      "144:                          opt->dbg_file,",
      "145:                          opt->guid,",
      "146:                          archive_name_escaped,",
      "147:                          abspath_to_file);",
      "149:   if ((cmd_ret = r_sys_cmd (curl_cmd) != 0)) {",
      "150:    eprintf(\"curl exited with error %d\\n\", cmd_ret);",
      "151:    res = 0;",
      "152:   }",
      "153:   R_FREE (curl_cmd);",
      "154:  }",
      "155:  R_FREE (abspath_to_archive);",
      "156:  R_FREE (abspath_to_file);",
      "157:  R_FREE (archive_name);",
      "158:  R_FREE (extractor_cmd);",
      "159:  R_FREE (symbol_store_path);",
      "160:  R_FREE (dbg_file);",
      "161:  R_FREE (guid);",
      "162:  R_FREE (archive_name_escaped);",
      "163:  R_FREE (user_agent);",
      "164:  R_FREE (symbol_server);",
      "",
      "[Added Lines]",
      "21: static bool download_and_write(SPDBDownloaderOpt *opt, const char *file) {",
      "22:  char *dir = r_str_newf (\"%s%s%s%s%s\",",
      "23:   opt->symbol_store_path, R_SYS_DIR,",
      "24:   opt->dbg_file, R_SYS_DIR,",
      "25:   opt->guid);",
      "26:  if (!r_sys_mkdirp (dir)) {",
      "27:   free (dir);",
      "30:  char *url = r_str_newf (\"%s/%s/%s/%s\", opt->symbol_server, opt->dbg_file, opt->guid, file);",
      "31:  int len;",
      "32:  char *file_buf = r_socket_http_get (url, NULL, &len);",
      "33:  free (url);",
      "34:  if (!len || R_STR_ISEMPTY (file_buf)) {",
      "35:   free (dir);",
      "36:   free (file_buf);",
      "37:   return false;",
      "38:  }",
      "39:  char *path = r_str_newf (\"%s%s%s\", dir, R_SYS_DIR, opt->dbg_file);",
      "40:  FILE *f = fopen (path, \"wb\");",
      "41:  if (f) {",
      "42:   fwrite (file_buf, sizeof (char), (size_t)len, f);",
      "43:   fclose (f);",
      "44:  }",
      "45:  free (dir);",
      "46:  free (path);",
      "47:  free (file_buf);",
      "61:  char *abspath_to_file = r_str_newf (\"%s%s%s%s%s%s%s\",",
      "62:   opt->symbol_store_path, R_SYS_DIR,",
      "63:   opt->dbg_file, R_SYS_DIR,",
      "64:   opt->guid, R_SYS_DIR,",
      "65:   opt->dbg_file);",
      "69:   free (abspath_to_file);",
      "74:   char *extractor_cmd = NULL;",
      "75:   char *archive_name = strdup (opt->dbg_file);",
      "76:   archive_name[strlen (archive_name) - 1] = '_';",
      "77:   char *abspath_to_archive = r_str_newf (\"%s%s%s%s%s%s%s\",",
      "78:    opt->symbol_store_path, R_SYS_DIR,",
      "79:    opt->dbg_file, R_SYS_DIR,",
      "80:    opt->guid, R_SYS_DIR,",
      "81:    archive_name);",
      "83:   eprintf (\"Attempting to download compressed pdb in %s\\n\", abspath_to_archive);",
      "84:   char *abs_arch_esc = r_str_escape_sh (abspath_to_archive);",
      "86:   char *abs_file_esc = r_str_escape_sh (abspath_to_file);",
      "90:   extractor_cmd = r_str_newf (\"expand \\\"%s\\\" \\\"%s\\\"\", abs_arch_esc, abs_file_esc);",
      "91:   free (abs_file_esc);",
      "94:   char *abs_dir_esc = r_str_escape_sh (abspath_to_dir);",
      "98:   extractor_cmd = r_str_newf (\"cabextract -d \\\"%s\\\" \\\"%s\\\"\", abs_arch_esc, abs_dir_esc);",
      "99:   free (abs_dir_esc);",
      "100:   free (abspath_to_dir);",
      "102:   free (abs_arch_esc);",
      "103:   res = download_and_write (opt, archive_name);",
      "105:   if (opt->extract > 0 && res) {",
      "106:    eprintf (\"Attempting to decompress pdb\\n\");",
      "113:   free (archive_name);",
      "114:   free (abspath_to_archive);",
      "119:   res = download_and_write (opt, opt->dbg_file);",
      "120:  }",
      "121:  free (abspath_to_file);",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "191:  pd->download = 0;",
      "192: }",
      "194: int r_bin_pdb_download(RCore *core, int isradjson, int *actions_done, SPDBOptions *options) {",
      "195:  int ret;",
      "196:  SPDBDownloaderOpt opt;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "151: static bool is_valid_guid(const char *guid) {",
      "152:  if (!guid) {",
      "153:   return false;",
      "154:  }",
      "155:  size_t i;",
      "156:  for (i = 0; guid[i]; i++) {",
      "157:   if (!isxdigit (guid[i])) {",
      "158:    return false;",
      "159:   }",
      "160:  }",
      "161:  return i >= 33; // len of GUID and age",
      "162: }",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "202:   return 1;",
      "203:  }",
      "205:  if (!options || !options->symbol_server || !options->user_agent) {",
      "206:   eprintf (\"Can't retrieve pdb configurations\\n\");",
      "207:   return 1;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "175:  if (!is_valid_guid (info->guid)) {",
      "176:   eprintf (\"Invalid GUID for file\\n\");",
      "177:   return 1;",
      "178:  }",
      "",
      "---------------"
    ],
    "libr/config.mk.tail||libr/config.mk.tail": [
      "File: libr/config.mk.tail -> libr/config.mk.tail",
      "--- Hunk 1 ---",
      "[Context before]",
      "52: BN_LIBS=-lgmp",
      "53: endif",
      "55: #both of these need ssl includes",
      "56: ifneq (,$(filter r_socket r_util,$(BINDEPS)))",
      "57: ifeq (${HAVE_LIB_SSL},1)",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "55: # open-ssl",
      "56: ifeq (${HAVE_LIB_SSL},1)",
      "57: BN_LIBS=${SSL_LDFLAGS}",
      "58: endif",
      "",
      "---------------"
    ],
    "libr/include/r_socket.h||libr/include/r_socket.h": [
      "File: libr/include/r_socket.h -> libr/include/r_socket.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "1: #ifndef R2_SOCKET_H",
      "2: #define R2_SOCKET_H",
      "9: #include \"r_types.h\"",
      "10: #include \"r_bind.h\"",
      "11: #include \"r_list.h\"",
      "",
      "[Removed Lines]",
      "5: #if defined(__WINDOWS__)",
      "6: #include <ws2tcpip.h>",
      "7: #endif",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ],
    "libr/include/r_types.h||libr/include/r_types.h": [
      "File: libr/include/r_types.h -> libr/include/r_types.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "152:   #ifdef _MSC_VER",
      "154:   #include <winsock2.h>",
      "155:   #ifndef WIN32_LEAN_AND_MEAN",
      "156:   #define WIN32_LEAN_AND_MEAN",
      "157:   #endif",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "155:   #include <ws2tcpip.h>",
      "",
      "---------------"
    ],
    "libr/include/r_util/r_str.h||libr/include/r_util/r_str.h": [
      "File: libr/include/r_util/r_str.h -> libr/include/r_util/r_str.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "148: R_API char *r_str_path_escape(const char *path);",
      "149: R_API int r_str_unescape(char *buf);",
      "150: R_API char *r_str_escape(const char *buf);",
      "151: R_API char *r_str_escape_dot(const char *buf);",
      "152: R_API char *r_str_escape_latin1(const char *buf, bool show_asciidot, bool esc_bslash, bool colors);",
      "153: R_API char *r_str_escape_utf8(const char *buf, bool show_asciidot, bool esc_bslash);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "151: R_API char *r_str_escape_sh(const char *buf);",
      "",
      "---------------"
    ],
    "libr/socket/socket.c||libr/socket/socket.c": [
      "File: libr/socket/socket.c -> libr/socket/socket.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "260: R_API bool r_socket_connect(RSocket *s, const char *host, const char *port, int proto, unsigned int timeout) {",
      "261:  r_return_val_if_fail (s, false);",
      "262: #if __WINDOWS__",
      "263:  struct sockaddr_in sa;",
      "265:  WSADATA wsadata;",
      "270:  if (WSAStartup (MAKEWORD (1, 1), &wsadata) == SOCKET_ERROR) {",
      "271:   eprintf (\"Error creating socket.\");",
      "272:   return false;",
      "273:  }",
      "292: #endif",
      "326:  int ret;",
      "328:  struct addrinfo *res, *rp;",
      "329:  if (!proto) {",
      "330:   proto = R_SOCKET_PROTO_TCP;",
      "331:  }",
      "332:  r_sys_signal (SIGPIPE, SIG_IGN);",
      "333:  if (proto == R_SOCKET_PROTO_UNIX) {",
      "334:   if (!__connect_unix (s, host)) {",
      "335:    return false;",
      "336:   }",
      "337:  } else {",
      "339:   hints.ai_protocol = proto;",
      "",
      "[Removed Lines]",
      "264:  struct hostent *he;",
      "266:  TIMEVAL Timeout;",
      "267:  Timeout.tv_sec = timeout;",
      "268:  Timeout.tv_usec = 0;",
      "274:  s->fd = socket (AF_INET, SOCK_STREAM, 0);",
      "275:  if (s->fd == R_INVALID_SOCKET) {",
      "276:   return false;",
      "277:  }",
      "279:  unsigned long iMode = 1;",
      "280:  int iResult = ioctlsocket (s->fd, FIONBIO, &iMode);",
      "281:  if (iResult != NO_ERROR) {",
      "282:   eprintf (\"ioctlsocket error: %d\\n\", iResult);",
      "283:  }",
      "284:  memset (&sa, 0, sizeof (sa));",
      "285:  sa.sin_family = AF_INET;",
      "286:  he = (struct hostent *)gethostbyname (host);",
      "287:  if (he == (struct hostent*)0) {",
      "288: #ifdef _MSC_VER",
      "289:   closesocket (s->fd);",
      "290: #else",
      "291:   close (s->fd);",
      "293:   return false;",
      "294:  }",
      "295:  sa.sin_addr = *((struct in_addr *)he->h_addr);",
      "296:  s->port = r_socket_port_by_name (port);",
      "297:  s->proto = proto;",
      "298:  sa.sin_port = htons (s->port);",
      "299:  if (!connect (s->fd, (const struct sockaddr*)&sa, sizeof (struct sockaddr))) {",
      "300: #ifdef _MSC_VER",
      "301:   closesocket (s->fd);",
      "302: #else",
      "303:   close (s->fd);",
      "304: #endif",
      "305:   return false;",
      "306:  }",
      "307:  iMode = 0;",
      "308:  iResult = ioctlsocket (s->fd, FIONBIO, &iMode);",
      "309:  if (iResult != NO_ERROR) {",
      "310:   eprintf (\"ioctlsocket error: %d\\n\", iResult);",
      "311:  }",
      "312:  if (timeout > 0) {",
      "313:   r_socket_block_time (s, 1, timeout, 0);",
      "314:  }",
      "315:  fd_set Write, Err;",
      "316:  FD_ZERO (&Write);",
      "317:  FD_ZERO (&Err);",
      "318:  FD_SET (s->fd, &Write);",
      "319:  FD_SET (s->fd, &Err);",
      "320:  select (0, NULL, &Write, &Err, &Timeout);",
      "321:  if (FD_ISSET (s->fd, &Write)) {",
      "322:   return true;",
      "323:  }",
      "324:  return false;",
      "325: #elif __UNIX__",
      "327:  struct addrinfo hints = {0};",
      "",
      "[Added Lines]",
      "263: #define gai_strerror gai_strerrorA",
      "273:  struct addrinfo hints = { 0 };",
      "278: #if __UNIX__",
      "280: #endif",
      "282: #if __UNIX__",
      "286: #endif",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "367:     return true;",
      "368:    }",
      "369:    if (errno == EINPROGRESS) {",
      "373:     fd_set wfds;",
      "377:     if ((ret = select (s->fd + 1, NULL, &wfds, NULL, &tv)) != -1) {",
      "378:      if (r_socket_is_connected (s)) {",
      "379:       freeaddrinfo (res);",
      "381:      }",
      "382:     } else {",
      "383:      perror (\"connect\");",
      "",
      "[Removed Lines]",
      "370:     struct timeval tv;",
      "371:     tv.tv_sec = timeout;",
      "372:     tv.tv_usec = 0;",
      "374:     FD_ZERO(&wfds);",
      "375:     FD_SET(s->fd, &wfds);",
      "380:       return true;",
      "",
      "[Added Lines]",
      "320:     struct timeval tv = {timeout, 0};",
      "322:     FD_ZERO (&wfds);",
      "323:     FD_SET (s->fd, &wfds);",
      "328:       goto success;",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "391:    return false;",
      "392:   }",
      "393:  }",
      "395: #if HAVE_LIB_SSL",
      "396:  if (s->is_ssl) {",
      "397:   s->ctx = SSL_CTX_new (SSLv23_client_method ());",
      "398:   if (!s->ctx) {",
      "400:    return false;",
      "401:   }",
      "402:   s->sfd = SSL_new (s->ctx);",
      "403:   SSL_set_fd (s->sfd, s->fd);",
      "406:    return false;",
      "407:   }",
      "408:  }",
      "",
      "[Removed Lines]",
      "394: #endif",
      "399:    r_socket_free (s);",
      "404:   if (SSL_connect (s->sfd) != 1) {",
      "405:    r_socket_free (s);",
      "",
      "[Added Lines]",
      "342: success:",
      "347:    r_socket_close (s);",
      "352:   int ret = SSL_connect (s->sfd);",
      "353:   if (ret != 1) {",
      "354:    int error = SSL_get_error (s->sfd, ret);",
      "355:    int tries = 10;",
      "356:    while (tries && ret && (error == SSL_ERROR_WANT_READ || error == SSL_ERROR_WANT_WRITE)) {",
      "357:     struct timeval tv = {1, 0};",
      "358:     fd_set rfds, wfds;",
      "359:     FD_ZERO (&rfds);",
      "360:     FD_ZERO (&wfds);",
      "361:     if (error == SSL_ERROR_WANT_READ) {",
      "362:      FD_SET (s->fd, &rfds);",
      "363:     } else {",
      "364:      FD_SET (s->fd, &wfds);",
      "365:     }",
      "366:     if ((ret = select (s->fd + 1, &rfds, &wfds, NULL, &tv)) < 1) {",
      "367:      r_socket_close (s);",
      "368:      return false;",
      "369:     }",
      "370:     ret = SSL_connect (s->sfd);",
      "371:     if (ret == 1) {",
      "372:      return true;",
      "373:     }",
      "374:     error = SSL_get_error (s->sfd, ret);",
      "375:     tries--;",
      "376:    }",
      "377:    r_socket_close (s);",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "622:  FD_ZERO (&except_fds);",
      "623:  FD_SET (s->fd, &except_fds);",
      "629:  int r = select (s->fd + 1, &read_fds, NULL, &except_fds, &t);",
      "630:  if(r < 0) {",
      "",
      "[Removed Lines]",
      "625:  struct timeval t;",
      "626:  t.tv_sec = timeout;",
      "627:  t.tv_usec = 0;",
      "",
      "[Added Lines]",
      "597:  struct timeval t = {timeout, 0};",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "659:  ioctlsocket (s->fd, FIONBIO, (u_long FAR*)&block);",
      "660: #endif",
      "661:  if (sec > 0 || usec > 0) {",
      "665:   if (setsockopt (s->fd, SOL_SOCKET, SO_RCVTIMEO, (char *)&tv, sizeof (tv)) < 0) {",
      "666:    return false;",
      "667:   }",
      "",
      "[Removed Lines]",
      "662:   struct timeval tv = {0};",
      "663:   tv.tv_sec = sec;",
      "664:   tv.tv_usec = usec;",
      "",
      "[Added Lines]",
      "632:   struct timeval tv = {sec, usec};",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "678:  return true;",
      "679: }",
      "684: R_API int r_socket_ready(RSocket *s, int secs, int usecs) {",
      "694:  fd_set rfds;",
      "696:  if (s->fd == R_INVALID_SOCKET) {",
      "697:   return -1;",
      "698:  }",
      "699:  FD_ZERO (&rfds);",
      "700:  FD_SET (s->fd, &rfds);",
      "703:  return select (s->fd + 1, &rfds, NULL, NULL, &tv);",
      "707: }",
      "709: R_API char *r_socket_to_string(RSocket *s) {",
      "",
      "[Removed Lines]",
      "685: #if __UNIX__",
      "687:  int msecs = (usecs / 1000);",
      "688:  struct pollfd fds[1];",
      "689:  fds[0].fd = s->fd;",
      "690:  fds[0].events = POLLIN | POLLPRI;",
      "691:  fds[0].revents = POLLNVAL | POLLHUP | POLLERR;",
      "692:  return poll ((struct pollfd *)&fds, 1, msecs);",
      "693: #elif __WINDOWS__",
      "695:  struct timeval tv;",
      "701:  tv.tv_sec = secs;",
      "702:  tv.tv_usec = usecs;",
      "704: #else",
      "706: #endif",
      "",
      "[Added Lines]",
      "653:  struct timeval tv = {secs, usecs};",
      "",
      "---------------",
      "--- Hunk 7 ---",
      "[Context before]",
      "794:   return SSL_read (s->sfd, buf, len);",
      "795:  }",
      "796: #endif",
      "808:  int r = recv (s->fd, buf, len, 0);",
      "809:  D { eprintf (\"READ \"); int i; for (i = 0; i<len; i++) { eprintf (\"%02x \", buf[i]); } eprintf (\"\\n\"); }",
      "810:  return r;",
      "812: }",
      "814: R_API int r_socket_read_block(RSocket *s, ut8 *buf, int len) {",
      "",
      "[Removed Lines]",
      "797: #if __WINDOWS__",
      "798: rep:",
      "799:  {",
      "800:  int ret = recv (s->fd, (void *)buf, len, 0);",
      "801:  if (ret == -1) {",
      "802:   goto rep;",
      "803:  }",
      "804:  return ret;",
      "805:  }",
      "806: #else",
      "811: #endif",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 8 ---",
      "[Context before]",
      "816:  for (ret = 0; ret < len; ) {",
      "817:   int r = r_socket_read (s, buf + ret, len - ret);",
      "818:   if (r == -1) {",
      "819:    return -1;",
      "820:   }",
      "821:   if (r < 1) {",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "761: #if HAVE_LIB_SSL",
      "762:    if (SSL_get_error (s->sfd, r) == SSL_ERROR_WANT_READ) {",
      "763:     if (r_socket_ready (s, 1, 0) == 1) {",
      "764:      continue;",
      "765:     }",
      "766:    }",
      "767: #endif",
      "",
      "---------------"
    ],
    "libr/socket/socket_http.c||libr/socket/socket_http.c": [
      "File: libr/socket/socket_http.c -> libr/socket/socket_http.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "3: #include <r_socket.h>",
      "4: #include <r_util.h>",
      "11:   return 0;",
      "12:  }",
      "19:    break;",
      "20:   }",
      "21:  }",
      "22:  return i;",
      "23: }",
      "26:  r_return_val_if_fail (s, NULL);",
      "27:  const char *p;",
      "31:   return NULL;",
      "32:  }",
      "33:  char *res = NULL;",
      "35:  if ((dn = (char*)r_str_casestr (buf, \"\\n\\n\"))) {",
      "36:   delta += 2;",
      "37:  } else if ((dn = (char*)r_str_casestr (buf, \"\\r\\n\\r\\n\"))) {",
      "38:   delta += 4;",
      "39:  } else {",
      "41:  }",
      "43:  olen -= delta;",
      "46:  p = r_str_casestr (buf, \"Content-Length: \");",
      "47:  if (p) {",
      "",
      "[Removed Lines]",
      "6: static int __socket_slurp (RSocket *s, ut8 *buf, int bufsz) {",
      "7:  int i;",
      "8:  int chsz = 1;",
      "10:  if (r_socket_read_block (s, (ut8 *) buf, 1) != 1) {",
      "13:  for (i = 1; i < bufsz; i += chsz) {",
      "14:   buf[i] =0;",
      "15:   r_socket_block_time (s, 1, 0, 1000);",
      "16:   int olen = r_socket_read_block (s, (ut8 *) buf + i , chsz);",
      "17:   if (olen != chsz) {",
      "18:    buf[i] = 0;",
      "25: static char *r_socket_http_answer (RSocket *s, int *code, int *rlen) {",
      "28:  int ret, len = 0, bufsz = 32768, delta = 0;",
      "29:  char *dn, *buf = calloc (1, bufsz + 32); // XXX: use r_buffer here",
      "30:  if (!buf) {",
      "34:  int olen = __socket_slurp (s, (ut8*)buf, bufsz);",
      "40:   goto fail;",
      "",
      "[Added Lines]",
      "6: #if __WINDOWS__",
      "7: #include <WinInet.h>",
      "8: #endif",
      "10: #define SOCKET_HTTP_MAX_HEADER_LENGTH 0x2000",
      "11: #define SOCKET_HTTP_MAX_REDIRECTS 5",
      "13: static size_t socket_slurp(RSocket *s, RBuffer *buf) {",
      "14:  size_t i;",
      "15:  if (r_socket_ready (s, 1, 0) != 1) {",
      "18:  r_socket_block_time (s, 1, 0, 1000);",
      "19:  for (i = 0; i < SOCKET_HTTP_MAX_HEADER_LENGTH; i += 1) {",
      "20:   ut8 c;",
      "21:   int olen = r_socket_read_block (s, &c, 1);",
      "22:   if (olen != 1) {",
      "23:    r_buf_append_bytes (buf, (ut8 *)\"\", 1);",
      "26:   r_buf_append_bytes (buf, &c, 1);",
      "31: static char *socket_http_get_recursive(const char *url, int *code, int *rlen, ut32 redirections);",
      "33: static char *socket_http_answer(RSocket *s, int *code, int *rlen, ut32 redirections) {",
      "36:  int ret, len = 0, delta = 0;",
      "37:  char *dn;",
      "38:  RBuffer *b = r_buf_new ();",
      "39:  if (!b) {",
      "43:  size_t olen = socket_slurp (s, b);",
      "44:  char *buf = malloc (olen + 1);",
      "45:  if (!buf) {",
      "46:   goto exit;",
      "47:  }",
      "48:  r_buf_read_at (b, 0, (ut8 *)buf, olen);",
      "49:  buf[olen] = 0;",
      "55:   goto exit;",
      "62:  p = r_str_casestr (buf, \"Location:\");",
      "63:  if (p) {",
      "64:   if (!redirections) {",
      "65:    eprintf (\"Too many redirects\\n\");",
      "66:    goto exit;",
      "67:   }",
      "68:   p += strlen (\"Location:\");",
      "69:   char *end_url = strchr (p, '\\n');",
      "70:   if (end_url) {",
      "71:    int url_len = end_url - p;",
      "72:    char *url = r_str_ndup (p, url_len);",
      "73:    r_str_trim (url);",
      "74:    res = socket_http_get_recursive (url, code, rlen, --redirections);",
      "75:    free (url);",
      "76:    len = *rlen;",
      "77:   }",
      "78:   goto exit;",
      "79:  }",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "52:  if (len > 0) {",
      "53:   if (len > olen) {",
      "54:    res = malloc (len + 2);",
      "55:    memcpy (res, dn + delta, olen);",
      "56:    do {",
      "57:     ret = r_socket_read_block (s, (ut8*) res + olen, len - olen);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "91:    if (!res) {",
      "92:     goto exit;",
      "93:    }",
      "94:    olen -= dn - buf;",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "71:  } else {",
      "72:   res = NULL;",
      "73:  }",
      "75:  free (buf);",
      "77:  r_socket_close (s);",
      "78:  if (rlen) {",
      "",
      "[Removed Lines]",
      "74: fail:",
      "",
      "[Added Lines]",
      "114: exit:",
      "116:  r_buf_free (b);",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "81:  return res;",
      "82: }",
      "85:  char *curl_env = r_sys_getenv (\"R2_CURL\");",
      "90:   if (res) {",
      "91:    if (code) {",
      "93:    }",
      "94:    if (rlen) {",
      "96:    }",
      "97:   }",
      "99:   return res;",
      "100:  }",
      "101:  free (curl_env);",
      "102:  RSocket *s;",
      "103:  int ssl = r_str_startswith (url, \"https://\");",
      "104:  char *response, *host, *path, *port = \"80\";",
      "105:  char *uri = strdup (url);",
      "106:  if (!uri) {",
      "107:   return NULL;",
      "108:  }",
      "116:  host = strstr (uri, \"://\");",
      "117:  if (!host) {",
      "118:   free (uri);",
      "",
      "[Removed Lines]",
      "84: R_API char *r_socket_http_get(const char *url, int *code, int *rlen) {",
      "86:  if (curl_env && *curl_env) {",
      "87:   char *encoded_url = r_str_escape (url);",
      "88:   char *res = r_sys_cmd_strf (\"curl '%s'\", encoded_url);",
      "89:   free (encoded_url);",
      "98:   free (curl_env);",
      "110:  if (code) {",
      "112:  }",
      "113:  if (rlen) {",
      "115:  }",
      "",
      "[Added Lines]",
      "124: #if __WINDOWS__",
      "125: static char *http_get_w32(const char *url, int *code, int *rlen) {",
      "126:  HINTERNET hInternet = InternetOpenA (\"radare2 \"R2_VERSION, INTERNET_OPEN_TYPE_DIRECT, NULL, NULL, 0);",
      "127:  if (!hInternet) {",
      "128:   r_sys_perror (\"InternetOpenA\");",
      "129:   return NULL;",
      "130:  }",
      "131:  HINTERNET hOpenUrl = InternetOpenUrlA (hInternet, url, NULL, 0, 0, 0);",
      "132:  if (!hOpenUrl) {",
      "133:   r_sys_perror (\"InternetOpenUrlA\");",
      "134:   InternetCloseHandle (hInternet);",
      "135:   return NULL;",
      "136:  }",
      "138:  char *ret = NULL;",
      "139:  size_t read_sz = 0x100000;",
      "140:  DWORD r = 0, w = 0;",
      "141:  bool res = true;",
      "142:  do {",
      "143:   w += r;",
      "144:   if (!res && GetLastError () == ERROR_INSUFFICIENT_BUFFER) {",
      "145:    read_sz *= 2;",
      "146:   }",
      "147:   char *tmp = realloc (ret, read_sz + w);",
      "148:   if (!tmp) {",
      "149:    R_FREE (ret);",
      "150:    goto exit;",
      "151:   }",
      "152:   ret = tmp;",
      "153:  } while (!(res = InternetReadFile (hOpenUrl, ret + w, read_sz, &r)) || r);",
      "155:  if (w) {",
      "156:   char *tmp = realloc (ret, (size_t)w + 1);",
      "157:   if (tmp) {",
      "158:    ret = tmp;",
      "159:    ret[w] = 0;",
      "160:   } else {",
      "161:    R_FREE (ret);",
      "162:   }",
      "163:  } else {",
      "164:   R_FREE (ret);",
      "165:  }",
      "167: exit:",
      "168:  if (rlen) {",
      "170:  }",
      "171:  if (code && w) {",
      "173:  }",
      "174:  InternetCloseHandle (hInternet);",
      "175:  InternetCloseHandle (hOpenUrl);",
      "176:  return ret;",
      "177: }",
      "178: #endif",
      "180: static char *socket_http_get_recursive(const char *url, int *code, int *rlen, ut32 redirections) {",
      "181:  if (code) {",
      "183:  }",
      "184:  if (rlen) {",
      "186:  }",
      "188:  if (!R_STR_ISEMPTY (curl_env) && atoi (curl_env)) {",
      "189:   int len;",
      "190:   char *escaped_url = r_str_escape_sh (url);",
      "191:   char *command = r_str_newf (\"curl -sfL -o - \\\"%s\\\"\", escaped_url);",
      "192:   char *res = r_sys_cmd_str (command, NULL, &len);",
      "193:   free (escaped_url);",
      "194:   free (command);",
      "195:   free (curl_env);",
      "196:   if (!res) {",
      "197:    return NULL;",
      "198:   }",
      "210: #if __WINDOWS__",
      "211:  return http_get_w32 (url, code, rlen);",
      "212: #else",
      "215: #if !HAVE_LIB_SSL",
      "216:  if (ssl) {",
      "217:   eprintf (\"Tried to get '%s', but SSL support is disabled, set R2_CURL=1 to use curl\\n\", url);",
      "218:   return NULL;",
      "219:  }",
      "220: #endif",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "147:     \"Accept: */*\\r\\n\"",
      "148:     \"Host: %s:%s\\r\\n\"",
      "149:     \"\\r\\n\", path, host, port);",
      "151:  } else {",
      "152:   eprintf (\"Cannot connect to %s:%s\\n\", host, port);",
      "153:   response = NULL;",
      "",
      "[Removed Lines]",
      "150:   response = r_socket_http_answer (s, code, rlen);",
      "",
      "[Added Lines]",
      "260:   response = socket_http_answer (s, code, rlen, redirections);",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "155:  free (uri);",
      "156:  r_socket_free (s);",
      "157:  return response;",
      "158: }",
      "161:  RSocket *s;",
      "162:  bool ssl = r_str_startswith (url, \"https://\");",
      "163:  char *uri = strdup (url);",
      "",
      "[Removed Lines]",
      "160: R_API char *r_socket_http_post (const char *url, const char *data, int *code, int *rlen) {",
      "",
      "[Added Lines]",
      "268: #endif",
      "269: }",
      "271: R_API char *r_socket_http_get(const char *url, int *code, int *rlen) {",
      "272:  return socket_http_get_recursive (url, code, rlen, SOCKET_HTTP_MAX_REDIRECTS);",
      "275: R_API char *r_socket_http_post(const char *url, const char *data, int *code, int *rlen) {",
      "",
      "---------------",
      "--- Hunk 7 ---",
      "[Context before]",
      "206:    \"\\r\\n\", path, host, (int)strlen (data));",
      "207:  free (uri);",
      "208:  r_socket_write (s, (void *)data, strlen (data));",
      "210: }",
      "212: #if TEST",
      "",
      "[Removed Lines]",
      "209:  return r_socket_http_answer (s, code, rlen);",
      "",
      "[Added Lines]",
      "324:  return socket_http_answer (s, code, rlen, 0);",
      "",
      "---------------"
    ],
    "libr/util/str.c||libr/util/str.c": [
      "File: libr/util/str.c -> libr/util/str.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "1351:  return r_str_escape_ (buf, false, true, true, false, true);",
      "1352: }",
      "1354: R_API char *r_str_escape_dot(const char *buf) {",
      "1355:  return r_str_escape_ (buf, true, true, true, false, true);",
      "1356: }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1355: R_API char *r_str_escape_sh(const char *buf) {",
      "1356:  r_return_val_if_fail (buf, NULL);",
      "1357:  char *new_buf = malloc (1 + strlen (buf) * 2);",
      "1358:  if (!new_buf) {",
      "1359:   return NULL;",
      "1360:  }",
      "1361:  const char *p = buf;",
      "1362:  char *q = new_buf;",
      "1363:  while (*p) {",
      "1364:   switch (*p) {",
      "1365: #if __UNIX__",
      "1366:   case '$':",
      "1367:   case '`':",
      "1368: #endif",
      "1369:   case '\\\\':",
      "1370:   case '\"':",
      "1373:   default:",
      "1375:    break;",
      "1376:   }",
      "1377:  }",
      "1379:  return new_buf;",
      "1380: }",
      "",
      "---------------"
    ],
    "libr/util/sys.c||libr/util/sys.c": [
      "File: libr/util/sys.c -> libr/util/sys.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "660:   }",
      "662:   r_sys_signal (SIGPIPE, SIG_IGN);",
      "663:   for (;;) {",
      "664:    fd_set rfds, wfds;",
      "665:    int nfd;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "663:   size_t err_len = 0, out_len = 0;",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "680:     break;",
      "681:    }",
      "682:    if (output && FD_ISSET (sh_out[0], &rfds)) {",
      "684:      break;",
      "685:     }",
      "689:     }",
      "691:    } else if (FD_ISSET (sh_err[0], &rfds) && sterr) {",
      "693:      break;",
      "694:     }",
      "697:    } else if (FD_ISSET (sh_in[1], &wfds) && inputptr && *inputptr) {",
      "698:     int inputptr_len = strlen (inputptr);",
      "699:     bytes = write (sh_in[1], inputptr, inputptr_len);",
      "",
      "[Removed Lines]",
      "683:     if (!(bytes = read (sh_out[0], buffer, sizeof (buffer)-1))) {",
      "686:     buffer[sizeof (buffer) - 1] = '\\0';",
      "687:     if (len) {",
      "690:     outputptr = r_str_append (outputptr, buffer);",
      "692:     if (!read (sh_err[0], buffer, sizeof (buffer)-1)) {",
      "695:     buffer[sizeof (buffer) - 1] = '\\0';",
      "",
      "[Added Lines]",
      "684:     if ((bytes = read (sh_out[0], buffer, sizeof (buffer))) < 1) {",
      "687:     char *tmp = realloc (outputptr, out_len + bytes + 1);",
      "688:     if (!tmp) {",
      "689:      R_FREE (outputptr);",
      "690:      break;",
      "692:     outputptr = tmp;",
      "693:     memcpy (outputptr + out_len, buffer, bytes);",
      "694:     out_len += bytes;",
      "696:     if ((bytes = read (sh_err[0], buffer, sizeof (buffer))) < 1) {",
      "697:      break;",
      "698:     }",
      "699:     char *tmp = realloc (*sterr, err_len + bytes + 1);",
      "700:     if (!tmp) {",
      "701:      R_FREE (*sterr);",
      "705:     memcpy (*sterr + err_len, buffer, bytes);",
      "706:     err_len += bytes;",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "727:    ret = false;",
      "728:   }",
      "730:   if (output) {",
      "732:   } else {",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "740:   if (len) {",
      "742:   }",
      "743:   if (*sterr) {",
      "744:    (*sterr)[err_len] = 0;",
      "745:   }",
      "746:   if (outputptr) {",
      "747:    outputptr[out_len] = 0;",
      "748:   }",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "829:  {",
      "830:   char *p = strstr (ptr, \":\\\\\");",
      "831:   if (p) {",
      "833:   }",
      "834:  }",
      "835: #endif",
      "",
      "[Removed Lines]",
      "832:    ptr = p + 2;",
      "",
      "[Added Lines]",
      "851:    ptr = p + 3;",
      "",
      "---------------"
    ],
    "meson.build||meson.build": [
      "File: meson.build -> meson.build",
      "--- Hunk 1 ---",
      "[Context before]",
      "112: platform_deps = []",
      "113: platform_inc = ['.', 'libr/include']",
      "114: if host_machine.system() == 'windows'",
      "116: endif",
      "117: platform_inc = include_directories(platform_inc)",
      "",
      "[Removed Lines]",
      "115:   platform_deps = [cc.find_library('ws2_32'), cc.find_library('psapi')]",
      "",
      "[Added Lines]",
      "115:   platform_deps = [cc.find_library('ws2_32'), cc.find_library('wininet'), cc.find_library('psapi')]",
      "",
      "---------------"
    ],
    "shlr/sdb/src/disk.c||shlr/sdb/src/disk.c": [
      "File: shlr/sdb/src/disk.c -> shlr/sdb/src/disk.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "64: #if __SDB_WINDOWS__",
      "65:  char *p = strstr (ptr, \":\\\\\");",
      "66:  if (p) {",
      "68:  }",
      "69: #endif",
      "70:  while ((ptr = strchr (ptr, slash))) {",
      "",
      "[Removed Lines]",
      "67:   ptr = p + 2;",
      "",
      "[Added Lines]",
      "67:   ptr = p + 3;",
      "",
      "---------------"
    ],
    "test/unit/test_str.c||test/unit/test_str.c": [
      "File: test/unit/test_str.c -> test/unit/test_str.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "336:  mu_end;",
      "337: }",
      "339: bool test_r_str_unescape(void) {",
      "340:  char buf[] = \"Hello\\\\x31World\\\\n\";",
      "341:  r_str_unescape (buf);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "339: bool test_r_str_escape_sh(void) {",
      "340:  char *escaped = r_str_escape_sh (\"Hello, \\\"World\\\"\");",
      "341:  mu_assert_streq (escaped, \"Hello, \\\\\\\"World\\\\\\\"\", \"escaped \\\"double quotes\\\"\");",
      "342:  free (escaped);",
      "343:  escaped = r_str_escape_sh (\"Hello, \\\\World\\\\\");",
      "344:  mu_assert_streq (escaped, \"Hello, \\\\\\\\World\\\\\\\\\", \"escaped backspace\");",
      "345:  free (escaped);",
      "346: #if __UNIX__",
      "347:  escaped = r_str_escape_sh (\"Hello, $(World)\");",
      "348:  mu_assert_streq (escaped, \"Hello, \\\\$(World)\", \"escaped $(command)\");",
      "349:  free (escaped);",
      "350:  escaped = r_str_escape_sh (\"Hello, `World`\");",
      "351:  mu_assert_streq (escaped, \"Hello, \\\\`World\\\\`\", \"escaped `command`\");",
      "352:  free (escaped);",
      "353: #endif",
      "354:  mu_end;",
      "355: }",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "477:  mu_run_test (test_r_str_utf8_charsize);",
      "478:  mu_run_test (test_r_str_utf8_charsize_prev);",
      "479:  mu_run_test (test_r_str_sanitize_sdb_key);",
      "480:  mu_run_test (test_r_str_unescape);",
      "481:  mu_run_test (test_r_str_constpool);",
      "482:  mu_run_test (test_r_str_format_msvc_argv);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "498:  mu_run_test (test_r_str_escape_sh);",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "6a0d90d2f50740822ba665c409febc412c4550af",
      "candidate_info": {
        "commit_hash": "6a0d90d2f50740822ba665c409febc412c4550af",
        "repo": "radareorg/radare2",
        "commit_url": "https://github.com/radareorg/radare2/commit/6a0d90d2f50740822ba665c409febc412c4550af",
        "files": [
          "libr/socket/socket.c"
        ],
        "message": "Create writefds set to fix socket timeout in r_socket_connect (fixes #16788) (#16946)\n\nSigned-off-by: Paul Fertser <fercerpav@gmail.com>",
        "before_after_code_files": [
          "libr/socket/socket.c||libr/socket/socket.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "libr/socket/socket.c||libr/socket/socket.c"
          ],
          "candidate": [
            "libr/socket/socket.c||libr/socket/socket.c"
          ]
        }
      },
      "candidate_diff": {
        "libr/socket/socket.c||libr/socket/socket.c": [
          "File: libr/socket/socket.c -> libr/socket/socket.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "370:     struct timeval tv;",
          "371:     tv.tv_sec = timeout;",
          "372:     tv.tv_usec = 0;",
          "375:      if (r_socket_is_connected (s)) {",
          "376:       freeaddrinfo (res);",
          "377:       return true;",
          "",
          "[Removed Lines]",
          "374:     if ((ret = select (s->fd + 1, NULL, NULL, NULL, &tv)) != -1) {",
          "",
          "[Added Lines]",
          "373:     fd_set wfds;",
          "374:     FD_ZERO(&wfds);",
          "375:     FD_SET(s->fd, &wfds);",
          "377:     if ((ret = select (s->fd + 1, NULL, &wfds, NULL, &tv)) != -1) {",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "0c46c3e1e30bb272a5a05fc367d874af32b41fe4",
      "candidate_info": {
        "commit_hash": "0c46c3e1e30bb272a5a05fc367d874af32b41fe4",
        "repo": "radareorg/radare2",
        "commit_url": "https://github.com/radareorg/radare2/commit/0c46c3e1e30bb272a5a05fc367d874af32b41fe4",
        "files": [
          "libr/bin/format/le/le.c",
          "libr/bin/format/ne/ne.c",
          "libr/bin/pdb/pdb_downloader.c",
          "libr/core/agraph.c",
          "libr/core/cbin.c",
          "libr/core/cfile.c",
          "libr/core/cmd_open.c",
          "libr/core/cmd_print.c",
          "libr/core/core.c",
          "libr/core/fortune.c",
          "libr/core/linux_heap_glibc.c",
          "libr/debug/p/debug_windbg.c",
          "libr/lang/p/cpipe.c",
          "libr/main/radare2.c",
          "libr/util/intervaltree.c"
        ],
        "message": "Some coverity fixes",
        "before_after_code_files": [
          "libr/bin/format/le/le.c||libr/bin/format/le/le.c",
          "libr/bin/format/ne/ne.c||libr/bin/format/ne/ne.c",
          "libr/bin/pdb/pdb_downloader.c||libr/bin/pdpdb_downloader.c",
          "libr/core/agraph.c||libr/core/agraph.c",
          "libr/core/cbin.c||libr/core/cbin.c",
          "libr/core/cfile.c||libr/core/cfile.c",
          "libr/core/cmd_open.c||libr/core/cmd_open.c",
          "libr/core/cmd_print.c||libr/core/cmd_print.c",
          "libr/core/core.c||libr/core/core.c",
          "libr/core/fortune.c||libr/core/fortune.c",
          "libr/core/linux_heap_glibc.c||libr/core/linux_heap_glibc.c",
          "libr/debug/p/debug_windbg.c||libr/debug/p/debug_windbg.c",
          "libr/lang/p/cpipe.c||libr/lang/p/cpipe.c",
          "libr/main/radare2.c||libr/main/radare2.c",
          "libr/util/intervaltree.c||libr/util/intervaltree.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "libr/bin/pdb/pdb_downloader.c||libr/bin/pdb/pdb_downloader.c"
          ],
          "candidate": [
            "libr/bin/pdb/pdb_downloader.c||libr/bin/pdpdb_downloader.c"
          ]
        }
      },
      "candidate_diff": {
        "libr/bin/format/le/le.c||libr/bin/format/le/le.c": [
          "File: libr/bin/format/le/le.c -> libr/bin/format/le/le.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "172:  offset = h->nrestab;",
          "173:  end = h->nrestab + h->cbnrestab;",
          "174:  __get_symbols_at (bin, l, entries, offset, end);",
          "175:  return l;",
          "176: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "175:  r_list_free (entries);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "340:    LE_object_page_entry page;",
          "341:    RBinSection *s = R_NEW0 (RBinSection);",
          "342:    if (!s) {",
          "343:     return l;",
          "344:    }",
          "345:    s->name = r_str_newf (\"%s.page.%d\", sec->name, j);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "344:     r_bin_section_free (sec);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "348:    int cur_idx = entry->page_tbl_idx + j - 1;",
          "349:    ut64 page_entry_off = objpageentrysz * cur_idx + objmaptbloff;",
          "351:    if (cur_idx < next_idx) { // If not true rest of pages will be zeroes",
          "352:     if (bin->is_le) {",
          "",
          "[Removed Lines]",
          "350:    r_buf_read_at (bin->buf, page_entry_off, (ut8 *)&page, sizeof (page));",
          "",
          "[Added Lines]",
          "352:    r_buf_read_at (bin->buf, page_entry_off, (ut8 *)&page, sizeof (page));",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "475:    }",
          "476:    char *mod_name = __get_modname_by_ord (bin, ordinal);",
          "477:    if (!mod_name) {",
          "478:     break;",
          "479:    }",
          "481:    if (header.target & F_TARGET_ORD8) {",
          "482:     ordinal = r_buf_read8_at (bin->buf, offset);",
          "483:     offset += sizeof (ut8);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "480:     r_bin_import_free (imp);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "572:    cur_section = (RBinSection *)r_list_get_n (sections, cur_page);",
          "573:    cur_page_offset = cur_section ? cur_section->vaddr : 0;",
          "574:   }",
          "575:  }",
          "576:  r_list_free (entries);",
          "577:  r_list_free (sections);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "578:   free (rel);",
          "",
          "---------------"
        ],
        "libr/bin/format/ne/ne.c||libr/bin/format/ne/ne.c": [
          "File: libr/bin/format/ne/ne.c -> libr/bin/format/ne/ne.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "324:   }",
          "325:   ut8 sz = r_buf_read8_at (bin->buf, off);",
          "326:   if (!sz) {",
          "327:    break;",
          "328:   }",
          "329:   off++;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "327:    r_bin_import_free (imp);",
          "",
          "---------------"
        ],
        "libr/bin/pdb/pdb_downloader.c||libr/bin/pdpdb_downloader.c": [
          "File: libr/bin/pdb/pdb_downloader.c -> libr/bin/pdpdb_downloader.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "75:  abspath_to_file[strlen (abspath_to_file) - 1] = 'b';",
          "76:  if (r_file_exists (abspath_to_file)) {",
          "77:   eprintf (\"File already downloaded.\\n\");",
          "78:   return 1;",
          "79:  }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "libr/core/agraph.c||libr/core/agraph.c": [
          "File: libr/core/agraph.c -> libr/core/agraph.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "2095:   r_str_trim (res);",
          "2096:   res = r_str_trim_lines (res);",
          "2097:   r_core_visual_toggle_decompiler_disasm (core, true, false);",
          "2098:   return res;",
          "2099:  }",
          "2100:  const char *cmd = (opts & BODY_SUMMARY)? \"pds\": \"pD\";",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2098:   r_config_hold_restore (hc);",
          "2099:   r_config_hold_free (hc);",
          "",
          "---------------"
        ],
        "libr/core/cbin.c||libr/core/cbin.c": [
          "File: libr/core/cbin.c -> libr/core/cbin.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "2087:   if (IS_MODE_JSON (mode)) {",
          "2088:    r_cons_printf (\"[]\");",
          "2089:   }",
          "2090:   return 0;",
          "2091:  }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2090:   r_table_free (table);",
          "",
          "---------------"
        ],
        "libr/core/cfile.c||libr/core/cfile.c": [
          "File: libr/core/cfile.c -> libr/core/cfile.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "258:  char *config_sdb_path = NULL;",
          "259:  int config_sdb_fd = r_file_mkstemp (NULL, &config_sdb_path);",
          "262:  Sdb *config_sdb = sdb_new (NULL, config_sdb_path, 0);",
          "263:  r_config_serialize (core->config, config_sdb);",
          "",
          "[Removed Lines]",
          "260:  close (config_sdb_fd);",
          "",
          "[Added Lines]",
          "260:  if (config_sdb_fd >= 0) {",
          "261:   close (config_sdb_fd);",
          "262:  }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "272:  r_sys_setenv (\"R2_COLOR\", r_config_get_i (core->config, \"scr.color\")? \"1\": \"0\");",
          "273:  r_sys_setenv (\"R2_DEBUG\", r_config_get_i (core->config, \"cfg.debug\")? \"1\": \"0\");",
          "274:  r_sys_setenv (\"R2_IOVA\", r_config_get_i (core->config, \"io.va\")? \"1\": \"0\");",
          "275:  return ret;",
          "276: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "277:  free (config_sdb_path);",
          "",
          "---------------"
        ],
        "libr/core/cmd_open.c||libr/core/cmd_open.c": [
          "File: libr/core/cmd_open.c -> libr/core/cmd_open.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1071:   r_core_bin_load (core, uri, addr);",
          "1072:  } else {",
          "1073:   eprintf (\"cannot open file %s\\n\", uri);",
          "1074:   return;",
          "1075:  }",
          "1076:  r_core_block_read (core);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1074:   r_list_free (old_sections);",
          "",
          "---------------"
        ],
        "libr/core/cmd_print.c||libr/core/cmd_print.c": [
          "File: libr/core/cmd_print.c -> libr/core/cmd_print.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "4651: }",
          "4653: R_API void r_print_code(RPrint *p, ut64 addr, const ut8 *buf, int len, char lang) {",
          "4655:  if (w < 1) {",
          "4656:   w = 1;",
          "4657:  }",
          "",
          "[Removed Lines]",
          "4654:  int i, w = p->cols * 0.7;",
          "",
          "[Added Lines]",
          "4654:  int i, w = (int)(p->cols * 0.7);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "5557:    pd_result = 0;",
          "5558:    processed_cmd = true;",
          "5559:    break;",
          "5561:    r_core_disasm_table (core, l, r_str_trim_ro (input + 2));",
          "5562:    pd_result = 0;",
          "5563:    processed_cmd = true;",
          "",
          "[Removed Lines]",
          "5560:   case 't': // \"pdt\"",
          "",
          "[Added Lines]",
          "5560:   case 't': // \"pdt\"",
          "",
          "---------------"
        ],
        "libr/core/core.c||libr/core/core.c": [
          "File: libr/core/core.c -> libr/core/core.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "302:  if (r_config_get_i (core->config, \"cfg.debug\")) {",
          "303:   return r_debug_map_sync (core->dbg);",
          "304:  }",
          "306: }",
          "308: R_API int r_core_bind(RCore *core, RCoreBind *bnd) {",
          "",
          "[Removed Lines]",
          "305:  return NULL;",
          "",
          "[Added Lines]",
          "305:  return 0;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1268:    break;",
          "1269:   }",
          "1270:   autocomplete_process_path (completion, buf->data, s);",
          "1271:  }",
          "1272: out:",
          "1273:  free (args);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1271:   free (s);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1464:     if (!strncmp (tmp, temp_cmd, n)) {",
          "1465:      char *cmplt = r_str_newf (\"anal/%s/%s\", ns, temp_cmd);",
          "1466:      r_line_completion_push (completion, cmplt);",
          "1467:     }",
          "1468:     out += temp_pos - out + 1;",
          "1469:    }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1469:      free (cmplt);",
          "",
          "---------------"
        ],
        "libr/core/fortune.c||libr/core/fortune.c": [
          "File: libr/core/fortune.c -> libr/core/fortune.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "27:    char *file = getFortuneFile(core, fortunes[i]);",
          "28:    char *str = r_file_slurp (file, NULL);",
          "29:    if (!str) {",
          "30:     continue;",
          "31:    }",
          "32:    for (j = 0; str[j]; j++) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "30:     free (file);",
          "",
          "---------------"
        ],
        "libr/core/linux_heap_glibc.c||libr/core/linux_heap_glibc.c": [
          "File: libr/core/linux_heap_glibc.c -> libr/core/linux_heap_glibc.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "881:  GHT next_chunk = initial_brk, prev_chunk = next_chunk;",
          "882:  GH(RHeapChunk) *cnk = R_NEW0 (GH(RHeapChunk));",
          "883:  GH(RHeapChunk) *cnk_next = R_NEW0 (GH(RHeapChunk));",
          "885:   return;",
          "886:  }",
          "",
          "[Removed Lines]",
          "884:  if (!cnk || !cnk_next) {",
          "",
          "[Added Lines]",
          "883:  if (!cnk) {",
          "884:   return;",
          "885:  }",
          "887:  if (!cnk_next) {",
          "888:   free (cnk);",
          "",
          "---------------"
        ],
        "libr/debug/p/debug_windbg.c||libr/debug/p/debug_windbg.c": [
          "File: libr/debug/p/debug_windbg.c -> libr/debug/p/debug_windbg.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "261:   r_list_append (ret, mod);",
          "262:  }",
          "264:  return ret;",
          "265: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "264:  r_list_free (modules);",
          "",
          "---------------"
        ],
        "libr/lang/p/cpipe.c||libr/lang/p/cpipe.c": [
          "File: libr/lang/p/cpipe.c -> libr/lang/p/cpipe.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "59: static int lang_cpipe_run(RLang *lang, const char *code, int len) {",
          "60:  FILE *fd = r_sandbox_fopen (\".tmp.c\", \"w\");",
          "62:   eprintf (\"Cannot open .tmp.c\\n\");",
          "63:   return false;",
          "64:  }",
          "",
          "[Removed Lines]",
          "61:  if (fd) {",
          "",
          "[Added Lines]",
          "61:  if (!fd) {",
          "",
          "---------------"
        ],
        "libr/main/radare2.c||libr/main/radare2.c": [
          "File: libr/main/radare2.c -> libr/main/radare2.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "624:  if (noStderr) {",
          "625:   if (-1 == close (2)) {",
          "626:    eprintf (\"Failed to close stderr\");",
          "627:    return 1;",
          "628:   }",
          "629:   const char nul[] = R_SYS_DEVNULL;",
          "630:   int new_stderr = open (nul, O_RDWR);",
          "631:   if (-1 == new_stderr) {",
          "632:    eprintf (\"Failed to open %s\", nul);",
          "633:    return 1;",
          "634:   }",
          "635:   if (2 != new_stderr) {",
          "636:    if (-1 == dup2 (new_stderr, 2)) {",
          "637:     eprintf (\"Failed to dup2 stderr\");",
          "638:     return 1;",
          "639:    }",
          "640:    if (-1 == close (new_stderr)) {",
          "641:     eprintf (\"Failed to close %s\", nul);",
          "642:     return 1;",
          "643:    }",
          "644:   }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "627:    LISTS_FREE ();",
          "634:    LISTS_FREE ();",
          "640:     LISTS_FREE ();",
          "645:     LISTS_FREE ();",
          "",
          "---------------"
        ],
        "libr/util/intervaltree.c||libr/util/intervaltree.c": [
          "File: libr/util/intervaltree.c -> libr/util/intervaltree.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "180: }",
          "182: R_API RBIter r_interval_tree_first_at(RIntervalTree *tree, ut64 start) {",
          "187:  RIntervalNode *top_intervalnode = r_interval_tree_node_at (tree, start);",
          "",
          "[Removed Lines]",
          "183:  RBIter it;",
          "184:  it.len = 0;",
          "",
          "[Added Lines]",
          "183:  RBIter it = { 0 };",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "ebfbf1a039459606be4a1179f02934809d9d0981",
      "candidate_info": {
        "commit_hash": "ebfbf1a039459606be4a1179f02934809d9d0981",
        "repo": "radareorg/radare2",
        "commit_url": "https://github.com/radareorg/radare2/commit/ebfbf1a039459606be4a1179f02934809d9d0981",
        "files": [
          "libr/socket/socket.c"
        ],
        "message": "Fix r_socket_connect not using the given timeout in unix ##network\n\nConnect isn't effected by r_socket_block_time since it can only change the\ntimeout of read(and not implemented, write) actions with setsockopt.\nAlso, connect may wait for an unspecified amount of time so we have to use\nselect.",
        "before_after_code_files": [
          "libr/socket/socket.c||libr/socket/socket.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "libr/socket/socket.c||libr/socket/socket.c"
          ],
          "candidate": [
            "libr/socket/socket.c||libr/socket/socket.c"
          ]
        }
      },
      "candidate_diff": {
        "libr/socket/socket.c||libr/socket/socket.c": [
          "File: libr/socket/socket.c -> libr/socket/socket.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "348:     s->fd = -1;",
          "349:     continue;",
          "350:    }",
          "355:    ret = connect (s->fd, rp->ai_addr, rp->ai_addrlen);",
          "358:     freeaddrinfo (res);",
          "359:     return true;",
          "360:    }",
          "362:     struct timeval tv;",
          "367:     tv.tv_usec = 0;",
          "382:       freeaddrinfo (res);",
          "383:       return true;",
          "384:      }",
          "385:     }",
          "386:    }",
          "389:   }",
          "390:   freeaddrinfo (res);",
          "391:   if (!rp) {",
          "",
          "[Removed Lines]",
          "351:    if (timeout > 0) {",
          "352:     r_socket_block_time (s, 1, timeout, 0);",
          "354:    }",
          "357:    if (timeout == 0 && ret == 0) {",
          "361:    if (ret == 0 /* || nonblocking */) {",
          "363:     fd_set fdset, errset;",
          "364:     FD_ZERO (&fdset);",
          "365:     FD_SET (s->fd, &fdset);",
          "366:     tv.tv_sec = 1; //timeout;",
          "369:     if (r_socket_is_connected (s)) {",
          "370:      freeaddrinfo (res);",
          "371:      return true;",
          "372:     }",
          "373:     if (select (s->fd + 1, NULL, NULL, &errset, &tv) == 1) {",
          "374:      int so_error;",
          "375:      socklen_t len = sizeof so_error;",
          "376:      ret = getsockopt (s->fd, SOL_SOCKET,",
          "377:       SO_ERROR, &so_error, &len);",
          "379:      if (ret == 0 && so_error == 0) {",
          "387:    close (s->fd);",
          "388:    s->fd = -1;",
          "",
          "[Added Lines]",
          "352:    r_socket_block_time (s, 0, 0, 0);",
          "355:    if (ret == 0) {",
          "359:    if (errno == EINPROGRESS) {",
          "361:     tv.tv_sec = timeout;",
          "364:     if ((ret = select (s->fd + 1, NULL, NULL, NULL, &tv)) != -1) {",
          "365:      if (r_socket_is_connected (s)) {",
          "369:     } else {",
          "370:      perror (\"connect\");",
          "373:    r_socket_close (s);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "34e4bd72917d5d3e5d76ab0eee9bae6359f3c0fa",
      "candidate_info": {
        "commit_hash": "34e4bd72917d5d3e5d76ab0eee9bae6359f3c0fa",
        "repo": "radareorg/radare2",
        "commit_url": "https://github.com/radareorg/radare2/commit/34e4bd72917d5d3e5d76ab0eee9bae6359f3c0fa",
        "files": [
          "binr/preload/libr2.c",
          "configure",
          "configure.acr",
          "libr/cons/cons.c",
          "libr/cons/input.c",
          "libr/core/cmd.c",
          "libr/core/rtr.c",
          "libr/include/r_userconf.h.acr",
          "libr/include/r_util/r_sys.h",
          "libr/io/p/io_debug.c",
          "libr/io/p/io_self.c",
          "libr/io/p/io_tcp.c",
          "libr/main/rarun2.c",
          "libr/socket/socket.c",
          "libr/util/sys.c"
        ],
        "message": "Use sigaction instead of signal ##core",
        "before_after_code_files": [
          "binr/preload/libr2.c||binr/preload/libr2.c",
          "configure.acr||configure.acr",
          "libr/cons/cons.c||libr/cons/cons.c",
          "libr/cons/input.c||libr/cons/input.c",
          "libr/core/cmd.c||libr/core/cmd.c",
          "libr/core/rtr.c||libr/core/rtr.c",
          "libr/include/r_userconf.h.acr||libr/include/r_userconf.h.acr",
          "libr/include/r_util/r_sys.h||libr/include/r_util/r_sys.h",
          "libr/io/p/io_debug.c||libr/io/p/io_debug.c",
          "libr/io/p/io_self.c||libr/io/p/io_self.c",
          "libr/io/p/io_tcp.c||libr/io/p/io_tcp.c",
          "libr/main/rarun2.c||libr/main/rarun2.c",
          "libr/socket/socket.c||libr/socket/socket.c",
          "libr/util/sys.c||libr/util/sys.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "libr/socket/socket.c||libr/socket/socket.c",
            "libr/util/sys.c||libr/util/sys.c"
          ],
          "candidate": [
            "libr/socket/socket.c||libr/socket/socket.c",
            "libr/util/sys.c||libr/util/sys.c"
          ]
        }
      },
      "candidate_diff": {
        "binr/preload/libr2.c||binr/preload/libr2.c": [
          "File: binr/preload/libr2.c -> binr/preload/libr2.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "37: static void _libwrap_init() __attribute__ ((constructor));",
          "38: static void _libwrap_init() {",
          "39:  char *web;",
          "42:  printf (\"libr2 initialized. send SIGUSR1 to %d in order to reach the r2 prompt\\n\", getpid ());",
          "43:  printf (\"kill -USR1 %d\\n\", getpid ());",
          "44:  fflush (stdout);",
          "",
          "[Removed Lines]",
          "40:  signal (SIGUSR1, sigusr1);",
          "41:  signal (SIGUSR2, sigusr2);",
          "",
          "[Added Lines]",
          "40:  r_sys_signal (SIGUSR1, sigusr1);",
          "41:  r_sys_signal (SIGUSR2, sigusr2);",
          "",
          "---------------"
        ],
        "configure.acr||configure.acr": [
          "File: configure.acr -> configure.acr",
          "--- Hunk 1 ---",
          "[Context before]",
          "74: CHKFNC c explicit_bzero",
          "75: CHKFNC c explicit_memset",
          "76: CHKFNC c clock_nanosleep",
          "78: (( TODO must deprecate",
          "79: CHKLIB gmp",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "77: CHKFNC c sigaction",
          "",
          "---------------"
        ],
        "libr/cons/cons.c||libr/cons/cons.c": [
          "File: libr/cons/cons.c -> libr/cons/cons.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "8: #include <string.h>",
          "9: #include <stdlib.h>",
          "10: #include <stdarg.h>",
          "15: #define COUNT_LINES 1",
          "16: #define CTX(x) I.context->x",
          "",
          "[Removed Lines]",
          "11: #if __UNIX__",
          "12: #include <signal.h>",
          "13: #endif",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "293:  if (r_stack_is_empty (context->break_stack)) {",
          "294: #if __UNIX__",
          "295:   if (sig && r_cons_context_is_main ()) {",
          "297:   }",
          "298: #endif",
          "299:   context->breaked = false;",
          "",
          "[Removed Lines]",
          "296:    signal (SIGINT, __break_signal);",
          "",
          "[Added Lines]",
          "293:    r_sys_signal (SIGINT, __break_signal);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "323: #if __UNIX__",
          "324:   if (sig && r_cons_context_is_main ()) {",
          "326:   }",
          "327: #endif",
          "328:   context->breaked = false;",
          "",
          "[Removed Lines]",
          "325:    signal (SIGINT, SIG_IGN);",
          "",
          "[Added Lines]",
          "322:    r_sys_signal (SIGINT, SIG_IGN);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "404:  I.context->breaked = false;",
          "405:  I.timeout = 0;",
          "406: #if __UNIX__",
          "408: #endif",
          "409:  if (!r_stack_is_empty (I.context->break_stack)) {",
          "",
          "[Removed Lines]",
          "407:  signal (SIGINT, SIG_IGN);",
          "",
          "[Added Lines]",
          "404:  r_sys_signal (SIGINT, SIG_IGN);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "554:  I.term_raw.c_cflag &= ~(CSIZE|PARENB);",
          "555:  I.term_raw.c_cflag |= CS8;",
          "556:  I.term_raw.c_cc[VMIN] = 1; // Solaris stuff hehe",
          "558: #elif __WINDOWS__",
          "559:  h = GetStdHandle (STD_INPUT_HANDLE);",
          "560:  GetConsoleMode (h, &I.term_buf);",
          "",
          "[Removed Lines]",
          "557:  signal (SIGWINCH, resize);",
          "",
          "[Added Lines]",
          "554:  r_sys_signal (SIGWINCH, resize);",
          "",
          "---------------"
        ],
        "libr/cons/input.c||libr/cons/input.c": [
          "File: libr/cons/input.c -> libr/cons/input.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "685:  tcsetattr (0, TCSADRAIN, &a->term_raw);",
          "687: #endif",
          "688:  while (i < sizeof (buf) - 1) {",
          "689:   int ch = r_cons_readchar ();",
          "",
          "[Removed Lines]",
          "686:  signal (SIGTSTP, SIG_IGN);",
          "",
          "[Added Lines]",
          "686:  r_sys_signal (SIGTSTP, SIG_IGN);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "703:  r_cons_set_raw (0);",
          "704:  printf (\"\\n\");",
          "705: #if __UNIX__",
          "707: #endif",
          "708:  return strdup (buf);",
          "709: }",
          "",
          "[Removed Lines]",
          "706:  signal (SIGTSTP, SIG_DFL);",
          "",
          "[Added Lines]",
          "706:  r_sys_signal (SIGTSTP, SIG_DFL);",
          "",
          "---------------"
        ],
        "libr/core/cmd.c||libr/core/cmd.c": [
          "File: libr/core/cmd.c -> libr/core/cmd.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "2333:  radare_cmd = (char*)r_str_trim_head (radare_cmd);",
          "2334:  shell_cmd = (char*)r_str_trim_head (shell_cmd);",
          "2337:  stdout_fd = dup (1);",
          "2338:  if (stdout_fd != -1) {",
          "2339:   if (pipe (fds) == 0) {",
          "",
          "[Removed Lines]",
          "2336:  signal (SIGPIPE, SIG_IGN);",
          "",
          "[Added Lines]",
          "2336:  r_sys_signal (SIGPIPE, SIG_IGN);",
          "",
          "---------------"
        ],
        "libr/core/rtr.c||libr/core/rtr.c": [
          "File: libr/core/rtr.c -> libr/core/rtr.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "223:  int dt = r_config_get_i (core->config, \"http.dietime\");",
          "224:  if (dt > 0) {",
          "225: #if __UNIX__",
          "227:   alarm (dt);",
          "228: #else",
          "229:   eprintf (\"http.dietime only works on *nix systems\\n\");",
          "",
          "[Removed Lines]",
          "226:   signal (SIGALRM, dietime);",
          "",
          "[Added Lines]",
          "226:   r_sys_signal (SIGALRM, dietime);",
          "",
          "---------------"
        ],
        "libr/include/r_userconf.h.acr||libr/include/r_userconf.h.acr": [
          "File: libr/include/r_userconf.h.acr -> libr/include/r_userconf.h.acr",
          "--- Hunk 1 ---",
          "[Context before]",
          "10: #define HAVE_EXPLICIT_BZERO @HAVE_EXPLICIT_BZERO@",
          "11: #define HAVE_EXPLICIT_MEMSET @HAVE_EXPLICIT_MEMSET@",
          "12: #define HAVE_CLOCK_NANOSLEEP @HAVE_CLOCK_NANOSLEEP@",
          "14: #ifdef R_MESON_VERSION",
          "15: #define R2_PREFIX \"@PREFIX@\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "13: #define HAVE_SIGACTION @HAVE_SIGACTION@",
          "",
          "---------------"
        ],
        "libr/include/r_util/r_sys.h||libr/include/r_util/r_sys.h": [
          "File: libr/include/r_util/r_sys.h -> libr/include/r_util/r_sys.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "32: R_API RSysInfo *r_sys_info(void);",
          "33: R_API void r_sys_info_free(RSysInfo *si);",
          "35: R_API char **r_sys_get_environ(void);",
          "36: R_API void r_sys_set_environ(char **e);",
          "37: R_API ut64 r_sys_now(void);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "35: R_API int r_sys_sigaction(int *sig, void (*handler) (int));",
          "36: R_API int r_sys_signal(int sig, void (*handler) (int));",
          "",
          "---------------"
        ],
        "libr/io/p/io_debug.c||libr/io/p/io_debug.c": [
          "File: libr/io/p/io_debug.c -> libr/io/p/io_debug.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "199: static void trace_me (void) {",
          "200: #if __APPLE__",
          "202: #endif",
          "203: #if __APPLE__ || __BSD__",
          "206:  if (ptrace (PT_TRACE_ME, 0, 0, 0) != 0) {",
          "207:   r_sys_perror (\"ptrace-traceme\");",
          "208:  }",
          "",
          "[Removed Lines]",
          "201:  signal (SIGTRAP, SIG_IGN); //NEED BY STEP",
          "205:  signal (SIGABRT, inferior_abort_handler);",
          "",
          "[Added Lines]",
          "201:  r_sys_signal (SIGTRAP, SIG_IGN); //NEED BY STEP",
          "205:  r_sys_signal (SIGABRT, inferior_abort_handler);",
          "",
          "---------------"
        ],
        "libr/io/p/io_self.c||libr/io/p/io_self.c": [
          "File: libr/io/p/io_self.c -> libr/io/p/io_self.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "345:   free (argv);",
          "346: #if !defined(__WINDOWS__)",
          "347:  } else if (!strncmp (cmd, \"alarm \", 6)) {",
          "350:   alarm (atoi (cmd + 6));",
          "351: #else",
          "",
          "[Removed Lines]",
          "348:   signal (SIGALRM, got_alarm);",
          "",
          "[Added Lines]",
          "348:   r_sys_signal (SIGALRM, got_alarm);",
          "",
          "---------------"
        ],
        "libr/io/p/io_tcp.c||libr/io/p/io_tcp.c": [
          "File: libr/io/p/io_tcp.c -> libr/io/p/io_tcp.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "75:  pathname += 6;",
          "77: #if __UNIX__",
          "79: #endif",
          "80:  if (*pathname == ':') {",
          "",
          "[Removed Lines]",
          "78:  signal (SIGINT, 0);",
          "",
          "[Added Lines]",
          "78:  r_sys_signal (SIGINT, SIG_IGN);",
          "",
          "---------------"
        ],
        "libr/main/rarun2.c||libr/main/rarun2.c": [
          "File: libr/main/rarun2.c -> libr/main/rarun2.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "14:  r_sys_cmd (\"tty\");",
          "15:  close(1);",
          "16:  dup2(2, 1);",
          "18:  for (;;) {",
          "19:   sleep (1);",
          "20:  }",
          "",
          "[Removed Lines]",
          "17:  signal (SIGINT, fwd);",
          "",
          "[Added Lines]",
          "17:  r_sys_signal (SIGINT, fwd);",
          "",
          "---------------"
        ],
        "libr/socket/socket.c||libr/socket/socket.c": [
          "File: libr/socket/socket.c -> libr/socket/socket.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "153:   close (sock);",
          "154:   return false;",
          "155:  }",
          "159:  if (chmod (unix_name.sun_path, 0777) != 0) {",
          "",
          "[Removed Lines]",
          "156:  signal (SIGPIPE, SIG_IGN);",
          "",
          "[Added Lines]",
          "156:  r_sys_signal (SIGPIPE, SIG_IGN);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "177:  s->is_ssl = is_ssl;",
          "178:  s->port = 0;",
          "179: #if __UNIX_",
          "181: #endif",
          "182:  s->local = 0;",
          "183:  s->fd = R_INVALID_SOCKET;",
          "",
          "[Removed Lines]",
          "180:  signal (SIGPIPE, SIG_IGN);",
          "",
          "[Added Lines]",
          "180:  r_sys_signal (SIGPIPE, SIG_IGN);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "319:  if (!proto) {",
          "320:   proto = R_SOCKET_PROTO_TCP;",
          "321:  }",
          "323:  if (proto == R_SOCKET_PROTO_UNIX) {",
          "324:   if (!__connect_unix (s, host)) {",
          "325:    return false;",
          "",
          "[Removed Lines]",
          "322:  signal (SIGPIPE, SIG_IGN);",
          "",
          "[Added Lines]",
          "322:  r_sys_signal (SIGPIPE, SIG_IGN);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "539:   return false;",
          "540:  }",
          "541: #if __UNIX__",
          "543: #endif",
          "544:  if (listen (s->fd, 32) < 0) {",
          "545: #ifdef _MSC_VER",
          "",
          "[Removed Lines]",
          "542:  signal (SIGPIPE, SIG_IGN);",
          "",
          "[Added Lines]",
          "542:  r_sys_signal (SIGPIPE, SIG_IGN);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "735: R_API int r_socket_write(RSocket *s, void *buf, int len) {",
          "736:  int ret, delta = 0;",
          "737: #if __UNIX__",
          "739: #endif",
          "740:  for (;;) {",
          "741:   int b = 1500; //65536; // Use MTU 1500?",
          "",
          "[Removed Lines]",
          "738:  signal (SIGPIPE, SIG_IGN);",
          "",
          "[Added Lines]",
          "738:  r_sys_signal (SIGPIPE, SIG_IGN);",
          "",
          "---------------"
        ],
        "libr/util/sys.c||libr/util/sys.c": [
          "File: libr/util/sys.c -> libr/util/sys.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "142: #endif",
          "143: }",
          "145: R_API void r_sys_exit(int status, bool nocleanup) {",
          "146:  if (nocleanup) {",
          "147:   _exit (status);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "145: #if HAVE_SIGACTION",
          "146: R_API int r_sys_sigaction(int *sig, void (*handler) (int)) {",
          "147:  struct sigaction sigact = { };",
          "148:  int ret, i;",
          "150:  if (!sig) {",
          "151:   return -EINVAL;",
          "152:  }",
          "154:  sigact.sa_handler = handler;",
          "155:  sigemptyset (&sigact.sa_mask);",
          "157:  for (i = sig[0]; sig[i] != 0; i++) {",
          "158:   sigaddset (&sigact.sa_mask, sig[i]);",
          "159:  }",
          "161:  for (i = sig[0]; sig[i] != 0; i++) {",
          "162:   ret = sigaction (sig[i], &sigact, NULL);",
          "163:   if (ret) {",
          "164:    return ret;",
          "165:   }",
          "166:  }",
          "168:  return 0;",
          "169: }",
          "170: #else",
          "171: R_API int r_sys_sigaction(int *sig, void (*handler) (int)) {",
          "172:  int ret, i;",
          "174:  if (!sig) {",
          "175:   return -EINVAL;",
          "176:  }",
          "178:  for (i = sig[0]; sig[i] != 0; i++) {",
          "179:   ret = signal (sig[i], handler);",
          "180:   if (ret == SIG_ERR) {",
          "181:    return -1;",
          "182:   }",
          "183:  }",
          "184:  return 0;",
          "185: }",
          "186: #endif",
          "188: R_API int r_sys_signal(int sig, void (*handler) (int)) {",
          "189:  int s[2] = { sig, 0 };",
          "190:  return r_sys_sigaction (s, handler);",
          "191: }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "398: #endif",
          "400: R_API int r_sys_crash_handler(const char *cmd) {",
          "403:  if (!checkcmd (cmd)) {",
          "404:   return false;",
          "405:  }",
          "",
          "[Removed Lines]",
          "401: #if __UNIX__",
          "402:  struct sigaction sigact;",
          "",
          "[Added Lines]",
          "449:  int sig[] = { SIGINT, SIGSEGV, SIGBUS, SIGQUIT, SIGHUP, 0 };",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "412:  free (crash_handler_cmd);",
          "413:  crash_handler_cmd = strdup (cmd);",
          "428:  return true;",
          "432: }",
          "434: R_API char *r_sys_getenv(const char *key) {",
          "",
          "[Removed Lines]",
          "414:  sigact.sa_handler = signal_handler;",
          "415:  sigemptyset (&sigact.sa_mask);",
          "416:  sigact.sa_flags = 0;",
          "417:  sigaddset (&sigact.sa_mask, SIGINT);",
          "418:  sigaddset (&sigact.sa_mask, SIGSEGV);",
          "419:  sigaddset (&sigact.sa_mask, SIGBUS);",
          "420:  sigaddset (&sigact.sa_mask, SIGQUIT);",
          "421:  sigaddset (&sigact.sa_mask, SIGHUP);",
          "423:  sigaction (SIGINT, &sigact, (struct sigaction *)NULL);",
          "424:  sigaction (SIGSEGV, &sigact, (struct sigaction *)NULL);",
          "425:  sigaction (SIGBUS, &sigact, (struct sigaction *)NULL);",
          "426:  sigaction (SIGQUIT, &sigact, (struct sigaction *)NULL);",
          "427:  sigaction (SIGHUP, &sigact, (struct sigaction *)NULL);",
          "429: #else",
          "430:  return false;",
          "431: #endif",
          "",
          "[Added Lines]",
          "463:  r_sys_sigaction (sig, signal_handler);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "620:    close (sh_in[1]);",
          "621:   }",
          "624:   for (;;) {",
          "625:    fd_set rfds, wfds;",
          "626:    int nfd;",
          "",
          "[Removed Lines]",
          "623:   signal (SIGPIPE, SIG_IGN);",
          "",
          "[Added Lines]",
          "656:   r_sys_signal (SIGPIPE, SIG_IGN);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "2318e1afcc7521b0d221e696b3832113d7ec7d5e",
      "candidate_info": {
        "commit_hash": "2318e1afcc7521b0d221e696b3832113d7ec7d5e",
        "repo": "radareorg/radare2",
        "commit_url": "https://github.com/radareorg/radare2/commit/2318e1afcc7521b0d221e696b3832113d7ec7d5e",
        "files": [
          "libr/socket/socket.c"
        ],
        "message": "Use SSL_get_error only if SSL is being used",
        "before_after_code_files": [
          "libr/socket/socket.c||libr/socket/socket.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "libr/socket/socket.c||libr/socket/socket.c"
          ],
          "candidate": [
            "libr/socket/socket.c||libr/socket/socket.c"
          ]
        }
      },
      "candidate_diff": {
        "libr/socket/socket.c||libr/socket/socket.c": [
          "File: libr/socket/socket.c -> libr/socket/socket.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "798:   int r = r_socket_read (s, buf + ret, len - ret);",
          "799:   if (r == -1) {",
          "800: #if HAVE_LIB_SSL",
          "802:     if (r_socket_ready (s, 1, 0) == 1) {",
          "803:      continue;",
          "804:     }",
          "",
          "[Removed Lines]",
          "801:    if (SSL_get_error (s->sfd, r) == SSL_ERROR_WANT_READ) {",
          "",
          "[Added Lines]",
          "801:    if (s->is_ssl && SSL_get_error (s->sfd, r) == SSL_ERROR_WANT_READ) {",
          "",
          "---------------"
        ]
      }
    }
  ]
}
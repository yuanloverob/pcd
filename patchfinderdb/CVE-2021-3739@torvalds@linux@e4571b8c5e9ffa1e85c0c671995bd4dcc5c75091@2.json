{
  "cve_id": "CVE-2021-3739",
  "cve_desc": "A NULL pointer dereference flaw was found in the btrfs_rm_device function in fs/btrfs/volumes.c in the Linux Kernel, where triggering the bug requires \u2018CAP_SYS_ADMIN\u2019. This flaw allows a local attacker to crash the system or leak kernel internal information. The highest threat from this vulnerability is to system availability.",
  "repo": "torvalds/linux",
  "patch_hash": "e4571b8c5e9ffa1e85c0c671995bd4dcc5c75091",
  "patch_info": {
    "commit_hash": "e4571b8c5e9ffa1e85c0c671995bd4dcc5c75091",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/e4571b8c5e9ffa1e85c0c671995bd4dcc5c75091",
    "files": [
      "fs/btrfs/volumes.c"
    ],
    "message": "btrfs: fix NULL pointer dereference when deleting device by invalid id\n\n[BUG]\nIt's easy to trigger NULL pointer dereference, just by removing a\nnon-existing device id:\n\n # mkfs.btrfs -f -m single -d single /dev/test/scratch1 \\\n\t\t\t\t     /dev/test/scratch2\n # mount /dev/test/scratch1 /mnt/btrfs\n # btrfs device remove 3 /mnt/btrfs\n\nThen we have the following kernel NULL pointer dereference:\n\n BUG: kernel NULL pointer dereference, address: 0000000000000000\n #PF: supervisor read access in kernel mode\n #PF: error_code(0x0000) - not-present page\n PGD 0 P4D 0\n Oops: 0000 [#1] PREEMPT SMP NOPTI\n CPU: 9 PID: 649 Comm: btrfs Not tainted 5.14.0-rc3-custom+ #35\n Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 0.0.0 02/06/2015\n RIP: 0010:btrfs_rm_device+0x4de/0x6b0 [btrfs]\n  btrfs_ioctl+0x18bb/0x3190 [btrfs]\n  ? lock_is_held_type+0xa5/0x120\n  ? find_held_lock.constprop.0+0x2b/0x80\n  ? do_user_addr_fault+0x201/0x6a0\n  ? lock_release+0xd2/0x2d0\n  ? __x64_sys_ioctl+0x83/0xb0\n  __x64_sys_ioctl+0x83/0xb0\n  do_syscall_64+0x3b/0x90\n  entry_SYSCALL_64_after_hwframe+0x44/0xae\n\n[CAUSE]\nCommit a27a94c2b0c7 (\"btrfs: Make btrfs_find_device_by_devspec return\nbtrfs_device directly\") moves the \"missing\" device path check into\nbtrfs_rm_device().\n\nBut btrfs_rm_device() itself can have case where it only receives\n@devid, with NULL as @device_path.\n\nIn that case, calling strcmp() on NULL will trigger the NULL pointer\ndereference.\n\nBefore that commit, we handle the \"missing\" case inside\nbtrfs_find_device_by_devspec(), which will not check @device_path at all\nif @devid is provided, thus no way to trigger the bug.\n\n[FIX]\nBefore calling strcmp(), also make sure @device_path is not NULL.\n\nFixes: a27a94c2b0c7 (\"btrfs: Make btrfs_find_device_by_devspec return btrfs_device directly\")\nCC: stable@vger.kernel.org # 5.4+\nReported-by: butt3rflyh4ck <butterflyhuangxx@gmail.com>\nReviewed-by: Anand Jain <anand.jain@oracle.com>\nSigned-off-by: Qu Wenruo <wqu@suse.com>\nReviewed-by: David Sterba <dsterba@suse.com>\nSigned-off-by: David Sterba <dsterba@suse.com>",
    "before_after_code_files": [
      "fs/btrfs/volumes.c||fs/btrfs/volumes.c"
    ]
  },
  "patch_diff": {
    "fs/btrfs/volumes.c||fs/btrfs/volumes.c": [
      "File: fs/btrfs/volumes.c -> fs/btrfs/volumes.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "2075:  if (IS_ERR(device)) {",
      "2076:   if (PTR_ERR(device) == -ENOENT &&",
      "2078:    ret = BTRFS_ERROR_DEV_MISSING_NOT_FOUND;",
      "2079:   else",
      "2080:    ret = PTR_ERR(device);",
      "",
      "[Removed Lines]",
      "2077:       strcmp(device_path, \"missing\") == 0)",
      "",
      "[Added Lines]",
      "2077:       device_path && strcmp(device_path, \"missing\") == 0)",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "cc1d0d93d55ac12e7faee9acfcd7c28c8b86cf89",
      "candidate_info": {
        "commit_hash": "cc1d0d93d55ac12e7faee9acfcd7c28c8b86cf89",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/cc1d0d93d55ac12e7faee9acfcd7c28c8b86cf89",
        "files": [
          "fs/btrfs/extent_io.c",
          "fs/btrfs/subpage.c",
          "fs/btrfs/subpage.h"
        ],
        "message": "btrfs: subpage: fix writeback which does not have ordered extent\n\n[BUG]\nWhen running fsstress with subpage RW support, there are random\nBUG_ON()s triggered with the following trace:\n\n kernel BUG at fs/btrfs/file-item.c:667!\n Internal error: Oops - BUG: 0 [#1] SMP\n CPU: 1 PID: 3486 Comm: kworker/u13:2 5.11.0-rc4-custom+ #43\n Hardware name: Radxa ROCK Pi 4B (DT)\n Workqueue: btrfs-worker-high btrfs_work_helper [btrfs]\n pstate: 60000005 (nZCv daif -PAN -UAO -TCO BTYPE=--)\n pc : btrfs_csum_one_bio+0x420/0x4e0 [btrfs]\n lr : btrfs_csum_one_bio+0x400/0x4e0 [btrfs]\n Call trace:\n  btrfs_csum_one_bio+0x420/0x4e0 [btrfs]\n  btrfs_submit_bio_start+0x20/0x30 [btrfs]\n  run_one_async_start+0x28/0x44 [btrfs]\n  btrfs_work_helper+0x128/0x1b4 [btrfs]\n  process_one_work+0x22c/0x430\n  worker_thread+0x70/0x3a0\n  kthread+0x13c/0x140\n  ret_from_fork+0x10/0x30\n\n[CAUSE]\nAbove BUG_ON() means there is some bio range which doesn't have ordered\nextent, which indeed is worth a BUG_ON().\n\nUnlike regular sectorsize == PAGE_SIZE case, in subpage we have extra\nsubpage dirty bitmap to record which range is dirty and should be\nwritten back.\n\nThis means, if we submit bio for a subpage range, we do not only need to\nclear page dirty, but also need to clear subpage dirty bits.\n\nIn __extent_writepage_io(), we will call btrfs_page_clear_dirty() for\nany range we submit a bio.\n\nBut there is loophole, if we hit a range which is beyond i_size, we just\ncall btrfs_writepage_endio_finish_ordered() to finish the ordered io,\nthen break out, without clearing the subpage dirty.\n\nThis means, if we hit above branch, the subpage dirty bits are still\nthere, if other range of the page get dirtied and we need to writeback\nthat page again, we will submit bio for the old range, leaving a wild\nbio range which doesn't have ordered extent.\n\n[FIX]\nFix it by always calling btrfs_page_clear_dirty() in\n__extent_writepage_io().\n\nAlso to avoid such problem from happening again, add a new assert,\nbtrfs_page_assert_not_dirty(), to make sure both page dirty and subpage\ndirty bits are cleared before exiting __extent_writepage_io().\n\nSigned-off-by: Qu Wenruo <wqu@suse.com>\nSigned-off-by: David Sterba <dsterba@suse.com>",
        "before_after_code_files": [
          "fs/btrfs/extent_io.c||fs/btrfs/extent_io.c",
          "fs/btrfs/subpage.c||fs/btrfs/subpage.c",
          "fs/btrfs/subpage.h||fs/btrfs/subpage.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "fs/btrfs/extent_io.c||fs/btrfs/extent_io.c": [
          "File: fs/btrfs/extent_io.c -> fs/btrfs/extent_io.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "3864:   if (cur >= i_size) {",
          "3865:    btrfs_writepage_endio_finish_ordered(inode, page, cur,",
          "3866:             end, true);",
          "3867:    break;",
          "3868:   }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3875:    btrfs_page_clear_dirty(fs_info, page, cur, end + 1 - cur);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "3914:    else",
          "3915:     btrfs_writepage_endio_finish_ordered(inode,",
          "3916:       page, cur, cur + iosize - 1, true);",
          "3917:    cur += iosize;",
          "3918:    continue;",
          "3919:   }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3926:    btrfs_page_clear_dirty(fs_info, page, cur, iosize);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "3949:   cur += iosize;",
          "3950:   nr++;",
          "3951:  }",
          "3953:  return ret;",
          "3954: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3966:  if (!ret)",
          "3967:   btrfs_page_assert_not_dirty(fs_info, page);",
          "",
          "---------------"
        ],
        "fs/btrfs/subpage.c||fs/btrfs/subpage.c": [
          "File: fs/btrfs/subpage.c -> fs/btrfs/subpage.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "559:     PageWriteback);",
          "560: IMPLEMENT_BTRFS_PAGE_OPS(ordered, SetPageOrdered, ClearPageOrdered,",
          "561:     PageOrdered);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "567: void btrfs_page_assert_not_dirty(const struct btrfs_fs_info *fs_info,",
          "568:      struct page *page)",
          "569: {",
          "570:  struct btrfs_subpage *subpage = (struct btrfs_subpage *)page->private;",
          "572:  if (!IS_ENABLED(CONFIG_BTRFS_ASSERT))",
          "573:   return;",
          "575:  ASSERT(!PageDirty(page));",
          "576:  if (fs_info->sectorsize == PAGE_SIZE)",
          "577:   return;",
          "579:  ASSERT(PagePrivate(page) && page->private);",
          "580:  ASSERT(subpage->dirty_bitmap == 0);",
          "581: }",
          "",
          "---------------"
        ],
        "fs/btrfs/subpage.h||fs/btrfs/subpage.h": [
          "File: fs/btrfs/subpage.h -> fs/btrfs/subpage.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "126: bool btrfs_subpage_clear_and_test_dirty(const struct btrfs_fs_info *fs_info,",
          "127:   struct page *page, u64 start, u32 len);",
          "129: #endif",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "129: void btrfs_page_assert_not_dirty(const struct btrfs_fs_info *fs_info,",
          "130:      struct page *page);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "0d977e0eba234e01a60bdde27314dc21374201b3",
      "candidate_info": {
        "commit_hash": "0d977e0eba234e01a60bdde27314dc21374201b3",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/0d977e0eba234e01a60bdde27314dc21374201b3",
        "files": [
          "fs/btrfs/volumes.c"
        ],
        "message": "btrfs: reset replace target device to allocation state on close\n\nThis crash was observed with a failed assertion on device close:\n\n  BTRFS: Transaction aborted (error -28)\n  WARNING: CPU: 1 PID: 3902 at fs/btrfs/extent-tree.c:2150 btrfs_run_delayed_refs+0x1d2/0x1e0 [btrfs]\n  Modules linked in: btrfs blake2b_generic libcrc32c crc32c_intel xor zstd_decompress zstd_compress xxhash lzo_compress lzo_decompress raid6_pq loop\n  CPU: 1 PID: 3902 Comm: kworker/u8:4 Not tainted 5.14.0-rc5-default+ #1532\n  Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.12.0-59-gc9ba527-rebuilt.opensuse.org 04/01/2014\n  Workqueue: events_unbound btrfs_async_reclaim_metadata_space [btrfs]\n  RIP: 0010:btrfs_run_delayed_refs+0x1d2/0x1e0 [btrfs]\n  RSP: 0018:ffffb7a5452d7d80 EFLAGS: 00010282\n  RAX: 0000000000000000 RBX: 0000000000000003 RCX: 0000000000000000\n  RDX: 0000000000000001 RSI: ffffffffabee13c4 RDI: 00000000ffffffff\n  RBP: ffff97834176a378 R08: 0000000000000001 R09: 0000000000000001\n  R10: 0000000000000000 R11: 0000000000000001 R12: ffff97835195d388\n  R13: 0000000005b08000 R14: ffff978385484000 R15: 000000000000016c\n  FS:  0000000000000000(0000) GS:ffff9783bd800000(0000) knlGS:0000000000000000\n  CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n  CR2: 000056190d003fe8 CR3: 000000002a81e005 CR4: 0000000000170ea0\n  Call Trace:\n   flush_space+0x197/0x2f0 [btrfs]\n   btrfs_async_reclaim_metadata_space+0x139/0x300 [btrfs]\n   process_one_work+0x262/0x5e0\n   worker_thread+0x4c/0x320\n   ? process_one_work+0x5e0/0x5e0\n   kthread+0x144/0x170\n   ? set_kthread_struct+0x40/0x40\n   ret_from_fork+0x1f/0x30\n  irq event stamp: 19334989\n  hardirqs last  enabled at (19334997): [<ffffffffab0e0c87>] console_unlock+0x2b7/0x400\n  hardirqs last disabled at (19335006): [<ffffffffab0e0d0d>] console_unlock+0x33d/0x400\n  softirqs last  enabled at (19334900): [<ffffffffaba0030d>] __do_softirq+0x30d/0x574\n  softirqs last disabled at (19334893): [<ffffffffab0721ec>] irq_exit_rcu+0x12c/0x140\n  ---[ end trace 45939e308e0dd3c7 ]---\n  BTRFS: error (device vdd) in btrfs_run_delayed_refs:2150: errno=-28 No space left\n  BTRFS info (device vdd): forced readonly\n  BTRFS warning (device vdd): failed setting block group ro: -30\n  BTRFS info (device vdd): suspending dev_replace for unmount\n  assertion failed: !test_bit(BTRFS_DEV_STATE_REPLACE_TGT, &device->dev_state), in fs/btrfs/volumes.c:1150\n  ------------[ cut here ]------------\n  kernel BUG at fs/btrfs/ctree.h:3431!\n  invalid opcode: 0000 [#1] PREEMPT SMP\n  CPU: 1 PID: 3982 Comm: umount Tainted: G        W         5.14.0-rc5-default+ #1532\n  Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.12.0-59-gc9ba527-rebuilt.opensuse.org 04/01/2014\n  RIP: 0010:assertfail.constprop.0+0x18/0x1a [btrfs]\n  RSP: 0018:ffffb7a5454c7db8 EFLAGS: 00010246\n  RAX: 0000000000000068 RBX: ffff978364b91c00 RCX: 0000000000000000\n  RDX: 0000000000000000 RSI: ffffffffabee13c4 RDI: 00000000ffffffff\n  RBP: ffff9783523a4c00 R08: 0000000000000001 R09: 0000000000000001\n  R10: 0000000000000000 R11: 0000000000000001 R12: ffff9783523a4d18\n  R13: 0000000000000000 R14: 0000000000000004 R15: 0000000000000003\n  FS:  00007f61c8f42800(0000) GS:ffff9783bd800000(0000) knlGS:0000000000000000\n  CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n  CR2: 000056190cffa810 CR3: 0000000030b96002 CR4: 0000000000170ea0\n  Call Trace:\n   btrfs_close_one_device.cold+0x11/0x55 [btrfs]\n   close_fs_devices+0x44/0xb0 [btrfs]\n   btrfs_close_devices+0x48/0x160 [btrfs]\n   generic_shutdown_super+0x69/0x100\n   kill_anon_super+0x14/0x30\n   btrfs_kill_super+0x12/0x20 [btrfs]\n   deactivate_locked_super+0x2c/0xa0\n   cleanup_mnt+0x144/0x1b0\n   task_work_run+0x59/0xa0\n   exit_to_user_mode_loop+0xe7/0xf0\n   exit_to_user_mode_prepare+0xaf/0xf0\n   syscall_exit_to_user_mode+0x19/0x50\n   do_syscall_64+0x4a/0x90\n   entry_SYSCALL_64_after_hwframe+0x44/0xae\n\nThis happens when close_ctree is called while a dev_replace hasn't\ncompleted. In close_ctree, we suspend the dev_replace, but keep the\nreplace target around so that we can resume the dev_replace procedure\nwhen we mount the root again. This is the call trace:\n\n  close_ctree():\n    btrfs_dev_replace_suspend_for_unmount();\n    btrfs_close_devices():\n      btrfs_close_fs_devices():\n        btrfs_close_one_device():\n          ASSERT(!test_bit(BTRFS_DEV_STATE_REPLACE_TGT,\n                 &device->dev_state));\n\nHowever, since the replace target sticks around, there is a device\nwith BTRFS_DEV_STATE_REPLACE_TGT set on close, and we fail the\nassertion in btrfs_close_one_device.\n\nTo fix this, if we come across the replace target device when\nclosing, we should properly reset it back to allocation state. This\nfix also ensures that if a non-target device has a corrupted state and\nhas the BTRFS_DEV_STATE_REPLACE_TGT bit set, the assertion will still\ncatch the error.\n\nReported-by: David Sterba <dsterba@suse.com>\nFixes: b2a616676839 (\"btrfs: fix rw device counting in __btrfs_free_extra_devids\")\nCC: stable@vger.kernel.org # 4.19+\nReviewed-by: Anand Jain <anand.jain@oracle.com>\nSigned-off-by: Desmond Cheong Zhi Xi <desmondcheongzx@gmail.com>\nReviewed-by: David Sterba <dsterba@suse.com>\nSigned-off-by: David Sterba <dsterba@suse.com>",
        "before_after_code_files": [
          "fs/btrfs/volumes.c||fs/btrfs/volumes.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [
            "fs/btrfs/volumes.c||fs/btrfs/volumes.c"
          ],
          "candidate": [
            "fs/btrfs/volumes.c||fs/btrfs/volumes.c"
          ]
        }
      },
      "candidate_diff": {
        "fs/btrfs/volumes.c||fs/btrfs/volumes.c": [
          "File: fs/btrfs/volumes.c -> fs/btrfs/volumes.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1118:   fs_devices->rw_devices--;",
          "1119:  }",
          "1121:  if (test_bit(BTRFS_DEV_STATE_MISSING, &device->dev_state))",
          "1122:   fs_devices->missing_devices--;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1121:  if (device->devid == BTRFS_DEV_REPLACE_DEVID)",
          "1122:   clear_bit(BTRFS_DEV_STATE_REPLACE_TGT, &device->dev_state);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "3eb9cdffb39701743973382860f214026f4d7825",
      "candidate_info": {
        "commit_hash": "3eb9cdffb39701743973382860f214026f4d7825",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/3eb9cdffb39701743973382860f214026f4d7825",
        "files": [
          "arch/arm64/Kconfig",
          "arch/arm64/include/asm/page.h",
          "arch/arm64/mm/init.c"
        ],
        "message": "Partially revert \"arm64/mm: drop HAVE_ARCH_PFN_VALID\"\n\nThis partially reverts commit 16c9afc776608324ca71c0bc354987bab532f51d.\n\nAlex Bee reports a regression in 5.14 on their RK3328 SoC when\nconfiguring the PL330 DMA controller:\n\n | ------------[ cut here ]------------\n | WARNING: CPU: 2 PID: 373 at kernel/dma/mapping.c:235 dma_map_resource+0x68/0xc0\n | Modules linked in: spi_rockchip(+) fuse\n | CPU: 2 PID: 373 Comm: systemd-udevd Not tainted 5.14.0-rc7 #1\n | Hardware name: Pine64 Rock64 (DT)\n | pstate: 80000005 (Nzcv daif -PAN -UAO -TCO BTYPE=--)\n | pc : dma_map_resource+0x68/0xc0\n | lr : pl330_prep_slave_fifo+0x78/0xd0\n\nThis appears to be because dma_map_resource() is being called for a\nphysical address which does not correspond to a memory address yet does\nhave a valid 'struct page' due to the way in which the vmemmap is\nconstructed.\n\nPrior to 16c9afc77660 (\"arm64/mm: drop HAVE_ARCH_PFN_VALID\"), the arm64\nimplementation of pfn_valid() called memblock_is_memory() to return\n'false' for such regions and the DMA mapping request would proceed.\nHowever, now that we are using the generic implementation where only the\npresence of the memory map entry is considered, we return 'true' and\nerroneously fail with DMA_MAPPING_ERROR because we identify the region\nas DRAM.\n\nAlthough fixing this in the DMA mapping code is arguably the right fix,\nit is a risky, cross-architecture change at this stage in the cycle. So\njust revert arm64 back to its old pfn_valid() implementation for v5.14.\nThe change to the generic pfn_valid() code is preserved from the original\npatch, so as to avoid impacting other architectures.\n\nCc: Catalin Marinas <catalin.marinas@arm.com>\nCc: Robin Murphy <robin.murphy@arm.com>\nCc: Mike Rapoport <rppt@kernel.org>\nCc: Anshuman Khandual <anshuman.khandual@arm.com>\nCc: Christoph Hellwig <hch@lst.de>\nReported-by: Alex Bee <knaerzche@gmail.com>\nLink: https://lore.kernel.org/r/d3a3c828-b777-faf8-e901-904995688437@gmail.com\nSigned-off-by: Will Deacon <will@kernel.org>",
        "before_after_code_files": [
          "arch/arm64/include/asm/page.h||arch/arm64/include/asm/page.h",
          "arch/arm64/mm/init.c||arch/arm64/mm/init.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "arch/arm64/include/asm/page.h||arch/arm64/include/asm/page.h": [
          "File: arch/arm64/include/asm/page.h -> arch/arm64/include/asm/page.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "42: typedef struct page *pgtable_t;",
          "44: int pfn_is_map_memory(unsigned long pfn);",
          "46: #include <asm/memory.h>",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "44: int pfn_valid(unsigned long pfn);",
          "",
          "---------------"
        ],
        "arch/arm64/mm/init.c||arch/arm64/mm/init.c": [
          "File: arch/arm64/mm/init.c -> arch/arm64/mm/init.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "219:  free_area_init(max_zone_pfns);",
          "220: }",
          "222: int pfn_is_map_memory(unsigned long pfn)",
          "223: {",
          "224:  phys_addr_t addr = PFN_PHYS(pfn);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "222: int pfn_valid(unsigned long pfn)",
          "223: {",
          "224:  phys_addr_t addr = PFN_PHYS(pfn);",
          "225:  struct mem_section *ms;",
          "233:  if (PHYS_PFN(addr) != pfn)",
          "234:   return 0;",
          "236:  if (pfn_to_section_nr(pfn) >= NR_MEM_SECTIONS)",
          "237:   return 0;",
          "239:  ms = __pfn_to_section(pfn);",
          "240:  if (!valid_section(ms))",
          "241:   return 0;",
          "252:  if (!early_section(ms))",
          "253:   return pfn_section_valid(ms, pfn);",
          "255:  return memblock_is_memory(addr);",
          "256: }",
          "257: EXPORT_SYMBOL(pfn_valid);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "9f7853d7609d59172eecfc5e7ccf503bc1b690bd",
      "candidate_info": {
        "commit_hash": "9f7853d7609d59172eecfc5e7ccf503bc1b690bd",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/9f7853d7609d59172eecfc5e7ccf503bc1b690bd",
        "files": [
          "arch/powerpc/mm/pageattr.c"
        ],
        "message": "powerpc/mm: Fix set_memory_*() against concurrent accesses\n\nLaurent reported that STRICT_MODULE_RWX was causing intermittent crashes\non one of his systems:\n\n  kernel tried to execute exec-protected page (c008000004073278) - exploit attempt? (uid: 0)\n  BUG: Unable to handle kernel instruction fetch\n  Faulting instruction address: 0xc008000004073278\n  Oops: Kernel access of bad area, sig: 11 [#1]\n  LE PAGE_SIZE=64K MMU=Radix SMP NR_CPUS=2048 NUMA pSeries\n  Modules linked in: drm virtio_console fuse drm_panel_orientation_quirks ...\n  CPU: 3 PID: 44 Comm: kworker/3:1 Not tainted 5.14.0-rc4+ #12\n  Workqueue: events control_work_handler [virtio_console]\n  NIP:  c008000004073278 LR: c008000004073278 CTR: c0000000001e9de0\n  REGS: c00000002e4ef7e0 TRAP: 0400   Not tainted  (5.14.0-rc4+)\n  MSR:  800000004280b033 <SF,VEC,VSX,EE,FP,ME,IR,DR,RI,LE>  CR: 24002822 XER: 200400cf\n  ...\n  NIP fill_queue+0xf0/0x210 [virtio_console]\n  LR  fill_queue+0xf0/0x210 [virtio_console]\n  Call Trace:\n    fill_queue+0xb4/0x210 [virtio_console] (unreliable)\n    add_port+0x1a8/0x470 [virtio_console]\n    control_work_handler+0xbc/0x1e8 [virtio_console]\n    process_one_work+0x290/0x590\n    worker_thread+0x88/0x620\n    kthread+0x194/0x1a0\n    ret_from_kernel_thread+0x5c/0x64\n\nJordan, Fabiano & Murilo were able to reproduce and identify that the\nproblem is caused by the call to module_enable_ro() in do_init_module(),\nwhich happens after the module's init function has already been called.\n\nOur current implementation of change_page_attr() is not safe against\nconcurrent accesses, because it invalidates the PTE before flushing the\nTLB and then installing the new PTE. That leaves a window in time where\nthere is no valid PTE for the page, if another CPU tries to access the\npage at that time we see something like the fault above.\n\nWe can't simply switch to set_pte_at()/flush TLB, because our hash MMU\ncode doesn't handle a set_pte_at() of a valid PTE. See [1].\n\nBut we do have pte_update(), which replaces the old PTE with the new,\nmeaning there's no window where the PTE is invalid. And the hash MMU\nversion hash__pte_update() deals with synchronising the hash page table\ncorrectly.\n\n[1]: https://lore.kernel.org/linuxppc-dev/87y318wp9r.fsf@linux.ibm.com/\n\nFixes: 1f9ad21c3b38 (\"powerpc/mm: Implement set_memory() routines\")\nReported-by: Laurent Vivier <lvivier@redhat.com>\nReviewed-by: Christophe Leroy <christophe.leroy@csgroup.eu>\nReviewed-by: Murilo Opsfelder Ara\u00fajo <muriloo@linux.ibm.com>\nTested-by: Laurent Vivier <lvivier@redhat.com>\nSigned-off-by: Fabiano Rosas <farosas@linux.ibm.com>\nSigned-off-by: Michael Ellerman <mpe@ellerman.id.au>\nLink: https://lore.kernel.org/r/20210818120518.3603172-1-mpe@ellerman.id.au",
        "before_after_code_files": [
          "arch/powerpc/mm/pageattr.c||arch/powerpc/mm/pageattr.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "arch/powerpc/mm/pageattr.c||arch/powerpc/mm/pageattr.c": [
          "File: arch/powerpc/mm/pageattr.c -> arch/powerpc/mm/pageattr.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "37:  spin_lock(&init_mm.page_table_lock);",
          "44:  switch (action) {",
          "",
          "[Removed Lines]",
          "40:  pte = ptep_get_and_clear(&init_mm, addr, ptep);",
          "41:  flush_tlb_kernel_range(addr, addr + PAGE_SIZE);",
          "",
          "[Added Lines]",
          "35:  pte = ptep_get(ptep);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "59:   break;",
          "60:  }",
          "65:  if (radix_enabled())",
          "66:   asm volatile(\"ptesync\": : :\"memory\");",
          "67:  spin_unlock(&init_mm.page_table_lock);",
          "69:  return 0;",
          "",
          "[Removed Lines]",
          "62:  set_pte_at(&init_mm, addr, ptep, pte);",
          "",
          "[Added Lines]",
          "56:  pte_update(&init_mm, addr, ptep, ~0UL, pte_val(pte), 0);",
          "62:  flush_tlb_kernel_range(addr, addr + PAGE_SIZE);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "fe4d55773b879c785ae61da9b1c2160f0110f67e",
      "candidate_info": {
        "commit_hash": "fe4d55773b879c785ae61da9b1c2160f0110f67e",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/fe4d55773b879c785ae61da9b1c2160f0110f67e",
        "files": [
          "drivers/crypto/omap-aes.c",
          "drivers/crypto/omap-des.c",
          "drivers/crypto/omap-sham.c"
        ],
        "message": "crypto: omap - Fix inconsistent locking of device lists\n\nlockdep complains that in omap-aes, the list_lock is taken both with\nsoftirqs enabled at probe time, and also in softirq context, which\ncould lead to a deadlock:\n\n    ================================\n    WARNING: inconsistent lock state\n    5.14.0-rc1-00035-gc836005b01c5-dirty #69 Not tainted\n    --------------------------------\n    inconsistent {SOFTIRQ-ON-W} -> {IN-SOFTIRQ-W} usage.\n    ksoftirqd/0/7 [HC0[0]:SC1[3]:HE1:SE0] takes:\n    bf00e014 (list_lock){+.?.}-{2:2}, at: omap_aes_find_dev+0x18/0x54 [omap_aes_driver]\n    {SOFTIRQ-ON-W} state was registered at:\n      _raw_spin_lock+0x40/0x50\n      omap_aes_probe+0x1d4/0x664 [omap_aes_driver]\n      platform_probe+0x58/0xb8\n      really_probe+0xbc/0x314\n      __driver_probe_device+0x80/0xe4\n      driver_probe_device+0x30/0xc8\n      __driver_attach+0x70/0xf4\n      bus_for_each_dev+0x70/0xb4\n      bus_add_driver+0xf0/0x1d4\n      driver_register+0x74/0x108\n      do_one_initcall+0x84/0x2e4\n      do_init_module+0x5c/0x240\n      load_module+0x221c/0x2584\n      sys_finit_module+0xb0/0xec\n      ret_fast_syscall+0x0/0x2c\n      0xbed90b30\n    irq event stamp: 111800\n    hardirqs last  enabled at (111800): [<c02a21e4>] __kmalloc+0x484/0x5ec\n    hardirqs last disabled at (111799): [<c02a21f0>] __kmalloc+0x490/0x5ec\n    softirqs last  enabled at (111776): [<c01015f0>] __do_softirq+0x2b8/0x4d0\n    softirqs last disabled at (111781): [<c0135948>] run_ksoftirqd+0x34/0x50\n\n    other info that might help us debug this:\n     Possible unsafe locking scenario:\n\n           CPU0\n           ----\n      lock(list_lock);\n      <Interrupt>\n        lock(list_lock);\n\n     *** DEADLOCK ***\n\n    2 locks held by ksoftirqd/0/7:\n     #0: c0f5e8c8 (rcu_read_lock){....}-{1:2}, at: netif_receive_skb+0x6c/0x260\n     #1: c0f5e8c8 (rcu_read_lock){....}-{1:2}, at: ip_local_deliver_finish+0x2c/0xdc\n\n    stack backtrace:\n    CPU: 0 PID: 7 Comm: ksoftirqd/0 Not tainted 5.14.0-rc1-00035-gc836005b01c5-dirty #69\n    Hardware name: Generic AM43 (Flattened Device Tree)\n    [<c010e6e0>] (unwind_backtrace) from [<c010b9d0>] (show_stack+0x10/0x14)\n    [<c010b9d0>] (show_stack) from [<c017c640>] (mark_lock.part.17+0x5bc/0xd04)\n    [<c017c640>] (mark_lock.part.17) from [<c017d9e4>] (__lock_acquire+0x960/0x2fa4)\n    [<c017d9e4>] (__lock_acquire) from [<c0180980>] (lock_acquire+0x10c/0x358)\n    [<c0180980>] (lock_acquire) from [<c093d324>] (_raw_spin_lock_bh+0x44/0x58)\n    [<c093d324>] (_raw_spin_lock_bh) from [<bf00b258>] (omap_aes_find_dev+0x18/0x54 [omap_aes_driver])\n    [<bf00b258>] (omap_aes_find_dev [omap_aes_driver]) from [<bf00b328>] (omap_aes_crypt+0x94/0xd4 [omap_aes_driver])\n    [<bf00b328>] (omap_aes_crypt [omap_aes_driver]) from [<c08ac6d0>] (esp_input+0x1b0/0x2c8)\n    [<c08ac6d0>] (esp_input) from [<c08c9e90>] (xfrm_input+0x410/0x1290)\n    [<c08c9e90>] (xfrm_input) from [<c08b6374>] (xfrm4_esp_rcv+0x54/0x11c)\n    [<c08b6374>] (xfrm4_esp_rcv) from [<c0838840>] (ip_protocol_deliver_rcu+0x48/0x3bc)\n    [<c0838840>] (ip_protocol_deliver_rcu) from [<c0838c50>] (ip_local_deliver_finish+0x9c/0xdc)\n    [<c0838c50>] (ip_local_deliver_finish) from [<c0838dd8>] (ip_local_deliver+0x148/0x1b0)\n    [<c0838dd8>] (ip_local_deliver) from [<c0838f5c>] (ip_rcv+0x11c/0x180)\n    [<c0838f5c>] (ip_rcv) from [<c077e3a4>] (__netif_receive_skb_one_core+0x54/0x74)\n    [<c077e3a4>] (__netif_receive_skb_one_core) from [<c077e588>] (netif_receive_skb+0xa8/0x260)\n    [<c077e588>] (netif_receive_skb) from [<c068d6d4>] (cpsw_rx_handler+0x224/0x2fc)\n    [<c068d6d4>] (cpsw_rx_handler) from [<c0688ccc>] (__cpdma_chan_process+0xf4/0x188)\n    [<c0688ccc>] (__cpdma_chan_process) from [<c068a0c0>] (cpdma_chan_process+0x3c/0x5c)\n    [<c068a0c0>] (cpdma_chan_process) from [<c0690e14>] (cpsw_rx_mq_poll+0x44/0x98)\n    [<c0690e14>] (cpsw_rx_mq_poll) from [<c0780810>] (__napi_poll+0x28/0x268)\n    [<c0780810>] (__napi_poll) from [<c0780c64>] (net_rx_action+0xcc/0x204)\n    [<c0780c64>] (net_rx_action) from [<c0101478>] (__do_softirq+0x140/0x4d0)\n    [<c0101478>] (__do_softirq) from [<c0135948>] (run_ksoftirqd+0x34/0x50)\n    [<c0135948>] (run_ksoftirqd) from [<c01583b8>] (smpboot_thread_fn+0xf4/0x1d8)\n    [<c01583b8>] (smpboot_thread_fn) from [<c01546dc>] (kthread+0x14c/0x174)\n    [<c01546dc>] (kthread) from [<c010013c>] (ret_from_fork+0x14/0x38)\n    ...\n\nThe omap-des and omap-sham drivers appear to have a similar issue.\n\nFix this by using spin_{,un}lock_bh() around device list access in all\nthe probe and remove functions.\n\nSigned-off-by: Ben Hutchings <ben.hutchings@mind.be>\nSigned-off-by: Herbert Xu <herbert@gondor.apana.org.au>",
        "before_after_code_files": [
          "drivers/crypto/omap-aes.c||drivers/crypto/omap-aes.c",
          "drivers/crypto/omap-des.c||drivers/crypto/omap-des.c",
          "drivers/crypto/omap-sham.c||drivers/crypto/omap-sham.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "drivers/crypto/omap-aes.c||drivers/crypto/omap-aes.c": [
          "File: drivers/crypto/omap-aes.c -> drivers/crypto/omap-aes.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1175:  spin_lock_init(&dd->lock);",
          "1177:  INIT_LIST_HEAD(&dd->list);",
          "1179:  list_add_tail(&dd->list, &dev_list);",
          "1183:  dd->engine = crypto_engine_alloc_init(dev, 1);",
          "",
          "[Removed Lines]",
          "1178:  spin_lock(&list_lock);",
          "1180:  spin_unlock(&list_lock);",
          "",
          "[Added Lines]",
          "1178:  spin_lock_bh(&list_lock);",
          "1180:  spin_unlock_bh(&list_lock);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1264:  if (!dd)",
          "1265:   return -ENODEV;",
          "1268:  list_del(&dd->list);",
          "1271:  for (i = dd->pdata->algs_info_size - 1; i >= 0; i--)",
          "1272:   for (j = dd->pdata->algs_info[i].registered - 1; j >= 0; j--) {",
          "",
          "[Removed Lines]",
          "1267:  spin_lock(&list_lock);",
          "1269:  spin_unlock(&list_lock);",
          "",
          "[Added Lines]",
          "1267:  spin_lock_bh(&list_lock);",
          "1269:  spin_unlock_bh(&list_lock);",
          "",
          "---------------"
        ],
        "drivers/crypto/omap-des.c||drivers/crypto/omap-des.c": [
          "File: drivers/crypto/omap-des.c -> drivers/crypto/omap-des.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1035:  INIT_LIST_HEAD(&dd->list);",
          "1037:  list_add_tail(&dd->list, &dev_list);",
          "1041:  dd->engine = crypto_engine_alloc_init(dev, 1);",
          "",
          "[Removed Lines]",
          "1036:  spin_lock(&list_lock);",
          "1038:  spin_unlock(&list_lock);",
          "",
          "[Added Lines]",
          "1036:  spin_lock_bh(&list_lock);",
          "1038:  spin_unlock_bh(&list_lock);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1094:  if (!dd)",
          "1095:   return -ENODEV;",
          "1098:  list_del(&dd->list);",
          "1101:  for (i = dd->pdata->algs_info_size - 1; i >= 0; i--)",
          "1102:   for (j = dd->pdata->algs_info[i].registered - 1; j >= 0; j--)",
          "",
          "[Removed Lines]",
          "1097:  spin_lock(&list_lock);",
          "1099:  spin_unlock(&list_lock);",
          "",
          "[Added Lines]",
          "1097:  spin_lock_bh(&list_lock);",
          "1099:  spin_unlock_bh(&list_lock);",
          "",
          "---------------"
        ],
        "drivers/crypto/omap-sham.c||drivers/crypto/omap-sham.c": [
          "File: drivers/crypto/omap-sham.c -> drivers/crypto/omap-sham.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "2127:   (rev & dd->pdata->major_mask) >> dd->pdata->major_shift,",
          "2128:   (rev & dd->pdata->minor_mask) >> dd->pdata->minor_shift);",
          "2131:  list_add_tail(&dd->list, &sham.dev_list);",
          "2134:  dd->engine = crypto_engine_alloc_init(dev, 1);",
          "2135:  if (!dd->engine) {",
          "",
          "[Removed Lines]",
          "2130:  spin_lock(&sham.lock);",
          "2132:  spin_unlock(&sham.lock);",
          "",
          "[Added Lines]",
          "2130:  spin_lock_bh(&sham.lock);",
          "2132:  spin_unlock_bh(&sham.lock);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2177: err_engine_start:",
          "2178:  crypto_engine_exit(dd->engine);",
          "2179: err_engine:",
          "2181:  list_del(&dd->list);",
          "2183: err_pm:",
          "2184:  pm_runtime_dont_use_autosuspend(dev);",
          "2185:  pm_runtime_disable(dev);",
          "",
          "[Removed Lines]",
          "2180:  spin_lock(&sham.lock);",
          "2182:  spin_unlock(&sham.lock);",
          "",
          "[Added Lines]",
          "2180:  spin_lock_bh(&sham.lock);",
          "2182:  spin_unlock_bh(&sham.lock);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "2199:  dd = platform_get_drvdata(pdev);",
          "2200:  if (!dd)",
          "2201:   return -ENODEV;",
          "2203:  list_del(&dd->list);",
          "2205:  for (i = dd->pdata->algs_info_size - 1; i >= 0; i--)",
          "2206:   for (j = dd->pdata->algs_info[i].registered - 1; j >= 0; j--) {",
          "2207:    crypto_unregister_ahash(",
          "",
          "[Removed Lines]",
          "2202:  spin_lock(&sham.lock);",
          "2204:  spin_unlock(&sham.lock);",
          "",
          "[Added Lines]",
          "2202:  spin_lock_bh(&sham.lock);",
          "2204:  spin_unlock_bh(&sham.lock);",
          "",
          "---------------"
        ]
      }
    }
  ]
}
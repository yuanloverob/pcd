{
  "cve_id": "CVE-2015-3288",
  "cve_desc": "mm/memory.c in the Linux kernel before 4.1.4 mishandles anonymous pages, which allows local users to gain privileges or cause a denial of service (page tainting) via a crafted application that triggers writing to page zero.",
  "repo": "torvalds/linux",
  "patch_hash": "6b7339f4c31ad69c8e9c0b2859276e22cf72176d",
  "patch_info": {
    "commit_hash": "6b7339f4c31ad69c8e9c0b2859276e22cf72176d",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/6b7339f4c31ad69c8e9c0b2859276e22cf72176d",
    "files": [
      "mm/memory.c"
    ],
    "message": "mm: avoid setting up anonymous pages into file mapping\n\nReading page fault handler code I've noticed that under right\ncircumstances kernel would map anonymous pages into file mappings: if\nthe VMA doesn't have vm_ops->fault() and the VMA wasn't fully populated\non ->mmap(), kernel would handle page fault to not populated pte with\ndo_anonymous_page().\n\nLet's change page fault handler to use do_anonymous_page() only on\nanonymous VMA (->vm_ops == NULL) and make sure that the VMA is not\nshared.\n\nFor file mappings without vm_ops->fault() or shred VMA without vm_ops,\npage fault on pte_none() entry would lead to SIGBUS.\n\nSigned-off-by: Kirill A. Shutemov <kirill.shutemov@linux.intel.com>\nAcked-by: Oleg Nesterov <oleg@redhat.com>\nCc: Andrew Morton <akpm@linux-foundation.org>\nCc: Willy Tarreau <w@1wt.eu>\nCc: stable@vger.kernel.org\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
    "before_after_code_files": [
      "mm/memory.c||mm/memory.c"
    ]
  },
  "patch_diff": {
    "mm/memory.c||mm/memory.c": [
      "File: mm/memory.c -> mm/memory.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "2671:  pte_unmap(page_table);",
      "2674:  if (check_stack_guard_page(vma, address) < 0)",
      "2675:   return VM_FAULT_SIGSEGV;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "2674:  if (vma->vm_flags & VM_SHARED)",
      "2675:   return VM_FAULT_SIGBUS;",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "3099:    - vma->vm_start) >> PAGE_SHIFT) + vma->vm_pgoff;",
      "3101:  pte_unmap(page_table);",
      "3102:  if (!(flags & FAULT_FLAG_WRITE))",
      "3103:   return do_read_fault(mm, vma, address, pmd, pgoff, flags,",
      "3104:     orig_pte);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "3107:  if (!vma->vm_ops->fault)",
      "3108:   return VM_FAULT_SIGBUS;",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "3244:  barrier();",
      "3245:  if (!pte_present(entry)) {",
      "3246:   if (pte_none(entry)) {",
      "3254:   }",
      "3255:   return do_swap_page(mm, vma, address,",
      "3256:      pte, pmd, flags, entry);",
      "",
      "[Removed Lines]",
      "3247:    if (vma->vm_ops) {",
      "3248:     if (likely(vma->vm_ops->fault))",
      "3249:      return do_fault(mm, vma, address, pte,",
      "3250:        pmd, flags, entry);",
      "3251:    }",
      "3252:    return do_anonymous_page(mm, vma, address,",
      "3253:        pte, pmd, flags);",
      "",
      "[Added Lines]",
      "3254:    if (vma->vm_ops)",
      "3255:     return do_fault(mm, vma, address, pte, pmd,",
      "3256:       flags, entry);",
      "3258:    return do_anonymous_page(mm, vma, address, pte, pmd,",
      "3259:      flags);",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "e37c698270633327245beb0fbd8699db8a4b65b4",
      "candidate_info": {
        "commit_hash": "e37c698270633327245beb0fbd8699db8a4b65b4",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/e37c698270633327245beb0fbd8699db8a4b65b4",
        "files": [
          "mm/gup.c",
          "mm/memory.c",
          "mm/rmap.c"
        ],
        "message": "mm: replace ACCESS_ONCE with READ_ONCE or barriers\n\nACCESS_ONCE does not work reliably on non-scalar types. For\nexample gcc 4.6 and 4.7 might remove the volatile tag for such\naccesses during the SRA (scalar replacement of aggregates) step\n(https://gcc.gnu.org/bugzilla/show_bug.cgi?id=58145)\n\nLet's change the code to access the page table elements with\nREAD_ONCE that does implicit scalar accesses for the gup code.\n\nmm_find_pmd is tricky, because m68k and sparc(32bit) define pmd_t\nas array of longs. This code requires just that the pmd_present\nand pmd_trans_huge check are done on the same value, so a barrier\nis sufficent.\n\nA similar case is in handle_pte_fault. On ppc44x the word size is\n32 bit, but a pte is 64 bit. A barrier is ok as well.\n\nSigned-off-by: Christian Borntraeger <borntraeger@de.ibm.com>\nCc: linux-mm@kvack.org\nAcked-by: Paul E. McKenney <paulmck@linux.vnet.ibm.com>",
        "before_after_code_files": [
          "mm/gup.c||mm/gup.c",
          "mm/memory.c||mm/memory.c",
          "mm/rmap.c||mm/rmap.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "mm/memory.c||mm/memory.c"
          ],
          "candidate": [
            "mm/memory.c||mm/memory.c"
          ]
        }
      },
      "candidate_diff": {
        "mm/gup.c||mm/gup.c": [
          "File: mm/gup.c -> mm/gup.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "918:  pudp = pud_offset(pgdp, addr);",
          "919:  do {",
          "922:   next = pud_addr_end(addr, end);",
          "923:   if (pud_none(pud))",
          "",
          "[Removed Lines]",
          "920:   pud_t pud = ACCESS_ONCE(*pudp);",
          "",
          "[Added Lines]",
          "920:   pud_t pud = READ_ONCE(*pudp);",
          "",
          "---------------"
        ],
        "mm/memory.c||mm/memory.c": [
          "File: mm/memory.c -> mm/memory.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "3202:  pte_t entry;",
          "3203:  spinlock_t *ptl;",
          "3206:  if (!pte_present(entry)) {",
          "3207:   if (pte_none(entry)) {",
          "3208:    if (vma->vm_ops) {",
          "",
          "[Removed Lines]",
          "3205:  entry = ACCESS_ONCE(*pte);",
          "",
          "[Added Lines]",
          "3213:  entry = *pte;",
          "3214:  barrier();",
          "",
          "---------------"
        ],
        "mm/rmap.c||mm/rmap.c": [
          "File: mm/rmap.c -> mm/rmap.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "585:  if (!pmd_present(pmde) || pmd_trans_huge(pmde))",
          "586:   pmd = NULL;",
          "587: out:",
          "",
          "[Removed Lines]",
          "584:  pmde = ACCESS_ONCE(*pmd);",
          "",
          "[Added Lines]",
          "584:  pmde = *pmd;",
          "585:  barrier();",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "b5330628546616af14ff23075fbf8d4ad91f6e25",
      "candidate_info": {
        "commit_hash": "b5330628546616af14ff23075fbf8d4ad91f6e25",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/b5330628546616af14ff23075fbf8d4ad91f6e25",
        "files": [
          "include/linux/mm.h",
          "mm/memory.c"
        ],
        "message": "mm: introduce vma_is_anonymous(vma) helper\n\nspecial_mapping_fault() is absolutely broken.  It seems it was always\nwrong, but this didn't matter until vdso/vvar started to use more than\none page.\n\nAnd after this change vma_is_anonymous() becomes really trivial, it\nsimply checks vm_ops == NULL.  However, I do think the helper makes\nsense.  There are a lot of ->vm_ops != NULL checks, the helper makes the\ncaller's code more understandable (self-documented) and this is more\ngrep-friendly.\n\nThis patch (of 3):\n\nPreparation.  Add the new simple helper, vma_is_anonymous(vma), and change\nhandle_pte_fault() to use it.  It will have more users.\n\nThe name is not accurate, say a hpet_mmap()'ed vma is not anonymous.\nPerhaps it should be named vma_has_fault() instead.  But it matches the\nlogic in mmap.c/memory.c (see next changes).  \"True\" just means that a\npage fault will use do_anonymous_page().\n\nSigned-off-by: Oleg Nesterov <oleg@redhat.com>\nAcked-by: Kirill A. Shutemov <kirill.shutemov@linux.intel.com>\nCc: Andy Lutomirski <luto@kernel.org>\nCc: Hugh Dickins <hughd@google.com>\nCc: Pavel Emelyanov <xemul@parallels.com>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
        "before_after_code_files": [
          "include/linux/mm.h||include/linux/mm.h",
          "mm/memory.c||mm/memory.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "mm/memory.c||mm/memory.c"
          ],
          "candidate": [
            "mm/memory.c||mm/memory.c"
          ]
        }
      },
      "candidate_diff": {
        "include/linux/mm.h||include/linux/mm.h": [
          "File: include/linux/mm.h -> include/linux/mm.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "1260:  return vma && (vma->vm_end == addr) && (vma->vm_flags & VM_GROWSDOWN);",
          "1261: }",
          "1263: static inline int stack_guard_page_start(struct vm_area_struct *vma,",
          "1264:           unsigned long addr)",
          "1265: {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1263: static inline bool vma_is_anonymous(struct vm_area_struct *vma)",
          "1264: {",
          "1265:  return !vma->vm_ops;",
          "1266: }",
          "",
          "---------------"
        ],
        "mm/memory.c||mm/memory.c": [
          "File: mm/memory.c -> mm/memory.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "3267:  barrier();",
          "3268:  if (!pte_present(entry)) {",
          "3269:   if (pte_none(entry)) {",
          "3271:     return do_fault(mm, vma, address, pte, pmd,",
          "3272:       flags, entry);",
          "3276:   }",
          "3277:   return do_swap_page(mm, vma, address,",
          "3278:      pte, pmd, flags, entry);",
          "",
          "[Removed Lines]",
          "3270:    if (vma->vm_ops)",
          "3274:    return do_anonymous_page(mm, vma, address, pte, pmd,",
          "3275:      flags);",
          "",
          "[Added Lines]",
          "3270:    if (vma_is_anonymous(vma))",
          "3271:     return do_anonymous_page(mm, vma, address,",
          "3272:         pte, pmd, flags);",
          "3273:    else",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "c0d73261f5c1355a35b8b40e871d31578ce0c044",
      "candidate_info": {
        "commit_hash": "c0d73261f5c1355a35b8b40e871d31578ce0c044",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/c0d73261f5c1355a35b8b40e871d31578ce0c044",
        "files": [
          "mm/memory.c"
        ],
        "message": "mm/memory.c: use entry = ACCESS_ONCE(*pte) in handle_pte_fault()\n\nUse ACCESS_ONCE() in handle_pte_fault() when getting the entry or\norig_pte upon which all subsequent decisions and pte_same() tests will\nbe made.\n\nI have no evidence that its lack is responsible for the mm/filemap.c:202\nBUG_ON(page_mapped(page)) in __delete_from_page_cache() found by\ntrinity, and I am not optimistic that it will fix it.  But I have found\nno other explanation, and ACCESS_ONCE() here will surely not hurt.\n\nIf gcc does re-access the pte before passing it down, then that would be\ndisastrous for correct page fault handling, and certainly could explain\nthe page_mapped() BUGs seen (concurrent fault causing page to be mapped\nin a second time on top of itself: mapcount 2 for a single pte).\n\nSigned-off-by: Hugh Dickins <hughd@google.com>\nCc: Sasha Levin <sasha.levin@oracle.com>\nCc: Linus Torvalds <torvalds@linux-foundation.org>\nCc: \"Kirill A. Shutemov\" <kirill.shutemov@linux.intel.com>\nCc: Konstantin Khlebnikov <koct9i@gmail.com>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
        "before_after_code_files": [
          "mm/memory.c||mm/memory.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "mm/memory.c||mm/memory.c"
          ],
          "candidate": [
            "mm/memory.c||mm/memory.c"
          ]
        }
      },
      "candidate_diff": {
        "mm/memory.c||mm/memory.c": [
          "File: mm/memory.c -> mm/memory.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "3181:  pte_t entry;",
          "3182:  spinlock_t *ptl;",
          "3185:  if (!pte_present(entry)) {",
          "3186:   if (pte_none(entry)) {",
          "3187:    if (vma->vm_ops) {",
          "",
          "[Removed Lines]",
          "3184:  entry = *pte;",
          "",
          "[Added Lines]",
          "3184:  entry = ACCESS_ONCE(*pte);",
          "",
          "---------------"
        ]
      }
    }
  ]
}
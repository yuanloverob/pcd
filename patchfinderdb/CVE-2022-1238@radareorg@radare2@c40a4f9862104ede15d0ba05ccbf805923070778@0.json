{
  "cve_id": "CVE-2022-1238",
  "cve_desc": "Out-of-bounds Write in libr/bin/format/ne/ne.c in GitHub repository radareorg/radare2 prior to 5.6.8. This vulnerability is heap overflow and may be exploitable. For more general description of heap buffer overflow, see [CWE](https://cwe.mitre.org/data/definitions/122.html).",
  "repo": "radareorg/radare2",
  "patch_hash": "c40a4f9862104ede15d0ba05ccbf805923070778",
  "patch_info": {
    "commit_hash": "c40a4f9862104ede15d0ba05ccbf805923070778",
    "repo": "radareorg/radare2",
    "commit_url": "https://github.com/radareorg/radare2/commit/c40a4f9862104ede15d0ba05ccbf805923070778",
    "files": [
      "libr/bin/format/ne/ne.c"
    ],
    "message": "Fix another oobread segfault in the NE bin parser ##crash\n\n* Reported by @han0nly via huntr.dev\n* Reproducers: sample1 sample2 sample3\n* BountyID: 47422cdf-aad2-4405-a6a1-6f63a3a93200",
    "before_after_code_files": [
      "libr/bin/format/ne/ne.c||libr/bin/format/ne/ne.c"
    ]
  },
  "patch_diff": {
    "libr/bin/format/ne/ne.c||libr/bin/format/ne/ne.c": [
      "File: libr/bin/format/ne/ne.c -> libr/bin/format/ne/ne.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "374:  }",
      "375:  int off = 0;",
      "376:  while (off < bin->ne_header->EntryTableLength) {",
      "377:   ut8 bundle_length = *(ut8 *)(bin->entry_table + off);",
      "378:   if (!bundle_length) {",
      "379:    break;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "377:   if (bin->entry_table + off + 32 >= r_buf_size (bin->buf)) {",
      "378:    break;",
      "379:   }",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "398:     ut8 segnum = *(bin->entry_table + off);",
      "399:     off++;",
      "400:     ut16 segoff = *(ut16 *)(bin->entry_table + off);",
      "402:    } else { // Fixed",
      "403:     entry->paddr = (ut64)bin->segment_entries[bundle_type - 1].offset * bin->alignment + *(ut16 *)(bin->entry_table + off);",
      "404:    }",
      "",
      "[Removed Lines]",
      "401:     entry->paddr = (ut64)bin->segment_entries[segnum - 1].offset * bin->alignment + segoff;",
      "",
      "[Added Lines]",
      "404:     if (segnum > 0) {",
      "405:      entry->paddr = (ut64)bin->segment_entries[segnum - 1].offset * bin->alignment + segoff;",
      "406:     }",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "2d782cdaa2112c10b8dd5e7a93c134b2ada9c1a6",
      "candidate_info": {
        "commit_hash": "2d782cdaa2112c10b8dd5e7a93c134b2ada9c1a6",
        "repo": "radareorg/radare2",
        "commit_url": "https://github.com/radareorg/radare2/commit/2d782cdaa2112c10b8dd5e7a93c134b2ada9c1a6",
        "files": [
          "libr/bin/format/ne/ne.c"
        ],
        "message": "Fix oobread segfaults in the NE bin parser ##crash\n\n* Reported by @han0nly via huntr.dev\n* Reproducers: seed1 seed2\n* BountyID: ad3c9c4c-76e7-40c8-bd4a-c095acd8bb40",
        "before_after_code_files": [
          "libr/bin/format/ne/ne.c||libr/bin/format/ne/ne.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/radareorg/radare2/pull/19918"
        ],
        "olp_code_files": {
          "patch": [
            "libr/bin/format/ne/ne.c||libr/bin/format/ne/ne.c"
          ],
          "candidate": [
            "libr/bin/format/ne/ne.c||libr/bin/format/ne/ne.c"
          ]
        }
      },
      "candidate_diff": {
        "libr/bin/format/ne/ne.c||libr/bin/format/ne/ne.c": [
          "File: libr/bin/format/ne/ne.c -> libr/bin/format/ne/ne.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "83:  RList *segments = r_list_newf (free);",
          "84:  for (i = 0; i < bin->ne_header->SegCount; i++) {",
          "85:   RBinSection *bs = R_NEW0 (RBinSection);",
          "87:   if (!bs) {",
          "88:    return segments;",
          "89:   }",
          "90:   bs->size = se->length;",
          "91:   bs->vsize = se->minAllocSz ? se->minAllocSz : 64000;",
          "92:   bs->bits = R_SYS_BITS_16;",
          "",
          "[Removed Lines]",
          "86:   NE_image_segment_entry *se = &bin->segment_entries[i];",
          "",
          "[Added Lines]",
          "89:   NE_image_segment_entry *se = &bin->segment_entries[i];",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "425:   return NULL;",
          "426:  }",
          "429:  if (!modref) {",
          "430:   return NULL;",
          "431:  }",
          "",
          "[Removed Lines]",
          "428:  ut16 *modref = malloc (bin->ne_header->ModRefs * sizeof (ut16));",
          "",
          "[Added Lines]",
          "428:  ut16 *modref = calloc (bin->ne_header->ModRefs, sizeof (ut16));",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "451:    continue;",
          "452:   }",
          "453:   off += 2;",
          "455:    RBinReloc *reloc = R_NEW0 (RBinReloc);",
          "456:    if (!reloc) {",
          "457:     return NULL;",
          "",
          "[Removed Lines]",
          "454:   while (off < start + length * sizeof (NE_image_reloc_item)) {",
          "",
          "[Added Lines]",
          "454:   size_t buf_size = r_buf_size (bin->buf);",
          "455:   while (off < start + length * sizeof (NE_image_reloc_item) && off < buf_size) {",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "484:      break;",
          "485:     }",
          "486:     char *name;",
          "488:      name = r_str_newf (\"UnknownModule%d_%x\", rel.index, off); // ????",
          "489:     } else {",
          "491:      name = __read_nonnull_str_at (bin->buf, offset);",
          "492:     }",
          "493:     if (rel.flags & IMPORTED_ORD) {",
          "",
          "[Removed Lines]",
          "487:     if (rel.index > bin->ne_header->ModRefs) {",
          "490:      offset = modref[rel.index - 1] + bin->header_offset + bin->ne_header->ImportNameTable;",
          "",
          "[Added Lines]",
          "488:     if (rel.index < 1 || rel.index > bin->ne_header->ModRefs) {",
          "491:      int index = rel.index;",
          "492:      offset = modref[index - 1] + bin->header_offset + bin->ne_header->ImportNameTable;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "563:   return;",
          "564:  }",
          "565:  bin->buf = buf;",
          "566:  r_buf_read_at (buf, bin->header_offset, (ut8 *)bin->ne_header, sizeof (NE_image_header));",
          "567:  bin->alignment = 1 << bin->ne_header->FileAlnSzShftCnt;",
          "568:  if (!bin->alignment) {",
          "569:   bin->alignment = 1 << 9;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "570:  if (bin->ne_header->FileAlnSzShftCnt > 8) {",
          "571:   bin->ne_header->FileAlnSzShftCnt = 8;",
          "572:  }",
          "573:  if (bin->ne_header->ModRefs * sizeof (ut16) >= r_buf_size (bin->buf)) {",
          "574:   bin->ne_header->ModRefs = r_buf_size (bin->buf) / sizeof (ut16);",
          "575:  }",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "571:  bin->os = __get_target_os (bin);",
          "573:  ut16 offset = bin->ne_header->SegTableOffset + bin->header_offset;",
          "575:  bin->segment_entries = calloc (1, size);",
          "576:  if (!bin->segment_entries) {",
          "577:   return;",
          "578:  }",
          "",
          "[Removed Lines]",
          "574:  ut16 size = bin->ne_header->SegCount * sizeof (NE_image_segment_entry);",
          "",
          "[Added Lines]",
          "583:  size_t size = bin->ne_header->SegCount * sizeof (NE_image_segment_entry);",
          "584:  if (offset >= r_buf_size (bin->buf)) {",
          "585:   return;",
          "586:  }",
          "587:  size_t remaining = r_buf_size (bin->buf) - offset;",
          "588:  size = R_MIN (remaining, size);",
          "590:  if (size >= remaining) {",
          "591:   bin->ne_header->SegCount = size / sizeof (NE_image_segment_entry);",
          "592:  }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "c35d1629422a12fafb0b3d379c8739c7894521e9",
      "candidate_info": {
        "commit_hash": "c35d1629422a12fafb0b3d379c8739c7894521e9",
        "repo": "radareorg/radare2",
        "commit_url": "https://github.com/radareorg/radare2/commit/c35d1629422a12fafb0b3d379c8739c7894521e9",
        "files": [
          "libr/bin/format/ne/ne.c"
        ],
        "message": "Fix another oobread in the NE parser ##crash",
        "before_after_code_files": [
          "libr/bin/format/ne/ne.c||libr/bin/format/ne/ne.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "libr/bin/format/ne/ne.c||libr/bin/format/ne/ne.c"
          ],
          "candidate": [
            "libr/bin/format/ne/ne.c||libr/bin/format/ne/ne.c"
          ]
        }
      },
      "candidate_diff": {
        "libr/bin/format/ne/ne.c||libr/bin/format/ne/ne.c": [
          "File: libr/bin/format/ne/ne.c -> libr/bin/format/ne/ne.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "3: #include \"ne.h\"",
          "5: static char *__get_target_os(r_bin_ne_obj_t *bin) {",
          "6:  switch (bin->ne_header->targOS) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4: #define NE_BUG 0",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "355:  if (!entries) {",
          "356:   return NULL;",
          "357:  }",
          "359:  RList *segments = r_bin_ne_get_segments (bin);",
          "360:  if (!segments) {",
          "361:   r_list_free (entries);",
          "362:   return NULL;",
          "363:  }",
          "364:  if (bin->ne_header->csEntryPoint) {",
          "366:   if (!entry) {",
          "367:    r_list_free (entries);",
          "368:    return NULL;",
          "369:   }",
          "370:   entry->bits = 16;",
          "372:   entry->paddr = bin->ne_header->ipEntryPoint + (s? s->paddr: 0);",
          "373:   r_list_append (entries, entry);",
          "374:  }",
          "375:  int off = 0;",
          "376:  while (off < bin->ne_header->EntryTableLength) {",
          "378:    break;",
          "379:   }",
          "380:   ut8 bundle_length = *(ut8 *)(bin->entry_table + off);",
          "",
          "[Removed Lines]",
          "358:  RBinAddr *entry;",
          "365:   entry = R_NEW0 (RBinAddr);",
          "371:   RBinSection *s = r_list_get_n (segments, bin->ne_header->csEntryPoint - 1);",
          "377:   if (bin->entry_table + off + 32 >= r_buf_size (bin->buf)) {",
          "",
          "[Added Lines]",
          "365:   RBinAddr *entry = R_NEW0 (RBinAddr);",
          "371:   ut32 entry_cs = bin->ne_header->csEntryPoint;",
          "372:   RBinSection *s = r_list_get_n (segments, entry_cs - 1);",
          "378:  size_t tableat = bin->header_offset + bin->ne_header->EntryTableOffset;",
          "380:   if (tableat + off >= r_buf_size (bin->buf)) {",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "386:   off++;",
          "387:   int i;",
          "388:   for (i = 0; i < bundle_length; i++) {",
          "390:    if (!entry) {",
          "391:     r_list_free (entries);",
          "392:     return NULL;",
          "",
          "[Removed Lines]",
          "389:    entry = R_NEW0 (RBinAddr);",
          "",
          "[Added Lines]",
          "392:    if (tableat + off + 4 >= r_buf_size (bin->buf)) {",
          "393:     break;",
          "394:    }",
          "395:    RBinAddr *entry = R_NEW0 (RBinAddr);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "396:     off--;",
          "397:     free (entry);",
          "398:     break;",
          "400:     off += 2;",
          "401:     ut8 segnum = *(bin->entry_table + off);",
          "402:     off++;",
          "",
          "[Removed Lines]",
          "399:    } else if (bundle_type == 0xFF) { // Moveable",
          "",
          "[Added Lines]",
          "405:    } else if (bundle_type == 0xff) { // moveable",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "405:      entry->paddr = (ut64)bin->segment_entries[segnum - 1].offset * bin->alignment + segoff;",
          "406:     }",
          "407:    } else { // Fixed",
          "409:    }",
          "410:    off += 2;",
          "411:    r_list_append (entries, entry);",
          "",
          "[Removed Lines]",
          "408:     entry->paddr = (ut64)bin->segment_entries[bundle_type - 1].offset * bin->alignment + *(ut16 *)(bin->entry_table + off);",
          "",
          "[Added Lines]",
          "414:     if (bundle_type < bin->ne_header->SegCount) {",
          "415:      entry->paddr = (ut64)bin->segment_entries[bundle_type - 1].offset",
          "417:     }",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "450:   if (!(bin->segment_entries[index].flags & RELOCINFO)) {",
          "451:    continue;",
          "452:   }",
          "454:   ut16 length = r_buf_read_le16_at (bin->buf, off);",
          "455:   if (!length) {",
          "456:    continue;",
          "457:   }",
          "458:   off += 2;",
          "461:    RBinReloc *reloc = R_NEW0 (RBinReloc);",
          "462:    if (!reloc) {",
          "463:     return NULL;",
          "464:    }",
          "467:    reloc->paddr = seg->paddr + rel.offset;",
          "468:    switch (rel.type) {",
          "469:    case LOBYTE:",
          "",
          "[Removed Lines]",
          "453:   ut32 off, start = off = seg->paddr + seg->size;",
          "459:   size_t buf_size = r_buf_size (bin->buf);",
          "460:   while (off < start + length * sizeof (NE_image_reloc_item) && off < buf_size) {",
          "465:    NE_image_reloc_item rel;",
          "466:    r_buf_read_at (bin->buf, off, (ut8 *)&rel, sizeof (rel));",
          "",
          "[Added Lines]",
          "462:   ut32 off = seg->paddr + seg->size;",
          "463:   ut32 start = off;",
          "470:   while (off < start + length * sizeof (NE_image_reloc_item)) {",
          "472:    NE_image_reloc_item rel = {0};",
          "473:    if (r_buf_read_at (bin->buf, off, (ut8 *)&rel, sizeof (rel)) < 1) {",
          "474:     return NULL;",
          "475:    }",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "490:      break;",
          "491:     }",
          "492:     char *name;",
          "494:      name = r_str_newf (\"UnknownModule%d_%x\", rel.index, off); // ????",
          "495:     } else {",
          "498:      name = __read_nonnull_str_at (bin->buf, offset);",
          "499:     }",
          "500:     if (rel.flags & IMPORTED_ORD) {",
          "501:      imp->ordinal = rel.func_ord;",
          "502:      imp->name = r_str_newf (\"%s.%s\", name, __func_name_from_ord(name, rel.func_ord));",
          "",
          "[Removed Lines]",
          "493:     if (rel.index < 1 || rel.index > bin->ne_header->ModRefs) {",
          "496:      int index = rel.index;",
          "497:      offset = modref[index - 1] + bin->header_offset + bin->ne_header->ImportNameTable;",
          "",
          "[Added Lines]",
          "506: #if NE_BUG",
          "507:     if (rel.index > 0 && rel.index < bin->ne_header->ModRefs) {",
          "508:      offset = modref[rel.index - 1] + bin->header_offset + bin->ne_header->ImportNameTable;",
          "509:      name = __read_nonnull_str_at (bin->buf, offset);",
          "510:     } else {",
          "511:      name = r_str_newf (\"UnknownModule%d_%x\", rel.index, off); // ????",
          "512:     }",
          "513: #else",
          "514:     if (rel.index > bin->ne_header->ModRefs) {",
          "517:      offset = modref[rel.index - 1] + bin->header_offset + bin->ne_header->ImportNameTable;",
          "520: #endif",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "542:     r_list_append (relocs, reloc);",
          "543:    } else {",
          "544:     do {",
          "545:      r_list_append (relocs, reloc);",
          "547:      offset = r_buf_read_le16_at (bin->buf, reloc->paddr);",
          "548:      RBinReloc *tmp = reloc;",
          "549:      reloc = R_NEW0 (RBinReloc);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "566: #if NE_BUG",
          "567:      if (reloc->paddr + 4 < r_buf_size (bin->buf)) {",
          "568:       break;",
          "569:      }",
          "570: #endif",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "571:  }",
          "572:  bin->buf = buf;",
          "577:  }",
          "580:  }",
          "581:  bin->alignment = 1 << bin->ne_header->FileAlnSzShftCnt;",
          "582:  if (!bin->alignment) {",
          "",
          "[Removed Lines]",
          "574:  r_buf_read_at (buf, bin->header_offset, (ut8 *)bin->ne_header, sizeof (NE_image_header));",
          "575:  if (bin->ne_header->FileAlnSzShftCnt > 8) {",
          "576:   bin->ne_header->FileAlnSzShftCnt = 8;",
          "578:  if (bin->ne_header->ModRefs * sizeof (ut16) >= r_buf_size (bin->buf)) {",
          "579:   bin->ne_header->ModRefs = r_buf_size (bin->buf) / sizeof (ut16);",
          "",
          "[Added Lines]",
          "599:  if (r_buf_read_at (buf, bin->header_offset, (ut8 *)bin->ne_header, sizeof (NE_image_header)) < 1) {",
          "600:   R_FREE (bin->ne_header);",
          "601:   return;",
          "602:  }",
          "603:  if (bin->ne_header->FileAlnSzShftCnt > 15) {",
          "604:   bin->ne_header->FileAlnSzShftCnt = 15;",
          "606:  ut64 from = bin->ne_header->ModRefTable + bin->header_offset;",
          "607:  ut64 left = r_buf_size (bin->buf) - from;",
          "608:  if (from + bin->ne_header->ModRefs * sizeof (ut16) >= left) {",
          "609:   bin->ne_header->ModRefs = left / sizeof (ut16);",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "591:  }",
          "592:  size_t remaining = r_buf_size (bin->buf) - offset;",
          "593:  size = R_MIN (remaining, size);",
          "594:  bin->segment_entries = calloc (1, size);",
          "595:  if (size >= remaining) {",
          "596:   bin->ne_header->SegCount = size / sizeof (NE_image_segment_entry);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "624:  bin->ne_header->SegCount = size / sizeof (NE_image_segment_entry); // * sizeof (NE_image_segment_entry);",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "599:   return;",
          "600:  }",
          "601:  r_buf_read_at (buf, offset, (ut8 *)bin->segment_entries, size);",
          "603:  r_buf_read_at (buf, (ut64)bin->header_offset + bin->ne_header->EntryTableOffset, bin->entry_table, bin->ne_header->EntryTableLength);",
          "604:  bin->imports = r_bin_ne_get_imports (bin);",
          "605:  __ne_get_resources (bin);",
          "",
          "[Removed Lines]",
          "602:  bin->entry_table = calloc (1, bin->ne_header->EntryTableLength);",
          "",
          "[Added Lines]",
          "633:  bin->entry_table = calloc (4, bin->ne_header->EntryTableLength);",
          "634:  if (!bin->entry_table) {",
          "635:   R_FREE (bin->segment_entries);",
          "636:   return;",
          "637:  }",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "612:  free (bin->ne_header);",
          "613:  free (bin->resident_name_table);",
          "614:  free (bin->segment_entries);",
          "615: }",
          "617: r_bin_ne_obj_t *r_bin_ne_new_buf(RBuffer *buf, bool verbose) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "650:  free (bin);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "0a557045476a2969c7079aec9eeb29d02f2809c6",
      "candidate_info": {
        "commit_hash": "0a557045476a2969c7079aec9eeb29d02f2809c6",
        "repo": "radareorg/radare2",
        "commit_url": "https://github.com/radareorg/radare2/commit/0a557045476a2969c7079aec9eeb29d02f2809c6",
        "files": [
          "libr/bin/format/ne/ne.c"
        ],
        "message": "Fix oobread and unaligned casts in the NE entrypoint logic ##crash\n\n* Reported by @hmsec via huntr.dev\n* Reproducer: nepocaligns\n* BountyID: ec538fa4-06c6-4050-a141-f60153ddeaac",
        "before_after_code_files": [
          "libr/bin/format/ne/ne.c||libr/bin/format/ne/ne.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "libr/bin/format/ne/ne.c||libr/bin/format/ne/ne.c"
          ],
          "candidate": [
            "libr/bin/format/ne/ne.c||libr/bin/format/ne/ne.c"
          ]
        }
      },
      "candidate_diff": {
        "libr/bin/format/ne/ne.c||libr/bin/format/ne/ne.c": [
          "File: libr/bin/format/ne/ne.c -> libr/bin/format/ne/ne.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "408:     off += 2;",
          "409:     ut8 segnum = *(bin->entry_table + off);",
          "410:     off++;",
          "413:      entry->paddr = (ut64)bin->segment_entries[segnum - 1].offset * bin->alignment + segoff;",
          "414:     }",
          "415:    } else { // Fixed",
          "416:     if (bundle_type < bin->ne_header->SegCount) {",
          "417:      entry->paddr = (ut64)bin->segment_entries[bundle_type - 1].offset",
          "419:     }",
          "420:    }",
          "421:    off += 2;",
          "",
          "[Removed Lines]",
          "411:     ut16 segoff = *(ut16 *)(bin->entry_table + off);",
          "412:     if (segnum > 0) {",
          "",
          "[Added Lines]",
          "411:     if (off > bin->ne_header->EntryTableLength) {",
          "412:      break;",
          "413:     }",
          "414:     ut16 segoff = r_read_le16 (bin->entry_table + off);",
          "415:     if (segnum > 0 && segnum < bin->ne_header->SegCount) {",
          "419:     if (off + 2 >= bin->ne_header->EntryTableLength) {",
          "420:      break;",
          "421:     }",
          "422:     ut16 delta = r_read_le16 (bin->entry_table + off);",
          "",
          "---------------"
        ]
      }
    }
  ]
}
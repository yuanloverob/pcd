{
  "cve_id": "CVE-2014-8509",
  "cve_desc": "The lazy_bdecode function in BitTorrent bootstrap-dht (aka Bootstrap) allows remote attackers to execute arbitrary code via a crafted packet, which triggers an out-of-bounds read, related to \"Improper Indexing.\"",
  "repo": "bittorrent/bootstrap-dht",
  "patch_hash": "bbc0b7191e3f48461ca6e5b1b34bdf4b3f1e79a9",
  "patch_info": {
    "commit_hash": "bbc0b7191e3f48461ca6e5b1b34bdf4b3f1e79a9",
    "repo": "bittorrent/bootstrap-dht",
    "commit_url": "https://github.com/bittorrent/bootstrap-dht/commit/bbc0b7191e3f48461ca6e5b1b34bdf4b3f1e79a9",
    "files": [
      "lazy_bdecode.cpp",
      "lazy_entry.hpp"
    ],
    "message": "update version of lazy_bdecode from libtorrent",
    "before_after_code_files": [
      "lazy_bdecode.cpp||lazy_bdecode.cpp",
      "lazy_entry.hpp||lazy_entry.hpp"
    ]
  },
  "patch_diff": {
    "lazy_bdecode.cpp||lazy_bdecode.cpp": [
      "File: lazy_bdecode.cpp -> lazy_bdecode.cpp",
      "--- Hunk 1 ---",
      "[Context before]",
      "4: All rights reserved.",
      "6: Redistribution and use in source and binary forms, with or without",
      "",
      "[Removed Lines]",
      "3: Copyright (c) 2008-2012, Arvid Norberg",
      "",
      "[Added Lines]",
      "3: Copyright (c) 2008-2014, Arvid Norberg",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "45: namespace libtorrent",
      "46: {",
      "58:  }",
      "69:  {",
      "70:   while (start < end && *start != delimiter)",
      "71:   {",
      "73:    val *= 10;",
      "75:    ++start;",
      "76:   }",
      "77:   return start;",
      "78:  }",
      "",
      "[Removed Lines]",
      "48: #define TORRENT_FAIL_BDECODE(code) \\",
      "49:  { \\",
      "50:   ec = make_error_code(code); \\",
      "51:   while (!stack.empty()) { \\",
      "52:    top = stack.back(); \\",
      "53:    if (top->type() == lazy_entry::dict_t || top->type() == lazy_entry::list_t) top->pop(); \\",
      "54:    stack.pop_back(); \\",
      "55:   } \\",
      "56:   if (error_pos) *error_pos = start - orig_start; \\",
      "57:   return -1; \\",
      "60:  bool is_digit(char c) { return c >= '0' && c <= '9'; }",
      "62:  bool is_print(char c) { return c >= 32 && c < 127; }",
      "68:  char const* parse_int(char const* start, char const* end, char delimiter, boost::int64_t& val)",
      "72:    if (!is_digit(*start)) { return 0; }",
      "74:    val += *start - '0';",
      "",
      "[Added Lines]",
      "48:  namespace",
      "49:  {",
      "50:   int fail(int* error_pos",
      "51:    , std::vector<lazy_entry*>& stack",
      "52:    , char const* start",
      "53:    , char const* orig_start)",
      "54:   {",
      "55:    while (!stack.empty()) {",
      "56:     lazy_entry* top = stack.back();",
      "57:     if (top->type() == lazy_entry::dict_t || top->type() == lazy_entry::list_t)",
      "58:     {",
      "59:      top->pop();",
      "60:      break;",
      "61:     }",
      "62:     stack.pop_back();",
      "63:    }",
      "64:    if (error_pos) *error_pos = start - orig_start;",
      "65:    return -1;",
      "66:   }",
      "69: #define TORRENT_FAIL_BDECODE(code) do { ec = make_error_code(code); return fail(error_pos, stack, start, orig_start); } while (false)",
      "71:  namespace { bool numeric(char c) { return c >= '0' && c <= '9'; } }",
      "77:  char const* parse_int(char const* start, char const* end, char delimiter",
      "78:   , boost::int64_t& val, bdecode_errors::error_code_enum& ec)",
      "82:    if (!numeric(*start))",
      "83:    {",
      "84:     ec = bdecode_errors::expected_string;",
      "85:     return start;",
      "86:    }",
      "87:    if (val > INT64_MAX / 10)",
      "88:    {",
      "89:     ec = bdecode_errors::overflow;",
      "90:     return start;",
      "91:    }",
      "93:    int digit = *start - '0';",
      "94:    if (val > INT64_MAX - digit)",
      "95:    {",
      "96:     ec = bdecode_errors::overflow;",
      "97:     return start;",
      "98:    }",
      "99:    val += digit;",
      "102:   if (*start != delimiter)",
      "103:    ec = bdecode_errors::expected_colon;",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "94:   std::vector<lazy_entry*> stack;",
      "96:   stack.push_back(&ret);",
      "98:   {",
      "99:    if (stack.empty()) break; // done!",
      "",
      "[Removed Lines]",
      "97:   while (start < end)",
      "",
      "[Added Lines]",
      "124:   while (start <= end)",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "116:       stack.pop_back();",
      "117:       continue;",
      "118:      }",
      "120:      boost::int64_t len = t - '0';",
      "124:      ++start;",
      "125:      if (start == end) TORRENT_FAIL_BDECODE(bdecode_errors::unexpected_eof);",
      "126:      lazy_entry* ent = top->dict_append(start);",
      "",
      "[Removed Lines]",
      "119:      if (!is_digit(t)) TORRENT_FAIL_BDECODE(bdecode_errors::expected_string);",
      "121:      start = parse_int(start, end, ':', len);",
      "122:      if (start == 0 || start + len + 3 > end || *start != ':')",
      "123:       TORRENT_FAIL_BDECODE(bdecode_errors::expected_colon);",
      "",
      "[Added Lines]",
      "146:      if (!numeric(t)) TORRENT_FAIL_BDECODE(bdecode_errors::expected_string);",
      "148:      bdecode_errors::error_code_enum e = bdecode_errors::no_error;",
      "149:      start = parse_int(start, end, ':', len, e);",
      "150:      if (e)",
      "151:       TORRENT_FAIL_BDECODE(e);",
      "153:      if (start + len + 1 > end)",
      "154:       TORRENT_FAIL_BDECODE(bdecode_errors::unexpected_eof);",
      "156:      if (len < 0)",
      "157:       TORRENT_FAIL_BDECODE(bdecode_errors::overflow);",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "173:     }",
      "174:     default:",
      "175:     {",
      "177:       TORRENT_FAIL_BDECODE(bdecode_errors::expected_value);",
      "179:      boost::int64_t len = t - '0';",
      "183:      ++start;",
      "184:      top->construct_string(start, int(len));",
      "185:      stack.pop_back();",
      "",
      "[Removed Lines]",
      "176:      if (!is_digit(t))",
      "180:      start = parse_int(start, end, ':', len);",
      "181:      if (start == 0 || start + len + 1 > end || *start != ':')",
      "182:       TORRENT_FAIL_BDECODE(bdecode_errors::expected_colon);",
      "",
      "[Added Lines]",
      "211:      if (!numeric(t))",
      "215:      bdecode_errors::error_code_enum e = bdecode_errors::no_error;",
      "216:      start = parse_int(start, end, ':', len, e);",
      "217:      if (e)",
      "218:       TORRENT_FAIL_BDECODE(e);",
      "219:      if (start + len + 1 > end)",
      "220:       TORRENT_FAIL_BDECODE(bdecode_errors::unexpected_eof);",
      "221:      if (len < 0)",
      "222:       TORRENT_FAIL_BDECODE(bdecode_errors::overflow);",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "198:   boost::int64_t val = 0;",
      "199:   bool negative = false;",
      "200:   if (*m_data.start == '-') negative = true;",
      "202:   if (negative) val = -val;",
      "203:   return val;",
      "204:  }",
      "",
      "[Removed Lines]",
      "201:   parse_int(negative?m_data.start+1:m_data.start, m_data.start + m_size, 'e', val);",
      "",
      "[Added Lines]",
      "242:   bdecode_errors::error_code_enum ec = bdecode_errors::no_error;",
      "243:   parse_int(m_data.start + negative",
      "244:    , m_data.start + m_size, 'e', val, ec);",
      "245:   if (ec) return 0;",
      "",
      "---------------",
      "--- Hunk 7 ---",
      "[Context before]",
      "331:   return e;",
      "332:  }",
      "334:  lazy_entry const* lazy_entry::dict_find_list(char const* name) const",
      "335:  {",
      "336:   lazy_entry const* e = dict_find(name);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "378:  lazy_entry const* lazy_entry::dict_find_dict(std::string const& name) const",
      "379:  {",
      "380:   lazy_entry const* e = dict_find(name);",
      "381:   if (e == 0 || e->type() != lazy_entry::dict_t) return 0;",
      "382:   return e;",
      "383:  }",
      "",
      "---------------",
      "--- Hunk 8 ---",
      "[Context before]",
      "350:   return 0;",
      "351:  }",
      "353:  lazy_entry* lazy_entry::list_append()",
      "354:  {",
      "355:   TORRENT_ASSERT(m_type == list_t);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "404:  lazy_entry* lazy_entry::dict_find(std::string const& name)",
      "405:  {",
      "406:   TORRENT_ASSERT(m_type == dict_t);",
      "407:   for (int i = 0; i < int(m_size); ++i)",
      "408:   {",
      "409:    lazy_dict_entry& e = m_data.dict[i];",
      "410:    if (name.size() != e.val.m_begin - e.name) continue;",
      "411:    if (std::equal(name.begin(), name.end(), e.name))",
      "412:     return &e.val;",
      "413:   }",
      "414:   return 0;",
      "415:  }",
      "",
      "---------------",
      "--- Hunk 9 ---",
      "[Context before]",
      "492:     char const* str = e.string_ptr();",
      "493:     for (int i = 0; i < e.string_length(); ++i)",
      "494:     {",
      "497:      printable = false;",
      "498:      break;",
      "499:     }",
      "500:     ret += \"'\";",
      "501:     if (printable)",
      "502:     {",
      "504:      ret += \"'\";",
      "505:      return ret;",
      "506:     }",
      "508:     {",
      "512:     }",
      "513:     ret += \"'\";",
      "514:     return ret;",
      "",
      "[Removed Lines]",
      "495:      using namespace std;",
      "496:      if (is_print((unsigned char)str[i])) continue;",
      "503:      ret += e.string_value();",
      "507:     for (int i = 0; i < e.string_length(); ++i)",
      "509:      char tmp[5];",
      "510:      snprintf(tmp, sizeof(tmp), \"%02x\", (unsigned char)str[i]);",
      "511:      ret += tmp;",
      "",
      "[Added Lines]",
      "559:      char c = str[i];",
      "560:      if (c >= 32 && c < 127) continue;",
      "567:      if (single_line && e.string_length() > 30)",
      "568:      {",
      "569:       ret.append(e.string_ptr(), 14);",
      "570:       ret += \"...\";",
      "571:       ret.append(e.string_ptr() + e.string_length()-14, 14);",
      "572:      }",
      "573:      else",
      "574:       ret.append(e.string_ptr(), e.string_length());",
      "578:     if (single_line && e.string_length() > 20)",
      "580:      for (int i = 0; i < 9; ++i)",
      "581:      {",
      "582:       char tmp[5];",
      "583:       snprintf(tmp, sizeof(tmp), \"%02x\", (unsigned char)str[i]);",
      "584:       ret += tmp;",
      "585:      }",
      "586:      ret += \"...\";",
      "587:      for (int i = e.string_length() - 9",
      "588:       , len(e.string_length()); i < len; ++i)",
      "589:      {",
      "590:       char tmp[5];",
      "591:       snprintf(tmp, sizeof(tmp), \"%02x\", (unsigned char)str[i]);",
      "592:       ret += tmp;",
      "593:      }",
      "594:     }",
      "595:     else",
      "596:     {",
      "597:      for (int i = 0; i < e.string_length(); ++i)",
      "598:      {",
      "599:       char tmp[5];",
      "600:       snprintf(tmp, sizeof(tmp), \"%02x\", (unsigned char)str[i]);",
      "601:       ret += tmp;",
      "602:      }",
      "",
      "---------------",
      "--- Hunk 10 ---",
      "[Context before]",
      "577:    \"expected value (list, dict, int or string) in bencoded string\",",
      "578:    \"bencoded nesting depth exceeded\",",
      "579:    \"bencoded item count limit exceeded\",",
      "580:   };",
      "581:   if (ev < 0 || ev >= int(sizeof(msgs)/sizeof(msgs[0])))",
      "582:    return \"Unknown error\";",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "671:    \"integer overflow\",",
      "",
      "---------------",
      "--- Hunk 11 ---",
      "[Context before]",
      "589:   return bdecode_category;",
      "590:  }",
      "592: };",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "684:  namespace bdecode_errors",
      "685:  {",
      "686:   boost::system::error_code make_error_code(error_code_enum e)",
      "687:   {",
      "688:    return boost::system::error_code(e, get_bdecode_category());",
      "689:   }",
      "690:  }",
      "",
      "---------------"
    ],
    "lazy_entry.hpp||lazy_entry.hpp": [
      "File: lazy_entry.hpp -> lazy_entry.hpp",
      "--- Hunk 1 ---",
      "[Context before]",
      "4: All rights reserved.",
      "6: Redistribution and use in source and binary forms, with or without",
      "",
      "[Removed Lines]",
      "3: Copyright (c) 2003-2012, Arvid Norberg",
      "",
      "[Added Lines]",
      "3: Copyright (c) 2003-2014, Arvid Norberg",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "37: #include <vector>",
      "38: #include <string>",
      "39: #include <cstring>",
      "40: #include <boost/system/error_code.hpp>",
      "42: #define TORRENT_EXPORT",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "40: #include <algorithm>",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "221:   lazy_entry* dict_find(char const* name);",
      "222:   lazy_entry const* dict_find(char const* name) const",
      "223:   { return const_cast<lazy_entry*>(this)->dict_find(name); }",
      "224:   lazy_entry const* dict_find_string(char const* name) const;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "226:   lazy_entry* dict_find(std::string const& name);",
      "227:   lazy_entry const* dict_find(std::string const& name) const",
      "228:   { return const_cast<lazy_entry*>(this)->dict_find(name); }",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "235:   boost::int64_t dict_find_int_value(char const* name, boost::int64_t default_val = 0) const;",
      "236:   lazy_entry const* dict_find_int(char const* name) const;",
      "238:   lazy_entry const* dict_find_dict(char const* name) const;",
      "239:   lazy_entry const* dict_find_list(char const* name) const;",
      "243:   std::pair<std::string, lazy_entry const*> dict_at(int i) const;",
      "246:   int dict_size() const",
      "247:   {",
      "248:    TORRENT_ASSERT(m_type == dict_t);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "250:   lazy_entry const* dict_find_dict(std::string const& name) const;",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "361:   lazy_entry val;",
      "362:  };",
      "365:   , bool single_line = false, int indent = 0);",
      "367:  TORRENT_EXPORT boost::system::error_category& get_bdecode_category();",
      "369:  namespace bdecode_errors",
      "",
      "[Removed Lines]",
      "364:  TORRENT_EXTRA_EXPORT std::string print_entry(lazy_entry const& e",
      "",
      "[Added Lines]",
      "391:  TORRENT_EXPORT std::string print_entry(lazy_entry const& e",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "386:    depth_exceeded,",
      "388:    limit_exceeded,",
      "391:    error_code_max",
      "392:   };",
      "399:  }",
      "400: }",
      "402: #endif",
      "",
      "[Removed Lines]",
      "395:   inline boost::system::error_code make_error_code(error_code_enum e)",
      "396:   {",
      "397:    return boost::system::error_code(e, get_bdecode_category());",
      "398:   }",
      "",
      "[Added Lines]",
      "418:    overflow,",
      "425:   TORRENT_EXPORT boost::system::error_code make_error_code(error_code_enum e);",
      "428:  TORRENT_EXTRA_EXPORT char const* parse_int(char const* start",
      "429:   , char const* end, char delimiter, boost::int64_t& val",
      "430:   , bdecode_errors::error_code_enum& ec);",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "d5366177d2afc5a542840c7bda52120b19a14048",
      "candidate_info": {
        "commit_hash": "d5366177d2afc5a542840c7bda52120b19a14048",
        "repo": "bittorrent/bootstrap-dht",
        "commit_url": "https://github.com/bittorrent/bootstrap-dht/commit/d5366177d2afc5a542840c7bda52120b19a14048",
        "files": [
          "Jamfile",
          "LICENSE",
          "README.md",
          "README.rst",
          "bencode.hpp",
          "bencode.py",
          "lazy_bdecode.cpp",
          "lazy_entry.hpp",
          "main.cpp",
          "project-root.jam",
          "test_dht.py"
        ],
        "message": "initial check-in",
        "before_after_code_files": [
          "bencode.hpp||bencode.hpp",
          "bencode.py||bencode.py",
          "lazy_bdecode.cpp||lazy_bdecode.cpp",
          "lazy_entry.hpp||lazy_entry.hpp",
          "main.cpp||main.cpp",
          "test_dht.py||test_dht.py"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "lazy_bdecode.cpp||lazy_bdecode.cpp",
            "lazy_entry.hpp||lazy_entry.hpp"
          ],
          "candidate": [
            "lazy_bdecode.cpp||lazy_bdecode.cpp",
            "lazy_entry.hpp||lazy_entry.hpp"
          ]
        }
      },
      "candidate_diff": {
        "bencode.hpp||bencode.hpp": [
          "File: bencode.hpp -> bencode.hpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2: The MIT License (MIT)",
          "4: Copyright (c) 2013 BitTorrent Inc.",
          "6: Permission is hereby granted, free of charge, to any person obtaining a copy of",
          "7: this software and associated documentation files (the \"Software\"), to deal in",
          "8: the Software without restriction, including without limitation the rights to",
          "9: use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of",
          "10: the Software, and to permit persons to whom the Software is furnished to do so,",
          "11: subject to the following conditions:",
          "13: The above copyright notice and this permission notice shall be included in all",
          "14: copies or substantial portions of the Software.",
          "16: THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR",
          "17: IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS",
          "18: FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR",
          "19: COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER",
          "20: IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN",
          "21: CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.",
          "24: #ifndef _BENCODE_HPP_",
          "25: #define _BENCODE_HPP_",
          "27: #include <cstring>",
          "28: #include <string>",
          "29: #include <algorithm>",
          "31: struct bencoder",
          "32: {",
          "33:  bencoder(char* buf, int len) : m_buf(buf), m_end(buf + len) {}",
          "35:  void open_dict() { if (m_buf < m_end) *m_buf++ = 'd'; }",
          "36:  void close_dict() { if (m_buf < m_end) *m_buf++ = 'e'; }",
          "37:  void add_string(char const* str, int len = -1)",
          "38:  {",
          "39:   if (len == -1) len = std::strlen(str);",
          "40:   m_buf += std::snprintf(m_buf, m_end - m_buf, \"%d:\", len);",
          "41:   len = (std::min)(len, int(m_end - m_buf));",
          "42:   memcpy(m_buf, str, len);",
          "43:   m_buf += len;",
          "44:  }",
          "45:  void add_string(std::string const& str)",
          "46:  {",
          "47:   add_string(str.c_str(), str.length());",
          "48:  }",
          "49:  char* end() const { return m_buf; }",
          "51: private:",
          "53:  char* m_buf;",
          "54:  char* m_end;",
          "55: };",
          "57: #endif",
          "",
          "---------------"
        ],
        "bencode.py||bencode.py": [
          "File: bencode.py -> bencode.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: # The contents of this file are subject to the BitTorrent Open Source License",
          "2: # Version 1.1 (the License).  You may not copy or use this file, in either",
          "3: # source code or executable form, except in compliance with the License.  You",
          "4: # may obtain a copy of the License at http://www.bittorrent.com/license/.",
          "5: #",
          "6: # Software distributed under the License is distributed on an AS IS basis,",
          "7: # WITHOUT WARRANTY OF ANY KIND, either express or implied.  See the License",
          "8: # for the specific language governing rights and limitations under the",
          "9: # License.",
          "11: # Written by Petru Paler",
          "13: class BTFailure(Exception):",
          "14:     pass",
          "16: def decode_int(x, f):",
          "17:     f += 1",
          "18:     newf = x.index('e', f)",
          "19:     n = int(x[f:newf])",
          "20:     if x[f] == '-':",
          "21:         if x[f + 1] == '0':",
          "22:             raise ValueError",
          "23:     elif x[f] == '0' and newf != f+1:",
          "24:         raise ValueError",
          "25:     return (n, newf+1)",
          "27: def decode_string(x, f):",
          "28:     colon = x.index(':', f)",
          "29:     n = int(x[f:colon])",
          "30:     if x[f] == '0' and colon != f+1:",
          "31:         raise ValueError",
          "32:     colon += 1",
          "33:     return (x[colon:colon+n], colon+n)",
          "35: def decode_list(x, f):",
          "36:     r, f = [], f+1",
          "37:     while x[f] != 'e':",
          "38:         v, f = decode_func[x[f]](x, f)",
          "39:         r.append(v)",
          "40:     return (r, f + 1)",
          "42: def decode_dict(x, f):",
          "43:     r, f = {}, f+1",
          "44:     while x[f] != 'e':",
          "45:         k, f = decode_string(x, f)",
          "46:         r[k], f = decode_func[x[f]](x, f)",
          "47:     return (r, f + 1)",
          "49: decode_func = {}",
          "50: decode_func['l'] = decode_list",
          "51: decode_func['d'] = decode_dict",
          "52: decode_func['i'] = decode_int",
          "53: decode_func['0'] = decode_string",
          "54: decode_func['1'] = decode_string",
          "55: decode_func['2'] = decode_string",
          "56: decode_func['3'] = decode_string",
          "57: decode_func['4'] = decode_string",
          "58: decode_func['5'] = decode_string",
          "59: decode_func['6'] = decode_string",
          "60: decode_func['7'] = decode_string",
          "61: decode_func['8'] = decode_string",
          "62: decode_func['9'] = decode_string",
          "64: def bdecode(x):",
          "65:     try:",
          "66:         r, l = decode_func[x[0]](x, 0)",
          "67:     except (IndexError, KeyError, ValueError):",
          "68:         raise BTFailure(\"not a valid bencoded string\")",
          "69:     if l != len(x):",
          "70:         raise BTFailure(\"invalid bencoded value (data after valid prefix)\")",
          "71:     return r",
          "73: from types import StringType, IntType, LongType, DictType, ListType, TupleType",
          "76: class Bencached(object):",
          "78:     __slots__ = ['bencoded']",
          "80:     def __init__(self, s):",
          "81:         self.bencoded = s",
          "83: def encode_bencached(x,r):",
          "84:     r.append(x.bencoded)",
          "86: def encode_int(x, r):",
          "87:     r.extend(('i', str(x), 'e'))",
          "89: def encode_bool(x, r):",
          "90:     if x:",
          "91:         encode_int(1, r)",
          "92:     else:",
          "93:         encode_int(0, r)",
          "95: def encode_string(x, r):",
          "96:     r.extend((str(len(x)), ':', x))",
          "98: def encode_list(x, r):",
          "99:     r.append('l')",
          "100:     for i in x:",
          "101:         encode_func[type(i)](i, r)",
          "102:     r.append('e')",
          "104: def encode_dict(x,r):",
          "105:     r.append('d')",
          "106:     ilist = x.items()",
          "107:     ilist.sort()",
          "108:     for k, v in ilist:",
          "109:         r.extend((str(len(k)), ':', k))",
          "110:         encode_func[type(v)](v, r)",
          "111:     r.append('e')",
          "113: encode_func = {}",
          "114: encode_func[Bencached] = encode_bencached",
          "115: encode_func[IntType] = encode_int",
          "116: encode_func[LongType] = encode_int",
          "117: encode_func[StringType] = encode_string",
          "118: encode_func[ListType] = encode_list",
          "119: encode_func[TupleType] = encode_list",
          "120: encode_func[DictType] = encode_dict",
          "122: try:",
          "123:     from types import BooleanType",
          "124:     encode_func[BooleanType] = encode_bool",
          "125: except ImportError:",
          "126:     pass",
          "128: def bencode(x):",
          "129:     r = []",
          "130:     encode_func[type(x)](x, r)",
          "131:     return ''.join(r)",
          "",
          "---------------"
        ],
        "lazy_bdecode.cpp||lazy_bdecode.cpp": [
          "File: lazy_bdecode.cpp -> lazy_bdecode.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3: Copyright (c) 2008-2012, Arvid Norberg",
          "4: All rights reserved.",
          "6: Redistribution and use in source and binary forms, with or without",
          "7: modification, are permitted provided that the following conditions",
          "8: are met:",
          "11:       notice, this list of conditions and the following disclaimer.",
          "13:       notice, this list of conditions and the following disclaimer in",
          "14:       the documentation and/or other materials provided with the distribution.",
          "16:       contributors may be used to endorse or promote products derived",
          "17:       from this software without specific prior written permission.",
          "19: THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"",
          "20: AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE",
          "21: IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE",
          "22: ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE",
          "23: LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR",
          "24: CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF",
          "25: SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS",
          "26: INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN",
          "27: CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)",
          "28: ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE",
          "29: POSSIBILITY OF SUCH DAMAGE.",
          "33: #include \"lazy_entry.hpp\"",
          "34: #include <cstring>",
          "35: #include <inttypes.h>",
          "37: namespace",
          "38: {",
          "39:  const int lazy_entry_grow_factor = 150; // percent",
          "40:  const int lazy_entry_dict_init = 5;",
          "41:  const int lazy_entry_list_init = 5;",
          "42: }",
          "44: namespace libtorrent",
          "45: {",
          "47: #define TORRENT_FAIL_BDECODE(code) \\",
          "48:  { \\",
          "49:   ec = make_error_code(code); \\",
          "50:   while (!stack.empty()) { \\",
          "51:    top = stack.back(); \\",
          "52:    if (top->type() == lazy_entry::dict_t || top->type() == lazy_entry::list_t) top->pop(); \\",
          "53:    stack.pop_back(); \\",
          "54:   } \\",
          "55:   if (error_pos) *error_pos = start - orig_start; \\",
          "56:   return -1; \\",
          "57:  }",
          "59:  bool is_digit(char c) { return c >= '0' && c <= '9'; }",
          "61:  bool is_print(char c) { return c >= 32 && c < 127; }",
          "67:  char const* parse_int(char const* start, char const* end, char delimiter, boost::int64_t& val)",
          "68:  {",
          "69:   while (start < end && *start != delimiter)",
          "70:   {",
          "71:    if (!is_digit(*start)) { return 0; }",
          "72:    val *= 10;",
          "73:    val += *start - '0';",
          "74:    ++start;",
          "75:   }",
          "76:   return start;",
          "77:  }",
          "79:  char const* find_char(char const* start, char const* end, char delimiter)",
          "80:  {",
          "81:   while (start < end && *start != delimiter) ++start;",
          "82:   return start;",
          "83:  }",
          "86:  int lazy_bdecode(char const* start, char const* end, lazy_entry& ret",
          "87:   , error_code& ec, int* error_pos, int depth_limit, int item_limit)",
          "88:  {",
          "89:   char const* const orig_start = start;",
          "90:   ret.clear();",
          "91:   if (start == end) return 0;",
          "93:   std::vector<lazy_entry*> stack;",
          "95:   stack.push_back(&ret);",
          "96:   while (start < end)",
          "97:   {",
          "98:    if (stack.empty()) break; // done!",
          "100:    lazy_entry* top = stack.back();",
          "102:    if (int(stack.size()) > depth_limit) TORRENT_FAIL_BDECODE(bdecode_errors::depth_exceeded);",
          "103:    if (start >= end) TORRENT_FAIL_BDECODE(bdecode_errors::unexpected_eof);",
          "104:    char t = *start;",
          "105:    ++start;",
          "106:    if (start >= end && t != 'e') TORRENT_FAIL_BDECODE(bdecode_errors::unexpected_eof);",
          "108:    switch (top->type())",
          "109:    {",
          "110:     case lazy_entry::dict_t:",
          "111:     {",
          "112:      if (t == 'e')",
          "113:      {",
          "114:       top->set_end(start);",
          "115:       stack.pop_back();",
          "116:       continue;",
          "117:      }",
          "118:      if (!is_digit(t)) TORRENT_FAIL_BDECODE(bdecode_errors::expected_string);",
          "119:      boost::int64_t len = t - '0';",
          "120:      start = parse_int(start, end, ':', len);",
          "121:      if (start == 0 || start + len + 3 > end || *start != ':')",
          "122:       TORRENT_FAIL_BDECODE(bdecode_errors::expected_colon);",
          "123:      ++start;",
          "124:      if (start == end) TORRENT_FAIL_BDECODE(bdecode_errors::unexpected_eof);",
          "125:      lazy_entry* ent = top->dict_append(start);",
          "126:      if (ent == 0) TORRENT_FAIL_BDECODE(boost::system::errc::not_enough_memory);",
          "127:      start += len;",
          "128:      if (start >= end) TORRENT_FAIL_BDECODE(bdecode_errors::unexpected_eof);",
          "129:      stack.push_back(ent);",
          "130:      t = *start;",
          "131:      ++start;",
          "132:      break;",
          "133:     }",
          "134:     case lazy_entry::list_t:",
          "135:     {",
          "136:      if (t == 'e')",
          "137:      {",
          "138:       top->set_end(start);",
          "139:       stack.pop_back();",
          "140:       continue;",
          "141:      }",
          "142:      lazy_entry* ent = top->list_append();",
          "143:      if (ent == 0) TORRENT_FAIL_BDECODE(boost::system::errc::not_enough_memory);",
          "144:      stack.push_back(ent);",
          "145:      break;",
          "146:     }",
          "147:     default: break;",
          "148:    }",
          "150:    --item_limit;",
          "151:    if (item_limit <= 0) TORRENT_FAIL_BDECODE(bdecode_errors::limit_exceeded);",
          "153:    top = stack.back();",
          "154:    switch (t)",
          "155:    {",
          "156:     case 'd':",
          "157:      top->construct_dict(start - 1);",
          "158:      continue;",
          "159:     case 'l':",
          "160:      top->construct_list(start - 1);",
          "161:      continue;",
          "162:     case 'i':",
          "163:     {",
          "164:      char const* int_start = start;",
          "165:      start = find_char(start, end, 'e');",
          "166:      top->construct_int(int_start, start - int_start);",
          "167:      if (start == end) TORRENT_FAIL_BDECODE(bdecode_errors::unexpected_eof);",
          "168:      TORRENT_ASSERT(*start == 'e');",
          "169:      ++start;",
          "170:      stack.pop_back();",
          "171:      continue;",
          "172:     }",
          "173:     default:",
          "174:     {",
          "175:      if (!is_digit(t))",
          "176:       TORRENT_FAIL_BDECODE(bdecode_errors::expected_value);",
          "178:      boost::int64_t len = t - '0';",
          "179:      start = parse_int(start, end, ':', len);",
          "180:      if (start == 0 || start + len + 1 > end || *start != ':')",
          "181:       TORRENT_FAIL_BDECODE(bdecode_errors::expected_colon);",
          "182:      ++start;",
          "183:      top->construct_string(start, int(len));",
          "184:      stack.pop_back();",
          "185:      start += len;",
          "186:      continue;",
          "187:     }",
          "188:    }",
          "189:    return 0;",
          "190:   }",
          "191:   return 0;",
          "192:  }",
          "194:  boost::int64_t lazy_entry::int_value() const",
          "195:  {",
          "196:   TORRENT_ASSERT(m_type == int_t);",
          "197:   boost::int64_t val = 0;",
          "198:   bool negative = false;",
          "199:   if (*m_data.start == '-') negative = true;",
          "200:   parse_int(negative?m_data.start+1:m_data.start, m_data.start + m_size, 'e', val);",
          "201:   if (negative) val = -val;",
          "202:   return val;",
          "203:  }",
          "205:  lazy_entry* lazy_entry::dict_append(char const* name)",
          "206:  {",
          "207:   TORRENT_ASSERT(m_type == dict_t);",
          "208:   TORRENT_ASSERT(m_size <= m_capacity);",
          "209:   if (m_capacity == 0)",
          "210:   {",
          "211:    int capacity = lazy_entry_dict_init;",
          "212:    m_data.dict = new (std::nothrow) lazy_dict_entry[capacity];",
          "213:    if (m_data.dict == 0) return 0;",
          "214:    m_capacity = capacity;",
          "215:   }",
          "216:   else if (m_size == m_capacity)",
          "217:   {",
          "218:    int capacity = m_capacity * lazy_entry_grow_factor / 100;",
          "219:    lazy_dict_entry* tmp = new (std::nothrow) lazy_dict_entry[capacity];",
          "220:    if (tmp == 0) return 0;",
          "221:    std::memcpy(tmp, m_data.dict, sizeof(lazy_dict_entry) * m_size);",
          "222:    for (int i = 0; i < int(m_size); ++i) m_data.dict[i].val.release();",
          "223:    delete[] m_data.dict;",
          "224:    m_data.dict = tmp;",
          "225:    m_capacity = capacity;",
          "226:   }",
          "228:   TORRENT_ASSERT(m_size < m_capacity);",
          "229:   lazy_dict_entry& ret = m_data.dict[m_size++];",
          "230:   ret.name = name;",
          "231:   return &ret.val;",
          "232:  }",
          "234:  void lazy_entry::pop()",
          "235:  {",
          "236:   if (m_size > 0) --m_size;",
          "237:  }",
          "239:  namespace",
          "240:  {",
          "243:   int num_digits(int val)",
          "244:   {",
          "245:    int ret = 1;",
          "246:    while (val >= 10)",
          "247:    {",
          "248:     ++ret;",
          "249:     val /= 10;",
          "250:    }",
          "251:    return ret;",
          "252:   }",
          "253:  }",
          "255:  void lazy_entry::construct_string(char const* start, int length)",
          "256:  {",
          "257:   TORRENT_ASSERT(m_type == none_t);",
          "258:   m_type = string_t;",
          "259:   m_data.start = start;",
          "260:   m_size = length;",
          "261:   m_begin = start - 1 - num_digits(length);",
          "262:   m_len = start - m_begin + length;",
          "263:  }",
          "265:  namespace",
          "266:  {",
          "269:   bool string_equal(char const* str1, char const* str2, int len2)",
          "270:   {",
          "271:    while (len2 > 0)",
          "272:    {",
          "273:     if (*str1 != *str2) return false;",
          "274:     if (*str1 == 0) return false;",
          "275:     ++str1;",
          "276:     ++str2;",
          "277:     --len2;",
          "278:    }",
          "279:    return *str1 == 0;",
          "280:   }",
          "281:  }",
          "283:  std::pair<std::string, lazy_entry const*> lazy_entry::dict_at(int i) const",
          "284:  {",
          "285:   TORRENT_ASSERT(m_type == dict_t);",
          "286:   TORRENT_ASSERT(i < int(m_size));",
          "287:   lazy_dict_entry const& e = m_data.dict[i];",
          "288:   return std::make_pair(std::string(e.name, e.val.m_begin - e.name), &e.val);",
          "289:  }",
          "291:  std::string lazy_entry::dict_find_string_value(char const* name) const",
          "292:  {",
          "293:   lazy_entry const* e = dict_find(name);",
          "294:   if (e == 0 || e->type() != lazy_entry::string_t) return std::string();",
          "295:   return e->string_value();",
          "296:  }",
          "298:  pascal_string lazy_entry::dict_find_pstr(char const* name) const",
          "299:  {",
          "300:   lazy_entry const* e = dict_find(name);",
          "301:   if (e == 0 || e->type() != lazy_entry::string_t) return pascal_string(0, 0);",
          "302:   return e->string_pstr();",
          "303:  }",
          "305:  lazy_entry const* lazy_entry::dict_find_string(char const* name) const",
          "306:  {",
          "307:   lazy_entry const* e = dict_find(name);",
          "308:   if (e == 0 || e->type() != lazy_entry::string_t) return 0;",
          "309:   return e;",
          "310:  }",
          "312:  lazy_entry const* lazy_entry::dict_find_int(char const* name) const",
          "313:  {",
          "314:   lazy_entry const* e = dict_find(name);",
          "315:   if (e == 0 || e->type() != lazy_entry::int_t) return 0;",
          "316:   return e;",
          "317:  }",
          "319:  boost::int64_t lazy_entry::dict_find_int_value(char const* name, boost::int64_t default_val) const",
          "320:  {",
          "321:   lazy_entry const* e = dict_find(name);",
          "322:   if (e == 0 || e->type() != lazy_entry::int_t) return default_val;",
          "323:   return e->int_value();",
          "324:  }",
          "326:  lazy_entry const* lazy_entry::dict_find_dict(char const* name) const",
          "327:  {",
          "328:   lazy_entry const* e = dict_find(name);",
          "329:   if (e == 0 || e->type() != lazy_entry::dict_t) return 0;",
          "330:   return e;",
          "331:  }",
          "333:  lazy_entry const* lazy_entry::dict_find_list(char const* name) const",
          "334:  {",
          "335:   lazy_entry const* e = dict_find(name);",
          "336:   if (e == 0 || e->type() != lazy_entry::list_t) return 0;",
          "337:   return e;",
          "338:  }",
          "340:  lazy_entry* lazy_entry::dict_find(char const* name)",
          "341:  {",
          "342:   TORRENT_ASSERT(m_type == dict_t);",
          "343:   for (int i = 0; i < int(m_size); ++i)",
          "344:   {",
          "345:    lazy_dict_entry& e = m_data.dict[i];",
          "346:    if (string_equal(name, e.name, e.val.m_begin - e.name))",
          "347:     return &e.val;",
          "348:   }",
          "349:   return 0;",
          "350:  }",
          "352:  lazy_entry* lazy_entry::list_append()",
          "353:  {",
          "354:   TORRENT_ASSERT(m_type == list_t);",
          "355:   TORRENT_ASSERT(m_size <= m_capacity);",
          "356:   if (m_capacity == 0)",
          "357:   {",
          "358:    int capacity = lazy_entry_list_init;",
          "359:    m_data.list = new (std::nothrow) lazy_entry[capacity];",
          "360:    if (m_data.list == 0) return 0;",
          "361:    m_capacity = capacity;",
          "362:   }",
          "363:   else if (m_size == m_capacity)",
          "364:   {",
          "365:    int capacity = m_capacity * lazy_entry_grow_factor / 100;",
          "366:    lazy_entry* tmp = new (std::nothrow) lazy_entry[capacity];",
          "367:    if (tmp == 0) return 0;",
          "368:    std::memcpy(tmp, m_data.list, sizeof(lazy_entry) * m_size);",
          "369:    for (int i = 0; i < int(m_size); ++i) m_data.list[i].release();",
          "370:    delete[] m_data.list;",
          "371:    m_data.list = tmp;",
          "372:    m_capacity = capacity;",
          "373:   }",
          "375:   TORRENT_ASSERT(m_size < m_capacity);",
          "376:   return m_data.list + (m_size++);",
          "377:  }",
          "379:  std::string lazy_entry::list_string_value_at(int i) const",
          "380:  {",
          "381:   lazy_entry const* e = list_at(i);",
          "382:   if (e == 0 || e->type() != lazy_entry::string_t) return std::string();",
          "383:   return e->string_value();",
          "384:  }",
          "386:  pascal_string lazy_entry::list_pstr_at(int i) const",
          "387:  {",
          "388:   lazy_entry const* e = list_at(i);",
          "389:   if (e == 0 || e->type() != lazy_entry::string_t) return pascal_string(0, 0);",
          "390:   return e->string_pstr();",
          "391:  }",
          "393:  boost::int64_t lazy_entry::list_int_value_at(int i, boost::int64_t default_val) const",
          "394:  {",
          "395:   lazy_entry const* e = list_at(i);",
          "396:   if (e == 0 || e->type() != lazy_entry::int_t) return default_val;",
          "397:   return e->int_value();",
          "398:  }",
          "400:  void lazy_entry::clear()",
          "401:  {",
          "402:   switch (m_type)",
          "403:   {",
          "404:    case list_t: delete[] m_data.list; break;",
          "405:    case dict_t: delete[] m_data.dict; break;",
          "406:    default: break;",
          "407:   }",
          "408:   m_data.start = 0;",
          "409:   m_size = 0;",
          "410:   m_capacity = 0;",
          "411:   m_type = none_t;",
          "412:  }",
          "414:  std::pair<char const*, int> lazy_entry::data_section() const",
          "415:  {",
          "416:   typedef std::pair<char const*, int> return_t;",
          "417:   return return_t(m_begin, m_len);",
          "418:  }",
          "420:  int line_longer_than(lazy_entry const& e, int limit)",
          "421:  {",
          "422:   int line_len = 0;",
          "423:   switch (e.type())",
          "424:   {",
          "425:   case lazy_entry::list_t:",
          "426:    line_len += 4;",
          "427:    if (line_len > limit) return -1;",
          "428:    for (int i = 0; i < e.list_size(); ++i)",
          "429:    {",
          "430:     int ret = line_longer_than(*e.list_at(i), limit - line_len);",
          "431:     if (ret == -1) return -1;",
          "432:     line_len += ret + 2;",
          "433:    }",
          "434:    break;",
          "435:   case lazy_entry::dict_t:",
          "436:    line_len += 4;",
          "437:    if (line_len > limit) return -1;",
          "438:    for (int i = 0; i < e.dict_size(); ++i)",
          "439:    {",
          "440:     line_len += 4 + e.dict_at(i).first.size();",
          "441:     if (line_len > limit) return -1;",
          "442:     int ret = line_longer_than(*e.dict_at(i).second, limit - line_len);",
          "443:     if (ret == -1) return -1;",
          "444:     line_len += ret + 1;",
          "445:    }",
          "446:    break;",
          "447:   case lazy_entry::string_t:",
          "448:    line_len += 3 + e.string_length();",
          "449:    break;",
          "450:   case lazy_entry::int_t:",
          "451:   {",
          "452:    boost::int64_t val = e.int_value();",
          "453:    while (val > 0)",
          "454:    {",
          "455:     ++line_len;",
          "456:     val /= 10;",
          "457:    }",
          "458:    line_len += 2;",
          "459:   }",
          "460:   break;",
          "461:   case lazy_entry::none_t:",
          "462:    line_len += 4;",
          "463:    break;",
          "464:   }",
          "466:   if (line_len > limit) return -1;",
          "467:   return line_len;",
          "468:  }",
          "470:  std::string print_entry(lazy_entry const& e, bool single_line, int indent)",
          "471:  {",
          "472:   char indent_str[200];",
          "473:   memset(indent_str, ' ', 200);",
          "474:   indent_str[0] = ',';",
          "475:   indent_str[1] = '\\n';",
          "476:   indent_str[199] = 0;",
          "477:   if (indent < 197 && indent >= 0) indent_str[indent+2] = 0;",
          "478:   std::string ret;",
          "479:   switch (e.type())",
          "480:   {",
          "481:    case lazy_entry::none_t: return \"none\";",
          "482:    case lazy_entry::int_t:",
          "483:    {",
          "484:     char str[100];",
          "485:     snprintf(str, sizeof(str), \"%\" PRId64, e.int_value());",
          "486:     return str;",
          "487:    }",
          "488:    case lazy_entry::string_t:",
          "489:    {",
          "490:     bool printable = true;",
          "491:     char const* str = e.string_ptr();",
          "492:     for (int i = 0; i < e.string_length(); ++i)",
          "493:     {",
          "494:      using namespace std;",
          "495:      if (is_print((unsigned char)str[i])) continue;",
          "496:      printable = false;",
          "497:      break;",
          "498:     }",
          "499:     ret += \"'\";",
          "500:     if (printable)",
          "501:     {",
          "502:      ret += e.string_value();",
          "503:      ret += \"'\";",
          "504:      return ret;",
          "505:     }",
          "506:     for (int i = 0; i < e.string_length(); ++i)",
          "507:     {",
          "508:      char tmp[5];",
          "509:      snprintf(tmp, sizeof(tmp), \"%02x\", (unsigned char)str[i]);",
          "510:      ret += tmp;",
          "511:     }",
          "512:     ret += \"'\";",
          "513:     return ret;",
          "514:    }",
          "515:    case lazy_entry::list_t:",
          "516:    {",
          "517:     ret += '[';",
          "518:     bool one_liner = line_longer_than(e, 200) != -1 || single_line;",
          "520:     if (!one_liner) ret += indent_str + 1;",
          "521:     for (int i = 0; i < e.list_size(); ++i)",
          "522:     {",
          "523:      if (i == 0 && one_liner) ret += \" \";",
          "524:      ret += print_entry(*e.list_at(i), single_line, indent + 2);",
          "525:      if (i < e.list_size() - 1) ret += (one_liner?\", \":indent_str);",
          "526:      else ret += (one_liner?\" \":indent_str+1);",
          "527:     }",
          "528:     ret += \"]\";",
          "529:     return ret;",
          "530:    }",
          "531:    case lazy_entry::dict_t:",
          "532:    {",
          "533:     ret += \"{\";",
          "534:     bool one_liner = line_longer_than(e, 200) != -1 || single_line;",
          "536:     if (!one_liner) ret += indent_str+1;",
          "537:     for (int i = 0; i < e.dict_size(); ++i)",
          "538:     {",
          "539:      if (i == 0 && one_liner) ret += \" \";",
          "540:      std::pair<std::string, lazy_entry const*> ent = e.dict_at(i);",
          "541:      ret += \"'\";",
          "542:      ret += ent.first;",
          "543:      ret += \"': \";",
          "544:      ret += print_entry(*ent.second, single_line, indent + 2);",
          "545:      if (i < e.dict_size() - 1) ret += (one_liner?\", \":indent_str);",
          "546:      else ret += (one_liner?\" \":indent_str+1);",
          "547:     }",
          "548:     ret += \"}\";",
          "549:     return ret;",
          "550:    }",
          "551:   }",
          "552:   return ret;",
          "553:  }",
          "555:  struct bdecode_error_category : boost::system::error_category",
          "556:  {",
          "557:   virtual const char* name() const BOOST_SYSTEM_NOEXCEPT;",
          "558:   virtual std::string message(int ev) const BOOST_SYSTEM_NOEXCEPT;",
          "559:   virtual boost::system::error_condition default_error_condition(int ev) const BOOST_SYSTEM_NOEXCEPT",
          "560:   { return boost::system::error_condition(ev, *this); }",
          "561:  };",
          "563:  const char* bdecode_error_category::name() const BOOST_SYSTEM_NOEXCEPT",
          "564:  {",
          "565:   return \"bdecode error\";",
          "566:  }",
          "568:  std::string bdecode_error_category::message(int ev) const BOOST_SYSTEM_NOEXCEPT",
          "569:  {",
          "570:   static char const* msgs[] =",
          "571:   {",
          "572:    \"no error\",",
          "573:    \"expected string in bencoded string\",",
          "574:    \"expected colon in bencoded string\",",
          "575:    \"unexpected end of file in bencoded string\",",
          "576:    \"expected value (list, dict, int or string) in bencoded string\",",
          "577:    \"bencoded nesting depth exceeded\",",
          "578:    \"bencoded item count limit exceeded\",",
          "579:   };",
          "580:   if (ev < 0 || ev >= int(sizeof(msgs)/sizeof(msgs[0])))",
          "581:    return \"Unknown error\";",
          "582:   return msgs[ev];",
          "583:  }",
          "585:  boost::system::error_category& get_bdecode_category()",
          "586:  {",
          "587:   static bdecode_error_category bdecode_category;",
          "588:   return bdecode_category;",
          "589:  }",
          "591: };",
          "",
          "---------------"
        ],
        "lazy_entry.hpp||lazy_entry.hpp": [
          "File: lazy_entry.hpp -> lazy_entry.hpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3: Copyright (c) 2003-2012, Arvid Norberg",
          "4: All rights reserved.",
          "6: Redistribution and use in source and binary forms, with or without",
          "7: modification, are permitted provided that the following conditions",
          "8: are met:",
          "11:       notice, this list of conditions and the following disclaimer.",
          "13:       notice, this list of conditions and the following disclaimer in",
          "14:       the documentation and/or other materials provided with the distribution.",
          "16:       contributors may be used to endorse or promote products derived",
          "17:       from this software without specific prior written permission.",
          "19: THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"",
          "20: AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE",
          "21: IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE",
          "22: ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE",
          "23: LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR",
          "24: CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF",
          "25: SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS",
          "26: INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN",
          "27: CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)",
          "28: ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE",
          "29: POSSIBILITY OF SUCH DAMAGE.",
          "33: #ifndef TORRENT_LAZY_ENTRY_HPP_INCLUDED",
          "34: #define TORRENT_LAZY_ENTRY_HPP_INCLUDED",
          "36: #include <utility>",
          "37: #include <vector>",
          "38: #include <string>",
          "39: #include <cstring>",
          "40: #include <boost/system/error_code.hpp>",
          "42: #define TORRENT_EXPORT",
          "43: #define TORRENT_EXTRA_EXPORT",
          "44: #define TORRENT_ASSERT(x) assert(x)",
          "46: namespace libtorrent",
          "47: {",
          "48:  using boost::system::error_code;",
          "50:  struct lazy_entry;",
          "85:  TORRENT_EXPORT int lazy_bdecode(char const* start, char const* end",
          "86:   , lazy_entry& ret, error_code& ec, int* error_pos = 0",
          "87:   , int depth_limit = 1000, int item_limit = 1000000);",
          "96:  struct TORRENT_EXPORT pascal_string",
          "97:  {",
          "100:   pascal_string(char const* p, int l): len(l), ptr(p) {}",
          "103:   int len;",
          "108:   char const* ptr;",
          "112:   bool operator<(pascal_string const& rhs) const",
          "113:   {",
          "114:    return std::memcmp(ptr, rhs.ptr, (std::min)(len, rhs.len)) < 0",
          "115:     || len < rhs.len;",
          "116:   }",
          "117:  };",
          "119:  struct lazy_dict_entry;",
          "131:  struct TORRENT_EXPORT lazy_entry",
          "132:  {",
          "134:   enum entry_type_t",
          "135:   {",
          "136:    none_t, dict_t, list_t, string_t, int_t",
          "137:   };",
          "139:   lazy_entry() : m_begin(0), m_len(0), m_size(0), m_capacity(0), m_type(none_t)",
          "140:   { m_data.start = 0; }",
          "145:   entry_type_t type() const { return (entry_type_t)m_type; }",
          "149:   void construct_int(char const* start, int length)",
          "150:   {",
          "151:    TORRENT_ASSERT(m_type == none_t);",
          "152:    m_type = int_t;",
          "153:    m_data.start = start;",
          "154:    m_size = length;",
          "155:    m_begin = start - 1; // include 'i'",
          "156:    m_len = length + 2; // include 'e'",
          "157:   }",
          "160:   boost::int64_t int_value() const;",
          "163:   void construct_string(char const* start, int length);",
          "168:   char const* string_ptr() const",
          "169:   {",
          "170:    TORRENT_ASSERT(m_type == string_t);",
          "171:    return m_data.start;",
          "172:   }",
          "176:   char const* string_cstr() const",
          "177:   {",
          "178:    TORRENT_ASSERT(m_type == string_t);",
          "179:    const_cast<char*>(m_data.start)[m_size] = 0;",
          "180:    return m_data.start;",
          "181:   }",
          "185:   pascal_string string_pstr() const",
          "186:   {",
          "187:    TORRENT_ASSERT(m_type == string_t);",
          "188:    return pascal_string(m_data.start, m_size);",
          "189:   }",
          "193:   std::string string_value() const",
          "194:   {",
          "195:    TORRENT_ASSERT(m_type == string_t);",
          "196:    return std::string(m_data.start, m_size);",
          "197:   }",
          "201:   int string_length() const",
          "202:   { return m_size; }",
          "205:   void construct_dict(char const* begin)",
          "206:   {",
          "207:    TORRENT_ASSERT(m_type == none_t);",
          "208:    m_type = dict_t;",
          "209:    m_size = 0;",
          "210:    m_capacity = 0;",
          "211:    m_begin = begin;",
          "212:   }",
          "215:   lazy_entry* dict_append(char const* name);",
          "217:   void pop();",
          "221:   lazy_entry* dict_find(char const* name);",
          "222:   lazy_entry const* dict_find(char const* name) const",
          "223:   { return const_cast<lazy_entry*>(this)->dict_find(name); }",
          "224:   lazy_entry const* dict_find_string(char const* name) const;",
          "229:   std::string dict_find_string_value(char const* name) const;",
          "230:   pascal_string dict_find_pstr(char const* name) const;",
          "235:   boost::int64_t dict_find_int_value(char const* name, boost::int64_t default_val = 0) const;",
          "236:   lazy_entry const* dict_find_int(char const* name) const;",
          "238:   lazy_entry const* dict_find_dict(char const* name) const;",
          "239:   lazy_entry const* dict_find_list(char const* name) const;",
          "243:   std::pair<std::string, lazy_entry const*> dict_at(int i) const;",
          "246:   int dict_size() const",
          "247:   {",
          "248:    TORRENT_ASSERT(m_type == dict_t);",
          "249:    return m_size;",
          "250:   }",
          "253:   void construct_list(char const* begin)",
          "254:   {",
          "255:    TORRENT_ASSERT(m_type == none_t);",
          "256:    m_type = list_t;",
          "257:    m_size = 0;",
          "258:    m_capacity = 0;",
          "259:    m_begin = begin;",
          "260:   }",
          "263:   lazy_entry* list_append();",
          "266:   lazy_entry* list_at(int i)",
          "267:   {",
          "268:    TORRENT_ASSERT(m_type == list_t);",
          "269:    TORRENT_ASSERT(i < int(m_size));",
          "270:    return &m_data.list[i];",
          "271:   }",
          "272:   lazy_entry const* list_at(int i) const",
          "273:   { return const_cast<lazy_entry*>(this)->list_at(i); }",
          "275:   std::string list_string_value_at(int i) const;",
          "276:   pascal_string list_pstr_at(int i) const;",
          "277:   boost::int64_t list_int_value_at(int i, boost::int64_t default_val = 0) const;",
          "280:   int list_size() const",
          "281:   {",
          "282:    TORRENT_ASSERT(m_type == list_t);",
          "283:    return int(m_size);",
          "284:   }",
          "288:   void set_end(char const* end)",
          "289:   {",
          "290:    TORRENT_ASSERT(end > m_begin);",
          "291:    m_len = end - m_begin;",
          "292:   }",
          "295:   void clear();",
          "298:   void release()",
          "299:   {",
          "300:    m_data.start = 0;",
          "301:    m_size = 0;",
          "302:    m_capacity = 0;",
          "303:    m_type = none_t;",
          "304:   }",
          "307:   ~lazy_entry()",
          "308:   { clear(); }",
          "312:   std::pair<char const*, int> data_section() const;",
          "315:   void swap(lazy_entry& e)",
          "316:   {",
          "317:    using std::swap;",
          "318:    boost::uint32_t tmp = e.m_type;",
          "319:    e.m_type = m_type;",
          "320:    m_type = tmp;",
          "321:    tmp = e.m_capacity;",
          "322:    e.m_capacity = m_capacity;",
          "323:    m_capacity = tmp;",
          "324:    swap(m_data.start, e.m_data.start);",
          "325:    swap(m_size, e.m_size);",
          "326:    swap(m_begin, e.m_begin);",
          "327:    swap(m_len, e.m_len);",
          "328:   }",
          "330:  private:",
          "332:   union data_t",
          "333:   {",
          "334:    lazy_dict_entry* dict;",
          "335:    lazy_entry* list;",
          "336:    char const* start;",
          "337:   } m_data;",
          "341:   char const* m_begin;",
          "344:   boost::uint32_t m_len;",
          "347:   boost::uint32_t m_size;",
          "349:   boost::uint32_t m_capacity:29;",
          "351:   boost::uint32_t m_type:3;",
          "354:   lazy_entry(lazy_entry const&);",
          "355:   lazy_entry const& operator=(lazy_entry const&);",
          "356:  };",
          "358:  struct lazy_dict_entry",
          "359:  {",
          "360:   char const* name;",
          "361:   lazy_entry val;",
          "362:  };",
          "364:  TORRENT_EXTRA_EXPORT std::string print_entry(lazy_entry const& e",
          "365:   , bool single_line = false, int indent = 0);",
          "367:  TORRENT_EXPORT boost::system::error_category& get_bdecode_category();",
          "369:  namespace bdecode_errors",
          "370:  {",
          "373:   enum error_code_enum",
          "374:   {",
          "376:    no_error = 0,",
          "378:    expected_string,",
          "380:    expected_colon,",
          "382:    unexpected_eof,",
          "384:    expected_value,",
          "386:    depth_exceeded,",
          "388:    limit_exceeded,",
          "391:    error_code_max",
          "392:   };",
          "395:   inline boost::system::error_code make_error_code(error_code_enum e)",
          "396:   {",
          "397:    return boost::system::error_code(e, get_bdecode_category());",
          "398:   }",
          "399:  }",
          "400: }",
          "402: #endif",
          "",
          "---------------"
        ],
        "main.cpp||main.cpp": [
          "File: main.cpp -> main.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2: The MIT License (MIT)",
          "4: Copyright (c) 2013 BitTorrent Inc.",
          "6: Permission is hereby granted, free of charge, to any person obtaining a copy of",
          "7: this software and associated documentation files (the \"Software\"), to deal in",
          "8: the Software without restriction, including without limitation the rights to",
          "9: use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of",
          "10: the Software, and to permit persons to whom the Software is furnished to do so,",
          "11: subject to the following conditions:",
          "13: The above copyright notice and this permission notice shall be included in all",
          "14: copies or substantial portions of the Software.",
          "16: THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR",
          "17: IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS",
          "18: FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR",
          "19: COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER",
          "20: IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN",
          "21: CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.",
          "24: #include <boost/asio.hpp>",
          "25: #include <thread>",
          "26: #include <functional>",
          "27: #include <deque>",
          "28: #include <chrono>",
          "29: #include <type_traits>",
          "30: #include <random>",
          "31: #include <unordered_set>",
          "33: #include <boost/uuid/sha1.hpp>",
          "34: #include <boost/system/error_code.hpp>",
          "35: #include <boost/bind.hpp>",
          "36: #include \"lazy_entry.hpp\"",
          "37: #include \"bencode.hpp\"",
          "39: using boost::asio::signal_set;",
          "40: using boost::asio::io_service;",
          "41: using boost::asio::ip::udp;",
          "42: using boost::asio::ip::address_v4;",
          "43: using boost::system::error_code;",
          "44: using boost::asio::buffer;",
          "45: using std::chrono::steady_clock;",
          "46: using std::chrono::minutes;",
          "47: using std::chrono::seconds;",
          "48: using boost::uuids::detail::sha1;",
          "50: typedef steady_clock::time_point time_point;",
          "52: namespace std {",
          "54: template <>",
          "55: struct hash<address_v4::bytes_type> : hash<uint32_t>",
          "56: {",
          "57:  size_t operator()(address_v4::bytes_type ip) const",
          "58:  {",
          "59:   uint32_t arg;",
          "60:   std::memcpy(&arg, &ip[0], 4);",
          "61:   return this->hash<uint32_t>::operator()(arg);",
          "62:  }",
          "63: };",
          "65: }",
          "69:  The way the DHT bootstrapping works is by storing all",
          "70:  nodes in one circular buffer of (IP, port, node-id)-triplets.",
          "71:  In this circular buffer there are two cursors, one read",
          "72:  cursor and one write cursor.",
          "73:  When a find_nodes request comes in, we return the next",
          "74:  8 nodes under the read cursor and progresses it.",
          "76:  We remember the node that asked in a separate queue.",
          "77:  At a later time we send ping it. If it responds, we",
          "78:  add it at the write cursor and progresses it.",
          "79:  The transaction ID in the ping acts as a SYN-cookie.",
          "80:  It's set to SHA1(secret, IP, port, node-id), only if",
          "81:  the response matches the transaction ID will it be",
          "82:  added to the list of nodes. The secret rotates periodically",
          "83:  to avoid malicious nodes from inserting themselves",
          "84:  without us pinging them.",
          "86:  In addition to this, nodes whose node ID don't match",
          "87:  the specification at [1] will not be pinged.",
          "89:  A node's external IP and port is always included",
          "90:  in all responses.",
          "93:  [1]: http://libtorrent.org/dht_sec.html",
          "99: struct queued_node_t",
          "100: {",
          "101:  udp::endpoint ep;",
          "102:  char node_id[20];",
          "105:  time_point expire;",
          "106: };",
          "108: struct ping_queue_t",
          "109: {",
          "115:  bool need_ping(queued_node_t* out, bool force)",
          "116:  {",
          "117:   if (m_queue.empty()) return false;",
          "121:   if (!force && m_queue.size() > 10000",
          "122:    && m_queue.front().expire < steady_clock::now())",
          "123:    return false;",
          "126:   m_queue.pop_front();",
          "127:   return true;",
          "128:  }",
          "130:  void insert_node(udp::endpoint const& ep, char const* node_id)",
          "131:  {",
          "132:   queued_node_t e;",
          "133:   e.ep = ep;",
          "134:   memcpy(e.node_id, node_id, 20);",
          "142:   e.expire = steady_clock::now() + minutes(10);",
          "144:   m_queue.push_back(e);",
          "145:  }",
          "147: private:",
          "149:  std::deque<queued_node_t> m_queue;",
          "150: };",
          "154: struct node_entry_t",
          "155: {",
          "156:  address_v4::bytes_type ip;",
          "157:  uint16_t port;",
          "158:  char node_id[20];",
          "159: };",
          "161: struct node_buffer_t",
          "162: {",
          "163:  node_buffer_t() : m_read_cursor(0), m_write_cursor(0) {}",
          "165:  enum { ideal_size = 10000 };",
          "167:  bool empty() const { return m_buffer.empty(); }",
          "169:  bool need_growth() const { return m_buffer.size() < ideal_size; }",
          "171:  std::string get_nodes()",
          "172:  {",
          "173:   std::string ret;",
          "175:   if (m_buffer.size() < 8)",
          "176:   {",
          "177:    ret.resize(m_buffer.size() * sizeof(node_entry_t));",
          "178:    memcpy(&ret[0], &m_buffer[0], m_buffer.size() * sizeof(node_entry_t));",
          "179:    m_read_cursor = 0;",
          "180:    return ret;",
          "181:   }",
          "183:   ret.resize(8 * sizeof(node_entry_t));",
          "185:   if (m_read_cursor < m_buffer.size() - 8)",
          "186:   {",
          "187:    memcpy(&ret[0], &m_buffer[m_read_cursor], sizeof(node_entry_t) * 8);",
          "188:    m_read_cursor += 8;",
          "189:    return ret;",
          "190:   }",
          "192:   int slice1 = m_buffer.size() - m_read_cursor;",
          "193:   assert(slice1 < 8);",
          "194:   memcpy(&ret[0], &m_buffer[m_read_cursor], sizeof(node_entry_t) * slice1);",
          "195:   m_read_cursor += slice1;",
          "197:   int slice2 = 8 - slice1;",
          "198:   memcpy(&ret[slice1 * sizeof(node_entry_t)], &m_buffer[m_read_cursor], sizeof(node_entry_t) * slice2);",
          "199:   m_read_cursor = slice2;",
          "200:   return ret;",
          "201:  }",
          "203:  void insert_node(udp::endpoint const& ep, char const* node_id)",
          "204:  {",
          "205:   node_entry_t e;",
          "206:   e.ip = ep.address().to_v4().to_bytes();",
          "207:   e.port = htons(ep.port());",
          "208:   memcpy(e.node_id, node_id, 20);",
          "211:   if (m_ips.count(e.ip)) return;",
          "213:   if (m_buffer.size() < ideal_size)",
          "214:   {",
          "215:    m_buffer.push_back(e);",
          "216:    m_ips.insert(e.ip);",
          "217:    return;",
          "218:   }",
          "221:   m_ips.erase(m_buffer[m_write_cursor].ip);",
          "222:   m_buffer[m_write_cursor] = e;",
          "224:   m_ips.insert(e.ip);",
          "225:   m_write_cursor = (m_write_cursor + 1) % m_buffer.size();",
          "226:  }",
          "228: private:",
          "230:  int m_read_cursor;",
          "231:  int m_write_cursor;",
          "232:  std::vector<node_entry_t> m_buffer;",
          "236:  std::unordered_set<address_v4::bytes_type> m_ips;",
          "237: };",
          "239: char our_node_id[20];",
          "242: std::string compute_tid(char const* secret, char const* remote_ip, char const* node_id)",
          "243: {",
          "244:  sha1 ctx;",
          "245:  ctx.process_bytes(secret, 20);",
          "246:  ctx.process_bytes(remote_ip, 6);",
          "247:  ctx.process_bytes(node_id, 20);",
          "248:  uint32_t d[5];",
          "249:  ctx.get_digest(d);",
          "250:  std::string ret;",
          "251:  ret.resize(6);",
          "252:  ret[0] = (d[0] >> 24) & 0xff;",
          "253:  ret[1] = (d[0] >> 16) & 0xff;",
          "254:  ret[2] = (d[0] >> 8) & 0xff;",
          "255:  ret[3] = d[0] & 0xff;",
          "256:  ret[4] = (d[1] >> 24) & 0xff;",
          "257:  ret[5] = (d[1] >> 16) & 0xff;",
          "258:  return ret;",
          "259: }",
          "261: bool verify_tid(std::string tid, char const* secret1, char const* secret2, char const* remote_ip, char const* node_id)",
          "262: {",
          "264:  if (tid.size() != 6) return false;",
          "266:  return compute_tid(secret1, remote_ip, node_id) == tid",
          "267:   || compute_tid(secret2, remote_ip, node_id) == tid;",
          "268: }",
          "270: void router_thread(int threadid, udp::socket& sock)",
          "271: {",
          "272:  printf(\"starting thread %d\\n\", threadid);",
          "274:  ping_queue_t ping_queue;",
          "275:  node_buffer_t node_buffer;",
          "278:  char packet[1500];",
          "281:  char response[1500];",
          "283:  char secret1[20];",
          "284:  char secret2[20];",
          "286:  std::random_device r;",
          "287:  std::generate(secret1, secret1 + 20, std::ref(r));",
          "288:  std::generate(secret2, secret2 + 20, std::ref(r));",
          "290:  time_point last_secret_rotate = steady_clock::now();",
          "292:  for (;;)",
          "293:  {",
          "294:   udp::endpoint ep;",
          "295:   error_code ec;",
          "298:   if (last_secret_rotate + minutes(10) < steady_clock::now())",
          "299:   {",
          "300:    std::memcpy(secret2, secret1, 20);",
          "301:    std::generate(secret1, secret1 + 20, std::ref(r));",
          "302:    last_secret_rotate = steady_clock::now();",
          "303:   }",
          "306:   queued_node_t n;",
          "307:   while (ping_queue.need_ping(&n, node_buffer.need_growth()))",
          "308:   {",
          "309:    fprintf(stderr, \"pinging node\\n\");",
          "311:    char remote_ip[6];",
          "312:    address_v4::bytes_type ip = n.ep.address().to_v4().to_bytes();",
          "313:    memcpy(remote_ip, &ip[0], 4);",
          "314:    remote_ip[4] = (n.ep.port() >> 8) & 0xff;",
          "315:    remote_ip[5] = n.ep.port() & 0xff;",
          "318:    std::string transaction_id = compute_tid(secret1, remote_ip, n.node_id);",
          "321:    bencoder b(response, sizeof(response));",
          "322:    b.open_dict();",
          "324:    b.add_string(\"ip\"); b.add_string(remote_ip, 6);",
          "327:    b.add_string(\"a\");",
          "328:    b.open_dict();",
          "329:    b.add_string(\"id\"); b.add_string(our_node_id, 20);",
          "330:    b.close_dict();",
          "332:    b.add_string(\"t\"); b.add_string(transaction_id);",
          "333:    b.add_string(\"q\"); b.add_string(\"ping\");",
          "334:    b.add_string(\"y\"); b.add_string(\"q\");",
          "336:    b.close_dict();",
          "338:    int len = sock.send_to(buffer(response, b.end() - response), n.ep, 0, ec);",
          "339:    if (ec)",
          "340:     fprintf(stderr, \"PING send_to failed: (%d) %s\\n\", ec.value(), ec.message().c_str());",
          "341:    else if (len <= 0)",
          "342:     fprintf(stderr, \"PING send_to failed: return=%d\\n\", len);",
          "343:   }",
          "345:   int len = sock.receive_from(buffer(packet, sizeof(packet)), ep, 0, ec);",
          "346:   if (ec)",
          "347:   {",
          "348:    if (ec == boost::system::errc::interrupted) continue;",
          "349:    if (ec == boost::system::errc::bad_file_descriptor)",
          "350:    {",
          "351:     printf(\"stopping thread %d\\n\", threadid);",
          "352:     return;",
          "353:    }",
          "354:    fprintf(stderr, \"receive_from: (%d) %s\\n\", ec.value(), ec.message().c_str());",
          "355:    return;",
          "356:   }",
          "359:   if (!ep.address().is_v4()) continue;",
          "361:   using libtorrent::lazy_entry;",
          "362:   using libtorrent::lazy_bdecode;",
          "364:   lazy_entry e;",
          "365:   int ret = lazy_bdecode(packet, &packet[len], e, ec, nullptr, 5, 100);",
          "366:   if (ec || ret != 0) continue;",
          "368:   printf(\"R: %s\\n\", print_entry(e, true).c_str());",
          "372:   std::string transaction_id = e.dict_find_string_value(\"t\");",
          "373:   if (transaction_id.empty()) continue;",
          "375:   if (e.type() != lazy_entry::dict_t) continue;",
          "376:   std::string cmd = e.dict_find_string_value(\"q\");",
          "378:   lazy_entry const* a = e.dict_find_dict(\"a\");",
          "379:   if (!a)",
          "380:   {",
          "381:    a = e.dict_find_dict(\"r\");",
          "382:    if (!a) continue;",
          "383:   }",
          "384:   lazy_entry const* node_id = a->dict_find_string(\"id\");",
          "385:   if (!node_id || node_id->string_length() != 20) continue;",
          "391:   char remote_ip[6];",
          "392:   address_v4::bytes_type b = ep.address().to_v4().to_bytes();",
          "393:   memcpy(remote_ip, &b[0], 4);",
          "394:   remote_ip[4] = (ep.port() >> 8) & 0xff;",
          "395:   remote_ip[5] = ep.port() & 0xff;",
          "397:   if (cmd.empty())",
          "398:   {",
          "404:    if (!verify_tid(transaction_id, secret1, secret2, remote_ip, node_id->string_ptr()))",
          "405:     continue;",
          "407:    fprintf(stderr, \"got ping response\\n\");",
          "411:    node_buffer.insert_node(ep, node_id->string_ptr());",
          "412:   }",
          "413:   else if (cmd == \"ping\" || cmd == \"find_node\")",
          "414:   {",
          "416:    bencoder b(response, sizeof(response));",
          "417:    b.open_dict();",
          "419:    b.add_string(\"ip\");",
          "420:    b.add_string(remote_ip, 6);",
          "423:    b.add_string(\"r\");",
          "424:    b.open_dict();",
          "425:    b.add_string(\"id\");",
          "426:    b.add_string(our_node_id, 20);",
          "428:    if (cmd == \"find_node\")",
          "429:    {",
          "432:     if (node_buffer.empty()) continue;",
          "434:     b.add_string(\"values\");",
          "435:     b.add_string(node_buffer.get_nodes());",
          "436:    }",
          "437:    b.close_dict();",
          "439:    b.add_string(\"t\");",
          "440:    b.add_string(transaction_id);",
          "442:    b.add_string(\"y\");",
          "443:    b.add_string(\"r\");",
          "445:    b.close_dict();",
          "447:    int len = sock.send_to(buffer(response, b.end() - response), ep, 0, ec);",
          "448:    if (ec)",
          "449:     fprintf(stderr, \"send_to failed: (%d) %s\\n\", ec.value(), ec.message().c_str());",
          "450:    else if (len <= 0)",
          "451:     fprintf(stderr, \"send_to failed: return=%d\\n\", len);",
          "458:    ping_queue.insert_node(ep, node_id->string_ptr());",
          "459:   }",
          "460:  }",
          "461: }",
          "463: void shutdown(udp::socket& s)",
          "464: {",
          "465:  error_code ec;",
          "466:  s.close(ec);",
          "467:  if (ec)",
          "468:   fprintf(stderr, \"socket: (%d) %s\\n\", ec.value(), ec.message().c_str());",
          "469: }",
          "471: int main()",
          "472: {",
          "473:  static_assert(sizeof(node_entry_t) == 26, \"node_entry_t may not contain padding\");",
          "475:  io_service ios;",
          "476:  udp::socket sock(ios);",
          "478:  error_code ec;",
          "479:  sock.open(udp::v4(), ec);",
          "480:  if (ec)",
          "481:  {",
          "482:   fprintf(stderr, \"socket: (%d) %s\\n\", ec.value(), ec.message().c_str());",
          "483:   return 1;",
          "484:  }",
          "486:  sock.bind(udp::endpoint(address_v4::any(), 6881), ec);",
          "487:  if (ec)",
          "488:  {",
          "489:   fprintf(stderr, \"bind: (%d) %s\\n\", ec.value(), ec.message().c_str());",
          "490:   return 1;",
          "491:  }",
          "498:  signal_set signals(ios);",
          "499:  signals.add(SIGINT);",
          "500:  signals.add(SIGTERM);",
          "503:  signals.async_wait(boost::bind(&shutdown, std::ref(sock)));",
          "505:  std::vector<std::thread> threads;",
          "506:  for (int i = 0; i < 4; ++i)",
          "507:   threads.emplace_back(&router_thread, i, std::ref(sock));",
          "509:  ios.run(ec);",
          "510:  if (ec)",
          "511:  {",
          "512:   fprintf(stderr, \"io_service: (%d) %s\\n\", ec.value(), ec.message().c_str());",
          "513:   return 1;",
          "514:  }",
          "516:  for (auto& i : threads)",
          "517:   i.join();",
          "519:  return 0;",
          "520: }",
          "",
          "---------------"
        ],
        "test_dht.py||test_dht.py": [
          "File: test_dht.py -> test_dht.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: #!/usr/bin/python",
          "3: import socket",
          "4: import select",
          "5: import sys",
          "7: from bencode import bencode, bdecode",
          "9: import random",
          "12: def send_dht_message(msg, target):",
          "13:  try:",
          "14:   s.sendto(bencode(msg), 0, target)",
          "15:  except:",
          "16:   print msg",
          "18: def random_key():",
          "19:  ret = ''",
          "20:  for i in range(0, 20):",
          "21:   ret += chr(random.randint(0, 255))",
          "22:  return ret",
          "24: def test_message(query, args, verify):",
          "25:  tid = random.randint(0, 255)",
          "26:  node_id = random_key()",
          "28:  print '%s %d -> %s:%d' % (query, tid, sys.argv[1], int(sys.argv[2]))",
          "30:  msg = {'a': {'id': node_id}, 'q': query, 'y': 'q', 't': '%d' % tid}",
          "31:  for k,v in args.iteritems():",
          "32:   msg['a'][k] = v",
          "34:  send_dht_message(msg, (sys.argv[1], int(sys.argv[2])))",
          "36:  while 1:",
          "37:   n = select.select([s], [], [s], 5)",
          "39:   ret = False",
          "40:   if len(n[0]) == 0:",
          "41:    print 'socket timed out'",
          "42:    print '\\n\\n=== FAILED ===\\n\\n'",
          "43:    return False",
          "44:   # the socket became readable",
          "45:   response = s.recv(1000)",
          "46:   try:",
          "47:    response = bdecode(response)",
          "48:    if response['y'] != 'r':",
          "49:     print 'expected a response, received %s' % response",
          "50:     continue",
          "51: #    print '\\n\\n=== FAILED ===\\n\\n'",
          "52: #    return False",
          "53:    if response['t'] != '%d' % tid:",
          "54:     print 'incorrect tid: %s, expected %d' % (response['t'], tid)",
          "55:     print '\\n\\n=== FAILED ===\\n\\n'",
          "56:     return False",
          "57:   except:",
          "58:    print response",
          "60:   break",
          "62:  print '<-- ', response",
          "63:  ret = verify(response['r'])",
          "65:  if ret: print '*** Passed ***'",
          "66:  else: print '\\n\\n=== FAILED ===\\n%s\\n' % response",
          "67:  return ret",
          "69: s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)",
          "70: if len(sys.argv) < 3:",
          "71:  print 'usage: %s host port' % sys.argv[0]",
          "72:  sys.exit(1)",
          "74: def verify_nodes(x):",
          "75:  if not 'nodes' in x:",
          "76:   print 'missing nodes entry'",
          "77:   return False",
          "79:  if len(x['nodes']) % (6+20) != 0:",
          "80:   print 'node response not divisible by 26 (%d)' % len(x['nodes'])",
          "81:   return False",
          "83:  print 'received %d nodes' % (len(x['nodes']) / 26)",
          "85:  return True",
          "87: ret = True",
          "88: print '=== TESTING DHT PING ==='",
          "89: ret &= test_message('ping', {}, lambda x: True)",
          "90: ret &= test_message('find_node', {'target': random_key()}, verify_nodes)",
          "92: sys.exit(ret)",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "e809ea80e3527e32c40756eddd8b2ae44bc3af1a",
      "candidate_info": {
        "commit_hash": "e809ea80e3527e32c40756eddd8b2ae44bc3af1a",
        "repo": "bittorrent/bootstrap-dht",
        "commit_url": "https://github.com/bittorrent/bootstrap-dht/commit/e809ea80e3527e32c40756eddd8b2ae44bc3af1a",
        "files": [
          "lazy_bdecode.cpp"
        ],
        "message": "Check for out-of-bounds bencoded lengths before advancing buffer pointer",
        "before_after_code_files": [
          "lazy_bdecode.cpp||lazy_bdecode.cpp"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "lazy_bdecode.cpp||lazy_bdecode.cpp"
          ],
          "candidate": [
            "lazy_bdecode.cpp||lazy_bdecode.cpp"
          ]
        }
      },
      "candidate_diff": {
        "lazy_bdecode.cpp||lazy_bdecode.cpp": [
          "File: lazy_bdecode.cpp -> lazy_bdecode.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "150:      if (e)",
          "151:       TORRENT_FAIL_BDECODE(e);",
          "154:       TORRENT_FAIL_BDECODE(bdecode_errors::unexpected_eof);",
          "156:      if (len < 0)",
          "",
          "[Removed Lines]",
          "153:      if (start + len + 1 > end)",
          "",
          "[Added Lines]",
          "154:      const ptrdiff_t buff_size = end - start - 1;",
          "155:      if (len > buff_size)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "216:      start = parse_int(start, end, ':', len, e);",
          "217:      if (e)",
          "218:       TORRENT_FAIL_BDECODE(e);",
          "220:       TORRENT_FAIL_BDECODE(bdecode_errors::unexpected_eof);",
          "221:      if (len < 0)",
          "222:       TORRENT_FAIL_BDECODE(bdecode_errors::overflow);",
          "224:      ++start;",
          "225:      top->construct_string(start, int(len));",
          "226:      stack.pop_back();",
          "227:      start += len;",
          "",
          "[Removed Lines]",
          "219:      if (start + len + 1 > end)",
          "",
          "[Added Lines]",
          "223:      const ptrdiff_t buff_size = end - start - 1;",
          "224:      if (len > buff_size)",
          "230:      if (start == end) TORRENT_FAIL_BDECODE(bdecode_errors::unexpected_eof);",
          "",
          "---------------"
        ]
      }
    }
  ]
}
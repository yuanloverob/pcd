{
  "cve_id": "CVE-2021-32675",
  "cve_desc": "Redis is an open source, in-memory database that persists on disk. When parsing an incoming Redis Standard Protocol (RESP) request, Redis allocates memory according to user-specified values which determine the number of elements (in the multi-bulk header) and size of each element (in the bulk header). An attacker delivering specially crafted requests over multiple connections can cause the server to allocate significant amount of memory. Because the same parsing mechanism is used to handle authentication requests, this vulnerability can also be exploited by unauthenticated users. The problem is fixed in Redis versions 6.2.6, 6.0.16 and 5.0.14. An additional workaround to mitigate this problem without patching the redis-server executable is to block access to prevent unauthenticated users from connecting to Redis. This can be done in different ways: Using network access control tools like firewalls, iptables, security groups, etc. or Enabling TLS and requiring users to authenticate using client side certificates.",
  "repo": "redis/redis",
  "patch_hash": "5674b0057ff2903d43eaff802017eddf37c360f8",
  "patch_info": {
    "commit_hash": "5674b0057ff2903d43eaff802017eddf37c360f8",
    "repo": "redis/redis",
    "commit_url": "https://github.com/redis/redis/commit/5674b0057ff2903d43eaff802017eddf37c360f8",
    "files": [
      "src/networking.c",
      "src/server.c",
      "src/server.h",
      "tests/unit/auth.tcl"
    ],
    "message": "Prevent unauthenticated client from easily consuming lots of memory (CVE-2021-32675)\n\nThis change sets a low limit for multibulk and bulk length in the\nprotocol for unauthenticated connections, so that they can't easily\ncause redis to allocate massive amounts of memory by sending just a few\ncharacters on the network.\nThe new limits are 10 arguments of 16kb each (instead of 1m of 512mb)",
    "before_after_code_files": [
      "src/networking.c||src/networking.c",
      "src/server.c||src/server.c",
      "src/server.h||src/server.h",
      "tests/unit/auth.tcl||tests/unit/auth.tcl"
    ]
  },
  "patch_diff": {
    "src/networking.c||src/networking.c": [
      "File: src/networking.c -> src/networking.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "97:     raxInsert(server.clients_index,(unsigned char*)&id,sizeof(id),c,NULL);",
      "98: }",
      "100: client *createClient(connection *conn) {",
      "101:     client *c = zmalloc(sizeof(client));",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "100: int authRequired(client *c) {",
      "103:     int auth_required = (!(DefaultUser->flags & USER_FLAG_NOPASS) ||",
      "104:                           (DefaultUser->flags & USER_FLAG_DISABLED)) &&",
      "105:                         !c->authenticated;",
      "106:     return auth_required;",
      "107: }",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "1744:             addReplyError(c,\"Protocol error: invalid multibulk length\");",
      "1745:             setProtocolError(\"invalid mbulk count\",c);",
      "1746:             return C_ERR;",
      "1747:         }",
      "1749:         c->qb_pos = (newline-c->querybuf)+2;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1756:         } else if (ll > 10 && authRequired(c)) {",
      "1757:             addReplyError(c, \"Protocol error: unauthenticated multibulk length\");",
      "1758:             setProtocolError(\"unauth mbulk count\", c);",
      "1759:             return C_ERR;",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "1791:                 addReplyError(c,\"Protocol error: invalid bulk length\");",
      "1792:                 setProtocolError(\"invalid bulk length\",c);",
      "1793:                 return C_ERR;",
      "1794:             }",
      "1796:             c->qb_pos = newline-c->querybuf+2;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1807:             } else if (ll > 16384 && authRequired(c)) {",
      "1808:                 addReplyError(c, \"Protocol error: unauthenticated bulk length\");",
      "1809:                 setProtocolError(\"unauth bulk length\", c);",
      "1810:                 return C_ERR;",
      "",
      "---------------"
    ],
    "src/server.c||src/server.c": [
      "File: src/server.c -> src/server.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "3590:     int is_denyloading_command = !(c->cmd->flags & CMD_LOADING) ||",
      "3591:                                  (c->cmd->proc == execCommand && (c->mstate.cmd_inv_flags & CMD_LOADING));",
      "3601:         if (!(c->cmd->flags & CMD_NO_AUTH)) {",
      "3602:             rejectCommand(c,shared.noautherr);",
      "",
      "[Removed Lines]",
      "3595:     int auth_required = (!(DefaultUser->flags & USER_FLAG_NOPASS) ||",
      "3596:                           (DefaultUser->flags & USER_FLAG_DISABLED)) &&",
      "3597:                         !c->authenticated;",
      "3598:     if (auth_required) {",
      "",
      "[Added Lines]",
      "3593:     if (authRequired(c)) {",
      "",
      "---------------"
    ],
    "src/server.h||src/server.h": [
      "File: src/server.h -> src/server.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "1743: void unprotectClient(client *c);",
      "1744: void initThreadedIO(void);",
      "1745: client *lookupClientByID(uint64_t id);",
      "1747: #ifdef __GNUC__",
      "1748: void addReplyErrorFormat(client *c, const char *fmt, ...)",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1746: int authRequired(client *c);",
      "",
      "---------------"
    ],
    "tests/unit/auth.tcl||tests/unit/auth.tcl": [
      "File: tests/unit/auth.tcl -> tests/unit/auth.tcl",
      "--- Hunk 1 ---",
      "[Context before]",
      "24:         r set foo 100",
      "25:         r incr foo",
      "26:     } {101}",
      "27: }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "28:     test {For unauthenticated clients multibulk and bulk length are limited} {",
      "29:         set rr [redis [srv \"host\"] [srv \"port\"] 0 $::tls]",
      "30:         $rr write \"*100\\r\\n\"",
      "31:         $rr flush",
      "32:         catch {[$rr read]} e",
      "33:         assert_match {*unauthenticated multibulk length*} $e",
      "34:         $rr close",
      "36:         set rr [redis [srv \"host\"] [srv \"port\"] 0 $::tls]",
      "37:         $rr write \"*1\\r\\n\\$100000000\\r\\n\"",
      "38:         $rr flush",
      "39:         catch {[$rr read]} e",
      "40:         assert_match {*unauthenticated bulk length*} $e",
      "41:         $rr close",
      "42:     }",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "6ac3c0b7abd35f37201ed2d6298ecef4ea1ae1dd",
      "candidate_info": {
        "commit_hash": "6ac3c0b7abd35f37201ed2d6298ecef4ea1ae1dd",
        "repo": "redis/redis",
        "commit_url": "https://github.com/redis/redis/commit/6ac3c0b7abd35f37201ed2d6298ecef4ea1ae1dd",
        "files": [
          "src/scripting.c",
          "tests/unit/scripting.tcl"
        ],
        "message": "Fix protocol parsing on 'ldbReplParseCommand' (CVE-2021-32672)\n\nThe protocol parsing on 'ldbReplParseCommand' (LUA debugging)\nAssumed protocol correctness. This means that if the following\nis given:\n*1\n$100\ntest\nThe parser will try to read additional 94 unallocated bytes after\nthe client buffer.\nThis commit fixes this issue by validating that there are actually enough\nbytes to read. It also limits the amount of data that can be sent by\nthe debugger client to 1M so the client will not be able to explode\nthe memory.",
        "before_after_code_files": [
          "src/scripting.c||src/scripting.c",
          "tests/unit/scripting.tcl||tests/unit/scripting.tcl"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/redis/redis/pull/9584"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "src/scripting.c||src/scripting.c": [
          "File: src/scripting.c -> src/scripting.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "2030:     sds *argv = NULL;",
          "2031:     int argc = 0;",
          "2032:     if (sdslen(ldb.cbuf) == 0) return NULL;",
          "",
          "[Removed Lines]",
          "2029: sds *ldbReplParseCommand(int *argcp) {",
          "",
          "[Added Lines]",
          "2029: sds *ldbReplParseCommand(int *argcp, char** err) {",
          "2030:     static char* protocol_error = \"protocol error\";",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2044:     p = strchr(p,'*'); if (!p) goto protoerr;",
          "2049:     if (*argcp <= 0 || *argcp > 1024) goto protoerr;",
          "",
          "[Removed Lines]",
          "2046:     p = strstr(p,\"\\r\\n\"); if (!p) goto protoerr;",
          "",
          "[Added Lines]",
          "2047:     p = strstr(p,\"\\r\\n\"); if (!p) goto keep_reading;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "2052:     argv = zmalloc(sizeof(sds)*(*argcp));",
          "2053:     argc = 0;",
          "2054:     while(argc < *argcp) {",
          "2055:         if (*p != '$') goto protoerr;",
          "2060:         if (slen <= 0 || slen > 1024) goto protoerr;",
          "2061:         argv[argc++] = sdsnewlen(p,slen);",
          "2063:         if (p[0] != '\\r' || p[1] != '\\n') goto protoerr;",
          "",
          "[Removed Lines]",
          "2057:         p = strstr(p,\"\\r\\n\"); if (!p) goto protoerr;",
          "",
          "[Added Lines]",
          "2057:         if (*p == '\\0') goto keep_reading;",
          "2061:         p = strstr(p,\"\\r\\n\"); if (!p) goto keep_reading;",
          "2065:         if ((size_t)(p + slen + 2 - copy) > sdslen(copy) ) goto keep_reading;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "2067:     return argv;",
          "2069: protoerr:",
          "2070:     sdsfreesplitres(argv,argc);",
          "2071:     sdsfree(copy);",
          "2072:     return NULL;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2076: keep_reading:",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "2555: int ldbRepl(lua_State *lua) {",
          "2556:     sds *argv;",
          "2557:     int argc;",
          "2561:     while(1) {",
          "2563:             char buf[1024];",
          "2564:             int nread = connRead(ldb.conn,buf,sizeof(buf));",
          "2565:             if (nread <= 0) {",
          "",
          "[Removed Lines]",
          "2562:         while((argv = ldbReplParseCommand(&argc)) == NULL) {",
          "",
          "[Added Lines]",
          "2565:     char* err = NULL;",
          "2570:         while((argv = ldbReplParseCommand(&argc, &err)) == NULL) {",
          "2572:             if (err) {",
          "2573:                 lua_pushstring(lua, err);",
          "2574:                 lua_error(lua);",
          "2575:             }",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "2570:                 return C_ERR;",
          "2571:             }",
          "2572:             ldb.cbuf = sdscatlen(ldb.cbuf,buf,nread);",
          "2573:         }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2588:             if (sdslen(ldb.cbuf) > 1<<20) {",
          "2589:                 sdsfree(ldb.cbuf);",
          "2590:                 ldb.cbuf = sdsempty();",
          "2591:                 lua_pushstring(lua, \"max client buffer reached\");",
          "2592:                 lua_error(lua);",
          "2593:             }",
          "",
          "---------------"
        ],
        "tests/unit/scripting.tcl||tests/unit/scripting.tcl": [
          "File: tests/unit/scripting.tcl -> tests/unit/scripting.tcl",
          "--- Hunk 1 ---",
          "[Context before]",
          "820:     r eval {return 'hello'} 0",
          "821:     r eval {return 'hello'} 0",
          "822: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "824: start_server {tags {\"scripting needs:debug external:skip\"}} {",
          "825:     test {Test scripting debug protocol parsing} {",
          "826:         r script debug sync",
          "827:         r eval {return 'hello'} 0",
          "828:         catch {r 'hello\\0world'} e",
          "829:         assert_match {*Unknown Redis Lua debugger command*} $e",
          "830:         catch {r 'hello\\0'} e",
          "831:         assert_match {*Unknown Redis Lua debugger command*} $e",
          "832:         catch {r '\\0hello'} e",
          "833:         assert_match {*Unknown Redis Lua debugger command*} $e",
          "834:         catch {r '\\0hello\\0'} e",
          "835:         assert_match {*Unknown Redis Lua debugger command*} $e",
          "836:     }",
          "837: }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "12a6b438a34b064389f347a09970237fc5f616d1",
      "candidate_info": {
        "commit_hash": "12a6b438a34b064389f347a09970237fc5f616d1",
        "repo": "redis/redis",
        "commit_url": "https://github.com/redis/redis/commit/12a6b438a34b064389f347a09970237fc5f616d1",
        "files": [
          "src/rio.c"
        ],
        "message": "Fix harmless bug in rioConnRead (#7557)\n\nthis code is in use only if the master is disk-based, and the replica is\ndiskless. In this case we use a buffered reader, but we must avoid reading\npast the rdb file, into the command stream. which Luckly rdb.c doesn't\nreally attempt to do (it knows how much it should read).\n\nWhen rioConnRead detects that the extra buffering attempt reaches beyond\nthe read limit it should read less, but if the caller actually requested\nmore, then it should return with an error rather than a short read. the\nbug would have resulted in short read.\n\nin order to fix it, the code must consider the real requested size, and\nnot the extra buffering size.\n\n(cherry picked from commit 40d7fca3685d8439bae8480ddbd59775a2390411)",
        "before_after_code_files": [
          "src/rio.c||src/rio.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/redis/redis/pull/9584"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "src/rio.c||src/rio.c": [
          "File: src/rio.c -> src/rio.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "191:     while (len > sdslen(r->io.conn.buf) - r->io.conn.pos) {",
          "192:         size_t buffered = sdslen(r->io.conn.buf) - r->io.conn.pos;",
          "197:         if (toread > sdsavail(r->io.conn.buf)) toread = sdsavail(r->io.conn.buf);",
          "198:         if (r->io.conn.read_limit != 0 &&",
          "199:             r->io.conn.read_so_far + buffered + toread > r->io.conn.read_limit)",
          "200:         {",
          "202:                 toread = r->io.conn.read_limit - r->io.conn.read_so_far - buffered;",
          "203:             else {",
          "204:                 errno = EOVERFLOW;",
          "",
          "[Removed Lines]",
          "193:         size_t toread = len - buffered;",
          "196:         if (toread < PROTO_IOBUF_LEN) toread = PROTO_IOBUF_LEN;",
          "201:             if (r->io.conn.read_limit >= r->io.conn.read_so_far - buffered)",
          "",
          "[Added Lines]",
          "193:         size_t needs = len - buffered;",
          "196:         size_t toread = needs < PROTO_IOBUF_LEN ? PROTO_IOBUF_LEN: needs;",
          "204:             if (r->io.conn.read_limit >= r->io.conn.read_so_far + needs)",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "5a82df05aa07cbc99213c5c0128276f6e12c8d3a",
      "candidate_info": {
        "commit_hash": "5a82df05aa07cbc99213c5c0128276f6e12c8d3a",
        "repo": "redis/redis",
        "commit_url": "https://github.com/redis/redis/commit/5a82df05aa07cbc99213c5c0128276f6e12c8d3a",
        "files": [
          "src/rio.c"
        ],
        "message": "more strict check in rioConnRead (#7564)\n\n(cherry picked from commit da840e9851bab8d1674e245a812b2105be111208)",
        "before_after_code_files": [
          "src/rio.c||src/rio.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/redis/redis/pull/9584"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "src/rio.c||src/rio.c": [
          "File: src/rio.c -> src/rio.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "205:                 toread = r->io.conn.read_limit - r->io.conn.read_so_far - buffered;",
          "206:             else {",
          "207:                 errno = EOVERFLOW;",
          "",
          "[Removed Lines]",
          "204:             if (r->io.conn.read_limit >= r->io.conn.read_so_far + needs)",
          "",
          "[Added Lines]",
          "204:             if (r->io.conn.read_limit >= r->io.conn.read_so_far + len)",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "666ed7facf4524bf6d19b11b20faa2cf93fdf591",
      "candidate_info": {
        "commit_hash": "666ed7facf4524bf6d19b11b20faa2cf93fdf591",
        "repo": "redis/redis",
        "commit_url": "https://github.com/redis/redis/commit/666ed7facf4524bf6d19b11b20faa2cf93fdf591",
        "files": [
          "src/scripting.c"
        ],
        "message": "Fix invalid memory write on lua stack overflow {CVE-2021-32626}\n\nWhen LUA call our C code, by default, the LUA stack has room for 20\nelements. In most cases, this is more than enough but sometimes it's not\nand the caller must verify the LUA stack size before he pushes elements.\n\nOn 3 places in the code, there was no verification of the LUA stack size.\nOn specific inputs this missing verification could have lead to invalid\nmemory write:\n1. On 'luaReplyToRedisReply', one might return a nested reply that will\n   explode the LUA stack.\n2. On 'redisProtocolToLuaType', the Redis reply might be deep enough\n\u00a0 \u00a0to explode the LUA stack (notice that currently there is no such\n\u00a0 \u00a0command in Redis that returns such a nested reply, but modules might\n\u00a0 \u00a0do it)\n3. On 'ldbRedis', one might give a command with enough arguments to\n\u00a0 \u00a0explode the LUA stack (all the arguments will be pushed to the LUA\n\u00a0 \u00a0stack)\n\nThis commit is solving all those 3 issues by calling 'lua_checkstack' and\nverify that there is enough room in the LUA stack to push elements. In\ncase 'lua_checkstack' returns an error (there is not enough room in the\nLUA stack and it's not possible to increase the stack), we will do the\nfollowing:\n1. On 'luaReplyToRedisReply', we will return an error to the user.\n2. On 'redisProtocolToLuaType' we will exit with panic (we assume this\n   scenario is rare because it can only happen with a module).\n3. On 'ldbRedis', we return an error.",
        "before_after_code_files": [
          "src/scripting.c||src/scripting.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/redis/redis/pull/9584"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "src/scripting.c||src/scripting.c": [
          "File: src/scripting.c -> src/scripting.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "130: char *redisProtocolToLuaType(lua_State *lua, char* reply) {",
          "131:     char *p = reply;",
          "133:     switch(*p) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "132:     if (!lua_checkstack(lua, 5)) {",
          "138:         serverPanic(\"lua stack limit reach when parsing redis.call reply\");",
          "139:     }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "220:             if (atype == '%') {",
          "221:                 p = redisProtocolToLuaType(lua,p);",
          "222:             } else {",
          "223:                 lua_pushboolean(lua,1);",
          "224:             }",
          "225:             lua_settable(lua,-3);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "233:                 if (!lua_checkstack(lua, 1)) {",
          "236:                     serverPanic(\"lua stack limit reach when parsing redis.call reply\");",
          "237:                 }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "341: void luaReplyToRedisReply(client *c, lua_State *lua) {",
          "342:     int t = lua_type(lua,-1);",
          "344:     switch(t) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "358:     if (!lua_checkstack(lua, 4)) {",
          "363:         addReplyErrorFormat(c, \"reached lua stack limit\");",
          "364:         lua_pop(lua,1); // pop the element from the stack",
          "365:         return;",
          "366:     }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "2506: void ldbRedis(lua_State *lua, sds *argv, int argc) {",
          "2507:     int j, saved_rc = server.lua_replicate_commands;",
          "2509:     lua_getglobal(lua,\"redis\");",
          "2510:     lua_pushstring(lua,\"call\");",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2539:     if (!lua_checkstack(lua, argc + 1)) {",
          "2546:         ldbLogRedisReply(\"max lua stack reached\");",
          "2547:         return;",
          "2548:     }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "dde1c975b88f2e305ad4df720230474e30f6b100",
      "candidate_info": {
        "commit_hash": "dde1c975b88f2e305ad4df720230474e30f6b100",
        "repo": "redis/redis",
        "commit_url": "https://github.com/redis/redis/commit/dde1c975b88f2e305ad4df720230474e30f6b100",
        "files": [
          "src/replication.c",
          "src/rio.c"
        ],
        "message": "Minor refactoring for rioConnRead and adding errno (#9280)\n\nminor refactoring for rioConnRead and adding errno\n\n(cherry picked from commit a40381640502439f751f42c4b23d4c6d396993e3)",
        "before_after_code_files": [
          "src/replication.c||src/replication.c",
          "src/rio.c||src/rio.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/redis/redis/pull/9584"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "src/replication.c||src/replication.c": [
          "File: src/replication.c -> src/replication.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1667:         if (rdbLoadRio(&rdb,RDBFLAGS_REPLICATION,&rsi) != C_OK) {",
          "1670:             serverLog(LL_WARNING,",
          "1673:             cancelReplicationHandshake();",
          "1674:             rioFreeConn(&rdb, NULL);",
          "",
          "[Removed Lines]",
          "1669:             stopLoading(0);",
          "1671:                 \"Failed trying to load the MASTER synchronization DB \"",
          "1672:                 \"from socket\");",
          "",
          "[Added Lines]",
          "1670:                       \"Failed trying to load the MASTER synchronization DB \"",
          "1671:                       \"from socket: %s\", strerror(errno));",
          "1672:             stopLoading(0);",
          "",
          "---------------"
        ],
        "src/rio.c||src/rio.c": [
          "File: src/rio.c -> src/rio.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "187:         r->io.conn.pos = 0;",
          "188:     }",
          "191:     while (len > sdslen(r->io.conn.buf) - r->io.conn.pos) {",
          "192:         size_t buffered = sdslen(r->io.conn.buf) - r->io.conn.pos;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "193:     if (r->io.conn.read_limit != 0 && r->io.conn.read_limit < r->io.conn.read_so_far + len) {",
          "194:         errno = EOVERFLOW;",
          "195:         return 0;",
          "196:     }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "198:         if (r->io.conn.read_limit != 0 &&",
          "199:             r->io.conn.read_so_far + buffered + toread > r->io.conn.read_limit)",
          "200:         {",
          "210:         }",
          "211:         int retval = connRead(r->io.conn.conn,",
          "212:                           (char*)r->io.conn.buf + sdslen(r->io.conn.buf),",
          "",
          "[Removed Lines]",
          "204:             if (r->io.conn.read_limit >= r->io.conn.read_so_far + len)",
          "205:                 toread = r->io.conn.read_limit - r->io.conn.read_so_far - buffered;",
          "206:             else {",
          "207:                 errno = EOVERFLOW;",
          "208:                 return 0;",
          "209:             }",
          "",
          "[Added Lines]",
          "209:             toread = r->io.conn.read_limit - r->io.conn.read_so_far - buffered;",
          "",
          "---------------"
        ]
      }
    }
  ]
}
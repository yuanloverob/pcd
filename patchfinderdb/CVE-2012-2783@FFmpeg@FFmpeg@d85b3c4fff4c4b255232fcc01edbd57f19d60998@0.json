{
  "cve_id": "CVE-2012-2783",
  "cve_desc": "Unspecified vulnerability in libavcodec/vp56.c in FFmpeg before 0.11, and Libav 0.7.x before 0.7.7 and 0.8.x before 0.8.5, has unknown impact and attack vectors, related to \"freeing the returned frame.\"",
  "repo": "FFmpeg/FFmpeg",
  "patch_hash": "d85b3c4fff4c4b255232fcc01edbd57f19d60998",
  "patch_info": {
    "commit_hash": "d85b3c4fff4c4b255232fcc01edbd57f19d60998",
    "repo": "FFmpeg/FFmpeg",
    "commit_url": "https://github.com/FFmpeg/FFmpeg/commit/d85b3c4fff4c4b255232fcc01edbd57f19d60998",
    "files": [
      "libavcodec/vp56.c"
    ],
    "message": "vp56dec: avoid freeing the returned frame before returning it.\n\nFound-by: Mateusz \"j00ru\" Jurczyk and Gynvael Coldwind\nSigned-off-by: Michael Niedermayer <michaelni@gmx.at>",
    "before_after_code_files": [
      "libavcodec/vp56.c||libavcodec/vp56.c"
    ]
  },
  "patch_diff": {
    "libavcodec/vp56.c||libavcodec/vp56.c": [
      "File: libavcodec/vp56.c -> libavcodec/vp56.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "622:     next:",
      "623:         if (p->key_frame || golden_frame) {",
      "625:                 s->framep[VP56_FRAME_GOLDEN] != s->framep[VP56_FRAME_GOLDEN2])",
      "626:                 avctx->release_buffer(avctx, s->framep[VP56_FRAME_GOLDEN]);",
      "627:             s->framep[VP56_FRAME_GOLDEN] = p;",
      "",
      "[Removed Lines]",
      "624:             if (s->framep[VP56_FRAME_GOLDEN]->data[0] &&",
      "",
      "[Added Lines]",
      "624:             if (s->framep[VP56_FRAME_GOLDEN]->data[0] && s->framep[VP56_FRAME_GOLDEN] != p &&",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "1c20fcf0b0d30b63c33e4302c3d92b66b1665b33",
      "candidate_info": {
        "commit_hash": "1c20fcf0b0d30b63c33e4302c3d92b66b1665b33",
        "repo": "FFmpeg/FFmpeg",
        "commit_url": "https://github.com/FFmpeg/FFmpeg/commit/1c20fcf0b0d30b63c33e4302c3d92b66b1665b33",
        "files": [
          "libavcodec/vp56.c"
        ],
        "message": "lavc/vp56: Simplify get/release_buffer code\n\nRather than cleverly managing frame pointers with swaps to avoid\nre-using \"golden\" frames, just do brute-force management of the\n4 AVFrames.  New strategy is probably no more costly and is easier\nto adapt to threaded usage.\n\nSigned-off-by: Ben Jackson <ben@ben.com>\nSigned-off-by: Michael Niedermayer <michaelni@gmx.at>",
        "before_after_code_files": [
          "libavcodec/vp56.c||libavcodec/vp56.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "libavcodec/vp56.c||libavcodec/vp56.c"
          ],
          "candidate": [
            "libavcodec/vp56.c||libavcodec/vp56.c"
          ]
        }
      },
      "candidate_diff": {
        "libavcodec/vp56.c||libavcodec/vp56.c": [
          "File: libavcodec/vp56.c -> libavcodec/vp56.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "491: {",
          "492:     const uint8_t *buf = avpkt->data;",
          "493:     VP56Context *s = avctx->priv_data;",
          "495:     int remaining_buf_size = avpkt->size;",
          "496:     int is_alpha, av_uninit(alpha_offset);",
          "498:     if (s->has_alpha) {",
          "499:         if (remaining_buf_size < 3)",
          "",
          "[Removed Lines]",
          "494:     AVFrame *const p = s->framep[VP56_FRAME_CURRENT];",
          "",
          "[Added Lines]",
          "494:     AVFrame *p = 0;",
          "497:     int i;",
          "500:     for (i = 0; i < 4; ++i) {",
          "501:         if (!s->frames[i].data[0]) {",
          "502:             p = &s->frames[i];",
          "503:             break;",
          "504:         }",
          "505:     }",
          "506:     av_assert0(p != 0);",
          "507:     s->framep[VP56_FRAME_CURRENT] = p;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "621:     next:",
          "622:         if (p->key_frame || s->golden_frame) {",
          "626:             s->framep[VP56_FRAME_GOLDEN] = p;",
          "627:         }",
          "",
          "[Removed Lines]",
          "623:             if (s->framep[VP56_FRAME_GOLDEN]->data[0] && s->framep[VP56_FRAME_GOLDEN] != p &&",
          "624:                 s->framep[VP56_FRAME_GOLDEN] != s->framep[VP56_FRAME_GOLDEN2])",
          "625:                 avctx->release_buffer(avctx, s->framep[VP56_FRAME_GOLDEN]);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "634:         }",
          "635:     }",
          "648:     FFSWAP(AVFrame *, s->framep[VP56_FRAME_CURRENT],",
          "649:                       s->framep[VP56_FRAME_PREVIOUS]);",
          "651:     p->qstride = 0;",
          "652:     p->qscale_table = s->qscale_table;",
          "653:     p->qscale_type = FF_QSCALE_TYPE_VP56;",
          "",
          "[Removed Lines]",
          "637:     if (s->framep[VP56_FRAME_PREVIOUS] == s->framep[VP56_FRAME_GOLDEN] ||",
          "638:         s->framep[VP56_FRAME_PREVIOUS] == s->framep[VP56_FRAME_GOLDEN2]) {",
          "639:         if (s->framep[VP56_FRAME_UNUSED] != s->framep[VP56_FRAME_GOLDEN] &&",
          "640:             s->framep[VP56_FRAME_UNUSED] != s->framep[VP56_FRAME_GOLDEN2])",
          "641:             FFSWAP(AVFrame *, s->framep[VP56_FRAME_PREVIOUS],",
          "642:                               s->framep[VP56_FRAME_UNUSED]);",
          "643:         else",
          "644:             FFSWAP(AVFrame *, s->framep[VP56_FRAME_PREVIOUS],",
          "645:                               s->framep[VP56_FRAME_UNUSED2]);",
          "646:     } else if (s->framep[VP56_FRAME_PREVIOUS]->data[0])",
          "647:         avctx->release_buffer(avctx, s->framep[VP56_FRAME_PREVIOUS]);",
          "",
          "[Added Lines]",
          "649:     for (i = 0; i < 4; ++i) {",
          "650:         AVFrame *victim = &s->frames[i];",
          "651:         if (!victim->data[0])",
          "652:             continue;",
          "653:         if (victim != s->framep[VP56_FRAME_PREVIOUS] &&",
          "654:             victim != s->framep[VP56_FRAME_GOLDEN] &&",
          "655:             (!s->has_alpha || victim != s->framep[VP56_FRAME_GOLDEN2]))",
          "656:             avctx->release_buffer(avctx, victim);",
          "657:     }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "714: av_cold int ff_vp56_free_context(VP56Context *s)",
          "715: {",
          "716:     AVCodecContext *avctx = s->avctx;",
          "718:     av_freep(&s->qscale_table);",
          "719:     av_freep(&s->above_blocks);",
          "720:     av_freep(&s->macroblocks);",
          "721:     av_freep(&s->edge_emu_buffer_alloc);",
          "728:     return 0;",
          "729: }",
          "",
          "[Removed Lines]",
          "722:     if (s->framep[VP56_FRAME_GOLDEN]->data[0])",
          "723:         avctx->release_buffer(avctx, s->framep[VP56_FRAME_GOLDEN]);",
          "724:     if (s->framep[VP56_FRAME_GOLDEN2]->data[0])",
          "725:         avctx->release_buffer(avctx, s->framep[VP56_FRAME_GOLDEN2]);",
          "726:     if (s->framep[VP56_FRAME_PREVIOUS]->data[0])",
          "727:         avctx->release_buffer(avctx, s->framep[VP56_FRAME_PREVIOUS]);",
          "",
          "[Added Lines]",
          "725:     int i;",
          "731:     for (i = 0; i < 4; ++i) {",
          "732:         if (s->frames[i].data[0])",
          "733:             avctx->release_buffer(avctx, &s->frames[i]);",
          "734:     }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "374c17c8fc624e4110e421bf280a793a5111bb6f",
      "candidate_info": {
        "commit_hash": "374c17c8fc624e4110e421bf280a793a5111bb6f",
        "repo": "FFmpeg/FFmpeg",
        "commit_url": "https://github.com/FFmpeg/FFmpeg/commit/374c17c8fc624e4110e421bf280a793a5111bb6f",
        "files": [
          "libavcodec/vp56.c"
        ],
        "message": "lavc/vp56: Re-indent functions affected by threading refactor\n\nAll whitespace plus a curly brace.\n\nSigned-off-by: Ben Jackson <ben@ben.com>\nSigned-off-by: Michael Niedermayer <michaelni@gmx.at>",
        "before_after_code_files": [
          "libavcodec/vp56.c||libavcodec/vp56.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "libavcodec/vp56.c||libavcodec/vp56.c"
          ],
          "candidate": [
            "libavcodec/vp56.c||libavcodec/vp56.c"
          ]
        }
      },
      "candidate_diff": {
        "libavcodec/vp56.c||libavcodec/vp56.c": [
          "File: libavcodec/vp56.c -> libavcodec/vp56.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "522:             return -1;",
          "523:     }",
          "534:         }",
          "548:     if (s->has_alpha) {",
          "549:         buf += alpha_offset;",
          "",
          "[Removed Lines]",
          "525:         res = s->parse_header(s, buf, remaining_buf_size);",
          "526:         if (!res)",
          "527:             return -1;",
          "529:         if (res == 2) {",
          "530:             for (i = 0; i < 4; i++) {",
          "531:                 if (s->frames[i].data[0])",
          "532:                     avctx->release_buffer(avctx, &s->frames[i]);",
          "533:             }",
          "536:             p->reference = 3;",
          "537:             if (avctx->get_buffer(avctx, p) < 0) {",
          "538:                 av_log(avctx, AV_LOG_ERROR, \"get_buffer() failed\\n\");",
          "539:                 return -1;",
          "540:             }",
          "542:             if (res == 2)",
          "543:                 if (vp56_size_changed(s)) {",
          "544:                     avctx->release_buffer(avctx, p);",
          "545:                     return -1;",
          "546:                 }",
          "",
          "[Added Lines]",
          "525:     res = s->parse_header(s, buf, remaining_buf_size);",
          "526:     if (!res)",
          "527:         return -1;",
          "529:     if (res == 2) {",
          "530:         for (i = 0; i < 4; i++) {",
          "531:             if (s->frames[i].data[0])",
          "532:                 avctx->release_buffer(avctx, &s->frames[i]);",
          "534:     }",
          "536:     p->reference = 3;",
          "537:     if (avctx->get_buffer(avctx, p) < 0) {",
          "538:         av_log(avctx, AV_LOG_ERROR, \"get_buffer() failed\\n\");",
          "539:         return -1;",
          "540:     }",
          "542:     if (res == 2) {",
          "543:         if (vp56_size_changed(s)) {",
          "544:             avctx->release_buffer(avctx, p);",
          "545:             return -1;",
          "546:         }",
          "547:     }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "588:     int mb_row, mb_col, mb_row_flip, mb_offset = 0;",
          "589:     int block, y, uv, stride_y, stride_uv;",
          "621:         if (s->flip < 0)",
          "635:             }",
          "665:             }",
          "666:         }",
          "673:     FFSWAP(AVFrame *, s->framep[VP56_FRAME_CURRENT],",
          "674:                       s->framep[VP56_FRAME_PREVIOUS]);",
          "",
          "[Removed Lines]",
          "591:         if (p->key_frame) {",
          "592:             p->pict_type = AV_PICTURE_TYPE_I;",
          "593:             s->default_models_init(s);",
          "594:             for (block=0; block<s->mb_height*s->mb_width; block++)",
          "595:                 s->macroblocks[block].type = VP56_MB_INTRA;",
          "596:         } else {",
          "597:             p->pict_type = AV_PICTURE_TYPE_P;",
          "598:             vp56_parse_mb_type_models(s);",
          "599:             s->parse_vector_models(s);",
          "600:             s->mb_type = VP56_MB_INTER_NOVEC_PF;",
          "601:         }",
          "603:         if (s->parse_coeff_models(s))",
          "604:             goto next;",
          "606:         memset(s->prev_dc, 0, sizeof(s->prev_dc));",
          "607:         s->prev_dc[1][VP56_FRAME_CURRENT] = 128;",
          "608:         s->prev_dc[2][VP56_FRAME_CURRENT] = 128;",
          "610:         for (block=0; block < 4*s->mb_width+6; block++) {",
          "611:             s->above_blocks[block].ref_frame = VP56_FRAME_NONE;",
          "612:             s->above_blocks[block].dc_coeff = 0;",
          "613:             s->above_blocks[block].not_null_dc = 0;",
          "614:         }",
          "615:         s->above_blocks[2*s->mb_width + 2].ref_frame = VP56_FRAME_CURRENT;",
          "616:         s->above_blocks[3*s->mb_width + 4].ref_frame = VP56_FRAME_CURRENT;",
          "618:         stride_y  = p->linesize[0];",
          "619:         stride_uv = p->linesize[1];",
          "622:             mb_offset = 7;",
          "625:         for (mb_row=0; mb_row<s->mb_height; mb_row++) {",
          "626:             if (s->flip < 0)",
          "627:                 mb_row_flip = s->mb_height - mb_row - 1;",
          "628:             else",
          "629:                 mb_row_flip = mb_row;",
          "631:             for (block=0; block<4; block++) {",
          "632:                 s->left_block[block].ref_frame = VP56_FRAME_NONE;",
          "633:                 s->left_block[block].dc_coeff = 0;",
          "634:                 s->left_block[block].not_null_dc = 0;",
          "636:             memset(s->coeff_ctx, 0, sizeof(s->coeff_ctx));",
          "637:             memset(s->coeff_ctx_last, 24, sizeof(s->coeff_ctx_last));",
          "639:             s->above_block_idx[0] = 1;",
          "640:             s->above_block_idx[1] = 2;",
          "641:             s->above_block_idx[2] = 1;",
          "642:             s->above_block_idx[3] = 2;",
          "643:             s->above_block_idx[4] = 2*s->mb_width + 2 + 1;",
          "644:             s->above_block_idx[5] = 3*s->mb_width + 4 + 1;",
          "646:             s->block_offset[s->frbi] = (mb_row_flip*16 + mb_offset) * stride_y;",
          "647:             s->block_offset[s->srbi] = s->block_offset[s->frbi] + 8*stride_y;",
          "648:             s->block_offset[1] = s->block_offset[0] + 8;",
          "649:             s->block_offset[3] = s->block_offset[2] + 8;",
          "650:             s->block_offset[4] = (mb_row_flip*8 + mb_offset) * stride_uv;",
          "651:             s->block_offset[5] = s->block_offset[4];",
          "653:             for (mb_col=0; mb_col<s->mb_width; mb_col++) {",
          "654:                 vp56_decode_mb(s, mb_row, mb_col, is_alpha);",
          "656:                 for (y=0; y<4; y++) {",
          "657:                     s->above_block_idx[y] += 2;",
          "658:                     s->block_offset[y] += 16;",
          "659:                 }",
          "661:                 for (uv=4; uv<6; uv++) {",
          "662:                     s->above_block_idx[uv] += 1;",
          "663:                     s->block_offset[uv] += 8;",
          "664:                 }",
          "668:     next:",
          "669:         if (p->key_frame || s->golden_frame) {",
          "670:             s->framep[VP56_FRAME_GOLDEN] = p;",
          "671:         }",
          "",
          "[Added Lines]",
          "592:     if (p->key_frame) {",
          "593:         p->pict_type = AV_PICTURE_TYPE_I;",
          "594:         s->default_models_init(s);",
          "595:         for (block=0; block<s->mb_height*s->mb_width; block++)",
          "596:             s->macroblocks[block].type = VP56_MB_INTRA;",
          "597:     } else {",
          "598:         p->pict_type = AV_PICTURE_TYPE_P;",
          "599:         vp56_parse_mb_type_models(s);",
          "600:         s->parse_vector_models(s);",
          "601:         s->mb_type = VP56_MB_INTER_NOVEC_PF;",
          "602:     }",
          "604:     if (s->parse_coeff_models(s))",
          "605:         goto next;",
          "607:     memset(s->prev_dc, 0, sizeof(s->prev_dc));",
          "608:     s->prev_dc[1][VP56_FRAME_CURRENT] = 128;",
          "609:     s->prev_dc[2][VP56_FRAME_CURRENT] = 128;",
          "611:     for (block=0; block < 4*s->mb_width+6; block++) {",
          "612:         s->above_blocks[block].ref_frame = VP56_FRAME_NONE;",
          "613:         s->above_blocks[block].dc_coeff = 0;",
          "614:         s->above_blocks[block].not_null_dc = 0;",
          "615:     }",
          "616:     s->above_blocks[2*s->mb_width + 2].ref_frame = VP56_FRAME_CURRENT;",
          "617:     s->above_blocks[3*s->mb_width + 4].ref_frame = VP56_FRAME_CURRENT;",
          "619:     stride_y  = p->linesize[0];",
          "620:     stride_uv = p->linesize[1];",
          "622:     if (s->flip < 0)",
          "623:         mb_offset = 7;",
          "626:     for (mb_row=0; mb_row<s->mb_height; mb_row++) {",
          "628:             mb_row_flip = s->mb_height - mb_row - 1;",
          "629:         else",
          "630:             mb_row_flip = mb_row;",
          "632:         for (block=0; block<4; block++) {",
          "633:             s->left_block[block].ref_frame = VP56_FRAME_NONE;",
          "634:             s->left_block[block].dc_coeff = 0;",
          "635:             s->left_block[block].not_null_dc = 0;",
          "636:         }",
          "637:         memset(s->coeff_ctx, 0, sizeof(s->coeff_ctx));",
          "638:         memset(s->coeff_ctx_last, 24, sizeof(s->coeff_ctx_last));",
          "640:         s->above_block_idx[0] = 1;",
          "641:         s->above_block_idx[1] = 2;",
          "642:         s->above_block_idx[2] = 1;",
          "643:         s->above_block_idx[3] = 2;",
          "644:         s->above_block_idx[4] = 2*s->mb_width + 2 + 1;",
          "645:         s->above_block_idx[5] = 3*s->mb_width + 4 + 1;",
          "647:         s->block_offset[s->frbi] = (mb_row_flip*16 + mb_offset) * stride_y;",
          "648:         s->block_offset[s->srbi] = s->block_offset[s->frbi] + 8*stride_y;",
          "649:         s->block_offset[1] = s->block_offset[0] + 8;",
          "650:         s->block_offset[3] = s->block_offset[2] + 8;",
          "651:         s->block_offset[4] = (mb_row_flip*8 + mb_offset) * stride_uv;",
          "652:         s->block_offset[5] = s->block_offset[4];",
          "654:         for (mb_col=0; mb_col<s->mb_width; mb_col++) {",
          "655:             vp56_decode_mb(s, mb_row, mb_col, is_alpha);",
          "657:             for (y=0; y<4; y++) {",
          "658:                 s->above_block_idx[y] += 2;",
          "659:                 s->block_offset[y] += 16;",
          "662:             for (uv=4; uv<6; uv++) {",
          "663:                 s->above_block_idx[uv] += 1;",
          "664:                 s->block_offset[uv] += 8;",
          "667:     }",
          "669: next:",
          "670:     if (p->key_frame || s->golden_frame) {",
          "671:         s->framep[VP56_FRAME_GOLDEN] = p;",
          "672:     }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "eebc11ebc8000aefc8562d17749ac2f9160fdfec",
      "candidate_info": {
        "commit_hash": "eebc11ebc8000aefc8562d17749ac2f9160fdfec",
        "repo": "FFmpeg/FFmpeg",
        "commit_url": "https://github.com/FFmpeg/FFmpeg/commit/eebc11ebc8000aefc8562d17749ac2f9160fdfec",
        "files": [
          "libavcodec/vp5.c",
          "libavcodec/vp56.c",
          "libavcodec/vp56.h",
          "libavcodec/vp6.c"
        ],
        "message": "lavc/vp56: Move golden_frame into VP56Context\n\nMakes golden_frame more like other frame data, paves way for threading\nalpha channel decode.\n\nSigned-off-by: Ben Jackson <ben@ben.com>\nSigned-off-by: Michael Niedermayer <michaelni@gmx.at>",
        "before_after_code_files": [
          "libavcodec/vp5.c||libavcodec/vp5.c",
          "libavcodec/vp56.c||libavcodec/vp56.c",
          "libavcodec/vp56.h||libavcodec/vp56.h",
          "libavcodec/vp6.c||libavcodec/vp6.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "libavcodec/vp56.c||libavcodec/vp56.c"
          ],
          "candidate": [
            "libavcodec/vp56.c||libavcodec/vp56.c"
          ]
        }
      },
      "candidate_diff": {
        "libavcodec/vp5.c||libavcodec/vp5.c": [
          "File: libavcodec/vp5.c -> libavcodec/vp5.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "35: #include \"vp5data.h\"",
          "40: {",
          "41:     VP56RangeCoder *c = &s->c;",
          "42:     int rows, cols;",
          "",
          "[Removed Lines]",
          "38: static int vp5_parse_header(VP56Context *s, const uint8_t *buf, int buf_size,",
          "39:                             int *golden_frame)",
          "",
          "[Added Lines]",
          "38: static int vp5_parse_header(VP56Context *s, const uint8_t *buf, int buf_size)",
          "",
          "---------------"
        ],
        "libavcodec/vp56.c||libavcodec/vp56.c": [
          "File: libavcodec/vp56.c -> libavcodec/vp56.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "507:     for (is_alpha=0; is_alpha < 1+s->has_alpha; is_alpha++) {",
          "508:         int mb_row, mb_col, mb_row_flip, mb_offset = 0;",
          "509:         int block, y, uv, stride_y, stride_uv;",
          "511:         int res;",
          "513:         s->modelp = &s->models[is_alpha];",
          "516:         if (!res)",
          "517:             return -1;",
          "",
          "[Removed Lines]",
          "510:         int golden_frame = 0;",
          "515:         res = s->parse_header(s, buf, remaining_buf_size, &golden_frame);",
          "",
          "[Added Lines]",
          "514:         res = s->parse_header(s, buf, remaining_buf_size);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "620:         }",
          "622:     next:",
          "624:             if (s->framep[VP56_FRAME_GOLDEN]->data[0] && s->framep[VP56_FRAME_GOLDEN] != p &&",
          "625:                 s->framep[VP56_FRAME_GOLDEN] != s->framep[VP56_FRAME_GOLDEN2])",
          "626:                 avctx->release_buffer(avctx, s->framep[VP56_FRAME_GOLDEN]);",
          "",
          "[Removed Lines]",
          "623:         if (p->key_frame || golden_frame) {",
          "",
          "[Added Lines]",
          "622:         if (p->key_frame || s->golden_frame) {",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "690:     s->macroblocks = NULL;",
          "691:     s->quantizer = -1;",
          "692:     s->deblock_filtering = 1;",
          "694:     s->filter = NULL;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "692:     s->golden_frame = 0;",
          "",
          "---------------"
        ],
        "libavcodec/vp56.h||libavcodec/vp56.h": [
          "File: libavcodec/vp56.h -> libavcodec/vp56.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "50: typedef void (*VP56ParseVectorModels)(VP56Context *s);",
          "51: typedef int  (*VP56ParseCoeffModels)(VP56Context *s);",
          "52: typedef int  (*VP56ParseHeader)(VP56Context *s, const uint8_t *buf,",
          "55: typedef struct {",
          "56:     int high;",
          "",
          "[Removed Lines]",
          "53:                                 int buf_size, int *golden_frame);",
          "",
          "[Added Lines]",
          "53:                                 int buf_size);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "105:     int sub_version;",
          "108:     int plane_width[4];",
          "109:     int plane_height[4];",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "108:     int golden_frame;",
          "",
          "---------------"
        ],
        "libavcodec/vp6.c||libavcodec/vp6.c": [
          "File: libavcodec/vp6.c -> libavcodec/vp6.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "43: static void vp6_parse_coeff(VP56Context *s);",
          "44: static void vp6_parse_coeff_huffman(VP56Context *s);",
          "48: {",
          "49:     VP56RangeCoder *c = &s->c;",
          "50:     int parse_filter_info = 0;",
          "",
          "[Removed Lines]",
          "46: static int vp6_parse_header(VP56Context *s, const uint8_t *buf, int buf_size,",
          "47:                             int *golden_frame)",
          "",
          "[Added Lines]",
          "46: static int vp6_parse_header(VP56Context *s, const uint8_t *buf, int buf_size)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "100:         if (sub_version < 8)",
          "101:             vrt_shift = 5;",
          "102:         s->sub_version = sub_version;",
          "103:     } else {",
          "104:         if (!s->sub_version || !s->avctx->coded_width || !s->avctx->coded_height)",
          "105:             return 0;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "102:         s->golden_frame = 0;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "111:         }",
          "112:         ff_vp56_init_range_decoder(c, buf+1, buf_size-1);",
          "115:         if (s->filter_header) {",
          "116:             s->deblock_filtering = vp56_rac_get(c);",
          "117:             if (s->deblock_filtering)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "114:         s->golden_frame = vp56_rac_get(c);",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2019-9003",
  "cve_desc": "In the Linux kernel before 4.20.5, attackers can trigger a drivers/char/ipmi/ipmi_msghandler.c use-after-free and OOPS by arranging for certain simultaneous execution of the code, as demonstrated by a \"service ipmievd restart\" loop.",
  "repo": "torvalds/linux",
  "patch_hash": "77f8269606bf95fcb232ee86f6da80886f1dfae8",
  "patch_info": {
    "commit_hash": "77f8269606bf95fcb232ee86f6da80886f1dfae8",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/77f8269606bf95fcb232ee86f6da80886f1dfae8",
    "files": [
      "drivers/char/ipmi/ipmi_msghandler.c"
    ],
    "message": "ipmi: fix use-after-free of user->release_barrier.rda\n\nWhen we do the following test, we got oops in ipmi_msghandler driver\nwhile((1))\ndo\n\tservice ipmievd restart & service ipmievd restart\ndone\n\n---------------------------------------------------------------\n[  294.230186] Unable to handle kernel paging request at virtual address 0000803fea6ea008\n[  294.230188] Mem abort info:\n[  294.230190]   ESR = 0x96000004\n[  294.230191]   Exception class = DABT (current EL), IL = 32 bits\n[  294.230193]   SET = 0, FnV = 0\n[  294.230194]   EA = 0, S1PTW = 0\n[  294.230195] Data abort info:\n[  294.230196]   ISV = 0, ISS = 0x00000004\n[  294.230197]   CM = 0, WnR = 0\n[  294.230199] user pgtable: 4k pages, 48-bit VAs, pgdp = 00000000a1c1b75a\n[  294.230201] [0000803fea6ea008] pgd=0000000000000000\n[  294.230204] Internal error: Oops: 96000004 [#1] SMP\n[  294.235211] Modules linked in: nls_utf8 isofs rpcrdma ib_iser ib_srpt target_core_mod ib_srp scsi_transport_srp ib_ipoib rdma_ucm ib_umad rdma_cm ib_cm iw_cm dm_mirror dm_region_hash dm_log dm_mod aes_ce_blk crypto_simd cryptd aes_ce_cipher ghash_ce sha2_ce ses sha256_arm64 sha1_ce hibmc_drm hisi_sas_v2_hw enclosure sg hisi_sas_main sbsa_gwdt ip_tables mlx5_ib ib_uverbs marvell ib_core mlx5_core ixgbe ipmi_si mdio hns_dsaf ipmi_devintf ipmi_msghandler hns_enet_drv hns_mdio\n[  294.277745] CPU: 3 PID: 0 Comm: swapper/3 Kdump: loaded Not tainted 5.0.0-rc2+ #113\n[  294.285511] Hardware name: Huawei TaiShan 2280 /BC11SPCD, BIOS 1.37 11/21/2017\n[  294.292835] pstate: 80000005 (Nzcv daif -PAN -UAO)\n[  294.297695] pc : __srcu_read_lock+0x38/0x58\n[  294.301940] lr : acquire_ipmi_user+0x2c/0x70 [ipmi_msghandler]\n[  294.307853] sp : ffff00001001bc80\n[  294.311208] x29: ffff00001001bc80 x28: ffff0000117e5000\n[  294.316594] x27: 0000000000000000 x26: dead000000000100\n[  294.321980] x25: dead000000000200 x24: ffff803f6bd06800\n[  294.327366] x23: 0000000000000000 x22: 0000000000000000\n[  294.332752] x21: ffff00001001bd04 x20: ffff80df33d19018\n[  294.338137] x19: ffff80df33d19018 x18: 0000000000000000\n[  294.343523] x17: 0000000000000000 x16: 0000000000000000\n[  294.348908] x15: 0000000000000000 x14: 0000000000000002\n[  294.354293] x13: 0000000000000000 x12: 0000000000000000\n[  294.359679] x11: 0000000000000000 x10: 0000000000100000\n[  294.365065] x9 : 0000000000000000 x8 : 0000000000000004\n[  294.370451] x7 : 0000000000000000 x6 : ffff80df34558678\n[  294.375836] x5 : 000000000000000c x4 : 0000000000000000\n[  294.381221] x3 : 0000000000000001 x2 : 0000803fea6ea000\n[  294.386607] x1 : 0000803fea6ea008 x0 : 0000000000000001\n[  294.391994] Process swapper/3 (pid: 0, stack limit = 0x0000000083087293)\n[  294.398791] Call trace:\n[  294.401266]  __srcu_read_lock+0x38/0x58\n[  294.405154]  acquire_ipmi_user+0x2c/0x70 [ipmi_msghandler]\n[  294.410716]  deliver_response+0x80/0xf8 [ipmi_msghandler]\n[  294.416189]  deliver_local_response+0x28/0x68 [ipmi_msghandler]\n[  294.422193]  handle_one_recv_msg+0x158/0xcf8 [ipmi_msghandler]\n[  294.432050]  handle_new_recv_msgs+0xc0/0x210 [ipmi_msghandler]\n[  294.441984]  smi_recv_tasklet+0x8c/0x158 [ipmi_msghandler]\n[  294.451618]  tasklet_action_common.isra.5+0x88/0x138\n[  294.460661]  tasklet_action+0x2c/0x38\n[  294.468191]  __do_softirq+0x120/0x2f8\n[  294.475561]  irq_exit+0x134/0x140\n[  294.482445]  __handle_domain_irq+0x6c/0xc0\n[  294.489954]  gic_handle_irq+0xb8/0x178\n[  294.497037]  el1_irq+0xb0/0x140\n[  294.503381]  arch_cpu_idle+0x34/0x1a8\n[  294.510096]  do_idle+0x1d4/0x290\n[  294.516322]  cpu_startup_entry+0x28/0x30\n[  294.523230]  secondary_start_kernel+0x184/0x1d0\n[  294.530657] Code: d538d082 d2800023 8b010c81 8b020021 (c85f7c25)\n[  294.539746] ---[ end trace 8a7a880dee570b29 ]---\n[  294.547341] Kernel panic - not syncing: Fatal exception in interrupt\n[  294.556837] SMP: stopping secondary CPUs\n[  294.563996] Kernel Offset: disabled\n[  294.570515] CPU features: 0x002,21006008\n[  294.577638] Memory Limit: none\n[  294.587178] Starting crashdump kernel...\n[  294.594314] Bye!\n\nBecause the user->release_barrier.rda is freed in ipmi_destroy_user(), but\nthe refcount is not zero, when acquire_ipmi_user() uses user->release_barrier.rda\nin __srcu_read_lock(), it causes oops.\nFix this by calling cleanup_srcu_struct() when the refcount is zero.\n\nFixes: e86ee2d44b44 (\"ipmi: Rework locking and shutdown for hot remove\")\nCc: stable@vger.kernel.org # 4.18\nSigned-off-by: Yang Yingliang <yangyingliang@huawei.com>\n\nSigned-off-by: Corey Minyard <cminyard@mvista.com>",
    "before_after_code_files": [
      "drivers/char/ipmi/ipmi_msghandler.c||drivers/char/ipmi/ipmi_msghandler.c"
    ]
  },
  "patch_diff": {
    "drivers/char/ipmi/ipmi_msghandler.c||drivers/char/ipmi/ipmi_msghandler.c": [
      "File: drivers/char/ipmi/ipmi_msghandler.c -> drivers/char/ipmi/ipmi_msghandler.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "1184: static void free_user(struct kref *ref)",
      "1185: {",
      "1186:  struct ipmi_user *user = container_of(ref, struct ipmi_user, refcount);",
      "1187:  kfree(user);",
      "1188: }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1187:  cleanup_srcu_struct(&user->release_barrier);",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "1260: {",
      "1261:  _ipmi_destroy_user(user);",
      "1264:  kref_put(&user->refcount, free_user);",
      "1266:  return 0;",
      "",
      "[Removed Lines]",
      "1263:  cleanup_srcu_struct(&user->release_barrier);",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "e40e2a2e78664fa90ea4b9bdf4a84efce2fea9d9",
      "candidate_info": {
        "commit_hash": "e40e2a2e78664fa90ea4b9bdf4a84efce2fea9d9",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/e40e2a2e78664fa90ea4b9bdf4a84efce2fea9d9",
        "files": [
          "drivers/net/phy/mdio_bus.c"
        ],
        "message": "net: phy: mdio_bus: add missing device_del() in mdiobus_register() error handling\n\nThe current code in __mdiobus_register() doesn't properly handle\nfailures returned by the devm_gpiod_get_optional() call: it returns\nimmediately, without unregistering the device that was added by the\ncall to device_register() earlier in the function.\n\nThis leaves a stale device, which then causes a NULL pointer\ndereference in the code that handles deferred probing:\n\n[    1.489982] Unable to handle kernel NULL pointer dereference at virtual address 00000074\n[    1.498110] pgd = (ptrval)\n[    1.500838] [00000074] *pgd=00000000\n[    1.504432] Internal error: Oops: 17 [#1] SMP ARM\n[    1.509133] Modules linked in:\n[    1.512192] CPU: 1 PID: 51 Comm: kworker/1:3 Not tainted 4.20.0-00039-g3b73a4cc8b3e-dirty #99\n[    1.520708] Hardware name: Xilinx Zynq Platform\n[    1.525261] Workqueue: events deferred_probe_work_func\n[    1.530403] PC is at klist_next+0x10/0xfc\n[    1.534403] LR is at device_for_each_child+0x40/0x94\n[    1.539361] pc : [<c0683fbc>]    lr : [<c0455d90>]    psr: 200e0013\n[    1.545628] sp : ceeefe68  ip : 00000001  fp : ffffe000\n[    1.550863] r10: 00000000  r9 : c0c66790  r8 : 00000000\n[    1.556079] r7 : c0457d44  r6 : 00000000  r5 : ceeefe8c  r4 : cfa2ec78\n[    1.562604] r3 : 00000064  r2 : c0457d44  r1 : ceeefe8c  r0 : 00000064\n[    1.569129] Flags: nzCv  IRQs on  FIQs on  Mode SVC_32  ISA ARM  Segment none\n[    1.576263] Control: 18c5387d  Table: 0ed7804a  DAC: 00000051\n[    1.582013] Process kworker/1:3 (pid: 51, stack limit = 0x(ptrval))\n[    1.588280] Stack: (0xceeefe68 to 0xceef0000)\n[    1.592630] fe60:                   cfa2ec78 c0c03c08 00000000 c0457d44 00000000 c0c66790\n[    1.600814] fe80: 00000000 c0455d90 ceeefeac 00000064 00000000 0d7a542e cee9d494 cfa2ec78\n[    1.608998] fea0: cfa2ec78 00000000 c0457d44 c0457d7c cee9d494 c0c03c08 00000000 c0455dac\n[    1.617182] fec0: cf98ba44 cf926a00 cee9d494 0d7a542e 00000000 cf935a10 cf935a10 cf935a10\n[    1.625366] fee0: c0c4e9b8 c0457d7c c0c4e80c 00000001 cf935a10 c0457df4 cf935a10 c0c4e99c\n[    1.633550] ff00: c0c4e99c c045a27c c0c4e9c4 ced63f80 cfde8a80 cfdebc00 00000000 c013893c\n[    1.641734] ff20: cfde8a80 cfde8a80 c07bd354 ced63f80 ced63f94 cfde8a80 00000008 c0c02d00\n[    1.649936] ff40: cfde8a98 cfde8a80 ffffe000 c0139a30 ffffe000 c0c6624a c07bd354 00000000\n[    1.658120] ff60: ffffe000 cee9e780 ceebfe00 00000000 ceeee000 ced63f80 c0139788 cf8cdea4\n[    1.666304] ff80: cee9e79c c013e598 00000001 ceebfe00 c013e44c 00000000 00000000 00000000\n[    1.674488] ffa0: 00000000 00000000 00000000 c01010e8 00000000 00000000 00000000 00000000\n[    1.682671] ffc0: 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000\n[    1.690855] ffe0: 00000000 00000000 00000000 00000000 00000013 00000000 00000000 00000000\n[    1.699058] [<c0683fbc>] (klist_next) from [<c0455d90>] (device_for_each_child+0x40/0x94)\n[    1.707241] [<c0455d90>] (device_for_each_child) from [<c0457d7c>] (device_reorder_to_tail+0x38/0x88)\n[    1.716476] [<c0457d7c>] (device_reorder_to_tail) from [<c0455dac>] (device_for_each_child+0x5c/0x94)\n[    1.725692] [<c0455dac>] (device_for_each_child) from [<c0457d7c>] (device_reorder_to_tail+0x38/0x88)\n[    1.734927] [<c0457d7c>] (device_reorder_to_tail) from [<c0457df4>] (device_pm_move_to_tail+0x28/0x40)\n[    1.744235] [<c0457df4>] (device_pm_move_to_tail) from [<c045a27c>] (deferred_probe_work_func+0x58/0x8c)\n[    1.753746] [<c045a27c>] (deferred_probe_work_func) from [<c013893c>] (process_one_work+0x210/0x4fc)\n[    1.762888] [<c013893c>] (process_one_work) from [<c0139a30>] (worker_thread+0x2a8/0x5c0)\n[    1.771072] [<c0139a30>] (worker_thread) from [<c013e598>] (kthread+0x14c/0x154)\n[    1.778482] [<c013e598>] (kthread) from [<c01010e8>] (ret_from_fork+0x14/0x2c)\n[    1.785689] Exception stack(0xceeeffb0 to 0xceeefff8)\n[    1.790739] ffa0:                                     00000000 00000000 00000000 00000000\n[    1.798923] ffc0: 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000\n[    1.807107] ffe0: 00000000 00000000 00000000 00000000 00000013 00000000\n[    1.813724] Code: e92d47f0 e1a05000 e8900048 e1a00003 (e5937010)\n[    1.819844] ---[ end trace 3c2c0c8b65399ec9 ]---\n\nThe actual error that we had from devm_gpiod_get_optional() was\n-EPROBE_DEFER, due to the GPIO being provided by a driver that is\nprobed later than the Ethernet controller driver.\n\nTo fix this, we simply add the missing device_del() invocation in the\nerror path.\n\nFixes: 69226896ad636 (\"mdio_bus: Issue GPIO RESET to PHYs\")\nSigned-off-by: Thomas Petazzoni <thomas.petazzoni@bootlin.com>\nReviewed-by: Andrew Lunn <andrew@lunn.ch>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "before_after_code_files": [
          "drivers/net/phy/mdio_bus.c||drivers/net/phy/mdio_bus.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "drivers/net/phy/mdio_bus.c||drivers/net/phy/mdio_bus.c": [
          "File: drivers/net/phy/mdio_bus.c -> drivers/net/phy/mdio_bus.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "390:  if (IS_ERR(gpiod)) {",
          "391:   dev_err(&bus->dev, \"mii_bus %s couldn't get reset GPIO\\n\",",
          "392:    bus->id);",
          "393:   return PTR_ERR(gpiod);",
          "394:  } else if (gpiod) {",
          "395:   bus->reset_gpiod = gpiod;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "393:   device_del(&bus->dev);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "3b9a907223d7f6b9d1dadea29436842ae9bcd76d",
      "candidate_info": {
        "commit_hash": "3b9a907223d7f6b9d1dadea29436842ae9bcd76d",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/3b9a907223d7f6b9d1dadea29436842ae9bcd76d",
        "files": [
          "drivers/char/ipmi/ipmi_msghandler.c"
        ],
        "message": "ipmi: fix sleep-in-atomic in free_user at cleanup SRCU user->release_barrier\n\nfree_user() could be called in atomic context.\n\nThis patch pushed the free operation off into a workqueue.\n\nExample:\n\n BUG: sleeping function called from invalid context at kernel/workqueue.c:2856\n in_atomic(): 1, irqs_disabled(): 0, pid: 177, name: ksoftirqd/27\n CPU: 27 PID: 177 Comm: ksoftirqd/27 Not tainted 4.19.25-3 #1\n Hardware name: AIC 1S-HV26-08/MB-DPSB04-06, BIOS IVYBV060 10/21/2015\n Call Trace:\n  dump_stack+0x5c/0x7b\n  ___might_sleep+0xec/0x110\n  __flush_work+0x48/0x1f0\n  ? try_to_del_timer_sync+0x4d/0x80\n  _cleanup_srcu_struct+0x104/0x140\n  free_user+0x18/0x30 [ipmi_msghandler]\n  ipmi_free_recv_msg+0x3a/0x50 [ipmi_msghandler]\n  deliver_response+0xbd/0xd0 [ipmi_msghandler]\n  deliver_local_response+0xe/0x30 [ipmi_msghandler]\n  handle_one_recv_msg+0x163/0xc80 [ipmi_msghandler]\n  ? dequeue_entity+0xa0/0x960\n  handle_new_recv_msgs+0x15c/0x1f0 [ipmi_msghandler]\n  tasklet_action_common.isra.22+0x103/0x120\n  __do_softirq+0xf8/0x2d7\n  run_ksoftirqd+0x26/0x50\n  smpboot_thread_fn+0x11d/0x1e0\n  kthread+0x103/0x140\n  ? sort_range+0x20/0x20\n  ? kthread_destroy_worker+0x40/0x40\n  ret_from_fork+0x1f/0x40\n\nFixes: 77f8269606bf (\"ipmi: fix use-after-free of user->release_barrier.rda\")\n\nReported-by: Konstantin Khlebnikov <khlebnikov@yandex-team.ru>\nSigned-off-by: Corey Minyard <cminyard@mvista.com>\nCc: stable@vger.kernel.org # 5.0\nCc: Yang Yingliang <yangyingliang@huawei.com>",
        "before_after_code_files": [
          "drivers/char/ipmi/ipmi_msghandler.c||drivers/char/ipmi/ipmi_msghandler.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "drivers/char/ipmi/ipmi_msghandler.c||drivers/char/ipmi/ipmi_msghandler.c"
          ],
          "candidate": [
            "drivers/char/ipmi/ipmi_msghandler.c||drivers/char/ipmi/ipmi_msghandler.c"
          ]
        }
      },
      "candidate_diff": {
        "drivers/char/ipmi/ipmi_msghandler.c||drivers/char/ipmi/ipmi_msghandler.c": [
          "File: drivers/char/ipmi/ipmi_msghandler.c -> drivers/char/ipmi/ipmi_msghandler.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "216:  bool gets_events;",
          "217: };",
          "219: static struct ipmi_user *acquire_ipmi_user(struct ipmi_user *user, int *index)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "219:  struct work_struct remove_work;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1157:  return rv;",
          "1158: }",
          "1160: int ipmi_create_user(unsigned int          if_num,",
          "1161:        const struct ipmi_user_hndl *handler,",
          "1162:        void                  *handler_data,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1163: static void free_user_work(struct work_struct *work)",
          "1164: {",
          "1165:  struct ipmi_user *user = container_of(work, struct ipmi_user,",
          "1166:            remove_work);",
          "1168:  cleanup_srcu_struct(&user->release_barrier);",
          "1169:  kfree(user);",
          "1170: }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1200:  goto out_kfree;",
          "1202:  found:",
          "1203:  rv = init_srcu_struct(&new_user->release_barrier);",
          "1204:  if (rv)",
          "1205:   goto out_kfree;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1215:  INIT_WORK(&new_user->remove_work, free_user_work);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1260: static void free_user(struct kref *ref)",
          "1261: {",
          "1262:  struct ipmi_user *user = container_of(ref, struct ipmi_user, refcount);",
          "1265: }",
          "1267: static void _ipmi_destroy_user(struct ipmi_user *user)",
          "",
          "[Removed Lines]",
          "1263:  cleanup_srcu_struct(&user->release_barrier);",
          "1264:  kfree(user);",
          "",
          "[Added Lines]",
          "1279:  schedule_work(&user->remove_work);",
          "",
          "---------------"
        ]
      }
    }
  ]
}
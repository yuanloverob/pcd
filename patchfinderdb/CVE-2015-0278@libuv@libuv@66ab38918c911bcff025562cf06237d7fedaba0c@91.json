{
  "cve_id": "CVE-2015-0278",
  "cve_desc": "libuv before 0.10.34 does not properly drop group privileges, which allows context-dependent attackers to gain privileges via unspecified vectors.",
  "repo": "libuv/libuv",
  "patch_hash": "66ab38918c911bcff025562cf06237d7fedaba0c",
  "patch_info": {
    "commit_hash": "66ab38918c911bcff025562cf06237d7fedaba0c",
    "repo": "libuv/libuv",
    "commit_url": "https://github.com/libuv/libuv/commit/66ab38918c911bcff025562cf06237d7fedaba0c",
    "files": [
      "src/unix/process.c"
    ],
    "message": "unix: call setgoups before calling setuid/setgid\n\nPartial fix for #1093",
    "before_after_code_files": [
      "src/unix/process.c||src/unix/process.c"
    ]
  },
  "patch_diff": {
    "src/unix/process.c||src/unix/process.c": [
      "File: src/unix/process.c -> src/unix/process.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "330:     _exit(127);",
      "331:   }",
      "333:   if ((options->flags & UV_PROCESS_SETGID) && setgid(options->gid)) {",
      "334:     uv__write_int(error_fd, -errno);",
      "335:     perror(\"setgid()\");",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "333:   if (options->flags & (UV_PROCESS_SETUID | UV_PROCESS_SETGID)) {",
      "341:     SAVE_ERRNO(setgroups(0, NULL));",
      "342:   }",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "6c525df76d1e732c197f926f931cc804925392ac",
      "candidate_info": {
        "commit_hash": "6c525df76d1e732c197f926f931cc804925392ac",
        "repo": "libuv/libuv",
        "commit_url": "https://github.com/libuv/libuv/commit/6c525df76d1e732c197f926f931cc804925392ac",
        "files": [
          "test/test-list.h"
        ],
        "message": "test: set getaddrinfo_fail timeout to 10000\n\ngetaddrinfo_fail can sometimes take slightly longer than the default\ntimeout of 5000. Set its timeout to 10000 to compensate, but leave the\ntimeout of all other tests at the default.",
        "before_after_code_files": [
          "test/test-list.h||test/test-list.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/libuv/libuv/pull/41"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "test/test-list.h||test/test-list.h": [
          "File: test/test-list.h -> test/test-list.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "433:   TEST_ENTRY  (hrtime)",
          "436:   TEST_ENTRY  (getaddrinfo_basic)",
          "437:   TEST_ENTRY  (getaddrinfo_concurrent)",
          "",
          "[Removed Lines]",
          "435:   TEST_ENTRY  (getaddrinfo_fail)",
          "",
          "[Added Lines]",
          "435:   TEST_ENTRY_CUSTOM (getaddrinfo_fail, 0, 0, 10000)",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "ad78e456e9f4670f234f51c768598c04b76fce37",
      "candidate_info": {
        "commit_hash": "ad78e456e9f4670f234f51c768598c04b76fce37",
        "repo": "libuv/libuv",
        "commit_url": "https://github.com/libuv/libuv/commit/ad78e456e9f4670f234f51c768598c04b76fce37",
        "files": [
          "test/test-watcher-cross-stop.c"
        ],
        "message": "test: fix watcher_cross_stop\n\nIt's possible that recv_cb_called is bigger than the number of sockets,\nbecause if all sends succeed the recv callback is called twice: once\nwith the actual data, and another time with 0.",
        "before_after_code_files": [
          "test/test-watcher-cross-stop.c||test/test-watcher-cross-stop.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/libuv/libuv/pull/41"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "test/test-watcher-cross-stop.c||test/test-watcher-cross-stop.c": [
          "File: test/test-watcher-cross-stop.c -> test/test-watcher-cross-stop.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "91:   for (i = 0; i < ARRAY_SIZE(sockets); i++)",
          "92:     uv_close((uv_handle_t*) &sockets[i], close_cb);",
          "95:   ASSERT(ARRAY_SIZE(sockets) == send_cb_called);",
          "97:   uv_run(loop, UV_RUN_DEFAULT);",
          "",
          "[Removed Lines]",
          "94:   ASSERT(0 < recv_cb_called && recv_cb_called <= ARRAY_SIZE(sockets));",
          "",
          "[Added Lines]",
          "94:   ASSERT(recv_cb_called > 0);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "6941cab549201c0cfca566ed1b2335c3004fcc4d",
      "candidate_info": {
        "commit_hash": "6941cab549201c0cfca566ed1b2335c3004fcc4d",
        "repo": "libuv/libuv",
        "commit_url": "https://github.com/libuv/libuv/commit/6941cab549201c0cfca566ed1b2335c3004fcc4d",
        "files": [
          "Makefile.am",
          "src/win/udp.c",
          "test/test-list.h",
          "test/test-udp-send-unreachable.c",
          "uv.gyp"
        ],
        "message": "windows: fix buffer leak after failed udp send\n\nFixes #1426\n\nSigned-off-by: Sa\u00fal Ibarra Corretg\u00e9 <saghul@gmail.com>",
        "before_after_code_files": [
          "Makefile.am||Makefile.am",
          "src/win/udp.c||src/win/udp.c",
          "test/test-list.h||test/test-list.h",
          "test/test-udp-send-unreachable.c||test/test-udp-send-unreachable.c",
          "uv.gyp||uv.gyp"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/libuv/libuv/pull/41"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "Makefile.am||Makefile.am": [
          "File: Makefile.am -> Makefile.am",
          "--- Hunk 1 ---",
          "[Context before]",
          "221:                          test/test-udp-options.c \\",
          "222:                          test/test-udp-send-and-recv.c \\",
          "223:                          test/test-udp-send-immediate.c \\",
          "224:                          test/test-udp-try-send.c \\",
          "225:                          test/test-walk-handles.c \\",
          "226:                          test/test-watcher-cross-stop.c",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "224:                          test/test-udp-send-unreachable.c \\",
          "",
          "---------------"
        ],
        "src/win/udp.c||src/win/udp.c": [
          "File: src/win/udp.c -> src/win/udp.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "506:       } else if (err == WSAEWOULDBLOCK) {",
          "508:         handle->recv_cb(handle, 0, &buf, NULL, 0);",
          "512:         uv_udp_recv_stop(handle);",
          "513:         handle->recv_cb(handle, uv_translate_sys_error(err), &buf, NULL, 0);",
          "514:       }",
          "",
          "[Removed Lines]",
          "509:       } else if (err != WSAECONNRESET && err != WSAENETRESET) {",
          "",
          "[Added Lines]",
          "509:       } else if (err == WSAECONNRESET || err == WSAENETRESET) {",
          "513:         handle->recv_cb(handle, 0, &buf, NULL, 0);",
          "514:       } else {",
          "",
          "---------------"
        ],
        "test/test-list.h||test/test-list.h": [
          "File: test/test-list.h -> test/test-list.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "92: TEST_DECLARE   (udp_bind_reuseaddr)",
          "93: TEST_DECLARE   (udp_send_and_recv)",
          "94: TEST_DECLARE   (udp_send_immediate)",
          "95: TEST_DECLARE   (udp_multicast_join)",
          "96: TEST_DECLARE   (udp_multicast_join6)",
          "97: TEST_DECLARE   (udp_multicast_ttl)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "95: TEST_DECLARE   (udp_send_unreachable)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "397:   TEST_ENTRY  (udp_bind_reuseaddr)",
          "398:   TEST_ENTRY  (udp_send_and_recv)",
          "399:   TEST_ENTRY  (udp_send_immediate)",
          "400:   TEST_ENTRY  (udp_dgram_too_big)",
          "401:   TEST_ENTRY  (udp_dual_stack)",
          "402:   TEST_ENTRY  (udp_ipv6_only)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "401:   TEST_ENTRY  (udp_send_unreachable)",
          "",
          "---------------"
        ],
        "test/test-udp-send-unreachable.c||test/test-udp-send-unreachable.c": [
          "File: test/test-udp-send-unreachable.c -> test/test-udp-send-unreachable.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "22: #include \"uv.h\"",
          "23: #include \"task.h\"",
          "25: #include <stdio.h>",
          "26: #include <stdlib.h>",
          "27: #include <string.h>",
          "29: #define CHECK_HANDLE(handle) \\",
          "30:   ASSERT((uv_udp_t*)(handle) == &client)",
          "32: static uv_udp_t client;",
          "33: static uv_timer_t timer;",
          "35: static int send_cb_called;",
          "36: static int recv_cb_called;",
          "37: static int close_cb_called;",
          "38: static int alloc_cb_called;",
          "39: static int timer_cb_called;",
          "42: static void alloc_cb(uv_handle_t* handle,",
          "43:                      size_t suggested_size,",
          "44:                      uv_buf_t* buf) {",
          "45:   static char slab[65536];",
          "46:   CHECK_HANDLE(handle);",
          "47:   ASSERT(suggested_size <= sizeof(slab));",
          "48:   buf->base = slab;",
          "49:   buf->len = sizeof(slab);",
          "50:   alloc_cb_called++;",
          "51: }",
          "54: static void close_cb(uv_handle_t* handle) {",
          "55:   ASSERT(1 == uv_is_closing(handle));",
          "56:   close_cb_called++;",
          "57: }",
          "60: static void send_cb(uv_udp_send_t* req, int status) {",
          "61:   ASSERT(req != NULL);",
          "62:   ASSERT(status == 0);",
          "63:   CHECK_HANDLE(req->handle);",
          "64:   send_cb_called++;",
          "65: }",
          "68: static void recv_cb(uv_udp_t* handle,",
          "69:                        ssize_t nread,",
          "70:                        const uv_buf_t* rcvbuf,",
          "71:                        const struct sockaddr* addr,",
          "72:                        unsigned flags) {",
          "73:   CHECK_HANDLE(handle);",
          "74:   recv_cb_called++;",
          "76:   if (nread < 0) {",
          "77:     ASSERT(0 && \"unexpected error\");",
          "78:   } else if (nread == 0) {",
          "80:     ASSERT(addr == NULL);",
          "81:   } else {",
          "82:     ASSERT(addr != NULL);",
          "83:   }",
          "84: }",
          "87: static void timer_cb(uv_timer_t* h) {",
          "88:   ASSERT(h == &timer);",
          "89:   timer_cb_called++;",
          "90:   uv_close((uv_handle_t*) &client, close_cb);",
          "91:   uv_close((uv_handle_t*) h, close_cb);",
          "92: }",
          "95: TEST_IMPL(udp_send_unreachable) {",
          "96:   struct sockaddr_in addr;",
          "97:   struct sockaddr_in addr2;",
          "98:   uv_udp_send_t req1, req2;",
          "99:   uv_buf_t buf;",
          "100:   int r;",
          "102:   ASSERT(0 == uv_ip4_addr(\"127.0.0.1\", TEST_PORT, &addr));",
          "103:   ASSERT(0 == uv_ip4_addr(\"127.0.0.1\", TEST_PORT_2, &addr2));",
          "105:   r = uv_timer_init( uv_default_loop(), &timer );",
          "106:   ASSERT(r == 0);",
          "108:   r = uv_timer_start( &timer, timer_cb, 1000, 0 );",
          "109:   ASSERT(r == 0);",
          "111:   r = uv_udp_init(uv_default_loop(), &client);",
          "112:   ASSERT(r == 0);",
          "114:   r = uv_udp_bind(&client, (const struct sockaddr*) &addr2, 0);",
          "115:   ASSERT(r == 0);",
          "117:   r = uv_udp_recv_start(&client, alloc_cb, recv_cb);",
          "118:   ASSERT(r == 0);",
          "121:   buf = uv_buf_init(\"PING\", 4);",
          "123:   r = uv_udp_send(&req1,",
          "124:                   &client,",
          "125:                   &buf,",
          "126:                   1,",
          "127:                   (const struct sockaddr*) &addr,",
          "128:                   send_cb);",
          "129:   ASSERT(r == 0);",
          "131:   buf = uv_buf_init(\"PANG\", 4);",
          "133:   r = uv_udp_send(&req2,",
          "134:                   &client,",
          "135:                   &buf,",
          "136:                   1,",
          "137:                   (const struct sockaddr*) &addr,",
          "138:                   send_cb);",
          "139:   ASSERT(r == 0);",
          "141:   uv_run(uv_default_loop(), UV_RUN_DEFAULT);",
          "143:   ASSERT(send_cb_called == 2);",
          "144:   ASSERT(recv_cb_called == alloc_cb_called);",
          "145:   ASSERT(timer_cb_called == 1);",
          "146:   ASSERT(close_cb_called == 2);",
          "148:   MAKE_VALGRIND_HAPPY();",
          "149:   return 0;",
          "150: }",
          "",
          "---------------"
        ],
        "uv.gyp||uv.gyp": [
          "File: uv.gyp -> uv.gyp",
          "--- Hunk 1 ---",
          "[Context before]",
          "399:         'test/test-udp-options.c',",
          "400:         'test/test-udp-send-and-recv.c',",
          "401:         'test/test-udp-send-immediate.c',",
          "402:         'test/test-udp-multicast-join.c',",
          "403:         'test/test-udp-multicast-join6.c',",
          "404:         'test/test-dlerror.c',",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "402:         'test/test-udp-send-unreachable.c',",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "08aeaf61935060e01f15cc1df2c9f09e892b0980",
      "candidate_info": {
        "commit_hash": "08aeaf61935060e01f15cc1df2c9f09e892b0980",
        "repo": "libuv/libuv",
        "commit_url": "https://github.com/libuv/libuv/commit/08aeaf61935060e01f15cc1df2c9f09e892b0980",
        "files": [
          "include/uv-unix.h",
          "include/uv.h",
          "src/unix/stream.c"
        ],
        "message": "pipe: allow queueing pending handles\n\nIf multiple handles arrive to the IPC pipe at the same time (happens on\nsome platforms), libuv will queue them internally, and call `read2_cb`\nmultiple times with a null-buffer and proper `handle_type`.",
        "before_after_code_files": [
          "include/uv-unix.h||include/uv-unix.h",
          "include/uv.h||include/uv.h",
          "src/unix/stream.c||src/unix/stream.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/libuv/libuv/pull/41"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "include/uv-unix.h||include/uv-unix.h": [
          "File: include/uv-unix.h -> include/uv-unix.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "229:   uv_connection_cb connection_cb;                                             \\",
          "230:   int delayed_error;                                                          \\",
          "231:   int accepted_fd;                                                            \\",
          "232:   UV_STREAM_PRIVATE_PLATFORM_FIELDS                                           \\",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "232:   int* queued_fds;                                                            \\",
          "",
          "---------------"
        ],
        "include/uv.h||include/uv.h": [
          "File: include/uv.h -> include/uv.h"
        ],
        "src/unix/stream.c||src/unix/stream.c": [
          "File: src/unix/stream.c -> src/unix/stream.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "119:   stream->connect_req = NULL;",
          "120:   stream->shutdown_req = NULL;",
          "121:   stream->accepted_fd = -1;",
          "122:   stream->delayed_error = 0;",
          "123:   QUEUE_INIT(&stream->write_queue);",
          "124:   QUEUE_INIT(&stream->write_completed_queue);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "122:   stream->queued_fds = NULL;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "559:   if (server->accepted_fd == -1)",
          "560:     return -EAGAIN;",
          "562:   switch (client->type) {",
          "563:     case UV_NAMED_PIPE:",
          "564:     case UV_TCP:",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "563:   err = 0;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "568:       if (err) {",
          "570:         uv__close(server->accepted_fd);",
          "573:       }",
          "574:       break;",
          "",
          "[Removed Lines]",
          "571:         server->accepted_fd = -1;",
          "572:         return err;",
          "",
          "[Added Lines]",
          "573:         goto done;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "577:       err = uv_udp_open((uv_udp_t*) client, server->accepted_fd);",
          "578:       if (err) {",
          "579:         uv__close(server->accepted_fd);",
          "582:       }",
          "583:       break;",
          "",
          "[Removed Lines]",
          "580:         server->accepted_fd = -1;",
          "581:         return err;",
          "",
          "[Added Lines]",
          "581:         goto done;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "586:       assert(0);",
          "587:   }",
          "592: }",
          "",
          "[Removed Lines]",
          "589:   uv__io_start(server->loop, &server->io_watcher, UV__POLLIN);",
          "590:   server->accepted_fd = -1;",
          "591:   return 0;",
          "",
          "[Added Lines]",
          "589: done:",
          "591:   if (server->queued_fds != NULL) {",
          "593:     server->accepted_fd = server->queued_fds[2];",
          "596:     if (--server->queued_fds[0] == 0) {",
          "597:       free(server->queued_fds);",
          "598:       server->queued_fds = NULL;",
          "599:     } else {",
          "601:       memmove(server->queued_fds + 2,",
          "602:               server->queued_fds + 3,",
          "603:               server->queued_fds[0]);",
          "604:     }",
          "607:     uv__io_feed(server->loop, &server->io_watcher);",
          "608:   } else {",
          "609:     server->accepted_fd = -1;",
          "610:     if (err == 0)",
          "611:       uv__io_start(server->loop, &server->io_watcher, UV__POLLIN);",
          "612:   }",
          "613:   return err;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "951: }",
          "954: static void uv__read(uv_stream_t* stream) {",
          "955:   uv_buf_t buf;",
          "956:   ssize_t nread;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "976: static int uv__stream_queue_fd(uv_stream_t* stream, int fd) {",
          "977:   int queue_offset;",
          "978:   int queue_len;",
          "980:   if (stream->queued_fds == NULL) {",
          "981:     queue_offset = 0;",
          "982:     queue_len = 8;",
          "983:     stream->queued_fds = malloc((queue_len + 2) * sizeof(*stream->queued_fds));",
          "984:     if (stream->queued_fds == NULL)",
          "985:       return UV_ENOMEM;",
          "986:     stream->queued_fds[1] = queue_len;",
          "987:   } else {",
          "988:     queue_offset = stream->queued_fds[0];",
          "989:     queue_len = stream->queued_fds[1];",
          "992:     if (queue_offset == queue_len) {",
          "993:       queue_len += 8;",
          "994:       stream->queued_fds = realloc(stream->queued_fds,",
          "995:                                    (queue_len + 2) *",
          "996:                                        sizeof(*stream->queued_fds));",
          "997:       if (stream->queued_fds == NULL)",
          "998:         return UV_ENOMEM;",
          "999:       stream->queued_fds[1] = queue_len;",
          "1000:     }",
          "1001:   }",
          "1004:   stream->queued_fds[0] = queue_offset;",
          "1005:   stream->queued_fds[2 + queue_offset++] = fd;",
          "1007:   return 0;",
          "1008: }",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "958:   struct cmsghdr* cmsg;",
          "959:   char cmsg_space[64];",
          "960:   int count;",
          "962:   stream->flags &= ~UV_STREAM_READ_PARTIAL;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1018:   int err;",
          "1021:   if (stream->accepted_fd != -1) {",
          "1022:     static uv_buf_t buf = { NULL, 0 };",
          "1023:     stream->read2_cb((uv_pipe_t*) stream,",
          "1024:                      0,",
          "1025:                      &buf,",
          "1026:                      uv__handle_type(stream->accepted_fd));",
          "1027:   }",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "1046:              cmsg = CMSG_NXTHDR(&msg, cmsg)) {",
          "1048:           if (cmsg->cmsg_type == SCM_RIGHTS) {",
          "1057:               stream->accepted_fd = *pi;",
          "1058:             }",
          "1060:           } else {",
          "1061:             fprintf(stderr, \"ignoring non-SCM_RIGHTS ancillary data: %d\\n\",",
          "1062:                 cmsg->cmsg_type);",
          "",
          "[Removed Lines]",
          "1049:             if (stream->accepted_fd != -1) {",
          "1050:               fprintf(stderr, \"(libuv) ignoring extra FD received\\n\");",
          "1051:             }",
          "1054:             {",
          "1055:               void* pv = CMSG_DATA(cmsg);",
          "1056:               int* pi = pv;",
          "",
          "[Added Lines]",
          "1117:             void* pv = CMSG_DATA(cmsg);",
          "1118:             int* pi = pv;",
          "1121:             if (stream->accepted_fd != -1) {",
          "1122:               err = uv__stream_queue_fd(stream, *pi);",
          "1123:               if (err != 0) {",
          "1124:                 uv__stream_read_cb(stream, err, NULL, UV_UNKNOWN_HANDLE);",
          "1125:                 return;",
          "1126:               }",
          "1127:             } else {",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "1493:     handle->accepted_fd = -1;",
          "1494:   }",
          "1496:   assert(!uv__io_active(&handle->io_watcher, UV__POLLIN | UV__POLLOUT));",
          "1497: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1566:   free(handle->queued_fds);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "deff0e357121247062a418a27332f1060a0d191a",
      "candidate_info": {
        "commit_hash": "deff0e357121247062a418a27332f1060a0d191a",
        "repo": "libuv/libuv",
        "commit_url": "https://github.com/libuv/libuv/commit/deff0e357121247062a418a27332f1060a0d191a",
        "files": [
          "test/test-spawn.c"
        ],
        "message": "test: Close process handles when spawn fails\n\nThis should avoid assertions tripping in debug mode.",
        "before_after_code_files": [
          "test/test-spawn.c||test/test-spawn.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/libuv/libuv/pull/41"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "test/test-spawn.c||test/test-spawn.c": [
          "File: test/test-spawn.c -> test/test-spawn.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "171:   r = uv_spawn(uv_default_loop(), &process, &options);",
          "172:   ASSERT(r == UV_ENOENT || r == UV_EACCES);",
          "173:   ASSERT(0 == uv_is_active((uv_handle_t*) &process));",
          "174:   ASSERT(0 == uv_run(uv_default_loop(), UV_RUN_DEFAULT));",
          "176:   MAKE_VALGRIND_HAPPY();",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "174:   uv_close((uv_handle_t*) &process, NULL);",
          "",
          "---------------"
        ]
      }
    }
  ]
}
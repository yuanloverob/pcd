{
  "cve_id": "CVE-2019-15900",
  "cve_desc": "An issue was discovered in slicer69 doas before 6.2 on certain platforms other than OpenBSD. On platforms without strtonum(3), sscanf was used without checking for error cases. Instead, the uninitialized variable errstr was checked and in some cases returned success even if sscanf failed. The result was that, instead of reporting that the supplied username or group name did not exist, it would execute the command as root.",
  "repo": "slicer69/doas",
  "patch_hash": "2f83222829448e5bc4c9391d607ec265a1e06531",
  "patch_info": {
    "commit_hash": "2f83222829448e5bc4c9391d607ec265a1e06531",
    "repo": "slicer69/doas",
    "commit_url": "https://github.com/slicer69/doas/commit/2f83222829448e5bc4c9391d607ec265a1e06531",
    "files": [
      "Makefile",
      "doas.c"
    ],
    "message": "Added optimization to Makefile (can be set/overruled using OPT). Added flag to display all warnings during compiling. Added status checks when parsing user/group IDs for Linux. Make sure Linux drops original user's groups when running as another user.",
    "before_after_code_files": [
      "doas.c||doas.c"
    ]
  },
  "patch_diff": {
    "doas.c||doas.c": [
      "File: doas.c -> doas.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "85: parseuid(const char *s, uid_t *uid)",
      "86: {",
      "87:  struct passwd *pw;",
      "90:  if ((pw = getpwnam(s)) != NULL) {",
      "",
      "[Removed Lines]",
      "88:  const char *errstr;",
      "",
      "[Added Lines]",
      "88:  #if !defined(__linux__) && !defined(__NetBSD__)",
      "89:  const char *errstr = NULL;",
      "90:         #else",
      "91:         int status;",
      "92:         #endif",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "93:  }",
      "94:  #if !defined(__linux__) && !defined(__NetBSD__)",
      "99:  if (errstr)",
      "100:   return -1;",
      "101:  return 0;",
      "102: }",
      "",
      "[Removed Lines]",
      "96:  #else",
      "97:  sscanf(s, \"%d\", uid);",
      "98:  #endif",
      "",
      "[Added Lines]",
      "102:  #else",
      "103:  status = sscanf(s, \"%d\", uid);",
      "104:         if (status != 1)",
      "105:            return -1;",
      "106:  #endif",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "117: parsegid(const char *s, gid_t *gid)",
      "118: {",
      "119:  struct group *gr;",
      "122:  if ((gr = getgrnam(s)) != NULL) {",
      "",
      "[Removed Lines]",
      "120:  const char *errstr;",
      "",
      "[Added Lines]",
      "126:  #if !defined(__linux__) && !defined(__NetBSD__)",
      "127:  const char *errstr = NULL;",
      "128:         #else",
      "129:         int status;",
      "130:         #endif",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "125:  }",
      "126:  #if !defined(__linux__) && !defined(__NetBSD__)",
      "131:  if (errstr)",
      "132:   return -1;",
      "133:  return 0;",
      "134: }",
      "",
      "[Removed Lines]",
      "128:  #else",
      "129:  sscanf(s, \"%d\", gid);",
      "130:  #endif",
      "",
      "[Added Lines]",
      "140:  #else",
      "141:  status = sscanf(s, \"%d\", gid);",
      "142:         if (status != 1)",
      "143:             return -1;",
      "144:  #endif",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "9c53fdeb0b5d22eadc437e2cbd4cc934d4aee2e5",
      "candidate_info": {
        "commit_hash": "9c53fdeb0b5d22eadc437e2cbd4cc934d4aee2e5",
        "repo": "slicer69/doas",
        "commit_url": "https://github.com/slicer69/doas/commit/9c53fdeb0b5d22eadc437e2cbd4cc934d4aee2e5",
        "files": [
          "Makefile",
          "README.md",
          "compat/compat.h",
          "compat/errc.c",
          "compat/pm_pam_conv.c",
          "compat/pm_pam_conv.h",
          "compat/setresuid.c",
          "compat/sys/tree.h",
          "compat/verrc.c",
          "doas.c",
          "doas.h",
          "execvpe.c"
        ],
        "message": "Add support for illumos",
        "before_after_code_files": [
          "compat/compat.h||compat/compat.h",
          "compat/errc.c||compat/errc.c",
          "compat/pm_pam_conv.c||compat/pm_pam_conv.c",
          "compat/pm_pam_conv.h||compat/pm_pam_conv.h",
          "compat/setresuid.c||compat/setresuid.c",
          "compat/sys/tree.h||compat/sys/tree.h",
          "compat/verrc.c||compat/verrc.c",
          "doas.c||doas.c",
          "doas.h||doas.h",
          "execvpe.c||execvpe.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "doas.c||doas.c"
          ],
          "candidate": [
            "doas.c||doas.c"
          ]
        }
      },
      "candidate_diff": {
        "compat/compat.h||compat/compat.h": [
          "File: compat/compat.h -> compat/compat.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: #include <sys/types.h>",
          "2: #include <stdarg.h>",
          "4: void errc(int eval, int code, const char *fmt, ...);",
          "6: int setresuid(uid_t ruid, uid_t euid, uid_t suid);",
          "8: void verrc(int eval, int code, const char *fmt, va_list ap);",
          "",
          "---------------"
        ],
        "compat/errc.c||compat/errc.c": [
          "File: compat/errc.c -> compat/errc.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "31: #include <err.h>",
          "32: #include <stdarg.h>",
          "34: void",
          "35: errc(int eval, int code, const char *fmt, ...)",
          "36: {",
          "37:  va_list ap;",
          "39:  va_start(ap, fmt);",
          "40:  verrc(eval, code, fmt, ap);",
          "41:  va_end(ap);",
          "42: }",
          "",
          "---------------"
        ],
        "compat/pm_pam_conv.c||compat/pm_pam_conv.c": [
          "File: compat/pm_pam_conv.c -> compat/pm_pam_conv.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "35: #include <errno.h>",
          "36: #include <libgen.h>",
          "37: #include <malloc.h>",
          "38: #include <signal.h>",
          "39: #include <stdio.h>",
          "40: #include <stdlib.h>",
          "41: #include <strings.h>",
          "42: #include <stropts.h>",
          "43: #include <unistd.h>",
          "44: #include <termio.h>",
          "46: #include <security/pam_appl.h>",
          "51: static void",
          "52: interrupt(int x)",
          "53: {",
          "54:  ctl_c = 1;",
          "55: }",
          "65: static char *",
          "66: getinput(int noecho)",
          "67: {",
          "68:  struct termio tty;",
          "69:  unsigned short tty_flags = 0;",
          "70:  char input[PAM_MAX_RESP_SIZE + 1];",
          "71:  int c;",
          "72:  int i = 0;",
          "73:  void (*sig)(int);",
          "75:  ctl_c = 0;",
          "76:  sig = signal(SIGINT, interrupt);",
          "77:  if (noecho) {",
          "78:   (void) ioctl(fileno(stdin), TCGETA, &tty);",
          "79:   tty_flags = tty.c_lflag;",
          "80:   tty.c_lflag &= ~(ECHO | ECHOE | ECHOK | ECHONL);",
          "81:   (void) ioctl(fileno(stdin), TCSETAF, &tty);",
          "82:  }",
          "84:  flockfile(stdin);",
          "85:  while (ctl_c == 0 &&",
          "86:      (c = getchar_unlocked()) != '\\n' &&",
          "87:      c != '\\r' &&",
          "88:      c != EOF) {",
          "89:   if (i < PAM_MAX_RESP_SIZE) {",
          "90:    input[i++] = (char)c;",
          "91:   }",
          "92:  }",
          "93:  funlockfile(stdin);",
          "94:  input[i] = '\\0';",
          "95:  if (noecho) {",
          "96:   tty.c_lflag = tty_flags;",
          "97:   (void) ioctl(fileno(stdin), TCSETAW, &tty);",
          "98:   (void) fputc('\\n', stdout);",
          "99:  }",
          "100:  (void) signal(SIGINT, sig);",
          "101:  if (ctl_c == 1)",
          "102:   (void) kill(getpid(), SIGINT);",
          "104:  return (strdup(input));",
          "105: }",
          "111: static void",
          "112: free_resp(int num_msg, struct pam_response *pr)",
          "113: {",
          "114:  int i;",
          "115:  struct pam_response *r = pr;",
          "117:  if (pr == NULL)",
          "118:   return;",
          "120:  for (i = 0; i < num_msg; i++, r++) {",
          "122:   if (r->resp) {",
          "124:    bzero(r->resp, strlen(r->resp));",
          "125:    free(r->resp);",
          "126:    r->resp = NULL;",
          "127:   }",
          "128:  }",
          "129:  free(pr);",
          "130: }",
          "133: int",
          "134: pam_tty_conv(int num_msg, struct pam_message **mess,",
          "135:     struct pam_response **resp, void *my_data)",
          "136: {",
          "137:  struct pam_message *m = *mess;",
          "138:  struct pam_response *r = calloc(num_msg, sizeof (struct pam_response));",
          "139:  int i;",
          "141:  if (num_msg >= PAM_MAX_NUM_MSG) {",
          "142:   (void) fprintf(stderr, \"too many messages %d >= %d\\n\",",
          "143:       num_msg, PAM_MAX_NUM_MSG);",
          "144:   free(r);",
          "146:   return (PAM_CONV_ERR);",
          "147:  }",
          "151:  for (i = 0; i < num_msg; i++) {",
          "152:   int echo_off;",
          "155:   if (m->msg == NULL) {",
          "156:    (void) fprintf(stderr, \"message[%d]: %d/NULL\\n\",",
          "157:        i, m->msg_style);",
          "158:    goto err;",
          "159:   }",
          "166:   if (m->msg[strlen(m->msg)] == '\\n')",
          "167:    m->msg[strlen(m->msg)] = '\\0';",
          "169:   r->resp = NULL;",
          "170:   r->resp_retcode = 0;",
          "171:   echo_off = 0;",
          "172:   switch (m->msg_style) {",
          "174:   case PAM_PROMPT_ECHO_OFF:",
          "175:    echo_off = 1;",
          "178:   case PAM_PROMPT_ECHO_ON:",
          "179:    (void) fputs(m->msg, stdout);",
          "181:    r->resp = getinput(echo_off);",
          "182:    break;",
          "184:   case PAM_ERROR_MSG:",
          "185:    (void) fputs(m->msg, stderr);",
          "186:    (void) fputc('\\n', stderr);",
          "187:    break;",
          "189:   case PAM_TEXT_INFO:",
          "190:    (void) fputs(m->msg, stdout);",
          "191:    (void) fputc('\\n', stdout);",
          "192:    break;",
          "194:   default:",
          "195:    (void) fprintf(stderr, \"message[%d]: unknown type \"",
          "196:        \"%d/val=\\\"%s\\\"\\n\",",
          "197:        i, m->msg_style, m->msg);",
          "199:    goto err;",
          "200:   }",
          "201:   if (errno == EINTR)",
          "202:    goto err;",
          "205:   m++;",
          "206:   r++;",
          "207:  }",
          "208:  return (PAM_SUCCESS);",
          "210: err:",
          "211:  free_resp(i, r);",
          "213:  return (PAM_CONV_ERR);",
          "214: }",
          "",
          "---------------"
        ],
        "compat/pm_pam_conv.h||compat/pm_pam_conv.h": [
          "File: compat/pm_pam_conv.h -> compat/pm_pam_conv.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: #include <security/pam_appl.h>",
          "3: int pam_tty_conv(int num_msg, struct pam_message **mess,",
          "4:     struct pam_response **resp, void *my_data);",
          "",
          "---------------"
        ],
        "compat/setresuid.c||compat/setresuid.c": [
          "File: compat/setresuid.c -> compat/setresuid.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: #include <sys/types.h>",
          "3: #include <unistd.h>",
          "4: #include <errno.h>",
          "6: int",
          "7: setresuid(uid_t ruid, uid_t euid, uid_t suid)",
          "8: {",
          "9:  int ret = 0;",
          "11:  if (ruid != suid) {",
          "12:   errno = ENOSYS;",
          "13:   return -1;",
          "14:  }",
          "16:  if (setreuid(ruid, euid) < 0) {",
          "17:   ret = -1;",
          "18:  }",
          "20:  return ret;",
          "21: }",
          "",
          "---------------"
        ],
        "compat/sys/tree.h||compat/sys/tree.h": [
          "File: compat/sys/tree.h -> compat/sys/tree.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "27: #ifndef _SYS_TREE_H_",
          "28: #define _SYS_TREE_H_",
          "57: #define SPLAY_HEAD(name, type)      \\",
          "58: struct name {        \\",
          "59:  struct type *sph_root; /* root of the tree */   \\",
          "60: }",
          "62: #define SPLAY_INITIALIZER(root)      \\",
          "63:  { NULL }",
          "65: #define SPLAY_INIT(root) do {      \\",
          "66:  (root)->sph_root = NULL;     \\",
          "67: } while (0)",
          "69: #define SPLAY_ENTRY(type)      \\",
          "70: struct {        \\",
          "71:  struct type *spe_left; /* left element */   \\",
          "72:  struct type *spe_right; /* right element */   \\",
          "73: }",
          "75: #define SPLAY_LEFT(elm, field)  (elm)->field.spe_left",
          "76: #define SPLAY_RIGHT(elm, field)  (elm)->field.spe_right",
          "77: #define SPLAY_ROOT(head)  (head)->sph_root",
          "78: #define SPLAY_EMPTY(head)  (SPLAY_ROOT(head) == NULL)",
          "81: #define SPLAY_ROTATE_RIGHT(head, tmp, field) do {   \\",
          "82:  SPLAY_LEFT((head)->sph_root, field) = SPLAY_RIGHT(tmp, field); \\",
          "83:  SPLAY_RIGHT(tmp, field) = (head)->sph_root;   \\",
          "84:  (head)->sph_root = tmp;      \\",
          "85: } while (0)",
          "87: #define SPLAY_ROTATE_LEFT(head, tmp, field) do {   \\",
          "88:  SPLAY_RIGHT((head)->sph_root, field) = SPLAY_LEFT(tmp, field); \\",
          "89:  SPLAY_LEFT(tmp, field) = (head)->sph_root;   \\",
          "90:  (head)->sph_root = tmp;      \\",
          "91: } while (0)",
          "93: #define SPLAY_LINKLEFT(head, tmp, field) do {    \\",
          "94:  SPLAY_LEFT(tmp, field) = (head)->sph_root;   \\",
          "95:  tmp = (head)->sph_root;      \\",
          "96:  (head)->sph_root = SPLAY_LEFT((head)->sph_root, field);  \\",
          "97: } while (0)",
          "99: #define SPLAY_LINKRIGHT(head, tmp, field) do {    \\",
          "100:  SPLAY_RIGHT(tmp, field) = (head)->sph_root;   \\",
          "101:  tmp = (head)->sph_root;      \\",
          "102:  (head)->sph_root = SPLAY_RIGHT((head)->sph_root, field); \\",
          "103: } while (0)",
          "105: #define SPLAY_ASSEMBLE(head, node, left, right, field) do {  \\",
          "106:  SPLAY_RIGHT(left, field) = SPLAY_LEFT((head)->sph_root, field); \\",
          "107:  SPLAY_LEFT(right, field) = SPLAY_RIGHT((head)->sph_root, field);\\",
          "108:  SPLAY_LEFT((head)->sph_root, field) = SPLAY_RIGHT(node, field); \\",
          "109:  SPLAY_RIGHT((head)->sph_root, field) = SPLAY_LEFT(node, field); \\",
          "110: } while (0)",
          "114: #define SPLAY_PROTOTYPE(name, type, field, cmp)    \\",
          "115: void name##_SPLAY(struct name *, struct type *);   \\",
          "116: void name##_SPLAY_MINMAX(struct name *, int);    \\",
          "117: struct type *name##_SPLAY_INSERT(struct name *, struct type *);  \\",
          "118: struct type *name##_SPLAY_REMOVE(struct name *, struct type *);  \\",
          "119:          \\",
          "121: static __inline struct type *      \\",
          "122: name##_SPLAY_FIND(struct name *head, struct type *elm)   \\",
          "123: {         \\",
          "124:  if (SPLAY_EMPTY(head))      \\",
          "125:   return(NULL);      \\",
          "126:  name##_SPLAY(head, elm);     \\",
          "127:  if ((cmp)(elm, (head)->sph_root) == 0)    \\",
          "128:   return (head->sph_root);    \\",
          "129:  return (NULL);       \\",
          "130: }         \\",
          "131:          \\",
          "132: static __inline struct type *      \\",
          "133: name##_SPLAY_NEXT(struct name *head, struct type *elm)   \\",
          "134: {         \\",
          "135:  name##_SPLAY(head, elm);     \\",
          "136:  if (SPLAY_RIGHT(elm, field) != NULL) {    \\",
          "137:   elm = SPLAY_RIGHT(elm, field);    \\",
          "138:   while (SPLAY_LEFT(elm, field) != NULL) {  \\",
          "139:    elm = SPLAY_LEFT(elm, field);   \\",
          "140:   }       \\",
          "141:  } else        \\",
          "142:   elm = NULL;      \\",
          "143:  return (elm);       \\",
          "144: }         \\",
          "145:          \\",
          "146: static __inline struct type *      \\",
          "147: name##_SPLAY_MIN_MAX(struct name *head, int val)   \\",
          "148: {         \\",
          "149:  name##_SPLAY_MINMAX(head, val);     \\",
          "150:         return (SPLAY_ROOT(head));     \\",
          "151: }",
          "156: #define SPLAY_GENERATE(name, type, field, cmp)    \\",
          "157: struct type *        \\",
          "158: name##_SPLAY_INSERT(struct name *head, struct type *elm)  \\",
          "159: {         \\",
          "160:     if (SPLAY_EMPTY(head)) {      \\",
          "161:      SPLAY_LEFT(elm, field) = SPLAY_RIGHT(elm, field) = NULL; \\",
          "162:     } else {        \\",
          "163:      int __comp;       \\",
          "164:      name##_SPLAY(head, elm);     \\",
          "165:      __comp = (cmp)(elm, (head)->sph_root);   \\",
          "166:      if(__comp < 0) {      \\",
          "167:       SPLAY_LEFT(elm, field) = SPLAY_LEFT((head)->sph_root, field);\\",
          "168:       SPLAY_RIGHT(elm, field) = (head)->sph_root;  \\",
          "169:       SPLAY_LEFT((head)->sph_root, field) = NULL;  \\",
          "170:      } else if (__comp > 0) {     \\",
          "171:       SPLAY_RIGHT(elm, field) = SPLAY_RIGHT((head)->sph_root, field);\\",
          "172:       SPLAY_LEFT(elm, field) = (head)->sph_root;  \\",
          "173:       SPLAY_RIGHT((head)->sph_root, field) = NULL; \\",
          "174:      } else       \\",
          "175:       return ((head)->sph_root);    \\",
          "176:     }         \\",
          "177:     (head)->sph_root = (elm);      \\",
          "178:     return (NULL);       \\",
          "179: }         \\",
          "180:          \\",
          "181: struct type *        \\",
          "182: name##_SPLAY_REMOVE(struct name *head, struct type *elm)  \\",
          "183: {         \\",
          "184:  struct type *__tmp;      \\",
          "185:  if (SPLAY_EMPTY(head))      \\",
          "186:   return (NULL);      \\",
          "187:  name##_SPLAY(head, elm);     \\",
          "188:  if ((cmp)(elm, (head)->sph_root) == 0) {   \\",
          "189:   if (SPLAY_LEFT((head)->sph_root, field) == NULL) { \\",
          "190:    (head)->sph_root = SPLAY_RIGHT((head)->sph_root, field);\\",
          "191:   } else {      \\",
          "192:    __tmp = SPLAY_RIGHT((head)->sph_root, field); \\",
          "193:    (head)->sph_root = SPLAY_LEFT((head)->sph_root, field);\\",
          "194:    name##_SPLAY(head, elm);   \\",
          "195:    SPLAY_RIGHT((head)->sph_root, field) = __tmp; \\",
          "196:   }       \\",
          "197:   return (elm);      \\",
          "198:  }        \\",
          "199:  return (NULL);       \\",
          "200: }         \\",
          "201:          \\",
          "202: void         \\",
          "203: name##_SPLAY(struct name *head, struct type *elm)   \\",
          "204: {         \\",
          "205:  struct type __node, *__left, *__right, *__tmp;   \\",
          "206:  int __comp;       \\",
          "207: \\",
          "208:  SPLAY_LEFT(&__node, field) = SPLAY_RIGHT(&__node, field) = NULL;\\",
          "209:  __left = __right = &__node;     \\",
          "210: \\",
          "211:  while ((__comp = (cmp)(elm, (head)->sph_root))) {  \\",
          "212:   if (__comp < 0) {     \\",
          "213:    __tmp = SPLAY_LEFT((head)->sph_root, field); \\",
          "214:    if (__tmp == NULL)    \\",
          "215:     break;     \\",
          "216:    if ((cmp)(elm, __tmp) < 0){   \\",
          "217:     SPLAY_ROTATE_RIGHT(head, __tmp, field); \\",
          "218:     if (SPLAY_LEFT((head)->sph_root, field) == NULL)\\",
          "219:      break;    \\",
          "220:    }      \\",
          "221:    SPLAY_LINKLEFT(head, __right, field);  \\",
          "222:   } else if (__comp > 0) {    \\",
          "223:    __tmp = SPLAY_RIGHT((head)->sph_root, field); \\",
          "224:    if (__tmp == NULL)    \\",
          "225:     break;     \\",
          "226:    if ((cmp)(elm, __tmp) > 0){   \\",
          "227:     SPLAY_ROTATE_LEFT(head, __tmp, field); \\",
          "228:     if (SPLAY_RIGHT((head)->sph_root, field) == NULL)\\",
          "229:      break;    \\",
          "230:    }      \\",
          "231:    SPLAY_LINKRIGHT(head, __left, field);  \\",
          "232:   }       \\",
          "233:  }        \\",
          "234:  SPLAY_ASSEMBLE(head, &__node, __left, __right, field);  \\",
          "235: }         \\",
          "236:          \\",
          "240: void name##_SPLAY_MINMAX(struct name *head, int __comp) \\",
          "241: {         \\",
          "242:  struct type __node, *__left, *__right, *__tmp;   \\",
          "243: \\",
          "244:  SPLAY_LEFT(&__node, field) = SPLAY_RIGHT(&__node, field) = NULL;\\",
          "245:  __left = __right = &__node;     \\",
          "246: \\",
          "247:  while (1) {       \\",
          "248:   if (__comp < 0) {     \\",
          "249:    __tmp = SPLAY_LEFT((head)->sph_root, field); \\",
          "250:    if (__tmp == NULL)    \\",
          "251:     break;     \\",
          "252:    if (__comp < 0){    \\",
          "253:     SPLAY_ROTATE_RIGHT(head, __tmp, field); \\",
          "254:     if (SPLAY_LEFT((head)->sph_root, field) == NULL)\\",
          "255:      break;    \\",
          "256:    }      \\",
          "257:    SPLAY_LINKLEFT(head, __right, field);  \\",
          "258:   } else if (__comp > 0) {    \\",
          "259:    __tmp = SPLAY_RIGHT((head)->sph_root, field); \\",
          "260:    if (__tmp == NULL)    \\",
          "261:     break;     \\",
          "262:    if (__comp > 0) {    \\",
          "263:     SPLAY_ROTATE_LEFT(head, __tmp, field); \\",
          "264:     if (SPLAY_RIGHT((head)->sph_root, field) == NULL)\\",
          "265:      break;    \\",
          "266:    }      \\",
          "267:    SPLAY_LINKRIGHT(head, __left, field);  \\",
          "268:   }       \\",
          "269:  }        \\",
          "270:  SPLAY_ASSEMBLE(head, &__node, __left, __right, field);  \\",
          "271: }",
          "273: #define SPLAY_NEGINF -1",
          "274: #define SPLAY_INF 1",
          "276: #define SPLAY_INSERT(name, x, y) name##_SPLAY_INSERT(x, y)",
          "277: #define SPLAY_REMOVE(name, x, y) name##_SPLAY_REMOVE(x, y)",
          "278: #define SPLAY_FIND(name, x, y)  name##_SPLAY_FIND(x, y)",
          "279: #define SPLAY_NEXT(name, x, y)  name##_SPLAY_NEXT(x, y)",
          "280: #define SPLAY_MIN(name, x)  (SPLAY_EMPTY(x) ? NULL \\",
          "281:      : name##_SPLAY_MIN_MAX(x, SPLAY_NEGINF))",
          "282: #define SPLAY_MAX(name, x)  (SPLAY_EMPTY(x) ? NULL \\",
          "283:      : name##_SPLAY_MIN_MAX(x, SPLAY_INF))",
          "285: #define SPLAY_FOREACH(x, name, head)     \\",
          "286:  for ((x) = SPLAY_MIN(name, head);    \\",
          "287:       (x) != NULL;      \\",
          "288:       (x) = SPLAY_NEXT(name, head, x))",
          "291: #define RB_HEAD(name, type)      \\",
          "292: struct name {        \\",
          "293:  struct type *rbh_root; /* root of the tree */   \\",
          "294: }",
          "296: #define RB_INITIALIZER(root)      \\",
          "297:  { NULL }",
          "299: #define RB_INIT(root) do {      \\",
          "300:  (root)->rbh_root = NULL;     \\",
          "301: } while (0)",
          "303: #define RB_BLACK 0",
          "304: #define RB_RED  1",
          "305: #define RB_ENTRY(type)       \\",
          "306: struct {        \\",
          "307:  struct type *rbe_left;  /* left element */  \\",
          "308:  struct type *rbe_right;  /* right element */  \\",
          "309:  struct type *rbe_parent; /* parent element */  \\",
          "310:  int rbe_color;   /* node color */  \\",
          "311: }",
          "313: #define RB_LEFT(elm, field)  (elm)->field.rbe_left",
          "314: #define RB_RIGHT(elm, field)  (elm)->field.rbe_right",
          "315: #define RB_PARENT(elm, field)  (elm)->field.rbe_parent",
          "316: #define RB_COLOR(elm, field)  (elm)->field.rbe_color",
          "317: #define RB_ROOT(head)   (head)->rbh_root",
          "318: #define RB_EMPTY(head)   (RB_ROOT(head) == NULL)",
          "320: #define RB_SET(elm, parent, field) do {     \\",
          "321:  RB_PARENT(elm, field) = parent;     \\",
          "322:  RB_LEFT(elm, field) = RB_RIGHT(elm, field) = NULL;  \\",
          "323:  RB_COLOR(elm, field) = RB_RED;     \\",
          "324: } while (0)",
          "326: #define RB_SET_BLACKRED(black, red, field) do {    \\",
          "327:  RB_COLOR(black, field) = RB_BLACK;    \\",
          "328:  RB_COLOR(red, field) = RB_RED;     \\",
          "329: } while (0)",
          "331: #ifndef RB_AUGMENT",
          "332: #define RB_AUGMENT(x) do {} while (0)",
          "333: #endif",
          "335: #define RB_ROTATE_LEFT(head, elm, tmp, field) do {   \\",
          "336:  (tmp) = RB_RIGHT(elm, field);     \\",
          "337:  if ((RB_RIGHT(elm, field) = RB_LEFT(tmp, field))) {  \\",
          "338:   RB_PARENT(RB_LEFT(tmp, field), field) = (elm);  \\",
          "339:  }        \\",
          "340:  RB_AUGMENT(elm);      \\",
          "341:  if ((RB_PARENT(tmp, field) = RB_PARENT(elm, field))) {  \\",
          "342:   if ((elm) == RB_LEFT(RB_PARENT(elm, field), field)) \\",
          "343:    RB_LEFT(RB_PARENT(elm, field), field) = (tmp); \\",
          "344:   else       \\",
          "345:    RB_RIGHT(RB_PARENT(elm, field), field) = (tmp); \\",
          "346:  } else        \\",
          "347:   (head)->rbh_root = (tmp);    \\",
          "348:  RB_LEFT(tmp, field) = (elm);     \\",
          "349:  RB_PARENT(elm, field) = (tmp);     \\",
          "350:  RB_AUGMENT(tmp);      \\",
          "351:  if ((RB_PARENT(tmp, field)))     \\",
          "352:   RB_AUGMENT(RB_PARENT(tmp, field));   \\",
          "353: } while (0)",
          "355: #define RB_ROTATE_RIGHT(head, elm, tmp, field) do {   \\",
          "356:  (tmp) = RB_LEFT(elm, field);     \\",
          "357:  if ((RB_LEFT(elm, field) = RB_RIGHT(tmp, field))) {  \\",
          "358:   RB_PARENT(RB_RIGHT(tmp, field), field) = (elm);  \\",
          "359:  }        \\",
          "360:  RB_AUGMENT(elm);      \\",
          "361:  if ((RB_PARENT(tmp, field) = RB_PARENT(elm, field))) {  \\",
          "362:   if ((elm) == RB_LEFT(RB_PARENT(elm, field), field)) \\",
          "363:    RB_LEFT(RB_PARENT(elm, field), field) = (tmp); \\",
          "364:   else       \\",
          "365:    RB_RIGHT(RB_PARENT(elm, field), field) = (tmp); \\",
          "366:  } else        \\",
          "367:   (head)->rbh_root = (tmp);    \\",
          "368:  RB_RIGHT(tmp, field) = (elm);     \\",
          "369:  RB_PARENT(elm, field) = (tmp);     \\",
          "370:  RB_AUGMENT(tmp);      \\",
          "371:  if ((RB_PARENT(tmp, field)))     \\",
          "372:   RB_AUGMENT(RB_PARENT(tmp, field));   \\",
          "373: } while (0)",
          "376: #define RB_PROTOTYPE(name, type, field, cmp)    \\",
          "377:  RB_PROTOTYPE_INTERNAL(name, type, field, cmp,)",
          "378: #define RB_PROTOTYPE_STATIC(name, type, field, cmp)   \\",
          "379:  RB_PROTOTYPE_INTERNAL(name, type, field, cmp, __attribute__((__unused__)) static)",
          "380: #define RB_PROTOTYPE_INTERNAL(name, type, field, cmp, attr)  \\",
          "381: attr void name##_RB_INSERT_COLOR(struct name *, struct type *);  \\",
          "382: attr void name##_RB_REMOVE_COLOR(struct name *, struct type *, struct type *);\\",
          "383: attr struct type *name##_RB_REMOVE(struct name *, struct type *); \\",
          "384: attr struct type *name##_RB_INSERT(struct name *, struct type *); \\",
          "385: attr struct type *name##_RB_FIND(struct name *, struct type *);  \\",
          "386: attr struct type *name##_RB_NFIND(struct name *, struct type *); \\",
          "387: attr struct type *name##_RB_NEXT(struct type *);   \\",
          "388: attr struct type *name##_RB_PREV(struct type *);   \\",
          "389: attr struct type *name##_RB_MINMAX(struct name *, int);   \\",
          "390:          \\",
          "395: #define RB_GENERATE(name, type, field, cmp)    \\",
          "396:  RB_GENERATE_INTERNAL(name, type, field, cmp,)",
          "397: #define RB_GENERATE_STATIC(name, type, field, cmp)   \\",
          "398:  RB_GENERATE_INTERNAL(name, type, field, cmp, __attribute__((__unused__)) static)",
          "399: #define RB_GENERATE_INTERNAL(name, type, field, cmp, attr)  \\",
          "400: attr void        \\",
          "401: name##_RB_INSERT_COLOR(struct name *head, struct type *elm)  \\",
          "402: {         \\",
          "403:  struct type *parent, *gparent, *tmp;    \\",
          "404:  while ((parent = RB_PARENT(elm, field)) &&   \\",
          "405:      RB_COLOR(parent, field) == RB_RED) {   \\",
          "406:   gparent = RB_PARENT(parent, field);   \\",
          "407:   if (parent == RB_LEFT(gparent, field)) {  \\",
          "408:    tmp = RB_RIGHT(gparent, field);   \\",
          "409:    if (tmp && RB_COLOR(tmp, field) == RB_RED) { \\",
          "410:     RB_COLOR(tmp, field) = RB_BLACK; \\",
          "411:     RB_SET_BLACKRED(parent, gparent, field);\\",
          "412:     elm = gparent;    \\",
          "413:     continue;    \\",
          "414:    }      \\",
          "415:    if (RB_RIGHT(parent, field) == elm) {  \\",
          "416:     RB_ROTATE_LEFT(head, parent, tmp, field);\\",
          "417:     tmp = parent;    \\",
          "418:     parent = elm;    \\",
          "419:     elm = tmp;    \\",
          "420:    }      \\",
          "421:    RB_SET_BLACKRED(parent, gparent, field); \\",
          "422:    RB_ROTATE_RIGHT(head, gparent, tmp, field); \\",
          "423:   } else {      \\",
          "424:    tmp = RB_LEFT(gparent, field);   \\",
          "425:    if (tmp && RB_COLOR(tmp, field) == RB_RED) { \\",
          "426:     RB_COLOR(tmp, field) = RB_BLACK; \\",
          "427:     RB_SET_BLACKRED(parent, gparent, field);\\",
          "428:     elm = gparent;    \\",
          "429:     continue;    \\",
          "430:    }      \\",
          "431:    if (RB_LEFT(parent, field) == elm) {  \\",
          "432:     RB_ROTATE_RIGHT(head, parent, tmp, field);\\",
          "433:     tmp = parent;    \\",
          "434:     parent = elm;    \\",
          "435:     elm = tmp;    \\",
          "436:    }      \\",
          "437:    RB_SET_BLACKRED(parent, gparent, field); \\",
          "438:    RB_ROTATE_LEFT(head, gparent, tmp, field); \\",
          "439:   }       \\",
          "440:  }        \\",
          "441:  RB_COLOR(head->rbh_root, field) = RB_BLACK;   \\",
          "442: }         \\",
          "443:          \\",
          "444: attr void        \\",
          "445: name##_RB_REMOVE_COLOR(struct name *head, struct type *parent, struct type *elm) \\",
          "446: {         \\",
          "447:  struct type *tmp;      \\",
          "448:  while ((elm == NULL || RB_COLOR(elm, field) == RB_BLACK) && \\",
          "449:      elm != RB_ROOT(head)) {     \\",
          "450:   if (RB_LEFT(parent, field) == elm) {   \\",
          "451:    tmp = RB_RIGHT(parent, field);   \\",
          "452:    if (RB_COLOR(tmp, field) == RB_RED) {  \\",
          "453:     RB_SET_BLACKRED(tmp, parent, field); \\",
          "454:     RB_ROTATE_LEFT(head, parent, tmp, field);\\",
          "455:     tmp = RB_RIGHT(parent, field);  \\",
          "456:    }      \\",
          "457:    if ((RB_LEFT(tmp, field) == NULL ||  \\",
          "458:        RB_COLOR(RB_LEFT(tmp, field), field) == RB_BLACK) &&\\",
          "459:        (RB_RIGHT(tmp, field) == NULL ||  \\",
          "460:        RB_COLOR(RB_RIGHT(tmp, field), field) == RB_BLACK)) {\\",
          "461:     RB_COLOR(tmp, field) = RB_RED;  \\",
          "462:     elm = parent;    \\",
          "463:     parent = RB_PARENT(elm, field);  \\",
          "464:    } else {     \\",
          "465:     if (RB_RIGHT(tmp, field) == NULL || \\",
          "466:         RB_COLOR(RB_RIGHT(tmp, field), field) == RB_BLACK) {\\",
          "467:      struct type *oleft;  \\",
          "468:      if ((oleft = RB_LEFT(tmp, field)))\\",
          "469:       RB_COLOR(oleft, field) = RB_BLACK;\\",
          "470:      RB_COLOR(tmp, field) = RB_RED; \\",
          "471:      RB_ROTATE_RIGHT(head, tmp, oleft, field);\\",
          "472:      tmp = RB_RIGHT(parent, field); \\",
          "473:     }     \\",
          "474:     RB_COLOR(tmp, field) = RB_COLOR(parent, field);\\",
          "475:     RB_COLOR(parent, field) = RB_BLACK; \\",
          "476:     if (RB_RIGHT(tmp, field))  \\",
          "477:      RB_COLOR(RB_RIGHT(tmp, field), field) = RB_BLACK;\\",
          "478:     RB_ROTATE_LEFT(head, parent, tmp, field);\\",
          "479:     elm = RB_ROOT(head);   \\",
          "480:     break;     \\",
          "481:    }      \\",
          "482:   } else {      \\",
          "483:    tmp = RB_LEFT(parent, field);   \\",
          "484:    if (RB_COLOR(tmp, field) == RB_RED) {  \\",
          "485:     RB_SET_BLACKRED(tmp, parent, field); \\",
          "486:     RB_ROTATE_RIGHT(head, parent, tmp, field);\\",
          "487:     tmp = RB_LEFT(parent, field);  \\",
          "488:    }      \\",
          "489:    if ((RB_LEFT(tmp, field) == NULL ||  \\",
          "490:        RB_COLOR(RB_LEFT(tmp, field), field) == RB_BLACK) &&\\",
          "491:        (RB_RIGHT(tmp, field) == NULL ||  \\",
          "492:        RB_COLOR(RB_RIGHT(tmp, field), field) == RB_BLACK)) {\\",
          "493:     RB_COLOR(tmp, field) = RB_RED;  \\",
          "494:     elm = parent;    \\",
          "495:     parent = RB_PARENT(elm, field);  \\",
          "496:    } else {     \\",
          "497:     if (RB_LEFT(tmp, field) == NULL || \\",
          "498:         RB_COLOR(RB_LEFT(tmp, field), field) == RB_BLACK) {\\",
          "499:      struct type *oright;  \\",
          "500:      if ((oright = RB_RIGHT(tmp, field)))\\",
          "501:       RB_COLOR(oright, field) = RB_BLACK;\\",
          "502:      RB_COLOR(tmp, field) = RB_RED; \\",
          "503:      RB_ROTATE_LEFT(head, tmp, oright, field);\\",
          "504:      tmp = RB_LEFT(parent, field); \\",
          "505:     }     \\",
          "506:     RB_COLOR(tmp, field) = RB_COLOR(parent, field);\\",
          "507:     RB_COLOR(parent, field) = RB_BLACK; \\",
          "508:     if (RB_LEFT(tmp, field))  \\",
          "509:      RB_COLOR(RB_LEFT(tmp, field), field) = RB_BLACK;\\",
          "510:     RB_ROTATE_RIGHT(head, parent, tmp, field);\\",
          "511:     elm = RB_ROOT(head);   \\",
          "512:     break;     \\",
          "513:    }      \\",
          "514:   }       \\",
          "515:  }        \\",
          "516:  if (elm)       \\",
          "517:   RB_COLOR(elm, field) = RB_BLACK;   \\",
          "518: }         \\",
          "519:          \\",
          "520: attr struct type *       \\",
          "521: name##_RB_REMOVE(struct name *head, struct type *elm)   \\",
          "522: {         \\",
          "523:  struct type *child, *parent, *old = elm;   \\",
          "524:  int color;       \\",
          "525:  if (RB_LEFT(elm, field) == NULL)    \\",
          "526:   child = RB_RIGHT(elm, field);    \\",
          "527:  else if (RB_RIGHT(elm, field) == NULL)    \\",
          "528:   child = RB_LEFT(elm, field);    \\",
          "529:  else {        \\",
          "530:   struct type *left;     \\",
          "531:   elm = RB_RIGHT(elm, field);    \\",
          "532:   while ((left = RB_LEFT(elm, field)))   \\",
          "533:    elm = left;     \\",
          "534:   child = RB_RIGHT(elm, field);    \\",
          "535:   parent = RB_PARENT(elm, field);    \\",
          "536:   color = RB_COLOR(elm, field);    \\",
          "537:   if (child)      \\",
          "538:    RB_PARENT(child, field) = parent;  \\",
          "539:   if (parent) {      \\",
          "540:    if (RB_LEFT(parent, field) == elm)  \\",
          "541:     RB_LEFT(parent, field) = child;  \\",
          "542:    else      \\",
          "543:     RB_RIGHT(parent, field) = child; \\",
          "544:    RB_AUGMENT(parent);    \\",
          "545:   } else       \\",
          "546:    RB_ROOT(head) = child;    \\",
          "547:   if (RB_PARENT(elm, field) == old)   \\",
          "548:    parent = elm;     \\",
          "549:   (elm)->field = (old)->field;    \\",
          "550:   if (RB_PARENT(old, field)) {    \\",
          "551:    if (RB_LEFT(RB_PARENT(old, field), field) == old)\\",
          "552:     RB_LEFT(RB_PARENT(old, field), field) = elm;\\",
          "553:    else      \\",
          "554:     RB_RIGHT(RB_PARENT(old, field), field) = elm;\\",
          "555:    RB_AUGMENT(RB_PARENT(old, field));  \\",
          "556:   } else       \\",
          "557:    RB_ROOT(head) = elm;    \\",
          "558:   RB_PARENT(RB_LEFT(old, field), field) = elm;  \\",
          "559:   if (RB_RIGHT(old, field))    \\",
          "560:    RB_PARENT(RB_RIGHT(old, field), field) = elm; \\",
          "561:   if (parent) {      \\",
          "562:    left = parent;     \\",
          "563:    do {      \\",
          "564:     RB_AUGMENT(left);   \\",
          "565:    } while ((left = RB_PARENT(left, field))); \\",
          "566:   }       \\",
          "567:   goto color;      \\",
          "568:  }        \\",
          "569:  parent = RB_PARENT(elm, field);     \\",
          "570:  color = RB_COLOR(elm, field);     \\",
          "571:  if (child)       \\",
          "572:   RB_PARENT(child, field) = parent;   \\",
          "573:  if (parent) {       \\",
          "574:   if (RB_LEFT(parent, field) == elm)   \\",
          "575:    RB_LEFT(parent, field) = child;   \\",
          "576:   else       \\",
          "577:    RB_RIGHT(parent, field) = child;  \\",
          "578:   RB_AUGMENT(parent);     \\",
          "579:  } else        \\",
          "580:   RB_ROOT(head) = child;     \\",
          "581: color:         \\",
          "582:  if (color == RB_BLACK)      \\",
          "583:   name##_RB_REMOVE_COLOR(head, parent, child);  \\",
          "584:  return (old);       \\",
          "585: }         \\",
          "586:          \\",
          "588: attr struct type *       \\",
          "589: name##_RB_INSERT(struct name *head, struct type *elm)   \\",
          "590: {         \\",
          "591:  struct type *tmp;      \\",
          "592:  struct type *parent = NULL;     \\",
          "593:  int comp = 0;       \\",
          "594:  tmp = RB_ROOT(head);      \\",
          "595:  while (tmp) {       \\",
          "596:   parent = tmp;      \\",
          "597:   comp = (cmp)(elm, parent);    \\",
          "598:   if (comp < 0)      \\",
          "599:    tmp = RB_LEFT(tmp, field);   \\",
          "600:   else if (comp > 0)     \\",
          "601:    tmp = RB_RIGHT(tmp, field);   \\",
          "602:   else       \\",
          "603:    return (tmp);     \\",
          "604:  }        \\",
          "605:  RB_SET(elm, parent, field);     \\",
          "606:  if (parent != NULL) {      \\",
          "607:   if (comp < 0)      \\",
          "608:    RB_LEFT(parent, field) = elm;   \\",
          "609:   else       \\",
          "610:    RB_RIGHT(parent, field) = elm;   \\",
          "611:   RB_AUGMENT(parent);     \\",
          "612:  } else        \\",
          "613:   RB_ROOT(head) = elm;     \\",
          "614:  name##_RB_INSERT_COLOR(head, elm);    \\",
          "615:  return (NULL);       \\",
          "616: }         \\",
          "617:          \\",
          "619: attr struct type *       \\",
          "620: name##_RB_FIND(struct name *head, struct type *elm)   \\",
          "621: {         \\",
          "622:  struct type *tmp = RB_ROOT(head);    \\",
          "623:  int comp;       \\",
          "624:  while (tmp) {       \\",
          "625:   comp = cmp(elm, tmp);     \\",
          "626:   if (comp < 0)      \\",
          "627:    tmp = RB_LEFT(tmp, field);   \\",
          "628:   else if (comp > 0)     \\",
          "629:    tmp = RB_RIGHT(tmp, field);   \\",
          "630:   else       \\",
          "631:    return (tmp);     \\",
          "632:  }        \\",
          "633:  return (NULL);       \\",
          "634: }         \\",
          "635:          \\",
          "637: attr struct type *       \\",
          "638: name##_RB_NFIND(struct name *head, struct type *elm)   \\",
          "639: {         \\",
          "640:  struct type *tmp = RB_ROOT(head);    \\",
          "641:  struct type *res = NULL;     \\",
          "642:  int comp;       \\",
          "643:  while (tmp) {       \\",
          "644:   comp = cmp(elm, tmp);     \\",
          "645:   if (comp < 0) {      \\",
          "646:    res = tmp;     \\",
          "647:    tmp = RB_LEFT(tmp, field);   \\",
          "648:   }       \\",
          "649:   else if (comp > 0)     \\",
          "650:    tmp = RB_RIGHT(tmp, field);   \\",
          "651:   else       \\",
          "652:    return (tmp);     \\",
          "653:  }        \\",
          "654:  return (res);       \\",
          "655: }         \\",
          "656:          \\",
          "658: attr struct type *       \\",
          "659: name##_RB_NEXT(struct type *elm)     \\",
          "660: {         \\",
          "661:  if (RB_RIGHT(elm, field)) {     \\",
          "662:   elm = RB_RIGHT(elm, field);    \\",
          "663:   while (RB_LEFT(elm, field))    \\",
          "664:    elm = RB_LEFT(elm, field);   \\",
          "665:  } else {       \\",
          "666:   if (RB_PARENT(elm, field) &&    \\",
          "667:       (elm == RB_LEFT(RB_PARENT(elm, field), field))) \\",
          "668:    elm = RB_PARENT(elm, field);   \\",
          "669:   else {       \\",
          "670:    while (RB_PARENT(elm, field) &&   \\",
          "671:        (elm == RB_RIGHT(RB_PARENT(elm, field), field)))\\",
          "672:     elm = RB_PARENT(elm, field);  \\",
          "673:    elm = RB_PARENT(elm, field);   \\",
          "674:   }       \\",
          "675:  }        \\",
          "676:  return (elm);       \\",
          "677: }         \\",
          "678:          \\",
          "680: attr struct type *       \\",
          "681: name##_RB_PREV(struct type *elm)     \\",
          "682: {         \\",
          "683:  if (RB_LEFT(elm, field)) {     \\",
          "684:   elm = RB_LEFT(elm, field);    \\",
          "685:   while (RB_RIGHT(elm, field))    \\",
          "686:    elm = RB_RIGHT(elm, field);   \\",
          "687:  } else {       \\",
          "688:   if (RB_PARENT(elm, field) &&    \\",
          "689:       (elm == RB_RIGHT(RB_PARENT(elm, field), field))) \\",
          "690:    elm = RB_PARENT(elm, field);   \\",
          "691:   else {       \\",
          "692:    while (RB_PARENT(elm, field) &&   \\",
          "693:        (elm == RB_LEFT(RB_PARENT(elm, field), field)))\\",
          "694:     elm = RB_PARENT(elm, field);  \\",
          "695:    elm = RB_PARENT(elm, field);   \\",
          "696:   }       \\",
          "697:  }        \\",
          "698:  return (elm);       \\",
          "699: }         \\",
          "700:          \\",
          "701: attr struct type *       \\",
          "702: name##_RB_MINMAX(struct name *head, int val)    \\",
          "703: {         \\",
          "704:  struct type *tmp = RB_ROOT(head);    \\",
          "705:  struct type *parent = NULL;     \\",
          "706:  while (tmp) {       \\",
          "707:   parent = tmp;      \\",
          "708:   if (val < 0)      \\",
          "709:    tmp = RB_LEFT(tmp, field);   \\",
          "710:   else       \\",
          "711:    tmp = RB_RIGHT(tmp, field);   \\",
          "712:  }        \\",
          "713:  return (parent);      \\",
          "714: }",
          "716: #define RB_NEGINF -1",
          "717: #define RB_INF 1",
          "719: #define RB_INSERT(name, x, y) name##_RB_INSERT(x, y)",
          "720: #define RB_REMOVE(name, x, y) name##_RB_REMOVE(x, y)",
          "721: #define RB_FIND(name, x, y) name##_RB_FIND(x, y)",
          "722: #define RB_NFIND(name, x, y) name##_RB_NFIND(x, y)",
          "723: #define RB_NEXT(name, x, y) name##_RB_NEXT(y)",
          "724: #define RB_PREV(name, x, y) name##_RB_PREV(y)",
          "725: #define RB_MIN(name, x)  name##_RB_MINMAX(x, RB_NEGINF)",
          "726: #define RB_MAX(name, x)  name##_RB_MINMAX(x, RB_INF)",
          "728: #define RB_FOREACH(x, name, head)     \\",
          "729:  for ((x) = RB_MIN(name, head);     \\",
          "730:       (x) != NULL;      \\",
          "731:       (x) = name##_RB_NEXT(x))",
          "733: #define RB_FOREACH_SAFE(x, name, head, y)    \\",
          "734:  for ((x) = RB_MIN(name, head);     \\",
          "735:      ((x) != NULL) && ((y) = name##_RB_NEXT(x), 1);  \\",
          "736:       (x) = (y))",
          "738: #define RB_FOREACH_REVERSE(x, name, head)    \\",
          "739:  for ((x) = RB_MAX(name, head);     \\",
          "740:       (x) != NULL;      \\",
          "741:       (x) = name##_RB_PREV(x))",
          "743: #define RB_FOREACH_REVERSE_SAFE(x, name, head, y)   \\",
          "744:  for ((x) = RB_MAX(name, head);     \\",
          "745:      ((x) != NULL) && ((y) = name##_RB_PREV(x), 1);  \\",
          "746:       (x) = (y))",
          "",
          "---------------"
        ],
        "compat/verrc.c||compat/verrc.c": [
          "File: compat/verrc.c -> compat/verrc.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "31: #include <err.h>",
          "32: #include <stdio.h>",
          "33: #include <stdlib.h>",
          "34: #include <string.h>",
          "35: #include <stdarg.h>",
          "37: void",
          "38: verrc(int eval, int code, const char *fmt, va_list ap)",
          "39: {",
          "40:  (void)fprintf(stderr, \"%s: \", getprogname());",
          "41:  if (fmt != NULL) {",
          "42:   (void)vfprintf(stderr, fmt, ap);",
          "43:   (void)fprintf(stderr, \": \");",
          "44:  }",
          "45:  (void)fprintf(stderr, \"%s\\n\", strerror(code));",
          "46:  exit(eval);",
          "47: }",
          "",
          "---------------"
        ],
        "doas.c||doas.c": [
          "File: doas.c -> doas.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "24: #endif",
          "26: #include <limits.h>",
          "34: #include <string.h>",
          "35: #include <stdio.h>",
          "36: #include <stdlib.h>",
          "",
          "[Removed Lines]",
          "28: #include <login_cap.h>",
          "29: #include <bsd_auth.h>",
          "31: #ifdef __freebsd__",
          "32: #include <readpassphrase.h>",
          "33: #endif",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "49: #if defined(USE_BSD_AUTH)",
          "50: #include <bsd_auth.h>",
          "51: #endif",
          "53: #if defined(USE_PAM)",
          "54: #include <security/pam_appl.h>",
          "57: #include <security/openpam.h>",
          "58: static struct pam_conv pamc = { openpam_ttyconv, NULL };",
          "63: #include <security/pam_misc.h>",
          "64: static struct pam_conv pamc = { misc_conv, NULL };",
          "69: #include \"doas.h\"",
          "",
          "[Removed Lines]",
          "56: #ifndef linux",
          "59: #include <fcntl.h>",
          "60: #endif // BSD using PAM",
          "62: #ifdef linux",
          "65: #endif // Linux using PAM",
          "67: #endif // PAM",
          "",
          "[Added Lines]",
          "44: #include <readpassphrase.h>",
          "59: #include \"pm_pam_conv.h\"",
          "60: static struct pam_conv pamc = { pam_tty_conv, NULL };",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "96:   return 0;",
          "97:  }",
          "103:  if (errstr)",
          "104:   return -1;",
          "105:  return 0;",
          "",
          "[Removed Lines]",
          "98:         #ifdef __freebsd__",
          "100:         #else",
          "101:         sscanf(s, \"%d\", uid);",
          "102:         #endif",
          "",
          "[Added Lines]",
          "94:  #if !defined(__linux__) && !defined(__NetBSD__)",
          "96:  #else",
          "97:  sscanf(s, \"%d\", uid);",
          "98:  #endif",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "128:   return 0;",
          "129:  }",
          "135:  if (errstr)",
          "136:   return -1;",
          "137:  return 0;",
          "",
          "[Removed Lines]",
          "130:         #ifdef __freebsd__",
          "132:         #else",
          "133:         sscanf(s, \"%d\", gid);",
          "134:         #endif",
          "",
          "[Added Lines]",
          "126:  #if !defined(__linux__) && !defined(__NetBSD__)",
          "128:  #else",
          "129:  sscanf(s, \"%d\", gid);",
          "130:  #endif",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "228:  struct rule *rule;",
          "229:         int status;",
          "234:  status = setresuid(uid, uid, uid);",
          "243:  parseconfig(confpath, 0);",
          "244:  if (!argc)",
          "245:   exit(0);",
          "",
          "[Removed Lines]",
          "231:         #ifdef linux",
          "232:  status = setresuid(uid, uid, uid);",
          "233:         #elif __freebsd__",
          "235:         #else",
          "236:         status = setreuid(uid, uid);",
          "237:         #endif",
          "238:         if (status == -1)",
          "239:         {",
          "240:            printf(\"doas: Unable to set UID\\n\");",
          "241:            exit(1);",
          "242:         }",
          "",
          "[Added Lines]",
          "227:  #if defined(__linux__) || defined(__FreeBSD__)",
          "229:  #else",
          "230:  status = setreuid(uid, uid);",
          "231:  #endif",
          "232:  if (status == -1)",
          "233:  {",
          "234:   printf(\"doas: Unable to set UID\\n\");",
          "235:   exit(1);",
          "236:  }",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "305: int",
          "306: main(int argc, char **argv)",
          "307: {",
          "310:  const char *confpath = NULL;",
          "311:  char *shargv[] = { NULL, NULL };",
          "312:  char *sh;",
          "",
          "[Removed Lines]",
          "308:  const char *safepath = \"/bin:/sbin:/usr/bin:/usr/sbin:\"",
          "309:      \"/usr/local/bin:/usr/local/sbin\";",
          "",
          "[Added Lines]",
          "302:  const char *safepath = SAFE_PATH;",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "327:  char *login_style = NULL;",
          "328:  char **envp;",
          "331:  setprogname(\"doas\");",
          "335:  closefrom(STDERR_FILENO + 1);",
          "338:  uid = getuid();",
          "",
          "[Removed Lines]",
          "330:         #ifndef linux",
          "332:         #endif",
          "334:         #ifndef linux",
          "336:         #endif",
          "",
          "[Added Lines]",
          "323:  #ifndef linux",
          "325:  #endif",
          "327:  #ifndef linux",
          "329:  #endif",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "520:   }",
          "521:   pam_end(pamh, pam_err);",
          "525:   if (dup2(temp_stdin, STDIN_FILENO) == -1)",
          "526:    err(1, \"dup2\");",
          "",
          "[Removed Lines]",
          "523: #ifndef linux",
          "",
          "[Added Lines]",
          "516: #ifndef linux",
          "",
          "---------------"
        ],
        "doas.h||doas.h": [
          "File: doas.h -> doas.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "59: #define _PW_NAME_LEN 32",
          "60: #endif",
          "62: void *reallocarray(void *ptr, size_t nmemb, size_t size);",
          "64: #if !defined(HAVE_EXECVPE)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "62: #ifndef SAFE_PATH",
          "63: #define SAFE_PATH \"/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin\"",
          "64: #endif",
          "",
          "---------------"
        ],
        "execvpe.c||execvpe.c": [
          "File: execvpe.c -> execvpe.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "40: #include <string.h>",
          "41: #include <unistd.h>",
          "43: #include \"doas.h\"",
          "45: int",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "43: #if defined(__sun)",
          "44: #include <strings.h>",
          "45: #include <alloca.h>",
          "46: #endif",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "705dd9ce2440878c78251ea92c4161f914300cdd",
      "candidate_info": {
        "commit_hash": "705dd9ce2440878c78251ea92c4161f914300cdd",
        "repo": "slicer69/doas",
        "commit_url": "https://github.com/slicer69/doas/commit/705dd9ce2440878c78251ea92c4161f914300cdd",
        "files": [
          "Makefile",
          "compat/compat.h",
          "compat/setresuid.c",
          "doas.c",
          "doas.h",
          "env.c",
          "execvpe.c",
          "reallocarray.c",
          "strlcat.c",
          "strlcpy.c",
          "tree.h"
        ],
        "message": "Reorganized compatibility code and Makefile. - amalleo25 Provided cleaner fix for crash when user/command has no valid match in the doas.conf file. - amalleo25 Removed option to match UID with -u flag. Provided usernames must now match a username, not UID. This was ambigious if a user had a numeric username. - Jesse",
        "before_after_code_files": [
          "compat/compat.h||compat/compat.h",
          "compat/setresuid.c||compat/setresuid.c",
          "doas.c||doas.c",
          "doas.h||doas.h",
          "env.c||env.c",
          "execvpe.c||execvpe.c",
          "reallocarray.c||reallocarray.c",
          "strlcat.c||strlcat.c",
          "strlcpy.c||strlcpy.c",
          "tree.h||tree.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "doas.c||doas.c"
          ],
          "candidate": [
            "doas.c||doas.c"
          ]
        }
      },
      "candidate_diff": {
        "compat/compat.h||compat/compat.h": [
          "File: compat/compat.h -> compat/compat.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "1: #include <sys/types.h>",
          "2: #include <stdarg.h>",
          "4: void errc(int eval, int code, const char *fmt, ...);",
          "6: int setresuid(uid_t ruid, uid_t euid, uid_t suid);",
          "8: void verrc(int eval, int code, const char *fmt, va_list ap);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4: #if !defined(__NetBSD__)",
          "5: void closefrom(int lowfd);",
          "6: #endif",
          "10: int execvpe(const char *file, char * const *argv, char * const *envp);",
          "12: extern const char *__progname;",
          "14: const char *getprogname(void);",
          "16: void *reallocarray(void *optr, size_t nmemb, size_t size);",
          "18: void setprogname(const char *progname);",
          "22: size_t strlcat(char *dst, const char *src, size_t dsize);",
          "24: size_t strlcpy(char *dst, const char *src, size_t dsize);",
          "26: long long strtonum(const char *numstr, long long minval, long long maxval,",
          "27:  const char **errstrp);",
          "",
          "---------------"
        ],
        "compat/setresuid.c||compat/setresuid.c": [
          "File: compat/setresuid.c -> compat/setresuid.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "6: int",
          "7: setresuid(uid_t ruid, uid_t euid, uid_t suid)",
          "8: {",
          "11:  if (ruid != suid) {",
          "12:   errno = ENOSYS;",
          "13:   return -1;",
          "14:  }",
          "21: }",
          "",
          "[Removed Lines]",
          "9:  int ret = 0;",
          "16:  if (setreuid(ruid, euid) < 0) {",
          "17:   ret = -1;",
          "18:  }",
          "20:  return ret;",
          "",
          "[Added Lines]",
          "32:  return setreuid(ruid, euid);",
          "",
          "---------------"
        ],
        "doas.c||doas.c": [
          "File: doas.c -> doas.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "72:  exit(1);",
          "73: }",
          "87: static int",
          "88: parseuid(const char *s, uid_t *uid)",
          "89: {",
          "90:  struct passwd *pw;",
          "99:   return 0;",
          "100:  }",
          "111: }",
          "113: static int",
          "",
          "[Removed Lines]",
          "75: #ifdef linux",
          "76: void",
          "77: errc(int eval, int code, const char *format)",
          "78: {",
          "79:    if (format)",
          "80:       fprintf(stderr, \"%s\", format);",
          "81:     else",
          "82:       fprintf(stderr, \"doas: Permission error encountered. Your user may not have access to perform this action.\\n\");",
          "83:    exit(code);",
          "84: }",
          "85: #endif",
          "91:  #if !defined(__linux__) && !defined(__NetBSD__)",
          "92:  const char *errstr = NULL;",
          "93:         #else",
          "94:         int status;",
          "95:         #endif",
          "97:  if ((pw = getpwnam(s)) != NULL) {",
          "101:  #if !defined(__linux__) && !defined(__NetBSD__)",
          "103:  if (errstr)",
          "104:   return -1;",
          "105:  #else",
          "106:  status = sscanf(s, \"%d\", uid);",
          "107:         if (status != 1)",
          "108:            return -1;",
          "109:  #endif",
          "110:  return 0;",
          "",
          "[Added Lines]",
          "79:         pw = getpwnam(s);",
          "80:  if (pw != NULL) {",
          "84:  return -1;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "126: parsegid(const char *s, gid_t *gid)",
          "127: {",
          "128:  struct group *gr;",
          "137:   return 0;",
          "138:  }",
          "149: }",
          "151: static int",
          "",
          "[Removed Lines]",
          "129:  #if !defined(__linux__) && !defined(__NetBSD__)",
          "130:  const char *errstr = NULL;",
          "131:         #else",
          "132:         int status;",
          "133:         #endif",
          "135:  if ((gr = getgrnam(s)) != NULL) {",
          "139:  #if !defined(__linux__) && !defined(__NetBSD__)",
          "141:  if (errstr)",
          "142:   return -1;",
          "143:  #else",
          "144:  status = sscanf(s, \"%d\", gid);",
          "145:         if (status != 1)",
          "146:             return -1;",
          "147:  #endif",
          "148:  return 0;",
          "",
          "[Added Lines]",
          "103:         gr = getgrnam(s);",
          "104:  if (gr != NULL) {",
          "108:  return -1;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "245:  status = setreuid(uid, uid);",
          "246:  #endif",
          "247:  if (status == -1)",
          "252:  parseconfig(confpath, 0);",
          "253:  if (!argc)",
          "254:   exit(0);",
          "",
          "[Removed Lines]",
          "248:  {",
          "249:   printf(\"doas: Unable to set UID\\n\");",
          "250:   exit(1);",
          "251:  }",
          "",
          "[Added Lines]",
          "208:   errx(1, \"unable to set uid to %d\", uid);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "337:         #endif",
          "338:  char **envp;",
          "341:  setprogname(\"doas\");",
          "345:  closefrom(STDERR_FILENO + 1);",
          "348:  uid = getuid();",
          "",
          "[Removed Lines]",
          "340:  #ifndef linux",
          "342:  #endif",
          "344:  #ifndef linux",
          "346:  #endif",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "561:      LOGIN_SETUSER) != 0)",
          "562:   errx(1, \"failed to set user context for target\");",
          "563: #else",
          "565:  if (setresgid(target_pw->pw_gid, target_pw->pw_gid, target_pw->pw_gid) == -1)",
          "566:   err(1, \"setresgid\");",
          "567:  #else",
          "",
          "[Removed Lines]",
          "564:  #if defined(__linux__) || defined(__FreeBSD__) || defined(__NetBSD__)",
          "",
          "[Added Lines]",
          "518:  #if defined(__linux__) || defined(__FreeBSD__)",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "570:  #endif",
          "571:  if (initgroups(target_pw->pw_name, target_pw->pw_gid) == -1)",
          "572:   err(1, \"initgroups\");",
          "574:  if (setresuid(target, target, target) == -1)",
          "575:   err(1, \"setresuid\");",
          "576:  #else",
          "",
          "[Removed Lines]",
          "573:  #if defined(__linux__) || defined(__FreeBSD__) || defined(__NetBSD__)",
          "",
          "[Added Lines]",
          "527:  #if defined(__linux__) || defined(__FreeBSD__)",
          "",
          "---------------"
        ],
        "doas.h||doas.h": [
          "File: doas.h -> doas.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "63: #define SAFE_PATH \"/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin\"",
          "64: #endif",
          "",
          "[Removed Lines]",
          "66: void *reallocarray(void *ptr, size_t nmemb, size_t size);",
          "68: #if !defined(HAVE_EXECVPE)",
          "69: int execvpe(const char *file, char * const *argv, char * const *envp);",
          "72: #ifdef linux",
          "73: void errc(int eval, int code, const char *format);",
          "74: size_t strlcat(char *dst, const char *src, size_t dsize);",
          "75: size_t strlcpy(char *dst, const char *src, size_t dsize);",
          "76: #endif",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "env.c||env.c": [
          "File: env.c -> env.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "18: #include <sys/types.h>",
          "20: #include <sys/tree.h>",
          "23: #include <stdio.h>",
          "24: #include <stdlib.h>",
          "",
          "[Removed Lines]",
          "19: #ifndef linux",
          "21: #endif",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "28: #include <unistd.h>",
          "29: #include <errno.h>",
          "35: #include \"doas.h\"",
          "37: struct envnode {",
          "",
          "[Removed Lines]",
          "31: #ifdef linux",
          "32: #include \"tree.h\"",
          "33: #endif",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "execvpe.c||execvpe.c": [
          "File: execvpe.c -> execvpe.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "reallocarray.c||reallocarray.c": [
          "File: reallocarray.c -> reallocarray.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "strlcat.c||strlcat.c": [
          "File: strlcat.c -> strlcat.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "strlcpy.c||strlcpy.c": [
          "File: strlcpy.c -> strlcpy.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "tree.h||tree.h": [
          "File: tree.h -> tree.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "1f76dd95158df01c295547055a180fe5682bbe8e",
      "candidate_info": {
        "commit_hash": "1f76dd95158df01c295547055a180fe5682bbe8e",
        "repo": "slicer69/doas",
        "commit_url": "https://github.com/slicer69/doas/commit/1f76dd95158df01c295547055a180fe5682bbe8e",
        "files": [
          "Makefile",
          "doas.c"
        ],
        "message": "Enabled doas to compile and run on NetBSD 8.1.",
        "before_after_code_files": [
          "doas.c||doas.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "doas.c||doas.c"
          ],
          "candidate": [
            "doas.c||doas.c"
          ]
        }
      },
      "candidate_diff": {
        "doas.c||doas.c": [
          "File: doas.c -> doas.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "28: #include <login_cap.h>",
          "29: #include <bsd_auth.h>",
          "32: #include <readpassphrase.h>",
          "33: #endif",
          "34: #include <string.h>",
          "",
          "[Removed Lines]",
          "31: #ifndef linux",
          "",
          "[Added Lines]",
          "31: #ifdef __freebsd__",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "96:   return 0;",
          "97:  }",
          "102:         sscanf(s, \"%d\", uid);",
          "103:         #endif",
          "104:  if (errstr)",
          "",
          "[Removed Lines]",
          "98:         #ifndef linux",
          "100:         #endif",
          "101:         #ifdef linux",
          "",
          "[Added Lines]",
          "98:         #ifdef __freebsd__",
          "100:         #else",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "129:   return 0;",
          "130:  }",
          "135:         sscanf(s, \"%d\", gid);",
          "136:         #endif",
          "137:  if (errstr)",
          "",
          "[Removed Lines]",
          "131:         #ifndef linux",
          "133:         #endif",
          "134:         #ifdef linux",
          "",
          "[Added Lines]",
          "130:         #ifdef __freebsd__",
          "132:         #else",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "228:     uid_t uid, gid_t *groups, int ngroups, uid_t target)",
          "229: {",
          "230:  struct rule *rule;",
          "233:  parseconfig(confpath, 0);",
          "234:  if (!argc)",
          "235:   exit(0);",
          "",
          "[Removed Lines]",
          "232:  setresuid(uid, uid, uid);",
          "",
          "[Added Lines]",
          "229:         int status;",
          "231:         #ifdef linux",
          "232:  status = setresuid(uid, uid, uid);",
          "233:         #elif __freebsd__",
          "234:  status = setresuid(uid, uid, uid);",
          "235:         #else",
          "236:         status = setreuid(uid, uid);",
          "237:         #endif",
          "238:         if (status == -1)",
          "239:         {",
          "240:            printf(\"doas: Unable to set UID\\n\");",
          "241:            exit(1);",
          "242:         }",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "510:   }",
          "511:   pam_end(pamh, pam_err);",
          "515:   if (dup2(temp_stdin, STDIN_FILENO) == -1)",
          "516:    err(1, \"dup2\");",
          "",
          "[Removed Lines]",
          "513: #ifndef linux",
          "",
          "[Added Lines]",
          "523: #ifndef linux",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "520:   close(1);",
          "521:   if (dup2(temp_stdout, 1) == -1)",
          "522:    err(1, \"dup2\");",
          "524: #else",
          "525: #error No auth module!",
          "526: #endif",
          "",
          "[Removed Lines]",
          "523: #endif",
          "",
          "[Added Lines]",
          "533: #endif",
          "",
          "---------------"
        ]
      }
    }
  ]
}
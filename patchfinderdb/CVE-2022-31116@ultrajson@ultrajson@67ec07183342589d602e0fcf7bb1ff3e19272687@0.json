{
  "cve_id": "CVE-2022-31116",
  "cve_desc": "UltraJSON is a fast JSON encoder and decoder written in pure C with bindings for Python 3.7+. Affected versions were found to improperly decode certain characters. JSON strings that contain escaped surrogate characters not part of a proper surrogate pair were decoded incorrectly. Besides corrupting strings, this allowed for potential key confusion and value overwriting in dictionaries. All users parsing JSON from untrusted sources are vulnerable. From version 5.4.0, UltraJSON decodes lone surrogates in the same way as the standard library's `json` module does, preserving them in the parsed output. Users are advised to upgrade. There are no known workarounds for this issue.",
  "repo": "ultrajson/ultrajson",
  "patch_hash": "67ec07183342589d602e0fcf7bb1ff3e19272687",
  "patch_info": {
    "commit_hash": "67ec07183342589d602e0fcf7bb1ff3e19272687",
    "repo": "ultrajson/ultrajson",
    "commit_url": "https://github.com/ultrajson/ultrajson/commit/67ec07183342589d602e0fcf7bb1ff3e19272687",
    "files": [
      "lib/ultrajson.h",
      "lib/ultrajsondec.c",
      "python/JSONtoObj.c",
      "tests/test_ujson.py"
    ],
    "message": "Merge pull request #555 from JustAnotherArchivist/fix-decode-surrogates-2",
    "before_after_code_files": [
      "lib/ultrajson.h||lib/ultrajson.h",
      "lib/ultrajsondec.c||lib/ultrajsondec.c",
      "python/JSONtoObj.c||python/JSONtoObj.c",
      "tests/test_ujson.py||tests/test_ujson.py"
    ]
  },
  "patch_diff": {
    "lib/ultrajson.h||lib/ultrajson.h": [
      "File: lib/ultrajson.h -> lib/ultrajson.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "54: #define __ULTRAJSON_H__",
      "56: #include <stdio.h>",
      "60: #ifndef JSON_DOUBLE_MAX_DECIMALS",
      "",
      "[Removed Lines]",
      "57: #include <wchar.h>",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "319: typedef struct __JSONObjectDecoder",
      "320: {",
      "322:   void (*objectAddKey)(void *prv, JSOBJ obj, JSOBJ name, JSOBJ value);",
      "323:   void (*arrayAddItem)(void *prv, JSOBJ obj, JSOBJ value);",
      "324:   JSOBJ (*newTrue)(void *prv);",
      "",
      "[Removed Lines]",
      "321:   JSOBJ (*newString)(void *prv, wchar_t *start, wchar_t *end);",
      "",
      "[Added Lines]",
      "320:   JSOBJ (*newString)(void *prv, JSUINT32 *start, JSUINT32 *end);",
      "",
      "---------------"
    ],
    "lib/ultrajsondec.c||lib/ultrajsondec.c": [
      "File: lib/ultrajsondec.c -> lib/ultrajsondec.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "41: #include <assert.h>",
      "42: #include <string.h>",
      "43: #include <limits.h>",
      "45: #include <stdlib.h>",
      "46: #include <errno.h>",
      "47: #include <stdint.h>",
      "",
      "[Removed Lines]",
      "44: #include <wchar.h>",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "58: {",
      "59:   char *start;",
      "60:   char *end;",
      "63:   int escHeap;",
      "64:   int lastType;",
      "65:   JSUINT32 objDepth;",
      "",
      "[Removed Lines]",
      "61:   wchar_t *escStart;",
      "62:   wchar_t *escEnd;",
      "",
      "[Added Lines]",
      "60:   JSUINT32 *escStart;",
      "61:   JSUINT32 *escEnd;",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "361: static FASTCALL_ATTR JSOBJ FASTCALL_MSVC decode_string ( struct DecoderState *ds)",
      "362: {",
      "363:   int index;",
      "366:   size_t escLen = (ds->escEnd - ds->escStart);",
      "367:   JSUINT8 *inputOffset;",
      "368:   JSUTF16 ch = 0;",
      "370:   JSUINT8 *lastHighSurrogate = NULL;",
      "372:   JSUINT8 oct;",
      "373:   JSUTF32 ucs;",
      "374:   ds->lastType = JT_INVALID;",
      "",
      "[Removed Lines]",
      "364:   wchar_t *escOffset;",
      "365:   wchar_t *escStart;",
      "369: #if WCHAR_MAX >= 0x10FFFF",
      "371: #endif",
      "",
      "[Added Lines]",
      "363:   JSUINT32 *escOffset;",
      "364:   JSUINT32 *escStart;",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "381:     if (ds->escHeap)",
      "382:     {",
      "384:       {",
      "385:         return SetError(ds, -1, \"Could not reserve memory block\");",
      "386:       }",
      "388:       if (!escStart)",
      "389:       {",
      "390:         ds->dec->free(ds->escStart);",
      "",
      "[Removed Lines]",
      "383:       if (newSize > (SIZE_MAX / sizeof(wchar_t)))",
      "387:       escStart = (wchar_t *)ds->dec->realloc(ds->escStart, newSize * sizeof(wchar_t));",
      "",
      "[Added Lines]",
      "380:       if (newSize > (SIZE_MAX / sizeof(JSUINT32)))",
      "384:       escStart = (JSUINT32 *)ds->dec->realloc(ds->escStart, newSize * sizeof(JSUINT32));",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "394:     }",
      "395:     else",
      "396:     {",
      "399:       {",
      "400:         return SetError(ds, -1, \"Could not reserve memory block\");",
      "401:       }",
      "403:       if (!ds->escStart)",
      "404:       {",
      "405:         return SetError(ds, -1, \"Could not reserve memory block\");",
      "406:       }",
      "407:       ds->escHeap = 1;",
      "409:     }",
      "411:     ds->escEnd = ds->escStart + newSize;",
      "",
      "[Removed Lines]",
      "397:       wchar_t *oldStart = ds->escStart;",
      "398:       if (newSize > (SIZE_MAX / sizeof(wchar_t)))",
      "402:       ds->escStart = (wchar_t *) ds->dec->malloc(newSize * sizeof(wchar_t));",
      "408:       memcpy(ds->escStart, oldStart, escLen * sizeof(wchar_t));",
      "",
      "[Added Lines]",
      "394:       JSUINT32 *oldStart = ds->escStart;",
      "395:       if (newSize > (SIZE_MAX / sizeof(JSUINT32)))",
      "399:       ds->escStart = (JSUINT32 *) ds->dec->malloc(newSize * sizeof(JSUINT32));",
      "405:       memcpy(ds->escStart, oldStart, escLen * sizeof(JSUINT32));",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "438:         inputOffset ++;",
      "439:         switch (*inputOffset)",
      "440:         {",
      "450:           case 'u':",
      "451:           {",
      "",
      "[Removed Lines]",
      "441:           case '\\\\': *(escOffset++) = L'\\\\'; inputOffset++; continue;",
      "442:           case '\\\"': *(escOffset++) = L'\\\"'; inputOffset++; continue;",
      "443:           case '/':  *(escOffset++) = L'/';  inputOffset++; continue;",
      "444:           case 'b':  *(escOffset++) = L'\\b'; inputOffset++; continue;",
      "445:           case 'f':  *(escOffset++) = L'\\f'; inputOffset++; continue;",
      "446:           case 'n':  *(escOffset++) = L'\\n'; inputOffset++; continue;",
      "447:           case 'r':  *(escOffset++) = L'\\r'; inputOffset++; continue;",
      "448:           case 't':  *(escOffset++) = L'\\t'; inputOffset++; continue;",
      "",
      "[Added Lines]",
      "438:           case '\\\\': *(escOffset++) = '\\\\'; inputOffset++; continue;",
      "439:           case '\\\"': *(escOffset++) = '\\\"'; inputOffset++; continue;",
      "440:           case '/':  *(escOffset++) = '/';  inputOffset++; continue;",
      "441:           case 'b':  *(escOffset++) = '\\b'; inputOffset++; continue;",
      "442:           case 'f':  *(escOffset++) = '\\f'; inputOffset++; continue;",
      "443:           case 'n':  *(escOffset++) = '\\n'; inputOffset++; continue;",
      "444:           case 'r':  *(escOffset++) = '\\r'; inputOffset++; continue;",
      "445:           case 't':  *(escOffset++) = '\\t'; inputOffset++; continue;",
      "",
      "---------------",
      "--- Hunk 7 ---",
      "[Context before]",
      "494:               inputOffset ++;",
      "495:             }",
      "498:             if ((ch & 0xfc00) == 0xdc00 && lastHighSurrogate == inputOffset - 6 * sizeof(*inputOffset))",
      "499:             {",
      "",
      "[Removed Lines]",
      "497: #if WCHAR_MAX >= 0x10FFFF",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 8 ---",
      "[Context before]",
      "503:             }",
      "504:             else",
      "506:             {",
      "508:             }",
      "510:             if ((ch & 0xfc00) == 0xd800)",
      "511:             {",
      "512:               lastHighSurrogate = inputOffset;",
      "513:             }",
      "515:             break;",
      "516:           }",
      "",
      "[Removed Lines]",
      "505: #endif",
      "509: #if WCHAR_MAX >= 0x10FFFF",
      "514: #endif",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 9 ---",
      "[Context before]",
      "585:         if (ucs < 0x10000) return SetError (ds, -1, \"Overlong 4 byte UTF-8 sequence detected when decoding 'string'\");",
      "601:         break;",
      "602:       }",
      "603:     }",
      "",
      "[Removed Lines]",
      "587: #if WCHAR_MAX == 0xffff",
      "588:         if (ucs >= 0x10000)",
      "589:         {",
      "590:           ucs -= 0x10000;",
      "593:         }",
      "594:         else",
      "595:         {",
      "597:         }",
      "598: #else",
      "600: #endif",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 10 ---",
      "[Context before]",
      "812:   struct DecoderState ds;",
      "814:   JSOBJ ret;",
      "816:   ds.start = (char *) buffer;",
      "817:   ds.end = ds.start + cbBuffer;",
      "819:   ds.escStart = escBuffer;",
      "821:   ds.escHeap = 0;",
      "822:   ds.prv = dec->prv;",
      "823:   ds.dec = dec;",
      "",
      "[Removed Lines]",
      "813:   wchar_t escBuffer[(JSON_MAX_STACK_BUFFER_SIZE / sizeof(wchar_t))];",
      "820:   ds.escEnd = ds.escStart + (JSON_MAX_STACK_BUFFER_SIZE / sizeof(wchar_t));",
      "",
      "[Added Lines]",
      "793:   JSUINT32 escBuffer[(JSON_MAX_STACK_BUFFER_SIZE / sizeof(JSUINT32))];",
      "800:   ds.escEnd = ds.escStart + (JSON_MAX_STACK_BUFFER_SIZE / sizeof(JSUINT32));",
      "",
      "---------------"
    ],
    "python/JSONtoObj.c||python/JSONtoObj.c": [
      "File: python/JSONtoObj.c -> python/JSONtoObj.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "59:   return;",
      "60: }",
      "63: {",
      "65: }",
      "67: static JSOBJ Object_newTrue(void *prv)",
      "",
      "[Removed Lines]",
      "62: static JSOBJ Object_newString(void *prv, wchar_t *start, wchar_t *end)",
      "64:   return PyUnicode_FromWideChar (start, (end - start));",
      "",
      "[Added Lines]",
      "63: Check that Py_UCS4 is the same as JSUINT32, else Object_newString will fail.",
      "64: Based on Linux's check in vbox_vmmdev_types.h.",
      "65: This should be replaced with",
      "66:   _Static_assert(sizeof(Py_UCS4) == sizeof(JSUINT32));",
      "67: when C11 is made mandatory (CPython 3.11+, PyPy ?).",
      "69: typedef char assert_py_ucs4_is_jsuint32[1 - 2*!(sizeof(Py_UCS4) == sizeof(JSUINT32))];",
      "71: static JSOBJ Object_newString(void *prv, JSUINT32 *start, JSUINT32 *end)",
      "73:   return PyUnicode_FromKindAndData (PyUnicode_4BYTE_KIND, (Py_UCS4 *) start, (end - start));",
      "",
      "---------------"
    ],
    "tests/test_ujson.py||tests/test_ujson.py": [
      "File: tests/test_ujson.py -> tests/test_ujson.py",
      "--- Hunk 1 ---",
      "[Context before]",
      "2: import datetime as dt",
      "3: import decimal",
      "4: import io",
      "",
      "[Removed Lines]",
      "1: import ctypes",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "515:     assert ujson.dumps({\"\\ud800\": \"\\udfff\"}, ensure_ascii=False, sort_keys=True) == out2",
      "522: @pytest.mark.parametrize(",
      "523:     \"test_input, expected\",",
      "524:     [",
      "",
      "[Removed Lines]",
      "518: @pytest.mark.xfail(",
      "519:     hasattr(sys, \"pypy_version_info\") and os.name == \"nt\",",
      "520:     reason=\"This feature needs fixing! See #552\",",
      "521: )",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "543:     ],",
      "544: )",
      "545: def test_decode_surrogate_characters(test_input, expected):",
      "550:     assert ujson.loads(test_input) == expected",
      "551:     assert ujson.loads(test_input.encode(\"utf-8\", \"surrogatepass\")) == expected",
      "",
      "[Removed Lines]",
      "546:     # FIXME Wrong output (combined char) on platforms with 16-bit wchar_t",
      "547:     if test_input == '\"\\uD83D\\uDCA9\"' and ctypes.sizeof(ctypes.c_wchar) == 2:",
      "548:         pytest.skip(\"Raw surrogate pairs are not supported with 16-bit wchar_t\")",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "bc7bdff051e19188edf121c216b8250110abf39a",
      "candidate_info": {
        "commit_hash": "bc7bdff051e19188edf121c216b8250110abf39a",
        "repo": "ultrajson/ultrajson",
        "commit_url": "https://github.com/ultrajson/ultrajson/commit/bc7bdff051e19188edf121c216b8250110abf39a",
        "files": [
          "lib/ultrajson.h",
          "lib/ultrajsondec.c",
          "python/JSONtoObj.c",
          "tests/test_ujson.py"
        ],
        "message": "Replace wchar_t string decoding implementation with a uint32_t-based one\n\nThis fixes character handling on platforms with 16-bit wchar_t (notably, Windows), which was broken (in different ways) on both CPython and PyPy.\n\nFixes #552",
        "before_after_code_files": [
          "lib/ultrajson.h||lib/ultrajson.h",
          "lib/ultrajsondec.c||lib/ultrajsondec.c",
          "python/JSONtoObj.c||python/JSONtoObj.c",
          "tests/test_ujson.py||tests/test_ujson.py"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/ultrajson/ultrajson/pull/555"
        ],
        "olp_code_files": {
          "patch": [
            "lib/ultrajson.h||lib/ultrajson.h",
            "lib/ultrajsondec.c||lib/ultrajsondec.c",
            "python/JSONtoObj.c||python/JSONtoObj.c",
            "tests/test_ujson.py||tests/test_ujson.py"
          ],
          "candidate": [
            "lib/ultrajson.h||lib/ultrajson.h",
            "lib/ultrajsondec.c||lib/ultrajsondec.c",
            "python/JSONtoObj.c||python/JSONtoObj.c",
            "tests/test_ujson.py||tests/test_ujson.py"
          ]
        }
      },
      "candidate_diff": {
        "lib/ultrajson.h||lib/ultrajson.h": [
          "File: lib/ultrajson.h -> lib/ultrajson.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "54: #define __ULTRAJSON_H__",
          "56: #include <stdio.h>",
          "60: #ifndef JSON_DOUBLE_MAX_DECIMALS",
          "",
          "[Removed Lines]",
          "57: #include <wchar.h>",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "319: typedef struct __JSONObjectDecoder",
          "320: {",
          "322:   void (*objectAddKey)(void *prv, JSOBJ obj, JSOBJ name, JSOBJ value);",
          "323:   void (*arrayAddItem)(void *prv, JSOBJ obj, JSOBJ value);",
          "324:   JSOBJ (*newTrue)(void *prv);",
          "",
          "[Removed Lines]",
          "321:   JSOBJ (*newString)(void *prv, wchar_t *start, wchar_t *end);",
          "",
          "[Added Lines]",
          "320:   JSOBJ (*newString)(void *prv, JSUINT32 *start, JSUINT32 *end);",
          "",
          "---------------"
        ],
        "lib/ultrajsondec.c||lib/ultrajsondec.c": [
          "File: lib/ultrajsondec.c -> lib/ultrajsondec.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "41: #include <assert.h>",
          "42: #include <string.h>",
          "43: #include <limits.h>",
          "45: #include <stdlib.h>",
          "46: #include <errno.h>",
          "47: #include <stdint.h>",
          "",
          "[Removed Lines]",
          "44: #include <wchar.h>",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "58: {",
          "59:   char *start;",
          "60:   char *end;",
          "63:   int escHeap;",
          "64:   int lastType;",
          "65:   JSUINT32 objDepth;",
          "",
          "[Removed Lines]",
          "61:   wchar_t *escStart;",
          "62:   wchar_t *escEnd;",
          "",
          "[Added Lines]",
          "60:   JSUINT32 *escStart;",
          "61:   JSUINT32 *escEnd;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "361: static FASTCALL_ATTR JSOBJ FASTCALL_MSVC decode_string ( struct DecoderState *ds)",
          "362: {",
          "363:   int index;",
          "366:   size_t escLen = (ds->escEnd - ds->escStart);",
          "367:   JSUINT8 *inputOffset;",
          "368:   JSUTF16 ch = 0;",
          "370:   JSUINT8 *lastHighSurrogate = NULL;",
          "372:   JSUINT8 oct;",
          "373:   JSUTF32 ucs;",
          "374:   ds->lastType = JT_INVALID;",
          "",
          "[Removed Lines]",
          "364:   wchar_t *escOffset;",
          "365:   wchar_t *escStart;",
          "369: #if WCHAR_MAX >= 0x10FFFF",
          "371: #endif",
          "",
          "[Added Lines]",
          "363:   JSUINT32 *escOffset;",
          "364:   JSUINT32 *escStart;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "381:     if (ds->escHeap)",
          "382:     {",
          "384:       {",
          "385:         return SetError(ds, -1, \"Could not reserve memory block\");",
          "386:       }",
          "388:       if (!escStart)",
          "389:       {",
          "390:         ds->dec->free(ds->escStart);",
          "",
          "[Removed Lines]",
          "383:       if (newSize > (SIZE_MAX / sizeof(wchar_t)))",
          "387:       escStart = (wchar_t *)ds->dec->realloc(ds->escStart, newSize * sizeof(wchar_t));",
          "",
          "[Added Lines]",
          "380:       if (newSize > (SIZE_MAX / sizeof(JSUINT32)))",
          "384:       escStart = (JSUINT32 *)ds->dec->realloc(ds->escStart, newSize * sizeof(JSUINT32));",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "394:     }",
          "395:     else",
          "396:     {",
          "399:       {",
          "400:         return SetError(ds, -1, \"Could not reserve memory block\");",
          "401:       }",
          "403:       if (!ds->escStart)",
          "404:       {",
          "405:         return SetError(ds, -1, \"Could not reserve memory block\");",
          "406:       }",
          "407:       ds->escHeap = 1;",
          "409:     }",
          "411:     ds->escEnd = ds->escStart + newSize;",
          "",
          "[Removed Lines]",
          "397:       wchar_t *oldStart = ds->escStart;",
          "398:       if (newSize > (SIZE_MAX / sizeof(wchar_t)))",
          "402:       ds->escStart = (wchar_t *) ds->dec->malloc(newSize * sizeof(wchar_t));",
          "408:       memcpy(ds->escStart, oldStart, escLen * sizeof(wchar_t));",
          "",
          "[Added Lines]",
          "394:       JSUINT32 *oldStart = ds->escStart;",
          "395:       if (newSize > (SIZE_MAX / sizeof(JSUINT32)))",
          "399:       ds->escStart = (JSUINT32 *) ds->dec->malloc(newSize * sizeof(JSUINT32));",
          "405:       memcpy(ds->escStart, oldStart, escLen * sizeof(JSUINT32));",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "438:         inputOffset ++;",
          "439:         switch (*inputOffset)",
          "440:         {",
          "450:           case 'u':",
          "451:           {",
          "",
          "[Removed Lines]",
          "441:           case '\\\\': *(escOffset++) = L'\\\\'; inputOffset++; continue;",
          "442:           case '\\\"': *(escOffset++) = L'\\\"'; inputOffset++; continue;",
          "443:           case '/':  *(escOffset++) = L'/';  inputOffset++; continue;",
          "444:           case 'b':  *(escOffset++) = L'\\b'; inputOffset++; continue;",
          "445:           case 'f':  *(escOffset++) = L'\\f'; inputOffset++; continue;",
          "446:           case 'n':  *(escOffset++) = L'\\n'; inputOffset++; continue;",
          "447:           case 'r':  *(escOffset++) = L'\\r'; inputOffset++; continue;",
          "448:           case 't':  *(escOffset++) = L'\\t'; inputOffset++; continue;",
          "",
          "[Added Lines]",
          "438:           case '\\\\': *(escOffset++) = '\\\\'; inputOffset++; continue;",
          "439:           case '\\\"': *(escOffset++) = '\\\"'; inputOffset++; continue;",
          "440:           case '/':  *(escOffset++) = '/';  inputOffset++; continue;",
          "441:           case 'b':  *(escOffset++) = '\\b'; inputOffset++; continue;",
          "442:           case 'f':  *(escOffset++) = '\\f'; inputOffset++; continue;",
          "443:           case 'n':  *(escOffset++) = '\\n'; inputOffset++; continue;",
          "444:           case 'r':  *(escOffset++) = '\\r'; inputOffset++; continue;",
          "445:           case 't':  *(escOffset++) = '\\t'; inputOffset++; continue;",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "494:               inputOffset ++;",
          "495:             }",
          "498:             if ((ch & 0xfc00) == 0xdc00 && lastHighSurrogate == inputOffset - 6 * sizeof(*inputOffset))",
          "499:             {",
          "",
          "[Removed Lines]",
          "497: #if WCHAR_MAX >= 0x10FFFF",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "503:             }",
          "504:             else",
          "506:             {",
          "508:             }",
          "510:             if ((ch & 0xfc00) == 0xd800)",
          "511:             {",
          "512:               lastHighSurrogate = inputOffset;",
          "513:             }",
          "515:             break;",
          "516:           }",
          "",
          "[Removed Lines]",
          "505: #endif",
          "509: #if WCHAR_MAX >= 0x10FFFF",
          "514: #endif",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "585:         if (ucs < 0x10000) return SetError (ds, -1, \"Overlong 4 byte UTF-8 sequence detected when decoding 'string'\");",
          "601:         break;",
          "602:       }",
          "603:     }",
          "",
          "[Removed Lines]",
          "587: #if WCHAR_MAX == 0xffff",
          "588:         if (ucs >= 0x10000)",
          "589:         {",
          "590:           ucs -= 0x10000;",
          "593:         }",
          "594:         else",
          "595:         {",
          "597:         }",
          "598: #else",
          "600: #endif",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "812:   struct DecoderState ds;",
          "814:   JSOBJ ret;",
          "816:   ds.start = (char *) buffer;",
          "817:   ds.end = ds.start + cbBuffer;",
          "819:   ds.escStart = escBuffer;",
          "821:   ds.escHeap = 0;",
          "822:   ds.prv = dec->prv;",
          "823:   ds.dec = dec;",
          "",
          "[Removed Lines]",
          "813:   wchar_t escBuffer[(JSON_MAX_STACK_BUFFER_SIZE / sizeof(wchar_t))];",
          "820:   ds.escEnd = ds.escStart + (JSON_MAX_STACK_BUFFER_SIZE / sizeof(wchar_t));",
          "",
          "[Added Lines]",
          "793:   JSUINT32 escBuffer[(JSON_MAX_STACK_BUFFER_SIZE / sizeof(JSUINT32))];",
          "800:   ds.escEnd = ds.escStart + (JSON_MAX_STACK_BUFFER_SIZE / sizeof(JSUINT32));",
          "",
          "---------------"
        ],
        "python/JSONtoObj.c||python/JSONtoObj.c": [
          "File: python/JSONtoObj.c -> python/JSONtoObj.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "59:   return;",
          "60: }",
          "63: {",
          "65: }",
          "67: static JSOBJ Object_newTrue(void *prv)",
          "",
          "[Removed Lines]",
          "62: static JSOBJ Object_newString(void *prv, wchar_t *start, wchar_t *end)",
          "64:   return PyUnicode_FromWideChar (start, (end - start));",
          "",
          "[Added Lines]",
          "63: Check that Py_UCS4 is the same as JSUINT32, else Object_newString will fail.",
          "64: Based on Linux's check in vbox_vmmdev_types.h.",
          "65: This should be replaced with",
          "66:   _Static_assert(sizeof(Py_UCS4) == sizeof(JSUINT32));",
          "67: when C11 is made mandatory (CPython 3.11+, PyPy ?).",
          "69: typedef char assert_py_ucs4_is_jsuint32[1 - 2*!(sizeof(Py_UCS4) == sizeof(JSUINT32))];",
          "71: static JSOBJ Object_newString(void *prv, JSUINT32 *start, JSUINT32 *end)",
          "73:   return PyUnicode_FromKindAndData (PyUnicode_4BYTE_KIND, (Py_UCS4 *) start, (end - start));",
          "",
          "---------------"
        ],
        "tests/test_ujson.py||tests/test_ujson.py": [
          "File: tests/test_ujson.py -> tests/test_ujson.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "2: import datetime as dt",
          "3: import decimal",
          "4: import io",
          "",
          "[Removed Lines]",
          "1: import ctypes",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "515:     assert ujson.dumps({\"\\ud800\": \"\\udfff\"}, ensure_ascii=False, sort_keys=True) == out2",
          "522: @pytest.mark.parametrize(",
          "523:     \"test_input, expected\",",
          "524:     [",
          "",
          "[Removed Lines]",
          "518: @pytest.mark.xfail(",
          "519:     hasattr(sys, \"pypy_version_info\") and os.name == \"nt\",",
          "520:     reason=\"This feature needs fixing! See #552\",",
          "521: )",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "543:     ],",
          "544: )",
          "545: def test_decode_surrogate_characters(test_input, expected):",
          "550:     assert ujson.loads(test_input) == expected",
          "551:     assert ujson.loads(test_input.encode(\"utf-8\", \"surrogatepass\")) == expected",
          "",
          "[Removed Lines]",
          "546:     # FIXME Wrong output (combined char) on platforms with 16-bit wchar_t",
          "547:     if test_input == '\"\\uD83D\\uDCA9\"' and ctypes.sizeof(ctypes.c_wchar) == 2:",
          "548:         pytest.skip(\"Raw surrogate pairs are not supported with 16-bit wchar_t\")",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    }
  ]
}
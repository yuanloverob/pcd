{
  "cve_id": "CVE-2014-0063",
  "cve_desc": "Multiple stack-based buffer overflows in PostgreSQL before 8.4.20, 9.0.x before 9.0.16, 9.1.x before 9.1.12, 9.2.x before 9.2.7, and 9.3.x before 9.3.3 allow remote authenticated users to cause a denial of service (crash) or possibly execute arbitrary code via vectors related to an incorrect MAXDATELEN constant and datetime values involving (1) intervals, (2) timestamps, or (3) timezones, a different vulnerability than CVE-2014-0065.",
  "repo": "postgres/postgres",
  "patch_hash": "4318daecc959886d001a6e79c6ea853e8b1dfb4b",
  "patch_info": {
    "commit_hash": "4318daecc959886d001a6e79c6ea853e8b1dfb4b",
    "repo": "postgres/postgres",
    "commit_url": "https://github.com/postgres/postgres/commit/4318daecc959886d001a6e79c6ea853e8b1dfb4b",
    "files": [
      "src/include/utils/datetime.h",
      "src/interfaces/ecpg/pgtypeslib/datetime.c",
      "src/interfaces/ecpg/pgtypeslib/dt.h",
      "src/interfaces/ecpg/pgtypeslib/dt_common.c",
      "src/interfaces/ecpg/pgtypeslib/interval.c",
      "src/interfaces/ecpg/pgtypeslib/timestamp.c",
      "src/interfaces/ecpg/test/expected/pgtypeslib-dt_test2.c",
      "src/interfaces/ecpg/test/expected/pgtypeslib-dt_test2.stdout",
      "src/interfaces/ecpg/test/pgtypeslib/dt_test2.pgc",
      "src/test/regress/expected/interval.out",
      "src/test/regress/sql/interval.sql"
    ],
    "message": "Fix handling of wide datetime input/output.\n\nMany server functions use the MAXDATELEN constant to size a buffer for\nparsing or displaying a datetime value.  It was much too small for the\nlongest possible interval output and slightly too small for certain\nvalid timestamp input, particularly input with a long timezone name.\nThe long input was rejected needlessly; the long output caused\ninterval_out() to overrun its buffer.  ECPG's pgtypes library has a copy\nof the vulnerable functions, which bore the same vulnerabilities along\nwith some of its own.  In contrast to the server, certain long inputs\ncaused stack overflow rather than failing cleanly.  Back-patch to 8.4\n(all supported versions).\n\nReported by Daniel Sch\u00fcssler, reviewed by Tom Lane.\n\nSecurity: CVE-2014-0063",
    "before_after_code_files": [
      "src/include/utils/datetime.h||src/include/utils/datetime.h",
      "src/interfaces/ecpg/pgtypeslib/datetime.c||src/interfaces/ecpg/pgtypeslib/datetime.c",
      "src/interfaces/ecpg/pgtypeslib/dt.h||src/interfaces/ecpg/pgtypeslib/dt.h",
      "src/interfaces/ecpg/pgtypeslib/dt_common.c||src/interfaces/ecpg/pgtypeslib/dt_common.c",
      "src/interfaces/ecpg/pgtypeslib/interval.c||src/interfaces/ecpg/pgtypeslib/interval.c",
      "src/interfaces/ecpg/pgtypeslib/timestamp.c||src/interfaces/ecpg/pgtypeslib/timestamp.c",
      "src/interfaces/ecpg/test/expected/pgtypeslib-dt_test2.c||src/interfaces/ecpg/test/expected/pgtypeslib-dt_test2.c",
      "src/interfaces/ecpg/test/expected/pgtypeslib-dt_test2.stdout||src/interfaces/ecpg/test/expected/pgtypeslib-dt_test2.stdout",
      "src/interfaces/ecpg/test/pgtypeslib/dt_test2.pgc||src/interfaces/ecpg/test/pgtypeslib/dt_test2.pgc",
      "src/test/regress/sql/interval.sql||src/test/regress/sql/interval.sql"
    ]
  },
  "patch_diff": {
    "src/include/utils/datetime.h||src/include/utils/datetime.h": [
      "File: src/include/utils/datetime.h -> src/include/utils/datetime.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "188: #define DTK_DATE_M  (DTK_M(YEAR) | DTK_M(MONTH) | DTK_M(DAY))",
      "189: #define DTK_TIME_M  (DTK_M(HOUR) | DTK_M(MINUTE) | DTK_ALL_SECS_M)",
      "199: typedef struct",
      "",
      "[Removed Lines]",
      "191: #define MAXDATELEN  63  /* maximum possible length of an input date",
      "193: #define MAXDATEFIELDS 25  /* maximum possible number of fields in a date",
      "195: #define TOKMAXLEN  10  /* only this many chars are stored in",
      "",
      "[Added Lines]",
      "197: #define MAXDATELEN  128",
      "199: #define MAXDATEFIELDS 25",
      "201: #define TOKMAXLEN  10",
      "",
      "---------------"
    ],
    "src/interfaces/ecpg/pgtypeslib/datetime.c||src/interfaces/ecpg/pgtypeslib/datetime.c": [
      "File: src/interfaces/ecpg/pgtypeslib/datetime.c -> src/interfaces/ecpg/pgtypeslib/datetime.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "60:  int   nf;",
      "61:  char    *field[MAXDATEFIELDS];",
      "62:  int   ftype[MAXDATEFIELDS];",
      "64:  char    *realptr;",
      "65:  char   **ptr = (endptr != NULL) ? endptr : &realptr;",
      "67:  bool  EuroDates = FALSE;",
      "69:  errno = 0;",
      "71:  {",
      "72:   errno = PGTYPES_DATE_BAD_DATE;",
      "73:   return INT_MIN;",
      "",
      "[Removed Lines]",
      "63:  char  lowstr[MAXDATELEN + 1];",
      "70:  if (strlen(str) >= sizeof(lowstr))",
      "",
      "[Added Lines]",
      "63:  char  lowstr[MAXDATELEN + MAXDATEFIELDS];",
      "70:  if (strlen(str) > MAXDATELEN)",
      "",
      "---------------"
    ],
    "src/interfaces/ecpg/pgtypeslib/dt.h||src/interfaces/ecpg/pgtypeslib/dt.h": [
      "File: src/interfaces/ecpg/pgtypeslib/dt.h -> src/interfaces/ecpg/pgtypeslib/dt.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "192: #define DTK_DATE_M  (DTK_M(YEAR) | DTK_M(MONTH) | DTK_M(DAY))",
      "193: #define DTK_TIME_M  (DTK_M(HOUR) | DTK_M(MINUTE) | DTK_M(SECOND))",
      "203: typedef struct",
      "",
      "[Removed Lines]",
      "195: #define MAXDATELEN  63  /* maximum possible length of an input date",
      "197: #define MAXDATEFIELDS 25  /* maximum possible number of fields in a date",
      "199: #define TOKMAXLEN  10  /* only this many chars are stored in",
      "",
      "[Added Lines]",
      "201: #define MAXDATELEN  128",
      "203: #define MAXDATEFIELDS 25",
      "205: #define TOKMAXLEN  10",
      "",
      "---------------"
    ],
    "src/interfaces/ecpg/pgtypeslib/dt_common.c||src/interfaces/ecpg/pgtypeslib/dt_common.c": [
      "File: src/interfaces/ecpg/pgtypeslib/dt_common.c -> src/interfaces/ecpg/pgtypeslib/dt_common.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "1171:  if ((cp = strchr(str, '.')) != NULL)",
      "1172:  {",
      "1173: #ifdef HAVE_INT64_TIMESTAMP",
      "1184: #else",
      "",
      "[Removed Lines]",
      "1174:   char  fstr[MAXDATELEN + 1];",
      "1180:   strcpy(fstr, (cp + 1));",
      "1181:   strcpy(fstr + strlen(fstr), \"000000\");",
      "",
      "[Added Lines]",
      "1174:   char  fstr[7];",
      "1175:   int   i;",
      "1177:   cp++;",
      "1187:   for (i = 0; i < 6; i++)",
      "1188:    fstr[i] = *cp != '\\0' ? *cp++ : '0';",
      "1189:   fstr[i] = '\\0';",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "1531:   else if (*cp == '.')",
      "1532:   {",
      "1533: #ifdef HAVE_INT64_TIMESTAMP",
      "1544: #else",
      "1545:    str = cp;",
      "",
      "[Removed Lines]",
      "1534:    char  fstr[MAXDATELEN + 1];",
      "1540:    strncpy(fstr, (cp + 1), 7);",
      "1541:    strcpy(fstr + strlen(fstr), \"000000\");",
      "",
      "[Added Lines]",
      "1541:    char  fstr[7];",
      "1542:    int   i;",
      "1544:    cp++;",
      "1554:    for (i = 0; i < 6; i++)",
      "1555:     fstr[i] = *cp != '\\0' ? *cp++ : '0';",
      "1556:    fstr[i] = '\\0';",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "1678:  while (*(*endstr) != '\\0')",
      "1679:  {",
      "1680:   field[nf] = lp;",
      "1683:   if (isdigit((unsigned char) *(*endstr)))",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1699:   if (nf >= MAXDATEFIELDS)",
      "1700:    return -1;",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "1820:   nf++;",
      "1823:  }",
      "",
      "[Removed Lines]",
      "1821:   if (nf > MAXDATEFIELDS)",
      "1822:    return -1;",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ],
    "src/interfaces/ecpg/pgtypeslib/interval.c||src/interfaces/ecpg/pgtypeslib/interval.c": [
      "File: src/interfaces/ecpg/pgtypeslib/interval.c -> src/interfaces/ecpg/pgtypeslib/interval.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "1094:  tm->tm_sec = 0;",
      "1095:  fsec = 0;",
      "1098:  {",
      "1099:   errno = PGTYPES_INTVL_BAD_INTERVAL;",
      "1100:   return NULL;",
      "",
      "[Removed Lines]",
      "1097:  if (strlen(str) >= sizeof(lowstr))",
      "",
      "[Added Lines]",
      "1097:  if (strlen(str) > MAXDATELEN)",
      "",
      "---------------"
    ],
    "src/interfaces/ecpg/pgtypeslib/timestamp.c||src/interfaces/ecpg/pgtypeslib/timestamp.c": [
      "File: src/interfaces/ecpg/pgtypeslib/timestamp.c -> src/interfaces/ecpg/pgtypeslib/timestamp.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "294:  char    *realptr;",
      "295:  char   **ptr = (endptr != NULL) ? endptr : &realptr;",
      "298:  {",
      "299:   errno = PGTYPES_TS_BAD_TIMESTAMP;",
      "300:   return (noresult);",
      "",
      "[Removed Lines]",
      "297:  if (strlen(str) >= sizeof(lowstr))",
      "",
      "[Added Lines]",
      "297:  if (strlen(str) > MAXDATELEN)",
      "",
      "---------------"
    ],
    "src/interfaces/ecpg/test/expected/pgtypeslib-dt_test2.c||src/interfaces/ecpg/test/expected/pgtypeslib-dt_test2.c": [
      "File: src/interfaces/ecpg/test/expected/pgtypeslib-dt_test2.c -> src/interfaces/ecpg/test/expected/pgtypeslib-dt_test2.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "45:       \"1999.008\",",
      "46:       \"J2451187\",",
      "47:       \"January 8, 99 BC\",",
      "48:       NULL };",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "52:       \"........................Xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"",
      "53:       \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",",
      "55:       \".........................aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"",
      "56:       \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "52:       \"1:59 PDT\",",
      "53:       \"13:24:40 -8:00\",",
      "54:       \"13:24:40.495+3\",",
      "55:       NULL };",
      "57: char *intervals[] = { \"1 minute\",",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "64:       \"13:24:40.123456789+3\",",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "77:  date date1 ;",
      "80:  timestamp ts1 , ts2 ;",
      "83:  char * text ;",
      "86:  interval * i1 ;",
      "89:  date * dc ;",
      "94:  int i, j;",
      "",
      "[Removed Lines]",
      "76: #line 52 \"dt_test2.pgc\"",
      "79: #line 53 \"dt_test2.pgc\"",
      "82: #line 54 \"dt_test2.pgc\"",
      "85: #line 55 \"dt_test2.pgc\"",
      "88: #line 56 \"dt_test2.pgc\"",
      "91: #line 57 \"dt_test2.pgc\"",
      "",
      "[Added Lines]",
      "86: #line 62 \"dt_test2.pgc\"",
      "89: #line 63 \"dt_test2.pgc\"",
      "92: #line 64 \"dt_test2.pgc\"",
      "95: #line 65 \"dt_test2.pgc\"",
      "98: #line 66 \"dt_test2.pgc\"",
      "101: #line 67 \"dt_test2.pgc\"",
      "",
      "---------------"
    ],
    "src/interfaces/ecpg/test/expected/pgtypeslib-dt_test2.stdout||src/interfaces/ecpg/test/expected/pgtypeslib-dt_test2.stdout": [
      "File: src/interfaces/ecpg/test/expected/pgtypeslib-dt_test2.stdout -> src/interfaces/ecpg/test/expected/pgtypeslib-dt_test2.stdout",
      "--- Hunk 1 ---",
      "[Context before]",
      "8: TS[3,1]: 1999-01-08 01:59:00",
      "9: TS[3,2]: 1999-01-08 13:24:40",
      "10: TS[3,3]: 1999-01-08 13:24:40.495",
      "11: Date[4]: 1999-01-08 (N - F)",
      "12: TS[4,0]: 1999-01-08 00:04:00",
      "13: TS[4,1]: 1999-01-08 01:59:00",
      "14: TS[4,2]: 1999-01-08 13:24:40",
      "15: TS[4,3]: 1999-01-08 13:24:40.495",
      "16: Date[5]: 1999-01-08 (N - F)",
      "17: TS[5,0]: 1999-01-08 00:04:00",
      "18: TS[5,1]: 1999-01-08 01:59:00",
      "19: TS[5,2]: 1999-01-08 13:24:40",
      "20: TS[5,3]: 1999-01-08 13:24:40.495",
      "21: Date[6]: 1999-01-18 (N - F)",
      "22: TS[6,0]: 1999-01-18 00:04:00",
      "23: TS[6,1]: 1999-01-18 01:59:00",
      "24: TS[6,2]: 1999-01-18 13:24:40",
      "25: TS[6,3]: 1999-01-18 13:24:40.495",
      "26: Date[7]: 2003-01-02 (N - F)",
      "27: TS[7,0]: 2003-01-02 00:04:00",
      "28: TS[7,1]: 2003-01-02 01:59:00",
      "29: TS[7,2]: 2003-01-02 13:24:40",
      "30: TS[7,3]: 2003-01-02 13:24:40.495",
      "31: Date[8]: 1999-01-08 (N - F)",
      "32: TS[8,0]: 1999-01-08 00:04:00",
      "33: TS[8,1]: 1999-01-08 01:59:00",
      "34: TS[8,2]: 1999-01-08 13:24:40",
      "35: TS[8,3]: 1999-01-08 13:24:40.495",
      "36: Date[9]: 1999-01-08 (N - F)",
      "37: TS[9,0]: 1999-01-08 00:04:00",
      "38: TS[9,1]: 1999-01-08 01:59:00",
      "39: TS[9,2]: 1999-01-08 13:24:40",
      "40: TS[9,3]: 1999-01-08 13:24:40.495",
      "41: Date[10]: 1999-01-08 (N - F)",
      "42: TS[10,0]: 1999-01-08 00:04:00",
      "43: TS[10,1]: 1999-01-08 01:59:00",
      "44: TS[10,2]: 1999-01-08 13:24:40",
      "45: TS[10,3]: 1999-01-08 13:24:40.495",
      "46: Date[11]: 1999-01-08 (N - F)",
      "47: TS[11,0]: 1999-01-08 00:04:00",
      "48: TS[11,1]: 1999-01-08 01:59:00",
      "49: TS[11,2]: 1999-01-08 13:24:40",
      "50: TS[11,3]: 1999-01-08 13:24:40.495",
      "51: Date[12]: 1999-01-08 (N - F)",
      "52: TS[12,0]: 1999-01-08 00:04:00",
      "53: TS[12,1]: 1999-01-08 01:59:00",
      "54: TS[12,2]: 1999-01-08 13:24:40",
      "55: TS[12,3]: 1999-01-08 13:24:40.495",
      "56: Date[13]: 2006-01-08 (N - F)",
      "57: TS[13,0]: 2006-01-08 00:04:00",
      "58: TS[13,1]: 2006-01-08 01:59:00",
      "59: TS[13,2]: 2006-01-08 13:24:40",
      "60: TS[13,3]: 2006-01-08 13:24:40.495",
      "61: Date[14]: 1999-01-08 (N - F)",
      "62: TS[14,0]: 1999-01-08 00:04:00",
      "63: TS[14,1]: 1999-01-08 01:59:00",
      "64: TS[14,2]: 1999-01-08 13:24:40",
      "65: TS[14,3]: 1999-01-08 13:24:40.495",
      "66: Date[15]: 1999-01-08 (N - F)",
      "67: TS[15,0]: 1999-01-08 00:04:00",
      "68: TS[15,1]: 1999-01-08 01:59:00",
      "69: TS[15,2]: 1999-01-08 13:24:40",
      "70: TS[15,3]: 1999-01-08 13:24:40.495",
      "71: Date[16]: 1999-01-08 (N - F)",
      "72: TS[16,0]: 1999-01-08 00:04:00",
      "73: TS[16,1]: 1999-01-08 01:59:00",
      "74: TS[16,2]: 1999-01-08 13:24:40",
      "75: TS[16,3]: 1999-01-08 13:24:40.495",
      "76: Date[17]: 1999-01-08 (N - F)",
      "77: TS[17,0]: 1999-01-08 00:04:00",
      "78: TS[17,1]: 1999-01-08 01:59:00",
      "79: TS[17,2]: 1999-01-08 13:24:40",
      "80: TS[17,3]: 1999-01-08 13:24:40.495",
      "81: Date[18]: 1999-01-08 (N - F)",
      "82: TS[18,0]: 1999-01-08 00:04:00",
      "83: TS[18,1]: 1999-01-08 01:59:00",
      "84: TS[18,2]: 1999-01-08 13:24:40",
      "85: TS[18,3]: 1999-01-08 13:24:40.495",
      "86: Date[19]: 0099-01-08 BC (N - F)",
      "87: TS[19,0]: 0099-01-08 00:04:00 BC",
      "88: TS[19,1]: 0099-01-08 01:59:00 BC",
      "89: TS[19,2]: 0099-01-08 13:24:40 BC",
      "90: interval[0]: @ 1 min",
      "91: interval_copy[0]: @ 1 min",
      "92: interval[1]: @ 1 day 12 hours 59 mins 10 secs",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "11: TS[3,4]: 1999-01-08 13:24:40.123456",
      "17: TS[4,4]: 1999-01-08 13:24:40.123456",
      "23: TS[5,4]: 1999-01-08 13:24:40.123456",
      "29: TS[6,4]: 1999-01-18 13:24:40.123456",
      "35: TS[7,4]: 2003-01-02 13:24:40.123456",
      "41: TS[8,4]: 1999-01-08 13:24:40.123456",
      "47: TS[9,4]: 1999-01-08 13:24:40.123456",
      "53: TS[10,4]: 1999-01-08 13:24:40.123456",
      "59: TS[11,4]: 1999-01-08 13:24:40.123456",
      "65: TS[12,4]: 1999-01-08 13:24:40.123456",
      "71: TS[13,4]: 2006-01-08 13:24:40.123456",
      "77: TS[14,4]: 1999-01-08 13:24:40.123456",
      "83: TS[15,4]: 1999-01-08 13:24:40.123456",
      "89: TS[16,4]: 1999-01-08 13:24:40.123456",
      "95: TS[17,4]: 1999-01-08 13:24:40.123456",
      "101: TS[18,4]: 1999-01-08 13:24:40.123456",
      "106: TS[19,4]: 0099-01-08 13:24:40.123456 BC",
      "107: Date[20]: - (N - T)",
      "108: Date[21]: - (N - T)",
      "",
      "---------------"
    ],
    "src/interfaces/ecpg/test/pgtypeslib/dt_test2.pgc||src/interfaces/ecpg/test/pgtypeslib/dt_test2.pgc": [
      "File: src/interfaces/ecpg/test/pgtypeslib/dt_test2.pgc -> src/interfaces/ecpg/test/pgtypeslib/dt_test2.pgc",
      "--- Hunk 1 ---",
      "[Context before]",
      "27:       \"1999.008\",",
      "28:       \"J2451187\",",
      "29:       \"January 8, 99 BC\",",
      "30:       NULL };",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "34:       \"........................Xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"",
      "35:       \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",",
      "37:       \".........................aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"",
      "38:       \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "34:       \"1:59 PDT\",",
      "35:       \"13:24:40 -8:00\",",
      "36:       \"13:24:40.495+3\",",
      "37:       NULL };",
      "39: char *intervals[] = { \"1 minute\",",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "46:       \"13:24:40.123456789+3\",",
      "",
      "---------------"
    ],
    "src/test/regress/sql/interval.sql||src/test/regress/sql/interval.sql": [
      "File: src/test/regress/sql/interval.sql -> src/test/regress/sql/interval.sql",
      "--- Hunk 1 ---",
      "[Context before]",
      "108: -- test long interval input",
      "109: select '4 millenniums 5 centuries 4 decades 1 year 4 months 4 days 17 minutes 31 seconds'::interval;",
      "112: -- test justify_hours() and justify_days()",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "111: -- test long interval output",
      "112: select '100000000y 10mon -1000000000d -1000000000h -10min -10.000001s ago'::interval;",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "f416622be81d1320417bbc7892fd562cae0dba72",
      "candidate_info": {
        "commit_hash": "f416622be81d1320417bbc7892fd562cae0dba72",
        "repo": "postgres/postgres",
        "commit_url": "https://github.com/postgres/postgres/commit/f416622be81d1320417bbc7892fd562cae0dba72",
        "files": [
          "src/include/utils/datetime.h",
          "src/interfaces/ecpg/pgtypeslib/datetime.c",
          "src/interfaces/ecpg/pgtypeslib/dt.h",
          "src/interfaces/ecpg/pgtypeslib/dt_common.c",
          "src/interfaces/ecpg/pgtypeslib/interval.c",
          "src/interfaces/ecpg/pgtypeslib/timestamp.c",
          "src/interfaces/ecpg/test/expected/pgtypeslib-dt_test2.c",
          "src/interfaces/ecpg/test/expected/pgtypeslib-dt_test2.stdout",
          "src/interfaces/ecpg/test/pgtypeslib/dt_test2.pgc",
          "src/test/regress/expected/interval.out",
          "src/test/regress/sql/interval.sql"
        ],
        "message": "Fix handling of wide datetime input/output.\n\nMany server functions use the MAXDATELEN constant to size a buffer for\nparsing or displaying a datetime value.  It was much too small for the\nlongest possible interval output and slightly too small for certain\nvalid timestamp input, particularly input with a long timezone name.\nThe long input was rejected needlessly; the long output caused\ninterval_out() to overrun its buffer.  ECPG's pgtypes library has a copy\nof the vulnerable functions, which bore the same vulnerabilities along\nwith some of its own.  In contrast to the server, certain long inputs\ncaused stack overflow rather than failing cleanly.  Back-patch to 8.4\n(all supported versions).\n\nReported by Daniel Sch\u00fcssler, reviewed by Tom Lane.\n\nSecurity: CVE-2014-0063",
        "before_after_code_files": [
          "src/include/utils/datetime.h||src/include/utils/datetime.h",
          "src/interfaces/ecpg/pgtypeslib/datetime.c||src/interfaces/ecpg/pgtypeslib/datetime.c",
          "src/interfaces/ecpg/pgtypeslib/dt.h||src/interfaces/ecpg/pgtypeslib/dt.h",
          "src/interfaces/ecpg/pgtypeslib/dt_common.c||src/interfaces/ecpg/pgtypeslib/dt_common.c",
          "src/interfaces/ecpg/pgtypeslib/interval.c||src/interfaces/ecpg/pgtypeslib/interval.c",
          "src/interfaces/ecpg/pgtypeslib/timestamp.c||src/interfaces/ecpg/pgtypeslib/timestamp.c",
          "src/interfaces/ecpg/test/expected/pgtypeslib-dt_test2.c||src/interfaces/ecpg/test/expected/pgtypeslib-dt_test2.c",
          "src/interfaces/ecpg/test/expected/pgtypeslib-dt_test2.stdout||src/interfaces/ecpg/test/expected/pgtypeslib-dt_test2.stdout",
          "src/interfaces/ecpg/test/pgtypeslib/dt_test2.pgc||src/interfaces/ecpg/test/pgtypeslib/dt_test2.pgc",
          "src/test/regress/sql/interval.sql||src/test/regress/sql/interval.sql"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "src/include/utils/datetime.h||src/include/utils/datetime.h",
            "src/interfaces/ecpg/pgtypeslib/datetime.c||src/interfaces/ecpg/pgtypeslib/datetime.c",
            "src/interfaces/ecpg/pgtypeslib/dt.h||src/interfaces/ecpg/pgtypeslib/dt.h",
            "src/interfaces/ecpg/pgtypeslib/dt_common.c||src/interfaces/ecpg/pgtypeslib/dt_common.c",
            "src/interfaces/ecpg/pgtypeslib/interval.c||src/interfaces/ecpg/pgtypeslib/interval.c",
            "src/interfaces/ecpg/pgtypeslib/timestamp.c||src/interfaces/ecpg/pgtypeslib/timestamp.c",
            "src/interfaces/ecpg/test/expected/pgtypeslib-dt_test2.c||src/interfaces/ecpg/test/expected/pgtypeslib-dt_test2.c",
            "src/interfaces/ecpg/test/expected/pgtypeslib-dt_test2.stdout||src/interfaces/ecpg/test/expected/pgtypeslib-dt_test2.stdout",
            "src/interfaces/ecpg/test/pgtypeslib/dt_test2.pgc||src/interfaces/ecpg/test/pgtypeslib/dt_test2.pgc",
            "src/test/regress/sql/interval.sql||src/test/regress/sql/interval.sql"
          ],
          "candidate": [
            "src/include/utils/datetime.h||src/include/utils/datetime.h",
            "src/interfaces/ecpg/pgtypeslib/datetime.c||src/interfaces/ecpg/pgtypeslib/datetime.c",
            "src/interfaces/ecpg/pgtypeslib/dt.h||src/interfaces/ecpg/pgtypeslib/dt.h",
            "src/interfaces/ecpg/pgtypeslib/dt_common.c||src/interfaces/ecpg/pgtypeslib/dt_common.c",
            "src/interfaces/ecpg/pgtypeslib/interval.c||src/interfaces/ecpg/pgtypeslib/interval.c",
            "src/interfaces/ecpg/pgtypeslib/timestamp.c||src/interfaces/ecpg/pgtypeslib/timestamp.c",
            "src/interfaces/ecpg/test/expected/pgtypeslib-dt_test2.c||src/interfaces/ecpg/test/expected/pgtypeslib-dt_test2.c",
            "src/interfaces/ecpg/test/expected/pgtypeslib-dt_test2.stdout||src/interfaces/ecpg/test/expected/pgtypeslib-dt_test2.stdout",
            "src/interfaces/ecpg/test/pgtypeslib/dt_test2.pgc||src/interfaces/ecpg/test/pgtypeslib/dt_test2.pgc",
            "src/test/regress/sql/interval.sql||src/test/regress/sql/interval.sql"
          ]
        }
      },
      "candidate_diff": {
        "src/include/utils/datetime.h||src/include/utils/datetime.h": [
          "File: src/include/utils/datetime.h -> src/include/utils/datetime.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "188: #define DTK_DATE_M  (DTK_M(YEAR) | DTK_M(MONTH) | DTK_M(DAY))",
          "189: #define DTK_TIME_M  (DTK_M(HOUR) | DTK_M(MINUTE) | DTK_ALL_SECS_M)",
          "199: typedef struct",
          "",
          "[Removed Lines]",
          "191: #define MAXDATELEN  63  /* maximum possible length of an input date",
          "193: #define MAXDATEFIELDS 25  /* maximum possible number of fields in a date",
          "195: #define TOKMAXLEN  10  /* only this many chars are stored in",
          "",
          "[Added Lines]",
          "197: #define MAXDATELEN  128",
          "199: #define MAXDATEFIELDS 25",
          "201: #define TOKMAXLEN  10",
          "",
          "---------------"
        ],
        "src/interfaces/ecpg/pgtypeslib/datetime.c||src/interfaces/ecpg/pgtypeslib/datetime.c": [
          "File: src/interfaces/ecpg/pgtypeslib/datetime.c -> src/interfaces/ecpg/pgtypeslib/datetime.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "61:  int   nf;",
          "62:  char    *field[MAXDATEFIELDS];",
          "63:  int   ftype[MAXDATEFIELDS];",
          "65:  char    *realptr;",
          "66:  char   **ptr = (endptr != NULL) ? endptr : &realptr;",
          "68:  bool  EuroDates = FALSE;",
          "70:  errno = 0;",
          "72:  {",
          "73:   errno = PGTYPES_DATE_BAD_DATE;",
          "74:   return INT_MIN;",
          "",
          "[Removed Lines]",
          "64:  char  lowstr[MAXDATELEN + 1];",
          "71:  if (strlen(str) >= sizeof(lowstr))",
          "",
          "[Added Lines]",
          "64:  char  lowstr[MAXDATELEN + MAXDATEFIELDS];",
          "71:  if (strlen(str) > MAXDATELEN)",
          "",
          "---------------"
        ],
        "src/interfaces/ecpg/pgtypeslib/dt.h||src/interfaces/ecpg/pgtypeslib/dt.h": [
          "File: src/interfaces/ecpg/pgtypeslib/dt.h -> src/interfaces/ecpg/pgtypeslib/dt.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "192: #define DTK_DATE_M  (DTK_M(YEAR) | DTK_M(MONTH) | DTK_M(DAY))",
          "193: #define DTK_TIME_M  (DTK_M(HOUR) | DTK_M(MINUTE) | DTK_M(SECOND))",
          "203: typedef struct",
          "",
          "[Removed Lines]",
          "195: #define MAXDATELEN  63  /* maximum possible length of an input date",
          "197: #define MAXDATEFIELDS 25  /* maximum possible number of fields in a date",
          "199: #define TOKMAXLEN  10  /* only this many chars are stored in",
          "",
          "[Added Lines]",
          "201: #define MAXDATELEN  128",
          "203: #define MAXDATEFIELDS 25",
          "205: #define TOKMAXLEN  10",
          "",
          "---------------"
        ],
        "src/interfaces/ecpg/pgtypeslib/dt_common.c||src/interfaces/ecpg/pgtypeslib/dt_common.c": [
          "File: src/interfaces/ecpg/pgtypeslib/dt_common.c -> src/interfaces/ecpg/pgtypeslib/dt_common.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1171:  if ((cp = strchr(str, '.')) != NULL)",
          "1172:  {",
          "1173: #ifdef HAVE_INT64_TIMESTAMP",
          "1184: #else",
          "",
          "[Removed Lines]",
          "1174:   char  fstr[MAXDATELEN + 1];",
          "1180:   strcpy(fstr, (cp + 1));",
          "1181:   strcpy(fstr + strlen(fstr), \"000000\");",
          "",
          "[Added Lines]",
          "1174:   char  fstr[7];",
          "1175:   int   i;",
          "1177:   cp++;",
          "1187:   for (i = 0; i < 6; i++)",
          "1188:    fstr[i] = *cp != '\\0' ? *cp++ : '0';",
          "1189:   fstr[i] = '\\0';",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1531:   else if (*cp == '.')",
          "1532:   {",
          "1533: #ifdef HAVE_INT64_TIMESTAMP",
          "1544: #else",
          "1545:    str = cp;",
          "",
          "[Removed Lines]",
          "1534:    char  fstr[MAXDATELEN + 1];",
          "1540:    strncpy(fstr, (cp + 1), 7);",
          "1541:    strcpy(fstr + strlen(fstr), \"000000\");",
          "",
          "[Added Lines]",
          "1541:    char  fstr[7];",
          "1542:    int   i;",
          "1544:    cp++;",
          "1554:    for (i = 0; i < 6; i++)",
          "1555:     fstr[i] = *cp != '\\0' ? *cp++ : '0';",
          "1556:    fstr[i] = '\\0';",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1678:  while (*(*endstr) != '\\0')",
          "1679:  {",
          "1680:   field[nf] = lp;",
          "1683:   if (isdigit((unsigned char) *(*endstr)))",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1699:   if (nf >= MAXDATEFIELDS)",
          "1700:    return -1;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1820:   nf++;",
          "1823:  }",
          "",
          "[Removed Lines]",
          "1821:   if (nf > MAXDATEFIELDS)",
          "1822:    return -1;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/interfaces/ecpg/pgtypeslib/interval.c||src/interfaces/ecpg/pgtypeslib/interval.c": [
          "File: src/interfaces/ecpg/pgtypeslib/interval.c -> src/interfaces/ecpg/pgtypeslib/interval.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1092:  tm->tm_sec = 0;",
          "1093:  fsec = 0;",
          "1096:  {",
          "1097:   errno = PGTYPES_INTVL_BAD_INTERVAL;",
          "1098:   return NULL;",
          "",
          "[Removed Lines]",
          "1095:  if (strlen(str) >= sizeof(lowstr))",
          "",
          "[Added Lines]",
          "1095:  if (strlen(str) > MAXDATELEN)",
          "",
          "---------------"
        ],
        "src/interfaces/ecpg/pgtypeslib/timestamp.c||src/interfaces/ecpg/pgtypeslib/timestamp.c": [
          "File: src/interfaces/ecpg/pgtypeslib/timestamp.c -> src/interfaces/ecpg/pgtypeslib/timestamp.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "297:  char    *realptr;",
          "298:  char   **ptr = (endptr != NULL) ? endptr : &realptr;",
          "301:  {",
          "302:   errno = PGTYPES_TS_BAD_TIMESTAMP;",
          "303:   return (noresult);",
          "",
          "[Removed Lines]",
          "300:  if (strlen(str) >= sizeof(lowstr))",
          "",
          "[Added Lines]",
          "300:  if (strlen(str) > MAXDATELEN)",
          "",
          "---------------"
        ],
        "src/interfaces/ecpg/test/expected/pgtypeslib-dt_test2.c||src/interfaces/ecpg/test/expected/pgtypeslib-dt_test2.c": [
          "File: src/interfaces/ecpg/test/expected/pgtypeslib-dt_test2.c -> src/interfaces/ecpg/test/expected/pgtypeslib-dt_test2.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "45:       \"1999.008\",",
          "46:       \"J2451187\",",
          "47:       \"January 8, 99 BC\",",
          "48:       NULL };",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "52:       \"........................Xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"",
          "53:       \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",",
          "55:       \".........................aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"",
          "56:       \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "52:       \"1:59 PDT\",",
          "53:       \"13:24:40 -8:00\",",
          "54:       \"13:24:40.495+3\",",
          "55:       NULL };",
          "57: char *intervals[] = { \"1 minute\",",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "64:       \"13:24:40.123456789+3\",",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "77:  date date1 ;",
          "80:  timestamp ts1 , ts2 ;",
          "83:  char * text ;",
          "86:  interval * i1 ;",
          "89:  date * dc ;",
          "94:  int i, j;",
          "",
          "[Removed Lines]",
          "76: #line 52 \"dt_test2.pgc\"",
          "79: #line 53 \"dt_test2.pgc\"",
          "82: #line 54 \"dt_test2.pgc\"",
          "85: #line 55 \"dt_test2.pgc\"",
          "88: #line 56 \"dt_test2.pgc\"",
          "91: #line 57 \"dt_test2.pgc\"",
          "",
          "[Added Lines]",
          "86: #line 62 \"dt_test2.pgc\"",
          "89: #line 63 \"dt_test2.pgc\"",
          "92: #line 64 \"dt_test2.pgc\"",
          "95: #line 65 \"dt_test2.pgc\"",
          "98: #line 66 \"dt_test2.pgc\"",
          "101: #line 67 \"dt_test2.pgc\"",
          "",
          "---------------"
        ],
        "src/interfaces/ecpg/test/expected/pgtypeslib-dt_test2.stdout||src/interfaces/ecpg/test/expected/pgtypeslib-dt_test2.stdout": [
          "File: src/interfaces/ecpg/test/expected/pgtypeslib-dt_test2.stdout -> src/interfaces/ecpg/test/expected/pgtypeslib-dt_test2.stdout",
          "--- Hunk 1 ---",
          "[Context before]",
          "8: TS[3,1]: 1999-01-08 01:59:00",
          "9: TS[3,2]: 1999-01-08 13:24:40",
          "10: TS[3,3]: 1999-01-08 13:24:40.495",
          "11: Date[4]: 1999-01-08 (N - F)",
          "12: TS[4,0]: 1999-01-08 00:04:00",
          "13: TS[4,1]: 1999-01-08 01:59:00",
          "14: TS[4,2]: 1999-01-08 13:24:40",
          "15: TS[4,3]: 1999-01-08 13:24:40.495",
          "16: Date[5]: 1999-01-08 (N - F)",
          "17: TS[5,0]: 1999-01-08 00:04:00",
          "18: TS[5,1]: 1999-01-08 01:59:00",
          "19: TS[5,2]: 1999-01-08 13:24:40",
          "20: TS[5,3]: 1999-01-08 13:24:40.495",
          "21: Date[6]: 1999-01-18 (N - F)",
          "22: TS[6,0]: 1999-01-18 00:04:00",
          "23: TS[6,1]: 1999-01-18 01:59:00",
          "24: TS[6,2]: 1999-01-18 13:24:40",
          "25: TS[6,3]: 1999-01-18 13:24:40.495",
          "26: Date[7]: 2003-01-02 (N - F)",
          "27: TS[7,0]: 2003-01-02 00:04:00",
          "28: TS[7,1]: 2003-01-02 01:59:00",
          "29: TS[7,2]: 2003-01-02 13:24:40",
          "30: TS[7,3]: 2003-01-02 13:24:40.495",
          "31: Date[8]: 1999-01-08 (N - F)",
          "32: TS[8,0]: 1999-01-08 00:04:00",
          "33: TS[8,1]: 1999-01-08 01:59:00",
          "34: TS[8,2]: 1999-01-08 13:24:40",
          "35: TS[8,3]: 1999-01-08 13:24:40.495",
          "36: Date[9]: 1999-01-08 (N - F)",
          "37: TS[9,0]: 1999-01-08 00:04:00",
          "38: TS[9,1]: 1999-01-08 01:59:00",
          "39: TS[9,2]: 1999-01-08 13:24:40",
          "40: TS[9,3]: 1999-01-08 13:24:40.495",
          "41: Date[10]: 1999-01-08 (N - F)",
          "42: TS[10,0]: 1999-01-08 00:04:00",
          "43: TS[10,1]: 1999-01-08 01:59:00",
          "44: TS[10,2]: 1999-01-08 13:24:40",
          "45: TS[10,3]: 1999-01-08 13:24:40.495",
          "46: Date[11]: 1999-01-08 (N - F)",
          "47: TS[11,0]: 1999-01-08 00:04:00",
          "48: TS[11,1]: 1999-01-08 01:59:00",
          "49: TS[11,2]: 1999-01-08 13:24:40",
          "50: TS[11,3]: 1999-01-08 13:24:40.495",
          "51: Date[12]: 1999-01-08 (N - F)",
          "52: TS[12,0]: 1999-01-08 00:04:00",
          "53: TS[12,1]: 1999-01-08 01:59:00",
          "54: TS[12,2]: 1999-01-08 13:24:40",
          "55: TS[12,3]: 1999-01-08 13:24:40.495",
          "56: Date[13]: 2006-01-08 (N - F)",
          "57: TS[13,0]: 2006-01-08 00:04:00",
          "58: TS[13,1]: 2006-01-08 01:59:00",
          "59: TS[13,2]: 2006-01-08 13:24:40",
          "60: TS[13,3]: 2006-01-08 13:24:40.495",
          "61: Date[14]: 1999-01-08 (N - F)",
          "62: TS[14,0]: 1999-01-08 00:04:00",
          "63: TS[14,1]: 1999-01-08 01:59:00",
          "64: TS[14,2]: 1999-01-08 13:24:40",
          "65: TS[14,3]: 1999-01-08 13:24:40.495",
          "66: Date[15]: 1999-01-08 (N - F)",
          "67: TS[15,0]: 1999-01-08 00:04:00",
          "68: TS[15,1]: 1999-01-08 01:59:00",
          "69: TS[15,2]: 1999-01-08 13:24:40",
          "70: TS[15,3]: 1999-01-08 13:24:40.495",
          "71: Date[16]: 1999-01-08 (N - F)",
          "72: TS[16,0]: 1999-01-08 00:04:00",
          "73: TS[16,1]: 1999-01-08 01:59:00",
          "74: TS[16,2]: 1999-01-08 13:24:40",
          "75: TS[16,3]: 1999-01-08 13:24:40.495",
          "76: Date[17]: 1999-01-08 (N - F)",
          "77: TS[17,0]: 1999-01-08 00:04:00",
          "78: TS[17,1]: 1999-01-08 01:59:00",
          "79: TS[17,2]: 1999-01-08 13:24:40",
          "80: TS[17,3]: 1999-01-08 13:24:40.495",
          "81: Date[18]: 1999-01-08 (N - F)",
          "82: TS[18,0]: 1999-01-08 00:04:00",
          "83: TS[18,1]: 1999-01-08 01:59:00",
          "84: TS[18,2]: 1999-01-08 13:24:40",
          "85: TS[18,3]: 1999-01-08 13:24:40.495",
          "86: Date[19]: 0099-01-08 BC (N - F)",
          "87: TS[19,0]: 0099-01-08 00:04:00 BC",
          "88: TS[19,1]: 0099-01-08 01:59:00 BC",
          "89: TS[19,2]: 0099-01-08 13:24:40 BC",
          "90: interval[0]: @ 1 min",
          "91: interval_copy[0]: @ 1 min",
          "92: interval[1]: @ 1 day 12 hours 59 mins 10 secs",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "11: TS[3,4]: 1999-01-08 13:24:40.123456",
          "17: TS[4,4]: 1999-01-08 13:24:40.123456",
          "23: TS[5,4]: 1999-01-08 13:24:40.123456",
          "29: TS[6,4]: 1999-01-18 13:24:40.123456",
          "35: TS[7,4]: 2003-01-02 13:24:40.123456",
          "41: TS[8,4]: 1999-01-08 13:24:40.123456",
          "47: TS[9,4]: 1999-01-08 13:24:40.123456",
          "53: TS[10,4]: 1999-01-08 13:24:40.123456",
          "59: TS[11,4]: 1999-01-08 13:24:40.123456",
          "65: TS[12,4]: 1999-01-08 13:24:40.123456",
          "71: TS[13,4]: 2006-01-08 13:24:40.123456",
          "77: TS[14,4]: 1999-01-08 13:24:40.123456",
          "83: TS[15,4]: 1999-01-08 13:24:40.123456",
          "89: TS[16,4]: 1999-01-08 13:24:40.123456",
          "95: TS[17,4]: 1999-01-08 13:24:40.123456",
          "101: TS[18,4]: 1999-01-08 13:24:40.123456",
          "106: TS[19,4]: 0099-01-08 13:24:40.123456 BC",
          "107: Date[20]: - (N - T)",
          "108: Date[21]: - (N - T)",
          "",
          "---------------"
        ],
        "src/interfaces/ecpg/test/pgtypeslib/dt_test2.pgc||src/interfaces/ecpg/test/pgtypeslib/dt_test2.pgc": [
          "File: src/interfaces/ecpg/test/pgtypeslib/dt_test2.pgc -> src/interfaces/ecpg/test/pgtypeslib/dt_test2.pgc",
          "--- Hunk 1 ---",
          "[Context before]",
          "27:       \"1999.008\",",
          "28:       \"J2451187\",",
          "29:       \"January 8, 99 BC\",",
          "30:       NULL };",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "34:       \"........................Xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"",
          "35:       \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",",
          "37:       \".........................aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"",
          "38:       \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "34:       \"1:59 PDT\",",
          "35:       \"13:24:40 -8:00\",",
          "36:       \"13:24:40.495+3\",",
          "37:       NULL };",
          "39: char *intervals[] = { \"1 minute\",",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "46:       \"13:24:40.123456789+3\",",
          "",
          "---------------"
        ],
        "src/test/regress/sql/interval.sql||src/test/regress/sql/interval.sql": [
          "File: src/test/regress/sql/interval.sql -> src/test/regress/sql/interval.sql",
          "--- Hunk 1 ---",
          "[Context before]",
          "108: -- test long interval input",
          "109: select '4 millenniums 5 centuries 4 decades 1 year 4 months 4 days 17 minutes 31 seconds'::interval;",
          "112: -- test justify_hours() and justify_days()",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "111: -- test long interval output",
          "112: select '100000000y 10mon -1000000000d -1000000000h -10min -10.000001s ago'::interval;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "98be8a6eaa9fe917f6be9e121187b912e19ab484",
      "candidate_info": {
        "commit_hash": "98be8a6eaa9fe917f6be9e121187b912e19ab484",
        "repo": "postgres/postgres",
        "commit_url": "https://github.com/postgres/postgres/commit/98be8a6eaa9fe917f6be9e121187b912e19ab484",
        "files": [
          "contrib/intarray/_int.h",
          "contrib/intarray/_int_bool.c",
          "contrib/ltree/ltree.h",
          "contrib/ltree/ltree_io.c",
          "contrib/ltree/ltxtquery_io.c",
          "src/backend/utils/adt/geo_ops.c",
          "src/backend/utils/adt/tsquery.c",
          "src/backend/utils/adt/tsquery_util.c",
          "src/backend/utils/adt/txid.c",
          "src/backend/utils/adt/varbit.c",
          "src/include/tsearch/ts_type.h",
          "src/include/utils/varbit.h"
        ],
        "message": "Predict integer overflow to avoid buffer overruns.\n\nSeveral functions, mostly type input functions, calculated an allocation\nsize such that the calculation wrapped to a small positive value when\narguments implied a sufficiently-large requirement.  Writes past the end\nof the inadvertent small allocation followed shortly thereafter.\nCoverity identified the path_in() vulnerability; code inspection led to\nthe rest.  In passing, add check_stack_depth() to prevent stack overflow\nin related functions.\n\nBack-patch to 8.4 (all supported versions).  The non-comment hstore\nchanges touch code that did not exist in 8.4, so that part stops at 9.0.\n\nNoah Misch and Heikki Linnakangas, reviewed by Tom Lane.\n\nSecurity: CVE-2014-0064",
        "before_after_code_files": [
          "contrib/intarray/_int.h||contrib/intarray/_int.h",
          "contrib/intarray/_int_bool.c||contrib/intarray/_int_bool.c",
          "contrib/ltree/ltree.h||contrib/ltree/ltree.h",
          "contrib/ltree/ltree_io.c||contrib/ltree/ltree_io.c",
          "contrib/ltree/ltxtquery_io.c||contrib/ltree/ltxtquery_io.c",
          "src/backend/utils/adt/geo_ops.c||src/backend/utils/adt/geo_ops.c",
          "src/backend/utils/adt/tsquery.c||src/backend/utils/adt/tsquery.c",
          "src/backend/utils/adt/tsquery_util.c||src/backend/utils/adt/tsquery_util.c",
          "src/backend/utils/adt/txid.c||src/backend/utils/adt/txid.c",
          "src/backend/utils/adt/varbit.c||src/backend/utils/adt/varbit.c",
          "src/include/tsearch/ts_type.h||src/include/tsearch/ts_type.h",
          "src/include/utils/varbit.h||src/include/utils/varbit.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "contrib/intarray/_int.h||contrib/intarray/_int.h": [
          "File: contrib/intarray/_int.h -> contrib/intarray/_int.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "5: #define ___INT_H__",
          "7: #include \"utils/array.h\"",
          "10: #define MAXNUMRANGE 100",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "8: #include \"utils/memutils.h\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "143: #define HDRSIZEQT (VARHDRSZ + sizeof(int4))",
          "144: #define COMPUTESIZE(size) ( HDRSIZEQT + size * sizeof(ITEM) )",
          "145: #define GETQUERY(x)  (ITEM*)( (char*)(x)+HDRSIZEQT )",
          "147: #define END  0",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "146: #define QUERYTYPEMAXITEMS ((MaxAllocSize - HDRSIZEQT) / sizeof(ITEM))",
          "",
          "---------------"
        ],
        "contrib/intarray/_int_bool.c||contrib/intarray/_int_bool.c": [
          "File: contrib/intarray/_int_bool.c -> contrib/intarray/_int_bool.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "416: static void",
          "417: findoprnd(ITEM *ptr, int4 *pos)",
          "418: {",
          "419: #ifdef BS_DEBUG",
          "420:  elog(DEBUG3, (ptr[*pos].type == OPR) ?",
          "421:    \"%d  %c\" : \"%d  %d\", *pos, ptr[*pos].val);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "420:  check_stack_depth();",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "476:     (errcode(ERRCODE_INVALID_PARAMETER_VALUE),",
          "477:      errmsg(\"empty query\")));",
          "479:  commonlen = COMPUTESIZE(state.num);",
          "480:  query = (QUERYTYPE *) palloc(commonlen);",
          "481:  SET_VARSIZE(query, commonlen);",
          "482:  query->size = state.num;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "482:  if (state.num > QUERYTYPEMAXITEMS)",
          "483:   ereport(ERROR,",
          "484:     (errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),",
          "485:   errmsg(\"number of query items (%d) exceeds the maximum allowed (%d)\",",
          "486:       state.num, (int) QUERYTYPEMAXITEMS)));",
          "",
          "---------------"
        ],
        "contrib/ltree/ltree.h||contrib/ltree/ltree.h": [
          "File: contrib/ltree/ltree.h -> contrib/ltree/ltree.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "6: #include \"postgres.h\"",
          "7: #include \"fmgr.h\"",
          "8: #include \"tsearch/ts_locale.h\"",
          "10: typedef struct",
          "11: {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "9: #include \"utils/memutils.h\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "113: #define HDRSIZEQT  MAXALIGN(VARHDRSZ + sizeof(int4))",
          "114: #define COMPUTESIZE(size,lenofoperand) ( HDRSIZEQT + (size) * sizeof(ITEM) + (lenofoperand) )",
          "115: #define GETQUERY(x)  (ITEM*)( (char*)(x)+HDRSIZEQT )",
          "116: #define GETOPERAND(x) ( (char*)GETQUERY(x) + ((ltxtquery*)x)->size * sizeof(ITEM) )",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "116: #define LTXTQUERY_TOO_BIG(size,lenofoperand) \\",
          "117:  ((size) > (MaxAllocSize - HDRSIZEQT - (lenofoperand)) / sizeof(ITEM))",
          "",
          "---------------"
        ],
        "contrib/ltree/ltree_io.c||contrib/ltree/ltree_io.c": [
          "File: contrib/ltree/ltree_io.c -> contrib/ltree/ltree_io.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "8: #include <ctype.h>",
          "10: #include \"ltree.h\"",
          "11: #include \"crc32.h\"",
          "13: PG_FUNCTION_INFO_V1(ltree_in);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "11: #include \"utils/memutils.h\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "64:   ptr += charlen;",
          "65:  }",
          "67:  list = lptr = (nodeitem *) palloc(sizeof(nodeitem) * (num + 1));",
          "68:  ptr = buf;",
          "69:  while (*ptr)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "68:  if (num + 1 > MaxAllocSize / sizeof(nodeitem))",
          "69:   ereport(ERROR,",
          "70:     (errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),",
          "71:     errmsg(\"number of levels (%d) exceeds the maximum allowed (%d)\",",
          "72:      num + 1, (int) (MaxAllocSize / sizeof(nodeitem)))));",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "228:  }",
          "230:  num++;",
          "231:  curqlevel = tmpql = (lquery_level *) palloc0(ITEMSIZE * num);",
          "232:  ptr = buf;",
          "233:  while (*ptr)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "237:  if (num > MaxAllocSize / ITEMSIZE)",
          "238:   ereport(ERROR,",
          "239:     (errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),",
          "240:     errmsg(\"number of levels (%d) exceeds the maximum allowed (%d)\",",
          "241:      num, (int) (MaxAllocSize / ITEMSIZE))));",
          "",
          "---------------"
        ],
        "contrib/ltree/ltxtquery_io.c||contrib/ltree/ltxtquery_io.c": [
          "File: contrib/ltree/ltxtquery_io.c -> contrib/ltree/ltxtquery_io.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "10: #include \"crc32.h\"",
          "11: #include \"ltree.h\"",
          "13: PG_FUNCTION_INFO_V1(ltxtq_in);",
          "14: Datum  ltxtq_in(PG_FUNCTION_ARGS);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "12: #include \"miscadmin.h\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "213:  int4  lenstack = 0;",
          "214:  uint16  flag = 0;",
          "216:  while ((type = gettoken_query(state, &val, &lenval, &strval, &flag)) != END)",
          "217:  {",
          "218:   switch (type)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "218:  check_stack_depth();",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "277: static void",
          "278: findoprnd(ITEM *ptr, int4 *pos)",
          "279: {",
          "280:  if (ptr[*pos].type == VAL || ptr[*pos].type == VALTRUE)",
          "281:  {",
          "282:   ptr[*pos].left = 0;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "285:  check_stack_depth();",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "341:      errmsg(\"syntax error\"),",
          "342:      errdetail(\"Empty query.\")));",
          "345:  commonlen = COMPUTESIZE(state.num, state.sumlen);",
          "346:  query = (ltxtquery *) palloc(commonlen);",
          "347:  SET_VARSIZE(query, commonlen);",
          "348:  query->size = state.num;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "351:  if (LTXTQUERY_TOO_BIG(state.num, state.sumlen))",
          "352:   ereport(ERROR,",
          "353:     (errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),",
          "354:      errmsg(\"ltxtquery is too large\")));",
          "",
          "---------------"
        ],
        "src/backend/utils/adt/geo_ops.c||src/backend/utils/adt/geo_ops.c": [
          "File: src/backend/utils/adt/geo_ops.c -> src/backend/utils/adt/geo_ops.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1401:  char    *s;",
          "1402:  int   npts;",
          "1403:  int   size;",
          "1404:  int   depth = 0;",
          "1406:  if ((npts = pair_count(str, ',')) <= 0)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1404:  int   base_size;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1419:   depth++;",
          "1420:  }",
          "1423:  path = (PATH *) palloc(size);",
          "1425:  SET_VARSIZE(path, size);",
          "",
          "[Removed Lines]",
          "1422:  size = offsetof(PATH, p[0]) +sizeof(path->p[0]) * npts;",
          "",
          "[Added Lines]",
          "1423:  base_size = sizeof(path->p[0]) * npts;",
          "1424:  size = offsetof(PATH, p[0]) + base_size;",
          "1427:  if (base_size / npts != sizeof(path->p[0]) || size <= base_size)",
          "1428:   ereport(ERROR,",
          "1429:     (errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),",
          "1430:      errmsg(\"too many points requested\")));",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "3439:  POLYGON    *poly;",
          "3440:  int   npts;",
          "3441:  int   size;",
          "3442:  int   isopen;",
          "3443:  char    *s;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3451:  int   base_size;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "3447:     (errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),",
          "3448:      errmsg(\"invalid input syntax for type polygon: \\\"%s\\\"\", str)));",
          "3453:  SET_VARSIZE(poly, size);",
          "",
          "[Removed Lines]",
          "3450:  size = offsetof(POLYGON, p[0]) +sizeof(poly->p[0]) * npts;",
          "",
          "[Added Lines]",
          "3460:  base_size = sizeof(poly->p[0]) * npts;",
          "3461:  size = offsetof(POLYGON, p[0]) + base_size;",
          "3464:  if (base_size / npts != sizeof(poly->p[0]) || size <= base_size)",
          "3465:   ereport(ERROR,",
          "3466:     (errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),",
          "3467:      errmsg(\"too many points requested\")));",
          "",
          "---------------"
        ],
        "src/backend/utils/adt/tsquery.c||src/backend/utils/adt/tsquery.c": [
          "File: src/backend/utils/adt/tsquery.c -> src/backend/utils/adt/tsquery.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "517:   return query;",
          "518:  }",
          "521:  commonlen = COMPUTESIZE(list_length(state.polstr), state.sumlen);",
          "522:  query = (TSQuery) palloc0(commonlen);",
          "523:  SET_VARSIZE(query, commonlen);",
          "524:  query->size = list_length(state.polstr);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "520:  if (TSQUERY_TOO_BIG(list_length(state.polstr), state.sumlen))",
          "521:   ereport(ERROR,",
          "522:     (errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),",
          "523:      errmsg(\"tsquery is too large\")));",
          "",
          "---------------"
        ],
        "src/backend/utils/adt/tsquery_util.c||src/backend/utils/adt/tsquery_util.c": [
          "File: src/backend/utils/adt/tsquery_util.c -> src/backend/utils/adt/tsquery_util.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "334:  QTN2QTState state;",
          "336:  cntsize(in, &sumlen, &nnode);",
          "337:  len = COMPUTESIZE(nnode, sumlen);",
          "339:  out = (TSQuery) palloc0(len);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "338:  if (TSQUERY_TOO_BIG(nnode, sumlen))",
          "339:   ereport(ERROR,",
          "340:     (errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),",
          "341:      errmsg(\"tsquery is too large\")));",
          "",
          "---------------"
        ],
        "src/backend/utils/adt/txid.c||src/backend/utils/adt/txid.c": [
          "File: src/backend/utils/adt/txid.c -> src/backend/utils/adt/txid.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "26: #include \"funcapi.h\"",
          "27: #include \"libpq/pqformat.h\"",
          "28: #include \"utils/builtins.h\"",
          "29: #include \"utils/snapmgr.h\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "29: #include \"utils/memutils.h\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "71: #define TXID_SNAPSHOT_SIZE(nxip) \\",
          "72:  (offsetof(TxidSnapshot, xip) + sizeof(txid) * (nxip))",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "74: #define TXID_SNAPSHOT_MAX_NXIP \\",
          "75:  ((MaxAllocSize - offsetof(TxidSnapshot, xip)) / sizeof(txid))",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "445:  txid  last = 0;",
          "446:  int   nxip;",
          "447:  int   i;",
          "450:  txid  xmin,",
          "451:     xmax;",
          "458:  nxip = pq_getmsgint(buf, 4);",
          "462:   goto bad_format;",
          "464:  xmin = pq_getmsgint64(buf);",
          "",
          "[Removed Lines]",
          "448:  int   avail;",
          "449:  int   expect;",
          "459:  avail = buf->len - buf->cursor;",
          "460:  expect = 8 + 8 + nxip * 8;",
          "461:  if (nxip < 0 || nxip > avail || expect > avail)",
          "",
          "[Added Lines]",
          "456:  if (nxip < 0 || nxip > TXID_SNAPSHOT_MAX_NXIP)",
          "",
          "---------------"
        ],
        "src/backend/utils/adt/varbit.c||src/backend/utils/adt/varbit.c": [
          "File: src/backend/utils/adt/varbit.c -> src/backend/utils/adt/varbit.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "138:   sp = input_string;",
          "139:  }",
          "141:  slen = strlen(sp);",
          "143:  if (bit_not_hex)",
          "144:   bitlen = slen;",
          "145:  else",
          "146:   bitlen = slen * 4;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "149:  {",
          "150:   if (slen > VARBITMAXLEN / 4)",
          "151:    ereport(ERROR,",
          "152:      (errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),",
          "153:      errmsg(\"bit string length exceeds the maximum allowed (%d)\",",
          "154:       VARBITMAXLEN)));",
          "156:  }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "436:   sp = input_string;",
          "437:  }",
          "439:  slen = strlen(sp);",
          "441:  if (bit_not_hex)",
          "442:   bitlen = slen;",
          "443:  else",
          "444:   bitlen = slen * 4;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "457:  {",
          "458:   if (slen > VARBITMAXLEN / 4)",
          "459:    ereport(ERROR,",
          "460:      (errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),",
          "461:      errmsg(\"bit string length exceeds the maximum allowed (%d)\",",
          "462:       VARBITMAXLEN)));",
          "464:  }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "886:  bitlen1 = VARBITLEN(arg1);",
          "887:  bitlen2 = VARBITLEN(arg2);",
          "889:  bytelen = VARBITTOTALLEN(bitlen1 + bitlen2);",
          "891:  result = (VarBit *) palloc(bytelen);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "912:  if (bitlen1 > VARBITMAXLEN - bitlen2)",
          "913:   ereport(ERROR,",
          "914:     (errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),",
          "915:      errmsg(\"bit string length exceeds the maximum allowed (%d)\",",
          "916:       VARBITMAXLEN)));",
          "",
          "---------------"
        ],
        "src/include/tsearch/ts_type.h||src/include/tsearch/ts_type.h": [
          "File: src/include/tsearch/ts_type.h -> src/include/tsearch/ts_type.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "13: #define _PG_TSTYPE_H_",
          "15: #include \"fmgr.h\"",
          "16: #include \"utils/pg_crc.h\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "16: #include \"utils/memutils.h\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "244: #define COMPUTESIZE(size, lenofoperand) ( HDRSIZETQ + (size) * sizeof(QueryItem) + (lenofoperand) )",
          "247: #define GETQUERY(x)  ((QueryItem*)( (char*)(x)+HDRSIZETQ ))",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "246: #define TSQUERY_TOO_BIG(size, lenofoperand) \\",
          "247:  ((size) > (MaxAllocSize - HDRSIZETQ - (lenofoperand)) / sizeof(QueryItem))",
          "",
          "---------------"
        ],
        "src/include/utils/varbit.h||src/include/utils/varbit.h": [
          "File: src/include/utils/varbit.h -> src/include/utils/varbit.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "15: #ifndef VARBIT_H",
          "16: #define VARBIT_H",
          "18: #include \"fmgr.h\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "18: #include <limits.h>",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "54: #define VARBITTOTALLEN(BITLEN) (((BITLEN) + BITS_PER_BYTE-1)/BITS_PER_BYTE + \\",
          "55:          VARHDRSZ + VARBITHDRSZ)",
          "57: #define VARBITEND(PTR)  (((bits8 *) (PTR)) + VARSIZE(PTR))",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "62: #define VARBITMAXLEN  (INT_MAX - BITS_PER_BYTE + 1)",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "2c3203e18551343db11ed9d372cd2a25d65d3f35",
      "candidate_info": {
        "commit_hash": "2c3203e18551343db11ed9d372cd2a25d65d3f35",
        "repo": "postgres/postgres",
        "commit_url": "https://github.com/postgres/postgres/commit/2c3203e18551343db11ed9d372cd2a25d65d3f35",
        "files": [
          "contrib/hstore/hstore.h",
          "contrib/hstore/hstore_io.c",
          "contrib/hstore/hstore_op.c",
          "contrib/intarray/_int.h",
          "contrib/intarray/_int_bool.c",
          "contrib/ltree/ltree.h",
          "contrib/ltree/ltree_io.c",
          "contrib/ltree/ltxtquery_io.c",
          "src/backend/utils/adt/geo_ops.c",
          "src/backend/utils/adt/tsquery.c",
          "src/backend/utils/adt/tsquery_util.c",
          "src/backend/utils/adt/txid.c",
          "src/backend/utils/adt/varbit.c",
          "src/include/tsearch/ts_type.h",
          "src/include/utils/varbit.h"
        ],
        "message": "Predict integer overflow to avoid buffer overruns.\n\nSeveral functions, mostly type input functions, calculated an allocation\nsize such that the calculation wrapped to a small positive value when\narguments implied a sufficiently-large requirement.  Writes past the end\nof the inadvertent small allocation followed shortly thereafter.\nCoverity identified the path_in() vulnerability; code inspection led to\nthe rest.  In passing, add check_stack_depth() to prevent stack overflow\nin related functions.\n\nBack-patch to 8.4 (all supported versions).  The non-comment hstore\nchanges touch code that did not exist in 8.4, so that part stops at 9.0.\n\nNoah Misch and Heikki Linnakangas, reviewed by Tom Lane.\n\nSecurity: CVE-2014-0064",
        "before_after_code_files": [
          "contrib/hstore/hstore.h||contrib/hstore/hstore.h",
          "contrib/hstore/hstore_io.c||contrib/hstore/hstore_io.c",
          "contrib/hstore/hstore_op.c||contrib/hstore/hstore_op.c",
          "contrib/intarray/_int.h||contrib/intarray/_int.h",
          "contrib/intarray/_int_bool.c||contrib/intarray/_int_bool.c",
          "contrib/ltree/ltree.h||contrib/ltree/ltree.h",
          "contrib/ltree/ltree_io.c||contrib/ltree/ltree_io.c",
          "contrib/ltree/ltxtquery_io.c||contrib/ltree/ltxtquery_io.c",
          "src/backend/utils/adt/geo_ops.c||src/backend/utils/adt/geo_ops.c",
          "src/backend/utils/adt/tsquery.c||src/backend/utils/adt/tsquery.c",
          "src/backend/utils/adt/tsquery_util.c||src/backend/utils/adt/tsquery_util.c",
          "src/backend/utils/adt/txid.c||src/backend/utils/adt/txid.c",
          "src/backend/utils/adt/varbit.c||src/backend/utils/adt/varbit.c",
          "src/include/tsearch/ts_type.h||src/include/tsearch/ts_type.h",
          "src/include/utils/varbit.h||src/include/utils/varbit.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "contrib/hstore/hstore.h||contrib/hstore/hstore.h": [
          "File: contrib/hstore/hstore.h -> contrib/hstore/hstore.h"
        ],
        "contrib/hstore/hstore_io.c||contrib/hstore/hstore_io.c": [
          "File: contrib/hstore/hstore_io.c -> contrib/hstore/hstore_io.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "11: #include \"funcapi.h\"",
          "12: #include \"libpq/pqformat.h\"",
          "13: #include \"utils/lsyscache.h\"",
          "14: #include \"utils/typcache.h\"",
          "16: #include \"hstore.h\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "14: #include \"utils/memutils.h\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "438:   PG_RETURN_POINTER(out);",
          "439:  }",
          "441:  pairs = palloc(pcount * sizeof(Pairs));",
          "443:  for (i = 0; i < pcount; ++i)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "442:  if (pcount < 0 || pcount > MaxAllocSize / sizeof(Pairs))",
          "443:   ereport(ERROR,",
          "444:     (errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),",
          "445:      errmsg(\"number of pairs (%d) exceeds the maximum allowed (%d)\",",
          "446:       pcount, (int) (MaxAllocSize / sizeof(Pairs)))));",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "553:        TEXTOID, -1, false, 'i',",
          "554:        &key_datums, &key_nulls, &key_count);",
          "558:  if (PG_ARGISNULL(1))",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "563:  if (key_count > MaxAllocSize / sizeof(Pairs))",
          "564:   ereport(ERROR,",
          "565:     (errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),",
          "566:      errmsg(\"number of pairs (%d) exceeds the maximum allowed (%d)\",",
          "567:       key_count, (int) (MaxAllocSize / sizeof(Pairs)))));",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "676:  count = in_count / 2;",
          "678:  pairs = palloc(count * sizeof(Pairs));",
          "680:  for (i = 0; i < count; ++i)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "692:  if (count > MaxAllocSize / sizeof(Pairs))",
          "693:   ereport(ERROR,",
          "694:     (errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),",
          "695:      errmsg(\"number of pairs (%d) exceeds the maximum allowed (%d)\",",
          "696:       count, (int) (MaxAllocSize / sizeof(Pairs)))));",
          "",
          "---------------"
        ],
        "contrib/hstore/hstore_op.c||contrib/hstore/hstore_op.c": [
          "File: contrib/hstore/hstore_op.c -> contrib/hstore/hstore_op.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "9: #include \"catalog/pg_type.h\"",
          "10: #include \"funcapi.h\"",
          "11: #include \"utils/builtins.h\"",
          "13: #include \"hstore.h\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "12: #include \"utils/memutils.h\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "91:   return NULL;",
          "92:  }",
          "94:  key_pairs = palloc(sizeof(Pairs) * key_count);",
          "96:  for (i = 0, j = 0; i < key_count; i++)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "102:  if (key_count > MaxAllocSize / sizeof(Pairs))",
          "103:   ereport(ERROR,",
          "104:     (errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),",
          "105:      errmsg(\"number of pairs (%d) exceeds the maximum allowed (%d)\",",
          "106:       key_count, (int) (MaxAllocSize / sizeof(Pairs)))));",
          "",
          "---------------"
        ],
        "contrib/intarray/_int.h||contrib/intarray/_int.h": [
          "File: contrib/intarray/_int.h -> contrib/intarray/_int.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "5: #define ___INT_H__",
          "7: #include \"utils/array.h\"",
          "10: #define MAXNUMRANGE 100",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "8: #include \"utils/memutils.h\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "143: #define HDRSIZEQT (VARHDRSZ + sizeof(int4))",
          "144: #define COMPUTESIZE(size) ( HDRSIZEQT + size * sizeof(ITEM) )",
          "145: #define GETQUERY(x)  (ITEM*)( (char*)(x)+HDRSIZEQT )",
          "147: #define END  0",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "146: #define QUERYTYPEMAXITEMS ((MaxAllocSize - HDRSIZEQT) / sizeof(ITEM))",
          "",
          "---------------"
        ],
        "contrib/intarray/_int_bool.c||contrib/intarray/_int_bool.c": [
          "File: contrib/intarray/_int_bool.c -> contrib/intarray/_int_bool.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "416: static void",
          "417: findoprnd(ITEM *ptr, int4 *pos)",
          "418: {",
          "419: #ifdef BS_DEBUG",
          "420:  elog(DEBUG3, (ptr[*pos].type == OPR) ?",
          "421:    \"%d  %c\" : \"%d  %d\", *pos, ptr[*pos].val);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "420:  check_stack_depth();",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "476:     (errcode(ERRCODE_INVALID_PARAMETER_VALUE),",
          "477:      errmsg(\"empty query\")));",
          "479:  commonlen = COMPUTESIZE(state.num);",
          "480:  query = (QUERYTYPE *) palloc(commonlen);",
          "481:  SET_VARSIZE(query, commonlen);",
          "482:  query->size = state.num;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "482:  if (state.num > QUERYTYPEMAXITEMS)",
          "483:   ereport(ERROR,",
          "484:     (errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),",
          "485:   errmsg(\"number of query items (%d) exceeds the maximum allowed (%d)\",",
          "486:       state.num, (int) QUERYTYPEMAXITEMS)));",
          "",
          "---------------"
        ],
        "contrib/ltree/ltree.h||contrib/ltree/ltree.h": [
          "File: contrib/ltree/ltree.h -> contrib/ltree/ltree.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "6: #include \"postgres.h\"",
          "7: #include \"fmgr.h\"",
          "8: #include \"tsearch/ts_locale.h\"",
          "10: typedef struct",
          "11: {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "9: #include \"utils/memutils.h\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "113: #define HDRSIZEQT  MAXALIGN(VARHDRSZ + sizeof(int4))",
          "114: #define COMPUTESIZE(size,lenofoperand) ( HDRSIZEQT + (size) * sizeof(ITEM) + (lenofoperand) )",
          "115: #define GETQUERY(x)  (ITEM*)( (char*)(x)+HDRSIZEQT )",
          "116: #define GETOPERAND(x) ( (char*)GETQUERY(x) + ((ltxtquery*)x)->size * sizeof(ITEM) )",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "116: #define LTXTQUERY_TOO_BIG(size,lenofoperand) \\",
          "117:  ((size) > (MaxAllocSize - HDRSIZEQT - (lenofoperand)) / sizeof(ITEM))",
          "",
          "---------------"
        ],
        "contrib/ltree/ltree_io.c||contrib/ltree/ltree_io.c": [
          "File: contrib/ltree/ltree_io.c -> contrib/ltree/ltree_io.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "8: #include <ctype.h>",
          "10: #include \"ltree.h\"",
          "11: #include \"crc32.h\"",
          "13: PG_FUNCTION_INFO_V1(ltree_in);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "11: #include \"utils/memutils.h\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "64:   ptr += charlen;",
          "65:  }",
          "67:  list = lptr = (nodeitem *) palloc(sizeof(nodeitem) * (num + 1));",
          "68:  ptr = buf;",
          "69:  while (*ptr)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "68:  if (num + 1 > MaxAllocSize / sizeof(nodeitem))",
          "69:   ereport(ERROR,",
          "70:     (errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),",
          "71:     errmsg(\"number of levels (%d) exceeds the maximum allowed (%d)\",",
          "72:      num + 1, (int) (MaxAllocSize / sizeof(nodeitem)))));",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "228:  }",
          "230:  num++;",
          "231:  curqlevel = tmpql = (lquery_level *) palloc0(ITEMSIZE * num);",
          "232:  ptr = buf;",
          "233:  while (*ptr)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "237:  if (num > MaxAllocSize / ITEMSIZE)",
          "238:   ereport(ERROR,",
          "239:     (errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),",
          "240:     errmsg(\"number of levels (%d) exceeds the maximum allowed (%d)\",",
          "241:      num, (int) (MaxAllocSize / ITEMSIZE))));",
          "",
          "---------------"
        ],
        "contrib/ltree/ltxtquery_io.c||contrib/ltree/ltxtquery_io.c": [
          "File: contrib/ltree/ltxtquery_io.c -> contrib/ltree/ltxtquery_io.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "10: #include \"crc32.h\"",
          "11: #include \"ltree.h\"",
          "13: PG_FUNCTION_INFO_V1(ltxtq_in);",
          "14: Datum  ltxtq_in(PG_FUNCTION_ARGS);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "12: #include \"miscadmin.h\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "213:  int4  lenstack = 0;",
          "214:  uint16  flag = 0;",
          "216:  while ((type = gettoken_query(state, &val, &lenval, &strval, &flag)) != END)",
          "217:  {",
          "218:   switch (type)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "218:  check_stack_depth();",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "277: static void",
          "278: findoprnd(ITEM *ptr, int4 *pos)",
          "279: {",
          "280:  if (ptr[*pos].type == VAL || ptr[*pos].type == VALTRUE)",
          "281:  {",
          "282:   ptr[*pos].left = 0;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "285:  check_stack_depth();",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "341:      errmsg(\"syntax error\"),",
          "342:      errdetail(\"Empty query.\")));",
          "345:  commonlen = COMPUTESIZE(state.num, state.sumlen);",
          "346:  query = (ltxtquery *) palloc(commonlen);",
          "347:  SET_VARSIZE(query, commonlen);",
          "348:  query->size = state.num;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "351:  if (LTXTQUERY_TOO_BIG(state.num, state.sumlen))",
          "352:   ereport(ERROR,",
          "353:     (errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),",
          "354:      errmsg(\"ltxtquery is too large\")));",
          "",
          "---------------"
        ],
        "src/backend/utils/adt/geo_ops.c||src/backend/utils/adt/geo_ops.c": [
          "File: src/backend/utils/adt/geo_ops.c -> src/backend/utils/adt/geo_ops.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1403:  char    *s;",
          "1404:  int   npts;",
          "1405:  int   size;",
          "1406:  int   depth = 0;",
          "1408:  if ((npts = pair_count(str, ',')) <= 0)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1406:  int   base_size;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1421:   depth++;",
          "1422:  }",
          "1425:  path = (PATH *) palloc(size);",
          "1427:  SET_VARSIZE(path, size);",
          "",
          "[Removed Lines]",
          "1424:  size = offsetof(PATH, p[0]) +sizeof(path->p[0]) * npts;",
          "",
          "[Added Lines]",
          "1425:  base_size = sizeof(path->p[0]) * npts;",
          "1426:  size = offsetof(PATH, p[0]) + base_size;",
          "1429:  if (base_size / npts != sizeof(path->p[0]) || size <= base_size)",
          "1430:   ereport(ERROR,",
          "1431:     (errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),",
          "1432:      errmsg(\"too many points requested\")));",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "3465:  POLYGON    *poly;",
          "3466:  int   npts;",
          "3467:  int   size;",
          "3468:  int   isopen;",
          "3469:  char    *s;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3477:  int   base_size;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "3473:     (errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),",
          "3474:      errmsg(\"invalid input syntax for type polygon: \\\"%s\\\"\", str)));",
          "3479:  SET_VARSIZE(poly, size);",
          "",
          "[Removed Lines]",
          "3476:  size = offsetof(POLYGON, p[0]) +sizeof(poly->p[0]) * npts;",
          "",
          "[Added Lines]",
          "3486:  base_size = sizeof(poly->p[0]) * npts;",
          "3487:  size = offsetof(POLYGON, p[0]) + base_size;",
          "3490:  if (base_size / npts != sizeof(poly->p[0]) || size <= base_size)",
          "3491:   ereport(ERROR,",
          "3492:     (errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),",
          "3493:      errmsg(\"too many points requested\")));",
          "",
          "---------------"
        ],
        "src/backend/utils/adt/tsquery.c||src/backend/utils/adt/tsquery.c": [
          "File: src/backend/utils/adt/tsquery.c -> src/backend/utils/adt/tsquery.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "517:   return query;",
          "518:  }",
          "521:  commonlen = COMPUTESIZE(list_length(state.polstr), state.sumlen);",
          "522:  query = (TSQuery) palloc0(commonlen);",
          "523:  SET_VARSIZE(query, commonlen);",
          "524:  query->size = list_length(state.polstr);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "520:  if (TSQUERY_TOO_BIG(list_length(state.polstr), state.sumlen))",
          "521:   ereport(ERROR,",
          "522:     (errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),",
          "523:      errmsg(\"tsquery is too large\")));",
          "",
          "---------------"
        ],
        "src/backend/utils/adt/tsquery_util.c||src/backend/utils/adt/tsquery_util.c": [
          "File: src/backend/utils/adt/tsquery_util.c -> src/backend/utils/adt/tsquery_util.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "334:  QTN2QTState state;",
          "336:  cntsize(in, &sumlen, &nnode);",
          "337:  len = COMPUTESIZE(nnode, sumlen);",
          "339:  out = (TSQuery) palloc0(len);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "338:  if (TSQUERY_TOO_BIG(nnode, sumlen))",
          "339:   ereport(ERROR,",
          "340:     (errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),",
          "341:      errmsg(\"tsquery is too large\")));",
          "",
          "---------------"
        ],
        "src/backend/utils/adt/txid.c||src/backend/utils/adt/txid.c": [
          "File: src/backend/utils/adt/txid.c -> src/backend/utils/adt/txid.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "27: #include \"miscadmin.h\"",
          "28: #include \"libpq/pqformat.h\"",
          "29: #include \"utils/builtins.h\"",
          "30: #include \"utils/snapmgr.h\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "30: #include \"utils/memutils.h\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "67: #define TXID_SNAPSHOT_SIZE(nxip) \\",
          "68:  (offsetof(TxidSnapshot, xip) + sizeof(txid) * (nxip))",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "70: #define TXID_SNAPSHOT_MAX_NXIP \\",
          "71:  ((MaxAllocSize - offsetof(TxidSnapshot, xip)) / sizeof(txid))",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "444:  txid  last = 0;",
          "445:  int   nxip;",
          "446:  int   i;",
          "449:  txid  xmin,",
          "450:     xmax;",
          "457:  nxip = pq_getmsgint(buf, 4);",
          "461:   goto bad_format;",
          "463:  xmin = pq_getmsgint64(buf);",
          "",
          "[Removed Lines]",
          "447:  int   avail;",
          "448:  int   expect;",
          "458:  avail = buf->len - buf->cursor;",
          "459:  expect = 8 + 8 + nxip * 8;",
          "460:  if (nxip < 0 || nxip > avail || expect > avail)",
          "",
          "[Added Lines]",
          "455:  if (nxip < 0 || nxip > TXID_SNAPSHOT_MAX_NXIP)",
          "",
          "---------------"
        ],
        "src/backend/utils/adt/varbit.c||src/backend/utils/adt/varbit.c": [
          "File: src/backend/utils/adt/varbit.c -> src/backend/utils/adt/varbit.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "143:   sp = input_string;",
          "144:  }",
          "146:  slen = strlen(sp);",
          "148:  if (bit_not_hex)",
          "149:   bitlen = slen;",
          "150:  else",
          "151:   bitlen = slen * 4;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "154:  {",
          "155:   if (slen > VARBITMAXLEN / 4)",
          "156:    ereport(ERROR,",
          "157:      (errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),",
          "158:      errmsg(\"bit string length exceeds the maximum allowed (%d)\",",
          "159:       VARBITMAXLEN)));",
          "161:  }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "441:   sp = input_string;",
          "442:  }",
          "444:  slen = strlen(sp);",
          "446:  if (bit_not_hex)",
          "447:   bitlen = slen;",
          "448:  else",
          "449:   bitlen = slen * 4;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "462:  {",
          "463:   if (slen > VARBITMAXLEN / 4)",
          "464:    ereport(ERROR,",
          "465:      (errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),",
          "466:      errmsg(\"bit string length exceeds the maximum allowed (%d)\",",
          "467:       VARBITMAXLEN)));",
          "469:  }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "898:  bitlen1 = VARBITLEN(arg1);",
          "899:  bitlen2 = VARBITLEN(arg2);",
          "901:  bytelen = VARBITTOTALLEN(bitlen1 + bitlen2);",
          "903:  result = (VarBit *) palloc(bytelen);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "924:  if (bitlen1 > VARBITMAXLEN - bitlen2)",
          "925:   ereport(ERROR,",
          "926:     (errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),",
          "927:      errmsg(\"bit string length exceeds the maximum allowed (%d)\",",
          "928:       VARBITMAXLEN)));",
          "",
          "---------------"
        ],
        "src/include/tsearch/ts_type.h||src/include/tsearch/ts_type.h": [
          "File: src/include/tsearch/ts_type.h -> src/include/tsearch/ts_type.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "13: #define _PG_TSTYPE_H_",
          "15: #include \"fmgr.h\"",
          "16: #include \"utils/pg_crc.h\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "16: #include \"utils/memutils.h\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "244: #define COMPUTESIZE(size, lenofoperand) ( HDRSIZETQ + (size) * sizeof(QueryItem) + (lenofoperand) )",
          "247: #define GETQUERY(x)  ((QueryItem*)( (char*)(x)+HDRSIZETQ ))",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "246: #define TSQUERY_TOO_BIG(size, lenofoperand) \\",
          "247:  ((size) > (MaxAllocSize - HDRSIZETQ - (lenofoperand)) / sizeof(QueryItem))",
          "",
          "---------------"
        ],
        "src/include/utils/varbit.h||src/include/utils/varbit.h": [
          "File: src/include/utils/varbit.h -> src/include/utils/varbit.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "15: #ifndef VARBIT_H",
          "16: #define VARBIT_H",
          "18: #include \"fmgr.h\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "18: #include <limits.h>",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "54: #define VARBITTOTALLEN(BITLEN) (((BITLEN) + BITS_PER_BYTE-1)/BITS_PER_BYTE + \\",
          "55:          VARHDRSZ + VARBITHDRSZ)",
          "57: #define VARBITEND(PTR)  (((bits8 *) (PTR)) + VARSIZE(PTR))",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "62: #define VARBITMAXLEN  (INT_MAX - BITS_PER_BYTE + 1)",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "1d701d28a796ea2d1a4d2be9e9ee06209eaea040",
      "candidate_info": {
        "commit_hash": "1d701d28a796ea2d1a4d2be9e9ee06209eaea040",
        "repo": "postgres/postgres",
        "commit_url": "https://github.com/postgres/postgres/commit/1d701d28a796ea2d1a4d2be9e9ee06209eaea040",
        "files": [
          "doc/src/sgml/plhandler.sgml",
          "src/backend/catalog/pg_proc.c",
          "src/backend/commands/functioncmds.c",
          "src/backend/utils/fmgr/fmgr.c",
          "src/include/fmgr.h",
          "src/pl/plperl/plperl.c",
          "src/pl/plpgsql/src/pl_handler.c",
          "src/pl/plpython/plpy_main.c"
        ],
        "message": "Prevent privilege escalation in explicit calls to PL validators.\n\nThe primary role of PL validators is to be called implicitly during\nCREATE FUNCTION, but they are also normal functions that a user can call\nexplicitly.  Add a permissions check to each validator to ensure that a\nuser cannot use explicit validator calls to achieve things he could not\notherwise achieve.  Back-patch to 8.4 (all supported versions).\nNon-core procedural language extensions ought to make the same two-line\nchange to their own validators.\n\nAndres Freund, reviewed by Tom Lane and Noah Misch.\n\nSecurity: CVE-2014-0061",
        "before_after_code_files": [
          "src/backend/catalog/pg_proc.c||src/backend/catalog/pg_proc.c",
          "src/backend/commands/functioncmds.c||src/backend/commands/functioncmds.c",
          "src/backend/utils/fmgr/fmgr.c||src/backend/utils/fmgr/fmgr.c",
          "src/include/fmgr.h||src/include/fmgr.h",
          "src/pl/plperl/plperl.c||src/pl/plperl/plperl.c",
          "src/pl/plpgsql/src/pl_handler.c||src/pl/plpgsql/src/pl_handler.c",
          "src/pl/plpython/plpy_main.c||src/pl/plpython/plpy_main.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "src/backend/catalog/pg_proc.c||src/backend/catalog/pg_proc.c": [
          "File: src/backend/catalog/pg_proc.c -> src/backend/catalog/pg_proc.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "718:  Datum  tmp;",
          "719:  char    *prosrc;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "721:  if (!CheckFunctionValidatorAccess(fcinfo->flinfo->fn_oid, funcoid))",
          "722:   PG_RETURN_VOID();",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "763:  char    *prosrc;",
          "764:  char    *probin;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "769:  if (!CheckFunctionValidatorAccess(fcinfo->flinfo->fn_oid, funcoid))",
          "770:   PG_RETURN_VOID();",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "814:  bool  haspolyarg;",
          "815:  int   i;",
          "817:  tuple = SearchSysCache1(PROCOID, ObjectIdGetDatum(funcoid));",
          "818:  if (!HeapTupleIsValid(tuple))",
          "819:   elog(ERROR, \"cache lookup failed for function %u\", funcoid);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "823:  if (!CheckFunctionValidatorAccess(fcinfo->flinfo->fn_oid, funcoid))",
          "824:   PG_RETURN_VOID();",
          "",
          "---------------"
        ],
        "src/backend/commands/functioncmds.c||src/backend/commands/functioncmds.c": [
          "File: src/backend/commands/functioncmds.c -> src/backend/commands/functioncmds.c"
        ],
        "src/backend/utils/fmgr/fmgr.c||src/backend/utils/fmgr/fmgr.c": [
          "File: src/backend/utils/fmgr/fmgr.c -> src/backend/utils/fmgr/fmgr.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "24: #include \"miscadmin.h\"",
          "25: #include \"nodes/nodeFuncs.h\"",
          "26: #include \"pgstat.h\"",
          "27: #include \"utils/builtins.h\"",
          "28: #include \"utils/fmgrtab.h\"",
          "29: #include \"utils/guc.h\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "27: #include \"utils/acl.h\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2446:  return false;",
          "2447: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2480: bool",
          "2481: CheckFunctionValidatorAccess(Oid validatorOid, Oid functionOid)",
          "2482: {",
          "2483:  HeapTuple procTup;",
          "2484:  HeapTuple langTup;",
          "2485:  Form_pg_proc procStruct;",
          "2486:  Form_pg_language langStruct;",
          "2487:  AclResult aclresult;",
          "2490:  procTup = SearchSysCache1(PROCOID, ObjectIdGetDatum(functionOid));",
          "2491:  if (!HeapTupleIsValid(procTup))",
          "2492:   elog(ERROR, \"cache lookup failed for function %u\", functionOid);",
          "2493:  procStruct = (Form_pg_proc) GETSTRUCT(procTup);",
          "2499:  langTup = SearchSysCache1(LANGOID, ObjectIdGetDatum(procStruct->prolang));",
          "2500:  if (!HeapTupleIsValid(langTup))",
          "2501:   elog(ERROR, \"cache lookup failed for language %u\", procStruct->prolang);",
          "2502:  langStruct = (Form_pg_language) GETSTRUCT(langTup);",
          "2504:  if (langStruct->lanvalidator != validatorOid)",
          "2505:   ereport(ERROR,",
          "2506:     (errcode(ERRCODE_INSUFFICIENT_PRIVILEGE),",
          "2507:      errmsg(\"language validation function %u called for language %u instead of %u\",",
          "2508:       validatorOid, procStruct->prolang,",
          "2509:       langStruct->lanvalidator)));",
          "2512:  aclresult = pg_language_aclcheck(procStruct->prolang, GetUserId(),",
          "2513:           ACL_USAGE);",
          "2514:  if (aclresult != ACLCHECK_OK)",
          "2515:   aclcheck_error(aclresult, ACL_KIND_LANGUAGE,",
          "2516:         NameStr(langStruct->lanname));",
          "2523:  aclresult = pg_proc_aclcheck(functionOid, GetUserId(), ACL_EXECUTE);",
          "2524:  if (aclresult != ACLCHECK_OK)",
          "2525:   aclcheck_error(aclresult, ACL_KIND_PROC, NameStr(procStruct->proname));",
          "2527:  ReleaseSysCache(procTup);",
          "2528:  ReleaseSysCache(langTup);",
          "2530:  return true;",
          "2531: }",
          "",
          "---------------"
        ],
        "src/include/fmgr.h||src/include/fmgr.h": [
          "File: src/include/fmgr.h -> src/include/fmgr.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "624: extern Oid get_call_expr_argtype(fmNodePtr expr, int argnum);",
          "625: extern bool get_fn_expr_arg_stable(FmgrInfo *flinfo, int argnum);",
          "626: extern bool get_call_expr_arg_stable(fmNodePtr expr, int argnum);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "627: extern bool CheckFunctionValidatorAccess(Oid validatorOid, Oid functionOid);",
          "",
          "---------------"
        ],
        "src/pl/plperl/plperl.c||src/pl/plperl/plperl.c": [
          "File: src/pl/plperl/plperl.c -> src/pl/plperl/plperl.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1847:  bool  istrigger = false;",
          "1848:  int   i;",
          "1851:  tuple = SearchSysCache1(PROCOID, ObjectIdGetDatum(funcoid));",
          "1852:  if (!HeapTupleIsValid(tuple))",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1850:  if (!CheckFunctionValidatorAccess(fcinfo->flinfo->fn_oid, funcoid))",
          "1851:   PG_RETURN_VOID();",
          "",
          "---------------"
        ],
        "src/pl/plpgsql/src/pl_handler.c||src/pl/plpgsql/src/pl_handler.c": [
          "File: src/pl/plpgsql/src/pl_handler.c -> src/pl/plpgsql/src/pl_handler.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "227:  bool  istrigger = false;",
          "228:  int   i;",
          "231:  tuple = SearchSysCache1(PROCOID, ObjectIdGetDatum(funcoid));",
          "232:  if (!HeapTupleIsValid(tuple))",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "230:  if (!CheckFunctionValidatorAccess(fcinfo->flinfo->fn_oid, funcoid))",
          "231:   PG_RETURN_VOID();",
          "",
          "---------------"
        ],
        "src/pl/plpython/plpy_main.c||src/pl/plpython/plpy_main.c": [
          "File: src/pl/plpython/plpy_main.c -> src/pl/plpython/plpy_main.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "159:  Form_pg_proc procStruct;",
          "160:  bool  is_trigger;",
          "162:  if (!check_function_bodies)",
          "163:  {",
          "164:   PG_RETURN_VOID();",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "162:  if (!CheckFunctionValidatorAccess(fcinfo->flinfo->fn_oid, funcoid))",
          "163:   PG_RETURN_VOID();",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "d0ed1a6c044452a529c1d544647ea1fcb90dcb81",
      "candidate_info": {
        "commit_hash": "d0ed1a6c044452a529c1d544647ea1fcb90dcb81",
        "repo": "postgres/postgres",
        "commit_url": "https://github.com/postgres/postgres/commit/d0ed1a6c044452a529c1d544647ea1fcb90dcb81",
        "files": [
          "src/include/utils/datetime.h",
          "src/interfaces/ecpg/pgtypeslib/datetime.c",
          "src/interfaces/ecpg/pgtypeslib/dt.h",
          "src/interfaces/ecpg/pgtypeslib/dt_common.c",
          "src/interfaces/ecpg/pgtypeslib/interval.c",
          "src/interfaces/ecpg/pgtypeslib/timestamp.c",
          "src/interfaces/ecpg/test/expected/pgtypeslib-dt_test2.c",
          "src/interfaces/ecpg/test/expected/pgtypeslib-dt_test2.stdout",
          "src/interfaces/ecpg/test/pgtypeslib/dt_test2.pgc",
          "src/test/regress/expected/interval.out",
          "src/test/regress/sql/interval.sql"
        ],
        "message": "Fix handling of wide datetime input/output.\n\nMany server functions use the MAXDATELEN constant to size a buffer for\nparsing or displaying a datetime value.  It was much too small for the\nlongest possible interval output and slightly too small for certain\nvalid timestamp input, particularly input with a long timezone name.\nThe long input was rejected needlessly; the long output caused\ninterval_out() to overrun its buffer.  ECPG's pgtypes library has a copy\nof the vulnerable functions, which bore the same vulnerabilities along\nwith some of its own.  In contrast to the server, certain long inputs\ncaused stack overflow rather than failing cleanly.  Back-patch to 8.4\n(all supported versions).\n\nReported by Daniel Sch\u00fcssler, reviewed by Tom Lane.\n\nSecurity: CVE-2014-0063",
        "before_after_code_files": [
          "src/include/utils/datetime.h||src/include/utils/datetime.h",
          "src/interfaces/ecpg/pgtypeslib/datetime.c||src/interfaces/ecpg/pgtypeslib/datetime.c",
          "src/interfaces/ecpg/pgtypeslib/dt.h||src/interfaces/ecpg/pgtypeslib/dt.h",
          "src/interfaces/ecpg/pgtypeslib/dt_common.c||src/interfaces/ecpg/pgtypeslib/dt_common.c",
          "src/interfaces/ecpg/pgtypeslib/interval.c||src/interfaces/ecpg/pgtypeslib/interval.c",
          "src/interfaces/ecpg/pgtypeslib/timestamp.c||src/interfaces/ecpg/pgtypeslib/timestamp.c",
          "src/interfaces/ecpg/test/expected/pgtypeslib-dt_test2.c||src/interfaces/ecpg/test/expected/pgtypeslib-dt_test2.c",
          "src/interfaces/ecpg/test/expected/pgtypeslib-dt_test2.stdout||src/interfaces/ecpg/test/expected/pgtypeslib-dt_test2.stdout",
          "src/interfaces/ecpg/test/pgtypeslib/dt_test2.pgc||src/interfaces/ecpg/test/pgtypeslib/dt_test2.pgc",
          "src/test/regress/sql/interval.sql||src/test/regress/sql/interval.sql"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "src/include/utils/datetime.h||src/include/utils/datetime.h",
            "src/interfaces/ecpg/pgtypeslib/datetime.c||src/interfaces/ecpg/pgtypeslib/datetime.c",
            "src/interfaces/ecpg/pgtypeslib/dt.h||src/interfaces/ecpg/pgtypeslib/dt.h",
            "src/interfaces/ecpg/pgtypeslib/dt_common.c||src/interfaces/ecpg/pgtypeslib/dt_common.c",
            "src/interfaces/ecpg/pgtypeslib/interval.c||src/interfaces/ecpg/pgtypeslib/interval.c",
            "src/interfaces/ecpg/pgtypeslib/timestamp.c||src/interfaces/ecpg/pgtypeslib/timestamp.c",
            "src/interfaces/ecpg/test/expected/pgtypeslib-dt_test2.c||src/interfaces/ecpg/test/expected/pgtypeslib-dt_test2.c",
            "src/interfaces/ecpg/test/expected/pgtypeslib-dt_test2.stdout||src/interfaces/ecpg/test/expected/pgtypeslib-dt_test2.stdout",
            "src/interfaces/ecpg/test/pgtypeslib/dt_test2.pgc||src/interfaces/ecpg/test/pgtypeslib/dt_test2.pgc",
            "src/test/regress/sql/interval.sql||src/test/regress/sql/interval.sql"
          ],
          "candidate": [
            "src/include/utils/datetime.h||src/include/utils/datetime.h",
            "src/interfaces/ecpg/pgtypeslib/datetime.c||src/interfaces/ecpg/pgtypeslib/datetime.c",
            "src/interfaces/ecpg/pgtypeslib/dt.h||src/interfaces/ecpg/pgtypeslib/dt.h",
            "src/interfaces/ecpg/pgtypeslib/dt_common.c||src/interfaces/ecpg/pgtypeslib/dt_common.c",
            "src/interfaces/ecpg/pgtypeslib/interval.c||src/interfaces/ecpg/pgtypeslib/interval.c",
            "src/interfaces/ecpg/pgtypeslib/timestamp.c||src/interfaces/ecpg/pgtypeslib/timestamp.c",
            "src/interfaces/ecpg/test/expected/pgtypeslib-dt_test2.c||src/interfaces/ecpg/test/expected/pgtypeslib-dt_test2.c",
            "src/interfaces/ecpg/test/expected/pgtypeslib-dt_test2.stdout||src/interfaces/ecpg/test/expected/pgtypeslib-dt_test2.stdout",
            "src/interfaces/ecpg/test/pgtypeslib/dt_test2.pgc||src/interfaces/ecpg/test/pgtypeslib/dt_test2.pgc",
            "src/test/regress/sql/interval.sql||src/test/regress/sql/interval.sql"
          ]
        }
      },
      "candidate_diff": {
        "src/include/utils/datetime.h||src/include/utils/datetime.h": [
          "File: src/include/utils/datetime.h -> src/include/utils/datetime.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "188: #define DTK_DATE_M  (DTK_M(YEAR) | DTK_M(MONTH) | DTK_M(DAY))",
          "189: #define DTK_TIME_M  (DTK_M(HOUR) | DTK_M(MINUTE) | DTK_ALL_SECS_M)",
          "199: typedef struct",
          "",
          "[Removed Lines]",
          "191: #define MAXDATELEN  63  /* maximum possible length of an input date",
          "193: #define MAXDATEFIELDS 25  /* maximum possible number of fields in a date",
          "195: #define TOKMAXLEN  10  /* only this many chars are stored in",
          "",
          "[Added Lines]",
          "197: #define MAXDATELEN  128",
          "199: #define MAXDATEFIELDS 25",
          "201: #define TOKMAXLEN  10",
          "",
          "---------------"
        ],
        "src/interfaces/ecpg/pgtypeslib/datetime.c||src/interfaces/ecpg/pgtypeslib/datetime.c": [
          "File: src/interfaces/ecpg/pgtypeslib/datetime.c -> src/interfaces/ecpg/pgtypeslib/datetime.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "61:  int   nf;",
          "62:  char    *field[MAXDATEFIELDS];",
          "63:  int   ftype[MAXDATEFIELDS];",
          "65:  char    *realptr;",
          "66:  char   **ptr = (endptr != NULL) ? endptr : &realptr;",
          "68:  bool  EuroDates = FALSE;",
          "70:  errno = 0;",
          "72:  {",
          "73:   errno = PGTYPES_DATE_BAD_DATE;",
          "74:   return INT_MIN;",
          "",
          "[Removed Lines]",
          "64:  char  lowstr[MAXDATELEN + 1];",
          "71:  if (strlen(str) >= sizeof(lowstr))",
          "",
          "[Added Lines]",
          "64:  char  lowstr[MAXDATELEN + MAXDATEFIELDS];",
          "71:  if (strlen(str) > MAXDATELEN)",
          "",
          "---------------"
        ],
        "src/interfaces/ecpg/pgtypeslib/dt.h||src/interfaces/ecpg/pgtypeslib/dt.h": [
          "File: src/interfaces/ecpg/pgtypeslib/dt.h -> src/interfaces/ecpg/pgtypeslib/dt.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "192: #define DTK_DATE_M  (DTK_M(YEAR) | DTK_M(MONTH) | DTK_M(DAY))",
          "193: #define DTK_TIME_M  (DTK_M(HOUR) | DTK_M(MINUTE) | DTK_M(SECOND))",
          "203: typedef struct",
          "",
          "[Removed Lines]",
          "195: #define MAXDATELEN  63  /* maximum possible length of an input date",
          "197: #define MAXDATEFIELDS 25  /* maximum possible number of fields in a date",
          "199: #define TOKMAXLEN  10  /* only this many chars are stored in",
          "",
          "[Added Lines]",
          "201: #define MAXDATELEN  128",
          "203: #define MAXDATEFIELDS 25",
          "205: #define TOKMAXLEN  10",
          "",
          "---------------"
        ],
        "src/interfaces/ecpg/pgtypeslib/dt_common.c||src/interfaces/ecpg/pgtypeslib/dt_common.c": [
          "File: src/interfaces/ecpg/pgtypeslib/dt_common.c -> src/interfaces/ecpg/pgtypeslib/dt_common.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1143:  if ((cp = strchr(str, '.')) != NULL)",
          "1144:  {",
          "1145: #ifdef HAVE_INT64_TIMESTAMP",
          "1156: #else",
          "",
          "[Removed Lines]",
          "1146:   char  fstr[MAXDATELEN + 1];",
          "1152:   strcpy(fstr, (cp + 1));",
          "1153:   strcpy(fstr + strlen(fstr), \"000000\");",
          "",
          "[Added Lines]",
          "1146:   char  fstr[7];",
          "1147:   int   i;",
          "1149:   cp++;",
          "1159:   for (i = 0; i < 6; i++)",
          "1160:    fstr[i] = *cp != '\\0' ? *cp++ : '0';",
          "1161:   fstr[i] = '\\0';",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1503:   else if (*cp == '.')",
          "1504:   {",
          "1505: #ifdef HAVE_INT64_TIMESTAMP",
          "1516: #else",
          "1517:    str = cp;",
          "",
          "[Removed Lines]",
          "1506:    char  fstr[MAXDATELEN + 1];",
          "1512:    strncpy(fstr, (cp + 1), 7);",
          "1513:    strcpy(fstr + strlen(fstr), \"000000\");",
          "",
          "[Added Lines]",
          "1513:    char  fstr[7];",
          "1514:    int   i;",
          "1516:    cp++;",
          "1526:    for (i = 0; i < 6; i++)",
          "1527:     fstr[i] = *cp != '\\0' ? *cp++ : '0';",
          "1528:    fstr[i] = '\\0';",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1650:  while (*(*endstr) != '\\0')",
          "1651:  {",
          "1652:   field[nf] = lp;",
          "1655:   if (isdigit((unsigned char) *(*endstr)))",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1671:   if (nf >= MAXDATEFIELDS)",
          "1672:    return -1;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1792:   nf++;",
          "1795:  }",
          "",
          "[Removed Lines]",
          "1793:   if (nf > MAXDATEFIELDS)",
          "1794:    return -1;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/interfaces/ecpg/pgtypeslib/interval.c||src/interfaces/ecpg/pgtypeslib/interval.c": [
          "File: src/interfaces/ecpg/pgtypeslib/interval.c -> src/interfaces/ecpg/pgtypeslib/interval.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1092:  tm->tm_sec = 0;",
          "1093:  fsec = 0;",
          "1096:  {",
          "1097:   errno = PGTYPES_INTVL_BAD_INTERVAL;",
          "1098:   return NULL;",
          "",
          "[Removed Lines]",
          "1095:  if (strlen(str) >= sizeof(lowstr))",
          "",
          "[Added Lines]",
          "1095:  if (strlen(str) > MAXDATELEN)",
          "",
          "---------------"
        ],
        "src/interfaces/ecpg/pgtypeslib/timestamp.c||src/interfaces/ecpg/pgtypeslib/timestamp.c": [
          "File: src/interfaces/ecpg/pgtypeslib/timestamp.c -> src/interfaces/ecpg/pgtypeslib/timestamp.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "299:  char    *realptr;",
          "300:  char   **ptr = (endptr != NULL) ? endptr : &realptr;",
          "303:  {",
          "304:   errno = PGTYPES_TS_BAD_TIMESTAMP;",
          "305:   return (noresult);",
          "",
          "[Removed Lines]",
          "302:  if (strlen(str) >= sizeof(lowstr))",
          "",
          "[Added Lines]",
          "302:  if (strlen(str) > MAXDATELEN)",
          "",
          "---------------"
        ],
        "src/interfaces/ecpg/test/expected/pgtypeslib-dt_test2.c||src/interfaces/ecpg/test/expected/pgtypeslib-dt_test2.c": [
          "File: src/interfaces/ecpg/test/expected/pgtypeslib-dt_test2.c -> src/interfaces/ecpg/test/expected/pgtypeslib-dt_test2.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "45:       \"1999.008\",",
          "46:       \"J2451187\",",
          "47:       \"January 8, 99 BC\",",
          "48:       NULL };",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "52:       \"........................Xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"",
          "53:       \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",",
          "55:       \".........................aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"",
          "56:       \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "52:       \"1:59 PDT\",",
          "53:       \"13:24:40 -8:00\",",
          "54:       \"13:24:40.495+3\",",
          "55:       NULL };",
          "57: char *intervals[] = { \"1 minute\",",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "64:       \"13:24:40.123456789+3\",",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "77:  date date1 ;",
          "80:  timestamp ts1 , ts2 ;",
          "83:  char * text ;",
          "86:  interval * i1 ;",
          "89:  date * dc ;",
          "94:  int i, j;",
          "",
          "[Removed Lines]",
          "76: #line 52 \"dt_test2.pgc\"",
          "79: #line 53 \"dt_test2.pgc\"",
          "82: #line 54 \"dt_test2.pgc\"",
          "85: #line 55 \"dt_test2.pgc\"",
          "88: #line 56 \"dt_test2.pgc\"",
          "91: #line 57 \"dt_test2.pgc\"",
          "",
          "[Added Lines]",
          "86: #line 62 \"dt_test2.pgc\"",
          "89: #line 63 \"dt_test2.pgc\"",
          "92: #line 64 \"dt_test2.pgc\"",
          "95: #line 65 \"dt_test2.pgc\"",
          "98: #line 66 \"dt_test2.pgc\"",
          "101: #line 67 \"dt_test2.pgc\"",
          "",
          "---------------"
        ],
        "src/interfaces/ecpg/test/expected/pgtypeslib-dt_test2.stdout||src/interfaces/ecpg/test/expected/pgtypeslib-dt_test2.stdout": [
          "File: src/interfaces/ecpg/test/expected/pgtypeslib-dt_test2.stdout -> src/interfaces/ecpg/test/expected/pgtypeslib-dt_test2.stdout",
          "--- Hunk 1 ---",
          "[Context before]",
          "8: TS[3,1]: 1999-01-08 01:59:00",
          "9: TS[3,2]: 1999-01-08 13:24:40",
          "10: TS[3,3]: 1999-01-08 13:24:40.495",
          "11: Date[4]: 1999-01-08 (N - F)",
          "12: TS[4,0]: 1999-01-08 00:04:00",
          "13: TS[4,1]: 1999-01-08 01:59:00",
          "14: TS[4,2]: 1999-01-08 13:24:40",
          "15: TS[4,3]: 1999-01-08 13:24:40.495",
          "16: Date[5]: 1999-01-08 (N - F)",
          "17: TS[5,0]: 1999-01-08 00:04:00",
          "18: TS[5,1]: 1999-01-08 01:59:00",
          "19: TS[5,2]: 1999-01-08 13:24:40",
          "20: TS[5,3]: 1999-01-08 13:24:40.495",
          "21: Date[6]: 1999-01-18 (N - F)",
          "22: TS[6,0]: 1999-01-18 00:04:00",
          "23: TS[6,1]: 1999-01-18 01:59:00",
          "24: TS[6,2]: 1999-01-18 13:24:40",
          "25: TS[6,3]: 1999-01-18 13:24:40.495",
          "26: Date[7]: 2003-01-02 (N - F)",
          "27: TS[7,0]: 2003-01-02 00:04:00",
          "28: TS[7,1]: 2003-01-02 01:59:00",
          "29: TS[7,2]: 2003-01-02 13:24:40",
          "30: TS[7,3]: 2003-01-02 13:24:40.495",
          "31: Date[8]: 1999-01-08 (N - F)",
          "32: TS[8,0]: 1999-01-08 00:04:00",
          "33: TS[8,1]: 1999-01-08 01:59:00",
          "34: TS[8,2]: 1999-01-08 13:24:40",
          "35: TS[8,3]: 1999-01-08 13:24:40.495",
          "36: Date[9]: 1999-01-08 (N - F)",
          "37: TS[9,0]: 1999-01-08 00:04:00",
          "38: TS[9,1]: 1999-01-08 01:59:00",
          "39: TS[9,2]: 1999-01-08 13:24:40",
          "40: TS[9,3]: 1999-01-08 13:24:40.495",
          "41: Date[10]: 1999-01-08 (N - F)",
          "42: TS[10,0]: 1999-01-08 00:04:00",
          "43: TS[10,1]: 1999-01-08 01:59:00",
          "44: TS[10,2]: 1999-01-08 13:24:40",
          "45: TS[10,3]: 1999-01-08 13:24:40.495",
          "46: Date[11]: 1999-01-08 (N - F)",
          "47: TS[11,0]: 1999-01-08 00:04:00",
          "48: TS[11,1]: 1999-01-08 01:59:00",
          "49: TS[11,2]: 1999-01-08 13:24:40",
          "50: TS[11,3]: 1999-01-08 13:24:40.495",
          "51: Date[12]: 1999-01-08 (N - F)",
          "52: TS[12,0]: 1999-01-08 00:04:00",
          "53: TS[12,1]: 1999-01-08 01:59:00",
          "54: TS[12,2]: 1999-01-08 13:24:40",
          "55: TS[12,3]: 1999-01-08 13:24:40.495",
          "56: Date[13]: 2006-01-08 (N - F)",
          "57: TS[13,0]: 2006-01-08 00:04:00",
          "58: TS[13,1]: 2006-01-08 01:59:00",
          "59: TS[13,2]: 2006-01-08 13:24:40",
          "60: TS[13,3]: 2006-01-08 13:24:40.495",
          "61: Date[14]: 1999-01-08 (N - F)",
          "62: TS[14,0]: 1999-01-08 00:04:00",
          "63: TS[14,1]: 1999-01-08 01:59:00",
          "64: TS[14,2]: 1999-01-08 13:24:40",
          "65: TS[14,3]: 1999-01-08 13:24:40.495",
          "66: Date[15]: 1999-01-08 (N - F)",
          "67: TS[15,0]: 1999-01-08 00:04:00",
          "68: TS[15,1]: 1999-01-08 01:59:00",
          "69: TS[15,2]: 1999-01-08 13:24:40",
          "70: TS[15,3]: 1999-01-08 13:24:40.495",
          "71: Date[16]: 1999-01-08 (N - F)",
          "72: TS[16,0]: 1999-01-08 00:04:00",
          "73: TS[16,1]: 1999-01-08 01:59:00",
          "74: TS[16,2]: 1999-01-08 13:24:40",
          "75: TS[16,3]: 1999-01-08 13:24:40.495",
          "76: Date[17]: 1999-01-08 (N - F)",
          "77: TS[17,0]: 1999-01-08 00:04:00",
          "78: TS[17,1]: 1999-01-08 01:59:00",
          "79: TS[17,2]: 1999-01-08 13:24:40",
          "80: TS[17,3]: 1999-01-08 13:24:40.495",
          "81: Date[18]: 1999-01-08 (N - F)",
          "82: TS[18,0]: 1999-01-08 00:04:00",
          "83: TS[18,1]: 1999-01-08 01:59:00",
          "84: TS[18,2]: 1999-01-08 13:24:40",
          "85: TS[18,3]: 1999-01-08 13:24:40.495",
          "86: Date[19]: 0099-01-08 BC (N - F)",
          "87: TS[19,0]: 0099-01-08 00:04:00 BC",
          "88: TS[19,1]: 0099-01-08 01:59:00 BC",
          "89: TS[19,2]: 0099-01-08 13:24:40 BC",
          "90: interval[0]: @ 1 min",
          "91: interval_copy[0]: @ 1 min",
          "92: interval[1]: @ 1 day 12 hours 59 mins 10 secs",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "11: TS[3,4]: 1999-01-08 13:24:40.123456",
          "17: TS[4,4]: 1999-01-08 13:24:40.123456",
          "23: TS[5,4]: 1999-01-08 13:24:40.123456",
          "29: TS[6,4]: 1999-01-18 13:24:40.123456",
          "35: TS[7,4]: 2003-01-02 13:24:40.123456",
          "41: TS[8,4]: 1999-01-08 13:24:40.123456",
          "47: TS[9,4]: 1999-01-08 13:24:40.123456",
          "53: TS[10,4]: 1999-01-08 13:24:40.123456",
          "59: TS[11,4]: 1999-01-08 13:24:40.123456",
          "65: TS[12,4]: 1999-01-08 13:24:40.123456",
          "71: TS[13,4]: 2006-01-08 13:24:40.123456",
          "77: TS[14,4]: 1999-01-08 13:24:40.123456",
          "83: TS[15,4]: 1999-01-08 13:24:40.123456",
          "89: TS[16,4]: 1999-01-08 13:24:40.123456",
          "95: TS[17,4]: 1999-01-08 13:24:40.123456",
          "101: TS[18,4]: 1999-01-08 13:24:40.123456",
          "106: TS[19,4]: 0099-01-08 13:24:40.123456 BC",
          "107: Date[20]: - (N - T)",
          "108: Date[21]: - (N - T)",
          "",
          "---------------"
        ],
        "src/interfaces/ecpg/test/pgtypeslib/dt_test2.pgc||src/interfaces/ecpg/test/pgtypeslib/dt_test2.pgc": [
          "File: src/interfaces/ecpg/test/pgtypeslib/dt_test2.pgc -> src/interfaces/ecpg/test/pgtypeslib/dt_test2.pgc",
          "--- Hunk 1 ---",
          "[Context before]",
          "27:       \"1999.008\",",
          "28:       \"J2451187\",",
          "29:       \"January 8, 99 BC\",",
          "30:       NULL };",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "34:       \"........................Xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"",
          "35:       \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",",
          "37:       \".........................aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"",
          "38:       \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "34:       \"1:59 PDT\",",
          "35:       \"13:24:40 -8:00\",",
          "36:       \"13:24:40.495+3\",",
          "37:       NULL };",
          "39: char *intervals[] = { \"1 minute\",",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "46:       \"13:24:40.123456789+3\",",
          "",
          "---------------"
        ],
        "src/test/regress/sql/interval.sql||src/test/regress/sql/interval.sql": [
          "File: src/test/regress/sql/interval.sql -> src/test/regress/sql/interval.sql",
          "--- Hunk 1 ---",
          "[Context before]",
          "108: -- test long interval input",
          "109: select '4 millenniums 5 centuries 4 decades 1 year 4 months 4 days 17 minutes 31 seconds'::interval;",
          "112: -- test justify_hours() and justify_days()",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "111: -- test long interval output",
          "112: select '100000000y 10mon -1000000000d -1000000000h -10min -10.000001s ago'::interval;",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2015-0278",
  "cve_desc": "libuv before 0.10.34 does not properly drop group privileges, which allows context-dependent attackers to gain privileges via unspecified vectors.",
  "repo": "libuv/libuv",
  "patch_hash": "66ab38918c911bcff025562cf06237d7fedaba0c",
  "patch_info": {
    "commit_hash": "66ab38918c911bcff025562cf06237d7fedaba0c",
    "repo": "libuv/libuv",
    "commit_url": "https://github.com/libuv/libuv/commit/66ab38918c911bcff025562cf06237d7fedaba0c",
    "files": [
      "src/unix/process.c"
    ],
    "message": "unix: call setgoups before calling setuid/setgid\n\nPartial fix for #1093",
    "before_after_code_files": [
      "src/unix/process.c||src/unix/process.c"
    ]
  },
  "patch_diff": {
    "src/unix/process.c||src/unix/process.c": [
      "File: src/unix/process.c -> src/unix/process.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "330:     _exit(127);",
      "331:   }",
      "333:   if ((options->flags & UV_PROCESS_SETGID) && setgid(options->gid)) {",
      "334:     uv__write_int(error_fd, -errno);",
      "335:     perror(\"setgid()\");",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "333:   if (options->flags & (UV_PROCESS_SETUID | UV_PROCESS_SETGID)) {",
      "341:     SAVE_ERRNO(setgroups(0, NULL));",
      "342:   }",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "ecaede660c44d5649223e0c8c734ab04d3093f83",
      "candidate_info": {
        "commit_hash": "ecaede660c44d5649223e0c8c734ab04d3093f83",
        "repo": "libuv/libuv",
        "commit_url": "https://github.com/libuv/libuv/commit/ecaede660c44d5649223e0c8c734ab04d3093f83",
        "files": [
          "include/uv.h",
          "src/unix/dl.c",
          "src/win/dl.c"
        ],
        "message": "unix, windows: uv_dlerror const argument",
        "before_after_code_files": [
          "include/uv.h||include/uv.h",
          "src/unix/dl.c||src/unix/dl.c",
          "src/win/dl.c||src/win/dl.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/libuv/libuv/pull/41"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "include/uv.h||include/uv.h": [
          "File: include/uv.h -> include/uv.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "2127: UV_EXTERN const char* uv_dlerror(uv_lib_t* lib);",
          "",
          "[Added Lines]",
          "2127: UV_EXTERN const char* uv_dlerror(const uv_lib_t* lib);",
          "",
          "---------------"
        ],
        "src/unix/dl.c||src/unix/dl.c": [
          "File: src/unix/dl.c -> src/unix/dl.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "59: }",
          "63:   return lib->errmsg ? lib->errmsg : \"no error\";",
          "64: }",
          "",
          "[Removed Lines]",
          "62: const char* uv_dlerror(uv_lib_t* lib) {",
          "",
          "[Added Lines]",
          "62: const char* uv_dlerror(const uv_lib_t* lib) {",
          "",
          "---------------"
        ],
        "src/win/dl.c||src/win/dl.c": [
          "File: src/win/dl.c -> src/win/dl.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "64: }",
          "68:   return lib->errmsg ? lib->errmsg : \"no error\";",
          "69: }",
          "",
          "[Removed Lines]",
          "67: const char* uv_dlerror(uv_lib_t* lib) {",
          "",
          "[Added Lines]",
          "67: const char* uv_dlerror(const uv_lib_t* lib) {",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "133b9d1cc1cf2a1a85b2c811c870d2dfeadaa517",
      "candidate_info": {
        "commit_hash": "133b9d1cc1cf2a1a85b2c811c870d2dfeadaa517",
        "repo": "libuv/libuv",
        "commit_url": "https://github.com/libuv/libuv/commit/133b9d1cc1cf2a1a85b2c811c870d2dfeadaa517",
        "files": [
          "src/unix/getnameinfo.c",
          "test/test-list.h",
          "test/test-threadpool-cancel.c"
        ],
        "message": "unix: allow uv_getnameinfo to be cancelled",
        "before_after_code_files": [
          "src/unix/getnameinfo.c||src/unix/getnameinfo.c",
          "test/test-list.h||test/test-list.h",
          "test/test-threadpool-cancel.c||test/test-threadpool-cancel.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/libuv/libuv/pull/41"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "src/unix/getnameinfo.c||src/unix/getnameinfo.c": [
          "File: src/unix/getnameinfo.c -> src/unix/getnameinfo.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "60:   req = container_of(w, uv_getnameinfo_t, work_req);",
          "61:   uv__req_unregister(req->loop, req);",
          "64:     host = req->host;",
          "65:     service = req->service;",
          "69:   }",
          "71:   req->getnameinfo_cb(req, req->retcode, host, service);",
          "",
          "[Removed Lines]",
          "63:   if (req->retcode == 0) {",
          "66:   } else {",
          "67:     host = NULL;",
          "68:     service = NULL;",
          "",
          "[Added Lines]",
          "62:   host = service = NULL;",
          "64:   if (status == -ECANCELED) {",
          "65:     assert(req->retcode == 0);",
          "66:     req->retcode = UV_EAI_CANCELED;",
          "67:   } else if (req->retcode == 0) {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "102:   req->flags = flags;",
          "103:   req->type = UV_GETNAMEINFO;",
          "104:   req->loop = loop;",
          "106:   uv__work_submit(loop,",
          "107:                   &req->work_req,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "106:   req->retcode = 0;",
          "",
          "---------------"
        ],
        "test/test-list.h||test/test-list.h": [
          "File: test/test-list.h -> test/test-list.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "229: TEST_DECLARE   (threadpool_queue_work_einval)",
          "230: TEST_DECLARE   (threadpool_multiple_event_loops)",
          "231: TEST_DECLARE   (threadpool_cancel_getaddrinfo)",
          "232: TEST_DECLARE   (threadpool_cancel_work)",
          "233: TEST_DECLARE   (threadpool_cancel_fs)",
          "234: TEST_DECLARE   (threadpool_cancel_single)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "232: TEST_DECLARE   (threadpool_cancel_getnameinfo)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "573:   TEST_ENTRY  (threadpool_queue_work_einval)",
          "574:   TEST_ENTRY  (threadpool_multiple_event_loops)",
          "575:   TEST_ENTRY  (threadpool_cancel_getaddrinfo)",
          "576:   TEST_ENTRY  (threadpool_cancel_work)",
          "577:   TEST_ENTRY  (threadpool_cancel_fs)",
          "578:   TEST_ENTRY  (threadpool_cancel_single)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "577:   TEST_ENTRY  (threadpool_cancel_getnameinfo)",
          "",
          "---------------"
        ],
        "test/test-threadpool-cancel.c||test/test-threadpool-cancel.c": [
          "File: test/test-threadpool-cancel.c -> test/test-threadpool-cancel.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "46: static unsigned done_cb_called;",
          "47: static unsigned done2_cb_called;",
          "48: static unsigned timer_cb_called;",
          "52: static void work_cb(uv_work_t* req) {",
          "",
          "[Removed Lines]",
          "49: static unsigned getaddrinfo_cb_called;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "125:   ASSERT(status == UV_EAI_CANCELED);",
          "126:   ASSERT(res == NULL);",
          "129: }",
          "",
          "[Removed Lines]",
          "128:   getaddrinfo_cb_called++;",
          "",
          "[Added Lines]",
          "127: }",
          "130: static void getnameinfo_cb(uv_getnameinfo_t* handle,",
          "131:                            int status,",
          "132:                            char* hostname,",
          "133:                            char* service) {",
          "134:   ASSERT(status == UV_EAI_CANCELED);",
          "135:   ASSERT(hostname == NULL);",
          "136:   ASSERT(service == NULL);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "202: }",
          "205: TEST_IMPL(threadpool_cancel_work) {",
          "206:   struct cancel_info ci;",
          "207:   uv_work_t reqs[16];",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "213: TEST_IMPL(threadpool_cancel_getnameinfo) {",
          "214:   uv_getnameinfo_t reqs[4];",
          "215:   struct sockaddr_in addr4;",
          "216:   struct cancel_info ci;",
          "217:   uv_loop_t* loop;",
          "218:   int r;",
          "220:   r = uv_ip4_addr(\"127.0.0.1\", 80, &addr4);",
          "221:   ASSERT(r == 0);",
          "223:   INIT_CANCEL_INFO(&ci, reqs);",
          "224:   loop = uv_default_loop();",
          "225:   saturate_threadpool();",
          "227:   r = uv_getnameinfo(loop, reqs + 0, getnameinfo_cb, (const struct sockaddr*)&addr4, 0);",
          "228:   ASSERT(r == 0);",
          "230:   r = uv_getnameinfo(loop, reqs + 1, getnameinfo_cb, (const struct sockaddr*)&addr4, 0);",
          "231:   ASSERT(r == 0);",
          "233:   r = uv_getnameinfo(loop, reqs + 2, getnameinfo_cb, (const struct sockaddr*)&addr4, 0);",
          "234:   ASSERT(r == 0);",
          "236:   r = uv_getnameinfo(loop, reqs + 3, getnameinfo_cb, (const struct sockaddr*)&addr4, 0);",
          "237:   ASSERT(r == 0);",
          "239:   ASSERT(0 == uv_timer_init(loop, &ci.timer_handle));",
          "240:   ASSERT(0 == uv_timer_start(&ci.timer_handle, timer_cb, 10, 0));",
          "241:   ASSERT(0 == uv_run(loop, UV_RUN_DEFAULT));",
          "242:   ASSERT(1 == timer_cb_called);",
          "244:   cleanup_threadpool();",
          "246:   MAKE_VALGRIND_HAPPY();",
          "247:   return 0;",
          "248: }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "68795b7d6f4d8bad8b383529ecf19bbe7bdef2e7",
      "candidate_info": {
        "commit_hash": "68795b7d6f4d8bad8b383529ecf19bbe7bdef2e7",
        "repo": "libuv/libuv",
        "commit_url": "https://github.com/libuv/libuv/commit/68795b7d6f4d8bad8b383529ecf19bbe7bdef2e7",
        "files": [
          "src/win/pipe.c"
        ],
        "message": "windows: _snprintf expected wrong parameter type in string",
        "before_after_code_files": [
          "src/win/pipe.c||src/win/pipe.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/libuv/libuv/pull/41"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "src/win/pipe.c||src/win/pipe.c": [
          "File: src/win/pipe.c -> src/win/pipe.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "72: static void uv_unique_pipe_name(char* ptr, char* name, size_t size) {",
          "74: }",
          "",
          "[Removed Lines]",
          "73:   _snprintf(name, size, \"\\\\\\\\.\\\\pipe\\\\uv\\\\%p-%d\", ptr, GetCurrentProcessId());",
          "",
          "[Added Lines]",
          "73:   _snprintf(name, size, \"\\\\\\\\.\\\\pipe\\\\uv\\\\%p-%u\", ptr, GetCurrentProcessId());",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "a2506c936296006abe7b8a7517c3f37691191858",
      "candidate_info": {
        "commit_hash": "a2506c936296006abe7b8a7517c3f37691191858",
        "repo": "libuv/libuv",
        "commit_url": "https://github.com/libuv/libuv/commit/a2506c936296006abe7b8a7517c3f37691191858",
        "files": [
          "LICENSE",
          "Makefile.am",
          "configure.ac",
          "include/android-ifaddrs.h",
          "src/unix/android-ifaddrs.c",
          "src/unix/linux-core.c",
          "uv.gyp"
        ],
        "message": "android: add support of ifaddrs in android\n\nFixes https://github.com/joyent/node/issues/7291",
        "before_after_code_files": [
          "Makefile.am||Makefile.am",
          "configure.ac||configure.ac",
          "include/android-ifaddrs.h||include/android-ifaddrs.h",
          "src/unix/android-ifaddrs.c||src/unix/android-ifaddrs.c",
          "src/unix/linux-core.c||src/unix/linux-core.c",
          "uv.gyp||uv.gyp"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/libuv/libuv/pull/41"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "Makefile.am||Makefile.am": [
          "File: Makefile.am -> Makefile.am",
          "--- Hunk 1 ---",
          "[Context before]",
          "234: libuv_la_SOURCES += src/unix/aix.c",
          "235: endif",
          "237: if DARWIN",
          "238: include_HEADERS += include/uv-darwin.h",
          "239: libuv_la_CFLAGS += -D_DARWIN_USE_64_BIT_INODE=1",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "237: if ANDROID",
          "238: include_HEADERS += include/android-ifaddrs.h",
          "239: libuv_la_SOURCES += src/unix/android-ifaddrs.c",
          "240: endif",
          "",
          "---------------"
        ],
        "configure.ac||configure.ac": [
          "File: configure.ac -> configure.ac",
          "--- Hunk 1 ---",
          "[Context before]",
          "37: AC_CHECK_LIB([sendfile], [sendfile])",
          "38: AC_CHECK_LIB([socket], [socket])",
          "39: AC_SYS_LARGEFILE",
          "48: PANDORA_ENABLE_DTRACE",
          "49: AC_CHECK_PROG(PKG_CONFIG, pkg-config, yes)",
          "50: AM_CONDITIONAL([HAVE_PKG_CONFIG], [test \"x$PKG_CONFIG\" != \"x\"])",
          "",
          "[Removed Lines]",
          "40: AM_CONDITIONAL([AIX],     [AS_CASE([$host_os], [aix*],     [true], [false])])",
          "41: AM_CONDITIONAL([DARWIN],  [AS_CASE([$host_os], [darwin*],  [true], [false])])",
          "42: AM_CONDITIONAL([FREEBSD], [AS_CASE([$host_os], [freebsd*], [true], [false])])",
          "43: AM_CONDITIONAL([LINUX],   [AS_CASE([$host_os], [linux*],   [true], [false])])",
          "44: AM_CONDITIONAL([NETBSD],  [AS_CASE([$host_os], [netbsd*],  [true], [false])])",
          "45: AM_CONDITIONAL([OPENBSD], [AS_CASE([$host_os], [openbsd*], [true], [false])])",
          "46: AM_CONDITIONAL([SUNOS],   [AS_CASE([$host_os], [solaris*], [true], [false])])",
          "47: AM_CONDITIONAL([WINNT],   [AS_CASE([$host_os], [mingw*],   [true], [false])])",
          "",
          "[Added Lines]",
          "40: AM_CONDITIONAL([AIX],    [AS_CASE([$host_os],[aix*],          [true], [false])])",
          "41: AM_CONDITIONAL([ANDROID],[AS_CASE([$host_os],[linux-android*],[true], [false])])",
          "42: AM_CONDITIONAL([DARWIN], [AS_CASE([$host_os],[darwin*],       [true], [false])])",
          "43: AM_CONDITIONAL([FREEBSD],[AS_CASE([$host_os],[freebsd*],      [true], [false])])",
          "44: AM_CONDITIONAL([LINUX],  [AS_CASE([$host_os],[linux*],        [true], [false])])",
          "45: AM_CONDITIONAL([NETBSD], [AS_CASE([$host_os],[netbsd*],       [true], [false])])",
          "46: AM_CONDITIONAL([OPENBSD],[AS_CASE([$host_os],[openbsd*],      [true], [false])])",
          "47: AM_CONDITIONAL([SUNOS],  [AS_CASE([$host_os],[solaris*],      [true], [false])])",
          "48: AM_CONDITIONAL([WINNT],  [AS_CASE([$host_os],[mingw*],        [true], [false])])",
          "",
          "---------------"
        ],
        "include/android-ifaddrs.h||include/android-ifaddrs.h": [
          "File: include/android-ifaddrs.h -> include/android-ifaddrs.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "26: #ifndef _IFADDRS_H_",
          "27: #define _IFADDRS_H_",
          "29: struct ifaddrs {",
          "30:  struct ifaddrs  *ifa_next;",
          "31:  char  *ifa_name;",
          "32:  unsigned int  ifa_flags;",
          "33:  struct sockaddr *ifa_addr;",
          "34:  struct sockaddr *ifa_netmask;",
          "35:  struct sockaddr *ifa_dstaddr;",
          "36:  void  *ifa_data;",
          "37: };",
          "43: #ifndef ifa_broadaddr",
          "45: #endif",
          "47: #include <sys/cdefs.h>",
          "49: __BEGIN_DECLS",
          "50: extern int getifaddrs(struct ifaddrs **ifap);",
          "51: extern void freeifaddrs(struct ifaddrs *ifa);",
          "52: __END_DECLS",
          "54: #endif",
          "",
          "---------------"
        ],
        "src/unix/android-ifaddrs.c||src/unix/android-ifaddrs.c": [
          "File: src/unix/android-ifaddrs.c -> src/unix/android-ifaddrs.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2: Copyright (c) 2013, Kenneth MacKay",
          "3: Copyright (c) 2014, Emergya (Cloud4all, FP7/2007-2013 grant agreement n\u00b0 289016)",
          "4: All rights reserved.",
          "6: Redistribution and use in source and binary forms, with or without modification,",
          "7: are permitted provided that the following conditions are met:",
          "9:    list of conditions and the following disclaimer.",
          "11:    this list of conditions and the following disclaimer in the documentation",
          "12:    and/or other materials provided with the distribution.",
          "14: THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND",
          "15: ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED",
          "16: WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE",
          "17: DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR",
          "18: ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES",
          "19: (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;",
          "20: LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON",
          "21: ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT",
          "22: (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS",
          "23: SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.",
          "26: #include \"android-ifaddrs.h\"",
          "28: #include <string.h>",
          "29: #include <stdlib.h>",
          "30: #include <errno.h>",
          "31: #include <unistd.h>",
          "32: #include <sys/socket.h>",
          "33: #include <net/if_arp.h>",
          "34: #include <netinet/in.h>",
          "35: #include <linux/netlink.h>",
          "36: #include <linux/rtnetlink.h>",
          "38: typedef struct NetlinkList",
          "39: {",
          "40:     struct NetlinkList *m_next;",
          "41:     struct nlmsghdr *m_data;",
          "42:     unsigned int m_size;",
          "43: } NetlinkList;",
          "45: static int netlink_socket(void)",
          "46: {",
          "47:     struct sockaddr_nl l_addr;",
          "49:     int l_socket = socket(PF_NETLINK, SOCK_RAW, NETLINK_ROUTE);",
          "50:     if(l_socket < 0)",
          "51:     {",
          "52:         return -1;",
          "53:     }",
          "55:     memset(&l_addr, 0, sizeof(l_addr));",
          "56:     l_addr.nl_family = AF_NETLINK;",
          "57:     if(bind(l_socket, (struct sockaddr *)&l_addr, sizeof(l_addr)) < 0)",
          "58:     {",
          "59:         close(l_socket);",
          "60:         return -1;",
          "61:     }",
          "63:     return l_socket;",
          "64: }",
          "66: static int netlink_send(int p_socket, int p_request)",
          "67: {",
          "68:     char l_buffer[NLMSG_ALIGN(sizeof(struct nlmsghdr)) + NLMSG_ALIGN(sizeof(struct rtgenmsg))];",
          "70:     struct nlmsghdr *l_hdr;",
          "71:     struct rtgenmsg *l_msg;",
          "72:     struct sockaddr_nl l_addr;",
          "74:     memset(l_buffer, 0, sizeof(l_buffer));",
          "76:     l_hdr = (struct nlmsghdr *)l_buffer;",
          "77:     l_msg = (struct rtgenmsg *)NLMSG_DATA(l_hdr);",
          "79:     l_hdr->nlmsg_len = NLMSG_LENGTH(sizeof(*l_msg));",
          "80:     l_hdr->nlmsg_type = p_request;",
          "81:     l_hdr->nlmsg_flags = NLM_F_ROOT | NLM_F_MATCH | NLM_F_REQUEST;",
          "82:     l_hdr->nlmsg_pid = 0;",
          "83:     l_hdr->nlmsg_seq = p_socket;",
          "84:     l_msg->rtgen_family = AF_UNSPEC;",
          "86:     memset(&l_addr, 0, sizeof(l_addr));",
          "87:     l_addr.nl_family = AF_NETLINK;",
          "88:     return (sendto(p_socket, l_hdr, l_hdr->nlmsg_len, 0, (struct sockaddr *)&l_addr, sizeof(l_addr)));",
          "89: }",
          "91: static int netlink_recv(int p_socket, void *p_buffer, size_t p_len)",
          "92: {",
          "93:     struct sockaddr_nl l_addr;",
          "94:     struct msghdr l_msg;",
          "96:     struct iovec l_iov;",
          "97:     l_iov.iov_base = p_buffer;",
          "98:     l_iov.iov_len = p_len;",
          "100:     for(;;)",
          "101:     {",
          "102:         int l_result;",
          "103:         l_msg.msg_name = (void *)&l_addr;",
          "104:         l_msg.msg_namelen = sizeof(l_addr);",
          "105:         l_msg.msg_iov = &l_iov;",
          "106:         l_msg.msg_iovlen = 1;",
          "107:         l_msg.msg_control = NULL;",
          "108:         l_msg.msg_controllen = 0;",
          "109:         l_msg.msg_flags = 0;",
          "110:         l_result = recvmsg(p_socket, &l_msg, 0);",
          "112:         if(l_result < 0)",
          "113:         {",
          "114:             if(errno == EINTR)",
          "115:             {",
          "116:                 continue;",
          "117:             }",
          "118:             return -2;",
          "119:         }",
          "122:         if(l_msg.msg_flags & MSG_TRUNC)",
          "123:         {",
          "124:             return -1;",
          "125:         }",
          "126:         return l_result;",
          "127:     }",
          "128: }",
          "130: static struct nlmsghdr *getNetlinkResponse(int p_socket, int *p_size, int *p_done)",
          "131: {",
          "132:     size_t l_size = 4096;",
          "133:     void *l_buffer = NULL;",
          "135:     for(;;)",
          "136:     {",
          "137:         int l_read;",
          "139:         free(l_buffer);",
          "140:         l_buffer = malloc(l_size);",
          "141:         if (l_buffer == NULL)",
          "142:         {",
          "143:             return NULL;",
          "144:         }",
          "146:         l_read = netlink_recv(p_socket, l_buffer, l_size);",
          "148:         if(l_read == -2)",
          "149:         {",
          "150:             free(l_buffer);",
          "151:             return NULL;",
          "152:         }",
          "153:         if(l_read >= 0)",
          "154:         {",
          "155:             pid_t l_pid = getpid();",
          "156:             struct nlmsghdr *l_hdr;",
          "157:             for(l_hdr = (struct nlmsghdr *)l_buffer; NLMSG_OK(l_hdr, (unsigned int)l_read); l_hdr = (struct nlmsghdr *)NLMSG_NEXT(l_hdr, l_read))",
          "158:             {",
          "159:                 if((pid_t)l_hdr->nlmsg_pid != l_pid || (int)l_hdr->nlmsg_seq != p_socket)",
          "160:                 {",
          "161:                     continue;",
          "162:                 }",
          "164:                 if(l_hdr->nlmsg_type == NLMSG_DONE)",
          "165:                 {",
          "167:                     break;",
          "168:                 }",
          "170:                 if(l_hdr->nlmsg_type == NLMSG_ERROR)",
          "171:                 {",
          "172:                     free(l_buffer);",
          "173:                     return NULL;",
          "174:                 }",
          "175:             }",
          "176:             return l_buffer;",
          "177:         }",
          "179:         l_size *= 2;",
          "180:     }",
          "181: }",
          "183: static NetlinkList *newListItem(struct nlmsghdr *p_data, unsigned int p_size)",
          "184: {",
          "185:     NetlinkList *l_item = malloc(sizeof(NetlinkList));",
          "186:     if (l_item == NULL)",
          "187:     {",
          "188:         return NULL;",
          "189:     }",
          "191:     l_item->m_next = NULL;",
          "192:     l_item->m_data = p_data;",
          "193:     l_item->m_size = p_size;",
          "194:     return l_item;",
          "195: }",
          "197: static void freeResultList(NetlinkList *p_list)",
          "198: {",
          "199:     NetlinkList *l_cur;",
          "200:     while(p_list)",
          "201:     {",
          "202:         l_cur = p_list;",
          "203:         p_list = p_list->m_next;",
          "204:         free(l_cur->m_data);",
          "205:         free(l_cur);",
          "206:     }",
          "207: }",
          "209: static NetlinkList *getResultList(int p_socket, int p_request)",
          "210: {",
          "211:     int l_size;",
          "212:     int l_done;",
          "213:     NetlinkList *l_list;",
          "214:     NetlinkList *l_end;",
          "216:     if(netlink_send(p_socket, p_request) < 0)",
          "217:     {",
          "218:         return NULL;",
          "219:     }",
          "221:     l_list = NULL;",
          "222:     l_end = NULL;",
          "224:     l_done = 0;",
          "225:     while(!l_done)",
          "226:     {",
          "227:         NetlinkList *l_item;",
          "229:         struct nlmsghdr *l_hdr = getNetlinkResponse(p_socket, &l_size, &l_done);",
          "231:         if(!l_hdr)",
          "232:         {",
          "233:             freeResultList(l_list);",
          "234:             return NULL;",
          "235:         }",
          "237:         l_item = newListItem(l_hdr, l_size);",
          "238:         if (!l_item)",
          "239:         {",
          "240:             freeResultList(l_list);",
          "241:             return NULL;",
          "242:         }",
          "243:         if(!l_list)",
          "244:         {",
          "245:             l_list = l_item;",
          "246:         }",
          "247:         else",
          "248:         {",
          "249:             l_end->m_next = l_item;",
          "250:         }",
          "251:         l_end = l_item;",
          "252:     }",
          "253:     return l_list;",
          "254: }",
          "256: static size_t maxSize(size_t a, size_t b)",
          "257: {",
          "258:     return (a > b ? a : b);",
          "259: }",
          "261: static size_t calcAddrLen(sa_family_t p_family, int p_dataSize)",
          "262: {",
          "263:     switch(p_family)",
          "264:     {",
          "265:         case AF_INET:",
          "266:             return sizeof(struct sockaddr_in);",
          "267:         case AF_INET6:",
          "268:             return sizeof(struct sockaddr_in6);",
          "269:         case AF_PACKET:",
          "270:             return maxSize(sizeof(struct sockaddr_ll), offsetof(struct sockaddr_ll, sll_addr) + p_dataSize);",
          "271:         default:",
          "272:             return maxSize(sizeof(struct sockaddr), offsetof(struct sockaddr, sa_data) + p_dataSize);",
          "273:     }",
          "274: }",
          "276: static void makeSockaddr(sa_family_t p_family, struct sockaddr *p_dest, void *p_data, size_t p_size)",
          "277: {",
          "278:     switch(p_family)",
          "279:     {",
          "280:         case AF_INET:",
          "281:             memcpy(&((struct sockaddr_in*)p_dest)->sin_addr, p_data, p_size);",
          "282:             break;",
          "283:         case AF_INET6:",
          "284:             memcpy(&((struct sockaddr_in6*)p_dest)->sin6_addr, p_data, p_size);",
          "285:             break;",
          "286:         case AF_PACKET:",
          "287:             memcpy(((struct sockaddr_ll*)p_dest)->sll_addr, p_data, p_size);",
          "288:             ((struct sockaddr_ll*)p_dest)->sll_halen = p_size;",
          "289:             break;",
          "290:         default:",
          "291:             memcpy(p_dest->sa_data, p_data, p_size);",
          "292:             break;",
          "293:     }",
          "294:     p_dest->sa_family = p_family;",
          "295: }",
          "297: static void addToEnd(struct ifaddrs **p_resultList, struct ifaddrs *p_entry)",
          "298: {",
          "299:     if(!*p_resultList)",
          "300:     {",
          "302:     }",
          "303:     else",
          "304:     {",
          "305:         struct ifaddrs *l_cur = *p_resultList;",
          "306:         while(l_cur->ifa_next)",
          "307:         {",
          "308:             l_cur = l_cur->ifa_next;",
          "309:         }",
          "310:         l_cur->ifa_next = p_entry;",
          "311:     }",
          "312: }",
          "314: static int interpretLink(struct nlmsghdr *p_hdr, struct ifaddrs **p_resultList)",
          "315: {",
          "316:     struct ifaddrs *l_entry;",
          "318:     char *l_index;",
          "319:     char *l_name;",
          "320:     char *l_addr;",
          "321:     char *l_data;",
          "323:     struct ifinfomsg *l_info = (struct ifinfomsg *)NLMSG_DATA(p_hdr);",
          "325:     size_t l_nameSize = 0;",
          "326:     size_t l_addrSize = 0;",
          "327:     size_t l_dataSize = 0;",
          "329:     size_t l_rtaSize = NLMSG_PAYLOAD(p_hdr, sizeof(struct ifinfomsg));",
          "330:     struct rtattr *l_rta;",
          "331:     for(l_rta = IFLA_RTA(l_info); RTA_OK(l_rta, l_rtaSize); l_rta = RTA_NEXT(l_rta, l_rtaSize))",
          "332:     {",
          "333:         size_t l_rtaDataSize = RTA_PAYLOAD(l_rta);",
          "334:         switch(l_rta->rta_type)",
          "335:         {",
          "336:             case IFLA_ADDRESS:",
          "337:             case IFLA_BROADCAST:",
          "338:                 l_addrSize += NLMSG_ALIGN(calcAddrLen(AF_PACKET, l_rtaDataSize));",
          "339:                 break;",
          "340:             case IFLA_IFNAME:",
          "341:                 l_nameSize += NLMSG_ALIGN(l_rtaSize + 1);",
          "342:                 break;",
          "343:             case IFLA_STATS:",
          "344:                 l_dataSize += NLMSG_ALIGN(l_rtaSize);",
          "345:                 break;",
          "346:             default:",
          "347:                 break;",
          "348:         }",
          "349:     }",
          "351:     l_entry = malloc(sizeof(struct ifaddrs) + sizeof(int) + l_nameSize + l_addrSize + l_dataSize);",
          "352:     if (l_entry == NULL)",
          "353:     {",
          "354:         return -1;",
          "355:     }",
          "356:     memset(l_entry, 0, sizeof(struct ifaddrs));",
          "357:     l_entry->ifa_name = \"\";",
          "359:     l_index = ((char *)l_entry) + sizeof(struct ifaddrs);",
          "360:     l_name = l_index + sizeof(int);",
          "361:     l_addr = l_name + l_nameSize;",
          "362:     l_data = l_addr + l_addrSize;",
          "367:     memcpy(l_index, &l_info->ifi_index, sizeof(int));",
          "369:     l_entry->ifa_flags = l_info->ifi_flags;",
          "371:     l_rtaSize = NLMSG_PAYLOAD(p_hdr, sizeof(struct ifinfomsg));",
          "372:     for(l_rta = IFLA_RTA(l_info); RTA_OK(l_rta, l_rtaSize); l_rta = RTA_NEXT(l_rta, l_rtaSize))",
          "373:     {",
          "374:         void *l_rtaData = RTA_DATA(l_rta);",
          "375:         size_t l_rtaDataSize = RTA_PAYLOAD(l_rta);",
          "376:         switch(l_rta->rta_type)",
          "377:         {",
          "378:             case IFLA_ADDRESS:",
          "379:             case IFLA_BROADCAST:",
          "380:             {",
          "381:                 size_t l_addrLen = calcAddrLen(AF_PACKET, l_rtaDataSize);",
          "382:                 makeSockaddr(AF_PACKET, (struct sockaddr *)l_addr, l_rtaData, l_rtaDataSize);",
          "383:                 ((struct sockaddr_ll *)l_addr)->sll_ifindex = l_info->ifi_index;",
          "384:                 ((struct sockaddr_ll *)l_addr)->sll_hatype = l_info->ifi_type;",
          "385:                 if(l_rta->rta_type == IFLA_ADDRESS)",
          "386:                 {",
          "387:                     l_entry->ifa_addr = (struct sockaddr *)l_addr;",
          "388:                 }",
          "389:                 else",
          "390:                 {",
          "391:                     l_entry->ifa_broadaddr = (struct sockaddr *)l_addr;",
          "392:                 }",
          "393:                 l_addr += NLMSG_ALIGN(l_addrLen);",
          "394:                 break;",
          "395:             }",
          "396:             case IFLA_IFNAME:",
          "397:                 strncpy(l_name, l_rtaData, l_rtaDataSize);",
          "398:                 l_name[l_rtaDataSize] = '\\0';",
          "399:                 l_entry->ifa_name = l_name;",
          "400:                 break;",
          "401:             case IFLA_STATS:",
          "402:                 memcpy(l_data, l_rtaData, l_rtaDataSize);",
          "403:                 l_entry->ifa_data = l_data;",
          "404:                 break;",
          "405:             default:",
          "406:                 break;",
          "407:         }",
          "408:     }",
          "410:     addToEnd(p_resultList, l_entry);",
          "411:     return 0;",
          "412: }",
          "414: static struct ifaddrs *findInterface(int p_index, struct ifaddrs **p_links, int p_numLinks)",
          "415: {",
          "416:     int l_num = 0;",
          "417:     struct ifaddrs *l_cur = *p_links;",
          "418:     while(l_cur && l_num < p_numLinks)",
          "419:     {",
          "420:         char *l_indexPtr = ((char *)l_cur) + sizeof(struct ifaddrs);",
          "421:         int l_index;",
          "422:         memcpy(&l_index, l_indexPtr, sizeof(int));",
          "423:         if(l_index == p_index)",
          "424:         {",
          "425:             return l_cur;",
          "426:         }",
          "428:         l_cur = l_cur->ifa_next;",
          "429:         ++l_num;",
          "430:     }",
          "431:     return NULL;",
          "432: }",
          "434: static int interpretAddr(struct nlmsghdr *p_hdr, struct ifaddrs **p_resultList, int p_numLinks)",
          "435: {",
          "436:     struct ifaddrmsg *l_info = (struct ifaddrmsg *)NLMSG_DATA(p_hdr);",
          "437:     struct ifaddrs *l_interface = findInterface(l_info->ifa_index, p_resultList, p_numLinks);",
          "439:     size_t l_nameSize = 0;",
          "440:     size_t l_addrSize = 0;",
          "442:     int l_addedNetmask = 0;",
          "444:     size_t l_rtaSize = NLMSG_PAYLOAD(p_hdr, sizeof(struct ifaddrmsg));",
          "445:     struct rtattr *l_rta;",
          "446:     struct ifaddrs *l_entry;",
          "448:     char *l_name;",
          "449:     char *l_addr;",
          "451:     for(l_rta = IFLA_RTA(l_info); RTA_OK(l_rta, l_rtaSize); l_rta = RTA_NEXT(l_rta, l_rtaSize))",
          "452:     {",
          "453:         size_t l_rtaDataSize = RTA_PAYLOAD(l_rta);",
          "454:         if(l_info->ifa_family == AF_PACKET)",
          "455:         {",
          "456:             continue;",
          "457:         }",
          "459:         switch(l_rta->rta_type)",
          "460:         {",
          "461:             case IFA_ADDRESS:",
          "462:             case IFA_LOCAL:",
          "463:                 if((l_info->ifa_family == AF_INET || l_info->ifa_family == AF_INET6) && !l_addedNetmask)",
          "464:                 {",
          "466:                     l_addrSize += NLMSG_ALIGN(calcAddrLen(l_info->ifa_family, l_rtaDataSize));",
          "467:                     l_addedNetmask = 1;",
          "468:                 }",
          "469:             case IFA_BROADCAST:",
          "470:                 l_addrSize += NLMSG_ALIGN(calcAddrLen(l_info->ifa_family, l_rtaDataSize));",
          "471:                 break;",
          "472:             case IFA_LABEL:",
          "473:                 l_nameSize += NLMSG_ALIGN(l_rtaSize + 1);",
          "474:                 break;",
          "475:             default:",
          "476:                 break;",
          "477:         }",
          "478:     }",
          "480:     l_entry = malloc(sizeof(struct ifaddrs) + l_nameSize + l_addrSize);",
          "481:     if (l_entry == NULL)",
          "482:     {",
          "483:         return -1;",
          "484:     }",
          "485:     memset(l_entry, 0, sizeof(struct ifaddrs));",
          "486:     l_entry->ifa_name = (l_interface ? l_interface->ifa_name : \"\");",
          "488:     l_name = ((char *)l_entry) + sizeof(struct ifaddrs);",
          "489:     l_addr = l_name + l_nameSize;",
          "491:     l_entry->ifa_flags = l_info->ifa_flags;",
          "492:     if(l_interface)",
          "493:     {",
          "494:         l_entry->ifa_flags |= l_interface->ifa_flags;",
          "495:     }",
          "497:     l_rtaSize = NLMSG_PAYLOAD(p_hdr, sizeof(struct ifaddrmsg));",
          "498:     for(l_rta = IFLA_RTA(l_info); RTA_OK(l_rta, l_rtaSize); l_rta = RTA_NEXT(l_rta, l_rtaSize))",
          "499:     {",
          "500:         void *l_rtaData = RTA_DATA(l_rta);",
          "501:         size_t l_rtaDataSize = RTA_PAYLOAD(l_rta);",
          "502:         switch(l_rta->rta_type)",
          "503:         {",
          "504:             case IFA_ADDRESS:",
          "505:             case IFA_BROADCAST:",
          "506:             case IFA_LOCAL:",
          "507:             {",
          "508:                 size_t l_addrLen = calcAddrLen(l_info->ifa_family, l_rtaDataSize);",
          "509:                 makeSockaddr(l_info->ifa_family, (struct sockaddr *)l_addr, l_rtaData, l_rtaDataSize);",
          "510:                 if(l_info->ifa_family == AF_INET6)",
          "511:                 {",
          "512:                     if(IN6_IS_ADDR_LINKLOCAL((struct in6_addr *)l_rtaData) || IN6_IS_ADDR_MC_LINKLOCAL((struct in6_addr *)l_rtaData))",
          "513:                     {",
          "514:                         ((struct sockaddr_in6 *)l_addr)->sin6_scope_id = l_info->ifa_index;",
          "515:                     }",
          "516:                 }",
          "521:                 if(l_rta->rta_type == IFA_ADDRESS)",
          "522:                 {",
          "523:                     if(l_entry->ifa_addr)",
          "524:                     {",
          "525:                         l_entry->ifa_dstaddr = (struct sockaddr *)l_addr;",
          "526:                     }",
          "527:                     else",
          "528:                     {",
          "529:                         l_entry->ifa_addr = (struct sockaddr *)l_addr;",
          "530:                     }",
          "531:                 }",
          "532:                 else if(l_rta->rta_type == IFA_LOCAL)",
          "533:                 {",
          "534:                     if(l_entry->ifa_addr)",
          "535:                     {",
          "536:                         l_entry->ifa_dstaddr = l_entry->ifa_addr;",
          "537:                     }",
          "538:                     l_entry->ifa_addr = (struct sockaddr *)l_addr;",
          "539:                 }",
          "540:                 else",
          "541:                 {",
          "542:                     l_entry->ifa_broadaddr = (struct sockaddr *)l_addr;",
          "543:                 }",
          "544:                 l_addr += NLMSG_ALIGN(l_addrLen);",
          "545:                 break;",
          "546:             }",
          "547:             case IFA_LABEL:",
          "548:                 strncpy(l_name, l_rtaData, l_rtaDataSize);",
          "549:                 l_name[l_rtaDataSize] = '\\0';",
          "550:                 l_entry->ifa_name = l_name;",
          "551:                 break;",
          "552:             default:",
          "553:                 break;",
          "554:         }",
          "555:     }",
          "557:     if(l_entry->ifa_addr && (l_entry->ifa_addr->sa_family == AF_INET || l_entry->ifa_addr->sa_family == AF_INET6))",
          "558:     {",
          "559:         unsigned l_maxPrefix = (l_entry->ifa_addr->sa_family == AF_INET ? 32 : 128);",
          "560:         unsigned l_prefix = (l_info->ifa_prefixlen > l_maxPrefix ? l_maxPrefix : l_info->ifa_prefixlen);",
          "561:         char l_mask[16] = {0};",
          "562:         unsigned i;",
          "563:         for(i=0; i<(l_prefix/8); ++i)",
          "564:         {",
          "565:             l_mask[i] = 0xff;",
          "566:         }",
          "567:         if(l_prefix % 8)",
          "568:         {",
          "569:             l_mask[i] = 0xff << (8 - (l_prefix % 8));",
          "570:         }",
          "572:         makeSockaddr(l_entry->ifa_addr->sa_family, (struct sockaddr *)l_addr, l_mask, l_maxPrefix / 8);",
          "573:         l_entry->ifa_netmask = (struct sockaddr *)l_addr;",
          "574:     }",
          "576:     addToEnd(p_resultList, l_entry);",
          "577:     return 0;",
          "578: }",
          "580: static int interpretLinks(int p_socket, NetlinkList *p_netlinkList, struct ifaddrs **p_resultList)",
          "581: {",
          "583:     int l_numLinks = 0;",
          "584:     pid_t l_pid = getpid();",
          "585:     for(; p_netlinkList; p_netlinkList = p_netlinkList->m_next)",
          "586:     {",
          "587:         unsigned int l_nlsize = p_netlinkList->m_size;",
          "588:         struct nlmsghdr *l_hdr;",
          "589:         for(l_hdr = p_netlinkList->m_data; NLMSG_OK(l_hdr, l_nlsize); l_hdr = NLMSG_NEXT(l_hdr, l_nlsize))",
          "590:         {",
          "591:             if((pid_t)l_hdr->nlmsg_pid != l_pid || (int)l_hdr->nlmsg_seq != p_socket)",
          "592:             {",
          "593:                 continue;",
          "594:             }",
          "596:             if(l_hdr->nlmsg_type == NLMSG_DONE)",
          "597:             {",
          "598:                 break;",
          "599:             }",
          "601:             if(l_hdr->nlmsg_type == RTM_NEWLINK)",
          "602:             {",
          "603:                 if(interpretLink(l_hdr, p_resultList) == -1)",
          "604:                 {",
          "605:                     return -1;",
          "606:                 }",
          "607:                 ++l_numLinks;",
          "608:             }",
          "609:         }",
          "610:     }",
          "611:     return l_numLinks;",
          "612: }",
          "614: static int interpretAddrs(int p_socket, NetlinkList *p_netlinkList, struct ifaddrs **p_resultList, int p_numLinks)",
          "615: {",
          "616:     pid_t l_pid = getpid();",
          "617:     for(; p_netlinkList; p_netlinkList = p_netlinkList->m_next)",
          "618:     {",
          "619:         unsigned int l_nlsize = p_netlinkList->m_size;",
          "620:         struct nlmsghdr *l_hdr;",
          "621:         for(l_hdr = p_netlinkList->m_data; NLMSG_OK(l_hdr, l_nlsize); l_hdr = NLMSG_NEXT(l_hdr, l_nlsize))",
          "622:         {",
          "623:             if((pid_t)l_hdr->nlmsg_pid != l_pid || (int)l_hdr->nlmsg_seq != p_socket)",
          "624:             {",
          "625:                 continue;",
          "626:             }",
          "628:             if(l_hdr->nlmsg_type == NLMSG_DONE)",
          "629:             {",
          "630:                 break;",
          "631:             }",
          "633:             if(l_hdr->nlmsg_type == RTM_NEWADDR)",
          "634:             {",
          "635:                 if (interpretAddr(l_hdr, p_resultList, p_numLinks) == -1)",
          "636:                 {",
          "637:                     return -1;",
          "638:                 }",
          "639:             }",
          "640:         }",
          "641:     }",
          "642:     return 0;",
          "643: }",
          "645: int getifaddrs(struct ifaddrs **ifap)",
          "646: {",
          "647:     int l_socket;",
          "648:     int l_result;",
          "649:     int l_numLinks;",
          "650:     NetlinkList *l_linkResults;",
          "651:     NetlinkList *l_addrResults;",
          "653:     if(!ifap)",
          "654:     {",
          "655:         return -1;",
          "656:     }",
          "659:     l_socket = netlink_socket();",
          "660:     if(l_socket < 0)",
          "661:     {",
          "662:         return -1;",
          "663:     }",
          "665:     l_linkResults = getResultList(l_socket, RTM_GETLINK);",
          "666:     if(!l_linkResults)",
          "667:     {",
          "668:         close(l_socket);",
          "669:         return -1;",
          "670:     }",
          "672:     l_addrResults = getResultList(l_socket, RTM_GETADDR);",
          "673:     if(!l_addrResults)",
          "674:     {",
          "675:         close(l_socket);",
          "676:         freeResultList(l_linkResults);",
          "677:         return -1;",
          "678:     }",
          "680:     l_result = 0;",
          "681:     l_numLinks = interpretLinks(l_socket, l_linkResults, ifap);",
          "682:     if(l_numLinks == -1 || interpretAddrs(l_socket, l_addrResults, ifap, l_numLinks) == -1)",
          "683:     {",
          "684:         l_result = -1;",
          "685:     }",
          "687:     freeResultList(l_linkResults);",
          "688:     freeResultList(l_addrResults);",
          "689:     close(l_socket);",
          "690:     return l_result;",
          "691: }",
          "693: void freeifaddrs(struct ifaddrs *ifa)",
          "694: {",
          "695:     struct ifaddrs *l_cur;",
          "696:     while(ifa)",
          "697:     {",
          "698:         l_cur = ifa;",
          "699:         ifa = ifa->ifa_next;",
          "700:         free(l_cur);",
          "701:     }",
          "702: }",
          "",
          "---------------"
        ],
        "src/unix/linux-core.c||src/unix/linux-core.c": [
          "File: src/unix/linux-core.c -> src/unix/linux-core.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "36: #include <fcntl.h>",
          "37: #include <time.h>",
          "40: #define HAVE_IFADDRS_H 1",
          "43: #ifdef __UCLIBC__",
          "44: # if __UCLIBC_MAJOR__ < 0 || __UCLIBC_MINOR__ < 9 || __UCLIBC_SUBLEVEL__ < 32",
          "45: #  undef HAVE_IFADDRS_H",
          "46: # endif",
          "47: #endif",
          "48: #ifdef HAVE_IFADDRS_H",
          "50: # include <sys/socket.h>",
          "51: # include <net/ethernet.h>",
          "52: # include <linux/if_packet.h>",
          "56: #ifndef CLOCK_MONOTONIC_COARSE",
          "",
          "[Removed Lines]",
          "39: #ifndef __ANDROID__",
          "41: #endif",
          "49: # include <ifaddrs.h>",
          "53: #endif",
          "",
          "[Added Lines]",
          "48: # if defined(__ANDROID__)",
          "49: #  include \"android-ifaddrs.h\"",
          "50: # else",
          "51: #  include <ifaddrs.h>",
          "52: # endif",
          "",
          "---------------"
        ],
        "uv.gyp||uv.gyp": [
          "File: uv.gyp -> uv.gyp",
          "--- Hunk 1 ---",
          "[Context before]",
          "217:             'src/unix/linux-syscalls.c',",
          "218:             'src/unix/linux-syscalls.h',",
          "219:             'src/unix/pthread-fixes.c',",
          "220:           ],",
          "221:           'link_settings': {",
          "222:             'libraries': [ '-ldl' ],",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "220:             'src/unix/android-ifaddrs.c'",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "b53aeb491a66ce4e0773b37d5dfd0ee5e875bad6",
      "candidate_info": {
        "commit_hash": "b53aeb491a66ce4e0773b37d5dfd0ee5e875bad6",
        "repo": "libuv/libuv",
        "commit_url": "https://github.com/libuv/libuv/commit/b53aeb491a66ce4e0773b37d5dfd0ee5e875bad6",
        "files": [
          "src/win/udp.c"
        ],
        "message": "windows: replace use of inet_addr with uv_inet_pton\n\nFixes a compilation warning with Visual Studio 2013.",
        "before_after_code_files": [
          "src/win/udp.c||src/win/udp.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/libuv/libuv/pull/41"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "src/win/udp.c||src/win/udp.c": [
          "File: src/win/udp.c -> src/win/udp.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "572:   memset(&mreq, 0, sizeof mreq);",
          "574:   if (interface_addr) {",
          "576:   } else {",
          "577:     mreq.imr_interface.s_addr = htonl(INADDR_ANY);",
          "578:   }",
          "",
          "[Removed Lines]",
          "575:     mreq.imr_interface.s_addr = inet_addr(interface_addr);",
          "",
          "[Added Lines]",
          "575:     err = uv_inet_pton(AF_INET, interface_addr, &mreq.imr_interface.s_addr);",
          "576:     if (err)",
          "577:       return err;",
          "",
          "---------------"
        ]
      }
    }
  ]
}
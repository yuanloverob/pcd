{
  "cve_id": "CVE-2018-7333",
  "cve_desc": "In Wireshark 2.4.0 to 2.4.4 and 2.2.0 to 2.2.12, epan/dissectors/packet-rpcrdma.c had an infinite loop that was addressed by validating a chunk size.",
  "repo": "wireshark/wireshark",
  "patch_hash": "65aa59d28ab5f41a06dbfcf25b191f2b3547b78e",
  "patch_info": {
    "commit_hash": "65aa59d28ab5f41a06dbfcf25b191f2b3547b78e",
    "repo": "wireshark/wireshark",
    "commit_url": "https://github.com/wireshark/wireshark/commit/65aa59d28ab5f41a06dbfcf25b191f2b3547b78e",
    "files": [
      "epan/dissectors/packet-rpcrdma.c"
    ],
    "message": "RPCoRDMA: Set an upper bound for our chunk size.\n\nMake sure our write chunk size doesn't exceed our tvbuff. Adjust a few\nlength checks.\n\nBug: 14449\nChange-Id: If9dd8a6094830c5b47adfff0acb3ff726168e801\nReviewed-on: https://code.wireshark.org/review/25943\nReviewed-by: Gerald Combs <gerald@wireshark.org>\nPetri-Dish: Gerald Combs <gerald@wireshark.org>\nTested-by: Petri Dish Buildbot\nReviewed-by: Michael Mann <mmann78@netscape.net>",
    "before_after_code_files": [
      "epan/dissectors/packet-rpcrdma.c||epan/dissectors/packet-rpcrdma.c"
    ]
  },
  "patch_diff": {
    "epan/dissectors/packet-rpcrdma.c||epan/dissectors/packet-rpcrdma.c": [
      "File: epan/dissectors/packet-rpcrdma.c -> epan/dissectors/packet-rpcrdma.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "148: static guint get_write_chunk_size(tvbuff_t *tvb, guint offset)",
      "149: {",
      "150:     guint segment_count;",
      "152:     segment_count = tvb_get_ntohl(tvb, offset);",
      "153:     return 4 + (segment_count * 16);",
      "154: }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "151:     guint max_count = (guint)tvb_reported_length_remaining(tvb, offset + 4) / 16;",
      "154:     if (segment_count > max_count) {",
      "156:         segment_count = max_count;",
      "157:     }",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "167:             break;",
      "169:         chunk_size = get_write_chunk_size(tvb, offset);",
      "172:             return 0;",
      "173:         offset += chunk_size;",
      "174:     }",
      "",
      "[Removed Lines]",
      "170:         if ((offset + chunk_size) < offset ||",
      "171:             (offset + chunk_size) > max_offset)",
      "",
      "[Added Lines]",
      "175:         if ((offset > max_offset) ||",
      "176:             (max_offset - offset < chunk_size))",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "191:         num_chunks++;",
      "192:         chunk_size = get_write_chunk_size(tvb, offset);",
      "194:             break;",
      "195:         offset += chunk_size;",
      "196:     }",
      "",
      "[Removed Lines]",
      "193:         if ((offset + chunk_size) < offset)",
      "",
      "[Added Lines]",
      "198:         if (chunk_size == 0)",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "bd6313181317bfe83842b27650b65f3c2b8d5dc9",
      "candidate_info": {
        "commit_hash": "bd6313181317bfe83842b27650b65f3c2b8d5dc9",
        "repo": "wireshark/wireshark",
        "commit_url": "https://github.com/wireshark/wireshark/commit/bd6313181317bfe83842b27650b65f3c2b8d5dc9",
        "files": [
          "epan/dissectors/packet-rpcrdma.c"
        ],
        "message": "RPCoRDMA: Set an upper bound for our chunk size.\n\nMake sure our write chunk size doesn't exceed our tvbuff. Adjust a few\nlength checks.\n\nBug: 14449\nChange-Id: If9dd8a6094830c5b47adfff0acb3ff726168e801\nReviewed-on: https://code.wireshark.org/review/25945\nPetri-Dish: Michael Mann <mmann78@netscape.net>\nTested-by: Petri Dish Buildbot\nReviewed-by: Michael Mann <mmann78@netscape.net>",
        "before_after_code_files": [
          "epan/dissectors/packet-rpcrdma.c||epan/dissectors/packet-rpcrdma.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "epan/dissectors/packet-rpcrdma.c||epan/dissectors/packet-rpcrdma.c"
          ],
          "candidate": [
            "epan/dissectors/packet-rpcrdma.c||epan/dissectors/packet-rpcrdma.c"
          ]
        }
      },
      "candidate_diff": {
        "epan/dissectors/packet-rpcrdma.c||epan/dissectors/packet-rpcrdma.c": [
          "File: epan/dissectors/packet-rpcrdma.c -> epan/dissectors/packet-rpcrdma.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "178: static guint get_write_chunk_size(tvbuff_t *tvb, guint offset)",
          "179: {",
          "180:     guint segment_count;",
          "182:     segment_count = tvb_get_ntohl(tvb, offset);",
          "183:     return 4 + (segment_count * 16);",
          "184: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "181:     guint max_count = (guint)tvb_reported_length_remaining(tvb, offset + 4) / 16;",
          "184:     if (segment_count > max_count) {",
          "186:         segment_count = max_count;",
          "187:     }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "197:             break;",
          "199:         chunk_size = get_write_chunk_size(tvb, offset);",
          "202:             return 0;",
          "203:         offset += chunk_size;",
          "204:     }",
          "",
          "[Removed Lines]",
          "200:         if ((offset + chunk_size) < offset ||",
          "201:             (offset + chunk_size) > max_offset)",
          "",
          "[Added Lines]",
          "205:         if ((offset > max_offset) ||",
          "206:             (max_offset - offset < chunk_size))",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "221:         num_chunks++;",
          "222:         chunk_size = get_write_chunk_size(tvb, offset);",
          "224:             break;",
          "225:     }",
          "",
          "[Removed Lines]",
          "223:         if ((offset + chunk_size) < offset)",
          "",
          "[Added Lines]",
          "228:         if (chunk_size == 0)",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "2da2a36a8b42ef530a4706c6ea88731eb95126a8",
      "candidate_info": {
        "commit_hash": "2da2a36a8b42ef530a4706c6ea88731eb95126a8",
        "repo": "wireshark/wireshark",
        "commit_url": "https://github.com/wireshark/wireshark/commit/2da2a36a8b42ef530a4706c6ea88731eb95126a8",
        "files": [
          "epan/dissectors/packet-rpcrdma.c"
        ],
        "message": "RPCoRDMA: Set an upper bound for our chunk size.\n\nMake sure our write chunk size doesn't exceed our tvbuff. Adjust a few\nlength checks.\n\nBug: 14449\nChange-Id: If9dd8a6094830c5b47adfff0acb3ff726168e801\nReviewed-on: https://code.wireshark.org/review/25944\nPetri-Dish: Michael Mann <mmann78@netscape.net>\nTested-by: Petri Dish Buildbot\nReviewed-by: Michael Mann <mmann78@netscape.net>",
        "before_after_code_files": [
          "epan/dissectors/packet-rpcrdma.c||epan/dissectors/packet-rpcrdma.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "epan/dissectors/packet-rpcrdma.c||epan/dissectors/packet-rpcrdma.c"
          ],
          "candidate": [
            "epan/dissectors/packet-rpcrdma.c||epan/dissectors/packet-rpcrdma.c"
          ]
        }
      },
      "candidate_diff": {
        "epan/dissectors/packet-rpcrdma.c||epan/dissectors/packet-rpcrdma.c": [
          "File: epan/dissectors/packet-rpcrdma.c -> epan/dissectors/packet-rpcrdma.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "160: static guint get_write_chunk_size(tvbuff_t *tvb, guint offset)",
          "161: {",
          "162:     guint segment_count;",
          "164:     segment_count = tvb_get_ntohl(tvb, offset);",
          "165:     return 4 + (segment_count * 16);",
          "166: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "163:     guint max_count = (guint)tvb_reported_length_remaining(tvb, offset + 4) / 16;",
          "166:     if (segment_count > max_count) {",
          "168:         segment_count = max_count;",
          "169:     }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "179:             break;",
          "181:         chunk_size = get_write_chunk_size(tvb, offset);",
          "184:             return 0;",
          "185:         offset += chunk_size;",
          "186:     }",
          "",
          "[Removed Lines]",
          "182:         if ((offset + chunk_size) < offset ||",
          "183:             (offset + chunk_size) > max_offset)",
          "",
          "[Added Lines]",
          "187:         if ((offset > max_offset) ||",
          "188:             (max_offset - offset < chunk_size))",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "203:         num_chunks++;",
          "204:         chunk_size = get_write_chunk_size(tvb, offset);",
          "206:             break;",
          "207:         offset += chunk_size;",
          "208:     }",
          "",
          "[Removed Lines]",
          "205:         if ((offset + chunk_size) < offset)",
          "",
          "[Added Lines]",
          "210:         if (chunk_size == 0)",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2013-4263",
  "cve_desc": "libavfilter in FFmpeg before 2.0.1 has unspecified impact and remote vectors related to a crafted \"plane,\" which triggers an out-of-bounds heap write.",
  "repo": "FFmpeg/FFmpeg",
  "patch_hash": "e43a0a232dbf6d3c161823c2e07c52e76227a1bc",
  "patch_info": {
    "commit_hash": "e43a0a232dbf6d3c161823c2e07c52e76227a1bc",
    "repo": "FFmpeg/FFmpeg",
    "commit_url": "https://github.com/FFmpeg/FFmpeg/commit/e43a0a232dbf6d3c161823c2e07c52e76227a1bc",
    "files": [
      "libavfilter/vf_boxblur.c",
      "libavfilter/vf_delogo.c",
      "libavfilter/vf_fieldmatch.c",
      "libavfilter/vf_fieldorder.c",
      "libavfilter/vf_gradfun.c",
      "libavfilter/vf_hflip.c",
      "libavfilter/vf_kerndeint.c",
      "libavfilter/vf_lut.c",
      "libavfilter/vf_pad.c",
      "libavfilter/vf_showinfo.c",
      "libavfilter/vf_vignette.c"
    ],
    "message": "avfilter: fix plane validity checks\n\nFixes out of array accesses\n\nSigned-off-by: Michael Niedermayer <michaelni@gmx.at>",
    "before_after_code_files": [
      "libavfilter/vf_boxblur.c||libavfilter/vf_boxblur.c",
      "libavfilter/vf_delogo.c||libavfilter/vf_delogo.c",
      "libavfilter/vf_fieldmatch.c||libavfilter/vf_fieldmatch.c",
      "libavfilter/vf_fieldorder.c||libavfilter/vf_fieldorder.c",
      "libavfilter/vf_gradfun.c||libavfilter/vf_gradfun.c",
      "libavfilter/vf_hflip.c||libavfilter/vf_hflip.c",
      "libavfilter/vf_kerndeint.c||libavfilter/vf_kerndeint.c",
      "libavfilter/vf_lut.c||libavfilter/vf_lut.c",
      "libavfilter/vf_pad.c||libavfilter/vf_pad.c",
      "libavfilter/vf_showinfo.c||libavfilter/vf_showinfo.c",
      "libavfilter/vf_vignette.c||libavfilter/vf_vignette.c"
    ]
  },
  "patch_diff": {
    "libavfilter/vf_boxblur.c||libavfilter/vf_boxblur.c": [
      "File: libavfilter/vf_boxblur.c -> libavfilter/vf_boxblur.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "313:     }",
      "314:     av_frame_copy_props(out, in);",
      "317:         hblur(out->data[plane], out->linesize[plane],",
      "318:               in ->data[plane], in ->linesize[plane],",
      "319:               w[plane], h[plane], s->radius[plane], s->power[plane],",
      "320:               s->temp);",
      "323:         vblur(out->data[plane], out->linesize[plane],",
      "324:               out->data[plane], out->linesize[plane],",
      "325:               w[plane], h[plane], s->radius[plane], s->power[plane],",
      "",
      "[Removed Lines]",
      "316:     for (plane = 0; in->data[plane] && plane < 4; plane++)",
      "322:     for (plane = 0; in->data[plane] && plane < 4; plane++)",
      "",
      "[Added Lines]",
      "316:     for (plane = 0; plane < 4 && in->data[plane] && in->linesize[plane]; plane++)",
      "322:     for (plane = 0; plane < 4 && in->data[plane] && in->linesize[plane]; plane++)",
      "",
      "---------------"
    ],
    "libavfilter/vf_delogo.c||libavfilter/vf_delogo.c": [
      "File: libavfilter/vf_delogo.c -> libavfilter/vf_delogo.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "237:     if (!sar.num)",
      "238:         sar.num = sar.den = 1;",
      "241:         int hsub = plane == 1 || plane == 2 ? hsub0 : 0;",
      "242:         int vsub = plane == 1 || plane == 2 ? vsub0 : 0;",
      "",
      "[Removed Lines]",
      "240:     for (plane = 0; plane < 4 && in->data[plane]; plane++) {",
      "",
      "[Added Lines]",
      "240:     for (plane = 0; plane < 4 && in->data[plane] && in->linesize[plane]; plane++) {",
      "",
      "---------------"
    ],
    "libavfilter/vf_fieldmatch.c||libavfilter/vf_fieldmatch.c": [
      "File: libavfilter/vf_fieldmatch.c -> libavfilter/vf_fieldmatch.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "608:                         const AVFrame *src, int field)",
      "609: {",
      "610:     int plane;",
      "612:         av_image_copy_plane(dst->data[plane] + field*dst->linesize[plane], dst->linesize[plane] << 1,",
      "613:                             src->data[plane] + field*src->linesize[plane], src->linesize[plane] << 1,",
      "614:                             get_width(fm, src, plane), get_height(fm, src, plane) / 2);",
      "",
      "[Removed Lines]",
      "611:     for (plane = 0; plane < 4 && src->data[plane]; plane++)",
      "",
      "[Added Lines]",
      "611:     for (plane = 0; plane < 4 && src->data[plane] && src->linesize[plane]; plane++)",
      "",
      "---------------"
    ],
    "libavfilter/vf_fieldorder.c||libavfilter/vf_fieldorder.c": [
      "File: libavfilter/vf_fieldorder.c -> libavfilter/vf_fieldorder.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "106:             \"picture will move %s one line\\n\",",
      "107:             s->dst_tff ? \"up\" : \"down\");",
      "108:     h = frame->height;",
      "110:         line_step = frame->linesize[plane];",
      "111:         line_size = s->line_size[plane];",
      "112:         data = frame->data[plane];",
      "",
      "[Removed Lines]",
      "109:     for (plane = 0; plane < 4 && frame->data[plane]; plane++) {",
      "",
      "[Added Lines]",
      "109:     for (plane = 0; plane < 4 && frame->data[plane] && frame->linesize[plane]; plane++) {",
      "",
      "---------------"
    ],
    "libavfilter/vf_gradfun.c||libavfilter/vf_gradfun.c": [
      "File: libavfilter/vf_gradfun.c -> libavfilter/vf_gradfun.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "199:         av_frame_copy_props(out, in);",
      "200:     }",
      "203:         int w = inlink->w;",
      "204:         int h = inlink->h;",
      "205:         int r = s->radius;",
      "",
      "[Removed Lines]",
      "202:     for (p = 0; p < 4 && in->data[p]; p++) {",
      "",
      "[Added Lines]",
      "202:     for (p = 0; p < 4 && in->data[p] && in->linesize[p]; p++) {",
      "",
      "---------------"
    ],
    "libavfilter/vf_hflip.c||libavfilter/vf_hflip.c": [
      "File: libavfilter/vf_hflip.c -> libavfilter/vf_hflip.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "90:     if (av_pix_fmt_desc_get(inlink->format)->flags & AV_PIX_FMT_FLAG_PAL)",
      "91:         memcpy(out->data[1], in->data[1], AVPALETTE_SIZE);",
      "94:         const int width  = (plane == 1 || plane == 2) ? FF_CEIL_RSHIFT(inlink->w, s->hsub) : inlink->w;",
      "95:         const int height = (plane == 1 || plane == 2) ? FF_CEIL_RSHIFT(inlink->h, s->vsub) : inlink->h;",
      "96:         step = s->max_step[plane];",
      "",
      "[Removed Lines]",
      "93:     for (plane = 0; plane < 4 && in->data[plane]; plane++) {",
      "",
      "[Added Lines]",
      "93:     for (plane = 0; plane < 4 && in->data[plane] && in->linesize[plane]; plane++) {",
      "",
      "---------------"
    ],
    "libavfilter/vf_kerndeint.c||libavfilter/vf_kerndeint.c": [
      "File: libavfilter/vf_kerndeint.c -> libavfilter/vf_kerndeint.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "150:     av_frame_copy_props(outpic, inpic);",
      "151:     outpic->interlaced_frame = 0;",
      "154:         h = plane == 0 ? inlink->h : FF_CEIL_RSHIFT(inlink->h, kerndeint->vsub);",
      "155:         bwidth = kerndeint->tmp_bwidth[plane];",
      "",
      "[Removed Lines]",
      "153:     for (plane = 0; inpic->data[plane] && plane < 4; plane++) {",
      "",
      "[Added Lines]",
      "153:     for (plane = 0; plane < 4 && inpic->data[plane] && inpic->linesize[plane]; plane++) {",
      "",
      "---------------"
    ],
    "libavfilter/vf_lut.c||libavfilter/vf_lut.c": [
      "File: libavfilter/vf_lut.c -> libavfilter/vf_lut.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "304:         }",
      "305:     } else {",
      "308:             int vsub = plane == 1 || plane == 2 ? s->vsub : 0;",
      "309:             int hsub = plane == 1 || plane == 2 ? s->hsub : 0;",
      "310:             int h = FF_CEIL_RSHIFT(inlink->h, vsub);",
      "",
      "[Removed Lines]",
      "307:         for (plane = 0; plane < 4 && in->data[plane]; plane++) {",
      "",
      "[Added Lines]",
      "307:         for (plane = 0; plane < 4 && in->data[plane] && in->linesize[plane]; plane++) {",
      "",
      "---------------"
    ],
    "libavfilter/vf_pad.c||libavfilter/vf_pad.c": [
      "File: libavfilter/vf_pad.c -> libavfilter/vf_pad.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "214:     frame->width  = w;",
      "215:     frame->height = h;",
      "218:         int hsub = s->draw.hsub[plane];",
      "219:         int vsub = s->draw.vsub[plane];",
      "220:         frame->data[plane] += (s->x >> hsub) * s->draw.pixelstep[plane] +",
      "",
      "[Removed Lines]",
      "217:     for (plane = 0; plane < 4 && frame->data[plane]; plane++) {",
      "",
      "[Added Lines]",
      "217:     for (plane = 0; plane < 4 && frame->data[plane] && frame->linesize[plane]; plane++) {",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "311:         int i;",
      "313:         out = in;",
      "315:             int hsub = s->draw.hsub[i];",
      "316:             int vsub = s->draw.vsub[i];",
      "317:             out->data[i] -= (s->x >> hsub) * s->draw.pixelstep[i] +",
      "",
      "[Removed Lines]",
      "314:         for (i = 0; i < 4 && out->data[i]; i++) {",
      "",
      "[Added Lines]",
      "314:         for (i = 0; i < 4 && out->data[i] && out->linesize[i]; i++) {",
      "",
      "---------------"
    ],
    "libavfilter/vf_showinfo.c||libavfilter/vf_showinfo.c": [
      "File: libavfilter/vf_showinfo.c -> libavfilter/vf_showinfo.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "38:     uint32_t plane_checksum[4] = {0}, checksum = 0;",
      "39:     int i, plane, vsub = desc->log2_chroma_h;",
      "42:         int64_t linesize = av_image_get_linesize(frame->format, frame->width, plane);",
      "43:         uint8_t *data = frame->data[plane];",
      "44:         int h = plane == 1 || plane == 2 ? FF_CEIL_RSHIFT(inlink->h, vsub) : inlink->h;",
      "",
      "[Removed Lines]",
      "41:     for (plane = 0; plane < 4 && frame->data[plane]; plane++) {",
      "",
      "[Added Lines]",
      "41:     for (plane = 0; plane < 4 && frame->data[plane] && frame->linesize[plane]; plane++) {",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "68:            av_get_picture_type_char(frame->pict_type),",
      "69:            checksum, plane_checksum[0]);",
      "72:         av_log(ctx, AV_LOG_INFO, \" %08X\", plane_checksum[plane]);",
      "73:     av_log(ctx, AV_LOG_INFO, \"]\\n\");",
      "",
      "[Removed Lines]",
      "71:     for (plane = 1; plane < 4 && frame->data[plane]; plane++)",
      "",
      "[Added Lines]",
      "71:     for (plane = 1; plane < 4 && frame->data[plane] && frame->linesize[plane]; plane++)",
      "",
      "---------------"
    ],
    "libavfilter/vf_vignette.c||libavfilter/vf_vignette.c": [
      "File: libavfilter/vf_vignette.c -> libavfilter/vf_vignette.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "239:     } else {",
      "240:         int plane;",
      "243:             uint8_t       *dst = out->data[plane];",
      "244:             const uint8_t *src = in ->data[plane];",
      "245:             const float *fmap = s->fmap;",
      "",
      "[Removed Lines]",
      "242:         for (plane = 0; plane < 4 && in->data[plane]; plane++) {",
      "",
      "[Added Lines]",
      "242:         for (plane = 0; plane < 4 && in->data[plane] && in->linesize[plane]; plane++) {",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "9138f6da4a3ee0d11947b8593db6b6b05e53fbae",
      "candidate_info": {
        "commit_hash": "9138f6da4a3ee0d11947b8593db6b6b05e53fbae",
        "repo": "FFmpeg/FFmpeg",
        "commit_url": "https://github.com/FFmpeg/FFmpeg/commit/9138f6da4a3ee0d11947b8593db6b6b05e53fbae",
        "files": [
          "libavfilter/vf_showinfo.c"
        ],
        "message": "lavfi/showinfo: check plane count before dereferencing.",
        "before_after_code_files": [
          "libavfilter/vf_showinfo.c||libavfilter/vf_showinfo.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "libavfilter/vf_showinfo.c||libavfilter/vf_showinfo.c"
          ],
          "candidate": [
            "libavfilter/vf_showinfo.c||libavfilter/vf_showinfo.c"
          ]
        }
      },
      "candidate_diff": {
        "libavfilter/vf_showinfo.c||libavfilter/vf_showinfo.c": [
          "File: libavfilter/vf_showinfo.c -> libavfilter/vf_showinfo.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "50:     uint32_t plane_checksum[4] = {0}, checksum = 0;",
          "51:     int i, plane, vsub = desc->log2_chroma_h;",
          "54:         int64_t linesize = av_image_get_linesize(frame->format, frame->video->w, plane);",
          "55:         uint8_t *data = frame->data[plane];",
          "56:         int h = plane == 1 || plane == 2 ? inlink->h >> vsub : inlink->h;",
          "",
          "[Removed Lines]",
          "53:     for (plane = 0; frame->data[plane] && plane < 4; plane++) {",
          "",
          "[Added Lines]",
          "53:     for (plane = 0; plane < 4 && frame->data[plane]; plane++) {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "80:            av_get_picture_type_char(frame->video->pict_type),",
          "81:            checksum, plane_checksum[0]);",
          "84:         av_log(ctx, AV_LOG_INFO, \" %08X\", plane_checksum[plane]);",
          "85:     av_log(ctx, AV_LOG_INFO, \"]\\n\");",
          "",
          "[Removed Lines]",
          "83:     for (plane = 1; frame->data[plane] && plane < 4; plane++)",
          "",
          "[Added Lines]",
          "83:     for (plane = 1; plane < 4 && frame->data[plane]; plane++)",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "172505b8bc361e4b08c75baf2d4d94e6c2ac94b9",
      "candidate_info": {
        "commit_hash": "172505b8bc361e4b08c75baf2d4d94e6c2ac94b9",
        "repo": "FFmpeg/FFmpeg",
        "commit_url": "https://github.com/FFmpeg/FFmpeg/commit/172505b8bc361e4b08c75baf2d4d94e6c2ac94b9",
        "files": [
          "Changelog",
          "LICENSE",
          "configure",
          "doc/filters.texi",
          "libavfilter/Makefile",
          "libavfilter/allfilters.c",
          "libavfilter/version.h",
          "libavfilter/vf_kerndeint.c",
          "tests/fate/avfilter.mak",
          "tests/lavfi-regression.sh",
          "tests/ref/lavfi/kerndeint"
        ],
        "message": "lavfi: add kerndeint filter\n\nThis is a port of the kerndeint filter (libmpcodecs/vf_kerndeint) by\nDonal A. Graft (original avisynth plugin author), and is based on the\nwork by Je\u0301re\u0301my Tran <tran.jeremy.av@gmail.com> done for SOCIS 2012.",
        "before_after_code_files": [
          "libavfilter/allfilters.c||libavfilter/allfilters.c",
          "libavfilter/version.h||libavfilter/version.h",
          "libavfilter/vf_kerndeint.c||libavfilter/vf_kerndeint.c",
          "tests/fate/avfilter.mak||tests/fate/avfilter.mak",
          "tests/lavfi-regression.sh||tests/lavfi-regression.sh"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "libavfilter/vf_kerndeint.c||libavfilter/vf_kerndeint.c"
          ],
          "candidate": [
            "libavfilter/vf_kerndeint.c||libavfilter/vf_kerndeint.c"
          ]
        }
      },
      "candidate_diff": {
        "libavfilter/allfilters.c||libavfilter/allfilters.c": [
          "File: libavfilter/allfilters.c -> libavfilter/allfilters.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "108:     REGISTER_FILTER(HQDN3D,         hqdn3d,         vf);",
          "109:     REGISTER_FILTER(HUE,            hue,            vf);",
          "110:     REGISTER_FILTER(IDET,           idet,           vf);",
          "111:     REGISTER_FILTER(LUT,            lut,            vf);",
          "112:     REGISTER_FILTER(LUTRGB,         lutrgb,         vf);",
          "113:     REGISTER_FILTER(LUTYUV,         lutyuv,         vf);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "111:     REGISTER_FILTER(KERNDEINT,      kerndeint,      vf);",
          "",
          "---------------"
        ],
        "libavfilter/version.h||libavfilter/version.h": [
          "File: libavfilter/version.h -> libavfilter/version.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "29: #include \"libavutil/avutil.h\"",
          "31: #define LIBAVFILTER_VERSION_MAJOR  3",
          "35: #define LIBAVFILTER_VERSION_INT AV_VERSION_INT(LIBAVFILTER_VERSION_MAJOR, \\",
          "36:                                                LIBAVFILTER_VERSION_MINOR, \\",
          "",
          "[Removed Lines]",
          "32: #define LIBAVFILTER_VERSION_MINOR  30",
          "33: #define LIBAVFILTER_VERSION_MICRO 104",
          "",
          "[Added Lines]",
          "32: #define LIBAVFILTER_VERSION_MINOR  31",
          "33: #define LIBAVFILTER_VERSION_MICRO 100",
          "",
          "---------------"
        ],
        "libavfilter/vf_kerndeint.c||libavfilter/vf_kerndeint.c": [
          "File: libavfilter/vf_kerndeint.c -> libavfilter/vf_kerndeint.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "29: #include \"libavutil/imgutils.h\"",
          "30: #include \"libavutil/intreadwrite.h\"",
          "31: #include \"libavutil/opt.h\"",
          "32: #include \"libavutil/pixdesc.h\"",
          "34: #include \"avfilter.h\"",
          "35: #include \"formats.h\"",
          "36: #include \"internal.h\"",
          "38: typedef struct {",
          "39:     const AVClass *class;",
          "40:     int           frame; ///< frame count, starting from 0",
          "41:     int           thresh, map, order, sharp, twoway;",
          "42:     int           vsub;",
          "43:     uint8_t       *tmp_data [4];  ///< temporary plane data buffer",
          "44:     int           tmp_bwidth[4];  ///< temporary plane byte width",
          "45:     int           pixel_step;",
          "46: } KerndeintContext;",
          "48: #define OFFSET(x) offsetof(KerndeintContext, x)",
          "49: #define FLAGS AV_OPT_FLAG_VIDEO_PARAM|AV_OPT_FLAG_FILTERING_PARAM",
          "50: static const AVOption kerndeint_options[] = {",
          "51:     { \"thresh\", \"set the threshold\", OFFSET(thresh), AV_OPT_TYPE_INT, {.i64=10}, 0, 255, FLAGS },",
          "52:     { \"map\",    \"set the map\", OFFSET(map), AV_OPT_TYPE_INT, {.i64=0}, 0, 1, FLAGS },",
          "53:     { \"order\",  \"set the order\", OFFSET(order), AV_OPT_TYPE_INT, {.i64=0}, 0, 1, FLAGS },",
          "54:     { \"sharp\",  \"enable sharpening\", OFFSET(sharp), AV_OPT_TYPE_INT, {.i64=0}, 0, 1, FLAGS },",
          "55:     { \"twoway\", \"enable twoway\", OFFSET(twoway), AV_OPT_TYPE_INT, {.i64=0}, 0, 1, FLAGS },",
          "56:     { NULL }",
          "57: };",
          "59: AVFILTER_DEFINE_CLASS(kerndeint);",
          "61: static av_cold int init(AVFilterContext *ctx, const char *args)",
          "62: {",
          "63:     KerndeintContext *kerndeint = ctx->priv;",
          "64:     const char const * shorthand[] = { \"thresh\", \"map\", \"order\", \"sharp\", \"twoway\", NULL };",
          "66:     kerndeint->class = &kerndeint_class;",
          "67:     av_opt_set_defaults(kerndeint);",
          "69:     return av_opt_set_from_string(kerndeint, args, shorthand, \"=\", \":\");",
          "70: }",
          "72: static av_cold void uninit(AVFilterContext *ctx)",
          "73: {",
          "74:     KerndeintContext *kerndeint = ctx->priv;",
          "76:     av_free(kerndeint->tmp_data[0]);",
          "77:     av_opt_free(kerndeint);",
          "78: }",
          "80: static int query_formats(AVFilterContext *ctx)",
          "81: {",
          "82:     static const enum PixelFormat pix_fmts[] = {",
          "83:         AV_PIX_FMT_YUV420P,",
          "84:         AV_PIX_FMT_YUYV422,",
          "85:         AV_PIX_FMT_ARGB,",
          "86:         AV_PIX_FMT_NONE",
          "87:     };",
          "89:     ff_set_common_formats(ctx, ff_make_format_list(pix_fmts));",
          "91:     return 0;",
          "92: }",
          "94: static int config_props(AVFilterLink *inlink)",
          "95: {",
          "96:     KerndeintContext *kerndeint = inlink->dst->priv;",
          "97:     const AVPixFmtDescriptor *desc = &av_pix_fmt_descriptors[inlink->format];",
          "99:     kerndeint->vsub = desc->log2_chroma_h;",
          "100:     kerndeint->pixel_step = av_get_bits_per_pixel(desc) >> 3;",
          "102:     return av_image_alloc(kerndeint->tmp_data, kerndeint->tmp_bwidth,",
          "103:                           inlink->w, inlink->h, inlink->format, 1);",
          "104: }",
          "106: static int filter_frame(AVFilterLink *inlink, AVFilterBufferRef *inpic)",
          "107: {",
          "108:     KerndeintContext *kerndeint = inlink->dst->priv;",
          "109:     AVFilterLink *outlink = inlink->dst->outputs[0];",
          "110:     AVFilterBufferRef *outpic;",
          "111:     const uint8_t *prvp;   ///< Previous field's pixel line number n",
          "112:     const uint8_t *prvpp;  ///< Previous field's pixel line number (n - 1)",
          "113:     const uint8_t *prvpn;  ///< Previous field's pixel line number (n + 1)",
          "114:     const uint8_t *prvppp; ///< Previous field's pixel line number (n - 2)",
          "115:     const uint8_t *prvpnn; ///< Previous field's pixel line number (n + 2)",
          "116:     const uint8_t *prvp4p; ///< Previous field's pixel line number (n - 4)",
          "117:     const uint8_t *prvp4n; ///< Previous field's pixel line number (n + 4)",
          "119:     const uint8_t *srcp;   ///< Current field's pixel line number n",
          "120:     const uint8_t *srcpp;  ///< Current field's pixel line number (n - 1)",
          "121:     const uint8_t *srcpn;  ///< Current field's pixel line number (n + 1)",
          "122:     const uint8_t *srcppp; ///< Current field's pixel line number (n - 2)",
          "123:     const uint8_t *srcpnn; ///< Current field's pixel line number (n + 2)",
          "124:     const uint8_t *srcp3p; ///< Current field's pixel line number (n - 3)",
          "125:     const uint8_t *srcp3n; ///< Current field's pixel line number (n + 3)",
          "126:     const uint8_t *srcp4p; ///< Current field's pixel line number (n - 4)",
          "127:     const uint8_t *srcp4n; ///< Current field's pixel line number (n + 4)",
          "129:     uint8_t *dstp, *dstp_saved;",
          "130:     const uint8_t *srcp_saved;",
          "132:     int src_linesize, psrc_linesize, dst_linesize, bwidth;",
          "133:     int x, y, plane, val, hi, lo, g, h, n = kerndeint->frame++;",
          "134:     double valf;",
          "136:     const int thresh = kerndeint->thresh;",
          "137:     const int order  = kerndeint->order;",
          "138:     const int map    = kerndeint->map;",
          "139:     const int sharp  = kerndeint->sharp;",
          "140:     const int twoway = kerndeint->twoway;",
          "142:     outpic = ff_get_video_buffer(outlink, AV_PERM_WRITE|AV_PERM_ALIGN, outlink->w, outlink->h);",
          "143:     if (!outpic) {",
          "144:         avfilter_unref_bufferp(&inpic);",
          "145:         return AVERROR(ENOMEM);",
          "146:     }",
          "147:     avfilter_copy_buffer_ref_props(outpic, inpic);",
          "148:     outpic->video->interlaced = 0;",
          "150:     for (plane = 0; inpic->data[plane] && plane < 4; plane++) {",
          "151:         h = plane == 0 ? inlink->h : inlink->h >> kerndeint->vsub;",
          "152:         bwidth = kerndeint->tmp_bwidth[plane];",
          "154:         srcp = srcp_saved = inpic->data[plane];",
          "155:         src_linesize      = inpic->linesize[plane];",
          "156:         psrc_linesize     = outpic->linesize[plane];",
          "157:         dstp = dstp_saved = outpic->data[plane];",
          "158:         dst_linesize      = outpic->linesize[plane];",
          "159:         srcp              = srcp_saved + (1 - order) * src_linesize;",
          "160:         dstp              = dstp_saved + (1 - order) * dst_linesize;",
          "162:         for (y = 0; y < h; y += 2) {",
          "163:             memcpy(dstp, srcp, bwidth);",
          "164:             srcp += 2 * src_linesize;",
          "165:             dstp += 2 * dst_linesize;",
          "166:         }",
          "169:         memcpy(dstp_saved + order            * dst_linesize, srcp_saved + (1 -     order) * src_linesize, bwidth);",
          "170:         memcpy(dstp_saved + (2 + order    )  * dst_linesize, srcp_saved + (3 -     order) * src_linesize, bwidth);",
          "171:         memcpy(dstp_saved + (h - 2 + order)  * dst_linesize, srcp_saved + (h - 1 - order) * src_linesize, bwidth);",
          "172:         memcpy(dstp_saved + (h - 4 + order)  * dst_linesize, srcp_saved + (h - 3 - order) * src_linesize, bwidth);",
          "176:         prvp   = kerndeint->tmp_data[plane] + 5 * psrc_linesize - (1 - order) * psrc_linesize;",
          "177:         prvpp  = prvp - psrc_linesize;",
          "178:         prvppp = prvp - 2 * psrc_linesize;",
          "179:         prvp4p = prvp - 4 * psrc_linesize;",
          "180:         prvpn  = prvp + psrc_linesize;",
          "181:         prvpnn = prvp + 2 * psrc_linesize;",
          "182:         prvp4n = prvp + 4 * psrc_linesize;",
          "184:         srcp   = srcp_saved + 5 * src_linesize - (1 - order) * src_linesize;",
          "185:         srcpp  = srcp - src_linesize;",
          "186:         srcppp = srcp - 2 * src_linesize;",
          "187:         srcp3p = srcp - 3 * src_linesize;",
          "188:         srcp4p = srcp - 4 * src_linesize;",
          "190:         srcpn  = srcp + src_linesize;",
          "191:         srcpnn = srcp + 2 * src_linesize;",
          "192:         srcp3n = srcp + 3 * src_linesize;",
          "193:         srcp4n = srcp + 4 * src_linesize;",
          "195:         dstp   = dstp_saved + 5 * dst_linesize - (1 - order) * dst_linesize;",
          "197:         for (y = 5 - (1 - order); y <= h - 5 - (1 - order); y += 2) {",
          "198:             for (x = 0; x < bwidth; x++) {",
          "199:                 if (thresh == 0 || n == 0 ||",
          "200:                     (abs((int)prvp[x]  - (int)srcp[x])  > thresh) ||",
          "201:                     (abs((int)prvpp[x] - (int)srcpp[x]) > thresh) ||",
          "202:                     (abs((int)prvpn[x] - (int)srcpn[x]) > thresh)) {",
          "203:                     if (map) {",
          "204:                         g = x & ~3;",
          "206:                         if (inlink->format == AV_PIX_FMT_RGBA) {",
          "207:                             AV_WB32(dstp + g, 0xffffffff);",
          "208:                             x = g + 3;",
          "209:                         } else if (inlink->format == AV_PIX_FMT_YUYV422) {",
          "211:                             AV_WB32(dstp + g, 0xeb80eb80);",
          "212:                             x = g + 3;",
          "213:                         } else {",
          "214:                             dstp[x] = plane == 0 ? 235 : 128;",
          "215:                         }",
          "216:                     } else {",
          "217:                         if (inlink->format == AV_PIX_FMT_RGBA) {",
          "218:                             hi = 255;",
          "219:                             lo = 0;",
          "220:                         } else if (inlink->format == AV_PIX_FMT_YUYV422) {",
          "221:                             hi = x & 1 ? 240 : 235;",
          "222:                             lo = 16;",
          "223:                         } else {",
          "224:                             hi = plane == 0 ? 235 : 240;",
          "225:                             lo = 16;",
          "226:                         }",
          "228:                         if (sharp) {",
          "229:                             if (twoway) {",
          "230:                                 valf = + 0.526 * ((int)srcpp[x] + (int)srcpn[x])",
          "231:                                     + 0.170 * ((int)srcp[x] + (int)prvp[x])",
          "232:                                     - 0.116 * ((int)srcppp[x] + (int)srcpnn[x] + (int)prvppp[x] + (int)prvpnn[x])",
          "233:                                     - 0.026 * ((int)srcp3p[x] + (int)srcp3n[x])",
          "234:                                     + 0.031 * ((int)srcp4p[x] + (int)srcp4n[x] + (int)prvp4p[x] + (int)prvp4n[x]);",
          "235:                             } else {",
          "236:                                 valf = + 0.526 * ((int)srcpp[x] + (int)srcpn[x])",
          "237:                                     + 0.170 * ((int)prvp[x])",
          "238:                                     - 0.116 * ((int)prvppp[x] + (int)prvpnn[x])",
          "239:                                     - 0.026 * ((int)srcp3p[x] + (int)srcp3n[x])",
          "240:                                     + 0.031 * ((int)prvp4p[x] + (int)prvp4p[x]);",
          "241:                             }",
          "242:                             dstp[x] = av_clip(valf, lo, hi);",
          "243:                         } else {",
          "244:                             if (twoway) {",
          "245:                                 val = (8 * ((int)srcpp[x] + (int)srcpn[x]) + 2 * ((int)srcp[x] + (int)prvp[x])",
          "246:                                        - (int)(srcppp[x]) - (int)(srcpnn[x])",
          "247:                                        - (int)(prvppp[x]) - (int)(prvpnn[x])) >> 4;",
          "248:                             } else {",
          "249:                                 val = (8 * ((int)srcpp[x] + (int)srcpn[x]) + 2 * ((int)prvp[x])",
          "250:                                        - (int)(prvppp[x]) - (int)(prvpnn[x])) >> 4;",
          "251:                             }",
          "252:                             dstp[x] = av_clip(val, lo, hi);",
          "253:                         }",
          "254:                     }",
          "255:                 } else {",
          "256:                     dstp[x] = srcp[x];",
          "257:                 }",
          "258:             }",
          "259:             prvp   += 2 * psrc_linesize;",
          "260:             prvpp  += 2 * psrc_linesize;",
          "261:             prvppp += 2 * psrc_linesize;",
          "262:             prvpn  += 2 * psrc_linesize;",
          "263:             prvpnn += 2 * psrc_linesize;",
          "264:             prvp4p += 2 * psrc_linesize;",
          "265:             prvp4n += 2 * psrc_linesize;",
          "266:             srcp   += 2 * src_linesize;",
          "267:             srcpp  += 2 * src_linesize;",
          "268:             srcppp += 2 * src_linesize;",
          "269:             srcp3p += 2 * src_linesize;",
          "270:             srcp4p += 2 * src_linesize;",
          "271:             srcpn  += 2 * src_linesize;",
          "272:             srcpnn += 2 * src_linesize;",
          "273:             srcp3n += 2 * src_linesize;",
          "274:             srcp4n += 2 * src_linesize;",
          "275:             dstp   += 2 * dst_linesize;",
          "276:         }",
          "278:         srcp = inpic->data[plane];",
          "279:         dstp = kerndeint->tmp_data[plane];",
          "280:         av_image_copy_plane(dstp, psrc_linesize, srcp, src_linesize, bwidth, h);",
          "281:     }",
          "283:     avfilter_unref_buffer(inpic);",
          "284:     return ff_filter_frame(outlink, outpic);",
          "285: }",
          "287: static const AVFilterPad kerndeint_inputs[] = {",
          "288:     {",
          "289:         .name         = \"default\",",
          "290:         .type         = AVMEDIA_TYPE_VIDEO,",
          "291:         .filter_frame = filter_frame,",
          "292:         .config_props = config_props,",
          "293:         .min_perms    = AV_PERM_READ,",
          "294:     },",
          "295:     { NULL }",
          "296: };",
          "298: static const AVFilterPad kerndeint_outputs[] = {",
          "299:     {",
          "300:         .name = \"default\",",
          "301:         .type = AVMEDIA_TYPE_VIDEO,",
          "302:     },",
          "303:     { NULL }",
          "304: };",
          "306: AVFilter avfilter_vf_kerndeint = {",
          "307:     .name          = \"kerndeint\",",
          "308:     .description   = NULL_IF_CONFIG_SMALL(\"Apply kernel deinterlacing to the input.\"),",
          "309:     .priv_size     = sizeof(KerndeintContext),",
          "310:     .init          = init,",
          "311:     .uninit        = uninit,",
          "312:     .query_formats = query_formats,",
          "314:     .inputs        = kerndeint_inputs,",
          "315:     .outputs       = kerndeint_outputs,",
          "317:     .priv_class = &kerndeint_class,",
          "318: };",
          "",
          "---------------"
        ],
        "tests/fate/avfilter.mak||tests/fate/avfilter.mak": [
          "File: tests/fate/avfilter.mak -> tests/fate/avfilter.mak",
          "--- Hunk 1 ---",
          "[Context before]",
          "11:              fate-lavfi-fade                                            \\",
          "12:              fate-lavfi-field                                           \\",
          "13:              fate-lavfi-idet                                            \\",
          "14:              fate-lavfi-life                                            \\",
          "15:              fate-lavfi-null                                            \\",
          "16:              fate-lavfi-overlay                                         \\",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "14:              fate-lavfi-kerndeint                                       \\",
          "",
          "---------------"
        ],
        "tests/lavfi-regression.sh||tests/lavfi-regression.sh": [
          "File: tests/lavfi-regression.sh -> tests/lavfi-regression.sh",
          "--- Hunk 1 ---",
          "[Context before]",
          "80:     test ${test%_[bl]e} = $testname || return 0",
          "81:     filter=$2",
          "82:     filter_args=$3",
          "84:     showfiltfmts=\"$target_exec $target_path/libavfilter/filtfmts-test\"",
          "85:     scale_exclude_fmts=${outfile}${testname}_scale_exclude_fmts",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "83:     prefilter_chain=$4",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "96:     pix_fmts=$(comm -12 $scale_exclude_fmts $in_fmts)",
          "98:     for pix_fmt in $pix_fmts; do",
          "100:     done",
          "102:     rm $in_fmts $scale_in_fmts $scale_out_fmts $scale_exclude_fmts",
          "",
          "[Removed Lines]",
          "99:         do_video_filter $pix_fmt \"format=$pix_fmt,$filter=$filter_args\" -pix_fmt $pix_fmt",
          "",
          "[Added Lines]",
          "100:         do_video_filter $pix_fmt \"${prefilter_chain}format=$pix_fmt,$filter=$filter_args\" -pix_fmt $pix_fmt",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "105: # all these filters have exactly one input and exactly one output",
          "106: do_lavfi_pixfmts \"field\"               \"field\"   \"bottom\"",
          "107: do_lavfi_pixfmts \"pixfmts_copy\"        \"copy\"    \"\"",
          "108: do_lavfi_pixfmts \"pixfmts_crop\"        \"crop\"    \"100:100:100:100\"",
          "109: do_lavfi_pixfmts \"pixfmts_hflip\"       \"hflip\"   \"\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "108: do_lavfi_pixfmts \"kerndeint\"           \"kerndeint\" \"\" \"tinterlace=interleave_top,\"",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "2b550beb2299e30d5fc13596c619457c13b49d5f",
      "candidate_info": {
        "commit_hash": "2b550beb2299e30d5fc13596c619457c13b49d5f",
        "repo": "FFmpeg/FFmpeg",
        "commit_url": "https://github.com/FFmpeg/FFmpeg/commit/2b550beb2299e30d5fc13596c619457c13b49d5f",
        "files": [
          "libavfilter/vf_lut.c"
        ],
        "message": "vf_lut: add plane validity check in draw_slice()\n\nThe value for inpic->data[plane] with plane >=4 is undefined, and it\nwill contain in general random data. This change adds a check for\nexiting the loop when plane reaches the value 4.\n\nFix crash (occurring for example with: format=rgba,lut).",
        "before_after_code_files": [
          "libavfilter/vf_lut.c||libavfilter/vf_lut.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "libavfilter/vf_lut.c||libavfilter/vf_lut.c"
          ],
          "candidate": [
            "libavfilter/vf_lut.c||libavfilter/vf_lut.c"
          ]
        }
      },
      "candidate_diff": {
        "libavfilter/vf_lut.c||libavfilter/vf_lut.c": [
          "File: libavfilter/vf_lut.c -> libavfilter/vf_lut.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "319:         }",
          "320:     } else {",
          "323:             int vsub = plane == 1 || plane == 2 ? lut->vsub : 0;",
          "324:             int hsub = plane == 1 || plane == 2 ? lut->hsub : 0;",
          "",
          "[Removed Lines]",
          "322:         for (plane = 0; inpic->data[plane]; plane++) {",
          "",
          "[Added Lines]",
          "322:         for (plane = 0; plane < 4 && inpic->data[plane]; plane++) {",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "7a92ec93c6507bd3dea4563ec7a0e3679034fc57",
      "candidate_info": {
        "commit_hash": "7a92ec93c6507bd3dea4563ec7a0e3679034fc57",
        "repo": "FFmpeg/FFmpeg",
        "commit_url": "https://github.com/FFmpeg/FFmpeg/commit/7a92ec93c6507bd3dea4563ec7a0e3679034fc57",
        "files": [
          "Changelog",
          "doc/filters.texi",
          "libavfilter/Makefile",
          "libavfilter/allfilters.c",
          "libavfilter/version.h",
          "libavfilter/vf_decimate.c",
          "libavfilter/vf_fieldmatch.c"
        ],
        "message": "lavfi: port IVTC filters from vapoursynth.",
        "before_after_code_files": [
          "libavfilter/allfilters.c||libavfilter/allfilters.c",
          "libavfilter/version.h||libavfilter/version.h",
          "libavfilter/vf_decimate.c||libavfilter/vf_decimate.c",
          "libavfilter/vf_fieldmatch.c||libavfilter/vf_fieldmatch.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "libavfilter/vf_fieldmatch.c||libavfilter/vf_fieldmatch.c"
          ],
          "candidate": [
            "libavfilter/vf_fieldmatch.c||libavfilter/vf_fieldmatch.c"
          ]
        }
      },
      "candidate_diff": {
        "libavfilter/allfilters.c||libavfilter/allfilters.c": [
          "File: libavfilter/allfilters.c -> libavfilter/allfilters.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "107:     REGISTER_FILTER(CROP,           crop,           vf);",
          "108:     REGISTER_FILTER(CROPDETECT,     cropdetect,     vf);",
          "109:     REGISTER_FILTER(CURVES,         curves,         vf);",
          "110:     REGISTER_FILTER(DELOGO,         delogo,         vf);",
          "111:     REGISTER_FILTER(DESHAKE,        deshake,        vf);",
          "112:     REGISTER_FILTER(DRAWBOX,        drawbox,        vf);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "110:     REGISTER_FILTER(DECIMATE,       decimate,       vf);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "114:     REGISTER_FILTER(EDGEDETECT,     edgedetect,     vf);",
          "115:     REGISTER_FILTER(FADE,           fade,           vf);",
          "116:     REGISTER_FILTER(FIELD,          field,          vf);",
          "117:     REGISTER_FILTER(FIELDORDER,     fieldorder,     vf);",
          "118:     REGISTER_FILTER(FORMAT,         format,         vf);",
          "119:     REGISTER_FILTER(FPS,            fps,            vf);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "118:     REGISTER_FILTER(FIELDMATCH,     fieldmatch,     vf);",
          "",
          "---------------"
        ],
        "libavfilter/version.h||libavfilter/version.h": [
          "File: libavfilter/version.h -> libavfilter/version.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "29: #include \"libavutil/avutil.h\"",
          "31: #define LIBAVFILTER_VERSION_MAJOR  3",
          "33: #define LIBAVFILTER_VERSION_MICRO 100",
          "35: #define LIBAVFILTER_VERSION_INT AV_VERSION_INT(LIBAVFILTER_VERSION_MAJOR, \\",
          "",
          "[Removed Lines]",
          "32: #define LIBAVFILTER_VERSION_MINOR  55",
          "",
          "[Added Lines]",
          "32: #define LIBAVFILTER_VERSION_MINOR  56",
          "",
          "---------------"
        ],
        "libavfilter/vf_decimate.c||libavfilter/vf_decimate.c": [
          "File: libavfilter/vf_decimate.c -> libavfilter/vf_decimate.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "22: #include \"libavutil/opt.h\"",
          "23: #include \"libavutil/pixdesc.h\"",
          "24: #include \"libavutil/timestamp.h\"",
          "25: #include \"avfilter.h\"",
          "26: #include \"internal.h\"",
          "28: #define INPUT_MAIN     0",
          "29: #define INPUT_CLEANSRC 1",
          "31: struct qitem {",
          "32:     AVFrame *frame;",
          "33:     int64_t maxbdiff;",
          "34:     int64_t totdiff;",
          "35: };",
          "37: typedef struct {",
          "38:     const AVClass *class;",
          "39:     struct qitem *queue;    ///< window of cycle frames and the associated data diff",
          "40:     int fid;                ///< current frame id in the queue",
          "41:     int filled;             ///< 1 if the queue is filled, 0 otherwise",
          "42:     AVFrame *last;          ///< last frame from the previous queue",
          "43:     int64_t frame_count;    ///< output frame counter",
          "44:     AVFrame **clean_src;    ///< frame queue for the clean source",
          "45:     int got_frame[2];       ///< frame request flag for each input stream",
          "46:     double ts_unit;         ///< timestamp units for the output frames",
          "47:     uint32_t eof;           ///< bitmask for end of stream",
          "48:     int hsub, vsub;         ///< chroma subsampling values",
          "49:     int depth;",
          "50:     int nxblocks, nyblocks;",
          "51:     int bdiffsize;",
          "52:     int64_t *bdiffs;",
          "55:     int cycle;",
          "56:     double dupthresh_flt;",
          "57:     double scthresh_flt;",
          "58:     int64_t dupthresh;",
          "59:     int64_t scthresh;",
          "60:     int blockx, blocky;",
          "61:     int ppsrc;",
          "62:     int chroma;",
          "63: } DecimateContext;",
          "65: #define OFFSET(x) offsetof(DecimateContext, x)",
          "66: #define FLAGS AV_OPT_FLAG_VIDEO_PARAM|AV_OPT_FLAG_FILTERING_PARAM",
          "68: static const AVOption decimate_options[] = {",
          "69:     { \"cycle\",     \"set the number of frame from which one will be dropped\", OFFSET(cycle), AV_OPT_TYPE_INT, {.i64 = 5}, 2, 25, FLAGS },",
          "70:     { \"dupthresh\", \"set duplicate threshold\",    OFFSET(dupthresh_flt), AV_OPT_TYPE_DOUBLE, {.dbl =  1.1}, 0, 100, FLAGS },",
          "71:     { \"scthresh\",  \"set scene change threshold\", OFFSET(scthresh_flt),  AV_OPT_TYPE_DOUBLE, {.dbl = 15.0}, 0, 100, FLAGS },",
          "72:     { \"blockx\",    \"set the size of the x-axis blocks used during metric calculations\", OFFSET(blockx), AV_OPT_TYPE_INT, {.i64 = 32}, 4, 1<<9, FLAGS },",
          "73:     { \"blocky\",    \"set the size of the y-axis blocks used during metric calculations\", OFFSET(blocky), AV_OPT_TYPE_INT, {.i64 = 32}, 4, 1<<9, FLAGS },",
          "74:     { \"ppsrc\",     \"mark main input as a pre-processed input and activate clean source input stream\", OFFSET(ppsrc), AV_OPT_TYPE_INT, {.i64=0}, 0, 1, FLAGS },",
          "75:     { \"chroma\",    \"set whether or not chroma is considered in the metric calculations\", OFFSET(chroma), AV_OPT_TYPE_INT, {.i64=1}, 0, 1, FLAGS },",
          "76:     { NULL }",
          "77: };",
          "79: AVFILTER_DEFINE_CLASS(decimate);",
          "81: static void calc_diffs(const DecimateContext *dm, struct qitem *q,",
          "82:                        const AVFrame *f1, const AVFrame *f2)",
          "83: {",
          "84:     int64_t maxdiff = -1;",
          "85:     int64_t *bdiffs = dm->bdiffs;",
          "86:     int plane, i, j;",
          "88:     memset(bdiffs, 0, dm->bdiffsize * sizeof(*bdiffs));",
          "90:     for (plane = 0; plane < (dm->chroma ? 3 : 1); plane++) {",
          "91:         int x, y, xl;",
          "92:         const int linesize1 = f1->linesize[plane];",
          "93:         const int linesize2 = f2->linesize[plane];",
          "94:         const uint8_t *f1p = f1->data[plane];",
          "95:         const uint8_t *f2p = f2->data[plane];",
          "96:         int width    = plane ? f1->width  >> dm->hsub : f1->width;",
          "97:         int height   = plane ? f1->height >> dm->vsub : f1->height;",
          "98:         int hblockx  = dm->blockx / 2;",
          "99:         int hblocky  = dm->blocky / 2;",
          "101:         if (plane) {",
          "102:             hblockx >>= dm->hsub;",
          "103:             hblocky >>= dm->vsub;",
          "104:         }",
          "106:         for (y = 0; y < height; y++) {",
          "107:             int ydest = y / hblocky;",
          "108:             int xdest = 0;",
          "110: #define CALC_DIFF(nbits) do {                               \\",
          "111:     for (x = 0; x < width; x += hblockx) {                  \\",
          "112:         int64_t acc = 0;                                    \\",
          "113:         int m = FFMIN(width, x + hblockx);                  \\",
          "114:         for (xl = x; xl < m; xl++)                          \\",
          "115:             acc += abs(((const uint##nbits##_t *)f1p)[xl] - \\",
          "116:                        ((const uint##nbits##_t *)f2p)[xl]); \\",
          "117:         bdiffs[ydest * dm->nxblocks + xdest] += acc;        \\",
          "118:         xdest++;                                            \\",
          "119:     }                                                       \\",
          "120: } while (0)",
          "121:             if (dm->depth == 8) CALC_DIFF(8);",
          "122:             else                CALC_DIFF(16);",
          "124:             f1p += linesize1;",
          "125:             f2p += linesize2;",
          "126:         }",
          "127:     }",
          "129:     for (i = 0; i < dm->nyblocks - 1; i++) {",
          "130:         for (j = 0; j < dm->nxblocks - 1; j++) {",
          "131:             int64_t tmp = bdiffs[      i * dm->nxblocks + j    ]",
          "132:                         + bdiffs[      i * dm->nxblocks + j + 1]",
          "133:                         + bdiffs[(i + 1) * dm->nxblocks + j    ]",
          "134:                         + bdiffs[(i + 1) * dm->nxblocks + j + 1];",
          "135:             if (tmp > maxdiff)",
          "136:                 maxdiff = tmp;",
          "137:         }",
          "138:     }",
          "140:     q->totdiff = 0;",
          "141:     for (i = 0; i < dm->bdiffsize; i++)",
          "142:         q->totdiff += bdiffs[i];",
          "143:     q->maxbdiff = maxdiff;",
          "144: }",
          "146: static int filter_frame(AVFilterLink *inlink, AVFrame *in)",
          "147: {",
          "148:     int scpos = -1, duppos = -1;",
          "149:     int drop = INT_MIN, i, lowest = 0, ret;",
          "150:     AVFilterContext *ctx  = inlink->dst;",
          "151:     AVFilterLink *outlink = ctx->outputs[0];",
          "152:     DecimateContext *dm   = ctx->priv;",
          "153:     AVFrame *prv;",
          "156:     if (FF_INLINK_IDX(inlink) == INPUT_MAIN) {",
          "157:         dm->queue[dm->fid].frame = in;",
          "158:         dm->got_frame[INPUT_MAIN] = 1;",
          "159:     } else {",
          "160:         dm->clean_src[dm->fid] = in;",
          "161:         dm->got_frame[INPUT_CLEANSRC] = 1;",
          "162:     }",
          "163:     if (!dm->got_frame[INPUT_MAIN] || (dm->ppsrc && !dm->got_frame[INPUT_CLEANSRC]))",
          "164:         return 0;",
          "165:     dm->got_frame[INPUT_MAIN] = dm->got_frame[INPUT_CLEANSRC] = 0;",
          "167:     if (in) {",
          "169:         prv = dm->fid ? dm->queue[dm->fid - 1].frame : dm->last;",
          "170:         if (!prv)",
          "171:             prv = in;",
          "172:         calc_diffs(dm, &dm->queue[dm->fid], prv, in);",
          "173:         if (++dm->fid != dm->cycle)",
          "174:             return 0;",
          "175:         av_frame_free(&dm->last);",
          "176:         dm->last = av_frame_clone(in);",
          "177:         dm->fid = 0;",
          "180:         lowest = 0;",
          "181:         for (i = 0; i < dm->cycle; i++) {",
          "182:             if (dm->queue[i].totdiff > dm->scthresh)",
          "183:                 scpos = i;",
          "184:             if (dm->queue[i].maxbdiff < dm->queue[lowest].maxbdiff)",
          "185:                 lowest = i;",
          "186:         }",
          "187:         if (dm->queue[lowest].maxbdiff < dm->dupthresh)",
          "188:             duppos = lowest;",
          "189:         drop = scpos >= 0 && duppos < 0 ? scpos : lowest;",
          "190:     }",
          "193:     if (av_log_get_level() >= AV_LOG_DEBUG) {",
          "194:         av_log(ctx, AV_LOG_DEBUG, \"1/%d frame drop:\\n\", dm->cycle);",
          "195:         for (i = 0; i < dm->cycle && dm->queue[i].frame; i++) {",
          "196:             av_log(ctx, AV_LOG_DEBUG,\"  #%d: totdiff=%08\"PRIx64\" maxbdiff=%08\"PRIx64\"%s%s%s%s\\n\",",
          "197:                    i + 1, dm->queue[i].totdiff, dm->queue[i].maxbdiff,",
          "198:                    i == scpos  ? \" sc\"     : \"\",",
          "199:                    i == duppos ? \" dup\"    : \"\",",
          "200:                    i == lowest ? \" lowest\" : \"\",",
          "201:                    i == drop   ? \" [DROP]\" : \"\");",
          "202:         }",
          "203:     }",
          "206:     ret = 0;",
          "207:     for (i = 0; i < dm->cycle && dm->queue[i].frame; i++) {",
          "208:         if (i == drop) {",
          "209:             if (dm->ppsrc)",
          "210:                 av_frame_free(&dm->clean_src[i]);",
          "211:             av_frame_free(&dm->queue[i].frame);",
          "212:         } else {",
          "213:             AVFrame *frame = dm->queue[i].frame;",
          "214:             if (dm->ppsrc) {",
          "215:                 av_frame_free(&frame);",
          "216:                 frame = dm->clean_src[i];",
          "217:             }",
          "218:             frame->pts = dm->frame_count++ * dm->ts_unit;",
          "219:             ret = ff_filter_frame(outlink, frame);",
          "220:             if (ret < 0)",
          "221:                 break;",
          "222:         }",
          "223:     }",
          "225:     return ret;",
          "226: }",
          "228: static int config_input(AVFilterLink *inlink)",
          "229: {",
          "230:     int max_value;",
          "231:     AVFilterContext *ctx = inlink->dst;",
          "232:     DecimateContext *dm = ctx->priv;",
          "233:     const AVPixFmtDescriptor *pix_desc = av_pix_fmt_desc_get(inlink->format);",
          "234:     const int w = inlink->w;",
          "235:     const int h = inlink->h;",
          "237:     dm->hsub      = pix_desc->log2_chroma_w;",
          "238:     dm->vsub      = pix_desc->log2_chroma_h;",
          "239:     dm->depth     = pix_desc->comp[0].depth_minus1 + 1;",
          "240:     max_value     = (1 << dm->depth) - 1;",
          "241:     dm->scthresh  = (int64_t)(((int64_t)max_value *          w * h          * dm->scthresh_flt)  / 100);",
          "242:     dm->dupthresh = (int64_t)(((int64_t)max_value * dm->blockx * dm->blocky * dm->dupthresh_flt) / 100);",
          "243:     dm->nxblocks  = (w + dm->blockx/2 - 1) / (dm->blockx/2);",
          "244:     dm->nyblocks  = (h + dm->blocky/2 - 1) / (dm->blocky/2);",
          "245:     dm->bdiffsize = dm->nxblocks * dm->nyblocks;",
          "246:     dm->bdiffs    = av_malloc(dm->bdiffsize * sizeof(*dm->bdiffs));",
          "247:     dm->queue     = av_calloc(dm->cycle, sizeof(*dm->queue));",
          "249:     if (!dm->bdiffs || !dm->queue)",
          "250:         return AVERROR(ENOMEM);",
          "252:     if (dm->ppsrc) {",
          "253:         dm->clean_src = av_calloc(dm->cycle, sizeof(*dm->clean_src));",
          "254:         if (!dm->clean_src)",
          "255:             return AVERROR(ENOMEM);",
          "256:     }",
          "258:     return 0;",
          "259: }",
          "261: static av_cold int decimate_init(AVFilterContext *ctx)",
          "262: {",
          "263:     const DecimateContext *dm = ctx->priv;",
          "264:     AVFilterPad pad = {",
          "265:         .name         = av_strdup(\"main\"),",
          "266:         .type         = AVMEDIA_TYPE_VIDEO,",
          "267:         .filter_frame = filter_frame,",
          "268:         .config_props = config_input,",
          "269:     };",
          "271:     if (!pad.name)",
          "272:         return AVERROR(ENOMEM);",
          "273:     ff_insert_inpad(ctx, INPUT_MAIN, &pad);",
          "275:     if (dm->ppsrc) {",
          "276:         pad.name = av_strdup(\"clean_src\");",
          "277:         pad.config_props = NULL;",
          "278:         if (!pad.name)",
          "279:             return AVERROR(ENOMEM);",
          "280:         ff_insert_inpad(ctx, INPUT_CLEANSRC, &pad);",
          "281:     }",
          "283:     if ((dm->blockx & (dm->blockx - 1)) ||",
          "284:         (dm->blocky & (dm->blocky - 1))) {",
          "285:         av_log(ctx, AV_LOG_ERROR, \"blockx and blocky settings must be power of two\\n\");",
          "286:         return AVERROR(EINVAL);",
          "287:     }",
          "289:     return 0;",
          "290: }",
          "292: static av_cold void decimate_uninit(AVFilterContext *ctx)",
          "293: {",
          "294:     int i;",
          "295:     DecimateContext *dm = ctx->priv;",
          "297:     av_frame_free(&dm->last);",
          "298:     av_freep(&dm->bdiffs);",
          "299:     av_freep(&dm->queue);",
          "300:     av_freep(&dm->clean_src);",
          "301:     for (i = 0; i < ctx->nb_inputs; i++)",
          "302:         av_freep(&ctx->input_pads[i].name);",
          "303: }",
          "305: static int request_inlink(AVFilterContext *ctx, int lid)",
          "306: {",
          "307:     int ret = 0;",
          "308:     DecimateContext *dm = ctx->priv;",
          "310:     if (!dm->got_frame[lid]) {",
          "311:         AVFilterLink *inlink = ctx->inputs[lid];",
          "312:         ret = ff_request_frame(inlink);",
          "313:         if (ret == AVERROR_EOF) { // flushing",
          "314:             dm->eof |= 1 << lid;",
          "315:             ret = filter_frame(inlink, NULL);",
          "316:         }",
          "317:     }",
          "318:     return ret;",
          "319: }",
          "321: static int request_frame(AVFilterLink *outlink)",
          "322: {",
          "323:     int ret;",
          "324:     AVFilterContext *ctx = outlink->src;",
          "325:     DecimateContext *dm = ctx->priv;",
          "326:     const uint32_t eof_mask = 1<<INPUT_MAIN | dm->ppsrc<<INPUT_CLEANSRC;",
          "328:     if ((dm->eof & eof_mask) == eof_mask) // flush done?",
          "329:         return AVERROR_EOF;",
          "330:     if ((ret = request_inlink(ctx, INPUT_MAIN)) < 0)",
          "331:         return ret;",
          "332:     if (dm->ppsrc && (ret = request_inlink(ctx, INPUT_CLEANSRC)) < 0)",
          "333:         return ret;",
          "334:     return 0;",
          "335: }",
          "337: static int query_formats(AVFilterContext *ctx)",
          "338: {",
          "339:     static const enum AVPixelFormat pix_fmts[] = {",
          "340: #define PF_NOALPHA(suf) AV_PIX_FMT_YUV420##suf,  AV_PIX_FMT_YUV422##suf,  AV_PIX_FMT_YUV444##suf",
          "341: #define PF_ALPHA(suf)   AV_PIX_FMT_YUVA420##suf, AV_PIX_FMT_YUVA422##suf, AV_PIX_FMT_YUVA444##suf",
          "342: #define PF(suf)         PF_NOALPHA(suf), PF_ALPHA(suf)",
          "343:         PF(P), PF(P9), PF(P10), PF_NOALPHA(P12), PF_NOALPHA(P14), PF(P16),",
          "344:         AV_PIX_FMT_YUV411P, AV_PIX_FMT_YUV410P,",
          "345:         AV_PIX_FMT_GRAY8,",
          "346:         AV_PIX_FMT_NONE",
          "347:     };",
          "348:     ff_set_common_formats(ctx, ff_make_format_list(pix_fmts));",
          "349:     return 0;",
          "350: }",
          "352: static int config_output(AVFilterLink *outlink)",
          "353: {",
          "354:     AVFilterContext *ctx = outlink->src;",
          "355:     DecimateContext *dm = ctx->priv;",
          "356:     const AVFilterLink *inlink =",
          "357:         ctx->inputs[dm->ppsrc ? INPUT_CLEANSRC : INPUT_MAIN];",
          "358:     AVRational fps = inlink->frame_rate;",
          "360:     if (!fps.num || !fps.den) {",
          "361:         av_log(ctx, AV_LOG_ERROR, \"The input needs a constant frame rate; \"",
          "362:                \"current rate of %d/%d is invalid\\n\", fps.num, fps.den);",
          "363:         return AVERROR(EINVAL);",
          "364:     }",
          "365:     fps = av_mul_q(fps, (AVRational){dm->cycle - 1, dm->cycle});",
          "366:     av_log(ctx, AV_LOG_VERBOSE, \"FPS: %d/%d -> %d/%d\\n\",",
          "367:            inlink->frame_rate.num, inlink->frame_rate.den, fps.num, fps.den);",
          "368:     outlink->flags |= FF_LINK_FLAG_REQUEST_LOOP;",
          "369:     outlink->time_base  = inlink->time_base;",
          "370:     outlink->frame_rate = fps;",
          "371:     outlink->sample_aspect_ratio = inlink->sample_aspect_ratio;",
          "372:     outlink->w = inlink->w;",
          "373:     outlink->h = inlink->h;",
          "374:     dm->ts_unit = av_q2d(av_inv_q(av_mul_q(fps, outlink->time_base)));",
          "375:     return 0;",
          "376: }",
          "378: static const AVFilterPad decimate_outputs[] = {",
          "379:     {",
          "380:         .name          = \"default\",",
          "381:         .type          = AVMEDIA_TYPE_VIDEO,",
          "382:         .request_frame = request_frame,",
          "383:         .config_props  = config_output,",
          "384:     },",
          "385:     { NULL }",
          "386: };",
          "388: AVFilter avfilter_vf_decimate = {",
          "389:     .name          = \"decimate\",",
          "390:     .description   = NULL_IF_CONFIG_SMALL(\"Decimate frames (post field matching filter).\"),",
          "391:     .init          = decimate_init,",
          "392:     .uninit        = decimate_uninit,",
          "393:     .priv_size     = sizeof(DecimateContext),",
          "394:     .query_formats = query_formats,",
          "395:     .outputs       = decimate_outputs,",
          "396:     .priv_class    = &decimate_class,",
          "397:     .flags         = AVFILTER_FLAG_DYNAMIC_INPUTS,",
          "398: };",
          "",
          "---------------"
        ],
        "libavfilter/vf_fieldmatch.c||libavfilter/vf_fieldmatch.c": [
          "File: libavfilter/vf_fieldmatch.c -> libavfilter/vf_fieldmatch.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "33: #include <inttypes.h>",
          "35: #include \"libavutil/avassert.h\"",
          "36: #include \"libavutil/imgutils.h\"",
          "37: #include \"libavutil/opt.h\"",
          "38: #include \"libavutil/timestamp.h\"",
          "39: #include \"avfilter.h\"",
          "40: #include \"internal.h\"",
          "42: #define INPUT_MAIN     0",
          "43: #define INPUT_CLEANSRC 1",
          "45: enum fieldmatch_parity {",
          "46:     FM_PARITY_AUTO   = -1,",
          "47:     FM_PARITY_BOTTOM =  0,",
          "48:     FM_PARITY_TOP    =  1,",
          "49: };",
          "51: enum matching_mode {",
          "52:     MODE_PC,",
          "53:     MODE_PC_N,",
          "54:     MODE_PC_U,",
          "55:     MODE_PC_N_UB,",
          "56:     MODE_PCN,",
          "57:     MODE_PCN_UB,",
          "58:     NB_MODE",
          "59: };",
          "61: enum comb_matching_mode {",
          "62:     COMBMATCH_NONE,",
          "63:     COMBMATCH_SC,",
          "64:     COMBMATCH_FULL,",
          "65:     NB_COMBMATCH",
          "66: };",
          "68: enum comb_dbg {",
          "69:     COMBDBG_NONE,",
          "70:     COMBDBG_PCN,",
          "71:     COMBDBG_PCNUB,",
          "72:     NB_COMBDBG",
          "73: };",
          "75: typedef struct {",
          "76:     const AVClass *class;",
          "78:     AVFrame *prv,  *src,  *nxt;     ///< main sliding window of 3 frames",
          "79:     AVFrame *prv2, *src2, *nxt2;    ///< sliding window of the optional second stream",
          "80:     int64_t frame_count;            ///< output frame counter",
          "81:     int got_frame[2];               ///< frame request flag for each input stream",
          "82:     int hsub, vsub;                 ///< chroma subsampling values",
          "83:     uint32_t eof;                   ///< bitmask for end of stream",
          "84:     int64_t lastscdiff;",
          "85:     int64_t lastn;",
          "88:     int order;",
          "89:     int ppsrc;",
          "90:     enum matching_mode mode;",
          "91:     int field;",
          "92:     int mchroma;",
          "93:     int y0, y1;",
          "94:     int64_t scthresh;",
          "95:     double scthresh_flt;",
          "96:     enum comb_matching_mode combmatch;",
          "97:     int combdbg;",
          "98:     int cthresh;",
          "99:     int chroma;",
          "100:     int blockx, blocky;",
          "101:     int combpel;",
          "104:     uint8_t *map_data[4];",
          "105:     int map_linesize[4];",
          "106:     uint8_t *cmask_data[4];",
          "107:     int cmask_linesize[4];",
          "108:     int *c_array;",
          "109:     int tpitchy, tpitchuv;",
          "110:     uint8_t *tbuffer;",
          "111: } FieldMatchContext;",
          "113: #define OFFSET(x) offsetof(FieldMatchContext, x)",
          "114: #define FLAGS AV_OPT_FLAG_VIDEO_PARAM|AV_OPT_FLAG_FILTERING_PARAM",
          "116: static const AVOption fieldmatch_options[] = {",
          "117:     { \"order\", \"specify the assumed field order\", OFFSET(order), AV_OPT_TYPE_INT, {.i64=FM_PARITY_AUTO}, -1, 1, FLAGS, \"order\" },",
          "118:         { \"auto\", \"auto detect parity\",        0, AV_OPT_TYPE_CONST, {.i64=FM_PARITY_AUTO},    INT_MIN, INT_MAX, FLAGS, \"order\" },",
          "119:         { \"bff\",  \"assume bottom field first\", 0, AV_OPT_TYPE_CONST, {.i64=FM_PARITY_BOTTOM},  INT_MIN, INT_MAX, FLAGS, \"order\" },",
          "120:         { \"tff\",  \"assume top field first\",    0, AV_OPT_TYPE_CONST, {.i64=FM_PARITY_TOP},     INT_MIN, INT_MAX, FLAGS, \"order\" },",
          "121:     { \"mode\", \"set the matching mode or strategy to use\", OFFSET(mode), AV_OPT_TYPE_INT, {.i64=MODE_PC_N}, MODE_PC, NB_MODE-1, FLAGS, \"mode\" },",
          "122:         { \"pc\",      \"2-way match (p/c)\",                                                                    0, AV_OPT_TYPE_CONST, {.i64=MODE_PC},      INT_MIN, INT_MAX, FLAGS, \"mode\" },",
          "123:         { \"pc_n\",    \"2-way match + 3rd match on combed (p/c + u)\",                                          0, AV_OPT_TYPE_CONST, {.i64=MODE_PC_N},    INT_MIN, INT_MAX, FLAGS, \"mode\" },",
          "124:         { \"pc_u\",    \"2-way match + 3rd match (same order) on combed (p/c + u)\",                             0, AV_OPT_TYPE_CONST, {.i64=MODE_PC_U},    INT_MIN, INT_MAX, FLAGS, \"mode\" },",
          "125:         { \"pc_n_ub\", \"2-way match + 3rd match on combed + 4th/5th matches if still combed (p/c + u + u/b)\",  0, AV_OPT_TYPE_CONST, {.i64=MODE_PC_N_UB}, INT_MIN, INT_MAX, FLAGS, \"mode\" },",
          "126:         { \"pcn\",     \"3-way match (p/c/n)\",                                                                  0, AV_OPT_TYPE_CONST, {.i64=MODE_PCN},     INT_MIN, INT_MAX, FLAGS, \"mode\" },",
          "127:         { \"pcn_ub\",  \"3-way match + 4th/5th matches on combed (p/c/n + u/b)\",                                0, AV_OPT_TYPE_CONST, {.i64=MODE_PCN_UB},  INT_MIN, INT_MAX, FLAGS, \"mode\" },",
          "128:     { \"ppsrc\", \"mark main input as a pre-processed input and activate clean source input stream\", OFFSET(ppsrc), AV_OPT_TYPE_INT, {.i64=0}, 0, 1, FLAGS },",
          "129:     { \"field\", \"set the field to match from\", OFFSET(field), AV_OPT_TYPE_INT, {.i64=FM_PARITY_AUTO}, -1, 1, FLAGS, \"field\" },",
          "130:         { \"auto\",   \"automatic (same value as 'order')\",    0, AV_OPT_TYPE_CONST, {.i64=FM_PARITY_AUTO},    INT_MIN, INT_MAX, FLAGS, \"field\" },",
          "131:         { \"bottom\", \"bottom field\",                         0, AV_OPT_TYPE_CONST, {.i64=FM_PARITY_BOTTOM},  INT_MIN, INT_MAX, FLAGS, \"field\" },",
          "132:         { \"top\",    \"top field\",                            0, AV_OPT_TYPE_CONST, {.i64=FM_PARITY_TOP},     INT_MIN, INT_MAX, FLAGS, \"field\" },",
          "133:     { \"mchroma\", \"set whether or not chroma is included during the match comparisons\", OFFSET(mchroma), AV_OPT_TYPE_INT, {.i64=1}, 0, 1,  FLAGS },",
          "134:     { \"y0\", \"define an exclusion band which excludes the lines between y0 and y1 from the field matching decision\", OFFSET(y0), AV_OPT_TYPE_INT, {.i64=0}, 0, INT_MAX, FLAGS },",
          "135:     { \"y1\", \"define an exclusion band which excludes the lines between y0 and y1 from the field matching decision\", OFFSET(y1), AV_OPT_TYPE_INT, {.i64=0}, 0, INT_MAX, FLAGS },",
          "136:     { \"scthresh\", \"set scene change detection threshold\", OFFSET(scthresh_flt), AV_OPT_TYPE_DOUBLE, {.dbl=12}, 0, 100, FLAGS },",
          "137:     { \"combmatch\", \"set combmatching mode\", OFFSET(combmatch), AV_OPT_TYPE_INT, {.i64=COMBMATCH_SC}, COMBMATCH_NONE, NB_COMBMATCH-1, FLAGS, \"combmatching\" },",
          "138:         { \"none\", \"disable combmatching\",                     0, AV_OPT_TYPE_CONST, {.i64=COMBMATCH_NONE}, INT_MIN, INT_MAX, FLAGS, \"combmatching\" },",
          "139:         { \"sc\",   \"enable combmatching only on scene change\", 0, AV_OPT_TYPE_CONST, {.i64=COMBMATCH_SC},   INT_MIN, INT_MAX, FLAGS, \"combmatching\" },",
          "140:         { \"full\", \"enable combmatching all the time\",         0, AV_OPT_TYPE_CONST, {.i64=COMBMATCH_FULL}, INT_MIN, INT_MAX, FLAGS, \"combmatching\" },",
          "141:     { \"combdbg\",   \"enable comb debug\", OFFSET(combdbg), AV_OPT_TYPE_INT, {.i64=COMBDBG_NONE}, COMBDBG_NONE, NB_COMBDBG-1, FLAGS, \"dbglvl\" },",
          "142:         { \"none\",  \"no forced calculation\", 0, AV_OPT_TYPE_CONST, {.i64=COMBDBG_NONE},  INT_MIN, INT_MAX, FLAGS, \"dbglvl\" },",
          "143:         { \"pcn\",   \"calculate p/c/n\",       0, AV_OPT_TYPE_CONST, {.i64=COMBDBG_PCN},   INT_MIN, INT_MAX, FLAGS, \"dbglvl\" },",
          "144:         { \"pcnub\", \"calculate p/c/n/u/b\",   0, AV_OPT_TYPE_CONST, {.i64=COMBDBG_PCNUB}, INT_MIN, INT_MAX, FLAGS, \"dbglvl\" },",
          "145:     { \"cthresh\", \"set the area combing threshold used for combed frame detection\",       OFFSET(cthresh), AV_OPT_TYPE_INT, {.i64= 9}, -1, 0xff, FLAGS },",
          "146:     { \"chroma\",  \"set whether or not chroma is considered in the combed frame decision\", OFFSET(chroma),  AV_OPT_TYPE_INT, {.i64= 0},  0,    1, FLAGS },",
          "147:     { \"blockx\",  \"set the x-axis size of the window used during combed frame detection\", OFFSET(blockx),  AV_OPT_TYPE_INT, {.i64=16},  4, 1<<9, FLAGS },",
          "148:     { \"blocky\",  \"set the y-axis size of the window used during combed frame detection\", OFFSET(blocky),  AV_OPT_TYPE_INT, {.i64=16},  4, 1<<9, FLAGS },",
          "149:     { \"combpel\", \"set the number of combed pixels inside any of the blocky by blockx size blocks on the frame for the frame to be detected as combed\", OFFSET(combpel), AV_OPT_TYPE_INT, {.i64=80}, 0, INT_MAX, FLAGS },",
          "150:     { NULL }",
          "151: };",
          "153: AVFILTER_DEFINE_CLASS(fieldmatch);",
          "155: static int get_width(const FieldMatchContext *fm, const AVFrame *f, int plane)",
          "156: {",
          "157:     return plane ? f->width >> fm->hsub : f->width;",
          "158: }",
          "160: static int get_height(const FieldMatchContext *fm, const AVFrame *f, int plane)",
          "161: {",
          "162:     return plane ? f->height >> fm->vsub : f->height;",
          "163: }",
          "165: static int64_t luma_abs_diff(const AVFrame *f1, const AVFrame *f2)",
          "166: {",
          "167:     int x, y;",
          "168:     const uint8_t *srcp1 = f1->data[0];",
          "169:     const uint8_t *srcp2 = f2->data[0];",
          "170:     const int src1_linesize = f1->linesize[0];",
          "171:     const int src2_linesize = f2->linesize[0];",
          "172:     const int width  = f1->width;",
          "173:     const int height = f1->height;",
          "174:     int64_t acc = 0;",
          "176:     for (y = 0; y < height; y++) {",
          "177:         for (x = 0; x < width; x++)",
          "178:             acc += abs(srcp1[x] - srcp2[x]);",
          "179:         srcp1 += src1_linesize;",
          "180:         srcp2 += src2_linesize;",
          "181:     }",
          "182:     return acc;",
          "183: }",
          "185: static void fill_buf(uint8_t *data, int w, int h, int linesize, uint8_t v)",
          "186: {",
          "187:     int y;",
          "189:     for (y = 0; y < h; y++) {",
          "190:         memset(data, v, w);",
          "191:         data += linesize;",
          "192:     }",
          "193: }",
          "195: static int calc_combed_score(const FieldMatchContext *fm, const AVFrame *src)",
          "196: {",
          "197:     int x, y, plane, max_v = 0;",
          "198:     const int cthresh = fm->cthresh;",
          "199:     const int cthresh6 = cthresh * 6;",
          "201:     for (plane = 0; plane < (fm->chroma ? 3 : 1); plane++) {",
          "202:         const uint8_t *srcp = src->data[plane];",
          "203:         const int src_linesize = src->linesize[plane];",
          "204:         const int width  = get_width (fm, src, plane);",
          "205:         const int height = get_height(fm, src, plane);",
          "206:         uint8_t *cmkp = fm->cmask_data[plane];",
          "207:         const int cmk_linesize = fm->cmask_linesize[plane];",
          "209:         if (cthresh < 0) {",
          "210:             fill_buf(cmkp, width, height, cmk_linesize, 0xff);",
          "211:             continue;",
          "212:         }",
          "213:         fill_buf(cmkp, width, height, cmk_linesize, 0);",
          "216: #define FILTER(xm2, xm1, xp1, xp2) \\",
          "217:         abs(  4 * srcp[x] \\",
          "218:              -3 * (srcp[x + (xm1)*src_linesize] + srcp[x + (xp1)*src_linesize]) \\",
          "219:              +    (srcp[x + (xm2)*src_linesize] + srcp[x + (xp2)*src_linesize])) > cthresh6",
          "222:         for (x = 0; x < width; x++) {",
          "223:             const int s1 = abs(srcp[x] - srcp[x + src_linesize]);",
          "224:             if (s1 > cthresh && FILTER(2, 1, 1, 2))",
          "225:                 cmkp[x] = 0xff;",
          "226:         }",
          "227:         srcp += src_linesize;",
          "228:         cmkp += cmk_linesize;",
          "231:         for (x = 0; x < width; x++) {",
          "232:             const int s1 = abs(srcp[x] - srcp[x - src_linesize]);",
          "233:             const int s2 = abs(srcp[x] - srcp[x + src_linesize]);",
          "234:             if (s1 > cthresh && s2 > cthresh && FILTER(2, -1, 1, 2))",
          "235:                 cmkp[x] = 0xff;",
          "236:         }",
          "237:         srcp += src_linesize;",
          "238:         cmkp += cmk_linesize;",
          "241:         for (y = 2; y < height-2; y++) {",
          "242:             for (x = 0; x < width; x++) {",
          "243:                 const int s1 = abs(srcp[x] - srcp[x - src_linesize]);",
          "244:                 const int s2 = abs(srcp[x] - srcp[x + src_linesize]);",
          "245:                 if (s1 > cthresh && s2 > cthresh && FILTER(-2, -1, 1, 2))",
          "246:                     cmkp[x] = 0xff;",
          "247:             }",
          "248:             srcp += src_linesize;",
          "249:             cmkp += cmk_linesize;",
          "250:         }",
          "253:         for (x = 0; x < width; x++) {",
          "254:             const int s1 = abs(srcp[x] - srcp[x - src_linesize]);",
          "255:             const int s2 = abs(srcp[x] - srcp[x + src_linesize]);",
          "256:             if (s1 > cthresh && s2 > cthresh && FILTER(-2, -1, 1, -2))",
          "257:                 cmkp[x] = 0xff;",
          "258:         }",
          "259:         srcp += src_linesize;",
          "260:         cmkp += cmk_linesize;",
          "263:         for (x = 0; x < width; x++) {",
          "264:             const int s1 = abs(srcp[x] - srcp[x - src_linesize]);",
          "265:             if (s1 > cthresh && FILTER(-2, -1, -1, -2))",
          "266:                 cmkp[x] = 0xff;",
          "267:         }",
          "268:     }",
          "270:     if (fm->chroma) {",
          "271:         uint8_t *cmkp  = fm->cmask_data[0];",
          "272:         uint8_t *cmkpU = fm->cmask_data[1];",
          "273:         uint8_t *cmkpV = fm->cmask_data[2];",
          "274:         const int width  = src->width  >> fm->hsub;",
          "275:         const int height = src->height >> fm->vsub;",
          "276:         const int cmk_linesize   = fm->cmask_linesize[0] << 1;",
          "277:         const int cmk_linesizeUV = fm->cmask_linesize[2];",
          "278:         uint8_t *cmkpp  = cmkp - (cmk_linesize>>1);",
          "279:         uint8_t *cmkpn  = cmkp + (cmk_linesize>>1);",
          "280:         uint8_t *cmkpnn = cmkp +  cmk_linesize;",
          "281:         for (y = 1; y < height - 1; y++) {",
          "282:             cmkpp  += cmk_linesize;",
          "283:             cmkp   += cmk_linesize;",
          "284:             cmkpn  += cmk_linesize;",
          "285:             cmkpnn += cmk_linesize;",
          "286:             cmkpV  += cmk_linesizeUV;",
          "287:             cmkpU  += cmk_linesizeUV;",
          "288:             for (x = 1; x < width - 1; x++) {",
          "289: #define HAS_FF_AROUND(p, lz) (p[x-1 - lz] == 0xff || p[x - lz] == 0xff || p[x+1 - lz] == 0xff || \\",
          "290:                               p[x-1     ] == 0xff ||                      p[x+1     ] == 0xff || \\",
          "291:                               p[x-1 + lz] == 0xff || p[x + lz] == 0xff || p[x+1 + lz] == 0xff)",
          "292:                 if ((cmkpV[x] == 0xff && HAS_FF_AROUND(cmkpV, cmk_linesizeUV)) ||",
          "293:                     (cmkpU[x] == 0xff && HAS_FF_AROUND(cmkpU, cmk_linesizeUV))) {",
          "294:                     ((uint16_t*)cmkp)[x]  = 0xffff;",
          "295:                     ((uint16_t*)cmkpn)[x] = 0xffff;",
          "296:                     if (y&1) ((uint16_t*)cmkpp)[x]  = 0xffff;",
          "297:                     else     ((uint16_t*)cmkpnn)[x] = 0xffff;",
          "298:                 }",
          "299:             }",
          "300:         }",
          "301:     }",
          "303:     {",
          "304:         const int blockx = fm->blockx;",
          "305:         const int blocky = fm->blocky;",
          "306:         const int xhalf = blockx/2;",
          "307:         const int yhalf = blocky/2;",
          "308:         const int cmk_linesize = fm->cmask_linesize[0];",
          "309:         const uint8_t *cmkp    = fm->cmask_data[0] + cmk_linesize;",
          "310:         const int width  = src->width;",
          "311:         const int height = src->height;",
          "312:         const int xblocks = ((width+xhalf)/blockx) + 1;",
          "313:         const int xblocks4 = xblocks<<2;",
          "314:         const int yblocks = ((height+yhalf)/blocky) + 1;",
          "315:         int *c_array = fm->c_array;",
          "316:         const int arraysize = (xblocks*yblocks)<<2;",
          "317:         int      heighta = (height/(blocky/2))*(blocky/2);",
          "318:         const int widtha = (width /(blockx/2))*(blockx/2);",
          "319:         if (heighta == height)",
          "320:             heighta = height - yhalf;",
          "321:         memset(c_array, 0, arraysize * sizeof(*c_array));",
          "323: #define C_ARRAY_ADD(v) do {                         \\",
          "324:     const int box1 = (x / blockx) * 4;              \\",
          "325:     const int box2 = ((x + xhalf) / blockx) * 4;    \\",
          "326:     c_array[temp1 + box1    ] += v;                 \\",
          "327:     c_array[temp1 + box2 + 1] += v;                 \\",
          "328:     c_array[temp2 + box1 + 2] += v;                 \\",
          "329:     c_array[temp2 + box2 + 3] += v;                 \\",
          "330: } while (0)",
          "332: #define VERTICAL_HALF(y_start, y_end) do {                                  \\",
          "333:     for (y = y_start; y < y_end; y++) {                                     \\",
          "334:         const int temp1 = (y / blocky) * xblocks4;                          \\",
          "335:         const int temp2 = ((y + yhalf) / blocky) * xblocks4;                \\",
          "336:         for (x = 0; x < width; x++)                                         \\",
          "337:             if (cmkp[x - cmk_linesize] == 0xff &&                           \\",
          "338:                 cmkp[x               ] == 0xff &&                           \\",
          "339:                 cmkp[x + cmk_linesize] == 0xff)                             \\",
          "340:                 C_ARRAY_ADD(1);                                             \\",
          "341:         cmkp += cmk_linesize;                                               \\",
          "342:     }                                                                       \\",
          "343: } while (0)",
          "345:         VERTICAL_HALF(1, yhalf);",
          "347:         for (y = yhalf; y < heighta; y += yhalf) {",
          "348:             const int temp1 = (y / blocky) * xblocks4;",
          "349:             const int temp2 = ((y + yhalf) / blocky) * xblocks4;",
          "351:             for (x = 0; x < widtha; x += xhalf) {",
          "352:                 const uint8_t *cmkp_tmp = cmkp + x;",
          "353:                 int u, v, sum = 0;",
          "354:                 for (u = 0; u < yhalf; u++) {",
          "355:                     for (v = 0; v < xhalf; v++)",
          "356:                         if (cmkp_tmp[v - cmk_linesize] == 0xff &&",
          "357:                             cmkp_tmp[v               ] == 0xff &&",
          "358:                             cmkp_tmp[v + cmk_linesize] == 0xff)",
          "359:                             sum++;",
          "360:                     cmkp_tmp += cmk_linesize;",
          "361:                 }",
          "362:                 if (sum)",
          "363:                     C_ARRAY_ADD(sum);",
          "364:             }",
          "366:             for (x = widtha; x < width; x++) {",
          "367:                 const uint8_t *cmkp_tmp = cmkp + x;",
          "368:                 int u, sum = 0;",
          "369:                 for (u = 0; u < yhalf; u++) {",
          "370:                     if (cmkp_tmp[-cmk_linesize] == 0xff &&",
          "371:                         cmkp_tmp[            0] == 0xff &&",
          "372:                         cmkp_tmp[ cmk_linesize] == 0xff)",
          "373:                         sum++;",
          "374:                     cmkp_tmp += cmk_linesize;",
          "375:                 }",
          "376:                 if (sum)",
          "377:                     C_ARRAY_ADD(sum);",
          "378:             }",
          "380:             cmkp += cmk_linesize * yhalf;",
          "381:         }",
          "383:         VERTICAL_HALF(heighta, height - 1);",
          "385:         for (x = 0; x < arraysize; x++)",
          "386:             if (c_array[x] > max_v)",
          "387:                 max_v = c_array[x];",
          "388:     }",
          "389:     return max_v;",
          "390: }",
          "393: static void build_abs_diff_mask(const uint8_t *prvp, int prv_linesize,",
          "394:                                 const uint8_t *nxtp, int nxt_linesize,",
          "395:                                 uint8_t *tbuffer,    int tbuf_linesize,",
          "396:                                 int width, int height)",
          "397: {",
          "398:     int y, x;",
          "400:     prvp -= prv_linesize;",
          "401:     nxtp -= nxt_linesize;",
          "402:     for (y = 0; y < height; y++) {",
          "403:         for (x = 0; x < width; x++)",
          "404:             tbuffer[x] = FFABS(prvp[x] - nxtp[x]);",
          "405:         prvp += prv_linesize;",
          "406:         nxtp += nxt_linesize;",
          "407:         tbuffer += tbuf_linesize;",
          "408:     }",
          "409: }",
          "414: static void build_diff_map(FieldMatchContext *fm,",
          "415:                            const uint8_t *prvp, int prv_linesize,",
          "416:                            const uint8_t *nxtp, int nxt_linesize,",
          "417:                            uint8_t *dstp, int dst_linesize, int height,",
          "418:                            int width, int plane)",
          "419: {",
          "420:     int x, y, u, diff, count;",
          "421:     int tpitch = plane ? fm->tpitchuv : fm->tpitchy;",
          "422:     const uint8_t *dp = fm->tbuffer + tpitch;",
          "424:     build_abs_diff_mask(prvp, prv_linesize, nxtp, nxt_linesize,",
          "425:                         fm->tbuffer, tpitch, width, height>>1);",
          "427:     for (y = 2; y < height - 2; y += 2) {",
          "428:         for (x = 1; x < width - 1; x++) {",
          "429:             diff = dp[x];",
          "430:             if (diff > 3) {",
          "431:                 for (count = 0, u = x-1; u < x+2 && count < 2; u++) {",
          "432:                     count += dp[u-tpitch] > 3;",
          "433:                     count += dp[u       ] > 3;",
          "434:                     count += dp[u+tpitch] > 3;",
          "435:                 }",
          "436:                 if (count > 1) {",
          "437:                     dstp[x] = 1;",
          "438:                     if (diff > 19) {",
          "439:                         int upper = 0, lower = 0;",
          "440:                         for (count = 0, u = x-1; u < x+2 && count < 6; u++) {",
          "441:                             if (dp[u-tpitch] > 19) { count++; upper = 1; }",
          "442:                             if (dp[u       ] > 19)   count++;",
          "443:                             if (dp[u+tpitch] > 19) { count++; lower = 1; }",
          "444:                         }",
          "445:                         if (count > 3) {",
          "446:                             if (upper && lower) {",
          "447:                                 dstp[x] |= 1<<1;",
          "448:                             } else {",
          "449:                                 int upper2 = 0, lower2 = 0;",
          "450:                                 for (u = FFMAX(x-4,0); u < FFMIN(x+5,width); u++) {",
          "451:                                     if (y != 2 &&        dp[u-2*tpitch] > 19) upper2 = 1;",
          "452:                                     if (                 dp[u-  tpitch] > 19) upper  = 1;",
          "453:                                     if (                 dp[u+  tpitch] > 19) lower  = 1;",
          "454:                                     if (y != height-4 && dp[u+2*tpitch] > 19) lower2 = 1;",
          "455:                                 }",
          "456:                                 if ((upper && (lower || upper2)) ||",
          "457:                                     (lower && (upper || lower2)))",
          "458:                                     dstp[x] |= 1<<1;",
          "459:                                 else if (count > 5)",
          "460:                                     dstp[x] |= 1<<2;",
          "461:                             }",
          "462:                         }",
          "463:                     }",
          "464:                 }",
          "465:             }",
          "466:         }",
          "467:         dp += tpitch;",
          "468:         dstp += dst_linesize;",
          "469:     }",
          "470: }",
          "472: enum { mP, mC, mN, mB, mU };",
          "474: static int get_field_base(int match, int field)",
          "475: {",
          "476:     return match < 3 ? 2 - field : 1 + field;",
          "477: }",
          "479: static AVFrame *select_frame(FieldMatchContext *fm, int match)",
          "480: {",
          "481:     if      (match == mP || match == mB) return fm->prv;",
          "482:     else if (match == mN || match == mU) return fm->nxt;",
          "483:     else  /* match == mC */              return fm->src;",
          "484: }",
          "486: static int compare_fields(FieldMatchContext *fm, int match1, int match2, int field)",
          "487: {",
          "488:     int plane, ret;",
          "489:     uint64_t accumPc = 0, accumPm = 0, accumPml = 0;",
          "490:     uint64_t accumNc = 0, accumNm = 0, accumNml = 0;",
          "491:     int norm1, norm2, mtn1, mtn2;",
          "492:     float c1, c2, mr;",
          "493:     const AVFrame *src = fm->src;",
          "495:     for (plane = 0; plane < (fm->mchroma ? 3 : 1); plane++) {",
          "496:         int x, y, temp1, temp2, fbase;",
          "497:         const AVFrame *prev, *next;",
          "498:         uint8_t *mapp    = fm->map_data[plane];",
          "499:         int map_linesize = fm->map_linesize[plane];",
          "500:         const uint8_t *srcp = src->data[plane];",
          "501:         const int src_linesize  = src->linesize[plane];",
          "502:         const int srcf_linesize = src_linesize << 1;",
          "503:         int prv_linesize,  nxt_linesize;",
          "504:         int prvf_linesize, nxtf_linesize;",
          "505:         const int width  = get_width (fm, src, plane);",
          "506:         const int height = get_height(fm, src, plane);",
          "507:         const int y0a = fm->y0 >> (plane != 0);",
          "508:         const int y1a = fm->y1 >> (plane != 0);",
          "509:         const int startx = (plane == 0 ? 8 : 4);",
          "510:         const int stopx  = width - startx;",
          "511:         const uint8_t *srcpf, *srcf, *srcnf;",
          "512:         const uint8_t *prvpf, *prvnf, *nxtpf, *nxtnf;",
          "514:         fill_buf(mapp, width, height, map_linesize, 0);",
          "517:         fbase = get_field_base(match1, field);",
          "518:         srcf  = srcp + (fbase + 1) * src_linesize;",
          "519:         srcpf = srcf - srcf_linesize;",
          "520:         srcnf = srcf + srcf_linesize;",
          "521:         mapp  = mapp + fbase * map_linesize;",
          "522:         prev = select_frame(fm, match1);",
          "523:         prv_linesize  = prev->linesize[plane];",
          "524:         prvf_linesize = prv_linesize << 1;",
          "525:         prvpf = prev->data[plane] + fbase * prv_linesize;   // previous frame, previous field",
          "526:         prvnf = prvpf + prvf_linesize;                      // previous frame, next     field",
          "529:         fbase = get_field_base(match2, field);",
          "530:         next = select_frame(fm, match2);",
          "531:         nxt_linesize  = next->linesize[plane];",
          "532:         nxtf_linesize = nxt_linesize << 1;",
          "533:         nxtpf = next->data[plane] + fbase * nxt_linesize;   // next frame, previous field",
          "534:         nxtnf = nxtpf + nxtf_linesize;                      // next frame, next     field",
          "536:         map_linesize <<= 1;",
          "537:         if ((match1 >= 3 && field == 1) || (match1 < 3 && field != 1))",
          "538:             build_diff_map(fm, prvpf, prvf_linesize, nxtpf, nxtf_linesize,",
          "539:                            mapp, map_linesize, height, width, plane);",
          "540:         else",
          "541:             build_diff_map(fm, prvnf, prvf_linesize, nxtnf, nxtf_linesize,",
          "542:                            mapp + map_linesize, map_linesize, height, width, plane);",
          "544:         for (y = 2; y < height - 2; y += 2) {",
          "545:             if (y0a == y1a || y < y0a || y > y1a) {",
          "546:                 for (x = startx; x < stopx; x++) {",
          "547:                     if (mapp[x] > 0 || mapp[x + map_linesize] > 0) {",
          "548:                         temp1 = srcpf[x] + (srcf[x] << 2) + srcnf[x]; // [1 4 1]",
          "550:                         temp2 = abs(3 * (prvpf[x] + prvnf[x]) - temp1);",
          "551:                         if (temp2 > 23 && ((mapp[x]&1) || (mapp[x + map_linesize]&1)))",
          "552:                             accumPc += temp2;",
          "553:                         if (temp2 > 42) {",
          "554:                             if ((mapp[x]&2) || (mapp[x + map_linesize]&2))",
          "555:                                 accumPm += temp2;",
          "556:                             if ((mapp[x]&4) || (mapp[x + map_linesize]&4))",
          "557:                                 accumPml += temp2;",
          "558:                         }",
          "560:                         temp2 = abs(3 * (nxtpf[x] + nxtnf[x]) - temp1);",
          "561:                         if (temp2 > 23 && ((mapp[x]&1) || (mapp[x + map_linesize]&1)))",
          "562:                             accumNc += temp2;",
          "563:                         if (temp2 > 42) {",
          "564:                             if ((mapp[x]&2) || (mapp[x + map_linesize]&2))",
          "565:                                 accumNm += temp2;",
          "566:                             if ((mapp[x]&4) || (mapp[x + map_linesize]&4))",
          "567:                                 accumNml += temp2;",
          "568:                         }",
          "569:                     }",
          "570:                 }",
          "571:             }",
          "572:             prvpf += prvf_linesize;",
          "573:             prvnf += prvf_linesize;",
          "574:             srcpf += srcf_linesize;",
          "575:             srcf  += srcf_linesize;",
          "576:             srcnf += srcf_linesize;",
          "577:             nxtpf += nxtf_linesize;",
          "578:             nxtnf += nxtf_linesize;",
          "579:             mapp  += map_linesize;",
          "580:         }",
          "581:     }",
          "583:     if (accumPm < 500 && accumNm < 500 && (accumPml >= 500 || accumNml >= 500) &&",
          "584:         FFMAX(accumPml,accumNml) > 3*FFMIN(accumPml,accumNml)) {",
          "585:         accumPm = accumPml;",
          "586:         accumNm = accumNml;",
          "587:     }",
          "589:     norm1 = (int)((accumPc / 6.0f) + 0.5f);",
          "590:     norm2 = (int)((accumNc / 6.0f) + 0.5f);",
          "591:     mtn1  = (int)((accumPm / 6.0f) + 0.5f);",
          "592:     mtn2  = (int)((accumNm / 6.0f) + 0.5f);",
          "593:     c1 = ((float)FFMAX(norm1,norm2)) / ((float)FFMAX(FFMIN(norm1,norm2),1));",
          "594:     c2 = ((float)FFMAX(mtn1, mtn2))  / ((float)FFMAX(FFMIN(mtn1, mtn2), 1));",
          "595:     mr = ((float)FFMAX(mtn1, mtn2))  / ((float)FFMAX(FFMAX(norm1,norm2),1));",
          "596:     if (((mtn1 >=  500 || mtn2 >=  500) && (mtn1*2 < mtn2*1 || mtn2*2 < mtn1*1)) ||",
          "597:         ((mtn1 >= 1000 || mtn2 >= 1000) && (mtn1*3 < mtn2*2 || mtn2*3 < mtn1*2)) ||",
          "598:         ((mtn1 >= 2000 || mtn2 >= 2000) && (mtn1*5 < mtn2*4 || mtn2*5 < mtn1*4)) ||",
          "599:         ((mtn1 >= 4000 || mtn2 >= 4000) && c2 > c1))",
          "600:         ret = mtn1 > mtn2 ? match2 : match1;",
          "601:     else if (mr > 0.005 && FFMAX(mtn1, mtn2) > 150 && (mtn1*2 < mtn2*1 || mtn2*2 < mtn1*1))",
          "602:         ret = mtn1 > mtn2 ? match2 : match1;",
          "603:     else",
          "604:         ret = norm1 > norm2 ? match2 : match1;",
          "605:     return ret;",
          "606: }",
          "608: static void copy_fields(const FieldMatchContext *fm, AVFrame *dst,",
          "609:                         const AVFrame *src, int field)",
          "610: {",
          "611:     int plane;",
          "612:     for (plane = 0; plane < 4 && src->data[plane]; plane++)",
          "613:         av_image_copy_plane(dst->data[plane] + field*dst->linesize[plane], dst->linesize[plane] << 1,",
          "614:                             src->data[plane] + field*src->linesize[plane], src->linesize[plane] << 1,",
          "615:                             get_width(fm, src, plane), get_height(fm, src, plane) / 2);",
          "616: }",
          "618: static AVFrame *create_weave_frame(AVFilterContext *ctx, int match, int field,",
          "619:                                    const AVFrame *prv, AVFrame *src, const AVFrame *nxt)",
          "620: {",
          "621:     AVFrame *dst;",
          "622:     FieldMatchContext *fm = ctx->priv;",
          "624:     if (match == mC) {",
          "625:         dst = av_frame_clone(src);",
          "626:     } else {",
          "627:         AVFilterLink *outlink = ctx->outputs[0];",
          "629:         dst = ff_get_video_buffer(outlink, outlink->w, outlink->h);",
          "630:         if (!dst)",
          "631:             return NULL;",
          "632:         av_frame_copy_props(dst, src);",
          "634:         switch (match) {",
          "635:         case mP: copy_fields(fm, dst, src, 1-field); copy_fields(fm, dst, prv,   field); break;",
          "636:         case mN: copy_fields(fm, dst, src, 1-field); copy_fields(fm, dst, nxt,   field); break;",
          "637:         case mB: copy_fields(fm, dst, src,   field); copy_fields(fm, dst, prv, 1-field); break;",
          "638:         case mU: copy_fields(fm, dst, src,   field); copy_fields(fm, dst, nxt, 1-field); break;",
          "639:         default: av_assert0(0);",
          "640:         }",
          "641:     }",
          "642:     return dst;",
          "643: }",
          "645: static int checkmm(AVFilterContext *ctx, int *combs, int m1, int m2,",
          "646:                    AVFrame **gen_frames, int field)",
          "647: {",
          "648:     const FieldMatchContext *fm = ctx->priv;",
          "650: #define LOAD_COMB(mid) do {                                                     \\",
          "651:     if (combs[mid] < 0) {                                                       \\",
          "652:         if (!gen_frames[mid])                                                   \\",
          "653:             gen_frames[mid] = create_weave_frame(ctx, mid, field,               \\",
          "654:                                                  fm->prv, fm->src, fm->nxt);    \\",
          "655:         combs[mid] = calc_combed_score(fm, gen_frames[mid]);                    \\",
          "656:     }                                                                           \\",
          "657: } while (0)",
          "659:     LOAD_COMB(m1);",
          "660:     LOAD_COMB(m2);",
          "662:     if ((combs[m2] * 3 < combs[m1] || (combs[m2] * 2 < combs[m1] && combs[m1] > fm->combpel)) &&",
          "663:         abs(combs[m2] - combs[m1]) >= 30 && combs[m2] < fm->combpel)",
          "664:         return m2;",
          "665:     else",
          "666:         return m1;",
          "667: }",
          "669: static const int fxo0m[] = { mP, mC, mN, mB, mU };",
          "670: static const int fxo1m[] = { mN, mC, mP, mU, mB };",
          "672: static int filter_frame(AVFilterLink *inlink, AVFrame *in)",
          "673: {",
          "674:     AVFilterContext *ctx  = inlink->dst;",
          "675:     AVFilterLink *outlink = ctx->outputs[0];",
          "676:     FieldMatchContext *fm = ctx->priv;",
          "677:     int combs[] = { -1, -1, -1, -1, -1 };",
          "678:     int order, field, i, match, sc = 0;",
          "679:     const int *fxo;",
          "680:     AVFrame *gen_frames[] = { NULL, NULL, NULL, NULL, NULL };",
          "681:     AVFrame *dst;",
          "684: #define SLIDING_FRAME_WINDOW(prv, src, nxt) do {                \\",
          "685:         if (prv != src) /* 2nd loop exception (1st has prv==src and we don't want to loose src) */ \\",
          "686:             av_frame_free(&prv);                                \\",
          "687:         prv = src;                                              \\",
          "688:         src = nxt;                                              \\",
          "689:         if (in)                                                 \\",
          "690:             nxt = in;                                           \\",
          "691:         if (!prv)                                               \\",
          "692:             prv = src;                                          \\",
          "693:         if (!prv) /* received only one frame at that point */   \\",
          "694:             return 0;                                           \\",
          "695:         av_assert0(prv && src && nxt);                          \\",
          "696: } while (0)",
          "697:     if (FF_INLINK_IDX(inlink) == INPUT_MAIN) {",
          "698:         SLIDING_FRAME_WINDOW(fm->prv, fm->src, fm->nxt);",
          "699:         fm->got_frame[INPUT_MAIN] = 1;",
          "700:     } else {",
          "701:         SLIDING_FRAME_WINDOW(fm->prv2, fm->src2, fm->nxt2);",
          "702:         fm->got_frame[INPUT_CLEANSRC] = 1;",
          "703:     }",
          "704:     if (!fm->got_frame[INPUT_MAIN] || (fm->ppsrc && !fm->got_frame[INPUT_CLEANSRC]))",
          "705:         return 0;",
          "706:     fm->got_frame[INPUT_MAIN] = fm->got_frame[INPUT_CLEANSRC] = 0;",
          "707:     in = fm->src;",
          "710:     order = fm->order != FM_PARITY_AUTO ? fm->order : (in->interlaced_frame ? in->top_field_first : 1);",
          "711:     field = fm->field != FM_PARITY_AUTO ? fm->field : order;",
          "712:     av_assert0(order == 0 || order == 1 || field == 0 || field == 1);",
          "713:     fxo = field ^ order ? fxo1m : fxo0m;",
          "717:     if (fm->combdbg) {",
          "718:         for (i = 0; i < FF_ARRAY_ELEMS(combs); i++) {",
          "719:             if (i > mN && fm->combdbg == COMBDBG_PCN)",
          "720:                 break;",
          "721:             gen_frames[i] = create_weave_frame(ctx, i, field, fm->prv, fm->src, fm->nxt);",
          "722:             if (!gen_frames[i])",
          "723:                 return AVERROR(ENOMEM);",
          "724:             combs[i] = calc_combed_score(fm, gen_frames[i]);",
          "725:         }",
          "726:         av_log(ctx, AV_LOG_INFO, \"COMBS: %3d %3d %3d %3d %3d\\n\",",
          "727:                combs[0], combs[1], combs[2], combs[3], combs[4]);",
          "728:     } else {",
          "729:         gen_frames[mC] = av_frame_clone(fm->src);",
          "730:         if (!gen_frames[mC])",
          "731:             return AVERROR(ENOMEM);",
          "732:     }",
          "735:     match = compare_fields(fm, fxo[mC], fxo[mP], field);",
          "736:     if (fm->mode == MODE_PCN || fm->mode == MODE_PCN_UB)",
          "737:         match = compare_fields(fm, match, fxo[mN], field);",
          "740:     if (fm->combmatch == COMBMATCH_SC) {",
          "741:         if (fm->lastn == fm->frame_count - 1) {",
          "742:             if (fm->lastscdiff > fm->scthresh)",
          "743:                 sc = 1;",
          "744:         } else if (luma_abs_diff(fm->prv, fm->src) > fm->scthresh) {",
          "745:             sc = 1;",
          "746:         }",
          "748:         if (!sc) {",
          "749:             fm->lastn = fm->frame_count;",
          "750:             fm->lastscdiff = luma_abs_diff(fm->src, fm->nxt);",
          "751:             sc = fm->lastscdiff > fm->scthresh;",
          "752:         }",
          "753:     }",
          "755:     if (fm->combmatch == COMBMATCH_FULL || (fm->combmatch == COMBMATCH_SC && sc)) {",
          "756:         switch (fm->mode) {",
          "758:         case MODE_PC:",
          "759:             match = checkmm(ctx, combs, match, match == fxo[mP] ? fxo[mC] : fxo[mP], gen_frames, field);",
          "760:             break;",
          "761:         case MODE_PC_N:",
          "762:             match = checkmm(ctx, combs, match, fxo[mN], gen_frames, field);",
          "763:             break;",
          "764:         case MODE_PC_U:",
          "765:             match = checkmm(ctx, combs, match, fxo[mU], gen_frames, field);",
          "766:             break;",
          "767:         case MODE_PC_N_UB:",
          "768:             match = checkmm(ctx, combs, match, fxo[mN], gen_frames, field);",
          "769:             match = checkmm(ctx, combs, match, fxo[mU], gen_frames, field);",
          "770:             match = checkmm(ctx, combs, match, fxo[mB], gen_frames, field);",
          "771:             break;",
          "773:         case MODE_PCN:",
          "774:             match = checkmm(ctx, combs, match, match == fxo[mP] ? fxo[mC] : fxo[mP], gen_frames, field);",
          "775:             break;",
          "776:         case MODE_PCN_UB:",
          "777:             match = checkmm(ctx, combs, match, fxo[mU], gen_frames, field);",
          "778:             match = checkmm(ctx, combs, match, fxo[mB], gen_frames, field);",
          "779:             break;",
          "780:         default:",
          "781:             av_assert0(0);",
          "782:         }",
          "783:     }",
          "786:     if (fm->ppsrc) {",
          "789:         dst = create_weave_frame(ctx, match, field, fm->prv2, fm->src2, fm->nxt2);",
          "790:     } else {",
          "791:         if (!gen_frames[match]) { // XXX: is that possible?",
          "792:             dst = create_weave_frame(ctx, match, field, fm->prv, fm->src, fm->nxt);",
          "793:         } else {",
          "794:             dst = gen_frames[match];",
          "795:             gen_frames[match] = NULL;",
          "796:         }",
          "797:     }",
          "798:     if (!dst)",
          "799:         return AVERROR(ENOMEM);",
          "800:     for (i = 0; i < FF_ARRAY_ELEMS(gen_frames); i++)",
          "801:         av_frame_free(&gen_frames[i]);",
          "805:     dst->interlaced_frame = combs[match] >= fm->combpel;",
          "806:     if (dst->interlaced_frame) {",
          "807:         av_log(ctx, AV_LOG_WARNING, \"Frame #%\"PRId64\" at %s is still interlaced\\n\",",
          "808:                fm->frame_count, av_ts2timestr(in->pts, &inlink->time_base));",
          "809:         dst->top_field_first = field;",
          "810:     }",
          "811:     fm->frame_count++;",
          "813:     av_log(ctx, AV_LOG_DEBUG, \"SC:%d | COMBS: %3d %3d %3d %3d %3d (combpel=%d)\"",
          "814:            \" match=%d combed=%s\\n\", sc, combs[0], combs[1], combs[2], combs[3], combs[4],",
          "815:            fm->combpel, match, dst->interlaced_frame ? \"YES\" : \"NO\");",
          "817:     return ff_filter_frame(outlink, dst);",
          "818: }",
          "820: static int request_inlink(AVFilterContext *ctx, int lid)",
          "821: {",
          "822:     int ret = 0;",
          "823:     FieldMatchContext *fm = ctx->priv;",
          "825:     if (!fm->got_frame[lid]) {",
          "826:         AVFilterLink *inlink = ctx->inputs[lid];",
          "827:         ret = ff_request_frame(inlink);",
          "828:         if (ret == AVERROR_EOF) { // flushing",
          "829:             fm->eof |= 1 << lid;",
          "830:             ret = filter_frame(inlink, NULL);",
          "831:         }",
          "832:     }",
          "833:     return ret;",
          "834: }",
          "836: static int request_frame(AVFilterLink *outlink)",
          "837: {",
          "838:     int ret;",
          "839:     AVFilterContext *ctx = outlink->src;",
          "840:     FieldMatchContext *fm = ctx->priv;",
          "841:     const uint32_t eof_mask = 1<<INPUT_MAIN | fm->ppsrc<<INPUT_CLEANSRC;",
          "843:     if ((fm->eof & eof_mask) == eof_mask) // flush done?",
          "844:         return AVERROR_EOF;",
          "845:     if ((ret = request_inlink(ctx, INPUT_MAIN)) < 0)",
          "846:         return ret;",
          "847:     if (fm->ppsrc && (ret = request_inlink(ctx, INPUT_CLEANSRC)) < 0)",
          "848:         return ret;",
          "849:     return 0;",
          "850: }",
          "852: static int query_formats(AVFilterContext *ctx)",
          "853: {",
          "855:     static const enum AVPixelFormat pix_fmts[] = {",
          "856:         AV_PIX_FMT_YUV444P,  AV_PIX_FMT_YUV422P,  AV_PIX_FMT_YUV420P,",
          "857:         AV_PIX_FMT_YUV411P,  AV_PIX_FMT_YUV410P,",
          "858:         AV_PIX_FMT_NONE",
          "859:     };",
          "860:     ff_set_common_formats(ctx, ff_make_format_list(pix_fmts));",
          "861:     return 0;",
          "862: }",
          "864: static int config_input(AVFilterLink *inlink)",
          "865: {",
          "866:     int ret;",
          "867:     AVFilterContext *ctx = inlink->dst;",
          "868:     FieldMatchContext *fm = ctx->priv;",
          "869:     const AVPixFmtDescriptor *pix_desc = av_pix_fmt_desc_get(inlink->format);",
          "870:     const int w = inlink->w;",
          "871:     const int h = inlink->h;",
          "873:     fm->scthresh = (int64_t)((w * h * 255.0 * fm->scthresh_flt) / 100.0);",
          "875:     if ((ret = av_image_alloc(fm->map_data,   fm->map_linesize,   w, h, inlink->format, 32)) < 0 ||",
          "876:         (ret = av_image_alloc(fm->cmask_data, fm->cmask_linesize, w, h, inlink->format, 32)) < 0)",
          "877:         return ret;",
          "879:     fm->hsub = pix_desc->log2_chroma_w;",
          "880:     fm->vsub = pix_desc->log2_chroma_h;",
          "882:     fm->tpitchy  = FFALIGN(w,      16);",
          "883:     fm->tpitchuv = FFALIGN(w >> 1, 16);",
          "885:     fm->tbuffer = av_malloc(h/2 * fm->tpitchy);",
          "886:     fm->c_array = av_malloc((((w + fm->blockx/2)/fm->blockx)+1) *",
          "887:                             (((h + fm->blocky/2)/fm->blocky)+1) *",
          "888:                             4 * sizeof(*fm->c_array));",
          "889:     if (!fm->tbuffer || !fm->c_array)",
          "890:         return AVERROR(ENOMEM);",
          "892:     return 0;",
          "893: }",
          "895: static av_cold int fieldmatch_init(AVFilterContext *ctx)",
          "896: {",
          "897:     const FieldMatchContext *fm = ctx->priv;",
          "898:     AVFilterPad pad = {",
          "899:         .name         = av_strdup(\"main\"),",
          "900:         .type         = AVMEDIA_TYPE_VIDEO,",
          "901:         .filter_frame = filter_frame,",
          "902:         .config_props = config_input,",
          "903:     };",
          "905:     if (!pad.name)",
          "906:         return AVERROR(ENOMEM);",
          "907:     ff_insert_inpad(ctx, INPUT_MAIN, &pad);",
          "909:     if (fm->ppsrc) {",
          "910:         pad.name = av_strdup(\"clean_src\");",
          "911:         pad.config_props = NULL;",
          "912:         if (!pad.name)",
          "913:             return AVERROR(ENOMEM);",
          "914:         ff_insert_inpad(ctx, INPUT_CLEANSRC, &pad);",
          "915:     }",
          "917:     if ((fm->blockx & (fm->blockx - 1)) ||",
          "918:         (fm->blocky & (fm->blocky - 1))) {",
          "919:         av_log(ctx, AV_LOG_ERROR, \"blockx and blocky settings must be power of two\\n\");",
          "920:         return AVERROR(EINVAL);",
          "921:     }",
          "923:     if (fm->combpel > fm->blockx * fm->blocky) {",
          "924:         av_log(ctx, AV_LOG_ERROR, \"Combed pixel should not be larger than blockx x blocky\\n\");",
          "925:         return AVERROR(EINVAL);",
          "926:     }",
          "928:     return 0;",
          "929: }",
          "931: static av_cold void fieldmatch_uninit(AVFilterContext *ctx)",
          "932: {",
          "933:     int i;",
          "934:     FieldMatchContext *fm = ctx->priv;",
          "936:     if (fm->prv != fm->src)",
          "937:         av_frame_free(&fm->prv);",
          "938:     if (fm->nxt != fm->src)",
          "939:         av_frame_free(&fm->nxt);",
          "940:     av_frame_free(&fm->src);",
          "941:     av_freep(&fm->map_data[0]);",
          "942:     av_freep(&fm->cmask_data[0]);",
          "943:     av_freep(&fm->tbuffer);",
          "944:     av_freep(&fm->c_array);",
          "945:     for (i = 0; i < ctx->nb_inputs; i++)",
          "946:         av_freep(&ctx->input_pads[i].name);",
          "947: }",
          "949: static int config_output(AVFilterLink *outlink)",
          "950: {",
          "951:     AVFilterContext *ctx  = outlink->src;",
          "952:     const FieldMatchContext *fm = ctx->priv;",
          "953:     const AVFilterLink *inlink =",
          "954:         ctx->inputs[fm->ppsrc ? INPUT_CLEANSRC : INPUT_MAIN];",
          "956:     outlink->flags |= FF_LINK_FLAG_REQUEST_LOOP;",
          "957:     outlink->time_base = inlink->time_base;",
          "958:     outlink->sample_aspect_ratio = inlink->sample_aspect_ratio;",
          "959:     outlink->frame_rate = inlink->frame_rate;",
          "960:     outlink->w = inlink->w;",
          "961:     outlink->h = inlink->h;",
          "962:     return 0;",
          "963: }",
          "965: static const AVFilterPad fieldmatch_outputs[] = {",
          "966:     {",
          "967:         .name          = \"default\",",
          "968:         .type          = AVMEDIA_TYPE_VIDEO,",
          "969:         .request_frame = request_frame,",
          "970:         .config_props  = config_output,",
          "971:     },",
          "972:     { NULL }",
          "973: };",
          "975: AVFilter avfilter_vf_fieldmatch = {",
          "976:     .name           = \"fieldmatch\",",
          "977:     .description    = NULL_IF_CONFIG_SMALL(\"Field matching for inverse telecine\"),",
          "978:     .query_formats  = query_formats,",
          "979:     .priv_size      = sizeof(FieldMatchContext),",
          "980:     .init           = fieldmatch_init,",
          "981:     .uninit         = fieldmatch_uninit,",
          "982:     .inputs         = NULL,",
          "983:     .outputs        = fieldmatch_outputs,",
          "984:     .priv_class     = &fieldmatch_class,",
          "985:     .flags          = AVFILTER_FLAG_DYNAMIC_INPUTS,",
          "986: };",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "0ab9362fcb77c2d442fa20afcc2f1d9151228f06",
      "candidate_info": {
        "commit_hash": "0ab9362fcb77c2d442fa20afcc2f1d9151228f06",
        "repo": "FFmpeg/FFmpeg",
        "commit_url": "https://github.com/FFmpeg/FFmpeg/commit/0ab9362fcb77c2d442fa20afcc2f1d9151228f06",
        "files": [
          "Changelog",
          "doc/filters.texi",
          "libavfilter/Makefile",
          "libavfilter/allfilters.c",
          "libavfilter/version.h",
          "libavfilter/vf_vignette.c"
        ],
        "message": "lavfi: add vignette filter.",
        "before_after_code_files": [
          "libavfilter/allfilters.c||libavfilter/allfilters.c",
          "libavfilter/version.h||libavfilter/version.h",
          "libavfilter/vf_vignette.c||libavfilter/vf_vignette.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "libavfilter/vf_vignette.c||libavfilter/vf_vignette.c"
          ],
          "candidate": [
            "libavfilter/vf_vignette.c||libavfilter/vf_vignette.c"
          ]
        }
      },
      "candidate_diff": {
        "libavfilter/allfilters.c||libavfilter/allfilters.c": [
          "File: libavfilter/allfilters.c -> libavfilter/allfilters.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "188:     REGISTER_FILTER(VFLIP,          vflip,          vf);",
          "189:     REGISTER_FILTER(VIDSTABDETECT,  vidstabdetect,  vf);",
          "190:     REGISTER_FILTER(VIDSTABTRANSFORM, vidstabtransform, vf);",
          "191:     REGISTER_FILTER(YADIF,          yadif,          vf);",
          "192:     REGISTER_FILTER(ZMQ,            zmq,            vf);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "191:     REGISTER_FILTER(VIGNETTE,       vignette,       vf);",
          "",
          "---------------"
        ],
        "libavfilter/version.h||libavfilter/version.h": [
          "File: libavfilter/version.h -> libavfilter/version.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "30: #include \"libavutil/avutil.h\"",
          "32: #define LIBAVFILTER_VERSION_MAJOR  3",
          "34: #define LIBAVFILTER_VERSION_MICRO 100",
          "36: #define LIBAVFILTER_VERSION_INT AV_VERSION_INT(LIBAVFILTER_VERSION_MAJOR, \\",
          "",
          "[Removed Lines]",
          "33: #define LIBAVFILTER_VERSION_MINOR  72",
          "",
          "[Added Lines]",
          "33: #define LIBAVFILTER_VERSION_MINOR  73",
          "",
          "---------------"
        ],
        "libavfilter/vf_vignette.c||libavfilter/vf_vignette.c": [
          "File: libavfilter/vf_vignette.c -> libavfilter/vf_vignette.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "21: #include \"libavutil/opt.h\"",
          "22: #include \"libavutil/eval.h\"",
          "23: #include \"libavutil/avassert.h\"",
          "24: #include \"libavutil/pixdesc.h\"",
          "25: #include \"avfilter.h\"",
          "26: #include \"formats.h\"",
          "27: #include \"internal.h\"",
          "28: #include \"video.h\"",
          "30: static const char *const var_names[] = {",
          "31:     \"w\",    // stream width",
          "32:     \"h\",    // stream height",
          "33:     \"n\",    // frame count",
          "34:     \"pts\",  // presentation timestamp expressed in AV_TIME_BASE units",
          "35:     \"r\",    // frame rate",
          "36:     \"t\",    // timestamp expressed in seconds",
          "37:     \"tb\",   // timebase",
          "38:     NULL",
          "39: };",
          "41: enum var_name {",
          "42:     VAR_W,",
          "43:     VAR_H,",
          "44:     VAR_N,",
          "45:     VAR_PTS,",
          "46:     VAR_R,",
          "47:     VAR_T,",
          "48:     VAR_TB,",
          "49:     VAR_NB",
          "50: };",
          "52: typedef struct {",
          "53:     const AVClass *class;",
          "54:     const AVPixFmtDescriptor *desc;",
          "55:     int backward;",
          "56:     enum EvalMode { EVAL_MODE_INIT, EVAL_MODE_FRAME, EVAL_MODE_NB } eval_mode;",
          "57: #define DEF_EXPR_FIELDS(name) AVExpr *name##_pexpr; char *name##_expr; double name;",
          "58:     DEF_EXPR_FIELDS(angle);",
          "59:     DEF_EXPR_FIELDS(x0);",
          "60:     DEF_EXPR_FIELDS(y0);",
          "61:     double var_values[VAR_NB];",
          "62:     float *fmap;",
          "63:     int fmap_linesize;",
          "64:     double dmax;",
          "65:     float xscale, yscale;",
          "66:     uint32_t dither;",
          "67:     int do_dither;",
          "68: } VignetteContext;",
          "70: #define OFFSET(x) offsetof(VignetteContext, x)",
          "71: #define FLAGS AV_OPT_FLAG_FILTERING_PARAM|AV_OPT_FLAG_VIDEO_PARAM",
          "72: static const AVOption vignette_options[] = {",
          "73:     { \"angle\", \"set lens angle\", OFFSET(angle_expr), AV_OPT_TYPE_STRING, {.str=\"PI/5\"}, .flags = FLAGS },",
          "74:     { \"a\",     \"set lens angle\", OFFSET(angle_expr), AV_OPT_TYPE_STRING, {.str=\"PI/5\"}, .flags = FLAGS },",
          "75:     { \"x0\", \"set circle center position on x-axis\", OFFSET(x0_expr), AV_OPT_TYPE_STRING, {.str=\"w/2\"}, .flags = FLAGS },",
          "76:     { \"y0\", \"set circle center position on y-axis\", OFFSET(y0_expr), AV_OPT_TYPE_STRING, {.str=\"h/2\"}, .flags = FLAGS },",
          "77:     { \"mode\", \"set forward/backward mode\", OFFSET(backward), AV_OPT_TYPE_INT, {.i64 = 0}, 0, 1, FLAGS, \"mode\" },",
          "78:         { \"forward\",  NULL, 0, AV_OPT_TYPE_CONST, {.i64 = 0}, INT_MIN, INT_MAX, FLAGS, \"mode\"},",
          "79:         { \"backward\", NULL, 0, AV_OPT_TYPE_CONST, {.i64 = 1}, INT_MIN, INT_MAX, FLAGS, \"mode\"},",
          "80:     { \"eval\", \"specify when to evaluate expressions\", OFFSET(eval_mode), AV_OPT_TYPE_INT, {.i64 = EVAL_MODE_INIT}, 0, EVAL_MODE_NB-1, FLAGS, \"eval\" },",
          "81:          { \"init\",  \"eval expressions once during initialization\", 0, AV_OPT_TYPE_CONST, {.i64=EVAL_MODE_INIT},  .flags = FLAGS, .unit = \"eval\" },",
          "82:          { \"frame\", \"eval expressions for each frame\",             0, AV_OPT_TYPE_CONST, {.i64=EVAL_MODE_FRAME}, .flags = FLAGS, .unit = \"eval\" },",
          "83:     { \"dither\", \"set dithering\", OFFSET(do_dither), AV_OPT_TYPE_INT, {.i64 = 1}, 0, 1, FLAGS },",
          "84:     { NULL }",
          "85: };",
          "87: AVFILTER_DEFINE_CLASS(vignette);",
          "89: static av_cold int init(AVFilterContext *ctx)",
          "90: {",
          "91:     VignetteContext *s = ctx->priv;",
          "93: #define PARSE_EXPR(name) do {                                               \\",
          "94:     int ret = av_expr_parse(&s->name##_pexpr,  s->name##_expr, var_names,   \\",
          "95:                             NULL, NULL, NULL, NULL, 0, ctx);                \\",
          "96:     if (ret < 0) {                                                          \\",
          "97:         av_log(ctx, AV_LOG_ERROR, \"Unable to parse expression for '\"        \\",
          "98:                AV_STRINGIFY(name) \"'\\n\");                                   \\",
          "99:         return ret;                                                         \\",
          "100:     }                                                                       \\",
          "101: } while (0)",
          "103:     PARSE_EXPR(angle);",
          "104:     PARSE_EXPR(x0);",
          "105:     PARSE_EXPR(y0);",
          "106:     return 0;",
          "107: }",
          "109: static av_cold void uninit(AVFilterContext *ctx)",
          "110: {",
          "111:     VignetteContext *s = ctx->priv;",
          "112:     av_freep(&s->fmap);",
          "113:     av_expr_free(s->angle_pexpr);",
          "114:     av_expr_free(s->x0_pexpr);",
          "115:     av_expr_free(s->y0_pexpr);",
          "116: }",
          "118: static int query_formats(AVFilterContext *ctx)",
          "119: {",
          "120:     static const enum AVPixelFormat pix_fmts[] = {",
          "121:         AV_PIX_FMT_YUV444P, AV_PIX_FMT_YUV422P,",
          "122:         AV_PIX_FMT_YUV420P, AV_PIX_FMT_YUV411P,",
          "123:         AV_PIX_FMT_YUV410P, AV_PIX_FMT_YUV440P,",
          "124:         AV_PIX_FMT_RGB24,   AV_PIX_FMT_BGR24,",
          "125:         AV_PIX_FMT_GRAY8,",
          "126:         AV_PIX_FMT_NONE",
          "127:     };",
          "128:     ff_set_common_formats(ctx, ff_make_format_list(pix_fmts));",
          "129:     return 0;",
          "130: }",
          "132: static double get_natural_factor(const VignetteContext *s, int x, int y)",
          "133: {",
          "134:     const int xx = (x - s->x0) * s->xscale;",
          "135:     const int yy = (y - s->y0) * s->yscale;",
          "136:     const double dnorm = hypot(xx, yy) / s->dmax;",
          "137:     if (dnorm > 1) {",
          "138:         return 0;",
          "139:     } else {",
          "140:         const double c = cos(s->angle * dnorm);",
          "141:         return (c*c)*(c*c); // do not remove braces, it helps compilers",
          "142:     }",
          "143: }",
          "145: #define TS2D(ts)     ((ts) == AV_NOPTS_VALUE ? NAN : (double)(ts))",
          "146: #define TS2T(ts, tb) ((ts) == AV_NOPTS_VALUE ? NAN : (double)(ts) * av_q2d(tb))",
          "148: static void update_context(VignetteContext *s, AVFilterLink *inlink, AVFrame *frame)",
          "149: {",
          "150:     int x, y;",
          "151:     float *dst = s->fmap;",
          "152:     int dst_linesize = s->fmap_linesize;",
          "154:     if (frame) {",
          "155:         s->var_values[VAR_N]   = inlink->frame_count;",
          "156:         s->var_values[VAR_T]   = TS2T(frame->pts, inlink->time_base);",
          "157:         s->var_values[VAR_PTS] = TS2D(frame->pts);",
          "158:     } else {",
          "159:         s->var_values[VAR_N]   = 0;",
          "160:         s->var_values[VAR_T]   = NAN;",
          "161:         s->var_values[VAR_PTS] = NAN;",
          "162:     }",
          "164:     s->angle = av_clipf(av_expr_eval(s->angle_pexpr, s->var_values, NULL), 0, M_PI_2);",
          "165:     s->x0 = av_expr_eval(s->x0_pexpr, s->var_values, NULL);",
          "166:     s->y0 = av_expr_eval(s->y0_pexpr, s->var_values, NULL);",
          "168:     if (s->backward) {",
          "169:         for (y = 0; y < inlink->h; y++) {",
          "170:             for (x = 0; x < inlink->w; x++)",
          "171:                 dst[x] = 1. / get_natural_factor(s, x, y);",
          "172:             dst += dst_linesize;",
          "173:         }",
          "174:     } else {",
          "175:         for (y = 0; y < inlink->h; y++) {",
          "176:             for (x = 0; x < inlink->w; x++)",
          "177:                 dst[x] = get_natural_factor(s, x, y);",
          "178:             dst += dst_linesize;",
          "179:         }",
          "180:     }",
          "181: }",
          "183: static inline double get_dither_value(VignetteContext *s)",
          "184: {",
          "185:     double dv = 0;",
          "186:     if (s->do_dither) {",
          "187:         dv = s->dither / (double)(1LL<<32);",
          "188:         s->dither = s->dither * 1664525 + 1013904223;",
          "189:     }",
          "190:     return dv;",
          "191: }",
          "193: static int filter_frame(AVFilterLink *inlink, AVFrame *in)",
          "194: {",
          "195:     unsigned x, y;",
          "196:     AVFilterContext *ctx = inlink->dst;",
          "197:     VignetteContext *s = ctx->priv;",
          "198:     AVFilterLink *outlink = inlink->dst->outputs[0];",
          "199:     AVFrame *out;",
          "201:     out = ff_get_video_buffer(outlink, outlink->w, outlink->h);",
          "202:     if (!out) {",
          "203:         av_frame_free(&in);",
          "204:         return AVERROR(ENOMEM);",
          "205:     }",
          "206:     av_frame_copy_props(out, in);",
          "208:     if (s->eval_mode == EVAL_MODE_FRAME)",
          "209:         update_context(s, inlink, in);",
          "211:     if (s->desc->flags & PIX_FMT_RGB) {",
          "212:         uint8_t       *dst = out->data[0];",
          "213:         const uint8_t *src = in ->data[0];",
          "214:         const float *fmap = s->fmap;",
          "215:         const int dst_linesize = out->linesize[0];",
          "216:         const int src_linesize = in ->linesize[0];",
          "217:         const int fmap_linesize = s->fmap_linesize;",
          "219:         for (y = 0; y < inlink->h; y++) {",
          "220:             uint8_t       *dstp = dst;",
          "221:             const uint8_t *srcp = src;",
          "223:             for (x = 0; x < inlink->w; x++, dstp += 3, srcp += 3) {",
          "224:                 const float f = fmap[x];",
          "226:                 dstp[0] = av_clip_uint8(srcp[0] * f + get_dither_value(s));",
          "227:                 dstp[1] = av_clip_uint8(srcp[1] * f + get_dither_value(s));",
          "228:                 dstp[2] = av_clip_uint8(srcp[2] * f + get_dither_value(s));",
          "229:             }",
          "230:             dst += dst_linesize;",
          "231:             src += src_linesize;",
          "232:             fmap += fmap_linesize;",
          "233:         }",
          "234:     } else {",
          "235:         int plane;",
          "237:         for (plane = 0; plane < 4 && in->data[plane]; plane++) {",
          "238:             uint8_t       *dst = out->data[plane];",
          "239:             const uint8_t *src = in ->data[plane];",
          "240:             const float *fmap = s->fmap;",
          "241:             const int dst_linesize = out->linesize[plane];",
          "242:             const int src_linesize = in ->linesize[plane];",
          "243:             const int fmap_linesize = s->fmap_linesize;",
          "244:             const int chroma = plane == 1 || plane == 2;",
          "245:             const int hsub = chroma ? s->desc->log2_chroma_w : 0;",
          "246:             const int vsub = chroma ? s->desc->log2_chroma_h : 0;",
          "247:             const int w = FF_CEIL_RSHIFT(inlink->w, hsub);",
          "248:             const int h = FF_CEIL_RSHIFT(inlink->h, vsub);",
          "250:             for (y = 0; y < h; y++) {",
          "251:                 uint8_t *dstp = dst;",
          "252:                 const uint8_t *srcp = src;",
          "254:                 for (x = 0; x < w; x++) {",
          "255:                     const double dv = get_dither_value(s);",
          "256:                     if (chroma) *dstp++ = av_clip_uint8(fmap[x << hsub] * (*srcp++ - 127) + 127 + dv);",
          "257:                     else        *dstp++ = av_clip_uint8(fmap[x        ] *  *srcp++              + dv);",
          "258:                 }",
          "259:                 dst += dst_linesize;",
          "260:                 src += src_linesize;",
          "261:                 fmap += fmap_linesize << vsub;",
          "262:             }",
          "263:         }",
          "264:     }",
          "266:     return ff_filter_frame(outlink, out);",
          "267: }",
          "269: static int config_props(AVFilterLink *inlink)",
          "270: {",
          "271:     VignetteContext *s = inlink->dst->priv;",
          "273:     s->desc = av_pix_fmt_desc_get(inlink->format);",
          "274:     s->var_values[VAR_W]  = inlink->w;",
          "275:     s->var_values[VAR_H]  = inlink->h;",
          "276:     s->var_values[VAR_TB] = av_q2d(inlink->time_base);",
          "277:     s->var_values[VAR_R]  = inlink->frame_rate.num == 0 || inlink->frame_rate.den == 0 ?",
          "278:         NAN : av_q2d(inlink->frame_rate);",
          "280:     if (inlink->sample_aspect_ratio.num > inlink->sample_aspect_ratio.den) {",
          "281:         s->xscale = av_q2d(inlink->sample_aspect_ratio);",
          "282:         s->yscale = 1;",
          "283:         s->dmax = hypot(inlink->w / 2., s->yscale * inlink->h / 2.);",
          "284:     } else {",
          "285:         s->yscale = av_q2d(inlink->sample_aspect_ratio);",
          "286:         s->xscale = 1;",
          "287:         s->dmax = hypot(s->xscale * inlink->w / 2., inlink->h / 2.);",
          "288:     }",
          "290:     s->fmap_linesize = FFALIGN(inlink->w, 32);",
          "291:     s->fmap = av_malloc(s->fmap_linesize * inlink->h * sizeof(*s->fmap));",
          "292:     if (!s->fmap)",
          "293:         return AVERROR(ENOMEM);",
          "295:     if (s->eval_mode == EVAL_MODE_INIT)",
          "296:         update_context(s, inlink, NULL);",
          "298:     return 0;",
          "299: }",
          "301: static const AVFilterPad vignette_inputs[] = {",
          "302:     {",
          "303:         .name         = \"default\",",
          "304:         .type         = AVMEDIA_TYPE_VIDEO,",
          "305:         .filter_frame = filter_frame,",
          "306:         .config_props = config_props,",
          "307:     },",
          "308:     { NULL }",
          "309: };",
          "311: static const AVFilterPad vignette_outputs[] = {",
          "312:      {",
          "313:          .name = \"default\",",
          "314:          .type = AVMEDIA_TYPE_VIDEO,",
          "315:      },",
          "316:      { NULL }",
          "317: };",
          "319: AVFilter avfilter_vf_vignette = {",
          "320:     .name          = \"vignette\",",
          "321:     .description   = NULL_IF_CONFIG_SMALL(\"Make or reverse a vignette effect.\"),",
          "322:     .priv_size     = sizeof(VignetteContext),",
          "323:     .init          = init,",
          "324:     .uninit        = uninit,",
          "325:     .query_formats = query_formats,",
          "326:     .inputs        = vignette_inputs,",
          "327:     .outputs       = vignette_outputs,",
          "328:     .priv_class    = &vignette_class,",
          "329:     .flags         = AVFILTER_FLAG_SUPPORT_TIMELINE_GENERIC,",
          "330: };",
          "",
          "---------------"
        ]
      }
    }
  ]
}
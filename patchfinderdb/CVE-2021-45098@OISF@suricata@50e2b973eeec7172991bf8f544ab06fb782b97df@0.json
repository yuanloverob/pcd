{
  "cve_id": "CVE-2021-45098",
  "cve_desc": "An issue was discovered in Suricata before 6.0.4. It is possible to bypass/evade any HTTP-based signature by faking an RST TCP packet with random TCP options of the md5header from the client side. After the three-way handshake, it's possible to inject an RST ACK with a random TCP md5header option. Then, the client can send an HTTP GET request with a forbidden URL. The server will ignore the RST ACK and send the response HTTP packet for the client's request. These packets will not trigger a Suricata reject action.",
  "repo": "OISF/suricata",
  "patch_hash": "50e2b973eeec7172991bf8f544ab06fb782b97df",
  "patch_info": {
    "commit_hash": "50e2b973eeec7172991bf8f544ab06fb782b97df",
    "repo": "OISF/suricata",
    "commit_url": "https://github.com/OISF/suricata/commit/50e2b973eeec7172991bf8f544ab06fb782b97df",
    "files": [
      "src/decode-tcp.c",
      "src/decode-tcp.h",
      "src/stream-tcp.c"
    ],
    "message": "stream/tcp: handle RST with MD5 or AO header\n\nSpecial handling for RST packets if they have an TCP MD5 or AO header option.\nThe options hash can't be validated. The end host might be able to validate\nit, as it can have a key/password that was communicated out of band.\n\nThe sender could use this to move the TCP state to 'CLOSED', leading to\na desync of the TCP session.\n\nThis patch builds on top of\n843d0b7a10bb (\"stream: support RST getting lost/ignored\")\n\nIt flags the receiver as having received an RST and moves the TCP state\ninto the CLOSED state. It then reverts this if the sender continues to\nsend traffic. In this case it sets the following event:\n\n    stream-event:suspected_rst_inject;\n\nBug: #4710.",
    "before_after_code_files": [
      "src/decode-tcp.c||src/decode-tcp.c",
      "src/decode-tcp.h||src/decode-tcp.h",
      "src/stream-tcp.c||src/stream-tcp.c"
    ]
  },
  "patch_diff": {
    "src/decode-tcp.c||src/decode-tcp.c": [
      "File: src/decode-tcp.c -> src/decode-tcp.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "183:                         ENGINE_SET_EVENT(p,TCP_OPT_INVALID_LEN);",
      "184:                     }",
      "185:                     break;",
      "186:             }",
      "188:             pkt += olen;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "187:                 case TCP_OPT_MD5:",
      "188:                     SCLogDebug(\"MD5 option, len %u\", olen);",
      "189:                     if (olen != 18) {",
      "190:                         ENGINE_SET_INVALID_EVENT(p,TCP_OPT_INVALID_LEN);",
      "191:                     } else {",
      "193:                         p->tcpvars.md5_option_present = true;",
      "194:                     }",
      "195:                     break;",
      "197:                 case TCP_OPT_AO:",
      "198:                     SCLogDebug(\"AU option, len %u\", olen);",
      "199:                     if (olen < 4) {",
      "200:                         ENGINE_SET_INVALID_EVENT(p,TCP_OPT_INVALID_LEN);",
      "201:                     } else {",
      "203:                         p->tcpvars.ao_option_present = true;",
      "204:                     }",
      "205:                     break;",
      "",
      "---------------"
    ],
    "src/decode-tcp.h||src/decode-tcp.h": [
      "File: src/decode-tcp.h -> src/decode-tcp.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "153: typedef struct TCPVars_",
      "154: {",
      "156:     bool ts_set;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "158:     bool md5_option_present;",
      "159:     bool ao_option_present;",
      "",
      "---------------"
    ],
    "src/stream-tcp.c||src/stream-tcp.c": [
      "File: src/stream-tcp.c -> src/stream-tcp.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "4433:         if (ostream->flags & STREAMTCP_STREAM_FLAG_RST_RECV) {",
      "4434:             if (StreamTcpStateDispatch(tv, p, stt, ssn, &stt->pseudo_queue, ssn->pstate) < 0)",
      "4435:                 return -1;",
      "4436:         }",
      "4437:     }",
      "4438:     return 0;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "4437:             if (ssn->state == TCP_CLOSED)",
      "4438:                 ssn->state = ssn->pstate;",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "5448:         }",
      "5449:     }",
      "5451:     if (ssn->flags & STREAMTCP_FLAG_ASYNC) {",
      "5452:         if (PKT_IS_TOSERVER(p)) {",
      "5453:             if (SEQ_GEQ(TCP_GET_SEQ(p), ssn->client.next_seq)) {",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "5457:     if (p->tcpvars.md5_option_present || p->tcpvars.ao_option_present) {",
      "5458:         TcpStream *receiver_stream;",
      "5459:         if (PKT_IS_TOSERVER(p)) {",
      "5460:             receiver_stream = &ssn->server;",
      "5461:         } else {",
      "5462:             receiver_stream = &ssn->client;",
      "5463:         }",
      "5464:         SCLogDebug(\"ssn %p: setting STREAMTCP_STREAM_FLAG_RST_RECV on receiver stream\", ssn);",
      "5465:         receiver_stream->flags |= STREAMTCP_STREAM_FLAG_RST_RECV;",
      "5466:     }",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "f0dda61732fd75433e9372265993d477687e269d",
      "candidate_info": {
        "commit_hash": "f0dda61732fd75433e9372265993d477687e269d",
        "repo": "OISF/suricata",
        "commit_url": "https://github.com/OISF/suricata/commit/f0dda61732fd75433e9372265993d477687e269d",
        "files": [
          "src/decode-tcp.c",
          "src/decode-tcp.h",
          "src/stream-tcp.c"
        ],
        "message": "stream/tcp: handle RST with MD5 or AO header\n\nSpecial handling for RST packets if they have an TCP MD5 or AO header option.\nThe options hash can't be validated. The end host might be able to validate\nit, as it can have a key/password that was communicated out of band.\n\nThe sender could use this to move the TCP state to 'CLOSED', leading to\na desync of the TCP session.\n\nThis patch builds on top of\n843d0b7a10bb (\"stream: support RST getting lost/ignored\")\n\nIt flags the receiver as having received an RST and moves the TCP state\ninto the CLOSED state. It then reverts this if the sender continues to\nsend traffic. In this case it sets the following event:\n\n    stream-event:suspected_rst_inject;\n\nBug: #4710.\n(cherry picked from commit 50e2b973eeec7172991bf8f544ab06fb782b97df)",
        "before_after_code_files": [
          "src/decode-tcp.c||src/decode-tcp.c",
          "src/decode-tcp.h||src/decode-tcp.h",
          "src/stream-tcp.c||src/stream-tcp.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_cherry_pick": 1,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "src/decode-tcp.c||src/decode-tcp.c",
            "src/decode-tcp.h||src/decode-tcp.h",
            "src/stream-tcp.c||src/stream-tcp.c"
          ],
          "candidate": [
            "src/decode-tcp.c||src/decode-tcp.c",
            "src/decode-tcp.h||src/decode-tcp.h",
            "src/stream-tcp.c||src/stream-tcp.c"
          ]
        }
      },
      "candidate_diff": {
        "src/decode-tcp.c||src/decode-tcp.c": [
          "File: src/decode-tcp.c -> src/decode-tcp.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "183:                         ENGINE_SET_EVENT(p,TCP_OPT_INVALID_LEN);",
          "184:                     }",
          "185:                     break;",
          "186:             }",
          "188:             pkt += olen;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "187:                 case TCP_OPT_MD5:",
          "188:                     SCLogDebug(\"MD5 option, len %u\", olen);",
          "189:                     if (olen != 18) {",
          "190:                         ENGINE_SET_INVALID_EVENT(p,TCP_OPT_INVALID_LEN);",
          "191:                     } else {",
          "193:                         p->tcpvars.md5_option_present = true;",
          "194:                     }",
          "195:                     break;",
          "197:                 case TCP_OPT_AO:",
          "198:                     SCLogDebug(\"AU option, len %u\", olen);",
          "199:                     if (olen < 4) {",
          "200:                         ENGINE_SET_INVALID_EVENT(p,TCP_OPT_INVALID_LEN);",
          "201:                     } else {",
          "203:                         p->tcpvars.ao_option_present = true;",
          "204:                     }",
          "205:                     break;",
          "",
          "---------------"
        ],
        "src/decode-tcp.h||src/decode-tcp.h": [
          "File: src/decode-tcp.h -> src/decode-tcp.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "153: typedef struct TCPVars_",
          "154: {",
          "156:     _Bool ts_set;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "158:     bool md5_option_present;",
          "159:     bool ao_option_present;",
          "",
          "---------------"
        ],
        "src/stream-tcp.c||src/stream-tcp.c": [
          "File: src/stream-tcp.c -> src/stream-tcp.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "4378:         if (ostream->flags & STREAMTCP_STREAM_FLAG_RST_RECV) {",
          "4379:             if (StreamTcpStateDispatch(tv, p, stt, ssn, &stt->pseudo_queue, ssn->pstate) < 0)",
          "4380:                 return -1;",
          "4381:         }",
          "4382:     }",
          "4383:     return 0;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4382:             if (ssn->state == TCP_CLOSED)",
          "4383:                 ssn->state = ssn->pstate;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "5388:         }",
          "5389:     }",
          "5391:     if (ssn->flags & STREAMTCP_FLAG_ASYNC) {",
          "5392:         if (PKT_IS_TOSERVER(p)) {",
          "5393:             if (SEQ_GEQ(TCP_GET_SEQ(p), ssn->client.next_seq)) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "5397:     if (p->tcpvars.md5_option_present || p->tcpvars.ao_option_present) {",
          "5398:         TcpStream *receiver_stream;",
          "5399:         if (PKT_IS_TOSERVER(p)) {",
          "5400:             receiver_stream = &ssn->server;",
          "5401:         } else {",
          "5402:             receiver_stream = &ssn->client;",
          "5403:         }",
          "5404:         SCLogDebug(\"ssn %p: setting STREAMTCP_STREAM_FLAG_RST_RECV on receiver stream\", ssn);",
          "5405:         receiver_stream->flags |= STREAMTCP_STREAM_FLAG_RST_RECV;",
          "5406:     }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "77872904545fec56dcbece2e239ddf9e3c321eeb",
      "candidate_info": {
        "commit_hash": "77872904545fec56dcbece2e239ddf9e3c321eeb",
        "repo": "OISF/suricata",
        "commit_url": "https://github.com/OISF/suricata/commit/77872904545fec56dcbece2e239ddf9e3c321eeb",
        "files": [
          "src/decode-tcp.c",
          "src/decode-tcp.h",
          "src/stream-tcp.c"
        ],
        "message": "stream/tcp: handle RST with MD5 or AO header\n\nSpecial handling for RST packets if they have an TCP MD5 or AO header option.\nThe options hash can't be validated. The end host might be able to validate\nit, as it can have a key/password that was communicated out of band.\n\nThe sender could use this to move the TCP state to 'CLOSED', leading to\na desync of the TCP session.\n\nThis patch builds on top of\n843d0b7a10bb (\"stream: support RST getting lost/ignored\")\n\nIt flags the receiver as having received an RST and moves the TCP state\ninto the CLOSED state. It then reverts this if the sender continues to\nsend traffic. In this case it sets the following event:\n\n    stream-event:suspected_rst_inject;\n\nBug: #4710.\n(cherry picked from commit 50e2b973eeec7172991bf8f544ab06fb782b97df)",
        "before_after_code_files": [
          "src/decode-tcp.c||src/decode-tcp.c",
          "src/decode-tcp.h||src/decode-tcp.h",
          "src/stream-tcp.c||src/stream-tcp.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_cherry_pick": 1,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "src/decode-tcp.c||src/decode-tcp.c",
            "src/decode-tcp.h||src/decode-tcp.h",
            "src/stream-tcp.c||src/stream-tcp.c"
          ],
          "candidate": [
            "src/decode-tcp.c||src/decode-tcp.c",
            "src/decode-tcp.h||src/decode-tcp.h",
            "src/stream-tcp.c||src/stream-tcp.c"
          ]
        }
      },
      "candidate_diff": {
        "src/decode-tcp.c||src/decode-tcp.c": [
          "File: src/decode-tcp.c -> src/decode-tcp.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "183:                         ENGINE_SET_EVENT(p,TCP_OPT_INVALID_LEN);",
          "184:                     }",
          "185:                     break;",
          "186:             }",
          "188:             pkt += olen;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "187:                 case TCP_OPT_MD5:",
          "188:                     SCLogDebug(\"MD5 option, len %u\", olen);",
          "189:                     if (olen != 18) {",
          "190:                         ENGINE_SET_INVALID_EVENT(p,TCP_OPT_INVALID_LEN);",
          "191:                     } else {",
          "193:                         p->tcpvars.md5_option_present = true;",
          "194:                     }",
          "195:                     break;",
          "197:                 case TCP_OPT_AO:",
          "198:                     SCLogDebug(\"AU option, len %u\", olen);",
          "199:                     if (olen < 4) {",
          "200:                         ENGINE_SET_INVALID_EVENT(p,TCP_OPT_INVALID_LEN);",
          "201:                     } else {",
          "203:                         p->tcpvars.ao_option_present = true;",
          "204:                     }",
          "205:                     break;",
          "",
          "---------------"
        ],
        "src/decode-tcp.h||src/decode-tcp.h": [
          "File: src/decode-tcp.h -> src/decode-tcp.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "153: typedef struct TCPVars_",
          "154: {",
          "156:     bool ts_set;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "158:     bool md5_option_present;",
          "159:     bool ao_option_present;",
          "",
          "---------------"
        ],
        "src/stream-tcp.c||src/stream-tcp.c": [
          "File: src/stream-tcp.c -> src/stream-tcp.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "4362:         if (ostream->flags & STREAMTCP_STREAM_FLAG_RST_RECV) {",
          "4363:             if (StreamTcpStateDispatch(tv, p, stt, ssn, &stt->pseudo_queue, ssn->pstate) < 0)",
          "4364:                 return -1;",
          "4365:         }",
          "4366:     }",
          "4367:     return 0;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4366:             if (ssn->state == TCP_CLOSED)",
          "4367:                 ssn->state = ssn->pstate;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "5370:         }",
          "5371:     }",
          "5373:     if (ssn->flags & STREAMTCP_FLAG_ASYNC) {",
          "5374:         if (PKT_IS_TOSERVER(p)) {",
          "5375:             if (SEQ_GEQ(TCP_GET_SEQ(p), ssn->client.next_seq)) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "5379:     if (p->tcpvars.md5_option_present || p->tcpvars.ao_option_present) {",
          "5380:         TcpStream *receiver_stream;",
          "5381:         if (PKT_IS_TOSERVER(p)) {",
          "5382:             receiver_stream = &ssn->server;",
          "5383:         } else {",
          "5384:             receiver_stream = &ssn->client;",
          "5385:         }",
          "5386:         SCLogDebug(\"ssn %p: setting STREAMTCP_STREAM_FLAG_RST_RECV on receiver stream\", ssn);",
          "5387:         receiver_stream->flags |= STREAMTCP_STREAM_FLAG_RST_RECV;",
          "5388:     }",
          "",
          "---------------"
        ]
      }
    }
  ]
}